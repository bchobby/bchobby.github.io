<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6583b9b9ca3f36ea9a165da42c310b84/" rel="bookmark">
			Spring Boot整合Spring Security并设置自定义登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作，创建一个Spring Boot项目，注意选择Spring Boot的版本，选择3.0以下的版本。
选择如下依赖,等待项目创建成功。
项目创建成功之后，添加Mybatis-plus的依赖。
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt; &lt;/dependency&gt; 上篇文章没有带大家查询数据库，这次我们就去查一下，并且使用ide自带的MybatisX的插件去逆向生成我们的的实体类和mapper文件。
创建数据库text，创建表、字段.
CREATE DATABASE `text`; USE `text`; DROP TABLE IF EXISTS `t_user`; CREATE TABLE `t_user` ( `t_id` int(4) NOT NULL AUTO_INCREMENT, `t_name` varchar(20) DEFAULT NULL, `t_password` varchar(60) DEFAULT NULL, `t_authority` varchar(60) DEFAULT NULL, PRIMARY KEY (`t_id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; insert into `t_user`(`t_id`,`t_name`,`t_password`,`t_authority`) values (1,'yjd','123','1'),(2,'zhansan','123','0'); MybatisX的使用大家可以看一下我的另外一篇文章。这里不再赘述了。
逆向生成实体类之后，我们先配置数据源。
server: port: 8081 spring: datasource: url: jdbc:mysql://localhost:3306/text?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai username: root password: ****** mybatis-plus: # 配置mybatis-plus mapper-locations: mapper/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6583b9b9ca3f36ea9a165da42c310b84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97904b297e53e67f5ee93b0785bcd8dc/" rel="bookmark">
			python实现十以内加减乘数运算自测小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非常适合python初学者(掌握基础语法)的一道练手题୧꒰•̀ᴗ•́꒱୨ 编写自测小程序，程序随机生成10道加减乘除运算（运算种类随机，参与运算操作数为随机[1-10]之间的正整数），程序给出一道随机生成的题目，程序使用者来给出答案，当使用者10道题都打完之后，统一将十道题及使用者给出答案进行打印，并在每道题后面给出使用者当前题目的对错情况，如果打错还需另给出正确答案，在最后给出使用者本次测试的总得分（每题10分，总分100分）。
说明：
1、示例中蓝色部分为用户输入部分，黑色部分为程序输出部分，只是为了帮助大家区分哪部分是需要使用者输入的，程序运行时无序进行颜色设置。
2、除法结果小数点后保留两位有效数字。
3、本程序题目生成可通过随机数来完成。
程序运行示例：
代码实现:
import random x1=[] x2=[] x3=[] x4=[] x5=[] #上面列表用来存测试的试题和你输入的结果,还有正确答案,方便后续每题答案的判断对错,即最后成绩的给出 cj=0 print("欢迎使用算术自测程序，测试开始：") for i in range(0,10): a=random.randint(1,10) #随机产生指定范围内的整数 b=random.randint(1,10) c=random.choice(["+","-","*","/"]) print("第%d题；%d%s%d= " %(i+1,a,c,b),end="") if c=="+": qes=int(input()) res=a+b if c=="-": qes=int(input()) res=a-b if c=="*": qes=int(input()) res=a*b if c=="/": qes=float(input()) res=a/b x1.append(a) x2.append(b) x3.append(c) x4.append(qes) x5.append(round(res, 2)) #题目要求除法保留两位小数(round不对整数处理) print("答题完毕，您的答题结果为：") for i in range(0,10): if x3[i]=="+": if x4[i]==x5[i]: print("第%d题：%d+%d=%d" %(i+1,x1[i],x2[i],x4[i]),end="") print(" √") cj+=10 else: print("第%d题：%d+%d=%d" %(i + 1, x1[i], x2[i], x4[i]), end="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97904b297e53e67f5ee93b0785bcd8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49bc061b8bf92b9b7f5a0e558b674a7b/" rel="bookmark">
			vscode中怎样让python代码对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VSCode中让Python代码对齐有多种方法：
手动对齐：选中要对齐的代码行，按下“Tab”键或“Shift+Tab”键，可以向右或向左缩进，实现对齐。
自动对齐：在VSCode中，可以通过安装Python插件来实现自动对齐。安装完插件后，在编辑Python文件时，按下“Shift+Alt+F”快捷键，可以对整个文件进行自动对齐。
设置缩进：在VSCode中，可以通过设置缩进来实现代码对齐。打开“文件”菜单中的“首选项”选项，选择“设置”菜单，在搜索框中输入“python.indentation”，可以找到Python代码缩进相关的设置，可以根据自己的习惯设置缩进大
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684013f990368c095f4b35af4c5d5dd0/" rel="bookmark">
			在Linux和Windows上安装kafka(版本:2.12-2.8.0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：379
场景：在CentOS 7.9操作系统上，安装kafka_2.12-2.8.0。在Windows上操作系统上，安装kafka_2.12-2.8.0。
版本：
JDK 1.8 CentOS 7.9 zookeeper-3.5.9 kafka_2.12-2.8.0 一、在Linux上安装kafka
安装虚拟机：B203
虚拟机IP：192.168.19.203
1.下载kafka
版本：kafka_2.12-2.8.0。
下载命令：wget https://archive.apache.org/dist/kafka/2.8.0/kafka_2.12-2.8.0.tgz
下载包：kafka_2.12-2.8.0.tgz
2.解压kafka
解压到目录：/opt/zk
解压命令：tar -zxvf kafka_2.12-2.8.0.tgz -C /opt/kafka/
解析：在kafka_2.12-2.8.0目录下，包括bin、config、libs、site-docs、licenses目录。在bin目录下存放脚本。config目录下存放配置文件。site-docs目录下存放kafka的文档。在lib目录下存放kafka运行包以及全量依赖包。licenses目录下存放许可文件。
3.配置kafka
操作目录：/opt/kafka/kafka_2.12-2.8.0/config
修改文件：server.properties
修改内容：
# 配置日志目录 log.dirs=/opt/kafka/kafka-logs-2.8.0 # 配置Kafka端口 port=29001 # 配置连接zookeeper zookeeper.connect=192.168.19.203:12181 4.启动kafka
4.1启动zookeeper
操作目录：/opt/zk/zookeeper-3.5.9/bin
命令：sh zkServer.sh start
在Linux上安装zookeeper，请参考博文。
地址：https://blog.csdn.net/zhangbeizhen18/article/details/129071097
4.2启动kafka
操作目录：/opt/kafka/kafka_2.12-2.8.0/bin
启动命令1：./kafka-server-start.sh ../config/server.properties
启动命令2：nohup ./kafka-server-start.sh ../config/server.properties &gt;/dev/null 2&gt;&amp;1 &amp;
解析：启动命令1，直接在控制台打印信息。启动命令2，后台启动。
4.3关闭kafka
Pid=$(jps -lm | grep -i 'kafka.Kafka'| awk '{print $1}') kill -s KILL $Pid 解析：直接使用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684013f990368c095f4b35af4c5d5dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a156ec3e4134209e90aaff80c1112951/" rel="bookmark">
			【Spring】@Value注入配置文件 application.yml 中的值失败怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期目录 一、 问题背景二、 问题原因三、 解决方法 一、 问题背景 今天碰到的问题是用 @Value 注解无法注入配置文件 application.yml 中的配置值。
检查过该类已经交给 Spring 容器管理了，即已经在类上加了 @Configuration 和 @ConfigurationProperties(prefix = "xxx") 注解了。但还是注入失败。
下面是配置文件 application.yml 中要注入的配置值：
student: name: Tom age: 21 问题伪代码如下：
@Configuration @ConfigurationProperties(prefix = "student") public class StudentConfig { @Value("${student.name}") private String name; @Value("${student.age}") private int age; private Map&lt;Long, Student&gt; stuMap = new HashMap&lt;&gt;(); // 使用空参构造器初始化stuMap public StudentConfig() { stuMap.put(1001L, new Student(name, age)); } } 看起来没有问题，但当我获取 stuMap 中的 Student 对象时，却发现其两个属性 name 为 null 、age = 0 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a156ec3e4134209e90aaff80c1112951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db96cab397ee3b2a9f8c3b0e171d4973/" rel="bookmark">
			Python和pycharm先安装谁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建议先安装Python，因为PyCharm是一个Python的集成开发环境(IDE)，需要使用Python的解释器来运行和调试代码。安装Python后，您可以在PyCharm中设置Python解释器，然后开始编写和运行Python代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290dd4a996c8770fe5781551158add73/" rel="bookmark">
			使用 whistle 在 macOS 上进行抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先确保 node.js 已经安装，没有安装的在 https://nodejs.org/en/ 下载安装使用 node.js 全局安装 whistle （仅第一次需要） $ npm i -g whistle whistle 安装 ca 证书 (仅第一次需要) $ w2 ca whistle 自动设置代理 (每次都需要) whistle proxy whistle 启动 w2 start 开始抓包
访问这个地址
进入 Network 栏目
记得打开 http/2
即可查看当前设备的所有请求
whsitle 停止
whistle stop whistle 关闭代理(不关闭无法正常使用网络) w2 proxy --off 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e70572077dc85c16a994280e51ec0c/" rel="bookmark">
			C# 进阶教程（一） 委托
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 委托 1.1 委托简介 委托是C#语言中的一种高级语法，其作为一种与类同级的对象，定义在命名空间内。
//委托的定义 namespace TestNameSpace { public delegate void testDelegate (string text); public class TestClass { static void Main(string[] args) { Console.WriteLine("Hello World!"); } } } 委托是一个对象，它知道该如何调用方法，作为一个引用类型，和类是同级的，委托实例 把方法赋值给委托变量时调用者调用委托，委托调用目标方法。
1.2 委托是一种方法模板 和面向对象中的类的概念相似，我们都知道类作为一个对象的模板，各种对象都可以被描述为一个类或者继承于某个类的子类。
而委托也是一种模板，它是函数/方法的模板，如上面所看到的委托 testDelegate ，其就是一类方法的模板，其代表的是输入类型为 string ，返回类型为 void 的一类函数。其实例化的过程需要接收该类型的函数。如下方示例所示：
using System; namespace TestNameSpace { public delegate void testDelegate(string text); public class TestClass { static void Main(string[] args) { MethodClass methodClass = new MethodClass();//实例化类 用于引用类中存在的方法 testDelegate testDelegate_1 = new testDelegate( methodClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3e70572077dc85c16a994280e51ec0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8967aae34a76086fcb25c28c274d6a80/" rel="bookmark">
			WebRTC QoS方法一（NACK实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 与NACK对应的是ACK，ACK是到达通知技术。以TCP为例，他可靠因为接收方在收到数据后会给发送方返回一个“已收到数据”的消息（ACK），告诉发送方“我已经收到了”，确保消息的可靠。
NACK也是一种通知技术，只是触发通知的条件刚好的ACK相反，在未收到消息时，通知发送方“我未收到消息”，即通知未达。
在rfc4585协议中定义可重传未到达数据的类型有二种：
1）RTPFB：rtp报文丢失重传。
2）PSFB：指定净荷重传，指定净荷重传里面又分如下三种：
1、PLI (Picture Loss Indication) 视频帧丢失重传。
2、SLI (Slice Loss Indication) slice丢失重转。
3、RPSI (Reference Picture Selection Indication)参考帧丢失重传。
在创建视频连接的SDP协议里面，会协商以上述哪种类型进行NACK重转。以webrtc为例，会协商两种NACK，一个rtp报文丢包重传的nack（nack后面不带参数，默认RTPFB）、PLI 视频帧丢失重传的nack。
二、定义 V： 2bit 目前固定为2
P： 1bit padding
FMT：5bit Feedback message type。 RTP FP模式下定义值为：
0:unassigned
1:Generic NACK
2-30:unassigned
31:reserved for future expansion of the identifier number space
PS FP模式下定义值为：
0: unassigned
1: Picture Loss Indication (PLI)
2: Slice Loss Indication (SLI)
3: Reference Picture Selection Indication (RPSI)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8967aae34a76086fcb25c28c274d6a80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f759e9e40ce9968894f5e885484128d0/" rel="bookmark">
			本地搭建NC环境，实现代码开发工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地搭建NC环境，实现代码开发工作 1、下载eclipse和NC5.7，配置好jdk路径32位 2、拉取nc项目代码 3、配置环境 4、启动服务端和客户端 5、开发接口服务 5.1 新建测试接口和对应的实现类 5.2 编写upm文件 &lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;module name="xljt"&gt; &lt;public&gt; &lt;component remote="true" singleton="true" tx="CMT"&gt; &lt;interface&gt;nc.itf.webapi.Test&lt;/interface&gt; &lt;implementation&gt;nc.impl.xljt.TestServiceImpl&lt;/implementation&gt; &lt;extension class="nc.uap.ws.deploy.OxbWSExtensionProcessor"&gt; &lt;wsdl&gt;/nc/itf/webapi/Test.wsdl&lt;/wsdl&gt; &lt;address&gt;/nc.itf.webapi.Test&lt;/address&gt; &lt;/extension&gt; &lt;/component&gt; &lt;/public&gt; &lt;/module&gt; 5.2 生成wsdl文件 5.3 public web services 、
6、部署接口服务 6.1 导出补丁，把接口代码放到nchome里面 6.2 把导出的nc压缩包的modules文件夹放到nc的根目录下，替换原先的modules文件夹 6.3 执行%nchome%\bin\ncSysConfig.bat 6.4 点击部署EJB, 等待部署完成 注意：需要先关闭eclipse，不然部署会失败
7、使用SOAP UI 工具测试接口 7.1启动中间件后, 访问localhost/uapws/service 7.2 找到测试的接口, 然后复制接口地址 7.3 使用webservice接口测试工具SOAP UI ,进行测试 8、在项目中测试接口-使用wsimport命令 8.1 使用wsimport命令生成的本地java代码 http://localhost/uapws/service/nc.itf.webapi.Test?wsdl
8.2 把生成的代码移动到项目中 8.3 测试接口 @RequestMapping("/test2") public String test2() { Test_Service test_service = new Test_Service(); String result = test_service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f759e9e40ce9968894f5e885484128d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534bf0f7fb777f839970b64ce0e5974b/" rel="bookmark">
			西门子S7-200 SMART PLC模拟量模块常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		西门子S7-200 SMART PLC模拟量模块常见问题
1、S7-200 SMART 普通模拟量模块可以连接4-20mA的信号吗？
可以，S7-200 SMART CPU模拟量模块可以检测0～20mA和4～20mA的标准电流信号；两种电流信号的接线、在STEP 7-Micro/WIN SMART软件中的参数设置都是一样的。区别在于：0～20mA对应的通道值量程是0～27648，而4～20mA对应的通道值量程是5530～27648。
2、S7-200 SMART RTD模块可以测量电阻值吗？
可以，S7-200 SMART RTD模块最大可以测量3000Ω的电阻值。如下图所示，在“类型”下拉菜单中选择电阻类型；在“电阻”下拉菜单中中选择可测量电阻的最大值。
3、S7-200 SMART RTD和TC模块如何得到实际温度值？
把S7-200 SMART EM RTD和TC模块的通道值除以10就是实际的温度值。由于RTD和TC模块的通道值是整数值，需要把整数值转换成浮点数才能在计算后得到带有小数位的温度值。
4、模拟量模块分辨率和转换精度的区别？
分辨率是A/D模拟量转换芯片的转换精度，即用多少位的数值来表示模拟量。以下举例说明10位分辨率和11位分辨率的区别。S7-200 SMART CPU模拟量0~20mA的通道值范围为0~27648。如果分辨率为10位，则表示当外部电流信号的变化大于0.01953125mA时，模拟量A/D转换芯片才认为外部信号有变化。如果分辨率为11位，则表示当外部电流信号的变化大于0.009765625mA时，模拟量A/D转换芯片即认为外部信号有变化。模拟量转换的精度除了取决于A/D转换的分辨率，还受到转换芯片的外围电路的影响。在实际应用中，输入的模拟量信号会有波动、噪声和干扰，内部模拟电路也会产生噪声、漂移，这些都会对转换的最后精度造成影响。这些因素造成的误差要大于A/D芯片的转换误差。
5、S7-200 SMART I/O扩展模块DIAG指示灯以红色闪烁的原因？
S7-200 SMART I/O扩展模块的DIAG指示灯以红色闪烁的原因有两个，建议查看CPU的信息来确认具体报错原因，查看CPU信息的方法请见硬件诊断或诊断方法举例。
（1） 模块缺少24V直流供电电源；I/O扩展模块缺少24V直流供电电源时，所有通道指示灯也以红色闪烁。建议核对模块接线图，尤其是模块供电端含两排端子的，确定供电接线是否正确。
（2）、模拟量模块上通道断线或是输入值超量程。 模拟量模块上通道断线或是输入值超量程，除了会引起模块的DIAG指示灯以红色闪烁，断线或是超量程的通道的指示灯也以红色闪烁，以提示用户存在故障通道。
以RTD或TC模块为例，如果RTD或TC模块选择了断线报警。则模块会检测每个通道的断线情况。默认情况下，该选项是没有被激活的。RTD或TC模块对于没有使用的通道的处理方法如下：
①、RTD模块：将一个100Ohm的电阻按照与已用通道相同的接线方式连接到空的通道；或者将已经接好的那一路热电阻的所有引线，一一对应连接到空的通道上。
②、TC模块：短接未使用的通道，或者并联到旁边的实际接线通道上。启动断线报警如果不是通道断线引起的报警，就是输入值超量程了。默认情况下，RTD和TC模块的通道输入值超上下限报警是激活的。发生了该报警，用户需要判断引起通道值超量程的原因：是信号问题还是模块硬件的问题。
6. 为什么使用S7-200 SMART模拟量输入模块时接收到变动很大的不稳定的值？
可能的原因如下：
1）可能模拟量输入模块和现场传感器分别使用了自供电或隔离的电源，而两个电源没有彼此连接，即模拟量输入模块的电源和现场传感器的信号地没有连接；这将会产生一个很高的上下振动的共模电压，影响模拟量输入值。
2）另一个原因可能是模拟量输入模块接线太长或绝缘不好受到电磁干扰。
可以用如下方法解决：
A .连接现场传感器的负端与模块上的公共M端以补偿此波动。
背景是：
模拟量输入模块内部是非隔离的；
共模电压必须小于12V且大于-12V；
对于60Hz干扰信号的共模抑制比为40dB；
注意：模块中未使用的通道直接短接本通道的+、-，已使用的通道将传感器的负端与模块上的公共M端短接 。
B、使用模拟量输入滤波；选择需要滤波的通道；选择滤波强度；
模拟量输入值的滤波过程会产生稳定的模拟信号，通常过滤对于在处理变化缓慢的信号时非常有用，例如温度测量。可以为滤波分为4个级别(无、弱、中、强)。可组态模块在组态的周期数内平滑模拟量输入信号，从而将一个平均值传送给程序逻辑，滤波级别越高，经滤波处理的模拟值就越稳定，但无法反应快速变化的实际信号。
S7-200 SMART模拟量输入模块接收到测量值波动时的检测方法和步骤；
当 S7-200 SMART模拟量输入模块接收到测量值波动时，可通过如下图的步骤进行检查：
注意：
A、上图中所提到的等电位连接以及不用通道短接请参考上面6解决方法。
B、屏蔽层单端接地：是在屏蔽电缆的一端将金属屏蔽层直接接地，另一端不接地或通过保护接地。
在屏蔽层单端接地情况下，非接地端的金属屏蔽层对地之间有感应电压存在，感应电压与电缆的长度成正比，但屏蔽层无电势环流通过。单端接地就是利用抑制电势电位差达到消除电磁干扰的目的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224ef2de28a2cb4777c1d452dc22cd6f/" rel="bookmark">
			将引入antd组件默认语言改为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们使用antd时会发现上面的语言为英文，那么如何改为中文呢？
只需要如下操作就可以了：
import { ConfigProvider } from 'antd';
import zhCN from "antd/es/locale/zh_CN";
&lt;ConfigProvider locale={zhCN}&gt;
&lt;/ConfigProvider&gt;
这时，我们引入的组件默认语言就变为中文了，但是，日期选择框组件可能有部分位置还是英文状态，这是我们只需要进行如下操作就可以：
import dayjs from 'dayjs';
import 'dayjs/locale/zh-cn';
dayjs.locale('zh-cn');
需要注意检查你本地的 dayjs 版本和 antd 依赖的 dayjs 版本是否一致
如果还有问题，请检查是否有两个版本的 dayjs 共存？
npm ls dayjs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e89a2626c12cad2db132095ea40115/" rel="bookmark">
			二、Gstreamer splitmuxsink
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该元素包装muxer和sink，并在mux内容即将跨越最大尺寸的最大时间阈值时启动一个新文件，在视频关键帧边界分割。只有一个输入视频流可以与任意多的音频和字幕流混接。
默认情况下，它使用mp4mux和filesink，但可以通过muxer和sink属性更改它们。
最小文件大小是1 GOP，但是，如果任意两个关键帧之间的距离大于限制，则限制可能会超过。
如果视频流可用，则分割过程由视频流内容驱动，视频流必须包含关闭的GOPs，以便输出文件的部分能够正确地单独播放。在没有视频流的情况下，第一个可用的流用作同步的参考。
在async-finalize模式下，当超过阈值时，旧的muxer和sink从管道断开连接，然后离开以异步方式完成文件，并创建一个新的muxer和sink来继续处理下一个片段。因此，使用muxer-factory和sink-factory属性以及muxer-properties和sink-properties来构造新对象，而不是使用muxer和sink对象。
Example pipelines 从测试源捕获的视频流，并将其融合到ISO mp4文件中，根据需要分割以限制大小/持续时间为10秒和1MB的最大大小。
gst-launch-1.0 -e videotestsrc ! video/x-raw,width=320,height=240 ! videoconvert ! queue ! timeoverlay ! x264enc key-int-max=10 ! h264parse ! splitmuxsink location=video%02d.mov max-size-time=10000000000 max-size-bytes=1000000
记录从v4l2设备捕获的视频流，并将其绑定到可流的Matroska文件中，根据需要分割以限制大小/持续时间为10秒。每个文件都将异步完成。
gst-launch-1.0 -e v4l2src num-buffers=500 ! video/x-raw,width=320,height=240 ! videoconvert ! queue ! timeoverlay ! x264enc key-int-max=10 ! h264parse ! splitmuxsink location=video%02d.mkv max-size-time=10000000000 muxer-factory=matroskamux muxer-properties=“properties,streamable=true”
记录10帧到mp4文件，使用muxer-pad-map在splitmuxsink sink pad和它将交付到的相应muxer pad之间进行显式映射。
gst-launch-1.0 videotestsrc num-buffers=10 ! jpegenc ! .video splitmuxsink muxer=qtmux muxer-pad-map=x-pad-map,video=video_1 location=test%05d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e89a2626c12cad2db132095ea40115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d12640095abfd75fcdfcaec5499913d/" rel="bookmark">
			什么是分类、聚类，两者的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分类和聚类都是数据挖掘领域中的常用技术，用于在数据集中识别模式和结构。虽然这两个术语经常被混淆，但它们代表不同的概念。
分类是一种有监督学习技术，它的目的是将数据集中的每个样本分配到预定义的类别中。分类算法依靠已知的标签或类别来训练模型，并在训练后将新数据分配到它们所属的类别中。例如，一个电子邮件垃圾邮件过滤器可以根据电子邮件的内容、附件和其他特征将电子邮件分类为“垃圾邮件”或“非垃圾邮件”。
聚类是一种无监督学习技术，它的目的是根据数据之间的相似性将数据集中的样本分组成簇。聚类算法不需要预先定义类别或标签，而是通过计算样本之间的相似性来识别相似的样本，并将它们分配到相同的簇中。聚类算法可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0caa1f96eb288f20f7f74582176609d7/" rel="bookmark">
			【计算机网络】HTTPS协议原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、认识HTTPS协议二、为什么要发明HTTPS三、HTTP与HTTPS的区别四、常见的加密方式1. 对称加密2. 非对称加密3. 数据摘要4. 数字签名 五、HTTPS的原理探究方案1：只使用对称加密方案2：只使用非对称加密方案3：双方都使用非对称加密方案4：非对称加密 + 对称加密引入证书方案5：非对称加密 + 对称加密 + 证书认证 总结 一、认识HTTPS协议 HTTPS背景：
HTTPS是由网景公司（Netscape）于1994年发明的。在当时，网络刚刚兴起，人们开始使用互联网进行各种通信和交易，但是网络安全问题也随之成为人们关注的焦点。网景公司的工程师们在HTTP协议的基础上开发了SSL（Secure Sockets Layer）协议，通过在传输层对数据进行加密，从而保障网络传输的安全性。
后来，SSL协议逐渐得到了广泛的应用和推广，并在1999年被标准化为TLS（Transport Layer Security）协议。TLS协议是SSL的升级版，具有更高的安全性和可扩展性，被广泛应用于Web浏览器和Web服务器之间的数据传输，以确保网络通信的安全和隐私。
尽管网景公司在1998年被AOL收购，但HTTPS协议仍然被广泛应用于现代互联网中，成为了保护网络通信安全的标准协议。
HTTPS协议：
HTTPS是一种用于保护互联网通信安全的协议，全称为超文本传输安全协议（Hypertext Transfer Protocol Secure）。它是基于HTTP协议的加密传输协议，通过在传输数据之前使用加密算法（利用 SSL/TLS 来加密数据包）对数据进行加密，以确保通信的安全性。
HTTPS协议的加密过程主要分为三个步骤：握手、加密和身份验证。具体步骤如下：
握手阶段：客户端向服务器发起HTTPS连接请求，服务器会向客户端发送数字证书和公钥，客户端会验证证书的有效性，如果证书通过验证，客户端就生成一个随机数，使用服务器的公钥对其进行加密，然后将加密后的随机数发送给服务器。
加密阶段：服务器使用私钥解密客户端发送过来的随机数，然后使用这个随机数生成对称密钥，再将对称密钥用客户端的公钥进行加密，发送给客户端。客户端使用私钥解密服务器发送过来的对称密钥，然后使用这个密钥对所有传输的数据进行加密。
身份验证阶段：在握手阶段，客户端会验证服务器的数字证书，以确认连接的安全性。而服务器也可以要求客户端进行身份验证，以确认客户端的身份。
使用HTTPS协议可以有效地保护网站的访问安全性，防止数据被窃听、篡改、伪造等问题。对于一些需要保密性的数据交互，例如金融交易、个人账户信息等，使用HTTPS协议进行加密传输是非常必要的。
二、为什么要发明HTTPS HTTPS的发明主要是为了解决HTTP协议的安全问题。
因为HTTP协议是一种基于文本的协议，所有传输的数据都是明文传输，因此容易被黑客截获并窃取敏感信息。例如，当用户在浏览器中输
入用户名和密码时，这些信息就以明文形式在网络上传输，黑客可以通过截获这些数据来获取用户的敏感信息。
HTTPS通过在HTTP协议的基础上增加了加密传输的功能，将传输的数据进行加密，从而保证通信的安全性。这使得HTTPS协议可以有效地保护网站的访问安全性，防止数据被窃听、篡改、伪造等问题。
此外，随着网络的发展和应用场景的不断拓展，越来越多的网站需要进行身份验证和身份认证。HTTPS协议通过数字证书的方式，可以对服务器和客户端进行身份验证，防止恶意用户伪造网站，从而保护用户的隐私和财产安全。
因此，HTTPS协议的发明是为了保障网络通信的安全和隐私，保护用户敏感信息不被窃取、篡改和伪造，使用户能够更加安全地浏览网页和进行网上交易。
三、HTTP与HTTPS的区别 HTTP（HyperText Transfer Protocol）是一种基于文本的协议，用于在Web浏览器和Web服务器之间传输数据，它的数据传输是明文传输，不提供加密和安全保障。而HTTPS（HyperText Transfer Protocol Secure）是HTTP协议的安全版本，提供了加密和身份认证的功能。
以下是HTTP和HTTPS之间的主要区别：
数据传输安全性
HTTP传输的数据是明文传输的，容易被黑客截获并窃取敏感信息。而HTTPS在HTTP的基础上增加了加密传输的功能，将传输的数据进行加密，从而保证通信的安全性。
传输协议
HTTP是基于TCP/IP协议进行通信的，而HTTPS在HTTP的基础上加入了SSL/TLS协议进行加密，以保证数据传输的安全性。
端口号
HTTP默认使用80端口进行传输，而HTTPS默认使用443端口进行传输。
证书和身份认证
HTTPS使用数字证书进行身份验证和身份认证，确保客户端和服务器的安全连接。而HTTP不需要进行身份验证和身份认证，容易被攻击者伪装。
性能
由于加密和身份验证的额外开销，HTTPS相对于HTTP会增加一些网络负载和延迟，因此会有一定的性能损失。
综上所述，HTTPS相比于HTTP具有更高的安全性和可信度，但会增加一定的性能开销。因此，对于需要保护用户隐私和数据安全的网站，应该采用HTTPS协议来确保通信的安全性。
四、常见的加密方式 1. 对称加密 采⽤单钥密码系统的加密⽅法，同⼀个密钥可以同时⽤作信息的加密和解密，这种加密⽅法称为对称加密，也称为单密钥加密。其特征是：加密和解密所⽤的密钥是相同的。
最常见的对称算法包括AES（Advanced Encryption Standard）、DES（Data Encryption Standard）和3DES（Triple Data Encryption Algorithm）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0caa1f96eb288f20f7f74582176609d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fead9302709b9775c30dde3c4e74edc7/" rel="bookmark">
			基于SSM的社团报名管理系统在进行毕业答辩时可能会提问的问题有哪些？以及这些问题的答案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对基于SSM的社团报名管理系统，在毕业答辩中可能会被问到的问题包括：
为什么选择使用SSM框架来开发这个系统？ 答：SSM框架包含了Spring、SpringMVC和MyBatis，能够帮助我们实现Web应用的开发和数据访问。相较于其他框架，SSM框架具有更加灵活的配置、更好的性能和更高的开发效率。
在这个系统中，你们用到了哪些设计模式？ 答：在这个系统中，我们使用了很多设计模式，比如单例模式、工厂模式、装饰器模式、观察者模式、策略模式等等。这些设计模式能够帮助我们更好地实现代码的复用和可扩展性。
在这个系统中，你们使用了哪些数据库技术？ 答：在这个系统中，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4bc1ed85ab7138ff570295d55727b3/" rel="bookmark">
			基于ssm的社团报名管理系统答辩时提问的问题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是可能涉及到的问题及其答案：
问题1：什么是SSM框架？
答：SSM框架是指Spring + SpringMVC + MyBatis框架的组合。Spring是一个Java企业应用开发框架，SpringMVC是基于Spring的MVC(模型-视图-控制器)框架，MyBatis是一个数据访问框架。这三个框架的组合可以很好地协同工作，实现Java Web应用程序的开发。
问题2：社团报名管理系统的主要功能是什么？
答：社团报名管理系统主要包括社团信息管理、社团成员管理、活动管理和报名管理等功能。社团信息管理包括社团的基本信息、成员列表和活动列表等；社团成员管理包括成员的添加、删除、修
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b7ad2311e6bda82eae4716db2833b8/" rel="bookmark">
			Java中去除字符串空格的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、String.trim()： 它去掉的只是String首尾空格，内部不处理； 2、str.replace(" ", “”)： 去掉所有空格，包括首尾、中间，但是又仅仅局限于一个空格 3、str.replaceAll(" +","") ： 可以匹配去掉所有空格 4、str.replaceAll("\s*", “”)： 可以替换大部分空白字符， 不限于空格 \s 可以匹配空格、制表符、换页符等空白字符的其中任意一个 5、StringUtils.deleteWhitespace(str)； 这是StringUtils类中封装的方法，可以去除所有空格，并且可以匹配空格、制表符、换页符等空白字符的其中任意一个 @Test public void testRemoveAll() { String str = " Ji m m y"; String str1 = str.replaceAll("\\s*", ""); String str2 = str.replaceAll(" +",""); String str3 = StringUtils.deleteWhitespace(str); System.out.println("str1 = " + str1); System.out.println("str2 = " + str2); System.out.println("str3 = " + str3);	} 输出结果为：
str1 = Jimmy
str3 = Jimmy
str3 = Jimmy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedf3838728b4310dafd9cfa7c7be749/" rel="bookmark">
			DataStreamApi简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么可以转化为流 flink的java和scala DataStream API可以将任何可序列化的对象转化为流 1、flink自带的序列化器有 基本类型：String、Long、Integer、Boolean、Array 复合类型：Tuples、POJOs 和 Scala case classes 2、并且flink会交给kryo序列化其他类型。也可以将其他序列化器和 Flink 一起使用。特别是有良好支持的 Avro。 POJOS 如果满足以下条件，flink会将数据类型识别为POJO类型(并允许"按名称"字段引用)
公有且独立有公有的无参构造类及父类中所有的不被static、transient修饰的属性要么是公有的且不被final修饰，要么包含公有的getter和setter方法 stream执行环境 DataStream API将应用构建为一个job graph，并附加到StreamExcutionEnvironment。当调用 env.execute() 时此 graph 就被打包并发送到 JobManager 上，后者对作业并行处理并将其子任务分发给 Task Manager 来执行。每个作业的并行子任务将在 task slot 中执行。如果没有调用 execute()，应用就不会运行
基本的stream source 1、数据类型转换 2、socket接收 3、读取文件 基本的stream sink 使用print()方法打印结果到task manager的日志中。会对流中的每个元素都调用toString()方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047b56bd769409ac10cb36bbb2257a04/" rel="bookmark">
			printf在stm32中的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在STM32中，printf()函数可以用于将文本消息打印到终端或串口。它是C语言标准库中的一个输出函数，用于格式化输出字符串和变量。
要在STM32中使用printf()函数，通常需要先通过串口初始化函数初始化串口，并将串口与printf()函数关联起来。然后，在程序中调用printf()函数时，将要输出的文本作为参数传递给它即可。输出的文本可以包括格式化字符串和变量，例如：
printf("The value of my variable is: %d\n", my_variable); 其中，%d是一个格式控制符，用于表示要输出的变量是一个整数。如果需要输出其他类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f37e727e38a6be01253cf31bb350d4/" rel="bookmark">
			Spring Security是什么，以及如何在Spring Boot项目中整合Spring Security并且使用它，下面我们通过一个登录案例简单介绍一下Spring Security。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Spring Security？ 在了解Spring Security之前，我们是不是应该先思考一个问题，我们自己写的web案例一般都需要先登录，之后登录之后才能访问其他页面，或者说我们不同的用户登录之后能进行的操作不同，比如系统管理员和普通用户所能操作的功能是有所区别的。那我们如何解决这个问题？
不错，这时候我们就需要用到一些安全框架，比较Apache 旗下的Shiro、Spring家族中的Spring Security，Shiro相比Spring Security而言，比较简单易上手，不过我们这篇文章主要讲解Spring Security的简单应用。
接着上面的话题，Spring Security提供了一组可用在Spring应用上下文中配置的Bean，充分的利用了Spring IOC、DI（依赖注入）、AOP（面向切面编程）的功能，提供了生命式的安全访问控制功能，提高了开发效率。
Spring Security的本质就是一组过滤器链（16个），通过创建大量的filter和interceptor来进行请求的验证和拦截，以此来达到安全校验和鉴权的效果。
2.如何使用Spring Security？ 要使用Spring Security很简单，我们只需要引入Spring Security 的相关依赖，就可以得到一个Spring Security的简单示例。
创建Spring Boot项目 ，引入相关的依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt; &lt;/dependency&gt; &lt;!--security 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--JWT 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; 配置yaml文件，主要配置数据源：
server: #配置服务端口号 port: 8081 spring: datasource: #配置数据库驱动 driver-class-name: com.mysql.cj.jdbc.Driver #配置数据库地址，务必加上时区 url: jdbc:mysql://localhost:3306/yeb?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7f37e727e38a6be01253cf31bb350d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f124ca8296eae5a9407f73e3a2c5ebf9/" rel="bookmark">
			【问题记录】关于百度网盘客户端打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 双击桌面图标没有任何反应，用管理员模式也是没什么反应。
问题追踪 按ctrl+shift+esc打开任务管理器，查看到百度网盘的一个升级程序在运行中，注意升级程序的网络一栏，表明该进程在下载东西，但是速度很慢
在网盘升级过程中是打不开程序的，结束该进程后，再次尝试打开，依然不行，还是运行的升级程序
查看其升级速度
我的网速并不是很慢，但是在网盘升级过程中确实只有一两百kb的速度
等了好一段时间还是没升级完……
不会升级也限速把……
问题解决 进入官网https://pan.baidu.com/download#pan重新下载个安装包，安装包大概两百多兆，按照每秒一两百k的速度确实是慢，但是下载官网的最新安装包确是很快。
下载完安装包后，安装程序会自动检测你电脑有么有安装，如果安装有就会进行替换，相当于是进行升级啦。
总结 百度网盘客户端打不开的原因之一是程序正在后台升级中，由于双击程序图标后没有任何提示，加上升级的速度实在有点慢，所以用户感知不到，会以为是不是电脑出问题了。当然，这种情况建立在禁止开机自启，因为如果开机自启，那么大概率会在你不知道的情况下就已经升级好了。我是因为很久没打开过客户端，而且也进行了自启，所以导致一起动就自动升级的情况。
新版客户端貌似已经找不到设置自动升级管理的选项了，查看升级程序的配置文件，发现默认是设置了30天的升级检查，应该是可以更改的，我这用不到，所以就不尝试了，给有需要的朋友提示下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6fafeab3f2568bd084a339c02ada5e/" rel="bookmark">
			手持设备EMC静电放电实验放电路径分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前接触的都是大设备，去年公司准备上马一些手持式的小设备，此类设备无法进行防静电接地处理。刚开始接触此类设备的时候，非常困惑，很长一段时间没有想通此类设备在打静电时，静电放电路径是什么？现把自己的一些想法写下来，与大家分享，有可能我的想法不对，欢迎讨论指正。
我们简化抽象放电实验装置电路，把EUT简化为一张铜皮（静电放电是共模干扰，无论EUT内的PCB是几层板，在此把它当作一个整体看待。）：
我们简化抽象放电实验装置电路，把EUT简化为一张铜皮（静电放电是共模干扰，无论EUT内的PCB是几层板，在此把它当作一个整体看待。）：
EUT内PCB上的铜皮和水平耦合板构成一个电容：
静电放电其实就是对“EUT和耦合板形成电容”的充电过程，充电时，会在有阻抗的地方产生电压降。
那么，如何保护EUT不被静电打到？如果设备没有裸露的金属，我们可以提高设备外壳的绝缘，阻止静电放电的产生；如果设备有裸露的金属，应尽量保证PCB地平面的完整性，减小地平面上的阻抗，必要时可以增加外屏蔽层，由于外屏蔽的阻抗更小，大部分静电顺着外屏蔽放电，从而保护了EUT。
手持设备外静电屏蔽的工作机理如下：
外屏蔽取代EUT，和耦合板之间形成电容，静电放电经过外屏蔽而不是EUT，从而保护了EUT。
虽然EUT和外屏蔽是连接在一起的，但静电只聚集在金属的表面，也就是说静电只聚集在外屏蔽的外表面，EUT上是没有静电的。
上图中，如果要静电保护EUT的上部，在EUT的上面也应该有外屏蔽。外屏蔽最好包裹整个EUT，进而保护EUT的全部侧面，一般来说，对EUT的每个侧面都需要打静电。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87f90474d182b2be827f14be21751ea/" rel="bookmark">
			史上最强python基础知识导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a320a0fd05efeaf672382ce3fb3d1c64/" rel="bookmark">
			echarts柱状图固定展示n个，超过n个出现换页按钮。点击展示剩下的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.echart官方用法我没找到，自己写了一个，如果大家知道的话，麻烦评论一下或者私我哈，学习学习~٩(๑❛ᴗ❛๑)۶~
2.先说一下整体思路哈：
左右两边的换页符号是ui小姐姐切的图片，先固定放在柱形图两边。然后给图片绑定样式让他默认隐藏，在进入这个页面（出现柱形图的页面）的时候，判断获取的你要展示的柱形图列表的长度。如果超过了13（我这里用的是13）个，就让柱形图列表等于前13个数据，同时出现换页符号（原来是默认隐藏），然后给换页符号加上点击事件，获取13个之后的数据（剩余的数据），就相当于展示在下一页 3.具体代码分析
先写好换页符号的样式，默认隐藏
&lt;img src=".......图片地址" alt="" @click="handleClickright()" :class="[{showleft : disabled},'positionimgright']" /&gt; &lt;img src=".......图片地址" alt="" @click="handleClickleft()" :class="[{showright: disabled},'positionimgleft']" /&gt; 先不要看点击事件哈，这个后面才用到，先看 ：class的绑定 {showleft:disabled}是控制显示隐藏的，positionimgleft是基本样式
样式代码，先确定图片的位置样式，再默认图片不显示
. gxgaswitch { position: relative；//这个是外面定位的样式，不用管这个 . positionimgleft { //定位左边图片的样式 display: none ; position: absolute ; left: 12px; top: 76px; z-index: 999; } . positionimgright { //定位右边图片的样式 display: none; position: absolute ; left: 368px; top: 76px; z- index: 999; &amp;: hover { //图片默认不展示 . positionimgright {display: block;} .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a320a0fd05efeaf672382ce3fb3d1c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32bcab667a5592dbfaff86e499a90b40/" rel="bookmark">
			linux各路径（目录）的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 /bin
存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。
/etc
存放系统管理和配置文件
/home
存放所有用户文件的根目录，是用户主目录的基点，
比如用户user的主目录就是/home/user，可以用~user表示
/usr
用于存放系统应用程序，比较重要的目录/usr/local 本地系统
管理员软件安装目录（安装系统级的应用）。
这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。
/usr/x11r6 存放x window的目录
/usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库
/opt
额外安装的可选应用程序包所放置的位置。一般情况下，
我们可以把tomcat等都安装到这里。
/proc
虚拟文件系统目录，是系统内存的映射。
可直接访问这个目录来获取系统信息。
/root
超级用户（系统管理员）的主目录（特权阶级^o^）
/sbin
存放二进制可执行文件，只有root才能访问。
这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。
/dev
用于存放设备文件。
/mnt
系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。
/boot
存放用于系统引导时使用的各种文件
/lib
存放跟文件系统中的程序运行所需要的共享库及内核模块。
共享库又叫动态链接共享库，作用类似windows里的.dll文件，
存放了根文件系统程序运行所需的共享文件。
/tmp
用于存放各种临时文件，是公用的临时文件存储点。
/var
用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，
比方说各种服务的日志文件（系统启动日志等。）等。
/lost+found
这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图：
/bin 二进制可执行命令
/dev 设备特殊文件
/etc 系统管理和配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32bcab667a5592dbfaff86e499a90b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58edd78421f046851198b06371e202e/" rel="bookmark">
			pyecharts设置柱形图颜色每个不一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用pyecharts设置柱形图每个柱子的颜色不同，可以通过在add方法中使用itemstyle_opts参数来设置。具体来说，可以使用item_color选项来指定每个柱子的颜色。
例如，以下代码可以创建一个简单的柱状图，并将第一个柱子的颜色设置为红色，第二个柱子的颜色设置为绿色，第三个柱子的颜色设置为蓝色：
from pyecharts.charts import Bar bar = Bar() bar.add_xaxis(['A', 'B', 'C']) bar.add_yaxis('Series', [1, 2, 3], itemstyle_opt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac4cb3d98262e31418559342e99db6b/" rel="bookmark">
			单片机非阻塞延时实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 准备工作 1.1 配置定时器 利用单片机外设配置定时器中断 --- 1ms周期（该触发周期决定非阻塞延时精度）
1.2 定义全局变量以及编写中断服务函数 uint32_t delay_tick = 0; void TIM2_IRQHandler(void){ if(TIM_GetITStatus(TIM2,TIM_IT_Update)==SET){ delay_tick++; //1ms自加一次 delay_tick&amp;=0xFFFFFFFF; //防止溢出 TIM_ClearITPendingBit(TIM2,TIM_IT_Update); //清除中断标志位 } } uint32_t GetDelayTick(void) { return delay_tick; } 1.3 定义全局变量以及编写ms精度延时函数 uint32_t tick = 0; bool IsTimeOut(uint32_t *tick, uint32_t delay_time){ uint32_t temp = 0; /* 获取上一次延时到时时刻到本次调用该函数时间间隔 */ if(*tick &lt;= GetDelayTick()){ temp = GetDelayTick() - *tick; } //delay_tick已经产生溢出 else{ temp = 0xFFFFFFFF - *tick + GetDelayTick(); } /* 判断是否已经超过延时时间 */ if(temp &gt;= delay_time){ *tick = sysTick; //记录本次延时到时时刻 return true; //延时时间到，返回true } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a108c8e38f43979bdcc73ab58ada68/" rel="bookmark">
			maven的配置及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、maven 1 简介 项目管理工具
项目对象模型project object model（pom）
一个项目：清理，编译，测试，打包，发布，部署
1.1.1 java构建工具的发展史 make： 编写makefile
Ant： Apache
maven：使用量较高
gradle：安卓端使用较多
bazel：
1.1.2 maven能做什么 管理jar包构建项目：自动完成 （清理，编译，测试，打包，发布，部署）项目的拆分与聚合 1.1.3 为什么使用maven IDE（继承开发环境）不是万能的，依赖大量的手动操作，编译，测试，代码生成，这些工作是相互独立的，很难一键自动操作很难统一所有IDE的配置 1.1.4 maven对jar文件的管理 没有maven之前，自己对jar包的下载，匹配版本，jar包重复使用，考虑jar包之间依赖的问题
2. maven应用 2.1 下载和安装 官网: https://maven.apache.org/
下载：https://dlcdn.apache.org/maven/maven-3/3.9.0/binaries/apache-maven-3.9.0-bin.zip
解压后的目录
bin：存放maven指令
boot：存放类加载器框架
conf：存放配置文件
lib：存放第三方jar包
安装
环境变量配置
maven_home
path路径
检验环境配置是否成功
mvn -v
配置jdk版本
pom.xml
&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;JAVA_HOME&gt;C:\Users\hison\.jdks\corretto-11.0.17&lt;/JAVA_HOME&gt; &lt;/properties&gt; 2.2 maven的项目结构 不同的ide（继承开发环境），目录结构不同，导致不能直接将不同IDE开发的项目进行导入。
maven项目的目录结构是统一的
maven项目结构
mvn_app --pom.xml --src --main --java : 源代码的根 --com --mycompany --app --App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a108c8e38f43979bdcc73ab58ada68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345347c6e4ac1049bb0da7cff31a8b3d/" rel="bookmark">
			JDBC知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC JDBC驱动程序 数据库配置信息 url：连接数据库系统资源描述符 jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8
DriverClass：数据库系统驱动名称
UserName：数据库系统用户名称
PassWord：登录数据库系统用户密码
others：其他信息
## 数据库属性配置信息 ## 连接数据库服务器URL jdbc_url = jdbc:mysql://localhost:3306/ATMSYSTEM?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=UTC ## 连接数据库服务器驱动类 jdbc_driver = com.mysql.jdbc.Driver ## 访问数据库服务器用户名称 jdbc_UserName = root ## 访问数据库服务器用户密码 jdbc_PassWord = 123456 步骤 加载驱动 Class.forName(“com.mysql.jdbc.Driver”);连接数据库 DriverManger.getConnection()； 返回Connection对象执行SQL对象 调用createStatement（） 返回Statement对象调用executeQuery（sql） 执行sql语句 try { Class.forName("com.mysql.cj.jdbc.Driver"); //加载驱动 String url = "jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8"; Connection connection = DriverManager.getConnection(url,"root","123456"); Statement statement = connection.createStatement(); String sql = "select * from meet "; ResultSet execute = statement.executeQuery(sql); while (execute.next()){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/345347c6e4ac1049bb0da7cff31a8b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802f70d479b7e3eb05a85c825f1149d9/" rel="bookmark">
			docker login 账号密码查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker login 之后，会在 /root/.docker/config.json 中保存base64编码后的用户名和密码信息。
执行 sudo cat /root/.docker/config.json 打印文件内容，如下：
{ "auths": { "registry.*****.com": { "auth": "bWFya2l4OjEyMzQ1NmFiYw==" } } } 文件中 auth 的值就是账号信息，解码后就可以看到用户名和密码， 格式为 username:password​​，冒号前面就是用户名，后面是密码。
base64 解码命令：echo 上面auth的值 | base64 -d
示例：
$ echo bWFya2l4OjEyMzQ1NmFiYw== | base64 -d markix:123456abc 账号就是markix，密码是123456abc
题外话：可以看到这种敏感信息很不安全，docker也支持将凭证保存在外部存储，可以了解下 credentials-store
end
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b51d47135d8afb3392b54eb1c510e6f/" rel="bookmark">
			VScode shell脚本编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文分享如何将vscode打造成shell脚本IDE，并分享一些关于shell相关的学习资料。
vscode打造shell脚本IDE【转】
近期多了些开发shell脚本的需求，便做了些研究，于是发现：
1、shell没有专用的IDE
2、老手们习惯了vim的开发方式，干起活来非常黑客。但对新人，不太友好
既然没有现成的，那就用插件组一套，软件依然是vscode。
shellman
说起IDE，第一时间想到的必然是智能提示和自动补全，shellman全部搞定 下载后，新建test.bash文件，输入case，可见如下结果：
选中提示中的第一个，然后就获得了if全家桶：
由上面两张图可见shellman的提示是比较系统的。
shellcheck
有了自动补全，然后就是语法错误检查了 安装成功后，再写代码就会出现如下的错误提示：
shell-format
脚本写好了，当然要格式化一下 快捷键：Alt+Shift+F
Code Runner
在vs code里开发，在vs code里纠错，又在vs code里格式化，到了调试不会要去命令行吧！ 安装完后，如果出现require reload的字样，请重启vs code。然后对刚才创建的test.bash右键，（或者在文件里右键）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9b57c2e1d9519bb1e474558dd81867/" rel="bookmark">
			Error in [.data.frame(data, c(i, j)) : undefined columns selected
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个错误是因为你在对数据框进行子集选择时，指定的列名(i和j)不存在于数据框中，导致选择出错。
可能的原因包括：
你打错了列名。列名包含空格或其他非法字符。数据框中确实不存在你指定的列名。 解决方法包括：
检查列名是否正确，确保没有打错或包含非法字符。使用列的索引号而不是列名进行子集选择。检查数据框是否包含你需要的列，可能需要重新导入数据或对数据进行清洗。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24187c2854ee4b642ff701fcdaa9352/" rel="bookmark">
			解决 error: subprocess-exited-with-error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"error: subprocess-exited-with-error" 是一个比较常见的错误，通常在使用命令行工具时出现。它表示执行的子进程在执行过程中出现了错误，可能是由于命令的语法错误、文件权限问题或其他原因导致的。
要解决这个错误，首先需要查看完整的错误消息和执行的命令。如果是语法错误，那么需要修改命令或脚本中的错误。如果是文件权限问题，需要使用适当的权限运行命令。
另外，还可以尝试将命令分成多个步骤，逐步调试，找到出现错误的具体步骤。如果还无法解决问题，可以在相关的开发者社区或论坛上寻求帮助，也可以咨询专业的技术支持人员。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ecfd95f2135893a0307ae35dad29d21/" rel="bookmark">
			Qt开发-字符串详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用字符串类型 类型
说明
QChar
1个UTF-16字符。
QString
由QChar组成的字符串。默认使用深拷贝。如果必须使用浅拷贝，可以通过fromRawData进行构建。
QByteArray
传统字符串，以\0结尾。不建议使用。当前只在保存raw数据，或者使用内存非常严格的情况下可以使用。
QLatin1String
纯US-ASCII (ANSI X3.4-1986)和Latin-1 (ISO 8859-1)编码情况下，对char * 进行的轻量级封装。直接对纯latin1数据进行处理。速度比操作unicode编码数据更快。
QStringLiteral
宏！在编译期间，将一个const char * 对象转换成QString对象。节约程序运行时的操作。
QStringLiteral详细 #define QStringLiteral(str) \ ([]() noexcept -&gt; QString { \ enum { Size = sizeof(QT_UNICODE_LITERAL(str))/2 - 1 }; \ static const QStaticStringData&lt;Size&gt; qstring_literal = { \ Q_STATIC_STRING_DATA_HEADER_INITIALIZER(Size), \ QT_UNICODE_LITERAL(str) }; \ QStringDataPtr holder = { qstring_literal.data_ptr() }; \ return QString(holder); \ }()) \ 这里是一个匿名函数，不抛任何异常。返回值是QString。
创建一个enum数值 Size，按照按照当前字符串的长度除以2，再刨除后面的\0.
利用Size创建一个QStaticStringData类型的数据qstring_literal，会返回qstring_literal的data_ptr()，直接转换成QString。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ecfd95f2135893a0307ae35dad29d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63ae197d4e1226a432c7d1722523775/" rel="bookmark">
			YOLOv8进行改进并训练自定义的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.训练数据集准备 YOLOv8的训练数据格式与YOLOv5的训练数据格式一致，这一部分可以进行沿用。之前博文有发布VOC标注格式转YOLO标注格式的脚本，有需要可以查看。 二.项目克隆 YOLOv8项目文件可以直接去github上下载zip文件然后解压，也可以直接Git克隆。项目官方地址 三.训练前准备 这一部分首先保证机子上安装好了深度学习环境（可以跑YOLOv5就行）。 下一步用Pycharm打开YOLOv8项目，打开项目的终端，输入 pip install -r requirements.txt 到这里。如果按照官方的操作指南需安装ultralytics这个包（我认为，这也是YOLOv8相较于YOLOv5区别最大的地方），但是如果大家要对YOLOv8做出改进，这里可能会出现问题。因此，我推荐大家不要执行这一步操作（如果不需要对YOLOv8做出改进，可以按照官方的指南进行操作）。 四.模型训练 第一、需要创建数据集的yanl文件 NWPU VHR-10 dataset/split_data
train
images
000001.jpg
000002.jpg
000003.jpg
......
labels 000001.txt
000002.txt
000003.txt
......
val
images
......
labels
......
test
images
......
labels
......
第二、下载YOLOv8的预训练权重文件（这一步也可以不需要） 链接地址 第三、添加自定义模块（这里如果不对YOLOv8进行改进可以直接看第五步） 比如这里我要在YOLOv8的基础上添加CBAM注意力模块，首先打开modules.py，在下方添加CBAM注意力模块的代码实现。 再打开task.py，在对应位置添加CBAM模块的声明 第四、根据自己设计的网络结构修改yaml文件 比如这里我将YOLOv8中部分的C2f模块替换为C3模块。 第五、开始训练 这里也是和YOLOv5有着较大的差别，在YOLOv8中train、val和test的参数设置都是依赖于default.yaml这个文件，因此在对参数设置进行修改前，建议先对该文件进行备份。 这里进行切换任务与模式。 这里需要注意，在YOLOv5中是同时包含--weights预训练权重文件和--cfg模型文件，预训练权重（.pt）是由官方提供，模型文件（.yaml）是自己修改的文件，并在训练中导入相同层的权重信息。而在YOLOv8中，只有--model这一个参数设置，且同时允许.pt文件与.yaml文件的接受处理。因此，这里的话，我建议用yaml文件，因为这样我们才能载入我们自己设计的网络结构（注：从目前的实验来看，只导入yaml文件也能进行迁移学习，载入预训练权重文件）。--data存放我们数据集的yaml文件。其他参数可以根据自己的需求自己设定（注：这里发现YOLOv8在训练时GPU的内存占用比YOLOv5的大许多，有bug。部分博主说可通过减少workers来缓解此类现象）。 # Train settings ------------------------------------------------------------------------------------------------------- model: # path to model file, i.e. yolov8n.pt, yolov8n.yaml data: # path to data file, i.e. i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d63ae197d4e1226a432c7d1722523775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33882f2af6ad78b6f8eda5cbd6449e2c/" rel="bookmark">
			解释：ball_54_0 = io.loadmat(&#34;./CWRU/ball/ball54/222&#34;)[&#34;X222_DE_time&#34;].tolist()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这行代码的作用是从指定路径下的.mat文件中加载数据，将其中键名为"X222_DE_time"的数据取出并转换为列表，然后将该列表赋值给变量ball_54_0。其中，"./CWRU/ball/ball54/222"是.mat文件的路径，"X222_DE_time"是.mat文件中数据的键名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ddc693c9f13fec8a1ad26d0ec36e391/" rel="bookmark">
			Java网络编程之UDP和TCP套接字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 网络编程概述二. UDP网络编程1. UDP套接字2. UDP客户端回显服务器程序2.1 UDP回显服务器2.2 UDP客户端2.3 UDP实现查词典的服务器 三. TCP网络编程1. TCP套接字2. TCP客户端回显服务器程序2.1 TCP回显服务器2.2 TCP客户端2.3 解决服务器无法同时出力多个客户端的问题2.4 TCP实现查词典的服务器 一. 网络编程概述 我们知道在网络通信中, 数据的发送是从应用层开始, 一直封装到物理层然后进行发送的, 应用层要将数据交给传输层进行封装; 而接收方拿到数据后是从物理层到应用层进行分用, 传输层要将拿到的数据再分用给应用层进行使用, 网络编程实际操作中最关键的就是我们所能控制的应用层和传输层之间的交互, 而在操作系统中提供了一组API即socket, 用来实现应用层和传输层之间的交互, Java当中把操作系统提供的API进行了进一步封装以便我们进行使用.
常见传输层协议有UDP和TCP两种, 其中UDP的特点是无连接, 不可靠传输, 面向数据报, 全双工; TCP的特点是有连接, 可靠传输, 面向字节流, 全双工.
使用TCP协议, 必须是通信双方先建立连接才能进行通信(想象打电话的场景), 而使用UDP协议在无连接的情况下可以进行通信(想象发微信, 短信的场景).
这里的可靠与不可靠传输指的不是安全性质, 而是说你发送出数据后, 能不能判断对方已经收到, 如果能够确定对方是否收到则就是可靠传输, 否则就是不可靠传输.
面向字节流就类文件读写数据的操作, 是 “流” 式的; 而面向数据报的话数据传输则是以一个个的 “数据报” 为基本单位(一个数据报可能是若干个字节, 是带有一定的格式的).
全双工是指一条通信链路, 可以双向传输(同一时间既可以发, 也可以收); 而半双工是一条链路, 只能单向通信.
二. UDP网络编程 1. UDP套接字 UDP类型的Socket, 涉及两个核心类, 一个是DatagramSocket, 其实例的对象表示UDP版本的Socket, 操作系统中将网卡这种硬件设备也抽象成了文件进行处理, 这个Soket对象也就成了文件描述表上面的一项, 通过操作这个Socket文件来间接的操作网卡, 就可以通信了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ddc693c9f13fec8a1ad26d0ec36e391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56fb8eb482f791753e8cb309e2dfc5ba/" rel="bookmark">
			vue3&#43;ts登入按钮防抖和节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在uilt文件夹下新建一个DebounceThrottle.ts进行函数的封装
// 防抖：防抖指的是在事件触发n秒后再执行回调，如果在n秒内再次被触发，则重新计算时间。 // 为什么需要防抖：就拿用户登录来说，如果不做防抖操作，多次点击登入按钮就会多次请求后台， // 既会造成不必要的性能消耗也会造成用户体验的不好 // 防抖在连续的事件，只需触发一次回调的场景有： // 搜索框搜索输入。只需用户最后一次输入完，再发送请求。 // 窗口大小的改变resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 // 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖。 // 实现过程：封装一个函数并传递两个参数， // 第一个参数是需要调用的函数或者请求，第二个参数是延迟多少毫秒才执行函数 // 在函数里先定义一个空变量，再return一个匿名函数，在该函数中先判断定义的变量是否为空， // 为空就添加一个定时器，不为空就清除定时器 // fn代表有个函数，里面可能会频繁发生回调或ajax // delay表示间隔多少毫秒才触发，默认200毫秒 export function debounce(fn:Function,delay=200){//fn是需要防抖的函数，delay是延迟多少毫秒执行fn let timer:NodeJS.Timeout | null = null; return function (){ if(timer){ clearTimeout(timer); } timer=setTimeout(()=&gt;{ fn.apply(fn,arguments); timer = null; },delay) console.log(timer,"timer"); } } // 节流：节流是指如果持续触发某个事件，则每隔n秒执行一次 // fn代表可能会频繁发生回调或ajax请求的函数 // delay表示间隔多少毫秒才触发，默认100毫秒 // 节流在间隔一段时间执行一次回调的场景有： // 滚动加载，加载更多或滚到底部监听 // 搜索框，搜索联想功能 // 实现过程：封装一个函数并传递两个参数， // 第一个参数是需要调用的函数或者请求，第二个参数是延迟多少毫秒才执行函数 // 在函数里先定义一个空变量，再return一个匿名函数，在该函数中先判断定义的变量是否为空， // 为空就执行定时器，不为空就不执行定时器而不是像防抖一样清除定时器 export function throttle(fn:Function,delay=100){ //首先设定一个变量，在没有执行我们的定时器为null let timer:NodeJS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56fb8eb482f791753e8cb309e2dfc5ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149981dc61e648ee3c4a89c4129da964/" rel="bookmark">
			如何安装docky和SuperTuxKart
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、第一个安SuperTuxKart ：
1.1、 Ubuntu用户安装方法：
sudo add-apt-repository ppa:stk/dev
sudo apt-get update &amp;&amp; sudo apt-get install supertuxkart
下面以Ubuntu的衍生版ultimate为例,安装如下：
fantlam@fantlam-ODM:~$ sudo add-apt-repository ppa:stk/dev
[sudo] password for fantlam:
Executing: gpg –ignore-time-conflict –no-options –no-default-keyring –secret-keyring /etc/apt/secring.gpg –trustdb-name /etc/apt/trustdb.gpg –keyring /etc/apt/trusted.gpg –primary-keyring /etc/apt/trusted.gpg –keyserver keyserver.ubuntu.com –recv AEC3B92F669B86354C7D5E676D3B959722E58263
gpg: 下载密钥‘22E58263’，从 hkp 服务器 keyserver.ubuntu.com
gpg: 密钥 22E58263：公钥“Launchpad SuperTuxKart PPA”已导入
gpg: 合计被处理的数量：1
gpg: 已导入：1 (RSA: 1)
fantlam@fantlam-ODM:~$ sudo apt-get update &amp;&amp; sudo apt-get install supertuxkart
[sudo] password for fantlam:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149981dc61e648ee3c4a89c4129da964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e96fab5432694b40901caef44cc08cd/" rel="bookmark">
			Flutter更新showDialog以及showModalBottomSheet中的状态中的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Flutter更新showDialog以及ModalBottomSheet中的状态中的内容 1、Flutter更新showDialog中的状态中的内容 很多人在用showDialog的时候应该都遇到过这个问题，使用showDialog后，通过setState()无法更新当前dialog。其实原因很简单，因为dialog其实是另一个页面，准确地来说是另一个路由，因为dialog的关闭也是通过navigator来pop的，所以它的地位跟你当前主页面一样。这个概念一定要明确，因为无论在Android或iOS中，daliog都是依附于当前主页面的一个控件，但是在Flutter中不同，它是一个新的路由。所以使用当前主页面的setState()来更新，当然没法达到你要的效果。
StatefulBuilder
很多人使用StatefulBuilder依然达不到更新的效果，是因为你用错了setState()方法。
就像我们上面说的那样，这个builder构建的控件，不会响应老页面的任何操作，因为它们是两个互不影响的路由控制的。
showDialog( context: context, builder: (context) { String label = 'test'; return StatefulBuilder( builder: (context, state) { print('label = $label'); return GestureDetector( child: Text(label), onTap: () { label = 'test8'; print('onTap:label = $label'); // 注意不是调用老页面的setState，而是要调用builder中的setState。 //在这里为了区分，在构建builder的时候将setState方法命名为了state。 state(() {}); }, ); }, ); }); 2、Flutter 更新showModalBottomSheet中的状态（state） 和上面一样的showModalBottomSheet也会有这样的问题。解决方法如下 bool btnState=false; showModalBottomSheet(context:context, builder:(BuildContext context){ return StatefulBuilder( builder:(context1, state) {///这里的state就是setState，这里是终点 return Container( child:OutlineButton( onPressed: (){ state(() {///为了区分把setState改个名字 btnState=!btnState; }); }, child:Stack( children: &lt;Widget&gt;[ Opacity( opacity: btnState ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e96fab5432694b40901caef44cc08cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e423df5b86c01c377280e0b8562cc2c3/" rel="bookmark">
			zip 命令的解释与示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是 Linux 命令学习系列的一部分。
zip 文件是一个包含一个或多个文件的压缩档案。它作为一种无损数据压缩技术被广泛使用。由于压缩，它占用的磁盘空间更少，在计算机网络上传输时需要的数据也更少。
这些压缩文件可以在 Linux、Windows 和 macOS 中轻松提取。有各种支持压缩 zip 文件的软件，也提供提取它们的功能。
由于它很流行，几乎所有的操作系统都内置了这个功能。
在本教程中，我们将谈论几种基于终端的方法来压缩 Linux 中的文件。
Linux 中的 Zip 命令示例 语法
在 Linux 中，你需要使用的压缩文件的程序名称是 zip。下面是基本的语法：
zip [压缩文件名] file1 file2 file3 以下是正式的语法：
zip [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list] [-xi list] 理想情况下，zip 命令应该被安装在所有主流的 Linux 发行版中。如果没有，使用下面的命令来安装它。
在 Debian、Ubuntu 和相关发行版上安装
sudo apt install zip 在 Fedora、基于 RHEL 的系统上安装
sudo dnf install zip 在 Arch Linux 上安装
pacman -S zip 让我们继续看一些例子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e423df5b86c01c377280e0b8562cc2c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b2d2ae927700e06176689331c49ace/" rel="bookmark">
			Maven进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1.分模块开发1.1 模块更新后,会造成的影响 2.依赖管理2.1 依赖传递2.2 可选依赖(隐藏自己的依赖,不让别人用)2.3 排除依赖(用别人的资源,把不用的去了) 3.聚合与继承3.1 为什么要使用聚合工程?3.2 聚合工程开发3.3 继承关系3.3.1 可选依赖 3.4 聚合和继承的区别(重要) 4.属性管理5.版本管理6.多环境配置和应用6.1 跳过测试 1.分模块开发 我们之前做的项目,是将功能模块都汇聚到一起,这样会导致项目结构非常庞大,不利于开发人员的维护和开发,我希望是我做这个功能模块,那我就只要关心这个功能模块
一、模块拆分原则
目的：项目的扩展性变强了，方便其他项目引用相同的功能。
将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享
二、 通过maven指令安装模块到本地仓库（install指令）
我们写到一个功能模块后,使用mvn install命令将功能模块发布到本地仓库中(团队共享的仓库,也被称为私服)
三、 依赖管理
&lt;!--设置当前项目所依赖的所有jar--&gt; &lt;dependencies&gt; &lt;!--设置具体的依赖--&gt; &lt;dependency&gt; &lt;!--依赖所属群组id--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;!--依赖所属项目id--&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;!--依赖版本号--&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.1 模块更新后,会造成的影响 举例:例如有controller、service、dao、pojo这四个模块,其中controller依赖service、service依赖dao、dao依赖pojo,那如果我们对pojo这个模块的功能进行修改, 此时启动服务会有哪些影响?
一、回答这个问题前,首先我们明确一点:即服务的启动流程
无论是普通的main函数,还是通过引导类启动服务,都会先对项目结构进行编译(compile),编译通过,才能启动函数/服务.
编译时会根据pom.xml文件中的依赖关系,从底层依赖开始编译,此时就会根据pojo的坐标,在本地仓库中找到pojo的jar包,编译通过,继续往上编译,只要当编译全部通过,才会启动服务
所以我们要清楚
controller中只有service的jar包坐标(非包含service的jar包)service中只有dao的jar包坐标(非包含dao的jar包)dao中只有pojo的jar坐标(非包含pojo的jar包) 如果service的jar包包含dao的jar包,就不可能只有3KB
二、此时我们可以回答这个问题:
如果我们修改了pojo模块分为两种情况
情况一:如果pojo类修改了,没有install,此时执行的是修改前的逻辑情况二:如果pojo类修改了,进行install,此时执行的是修改后的逻辑 我们只需要对pojo进行install,更新pojo的jar包即可,不用对service和dao的包进行install(因为jar包中只是引用依赖,而非依赖实际存在)
三、特殊情况
如果我们在同一个project中打开controller、service、dao、pojo,此时当我们修改了pojo中的代码(没有install),并启动项目,此时运行的也是修改后的代码哦!!!
2.依赖管理 2.1 依赖传递 路径优先: 当依赖中出现相同的资源时, 层级约深, 优先级越低, 层级越浅, 优先级越高声明优先: 当资源在相同层级被依赖时, 配置顺序靠前的覆盖配置顺序靠后的(非直接依赖)当同级配置了相同资源的不同版本,后配置的覆盖先配置的(直接依赖) 2.2 可选依赖(隐藏自己的依赖,不让别人用) 可选依赖指对外隐藏当前所依赖的资源————不透明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b2d2ae927700e06176689331c49ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f6fdb74382459ed05e6eba1d0827ee/" rel="bookmark">
			vscode .vue 中的页面代码不显示颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你在使用VS Code时，发现你的.vue页面中的代码没有显示颜色，可以尝试以下方法来解决这个问题：
确认安装了适当的扩展。在VS Code中打开扩展面板(可以使用快捷键 Ctrl+Shift+X 或者 Cmd+Shift+X)，并搜索 Vue。如果你没有安装该扩展，安装它，并重启VS Code。这通常可以解决问题。
确认在VS Code的设置中启用了语言模式。在VS Code中打开设置(可以使用快捷键 Ctrl+, 或者 Cmd+,)，并搜索 files.associations。找到 .vue 文件的条目，并确保它与 "vue" 或
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48b228d15fe7f09ee5b9ed345676faa/" rel="bookmark">
			已解决：由于缺少调试目标，无法开始调试。请生成项目并重试，或者相应的设置OutputPath和AssemblyName属性，使其指向目标程序集的正确位置。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上找了一大堆方法，什么重新生成解决方案啊，重置啊等等，都没有用
后来我就自己观察发现代码有报错提示，我检查了代码中没有出现红色表示，如下图。
后来发现在Designer.cs文件中，打开后，将错误删除后，发现代码可以正常调试了，建议大家找到自己的错误，改正尝试一下，我觉得比网上的方法靠谱的多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45258ec43a1253464b6fd7962bce1d4/" rel="bookmark">
			flink基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 流处理 自然环境中数据的产生都是流式的，分析数据时，可以围绕有界流（bounded）和无解流（unbounded）两种模型来处理数据 在flink中，应用程序由用户自定义算子转换而来的流式dataflows组成。这些流式dataflows形成了有向图，以一个或多个源（source）开始，并以一个或多个汇（sink）结束 并行Dataflows flink程序本质上是分布式并行程序，在程序执行期间，一个流有一个或多个分区，每个算子有一个或多个子任务（operator subtask）。每个子任务彼此独立，并且在不同的线程中运行，或在不同的计算机或容器中运行 算子的子任务数就是对应算子的并行度。在同一程序中，不同算子也可能具有不同并行度 数据传输 一对一(直传)模式：同一分区的数据传输到下游的同一分区（输入的数据及其顺序完全相同） 重新分发模式：根据不同的算子进行不同的数据分发模式，如keyBy()通过散列键重新分区、broadcast()广播、rebalance()随机重新分发 自定义时间流处理 使用事件时间而不是处理数据的机器时间 有状态流处理 flink中的算子可以是有状态的。这意味着如何处理一个事件可能取决于该事件之前所有事件数据的累积结果 flink程序的状态访问都在本地，这有助于提高吞吐量和降低延迟。通常情况下，flink状态存储在jvm堆上，但如果状态太大，我们也可以选择将其以结构化数据格式存储在高速磁盘中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de12ec8d408a03c7466f501f7b1c85db/" rel="bookmark">
			三极管恒流源电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用三极管搭恒流源的几种形式。
配合稳压管搭恒流源
用稳压管稳定三极管基极的电压，此电压经过发射结钳位之后降低0.7V，此时发射极电压也是稳定的，发射极电压除以发射极电阻就得到恒定电流。如图，在红点处接负载，负载电流恒定为5mA。
通过调节发射极电阻阻值或者换用不同稳压值的稳压管可以实现负载电流大小的调节。
电流计算公式：
配合二极管恒流源
用两个二极管钳位，稳定基极电压1.4V。其余的分析和稳压管一样。
不管是配合稳压管还是二极管搭恒流源，它们的原理都一样，我们要挖掘出精髓出来，往后遇到这种原理图才能做到举一反三，这里恒流设计的精髓就是稳定三极管的基极电压！因为稳定基极电压之后通过射极钳位，再通过射极电阻将稳定的电压转化为稳定的电流，这样就实现了恒流！
它们通用的电流计算公式如下：
掌握了稳定基极电压这个原理，就可以拓展出很多恒流设计电路了
两个三极管搭恒流源
参考原文：《三极管恒流源》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c322b02d494c99460464f3d5260ca13/" rel="bookmark">
			R语言逻辑回归(对数几率回归,Logistic)分析研究生录取数据实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被客户要求撰写关于逻辑回归的研究报告，包括一些图形和统计输出。
Logistic回归，也称为Logit模型，用于对二元结果变量进行建模。在Logit模型中，结果的对数概率被建模为预测变量的线性组合。
相关视频：R语言逻辑回归（Logistic回归）模型分类预测病人冠心病风险 逻辑回归Logistic模型原理和R语言分类预测冠心病风险实例
，时长06:48
例子 例1. 假设我们对影响一个政治候选人是否赢得选举的因素感兴趣。结果（因）变量是二元的（0/1）；赢或输。我们感兴趣的预测变量是花在竞选上的钱，花在竞选上的时间，以及候选人是否是现任者。
例2. 一个研究者对GRE（研究生入学考试成绩）、GPA（平均分）和本科院校的声望等变量如何影响研究生院的录取感兴趣。因变量，录取/不录取，是一个二元变量。
数据的描述 对于我们下面的数据分析，我们将在例2的基础上展开关于进入研究生院的分析。我们生成了假设的数据，这些数据可以在R中从我们的网站上获得。请注意，R在指定文件位置时需要正斜杠（/）而不是反斜杠（），该文件在你的硬盘上。
##查看数据的前几行 head(mydata) 这个数据集有一个二元因（结果，因果）变量，叫做录取。有三个预测变量：gre、gpa和rank。我们将把gre和gpa这两个变量视为连续变量。变量rank的值为1到4。排名为1的院校有最高的声望，而排名为4的院校有最低的声望。我们可以通过使用总结来获得整个数据集的基本描述。为了得到标准差，我们使用sapply对数据集中的每个变量应用sd函数。
你可能考虑的分析方法 以下是你可能遇到过的一些分析方法的清单。所列的一些方法是相当合理的，而其他的方法可能有局限性。
Logistic回归，是本文的重点。Probit回归。Probit分析会产生类似Logistic回归的结果。选择probit还是logit，主要取决于个人的偏好。OLS回归。当与二元因变量一起使用时，这个模型被称为线性概率模型，可以作为描述条件概率的一种方式。然而，线性概率模型的误差（即残差）违反了OLS回归的同方差和误差的正态性假设，导致标准误差和假设检验无效。双组判别函数分析。一种用于二分结果变量的多变量方法。 使用logit模型 下面的代码使用glm（广义线性模型）函数估计一个逻辑回归模型。首先，我们将等级转换为一个因子变量，以表明等级应被视为一个分类变量。
rank &lt;- factor(rank) 由于我们给我们的模型起了个名字（mylogit），R不会从我们的回归中产生任何输出。为了得到结果，我们使用summary命令。 在上面的输出中，我们首先看到的是调用，这是R提醒我们所运行的模型是什么，我们指定了哪些选项，等等。接下来我们看到偏差残差，这是衡量模型拟合度的一个指标。这部分输出显示了模型中使用的各个案例的偏差残差的分布。下面我们讨论如何使用偏差统计的摘要来评估模型的拟合度。输出的下一部分显示了系数、它们的标准误差、z统计量（有时称为Wald z统计量）以及相关的p值。gre和gpa都有统计学意义，三个等级项也是如此。逻辑回归系数给出了预测变量增加一个单位时结果的对数几率变化。 gre每增加一个单位，录取（与未录取）的对数几率增加0.002。gpa增加一个单位，被研究生院录取的对数几率就会增加0.804。级别的指标变量有一个稍微不同的解释。例如，就读于排名为2的本科院校与排名为1的院校相比，被录取的对数几率会改变为-0.675。系数表下面是拟合指数，包括无效和偏差残差以及AIC。稍后我们将展示一个例子，说明如何使用这些值来帮助评估模型的拟合。 我们可以使用confint函数来获得系数估计值的置信区间。注意，对于logistic模型，置信区间是基于剖析的对数似然函数。我们也可以通过使用默认的方法，只根据标准误差来获得CI。
我们可以用wald.test函数来检验等级的整体效应。系数表中系数的顺序与模型中项的顺序相同。这一点很重要，因为wald.test函数是按照系数在模型中的顺序来参考的。我们使用wald.test函数。b提供了系数，而Sigma提供了误差项的方差协方差矩阵，最后Terms告诉R模型中哪些项要被测试，在本例中，4、5、6项是等级水平的三个项。
卡方检验统计量为20.9，有三个自由度，P值为0.00011，表明等级的总体影响在统计上是显著的。
我们还可以检验关于不同等级的系数差异的其他假设。下面我们测试等级=2的系数是否等于等级=3的系数。下面的第一行代码创建了一个向量l，定义了我们要执行的测试。在这种情况下，我们要测试等级=2的项和等级=3的项（即模型中的第4和第5项）的差异（减法）。为了对比这两个项，我们把其中一个项乘以1，另一个项乘以-1。下面的第二行代码使用L=l来告诉R，我们希望以向量l为基础进行测试（而不是像上面那样使用Terms选项）。
wald.test(b , Sigma , L = l) 1个自由度的卡方检验统计量为5.5，P值为0.019，表明等级=2的系数和等级=3的系数之间的差异具有统计学意义。
你也可以对系数进行指数化，并将其解释为概率。为了得到指数化的系数，你要告诉R你要进行指数化（exp），你要指数化的对象叫做coefficients，它是mylogit的一部分（coef(mylogit)）。我们可以使用同样的逻辑，通过对之前的置信区间进行指数化，得到概率及其置信区间。为了把这些都放在一个表中，我们用cbind把系数和置信区间按列绑定起来。
## 概率比 ##概率和95％CI 现在我们可以说，gpa增加一个单位，被研究生院录取（与未被录取）的几率就会增加2.23倍。请注意，截距的几率一般不会被解释。
你也可以使用预测概率来帮助你理解模型。预测概率可以针对分类和连续预测变量进行计算。为了创建预测的概率，我们首先需要创建一个新的数据框架，其中包含我们希望自变量采取的数值，来创建我们的预测。
我们将首先计算每个等级值的预测录取概率，保持gre和gpa的平均值。首先，我们创建并查看数据框架。
data.frame(mean(gre), mean(gpa), factor(1:4)) ## 查看数据框 这些对象的名称必须与上述逻辑回归中的变量相同（例如，在本例中，gre的平均值必须被命名为gre）。 现在我们有了要用来计算预测概率的数据框，我们可以告诉R来创建预测概率。下面的第一行代码非常紧凑，我们将把它拆开来讨论各个部分的作用。newdata1$rankP告诉R，我们要在数据集（数据框）newdata1中创建一个名为rankP的新变量，命令的其余部分告诉R，rankP的值应该是使用predict（ ）函数进行的预测。括号内的选项告诉R，预测应该基于mylogit分析，预测变量的值来自newdata1，预测的类型是预测的概率（type="response"）。代码的第二行列出数据框newdata1中的值。这是预测概率的表格。
predict(mylogit, newdata, type) 在上面的输出中，我们看到，在保持gre和gpa的平均值的情况下，来自最高声望的本科院校（排名=1）的学生被研究生课程录取的预测概率为0.52，而来自排名最低的院校（排名=4）的学生为0.18。我们可以做一些非常类似的事情，创建一个预测概率的表格，改变gre和排名的值。我们将绘制这些图表，因此我们将在每个等级值（即1、2、3和4）上创建100个200至800的gre值。
gre = rep(seq(from = 200, to = 800, length.out = 100), 4), mean(gpa), factor(rep(1:4, each = 100)) 生成预测概率的代码（下面第一行）与之前的相同，只是我们还要提供标准误差，这样我们就可以绘制一个置信区间。我们在链接标度上得到估计值，并将预测值和置信区间都反过来转化为概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c322b02d494c99460464f3d5260ca13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53fcd20fd2c36789c595383892d63e3/" rel="bookmark">
			mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库 MySQL，使用最常用的结构化查询语言(SQL)进行数据库管理(CURD)
MySQL常用命令 连接到mysql服务器
mysql -h[服务器地址/IP] -p[端口号] -u&lt;用户名&gt; -p&lt;密码&gt; -h：目标数据库服务器地址名称或IP地址，本机可以省略此参数 -P：访问应用程序端口号（P必须大写），本机可省略 -u：登录数据库服务器用户名，必须写参数 -p：登录用户密码，必须写参数 查看MySQL数据库信息
&gt; show databases\g &gt; show databases; 使用目标数据库
&gt; use databases_name &gt; use mysql; --使用mysql系统数据库 查看当前数据库中所有表名称
&gt; show tables; 查看数据字符编码集信息
&gt; show variables like 'character%'; 查看命令帮助信息
&gt; ? 或 \? 或 help 看成当前已登录的用户
&gt; select user(); 或 select current_user; 查看数据库表结构信息
&gt; desc table_name; &gt; desc db; 关系型数据库 一行一条记录，一列一个字段。
创建MySQL数据库 DDL 数据定义语言，主要用来创建修改以及删除数据库对象，包括creat，drop，alter …DML 数据操纵语言,主要用来对表中的数据进行增删改操作,包括insert,update,delete…DQL 数据查询语言,主要用来查询数据库表中业务数据,通常包括selec…DCL 数据控制语言，对数据访问权进行控制，包括授与，回收权限操作，主要包括grant以及revokeTCL 事物控制语言，主要在执行事物是使用实现对事物的控制，包括commit，Rollback以及savepoint 数据库创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53fcd20fd2c36789c595383892d63e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77a9303717a99038e6e4dbf9cfb862c5/" rel="bookmark">
			LeetCode 刷题之堆【Python版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. heapq 堆 Python 中只有最小堆：
import heapq a = [] heapq.heappush(a, 3) # 添加元素 heapq.heappush(a, 2) heapq.heappush(a, 1) while len(a): # 判断堆的长度 print(heapq.heappop(a)) # 弹出堆顶元素 # 将列表转换为最小堆 nums = [2, 3, 1, 4, 5, 6] heapq.heapify(nums) while len(nums): print(heapq.heappop(nums)) # 转换为最大堆 nums_1 = [2, 3, 1, 4, 5, 6] max_heap = [] for i in max_heap: heapq.heappush(max_heap, i * -1) # 对当前元素乘 -1 ，取出来后再乘以 -1 2. 数组中的第 K 个最大元素 215.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77a9303717a99038e6e4dbf9cfb862c5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/101/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>