<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a8d7605c7a9bab1c98cd5ab5cd2545/" rel="bookmark">
			caj转pdf在线转换器免费，不限制页数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAJ文献格式是一种常见的文献格式类型，无论是文科还是理科都经常使用。但是很多打印店无法打印CAJ格式的文件，因此需要将其转换为PDF文件。。那么我们怎么把caj文件转化成PDF格式呢？今天我就给大家分享两个caj文件转PDF的好办法。
方法一：记灵在线工具
工具地址：记灵在线工具 - 更专注于发现工具的实用性
1.打开工具，找到【CAJ转PDF】工具。
2.上传需要转换的CAJ文件到服务器进行在线转换。
3.点击确认转换
4.等待文件在云端转换完成，下载转换好的PDF文件。
方法二：CAJViewer阅读器
CAJViewer阅读器又称为CAJ阅读器，是一款用于阅读和编辑CNKI系列数据库文献的专用阅读器。支持多种文档格式、阅读和编辑功能更加方便齐全、对文献的管理功能增强，是一款集体积小、功能强大、占用资源少、使用方便等优点于一身的文献阅读软件。
方法很简单，将CAJ文献转换为PDF格式，可以使用Windows系统自带的虚拟打印功能，将CAJ文献打印成PDF格式即可。不需要安装第三方软件，操作简便。
1、CAJViewer界面，点击文件点击打印
2、打印机选择Microsoft Print to PDF点击确定
3、输入一个文件名，点击保存
这就是CAJ转PDF的两种方法，方法一适合没用CAJ阅读器的情况，大家根据自己的情况选择转换方法即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d37ef71bfcab3628307e6b9e873c46c/" rel="bookmark">
			YOLOv8 目标检测 | 自定义数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了使用用于目标检测的自定义数据训练 YOLOv8 模型。我正在使用来自 kaggle 的 yolo 格式的“Face Mask Dataset”，数据集链接如下：https://www.kaggle.com/datasets/maalialharbi/face-mask-dataset?resource=download
YOLOv8 是目前最先进的 YOLO 模型，可用于目标检测、图像分类和实例分割任务。
我使用 Google Colab 进行训练，如果您有兴趣使用 YOLOv5 对自定义数据进行检查，可是使用下面链接中的代码：https://github.com/Balakishan77/yolov5_custom_traffic_sign_detector。
关于这个用于目标检测任务的数据集：
数据集“Face Mask Dataset”已转换好 YOLO 格式以用于检测任务。它既可以用于训练，也可以用于测试。
图像数据集可以切分如下：
测试：136 =10%
训练：990 = 70%
验证：294 = 20%
总计 = 1420 张图片
图像数据增强是为了增加数据集的大小并使其更强大。图像格式：JPEG、PNG，共有 3 个类：no_mask mask improper_mask。
训练自定义检测模型：
我正在使用 Yolov8m 对口罩数据进行自定义训练。我通过从 Google Drive 读取数据并在 Google colab 上进行训练。以下步骤将详细介绍使用 YOLOv8 在 Mask Data 上进行自定义训练：
配置 Google Colab
YOLOv8 安装
安装 Google Drive
创建 face_mask_detetcion.yaml（数据集配置文件）（YOLOV8格式）
训练我们的自定义口罩检测模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d37ef71bfcab3628307e6b9e873c46c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6025100ac1e3b4abef167631a0ec0d9c/" rel="bookmark">
			计网实验2-网络测速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验准备： win10系统64位计算机 实验概述： 目的：了解你的互联网服务的带宽 了解你的互联网服务的带宽；了解速度测试的工作原理。
速度测试的工作。
任务： 第一部分 使用浏览器（Chrome或Firefox）访问www.speedtest.net。在网站的
在网站上看到的地图上，找到离你的电脑最近的服务器，并命名为服务器A。
同时，选择一个遥远的服务器（至少在1000英里以外），并将其命名为服务器B。
然后，回答下列问题。
(1) 用服务器A进行速度测试，并记录下载带宽。
测得的带宽和你的服务提供商宣传的带宽之间的差异是多少？
相差大约40%
(2) 计算从服务器A和B到你的电脑的传播延迟。
条件:主机之间传输介质长度D=1000km。电磁波传播速度为2*108m/s。则传播延时= 1000km / 2x108m/s = 10x105m / 2x108m/s =5x10-3 s = 5ms
(3)使用问题1中测量的带宽来计算从服务器A到你的计算机的
电脑的带宽-延迟乘积和从服务器B到你的电脑的带宽-延迟乘积。
从服务器B到你的计算机的带宽延迟乘积。
时延带宽积 = 传播时延 * 带宽
A:5ms* 359mbps
B:5ms* 88mbps
第二部分 通过访问这个网站阅读速度测试的工作原理。
https://support.speedtest.net/entries/20862782-How-does-the-test-itself-w
ork-How-is-the result-calculated- 然后回答下列问题
问题。
你认为速度测试所使用的协议是什么？ speedtest是承载在HTTP协议之上的，包括ping测试，下载测试和上传测试（Speedtest.net operates entirely over HTTP for maximum compatibility. It tests ping (latency), download speed and upload speed.）
解释为什么带宽测量更可能是准确的？
如果你使用附近的服务器并从它那里下载小文件，而不是使用远处的服务器 并从它那里下载大文件。 长距离传输会产生无法忽略的传输时延，在网速测量中，我们关注数据在互联网管道中传输的速率。带宽越宽，网速也就越快，其实这不代表延迟低，因为信号都是光速，在不达到带宽瓶颈的情况下，延迟应该是稳定的。当然达到了带宽瓶颈需要排队发送的时候，那延迟肯定就会高了带宽越宽，也就是我们能以更多的频率在网上传输数据，同一时刻可以传输的信号就有更多的频率可以去表示，那么传输的信息就越多。用来表示网络数据传输速率是准确的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6025100ac1e3b4abef167631a0ec0d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102208235fd476e33536ee1ed14f314e/" rel="bookmark">
			因为锁的问题，我们被扣了1万
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 春节放假期间，一个项目上的积分接口被刷，而且不止一个人在刷，并且东西也被兑走，放假晚上被人叫起来排查问题，通过这个人的积分明细观察，基本一秒就能获取一次，远远超过了积分规则限定的次数，这肯定是用脚本了，虽然后期联系死活说自己是正常途径获取。由于是业主，我们还是决定自己来承担这个损失，被项目方从合同中扣除奖品费用1万余元。
问题原因 先说下接口的逻辑层次结构：
–controller 积分获取接口，用PointController表示
–service 积分获取接口service，用PointService表示
我用伪代码来表示整个调用逻辑：
PointController
@RestController public class PointController { @Resource private PointService pointService; @GetMapping(/addPoint) public Response addPoint() { //分布式锁，使用redis的NX命令 RedisDistributedLock lock = new RedisDistributedLock(); //创建一个3s过期，100ms休眠的锁 if(lock.lock("POINT_KEY", 3000L, 100L)) { try { //调用 pointService.addPoint(); } catch (Exception ex) { e.printStackTrace; } finally { //解锁 lock.unlock("POINT_KEY"); } } return Response.ok(getLastPoint()); } } 创建一个分布式锁对象，该分布式锁使用redis的NX命令实现随后创建一个3s过期的分布式锁，以便锁住该新增积分的请求最后在新增积分执行完后，在finally中释放锁最后返回该用户的最终积分 PointService
public class PointService { @Transactional(rollbackFor = Exception.class) public void addPoint() { //查询积分规则 PointRule pointRule = getPointRule(); //查询用户该积分项的积分获取记录总数 Integer total = getPointRecords(); //判断该用户的积分记录总数是否大于 积分规则限定的次数 //大于则不处理，返回 if(total - pointRule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102208235fd476e33536ee1ed14f314e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2774175d2de19aba9dc3a7ebb4269681/" rel="bookmark">
			sqlserver除法保留两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server 中可以使用 ROUND 函数来保留除法的结果的小数位。例如：
SELECT ROUND(column1 / column2, 2) AS result FROM table_name; 其中，ROUND 函数的第一个参数是除法的结果，第二个参数是保留的小数位数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4507ece9bda0216cc7b6e5773a5c0c/" rel="bookmark">
			PFC离散元与3DEC离散元数值模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着我国经济的发展，岩土工程涉及的要求从材料、理论到施工工艺都提出了全方位的系统升级。在岩土工程分析设计中，3DEC和PFC软件快速建模也一直是岩土工作者所关注的问题。3DEC是非连续岩石力学与结构问题的首选分析程序，从岩石边坡失稳的发展研究到地下工程挖掘和岩石地基工程中节理岩体、断层、层理等结构影响的模拟估算，3DEC在复杂行业问题研究有很大优势。而PFC离散元计算方法在岩体的动态、非线性过程的数值计算方面较传统的连续元有独特的优势和进步，在PFC计算中无需给定材料的宏观本构关系和对应的参数，这些传统的参数和力学特性在程序中可以自动得到。离散元数值模拟试验的方法可以解决传统试验造价高、操作繁琐、材料模型复杂等难题，并且可以精确化数值，在科研工作中发挥了非常重要的作用。
以下可以作为学习的参考
PFC离散元仿真核心技术与应用 理论基础及PFC入门
1 岩土工程数值模拟方法概述
1.1基于网格的模拟方法（有限元、有限差分、大变形处理CEL、ALE、XFEM）
1.2基于点的模拟方法（离散单元法DEM、光滑粒子流方法SPH、物质点法MPM）
1.3基于块体的模拟方法
2 离散元与PFC软件操作
2.1 离散元的基本原理（计算原理、宏观参量与微观参量的关系）
2.2 PFC软件界面操作
2.3文件系统
2.4显示控制
2.5帮助文档的使用
FISH、PYTHON语言及COMMAND命令
3 PFC软件的计算控制方法
3.1 PFC计算控制的语言逻辑
3.2 FISH语言（基本语法、函数定义与调用、创建模型、控制模拟过程、处理模拟结果、FISH Callback操作等）
3.3 COMMAND命令（命令结构、创建模型、状态监测与绘图、控制模拟过程、求解控制、状态查询、与FISH语言的混合使用等）
3.4 PYTHON语言（基本语法、Numpy库的使用、接口的使用等）
离散元模拟方法
4 离散元模拟方法
4.1离散元数值试样的生成方法
4.1.1单元试样模型生成方法
4.1.2边值问题（场地）模型生成方法
4.1.3连续—非连续耦合模型生成方法
4.1.4复杂颗粒形状的模拟方法（Rblock方法、Clump方法）
4.2接触模型选择与参数标定
4.2.1离散元接触模型的选择原则—12个内置模型
4.2.2接触模型参数的标定方法与参数意义—以胶结颗粒材料（岩石、胶结砂土等）为例，讲授参数标定步骤
4.3其他问题
4.3.1模型边界条件施加方法（达到初始平衡状态、开挖类模拟、填筑类模拟、加载类模拟、周期性边界、应力伺服）
4.3.2各种阻尼的选择（粘滞阻尼、局部阻尼、滞回接触模型）
4.3.3时步与时步缩放（静力、动力问题时步及相关命令）
4.3.4试样尺寸、颗粒数量、级配选择
4.3.5 并行计算
土体单元试验模拟
5 土体单元试验模拟方法
5.1常规三轴剪切试验模拟(命令流+FISH)
5.1.1建模方法与注意事项
5.1.2模拟结果分析
5.1.3模拟结果可视化
5.2真三轴剪切模拟(命令流+FISH)
5.2.1真三轴加载路径的模拟
5.2.2真三轴强度准则
5.2.3微观结构演变过程
5.3不排水三轴剪切模拟(命令流+FISH)
5.4循环三轴剪切的模拟(命令流+FISH)
5.5颗粒破碎过程模拟(命令流+FISH)
5.6岩石（胶结颗粒）材料的剪切过程模拟
5.7离散元模拟与弹塑性本构模型
工程实例分析
6 工程实例分析
6.1活动门试验模拟(命令流+FISH)
6.1.1试样级配控制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf4507ece9bda0216cc7b6e5773a5c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab88cc797d7a975cb4a0732be61212f/" rel="bookmark">
			Visual Studio 2022调试控制台界面大小设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上大多是关于VS2019控制台大小的设置，关于VS2022的设置很少，特此与大家进行分享。
系统：win11。
软件版本：VS2022。
首先创建一个简单的控制台程序
进行调试
右键打开设置
在启动选项找到启动大小
改为自己喜欢的大小并保存
再次运行程序，可以发现界面大小发生了改变
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10b68df733014bd8e1fda3d01b2e849/" rel="bookmark">
			使用虚拟机完成Hadoop完全分布式的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先要下载好虚拟机VMware workstation，并进行安装。
链接：https://pan.baidu.com/s/1EuNflW8so-xx46qrdCRbDg 提取码：hjl4
2、下载Linux的对应版本，可以通过官网下载。
链接：https://pan.baidu.com/s/1DJ411izE54jI014dgVwekg 提取码：hjl4
3、在VMware上新建三台虚拟机（以示范为主），主机名分别为master、slave1，slave2。
4、创建好虚拟机后，每台虚拟机都要进行以下几步操作。
设置静态IP； 关闭防火墙； 修改主机名； 配置主机名与IP映射； 设置SSH免密登录； 安装Java运行环境； 配置时间同步服务； 设置静态IP
在打开的虚拟机的命令行中输入以下代码，然后回车
vi /etc/sysconfig/network-scripts/ifcfg-ens33 并将以下标记的项进行添加和修改。（修改不了记得切换root用户） IPADDR=192.168.5.130 NETMASK=255.255.255.0 GATEWAY=192.168.5.2 DNS1=114.114.114.114 DNS2=8.8.8.8 要根据自身的电脑去设置IPADDR和GATEWAY。这里只是示例。
关闭防火墙 使用以下命令关闭防火墙
关闭——systemctl stop firewalld.service
永久关闭——systemctl disable firewalld.service（防止重启虚拟机后防火墙重新开启）
查看状态——firewall-cmd --state
修改主机名
vi /etc/hostname 把原本的改为master（其他两台虚拟机是slave1和slave2）
修改完后需要重启虚拟机
shutdown -r now 重启后
配置主机名与IP映射
vi /etc/hosts 添加以下代码
192.168.5.130 master 192.168.5.131 slave1 192.168.5.132 slave2 设置SSH免密登录
在三台虚拟机中都使用以下命令生成密钥。输入命令后一直回车。
ssh-keygen -t rsa 出现以下结果为成功
然后在三个虚拟机都输入以下命令
ssh-copy-id -i ~/.ssh/id_rsa.pub master ssh-copy-id -i ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10b68df733014bd8e1fda3d01b2e849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f9c00445cc24a945a6835e0aa634f7/" rel="bookmark">
			软件测试-python-UnitTest-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnitTest unittest是Python单元测试框架，类似于JUnit框架。
unittest中有4个重要的概念：test fixture, test case, test suite, test runner Testcase： 一个TestCase的实例就是一个测试用例。什么是测试用例呢？就是一个完整的测试流程，包括测试前准备环境的搭建(setUp)，执行测试代码 (run)，以及测试后环境的还原(tearDown)。元测试(unit test)的本质也就在这里，一个测试用例是一个完整的测试单元，通过运行这个测试单元，可以对某一个问题进行验证。
Test suite： 多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite。
Test runner： 是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法。
TestLoader： 是用来加载TestCase到TestSuite中的，其中有几个loadTestsFrom__()方法，就是从各个地方寻找TestCase，创建它们的实例，然后add到TestSuite中，再返回一个TestSuite实例。
Test fixture： 对一个测试用例环境的搭建和销毁，是一个fixture，通过覆盖 TestCase的setUp()和tearDown()方法来实现。这个有什么用呢？比如说在这个测试用例中需要访问数据库，那么可以在setUp() 中建立数据库连接以及进行一些初始化，在tearDown()中清除在数据库中产生的数据，然后关闭连接。注意tearDown的过程很重要，要为以后的 TestCase留下一个干净的环境。关于fixture，还有一个专门的库函数叫做fixtures，功能更加强大。
使用unittest编写python的单元测试代码，包括如下几个步骤： 1、编写一个python类，继承 unittest模块中的TestCase类，这就是一个测试类
2、在上面编写的测试类中定义测试方法（这个就是指的测试用例），每个方法的方法名要求以 test 打头，没有额外的参数。 在该测试方法中 调用被测试代码，校验测试结果，TestCase类中提供了很多标准的校验方法，如 最常见的assertEqual。
3、执行 unittest.main() ，该函数会负责运行测试，它会实例化所有TestCase的子类，并运行其中所有以test打头的方法。
用法 1.用import unittest导入unittest模块
2.定义一个继承自unittest.TestCase的测试用例类，如class xxx(unittest.TestCase):
3.定义setUp和tearDown，这两个方法与junit相同，即如果定义了则会在每个测试case执行前先执行setUp方法，执行完毕后执行tearDown方法。
4.定义测试用例，名字以test开头，unittest会自动将test开头的方法放入测试用例集中。
5.一个测试用例应该只测试一个方面，测试目的和测试内容应很明确。主要是调用assertEqual、assertRaises等断言方法判断程序执行结果和预期值是否相符。
6.调用unittest.main()启动测试
7.如果测试未通过，则会显示e，并给出具体的错误（此处为程序问题导致）。如果测试失败则显示为f，测试通过为.，如有多个testcase，则结果依次显示。
代码
import unittest # class FirstTest(unittest.TestCase): # # def test_1(self): # print("test_1") # # def test_2(self): # print("test_2") # # # if __name__ == '_main': # unittest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f9c00445cc24a945a6835e0aa634f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87109b8be2924ae6d568f3b533f42fc1/" rel="bookmark">
			接口自动化测试-python-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 接口测试：是对系统或组件之间的接口进行测试，主要是校验数据的交换、传递和控制管理过程，以及相互逻辑依赖关系。
自动化测试：是把以人为驱动的测试行为转化为机器执行的一种过程。
实现方式 使用接口测试工具来实现，比如：JMeter
通过编写代码来实现
接口测试工具的不足 1.测试数据不好控制
2.不方便测试加密接口
3.扩展能力不足
Requests库 介绍
Requests库是用Python编写的，基于urllib，采用Apache2Licensed开源协议的HTTP库；相比urllib库，Requests库更加方便，可以节约我们大量的工作，完全满足HTTP测试需求；
安装
pip install requests 发送请求
常见的HTTP请求方式：GET、POST、PUT、DELETE、HEAD、OPTIONS
使用requests发送网络请求非常简单，只需要调用HTTP请求类型所对应的方法即可。
GET请求 import requests response = requests.get("http://www.baidu.com") 请求方法的返回值response为Response对象，我们可以从这个对象中获取所有我们想要的响应信息。
POST请求 import requests #:paramurl:请求的URL #:paramdata:(可选)要发送到请求体中的字典、元组、字节或文件对象 #:paramjson:(可选)要发送到请求体中的JSON数据 #:rtype:requests.Response response=requests.post(url,data=None,json=None) 其他请求类型 import requests response=requests.put("http://www.baidu.com",data={"key":"value"}) response=requests.delete("http://www.baidu.com") response=requests.head("http://www.baidu.com") response=requests.options("http://www.baidu.com") 传递URL参数 如果需要在URL的查询字符串中传递数据，可以使用params参数来定义，params传递的参数可以是字符串或字典。
import requests response=requests.get("http://www.baidu.com",params="kw=python") print(response.url)#http://www.baidu.com/?kw=python params={"k1":"v1","k2":["v2","v3"]} response=requests.get("http://www.baidu.com",params=params) print(response.url)#http://www.baidu.com/?k1=v1&amp;k2=v2&amp;k2=v3 响应内容 请求方法的返回值response为Response对象，我们可以从这个对象中获取所有我们想要的响应信息。
response.status_code 状态码 response.url 请求url response.encoding 查看响应头部字符编码 response.headers 头信息 response.cookies cookie信息 response.text 文本形式的响应内容 response.content 字节形式的响应内容 response.json() JSON形式的响应内容 JSON响应内容 如果请求响应的内容为JSON格式的数据，则可以直接调用response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87109b8be2924ae6d568f3b533f42fc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/818704aaaa4c5b53ec998240d7d372f6/" rel="bookmark">
			JS 加减乘除丢失精度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js在加减乘除时对浮点型数据有丢失精度问题 比如 0.1+0.2≠0.3；得到的却是0.300...0004，为了防止这个问题可以用一下方法来处理 export default { /** * 数字相加 * @param {*} arg1 * @param {*} arg2 * @returns */ accAdd (arg1, arg2) { return this.changeNum(arg1, arg2) }, /** * 数字相减 * @param {*} arg1 * @param {*} arg2 * @returns */ accSub (arg1, arg2) { return this.changeNum(arg1, arg2, false) }, /** * 数字相乘 * @param {*} arg1 * @param {*} arg2 * @returns */ accMul (arg1, arg2) { let m = 0 m = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/818704aaaa4c5b53ec998240d7d372f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7c457c3cc21827665c408df1e390c3/" rel="bookmark">
			idea 打开项目后卡顿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对不起，IntelliJ IDEA 打开项目后卡顿是一个常见问题，有以下几种可能的原因:
计算机硬件配置低：如果你的计算机配置较低，特别是内存不足，则可能会导致卡顿。
项目太大：如果项目文件太大，IntelliJ IDEA 可能需要很长时间来加载所有文件，导致卡顿。
插件过多：如果安装了过多的插件，IntelliJ IDEA 可能需要很长时间来加载和初始化它们，导致卡顿。
为了解决这个问题，你可以尝试以下措施：
升级计算机配置：尽量保证计算机配置较高，特别是内存。
减小项目大小：尽量减小项目文件大小。
卸载不需要的插件：卸载不需要的插件，减少
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e544a186c99425b7604b8878da1c27/" rel="bookmark">
			elementplus 上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 form-data格式上传代码示例如下： &lt;el-upload class="upload-img" action="" :on-remove="handleRemove" :before-upload="beforeUpload" list-type="picture" :file-list="fileList" &gt; &lt;el-button size="small" type="danger"&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; // 使用上传文件之前的钩子来进行自定义文件上传 beforeUpload(file,id) { let fd = new FormData() fd.append('file', file) const obj = { name:'', file:'' } dataSet.fileList = [] axios.post('/api/common/upload', fd, { headers: { 'Content-Type': 'multipart/form-data' } }).then(res=&gt;{ // 上传成功，返回图片完整路径 console.log(res); }) // 阻止默认的上传操作, 就不会产生如下图action为空报404错误的情况 return false; }, 二、从File对象中读取图片数据 (base64格式) 示例 //图片转64格式 //处理上传的图片 getFile(file, fileList){ console.log(file) methods.getBase64(file.raw).then(res =&gt; { // dataSet.imgObj.name = file.name; // dataSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7e544a186c99425b7604b8878da1c27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d28df672032caa49679004bb4c688d/" rel="bookmark">
			python 爬虫去获得省市区县的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：发现以前项目里面的地区还是以前规划的，而杭州去年划分了新的区域，所以就要重新获取一份新的区域表了。这边使用了python去爬虫新的数据。
最新的区域url是：2022年统计用区划代码
以前写的都是java，这次用了python就要装一下环境啥的（以前没事配置了flutter就已经配置了pytnon），但是还要有requests，beautifulBase4，lxml。
pip install requests pip install bs4 pip install lxml //我是python3，这边用了pip3 在idea的插件库中添加python插件 直接贴一下python的代码（面向百度开发了）哈哈哈哈 #!/usr/bin/env python # -*- coding: utf-8 -*- """ 利用BeautifulSoup爬取省、市、区、街道、办事处五级地址 author: gxcuizy date: 2018-11-01 """ import requests from bs4 import BeautifulSoup from urllib import parse import json import os from datetime import datetime import threading class GetCity(object): """爬取国家统计局省、市、区、街道、办事处五级地址""" # 地址 url = 'http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2022/' def __init__(self): """初始化属性""" self.json_folder = 'json' self.json_file = {'province': 'province.json', 'city': 'city.json', 'county': 'county.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d28df672032caa49679004bb4c688d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500e4b67a4c4814c8e18010635d553f8/" rel="bookmark">
			怎么爬取链家小区的省市区、名称、房价、户数、建成年份等数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要爬取链家小区的数据，您需要掌握一些编程知识，特别是网络爬虫的技巧。具体步骤如下：
分析网页：打开链家网站，找到要爬取的小区信息页面，分析网页的结构和数据存储方式。
编写爬虫代码：根据网页结构和数据存储方式，使用编程语言(如Python)编写爬虫代码，获取网页中的数据。
解析数据：对爬取的数据进行解析，提取所需的省市区、名称、房价、户数、建成年份等数据。
存储数据：将提取的数据存储到本地文件或数据库中，方便后续的数据分析和使用。
请注意，爬取网站的数据可能存在法律风险，在爬取前请仔细了解相关法律法规，并且尽量遵守网站的爬取规则。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd52590050ae968710967600cf29306/" rel="bookmark">
			打开遥感raw格式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开raw文件
①通道深度选择16位
②通道字节顺序选择IBM PC（8）
③尺寸根据原始图像尺寸填写，（3000或者1500）
④删除高度中的像素大小，点估算，出来高度像素大小
⑤好，打开图片
⑥图像-调整-自动对比度，调整图像的亮度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc282f427582830bc54c8a5611179cd/" rel="bookmark">
			【Chrome谷歌浏览器安装vue.js.devtools】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Chrome谷歌浏览器安装vue.js.devtools--离线安装记录 下载离线包下载地址：https://github.com/vuejs/devtools 解压文件：执行npm run build找到谷歌扩展程序加载工具安装后效果 下载离线包 下载地址：https://github.com/vuejs/devtools 在1处切换到分支add-remote-devtools,下载zip格式
解压文件： 进入刚下载的文件路径，解压，win+R打开运行窗口，执行npm i
执行npm run build 找到谷歌扩展程序 找到扩展程序
加载工具 安装后效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e523d7dbc6e7f3e3b35c68ae7c02dfe/" rel="bookmark">
			Jmeter接口关联技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取token
1、创建线程组–添加http请求
2、添加获取token接口
3、添加查看结果树
4、提取tonken
1）json提取器
步骤：添加–后置处理器–JSON提取器
json表达式格式：$.提取值的变量名称
2）正则表达式提取器
步骤：添加–后置处理器–正则表达式提取器
正则表达式：提取内容的正则表达式
() ---- 括起来的部分就是需要提取内容
. ---- 点号表示匹配除换行符 \n 之外的任何字符串
---- 匹配一次或多次 ？ ---- 在找到第一个匹配项后停止
如果匹配到在正则表达式中有多个正则表达式
$0$：表示取所有值，取正则表达式中所有的值，也就是非括号与括号中所有的值 $1$：表示取第一个()中的值 $2$：表示只取第二个()中的值 $n$：表示取第n个()中的值 $1$,$2$：表示取第一个()与第二个()中的值，注意：第一个括号中的值与第二个括号中的值连接方式就依赖于它们之间是用什么分隔符，如$1$,$2$，它们之间是用逗号来分隔的，那么取到的第一个值与第二个值连接方式就是逗号分隔，这个下面举例会说明的 匹配数字：根据正则表达式所能匹配到的值
0 ---- 代表随机取一个值
-1 ---- 代表取出所有值，但是这种情况下引用变量时，就必须要指名引用哪个变量值，如引用名称是token，那么后续引用此变量时，就需要用 t o k e n 1 或 {token_1}或 token1​或{token_n}来匹配对应的值
1 ---- 代表取第一个值
2 ---- 代表取第二个值
n ---- 代表取n个值
缺省值：如果正则表达式没有搜找到值，则使用此缺省值
检查是否提取成功可以通过添加调试取样器和查看结果树来查看 添加调试取样器步骤：线程组--添加--取样器--Debug Sampler 5.关联接口
在其他接口中需要使用Token的地方使用${Token}调用Token
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c8695045834ff954e5a2e794fec0f9/" rel="bookmark">
			windows 上Miktex的镜像源最新配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 上Miktex的镜像源最新配置方法 安装完Miktex之后，试了试网上的例子，发现要安装包，但是默认的国外的（反正连接失败），就去搜如何更换国内镜像源，然而，然并卵，特别是一个百度的一篇老文章，老是搜到它，很生气。
因为现在新版本的 Miktex control 找不到配置镜像源的地方了，只能用命令行的形式。
软件版本和下载地址 basic-miktex-21.8-x64.exe
Note: 最新的版本可能不好用， 尽量用这个版本
第二个就是Miktex control
然后打开命令行
更换前注意点击“更新”中进行更新
然后查找能用的镜像源
mpm.exe --list-repositories
然后更换镜像源（我选的是第一个）
如果上一步出现错误， 注意在“更新”中进行更新， 更新过后再执行下上面的配置
然后就可以在下图搜索安装了，（或者它自动安装）
清爽，哈哈哈哈啊哈哈哈哈哈哈哈啊哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12713e89d2587e65f6fc4ae04662dca/" rel="bookmark">
			金额小写转大写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// val是金额可以是数字/字符串 len是小数点后几位，默认2位 const formatUpper = (val, len = 2) =&gt; { let n = val.toString(); const flagLen = typeof len !== 'number' || (typeof len === 'number' &amp;&amp; (len &lt; 0 || len &gt; 6)); if (!val) { return; } if (!/^(0|[1-9]\d*)(\.\d+)?$/.test(n) || flagLen) { return '数据非法'; } let unit: string = '千百拾亿千百拾万千百拾元角分厘毫微纳皮'; let str: string = ''; const p: number = n.indexOf('.'); n += '0'.repeat(len); const unitFrac: number = unit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c12713e89d2587e65f6fc4ae04662dca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f13b1ad7a82ca59f86e68ff66fd85f0/" rel="bookmark">
			Module build failed (from ./node_modules/sass-loader/dist/cjs.js):
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因 node node-sass node-loader版本号没对上
处理 打开cmd输入node -v判断版本号
根据node版本号判断对应的node-sass版本号
根据node-sass版本号判断node-loader版本号
sass-loader 4.1.1，node-sass 4.3.0
sass-loader 7.0.3，node-sass 4.7.2
sass-loader 7.3.1，node-sass 4.7.2
sass-loader 7.3.1，node-sass 4.14.1
sass-loader 10.0.1，node-sass 6.0.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893bac4f2ce59dbcbcb183a514c38bb6/" rel="bookmark">
			web 自动化如何用代码查询浏览器的默认下载路径？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		曾经接触到一个保密检查的项目，我就负责这一块的开发，但因为种种原因，最后还没来得及向团队提交代码，所幸代码有所保存，分享如下：
首先是针对火狐浏览器，代码如下：
from selenium import webdriver # 创建浏览器对象 driver = webdriver.Firefox() # 获取浏览器的默认下载路径 download_dir = driver.capabilities["moz:profile"]["path"] # 打印默认下载路径 print("默认下载路径为：", download_dir) # 关闭浏览器 driver.quit() 然后是谷歌：
```python from selenium import webdriver # 创建浏览器对象 options = webdriver.ChromeOptions() options.add_experimental_option("prefs", { "download.default_directory": "/path/to/default/download/directory", "download.prompt_for_download": False, "download.directory_upgrade": True, "safebrowsing.enabled": True }) driver = webdriver.Chrome(chrome_options=options) # 获取浏览器的默认下载路径 download_dir = driver.capabilities["chrome"]["download.default_directory"] # 打印默认下载路径 print("默认下载路径为：", download_dir) # 关闭浏览器 driver.quit() 针对windows自带的浏览器，代码如下：
import winreg def get_ie_download_folder(): key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\Microsoft\Internet Explorer\Main') download_folder, _ = winreg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893bac4f2ce59dbcbcb183a514c38bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6b6d4357eb1a8e39aeb803fc95d161/" rel="bookmark">
			el-upload组件的文件回显功能和添加文件到elupload组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省流： 先获取这个文件对象，使用handleStart方法添加到组件。
this.$refs.uploadRefName.handleStart(rawfile); 在开发的时候遇到表单里需要上传图片的功能。看了下el-upload组件的使用方法，在修改表单的时候，el-upload组件的回显遇到了麻烦：
过程：
根据一开始的理解，按照其他教程的方法，向file-list里添加一个文件对象[{name: "aa", url: http:xxxxxxxx}]就可以。
我尝试加入一个图片的url（后来发现那并不是一个直接的url路径，而是一个get的请求路径,这可能是我添加filelist不成功的原因，暂没验证），发现组件里的文件列表一直显示不成功，后来尝试new了一个File对象，成功在文件列表里显示成功，但是在before-upload钩子函数中却找不到这个文件，传过来的参数file一直是undefined，而file-list里有这个文件对象，但是属性和其他文件对象千差万别。
思考： 到这里我感觉向file-list加入自己new出来的文件对象并不是向upload组件上传文件，而是向uploadList这个组件（el-upload的子组件），然后显示到对应div和file-list
这种行为和点击区域从本地选择文件进行上传不一样，并不是把文件对象加入组件。
在编辑表单回显的时候，假如对upload这个组件没有做任何更改，点击提交是不会通过beforeupload钩子函数的验证的，这说明组件里并没有文件对象，往file-list添加文件对象没有真正的添加进去。
我的需求： 我需要在编辑表单回显的时候，把文件对象加入到组件中，用于通过beforeUpload钩子函数的验证和上传文件对象到后台。
解决办法：
然后我开始查找如何向el-upload组件添加组件，官方文档里并没有提供手动加入file对象的方法，百度了下发现也没有关于加入文件到el-upload组件的内容。
遂去看了下源码。elementUi对这个组件的实现就300来行，看了后发现有个handleStart方法用于获取增加文件对象，根据上文提到的url路径问题，我用xmlhttprequest方法get到这个文件对象，然后用handleStart方法成功添加到组件，通过了钩子函数验证，成功传到后台。代码如下
//给upload组件添加文件 addFile(url, iamgeName) { var blob =null; var xhr = new XMLHttpRequest(); xhr.open("get", url); xhr.setRequestHeader('Accept', 'image/png'); xhr.responseType = "blob"; xhr.onload = () =&gt; { blob = xhr.response; let imageFile = new File([blob], imageName, {type: 'image/png'}); console.log(imageFile); //el-upload组件的添加文件方法 this.$refs.upload.handleStart(imageFile); }; xhr.onerror = (e) =&gt; { }; xhr.send(); } 说了这么多废话，有用的就一句，用handleStart方法添加文件对象到组件，也可能是我的url问题导致filelist没有把文件对象真正加入进去，还没验证，懒得验证了。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204b0994876d98e36aa8ed31e25bfdac/" rel="bookmark">
			centos7开机报错bash:cannot set terminal process group (-1):Inappropriate ioctl for device的解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几日服务器突然无法正常连接，一直没时间处理，今日进入机房查看发现服务器已重启，停在了启动过程中，报错如图：
大致的意思是检查文件系统时到某个文件出错了，异常的文件是
/dev/mapper/vg_hljtnits-lv_home
报错信息如下：
bash:cannot set terminal process group (-1):Inappropriate ioctl for device
bash:no job control in this shell
说实话第一次遇到过，对于这种报错很懵逼，不知道如何处理，只能询问网友并在搜索引擎上查找相关信息。
试了下大家出的主意，也尝试了不少在搜索引擎上查到的方法，最后使用了在这个链接中的方法解决的问题：
https://blog.csdn.net/Will_cruise/article/details/102958828
处理过程如下：
根据屏幕提示让我们输入root密码或按ctrl+D继续，我尝试按ctrl+D，服务器继续启动过程然后报错退出，自动重启。
再次进入这个画面，输入了root密码之后手工重启服务器，依然报错停止在这个画面。
在找到了上面的链接内容后使用fsck命令来检查并处理不一致的异常文件。
fsck -y /dev/mapper/vg_hljtnits-lv_home
#命令解释：
#fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查
#-y : 选项指定检测每个文件是自动输入yes
执行以上命令后进入检查和修复阶段，略作等待之后进入命令行状态，此时检查与修复完成，输入shutdown -r now重启系统，恢复正常。
经验总结：应该是服务器非正常重启之后导致了系统文件异常，用fsck命令检查异常文件和目录并修复了问题，有点类似于windows以前我们经常遇到的开启后蓝屏状态下的系统文件自检。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88de2c84d10455d7bfaaee97f582523e/" rel="bookmark">
			Vue3路由守卫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由守卫 分类：
全局守卫
单个路由守卫
组件内部守卫
一.全局守卫 全局前置守卫beforeEach 场景：
用户页面是否跳转到登录界面，是否有权限跳转到某个页面 定义：
beforeEach()全局前置守卫：初始化时执行、每次路由切换前执行；
三个参数：
to：要跳转到的目标路由
from：从当前哪个路由进行跳转
next：不做任何阻拦，直接通行，该往哪个路由跳转就往哪个跳转
route中有一个配置项是meta，专门提供给我们，在meta项中配置自己的属性与值，可用于在守卫中的权限判断
//前置路由 import { userStore } from '../store/userInfo'; router.beforeEach((to, from, next) =&gt; { const store = userStore(); //判断是否有权限返回登录界面 if (from.meta.isAuth) { if (store.userInfo.token) { next() } else { next("/login") } } else { console.log("没有权限"); next() } }) 全局解析守卫beforeResolve 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置(用的不多)
全局后置守卫afterEach 对于分析、更改页面标题、声明页面等辅助功能都很有用
//后置路由 router.afterEach((to, from) =&gt; { console.log("全局后置路由守卫"); //设置跳转路由后页面的标题 document.title = to.meta.title as string }) 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88de2c84d10455d7bfaaee97f582523e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe4819631bda72c48d710128b84da48/" rel="bookmark">
			利用python倒置所输字符串的顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 目的
二、思路与方法
python菜鸟一只，本文仅供自己记录，所写代码难免有猫饼，如有错误以及可以改进的地方，还请各位多多海涵，不吝赐教。
一、 目的 如题，用python将输入的字符串倒置。倒置情况如下：
1. 输入字符串（内无空格）“abcd1234”
返回：“4321dcba”
2. 输入一串英文单词，进行单词内部倒置：
输入：“hello world”
返回：“olleh dlrow”
3. 输入一串英文单词，进行单词顺序倒置：
输入：“hello world”
返回：“world hello”
二、思路与方法 1. 首先明确，字符串有索引，字符串中第一个字符的索引为0，其他字符的索引按从左到右顺序依次+1
a b c d
0 1 2 3
如果按倒序进行索引，则字符串中最后一个字符的索引为-1，其他字符的索引按从右到左的顺序依次-1
a b c d
-4 -3 -2 -1
预期实现的是将【输入】的字符串反转，需要明确，我们不知道输入的字符串中一共有几个字符。
于是用到for循环，遍历字符串中字符数：
k = "" m = 0 for i in a: m -= 1 k += a[m] print(k) 其中i是遍历的内容，但是我们不需要这些字符，于是没有用到i。m为字符串的索引。
k为空字符串，用来装倒置结果。
字符串的拼接用运算符即可。
（以上内容可以封装为一个函数，后面的内容就可以用到这个函数了）
def re(a): # 将输入的字符串倒置 m = 0 k = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffe4819631bda72c48d710128b84da48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e52b1953365ed020361f0420e47551/" rel="bookmark">
			用VScode写一个简单html网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Visual Studio Code 写一个简单的 HTML 网页可以通过以下步骤完成：1.打开 Visual Studio Code；2.新建一个文件，可以使用 .html 作为文件后缀名；3.编写 HTML 代码；4.保存文件；5.使用浏览器打开新建的 HTML 网页文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccaeefab01865b5177af9b1b1414eb44/" rel="bookmark">
			Docker部署Openldap和phpLDAPadmin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、LDAP概念：
LDAP是轻量级目录访问协议，英文全称是：LightWeight Directory Access Protocol，一般称为LDAP。
按照我们对文件目录的理解，LDAP可以看成是一个文件系统，类似目录和文件树。
2、LDAP软件：
LDAP是一个协议。
LDAP产品：Microsoft的ActiveDrectory，Lotus的Domino Directory、IBM的WebSphere中也集成了LDAP服务。
LDAP的开源实现是OpenLDAP。
3、OpenLDAP介绍：
OpenLDAP是最常用的目录服务之一，提供了目录服务的所有功能，包括目录搜索，身份认证、安全通道、过滤器等。
大多数的Linux发行版里面都带有OpenLDAP的安装包。
OpenLDAP服务默认是使用非加密的TCP/IP协议来接收服务的请求，并将查询结果传到客户端。
由于大多数目录服务都是用于系统的安全认证部分比如：用户登录和身份验证，所以它也支持使用基于SSL/TLS的加密协议来保证数据传送的保密性和完整性。
OpenLDAP是使用的OpenSSL来实现SSL/TLS的加密通信的。
4、LDAP的信息模型：
LDAP的信息模型是建立在目录entries的基础上。
一个条目是一些属性的集合，并且具有一个全局唯一性的可区分名称DN, 一个条目可以通过DN来引用。
每一个条目的属性具有一个类型和一个或多个值。
类型通常是容易记忆的名称，比如cn是通用名称common name，或者mail是电子邮件。
条目的值的语法取决于属性类型。比如cn属性可能具有一个值“Babs Jensen”。
一个mail属性可能包括"test@123.com”
5、LDAP的objectClass
LDAP通过属性objectClass来控制哪一个属性必须出现或允许出现在一个条目中，它的值决定了该条目必须遵守的模式规则。可以理解为关系数据库的表结构。
6、LDAP的常用关键字：
LDAP的entry是由各种字段构成，可以理解为关系数据库的字段。
7、OpenLDAP的部署：
7.1 拉取相关镜像：
docker pull osixia/openldap docker pull osixia/phpldapadmin 7.2 运行容器openldap:
docker run \ -d \ -p 389:389 \ -p 636:636 \ -v /usr/local/ldap:/usr/local/ldap \ -v /data/openldap/ldap:/var/lib/ldap \ -v /data/openldap/slapd.d:/etc/ldap/slapd.d \ --env LDAP_ORGANISATION="changchunhua" \ --env LDAP_DOMAIN="changchunhua.cloud" \ --env LDAP_ADMIN_PASSWORD="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccaeefab01865b5177af9b1b1414eb44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c482c75585ac30143b19da8e5dfe29/" rel="bookmark">
			js-file-download ，文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导出文件接口 1，安装js-file-download npm install js-file-download 2，引入文件
import fileDownload from 'js-file-download' 3，代码部分
exportFile () { axios.get(url地址, { responseType: 'blob', // 头部参数 headers: { 'Authorization': token, }, // 请求参数 params: { year: 2023, town: '330100', } }).then(res =&gt; { fileDownload(res.data, '附件' + '.xls') }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d2c3d33d22c4da34698518d3b3376e/" rel="bookmark">
			appstore构建版本的windows上传方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在appstore上架应用的时候，会遇到一个问题，我们需要将打包好的苹果应用ipa文件上传到appstore的构建版本里面，但是appstore提示，这个上传需要安装xcode或transporter等软件，这些软件只能安装在mac电脑上，安装这两个软件很麻烦，首先要有mac电脑，然后安装的体积还非常大，还要升级操作系统才能安装。
因此我们这个教程将教会大家如何通过windows电脑上传ipa文件到构建版本。
没有mac，我们可以使用香蕉云编来上传,香蕉云编地址：
地址：https://www.yunedit.com 登录香蕉云编，进入上传ipa的控制台，上传ipa,如下图界面
上传的步骤中，它会要求我们输入苹果开发者中心的账号和专用密码，注意这里输入的是需要专用密码，不是登录密码，不要搞错了哦，专用密码你可以参考香蕉云编上传界面的教程去设置。
上传成功后，大概过30分钟，就可以在构建版本里见到了。
然后回到app store connect，填写其他资料，就可以上架提交人工审核了，过程中它会要求我们提供各尺寸APP的截图，然后你没有真机截图，你可以使用香蕉云编的合成图片功能来生成截图，由于生成的过程比较简单，这里就不一一说明了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e408539d03e9b7f8f92141686b30d9de/" rel="bookmark">
			python编写一个指纹识别器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要编写一个指纹识别器，首先需要一个指纹扫描仪或摄像头来获取指纹图像。然后，可以使用图像处理算法对图像进行预处理，以确定关键特征。接下来，可以使用比对算法将该特征与数据库中的指纹进行比对，以确定匹配。
具体的实现方法可以使用各种图像处理库，例如OpenCV或scikit-image。可以先了解指纹识别的基本原理和算法，再根据需要编写代码。
以下是一个简单的示例代码：
import cv2 # 读取指纹图像 img = cv2.imread("fingerprint.jpg", 0) # 进行图像预处理，提取特征 features = extract_features(img) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4facaa56915dd3c6e2bb59211c22156/" rel="bookmark">
			三种循环的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、了解循环
JS循环的概念
循环就是重复做一件事, 在程序中指的是重复执行某段代码.. 不成立为止.
如: 大家每天早上7点起床, 9点上课, 12点吃饭, 19点晚自习, 21点下课, 23点睡觉, 第二天又重复7点起床, ….. , 直到毕业找到工作就可以跳出这个循环.
2.死循环的概念
死循环就是重复执行代码, 不会停止.
死循环会造成程序卡死甚至崩溃等问题, 我们不能写会造成死循环的代码.
3.循环的用处
循环的用处非常广泛, 特别是对大量的数据进行操作的时候,
如：求若干个数之和； (重复做加法)
求某个班全部学生的总成绩；(重复做加法) 4.循环的分类
循环有很多种方式, 如: while, do-while, for, for-in, for-each等.
这里我们先介绍最常见的,也是很多其他计算机语言通用的三种方式:
1). while循环 2). do-while循环 3). for循环
二、常用的循环语句
1.while 循环
while循环语法格式:
while(表达式)
{
执行代码;
}
注意：1, while循环必须按照上述语法格式来写, 只能更改表达式内容和执行代码.
2, 表达式可以是常量,变量或者其他表达式,该表达式会被强制转换为boolean类型, 可以理解表达式就是循环 的条件, 条件成立则进入括号{}里面执行代码，否则不进入；
3, 执行代码可以有多行, {}所包含的称为循环体.
4, 表达式不要一直是true, 避免死循环.
5. while循环的顺序是: 先判断表达式是否为true, 若true则执行执行代码, 然后再继续判断表达式是否为true, ….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4facaa56915dd3c6e2bb59211c22156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6ccea6fc7b2ee921981b5e945ec8a8/" rel="bookmark">
			最快的排序算法是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最快的排序算法是基数排序。基数排序是一种非比较型排序算法，它的时间复杂度可以做到 O(n)，在数据规模较大时效率非常高。基数排序的基本思想是将数据按照位数分组，然后按照每一位的数字大小对数据进行排序。基数排序适用于数据规模较大，且数据的数值范围不是很大的情况。
不过，在实际应用中，最快的排序算法并不是唯一的考虑因素。在数据规模较小时，插入排序、选择排序等排序算法的时间复杂度都很小，也可以很快地完成排序。在实际使用中，应根据具体情况选择合适的排序算法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e1812293e5d6fece8775ae5a4c24420/" rel="bookmark">
			DIY NAS服务器之OMV 5.6入坑指南（六） -debian终端菱形乱码修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 DIY NAS服务器之OMV 5.6入坑指南（一）- openmediavalut 5.6安装
DIY NAS服务器之OMV 5.6入坑指南（二）- 安装omv-extras插件
DIY NAS服务器之OMV 5.6入坑指南（三）- 切换系统源
DIY NAS服务器之OMV 5.6入坑指南（四）- 安装docker和Portainer
DIY NAS服务器之OMV 5.6入坑指南（五）- 数据同步及管理
DIY NAS服务器之OMV 5.6入坑指南（六）- debian终端菱形乱码修复
目录
系列文章目录
前言
一、最终结论
二、尝试的方法
前言 本节主要是openmediavalut 系统下的debian终端出现菱形乱码问题，强迫症状态下想着能不能修复一下而进行的一些努力。
一、最终结论 先放上个人努力后的最终结论：
最终无法修复菱形乱码问题，尝试的方法无效。
下面命令可以用来设置默认语言
dpkg-reconfigure locales
dpkg-reconfigure tzdata
二、尝试的方法 如下记录努力过程方法
最简安装debian的时候由于没有中文字库，若选择看中文环境会出现菱形乱码。
注：上面这个图是网上找的，当时没记录，将就参考一下吧。
先把zh.utf8换为us.utf8看着好顺眼些。
# aptitude install locales
dpkg-reconfigure locales
跳出一个文字选择界面（如果安装时选择中文，此时文字全是乱码），page up/down 翻页、空格键选择以下编码
en_US.UTF-8 UTF-8
zh_CN.GBK GBK
zh_CN.GB2312
zh_CN.UTF-8 UTF-8 然后 Tab 鍵切换到 OK，最后默认语言选择 en_US.UTF-8
OK后会出现如下提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e1812293e5d6fece8775ae5a4c24420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bff76c5002b917115e6ade74041617f/" rel="bookmark">
			React项目运行默认打开Chrome浏览器和取消打开浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react 取消每次运行项目默认打开浏览器 在package.json 文件中将 "start": "node scripts/start.js"修改为set BROWSER=none &amp;&amp; node scripts/start.js
"scripts": { "start": "set BROWSER=none &amp;&amp; node scripts/start.js", "build": "node scripts/build.js", "test": "node scripts/test.js" }, 运行成功之后，不会自动打开浏览器，需要我们复制url在浏览器中打开，
React项目运行默认打开Chrome浏览器 在在package.json 文件中设置"start": "set BROWSER=chrome&amp;&amp; node scripts/start.js",
"scripts": { "start": "set BROWSER=chrome&amp;&amp; node scripts/start.js", "build": "node scripts/build.js", "test": "node scripts/test.js" }, 运行项目之后会自动打开chrome浏览器
注意，chrome和&amp;&amp;之间不要有空格，否则，浏览器不会启动。
在设置时，开始在chrome后面加了空格，运行项目时chrome浏览器没有打开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91dee59304b671783bb3195915033fb9/" rel="bookmark">
			敏捷设计的的4个核心思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自《互联网产品之美》。
4个核心思想
1、强调面对面的沟通，也就是说沟通很重要，任何人的相互交流胜于任何流程和工具；
2、要把精力集中在可执行的程序上，可以运行的产品胜于综合性文档，也就是强调了原型、模型、演示等的重要性；
3、团队合作和团队激励，合作胜于谈判，敏捷开发能将需求分析、开发、测试等全部团队成员融合成一个整体，大家都是“一条线上的蚂蚱”；
4、团队成员要有超强的适应能力，适应变化胜于按部就班，敏捷开发的特点就是快速，对于互联网行业来说，这点非常重要。
敏捷设计强调的是团队成员的高度参与，目的就是要让大家统一认识，把团队的目标变成每个人的工作目标，并得到每个团队成员的认同，
形成高度的凝聚力，以达到群策群力、高效协作的效果。
在敏捷设计过程中，由于没有高度细化的文档，成员之间交互信息的唯一渠道就是面对面沟通，良好的团队氛围和协作关系促进了这种沟通，
并使得消息有效传达。
上面几段话，总体比较靠谱，文档方面值得进一步探讨。
下面是自己的3点看法：
1、老外提出的很多概念、想法，可能是有一定的适用场景，也有可能是到了国内就“水土不服”，因为国内极度强调效率等特色化的东西。
懂得自然都懂。
我所经历学习到的：UML统一建模语言、敏捷开发、领域驱动设计、单元测试（国内普遍都是“伪”单元测试）。
概念都挺好，就是难以落地。
2、敏捷开发
国内存在非常推崇敏捷开发的人群，也有很多相关书籍和实际。
在xx厂xx团队期间，有幸参与了“敏捷开发”模式。
总的观点：“新瓶装旧酒，换汤不换药”。其实，很难见到全新的事物和方法论，通常只是名字不同，但内涵其实都差不太多。
比如，敏捷开发的特有实践：早会、晚会、看板、认领工作和工时、master角色。
存在不接地气或者无法“普试”的做法。
1）、快速开发、快速上线。
普遍存在一种现象，很多上游人群对“敏捷开发”的直观认识，就是：我提出一个需求，你们赶紧开发，赶紧上线。
单方面强调，加班加点干活。
“敏捷开发”成了让下游加班干活，快速出成果，廉价劳动力的借口和幌子。
2、早会和晚会
对于很多场景来说，会开多了，没啥意思，除了浪费时间。
1天大概就8小时，除去开会，进度不会那么明显。
频繁的开会，哪有这么快的进度更新。
如果跨部门、跨项目或者人员较多时，每个人的节奏根本就不同，比如上班下班时间点。
3）、看板
需求方或者大家之间，对别人的工作，根本没那么在乎。
如果是需求方和进度管理有需要，直接1个在线Excel表格或wiki页面即可。
纸质看板，写纸条、描述任务、贴纸条，已经过时啦。
通常来说，老板要的是：总的进度计划、里程碑节点、好的结果，提出需要协调解决的问题，任务细节没那个功夫关注。
结果优先。
4）、认领工作和工时
普遍存在一种情况：每个成员的定位角色，就决定了每个人该干嘛。
认领工作适用于自组织的情况？什么场景合适呢？
5）、master角色
一般不就是组长、项目经理、产品经理等人担任么？
做的事情有啥本质区别吗？
还是说只是形式不同，名称不同？
3、事物发展需要的条件和环境
橘生淮南则为橘，橘生淮北则为枳。
事物生长发展，需要相应的环境和土壤。
只吹好处，不讲环境，是无法落地的，最终只是形式而已。
中国的制度、人文环境、行业特点，都需要考虑，否则容易变了味，甚至成了相关人群的单方面道具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd948f2292a64acb37f726e770a2c9c3/" rel="bookmark">
			webpack.config.js哪里找？react项目关闭eslint监测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
webpack.config.js哪里找？
react项目关闭eslint监测
webpack.config.js哪里找？ 在React项目中，当我们需要修改一些配置时，发现找不到webpack.config.js，是我们创建的项目有问题吗，还需新创建项目的项目已经不包含webpack.config.js文件了吗？
其实是创建项目时，自动隐藏的webpack.config.js文件，需要我们自己暴露webpack.config.js文件。
暴露webpack.config.js文件的方式：
执行npm run eject
执行之后，我们就会在暴露的config文件夹中看到webpack.config.js文件
react项目关闭eslint监测 1、设置package.json文件
"eslintConfig": { "extends": [ "react-app", "react-app/jest" ], "rules": { "no-undef": "off", "no-restricted-globals": "off", "no-unused-vars": "off" } }, 对eslint的规则了解可参考以下文章
eslint官网规则http://eslint.cn/docs/rules/
或者
Eslint_规则参考手 http://www.verydoc.net/eslint/00003312.html
根据自己的需要关闭相关规则。
如果 package.json文件设置了以上代码之后，发现eslint关闭失效，可以直接在webpack.config.js中注释eslint相关的代码
2、webpack.config.js中注释eslint相关的代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fd7bc16b9bc4dfb1a62595377dc613/" rel="bookmark">
			因子中性化和因子解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因子中性化
因子值本身是否和市值存在高度相关性，若如此，会导致市值因子和该因子混在一起。如果相关性较高，那么实际上就和市值因子的效果一样了。
有时候，我们一样因子本身不受市值影响，那么就可以通过使用中性化处理后的因子值。但是有时候，我们因子本身的含义本来就偏好某类市值股票，即这种市值效应是该因子本身的一种预期特点，那么就不需要中性化。因此，只有当我们一样剥离某些其他因子的影响，才需要中性化。
一般什么情况下需要中性化？当我们想要的因子由于代理变量不够纯粹，会和其他因子存在较大相关性，但是我们又只想看纯粹效应，这时需要剔除其他因子的影响。或者想看新因子是否实际上可以被旧因子解释，或者说新因子是否相对于旧因子有新贡献，那么就需要相对其他因子中性化，看中性化后的因子是否还有显著的预测作用。
要注意，中性化是为了平衡因子，使得具有剔除其他因子后的可比性，其他因子不必对收益有影响，而是为了不让研究因子值受其他因子影响，使得效果和其他因子一样，即使某个因素对收益没有预测作用，但是如果因子受这个因素影响很大，那么这个因子在这个因素的影响下，也会失去预测作用。
什么情况下不需要中性化？就想看该因子本身的表现，其因子相关性是预期中的。不需要剔除其他因子的影响。或者因子构建本身已经考虑到了市值等因素的影响，比如用市值scale等。
中性化方法
1. 分组法
分组算z score，比如将股票分为大中小市值组，然后组内算z score，这样就可以将因子组内标准化，转为近似同分布，不同市值下的因子值就具有剔除市值效应后的可比性了。缺点是效率低，容易造成样本不均，稀疏。比如同时再加一个行业中性化，那么就要对每个行业做大中小市值分组，这样由于有的行业本来股票就不多，再一分，导致不同行业的样本分布数量很不均，容易出现偏差，如果因子再多，那么组别指数增加，就不现实了。
2. 回归法
将因子在需要剔除影响的其他因子上做回归，取残差。回归后，残差和其他因子没有相关性，残差的对收益的解释预测作用就是剔除了其他因子后的。
回归法要特别注意异常值处理，因为回归结果本身是容易受异常值影响的（除非是rank回归，对异常值比较robust）
回归法可以中性化，也可以用来剔除其他因子对收益的解释，前者不必要求其他因子对收益有影响，要求对因子本身取值有影响，是为了剔除其他因子效应（该效应可能是有正预测作用、负预测作用或者没有预测作用），后者一般是为了看因子是否有新增贡献，这个一般要求其他因子是有预测作用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b94c562153f083a747592125a44db2f/" rel="bookmark">
			如何创建vue3&#43;vite&#43;ts的项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅为新手提供刚接触vue3时不懂如何创建demo的教程。
一般情况下，官方推荐使用vite来构建vue3项目，vite是一种新型前端构建工具，能够显著提升前端开发体验。但是使用Vite需要Node.js版本 &gt;= 12.0.0。
操作步骤 yarn create vite 1、运行上述命令，会提示你输入项目的名称：
2、选择所使用的框架
3、选择使用的编程语言
上述三步执行完后，就会创建成功一个模板
4、根据创建成功后的提示执行命令，首先cd todo-list进入到项目目录下，然后执行yarn安装依赖，依赖安装成功后执行yarn dev即可运行项目。
至此，一个非常简洁的基于vite + ts的vue3demo创建成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29418c8edc1897d6ea11a14ee4a9438/" rel="bookmark">
			解决ERROR in ./node_modules/vuex/dist/vuex.esm.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你安装vuex时，安装完成后可能会出现这样的报错
ERROR in ./node_modules/vuex/dist/vuex.esm.js
两种原因：
1、如果你是用的是vue2,那应该安装vuex@3版本
npm i vuex@3
如果你是用的是vue3，那么应该安装vuex@4版本 npm i vuex@4
2、第二种情况就是，你安装的版本没问题，但是你是在运行情况下安装的，那么他还是会报错，
应该先停止项目，在安装(两次ctri+c)
ctrl+c 根据不同版本安装完成之后再执行一次就好了
npm run serve 成功运行！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3865881845a6c68823456f0a189c39/" rel="bookmark">
			这是一份保姆级Vue3&#43;Vite实战教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们要创建一个 Vue3+Vite 项目，目前 Vue 官方创建项目时默认就是 Vite 构建了，所以直接按照官网来就可以，如下：
确保你安装了最新版本的 Node.js[1]，然后在命令行中运行以下命令
npm init vue@latest# orpnpm create vue@latest 「PS：」 我这边使用的是 pnpm ，它的优缺点我就不说了，大家自行百度吧，不过后面所有的命令中我都会写 npm 和 pnpm 两种，大家想用啥都无所谓的，工具而已，但是 pnpm 真的很香。
这一指令将会安装并执行 create-vue[2]，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示，我们的选择如下：
✔ Project name（项目名）: toolsdog✔ Add TypeScript（添加TS）? : No✔ Add JSX Support（添加JSX支持）? : No✔ Add Vue Router for Single Page Application development（添加Vue-router）? : Yes✔ Add Pinia for state management（添加状态管理Pinia）? : Yes✔ Add Vitest for Unit testing（为单元测试添加Vitest）? : No✔ Add Cypress for both Unit and End-to-End testing（为单元测试与端到端测试添加Cypress）?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3865881845a6c68823456f0a189c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a091480cfb4a68c1059b04a0f8835b3/" rel="bookmark">
			MATLAB tof仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB 是一个高级编程语言，它有丰富的工具箱可以帮助你进行各种仿真。如果你想进行 Time-of-Flight (TOF) 仿真，可以使用 MATLAB 的信号处理工具箱，对 TOF 信号进行模拟和分析。
你可以先构造一个 TOF 模型，然后使用 MATLAB 工具箱进行仿真，并对模拟结果进行可视化分析。在进行仿真时，你可以调整模型的参数，比如光线传播速度和光线衰减系数，以观察它们对仿真结果的影响。
总的来说，使用 MATLAB 进行 TOF 仿真是一个非常方便和有效的方法，它可以帮助你更好地理解 TOF 技术的原理，并对其进行有效的评估。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c473c5787ede8ccad94f52f7e03718a/" rel="bookmark">
			matlab安装gurobi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(26条消息) Yalmip + Gurobi下载安装及matlab导入_DaryDaryDary的博客-CSDN博客_win matlab 安装 gurobi
如何在MATLAB中安装Gurobi (qq.com)
使用程序验正效果
%% 用gurobi求解简单QP问题 % 目标函数及约束条件如下： % 目标函数：minf(x)=x^2+x*y+y^2+y*z+z^2+2*x % 约束条件：x+2*y+3*z&gt;=4 % x+Y&gt;=1 % x&gt;=0 % y&gt;=0 % z&gt;=0 function qp() names={'x','y','z'}; model.varnames=names;%定义变量名 model.Q=sparse([1 0.5 0; 0.5 1 0.5; 0 0.5 1]);%目标函数中多次项系数矩阵 model.A=sparse([1 2 3; 1 1 0]);%约束条件系数矩阵 model.obj=[2 0 0];%目标函数中线性系数矩阵 model.rhs=[4 1]; model.sense='&gt;'; gurobi_write(model,'qp.lp'); results=gurobi(model); for v=1:length(names) fprintf('%s %e\n',names{v}, results.x(v)); end fprintf('Obj:%e\n', results.objval); model.vtype='B'; results=gurobi(model); for v=1:length(names) fprintf('%s %e\n',names{v}, results.x(v)); end fprintf('Obj:%e\n', results.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c473c5787ede8ccad94f52f7e03718a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e634772c4526613473ee1e1cf8a5c6c1/" rel="bookmark">
			【Cocos2dx】【一】lua c&#43;&#43; 绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cocos2dx lua c++ bind Lua官方页面
为啥一般游戏基本都用Lua来做脚本，因为Lua本身就是C写的程序。Lua的解释器代码直接放入你的C/C++项目里，调用相关接口就可以用了。
在cocos2d-x中lua与C++的交互，主要借助于第三方工具tolua++来实现。
该工具会将C++按照Lua支持的C API指定生成绑定代码，以便于Lua通过这些绑定代码更快捷的访问C++下的类及方法相关。
以下内容大部分来参考链接的自文章，会根据自己的想法做些修改。
非常感谢
参考链接
cocos C++与Lua的交互
一.Lua 与 C++ 交互 想要做Lua和C++的交互，肯定先从原理入手。
lua学习03：tolua的编译和使用：C/C++调用lua、lua调用C++、lua调用tolua、常用tolua和lua的API介绍
1).Lua虚拟机/解释器 Lua_State 一般脚本语言的底层都是由静态语言实现的。
Lua的解释器就是一个C程序/模块，不过要注意它的版本和工程的版本对不对应的上。
在cocos中，C/C++就是lua的宿主，虚拟机说白了就是要提供一个lua运行的环境，该环境下需要保存Lua脚本运行的内存空间，全局变量，库文件等， 该环境被称为Lua_State。
在Lua_State环境下，若实现Lua与C/C++的数据交互，我们需要有个容器来对数据进行传递，这个容器就是Lua虚拟栈。
2.)Lua虚拟栈 栈是先进后出的，在Lua的虚拟栈中，栈中数据通过索引值进行定位，索引值可为正数，也可为负数。
通俗的来说，1的永远表示栈底，-1的永远表示栈顶。
可以这么理解，队列中第一个下标index肯定是1，栈中是先进后出，所以栈底肯定是1，因为它先进。
3).C++ 访问 Lua 文章里的样例写的很好，但是我想做一些自己的修改。
具体如何将Lua加入到C/C++项目工程请自行百度。
test.lua
-- 文件命名为:test.lua str = "Get Lua Data Sucess!!!" function Add(num1, num2) return num1 + num2 end .cpp
#include &lt;iostream&gt; #include &lt;string.h&gt; extern "C" { #include "lua.h" // 提供了Lua的基本函数，在lua.h中的函数均已"lua_"为前缀 #include "lualib.h" // 定义lua的标准库函数，比如table, io, math等 #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e634772c4526613473ee1e1cf8a5c6c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef268ff0344a9a3b5c115156511dd63/" rel="bookmark">
			【Cocos2dx】【二】fairyGUI lua 接入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Cocos2dx】【二】fairyGUI lua 接入 官方文档
或者看这篇官方推荐的博客：
FairyGUI在Cocos2d-x下的多平台接入和lua绑定
其中有两个步骤暂时不理解。
一.conversions.yaml definitions: # the names of the functions - we use this to generate the code and to register the functions in # the javascript class ifunction: "lua_${generator.prefix}_${class_name}_${func_name}" sfunction: "lua_${generator.prefix}_${class_name}_${func_name}" constructor: "lua_${generator.prefix}_${class_name}_constructor" conversions: # some times you want to use a special native type when converting from spidermonkey to native # the most common case would be from JS-boolean to bool. Using "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef268ff0344a9a3b5c115156511dd63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5713322ce35aa7e4215530405fa3bed0/" rel="bookmark">
			(day12) 自学Java——集合进阶(双列集合)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.双列集合特点
Map遍历三种方式
2.HashMap
3.LinkedHashMap
4.TreeMap
5.源码解析
6.可变参数(形参个数可变)
7.Collections
8.综合练习
1.双列集合特点 ①双列集合一次需要存一对数据，分别为键和值
②键不能重复，值可以重复
③键和值是一—对应的，每一个键只能找到自己对应的值
④键+值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”
Map是接口，不能直接创建对象，要创建它实现类的对象。
Map遍历三种方式 Map遍历方式：
1.键找值
2.键值对
3.Lambda表达式
练习：用键找值的方式遍历map集合，要求：用装着键的单列集合，使用增强for的形式遍历。
用键找值的方式遍历map集合，要求：用装着键的单列集合，使用迭代器的形式遍历。
用键找值的方式遍历map集合，要求：用装着键的单列集合，使用Lambda的形式遍历。
import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class MapDemo { public static void main(String[] args) { Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put("bk","pp"); map.put("文总","包包"); map.put("桃桃","福福"); //获取所有的键，将键放到单列集合中 Set&lt;String&gt; keys=map.keySet(); //增强for遍历 for (String key : keys) { String value=map.get(key); System.out.println(key+"="+value); } //迭代器 Iterator&lt;String&gt; it=keys.iterator(); while (it.hasNext()){ String keys1=it.next(); String value1=map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5713322ce35aa7e4215530405fa3bed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68381f5d090c911ef5169b0044865048/" rel="bookmark">
			每个结点的关键字都比左孩子关键字大，比右孩子关键字小，这样的二叉树一定是二叉排序树为啥错了能解释一下吗...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不对，这样的二叉树不一定是二叉排序树。二叉排序树的定义是：在二叉树的左子树中，所有的结点的关键字都比根结点的关键字小；在二叉树的右子树中，所有的结点的关键字都比根结点的关键字大。因此，如果一棵二叉树每个结点的关键字都比左孩子关键字大，比右孩子关键字小，那么这个二叉树不一定是二叉排序树。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e98555b286fcc9185b77d7be9485001/" rel="bookmark">
			H265视频码流结构分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
H265码流结构
H265帧结构 H265档次介绍
RTSP实时音视频开发实战课程：&lt;RTSP实时音视频开发实战&gt;
《YUV编码为H265视频流代码实现》链接：
https://edu.csdn.net/learn/38258/606134?spm=1003.2001.3001.4157
《H265视频流解码为YUV代码实现》链接：
https://edu.csdn.net/learn/38258/606144?spm=1003.2001.3001.4157
前言 在音视频开发入门基础知识（视频入门篇）中介绍了H265的一些编码基础，本文会对H265编码后的视频流做一个详细的介绍。H264视频码流结构分析一文中对H264视频码流结构做了详细的分析，H265的视频码流结构和H264视频码流结构比较相似，建议阅读H264视频码流结构分析先了解下H264视频码流结构的特性和一些术语、概念。
H265码流结构 H265的视频流中也是存在多个GOP，每一个GOP里面包含多个视频编码帧。H265支持的视频编码帧类型有IDR帧、I帧、P帧、B帧，这些帧类型的含义和H264码流的帧类型的含义是一样，作用也是一样，比如IDR帧和I帧都是帧内压缩编码，IDR帧是即时解码刷新帧，也是关键帧；P帧是前向参考帧，B帧是双向参考帧。
H265的I帧或者IDR帧采用帧内编码，由于帧内压缩效率低，所以往往IDR帧/I帧比较大；如下图中的图像是H265的视频IDR帧的图像，可以看出IDR帧里面的每一个小块都是帧内编码块(橙色)；图中上方的柱状图表示每个视频帧的大小，柱状图越高表示数据量越大，可以看出IDR帧(橙色)比较大。
H265的P帧B帧也可以采用帧内压缩的方式来编码，不过主要还是靠帧间编码来提示压缩率的；如下图中的图像是H265的视频P帧的图像，可以看出P帧里面的小方块的大多是帧间编码块(蓝色块)，还出了一个帧内编码块(橙色块)。
H265帧结构 H265每一个帧的组成和H264的构成一样，功能上分为NAL层(NetworkAbstraction Layer,网络提取层)和VCL层(VideoCoding Layer,视频编码层)；H265的一帧编码图像中分为一个或者多个Nal 单元；每个NAL单元包含Nal 单元头和NAL 单元 Body；Nal 单元头由起始码和Nal Type组成。NAL 单元 Body通常是RBSP(Raw Byte Sequence Payload 原始字节序列载荷)数据 。如下图所示。H265的Nal Type和H264Nal Type有些许差异，如在IDR/I帧数据通常除了SPS、PPS还有VPS，如下图中红色字体VPS是H265视频流中增加的Nal Type。
VPS：Video Parameter Set,视频参数集；主要包含视频时域子层的最大数目，时钟周期计算相关参数等。
与H264一样，H265可以通过Nal Type来判断当前Nal Unit的类型；如下图是Nal Unit 定义；在Nal Unit最开始的位置就是nal_unit_header，之后才是rbsp。
下图是nal_unit_header的定义，共占用了16bit(2个字节)；其中nal_unit_type表示的是一个NalUnit数据的类型，占前8bit的6个bit位；nal_unit_type的取值计算为(data[0] &amp;0x7e)&gt;&gt; 1 。
nal_unit_type字段定义如下图；如下图可以知道 nal_unit_type为32时候 Nal Unit是VPS；nal_unit_type为33时候 Nal Unit是SPS；nal_unit_type为34时候 Nal Unit是PPS；nal_unit_type为19-20时候 Nal Unit是IDR Slice；nal_unit_type为0-9，16-18，21的时候 Nal Unit是非IDR Slice；nal_unit_type为39-40时候 Nal Unit是SEI（视频增强信息）。实际上16-21都是I帧类型的数据。
在H265视频帧中，对于非IDR 的Slice我们可以进一步解析slice_segment_header()中的slice_type；slice_segment_header()定义如下图。
下图是H265视频帧中slice_type的定义 ；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e98555b286fcc9185b77d7be9485001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9d5a748aacbb349e6439a9ea6c0974/" rel="bookmark">
			python实现caj转pdf代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要实现将 caj 文件转换为 pdf，您可以使用一个第三方库，例如 PyMuPDF。
以下是一个示例代码：
import fitz def caj_to_pdf(caj_file, pdf_file): # 打开 caj 文件 doc = fitz.open(caj_file) # 保存为 pdf 文件 doc.save(pdf_file) # 关闭文件 doc.close() if __name__ == '__main__': caj_to_pdf('example.caj', 'example.pdf') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2111b47d56b8badc9c0ca72de84d62a2/" rel="bookmark">
			SpringBoot整合SpringSecurity，实现登陆认证及授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、导入jar包 &lt;dependencies&gt; &lt;!-- SpringBoot的依赖配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jwt依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--验证码 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Security--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Security方法级权限控制注解--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2111b47d56b8badc9c0ca72de84d62a2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/100/">«</a>
	<span class="pagination__item pagination__item--current">101/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/102/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>