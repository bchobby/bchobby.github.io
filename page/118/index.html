<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e631b7f308735faf107bb2ffe0538058/" rel="bookmark">
			canal环境搭建及出现问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、canal作用 1.canal介绍
Canal 是阿里开源的一个项目，官方主页：https://github.com/alibaba/canal。
它通过模拟 MySOL 主从复制的交互协议，把自己伪装成一个 MySOL 的从节
点，向 MySOL 主节点发送 dump 请求。MySOL 收到请求后，就会向 Canal 开始
推送 Binlog，Canal 解析 Binlog 字节流之后，将其转换为便于读取的结构化数据，
供下游程序订阅使用
项目中使用canal一般希望借助canal实现mysql数据库的同步（比如将mysql中的数据更新redis保证缓存和数据库数据的一致性）
二、环境搭建 安装环境：操作系统 Windows10，MySQL 8.0.19，canal1.1.6.
因为canal是模拟mysql的从节点工作，所以先安装mysql，并且让mysql按照主从节点的主节点配置就可以。
1.配置mysql
1.1 先开启binlog写入功能
show variables like "%log_bin%" 1.2 配置 binlog-format 为 ROW 模式
show variables like "%binlog_format%"; 1.3 mysql的server_id
show variables like "%server_id%"; 如果本机的 MySQL 的配置与上述不符合，可以修改 MySQL 的配置文件并重
启 MySQL，一般来说是 my.ini,如果自己不清楚放在哪里可以直接在电脑上搜索一下。
2.配置canal同步账号密码
2.1既然是将 Canal 模拟 MySQL 从节点，自然还要给 Canal 设置一个用来复制数
据的 MySQL 账号，我们这里设定这个用户名为 canal，密码 canal
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e631b7f308735faf107bb2ffe0538058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a27155b203ef1d70bdd31eb684e276eb/" rel="bookmark">
			CentOS7中没有网络图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7中没有网络图标===&gt;先修改NetworkManager的目录名 mv /var/lib/NetworkManager /var/lib/NetworkManager.bak
先配置静态IP chkconfig network off
chkconfig network on
先停掉NetworkManager systemctl stop NetworkManager
systemctl disable NetworkManager
#再启动NetworkManager
systemctl start NetworkManager
再重启network service network restart
测试ping百度 ping www.baidu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba837dfa9feea6a8dad566fc17286e6f/" rel="bookmark">
			do while(0)的作用以及原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，do...while 通常是用来做循环用的，然而我们做循环操作可能用for和while要多一些。经常看到一些开源代码会出现do...while(0)这样的代码，这样的代码看上去肯定不是用来做循环的，那为什么要这样用呢？
实际上do...while(0)的作用远大于美化代码，现总结起来主要有以下几个作用：
辅助定义复杂的宏，避免引用的时候出错，提高代码健壮性
假设你需要定义一个这样的宏：
#define DOSOMETHING()\ func1();\ func2(); 这个宏的本意是，当调用DOSOMETHING()时，函数func1()和func2()都会被调用。但是如果你在调用的时候这么写：
if(a&gt;0) DOSOMETHING(); 因为宏在预处理的时候会直接被展开，你实际上写的代码是这个样子的：
if(a&gt;0) func1(); func2(); 这就出现了问题，因为无论a是否大于0，func2()都会被执行，导致程序出错。
那么仅仅使用{}将func1()和func2()包起来行么？
我们在写代码的时候都习惯在语句右面加上分号，如果在宏中使用{}，代码里就相当于这样写了：“{...};”，假如有以下代码：
#define DOSOMETHING(){\ func1();\ func2();} ... if(a&gt;0) DOSOMETHING(); else ... ... 展开后就是这个样子:
if(a&gt;0) { func1(); func2(); }; else ... 这样是不会编译通过。所以，很多人才采用了do{...}while(0);
#define DOSOMETHING() \ do{ \ func1();\ func2();\ }while(0)\ ... if(a&gt;0) DOSOMETHING(); else ... ... 消除分支语句或者goto语句，提高代码的易读性
如果在一个函数中开始要分配一些资源，然后在中途执行过程中如果遇到错误则退出函数，当然，退出前先释放资源，我们的代码可能是这样：
bool Execute() { // 分配资源 int *p = new int; bool bOk(true); // 执行并进行错误处理 bOk = func1(); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba837dfa9feea6a8dad566fc17286e6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad03ef7b64a1601cdc19c1fe065d90f2/" rel="bookmark">
			【CUDA】Ubuntu系统如何安装CUDA保姆级教程(2022年最新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期目录 Linux安装CUDA Linux安装CUDA 输入以下命令，查看 GPU 支持的最高 CUDA 版本。笔者这里显示的是 11.6 ，这意味着，安装的 CUDA 版本必须 &lt;= 11.6 。
nvidia-smi 前往 Nvidia 的 CUDA 官网：CUDA Toolkit Archive | NVIDIA Developer ，笔者下载 CUDA 11.6.2 版本：
如下图选择：
选择好后，下方会显示两条 Linux 命令。在 Linux 终端输入这条命令：
$ wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.run 这里笔者的服务器无法翻墙，直接在服务器上下载会超时。所以直接复制下载地址，先在 Windows 系统下下载好，再上传到 /root/ 目录下。
https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.run 这里由于笔者没有 root 权限，无法上传到 /root/ 目录下。因此将此安装包上传至 /home/og/xxx 自己的工作目录下。输入以下命令：
$ sudo sh cuda_11.6.2_510.47.03_linux.run 弹出来第一个选择框，笔者这台服务器已经安装过 Nvidia 的显卡驱动了，因此选择 “continute” ，会出现下面这个对话框，选择 “accept” 。
笔者服务器已经安装过 Nvidia 显卡驱动了，因此不需要再安装了。如果你尚未安装驱动，可以顺便一起安装了。摁一下空格取消 Driver 安装，直接选择 Install 安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad03ef7b64a1601cdc19c1fe065d90f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0652d842249b331570bfcec6458283/" rel="bookmark">
			【Go语言入门教程】单元测试时同一个包下不同文件函数调用报错为 `undefined`
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期目录 单元测试时同一个包下不同文件函数调用报错为 `undefined` 的问题1. 背景知识2. 问题描述3. 原因4. 解决方法一：关闭GOPATH，使用go mod4.1 设置GO111MODULE4.2 清空所有GOPATH4.3 在新项目中创建go mod4.4 执行单元测试 5. 解决方法二：坚持GOPATH模式，改变测试命令 单元测试时同一个包下不同文件函数调用报错为 undefined 的问题 1. 背景知识 在 Terminal 终端命令行中，使用 go test 指令执行单元测试，所有以 _test.go 结尾的代码内以 Test 开头的函数会自动被执行。
go test -v hello_test.go 其中，-v 可以让测试时显示详细的流程信息。
2. 问题描述 单元测试的目录结构如下图所示：
① hello.go 代码：
package hello func Hello() string { return "Hello, world." } ② hello_test.go 代码：
package hello import "testing" func TestHello(t *testing.T) { want := "Hello, world." if got := Hello(); got !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b0652d842249b331570bfcec6458283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6d227ee645caaf836665bdc1f46de1/" rel="bookmark">
			【PyTorch教程】04-详解torchvision 0.13中的预训练模型加载的更新及报错的解决方法 (2022年最新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期目录 加载预训练模型(有重大更新)1. 新老版本写法对比2. 新写法的好处 加载预训练模型(有重大更新) 相信最近 (2022年7月) 安装或者更新了 PyTorch 和 torchvision 的同志们可能跑代码时遇到了下面的报错之一：
UserWarning: The parameter ‘pretrained’ is deprecated since 0.13 and will be removed in 0.15, please use ‘weights’ instead.
UserWarning: Arguments other than a weight enum or None for ‘weights’ are deprecated since 0.13 and will be removed in 0.15. The current behavior is equivalent to passing weights=ResNet50_Weights.IMAGENET1K_V1. You can also use weights=ResNet50_Weights.DEFAULT to get the most up-to-date weights.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd6d227ee645caaf836665bdc1f46de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43244f47455771974c48d1c0cb0c1557/" rel="bookmark">
			Python &#39;utf-8&#39; codec can&#39;t decode byte 0x8b in position 1: invalid start byte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例一：
```py
使用 urllib import urllib.request
使用 json import json
定义 header headers = { # 'Accept': '/',
# 因为有 Accept-Encoding 这行会报错：'utf-8' codec can't decode byte 0x8b in position 1: invalid start byte # 'Accept-Encoding': 'gzip, deflate, br', # 在写爬虫的时候这一句话一定要注释掉，因为接受编码格式没有 utf-8
# 'Accept-Language': 'zh-CN,zh;q=0.9', # 'Acs-Token': '16683230096471668329342293ts2LNTmAMNu8bz6UcQlmajMjkFeD7EM7TNicuMqP14qLPx6R8FOs/pHR9jGpORyVc3jkLtMD7dh7/9XDK7+b5SqO0f2bzrYB1DzNkaXGMwkcPyDo9cygYroE1pFoncx4VbCQu/ieJyUK+TbYU4atAB/XCth4Lc8zNYRCQuOtbLb2zJ9RX1Jj7krqZIfNr14muZP1N5+rq7cjPbnBgvf5V6m03XLliDp4ueln/xS/qSQVL3XiWSOpemYY9gD9UHaUVPGIi4Q6uIT/05yCxxhd4kJCfeRys/AiOLQ+nbNaXUGoyTBZg90HLn6A9NTb5HAF', # 'Connection': 'keep-alive', # 'Content-Length': '135', # 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
# 防爬方式的一种，验证 Cookie 'Cookie': '换成自己百度账号的 Cookie',
# 'Host': 'fanyi.baidu.com', # 'Origin': 'https://fanyi.baidu.com', # 'Referer': 'https://fanyi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43244f47455771974c48d1c0cb0c1557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdfc8ffb7d6fb287d0a1b26c5fcb40c4/" rel="bookmark">
			【CentOS8安装docker】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS8安装docker 文章目录 一、更新yum
二、卸载旧版本
三、安装 Docker Engine-Community(使用 Docker 仓库进行安装)
四、安装成功后需重启docker 五、卸载 docker
六、注意
七、***安装特定版本的 Docker Engine-Community***
有多个 Docker 仓库吗？
前言 您可以根据需要以不同的方式安装 Docker 引擎：
大多数用户设置Docker的存储库并从中安装，以便于安装和升级任务。这是推荐的方法。
一些用户下载 RPM 软件包并手动安装，并完全手动管理升级。这在无法访问互联网的气隙系统上安装 Docker 等情况下很有用。
在测试和开发环境中，一些用户选择使用自动化的便利脚本来安装 Docker。
本文介绍安装方法为使用存储库安装。
在新主机上首次安装 Docker 引擎之前，您需要设置 Docker 存储库。之后，您可以从存储库安装和更新 Docker。
一、更新yum yum -y update 二、卸载旧版本 较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。
sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 三、安装 Docker Engine-Community(使用 Docker 仓库进行安装) 在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdfc8ffb7d6fb287d0a1b26c5fcb40c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad90fe7ddd9ff7d4c5321fcbe9a3803/" rel="bookmark">
			PyTorch 训练过程中，冻结某些层的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 深度学习训练自己的数据集时，由于计算资源，训练耗时等原因，通常我们站在巨人的肩膀上（迁移学习方式），来进行自己的数据训练。 在迁移学习的过程中，通常有两种方式： 1.直接使用预训练模型，重头到尾进行参数更新；	2.首先，冻结预训练模型某些层的参数，进行初次训练，保存最好的模型结果best，然后，利用加载best与unfreeze某些层的参数， 再次训练更新权重参数，最后，保存结果最好的模型。 具体选择哪种迁移学习方式，根据自己的数据集与训练初始化权重的数据集相似程度而定。以下我们主要讲解冻结某些网络层的三种方法。 冻结方法 1. require_grad=False def freeze(model): for param in model.parameters(): param.requires_grad = False a. 冻结某一层参数
import torch import torch.nn as nn #lenet class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 6, 5) self.conv2 = nn.Conv2d(6, 16, 5) freeze(self.conv2) # 冻结self.conv2层 self.fc1 = nn.Linear(16 * 4 * 4, 120) self.fc2 = nn.Linear(120, 84) # print(self) self.fc3 = nn.Linear(84, 10) b. 如果是冻结某一层上面所有层（传self）
import torch import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad90fe7ddd9ff7d4c5321fcbe9a3803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fe2770066e40da1b2c087a2d111041/" rel="bookmark">
			Dependency ‘org.springframework.cloud:spring-cloud-starter-gateway:‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在创建网关模块时，
根本原因在于没有将此模块作为maven工程，选择对应模块，右击make directory as 作为source root即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50c198ca471f9427aa36ff2a3cea4d9f/" rel="bookmark">
			在Ubuntu系统下安装配置SeaDas与问题解决方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.前言
2.Python环境及Java环境配置
3.SeaDAS的安装
4.OCSSW的安装
建了一个QQ群，大家可以在里边聊聊水色遥感数据下载和数据处理方面的事情：1087024529
不想自己在Ubuntu里安装SeaDAS，那就加群吧！！
1.前言 最近在学习水色遥感数据处理软件SeaDAS的使用，而SeaDAS中的OCSSW工具（包含大气校正等模块）目前只能运行在Linux或者MacOS系统下。因此我选择了在Ubuntu系统下安装和配置SeaDAS以及OCSSW。在按照官方文档安装的过程中，遇见了很多坑，所以在此总结。希望各位小伙伴在安装的时候可以避开我遇见的问题。
我采用的方法是在VirtualBox中的Ubuntu 18.04系统下安装SeaDAS。大家可以在网上找相应的博客，如何在VirtualBoX中安装Ubuntu。这里默认Ubuntu刚安装完成。
SeaDAS的安装包下载地址：
https://seadas.gsfc.nasa.gov/downloads/
SeaDAS的官方安装文档如下：
https://seadas.gsfc.nasa.gov/tutorials/installation_tutorial/
不用再被别人骗积分了！
首先说明我的配置：
VirtualBoX:6.1.12 Ubuntu:18.04 SeaDAS:seadas_7.5.3_linux64_installer.sh 2.Python环境及Java环境配置 SeaDAS和OCSSW的安装和使用是需要Python和Java环境的，所以在安装好Ubuntu后，我首先进行了Python和Java的环境配置。
2.1.Python环境配置 Ubuntu安装完成后，系统内自带Python环境。但在终端中输入Python时，可能会提示没有Python。因此这需要进行配置，使得系统能够识别Python命令。
注：刚安装好的Ubuntu系统，能够识别Python3命令，但是在安装OCSSW的时候，它只调用Python命令，不进行配置将会出错。
在终端中输入：
sudo apt install python sudo apt install python-pip 这时安装的是python2.7，在终端中输入Python命令，会显示python2的版本。python2的支持已经结束，因此这里使用3.x的Python，将Python命令指向Python3。
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2 这时，在终端中输入python，将会显示是3.6版本。
之后安装pip3。
sudo apt install python3-pip 在安装OCSSW工具时，可能需要requests库，这里一并进行安装：
pip install requests 这里的配置可能比较啰嗦，主要的目的是让系统能够识别Python命令(不能是Python3)。大家如果有简单的方法也可以使用。
2.2.Java环境的配置 关于Java环境的配置，这是问题比较大的一步。以下说明我遇到的问题及解决方案。
步骤a-b是遇到的一些问题，想看成功的配置方法请直接忽略a-b步骤：
a.SeaDAS官方给出了Java的安装步骤：
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install oracle-java8-installer 当执行到这里时，系统会报出错误：
没有可用的软件包 oracle-java8-installer，但是它被其它的软件包引用了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50c198ca471f9427aa36ff2a3cea4d9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2517e471cee29b63891e5c0cac830f5/" rel="bookmark">
			bazel安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境 以centos为例
安装步骤 # 安装g++, git sudo yum install gcc gcc-c++ gdb git # 下载对应版本的bazelisk, 并且安装 # 在https://github.com/bazelbuild/bazelisk中找对应的版本, 然后加到PATH中 wget https://github.com/bazelbuild/bazelisk/releases/download/v1.15.0/bazelisk-linux-amd64 chmod +x bazelisk-linux-amd64 ln -s $(pwd)/bazelisk-linux-amd64 ~/bin/bazel # 测试bazel bazel --version 参考 bazelbazeliskCentOS 7 安装gcc、g++、gdb教程bazel 根据.proto文件生成.h、.cc文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61250443a26d3a5bb39f78cf2bf9f1df/" rel="bookmark">
			简单介绍API分类接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API其实就是一类服务的封装。我们可以使用不同的编程语言编写API，开发习惯和编程语言的不同导致API风格也存在差异。常见的API有以下几种形式：
1、HTTP类型接口
基于HTTP协议提供的API，这类API常常以“网址”形式提供的，像现在主流的RESTful就属于这类接口。
2、RPC接口
RPC它是指远程过程调用，将一部分代码逻辑放在远程服务器上部署，然后在需要的地方调用即可（调用远程方法就像调用本地方法一样），本质上是Client/Server模式，而且支持多种协议和数据传输方式。
3、Web Service 接口
Web Service并不具象地指某种API，我们将以WEB形式提供的服务都称之为Web Service，像RESTful也属于Web Service。 4、目前支持以下基本接口
item_get 获得淘宝商品详情item_get_pro 获得淘宝商品详情高级版item_review 获得淘宝商品评论item_fee 获得淘宝商品快递费用item_password 获得淘口令真实urlitem_list_updown 批量获得淘宝商品上下架时间seller_info 获得淘宝店铺详情item_search 按关键字搜索淘宝商品item_search_tmall 按关键字搜索天猫商品item_search_img 按图搜索淘宝商品（拍立淘）item_search_shop 获得店铺的所有商品item_search_seller 搜索店铺列表item_search_guang 爱逛街item_search_suggest 获得搜索词推荐item_search_jupage 天天特价item_search_coupon 优惠券查询cat_get 获得淘宝分类详情item_cat_get 获得淘宝商品类目item_search_similar 搜索相似的商品item_sku 获取sku详细信息item_recommend 获取推荐商品列表custom 自定义API操作buyer_cart_add 添加到购物车buyer_cart_remove 删除购物车商品buyer_cart_clear 清空购物车buyer_cart_list 获取购物车的商品列表buyer_cart_order 将购物车商品保存为订单buyer_order_list 获取购买到的商品订单列表buyer_order_detail 获取购买到的商品订单详情buyer_order_express 获取购买到的商品订单物流buyer_order_message 获取购买到的订单买家留言buyer_address_list 收货地址列表buyer_address_clear 清除收货地址buyer_address_remove 删除收货地址buyer_address_modify 修改收货地址buyer_address_add 添加收货地址buyer_info 买家信息buyer_token 买家tokenseller_order_list 获取卖出的商品订单列表seller_order_detail 获取卖出的商品订单详情seller_order_close 卖家关闭一笔交易seller_order_message 获取或修改卖出去的订单备注seller_auction_list 商品可上下架商品列表seller_auction 商品上下架seller_item_add 商品上传upload_img 上传图片到淘宝img2text 图片识别商品接口tbk_order_query 淘宝客订单查询item_list_weight 批量获取商品信息item_history_price 获取商品历史价格信息item_get_app 获得淘宝app商品详情原数据 5、代码展示
{ "item": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61250443a26d3a5bb39f78cf2bf9f1df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1335417111049d2fe39a2b7fe283b53/" rel="bookmark">
			使用mobaxterm与虚拟机远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.
下载mobaxterm安装玩打开
2.
打开虚拟机，打开命令，输入ifconfig查看ip 3. 找到红框中的ip
如果是刚创建好的虚拟机是没有ip的，需要我们手动去获取ip
输入 nmcli connect ens160 就可以得到ip
如果想每次开机自动获取ip，输入 nmcli connection nodify ens160 autoconnect yes
4.打开mobaxterm,输入 nmcli connect点start local terminal输入以下代码
ssh 账号@ip
输入密码后连接成功
5.验证是否连接
可以看到虚拟机被关闭
只有连接root管理员用户才能远程关机，正常用户是没有权限的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a0f207ad471758db4f20ca39a7a7af/" rel="bookmark">
			获取字符串长度、字节长度、UTF-8字节长度（C#）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取字符串长度、字节长度、UTF-8字节长度，
代码编写：
string str = "字符串长度测试12345+-=@#"; int test1 = str.Length;//字符串长度：不管中文、英文、符号都是一个字符 int test2 = System.Text.Encoding.Default.GetByteCount(str);//默认编码：中文占两个字节，其他占一个字节 int test3 = System.Text.Encoding.UTF8.GetByteCount(str);//UTF-8编码：中文占三个字节，其他占一个字节 Console.WriteLine("---------------字符串长度-----------------"); Console.WriteLine("test1长度：" + test1); Console.WriteLine("test2长度（默认编码）：" + test2); Console.WriteLine("test3长度（UTF-8编码）：" + test3); Console.WriteLine("---------------字符串长度-----------------"); 输出结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f486445a86b3626b7ccb605720829f/" rel="bookmark">
			使用Easy Excel对excel的读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Easy Excel
所需依赖
准备一个excel文件
对excel的读取
创建对应的实体类
创建EasyExcelUtil类
修改实体类
对excel的写入
在EasyExcelUtil类中加入写方法
对excel的填充
在EasyExcelUtil类中加入填充方法
整合为工具类
Easy Excel EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。
他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。
所需依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok依赖可以不加，只是之后要手动的写get，set方法--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--easyexcel--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--slf4j 日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 准备一个excel文件 内容如下：
id姓名年龄1小明122小红133小刚134小美115小智10 对excel的读取 创建对应的实体类 @Data @AllArgsConstructor @NoArgsConstructor public class User { private String id; private String name; private Integer age; } 如果没有导入lombok依赖需要手动加入get，set方法和构造方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45f486445a86b3626b7ccb605720829f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a90092a8c3834547190eb955cd2d971/" rel="bookmark">
			算法设计与分析——活动安排问题（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源(如演讲会场)，而在同一时间内只有一个活动能使用这一资源。每个活动 都有一个要求使用该资源的起始时间 和一个结束时间 ，且 &lt;。如果选择了活动 ，则它在半开时间区间 [，) 内占用资源。若区间 [，) 与区间 [，) 不相交，则称活动 与活动 是相容的。也就是说，当 ≥ ，或 ≥ 时，活动 与活动 相容。活动安排问题(activity arrangement problem)要求在所给的活动集合中选出最大的相容活动子集。 【想法】贪心法求解活动安排问题的关键是如何选择贪心策略，使得按照一定的顺序选择相容活动，并能够安排尽量多的活动。至少有以下两种看似合理的贪心策略。 (1)最早开始时间：这样可以增大资源的利用率。 (2)最早结束时间：这样可以使下一个活动尽早开始。
由于活动占用资源的时间没有限制，因此，后一种贪心选择更为合理。直观上，按这种策略选择相容活动可以为未安排的活动留下尽可能多的时间，也就是说，这种贪心选择的目的是使剩余时间段极大化，以便安排尽可能多的相容活动。 为了在每一次贪心选择时快速查找具有最早结束时间的相容活动，可以将 个活动按结束时间非减序排列。这样，贪心选择时取当前活动集合中结束时间最早的活动就归结为取当前活动集合中排在最前面的活动。 例如，设有11个活动等待安排，这些活动按结束时间的非减序排列如下表所示。 12345678910111305356882124567891011121314 贪心法求解活动安排问题的过程如下图所示，其中阴影长条表示该活动已加入解集合中，空白长条表示该活动是当前正在检查相容性的活动。首先选择活动 1 加入解集合，因为活动 1 具有最早结束时间；活动 2 和活动 3 与活动 1 不相容，所以舍弃它们；活动 4 与活动 1 相容，因此将活动 4 加入解集合；然后在剩下的活动中找与活动 4 相容并具有最早结束时间的活动，依此类推。最终被选定的活动集合为{1，4，8，11}。 【算法】设有 n 个活动等待安排， 表示活动 的起始时间， 表示活动 的结束时间( 1 ≤ ≤ )，集合 B 存放问题的解，即选定的活动集合，算法如下。
输入： 个活动的开始时间 {，，...，} 和结束时间 {，,...，}
输出：选定的活动集合
1.对 {，,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a90092a8c3834547190eb955cd2d971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429f9b7d67bfc77fe51d1b870f0b926a/" rel="bookmark">
			cap理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周预习作业，两个主题：
连接池 池(Pool)技术在一定程度上可以明显优化服务器应用程序的性能，提高程序执行效率和降低系统资源开销。这里所说的池是一种广义上的池，比如数据库连接池、线程池、内存池、对象池等。其中，对象池可以看成保存对象的容器，在进程初始化时创建一定数量的对象。需要时直接从池中取出一个空闲对象，用完后并不直接释放掉对象，而是再放到对象池中以方便下一次对象请求可以直接复用。其他几种池的设计思想也是如此，池技术的优势是，可以消除对象创建所带来的延迟，从而提高系统的性能。
要了解Java连接池我们先要了解数据库连接池（connection pool）的原理，Java连接池正是数据库连接池在Java上的应用。——我们知道，对于共享资源，有一个很著名的设计模式：资源池（Resource Pool）。
该模式正是为了解决资源的频繁分配﹑释放所造成的问题。为解决上述问题，可以采用数据库连接池技术。数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据。
Java中几个主流的数据库连接池 Java中几个主流的数据库连接池_但行好事 莫問前程的技术博客_51CTO博客
cap理论 一、什么是分布式系统 拿一个最简单的例子，就比如说我们的图书管理系统。之前的系统包含了所有的功能，比如用户注册登录、管理员功能、图书借阅管理等。这叫做集中式系统。也就是一个人干了好几件事。
后来随着功能的增多，用户量也越来越大。集中式系统维护太麻烦，拓展性也不好。于是就考虑着把这些功能分开。通俗的理解就是原本需要一个人干的事，现在分给n个人干，各自干各自的，最终取得和一个人干的效果一样。
稍微正规一点的定义就是：一个业务分拆多个子业务，部署在不同的服务器上。 然后通过一定的通信协议，能够让这些子业务之间相互通信。
既然分给了n个人，那就涉及到这些人的沟通交流协作问题。想要去解决这些问题，就需要先聊聊分布式系统中的CAP理论。千万不要被这个看起来高大上的概念迷惑住。
二、cap理论 CAP理论指的是一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。
这张图不知道你之前看到过没，如果你看过书或者是视频，这张图应该被列举了好几遍了。下面我不准备直接上来就对每一个特性进行概述。我们先从案例出发逐步过渡。
1、一个小例子 首先我们看一张图
现在网络中有两个节点N1和N2，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的两个子数据库。
现在问题来了。突然有两个用户小明和小华分别同时访问了N1和N2。我们理想中的操作是下面这样的
（1）小明访问N1节点，小华访问N2节点。同时访问的。
（2）小明把N1节点的数据V0变成了V1。
（2）N1节点一看自己的数据有变化，立马执行M操作，告诉了N2节点。
（4）小华读取到的就是最新的数据。也是正确的数据。
上面这是一种最理想的情景。它满足了CAP理论的三个特性。现在我们看看如何来理解满足的这三个特性。
2、Consistency 一致性 一致性指的是所有节点在同一时间的数据完全一致。就好比刚刚举得例子中，小明和小华读取的都是正确的数据，对他们用户来说，就好像是操作了同一个数据库的同一个数据一样。
因此对于一致性，也可以分为从客户端和服务端两个不同的视角来理解。
（1）客户端
从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。也就是小明和小华同时访问，如何获取更新的最新的数据。
（2）服务端
从服务端来看，则是更新如何分布到整个系统，以保证数据最终一致。也就是N1节点和N2节点如何通信保持数据的一致。
对于一致性，一致的程度不同大体可以分为强、弱、最终一致性三类。
（1）强一致性
对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。比如小明更新V0到V1，那么小华读取的时候也应该是V1。
（2）弱一致性
如果能容忍后续的部分或者全部访问不到，则是弱一致性。比如小明更新VO到V1，可以容忍那么小华读取的时候是V0。
（3）最终一致性
如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。比如小明更新VO到V1，可以使得小华在一段时间之后读取的时候是V0。
3、可用性 可用性指服务一直可用，而且是正常响应时间。就好比刚刚的N1和N2节点，不管什么时候访问，都可以正常的获取数据值。而不会出现问题。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。
对于可用性来说就比较好理解了。
4、分区容错性 分区容错性指在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。就好比是N1节点和N2节点出现故障，但是依然可以很好地对外提供服务。
这个分区容错性也是很好理解。
在经过上面的分析中，在理想情况下，没有出现任何错误的时候，这三条应该都是满足的。但是天有不测风云。系统总是会出现各种各样的问题。下面来分析一下为什么说CAP理论只能满足两条。
三、验证CAP理论 既然系统总是会有错误，那我们就来看看可能会出现什么错误。
N1节点更新了V0到V1，想在也想把这个消息通过M操作告诉N1节点，却发生了网络故障。这时候小明和小华都要同时访问这个数据，怎么办呢？现在我们依然想要我们的系统具有CAP三个特性，我们分析一下会发生什么。
（1）系统网络发生了故障，但是系统依然可以访问，因此具有容错性。
（2）小明在访问节点N1的时候更改了V0到V1，想要小华访问节点N2的V数据库的时候是V1，因此需要等网络故障恢复，将N2节点的数据库进行更新才可以。
（3）在网络故障恢复的这段时间内，想要系统满足可用性，是不可能的。因为可用性要求随时随地访问系统都是正确有效的。这就出现了矛盾。
正是这个矛盾所以CAP三个特性肯定不能同时满足。既然不能满足，那我们就进行取舍。
有两种选择：
（1）牺牲数据一致性，也就是小明看到的衣服数量是10，买了一件应该是9了。但是小华看到的依然是10。
（2）牺牲可用性，也就是小明看到的衣服数量是10，买了一件应该是9了。但是小华想要获取的最新的数据的话，那就一直等待阻塞，一直到网络故障恢复。
现在你可以看到了CAP三个特性肯定是不能同时满足的，但是可以满足其中两个。
三、CAP特性的取舍 我们分析一下既然可以满足两个，那么舍弃哪一个比较好呢？
（1）满足CA舍弃P，也就是满足一致性和可用性，舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。
（2）满足CP舍弃A，也就是满足一致性和容错性，舍弃可用性。如果你的系统允许有段时间的访问失效等问题，这个是可以满足的。就好比多个人并发买票，后台网络出现故障，你买的时候系统就崩溃了。
（3）满足AP舍弃C，也就是满足可用性和容错性，舍弃一致性。这也就是意味着你的系统在并发访问的时候可能会出现数据不一致的情况。
实时证明，大多数都是牺牲了一致性。像12306还有淘宝网，就好比是你买火车票，本来你看到的是还有一张票，其实在这个时刻已经被买走了，你填好了信息准备买的时候发现系统提示你没票了。这就是牺牲了一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429f9b7d67bfc77fe51d1b870f0b926a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc74b68a8b8265aaf3fbc8d0b97c605/" rel="bookmark">
			【计算机组成原理】电路基本原理、加法器的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ALU 算术运算：加减乘除等
逻辑运算：与、或、非、异或等
辅助功能：移位、求补等
M S为来自CU控制单元的信号
A和B为两个4bit的数据输入，F为4bit数据的输出
机器字长和ALU位数，输入数据位数和其他寄存器位数相同
逻辑运算和门电路 下面的门电路，分别展示了与门，或门，非门。
一般非都会有个小⭕在前面。
优先级：与&gt;或（类比加减乘除）
Ex：实现AC+AD
异或的逻辑表达与门电路：
同或是异或取反
一位全加器 我们可以将加法化为4个元素的有机结合
每一步的C和S和这一步的A、B以及上一步的C有关。相关逻辑运算如下：
相应的门电路：
一位全加器：
串行加法器： 只有一个加法器，数据逐行传入运算，进位触发器保留进位数，参与下一次运算。
串行进位的并行加法器（行波进位） 把n个全加器串接起来，直接进行两个n位数的相加
more 带组内运行的是将结果根据之前的数据直接运算得出，不需要等输出过来得数据了。
组内并行，组间串行 组内并行，组间并行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bcb00bbef0ae8260501a5ca41aad9e6/" rel="bookmark">
			【计算机组成原理】浮点数的运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浮点数的运算 X = -5/256
Y= +59/1024
计算X-Y
阶符2位，阶码3位，数符2位，尾数9位
X = -5 x 1/256 = -5 x 2-8 = -101x 2-8 = -0.101 x 2-5 = -0.101 x 2-101
Y = 59 x 1/1024 = 59 x 2-10 = 111011x 2-10 = 0.111011 x 2-4 = 0.101 x 2-100
对阶 小阶向大阶看齐
1、求阶差
求出两个数阶的差
Ex: E1=-101 E2=-100 （二进制） 相对应的补码(双符号)为11011, 11100 第二个补码取反为00100 得差为 11011 + 00100 = 11111 补码转为真值为11001，为-1 2、对阶
根据求出的阶差，进行阶码和尾数的移位与变换。
Ex: 根据上面Ex得出第一个阶码比第二个阶码小1 因此x=-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bcb00bbef0ae8260501a5ca41aad9e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288664dd48c5f2cdcc150ff092b4aa52/" rel="bookmark">
			CentOS7部署k8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS版本 ​​​​​​​#cat /etc/redhat-release CentOS Linux release 7.9.2009 (Core) 角色 IP
k8s-master 172.26.197.206
k8s-node1 172.26.201.116
k8s-node2 172.26.203.93
以下步骤，1-8在所有节点执行；9-10在master节点执行
1 关闭防火墙： $ systemctl stop firewalld $ systemctl disable firewalld 2 关闭 selinux： $ sed -i 's/enforcing/disabled/' /etc/selinux/config # 永久 $ setenforce 0 # 临时 3 关闭 swap： $ swapoff -a # 临时 $ vi /etc/fstab # 永久 #注释掉 /dev/mapper/centos-swap swap swap defaults 0 0 这行 systemctl reboot #重启生效 free ‐m #查看下swap交换区是否都为0，如果都为0则swap关闭成功 4 设置主机名： $ hostnamectl set-hostname &lt;hostname&gt; 5 添加 hosts： $ cat &gt;&gt; /etc/hosts &lt;&lt; EOF 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/288664dd48c5f2cdcc150ff092b4aa52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219b0f44b87521270ea18babfee231f6/" rel="bookmark">
			【python学习】批量替换/修改文件某字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 批量替换文件某字符串 任务要求代码思路实现代码 本文实现批量读取文件，并修改文件中某字符串，重新写入文件。
任务要求 要求实现将某文件夹下，所有子文件夹中文件的某个字段进行修改
代码思路 代码思路设计如下：
【对单份文件】
使用read()将文件内容读取为一个字符串使用replace()将该字符串中的某个字段进行替换重新以只写模式读入文件，将修改后的字符串重新写入文件 【对多份文件】
结合os模块，依次读入文件夹路径，子文件夹路径，文件路径，然后使用for循环，对每份文件进行遍历，然后执行读入文件、替换字符串、重新写入文件的操作
实现代码 import os def new_file(file_PATH,old_str,new_str): ''' 该函数实现批量读入文件，并寻找替换某个字符串，将修改后的字符串重新写入文件 file_PATH:主文件夹路径 folder_path：子文件夹路径 file_path：文件路径 old_str:待修改的字符串 new_str：修改后的字符串 ''' folder_list=os.listdir(file_PATH)#文件夹下的子文件夹列表 for folder in folder_list: folder_path=os.path.join(file_PATH,folder)#子文件夹路径 file_list=os.listdir(folder_path)#子文件夹下的文件列表 for file in file_list: file_path=os.path.join(folder_path,file)#文件路径 with open(file_path, "r") as f: # 以只读方式打开文件 data = f.read() # 读取文件，读取为一个字符串 str_replace = data.replace(old_str,new_str)#将字符串中的某个字符进行替换 with open(file_path, "w") as f:#重新打开文件，选择写入模式 f.write(str_replace) # 将修改后的字符串重新写入文件 #函数执行 if __name__ == "__main__": file_PATH=r'/quantum_chemistry/xtb_calc/file' old_str="PBE" new_str="BLYP" new_file(file_PATH=file_PATH,old_str=old_str,new_str=new_str) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c4022e1498e4e0bdc10daf47a1d46b/" rel="bookmark">
			粒子群算法及其Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 算法原理Python实现算法测试 算法原理 粒子群算法，缩写为PSO(Particle Swarm Optimization)，是一种非线性寻优算法，其特点是实现简单、收敛速度快，对多元函数的局部最优有较好的克服能力。
所谓粒子群，就是一群粒子，每个粒子都有自己的位置和速度，记第 i i i个粒子的位置为 x ⃗ i \vec x_i x i​，速度为 v ⃗ i \vec v_i v i​。如果没有任何外加条件，这群粒子的轨迹，将完全由某一时刻的位置和速度决定。
而想要通PSO进行优化的函数，则可理解为对粒子的某种约束。例如，现有一个二元函数 y = x 1 2 + x 2 2 y=x_1^2+x_2^2 y=x12​+x22​，要找到这个函数的最小值，根据当前每个粒子的位置都可以得到一个 y y y，记每个粒子的 y y y值为 y i = x i 1 2 + x i 2 2 y_i=x_{i1}^2+x_{i2}^2 yi​=xi12​+xi22​，那么就当前来说，必定有一个 y y y值最小的粒子，这个粒子会成为其他粒子的风向标，大家都纷纷向这颗粒子靠拢，以便让自己也达到最优。
另一方面，每当经历一轮迭代，第 i i i个粒子都会经历一个地方，如果粒子有记忆的话，它会记住自己的 y y y值最小时的参数，从而不必完全地随波逐流，向当前最优粒子靠拢。
也就是说，粒子的速度，将由三个因素决定，一是粒子当前的速度；二是粒子群中最优粒子的位置；三则是这个粒子曾经去过的最优的位置。
记 X ⃗ i \vec X_i X i​为第 i i i个粒子历史上最好的位置； b ⃗ j \vec b_j b j​为第 j j j次迭代得到的最好结果，则第 i i i个粒子的速度表达式可以记作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c4022e1498e4e0bdc10daf47a1d46b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e20196298ed1fb65344c5d1ce841b6/" rel="bookmark">
			node/npm/nvm node /以及镜像的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node: 概述: Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于ChromeV8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型， [1] 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言
node相关文档: node 命令运行js文件的（自带）
npm 命令包管理器（管理依赖包的）（自带）
nvm node版本管理器（node version manage）（安装）
npx node的快速执行工具（类似于node 快速启动模块）（使用npm安装）
nrm node的npm管理工具（管理npm的镜像）（使用npm安装的）
nvm GitHub地址
配置 在环境变量中进行编辑（如果你不配置对应的环境变量那么在path下要直接填入对应的变量值
在path中进行配置
测试: nvm version
nvm相关指令 nvm current //查看当前的版本
nvm list //以列表形式查看所有管理的版本 nvm use 版本号 //使用当前版本号
npx (node版本5.2以上内置npx) npm i npx -g
nrm (管理对应的镜像地址) npm i nrm -g
npm配置国内淘宝镜像 1.通过cnpm使用淘宝镜像： npm install -g cnpm --registry=https://registry.npm.taobao.org
2.将cnpm设置为淘宝镜像：　cnpm config set registry https://registry.npm.taobao.org
3. 查看cnpm镜像设置： cnpm config get registry
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e20196298ed1fb65344c5d1ce841b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdc7e53e2aedcd9fde64a1a14d0fb66/" rel="bookmark">
			ssm的Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习了SSM 后将其整合成一个小Demo 1 结构图 2 config层 2.1 JdbcConfig （jdbc配置） public class JdbcConfig { @Value("${jdbc.driver}") private String driver ; @Value("${jdbc.url}") private String url; @Value("${jdbc.username}") private String username; @Value("${jdbc.password}") private String password; /** * 创建 dataSource 的bean * @return DataSource */ @Bean public DataSource dataSource(){ DruidDataSource dataSource =new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } /** * 用于事务控制的bean * @param dataSource 参数类型：DataSource 数据库信息 * @return 事务 */ @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager ds =new DataSourceTransactionManager(); ds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cdc7e53e2aedcd9fde64a1a14d0fb66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a586614d9ec2f03f0f98884fe58955d/" rel="bookmark">
			MySQL insert 死锁问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 Insert死锁问题剖析前置知识构造死锁原因故死锁产生的原因 MySQL 5.7 的死锁前提示例原因解决方案 Insert死锁问题剖析 线上有个批量的insert … on duplicate key update语句引发的死锁问题，查过很多资料并且亲自尝试过后，发现好多博客说的都是错的，其实本身只跟insert的顺序有关，在此记录一下备忘。
前置知识 X型锁：排他锁
S型锁：共享锁
行锁：锁住一行记录
Next-Key锁：左开右闭区间
Gap锁：左右开区间
构造死锁 建表：
CREATE TABLE hero ( number INT AUTO_INCREMENT, name VARCHAR(100), country varchar(100), PRIMARY KEY (number), UNIQUE KEY uk_name (name) ) Engine=InnoDB CHARSET=utf8; 构造初始数据：
INSERT INTO hero VALUES (1, 'l刘备', '蜀'), (3, 'z诸葛亮', '蜀'), (8, 'c曹操', '魏'), (15, 'x荀彧', '魏'), (20, 's孙权', '吴'); 好了，开始了，下面开始两个事务，按顺序执行：
事务1
begin: INSERT INTO hero(name, country) VALUES('g关羽', '蜀'); 事务2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a586614d9ec2f03f0f98884fe58955d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469e87736d9a48d6abac1515c68174c2/" rel="bookmark">
			C/C&#43;&#43;，不废话的宏使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经典废话 下面的所有内容全是我在欣赏一串代码时发出的疑问，之前对宏的了解不多，导致在刚看到下面的这串代码的时候是“地铁 老人 手机”，具体代码如下，如果有对这里解读有问题的欢迎在评论区留言。
一、预定义宏 编译一个程序涉及很多的步骤
第一个就是预处理阶段
预处理器就是在源码编译之前进行一些文本性质的操作
主要任务比如： 删除注释，插入被include 包含的头文件的内容，替换由define定义的符号，以及确认根据条件编译进行编译
Visual c + + 编译器预定义某些预处理器宏，具体取决于语言 （C 或 C + +）、 编译目标，以及选择的编译器选项。
Visual c + + 支持 ANSI/ISO C99 标准和 ISO C + + 14 标准所指定的所需预定义的预处理器宏。 该实现还支持几个更多特定于 Microsoft 的预处理器宏。 仅针对特定的生成环境或编译器选项定义一些宏，宏。 除非另有说明，宏的定义整个翻译单元如同它们指定为 /D 编译器选项参数。 在定义时，宏是由预处理器在编译前扩展为指定的值。 预定义的宏不采用任何参数，并且不能重新定义。
常见的预定义宏：
还有更多的一些看如下网址：
https://learn.microsoft.com/zh-cn/cpp/preprocessor/predefined-macros?view=msvc-170
在顶部的代码里，由于不同环境下的语言可能有所不同，为了统一书写，需要根据不同版本的特性来做不同的调整，而这就是通过每个版本特殊的预定义宏来实现的。
二、decltype(x) 以下参考至http://c.biancheng.net/view/7151.html
什么是decltype decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。
decltype 是“declare type”的缩写，译为“声明类型”。
既然已经有了 auto 关键字，为什么还需要 decltype 关键字呢？因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/469e87736d9a48d6abac1515c68174c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce22d17a2fd676f9413e3b47e7e4bb7/" rel="bookmark">
			linux常用压缩-解压-打包命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 常见的压缩文件扩展名2 gzip, zcat/zmore/zless/zgrep3 bzip2, bzcat/bzmore/bzless/bzgrep4 xz, xzcat/xzmore/xzless/xzgrep5 tar6 zip、rar、7z7 多线程压缩 1 常见的压缩文件扩展名 *.Z compress 程序压缩的文件； *.zip zip 程序压缩的文件； *.gz gzip 程序压缩的文件； *.bz2 bzip2 程序压缩的文件； *.xz xz 程序压缩的文件； *.tar tar 程序打包的数据，并没有压缩过； *.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩 Linux上常见的压缩指令就是compress、gzip、bzip2、xz，为了支持 windows 常见的 zip，Linux 也加入了 zip 指令。其中compress出现最早，现已不常用。gzip、bzip2、xz 按时间早晚先后出现，并且压缩比一个比一个高。
起初，tar 仅提供单纯的“打包”功能，即将很多文件打包为一个文件。后来，GNU 将整个 tar 与压缩的功能结合在一起，如此一来提供使用者更方便并且更强大的压缩与打包功能！
2 gzip, zcat/zmore/zless/zgrep gzip 可以说是应用度最广的压缩指令了！目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。gzip 所创建的压缩文件后缀名为 *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce22d17a2fd676f9413e3b47e7e4bb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c0ba9ceae593790b15d6aa2a6f554d/" rel="bookmark">
			百度富文本编辑器UEditor配置及功能实现详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前功能基于PHP，其它语言流程大抵相同。
大概流程：
1. 将docx文件上传到服务器中
2. 使用PHPoffice/PHPword实现将word转换为HTML
3. 将HTML代码返回并赋值到编辑器中
1 编辑器配置修改
1.1 新增上传word json配置
在ueditor\php\config.json中新增如下配置：
/* 上传word配置 */
"wordActionName": "wordupload", /* 执行上传视频的action名称 */
"wordFieldName": "upfile", /* 提交的视频表单名称 */
"wordPathFormat": "/public/uploads/word/{yyyy}{mm}{dd}/{time}{rand:6}", /* 上传保存路径,可以自定义保存路径和文件名格式 */
"wordMaxSize": 102400000, /* 上传大小限制，单位B，默认100MB */
"wordAllowFiles": [".docx"] /* 仅支持docx格式的word */
1.2 修改编辑器配置文件
1.2.1 在工具栏上新增按钮
在ueditor\ueditor.config.js文件中，新增按钮名称"wordupload"，并添加鼠标悬浮提示，如下所示：
//工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的重新定义
, toolbars: [[
'fullscreen', 'source', '|', 'undo', 'redo', '|',
'bold', 'italic', 'underline', 'fontborder', 'strikethrough', 'superscript', 'subscript', 'removeformat', 'formatmatch', 'autotypeset', 'blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist', 'selectall', 'cleardoc', '|',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c0ba9ceae593790b15d6aa2a6f554d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2290966736a78476d6956d05eee50d69/" rel="bookmark">
			Flume汇入数据到Hive&amp;Hbase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章内容代码部分地方需要根据自身的环境路径进行修改！
目录
前言
一.Flume汇入数据到Hive
方法一：汇入到Hive指定的HDFS路径中：
1.在hive中创建数据库和外部表
2.在/root中创建hive.log文件 3.在flume的conf路径中编写配置文件
4.运行flume
5.查询hdfs中的数据
6.在hive表中加载数据
7.查询hive表中的数据
方法二：利用HiveSink汇入数据
1.从hive/lib和和hive/hcatalog/share/hcatalog/中找寻下列JAR包，放入到flume/lib中。如果flume中有重名的则先删除flume中的再进行复制。
2.编写flume的配置文件
3.在hive中创建表
4.在hive中设置权限
5.启动metastore服务
6.运行flume
7.查询数据
二.Flume 汇入数据到HBase
一、Flume 的HBaseSinks 详细介绍
二.HBaseSink
三.HBaseSinks的三种序列化模式使用
1.SimpleHbaseEventSerializer
2.SimpleAsyncHbaseEventSerializer
​编辑 3.RegexHbaseEventSerializer
总结
前言
提示：这里可以添加本文要记录的大概内容：
主要讲述Flume汇入数据到Hive&amp;Hbase的方法及操作。
提示：以下是本篇文章正文内容，下面案例可供参考
一.Flume汇入数据到Hive 方法一：汇入到Hive指定的HDFS路径中： 1.在hive中创建数据库和外部表 代码：
create database flume; 代码：
create external table flume_into_hive(name string,age int) partitioned by (dt string) row format delimited fields terminated by ',' location '/user/hive/warehouse/flume.db/flume_into_hive'; 2.在/root中创建hive.log文件 代码：
mkdir flume-hive cd flume-hive/ vi hive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2290966736a78476d6956d05eee50d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8dbbab8664360e35ed14267d007430/" rel="bookmark">
			SNAP处理Sentinel-1数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ①轨道校正
Radar-&gt;Apply orbit file 在弹出来的框中要选中“Do not fail if new orbit file is not found”
不然会出现错误“qc.seninel1.eo.esa.int”
②辐射校正
Radar-&gt;Radiometric-&gt;Calibrate
(一般在完成界面上方有一行红字就是操作成功完成了)
③相干斑滤波
Radar—&gt;Speckle Filtering—&gt;Single Product Speckle Filter
④地形校正
Radar —&gt;Geometric — &gt;Terrain Correction — &gt; Range-Doppler Terrain Correction 在Digital Elevation Model这一行选择“SRTM 1Sec HGT(Auto Download)”,默认是3Sec会陷入无限的EDM获取中。 "Mask out areas wiithout elevation"前的勾去掉。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb6c6448662e7cddc5f36d77d3f2d6e/" rel="bookmark">
			谷歌浏览器 无法翻译此网页问题（已解决，亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：习惯使用谷歌浏览器，这几天出现了无法翻译此网页的问题，本以为是版本的问题，没想到升级后还是不能翻译，在网上看到这个方法（更改hosts文件），亲测有效，写这篇文章记录分享一下。
一、找到C:\Windows\System32\drivers\etc目录下的hosts文件，如图示：
二、打开hosts文件（可以直接选择用记事本打开），打开后如图示：
三、修改hosts文件，在最下面加入
203.208.40.66 translate.google.com
203.208.40.66 translate.googleapis.com
四、 刷新 DNS，如图所示：
（win+R）打开控制台，输入ipconfig /flushdns 命令 刷新DNS
五、重启谷歌浏览器
到这里，谷歌浏览器应该就可以正常翻译了！
写在后面：
① 如果提示没有权限修改hosts文件，可以将hosts文件拖到桌面，修改完成后再放回原位置；也可以修改hosts文件的权限，这里不再详述。
② 修改hosts文件时，另一个方法是先在文件名后面加上.txt再进行修改，但是这样保存之后是另一个文本文件，而且后面还需要修改文件类型，比较麻烦，因此建议将hosts文件拖到桌面，修改完成后再放回原位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2aeb232086bab445fdff658721832e/" rel="bookmark">
			Dubbo ScopeModel 的设计思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文我来简单描述一下 Dubbo ScopeModel 的设计思想。
上图是 Dubbo ScopeModel 的源码、我们可以从一段简单的注释看到
FrameworkModel -&gt; ApplicationModel -&gt; ModuleModel，中间的映射都是 1:N 的 抽象这三个能力是为了实现 Dubbo 的多实例支持，FrameworkModel 是实现类似 JVM 租户级别的隔离，ApplicationModel 是为了实现一个机器上发布多个应用（如 demo-application1 和 demo-application2 一起发布），ModuleModel 是为了实现服务生命周期的独立管理（如一个 demo-application 可以由多个 Spring 容器共同提供）。
所以一个 Dubbo 服务是对应到 ModuleModel 上的。 举一个复杂一些的例子，比如:
目前需要发布 DemoInterface1、DemoInterface2、DemoInterface3、DemoInterface4 四个服务，分别订阅 DemoService1、DemoService2、DemoService3、DemoService4 四个服务。
其中 DemoInterface1 和 DemoInterface2 由 demo-application-1 这个应用名发布（而且由 2 个 Spring Context 分别管理），DemoInterface3 和 DemoInterface4 由 demo-application-2 这个应用名发布 ，DemoService1、DemoService2、DemoService3、DemoService4 由 demo-application-3 这个应用名订阅。此外出于多租户的考虑，DemoInterface1、DemoInterface2、DemoInterface3、DemoInterface4 在 20880 端口和 20881 端口都独立发布，这 8 个服务（多租户 2 * 4 个服务）的实现都不一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c2aeb232086bab445fdff658721832e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79048f725408d375a19da45df59bd10f/" rel="bookmark">
			独立逆变器系统MATLAB-simulink建模及仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独立逆变器不同于并网逆变器，是一种将直流电转换为特定频率与幅值交流电的电力电子装置，一般作为EPS、UPS以及孤岛微电网系统的雏形装置。由于其负载的多样性导致独立逆变器必须具备快速适应负载变化的特性。本设计通过对独立逆变器系统传递函数分析并由分析结果设计PID控制器，实现了电压电流三闭环的控制系统仿真，其仿真结果在不同比例系数下做了比较，同开环系统相比更具备快速响应能力和更高的系统稳定性，对不同的负载变化也更加满足响应要求。
一、系统框架图
本设计逆变器主电路如图所示，经过LCL滤波器，滤除高频成分在负载处获得光滑的正弦波，控制技术采用正弦脉宽调制法（SPWM），图中L1、L2为滤波电感，其各自线路有等效阻抗RL。
假设负载为电阻R时，输出电压与输入电压之间的传递函数为：
当负载为R无穷大时，得到逆变空载时的传递函数：
由于逆变器在空载时的阻尼最小，振荡性最为强烈，控制难度也大，因此控制器的设计也必须基于空载来进行，逆变器空载时的传递函数可表示为： 其中， 设计中，滤波电感L=2mH，RL=1Ω，滤波电容C=20uF，功率管开关频率为10KHz，代入式可得： 阻尼系数 转折频率为
由自控原理知识，系统在转折频率处出现较大的谐振峰值，且随着负载R得不断增大谐振峰值也增加，在R无穷大空载时，谐振峰值达到最大， 为了保证系统在任何负载条件下都能够稳定，设计时以空载状态下谐振频率点处的稳定性作为设计指标。
二、PID算法及控制器设计
模拟式PID算法表达式为
其中， 为控制器的输出信号，为误差信号，是比例系数，是积分时间常数，是微分时间常数，写成传递函数形式： 以和式代替积分，以增量代替微分，离散化后，为
其中，T为采样周期，令积分系数，微分系数，则有 增量式PID算法为：
当逆变器采用PID控制方式时，由于被控对象本身为相位滞后系统，逆变桥在系统中的作用也等效为一阶保持器，具有一个开关周期的滞后效应，再加上数控系统本身的计算延迟，使整个系统滞后效应非常明显，宜采用P调节器或微分作用很小的PD调节器，不宜采用具有滞后作用的积分运算。
PID控制器参数的整定一般采用试凑法，先采用比例控制器，KP有小到大逐渐改变直到系统变得不稳定，如果此时可以得到满意的系统特性，表明只采用比例调节器即可。如果系统的动态特性和 稳定精度不能满足要求，可采用PI调节器。开始时，把参数TI设大一些，然后反复调整KP和TI。如果系统的动态特性不能满足要求，可以再加入微分调节器。TD由小到大逐次改变，并相应改变KP值，反复试凑，直到得到满意的性能为止。
在控制过程中，不希望输出值出现极限状态，为安全起见，设置了上限限位和下限限位。
三、仿真建模及结果分析
1、独立逆变器建模
独立逆变器不同于并网逆变器，这是一种将直流电转换为特定频率与幅值交流电的电力电子装置，一般作为EPS、UPS以及孤岛微电网系统的雏形装置。直流侧接蓄电池，由大电容稳压，经逆变桥转换为交流电，再经滤波器输出至负载端，由于负载的多样性导致独立逆变器必须具备快速适应负载变化的特性。
利用matlab建立了基于电压电流内环的单相独立逆变器的仿真模型，如图2所示。
电压外环的输出量Uref*(311V)与输出端电压Uac的误差值送入PID调节器，PID调节器输出信号Iref*，Iref*作为电流内环的给定信号，电流互感器采集的负载电流信号与Iref*的误差值送入PID调节器，产生用于产生PWM脉冲的调制波信号，从而保证独立逆变器输出端电压与负载电流的稳定性。PID调节器的输出可用于限制负载电流幅值以防止系统过流从而起到保护独立逆变器的作用。
SPWM产生模块如下图：
IGBT全桥逆变双脉冲输入模块如下图：
2、仿真结果
独立逆变器输出电压与电流波形
独立逆变器输出电压波形
独立逆变器输出电压反馈处误差波形
四、1KW储能逆变器功能说明
1、储能逆变器两种工作模式
（1）并网模式（并网充电、并网放电）；（2）独立逆变模式。
2、运行状态描述
当逆变器器开机进入初始状态时，控制系统将完成自检，以验证控制和传感器系统的完整性。监控和保护功能正常启动，变流器进入停机状态。停机状态时，储能变流器封锁IGBT脉冲，断开交直流继电器。待机状态时，储能变流器封锁IGBT脉冲，但闭合交直流继电器，变流器处于热备份状态。
储能逆变器可以在不同模式中转换，需要满足的条件如图7所示。
3、功能描述
①运行信息，即运行指示灯和实时数据显示功能。实时数据显示包括：“直流电压”，“直流电流”，“电网电压”，“电网电流”，“电网频率”，“机内温度”，“充电功率”，“放电功率”，“有功功率”，“无功功率”，“功率因数”以及当前工作状态，各模块温度等等。
②三种模式功能：
充电模式---包括恒压充电、恒流充电、恒功率充电；
放电模式---包括限压放电、恒流放电、恒功率放电；
控制模式---包括待机、停机、计时充放电、独立逆变功能。
③参数设置功能：
系统参数设置---包括密码设置、时钟、电量校正、恢复出厂；
保护参数设置---直流过压点、直流欠压点、电网过频值、电网欠频值、电网过压值、电网欠压值；
通讯参数设置---设置设备地址、波特率、通讯方式。
④历史信息查询功能：
历史事件---机器最近的100条运行信息（非故障）；
故障信息---机器最近的100条故障信息，包括发生时间和故障类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a57083cbbea77abfd6e42e19679374/" rel="bookmark">
			Dubbo源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题。相比其他RPC框架，dubbo更加灵活，可以做到方法级别的服务治理，粒度更细。
Dubbo作用域隔离 Dubbo 3.x支持在一个进程中启动多个dubbo实例，通过ApplicationModel进行隔离。
利用父委派机制/双亲委派模型进行类的加载，比如加载ModuleConfig，ModuleModel会先委派父级ApplicationModel，ApplicationModel会委派给它的父级FrameworkModel，FrameworkModel加载不了，然后会重新交给ApplicationModel，ApplicationModel也加载不了，又再次递回给ModuleModel去加载。
父委派/双亲委派模型：某个特定的类加载器在接到加载类的请求时，首先将加载任务委派给父类加载器，依次递归到顶级父类，如果父类加载器可以完成类加载任务，就成功返回；如果父类加载器无法完成加载任务，再反向交给子类加载器去加载，依次反向递归，直到某个子类加载器完成加载任务。
dubbo通过作用域ScopeModel对不同范围的配置数据进行作用域管理：
Dubbo如何实现双亲委派 new ServiceConfig() --&gt; new AbstractServiceConfig() --&gt; new AbstractServiceConfig() --&gt; new AbstractInterfaceConfig() --&gt; new AbstractMethodConfig() --&gt; ApplicationModel.defaultModel().getDefaultModule()
public class FrameworkModel extends ScopeModel { public FrameworkModel() { super(null, ExtensionScope.FRAMEWORK, false); this.setInternalId(String.valueOf(index.getAndIncrement())); // register FrameworkModel instance early synchronized (globalLock) { allInstances.add(this); resetDefaultFrameworkModel(); } initialize(); // 初始化framework范围的配置 } @Override protected void initialize() { super.initialize(); TypeDefinitionBuilder.initBuilders(this); // 定义作用域类型 // 定义当前作用域范围内存仓库 serviceRepository = new FrameworkServiceRepository(this); // 扩展点 ExtensionLoader&lt;ScopeModelInitializer&gt; initializerExtensionLoader = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a57083cbbea77abfd6e42e19679374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06dfba1d09436f13c65db16dc71c7c65/" rel="bookmark">
			Linux系统上库文件的生成与使用（静态库和动态库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是库文件？
2、静态库的生成与使用
2.1、生成 .o 文件
2.2、创建静态库
2.3、使用静态库
3、动态（共享）库的生成与使用
3.1、生成 .o 文件
3.2、生成动态库文件
3.3、使用动态库
4、静态库与动态库的区别
1、什么是库文件？ 库是一组预先编译好的方法的集合，是计算机上的一类文件，提供给使用者一些开箱即用的变量、函数或类。库文件分为静态库和动态库，静态库和动态库的区别体现在程序的链接阶段。
一般来说，Windows的静态库文件扩展名是 .lib，动态库文件扩展名是 .dll (Dynamic-Link Libraries)；Linux的静态库扩展名是 .a，动态库扩展名是 .so (Shared Object)。内容一样，都是将函数封装，编译后生成.o文件，将所有 .o 文件合并生成库文件，再将供自己或他人调用。好处在于编译后的库文件的源代码被加密，使用者看不到，可保密。
Linux系统存储的库的位置一般在：/lib 和 /usr/lib。 在 64 位的系统上有些库也可能被存储在/usr/lib64 下。库的头文件一般会被存储在 /usr/include 下或其子目录下。
Linux库有两种，一种是静态库，其命令规则为 libxxx.a；一种是共享库，其命令规则为 libxxx.so。
2、静态库的生成与使用 静态库是.o 文件打包的结果，.o文件的数量可以是1个，也可以是多个。生成的过程需要使用 ar 工具来操作。
测试文件：
add.c：
max.c：
foo.h：
main.c：
2.1、生成 .o 文件 使用命令：gcc -c 源文件序列。
命令的用法是多种多样的，可以分步经 预处理、编译、汇编 生成 .o 文件，也可以直接使用 gcc -c 源文件名，一步生成 .o 文件。
例如，使用命令 gcc -c add.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06dfba1d09436f13c65db16dc71c7c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554d9d4874c479ea7e6bfbaca47633e0/" rel="bookmark">
			20、断点调试（debug）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本介绍：
（1）断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下，进行分析从而找到这个Bug
（2）断点调试也能帮助我们查看java底层源代码的执行过程，提高我们的java水平
（3）在断点调试过程中，是运行状态，是以对象的运行类型来执行的
2、快捷键：
F7：跳入方法内
F8：逐行执行代码（跳过）
shift+F8：跳出方法
F9：rsume，执行到下一个断点
3、案例：
（1）
（2）追源码（看java设计者是怎么实现的，可以提高编程思想）
技巧：将光标放在某个变量上，可以看到最新的数据
idea debug如何进入jdk源码？
方法1：
使用force step into;快捷键alt+shift+F7
方法2：
idea→Setting→Build,Execution,Deployment→Debugger→Stepping→把"Do not step into the classes"中的java.*,javax.*取消勾选即可→然后把光标放在某个变量上，点击“步入”的键即可进入源码中
（3）如何直接执行到下一个断点F9（在debug过程中动态地下断点，随意地快进）
下完断点后，点击左侧的绿键即可运行 4、练习题
package Debug; //使用断点调试的方法追踪下一个对象创建的过程 //另外也使用断点调试来查看动态绑定机制是如何工作的 public class DebugExercise { public static void main(String[] args) { //创建对象的流程 //1、加载Person信息 //2、初始化 2.1默认初始化 2.2显式初始化 2.3构造器初始化 //3、返回对象的地址 Person1 p1=new Person1("jack",18); System.out.println(p1); } } class Person1{ private String name; private int age; public Person1(String name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/554d9d4874c479ea7e6bfbaca47633e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86344b3ae1bd99aa9b9db07aa4175036/" rel="bookmark">
			k8s Pod基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、资源限制
二、Pod的两种使用方式
三、Pod资源共享
四、底层容器Pause
1.Pause共享资源
网络
存储
2.Pause主要功能
3.Pod与Pause结构的设计初衷
五、Pod容器的分类
1.基础容器（infrastructure container）
2.初始化容器（init container）
Init 的容器作用
3.应用容器（main container）
六、操作示例
1.编写myapp.yaml
2.myapp.yaml配置资源
3.查看pod创建过程
4. 发现开启 init-myservice 容器后，创建步骤停滞，查看 init-myservice 日志进一步查明原因
5.编写myservice.yaml
6.创建myservice.yaml配置资源
7.编写mydb.yaml
8.创建mydb.yaml配置资源
9. chakan myapp-pod创建全过程
10.小结
七、镜像拉取策略（Image PullPolicy）
1、官方示例
2.不指定版本，查看默认拉取策略
不指定版本号创建Pod
查看默认拉取策略
查看创建过程
3.测试案例（非循环命令）
创建测试案例mypod.yaml
查看创建过程
修改mypod.yaml
删除原有资源
更新资源
4.测试案例（循环命令）
修改mypod.yaml
生成新的 mypod.yaml 配置资源
检查mypod.yaml文件
查看pod日志
一、资源限制 Pod是kuberbetes中最小的资源管理组件，Pod也是最小化运行容器化应用的资源对象。一个Pod代表着集群中运行的一个进程。kubernetes中其他大多数组件都是围绕着Pod来进行支撑和扩展Pod功能的，例如用于管理Pod运行的StatefuSet和Deployment等控制器对象，用于暴露Pod应用的Service和Ingress对象，为Pod提供存储的PersistenVolume存储资源对象等。
二、Pod的两种使用方式 一个Pod中运行一个容器，每个Pod中一个容器的模式是最常见的用法，在这种使用方法中，你可以把Pod想象成是单个容器封装，kubernetes管理的是 Pod而不是直接管理容器。在一个Pod中同时运行多个容器。一个Pod也可以同时封装吉哥需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个service单位，比如一个容器共享文件，另一个sidecar容器来更新这些文件。Pod将这些容器的存储作为一个实体来管理。 三、Pod资源共享 一个 Pod 下的容器必须运行于同一节点上。**现代容器技术建议一个容器只运行一个进程，该进程在容器中 PID 命令空间中的进程号为 1，可直接接收并处理信号，进程终止时容器生命周期也就结束了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86344b3ae1bd99aa9b9db07aa4175036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded01de69fa25669699ff041cad2b087/" rel="bookmark">
			处理vscode下的控制台输入node时,出现“无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称“的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、vscode下按出powershell的快捷键:Ctrl+~
2、输入node命令,报错如下:
3、解决办法：
在window搜索栏输入"windows powershell ",以管理员身份运行后输入命令:
set-ExecutionPolicy RemoteSigned，回车后选择a
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c04b42095cb0baa7291596539f31c11/" rel="bookmark">
			Qt OpenCV 在界面显示图片 通过Lable方式 和GraphicsView 方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 通过lable方式打开图片。 代码如下：
void MainWindow::on_pushButton_clicked() { Mat srcImage,gray_image,srcImage1; QString Fileadd = QFileDialog::getOpenFileName(this,"get file"); if(Fileadd.isEmpty()) { QMessageBox::information(this,"警告","没有选择文件"); return ; } srcImage = imread(Fileadd.toLatin1().data()); //读取图片 cvtColor(srcImage,srcImage1,COLOR_BGR2RGB); // 图像格式转换 QImage disImage = QImage((const unsigned char*)(srcImage1.data),srcImage1.cols,srcImage1.rows,QImage::Format_RGB888); ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(disImage.scaled(ui-&gt;label-&gt;size(), Qt::KeepAspectRatio))); } 效果图如下：
2.Graphics View 方式打开图片 代码如下：
void MainWindow::on_pushButton_2_clicked() { QString fileName = QFileDialog::getOpenFileName(this,tr("Open Image"),".",tr("Image File(*.png *.jpg *.jpeg *.bmp)")); if (fileName.isEmpty()) { return; } Mat srcImage = imread(fileName.toLatin1().data());//读取图片数据 cvtColor(srcImage, srcImage, COLOR_BGR2RGB);//图像格式转换 QImage disImage = QImage((const unsigned char*)(srcImage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c04b42095cb0baa7291596539f31c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37f55a5eb42902750a3a4e6ed0e1c25/" rel="bookmark">
			微服务国产化改造-金蝶Apusic应用服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、金蝶Apusic配置 2.1、修改启动端口 注意查看端口是否被使用
lsof -i tcp:9999
修改/opt/AAS/domains/mydomain/config/apusic.conf
&lt;ATTRIBUTE NAME="Port" VALUE="9999" /&gt;
2.2、修改jvm启动参数
根据需要，修改/opt/AAS/domains/mydomain/bin/data.xml
&lt;aasjvm&gt;-Xms2g -Xmx2g -XX:MaxPermSize=768m&lt;/aasjvm&gt;
2.3、开启DELETE,PUT,TRACE,OPTIONS请求方式
修改文件/opt/AAS/domains/mydomain/config/vm.options
注释apusic.http.disabledMethods
#apusic.http.disabledMethods=DELETE,PUT,TRACE,OPTIONS
二、后端服务改造
2.1、pom.xml改造
排除springboot内嵌tomcat
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
&lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
添加servlet支持
&lt;dependency&gt;
&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
&lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
&lt;version&gt;3.1.0&lt;/version&gt;
&lt;/dependency&gt;
修改打包方式
&lt;packaging&gt;war&lt;/packaging&gt;
打包插件配置
&lt;plugin&gt;
&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
&lt;version&gt;2.2&lt;/version&gt;
&lt;configuration&gt;
&lt;!--如果想在没有web.xml文件的情况下构建WAR，请设置为false。--&gt;
&lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
2.2、启动类修改
继承SpringBootServletInitializer ，重写 configure 方法。
public class OrganizationApplication extends SpringBootServletInitializer {
@Override
protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
return builder.sources(new Class[]{OrganizationApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37f55a5eb42902750a3a4e6ed0e1c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37bfad2babc309beb3c1ac0170fde476/" rel="bookmark">
			使用Ventoy制作U盘启动项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在安装linux镜像的时候遇到了使用UltraISO软件制作U盘启动盘无法使用的情况。
下面介绍另外一个软件把U盘制作成启动盘Ventoy：
下载地址：Ventoy
使用方法：
1.下载好Ventoy，进行解压，打开其中的Ventoy2Disk.exe
2.在设备一栏选择自己的U盘
3.点击安装，弹窗都选择 是
4.点击升级，弹窗都选择 是
5.将 ISO 镜像文件保存在U盘 根目录下
6.将U盘插入电脑，在开机时进入boot页面，选择UEFI开头的U盘
7.即可看到之前放入的镜像文件。
以上是使用Ventoy制作U盘启动项的方法，此外U盘内还可以放一些其余文件也没关系。
更详细教程：
Ventoy 制作U盘启动盘 使用教程_李昊哲-小课的博客-CSDN博客_ventoy使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b69c2e4f0b714466095383d4ad1217/" rel="bookmark">
			import tensorflow.keras报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tensorflow版本为： tensorflow-gpu==2.10.0
输入命令：
import tensorflow.keras
错误信息：
ModuleNotFoundError: No module named 'tensorflow.keras'
解决方法：
(1)确认已正确安装tensorflow (2)使用命令 import tensorflow.python.keras 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e5c8094353a8ee26b312729fcb9bbea/" rel="bookmark">
			Win10安装Microsoft Store
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1UpGOOENs99_1pohOWZHv7Q 提取码：drpm
下载压缩包并解压，看readme.md文件内容操作。
进入存放.Appx后缀文件的目录，Shift+右键打开PowerShell窗口，输入 Add-AppxPackage * 命令并回车。
搜索Microsoft Store可以看见已经安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3634760f51bd515be62dda765bf5c9/" rel="bookmark">
			瑞利分布与莱斯分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例2-1 瑞利分布与莱斯分布
% 瑞利分布与莱斯分布 clear,clf%clear：清除工作空间的所有变量 clf：清除当前的Figure N = 200000;%产生200000个信道系数供统计使用 level = 30;%统计区间被划分的分数 K_dB = [-40 0 15];%莱斯因子为-40dB 0dB 15dB gss = ['k - *'; 'k - o'; 'k - +';'k - ^'];%绘制曲线的颜色、线线与标志符号 % 瑞利模型 Rayleigh_ch = Ray_model(N);%调用Ray_model子程序，产生瑞利分布幅度系数 [temp,x] = hist(abs(Rayleigh_ch(1,:)),level); %统计数据分布 ：表示所有的，(1,:)即第一行所有列 plot(x,temp,gss(1,:)) hold on %莱斯模型 for i=1:length(K_dB);%对不同莱斯因子进行信道模型仿真 i循环从1循环到length（K_dB)=3 Rician_ch(i,:) = Ric_model(K_dB(i),N);%调用Ric_model产生莱斯分布幅度系数 [temp x] = hist(abs(Rician_ch(i,:)),level);%统计数据分布 plot(x,temp,gss(i+1,:)) end xlabel('x'),ylabel('Occurrence') legend('Rayleigh','Rician,K = -40dB','Rician,K = 0dB','Rician,K = 15dB') %在坐标区上添加图例 %莱斯信道模型子程序，子程序程序名称：Ric_model.m function H=Ric_model(K_dB,L) %输入参数：K_dB为莱斯因子，L为仿真信道个数 %输出参数：H为返回莱斯信道矩阵 K = 10^(K_dB/10);%将dB值描述的莱斯因子转换为幅度值 H = sqrt(K/(K+1)) + sqrt(1/(K+1))*Ray_model(L); %产生莱斯信道幅度系数。莱斯信道模型中包含视距通信，收发之间有直通路径 %瑞利信道模型子程序，子程序程序名称：Ray_model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3634760f51bd515be62dda765bf5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a89b542e99c166f5b57103250141780/" rel="bookmark">
			VScode安装Flask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Win+R—cmd—切换目录至D盘（或其他地方）
2.创建虚拟环境：
d:\&gt; md pywebgis
d:\&gt; python -m venv \pywebgis
3.激活虚拟环境（先切换目录至虚拟环境）
d:\cd d:\pywebgis
d:\pywebgis&gt;.\Scripts\activate
4.安装Flask
(pywebgis) D:\ pywebgis&gt;pip install flask
5. 连接d:\pywebgis到工作区，创建hello文件夹\app.py文件，运行一下（或者用其他方法），主要就是把工作环境转到d:\pywebgis来。
6.在VScode的终端输入pip install flask，相当于在VScode“重新安装”Flask（实际上并没有，只是需要用Flask而已）。
7.在app.py中写代码并运行（可以右击—Run Code）。
from flask import Flask app=Flask(__name__) @app.route('/') def index(): return "hello world" if __name__=='__main__': app.run(debug = True) 8.运行结果（终端或者输出都可以看）。可以复制打开划线网址，或者Ctrl+鼠标点击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deac8ef0c93857ed47756d78e8fa4049/" rel="bookmark">
			简易配置：vim添加systemverilog语法高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在gvim使用中，有时需要添加systemverilog语法支持：（Lniux环境下）
简易配置方式：
1）所需要语法支持包：自己可去其它网站下载，或者在：systemverilog.vim-1.9插件包
2）解压systemverilog.vim-1.9.zip文件（这里，我采用的是这个1.9版本）：
得到：ftdetect、indent、syntax 三个目录（里面都有相应的支持语法的vim配置文件）。
2）在用户目录下（~/），ls -a 查看找到 .vim目录；如果没有，自己建立一个。
3）将ftdetect、indent、syntax三个目录, 复制到.vim目录下，即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1aeb0898f1242cfcb49942e411c393/" rel="bookmark">
			一键制作三维真实地形DEM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一键制作三维真实地形 建过三维地形的同仁们都清楚，要建出一个精确的地形模型基本要靠CAD，GIS，AI这些软件协同操作。还需要下载在线底图，多重叠加分析。
如果说有一个PS插件可以在半个小时，甚至几分钟内生成一张这样的可视化的3D地形图，是否足够黑科技？▼
https://www.3d-map-generator.com/
在下面网址选择一真实地形，保存 https://tangrams.github.io/heightmapper/
范围选择好后，选择“Export”
把上面的图层丢进PS，可以用ctrl T自由变换或者裁剪工具修改大小
之后去Google Map截图一张卫星影像
记得把标签去掉
https://www.google.com/maps
把影像截图粘贴到PS中，这样PS中就有两个图层，一个地形、一个影像。还可以修改画布大小，要确保影像和地形的范围是重叠的（设置一个观测点）
选中地形图层，之后点击创建地形
如图所示，创建好了，接下来选中“Top layer groups”图层
top_layer_groups中top_layer_hd的第一个图层双击进行编辑。再把影像图层复制过去
在top_layer_01.psb上Ctrl+s 保存后打开地形图界面我们就可以看到地形已经出现在了模型上。（如果没出现，按下面的top_layer_01.psd图层位置修改）
这样就制作好了，接下来就可以按自己的需求绘制了。
最后可以添加一点气象要素，整张图就完成了。
可惜的是，这个插件是收费的，不算贵也不算便宜
这系列我目前在试用中，目标是复现NS的水循环概念图。
这系列我目前在试用中，目标是复现NS的水循环概念图。
条件允许，还是支持正版为好。21美刀的价格，相比其他软件还是物超所值的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b92ff1594592f21ed05124a0df0f4a/" rel="bookmark">
			Gitlab 设置页面语言为简体中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用户登录，点击头像，再点击Preferences
2.向下滑动，找到 Localization，进行修改，并保存
3.刷新页面，就更改成简体中文了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1b52a055272f7aa2ff2ea07bbca7f5/" rel="bookmark">
			IP地址的划分、分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IP地址的划分： IP地址一个包括五大类，分别是A类IP地址、B类IP地址、C类IP地址、D类IP地址和E类IP地址。其中
A类IP地址的范围是0-127，在这个范围内的0表示的是任何地址，127表示的是回环测试相应的地址，由此我们可以看出A类IP地址的实际范围是1-126，255.0.0.0是A类IP地址的默认子网掩码，其显示的子网掩码在一个范围当中。　B类IP地址的范围是128-191，其中子网掩码128.0.0.0和子网掩码191.255.0.0都是保留IP，B类IP地址的子网掩码实际范围是从子网掩码128.1.0.0到子网掩码191.254.0.0。
C类IP地址的范围是192-223，在这个范围当中的保留IP为子网掩码192.0.0.0和子网掩码223.255.255.0，C类IP地址的子网掩码实际范围是从子网掩码192.0.1.0到子网掩码223.255.254.0。
D类IP地址资子网掩码的范围是子掩码网224.0.0.0到子网掩码239.255.255.255，这两个子网掩码范围内的地址一般用于多点广播。
E类IP地址子网掩码的范围是从子网掩码240.0.0.0到子网掩码55.255.255.254，这两个子网掩码范围的IP地址一般用于地址的广播。
二、获取IP地址的方式 1、静态分配IP地址
静态分配也称为手工分配。网络管理员在计算机中直接设置所使用的IP地址。在 Windows 系统中，用户可以在“Internet协议版本4（TCP/IPv4）属性”对话框中手动配置静态地址。
2、动态分配IP地址
动态分配是指计算机向 DHCP 服务器申请 IP 地址，获取后使用该地址。这时，计算机作为 DHCP 客户机。
在这个过程中，DHCP 客户机向 DHCP 服务器租用 IP 地址，DHCP 服务器只是暂时分配给客户机一个IP地址。只要租约到期，这个地址就会还给 DHCP 服务器，以供其他客户机使用。如果 DHCP 客户机仍需要一个 IP 地址来完成工作，则可以再申请另外一个 IP 地址。所以，计算机获取的IP地址每次都可能变化，属于动态分配。
3、零配置
在动态分配方式中，如果 DHCP 服务器不在线或出现故障等情况时，客户机就无法获取地址。这时，有些系统将会通过零配置技术为自己分配一个私有的地址，范围为 169.254.0.0~169.254.255.255。
三、申请IP的方法 一种方法是：直接成为APNIC的会员单位，直接从APNIC获得IP地址，但是必须向APNIC交纳2500美元到10000美元不等的年费，而且会员的规模越小，申请地址的难度相对较大；
另外一种方法是：加入一个IP地址分配联盟（以下简称分配联盟），通过分配联盟召集单位向APNIC交纳一定的年费及向召集单位交纳联盟成员费。
中国互联网络信息中心（China Internet Network Information Center，简称CNNIC）以国家NIC的身份于1997年1月成为APNIC的大型会员，成立了以CNNIC为召集单位的分配联盟，我们称为CNNIC分配联盟。按照APNIC的有关规定（APNIC-051），CNNIC分配联盟成员单位可以通过CNNIC获得IP地址号码，CNNIC必须将其分配联盟单位的名单及IP地址分配报告APNIC，同时除了CNNIC向APNIC交纳年费（1万美元）外，CNNIC分配联盟的成员单位还应通过CNNIC向APNIC交纳年费，并每年向CNNIC交纳一定的联盟成员费。
中国的任何单位，只要对IP地址的需求量达到一定要求，而且可能继续向前发展的，就有资格申请加入CNNIC分配联盟。如果只是需要少量地址，也可向CNNIC分配联盟提交详细的申请资料，CNNIC会将其介绍给合适的联盟成员单位或其它的ISP，以便该单位能获得所需的IP地址。对于地域较近，业务上有联系的若干单位，或者自愿合作的若干单位，可联合申请联盟成员资格。
因此任何机构和个人只要向某个ISP交纳规定的费用，就可从该ISP获取所需lP地址的使用权，但各单位的IP地址分配要统一进行规划，统一联入因特网。
四、ip是私有地址，怎么连接Internet？ 如果我们的ip是私有地址，那怎么连接Internet呢？
既然我们都是用的私有ip，那么我们应该只可以在内网内部进行通信，你可能会疑问那么我们是怎么连接上Internet的呢?
这是使用了NAT技术。NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。
简单的说，NAT就是在内部网络中使用私有地址，而当内部计算机连接Internet时，就在网关（可以理解为出口，打个比方就像院子的门一样）处，将内部地址替换成公用地址，从而在外部公网（internet）上正常使用，NAT可以使多台计算机共享Internet连接。
实现NAT转换的地方一般是路由器。我们也可以通过对路由器的设置来让外界对公网的访问映射成对局域网某一主机的访问，当我们要将计算机做成服务器时，需要用到此技术。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/119/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>