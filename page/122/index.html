<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91082dd31c6f0c1b5a2ef86260905388/" rel="bookmark">
			pycharm用不了anaconda的库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm用不了anaconda的库 电脑安装了anaconda之后，运行含有一些库的代码没有出现错误，但是用pycharm运行之后出现了错误，报错为no module named numpy
解决方法如下：
1：打开pycharm软件
2：选择菜单栏中的file(文件)中的settings（设置）找到project后，选中project interpreter，点击右边的设置选择add interpreter
！！！！一定要先点system interpreter在去点击4：添加，我就是没点3，导致弄了好久，弄奔溃！
等待一定时间后会看到可以用的包，点击OK后开始加载包，加载成功后就可以用啦~
撒花！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e50184c5ad3d4b017b43a6bf49c8df/" rel="bookmark">
			GCN-图卷积神经网络算法讲解（通俗版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于博主学疏才浅，经过一段时间学习，只能做到基础层面的理解，本文就较为通俗地讲解一下图卷积神经网络算法，下篇文章会讲解代码实现部分！
文章目录 GCN-图卷积神经网络算法介绍和算法原理
1. GCN从何而来
2. GCN是做什么的
3. GCN算法的原理
3.1 GCN的结构
3.2 GCN的传播公式
总结
GCN-图卷积神经网络算法介绍和算法原理 1. GCN从何而来 GCN的概念首次提出于2017年的国际学习表征会议（ICLR），成文于2016年：
神经网络在各种传统任务上都体现出了惊人的效果，如：CNN卷积神经网络系列在图像领域（例如图像识别）的结果、RNN循环神经网络系列在序列数据（语言处理）上表现出的效果。
传统卷积神经网络中的卷积操作只能处理规则的数据结构，例如图片或者语言，都属于欧式空间的数据，因此才有维度的概念，欧式空间的数据的特点就是结构很规则。但是现实生活中，其实有很多很多不规则的数据结构，典型的就是图结构，或称拓扑结构，如社交网络、化学分子结构、知识图谱等等；即使是语言，实际上其内部也是复杂的树形结构，也是一种图结构。
图的结构一般来说是十分不规则的，可以认为是无限维的一种数据，所以它没有平移不变性。每一个节点的周围结构可能都是独一无二的，这种结构的数据，就让传统的CNN、RNN瞬间失效。而图数据却很少有相应的模型供我们直接使用，所以GCN应运而生。 2. GCN是做什么的 GCN图卷积神经网络，实际上跟卷积神经网络CNN的作用一样，就是一个特征提取器，只不过它的对象是图数据。GCN精妙地设计了一种从图数据中提取特征的方法，从而让我们可以使用这些特征去对图数据进行节点分类（node classification）、图分类（graph classification）、边预测（link prediction），还可以顺便得到图的嵌入表示（graph embedding），可见用途广泛。
这里的图数据指的不是图片，而是这种具有图结构的数据：
就像"卷积"这个名字所指代的那样，这个想法来自于图像，之后引进到图（Graphs）中。于有固定的结构的图像相比时，图（Graphs）就复杂得多。 3. GCN算法的原理 假设有一批图数据，其中有N个节点（node），每个节点都有自己的特征，假设特征一共有D个，我们设这些节点的特征组成一个N×D维的矩阵X，然后各个节点之间的关系也会形成一个N×N维的矩阵A，也称为邻接矩阵（adjacency matrix）。X和A便是我们模型的输入。
GCN算法的步骤简单可总结为：
第一步聚类
第二步更新
第三步循环
对于每个节点，我们在聚类时从它的所有邻居节点处获取其特征信息，当然也包括它自身的特征。
举个例子
我们想通过聚类，估计出一个人的工资水平
因为有一句很有名的鸡汤 『你朋友圈的平均工资就是你的工资』
先假设：一个人所有朋友的工资平均值等于那个人的工资，利用社交网络（graph图）中的关联信息（edge边），我们可以得到节点的有效信息
当前节点可以用相邻节点推断出来。我们先考虑用相邻节点的加和来代表当前节点：
如果图中的边没有权重，Xj是每个节点的特征值， Aij也就是节点间的关系只能为0或1。当一个节点不是i的邻居节点时，Aij就是0。
那么我们将Aij写成描述节点间关系的邻接矩阵A，就能得到：
但是没有权重显然不合适，因为假如我和马云见过一面，相互仅是认识，但是马化腾和马云是铁哥们，那么将我与马云间联系的权重和马化腾与马云间联系的权重都设为1就是不合理的，所以在处理问题时，Aij一定可以为0到1的任意值，这样才可以科学的计算我的工资水平。
并且只考虑朋友的工资水平也是不科学的，比如有的人会拍领导马屁，那么他的工资就会比没有拍马屁技能的同事高。
所以要想准确评估他的工资，还要加上他自身的一些特征Xi。在矩阵里就是加上自连接矩阵I：
截止目前，我们已经结合节点特征，将朋友们的工资科学地进行了求和，那么接下来就需要取平均值了
因为可能某些技术高薪大佬，朋友不多但是个个有钱，而某些人善于交际，狐朋狗友就很多，虽然狐朋狗友的工资低，但是也架不住多
所以需要求平均，求平均的公式：
分母是节点个数，分子就是节点特征，然后进行求和。
到目前为止，我们就通过求平均，得到了一个人的工资水平，当然简单的求平均肯定是不完善的；
假如我的朋友只有一个大佬，那么我和大佬的关系网络如果用平均算法的话就等同了，所以直接把B的特征赋给A肯定是不合适的
而GCN中的传播公式就可以解决这个问题：
3.1 GCN的结构 GCN是一个多层的图卷积神经网络，每一个卷积层仅处理一阶邻域信息，通过叠加若干卷积层可以实现多阶邻域的信息传递。
从输入层开始，前向传播经过图卷积层运算，然后经过softmax激活函数的运算得到预测分类概率分布。
softmax的作用是将卷积网络的输出的结果进行概率化，我直接将Softmax理解为依据公式运算出样本点的类别。
假设我们构造一个两层的GCN，激活函数分别采用ReLU和Softmax，则整体的正向传播的公式为：
该模型实际是输入层+隐藏层（图卷积层，类似全连接层的作用）+SoftMax+输出层构成的，GCN模型可视化为：
GCN输入一个图，通过若干层GCN每个node的特征从X变成了Z，但是，无论中间有多少层，node之间的连接关系，即邻接矩阵A，都是共享的。 3.2 GCN的传播公式 GCN就是一个神经网络层，每一层GCN的输入都是邻接矩阵A和node的特征H，它的层与层之间的传播方式是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e50184c5ad3d4b017b43a6bf49c8df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e79425f1a9a7a1f33deb9c89bb7cf9/" rel="bookmark">
			软件测试十几个可以练手的项目实战，力推
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近来工作挺忙， 因此也都没什么时间总结了。当然，忙的这段时间我也发现了自己工作中的诸多问题，今天偷闲上来总结一下。
在这之前，我对测试工作的观点是，熟悉业务加上熟练的技术能力就能很好的完成大部分测试工作，通过这次项目的追赶，我突然感觉到这之中有太多的不合理性，毕竟测试有很多不确定性，而且每个人的测试思路不一样，很容易忽略和遗漏很多测试点，这样下来测试的覆盖度降低了很多，到最后产品上线的时候肯定有很多问题，所以还是不能靠感觉和思路来做事，因为到最后没人代理你承担责任。所以这里关于测试设计，我也想谈谈自己的一些观点，以帮助和指导我之后的工作方向。
通常情况下，项目开始的时候，需求人员会将一堆所谓需求文档分散到开发和测试人员手中，此时也就是说让测试前期介入到项目进展中。当然这个时候，我们会有很多很多的问题需要跟需求确认，因为一堆零散的需求文档就足以说明他们是如何草率，但每到项产品交付的时候，这个时候就是开发和测试人员最痛恨需求人员的时候，因为他们前期的需求不明确，让我们白白辛苦并浪费了这么多时间。但对于测试来说，在这个过程中其实就起到了承上启下的作用，因为只有测试人员才会不厌其烦的去与需求人员周旋，而开发这个时候自认为只要加工完就ok了，而测试不能向任何人说ok，不然我们的工作就变得毫无意义了。所以说，测试工作就是一项去深入理解需求，正确引导开发向着最正确的轨道行驶，可见伟大，嘿嘿！
首先，从需求文档中，我们从中抽象出基本功能，得到一个测试人员能够理解的文档，这样我们就知道我们大致要测试那些功能点了；
其次，再从需求文档中提取出业务流程，并与需求人员深入沟通，画出业务流程图；
第三，通过以上两点成果，输出一份初步的测试计划，包括测试目标、范围，以及测试内容、测试流程、测试方法和测试工具，最主要全面列举测试覆盖范围，比如对于客户端软件最后要进行系统平台测试，包括windows 7/Vista（32/64bit）等；安装卸载测试、杀毒软件的覆盖测试等等；如web页面要执行浏览器兼容性测试等；
最后，就要注重测试思路的总体连贯性，“先正常，后异常”，保证正常情况下的功能能走通，异常情况下近可能的去覆盖。
可能这里要说还应该完成测试case的设计，以及评审，至最后的完善归档，不过并不是所有的项目都会有大量的时间留给测试人员，这也就是产品测试和项目测试的区别所在。如果时间充足的情况下，设计详细的case，以及评审，那当然是最完整的流程了。这里主要谈到的测试对象是项目测试，通常都是时间非常紧急，留给测试的时间很短，无暇顾及完成软件测试流程，那么就需要找到更合适自己以及项目的方法和流程来完成。
最近，不少读者托我找一个能实际练手的测试项目。开始，我觉得这是很简单的一件事，但当我付诸行动时，却发现，要找到一个对新手友好的练手项目，着实困难。
下面这几十个项目可能会帮助到你。
电商平台 “ShopNc商城”商城系统是基于 web 浏览器的电子商务系统，通过互联网实现商品的线上电子化销售及业务流程处理。该系统主要以系统会员及普通游客为服务目标，提供快捷方便的商品展示和线上购物。项目由前后台共同构成，前台主要提供与用户的交互入口，展示形式是 web 网页界面；后台提供管理员、客服等对应的服务管理接口服务于前端。
项目模块: 登录、搜索、广告、购物车、我的优惠卷、抢购、会员管理、商品管理、订单管理、促销管理等
1.商场主页
2.登录页面 3.商城后台
4.系统向导
4.安装页面
其他的我就不一一介绍了。
通过此次实战训练，我希望你能学会：
写测试用例（xmind工具）
执行测试用例
bug管理（禅道）
除此之外，我还无偿提供一份我使用很久的、个人总结的、完整的web测试用例，为你以后的工作提供指引和参考。
如果这篇文章对你有帮助，请给小编点个赞！👍这样我才有动力继续更新下去！
今天的小知识学会了么
欢迎在留言区跟我们互动噢~
觉得有所帮助的话点个赞呗
最后是小编自己整理的一些学习资料、测试工具、项目相关资料点击下方小卡片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634471daa6343b9cfbdc982902e64e45/" rel="bookmark">
			使用ssm框架实现用户注册与查询的简单demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我们分一下步邹进行构建 目录结构如下所示
首先创建项目，并加入pom.xml依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;demo-regiser-student&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;demo-regiser-student Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1-b03&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springmvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--事务的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/634471daa6343b9cfbdc982902e64e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1582b8c29bff176caf3fb4be0df21e5a/" rel="bookmark">
			MCU不用定时器实现非阻塞延时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 我们在日常MCU开发中经常会遇到需要按照一定时间间隔轮询的任务比如：Work灯、心跳包等等，所对应最常见的实现方法就是通过（软/硬）定时器来实现。接下来就给大家推荐一种不使用定时器来实现非阻塞延时轮询任务的一种方法，话不多说直接上代码。
就拿一个在RTOS中Work灯的实现方法来举例子，我们在空闲线程中使用钩子函数一行代码实现让Work灯每隔一秒闪烁一次。
/* 全局变量 */ rt_tick_t timeout = 0; /* 函数声明 */ static void work_led_init(void); static void work_led_hook(void); /* 主函数 */ int main(void) { work_led_init(); rt_kprintf("=== [work_led] init success! ===\n"); /* 设置空闲线程回调函数 */ if (rt_thread_idle_sethook(work_led_hook) != RT_EOK) { rt_kprintf("=== [set work_led_hook] failed! ===\n"); }else { rt_kprintf("=== [set work_led_hook] success! ===\n"); } while(1) { rt_thread_delay(5000); } } /********************************************************************** * @brief work灯初始化函数 * @author Dev_XH * @date 2022-10-19 **********************************************************************/ static void work_led_init(void) { GPIO_InitTypeDef GPIO_InitStructure = {0}; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1582b8c29bff176caf3fb4be0df21e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83322897530e71799f839d8a48b4fae2/" rel="bookmark">
			nginx负载均衡核心模块(upstream和proxy模块)及常用参数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 环境：centos nginx 1.18.0
以下所说的反向代理服务器和负载均衡服务器其实是一个意思，因为nginx做反向代理的时候本质上做到了负载均衡的效果。
upstream模块 nginx的负载均衡功能依赖于http_upstream_module模块，所支持的代理方式包括proxy_pass、fastcgi_pass、memcached_pass等。
http_upstream_module模块允许nginx定义一组或多组节点服务器组，使用时可以通过proxy_pass代理方式把网站请求发送到事先定义好的对应upstream组名上，具体的写法为：proxy_pass http://www.server_pools，其中www.server_pools就是一个upstream节点服务器组名。
upstream模块语法：
upstream 组名{ server IP:port 参1,参2，....; server IP:port 参1,参2，....; } 说明：upstream模块放在http里面，语法结构中upstream是关键字，接着定义一个组名，server也是关键字，后面是IP或者域名，再是参数。
upstream范例如下：
upstream www.server_pools{	#www.server_pools是集群组名 server 10.0.0.1:80 weight=15;	#可以写IP或域名，指定端口，如果不指定端口就认80端口 server 10.0.0.2:80 weight=15;	#weight表示权重，后面会讲 } upstream www.server_pools{	#www.server_pools是集群组名 server www.fujiseiko.com:80;	#域名，DNS或负载均衡服务器必须做解析 server 10.0.0.2:80 backup;	#backup表示备用服务器,除非其它都挂了，否则不会请求不会到这台服务器 server 10.0.0.3:80 max_fails=3,fail_timeout=15s;	#表示在15秒内尝试重连3次，3次都失败就认为服务器不可用，请求就不会转发到这台服务器 } 下面讲一下server标签的一些常用参数：
weight	表示权重，其书写规则为weight=1，默认就等于1，权重数值越大表示接受的请求比例就越大； max_fails 表示nginx在fail_timeout 参数设置的持续时间内尝试连接后端主机失败次数，则认为服务器在fail_timeout参数设置的持续时间内不可用 。其书写规则为max_fails=2；默认max_fails=1，零值将禁用对尝试的记帐。认为失败的尝试由 proxy_next_upstream， fastcgi_next_upstream， uwsgi_next_upstream， scgi_next_upstream， memcached_next_upstream和 grpc_next_upstream 指令定义。 fail_timeout	表示在指定次数的不成功尝试与服务器通信的时间范围内，应考虑服务器不可用，其书写规则为fail_timeout=15s，默认该参数为fail_timeout=10s； down	表示将服务器标记为永久不可用； backup	表示当前服务器节点是备用机，只有在其他的服务器都宕机以后，请求才会被转发到这个备用服务器上； upstream模块的调度算法 我们知道，定义一个upstream模块的时候，定义了很多server主机，那么LB服务器是如何决定将请求调度给哪一个后端主机的呢？这就涉及到调度算法的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83322897530e71799f839d8a48b4fae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168c739713d0b45cf79a18a09a14d9ad/" rel="bookmark">
			强化学习自然策略梯度Natural Policy Gradient推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强化学习自然策略梯度Natural Policy Gradient推导 前言预先准备的知识似然函数与对数似然函数Score functionFisher Information Matrix (FIM)KL散度 (KL divergence)Natural Gradient Natural Policy Gradient 前言 最近在学习TRPO，发现里面好多好多完全陌生的概念。为了能够尽量多地去理解TRPO算法的原理，所以正在一步一步地学习里面的新概念，其中一个就是自然策略梯度：Natural Policy Gradient (NPG)。在这里整理出来，一方面防止自己忘记，另一方面哪里接错了，还请各位大佬指正一下^_^。
预先准备的知识 似然函数与对数似然函数 有一个随机变量 X X X，它的理想概率分布为： x ∼ p ( x ; θ ) x \sim p(x;\theta) x∼p(x;θ)。 X X X是啥样的不知道， p p p是啥样的也不知道。现对 X X X进行 n n n次采样，得到 n n n组独立同分布的样本 { x 1 , x 2 , ⋯ , x n } \left\{x_1, x_2, \cdots, x_n\right\} {x1​,x2​,⋯,xn​}。那么定义其似然函数为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168c739713d0b45cf79a18a09a14d9ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26d1c59799852af325b8e98dba2f112/" rel="bookmark">
			验证平台，SV 和UVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		验证是确保设计和预定的设计期望一致的过程。
验证平台：被用来应用一个或多个测试激励，并将激励发送到设计的输入中，激励可通过验证平台产生，或者通过手动创建。最后，输出进行比较，看结果是否正确。结果检查可通过验证平台、脚本或者手工来实现。
验证平台的主要功能：产生激励、把激励应用到被测设计DUT中，检查结果和验证测试是否通过，也就是确保被测设计的输出和期望一致。
验证的难点：如何产生全部的激励，如何检查结果的正确性。
功能验证流程：制定验证策略（定义测试用例，验证平台抽象层次，激励产生方案，结果检查方案）和验证计划（搭建验证平台，创建测试用例、运行和调试）、 覆盖率分析和回归测试。
验证流程：1、仔细阅读设计文档，并理解分析。2、指定验证计划，包括验证功能点的提取，规划tests，TB的架构，用什么方法学，功能覆盖率的提取以及检查机制。3、搭建验证环境，码代码，测试用例编写以及调试debug。4、回归测试。5、覆盖率包括代码代码覆盖率和功能覆盖率，增加一些tests。6、撰写验证报告，主要是覆盖率的分析。
验证手段：黑盒验证：只通过其边界信号来验证一个模块或者设计的功能。通过这种方法，激励可以被应用到设计和参考模型中，在某个抽象层次，通过被测设计和参考模型的输出被校对，黑盒验证存在下列主要的缺点：很难验证和设计相关的特点、很难调试、要求一个精确的参考模型。白盒验证：可以不需要参考模型，通过在设计内部或外部输出信号放置监控器和断言来保证设计操作的正确性。灰盒验证：综合了白盒和黑盒的一个阶段，也就是在设计内部添加监控器和断言来减少对参考模型的精确要求，在错误发现的时候也减少调试的压力。
验证可能出现的错误：从来没有被激发过的错误，被激发的错误没有被传递出来，多个潜在的错误掩盖了其他错误。
代码覆盖率：行覆盖率、状态机覆盖、翻转覆盖、判定覆盖、条件覆盖、路径覆盖。
功能覆盖率：代表设计要求的功能中有多少被验证了。功能覆盖率包括3个概念：覆盖点、交叉覆盖率、传输覆盖率。覆盖点是单个标量值或者表达式的抽样。目的是确保所有感兴趣的和相关的值都可以在已抽样的值或表达式中被观测到。交叉覆盖率是度量同一点多个标量值的结合，可以设计两种或者多种覆盖点的结合，只能用于同一类的覆盖组。传输覆盖率是度量一系列值的存在和发生，可以包括统一覆盖点上超过两个的连续不断的值。
功能覆盖率高、代码覆盖率低：验证计划不充分，需要增加佛南功能覆盖点。
代码覆盖率高，功能覆盖率低：设计没有实现指定的功能。
覆盖率驱动验证：最重要的特点是基于随机激励产生。随机激励生成是提高效率的最主要的原动力，覆盖率验证驱动是将事务级验证、约束随机激励产生、自动化结果比较、覆盖率统计分析和直接测试。事务级验证允许在一个更高的抽象层次来创建验证场景。约束随机激励产生可以获取更高的效率，为生成验证场景和自动化结果比较提供了充分的保证，设计能够在各种随机的情况下被验证。覆盖率统计是必须的，若没有覆盖率统计，就没有办法清晰的分析哪个场景被随机生成过。直接测试也是必须的，因为最终不可能全部的场景都能够随机生成。覆盖率驱动验证方法学要求指定一个可以数量化衡量完备性，可追踪、有组织的验证计划，这对于验证计划的严格要求可以暴露出可能被遗漏的相关场景。
验证存在的挑战，一个有效的验证方案必须解决验证完备性、验证可重用性、验证可靠性、验证效率、验证的性能。验证完备性是如何最大限度地验证被测设计的行为，难点在于如何获取所有必须被验证的场景，可采用覆盖率驱动的验证方法学。覆盖率驱动验证方法学要求指定一个可以数量化衡量完备性，可追踪、有组织的验证计划，这对于验证计划的严格要求可以暴露出可能被遗漏的相关场景。验证可重用性是优化验证环境的架构，使之可以在不同的场合重用。重用可以通过模块化验证组件、采用标准接口、将激励产生机制和验证架构分离等方式实现。一个项目中，深层次的重用是如何实现一个验证平台可以供多个测试用例使用。验证可靠性在于如何减少在完成一个验证项目中的手工操作，手工操作可能存在错误、冗长和耗时很大的问题。有一个很好的方法是约束随机验证，是通过搭建一个自动化的系统来产生激励和自动比较，进而提高验证的可靠性。验证的效率可以通过提高验证平台的抽象层次和采用重用。验证性能是在运行回归测试时候，迭代周期主要为验证平台运作的有效性来决定，验证程序的性能成为这个阶段的主要因素。
数字ic设计流程：确定项目需求，指定芯片的具体指标，系统级设计，用系统建模语言对各个模块描述。前端设计，RTL设计，仿真，硬件原型验证，电路综合，后端设计，版图设计，物理验证，后仿真。
数字ic设计具体指标：物理指标（制作工艺）、性能指标（速度、功耗）、功能指标（功能描述、接口定义）
集成电路产业链：集成电路设计、晶圆、封装测试、组装、成品整机。
soc芯片最重要的是cpu
总线连接，总线直接桥接，AHB-bridge-APB总线协议。
system controller产生系统的时钟和复位信号。
soc芯片主要无线通信和数据存储功能，主要应用场景是数码相机的存储片。
无线通信功能是通过apb总线上的spi接口外挂wifi芯片。
sv基本语法：2值逻辑（0，1）和4值逻辑（0，1，x，z，reg类型，verilog中用），有符号数（整型）与无符号数（bit），合并数据（内存空间更紧凑）与非合并数据（每个元素占用32bit内存空间），动态数据（数组大小不确定）和队列，关联数据（不需要连续空间，可以整数、字符串等），数组的方法。
多线程：join（三个子线程都执行完后，才可以执行主线程），fork_join_any(任何一个子线程执行完后，便可以执行主线程)，fork_join_none(子线程不会阻塞主线程、先执行主线程，三个子线程才会并行执行。)
function是没有时间的，task是有时间的。void function是没有返回值。
static：module和program子程序默认是静态存储。
automatic：自动存储模式，函数和任务的重入成为可能。
random()产生有符号的随机数，urandom()产生无符号的随机数，randomc产生平均分布的平均数。
sv预定义随机化方法：randomize，pre_randomize, post_randomize.调用randomize之前调用pre，之后调动post
用super.task_name()调用一个定义在父类的task
this是指向当前class
local和protected都是保护变量，外部不可以访问，子类不能访问父类的local变量。子类可以访问父类的protected变量。
把代码打包，使用package，解决类命名冲突等问题
dut是module，TB是program，不同代码运行在不同区域，program与module运行的时间域是不同的，这样会避免竞争和冒险。
virtual interface ： virtual interface的本质是指向interface的指针，因此其并不是一个真实存在的实体，而interface是一个真实存在的实体。
静态cast是数据类型的转化。动态cast类的向下转换（当父类句柄指向的对象是真正的子类对象，可使用），或者是枚举的转换。
类的三大属性：封装性、继承性、多态性。
多态：虚方法与重写的实现。当一个类派生出子类的时候，基类中的一些方法（定义为virtual）可能需要被重写（在派生类），对象中的类型来决定调用方法的实现方式，通常这是一个动态的过程，动态的选择方法的实现方式叫多态。如果想要重写某个方法，在父类中声明中为虚方法，后续继承过程中永远是一个虚方法，不再注意是否virtual。
封装性：通过访问控制来实现的。高内聚、低耦合，类的内部数据操作细节自己完成，不允许外部干涉，仅暴露少量的方法给外部使用。通常是禁止直接访问一个对象中数据的实际表示，应该通过操作接口来访问，称为信息隐藏。封装可以提高程序安全性，保护数据，隐藏代码实现细节，统一接口，更加具有规范性，增加系统可维护性。
继承：对某一批类的抽象，从而实现对显示世界更好的建模。
UVM：分层的验证环境，组件(test、env、agent、sequencer、driver、monitor、scoreboard)、每个类的激励，如何通信，如何连接（port）、如何启动、如何结束、如何打印信息、数据（uvm_sequence_item）。
uvm平台的开启和结束：启动：在run-test函数里面调用用例名字，仿真用UVM_TESTNAME, 结束：正常结束（drops objection+check）异常结束（错误而挂起 / timeouts）
UVM 的PHASE：build phase总体目的是构建、配置和连接测试台组件层次结构，所有的build phases方法都是functions，在0仿真时间执行完成。一旦构建了UVM testbench根节点组件，build phase 就开始执行。是从上到下地构建testbench组件层次结构。connect phases用于在组件之间建立TLM连接，或者向testbench资源池分配对象句柄。connect phase 在build phases方法之后自底向上地执行。run phase（reset、configure、main、shutdown 共12个）发生在start_of_simulation阶段之后，用于激励的产生和testbench的监测和检查。run phase 作为一个task实现，所有uvm_component 的run phase 都并行执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c26d1c59799852af325b8e98dba2f112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e126297f4205131f9f0fe8dbd1cd6b38/" rel="bookmark">
			stm32中printf重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码 //加入以下代码,支持printf函数,而不需要选择use MicroLIB #if 1 #pragma import(__use_no_semihosting) //标准库需要的支持函数 struct __FILE { int handle; }; FILE __stdout; //定义_sys_exit()以避免使用半主机模式 _sys_exit(int x) { x = x; } //重定义fp utc函数 int fputc(int ch, FILE *f) { while((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch; } #endif //加入以下代码,支持printf函数,而不需要选择use MicroLIB 为什么要用标准库我也不清楚，下文是他们的解释:
实际上，我们大部分工程用到的标准C库函数很少，而且keil中的microLIB默认已将printf重定向到UART1，我们可以直接使用printf通过串口1输出数据，所以勾选使用microLIB是一种非常好的方法，如果不勾选microLIB，则keil变压器会自动链接标准库函数。 一旦没勾选可不就是要自己重定义么
#if 1 #endif #if 1, 看起来是很鸡肋的东西，之所以要这样搞，假设#if 0，就可以不执行里面的代码，编译的时候会被优化掉，正常情况下那个数字应该变成一个宏定义，估计写这个的人一开始只是随意写的。
问题来了，为什么要一会执行，一会不执行，这得从长说起。
重新定义printf，是用来串口调试的，（调试有很多种方法，有硬件调试，软件调试，串口调试）在写代码逻辑的过程中，很可能会很混乱，出现一些bug，printf可以查看代码，相较于debug选项，他们各有各自的优缺点，
#pragma import(__use_no_semihosting) 在keil中编程时常会遇到use_no_semihosting_swi的警告，这时你就是进入了半主机模式。**在嵌入式的编程中你是避免不了使用printf、fopen、fclose等函数的但是因为嵌入式的程序中并没有对这些函数的底层实现，使得设备运行时会进入软件中断BAEB处，这时就需要use_no_semihosting_swi这 个声明，使程序遇到这些文件操作函数时不停在此中断处，具体操作如下，将下列程序加入你的工程中：**
pragma import(__use_no_semihosting_swi) 这条语句可以关闭半主机模式，只需要在任意一个C文件中加入即可。
什么是半主机模式？
半主机是用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机。 例如，使用此机制可以启用 C 库中的函数，如 printf() 和 scanf()，来使用主机的屏幕和键盘，而不是在目标系统上配备屏幕和键盘。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e126297f4205131f9f0fe8dbd1cd6b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b51bed62a7adb8e3b142f8804c3f3485/" rel="bookmark">
			STM32 Combined PWM的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PWM模式概念 PWM 模式1 - 向上计数， TIMx_CNT&lt;TIMx_CCR1时有效，否则无效；
向下计数, TIMx_CNT&gt;TIMx_CCR1 时无效，否则有效。
PWM 模式2 - 向上计数, TIMx_CNT&lt;TIMx_CCR1 时无效，否则有效；
向下计数, TIMx_CNT&gt;TIMx_CCR1有效，否则无效。
注意：上述有效表示OCxREF输出高电平，无效表示OCxREF输出低电平，OCxREF为内部信号，并不代表最终输出引脚的高低电平，引脚输出电平
由OCxREF的值根据CCxP极性的高低共同决定。
Combined PWM模式 1 - OC1REF 输出与 PWM 模式1相同。
OC1REFC 输出为 OC1REF 、OC2REF的逻辑或（OR）。
Combined PWM 模式 2 - OC1REF 输出与 PWM 模式2.相同。
OC1REFC输出为 OC1REF 、OC2REF的逻辑与（AND）。
应用示例 故事要从产生一组带有相移的PWM波,并且动态改变PWM脉宽和周期说起。
基于对前面描述的PWM1、PWM2、Combined PWM1和Combined PWM2的理解，下面示例演示Combined PWM2的实现方式。
假设使用TIM2的通道1和通道2，首先将TIM2配置为向上计数，通道1配置为PWM1，CCRX=2，即计数值到2时，OC2REF无效，输出低电平；通道2配置为Combined PWM2，CCRX=1，此时通道2 OC2REF与PWM2相同，即计数值小于1时无效，输出低电平。
COmbined PWM2 的输出OC2REFC为 OC1REF 和OC2REF的与操作，如下图所示：
引脚最终的输出由OC2REFC和极性定义决定，当极性定义为高电平时，引脚输出则为OC2REFC的值，从而实现特殊的PWM波。
COmbined PWM1于Combined PWM2相似，其OC2REFC为OC1REF 和OC2REF的或操作。
注意：Combined PWM模式相邻通道为（CH1、CH2）和（CH3、Ch4），且第一个通道为PWM1时，第二通道必须为Combined　PWM２，反之，第一个通道为PWM２时，第二个通道必须为CombinedＰＷＭ１。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fed86f9732fa54f24c6ac2c315e144b/" rel="bookmark">
			go语言调用同一个包下的函数出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现undefined
编译有按file编译和package编译还有按directory编译
其中按file编译是一个file中只有一个main
按package编译是一个包下一个main，大部分人是因为一个包下多个main导致上面情况的
按directory就是一个目录一个main
上面的三种编译方式可以认为的进行修改
如果需要在同一个包下确保调用其它函数，那么就需要确保是按包编译的，还需要确保同一个包下只有一个main函数
那么上面个人情况是一个包中含有多个main函数，所以可以通过指令进行编译运行
进入所在包，使用go run 命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b4f92d18dee0621769da73732eabe5/" rel="bookmark">
			Java对象逃逸分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概念 对象逃逸分析，是一种有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java虚拟机能够分析出一个新的对象的引用范围从而决定是否要将这个对象分配到堆上。Java1.7后默认开启逃逸分析的选项。Java的JIT编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析，同时Java对象在堆上分配和内置线程的特点使得逃逸分析成Java的重要功能。
JIT技术：为了解决JVM执行字节码速度问题。引入JIT(即时编译)技术，当JVM发现某个方法或代码块运行的特别频繁的时候，就会认为这是"热点代码"，然后JIT会把部分热点代码翻译成本地机器相关的机器码，然后再把翻译后的机器码缓存起来，以备下次使用。
2. 逃逸分析主要就是分析对象的动态作用域 基于逃逸分析，一个对象可能会被用作三种逃逸状态标记：
全局级别逃逸：一个对象可能从一个方法或者当前线程中逃逸。再明确一点，如果一个对象被作为一个方法的返回值，那么对象被标记为全局逃逸状态。参数级别逃逸：如果一个对象被作为参数传递给一个方法，但是在这个方法之外无法访问或者对其他线程不可见，这个对象标记为参数级别逃逸。无逃逸状态：一个对象不会产生逃逸。 3. 逃逸分析的作用 通过逃逸分析，在不存在逃逸下JVM可以进行以下优化：
同步消除。线程同步本身比较耗时，如果确定一个变量不会逃逸出线程，无法被其他线程访问到，那么这个变量的读写就不会存在竞争，对这个变量的同步措施可以清除。将堆分配转为栈上分配：在一般应用中，不会逃逸的局部对象占比很大，如果使用栈上分配，那大量对象会随着方法结束而自动销毁，减轻垃圾回收系统压力。分离对象或标量替换：标量就是不可分割的量，java中基本数据类型，reference类型都是标量。相对的一个数据可以继续分解，它就是聚合量。如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序真正执行的时候可能在栈上创建若干个成员变量。 4. 栈上分配对象 我们来看以下代码：
public static void main(String[] args) { long a1 = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) { alloc(); } // 查看执行时间 long a2 = System.currentTimeMillis(); System.out.println("cost " + (a2 - a1) + " ms"); // 为了方便查看堆内存中对象个数，线程sleep try { Thread.sleep(100000); } catch (InterruptedException e1) { e1.printStackTrace(); } } private static void alloc() { User user = new User(); } static class User { } 我们在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9b4f92d18dee0621769da73732eabe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb6a8d3918bfe4865798f2ad2959f13/" rel="bookmark">
			Windows android adb interface驱动安装失败 ADB interface驱动安装失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.我们在Androidstudio进行APP真机调试时，经常会出现USB驱动安装成功，ADB Interface驱动安装失败，如下图所示：
2.选中“我的电脑”右击，选择“属性”，然后点击“设备管理器”；
3.进入设备管理器界面后，选择“ADB Interface”【有时“ADB Interface”和“HDB Interface”都要选择进行驱动更新才会生效】,右击选择“更新驱动程序软件”；
4.接着选择“浏览计算机以查找驱动程序软件”，然后选择“从计算机的设备驱动程序列表中选择”，点击下一步；
5.显示所有设备，点击下一步，选择从磁盘安装，点击下一步；
6.选择浏览，找到Android SDK中带有Adb Interface的驱动(android_winusb.inf)，打开，点击确定。
【其中驱动存放的位置为：D:\Android\SDK\extras\google\usb_driver\android_winusb.inf】
7.点击下一步，出现更新驱动程序警告，点击“是”；
8.ADB Interface驱动安装成功。
相关资源：中兴adb驱动安装错误解决办法_androidadbinterface驱动-Android...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e786e147fccd3f755ea746d1bbe1f4/" rel="bookmark">
			React Hooks 使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言、Hooks 出现本质上原因是：
让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。
解决逻辑复用难的问题。
放弃面向对象编程，拥抱函数式编程。
不同的 hooks 功能也是不同的，分成了 数据更新驱动，状态获取与传递，执行副作用，状态派生与保存，和工具类型。
一、 hooks 之数据更新驱动 1.useState const [ state , useState ] = useState(initData) ① state，目的提供给 UI ，作为渲染视图的数据源。
② useState 改变 state 的函数，可以理解为推动函数组件渲染的渲染函数。
③ initData 有两种情况，第一种情况是非函数，将作为 state 初始化的值。第二种情况是函数，函数的返回值作为 useState 初始化的值。
useState 基础用法：
const Demo = (props) =&gt; { /* number为此时state读取值 ，setNumber为派发更新的函数 */ let [number, setNumber] = useState(0) /* 0为初始值 */ return ( &lt;div&gt; &lt;span&gt;{ number }&lt;/span&gt; &lt;button onClick={ ()=&gt; { setNumber(number+1) console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e786e147fccd3f755ea746d1bbe1f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3136329b40aa5695a0e2cab32b452fb/" rel="bookmark">
			Vue3.0----基础入门(第一章)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue 简介 1. 什么是vue 官方给出的概念：Vue (读音/vjuː/，类似于view) 是一套用于构建用户界面的前端框架。
1.1 解读核心关键词：构建用户界面 前端开发者最主要的工作，就是为网站的使用者（又称为：网站的用户）构建出美观、舒适、好用的网页。
1.2 构建用户界面的传统方式 在传统的Web 前端开发中，是基于jQuery + 模板引擎的方式来构建用户界面的。
1.3 使用vue 构建用户界面 使用vue 构建用户界面，解决了jQuery + 模板引擎的诸多痛点，极大的提高了前端开发的效率和体验。
1.4 解读核心关键词：框架 官方给vue 的定位是前端框架，因为它提供了构建用户界面的一整套解决方案（俗称vue 全家桶）：
vue（核心库）vue-router（路由方案）vuex（状态管理方案）vue 组件库（快速搭建页面UI 效果的方案） 以及辅助vue 项目开发的一系列工具：
vue-cli（npm 全局包：一键生成工程化的vue 项目-基于webpack、大而全）vite（npm 全局包：一键生成工程化的vue 项目-小而巧）vue-devtools（浏览器插件：辅助调试的工具）vetur（vscode插件：提供语法高亮和智能提示） 1.5 总结：什么是vue vue 是一套用于构建用户界面的前端框架。
2. vue 的特性 vue 框架的特性，主要体现在如下两方面：
①数据驱动视图
②双向数据绑定
2.1 数据驱动视图 在使用了vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。示意图如下：
好处：当页面数据发生变化时，页面会自动重新渲染！
注意：数据驱动视图是单向的数据绑定。
2.2 双向数据绑定 在填写表单时，双向数据绑定可以辅助开发者在不操作DOM 的前提下，自动把用户填写的内容同步到数据源
中。示意图如下：
好处：开发者不再需要手动操作DOM 元素，来获取表单元素最新的值！
2.3 MVVM MVVM是vue 实现数据驱动视图和双向数据绑定的核心原理。它把每个HTML 页面都拆分成了如下三个部分：
在MVVM 概念中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3136329b40aa5695a0e2cab32b452fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833c84bff17e539e2bac4d645c9838f7/" rel="bookmark">
			arm驱动开发学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：什么是驱动 驱动程序：就是对底层硬件设备的操作进行封装，并向上层提供函数接口。
Linux将驱动设备分为三类：字符设备、块设备、网络设备。
字符设备：只能一个字节一个字节的读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后顺序进行。字符设备是面向流的设备。
如鼠标、键盘、串口、控制台、LED等。
块设备：块设备驱动是以固定大小长度来传送和转移资料，块设备能够随机，不需要按照顺序地访问固定大小的数据片；
块设备包括硬盘、磁盘、U盘和SD卡等。
网络设备：网络设备主要负责主机之间的数据交换。
蓝牙，WIFI，网卡等。
二：字符设备驱动 1.字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。
2.因为，应用程序位于用户空间，驱动程序位于内核空间，用户空间不可以直接调用内核空间的函数。所以必须经过系统调用，应用程序才可以调用驱动程序的函数。
应用程序调用驱动程序过程： 1.应用程序： 2.应用程序里的open(),write(),read()函数将调用驱动程序里的接口里的函数。 如：应用程序里open（）调用接口结led_open();
2.应用和驱动之间的数据交换 (1)copy_from_user，用来将数据从用户空间复制到内核空间
(2)copy_to_user，用来将数据从内核空间复制到用户空间
3. 驱动程序结构： 驱动代码必须有4部分：
//1、头文件
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
//2、驱动入口函数的声明，在内核加载驱动时，执行哪个函数；在内核卸载驱动时，执行哪个函数
//声明：加载时的入口声明
module_init(hello_init);
//声明：卸载时的入口声明
module_exit(hello_exit);
//3、加载函数、卸载函数的实现
//加载函数的实现：当内核加载驱动（内核执行这个驱动时，就会调用的函数）
static int __init hello_init(void)
{
return 0;
}
//卸载函数的实现：当内核卸载驱动（内核删除这个驱动时，就会调用的函数）
static void __exit hello_exit(void)
{
return 0;
}
//4、协议选择GPL
MODULE_LICENSE("GPL");
4.makefile文件 KERNEL_PATH=/home/ubuntu/code/kernel/linux-3.14
obj-m += 1st_drv.o #把.c文件编译为.o文件
#编译为驱动程序 .ko 要借助 已经编译过的内核
all:
make modules -C $(KERNEL_PATH) M=$(shell pwd) #去执行kernel目录下的makefile
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833c84bff17e539e2bac4d645c9838f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b699133667e0512d6e4389314cecb5b/" rel="bookmark">
			算法学习———二叉树（Java版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周leetcode刷题路线：
二叉树算法题常用方法：递归算法
递归算法基本思路：只考虑部分，不考虑整体；
101. 对称二叉树（简单）：
题目描述： 给你一个二叉树的根节点 root， 检查它是否轴对称。
示例：
输入：root = [1, 2, 2, 3, 4, 4, 3]
输出：true
解题思路：
检查该二叉树是否为对称二叉树，即检查该二叉树根节点的左子树翻转后是否与右子树相等（226. 翻转二叉树）。
将二叉树的左子树翻转后，将其每个节点与右子树对应位置的节点进行比较，只有当两个子树都能顺利递归到末尾时，该二叉树才是对称二叉树。
解题代码：
class Solution { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); public boolean isSymmetric(TreeNode root) { func(root.left); return judge(root.left, root.right); } void func(TreeNode node){ if(node == null) return; TreeNode temp; temp = node.left; node.left = node.right; node.right = temp; func(node.right); func(node.left); } boolean judge(TreeNode node1, TreeNode node2){ if(node1 == null &amp;&amp; node2 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b699133667e0512d6e4389314cecb5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf7c57826c42117a81a4afa47113810/" rel="bookmark">
			火狐浏览器hackbar安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		火狐浏览器hackbar安装使用教程 首先先打开火狐自带的扩展和主题
在搜索框中搜索hackbar
由于hackbar现在收费了，这里直接使用hackbarV2来进行平替。
接下来使用F12或者手动打开web开发者工具。
查看效果
使用的第一步就是先去点击load URL导入URL
通过在框里修改url，然后点击execute按钮进行运行
这里的诸多功能就不进行赘述了，自行在网上找教程。
这里说一下如何去使用POST来进行传参。
点击POST data，输入自己想要传参的数据。
然后点击execute就能进行交互。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af32ce69def8be450d0713656f9135a/" rel="bookmark">
			Matlab程序设计语言基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1Matlab程序设计语言基础 1.若i和j不改写，它们将表示虚数的。但是在Matlab程序的设计过程中，经常使用i或者j作为循环的变量。如果涉及到虚数运算，应当先确认这两个量有没有被改写，如果被改写了，用i=sqrt(-1)来重置。
2.无穷大，在Matlab中用inf表示，负无穷大相应地用-inf表示。
3.NaN,指的是不定式（not a number,NaN)，通常由0/0运算、Inf/Inf及其他可能的运算得出。
4.pi，圆周率的双精度浮点表示。
2.1.2数据结构 1.数值型。Matlab中最常用的数值量是双精度的浮点数，占8个字节（64位），在matlab中其表示为double()。
2.符号型。Matlab中还定义了符号型变量，用来区别数值型变量，可以用于推导公式和数学解析求解。在进行解析运算之前要将采用的变量声明为符号变量，利用的命令是syms.具体用法是syms vars props，其中vars是需要声明的变量列表，可以同时生命多个变量，中间用空格分隔，而不是用逗号分隔开。如果需要，还可以进一步生命变量的类型：props，可以使用的类型由real、positive等。例如，将a、b定义为符号变量可以表达为：syms a b，假设要将a定义成实数，那就用syms a real
符号型数值可以通过变精度算法函数vpa()以任意指定的精度显示出来。该函数的调用格式为vpa(A),或vpa(A,n)，其中A是要显示的数值或者矩阵，n为指定的有效数字位数，前者以默认的十进制位数（32位）显示结果
例2-1.自然对数底e的前300位有效数字可以由下面的语句直接显示出来。代码中首先要把1转换成符号量。
如果没有把1转换成符号量，则结果如下：
说明如果没有把1转换成符号类型，虽然要求了提供前300位的解析解，但是程序做不到。
3.其他数据结构。
3.1字符串。Matlab支持字符串变量，与其他语言不同的是，matlab的字符串需要用单引号括起来。（这点跟Python有点像）
3.2多维数组。三维数组是一般矩阵的直接拓展。在控制系统的分析中也可以直接用于多变量系统的表示上。在实际编程中还可以使用维数更高的数组。
3.3单元数组。单元数组是矩阵的直接扩展，其存储格式类似于普通的矩阵，而矩阵的每个元素不是数值，可以认为能储存任意类型的信息，这样每个元素称为“单元”（cell)，例如A{i,j}可以表示单元数组A的第i行，第j列的内容。
3.4类与对象。后面再介绍，高阶内容。
2.1.3Matlab的基本语句结构 1.直接赋值语句
变量=值。例如考虑矩阵：
由下面的语句将值直接赋值给矩阵A
2.函数调用语句
基本形式：[返回变量列表]=函数名（输入变量列表），其中，函数名的要求和变量名的要求是一致的，一般函数名应该对应再MATLAB路径下的一个文件。
例如函数名为：my_fun应该对应于my_fun.m文件。还有一些函数名需对应于MATLAB的内核函数(built-n function)，如inv()等函数。
返回变量列表和输入变量列表均可以由若干个变量名组成，它们之间应该分别用逗号。返回变量还允许使用空格分隔，例如[U S V]=svd(X),这是对矩阵X进行SVD分解的函数，返回值是S,V,D这三个变量，如果不想返回某个变量，则可以用~符号占位。 2.1.4冒号表达式于子矩阵提取 这一部分很重要，因为控制系统中的运算除了少数简单的的纯代数运算，大部分都是矩阵运算。冒号表达式时MATLAB中很有用的表达式，在向量生成、子矩阵提取等很多方面极其重要。冒号表达式的原型为：v=s1:s2:s3，该函数将生成一个行向量v，其中s1时向量的起始值，s2为步距：该向量从s1出发，每隔步距s2就取一个点，直至不超过s3的最大值就可以构成一个向量。若省略s2，则步距默认取1.
例2-4选择不同的步距，则可以用下面语句在t∈[0,Π]区间去除一些点构成向量。
下面尝试冒号表达式的不同写法
很明显步距无法是负的，所以v2取出来是个空的向量。
如果省略了s2，程序会默认步距为1.
如果把上下限反过来写，步距写成-1，那么就会逆序排列构成新向量。 提取子矩阵是在MATLAB操作中非常容易用到的操作。提取子矩阵的具体方法是B=A(v1,v2)，其中，v1向量表示子矩阵要包含的行号构成的向量，v2表示要包含的列号构成的向量，这样从A矩阵中提取有关的行和列，就可以构成子矩阵B了。如果v1的地方用冒号占位，即B=A(:,v2)意思是要提取A矩阵所有的行。子矩阵提取通常配合关键字end使用，end用于表示最后一行/列。
例2-5 下面将列出若干命令，并加以解释。
提取矩阵A的奇数行和所有列。这里嵌套了冒号表达式，我们知道冒号表示的格式是，a=s1:s2:s3，其中s2为步距。那么在B1=A(1:2:end,:)中，逗号前的语句就是冒号表达式，即1:2:end，意思是，从第一行开始，以步距为2，取下一行，一直到行数的末尾。 这样就实现了奇数行的提取。而逗号之后是一个冒号，意思是所有的列都取。
取A矩阵的第3、2、1行和2、3、4列组成新矩阵B2
取A矩阵的所有行，列从第一列到最后一列反着排列组成新矩阵B3。实际上就是左右颠倒个儿。 2.2 基本数学运算 2.2.1矩阵代数运算 如果一个矩阵A有n行、m列元素，则称A矩阵为nxm矩阵；若n=m则矩阵为仿真。
1.矩阵转置
矩阵转置记作,其元素定义为，故B为mxn矩阵。如果A矩阵含有复数元素，则对之转置时，其转置矩阵B的元素定义为，即先对各个元素进行转置，然后再逐项求取其共轭复数值。这种转置又称为Hermit转置，其数学符号是。MATLAB中用可以求出A矩阵的Hermit转置，矩阵的转置则可以由求出。
2.加减法
假设再MATLAB环境下有两个矩阵A和B，则可以由和命令取执行矩阵加减法。若A和B的矩阵维数相同，它将会自动地将A和B矩阵对应元素相加减，从而得到正确的结果，并赋值给C变量。若二者之一为标量，则应该将其遍加（减）于两一个矩阵。在其他情况下，MATLAB将自动地给出错误信息，提示用户两个矩阵的维数不匹配。
3.矩阵乘法
4.矩阵的左右除
MATLAB中用“\"和"/"分别表示矩阵的左除和右除，A\B为方程的解，为方程的解。若A为非奇异方阵，则左除和右除分别为和
5.矩阵翻转
矩阵A进行左右翻转再赋值给B：B=fliplr(A)，而C=flipud(A)是指把矩阵A上下翻转再赋值给C，D=rot90(A)是将矩阵A逆时针旋转90度再赋值给D
6.矩阵乘方
矩阵乘方要求A必须是方阵，代码为F=A^x，其中x可以是整数、分数、无理数和复数。
7.点运算
MATLAB中的特殊运算。两个矩阵之间的点运算是它们对应元素的直接运算。例如表示A和B的相应元素之间直接进行点乘运算，然后将结果赋值给C矩阵，即。这种点乘运算又称为Hadamard乘积。注意，点乘积要求A和B矩阵的维数相同或其一为标量。这种运算和普通乘法不同。
点运算在MATLAB中起到很重要的作用。例如，当x是一个向量时，则求取数值时不能直接写成x^5，而必须写成x.^5。在进行矩阵的点运算时，同样要求运算的两个矩阵是维度一致的。其实一些特殊的函数，例如sin()也是由点运算的形式进行的，因为它要对矩阵的每个元素求取正弦值。
矩阵点运算不仅可以用于点乘积，还可以用于其他。例如进行A.^A运算，则新的矩阵元素为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af32ce69def8be450d0713656f9135a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9660df81767e722ab98d323dca727243/" rel="bookmark">
			BoxInst配置及训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BoxInst安装 使用BoxInst需要先安装AdelaiDet，AdelaiDet是一个运行在Detectron2基础上的工具箱，可以实现以下多个算法：
FCOS，BlendMask，MEInst，ABCNet，ABCNetv2，CondInst，SOLO，SOLOv2，BoxInst，DenseCL，FCPose，DirectPose
github地址：https://github.com/aim-uofa/AdelaiDet
requirement linux or macOS with Python &gt;= 3.7
pytorch &gt;= 1.8 (最好是1.8.1，1.10以上的会出一点bug，很怪，最后也没解决掉)
Opencv
gcc&amp;g++ &gt;= 5.4
sudo apt-get install gcc ninja
Build detectron2 from source git clone https://github.com/facebookresearch/detectron2.git python -m pip install -e detectron2 如果安装出了bug，需要重新安装，使用指令 rm -rf build/ **/*.so清除掉旧的build文件，然后重新安装
如果重新安装的pytorch，也需要对detectron2进行重新安装。
Install AdelaiDet git clone https://github.com/aim-uofa/AdelaiDet.git cd AdelaiDet python setup.py build develop 可能会出的bug：
这一步基本上没啥bug出现，很常见的一个bug，就是
AdelaiDet/adet/layers/csrc/ml_nms/ml_nms.cu:4:10: fatal error: THC/THC.h: No such file or directory 4 | #include &lt;THC/THC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9660df81767e722ab98d323dca727243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d877dcda6188694eac03171e794acdb3/" rel="bookmark">
			《运维》三、解析二级域名和配置https证书(运维4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析二级域名和配置https证书 一、解析二级域名(DNS 解析 DNSPod) 1、打开腾讯云/阿里云
2、找到 云解析 -&gt; 域名解析列表 -&gt; 点击要解析域名的解析操作
3、点击添加记录
比如原来主域名为mywebsite.com，子域名名字填写abc
4、ping abc.mywebsite.com 测试是否添加子域名成功
二、配置https证书 1、打开腾讯云/阿里云2、找到 ssl证书 -&gt; 证书管理 -&gt; 申请免费证书3、通用名字可写abc.mywebsite.com4、选中 自动DNS验证5、下载ssl证书后放到云服务器上某个路径6、/etc/nginx/conf.d/ 目录下新增一个nginx的conf配置，如xxx.conf配置中，开启ssl并指定证书的路径// 完整配置 server { 5 listen 443 ssl; 6 server_name abc.mywebsite.com; 7 8 root /data/www/abc; 9 index index.php index.html index.htm; 10 11 access_log /var/log/nginx/access_it.log main; 12 13 ssl on; 14 ssl_certificate /abc/httpscer/Nginx/1_abc.mywebsite.com_bundle.crt; 15 ssl_certificate_key /envirsqy/httpscer/Nginx/2_abc.mywebsite.com.key; 16 ssl_session_timeout 5m; 17 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 18 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d877dcda6188694eac03171e794acdb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd09d11801ca9547c8bc6b7fae8103a/" rel="bookmark">
			Dubbo经典之作(Dubbo使用详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识Dubbo Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题，官方提供了 Java、Golang 等多语言 SDK 实现。使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力， 利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑。
Dubbo3 定义为面向云原生的下一代 RPC 服务框架。3.0 基于 Dubbo 2.x 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全性等几大方向上进行了全面升级。
Apache Dubbo 总体架构能很好的满足企业的大规模微服务实践，因为它从设计之初就是为了解决超大规模微服务集群实践问题，不论是阿里巴巴还是工商银行、中国平安、携程等社区用户，它们都通过多年的大规模生产环境流量对 Dubbo 的稳定性与性能进行了充分验证，因此，Dubbo 在解决业务落地与规模化实践方面有着无可比拟的优势：
开箱即用
易用性高，如 Java 版本的面向接口代理特性能实现本地透明调用
功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力面向超大规模微服务集群设计
极致性能，高性能的 RPC 通信协议设计与实现
横向可扩展，轻松支持百万规模集群实例的地址发现与流量治理高度可扩展
调用过程中对流量及协议的拦截扩展，如 Filter、Router、LB 等
微服务治理组件扩展，如 Registry、Config Center、Metadata Center 等企业级微服务治理能力
国内公有云厂商支持的事实标准服务框架
多年企业实践经验考验，参考用户实践案例 Dubbo 基本工作流程 分布式系统 分布式系统是若干独立计算机的集合，是建立在网络之上的软件系统，在一个分布式系统中，一组独立的计算机展现给用户的是一个统一的整体，因此，我们可以将应用拆分几个核心的业务，通过分布式部署，集群构成一个分布式系统，对于用户来说，用户是感觉不到系统的分布性。
分布式系统特征 (1)分布性。分布式系统由多台计算机组成，它们在地域上是分散的，可以散布在一个单位、一个城市、一个国家，甚至全球范围内。整个系统的功能是分散在各个节点上实现的，因而分布式系统具有数据处理的分布性。(2)自治性。分布式系统中的各个节点都包含自己的处理机和内存，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。(3)并行性。一个大的任务可以划分为若干个子任务，分别在不同的主机上执行。(4)全局性。分布式系统中必须存在一个单一的、全局的进程通信机制，使得任何一个进程都能与其他进程通信，并且不区分本地通信与远程通信。同时，还应当有全局的保护机制。系统中所有机器上有统一的系统调用集合，它们必须适应分布式的环境。在所有CPU上运行同样的内核，使协调工作更加容易。 RPC 框架 RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，编写的调用代码基本相同。
Dubbo工作流程 Dubbo 首先是一款 RPC 框架，它定义了自己的 RPC 通信协议与编程方式。如上图所示，用户在使用 Dubbo 时首先需要定义好 Dubbo 服务；其次，是在将 Dubbo 服务部署上线之后，依赖 Dubbo 的应用层通信协议实现数据交换，Dubbo 所传输的数据都要经过序列化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd09d11801ca9547c8bc6b7fae8103a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c994b418d967bdf8048ee20b4acf2642/" rel="bookmark">
			百问网七天物联网课程笔记（第六天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础班部分 今日内容：使用开发板配置TCP连接，使用小程序和开发板进行交互。
AT指令发送函数：
// 向ESP8266发送AT指令 uint8_t ESP8266_SendCommand(char *cmd, char *reply, uint16_t timeout) { // 1.保存传入的指令 char buf[256] = {0}; strcat(buf, cmd); // 2.处理AT指令 if (strstr(buf, "\r\n") == 0) { strcat(buf, "\r\n"); } // 3.清理前面接收的buf USART2_ClearBuf(); // 4.发送数据 USART2_Transmit((uint8_t *)buf, strlen(buf), 500); // 5.接收数据 memset(buf, 0, 256); while(timeout != 0) { if(USART2_Receive((uint8_t *)buf)) { if (strstr(buf, reply)) { printf("%s Send ok!\r\n", cmd); // 发送成功 if (strstr(buf, "CIFSR")) printf("%s\r\n", buf); // 打印IP地址 return 0; } else { timeout--; HAL_Delay(1); } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c994b418d967bdf8048ee20b4acf2642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603f52ac48c2ccdcaa278278731f1d88/" rel="bookmark">
			MyBatis框架常用优化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、优化之Session工具类 1、单独使用 MyBatis时，可以封装一个用来获取MyBatis中Session的工具类 回顾之前使用Mybatis来操作数据库的步骤：
（1）启动mybatis框架（ SqlSession----&gt;SqlSessionFactory----&gt;SqlSessionFactoryBuilder）
（2）通过 SqlSessionFactoryBuilder来得到SqlSessionFactory ；
（3）通过SqlSessionFactory 来创建SqlSession；
（4）读source文件下的mybatis.xml，将mybatis.xml文件转化成流
（5）创建SqlSession对象
public static SqlSession session; //启动mybatis框架，读配置文件，获取Session对象 public void getSession() throws IOException{ // (1)启动mybatis框架 // SqlSession----&gt;SqlSessionFactory----&gt;SqlSessionFactoryBuilder SqlSessionFactoryBuilder sfb = new SqlSessionFactoryBuilder(); // 读source文件下的mybatis.xml,将mybatis.xml文件转化成流 InputStream ins = Resources.getResourceAsStream("mybatis.xml"); // (2)创建SQLSessionFactory工厂对象 SqlSessionFactory ssf = sfb.build(ins); // (3)创建SqlSession对象 session = ssf.openSession(); } 每次操作数据库都要重复上述步骤，因此，可以像封装jdbcUtil一样，将它封装成一个工具类！
2、MybatisUtil.java package cn.java.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MybatisUtil { //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603f52ac48c2ccdcaa278278731f1d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7258f7fdcd9feb5e6a232e47ac575b78/" rel="bookmark">
			javaweb论文参考文献(2020年精选91个)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Web,是用Java技术来解决相关web互联网领域的技术栈。web包括：web服务端和web客户端两部分。Java在客户端的应用有java applet,不过使用得很少，Java在服务器端的应用非常的丰富，比如Servlet,JSP和第三方框架等等。Java技术对Web领域的发展注入了强大的动力。下面是javaweb论文参考文献91个，供大家参考阅读。
javaweb论文参考文献一：
[1]邓明杨，李忠雄。基于JAVA Web技术的网上书城的设计与实现[J].计算机产品与流通，2020（05）：159-160.
[2]陶林，瞿少成，易宇凡，杨军文，郝超。一种模拟农场环境监测与灌溉控制的教育物联网系统实现[J].电子测量技术，2019,42（24）：81-85.
[3]苗立志，崔进东，孙敏，崔文俊。面向北斗CORS运行数据的动态监测系统[J].南京邮电大学学报（自然科学版），2020,40（01）：70-74.
[4]汪永松。JavaWeb开发技巧之项目模板[J].电脑编程技巧与维护，2020（02）：3-8+16.
[5]武奕含。浅谈计算机专业学生“学习高原”现象[J].数字通信世界，2020（02）：270.
[6]薛茹。基于JavaWeb的图书购物网站的设计与实现研究[J].南方农机，2020,51（02）：217.
[7]李光明，房靖力。基于JavaWeb的推荐数据后台管理系统的设计与实现[J].电脑知识与技术，2020,16（03）：66-68.
[8]匡少华，丁昊，赵正平。基于Javaweb的大学生食堂外卖平台的设计与实现[J].信息与电脑（理论版），2020,32（01）：91-94.
[9]刘岑松，罗小巧，洪习欢。基于物联网的智能浇花系统[J].电子测量技术，2020,43（01）：176-180.
[10]聂毓谣。基于数据库的员工考勤系统设计与实现[J].电脑知识与技术，2020,16（01）：56-58+87.
[11]季昆，孟丽丽，薛迁，孙晓伟，王才华。基于JavaWeb的产品质量检测预警系统的设计与实现[J].数字技术与应用，2019,37（10）：176-177.
[12]李宣廷，姜楠，狄查美玲，王淖莹，孟德文。基于ElasticSearch的网络舆情搜索平台设计[J].大连民族大学学报，2019,21（05）：449-452.
[13]王瑾，童莲。基于Javaweb的宿舍报修系统的设计与实现[J].花炮科技与市场，2019（03）：223.
[14]王予诺。基于Web的C2C农业电子商城的设计与实现[J].信息与电脑（理论版），2019（12）：89-90.
[15]陈秋玲。基于JavaWeb的图书购物网站的设计与实现[J].电脑知识与技术，2019,15（16）：36-38.
[16]吴昊。基于JavaWeb的学生云博客的设计与实现[J].电脑知识与技术，2019,15（16）：57-58.
[17]汪美。基于Javaweb内置对象session的仿真[J].科技风，2019（10）：74.
[18]蒋凌志。Java程序设计在线考试系统的开发[J].电脑知识与技术，2019,15（07）：142-144.
[19]干佳林，何贞铭，廖环宇。JFinal与SSH在JavaWeb应用开发中的研究[J].电脑知识与技术，2019,15（07）：81-82.
[20]赵宇，马静，陶一平，陈佳智。花卉温室可视化监控系统设计[J].黑龙江科学，2019,10（04）：24-25.
[21]林琴，王庆伟。基于JavaWeb的图书馆座位预约系统设计与实现[J].电脑知识与技术，2019,15（05）：78-79.
[22]段聪聪，柴世一。基于知识图谱的软件工程项目库设计与开发[J].科技视界，2019（03）：105+86.
[23]韩嘉锐，郑浩，郭鲁，魏颖。基于JavaWeb的高校二手交易平台管理系统的设计与实现[J].南方农机，2019,50（01）：159.
[24]陈鹏，李向阳，罗许丰，陈义明。VR实景分享平台的设计与实现[J].电脑知识与技术，2019,15（02）：31-32+47.
[25]孙丽。将思想政治教育融入高职院校专业课教学的探索与实践--以Javaweb程序设计课程为例[J].产业与科技论坛，2018,17（22）：167-168.
[26]胡子豪。学生宿舍管理系统分析与设计[J].信息与电脑（理论版），2018（21）：82-83.
[27]吴若飞。用Java Web实现OA办公系统[J].山东工业技术，2018（23）：98-99.
[28]姜维，王岩。基于JavaWeb+JDBC的校园服务平台的功能设计与实现[J].时代农机，2018,45（10）：245.
[29]俞昊，陈磊。基于JavaWeb的实验室用电管理系统[J].福建电脑，2018,34（10）：140+95.
[30]马英瑞，刘真，李娟。基于JavaWeb的健身管理系统设计与实现[J].福建电脑，2018,34（09）：39-40+44.
javaweb论文参考文献二：
[31]张学诚。Java WEB开发中的中文乱码问题解决方法[J].电脑知识与技术，2018,14（27）：62-63.
[32]李天赐，李璟璐，于姗姗，刘梓艺。基于Spring MVC的高校学院学工助理系统的设计与实现[J].智能计算机与应用，2018,8（04）：167-169.
[33]李天赐，刘开森，李胜辉。基于SpringBoot卫生备案系统的设计与实现[J].网络安全技术与应用，2018（08）：96-97.
[34]张雪敏。浅议MVC设计模式在JavaWeb中的作用[J].科技风，2018（22）：58-59.
[35]艾磊磊，马春江。基于JavaWeb的特产销售系统中的技术分析[J].信息与电脑（理论版），2018（14）：51-52.
[36]李天赐，田精白。基于SSH框架卫生科技成果申报系统的设计与实现[J].软件，2018,39（07）：84-88.
[37]李天赐，余海情。基于SSH框架试题系统的设计与实现[J].软件，2018,39（06）：74-77.
[38]严春时，黄砷才，蓝伟杰，李国武，邓礼铭。中职招生系统的研发与应用[J].科技视界，2018（17）：62-63.
[39]董成光，杨保华。基于ssm+redis的网络问答社区的设计与实现[J].电脑知识与技术，2018,14（14）：48-51.
[40]李永亮。基于JavaWeb的安防监控系统服务端的设计与实现[J].计算机与网络，2018,44（09）：68-71.
[41]严志。高职职业技能大赛云计算平台关键技术研究[J].长沙民政职业技术学院学报，2018,25（01）：116-118.
[42]沈朝元。JavaWeb在线学习平台的设计与实现[J].电子技术与软件工程，2018（01）：43.
[43]洪幸，崔忠伟，刘卓，孙群龙，付波。基于JavaWeb的大学生兼职管理系统的分析与设计[J].电脑知识与技术，2017,13（31）：76-77.
[44]许文义，刘卓。基于Javaweb的实习管理系统的设计与实现[J].电脑知识与技术，2017,13（29）：67-69.
[45]马国强，王哲。基于JavaWeb的智慧医疗问诊系统设计与实现[J].信息技术与信息化，2017（09）：105-106.
[46]肖德芳，刘卓。基于Javaweb的科研项目管理系统的设计与实现[J].电脑知识与技术，2017,13（27）：69-70.
[47]王品越，韩义波。基于JavaWeb的社区商超系统的设计与实现[J].电子技术与软件工程，2017（16）：54-55.
[48]欧阳宏基，葛萌。基于Struts2+Ajax+JDBC的企业级JavaWeb架构[J].计算机系统应用，2017,26（08）：77-82.
[49]崔梦天，丁春晓。基于JavaWeb的匿名社交软件的设计[J].吉林师范大学学报（自然科学版），2017,38（03）：112-119.
[50]林光源，张国平，高雪莲，陈志文，蔡盼盼。基于JavaWeb的远程库房环境监控系统[J].信息技术，2017（05）：50-55.
[51]李霖，李庆达，区善宁。基于云平台的老年公寓服务系统设计[J].中国新通信，2017,19（09）：66.
[52]陈帅，关玉蓉。基于JavaWeb的奖助学金系统设计与实现[J].科技广场，2017（03）：190-192.
[53]迪丽努尔·库尔班，阿布力米提·艾西丁。网络微信教学系统的设计与研究[J].电脑知识与技术，2017,13（04）：50-51.
[54]李毅。基于Android平台的新闻客户端设计与实现[J].石家庄职业技术学院学报，2016,28（06）：43-45.
[55]许汉平，余颜宏，张东寅，袁艳斌，袁晓辉。短期水电优化调度系统设计与开发[J].水电能源科学，2016,34（12）：186-189.
[56]周伟。计算机JavaWeb软件MVC设计模式的研究与实现[J].电脑迷，2016（12）：33+57.
[57]李迪迪。浅谈房产中介智能推荐系统的实现[J].无线互联科技，2016（21）：43-44.
[58]张恩丽，张龙翔。基于JavaWeb的在线考试系统设计与实现[J].福建电脑，2016,32（10）：106+148.
[59]王光琼，任杨，冉椿林，宋敏，叶凤林。基于JavaWeb的物流兼职系统的设计与实现[J].电脑知识与技术，2016,12（24）：81-83.
[60]高磊，阳许军，陶方涛，陈亮。基于JavaWeb和Android的基站发电稽核系统的设计[J].电子设计工程，2016,24（13）：49-51.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7258f7fdcd9feb5e6a232e47ac575b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/049037f3e26b73d1288f2b7c1a5859b5/" rel="bookmark">
			MySql下载和安装&amp;Sqlyog下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载&amp;安装 视频教程: https://www.bilibili.com/video/BV1Qf4y1T7Hx?p=3
1.1 下载 https://downloads.mysql.com/archives/community/
点开上面的链接就能看到如下界面：
选择选择和自己系统位数相对应的版本点击右边的 Download ，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置：
不用理会上面的登录和注册按钮，直接点击 No thanks, just start my download. 就可以下载。
1.2 安装(解压) 下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 5.7.24的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置 例如我是放在D:/software下面 data, my.ini我之后配置的， 此时应该是没有的
2.配置环境&amp;文件 2.1 添加环境变量 右键 此电脑 → 属性 —&gt; 高级系统设置—&gt; 环境变量—&gt;新建
变量名
MYSQL_HOME 变量值 (mysql位置 根据自己的位置改变)
D:\Software\mysql-5.7.24-winx64 配置之后点击确定
2.2 path路径环境 添加如下到path路径中
%MYSQL_HOME%\bin 2.3如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择 命令提示符(管理员) ，打开黑框，敲入 mysql ，回车。 如果提示 Can't connect to MySQL server on 'localhost' 则证明添加成功； 如果提示 mysql不是内部或外部命令，也不是可运行的程序或批处理文件 则表示添加添加失败，请重新检查步骤并重试。
2.4 配置文件my.ini 在安装目录下配置新建一个my.ini文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/049037f3e26b73d1288f2b7c1a5859b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9806e89ff73e6bc9f80cb57876466e8/" rel="bookmark">
			dockerfile如何自己建一个tomcat(自己制作一个tomcat,访问8080的时候是显示我们的页面而不是它的那个猫)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本
家想想，Nginx，tomcat，mysql 这些镜像都是哪里来的？官方能写，我们不能写吗？
我们要研究自己如何做一个镜像，而且我们写的微服务项目以及 springboot 打包上云部署，Docker就是最方便的。
微服务打包成镜像，任何装了Docker的地方，都可以下载使用，极其的方便。
流程：开发应用=&gt;DockerFile=&gt;打包为镜像=&gt;上传到仓库（私有仓库，公有仓库）=&gt; 下载镜像 =&gt; 启动 运行。
还可以方便移植！
构建步骤：
1、编写DockerFile文件
2、docker build 构建镜像
3、docker run
实战测试
CentOS
官方默认的 CentOS 的情况不支持 vim 和 ifconfig 指令
我们自己构建一个支持这些指令的镜像
步骤：
将 JDK 和 tomcat 安装的压缩包拷贝到自己放的地方（我个人放的位置不当就放在了src里面）用的是（jkd1.8与tomcat7.047） 2.新建一个 Dockerfile 文件
FROM centos MAINTAINER xiaomi&lt;test@qq.com&gt; #把宿主机当前上下文的read.txt拷贝到容器/usr/local/路径下 COPY read.txt /usr/local/cincontainer.txt #把java与tomcat添加到容器中 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ ADD apache-tomcat-7.0.47.tar.gz /usr/local/ #安装vim编辑器 RUN yum -y install vim #变量 ENV MYPATH /usr/local #设置工作访问时候的WORKDIR路径，登录落脚点 WORKDIR $MYPATH #配置java与tomcat环境变量 ENV JAVA_HOME /usr/local/jdk1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9806e89ff73e6bc9f80cb57876466e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee66d559bfb57cf44fa7f19a934ce6be/" rel="bookmark">
			百问网七天物联网课程课后笔记（第五天提高课）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础概念QOS0:最多发一次 QOS1:至少发一次
QOS2：只发一次
MQTT的客户端：
一个使用MQTT协议的应用程序或者设备，总是建立到服务器的网络连接
发布其他客户端可能会订阅的消息
订阅其他客户端发布的消息
退订或者删除其他客户端的消息
断开和服务器的连接
MQTT 的服务器
称之为代理“broker”,可以是一个应用程序或者一个设备，它是连接联系发布者和订阅者的桥梁
接收连接客户端的网络连接
接收客户端发来的消息
处理来自客户端的订阅和退订请求
向订阅的客户转发应用程序消息
![在这里插入图片描述](https://img-blog.csdnimg.cn/9fc821ebc77443968a861bbdef5a69f0.jpeg#pic_cente
使用MQTTX连接阿里云 打开阿里云物联网平台，新建一个产品SmartHome
自定义一个LED1的TOPIC，路径如下：产品→TOPIC类列表→自定义TOPIC→定义一个TOPIC类
添加LED1设备到SmartHome
点击设备LED1，查看MQTT连接参数
5. 打开MQTTX这个软件，将连接参数输入
6. 点击右上角CONNECT，连接成功后，返回阿里云，刷新一下，设备会显示“在线”
7. 在MQTTX软件中，点击 NEW Subscription 订阅刚刚自定义的TOPIC
注意：需要将devicename改成自己设备的名字
8. 订阅后，在设备→→LED1→Topic列表中就能看到新的TOPIC
在新的TOPIC中，点击发布消息,之后在MQTTX这个软件中就会收到这条消息
10. MQTTX客户端向服务端发送消息。输入TOPIC，然后输入消息，点击发送
，之后就能在阿里云的日志服务中找到这条消息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9723f57b040d9f06eb1aae9dcc42d75/" rel="bookmark">
			谷歌翻译网页无法翻译，最新解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原始方法
关于没有权限修改host文件的解决方法1
关于没有权限修改host文件的解决方法2-
--------------------------------下面为最新解决方法 10.22-------------------------------------
做完忽然发现谷歌网页翻译又失效了，于是我又重复了之前的旧方法，还是不行。
后来发现是之前的ip地址可能也被关掉了，现在提供几个新的ip地址，大家可以按照之前的方法一个一个去试：
120.253.253.34 translate.googleapis.com 142.250.0.90 translate.googleapis.com （这个我的可以） 142.250.66.138 translate.googleapis.com 113.108.239.162 translate.googleapis.com 203.208.39.226 translate.googleapis.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1c3fd66d02ef26b10d402893c70fe3/" rel="bookmark">
			endNote使用教程笔记-1-简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于如何添加文献引用格式 在endNote官网，下载你要写的杂志的对应文献参考格式的.ens文件
进入官网点击downloads，然后点击add output styles
在搜索栏输入你要搜索的杂志，然后下拉，找到对应的文件，点击下载
下载的ens文件保存到D:\endNote\Styles目录中即可 在endNote中直接搜索论文 新建数据库文件
file-&gt;new-&gt;选择新的数据库名称-&gt;选择存放路径点击第三个按钮（即本地又联网）
在线检索数据库中搜索
下载搜索到的论文的全文
阅读文献 选中下载好全文的文件，再点击open file
默认打开外置阅读器，也可以用内置阅读器
参考文献引用 选中要参考的文献，然后点击应用符号
在word中选择你要插入的位置，点击endNote插件，点击insert citation
点击insert selected citation即可
可以在style中选择你要参考的文献格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160e31bd21365c791ca4d61ba6f2546f/" rel="bookmark">
			esp32关于vscode的安装和编译环境的配置（platformio）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载vscode：Download Visual Studio Code - Mac, Linux, Windows 2.配置vscode： 1）打开vscode：点击扩展
2）搜索platform：安装platformio插件
3）下载平台支持包：
3.查看eps32的串口是否成功： 4.尝试使用点亮板载灯： #include &lt;Arduino.h&gt; #include &lt;Adafruit_I2CDevice.h&gt; #include &lt;SPI.h&gt; void setup() { //pinMode(串口，模式) //初始化 pinMode(2, OUTPUT); } void loop() { //digitalWrite(串口，模式) //循环 digitalWrite(2, HIGH); delay(1000);//延时函数 digitalWrite(2, LOW); delay(1000);//延时函数 } 5.烧录：点击下方箭头（先build 工程，然后连接好board，最后upload） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab834dbd6a98fd6b88af0ca5e0f6fce/" rel="bookmark">
			vue中缓存组件keep-alive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍
使用
缓存所有的组件
缓存某个组件
keep-alive的使用示例
include和exclude属性的使用
include的使用
exclude的使用
生命周期
介绍 keep-alive是vue的内置组件，可以用来缓存组件。当它包裹动态组件时，会缓存不活动的组件实例，不会销毁它们；将不活动的组件的状态保留在内存中，可以防止重复渲染DOM，减少加载事件和性能消耗。
注意：keep-alive是一个抽象组件，自身不会渲染成一个DOM元素，也不会出现在父组件链中。
原理：
在 created 函数调用时将需要缓存的 VNode 节点保存在 this.cache 中／在 render（页面渲染） 时，如果 VNode 的 name 符合缓存条件（可以用 include 以及 exclude 控制），则会从 this.cache 中取出之前缓存的 VNode 实例进行渲染。
使用 缓存所有的组件 在APP.vue中缓存所有组件
&lt;template&gt; &lt;div id="app"&gt; &lt;keep-alive&gt; &lt;NativeBtn&gt; &lt;router-view /&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/template&gt; 缓存某个组件 缓存某个组件就直接在该组件的外层嵌套一层&lt;keep-alive&gt;
&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 只缓存NativeBtn组件 --&gt; &lt;keep-alive&gt; &lt;NativeBtn /&gt; &lt;/keep-alive&gt; &lt;router-view /&gt; &lt;/div&gt; &lt;/template&gt; keep-alive的使用示例 先来看看不加keep alive的情况
代码：
keepAliveDemo的代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ab834dbd6a98fd6b88af0ca5e0f6fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27519146561db935b54bc32cbcccd29b/" rel="bookmark">
			vscode代码自动排版对齐的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode自带格式化文档功能，但是我们安装插件过多，或者修改配置后，部分快捷键被占用。因此很多时候改快捷键就可以解决问题。
注意，在输入前，可以输入要修改的键位名称查询已绑定的功能，防止发生键位冲突
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d968093a39b63977ddb094d76e1aa2d9/" rel="bookmark">
			【MATLAB】根据已有数据绘制Bode图、时域曲线等（进阶版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前期教程前言读取数据方法一：按行读取方法二：按列读取 设置figure属性自定义横纵坐标刻度使横坐标按对数刻度显示，即Bode图的形式去掉复制的图片的空白边距 在同一个figure中画不同的图——plotyy补充：WORD转PDF时MATLAB图片失真 前期教程 建议查看上面的专栏。
前言 最近上了一个自控相关的实验，因为打印需要，报告里面的图片不能用实验过程中保存的图片（黑色背景，而且样式复古），因此想到使用MATLAB来实现，因此研究了一下进阶版的MATLAB绘图，收获颇多，记录一下。
读取数据 既然要根据已有数据绘图，那么如何有效读取数据就成为非常重要的一步。我这个实验保存的数据是txt格式，于是找到这个链接，记录的方法比较全面，具体使用方法建议去啃help文档。
本实验记录的数据格式是类似于表格的形式，但是上面还有题头，如下图所示。
一个行之有效的方法是在MATLAB中选择导入数据，然后选择对应的txt文件，然后有选择性地只导入数据部分，但是这样有一个很大的缺点，那就是非常慢！！！ 毕竟，我这实验有近50个数据文件呢。。。
因此，使用代码实现势在必行！由于文件中中英文混杂，还有题头等数据的干扰，只有部分数据是表格形式的有效数据，于是采用的是textscan函数，这里介绍两种方式。
方法一：按行读取 这种方法适用于上面第二张图，数据是根据时间顺序按行写入的，因此可以按照读取文件的方式来读取。
fID = fopen(filename, 'r'); %以读取的方式打开文件，返回文件ID data_cell = textscan(fID,'%s','CommentStyle','\n'); %以忽略回车的方式读取文本文件中的数据，cell格式 fclose(fID); %及时关闭文件，以免产生后患 这种方式巧妙之处在于，这个函数恰好可以将同一行的数据分开，最后得到的就是一个一个数据，只是需要将“3.478伏”变成数据3.478即可。具体实现是采用sscanf函数：
value(i) = sscanf(A{i}, "%f%*s"); %A为cell数组，读取到的浮点数返回到value中 其中用%*s表示读取一个字符串但忽略，不输出，这种操作非常好用。
方法二：按列读取 除了根据时间顺序按行写入的数据文件，还有按列写入的数据（tmd。。。），不能直接套用上面的方法，而是需要先整体读入数据，得到一个矩阵（二维数组），然后将其按列组合成一个向量。因此textscan得换一种应用方式：
fID = fopen(filename, 'r'); %需要注意，这个数据是按列写入的，所以要进行后续处理 data_cell = textscan(fID,'%s','Delimiter','\n'); %按换行符划分，先分行 fclose(fID); d = data_cell{1}; 得到数据之后去掉题头部分，剩下的部分仍然使用sscanf函数进行数据提取：
value(i) = sscanf(D{i}, '%*s%*s%d'); 这里还需要注意，不要认为只有一个字符就可以使用%*c，建议优先考虑%*s，因为读取字符是可以读取空格的！！！
设置figure属性 一般来说，我们使用MATLAB绘图，就是直接复制图窗，顶多是点开属性栏简单设置一下属性，但是如果图片较多的话，逐个设置就会很麻烦，使用代码来设置才是最佳选项。
在MATLAB中，每次绘制的曲线图像实际上就是一个对象，它具有非常多的属性，于是可以通过代码来修改这个对象的属性。这里用到的对象主要有两个：
gcf：Figure对象，主要用于设置那个figure窗口的属性。gca：axes对象，主要用于设置坐标轴相关的属性。 下面简单介绍常用的两种设置。
自定义横纵坐标刻度 有时候画图时，我们想要看到一些特定值对应曲线函数值是多少，但是由于默认的自动坐标没有显示该值，那么就可以通过设定刻度来实现特定函数值的观察。方法如下。
x=1:10; set(gca, 'xtick', x); 或者对于R2014b之后的版本，可以这样：
ax = gca; ax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d968093a39b63977ddb094d76e1aa2d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad6e2a0a778e110b7978595322635d1/" rel="bookmark">
			vue3&#43;ts封装el-select el-input通用组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你还在为项目中多个页面输入框下拉框样式不统一而苦恼吗，你还在为页面中书写大段重复代码而痛苦吗？那就使用这个组件吧！此组件将输入框和下拉框统一封装，一行代码到处复用！
最近为了统一项目样式，决定将列表头部的输入框和下拉框统一封装，这样无论是哪个页面的输入下拉都看起来一样啦，代码如下：
&lt;template&gt; &lt;div class="component_wapper"&gt; &lt;el-row :gutter="16"&gt; &lt;el-col v-for="(item, index) in props.searchFormDesc" :key="index" :span="item.layout || 6"&gt; &lt;slot :name="`search-${item.searchKey}`" :form-data="searchFormData"&gt; &lt;component :is="item.searchType === 1 ? ElInput : ElSelect" v-model="searchFormData[item.searchKey]" :placeholder="item.placeholder" clearable :disabled="item.disabled" :prefix-icon="item.searchType === 1 ? Search : ''" @change="formDataChange" &gt; &lt;template v-if="item.searchType === 2 &amp;&amp; item.option" #default&gt; &lt;el-option v-for="op in item.option" :key="op[item.optionLabel || 'label']" :value="op[item.optionValue || 'value']" :label="op[item.optionLabel || 'label']" /&gt; &lt;/template&gt; &lt;/component&gt; &lt;/slot&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad6e2a0a778e110b7978595322635d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815c10cc37a9c6403aa570751545b62c/" rel="bookmark">
			Feign远程调用服务提供方入参没有值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 今天使用Feign远程调用的时候，服务端接收到了入参，但是入参的每个字段都为空，本质上请求接口成功了，但是入参没有接收到，因此记录下问题处理的过程。
问题原因 这里先说下问题的原因，服务调用方发起请求时Content-Type为application/json格式，但是服务提供方接收请求而时却把它当做application/x-www-form-urlencoded接收了。
问题解决 在Feign客户端远程调用的接口指定当前请求的格式和服务提供方期望的格式一致，加上如下注解值：
@PostMapping(value = "/xxx", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE) 另外再说下自己对Feign客户端的思考，Feign客户端有的人喜欢把它写在服务调用方，有的人喜欢把它写到服务提供方，其实各有各的好处。
写在服务调用方：则不需要再引入服务提供方的maven包依赖，但是如果调用过程中的入参类或返参类在服务调用方中不存在的话，则需要新建这样的基础类。写在服务提供方：服务调用方不需要再新建一些额外的基础类，但是需要引入服务提供方的依赖。 以上只是代码级别的对比，大家可以根据自己项目的实际需求决定Feign客户端写在哪一方。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8abc30caee23147673e731d828ff3a2f/" rel="bookmark">
			【JAVA核心知识】4.2: CMS垃圾收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在【JAVA核心知识（面试宝典）】4.1: JVM GC垃圾收集器之Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old这篇博文中介绍了GC垃圾收集器中5种相对简单的垃圾收集器。这篇博文来介绍较为复杂的CMS垃圾收集器，也是目前的主流垃圾收集器。
CMS垃圾收集器 关键字：标记清除，并行，老年代
CMS(Concurrent Mark Sweep)垃圾收集器是一种采用标记清除算法的的垃圾收集器。其主要目标是获得更短的垃圾回收停顿时间。更短的停顿时间可以为交互性较强的程序提供更好的用户体验。
CMS垃圾收集的过程要经历两次Stop The World。虽然比Serial Old，Parallel Old这两种垃圾收集器多了一次Stop The World。但是CMS通过将耗时较严重的引用链分析（大部分的引用链分析都是并发完成的，但是有小部分引用链分析依然是在Stop The World期间完成）以及内存清理过程并发实现，使得其在停顿时间要比Serial Old, Parallel Old短的多。但是这种并发实现因为并发期间的对象在使用，无法进行移动，也就使得CMS无法使用标记整理算法，会出现堆内存碎片化的问题。
因为CMS的并发执行特性，使得CMS垃圾收集器不能等到老年代内存消耗完时才进行回收，它需要预留一部分内存用来存放GC过程中新产生的老年代对象。可以通过CMSInitiatingOccupancyFraction来控制老年代内存达到百分之多少时开始进行CMS GC。
CMS垃圾收集器通过三色标记法将对象标记为不同的状态，并根据标记状态进行相应的处理：
白色：该对象未被标记过灰色：该对象自身被标记，但是内部引用未被处理（该对象可达，但是没做后续的引用链分析）。黑色：该对象自身被标记，且内部引用已被处理（该对象可达，且已分析该对象所在的引用链）。 CMS的垃圾收集有7个阶段，分别为：
初始标记（Initial-Mark）
初始标记阶段是CMS垃圾收集过程中第一个Stop The World产生的阶段，单线程执行。这个阶段标记（灰色标记）两类对象。一类是GC Roots对象。一类是有新生代对象引用的老年代对象。GC Roots对象的自无需多说，他是可达性分析法引用链的根节点。标记有新生代对象引用的老年代对象是因为CMS是老年代垃圾收集器，新生代的对象引用对于老年代对象来说依然属于老年代外部的引用，因此仍然有必要认为其引用链是有效的。
经历了初始标记：
并发标记（Concurrent-Mark）
并发标记的过程与用户线程同步进行。此阶段做两件事情，一件是以初始标记阶段所标记的对象为根节点进行引用链分析，并标记（黑色标记）引用链上的对象为存活。第二件是记录引用链分析标记过程中老年代引用关系产生变化的对象[注1]。因为并发标记和用户线程同步进行，这就意味着标记过程中可能会发生有新生代对象晋升入老年代，有新对象直接被分配入老年代，这种晋升的情况在重新标记阶段会重新扫描GC Roots对象以及新生代对象避免漏标。
对于老年代内部引用关系的变更，如下图A-C的新链，A已标位存活，所以GC Roots不会重复处理，这就会导致C的漏标，CMS处理这种漏标是采用增量更新的方式：标记的方法是为老年代堆内存设立一个Dirty Card表[注2]，如果有对象在并发标记过程中出现了引用变更，那么就将其所在的Card标记为Dirty[注3]，这样后面预清理和重新标记阶段就对Card中的所有对象都重新进行一遍引用分析（Dirty Card只标记了这个Card里有引用变更，而不是标记哪个对象的哪个链出现了变更，因此需要对所有对象的所有引用链都进行一次分析）。 G1采取起始快照算法解决这个问题，关于CMS为什么采用增量更新的方式，起始快照算法和增量更新的优缺点，为什么G1采取起始快照算法的原因及对比可见看下一节 G1垃圾收集器-5.2.3.1 SATB（起始快照算法 Snapshot at the beginning）
经历了并发标记：
注1：引用关系更新是指老年代对象对老年代对象引用更新，新生代对老年代新的引用并不算引用更新，原因上面提过，CMS是老年代垃圾收收集器，来自新生代的引用对老年代来说是外部引用，会在后面重新标记阶段处理。
注2：Dirty Card表并不是使用的Card Table，而是一种类似数据结构被称为ModUnionTalble的数据表。具体行为是将老年代堆内存空间分为一个个相等的小区间，每一个区间被称为Card Page，每个Card Page在Dirty Card表中会有一个对应的bit位标识其状态，如果一个对象的引用关系改变，写屏障逻辑就会将其所在的Card Page就会被标记位Dirty。注意Dirty标记是不是标记在对象上面的，而是标记到对象所在的Card Page上面。扫描时是扫描Card Page中的所有对象。一个Card Page可能不只有一个对象，那么并发情况一个Card Page的多个对象发生改变，那么都需要对Dirty Card表的同一位进行标记修改，这时间就会发生伪共享（false sharding：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享）的问题。为了解决这个问题，JDK1.7加入一个参数-XX:+UseCondCardMark来控制是否进行有条件的写屏障，开启时就会判断目标Card Page是否已经被标记为Dirty，如果是就不再重复进行标记了.
注3：需要标记的是引用对象所在的Card而不是被引用对象，比如老年代中新增A-&gt;B,那么标记在A的Card，而不是标记在B的Card。原因是A引用B，扫描A所在Card时如果A是存活节点那么B也就是存活节点，A是待回收节点B也是待回收节点。如果标记在B上，那么就会出现只知道B被别人引用了，但是引用他的是一个存活节点还是死亡节点却无法判断。
预清理（Concurrent-PreClean）
在并发标记阶段CMS标记出了那些在并发标记阶段发生改变的Card，预处理阶段就是对这些Card中的对象进行引用链分析，进行存活性标记。因为这个阶段不会Stop The World，所以也会持续进行Dirty Card标记。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8abc30caee23147673e731d828ff3a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d213240b2c1cb23cc132c1653eddbf4/" rel="bookmark">
			Anaconda（python，pycharm）半详细安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文章目录
简介
一.Anaconda（python，pycharm）简介概述
二.Python安装
三.Anaconda安装
四:pycharm安装
简介 本文尽量通过精简的语言，一次说明白安装的流程及其注意事项。。。文章中是以电脑中已经安装了python为基础但又想在额外安装anaconda以及保留原有python版本的情况进行讲解的。
一.Anaconda（python，pycharm）简介概述 二.Python安装 Python官网：python.org
进入官网后我们点击Downloads，然后选择跟软件配对的系统版本（本文是以windows为例子）。
进入下载链接后，里边包含了python的全部版本（根据自己需求下载，不建议下最新版本，容易出现库安装不上的情况），图中1与2都是python的安装包选择一个即可（好像有一个是免安装的...忘记了）然后文本中选择的是3.8.10的版本。。。
开始安装后，记得勾选上最下边（Add python 3.8 to PATH）的选项，程序会自动帮你添加环境变量，不然后边要自己手动添加了awa。然后再点击下边的（Customize installation）这个选项进行下一步。
这里也是全部勾选上然后单击下一步。
这里勾选前五个，最后安装位置的话不建议安装在C盘（下一步）。。
安装成功后便出现了如下的提示。
然后我们打开任务管理器输入python，这是上边显示的是我们刚刚安装的3.8版本（此时为默认python版本），pip list命令则是为了查看，目前python中存在的库的信息。
同理输入python --version或者是where python都可以查看目前电脑中所存在的python版本及情况。
补充：若前边安装时没有勾选自动添加环境变量的选项则需要自己在环境变量里自行添加python的环境路径（如图示）。。此时需要分别在用户和系统环境的path中添加python的环境路径，添加环境路径的顺序如图所示（切记不要把顺序弄错了）。
三.Anaconda安装 Anaconda官网：anaconda.org
进入官网后我们单击右上角的download选项。
或者可以直接通过anaconda.com/products/distribution这个网址进入。然后右下角有Anaconda的下载版本，这边显示的是python3.9的版本（windows版本），若下选择其他系统版本可以单击get add下方的图标进行。
如果觉得顶页的Anaconda的python版本太高，可以选择下载其他得版本，将页面网页滑到底，如图示可以看到archive一段字样，点击进入。。
这个网页包含了以往所有Anaconda的版本，单击一个自己合适的版本进行下载即可，这边我下载的还是python3.9版本的。
然后我们进入Anaconda的软件安装，这边建议勾选第二个选项（好像是全部用户都可以使用来着），然后进行下一步。。安装位置的话不建议在c盘（一个盘的话就随意啦~）
注：下图为特殊情况（以前安装但又卸载过Anaconda的话极有可能出现）
个人的解决方法：返回前二步的选项，点击选择中的just me选项然后进行下一步的安装就不会遇到这种情况了，缺点是如果想要和第二个任何人都可以使用Anaconda这个选项一样的话，就需要在Anaconda安装完成后在额外系统变量的path列表里添加Anaconda的环境变量。注：一定要按顺序添加Anaconda的环境变量。
最后就安装完成了
由于Anaconda是自带python的，但打开cmd窗口时仍然会显示先前安装的3.8版本的python。这时打开环境变量的窗口，把Anaconda的环境变量路径移动到原先安装的3.8版本的python上去，注意不要打乱Anaconda的路径顺序（很重要）。
移动后再次打开cmd输入python发现python版本已经变成anaconda里自带的python版本了。
换号相应的Python版本的后，打开Anaconda的界面 然后再点击cmd.exe进行运行，进行第三方库安装时的链接换源（这里提供二种方法，仅供参考）：
1.首先打开cmd输入%APPDATA%，然后在该目录下创建一个pip的文件夹，然后再里边的新建记事本上写上图中的代码，即可完成换源。
2.或者直接在anaconda中的cmd输入换源的地址 即可（如图示）。
这边提供其他几个国内第三方库的下载源地址：
阿里云：http://mirrors.aliyun.com/pypi/simple/ 科技大学：https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣：http://pypi.douban.com/simple/ 清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学：http://pypi.mirrors.ustc.edu.cn/simple/ 如何查看换源是否成功，可以在conda的cmd中随机安装几个第三方库的包进行验证，以图中opencv-python的包为例，其中的第二段looking后边跟定的清华源的网址，就是我们起先在电脑记事本中打入的换源网址，证明换源已经成功。。。
完成以上的第三方库安装换源后，我们还需要对conda内部自带的镜像源进行一次换源（默认自带国外的源）：
1.首先打开anaconda里的cmd.exe，输入conda config --show channels命令查看是否添加过镜像源（这边之前卸载的时候有残留），然后我们再次输入conda config --remove-key channels清空之前所有设置过的国内镜像源，然后在输入conda config --show channels进行查看可以看到conda内部的镜像地址已经恢复到了初始化状态。。。
2.输入conda config --add channels 后边加上要换源的网址进行镜像地址的添加。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d213240b2c1cb23cc132c1653eddbf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b906144df09eda83d23ae1f1e2fffe2/" rel="bookmark">
			JAVA多线程：狂抓 join()方法到底会不会释放锁，给你彻底介绍清楚（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 了解这个问题前，先了解锁的概念：
锁，这个概念比较抽象，拿到锁，就意味着拿到了CPU的执行权。
拿3个人看电视来说，锁就好比遥控。
A拿到遥控了，如果A仅仅是想休息一会儿，并不想放弃遥控的持有权（锁），那么就调用sleep(1000)方法。然而，管理员来了，对A说，你立刻、马上把遥控交给我，并且N秒内，不得再拥有遥控，此时就调用wait(10000)方法，调用wait后A会立刻丢失遥控的所有权（直到10秒后才会参与再次竞争），此时剩余的所有人立刻会按优先级，重新争取（锁）遥控的持有权。 概述 针对于这个问题，相信很多在使用多线程的人，都搞的不是很清楚，一直被这个问题困扰。
先说结论
join底层调用的是wait()，而wait是Object的方法，wait本身是会释放锁（彻底交出CPU的执行权），所以 Thread 的join() 方法是否会释放锁？答案是会！
但是，join()只会释放Thread的锁，不会释放线程对象的锁（可能会造成死锁）。
相信很多人看到这个答案，比较绕口，看了很懵逼，上代码（代码很简单，耐心一点哦）
一、示例代码 public class ThreadJoinTestLock { public static void main(String[] args) { Object object = new Object(); MThread mythread = new MThread("mythread ", object); mythread.start(); //synchronized (mythread) synchronized (object) { for (int i = 0; i &lt; 100; i++) { if (i == 20) { try { System.out.println("开始join"); mythread.join();//main主线程让出CPU执行权，让mythread子线程优先执行 System.out.println("结束join"); } catch (InterruptedException e) { e.printStackTrace(); } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b906144df09eda83d23ae1f1e2fffe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12213ff9b54a266ab12a0dd3a0c91f01/" rel="bookmark">
			【numpy】np.loadtxt超级简便的读取.txt文件文本方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在没有遇到np.loadtxt这个方式之前，我都是纯手写的代码，非常的冗余不好看，读取.txt文本内容的也不太方便，所以接下来这个函数将会帮我们完美的解决这个问题。
【numpy】np.loadtxt超级简便的读取.txt文件文本方式
前言
文件内容 .txt
代码文件
1.py
print()
2.py
print()
#致谢
文件内容 .txt 541 6 599 62 544 9 598 62 代码文件 1.py import numpy as np if __name__ == "__main__": box_list = [] with open(car_bbox_path, 'r') as f: for idx, data_ in enumerate(f.readlines()): data = data_.replace('\n', "").split(" ") bbox = [int(x) for x in data] box_list.append(bbox) f.close() print(box_list) print() (gp) C:\Users\86137\Desktop\PF-Face&gt;python pf.py [[714, 390, 1018, 632], [714, 390, 1018, 633]] 这样子写代码会显得代码非常的冗余不好看，实际上这完全可以用np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12213ff9b54a266ab12a0dd3a0c91f01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329fe491c394e9fe31e0315252a39e1e/" rel="bookmark">
			curl Failed to connect to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vps安装脚本时候出现该错误情况 其实使用curl 命令本质是访问一个网站，然后把网站内容下载下来。因此想要运行一个网站就需要一个服务器。所以解决问题的本质就是安装一个服务器 安装nginx yum install nginx -y #安装Nginx systemctl start nginx #启动nginx systemctl enable nginx #设置开机自启动 netstat -lntup|grep nginx #检查80端口 关闭防火墙 或者也有防火墙没有关闭的情况 systemctl status firewalld systemctl stop firewalld 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f073e75b11897736e75e5f4de21a00b/" rel="bookmark">
			SpringBoot集成Spring Security详细配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 Spring Security 和 Apache Shiro 都是安全框架，为Java应用程序提供身份认证和授权。
二者区别
Spring Security：重量级安全框架Apache Shiro：轻量级安全框架 关于shiro的权限认证与授权可参考小编的另外一篇文章 ： SpringBoot集成Shiro 实现动态加载权限
https://blog.csdn.net/qq_38225558/article/details/101616759
二、SpringBoot集成Spring Security入门体验 基本环境 ： springboot 2.1.8
1、引入Spring Security依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 2、新建一个controller测试访问
@RestController public class IndexController { @GetMapping("/index") public String index() { return "Hello World ~"; } } 3、运行项目访问 http://127.0.0.1:8080/index
温馨小提示：在不进行任何配置的情况下，Spring Security 给出的默认用户名为user 密码则是项目在启动运行时随机生成的一串字符串，会打印在控制台，如下图：
当我们访问index首页的时候，系统会默认跳转到login页面进行登录认证
认证成功之后才会跳转到我们的index页面
三、Spring Security用户密码配置 除了上面Spring Security在不进行任何配置下默认给出的用户user 密码随项目启动生成随机字符串，我们还可以通过以下方式配置
1、springboot配置文件中配置
spring: security: user: name: admin # 用户名 password: 123456 # 密码 2、java代码在内存中配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f073e75b11897736e75e5f4de21a00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a41ee2d09d0cc5e5885ae9982789cd7/" rel="bookmark">
			SpringCloud 之 Fegin —— 发送GET、POST请求以及文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud 之 Fegin —— 发送GET、POST请求以及文件上传 由于项目需要调用其他微服务的数据，首先想到的就是写一个http网络请求的工具类，但是想到在之前看springCloud的时候里面有这个Fegin可以实现，就顺便实践一下，虽然过程有点坎坷，好在都顺利解决了，在实践的过程中主要遇见了以下几个问题
1) 不同请求方式传参方式不同
2) 同一请求方式请求头信息不同
3) 发送请求时候的编码器不同
4) 文件上传
(一) Fegin使用
1) 添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; 2)在启动类上加上注解
@EnableEurekaClient @EnableHystrixDashboard @EnableFeignClients //这个就是使用Feign需要添加的注解 @SpringBootApplication public class VideoProxyServiceApplication { public static void main(String[] args) { SpringApplication.run(VideoProxyServiceApplication.class, args); } } 3)Feign 客户端接口
@Component @FeignClient(name = "stream-service",url = "${stream_service}") //name指定FeignClient的名称，url一般用于调试，可以手动指定@FeignClient调用的地址 public interface StreamServiceClient { //GET请求 @RequestMapping(value = "/task/findById",method = RequestMethod.GET) String findById(@RequestParam(value = "id") String id); 4)在Controller层里调用
@RestController @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a41ee2d09d0cc5e5885ae9982789cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec84ccaa9e3140dddac6401a28531067/" rel="bookmark">
			Linux-centos8官方源已下线，建议切换centos-vault源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
使用yum安装时出现如下错误：
Errors during downloading metadata for repository 'AppStream':
- Status code: 404 for http://mirrors.cloud.aliyuncs.com/centos/8/AppStream/x86_64/os/repodata/repomd.xml (IP: 100.100.2.148)
Error: Failed to download metadata for repo 'AppStream': Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried
问题分析
阿里云解释：centos8官方源已下线，建议切换centos-vault源
解决方法
1.删除AppStream源
rm -f /etc/yum.repos.d/CentOS-AppStream.repo
2.取消并备份旧yum源（可直接删除）
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
3.下载vault源
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
4.清除yum缓存
yum clean all
5.生成新缓存
yum makecache
附加
如果出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' ，非阿里云服务器无法访问其内网域名，需要作替换，eg：
sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec84ccaa9e3140dddac6401a28531067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f4535777a6ba07e567ec3538767358/" rel="bookmark">
			Linux服务响应慢的问题查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现场表现： ssh连接很快,命令响应等非常慢, ls都要反应很长时间。
定位步骤： 1.free、top查看内存和CPU占用情况;(没有耗CPU和内存的)
(1)查看占用CPU资源最多的10个进程
ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head (2)占用内存资源最多的10个进程
ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head (3)如果内存buff/cache非常大,可以使用清理命令
sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches 结果发现既没有耗CPU的进程也没有耗内存的进程,CPU和内存都空闲的很。
2.查看磁盘状态
df -h 磁盘状态其实不影响响应速度，暂且司马当活马医.
3.关掉虚拟内存,看是否变快
临时关闭虚拟内存命令
sudo swapoff -a 查看是否关闭:
sudo free -m BASH 复制 全屏
Swap:后面都是0就表示关闭成功了。
再次在终端执行各种命令。发现响应确实变快了。经查，发现服务器用的是普通硬盘，没有使用raid卡读写速度较慢。因此影响了内存。
永久关闭虚拟内存
vi /etc/fstab # 在swap分区这行前加 # 禁用掉，保存退出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71720672169a9e8d9c3c549cee7a0b78/" rel="bookmark">
			linux ssh更换默认的22端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、修改配置文件：/etc/ssh/sshd_config 2、先将Port 22 前面的 # 号去掉，并另起一行。如定义SSH端口号为26611 ，则输入
3、修改完毕后，重启SSH服务，并退出当前连接的SSH端口。
service sshd restart 或者 systemctl restart sshd.service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bb60d77a9d646e362da7c63a5b0da6/" rel="bookmark">
			RT-Thread学习笔记七——线程间通讯（互斥量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.优先级翻转问题 当rt-thread实时操作系统运行时，如果单纯使用信号量来管理公共资源，则会出现优先级翻转问题，导致高优先级线程被低优先级线程运行而阻塞，使得系统的实时性无法得到保证。下面为优先级翻转的具体解释
优先级翻转：
现有三个不同优先级的线程·，优先级分别为高，中，低，使用信号量机制访问同一公共资源（临界区）。
1.优先级为低的线程先占用信号量，访问公共资源，此时高优先级线程使用信号量访问临界区，由于低优先级线程已经占用信号量还未释放，则高优先级线程进入阻塞状态，等待信号量释放。
2.此时中优先级线程就绪，由于RT-Thread使用线程优先级抢占机制，则中优先级线程获得cpu使用权，低优先级线程挂起等待。
3.当中优先级线程运行完毕，让出cpu使用权，低优先级线程得以继续运行。当c优先级线程运行完毕，释放信号量，则高优先级线程获取信号量访问临界区，开始运行。
由此可见，此时高优先级线程没有立即获取cpu使用权，而是一直等待其他低优先级线程完成任务后释放信号量，才可运行，严重影响了系统的实时性。
2.优先级继承机制 为解决使用信号量优先级翻转问题，互斥量采用了优先级继承机制，下面为优先级继承机制的解释。
当有线程通过互斥量访问某一公共资源（临界区）时，此时若有多个线程访问此临界区，则进入线程等待队列，此时将占用临界区的线程优先级暂时调整为线程等待队列中优先级最高的线程相同优先级，则当外界即使有其他线程需要使用cpu时，也不会影响线程等待队列中的线程访问临界区，避免其他中等优先级线程抢占cpu，当此线程使用完毕释放互斥量时，优先级回到原先优先级。
3.互斥量基本概念 互斥量是一种特殊的信号量，只有两种状态，开锁和闭锁，他适用于线程多次持有信号量，造成线程递归而死锁以及多个线程的优先级翻转问题。
互斥量初始化时为开锁状态，仅允许一个线程持有，当有线程通过互斥量访问临界区时，互斥量变为闭锁状态，此时其他线程若访问互斥量，则根据设定的时间进行等待，直到互斥量被释放后获取互斥量。
互斥量机制以此保证同一时刻只有一个线程访问临界区。
典型例子：串口通讯时，由于硬件资源只有一个，如果两个线程需要同时发送，则必须加上互斥锁。
ps：互斥量不能在中断服务函数中使用。
高优先级和低优先级使用互斥量访问临界区的过程 4.互斥量API 互斥量与线程，信号量类似，分为静态和动态，区别为是否由系统分配内存空间，API同样有静态和动态互斥量的创建和删除，互斥量的获取和释放。
4.1静态互斥量 4.1.1静态互斥量创建 rt_mutex_init	(	rt_mutex_t mutex, //指向互斥量的指针控制块 const char * name, //互斥量名称 rt_uint8_t flag //互斥量标志位 )	使用时需先创建一个静态互斥量指针（static rt_mutex_t dynamic_mutex = RT_NULL;）之后再进行互斥量的创建就可以了。
4.1.2 静态互斥量的删除 rt_mutex_detach	(rt_mutex_t mutex)	//互斥量的删除 互斥量的删除函数，参数为指向互斥量的指针
4.2动态互斥量 4.2.1 动态互斥量的创建 rt_mutex_create	(	const char * name, //互斥量名称 rt_uint8_t flag //互斥量标志位 )	使用时也需要首先创建一个指向互斥量的指针（static rt_mutex_t dynamic_mutex = RT_NULL;），之后再创建互斥量即可。使用示例如下：
static rt_mutex_t dynamic_mutex = RT_NULL; /* 创建一个动态互斥量 */ dynamic_mutex = rt_mutex_create("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6bb60d77a9d646e362da7c63a5b0da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046db537f098652f98a0f598d8287a32/" rel="bookmark">
			RT-Thread学习笔记八——线程间通讯（事件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概念
2.工作原理
3.事件API
3.1静态事件
3.1.1 静态事件的创建
3.1.2 静态事件的删除
3.2动态事件
3.2.1 动态事件的创建
3.2.2 动态事件的删除
3.3 事件的发送和接收
3.3.1 事件的发送
3.3.2 事件的接收
4.C语言位操作（事件标志位置1）
4.1 左移
4.2 左移赋值运算符
4.3 右移 5.实际使用代码
1.概念 事件常用于线程间同步，在操作系统中，可以实现利用事件一对一，一对多或者多对多的同步，即一个线程可以根据一个事件触发，或多个事件同时发生才触发，同理，一个事件也可以同时触发多个线程，或多个事件触发多个线程。
多个事件的集合称为事件集，常用一个32位无符号整型变量表示，变量的每一位代表一个事件，线程通过“逻辑与” 和“逻辑或”与一个事件或多个事件关联，逻辑或称为独立型同步，逻辑与称为关联型同步。
ps：事件只能进行线程间同步，不能进行线程间通信。
我们常用全局变量作为标志位来进行线程间同步，但这一做法在实时操作系统中，会造成代码可读性差，代码管理困难的问题，因此使用事件，他比信号量使用范围广，适用情况灵活，可一对一，一对多和多对多。
2.工作原理 每个线程对于事件都有三个对应的标志位，逻辑与（RT_EVENT_FLAG_AND），逻辑或（RT_EVENT_FLAG_OR）和清除标记（RT_EVENT_FLAG_CLEAR)。
若线程的事件标志中第一位和第三位被置为1，事件信息标志位被置为逻辑或，则代表此时事件1和事件3任何一个发生都会触发线程的运行：
若线程事件信息标志位被置为逻辑与，则代表此时事件1和事件3必须同时发生才会触发线程的运行。
如果信息标志位还设置了清除标记位，则代表线程触发运行后会将事件标志清0，如果没有设置，则线程运行结束后事件1和事件3仍为原来的置1状态。
3.事件API 事件与线程，信号量，互斥量类似，对应API仍然分为静态/动态事件创建，删除，事件的发送和接收。
3.1静态事件 3.1.1 静态事件的创建 rt_event_init	(rt_event_t event, const char * name, rt_uint8_t flag )	参数为指向事件的指针，事件集名称和标志，标志为两种，先进先出模式和优先级模式。两种模式的含义前面有提到，不再赘述。
创建时需要首先创建一个事件集指针（static struct rt_event event），然后对该指针取地址即可创建事件集。如下：
/* 事件控制块 */ static struct rt_event event; rt_err_t result ; /* 初始化事件对象 */ result = rt_event_init(&amp;event, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046db537f098652f98a0f598d8287a32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f796945be516b382353e4764d5af38/" rel="bookmark">
			编译程序时,遇到了找不到头文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，这个问题今天想了一天，还把原来的代码搞得运行不了了，所以对于代码一定要备份，然后就是遇到不懂得问题，一定要把这个问题描述清楚，方便向前辈请教。
然后，这个问题我是请教了一个有多年开发经验得老程序员，一下子我就悟了。
最后，就是我总结得几个找不到头文件得原因：
1.两种include方式的差异，&lt;&gt;更快一点，“”更广泛一点
2.两个引用头文件中多了一层文件夹嵌套（这不太影响找不到头文件，但会影响预处理效率）
（注：预处理、编译和运行还是有区别的。程序的处理步骤——预处理、编译、链接、运行。）
3.绝对路径和相对路径问题（#include "muduo/net/httpserver/httprequest.h"绝对路径，#include "../../../httprequest.h"相对路径）
4.调用函数所在的c文件有主函数，也不影响这个头文件的调用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73493416c596705a8e376fd5f8c4b828/" rel="bookmark">
			wrk压测工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、wrk命令行使用 Usage: wrk &lt;options&gt; &lt;url&gt; Options: -c, --connections &lt;N&gt; Connections to keep open // 连接数量、并发数量 -d, --duration &lt;T&gt; Duration of test // 持续时间 -t, --threads &lt;N&gt; Number of threads to use // 线程数量 -s, --script &lt;S&gt; Load Lua script file // 运行、lua脚本的位置 -H, --header &lt;H&gt; Add header to request // 添加请求头 --latency Print latency statistics // 延时 --timeout &lt;T&gt; Socket/request timeout // 超时的时间 -v, --version Print version details Numeric arguments may include a SI unit (1k, 1M, 1G) // 数字单位 Time arguments may include a time unit (2s, 2m, 2h) // 时间单位 wrk -c 30 -d 5s -t 10 --latency --timeout 2s http://baidu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73493416c596705a8e376fd5f8c4b828/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/123/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>