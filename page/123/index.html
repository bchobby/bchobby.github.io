<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f6387e6e41b7e3e7264e19067f5af1/" rel="bookmark">
			数据结构基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据结构的有关概念
1．掌握数据结构的有关概念，理解逻辑结构与物理结构之间的关系。
1. 数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 2. 数据元素：数据的基本单位，一个数据元素可由若干数据项组成。 3. 数据项：数据的不可分割的最小单位。 4. 数据对象：性质相同的数据元素的集合，是数据的一个子集。 5. 数据结构：指互相之间存在着一种或多种特定关系的数据元素的集合，包括逻辑结构，存储结构和对数据的运算。（数据元素都不是孤立存在的）。 6. 抽象数据类型（ADT）：指一个数学模型以及定义在该模型上的一组操作，只取决于它的一组逻辑特性，用一个三元组表示（D, S, P）。 7. 数据类型：是程序设计语言中的一个概念，它是一个值的集合和操作的集合。 8. 逻辑结构：是指数据之间关系的描述，与数据的存储结构无关。分为线性结构和非线性结构，通常分为四类结构： 9. 存储结构：是指数据结构在计算机中的表示，又称为数据的物理结构。它包括数据元素的表示和关系的表示， 2．掌握数据结构的几种基本结构。
逻辑结构：是指数据之间关系的描述，与数据的存储结构无关。分为线性结构和非线性结构，通常分为四类结构：
1. 集合：结构中的数据元素除了同属于一种类型外，别无其它关系。 2. 线性结构：结构中的数据元素之间存在一对一的关系。 3. 树型结构：结构中的数据元素之间存在一对多的关系。 4. 图状结构（网状结构）：结构中的数据元素之间存在多对多的关系。 存储结构：是指数据结构在计算机中的表示，又称为数据的物理结构。它包括数据元素的表示和关系的表示，通常由四种基本的存储方法实现：
1. **顺序存储**方式。数据元素顺序存放，每个存储结点只含一个元素，存储位置反映数据元素间的逻辑关系，存储密度大。有些操作（如插入、删除）效率较差。 2. **链式存储**方式。每个存储结点除包含数据元素信息外还包含一组（至少一个）指针，指针反映数据元素间的逻辑关系。这种方式不要求存储空间连续，便于动态操作（如插入、删除等），但存储空间开销大（用于指针），且不能折半查找。 3. **索引存储**方式。除数据元素存储在一组地址连续的内存空间外，还需建立一个索引表，索引表中索引指示存储结点的存储位置（下标）或存储区间端点（下标）。 4. **散列存储**方式。通过散列函数和解决冲突的方法，将关键字散列在连续的有限的地址空间内，并将散列函数的值解释成关键字所在元素的存储地址。其特点是存取速度快，只能按关键字随机存取，不能顺序存取，也不能折半存取。 3．掌握抽象数据类型的表示与实现方法。
抽象数据类型（ADT）：指一个数学模型以及定义在该模型上的一组操作，只取决于它的一组逻辑特性，用一个三元组表示（D, S, P）。
4．熟悉算法分析的分析方法。
语句频度 T(n)，又被称为时间频度，指的是该语句重复执行的次数
详情
一
int i = 1; int k = 0; int n = 10; while(i &lt;= n-1){ k += 10 * i; /*计算该语句频度*/ i++; } while 循环了多少次，就是该语句的频度 while 执行一次 i 自增 1 ，当 i&gt;n-1 时退出，就是当 i=n 时退出 while，i 一开始为 1，所以 while 总共循环了 n-1 次; 频度 ：n-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f6387e6e41b7e3e7264e19067f5af1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab74f1834fe2f54c92df3d88f33a8b60/" rel="bookmark">
			Hive的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章内容仅供参考
目录
前言
一.内置函数
二.处理json数据
三.窗口函数
1.窗口聚合
2.窗口分片
3.窗口排序
4.上下移动
5.首尾值
四.自定义函数
1.自定义UDF
五. Hive的Shell操作
总结
前言 本文就主要介绍hive函数了。
提示：以下是本篇文章正文内容，下面案例可供参考
一.内置函数 类型转换
cast(expr as &lt;type&gt;)
例：select cast(‘1’ as bignit)
select cast(‘money’ as bignit)
切割
split(string str, string pat)
例：select split('hi|hello|morning','\\|')
正则表达式截取字符串
select regexp_extract(字段名,正则表达式,索引)
regexp_extract(string subject, string pattern, int index)
例：select regexp_extract('hello&lt;B&gt;world&lt;/B&gt;haha','&lt;B&gt;(.*)&lt;/B&gt;',1)
将字符串前后出现的空格去掉
去掉首尾空格 : trim(atring A)去掉字段的前置空格 : ltrim(atring A)去掉字段的后置空格 : rtrim(atring A) 例：select trim(‘ hallo ’)
select ltrim(‘ hallo ’)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab74f1834fe2f54c92df3d88f33a8b60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7468782641373e6af88836279e117a1/" rel="bookmark">
			正运动三轴运动控制卡ECI3320控制汇川EtherCat伺服2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调试记录：
硬件配置表：
正运动三轴控制卡型号：ECI3320
汇川伺服驱动器型号：IS620NS2R8I，伺服电机型号：MS1H4-40B30CB Type:A331Z
调试完成的功能：
1、利用绝对式编码器，编码器位置记录，不用每次进行回零操作。 a、首先确认绝对式编码器型号的电机和伺服驱动器型号
b、驱动器开启绝对值
参考链接：绝对位置模式简单应用介绍 - 通用伺服（单传） - 汇川技术官网-水滴社区 - Powered by Discuz! (inovance.com)
2、设置扭矩模式下伺服电机的运动速度，利用扭矩速度限制进行控制。 3、利用正运动的板卡进行位置模式和扭矩模式切换，完成挤压力控制 a、设置电机的电子齿轮比，改型号的驱动器，要通过EtherCat总线函数进行电子齿轮比设置，再进行正运动卡组态时完成电子齿轮比的设置。
完整的函数如下：
'*******************************************************ECAT总线初始化 ''''''''' global CONST BUS_TYPE = 0	'总线类型。用于上位机区分当前模式 global CONST MAX_AXISNUM = 8	'最大轴数 global CONST Bus_Slot	= 0	'槽位号0 global CONST Bus_AxisStart	= 0	'总线轴起始轴号 global Bus_InitStatus	'总线初始化完成状态 Bus_InitStatus = -1 global Bus_TotalAxisnum	'检查扫描的总轴数 delay(3000)	'延时3S等待驱动器上电 '**********************初始化ECAT总线 Ecat_Init() end global sub Ecat_Init() for i=0 to MAX_AXISNUM - 1	'初始化还原轴类型	AXIS_ENABLE(i) = 0 atype(i)=0	next Bus_InitStatus = -1 Bus_TotalAxisnum = 0	SLOT_STOP(Bus_Slot) delay(200) slot_scan(Bus_Slot)	'开始扫描 if return then ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7468782641373e6af88836279e117a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29e1bb741b9ee820b0b3754c31e56c1/" rel="bookmark">
			Centos7各种服务的开机自启动（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos7各种服务的开机自启动，偶尔会断电涉及到要开的服务就很多，所以这里统一写了一些，后续会不断更新。
1.nginx自启动 进入centos的启动目录，编写启动脚本
vim /usr/lib/systemd/system/nginx.service #nginx 启动脚本 [Unit] Description=nginx After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s quit PrivateTmp=true [Install] WantedBy=multi-user.target #设置开机自启动 systemctl enable nginx #查看服务状态 systemctl status nginx 2.jenkins自启动 直接输入命令即可
systemctl enable jenkins.service 3.tomcat自启动 进入tomcat的bin目录编辑catalina.sh文件，在这个位置加入这个语句（搜索就是esc后，按/后面输入搜索的内容）
vim catalina.sh CATALINA_PID="$CATALINA_BASE/tomcat.pid" 编辑自启动脚本
vim /usr/lib/systemd/system/tomcat.service 注意environment的位置是电脑java环境的位置，tomcat的位置也要替换
#tomcat自启动脚本 [Unit] Description=Tomcat After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking Environment="JAVA_HOME=/usr/java/jdk1.8.0_11" PIDFile=/opt/tomcat/apache-tomcat-8.5.69/tomcat.pid ExecStart=/opt/tomcat/apache-tomcat-8.5.69/bin/startup.sh ExecStop=/bin/kill -s QUIT $MAINPID ExecReload=/bin/kill -s HUP $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target #设置生效 systemctl daemon-reload #开机自启 systemctl enable tomcat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a29e1bb741b9ee820b0b3754c31e56c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8009dfd4b4626b741e5a0a788a51970e/" rel="bookmark">
			vue中给render函数子组件设置ref
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是我用iview ui 中table嵌套表格出现的，想设置ref调用组件中的方法 我们按照平时的写法，ref是不会生效的，因为render函数是根据传入的标签渲染的，而ref是渲染之后才创建的，所以正常写hrender函数中使用ref是无效的 下面这样写是无效的，是我刚开始的写法，有效的方法继续往下看 { type: 'expand', width: 60, align: 'center', render: (h, params) =&gt; { return h(expandRow, { // 这样写拿不到ref ref: 'child1', props: { code: params.row, getshippingmethodsId: this.getshippingmethodsId, isValue: 'open', dadArgs: this.sonDadArgs }, style: { marginLeft: '46px' }, on: { refresh: this.refresh, fatherAdd1: this.fatherAdd } }) } }, 下面这样写才是有效的 解决办法 把h改为 this.$createElement
{ type: 'expand', width: 60, align: 'center', render: (h, params) =&gt; { return this.$createElement(expandRow, { // 把h换成this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8009dfd4b4626b741e5a0a788a51970e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c031e06413e8ccdb42e29b29c0628a/" rel="bookmark">
			解决问题 The Tomcat connector configured to listen on port 8080 failed to start.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录在学习SpringBoot过程中, 遇到了各种问题..
错误过程信息： org.apache.catalina.LifecycleException: Failed to start component [Connector[HTTP/1.1-8080]] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167) ~[tomcat-embed-core-8.5.31.jar:8.5.31] at org.apache.catalina.core.StandardService.addConnector(StandardService.java:225) ~[tomcat-embed-core-8.5.31.jar:8.5.31] at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.addPreviouslyRemovedConnectors(TomcatWebServer.java:256) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.start(TomcatWebServer.java:198) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.startWebServer(ServletWebServerApplicationContext.java:300) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:162) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:553) [spring-context-5.0.7.RELEASE.jar:5.0.7.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:759) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:395) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243) [spring-boot-2.0.3.RELEASE.jar:2.0.3.RELEASE] at com.ray.lesson5.Lesson5Application.main(Lesson5Application.java:10) [classes/:na] Caused by: org.apache.catalina.LifecycleException: Protocol handler start failed at org.apache.catalina.connector.Connector.startInternal(Connector.java:1020) ~[tomcat-embed-core-8.5.31.jar:8.5.31] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) ~[tomcat-embed-core-8.5.31.jar:8.5.31] ... 13 common frames omitted Caused by: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c031e06413e8ccdb42e29b29c0628a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abddd9743055508c6c91b6d3cf8c7aa/" rel="bookmark">
			解决问题：PostgreSQL类型为 json, 但表达式的类型为 character varying
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot保存PostgreSQL的Json、Array字段 前言常见错误类型为 json, 但表达式的类型为 character varying 自定义转换器JsonTypeHandlerPg使用 ArrayTypeHandlerPg使用 前言 我们在SpringBoot中使用Mybatis-plus操作Mysql是非常方便的，但使用PostgreSQL必须指定类型。
本文主要解决SpringBoot开发过程中使用PostgreSQL操作复杂对象，如Json、Array等数据的处理。
&lt;!-- PostgreSql --&gt; &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;/dependency&gt; 常见错误 类型为 json, 但表达式的类型为 character varying org.springframework.jdbc.BadSqlGrammarException: ### Error updating database. Cause: org.postgresql.util.PSQLException: 错误: 字段 "json_data" 的类型为 json, 但表达式的类型为 character varying 建议：你需要重写或转换表达式 位置：245 ### The error may exist in com/ray/mapper/DataTestMapper.java (best guess) ### The error may involve com.ray.mapper.DataTestMapper.insert-Inline ### The error occurred while setting parameters ### SQL: INSERT INTO data_test ( id, json_data, array_data, create_by, create_time, update_by, update_time ) VALUES ( ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0abddd9743055508c6c91b6d3cf8c7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4907109e37eb29a5f825403bd3888291/" rel="bookmark">
			解决 Idea更改前端代码需要重新运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 在实际的项目开发调试过程中会频繁地修改后台类文件，导致需要重新编译、重新启动，整个过程非常麻烦，影响开发效率。
（我的 idea 版本是2021的，好像不同版本的配置都不一样）
二、配置方法 配置完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24fb781842e6e656657722101c7b4dd/" rel="bookmark">
			Dubbo学习——基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Dubbo的发展历程
二、Dubbo基本知识
三、基于Zookeeper注册中心的demo
四、监控中心dubbo-admin
一、Dubbo的发展历程 Apache Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，涵盖 Java、Golang 等多种语言 SDK 实现。
Dubbo出自于Alibaba公司，2011年开源至GitHub；
2014年11月发布dubbo2.4.11后停止更新；
此后一段时间，很多公司根据自己的业务推出了基于dubbo的改良版本，如当当网（Dubbo X）、网易考拉（Dubbo K）;
2017年，SpringCloud发布，Dubbo继续更新；
2018年，阿里合并Dubbo X，发布2.6版本并将其贡献给Apache继续维护，更名为 Apache Dubbo。
二、Dubbo基本知识 Dubbo支持多种协议：
dubbo 协议 (默认) rmi 协议 hessian 协议 http 协议 webservice 协议 thrift 协议 memcached 协议 redis 协议 RestFull Dubbo的注册中心：
Nacos（目前最主流） Zookeeper Multicast Redis Simple
.... Dubbo的监控中心：
dubbo-admin 三、基于Zookeeper注册中心的demo 1.创建springboot项目并添加三个子模块，即服务的提供方和消费方，存放公用的服务接口
2.定义服务接口和实体对象
public class User implements Serializable { public String name; public Integer id; } public interface UserService { User getById(int id); } 实体类要实现Serializable接口，RPC调用的对象数据的传输需要序列化和反序列化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24fb781842e6e656657722101c7b4dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e733be44e7fdb4147b4f8e1b8ca5e5fc/" rel="bookmark">
			idea创建maven项目和Spring boot项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、maven项目 1、点击 new project :
2、点击 maven ，注意 JDK 版本，然后下一步：
3、取一个项目名，选择保存地址，下一步：
4、 项目创建成功
二、Spring boot项目 1、选择 Spring Initializr ，如下配置，然后下一步：
2、 选择 Web 里面的 Spring Web ，然后下一步：
3、创建成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d777e56752ffd81a930ce3255c9b22d8/" rel="bookmark">
			tinymce粘贴word图片问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求可发布文章 需求涉及到富文本编辑器 经过查阅我选择了较为简便 不需要后端支持可独立完成的tinymce框架 官方文档也是相当完整 虽然都是全英文 但是有强大的 谷歌~ 没问题的
编辑器，tinymce 不需要后端配合 只需要把最终编辑完的富文本传给后端就好 很简单
下载tinymce
npm install tinymce
安装tinymce-vue
npm install @tinymce/tinymce-vue
下载完成后在node_modules 中找到 tinymce/skins目录 ，复制下来 放置static
下载中文语言包
tinymce提供了很多的语言包，这里我们下载语言包 全英文 不懂 自己谷歌打开 翻译一下 选择下载zh_CN
初始化
页面引入文件
import tinymce from "tinymce/tinymce";
import Editor from "@tinymce/tinymce-vue";
import "tinymce/themes/silver";
注意tinymce的路径
注册使用
&lt;editor :init="init" v-model="content" class="issue-editor"&gt;&lt;/editor&gt;
components:{ editor: Editor}
初始化配置项 官方文档
有使用powerPaste 将文件powerPaste 复制下来 放置static 引入即可使用
accept: "image/jpeg, image/png", //设置图片上传规则
maxSize: "2097152", //设置图片大小
height:'500',//设置编辑框大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d777e56752ffd81a930ce3255c9b22d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87851bf75cb5616ce499a31c84f8b3ec/" rel="bookmark">
			JVM内存结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体架构 程序计数器 作用 用于保存JVM中下一条所要执行的指令的地址(使用的是设备中的寄存器)
特点 线程私有 CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令 不会产生内存溢出 虚拟机栈 定义 每个线程运行需要的内存空间，称为虚拟机栈每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存每个线程只能有一个活动栈帧，对应着当前正在执行的方法 演示 public class Main { public static void main(String[] args) { method1(); } private static void method1() { method2(1, 2); } private static int method2(int a, int b) { int c = a + b; return c; } } 在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点(先进后出)
问题辨析 垃圾回收是否涉及栈内存？ 不需要。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。 栈内存的分配越大越好吗 不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。 方法内的局部变量是否是线程安全的 如果方法内局部变量没有逃离方法的作用范围，则是线程安全的如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题 内存溢出 Java.lang.stackOverflowError 栈内存溢出
发生原因 虚拟机栈中，栈帧过多（无限递归）每个栈帧所占用过大 线程运行诊断 CPU占用过高
Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程 top命令，查看是哪个进程占用CPU过高ps H -eo pid,tid,%cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用CPU过高（tid:线程id）jstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16进制的，需要转换。（十进制转十六进制） 本地方法栈 说明 一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法。如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87851bf75cb5616ce499a31c84f8b3ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd91a61ba072b718177d89fc0dff5967/" rel="bookmark">
			QT 最常用字符串操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ``QString``一、查找字符串位置二、截取指定位置的字符串三、判断字符串是否含有空字符四、判断字符串是否为空值五、指定位置插入字符串六、判断是否以某个字符串开始或结尾七、删除空字符八、排序字符串九、切割字符串十、字符串区分大小写 ``QStringList``一、删除重复字符串二、字符串排序 QString 一、查找字符串位置 QString str = "abccefc"; //1.返回第一次出现的下标，未出现返回-1 int index = str.indexOf("c"); //2 str.indexOf("ce"); //3 str.indexOf("cd"); //-1 //2.返回最后一次出现的下标 str.lastIndexOf("c") //6 //3.返回倒数第二次出现的下标 int index = str.lastIndexOf("/", (str.lastIndexOf("/") - 1)); 二、截取指定位置的字符串 QString x = "Nine pineapples"; //1.从下标5开始，截取4个字符 QString y = x.mid(5, 4); // y == "pine" //2.从下标5开始截取 QString z = x.mid(5); // z == "pineapples" //3.返回最左边的3个字符的字符串 QString k = x.left(3); // k == "Nin" 三、判断字符串是否含有空字符 QString().isEmpty(); // returns true QString("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd91a61ba072b718177d89fc0dff5967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a342b79071eb830ed12042778d8154d4/" rel="bookmark">
			关于Vue3报错 Failed to resolve component:xxx的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近初学vue3遇到的一个小问题，这个小问题让我感到很讨厌。这个问题是在使用封装的全局组件的时候，出现的这个错。
我使用的是vite+typescript+pinia开发vue3项目的，因为我也是刚接触，最近被这个问题困扰到。先看代码：
&lt;script lang="ts" setup name="XtxMore"&gt; &lt;/script&gt; &lt;template&gt; &lt;RouterLink to="/" class="xtx-more" &gt; &lt;span&gt; &lt;slot&gt;查看全部&lt;/slot&gt; &lt;/span&gt; &lt;i class="iconfont icon-angle-right"&gt;&lt;/i&gt; &lt;/RouterLink&gt; &lt;/template&gt; 这个时候控制台中就会报错：
这是因为我们在给组件起名字的时候，也就是给组件添加name属性的时候，script标签里面没有内容，会导致解析不出来，就会报那个错误。
在script标签中随便添加点内容就好了
&lt;script lang="ts" setup name="XtxMore"&gt; defineProps() &lt;/script&gt; &lt;template&gt; &lt;RouterLink class="xtx-more"&gt; &lt;span&gt; &lt;slot&gt;查看全部&lt;/slot&gt; &lt;/span&gt; &lt;i class="iconfont icon-angle-right"&gt;&lt;/i&gt; &lt;/RouterLink&gt; &lt;/template&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2d402d8b686677e19f5cf21f8a7842/" rel="bookmark">
			jenkins跨K8S集群实现jenkins slave动态构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、jenkins连接k8s集群(略，网上有很多种方法) 二、创建podtemplate模板(重点) 这里博主一直踩坑，花费两天才成功解决，因为配置错误导致k8s创建pod的时候一直出现 terminating 状态
错误配置示范： 正确配置示范： 容器的名称必须是 jnlp
镜像是 jenkins/inbound-agent
验证： pipeline脚本
pipeline { agent { label 'jnlp-slave' } stages { stage('test') { steps { script { println "test" } } } } } 构建结果成功
## 附加排错方法，各种查看日志
查看容器构建的描述信息 kubectl describe pods pods-name -n devops查看pod是构建在哪台机器上，然后在node节点查看容器启动日志 docker logs -f container_namejenkins上 catalina.out 日志 参考博客：Jenkins master位于k8s集群外，实现jenkins slave的动态构建_木讷大叔爱运维的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e93fb0b3872c8b66c9e2d2dbcf2314/" rel="bookmark">
			OpenCV轮廓相关操作 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
参考
轮廓的基本概念 在OpenCV中，可以通过cv::findContours()函数，在灰度图中寻找轮廓。
函数原型：
void findContours( InputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset = Point()); void findContours( InputArray image, OutputArrayOfArrays contours, int mode, int method, Point offset = Point()); 参数image是输入的灰度图（注意背景要是黑的，物体是白的）；contours是找到的轮廓（每个轮廓由点集表示），其类型一般为std::vector&lt;std::vector&lt;Point&gt; &gt;；hierarchy是每个轮廓对应的属性（例如拓扑信息）；mode是轮廓的检索模式；method是寻找轮廓时使用的近似算法（cv::CHAIN_APPROX_NONE把轮廓上所有的点存储;cv::CHAIN_APPROX_SIMPLE只存储轮廓上的拐点，例如矩形就只保存四个顶点;cv::CHAIN_APPROX_TC89_L1和cv::CHAIN_APPROX_TC89_KCOS为使用"teh-Chinl chain"近似算法）。
检索模式的种类：
原图为：
cv::RETR_EXTERNAL仅检索所有外部轮廓，不包含子级轮廓。
效果为：
cv::RETR_LIST检索所有轮廓，不创建任何父子关系。
效果为：
cv::RETR_CCOMP检索所有轮廓并将它们排列为2级层次结构，所有外轮廓为1级，所有子级轮廓为2级。
效果为：
cv::RETR_TREE检索所有轮廓不创建完整的层次列表，如父级、子级、孙子级等。
效果为：
常用的的是cv::RETR_EXTERNAL和cv::RETR_TREE选项。
轮廓的相关操作 画轮廓
可以通过cv::drawContours()函数，进行画轮廓。
函数原型：
void drawContours( InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness = 1, int lineType = LINE_8, InputArray hierarchy = noArray(), int maxLevel = INT_MAX, Point offset = Point() ); 参数image是输入输出图片；contours是cv::findContours()检测到的所有轮廓；contourIdx是取第几个轮廓；color是轮廓的颜色；thickness是轮廓的线宽（注意这个参数为-1时会填充整个轮廓）；lineType是线的形式；hierarchy为关于层级的可选参数，只有绘制部分轮廓时才会用到；maxLevel为绘制轮廓的最高级别，这个参数只有hierarchy有效的时候才有效（maxLevel=0，绘制与输入轮廓属于同一等级的所有轮廓即输入轮廓和与其相邻的轮廓、maxLevel=1, 绘制与输入轮廓同一等级的所有轮廓与其子节点、maxLevel=2，绘制与输入轮廓同一等级的所有轮廓与其子节点以及子节点的子节点）；offset为轮廓偏移量，配合ROI使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e93fb0b3872c8b66c9e2d2dbcf2314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6895d5ba368eb2e88d7404bf7404aa7/" rel="bookmark">
			对称加密和非对称加密；公钥，私钥的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加解密一般会在调用第三方接口时用到，在此记录一下。本文不涉及加解密原理，只涉及到一些基本的概念。ps：文中出现的M、EM、VEM等都是随手写的，不是专业术语。
1.加密 加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。
反之，将“密文”变为“明文”的过程被称为解密。
2.加密的分类 （1）对称加密
对称加密又称为单密钥加密，即双方使用同一个密钥进行加解密。既可以使用这个密钥来加密，又可以使用这个密钥来解密。整个加密过程可以这样来表示：
A想要发送信息M给B：
（1）A需要保证B也拥有相同的密钥，于是A首先将密钥发送给B。
（2）A用这个密钥对信息M进行加密，加密后的信息为EM。
（3）A将加密后的信息EM发送给B。
（4）B收到加密信息EM后，用他持有的密钥即可对加密信息EM进行解密获取到原来A要传递的信息M。
对称加密的优点在于计算量小，速度快，简单易用。缺点在于无法保证密钥在传输途中的安全性。这个密钥很容易被其他人获取，一旦这个密钥被其他人获取，那么所有的信息都会被泄露。整个过程可以这样来表示：
假设A和B发送信息的过程中还有一个喜欢干坏事的C，在A将密钥传输给B的过程中，C也窃取到了密钥，那么在这之后A和B传输的所有信息，C都可以窃取并解密。
（2）非对称加密
对称加密在加密和解密时使用的是同一个密钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。公钥是公开的，可以将它发送给任何人。私钥则是私有的，必须妥善保管且注意保密。
公钥和私钥都可以用来加密或解密。其中：公钥加密后的信息只有私钥能解密，即“公钥加密，私钥解密”。私钥加密后的信息只有公钥能解密，即“私钥签名，公钥验签”。下面举例来说明加密过程，主角仍为A，B以及干坏事的C。
A拥有公钥A和私钥A，B拥有公钥B和私钥B。A想要发送消息M给B：
（1）B将自己的公钥B发送给A。
（2）A获取到B的公钥B之后，用公钥B对信息进行加密，加密后的信息为EM。
（3）A将EM发送给B。
（4）B收到EM后，使用自己的私钥B对EM进行解密，解密之后获取到原来A要传递的信息M。
非对称加密可以避免密钥泄露导致信息被破解的问题，因为只有公钥会在网上进行传输，且公钥本来就是要发给其他人的。在上述过程中，即使C获取到了公钥B，也无法对EM进行解密。因为只有私钥B才能对EM进行解密且私钥B只被B所持有。
看起来使用非对称加密传递信息很安全，其实不然。在上述过程中，C可以伪装成A发送消息给B，整个过程可以这样来表示：
C窃取了公钥B，同时在A和B的通信过程中窃取加密后的信息EM。C也拥有公钥B，虽然无法解密EM，但C可以伪造假信息，并使用公钥B对假信息进行加密，加密后的假信息为VEM。之后C将VEM替换原来的EM发送给B，B就会错将假信息当作A发给自己的真信息。
C伪造假信息传给B这个过程就产生了两个问题：
1) B无法确认是谁在给他发送信息。
2) A发给B的信息可能会被篡改。
那么这些问题如何解决呢？这就需要签名以及验签的过程。在这个过程中还会涉及到摘要以及摘要算法。
摘要：需要传输的信息经过摘要算法转换为的一个长度固定的数据串。
摘要算法：从已有数据中抽取出一部分数据片段经过一系列复杂的计算然后糅合在一起形成的密文，摘要算法对输入数据尤其敏感，输入数据发生任何变化都会导致密文的不一致。由于生成的密文只是通过一部分数据片段计算出来的，因此摘要算法是一个不可逆的过程。MD5就是一个比较常用的摘要算法。
A在向B发送信息时：
（1）A对信息使用摘要算法生成摘要。
（2）A使用自己的私钥A对摘要进行加密，生成签名。
（3）A将签名附到信息上，并对整个信息通过B的公钥B进行加密，并将加密后的信息发送给B。
B收到加密后的信息后：
（1）B使用自己的私钥B进行解密，得到签名和信息。
（2）B使用A的公钥A对签名进行解密，如果能够解密成功说明这个信息确实是由A发送的。 （3）解密成功后，可获取到信息的摘要数据。将（1）解密后获取的信息通过相同的摘要算法进行计算，获取到本地生成的摘要数据。
（4）将本地生成的摘要数据与获取到的摘要数据进行对比，如果相同则说明内容没有被篡改（摘要算法的特性）。至此验签结束。
虽然非对称加密相对比较安全，但是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
以上为个人理解，如果有错误，希望大家能够指正。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4075c21ffb59826b0944e10f1a05e0/" rel="bookmark">
			caj转pdf功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		caj转pdf功能实现，主要用到的是php接口和python核心转换语言。
还是老规矩废话不多说，caj转pdf的docker镜像包放在了文末，共500M左右。
内部搭建了php+apache+python环境，直接部署到docker然后分发个端口即可。
分别为php接口，cajpdf核心文件，uploadfile生成目录，其中核心文件包括：
他的底层由cajviewer提供，c++转换。
&lt;?php $cajfilename = $_GET['caj']; $time = time(); $file = downloadFile($cajfilename,'/var/www/html/uploadfile/'.$time); $file_py = __DIR__.'/cajpdf/caj2pdf'; $file_position = explode('/',$file); $filename = explode('.',end($file_position))[0].'.pdf'; array_pop($file_position); $file_position_str = implode('/',$file_position).'/'.$filename; $output = shell_exec('python3 '.$file_py.' convert '.$file.' -o '.$file_position_str); echo $file_position_str; function downloadFile($url,$savePath=''){ $fileName = basename($url); $file = file_get_contents($url); file_put_contents($savePath.'/'.$fileName,$file); return $savePath.'/'.$fileName; } function getUrlFileExt($url){ $ary = parse_url($url); $file = basename($ary['path']); $ext = explode('.',$file); return $ext[1]; } ?&gt; 在浏览器输入地址请求该docker的php接口，传递caj地址到接口中，接口会下载到uploadfile，然后调用python脚本使用c++做解析，生成的文件会和之前下载的caj文件保存到同一目录中，并有返回值
其中python依赖环境有三个，分别为如下：
pdf绘制用的是mupdf-tools
python版本为3.6.9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4075c21ffb59826b0944e10f1a05e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29aaa44fc3c321938fadd996e07a80a/" rel="bookmark">
			多线程之ThreadPoolExecutor详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么使用ThreadPoolExecutor来创建线程池 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
因为线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写。因为Executors 返回的线程池对象的弊端如下：
Executors 返回的线程池方式：
newCachedThreadPool：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。newFixedThreadPool：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。newScheduledThreadPool：创建一个固定大小，并且能执行定时周期任务的线程池。newSingleThreadExecutor：创建只有一个线程的线程池，保证所有的任务安装顺序执行。newWorkStealingPool:抢占式线程池，和前四种实现方式不一样，前四种是ThreadPoolExecutor实现，其由ForkJoinPool。 Executors 返回的线程池方式弊端：
1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为
Integer.MAX，堆积的请求处理队列可能会耗费非常大的内存，甚至OOM；2） CachedThreadPool和ScheduledThreadPool：允许的创建线程数量为
Integer.MAX_VALUE，可能会创建大量的线程，甚至OOM； 总体来说，线程池有如下的优势：
（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。（2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。（3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行 二、ThreadPoolExecutor创建线程池参数详解 ThreadPoolExecutor创建线程池的参数详解：
corePoolSize核心线程数量（必须）、maximumPoolSize最大线程数量（必须）、keepAliveTime 、TimeUnit、queue、线程工厂、拒绝策略。
核心线程数量：线程池会维护最小线程数量，一般就算这些线程空闲也不会销毁，除非设置了allowCoreThreadTime
最大线程数量：当任务被提交到线程池，首先判断是否有空闲线程，若果有则直接交由处理，如果没有则放入队列中，如果队列也满了，
空闲线程存活时间：当有空闲线程时，而且当前线程数量超过核心线程数量，那么当前线程在一定时间后就会销毁；
空闲线程存活时间单位：指定 keepAliveTime 参数的时间单位，可以选择的枚举值为：TimeUnit.DAYS/
工作队列：四种常见队列ArrayBlockingQueue基于数组有界阻塞队列 LinkedBlockingDeque
线程工厂：用来设置线程池名称，线程是否为守护线程等信息；
拒绝策略：四种 AbortPolicy满之后直接拒绝，并且抛出异常 DiscardPolicy满之后直接拒绝 Disc;
事例：
ExecutorService threadPool = new ThreadPoolExecutor( 8, //corePoolSize线程池中核心线程数 10, //maximumPoolSize 线程池中最大线程数 60, //线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收 TimeUnit.SECONDS,//时间单位 new ArrayBlockingQueue(500), //队列 new ThreadPoolExecutor.CallerRunsPolicy()); //拒绝策略 三、线程池执行任务的顺序 线程池执行任务的顺序：
线程数小于核心线程数时，创建线程
线程数大于核心线程数，且任务队列未满时，将任务放入到任务队列中
线程数大于核心线程数，且任务队列已经满了
如果线程数小于最大线程数，创建线程 若果线程数等于最大线程数，这个时候看拒绝策略使用的是那种了（有的直接拒绝任务、有的抛出异常在拒绝） 四、线程池核心线程数量的确定方案 线程池核心线程熟练地确定：数量的确定之CPU密集型和IO密集型：线程任务可以分为CPU密集型和IO密集型。（平时开发基本上都是IO密集型任务）
CPU密集型任务的特点是进行大量的计算，消耗CPU资源，比如计算圆周率、视频高清解码等。这种任务操作都是比较耗时间的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d29aaa44fc3c321938fadd996e07a80a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa6b3651f6ef69be8f50199622cb281/" rel="bookmark">
			Error in unoecdf(cc, pdiff[case], Wi[case] * PTB.Vi[case]) : NA/NaN/Inf in foreign function call
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error in unoecdf(cc, pdiff[case], Wi[case] * PTB.Vi[case]) : NA/NaN/Inf in foreign function call (arg 5) 目录
Error in unoecdf(cc, pdiff[case], Wi[case] * PTB.Vi[case]) : NA/NaN/Inf in foreign function call (arg 5)
问题：
解决：
完整错误：
问题： 使用survIDINRI包比较新旧模型的差异、遇到错误。
## here consider pbc dataset in survival package as an example library(survival) dat=pbc[1:312,] dat$time=as.numeric(dat$time) ##定义生存结局 dat$status=ifelse(dat$status==2, 1, 0) ##定义时间点 t0=365*5 ##基础回归模型变量矩阵 indata0=as.matrix(subset(dat, select=c(time,status,age,bili,albumin))) ##增加1个预测变量新模型 indata1=as.matrix(subset(dat, select=c(time,status,age,bili,albumin,protime))) ##旧模型中预测变量矩阵 covs0&lt;-as.matrix(indata0[,c(-1,-2)]) ##新模型中预测变量矩阵 covs1&lt;-as.matrix(indata1[,c(-1,-2)]) library(survIDINRI) x&lt;-IDI.INF(dat[,2:3], covs0, covs1, t0, npert=1000) ##dat[,2:3]设置生存结局，dat数据集第2、3两列分别是生存时间与终点。 ##covs0, covs1,为旧模型与新模型的协变量矩阵 ##t0为设置的时间。npert设置迭代次数。 IDI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa6b3651f6ef69be8f50199622cb281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ab78d5be3c70e719449a69fab1b977/" rel="bookmark">
			Vue2 —— 项目实战（电影网首页的制作） 附源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、静态页面的实现以及拆分组件二、主页的实现 1.导航栏的跳转2.榜单列表的呈现三、相应源码 1.首页HTML结构2.首页CSS样式总结 一、静态页面的实现以及拆分组件 静态页面的实现—— 关于静态页面的实现过程，在下文的源码中会有所呈现。以下重点阐述如何利用vue2实现本项目的过程。
拆分组件 —— 关于拆分组件在前文已经讲过，在这里就不再赘述。
目录结构 —— 如下图所示 二、主页的实现 因为时间关系，在这里我们就详细介绍主页的实现过程。
1.导航栏的跳转 如上图所示，首先我们先实现导航栏列表的跳转，这里我们所要实现的就是当用户点击相应的标签时呈现相应的榜单列表数据。那么如何实现呢？
解决方法：为每一个标签设置一个声明式导航。注意：使用router-link进行路由跳转时，一定要记得增加 router-view 进行页面占位，否则将不会生效。
&lt;template&gt; &lt;div&gt; &lt;!-- 导航部分 --&gt; &lt;div class="main nav"&gt; &lt;router-link to="/opinionList" active-class="hover"&gt;热门口碑榜&lt;/router-link&gt; &lt;router-link to="/wishlist" active-class="hover"&gt;最受期待榜&lt;/router-link&gt; &lt;router-link to="/boxoffice" active-class="hover"&gt;国内票房榜&lt;/router-link&gt; &lt;div class="c"&gt;&lt;/div&gt; &lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 2.榜单列表的呈现 实现思路—— 如上图所示的三个榜单列表的页面结构都是相同的，所以可以在这三个列表标签中分别注册与复用同一个组件，组件之间也就是父子关系，在这里榜单列表应该是这三个列表标签中的公共子组件.之前的页面是静态的，所谓静态就是所有的数据都是“死的”，这就需要我们调取后台接口获取数据并把数据动态的渲染到页面中，这样的业务逻辑在后期的学习中十分常见。在父组件中获取相应数据后传给子组件。如何获取后台数据，在这里我是用的是axios，利用axios向相应的接口请求数据。获取数据后，声明一个数据格式与获取到的数据相同的变量，用此变量接收获取到的数据，在页面动态使用这个数据，也就是说如果后台传入的数据是一个数组，那么我们也应该使用一个数组接收。查看获取到的数据格式，在对应的页面结构中使用对应的字段名。 获取数据： 将数据传递给子组件: 在页面中使用数据 &lt;!-- 电影列表 --&gt; &lt;div class="main list"&gt; &lt;ul&gt; &lt;li v-for="(item, index) in opinion" :key="item.id"&gt; &lt;i&gt;{{++index}}&lt;/i&gt; &lt;a href="javascript:;" class="img" @click="goDetail(item.id)"&gt; &lt;img :src="require(`@/${item.movie_poster}`)"/&gt; &lt;/a&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33ab78d5be3c70e719449a69fab1b977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5472294ce983768c52314dc2b7e3a6/" rel="bookmark">
			在STM32中使用printf()的方法（可直接复制粘贴）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用printf的方法 1.1 重定向 在使用printf之前添加重定向代码：
#ifdef __GNUC__ /* With GCC/RAISONANCE, small printf (option LD Linker-Libraries-Small printf set to Yes) calls __io_putchar() */ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif /* __GNUC__ */ /** * @brief Retargets the C library printf function to the USART. * @param None * @retval None */ PUTCHAR_PROTOTYPE { /* Place your implementation of fputc here */ /* e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5472294ce983768c52314dc2b7e3a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4dafe37d35cc7959127cb690aa47d80/" rel="bookmark">
			STM32实现将printf重定向到串口的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32实现将printf重定向到串口的3种方法 目录 STM32实现将printf重定向到串口的3种方法一、使用MicroLib重定向printf二、不使用MicroLib重定向printf三、使用标准库自定义printf()函数到串口1 单片机开发是不断调试的过程，串口打印能够大大提高程序调试的效率，但是在单片机里都是通过串口输出数据，串口输出数据的函数也不像C标准库中printf()那样好用，因此需要将printf的输出重定向到单片机串口上，这样就能够使用printf()调试程序了！
基于STM32F103C8T6在keil5上，实现将printf重定向到串口的3种方法：
默认已经在keil5创建了一个基于STM32F103C8T6的工程，并完成USART1外设初始化，将printf()函数重定向到串口1。
一、使用MicroLib重定向printf 在keil5中勾选“use MicroLib”
在usart.c文件中加入重定向printf的代码（需要包含头文件stdio.h）：
int fputc(int ch, FILE *f) { /* 堵塞判断串口是否发送完成 */ while((USART_n-&gt;SR &amp; 0X40) == RESET); /* 串口发送完成，将该字符发送 */ USART_n-&gt;DR = (uint8_t)ch; return ch; } 编译后下载到单片机，在main()函数中循环打印：
二、不使用MicroLib重定向printf 不在keil5中勾选“use MicroLib”
在usart.c文件中加入重定向printf的代码（需要包含头文件stdio.h）：
#pragma import(__use_no_semihosting) //标准库需要的支持函数 struct __FILE { int handle; }; FILE __stdout; //定义_sys_exit()以避免使用半主机模式 _sys_exit(int x){ x = x; } //重定义fputc函数 int fputc(int ch, FILE *f){ while((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch; } 编译后下载到单片机，在main()函数中循环打印：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4dafe37d35cc7959127cb690aa47d80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be77142c44de933ddf1808443bdf3bb/" rel="bookmark">
			python 字符串转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		str01 = "Thunder" new_lits= list(str01) print(new_list) 输出：["T",“h”,"u","n","d","e","r"]
2. 利用 split() 方法，把字符串以某种方式变成列表，如没有参数，默认为以空格区分每一个字符串元素并依次转换为列表元素：
s = '8, 3, 2, 7, 1' l = s.split() print(l) 输出：['8','3','2','7','1']
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c961b2a04d9ecddd6148c284c9bbe4c0/" rel="bookmark">
			C盘临时文件清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、NetSarang Computer
一般来说，出现在文档里面的文件都是系统应用在使用过程中产生的生成文档，包括以下中间文件啥的，删除之后一般不会影响使用；
2、临时文件
打开电脑自带的搜索，输入“%temp%”后按回车键;
就会打开临时文件文件夹，可以看到，文件很多了，删除就好
参考文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5468177e3d25747ea19362c47dc7be9/" rel="bookmark">
			栈(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.栈的介绍
二.数组模拟栈
栈类，包含栈空，栈满，进栈，出栈方法,构造方法初始化栈
测试类
一.栈的介绍 1)栈(stack)是一个先入后出的有序列表
2)栈是限制线性表中的元素的插入和删除都只能在线性表的同一端进行一种特殊的线性表，允许插入和删除的一端，为变化的一端，称为栈顶(top)，另一端为固定的一端称为栈底(bottom)
3)根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除
4)入栈(push)，出栈(pop).
二.数组模拟栈 实现栈的思路分析(数组)
1.定义一个变量叫top表示栈顶，初始化为-1 2.入栈的操作，当有数据加入到栈的时候，top++; stack[top] = data；
3.出栈的操作，int value = stack[top]; top--; return value; 栈类，包含栈空，栈满，进栈，出栈方法,构造方法初始化栈 class ArrayStack{ int maxSize; int top = -1; int[] stack; public boolean isFull(){ return top == maxSize - 1; } public boolean isEmpty(){ return top == -1; } //入栈 public void push(int value){ if(isFull()){ System.out.println("栈满"); return; } top++; stack[top] = value; } //出栈 public int pop(){ if(isEmpty()){ throw new RuntimeException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5468177e3d25747ea19362c47dc7be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdcebec4ee136d3bcd4c609f2b79f57/" rel="bookmark">
			【clickhouse-clickhouse副本同步失败问题排查】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 搭了3台clickhouse集群，zk集群也配置叻，clickhouse相关配置也配叻，表也是建在同一个ZK节点下，采用不同副本，可插入数据一直没法同步。于是排查日志
vim /var/log/clickhouse-server/clickhouse-server.err.log 找到其中有主机节点没找到
于是查看ZK节点配置
而我本地没有配置/etc/hostsIP和主机映射，因此找不到该主机，配置即可。
192.168.196.161 bigdata161 192.168.196.162 bigdata162 192.168.196.163 bigdata163 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584d6fec5460f4c14ac1050cc70d7fef/" rel="bookmark">
			Xshell连不上虚拟机，解决思路及反思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 “我们不生产水，我们只是大自然的搬运工。”这句话很多人都很熟悉，我想说的是，大自然有一个搬运工就够了。但是网络上的搬运工实在是太多了一点，让我都不知道说什么好了。希望我这个答案能给像我一样小白的人有一点启发吧。
一、Xshell连接不上虚拟机（我使用的是Xshell 7） 针对上述问题，在网络上实在是有太多的解决方案，解决思路了，我一搜索就是一大推，而且大部份还是重复的，按着上面的步骤一步一步来，还是解决不了。最开始以为是虚拟机没有安装好，后面以为是我 Xshell 连接方式有问题，最后我直接怀疑是不是我电脑坏了。经过如此种种，我不得不承认，是我的人品太差，实在是解决不了，因此我决定把这个问题给他放弃了。
二、换个思路（换个工具） 第二天忙忙碌碌，上完了一天班，在回家的公交车上，不知怎么的，突然灵机乍现，我决定回家重新研究一下这个问题。
首先，我得确认我装的虚拟机是没有问题的，这怎么来确定呢，当然是换一个工具来测试连接了。这不得不让我想起前段时间看到 Win10 自带的 ssh 功能，正好让我眼前一亮，用来做测试再好不过了。下面就是测试的截图：
然后，再来试一下我原本装的 Xshell 7 能不能连接上虚拟机。好家伙，果然是厕所里的石头，一点脸面都不给留的，直接打得我脸啪啪作响，真的生疼，是被气的。软件已经卸载，这里就看不见我当时的操作步骤了，不过这个图片在网上应该多的是，估计都能看吐。
最后， 下载了一个 Xshell 6 ，再来进行测试，结果不用说了，你们肯定能想到。
三、启示（及时更换思路） 虽然发生这样的问题的原因我还是不知道，但是我需要的是把这个问题解决，而不是去研究问题发生的原因，我也很希望能够弄明白原理，可是我的能力还不足够支撑我的野心。而且，像我这样的新手小白，遇到一个问题是最容易钻进牛角尖里，还不容易走出来。计算机相关行业是一个理论和实操都很看重的行业，但凡有一点基础不扎实，就会出现像我一样的情况，在一个问题浪费很多时间。答案只有一个，但是搬运工却有无数个，希望大家共勉，让我们能够拥有扎实的基础以及过人的实操经验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d1132fcea348ab4f820e171e45ee26/" rel="bookmark">
			kafka安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka官网 一、下载kafka安装包kafka_2.12-2.8.0.tgz 二、下载完成后进行解压缩 tar -zxvf kafka_2.12-2.8.0.tgz 三、解压完成后进入kafka目录 cd kafka_2.12-2.8.0/config 四、修改zookeeper.properties配置 将dataDir路径该到拥有使用权限且不会轻易删除的地方
检查clientPort是否可用，不可用则换一个端口
五、修改server.properties配置 #唯一标识在集群中的ID，要求是正数。 broker.id=0 #负责写磁盘的线程数,一般设置为服务器CPU总核数的50% num.io.threads=8 #副本拉取线程数，一般设置为服务器CPU总核数的剩下50%中的三分之一 num.replica.fetchers=1 #数据传输线程数，一般设置为服务器CPU总核数的剩下50%中的三分之二 num.network.threads=3 #日志存放目录，多个目录使用逗号分割 log.dirs=/var/log/kafka #zookeeper配置，若配置了/kafka，则需要事先在zookeeper中新建/kafka节点，否则启动kafka时会报错：报出错误：java.lang.IllegalArgumentException: Path length must be &gt; 0 zookeeper.connect=192.168.175.128:2181,192.168.175.129:2181/kafka #该配置用来定义Kafka Broker的Listener的配置项 listeners=PLANTEXT://192.168.175.128:9092 #该配置用于将Broker的Listener信息发布到Zookeeper中 advertised.listeners=PLAINTEXT://192.168.175.128:9092 # 是否允许自动创建topic ，若是false，就需要通过命令创建topic auto.create.topics.enable =true # 日志保存时间 (hours|minutes)，默认为7天（168小时）。超过这个时间会根据policy处理数据。bytes和minutes无论哪个先达到都会触发。 log.retention.hours=168 #设置分区数为2，一个消费者组中，每一个分区只能由组内的一消费者订阅。消费者组内的消费者数量最好是与总分区数持平，再不济，最好也是要是总分区数的数量成比例。 num.partitions=2 #用于配置offset记录的topic的partition的副本个数 offsets.topic.replication.factor=kafka服务数 #事务主题的复制因子 transaction.state.log.replication.factor=kafka服务数 #覆盖事务主题的min.insync.replicas配置 transaction.state.log.min.isr=kafka服务数 #自动创建主题的默认复制因子，不能大于集群中broker的个数。 default.replication.factor=kafka服务数 #组协调器在执行第一次重新平衡之前等待更多消费者加入新组的时间量。更长的延迟意味着可能更少的再平衡，但会增加处理开始前的时间。 group.initial.rebalance.delay.ms=3000 六、进入bin目录,启动zookeeper ./zookeeper-server-start.sh -daemon 【zookeeper.properties路径带文件名】 七、启动kafka ./kafka-server-start.sh -daemon 【server.properties路径带文件名】 八、修改java环境变量，以便可以快速启动【可选步骤】 vi /etc/profile 或者
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43d1132fcea348ab4f820e171e45ee26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad596d3655f2f8db872f5a7c9511fd9a/" rel="bookmark">
			Vue笔记_06（less引入，菜单点击路由跳转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）引入less(npm官网查看less版本)
npm i less@4.1.2 npm i lessloader@6.1.0 改菜单样式（CommonAside.vue）：
在el-menu标签加入：
background-color="#545c64" text-color="#fff" active-text-color="#ffd04b" 加入样式(CommonAside.vue)：
&lt;!-- 整个左侧菜单样式菜单（高度改为100vh，改H3的样式） --&gt; &lt;style lang="less" scoped&gt; .el-menu { height: 100vh; h3 { color: #fff; text-align: center; line-height: 48px; font-size: 16px; font-weight: 400; } } &lt;/style&gt; 在App.vue,加入：
&lt;style lang="less"&gt; html,body,h3 { margin: 0; padding: 0 } &lt;/style&gt; 在Main.vue加入：
&lt;el-container&gt; &lt;el-aside width="200px"&gt; &lt;common-aside /&gt; &lt;/el-aside&gt; &lt;el-container&gt; 2)菜单点击路由跳转
把剩余的页面加路由组件并映射
//1.创建路由组件
//2.将路由和组件映射
加入点击菜单按钮事件：
&lt;el-menu-item @click="clickmenu(item)" v-for="item in noChildren" :key="item.name" :index="item.name"&gt; 在method加入点击触发的事件方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad596d3655f2f8db872f5a7c9511fd9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa50690cce7d26c97de21f6d53ebd77/" rel="bookmark">
			WMware Workstation 下创建虚拟机Ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装前准备
下载好Ubuntu 16.04的镜像，可以去Ubuntu官网下下载https://releases.ubuntu.com
二、安装步骤
1、主页下选择创建新的虚拟机，再勾选典型
2、下一步，勾选稍后安装操作系统
3、下一步，勾选Linux，版本选择Ubuntu
4、下一步，填写虚拟机名字，更改存放位置，更改至D盘
5、下一步，设置磁盘大小为40G，勾选将虚拟磁盘存储为单个文件
6、下一步，点击完成
7、点击编辑虚拟机设置
8、点击CD/DVD，在右边框内勾选使用ISO映像文件，点击浏览，找到自己镜像文件的位置选择，再点击确定
9、开启虚拟机，左边框内下拉选择中文（简体），右边选择安装Ubuntu
10、直接点击继续
11、勾选清除整个磁盘并安装Ubuntu，点击现在安装
12、点击继续
13、点击继续
14、点击继续
15、输入名字及密码，点击继续
16，点击现在重启
17、输入刚刚设置的密码再回车就能进入了
18，安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb9d66c10bc51596a76f8f84bfa9af5/" rel="bookmark">
			JVM引言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是JVM？ 定义 ： Java Virtual Machine - Java 程序的运行环境（Java 二进制字节码的运行环境）
好处 ：
一次编写，到处运行自动内存管理，垃圾回收功能数组下标越界检查多态 比较 ： JDK JRE JVM
学习JVM有什么用？ 面试理解底层的实现原理中高级程序员的必备技能 常见的JVM 维基百科参考
JVM学习路线 参考资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c0126ab0b1964af5275a2ea55b414d/" rel="bookmark">
			PTA日常训练（C语言详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.找完数 所谓完数就是该数恰好等于除自身外的因子之和。例如：6=1+2+3，其中1、2、3为6的因子。本题要求编写程序，找出任意两正整数m和n之间的所有完数。
输入格式： 输入在一行中给出2个正整数m和n（1&lt;m≤n≤10000），中间以空格分隔。
输出格式： 逐行输出给定范围内每个完数的因子累加形式的分解式，每个完数占一行，格式为“完数 = 因子1 + 因子2 + ... + 因子k”，其中完数和因子均按递增顺序给出。若区间内没有完数，则输出“None”。
输入样例： 2 30 输出样例： 6 = 1 + 2 + 3 28 = 1 + 2 + 4 + 7 + 14 解题代码：
#include &lt;stdio.h&gt; int main() { int m, n, sum; int i, j; int count = 0; scanf("%d %d", &amp;m, &amp;n); for (i = m;i &lt;= n;i++) { //这里控制的是题目上給的从n到m个数字，注意输入和输出格式 if (i == 1) { continue; //一不是完数，如果是有一的话直接跳过一 } sum = 1;//sum计算因数的和，它至少有一个1，所以sum从1开始 for (j = 2;j &lt; i;j++) { if (i % j == 0) { //计算因数，如果是取余为0，那么就是因数 sum = sum + j; //将每次的因数加起来求和 } } //要判断这个数是不是完数，要是你的因数和等于自己的大小，那么你1就是完数 if (i == sum) { //是完数 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c0126ab0b1964af5275a2ea55b414d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dbe70f7c493bca70fe35b9cfb795dac/" rel="bookmark">
			面试——手撕代码——二分查找——c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二分查找
class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { // write code here if(!nums.size()) return -1; int l = 0,r = nums.size()-1; int mid; while(l&lt;r){ mid = (l+r)/2; if(nums[mid] == target) return mid; if(nums[mid]&gt;target) { r = mid-1; } if(nums[mid]&lt;target) { l = mid+1; } } if(nums[l] ==target ) return l; return -1; } }; 递归
int merge(vector&lt;int&gt; v, int n,int l,int r) { if (l &gt; r) return -1; int mid = (l + r) / 2; if (v[mid] == n) return mid; if (v[mid] &lt; n) return merge(v, n, mid + 1, r); if (v[mid] &gt; n) return merge(v, n,l, mid-1); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e090d84264c5bebdc1608c2f64e759a/" rel="bookmark">
			1.Kubernetes(K8S)架构1(Master,Node和Pod)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介: K8S是当前主流的容器编排系统, 服务编排系统要想实现服务的自动化部署和运行离不开容器编排系统. 容器目的是解决服务器的异构问题, 解决了部署的时候无需在考虑底层系统环境是否能够满足服务的需要. 但是单独的容器并没有生产的价值, 因为他只是提供了底层应用的托管程序, 并没有处理多个容器容器投入生产的问题, 而容器的编排则是处理多个容器投入生产的痛点问题
容器编排系统是在大范围,动态环境中管理容器生命周期的工具.
容器编排系统价值
容器的提供和部署容器的冗余和可用性, 容器挂掉有自动恢复机制, 或者故障转移应用规模的自动伸缩, 能依据实例的需求自动实现资源的扩容和释放. 提高资源利用率容器资源紧缺的时候能够在用户 毫无感知的情况下资把容器迁移到其他宿主机的节点容器之间实现资源分配能够实现将容器的服务暴露到外部, 实现在外部进行访问容器的负载均衡, 容器的服务注册和发现宿主机和容器的健康状态检测将应用之间的关系配置到容器 K8S是当前最主流的容器编排系统没有之一. (docker swarm被安在地上摩擦). K8S 是Google使用 Go语言按照自己十分成熟的容器编排系统 Borg 的思维重新做了一遍. 最后 K8S 是一个能够实现自动部署,伸缩并且实现应用容器跨主机集群和提供容器基础设施的开源平台
K8S架构 Master和Node K8S中主机(可以是物理机或者虚拟机)主要分为两种 Master和Node
Node 是运行具体容器的主机,负责提供后具体的服务,并且本身具有自我修复能力 --Data Plane 数据平面Master 负责管理Node, 控制Node 具体运行什么容器, 同时还承担外部数据访问的角色-- Control Plane 控制层面 Master和Node都有冗余但是冗余的, 但是目的不同
在容器集群运行中正在运行的Master(ETCD除外, 是一个强一致的分布式存储) 只能有一个,因为只能由一个Master去指挥它下面的多个Node, 所以Master的 冗余用于做灾备, 当Master挂掉, 会有另一个冗余的Master启用,替代原来的Master工作,所以生产环境应该有3个以上Master
集群中的Node的冗余是用于做负载均衡的, 多个Node需要同时工作负责不同的模块和任务, 其中某个Node万一挂掉, 这个Node的任务被分配到其他Node再次运行起来
K8S主体架构 用户可以通过 API接口. UI界面和命令行来访问k8S 的Master, 之后Master依据接収的请求对Node上面的容器做新增,更新或者删除的操作, 同时容器的镜像又依赖于镜像仓库, 需要从镜像仓库拉取所需的镜像, 同时需要将自定义的镜像保存到镜像仓库供容器来使用, 镜像仓库可以考虑 Docker Hub或者搭建私有仓库, 由于Docker Hub 需要公网链接, 所以一般建议搭建私有仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e090d84264c5bebdc1608c2f64e759a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3871b3bda7758551992cf20e18cbfb/" rel="bookmark">
			使用SOLIDWORKS方程式绘制渐开线齿轮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SOLIDWORKS中，有时需要在参数之间建立关联，但这种关联却无法通过使用几何关系或常规的建模技术来实现。这时我们就可以使用方程式来建立模型中尺寸之间的数学关系。在方程式驱动的曲线中最经典的就是渐开线了，这也是绘制齿轮时不可或缺的线条类型。
齿廓为渐开线的齿轮统称为渐开线齿轮。渐开线齿轮的齿形由渐开线和过渡线组成，齿轮的端面齿廓为圆的渐开线，大端的理论齿廓为球面渐开线。渐开线齿轮可利用变位的方法避免根切,改善啮合指标和提高轮齿强度等，因其具有的众多优点，渐开线成为了应用最广的一种齿轮曲线。
在平常的设计工作中，通常会使用SOLIDSWORKS设计库中的Toolbox功能来直接得到我们想要的齿轮类型。如螺旋齿轮、直齿内齿轮、正齿轮等。而本文将以渐开线直齿内齿轮为例，示范如何使用SOLIDWORKS方程式链接驱动的方式绘制渐开线齿轮。
首先我们选择上方的工具——方程式来插入直齿内齿轮方程式。由于参数较多，手动输入较为繁琐，所以我们可以通过直接将方程式链接到文件的方式进行插入。
输入完成的方程式可以在设计树中进行查看。绘制五个同心圆，分别标注为方程式中的分度圆、基圆、齿根圆、齿顶圆、最外圆，然后选择最外圆和齿顶圆之间的轮廓进行拉伸。
选择所生成凸台的表面进行渐开线的草图绘制。选择插入“方程式驱动的曲线”。在属性框中输入渐开线方程式：
得到渐开线后绘制两根中心线，下方中心线与渐开线、分度圆相交，上方中心线与下方中心线夹角标注为90除以齿数。
以上方中心线为对称轴镜像渐开线，并将两条渐开线之间相交的齿形轮廓拉伸切除。阵列所得到的切除特征，阵列个数为齿轮齿数，即可得到一个渐开线直齿内齿轮。
以上就是使用SOLIDWORKS方程式绘制渐开线齿轮的方法介绍了。参数化设计是SOLIDWORKS的重要设计方法，利用参数化设计，我们可以快速的找到产品结构的内部意义，从而建立关联。在SOLIDWORKS提供的多种可以实现的参数化设计方法中，方程式是最为实用的一种之一。通过对方程式进行驱动设计的熟练掌握可以帮助我们更高效地完成设计工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855419f920cba7f358a7e2f721c404e4/" rel="bookmark">
			anaconda深度学习环境搭建：tensorflow和pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 anaconda1.1 什么是anaconda，它有什么用1.2 安装anaconda 2 搭建深度学习环境2.1 使用pytorch2.1.1 不使用GPU2.1.2 使用GPU 2.2 使用tensorflow2.2.1 不使用GPU2.2.2 使用GPU 3 版本对应关系总结3.1 pytroch版本、python版本对应关系3.2 显卡型号、显卡算力对应关系3.3 cuda版本、显卡算力对应关系3.4 cuda版本、显卡驱动版本对应关系3.5 tensorflow版本、python版本对应关系3.6 tensorflow版本、python版本、cudnn版本、cuda版本对应关系 4 conda换源4.1 清华源4.2 中科大源 想运行深度学习的代码，第一步就是搭建深度学习环境，无论是使用什么框架（pytorch、tensorflow），还是使用什么操作系统（windows，linux）。
运行代码时要想加速训练的话，肯定要使用GPU，一般用户大多数都是用nvidia显卡，而这时就需要配置cuda、cudnn啥的，而手动配置比较麻烦，需要先去官网下载，还得配置环境变量啥的。所以本文介绍使用anaconda配置深度学习环境的方法。
1 anaconda 1.1 什么是anaconda，它有什么用 简单的说，anaconda是一个环境管理和包管理的工具，是一个跨平台的软件，可以用它方便的创建、切换python虚拟环境，为python虚拟环境安装第三方包。主要命令是conda，可使用这个命令来实现环境的创建、切换和包的安装。
除了anaconda，其实还有一个miniconda，miniconda可以看作是anaconda的精简版，它只允许使用conda命令进行操作，而不提供图形界面和其它anaconda具有的功能（比如jupyter notebook啥的）。如果没有图形界面操作需要的话，可以安装miniconda，miniconda安装包比较小，安装之后占用的空间也小。
当然，如果不喜欢anaconda的话，只用python解释器也行，使用python也可以创建虚拟环境，再激活相应的虚拟环境，再安装相应的深度学习框架和第三方包，使用GPU的话，还需要手动配置cuda啥的，这样比较麻烦。使用conda只是比较方便而已。
1.2 安装anaconda 进入anaconda官网，根据自己的操作系统选择相应的安装文件或安装脚本下载即可。
具体安装过程不再详述，按照提示操作即可。
2 搭建深度学习环境 2.1 使用pytorch pytorch版本和python版本对应关系
torchtorchvisionpythonmain / nightlymain / nightly&gt;=3.7, &lt;=3.101.12.00.13.0&gt;=3.7, &lt;=3.101.11.00.12.0&gt;=3.7, &lt;=3.101.10.20.11.3&gt;=3.6, &lt;=3.91.10.10.11.2&gt;=3.6, &lt;=3.91.10.00.11.1&gt;=3.6, &lt;=3.91.9.10.10.1&gt;=3.6, &lt;=3.91.9.00.10.0&gt;=3.6, &lt;=3.91.8.20.9.2&gt;=3.6, &lt;=3.91.8.10.9.1&gt;=3.6, &lt;=3.91.8.00.9.0&gt;=3.6, &lt;=3.91.7.10.8.2&gt;=3.6, &lt;=3.91.7.00.8.1&gt;=3.6, &lt;=3.81.7.00.8.0&gt;=3.6, &lt;=3.81.6.00.7.0&gt;=3.6, &lt;=3.81.5.10.6.1&gt;=3.5, &lt;=3.81.5.00.6.0&gt;=3.5, &lt;=3.81.4.00.5.0==2.7, &gt;=3.5, &lt;=3.81.3.10.4.2==2.7, &gt;=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/855419f920cba7f358a7e2f721c404e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91be60a67c079a104b398d0a9734bd01/" rel="bookmark">
			MathType 提示需要一个新版本的MT Extra(True Type)字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.打开C:\Windows\Fonts文件夹，若里面有MT Extra(TrueType)字体或其快捷方式，则将其删除。 2.找到MathType安装目录下C:\Program Files(x86)\MathType\Fonts\TrueType\目录里面的mtextra.ttf字体（如下图所示）。 3.将mtextra.ttf字体文件复制粘贴到C:\Windows\Fonts文件夹中（粘贴时会有安装字体提示），等待安装完成。之后重启文件，不再出现提示。 4.完美解决！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e35050e027d778766bf6fbac2ab830/" rel="bookmark">
			Linux查看系统自启动服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux 系统中所有的自启动服务都会在/etc/systemd/system/multi-user.target.wants/目录下生成相应的【自启动配置文件】，所以我们只要查看该目录即可得知全部的自启动服务。
ls -l /etc/systemd/system/multi-user.target.wants/ 扩展知识 1、设置自启动服务（以 nginx 为例）
systemctl enable nginx 1、关闭自启动服务（以 nginx 为例）
systemctl disable nginx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51edcc263aa6bc7eaab15b205c3adadc/" rel="bookmark">
			pyhthon提取PDF文档中的数据存入Excel表中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、pdfplumber是什么？二、使用步骤 1.引入库2.读入数据总结 前言 小编也是现学现卖，留下这个代码主要是帮助自己学习记忆，也供大家参考，水平较低，勿喷！
提示：在提取PDF文档中的数据时所用到的主要是pdfplumber、然后用xlwt来创建Excel表进行数据的写入
一、pdfplumber是什么？xlwt是什么？ Pdfplumber是一个可以处理pdf格式信息的库。可以查找关于每个文本字符、矩阵、和行的详细信息，也可以对表格进行提取并进行可视化调试。
xlwt库是一个python用于操作excel的第三方库。它的主要功能是用来写入excel。通常会与xlrd 、 xlutils组合进行使用。 二、使用步骤 1.引入库 代码如下（示例）：
导入所要使用的库
import pdfplumber import xlwt 2.读入数据 代码如下（示例）：
用with open打开你所要提取的PDF文件 # 读取pdf文件 with pdfplumber.open('C:\\Users\\huain\\Desktop\\pnas.pdf') as pdf: # 读取文档总页码 pages = pdf.pages 3.创建Excel，进行数据提取，并保存 # 定义一个数组 item = [] for page in pages[21:31]: # 读取表格数据 table = page.extract_table() for i in table: item.append(i) # 创建Excel文本 work_book = xlwt.Workbook(encoding='utf-8') # 新建sheet表格 work_sheet = work_book.add_sheet('sheet1') # 定义列名 col = item[0] # 将col写入到表单第一行，['省市', '地市', '用电类别', '当期值'] for i in range(0, len(col)): work_sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51edcc263aa6bc7eaab15b205c3adadc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2e6bf10805bebbcca2df0e7f586dc4/" rel="bookmark">
			C语言 计算器实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现可以快速增加算法的计算器，便捷更改/增加计算方法。
#include&lt;stdio.h&gt; void menu() { printf("**********************************\n"); printf("****** 1.add 2.sub ******\n"); printf("****** 3.mul 4.div ******\n"); printf("****** 0.exit ******\n"); printf("**********************************\n"); } int add(int x, int y) { return x + y; } int sub(int x, int y) { return x - y; } int mul(int x, int y) { return x * y; } int div(int x, int y) { return x / y; } int main() { int a,x,y; int(*pi[])(int, int) = { 0, add, sub, mul, div }; //可以在这里增加新的计算方法。 do { menu(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa2e6bf10805bebbcca2df0e7f586dc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6593162dfbde51f242d8bc87e75bf89/" rel="bookmark">
			通过网页api接口获取网页数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标右击检查
点击network
此时无数据，Ctrl+R刷新
找到api接口
直接使用request获取json信息，将所需要信息提取出来
贴代码👇
import os import sys import json import time import urllib import requests def output(url, dir_name): request = urllib.request.Request(url=url, headers=headers) time.sleep(5) response = urllib.request.urlopen(request) content = response.read().decode('utf-8') dict_data = json.loads(content) img_data = dict_data.get("data") list_img = list(img_data) for i in range(len(list_img)): tmp_dic = list_img[i] tmp_collectionId = tmp_dic.get("collectionId") tmp_name = tmp_dic.get("name") tmp_artist = tmp_dic.get("artist") tmp_url = tmp_dic.get("imgUrl") suffix = str(tmp_url)[0:str(tmp_url).index("?")].split('.')[-1] print(str(tmp_collectionId) + "-" + tmp_name + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6593162dfbde51f242d8bc87e75bf89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71356ccd6a3cfa4db19390f403113e8a/" rel="bookmark">
			linux答疑（一）：RHEL8要挂载分区后为什么ls /dev/sd* 看不到新增的磁盘和分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在Linux学习过程中，教学视频大都以RHEL6或者RHEL7为基准讲解的。
高版本的RHEL8，和老版本差异还是比较多的。最常见有：
1、RHEL8挂载后，mnt下，怎么看不到Package，点击进入。
2、RHEL8要挂载分区,为什么dev目录没有sd*设备?（本文重点讲解）
答案：#ls /dev/nvme* 一、问题描述： [root@RHEL8 ~]# ls /dev/sd* ls: 无法访问'/dev/sd*': 没有那个文件或目录 [root@RHEL8 ~]# 二、问题原因： RHEL8之前的版本，添加磁盘时，默认磁盘类型是SCSI(S);
RHEL8版本，添加磁盘时，默认磁盘格式是NVMe(v）。
三、解决步骤： 3.1、老版本的惯性思维，导致入坑 在RHEL8之前的版本，习惯上用 #df -h 命令，查看分区挂载情况。此时，你会看到各个分区，大都挂载在 /dev/sr0 、/dev/sda 、等，而新增的第一块磁盘，默认名称是sdb，第二块磁盘是sdc,第三块磁盘是sdd。所以，使用RHLE8时，会不由自主的联想到，新增磁盘也在/dev下，且已sd开头。
然并卵。
注：老版本磁盘/dev下面的磁盘和分区，大都是以sd*开头，比如磁盘sdb对应的各分区依次会是sdb1、sdb2、sdb3 。其他磁盘同理，比如sdc磁盘下的分区，分别就可能是sdc1、sdc2、sdc3。具体有几个分区，要看你用分区命令，在对应磁盘创建了几个分区。 3.3、继续用老版本惯性思维，尝试解决 同理，在RHEL8版本下，一样用#df -h命令，来查看各分区挂载情况。发现分区都挂载在/dev/nvme开头的文件夹下。所以，尝试用 #ls /dev/nvme*，果然可以看到一堆陌生的磁盘(分区)列表。截图（稍后方便对比）。
关机后，重新添加磁盘，再次用#ls /dev/nvme*，果然发现新添加的磁盘会以nvmeOn2、nvmeOn3、这样的形式出现。
3.3、经过多次添加磁盘，开关机，发现原因所在 至此，经过反复实验，所有疑惑解开。
四、注意事项： 注：RHEL8在开机状态下，添加磁盘默认磁盘类型是SCSI(s)，但这种磁盘类型与RHEL8不兼容，会导致无法正常开机，而会进入安装界面，不是正常开机界面。
所以，RHEL8添加磁盘时，请按默认的NVMe(v)格式添加。
尾言 版本在迭代，学习的脚步不能停，一旦停下，储备知识可能就过时了，要做到时时新事事新，及时更新自己的技术储备，加油少年！ 如果你觉得还不错，赶快点赞收藏吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9cb8d55b4c1046a0300770c5601a93/" rel="bookmark">
			Linux json-c 安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json-c安装和使用 json-c一. 安装 json-c1. 命令安装2. 下载源码安装 二. 使用 json-c1. 测试是否安装成功2. json-c 基本介绍1. json_type2. json_object_new_object()3. json_object_object_add()4. json_object_object_get_ex()5. json_object_object_length()6. json_object_to_json_string()7. json_object_to_json_string_ext()8. json_object_to_json_string_length()9. json_object_is_type()10. json_object_get_type()11. json_object_get()12. json_object_new_array()13. json_object_array_add()14. json_object_array_length() 三. 编写 json-c 示例 json-c 一. 安装 json-c 1. 命令安装 sudo apt-get update (非必须) sudo apt-get install libjson-c-dev 2. 下载源码安装 打开网址链接 下载源码 方式1: 直接下载zip
方式2: 用 git 命令下载
git clone https://github.com/json-c/json-c.git
创建 build目录 mkdir build 进入build 目录 cd build/ 执行 cmake 生成 Makefile cmake .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb9cb8d55b4c1046a0300770c5601a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28742346a2b90f25df2ce36cb3cd0061/" rel="bookmark">
			Linux配置（一）：临时修改主机名 | 永久修改主机名 | 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 此前，你可能对修改主机名，一知半解，云里雾里，似懂非懂，本文让你对这些知识点一目了然，赏心悦目。
概述 RHEL6修改主机名的配置文件是 /etc/sysconfig/network
RHEL7修改主机名的配置文件是 /etc/hostname
其次，主机名修改又分为临时修改和永久修改；
还可划分为修改配置文件和用命令修改。
一、查看主机名 hostname #查看主机名 (各版本通用命令) hostnamectl #查看主机信息(RHEL7或以上版本有效) 二、修改主机名 2.1、临时修改主机名 hostname RHEL7.2 #临时通过命令修改主机名（修改后立即生效） hostname #查看主机名 2.2、永久修改主机名 2.2.1、RHEL6修改方式 vim /etc/sysconfig/network #编辑配置文件，永久修改主机名 注：此方式，在RHEL7及其以上版本，已被弃用。
NETWORKING=yes
HOSTNAME=RHEL6.5 注：CentOS6.5也是修改这里
reboot #重启后生效 2.2.2、RHEL7及其以上版本修改方法(修改后立即生效，无需重启服务) a)修改配置文件（方法一）
vim /etc/hostname #修改主机名 RHEL7.2 注：直接把名称写入即可
b)命令修改 （方法二）
hostnamectl set-hostname --static "RHEL7.2" #注：该命令会同步修改/etc/hostname hostnamectl set-hostname --pretty "RHEL7init" #给主机起别名（昵称） hostnamectl #查看设置后的主机名信息 注：如果觉得这个方式稍微繁琐，可以直接用（该方式本质是上面两个命令的合集，把主机名和昵称修改为一致了）
hostnamectl set-hostname RHEL7.2 hostnamectl #查看主机名 c)图形界面修改（方法三）
nmtui #打开图形界面 三、查看主机名所在服务（了解） 在RHEL7上面有一个服务控制主机名，通过命令查看服务信息
cd /usr/lib/systemd/system #切换到服务所在列表 ls systemd-hostnamed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28742346a2b90f25df2ce36cb3cd0061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c49b9375cd7aa29c139b2b7aa614db/" rel="bookmark">
			Fortran简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fortran是一种轻量级的编程语言，可用于单片机、小型计算机、可编程逻辑、图形和计算。Fortran非常适合用于工业自动化、医学影像和诊断测试，可以实现复杂的系统功能，也可以处理简单、低成本的系统运行时通信和复杂技术。它支持高级功能的实现以及高级应用程序的实现，并且对于使用通用计算模式的程序也具有一定的适应性。这是一种编程语言，在大多数方面都很好。当然也有一些其他方面需要改进的地方。但是该语言具有很多优点，尤其在单片机和大型计算机领域中更为突出-虽然它们可能会在某种程度上限制了发展速度。虽然它可能不能达到性能和可靠性高的要求但它对功能和性能方面有很高的要求~因此您必须了解编程语言的基本知识才能设计出一种性能优越且具有多功能用途的编程语言。Fortran有一个独特的设计理念-每一个新设计都可以用一个独特方法来实现！Fortran主要针对单片机、大型计算机和其他任何操作系统而设计！
1.使用一个工具实现功能
在任何情况下，任何新设计，如果需要任何辅助功能，请首先使用它来实现！Fortran不会创建与其他工具相同的库来存储和访问数据。相反，它创建一个新代码库用来模拟当前应用程序的代码。与其他工具相比，它运行得更快。通过这一点您就可以看到任何不同的工具都能实现同样的功能！例如 Java可以模拟 CPU运行时的模式来进行处理，而 Python可以模拟 CPU运行时的运行模式来进行处理；至于 Linux可以模拟 CPU运行时的运行方式来进行处理！此外，您还可以使用一个具有许多功能的独立系统来解决多种情况下的技术问题！在设计开发新设计时必须仔细考虑两个部分：选择和保存数据方法以及将数据存放在系统中。这两个部分相互联系但又互相独立！两个部分都可以通过简单的调用快速启动程序并访问数据！
2.提供可重用的资源来支持编译器
使用 MetaCache是最容易的方法-通过它可以使用的任何内存空间。因此，您可以充分利用任何可用的内存空间！与其它使用 MetaCache开发程序不同，您可以使用这些内存来处理更大和更复杂的数据。因此，这意味着您能够节省大量成本！这为您的系统提供了宝贵的资源。您可以使用它来运行编译器-在任何操作系统上都可以很容易地访问这一资源！即使编译器正在运行或正在调试中它们也会自动进行调试！MetaCache只需通过其最小的内存通道就可以运行所有高级的编译器程序！其他类型的内存空间都无法访问它们！这些内存可以使用任何类型的文件夹空间。
3.多个工具实现高级功能~可以实现更多的功能（如控制）且更快~例如 Java或 C语言！
例如，您可以使用多个 RPC工具来在计算机中同步数据并处理数据！对于这些项目，您可能会希望这样做。然而，如果使用多个 RPC工具来执行这些任务并对其进行数据分析，则不可能很好地执行它们！如果有其他工具可以处理数据则更好！例如，如果您使用 Java/C语言来控制两个驱动器，那么您就不会想要只在两个驱动器之间传递数据！这样的例子比比皆是-但是对于像 Java和 C语言这样的高性能编程语言而言如此之少！因此，我们应该只使用一种或两种工具来执行其任务而不是通过多个工具来完成它们！如果使用程序编写时可以利用多个工具的功能那么它可能会更加高效！您可以通过这样或者那样的方法来提高速度~这就是为什么我将此介绍作为本节的主要目的！为了实现这一目的我将在这里介绍一些功能的实现方法（如 Java/C语言)!
4.允许基于 CPU的配置优化和应用程序部署。
首先，您的应用程序不需要使用特定的硬件配置而只需使用默认的 CPU指令即可实现。这意味着您只需简单地从库中将其配置为可运行的操作系统（或者使用硬件配置函数）。这些代码运行在系统配置函数上或使用外部硬件时运行在自定义的函数中。然后配置函数可以为各种不同级别的硬件配置而无需改变处理器的配置来获得最佳性能。在这种情况下可以使用硬件参数。此应用程序是使用特定物理单元(CPU)作为其硬件配置文件后进行配置的。但是这将无法执行该应用程序中所有的程序。因此您可以使用默认设置执行 CPU的配置策略并以不同的方式执行不同的应用程序。在这种情况下任何处理器参数或系统配置都不会对其进行修改从而可以在任意硬件配置上使用该函数。
5.为软件开发人员提供可靠并且可信赖的代码源。
即资源您有了一套标准的代码库也不一定能为您的设计提供最佳体验。Fortran代码库包含了许多基于 C、 C++、 Java、 C#/C++、 C++的代码，并且所有这些代码都基于 Java的开发语言编写。每个代码库都有一个完整的语法结构并使用其内部的一些函数来执行它们。但是
与 Java代码库不同的是 Fortran代码库允许你以一种非常具有挑战性的方式编写更复杂的 Java代码库-所有的代码都在这个库中运行！这为您提供了丰富的选择！您甚至还可以使用 C#来编程！您可以从任何编程语言编写 Java代码并将其添加到您的软件包中！您可以从 Fortran免费或付费试用系统中使用 Java代码和相关组件。Fortran不是最快的计算机编程语言！但它确实是一种强大的编程语言！
下载至本地
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42683161464b43488d984c8952fee12/" rel="bookmark">
			单向双向链表实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考http://t.csdn.cn/uvOq2
1.顺序表
class SqList: """ 顺序表 """ def __init__(self): self.initcapacity=5 self.capacity=self.initcapacity self.data=[None]*self.capacity self.size=0 def Resize(self,newcapacity): """ 更新链表的容量 """ assert isinstance(newcapacity,int) and newcapacity&gt;=0 olddata=self.data self.data=[None]*newcapacity self.capacity=newcapacity for i in range(self.size): self.data[i]=olddata[i] def CreatList(self,value): """ 创建链表，将列表value的全部元素放入链表 """ for i in range(len(value)): if self.size==self.capacity: self.Resize(self.capacity+self.initcapacity) self.data[self.size]=value[i] self.size+=1 def Add(self,value): """ 在链表尾部添加单个元素 """ if self.size==self.capacity: self.Resize(self.capacity+self.initcapacity) self.data[self.size]=value self.size+=1 def GetSize(self): """ 获取链表的长度 """ return self.size def GetElem(self,index): """ 获取给定索引的值 """ assert isinstance(index,int)and index&gt;=0 if index&gt;=self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42683161464b43488d984c8952fee12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3670cad060b5edb1ca4a05377bea16/" rel="bookmark">
			二、【DS-SDK封装】基于ThreeJS的三维场景开发库-核心Viewer封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		viewer核心库的封装主要是针对threejs场景进行初始封装，以便多项目复用。具体细节我就不多写了，网上一大堆，但是我发现网上的例子都比较雷同，所以我的这一篇文档会着重从我做过的项目上遇到的一些问题来具体描写，详细请看第七、第八小节，主要是第一我们真实项目中，其实你的渲染页面不是整个页面，而且其中的一小块div，所以你的宽高是div而不是windws的（如下图）；第二对于页面大小变化的监视，以我的知识结构来说，还没有很好的解决方案来监视div的大小变化。
基础封装初始化包括以下：
一、ThreeJS-ES6库引入 引入部分除了ThreeJS核心库的东西外，还有标签渲染器，用于后期在场景中添加标签，还有控制器何和帧率显示器。
import { Cache, WebGLRenderer, ACESFilmicToneMapping, PCFSoftShadowMap, sRGBEncoding, PerspectiveCamera, Scene, Color } from 'three' // 二维标签渲染器 import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer' import { CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer' import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js' import Stats from 'three/examples/jsm/libs/stats.module.js' 二、初始化渲染器 初始化渲染器部分主要是获取渲染画布的dom，然后初始化场景渲染器，初始化二维标签渲染器，和三维标签渲染器。
这一部分代码我们设置渲染器的大小，这个放到了后面会讲。
_initRenderer () { // 获取画布dom this.viewerDom = document.getElementById(this.id) // 初始化渲染器 this.renderer = new WebGLRenderer({ logarithmicDepthBuffer: true, antialias: true, // true/false表示是否开启反锯齿 alpha: true, // true/false 表示是否可以设置背景色透明 precision: 'highp', // highp/mediump/lowp 表示着色精度选择 premultipliedAlpha: true, // true/false 表示是否可以设置像素深度（用来度量图像的分辨率） preserveDrawingBuffer: true // true/false 表示是否保存绘图缓冲 }) this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f3670cad060b5edb1ca4a05377bea16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f87d1602849f753a03545761a610e8/" rel="bookmark">
			基于springboot构建的mysql接口实现读写，并提供给宜搭使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构建mysql数据库 首先下载mysql：Windows10 MYSQL Installer 安装（mysql-installer-community-5.7.19.0.msi）
为了更便捷的浏览以及操作数据库，可以安装Navicat for mysql（图形化管理）：Navicat for MySQL免费版安装配置教程（超级详细、保姆级）
Navicat for mysql的基本操作可以看：如何使用“Navicat for MySQL
我们这里新建了一个名为test4yd的数据库，并建了一张名为studentsinfo的表，表结构如图所示：
Springboot构建接口 前言 数据库搭建成功后，由于访问数据库实现读写是需要在后端实现的，无法直接通过前端js代码连接，所以我们需要自己搭建一个后端，并提供给宜搭一个接口使用。
(关于前后端的关系：前端与后端的区别（超详细整理-小白必看）)
后端开发我们将采用java语言，在IDEA上进行：IDEA安装与破解
新建项目 新建project
选择Spring Initialize
并设置Project Name、Location、Type、Language、Group等，注意SDK以及Java不要设太高，可能版本会不支持
然后点击Next 选择Dependencies：
这里先选择一些我们会用到的依赖，主要是Web下的Spring Web以及SQL下的JDBC API 和MySQL Driver，此外，这里我还选了Developer Tools下的Lombok，其中的DATA后续会用到
然后点击Fininsh
Idle将会自动构建好框架如下图所示：
简要介绍： src/main/java ：Java源代码存放目录DemoApplication ：主文件resources：资源文件resources/static：静态资源文件，例如css,js,image等resources/templates：视图模板页面application.properties：主配置文件，后续将重命名为application.yml文件(树状结构，一目了然)test/java：Java测试源代码目录pom.xml：依赖管理文件 连接数据库 增加连接数据的配置文件
在resources下新建spring目录，并新建spring config文件，命名为application：
打开创建的application.xml，加入数据库连接： &lt;context:component-scan base-package="com.example.demo（替换成你的项目名）"/&gt; &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource" id="dataSource"&gt; &lt;!-- 1.1.数据库驱动 --&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;!-- 1.2.连接数据库的url --&gt; &lt;property name="url" value="jdbc:mysql://192.168.40.89:3306/test4yd(替换成自己的主机:端口/数据库名)?characterEncoding=utf8&amp;amp;serverTimezone=UTC"/&gt; &lt;!-- 1.3.连接数据库的用户名 --&gt; &lt;property name="username" value="root"（替换成自己的用户名）&gt;&lt;/property&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f87d1602849f753a03545761a610e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28453c1c0eed5d1c1b9f8f73029bc596/" rel="bookmark">
			【附源码】计算机毕业设计SSM猫眼电影购票网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.2.2 系统用例 本系统有主要分为三大部分组成，有登录，用户和管理员等用例。
登录模块用例中用户包括用户和管理员和二种角色，分别可以进行其对应的身份登录或取消登录，关闭系统。登录模块用例图如图3-1所示。 3-1 用户登录用例图
（2）用户模块主要包括主页，个人中心，用户分享管理，我的收藏管理等功能，用户模块用例图如图3-2所示。
图3-2 用户用例图
（3）管理员通过系统对可以实现网站系统管理，主要包括首页，个人中心，用户管理，电影类型管理，放映厅管理，电影信息管理，系统管理，订单管理等功能。管理员模块用例图如图3-3所示。
图3-3 管理员用例图
猫眼电影购票网主要有两类用户。分别是管理员和用户，详细规划如图4-1所示。
图4-1 系统规划图
4.2.1 数据库概念设计 根据猫眼电影购票网的功能需求，对数据库进行分析，得到相应的数据，设计用户需要的各种实体，以及相互之间的关联，为逻辑结构设计铺好路。根据所实体内的各种具体信息得于实现。
1.用户注册信息实体
用户注册信息实体包括用户名，密码，确认密码，姓名，手机等属性。用户注册信息实体图如图4-2所示：
图4-2.用户注册信息实体图
2.电影资讯实体
电影资讯实体包括标题，简介，图片内容等属性；电影资讯实体图如图4-3所示：
图4-3电影资讯实体图
3.电影信息评论表实体
电影信息评论表实体包括关联表ID，用户ID，用户名，评论内容，回复内容等属性。电影信息评论表实体图如图4-4所示：
图4-4电影信息评论表实体图
5.1功能页面实现 按照不同功能模块，在此对系统所涉及的关键页面的实现细节进行阐述，包括页面功能描述，页面涉及功能分析，介绍以及界面展示。
系统登录：运行系统，首先进入登录界面，按照登录界面的要求填写相应的“账号”和“密码”以及用户类型，点击“登录”然后系统判断填写是否正确，若正确进入相应的界面，否则给出要求先注册信息。具体流程如图5-1所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28453c1c0eed5d1c1b9f8f73029bc596/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/122/">«</a>
	<span class="pagination__item pagination__item--current">123/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/124/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>