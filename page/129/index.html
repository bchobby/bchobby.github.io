<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ede1291d0e636275d5766509e3cedd/" rel="bookmark">
			UnityWebRequest教程☀️2021，你还在使用过时的 www API吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🟥 常用网络传输方法
1️⃣ Get下载数据
2️⃣ Post上传数据
3️⃣ Put上传数据
4️⃣ Head下载头文件
🟧 网络传输的API
1️⃣ 测试网址是否连通
2️⃣ 获取要下载数据的长度
3️⃣ 显示下载进度
4️⃣ 显示上传进度
5️⃣ 保存下载的文件
6️⃣ 断点续传
各位小老弟，可能已经遇到www协议过时的问题了
但又因为BestHttp是一个插件，在大型公司，不好直接将自己的插件放在项目中。
那么下面，我们就来看看Unity自己的最新网络传输方法：
UnityWebRequest
🟥 常用网络传输方法 网络传输一般采用Get、Post、Put、Head，
同时还有一些控制的API，或者得到数据之类的API，那么就先从Get说起
1️⃣ Get下载数据 Get可用来下载字符串、数组、图片、AB包、音频等的数据。
当下载完成，可再将数据进行你想要的转换。
void Start() { StartCoroutine(SendGetRequest()); } IEnumerator SendGetRequest() { UnityWebRequest uwr = UnityWebRequest.Get("http://www.baidu.com"); yield return uwr.SendWebRequest(); if (uwr.isHttpError || uwr.isNetworkError) { Debug.Log(uwr.error); } else //请求成功 { Debug.Log("Get:请求成功"); Debug.Log("下载的数据：" + uwr.downloadedBytes); } } 2️⃣ Post上传数据 Post可以键值对的形式，将数据存在表单WWWForm里，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ede1291d0e636275d5766509e3cedd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464fecd40162f2efa7dd178ea0da1740/" rel="bookmark">
			javascript数组的操作方法集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是数组？
数组就是一个又一个元素组成的有序集合，数组取值用的是下标
数组有两种声明方式：
1.字面量声明
2.构造函数声明
// var arr = [1,{},''] // var arr1 = new Array() 数组.length
var arr = [1,2,3,4,5,6] for(var i=0;i&lt;=arr.length-1;i++){ console.log(arr[i],i) } 1.push() 可以添加一个或多个参数到数组的尾部，添加之后原来的数组会发生改变，返回的是添加后的数组的长度
const array = [1, 2, 3] console.log(array); //初始数组 const newArray = array.push(4, 5, 6, 7) console.log(array); //添加过后的数组 2.unshift 往数组的头部添加数据 unshift的返回值也是新数组的长度
var arr = ['a', 'b', 'c', 'd'] arr.unshift('e') console.log(arr) // ['e', 'a', 'b', 'c', 'd']打印的结果 3.pop 从数组的尾部删除一个数据 pop的返回值时删除的数据
var arr = ['a', 'b', 'c', 'd'] arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464fecd40162f2efa7dd178ea0da1740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7e4d2df88aa62fc5c4ee9e42653b5e/" rel="bookmark">
			Hive 上配置 Hive on Spark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive 的安装配置见：Hive 安装配置
在 Hive 上配置 Hive on Spark
安装 在服务器 ns1 上安装，此服务器之前已经安装好 Hive；
下载解压 官网地址：http://spark.apache.org/downloads.html
下载：spark-3.0.0-bin-hadoop3.2.tgz
说明：
Hive3.1.2 支持的 Spark 是 2.4.5，所以需要将下载的 Hive3.1.2 的源码中的 pom 文件中的 Spark 版本改为 3.0.0，然后再编译打包，得到支持 Spark 3.0.0 的 Jar 包；
$ tar xzvf spark-3.0.0-bin-hadoop3.2.tgz -C /home/hadoop/local/
$ cd /home/hadoop/local
$ ln -s spark-3.0.0-bin-hadoop3.2 spark
配置环境变量 $ sudo vim /etc/profile.d/my_env.sh
HADOOP_HOME=/home/local/hadoop ZOOKEEPER_HOME=/home/hadoop/local/zookeeper KAFKA_HOME=/home/hadoop/local/kafka KE_HOME=/home/hadoop/local/efak FLUME_HOME=/home/hadoop/local/flume SQOOP_HOME=/home/hadoop/local/sqoop HIVE_HOME=/home/hadoop/local/hive SPARK_HOME=/home/hadoop/local/spark PATH=$PATH:/home/hadoop/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$ZOOKEEPER_HOME/bin:$KAFKA_HOME/bin:$KE_HOME/bin:$FLUME_HOME/bin:$SQOOP_HOME/bin:$HIVE_HOME/bin:$SPARK _HOME/bin:$SPARK_HOME/sbin export HADOOP_HOME ZOOKEEPER_HOME KAFKA_HOME KE_HOME FLUME_HOME SQOOP_HOME HIVE_HOME SPARK_HOME PATH 配置 Hive on Spark 在 hive 中增加配置 spark-defaults.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7e4d2df88aa62fc5c4ee9e42653b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb5f1b5888a24efc43a5f3a4b37d137/" rel="bookmark">
			SpringCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ribbon Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。
Maven依赖
Eureka自带了Maven依赖
&lt;!--eureka 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; 默认轮询负载均衡
负载均衡算法 负载方式实现类RoundRobinRule轮询RandomRule随机RetryRule先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试WeightedResponseTimeRule对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择BestAvailableRule会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务AvailabilityFilteringRule先过滤掉故障实例，再选择并发较小的实例ZoneAvoidanceRule默认规则，复合判断server所在区域的性能和server的可用性选择服务器 Ribbon自定义配置负载均衡 项目启动类
@SpringBootApplication @EnableEurekaClient @RibbonClient(name = "CLOUD-PAYMENT-SERVICE", configuration = MySelfRule.class) public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } } @RibbonClient(name = “CLOUD-PAYMENT-SERVICE”, configuration = MySelfRule.class)
name指定服务名称,configuration配置实现类
package com.yunwangl.springcloud.myrule; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.RandomRule; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MySelfRule { @Bean public IRule myRule() { //定义为随机 return new RandomRule(); } } Ribbon官方说明配置实现类不能和程序的@ComponentScan扫描的包下，会导致其他的服务也使用该负载均衡实现，从而无法做到自定义负载均衡算法。MySelfRule需要建立在不同包名下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb5f1b5888a24efc43a5f3a4b37d137/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bfab9bee25c2e6b09b374a871efad7f/" rel="bookmark">
			QLC SSD适用的应用场景有哪些？附具体案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适合QLC SSD读为主的应用场景都有哪些呢？我们来一起总结下：
为了更加清晰的理解，把这个总结按照IO数据分布图填充，就得到下面这张图，更加的直观。
QLC应用案例分析 我们这里分享一个QLC SSD在CDN加速场景应用的案例。
首先看下CDN是什么。CDN 是内容分发的网络拓扑结构，在源服务器(网站原始所在地)和节点(服务器集群，缓存源服务器的文件并提供加速服务)之间提供网络加速的功能。
在没有开启CDN加速的情况下，当我们访问目标网站，会直接访问目标网站源服务器。这样就有一个缺陷，访问的距离越远，源服务器的响应就越慢。在开启CDN加速的情况下，当我们访问目标网站时，会第一优先级访问距离我们最新的节点。相当于提前把用户需要访问的文件传输到加速节点，用户就不需要等待源服务器的响应了，大大提升了用户的体验。 小编之前正好体验过CDN加速的快乐，事情是这样的，在代码开发中，我准备从官网下载VScode，但是开启下载后，发现速度真的是龟速啊，只有57KB/s, 5G的时代，还这么慢，简直不可接受。
后来发现，VScode官网有使用CDN加速功能，立即把下载链接中的域名替换成cdn加速域名(vscode.cdn.azure.cn)，现在速率直接飙升至2.3MB/s。飞一样的感觉！
好像有点扯远了，见证了CDN加速的好处，我们还是回归正题。在CDN场景下，QLC如何发挥价值呢？
CDN真正影响用户体验就是离用户最近节点服务器以及中间传输节点服务器，这部分机器既要求有低延迟的服务，又要求存储数据。访问的数据模型主要是128KB以上的95%顺序读，还有5%的随机混合读写。
CDN之前的解决方案通常采用混合存储的方式：TLC SSD作为缓存+HDD作为数据存储。这样既可以满足低延迟的需求，又可以满足低成本的数据存储需求。如果采用全QLC替换TLC SSD+HDD的混合方案，收益如何？
以Intel P5316为例，全QLC SSD的替换后，单个服务器容量提升6倍，带宽提升3.7倍，功耗效率提升3.7倍，单个服务器容量的提升，也可以服务更多的用户，收益明显。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97a6af9971e70c78ab1035bb60d5389/" rel="bookmark">
			使用无名管道进行父子进程之间的通信，父进程发送给子进程接收，当发送了quit就退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习：使用无名管道进行父子进程之间的通信，父进程发送给子进程接收，当发送了quit就退出 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;sys/wait.h&gt; #include &lt;stdlib.h&gt; //使用无名管道进行父子进程之间的通信，父进程发送给子进程接收，当发送了quit就退出 int main(void) { int pipefd[2]; pipe(pipefd); //创建子进程 pid_t x=fork(); if(x &gt; 0) //父进程写入 { char buf[50]; while(1) { bzero(buf,sizeof(buf)); //清空数组 scanf("%s",buf); write(pipefd[1],buf,sizeof(buf)); if(!strncmp(buf,"quit",4)) break; } wait(NULL); } if(x == 0) //子进程读取 { char buf[50]; while(1) { bzero(buf,sizeof(buf)); //清空数组 printf("%s",buf); read(pipefd[0],buf,sizeof(buf)); printf("读取： %s\n",buf); if(!strncmp(buf,"quit",4)) break; } exit(0); } return 0; } 结果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed330a6880d1a538c291e07902f43018/" rel="bookmark">
			Vue3全局挂载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：
import { createApp } from 'vue' import App from './App.vue' import router from './router' const app = createApp(App) app.use(router) app.config.globalProperties.$http = 'http...' app.mount('#app') // 使用： // import { getCurrentInstance } from "vue" // const { proxy } = getCurrentInstance() // console.log(proxy.$http) 方式二：
import { createApp } from 'vue' import App from './App.vue' import router from './router' const app = createApp(App) app.use(router) app.provide('$http', 'http...') app.mount('#app') // 使用： // import { inject } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed330a6880d1a538c291e07902f43018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1c2191c791761fb709f8146c710f4d/" rel="bookmark">
			Python操作列表的常用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.weidianyuedu.com/
下面列出列表常用的方法操作列表以及小例子：
Append 在列表末尾添加元素，需在列表末尾添加元素，需要注意几个点:
A. append中添加的参数是作为一个整体
name = list(“scott”)
name
[‘s’, ‘c’, ‘o’, ‘t’, ‘t’]
name.append(list(" tiger"))
name
[‘s’, ‘c’, ‘o’, ‘t’, ‘t’, [’ ', ‘t’, ‘i’, ‘g’, ‘e’, ‘r’]]
得到的值不是：[‘s’, ‘c’, ‘o’, ‘t’, ‘t’, ’ ', ‘t’, ‘i’, ‘g’, ‘e’, ‘r’]
如果想要这种的追加方式，可以试试分片赋值(或者下面说到的extend方法)：
name = list(“scott”)
name
[‘s’, ‘c’, ‘o’, ‘t’, ‘t’]
name[len(name):] = list(" tiger") #从末尾追加
name
[‘s’, ‘c’, ‘o’, ‘t’, ‘t’, ’ ', ‘t’, ‘i’, ‘g’, ‘e’, ‘r’]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1c2191c791761fb709f8146c710f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783a6f79c634d3ac8e39187186ac4186/" rel="bookmark">
			Webots R2022b 发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个功能不错webots.cloud
但是，如果网络不畅通：
个把小时也不会有任何进展……
文档如果网络不畅，也打开困难……
Webots参考手册 R2022b Webots R2022 更改日志 版本 R2022b 于 2022 年 9 月 13 日发布。
新机器人 添加了来自Bitcraze的Crazyflie 四旋翼机器人模型和带键盘控制的飞行演示 ( #4703 )。添加了来自Franka Emika的Panda机器人模型和取放演示 ( #4194 )。添加了Epson的SCARA T6机器人模型和演示它在食品行业环境中分拣水果的演示 ( #4192 )。新对象 添加了一些医院主题物品：病床、滴水架、药瓶、洗手液、窗帘、相框、花盆、紧急出口标志和织物外观（#4166）。将 CardboardBox 扩展为容器并添加了纸板外观（#4359）。添加了一个气罐原型（#4536）。添加了静态叉车的原型（#4561）。新的功能 macOS ( #4543 )上对 Apple M1 处理器的原生支持。将机器人窗口移至 Web 浏览器（#4085）。更改了 Webbot 和机器人控制器之间的管道，以允许在单独的 docker 容器中运行它们（#4344）。将模拟服务器升级到 docker-compose 以在 webots.cloud ( #4259 ) 上运行 Theia IDE。添加了对使用 TCP 连接 ( #4518 ) 的远程外部控制器的支持，并优先考虑允许的 IP ( #4644 )。添加了用于创建 PROTO 文件的向导 ( #4104 )。添加了两个新的机器人 API 函数wb_robot_step_begin和wb_robot_step_end，以优化计算机密集型控制器 ( #4107 )。添加了Extra Project通过“首选项”菜单定义多个路径的功能，以及通过设置WEBOTS_EXTRA_PROJECT_PATH环境变量的替代方法。（#4364）。先前设置的额外项目路径应在首选项菜单中重新设置。添加了一个分享按钮来上传场景和动画到webots.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783a6f79c634d3ac8e39187186ac4186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b6aba89e5eba1811bae3d436f6eeb1/" rel="bookmark">
			p4批量revert
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题提出：同事误操作直接把几个分支全部checkout了，在windows客户端没法批量操作，因为数量太多导致卡死
解决思路：在p4服务器上用脚本执行revert操作
代码如下
#!/bin/bash # $1是user,$2是workspace p4 opened -u $1 | grep $2 | awk '{pos=index($0, "#"); print substr($0,0,pos-1)}' &gt;revert_list_new.txt awk -v work_space=$2 '{if(length($0) &gt; 5){str = str" \""$0"\""}; if(length(str) &gt; 850){ print "p4 revert -C "work_space""str &gt;&gt; "out_file_new.sh"; str=""}}' revert_list_new.txt 第一行是通过p4 opened命令查找出所有打开的文件，同时提取文件名，这里是以第一个#为截止符，比如“//depot/impforest_upgrate/client/cocos2d-x-3.7/build/cocos2d_js_tests.xcodeproj/xcshareddata/xcschemes/js-tests Mac.xcscheme#1 - edit default change (text) by designer@designer_6193”，这里注意文件名中可能有空格，提取的时候一定要准确，还可以这样，用awk的贪婪匹配
p4 opened -u $1 | grep $2 | awk '{if(match($0, "//depot.*?#")&gt;0){print substr($0, RSTART, RLENGTH - 1)}}' &gt;revert_list_new.txt 第二行是将找出的所有文件名，批量的放到revert命令中，注意，因为文件名可能有空格，所有要加上引号。同时revert命令的参数有1024个utf8字符限制，所以我这里初略得设置为大于850字符的话就切换另一个revert命令，或者是直接向p4 revert传递10个参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b6aba89e5eba1811bae3d436f6eeb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7b39e66f56334d60aff66d0205d960/" rel="bookmark">
			【Please, upgrade your dependencies to the actual version of cor问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Please, upgrade your dependencies to the actual version of cor问题 npm版本依赖不兼容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103a5b53e9cc6127a7dc69faee2ae5ad/" rel="bookmark">
			信号的基本概念和分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号的基本概念和分类 通信系统 为传送消息而装设的全套设备技术
接收设备就是发送设备的逆过程，发送设备有编码器，接收设备肯定就有译码器
信号的描述和分类 信号的描述 信号是信息的一种物理体现，他一般是随时间或位置变化的物理量
信号按物理属性分：电信号和非电信号。他们可以相互转换。
电信号容易产生，便于控制，易于处理。本课程讨论电信号——简称“信号”
电信号的基本形式：随时间变化的电压或电流
描述信号的方法：
(1)表示为时间的函数
(2)信号的图形表示——波形图
信号的分类 按实际用途划分：
电视信号、雷达信号、控制信号、通信信号、广播信号、……
按所具有的时间特性划分：
确定信号和随机信号、连续信号和离散信号、周期信号和非周期信号、能量信号与功率信号、一维信号和多维信号、因果信号和反因果信号、实信号和复信号、左边信号和右边信号等
确定信号和随机信号 确定性信号：可用确定的时间函数表示的信号，对于指定的某一时刻\(t\)，有确定的函数值\(f(t)\)
随机信号：值具有不确定性的信号，如电子系统中的起伏热噪声、雷电干扰信号
伪随机信号：貌似随机而遵循严格规律产生的信号(伪随机码)
连续信号和离散信号 连续时间信号：在连续的时间范围内\((-\infty&lt;t&lt;-\infty)\)有定义的信号，简称连续信号
波形如下图所示：
这里的“连续”指函数的定义域——时间是连续的，但可含间断点，至于至于可连续也可不连续
用\(t\)表示时间变量
离散时间信号：尽在一些离散的瞬间才有定义的信号，简称离散信号
波形图如下：
定义域——时间是离散的，他只在某些规定的离散瞬间给函数值，其余时间无定义(无定义并不是等于 0 )
离散点间隔\(T_k = t_{k+1}-t_k\)可以相等也可以不相等。通常取等间隔\(T\)，离散信号可表示为\(f(kT)\)，简写为\(f(k)\)，这种等间隔的离散信号也常称为序列。其中k称为序号
模拟信号、抽样信号、数字信号
通过传感器采集到的很多信号是模拟信号，计算机处理的信号是数字信号
模拟信号：时间和幅值仅为连续的信号，抽样得到抽样信号
抽样信号：时间离散的，幅值连续的信号，量化得到数字信号
数字信号：时间和复制均为离散的信号
连续信号于模拟信号、离散信号与数字信号常通用
周期信号和非周期信号 定义在\((-\infty&lt;t&lt;-\infty)\)区间，每隔一定时间\(T\)(或整数\(N\))按相同规律重复变化的信号
连续周期信号\(f(t)\)满足：$$ f(t) = f(t+mT), m = 0,\pm1,\pm2,…… $$
离散周期信号\(f(k)\)满足：$$ f(k) = f(k+mN), m = 0,\pm1,\pm2,…… $$
满足以上关系的最小T(或整数N)称为该信号的周期，不具有周期性的信号称为非周期信号(没有规律，并不是不确定性)
能量信号与功率信号 将信号\(f(t)\)施加于 1 电阻上，他所消耗的瞬时功率为\(|f(t)|^2\)，在区间\((-\infty&lt;t&lt;-\infty)\)的能量和平均功率定义为：
(1)信号的能量\(E\)：
\[E^{def} = \int_{-\infty}^{\infty}|f(x)|^2\,dt \] (2)信号的功率\(P\)：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103a5b53e9cc6127a7dc69faee2ae5ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03c88d93d52dd692e03f8963c536b97/" rel="bookmark">
			input文本框自动换行,input textarea自动换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js可以做什么 。
对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于ChromeJavaScript运行时建立的平台，用于方便地搭建响应速度快、易于扩展的网络应用。
发布于2009年5月，由RyanDahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型，让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。
功能模块：Node使用Module模块去划分不同的功能，以简化应用的开发。Modules模块有点像C++语言中的类库。
每一个Node的类库都包含了十分丰富的各类函数，比如http模块就包含了和http功能相关的很多函数，可以帮助开发者很容易地对比如http,tcp/udp等进行操作，还可以很容易的创建http和tcp/udp的服务器。
要在程序中使用模块是十分方便的，只需要如下：在这里，引入了http类库，并且对http类库的引用存放在http变量中了。
这个时候，Node会在我们应用中搜索是否存在node_modules的目录，并且搜索这个目录中是否存在http的模块。
如果找不到这个目录，则会到全局模块缓存中去寻找，用户可以通过相对或者绝对路径，指定模块的位置。以上内容参考：百度百科。
谷歌人工智能写作项目：小发猫
Node.js是什么，它是用来做什么的？ 是一个基于ChromeV8引擎的JavaScript运行时typescript中文版教程，typescript实战指南。是一个基于ChromeV8引擎的JavaScript运行环境。使用了一个事件驱动、非阻塞式I/O的模型。
Node是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。
[2]发布于2009年5月，由RyanDahl开发，实质是对ChromeV8引擎进行了封装。Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。
V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于ChromeJavaScript运行时建立的平台，用于方便地搭建响应速度快、易于扩展的网络应用。
Node使用事件驱动，非阻塞I/O模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。
node.js能干什么？ 1.JavaScript为HTML设计师提供了一种编程工具HTML创作者往往都不是程序员，但是JavaScript却是一种只拥有极其简单的语法的脚本语言！
几乎每个人都有能力将短小的代码片断放入他们的HTML页面当中。
2.JavaScript可以将动态的文本放入HTML页面类似于这样的一段JavaScript声明可以将一段可变的文本放入HTML页面：document.write(""+name+"")3.JavaScript可以对事件作出响应可以将JavaScript设置为当某事件发生时才会被执行，例如页面载入完成或者当用户点击某个HTML元素时。
4.JavaScript可以读写HTML元素JavaScript可以读取及改变HTML元素的内容。
5.JavaScript可被用来验证数据在数据被提交到服务器之前，JavaScript可被用来验证这些数据。
6.JavaScript可被用来检测访问者的浏览器JavaScript可被用来检测访问者的浏览器，并根据所检测到的浏览器，为这个浏览器载入相应的页面。
7.JavaScript可被用来创建cookiesJavaScript可被用来存储和取回位于访问者的计算机中的信息。
前端用nodejs能做什么 到底是什么？是一个JavaScript的编译环境，当前端语言JavaScript在写完之后可以交给进行编译和解释，它的存在对于JavaScript有了质的飞跃。
下面就是一个简单的命令#node目前，在大部分领域都占有一席之地，尤其是I/O密集型的。比如Web开发，微服务，前端构建等。
不少大型网站都是使用作为后台开发语言的，用的最多的就是使用做前端渲染和架构优化，比如淘宝双十一、去哪儿网的PC端核心业务等。
另外，有不少知名的前端库也是使用开发的，如Webpack是一个强大的打包器，React/Vue是成熟的前端组件化框架。
通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。
阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和LinkedIn都采用了框架搭建应用。
另外，编写的包管理器npm已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。
是一个对于前端工作者不可或缺的工具。尤其是对于JavaScript有着巨大的提升，现阶段的应用已经有了非常蓬勃的发展。对于的学习和熟练运用，必不可少！
nodejs可以用来做什么 。
1、nodejs搭配MongoDB作后端；2、nodejs搭配“终端”作前端的编译工具使用；3、编辑一些小工具，例如“网络爬虫”啥的；4、在不使用浏览器的控制台功能时，可用nodejs达到同样的目的，如下面两张图所示：
nodejs 具体是做什么用的 是一个运行在chromeJavascript运行环境下（俗称GoogleV8引擎）的开发平台，用来方便快捷的创建服务器端网络应用程序。
你可以把它理解为一个轻量级的JSP或PHP环境，但是用来开发Web应用的话，有时要便捷很多。很多人都不明白，为什么一个javascript的东西用在了服务器端的开发上。
一般认为javascript是浏览器端的脚本语言，但是google将其再开发，用来作为服务器端脚本环境，其性能自称比Python、Perl、PHP还要快。
的最大优点是处理并行访问，如果一个web应用程序同时会有很多访问连接，就能体现使用的优势。另一个好处是，使用javascript作为服务器端脚本语言，可以消除一些与浏览器端js脚本的冲突。
甚至发挥javascript动态编程的特性，在服务器与浏览器之间建立直接的动态程序。
node能做什么? 是一个运行在chromeJavascript运行环境下（俗称GoogleV8引擎）的开发平台，用来方便快捷的创建服务器端网络应用程序。
的优点是：1、处理并行访问，如果一个web应用程序同时会有很多访问连接，就能体现使用的优势。2、使用javascript作为服务器端脚本语言，可以消除一些与浏览器端js脚本的冲突。
甚至发挥javascript动态编程的特性，在服务器与浏览器之间建立直接的动态程序。
node.js是什么 是一个基于ChromeV8引擎的 JavaScript 运行环境。使用了一个事件驱动、非阻塞式I/O的模型。
Node是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。
发布于2009年5月，由RyanDahl开发，实质是对ChromeV8引擎进行了封装。Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。
V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于ChromeJavaScript运行时建立的平台，用于方便地搭建响应速度快、易于扩展的网络应用。
Node使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。扩展资料：Node采用一系列“非阻塞”库来支持事件循环的方式。
本质上就是为文件系统、数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知Node。
该模型以可扩展的方式简化了对慢资源的访问，直观，易懂。尤其是对于熟悉onmouseover、onclick等DOM事件的用户，更有一种似曾相识的感觉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e417452a260fde87f39d8f5d13480f9/" rel="bookmark">
			C&#43;&#43;超级素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 超级素数是指一个 n 位正整数，它的前 1 位，前 2 位, . . . ，前 n 位均为素数，（例如： 7331 是个 4 位超级素数，因为 7,73,733,7331 均为素数）。
由键盘输入 n(n&lt;6) ， 然后输出全部的 n 位超级素数。
输入格式 一个整数 n ，表示超级素数的位数。
输出格式 若干行，每行一个整数，表示满足条件的超级素数。
样例数据 输入样例 #1输出样例 #1223
29
31
37
53
59
71
73
79 样例分析 如上所述。
数据范围 100% 的数据： 0&lt;n≤6
解题: #include&lt;bits/stdc++.h&gt; #include&lt;string&gt; using namespace std; int n; string str; bool isprime(int m){ if(m&lt;=1) return false; for(int i=2;i&lt;=sqrt(m);i++)if(m%i==0)return false; return true; } void superp(int i){ if(to_string(i).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e417452a260fde87f39d8f5d13480f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695253a19c529bf5ba0dfe1a03e537f3/" rel="bookmark">
			进程习题1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个程序，使其产生一个子进程c，并使用exec函数簇中的任意版本，使得子进程执行系统命令ls -l查看某个文件的详细信息，
父进程判断子进程是否执行成功？ #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/wait.h&gt; int main() { pid_t son=fork(); if(son&gt;0) //父进程 { int status; wait(&amp;status); if(WIFEXITED(status)) //判断子进程是否正常退出 { printf("正常退出，返回值为：%d\n",WIFEXITED(status)); } } if(son == 0) //子进程 { int ret=execl("/bin/ls","ls","-l","day1.c",NULL); if(ret == -1) { perror("execl error\n"); } exit(0); } return 0; } 写一个程序，创建嵌套的三个子进程，获取不同的子进程的父进程pid
尝试退出函数和等待函数waitpid监听 /* 写一个程序，创建嵌套的三个子进程，获取不同的子进程的父进程pid 尝试退出函数和等待函数waitpid监听 */ #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695253a19c529bf5ba0dfe1a03e537f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f696fa837bcad73cc36cf4b41a014b/" rel="bookmark">
			linux命令行中一键打开windows中对应目录的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
一般我们将代码放在Ubuntu里面，当我们在某个linux目录下面，想在windows的资源管理器里面打开对应的目录，如果直接在windows资源管理器里面一级一级的找，将非常麻烦。这里我提供一个脚本，在linux命令行上运行后，直接输出对应的windows资源管理器的目录，复制目录后在win+R中即可快速打开对应的目录。
linux中 #!/bin/bash String_To_Replace=home curr_path=$(pwd) echo $curr_path tihuan=$(echo $curr_path | sed 's#\/#\\#g') echo $tihuan t_ip=$(ifconfig eth0 |grep "inet addr" |awk -F":" '{print $2}' |awk '{print $1}') #echo $t_ip result=$(echo $tihuan | sed "s/$String_To_Replace/$t_ip/g") echo "\\"$result 在不同的环境中，变量String_To_Replace的值需要做对应的修改。
将此内容保存到一个随便你喜欢的名字的文件中，我用的是gggggg_get_windows_path.sh，因为这样就可以在命令行中快速的输入ggg后按一下tab键就自动补全脚本了，然后把这个文件放到~/bin目录下。此脚本输出了当前目录在windows资源管理器中的目录，然后按win+r打开run窗口，输入刚才输出的目录，就可以快速打开windows的目录。
注意：
首先要确保Ubuntu中安装并配置好了Samba，并且在windows资源管理器中添加了网络驱动器的映射；要给gggggg_get_windows_path.sh文件可执行权限；要确保放此脚本的目录在PATH中，否则输入ggg按tab无法自动补全； 在windows下的git bash中使用的脚本： #!/bin/bash curr_path=$(pwd) echo $curr_path tihuan=$(echo $curr_path | sed 's#\/#\\#g') echo $tihuan t_temp=${tihuan:2} echo "c:$t_temp" 将上述shell脚本保存到~/bin目录下面任意一个自己喜欢的文件中，然后给这个文件赋可执行权限。然后在git bash中任意目录输入这个文件名，就可以输出windows对应的目录了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de5da9d6008d7bbe4bf48a264bfcad8/" rel="bookmark">
			IDEA启动失败，错误信息显示为“无法启动此程序，因为计算机丢失api-ms-win-crt-runtime-l1-1-0.dll。尝试重新安装该程序以解决此问题”的问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.遇到问题： 因为最近给电脑重装了系统，原本以为需要重装的IDEA意外地让我在d盘找到了（安装的时间太久，忘记原本就是安装在d盘的了），当我正笑嘻嘻地以为可以省去重新安装的功夫的时候，在装完系统后再次启动IDEA时却意外地出现了错误信息，显示图一中的“无法启动此程序，因为计算机丢失api-ms-win-crt-runtime-l1-1-0.dll。尝试重新安装该程序以解决此问题”。o(╥﹏╥)o
图一
点击确定后显示图二的信息
图二
2.解决问题： 根据信息的提示相信许多人跟我一样，第一反应就是以为原本c盘中含有IDEA相关的文件在系统重装时被删除掉了，所以天真的我将IDEA重新卸载又安装了一遍，但结果……依然启动失败，错误信息提示依然如上。o(╥﹏╥)o
心凉凉的我冷静地重新观察和思考了一番，原来图二的那一大长串英文提示才是关键！
错误信息翻译如下：
加载JVM DLL D:\Program FilesJetBrains(IntelliJ IDEA . exe)失败2021.1.3Vjbrl（bin）serverljvm.dll
如果已经安装了64位的JDK，请在“计算机&gt;系统属性&gt;系统设置&gt;环境变量”中定义一个JAVA_HOME变量。
JAVA_HOME？环境变量？
噢！JDK的安装后的环境变量配置！
出现这两个关键词，那么大概率可以确定是JDK的环境配置问题而不是IDEA本身文件的问题了。
进入环境变量（计算机右击&gt;属性&gt;高级系统设置&gt;点击环境变量）后，果然，之前的配置过的CLASSPATH和JAVA和Path统统在系统重装后烟消云散了，而且在第一次重新配置的时候根据网上某个博主的文章进行操作后仍然有遗漏，对此补充操作记录如下。
安装jdk和jre完成后进行：
（1）进入环境变量（在计算机图标上右键点击&gt;属性&gt;高级系统设置&gt;点击环境变量）
（2）在【系统变量】点击【新建】，新建【JAVA_HOME】环境变量
变量名：JAVA_HOME
变量值：D:\Program Files\Java\jdk1.8.0_181(此处的路径为你的jdk安装目录,此次需根据自己的安装路径进行修改）
输入完成后点击确定
（3）找到【Path】，点击【编辑】
在开头处新增%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
输入完成后点击确定
（4）在【系统变量】点击【新建】，新建【CLASSPATH】环境变量
变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar
输入完成后点击确定
（5）点击【确定】进行保存
测试： （1）win+r输入cmd打开控制台，输入java -version，按回车键，显示当前的jdk版本号
（2）再次输入javac，按回车键，如图显示的表示Path变量配置成功
出现以上画面的话，表示安装与配置环境变量正式完成。
至此，重新启动IDEA，终于正常开启了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4662a20306f8496e45bfff7bd3fa641b/" rel="bookmark">
			什么是API接口？给大家举例说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Api接口也就是所谓的应用程序接口，api接口的全称是Application Program Interface，通过API接口可以实现计算机软件之间的相互通信，开发人员可以通过API接口程序开发应用程序，可以减少编写无用程序，减轻编程任务，API 同时也是一种中间件，为各种不同平台提供数据共享。根据单个或分布式平台上不同软件应用程序间的数据共享性能。
举个例子来说明，就是当你在购物平台上买东西付款之后，商家选择某一快递公司发货，然后你就可以在购物平台上面查看快递的实时进程。购物平台和快递公司都是独立的公司，为什么能够在购物平台看到快递公司的信息呢，这里就是用到了API，当你在查看快递信息的时候，购物平台的内部系统也开始运作，购物平台通过快递公司提供的API接口，可以实时调取快递信息到网站上。除此之外，你还可以在搜索引擎上输入快递的订单号进行查询，只要是通过快递公司的允许别的公司都可以通过快递公司的API接口调取到快递信息。
而API接口平台大多都是用来开发新的应用软件的，这样可以有效的避免因为程序员编写的接口有问题，导致拖延时间，无法在应有的时间内完成软件的编写，但是在有了api接口程序之后，能够帮助开发者提升开发效率，可以大大的缓解这种情况的发生，可以让开发人员更加有效的完成软件的开发工作。能以一种简单的方式实现App里的某个服务已经成为开发者们最好的选择。
我们以淘宝API接口为例，下图为测试页面展示：
通过接口可以快速的获取我们想要的信息。
测试地址：https://console.open.onebound.cn/console/index.php?i=hardy 注册可以赠送测试，亲测有效
{ "items": { "page": "1", "real_total_results": 1000, "total_results": 1000, "page_size": 40, "pagecount": 50, "data_from": "hid", "item": [ { "title": "优衣库 女装 棉质T恤(长袖) 430273 UNIQLO", "pic_url": "https://img.alicdn.com/imgextra/i1/196993935/O1CN019g5Rmc1ewH9VOcioZ_!!196993935-0-picasso.jpg", "promotion_price": "79.00", "price": "79.00", "sales": 0, "num_iid": "627543382638", "seller_nick": "优衣库官方旗舰店", "seller_id": "0", "detail_url": "https://item.taobao.com/item.htm?id=627543382638", "data_f": null, "data_update": "2021-10-18 04:05:29" }, { "title": "Data Zara新款 女装 垂褶直筒裙 08000878800", "pic_url": "//img.alicdn.com/imgextra/i1/2209090117041/O1CN01psHm3u21spO3HTo4R_!!2209090117041.jpg", "promotion_price": "179.00", "price": "299.00", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4662a20306f8496e45bfff7bd3fa641b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00806a573e4928bd8e7f060b19e2eea/" rel="bookmark">
			Latex 显示多组图，且不显示底标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，仅在最底下显示自己所需文字时
latex代码：
\begin{figure}[t]% \centering \begin{center} \begin{minipage}{\textwidth} \begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}c@{}c@{}c@{}c@{\extracolsep{\fill}}} \includegraphics[width = 2cm]{pic/qq.jpg} &amp; \includegraphics[width = 2cm]{pic/qq.jpg} &amp; \includegraphics[width = 2cm]{pic/qq.jpg} &amp; \includegraphics[width = 2cm]{pic/qq.jpg} \\ \includegraphics[width = 2cm]{pic/qq.jpg} &amp; \includegraphics[width = 2cm]{pic/qq.jpg} &amp; \includegraphics[width = 2cm]{pic/qq.jpg} &amp; \includegraphics[width = 2cm]{pic/qq.jpg} \\ A &amp; B &amp; C &amp; D \\ \cite{b22} &amp; &amp; \cite{b33} &amp; abc \\ \end{tabular*} \end{minipage} \end{center} \caption{Here is the caption.Here is the caption.Here is the caption.Here is the caption.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e00806a573e4928bd8e7f060b19e2eea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c630fb6e006be0c267222b10057a03d/" rel="bookmark">
			API接口是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API其实就是应用程序接口(Application Programming Interface)的简称。API 是一些功能、定义或者协议的集合，提供应用程序或者程序开发人员基于软件访问一组例程的能力，对外封装完善，调用时无需学习 API内部源码，依据 API文档功能说明书来使用即可。
那么API到底是一种什么技术呢？
如今具有开放式的业务体系结构将是下一代网络的重要特征之一。其中，关键的技术之一就是网络控制与应用层之间的应用程序接口(API)。通过应用程序接口，业务开发商 、独立软件提供商 (ISV)等第三方应用可以获得使用现有网络资源的能力 ，从而方便 、灵活地为客户提供所需的业务。API接口已经深入应用到各个网页与APP中。
测试页面展示：
测试地址：https://console.open.onebound.cn/console/index.php?i=hardy
名称类型必须示例值描述 num_iid
Bigint0572050066584宝贝ID name
String0尺码:S;颜色分类:白色衬衫规格名称 img
String0//gd2.alicdn.com/imgextra/i2/3542320334/TB2gPaOyYSYBuNjSspiXXXNzpXa_!!3542320334.jpg规格图片 price
Float083.7优惠价 orginal_price
Float0135.00原价 express_fee
Float06.00快递费用 title
String0雪纺白色衬衫女长袖面试职业正装2018秋新款OL防走光工作服打底衣宝贝标题 detail_link
String0http://item.taobao.com/item.htm?id=572050066584宝贝链接 pic_url
String0//gd3.alicdn.com/imgextra/i2/3542320334/TB2zGWny4SYBuNjSsphXXbGvVXa_!!3542320334.jpg宝贝图片 quantity
Int0257库存 properties
String020509:28314;1627207:3714507属性id组合 sku_id
String03880971359554规格ID {
"item": {
"num_iid": "680057873401",
"title": "茶桌组合新中式办公室茶桌茶具套装一体商用会客实木茶台功夫茶几",
"desc_short": "",
"price": "2635",
"total_price": 0,
"suggestive_price": 0,
"orginal_price": "7198.00",
"nick": "漳龙旗舰店",
"num": "200",
"min_num": 0,
"detail_url": "https://item.taobao.com/item.htm?id=680057873401",
"pic_url": "//img.alicdn.com/imgextra/i3/3470550929/O1CN01w3BRgs1IjWiT168gB_!!3470550929.jpg",
"brand": "漳龙",
"brandId": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c630fb6e006be0c267222b10057a03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8bf7fd07477e7eba305ab3ad7e4ddfe/" rel="bookmark">
			Java编写HTTP请求发送XML报文数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java编写HTTP请求发送XML报文数据 1、编写系统A代码（服务接收方）2、编写系统B代码（服务请求方）3、测试结果 测试背景：
现在有系统A和系统B，系统B使用HTTP请求向系统A发送报文数据，然后A系统接收到对应HTTP请求，并且对该请求中数据进行解析处理，最终返回与处理逻辑相对应的XML报文。
这里的系统A可以抽象理解为服务接收方，系统B可以抽象理解为服务请求方这里的xml，可以抽象一下， 并不一定需要是真正的xml报文数据，Json同理。为方便后期改写，故demo中的系统A使用SpringBoot进行构建，系统B使用测试类进行构建。 1、编写系统A代码（服务接收方） 注意：
@Slf4j注解：使用了lombok插件和引入对应的maven依赖。你也可以直接使用System.out.println进行打印输出requestData：xml格式的报文数据，xml测试片段代码逻辑分为两部分：处理接收到的数据；回写处理完的数据 @RequestMapping("/local") @Controller @Slf4j public class LocalController { @RequestMapping("/local") public void testOtherClient(HttpServletRequest request, HttpServletResponse response) throws IOException { String unifiedCharset = "UTF-8"; // 获取服务端接收的报文信息： // 1.获取输入流 // 2.封装为一个BufferedReader // 3.读取数据写入Java缓存 try (BufferedReader reader = new BufferedReader( new InputStreamReader(request.getInputStream()))) { String lines; StringBuffer sbf = new StringBuffer(); while ((lines = reader.readLine()) != null) { lines = new String(lines.getBytes(), unifiedCharset); sbf.append(lines); } log.info("接收到的数据为 {}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8bf7fd07477e7eba305ab3ad7e4ddfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d129c0470557b08c8ba4ac016db5777/" rel="bookmark">
			安鸾靶场之暴力破解实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、FTP暴力破解 使用kali自带的hydra暴力破解工具，目前该工具支持以下协议的爆破：
AFP，Cisco AAA，Cisco身份验证，Cisco启用，CVS，Firebird，FTP，HTTP-FORM-GET，HTTP-FORM-POST，HTTP-GET，HTTP-HEAD，HTTP-PROXY，HTTPS-FORM- GET，HTTPS-FORM-POST，HTTPS-GET，HTTPS-HEAD，HTTP-Proxy，ICQ，IMAP，IRC，LDAP，MS-SQL，MYSQL，NCP，NNTP，Oracle Listener，Oracle SID，Oracle，PC-Anywhere， PCNFS，POP3，POSTGRES，RDP，Rexec，Rlogin，Rsh，SAP / R3，SIP，SMB，SMTP，SMTP枚举，SNMP，SOCKS5，SSH（v1和v2），Subversion，Teamspeak（TS2），Telnet，VMware-Auth ，VNC和XMPP。
hydra -l admin -P top100pass.txt ftp://118.190.133.35 登录即可找到flag
2、telnet服务破解 如上，同样使用hydra爆破
hydra -l admin -P top100password.txt telnet://www.whalwl.fun:2323 3、登陆表单破解 先随便填写一个账号登录，发现弹窗显示用户不存在，
再使用admin账号，密码随便填写，发现弹窗显示账号或密码错误，所以我们可先进行用户名枚举，再根据用户名来爆破密码
使用burp suite抓包，指定爆破字典，即可先后爆破出用户名及密码
登录即可获取到flag
4、mysql暴力破解 题目提示使用mysql漏洞，我们可想到mysql的连续登录bug。在知道用户名的情况下(如root)，直接反复重试(平均大约256次)即可登入。
受影响的版本：
All MariaDB and MySQL versions up to 5.1.61, 5.2.11, 5.3.5, 5.5.22 are vulnerable.
MariaDB versions from 5.1.62, 5.2.12, 5.3.6, 5.5.23 are not.
MySQL versions from 5.1.63, 5.5.24, 5.6.6 are not.
for ((i=1;i&lt;1000;i++));do mysql -h 118.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d129c0470557b08c8ba4ac016db5777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3a92acb1dd56d00da74e736efa1bee/" rel="bookmark">
			漏洞解决：用户名枚举
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 漏洞描述 存在于系统登录页面，利用登陆时输入系统存在的“密码错误，5次后将锁定30分钟”和“用户名错误”，返回不同的出错信息可枚举出系统中存在的账号信息。
解决方法 对网站登录页面的判断回显信息修改为一致：用户名或密码错误，5次后将锁定30分钟
解决示例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ab411af2fe9dd58165d9460ffa3d39/" rel="bookmark">
			【在虚拟环境中安装包cnocr】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 直接打开命令窗口输入pip install cnocr，安装成功之后，在pycharm中打开设置，找不到cnocr包
原因 命令行直接pip是把包安装在了这个包文件夹里面
C:\Users\Anaconda3\Lib\site-packages
而没有安装在虚拟环境的包中
C:\Users\Anaconda3\envs\tensorflow_env\Lib\site-packages
处理办法 1、cmd打开命令行，
2、cd进入虚拟环境的包文件夹 ：cd C:\Users\Anaconda3\envs\tensorflow_env\Scripts
3、pip install cnocr；出错的话，试试pip install cnocr -i http://pypi.douban.com/simple --trusted-host=pypi.douban.com（后面是地址）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2bc46836aa7f61a507f0c53285b3ed/" rel="bookmark">
			STM32HAL库中断服务函数调用过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32HAL库中断服务函数调用过程 如何找到中断源，如何找到中断源对应的中断服务函数？
中断源在stm32f429xx.h文件中，与中断服务函数一一对应，中断服务函数位于启动文件startup_stm32f429xx.s之中，里面有中断向量表，存储着中断服务函数的地址。启动文件中的中断服务函数都是弱定义的【weak】,可以重新定义一个同名的函数来取代它。
如何找到中断服务函数实际调用的HAL库函数，怎么确认这种调用的存在？
有两个地方可以实现中断服务函数的内容
可以直接在中断源对应的中断服务函数中编写我们想要的功能 例如：
void EXTI9_5_IRQHandler(void) { if(__HAL_GPIO_EXTI_GET_IT( GPIO_PIN_5)!=RESET) { __HAL_GPIO_EXTI_CLEAR_IT( GPIO_PIN_5); /*按下按键1的函数*/ LED_RED; PRESS_Key1=SET; } else if(__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_6)!=RESET) { __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_6); /*按下按键2的函数*/ LED_BLUE; PRESS_Key2=SET; } else { __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_8); /*按下按键3的函数*/ LED_GREEN; PRESS_Key3=SET; } } 也可以间接调用HAL库的中断回调函数来实现我们想要的功能 例如外部中断线中断调用的HAL库的公用函数为void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin），这个函数会调用回调函数HAL_GPIO_EXTI_Callback(GPIO_Pin)来处理中断，可以在这个公用函数中实现功能，也可以重新实现一下这个回调函数，在回调函数中实现功能，但是前提是先把原来的中断服务函数重定向到HAL库的中断公用函数中去。
/*外部中断线中断公用函数*/ void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin) { /* EXTI line interrupt detected */ if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) { __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);//清除中断标志位 HAL_GPIO_EXTI_Callback(GPIO_Pin); //中断回调函数 } } /*中断回调函数 __weak 表示弱定义 */ __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { /* Prevent unused argument(s) compilation warning */ __IO uint32_t tmpreg = 0x00; UNUSED(tmpreg); /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */ } 借助HAL库重新实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2bc46836aa7f61a507f0c53285b3ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2329da9089e41fe2a86b1dfcf25145/" rel="bookmark">
			【python的cnocr包安装报错】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 pip install 安装 cnocr 报错
Microsoft Visual C++ 14.0 or greater is required. Get it with "Microsoft C++ Build Tools"解决办法
处理办法 链接：https://zhuanlan.zhihu.com/p/471661231
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b98ea220d54092703fb23f369a8c7dc/" rel="bookmark">
			git误删怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先：不要慌，一般是因为git删除的文件都有办法找回来。
事件过程：
1.远程仓库为空，我将本地项目推送至远程仓库。
2.推送之后，我发现有些文件不需要上传，为了图简便我直接将远程仓库手动删除。
3.第二次推送时，推送不了，系统报错。
hint: its remote counterpart. Integrate the remote changes (e.g. Done hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 一般这种错误，是先pull拉取一下，再推送就行了。但是我拉的时候系统又报
refusing to merge unrelated historis 于是我使用了
git pill origin master --allow-unrelated-histories 然后由于我的第2步操作，直接将我本地的文件全删了，导致了误删。
下面提供两种解决方法：
第一种：使用 git status 查看状态，你应该会看到你删除的文件，并且前面又delete：标记，如下图：
这时只需要使用git restore命令就能恢复了（这是根据这张图use 后面的提示得到的方法）。例如我们恢复pom.xml文件，就只需要执行
git restore pom.xml 恢复其他文件同理。
第二种方法：
登陆到码云平台，到仓库中，点击下图中红色框起来的区域。
就会看到下图，点击想要恢复时刻的“浏览文件”，就会显示当时的代码。
此时点击“克隆/下载”再点击“下载ZIP”，即可下载当时的代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb51ea50cbe7cde20b8c7ce16cca90f1/" rel="bookmark">
			（附源码）spring boot点餐系统的设计与实现 毕业设计 100908
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot 点餐系统
摘 要
随着互联网趋势的到来，各行各业都在考虑利用互联网将自己推广出去，最好方式就是建立自己的互联网系统，并对其进行维护和管理。在现实运用中，应用软件的工作规则和开发步骤，采用Java技术建设点餐系统。
本设计主要实现集人性化、高效率、便捷等优点于一身的点餐系统，完成用户管理、美食资讯、菜品分类、菜品信息、订单中心、餐厅餐桌、就餐预约等功能模块。系统通过浏览器与服务器进行通信，实现数据的交互与变更。只需通过一台电脑，动动手指就可以操作系统，实现数据通信管理。整个系统的设计过程都充分考虑了数据的安全、稳定及可靠等问题，而且操作过程简单。本系统通过科学的管理方式、便捷的服务提高了工作效率，减少了数据存储上的错误和遗漏。
点餐系统使用Java语言，采用基于 MVC模式的JavaEE技术进行开发，使用 MyEclipse 2017 CI 10 编译器编写，数据方面主要采用的是微软的MySQL关系型数据库来作为数据存储媒介，配合前台HTML+CSS 技术完成系统的开发。
关键词： 点餐；Spring boot框架；
Springboot ordering system
Abstract
With the advent of the Internet trend, all walks of life are considering using the Internet to promote themselves. The best way is to establish their own Internet system and maintain and manage it. In practical application, according to the working rules and development steps of application software, Java technology is used to build a meal ordering system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb51ea50cbe7cde20b8c7ce16cca90f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e155e02a98921902eb8428b2661107/" rel="bookmark">
			latex引用跳转失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天写论文，写也就写了，某一次查看的时候，突然发现，全文的引用跳转通通失效。就引用序号都对着呢，不是显示的“？”号那种完全找不到的情况。但是点击那个跳转引用的超链接，他们永远只跳到第一页，不会跳到文章最后引用对应的那行。
查看latex编译输出框，里面几百个warning。
pdftex warning (dest): name{cite.xxxxx } has been referenced but does not exist, replaced by a fixed one
就类似这种的警告。那应该就是不知道哪里出问题了呗。
查了半天，没查明白。后来看到了这个博客尝试了一下。
https://www.jianshu.com/p/4418bce42c49
就是大意是，引用包的时候，顺序不对，导致出问题。
\usepackage{hyperref}
这个包最后一个包进行导入。这...不懂。反正就按照他说的操作，还的确弄好了。emmm
就浅浅记录一下吧。第一次知道导包还要看顺序emmm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f482a8a00f659f57a9c8f10bd3194f91/" rel="bookmark">
			linux find 命令的使用/find 删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 find命令是一个linux 常用的命令，作用是查找文件。由于对于查找文件需求的多样性，find 的使用实际上是非常复杂的，因此本文记录一下 find 命令的使用，方便自己查阅。
一些参考：
find 的基础用法
find 的 35 种命令
二、具体代码 2.1 查找文件 # Find all directories named src find . -name src -type d # Find all python files that have a folder named test in their path find . -path '*/test/*.py' -type f # Find all files modified in the last day find . -mtime -1 # Find all zip files with size in range 500k to 10M find .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f482a8a00f659f57a9c8f10bd3194f91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9652eeb19de53a7766f049f6d5e2477/" rel="bookmark">
			Mybatis底层源码分析（最详细的版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis底层源码分析（最详细的版本） 1.概要介绍 MyBatis 是一款优秀的持久层框架，也是当前最流行的java持久层框架之一，它内部封装了jdbc，使开发 者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。采 用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用 与jdbc api打交道，就可以完成对数据库的持久化操作。 Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中SQL 的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 2.总体执行流程 通过getResourceAsReader(String resource)方法读取Resources下的mybatis.xml配置文件转换成Reader通过构建者的设计模式去生成SqlSessionFactory对象：new SqlSessionFactoryBuilder().build()方法去生成有了SqlSessionFactory的工厂对象后，就可以通过openSession()去获取DefaultSqlSession对象然后就可以对数据库进行insert、update、delete、select操作进行了数据库的相关操作之后，通过sqlSession.commit()进行事务的提交最后通过sqlSession.close()关闭连接，释放资源 代码如下：
//第一步：读取配置文件转换成Reader resourceAsReader = Resources.getResourceAsReader("mybatis.xml"); //第二步：通过流找到我们的SqlsessionFactory对象 sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader); //第三步：获取SqlSesion对象(会话对象) SqlSession sqlSession = sqlSessionFactory.openSession(); //第四步：提交事务 sqlSession.commit(); //第五步：关闭连接，释放资源 sqlSession.close(); 3. 对各个流程的细分详解 3.1 读取配置文件转换成Reader public static Reader getResourceAsReader(String resource) throws IOException { InputStreamReader reader; if (charset == null) { reader = new InputStreamReader(getResourceAsStream(resource)); } else { reader = new InputStreamReader(getResourceAsStream(resource), charset); } return reader; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9652eeb19de53a7766f049f6d5e2477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d122f80c333867cf803ba4dc52c94f/" rel="bookmark">
			点云配准ICP&amp;NDT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NDT 简介 很多匹配算法需要在两帧数据之间进行特征匹配，例如ICP中会进行点到点、点到线、点到面的特征匹配，特征匹配的效果最终决定了点云配准的效果，而NDT不需要进行特征匹配。NDT是将第一帧点云转换至栅格地图，每个栅格计算其中点的正态分布，因此将第一帧点云转换为一个个栅格表示的分段连续可导的概率密度函数，使用正态分布概率密度函数描述点云的局部性质。然后将第二帧点云投影至栅格地图中，计算出第二帧点云在栅格地图中的概率，通过牛顿法找到最佳匹配位姿，使得第二帧点云投影至栅格地图后概率最大化，最终完成点云配准。
NDT的步骤可分为：建立第一帧点云的栅格地图，牛顿法迭代使得第二帧点云投影至栅格地图得到的概率最大化。
NDT优点：不需要进行点云之间的特征匹配，避免了特征匹配中出现的问题，例如点云噪声、物体移动、点云重合度对特征匹配的影响。使用正态分布概率密度函数描述点云的局部性质，因此所有导数都可以通过解析法求解，因此计算结果准确并且比较快。
建立栅格地图 NDT通过一系列栅格描述的本地点云正态分布描述整个点云的分布。首先将第一帧点云分割为等大的栅格，对于包含一定数量点的栅格，计算栅格内点坐标的均值以及方差，最终可以获得本栅格内点云的正态分布：
因此每个栅格描述了栅格中任意位置的概率密度。
实现细节 由于栅格地图将整个点云进行了离散化，在栅格与栅格之间会出现不连续的现象，可能会造成误差。为了避免离散化的影响，NDT会同时建立四个栅格地图，彼此相互错位半个栅格的长度，这四个栅格地图会同时参与计算，最终结果为四个栅格地图计算结果的和。
计算栅格地图内协方差矩阵时，为了避免协方差矩阵出现奇异性，如果协方差矩阵较大特征值远大于较小的特征值，则将较大特征值进行减小，最终计算得到协方差矩阵。
扫描匹配 首先根据里程计或者匀速运动模型得到先验位姿，根据先验位姿将第二帧点云投影至栅格地图中，对于第二帧点云中每个点，根据它所在的栅格计算概率密度，最终通过求和得到第二帧点云在栅格地图中的概率密度，点云位姿作为参数块，使用牛顿法找到这个概率密度的最大值，最终得到后验位姿。
由于使用正态分布概率密度函数描述点云的局部性质，因此概率密度函数的导数和偏导数可以通过解析法进行求解，所以可以计算出牛顿法中所需要的海塞矩阵和雅克比矩阵。
牛顿法迭代公式推导 第二帧点云在栅格地图中的概率密度为：
对概率密度取负号，通过牛顿法找到最小值。对于牛顿法每次迭代，需要求解增量方程：
因此需要求解海塞矩阵和雅克比矩阵，得到增量后更新位姿，不断迭代，直到增量位姿小于一定阈值，说明收敛。
对于点云中一点，他在栅格内关于均值的坐标为：
因此这个点的概率密度为：
通过链式求导，概率密度关于位姿的导数等于概率密度关于点激光点局部坐标的导数乘以激光点局部坐标有关位姿的导数，因此可得到雅克比矩阵
其中，激光点局部坐标有关位姿的导数为：
海塞矩阵:
NDT算法特点： 不需要进行点云之间的特征匹配，避免了特征匹配中出现的问题。使用正态分布概率密度函数描述点云的局部性质，因此所有导数都可以通过解析法求解，因此计算结果准确并且比较快。可能存在的问题：点云是否可以通过局部正态分布描述？ ICP 简介 ICP通过迭代的方式，通过优化相对位姿，不断减小两帧点云之间点到点的距离，直到迭代收敛，最终计算出两帧点云的相对位姿。ICP分为特征匹配、位姿优化两个步骤。
由于无法像视觉SLAM提供准确的特征匹配关系，因此对于基于激光点云的经典ICP来说，使用点到点的最近距离进行特征匹配。使用ICP算法配准源点云和目标点云，对于源点云中每个点，找到它在目标点云中最近的点，如果这两个点的距离小于阈值，则将这两个点作为匹配点，计算出所有匹配点之后，最终可以获得源点云与目标点云的匹配关系。
获得两点云的匹配点之后，构建非线性最小二乘问题，参数块是两点云之间的相对位姿，残差是所有匹配点之间的距离的和，可以通过优化或者解析的方法计算最优位姿变换（例如基于SVD的解析方法），并不断进行特征匹配、位姿优化的迭代，直到满足收敛条件，最终计算出两点云的相对位姿。
位姿优化 公式推导思想 首先计算两点云的去质心坐标点云，然后两点云的旋转由去质心坐标点云求解，两点云的位移由经过旋转后的质心坐标求解，因此将将旋转和位移的求解分割为两个步骤。
详细推导 对于点云中每个匹配特征点，代价函数为：
由于两帧点云完成匹配后相互重合，因此两点云的质心坐标是相同的，因此首先计算两点云的质心坐标，然后计算出质心坐标下的两个点云
所以代价函数就成为质心坐标下的两点云匹配点的和：
所以将最小二乘问题转换为两步，首先根据质心坐标下的代价函数求得相对姿态，然后相对位置就是经过相对姿态变换后两点云坐标的差
计算
对H矩阵进行SVD分解，计算
如果行列式为1，说明X为相对姿态，然后求得相对位姿
SVD公式推导 思想 最后代价函数可转换为旋转矩阵与去质心坐标矩阵乘积的迹，由定理可知，正定矩阵的迹要大于任意正交矩阵乘以正定矩阵的迹，因此找到旋转矩阵R，可转换为正定矩阵的行驶，就求得了所需要的旋转矩阵。
对H矩阵进行SVD分解，取正交矩阵为SVD分解后的矩阵，然后回带，会发现转换为了正定矩阵的形式。
详细推导 质心坐标系下代价函数可写为
可以看到，最小化代价函数等价于最大化
通过对H的SVD分解，可以得到
因此令R等于
即可求得非线性最小二乘问题的最小值
TODO：如何理解通过SVD求最大值？
ICP和NDT算法之间的优劣 ICP相比NDT，更容易受到初值误差的影响，当初始误差较大时，ICP更容易出现无法计算位姿的情况。
NDT相比ICP，旋转误差更大。因此ICP对旋转的约束更强，NDT对初始误差的健壮性更强。[1]
NDT的匹配速度要比ICP块，NDT的时间复杂度为O(N)，其时间复杂度与点云的数量成正比，ICP的时间复杂度是O(NlogN)，即通过KD树进行查找的时间复杂度。
由于ICP是进行点云中点到点的匹配，而NDT是将点云转换为分段连续的正态分布函数，因此NDT对动态物体干扰的抵抗力更强。
由于NDT对初始误差的敏感度较低，因此当速度较快时，运动方程无法提供准确的先验位姿，此时NDT的效果要由于ICP。
当环境中缺少垂直特征时，NDT相比ICP会提供更好的约束，原因是NDT使用栅格正态分布描述点云的局部性质，因此稀少的垂直特征可以体系在某些栅格的正态分布中，而ICP使用点云之间点到点的匹配，垂直点特征的影响会被大面积水平点特征减弱。[2]
[1]Evaluation_of_3D_registration_reliability_and_speed_-_A_comparison_of_ICP_and_NDT
[2]3D Scan Registration Based Localization for Autonomous Vehicles – A Comparison of NDT and ICP under Realistic Conditions
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d122f80c333867cf803ba4dc52c94f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e2bed5c56acb1cc8bf4ed07e42274c/" rel="bookmark">
			LDPC编解码初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前SSD中ECC纠错代码主要两种BCH和LDPC。不过，随着SSD对ECC纠错技术要求越来越高，BCH纠错码开始有些吃力，所以，LDPC纠错码是发展趋势，也是最新最主流的纠错码。
为何需要LDPC？ 我们先回顾一下NAND闪存的基础知识。在这里以MLC NAND为例。在MLC NAND中，有四个Vt level. 如下图，
随着P/E cycles的增加，MLC NAND的vt电压分布就会变大变宽，如下图，
当P/E cycle到了一定的数值之后，MLC NAND不同vt level之间就会有交叉，这样的话，就会引起数据读取错误，这时，就需要请出LDPC纠错码了。
LDPC编码 LDPC，是Low Density Parity Check Code的简称，翻译为中文就是“低密度奇偶校验码”。在1963年，LDPC第一次出现在R.G.Gallager博士发表的论文之中。LDPC码是一种稀疏校验矩阵线性分组码。为何称为“稀疏”呢？因为校验矩阵中的1要远小于0的数目，这样做的好处就是，译码复杂度低，结构非常灵活。
在LDPC编码中，会用到一个叫做H矩阵的校验矩阵(Parity Check Matrix)，比如，我们来看一个交单的H矩阵：
为了可以更加直观的理解H矩阵，可以借助Tanner图，来表示H矩阵：
左侧V1~V7是变量节点，右侧C1~C3是校验节点。变量节点和校验节点之间的连接线称为沿(edge)，也代表这H矩阵中的1. 每个节点上连接线(edge)的数目称为节点维度(Degree).
LDPC编码分为正则编码和非正则编码。正则编码中，横向和纵向中1的个数是固定的。非正则编码中，横向和纵向中1的个数不固定。举一个例子，正则LDPC编码矩阵：
在这个正则H矩阵中，横向维度Dr=4, 纵向维度Dc=3. Codeword长度=20.
与校验H矩阵对偶的矩阵，称为G矩阵，也是生成矩阵。构建优异的H校验矩阵，是不同SSD主控商实现LDPC的核心内容，每家都有各自的专利。
LDPC解码 在SSD内部的LDPC解码过程中，主要包括了两方面内容：硬解码(Hard Decode)和软解码(Soft Decode). LDPC解码的方法就是收到码字之后，与校验矩阵H相乘，如果是0矩阵，则说明收到的是正确码字。反之，则不正确码字，再根据相乘结果进行进一步纠错解码。
硬解码(Hard Decode):
信息传递(Messag passing)是LDPC硬解码常用的方法。校验节点和可变节点之间传递信息，进行迭代，直至所有的奇偶校验归0，则解码成功。
举个解码的例子：
迭代1：第一次信息传递迭代之后，Hard decode解码，此时n0,n4,n6仍为1.
迭代2：第二次信息传递迭代之后，Hard decode解码，此时n0仍为1.
迭代3：第二次信息传递迭代之后，Hard decode解码，奇偶校验归0.
软解码(Soft Decode):
软解码的原理是调整不同read level，根据读取结果后，判断bit是1或者0的概率，然后根据1或者0概率实现软解码, 如下图。
结语 本文我们简单的阐述了为何需要LDPC，LDPC编解码的基本原理。小编在此抛砖引玉，欢迎各位看官拍砖讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4de2dbb96a3a6d58f97d5217821017/" rel="bookmark">
			Python网络爬虫及自动化--获取页面cookie、headers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Selenium库webdirver类 1、获取cookie，driver.get_cookies() 报错信息：
说明是驱动问题， 驱动和浏览器不匹配，且提示不要用64位ie驱动ie10or11，即使是在64位的电脑上。
IE驱动包下载地址：
https://github.com/SeleniumHQ/selenium/wiki/InternetExplorerDriver
下载替换IEDriverServer.exe，ok！
然后将获取的cookies转换:
cookie = [item["name"] + "=" + item["value"] for item in cookies ] cookiestr = ';'.join(item for item in cookie) headers_cookie ={ "Cookie": cookiestr # 通过接口请求时需要cookies等信息 } response = requests.post(url, data=body, headers=headers_cookie) 这样就可以在做UI自动化的时候，通过接口获取到数据来进行相关测试。
获取包含选中元素的HTML：get_attribute('outerHTML')
获取元素内的全部HTML：get_attribute('innerHTML')
获取元素标签的内容：get_attribute(‘textContent’)
元素没找到返回&lt;class 'NoneType'&gt;
2、获取请求headers， # 获取请求头信息 agent = driver.execute_script("return navigator.userAgent") print(agent) # 查看请求头是否更改。 注意：由于IE浏览器安全设置，driver.page_source为空，By.ID等无法定位元素
改用FireFox，使用driver.find_element定位元素需要等待页面加载结束，使用time.sleep(2)等待
from selenium import webdriver #导入驱动模块 from selenium.webdriver.common.by import By import time driver =webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4de2dbb96a3a6d58f97d5217821017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1395bdf031b1bebba04ed327a1a5ce2/" rel="bookmark">
			python中daemon的含义以及进程与线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于daemon
python线程的daemon选项作用 ：daemon是守护的意思,当daemon赋值为True时,进程不会等到线程的结束,进程一结束,线程也会结束;当daemon赋值为False时,进程会等线程执行结束再退出。打个比方,daemon为False,就相当于领导等员工活干完了,才下班;daemon为True,就相当于领导一走,员工也马上撤了,如果不设置,默认领导是会等员工再走的。
二、关于进程与线程
线程定义：
1.线程是操作系统中能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
2.一个线程指的是进程中一个单一顺序的控制流。
3.一个进程中可以并发多条线程，每条线程并行执行不同的任务。
进程定义：
1，程序：我们编写的程序用来描述进程要完成哪些功能以及如何完成。
2，数据集：数据集则是程序在执行过程中需要的资源，比如图片、音视频、文件等。
3，进程控制块：进程控制块是用来记录进程的外部特征，描述进程的执行变化过程，系统可以用它来控制和管理进程，它是系统感知进程存在的唯一标记。
二者区别：
1、运行方式不同
进程不能单独执行，它只是资源的集合。
进程要操作CPU，必须要先创建一个线程。
所有在同一个进程里的线程，是同享同一块进程所占的内存空间。
2、关系
进程中第一个线程是主线程，主线程可以创建其他线程;其他线程也可以创建线程;线程之间是平等的。
进程有父进程和子进程，独立的内存空间，唯一的标识符：pid。
3、速度
启动线程比启动进程快。
运行线程和运行进程速度上是一样的，没有可比性。
线程共享内存空间，进程的内存是独立的。
4、创建
父进程生成子进程，相当于复制一份内存空间，进程之间不能直接访问
创建新线程很简单，创建新进程需要对父进程进行一次复制。
一个线程可以控制和操作同级线程里的其他线程，但是进程只能操作子进程。
5、交互
同一个进程里的线程之间可以直接访问。两个进程想通信必须通过一个中间代理来实现。
进程与线程复制自：
原文链接：https://blog.csdn.net/weixin_46837674/article/details/114294502
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d656f5c4996f6ffc760f97c80fbee28/" rel="bookmark">
			新手小白一行代码快速生成HTML代码块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HTML下有head和body标签 html&gt;head+body 2、HTML下有head和body，head下有title和meta
html&gt;head&gt;title+meta^body 这里的body和head是同一级别 所以要从meta这一层中跳出 意思就是：html下有head，head下有title和meta ，但是我要在head后边再写一个body，
那就要让body从meta这层中跳出，回到head层
3、如果小白不会“跳”，那还有下边的方法
html&gt;(head&gt;title+meta)+body 4、练习
html&gt;(head&gt;meta+title)+(body&gt;video+div*2+button*11)+script html&gt;head&gt;meta+title^body&gt;div*2+video+button*11^script 5、元素关系
child 子元素
sibling 兄弟元素
parent 父元素
parents 祖父元素
以上图代码为例
body是p的父元素
a是p的子元素
head和body是兄弟元素
body是a的祖父元素
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c626f5a48956cb177f00e8d4e9c6d290/" rel="bookmark">
			Idea修改了.vmoptions文件导致 Idea 无法启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决因为修改IDEA中的.vmoptions中的配置信息导致IDEA无法启动的现象 刚刚自己在弄IDEA激活码时，需要修改IDEA菜单中的 Help -&gt; Edit Custom VM Options 文件中的路径，修改完之后，重启后就打不开IDEA了，真的很懵啊，然后我参考了一个比较好的解决方案，就是下面这个博客-----&gt;Idea修改了.vmoptions文件导致 Idea 无法启动的解决方案
下面的内容是我自己的理解：
1、现象 在IDEA的菜单上help-&gt;Edit Custom VM Options菜单下，修改了.vmoptions配置信息，重启后没有反应，尽管重启多次也无法解决。
2、解释 在修改文件的时候，配置信息写的不正确。在IDEA的bin目录下（这个得找到IDEA的位置），有 idea64.exe.vmoptions 或 idea.exe.vmoptions 配置文件（不要直接修改），修改了，在idea已经启动着的情况下，下次加载也不会去加载这个文件。
问题也就出现在这个地方，idea的vm配置数据与配置文件的不一致，导致无法正常启动。
3、正解 不要直接修改bin目录下的 idea64.exe.vmoptions 或 idea.exe.vmoptions 文件
使用IDEA 自带菜单中的 Help -&gt; Edit Custom VM Options 来进行参数个性化配置。
4、解决 idea启动之后，会生成一个临时生成文件，需要找出来，然后删除掉。
例如我本地临时生成文件的位置是：
C:\Users\admin（这个用户名不同，其他都差不多）\AppData\Roaming\JetBrains\IntelliJIdea2021.2（一般来说都除了admin不同，其他都是一样的，如果你们有问题，可以照着这个路径来，应该不会有错，或者按照全局搜索也行）
具体在哪个位置可以全局搜索下vmoptions即可，大胆删，不会有事，哈哈，每次总结，对自己以后的学习有帮助，当我们下次遇到这个问题时，就可以快速解决了，或者，别人有需要的时候就可以帮忙了，还有不懂得咱们可以讨论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674d9368871e2a9ce238108412863976/" rel="bookmark">
			电影票房预测-kaggle项目Python项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究问题：如何根据电影上映前的一些信息来预测出该电影的票房。
数据来源
数据主要是电影数据库中的 7000 多部过去电影的元数据。提供的数据信息包括演员，工作人员，情节关键词，预算，海报，发布日期，语言，制作公司和国家等。
数据导入 还是之前一模一样的操作
#数据导入 import pandas as pd df = pd.read_csv("https://labfile.oss.aliyuncs.com/courses/1363/TMDB.csv") df.head() #数据查看 df.shape df.info() df.describe() df.describe(include=['O']) #查看一下票房前10的电影 df.sort_values(by='revenue', ascending=False).head(10)[ ['title', 'revenue', 'release_date']] 数据预处理 数据预处理：数据清洗+填充空缺值等
上映时间
release_date为电影的上映时间列，对该列进行处理。将时间中的年、月、日这些信息都分别提取出来。
def date_features(df): df['release_date'] = pd.to_datetime(df['release_date']) # 转换为时间戳 df['release_year'] = df['release_date'].dt.year # 提取年 df['release_month'] = df['release_date'].dt.month # 提取月 df['release_day'] = df['release_date'].dt.day # 提取日 df['release_quarter'] = df['release_date'].dt.quarter # 提取季度 return df df = date_features(df) df['release_year'].head() 检查是否存在异常值，即电影上映时间超过 2019 年，因为收集的数据是 2019 年之前的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/674d9368871e2a9ce238108412863976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c739bb21b056fe4066bf62f1cfbf84/" rel="bookmark">
			css知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.css概述 css是Cascading Style Sheets(级联样式表)
css是一种样式表语言,用于为HTML文档控制外观,定义布局.
可将页面的内容与表现形式分离,页面内容存放在HTML文档中,而用于定义白线形式的css在一个.css文件中或HTML文档的某一部分
HTML如同网页的骨架,css如同修饰骨架的装饰品(样式)
2.基本语法 1.行内样式表 行内样式表,又称内联样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式
基本语法为:&lt;标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"&gt; 内容
&lt;p style="width: auto;"&gt;行内样式表&lt;/p&gt; 2.内嵌样式表 内嵌式是将css代码集中写在HTML文档中的head头部标签中,并且用style标签定义
&lt;style&gt; div{ background-color: brown; width: 200px; height: 400px; } &lt;/style&gt; 3.外部样式表 外部样式表是将所有的样式放在一个或多个以.css为扩展名的外部样式表文件中,通过link标签将外部样式表文件的链接到HTML文档中
使用link（链接）标签 : &lt;head&gt; &lt;link href="newstyle.css" rel="stylesheet" type=" text /css"&gt; &lt;style type=" text /css"&gt; &lt;/style&gt; &lt;/head&gt; 4.各表的优缺点 样式表优点缺点使用情况控制范围行内样式表书写方便没有实现样式和结构相分离较少控制一个标签(少)内部样式表部分结构和样式相分离没有彻底分离较多控制一个页面(中)外部样式表完全实现结构和样式相分离需要引入最多,强烈推荐控制整个站点(多) 3.选择器 标签选择器:通过标签选择器可以选择页面中的所有指定标签 语法:标签名{}
div{ background-color: brown; width: 200px; height: 400px; } 类选择器:通过标签的class属性值选中一组标签 语法: .class属性值{}
.box-1{ float: left; color: red; font-weight: 200; font-size: 30px; padding: 25px 25px; height: 50px; text-align: center; } id选择器:通过标签的Id属性值选中唯一的一个标签 语法: #id属性值{}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c739bb21b056fe4066bf62f1cfbf84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e562f917620add570e719e323034b0de/" rel="bookmark">
			pulp求解简单线性规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 pulp非整数约束整数型约束求解状态的一些解释例题1例题2 参考 pulp PULP是一个线性规划(Linear Programming, LP)问题求解库。它将优化问题描述为数学模型，生成MPS或者LP文件，然后调用LP求解器，如CBC、GLPK、CPLEX、Gurobi等来进行求解。
安装完pulp库默认就拥有了CBC求解器，其他求解器需要额外安装才能使用。
pip install pulp 即可
看一个例题即可：
非整数约束 from pulp import LpVariable, LpMaximize, LpProblem, value, LpStatus # 第一个参数为这个问题取名字，第二个参数表示求目标函数的最大值（LpMinimize） prob = LpProblem('max_z', sense=LpMaximize) # name为变量名， lowBound为下边界，None为没边界 x1 = LpVariable(name='x1', lowBound=0, upBound=None) x2 = LpVariable('x2', 0, None) x3 = LpVariable('x3', 0, None) # 设置目标函数 prob += 2*x1+3*x2-5*x3 # 约束条件 prob += x1+x2+x3 == 7 prob += 2*x1-5*x2+x3 &gt;= 10 prob += x1+3*x2+x3 &lt;= 12 status = prob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e562f917620add570e719e323034b0de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e1d7ce634442d0ee86cf8423873dcc/" rel="bookmark">
			c# 制作一个简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示如下：
代码：
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace june3 { public partial class Form1 : Form { int zhi;//加减乘除号的选择 double a, b;//输入前和输入后的值 double c;//等于DEL时上一个数值 public Form1() { InitializeComponent(); } /*—————— 加减乘除按钮和清零，小数，DEL按钮的功能 ——————*/ private void b_qing_Click(object sender, EventArgs e)//清零功能 { text1.Text = "0"; } private void b_xiaoShu_Click(object sender, EventArgs e)//小数功能 { if (text1.Text.Contains("."))//Contains: 判断某一个字符串中是否包含某一个字符串，结果是布尔类型 { } else { text1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e1d7ce634442d0ee86cf8423873dcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5a7fa6b2d5db3e214380eb68e3f541/" rel="bookmark">
			Vue报错：Error in render: “TypeError: Cannot read properties of null (reading ‘name‘)“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错：Error in render: "TypeError: Cannot read properties of null (reading 'name')" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c439f1530d8071272a66a0d1973c8230/" rel="bookmark">
			文本文件的读取&#43;操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本文件的读取一般使用如下三个方法：
1.read([size]):从文件中读取size个字符，并作为结果返回，如果没有size参数，则读取整个文件，读取到文件末尾，会返回空字符串
2.readline():读取一行内容作为结果返回，读取到文件末尾，会返回空字符串
3.readlines():文本文件中，每一行作为一个字符串存入列表中，返回该列表
操作：
# 读取一个文件前四个字符 with open(r"b.txt", 'r', encoding="GBK")as f: print(f.read(4)) # 文件较小，一次将文件内容读入到程序中 with open(r"b.txt", 'r', encoding="GBK")as f: print(f.read()) with open(r"b.txt", 'r', encoding="GBK")as f: print(f.readline()) with open(r"b.txt", 'r', encoding="GBK")as f: print(f.readlines()) # 使用迭代器（每次返回一行）读取文本文件： with open(r"b.txt", 'r', encoding="GBK")as f: for line in f: print(line) # 按行读取一个文件 with open(r"b.txt", 'r', encoding="GBK")as f: while True: line = f.readline() if not line: break else: print(line, end='') # 为文本文件每一行的末尾添加行号 with open("b.txt", 'r', encoding="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c439f1530d8071272a66a0d1973c8230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ad404fb77f1fd65410b34559a81057/" rel="bookmark">
			【CTF】buuctf web 详解（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最后 深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
小编已加密：aHR0cHM6Ly9kb2NzLnFxLmNvbS9kb2MvRFVrVm9aSGxQZUVsTlkwUnc==出于安全原因，我们把网站通过base64编码了，大家可以通过base64解码把网址获取下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f099cc89fca5b8ea116192eed02a83d6/" rel="bookmark">
			Android Studio 项目引入ProtoBuf(附序列化与反序列化)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直听说protobuf的优点 体积小 速度快 是这个的几十倍 那个的上百倍，一直以来的项目场景也很少遇到需要如此高性能的通信，但是也需要研究一下，万一哪天要写个 IM 呢，神器 就是神器。
首先呢，要去 https://github.com/protocolbuffers/protobuf/ 下载源码和编译器 （根据自己的环境）
protobuf-3.21.5 protoc-21.5-win64
因为后面需要用到mvn package 去编译项目，所以提前配置好 maven，这里就不说了。
把 protoc.exe 复制到 \protobuf-3.21.5\src 目录下
打开CMD 进入 protobuf-3.21.5\java 目录下， 输入命令: mvn package 也可以直接进入此文件夹中按住shift+鼠标右键选择在此处打开命令窗口再输入命令，然后要等待一会，最终出现了成功的窗口 如图
生成的文件在 protobuf-3.21.5\java\core\target 中，我的叫protobuf-java-3.21.5.jar 如图：
这个jar包就是我们想要的东西了，把它放到你工程的libs下面就可以了，别忘了让工程添加依赖！
下面就可以把proto变成JAVA文件了！随便写了一个proto 如下图： 然后运行命令 protoc.exe --java_out=protoout person.proto 第一个路径是要输入到的目录，第二个路径是protobuf的文件（这里我都放在一个目录下了）
执行后看结果
已经成功输出了！然后把这个文件放入工程里吧，要跟上面proto里包的目录一致！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250a68b488ec239426e9b74f0888506d/" rel="bookmark">
			c#中 .length和length()的差别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.leng是成员属性 ，而length()是Array中的一个成员方法
在c#中用.length对数组使用得到的是元素总数，对字符串使用得到的字符串长度。
在c#中不接受直接用length()方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0adca90b8fc3f11b282bdef1e2b74fc0/" rel="bookmark">
			数学编辑器——AxMath
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件下载地址：
链接：https://pan.baidu.com/s/1RSjyVJHy-7MWLEU7jZ1PLA 提取码：2022
1.解压后双击安装： 接受，
选择安装目录，（记一下这个目录，后面会用到） 2. 复制下载包里Crack中的安装文件 将Crack目录的文件替换到安装目录
以下为安装目录：
将上面的exe文件复制替换到这里就好了。
3.安装成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f07bbf1bb2bd59f88c31f822080403/" rel="bookmark">
			【开学征文】新生入学，盘点一下我的大学计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#新学期，新FLAG#
目录
一、前言
二、行业环境分析
三、自我盘点
四、解决自我盘点中的劣势和缺点
一、前言 谁都想活的精彩，都希望有一个新奇而又美好的明天，所以一直都在为心中的梦想而努力、而奋斗拼搏。大学生职业规划的另一个解释，就是用我们手中的画笔，描绘出我们心中的蓝图。我们对自己的职业生涯进行规划，就是放飞自己的梦想，去遨游寰宇。远大的理想总是建立在坚实的土地上的，青春短暂，人生易逝。可未来却是掌握在我们自己手中，从现在起，就力争主动，好好规划一下未来的路，去书写心中的梦想。作为当代大学生，若是带着一脸茫然，踏入这个拥挤的社会怎能满足社会的需要，使自己占有一席之地?因此，我试着为自己拟定一份职业规划，为将自己的未来好好的设计一下。漫漫人生，唯有急流勇进，不畏艰险，奋力拼搏，方能中流击水，抵达光明彼岸。大学期间，正是我奋力拼搏的大好时期，因此要有正确的理想和信念，它们是我乘风破浪，搏击沧海的灯塔和动力之源。人无远虑，必有近忧。成大事者，须立长志。
二、行业环境分析 说说我们现在的就业环境吧，二十一世纪进入信息时代，席卷全球的信息科技给人类的生产和生活方式带来了深刻的变革，信息产业已成为推动国家经济发展的主导产业之一。目前，中国软件产业还处于成长期，其市场潜力还远远没有挖掘出来。2012年左右，中国软件产业将步入成熟期。IT产业作为知识密集、技术密集的产业，其迅猛发展的关键是有一大批从事IT技术创新的人才。一定数量、结构和质量的IT人才队伍是IT产业发展的支撑，一个国家的IT人力资源储备、IT人才培养及使用状况决定着该国IT产业发展的水平和潜力。也可以说，IT产业的竞争就是人才的竞争，高水平的IT人才培养和队伍建设是走向IT产业大国和强国的前提条件。所以，无论是从大的方向讲，还是从小的方面讲，培养和储备高素质的IT人才都显得非常重要。
市场需要的是计算机专业人才，而很多计算机专业毕业的学生都不能满足市场的需求，所以才会有抱怨计算机专业就业难的说法。解决办法还是靠自己吧，大学四年，不要像上面说的无所事事，对自己的专业有所熟悉并且精通一个方向，相信前途会是美好的。
三、自我盘点 1、优势盘点：
小时候的生活条件虽然有些艰苦，却让我养成了不怕吃苦，刻苦奋斗，愈挫愈勇的良好品格。人生漫漫，难免去经历风吹雨打，面对纷繁复杂、竞争激烈，这些品格将永远伴随我，是我取得成功的重要保证，同时也是我人生中一笔弥足珍贵的巨大财富。
2、劣势盘点：
有时候不爱接受批评，推卸责任，明明是我的不对，却想法推卸到别人身上。现在虽然不那么严重了，但有时还是会有的。还有因为来自农村，没有经济基础，这决定了我的事业的起点相对而言要低，要做相对较长时间的物质积累，才能去实现心中的种种梦想。而且，到目前为止，还没有任何的工作经验，各类的荣誉证书也太少。而且目前我的专业课也不是很突出，这无疑为今后的求职之路带来一定的阻力。
3、优点盘点：
本人活泼开朗，乐观;善于坦诚待人，结交朋友，喜欢助人为乐，善于学习，时刻积累知识;善于组织活动，有一定的领导能力;容易与人相处，合作和适应能力强，喜欢与人共同工作;而且，我口齿伶俐，胆大，动手能力较强做事认真、投入，有毅力、有恒心，能坚持目标，另外有一股不服输的屈脾气。
4、缺点盘点：
做事不够细心，精力不够集中，效率不高，态度也不够专注。有时候也比较怀疑自己的能力，面对重大事情总是犹豫不决，于是很多情况下会坐失良机，另外还爱幻想，惰性较大，行动更不上思想。有时候说话过于直率，有时候还会有点霸道，总不能三思而后行，对此我深感悔恨。
四、解决自我盘点中的劣势和缺点 面对上面的自我分析，我想起自己走过岁月中的点点滴滴，心中不禁有些惭愧。我对自己以往在学业、文体、社团活动中的表现不是很满意。我发现我自己惰性较大，平日里总有些倦怠、懒散，学习、倘若不改正，这很可能会导致我最终庸碌无为。不过还好，我还有改进的机会！
否则，岂不遗憾终生?
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ac5acbea37111ca5cc64626ebdec4e/" rel="bookmark">
			备战数学建模1——MATLAB矩阵，二维图、三维图！（超级全面易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、矩阵超级基础的内容1.创建一个1行6列的矩阵2.对矩阵中每个元素都加33.plot函数作图。4.多维矩阵与常见运算5.矩阵乘法，和矩阵点乘6.使用矩阵A对方程A*x= b求解7.Matlab的迁就补全（标量非标量，不同维度） 二、Matlab四种常见二维图1.线图2.条形图3.极坐标图4.散点图 三、Matlab三维图1.三维曲面图2.画子图（几个图画在一张画布上） 一、矩阵超级基础的内容 1.创建一个1行6列的矩阵 a =[1 2 3 8 7 4] 2.对矩阵中每个元素都加3 (线代里面只有和规格的才能加减)
在Matlab里面，如果一个操作数是标量，而另一个操作数不是标量，MATLAB会将该标量隐式扩展到与另一个操作数具有相同的大小
b=a+3 结果：
a = 1 2 3 8 7 4 b = 4 5 6 11 10 7 3.plot函数作图。 以索引为横坐标。索引就是该数字在矩阵里是"第几个"
plot(b) grid on grid on 是添加网格线的意思
索引为横坐标，数组的值就是函数的纵坐标值
4.多维矩阵与常见运算 以空格或逗号分隔同一行元素， 分号分隔各行
常见运算:转置、取逆、求特征值和特征向量
A = [3 2 1;2 4 1;3 9 2] B = A' %求转置矩阵 [D,V] = eig(A) %特征值 特征向量 E = inv(A) %求逆矩阵 F = A*E %验证结果是否为单位矩阵 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ac5acbea37111ca5cc64626ebdec4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60371c17c36a6e8b5ea7a25572235909/" rel="bookmark">
			基于Springboot的调查问卷管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【毕业设计】基于Springboot的在线调查问卷系统
主要看视频上的演示吧
1、在线调查模块 用浏览器打开系统后，使用某个普通用户身份登陆系统，确保已经在“问卷管理页面”使问卷得到“启用”，且“问卷权限分配”将对应调查对象添加成功后，在问卷首页通过调查范围的用户登陆后可进入该问卷进行答卷，非范围内的用户无法答卷，即使获取了该问卷的URL，也会显示没有权限填写问卷（问卷只能提交一次，已完成的问卷不会继续出现在问卷首页）。
问卷作答时，对于选项类问题，多选题选择数量上限有条件限制；对于文本类问题，有文本字数限制。对于数字类问题，验证输入的数字是否超出范围、小数点位数以及文本框内只能输入数字。
问卷提交时，对必答题进行检测，确定所有必答题都已回答，对多选题的下限进行检查，确定符合下限要求，对选项类问题中的“其他”进行检测，确定“其他选项的文本框内有内容”，才能提交成功，否则弹出提示框提示问卷未完成，无法交卷。
2、问卷管理模块 管理员登陆系统后，可以点击首页的管理按钮进入问卷管理页面（管理员只能管理自己创建的问卷，超级管理员可以管理所有的问卷），管理员在管理界面可以进行问卷调查的时间控制、问卷的权限分配、问卷的新增和更新及管理问卷所属问题的具体信息的操作。
问卷新增成功后默认不启用，确定问卷中已有编辑问题且分配了权限则可以启用问卷，如果问卷未编辑问题且没有分配权限则无法启用问卷并弹出提示框。
3、问题管理模块 在问卷管理界面，点击问卷名称即可对相应的问卷页面进行操作，启用状态的问卷编辑页面，只有问卷的统计功能，不能编辑，未启用状态的问卷编辑页面，点击新增按钮，可进行问题的新增操作，可以选择不同的问卷类型，选择问题类型后会出现相应的填写内容；未启用状态下的问卷也可以进行更新，点击要修改的问题，将会出现修改和删除按钮，对问题进行更新或删除。
4、问题统计模块 问题统计是逐题给与统计信息，鼠标移动到要统计的问题上，将会出现统计按钮，点击统计按钮将会出现统计结果显示，统计类型分为：选项类、文本类。
针对选项类，给与每个选项的选择人数，同时可以通过点击人数查看哪些人选择该选项，下方生成一个饼状图。
针对数字类，给予一个柱状图，横轴为数字，纵轴为人数。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/128/">«</a>
	<span class="pagination__item pagination__item--current">129/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/130/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>