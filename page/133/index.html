<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e11d4062c902c6d8623b0a0b4d90e3e9/" rel="bookmark">
			爬虫系列：某家小区房产信息及POI数据获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌵爬虫系列文章
🌴欢迎点赞评论学习交流~
🌱各位看官多多关注哦😘~
🍀本文章只用于学术研究，不可商用！！！
目录
一、前提准备
二、分析网页
三、百度地图POI申请
四、ak调用获取信息
五、数据保存 六、结束
一、前提准备 工具使用：python3.8.5
python库：requests，lxml，pandas库等
二、分析网页 打开链家点击小区跳转至内置网页
我们要获取的数据有以下：
小区名称
小区均价
建筑类型
物业费用
物业公司
开发商
楼栋总数
房屋总数
附近门店
经纬获取
通过Xpath我们可以轻松获取以上内容，Xpath路径如下：
#xpath路径 items = { 'tt':'//div[@class="itemContent"]/span[2]/text()', 'name':'//div[@class="detailHeader fl"]/h1/text()', 'second_url':'//div[@class="title"]/a/@href', 'money':'//div[@class="fl"]/span[1]/text()', 'info':'//div[@class="xiaoquInfoItem"]/span[@class="xiaoquInfoContent"]/text()' '' } #获取数据 name = html_info.xpath(self.items['name'])[0] # 小区名称 money = html_info.xpath(self.items['money'])[0] #单价 /m2 type = html_info.xpath(self.items['info'])[0] # 建筑类型 fee = html_info.xpath(self.items['info'])[1] # 物业费用 company = html_info.xpath(self.items['info'])[2] # 物业公司 developers = html_info.xpath(self.items['info'])[3] # 开发商 sum = html_info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e11d4062c902c6d8623b0a0b4d90e3e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8488be85fb7b6236028bbe8167eef19d/" rel="bookmark">
			SVA断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Assertion介绍什么是assertion？断言覆盖率断言语言的发展与进步类型划分立即断言并行断言并行断言的执行阶段assertion，property，sequencesequences sequence定义基本操作符号and操作符号intersect操作符号or操作符号first_match操作符号throughout操作符号within操作符号if操作符号检测序列的终点局部变量调用方法访问采样方法系统函数和方法 Property使用介绍时钟声明绑定expect语句 Assertion介绍 什么是assertion？ 用来与设计功能和时序做比较的属性描述。断言可以用来完成：
1、检查设计的内容；
2、提高设计的可视度和调试能力；
3、检查设计特性在验证中是否被覆盖。可读性好，因此也可用来服务于设计文档。用来检查算法模型的断言在形式验证中可以穷尽计算，找出可能的违例。可以自由地打开或关闭。一小部分子集甚至可以用来综合或移植到emulation中，用来完成跨平台的移植。 断言覆盖率 仿真工具可以报告断言覆盖率，指示哪些断言没有被触发；帮助检查是否验证计划捕捉到了所有需要的覆盖率；断言覆盖率和功能覆盖率可以共同量化验证进度。 断言语言的发展与进步 Verilog不支持断言，因此需要写过程语句来坐替代；SVA是由一些支持断言的语言进化而来，作为SV相对独立的语言分支。 类型划分 立即断言（immediate assertion）：非时序的；执行时如同过程语句；可以在initial/always过程块或task/function中使用。并行断言（concurrent assertion）：时序性的；关键词property用于区分立即断言和并行断言；并行是因为它们与设计模块一同并行执行。 立即断言 [name:] assert (expression) [pass_statement] [else fail_statement]
time t; always @(posedge clk) if(staet == REQ) assert (req1 || req2) else begin t = $time; #5 $error("assert failed at time %0t", t); end //如果状态为REQ，但req1或req2均不为1时，断言将失败 立即断言可以结合$fatal/$error/$warning/$info给出不同严重级别的消息提示。
always @(state) assert (state == $onehot) else $fatal; 并行断言 base_rule1: assert property (cont_prop(rst,in1,in2)) pass_stat else fail_stat;
property req_grant_prop @(posedge clk) req ##2 gnt ##1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8488be85fb7b6236028bbe8167eef19d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70dd62b40b1b1b10501e585bc7de4b77/" rel="bookmark">
			mac Couldn‘t load OpenSSL lib解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、brew install openssl
2、sudo ln -s /usr/local/Cellar/openssl@3/3.0.5/lib/libssl.3.dylib /usr/local/lib/libssl.dylib
sudo ln -s /usr/local/Cellar/openssl@3/3.0.5/lib/libcrypto.3.dylib /usr/local/lib/libcrypto.dylib
3.pip2 install pyelliptic==1.5.8
--------------发现可以解析ios的日志，解析不了android，搜一又是一顿操作
1、pip2 uninstall pyelliptic
2、pip2 install https://github.com/mfranciszkiewicz/pyelliptic/archive/1.5.10.tar.gz#egg=pyelliptic
3、执行命令会报错
AttributeError: dlsym(0x219f33120, ECDH_OpenSSL): symbol not found
4、重新安装openssl。brew install openssl@1.1
5、rm /usr/local/lib/libssl.dylib
rm /usr/local/lib/libcrypto.dylib
6、
sudo ln -s /usr/local/Cellar/openssl@1.1/1.1.1q/lib/libssl.1.dylib /usr/local/lib/libssl.dylib
sudo ln -s /usr/local/Cellar/openssl@1.1/1.1.1q/lib/libcrypto.1.1.dylib /usr/local/lib/libcrypto.dylib
搞定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b9fed2acc46a42cb16a9d638baee4c/" rel="bookmark">
			用C语言实现菱形的打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们在进行菱形的打印时，要先去寻找规则，找到规则之后就会有了编程思路。
菱形是一个对称图形，我们可以分为上下两层，上层是逐行递增，下层是逐行递减。
#include &lt;stdio.h&gt; int main(void) { int n = 0,i = 0,j = 0; printf("请输入菱形的行数")； scanf("%d",&amp;n); //打印菱形的上层 for(i=1;i&lt;=n;i++) { for(j=i-n;j&lt;n;j++) printf(" "); for(j=1;j&lt;=2*i-1;j++) printf("*"); printf("\n"); } //打印菱形的下层 for(i=n-1;i&gt;=0;i--) { for(j=i-n;j&lt;n;j++) printf(" "); for(j=1;j&lt;=2*i-1;j++) printf("*"); printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bddf91026607183aeb7eb7af904fc0a8/" rel="bookmark">
			ElementUi之dialog弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单独弹窗
&lt;el-button type="text" @click="dialogVisible = true"&gt;点击打开 Dialog&lt;/el-button&gt; &lt;el-dialog :title="title" :visible.sync="dialogVisible" width="30%" :before-close="handleClose"&gt; &lt;span&gt;这是一段信息&lt;/span&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button @click="handleClose"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="dialogVisibleYes"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;script&gt; export default { data() { return { title: ' ', //弹出层标题 dialogVisible: false //是否显示弹出层 }; }, methods: { //取消弹窗 handleClose(done) { this.dialogVisible = true; }, //弹窗确定 dialogVisibleYes() {} } }; &lt;/script&gt; 弹窗套表单
&lt;el-button type="text" @click="dialogVisible = true"&gt;点击打开 Dialog&lt;/el-button&gt; &lt;el-dialog :title="title" :visible.sync="dialogVisible" width="30%" :before-close="handleClose"&gt; &lt;el-form ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bddf91026607183aeb7eb7af904fc0a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79f09e7127d7e2f566c2b1df13cfdde/" rel="bookmark">
			seismic_unix安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Seismic unix seismic_unix安装教程 本教程适用于公共主机安装，安装在/opt下,普通用户也可以添加路径运行su
参考链接
1、下载安装文件 nextcloud.seismic-unix.org
Ubuntu18.04 推荐安装 cwp_su_all_44R18.tgz
2、创建安装文件目录/opt/cwp sudo mkdir /opt/cwp 3、进入下载目录，解压文件到安装路径/opt/cwp gunzip cwp_su_all_44R18.tgz sudo tar -zxvf cwp_su_all_44R18.tar -C /opt/cwp/ 4、添加环境变量: 打开/root/.bashrc 末行添加
# set the CWPROOT variable export CWPROOT=/opt/cwp # set the PATH variable export PATH=$PATH:$CWPROOT/bin: 5、测试环境是否成功 输入echo $CWPROOT 输出以下内容即成功
root@509lab:~# echo $CWPROOT/ /opt/cwp/ 6、进入解压后的文件夹cd $CWPROOT/src 编辑下Makefile文件(可以省略) 修改前
#CWPROOT = include $(CWPROOT)/src/Makefile.config 修改后
#CWPROOT = /opt/cwp include $(CWPROOT)/src/Makefile.config 7、安装前更新数据库 sudo apt-get install build-essential sudo apt-get install libx11-dev sudo apt-get install libxt-dev sudo apt-get install libxmu-dev sudo apt-get install libxi-dev sudo apt-get install gfortran 8、正式安装 make install make xtinstall make finstall make mglinstall 9 、检查安装是否成功 执行suplane|suxwigb &amp;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a79f09e7127d7e2f566c2b1df13cfdde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12fe64d707b0ca2770b511726443c1a1/" rel="bookmark">
			【Scala问题大全】每日一题，劝退系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建了一个Scala问题大全的仓库，每日一题，劝退系列。
https://github.com/jxnu-liguobin/daily.question
感兴趣的可以参与哈。
怕暴露水平的，可以进群匿名回答问题。哈哈哈
比如：
【2022-10-02】简述什么是HList，与Tuple区别？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-03】简述什么是STM？解决了什么问题？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-04】简述什么是Fiber？解决了什么问题？与Thread区别？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-05】简述什么是背压（Back Pressure）？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-06】akka：简述actor模型是什么？解决了什么问题？与多线程比较？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-07】akka：简述actor 生命周期？作用，使用场景？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-08】akka：给出一个actor 系统的actor的（树形）层次结构？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-09】akka：简述actor的死信消息和unhandle消息的区别？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-10】akka：如何监听死信消息？ ⭐⭐️⭐️⭐️⭐️
【2022-10-11】akka：比较classic actor和typed actor？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-12】简述zio-stream和akka stream区别？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-13】akka：简述akka-remote的通信原理？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-14】akka：比较一下本地actor（LocalActorRef）和远程actor（RemoteActorRef）？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
【2022-10-15】akka：谈谈ActorSystem对象？classic和typed中的ActorSystem对象有变化吗，请说明？ ⭐⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e419c8d65a9fff4306d2159543ff598e/" rel="bookmark">
			C&#43;&#43;最大公因数、最小公倍数代码实现（比较简单，欧几里得法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家带来的代码微课是最大公因数、最小公倍数比较简单的代码实现（10~20行）
原理：利用欧几里得《几何原本》中的计算替换方法
详细讲解：
今天我们所运用的数学方法名曰：更相减损术（欧几里得辗转相除法）
这其实是一种很简便快捷、重要的方法，他可以快速地帮你求两个数的最大公因数。
实际上，对于两个不同的正整数a,b(a &gt; b)，有一个神奇的公式
gcd(a,b) = gcd(a,a - b) 也就是说，a和,b的最大公因数=a-b的最大公因数。
但是，这种方式仍旧有些许繁琐，于是作者简化了一下
gcd(a,b) = gcd(b,a % b); 现在，我们将它简化为一个函数。
int gcd(int x, int y) { while (y &gt; 0) { int temp = y; y = x % y; x = temp; } return x; } 这，就是最大公因数的快捷方式。
接下来我们就来运用它。
#include &lt;iostream&gt; using namespace std; ​ int gcd(int x, int y) { while (y &gt; 0) { int temp = y; y = x % y; x = temp; } return x; } ​ int main(){ int a,b; cin &gt;&gt; a,b; cout &lt;&lt; gcd(a,b) &lt;&lt; endl; return 0; } 这个草稿存了100多天了，今天给它完结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3c99475cf0558fcbdfbee38eecddfe/" rel="bookmark">
			Maven依赖导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要了解一下POM文件，它相当于是整个Maven项目的配置文件，由XML编写
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;first_Maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/project&gt; 以`project`为根节点，而`modelVersion`定义了当前模型的版本，一般是4.0.0
`groupId`、`artifactId`、`version`这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。
* `groupId` 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是`org.example`，一个组下面可以有很多个项目。
* `artifactId` 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。
* `version` 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新
创建一个`dependencies`节点
&lt;dependencies&gt; //里面填写的就是所有的依赖 &lt;/dependencies&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个`.m2`文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。
导入依赖时会卡顿，建议换个仓库地址
打开IDEA的安装目录，找到`安装根目录/plugins/maven/lib/maven3/conf`文件夹，找到`settings.xml`文件，打开编辑，找到mirros标签，添加以下内容
&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 如果我需要的依赖没有上传的远程仓库，而是只有一个Jar
**system**：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包
&lt;dependency&gt; &lt;groupId&gt;javax.jntm&lt;/groupId&gt; &lt;artifactId&gt;lbwnb&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3c99475cf0558fcbdfbee38eecddfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3698ed811de5ff61784dde5d7523f92f/" rel="bookmark">
			k8s各组件的端口说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		master
node
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d153d8243a50f7103f210a9a1a48a7a5/" rel="bookmark">
			把binary文件转为SU文件/SEGY文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
把binary文件转为SU/SEGY文件
SEGY/SU文件转为binary 其他常用的su小工具，
把binary文件转为SU/SEGY文件 首先，确定好binary文件的快慢轴、大小端以及数据类型。
然后，给binary文件增加道头 suaddhead；
suaddhead &lt; indata.bin ns=3001 &gt; oudata.su 由于suaddhead可以增加的参数有限，在此基础上继续增加其他的道头参数 sushw。比如
sushw &lt; indata.su key=dt a=2 &gt; oudata.su 具体有哪些参数可以填写，查看sukeyword -o。
比如这个dt，单位是us，需要注意一下。2ms的数据要写成dt=2000.
int tracl; /* Trace sequence number within line
--numbers continue to increase if the
same line continues across multiple
SEG Y files.
byte# 1-4
*/
int tracr; /* Trace sequence number within SEG Y file
---each file starts with trace sequence
one
byte# 5-8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d153d8243a50f7103f210a9a1a48a7a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b7c8b8d64011ee68f62bab4918170e1/" rel="bookmark">
			java项目启动端口号被占用，怎么办？1.结束占用此口号的进程 2.为java项目改端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.禁用占用此口号的进程 （两种方式）
（1）从cmd中禁止
1.打开cmd命令窗口
2.输入命令：netstat -ano，列出所有端口的情况。找到被占用的端口。例如 15022
3.输入命令：netstat -aon|findstr "15022" ，查看被占用端口对应的PID（最后一组数字，例如25704）
4.输入命令：tasklist|findstr "25704"，查看哪个进程或程序占用了此端口号
5.输入命令：taskkill /pid “25704” -f ，强制杀死此程序
（2）从任务管理器中禁止
1.打开项目管理器-详细信息
2.找到java.exe程序，右击结束任务即可
2.为java项目改端口号
1.在tomcat的server.xml中改
2.在编辑配置中改
2.在yaml文件中
3.在nacos中改。
具体需要看项目是怎么配置的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6e124b1a51cab02234e2f22253dba5/" rel="bookmark">
			maven 发部release版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 maven会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。
deploy发布
传统的web项目一般会有一个api模块，用于发布对外的RPC接口，如Dubbo。这个时候一般通过发布jar包，提供maven坐标的方式，让别人引入你的依赖。这个时候可以直接通过maven deploy命令直接发布快照版本到私服。
像IDEA这种集成环境，可以通过简单的点击直接发布。
同时需要注意，maven基于 POM文件中的 version来确定你将要发布的 SNAPSHOT还是 release。所以不能瞎命名，容易把不稳定的 jar包发布到 release仓库。
Release命令发布
比较复杂的是通过 mvn release:prepare和 mvn release:perform来发布，这种发布会自动升级版本，不用手动维护POM文件中的version版本。
流程：
发版之前需要保证本地文件提交，否则会导致发版失败 =&gt;发版前要commit发版之前需要保证本地成功执行 mvn checkstyle:checkstyle，否则会导致发版失败(可选)发版之前需要保证mvn仓库无重复版本，git上无重复的Tag，否则会导致发版失败
要清楚本地tag和远程tag发布之前需要保证本地成功执行mvn clean install -Dmaven.test.skip=true，否则会导致发版失败，而且有效性只有一次，修改代码后需要重新执行该命令。发版命令： mvn release:prepare -Darguments="-DskipTests" 预准备mvn release:perform -Darguments="-DskipTests" 发布mvn release:rollback -Darguments="-DskipTests" 回滚命令
关于上面三条命令的更详细解释：
release:prepare这条命令主要是做打包前的准备： 输入对应的release需要打包的版本等信息，如果不输入有默认的内容将需要记录和准备的内容缓存到pom.xml目录下的release.properties文件中在本地和远程库的GIT中打上对应版本的tag
在准备过程中还会run 单元测试等phase，如果没有异常的话可以继续最后一步。如果git还没有commit或单元测试失败会导致prepare失败，这时候你就需要到下面一个命令了。
release:rollback
如果在准备阶段发生错误，或者需要修改某些地方的话。就需要到这个命令了，这个命令执行以后会做以下这些事删除线上git库tag，但是本地库tag没有被删除，需要手动使用git tag -d XXX进行删除。如果不将本地库中的tag删除将会导致prepare失败。删除之前缓存在pom.xml统一目录下的配置
release:perform
如果确认无误了以后，就可以执行perform命令了。这个命令干了以下这些事：验证代码合法性将你之前的1.0-SNAPSHOT改为1.1-SNAPSHOT将1.0版本deploy至scm配置的nexus release库中jar打包上传至nexus库
恭喜，你已经把你的1.0-SNAPSHOT成功的打包成1.0的release版本了。同时你会发现你的pom.xml文件会自动的变成1.1-SNAPSHOT版本。虽然这一系列操作都可以通过手动完成。但是有这个工具的存在，免去了很多步骤。
QA
实际发包过程中，会遇到一些报错，这个时候通过执行 rollback外加删除远程和本地的 tag基本可以解决问题。
参考文献 Maven Release发布指南---Git版Maven deploy部署jar包到远程私仓 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d7cdce3c02e630a3ff5d78814c3180/" rel="bookmark">
			卸载流氓透明APP，帮老人清理手机弹窗广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		症状：只要解锁手机，就时不时弹出广告视频，声音还开到最大，无法关闭。尤其是，每点开一个app，都会弹出广告视频，接打电话也不例外，导致无法正常通话。
在卸载了一切可能的垃圾软件后，症状依旧。这时就考虑是流氓透明软件了。
这种APP没有名称，而且图标透明。这样就在应用商店等正常途径里看不到有这个软件，从而无法卸载。就跟哈利波特穿了隐形斗篷一样，你看不到它的存在。虽然看不到，却是可以摸到的，因为APP虽然透明了，仍然会占据一个位置。
解决办法就是，用一个app，挨个去占手机桌面上的每个空位置，如果占住了，就说明那个位置是空的。如果流氓透明APP在那个位置，则两个app会形成一个文件夹公用一个位置，文件夹里第一个位置是透明图标，也就是要找的流氓软件。第二个位置是测试用的正常显示的app。
注：图片来自网络。
长按已经找到的透明图标，会显示卸载，点击卸载就可以了。需要提醒的是，流氓透明APP可能不止一个，要把手机桌面上的空位置都试一遍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598b03240da8a993b560bfd7fbafcf94/" rel="bookmark">
			HCIE FusionSphere存储虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三天笔记
热迁移
更改主机：虚拟机热迁移
更改数据存储：存储热迁移
更改主机+数据存储：完整迁移
存储热迁移：IO mirror迭代迁移
虚拟机热迁移 虚拟机热迁移定义： 是指将运行中的虚拟机从一台主机迁移到另一台主机上的过程，迁移过程中不中断虚拟机的业务，用户无感知。
虚拟机热迁移原理： 是将一台正在运行的虚拟机从一台主机迁移到另一台主机的过程，迁移过程虚拟机的业务不中断，业务无感知
1、 将虚拟机配置和设备信息传送到目标主机上；
2、 传送虚拟机内存：将虚拟机迁移时的初始内存及内存变更分片同步到目标主机上；
3、 暂停源虚拟机并传送状态，在原主机上暂停虚拟机，将最后的变更内存传到目标主机；
4、 在目标主机上恢复虚拟机，并在原主机上停止虚拟机
虚拟机热迁移约束条件： ① 虚拟机要求：
虚拟机的状态为“运行中”；
虚拟机未绑定图形处理器、USB设备等外设。
② 计算资源要求：
目标主机不能是维护模式；
目标主机要有足够的CPU和内存资源；
当跨集群迁移时，源主机所属集群和目标主机所属集群的内存复用开关设置需相同；
迁移过程，不能下电或者重启源目主机；
如果源主机和目标主机的CPU（指的是同厂商不同代的CPU）类型不一致，需要开启集群的IMC模式。
① 存储要求：
虚拟机磁盘所在的数据存储必须是共享存储。
② 网络要求：
源目主机网络必须互通。
虚拟机热迁移应用场景： ① 主机负载较重或者较轻场景下，通过虚拟机热迁移实现负载均衡；
② 主机进行计划性停机维护；
③ 当多数主机负载过轻时，可以将虚拟机迁移整合，以减少主机数量，提高资源的利用率，实现节能减排。
虚拟机热迁移失败原因： ①源主机和目标主机网络中断或网络不通；
②目标主机无法访问虚拟机的磁盘；
③在迁移过程中源目标主机故障、被重启或已进入维护模式；
④源主机和目标主机的CPU类型不兼容；
⑤目标主机资源不足；
⑥设置了迁移超时时间，迁移时长超过了迁移超时时间。（设置迁移超时时间：创建迁移任务的地方可以勾选）
追问：热迁移数据走的什么网络？ 答：热迁移流量默认走业务管理网络或虚拟化SAN存储心跳网络，也可以单独规划一个网络平面用于迁移业务。
追问：虚拟机热迁移时传递的配置信息和设备信息具体是什么？保存在哪里？ 答：具体指的是虚拟机的操作系统，虚拟机的CPU个数、内存大小、硬盘以及网卡等信息，保存在VRM的数据库中，以及虚拟机所在的CNA上。
追问：VRM虚拟机能否进行虚拟机热迁移？ 答：不能，通过部署工具导入的VRM，会自动与主机绑定，不能迁移。
追问：跨集群迁移为什么要在相同的dvs? 答：因为虚拟机的MAC地址在EVS上，如果MAC地址改变会改变IP寻址，业务会中断。
追问：跨主机热迁移是否一定要共享存储？ 答：不一定，可以不要共享存储，如整机热迁移就不需要（先迁移存储，再迁移虚拟机）
追问：为什么要内存复用开关设置一致？ 答：若不开内存复用，物理内存与虚拟机内存的对应关系是一一对应的，若开启了内存复用，物理内存与虚拟机内存的关系不再是一一对应关系。若内存复用开关不一致，会导致虚拟机迁移失败。
追问：为什么开IMC就能迁移？ 答：IMC可以确保集群内的主机向虚拟机提供相同的CPU功能集，即使这些主机的实际CPU不同，也不会因CPU不兼容而导致迁移虚拟机失败。
追问：如果热迁移过程中失败了，源端的虚拟机会如何？ 答：迁移失败源虚拟机仍然在源主机上运行，目标主机删除虚拟机迁移的数据。
存储热迁移 （这个题一般和虚拟机热迁移一起出现，考试频率高！）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598b03240da8a993b560bfd7fbafcf94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133e1dbcc02edfadf01f450f3fd80d78/" rel="bookmark">
			离散数学——范式（一）定义与求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概览 范式的定义 范式的求解 范式的定义 1.引入范式 对于真值表，n个命题变元，真值表要列出2的n次方个解释。当n的数值过大时，真值表就不再简便，因此引入范式。
范式的定义自下而上， 正如语文中字组成词，词组成句。
命题变元或命题变元的否定称为文字
有限个文字的析取称为简单析取式（子句），要注意有限个包括一个，因此单独的文字也可以称为简单析取式（子句）。
同理，单独的一个文字也可以称为简单合取式（短语）。
2，范式的命名 有限个包括一个，因此一个短语也可以称为析取范式，又因为单独的文字也属于是短语，所以单独的文字也可以称为析取范式。
同理，单独的子句或文字也可以称为是合取范式。
例题解析.(2)将整个命题变元看做一个子句，则这个命题变元又可以称为合取范式；将P,Q,非R都看做短语（文字可以是短语），则整个命题变元可以称为析取范式
（3）将整个命题变元看做一个短语，则这个命题变元又可以称为是析取范式：若把非P,Q,R都看做子句（文字可以是子句），则整个命题变元可以称为合取范式
注意：当整体加上括号后，只能整体来论，不能拆开
因此整体加上括号后的（2）不能称为析取范式；整体加上括号后的（3）不能称为合取范式。
（4）括号内的是一个整体，是子句，把p看做子句，子句和子句的析取啥也不是
范式的求解 1.范式存在定理 熟记逻辑等价公式才能准确快速地将命题公式化成与其等价的析取范式和合取范式
转化的步骤一般为
转化蕴涵关系等价关系否定连接词的转移利用其他逻辑公式将命题公式装化成析取范式或合取范式 2范式求解定理 步骤解析
消去蕴含关系，等价关系使用分配律去掉大括号里面的小括号合并（析取或合取）相同的命题变元（或其否定）一路转化得到最终结果 一般而言，最终得到的合取范式或析取范式都是最简式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25bb42fafb90d919102eba2bc9274cb7/" rel="bookmark">
			ElasticSearch分析器解析(十四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES在文本字段的索引建立和搜索阶段都会用到分析器。分析器一般用在下面两个场景中：
创建或更新文档时（合称索引时），对相应的文本字段进行分词处理；查询文本字段时，对查询语句进行分词。 ES中的分析器有很多种，但是所有分析器的结构都遵循三段式原则，即字符过滤器、分词器和词语过滤器。其中，字符过滤器可以有0个或多个，分词器必须只有一个，词语过滤器可以有0个或多个。从整体上来讲，三个部分的数据流方向为字符过滤器→分词器→分词过滤器。如下所示为一个分析器的构成示例：
文本先以字符流的形式流经字符过滤器，在本例中，在本例中，由两个子字符过滤器组成一个字符过滤器组合。字符过滤器处理完字符后将结果传递给分词器，分词器对文本进行分词处理后将结果又传递给分词过滤器。在本例中，由两个子分词过滤器组成一个分词过滤器组合。最终，分析器输出分词后每个词的信息，至此，一个分析器的处理流程结束。
对于不同的分析器，上述三部分的工作内容是不同的，为了正确匹配，如果在数据写入时指定了某个分析器，那么在匹配查询时也需要设定相同的分析器对查询语句进行分析。
字符过滤器 字符过滤器是分析器处理文本数据的第一道工序，它接收原始的字符流，对原始字符流中的字符进行添加、删除或者转换操作，进而改变原始的字符流。
例如，原始数据中可能包含来自爬虫的结果，字符过滤器可以去除文本中的HTML标签，也可以将原始文本中的一些特殊字符进行转义，如把“＆”转换为and。
总而言之，字符过滤器就是对原始文本做一些粗加工的工作，为后续的分词做准备。
ES内置了一些字符过滤器，其中常用的字符过滤器及其功能如下表所示：
名称功能映射关系字符过滤器根据配置的映射关系替换字符HTML擦除过滤器去掉HTML元素正则表达式替换过滤器用正则表达式处理字符串 分词器 分词器在分析器中负责非常重要的一环工作——按照规则来切分词语。对于英文来说，简单的分词器通常是根据空格及标点符号进行切分。然而对于中文分词来说，字符之间往往没有空格，因此采用英文的切分规则是不可取的。中文分词有多种切分方案。不同的分词器采用的方案不同，处理后的结果也可能不同。分词器对文本进行切分后，需要保留词语与原始文本之间的对应关系，因此分词器还负责记录每个Token的位置，以及开始和结束的字符偏移量。
在ES中内置了一些分词器，其中常用的分词器及其功能如下表所示：
名称功能标准分词器对英文分词时，基于语法分词；对中文分词时，切分成单字字母分词器使用非字母的字符作为分词标记小写分词器功能上等同于字母分词器，并且把所有分词结果转换为小写形式空格分词器使用空格作为分词标记 分词过滤器 分词过滤器接收分词器的处理结果，并可以将切分好的词语进行加工和修改，进而对分词结果进行规范化、统一化和优化处理。例如，它可以将文本中的字母全部转换为小写形式，还可以删除停用词（如的、这、那等），还可以为某个分词增加同义词。
在ES中内置了一些分词过滤器，其中常用的分词过滤器及其功能如下表所示：
名称功能Lower Case过滤器将所有字母转换为小写形式Stop Token过滤器将停用词从分词结果中移除同义词分词过滤器为分词结果添加同义词 分析器的使用 ES提供了分析器的调用API，使用户可以方便地对比不同分析器的分析结果。另外，ES提供了一些开箱即用的内置分析器，这些分析器其实就是字符过滤器、分词器和分词过滤器的组合体，可以在索引建立时和搜索时指定使用这些分析器。当然，如果这些分析器不符合需求，用户还可以自定义分析器。
测试分析API 为了更好地理解分析器的运行结果，可以使用ES提供的分析API进行测试。在DSL中可以直接使用参数analyzer来指定分析器的名称进行测试，分析API的请求形式如下：
POST _analyze { "analyzer": "${analyzer_name}", //指定分析器名称 "text":"${analyzer_text}"//待分析文本 } 以下示例使用standard分析器分析一段英文：
POST _analyze { "analyzer": "standard", "text": "the hotel is not clean" } 上述文本的分析结果如下：
{ "tokens" : [ { "token" : "the", "start_offset" : 0, "end_offset" : 3, "type" : "&lt;ALPHANUM&gt;", "position" : 0 }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25bb42fafb90d919102eba2bc9274cb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ebfe96dc305480bdde63555cb6cbf32/" rel="bookmark">
			2021-07-22
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于stm32的USB HOST MTP协议开发 项目介绍USB 简介枚举过程描述符（Descriptor）配置描述符端点描述符字符串描述符MTP协议MTP协议实现文件的上传与下载功能设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 项目介绍 刚好手头上完成了一个项目，是基于stm32的USB HOST MTP协议开发的项目。现在已经完成移植，做成产品。出于对产品保密考虑，这里只说协议的实现。MTP协议 有专门的USB_MTP协议规范说明:mtp_specification__v1.0 。本次项目是基于ST官方库来做USB主机协议实现的。
USB 简介 USB分为主机host和从机device，单个USB总线上，只能有一个Host，USB中的Host端，负责所有底层的数据传输的控制，本项目把手机做device，单片机做host。当一个USB设备插入主机后，会有以下活动：
当设备插入主机，主机会检测设备的插入，如图：
上图为USB全速设备和高速设备插入检测，当全速设备插入时，D+会被拉高，此时主机检测到有设备插入。
供电；
主机复位；
主机向设备获取Device Descriptor前8个字节信息；
分配地址；
获取Device Descriptor；
获取Configuration Descriptor；
获取String Descriptor ( 可选 )；
配置。
枚举过程 这个很重要，枚举就是主机获得设备的基本信息，知道设备是什么样的设备，如何进行通信，这样主机就可以根据这些信息来加载合适的驱动程序。调试USB设备，很重要的一点就是USB的枚举过程，只要枚举成功了，那么就已经成功大半了。
描述符（Descriptor） 一设备描述符有多个配置描述符，一个配置描述符有多个接口描述符，配置描述符和接口描述符放在一起实现的。一个接口描述符有多个端点描述符。
USB 设备描述符⽰例
下面是 USB 远程 NDIS 以太网设备的示例描述符集。 它包括 CDC 通信类接口和 CDC 数据类接口。 设备描述符 是独立返回的。 配置描述符和所有以下描述符将作为单个块以显示的顺序返回
0 bLength 1 0x12 此描述符的大小 （以字节为单位）
1 bDescriptorType 1 0x01 设备描述符
2 bcdUSB 2 0x0110 1.1-当前版本的 USB 规范
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ebfe96dc305480bdde63555cb6cbf32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3215e15f0e074fe2bd8e46e3dc6d57be/" rel="bookmark">
			HDFS查看文件行数及大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件行数 Linux下的文件行数:
wc -l filename #文件行数 wc -l dirname/* #文件夹内容所有文件行数 hdfs内文件行数:
hadoop fs -cat filename | wc -l hadoop fs -cat 'filename/*' | wc -l #文件夹内所有文件行数之和 详解：
wc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。
参数：
-c或–bytes或——chars：只显示Bytes数；
-l或——lines：只显示列数；
-w或——words：只显示字数。
文件大小 第一种方式:查看当前目录下的各级目录分别大小
hdfs dfs -du -h /user/hive/warehouse/ #查看结果 19.7 K 59.0 K /user/hive/warehouse/hive_test 0 0 /user/hive/warehouse/test_float 67 201 /user/hive/warehouse/test_float2 ... ... /.. #第一列为单个文件实际大小，第二列为备份大小，第三列为详情目录。 第二种方式
hdfs dfs -ls -h /user/hive/warehouse/ drwxrwxrwt - hdfs hive 0 2020-11-09 14:13 /user/hive/warehouse/hive_test drwxrwxrwt - hdfs hive 0 2020-11-20 17:51 /user/hive/warehouse/test_float drwxrwxrwt - hdfs hive 0 2020-11-20 18:05 /user/hive/warehouse/test_float2 #这种方式需要注意：当子文件目录过多时，统计的大小为0。 第三种方式:查看指定目录下的总大小:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3215e15f0e074fe2bd8e46e3dc6d57be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2faf3dc6d8f1a84586403e32d513b21/" rel="bookmark">
			petalinux的介绍和安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		petalinux的介绍和安装 一、简介二、安装1.安装条件2.下载petalinux3.安装petalinux 一、简介 Petalinux是Xilinx公司推出的嵌入式Linux开发套件，包括了Linux Kernel、u-boot、device-tree、rootfs等源码、库，以及Yocto recipes，可以让客户很方便的生成、配置、编译及自定义。
二、安装 1.安装条件 Petalinux作为一款linux开发套件要在linux上安装和使用。
安装要求：
•最低工作站要求：
○ 8 GB RAM（Xilinx ®工具的推荐最低配置）
○ 2 GHz CPU 时钟或等效（最少八个内核）
○ 100 GB 可用硬盘空间
支持的操作系统：
-红帽企业工作站/服务器 7.4、7.5、7.6、7.7、7.8、7.9、8.1、8.2（64 位）
-CentOS 工作站/服务器 7.4、7.5、7.6、7.7、7.8、7.9、8.1、8.2（64 位）
-Ubuntu Linux 工作站/服务器 16.04.5、16.04.6、18.04.1、18.04.2、18.04.3、18.04.4、
18.04.5、20.04、20.04.1（64 位）
2.下载petalinux 一般petalinux可以在官网下载，下载完成后是一个 .run 的文件，要安装petalinux 需要将下载完成的 .run文件传入linux 系统， 这里推荐一款传输文件的软件 FileZilla 只需开启linux 的 ssh 功能，输入指令ifconfig 查看ip 地址，在 FileZilla 中连接linux 即可完成 Windows和linux之前互传文件，非常的方便。
3.安装petalinux 打开利用FileZilla 传输过来的.run文件 安装petalinux需要在非root权限下安装，必须先用 chmod 命令更改.run文件的权限，然后./文件 即可开始安装，过程中 输入y 就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3182c94456df42f6231b5f377339009c/" rel="bookmark">
			如何在 Ubuntu 和其他 Linux 发行版中查看 MAC 地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用命令行查找MAC地址获取蓝牙的MAC地址 使用 GUI 获取 MAC 地址 在学习网络或对其进行故障排除时，需要知道 MAC 地址。 一台计算机可以有多个 MAC 地址。因为MAC地址是联网的核心部分，每个联网外围设备都有自己的MAC地址。
因此，WiFi 卡有一个 MAC 地址，以太网 (LAN) 端口也有。连蓝牙都有。
MAC地址也称为物理地址，是12位十六进制代码（48位），表示为MM:MM:MM:SS:SS:SS 。
使用命令行查找MAC地址 打开终端并使用以下命令，它将在系统中显示当前网卡的地址：
ip link 输出：
通常，无线设备名称为 wlan0、wlan1、wlan2、wlo0、wlo1 和 wlo2，而以太网（有线设备）可能有 eth0、eth1、eno0、eno1、enpls0 或 enpls1。
可以在设备描述的最后一行找到每个设备的 MAC 地址，link/ether 后面的就是我的设备的MAC地址。
获取蓝牙的MAC地址 所有网络设备都有一个物理地址。如果要查看蓝牙适配器的 MAC 地址，可以使用以下命令：
hciconfig 在 BD 地址字段旁边可以看到它。
也可以使用命令bluetoothctl。
使用 GUI 获取 MAC 地址 首先，在系统菜单中打开设置。
对于左侧菜单栏，选择网络并单击位于有线网络切换附近的小齿轮图标。即使没有连接到有线网络，也可以采用相同的方法。
如果使用的是 Wi-Fi，左侧菜单栏中将有一个 Wi-Fi 选项。从那里，按照相同的方法（单击齿轮图标）来获取 MAC 地址。
单击齿轮图标后，将看到所选网络接口的详细信息。在这里，MAC 地址作为硬件地址给出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5b48065ffb66dd078d312c3d971e71/" rel="bookmark">
			Jenkins连接git时出现“Failed to connect to repository : Command ... HEAD“ returned status code 128:”问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题
解决
问题 配置仓库时报错：
Failed to connect to repository : Command "git.exe ls-remote -h -- http://192.168.0.XXX/XXX/cicd.git HEAD" returned status code 128:
stdout:
stderr: remote: The project you were looking for could not be found.
fatal: repository 'http://192.168.0.XXX/XXXX/cicd.git/' not found
解决 原因是我的gitlab仓库设置了权限，改成Public,并保存返回jenkins即可，红色报警消失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6efcc7de830bc386cfed2101743ca6/" rel="bookmark">
			微信第三方平台uni-app配置ext.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、官方链接 链接：小程序运营者，可以一键授权给第三方平台，通过第三方平台来完成业务
二、项目场景 微信公众平台要交给第三方去授权操作，相当于通过后端来通过微信提供的api来进行自定义，那小程序也要去配置一些文件来让后台进行动态的配置一些参数。
三、实现流程 1、vue-cli搭建的小程序的要把ext.json 放在src目录下面
2、Hbuilder X直接创建的需要把ext.json 放在根目录下
3、创建完ext.json文件后，exAppid是模版的id，ext：{} 是我们自己定义的数据可以通过wx.getExtConfigSync() 可以拿到ext：{} 中的数据
export function getExtStoreId(type:any){ try{ let extConfig = wx.getExtConfigSync? wx.getExtConfigSync(): {} console.log(extConfig) return extConfig[type]; }catch(err){ console.log(err,'getExtStoreId__error') } } 然后就可以在需要在需要的地方去动它配置数据，这里动态修改请求地址， 就可以了。
⚠️注意：小程序出现警告导致wx.getExtConfigSync()获取失败的时候，看下你的第三方平台是否绑定了3rdMiniProgramAppid
devtoolsconfig.js?t=wechat&amp;s=1661153035799&amp;v=676c8699f8bc4074222fbfaa7f214adf:3
wx13922a85721bead2 不是 3rdMiniProgramAppid, ext.json 无法生效；查看文档:
“https://developers.weixin.qq.com/miniprogram/dev/devtools/ext.html”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384892fabd0139f55667ed0affcabaca/" rel="bookmark">
			拥抱变化，面向Java17，Java8-18全系列特性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录：
Java 8 新特性Java 9 新特性Java 10 新特性Java 11 新特性Java 12 新特性Java 13 新特性Java 14 新特性Java 15 新特性Java 16 新特性Java 17 新特性Java 18 新特性 💡 文章较长，建议点赞、收藏、评论后慢慢看，合理利用 “只看目录功能”
前言 当我们大部分Javaer还沉浸在Java 8 的特性中时，Java 19 预计在2022年9月20号发布，现在半年发布一次的节奏真让人应接不暇，况且Spring Boot 3.0开始最低版本为Java 17，Spring Security、KafKa等也都宣布在后期版本最低需要Java 17 ，所以我们恶补一下Java 8-18的特性很有必要。
Java 8 新特性 Java 8 带来了大量的新特性。主要分为以下几个方面：语言、它的编译器、库、工具和 JVM（Java 虚拟机）。
这个教程包含Java开发者经常面对的几类问题：
语言编译器库工具运行时（JVM） 感兴趣的话，可以看下官网的描述：
https://docs.oracle.com/en/java/javase/index.html
语言新特性 Lambda表达式和函数式接口 一个概念：函数式接口：只有一个方法的接口。
Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。
它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。
Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt; 符号和语句块组成。
示例1：
Arrays.asList( "a", "b", "d" ).forEach( e -&gt; System.out.println( e ) ); 在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/384892fabd0139f55667ed0affcabaca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e9fa595afad5b907e7ead5f293f7e2/" rel="bookmark">
			分类、目标检测、语义分割、实例分割的区别【搬运】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉的任务很多，有图像分类、目标检测、语义分割、实例分割和全景分割等，那它们的区别是什么呢？ Image Classification（图像分类）（分出人、狗、狼） 图像分类（下图左）就是对图像判断出所属的分类，比如在学习分类中数据集有人（person）、羊（sheep）、狗（dog）和猫（cat）四种，图像分类要求给定一个图片输出图片里含有哪些分类，比如下图的例子是含有person、sheep和dog三种。
Object detection（目标检测）（框出个体） 目标检测（上图右）简单来说就是图片里面有什么？分别在哪里？（把它们用矩形框框住）
目前常用的目标检测算法有Faster R-CNN和基于YOLO的目标检测的算法
semantic segmentation（语义分割）(语义分割分割哪个像素属于哪个物种) 通常意义上的目标分割指的就是语义分割
语义分割（下图左）就是需要区分到图中每一点像素点，而不仅仅是矩形框框住了。但是同一物体的不同实例不需要单独分割出来。对下图左，标注为人，羊，狗，草地。而不需要羊1，羊2，羊3，羊4，羊5等。
Instance segmentation（实例分割）（实力分割 分割像素属于哪个个体） 实例分割（上图右）其实就是目标检测和语义分割的结合。相对目标检测的边界框，实例分割可精确到物体的边缘；相对语义分割，实例分割需要标注出图上同一物体的不同个体（羊1，羊2，羊3…）
目前常用的实例分割算法是Mask R-CNN。
Mask R-CNN 通过向 Faster R-CNN 添加一个分支来进行像素级分割，该分支输出一个二进制掩码，该掩码表示给定像素是否为目标对象的一部分：该分支是基于卷积神经网络特征映射的全卷积网络。将给定的卷积神经网络特征映射作为输入，输出为一个矩阵，其中像素属于该对象的所有位置用 1 表示，其他位置则用 0 表示，这就是二进制掩码。
一旦生成这些掩码， Mask R-CNN 将 RoIAlign 与来自 Faster R-CNN 的分类和边界框相结合，以便进行精确的分割：
Panoramic segmentation（全景分割）(全景分割连背景都要分) 全景分割是语义分割和实例分割的结合。跟实例分割不同的是：实例分割只对图像中的object进行检测，并对检测到的object进行分割，而全景分割是对图中的所有物体包括背景都要进行检测和分割。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c053e96eb4a3c444ff4aeb1d721d50/" rel="bookmark">
			本地模拟生产环境k8s安装部署（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇本地模拟生产环境k8s安装部署（一）_super_1301的博客-CSDN博客主要是环境配置、软件安装，主要是安装了kubeadm、kubelet、kubectl，接下来是用kubeadm创建集群步骤
三、使用 kubeadm 创建集群（参考：使用 kubeadm 创建集群 | Kubernetes）
1、通过官方文档步骤知道 需要从k8s.gcr.io下载镜像，通过ping 发现网络不通
2、生成初始化的配置文件（参考：kubeadm 配置 (v1beta3) | Kubernetes）
查看默认配置
kubeadm config print init-defaults 按照默认配置生成一份配置文件
kubeadm config print init-defaults &gt; kubeadm-config.yaml
修改了2个参数，镜像仓库地址和criSocket
2、执行 sudo kubeadm init --config kubeadm-config.yaml --v=5 先关注下那3个ERROR, 第一个NumCPU ， 说的是cpu个数至少2个,现在是1个
第二个Mem ， 说内存要求至少1700M ，现在是486M
第三个FileContent--proc-sys-net-ipv4-ip_forward ，说的是没有开启路由功能
由于是本地模拟， 第一、二先忽略，第三个配置下
sudo vi /etc/sysctl.d/k8s.conf
修改前
修改后 ： 增加一行 配置 net.ipv4.ip_forward=1
需要重启后才能生效 sudo reboot
在执行一遍 sudo kubeadm init --config kubeadm-config.yaml --v=5 --ignore-preflight-errors=NumCPU --ignore-preflight-errors=Mem
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c053e96eb4a3c444ff4aeb1d721d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc9ff565ac44d5a444a4cd2e0b41b78/" rel="bookmark">
			【java】tomcat配置域名访问并修改端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先修改ip地址访问 打开tomcat安装目录，找到conf文件夹 进入后找到server.xml文件，用文本编辑器打开后如下：
找到&lt;Engine name="Catalina" defaultHost="localhost"&gt;
将localhost修改为你的网站外网ip地址，事例如下：
&lt;Engine name="Catalina" defaultHost="47.111.183.59"&gt;
继续修改内网host映射 找到
&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;
将localhost修改为你的网站外网ip地址，事例如下：
&lt;Host name="47.111.183.59" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt;
配置外网ip地址映射到域名 这个过程各个平台服务器配置过程大同小异，以阿里云为例：
进入阿里云管理后台，打开云解析DNS板块
点击添加域名
在这里添加你申请的外网域名，添加成功后，在列表中会看到添加完成的域名
点击解析设置
点击新手引导
填写服务器外网ip地址后点击确定完成，等待3-5分钟后生效
修改端口号 tomcat默认端口号是8080
我们使用域名访问一般不会输入端口号，这是因为采用了默认的80端口，80端口可以不输入，是个默认值。接下来我们修改服务器端口号为80端口
打开tomcat安装目录，找到conf文件夹 进入后找到server.xml文件，用文本编辑器打开后如下：找到&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;
将8080修改为80，事例如下：
&lt;Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;
最后一步 保存文件内容后关闭，执行一下shutdown，停止tomcat服务器
然后执行startup启动服务器，启动完成后在外网直接访问域名就可以看到tomcat的首页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb519a043c1c4b19b2a7b06047aeec7b/" rel="bookmark">
			Java贪吃蛇大作战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为Java新手小白，渴望学习一些好玩有趣的java程序
废话不多说，接下来我会一步一步实现java小程序：贪吃蛇大作战哦！ 实现 Java贪吃蛇一共分四个步骤：
1、画出窗体对象 2、绘制静态ui 3、使用鼠标监听器事件和定时器事件让小蛇动起来 4、实现吃食物的功能 关于代码中的数值，因为小蛇的素材图片像素为25*25 ，游戏区域灰色方格为850*600
1、绘制窗体对象 使用JFrame这个类，分别设置界面标题、宽度、高度、位置、退出界面以及位置固定，最后将界面显示出来：
public class Main { public static void main(String[] args) { // write your code here JFrame frame = new JFrame("贪吃蛇大作战");//界面标题 frame.setSize(900, 720);//设置宽高 frame.setLocationRelativeTo(null);//布局正中间 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//退出 frame.setResizable(false);//大小固定，不能变化 frame.setVisible(true);//显示 } } 界面如下：
2、绘制静态Ui 新建Panel.java文件，添加如下绘制标题代码，并在Main.java中调用显示：
public class Panel extends JPanel { //由Panel继承JPanel，创建一个画布类 @Override protected void paintComponent(Graphics g) { //方法：绘制，Graphics g是画笔对象 super.paintComponent(g); //绘制顶部标题 //paintIcon()函数可将图片放到对应的容器中去：对象、画笔工具、位置坐标 new ImageIcon("img/title.png").paintIcon(this,g,20,11); } } 调用部分 frame.add(new Panel()); //显示顶部标题 绘制游戏区域，在Panel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb519a043c1c4b19b2a7b06047aeec7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f198f642d11a83876f83673c74013d27/" rel="bookmark">
			【html基础】原生表格一键搭建，一键生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们做网页当中经常要用到表格，当然也有人会选择用div来绘制一个表格。而用div绘制会存在诸多问题，而且也不方便维护。所以表格标签也是我们前端开发必备的技能。
我们先通过guiplan一键插入一个表格模版，
如果看不懂可以看源代码如下： &lt;table id="g570b4"&gt; &lt;tr id="g419fe"&gt; &lt;th id="g16b02"&gt;th标头 &lt;/th&gt; &lt;th id="gaae0b" class=" u7959f"&gt;th标头 &lt;/th&gt; &lt;th id="gd78bc"&gt;th标头 &lt;/th&gt; &lt;/tr&gt; &lt;tr id="g5af9b"&gt; &lt;td id="g920bb"&gt;td表格单元 &lt;/td&gt; &lt;td id="g9de93" class=" uab6e6"&gt;td表格单元 &lt;/td&gt; &lt;td id="gea8dc"&gt;td表格单元 &lt;/td&gt; &lt;/tr&gt; &lt;tr id="cf47d6" class=" u0cbcd "&gt; &lt;td id="c913e3" class=" ud690a "&gt;td表格单元 &lt;/td&gt; &lt;td id="c452e0" class=" uab6e6 "&gt;td表格单元 &lt;/td&gt; &lt;td id="c917b3" class=" u7eb06 "&gt;td表格单元 &lt;/td&gt; &lt;/tr&gt; &lt;tr id="cba81f" class=" u0cbcd "&gt; &lt;td id="c3dae7" class=" ud690a "&gt;td表格单元 &lt;/td&gt; &lt;td id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f198f642d11a83876f83673c74013d27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f91b0e7309615598a97cbeadb613bbf/" rel="bookmark">
			win10 右键菜单的注册表位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、鼠标右键桌面空白处，新建菜单中的项目在注册表中的位置
[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Discardable\PostSetup\ShellNew]
2、鼠标右键文件，弹出的菜单明细在注册表中的位置
[HKEY_CLASSES_ROOT\*\shellex\ContextMenuHandlers]
3、鼠标右键文件夹，弹出的菜单明细在注册表中的位置
[HKEY_CLASSES_ROOT\Directory\shellex\ContextMenuHandlers]
4、鼠标右键在IE浏览器里，弹出的菜单明细在注册表中的位置
[HKEY_CURRENT_USER\Software\Microsoft\InternetExplorer\MenuExt]
5、桌面空白处点击右键菜单
HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers
注意：
1、某些软件所添加的鼠标右键可能在
[HKEY_CLASSES_ROOT\Folder\shell]
[HKEY_CLASSES_ROOT\Folder\shellex\ContextMenuHandlers]
1.shift+右键
https://blog.csdn.net/wyx0712/article/details/82120806
2. 计算机中CLSID在注册表中的位置
计算机\HKEY_CLASSES_ROOT\CLSID
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d7be02f7195e44f3ddc42e0e7a3bb2/" rel="bookmark">
			mac M1安装Lightgbm 成功安装记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误尝试： 首先我是mac M1的电脑，在网上找了很多解决方案，也尝试了很多搜索中的常见的方案，利用brew安装cmake、gcc，看了有评论说能解决，有可能对于windows系统是有效果，但对于M1的电脑是真的无能为力。
也尝试了先安装brew install libomp，在导入lightgbm也出现了报错
brew install libomp 报错情况 解决方案： 先卸载所有安装过的lightgbm
pip uninstall lightgbm brew uninstall lightgbm 重新用conda安装
conda install lightgbm 如果conda安装还是报错，可以先卸载uninstall一下，再重新安装，我第一次也这样，卸了重装了一遍就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9febc1d2a3edc6c51d1b993cdb1269/" rel="bookmark">
			自动驾驶前沿综述：基于深度强化学习的自动驾驶算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | TIM 编辑 | 汽车人
原文链接：https://zhuanlan.zhihu.com/p/477372894
点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
点击进入→自动驾驶之心技术交流群
后台回复【数据集下载】获取计算机视觉近30种数据集！
这是 21 年的一篇综述文章，可以算得上是最前沿的自动驾驶技术综述。这几年随着深度表征学习的发展，强化学习领域也得到了加强。文章会对目前最先进的自动驾驶 DRL 算法进行汇总和分类。
论文标题：
Deep Reinforcement Learning for Autonomous Driving: A Survey
论文链接：
https://arxiv.org/abs/2002.00444
简介
自动驾驶系统（AD system），由多个级别的感知和控制任务组成，目前在感知方面，已经可以通过深度学习架构来实现。但在控制层面，经典的监督学习已经不再使用，因为代理需要在每一个瞬间做出动作决策，这些决策可能会改变场景条件。
▲ 自动驾驶各级别的任务
AD system 的组成
2.1 感知模块（Preception Module） 感知模块的目标是创建环境状态的中间级别表示（例如所有障碍物和代理的鸟瞰图），稍后将由最终产生驾驶策略的决策系统使用。该状态将包括车道位置、可行驶区域、代理（例如汽车和行人）的位置、交通信号灯的状态等。感知中的不确定性传播到信息链的其余部分。强大的传感对于安全至关重要，因此使用冗余源可以提高检测的信心。这是通过语义分割、运动估计、深度估计、污点检测等几种感知任务的组合来实现的，这些任务可以有效地统一成一个多任务模型。
▲ 多视角相机融合的鸟瞰图
2.2 场景理解（Scene Understanding） 该模块的作用是将感知模块获得的信息映射到高级动作或决策层。该模块旨在提供对场景的更高层次的理解，通过融合异构传感器源（如激光雷达、相机、雷达、超声波），抽象和概括场景信息，为决策制定提供简化的信息。
2.3 定位和建图（Localization and Mapping） 定位和建图技术，又称 SLAM 是自动驾驶的关键技术之一。由于问题的规模，传统的 SLAM 技术通过语义对象检测得到增强，以实现可靠的消歧。此外，局部高清地图（HD maps）可以用作物体检测的先验。
2.4 规划和推动策略（Planning and Driving Policy） 轨迹规划是自动驾驶中的关键模块，在高清地图或基于 GPS 的地图上计划路线，并引导代理生成运动层的命令。经典运动计划会忽略环境动态和差分约束，因此类似于 A* 算法之类的基于 Djisktra 的算法在此问题中并不适用。而快速探索随机树（RRT）通过随机采样和无障碍路径生成来探索配置空间。目前有多种版本的 RRT 被用于自动驾驶管道中的运动规划。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9febc1d2a3edc6c51d1b993cdb1269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f50e4163eb43af8d295585984ac062d/" rel="bookmark">
			rocketmq多主多从异步复制集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RocketMQ集群搭建
ROcketMQ集群搭建有以下几种方案：
「单Master模式」
「多Master模式」
「多Master多Slave模式-异步复制」
「多Master多Slave模式-同步双写」
其中，
「单Master模式」风险较大，「一旦Broker重启或者宕机时，会导致整个服务不可用」。不建议线上环境使用，可以用于本地测试。
「多Master模式」，一个集群无Slave，全是Master，单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，「消息实时性会受到影响」。
「多Master-Slave异步复制模式」，即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时「Master宕机后，消费者仍然可以从Slave消费」，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样。Master宕机会丢失少量的信息。
「多Master-Slave同步双写模式」，数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高，「性能比异步复制模式略低」（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。
我们采用多Master多Slave的异步复制模式来搭建RocketMQ集群。
架构图：
集群各个角色参考配置如下：
1.配置RocketMQ-Master01(10.11.12.223) 首先创建消息存储路径，RocketMQ获取到消息默认为 /home，我们可以修改消息存储路径：
mkdir ./store mkdir ./store/commitlog mkdir ./store/consumequeue mkdir ./store/index cd store/ ll total 0 drwxrwxr-x. 2 admin admin 6 Feb 18 09:50 commitlog drwxrwxr-x. 2 admin admin 6 Feb 18 09:50 consumequeue drwxrwxr-x. 2 admin admin 6 Feb 18 09:50 index 接下来编辑/conf/broker.conf
#所属集群名称 brokerClusterName=DefaultCluster #broker名字，同一组的master-slave中，broker名字相同 brokerName=broker-a #brokerId的ID，0 表示Master，&gt;0 表示Slave brokerId=0 #删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 小时 fileReservedTime=48 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=ASYNC_MASTER #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH #nameServer集群地址，如果是多个，使用分号;分割 namesrvAddr=10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f50e4163eb43af8d295585984ac062d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2907b610b891a543d9e501844376b04b/" rel="bookmark">
			EXPER LOG | 作为ByteDance青训营-客户端-项目leader的历程和收获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		~此处为记录2022SUMMER青训营，我担任项目组长时，在团队协作，项目任务分配，规则商议协定以及收获心得
~还在更新中
极简tiktok内容介绍： 榜单模块（主页面一） 榜单页面设计历史数据查询功能 个人中心模块（主页面二） 个人页面设计粉丝和关注列表发布视频列表发布视频详情页 我们的任务分配（每组2人）： UI设计组 参照官方文档，有合理美观的布局，在layout和activity中实现组件的合理布局（和交互逻辑组做好需求沟通）因为这部分代码难度不算复杂，所以要求最快完成 交互逻辑组 交互操作：实现在具体页面点击跳转页面，视频滑动效果，数据获取：具体页面点击相应按钮获取数据（和数据绑定组在接口等方面做好沟通配合） 数据绑定组 为榜单信息，个人信息，视频详情数据写好合适的数据类型，便于在交互逻辑中直接调用为交互逻辑组提供接口（官网文档已经有要求）数据准备：不同版本的榜单内容，至少3个；个人信息，粉丝列表和关注列表的头像，至少5个；特定视频至少5个 完善统筹开放平台申请，密钥权限分发 代码Git整合编写文稿，提交，演示demo录制，参加答辩“监工” 碎碎念：
有不会的一定要问，小组合作不喜欢划水的人，更讨厌故意拖延小组进度的人答辩我负责全程，原则上不要求大家，当然想给评委展示自己也欢迎我们的开发时间是5号-15号，起码10号我要求大家有整体的框架才开始学习（如果有）的话，推荐先把我pin的那本书过一遍，看看客户端开发的基本流程，组件，kotlin语法知识重申：开发和学习越早越好，人对于未知的困难总是要准备好充足的时间，我会问问大家的进度，这也是对开发组的每个人负责p.s.每个人可以在代码中给自己通过注释进行签名，in case真有人搞拖延失联或者想划水的，群内投票是否除名并上报给字节工作人员我们用git和github开发，会有一个test分支（Branch），请大家修改和提交在test里，master放最终版版本控制和写作开发知识我放两个：
BV1uT4y1J7zo
BV1df4y1m7B1github仓库已经成功建立，我已完成初始化和第一次同步，剩下的人尽快把邮箱给我，我拉你们进仓库，这样可以直接把你写的代码同步到我们的小组代码库中。注意:1.每次下载和上传都从test中操作，main留的是确认好的内容，如果直接改main里的代码，可能误操作影响开发；2.上传文件见https://www.cnblogs.com/weigaung/p/9233193.html
（将master改为test) 范例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eddc9067ca7d2c87674386e9669b2f2/" rel="bookmark">
			（2）日志工具和kotlin语法——客户端开发学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我使用的教材是《第一行代码》，感谢开放的互联网。
本篇内容包含：日志工具的概念知识和使用练习，以及kotlin的大部分基础语法特性
【日志工具的使用 工具类Log(andriod.util.Log):
Log.v()-&gt;级别最低，对应verbosed-&gt;debug，调试信息，分析问题i-&gt;info，分析用户行为w-&gt;warne-&gt;error 尝试日志工具 logcat过滤器尝试 logcat日志级别 【kotlin语言认识——杜绝空指针 运行结果：
知识点：
每一行代码不用加分号；出色的类型推导机制；对象数据类型；语法糖： fun largerNumber(num1: Int, num2: Int) = max(num1, num2)
变量 val-&gt;不可变量var-&gt;可变 延迟赋值出错时可用解决办法：val a: Int = 10
函数 函数=方法
函数定义： fun methodName(param1: Int, param2: Int): Int{//最后一个Int表示返回值类型，没有可不写 return 0 } 代码提示中选择函数模板后，还会自动导包。
运行结果：
逻辑控制 条件语句：if， when if可以有返回值，为为真条件中最后一行代码的返回值。
when：匹配值 -&gt; {执行逻辑}； 可以做类型匹配。
循环语句：while, for 概念： 区间
语法：val a = 0…10 表示[0, 10]
for-in语法常用： for(i in 0 until 10 step 2){}
输出：0,2,4,6,8
//0 until 10 =[0, 10)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eddc9067ca7d2c87674386e9669b2f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca185f5b1575ea04e53e630561c17a8f/" rel="bookmark">
			vue 高德地图使用热力图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码 在public/index.html中加入： &lt;script src="https://webapi.amap.com/maps?v=1.4.15&amp;key=您申请的key值"&gt;&lt;/script&gt; &lt;template&gt; &lt;div class="box"&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;div class="input-card" style="width: auto;"&gt; &lt;div class="input-item"&gt; &lt;button class="btn" @click="heatmap.show()"&gt;显示热力图&lt;/button&gt; &lt;/div&gt; &lt;div class="input-item"&gt; &lt;button class="btn" @click="heatmap.hide()"&gt;关闭热力图&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // https://a.amap.com/jsapi_demos/static/resource/heatmapData.js // 下面数据为热力图数据，可以下载上面网址数据进行测试 import heatmapData from '@/assets/js/heatmapData'; export default { data() { return { map: null, heatmap: null }; }, mounted() { // 延迟加载，防止出现AMap not defined setTimeout(() =&gt; { this.initMap(); this.createHeatMap(); }, 1000); }, beforeDestroy() { this.map &amp;&amp; this.map.destroy(); }, methods: { initMap() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca185f5b1575ea04e53e630561c17a8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db37b5cd767fd5972ab4695e39c70b1/" rel="bookmark">
			Spring Boot安全管理—Spring Security基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security的基本配置 1. 基本用法 1.1 创建项目，添加依赖 创建一个Spring Boot Web 项目，然后添加spring-boot-starter-security依赖。
&lt;!-- security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 1.2 添加hello接口 在项目中添加一个简单的/hello接口，内容如下：
@RestController public class HelloController { @GetMapping("/hello") public String hello(){ return "Hello"; } } 1.3 启动项目测试 访问/hello接口会自动跳转到登录页面，这个页面有Spring Security提供的。
默认的用户名是user，默认的登录密码在每次启动项目随机生成，查看项目日志：
2. 配置用户名和密码 在application。properties中配置默认的用户名、密码以及用户角色。
spring.security.user.name=chen spring.security.user.password=123456 spring.security.user.roles=admin 3. 基于内存的认证 开发者可以自定义类继承WebSecurityConfigurerAdapter，进而实现对Spring Security更多的自定义配置。例如基于内存的认证。
@Configuration public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder(){ return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5db37b5cd767fd5972ab4695e39c70b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904f31f26633d88cf5aeaef2452944b8/" rel="bookmark">
			CentOS 7安装zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单机安装 CentOS 7环境单机安装zookeeper 1、下载ZK zookeeper下载页面：https://zookeeper.apache.org/releases.html
这里下载二进制版本，不需要编译, 以安装路径 /usr/local/soft 为例
cd /usr/local/soft wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1-bin.tar.gz 2、解压 tar -xzvf apache-zookeeper-3.7.1-bin.tar.gz 3、修改配置文件 进入conf目录并拷贝zoo_sample.cfg改名为zoo.cfg
cd apache-zookeeper-3.7.1-bin/conf cp zoo_sample.cfg zoo.cfg 端口号默认2181，配置文件zoo.cfg里面的dataDir要修改，如果不改，需要创建这个目录 mkdir -p /tmp/zookeeper
mkdir -p /usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data tickTime=2000 initLimit=10 syncLimit=5 dataDir=/usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data clientPort=2181 4、配置zk环境变量 配置后在任意目录之下可以使用bin中的命令
vim /etc/profile # 文件末尾增加如下配置 export ZOOKEEPER_HOME=/usr/local/soft/apache-zookeeper-3.7.1-bin export PATH=$PATH:$ZOOKEEPER_HOME/bin # 让profile文件生效 source /etc/profile 如果没有安装jdk，需要先安装jdk并通过vi /etc/profile命令配置java环境变量
export JAVA_HOME=/usr/local/java/jdk1.8.0_131 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH export ZOOKEEPER_HOME=/usr/local/soft/apache-zookeeper-3.7.1-bin export PATH=$PATH:$ZOOKEEPER_HOME/bin 5、启动ZK 进入到apache-zookeeper-3.6.1-bin的bin文件夹，查看启动脚本zkServer.sh
./zkServer.sh help zkServer.sh start # 启动 zkServer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/904f31f26633d88cf5aeaef2452944b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78f975fd9a9c77f4f27d1bd39d0ff70/" rel="bookmark">
			从未初始化的字符串说起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在用C/C++编写程序的时候，尤其是新手，经常犯的错误就是忘记对变量进行初始化。如果一个字符串没有初始化，在调试的时候，会看到如下奇怪的事情
说到这，让我想起之前在网上看到的一个段子：
话说，有位仁兄读大学的时候学习C语言课程，有一次他在编写程序的时候忘记给一个字符串赋值，结果在打印字符串的时候，屏幕上出现了一大堆“烫烫烫烫”的字符串，让他大吃一惊。他以为是计算机温度过高，向他发出警报，于是立马关掉计算机，并感慨计算机的智能。
读到这个段子，也不禁也让我想起，在我初学C的时候，也犯过同样的错误，而且还告诉老师计算机在报警。
那么，未初始化的字符串在调试模式下为什么会显示“烫”呢？我们来说道说道。
一、INT 3 这里说的可不是一个整形值3，而是一条指令。从8086开始，Intel就在其产品中提供了一条专门用来支持调试的指令INT 3，这条指令的目的就是使CPU中断到调试器，使软件开发者对程序进行各种分析。
怎么使用呢？很简单，就是在需要调试的地方插入一条INT 3指令，当程序运行到此的时候，就会停下来，比如这样：
int main() { char s[50]; __asm int 3; std::cout &lt;&lt; "INT 3" &lt;&lt; std::endl; return 0; } 当程序执行到此时，在VS2022中会弹出这样一个窗口提示
我们点击窗口右上角的绿色三角，可以继续执行程序 ，最后程序输出
以上是编译的32位程序，如果是64位，不支持__asm指令的，那怎么办呢？可以用一个函数替代，__debugbreak()
int main() { char s[50]; __debugbreak(); std::cout &lt;&lt; "INT 3" &lt;&lt; std::endl; return 0; } 其实看__debugbreak()的汇编代码会发现，它就是一条int 3指令 __debugbreak();
00007FF72D5E24AC int 3 这个INT 3指令的机器码为0xCC，而0xCCCC刚好又是汉字“烫”的字符码，这下知道，“烫”是怎么来的了 二、为什么要使用它设置断点 我们经常使用的代码编译器VS，下断点是非常容易的，指定某一行，按F9就下了一个断点，或者在WinDbg中，在成功加载程序调试符号的情况下，也可以使用bp命令设置断点，这个指令似乎用不上。
就我使用到的场景，一般都是在驱动调试的时候。现在的VS调试驱动比十几年前方便太多了，那个时候，绝大部分都是通过WinDbg与虚拟机进行双机调试（多年前养成的习惯，现在也是喜欢如此调试，因为WinDbg可观察的东西太多了），为了让WinDbg调试器能够中断下来，就会使用这条指令。
其次，在客户机没有安装VS的时候，要在客户机上调试程序，也可以通过这种形式让程序在可能出问题的地方断下来，然后远程挂上调试器进行调试。
三、INT 3的一些特殊用途 为什么在调试模式下，对未赋值的字符串或者未初始化的内存赋值为0xCC呢？这其实是编译器故意这样做的。当遇到缓冲区溢出的时候（也就是指针超出了字符串的区域），指针正好指向这些区域，就会触发断点从而中断到调试器，这样开发人员就知道程序哪里出了问题。
再者，当我们在看某一个函数的汇编代码时，也会发现INT 3的踪影，比如以下汇编代码片段：
int main() { 00007FF7FC3D2150 push rbp 00007FF7FC3D2152 push rdi 00007FF7FC3D2153 sub rsp,158h 00007FF7FC3D215A lea rbp,[rsp+20h] 00007FF7FC3D215F lea rdi,[rsp+20h] 00007FF7FC3D2164 mov ecx,1Eh 00007FF7FC3D2169 mov eax,0CCCCCCCCh 00007FF7FC3D216E rep stos dword ptr [rdi] 00007FF7FC3D2170 lea rcx,[__39878DF1_main@cpp (07FF7FC3E3001h)] 00007FF7FC3D2177 call __CheckForDebuggerJustMyCode (07FF7FC3D13DEh) char s[50]; __debugbreak(); 00007FF7FC3D217C int 3 return 0; 00007FF7FC3D217D xor eax,eax } 00007FF7FC3D217F mov edi,eax 00007FF7FC3D2181 lea rcx,[rbp-20h] 00007FF7FC3D2185 lea rdx,[__xt_z+1B0h (07FF7FC3DAC50h)] 00007FF7FC3D218C call _RTC_CheckStackVars (07FF7FC3D1366h) 00007FF7FC3D2191 mov eax,edi 00007FF7FC3D2193 lea rsp,[rbp+138h] 00007FF7FC3D219A pop rdi 00007FF7FC3D219B pop rbp 00007FF7FC3D219C ret 00007FF7FC3D219D int 3 00007FF7FC3D219E int 3 00007FF7FC3D219F int 3 00007FF7FC3D21A0 int 3 00007FF7FC3D21A1 int 3 00007FF7FC3D21A2 int 3 00007FF7FC3D21A3 int 3 00007FF7FC3D21A4 int 3 00007FF7FC3D21A5 int 3 00007FF7FC3D21A6 int 3 00007FF7FC3D21A7 int 3 当函数结束的时候，会插入大量的int 3指令，这样做有两个目的：其一，来进行函数的内存对齐；其二，防止栈溢出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e78f975fd9a9c77f4f27d1bd39d0ff70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc7a2d9f3a39c3f5a7ba5fffd56cf9a/" rel="bookmark">
			CiteSpace关键词共现图谱含义详细解析与注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​本文以CiteSpace软件做的关键词共现分析为例，进行关键词共现图谱含义详细解析。作者、机构、国家、学科(COOC软件可做)等网络分析与此类似。
关键词是一篇论文的核心概括，对论文关键词进行分析可对文章主题窥探一二。
而一篇论文给出的几个关键词一定存在着某种关联，而这种关联可以用共现的频次来表示。一般认为，词汇对在同一篇文献中出现的次数越多，则代表这两个主题的关系越紧密。
共词分析法利用文献集中词汇对或名词短语共同出现的情况，来确定该文献集所代表学科中各主题之间的关系。
统计一组文献的主题词两两之间在同一篇文献出现的频率，便可形成一个由这些词对关联所组成的共词网络。
CiteSpace做的图谱并不是用的原共现矩阵，而是在原矩阵的基础上通过COSINE，PMI，DICE和JACCARD标准化后的矩阵，然后利用它们进行网络可视化，至于具体使用哪种标准化，这里就要发挥人的主观能动性啦，即反复比较，观看图谱找出最符合实际情况的标准化方法。一般默认都使用COSINE余弦相似度。也有一些研究常用相异矩阵，此时可借助COOC软件计算。
所以，本质上你在做图谱前已经对该领域有所了解了，否则你无法对图谱进行有效解读，且你并不知道那个图更好! 对于刚进入领域的研究小白来说最快速的方法就是看几篇综述型文章，以达到对该领域有个大概印象。
那反过来说，既然你对该研究领域已经有了解了，为什么还要再做图谱呢？
个人认为你的图谱除了能发论文，写报告等任务外，还有两个原因：
其一从自身角度来看：做出的图谱会修正你之前对该领域的理解，因为你之前的理解可能并不全面，存在遗漏且较为主观。而以数据为驱动的方法能够客观的展示领域发展的现状、趋势和前沿，达到以主观去理解客观，再以客观去修正完善主观的功效，最后主观与客观相统一，从而让你对领域的认识更加科学、客观、全面。
其二从他人角度来看：做出的图谱能够让那些不了解本领域的人花费最少的时间精力入门本领域。
下面看图吧！
如下图所示，此图由CiteSpace生成的关键词共现网络。与利用Ucinet软件或者Gephi软件绘制出来的共现网络图本质是相同的，就是由节点和边构成的网络罢了。
首先，我们可以通过左上角的参数看到网络的节点数、边数和网络密度。
其中节点数就是图中的关键词个数，边数就是关键词之间的连线数。只要关键词在同一篇文献中出现过，两者之间就会有一条连线。【PS.当然与你设置的每个时间切片提取的关键词个数有关系。】
图中圆圈大小代表的是关键词频次，频次越大，圆圈越大。Ucinet软件或者Gephi软件可以很方便的使用点度中心性、接近中心性、中间中心性和特征向量中心性等属性表征节点大小。(NSS视频理论部分已经详细讲解这些中心性的含义：[软件+教程] NSS2.2一款用于网络科学与知识图谱服务的软件)
但是请记住：CiteSpace软件统计的这个频次并不是导入的数据中的总频次，而是阈值设置后的频次，所以列表中的频次应该小于等于真实频次，一般是小于。如果想统计真实准确的频次可以使用COOC软件。但是很多人并不清楚，在论文中错误地认为这个频次是总频次。
另外，特别注意，在利用CiteSpace进行分析时需要进行数据清洗工作，利用清洗后的数据做与不清洗直接做存在一定误差。可利用COOC软件进行清洗，然后再利用CiteSpace作图，结果就非常准确了。
线条代表关键词之间的联系，线条颜色与图中上方年份相对应，用于标志每一年有哪些主要关键词。
左侧列表除了关键词频次和中心性外还有关键词初次出现年份，这个时间非常重要，它会在时区图和时间线图密切相关。
从这个图中我们可以获取什么信息呢？
还是回到了共词分析的原理上：共词分析法利用文献集中词汇对或名词短语共同出现的情况，来确定该文献集所代表学科中各主题之间的关系。
我们目的是为了获得学科中各主题之间的关系，而主题使用关键词表示的，本质就是关键词之间的联系，所以又返回去了，我们本质就获得了关键词之间的联系。联系紧密的关键词会相对形成一个个小的团体，进而我们可以将这个小团体中的关键词进行归纳总结，总结出一个个主题，然后对主题进行详细论述。其实本质就是聚类分析啦！只是过程是人工的而已！
当然CiteSpace软件自身也具有聚类的功能，下节课再讲。
提醒一下：当人工已经可以很容易的进行归纳后，就不需要再利用CiteSpace聚类功能啦。
该功能是在你看不清，看不懂共现图谱的时候用一下，辅助你了解的。结果往往并不总是十分理想。但是人工往往很难辨别清楚，所以还需要利用CiteSpace的自动聚类功能。除CiteSpace可做聚类分析外，Ucinet、Gephi、VOSviewer、Pajek等软件均可做聚类图谱分析，效果也很好，如果要是做文献计量，往往需要结合COOC软件。
注意事项
关键词共现网络相当于你进入文献计量领域做出的第一个有点难度的图。
有哪些事项需要注意呢？
【1】文献检索问题
文献计量第一步就是检索文献数据，在此过程中我们要尽量找全目标领域的同义词，尽量提高查全率。当然，同时也要考虑查准率。这两个基本呈现对立关系，一般查全率提高了，查准率就会降低，需要检索人员反复测试，构建合适的检索式。
怎么才叫合适的检索式呢？
我的经验是：
如果文献量特别的大，可以选择标题OR关键词检索，此时查准率高；
如果文献量不是很多，可以选择主题检索，此时查全率高。
【2】数据清洗问题
做文献计量必须进行数据清洗，所有不进行数据清洗的文献计量就是ZJ。
计算机界有一个很有名的说法，叫“Garbage In Garbage Out)，翻译成汉语就是“垃圾进、垃圾出”，即用胡乱选择的垃圾数据作分析，产生的研究结果自然也没有任何意义。
因为从中国知网、Web of Science等数据库里检索出的数据存在与目标领域不相关的文献或不是真正的论文，如有些是编辑部的通知、公告、选题指南等，如果不进行数据清洗将导致结果不准确。而目前已知软件(COOC除外)，均不具备数据清洗功能。COOC软件可将清洗后的数据转化为CiteSpace和VOSviewer等软件可识别的格式。所以，以后再做文献计量所用的软件应该是COOC+CiteSpace或者COOC+VOSviewer。
【3】文献去重问题
中国知网、Web of Science等数据库中存在重复的数据，所以在进行文献计量分析时首先需要对数据进行去重，这也是文献计量中必不可少的一步，而很多研究中并没有这一步，可使用COOC软件进行解决。
【4】关键词合并与删除问题
不同的作者由于习惯常用不同的关键词表示同一个含义，如“科研数据管理”、“科学数据管理”、“研究数据管理”等是同义词关系，这种情况就需要合并同义词了；此外在做文献计量分析时网络中会出现一些无意义的词，如“综述”、“进展”等，此时需要进行删除。如何快速有效的批量进行关键词的合并与删除也是一大难题，可使用COOC软件进行解决。
【5】关键词缺失问题问题
这个问题很隐蔽，如果你的论文直接使用CiteSpace、VOSviewer等软件绘制图谱，那么你永远也不可能发现这个问题。因为这些软件是直接把下载的题录数据导入软件进行的分析，当文献缺失关键词时也不会有所提示，使用者无法判断下载的文献是否缺失关键词。
这个问题如何解决呢？
目前没有好的办法，其一：放任不管；其二：利用COOC软件找到这些缺失关键词的文献，然后一篇篇找到原文进行补充，当总数据量不多时，建议进行补充，否则会严重影像件结果。
那么问题来了，问什么会缺失关键词呢？
其一：有些论文真的本来就没有关键词；
其二：各大数据库收录统计时少部分缺失未完全统计
拓展
共现分析的方法论基础是心理学的邻近联系法则和知识结构及映射原则。心理学的邻近联系法则是指曾经在一起感受过的对象往往在想象中也联系在一起，以致于想起它们中的某一个的时候，其他的对象也会以曾经同时出现时的顺序想起。
我们常说的关键词共现、作者共现、机构共现、国家共现都是共现分析的一种。
只不过依据分析对象的不同，作者共现称为作者合作网络、机构共现称为机构合作网络、国家共现称为国家合作网络而已…
一句话，正如我们在课程中所讲的一样，上述所有的分析本质上就是共现分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae041fc9c8b92b0cbbbe1569e815f12d/" rel="bookmark">
			三招彻底解决IDEA卡顿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一次使用IDEA软件，卡到怀疑人生，查阅资料无数，做此总结，希望能帮到需要的人。
1.首先，安装IDEA软件后，自动生成的桌面启动方式都是32位的，如果你是64位系统，我们使用这个快捷方式运行大项目，一般都会很卡
解决方案：找到idea的安装目录，然后进入bin文件夹，找到名称为idea64的应用程序，右键他生成桌面快捷方式。以后每次启动都用它这个快捷方式就可以了。
2.IDEA默认启动配置，一款软件它要考虑低配置用户，所以初始化参数不高（默认最低128m，最高512m），导致启动慢，然后运行也不流畅。
解决方案： 找到idea安装目录下的bin文件夹下的idea.exe.vmoptions文件！
idea.exe.vmoptions：默认32位机器运行的
idea64.exe.vmoptions：默认64位机器运行的
手动修改
关键的三个参数的说明 1、 -Xms 是最小启动内存参数
2、 -Xmx 是最大运行内存参数
3、 -XX:ReservedCodeCacheSize 保留代码占用的内存容量参数
手动修改
-Xms=1024m
-Xmx=2048m
-XX:ReservedCodeCacheSize =300m
3.软件安装默认会捆绑许多插件
解决方案：打开软件-设置-插件
禁Java开发无关的插件，例如：google的app，前端的js框架 等插件可以卸载掉项目中根本不用不到的一些框架，Struts，Hibernate,Ant 等可以卸载。
如上就是我解决idea卡顿的主要几种情况，另外建议安装idea软件的电脑内存最好在8G或16G及以上。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408896ae9a82cb2f79ee7f4a5f2d59e0/" rel="bookmark">
			HCIE FusionSphere产品解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器虚拟方案介绍 FusionSphere产品解决方案 服务器虚拟化 FusionSphere
私有云 FusionCloud
桌面云 FusionAccess
服务器虚拟化 FusionSphere = FusionCompute+FusionManger(纳管Vmare)
服务器虚拟化 6.3 FusionSphere
6.0 6.1 FusionSphere华为云计算总体解决方案
3个使用场景
1.服务器虚拟化 FusionCompute(xen)+FusionManager
2.云数据中心 FusionCompute（xen）+FusionSphereOpenstack
3.电信运营商 KVM+FusionSphereOpenstack
6.3.1 6.5.1
服务器虚拟化FusionSphere FusionCompte (KVM)+FusionManger
私有云FusionCloud（6.5以后叫华为云stack） KVM+FusionSphereOpenstack
场景 电信运营商
8.0
桌面云FusionAcess（6.1及以前，叫FusionCloud 6.3以后叫FusionAcess）
6.5相比6.3 主要增加了IPV6的支持
8.0相比6.5 主要是增加了对ARM服务器的注册
华为FusionSphere 6.5 云操作系统架构 FusionSphere 6.5云操作系统架构
云管理层：FusionManger 对FusionSphere中软件和硬件进行全面监控和 管理运营，实现对其他厂商的异构
虚拟化层: 华为：FusionCompute（计算虚拟化、存储虚拟化、网络虚拟化）、Fusionstorage（分布式块存储）、eBackup（备份）bcmanager（容灾）等 Vmare（vsphere\san）等
硬件基础设施层：服务器（计算资源） 储存（储存资源） 路由器、交换机（网络资源） 防火墙、制冷、供电等
FusionCompute云操作系统软件 CNA：计算节点代理 计算、存储、网络的虚拟化（UCP：华为虚拟化操作系统，6.3以前是XEN架构 6.3.1以后是KVM架构；VNA:虚拟节点代理，代理的是UVP与VRM的通信）
VRM:对多个CNA主机的资源进行统一管理、分配
FusionManager 云操作系统管理软件 1.异构虚拟化管理，同时管理华为和非华为（只有VMware）的虚拟化产品，通过FM提供统一的管理界面
2.软硬件统一管理，同时管理虚拟化软件，硬件，同时管理不同厂商的硬件
3.提供快捷入口，快速发放虚拟机
4.不同数据中心的统一管理（top+local）
5.资源划分（VDC、VPC)
6.业务的快速发放
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/408896ae9a82cb2f79ee7f4a5f2d59e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4bd64509434b1e2822da93a3841eef/" rel="bookmark">
			EChart 多y轴,X轴零点刻度线一致性通用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路已经在本人的上一篇小文章简述过了,不再赘述. 直接上代码
function AdjustXAxisPosition(op) { var yAxis = op.yAxis; var min, max; nmlMin = 1;// normalization of min nmlMax = -1; var yH = new Array(yAxis.length); for (i = 0; i &lt; yAxis.length; i++) { // normalization ... min = yAxis[i].min; max = yAxis[i].max; yH[i] = max - min; if (yH[i] &lt;= 0) { return op; } min = min / yH[i]; max = max / yH[i]; if (nmlMin &gt; min) { nmlMin = min } if (nmlMax &lt; max) { nmlMax = max } } // reset the min and max of each yAxis .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d4bd64509434b1e2822da93a3841eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92fc55e6672462e863e9292f2b75a1b/" rel="bookmark">
			VsCode编辑器之shell脚本的编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VsCode编辑宇宙之shell脚本的编辑 背景介绍 长期从事.Net开发，一直使用宇宙第一IDE Visual studio系列,VsCode的横空出世，让我又多了一个非常完美的选择，vscode从Python，前端，Golong，MarkDown，shell，qt，c#都有非常完美的插件支持，真的让人爱不释手。本系列将介绍用vscode开发和编辑的常用配置和插件。
环境介绍
操作系统：Win10
VsCode版本：1.46.0
开干 由于Windows和Linux的系统换行的区别，win是\n\r,而Linux是\n,没有回车符号，所以，Windows环境下编写的Shell脚本一般在Linux系统下运行都会产生各种错误，为了提升我们开发的效率，我们需要一个蹭手的编辑器，那就是VsCode
首先下载Shell相关的插件
shellman插件
提供智能提示和自动补全功能
shell-format
脚本代码格式化，不仅支持shell，还支持dockerfile
shell-format 需要安装shfmt支持
shfmt 下载地址 https://github.com/mvdan/sh/releases
将下载好的文件路径记住：D:\LLP Soft\shfmt_v3.5.0_windows_amd64.exe
ctrl+shift+p 选择首选项（打开用户设置），搜索 shellformat，配置刚才的路径
回到编辑器中，可以看见效果了。
ShellCheck
提供语法检测功能，更快定位问题，对不合法的语法，直接点击提示连接，跳转到问题详细页面，对新手简直不要太友好了
LF和CRLF
CRLF：英文全称：Carriage Return Line Feed，即：回车换行。windows 系统环境下的换行方式。
LF：英文全称：Line Feed，即：换行。Linux 系统环境下的换行方式。
点击VsCode的下方LF或者CRLF可以自由切换行位的换行符号组合
全部插件截图
博客review计划 由于以前很多时候是为了记录一下笔记，有的是为了活动啊之类的，导致很多博客环境不全，代码不全，排版混乱，专栏分类不清楚，所以在开始写新的博客直接，开启review计划。
review：20220820
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58bb4d040ddc97355463de8ddf3b386/" rel="bookmark">
			FusionSphere虚拟化套件简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FusionSphere虚拟化套件简介 华为FusionSphere虚拟化套件是业界领先的虚拟化解决方案，能够帮助客户带来如下的价值，从而大幅提升数据中心基础设施的效率。
帮助客户提升数据中心基础设施的资源利用率。帮助客户成倍缩短业务上线周期。帮助客户成倍降低数据中心能耗。利用虚拟化基础设施的高可用和强恢复能力，实现业务快速自动化故障恢复，降低数据中心成本和增加系统应用的正常运行时间。 FusionSphere虚拟化套件通过在服务器上部署虚拟化软件，使一台物理服务器可以承担多台服务器的工作。通过整合现有的工作负载并利用剩余的服务器以部署新的应用程序和解决方案，实现较高的整合率。
应用场景介绍 单虚拟化场景：
单虚拟化场景适用于企业只采用FusionCompute作为统一的操作维护管理平台对整个系统进行操作与维护的应用场景。包含资源监控、资源管理、系统管理等。
FusionCompute主要负责硬件资源的虚拟化，以及对虚拟资源、业务资源、用户资源的集中管理。它采用虚拟计算、虚拟存储、虚拟网络等技术，完成计算资源、存储资源、网络资源的虚拟化。同时通过统一的接口，对这些虚拟资源进行集中调度和管理，从而降低业务的运行成本，保证系统的安全性和可靠性。
多虚拟化场景：
多虚拟化场景适用于企业有多套虚拟化环境需要进行统一管理。多虚拟化场景提供如下主要功能：
统一管理和维护：支持同时接入FusionCompute和VMware虚拟化环境，对多虚拟化环境的资源和业务进行统一的管理和维护。统一监控告警：支持对多个虚拟化环境、多种物理设备的告警进行统一接入、监控和管理。 私有云场景：
私有云场景适用于企业各部门需要各自管理虚拟资源及业务。发放业务时由管理员和租户分别完成不同的任务，共同完成业务的发放。管理资源时，管理员可以对系统所有资源进行管理；租户只能管理所属VDC的资源。
根据实际使用需求的不同，私有云场景又可分为多租户共享VPC场景和多租户私有VPC场景。
多租户共享VPC场景
该场景中，发放业务时管理员通过VDC将虚拟资源分给租户。租户在租户视图，创建虚拟机时可使用管理员在共享VPC中创建的网络。若在创建VDC时，将管理员加入了VDC中，则管理员一人在不同视图中，可完成所有任务。该场景适用于如下情况：
企业各部门需要各自管理除网络之外的虚拟资源（包含虚拟机、磁盘等）及业务。企业中的网络由管理员统一规划和维护，企业各部门均使用管理员创建的网络。 多租户私有VPC场景
该场景中，发放业务时管理员通过VDC将虚拟资源分给租户。租户在租户视图，自行创建VPC、网络、虚拟机。当同时有共享网络需求时，可以由管理员创建共享VPC供所有租户使用。若在创建VDC时，将管理员加入了VDC中，则管理员一人在不同视图中，可完成所有任务。该场景适用于如下情况：
企业各部门需要各自管理虚拟资源（包含网络、虚拟机、磁盘等）及业务。企业各部门的网络相互隔离，各自规划、创建和维护 FusionSphere虚拟化套件的特点和用途 应用按需分配资源 提供虚拟机资源的可扩展能力，使用户可以按照应用需求随时随地调整虚拟机资源，并且无需中断应用。
虚拟资源SLA保障 提供虚拟机资源的控制能力，使用户可以按照应用的重要程度合理地分配物理资源。
统一虚拟化数据中心管理 提供虚拟机的创建、部署、转换、迁移等管理能力，并且可以异构管理业界主流的第三方虚拟化平台，从管理层屏蔽虚拟化平台差异，实现统一纳管。
广泛兼容各种软硬件 支持基于x86硬件平台的多种服务器和兼容多种存储设备，并且可以支持主流的Linux/Windows操作系统运行，支持主流APP运行于虚拟化平台。
自动化调度 根据预先设定策略进行工作负载的自动迁移，最终使资源分配达到最优比，保证系统良好的用户体验和业务系统的最佳响应。
完善的权限管理 根据不同的角色、权限等，提供完善的权限管理功能，授权用户对系统内容的资源进行管理。
应用智能管理 基于完整的审批流程机制提供服务目录和用户自定义模板，方便用户自定义快速部署私有应用。
完善的计量能力 虚拟化管理系统统计不同用户的资源使用量，方便第三方系统按资源使用计费。
丰富的运维管理 提供多种运营工具，实现业务的可控、可管，提高整个系统运营的效率。
云安全 采用多种安全措施和策略，并遵从信息安全法律法规，对用户接入、管理维护、数据、网络、虚拟化等提供端到端的业务保护。
FusionCompute产品定位 FusionCompute是云操作系统软件，主要负责硬件资源的虚拟化，以及对虚拟资源、业务资源、用户资源的集中管理。它采用虚拟计算、虚拟存储、虚拟网络等技术，完成计算资源、存储资源、网络资源的虚拟化。同时通过统一的接口，对这些虚拟资源进行集中调度和管理，从而降低业务的运行成本，保证系统的安全性和可靠性，协助运营商和企业构筑安全、绿色、节能的云数据中心能力。
FusionCompute在虚拟化套件中的位置如图1所示。
图1 FusionCompute定位
云机房 云机房是指为云数据中心运营所提供的一系列基本配套设施和空间，主要包括供电系统、消防系统、布线系统、制冷系统等。
华为基于SAFE创新理念，从智能管理（Smart）、高可用性（Availability）、灵活扩展（Flexibility）、高效节能（Efficient）四个方面持续提升数据中心机房竞争力。
硬件基础设施层 硬件资源包括服务器、存储、网络、安全等全面的云计算基础物理设备，支持用户从中小规模到大规模的新建或扩容，可运行从入门级到企业级的各种企业应用。设备类型丰富，可为客户提供灵活的部署选择。
FusionStorage Block FusionStorage Block是一种存储与计算高度融合的分布式存储软件，在通用X86服务器上部署该软件后，可以把所有服务器的本地硬盘组织成一个虚拟存储资源池，提供块存储功能。
FusionSphere虚拟化套件 FusionSphere虚拟化套件通过在服务器上部署虚拟化软件，将硬件资源虚拟化，从而使一台物理服务器可以承担多台服务器的工作。通过整合现有的工作负载并利用剩余的服务器以部署新的应用程序和解决方案，可以实现较高的整合率。
FusionCompute
FusionCompute是云操作系统软件，主要负责硬件资源的虚拟化，以及对虚拟资源、业务资源、用户资源的集中管理。它采用虚拟计算、虚拟存储、虚拟网络等技术，完成计算资源、存储资源、网络资源的虚拟化。同时通过统一的接口，对这些虚拟资源进行集中调度和管理，从而降低业务的运行成本，保证系统的安全性和可靠性，协助运营商和企业构筑安全、绿色、节能的云数据中心能力。
FusionManager
FusionManager主要对云计算的软件和硬件进行全面的监控和管理，实现自动化资源发放和自动化基础设施运维管理两大核心功能，并向内部运维管理人员提供运营与管理门户。
eBackup
eBackup是虚拟化备份软件，配合FusionCompute快照功能和CBT（Changed Block Tracking）备份功能实现FusionSphere的虚拟机数据备份方案。
UltraVR
UltraVR是容灾业务管理软件，利用底层SAN存储系统提供的异步远程复制特性，提供虚拟机关键数据的数据保护和容灾恢复。
FusionCompute技术特点 统一虚拟化平台 FusionCompute采用虚拟化管理软件，将计算资源划分为多个虚拟机资源，为用户提供高性能、可运营、可管理的虚拟机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a58bb4d040ddc97355463de8ddf3b386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6987242ee2f643b17e6690d2b92f15d1/" rel="bookmark">
			c&#43;&#43; GUI应用---吃豆人游戏(Visual Studio 2019)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址：https://download.csdn.net/download/m0_51152186/86404896​​​​​​​
一、GUI简介
1、概念：图形用户界面，是指采用图形方式显示的计算机操作用户界面
2、核心技术：Swing、AWT
3、优点
（1）可以写出我们心中想要的一些小工具
（2）工作时候，也许需要维护到 Swing 界面
（3）了解 MVC 架构，了解监听
使用GDI绘图
（1）画点
在pacman.cpp文件中找到：
// 获取消息
if(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) {
if(msg.message == WM_QUIT) {
break;
}
TranslateMessage(&amp;msg);
DispatchMessage(&amp;msg);
}
在这段代码下方增加如下的代码：
// 画点测试
{
HDC hdc = ::GetDC(g_hwnd); // 获得设备句柄
SetPixel(hdc, rand() % WLENTH , rand() % WHIGHT, // 在随机的位置一个随机颜色的点
RGB(rand() % 256, rand() % 256, rand() % 256));
::ReleaseDC(g_hwnd, hdc); // 释放设备
}
（2）画线段
将刚才 /画点即其后大括号内的代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6987242ee2f643b17e6690d2b92f15d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d161c10af92881098306dfdb50ccd877/" rel="bookmark">
			Rust实战系列-Rust介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“
学习资料：rust in action[1]
1. Rust 安装 curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh source"$HOME/.cargo/env" 2. hello world 创建 hello 项目 mkdir rust_tmp &amp;&amp; cd rust_tmp cargo new hello cd hello cargo run 看到这样的输出，就表示已经成功运行了 Rust 项目，尽管还没写任何代码。接下来看看发生了什么。
Cargo Cargo 是一个同时提供项目构建和软件包管理功能的工具。也就是说，Cargo 执行 rustc（Rust 编译器）将 Rust 代码转换为可执行的二进制文件或共享库。cargo new会创建一个遵循标准模板的项目，目录结构如下：
Cargo.toml：描述项目的元数据信息（项目名，版本，依赖）
[package] name = "hello" version = "0.1.0" edition = "2021" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] src：源码目录，Rust 的源码文件扩展名为 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d161c10af92881098306dfdb50ccd877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c021db6b0768df2db58c3202f7cc166/" rel="bookmark">
			istio和sdp(软件定义边界)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零信任原生安全：超越云原生安全 - DockOne.io
GitHub - greenstatic/opensdp: A proof of concept Software Defined Perimeter (SDP) implementation using OpenSPA for service hiding
开源SDP 软件定义边界环境的安装和搭建_caoli4608的博客-CSDN博客_sdp 开源
SDP Specification v1.0 | CSA
https://lindat.mff.cuni.cz/repository/xmlui/handle/11234/1-1956
SDP（软件定义边界）让SDN更安全,你的对面可不能是一条狗！ - 腾讯云开发者社区-腾讯云
SDP标准规范1.0 - 道客巴巴
百度安全验证
云原生应用的零信任
上一节主要谈的是IaaS和PaaS平台的零信任，在SaaS场景中，随着敏捷开发、高效运营的驱动下，用户越来越多地使用服务网格（Service Mesh）等云原生的架构开发应用。这些应用所在的基础设施虽然还在活跃开发中，但因现代化、软件化的基础设施使能、来自互联网攻击的防护需求，零信任理念已经随之落地。
云原生场景中，应用的颗粒度会被切得非常细，一个容器通常只运行一个或少数若干进程，故服务称之为微服务。所以，通常实现一个业务需要多个微服务的交互，所以在云原生场景中，服务之间的访问关系非常复杂，不能依靠实现固化的访问控制逻辑，而是应该按照业务的逻辑确定微服务间安全策略，划分微服务的边界进行持续有效的隔离，以及对微服务之间一致的访问权限控制，就变得非常重要。为了解决这个问题，云原生的系统通常都会有数据和管理平面的鉴权机制。
而在服务网格场景下，零信任还应覆盖微服务间的交互，这部分需要使用面向云原生的服务零信任机制。比较典型的方案是Google的Istio，我们在以前的文章（Istio的安全机制防护）中已有分析，也可参见官方文档。从功能上看，Istio可为微服务无缝加入认证授权和加密通信的功能。其思想是通过策略控制器，使用Kubernetes的RBAC授权机制，对资源粒度细到单个服务的访问进行控制，从而所有的服务交互都是可信的。
Istio在控制平面上，由Citadel组件做认证，Pilot组件做授权；数据平面上，在源目的服务旁插入Sidecar容器，截获进出流量，在进行加解密的同时，也根据Pilot的策略进行访问控制。
图5 Istio的访问控制和数据平面
图6 Istio的工作流程和组件
从效果看，如果攻击者没有合法身份，是无法在数据平面横向移动。因为在网络层，设置了网络策略白名单后，网络层的非法访问被禁止；而在服务层，微服务Pod开放服务较少，且都引入了认证和业务层访问控制，攻击者也很难发起非授权的连接。
从数据平面分析，Istio和SDP都需要对网络做比较大的修改。如SDP需要添加IH和AH，客户端需要添加组件，服务端也需要部署代理，而Istio的Sidecar容器也需要部署在所有业务容器旁，且截获流量，通过重写IPTABLES NAT表的方式将处理完的流量送回业务容器。
从结果观察，SDP在传统企业网络中部署因为上述原因遇到了非常大的挑战，但可预计Sidecar的部署模式会在服务网格环境中会成为主流的安全防护技术路线。原因是Sidecar虽然是一种侵入性部署模式，但全程自动化、用户友好：Istio主动监听Kubernetes-api服务获得新服务部署事件，通过仓库自动部署Sidecar容器，通过Init容器劫持流量，最后Sidecar使用Citadel和RBAC策略进行认证授权。一方面，业务方对安全机制毫无感知，所有开发、测试和运维均保持不变；另一方面，应用间能实现完备的认证和授权，最终达到内生安全。
零信任原生安全 软件定义边界(SDP)_百度百科
SDP与零信任安全 编辑 语音
零信任安全是一种理念，软件定义边界SDP是实践零信任安全理念的技术架构与方案。企业可以通过部署SDP产品或者解决方案来实现零信任安全理念中的原则。零信任理念强调：“Never Trust、Always Verify”。SDP的网络隐身技术可以很好实现Never Trust原则。区别于传统TCP/IP网络的默认允许连接，在没有经过身份验证和授权之前，服务器对于终端用户是完全不可见的，从By Default Trust变成Never Trust。另外，区别于传统网络安全验证的Verify Once，通过在SDP网关实施实时的动态可信授权验证，可以实现对于连接授权的Always Verify。SDP是一种快速高效的零信任安全实践技术架构，因此也被行业广泛应用。
SDP技术架构 编辑 语音
SDP安全模型由3大组件构成，分别是：1）Initiating SDP Host，即IH；2） Accepting SDP Host，即AH；3）SDP Controller，即控制器。3大组件的关系分成两个平面：1）控制平面和2）数据平面。AH 和 IH 都会连接到Controller。IH和AH 之间的连接是通过Controller与安全控制信道的交互来管理的。该结构使得控制平面能够与数据平面保持分离，以便实现完全可扩展的安全系统。此外，所有组件都可以是集群的，用于扩容或提高稳定运行时间。 [3]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c021db6b0768df2db58c3202f7cc166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0cfe8c10677da48caf8af5dfa32c25/" rel="bookmark">
			VS2019 MFC串口通信（基于SerialPort类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS2019 MFC串口通信（基于SerialPort类） SerialPort类由VC6.0 升级到VS2019遇到的问题总结及解决办法,串口通信（基于SerialPort类）可参考原文链接：[http://blog.csdn.net/humanking7/article/details/48110543]
写这篇文章主要是为了记录下调试程序过程中遇到的问题，留作以后参考，或是有相同问题的同学可以借鉴下。
基于VC6.0的串口通信程序，适用版本太低，现在的windows系统基本不支持，因此为了后续开发维护，将软件平台升级为VS2019，调试过程持续了三天，终于调通了，差点就怀疑这条路走不走得通了。还好，坚持着解决一个一个的问题，总算调通了。
这里具体记录下遇到的问题：
1、直接复制VC6.0版本的SerialPort.cpp和SerialPort.h文件。（本来有适用于VS2019的，但无奈按字符串接收WM_COMM_RXSTR可响应，而按字符接收WM_COMM_RXCHAR无响应，因此放弃）。具体操作过程参见其他博客，这里不再赘述。
2、需要将OncommMscomm(WPARAM ch, LPARAM port)函数类型更改为LRESULT。
3、显示错误“char*”类型的实参与“LPCWSTR”类型的形参不兼容时，需要点击项目属性-&gt;然后在属性页中点击-&gt;高级-&gt;字符集-&gt;将其值改为使用多字节字符集。
4、编译报4996错误时，可在SerialPort.h文件第1行，即所有头文件之前添加代码#pragma warning( disable : 4996)解决。
5、Run-Time Check Failure #3 - The variable ‘comstat’ is being used without being initialized 报错，百度有三种解决方案，本人采用的是将CSerialPort.CPP中的COMSTAT comstat;改为static COMSTAT comstat;
目前遇到的基本上就是这些问题，总的思想是：从VC6.0升级到VS2019这条路是可行的，剩下的就是遇到具体问题直接百度，都可以找到解决办法。☺☺☺☺☺☺☺
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d202ccc239db7c5a4a6fac2fae56625/" rel="bookmark">
			【Python入门】爬虫入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
（一）概述
（二）获得HTML
requests模块
获取headers
（三）爬取数据
正则表达式
re模块
正则提取
（四）保存数据
（五）实践-爬取B站top100
（一）概述 网页中的信息，大部分会出现在网页的源代码中，而爬虫的本质，就是从网页的源代码中爬取所需要的信息。
具体步骤可以概括为：伪装成User-Agent向网页服务器发送请求，获得响应，将响应解析成HTML源代码，再通过正则表达式等匹配手段提取出位于源代码中的特定信息，再将所提取的信息保存到Excel或数据库中，供数据可视化和数据分析使用。
欲实现以上步骤，我们需要导入re、bs4、requests（或者urllib.request）、xlwt和sqlite3模块,它们的功能如下：
# 向服务器发送请求并解析响应（following2选1） import urllib.request import requests # 定位信息，匹配信息 from bs4 import BeautifulSoup # 定位标签 import re # 进行正则匹配 # 保存数据 import xlwt # 保存到Excel import sqlite3 # 保存到数据库 （二）获得HTML requests模块 我们以requests模块举例，urllib模块中也有同样功能的方法。在requests模块中，我们可以使用get方法来向服务器发送请求并返回响应，再通过text方法将响应解析成HTML。在get方法中，我们主要需要的参数是URL（网址）和headers（用于伪装成浏览器）。我们以爬取b站top100举例:
import requests url = 'b站排行榜网址' head = { 'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) ' 'AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/104.0.5112.81 ' 'Mobile Safari/537.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d202ccc239db7c5a4a6fac2fae56625/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/132/">«</a>
	<span class="pagination__item pagination__item--current">133/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/134/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>