<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32ea06c40edb2776756a43241cbecbc/" rel="bookmark">
			LeetCode.565. 数组嵌套____暴力dfs-＞剪枝dfs-＞原地修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		565. 数组嵌套 索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], … }且遵守以下的规则。
假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]… 以此类推，不断添加直到S出现重复的元素。
示例 1:
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释:
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.
其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
提示：
1 &lt;= nums.length &lt;= 1050 &lt;= nums[i] &lt; nums.lengthA中不含有重复的元素。 Solution1(暴力dfs): 每次任选一个起点开始，接着使其不断的走，边走边进行标记，直到无法继续走后，判断长度即可，接着标记数组进行回溯，从下一个起点再继续走。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32ea06c40edb2776756a43241cbecbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c895ad379b20e75486cff66bdd555f7/" rel="bookmark">
			memcpy函数详解 看这一篇就够了-C语言（函数讲解、 使用用法举例、作用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		memcpy()函数用于：复制内存块
函数介绍 函数声明：void * memcpy ( void * destination, const void * source, size_t num );
参数
目的地：指向要在其中复制内容的目标数组的指针，类型转换为 void* 类型的指针。
源：指向要复制的数据源的指针，类型转换为 const void* 类型的指针。
数字：要复制的字节数。 size_t 是无符号整数类型。
头 文 件：#include &lt;string.h&gt;
返 回 值： 返回目的地。
用法示例 ​​​​​​ 函数讲解 将 num 字节值从源指向的位置直接复制到目标内存块。
源指针和目标指针所指向的对象的基础类型与此函数无关;结果是数据的二进制副本。
该函数不检查源中是否有任何终止空字符 - 它始终精确地复制数字字节。
为避免溢出，目标参数和源参数所指向的数组的大小应至少为 num 个字节，并且不应重叠（对于重叠的内存块，memmove 是一种更安全的方法）。
函数memcpy从source的位置开始向后复制num个字节的数据到destinatation
这个函数在遇到 '\0' 的时候并不会停下来。
如果source和destination有任何的重叠，复制的结果都是未定义的。
实现函数 void* My_memcpy(void* dest,const void* src, size_t num) { assert(dest &amp;&amp; src); void* ret = dest; while (num--) { *(char*)dest = *(char*)src; dest = (char*)dest + 1; src = (char*)src + 1; } return ret; } 事例展示 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c895ad379b20e75486cff66bdd555f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39633a3f56daf57ec91914e7c82a827/" rel="bookmark">
			strstr函数详解 看这一篇就够了-C语言（函数讲解、函数实现、使用用法举例、作用、自己实现函数 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		strstr()函数用于：查找子字符串
目录
函数介绍
用法示例
函数讲解
实现函数 事例展示
函数介绍 函数声明：char *strstr(const char *str1, const char *str2)
头 文 件：#include &lt;string.h&gt;
返 回 值： 返回值为char * 类型（ 返回指向 str1 中第一次出现的 str2 的指针）；如果 str2 不是 str1 的一部分，则返回空指针。 用法示例 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str[] = "This is a simple string"; char* pch; pch = strstr(str, "simple"); if (pch != NULL) strncpy(pch, "sample", 6); puts(str); return 0; } 函数讲解 实现函数 char* My_strstr(const char* str1, const char* str2) { assert(str1 &amp;&amp; str2); const char* s1 = str1; const char* s2 = str2; const char* p = str1; while (*p!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39633a3f56daf57ec91914e7c82a827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be0ce1b4c52db57f880f8f77998cc4b/" rel="bookmark">
			Gitee(码云)、Github同时配置ssh key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入ssh目录 cd ~/.ssh 使用命令分别创建两个平台的公钥 ssh-keygen -t rsa -C "test@qq.com" -f "id_rsa_gitee" ssh-keygen -t rsa -C "test@163.com" -f "id_rsa_github" 完成后，目录内容如下：
-rw------- 1 rpp staff 2.5K 6 18 2020 id_rsa -rw-r--r-- 1 rpp staff 570B 6 18 2020 id_rsa.pub -rw------- 1 rpp staff 2.5K 6 24 2020 id_rsa_gitee -rw-r--r-- 1 rpp staff 570B 6 24 2020 id_rsa_gitee.pub -rw------- 1 rpp staff 2.5K 6 24 2020 id_rsa_github -rw-r--r-- 1 rpp staff 568B 6 24 2020 id_rsa_github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be0ce1b4c52db57f880f8f77998cc4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adab38596ba7b398fee6080315f3b6f6/" rel="bookmark">
			Linux基础入门到精通之CentOS镜像下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载CentOS镜像可以从官网下载https://www.centos.org/download/，也可以从国内的镜像网站下载。
比如：
阿里云：https://mirrors.aliyun.com/centos/
网易：http://mirrors.163.com/
两个都可以，操作一样，下面就以阿里云举例。
1、进入上面阿里云centos镜像下载页面 centos镜像下载1
2、选择你要下载的版本，这里下载6.8版本，点击。 centos镜像下载2
3、点击readme，浏览器中可能需要下载，打开文件，选取网址。 centos镜像下载3
4、在浏览器中打开网址，选择对应的版本号进入文件。 centos镜像下载4
5、我们需要的镜像文件在 isos/ 目录下，点击进入下一层目录。 centos镜像下载5
6、我们发现这一层目录下又有两个子目录，i386/ 和x86_64/ ，i386表示32位的镜像文件，x86_64/ 表示64位的镜像文件，可根据自己需要选择，这里我们选择x86_64 centos镜像下载6
7、进入根目录后，发现里边有不同类型的镜像文件和其他文件 ： 首先是readme.txt里边给出了不同镜像文件类型的说明
然后是各种类型的镜像文件，简介中已有说明，再简单提一下：
bin-DVD.iso:本地离线镜像文件，可直接直接安装到硬盘上，一般下载这个即可。LiveCD/DVD.iso: 是一个光盘Centos系统，可通过光盘在电脑商启动系 统，也可以安装到计算机，有些内容还需要再次下载。minimal.iso: 精简版的镜像，可安装最基本的Centos系统，一般用在服务器上。netinstall.iso: 在线安装版本，启动后边下载边安装。
最后是一些不同的校检文件，用来验证文件的安全性和可用性，一般不用考虑。 最后，我们选择需要的版本（最好两个都下）： CentOS-6.5-x86_64-bin-DVD1.iso CentOS-6.5-x86_64-bin-DVD2.iso centos镜像下载7
注：下载好的镜像文件分成两部分，是因为光盘文件不能超过4.7GB，DVD1中包含主要的centos系统和部分必需的软件包，DVD2就是些额外的软件包，在安装centos的时候只安装DVD1也可以。
8、选择下载资源站点 点击上边选择的镜像文件中任一个后，进入一个资源站点选择界面，如下，只有两个资源区即USA和Europe，经测试，选择USA或Europe的第一个站点都可以的，第二个站点都不能访问。这里我们选USA的第一个站点，点击后会进入站点镜像资源主目录：
centos镜像下载8
Tips:
我一般会选择第7步中，下图中选项
直接下载种子，通过下载工具直接下载。（两个文件同时下载下来）
9、选择版本资源目录 接第8步，选择我们下载对应版本的资源目录，6.8。
centos镜像下载9
10、进入镜像资源根目录： 上一步选择版本号之后，就进入下一层资源目录，之后就是与前边相似的目录结构，依次选择，直到进入镜像资源根目录：
centos镜像下载10
centos镜像下载11
11、点击链接下载 分别点击图中链接，进行下载。
12、CentOS镜像下载结束 这里说一下，可以在CentOS官网上直接下载，在下载时，还是可以选择国内的镜像网站下载，和上边是一样。每种方式都可以，看自己的习惯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79bd0f9053f6bbe74cd54fede395a21c/" rel="bookmark">
			已解决Module not found: Error: Can‘t resolve ‘core-js/fn/reflect‘ in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是写construct ，Vue自动给添加一个路径
把上面标红的这行删掉就解决了 我当时只是想打const ，结果不小心写成construct，然后我改成const但是Vue添加的路径没有去掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3004b6b12f0e0eb1cf26ed5352e479b2/" rel="bookmark">
			【mysql】Lock wait timeout exceeded； try restarting transaction问题解决(trx_mysql_thread_id=0情况)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行接口调用时，响应时间超长，之后接口返回异常，查看日志发现为Lock wait timeout exceeded; try restarting transaction的错误。
在数据库执行了一下删除语句，发现也是这个错误，因为使用的数据库为mysql，而InnoDB表类型会出现锁等待的情况，在出现锁等待时，会根据参数innodb_lock_wait_timeout（默认50s）的配置，判断是否需要进行timeout的操作，如果等待时间超过了设置的时间就会报错。
我们可以用下面三张表来查原因：
1、 innodb_trx ## 当前运行的所有事务 2、innodb_locks ## 当前出现的锁 3、innodb_lock_waits ## 锁等待的对应关系 通过以下语句来查看正在执行的事务：
select * from information_schema.innodb_trx; 正常情况下，可以直接根据id杀死mysql线程
kill (trx_mysql_thread_id) XA事务
但是发现事务的trx_mysql_thread_id=0，发现这是XA事务，因为trx_mysql_thread_id=0 的事务无法通过kill trx_mysql_thread_id 的方式处理，所以，需要回滚这些XA事务。
查看XA事务信息
xa recover; 回滚事务
# XA事务回滚命令的格式： xa rollback 'left(data,gtrid_length)'，'substr(data,gtrid_length+1,bqual_length)', formatID; 以上查出来的信息拼接结果为（以下举其中一个为例）：
xa rollback '172.26.228.19:8091:50164878136127488','-50164878593306625',9752; 直到查询无正在执行事务为止：
此时再去执行删除语句，发现可以正常删除，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6980333dc6b5aa95c061c58507a1b28e/" rel="bookmark">
			点击一行字，弹窗显示全部文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能：点击文字弹窗显示全部内容
处理建议/措施文字太长怎么办？遇到此类需求可以弹窗显示全部内容，或者点击展开详情，在这里我用弹窗实现此功能。
代码如下：
.inner_deal_measures{ width: 100%; height: 50%; position: relative; } .measures2 li { display: flex; width: 100%; height: 23%; padding: 4px 0 0 0; } .inner_deal_measures h5 { height: 30px; font-size: 16px; color: #7FBED3; background: linear-gradient(90deg, rgba(65, 160, 190, 0.4) 0%, rgba(57, 151, 182, 0) 100%); line-height: 30px; border-left: 4px solid #13748F; padding-left: 10px; } .measures2 li p { font-size: 16px; padding: 0px 4px 0; width: calc(100% - 32px); overflow: hidden; height: 100%; text-overflow: ellipsis; white-space: nowrap; line-height: 30px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6980333dc6b5aa95c061c58507a1b28e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29bcd8045841dc4d9ef2a2c30225e0e6/" rel="bookmark">
			如何关闭谷歌浏览器的调试功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用谷歌浏览器运行web项目时，不小心点开了断点调试，然后无法关闭，重启浏览器也是一样
解决办法：
长按蓝色图标，切换为停止即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd0ec08daeed13ae6017c13805281e7/" rel="bookmark">
			SLAM十四讲-ch3-vistalizegeometry编译问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学高翔博士的《SLAM十四讲》，在ch3中运行vistalizegeometry这个demo的时候，出现如下报错信息（图片版报错看不清的话，文末附文字版的报错信息）：
刚开始我还以为是我pangolin安装有问题，后来发现是这个demo中的CMakeLists.txt配置不适合本机Ubuntu20.04的环境（和C++编译器版本有关系）
只需要更改CMakeLists.txt中的一行代码即可解决！！！！如图：
把第4行注释掉，
# set(CMAKE_CXX_FLAGS "-std=c++11") # 注释掉这一行！！！ 即可顺利make，然后执行！
slamlearn@slamlearn-VirtualBox:~/slambook2/ch3/visualizeGeometry/build$ cmake .. -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Looking for pthread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd0ec08daeed13ae6017c13805281e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/454b05e98d684cd3bfc069fe7e209e5d/" rel="bookmark">
			工具系列——foxmail 邮箱邮件接收不到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，公司行政遇到一个问题，用 foxmail 登录公司分配的邮箱账号后接收不到邮件。
登录后的界面如下：
这么一看，很明显就是少了写东西，第一时间感觉就是邮箱的接收和发件设置有问题，查看了一下设置，果然是接收和发件的地址写错了，后面改回来就没问题了
顺便科普下 pop 和 smtp:（来自百度）
POP3 — 接收
POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。
它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。
SMTP — 发送
SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。
SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4529489de2c333ca4e9f4c1a7ae6e9b9/" rel="bookmark">
			Linux系列——Linux操作指令之systemctl详细理解及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、systemctl理解 Linux 服务管理两种方式service和systemctl
systemd是Linux系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。
systemd对应的进程管理命令是systemctl
1. systemctl命令兼容了service 即systemctl也会去/etc/init.d目录下，查看，执行相关程序
systemctl redis start systemctl redis stop # 开机自启动 systemctl enable redis 2. systemctl命令管理systemd的资源Unit systemd的Unit放在目录/usr/lib/systemd/system(Centos)或/etc/systemd/system(Ubuntu)
主要有四种类型文件.mount,.service,.target,.wants
.mount文件
.mount文件定义了一个挂载点，[Mount]节点里配置了What,Where,Type三个数据项
等同于以下命令：
mount -t hugetlbfs /dev/hugepages hugetlbfs
.service文件
.service文件定义了一个服务，分为[Unit]，[Service]，[Install]三个小节
[Unit]
Description:描述，
After：在network.target,auditd.service启动后才启动
ConditionPathExists: 执行条件
[Service]
EnvironmentFile:变量所在文件
ExecStart: 执行启动脚本
Restart: fail时重启
[Install]
Alias:服务别名
WangtedBy: 多用户模式下需要的
.target文件
.target定义了一些基础的组件，供.service文件调用
.wants文件
二、常用命令 1.查看版本号 systemctl –-version 2.管理服务(unit)
systemctl 提供了一组子命令来管理单个的 unit，其命令格式为：
systemctl [command] [unit]
command 主要有：
start：立刻启动后面接的 unit。
stop：立刻关闭后面接的 unit。
restart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4529489de2c333ca4e9f4c1a7ae6e9b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0bbb08777c47248ce5a8b8b1997f3ff/" rel="bookmark">
			数据库系列（MySQL）—— MySQL优化之多表join，多个in或or查询的速率优化逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在优化一个sql查询，因为是一个订单的查询，需要验证一些订单的查看权限，其中逻辑需要join到多个其他表格，同时也用到很多in和or，导致多表都是用到全表扫描，速率及其慢。
比如订单中的商品的标签字段需要做过滤，下面模拟表格order（订单表），item（商品表），tag（标签表）
一般的逻辑大致上是这样的
select * from order
where (某些过滤语句)
where tag.name not in (tags)
left join item on item.tid = order.tid
left join tag on item.id = tag.item_id
优化方案是这样的，先根据tags 获取到对应的item_ids，即要不需要过滤掉的item_ids，然后根据item_ids获取到对应得tids，最后语句为
select * from order
where (某些过滤语句)
where tid in (tids)
可能表述有些乱，因为个人感觉这个数据库设计得有些问题，可能是经过几次的需求改动。或者是因为订单需要做快照，即下单之后订单的数据不会随着产品数据的修改而变动。
但是我要表述的优化逻辑就是，可以用反向的思维去，先把join的表格中的数据根据条件筛选出符合的数据，而不是一味地进行连表操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b003b2a169992ee611478e9df278e7b4/" rel="bookmark">
			nacos 集群连接报错： Nacos cluster is running with 1.X mode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整报错信息：
Nacos cluster is running with 1.X mode, can't accept gRPC request temporarily. Please check the server status or close Double write to force open 2.0 mode
背景：
生产环境springboot 应用连nacos 集群连不上，集群三个节点，版本都是2.x
具体报错：
这里说的是nacos节点运行的是1.x版本模式，我们应用使用的是2.x版本，2.x会使用gRPC进行通信，所以这里不支持。
解决：
报错里提示打开nacos官方文档，这里截图没展示出来。按照报错提示检查了nacos集群状态，显示正常。又因为是生产不敢轻易关闭双写，走流程申请之后联系集成的同学关闭了nacos双写，报错消失，应用正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/440056f87c3877a01c9a061e7b4bb546/" rel="bookmark">
			gitlab&#43;jenkins持续集成CICD服务部署详细篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitlab安装 GitLab简介
GitLab 是一个用于仓库管理系统的开源项目。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wal1)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用。常用的网站:
官网:GitLab最新版下载安装_GitLab中文免费版-极狐GitLab中文官方网站
国内镜像:https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/安装环境:
1、Centos 6或者7
2、2G内存(实验)生产(至少4G)
3、 安装包:gitlab-ce-10.2.2-ce 4 、禁用防火墙，关闭selinux
1. 安装和配置必须的依赖项
在 CentOS 7上，下面的命令也会在系统防火墙中打开 HTTP、HTTPS 和 SSH 访问。这是一个可选步骤，如果您打算仅从本地网络访问极狐GitLab，则可以跳过它。
sudo yum install -y curl policycoreutils-python openssh-server perl #上面这个是最重要的 sudo systemctl enable sshd sudo systemctl start sshd sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld 2.（可选）下一步，安装 Postfix 以发送电子邮件通知。如果您想使用其他解决方案发送电子邮件，请跳过此步骤并在安装极狐GitLab 后配置外部 SMTP 服务器。
sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix 在安装 Postfix 的过程中可能会出现一个配置界面，在该界面中选择“Internet Site”并按下回车。把“mail name”设置为您服务器的外部 DNS 域名并按下回车。如果还有其它配置界面出现，继续按下回车以接受默认配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/440056f87c3877a01c9a061e7b4bb546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90c26fe6411ccd93f4cd8e19f66b526/" rel="bookmark">
			linux批量删除指定名称的文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux批量删除指定名称的文件夹
find /root/baseline_dataset -name .ipynb_checkpoints | xargs rm -rf
find # find 命令又来查找
/root/baseline_dataset # 查找的目录
-name # 指定是通过名字 name 来查找
.ipynb_checkpoints # 指定文件/目录的名字
| # linux 管线
xargs # 组合多个命令的一个工具，建议自行搜索查阅
rm -rf # 删除命令
以删除.svn 文件夹为例
cd 存在.svn文件目录 执行
find . -name “*.svn” | xargs rm -rf
欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f90c26fe6411ccd93f4cd8e19f66b526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f4e6e0e4192de5d4af1b338fcc573dc/" rel="bookmark">
			Java------Stream流式编程源码分析（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java------Stream流式编程源码分析（二） Stream执行流程 Stream是一个接口，表示流的意思，类似一个管道，数据好比流水从管道经过。用于传递数据，并不存储数据。
Stream并不会修改源数据。
Stream整体流水线包括很多操作，按阶段划分分为三部分。
1.生成流（Stream.of）
2.中间操作（过滤、转大写、排序等等，每个操作处理完数据完成后，将结果交给下一个操作）
3.终结操作（结束整个流水线，一个流只有一个终结操作，只要执行终结操作，就触发整个流的执行。，不执行终结操作，中间操作也不会执行。中间操作具有惰性特点。）
@Test public void test1(){ String[] strs = new String[]{"hello","world","hi","com","student"}; //使用Stream流完成上边对字符串的处理需求 Stream.of(strs)//创建一个Stream流对象 .filter(x-&gt;{ System.out.println("1.过滤"+x); return x.length()&gt;4; })//过滤字符串，找到长度大于4的字符串 .map(x-&gt;{ System.out.println("2.转大写"+x); return x.toUpperCase(); })//转换大写 .forEach(x-&gt;{ System.out.println("3.遍历输出"+x); });//遍历输出 } 输出结果：
1.过滤hello 2.转大写hello 3.遍历输出HELLO 1.过滤world 2.转大写world 3.遍历输出WORLD 1.过滤hi 1.过滤com 1.过滤student 2.转大写student 3.遍历输出STUDENT 由结果可以看到，遍历输出是按先字符串：hello走一遍之后再走world、hi、com、student。并不是先过滤hello、world、hi、com、student，再转大写，再输出。
如果把forEach注释掉，这些输出语句也不会打印出来。
Stream原理-生成流 @SafeVarargs @SuppressWarnings("varargs") // Creating a stream from an array is safe public static&lt;T&gt; Stream&lt;T&gt; of(T... values) { return Arrays.stream(values); } //再下一步 public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) { return stream(array, 0, array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f4e6e0e4192de5d4af1b338fcc573dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/273bfcba4e599063d400ce3f34a82639/" rel="bookmark">
			【深度学习】使用yolov5对数据进行预标注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍手动标注少数图转化VOC到YOLO转移数据到Linux服务器训练YOLOV5添加数据yaml文件选一个合适的权重训练开服务写labelstxt文件 介绍 以条形码为例，下载数据集muenster_barcodedb，想使用yolov5对条形码进行检测。muenster_barcodedb数据集有几千张图，没有目标检测标注。
手动标注少数图 随意选95张图出来，手动LabelImg标注，VOC标注格式。
转化VOC到YOLO 填写xmi路径和yolo txt保存路径即可：
# coding:utf-8 import os import os.path import xml.etree.ElementTree as ET def convert_annotation(xmldir: str, txtdir: str, image_id: str, classes: dict): in_file = open(os.path.join(xmldir, '%s.xml' % (image_id)), 'r', encoding='UTF-8') out_file = open(os.path.join(txtdir, '%s.txt' % (image_id)), 'w') tree = ET.parse(in_file) root = tree.getroot() size = root.find('size') size_width = int(size.find('width').text) size_height = int(size.find('height').text) for obj in root.iter('object'): difficult = obj.find('difficult').text cls = obj.find('name').text if cls not in classes or int(difficult) == 1: continue cls_id = classes[cls] xmlbox = obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/273bfcba4e599063d400ce3f34a82639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fb07a06dc3d85f1ce153d8e32beb2d/" rel="bookmark">
			用户名枚举漏洞怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0544a0b862d4b6082e1e687e9e4d33/" rel="bookmark">
			Git技能树（3）：Git使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git技能树（3）：Git使用 在开始 Git 的基础命令学习之前，我们先来认识一下版本库——Repository，接下来我们所有提到的 Git 基础命令，都是基于版本库的。
那么什么是版本库呢？版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。
接下来，我们首先看看 Git 版本库创建的相关命令。
在已存在目录中初始化仓库 —— git init 在已存在目录中创建一个版本库的过程非常简单：
首先，选择一个合适的地方，创建一个空目录：
创建目录
$ mkdir learning-git $ cd learning-git $ pwd /Users/xxm/learning-git pwd命令用于显示当前目录。
第二步，通过git init命令把这个目录变成 Git 可以管理的仓库：
初始化仓库
$ git init Initialized empty Git repository in /Users/xxm/learning-git/.git/ 瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），同时在当前目录下多了一个.git的目录，这个目录是 Git 来跟踪管理版本库的，如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看到了。
克隆现有的仓库 —— git clone 如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。
git clone
当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0544a0b862d4b6082e1e687e9e4d33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7673c8e5e638515ecab3465ad2af14ce/" rel="bookmark">
			Windows无法启动启动服务，错误1053的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows无法启动启动服务，错误1053的解决方法 项目需求，要将一个exe二进制文件以windows服务的形式发布，开发编译运行后一切正常。sc命令安装为windows服务启动，出现下图错误：Windows无法启动启动服务，错误1053
关键代码处打上crash日志
发现获取程序运行路径的配置文件读取失败，但直接运行exe则成功。
原因及解决：
原因是加载配置文件的接口是用Getwd()获取的当前的工作目录，当将exe注册为windows服务运行时，Getwd获取的则是系统服务调用的工作目录
解决：
项目用的是golang开发，这里用到了 os.Executable() 来返回当前实际运行exe的路径，而不是调用者的工作路径。
func GetPath() (string, error) { executable, err := os.Executable() if err != nil { return "", err } symlinks, err := filepath.EvalSymlinks(executable) if err != nil { return "", err } rootPath := filepath.Dir(symlinks) if rootPath == "." { return "", errors.New("dir is empty") } return rootPath, nil } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5dc03864aa66ee1811492d6a0dc8eb2/" rel="bookmark">
			【python-opencv入门笔记】8 - 形态学操作：膨胀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单来说，膨胀就是把图像中的物体变大了！
与腐蚀操作一样，也需要一个矩阵参数。
膨胀函数：dilate(图像,矩阵)
示例图片：
源码
import cv2 import numpy as np csdn_img = cv2.imread("./csdn2.jpg") # 读取图像 k1 = np.ones((3, 3), np.uint8) # 3个不同尺度的膨胀单元 k2 = np.ones((5, 5), np.uint8) k3 = np.ones((9, 9), np.uint8) k1_img = cv2.dilate(csdn_img, k1) # 膨胀函数 k2_img = cv2.dilate(csdn_img, k2) k3_img = cv2.dilate(csdn_img, k3) cv2.imshow("csdn_img", csdn_img) cv2.imshow("k1_img", k1_img) cv2.imshow("k2_img", k2_img) cv2.imshow("k3_img", k3_img) cv2.waitKey(0) 执行结果：
碰撞矩阵为：(3, 3)
碰撞矩阵为：(5,5)
碰撞矩阵为：(9,9)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd35b8482ef6d91c60d38721c6824b4/" rel="bookmark">
			深度学习——（4）VGG16 图像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习——（4）VGG16 图像分类 文章目录 深度学习——（4）VGG16 图像分类1. model2. train3. predict 上次使用ResNet对图像进行分类，因为现在数据是同一类图像，想要对他进行更加细致的分类，还在学习其他的分类model。最近用VGG16，是站在巨人的肩膀上的一篇博客，是对以前模型的微调，但是真的有学习到，就算是自己的学习记录，后面会学习并尝试其他的model。 1. model 各个VGG在ImageNet上的训练参数下载
model_urls = { 'vgg11': 'https://download.pytorch.org/models/vgg11-bbd30ac9.pth', 'vgg13': 'https://download.pytorch.org/models/vgg13-c768596a.pth', 'vgg16': 'https://download.pytorch.org/models/vgg16-397923af.pth', 'vgg19': 'https://download.pytorch.org/models/vgg19-dcbb9e9d.pth' } # -*- coding: utf-8 -*- import torch.nn as nn import torch import torchvision.models as models # official pretrain weights device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") class VGG(nn.Module): def __init__(self, features, num_classes=1000, init_weights=False): super(VGG, self).__init__() self.features = features if init_weights==True: # 如果要加载imageNet的权重，还原 self.classifier = nn.Sequential( nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd35b8482ef6d91c60d38721c6824b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/733cc6351a9b64f979871185b5ba3ccd/" rel="bookmark">
			Pycharm打包项目为exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目打包生成exe可执行文件 1.首先，打开自己要发布的工程 ，点击底部的“Terminal”打开终端，输入命令：
pip install pyinstaller ，按回车键运行。
2.输入命令：pyinstaller ，按回车键显示安装成功。
3.输入命令pyinstaller --console --onefile xxx.py
4. exe文件的路径
在项目根目录下有一个dist文件夹，里面会有打包好的exe文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b879b9ffe7586b885ea9e9e4ef7d822/" rel="bookmark">
			如何在隔离电源 PCB 布局中接地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在隔离电源 PCB布局中接地
大多数使用台式电源的设计人员可能会使用插入墙壁的隔离式稳压（开关）PSU。在特定的 DC 或 AC 电平下提供稳定电源所需的一切都内置在该单元中，并且噪声相对较低，作为设计师，除了将一些引线连接到电路板之外，您实际上不需要做任何事情。不幸的是，带有集成电源部分的真实系统，或者甚至只是您想要集成到更大系统中的电源调节器模块，都没有那么简单，需要一些定制设计来确保它们正确运行。
将电源集成到系统中的一个重要方面是正确设置和连接接地，即使对于隔离电源也是如此。如果您将隔离电源与主要电路的其余部分集成到电路板上，您仍然需要在系统中接地。这些规则甚至适用于隔离式 DC 充电器或 DC 电源适配器的 PCB，因为设计可能需要连接回大地，具体取决于应用和安全问题。由于接地连接不良会产生噪声问题，甚至是安全隐患，因此让我们看看在电路板上将交流电转换为直流电时在电源调节部分创建接地连接的最佳做法。
隔离电源中的接地结构
假设您正在设计一个系统，该系统需要执行电源转换（交流到直流）、调节和传输到设计中的电路。如果您考虑该系统的实际构造，有三种不同的可能用于地面的选择：
接地：这是一个真正的接地电气连接，作为 3 线交流线路上的安全线 (PE) 存在。
机箱接地：这适用于带有金属元件的外壳，其中外壳中的金属用于创建接地连接。
信号地：这有时被错误地描述为模拟地和数字地（不要像这样分开你的地）。信号地通常是指除地或底盘以外的任何东西。
使用变压器耦合构建的电源（例如 AC-DC 转换器、DC-DC 开关转换器或这两种系统的组合）将使用变压器构建以弥补 PCB布局中的这些间隙。原因很简单：除非您仅在低电压和低电流下运行，否则您通常希望在设计中进行隔离以保护用户免受安全危害。
由于各种原因，这些接地系统并不总是位于单个接地平面上。这适用于开关电源，尤其是更复杂的电源，如LLC 谐振转换器。接地如此重要的原因是它定义了组件在系统中运行时测量的电压。当我写“一个组件测量的电压”时，它意味着在系统中的某个接地区域上定义的 5 V 信号在系统中的某个其他接地区域上测量时可能无法在 5V 下测量。
在此图中，如果两个接地区域之间存在电位差，则在右接地区域 (GND2) 上可能会错误地测量源自左侧接地区域 (GND1) 的信号。
隔离式开关电源中的这个问题称为“接地偏移”，会产生噪声问题。这非常重要，因为系统中的接地偏移可能只是您希望在变压器耦合电源中可靠提供的电压的一小部分。
用电容器接地可保持直流隔离
幸运的是，有一个简单的解决方案：用电容器将平面连接在一起。Y 级电容器是较高电压/电流设计的不错选择。您可以在原理图中轻松完成此操作：只需找到您的电容器所需的组件，然后通过直接连接桥接接地网络。在 PCB布局中执行此操作的典型位置靠近变压器。
尽管在 AC-DC 转换中仍然有效，但更复杂的方法是在电源轨和系统的 AC 侧之间使用电容器。通过抽取和释放一些位移电流来消除每一侧之间的接地偏移。
此示意图显示了一种桥接两个接地的简单方法。您会在一些参考设计中看到这一点。
请注意，这仅适用于板上的两个接地区域。我们还没有考虑底盘或地球。但是，您可以采取一些基本步骤来确保外壳、电路板和接地正确连接在一起。不幸的是，这并不是那么简单，需要考虑噪声和电流如何在系统中发挥作用，以及它们是否会造成安全隐患。以下是一些可供进一步阅读的资源，可帮助您确定在保持隔离的同时连接接地的最佳方式。
关于电子设计和 PCB布局中的接地
隔离与非隔离电源：正确的选择
定义电源接地：PCB 中的系统、机箱和接地
如何穿过地平面间隙布线
如果您想为您的电源系统实施控制算法，您将需要允许从输出返回到输入的反馈，以便可以感测到输出功率。这意味着您需要从稳压器一侧的输出端到包含开关元件的输入侧物理运行一条线路。问题是：如果您的输出端是 DC，但您想保持隔离，那么提供的最佳方法是什么？
答案是使用光耦合器。在间隙上放置走线是不合适的，因为走线会接收外部噪声，而开关电源会产生大量噪声。变压器耦合也无法使用，因为您正在调节 DC。在下面的示意图中，光耦合器跨越接地层之间的隔离，因此我们在此电源中保持了所需的隔离。
光耦合器允许您跨地平面间隙发送信号，而无需布线。
放置光耦合器后，您可以将输出路由到电源控制器。具有 PWM 输出的微控制器是定制电源控制器的不错选择，尽管有些公司生产具有反馈输入且可配置一些外部电阻器的 MOSFET 栅极驱动器控制器。如果您正在设计非常精确的功率调节或您正在试验控制算法，这是实现输出检测的简单解决方案。然后，您可以使用标准控制算法来调整 PWM 控制器的频率，以确保最大效率或专门跟踪所需的功率输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d48f3a78137ebad3a85ac103e0fe79/" rel="bookmark">
			Linux系统编程阶段：MySQL数据库相关知识点和函数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据库的作用和介绍
数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。
数据库里面的数据的增删改查速度比文件操作要快的多。
2.mysql的安装
sudo apt-get install mysql-server：服务端安装
sudo apt-get install mysql-client：客户端安装
sudo apt-get install libmysqlclient-dev:相关的库
sudo service mysql start：启动数据库
sudo service mysql stop:关闭
注意点：
在安装的过程中会弹出一个框 ，让你输入数据库的root用户的密码
这个密码一定不要选择跳过 而要设置一个密码
这个密码建议大家都设置成1 。
3.mysql的进入和退出
登录的时候 ，有两种情况
-&gt;假如在安装的时候 成功输入了密码
mysql -u root -p
-&gt;假如在安装的时候 没有设置密码
1）切换到root用户 Ubuntu的root用户
2）在root用户权限下 输入 ：mysql -u root
退出:quit 退出数据库
4.mysql的数据类型
布尔类型：只有0和1
字符类型：
数值类型：整型和浮点型
时间类型：
5.mysql常用词汇
datebase：数据库
table：表
column：列
from：来自
select：选中
*：所有
show：显示
insert：插入
drop：删除
change：更改
update：更新
6.mysql的显示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d48f3a78137ebad3a85ac103e0fe79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d175713987b290ab94319f6fb76de3/" rel="bookmark">
			使用python上传和下载文件到oss中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参看阿里接口文档链接: https://help.aliyun.com/document_detail/88426.html
上传本地文件到oss # -*- coding: utf-8 -*- import oss2 import os AccessKeyId = 'xxx' AccessKeySecret = 'xxx' # [这个是必须的] # 参考链接: https://help.aliyun.com/document_detail/31837.html ENDPOINT = 'https://oss-cn-hangzhou.aliyuncs.com' class HandleOSS(object): def __init__(self, key_id, key_secret, endpoint, bucket='qmgy-private-hz-dev'): ''' 初始化 :param key_id: :param key_secret: :param bucket: bucket名称 ''' self.key_id = key_id self.key_secret = key_secret self.endpoint = endpoint self.bucket = bucket self.auth = oss2.Auth(key_id, key_secret) if bucket: self.bucket = oss2.Bucket(self.auth, self.endpoint, self.bucket) def update_one_file(self, file_path, oss_path): ''' 将文件上传到oss上 :param file_dir: 要上传的文件 :param oss_dir: oss上的路径, 要存在oss上的那个文件 :return: ''' file_name = file_path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d175713987b290ab94319f6fb76de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddb71cbe6a296703117c89621bf8998/" rel="bookmark">
			文献阅读记录——Masked Generative Distillation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅对文章大致的方法做个记录。
先给出论文和代码的链接：https://github.com/yzd-v/MGD
这篇论文讲的是一个通用于各种视觉任务的知识蒸馏方法，因为它属于特征模仿类的知识蒸馏方法。所谓的特征模仿，就是要让学生网络的某一个或几个特征图去模仿对应的教师网络的特征图，从数学表达式上来说，就是计算学生网络特征图和教师网络特征图均方误差，如下所示：
其中F表示特征图，T表示教师，S表示学生，函数falign的作用是将学生网络特征图的shape reshap成和教师网络特征图相同的shape,这样才能逐点计算均方误差。
而本文就是基于上式进行的简单改进，其动机如下：
对于基于cnn的模型，更深层的特征有更大的感受野，对原始输入图片有更好的特征表示。换个角度来说，就是特征图上的像素在一定程度上包含相邻像素的信息。因此我们能使用部分像素来恢复完整的特征图。
此文章中的方法就是去通过学生网络masked feature去生成教师网络的feature，从而帮助学生实现更好的特征表示。
具体实现方法很简单，分为3步： 1、特征对齐，通过1*1卷积将学生网络某一层输出的特征图reshape成和教师网络对应层的特征图的shape一致。
2、生成masked feature. 在特征图上每一个点都生成一个随机数Ri,j（0，1之间），然后有一个超参数𝜆,比这个𝜆大的为1，否则为0，就获得了一个特征掩膜。
这步我个人理解 就是对特征图进行随机的采样，然后获得一个不那么完整的特征图
3、然后将这个掩膜和reshape后的特征图相乘就获得了masked feature;
4、这个masked feature 经过生成模块：3*3conv,Relu,3*3conv 后生成了新的特征图，这个特征图会和教师网络的特征图进行知识蒸馏，即计算两者的特征模仿的损失。
整体流程如下：
整个过程相当的简单啊，和原本的特征模仿相比就多了一个先采样再生成的过程。
这为啥有效，我的想法是：通过这个掩膜，获得了部分的特征图，然后再生成新的特征图去模仿教师网络的特征图，相比原始的特征模仿，多的这一步，是增大网络学习的难度，从而迫使学生网络去学习一个更优秀的特征表示，而生成的特征图去模仿教师网络是因为教师网络的特征表示更优秀，通过模仿可以让学生网络训练时候的”进步“方向不走偏，往学习更优秀的特征表示的方向走。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d441b8b21e9f4622673c0e6dd8089db1/" rel="bookmark">
			信息系统项目管理---第九章 项目人力资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息系统项目管理—第九章 项目人力资源管理 人力资源管理过程说明 （1）规划人力资源管理一识别和记录项目角色、职责、所需技能、报告关系，并编制人员配备管理计划。 （2）组建项目团队一确认人力资源的可用情况，并为开展项目活动而组建团队。 （3）建设项目团队—提高工作能力，促进团队成员互动，改善团队整体氛围，以提高项目绩效。 （4）管理项目团队—跟踪团队成员工作表现，提供反馈，解决问题并管理团队变更，以优化项目绩效的。 领导和管理 领导者：确定方向、统一思想、激励和鼓舞。 管理者：被组织赋予职位和权力，负责某件事情的管理或实现某个目标（关注流程、执行、交付成果、组织及理论等） 领导者设定目标，管理者率众实现目标。项目经理有领导者和管理者的双身份。 前三个权力来自于组织授权（正式权力），后两个来源于管理者自身（人身权力）。 项目经理应更注重运用奖励权力、专家权力和参照权力，尽量避免使用惩罚权力。 马斯洛需求层次理论：生理、安全、社会、尊重、自我实现 生理、安全、社交、尊重、自我；5个层次。 1.生理需求：对衣食住行等需求都是生理需求，这类需求的级别最低，人们在转向较高层次的需求之前，总是尽力满足这类需求。常见的激励措施：员工宿舍、工作餐、工作服、班车、工资、补贴、奖金等。 2.安全需求：包括对人身安全、生活稳定、不致失业以及免遭痛苦、威胁或疾病等的需求。和生理需求一样， 在安全需求没有得到满足之前，人们一般不追求更高层的需求。常见的激励措施：养老保险、医疗保障、长期劳动合同、意外保险、失业保险等。 3.社会交往的需求：包括对友谊、爱情以及隶属关系的需求。当生理需求和安全需求得到满足后，社交需求就会突出出来，进而产生激励作用。这些需求如果得不到满足，就会影响员工的精神，导致高缺勤率、低生产率、对工作不满及情绪低落。常见的激励措施：定期员工活动、聚会、比赛、俱乐部等。 4.受尊重的需求：自尊心和荣誉感。荣誉来自别人，自尊来自自己。常见的激励措施：荣誉性的奖励，形象、地位的提升，颁发奖章，作为导师培训别人等。 5.自我实现的需求：实现自己的潜力，发挥个人能力到最大程度，使自己越来越成为自己所期望的人物。达到自我实现境界的人，必须干与其能力相称的工作，这样才会使他们感到最大的快乐。常见的激励措施：给他更多的空间让他负责、让他成为智囊团、参与决策、参与公司的管理会议等。 赫兹伯格双因素理论 第一类是保健因素（Hygiene Factor），这些因素是与工作环境或条件有关的，能防止人们产生不满意感的一类因素，包括工作环境、工资薪水、公司政策、个人生活、管理监督、人际关系等。 当保健因素不健全时， 人们就会对工作产生不满意感。但即使保健因素很好时，也仅仅可以消除工作中的不满意，却无法增加人们对工作的满意感，所以这些因素是无法起到激励作用的。 第二类是激励因素（Motivator），这些因素是与员工的工作本身或工作内容有关的、能促使人们产生工作满意感的一类因素，是高层次的需要，包括成就、承认、工作本身、责任、发展机会等。 当激励因素缺乏时， 人们就会缺乏进取心，对工作无所谓，但一旦具备了激励因素，员工则会感觉到强大的激励力量而产生对工作的满意感，所以只有这 类因素才能真正激励员工。 麦格雷格的X、Y理论 期望理论 人力资源管理内容 一、规划人力资源管理 1、规划人力资源管理的工具技术 01、组织结构图和职位描述 02、责任分配矩阵 2、规划人力资源管理—输出 人力资源管理计划 01、角色与职责 02、项目组织图 03、人员配备管理计划 04、人力资源管理计划示例 05、资源日历 二、组建项目团队 1、组建项目团队—工具技术 01、预分派：事先指定或分派到项目的人员。 02、谈判：同职能部门、其他项目管理团队、外部组织等谈判，争取资源。 03、招募：外部招募、或外包。 04、虚拟团队：少见面或不见面，通过现代沟通技术（如电子邮件、电话会议、社交媒体、网络会议和视屏会议等）完成项目工作。在虚拟团队中，沟通规划很重要。 优点：可在不同地理位置的员工之间组建团队；增加特殊技能，即使专家不在同一区域；可在家办公；可将不同班次的员工组建团队；将行动不便者或残疾人纳入团队；执行那些原本会因差旅费过高而被否决的项目。 缺点：虚拟团队的一些缺点，例如：可能产生误解、有孤立感，团队成员之间难以分享知识和经验，采用通信技术的成本等。 05、多维决策分析：通过标准决策分析，制定出选择标准，并根据此对候选团队成员进行定级或打分。如可用性、成本、经验、能力、知识、技能、态度等。 2、虚拟团队 虚拟团队（Virtual Teams）的使用为招募项目团队成员提供了新的可能性。虚拟团队可定义为具有共同目标、在完成角色任务的过程中很少或没有时间面对面工作的一群人。现代沟通技术（如电子邮件、电话会议、社交媒体、网络会议和视频会议等）使虚拟团队成为可行。 虚拟团队形式的利： •在组织内部地处不同地理位置的员工之间组建团队。 •为项目团队增加特殊技能，即使相应的专家不在同一地理区域。 •将在家办公的员工纳入团队。 •在工作班次、工作小时或工作日不同的员工之间组建团队。 •将行动不便者或残疾人纳入团队。 •执行那些原本会因差旅费用过高而被否决的项目。虚拟团队形式的弊： 虚拟团队也有一些缺点，例如，可能产生误解，有孤立感，团队成员之间难以分享知识和经验，采用通信技术的成本。 在虚拟团队的环境中，沟通规划变得尤为重要。项目管理团队需要花更多时间，来设定明确的期望，促进沟通，制定冲突解决方法，召集人员参与决策，理解文化差异，以及共享成功喜悦。 三、建设项目团队 1、如何建设高效团队及建设团队的目标 1.1 建设团队的目标 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d441b8b21e9f4622673c0e6dd8089db1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80674c94fd5a393b3e5879226d3287a7/" rel="bookmark">
			实现OCR语言识别Demo（一）- BottomSheet实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现OCR语言识别Demo（一）- ButtomSheet实现 实现BottomSheetBottomSheet布局实现假数据准备BottomSheet代码实现 先来看看最终效果 正如你们看到的，这个Demo的功能是我们可以从手机里或者是拍照的方式获取到某张图片，然后经过OCR识别文字后，将识别出来的文字在图片上全部都框选出来，并且在底部以扩展界面的方式可以查看识别内容的列表，点击列表里的某一项识别项就会在图片上选中这一项识别项，反过来点击图片上的框选的识别项也会在列表中进行这一对应项的选中。
想要实现上面的这种效果，我们需要解决这几个技术点
实现内嵌RecycleView的BottomSheet图片大小跟随BottomSheet展开折叠的缩放处理图片上展示识别内容的渲染方式图片上识别内容的点击行为实现 让我们一步一步来实现并且一步步的解决这些问题
实现BottomSheet BottomSheet布局实现 首先我们为应用创建一个带BottomSheet的布局，实现main页面布局
activity_main.xml中
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/coordinator_Layout" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_height="match_parent" android:layout_width="match_parent" android:background="@color/white"&gt; &lt;io.github.karl.ocrdemo.OcrImageView android:id="@+id/image_preview" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center|top" android:scaleType="fitCenter" tools:src="@tools:sample/backgrounds/scenic" /&gt; &lt;LinearLayout android:id="@+id/custom_bottom_sheet" android:layout_width="match_parent" android:layout_height="210dp" app:layout_behavior="com.google.android.material.bottomsheet.BottomSheetBehavior" app:layout_anchorGravity="bottom|end" app:behavior_peekHeight="50dp" app:behavior_hideable="false" android:background="@drawable/bottom_sheet_layout_shape" android:paddingStart="6dp" android:paddingEnd="6dp" android:orientation="vertical"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/image_view" android:layout_width="match_parent" android:layout_height="50dp" android:layout_marginTop="2dp" android:scaleType="center" android:src="@mipmap/round_bar_icon" app:layout_constraintTop_toTopOf="parent" android:clickable="true" android:focusable="true"/&gt; &lt;ImageView android:id="@+id/open_take_pic" android:layout_width="30dp" android:layout_height="30dp" android:alpha="0.25" android:src="@mipmap/icon_takepic" android:scaleType="fitCenter" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintBottom_toBottomOf="parent" app:tint="@color/black" /&gt; &lt;ImageView android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80674c94fd5a393b3e5879226d3287a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52cabd88a4c0b0973fbcbf9f4f3bd08c/" rel="bookmark">
			ThreadPoolTaskExecutor和ThreadPoolExecutor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 今天在浏览代码发现前辈使用了ThreadPoolTaskExecutor，一时间有点懵，因为并不属于任何一个jdk下的线程池。后面浏览资料发现它属于Spring自带，所以根据网上博客来学习下：
首先在学习Spring自带的ThreadPoolTaskExecutor之前，我们先来回顾下老朋友：jdk下的ThreadPoolExecutor，很多人容易把这两个搞混。
二、ThreadPoolExecutor 这个类是JDK中的线程池类，继承自Executor， Executor 顾名思义是专门用来处理多线程相关的一个接口，所有线程相关的类都实现了这个接口，里面有一个execute()方法，用来执行线程，线程池主要提供一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁的额外开销，提高了响应的速度。相关的继承实现类图例如ScheduledThreadPoolExecutor。
2.1、线程池接口 ExecutorService为线程池接口，提供了线程池生命周期方法，继承自Executor接口，ThreadPoolExecutor为线程池实现类，提供了线程池的维护操作等相关方法，继承自AbstractExecutorService，AbstractExecutorService实现了ExecutorService接口。
2.2、java.util.concurrent.Executor 负责线程的使用和调度的根接口 |--ExecutorService 子接口： 线程池的主要接口 |--ThreadPoolExecutor 线程池的实现类 |--ScheduledExceutorService 子接口： 负责线程的调度 |--ScheduledThreadPoolExecutor : 继承ThreadPoolExecutor，实现了ScheduledExecutorService 2.3、工具类 ： Executors Executors为线程池工具类，相当于一个工厂类，用来创建合适的线程池，返回ExecutorService类型的线程池。有人如下方法。
ExecutorService newFixedThreadPool() : 创建固定大小的线程池
ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。
ExecutorService newSingleThreadExecutor() : 创建单个线程池。 线程池中只有一个线程
ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务
其中AbstractExecutorService是他的抽象父类，继承自ExecutorService,ExecutorService 接口扩展Executor接口，增加了生命周期方法。
实际应用中我一般都比较喜欢使用Exectuors工厂类来创建线程池，里面有五个方法，分别创建不同的线程池，如上，创建一个制定大小的线程池，Exectuors工厂实际上就是调用的ExectuorPoolService的构造方法，传入默认参数。
public class Executors { /** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52cabd88a4c0b0973fbcbf9f4f3bd08c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4ca31e1356b1df78a1885445436f6d/" rel="bookmark">
			nginx&#43;lua实现客户端请求token校验和动态获取转发uri实现rewrite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求场景：
1、客户端请求服务端时通过nginx转发，但是需要完成对请求相关的身份校验，如果客户端携带的token不合法则不允许请求；2、服务是多租户模式的，不同租户的客户端发起请求的uri所携带的标识不一致，且并非服务端接口实际的uri，另外还需要根据客户端发起请求携带的标识将服务请求转发至对应租户的服务端完成请求； nginx的location代码块：
location ~ /38ad46566ae64a20896bd95769c89199 { set $req_type "https"; #lua脚本完成对客户端token的校验 access_by_lua_file /usr/local/openresty/nginx/conf/lua/token_filter.lua; #lua脚本完成对客户端请求的uri的动态转换 set_by_lua_file $router /usr/local/openresty/nginx/conf/lua/router.lua; rewrite ^(.*) $router break; proxy_pass https://upstream_38ad46566ae64a20896bd95769c89199; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } 解决方案：
根据不同租户发起请求时的标识，将请求转发至对应的服务端 location ~ /38ad46566ae64a20896bd95769c89199 { } 可以看到location的匹配规则是通过通配符来匹配的，只要客户端请求的uri中包含
/38ad46566ae64a20896bd95769c89199
uri 作为一个 string，只要 regex 匹配其中的一部分，即可算作匹配成功，就认为请求是需要这个location去转发的，当然这也需要根据客户端实际的请求uri去决定使用哪种location匹配规则，我们服务中的客户端端请求的最后一级是租户的标识，所以使用regex 匹配是最合适的。
解决nginx转发的同时校验token方案
首选需要将nginx和lua配合使用，在nginx转发的同时，调用lua脚本完成对客户端请求时所携带token的校验工作，可以看到location代码块中增加了一行代码，引用了一个lua脚本， #lua脚本完成对客户端token的校验 access_by_lua_file /usr/local/openresty/nginx/conf/lua/token_filter.lua; 这个lua脚本就是用来完成对客户端请求token的校验功能，下面一起来看token_filter.lua脚本的具体实现：
function getHost() return ngx.var.host end function getUri() return ngx.var.uri end function getToken() --获取客户端请求的token，客户端的toekn存放在请求header的token属性 local reqHeaders = ngx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4ca31e1356b1df78a1885445436f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2a5e3dfeef2de21a42977f53a60d52/" rel="bookmark">
			使用OfficeDeploymentTool工具离线下载安装Office
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 配置下载安装 OfficeDeploymentTool（ODT）是一款命令行工具，可以使用它下载并将 Microsoft 365 应用版部署到客户端计算机。ODT可以更好地控制Office 安装：可以定义要安装哪些产品和语言、应该如何更新这些产品以及是否向用户显示安装体验。
从 Microsoft 下载中心下载Office部署工具。这将得到一个officedeploymenttool_14326-20404.exe文件。这是一个自解压可执行文件。
双击运行它，在弹出的对话框中指定一个空的文件夹，例如D:\OfficeDeploymentTool。执行完成之后，在这个文件夹中将出现1个setup.exe文件和4个*.xml文件。
setup.exe是Office部署工具可执行文件，*.xml文件是示例配置文件。其中，
configuration-Office365-x64.xml文件用于安装Microsoft 365 Apps for enterprise版本configuration-Office2021Enterprise.xml文件用于安装Microsoft 365 Apps for business版本 配置 对于个人用户，推荐安装Microsoft 365 Apps for enterprise。
用记事本打开configuration-Office365-x64.xml文件。将&lt;Language&gt;标签的ID属性修改成zh-cn。 如下所示：
&lt;!-- Office 365 client configuration file sample. To be used for Office 365 ProPlus apps, Office 365 Business apps, Project Pro for Office 365 and Visio Pro for Office 365. For detailed information regarding configuration options visit: http://aka.ms/ODT. To use the configuration file be sure to remove the comments The following sample allows you to download and install the 64 bit version of the Office 365 ProPlus apps and Visio Pro for Office 365 directly from the Office CDN using the Current Channel settings --&gt; &lt;Configuration&gt; &lt;Add OfficeClientEdition="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a2a5e3dfeef2de21a42977f53a60d52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e964e2dc6e89959dc1298d83a30ebfc4/" rel="bookmark">
			金蝶天燕Apusic AAS V10.0 5.1 8.0 9.0 9.1 信创国产化中间件 EAS Apusic V5.1 V9.0 永久
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apusic V5.0-5.1 ：
apusic V6.0-8.0：
apusic AAS V9.0：
apusic AAS V10.0：
EAS apusic V5.1-9.0：
一年：
一个月测试：
金蝶天燕Apusic AAS V10.0 5.1 8.0 9.0 9.1 信创国产化中间件 EAS Apusic V5.1 V9.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ea9dbfd4806394d6eb37ad0d31c118/" rel="bookmark">
			Docker 学习笔记（八）-- Dockerfile 构建CentOS 实战测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Hub 中99%的镜像都是从这个基础镜像（Scratch）中安装和配置需要的软件和配置构建出来的！
创建一个自己的 CentOS
1、查看官方镜像 2、编写自己的 DockerFile 初始化：
cd /home mkdir dockerfile vim dockerfile-centos 编写 dockerfile-centos：
FROM centos MAINTAINER mianbao&lt;843818747@qq.com&gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim \ &amp;&amp; yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo "----end----" CMD ["/bin/bash"] 3、通过这个文件构建镜像
# docker build -f dockerfile文件路径 -t 镜像名:[tag] 其中t表示target # . 表示当前目录（输出路径） [root@localhost dockerfile]$ docker build -f dockerfile-centos -t mycentos:1.0 . 3、报错和解决 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72ea9dbfd4806394d6eb37ad0d31c118/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ce67437b73ff81e30f91b33e9f25d9/" rel="bookmark">
			R语言手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.训练集数据的选择
2.模型的构建
3.模型训练
4.结果
噪声方差0.1：测试集上的准确率82.41%
噪声方差0.25：测试集上的准确率75.91%。
噪声方差0.5：测试集上的准确率67.37%。
5.代码 6.数据来源
1.训练集数据的选择 原数据文件中有60000个个体，要求选择1000个个体进行模型的训练（为了提高训练难度），其余的个体丢弃。有0~9共10种标签，为保证标签的平衡，防止某一种标签的训练集过少而造成训练结果较差，对10种标签进行相同数量的选择，即每种标签选择100个个体作为训练集。具体操作是按照标签将个体分成10类，每一类随机选择100个个体，将选择结果进行合并组成训练集。
若要求使用全部的训练集，则忽略此步。
2.模型的构建 利用keras的模型，是一个多个网络层的线性堆迭，通过向Sequential模型传递一个layer的列表构造。模型有一个784节点的输入层，一个784节点的全连接层，10个节点的输出层。激活函数选择为relu与exponential，损失函数选择为categorical_crossentropy，优化器选择为Nadam。评估标准选择为accuracy。
3.模型训练 每次神经网络的升级是使用了100个样本，这100个样本来自于对1000个样本的抽样。每个epoch包含了10次iteration，一共100个epoch。
4.结果 模型训练结果：
没有噪声：测试集上的准确率91.57%。 噪声方差0.1：测试集上的准确率82.41% 噪声方差0.25：测试集上的准确率75.91%。 噪声方差0.5：测试集上的准确率67.37%。 5.代码 rm(list=ls()) ##读取图片数据的函数，返回一个数据列表 read_image&lt;-function(filename){ read.filename &lt;- file(filename, "rb") test&lt;-list() length(test)&lt;-7 names(test)&lt;-c("magic_number1","magic_number2","number_of_images", "number_of_rows","number_of_columns","data","label") test$magic_number1&lt;-readBin(read.filename,integer(),size=4,n=1,endian="big") test$number_of_images&lt;-readBin(read.filename,integer(),size=4,n=1,endian="big") test$number_of_rows&lt;-readBin(read.filename,integer(),size=4,n=1,endian="big") test$number_of_columns&lt;-readBin(read.filename,integer(),size=4,n=1,endian="big") data&lt;-readBin(read.filename,integer(),size=1,n=test$number_of_images*test$number_of_rows*test$number_of_columns,signed=F,endian="big") data&lt;-data/255 data&lt;-matrix(data,byrow=T,test$number_of_images,test$number_of_rows*test$number_of_columns) data&lt;-as.data.frame(data) test$data&lt;-data close(read.filename) return (test) } ##读取图片标签的函数，返回数据列表 read_label&lt;-function(filename,test){ read.filename &lt;- file(filename, "rb") test$magic_number2&lt;-readBin(read.filename,integer(),size=4,n=1,endian="big") readBin(read.filename,integer(),size=4,n=1,endian="big") data&lt;-readBin(read.filename,integer(),size=1,n=test$number_of_images,signed=F,endian="big") test$label&lt;- as.factor(data) close(read.filename) return (test) } ##选取训练数据集函数 Randomlychoose&lt;-function(test,r){ d0&lt;-test$data[which(test$label=="0"),] d1&lt;-test$data[which(test$label=="1"),] d2&lt;-test$data[which(test$label=="2"),] d3&lt;-test$data[which(test$label=="3"),] d4&lt;-test$data[which(test$label=="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73ce67437b73ff81e30f91b33e9f25d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97206c39ad36bfa79527f1b46cd15e8f/" rel="bookmark">
			本地DNS服务器的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS服务器基本搭建
linux/server DNS功能以及过程：
用户在访问某一个域名的时候实际不是直接访问到这个承载业务的这个服务器而是先解析获取到这个域名对应的公网IP地址再请这个IP发送访问requst请求，这个解析会先在电脑本地缓存查询在没有的场景下会到上级的dns服务器来请求，如下图所示的就是一次DNS请求。
在一些特殊场景中通常机器不能使用使用dns解析的场景下，或者有内网访问业务非公网域名的情况下我们就可以通过配置属于我们私域的DNS服务器也叫本地域名服务器，来实现本地域名的解析以及公网域名的解析
以下的配置步骤：以centos/redhat系列系统为列其他版本操作方法类似只是配置文件不同罢了
一、配置DNS服务器网络 注意：DNS服务器要有必须要有一个静态的ip地址，如果使用DHCP获取的地址到期那可能会有一种情况就是DNS服务器的地址发生的变化，但此时用户的DNS配置不是实时更新的，在没有备用dns的场景下就会无法解析
（1）编写网卡主配置文件 vim /etc/sysconfig/network-scripts/ifcfg-ens33 内容： TYPE=Ethernet BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no NAME=ens33 UUID=7fac3a10-de6b-42c6-9175-cef32343c69b DEVICE=ens33 ONBOOT=yes //这个是网卡的开机自启选项，建议配置为yes IPADDR=192.168.35.1 //这个是机器的ipv4地址 NETMASK=255.255.255.0 //子网掩码 DNS1=192.168.35.1	//为DNS指定DNS服务器地址，如果没有访问外网的需求指定自己就好了，这样就实现了一个需求就是纯内网解析 （2）重启网络服务	systemctl restart network //重启网络服务 （3）查看网卡配置文件是否生效 ifconfig //查看网络配置 二、配置yum仓库（二选一） 方法1：机器不能联网的情况下使用，以挂载媒介做的本地的yum仓库，iso镜像里有集成一些软件包
（1）挂载光盘 vim /etc/fstab 内容： 添加一行： /dev/sr0	/mnt/cdrom	iso9660	defaults	0 0 （2）创建挂载点 mkdir /mnt/cdrom （3）刷新挂载表 mount -a （4）查看 lsblk （5）编辑仓库文件 vim /etc/yum.repo.d/a.repo 内容： [a] name=a gpgcheck=0 enabled=1 baseurl=file:///mnt/cdrom （6）查看仓库资源 yum repolist 方法2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97206c39ad36bfa79527f1b46cd15e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ecc306c974e860f7a8494665e4cd27/" rel="bookmark">
			JavaWeb在线商城系统(java&#43;jsp&#43;servlet&#43;MySQL&#43;jdbc&#43;css&#43;js&#43;jQuery)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaWeb在线商城系统 JavaWeb在线商城开发知识总结(java+jsp+servlet+MySQL+jdbc+css+js+jQuery)获取项目数据和数据库：期末实训项目-JavaWeb在线商城系统项目代码及数据库下载链接 数据库设计前端界面设计商城首页登录注册页面购物车页面 编写代码实现功能连接数据库实现登录注册功能购物车连接数据库，将商品加入购物车后，能够查看商品详细信息通过点击首页的商品图片，查看商品的详细信息资源包 JavaWeb在线商城开发知识总结(java+jsp+servlet+MySQL+jdbc+css+js+jQuery) 这个基于JavaWeb的在线商城项目是我们专业这学期期末实训的项目
项目视频演示
期末实训项目-JavaWeb在线商城系统(java+jsp+servlet+MySQL+jdbc+css+js+jQuery)
获取项目数据和数据库： 期末实训项目-JavaWeb在线商城系统 项目代码及数据库下载链接 gitee链接：
https://gitee.com/yuhaowen/ShoppingMall.git
GitHub：
https://github.com/yuhaowen0917/JavaWeb-ShoppingMall.git
项目资源和数据库
https://download.csdn.net/download/yuyunbai0917/85839278
项目结构图
数据库设计 前端界面设计 商城首页 商城首页.html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;实训在线商城&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/public.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="css/shouye.css"/&gt; &lt;script src="js/jquery-3.6.0.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="js/front_page.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="head"&gt; &lt;div class="head_zi"&gt; &lt;div class="huan"&gt; ,欢迎您 &lt;/div&gt; &lt;div class="car"&gt; &lt;a href="购物车界面.html"&gt;&lt;img src="images/购物车.png" height="28px"&gt; &lt;span&gt;购物车&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="login"&gt; &lt;div&gt;&lt;a href="注册.html"&gt;登录&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88ecc306c974e860f7a8494665e4cd27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f76b54a754581dc4d67db255cf4ac9f/" rel="bookmark">
			关于C&#43;&#43;&amp;Python混编实现算法检测的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ​ 本文提供了将Python算法嵌入C++或C语言的两种实现思路。算法大多是由Python语言编写，而我们开发软件大多使用的还是C++，比如常见的QT、C#等，两种不同的语言之间如何实现通信呢？有的将算法打包为.exe文件，通过软件去启动这个.exe，这种方法并不优雅。我们知道Python的底层是C语言编写，叫CPython，本文方法便是通过CPython调用Python脚本，实现数据交互。
​ 假设我们现在使用QT开发软件界面，通过摄像头去识别物体，所用算法为YoloV5，将带有检测结果的视频显示在QT界面上。
方法一 ​ QT开启一个视频接收的线程，通过opencv接收，将每一帧图像存放在消息队列中，假设消息队列叫srcMatQueue；再开启一个图像检测线程，将图像从srcMatQueue中取出，将图像传递给Python算法，获取返回之后的图像，并存入消息队列detectMatQueue中；再主线程(GUI)中，取出detectMatQueue中的图像，转为QImage格式，然后显示即可。
​ 这里重点介绍第二个图像检测线程。首先，要调用CPython，我们需要包含其头文件Python.h，如下
#include &lt;python/Python.h&gt; #include &lt;numpy/ndarrayobject.h&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/core.hpp&gt; #include &lt;opencv2/videoio.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; 调用Python算法可分为一下几步：
初始化Python环境加载Python模块获取模块中的函数名、类名等获取类名实例化类调用类中的方法 显然，我们需要将Python算法封装为一个类然后调用，（不封装也可以，只是封装为类后，我们可以在初始化时先加载模型，这样可以节省检测时多次加载模型），以YoloV5为例，我们只要将detect.py文件重新封装一下即可。我们封装的函数主要有三个，分别是__init__、loadModel、detect，__init__是实例化这个类时执行的函数，主要对一些变量进行初始化；loadModel函数是单独加载模型文件的函数，一般来说，加载模型比较耗时，你也可以直接将其写在初始化函数里；detect函数是对QT传给它的图像进行处理的函数，所以需要有一个入口参数frame，算法对frame进行处理后将结果return即可，需要注意的是返回的类型，QT端对返回值进行解析，得到处理后的图片和检测结果。
​ 以下是YoloV5中detect.py封装示例。
# This Python file uses the following encoding: utf-8 import os import sys from pathlib import Path import cv2 import torch # import torch.backends.cudnn as cudnn import numpy as np FILE = Path(__file__).resolve() ROOT = FILE.parents[0] # YOLOv5 root directory if str(ROOT) not in sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f76b54a754581dc4d67db255cf4ac9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31eef72050bc0297ac417c44be0e546c/" rel="bookmark">
			Dao层、Service层和Controller层之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要思想是面向接口编程。表示层调用控制层，控制层调用业务层，业务层调用数据访问层。是为了解耦和、提高代码复用。
Dao层
Dao层主要做数据持久层的工作，
负责与数据库进行联络的一些任务都封装在此
Dao层的设计
设计Dao层的接口 在Spring的配置文件中定义此接口的实现类 在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类 显得结构非常清晰，Dao层的数据源配置，以及有关数据库连接参数都在Spring配置文件中进行配置。
Dao接口中的方法都大同小异，因为对数据库的基本操作类似：insert、delete、update，select,也就是增删改查。 在Dao层定义的一些方法，在Service层并没有被使用的情况：Dao层的操作经过抽象后基本都是通用的，在Dao层完成相关方法的定义，有利于支持后期Service层的扩展。Dao会根据业务需求，构造SQL语句，构造参数，调用帮助类，获取结果
Service层
Service层主要负责业务模块的应用逻辑应用设计。将表示层与Dao数据访问层之间联系起来。所要负责的，就是处理涉及业务逻辑相关的问题，比如在调用访问数据库之前，先处理数据、判断数据。
设计接口 设计其实现类 在Spring的配置文件中配置其实现的关联。 这样就可以在应用中调用Service接口来进行业务处理。Service层的业务层具体要调用已经定义的Dao层接口，封装service层业务逻辑有利于通用的业务逻辑的独立性和重复利用性.
Controller层
Controller层负责具体的业务模块流程的控制。在此层要调用service层的接口来控制业务流程。负责url映射（action）。控制的配置也同样是在Spring的配置文件里进行，针对具体的业务流程，会有不同的控制器。我们具体的设计过程可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块。这样不仅使程序结构变得清晰，也大大减少了代码量。
关系：
Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是Controller层之下的，因而 Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。
每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。
参考链接：https://blog.csdn.net/qq_44645822/article/details/112061942
参考链接：https://blog.csdn.net/huangxiaozuo/article/details/71178445
参考链接：https://blog.csdn.net/weixin_42153410/article/details/90753696
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506c1ba601adad23b928e181e3837634/" rel="bookmark">
			HCIP干货笔记总结（5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有携带路由信息的 LSA 都需要通过 1 类和 2 类 LSA 进行验算 。----所谓验 算就是指传递路由信息的通告者的位置信息需要通过1类，2类LSA信息计 算出来。 Type-5 LSA Metric（ cost ）---5类LSA携带的通过重发布导入进来的域外的路由信息，因为不同网络对度量值的评判标准不同，所以，当域外路由导入到本网络当中，我们将放弃其原先的开销值，而赋予他一个定义值---seed-metric ----种子度量值。OSPF网络中默认的种子度量值为1。 [r4-ospf-1]import-route rip 1 cost 10---在重发布时修改种子度量值 E Type---一个标记位，当标记位置0时，则代表使用类型1；当标记位置1时，则代表使用类型2 ----指的是开销值的类型---OSPF协议默认使用类型2。 类型1 ：如果开销值类型为类型 1 ，则域内所有设备到达域外目标 网段的开销值等于本地到达通告者的开销值加种子度量值。 [r4-ospf-1]import-route rip 1 type 1---重发布时修改开销值类型 类型2 ：如果开销值类型为类型 2，则所有域内设备到达域外目标网段的开销值都等同于种子度量值。 Forwarding Address---转发地址---一个重定向地址，类似于RIPV2中的下一跳字段，当出现选路不佳的情况，则将会把最佳选路信息携带在这个字段上，则将按照转发地址寻找下一跳，而不再按照算法寻找通告者。5类LSA中，在不存在选路不佳的情况下，将使用0.0.0.0 来进行填充 Tag---路由标记---可以给5类LSA打标记，方便后面通过标记来抓取流量。 [r4-ospf-1]import-route rip 1 tag ? INTEGER&lt;0-4294967295&gt; Tag value Type -4 LSA ---辅助5类LSA完成验算过程，找到ASBR的位置。里面只 携带一个开销值，指的是通告者到达ASBR的开销。 V --- 置 1 ，则代表该路由器是 VLINK 的一个端点 E --- 置 1 ，则代表该路由器是 ASBR 设备 B --- 置 1 ，则代表该路由器是区域边界设备 ABR 。 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506c1ba601adad23b928e181e3837634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7158605a8344f96558f848f56f4b5b52/" rel="bookmark">
			springboot 注入方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Field 注入 field 注入方式是使用最多的，原因是这种方式使用起来非常简单，代码更加简洁。
@Controller public class HelloController { @Autowired private AlphaService alphaService; @Autowired private BetaService betaService; } 2、Setter 方法注入 该注入写起来不太方便，看起来也不整洁，个人不建议使用
@Controller public class HelloController { private AlphaService alphaService; private BetaService betaService; @Autowired public void setAlphaService(AlphaService alphaService) { this.alphaService = alphaService; } @Autowired public void setBetaService(BetaService betaService) { this.betaService = betaService; } } 3、Constructor 注入（构造器注入） 有利于强制依赖。通过在构造函数中提供依赖，您可以确保依赖对象在被构造时已准备好被使用。在构造函数中赋值的字段也可以是final的，这使得对象是完全不可变的，或者至少可以保护其必需的字段。
构造器注入还可以避免 Field 注入的循环依赖问题，比如 在 Alpha 中注入 Beta，又在 Beta 中注入 Alpha。如果使用构造器注入，在 Spring 启动的时候就会抛出 BeanCurrentlyInCreationException 提醒循环依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7158605a8344f96558f848f56f4b5b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5de506e04bd3c72df00846334729b56/" rel="bookmark">
			linux软硬连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软连接（快捷方式） 硬链接 文件数据存储在硬盘上，最小的存储单元是扇区，sector磁盘扇区大小，512bytes，也就是0.5kb（现在文件动辄几GB）操作系统在磁盘上读取扇区数据，以多个连续的扇区进行读取，这个连续的扇区，被称之为block（块）因此操作系统进行文件读写最小单位是块，8个扇区大小，也就是4kb。 inode 操作系统中专门用于管理和存储文件的信息软件被称为文件系统文件是以文件数据+文件元信息组成的，文件的inode号+文件数据内容代表一个单个文件文件系统又将文件元信息（元信息：存储文件大小，修改信息等，可用stat命令查看）存储在了一个称之为inode的地方，中文叫索引节点查看文件的inode号,ls -li filename.txt通过ls -l 查看到的数据，唯独文件名不属于inode存储的元信息 inode信息 文件大小属主信息属组信息文件权限数字文件修改时间文件的实体指针，指向block位置 访问文件原理 cat文件名找到inode编号根据inode号码找到文件在磁盘上的位置，也就是block的位置
磁盘在格式化的时候，系统自动的分为了2部分，一部分是元数据区域，存放文件的inode信息，一个是文件数据内容区域。每个inode的大小，都是在格式化分区的时候决定好了，默认是128或者256字节。 区别 软连接的inode号码是不一样的，代表软连接文件是单个的个体，硬链接的inode号是一样的。目录文件夹不支持硬链接。软连接可以针对文件夹操作。硬链接数据量的增加，会增加inode号码的计数（增加计数，不是增加inode号码）。创建硬链接：ln /opt/happy.txt /opt/happy1。 综合对比 删除软连接对源文件和硬链接无影响删除硬链接对软连接，源文件也是无影响的删除源文件对硬链接无影响，但是影响软连接删除源文件和所有硬链接，文件的链接数为0，此时文件数据丢失源文件和硬链接具有相同的inode号码，相当于超时的不同门 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e9db3ad5cd78d9348de3697a857ee5/" rel="bookmark">
			K8S管理命令(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置kubectl自动补全
source &lt;（kubectl completion bash）
node节点查看日志
journalctl -u kubelet -f
kubectl get pods --show tables
标签的格式（键值对的格式）
查看master节点的状态
kubectl get cs
kubectl api-resources | grep namespace
default #系统的默认命名空间
查看default命名空间下的所有资源
创建命名空间
kubectl create ns ky18（删除用delete）
区别
kubectl run：用于创建一个自主式的/静态Pod
kubectl delete pod
增kubectl create deployment ：用于创建deployment控制器管理的Pod
删kubectl delete deployment
改kubectl scale --replicas=
查kubectl get pod
若pod无法删除，总是处于terminate状态，则要强行删除pod
kubectl delete pod &lt;pod-name&gt; -n &lt;namespace&gt; --force --grace-period=0
service的四种类型
nodeport只支持四层转发，并且端口是有限的 如何查看一个service绑定了几个节点
删除标签后会自动生成一个从而达到期望值
将删除的标签添加回来 K8S中的四种端口号： containerPort：容器内部进程使用的端口
Port：为service在clusterIP上暴露的端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20e9db3ad5cd78d9348de3697a857ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3d08ba4a0b986e87d8a1a5d45fc928/" rel="bookmark">
			MySQL常见的几种数据类型盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：微点阅读 https://www.weidianyuedu.com
一、数据类型是什么？
数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型。
有一些数据是要存储为数字的，数字当中有些是要存储为整数、小数、日期型等...
二、MYSQL常见数据类型
MySQL支持多种类型，大致可以分为四类：数值型、浮点型、日期/时间和字符串(字符)类型。
1、数值类型
MySQL支持所有标准SQL数值数据类型。
这些数值类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。
关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。
作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围：
2、 浮点型
比如，我们发的工资，一般都带有小数。
3、日期和时间类型
表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。
每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。
TIMESTAMP类型有专有的自动更新特性，将在后面描述。
在生产里，日期时间型，往往用的比较少，而是用数字类型来取代日期类型！
4 字符串类型
字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。
CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。
BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。
有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。
ENUM是枚举类型
SET是集合类型不同于ENUM类型，它是一个排列组合。假如有abc，它可以选择a或b或c，也有选择是ab,ac,bc，也可以选择abc。
总结
这些数据类型可以用于数据表或存储过程或以后的函数中，也就是说只要用到数据类型的时候，可以从我们刚讲到的数值型、浮点型、日期/时间和字符串(字符)类型中任意选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ab6de514acfe6acaffa8c1b959943f/" rel="bookmark">
			YOLOV5-打标签建立自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌞欢迎来到机器学习的世界 🌈博客主页：卿云阁
💌欢迎关注🎉点赞👍收藏⭐️留言📝
🌟本文由卿云阁原创！
🌠本阶段属于练气阶段，希望各位仙友顺利完成突破
📆首发时间：🌹2021年7月16日🌹
✉️希望可以和大家一起完成进阶之路！
🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！
labelImg下载
labelImag在github上面有，可自行下载
下载链接: labelImg-master.
1.修改标签
在data/predefined_classes里面修改里面的class，比如我的标签为red和green就按这个格式改。
2.然后直接点击labelImg.py文件打开
运行环境一般有python的idle都可以直接打开，如果是pycharm就要在pycharm打开代码，然后手动run，这个时候小伙伴可能会遇到这个问题。 conda install pyqt=5 conda install -c anaconda lxml pyrcc5 -o libs/resources.py resources.qrc python labelImg.py python labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE] 主页信息告诉我们，当我们把源码下载下来之后，先要在Anaconda Prompt中进入到解压之后的文件目录下，在依次执行上面的指令。其中前三个指令缺一不可哦（除非环境中早已安装有前两个），其中第三条指令最重要! 3.打开后将格式改成yolo
4.选择图片位置和我们标注的txt文件保存的位置
一般用labelImg我们都要在文件中创建images文件夹和labels文件夹，将需要标注的图片放在images文件夹中，labels文件夹暂时不用放东西，到时候会自动生成标注的txt文件然后Open Dir选择images，Change Save Dir选择labels。
下图为我的数据集保存的位置 5.然后就可以开始标注我们的数据集了
按“w”键可以开始标注
按“a”键是上一张
按“d”键是下一张
6.自动保存
如果我们需要快速标注数据集，可以在view/atuo save mode选择自动保存，这样按下一张就不会跳出是否保存的选择框了。 7.更加快捷操作
如果标注的时候很多张都是red，就可以在右上角将"use default label"勾选上，在后面填上red。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45412a78c39fc3911439ea3026b388f/" rel="bookmark">
			Flink1.14学习测试:将数据写入到Hive&amp;Hdfs(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink1.14学习测试:将数据写入到Hive&amp;Hdfs(二) 参考 Kafka SQL 连接器 : https://nightlies.apache.org/flink/flink-docs-master/zh/docs/connectors/table/kafka/标量函数(udf) : https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/table/functions/udfs/#%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0Formats : https://nightlies.apache.org/flink/flink-docs-master/zh/docs/connectors/table/formats/overview/ 接收Kafka数据并写入到Hive （实现思路一） 说明 消息结构(JSON格式) {"name":"Fznjui","age":16,"gender":"女"} Kafka表定义 Kafka Table配置jsonformat。Schema结构保持与消息内容结构一致，当消息接收到时即可直接转换。
自定义UDF函数 此处是因为中文分区目录HIve不识别，所以做个转换函数。
测试完整代码 import cn.hutool.core.io.resource.ResourceUtil import org.apache.flink.api.java.utils.ParameterTool import org.apache.flink.streaming.api.CheckpointingMode import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment import org.apache.flink.table.api.Expressions.{$, currentTimestamp, dateFormat} import org.apache.flink.table.api.bridge.scala.StreamTableEnvironment import org.apache.flink.table.api.{ApiExpression, DataTypes, FieldExpression, Schema, SqlDialect, TableDescriptor, call} import org.apache.flink.table.catalog.hive.HiveCatalog import org.apache.flink.table.functions.ScalarFunction import java.util.concurrent.TimeUnit object KafkaToHiveTest1 { private val sourceTopic = "ly_test" private val kafkaServers = "192.168.11.160:9092,192.168.11.161:9092,192.168.11.162:9092" def main(args: Array[String]): Unit = { //参数配置(flink参数获取工具类) val parameterTool = ParameterTool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f45412a78c39fc3911439ea3026b388f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c879f88bb849fff47b493225968526b2/" rel="bookmark">
			超前进位加法器(Verilog&amp;数字IC)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在说到超前加法器之前，先要了解普通全加器。
首先画出全加器真值表
则此时可以写出Verilog代码：
module advance_adder( input [3:0] a, input [3:0] b, input c_in, output [3:0] sum_out, output c_out ); wire [4:0] g,p,c; assign g=a&amp;b; assign p=a|b; assign c0=c_in; assign c1=g[0]|(p[0]&amp;c[0]); assign c2=g[1]|(p[1]&amp;(g[0]|(p[0]&amp;c[0]))); assign c3=g[2]|(p[2]&amp;(g[1]|(p[1]&amp;(g[0]|(p[0]&amp;c[0]))))); assign c4=g[3]|(p[3]&amp;(g[2]|(p[2]&amp;(g[1]|(p[1]&amp;(g[0]|(p[0]&amp;c[0]))))))); assign sum_out = p^g^c[3:0]; assign c_out = c[4]; endmodule 普通加法器需要等进位完成才计算下一位，这样在计算大大增加了运算的时间，而超前进位加法器可以直接计算出所有全加器的进位输入信号，无需像普通加法器一样从最低位开始像最高位逐位传递信号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f61f565a1bacbcfd382dd92463b6f29/" rel="bookmark">
			python中列表常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表可以通过下标来改变元素的值列表中的元素也可以是列表列表中的元素种类可以不同 1.append（object）在列表尾部追加元素
#追加元素 a = ["city","kill",11,98] a.append("python") print(a) #追加元组 b = ["city","kill",11,98] t = ("java","python") b.append(t) print(b) #追加列表 c = ["city","kill",11,98] c.append(["java","python"]) print(c) ['city', 'kill', 11, 98, 'python']
['city', 'kill', 11, 98, ('java', 'python')]
['city', 'kill', 11, 98, ['java', 'python']]
2.insert（index，object）向指定位置添加元素
#插入元素 a = ["city","kill",11,98] a.insert(1,'python') print(a) #插入元组 b = ["city","kill",11,98] t = ("java","python") b.insert(1,t) print(b) #插入列表 c = ["city","kill",11,98] c.insert(3,["java","python"]) print(c) #插入字符串 d = ["city","kill",11,98] d.insert(0,"python") ['city', 'python', 'kill', 11, 98]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f61f565a1bacbcfd382dd92463b6f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac96a12b9298793b2ce5ccad4b25166/" rel="bookmark">
			大数据培训 Hive 相关知识的全面总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、了解Hive
1、Hive的概念及架构
Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL ），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL ，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 的开发者开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。
「Hive是SQL解析引擎」，它将SQL语句转译成Map/Reduce Job然后在Hadoop执行。「Hive的表其实就是HDFS的目录」，按表名把文件夹分开。如果是分区表，则分区值是子文件夹，可以直接在Map/Reduce Job里使用这些数据。
「Hive相当于hadoop的客户端工具」，部署时不一定放在集群管理节点中，也可以放在某个节点上。
❝
「数据仓库」，英文名称为「Data Warehouse」，可简写为DW或DWH。数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它出于分析性报告和决策支持目的而创建。为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。
❞
❝
Hive的版本介绍：0.13和.14版本，稳定版本，但是不支持更新删除操作。1.2.1和1.2.2 版本，稳定版本，为Hive2版本（是主流版本）1.2.1的程序只能连接hive1.2.1 的hiveserver2
❞
2、Hive与传统数据库比较
查询语言。类 SQL 的查询语言 HQL。熟悉 SQL 开发的开发者可以很方便的使用 Hive 进行开发。数据存储位置。所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。数据格式。Hive 中没有定义专门的数据格式。而在数据库中，所有数据都会按照一定的组织存储，因此，数据库加载数据的过程会比较耗时。数据更新。Hive 对数据的改写和添加比较弱化，0.14版本之后支持，需要启动配置项。而数据库中的数据通常是需要经常进行修改的。索引。Hive 在加载数据的过程中不会对数据进行任何处理。因此访问延迟较高。数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了 Hive 不适合在线数据查询。执行计算。Hive 中执行是通过 MapReduce 来实现的而数据库通常有自己的执行引擎。数据规模。由于 Hive 建立在集群上并可以利用 MapReduce 进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。 3、Hive的数据存储格式
Hive的数据存储基于Hadoop HDFS。Hive没有专门的数据文件格式，常见的有以下几种：TEXTFILE、SEQUENCEFILE、AVRO、RCFILE、ORCFILE、PARQUET。 「下面我们详细的看一下Hive的常见数据格式：」
「TextFile:」 「TEXTFILE 即正常的文本格式，是Hive默认文件存储格式」，因为大多数情况下源数据文件都是以text文件格式保存（便于查看验数和防止乱码）。此种格式的表文件在HDFS上是明文，可用hadoop fs -cat命令查看，从HDFS上get下来后也可以直接读取。 「TEXTFILE 存储文件默认每一行就是一条记录，可以指定任意的分隔符进行字段间的分割。但这个格式无压缩，需要的存储空间很大」。虽然可以结合Gzip、Bzip2、Snappy等使用，使用这种方式，Hive不会对数据进行切分，从而无法对数据进行并行操作。「一般只有与其他系统由数据交互的接口表采用TEXTFILE 格式，其他事实表和维度表都不建议使用。」
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac96a12b9298793b2ce5ccad4b25166/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/138/">«</a>
	<span class="pagination__item pagination__item--current">139/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/140/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>