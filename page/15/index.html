<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c86fc415634641d560d033c1915c6b13/" rel="bookmark">
			【教程】自动检测和安装Python脚本依赖的第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：小锋学长生活大爆炸[xfxuezhang.cn]
背景说明 对于新python环境，要运行某个脚本，可能需要安装很多库，一般可以通过提供的requirements.txt来自动安装。但如果没有这个txt，那就得手动一个一个安装，非常的麻烦。
通过捕捉ImportError错误，实际上可以从错误消息中提取缺失的模块名称，而一旦确定了缺失的模块名称，就可以使用 pip 自动安装它们了。
参考脚本 autoDependencyInstaller.py
import argparse import subprocess import sys import re def install_module(module_name, python_executable): try: subprocess.check_call([python_executable, "-m", "pip", "install", module_name]) return True except subprocess.CalledProcessError: return False def extract_imports(file_name): with open(file_name, 'r') as file: file_content = file.read() imports = re.findall(r'^(?:from\s+(\S+)|import\s+(\S+))(?:\s+|$)', file_content, re.MULTILINE) top_level_modules = {imp[0].split('.')[0] if imp[0] else imp[1].split('.')[0] for imp in imports} return list(top_level_modules) def check_module(module, python_executable): try: subprocess.check_call([python_executable, "-c", f"import {module}"]) return True except subprocess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c86fc415634641d560d033c1915c6b13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0192380c44080379a5ea5fb66c97e5c/" rel="bookmark">
			Flink实时电商数仓之DWS层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析 关键词
统计关键词出现的频率 IK分词 进行分词需要引入IK分词器，使用它时需要引入相关的依赖。它能够将搜索的关键字按照日常的使用习惯进行拆分。比如将苹果iphone 手机，拆分为苹果，iphone, 手机。
&lt;dependency&gt; &lt;groupId&gt;org.apache.doris&lt;/groupId&gt; &lt;artifactId&gt;flink-doris-connector-1.17&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.janeluo&lt;/groupId&gt; &lt;artifactId&gt;ikanalyzer&lt;/artifactId&gt; &lt;/dependency&gt; 测试代码如下：
public class IkUtil { public static void main(String[] args) throws IOException { String s = "Apple 苹果15 5G手机"; StringReader stringReader = new StringReader(s); IKSegmenter ikSegmenter = new IKSegmenter(stringReader, true);//第二个参数表示是否再对拆分后的单词再进行拆分，true时表示不在继续拆分 Lexeme next = ikSegmenter.next(); while (next!= null) { System.out.println(next.getLexemeText()); next = ikSegmenter.next(); } } } 整体流程 创建自定义分词工具类IKUtil，IK是一个分词工具依赖创建自定义函数类注册函数消费kafka DWD页面主题数据并设置水位线从主流中过滤搜索行为 page[‘item’] is not nullitem_type : “keyword”last_page_id: “search” 使用分词函数对keyword进行拆分对keyword进行分组开窗聚合写出到doris 创建doris sinkflink需要打开检查点才能将数据写出到doris 具体实现 import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0192380c44080379a5ea5fb66c97e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cc67112b1d667964e2b70ab5c1ac4e/" rel="bookmark">
			Centos7：Jenkins&#43;gitlab&#43;node项目启动(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7：Jenkins+gitlab+node项目启动(1)
Centos7：Jenkins+gitlab+node项目启动(1)-CSDN博客
Centos7：Jenkins+gitlab+node项目启动(2)
Centos7：Jenkins+gitlab+node项目启动(2)-CSDN博客
Centos7：Jenkins+gitlab+node项目启动(3)
Centos7：Jenkins+gitlab+node项目启动(3)-CSDN博客
安装gitlab 编辑文件(新建) vim /etc/yum.repos.d/gitlab-ce.repo
[gitlab-ce] name=Gitlab CE Repository baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/ gpgcheck=0 enabled=1 安装 yum install gitlab-ce
缓存 yum makecache
常用指令 gitlab-ctl start # 启动所有 gitlab 组件； gitlab-ctl stop # 停止所有 gitlab 组件； gitlab-ctl restart # 重启所有 gitlab 组件； gitlab-ctl status # 查看服务状态； gitlab-ctl reconfigure # 启动服务； vim /etc/gitlab/gitlab.rb # 修改默认的配置文件； gitlab-rake gitlab:check SANITIZE=true --trace # 检查gitlab； sudo gitlab-ctl tail # 查看日志； 修改配置 vim /etc/gitlab/gitlab.rb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88cc67112b1d667964e2b70ab5c1ac4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d6b98ac08fcb17c6e126da886c48a9/" rel="bookmark">
			Centos7：Jenkins&#43;gitlab&#43;node项目启动(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7：Jenkins+gitlab+node项目启动(1)
Centos7：Jenkins+gitlab+node项目启动(1)-CSDN博客
Centos7：Jenkins+gitlab+node项目启动(2)
Centos7：Jenkins+gitlab+node项目启动(2)-CSDN博客
Centos7：Jenkins+gitlab+node项目启动(3)
Centos7：Jenkins+gitlab+node项目启动(3)-CSDN博客
node项目启动 项目上传(window下的git) git add.
git commit -m "首次提交"
git push
登录gitLab网页查看 登录Jenkins 新建Item http://192.168.2.77:8080/
输入一个任务名字
构建一个自由风格的软件项目
配置参数 丢弃旧的构建 注1：随意配置一下吧 不然太多的话肯定也不好
源码管理（选择git ） 注1：分支要正确
构建触发器 注1：来吧 勾选一个最长的 别问为什么
构建环境 注1：每次构建的时候 把之前的目录删掉
构建环境 选择shell脚本构建
构建 pwd;
chmod 775 xl_start_project.sh;
./xl_start_project.sh
注1：第一行就是显示一下路径吧 方便你去查看代码 有没拉取下来
注2：xl_start_project.sh 是我项目的启动脚本 先改下权限吧
注3：启动项目
立即构建 查看构建情况 可以看到 之前的3条指令 都执行了
查看代码 注1：之前的pwd 用上了吧
shell 脚本 #!/bin/bash npm install cd src pm2 start app.json 注1：install一下 然后启动项目啊 ==&gt; 利用了pm2 的守护
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7d6b98ac08fcb17c6e126da886c48a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8220329b5f7c1de77141b68a19a3872/" rel="bookmark">
			Maven导入org.apache.commons.lang3.StringUtils
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Maven导入org.apache.commons.lang3.StringUtils Maven导入org.apache.commons.lang3.StringUtils Maven导入org.apache.commons.lang3.StringUtils pom.xml中加入以下内容
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1234567 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6befff3f2f65233b1682bb0253586c3/" rel="bookmark">
			【数据结构和算法】找出两数组的不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其他系列文章导航 Java基础合集
数据结构与算法合集
设计模式合集
多线程合集
分布式合集
ES合集
文章目录 其他系列文章导航
文章目录
前言
一、题目描述
二、题解
2.1 哈希类算法题注意事项
2.2 方法一：哈希法
三、代码
3.1 方法一：哈希法
四、复杂度分析
4.1 方法一：哈希法
前言 这是力扣的 2215 题，难度为简单，解题方案有很多种，本文讲解我认为最奇妙的一种。
一、题目描述 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：
answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。 注意：列表中的整数可以按 任意 顺序返回。
示例 1：
输入：nums1 = [1,2,3], nums2 = [2,4,6] 输出：[[1,3],[4,6]] 解释： 对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。 对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6befff3f2f65233b1682bb0253586c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce9d350b6496f6f52ce911e925ccf1d/" rel="bookmark">
			uniapp多级动态表单规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个新的业务、主要涉及多层级的动态表单提交，其中又涉及很多类型，踩了很多坑之后，终于研发完毕。
传来的数据格式处理 传来的数据格式涉及比较多的内容，以下举例一个，涉及到规则的填写
规则写法有两种，一种是直接在表单里添加规则，一种是在字段中添加规则
表单里规则添加，以下是第一级的写法 我这里字段的定义是因为有其他数据要一并提交，可按照自己需求来
1、字段里label-width我设定的是300，是因为会有比较长的字段。根据返回文本，自行调节
2、：name字段主要是为了寻找key值，这个必填，
dynamicLists为数组,index为数组下标位置，value
&lt;uni-forms ref="dynamicForm" :modelValue="dynamicFormData" label-position="top" label-width="300px"&gt; &lt;view v-for="(item, index) in dynamicFormData.dynamicLists" :key="item.inspectionItemId"&gt; &lt;uni-forms-item :label="index+1+'.'+ide+1+'、'+ite.itemName" label-width="100%" :rules="[{required: true,errorMessage: '请填写'}]" :name="['dynamicLists',index,'value']" required&gt; &lt;uni-data-checkbox v-model="dynamicFormData.dynamicLists[index].value" :localdata="ite.itemValueList" /&gt;	&lt;/uni-forms-item&gt; &lt;/view&gt; &lt;/uni-forms&gt; &lt;script&gt; export default { data(){ return{ dynamicFormData:{ dynamicLists:[], } } } } &lt;/script&gt; 第二种规则里填写 首先要对数据处理
在数据里添加rules规则
rules: [{ 'required': true, errorMessage: "请填写" + this.detail[i].itemName//这里写你想校验的内容 }], this.detail是我从后台返回的数据，其中内容做了处理。按照自己的值编辑
this.dynamicFormData.dynamicLists.push({ label: this.detail[i].itemName, value: "", itemType: this.detail[i].itemType, rules: [{ 'required': true, errorMessage: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce9d350b6496f6f52ce911e925ccf1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e6a34ed158eedbadd65b889ad13251/" rel="bookmark">
			用Html和js和layui写一个简单猜拳小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单学习技术，写了一个小游戏，用html和js写一个简单的小游戏。玩家点击按钮出拳，玩家胜利结果显示绿色，玩家输了结果显示红色，平局结果显示蓝色。
页面效果： 代码： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;石头、剪刀、布 小游戏&lt;/title&gt; &lt;link rel="stylesheet" href="../layui/css/layui.css" media="all"&gt; &lt;style&gt; /* 添加样式以中心布局两个游戏并增加一些间距 */ .game-container { text-align: center; margin: 5% auto; } .game-container &gt; button { margin: 0 5px; /* 添加按钮间距 */ } #result, #message { margin: 20px 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="game-container"&gt; &lt;h1&gt;石头、剪刀、布 小游戏&lt;/h1&gt; &lt;div id="choices"&gt; &lt;button onclick="play('石头')" class="layui-btn layui-btn-primary layui-border-blue"&gt;石头&lt;/button&gt; &lt;button onclick="play('布')" class="layui-btn layui-btn-primary layui-border-orange"&gt;布&lt;/button&gt; &lt;button onclick="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e6a34ed158eedbadd65b889ad13251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d476a9ad93a96bd8f5735d6b76670a/" rel="bookmark">
			We are a team - 华为OD统一考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OD统一考试
题解： Java / Python / C++
题目描述 总共有 n 个人在机房，每个人有一个标号 (1&lt;=标号&lt;=n) ，他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的:
消息构成为 a b c，整数 a、b 分别代表两个人的标号，整数 c 代表指令。c== 0 代表a和b在一个团队内。c == 1 代表需要判定 a 和b 的关系，如果 a和b是一个团队，输出一行"we are a team",如果不是，输出一行"we are not a team"。c 为其他值，或当前行a或b 超出 1~n 的范围，输出 “da pian zi”。 输入描述 第一行包含两个整数 n，m(1&lt;=n.m&lt;=100000).分别表示有n个人和 m 条消息。随后的 m 行，每行一条消息，消息格式为: a b c (1&lt;=a,b&lt;=n, 0&lt;=c&lt;=1) 输出描述 c ==1.根据 a 和 b 是否在一个团队中输出一行字符串,在一个团队中输出 “we are a team”, 不在一个团队中输出 “we are not a team”。c 为其他值，或当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串 “da pian zi”。如果第一行 n 和 m的值超出约定的范围时，输出字符串"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93d476a9ad93a96bd8f5735d6b76670a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1276e28cc7b57e4ab086982fab635acc/" rel="bookmark">
			【数据结构和算法】寻找数组的中心下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其他系列文章导航 Java基础合集
数据结构与算法合集
设计模式合集
多线程合集
分布式合集
ES合集
文章目录 其他系列文章导航
文章目录
前言
一、题目描述
二、题解
2.1 前缀和的解题模板
2.1.1 最长递增子序列长度
2.1.2 寻找数组中第 k 大的元素
2.1.3 最长公共子序列长度
2.1.4 寻找数组中第 k 小的元素
2.2 方法一：前缀和
三、代码
3.2 方法一：前缀和
四、复杂度分析
4.2 方法一：前缀和
前言 这是力扣的 724 题，难度为简单，解题方案有很多种，本文讲解我认为最奇妙的一种。
这是一道非常经典的前缀和问题，虽然看似简单，但它却能让你深入理解前缀和的特点。
一、题目描述 给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
示例 1：
输入：nums = [1, 7, 3, 6, 5, 6] 输出：3 解释： 中心下标是 3 。 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ， 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1276e28cc7b57e4ab086982fab635acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30dfdcf77592e794eb8a60e31444c812/" rel="bookmark">
			数字孪生在能源电力行业的技术难点和应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字孪生的关键技术
数字孪生技术架构包括物理空间、数字空间和信息处理三个部分，基于物联网和虚拟仿真的底层技术，实现了真实空间和虚拟空间之间的双向数据交换、指挥控制和虚拟现实联动，以满足这些需求，必须依靠五项关键技术。
一是智能传感技术，高精度、高灵敏度的传感监测系统是实现数字孪生的基础，是万物互联的入口，虚拟电网到物理电网的全息复制和动态调整依赖于实时传感技术；
二是异构通信技术数字孪生系统面临多系统、大连接、海量数据的双向传输需求，需要利用5g等新型异构网络技术实现高速、大容量、低延迟接入，从而保证物理电网中海量传感器的接入要求和虚拟电网中精确控制指令的传输要求；
三是数字模型技术电网数字模型的描述反映了物理电网的要素构成、运行动态和决策影响，是从实到虚的数字孪生的结果，是从虚到实的基石；
四是数据中心技术数字孪生模型的构建和自优化依赖于整个区域内的全量电网数据只有通过数据中心才能实现大规模、全量多源数据的安全存储和高效读取，为数字双平台的优化决策提供了良好的数据元素；
五是围绕电网数字模型和加载在模型上的多元数据集，运用人工智能技术和机器学习、深度学习等机器智能算法识别物理电网的自组织隐序和隐模式，推理学习复杂的操作规律和未知关系，实现辅助决策能力。
电力行业应用场景
一是电网状态可视化监测应用，基于数字孪生技术，对电网主要设备、厂房、车站及环境进行精细三维全景模拟，实现与采集数据的实时交互，通过部署在工厂和车站的视频网络和传感器网络，可以动态融合和显示仿真场景中的设备和关键传感数据，实时反馈和分析环境变化；
二是电网设备远程智能巡检应用，利用物联网的智能传感技术对多个关键测点进行监控，不仅可以提高巡检效率，还可以节省人工成本；
三是远程故障诊断与辅助决策的应用目前，电网各环节的监测数据尚未统一集中发送到国家电网总部，省级公司无法全面收集其管辖范围内的设备信息，因此，为了实现远程故障诊断，可以通过全面的数据调用和专家组的集中决策，大大提高故障诊断和后续处理的及时性和准确性；
第四，电网智能预警和状态检修的应用在过去的实际生产中，大多数管理者根据现有经验判断设备异常和故障，这种主观认识不能通过对设备运行数据的实时监测，准确反映设备状态的变化，提出对设备运行状态的智能评估、预警和预防措施，以防止危及系统和设备的严重故障，这也有利于科学合理地制定维修计划；
第五，应用电网设备仿真培训，通过三维动画演示进行电力系统维护指导和培训，不断提高维护人员的技术水平；
六是安全运行控制的应用，通过与三维空间位置信息相结合，实现人员、设备、车辆的安全运行控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e1d4271f4d0b8aacf0628ffad3209c/" rel="bookmark">
			卷积神经网络 反向传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		误差的计算 softmax 经过softmax处理后所有输出节点概率和为1
损失（激活函数） 多分类问题：输出只可能归于某一个类别，不可能同时归于多个类别。
误差的反向传播 求w的误差梯度
权值的更新 首先是更新输出层和隐藏层之间的权重。更新权重，我们首先需要知道损失梯度，损失梯度实际上是损失根据所需要的更新的权重求偏导，而要求解这个偏导，我们要通过链式法则来求解。成功求解损失梯度后，要通过梯度下降的方法来更新我们的权重。这里的损失梯度前面的系数，我们称之为学习率，直观意义去理解实际上就是步长。
这个参数是我们人为调整的，但是学习率不宜过大，也不易过小。过大可能会导致损失无法收敛，过小可能会导致损失收敛的速度过慢，或者会陷入局部最优解的问题中。因此学习率我们不能随意取值，需要通过后续不断地迭代，来获取最优学习率。
接着我们需要进一步更新我们的隐藏层和输入层之间的权重，对于这里的损失梯度，我们同样是通过链式法则得到损失梯度的表达式，过程基本与前面保持一致。但是这里有两个注意点，第一，这里通过链式法则最后得到的损失梯度的结果会用到我们前面更新过的权重，所以说反向传播的顺序是不可逆的。第二，对与隐藏层和输入层之间权重的更新是多个损失项更新的叠加。通过上述的推到过程，我们可以求得我们所需的损失梯度，得到损失梯度后，通过梯度下降，我们可以得到隐藏层和输入层之间更新后的权重。
至此，我们已经完成了通过误差的反向传播实现了一次完整的权重的更新。后面的过程就是在正向传播更新输出，然后再反向更新权重，循环迭代，直到损失收敛或者是达到设定的迭代次数，一次神经网络的训练完成。
优化器 使网络更快地得到收敛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56de437303e4566b3144f115dd1b8e96/" rel="bookmark">
			PAW3395传感器记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、查看数据手册二、SPI通信1.解析2.上代码 三、运动判断四、输出数组五、步骤总结 前言 paw3395
一、查看数据手册 首先，可以看到power on 需要做的步骤是7步
按照步骤区写寄存器即可。
可以让chatgpt帮忙写这些重复性的行为。
例如：
Write register Ox10 with value Ox20
Write register Ox20 with value Ox30
Write register Ox30 with value Ox40
帮忙 建立以下表格：
static PAW3395_REG_VALUE_T gst_additional_data[] = {
{0x10,0x20},
{0x20,0x30},
{0x30,0x40}
};
二、SPI通信 通过SPI接口读取鼠标的寄存器值
1.解析 函数接受三个参数：寄存器地址、数据缓冲区指针和要读取的数据长度。
在函数内部，首先将SPI的片选信号设置为低电平，以使得鼠标芯片能够与主控芯片进行通信。然后，使用spi_hw_s_write_byte函数向鼠标的寄存器地址发送数据，并使用spi_hw_s_read_byte函数读取寄存器的值，将其存储到数据缓冲区中。最后，延时5微秒，将SPI片选信号设置为高电平，完成一次寄存器读取操作。
2.上代码 spi_hw_read(0x6C,(k_uint8 *)&amp;reg_value,1); //向寄存器地址0x6c读,读到存储在变量reg_value里面 void spi_hw_read(k_uint8 uc_reg_addr,k_uint8 *puc_data, k_uint8 uc_data_len) { //k_uint8 uc_read_register = uc_reg_addr; gpio_write(SPI_CS_PIN,0);	spi_hw_s_write_byte(uc_reg_addr); for (k_uint8 cnt = 0; cnt &lt; uc_data_len; cnt++) { *puc_data++ = spi_hw_s_read_byte(); } time_delay_us(5); gpio_write(SPI_CS_PIN,1);	} 三、运动判断 #define K_BIT_MASK(i) (1ul &lt;&lt; (i)) #define PMW3325_MOTION_MASK (K_BIT_MASK(7)) if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56de437303e4566b3144f115dd1b8e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135acbb33559d3829e158678d6cd5954/" rel="bookmark">
			跳跃表原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、跳表数据结构 跳表是有序表的一种，其底层是通过链表实现的。链表的特点是插入删除效率高，但是查找节点效率很低，最坏的时间复杂度是O(N)，那么跳表就是解决这一痛点而生的。
为了提高查询效率，我们可以给链表加上索引，利用二分查找的思路，每两个节点抽取一个索引，根据数据规模，提升索引的高度，索引的最高层级为logN,那么跳跃表支持平均0 (1ogN)，这样可以快读提高节点访问速度。由于在原始链表的基础上加索引，这些索引需要额外的存储空间，所以这是典型的通过空间换时间。下图简单描述跳跃表原理：
如果要访问8这个歌节点元素，在没有索引的情况下，需要遍历链表8次才能找到目标节点，但是通过跳表访问(1 -&gt; 5 -&gt; 7-&gt; 7-&gt;7 -&gt; 8) ,只需要访问6次，数据规模越大优势越明显。
对于提取索引，理论上每隔两个元素生成一个索引节点，但是在具体情况下，链表是动态的，删除和增加节点的时机很难确定，通过两个节点维护索引的方式开销成本很大。那么如何添加索引，一个新增节点要不要加索引，索引加到第几层，为了解决这个问题，可以通过投掷硬币的方式（随机数模2），连续投掷正面几次，那么这个次数就是索引的层级。
二、跳表代码实现 1、跳表结构、操作函数声明 #ifndef SKIPLINKLIST_H__ #define SKIPLINKLIST_H__ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #include &lt;time.h&gt; #include &lt;math.h&gt; #include &lt;unistd.h&gt; #define MAX_LEVEL 8 //定义数据域 typedef int SkipLinkListData; typedef struct skiplinklistnode { int level; SkipLinkListData data; struct skiplinklistnode* next; struct skiplinklistnode* down; } SkipLinkListNode; /** * 创建链表节点 */ SkipLinkListNode* create_skiplinklist_node(SkipLinkListData data,int level); /** * 插入节点 */ void insert_skiplinklist_node(SkipLinkListNode* head,SkipLinkListData data); /** * 维护索引 */ void create_skiplinklist_index(SkipLinkListNode** index,SkipLinkListNode* node); /** * 随机数投硬币获取索引层高 */ int random_skiplinklistnode_level(); /** * 遍历跳表 */ void show_skiplinglistnode_all(SkipLinkListNode* head); /** * 查询节点 */ SkipLinkListNode* search_skiplinklistnode(SkipLinkListNode* head,SkipLinkListData data); /** * 删除跳表元素 重组索引 s * 删除的过程其实也是查找 */ void delete_skiplinklistnode(SkipLinkListNode* head,SkipLinkListData data); #endif 2、跳表增删查操作定义 #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/135acbb33559d3829e158678d6cd5954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875b10291255604fcab30872d7c72b23/" rel="bookmark">
			【概念】大模型与ChatGPT/SaaS、PaaS和IaaS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大模型与ChatGPT区别 大模型与ChatGPT是人工智能领域中的两个重要概念，它们之间有一些联系，也有一些区别。 大模型是指大规模的深度学习模型，通常包含数十亿甚至更多参数，需要大量的计算资源和 训练数据来进行训练。大模型的优点是可以处理复杂的任务，例如图像识别、语音识别、 自然语言处理等，但同时也需要更高的计算资源和更长的训练时间。 ChatGPT是一种基于自然语言处理的机器学习模型，主要用于实现自然语言对话系统。它通过 对大量文本数据进行分析和学习，能够理解人类语言的语法、语义和上下文信息，并生成符合 人类表达习惯的回答。ChatGPT在对话系统领域的应用非常广泛，例如智能客服、智能助手等。 虽然大模型和ChatGPT都是深度学习领域的重要概念，但它们的应用领域和侧重点有所不同。 大模型主要用于图像、语音等领域的复杂任务处理，而ChatGPT主要用于自然语言对话系统的 实现。此外，大模型的参数数量更大，需要更高的计算资源和训练时间，而ChatGPT则更注重 对人类语言的处理和理解。 总之，大模型和ChatGPT是人工智能领域中的两个重要概念，它们在应用领域和侧重点上有所不同。 虽然它们的技术原理有一定的联系，但它们的发展方向和应用场景各有特点。 SaaS、PaaS和IaaS SaaS、PaaS和IaaS是云计算服务中的三个重要概念，可以理解为这栋楼的三部分。 SaaS（Software-as-a-Service）即软件即服务，是一种将软件部署在云端，通过网络提供 给用户使用的服务模式。用户通过Web浏览器可以实现相同的功能并拥有访问数据的能力，而 软件的维护和管理则由服务商负责。SaaS在多个领域都有应用，例如企业资源规划（ERP）、 客户关系管理（CRM）、人力资源管理等。 PaaS（Platform-as-a-Service）即平台即服务，是一种将软件的开发、部署和管理作为一种 服务提供给用户的服务模式。用户可以通过云服务提供商提供的开发工具和环境来开发、部署和 管理应用程序，而不需要自行购买和维护开发环境所需的基础架构。PaaS的优点在于用户可以快 速地开发和部署应用程序，并且能够快速地迭代和改进应用程序。 IaaS（Infrastructure-as-a-Service）即基础设施即服务，是一种将计算基础架构作为一种 服务提供给用户的服务模式。用户可以通过云服务提供商提供的虚拟机、存储、网络等资源来部 署自己的应用程序，而不需要自行购买和维护这些基础设施。IaaS的优点在于用户可以灵活地扩 展自己的应用程序，并且可以根据自己的需求来选择和配置基础设施资源。 总的来说，SaaS、PaaS和IaaS各有特点和优势，适用于不同的应用场景和需求。用户可以根据 自己的需求选择合适的服务模式来满足自己的业务需求。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3587c4a8369d851d516fd508b0b055f2/" rel="bookmark">
			TCP中的三次握手和四次挥手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP中的连接和断开可以说是在面试中经常被问到的问题之一，正好有空就总结一下，首先回顾一下TCP的相关知识点
1. TCP的基础知识 1.1 TCP的基本概念 我们知道TCP是运输层的面向连接的可靠的传输协议。面向连接的，指的就是在两个进程发送数据之前，必须先相互“握手”，确保两进程可以进行连接。并且这个传输是点对点的，即一个TCP连接中只有一个发送方和接收方；可靠的，指的是在任何网络情况下，在TCP传输中数据都将完整的发送到接收方。
1.2 TCP的报文段结构 源端口和目的端口：和UDP一样用于多路复用/分解来自或送到上一层
序号：一个报文段的序号是整个传送的字节流序列，而不是该报文段的序列
确认号：主机正在等待的数据的下一个字节序号
数据偏移：指TCP首部的长度，可变。默认长度为20字节
窗口：用于流量控制，用于指示接收方愿意接受的字节数量
标志字段：
ACK：当该位为1时，确认号有效RST：该位为1时，表示TCP连接中出现异常必须强制断开连接SYC：该位为1时，开始建立连接，并且序号字段进行序列号初始值的设定FIN：该位为1时，断开连接，通信双方相互交换FIN位置为1的TCP段后断开连接 2. TCP连接 2.1 什么是连接(connection)和会话(Session) 连接是数据传输双方的契约，在设计上，连接是一种传输数据的行为，具体来说，数据收发双方的内存中都建立一个用于维护数据传输状态的对象，比如TCP 的连接组成包括一台主机上的缓存、变量和与进程连接的套接字，以及另外一台主机上的缓存、变量和与进程连接的套接字。（由端口号和IP地址组成）所以连接是网络行为状态的记录
而会话是应用的行为，比如说你在微信上给人发消息，打开应用聊天窗口和对方聊天是一个会话，但是连接只有在进行发消息、语音的时候连接才开启。其他不发消息和语音时，连接可能暂时断开，但是只要不关聊天窗口，会话时一直存在的。
总结而言，会话是应用层的概念，连接是传输层的概念，正是因为如此，在 TCP 连接的时候需要握手建立连接。
3. TCP连接建立 3.1 TCP 协议中的基本操作 也就是报文段的标志字段的含义和功能：
SYN(Synchronization)：请求同步，一个 Host 主动向另外一个 Host 发起连接。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接PSH(Push): 数据推送，一个 Host 主动向另外一个 Host 发送数据FIN(Finish): 请求完成，一个 Host 主动断开请求,如果 FIN=1，表示数据已经发送完成，可以释放连接。ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。 如图，开始时，两个端口都是出于closed状态，当服务器端口变成listen时，监听端口，是否有数据传来。
第一步：客户端向服务端发送一个特殊的TCP报文段。客户端进入SYN_SENT状态这个报文段有以下特点：
不包含应用层数据，封装在一个IP数据报中发送给服务器SYN为1（此步是ACK唯一可为0处，其他时间均为1）序号段有一个随机生成的初始序号（client_isn） 第二步：服务器端收到上步客户端的报文段后，同时为该TCP连接分配TCP缓存和变量，并向该客户发送允许连接的报文段。服务器进入SYN_RCVD状态，这个报文段特点有：
不包含应用层数据SYN为1，ACK为1确认号段被置为client_isn + 1，序号段被置为server_isn 第三步：客户端收到上步服务端的报文段后，客户端为该连接分配缓存和变量，同时客户端向服务器端发送报文段，这个报文端特点有：
可以包含应用层数据SYN为0，ACK为1确认号段被置为server_isn + 1 两端进入ESTABLISHED状态，连接建立
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3587c4a8369d851d516fd508b0b055f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d259ad452ad25c67ce2106a9062e52/" rel="bookmark">
			MS2358：96KHz、24bit 音频 ADC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 产品简述 MS2358 是带有采样速率 8kHz-96kHz 的立体声音频模数 转换器，适合于面向消费者的专业音频系统。 MS2358 通过使用增强型双位 Δ - ∑ 技术来实现其高精度 的特点。 MS2358 支持单端的模拟输入，所以不需要外部器 件，非常适合用于像 DTV,DVR 和 AV 接收器的系统。 主要特点  线性相位抗混叠数字滤波器  单端输入  带失调电压消除的数字高通滤波器  信噪失真比： 85dB  动态范围： 95dB  信噪比 : 95dB  采样速率： 8kHZ 到 96kHz  主时钟： 256fs/384fs/512fs (8kHz ~ 48kHz) 256fs/384fs (48kHz ~ 96kHz)  主机 / 从机模式  音频接口： I2S  电源： 4.5~5.5V 模拟， 2.7~5.5V 数字  温度范围 -20-85 ℃  DFN12 封装 应用  DVD 录音机  数字 TV  CD 录音机 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0e07d9d3c1c7300932f2013149569b/" rel="bookmark">
			OSError: We couldn‘t connect to ‘https://huggingface.co‘ to load this file, couldn‘t find it in the
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSError: We couldn't connect to 'https://huggingface.co' to load this file, couldn't find it in the 问题描述解决方案一个警告 问题描述 OSError: We couldn't connect to 'https://huggingface.co' to load this file, couldn't find it in the cached files and it looks like distilbert-base-uncased-finetuned-sst-2-english is not the path to a directory containing a file named config.json. Checkout your internet connection or see how to run the library in offline mode at 'https://huggingface.co/docs/transformers/installation#offline-mode'. 这个其实就是模型再国外，服务器无法访问到国外的模型，需要将模型下载到本地
解决方案 将下面的模型文件下载后，放在一个文件夹中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0e07d9d3c1c7300932f2013149569b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba1ad42f49758fe5da8fdd6c4a22893/" rel="bookmark">
			Qt&#43;Opencv：Qt中部署opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、获取opencv 本文先只介绍opencv-release版本的获取方式，如果有版本指定编译工具链需求的朋友，可以通过下载opencv的源码，使用cmake进行编译。
获取地址：https://opencv.org/releases/
注意：opencv-3.x.x的release版本是支持vc14-15的，opencv-4.x.x需要vc16以上版本支持
本系列仅作为研究学习，我们选择下载：opencv-3.4.16 windows版本，支持 vc14_vc15。
下载后文件解压目录如下：
我们直接打开bulid 目录：
include 、x64 和bin 目录是我们一会在Qt项目中需要的。很显然哈，官方的release版本果然只有64位的dll,如果采用32位编译工具链的朋友，自己配置编译下吧，也很简单。后面有需要，我们可以再出一篇专门讲解opencv保姆级源码编译的教程。话说博主还是很喜欢编译各种源码，貌似过往的博文里包含的编译江湖已经不下几十篇了。毕竟授人以鱼不如授人以渔。
二、在Qt中集成opencv 2.1 新建一个Qt项目 在pro中添加opencv头文件路径和库文件路径
QT += core gui greaterThan(QT_MAJOR_VERSION, 4): QT += widgets CONFIG += c++11 # The following define makes your compiler emit warnings if you use # any Qt feature that has been marked deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba1ad42f49758fe5da8fdd6c4a22893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4c20653b5f98ae4d3d4e1791810a23/" rel="bookmark">
			展现无限创意的Photoshop 2023 Mac/win中文版：打造您的独特艺术之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论您是摄影师、设计师还是艺术家，Photoshop 2023（ps 2023）都是您不可或缺的创意工具。最新升级的Photoshop 2023带来了更多令人兴奋的功能和改进，让您能够以前所未有的方式展现无限创意。
首先，Photoshop 2023拥有强大的图像编辑工具。您可以通过调整色彩、对比度、曝光等参数，精确地控制照片的外观和氛围。此外，借助于先进的修饰工具，您可以轻松去除瑕疵、添加特效和调整细节，让您的照片更加出色和精致。
其次，Photoshop 2023提供了丰富的创意特效和滤镜。无论是为照片增加艺术效果还是创建独特的图形设计，您都可以通过一键式操作，快速地应用预设或自定义的特效，实现您的创意想法。
另外，Photoshop 2023还具有智能对象和图层样式功能，让您能够轻松地管理和编辑复杂的设计项目。您可以随意调整图层的位置、改变样式和应用变形效果，实现更加精准和灵活的设计。
最重要的是，Photoshop 2023还与其他创意软件（如Illustrator和InDesign）紧密集成，让您能够无缝地在不同软件之间进行创作和编辑。不论是制作海报、设计标志还是创建复杂的插图，您都能够享受到高效和便捷的工作流程。
总之，Photoshop 2023是一款功能强大、操作简便的创意工具。无论您是初学者还是经验丰富的专业人士，它都能够帮助您展现独特的艺术风格和创意想法。立即下载Photoshop 2023，开始您的创作之旅，让您的作品与众不同！
Mac安装：Photoshop 2023 (ps 2023) for Mac v24.7正式激活版
Win安装：Adobe Photoshop 2023(PS2023)v24.7直装版+便携版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c75deb96edab7d9437d5a6ca8ddae8b/" rel="bookmark">
			托管在亚马逊云科技的向量数据库MyScale如何借助AWS基础设施构建稳定高效的云数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyScale是一款完全托管于亚马逊云科技，支持SQL的高效向量数据库。MyScale的优势在于，它在提供与专用向量数据库相匹敌甚至优于的性能的同时，还支持完整的SQL语法。以下内容，将阐述MyScale是如何借助亚马逊云科技的基础设施，构建出一个稳定且高效的云数据库。
什么是向量数据库
或许你尚未察觉，然而向量嵌入（vector embedding）实际上无处不在。它们构成了众多机器学习和深度学习算法的根基，被广泛运用于从搜索引擎到智能助手等各式各样的应用。机器学习与深度学习通常会把文本、图像、音频、视频等非结构化数据转化为向量嵌入的形式进行储存，并借由向量相似性搜索技术进行语义相关性搜索。基于向量的相似性搜索现如今已被大量应用于各类人工智能驱动的应用场景，包括图像检索、视频分析、自然语言理解、推荐系统、定向广告、个性化搜索、智能客服以及欺诈检测等。在这样的背景下，对向量数据的管理显得尤为重要，我们需要能够快速地储存、索引和搜索这些向量化的数据。
现存的向量数据库大体上可以分为两大类别。一类是专为向量设计的专有向量数据库产品，例如Pinecone、Weaviate、Qdrant、Chroma、Milvus等。另一类则是在通用的SQL或NoSQL数据库产品上进行扩展，其中最为人熟知的SQL数据库之一Postgres通过插件pgvector支持了向量索引和搜索；而包括ClickHouse、Redis、Elasticsearch和Cassandra在内的许多开源数据库近期都增加了对向量索引的原生支持。
人们通常认为，专有的向量数据库专门为向量检索设计，能够提供较佳的搜索性能。而支持向量搜索的通用数据库产品则依赖于原有的通用数据库，能够提供更为完善的数据管理和结构化数据查询能力，向量检索性能则有所损失。MyScale基于开源的在线分析处理（OLAP）数据库ClickHouse开发，集成了自主研发的多尺度树图（英文：multi-scale tree graph，缩写MSTG）向量索引算法。它不仅继承了ClickHouse卓越的结构化数据分析和查询能力，同时也提供了数倍于专有向量数据库的性价比，从而将两者的优势集于一身，给企业提供了统一的结构化和非结构化数据管理方案。
整体架构
MyScale是一款完全依托于亚马逊云科技云平台的数据库服务，其架构深度结合了亚马逊云科技的多元化产品线，包含了AWS EC2云端虚拟服务器、AWS EKS集群管理、AWS S3对象存储、AWS NLB负载均衡等。有赖于亚马逊云科技提供的强大底层设施，可迅速地构建出MyScale的云端服务产品。
如下图所示，MyScale云服务的架构设计包括全局控制平面（global control plane）、区域控制平面（regional control plane）以及区域数据平面（regional data plane）三个层次，每个层次对应一个Kubernetes集群。全局控制平面中部署了云服务的业务系统，负责组织、用户的管理以及整体的使用量统计等。每个区域对应一个云服务供应商的一个可用区，如AWS US-EAST-1。每个区域独立部署一个控制平面和多个数据平面。控制平面提供该区域内的集群管理（创建、停止、销毁）API以及计费系统，数据平面则运行用户启动的MyScale数据库集群，它们运行在同一个数据平面中的多个可用区。
MyScale的所有服务都部署在亚马逊云科技的托管Kubernetes服务EKS上。EKS提供了高度可用、安全及可扩展的Kubernetes环境，这使得MyScale可以充分利用Kubernetes的强大功能，如服务发现、负载均衡、自动扩缩容、安全隔离等。借助AWS EKS上的Cluster Autoscaler，MyScale可以根据用户工作负载的需求，快速地启动、停止和扩展实例，对EKS的节点池进行扩缩容。
为了保证用户集群之间的隔离，MyScale利用了Kubernetes的命名空间（namespace）特性。在数据平面中，用户创建的每个MyScale数据库集群对应Kubernetes中的一个命名空间，这样就可以最小化集群之间的相互影响。每个集群对应的命名空间中包含数据库节点、负载均衡服务和元数据存储服务。
用户在使用MyScale云服务时，可以通过运行在全局控制平面上的Web UI来创建和管理MyScale集群。用户在Web UI创建MyScale集群后，云服务的后端会调用相应区域控制平面中的接口，将MyScale数据库集群的具体参数和配置转成一个Kubernetes中的CRD资源配置文件，保存在该区域的控制平面中。对应的区域数据平面中运行的Cluster Manager会监听到区域控制平面中数据库集群CRD资源的变化情况，并做出相应的操作，在数据平面中创建或修改实际的MyScale数据库集群。在MyScale数据库集群启动后，用户可以通过Web UI、Python/Java/NodeJS客户端、HTTP接口以及包括Langchain和LlamaIndex在内的LLM应用框架来访问MyScale数据库。
选择配备基于NVMe的本地SSD盘的EC2实例来部署MyScale数据库。和大部分选择纯内存HNSW向量索引算法的向量数据库不同，MyScale自研的MSTG算法允许将向量数据缓存在本地NVMe SSD盘中，因此MyScale在为用户提供高性能的向量搜索的同时，大大节约了内存的使用。在亚马逊云科技的公开测试中，MyScale超过了Pinecone、Weaviate、Qdrant、Zilliz等专有向量数据库，提供了最佳的性价比（QPS per dollar）。
在部署MyScale云服务时，可以使用Crossplane来实现对亚马逊云科技上的EC2和EKS服务的部署和管理。首先，通过Crossplane的AWS Provider配置了对应的亚马逊云科技账户信息，使得Crossplane能够访问和操作亚马逊云科技资源。然后，定义EC2和EKS的YAML配置文件，通过这些文件，可以定义需要的服务器和Kubernetes集群的参数，如实例类型、集群大小等。通过应用这些配置文件，Crossplane的AWS Provider会调用AWS API来创建和配置这些资源。
不仅如此，Crossplane还能够定期同步这些资源的状态，可以通过Kubernetes的接口来监控和管理这些资源。当需要修改或删除这些资源时，只需要修改对应的YAML文件并重新应用，Crossplane就会自动完成对应的操作。通过使用Crossplane，能够以一种声明式、统一和自动化的方式来管理云资源，大大提升工作效率和准确性。
在数据安全方面，MyScale采用了Teleport，一种先进的远程访问管理系统。Teleport能够为开发者和运维人员提供通过密文连接安全地访问Kubernetes集群的能力。这不仅提升了系统的安全性，也提升了操作的便捷性。更重要的是，Teleport具有全面的审计功能，能够详细记录所有会话和事件，这对于进行安全分析和满足合规性要求非常有帮助。这就意味着可以对任何操作有完全的可视化，从而更好地控制和保护MyScale云服务系统，为用户提供安全可靠的服务。
小结
这篇文章介绍了MyScale，一个在亚马逊云科技上托管的向量数据库。MyScale基于开源的在线分析处理（OLAP）数据库ClickHouse开发，集成了自主研发的多尺度树图（MSTG）向量索引算法，可以提供优秀的数据管理和结构化数据查询能力，同时也提供了性价比突出的向量搜索功能，以及结构化和非结构化联合分析、处理的功能，可以被广泛应用于图像检索、视频分析、自然语言理解等AI驱动的场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d5dc0f85cb13f02ffd3450eb957124/" rel="bookmark">
			彻底解决VM ubuntu在虚拟机找不到网卡无法上网的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💖 作者简介：大家好，我是Zeeland，开源建设者与全栈领域优质创作者。📝 CSDN主页：Zeeland🔥📣 我的博客：Zeeland📚 Github主页: Undertone0809 (Zeeland)🎉 支持我：点赞👍+收藏⭐️+留言📝💬介绍：The mixture of software dev+Iot+ml+anything🔥 Introduction 本文将介绍如何解决VM ubuntu在虚拟机找不到网卡无法上网的问题，并给出一些排查思路，旨在帮助读者快速定位问题。
最近 vm ubuntu 用的比较多，因为 ubuntu 里面要跑一个 k8s，需要比较大的内存，于是给 VM 分配了 30G 的内存，分配完内存后，发现 VM 里面的 ubuntu 无法上网了，于是就有了这篇文章。Ubuntu 网卡消失的问题我不是第一次遇到了，之前已经预见过好几次了，有的时候重启 ubuntu 就没网卡了，有时候分配完内存就没网卡了，触发机制十分奇怪，我至今也没搞懂。之前各种遇到这个问题之后每次的处理方案都不一样，有点头疼，正好很久没写文章了，趁此机会好好总结一下问题。
Problem 在此，重新描述一下问题：VM ubuntu 无法上网，这是问题的表征，问题的本质是 VM ubuntu 找不到对应的网卡，从而导致无法上网。
网络环境：
VM ubuntu 22.04 LTS宿主机： windows 11内存分配： 30G网络连接： NAT 在我实践中，该问题的发生有两种原因：
给 VM Ubuntu 分配的内存大小发生改变时，可能会触发该问题VM Ubuntu 重启时，可能会触发该问题 Solution 该问题的解决方式比较多样，因为每个人的发生问题不唯一，因此下面将从最简单的解法开始介绍，读者可以根据自己的情况，逐步尝试，直到解决问题为止。
方法一 遇事不决先重启，重启电脑重启 VM，接着再进行下一步的排查。
在这个问题下，可以再尝试重启一下 Ubuntu 的 network-manager 服务，命令如下：
sudo service network-manager stop sudo rm /var/lib/NetworkManager/NetworkManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d5dc0f85cb13f02ffd3450eb957124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263074691478477857cc9e71a63c8142/" rel="bookmark">
			shell之objdump命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell之objdump命令 参数介绍例子 参数介绍 objdump 是一个在 Linux 中常用的工具，用于显示二进制文件（如可执行文件、目标文件和共享库）的详细信息。它可以提供关于二进制文件中的各种段、符号、机器指令等的详细信息。
以下是 objdump 的一些主要选项和用途：
-h: 显示二进制文件的各节头部信息。
-p: 显示二进制文件的段属性。
-x: 显示二进制文件的完整头部信息，包括节头部、段属性、符号表等。
-d: 反汇编二进制文件中的所有代码段。
-D: 与 -d 类似，但显示反汇编的格式更详细。
-r: 显示二进制文件的重定位表。
-s: 显示二进制文件的数据段。
-T: 显示二进制文件的动态节。
-p: 显示二进制文件的属性。
-t: 显示二进制文件的符号表。
-R: 显示二进制文件的运行时链接信息。
-x: 显示二进制文件的完整头部信息，包括符号表、段属性等。
-i: 显示二进制文件的 inode 信息（仅适用于 ELF 格式）。
-j : 只显示指定节的反汇编内容。 –section-headers: 等同于 -h。 –program-headers: 等同于 -p。 –headers: 等同于 -h -p -x。 –relocations: 等同于 -r。 –symbols: 等同于 -t。 –dynamic: 等同于 -T。 –full-contents: 等同于 -d -D -p -r -s -t -T。 –line-numbers: 在反汇编中包含行号信息（通常用于调试）。 –disassemble-all: 反汇编所有代码段，而不仅仅是那些包含符号的段。 –disassemble-zeroes: 反汇编所有包含零的代码段（通常用于调试）。 –add-gnu-debuglink: 为给定的二进制文件添加一个 GNU 调试链接，允许使用 gdb 进行调试。 –source 或 -S: 在反汇编中显示源代码级别的信息（需要调试信息）。 例子 1）显示二进制文件的各节头部信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/263074691478477857cc9e71a63c8142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c70294e5d9d9ce33a9116451b2d1a0/" rel="bookmark">
			Kubernetes 学习总结（41）—— 云原生容器网络详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 随着网络技术的发展，网络的虚拟化程度越来越高，特别是云原生网络，叠加了物理网络、虚机网络和容器网络，数据包在网络 OSI 七层网络模型、TCP/IP 五层网络模型的不同网络层进行封包、转发和解包。网络数据包跨主机网络、容器网络、虚机网络和物理网络到达对端，期间必然带来网络性能损耗。
场景 （1）低延时交易场景 证券交易系统具有交易时间相对集中、交易指令和数据密集的特点，对交易系统处理速度具有极高的要求。近年来，全球各大交易所都在不断对交易系统升级改造，其中“低时延”成为各大交易所竞争的核心，交易系统延时竞争已经进入微秒量级。用户通过客户端委托交易下单经过交易所外的交易软件、主机网络和物理网络，进入交易所内软硬件网络撮合交易，然后将委托回报和成交回报通过反向网络数据链路发送给用户。
（2）视频和云游戏等流媒体场景 在多媒体领域，直播流媒体、在线视频和云游戏等场景都存在对网络性能、传输速度有极高的要求。单纯从软件或者操作系统虚拟化出来的网络设备，无法达到网络收发处理、转发和传输的性能要求，以及保证低丢包率和低时延。
（3）流量隔离场景 在银行、证券、保险等金融行业，因金融政策、监管政策的要求，需要实现对管理流量、存储流量和业务流量进行隔离，做到网络运维管理，数据存储、数据备份和数据交互同步与业务流量分离，保障数据交互同步与正常网络访问的相互隔离，提高网络并发能力和降低网络延迟。
以上应用场景，无法通过单纯的应用网络、主机网络和硬件网络来解决微妙级低延时要求。如何提升云原生时代整体网络性能，降低网络时延呢？我们可以从传统网络和容器网络路径分析哪些可以优化的点或片段，针对这些点或片段提供可行的容器网络加速方案。
术语 CNI：Container Network Interface，容器运行时和网络实现之间的容器网络 API 接口。
IPAM：专门用于管理容器的IP地址管理，包含对容器分配 IP 地址、网关、路由和 DNS 等管理。
SR-IOV：Single Root I/O Virtualization，单根虚拟化，允许在虚拟机之间高效共享 PCIe 设备。
PF：Physical Function，包含 SR-IOV 功能结构主要用于 SR-IOV 功能管理。PF 通过分配 VF 来配置和管理 SR-IOV 功能。
VF：Virtual Function，轻量级 PCIE 功能（I/O 处理）的 PCIE 设备，每个VF 都是通过 PF 来生成管理，VF 的具体数量限制受限于 PCIE 设备、自身配置和驱动程序的支持。
RDMA：Remote Direct Memory Access，远程直接内存访问，将网络协议栈下沉到网卡硬件，网卡硬件收发包并进行协议栈封装和解析，然后将数据存放到指定内存地址，而不需要 CPU 干预。
DPDK：Data Plane Development Kit，数据平面开发套件，工作在用户态用于快速数据包处理，使用轮询 Polling 来处理数据包。
VPP：Vector Packet Processing，矢量数据包处理，工作在用户态的高性能数据包处理协议栈。通常与 DPDK 结合使用，提供多种收发数据包、交换和路由能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c70294e5d9d9ce33a9116451b2d1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbbcd8e270b4140e58605282cc9dc9dd/" rel="bookmark">
			堆叠降噪自动编码机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习中，堆叠降噪自动编码器（Stacked Denoising Autoencoder，SDAE）是一种用于特征学习和降维的深度学习模型。自动编码器是一类无监督学习模型，用于学习输入数据的紧凑表示。降噪自动编码器（Denoising Autoencoder）是自动编码器的一种变体，通过在输入中引入噪声来提高模型的鲁棒性和泛化能力。
堆叠降噪自动编码器通常由多个降噪自动编码器层叠在一起构成，每一层都逐步学习数据的更高级别的抽象表示。这些层的输出可以被用作输入来训练下一层。整个模型形成了一个深度神经网络，可以用于学习数据的分层表示，有助于捕捉数据中的复杂结构和特征。
以下是一个简单的使用Keras库实现的堆叠降噪自动编码器的示例代码：
from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, Dropout def create_denoising_autoencoder(input_dim, hidden_dim): model = Sequential() # Encoder model.add(Dense(hidden_dim, input_dim=input_dim, activation='relu')) # Dropout layer for denoising model.add(Dropout(0.2)) # Decoder model.add(Dense(input_dim, activation='sigmoid')) model.compile(optimizer='adam', loss='mean_squared_error') return model def create_stacked_denoising_autoencoder(input_dim, hidden_dims): model = Sequential() # Stack of denoising autoencoders for hidden_dim in hidden_dims: autoencoder = create_denoising_autoencoder(input_dim, hidden_dim) model.add(autoencoder) model.compile(optimizer='adam', loss='mean_squared_error') return model # 示例数据维度 input_dim = 50 # 堆叠降噪自动编码器的隐藏层维度 hidden_dims = [30, 20, 10] # 创建堆叠降噪自动编码器模型 stacked_dae = create_stacked_denoising_autoencoder(input_dim, hidden_dims) # 打印模型结构 stacked_dae.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbbcd8e270b4140e58605282cc9dc9dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/840211a342c19a5e0a9a9b723a5eab6b/" rel="bookmark">
			Echarts tooltip文字没有左对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tooltip : { trigger: 'axis', textStyle:{ align:'left' // 文字左对齐 } } 解决办法：tooltip加入如下代码。
textStyle:{
align:'left'
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8019dbbe76335350e7551d08efb609d5/" rel="bookmark">
			今天学习的是mysql-算术运算符 比较符 逻辑运算符 位运算符 mysql函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算术运算符 + - * / %
比较运算符 ： = &lt; &gt; isnull 区间 between and 等其他where后的条件均可
逻辑运算符：&amp;&amp;（and） ||（or） ！
位运算符： 比如说是十进制转二进制 24 的二进制是多少 是11000怎么运算的呢
64 32 16 8 4 2 1
24还剩8 8-8为0
1 1 0 0 0
这样就算出了24的二进制
mysql函数：
数学函数：比如 随机数 abs（值） 绝对值 PI（） 求圆周率
ceil 向上取整
cloor 向下取整
round 四舍五入 可跟位数 结果
rand（x） 随机数 不写值就是随机 x代表参数 参数一致 生成随机值
字符串函数 char_length
拼接
concat(直接拼接)
concat_ws（分割符，拼接）
大小写转换
upper（大写）
lower （小写）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8019dbbe76335350e7551d08efb609d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74cd988707c846d77a97c32f31199475/" rel="bookmark">
			使用Vue3开发学生管理系统模板1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境搭建 通过解压之前《Vue3开发后台管理系统模板》的代码，我们能够得到用户增删改查的页面，我们基于用户增删改查的页面做进一步的优化。
创建学生增删改查页面 第一步：复制用户增删改查页面，重命名为StudentCRUD.vue
&lt;script setup&gt; import {FilterMatchMode} from 'primevue/api'; import {ref, onBeforeMount} from 'vue'; import {useToast} from 'primevue/usetoast'; import users from "@/assets/data/user.json" // 用户 const user = ref({ id: 0, name: "", age: 0, }) const toast = useToast(); const userDialog = ref(false); // 用户弹窗是否显示 const deleteUserDialog = ref(false); // 确认删除用户弹窗是否显示 const deleteUsersDialog = ref(false); // 批量删除用户弹窗是否显示 const selectedUsers = ref(null); const dt = ref(null); const filters = ref({}); const submitted = ref(false); onBeforeMount(() =&gt; { initFilters(); }); /** * 打开新增用户的弹窗 */ function openNew() { user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74cd988707c846d77a97c32f31199475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c489c552473ea659e900d963486757b9/" rel="bookmark">
			Ubuntu安装K8S(1.28版本，基于containrd）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：Ubuntu安装K8S(1.28版本，基于containrd）-CSDN博客
简介 本文介绍Ubuntu安装K8S的方法。
官网文档：这里
1.安装K8S 1.让apt支持SSL传输
sudo apt-get update sudo apt-get -y install apt-transport-https ca-certificates 2.下载 gpg 密钥
curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - 3.添加 k8s 镜像源
创建/etc/apt/sources.list.d/kubernetes.list文件，并添加阿里的K8S源。
sudo touch /etc/apt/sources.list.d/kubernetes.list sudo vi /etc/apt/sources.list.d/kubernetes.list 添加的内容如下：
deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main 4.安装k8s
sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl kubeadm用于初始化环境，kubectl用于操作kubelet。 5.启动k8s
启动k8s
sudo systemctl start kubelet 设置开机启动
sudo systemctl enable kubelet 6.命令自动补全
这几个命令没有自动补全，用起来不方便。启用自动补全的方法见：这里
2.配置K8S环境 执行命令时有时候会报下边错误，不用管它。报错原因：去k8s官网查看发布版列表，但是国内访问不了这个网站，连不上；此时会自动使用本地客户端的版本，本处是：1.28.2。
1.禁用防火墙和swap 这两步必须操作！不然k8s无法正常运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c489c552473ea659e900d963486757b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4521f289f69e5cc0980c9351772004/" rel="bookmark">
			Spring Boot整合GraphQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPC选型入门测试系列文章
GraphQL是一种用于API开发的查询语言和运行时环境。它由Facebook开发并于2015年开源。GraphQL的主要目标是提供一种更高效、灵活和易于使用的方式来获取和操作数据。与传统的RESTful API相比，GraphQL允许客户端精确地指定需要的数据，并减少了不必要的网络传输和数据处理。
采用GraphQL，甚至不需要有任何的接口文档，在定义了Schema之后，服务端实现Schema，客户端可以查看Schema，然后构建出自己需要的查询请求来获得自己需要的数据。
1、数据类型 1.1、标量类型 Int －32位整型数字；Float－双精度浮点型；String－UTF‐8 字符序列；Boolean－布尔型，true 或者 false；ID－标识类型，唯一标识符，注意此ID为字符，如果使用Mysql自增长id，也会自动转为对应的字符串； 1.2. 高级数据类型 Object － 对象，用于描述层级或者树形数据结构。Object类型有一个类型名，以及类型包含的字段。 type Product { id: ID! info: String! price: Float } 12345 在此示例中，声明了Product对象类型，定义了3 个字段：
id：非空 ID 类型。
info：非空字符串类型。
price：浮点型。
Interface－接口，用于描述多个类型的通用字；与 Object一样。 interface Product { id: ID! info: String! price: Float } 12345 Union－联合类型，用于描述某个字段能够支持的所有返回类型以及具体请求真正的返回类型；Enum－枚举，用于表示可枚举数据结构的类型； enum Status { Yes No } type Product { id: ID! info: String! price: Float stat: Status } 12345678910 Input－输入类型input本质上也是一个type类型，是作为Mutation接口的输入参数。换言之，想要定义一个修改接口(add,update,delete)的输入参数对象，就必须定义一个input输入类型。 input BookInput { isbn: ID!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a4521f289f69e5cc0980c9351772004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597268a05f9b0fb7b5cd5addad43c016/" rel="bookmark">
			Redis Plus 来了，性能炸裂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，Java干货及时送达👇 来源：suo.im/4Cx7u
线程模型
链接管理
锁机制
Active-Replica
今天给大家介绍的是KeyDB，KeyDB项目是从redis fork出来的分支。众所周知redis是一个单线程的kv内存存储系统，而KeyDB在100%兼容redis API的情况下将redis改造成多线程。
上次也跟大家说了，项目地址是 https://github.com/EQ-Alpha/KeyDB
线程模型 KeyDB将redis原来的主线程拆分成了主线程和worker线程。每个worker线程都是io线程，负责监听端口，accept请求，读取数据和解析协议。如图所示：
图片 KeyDB使用了SO_REUSEPORT特性，多个线程可以绑定监听同个端口。
每个worker线程做了cpu绑核，读取数据也使用了SO_INCOMING_CPU特性，指定cpu接收数据。
解析协议之后每个线程都会去操作内存中的数据，由一把全局锁来控制多线程访问内存数据。
主线程其实也是一个worker线程，包括了worker线程的工作内容，同时也包括只有主线程才可以完成的工作内容。在worker线程数组中下标为0的就是主线程。
主线程的主要工作在实现serverCron，包括：
处理统计
客户端链接管理
db数据的resize和reshard
处理aof
replication主备同步
cluster模式下的任务
链接管理 在redis中所有链接管理都是在一个线程中完成的。在KeyDB的设计中，每个worker线程负责一组链接，所有的链接插入到本线程的链接列表中维护。链接的产生、工作、销毁必须在同个线程中。每个链接新增一个字段
int iel; /* the event loop index we're registered with */ 用来表示链接属于哪个线程接管。
KeyDB维护了三个关键的数据结构做链接管理：
clients_pending_write：线程专属的链表，维护同步给客户链接发送数据的队列
clients_pending_asyncwrite：线程专属的链表，维护异步给客户链接发送数据的队列
clients_to_close：全局链表，维护需要异步关闭的客户链接
分成同步和异步两个队列，是因为redis有些联动api，比如pub/sub，pub之后需要给sub的客户端发送消息，pub执行的线程和sub的客户端所在线程不是同一个线程，为了处理这种情况，KeyDB将需要给非本线程的客户端发送数据维护在异步队列中。
同步发送的逻辑比较简单，都是在本线程中完成，以下图来说明如何同步给客户端发送数据：
图片 如上文所提到的，一个链接的创建、接收数据、发送数据、释放链接都必须在同个线程执行。异步发送涉及到两个线程之间的交互。KeyDB通过管道在两个线程中传递消息：
int fdCmdWrite; //写管道 int fdCmdRead; //读管道 本地线程需要异步发送数据时，先检查client是否属于本地线程，非本地线程获取到client专属的线程ID，之后给专属的线程管到发送AE_ASYNC_OP::CreateFileEvent的操作，要求添加写socket事件。专属线程在处理管道消息时将对应的请求添加到写事件中，如图所示：
图片 redis有些关闭客户端的请求并非完全是在链接所在的线程执行关闭，所以在这里维护了一个全局的异步关闭链表。
图片 锁机制 KeyDB实现了一套类似spinlock的锁机制，称之为fastlock。
fastlock的主要数据结构有：
int fdCmdWrite; //写管道 int fdCmdRead; //读管道 使用原子操作__atomic_load_2，__atomic_fetch_add，__atomic_compare_exchange来通过比较m_active=m_avail判断是否可以获取锁。
fastlock提供了两种获取锁的方式：
try_lock：一次获取失败，直接返回
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597268a05f9b0fb7b5cd5addad43c016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bedd22a3080b212ae9ca7e1bfb7e880/" rel="bookmark">
			如何在SpringBoot中优雅地重试调用第三方API？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，Java干货及时送达👇
1引言 在实际的应用中，我们经常需要调用第三方API来获取数据或执行某些操作。然而，由于网络不稳定、第三方服务异常等原因，API调用可能会失败。为了提高系统的稳定性和可靠性，我们通常会考虑实现重试机制。
本文将深入探讨如何在Spring Boot项目中优雅地重试调用第三方API，并结合代码示例，展示具体实现方式。
2重试机制的必要性 第三方API调用可能面临各种不可预测的问题，如网络超时、服务器故障等。为了应对这些问题，引入重试机制可以帮助我们：
提高系统的稳定性： 在面对临时性故障时，通过重试机制可以减轻对系统的影响，确保服务的可用性。
降低因故障而导致的用户体验差： 用户可能无法感知到一次短暂的故障，而重试机制可以在不干扰用户操作的情况下自动修复问题。
3Spring Retry简介 Spring Retry是Spring框架提供的一个模块，它通过提供注解或编程方式的方式，帮助我们实现方法级别的重试机制。在Spring Boot中，可以很方便地集成并使用Spring Retry。
4Spring Boot中使用Spring Retry实现重试 4.1 添加依赖 首先，我们需要在pom.xml中添加Spring Retry的依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt; &lt;/dependency&gt; 4.2 配置重试策略 在Spring Boot中，我们可以使用@Retryable注解来标记希望重试的方法，并配置相应的重试策略。
4.2.1 代码示例 import org.springframework.retry.annotation.Backoff; import org.springframework.retry.annotation.Retryable; @Service public class ThirdPartyService { @Retryable( value = { RestClientException.class }, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 2) ) public String callThirdPartyApi() { // 调用第三方API的逻辑 // ... } } 在上述示例中，@Retryable注解标记了callThirdPartyApi方法，指定了当发生RestClientException异常时进行重试。maxAttempts指定最大重试次数，backoff指定了重试间隔的初始延迟和延迟倍数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bedd22a3080b212ae9ca7e1bfb7e880/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717ee71f54d570a99e33faf09edc0d4a/" rel="bookmark">
			微服务全做错了！谷歌提出新方法，成本直接降9倍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023，微服务“水逆”之年。
长期以来，不管大厂还是小厂，微服务都被认为是云原生服务应用程序架构的事实标准，然而2023，不止那位37signals的DHH决心下云，放弃微服务，就连亚马逊和谷歌等这些云巨头，正在带头开始革了微服务的命。
“在编写分布式应用程序时，传统观点认为将应用程序拆分为可以独立推出的独立服务。这种方法的初衷是好的，但像这样基于微服务的体系结构往往会适得其反，带来的挑战抵消了体系结构试图实现的好处。”
今年6月，一群谷歌员工（由谷歌软件工程师Michael Whittaker领导）发表了一篇名为“Towards Modern Development of Cloud Applications”的论文，开篇就对当下的微服务架构开怼。
文章认为，从架构上讲，微服务本身设置就有问题，它是一个没有边界的结构：“从根本上说，这是因为微服务将逻辑边界（如何编写代码）与物理边界（如何部署代码）混为一谈。”
因此，谷歌的工程师们提出了一种堪称“微服务2.0”的方法。将应用程序构建为逻辑整体，但将其交给自动化运行时，后者可以根据应用程序所需的内容和可用的内容来决定在哪里运行工作负载。
基于新提出的结构，他们能够将系统的延迟降低15倍，成本降低9倍。
“从有组织的模块化代码开始，我们就可以将部署架构作为实现细节，”Google开发人员倡导者Kelsey Hightower在10月份对这项工作表示了下一步计划。
这群谷歌开发者们发现了将应用程序拆分为独立部署的服务方法缺点太明显，并给出了非常有创新性的3条原则：
（1）鼓励开发人员编写分为逻辑组件的单片应用程序（2）将物理分布和执行模块化单片的挑战推迟到运行时（3）原子部署应用程序。
这三个指导原则带来了许多好处，并会为未来的开发创新打开大门。
无独有偶，同样是在6月，亚马逊流媒体平台 Prime Video发布的一则案例研究似乎改变了风向：“我们放弃了无服务器、微服务架构，改用单体架构取而代之，此举为客户节省90%的运营成本，还简化了系统复杂度”。
单体应用对微服务的“反戈一击”，还是亚马逊团队提出来的，再次让这个话题迅速引爆技术圈。
整个案例看下来，微服务跟降本增效似乎也扯不到一起去。问题出在哪里？
Prime Video 团队需要一个监控视频流质量问题的工具，由于视频数量太大，就要求该工具有很强的可扩展性。
最初这项工作是由一组分布式组件完成的，这些组件由AWS Step Functions（一种无服务器编排服务，AWS Lambda无服务器服务）编排，分分钟就能搭出一个有模有样的监控系统。但谁能想到，Step Function 伸缩问题竟然成为最大的绊脚石。
具体来看，一是对于视频流的每一秒，需要很多并发的 AWS Step Function，所以很快就达到了账户限制；二是 AWS Step Function 是按照状态转换向用户收费的，太贵了实在用不起。
无奈之下，Prime Video开始考虑用单体的解决方案以降低成本和增加应用的扩展能力，在经历了反复试验后，团队最终决定重建Prime Video的整个基础设施。
亚马逊在博客文章总结道：“微服务和无服务器组件是可以大规模工作的工具，但是否在整体上使用它们必须根据具体情况而定……将服务迁移成单体让我们的基础设施成本降低了 90%以上，还提升了我们的伸缩能力。”
这就说明，至少在视频监控领域，单体架构比微服务、无服务器主导的方法产生了更高的性能、更能降本增效。
始终鼓吹下云和反对微服务化的DHH（ Ruby on Rails创始人，David Heinemeier Hansson）一针见血地指出：连亚马逊自个都觉得微服务或无服务器“扯淡”了。
最近几年，无数的中小团队在权衡利弊后选择放弃微服务。
Uber 就是其中一家，此前 Uber 通过构建微服务来完成很小的需求或功能，甚至出现很多由一个人构建维护的微服务。这些微服务的存在给Uber带来了更多的挑战，比如监控、测试、持续集成 / 持续交付（CI/CD）、服务级别协议（SLA）等。
踩了微服务的“坑”之后，Uber 团队对新服务进行了更加深思熟虑的规划：不再只是完成一件事，而是使其服务于一项业务功能，由 5-10 个工程师负责维护，还总结出了血泪教训：要在正确的时间选择正确的解决方案来构建产品。
办公管理软件公司 Managed by Q 的应用程序是一个部署在 ECS 上的 Django 单体。为了赶上现代化开发实践的步伐，他们转向微服务架构。但他们很快发现，每多一个新服务，就会增加一些基础设施，而且开发一个跨多个服务的功能需要做更多的工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/717ee71f54d570a99e33faf09edc0d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c969d0ea8151abc4340c55a5bc291fb6/" rel="bookmark">
			conn.setAutoCommit()实现事务的控制用法及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务操作数据： 1.为什么要引入事务 假如银行转账系统
从张三的账户转1000元到小罗的账户
这个操作需要分两步
1.张三账户减少1000元
2.小罗账户增加1000元
假如于到断电等等，而刚好张三减了1000，而此时小罗却不增加。。。。可以想象银行这下有事做了
所以使用事务操作数据来搞定
2.实现事务的原理 java使用事务非常简单，首先调用conn.setAutoCommit(boolean b)方法，传入一个false,这样将不会自动提交，而需要使用conn.commit()方法，手动提交事务，当然只有在确认两个步骤都没有出错的情况下，才能提交，这样才能保证整个操作的完整性，一旦出错，使用conn.rollback()方法，回滚事务，这样的话，整个事务都将不被提交。那么如何判断有没有出错呢，非常简单，执行数据库操作的方法，都会抛出java.sql.SQLException，所以需要使用try……catch语句块捕获异常，在catch块中，使用conn.rollback()回滚事务即可
在数据库调用的javabean中conn.setAutoCommit()的功能是每执行一条SQL语句，就作为一次事务提交。但一般在项目中很有可能需要执行多条SQL语句作为一个事务。若有一个执行不成功，就会rollback（）；
一般来讲，大家对数据库中的表单，主要是增、删、改、查 这四个操作，如果你的程序当中，遇到一次业务逻辑需要两次或两次以上的对相同数据表的增删改操作，那么，为了数据的一致性，（或者具体说，在你的一次业务逻辑的处理过程中，其他(线程或程序或业务处理)的对相同数据的相同两次查询所得结果相同。）我们会利用数据库的事务操作，将一次业务逻辑所包含的所有操作封装在一个事务里，一次将多个操作进行提交。
而conn的setAutoCommit方法，是指，在事务当中，是否执行一条语句就自动提交一次。
想在一个事务里进行多个操作。就必然将setAutoCommit的参数设置成false，在多个操作的最后调用conn.commit()方法，进行手动提交
3.参数:true和false 假设如下：
1 数据库一个表格有50条记录
2 你设置参数为false
则在你执行整个查询SQL期间，一直是没有事务的，那么如果你的查询用到了一些函数，这些函数包含了多个查询语句，那么有可能会出现不一致的情况。
也就是说，函数、存储过程等，他们都将运行在非事务的环境下。
而你设置为true,则没有任何问题了,读一致性将保证不会出现问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c64380448a77610a8d4912e40fa588/" rel="bookmark">
			Python Selenium实现自动化测试及Chrome驱动使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 本文将介绍如何使用Python Selenium库实现自动化测试，并详细记录了Chrome驱动的使用方法。
通过本文的指导，读者将能够快速上手使用Python Selenium进行自动化测试。并了解如何配置和
使用Chrome驱动来实现更高效的自动化测试。
一、Python Selenium简介 Python Selenium是一个用于Web应用程序测试的开源工具，它提供了一组API。
可以模拟用户在浏览器中的操作，如点击、输入、提交表单等。
通过Python Selenium，我们可以编写自动化脚本来执行各种测试任务，从而提高测试效率和准确性。
二、安装Python Selenium库 在开始之前，我们需要先安装Python Selenium库。
可以通过以下命令来安装：
pip install selenium 三、Chrome驱动的下载和配置 1. 下载Chrome驱动 首先，我们需要下载Chrome驱动，Chrome驱动的版本需要与本地Chrome浏览器的版本保持一致。
可以通过以下链接下载对应版本的Chrome驱动：
https://googlechromelabs.github.io/chrome-for-testing/#stable 2. 配置Chrome驱动路径 下载完成后，将Chrome驱动解压到一个合适的位置，并将其路径添加到系统环境变量中，以便Python能够找到它。
四、编写自动化测试脚本 下面是一个简单的示例，演示了如何使用Python Selenium来自动化测试一个网页的登录功能：
from selenium import webdriver from selenium.webdriver.common.keys import Keys # 创建Chrome驱动对象 driver = webdriver.Chrome() # 打开网页 driver.get("https://www.example.com") # 找到用户名和密码输入框，并输入相应的值 username_input = driver.find_element_by_name("username") username_input.send_keys("your_username") password_input = driver.find_element_by_name("password") password_input.send_keys("your_password") # 提交表单 password_input.send_keys(Keys.RETURN) # 验证登录是否成功 assert "Welcome" in driver.page_source # 关闭浏览器 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c64380448a77610a8d4912e40fa588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1148d8a2fc344faa9614708803929d9b/" rel="bookmark">
			catboost回归自动调参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import os
import time
import optuna
import pandas as pd
from catboost import CatBoostRegressor
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.model_selection import train_test_split
X_train = data.drop([‘label’, ‘b1’, ‘b2’], axis=1).values
y_train = data[‘label’].values
X_train, X_test, y_train, y_test = train_test_split(X_train, y_train, test_size=0.2, random_state=42)
def epoch_time(start_time, end_time):
elapsed_secs = end_time - start_time
elapsed_mins = elapsed_secs / 60
return elapsed_mins, elapsed_secs
def objective(trial):
# 自定义的参数空间
depth = trial.suggest_int(‘depth’, 1, 16)
border_count = trial.suggest_int(‘border_count’, 1, 222)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1148d8a2fc344faa9614708803929d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea93a23940017c90fbb5b28917806a6/" rel="bookmark">
			Anaconda 完全指南：从安装到高级功能，一篇搞定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 Anaconda 是一个非常强大的 Python 数据科学平台，它集成了众多常用的数据科学工具和库，为数据分析、机器学习和科学计算提供了便捷的开发环境。本文将详细介绍 Anaconda 的安装、环境管理、常用工具和高级功能，帮助你快速掌握 Anaconda 的使用技巧。
1. 什么是 Anaconda？ Anaconda 是一个开源的 Python 发行版，包含了 Python 解释器、众多常用的数据科学工具和库（如 NumPy、Pandas、Matplotlib、Scikit-learn 等），以及一个强大的包管理系统。它的目标是简化数据科学和机器学习的开发过程，提供一站式的解决方案。
2. 安装 Anaconda 要使用 Anaconda，首先需要下载并安装 Anaconda 发行版。你可以从 Anaconda 官网（https://www.anaconda.com/products/distribution）下载适合你操作系统的安装包，并按照官方指南进行安装。安装完成后，你就可以在命令行中使用 Anaconda 提供的工具和命令了。
3. 环境管理 Anaconda 提供了一个强大的环境管理工具 conda，可以帮助你创建、管理和切换不同的 Python 环境。通过 conda，你可以创建一个独立的环境，并在该环境中安装特定版本的 Python 和其他库，从而避免不同项目之间的依赖冲突。下面是一些常用的环境管理命令： - 创建一个新环境：conda create --name myenv
- 激活一个环境：conda activate myenv
- 安装特定版本的 Python：conda install python=3.7
- 安装其他库：conda install numpy pandas matplotlib
4. 常用工具和库 Anaconda 预装了许多常用的数据科学工具和库，包括 NumPy、Pandas、Matplotlib、Scikit-learn 等。这些库提供了丰富的功能，可以帮助你进行数据处理、可视化、机器学习等工作。在使用 Anaconda 时，你可以直接调用这些库，无需额外安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea93a23940017c90fbb5b28917806a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf653b71e62dc8ff233d3251e648456/" rel="bookmark">
			32单片机按键扫描 实现长短按
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		key.c
/** **************************************************************************************************** * @file key.c * @author Kyro Qu * @brief 按键驱动代码 * 实验平台: STM32G431RB开发板 **************************************************************************************************** */ #include "key.h" #include "lcd.h" #include "stdio.h" typedef struct { GPIO_TypeDef *Key_Port; uint16_t Key_Pin; }Key_GPIO_t; static Key_GPIO_t g_KeyList[] = { { KEY_B1_GPIO_Port, KEY_B1_Pin }, { KEY_B2_GPIO_Port, KEY_B2_Pin }, { KEY_B3_GPIO_Port, KEY_B3_Pin }, { KEY_B4_GPIO_Port, KEY_B4_Pin } /* add other KEY, ... */ }; #define KEY_NUM_MAX (sizeof(g_KeyList)/sizeof(g_KeyList[0])) typedef enum { KEY_RELEASE =0,	/* 释放松开 */ KEY_CONFIRM,	/* 消抖确认 */ KEY_SHORT_PRESS,	/* 短按 */ KEY_LONG_PRESS,	/* 长按 */ }KEY_STATE; #define CONFIRM_TIME 10	/* 消抖时间 ms */ #define LONG_PRESS_TIME 2000	/* 长按时间窗 ms */ typedef struct { KEY_STATE keyState;	/* 按键状态 */ uint32_t prvTime;	/* 按键时间 */	}Key_Info_t; static Key_Info_t g_Key_Info[KEY_NUM_MAX]; /** * @brief 扫描单个按键不同状态函数 * @param 按键端口号 * @retval 键值 */ static uint8_t keyScan(uint8_t keyIndex) { uint8_t keyPress; keyPress=HAL_GPIO_ReadPin(g_KeyList[keyIndex].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cf653b71e62dc8ff233d3251e648456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d4172b3bab02e428060382fa81deb5/" rel="bookmark">
			【教程】将Python转为C语言并编译生成二进制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：小锋学长生活大爆炸[xfxuezhang.cn]
本教程以DGL版本的GCN为例，其他也相似。
1、安装cython、gcc：
sudo apt install cython gcc -y 2、安装DGL、PyTorch：
pip3 install torch torchvision torchaudio pip install dgl -f https://data.dgl.ai/wheels/cu117/repo.html pip install dglgo -f https://data.dgl.ai/wheels-test/repo.html 3、编写gcn.py。注意添加# cython: language_level=3，不然默认用的是python2：
# cython: language_level=3 import torch import torch.nn as nn import torch.nn.functional as F import dgl from dgl.data import CoraGraphDataset from dgl.nn import GraphConv # 定义 GCN 模型 class GCN(nn.Module): def __init__(self, in_feats, h_feats, num_classes): super(GCN, self).__init__() self.conv1 = GraphConv(in_feats, h_feats) self.conv2 = GraphConv(h_feats, num_classes) def forward(self, g, in_feat): h = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d4172b3bab02e428060382fa81deb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d66ac2fd2a845cf8b309c9c78477f8/" rel="bookmark">
			origin案例_绘制Spectrum，TRIR和曲线拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
origin 2021 软件 链接：https://pan.baidu.com/s/1B-lCGtZM-nVx6sSOes8New?pwd=y1mz 提取码：y1mz --来自百度网盘超级会员V7的分享 x.1 数据格式解析 首先，我们的IR采集数据格式，横轴表示衰减时间，纵轴表示波数，文件格式以.dat结尾，使用记事本和origin打开后如下所示，
x.2 绘制spectrum 以origin操作为例，我们首先使用origin打开文件，接着把第二列删除（LabVIEW采集数据的时候导致第二列是错误数据，实验室历史遗留问题）。
我们选择第一行，右键，set as comment，
这样我们的x轴就是波数，而legend上会根据每一衰减时间（即xps/位移平台位置）绘制多条光谱图。最后我们ctrl+a全选数据，点击左下角的Line绘制多个位移平台位置的光谱图，如下所示，
x.3 绘制TRIR 我们一般会在做实验的时候就选取我们觉得合适的波数下的衰减动力学曲线，我们实现记录下这些波数。回到我们在x.3章节中绘制的表格，根据我们记录的波数，我们从表格中选取我们需要的波数，例如1651cm-1，1647cm-1（一般会选择7，8条），我们将这些波数对应行的数据复制到一个新表格b中的从第二行开始的位置，
接着我们把x.3章节表格中的comment复制到新表格b中的第一行，
全选新表格b，在工作表中找到转置，将数据全部转置，
同样的，将第一行设置为comment，
再将新表格b中的数据全选，绘制出来的图就是时间动力学衰减图（当然这并不是我们期望的动力学衰减），如下所示，
x.4 曲线拟合 我们重点需要关注的是做动力学衰减后曲线拟合的参数，这个值可以反应亚稳态物质的振动情况。所以我们往往需要选择合适的曲线来拟合参数，通过拟合的参数来查看变化。
我们回到x.3中绘制的曲线，我们选择一条很明显有衰减的曲线，波数是1650。
我们使用左侧工具栏的data selector来选取曲线中需要拟合的片段，
框选完毕后，我们找到分析中的非线性拟合（一般是一次指数拟合或者二次指数拟合），
选择合适的分类和函数，点击右侧图标的fit until converged进行拟合
完全拟合时不会有红字报错，我们点击ok退出，保证t2和t1的±浮动不会大于主数值，如下就是ok的，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a430ed19632b21944986c78c69be203/" rel="bookmark">
			(vue)怎么监听表单里边的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(vue)怎么监听表单里边的数据 data() { return { form：{ name:"", }, show:false, } } watch: { //表单监听 "form.name": { deep: true, handler(newVal, oldVal) { if (newVal) { this.form.name= "张三"; } }, }, //常规监听 show: { deep: true, // immediate: true, handler(newVal, oldVal) { if (newVal === true) { ... } }, }, }, 解决参考：https://blog.csdn.net/m0_66570642/article/details/132521632
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e7719d405abd28df1d03f8984d9b1b/" rel="bookmark">
			服务器可以放在家里吗？一定要放在机房托管吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都会想，服务器为什么要进行托管？可以自己维护吗？
其实，服务器跟电脑还是区别的，为什么要托管到机房呢？有以下几点原因：
1.服务器不能断电，一年365天一直工作，需要保证环境的稳定，比如恒温、恒湿、防尘、供电，自己维护相当麻烦，家里电力也不稳定。如果出现停电、跳闸会影响到服务器的稳定性，导致软硬件的损坏，影响网站。而小鸟云机房有专业的供电设备和继电设备，各项设备指标稳定。
2.服务器对网络的要求较高，而IP地址就是网络里的身份证，通过这个身份证来识别你的服务器，访问你服务器上的内容。但是，由于家庭大都是动态IP，不固定，要保证访问者的访问速度和响应速度比较难。而小鸟云专业的机房拥有大量的网络带宽，节点范围广，能让用户顺畅访问。
3.如果是自己进行管理的话，一旦出现没遇到的问题，需要查询资料，万一弄错了，数据有可能会丢失，硬件有可能会故障，而小鸟云机房有专业的技术工程师，处理效率高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e8ed5d3bf9c2cc4bca4a5b521798544/" rel="bookmark">
			单元化、异地多活，大厂如何实现？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尼恩说在前面 在40岁老架构师 尼恩的读者交流群(50+)中，尼恩一直在指导大家改造简历、指导面试。指导很多小伙伴拿到了一线互联网企业网易、美团、字节、如阿里、滴滴、极兔、有赞、希音、百度、美团的面试资格，拿到大厂offer。
前几天，指导了一个40岁老伙伴拿到年薪100W offer，这个小伙伴的优势在：异地多活，在中间件的高可用（HA）。
在其他的小伙伴的简历指导的过程中，尼恩也发现： 异地多活的概念、异地多活的架构、非常重要。而且，异地多活的架构，本身就非常重要，大厂的线上高可用P0级别的严重问题也是非常频繁：
3月份出了两个大的线上事故，B站刚崩，唯品会又崩了。9月份之后，大厂接二连三的P0级事故（高可用事故）语雀崩了、阿里云崩，阿里崩完、滴滴崩…
异地容灾/异地多活，是架构师/高级开发必须掌握的核心技术，理由有2：
异地容灾/异地多活已经成为大厂核心服务的标准配置。当然，要实现真正意义上的异地多活，就需要对服务进行单元化改造。另外，从面试视角来看，异地容灾、单元化、高可用也是面试的核心重点。 刚好前面几天，有小伙伴面试，遇到一些异地多活的很重要的面试题：
高可用异地多活，如何实现？
高可用异地容灾，你的方案是啥？
你们的高可用、单元化改造方式是啥？
在这里，尼恩给自己的技术自由圈（未来 超级 架构师） 社区的小伙伴， 积累一些 异地多活的架构方案和素材。 这些资料的主要的目标： 方便在架构指导的时候，作为参考资料。在尼恩的公号【技术自由圈】中，之前有过多篇大厂异地多活的方案文章：
《B站刚崩，唯品会又崩：亿级用户网站的架构硬伤与解决方案》
《100Wqps异地多活，得物是怎么架构的？》
《大家都崩，美团不崩：其高可用架构，巧夺天工！》
《美团面试：ES+Redis+MySQL高可用，如何试实现？》
在这里，尼恩借助高德技术中心架构师韦王同学的文章《高德服务单元化方案和架构实践》，给大家做一下系统化、体系化的微服务底层架构 梳理，使得大家可以充分展示一下大家雄厚的 “技术肌肉”，让面试官爱到 “不能自已、口水直流”。
也一并把这个题目以及参考答案，收入咱们的 《尼恩Java面试宝典PDF》V151版本，供后面的小伙伴参考，提升大家的 3高 架构、设计、开发水平。
特别提示：尼恩的3高架构宇宙，持续升级。
《尼恩 架构笔记》《尼恩高并发三部曲》《尼恩Java面试宝典》的PDF，请到文末公号【技术自由圈】取
文章目录 尼恩说在前面高德服务单元化方案和架构实践一、为什么要做单元化二、高德单元化的特点三、高德单元化实践服务单元化架构就近接入实现方案路由表设计路由计算单元切流核心指标 四、后续优化统一接入集成单元化能力分组机制的优化热更时的双表计算服务端数据驱动的单元化场景 说在最后尼恩技术圣经系列PDF 高德服务单元化方案和架构实践 作者：韦王，高德技术
本文主要分享了高德在服务单元化构建方面的实际操作经验在服务单元化构建过程中，会遇到许多共性问题，例如请求路由、单元封闭、数据同步等。
有些问题已经有成熟的解决方案可以参考和使用，但是不同公司的业务都有各自的特点，因此需要尽可能结合自身的业务特点来进行相应的设计和处理。
一、为什么要做单元化 单机房资源瓶颈 随着业务规模和服务用户群体的扩大，单机房或同城双机房已经无法满足服务持续扩容的需求。
服务异地容灾 异地容灾已经成为核心服务的标准配置。虽然有些服务已经在多地多机房进行部署，但数据仍然只在中心机房。要实现真正意义上的异地多活，就需要对服务进行单元化改造。
二、高德单元化的特点 在做高德的单元化项目时，我们首先要考虑的是结合高德的业务特点，看高德的单元化有什么不一样的诉求，这样就清楚哪些经验和方案是可以直接拿来用的，哪些又是需要我们去解决的。
高德的业务与传统在线交易业务存在差异，高德为用户提供以导航为代表的出行服务，这些服务在许多场景下对响应时间（RT）有极高的要求。
因此，在做单元化方案时，尽可能减少对整体服务RT的影响，就是我们需要重点考虑的一个性能问题，尽量做到数据离用户近一些。转换到单元化技术层面需要解决两个问题:
用户设备的单元接入应尽可能实现就近接入，用户真实地理位置接近哪个单元就接入哪个单元。
例如华北用户接入到张北，华南接入到深圳。
用户的单元划分应与就近接入的单元保持一致，以减少单元间的跨单元路由。
例如用户请求从深圳进来，用户的单元划分最好就在深圳单元，如果划到张北单元就会造成跨单元路由。
此外，高德的许多服务无需用户登录，因此我们的单元化方案不仅需要支持用户ID，还必须支持基于设备ID的单元化。
高德的单元化项目要求我们深入理解其业务特性，并在此基础上设计出既能满足响应时间要求又能适应无需登录服务需求的单元化方案。
这涉及到优化用户接入策略，确保单元划分与用户地理位置的一致性，以及支持无登录服务的单元化技术。
三、高德单元化实践 为了实施服务的单元化架构改造，需要一个至上而下的系统性设计，核心要解决三个核心问题：
请求路由单元封闭数据同步 注意：请点击图像以查看清晰的视图！
请求路由：根据高德业务的特点，我们提供了两种路由策略：取模路由和路由表路由，目前上线应用使用较多的是路由表路由策略。
单元封闭：得益于集团的基础设施建设，我们使用vipserver、hsf等服务治理能力保证服务同机房调用，从而实现单元封闭(hsf unit模式也是一种可行的方案，但个人认为同机房调用的架构和模式更简洁且易于维护)。
数据同步：数据部分使用的是集团DB产品提供的DRC数据同步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e8ed5d3bf9c2cc4bca4a5b521798544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba58d964f0031c618bff85398a1e4775/" rel="bookmark">
			面试官：“只会这一种懒加载实现思路？回去等通知吧”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 前端Q，关注公众号
回复加群，加入前端Q技术交流群
思路一：监听滚动事件 监听滚动事件指的是：通过监听页面的滚动事件，判断需要懒加载的元素是否进入可视区域。当元素进入可视区域时，动态加载对应的资源。这种方式需要手动编写监听滚动事件的逻辑，可能会导致性能问题，如滚动时的抖动和卡顿。
关键 API
getBoundingClientRect() 方法返回的对象包含以下属性：
top：元素上边缘相对于视窗的距离。
right：元素右边缘相对于视窗的距离。
bottom：元素下边缘相对于视窗的距离。
left：元素左边缘相对于视窗的距离。
width：元素的宽度（可选）。
height：元素的高度（可选）。
可以看下下面的图。
来看看代码示例
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Lazy Loading Example&lt;/title&gt; &lt;style&gt; img { width: 100%; height: 300px; display: block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="https://via.placeholder.com/300x300?text=Image+1" src="" alt="Image 1"&gt; &lt;img src="https://via.placeholder.com/300x300?text=Image+2" src="" alt="Image 2"&gt; &lt;img src="https://via.placeholder.com/300x300?text=Image+3" src="" alt="Image 3"&gt; &lt;script&gt; function isInViewport(element) { const rect = element.getBoundingClientRect(); const windowHeight = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba58d964f0031c618bff85398a1e4775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2f8a86a314ab4ebb88959adc718074/" rel="bookmark">
			华为OD机试真题及题解（JAVA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 本系列参考MISAYAONE给出的题库，写出自己的题解，尽可能写出简单高效的代码，并对原来存在的误写或bug进行校对，但未上机实践过，无法保证100%通过。在实现思路上会有更加详细的说明。如果读者有更好的思路或者发现了某个题解的bug，欢迎在评论区留言讨论，发现bug时最好能提供具体的测试用例，便于问题分析~
题库 部分题在leetcode能找到类似题，可直接在leetcode提交验证
华为OD考试B卷题库 本专栏会持续更新，有超链接的题目代表已更新题目
序号OD题目时间分值leetcode1宜居星球改造计划2023Q2200994. 腐烂的橘子2需要打开多少监视器2023Q2100暂无3最佳植树距离 2023Q21001552. 两球之间的磁力4阿里巴巴找黄金宝箱（I）2023Q2200724. 寻找数组的中心下标5选修课2023Q2100暂无6五子棋迷 2023Q2100424. 替换后的最长重复字符7代表团坐车2023Q2100494.目标和8座位调整2023Q2100暂无9食堂供餐2023Q2100暂无10寻找矿堆的最大价值2023Q2100暂无11最长公共后缀2023Q210014. 最长公共前缀12模拟消息队列2023Q2100暂无13比赛2023Q2100暂无14告警抑制2023Q2100暂无15报文重排序2023Q2100暂无16字符串摘要2023Q2100暂无17矩阵稀疏扫描2023Q2100暂无18AI面板识别2023Q2100暂无19报文回路2023Q2100暂无20阿里巴巴找黄金宝箱(II)2023Q2100暂无21阿里巴巴找黄金宝箱(III)2023Q2100暂无22阿里巴巴找黄金宝箱(IV)2023Q2200503. 下一个更大元素 II23文件目录大小2023Q2100暂无24组装最大可靠性设备2023Q2200暂无25找出两个整数数组中同时出现的整数2023Q2100暂无26通过软盘拷贝文件2023Q2200暂无27代码编辑器2023Q2200暂无28数据分类2023Q2100暂无29恢复数字序列2023Q2100暂无30阿里巴巴找黄金宝箱(V)2023Q2100暂无31比赛的冠亚季军2023Q2100暂无32数字游戏2023Q2100974. 和可被 K 整除的子数组33经典屏保2023Q2100暂无34字符串化繁为简2023Q2200暂无35数据最节约的备份方法2023Q2100暂无36跳格子22023Q2100暂无37跳房子22023Q220015. 三数之和38支持优先级的对列2023Q2100暂无39乘坐保密电梯2023Q2100暂无40计算最接近的数2023Q2100暂无41人气最高的店铺2023Q2100暂无42战场索敌2023Q2200暂无43二维伞的雨滴效应2023Q21001008. 前序遍历构造二叉搜索树44跳房子I2023Q21001. 两数之和45分割数组的最大差值2023Q2100暂无46生日礼物2023Q2100暂无47求最小步数2023Q2100暂无48拔河比赛2023Q2100暂无49评论转换输出2023Q2200暂无50树状结构查询2023Q2200暂无51不开心的小朋友2023Q2200暂无52数字序列比大小2023Q2200暂无53符合要求的元组个数/k数之和2023Q2100暂无54最小循环子数组2023Q2200459. 重复的子字符串55金字塔/微商2023Q2100暂无56矩阵元素的边界值2023Q2100暂无57MELON的难题2023Q2200暂无58矩阵中非1的元素个数2023Q2200暂无59计算误码率2023Q2200暂无60增强的strstr2023Q2100暂无61关联子串2023Q2100暂无62计算礼品发放的最小分组数目2023Q2100暂无63字符匹配 2023Q210010. 正则表达式匹配64最小传输时延I2023Q2200743. 网络延迟时间65 一种字符串压缩表示的解压2023Q2100暂无66冠亚军排名2023Q2100暂无67报数游戏2023Q2100暂无68找出经过特定点的路径长度2023Q2100暂无69按单词下标区间翻转文章内容2023Q2100暂无70数列描述2023Q2100暂无71字符串筛选排序2023Q2100暂无72相对开音节2023Q2100暂无73字符串变换最小字符串2023Q2100暂无74VLAN资源池2023Q2100暂无75拼接URL2023Q2100暂无76执行时长/GPU算力2023Q2100暂无77荒岛求生2023Q3200735. 小行星碰撞78查字典2023Q3100暂无79周末爬山2023Q3200暂无80最小数字2023Q3100暂无81最长的元音子串2023Q3100暂无82TLV解析II2023Q3100暂无83玩牌高手2023Q3200暂无84最长连续子序列2023Q3100暂无85路灯照明II2023Q3100暂无86最多团队2023Q3100暂无87最长的顺子2023Q3100暂无88数字最低位排序2023Q3100暂无89整数编码2023Q3100暂无90找车位2023Q3100暂无91选举拉票2023Q3200暂无92单词加密2023Q3100暂无93购物2023Q3200暂无94最佳的出牌方法2023Q3200暂无95字符串划分2023Q3100暂无96洞穴探险2023Q3100暂无97最大岛屿体积2023Q3100暂无98DNA序列2023Q3100暂无99服务启动2023Q3100暂无100最长公共前缀2023Q310014. 最长公共前缀101查找舆情热词2023Q3100暂无102排队游戏2023Q4200暂无103BOSS的收入2023Q4100暂无104猴子吃桃2023Q4100暂无105滑动窗口最大值2023Q4100暂无106全排列2023Q4100暂无107编码能力提升计划 2023Q4200LCP 12. 小张刷题计划108水果摊小买卖2023Q4100暂无109正整数excel编号的转换2023Q4100暂无110反转每对括号间的子串2023Q4100暂无111模拟工作队列2023Q4200暂无112删除字符串中出现次数最少的字符2023Q4100暂无 备注 B卷题目已完结，完整代码连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6802cadf7f868c7a1cb34d3921ed687/" rel="bookmark">
			python股票分析挖掘预测金融大数据获取方法和实现（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜了，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包，
我们已经初步的接触与学习其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
数据是万物之源，我们做股票分析，首要条件是获取最新的，最全面的金融数据，我们才能进行下一步开发。
我们获取数据主要有二大渠道，爬虫爬取金融网站数据和金融网站主动提供API接口方式获得，这一章简单介绍一下金融数据接口的使用方法：
金融数据接口 目前有不少支持Python接口的金融数据库，比如Tushare、AKshare、Baostock、wind等，都可以获得国内股票、基金、期货、利率等数据。总共加起来几十个差不多，各位开发者可以按照自己的情况选择（很多接口版本如果升级，很大可能接口代码有所改变，所以开发者随时要调整代码，才能获得数据）
（1)AKshare接口 AKShare 是基于 Python 的开源金融数据接口库，目的是实现对股票、期货、期权、基金、债券、外汇等金融产品和另类数据从数据采集，数据清洗到数据下载的工具，满足金融数据科学家、数据科学爱好者在数据获取方面的需求。
它的特点是利用 AKShare 获取的是基于可信任数据源发布的原始数据，开发人员可以利用原始数据进行再加工，从而得出科学的结论。
优点： 代码语法符合PEP8 规范, 数据接口的命名统一;最佳支持Python 3.7.5 及其以上版本;提供最佳的文档支持, 每个数据接口提供详细的说明和示例, 只需要复制粘贴就可以下载数据;持续维护由于目标网页变化而导致的部分数据接口运行异常问题;持续更新财经数据接口, 同时优化源代码; 缺点： 如果是免费版本，如果访问过多随时封闭接口，也存在接口版本升级，很多获取数据代码随着改变，增加开发人员工作量。
安装： pip install akshare 代码案例： import akshare as ak import pandas as pd pd.set_option('expand_frame_repr', False) # True就是可以换行显示。设置成False的时候不允许换行 pd.set_option('display.max_columns', None) # 显示所有列 # pd.set_option('display.max_rows', None) # 显示所有行 pd.set_option('colheader_justify', 'centre') # 显示居中 def a_hist(): # period # str # choice of {'daily', 'weekly', 'monthly'} # start_date # str # 开始查询的日期 # end_date # str # 结束查询的日期 # adjust # str # 默认返回不复权的数据; # qfq: 返回前复权后的数据; # hfq: 返回后复权后的数据 stock_zh_a_hist_df = ak.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6802cadf7f868c7a1cb34d3921ed687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4057ea294c8dd8c52a910cb54b3d109d/" rel="bookmark">
			docker的安装的详细教程，以及出现错的解决办法（阿里云）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker的安装与使用
1.安装dnf
sudo yum -y install dnf
Repository extras is listed more than once in the configuration
错误：无法为仓库 appstream 找到一个有效的 baseurl
出现这个错误这是由于阿里云的版本导致的
在阿里云开发者社区有答案！
网址为：https://developer.aliyun.com/mirror/centos
（1）出现错误的原因
CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。
该网站有相关的解释和更新源的方法
（2）切换到 /etc/yum.repos.d/
cd /etc/yum.repos.d/
ls -l
（3）创建一个bak目录
mkdir bak
（4）将 CentOS-Linux-相关的内容全部放入bak中
mv CentOS-Linux-* bak
表示已经安装成功，yum源可用正常使用了
这里便可以测试yum是否可用了
（5）安装dnf
sudo yum -y install dnf
证明yum已经可用使用了，dnf安装成功
2.安装docker存储驱动的依赖包
sudo dnf install -y device-mapper-persistent-data lvm2
3.添加稳定的docker软件源
sudo dnf config-manager --add-repo=https://mirrors.aliyun.com/docker-ce/linux/
centos/docker-ce.repo
4.检查docker软件源是否已经添加
sudo dnf list docker-ce
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4057ea294c8dd8c52a910cb54b3d109d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb48716bbe7a70fd9aee0c4b417ba13/" rel="bookmark">
			楼宇智慧能源消耗监测管理系统，楼宇中的能源“管家”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人口的增加，楼宇数据呈上涨趋势，但是楼宇智能建设在我国普及性远远不足，相比传统楼宇控制，智能楼宇控制系统对于楼宇内部的用电设备控制，能够更加的节约能源，降低成本。对于现代化楼宇而言，选用一套智能能源管理系统对能源计量监控和应用有着重要意义。
系统主要功能
1、可视化大屏展示
可对所有能耗总产量、总产值、总消费趋势等进行展示，还可按能源计划量及实际使用量差值进行排名。
2、区域构建
支持对绘制区域素包括2D、3D素材进行维护，满足不同角度、不同粒度的能耗计量需求，支持提供不同区域的权限配置。
3、在线监测
在线监测能源介质与能源设备运行状态，实时显示能源参数及能耗值，支持查看能耗仪表网络与分布图。
4、设备能耗诊断
楼宇能耗诊断包括能效对标与能效诊断两部分。 能效对标通过建立不同的能耗分析模型， 实现能源数据多角度和多层次的分析，并形成各项 KPI 指标，如空调用电、照明用电等，将各项指标与标杆指标进行对标，当发生异常情况，能够及时提醒运营人员。
楼宇智慧能源消耗监测管理系统 5、统计报表
支持以自定义形式构建能耗记录报表，提供按日、月、季、年统计周期的能耗使用报表。
6、用能分析
能耗数据通过系统在线查询，支持按照实际管理组织结构和管理需求，实现基于计量管理模型的能耗同、环比统计分析，实现厂区、车间、生产线、设备级别能耗趋势对比及能耗排名分析。
7、能耗大数据分析
系统内拥有多种数据分析模型，通过分析能够发现最大用能区域、功率因数最低区域以及设备在空负载时能耗的分析。
8、能耗费用
可自动核算能耗费用，并进行能耗费用的同比、环比显示。支持可按能源类型、日期等不同条件相关的查询能耗费用查询统计和报表。
楼宇智慧能源消耗监测管理系统 9、设备管理
支持对设备使用、维修、保养、报废、导出、查询等功能，可显示停机时间、待机时间、运行时间、能耗占比、时间占比等。
10、能耗预警
系统提供灵活、丰富的异常告警管理功能，对所有报警事件可记录和写盘保存。当发生报警时，可通过自动业务流程生成异常告警工作单，并自动派单。
11、碳排管理
支持碳排统计、碳排排名，支持设置碳排阈值，设置阈值预警提醒，为管控提供依据。
12、数据录入
当能耗数据无法采集时，可提供能耗数据录入功能。
楼宇智慧能源消耗监测管理系统 系统优势
1、实现能源的节约
智慧楼宇能源消耗监测管理系统，可以对各种能源使用情况进行在线管理，通过能耗数据分析，可及时发现能耗冗余情况，并采取措施，减少能耗的浪费情况。
2、实现能源优化
系统通过对能源数据的收集与分析，帮助楼宇企业实现能源的优化，从而达到节能的目的。
3、提高管理效率
系统能够实现能源使用情况的在线监测，使得拥有更加精细化的管理，避免出现能源浪费。
随着科技的不断发展，楼宇智慧能源消耗监测管理系统，能够为楼宇的管理与维护带来更大的利益与效益，从而降低能耗使用费用，推动能源向绿色发展。
本文由“长春市吉佳通达信息技术有限责任公司”编写，转发请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3e12cd35c9b9fe7f1285011cc7b5af/" rel="bookmark">
			阿里云30个公共云地域、89个可用区、5个金融云和政务云地域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云基础设施目前已面向全球四大洲，公共云地域开服运营30个公共云地域、89个可用区，此外还拥有5个金融云、政务云地域，并且致力于持续的新地域规划和建设，从而更好的满足用户多样化的业务和场景需求。伴随着基础设施的加速投入和深入布局，阿里云将为广大用户享受云计算的优质体验提供坚实基础。阿里云百科aliyunbaike.com分享：
阿里云公有云地域，在阿里云CLUB中心领券 aliyun.club 专用满减优惠券。
阿里云公有云地域中国地域：张家口、乌兰察布、北京、呼和浩特、青岛、南京、武汉、成都、杭州、上海、福州、广州、河源、深圳和中国香港，其中南京、福州和武汉为本地地域。国外地域有伦敦、法兰克福、雅加达、迪拜、孟买、曼谷、吉隆坡、新加坡、雅加达、马尼拉、硅谷、弗吉尼亚。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe408c3693fe890932d29f3416bbd066/" rel="bookmark">
			C# WPF上位机开发（以始为终，寻找真实的上位机需求）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
c# wpf、qt、mfc这些上位机的需求是真实存在的，在现实中有很多应用的地方，这一点大家都很清楚。而程序员本身呢，他们比较擅长的部分，其实是实现需求，而不是发现和寻找到潜在客户的需求。但在商业社会中，寻找到客户，发掘出客户的需求，这是很重要的一个部分。找到了目标客户，满足他们的业务需求，这样也才能针对性地开发出对应的产品，实现技术人员自己的价值。今天，我们主要讨论的就是怎么去找到真实的上位机需求。
1、熟人关系 熟人一般是我们能想到的第一个方法。这些熟人包括，不限于亲戚、同学、朋友、同事，甚至是辗转找到的陌生人，这都没有关系。熟人的好处是，往往可以借助于他们拿到第一手消息。但是缺点也是明显的，由于各个人身处的行业、职位、背景各不相同，他们对于公司业务需求的理解，有很大的差别，是不是真的客观、认真、全面需要每个人去自己分析。
2、电商网站 如果我们希望了解的行业，正好在电商网站上面有成熟的产品正在出售，那是最好不过了。这个时候，比较简单的方法，就是直接去找到头部的企业、销量最好的产品。如果价格处于承受的范围之内，直接购买他们的产品，安装对应的上位机。上手使用之后，因为都是同一个专业，对于这些上位机的功能、性能、稳定性、风格、便捷性等等，很容易就得出一个快速的结论。
3、公司网站 有些上位机软件公司，他们的产品都是一些非标的产品，尤其是软件部分，客户不同，实现的软件也不通。这个时候，就需要查询到对应公司的网站上面，看看他们服务过哪些公司，有哪些方案，做出过什么产品，界面是什么样的，如果公司有一定的规模，或多或少都可以挖掘出一定的信息。
4、招聘网站 招聘网站是很多人比较容易忽视的一个地方。如果一个企业或者公司有上位机这方面的需求，加上一定的人员流动，那么它必然会定期到各大招聘网站去寻找对应的人才。这个时候，我们可以通过查找对应的招聘需求也可以发掘出一些信息。比如根据薪资、招聘条件、行业技术、技术难度等等，可以猜测出这家公司做什么业务，难度如何，上位机在其中扮演什么样的角色等等。此外，我们还可以将它和其他家公司进行对比，分析出各家擅长的地方，找出上位机的侧重点，这都是寻找真实需求的好方法。
5、展会、展览 对于成熟的产品后者商品，上面四种方法都是比较实用的。但是对于各家公司推出来的新产品、新系统，一般要到展会上面才能看到。展会具有鲜明的行业特性，这个时候同学们可以根据自己擅长的专业，到特定的展会去看看、去了解下，也是不错的一个方法。这方面的展会很多，没必要每个都去，只参加和自己本专业相关的展会就可以了。
6、其他渠道、媒介 当然现在论坛、blog、短视频等新媒体不断涌现，大家这方面也需要定时留心和留意，发掘出新的方式、方法、渠道，进一步细分市场，精准地去找到潜在的客户。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/16/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>