<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0efce73f448281b66d4a588a6e40626/" rel="bookmark">
			Git服务器搭建简明教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1前言 本文详解在Ubantu 16下搭建Git服务器，力求让读者知其所以然，仅需安装Git和ssh，而无需其他软件。
2服务器搭建 在真实服务器或虚拟机里操作均可。另外，如果用VMware Workstation 16 Player的话，默认不用配置虚拟机网卡，本地机就能Ping通。教程使用普通用户操作，如果是root用户，就不用加sudo了，命令将更加简洁。
2.1安装Git和SSH 已安装过的最好也再来一遍，以更新到最新，除非自己很清楚。
sudo apt-get install git sudo apt-get install ssh service ssh start 2.2新建用户 方便管理仓库，这里新建一个叫git的用户，名字可以任意，但推荐取名为git。建议以后Git的相关的东西，都放到这个用户目录下。
注意，中途输入的密码是给新建的git用户设置的密码，其他直接回车使用默认信息即可。
sudo adduser git 注意，以上只是创建了叫git的用户，后续的操作并没有切换到该用户进行。
2.3创建登录证书 创建路径.ssh，然后创建authorized_keys文件，这里路径和文件名不能任取，该文件用于存放各个git客户端的RSA公钥，只有在这个列表里的客户端才能连接git服务。公钥在下一步创建。
cd /home/git/ sudo mkdir .ssh sudo touch .ssh/authorized_keys 2.4本地端创建密钥 注意，这一步在本地端进行。不同的本地用户有不同的KEY。
ssh-keygen -t rsa 这里在windows下进行，这个命令可以在CMD、PowerShell或Git bash里执行。这里选Git bash，任意空白处右键点击Git bash here，然后右键粘贴执行，中途全默认按回车即可。
如上图就已经生成，在用户根目录的.ssh文件夹内，id_rsa.pub就是我们要的公钥：
2.5本地端公钥上传 这里只是方法之一，只要能把id_rsa.pub传到服务器就行。scp是ssh的文件复制命令。
scp id_rsa.pub git@103.66.218.190:/home/git/ 注意，使用你自己的ip地址。
我们来到上边.ssh文件夹内右键点击Git bash here，右键粘贴执行，中途输入yes，然后输入刚才创建git账号的密码，成功后如图：
2.6服务器添加用户公钥 注意，在服务器端进行。使用cat指令将公钥追加到authorized_keys文件。
sudo sh -c "cat id_rsa.pub &gt;&gt; .ssh/authorized_keys" 注意，如果不是root用户，使用如下方式则会报权限错误：
sudo cat id_rsa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0efce73f448281b66d4a588a6e40626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d120aa7a1729dd25cb259c2dc1684858/" rel="bookmark">
			一、Linux下的SVN服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里自己做个总结。
环境： contos7，百度云服务
下载svn服务器，必须是联网情况下。 yum -y install subversion
查看下载后的信息，安装位置及详细信息。 rpm -ql subversion
3.创建版本库目录，可以再chenjy目录上放置多个项目，不必为每个项目创建一个版本库。下面是我的版本库
mkdir /opt/svn/svnrepos/chenjy
创建版本库
svnadmin create /opt/svn/svnrepos/chenjy (chenjy 就是我的版本库)
4.进入conf配置修改，设置账号、权限。。。
cd /opt/svn/svnrepos/chenjy
查看版本库下面都有什么
[root@instance-45oh6r0z chenjy]# ll
total 24
drwxr-xr-x 2 root root 4096 Feb 21 18:02 conf
drwxr-sr-x 6 root root 4096 Feb 21 18:22 db
-r–r–r-- 1 root root 2 Feb 20 17:49 format
drwxr-xr-x 2 root root 4096 Feb 20 17:49 hooks
drwxr-xr-x 2 root root 4096 Feb 20 17:49 locks
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d120aa7a1729dd25cb259c2dc1684858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbec3566be2cc6241ea804995075a874/" rel="bookmark">
			基于Java web的SSM框架的宠物领养系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境: 最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
IDE环境： Eclipse,Myeclipse,IDEA都可以
tomcat环境： Tomcat 7.x,8.x,9.x版本均可
硬件环境： windows 7/8/10 2G内存以上（推荐4G，4G以上更好）
用了技术框架： HTML+CSS+JavaScript+jsp+mysql
所用的数据库： Mysql数据库，任意版本均可，也可使用各种数据库工具，例如Navicat等。
tips: 需要链接数据库的jsp程序，用到的数据库保存在源码码头的数据库平台上，为了防止童鞋们不注意删除数据，会每24小时还原一次，有较低的概率在你们演示的时候，刚插入或者刚更新，数据库就被还原了，是正常现象，你们下载到本地后，用你们自己的数据库就可以了~^_^。
适用于： 由于本程序规模不大，可供课程设计，毕业设计学习演示之用。
本系统分为前台和后台。
前台： 首页：
宠物信息页面：
领养页面：
新闻信息页面：
用户注册页面： 后台： 如有需要，请联系博主。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2b0554704e652af582cc61ef986b48/" rel="bookmark">
			ajax技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 全局刷新与局部刷新 在B/S 结构的项目中， 浏览器端负责把用户的请求和参数通过网络发送给服务器,服务端负责接收请求，并将处理的结果返回给浏览器。浏览器端负责展示响应结果给用户。
全局刷新 由浏览器亲自向服务端发送请求协议包，接着由服务端直接将【响应包】发送到浏览器的内存中，这个行为导致浏览器内存中原有内容被覆盖掉；所以整个浏览器数据全部被刷新。
局部刷新 不是由浏览器发送请求给服务端，而是浏览器委托浏览器内存中一个脚本对象代替浏览器发送请求。这个行为导致服务端直接将【响应包】发送脚本对象内存中，所以是脚本对象内容被覆盖掉，但是此时浏览器内存中绝大部分内容没有收到任何影响。只会刷新局部的内容。
ajax技术就是一种局部刷新的技术。 2. 准备工作–搭建后端环境 使用ajax技术是需要有后端环境的，因此，在使用该技术之前需要搭建好后端环境；这里使用基于node.js的koa2框架来搭建后端环境。此处有基本的node.js的知识就可以较好地使用起来。
1.koa2框架是基于node.js的，所以需要确保自己的电脑里已经安装了node.js环境。 2.安装脚手架，用于快速构建koa2的初始环境 npm install -g koa-generator 3.创建koa2的初始项目 koa2 tencentsports # 初始化依赖 cd tencentsports npm i 4.启动koa2环境 npm run dev 前往浏览器输入localhost:3000，如果出现以下画面，说明koa脚手架已经运行成功了；这也就表示我们已经搭建好一个后端环境了。
接下来，我们打开项目文件，简单介绍一下项目构成。
启动该项目，就相当于运行了一个后端环境，下面简单的使用该项目完成一个请求到响应的过程。
在public文件夹下添加静态资源，是可以是直接访问的。 在public文件夹下的image文件夹下放图片，可以直接通过浏览器访问查看。
在public文件夹下创建html文件，同样可以直接访问。 通过路由，映射请求 这种也是常规开发中最常见的形式。
// 这是测试方法，参照上面的形式即可 router.get('/test1', async (cxt, next) =&gt;{ cxt.body = '这是test1文件' }) 以上就是koa2的基本使用情况，想要详细了解该知识，可以参考官方网站koa官网
3. ajax基本使用 ajax通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。
var xhr = new XMLHttpRequest(); xhr实例下的onload()事件，用于监听请求是否已经成功完成。
xhr.onload = function(){ console("请求已经完成"); } xhr实例创建成功后，使用open()和send()方法发出HTTP请求。
xhr.open('GET', 'http://localhost/test1', true); xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac2b0554704e652af582cc61ef986b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f401f6126eabac9a878d9e589ba00d14/" rel="bookmark">
			element的el-input出现无法输入的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 某位传说级大佬 的指点下, 解决了该 bug
问题 : 在 el-table 中使用了 el-input , el-table 外层还嵌套了多层 el- 组件
原因 : 嵌套的 el- 组件太多
解决 :
1. 在 el-table 的 el-table-column 中, 使用 template slot-scope="scope" 插槽, 再将 el-input 放入其中
2. 将 el-input 绑定的数据, 存放在 el-table 的 :data 数据中
&lt;el-tabs :tab-position="tabPosition" style="height: 200px;" type="card" v-model="activeName" &gt; &lt;el-tab-pane :label="item.label" :name="item.name" v-for="(item, index) in sizeList" :key="index" &gt; &lt;el-table ref="singleTable" :data="tableData" style="width: 100%" border header-align="center" &gt; &lt;el-table-column width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f401f6126eabac9a878d9e589ba00d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1d6495b9d27455b29520c886a1860a/" rel="bookmark">
			记openssh升级，telnet安装（环境CentOS 7.9。 晗旧版本的不同补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前提工作
1. 先查看系统版本：
2. 准备相关安装包（rpm包）部分rpm包列表：
二、安装telnet（CentOS Linux release 7.9.2009环境）
1. 检查xinetd运行状态及telnet是否安装
2. 创建安装包存放目录 及 rz命令上传RMP包
3. 进入目录/tools/telnet执行安装：（按顺序执行，不然可能报错） 4. 启动telnet服务及查看服务端口
5. 设置root用户登录、关闭防火墙实现root用户登录到telnet 6. 卸载telnet的步骤 （补充）
三、编译安装gcc
1. 查看是否安装gcc 及 创建安装包存放目录
2. 安装gcc （多数情况系统已安装）
四、编译安装（升级openssl）
1. 检查以前安装的包
2. 查看相关依赖包是否安装
五、编译安装（升级openssh，CentOS Linux release 7.9.2009环境）
1. 查看相关依赖包是否安装
2. 创建安装包存放目录 及 rz命令上传压缩包 3. 解压 openssh-9.0p1.tar.gz 及 进入解压后的目录
4. 执行编译安装命令（安装过程建议telnet登录安装，但非必须） 5. CentOS 7 之前的版本需要做以下处理
6. 修改配置文件开启root用户直接登录 7. 开机自启,服务启动 8. 重启openssh测试 9. 升级后ssh ip跳转时的两个错误问题记录
一、前提工作 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e1d6495b9d27455b29520c886a1860a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be8b308e5db7d598dc166002a1783f6/" rel="bookmark">
			Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质配有效果图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质有效果图) 目录
Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质配有效果图)
一、简单介绍
二、各种材质说明
1、MeshBasicMaterial 基础网格材质
2、MeshDepthMaterial 深度网格材质
3、MeshDistanceMaterial 距离网格材质
4、MeshLambertMaterial Lambert网格材质
5、MeshMatcapMaterial
6、MeshNormalMaterial 法线网格材质
7、MeshPhongMaterial Phong网格材质
8、MeshPhysicalMaterial 物理网格材质
9、MeshStandardMaterial 标准网格材质
10、MeshToonMaterial 卡通网格材质
11、PointsMaterial 点材质
12、RawShaderMaterial 原始着色器材质
13、ShaderMaterial 着色器材质
14、ShadowMaterial 阴影材质
15、SpriteMaterial 点精灵材质
16、LineBasicMaterial 基础线条材质
17、LineDashedMaterial 虚线材质
一、简单介绍 Three js 开发的一些知识整理，方便后期遇到类似的问题，能够及时查阅使用。
本节介绍， three.js （webgl）中有各种材质，不同材质又有不同的效果，这里做简单的介绍，如果有不足之处，欢迎指出，或者你有更好的方法，欢迎留言。
Materail 材料的抽象基类。
材料描述物体的外观。它们是以一种(主要)与渲染无关的方式定义的，所以如果你决定使用不同的渲染器，你不必重写材料。
以下属性和方法可以被所有其他材质类型继承(尽管它们可能有不同的默认值)。
属性 ：
.alphaTest:Float
设置要在运行alpha测试时使用的alpha值。如果不透明度低于这个值，材质将不会被渲染。默认值为0。
.alphaToCoverage:Float
使alpha覆盖范围。只能在启用msaa的上下文中使用(意味着在创建渲染器时将antialias参数设置为true)。默认是假的。
.blendDst:Integer
混合的目的地。默认是OneMinusSrcAlphaFactor。请参阅所有可能值的目标因子常数。
材质的混合必须设置为customblend，这样才会有效果。
.blendDstAlpha:Integer
. blenddst的透明度。如果为空，则使用. blenddst值。默认为空。
方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be8b308e5db7d598dc166002a1783f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d22caeda76b6835715619234be920a/" rel="bookmark">
			【论文笔记】MV3D：Multi-View 3D Object Detection Network for Autonomous Driving
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文针对自动驾驶场景中的高精度3D对象检测。我们提出了多视点三维网络(MV3D)，这是一个以激光雷达点云和RGB图像为输入，预测定向三维边界框的传感器融合框架。我们用一个紧凑的多视图表示来编码稀疏的三维点云。该网络 由两个子网络组成: 一个用于三维物体建议生成，另一个用 于多视图特征融合。提案网络从三维点云的鸟瞰图表示中有效地生成三维候选框。我们设计了一个深度融合方案，将来自多个视图的区域特征结合起来，使不同路径的中间层之间能够相互作用。在具有挑战性的KITTI基准上的实验表明， 我们的方法在 3d 定位和 3d 检测任务上的表现优于最先进的 25% 和 30% 。此外，在二维检测方面，我们的方法 比基于激光雷达的方法在数据上获得的高出 14.9% 。
1.介绍 3D 物体检测在自动驾驶汽车的视觉感知系统中起着重要的 作用。现代自动驾驶汽车通常配备多个传感器，如激光雷达和 摄像头。激光扫描仪具有准确深度信息的优势，而相机则保留 了更多详细的语义信息。激光雷达点云和 RGB 图像的融合应该 能够为自动驾驶汽车提供更高的性能和安全性。
本文的研究重点是利用激光雷达和图像数据进行三维物体检测。我们的目标是高精度的 3d 定位和识别道路场景中的物体。最近基于激光雷达的方法将3D窗口放置在3D体素网格中，对点云进行评分[25,6] ，或者在密集框预测方案中对前视图点图应用卷积网络[16]。基于图像的方法[4,3] 通常首先生成3D框建议，然后使用 Fast R-CNN [9]中对前视图点图应用卷积网络。基于激光雷达点云的方法通常可以获得更精确的3D位置，而基于图像的方法在2D框评估方面具有更高的精度 [10,7]。通过采用早期或晚期融合方案将激光雷达和图像结合用于二维检测。然而，对于更具挑战性的三维物体检测任务，但是，对于更具挑战性的3D对象检测任务，需要设计良好的模型来利用多种模态的优势。
本文提出了一种多视图三维物体检测网络(MV3D) ，该网络将多模式数据作为输入并预测3D空间中对象的完整3D范围。利用多模态信息的主要思想是执行基于区域的特征融合。 我们首先提出了一个多视图编码方案，以获得一个紧凑和有 效的表示稀疏的三维点云。如图 1 所示，多视图三维检测网 络由两部分组成: 一个三维建议网络和一个基于区域的融合网络。3D 提案网络利用点云的鸟瞰图表示来生成高度准确的 3d 候选框。3D 物体提案的好处是它可以投影到 3d 空间 的任何视图。多视图融合网络通过从多个视图向特征地图投 影三维方案来提取区域特征。我们设计了一种深度融合方法， 从不同角度实现中间层的相互作用。Com 结合下降路径训 练[14]和辅助损失，我们的方法显示出优于早期/晚期融合方 案的性能。鉴于多视图特征表示，网络执行面向三维盒回归， 预测三维空间中物体的准确三维位置，大小和方向。
在具有挑战性的 KITTI [8]物体检测基准上，我们评估了 我们的三维建议生成、三维定位、三维检测和二维检测的方 法。实验表明，我们的三维建议显着优于最近的三维建议方 法 3dop [4]和 Mono3D [3]。特别是在只有 300 个提案的情 况下，在 Intersection-over-Union (IoU)阈值为 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d22caeda76b6835715619234be920a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aca43218b56bab005ab234a953362cb/" rel="bookmark">
			大数据培训学习程序员有必要吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有越来越多非科班出身的小伙伴在初次接触到大数据开发的时候，感觉工资很高，也想学习大数据开发技术，但是自己没有任何的编程基础，随着大数据开发技术的不断更新，学习大数据开发的门槛也在逐渐变高，自己看视频学吧，有些知识只能是一知半解，不能很好的理解透彻相关的大数据开发技术知识点，于是就产生了疑问：学习大数据开发真的需要去培训吗？
其实，我还是比较建议小伙伴选择一个比较靠谱的大数据培训机构来学习的。
现在随着互联网的不断发展，大数据开发技术也得到了更广泛的应用。不管是手机软件还是计算机软件，只要是你用电子产品的时候就会遇到大数据相关的事情，因此对大数据开发人才的需求也在不断增加。小伙伴想要学好大数据开发语言，选择一家靠谱的大数据培训机构来提升和巩固自己的开发技术水平不失为一种最佳决策。
1.决定参加培训前，小伙伴有一件事是必须认真考虑的，那就是不要盲目地参加培训班，要先确定自己是否适合学习大数据开发。毕竟学好一门编程语言并不是一蹴而就的，尤其是大数据开发技术的学习不仅需要一定的逻辑思维能力和分析能力，更需要掌握必要的编程技巧，才能在职业道路上越走越远。
2.看自己对大数据的学习是否充满兴趣，如果小伙伴对大数据开发的学习很感兴趣，那么小伙伴在学习大数据开发的时候也会有足够的动力。但如果小伙伴既对大数据开发技术学习没有任何兴趣，又不能静下心来学习，那就不必为应不应该参加大数据培训课程而烦恼了，因为这个问题没有任何意义。如果你坚持去，也是在浪费时间和金钱。
当确定自己适合学习大数据开发技术之后，就有另外一个问题需要考虑了，那就是如果参加了大数据培训课程的学习并且学完后能带给我什么？而不是白白浪费时间和金钱。
小伙伴要知道的就是参加培训的方式能够帮助我们更好的学习大数据开发技术。如果自己能找到一家可靠的培训机构并认真学习，把大数据学好、学明白，那么对自己的就业肯定是有一定的保障。因此，掌握好大数据语言技能就等于是多了一块进入大数据开发行业的敲门砖，也必然会给自己在大数据行业里带来更大的机遇和发展空间。所以只要能够掌握好大数据语言的学习,在大数据开发行业寻找一份工作易如反掌。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584683475c7c9bd3d467e32d83727186/" rel="bookmark">
			数据库delete语句和TRUNCATE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		delete语句：
delete from MyTableName where id = 6 truncate语句：
truncate table MyTableName 注意：区别于DELETE命令
相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快
不同 :
使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器
使用TRUNCATE TABLE不会对事务有影响
-- 删除表数据(不带where条件的delete)
DELETE FROM test;
-- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志.
-- 删除表数据(truncate)
TRUNCATE TABLE test;
-- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志.
ps：
在SQL SERVER 2008里，delete from ... where id = ... 删除一个数据后，再insert into一个数据，id会在原来的基础上自增，但是插入的数据是在删除的数据原来的位置那里。
例：
id name 1 Mike 2 Xiaoming 3 Xiaohong 4 Sarah delete from ... where id = 2 之后，insert into .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/584683475c7c9bd3d467e32d83727186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889152ce0f6948c60ebdfe9b91ec24ba/" rel="bookmark">
			c语言随机点名器(源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突发奇想写了个随机点名器…以供使用
随机点名器 main函数
#include "myList.h" #define FILENAME "stu.txt" void menu();//画面界面; void userOptions(Node* headNode);//用户选项 int main(void) { SetConsoleTitle(L"随机抽查系统"); Node* List = createrList(); readInfoFromFile(List, FILENAME); while (true) { menu(); userOptions(List); system("pause"); system("cls"); } system("pause"); return 0; } void menu() { printf("\t\t\t学生点名系统\n"); printf("\t\t1)开始随机抽查" "\t\t2)添加学生\n" "\t\t3)删除学生" "\t\t4)修改学生信息\n" "\t\tq)退出\n"); printf("请输入你的选项:"); } void userOptions(Node* List) { Student info; char choose = '0'; choose = enter(); switch (choose) { case '1': printf("\t\t\t*开始随机抽查*\n"); seekNode(List, rollCall(LengthNode(List))); break; case '2': printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889152ce0f6948c60ebdfe9b91ec24ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420e5a8f0251d0ae3cc9fe909b3002e8/" rel="bookmark">
			在底层框架使用@SneakyThrows注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@SneakyThrows注解是由lombok为我们封装的，它可以为我们的代码生成一个try…catch块，并把异常向上抛出来，而你之前的ex.getStackTrace()是没有这种能力的，有时，我们从底层抛出的异常需要被上层统一收集，而又不想在底层new出一大堆业务相关的异常实例，这时使用@SneakyThrows可以简化我们的代码。
@SneakyThrows为方法添加注解 import lombok.SneakyThrows; public class SneakyThrowsExample implements Runnable { @SneakyThrows(UnsupportedEncodingException.class) public String utf8ToString(byte[] bytes) { return new String(bytes, "UTF-8"); } @SneakyThrows public void run() { throw new Throwable(); } } 而它生成的代码为我们加上了try…cache块，并以新的Lombok.sneakyThrow的方式向上抛出
import lombok.Lombok; public class SneakyThrowsExample implements Runnable { public String utf8ToString(byte[] bytes) { try { return new String(bytes, "UTF-8"); } catch (UnsupportedEncodingException e) { throw Lombok.sneakyThrow(e); } } public void run() { try { throw new Throwable(); } catch (Throwable t) { throw Lombok.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420e5a8f0251d0ae3cc9fe909b3002e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736c8fc10ca810f309fa578a93d416e8/" rel="bookmark">
			5个可以加速开发的VueUse函数库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你想查看每个实用程序的完整列表，我绝对建议你查看官方文档。但总结一下，VueUse 中有 9 种函数。
动画（Animation）—包含易于使用的过渡、超时和计时函数
浏览器（Browser）—可用于不同的屏幕控制、剪贴板、首选项等
组件（Component）— 为不同的组件方法提供简写
Formatters – 提供反应时间格式化功能
传感器（Sensors ）—用于监听不同的 DOM 事件、输入事件和网络事件
状态（State ）—管理用户状态（全局、本地存储、会话存储）
实用程序（Utility）—不同的实用程序函数，如 getter、条件、引用同步等
Watch —更高级的观察者类型，如可暂停观察者、去抖动观察者和条件观察者
杂项（Misc）— 事件、WebSockets 和 Web Worker 的不同类型的功能
这些类别中的大多数都包含几个不同的功能，因此 VueUse 可以灵活地用于你的用例，并且可以作为快速开始构建 Vue 应用程序的绝佳场所。
在本文中，我们将研究 5 个不同的 VueUse 函数，以便你了解在这个库中工作是多么容易。
但首先，让我们将它添加到我们的 Vue 项目中！
将 VueUse 安装到你的 Vue 项目中
VueUse 的最佳特性之一是它仅通过一个包即可与 Vue 2 和 Vue 3 兼容！
安装 VueUse 有两种选择：npm 或 CDN
1、useRefHistory 跟踪响应式数据的更改 useRefHistory跟踪对 ref 所做的每个更改并将其存储在数组中。这使我们可以轻松地为我们的应用程序提供撤消和重做功能。
让我们看一个示例，其中我们正在构建一个我们希望能够撤消的文本区域。
第一步是在不使用 VueUse 的情况下创建我们的基本组件——使用 ref、textarea 和用于撤消和重做的按钮
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736c8fc10ca810f309fa578a93d416e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d706c6d433c975f1c9303d0a848c3e/" rel="bookmark">
			【selenium学习总结3】----高阶：js操作、下拉框定位、弹框定位、行为链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、js操作 1.js控制滚动条
滚动条回到顶部：
js = "var q = document.getElementById('id').scrollTop=0"
driver.execute_script(js)
滚动条拉到底部：
js = "var q = document.documentElementById('id').scrollTop=10000"
driver.execute_script(js)
0是最上面，10000是最底部
横向滚动条：
scrollTo(x, y)js = "window.scrollTo(100,400);"
driver.execute_script(js)
以上方法在火狐上正常，在谷歌上不行，需要修改：
js = "var q=document.body.scrollTop=0"
driver.execute_script(js)
元素聚焦
target = driver.find_element_by_xxxx()
driver.execute_script("arguments[0].scrollIntoView();", target)
scrollTo函数
--scrollHeight 获取对象的滚动高度。 --scrollLeft 设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离。 --scrollTop 设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离。
--scrollWidth 获取对象的滚动宽度。 scrollTo函数不存在兼容性问题，直接用这个函数就可以了
#滚动到底部
js = "window.scrollTo(0,document.body.scrollHeight)"
driver.execute_script(js)
#滚动到顶部
js = "window.scrollTo(0,0)" driver.execute_script(js)
2.js处理日历控件（修改readonly属性）
日历控件无法输入，只能选择
&lt;input id="train_date" class="inp-txt" type="text" value="" name="leftTicketDTO.train_date" autocomplete="off" maxlength="10" readonly="readonly"&gt;
3.js处理内嵌滚动条
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d706c6d433c975f1c9303d0a848c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62570e83bc128ee6fcba88ad2dd1c978/" rel="bookmark">
			mysql连接出现(1040, ‘ny connections‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与此同时navicat连接mysql出现too many connections 错误，睡一觉起来就可以连接了，应该是mysql设置的最大连接数太小导致的，在/etc/mysql/my.cnf里面加上max_connections=1000，wait_timeout=5，未试验过，仅参考，后在本机作尝试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0653665e7b411e1a4bc49be53fb9c0a/" rel="bookmark">
			【Hadoop】MapReduce案例——好友推荐度案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前期准备二、数据准备三、好友推荐度案例 一、前期准备 可参考 “词频统计” 案例中的前期准备阶段
二、数据准备 生成好友关系数据，上传至hdfs
package com.hdtrain; import com.google.inject.internal.util.$FinalizableReference; import java.util.HashMap; import java.util.Map; public class HelloFriend { public static void main(String[] args) { Map&lt;Integer, String&gt; friendMap = new HashMap&lt;&gt;(); for (int i=100;i&lt;=200;i++){ friendMap.put(i, ""); for (int j=1;j&lt;=4;j++){ int friend = (int) (Math.random() * 21 + 200 + 20 * j); if(!friendMap.containsKey(friend)) { friendMap.put(friend, ""); } friendMap.put(i, friendMap.get(i) + " " + friend); friendMap.put(friend, friendMap.get(friend) + " "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0653665e7b411e1a4bc49be53fb9c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b845816507c8cef7e1885b75245ee2c/" rel="bookmark">
			IDEA使用阿里巴巴Alibaba编码规范插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA使用阿里巴巴Alibaba编码规范插件
最新版《阿里巴巴Java开发手册》以及idea\eclipse插件等官方项目地址：https://github.com/alibaba/p3c
安装 打开IDEA，选择File-&gt;Settings-&gt;Plugins
在Marketplace中搜索Alibaba Java Coding Guidelines
点击install安装。
restart重启IDEA。
使用 1、Tools工具栏或者Tools下方快速工具栏中有编码规约扫描功能，可以实时开启扫描或关闭实时手动扫描。
2、扫描后下方会出现对应的Ali-Check，根据规约的程度进行修改，强制的一般会用红波浪线标注。
3、也可以对检查约束进行自定义选择，File-&gt;Settings-&gt;Editor-&gt;inspections，可以根据自己要求进行选择约束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ce0847bc30b93a9991521e23e2f30c/" rel="bookmark">
			RepeatMasker（一）——安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RepeatMasker安装及使用 文章目录 RepeatMasker安装及使用一、安装1. RMBlast序列搜索引擎2.TRF搜索串联重复序列3. repeatmasker下载4. Repbase数据库5. 配置repeatmasker依赖关系 二、使用1.参数说明2.输入3. 使用RepeatMasker 三、结果1. masked文件2. out文件3. out.gff文件（和.out文件完全一样）4. out.html文件（和.out文件一样，只是在html，显示方式不同罢了）5. polyout文件——单独列出了微卫星表格6. tbl文件——统计文件 一、安装 1. RMBlast序列搜索引擎 # 下载RMBlast源码包并编辑 cd /share2/pub/yangjy/yangjy/softs/ wget ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/2.6.0/ncbi-blast-2.6.0+-src.tar.gz wget http://www.repeatmasker.org/isb-2.6.0+-changes-vers2.patch.gz tar zxvf ncbi-blast-2.6.0+-src.tar.gz gunzip isb-2.6.0+-changes-vers2.patch.gz cd ncbi-blast-2.6.0+-src patch -p1 &lt; ../isb-2.6.0+-changes-vers2.patch cd c++ ./configure --with-mt --prefix=/share2/pub/yangjy/yangjy/softs/rmblast --without-debug make # 安装程序及库至系统目录，有报误，但我们需要的rmblastn已经可以正常使用了 sudo make install # Makefile:40: recipe for target 'install-toolkit' failed # 测试程序是否安装成功 /share2/pub/yangjy/yangjy/softs/rmblastn -h 2.TRF搜索串联重复序列 cd /share2/pub/yangjy/yangjy/softs/ wget http://tandem.bu.edu/trf/downloads/trf409.legacylinux64 cp trf409.legacylinux64 ./trf # 测试有帮助信息即可用 trf 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ce0847bc30b93a9991521e23e2f30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50df36c27ae4165cb5bfa3f6d16a4c30/" rel="bookmark">
			Python中eval()函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享一下Python中的eval()函数，如果感觉博主的文章还不错的话，希望大家点赞支持一下博主
文章目录 eval()函数语法实例实例1实例2实例3 eval()函数 eval() 函数用来执行一个字符串表达式，并返回表达式的值。
语法 eval(expression[, globals[, locals]])
expression – 表达式。globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。locals–变量作用域，局部命名空间，如果被提供，可以是任何映射对象。 返回值：返回表达式计算结果。
实例 我们在从键盘输入数据时，Python接收的是字符串类型，这时我们可以使用eval()函数，将输入的数据进行还原
实例1 n = input() m = eval(input()) # type()函数可以用来检测数据类型 print(type(n)) print(type(m)) #利用eval()将字符串类型转为整形 print(type(eval(n))) 输出结果：
使用eval()函数，将字符串还原为数字类型，和int()函数的作用类似
实例2 # 输入[1,2,3,4] m = input() # 得到一个字符串 n = eval(input()) # 得到一个列表 print(type(m)) print(type(n)) print(type(n[0])) 输出结果
将输入的字符串转为对应的数据类型，列表、元组等数据类型都可以使用这种方式输入
实例3 # 表达式 s1 = '3*7' s2 = 'pow(2,3)' n = eval(s1) m = eval(s2) print(n, m) 输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50df36c27ae4165cb5bfa3f6d16a4c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1c44f7228f8c603c07c5e05fed4f42/" rel="bookmark">
			【论文阅读 | cryoET】Gum-Net：快速准确的3D Subtomo图像对齐和平均的无监督几何匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文题目&amp;作者 Gum-Net: Unsupervised Geometric Matching for Fast and Accurate 3D Subtomogram Image Alignment and Averaging
Xiangrui Zeng, Min Xu
CVPR 2020
创新点 本文是第一个用于强变换变化和高噪声水平图像的三维无监督几何匹配方法。
三个创新模块:
观察到标准深度特征提取过程中的最大池化和平均池化操作都寻求局部变换不变性，这不适合进行精确的集合匹配，因为在特征提取过程中需要很大程度上保留特征空间位置。因此，本文引入了一个特征提取模块，该模块包含了池化和滤波在内的光谱操作，以保持提取特征的空间位置。提出了一种新的孪生匹配模块，通过并行处理两个特征相关映射来改善空间相关信息的传播。在对齐模块中加入了一个改进的空间transformer网络，该网络具有可微的缺失楔插补策略。通过输入随机配对的子层析图，而不考虑它们的结构类信息，从而实现了完全无监督训练。因此和其他弱监督的集合匹配方法相比不需要实例级或类别级的匹配信息等监督信息。 相关工作 基于CNN的2D图像配准
二维图像配准通常包括两步：
（1）获取图像特征描述子；
（2）根据几何模型匹配特征描述子。
层次学习策略可以学习更好的特征描述。无监督的光流估计
光流估计使用密集或系数的向量场来描述二维图像序列中像素的小位移。
虽然是无监督的，但是需要输入的图像仅有很小的像素偏移。无监督可变形医学图像配准
也要求输入的图像对是相似的，移动很小。非基于学习的subtomogram配准
需要很大的计算量，为了减少穷举搜索6D参数空间的计算成本，也有一些算法进行了改进。比如快速旋转匹配算法，考虑更多的振幅和相位信息，还有的是基于核范数同时配准多个子层析图。
这里对比了两种方法，一个是2012的，一个是2013的。（都是JSB上发的文章，2012是本文作者的文章。） 方法 Feature extraction module
Siamese matching module
为了更好地利用和处理特征相关信息，设计了一个孪生相关层。计算Cab和Cba两个相关图。它们各自保留一个输入特征图的空间坐标。两个相关映射的使用传播了更多的特征空间相关信息，用于变换参数的估计。
两张相关图被输入一个有卷积层组成的伪孪生网络，然后分别进行卷积，然后将其拼接成一个全连接层，在另一个全连接层后，孪生匹配模块输出估计的刚体变换参数（6D）。Unsupervised geometric alignment module
因为准备有监督的数据非常耗时，所以更适合无监督。
于是本文提出了一个无监督的几何配准模块，利用空间transformer网络和光谱数据输入，专门为子断层图数据设计。
表示由三维刚体变换参数生成的变换矩阵为：（ x i t , y i t , z i t x^t_i, y^t_i, z^t_i xit​,yit​,zit​)是目标坐标，（ x i s , y i s , z i s x^s_i, y^s_i, z^s_i xis​,yis​,zis​)是源坐标。 θ 11 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1c44f7228f8c603c07c5e05fed4f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba8620958ad13e6d8678272d6b40443/" rel="bookmark">
			取模与求余的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现了个知识盲点，之前一直以为取模和求余是一样的，记录如下，以后复习
取模运算在计算整数商时，采用的是向负无穷大的方向取整。
取余运算在计算整数商时，采用的是向0方向取整。
求模 和 求余 的区别_WesenTCYS的博客-CSDN博客_求余和求模的区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/012757eec3f8a18b7431371e94d298e1/" rel="bookmark">
			【JDBC-6】数据库连接池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类似于线程池，准备一些预先的资源，到使用的时候直接拿出。
之前我们在对数据库进行连接操作时，每次连接都需要连接 connection = JDBCUtils.getConnection(); 操作完毕后还需要释放
JDBCUtils.release(connection,preparedStatement,resultSet); 这些操作是非常消耗系统资源的，因此就推出了数据库连接池的概念。类似于线程池，在事先定义好连接次数后，不用每次操作都要进行数据库的连接和释放
热门的开源数据源实现（拿来即用）
DBCPC3P0Druid:阿里巴巴 用了这些数据库连接池后，在项目开发后就不需要编写连接数据库的代码
eg：
最小连接数：10最大连接数：15 超过了最大连接数就需要等待超时等待：100ms 编写连接池，要实现DateSource接口
数据库连接池使用步骤： 1.下载并导入dbcp、pool的jar包到lib文件夹下并设置为Library（IDEA版本高的话会自动解压）
2.写配置文件（固定写法）
driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/studentcourse?useUnicode=true&amp; characterEncoding=utf8&amp;useSSL=true&amp;serverTimeZone=UTC username=root password=family52 #!-- 初始化连接 -- initialSize=10 #最大连接数量 maxActive=50 #!-- 最大空闲连接 -- maxIdle=20 #!-- 最小空闲连接 -- minIdle=5 #!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 -- maxWait=60000 #JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：【属性名=property;】 #注意：user 与 password 两个属性会被明确地传递，因此这里不需要包含他们。 connectionProperties=useUnicode=true;characterEncoding=UTF8 #指定由连接池所创建的连接的自动提交（auto-commit）状态。 defaultAutoCommit=true #driver default 指定由连接池所创建的连接的只读（read-only）状态。 #如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix） defaultReadOnly= #driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。 #可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE defaultTransactionIsolation=READ_UNCOMMITTED 参数解释：
driverClassName=com.mysql.cj.jdbc.Driver // 不多解释，这是基本的驱动加载 url=jdbc:mysql://localhost:3306/studentcourse?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimeZone=UTC // 驱动注册 username=root //要连接的数据库用户名 password=family520 // 要连接的数据库密码 defaultAutoCommit=true：// 设置是否自动提交,默认为true defaultReadOnly=false： // 是否为只读 默认为false defaultTransactionIsolation=3：// 设置数据库的事务隔离级别默认为1，READ_UNCOMMITTED，推荐设置为3 initialSize=10： // 初始化数据池拥有的连接数量 maxActive=20： /池中最多可容纳的活着的连接数量，当达到这个数量不在创建连接 maxIdle=20： // 最大空闲等待，也就是连接等待队列超过这个值会自动回收未使用的连接，直到达到20 minIdle=5： // 最小空闲等待 ,数据池中最少保持的连接 maxWait=10000 // 最大等待时间，超过这个时间等待队列中的连接就会失效 testOnBorrow=true //从池中取出连接时完成校验 ，验证不通过销毁这个connection，默认为true， testOnReturn=false //放入池中时完成校验，默认我fasle validationQuery=select 1 // 校验语句，必须是查询语句，至少查询一列，设置了它onBorrow才会生效 validationQueryTimeout=1 // 校验查询时长，如果超过，认为校验失败 testWhileIdle=false // 清除一个连接时是否需要校验 timeBetweenEvictionRunsMillis=1 // DBCP默认有个回收器Eviction，这个为设置他的回收时间周期 numTestsPerEvictionRun=3 // Eviction在运行时一次处理几个连接 poolPreparedStatements=true //是否缓存PreparedStatements maxOpenPreparedStatements=1 // 缓存PreparedStatements的最大个数 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/012757eec3f8a18b7431371e94d298e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682f5eef0d1c15a861597c8e5239c302/" rel="bookmark">
			23种设计模式之单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式: 属于一种常见的创建者模式。通过单例模式创造的类只存在一个实例对象
简单的来说，某个程序的配置信息存放在一个文件中，这些配置信息由单例对象读取，然后通过单例对象服务其他对象
它的特点总共有三个:
构造方法私有化提供一个私有的静态变量有一个返回实例对象的公共方法 单例模式又有两个方法进行创建:饿汉式和懒汉式
这里用饿汉式的静态变量方法举例
public class SingletonTest { public static void main(String[] args) { Singleton instance1 = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance1 == instance2); } } // 饿汉式——静态变量 class Singleton { // 1、提供一个静态的私有的变量 private static Singleton instance = new Singleton(); // 2、构造方法私有化 private Singleton(){} // 3、提供一个返回单例对象本身的公共方法 public static Singleton getInstance() { return instance; } } true 输出为true，表示该两个变量都是同一个地址。
饿汉式的另一种方法:静态代码块
public class SingletonTest2 { public static void main(String[] args) { Singleton1 instance1 = Singleton1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/682f5eef0d1c15a861597c8e5239c302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d347686353ac3ff5ebf87cc01b19ff1e/" rel="bookmark">
			k8s数据持久化之NFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
NFS
部署nfs
测试
k8s中使用nfs示例
测试数据共享
测试数据持久化
NFS NFS是主流的k8s数据持久化解决方案与pod共享存储解决方案 NFS数据卷：提供对NFS挂载支持，可以自动将NFS共享 路径挂载到Pod中 NFS：是一个主流的文件共享服务器 部署nfs 1、实施nfs（所有节点） yum install nfs-utils -y 2、选择一台nfs-utils服务器作为数据节点，并进行配置 修改nfs服务器配置 vi /etc/exports 这*代表所有ip可以访问，rw代表对此目录有读写权限，no_root_squash代表他是root身份运行 /ifs/kubernetes *(rw,no_root_squash) 新建此数据目录 mkdir /ifs/kubernetes -p 启动服务并设置开机自启 systemctl start nfs systemctl enable nfs 测试 进去其他k8s节点，远程挂载nfs节点数据，命令（ip为nfs数据节点ip）,在挂载节点新建一个文件然后取消挂载 mount -t nfs 192.168.209.112:/ifs/kubernetes /mnt cd /mnt touch aaa umount /mnt 在nfs服务器可以看到刚刚新建的文件夹 k8s中使用nfs示例 创建一个deployment.yaml vi deployment-nfs.yaml apiVersion: apps/v1 kind: Deployment metadata: name: web-nfs spec: selector: matchLabels: app: nginx replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx volumeMounts: - name: wwwroot mountPath: /usr/share/nginx/html volumes: - name: wwwroot nfs: server: 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d347686353ac3ff5ebf87cc01b19ff1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f41e6b6d774b66cc15d64d445e21e1/" rel="bookmark">
			观察者模式及其应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观察者模式（Observer Design Pattern）,也叫做发布订阅模式（Publish-Subscribe Design Pattern）、模型-视图（Model-View）模式、源-监听器（Source-Listener）模式、从属者（Dependents）模式。指在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。
比如说Redis 中的基于频道的发布订阅就是观察者模式的应用：
一、观察者模式的介绍 观察者模式是一种对象行为型模式，下面就来看看观察者模式的结构及其实现：
1.1 观察者模式的结构 观察者模式结构中主要包括观察目标（Object）和观察者（Observer）主要结构：
Subject：主题抽象类，提供一系列观察者对象，以及对这些对象的增加、删除和通知的方法ConcreteSubject：主题具体实现类，实现抽象主题中的通知方法，通知所有注册过的观察者对象Observer：观察者抽象类，包含一个通知响应抽象方法ConcreteObserver1、ConcreteObserver2：观察者实现类，实现抽象观察者中的方法，以便在得到目标的更改通知时更新自身的状态Client：客户端，对主题及观察者进行调用 1.2 观察者模式的实现 根据上面的类图，我们可以实现对应的代码。
首先定义一个抽象目标类Subject，其中包括增加、注销和通知观察者方法
public abstract class Subject { protected List&lt;Observer&gt; observerList = new ArrayList&lt;Observer&gt;(); /** * 增加观察者 * @param observer 观察者 */ public void add(Observer observer) { observerList.add(observer); } /** * 注销观察者，从观察者集合中删除一个观察者 * @param observer 观察者 */ public void remove(Observer observer) { observerList.remove(observer); } /**通知观察者*/ public abstract void notifyObserver(); } 对应具体的目标类ConcreteSubject
public class ConcreteSubject extends Subject{ @Override public void notifyObserver() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84f41e6b6d774b66cc15d64d445e21e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd165cb67a1c1a026eedc3db1ddc1f0/" rel="bookmark">
			SSM框架整合demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示 本demo只是对SSM框架进行整合搭建的一个demo，并不包含其他的功能，只供ssm框架整合借鉴。
先对spring和springMVC框架进行整合 导入pom依赖 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;spring-webmvc.version&gt;5.3.19&lt;/spring-webmvc.version&gt; &lt;spring-jdbc.version&gt;5.3.16&lt;/spring-jdbc.version&gt; &lt;jsp.version&gt;2.2&lt;/jsp.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet.version&gt;2.5&lt;/servlet.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;fastjson.version&gt;1.2.78&lt;/fastjson.version&gt; &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt; &lt;mybatis-spring.version&gt;2.0.7&lt;/mybatis-spring.version&gt; &lt;druid.version&gt;1.2.8&lt;/druid.version&gt; &lt;mysql-connector.version&gt;8.0.27&lt;/mysql-connector.version&gt; &lt;jsr303.version&gt;0.0.2&lt;/jsr303.version&gt; &lt;lombok.version&gt;1.18.22&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring-webmvc.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring-jdbc.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring-jdbc.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;${jsp.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;${jstl.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;${servlet.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd165cb67a1c1a026eedc3db1ddc1f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebcef9ff09ca6538cc48119dd768c43d/" rel="bookmark">
			Java实现回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：
一、简述 从软件模块之间的调用方式看，分为三类：同步调用、异步调用和回调。
1️⃣同步调用
同步调用是最基本并且最简单的一种调用方式，类 A 的 a() 调用类 B 的 b()，一直等待 b() 执行完毕，a() 继续往下走。该调用方式适用于 b() 执行时间不长的情况，因为 b() 执行时间过长或者直接阻塞的话，a() 的余下代码是无法执行下去的，这样会造成整个流程的阻塞。
2️⃣异步调用
异步调用是为了解决同步调用可能出现阻塞，导致整个流程卡住而产生的一种调用方式。类 A 的 a() 通过新起线程的方式调用类 B 的 b()，代码接着直接往下执行，这样无论 b() 执行时间多久，都不会阻塞住 a() 的执行。但是，由于 a() 不等待 b() 的执行完成，在 a() 需要 b() 执行结果的情况下(视具体业务而定，有些业务比如启异步线程发个微信通知、刷新缓存这种就没必要)，必须通过一定的方式对 b() 的执行结果进行监听。Java 中，可以使用 Future+Callable 的方式做到这一点。
3️⃣回调
在面向对象的语言中，回调则是通过接口或抽象类来实现的，实现这种接口的类为回调类，回调类的对象为回调对象。回调的思想是：
class A 实现接口 CallBack——背景 1class A 中包含一个 class B 的引用 b——背景 2class B 有一个参数为 callback 的方法 b(CallBack callback)——背景 3A 的对象 a 在自己的 a() 里调用 B 的方法 b(CallBack callback)——A 类调用 B 类的某个方法然后 b 就可以在 b(CallBack callback) 中调用 A 的方法——B 类调用 A 类的某个方法 综上：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebcef9ff09ca6538cc48119dd768c43d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c58a917261f66318d1a935e702beb6fa/" rel="bookmark">
			Node基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node基础 node发展史 |
node 是什么 编写服务端的语言。
服务端和客户端编写代码有什么区别？
为什么学习Node? 为了咱们可以了解服务端开发。掌握服务端开发基本流程s
为了前端工程化开发。
IO优势IO I—inputu 读取文件 o — outinput 写入文件对于文件读写,Node采用的是非阻塞IO传统IO在读写文件的时候CPU来处理,而代码执行也处于等待中,浪费性能非阻塞IO将读写操作交给CPU,而代码正常执行,减少等待浪费的性能应用场景 实际应用: webpack/gulp/npm/http-server/json-server服务器中负责IO读写的中间层服务器(天猫中间层IO服务器) NodeJS特点 node 前端学习一个区别 1: 用js 操作dom bom
2: 用js 语言操作的核心模块
​ fs path http 。。。
基本使用 官网上下载 node-v-xx.msi 傻瓜式的安装包 一路下一步,就ok检测是否安装成功 node -v运行程序 node ./xxx.js 当前目录下的xxx.js文件 node js文件路径 运行js文件 js文件路径有当前终端在哪一个路径下有关 运行node程序
1：找到路径 node.exe 路径 where node.exe 2:双击程序 运行 方式二： 在系统终端： 输入 node --&gt; enter node 程序长相
与浏览器的控制题啊 console 一样 语法-模块化 **如何实现模块之间相互访问：** - 1：导出模块 - 2：导入模块 ### CMD-node 1:如何导出 **** ​~~~js module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c58a917261f66318d1a935e702beb6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d80f84141bfe403819758cd4d1c063/" rel="bookmark">
			深度学习技术在不同方向的应用及相关开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习的应用
深度学习是机器学习的一个分支，它除了可以学习特征和任务之间的关联以外，还能自动从简单特征中提取更加复杂的特征，完成对目标函数的拟合任务。随着神经网络的盛行，深度学习被应用到很多的领域，本文主要根据深度学习的技术类别和深度学习的应用场景两个方面进行说明。
1. 技术类型 根据网络模型参数的确定方法，深度学习技术可以分为监督学习技术、非监督学习技术和增强学习技术三类。其中监督深度学习技术中网络模型参数是利用带标注的训练数据对网络进行训练而得到的，非监督深度学习技术中网络模型参数的确定则无需带标注的训练数据，增强深度学习技术中网络模型参数是利用特定评分策略对网络输出进行评分后确定的。
1.1 监督深度学习技术 监督深度学习技术主要包括多层感知器、卷积神经网络和循环神经网络等。多层感知器技术是早期神经网络研究的基础性成果，也是衡量深度神经网络性能的对比参照基础；卷积神经网络包括分类网络、检测网络、分割网络、跟踪网络 和轻量化网络；循环神经网络主要包括长时短期记网络和门限循环单元网络。
一般情况下，卷积神经网络均属于前馈神经网络，信息按神经元在网络中层次由浅至深地进行处理，而层次较浅的神经元参数不会受到层次较深的神经元输出的控制，即网络没有记忆，因此通常不适用于序列学习。循环神经网络引入了深层神经元输出到浅层神经元输入和状态的控制机制，使网络具有记忆功能，更适用于序列学习。由于绝大部分经典自然语言处理任务均属于序列学习的范畴，因此，循环神经网络在自然语言处理领域取得了广泛的应用。经典的循环神经 网络主要包括长时短期记忆网络系和门限循环单元网络。
1.2 非监督深度学习技术 非监督深度学习技术主要包括玻尔兹曼机、自编码器和生成对抗网络等。虽然可以使用监督学习的方式训练网络，但受限玻尔兹曼机通常被视为一种早期经典的深度非监督学习技术。自编码器能够通过无监督学习，生成输入数据低维表示、可用于数据的去噪、降维和特征表示等任务。自编码器一般均是采用编码器-译码器结构，实现自监督学习，主要包括VAE、Stacked Denoising AE 和 Transforming AE 等技术。生成对抗网络是近年来非监督深度学习技术的研究 热点之一，主要包括GAN、CGAN、WGAN、 EBGAN、infoGAN、BigGAN 和 SimGAN 等。生成对抗网络的主要思想是利用生成模型和分辨模型之间的竞争关系，在网络损失度量中包含利于一个模型而不利于另一模型的部分，训练过程使生成模型输出将输入噪声信号尽可能逼近信息输入，而同时提高分辨模型分类与生成模型信息输出与输入的正确性，从而达到网络整体性能的优化。
1.3 增强深度学习技术 增强深度学习技术主要包括Q学习和策略梯度学习。Q学习的核心思想是利用深度神经网络，逼近贝尔曼方程描述的递归约束关系。Q学习算法一般采用估计、决策和更新的迭代过程, 经典的估计方法有蒙特卡洛树搜索算法、动态规划算法等，基本的Q学习方法有DQN、Double DQN、Prioritized DQN 和 DRQN 等。策略梯度 学习的基本方法是利用深度神经网络，实现策略的参数化，并通过梯度优化控制参数权重，选择较好的行为实现策略，常用的策略梯度有有限差分策略梯度、蒙特卡洛策略梯度、Actor- Critic 策略梯度等，主要的策略梯度学习方法有REINFORCE、TRPO、DGP、DDGP 等。
2. 应用场景及问题 2.1 多分类问题： 2.1.1 图像分类： 图像分类任务是模型根据输入的图像进行预估。比如Esteva 等基于 Inception v3 主干网络,直接使用多达13万份带标注的临床影像数据来训练，训练任务是检验该深度神经网络对于皮肤癌分类预估的性能。
深度学习在医学图像分类中的应用：（开源地址：https://github.com/21Vipin/Medical-Image-Classification-using-deep-learning）
2.1.2 文本分类： 文本分类是在NLP中很重要的模块。也是NLP任务中比较基础的模块。可以应用到很多领域：比如情感分析，新闻分类，垃圾邮件过滤等等。应用是非常广泛的。
医疗领域的文本数据还涉及到大量的领域内部命名实体、行业术语及表述习惯等问题,因此基于深度学习的自然语言处理在医疗领域的应用相比而言成熟度较低。
从医学实验室报告的图像中检测和识别文本的测试代码（开源地址：https://github.com/xuewenyuan/OCR-for-Medical-Laboratory-Reports）
手写体识别（开源地址：https://github.com/0x454447415244/HandwritingRecognitionSystem
文本分类中单词和标签的联合嵌入（论文开源地址https://github.com/guoyinwang/LEAM）增加标签对于文本分类中的影响
2.1.3 文本数据挖掘以及诊断报告的生成 文本数据挖掘可以应用于电子病历结构化、临床决策支持、异常事件检测、信息语义化检索等场景。
在医疗领域的应用有：Borjali 等人探索了采用深度学习方法从纯文本的医疗报告中提取相关信息,完成对医疗不良事件的检测统计工作,并以髋关节置换术后脱位的案例进行试验。Wu等人将自动图像描述应用在糖尿病视网膜眼底图像的诊断上,作者直接使用经典CNN-LSTM网络结构,即首先使CNN抽取特征,再依据特征使LSTM 生成对应的文字描述,作者的训练数据集使用370张临床眼底图像,并对每张图像人工添加5种自然语言描述作为标注,其测试结果显示对病变眼底图像生成的报告准确度能达到 90%,但当测试集包含正常眼底图像后,整体准确度下降到只有60%左右。
使用深度学习从临床笔记（在 MIMIC-III 数据集中）预测医疗账单代码：（开源地址：https://github.com/ziyuqiu/icd_prediction开源地址：https://github.com/asyzhejian/DeepLearning_Electronic_Medical_Record）
2.1.4 视频分类： 在做视频分类时候，直接使用3x3x3卷积核可能会产生参数过多、运算量过大的情况，难以训练等诸多问题，所以一般会分解为 1x3x3 的 spatial convolution 以及 3x1x1 的 temporal convolution。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d80f84141bfe403819758cd4d1c063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b346cb30fd5206e8a570f19b81b71e/" rel="bookmark">
			集成运算放大器的应用——放大、加减、跟随、（滞回）比较器、阻抗匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前大三自动化方向。因为设计电路时总是忘了它的工作原理和相关运用，故整理一下它的全部我遇到的相关的知识。文章内容并非原创，而来自网络，文末有引用，看不懂的可以自己再去研究研究，如侵联删。
目录 一、运放的内部电路二、加（求和）减法，正反相比例、T型放大三、跟随器四、(滞回)比较器五、阻抗匹配（网罗了各种理解，选个能接受的就好 一、运放的内部电路 它的工作原理大概是这样的——输入会有两个电压，输入之后就会产生一个电压差，电压差加在输入电阻上面；这里面还有一个压控电压源，它会把收到的一个小电压放大G倍，这个增益是非常非常大的；然后再通过一个内部的输出电阻输出出去，那么就可以得到一个被放大的电压。
Rb属于三角形之外的外接电阻了，vi1,2对应正负输入端。Vcc和Vee是插在三角形两边上的供电电源。
双入单出的函数（后续补充）：
再放一个封装好的运放的示意图，有基础的同学可以自己理解一下。(https://www.rohm.com.cn/electronics-basics/opamps/op_what2)
二、加（求和）减法，正反相比例、T型放大 主要是巧用运放的虚短虚断（同相输入时只有虚短），以及叠加原理。多输入用叠加原理时，其他输入端要接地，而不是悬空。
补充：T型放大一般适用场合增益在100倍以上。
T型放大电路会使噪声增益变大
T型反馈电路用于反相放大电路或变形的I-V电路中
三、跟随器 电压跟随器的作用
1、缓冲
在一定程度上可以避免由于输出阻抗较高，而下一级输入阻抗较小时产生的信号损耗，起到承上启下的作用。
2、隔离
电压跟随器的电压增益近似为 1。当输入阻抗很高时，就相当于对前级电路开路，当输出阻抗很低时，对后级电路就相当于一个恒压源，即输出电压不受后级电路阻抗影响。一个对前级电路相当于开路，输出电压又不受后级阻抗影响的电路当然具备隔离作用，即使前、后级电路之间互不影响。所以，电压跟随器常用作中间级，以“隔离”前后级之间的影响，此时也称之为缓冲级。
(来源：https://www.eefocus.com/ask/477622) 四、(滞回)比较器 普通比较器（https://blog.csdn.net/qlexcel/article/details/79671016，如侵联删）
滞回比较器（供电电源提供给反馈端一个电压，输入端的绝对值要大于它，输入端才有效)（https://blog.csdn.net/geek_monkey/article/details/104856225，如侵联删）
五、阻抗匹配（网罗了各种理解，选个能接受的就好 说法一
输入阻抗跟一个普通的电抗元件一样，反映了对电流阻碍作用的大小。对于电压驱动的电路，输入阻抗越大，则对电压源的负载就越轻，因而就越容易驱动，也不会对信号源有影响；而对于电流驱动型的电路，输入阻抗越小，则对电流源的负载就越轻。
因此，可以这样认为：如果是用电压源来驱动的，则输入阻抗越大越好；如果是用电流源来驱动的，则阻抗越小越好。
说法二
https://www.elecfans.com/dianzichangshi/20180313646583.html
说法三（最详细）
https://m.elecfans.com/article/671550.html
最后想说的是，集成运放有它自己的分析特点，但都是满足电压电流基本定律的。
1.运放的经典应用电路图
https://www.elecfans.com/dianlutu/amp/20171209599051_3.html
2.运放的内部电路图介绍
https://wenku.baidu.com/view/ffd3cdcf92c69ec3d5bbfd0a79563c1ec4dad769.html
3.一个将运放的B站视频，当时看了同相加法，弄懂了自己的一些误区。
比如：多输入用叠加原理时，其他输入端要接地，而不是悬空。
https://www.bilibili.com/video/BV1Cz4y1S748?spm_id_from=333.337.search-card.all.click
4.T型放大电路
https://www.cnblogs.com/lifan3a/articles/15393686.html
5.s普通比较器来源于https://blog.csdn.net/qlexcel/article/details/79671016
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa65b08cb4c2a64edf62a16390bd802/" rel="bookmark">
			Servlet--EL表达式与JSTL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、EL表达式
jsp页面因为内含servlet相关对象和Java代码，经常会出现空指针异常的问题，而EL表达式就替换了页面中的Java代码，避免了这样的问题的发生。
EL 表达式有标准标签库一起诞生， 与JSTL配合使用
自动化工作：可以在pageContext，request，session，application中子弹寻找 “attribute” request .setAttrbute(“k”,v)自动调用 get方法自动处理空值 ${users}//相当于List&lt;User&gt; list=(List&lt;User&gt;) request.getAttribute("users"); EL表达式演示
&lt;h2&gt;EL表达式输出信息&lt;/h2&gt; &lt;p&gt;自动寻获 ${message}， 自动调用get方法 ${emp.ename}, 自动处理空 ${text} &lt;/p&gt; &lt;h1&gt;EL表达式演示2&lt;/h1&gt; &lt;p&gt;arr1: ${arr1[0]} ${arr1[1]} &lt;/p&gt; &lt;p&gt;arr2: ${arr2[0]} ${arr2[1]} &lt;/p&gt; &lt;p&gt;arr3: ${arr3[0].ename} ${arr3[0].empno}&lt;/p&gt; &lt;p&gt;list1: ${list1[0]}&lt;/p&gt; &lt;p&gt;list2: ${list2[0].ename}&lt;/p&gt; &lt;p&gt;map: ${map.east.ename} ${map['east'].ename}&lt;/p&gt; 2、JSTL
配置JSTL
导入JSTL jar包
&lt;dependency&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 在前端页面开头需加上对JSTL的引用
&lt;%@taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt;
JSTL结合EL表达式遍历获取数据
&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="${users}" var="user"&gt; &lt;tr&gt; &lt;td&gt;${user.id}&lt;/td&gt; &lt;td&gt;${user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa65b08cb4c2a64edf62a16390bd802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9277b7fcdadedc08ab3cdcf5c35d8152/" rel="bookmark">
			CDR2022首发全新版本性能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Coreldraw 2022（软件套装全称：CorelDRAW Graphics Suite 2022，简称CDR 2022）官方正式版已经发布（含windows及Mac版）。Coreldraw 2022首发版版本号为：v2022，喜欢追新的用户可以从Corel下载新版本安装。
Coreldraw基本上每年都会发布新版本，这次我们来看看Coreldraw 2022又带来哪些新功能？
Coreldraw2022新功能简介 ⻚⾯泊坞窗/检查器
CorelDRAW 2022中新的⻚⾯泊坞窗/检查器简化了多⻚⾯⽂档的⼯作⽅式。它会列出⼀个设计中的所有⻚⾯，您可以轻松管理⻚⾯并快速导航项⽬。每个⻚⾯都有⼀个可缩放的缩略图预览，显⽰其⼤⼩和内容。⻚⾯重新排序简单，拖⼊泊坞窗/检查器即可。
您还可以⼀次性添加、删除和重命名⻚⾯，省时⼜省⼒。⼀键即可切换显⽰模式，重点置于单个⻚⾯或使⽤新的多⻚视图。
⾃动调整⻚⾯
CorelDRAW 2022中的另⼀项省时功能就是⾃动调整⻚⾯功能。⼀键即可根据⻚⾯内容调整⻚⾯尺⼨。您还可以通过指定设计元素和⻚⾯边缘之间的间距，快速⾃定义边距。
辅助线
使⽤辅助线时，您可以快速将视图从世界⽐例切换到⻚⾯尺⼨。此外，⾃定义辅助线更易于管理，因此您可以⽐以往更快地速度建⽴设计框架。
各⾃贴⻬
处理复杂的设计时，有⼀项新的设置可以防⽌对象贴⻬各⾃的对⻬点，您可以轻松精确地移动和转换设计元素。
透视绘图
在 CorelDRAW 2022中，在透视图中绘制对象或场景变得前所未有地轻松。该新功能是基于透视投影的原理，消除了⾸先设置复杂⽹格的需要，可以提⾼⽣产率。其中有四种类型透视绘图的预设，预设可以通过调整透视图域的任何部分轻松⾃定义。在同⼀个⻚⾯或⽂档中轻松创建多个透视图组，每个透视图组都有各⾃独特的透视视域，让您创造⽆限可能。
HEIF ⽀持
CorelDRAW Graphics Suite 2022具有⾼效图像⽂件 (HEIF) ⽀持功能，可以让您⼿机上捕捉的照⽚展现出最佳效果。许多设备将HEIF 作为默认捕获格式，因为这种格式的⽂件较⼩，⽽且不会牺牲图像质量。您可以从 Corel PHOTO-PAINT 中的 HEIF ⽂件中导⼊或打开关键图像，或者将其导⼊ CorelDRAW 中的绘图中。
图像调整
Corel PHOTO-PAINT 2022推出⼀系列特⾊功能和增强功能，提供更⾼效、更准确的图像编辑体验。新的调整泊坞窗/检查器可以让您即时访问最关键和常⽤的过滤器，让您以⽆损、实时的⽅式在上下⽂中快速地⼯作。全新的局部调整模式还简化了将过滤器定位到特定图像区域的过程。
替换颜⾊
“替换颜⾊”过滤器全新改版。改进的拾⾊器和滴管⼯具可以实现更精确的编辑，新的交互式控制使⾊调和饱和度微调更直观。CorelDRAW 2022还新增了⼀个滑块，可以确保选定像素和未选定像素之间的颜⾊转换更顺畅。
实时评论
该新功能可以让参与项⽬的每⼀个⼈都能实时⼯作，涉众可以在 CorelDRAW.app中对⽂档进⾏评论和注释，所有反馈将即时出现在 CorelDRAW 2022中的⼯作⽂件中。
项⽬管理界⾯
项⽬管理界⾯可以帮助存储、查看、组织和分享保存⾄ Cloud 的⽂件。CorelDRAW 2022 和 CorelDRAW.app 中的新版管理界⾯可以充当您的协作中⼼。其中包含了所有的 Cloud 图纸，单击⼀下即可显⽰预览、评论数量和团队成员以及项⽬状态。您还可以在管理界⾯中直接从 CorelDRAW 2022 共享设计，⽆需打开每个⽂件。
多⻚视图
CorelDRAW 2022 的多⻚视图有助于加快设计⼯作流程。它可以让您同时查看⽂档中的所有⻚⾯，您就不必单击选项卡导航⾄图纸的其他部分。在⼀个视图中查看、管理和编辑项⽬的所有数字资产。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9277b7fcdadedc08ab3cdcf5c35d8152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd955264241eb4b3f13e4b7b669eb11/" rel="bookmark">
			spring 的后置处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring的后置处理器 spring提供了三种后置处理器
BeanFactoryPostProcessorBeanPostProcessorInitializingBean 我们来依次看每个后置处理器的执行流程。
BeanFactoryPostProcessor 首先还是回到refresh方法中，我们可以看到在创建普通bean对象的上面有个方法叫invokeBeanFactoryPostProcessor，从方法名就可以看出是执行BeanFactoryPostProcessor方法
方法内部调用了一个代理类的静态方法 方法内部会首先拿出实现了PriorityOrdered接口的对象排序后执行
执行完PriorityOrdered接口后再拿出实现了Order接口的对象执行 最后把剩下的BeanFactoryPostProcessor根据类名排序后调用方法，这时候容器里面还是没有对象的，在getBean的时候需要走原来看过的创建普通bean的流程 前面的都是执行的BeanDefinitionRegistryPostProcessor的方法postProcessBeanDefinitionRegistry，三个判断结束之后最后执行BeanFactoryPostProcessor的postProcessBeanFactory方法 流程图如下
工厂后置增强的实际用途 我们现在知道了spring提供了一些工厂的后置处理器来增强工厂，那么我们现在来看看spring中实际使用工厂后置处理器做了什么事情，我们来看一个类ConfigurationClassPostProcessor
这个类是用于处理写了@Configuratioin注解的类 排序好之后就在一个循环里面解析容器里面的类 在方法中先判断是不是需要跳过，如果写了@Conditional注解的对象会判断条件是否生效 真正解析配置类的方法里面就是各种判断注解的情况，然后去做相应的方法
BeanPostProcessor 注册 工厂的增强至此就结束了，接下来看看普通组件的后置处理器的逻辑，还是回到refresh方法，这次是调用registerBeanPostProcessors方法，注册后置处理器。 注册的逻辑跟BeanFactory都是由同一个代理类来完成的 大部分逻辑和bean工厂的逻辑一致，都是判断优先级接口的就先执行 跟bean工厂不一致的是，bean工厂的后置处理器直接执行目标方法，这里只是把bean后置处理器创建好之后就放入list中
InstantiationAwareBeanPostProcessor 所有的BeanPostProcessor都被注册之后，我们来看其中一个分支：InstantiationAwareBeanPostProcessor 的流程
SmartInstantiationAwareBeanPostProcessor 从名字上可以看出叫智能的实例后置处理器，那么这个我们就来看看智能在什么地方. 在refresh方法中调用了一个注册监听器的方法 在该方法中调用了一个根据类型获取名称列表的方法，该方法是ListableBeanFactory接口的一个方法 为了获得目标类的名称，spring遍历所有的bean的名称，一个一个判断
判断逻辑是先判断已经初始化好的实例，然后再判断bean定义信息，如果都没有则让别人来判断 拿到容器中的SmartInstantiationAwareBeanPostProcessor然后把类名和bean名称穿进去，让实现类来决定 总结流程图 所以我们知道，在spring中，根据类型来找名称其实spring需要遍历所有对象，是一件很麻烦的事情
InstantiationAwareBeanPostProcessor 在spring容器创建对象之前，会先调用 InstantiationAwareBeanPostProcessor的 postProcessBeforeInstantiation方法尝试返回对象，如果用户返回了则会用用户创建的对象。 如果没有则调用doCreateBean方法，方法内也会从一个缓存中获取，没有的话就继续调用方法创建 创建逻辑会让用户返回一个构造函数，注意这里调用的是SmartInstantiationAwareBeanPostProcessor的一个方法，如果没有就用默认的无参构造函数，之后就是上面写过的用工具类创建的方式
MergedBeanDefinitionPostProcessor 在创建好bean实例对象之后会调用一下MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法让用户定义一下BeanDefinition
PopulateBean 之后就进入属性赋值方法，首先会先执行 InstantiationAwareBeanPostProcessor的 postProcessAfterInstantiation方法，返回bool类型的值，如果返回true则会继续属性赋值，返回false则不会属性赋值
如果返回true则开始执行InstantiationAwareBeanPostProcessor 的 postProcessProperties方法。自动注入 AutowiredAnnotationBeanPostProcessor的该方法就实现了自动注入的属性赋值
PropertyValues 在上面我们可以看到postProcessProperties方法返回了一个pvs，我们也可以自定义返回pvs，spring最后会帮我们注入到对象中，创建一个PVS返回即可
BeanPostProcessor 属性赋值之后spring会执行initializeBean 方法初始化bean,首先会先执行一些 Aware的注入
BeanNameAwareBeanClassLoaderAwareBeanFactoryAware 初始化的流程如下 postProcessBeforeInitialization方法在调用初始化方法之前执行,让用户可以不断的包装对象,有一个返回了null,则结束循环 返回对象之后就执行初始化方法,InitializingBean的方法就是在这里被触发 执行完初始化方法之后,spring会调用postProcessBeforeInitialization的另一个生命周期方法,同样也是让用户可以包装几层
作者：马尾区卷王
链接：https://juejin.cn/post/7089059751501234213
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e6546b2a49a764994fcec12f6b067a/" rel="bookmark">
			MODIS数据下载——CSV模式直接下载hdf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提： 经常下载MODIS数据就会发现，NASA官网经常不干活——NSAS官网经常会有订单归档困难的情况，不能通过订单批量下载，这样就无法直接下载选定波段、经过投影与转tif处理后的数据了。
订单批量下载MODIS数据链接：MODIS数据下载——订单模式下载tif影像
这时我们就可以利用下载CSV的方式下载hdf格式的文件，当然后期就需要自己再将这些hdf格式文件处理成tif格式的文件。
具体操作如下： 选择需要下载的影像文件，然后点击下载此处的CSV文件；
下载后是一个包含各个遥感影像部分下载地址的.csv文件，其中第一行为列标题；从第二行开始，第二列是遥感影像下载地址的一部分。
接下来我们需要在其前面添加一段网址，将所有下载链接补充完整。方式如下：
选中右侧第一个空白列，在D2中输入如下：
="https://ladsweb.modaps.eosdis.nasa.gov/"&amp; 然后选择B2单元格，即生成影像的完整下载链接，接着直接下拉单元格进行填充。
填充到有数据的最后一行即可；随后不要动鼠标，直接将当前选中的列内容加以复制。
将复制的内容粘贴到一个新建的.txt文件中（不要复制第一行列标题）。
将.txt文件拖动导入浏览器中；如下显示：
此时首先需要选中一条链接，将其在新的浏览器界面打开。
如果没有登录EARTHDATA，则需要在新打开的界面中进行登录。
然后会出现保存或下载界面，关闭该提示与下载页面，回到.txt文件页面。
如果使用的是FireFox浏览器，可右键直接DownThemAll!!，选定文件夹后下载即可。（也可以使用IDM进行下载。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8430f7fc00e32c347ca03a8f0a4b1ffc/" rel="bookmark">
			备忘录模式及其实现场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备忘录模式（Memento Design Pattern），也叫快照（Snapshot）模式。指在不违背封装原则前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。
备忘录模式在日常中很常见，比如Word中的回退，MySQL中的undo log日志，Git版本管理等等，我们都可以从当前状态退回之前保存的状态。比如Git中的checkout命令就可以从main版本切换到之前的bugFix版本：
一、备忘录模式介绍 备忘录是一种对象行为型模式，它提供了一种可以恢复状态的机制，并实现了内部状态的封装。下面就来看看备忘录模式的结构及其对应的实现：
1.1 备忘录模式的结构 备忘录的核心是备忘录类（Memento）和管理备忘录的管理者类（Caretaker）的设计，其结构如下图所示：
Originator：组织者类，记录当前业务的状态信息，提供备忘录创建和恢复的功能Memento：备忘录类，存储组织者类的内部状态，在需要时候提供这些内部状态给组织者类Caretaker：管理者类，对备忘录进行管理，提供存储于获取备忘录的功能，无法对备忘录对象进行修改和访问 1.2 备忘录模式的实现 在利用备忘录模式时，首先应该设计一个组织者类（Originator），它是一个具体的业务类，存储当前状态。它包含备忘录对象的创建方法createMemeto()和备忘录对象恢复方法restoreMemeto()。
Originator类的具体代码如下：
public class Originator { private String state; public String getState() { return state; } public void setState(String state) { this.state = state; } //创建一个备忘录对象 public Memento createMemento() { return new Memento(this); } //根据备忘录对象，恢复之前组织者的状态 public void restoreMemento(Memento m) { state = m.getState(); } } 对于备忘录类（Memento）而言，它存储组织者类（Originator）的状态，其具体代码如下：
public class Memento { private String state; public Memento(Originator o) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8430f7fc00e32c347ca03a8f0a4b1ffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3b4e30ccc098604b256a1bf0669f78/" rel="bookmark">
			Java中删除String中空格的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，要实现删除String中的空格的方法有很多种，具体有：
1、 trim() 删除字符串开头和结尾的空格，Java 1版本引入的接口，这是开发人员最常用的方法。trim移除的空白字符指的是指ASCII值小于或等于32的任何字符(’ U+0020 ')，其中包含了空格、换行、退格等字符。
String value = " Hellow world ! "; System.out.println("before: \'" + value + "\'"); String afterValue = value.trim(); System.out.println("after: \'" + afterValue + "\'"); 结果为：
before: ' Hellow world ! ' after: 'Hellow world !' 2、strip() 删除字符串开头和结尾的空格。与trim()功能基本相同，在Java 11版本上引入的接口，区别在于删除的是根据Unicode标准来标识的所有空格字符，除了ASCII中的字符以外，还是有很多其他的空白字符。
String value = " Hellow world ! "; System.out.println("before: \'" + value + "\'"); String afterValue = value.strip(); System.out.println("after: \'" + afterValue + "\'"); 结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3b4e30ccc098604b256a1bf0669f78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7372baafe9a8a36b1f5af0fe4dd612f5/" rel="bookmark">
			【HDLBits刷题】Dff.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A D flip-flop is a circuit that stores a bit and is updated periodically, at the (usually) positive edge of a clock signal.
D flip-flops are created by the logic synthesizer when a clocked always block is used (See alwaysblock2). A D flip-flop is the simplest form of "blob of combinational logic followed by a flip-flop" where the combinational logic portion is just a wire.
Create a single D flip-flop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7372baafe9a8a36b1f5af0fe4dd612f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f6f101f9fdc06b9fae3f957fde9681/" rel="bookmark">
			VOS3000 8.05安装及源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统需求环境：
1.系统 ：linux 64位系统 2.内核要求：内核2.6 以上 3.内存 ：2G以上内存 4.系统要求：centos7.X 或者 redhat5.X （笔者用的centos7.5_64， 博主weixin@yuyinjiqiren最好用centos7.5） 5.java环境：java version "1.5.0_08" 6.web环境 ：apache-tomcat-5.5.15 7.数据库 ：mysql 二、安装需求软件：
1.apache-tomcat-5.5.15.tar.gz 2.jdk-1_5_0_08-linux-i586.rpm 3.vos3000-2.1.8-05.i586.rpm 4.emp-2.1.8-05.noarch.rpm 5.mbx3000-2.1.8-05.i586.rpm 6.ivr-2.1.8-05.i586.rpm 三、安装：
1.系统基础环境配置： 关闭selinux； vi /etc/sysconfig/selinux 设置：SELINUX=disabled 保存，退出，需重启生效。 防火墙关闭； service iptables stop chkconfig iptables off 检查启动列表，关闭无用的程序； chkconfig sendmail off chkconfig ip6tables off 安装中文支持： yum groupinstall chinese-support -y 2.安装数据库： yum install mysql mysql-server -y 设置开机启动，并启动： chkconfig mysqld on service mysqld start 设置mysql安全启动脚本： mysql_secure_installation 回车： Set root password?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f6f101f9fdc06b9fae3f957fde9681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161e06cd60f7ff38fd6ae9645da87806/" rel="bookmark">
			The request client is not a secure context and the resource is in more-private address ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 新版的chrome浏览器会校验发起端的域名和访问资源的域名直接的关系，如果客户端发起域名比访问资源所在的域名更public（开放），会导致The request client is not a secure context and the resource is in more-private address …错误产生。
问题 最近使用Chrome浏览器访问公司内网某个地址时，突然报了这么个错：
The request client is not a secure context and the resource is in more-private address space private. 以前都是正常的，最新的浏览器最近有什么更新导致的。
原因 报错内容
错误原因
解决办法 在浏览器地址栏输入
chrome://flags/#block-insecure-private-network-requests 按照下图将Block insecure private network requests.项的Default改为Disabled即可。
参考 Chrome浏览器：The request client is not a secure context and the resource is in more-private address …
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bb1b509830322c89fba8ecdb492608/" rel="bookmark">
			vscode常用插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常用插件 1.Auto Close Tag 自动关闭标签，再开始标记的结束括号中键入 后，将自动插入结束标记
2.Auto Rename Tag 结合了自动关闭标签与同时修改同步标签
3.background
4.Beautify 美化代码
5.Bracket Pair Colorizer
6.Chinese(Simplified) Language Pack for Visual Studio Code
7.Debugger for Chrome 从VS Code调试在Google Chrome中运行的JavaScript代码。
8.GitLens-Gitsupercharged
9.HTML CSS Support
10.HTML Snippets
11.javaScript(ES6) code snippets ES6的代码片段
12.jQuery Code Snippets
13.Markdown Preview Enhanced
14.npm Intellisense
15.open in browser 在vscode中打开浏览器访问
16.Path Intellisense 自动路径补全
17.Vetur
18.vscode Gitlens 代码显示提交人员和时间
19.koroFileHeader 代码添加注释
vscode 更换背景图 设置-&gt;搜索background-&gt;Plugin background-&gt;在setting.json中编辑
"background.customImages": [ // "file:///D:/pro/images/fa1368691ed006f0aac9fd54c2cb196.png",//图片地址 "file:///D:/pro/images/f8e5b0ff63f0b7990a20c2285d699bd.png",//图片地址 ], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44bb1b509830322c89fba8ecdb492608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45da0f7db17f727246fb008ab9ecf6e0/" rel="bookmark">
			VSCODE（三）用户界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过用户界面，我们可以设置软件的一些功能和表现，了解界面上各个UI功能块非常有必要。
一、设置 1.1 用户设置和工作区设置 用户设置（User Setting）: 所有VSCODE实例都有效的设置，因此也叫全局设置，这个设置通常放在计算机的固定位置；工作区设置（Workspace Setting）:当前工作区有效的设置。工作区设置可以上传到服务器上方便所有成员共享。 工作区有点像是项目设置实例，如果你要设置一个所有项目都生效的设置，请设置在用户设置中。
1.2 打开设置 VSCODE有途径进行VSCODE设置，分别是JSON和UI方式。那么如何打开JSON或UI进行设置呢？
菜单栏选取。FIle-Preference-Settings(Linux)；Code-Preference-Settings(Mac)；命令面板搜索。 ctrl+shift+P或者F1，搜索Preference:Open Setting(UI/JSON)；快捷键。ctrl+, 命令面板搜索是一个方便的工具，在你不记得或需要设置某一项功能是，可以试试搜索它！
UI方法进行设置，其界面如下：
最左边已经将设置进行了分类方便我们查找对应内容。
1.3 修改设置 UI设置。大部分的设置都可以通过复选框、输入框和下拉列表实现；JSON文件设置。对于比较复杂的设置，就需要编辑对应JSON文件实现设置。 JSON文件的全局默认位置：
Windows: %APPDATA%\Code\User\settings.jsonmacOS: $HOME/Library/Application Support/Code/User/setting.jsonLinux: $HOME/.config/Code/User/setting.json JSON文件局部默认位置：
文件根目录的.vscode文件夹下
有时候我们某些语言需要特定设置，另一些语言则需要另一个设置。VSCODE通过设置语言特定的设置，通过命令面板查找：Preferences: Configure Language Specific Settings。
简单说一下JSON的语法，这是配置的基础。JSON 的语法基本上可以视为 JavaScript 语法的一个子集，包括以下内容：
数据使用名/值对表示。使用大括号保存对象，每个名称后面跟着一个 ‘:’（冒号），名/值对使用 ,（逗号）分割。使用方括号保存数组，数组值使用 ,（逗号）分割。 看个例子：
{ "book": [ { "id":"01", "language": "Java", "edition": "third", "author": "Herbert Schildt" }, { "id":"07", "language": "C++", "edition": "second", "author": "E.Balagurusamy" }] } %appdata%就代表了C:Users\用户名\AppData\Roaming这个文件夹。
注意：一些关乎安全的设置，则只能在全局进行设置。如：git.path termianl.integrated.shell.linux
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45da0f7db17f727246fb008ab9ecf6e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aabf6804842f389923e4a63bef6ea34/" rel="bookmark">
			Git clone的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Git clone项目 1 . 首先我们要确保我们的电脑上已经安装Git。
桌面点击右键出现如下图所示的两个Git即Git已经安装。
2 . 在电脑的任意一个磁盘里新建一个本地文件夹作为clone项目的保存文件夹。
3 . 在码云上面打开我们要clone的项目。
4 . 点击克隆/下载按钮出现项目地址的连接，点击后面的复制。
5 . 进入我们创建的本地文件夹内，右击选择Git Bash Here。
6 . 稍加等待，出现如下命令窗口。
7 . 输入git clone https://gitee.com/wei-weixiao/WareHouse.git。
即git clone 复制的项目地址。
8 . 回车进行项目的下载，如下图所示项目下载完成，项目已经出现在本地的文件夹内。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ff706a65ef3e890b432966124bd439/" rel="bookmark">
			二叉树的非递归遍历算法C语言实现（详细注释版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的非递归算法遍历分为：先序遍历，中序遍历，后序遍历。
此文章我会根据先、中、后的顺序为大家用C语言实现全部代码。
顾名思义先序遍历是先遍历根节点，随后是左孩子，右孩子 。
中序遍历与后序遍历可以通过类比改变根节点相对左右孩子的遍历顺序。
我不为大家讲解先、中、后遍历的实现思想了。
我为我所写的每一行代码都书写了详细的注释，为大家看懂代码的目的及功能提供便利。
所写注释可能会有少部分错别字，如果发现欢迎大家及时提出。
先为大家附上代码实现结果图：
马上为大家附上全部代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //创建节点结构体 typedef struct{ char data; //节点数据 struct BTNode * LChild, * RChild;	//左右孩子 }BTNode; //创建树 BTNode *CreateTree(void){ BTNode *T,*head,*s[50];	//T：用于储存和返回创建的树。 head：用于创建节点。 s[50]：用于储存树。 char ch; //用于获取树的节点的data数据 int i,j; //i：用于定位树节点的序号（i=0时退出）。 j：用于定位该树节点的父节点 while (1){ printf("please enter a number:");	scanf("%d", &amp;i);	//输入节点插入位置。 getchar();	//吸取输入后的回车符 防止回车符对数据影响 if (i==0) //当i=0时结束输入数据 break; else{ printf("please enter a char:"); ch=getchar();	//ch用于获取节点的储存数据 head=(BTNode *)malloc(sizeof(BTNode));	//为head分配内存 head-&gt;data=ch;	//将ch获取的值赋给head的data数据 head-&gt;LChild=head-&gt;RChild=NULL;	//将head的左右孩子节点指向空（初始化左右孩子节点） s[i]=head;	//将该节点对应的位置赋值到树的列表中 if (i==1) //如果i=1则该节点为树的根 T=head; else { j=i/2;	//否则用i/2定位到本次赋值节点的父节点并将父节点的位置赋值给j if (i%2==0) //如果i可以被2整除则该节点是其父节点的左孩子 s[j]-&gt;LChild=head;	else //否则该节点是其父节点的右孩子 s[j]-&gt;RChild=head; } } } return(T) ;	//将创建好的树返回 } //非递归算法的先序遍历 void LeftShow(BTNode *head){ BTNode * rchildlist[50];	//创建一个用于储存右孩子的栈。因为输出父节点，然后输出左孩子。所以需要将右孩子储存起来。 BTNode * show=head;	//将show指针初始化为head的地址。 show用于遍历时储存正在遍历的节点。从根节点开始遍历。 int i=0;	//i为rchildlist栈顶。 while(1){ if(show==NULL){	//当遍历到的节点是NULL时。进行分情况判定 if(i==0)	//如果栈此时也为空。则已经遍历完整个树。就可以退出循环。 break; else{	//如果栈此时不为空。则执行退栈操作。将退栈的值赋值为下一个需要遍历的节点。此时是左孩子已经遍历完，需要遍历右孩子。 show=rchildlist[i];	//将退栈的值赋值为下一个需要遍历的节点。 i--;	//执行退栈操作 } }else {	//当遍历到的节点不为NULL时。 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ff706a65ef3e890b432966124bd439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d3fe0cced6907f578f376488b98062/" rel="bookmark">
			使用VScode 开发ESP32-----1 VSCODE 创建 编译 下载程序基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,使用示例项目模板 创建一个项目 单击菜单 View -&gt; Command Palette… 或者 F1 调出命令面板.后面的内容将不在进行重复提示. 凡是 遇到
命令:
ESP-IDF: Show Examples Projects
均需要 调出命令面板 输入.
2, 显示所有示例模板
命令:
ESP-IDF: Show Examples Projects
3, 在列出的 示例列表中 选择 blink_example 项目. 随后点击 Create blink_example 项目按钮, 根据提示 选择创建项目所在目录.(如果用户选择/Users/myUser/someFolder这个路径 将会得到/Users/myUser/someFolder/blink. 同时这个新的项目目录将在 Visual Studio Code 中创建和打开。)
4, 选择一个 Espressif 目标（esp32、esp32s2 等）
命令:
ESP-IDF: Set Espressif device target
5, menuconfig 配置项目(此步骤是对项目进行整体的配置,配置内容较多 如不清楚 可先忽略)
命令:
ESP-IDF: SDK Configuration editor
6,C/C++配置文件. 在当前项目的 .vscode/c_cpp_properties.json 文件中将展示 对C++编译器的配置.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d3fe0cced6907f578f376488b98062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dae4aa4f25fb0ed8c76111930ebaf714/" rel="bookmark">
			pytorch实现：卷积神经网络识别FashionMNIST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch实现：卷积神经网络识别FashionMNIST 一、卷积神经网络1.1 导入需要的包1.2 图像数据准备1.3 卷积神经网络搭建1.4 卷积神经网络训练与预测 二、空洞卷积神经网络2.1 空洞卷积神经网络搭建2.2 空洞卷积网络预测 一、卷积神经网络 1.1 导入需要的包 对于moduleNotFoundError: No module named ‘pandas’等情况发生时，需要在Anaconda Prompt下进入pytorch（activate pytorch）环境，然后conda install pandas即可。（采用pip安装会报错，但也可以尝试）
import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns import copy import time import torch import torch.nn as nn import torch.utils.data as Data from sklearn.metrics import accuracy_score, confusion_matrix, classification_report from torch.optim import Adam from torchvision.datasets import FashionMNIST from torchvision import transforms import warnings warnings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dae4aa4f25fb0ed8c76111930ebaf714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc2ad8f43bc24d1b78ec423a08d8713a/" rel="bookmark">
			GPU深度学习环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置之前，先说一下基础概念。
显卡驱动 显卡驱动就是用来驱动显卡的程序，它是硬件所对应的软件。驱动程序即添加到操作系统中的一小
块代码，其中包含有关硬件设备的信息。
CUDA CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。 CUDA™
是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指
令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员可以使用C语言来为CUDA™架构编写程序，
所编写出的程序可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和
FORTRAN。
CUDA和cudatoolkit的区别 在使用conda 安装pytorch深度学习框架时，可以发现通常会自动安装对应版本的cudatoolkit。
上述安装的 cudatoolkit 与通过 Nvidia 官方提供的 CUDA Toolkit 是不一样的。具体而言，Nvidia
官方提供的 CUDA Toolkit 是一个完整的工具安装包，其中提供了 Nvidia 驱动程序、开发 CUDA 程序相
关的开发工具包等可供安装的选项。使用 Nvidia 官网提供的 CUDA Toolkit 可以安装开发 CUDA 程序所
需的工具，包括 CUDA 程序的编译器、IDE、调试器等，CUDA 程序所对应的各式库文件以及它们的头
文件。上述 CUDA Toolkit 的具体组成可参考 CUDA Toolkit Major Components.
实际上，Nvidia 官方提供安装的 CUDA Toolkit 包含了进行 CUDA 相关程序开发的编译、调试等过
程相关的所有组件。但对于 Pytorch 之类的深度学习框架而言，其在大多数需要使用 GPU 的情况中只
需要使用 CUDA 的动态链接库支持程序的运行( Pytorch 本身与 CUDA 相关的部分是提前编译好的 )，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc2ad8f43bc24d1b78ec423a08d8713a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e069cf3078b439c30853d41ec2ca7dd/" rel="bookmark">
			vue3怎样实现变量双向绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue2可以通过data、props、computed等钩子绑定变量，vue3也有相似的方式，这里只说一下vue2中的data方式在vue3中的写法
①通过reactive绑定： &lt;templete&gt; &lt;div&gt;{{value}}&lt;/div&gt; &lt;/templete&gt; &lt;script lang="ts"&gt; import { toRefs, reactive } from "vue"; export default{ setup(){ const data = reactive({ value:'' }) return { ...toRefs(data) //toRefs可以解构data中属性，属性也是双向绑定的，这样就不用绑定变量时嵌套data了 } } } &lt;/script&gt; ②通过ref绑定 &lt;templete&gt; &lt;div&gt;{{data}}&lt;/div&gt; &lt;/templete&gt; &lt;script lang="ts"&gt; import { onMounted, ref } from "vue"; export default{ setup(){ let data = ref('测试数据1') onMounted({ data.value = '测试数据2' }) return { data } } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2272112d33155af93d3d9d4a0c053d75/" rel="bookmark">
			1分钟学会使用json-server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨咯！这里是小M. （努力学习VUE版）
先来分享一个我的每日表情包（糊了的萨斯给才最可爱 ）
今天分享json-server的简单用法（学不会你来打我）
1.json-server是啥玩意儿 json-server 是一个 Node 模块，运行 Express 服务器，你可以指定一个 json 文件作为 api 的数据源。
简单的说，它可以模拟小型后台接口，在一个JSON文件中操作数据，是基于的node.js的一个模块
比如我在学习axios，就可以用json-server来模拟接口
2.安装和使用 npm上网址戳 这儿 gitHub网址戳 这儿 在README文件中都有很详细的介绍
$\color{20B2AA} {全局安装（在node环境下）} $
npm install -g json-server $\color{20B2AA} {创建一个名为db.json文件， 并且存放好以下数据} $
{ "posts": [ { "id": 1, "title": "json-server", "author": "typicode" } ], "comments": [ { "id": 1, "body": "some comment", "postId": 1 } ], "profile": { "name": "typicode" } } 文件中的数据是可以修改的，但是对象名最好不要改（posts、comments、profile）
启 动 服 务 \color{20B2AA}{启动服务} 启动服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2272112d33155af93d3d9d4a0c053d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1993a75cb38e11fc6d09e9687a552e07/" rel="bookmark">
			C#实现计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终效果图：
编辑器：Visual Studio 2022
具体步骤：
1、创建窗体应用
2、拖拽公共组件 label
并且 修改 字体
（name）labelout
font 宋体 常规 一号
Text 0
textalign BottomRight
autoSize false （可以任意拖拽大小 位置）
3、复制窗体1
（name）labelbefore
font 宋体 常规 二号
4、复制窗体2 最上面的
（name）labelmode
然后将 第一行 第二行 的 text 文本0 置空
5、拖拽公共组件button
（name）num1
text 1
然后复制 将对应的name text 改成对应的数字
6、双击数字 添加对应数字的点击事件（运行 保存完 双击才能加事件 ）
7、选中数字，点击工具箱中的公共组件 指针 复制 按钮
Text 改为 清除
name clean
双击清除 添加事件
number = 0;
label2.Text = Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1993a75cb38e11fc6d09e9687a552e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3952f4f2250fd1f6d6700295719804/" rel="bookmark">
			Floyd算法(代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无向图的Floyd算法+有向图的floyd算法
只需修改一行，
dist[u][v]=dist[v][u]= w;
改为
dist[u][v]= w;
代码:
#include&lt;iostream&gt; using namespace std; #define Max 9999 int n, m; int dist[Max][Max]; void Floyd() { for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { for (int p = 0; p &lt; n; ++p) { if (dist[j][p] &gt; dist[j][i] + dist[i][p]) { dist[j][p] = dist[j][i] + dist[i][p]; } } } } } int main() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3952f4f2250fd1f6d6700295719804/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/151/">«</a>
	<span class="pagination__item pagination__item--current">152/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/153/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>