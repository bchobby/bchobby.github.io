<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a635c5ceb57d8002e9cdff77ae526482/" rel="bookmark">
			第7.3节-中文简历制作-实习经历、工作经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（点击即可收听）
个人的技能、工作能力可以在实际的工作中完整地展现出来，相关的工作或实习经历是直接体现求职者岗位胜任能力的模块
因此，不管是应届生还是有工作经验的求职者，招聘方在简历筛选和面试过程中最看重的往往就是他们简历中的工作经验这一模块
在一份合格的简历中，相关的实习经历或工作经历应该是篇幅最大的一个模块
对于在校生或者应届生而言，往往没有正式的工作经验，那么利用日常空闲时间或者寒暑假进入企业进行实习显得尤为重要
通过实习，不仅能够学到工作中的一些基本技能，培养职场意识，而且能够在实习过程中认清自己的性格特点和优劣势，以更好地开展职业规划。
一般而言，建议求职者在找工作前至少完成两份相关岗位的实习，这样能确保在应聘时处于优势地位
很多学生在上大学后忙着兼职赚一些生活费，比如做家教、去家电商城当促销员等，如果不是生活特别拮据，我并不建议这么做
这些工作不管对你的职业规划还是工作经验的积累都不会有很大的帮助，虽然能赚些钱，但是你也失去了更好地提升自身能力的机会。
大多数公司的实习补贴不高，甚至部分公司都没有补贴，但从长远的职业发展角度来看，这些实习经历能够让你站在一个更高的职业起点上，获得更有潜力的工作机会
对于还在读书的学生而言，时间才是最宝贵的资源，一定要把有限的时间用在长期来看最有价值的事情上
招聘最讲究的是人岗匹配，比如企业可能只需要2年工作经验的开发人员，而你可能在开发岗位已经工作了10年，那么招聘方往往会存在很多顾虑
比如工作年限长的求职者往往会有更高的薪酬预期、不愿意从事基础性工作
甚至会由于年龄比主管大而引发一些沟通问题,思维固化,往往没有刚毕业的年轻学生,好培养,可塑性强
这也告诉了我们在职场不进则退的残酷现状。
对于年龄大的求职者,在职场当中本身就不占优势,如果从事的是跟刚毕业生一样的工作
可能年龄在增长,但是技术却毫无增长,停滞
有时,需要放低姿态,谦逊一点...让企业觉得自己拥有丰富的实战经验,能够解决公司的痛点,带来价值
工作经历各要素 工作时间是实习或者工作的起止时间，细化到月份即可，一般放置在行首或者行尾，但是无论是日期居左还是日期居右，整个简历所有模块必须统一
日期居左 如果实习在3个月以上，或者每份工作时长都在3年以上，那么这既是求职者经验丰富的证明
也是求职者稳定的表现
在这种情况下，工作时间长无疑是求职者的一种优势，所以可以居左排列
日期居右 如果求职者原来所供职的公司非常有知名度，或者该公司及岗位与应聘公司及岗位相关性强，这种情况下公司和岗位才是突出的重点
此时就应该将公司和岗位放置到左边，而将日期放置到右边
在经历描述中，重点突出自己参与的实际工作及取得的成果，使经历看起来专业且丰满一些
在正式工作以后，如果在不同公司之间的工作经历
历有空档期，且空档期超过3个月，需要对此有合理的解释。
虽然无需在简历上提及，但在面试前需要提前做好准备
公司名称 如果公司品牌的知名度高于公司名称，直接写公司品牌名称即可
如果公司没有品牌名，那就直接写公司名称的全称
如果公司名称的缩写更为人所熟知，可以直接写简称，比如“中信证券股份有限公司”简称“中信证券”
那么公司名称直接写中信证券就可以了
如果公司规模比较大，可以在公司名称后加一些标注，如500强企业、A股上市公司、共享单车龙头企业等
如果公司规模比较小，可以在正文描述中突出公司的优势和岗位的优势。
公司名称的字体大小和正文保持一致，但是需要加粗
部门名称 可以根据岗位性质或者业务性质划定一个部门
例如，互联网公司一般会划分为运营部、设计部、市场部、销售部、技术部、人力资源部等
证券公司
根据业务会划分为投资银行部、交易部、风控部、固定收益部、经纪业务部等
岗位名称 岗位有两个作用：第一个是表明工作的性质，这一点和部门的作用类似，对于一些工作而言，尤其是技能导向的工作，岗位比部门更加重要，如平面设计师、Java开发工程师等；
第二个是突出岗位级别，例如设计主管、技术总监等。
可以根据部门和岗位的性质，以及所负责的具体工作内容，来“定义”一个有显著意义的职位名
做的工作大多与互联网产品设计、产品调研相关，不妨写成“产品实习生”“产品经理助理”
工作几年后，个人的工作职级通常会发生变化，这种情况下简历通常按最高职位来写，升职经历可以放在具体的工作描述中。
毕竟你找的下一份工作，职级至少会和现在平级甚至更高，所以入行初期一些基层的经历可以略去，以突出自己的管理能力或者技术实力
中文简历的整体排版上，标题的字体字号和正文内容要保持一致。如果是一行标题，公司名称、部门名称、岗位名称全部加粗，日期用常规字体
如果是两行标题，公司、部门、岗位名称都在第一行的话仍然全部加粗，部门、岗位名称放置在第二行的话则不用加粗
应届生求职者在撰写该模块内容时往往存在以下问题
（1）缺少实习经历，没有什么可以写；
（2）过往实习经历与应聘职位相关性不大，有的实习完全是为了应付学校考核；
（3）实习内容以打印、复印、跑腿等琐碎的工作为主，缺乏技术含量；
（4）虽然有大公司实习经历，但是因为缺乏好的内容描述方式，本来应该很闪亮的经历却被描述得平淡无奇
寻找实习机会是一个从校园步入社会的过程，是一个从无到有、从四处撒网到精准投递的过程
在写简历的时候,一定要用心去写的,也要用专业的词汇去描述的
把最亮眼的经历放在核心区域
第7.1节-中文简历制作-基本信息
2023-12-26
第6节-写简历的样式排版
2023-12-25
第5.6节-关于毕业找工作是从事软件好还是硬件好
2023-12-24
第5.5节-写简历遵循的基本原则-简历排版规则-一页纸规则
2023-12-23
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a635c5ceb57d8002e9cdff77ae526482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1765088f7f22ef94a5602bac82566753/" rel="bookmark">
			Redis第3讲——跳跃表详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是跳跃表 跳跃表（skiplist）是一种随机化的数据结构，由William Pugh在论文《Skip lists: a probabilistic alternative to balanced trees》中提出。它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。
跳跃表支持O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点，在大部分情况下，跳跃表的效率可以和红黑树、AVL树不相上下，但跳表原理更加简单、实现起来也更简单直观。
在Redis中，跳跃表是有序集合（zSet）数据类型的实现之一，也在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其它用途。
二、举个例子 是不是有点抽象？那么下面我们举个有序链表的例子对比一下，就更容易理解了。
我们先来看下有序链表：
在这个链表中，如果我们想要查找一个数，需要从头结点开始向后依次遍历和比对，直到查到为止，那么它的时间复杂度就是O(N)。
当我们想要在这个链表插入一个数，过程和查找了类似，也是从头到尾遍历，然后在合适为止再插入，时间复杂度也是O(N)。
那有什么好办法呢？如果我们将链表中每两个节点建立第一级索引，是否可以提升效率呢，如下图：
有了索引后，如果我们查询10元素，我们先从一级索引5、8、17、29中查找：
先和5比较，发现10比5大，继续向后找。8比10小，继续向后找。发现8的next指针指向17，比10大，然后下降到0层。此时第0层的next指针指向10，也就是我们要找的元素。 可以看到，同样是查找10，有序链表需要比较（2，5，7，8，10）五个元素，而建了一层索引后，仅需比较（5，8，17，10）四个元素。
有了上面经验，我们在此基础上继续建立二级...
首先和8进行比较，发现比10小，向后查找。此时next指向NULL，下降一层。此时next指针指向17，比10大，下降一层。此时next指针指向10，正是我们要找的元素。 此时只需比较（5、8、10）。
综上所述，通过将有序集合的部分节点分层，从最上层节点依次开始向后查找，如果本层的next节点大于查找值或指向NULL，则从本节开始下降一层继续向后查找，如果找到则返回，反之返回NULL。
因为我们的链表不够大，查找的元素也比较靠前，所以速度上的感知可能没那么大，但是如果是在成千上万个节点、甚至数十万、百万个节点中遍历，那么这样的数据结构就能大大提高效率，这就是跳跃表的思想。
三、跳跃表的实现 Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量、指向表头结点和表尾系欸但的指针等，下面来分别介绍一下。
3.1 zskiplit结构 保存跳跃表节点的相关信息，比如节点的数量、指向表头结点和表尾系欸但的指针等，定义如下：
/* * 跳跃表链表结构 */ typedef struct zskiplist { // 表头节点和表尾节点 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level; } zskiplist; header：指向跳跃表的表头结点。tail：指向跳跃表的表尾结点。length：跳跃表长度，表示第0层除头节点以外的所有结点总数。level：跳跃表高度，除头节点外，其它节点层数最高的即为跳跃表高度。 ps：表头节点和其它节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到。
3.2 zskiplistNode结构 表示跳跃表节点，定义如下：
typedef struct zskiplistNode { // 成员对象 robj *obj; // 分值 double score; // 后退指针 struct zskiplistNode *backward; // 层 struct zskiplistLevel { // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; } level[]; } zskiplistNode; 成员对象（obj）：节点的成员对象，指向一个字符串对象，而字符串对象则保存着一个SDS值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1765088f7f22ef94a5602bac82566753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d709e4b487b8c110aede7f19b7c1bb86/" rel="bookmark">
			Koordinator 助力云原生应用性能提升：小红书混部技术实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：宋泽辉（小红书）、张佐玮（阿里云）
编者按：
Koordinator 是一个开源项目，是基于阿里巴巴内部多年容器调度、混部实践经验孵化诞生，是行业首个生产可用、面向大规模场景的开源混部系统，致力于提升应用服务质量，优化资源使用效率。自 2022 年 4 月正式开源以来，吸引了业界众多优秀工程师的贡献参与和讨论。
小红书是 Koordinator 社区的活跃成员，自项目诞生初期就深度参与了一系列重要功能的演进。本文是基于 2023 云栖大会上关于 Koordinator 分享的实录，Koordinator 社区成员宋泽辉（小红书）、张佐玮（阿里云）为大家介绍了小红书混部技术实践以及 Koordinator 的近期规划。
背景介绍 随着小红书业务的高速发展，各类在线，离线业务对于计算资源的需求也在快速增长。与此同时，部分在线集群天均利用率水位却维持在较低水平，造成这一现象的主要原因有以下几点：
在线服务资源使用量随着终端用户的使用习惯呈现稳定的潮汐现象，夜间 CPU 利用率极低，导致集群均值 CPU 利用率较低；业务保有大量的独占资源池，资源池割裂产生大量的资源碎片，拉低 CPU 利用率；业务为了稳定性考虑，会过量囤积资源，进一步拉低 CPU 利用率。 基于以上背景，为了帮助业务降低资源使用成本，提升集群 CPU 利用率，小红书容器团队从 2022 年开始，通过规模化落地混部技术来大幅提升集群资源效能，降低业务资源成本。
技术演进 小红书混部技术演进分为以下四个阶段：
阶段一：闲置资源再利用 早期集群资源管理粗放，集群中存在大量业务独占资源池，因为资源碎片等因素存在大量低分配率的低效节点，散落在各个集群中的低效节点形成大量资源浪费。另一方面，部分基于 K8s 发布的转码类近线/离线场景，全天时段均存在大量计算资源需求。基于以上背景，容器平台通过技术手段将集群中的闲置资源收集起来，分配给转码类业务场景使用。
我们通过 virtual-kubelet 打通元数据集群与物理集群，将闲置资源汇聚起来，在元数据集群分配给转码类场景近线/离线计算服务。策略方面，二次调度器负责巡检集群所有节点，识别为低效节点后标记出来，virtual-kubelet 获取物理集群中的低效节点可用资源作为集群闲置资源二次分配给离线转码，同时二次调度器需要保证一旦在线服务有资源需求，将会立刻驱逐离线 pod 并归还资源。
阶段二：整机腾挪分时复用 搜推广等业务的独占资源池，CPU 利用率潮汐现象明显，夜间利用率极低，资源池中的单个节点往往也只部署一个大规格业务 Pod，基于以上背景，平台通过弹性能力（HPA），在凌晨业务低峰期按比例对在线业务缩容，腾挪空出整机，并将转码，训练等离线 pod 在该时段运行起来，起到利用率“填谷”的效果。
具体实施时，需要确保在线服务能在规定的时间内全部被拉起，为此，策略方面我们实现了离线提前退场，并通过调度器抢占机制兜底，确保在线服务在业务高峰期来临之前能被全量及时拉起。
阶段三：常态混部 为了降低资源碎片率，降低业务资源持有成本，平台持续推进业务大规模合池，将业务由独占池迁至平台托管的公共混部池，通过合池，资源超卖等技术手段，CPU 分配率得到有效提升，但依旧无法解决合并后的资源池夜间利用率较低等问题。另一方面，合池后的复杂混部场景下，整机腾挪分时混部离线的调度策略很难再继续实施，平台需要通过建设更为细粒度的资源管理与调度能力来实现均值利用率提升的目标，具体包含以下几点：
调度侧： 通过动态超卖技术获取可二次分配给离线的可用资源量，并抽象出离线资源视图让 K8s 调度器感知到，调度器调度离线负载到对应节点上，实现离线对节点利用率的“填谷”效果；通过负载调度，尽可能避免在线服务被调度到高负载机器，让集群中节点负载更加均衡；通过二次调度，驱逐负载热点机器上的高利用率服务，使得集群负载处于动态均衡状态。 单机侧： 支持 Qos(Quality of service) 保障策略，根据服务的 Qos 等级提供差异化的运行时资源保障能力；支持干扰检测、离线驱逐等能力，当离线对在线敏感服务产生干扰时，第一时间驱逐离线。 通过以上技术手段，可以有效保障服务混部时的稳定性，从而常态化的让在线离线工作负载混跑在节点上，实现利用率填谷效果的最大化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d709e4b487b8c110aede7f19b7c1bb86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fb1692b50a5c8e57111a0d0998d6a5/" rel="bookmark">
			格密码基础：子格，q-ary垂直格与线性代数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.写在前面
二.子空间垂直
2.1 理论解释
2.2 举例分析
三. 零空间
3.1 零空间与q-ary垂直格
3.2 零空间与行/列空间
四. 格密码相关
一.写在前面 格密码中的很多基础原语都来自于线性代数的基本概念，比如举几个例子：
格密码中的非满秩格------------矩阵的秩，矩阵列向量的线性独立性
格基正交化过程------------------正交矩阵的性质与变换
子格---------------------------------矩阵子空间
正交子格---------------------------正交子空间
q-ary垂直格-----------------------向量与矩阵列空间垂直
本文章将解释线性代数中的子空间，正交矩阵，零空间，矩阵的秩在格密码中的运用。
二.子空间垂直 2.1 理论解释 一个点：0维度
一条线：1维度
一个平面：2维度
一个立体图形：3维度
以此类推。。。。。
子空间垂直要求：一个子空间中的任意向量与另一子空间中的任意向量都垂直。
比如的子空间维度可以是0,1,2,3。0维的子空间只能是原点（如果选其他点的话，必然构成一条线），当然按照惯例，原点形成的0维子空间与任意子空间都垂直。
子空间垂直领域，一条线可以跟一条线垂直，一条线可以跟一个平面垂直，但注意一个平面和一个平面不可能垂直。
注意：此处与以前高中学习的平面垂直是不一样的。
举个例子：
一间教室前面的墙和侧边的墙，我们感觉是垂直的。但不符合子空间垂直的概念，你沿着角落那条线，在前面墙画一条竖线，在侧面墙画一条竖线，这两条竖线很明显平行，并不垂直。
总结以上，子空间垂直的官方定义如下：
Two subspaces V and W of the same space are orthogonal if every vector v in V is orthogonal to every vector w in W: for all v and w.
2.2 举例分析 给出两个向量，很明显这两个向量形成的子空间V为2维的平面。给出向量，很明显这一个向量形成的子空间W为一条线。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1fb1692b50a5c8e57111a0d0998d6a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b418389fec11ff6e242aef5f7aceeca/" rel="bookmark">
			IntelliJ IDEA [插件 MybatisX] mapper和xml间跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 安装插件2. 如何使用3. 主要功能总结 MybatisX 是一款为 IntelliJ IDEA 提供支持的 MyBatis 开发插件
它通过提供丰富的功能集，大大简化了 MyBatis XML 文件的编写、映射关系的可视化查看以及 SQL 语句的调试等操作。本文将介绍如何安装、配置和使用 IntelliJ IDEA MybatisX 插件，以及它提供的一些主要功能。
1. 安装插件 打开 IntelliJ IDEA，进入插件市场（File -&gt; Setting… -&gt; Plugins -&gt; Marketplace）在搜索框中输入 “MybatisX”找到 MybatisX 插件并点击安装 安装完成后，点击 OK 按钮即可
2. 如何使用 打开 Mapper 接口 如：UserMapper.java
你可以看到一群小鸟图标，随便点击一个 如 insert，便可以直接调转到 xml 文件 insert 对应的 sql 处
然后再在 xml 中点击小鸟图标，便可以跳转到 Mapper 接口处
3. 主要功能 1）XML 文件智能提示
在 Mybatis XML 文件中，插件提供了智能提示功能，包括标签名、属性名等，以减少编写错误
2）SQL 语句可视化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b418389fec11ff6e242aef5f7aceeca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0ac9470e463793385337732ad467f5/" rel="bookmark">
			SpringbootActuator监控与管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Actuator监控与管理 准备条件 idea IntelliJ IDEA 2019.3 (Ultimate Edition)**SpringBoot '**2.2.2.RELEASE’Java version 1.8 在微服务架构中，将单体系统拆分为多个独立的服务应用使得系统变得更加灵活和可扩展，但也带来了运维上的挑战。随着应用数量增多，监控和维护这些服务变得更加复杂。为了解决这些挑战，需要建立一套自动化的监控和运维机制。
在使用Spring Boot作为微服务框架时，spring-boot-starter-actuator模块提供了一系列用于监控的端点，这些端点允许获取应用程序的各种信息，并且可以通过配置和扩展实现自定义监控需求。这个模块的使用可以减少监控系统在采集应用指标时的开发工作量。
spring-boot-starter-actuator模块提供了一些常用的端点，比如：
/actuator/health：提供应用程序的健康状态信息，可以检查应用程序是否正常运行。/actuator/info：提供关于应用程序的自定义信息。/actuator/metrics：展示应用程序的各种度量指标，比如内存使用情况、线程池信息等。** /actuator/env**：展示应用程序的环境变量信息。** /actuator/beans**：展示应用程序中所有的Spring Beans信息。 此外，Spring Cloud对spring-boot-starter-actuator模块进行了扩展，以支持与微服务相关的一些功能，比如与Eureka整合时，会在/actuator/health端点中添加更多健康检查信息。
虽然spring-boot-starter-actuator提供了很多功能，但有时候也需要根据特定需求做一些扩展或定制。可以通过自定义端点、配置指标收集、拦截器等方式来满足特定的监控需求。
总的来说，spring-boot-starter-actuator模块为微服务架构提供了一套方便且强大的监控机制，能够大大简化监控系统对应用指标收集的工作，同时也提供了扩展机制，允许根据特定需求进行定制。
快速入门 spring boot项目中引入 spring-boot-starter-actuator 模块功能，只需要在pom.xml的 dependency 节点中。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; application.yaml配置显示信息添加配置信息 management: endpoints: enabled: true web: base-path: /actuator exposure: include: "*" endpoint: health: show-details: always 重新启动应用。此时我们在控制台中可以看到如下输出
- http://localhost:8080/actuator显示所有的接口
http://localhost:8080/actuator/health显示健康检查，显示应用健康信息 官网显示的所有信息
Endpoint ID /health endpoint
http://localhost:8080/actuator/health { "status": "UP", "components": { "diskSpace": { "status": "UP", "details": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0ac9470e463793385337732ad467f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a733ccd53f35854e4ba44ea15bf3e51/" rel="bookmark">
			深入浅出RabbitMQ：顺序消费、死信队列和延时队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小❤，一个漂泊江湖多年的 985 非科班程序员，曾混迹于国企、互联网大厂和创业公司的后台开发攻城狮。
1. 引言 上篇文章（应对流量高峰的利器——消息中间件）中，我们已经介绍了消息中间件的用途，主要用作：解耦、削峰、异步通信、应用解耦，并介绍了业界常用的几种消息中间件，优劣对比和使用场景。
在今天的文章中，我们来聊一聊 RabbitMQ，这是小 ❤ 在工作中用的最早的消息中间件，主要用于大量数据的异步消费。
2. RabbitMQ 2.1 核心组件 RabbitMQ 是一个开源的消息中间件，它实现了高级消息队列协议（AMQP），同时提供了各种重要组件来支持消息的生产、传输和消费。
Producer（生产者）： 生产者是消息的发送方，负责将消息发布到 RabbitMQ 服务器。消息可以包含任何内容，例如任务、日志、通知等。
Channel（信道）：消息推送与接收时使用的通道。
Exchange（交换机）： 交换机是消息的中转站，它接收来自生产者的消息并将其路由到一个或多个队列。不同类型的交换机，如 fanout，direct，topic，headers，支持不同的路由规则。
Queue（队列）： 队列是消息的缓冲区，消息在发送到消费者之前存储在队列中，消费者从队列中获取消息并进行处理。
Consumer（消费者）： 消费者是消息的接收方，它从队列中获取消息并进行处理。消费者可以是多个，它们可以在不同的应用程序或服务器上运行。
2.2 工作流程 RabbitMQ 的工作方式是基于生产者、交换机和队列之间的协作。这是一个简单的消息传递过程：
将队列与交换机绑定（Binding）起来，定义了消息的路由规则；
生产者将消息发布到交换机，交换机根据绑定规则将消息路由到一个或多个队列；
消费者从队列中获取消息并进行处理。
这种模型具有高度的灵活性，可以轻松处理大量消息，同时确保消息的可靠传递。
2.3 特性 说到消息中间件，很多人首先想到的就是 Kafka，但 RabbitMQ 也是许多金融或互联网公司构建可靠、可伸缩和高性能系统的首选。
这是为什么呢？
主要得从 RabbitMQ 的特性说起，主要有二：一个是功能强大，另一个是可靠性！
RabbitMQ 注重消息的可靠性和灵活性，适合任务排队和消息传递。而 Kafka 是分布式流式平台，注重日志存储和数据分发。
顺序消费也是可靠性的一种，RabbitMQ 可以使用单一队列或多个单一队列来确保顺序消费。
除此之外，RabbitMQ 还提供持久性队列和消息，以确保消息在 RabbitMQ 服务器宕机后不会丢失。另外，生产者可以使用发布确认机制来确认消息是否被接收。
RabbitMQ 相对 kafka 可靠性更好，数据更不易丢失，这对于一些数据敏感型的业务来说，显然更适合用前者。
并且，RabbitMQ 中原生支持死信队列，可以更好地处理未完成的业务消息，以及实现延时队列等特性，接下来我们一一介绍。
3. 保证顺序消费 RabbitMQ 提供了多个队列模型来保证消息的顺序消费。这对于某些应用程序非常重要，例如处理订单、支付和库存管理。
消息错乱消费的场景 如上图所示，有三条业务消息分别是删除、增加和修改操作，但是 Consumer 没有按顺序消费，最终存储的顺序是增加、修改和删除，就会发生数据错乱。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a733ccd53f35854e4ba44ea15bf3e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d34e42695aa6fdf77c92f2f9cdf4691b/" rel="bookmark">
			flask文件夹列表前文修订版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上文：
https://blog.csdn.net/weixin_44517278/article/details/135228805
本文的代码和HTML模板已经修改了上文的问题，目前可以做到正常的上传，返回上层目录，下载
from flask import Flask, render_template, send_file, request, redirect, url_for import os app = Flask(__name__) @app.template_filter('basename') def basename_filter(value): return os.path.basename(value) @app.route('/') def index(): files, folder_names, folder_name = getfile() return render_template('index.html', files=files, folder_names=folder_names, folder_name=folder_name) @app.route('/download/&lt;file_name&gt;') def download_file(file_name): file_name = os.path.normpath(file_name) # 替换windows环境下出现的双斜杠 \\ 为 / return send_file(file_name, as_attachment=True) @app.route('/show_folder/&lt;folder_name&gt;') def show_folder(folder_name): files, folder_names, folder_name = getfile(folder_name) return render_template('index.html', files=files, folder_names=folder_names, folder_name=folder_name) # 这里是返回上一级的目录 @app.route('/return_folder/&lt;folder_name&gt;') def return_folder(folder_name): refolder = folder_name # 抓完全体的路径 full_path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d34e42695aa6fdf77c92f2f9cdf4691b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf71720d7d5d2c478e6ddd287e130efd/" rel="bookmark">
			【线性代数】通过矩阵乘法得到的线性方程组和原来的线性方程组同解吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过矩阵乘法得到的线性方程组和原来的线性方程组同解吗？ 如果你进行的矩阵乘法涉及一个线性方程组 Ax = b，并且你乘以一个可逆矩阵 M，且产生新的方程组 M(Ax) = Mb，那么这两个系统是等价的；它们具有相同的解集。这是因为可逆矩阵的乘法可以视为一个可逆的线性变换，不会改变方程解的存在性或唯一性。
换句话说，如果你将原始系数矩阵 A 通过左乘以一个可逆矩阵 M 来转换成 MA，且同样将常数项向量 b 转化为 Mb，那么新的线性方程组 MAx = Mb 与原始的 Ax = b 同解，因为你可以通过乘以 M 的逆矩阵 M⁻¹ 来恢复原始的方程组。
也就是说，如果 M 是可逆的，那么两个方程组是等价的，解 x 是不变的。不过值得注意的是，解不会变，但是方程组的表现形式（系数矩阵）会变。
如果 M 不是可逆的，或者说是奇异的，那么矩阵乘法会改变方程组的解集。在实践中，我们通常寻找可逆的变换，以保持方程组的解不变。总的来说，在应用矩阵乘法和其他类型的变换时，理解矩阵操作如何影响线性方程组的解是非常重要的。
二、矩阵与表示线性方程组的增广矩阵相乘得到的增广矩阵表示的线性方程组，与最初的线性方程组同解吗？ 矩阵与代表线性方程组的增广矩阵相乘得到的增广矩阵表示的线性方程组的解是否相同依赖于所用的矩阵是不是可逆的。
如果你使用一个可逆矩阵 P 与线性方程组 Ax = b 的增广矩阵 [A | b] 相乘，即计算 PAx = Pb，且 P 为方程组系数矩阵 A 同阶的可逆矩阵，那么新的增广矩阵所表示的线性方程组将与原始的线性方程组具有相同的解集。这是因为左乘一个可逆矩阵相当于在原有方程上应用了一个可逆的行变换。
可逆的行变换包括：
1. 交换两行（对应于乘以一个置换矩阵）。
2. 用非零常数乘以一行（对应于乘以一个对角矩阵，且对角线上只有一个元素不为1）。
3. 将一行的非零倍加到另一行上（对应于乘以一个特殊形式的上（下）三角矩阵）。
行变换不改变方程组的解。因此，通过这样的变换得到的新系数矩阵 PA 和新的常数项 Pb 组成的新的增广矩阵所代表的线性方程组与原方程组是等价的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf71720d7d5d2c478e6ddd287e130efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8fd5401b83ac4123354bfae949e690/" rel="bookmark">
			【JS】实现一个倒计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一： function countDown(time) { var nowTime = +new Date();//返回的是当前时间的总毫秒数 var inputTime = + new Date(time); //返回的是用户输入时间总的毫秒数 var times = (inputTime - nowTime) / 1000; //times是剩余时间的总数 var d = parseInt(times / 60 / 60 / 24); //计算天数 var h = parseInt(times / 60 / 60 % 24);//计算小时 var m = parseInt(times / 60 % 60);//计算分数 var s = parseInt(times % 60);//计算秒数 return d + '天' + h + '时' + m + '分' + s + '秒'; } document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8fd5401b83ac4123354bfae949e690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3a578cf4e518e2a918a01ca7982363/" rel="bookmark">
			【JS】快速实现一个猜奖游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 随机产生一个1~10的整数 function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } // console.log(getRandom(1,10)); //猜奖游戏 /* var random = getRandom(1, 50); while (true) { var num = prompt('你来猜？输入1~10之间的一个数字'); if (num &gt; random) { alert('你猜大了'); } else if (num &lt; random) { alert('你猜小了'); }else{ alert('帅气，回答正确！') break; } } console.log(random); */ var random = getRandom(1, 50); for (var i = 1; i &lt;= 3; i++) { var num = prompt('你来猜？输入1~10之间的一个数字'); if (Boolean(parseInt(num)) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd3a578cf4e518e2a918a01ca7982363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf341f6d0b6e5aae485949cbc056372/" rel="bookmark">
			Ubuntu安装MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu（在线版） 更新软件源
sudo apt-get update 添加MongoDB的官方存储库
注：本文章安装MongoDB-7.0。
wget -qO - https://www.mongodb.org/static/pgp/server-7.0.asc | sudo apt-key add - 将地址添加到系统的软件包源列表中
echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu $(lsb_release -cs)/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list 更新软件源
sudo apt-get update 安装MongoDB
sudo apt install mongodb-org 启动服务
systemctl start mongod 查看MongoDB状态
systemctl status mongod 看到activate即启动成功
进入Mongo-Shell
mongosh 测试MongoDB
show dbs # 展示数据库 无报错则输出数据库名
Ubuntu（离线版） 进入下载链接选择MongoDB版本下载
https://www.mongodb.com/try/download/community
注：本文章下载mongodb-linux-x86_64-ubuntu2004-7.0.4.tgz 解压文件到指定目录
tar -xvf mongodb-linux-x86_64-ubuntu2004-7.0.4.tgz -C /usr/local 进入解压后的目录
cd /usr/local/mongodb-linux-x86_64-ubuntu2004-7.0.4 查看版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acf341f6d0b6e5aae485949cbc056372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a51b7ced85848acaf79d0c3fa89bbe/" rel="bookmark">
			Python地理数据机器学习数学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地理数据 地理数据是存储在地理信息系统 (GIS) 中的位置信息。通过查看具有地理成分的数据，我们可以通过不同的视角来看待它。
用地理数据解决位置问题需要空间思维。让我们深入了解地理数据的类型、主题和来源。
类型 地理数据有不同类型，每种类型在使用方式上都有其独特的价值。
无论数据来自政府、私人来源还是开放数据，了解数据的类型、数据的来源、数据的收集方式以及数据的用途都很重要。
矢量文件：矢量数据由顶点和路径组成。矢量数据的三种基本类型是点、线和多边形（面）。每个点、线和多边形都有一个空间参考系，例如纬度和经度。首先，向量点只是 XY 坐标。其次，矢量线以特定顺序将每个点或顶点与路径连接起来。最后，多边形连接一组顶点。但它包围了第一个和最后一个顶点，创建了一个多边形区域。光栅文件：栅格数据由像素或网格单元组成。通常，它们是方形的并且间隔规则。但光栅也可以是矩形的。栅格将值与每个像素相关联。连续栅格具有逐渐变化的值，例如海拔或温度。但离散栅格将每个像素设置为特定类别。例如，我们将土地覆盖类别表示为一组值。地理数据库：地理数据库的目的是存储矢量和栅格。数据库将地理数据存储为一组结构化的数据/信息。例如，Esri 地理数据库、地理包和 SpatiaLite 是最常见的地理数据库类型。我们使用地理数据库，因为这是一种将所有数据放入单个容器中的方法。在这个容器中，我们可以构建网络、创建马赛克、进行版本控制并管理复杂的空间关系，从而实现地理数据的全面分析和表示。网页文件：例如，GeoJSON、GeoRSS 和 Web 地图服务 (WMS) 专门用于通过互联网提供和显示地理特征。此外，Esri 的 ArcGIS Online 等在线平台允许组织在云中构建数据仓库。多时相：多时态数据将时间成分附加到信息上。但多时相地理数据不仅具有时间成分，还具有地理成分。例如，天气和气候数据跟踪温度和气象信息在地理背景下如何随时间变化。多时相地理数据的其他示例包括人口趋势、土地利用模式和雷击。 Python处理地理数据 读取形状文件 首先，我们将导入 geopandas 库，然后使用变量“world_data”读取我们的 shapefile。 Geopandas 可以使用以下命令读取几乎任何基于矢量的空间数据格式，包括 ESRI shapefile、GeoJSON 文件等：
import geopandas as gpd # Reading the world shapefile world_data = gpd.read_file(r'world.shp') world_data 绘图 如果您想检查正在使用的数据类型，请转到控制台并输入“type(world_data)”，它会告诉您这不是 pandas 数据，而是 geopandas 地理数据。接下来，我们将使用plot()方法绘制这些GeoDataFrame。
import geopandas as gpd # Reading the world shapefile world_data = gpd.read_file(r'world.shp') world_data.plot() 选择列 如果我们看到“world_data”GeoDataFrame 显示了许多列（Geoseries），您可以通过以下方式选择特定的 Geoseries：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a51b7ced85848acaf79d0c3fa89bbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa634ca927d014c0247573d9ddea269/" rel="bookmark">
			MySQL8 一键部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash
### 定义变量
mysql_download_url=https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz
mysql_package_name=mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz
mysql_dec_name=mysql-8.0.33-linux-glibc2.12-x86_64
mysql_download_dir="/usr/local/src"
mysql_base_dir="/usr/local/mysql"
mysql_data_dir="/data/mysql"
mysql_root_password=!@#123QAz
ck_ok()
{
if [ $? -ne 0 ]
then echo "$1 error."
exit 1
fi
}
dependon_install()
{
if which yum &gt;/dev/null 2&gt;&amp;1
then
for pkg in "$@"
do
if ! rpm -q ${pkg} &gt;/dev/null 2&gt;&amp;1
then
sudo yum install -y ${pkg}
else
echo "${pkg}已安装"
fi
done
fi
if which apt &gt;/dev/mull 2&gt;&amp;1
then
for pkg in "$@"
do
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa634ca927d014c0247573d9ddea269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c082801ce7f89acefbddbaed6193bd8/" rel="bookmark">
			力扣热题100道-滑动窗口篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滑动窗口 3.无重复字符的最长字串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: s = "abcabcbb" 输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2:
输入: s = "bbbbb" 输出: 1 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3:
输入: s = "pwwkew" 输出: 3 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 /* 思路：滑动窗口 用一个哈希表，i,j作为滑动窗口，当hash[i]==2时候，j++,直到去除重复的为止 */ class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map&lt;char,int&gt;hash; int res=0; for(int i=0,j=0;i&lt;s.size();i++){ hash[s[i]]++; while(hash[s[i]]&gt;1) hash[s[j++]]--; res = max(res,i-j+1); } return res; } }; 438.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c082801ce7f89acefbddbaed6193bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf5b657e6a451d549eda8938bf15803/" rel="bookmark">
			Java：List转Map （用stream实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：JDK1.8及其以上，才支持下面案例 //实体类 public class Student { private String no; //学号 private String name;	//姓名 private Integer age; //年龄 //构造方法忽略 //set、get 方法忽略 } public class Teacher{ private String no; //教师号 private String name; //姓名 private Integer age; //年龄 } 一、List&lt;Object&gt; 转 Map&lt;String, String&gt; //注意事项 //在使用java.util.stream.Collectors 类的 toMap()方法转为 Map集合时，一定要注意当Map的value为null时会抛空指针异常！！！（如：下面示例的getName不可为空！！！） //声明一个List集合 List&lt;Student&gt; list = new ArrayList(); list.add(new Student("1001", "小A", 15)); list.add(new Student("1001", "小B", 20));//学号重复（下面特殊处理） list.add(new Student("1002", "小C", 15)); list.add(new Student("1003", "小D", 30)); //将list转map 【key为1个属性,value为1个属性】 （map的键重复不会报错，下面已经处理）（注意：getName不可为空！！！） Map&lt;String, String&gt; map = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cf5b657e6a451d549eda8938bf15803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea311339419f133df32efbe81e14dcd/" rel="bookmark">
			matinal：SAP SD模块中POD功能使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀欢迎来到本文🚀
🍉个人简介：matinal，目前职业是IT行业，一个正在慢慢前行的普通人。
🏀系列专栏：涵盖SAP各模块，Python，Excel，人工智能等
💡 其他专栏：一些平时学习的技术，感兴趣的小伙伴可以看看。
🍔公众号：matinal
🎁希望各位→点赞👍 + 收藏⭐️ + 留言📝 ​
⛱️万物从心起，心动则万物动🏄‍♂️
前言：介绍一个不太常规的SAP功能。
🦙（工作遇到傻逼，千万要远离。道路千万条，远离傻逼第一条）
介绍一个不太常规的SAP功能。POD
在某些行业，销售发货给客户，中途可能有损耗。发货数量与客户收获数量不等。例如液体或散装物等等。
这样的话，开票数量要根据客户确认数量而不是发货数量，而交货成本还是根据交货数量来算。
VLPOD 交货证明
注释：
POD也不能做差异的冲销，这个与冲销PGI是不一样的，冲销PGI后是会形成库存成品，而POD则是用于按客户确认数开票，即库存我们还是出的是deilvery的quantity,但做了POD后，invoice就会按POD确认的数量，可以多也可以少，去开发票.即成本还是不变，但收入增加或减少
怎么样，在了解SD模块中POD功能使用方法后，有何感想？
如果本文对大家有所帮助的话，还望各位能给我点赞、收藏并评论一下，感谢各位💕！！！ 另如果大家有什么疑问或者建议的话，欢迎评论区留言。更多精彩内容-&gt;在这里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277adde65016a45fb8a78e4234981833/" rel="bookmark">
			写一个随机点名的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取方式：
链接：https://pan.baidu.com/s/1fdCJ_3IYUl7v7x6I1zAWgg
提取码：1234
这里面用到JS当中的数组，random以及window.setInterval（）回调函数来进行实现的.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90fbbc75022d944996ea47f4459bd03e/" rel="bookmark">
			Enhance PDF Document Reviews Crack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Enhance PDF Document Reviews Crack Document Solutions for PDF v7 gains the ability to precisely point out missing content or required changes to PDF files.
Document Solutions for PDF (formerly GrapeCity Documents for PDF), is a powerful and comprehensive C# library that empowers developers to create, manipulate, and manage PDF documents with ease. This versatile product enables developers to generate PDFs from scratch, modify existing documents, import and export data, and incorporate advanced features like AcroForms and annotations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90fbbc75022d944996ea47f4459bd03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5073b5a8e99879221662f5831f8f824/" rel="bookmark">
			Linux实验一：熟悉Linux基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux实验一：熟悉Linux基本命令
【实验目的】
‏(1)熟悉常用的文件和目录类命令。
‏(2)熟悉常用的进程管理类命令。
‏【实验要求】
本实验的主要任务是在Linux终端窗口中练习已经学过的各种命令，熟练掌握常用命令的用法。清大家按照以下步骤完成本次实验。
‏(1)以普通用户登录系统，登录后，打开一个终端窗口。
‏(2)查看当前工作目录; 在当前目录中新建、并切换到tmp子目录。
‏(3)在tmp目录中新建文件file1和目录dir1; 查看tmp目录中有哪些内容，显示详细信息并根据输出信息判断哪些是普涌文件，哪些是目录。
‏(4)新建文件file2和file3; 将file2移动到dir1中，移动后的文件重命名为file2.bak; 将file3复制到dir1中，进入dir1目录并查看其中的内容。
‏(5)退回到tmp目录; 删除文件file1和目录dir1。
‏(6)回到步骤(1)最初的目录，查看tmp目录中的内容，并把输出重定向到file3中。
‏(7)查看当前用户的进程。
‏(8)在后台运行cat命令，然后结束这个进程。
‏(9)撰写【实验小结】：对本实验的知识点做个总结
‏(10)撰写【实验感想】：通过本实验，体会到了Linux操作系统的日常工作模式？可以与你熟悉的操作系统做个简单对比，也可描述一下自己初次接触Linux的感想。
[实验内容]
‏(1)以普通用户登录系统，登录后，打开一个终端窗口。
‏(2)查看当前工作目录; 在当前目录中新建、并切换到tmp子目录。
‏(3)在tmp目录中新建文件file1和目录dir1; 查看tmp目录中有哪些内容，显示详细信息并根据输出信息判断哪些是普涌文件，哪些是目录。
file1是普通文件，dir1是目录
‏(4)新建文件file2和file3; 将file2移动到dir1中，移动后的文件重命名为file2.bak; 将file3复制到dir1中，进入dir1目录并查看其中的内容。
‏(5)退回到tmp目录; 删除文件file1和目录dir1。
‏(6)回到步骤(1)最初的目录，查看tmp目录中的内容，并把输出重定向到file3中。
‏(7)查看当前用户的进程。
‎
‏(8)在后台运行cat命令，然后结束这个进程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85648bac4fe6a4343671c14d151cde47/" rel="bookmark">
			打地鼠游戏来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要利用js鼠标点击事件和window.setInterval（）回调函数来进行实现的.
源码获取方式：链接：https://pan.baidu.com/s/1eW9qvX3zFH9qlH82-I4yOA
提取码：1233
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f5c3d9309fbceeebff9aca08905fac/" rel="bookmark">
			各个版本的gradle下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gradle-6.5-bin.zip
链接：https://pan.baidu.com/s/1HZlluvM8EalUgPs-5JKPgA?pwd=qmzb 提取码：qmzb
gradle-5.6.4-all.zip
链接：https://pan.baidu.com/s/1hpQsCRMRfOSNYItSQONapQ?pwd=eq8v 提取码：eq8v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a146c3aaf5e3f515f791ea522f97eb7c/" rel="bookmark">
			产品经理学习-策略产品指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
数据指标概述
通用指标介绍
Web端常用指标
移动端常用指标
如何选择一个合适的数据指标
数据指标概述 指标是衡量目标的一个参数，指一项活动中预期达到的指标、目标等，一般用数据表示，因此又称为数据指标；
需求量化
美团天天一元起活动，协同美团外卖APP需求
新客量：活动引入的新客数；
订单量：活动引入的订单数
价值可视化
双十一活动，阿里巴巴提供可视化看板
产品数据可视化看板（流量、用户量、订单量）
迭代依据
优化搜索排序策略是为了提升搜索结果页点击转化率，点击转化率越高越表妹流量分发效率越高；
优化页面展示为了提升用户在应用内的停留时间
通用指标介绍 注册用户/首次登录用户数
表明的产品市场价值，占有率的一个指标
活跃用户数
指在一定的时间范围内，登录网站或者启动APP的独立用户之和，独立用户是指按照ip地址/设备号去重后的用户
DAU(日活跃用户)：以某个自然日来统计，比如一个用户在一日之内无论使用app多少次，DAU都是1
MAU(日活跃用户)：以某个自然月来统计，比如一个用户在一月之内无论使用app多少次，MAU都是1
相比注册用户，活跃用户可以真实表明当前业务的发展现状，也是产品最有价值的群体
新增用户：历史上第一次登录网站或者启动APP的用户，需要按照ip地址或者设备号进行去重。
留存用户：规定时间T1内的新增用户中，在经过一段时间T2后，仍然使用程序的用户
页面平均停留时长：指用户在应用内页面的停留时间长度。一方面是衡量产品对用户的吸引力，一方面也是衡量当前流程的效率。
Web页面平均停留时长=全站停留时间总和/全站的页面浏览量
访问web某网站总共访问了4个一维码，用时20s；则web页面平均停留时长为5s
APP页面平均停留时长=Average（离开页面时间-进入页面时间）
页面访问深度：指用户在一定的时间范围内，在应用内访问页面的数量，无需去重
Web页面平均访问深度=浏览页面数量/访问次数
APP页面访问呢深度是指用户在一次启动APP过程中所到达的页面累计数量视为用户的访问深度；例如某个用户一次访问app，访问了12个页面，则该用户的访问呢深度为12
Web端常用指标 页面浏览量(PV) 指页面被浏览的次数总和，指网站或页面包含的所有页面被浏览的总次数，无需去重，求和累加
独立访问量(UV) 依据浏览器Cookie标识访客，对所有访客按统计区间的排重处理后的数量，UV统计的是形式上的单个用户，并不是真正意义的自然用户，比如同一个用户在不同地方的浏览器访问一个网站，UV是2。
访问次数（访次） 依据浏览器Cookie标识回话，对所有会话按统计区间的排重处理后的数量
移动端常用指标 曝光 指页面的某些模板、区域被用户有效浏览；
曝光PV：曝光次数、曝光累加
曝光UV：曝光人次，曝光按照唯一标识去重后叠加
点击转化率CTR 指用户从一个场景通过点击进入另一个场景的比例大小
CTR=点击次数/曝光 （从PV的角度统计）
UCTR=点击人数/曝光人数（从UV角度统计）
订单转化率CVR 曝光订单转化率，是指用户访问某一场景后下单的比例
CVR=订单总数/曝光次数（从PV的角度统计）
UCVR=下单人数/曝光人数（从UV的角度统计）
RPM 千次展示收益，指页面模块展示1000次带来的收益
RPM=引入订单金额/曝光PV*1000
RPM通常用于衡量策略产品模块整体的收益效果
UV价值 UV价值是用来衡量每一个独立访客能够带来的价值（收益）
计算公式：UV=引入订单金额/曝光UV
如何选择一个合适的数据指标 选择合适的数据指标，首先要确定目的是什么，在不同的产品业务发展周期，目标是不同的
业务发展初始以流量类指标为主，DAU、MAU和曝光PV/UV；业务发展期中以流量转化为主CTR；业务发展成熟期以订单、金额指标为主RPM、CVR、UV价值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6912528e0348be77ee7fe49f88eb560c/" rel="bookmark">
			【数据结构】树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.二叉树的基本概念和性质： 1.二叉树的递归定义： 二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成
2.二叉树的特点： （1）每个结点最多只有两棵子树，即不存在结点度大于2的结点
（2）子树有左右之分，不能颠倒。
3.满二叉树： 深度为k，且有个结点的二叉树。
（1）每一层上结点数都达到最大。
（2）度为1的结点数
4.完全二叉树： 深度为k，结点数为n的二叉树，当且仅当每个结点的编号都与相同深度的满二叉树中从1到n的结点一一对应时，称为完全二叉树。
（1）完全二叉树的任意结点，左子树的高度-右子树的高度=0或1
5.二叉树的性质： 1）在二叉树的第i层，至多有个结点。
2）深度为k的二叉树上至多含有个结点。
3) 证明如下：
二叉树中全部结点数
除根结点外，每个结点必有一个直接前驱，即一个分支
（1度结点必有1个直接后继，2度结点必有2个直接后继）
即：
叶子数=2度结点数+1
4）具有n个结点的完全二叉树的深度为
5)
对有n个结点的完全二叉树的结点按层序编号，则对于任一结点i，有：
如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是i/2如果2i&gt;n，则结点i无左孩子；如果，则其左孩子是2i如果2i+1&gt;n，则结点i无右孩子；如果，则其右孩子是2i+1 例题：
设一棵完全二叉树具有1000个结点，则它有489个叶子结点，有488个度为2的结点，有1个结点只有非空左子树，有0个结点只有非空右子树。
二.二叉树、树以及森林的存储结构 1.二叉树的顺序存储结构 用一组地址连续的存储单元，以层序顺序存放二叉树的数据元素，结点的相对位置蕴含着结点之间的关系。
问：顺序存储后能否复原成唯一对应的二叉树形状？
若是完全二叉树则可以完全复原，下标值为i的双亲，左孩子为2i，右孩子为2i+1。
而对于一般的二叉树的存储，将其先补成完全二叉树，然后按照完全二叉树的顺序存储方式进行存储，而新补上的结点只占位置，不存放数据元素。
对于一般二叉树的顺序存储，如果是斜树，则会浪费很多的存储空间，而且插入删除不便。
2.二叉树的链式存储结构 有一个指向根的指针root
二叉链表：2个链分别存放左孩子和右孩子。
三叉链表：2个链分别存放左孩子和右孩子另外一个指向双亲。
线索链表：用空链域存放前驱或后继。
2.1 二叉链表： 结点结构：
lchilddatarchild typedef struct BiTreeNode{ DataType data; struct BiTreeNode *lchild,*rchild; }BiTreeNode,*BiTree; 2.2 三叉链表： 结点结构：
parentlchilddatarchild typedef struct BiTreeNode{ DataType data; struct BiTreeNode *lchild,*rchild,*parent; }BiTreeNode,*BiTree; 3.树和森林的存储结构 3.1 树的双亲表示法 对于一个结点来说，双亲是一定的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6912528e0348be77ee7fe49f88eb560c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730592cd1978da53548ad014454ab97d/" rel="bookmark">
			第六章 Linux 磁盘管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六章 Linux 磁盘管理 1、磁盘分区、格式化、文件系统、文件系统类型、挂载、挂载点 的概念1）对该磁盘进行分区（分割）2）对某个分区进行格式化3）挂载4）一块硬盘需要经过哪些步骤才可以被我们 Linux 操作系统用来实际的存取数据呢？ 2、查看文件系统使用情况（比如容量空间的使用情况）4、列出所有可用块设备的信息（即列出系统上所有存储5、磁盘分区1）通过 MSDOS (MBR) 分区表 方式分区2）GPT 分区表（GUID partition table） 方式分区3）partprobe [-s]4）parted 命令 6、格式化（写入文件系统）1）Linux 下常见的文件系统类型：2）格式化操作3）查看文件系统信息 7、挂载/卸载文件系统1）使用 mount 进行手动挂载 1、磁盘分区、格式化、文件系统、文件系统类型、挂载、挂载点 的概念 如果我们想在系统中增加一块硬盘用于数据存取，那么大概需要以下步骤：
1）对该磁盘进行分区（分割） 目的，一是为了分割硬盘空间方便管理，更重要的是让各个分区都基本独立开来，这样如果某个区发生问题，至少不会直接影响到其他分区。
举例：如果把一块磁盘比喻成一大块地，那么对磁盘进行分区就相当于是把地按照需要划分成几块地或者几个区域。划分出来的某块地或者某个区域我们一般称作“某个分区”
2）对某个分区进行格式化 各种操作系统都必须按照一定的方式来管理数据，对分区进行格式化的目的是为了在分区里写入文件系统，这样才能被操作系统使用。
举例：我们把向磁盘里存数据比喻成现实生活中向“银行保管箱”里存物贵重品
地刚刚你已经分好了，可是这个地你能直接用来存物品吗？当然不行，你得在分好的某块地上建好大厦以及在大厦里构建保管柜，这样才能够用于存储物品。
■ 磁盘分区也是同样的道理，要想能够被操作系统用于实际的存储数据，还得在磁盘分区里写入文件系统，也就是所谓的“格式化”，即操作系统需要按照特定的规划去建设开发这个分区，开发好后才能被操作系统用作数据存储。
■ 问一下：向分区写入文件系统，这个文件系统本身会占用磁盘空间吗？
■ 在地上建设大厦和构建保管柜，建设大厦时肯定可以有不同的结构供选择吧？保管柜也有不同的品牌供选择吧？同样的，文件系统也有不同的类型供选择，比如我们 windows 下常见的 NTFS、FAT32 等，它们就是传说中的文件系统类型，而 Linux 下常见的文件系统类型有 EXT*（比如 EXT4）、xfs 等等，具体我们后面讲。
■ 一个分区被格式化（写入文件系统，不管是什么类型的文件系统）后，我们就可以称作它是一个“文件系统”
3）挂载 这个就是把某个文件系统用管子接到某个目录上，对应的目录就称作挂载点，参考第一回！
4）一块硬盘需要经过哪些步骤才可以被我们 Linux 操作系统用来实际的存取数据呢？ 分区（分割） -&gt; 对（某个）分区进行格式化（写入文件系统） -&gt; 挂载
所以比较讲究的说法是：我们称呼一个可被挂载的数据为一个文件系统，而不是叫一个分区
请问：第一步 分区（分割） 是必须的吗？一整块磁盘可不可以不进行分区就直接格式化，然后挂载使用
2、查看文件系统使用情况（比如容量空间的使用情况） df [-ihT] [FILE...] 注： FILE 可以直接指定文件系统（路径），则会打印出该文件系统的磁盘空间使用情况； FILE 也可以指定为非文件系统文件的路径则会输出该文件相关的文件系统的磁盘空间使用情况； 选项： -i：以 inode 数量显示 -h：以较易阅读的单位来显示容量 -T：显示出分区的文件系统格式名称 3、查看目录所占容量（包括其后代文件所占） du [-ahcs] FILE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730592cd1978da53548ad014454ab97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40aa210fdc6752568d91cc935856f476/" rel="bookmark">
			普中STM32-PZ6806L开发板(使用过程中的问题收集)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil使用ST-Link 报错 Internal command error
描述: 在某一次使用过程中，前面都是正常使用, Keil在烧录时报错Internal command error, 试了网上的诸多方式, 例如 升级固件;ST-Link Utility 清除;Keil升级到最新版本;甚至笔者板子的Micro头也换了，因为坏之前是可以正常烧录的之类的, 怀疑现在供电不足low power有影响;
… 诸多方式都无法解决, 最终抱着试一试的心态
解决方式如下，设置Serial Wire的调试方式，重新生成代码, 就可以了, 经验积累吧， 之前用的板子并没有设置也并不会出现这种情况…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2208a8b2299feab025fe8251d9d64897/" rel="bookmark">
			双向链表的实现及头尾插入删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双链表的增删查改 一.双向链表的初始化二.创建返回链表的头结点三.双向链表销毁四. 双向链表打印五.双向链表尾插六. 双向链表尾删七. 双向链表头插八.双向链表头删九.双向链表的查找十.双向链表在pos的前面进行插入十一. 双向链表删除pos位置的节点 一.双向链表的初始化 ListNode* LTInit() { ListNode* Phead = ListCreate(-1); Phead-&gt;next = Phead; Phead-&gt;prev = Phead; return Phead; } 二.创建返回链表的头结点 ListNode* ListCreate(LTDataType x) { ListNode* newnode = (ListNode*)malloc(sizeof(ListNode)); if (newnode == NULL) { perror("malloc fial"); exit(-1); } newnode-&gt;data = x; newnode-&gt;next = NULL; newnode-&gt;prev = NULL; } 三.双向链表销毁 void ListDestory(ListNode* pHead) { assert(pHead); ListNode* cur = pHead-&gt;next; while (cur != NULL) { ListNode* next = cur-&gt;next; free(cur); cur = next; } free(pHead); //pHead = NULL; } 四.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2208a8b2299feab025fe8251d9d64897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39200a39e5e95fb44ba64286813f6693/" rel="bookmark">
			ubuntu设置服务器时区为东八区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.运行tzselect
2.复制文件到/etc目录下
3.再次查看时间date -R，已经修改为北京时间
今天测试时，发现时间不对，查了一下时区：
date -R
结果时区是：+0000
我需要的是东八区，这儿显示不是，所以需要设置一个时区
1.运行tzselect root@ubuntu:/# tzselect
在这里我们选择亚洲 Asia，确认之后选择中国（China)，最后选择北京(Beijing)
2.复制文件到/etc目录下 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
3.再次查看时间date -R，已经修改为北京时间 timedatectl set-timezone Asia/Shanghai
ntpdate time.windows.com
date
改时间
修改时间
sudo date -s MM/DD/YY //修改日期
sudo date -s hh:mm:ss //修改时间
在修改时间以后，修改硬件CMOS的时间
sudo hwclock --systohc //非常重要，如果没有这一步的话，后面时间还是不准
date系统时间和hwclock硬件时间不一致
这时硬件时钟应该存储 UTC 时间，然后使用hwclock命令来使系统时间和硬件时间同步
hwclock -ru
hwclock -su
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d704da8b7c7ab11e98653347697356/" rel="bookmark">
			Hive详解、配置、数据结构、Hive CLI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hive 认识 1. Hive 应用 问题：公司的经营状况？ 主题一：财务 现金流 指标1.1：净现金流入/流出量 指标1.2：现金转换周期 预算执行状况 指标2.1：预算内成本控制 指标2.2：预算与实际支出的差异 主题二：产品 指标1：产品销售量 指标2：产品利润率 指标3：新产品开发周期 主题三：客户 老客户的流失率 指标1.1：重复购买率 指标1.2：客户满意度调查结果 新客户的留存率、转化率 指标2.1：新客户留存率 指标2.2：潜在客户到实际客户的转化率 主题四：员工 指标1：员工满意度 指标2：员工流失率 指标3：员工绩效评估 主题五：资产 指标1：资产负债率 指标2：固定资产周转率 指标3：存货周转率 问题 =&gt; 主题(拆分) =&gt; 指标 =&gt; HQL
2. Hive 定义 基于元数据和表数据对数据进行结构化治理的机制(数仓)
"基于元数据"的核心：获取Hive MetaStore指定Mysql存储的元数据并根据其解析HQL生成执行计划
"基于表数据"的核心：获取表数据并通过执行计划进行数据处理和结果存储和加载。
3. Hive 具体设计 关键组件 UI：客户端提交查询。
Compiler：借助MetaStore获取存储在Mysql中的元数据信息解析查询块或表达式，生成执行计划。
Execution engine：管理计划的不同阶段之间的依赖关系(协调各操作的执行顺序)，并在适当的大数据组件上执行这些阶段。
关键步骤详解 6.1步：
1.将执行计划提交到Hadoop作为一个MapReduce作业.
2.RM将作业分解为多个任务，并且分配给不同的集群节点去执行。
3.启动Map任务(读取输入数据，处理，输出结果)
4.启动Reduce任务(可选)(读取Map|Shffle端输出，处理，输出结果) =&gt; 决定了是MapOnly引擎还是MapReduce引擎
6.2步：
完成了一个Job，将数据加载到Hive表上。
6.3步：
Hive与HDFS进行交互，包括读取数据文件以进行查询，或将查询结果写入到HDFS。
7,8,9步：
一旦执行引擎完成了查询任务，结果需要被传回UI
体现了将查询结果有执行引擎处理并通过Hive驱动程序返回给用户界面的过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12d704da8b7c7ab11e98653347697356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d665b281243f6e018e07137b6922bd4/" rel="bookmark">
			『精』CSS 小技巧之BEM规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		『精』CSS 小技巧之BEM规范 文章目录 『精』CSS 小技巧之BEM规范一、什么是BEM？二、BEM要怎么用？三、不用BEM会少个胳膊吗？💊四、Sass与BEM的结合🎈五、块与修饰符应放在一块👿参考资料💘推荐博文🍗 一、什么是BEM？ BEM风格规范指的是 Block、Element、Modifier 这三者的简称，这个规范将 CSS 拆分成块、元素、修饰符，根本作用是帮助开发者快速理解HTML与 CSS 之间的关系。那么通过使用 BEM 能获得到什么好处呢？我罗列了下面几点：
如果我们想制作一个组件的新样式，比如改个字体/背景色，可以很容易地看到有哪些样式项已经存在，只需要新增一个修饰符即可，甚至可能意识到一开始就不需要编写任何样式，有一个预先存在的修饰符可以满足我们的需求。得益于 CSS 命名语义化的好处，我们能够快速了解其 HTML 结构分布，一个元素依赖哪一个元素，在产品变更时快速更改其样式，并完全确信您的更改不会产生副作用。模块化的样式命名规则，能够最有效解决样式之间同名、继承、优先级等所带来的污染性问题，避免最后因为充斥着各种臃肿，而不敢触及修改遗留的各种未知样式，这其实给了开发人员一定的信心。团队配合成本的降低，样式可读性的提高能够让成员之间能够快速复用已有的样式规则，而不需要再去编写一套样式。 在没有接触 BEM 之前，也许你会对我这罗列的这一堆优点一头雾水，这很正常让我们接着往下看，在看完本文的剩余内容时也许回过头你就能恍然大悟。
需要注意的是 BEM 并非是官方的风格规范，它是由Yandex团队开发，程序员之间约定俗成的一种契约规范，受众范围十分广泛，许多知名开源 UI 框架将其使用，如 Elementui、vant、uView-ui。但随着 tailwind 这类 CSS 框架的强势入局，BEM使用也有减少的趋势，毕竟只有在手动编写CSS代码的时候才用的上，如新起之秀，号称最完整Vue UI套件的 primevue。
二、BEM要怎么用？ 要探究BEM怎么用，最简单的方法就是直接上手，让我们从编写一套有着丰富样式按钮组件开始，该组件包含最常见的颜色类型/大小切换功能。
可以看到属于 .btn 元素下的子项目，在命名时带上以父元素为头，__ 分割的命名，而按钮的不同状态颜色则通过基本样式名为头， -- 分割进行命名。以这样的命名方式，翻译过来就是基本样式名被称为块，__分割被称为元素，--分割则被称为修饰符。
&lt;article class="btn-demo"&gt; &lt;div class="btn btn--primary btn--large"&gt; &lt;span class="btn__icon"&gt;$&lt;/span&gt; &lt;span class="btn__text"&gt;按钮&lt;/span&gt; &lt;/div&gt; &lt;div class="btn btn--info"&gt; &lt;span class="btn__icon"&gt;$&lt;/span&gt; &lt;span class="btn__text"&gt;按钮&lt;/span&gt; &lt;/div&gt; &lt;div class="btn btn--mini"&gt; &lt;span class="btn__icon"&gt;$&lt;/span&gt; &lt;span class="btn__text"&gt;按钮&lt;/span&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d665b281243f6e018e07137b6922bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7aca9003a4fd56e7c4f397eb0f7773/" rel="bookmark">
			.NET 使用Camunda快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.工作流介绍 1. 什么是工作流 工作流（Workflow），是对工作流程及其各操作步骤之间业务规则的抽象、概括描述。
工作流将一套大的业务逻辑分解成业务逻辑段， 并统一控制这些业务逻辑段的执行条件，执行顺序以及相互通信，实现业务逻辑的分解和解耦。
做饭：
贷款审批：
2. 为什么要使用工作流 在企业日常的管理中，经常会有出差申请、加班申请、请假申请等流程。
如果用人工的方式管理这些流程，效率低，管理成本高。
因此为了提高效率，我们需要使用到工作流开发。
3. 使用工作流有什么好处 在工作流开发中，我们可以通过每一个流程定义清楚的看到业务的所有步骤，以及每一个流程实例运行到什么位置，参与者是谁；
能够节省更多的时间成本，提升企业信息化水平。
二. 工作流引擎 1. Camunda介绍 Camunda是一种工作流引擎，是由Java开发的一个纯Java库。
工作流引擎是用来开发工作流的框架。
市面上主流的工作流引擎有Activiti、Flowable、Camunda等。
ActivitiActiviti 由 Alfresco 公司开发，目前最高版本为 Activiti cloud 7.1.0。由于团队分歧 ，在Activiti6版本衍生出了Flowable。 FlowableFlowable是基于Activiti6衍生出来的版本，开发团队也是Activiti中分裂出来的，修复了Activiti6中的bug，并再此基础上实现的DMN、BPEL支持。 CamundaCamunda是基于Activiti5的，最新版本是Camunda7.17，开发团队也是从Activiti中分裂出来的，发展轨迹和Flowable相似。通过压力测试验证Camunda BPMN引擎性能和稳定性更好，功能完善；除了BPMN，Camunda还支持CMMN(案例管理)和DMN(决策自动化)。Camunda不仅带有引擎，还有很多强大的工具，用于建模、任务管理、监控和用户管理等。 Camunda BPM（业务流程管理）平台，用来管理，部署的流程定义、执行任务、策略等等。
下载安装一个Camunda平台，成功解压 Camunda 平台的发行版后，执行名为start.bat（对于 Windows 用户）或start.sh（对于 Unix 用户）的脚本。此脚本将启动应用程序服务器。
打开您的 Web 浏览器并导航到http://localhost:8080/以访问欢迎页面，Camunda的管理平台。
Camunda Modeler（用于编辑流程图及其他模型）平台，用来定义流程图，简单说就是一个画图工具。
下载 Modeler 后，只需将下载文件解压缩到您选择的文件夹中。
成功解压缩 zip 后，运行camunda-modeler.exe（对于 Windows 用户）、camunda-modeler.app（对于 Mac 用户）或camunda-modeler.sh（对于 Linux 用户）。 2. Camunda常用Api RepositoryService
该服务提供了管理和操控流程部署和流程定义的操作方法。
（1）查询流程引擎所知道的部署和流程定义。
（2）挂起、激活流程定义。挂起意味着不能进行下一步的操作，而激活则是反操作。
（3）获取各种资源，比如部署种包含的文件，或者引擎自动生成的流程图等。
RuntimeService
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7aca9003a4fd56e7c4f397eb0f7773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bead16d7db28c7cfce31e7fed4b62b7/" rel="bookmark">
			查看ios app运行日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文介绍了一款名为克魔助手的iOS应用日志查看工具，该工具可以方便地查看iPhone设备上应用和系统运行时的实时日志和奔溃日志。同时还提供了奔溃日志分析查看模块，可以对苹果奔溃日志进行符号化、格式化和分析，极大地简化了开发者的调试工作。
引言 在iOS应用开发过程中，调试日志和奔溃日志是开发者必不可少的工具。然而，使用Xcode Console等工具查看日志可能不够方便，而且处理奔溃日志也相当繁琐。克魔助手的出现为开发者带来了极大的便利，本文将详细介绍其功能和使用方法。 克魔助手会提供两种日志，一种是实时的，一种的是崩溃的。（由于崩溃日志的环境很麻烦，目前只展示实时日志操作步骤）
环境配置 电脑一台（台式和笔记本都OK）
iPhone 手机一台
下载克魔助手
下载爱思助手或者itunes驱动
实时日志 克魔助手提供了实时日志功能，能够在电脑上实时查看设备的日志信息。 下面是操作步骤：
1.先将 iPhone 通过数据线连接上电脑，iOS 手机上一定要信任这次连接
2.在电脑上打开克魔助手-实时日志。
3.因为你已经通过数据线连接了电脑和手机，所以此时在控制台的左侧工具栏里会显示你的设备，如果此时直接点击 开始日志那将输出的是此设备的所有日志，那么如果想要查看某一App的日志查看起来是非常繁琐的，那我就需要对App继续筛选过滤再输出。
4.选择需要查看iPhone里面的App（可以通过 command+ 空格，搜索应用），然后点击 开始日志，将会输出关于此App的所有日志
5.如果需要对App里面的关键字继续过滤处理，可关键字那直接输入后点击清空日志，再点击空白处即可过滤成功
6.当你过滤出来了错误信息后，你可以将这些错误日志存储起来，形成一个 errorlog 提交给到开发，点击 导出日志即可生成一个文件夹。
奔溃日志分析 克魔助手还提供了奔溃日志分析查看模块，可以方便地导出和查看iOS设备上的奔溃日志，并对其进行符号化、格式化和分析。 操作如下：
1.选择需要查看的奔溃日志。
2.点击“导出日志”，即可生成一个包含奔溃日志的文件夹，便于提交给开发团队进行分析。
PS：数据连接时，先将 iPhone 通过数据线连接上电脑，iOS 手机上一定要信任这次连接，（开启WiFi调试时，无需数据线）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c585659c9453d6f45b2cbf99736acfa0/" rel="bookmark">
			Arcgis根据经纬度匹配地级市，并将数据导出至excel(arcgis定义投影报错的解决办法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 先导入数据，依据X,Y导入（推荐为.csv格式的数据） 2. 在弹出的窗口添加文件，并标注经纬度数据，X字段为经度，Y字段为维度） 3. 右击此生成的事件，将事件数据导出（右击——数据——导出数据），并将导出的数据添加到图层中 4. 打开一个地级市的图层（可网上下载之后本地导入数据） 5. 进行定义投影。一般用China….2000 （工具箱\系统工具箱\Data Management Tools.tbx）
6. 点击地级市图层进行“点到面”的连接，并输出 在点击地级市图层，右击——连接和关联——连接
选择基于空间位置的另一图层数据，文件选择上面输出并添加的图层文件，进行“点到面”的连接，可依据新需求选择平均值，总和等属性，并将改图层输出shp文件
7. 将arcgis属性数据导出到excel： 1） 工具箱\系统工具箱\Conversion Tools.tbx\Excel\Excel 转表 2）用excel打开导出的图层文件中后缀为.dbf的数据（方便快捷，但是中文易乱码） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43160ef0d2d93a2bc0042147b327bf6b/" rel="bookmark">
			机器学习概述（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习概述 sklearn.datasets特征工程特征提取特征预处理特征降维 sklearn.datasets sklearn.datasets 模块用于获取较为经典的数据集。
sklearn.datasets.load_*() # 获取小规模数据集，直接从本地获取sklearn.datasets.fetch_*(data_home=None, subset=“train”, shuffle=True, random_state=42) # 获取大规模数据集，需要从网络上下载；data_home 表示用于存储数据集的路径，默认存储在 ~/scikit_learn_data/ 目录下；subset 表示要下载的数据集，可选 “train”、“test”、“all”sklearn.datasets.load_iris() # 从本地获取鸢尾花数据集
sklearn.datasets.fetch_20newsgroups(data_home=None) # 从网络上下载 20newsgroups 数据集的训练集 load_*() 和 fetch_*() 返回的数据类型为 sklearn.utils.Bunch，是一种字典格式。其中几个主要的键值对如下：
data: array([···])，特征数据数组，形如 (n_samples, n_features)target: array([···])，标签数据数组，形如 (n_samples,)feature_names: array([···])，特征名称target_names: array([···])，标签名称DESCR: str()，数据集描述 Bunch 类型可以通过 iris[‘data’] 或 iris.data 获取对应的值。
from sklearn.datasets import load_iris iris = load_iris() print(iris['data']) print(iris.data) 一个数据集通常会被划分为训练集和测试集，划分比例通常为 8:2 或 7:3，可以通过 sklearn.model_selection.train_test_split(arrays, *options) 进行划分。
x：数据集的特征值，可以以 ndarray、list 等类型结构传入y：数据集的标签值，可以以 ndarray、list 等类型结构传入test_size：测试集的大小，float，默认为 0.25train_size：训练集的大小，floatrandom_state：随机数种子，不同的种子会产生不同的随机采样结果，默认为 None返回训练集的特征数据、测试集的特征数据、训练集的标签数据、测试集的标签数据；传入的是 ndarray，返回的也是 ndarray；传入的是 list，返回的也是 list from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43160ef0d2d93a2bc0042147b327bf6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde557a9c54770388cb1fbee0ae8d564/" rel="bookmark">
			Jupyter Notebook 开启远程登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jupyter Notebook可以说是非常好用的小工具，但是不经过配置只能够在本机访问
安装jupyter notebook conda install jupyter notebook
生成默认配置文件 jupyter notebook --generate-config
将会在用户主目录下生成.jupyter文件夹，其中jupyter_notebook_config.py就是刚刚生成的配置文件
配置访问密码 jupyter notebook password #设置 jupyter 的密码,并生成自己配置文件，目录在 ~/.jupyter/jupyter_notebook_config.py test123456 修改配置文件 修改用户主目录下~/.jupyter/jupyter_notebook_config.py文件
c.NotebookApp.ip='*' c.NotebookApp.open_browser = False c.NotebookApp.port=8888 测试 在服务器开启jupyter notebook
浏览器不会自动开启其他电脑在浏览器输入服务器ip：8888，能够访问jupyter notebook jupyter notebook
有如下提示
在笔记本浏览器输入外网ip:8888
成功远程访问服务器的jupyter notebook 输入设置的密码即可进入
后台启动 nohup jupyter notebook --allow-root &gt; /root/nohup.log &amp;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3973e11dd8b08d27b33ce0d122a744db/" rel="bookmark">
			【头歌实训】PySpark Streaming 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1关：SparkStreaming 基础 与 套接字流任务描述相关知识Spark Streaming 简介Python 与 Spark StreamingPython Spark Streaming APISpark Streaming 初体验（套接字流） 编程要求测试说明答案代码 第2关：文件流任务描述相关知识文件流概述Python 与 Spark Streaming 文件流Spark Streaming 文件流初体验 编程要求测试说明答案代码 第3关：RDD 队列流任务描述相关知识队列流概述Python 与 Spark Streaming 队列流Spark Streaming 队列流初体验 编程要求测试说明答案代码 第1关：SparkStreaming 基础 与 套接字流 任务描述 本关任务：使用 Spark Streaming 实现词频统计。
相关知识 为了完成本关任务，你需要掌握：
Spark Streaming 简介；Python 与 Spark Streaming；Python Spark Streaming API；Spark Streaming 初体验（套接字流）。 Spark Streaming 简介 Spark Streaming 是 Spark 的核心组件之一，为 Spark 提供了可拓展、高吞吐、容错的流计算能力。如下图所示，Spark Streaming 可整合多种输入数据源，如 Kafka、Flume、HDFS，甚至是普通的 TCP 套接字。经处理后的数据可存储至文件系统、数据库，或显示在仪表盘里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3973e11dd8b08d27b33ce0d122a744db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303414ebf854be7456c989c7119f8e6c/" rel="bookmark">
			Android 配置不同应用ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android中，每个应用都有一个独特的应用ID，用于唯一标识该应用。如果您想配置不同ID的应用，请按照以下步骤操作：
在Android Studio中创建一个新的项目。
在创建项目时，使用不同的应用ID。您可以在app/build.gradle文件中的defaultConfig部分设置应用ID，例如：
defaultConfig { applicationId "com.example.myapp1" ... } 在创建项目时，您还可以选择自定义应用ID。在创建项目对话框中，选择"Edit"选项并输入自定义的应用ID。
如果您想在同一项目中创建多个变体，可以在build.gradle文件中的productFlavors部分配置不同的应用ID。例如：
productFlavors { flavor1 { applicationId "com.example.myapp1" ... } flavor2 { applicationId "com.example.myapp2" ... } } 在AndroidManifest.xml文件中，您还可以配置应用ID。在&lt;manifest&gt;标记内的package属性中指定应用ID，例如：
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapp1"&gt; ... &lt;/manifest&gt; 通过这些步骤，您可以配置不同ID的应用，并在同一设备上安装和运行它们。请注意，应用ID是唯一的，不同的应用ID将被视为不同的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e2ffa13283a6f59a81bd15153685d4/" rel="bookmark">
			使用VS code将项目从coding的代码仓库中拉到本地并运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.现在本地新建一个文件夹
2.在新建文件夹下右击后选择 Git Bash Here
3.打开coding的代码仓库，选择项目然后点击克隆/下载，点击复制
4.在git bash here中输入 git clone + 复制的项目地址
5.在vs code中选择打开这个文件夹，点击三个点，选择终端后新建终端
6.在终端中安装依赖
输入 npm i
黄色字体WARN是警告信息，但是没有报错，也不是什么很严重的警告，所以可以不用管
7.运行项目
输入npm run dev
运行完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ecef26589b672e4b18ed24e5448c36/" rel="bookmark">
			0044__CAN与CAN FD的区别是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN与CAN FD的区别是什么？ - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb5c32a3d25e0f097590951bd95527c/" rel="bookmark">
			安防视频监控系统EasyCVR实现H.265视频在3秒内起播的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可视化云监控平台/安防视频监控系统EasyCVR视频综合管理平台，采用了开放式的网络结构，可以提供实时远程视频监控、视频录像、录像回放与存储、告警、语音对讲、云台控制、平台级联、磁盘阵列存储、视频集中存储、云存储等丰富的视频能力，同时还具备权限管理、设备管理、鉴权管理、流媒体接入与转发等管理能力。
安防监控视频汇聚平台EasyCVR早已实现H.265自动转码H.264的功能，用户可以通过该功能配合EasyPlayer.js流媒体播放器，实现H.265的视频流在web端3秒内起播。那么实现该效果应该注意哪些事项呢？
1）服务器的硬件配置要高
如果存在较多的H.265视频流同时播放，服务器要选择高配置。因为EasyCVR安防视频管理平台是软转码，并没有使用硬解的方式，所以需要消耗服务器的cpu资源和内存资源。根据测试的情况，一台16核32进程的服务器可以同时转码30路左右的H.265的视频流（cpu消耗80%，内存消耗60%），极限情况下可以转码41路。
2）接口调用
用户可以通过http://127.0.0.1:18000/api/v1/state/codec这个接口来获取正在转码的路数，结合目前全部播放（H.265+H.264）的路数，以及服务器的消耗情况来调配。
视频云存储平台EasyCVR可拓展性强、部署轻快，能实现多现场的前端摄像头等设备统一集中接入与视频汇聚管理，并能进行视频高清监控、录像、云存储与磁盘阵列存储、检索与回放、级联共享等视频功能，可应用在工厂、工地、仓储、物流、社区、校园、水利、能源矿山等场景中。感兴趣的用户可以前往演示平台进行体验或部署测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2ef1a58bc530aefa58cb4e6b2f783b/" rel="bookmark">
			Linux date命令显示日期和时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Linux中，可以使用date命令来显示日期和时间，同时也可以通过指定格式来定制日期的显示方式。下面是一些常用的日期格式选项：
%Y：四位数的年份，例如“2023”。 %m：两位数的月份，例如“06”。 %d：两位数的日期，例如“15”。 %H：24小时制的小时数，两位数表示，例如“15”代表下午3点。 %M：两位数的分钟数，例如“30”。 %S：两位数的秒数，例如“10”。 %A：星期几，英文全名表示，例如“Tuesday”。 %a：星期几，英文缩写表示，例如“Tue”。 %B：月份，英文全名表示，例如“June”。 %b：月份，英文缩写表示，例如“Jun”。 你可以使用这些格式选项组合起来形成所需的日期格式。例如，要显示形如“2023-06-15 15:30:10”的日期和时间，可以运行以下命令：
date "+%Y-%m-%d %H:%M:%S" 这将输出当前日期和时间，格式为你指定的格式。如果你需要显示其他日期时间值，可以使用-d选项指定日期时间字符串。例如，要显示3天前的日期和时间，可以运行以下命令：
date -d "3 days ago" "+%Y-%m-%d %H:%M:%S" 这将输出3天前的日期和时间。你可以根据需要调整日期时间字符串和格式选项来满足你的需求。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deed5e3d66c16d64b86c0166d6b53b9d/" rel="bookmark">
			vue中异步移入组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：如果使用import CustomerSearch from '@/components/public/CustomerSearch'引入组件的话，有时候组件引入不成功，导致直接显示标签；
解决：使用异步引入即可解决这个问题
const CustomerSearch = () =&gt; import('@/components/public/CustomerSearch') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1411d5b355e6affe5156025fcf5dbdff/" rel="bookmark">
			基于C#语言的GUI开发,主要介绍WPF框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		框架 简介 下面是几种常见基于.Net的界面开发框架,都是Microsoft提供,下面简介由GPT生成
WinForms (Windows Forms
WPF (Windows Presentation Foundation)
UWP (Universal Windows Platform)
MAUI (Multi-platform App UI)
WinForms（Windows Forms）： 介绍： WinForms是由Microsoft提供的用于开发Windows桌面应用程序的UI框架。它使用简单的拖放界面进行用户界面的构建，并基于.NET框架。主要特点： 使用可视化设计器进行快速应用程序开发（RAD）。事件驱动的编程模型。与Windows API直接集成。 WPF（Windows Presentation Foundation）： 介绍： WPF是用于构建具有丰富用户界面的Windows桌面应用程序的框架。与WinForms相比，它提供了更现代和灵活的UI开发方法。主要特点： 强大的数据绑定和模板系统。分辨率独立的矢量图形。可扩展和可定制的控件。UI和业务逻辑的分离。 UWP（Universal Windows Platform）： 介绍： UWP是由Microsoft引入的平台，用于创建可以在各种Windows设备上运行的通用应用程序，包括PC、平板、手机、Xbox、HoloLens等。它是Windows 10生态系统的一部分。主要特点： 自适应用户界面，适应不同设备形状。安全性和性能改进。与Windows 10功能的集成，如Cortana和Live Tiles。 MAUI（Multi-platform App UI）： 介绍： MAUI是由Microsoft推出的现代跨平台框架，用于从单一代码库构建适用于iOS、Android、Windows和macOS的本机应用程序。它是Xamarin.Forms的演进，是.NET MAUI堆栈的一部分。主要特点： 单一代码库适用于多个平台。支持每个平台的本机UI控件。与.NET 6及更高版本集成。面向各种设备，包括桌面和移动设备。 选择 winform过于古早
uwp的话,我们就用windows电脑,没必要
maui因为跨平台,导致了其臃肿
所以我们选择WPF,下面文章也是主要讲WPF的
UI 设计思路 先根据功能,设计布局
然后就是如果项目比较大,要考虑设计模式的选取,让前后端分离
控件 因为UI的开发都是基于界面和控件的,而我们常用的控件都大同小异,需要的时候自行查阅文档就好了
常用 信息类 label
编辑类 文本编辑 textbox 状态编辑 checkbox
按钮 button
添加方式 拖拽添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1411d5b355e6affe5156025fcf5dbdff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36efad5bb4a804e755e4f1275f9a3155/" rel="bookmark">
			鸿蒙开发中的一些小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我在学习鸿蒙开发中遇见的小问题 Q1：This custom component must have a 'build' function. &lt;etsLint&gt;Q2：page_title is not translated into en_US(American English)Q3：Module '"../CustomComponent/CustomButton"' declares 'CustomButton' locally, but it is not exported. &lt;tsCheck&gt;Q4：提示文件不存在或者格式不合法 Q1：This custom component must have a ‘build’ function. 源码
@Component export default struct ProgressEditPanel { } 问题
源码中没有出现build方法
解决
@Component export default struct ProgressEditPanel { build() {} } Q2：page_title is not translated into en_US(American English) 提示：page_title is not translated into en_US(American English)
修改：三个string.json文件都需要出现相同的name和value才行，如果根据提示进行修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36efad5bb4a804e755e4f1275f9a3155/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a084b794bc0759e7a6b77810e01874f2/" rel="bookmark">
			.gitignore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.gitignore 文件忽略规则: 开头的/并不是标识文件夹的要表明仅忽略文件夹需要在名称后面添加 /，而不是前面.
要想忽略某文件夹，但其下部分文件不能忽略。则需要添加通配符*，然后在后面添加！开头的规则，来指出不忽略的文件或文件夹。
只要写了路径，即/左右两边都有字符，那么就是指的“绝对路径”(相对仓库的，仓库.git文件夹所在目录为根目录)，但可以用*来指定层级，指定第几层子目录下的某个文件夹。
空格不匹配任意文件，可作为分隔符，可用反斜杠转义
#开头的模式标识注释，可以使用反斜杠进行转义
! 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义
/ 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件
/ 开始的模式匹配项目跟目录
如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录
**匹配多级目录，可在开始，中间，结束
?通用匹配单个字符
[]通用匹配单个字符列表
常用匹配示例： bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 忽略根目录下的bin文件 /*.c: 忽略 cat.c，不忽略 build/cat.c debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj**/foo: 忽略/foo, a/foo, a/b/foo等a/**/b: 忽略a/b, a/x/b, a/x/y/b等 !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件*.log: 忽略所有 .log 文件config.php: 忽略当前路径的 config.php 文件 关于.gitignore规则不生效的问题 .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。
解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:
git rm -r --cached . git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a084b794bc0759e7a6b77810e01874f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c65f1025ed5aacf3163787ed51e17ff1/" rel="bookmark">
			十、Shell 变量类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Shell 支持不同类型的变量，其中一些主要的类型如下：
一、整数变量 整型变量用于存储整数据数据。可以使用整数赋值给变量，或者通过命令的输出结果获取整数值。整型变量可以用于数学计算、循环控制等等。
#!/bin/bash num1=10 num2=5 sum=$((num1 + num2)) echo "和为: $sum" 运行结果 和为: 15
二、字符变量 字符串变量用于存储文本数据。使用字符串变量来保存文本、文件名、命令的输出等。在Shell脚本中，使用双引号或单引号来定义字符串变量。
#!/bin/bash str1="Hello, World!" echo $str1 运行结果 Hello, World!
三、数组变量 数组变量用于存储多个值的数据结构。数组可以存储字符串或整数等不同类型的值，并可以通过索引访问特定的元素。在Shell脚本中，使用括号定义数组变量，以及索引访问数组中的元素。
#!/bin/bash arr1=("apple" "banana" "orange") echo ${arr1[0]} # 输出 "apple" echo ${arr1[1]} # 输出 "banana" echo ${arr1[2]} # 输出 "orange" apple banana orange 四、环境变量 环境变量是用来存储系统环境信息的变量。这些变量可以影响脚本的运行方式，并且可以在脚本之间共享和传递。环境变量通常用于配置脚本的行为、设置路径、设置系统参数等，需要使用 $ 符号来访问环境变量的值，以下是一些常见的环境变量：
PATH：用于存储可执行文件的搜索路径。HOME：当前用户的家目录。USER：当前登录的用户名。SHELL：当前使用的Shell解释器。PWD：当前工作目录。 #!/bin/bash echo "当前用户：$USER" echo "当前工作目录：$PWD" 当前用户：root 当前工作目录：/root 五、特殊变量 在Shell脚本中，有一些特殊的环境变量，它们具有特定的用途和意义。以下是一些常见的特殊环境变量：
$0：当前脚本的名称。$1、$2、$3...：位置参数，表示传递给脚本的参数。$#：传递给脚本的位置参数的数量。$*：所有位置参数的列表。$@：所有位置参数的列表，与$*类似，但每个参数都是作为一个独立的字符串传递的。$?：上一个命令的退出状态。0表示成功，非0表示失败。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93330caf8d24afc935da872a1116163/" rel="bookmark">
			ts相关笔记（Partial、Required、Readonly、Record、Exclude、Extract）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下ts内置的一些常用的工具类型。
TypeScript 内置了一批简单的工具类型，它们就是类型别名的使用方式，同时在全局可用，无需导入。
Partial 它接收一个对象类型，并将这个对象类型的所有属性都标记为可选
实现：
type Partial&lt;T&gt; = { [P in keyof T]?: T[P]; }; 使用案例：
type User = { name: string; age: number; email: string; }; type PartialUser = Partial&lt;User&gt;; const user: User = { name: 'John Doe', age: 30, email: 'john.doe@example.com' }; // 可以不实现全部的属性了！ const partialUser: PartialUser = { name: 'John Doe', age: 30 }; Required 把属性标记为必须
实现：
type Required&lt;T&gt; = { [P in keyof T]-?: T[P]; }; 使用案例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f93330caf8d24afc935da872a1116163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5879088e5b02feb244ee7087fa95871/" rel="bookmark">
			模式识别与机器学习-SVM（带软间隔的支持向量机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVM（带软间隔的支持向量机） 软间隔思想的由来软间隔的引入 谨以此博客作为复习期间的记录。
软间隔思想的由来 在上一篇博客中，回顾了线性可分的支持向量机,但在实际情况中，很少有完全线性可分的情况，大部分线性可分的情况都是整体线性可分，个别样本点无法线性分割开。因此就要避免这极个别样本点对分割平面产生的影响。
线性可分支持向量机
软间隔的引入 在分类过程中，允许极个别数据点“越界”，如何在目标函数中体现这一点呢？
软间隔支持向量机（Soft Margin Support Vector Machine）的数学形式可以通过修改支持向量机（SVM）的优化目标函数和约束条件来实现。软间隔允许一些数据点越界，引入了松弛变量来处理这些点。
首先，我们考虑软间隔的目标函数和约束条件：
目标函数：
最小化目标函数，同时考虑间隔的最大化和误分类点的惩罚，即：
min ⁡ w , b , ξ 1 2 ∥ w ∥ 2 + C ∑ i = 1 N ξ i \min_{\mathbf{w}, b, \boldsymbol{\xi}} \frac{1}{2}\|\mathbf{w}\|^2 + C \sum_{i=1}^{N} \xi_i w,b,ξmin​21​∥w∥2+Ci=1∑N​ξi​
这里 w \mathbf{w} w 是超平面的法向量， b b b 是截距， ξ \boldsymbol{\xi} ξ 是松弛变量， C &gt; 0 C &gt; 0 C&gt;0 是一个超参数，用于控制对误分类点的惩罚程度。
约束条件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5879088e5b02feb244ee7087fa95871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6400299bb09f4e43ca486fa678d177/" rel="bookmark">
			模式识别与机器学习-SVM（线性支持向量机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性支持向量机 线性支持向量机间隔距离学习的对偶算法算法:线性可分支持向量机学习算法线性可分支持向量机例子 谨以此博客作为复习期间的记录 线性支持向量机 在以上四条线中，都可以作为分割平面，误差率也都为0。但是那个分割平面效果更好呢？其实可以看出，黑色的线具有更好的性质，因为如果将黑色的线作为分割平面，将会有更大的间隔距离。
其中，分割平面可以用以下式子表示:
w x + b = 0 wx+b = 0 wx+b=0
w 和 b w\text{和}b w和b都是有待学习的参数，SVM的核心思想之一就是找到这样的一个平面，使得间隔距离最大。那么该如何表述间隔距离呢？
间隔距离 在分割平面 w x + b = 0 wx+b = 0 wx+b=0确定的情况下，对每一个样本点 x i , ∣ w x i + b ∣ x_i,|wx_i+b| xi​,∣wxi​+b∣可以表示样本点 x i x_i xi​到分割平面的距离。而若是二分类， y i ∈ { 1 , − 1 } y_i \in \{1,-1\} yi​∈{1,−1}，那么 y i ( w x i + b ) y_i(wx_i+b) yi​(wxi​+b)同样可以表示样本点到分割平面的距离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd6400299bb09f4e43ca486fa678d177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb449973d1918b542eb3ffa2d8d29d88/" rel="bookmark">
			App防止恶意截屏功能的方法：iOS、Android和鸿蒙系统的实现方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防止应用被截图是一个比较常见的需求，主要是出于安全考虑。下面将分别为iOS（苹果系统）、Android（安卓系统）及HarmonyOS（鸿蒙系统）提供防止截屏的方法和示例代码。
在企业内部使用的应用中，防止员工恶意截屏是一个重要的安全需求。本文将详细介绍iOS、Android和鸿蒙系统的防止截屏的方法，并提供相应的代码示例，以帮助代码初学者理解和实现该功能。
iOS系统防止截屏方法：
在iOS系统中，可以通过设置UIWindow的windowLevel为UIWindowLevelNormal + 1，使应用窗口覆盖在截屏窗口之上，从而阻止截屏。以下是Objective-C和Swift两种语言的代码示例：
1. iOS系统防止截屏
在iOS中，可以使用UIScreen的isCaptured属性来检测屏幕是否被录制或截图。为了防止截屏，你可以监听UIScreenCapturedDidChange通知，当屏幕开始被捕获时，你可以做一些操作，比如模糊视图或显示一个全屏的安全警告。
swift
// 注册屏幕捕获变化通知 NotificationCenter.default.addObserver( self, selector: #selector(screenCaptureChanged), name: UIScreen.capturedDidChangeNotification, object: nil ) @objc func screenCaptureChanged(notification: NSNotification) { if UIScreen.main.isCaptured { // 屏幕正在被捕获，可以在这里做一些隐藏内容的操作，比如 // 显示一个覆盖所有内容的视图 } else { // 屏幕没有被捕获，可以移除那个覆盖的视图 } } 但需要注意的是，iOS不允许应用程序完全禁止截屏。因为截图功能是系统级别的，而不是应用级别的，上述代码只能做到在截图时采取一定的响应措施，不能完全防止。
2. Android系统防止截屏
在Android中，可以通过设置Window的属性来防止用户截图或录屏。这通过禁用FLAG_SECURE来实现。
java
// 在Activity中设置禁止截屏 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 在setContentView之前调用 getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE); setContentView(R.layout.activity_main); } 这样设置后，当前的Activity将无法被截屏或录屏。
3. HarmonyOS（鸿蒙系统）防止截屏
HarmonyOS是华为开发的一个分布式操作系统，目前它在应用开发中有着与Android类似的API。因此可以使用与Android相同的方法进行禁止截屏。
java
// 在Ability(Activity)中设置禁止截屏 @Override protected void onStart(Intent intent) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb449973d1918b542eb3ffa2d8d29d88/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/17/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>