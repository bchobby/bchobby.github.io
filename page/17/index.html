<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55c323fcfda9824e2f934de84bd36ad/" rel="bookmark">
			面试陪伴群（一起打卡学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了迎接即将到了的 2024 年跳槽季和春招季，我准备创建一个高质量的面试陪伴群，和大家一起高效的学习，一起为即将到来的面试季做足充分的准备。
陪伴群规划 陪伴群愿景和规划：
一起参与打卡学习：设置 21 天学习打卡计划，由群主提供每天 10 道常见面试题的题目，学员自行学习和打卡（需提供学习笔记发表到飞书云文档，并提供云文档链接进行打卡）
查漏补缺（打卡第二天获得上一天面试题答案）：每个群成员在第一天打卡之后，在第二天会收到磊哥发的上一天面试答案，和自己的答案比较，查漏补缺、重复记忆。
提供简历辅导：磊哥每天为群内成员提供 2 份免费简历辅导的名额，先到先得，在群内申请文档中填写排队信息（申请地址见群公告）。
群内讨论和技术交流：所有群成员可在群内讨论和分享面试题以及面试经验等内容。
部门直推和内推：群成员在 2024 年年初会得到一手的部门直推和内推的信息，帮助大家更好的找到工作。
你将收获 技能提升：通过共同学习收获技能的飞速提升。
同道中人：一起找工作的搭子。
简历提升：由磊哥这个有十几年工作经验，八年面试官经验的资深程序员，帮你辅导简历，收获更多面试机会。
一手直推和内推消息：群成员会获得最新的一手直推和内推信息。
打卡规则 每人每天最多打卡 2 天学习内容（多打卡无效）。
每周至少打卡 5 天学习内容。
如何收费？ 陪伴群收费，总共由以下两部分组成：
固定群费：原价 299，目前内测阶段 99 元（满 50 人恢复原价）。
打卡押金（自愿缴纳）：50 元，自愿缴纳。完成 30 天打卡内容学习，退还押金；如果打卡中断或未完成打卡，则算打卡失败，押金放入当期奖金池，平分给所有打卡完成的学生。所有缴纳的押金，会公示给群成员。
什么时候开始？ 即日起开始招生，满 50 人，拉群开始打卡。
如何报名？ 添加微信：gg_stone，备注【陪伴群】，不然不予通过。
直接转账 99（+自愿缴纳的 50 打卡押金）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c736bed0b39f8fdc005c13f8576d643a/" rel="bookmark">
			couldn‘t find “libmmkv.so“ android8.1.0 Nexus 5X
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的应用一直没有奔溃，但是在某几款设备可能存在mmkv的报错。
研究了很久，一方面是因为mmkv团队也已经不管这个事情，从他的issue来看，每次有人提到这个，他要么就不予理睬，给出这个并非库维护者需要干的事情，要么就说你去找google。
抛开那种确实是集成库的开发者的问题之后，事实99%都能用的情况后，那么，还存在于某个机型，比如我这里也遇到的android8.1.0 Nexus 5X，也会存在找不到库的情况。
首先mmkv库新版已经不支持armeabi。
解决方案有多种：
https://blog.csdn.net/xiaobaaidaba123/article/details/127250141
方案1： app 的build.gradle 检查 android-buildTypes 下的ndk abiFilters
ndk {
abiFilters “armeabi”
}
改为
ndk {
abiFilters “armeabi-v7a”
}
armeabi-v7a 可以向下兼容 armeabi
方案2: 如果项目有些so 只有 armeabi 架构无法升级到 v7a 的话，可以 通过 mmkv maven 依赖的aar 包找到 armeabi-v7a 的 so, 把 so 放到项目 armeabi 目录，abiFilters 可以依旧是 “armeabi”。 从他的方案来看，只写了一个abiFilters，说明他是专用的机器。也难怪别人回复并不能解决。我推测可以参考的是，拷贝和全部写上abiFilters，目前没有尝试。
https://my.oschina.net/vivotech/blog/5129118
这里是vivo团队，提到的一个解决方案，重链接。但是没有给出具体的代码。后续有空再行翻阅。
https://github.com/Tencent/MMKV/wiki/android_advance_cn#%E8%87%AA%E5%AE%9A%E4%B9%89-library-loader
https://github.com/KeepSafe/ReLinker
官方和relinker，都提到了在android6.0以下，存在系统层面的loadLib方法不完善的问题，在6.0之上是好的。
但是显然，从relinker的issue和我这里，都可以看到8.1的nexus5x仍然出现了。
从这个角度，只能推测，可能这些手机解压库可能导致了丢失或者目录结构不正常的问题。
那么解决方案代码改进为：
MMKV.initialize(app) ---&gt; //start 尝试： 通过找到一个自行加载 // 二次保护来解决Mmkv可能在Nexus5X 8.1的crash问题 try { MMKV.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c736bed0b39f8fdc005c13f8576d643a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2078d56373b3ffbddeea9b611214ea2/" rel="bookmark">
			安全生产人员定位系统助企业实现智能化管理，提高生产安全性和效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全生产人员定位系统是基于物联网技术的系统，通过集成各种传感器和通信技术，实时监测员工的位置和活动状态。该系统可以帮助企业管理者了解员工的工作状态，及时发现潜在的安全隐患，从而采取相应的措施，保障员工的安全。
在工业生产过程中，安全生产是至关重要的。为了确保员工的安全，提高生产效率，安全生产人员定位系统应运而生。该系统通过实时监测员工的位置和活动状态，为管理者提供准确的信息，以做出及时的决策，从而保障员工的安全，提升生产效率。
安全生产人员定位系统的功能特点
实时定位：系统能够实时获取员工的位置信息，并展示在电子地图上，方便管理人员随时掌握员工分布情况。
轨迹回放：系统能够记录员工的行动轨迹，并支持回放功能，方便管理人员对员工行为进行分析和追溯。
预警功能：系统能够根据设定的规则，对员工的位置信息进行判断，如有安全隐患或违规操作，系统将自动预警并通知管理人员。
数据统计：系统能够对人员位置数据进行统计和分析，生成各类报表和图表，方便管理人员了解生产效率和人员分布情况。
权限管理：系统支持多级权限管理，不同级别的管理人员可以查看不同的数据和信息，确保数据安全。
安全生产人员定位系统的应用场景
化工企业：在化工企业中，安全生产人员定位系统可以帮助企业实时掌握员工的位置信息，预防事故发生，提高生产安全性。例如，在危险化学品生产区域，员工需要严格遵守安全距离和操作规程。通过人员定位系统，企业可以实时监测员工的位置，确保他们遵守安全规定，并及时预警潜在的安全隐患。
建筑施工现场：在建筑施工现场，安全生产人员定位系统可以帮助企业实时掌握员工的位置信息，预防事故发生，提高生产效率。例如，在高层建筑或复杂结构的施工中，员工需要遵循特定的安全规范和操作流程。通过人员定位系统，企业可以实时监测员工的位置和活动情况，确保他们遵守安全规定，并及时采取必要的措施，提高施工的安全性和效率。
制造企业：在制造企业中，安全生产人员定位系统可以帮助企业实现智能化管理，提高生产效率和质量。例如，在生产线自动化程度较高的制造企业中，员工需要按照规定的流程和操作规范进行生产。通过人员定位系统，企业可以实时监测员工的位置和活动情况，确保他们遵守操作规程，并及时采取必要的措施，提高生产效率和产品质量。
案例分析
以某大型化工企业为例，该企业引入了安全生产人员定位系统，实现了对员工的实时追踪和定位。通过在厂区内设置定位基站和为员工配备定位标签，系统能够实时获取员工的位置信息并展示在电子地图上。管理人员可以通过系统随时掌握员工分布情况，对安全隐患进行预警和干预，有效提高了生产安全性和效率。同时，系统还能够记录员工的行动轨迹和数据统计，方便企业对生产过程进行分析和优化。此外，该企业还利用该系统实现了对危险区域的管控和安全距离的设定，进一步提高了生产安全性。
安全生产人员定位系统在企业的安全生产过程中具有重要意义。通过实时掌握员工的位置信息，可以及时发现安全隐患，预防事故发生，提高生产效率。该系统具有实时定位、轨迹回放、预警功能、数据统计和权限管理等功能特点，可以广泛应用于化工、建筑施工、制造等企业。通过引入安全生产人员定位系统，企业可以实现智能化管理，提高生产安全性和效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0c7a1fcda361ae99d7b09283a2e79c/" rel="bookmark">
			BP算法与淋浴器的温度调节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BP算法（反向传播算法）是一种用于神经网络训练的基本算法。它通过逐层迭代地调整神经网络的权重和偏置，以使网络的输出尽可能接近期望的输出。BP算法之所以能够训练神经网络，是因为它基于梯度下降的思想，通过最小化损失函数来优化网络参数。
BP算法的原理如下：
前向传播（Forward Propagation）：从输入层开始，将输入信号通过每一层的权重和激活函数进行计算，得到网络的输出结果。
计算损失（Loss Calculation）：将网络的输出结果与期望的输出结果进行比较，计算出网络的误差（损失）。
反向传播（Backward Propagation）：从输出层开始，根据损失值计算每一层的梯度（导数），然后将梯度向前传递至输入层。这里利用了链式法则来计算每一层的梯度，将损失沿着网络反向传播。
更新权重和偏置（Weight and Bias Update）：利用梯度下降的思想，根据梯度和学习率的大小，更新每一层的权重和偏置，使得损失函数不断减小。
重复以上步骤：通过多次迭代，不断调整网络的权重和偏置，直到达到设定的训练停止条件（如达到最大迭代次数或损失函数收敛）。
将BP算法与淋浴器的温度调节类比可以更好地理解其原理。假设我们希望调节淋浴器的温度，使得输出的温度尽量接近期望的温度。我们可以将淋浴器看作是一个神经网络，温度调节器看作是网络的权重和偏置。初始时，淋浴器的温度与期望温度存在一定的差距，即损失。通过调整温度调节器的参数（权重和偏置），我们可以逐渐减小损失，使得淋浴器的温度越来越接近期望温度。
在这个类比中，调节温度的过程类似于前向传播，计算损失的过程类似于计算损失，调整温度调节器的参数类似于反向传播和参数更新。通过多次迭代，不断调整温度调节器的参数，最终可以达到期望的温度。同样地，通过多次迭代，BP算法可以不断调整神经网络的权重和偏置，使得网络的输出逐渐接近期望的输出。
综上所述，BP算法通过梯度下降的思想，利用反向传播和参数更新的方式，逐步优化神经网络的权重和偏置，从而实现网络的训练和学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c56c6794068c87ec08233c7f6c65dc/" rel="bookmark">
			利用ChatGPT在不同教学场景中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教学策略与最佳实践：
课堂讨论：在课堂上可以利用ChatGPT作为一个辅助工具，回答学生的问题、提供解释和补充知识。教师可以利用ChatGPT快速获取相关信息，并且根据学生的提问进行回答和引导讨论。
个别辅导：对于个别辅导场景，ChatGPT可以扮演一个虚拟助教的角色。学生可以通过与ChatGPT对话来解决问题、寻求帮助和获得指导。ChatGPT可以提供个性化的反馈和解答，帮助学生理解概念和解决困惑。
在线学习：在在线学习环境中，ChatGPT可以作为一个在线学习伙伴，与学生进行交互并提供学习支持。学生可以通过与ChatGPT的对话来复习知识、解答问题和进行自主学习。ChatGPT可以根据学生的需求提供个性化的学习材料和指导。
课程设计与教学资源开发：
利用ChatGPT生成课程笔记、习题和案例分析等教学资源，可以提高教学效率和资源的可重用性。教师可以将ChatGPT用于自动生成课程笔记，将讲解内容输入ChatGPT并生成详细的笔记，然后对生成的内容进行编辑和修正。同样地，使用ChatGPT也可以生成习题和案例分析，丰富教学资源库，并根据需要进行调整和定制。
ChatGPT在学生作业和考试的自动化批改与评估中的应用：
利用ChatGPT进行学生作业和考试的自动化批改可以提高效率和准确性。ChatGPT可以根据预设的标准答案和评分规则，对学生提交的作业和答案进行自动评估和打分。同时，ChatGPT还可以提供及时的反馈和建议，帮助学生了解自己的学习进展和改进空间。这种方式可以节省教师的时间，同时给予学生更加个性化的评估和指导。
ChatGPT背景下的实验课程教学：
在实验课程教学中，可以结合Code Interpreter和ChatGPT插件来提供更加全面的支持。Code Interpreter可以用于在线执行和调试学生的代码，帮助他们理解编程概念和调试错误。ChatGPT插件可以用于与学生进行交互，回答问题、提供指导和解释。通过这种方式，学生可以得到更加实时和个性化的支持，提高实验课程的学习效果。
总之，利用ChatGPT在不同教学场景中可以提供个性化的辅助学习和教学支持。它能够帮助教师提高教学效率，为学生提供个性化的学习体验，并且促进自主学习和深度思考。然而，在使用ChatGPT时，需要注意对生成内容的审查和修正，以确保准确性和可靠性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9a10fbb014c1ae6088c96ede5a1316/" rel="bookmark">
			IoT网关在工业生产中的应用分享-天拓四方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IoT网关可以连接各种不同类型的物联网设备，实现设备之间的数据传输和通信。IoT网关具有强大的数据处理和分析能力，可以对收集到的数据进行处理、分析和存储，从而为各种应用提供智能化的服务。
在工业生产环境中，IoT网关是实现设备间通信和数据传输的关键组件。它可以连接生产线上的各种设备，如传感器、执行器、PLC等，确保数据的实时、准确传输。同时，IoT网关还能对数据进行预处理和分析，为上层应用提供有价值的信息。
在工业4.0的框架下，物联网技术是实现生产自动化、智能化和网络化的关键。IoT网关作为连接设备与云平台、应用软件之间的桥梁，在工业4.0中发挥着核心作用。
IoT网关在工业生产中的功能特点
1、IoT网关与设备间的通信
在工业生产中，设备之间的通信是确保生产流程顺畅的关键。IoT网关支持多种通信协议，如MQTT、CoAP等，能够与各种类型的设备进行通信，确保数据的实时传输和共享。
2、数据采集与处理
IoT网关能够实时采集生产线上的各种数据，如温度、压力、流量等。通过对这些数据的处理和分析，可以实时监控生产线的运行状态，预测潜在的问题，并提前进行干预，确保生产的稳定和高效。
3、远程监控与管理
通过IoT网关，生产管理人员可以远程监控设备的运行状态，实时了解生产线的运行情况。同时，IoT网关还可以提供故障预警和故障诊断功能，帮助管理人员及时发现并解决问题，减少停机时间。
4、安全性与可靠性
在工业生产中，数据的安全性和可靠性至关重要。IoT网关通常配备强大的安全机制，如数据加密、访问控制等，确保数据在传输和存储过程中的安全性。此外，IoT网关还具备高可用性和容错能力，确保在设备故障或网络中断时，生产流程仍能正常运行。
IoT网关在工业生产中的应用案例
以某汽车制造厂的生产线为例，该厂引入了IoT网关技术，实现了生产线的智能化改造。通过IoT网关连接生产线上的各种设备，实现了设备间的实时通信和数据传输。同时，利用IoT网关的数据处理和分析功能，对生产线上的数据进行实时监控和分析，及时发现生产过程中的问题并进行调整。这不仅提高了生产效率和质量，还降低了生产成本和故障率。
相关产品
TDE 系列产品是天拓四方推出的带智能边缘计算的数据采集网关，可以方便地实现现场设备的远程数据采集、程序远程下载和远程维护。支持300+的工业设备驱动协议，2 路 RJ45 以太网和最多 5 路串口通讯接口，可满足绝大部分工业控制器设备的联网需求。同时支持以太网宽带、4G/5G、Wifi 上网方式。可通过数网星工业云平台实现远程配置、诊断和管理等功能。 IoT网关在工业生产中发挥着重要的作用。它不仅是连接设备与云平台和应用软件的桥梁，还是实现生产自动化、智能化和网络化的关键。通过引入IoT网关技术，企业能够提高生产效率和质量，降低成本和故障率，实现可持续发展。同时，随着物联网技术的不断发展和普及，IoT网关在工业生产中的应用将越来越广泛。它能够连接各种工业设备，实现设备间的通信和数据传输，为工业生产的智能化提供了有力支持。未来，随着技术的不断进步和创新，IoT网关将在工业生产中发挥更加重要的作用，推动工业生产的智能化和高效化发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ae41896af2d34823afc301fdc35ea4/" rel="bookmark">
			python打包项目pyinstaller的使用及问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
在使用python编写了一个小程序之后，希望能够将其打包为一个可执行文件，如exe格式，这样就能够在其他电脑上安装使用，因此，打包python项目是一个普遍的需求。
配置 平台：windows10
工具：visual studio code
语言：python
库：pyinstaller
第三方工具：虚拟文件打包工具Enigma Virtual Box
一、pyinstaller 安装 pip install pyinstaller 二、pyinstaller 使用 pyinstaller最简单的用法就是：
pyinstaller xxx.py 在你当前工作的项目根目录下，进入终端命令行，输入以上指令，其中xxx是你得python主项目名称。
正常情况下，pyinstaller此时会自动执行打包程序，但也可能会遇到错误：
The 'pathlib' package is an obsolete backport of a standard library package and is incompatible with PyInstaller. Please remove this package (located in E:\Program Files\Python312\Lib\site-packages) using "E:\Program Files\Python312\python.exe" -m pip uninstall pathlib then try again. 这个错误表示，如果你安装了pathlib，你需要卸载它。
pip uninstall pathlib 等待卸载完成，再次使用pyinstaller命令即可。
当打包完成后，会在当前项目文件下生成两个文件夹：
一个是build，一个是dist，其中exe文件就在dist文件夹下：
正常情况下，此时如果点击exe文件，应该能直接启动程序。但有时会遇到问题，比如路径问题。
我们在编程时，有时会为了方便，对于程序里用到的其他资源文件如图片、文本或者配置性文件，直接使用了相对路径，但一旦打包之后，程序启动时的终端可能就完全不一样了，此时相对路径很可能就报错。
那么此时应该如何处理呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47ae41896af2d34823afc301fdc35ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2dfd31fc0d3b2a62570c6ddff634650/" rel="bookmark">
			【机器学习】西瓜书第6章支持向量机课后习题6.1参考答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【机器学习】西瓜书学习心得及课后习题参考答案—第6章支持向量机
1.试证明样本空间中任意点x到超平面(w,b)的距离为式(6.2)。
首先，直观解释二维空间内点到直线的距离：
由平面向量的有关知识，可得：
超平面的法向量为 w w w，任取平面上一点 x 0 x_0 x0​，则超平面可以表示为 ω T ⋅ x 0 + b = 0 ω^T \cdot x_0 + b = 0 ωT⋅x0​+b=0。一个点 x x x到超平面的距离可以用该点到 x 0 x_0 x0​ 的距离在法向量 (ω) 方向上的投影来表示，即：
距离 = ∣ ω T ( x − x 0 ) ∣ ∣ ∣ ω ∣ ∣ = ∣ ω T x + b ∣ ∣ ∣ ω ∣ ∣ \text{距离} = \frac{|ω^T(x−x_0)|}{||ω||} = \frac{|ω^T x + b|}{||ω||} 距离=∣∣ω∣∣∣ωT(x−x0​)∣​=∣∣ω∣∣∣ωTx+b∣​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2dfd31fc0d3b2a62570c6ddff634650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf36e6b72a7f2da9219089b8a83cf18/" rel="bookmark">
			Vue框架引入Axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先已经创建好了 Vue 框架，安装好了 node.js。
没有完成的可按照此博客搭建：搭建Vue项目
之后打开终端，使用命令。
1、命令安装 axios 和 vue-axios npm install axios --save npm install vue-axios --save 2、package.json 查看版本 在 package.json 文件里可查看下载好的依赖版本。
3、在 main.js 完整引入 import axios from 'axios' import VueAxios from 'vue-axios' // VueAxios 与 axios 的位置不能交换，否则出现 TypeError: Cannot read property 'protocol' of undefined Vue.use( VueAxios , axios) 4.使用 初始化方法：
methods:{ getList(){ this.axios.get('http://localhost:8000/user/getList',{ params:{ page:this.query.page, size:this.query.size, name:this.query.name } }).then((resp)=&gt;{ console.log(resp); this.tableData = resp.data.content.list; this.total = resp.data.content.total; }) }, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3b6181145e6f178377c300cd6f0cfe/" rel="bookmark">
			IP地址在网络安全中的关键作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址是互联网世界中的重要标识符，它在网络安全领域发挥着至关重要的作用。这些地址不仅帮助设备在网络上找到彼此，还在多个方面有助于维护网络的完整性、机密性和可用性。IP地址在网络安全中的关键作用以及实际应用有哪些呢？
1、身份验证和访问控制
IP地址用于标识和验证连接到网络的设备。这为网络管理员提供了一种强有力的工具，可以根据IP地址来控制设备的访问权限。通过配置防火墙、路由器和交换机上的访问控制列表（ACL），管理员可以限制或允许特定IP地址范围的设备访问敏感信息或关键资源。这有助于确保未经授权的访问被拒绝，从而降低潜在的威胁。
2、溯源和日志记录
IP地址在追踪网络活动方面发挥着关键作用。网络管理员可以使用IP地址来记录设备之间的通信，以便在发生安全事件时进行溯源和分析。这些日志可用于确定攻击来源、确认恶意活动以及为进一步的调查提供线索。因此，IP地址充当了网络安全事件的数字指纹，为网络安全专业人员提供了必要的信息。
3、防御策略的执行
网络安全团队可以使用IP地址来实施各种安全策略。例如，入侵检测系统（IDS）和入侵防御系统（IPS）可以监视网络流量，识别并组织来自已知恶意IP地址的恶意活动。这些系统可以根据IP地址的黑名单和白名单来采取措施，有助于减轻潜在的攻击并提高网络的安全性。
4、网络分割和隔离
IP地址还用于创建虚拟局域网（VLAN）和子网，从而实现网络分割和隔离。这有助于减小攻击面，即降低潜在攻击者入侵的机会。通过将设备分组到不同的子网中，即使一部分网络受到攻击，其他部分仍然可以保持相对安全。
5、安全审计和合规性
IP地址是安全审计和合规性的重要组成部分。通过监视与特定IP地址相关的活动，组织可以满足合规性要求，确保符合法规和标准。此外，它们还有助于识别潜在的安全风险和迅速采取措施来纠正问题。
6、恶意流量过滤
IP地址被广泛用于识别和过滤恶意流量，如分布式拒绝服务（DDoS）攻击。安全设备可以检测并隔离来自大量恶意IP地址的流量，确保网络的可用性和性能不受影响。这种过滤可以帮助网络恢复正常运行，同时降低攻击的影响。
综上所述，IP地址在网络安全中是不可或缺的工具，用于标识、验证、监视和保护网络资源。它们不仅有助于阻止潜在威胁，还提供了关键的日志和数据，帮助组织提高其网络安全水平。通过合理利用IP地址，组织可以更好地保护其网络免受各种网络安全威胁的侵害。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b63b422b0b06f3f09417f76ff49659cd/" rel="bookmark">
			Redis实现限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基于Redis的zset数据结构实现滑动窗口限流 我们可以将请求打造成一个zset数组，当每一次请求进来的时候，value保持唯一，可以用UUID生成，而score可以用当前时间戳表示，因为score我们可以用来计算当前时间戳之内有多少的请求数量。而zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求。
public Response limitFlow(){ Long currentTime = new Date().getTime(); System.out.println(currentTime); if(redisTemplate.hasKey("limit")) { Integer count = redisTemplate.opsForZSet().rangeByScore("limit", currentTime - intervalTime, currentTime).size(); // intervalTime是限流的时间 System.out.println(count); if (count != null &amp;&amp; count &gt; 5) { return Response.ok("每分钟最多只能访问5次"); } } redisTemplate.opsForZSet().add("limit",UUID.randomUUID().toString(),currentTime); return Response.ok("访问成功"); } 通过上述代码可以做到滑动窗口的效果，并且能保证每N秒内至多M个请求，缺点就是zset的数据结构会越来越大。实现方式相对也是比较简单的。
3. 基于Redis的list数据结构实现令牌桶限流 令牌桶算法提及到输入速率和输出速率，当输出速率大于输入速率，那么就是超出流量限制了。
我们每访问一次请求的时候，可以从Redis中获取一个令牌，如果拿到令牌了，那就说明没超出限制，而如果拿不到，则结果相反。
// 定时放令牌 // 10S的速率往令牌桶中添加UUID，只为保证唯一性 @Scheduled(fixedDelay = 10_000,initialDelay = 0) public void setIntervalTimeTask(){ redisTemplate.opsForList().rightPush("limit_list",UUID.randomUUID().toString()); } // 取令牌 public Response limitFlow2(Long id){ Object result = redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b63b422b0b06f3f09417f76ff49659cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af74f4fd325b1e7fc8c17bd89479580b/" rel="bookmark">
			Python：PyTorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 PyTorch是一个开源的机器学习库，由Facebook的人工智能研究团队（FAIR）开发，用于应用于机器学习和深度学习的Python程序。PyTorch基于Torch，使用Python语言重新编写，使得它更容易使用和扩展。它支持强大的GPU加速，并且具有动态计算图（称为autograd），这使得它在构建和训练神经网络方面非常灵活和高效。
PyTorch的基础组成 Tensor：张量是PyTorch中的基本数据结构，类似于NumPy的ndarray，但可以在GPU上使用。它是向量和矩阵的高维推广。自动微分（Autograd）：这是PyTorch中的一个核心特性，可以自动计算梯度，对于神经网络的训练至关重要。神经网络模块（torch.nn）：这个模块提供了构建神经网络所需的各种层和函数。例如，全连接层、卷积层、池化层、激活函数等。损失函数：在训练神经网络时，需要计算损失函数来评估模型的性能。PyTorch提供了多种损失函数，如交叉熵损失、均方误差（MSE）等。优化器：优化器用于更新网络的权重，以最小化损失函数。例如，随机梯度下降（SGD）、Adam等。数据加载和预处理：PyTorch提供了torchvision包，用于加载和预处理图像数据，以及进行数据增强。 学习PyTorch的基础步骤 安装：首先需要在系统中安装PyTorch。可以通过其官方网站或者使用包管理工具（如pip或conda）进行安装。理解基本概念：学习Tensor、自动微分、神经网络层、损失函数和优化器等基础知识。实践：通过编写简单的代码来加深理解，如创建和操作Tensor、构建简单的神经网络、训练模型等。深入学习：研究更高级的概念，如多GPU支持、动态图、模型保存和加载、TensorBoard可视化等。项目实战：参与实际的深度学习项目，应用PyTorch来解决实际问题。 PyTorch的优势 易用性：对于有NumPy基础的用户来说，PyTorch非常容易上手。灵活性：动态计算图使得它在构建复杂的神经网络时非常灵活。社区支持：由于使用人数众多，社区提供了大量的教程、论坛和文档。 总结 PyTorch是一个功能强大、灵活且易于使用的深度学习框架。无论你是初学者还是有经验的开发者，都可以通过学习和实践来掌握它，并将其应用于各种机器学习和深度学习的任务中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7445ac386046acd88c78769102c6265/" rel="bookmark">
			开源项目推荐：Frooodle/Stirling-PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介一个本地的处理 PDF 的工具，界面是 Web UI，可以支持 Docker 部署。
各种主要的 PDF 操作都可以支持。比如拆分、合并、转换格式、重新排列、添加图片、旋转、压缩等等。这个本地托管的网络应用最初完全由 ChatGPT 制作，后来逐渐发展，增加了许多功能，以满足你对 PDF 的各种需求。Stirling PDF 不会对外发送任何数据以进行记录或跟踪。所有的文件和 PDF 要么只在客户端处理，要么只在服务器内存中暂存，用于执行任务，或者仅在执行任务时保存在临时文件中。一旦用户下载了文件，那些文件就会从服务器上删除。
特性
支持深色模式可自定义的下载选项文件的并行处理和下载功能提供&amp;nbsp;API，可与外部脚本整合可选的登录和认证功能 PDF&amp;nbsp;功能页面操作
查看和修改 PDF -&amp;nbsp;可以查看多页 PDF，并自定义排序和搜索，还支持页面上的编辑功能，如添加注释、绘图、文本和图片。（采用 PDF.js、Joxit 和 Liberation 字体）提供完整的交互式界面，用于合并、拆分、旋转、移动 PDF 及其页面。将多个 PDF 合并成一个文件。在指定页码处拆分 PDF或将所有页面作为单独文件提取。按不同顺序重新排列 PDF 页面。以 90&amp;nbsp;度的增量旋转 PDF。删除页面。多页布局（将 PDF 重组为多页面格式）。按指定百分比调整页面内容大小。调整对比度。裁剪 PDF。自动拆分带有物理扫描分隔页的 PDF。提取特定页面。将&amp;nbsp;PDF 转换为单页格式。
转换操作
将 PDF 转换为图片，反之亦然。将各种常见文件格式转换为 PDF（使用 LibreOffice）。将 PDF 转换为 Word、Powerpoint 等格式（使用 LibreOffice）。将 HTML 转换为 PDF。将网址直接转换为 PDF。将 Markdown 文件转换为 PDF。
安全与权限
设置和移除 PDF 密码。更改或设置 PDF 权限。添加水印。对 PDF 进行认证或签名。清理 PDF 文件。自动涂抹文本以保护隐私。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7445ac386046acd88c78769102c6265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55610d7ebf5f8b7dbb67a4a79468730/" rel="bookmark">
			【小白专用】c#之FileStream对象读写大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提及文件流，不得不先说以下几个类
FileStream，MemoryStream，NetWorkStream，StreamReader，StreamWriter，TextReader，TextWriter
在用这些类之前，我们先来了解一下这些类的用途以及区别。
C# 中常用的文件流(FileStream、StreamReader/Writer、MemoryStream)_c# filestream和streamwriter-CSDN博客
读取数据：
FileStream fs = new FileStream(path,FileMode.Open); //初始化文件流 byte[] arr = new byte[fs.Length]; //初始化字节数组 fs.Read(arr, 0, arr.Length); //从流中数据读取到字节数组中 fs.Close(); //关闭流 string str = Encoding.UTF8.GetString(arr); //将字节数组转换为字符串 Console.WriteLine(str); 写入数据
FileStream fs = new FileStream(path,FileMode.Append); //初始化文件流 byte[] arr = Encoding.UTF8.GetBytes("程序人生道可道"); //将字符串转换为字节数组 fs.Write(arr,0,arr.Length); //将字节数组写入文件流 fs.Close(); 二：StreamReader/StreamWriter类
用途：主要用来处理流数据，它们分别提供了高效的流读取/写入功能。
优点：可以直接用字符串进行读写，而不用转换成字节数组。
注意：对于文本文件的读写，通常用 StreamReader 类和 StreamWriter 类更方便，其底层是通过FileStream实现读写文本文件。
读取数据：
FileStream fs = new FileStream(path,FileMode.Open); //初始化文件流 StreamReader sr = new StreamReader(fs); //初始化StreamReader string line = sr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a55610d7ebf5f8b7dbb67a4a79468730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59bbf0c89a1f480e440e4d7b2eeba0e/" rel="bookmark">
			多卡训练报错RuntimeError: The server socket has failed to listen on any local network address.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多卡训练报错 RuntimeError: The server socket has failed to listen on any local network address. The server socket 问题描述解决方案 问题描述 RuntimeError: The server socket has failed to listen on any local network address. The server socket has failed to bind to [::]:29500 (errno: 98 - Address already in use). The server socket has failed to bind to ?UNKNOWN? (errno: 98 - Address already in use). 解决方案 原因：训练的时候，已经有一张卡在执行训练，第二张卡执行训练任务时，使用了同一个端口
解决办法：修改第二张卡的端口号，与第一张卡使用的端口号不重复即可
参考1
或者不使用多卡训练了。使用DP模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b59bbf0c89a1f480e440e4d7b2eeba0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ef108e145efb48dd172278a3f0c9b2/" rel="bookmark">
			python3 编译指定openssl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：
完整步骤linux下安装python环境 - 知乎
由于系统中有已经配置好的openssl（1.0.2k），只是版本比较低,编译python3.8需要openssl-1.1.1k，所以在一个linux 系统中安装两个openssl，并在python编译时指定使用的openssl.
下载openssl：/source/old/1.1.1/index.html将压缩包放在指定的位置：然后编译。 ./config --prefix=/old-openssl-version-x.x.x --openssldir=/old-openssl-version-x.x.makesudo make install将编译好的so库，在lib64中创建软链接 ln -s /oldpath/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -s /oldpath/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1在编译安装的目录下的bin中，执行./openssl version 就可以看到需要的版本了，还不干扰系统自带的版本python在编译时指定openssl: ./configure --prefix=/python指定安装路径 --with-ssl=/openssl的bin路径 注意，在安装时，将需要的依赖安装上就好，如果不清楚需要哪些依赖，就先安装，然后根据报错，把依赖包补全。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab69c40a57c96e95574c8de821ad8cbd/" rel="bookmark">
			基于云技术的域名解析系统研究：传统解析技术的局限性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域名解析是互联网的一项重要基础作用，主要用于将域名翻译成计算机可识别的IP地址，完成对网络中其他主机的寻址任务。我们日常工作生活中的大部分网络应用，如网站访问、电子邮件以及其他各种web应用服务，都需要经过域名解析的寻址去完成。域名解析依靠分层结构的DNS系统，经过不同域DNS服务器的共同协作，最终完成域名解析的查询工作。
当客户主机对目标域名发起请求时，首先会请求客户主机所配置的递归服务器，递归服务器代替客户主机去进行全球的迭代查询。递归服务器首先请求根域名服务器，从根域名服务器获得顶级域名服务器的地址；递归服务器请求顶级域名服务器，获得域名授权的权威解析服务器的地址；递归服务器请求权威解析服务器，并将权威解析服务器给出的解析值返回给客户主机；客户主机根据解析值中的IP地址，对web服务器发起访问。
从以上的解析流程中可以看出，根域名服务器、顶级域名服务器主要充当“中介”的角色，最终由权威域名服务器给出最终的解析记录，权威解析服务器在整个解析环节中占据核心地位，但同时也对域名解析的速度和质量形成了制约。
在以往网络规模较小的情况下，传统的权威解析系统能够充分满足用户查询所需，但在当前流量剧增、网络环境复杂多变的今天，传统权威解析模式的诸多问题逐渐暴露出来。
DNS查询延迟
当前网页中的内容往往与多个业务系统进行嵌入式对接，因此在打开某个网页时可能需要从多个域名中获取页面信息，这就导致短时间内出现大量的DNS请求。传统权威解析系统一般由单台服务器提供解析服务，当客户主机距离权威服务器位置较远时，可能需要多个跳数才能完成解析数据的请求和应答，产生较大的解析时延，一个网页访问中出现多个域名解析时延的叠加，就可能产生比较明显的访问延迟，影响用户的上网体验。
轮询随机返回结果
传统权威解析技术不支持智能解析，即根据客户主机的地址匹配就近的web服务器，而是根据解析控制台设置的不同线路权重进行轮询，为客户主机随机返回一个地址，这就可能出现北京用户访问到上海服务器的情况，跨域带来的影响最终体现在网站响应时间的增加上。此外，由于权重轮询无法对访客所属运营商作出判断，因此可能会导致电信、移动、联通等不同运营商客户跨网访问web服务器情况的出现，同样会产生一定的访问延迟。
面临DNS攻击风险
由于权威服务器在互联网尤其是域名解析环节中扮演的重要角色，使其成为DNS攻击的重点目标，而其中DDoS攻击是比较普遍也是危害比较大的一种攻击方式。攻击者通过控制僵尸网络对权威服务器发起超大流量的解析请求，从而形成DDoS攻击。传统解析技术采用单台服务器，如果遭受DDoS攻击发生故障，就会影响其对所有管辖域名提供正常的域名解析服务。有的权威解析可能采用多台服务器，但多为相同自治域内域名，属于相同网段，这导致域名解析服务在DDoS攻击和网络故障下的应变能力下降。
应用场景受限
自2017年《互联网协议第六版（IPv6）规模部署行动计划》印发以来，我国IPv6产业发展迅速，目前IPv6活跃用户已达到7.6亿以上，占互联网网民总数的70%以上。为了满足快速增长的IPv6访问需要，越来越多的网站开始进行IPv6的升级改造，以实现IPv4和IPv6网络的互联互通。传统解析技术在早期没有考虑到IPv6的迅猛发展，导致相当一部分比例的权威服务器不支持AAAA记录或者不具备独立的IPv6地址，无法支持对IPv4和IPv6双栈网络的解析，在一定程度上制约了各行业网站向IPv6改造的进程。
综上来看，传统权威解析模式存在的种种局限性，最终影响到域名解析的速度、精度和安全性，成为域名解析和网络安全的一个薄弱环节。而随着IPv6网络的快速推进，物联网时代接入设备的急剧增加，域名解析将面临越来越复杂多样的网络场景，传统解析技术已经无法适应对安全解析、智能解析的现实需求，基于云技术的新一代解析系统正逐渐替代传统解析技术，应用于一些重点领域之中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c23084768880c7975074e5fb459804/" rel="bookmark">
			Vue.js项目部署至Linux服务器的详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在现代Web开发中，Vue.js作为一款流行的前端框架，为开发者提供了灵活且高效的工具。然而，在将Vue.js项目成功部署到Linux服务器上，可能需要一些额外的步骤和注意事项。本文将深入介绍在Linux服务器上部署Vue.js项目的详细步骤，确保你能够轻松地将你的前端应用投入生产环境。
步骤一：准备工作 在开始之前，请确保你的Linux服务器上已经安装了Node.js和npm。你可以通过以下命令检查它们的安装情况：
node -v npm -v 如果尚未安装，你需要按照官方文档提供的指南进行安装。
sudo apt install nginx # 对于基于Debian/Ubuntu的系统 sudo yum install nginx # 对于基于CentOS的系统 步骤二：Vue.js项目构建 在本地开发环境中，我们使用`npm run serve`启动开发服务器，但在生产环境中，我们需要构建Vue.js项目以生成优化的静态文件。使用以下命令构建项目：
npm run build 这将在项目根目录下生成一个`dist`文件夹，其中包含了你的静态文件。
步骤三：传输文件至服务器 使用`scp`或其他文件传输工具，将`dist`文件夹中的内容复制到你的Linux服务器上的目标目录。确保目标目录有适当的访问权限：
scp -r /path/to/local/dist user@your_server_ip:/path/to/target/directory 步骤四：配置Web服务器 你需要一个 Web 服务器来提供这些静态资源。你可以选择 Nginx 或 Apache。以下是使用 Nginx 作为 Web 服务器的示例配置。
创建一个新的 Nginx 配置文件来提供你的 Vue.js 应用。例如，创建一个名为vue-app的配置文件：
sudo nano /etc/nginx/sites-available/vue-app 在Nginx配置文件中添加一个新的server块：
server { listen 80; server_name your_domain.com; location / { root /path/to/target/directory; index index.html; try_files $uri $uri/ /index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1c23084768880c7975074e5fb459804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6774be374e357812ba916cf6b3e38951/" rel="bookmark">
			docker 容器中 bash: vi: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 最近因为某些原因需要在docker容器中使用vi和vim
进入容器后使用vi发现报错如下:
bash: vi: command not found 原因分析： 本来想着没有就用yum源下载一个结果发现yum源也没有，看了一下系统是ubantu系统。
解决方案： 使用了下面的命令
apt-get install vim 如果出现
E: Unable to locate package vim 直接使用
apt-get update 然后使用
apt-get install vim 这样就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df5cef694ac58008a653bfa9d8359dd/" rel="bookmark">
			D - Swapping Puzzle （交换i和i&#43;1行或者i和i&#43;1列使得a矩阵和b矩阵相同，用next_permutation函数和逆序对）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：https://atcoder.jp/contests/abc332/tasks/abc332_d
思想：首先交换行对列中的元素无影响，同理交换列对行的元素无影响。
我们用暴力枚举（两层next_premutation函数）来找到所有的排列方式，同时判断这种排列方式是否a矩阵与b矩阵相同，初始行数组和列数组是1-n，1-m，全排列之后，如果相同，用逆序对同时记录行变化了多少以及列变化了多少，并且不断更新最小的交换次数。
代码：
// Problem: D - Swapping Puzzle // Contest: AtCoder - AtCoder Beginner Contest 332 // URL: https://atcoder.jp/contests/abc332/tasks/abc332_d // Memory Limit: 1024 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 10; const int inf = 0x3f3f3f3f; int n,m; int a[N][N],b[N][N]; int row[N],col[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ cin&gt;&gt;a[i][j]; } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ cin&gt;&gt;b[i][j]; } } for(int i=1;i&lt;=n;i++){ row[i]=i; } for(int i=1;i&lt;=m;i++){ col[i]=i; } int res=inf; do{ do{ int flag=1; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(a[row[i]][col[j]]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0df5cef694ac58008a653bfa9d8359dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d58c488377a7eddfe4cd4dbaf7adf7/" rel="bookmark">
			Mongodb聚合操作中的$type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mongodb查询语句中，用户可以通过指定$type值，查询出的符合字段类型的文档数据。在mongodb聚合操作中，也存在$type操作符。本文就聚合操作中的$type进行介绍。
定义 返回一个表示传入参数BSON类型的字符串。在聚合操作中，按照下面的语法来返回类型信息
{$type: &lt;expression&gt;} 其中，expression可以是字段名称，运算等任何合法的表达式。
行为 与查询过滤器中的$type用法不同。聚合操作中的$type用来返回表达式中的结果类型。如当传入一个数组作为参数是，返回数组类型。
当指定字段名称作为参数时，当文档中不存在该字段时，$type返回字符串"missing"。
下面表格描述了传入不同参数时获取到的结果。
表达式
结果
{$type: "a"}
"string"
{$type: /a/}
"regex"
{$type: 1}
"double"
{$type: NumberLong(627)}
"long"
{$type: {x: 1}}
"object"
{$type: [ [1, 2, 3] ]}
"array"
其中，为了避免数组[1, 2, 3]被解析成参数列表，这里将数组转换成了字面意义。
应用 在集合coll中有下面6个文档。
db.coll.insertMany([ {_id: 0, a: 8}, {_id: 1, a: [ 41.63, 88.19]}, {_id: 2, a: {a: "apple", b: "banana", c: "carrot"}}, {_id: 3, a: "caribou"}, {_id: 4, a: NumberLong(71)}, {_id: 5}, ]) 使用聚合查询，查询字段a的类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d58c488377a7eddfe4cd4dbaf7adf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8bd123d43f608a34bb92bef96c44a86/" rel="bookmark">
			短视频矩阵系统：创新营销利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短视频在当前互联网行业中正逐渐崭露头角。短视频矩阵系统作为支撑短视频发展的重要工具，对于其运行和提升起着关键的作用。本文将围绕短视频矩阵系统这一主题进行探讨，并阐述其在现代营销领域中的潜力。
首先，我们需要明确什么是短视频矩阵系统。短视频矩阵系统是指在各个短视频平台上建立多个账号，并以不同形式和内容发布短视频，从而形成一个庞大的矩阵网络。短视频矩阵系统的核心目的是通过多渠道、高频次的宣传，提高品牌曝光度和用户粘性，从而实现营销效果的最大化。
那么，为什么短视频矩阵系统能够成为创新营销利器呢？首先，短视频平台的用户数量庞大。根据数据显示，短视频用户群体呈现出快速增长的趋势，尤其是年轻用户的使用率较高。这意味着通过短视频矩阵系统，企业可以将品牌信息传递给更多的目标用户，提高品牌知名度和美誉度。
其次，短视频矩阵系统具有创意和互动性。相比于传统的广告形式，短视频更具吸引力和趣味性，用户在观看短视频时更容易被内容所吸引。通过短视频矩阵系统，企业可以灵活运用不同的创意手法来制作和发布视频，从而吸引用户的注意力，使之产生共鸣和分享。同时，短视频矩阵系统也可以与用户进行互动，通过评论、点赞等方式促进用户参与度的提升。
再者，短视频矩阵系统可以实现营销效果的全面展示。通过建立多个账号，企业可以将不同的产品特点和营销策略展示给不同的用户群体，提供个性化的推荐和服务。这样一来，企业可以更好地了解用户需求和喜好，进而调整和优化自身产品和服务。同时，通过短视频矩阵系统，企业还可以及时了解用户反馈和意见，对用户的问题进行解答，提升用户满意度和品牌口碑。
最后，短视频矩阵系统能够提高营销效果的指标。短视频平台提供了详尽的数据分析工具，企业可以通过统计用户观看、评论、点赞等数据来评估和优化短视频的传播效果。这些数据将为企业提供重要的参考依据，从而帮助企业更好地制定营销策略和投入资源，提高ROI。
总而言之，短视频矩阵系统是当今互联网营销领域中的创新利器。通过多渠道、高频次的宣传，短视频矩阵系统能够提升品牌曝光度和用户粘性；通过创意和互动性，短视频矩阵系统能够吸引用户的注意力和参与度；通过全面展示和数据分析，短视频矩阵系统能够提高营销效果的指标。未来，随着短视频行业的进一步发展，短视频矩阵系统将会催生更多的商机和营销创新，成为企业竞争的利器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e35386557a8a189c12b6b03602cc6d/" rel="bookmark">
			【Kafka】Kafka客户端认证失败：Cluster authorization failed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 kafka客户端是公司内部基于spring-kafka封装的spring-boot版本：3.xspring-kafka版本：2.1.11.RELEASE集群认证方式：SASL_PLAINTEXT/SCRAM-SHA-512经过多年的经验，以及实际验证，配置是没问题的，但是业务方反馈用相同的配置，还是报错！ 错误日志 2023-12-21 18:00:44.051 [kafka-producer-network-thread | producer-1] INFO o.a.k.c.p.i.TransactionManager - [Producer clientId=producer-1] Transiting to fatal error state due to org.apache.kafka.common.errors.ClusterAuthorizationException: Cluster authorization failed. 2023-12-21 18:00:44.066 [http-nio-8082-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state] with root cause org.apache.kafka.common.errors.ClusterAuthorizationException: Cluster authorization failed. 2023-12-21 18:00:44.156 [kafka-producer-network-thread | producer-1] ERROR o.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65e35386557a8a189c12b6b03602cc6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca187d00a3b47f8d75d48223c28b12d0/" rel="bookmark">
			电脑病毒感染 - 华为OD统一考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OD统一考试
题解： Java / Python / C++
题目描述 一个局域网只内有很多台电脑，分别标注为 1 ~ N 的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用t 表示。
其中网络内一台电脑被病毒感染，求其感染网络内所有的电脑最少需要多长时间。如果最后有电脑不会感染，则返回-1。
给定一个数组 times 表示一台电脑把相邻电脑感染所用的时间: path[i] = {i, j, t} 表示: 电脑i 上的病毒感染 j，需要时间 t 。
输入描述 第一行输入一个整数N，表示局域网内电脑个数 N，1&lt;= N&lt;= 200 ；
第二行输入一个整数M, 表示有 M 条网络连接；
接下来M行, 每行输入为 i,j,t 。表示电脑 i 感染电脑 j 需要时间t。(1 &lt;= i, j &lt;= N)
最后一行为病毒所在的电脑编号。
输出描述 输出最少需要多少时间才能感染全部电脑，如果不存在输出 -1
示例1 输入： 4 3 2 1 1 2 3 1 3 4 1 2 输出： 2 示例2 输入： 4 3 2 1 1 2 3 1 3 4 1 3 输出： -1 题解 经典的最短路径问题，使用 Dijkstra 算法求解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca187d00a3b47f8d75d48223c28b12d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34c4b8b1fb2c889cbe2f78d5056f1c7/" rel="bookmark">
			【xdma】 pcie.bar设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA优质开源项目– PCIE通信 xdma
两者保持一致
FPGA开源项目 – PCIE I/O控制卡 xdma
PCIe的XDMA应用
读写部分分为两种，一种是数据的读写，另一种是配置数据的读写，在数据读写部分，DMA通过MIG控制DDR完成数据读写。配置数据读写通过与BRAM通过AXI-lite总线连接完成，XDMA将PCIe配置信息存在BRAM，在进行配置信息读写时，将传入主机映射到用户逻辑的地址，然后与偏移地址处理（物理地址=段地址&lt;&lt;4+偏移地址），所以在bram设置时需要将其偏移地址设置的与主机地址映射的偏移地址相同。
对于DDR则不必，设置的话还减少了可使用的内存空间，只是一个袋子，写在哪里就从哪里读取即可，必须设置为0。
此处将配置信息存储到BRAM，通过AXI-lite总线读写Bram。
（1）、BAR为32bit，不使能64bit，prefetchable表示预读取，不使能。
（2）、映射空间选择1M，大小随意。
（3）、PCIe to AXI Translation：主机侧BAR地址与用户逻辑侧地址不同，通过设置转换地址实现BAR地址到AXI地址的转换。比如主机一侧BAR地址为0，则主机访问BAR地址0转换到AXI-Lite总线就是0x8000_0000.
PCIe to DMA Interface：数据传输宽度64bit，DMA控制器一般只支持数据8字节对齐的情况。
当数据从上位机通过PCIe接口发送到端点设备，XDMA内部自行解包对将数据与指令进行分析，得到读写操作的指令地址，并对DDR进行读写操作。操作的结果通过AXI接口返回XDMA，XDMA对数据进行组包，之后通过物理层发出，实现数据的DMA控制。
DMA的bar不需要映射ddr大小的空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a91226e5ea3e8f4ffe09ca0c1f9208c/" rel="bookmark">
			软考软件设计师学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
进制转换
按权展开法
短除法
减法
8421法
码制
数据的表示-原/反/补/移码
浮点数的表示
运算过程
特点
逻辑运算
关系运算符
逻辑运算符
校验码概述
奇偶校验码
CRC循环冗余校验码
海明校验码
奇偶校验码
CRC循环冗余校验码
海明校验码
CPU组成（运算器与控制器）
运算器 控制器
寻址方式
指令的基本概念
CISC与RISC
流水线技术
存储系统概述
层次化存储
层次化存储结构
层次化存储结构-分类
Cache
Cache-概念
Cache-映像
Cache-直接相联映像
Cache-全相联映像
Cache-组相联映像
总体表格
主存编址计算
编址
编址与计算
存储单元
编址内容
总容量
输入/输出技术
总线
可靠性
性能指标
计算机组成与体系章节回顾
操作系统章节概述
操作系统概念概述
操作系统的作用
特殊的操作系统
进程的概念
进程的状态
进程调度 PV的概念
信号量与PV操作
前驱图与PV操作
死锁资源数计算
进制转换 进制数码基数位权十进制（D）0,1,2,3,4,5,6,7,8,91010^k二进制（B）0,122^k十六进制（H）0~9,A,B,C,D,E,F1616^k 按权展开法 作用场景：R进制转十进制
解释：将R进制按权展开后相加
如二进制：10100.01=1*2^4+0*2^3+1*2^2+0*2^1+0*2^0+0*2^-1+1*2^-2
这种方法也可以先将10100.01当成十进制，如：10100.01=1*10^4+1*10^2+1*10^-2
然后再把10^k这个位权变成R^k，这样就能做到快速转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a91226e5ea3e8f4ffe09ca0c1f9208c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24467371b2c3dc7bc992bf88981c64a8/" rel="bookmark">
			git强制pull
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git fetch --all git reset --hard origin/master master为仓库分支
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4a0d345e3c354bc2775bae494eae00/" rel="bookmark">
			【EI、scopus稳定检索】2024年软件工程，网络与电力科学国际会议（ICSENPS 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【EI、scopus稳定检索】2024年软件工程，网络与电力科学国际会议（ICSENPS 2024） 2024 International Conference on Software Engineering, Networks, and Power Science
2024年软件工程，网络与电力科学国际会议（ICSENPS 2024）将在武汉举行。会议旨在为从事管理和软件工程领域的专家、学者、工程技术人员和技术研究人员提供一个平台，分享科学研究成果和前沿技术，了解学术发展趋势，拓宽研究思路，加强学术研究和探索，促进学术成果产业化合作。大会诚挚邀请国内外高校专家、科研机构专家、学者、工商界人士及其他相关人员参加交流。 大会主题：
软件架构
软件设计方法
软件领域建模
软件工程决策支持
软件测试技术
自动化的软件设计和合成
计算机工程
计算机软件
自动化的软件设计和合成
软件代理技术
电子政务工程
移动/无线计算/人工智能再造
逆向工程
设计与过程工程
科学/软件测试技术
软件重用和度量
测量技术与仪器
5G通信与网络
遥感和卫星通信
线传感器和通信网络
通讯渠道和移动设备
网络和信息安全技术
卫星通信技术
现代光纤通信技术
汇编语言程序设计
机电一体化和机器人
MEMS-微型传感器和结构
微型机械
信号处理
电力电子和电力驱动
电力市场与电力系统经济学
功率优化
电能质量和电磁兼容性
电力系统及其自动化
电力系统建模、仿真和分析
电力系统规划与调度
电力系统保护、运行和控制
电力系统可靠性和安全性
电力系统稳定性
电力系统和能源
电力系统放松管制
电力牵引系统和控制
电磁与应用超导
电磁兼容
电磁暂态程序
电子材料
电子、信息和控制系统
电工技术
高压及绝缘技术
高压工程及绝缘技术
工业过程控制和自动化
信息技术应用
智能控制系统
智能系统和方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4a0d345e3c354bc2775bae494eae00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30f6286dcd67cdc54992e1340c0de7f/" rel="bookmark">
			Flink项目实战篇 基于Flink的城市交通监控平台（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Flink项目实战篇 基于Flink的城市交通监控平台（上）
Flink项目实战篇 基于Flink的城市交通监控平台（下）
文章目录 系列文章目录4. 智能实时报警4.1 实时套牌分析4.2 实时危险驾驶分析4.3 出警分析4.4 违法车辆轨迹跟踪 5. 实时车辆布控5.1 实时车辆分布情况5.2 布隆过滤器(Bloom Filter)5.3 实时外地车分布情况 4. 智能实时报警 本模块主要负责城市交通管理中，可能存在违章或者违法非常严重的行为，系统可以自动实时报警。可以实现亿级数据在线分布式计算秒级反馈。满足实战的“实时”需要，争分夺秒、聚力办案。做的真正“零”延迟的报警和出警。主要功能包括：实时套牌分析，实时危险驾驶分析等。
4.1 实时套牌分析 当某个卡口中出现一辆行驶的汽车，我们可以通过摄像头识别车牌号，然后在10秒内，另外一个卡口（或者当前卡口）也识别到了同样车牌的车辆，那么很有可能这两辆车之中有很大几率存在套牌车，因为一般情况下不可能有车辆在10秒内经过两个卡口。如果发现涉嫌套牌车，系统实时发出报警信息，同时这些存在套牌车嫌疑的车辆，写入Mysql数据库的结果表中，在后面的模块中，可以对这些违法车辆进行实时轨迹跟踪。
本需求可以使用CEP编程，也可以使用状态编程。我们采用状态编程。
完整的代码：
object RepatitionCarWarning { def main(args: Array[String]): Unit = { val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment //导入scala包 import org.apache.flink.streaming.api.scala._ //设置并行度 env.setParallelism(1) //设置事件时间 env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val props = new Properties() props.setProperty("bootstrap.servers","mynode1:9092,mynode2:9092,mynode3:9092") props.setProperty("group.id","test4") props.setProperty("key.deserializer",classOf[StringDeserializer].getName) props.setProperty("value.deserializer",classOf[StringDeserializer].getName) val trafficDStream: DataStream[TrafficLog] = env.addSource(new FlinkKafkaConsumer[String]("traffic-topic", new SimpleStringSchema(), props).setStartFromEarliest()) // val trafficDStream: DataStream[TrafficLog] = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30f6286dcd67cdc54992e1340c0de7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63094b7fabdab3879dadc78ef27ab240/" rel="bookmark">
			设计模式之-桥梁模式，快速掌握桥梁模式，通俗易懂的讲解桥梁模式以及它的使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、快速掌握桥梁模式二、使用场景三、代码示例五、 桥梁模式的优点包括：听一个故事来讲解桥梁模式，加深理解 一、快速掌握桥梁模式 设计模式中的桥梁模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与实现部分分离，使它们可以独立地变化。桥梁模式的核心思想是通过组合而不是继承来实现不同维度的变化。
通俗地说，桥梁模式就像是一座桥，将两个不同的维度连接在一起。其中，一个维度是抽象部分（Abstraction），它定义了高层业务逻辑，并包含对实现部分的引用；另一个维度是实现部分（Implementation），它定义了底层实现的接口。
通过桥梁模式，我们可以在两个维度上独立地变化和扩展，而不会相互影响。这种解耦的设计使得系统更加灵活，易于维护和扩展。
二、使用场景 当一个类存在两个独立变化的维度时，使用桥梁模式可以将这两个维度进行解耦，使得它们可以独立地变化。当需要在多个对象间共享实现时，使用桥梁模式可以减少子类的数量，提高系统的可扩展性。当一个类需要在运行时切换不同的实现时，桥梁模式可以实现运行时的动态切换。 三、代码示例 下面是一个简单的示例代码来说明桥梁模式的应用：
// 实现部分接口 interface DrawingAPI { void drawCircle(double x, double y, double radius); } // 具体的实现部分 class DrawingAPI1 implements DrawingAPI { @Override public void drawCircle(double x, double y, double radius) { System.out.printf("API1.drawCircle at (%.2f, %.2f) with radius %.2f%n", x, y, radius); } } // 具体的实现部分 class DrawingAPI2 implements DrawingAPI { @Override public void drawCircle(double x, double y, double radius) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63094b7fabdab3879dadc78ef27ab240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61db86a57b550e9e2e0e169b634ab141/" rel="bookmark">
			Binder系列-service_manager.c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. service_manager的任务 open 驱动告诉驱动，它是“servicemanager”在一个循环里
从驱动读取数据
解析数据
调用，根据code执行注册服务或者获取服务 （图来自韦老师的视频）
2.代码流程 2.1.open驱动 //frameworks\native\cmds\servicemanager\service_manager.c int main(int argc, char **argv) { struct binder_state *bs; bs = binder_open(128*1024); //第一步打开驱动 if (!bs) { ALOGE("failed to open binder driver\n"); return -1; } //其他代码省略 return 0; } 2.2.告诉驱动，它是“servicemanager” binder_become_context_manager
//frameworks\native\cmds\servicemanager\service_manager.c int main(int argc, char **argv) { struct binder_state *bs; bs = binder_open(128*1024); //第一步打开驱动 if (!bs) { ALOGE("failed to open binder driver\n"); return -1; } if (binder_become_context_manager(bs)) { //第二步告诉驱动，它是ServiceManager ALOGE("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61db86a57b550e9e2e0e169b634ab141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b203747cb92fb3e39517b5e511299e90/" rel="bookmark">
			基于51单片机的八路抢答器（普中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于51系列单片机的八路抢答器设计通常包括以下几个主要部分： 1. **硬件设计：** **控制器选择：** 通常会选择STC89C52或其他类似的51系列单片机作为核心控制器，因为它具有足够的输入输出端口和内置定时器/计数器资源来处理抢答器的功能需求。
**输入模块：** 设计8个独立的抢答按钮，每个按钮对应一个选手。这些按钮连接到单片机的输入端口，当选手按下按钮时，单片机可以检测到相应的输入变化。
**输出模块：** 包括显示模块和指示灯。显示模块是LED数码管，用于显示抢答结果、计时信息和选手分数。指示灯通常用于表示哪个选手正在回答。
**定时器/计数器：** 利用单片机的定时器/计数器实现抢答计时。例如，可以设定一个定时器可调节分钟和秒，在主持人宣布开始后开始计时，一旦有选手抢答，立即停止计时并记录抢答时间。
2. **软件设计：** **主程序：** 主程序负责初始化各个硬件模块，设置定时器参数，并进入等待抢答的状态。
**中断服务程序：** 当有选手按下抢答按钮时，会产生一个中断请求。中断服务程序会立即响应，停止定时器，判断是否为有效抢答（如是否在规定时间内），然后更新显示和指示灯状态。
**计分和显示子程序：** 根据抢答结果和规则更新选手的分数，并通过显示模块显示出来。
**犯规处理子程序：** 如果有选手在主持人宣布开始前抢答，或者在其他选手已经抢答后再次抢答，会被判定为犯规。犯规处理子程序会进行相应的扣分或禁赛等操作。
3. **功能特性：** （必须看！！！！！） **八路抢答：** 允许最多8位选手同时参与抢答。
**抢答成功提示：** 抢答成功会有一段时间蜂鸣器提醒。
**抢答时间调整：** 抢答的允许时间可以根据需要进行调整分钟和秒。
在实际设计过程中，还需要考虑电路的抗干扰能力、电源稳定性、用户界面友好性等因素。此外，为了方便调试和测试，可以使用仿真软件进行系统仿真和调试。
具体按键功能
模块化编程，注释清晰 /*************************** 闲鱼搜索：科创工作室 ***************************/ #include &lt;REGX52.H&gt; #include &lt;Delay.h&gt; #include &lt;juzheng.h&gt; #include &lt;ledliang.h&gt; #include &lt;Timer0.h&gt; char miao=20,fen=2; unsigned char flag1=0,s0_flag=0,k_flag=0,flag2=0,flag3=0; unsigned char keynumber; int beepnum=0; sbit beep=P2^5; sbit k1=P3^1; sbit k2=P3^0; sbit k3=P3^2; sbit k4=P3^3; void key_scan() { if((k1==0)&amp;&amp;(flag2==0)) //调试界面时间切换 flag1：0调试分钟界面 1调试秒钟界面 { ET0=0; Delay(200); flag1++; if(flag1&gt;=2) { flag1=0; } } if((k4==0)&amp;&amp;(flag2==0)) //切换界面 flag3：0调试 1抢答 { flag3=1; if(s0_flag==0) //判断界面标志位 在抢答界面的话就进行抢答 否则无操作 { ET0=1; } if(s0_flag==1) { s0_flag=0; } } } 普中板子展示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b203747cb92fb3e39517b5e511299e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f35c3395902d08e5d648a9ba57cd34/" rel="bookmark">
			2024 年软件工程将如何发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件开发目前正在经历一场深刻的变革，其特点是先进自动化的悄然但显着的激增。这一即将发生的转变有望以前所未有的规模简化高质量应用程序的创建和部署。
它不是单一技术引领这一演变，而是创新的融合。从人工智能(AI) 和数字孪生技术，到植根于DevOps原则的平台工程，到增强弹性的混沌工程技术，再到扩大使用内部开发人员门户以提高生产力，创新正在结合起来，彻底改变软件工程的各个方面。
挑战和机遇在于有效利用这些能力，使组织能够培养他们的 DevOps 文化。这种转变将简化软件交付，涵盖基于云的系统到边缘计算平台。​
人工智能和数字孪生实现 DevOps 自动化 各种形式的人工智能正在稳步渗透到应用程序开发工具和 DevOps 平台中。然而，到目前为止，人工智能集成到开发工具中的速度比集成到 DevOps 平台中的速度快，这可能会导致不平衡。代码库的增长超出了 DevOps 团队跟上步伐的能力。
然而，注入人工智能并在云端运行的下一代 DevOps 平台即将出现。到 2024 年初，devops 团队将能够使用自然语言界面部署应用程序以参与大型语言模型(LLM)。这些法学硕士将接受培训，以自动执行各种手动任务，利用人工智能进行 IT 运营 ( AIOps ) 来消除目前困扰应用程序开发的瓶颈。
除了人工智能的这些突破性进步之外，数字孪生技术也被应用于应用程序部署。Devops 团队很快将通过简化 DevOps 工作流程管理的可视化界面从更高级别的抽象中受益。这一推动的核心是使用数字孪生技术创建并与自动化框架无缝集成的 IT 环境模型。不久之后，这些模型将被嵌入到持续集成和持续交付（CI/CD）平台中。
当与人工智能结合时，这些数字孪生技术将自动推断模型之间的关系。他们将生成代码并根据需要动态配置应用程序和基础设施。此外，实时反馈循环将提供对配置可行性的洞察，使部署更加透明。
最终目标是为 DevOps 环境提供一定程度的抽象，从而消除大部分复杂性。这将使更广泛的组织能够采用 DevOps 最佳实践。从本质上讲，DevOps 正处于数字化转型的风口浪尖，就像我们在许多其他流程中见证的现代化一样。
平台工程提高了开发人员的生产力 DevOps 不仅取决于工具和平台，还取决于文化。平台工程已成为一种集中 DevOps 流程和工作流管理的方法。平台工程的倡导者主张消除冗余的 DevOps 平台，转而采用统一的 CI/CD 平台作为企业标准。这种方法有望大规模管理 DevOps 工作流程，同时降低总体 IT 成本。
平台工程在提高开发人员生产力方面也发挥着关键作用。由精通 DevOps 最佳实践的平台工程团队提供的开发人员门户使开发人员能够在明确定义的边界内自助服务其需求，从而提高代码质量和安全性。平台工程师作为这些门户的管理者，消除了开发人员构建和维护应用程序开发环境时经常遇到的摩擦。
投资平台工程的主要动机是提高开发人员的生产力，在当前充满挑战的经济环境中，吸引和留住开发人员变得越来越困难，这是一个至关重要的考虑因素。
混沌工程与 CI/CD 集成 除非 IT 环境作为一个整体变得更有弹性，否则这些技术或文化进步都不会产生实质性成果。混沌工程已成为一门 DevOps 学科，它严格测试分布式计算系统承受不可预见的中断的能力。这是通过故意破坏组件来完成的。通过系统地揭示弱点，混沌工程为开发运营团队提供了对其应用程序环境的深刻洞察，可以利用这些洞察来增强从网络安全到成本效率的各个方面。
挑战在于如何将混沌工程工具和平台无缝集成到现有的 DevOps 工作流程中，而不会导致组织停机。实现这一目标的最自然途径是用于构建、部署和测试应用程序的 CI/CD 平台。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f35c3395902d08e5d648a9ba57cd34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e59007c9fb48c3aebd1201bc85b70d/" rel="bookmark">
			新能源光伏行业CRM：推动绿色能源发展与高效客户管理的双重突破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着“碳中和”计划以及传统能源价格的不断飙升，我国新能源光伏产业在国家“双碳”战略目标和市场需求的双重驱动下高歌猛进，中国光伏产业新增装机量、累计装机量连续多年位居全球首位。CRM在光伏产业中的作用也日益突出。下面为您介绍新能源光伏行业的CRM解决方案。
行业概述 光伏企业是指从事光伏产品研发、制造和销售的企业。
光伏产业的快速发展同时也伴随着数字化的创新，数字化转型能够赋予企业新的竞争优势。对于现阶段的光伏产业而言，数字化带来的全生命周期监控管理、生产和工艺流程可视化、以及降本增效是光伏、乃至新能源行业最直观的变化。
光伏产品主要包括太阳能电池板、组件、逆变器、控制器、蓄电池等，应用于太阳能光伏发电系统。这些产品的制造和销售需要经过多个环节和流程，包括原材料采购、生产加工、组装测试、安装调试等。
行业解决方案 新能源光伏行业的产业链比较长、涉及配件多，所以针对光伏产业的CRM解决方案也需要有实力的企业才能提供。
依托新能源CRM多年在全球企服市场的积淀，面向企业数字化转型与升级、企业市场全球化发展等实际场景，旨在以开放、灵活的技术优势，充分满足当下企业运营及管理的需求。
该解决方案以CRM为核心，帮助企业从粗放模式转为精细化生产，涉及到多人协作、任务交办、过程数据记录、数据分析与共享。通过销售自动化、全渠道沟通、绩效管理等功能模块进行项目跟进。
新能源CRM软件的优点 一、 简单易用：SaaS 模式的CRM系统是在云端运行的，只需注册一个账号即可直接使用，同时拥有手机端CRM移动版。UI界面简洁清新，且支持自定义界面。
二、 快速部署：注册账号的同时获取了管理员权限，在设置里可以创建不同角色和对应的权限，搭建公司的组织架构，将不同岗位人员分配在不同的流程环节上，并且设置不同的操作权限，就像是将公司搬到了网络上一样，部署非常的便捷。
三、 定制灵活：无论你是什么行业，使用哪种类型的销售流程和管理模式，在CRM系统里添加自定义模块和字段，就可以生成符合自己行业和公司的工作流和审批流等一系列流程，绘制整个企业管理过程的蓝图，并且任何时间都可以调整这些模块和字段。
四、 高性价比：为了扶持广大的小微企业，部分厂商推出了免费版，功能依然强大，如果公司正在创业期，CRM免费版足够用了。而对于中大型企业有高级版和旗舰版供选择，系统会不定期更新功能和用户体验，一次付费即可终生享有。
五、 高扩展性：客户管理系统并非只是独立的系统，同时集成了其它云服务功能，涉及到财务、开发、营销、客服等，通过数据接口将企业各个部门串联起来，实现数据互通，并且为其他第三方软件提供接口，例如呼叫中心、短信平台等。为什么厂商可以做到这一点，因为他们拥有自主研发团队，核心技术掌握在自己手里。
六、 AI智能：当AI智能融入CRM系统，让你快人一步。目前CRM已经植入了“销售助理-Zia”，简单的举个例子，当你给用户群发营销邮件时，Zia会自动分析邮件打开率和打开时间，并提醒你哪个时间发送邮件打开率会更高。Zia会的东西还有很多，帮助你在正确的路上做正确的事，工作效率翻番。
CRM解决方案示例
CRM厂商将更加专注于产品力的提升，以成熟的技术体系与优质的产品服务，持续为市场输出切实可行的解决方案。愿与广大能源企业携手超越，为新能源光伏行业提供更加有效的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241e19adec00ac6520a0d20e77751284/" rel="bookmark">
			数据结构常见算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图的广度遍历 初始化visited[]数组for 对未访问过的顶点调用广度优先遍历算法广度优先遍历 先将参数送进来的序号对应的visited[v]置为true，并将v入队队列Q不空时循环：遍历Q中元素，并将未访问过的边表结点入队 bool visited[max_vex_num]; void BFSTraverse(Graph G){ //初始化访问数组 for(int i = 0; i&lt; G.vexnum; i++) visited[i] = false; //广度遍历每个未访问过的节点 for(int v = 0; v &lt; G.vexnum; v++) if(!visited[v]) BFS(G,v); } void BFS(Graph G, int v){ int p; int Q[G.vexnum]; int front = 0, rear = 0; //先访问进来的节点，并入队 visit(v); visited[v] = true; Q[rear++] = v; while(front != rear){ p = Q[front++]; for(int w = FirstNeighbor(G,p); w&gt;=0; w = NextNeighbor(G,p,w)){ //访问未被访问过的边表节点，并入队 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/241e19adec00ac6520a0d20e77751284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0cfc8138048802565e2b111a9a610c/" rel="bookmark">
			easypoi 校验导入excel 将校验不通过字段返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cn.afterturn.easypoi.excel.ExcelImportUtil; import cn.afterturn.easypoi.excel.entity.ImportParams; import cn.afterturn.easypoi.excel.entity.enmus.ExcelType; import cn.afterturn.easypoi.excel.entity.result.ExcelVerifyHandlerResult; import cn.afterturn.easypoi.handler.inter.IExcelVerifyHandler; import java.io.File; import java.util.List; public class ExcelVerifyDemo { public static void main(String[] args) { // 指定Excel文件路径 String filePath = "path/to/your/excel/file.xlsx"; // 导入Excel数据 ImportParams params = new ImportParams(); params.setTitleRows(1); params.setHeadRows(1); params.setVerifyHandler(new MyVerifyHandler()); // 设置自定义校验处理器 List&lt;ExcelData&gt; dataList = ExcelImportUtil.importExcel(new File(filePath), ExcelData.class, params); // 处理校验结果 for (ExcelData data : dataList) { if (data.getVerifyResult() != null &amp;&amp; !data.getVerifyResult().isSuccess()) { System.out.println("校验不成功的数据：" + data); } } } // 定义Excel数据模型类 public static class ExcelData { // 标记需要校验的字段 @NotNull private String columnA; @Length(min = 5, max = 10, message = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f0cfc8138048802565e2b111a9a610c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9170ff4ca34259a80f962fcc63acc96/" rel="bookmark">
			Spring Boot 之helloworld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 是一个基于 Spring 框架的开源框架，它可以帮助开发者快速、高效地搭建一个 Spring 应用程序。下面是 Spring Boot 的简单使用说明：
安装 Java 开发环境和 Maven；在 Maven 中添加 Spring Boot 的依赖；创建一个 Spring Boot 应用程序入口类；在入口类中添加 Spring Boot 的相关注解，例如 @SpringBootApplication；编写业务代码和配置文件；运行 Spring Boot 应用程序。 具体操作步骤如下：
安装 Java 和 Maven： 如果你未安装 Java 和 Maven，你可以参考以下链接进行安装和配置：
Java 安装：https://www.oracle.com/java/technologies/javase-downloads.html
Maven 安装：https://maven.apache.org/install.html
在 Maven 中添加 Spring Boot 的依赖： 在 pom.xml 文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/dependency&gt; 这个依赖可以帮助你导入 Spring Boot 的核心包和一些常用的依赖库。
创建一个 Spring Boot 应用程序入口类： 创建一个 Java 类，命名为 Application，这个类应该包含一个 main() 方法。Spring Boot 应用程序总是从这个 main() 方法开始执行。在这个类中，你需要使用 @SpringBootApplication 注解来注释这个类，并使用 SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9170ff4ca34259a80f962fcc63acc96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99d8b9a91569b69821093d06640449b/" rel="bookmark">
			Flask 日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flask 日志 代码源码源自编程浪子flask点餐小程序代码
记录用户访问日志 和 错误日志 这段代码是一个基于Flask框架的日志服务类，用于 记录用户访问日志 和 错误日志。代码中定义了一个名为LogService的类，其中包含了两个静态方法：addAccessLog 和 addErrorLog。
addAccessLog方法用于记录用户的访问日志。在该方法中：
首先创建一个AppAccessLog实例化对象target，并将请求的URL、引用URL、IP地址、查询参数等信息赋值给相应的属性。如果当前用户已登录，则将用户ID也赋值给uid属性。然后获取请求的User-Agent，并赋值给ua属性。最后，将target对象添加到数据库会话中，并提交事务。
addErrorLog方法用于记录错误日志。在该方法中：
首先判断请求的URL是否为favicon.ico，如果是则直接返回。然后创建一个AppErrorLog对象target，并将请求的URL、引用URL、查询参数、错误内容等信息赋值给相应的属性。最后，将target对象添加到数据库会话中，并提交事务。
这段代码的作用是在用户访问网站时记录访问日志和错误日志，以便后续进行分析和排查问题
common/libs/LogService.py # -*- coding: utf-8 -*- from flask import request,g from application import app,db import json from common.libs.Helper import getCurrentDate from common.models.log.AppAccessLog import AppAccessLog from common.models.log.AppErrorLog import AppErrorLog class LogService(): @staticmethod def addAccessLog(): target = AppAccessLog() #target_url 访问的url target.target_url = request.url #referer_url 当前访问的refer target.referer_url = request.referrer # remote adj，（计算机）远程的、遥控的 target.ip = request.remote_addr target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f99d8b9a91569b69821093d06640449b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2436b87bd7e9953871ef5a90963670d/" rel="bookmark">
			Java String.format 保留小数点后几位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 String.format(“%.2f”, (double) 100.9) 解析：
保留小数点后两位；不够两位补0；超过两位的只留两位，第二位按照第三位的值四舍五入。 运行示例，
public class TestFormat2 { public static void main(String[] args) { System.out.println(String.format("%.2f", (double) 100)); System.out.println(String.format("%.2f", (double) 100.9)); System.out.println(String.format("%.3f", (double) 200)); System.out.println(String.format("%.3f", (double) 200.01)); System.out.println(String.format("%.3f", (double) 200.1234)); System.out.println(String.format("%.3f", (double) 200.1236)); } } 结果，
100.00 100.90 200.000 200.010 200.123 200.124 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35fa5e9e3b6bcd7bce52d47f6b3f228/" rel="bookmark">
			java 多线程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 多线程是 Java 编程语言中的一个重要特性，它允许程序同时执行多个任务。多线程在提高程序性能、提升用户体验等方面有着重要的作用。
在 Java 中，多线程可以通过继承 Thread 类或实现 Runnable 接口来创建。下面是创建多线程的两种方法的详细说明：
继承 Thread 类：
创建一个继承自 Thread 类的子类。重写 Thread 类的 run() 方法，在此方法中定义线程的执行逻辑。创建线程对象，并调用 start() 方法来启动线程。例如：
class MyThread extends Thread { public void run() { // 线程的执行逻辑 } } public class Main { public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); } } 实现 Runnable 接口：
创建一个实现 Runnable 接口的类。实现 Runnable 接口的 run() 方法，在此方法中定义线程的执行逻辑。创建线程对象，并传入实现了 Runnable 接口的类实例。调用线程对象的 start() 方法来启动线程。例如：
class MyRunnable implements Runnable { public void run() { // 线程的执行逻辑 } } public class Main { public static void main(String[] args) { Thread thread = new Thread(new MyRunnable()); thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35fa5e9e3b6bcd7bce52d47f6b3f228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7115628547aceff1ca66d3532a19e659/" rel="bookmark">
			雪花算法生成id重复的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雪花算法是一种分布式ID生成算法，用于生成全局唯一的ID。它的原理是通过将一个64位的ID分为不同的部分，分别表示不同的参数，以保证ID的全局唯一性。一般来说，雪花算法生成的ID是不会重复的，但是在实际应用中，也存在一些可能导致ID重复的情况，下面详细说明其中的坑：
1. 时钟回拨：雪花算法的第一部分是一个时间戳，其中包含了41位表示毫秒级时间戳的字段。如果系统时钟发生回拨，即当前时间小于上一次生成ID的时间，会导致生成的ID重复。为了解决这个问题，可以采用一些策略，如等待时钟追赶上去，或者拒绝生成ID。
2. 并发生成ID：雪花算法在同一毫秒内可以根据机器ID和序列号生成多个ID。但是如果同一毫秒内，并发生成的ID超过了序列号的范围（12位），则会导致序列号部分重复。为了解决这个问题，可以限制并发生成ID的线程数量或者等待下一毫秒再生成ID。
3. 机器ID重复：雪花算法的第二部分是机器ID，用来表示不同的机器。如果部署的多台机器使用了相同的机器ID，则会导致生成的ID重复。为了避免这个问题，需要保证每台机器使用唯一的机器ID。
4. 序列号溢出：雪花算法的最后一部分是序列号，用来表示同一毫秒内并发生成的ID。如果序列号部分的位数不够，即超过了序列号的范围（12位），则会导致序列号部分重复。为了解决这个问题，可以等待下一毫秒再生成ID，或者使用更长的序列号位数。
总之，雪花算法生成的ID在理论上是不会重复的。但是在实际应用中，还是需要注意以上几个问题，采取相应的策略来处理可能导致ID重复的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712102b862944296f8c7ed3dccf53463/" rel="bookmark">
			ORB-SLAM3的Local&amp;MapMerging线程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORB-SLAM3的Local&amp;MapMerging线程的代码主要集中于LocalClosing.cc的run()函数中，主要执行五个函数分别是：CheckNewKeyFrames() 函数、NewDetectCommonRegions()函数、MergeLocal()函数、MergeLocal2()函数、CorrectLoop() 函数。如果新进入的关键帧，在闭环检测的过程中，如果是当前地图下的，不用进入MergeLocal()函数和MergeLocal2()函数，直接做闭环校正；在非当前地图下，先做地图合并，再做闭环校正。
类型函数boolCheckNewKeyFrames()boolNewDetectCommonRegions()voidMergeLocal()voidMergeLocal2()voidCorrectLoop() 文章目录 一、LocalClosing的run()函数1、CheckNewKeyFrames()2、NewDetectCommonRegions()3、MergeLocal()4、MergeLocal2()5、CorrectLoop() 二、代码详解1、LoopClosing.h（1）参数（2） 主函数Run()（3） 插入关键帧函数InsertKeyFrame()（4） 运行全局BA优化函数RunGlobalBundleAdjustment()（5）是否有关键帧插入函数bool CheckNewKeyFrames()（6）检测闭环函数()bool NewDetectCommonRegions();（7）最后一帧中计算相似度()bool DetectAndReffineSim3FromLastKF();（8）通过词袋去计算相似度函数()bool DetectCommonRegionsFromBoW(); 2、LoopClosing.cc 一、LocalClosing的run()函数 1、CheckNewKeyFrames() 检查队列mlpLoopKeyFrameQueue是否有未处理的关键帧
这个函数和局部建图线程是一样的，首先看队列里是否插入关键帧。对于局部建图线程是跟踪线程给的关键帧，那么对于闭环和地图合并线程是局部建图线程给的关键帧。所以观察是否有未处理的关键帧，如果有，往后执行。
2、NewDetectCommonRegions() 实现闭环检测
布尔函数，在函数中确定有无闭环，有闭环就地图合并。
3、MergeLocal() 非当前地图闭环情况下，纯视觉模式的地图合并与校正
纯视觉误差为重投影误差
4、MergeLocal2() 非当前地图闭环情况下，IMU模式的地图合并与校正
对IMU情况， 考虑IMU误差和视觉的重投影误差
5、CorrectLoop() 当前地图闭环情况下，闭环校正
二、代码详解 1、LoopClosing.h （1）参数 LoopClosing(Atlas* pAtlas, KeyFrameDatabase* pDB, ORBVocabulary* pVoc,const bool bFixScale, const bool bActiveLC); 函数功能Atlas多地图系统KeyFrameDatabase关键帧库ORBVocabularyORB词袋bFixScale是否固定大小bActiveLC主动闭环检测 （2） 主函数Run() void Run(); 检查是否有执行关键帧到闭环和地图合并线程，闭环检测，地图合并，闭环校正
（3） 插入关键帧函数InsertKeyFrame() void InsertKeyFrame(KeyFrame *pKF); 将关键帧插入线程
（4） 运行全局BA优化函数RunGlobalBundleAdjustment() void RunGlobalBundleAdjustment(Map* pActiveMap, unsigned long nLoopKF); 涉及参数：主动图pActiveMap和闭环关键帧nLoopKF
（5）是否有关键帧插入函数bool CheckNewKeyFrames() 核心函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/712102b862944296f8c7ed3dccf53463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9aa14108dd7898532c24a5b439c3ef3/" rel="bookmark">
			K8S的二进制部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S的源码包部署 搭建准备：
k8smaster01：20.0.0.32 kube-apiserver kube-controller-manager kube-scheduler etcd k8smaster02：20.0.0.33 kube-apiserver kube-controller-manager kube-scheduler node节点01：20.0.0.34 kubelet kube-proxy etcd node节点02：20.0.0.35 kubelet kube-proxy etcd 负载均衡：nginx+keepalive+master01：20.0.0.36 负载均衡：nginx+keepalive+master02：20.0.0.37 ercd：20.0.0.32、20.0.0.34、20.0.0.35 开始部署 k8smaster01、node01、node02
iptables -F iptables -t nat -F iptables -t mangle -F iptables -x #清空iptables的所有策略 master01、node01、node02关闭swap交换分区 swapoff -a #关闭swap交换分区 #k8s在涉及时，为了提升性能，默认不使用swap交换分区，k8s在初始化的时候会自动检测swap 开始给主机改名 hostnamectl set-hostname master01 hostnamectl set-hostname node01 hostnamectl set-hostname node02 vim /etc/hosts/ 20.0.0.32 master01 20.0.0.34 node01 20.0.0.35 node02 #坐映射 cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF net.bridge.bridge-nf-call-ip6tables = 1 net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9aa14108dd7898532c24a5b439c3ef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138560dd4c9840e6b3efd97676ed3bd3/" rel="bookmark">
			如何才能更好的选择属于自己的服务器呢?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何才能更好的选择属于自己的服务器呢?
第一：网站有备案，1.用户多居于北方，选择联通线路;2.用户多居于南方，选择电信线路;3，用户分布于全国各个地区，选择BGP或者是双线线路。正所谓：南电信北联通。才能更好的顺应客户的本地网络情况。
第二：网站无备案，需要选择非大陆的海外云服务器，注：仅为域名无备案的，但是需要进行实名认证。方便更加快捷的联系处理问题。
第三：如果网站有攻击，尽可能选择带有防护的机房，美国高防服务器比较多，保证网络的安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df9b57e74da938942e9cffef2eb7bdd/" rel="bookmark">
			Java 使用 Integer 实现进制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 java.lang.Integer 可以很方便的实现进制转换。
十进制的 200 ，转换为二进制是 11001000 ，转换为十六进制是 c8 。
代码示例，
public class HexTest { public static void main(String[] args) { // 十进制的 200 ，转换为二进制是 11001000 ，转化为十六进制是 c8 System.out.println("把 (String)200 转为 int: " + Integer.parseInt("200")); System.out.println("把十进制 (int) 200 转为二进制 String: " + Integer.toBinaryString(200)); System.out.println("把二进制的（String）11001000 转为十进制 int: " + Integer.parseInt("11001000", 2)); System.out.println("把十进制 (int) 200 转为十六进制 String: " + Integer.toHexString(200)); System.out.println("把十六进制的 (String) c8 转为十进制 int: " + Integer.parseInt("c8", 16)); System.out.println("把十六进制的 (String) -c8 转为十进制 int: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0df9b57e74da938942e9cffef2eb7bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3feaea0860010f09cc41ed5ba6103d/" rel="bookmark">
			第五章 与HTTP协作的Web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.1 用单台虚拟主机实现多个域名 在传统的基于IP地址的服务器配置中，一台服务器通常只能提供一个域名的服务。然而，通过虚拟主机的技术，同一台服务器可以根据请求中的域名，区分并提供不同的网站内容。这使得在一台物理或虚拟服务器上托管多个域名成为可能，从而在资源更加有限的环境中实现更高的资源利用率。
实现这一功能的关键是在服务器的配置中定义多个虚拟主机，并为每个虚拟主机指定相应的域名和相关的配置信息，以确保服务器能够正确地区分和响应来自不同域名的请求。
在一台物理或虚拟服务器上，通过配置使得这台服务器能够响应来自多个不同域名的 HTTP 请求。这个概念通常被称为虚拟主机（Virtual Host）。
客户端使用HTTP协议访问服务器时，会经常采用类似www.hackrjp这样的主机名和城名
在互联网上，域名通过DNS服务映射到IP地址(域名解析)之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址形式访问了。
所以，如果一台服务器内托管了www.tricorderjp和wwwhackrjp这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。
在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和城名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI
5.2 通信数据转发程序: 代理, 网关, 隧道 HTTP通信时，除客户端和服务器以外，还有一此用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。
这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。
5.2.1 代理 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。
持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。
HTTP通信过程中, 可以级联多台代理服务器, 请求和响应的转发会经过数台连接起来的代理服务器, 转发时, 需要附加Via首部字段以标记出经过的主机信息
功能：
访问控制： 代理可以根据一些规则控制对特定资源的访问，实现访问控制策略。安全性： 代理可以提供额外的安全层，隐藏客户端的真实 IP 地址，防范攻击。缓存： 代理可以缓存先前请求的响应，提高对重复请求的响应速度。日志记录： 代理可以记录经过它的请求和响应，用于分析和监控网络活动。 透明代理
转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy)。反之，对报文内容进行加工的代理被称为非透明代理。
5.2.2 网关 网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务
利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。
5.2.3 隧道 隧道是一种通过网络传输层直接连接两个端点的通信机制。隧道通常用于在两个网络之间创建私密、安全的连接，将数据以加密的方式传输。
隧道本身不会去解析HTTP请求, 即请求会原样中转给之后的服务器, 隧道会在通信双方断开连接时结束
5.3 保存资源的缓存 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间
缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。
缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。
5.3.1 缓存的有效期限 即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题
当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了
即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。
5.3.2 客户端的缓存 缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer程序为例，把客户端缓存称为临时网络文件(TemporaryInternet File )。
浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。
另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091319a23bfa0f40146370f00601f71c/" rel="bookmark">
			Django创建投票应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
创建应用
创建模型mysite\\polls\\models.py
激活模型mysite\\setting.py
为模型的改变生成迁移文件
应用数据库迁移
创建管理员账号
管理投票应用mysite\\polls\\admin.py
添加视图mysite\\polls\\views.py
添加路径mysite\\polls\\urls.py
创建模版mysite\\polls\\templates\\polls\\index.html
启动开发服务器python manage.py runserver
关于数据库配置，更多内容请看在Django中配置PostgreSQL-CSDN博客
创建应用 python manage.py startapp polls 创建模型
mysite\\polls\\models.py from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField("date published") class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 激活模型
mysite\\setting.py INSTALLED_APPS = [ "polls.apps.PollsConfig", "django.contrib.admin", "django.contrib.auth", "django.contrib.contenttypes", "django.contrib.sessions", "django.contrib.messages", "django.contrib.staticfiles", ] 为模型的改变生成迁移文件 python manage.py makemigrations polls 应用数据库迁移 python manage.py migrate 创建管理员账号 python manage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091319a23bfa0f40146370f00601f71c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42401a49b478b0bc0f99c6fb8ca82854/" rel="bookmark">
			Alibaba Cloud Linux 3.2104 LTS 64位镜像兼容和性能如何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云Alibaba Cloud Linux 3.2104 LTS 64位镜像是可以选择的，它阿里云打造的Linux服务器操作系统发行版，针对云服务器ECS做了大量深度优化，完全兼容RHEL/CentOS生态和操作方式，如果是阿里云服务器ECS建议选择Alibaba Cloud Linux镜像操作系统，Alibaba Cloud Linux镜像由阿里云官方提供长期支持和维护(LTS)，阿里云服务器网aliyunfuwuqi.com分享Alibaba Cloud Linux 3.2104 LTS 64位详细说明：
Alibaba Cloud Linux 3.2104为64位操作系统，64位架构是指CPU一次性可以处理64位数据，提供更强的计算能力和更大的内存管理能力，镜像ID为aliyun_3_x64_20G_alibase_20230727.vhd，可以在阿里云CLUB中心领券 aliyun.club 专用满减优惠券。
版本号镜像ID发布时间发布内容Alibaba Cloud Linux 3.2104 U8aliyun_3_x64_20G_alibase_20230727.vhd2023-07-27更新Alibaba Cloud Linux 3.2104 LTS 64位基础镜像到最新的软件版本
内核版本更新至5.10.134-15.al8.x86_64 综上，放心选择阿里云Alibaba Cloud Linux 3.2104 LTS 64位镜像操作系统，阿里云支持免费更换操作系统，如果不合适，可以在后台免费更换云服务器的系统镜像。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b66845b2de142f05906a92ac8f1d8c1/" rel="bookmark">
			STL--集合：set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		set的介绍 set就是数学上的集合--每个元素最多只出现一次。和sort一样，自定义类型也可以构造set，但同样必须定义“小于”运算符。set中元素具有已从小到大排好序的性质。
set的应用 题目
输入一个文本，找出所有不同的单词（连续的字母序列），按字典序从小到大输出。单词不区分大小写。
样例输入
Adventures in Disneyland Two blondes were going to Disneyland
when they came to a fork in the road. The sign read: “Disneyland
Left.” So they went home.
样例输出
a
adventures
blondes
came
disneyland
fork
going
home
in
left
read
road
sign
so
the
they
to
two
went
were
when
代码
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;set&gt; #include&lt;sstream&gt; using namespace std; set&lt;string&gt;dict;//string集合 int main(){ string s,buf; while(cin&gt;&gt;s){ for(int i=0;i&lt;s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b66845b2de142f05906a92ac8f1d8c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8769b8101838b894e723640a363ac9/" rel="bookmark">
			如何获取2024年交易日历？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交易日历是金融领域的重要参考工具，包含了各国的法定节假日、休市日、交易时间调整等信息，能够帮助投资交易者合理安排交易时间、了解市场情况、提高决策的准确性。
DolphinDB 自 2.00.9/1.30.21 版本开始，内置了国内外五十多个交易所的交易日历，同时也支持用户在此基础上，基于场景进行个性化定制。
新的一年即将开启，DolphinDB 提供的交易日历也升级到2024年的全新版本啦！我们为大家提供了离线更新和在线更新两种方式：
离线更新 若采用离线更新方式，可以在 交易日历 下载 marketHoliday 文件夹，并替换 &lt;dolphindb&gt;/server 路径下的 marketHoliday 文件夹。若为集群环境，需要替换每台机器下的对应文件夹。在替换完成后，需要重启集群完成更新。
在线更新 若采用在线更新方式，可以在 交易日历 下载 marketHoliday 文件夹，并放在和 dolphindb 同一服务器的任意位置。若为集群环境，每台机器都需要放置 marketHoliday 文件夹。注意，不能覆盖原本 &lt;dolphindb&gt;/server 路径下的 marketHoliday 文件夹。在替换完成 marketHoliday 文件夹后，可以参照下面的代码实现在线更新：
def update_2024_holiday(market_code, old_holiday_dir, new_holiday_dir){ old_holiday_files = exec filename.strReplace(".csv","") from files(old_holiday_dir) new_holiday_files = exec filename.strReplace(".csv","") from files(new_holiday_dir) if (!(market_code in new_holiday_files)){ return "There is no market holiday file of the exchange." } this_holiday = loadText(new_holiday_dir+'/'+market_code+".csv") if (market_code in old_holiday_files){ updateMarketHoliday(market_code,this_holiday.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd8769b8101838b894e723640a363ac9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/18/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>