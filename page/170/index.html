<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8d9d60809284786d9def6858638960/" rel="bookmark">
			关于echarts的y轴x轴刻度不等分,不等距的设置法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于echarts的y轴x轴刻度不等分,不等距的设置法
前言 初衷是工作需要,同时用于记录一些心得(第一次写博客，写的不好请多见谅，ps:写这个是因为自己百度没找到，所有花了点时间做出来后分享给大家。)
提示：以下是本篇文章正文内容，下面案例可供参考
一、echarts echarts图标是我们比较常用的，功能十分的强大并且便捷，当然，与自由度相对等的就是庞大的属性，这篇文章只是帮您节省一点时间。
二、关于坐标轴（y,x）不等距不等分的方法 在这里，我本人认为存在多种方法(目前认为三种)，并且是具有可行性的，我会依次为各位说明（个人建议使用第三种）：
1.使用MARKLINE实现Y轴刻度不等分（个人推荐） MARKLINE是指series下的markLine属性,其本身官方的说明是"图表标线",在我看来就是自由画线，而且还有文本，就能搞起来！！,示例如下：
series: [ { data: [0, 5,30, 2, 218, 135, 147, 260], type: 'line', connectNulls: true, markLine: { symbol: ['none', 'none'],//去掉箭头 itemStyle: { normal: { lineStyle: { type: 'solid', color:'black'} } }, label:{ formatter: '{b}' }, data: [{ name: '-20%', yAxis: 0 }, { name: '-10%', yAxis: 2 }, { name: '0%', yAxis: 4 }, { name: '10%', yAxis: 8 } ] } } ] }; 这里要注意下，位置可以按照轴刻度索引来做，名称可以自定义，但要配套的设置label属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad8d9d60809284786d9def6858638960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7822e329f378a16e2c9a27b0ca67e1ef/" rel="bookmark">
			HTML CSS input输入框样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /* 修改输入框placeholder的字体颜色*/ input::-webkit-input-placeholder { /* WebKit browsers */ color: rgb(12, 203, 130); } input:-moz-placeholder { /* Mozilla Firefox 4 to 18 */ color: rgb(12, 203, 130); } input::-moz-placeholder { /* Mozilla Firefox 19+ */ color:rgb(12, 203, 130); } input:-ms-input-placeholder { /* Internet Explorer 10+ */ color: rgb(12, 203, 130); } /* 点击输入框不显示边框*/ input{ outline:medium; } /* 修改输入框placeholder的字体颜色end*/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d443f02ac88542213233be94d5e700/" rel="bookmark">
			Mac电脑使用自然码双拼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先在键盘里选择双拼
然后打开 终端 执行(启动台-&gt;其他当中)
defaults write com.apple.inputmethod.CoreChineseEngineFramework shuangpinLayout 5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6888361c26b98fd0d246235e9f094a/" rel="bookmark">
			MySQL之单行函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL之单行函数 1. 函数的理解 1.1 什么是函数 函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既提高了代码效率，又提高了可维护性。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地提高用户对数据库的管理效率。
从函数定义的角度出发，我们可以将函数分成内置函数和自定义函数。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的，本章及下一章讲解的是 SQL 的内置函数。
1.2 不同DBMS函数的差异 我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着采用 SQL 函数的代码可移植性是很差的，因此在使用函数的时候需要特别注意。
1.3 MySQL的内置函数及分类 MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。
MySQL提供的内置函数从实现的功能角度可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：单行函数、聚合函数（或分组函数）。
两种SQL函数
单行函数
操作数据对象接受参数返回一个结果只对一行进行变换每行返回一个结果可以嵌套参数可以是一列或一个值 2. 数值函数 2.1 基本函数 函数用法ABS(x)返回x的绝对值SIGN(X)返回X的符号。正数返回1，负数返回-1，0返回0PI()返回圆周率的值CEIL(x)，CEILING(x)返回大于或等于某个值的最小整数FLOOR(x)返回小于或等于某个值的最大整数LEAST(e1,e2,e3…)返回列表中的最小值GREATEST(e1,e2,e3…)返回列表中的最大值MOD(x,y)返回X除以Y后的余数RAND()返回0~1的随机值RAND(x)返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数ROUND(x)返回一个对x的值进行四舍五入后，最接近于X的整数ROUND(x,y)返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位TRUNCATE(x,y)返回数字x截断为y位小数的结果SQRT(x)返回x的平方根。当X的值为负数时，返回NULL 举例：
SELECT ABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32), FLOOR(-43.23),MOD(12,5) FROM DUAL; SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1) FROM DUAL; SELECT ROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1) FROM DUAL; 2.2 角度与弧度互换函数 函数用法RADIANS(x)将角度转化为弧度，其中，参数x为角度值DEGREES(x)将弧度转化为角度，其中，参数x为弧度值 SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90)) FROM DUAL; 2.3 三角函数 函数用法SIN(x)返回x的正弦值，其中，参数x为弧度值ASIN(x)返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULLCOS(x)返回x的余弦值，其中，参数x为弧度值ACOS(x)返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULLTAN(x)返回x的正切值，其中，参数x为弧度值ATAN(x)返回x的反正切值，即返回正切值为x的值ATAN2(m,n)返回两个参数的反正切值COT(x)返回x的余切值，其中，X为弧度值 举例：
ATAN2(M,N)函数返回两个参数的反正切值。
与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而ATAN2(M,N)函数则仍然可以计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f6888361c26b98fd0d246235e9f094a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a822e0e6912b45bb4ef590a8fe62f98d/" rel="bookmark">
			Docker 启动容器权限报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 安装完成，启动容器时报错，启动失败：
**
docker: Error response from daemon: OCI runtime create failed:
container_linux.go:345: starting container process caused
“process_linux.go:430: container init caused “write
/proc/self/attr/keycreate: permission denied””: unknown.
**
原因：
“write /proc/self/attr/keycreate: permission denied” 表示文件没有写入权限，被拒绝访问了
解决方法：
将/etc/selinux下的config文件中的SELINUX属性改为disabled
步骤
vi /etc/selinux/config 可以看到里面的属性为：enforcing 强制性的
将 SELINUX 属性改为 disabled
重新启动 docker，并启动容器即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc487e844d68f392c33dada5b0c07bb5/" rel="bookmark">
			java.sql.SQLNonTransientConnectionException: Public Key Retrieval is not allowed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在mysql 8中碰到这个问题。
我先创建用户，创建数据库，以及分配用户数据库的权限
create user 'test'@'192.168.96.1' identified by 'test'; grant all privileges on test.* to test@192.168.96.1; 结果：
我已经在数据库连接的url里指定了：
AllowPublicKeyRetrieval=True 但是还是出现这个错误。
参考：
https://stackoverflow.com/a/53300421
这个回答，是把mysql 8的默认密码方式改成：mysql_native_password
alter user test@192.168.96.1 identified with mysql_native_password by 'test'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756d57aaf80f2f5cdc21216ea5d52d49/" rel="bookmark">
			Vue3 引入Element Plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Element Plus 是为适配 Vue3 而对 Element UI 进行重构后产生的前端组件库，包含丰富的基础组件
下面先贴出 官方文档，里面的介绍已经十分全面和详细，大家遇到的很多问题都可以在上面找到答案
假设现在我们已经用 vue-cli 4 工具创建了一个 Vue3 项目，然后怎么在项目中引入 Element Plus 呢？
注意，这里必须是用 vue-cli 4 创建的 Vue3 项目，否则后面会报错，首先介绍一下默认生成的目录结构
+ demo + node_modules（存放第三方模块） + public（存放静态文件） - favicon.ico（图标） - index.html （页面模板） + src（我们自己写的文件一般放在这个文件夹下） + assets（存放资源文件） + components（存放公共组件） + router.js（路由管理：Router） + store.js （状态管理：Vuex） + views（存放视图组件） - App.vue（页面入口文件） - main.js（程序入口文件） - package.json（项目配置文件） - package-lock.json（项目配置文件） - babel.config.js（babel 配置文件） - README.md（项目说明文档） - ...（其它配置文件） 1、安装 Element Plus
npm 是 Node 的包管理工具，我们可以通过 npm 安装 Element Plus
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756d57aaf80f2f5cdc21216ea5d52d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f087d9a7a59dbaa6eb9f73357b4ca908/" rel="bookmark">
			断言失败了怎么清理已创建的测试数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景一：校验创建用户接口返回体中的字段默认值是否符合预期
（按照用例流程需要清理测试数据，但中间assert断言失败会导致用例停止，不会执行清理操作）
用例组织是这样的：
def test_case(self)
#调用adduser接口创建用户
#assert校验response的返回体字段默认值是否符合预期
#调用deleteuser接口删除创建的用户
如果assert校验失败，就会终止用例，deleteuser这一步不执行，导致测试数据未被清理。有什么办法解决这个问题？
方法一：使用try catch finally解决
将assert写在try中 将后面的清理操作写在finally里
方法二：使用pytest.assume 断言，assume断言失败后，不停止后面的执行
这种轮询校验response返回参数值是否符合预期的校验，推荐使用用pytest.assume，如果第一个参数断言失败，还会校验后面的参数，如果用assert，遇到失败就不校验后面的参数了
参考代码
expres = {'email': "", 'areacode': "", 'enabled': True, 'phone': "", 'description': "", 'is_domain': False, 'password_expires': None, } for key in expres: resValue = jsonpath.jsonpath(jsonRes, "$.user." + key)[0] pytest.assume(resValue == expres[key], "返回值与期望不一致，exp[" +key+"]="+ str(expres[key]) + "实际=" + str(resValue)) 场景二：参数异常创建用户，期望是创建失败返回400，如果代码有bug，参数异常创建201，需要对创建的测试数据进行清理
用例代码如下：
def test_case1(self):
#使用异常参数调用adduser接口
#断言返回400，结束
但是如果代码有bug，参数异常创建201，需要对创建的测试数据进行清理
方法：用例中如果判断返回201就抛出一个异常，在异常exception里将userid加入垃圾桶去回收,exception不会导致后面的异常参数不执行
参考代码如下：
@pytest.mark.parametrize("invalidparm", [{"domain_id": [getRandomString(len=32)]},{"password":["1232"]] ​​​​​​​def test_case1(self,invalidparm): for replaceParm in invalidparm: #invalidparm={'domain_id': ['oxCHUZgLoGg9lbGCERPcA9aazMSt2AEs']}#replaceParm =domain_id for replacevalue in invalidparm[replaceParm]: try: jsonbody = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f087d9a7a59dbaa6eb9f73357b4ca908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc70d78a10bb655d97a42e65f99d417f/" rel="bookmark">
			jason-2影像下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jason-2网址：https://www.aviso.altimetry.fr/en/home.html
数据下载页面网址：https://www.aviso.altimetry.fr/en/data/products/sea-surface-height-products/global/waveforms-1.html
打开数据下载页面，来到如下界面：
打开第一个链接，跳转到数据下载界面：
（会跳出这个界面，需要先注册账号，用账号登录？） 数据下载界面，有多种的数据，常用的是geophysical-data-record（GDR）数据。
继续往下选择，有多种卫星及其获取的数据可以选择：
一个cycle里大概是10天，数据有缺失，数据是按卫星飞过的轨道来排列的，要查询对应区域的轨道数要先在官网下载对应的kml文件，用google earth打开：
找到自己需要的地区，观察有哪些pass经过，并对地面轨迹线条（红色）单击鼠标右键，查看名称，如：“Ground Track 153”则代表该轨迹的pass号为153。
下载文件后，通过限制维度来获得指定区域数据（因为jason-2是条状的，限制维度即可）。代码操作参考这篇文章：【卫星测高】用matlab读取指定经纬度区域的卫星测高数据并计算高程_以jason2为例_Find your love-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd86b7694b619f615a6a77751490826a/" rel="bookmark">
			mathtype 插入章节编号后无法自动消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 正常情况下利用mathtype插入公式时，当点击插入分隔符后，会自动消失。特殊情况下，插入后不会消失的问题。
解决方式 点击开始-&gt;选项-&gt;显示，将隐藏文字去掉勾线，显示所有格式标记去掉格式。
创建一种新的格式，在文字选项将文字类型设为隐藏。然后将显示的mathtype章节号换成此种格式，就可以不显示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16e210a74fc3bb862cb479ee627ef36/" rel="bookmark">
			解决“Cannot set headers after they are sent to the client”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
使用 node 做了一个服务器去操作数据库并且暴露 API 接口给前端页面请求数据使用，在做登录页面时候，登录功能和修改用户的密码功能都已经实现并且单独调试的时候无误，但是在两者结合，即登录前修改了用户密码然后再进行登录验证，服务器会报错如下：
翻译为中文： 将请求头发送到客户端后无法设置请求头
报错原因： 客户端发送一次请求的时候，服务器端给出了多次响应
经过摸索与实践，解决方法如下：
服务器在每次响应后添加return，避免多余响应。
在下图中，在用户登录成功后服务器会返回响应，在响应后直接用 return 。
修改密码这里也一样，返回响应后直接 return。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06bdb219605671fd0e0fcebc6b4adc25/" rel="bookmark">
			外呼中心从“隐私面单”到“小号平台”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只要商家敢想，每天都是盛大购物节。我们最大的乐趣就是一咬牙一跺脚下单，然后慢慢在家等着收快递，然后……退单。在这个愉快的购物过程中，我们的所有信息都暴露的干干净净，联系人、联系号码、家庭地址都有，往坏了想，真的是不敢想象。号码隐私问题不单单只是快递面单，最常见到的当时是电话通讯这个渠道了，天天讯通小号模块(小号平台)的运用，确实解决了人们的一大痛点，甚至可以说是切肤之痛。
那么简单说说什么是天天讯通的小号平台。AXBAXB是一个虚拟号码绑定双方的真实号码、绑定完成后，双方可以拨打中间号码进行电话沟通，其中一个虚拟号码最大量可以绑定100对号码并同时通话。这种模式主要应用在出行打车、C2C、B2B平台。AXAX模式，一个虚拟号码绑定一个真实号码。其他电话通过这个虚拟号码联系到对应的联系人。主要运用在房产中介、教育平台、医疗咨询等平台经纪型企业。个人隐私保护一小步，社会文明一大步。天天讯通会更加专注“小号平台”的研发和应用，助力企业号码隐私保护更上一层楼！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a65e9ce9be75f2dfd7a8457f9b75c94/" rel="bookmark">
			RabbitMQWeb 管理界面及授权操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们在 linux 安装好了 RabbitMQ 但是为了我方便我们开发我们一般会安装一个 RabbitMQWeb 管理界面，那么如何去配置这个管理界面呢？
首先 我们先要在 linux 端安装配置好图形化管理的配置，在终端输入以下命令：
# rabbitmq-plugins enable rabbitmq_management 等待安装完成！如图：
安装完成之后你要重新启动一下 RabbitMQ 即可 ，
# systemctl restart rabbitmq-server 注意： 如果说你在这边的时候突然碰到以下的错误的时候，记得先检查一下你的Erlang 和RabbitMQ 的版本是不是对应的！！！！ 不对应的话那么就赶紧改过来，在重新启动就可以了！
错误如下图：
其次 我们就到我们浏览器中访问一下这个管理界面 你的主机ip: 15672 回车即可范问，这里会让我们输入账号和密码，那么这里又要注意了，如果说你是在本机安装的RabbitMQ的话那么你就 可以使用guest作为账号和密码登录界面，那如果你是跟我一下部署在 linux 上的话那么你还需要在你的 linux 终端上注册一个账号和密码，并且给他赋予权限即可！
1、在 linux 端创建一个账号
# rabbitmqctl add_user admin admin 2、设置用户分配操作权限
# rabbitmqctl set_user_tags admin administrator 用户级别： 1、administrator 可以登录控制台，查看所有信息、对rabbitmq进行管理，在开发的时候我们尽量把账户设成这个权限 2、monitoring 监控者 登录控制台，查看所有信息 3、policymaker 策略制定者 登录控制台，制定策略 4、management 普通管理员 登录控制台 3、为用户添加资源权限
# rabbitmqctl set_permissions -p / admin "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a65e9ce9be75f2dfd7a8457f9b75c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3455b2e9426c4ccbebbce75a46312c9f/" rel="bookmark">
			微服务问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
项目结构分析
pom.xml文件删除线​
MySQL的版本问题
Nacos服务启动问题
idea中启动nacos
Maven 依赖问题
项目克隆问题
JDK 配置问题
Maven配置编译问题
服务注册异常(NacosException)
服务配置读取问题
配置文件格式问题
无法访问此网站
pom.xml有删除横线
访问404异常
访问500异常
端口占用问题
服务调用案例分析
服务ID问题分析
Maven Helper插件应用
客户端调用异常(ClientException)
@PathVariable 注解在@FeignClient中应用
​ 依赖注入失败(Bean Not Found)
请求映射路径重复定义
@FeignClient注解名字问题
Feign远程调用超时
图解服务调用方案
配置文件加载顺序
​ 拉取(Pull)配置信息
Nacos配置中心模型
Tomcat 请求处理分析
Java线程池构成分析
线程池任务执行过程
线程拒绝执行异常
JDK 版本问题
Sentinel 控制台显示
微服务中的Sentinel日志
回顾Spring MVC 请求处理
Sentinel 请求拦截分析
Day06
Idea中启动Nacos
跨域访问问题
Nacos 服务注册问题
文件上传404问题
请求资源405异常
请求资源500异常
BeanCreationException 异常
服务名无效或没有定义
Day07
网关配置文件问题
服务访问被拒绝(Connection refused)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3455b2e9426c4ccbebbce75a46312c9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4396716d5c63a2445e7638746d8567ab/" rel="bookmark">
			Java并发编程--自旋锁的实现和使用（Spin Lock）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自旋锁是这样一类锁：当线程等待加锁时，不会阻塞，不会进入等待状态，而是保持运行状态。大致的思路是：让当前线程不停地的在循环体内执行，当循环的条件被其他线程改变时才能进入临界区。
一种实现方式是通过CAS原子操作：设置一个CAS原子共享变量，为该变量设置一个初始化的值；加锁时获取该变量的值和初始化值比较，若相等则加锁成功，让后把该值设置成另外一个值；若不相等，则进入循环（自旋过程），不停的比较该值，直到和初始化值相加锁成功。
自旋锁的优势 （1）性能较高：自旋锁不会使线程状态切换，始终处于用户态，即线程始终处于活动状态，不会让线程进入阻塞状态，减少不必要的上下文切换，性能较高；
（2）避免死锁：自旋锁不会让线程阻塞或等待，也就不需要唤醒，所以可以避免产生死锁；
自旋锁的缺点 （1）在等待锁时进入循环会占用CPU，若等待的线程很多，对CPU的消耗会比较大；
（2）不适合需要长时间等待的任务或线程；
（3）不适合大量线程等待的场景。
自旋锁的使用场景 （1）等待时间比较短的任务中；
（2）线程数量不太多的应用中；
（3）当等待时间长或线程数量很大时，可以使用其他锁（比如：可重入锁）。
自旋锁和互斥锁 （1）自旋锁和互斥锁都是保护资源共享的机制；
（2）无论是自旋锁还是互斥锁，任何时候最多只能有一个持有者；
（3）如果锁已被占用，则获取互斥锁的线程将进入阻塞状态；获取自旋锁的线程不会阻塞。
自旋锁的实现 使用AtomicReference变量的CAS机制来实现自旋锁。由于AtomicReference变量能够保证多个线程同时对其读写时的原子性（这种原子性是通过sun.misc.unsafe包来实现的，后面会专门介绍），所以，可以使用这种类型 的共享变量作为判断条件。
public class SpinLock { // 定义一个原子引用变量 private AtomicReference&lt;Thread&gt; sign = new AtomicReference&lt;&gt;(); public void lock(){ Thread current = Thread.currentThread(); // 加锁时：若sign为null，则设置为current；若sihn不为空，则进入循环，自旋等待； while(!sign.compareAndSet(null, current)){ // 自旋：Do Nothing！！ } } public void unlock (){ Thread current = Thread.currentThread(); // 解锁时：sign的值一定为current，所以直接把sign设置为null。 // 这样其他线程就可以拿到锁了（跳出循环）。 sign.compareAndSet(current, null); } } 注意：这种自旋锁的实现方式是不可重入的。也就是说：若一个已经加锁成功的线程再次获取该锁时，会失败。那么如何实现一个可重入的自旋锁呢？其实就是比较目前的线程引用是否和锁中记录的线程引用相等，若相等加锁成功。可重入自旋锁会在下面章节进行分析。
可重入自旋锁 当一个使用自旋锁加锁成功的线程，再次尝试加锁时可以加锁成功（可重入）。
第1种实现方式 通过ReentrantLock类来实现。ReentrantLock的tryLock不会让线程阻塞，从而可以用来当做自旋锁的对比判断然后循环等待的条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4396716d5c63a2445e7638746d8567ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a01414fc20b7564260dbcefa74af1b/" rel="bookmark">
			力扣每日一题（难的我也不会）（2021.11.29）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数 组成，且其中所有整数互不相同。 对于每对满足 0 &lt; i &lt; j &lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。 那么第 k 个最小的分数是多少呢? 以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。 public int[] kthSmallestPrimeFraction(int[] arr, int k) { //计算所有分数长度 int len=arr.length; int n=0; for (int i = 1; i &lt;= len-1; i++) { n=n+i; } Double[] darr=new Double[n]; int darrCount=0; HashMap&lt;Double,int[]&gt; map=new HashMap&lt;&gt;(); for (int i = 0; i &lt; len-1; i++) { for (int j = i+1; j &lt; len; j++) { double d=(double) arr[i]/arr[j]; darr[darrCount++]=d; map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a01414fc20b7564260dbcefa74af1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a49decefcefdb0fd0ac2ba1344b802/" rel="bookmark">
			02.SQL Server（表创建及约束）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用数据库的过程中，接触最多的就是数据库中的表，表中存放了数据库中的所有数据，所以表是SQL Server数据库系统的基本信息存储结构，也是数据库中你那个最重要的部分，管理好表自然就管理好了数据库。
1.数据表概述 数据表是数据库最重要的组成部分之一。数据库只是一个框架，数据表才是其实质内容，所有数据存储在数据表中。根据信息的分类情况，一个数据库中可能包含若干个数据表 。
在创建数据表的过程中，因为要定义表中的字段，需要为字段选定数据类型，下面介绍SQL Server 2008 R2 常用的基本类型。
2.SQL基本数据类型 分类
备注和说明
数据类型
说明
二进制数据类型
存储非子符和文本的数据
Image
可用来存储图像
文本数据类型
字符数据包括任意字母、符号或数字字符的组合
Char
固定长度的非 Unicode 字符数据
Varchar
可变长度非 Unicode 数据
Nchar
固定长度的 Unicode 数据
Nvarchar
可变长度 Unicode 数据
Text
存储长文本信息
Ntext
存储可变长度的长文本
日期和时间
日期和时间在单引号内输入
Datetime 日期和时间
数字数据
该数据仅包含数字，包括正数、负数以及分数
int
smallint
整数
float
real
数字
货币数据类型
用于十进制货币值
Money
Bit数据类型
表示是/否的数据
Bit
存储布尔数据类型
3.数据表创建 通过sql结构化查询语言创建数据表有2种方式，（1）对象资源管理器（2）脚本方式
3.1 使用对象资源管理器创建表
3.2 使用脚本方式创建表
create table tb_表名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a49decefcefdb0fd0ac2ba1344b802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7729f7651280bec4d89c04b50f07b00f/" rel="bookmark">
			linux模糊匹配文件后删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		find . -name ‘wget-log*’ -exec rm {} ;
命令含义：
. 表示查找的目录范围，也就是当前目录下
‘wget-log*’ 为查找的文件名，* 表示匹配任意字符串
支持以下通配符：
通配符 作用
匹配任意字符串
? 匹配任意单个字符
[] 匹配 [] 内字符,可以按,-区分,也可无符号区分
! 匹配非 ! 后的字符串中的每一个字符 一般配合[]使用
-exec rm {} 表示使用前面 find 命令获取到的文件名，替换 {} 批量执行rm命令，可以根据自己的需要修改执行的命令 在执行上面的命令删除文件时，最好先单独执行 find 命令，检查下匹配到的文件，以免错删
find . -name ‘wget-log*’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c3097b6cfb4d7fe6daeb7948fccbae/" rel="bookmark">
			idea使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全局搜索 ------ 美式键盘下Ctrl+Shift+f查看某个方法或类的详细内容 ------ Ctrl+鼠标点方法(类)名若执行2后想返回之前的位置 ------ Ctrl+Alt+向左箭头快速生成if、while循环、do~while循环、for循环、try等 ----- Ctrl+Alt+t调用方法获取返回值或new新对象接收其值 ------ .var大小写切换 ------ Ctrl+Shift+u代码格式化 ------ Ctrl+Alt+l快速生成输出语句 ------ 例如：“hello”.sout或"hello".soutv持久类生成代码(如GET,SET方法,构造函数等) ------ Alt+Insert自动导入包 ------ Alt+Enteridea设置菜单和左边项目文件目录字体的大小设置 ------ 用Ctrl+Alt+s打开Settings，Settings &gt;&gt; Appearance &amp; Behavior &gt; Appearance代码字体大小设置 ------ 用Ctrl+Alt+s打开Settings，Editor &gt; Fontidea设置代码提示和eclipse一样为Alt+/ ------ Settings &gt;&gt; Keymap &gt; Main menu &gt; Code &gt; Code Completion &gt; Basic 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8307b7bf8d7a426852a0b52f3207eb45/" rel="bookmark">
			ELK日志系统的写入优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日志系统的写入优化 1. 日志集群优化的基本原则 对于日志收集系统来说，就是使用尽可能少的资源来存储尽可能多的日志，所以需要结合日志集群的特点进行优化。这些优化一般可以分为两个方面，一个方面是提升服务器配置，给更多的资源，比如加机器，上ssd等这种，这种优化会提升集群的写入效率，但是不会有其他的损失，甚至其他方面也会有提升；还有一方面的优化则是带有trade-off的，也就是牺牲一些其他方面的性能来提升写入的效率（比如降低search的资源）。
2. 服务器配置优化 服务器的配置优化和搭建用于online搜索的集群类似
提升集群的节点数量使用专用的master给每个节点更多的内存和更多的cpu核数节点要开启memory-lockjvm配置优化使用ssd磁盘（这个实际上是可以对于高index专用的优化） 3.带有trade-off的配置优化 1.索引的配置优化（要配置到index-teplate中，因为索引按天生成） 索引的shard数量合理设置，保证每个shard数据量大概为20-50g,可以减小对内存的使用,副本数最多设置为1即可
索引的refresh设置更大，来降低refresh的开销，要配置到index-teplate中（因为索引按天生成）
"index.refresh_interval":"30s" translog设置，减小translog对性能的消耗，这种在节点挂掉的时候有可能会发生丢数据的情况
"translog": { "flush_threshold_size": "1024mb", "sync_interval": "600s", "durability": "async" } 2.节点配置优化 对于日志集群，一般是写多读少，所以可以分配更多的内存来做index buffer
indices.memory.index_buffer_size: 30% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d2992ea37695d0e664c20274d97009/" rel="bookmark">
			Spark综合学习笔记（二十二）SparkSQL实战4-花式查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习致谢 https://www.bilibili.com/video/BV1Xz4y1m7cv?p=59
SparkSQL花式查询 在Spark5QL模块中，将结构化数据封装到DataFrame或Dataset集合中后，提供了两种方式分析处理数据:
1、SQL编程，将DataFrame/Dataset注册为临时视图或表，编写SQL语句，类似HiveQL;
2、DSL (domain-specific language)编程，（类似于面向对象）调用DataFrame/Dataset APIl(函数），类似RDD中函数;
需求: 针对personDF中的数据使用SQL和DSL两种方式进行各种查询
代码实现： package sql import org.apache.spark.rdd.RDD import org.apache.spark.sql.SparkSession /** * Author itcast * Desc 演示使用spark-SQL-使用SQL和DSL两种方式进行各种查询 */ object Demo04_Query { def main(args: Array[String]): Unit = { //TODO 0.准备环境 val spark = SparkSession.builder().appName("sparksql").master("local[*]").getOrCreate() val sc = spark.sparkContext sc.setLogLevel("WARN") //TODO 1.加载数据 val lines:RDD[String] = sc.textFile("data/SogouE.txt") //TODO 2.处理数据 val personRDD:RDD[Person] = lines.map(line =&gt; { val arr: Array[String] = line.split(" ") Person(arr(0).toInt, arr(1), arr(2).toInt) }) //RDD---&gt;DF import spark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d2992ea37695d0e664c20274d97009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445494797a6568e8114122c6fd996981/" rel="bookmark">
			Python&#43;Selenium UI自动化-基础定位语法(id,name,class_name,tag_name,link_text)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 百度搜索举例
import time from selenium import webdriver driver = webdriver.Chrome() driver.get('https://www.baidu.com') driver.maximize_window() time.sleep(2) driver.find_element_by_id('kw').send_keys('丸子')#使用id定位方法 driver.find_element_by_name('wd').send_keys('丸子')#使用name定位方法 driver.find_element_by_class_name('s_ipt').send_keys('丸子') #通过classname匹配 print(len(driver.find_elements_by_tag_name('input'))) #通过tag_name driver.find_element_by_link_text('新闻').click() #通过link全部匹配 driver.find_element_by_partial_link_text('信息网络传播').click() #通过link，部分匹配 time.sleep(2) driver.quit()#退出浏览器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676621f4e89dfb6699fe087cff418be2/" rel="bookmark">
			lostash Timeout executing grok 问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Timeout executing grok 问题排查1. 问题背景1. 基础配置2. pipeline配置 2. 问题表现3. 尝试通过修改 memory-queue+ poll-size4. 通过gc日志定位问题 Timeout executing grok 问题排查 使用logstash的时候发现会有这个报错，导致logstash不稳定，input端是kafka，就会导致kafka的反复rebalance,一开始排查思路有问题，而且网上的资料可能都是其中的一个原因，所以导致我的排查思路偏了。
1. 问题背景 我有一组logstash 从kafka中消费日志数据，解析后丢到ES当中，提供一些日志的检索能力。大概的配置是这样的。
1. 基础配置 logstash版本 7.5.0
jvm
java -version openjdk version "1.8.0_312" OpenJDK Runtime Environment (build 1.8.0_312-b07) OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode) -Xms6g -Xmx6g config/logstash.yml
pipeline.workers: 6 pipeline.batch.size: 50 2. pipeline配置 input { kafka{ bootstrap_servers =&gt; "xxx:9092" topics_pattern =&gt; "log_.*" auto_offset_reset =&gt; "latest" group_id =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676621f4e89dfb6699fe087cff418be2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1fc8784fe9aaa7b591a2a9d56e0bfce/" rel="bookmark">
			解决跨域：“Access to XMLHttpRequest at ‘http://127.0.0.1:8081‘ from origin ‘http://localhost:8080‘“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 vue 过程中经常会向服务器请求数据，但是时常会发生跨域的错误，具体什么是“跨域”请自行百度，这里说明一下怎么解决这个问题。
1、在 vue.config.js 文件中配置如下操作：
2、在 main.js 中修改baseURL
3、在服务器中配置允许跨域
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fac8f54fd0b098fac24e4d5ed29a27/" rel="bookmark">
			实现mini-vue3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下面链接看视频 视频地址
初始化项目 yarn init -y vue3源码采用的是monorerpo的管理方式，我们这就简单点的方式
创建包
集成typescript
注意如果没有安装typescript需要先安装typescript
npx tsc --init 集成jest
yarn add jest @types/jest --dev 注意安装之后还是不能识别spec.ts文件
需要在ts.config文件中配置
配置测试脚本命令
配置ts.config
解决jest不兼容esmodule的问题
配置一下babel
https://jestjs.io/docs/getting-started
安装插件jest
实现收集依赖 先创建effect.spec.js
describe('effect', () =&gt; { it("enter", () =&gt; { const af = reactive({ age: 1 }) /** * 所谓的收集依赖就是将effect下面的回调函数fn get的时候先放在一个容器中 * set的时候在执行所有被收集起来的fn */ let newAge effect(() =&gt; { newAge =af.age + 1 }) expect(newAge).toBe(2) af.age++ expect(newAge).toBe(3) }) }) 配置ts.config使其兼容es6
reactive.spec.ts
import { reactive } from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68fac8f54fd0b098fac24e4d5ed29a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9fdc68db0c273c810244b795d36959/" rel="bookmark">
			数据结构（C语言）哈夫曼树 11月25日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验内容：
1．设置7个字符a~g的权值，以它们为叶子构造哈夫曼树
2. 输出它们的哈夫曼编码。
哈夫曼树：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include"string.h" //哈夫曼树 #define MAXLEAF 100 //最多叶子节点数 #define MAXVALUE 100 //最大权值 typedef struct { int weight;//权值 int parent;//父节点 int lchild;//左孩子 int rchild;//右孩子 }hnodetype; int n = 7;//叶子节点个数，全局变量 //哈夫曼算法生成哈夫曼树（最优二叉树） void huffmantree(hnodetype huffnode[MAXLEAF], int n) { int i = 0, j = 0; for (i = 0; i &lt; 2 * n - 1; i++) //初始化huffnode数组 { huffnode[i].weight = 0; huffnode[i].parent = -1; huffnode[i].lchild = -1; huffnode[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c9fdc68db0c273c810244b795d36959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26037711acd81b4fc76630baec6f32c5/" rel="bookmark">
			5940. 从数组中移除最大值和最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5940. 从数组中移除最大值和最小值 给你一个下标从 0 开始的数组 nums ，数组由若干 互不相同 的整数组成。
nums 中有一个值最小的元素和一个值最大的元素。分别称为 最小值 和 最大值 。你的目标是从数组中移除这两个元素。
一次 删除 操作定义为从数组的 前面 移除一个元素或从数组的 后面 移除一个元素。
返回将数组中最小值和最大值 都 移除需要的最小删除次数。
示例 1： 输入：nums = [2,10,7,5,4,1,8,6] 输出：5 解释： 数组中的最小元素是 nums[5] ，值为 1 。 数组中的最大元素是 nums[1] ，值为 10 。 将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。 结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。 示例 2： 输入：nums = [0,-4,19,1,8,-2,-3,5] 输出：3 解释： 数组中的最小元素是 nums[1] ，值为 -4 。 数组中的最大元素是 nums[2] ，值为 19 。 将最大值和最小值都移除需要从数组前面移除 3 个元素。 结果是 3 ，这是所有可能情况中的最小删除次数。 示例 3： 输入：nums = [101] 输出：1 解释： 数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。 移除它只需要 1 次删除操作。 提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26037711acd81b4fc76630baec6f32c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c5aeee7d10d1ed65d6e58676a6d9d2/" rel="bookmark">
			5939. 半径为 k 的子数组平均值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5939. 半径为 k 的子数组平均值 给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。
半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。
构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。
x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c5aeee7d10d1ed65d6e58676a6d9d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259c38d19ecef2d4be1f0aafb9d9e17b/" rel="bookmark">
			Navicat如何连接本地MySql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接连接
打开navicat，点击连接-&gt;MySql
可是点击“连接测试的时候”就出现了错误：
2.解决：
原因：
这是因为我安装的数据库版本是，mysql8。
在mysql8之前的版本中加密规则为mysql_native_password，而在mysql8以后的加密规则为caching_sha2_password。
而未更新驱动的navicat是按之前的即mysql_native_password的规则进行加密的，所以我们可以将mysql用户登录的加密规则修改为mysql_native_password。
解决方法
Win+R
输入cmd
输入如下命令：
3条命令：
ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; FLUSH PRIVILEGES; 这样修改加密规则后，应该就没问题了。
注意：navicat连接数据库的密码，和进入数据库的密码是一个密码。
3.连接
这样再点击测试，就提示测试成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613bbbf567c3cf04457bba923d6e5345/" rel="bookmark">
			寻找数组的中心索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1
优化后：
class Solution { public int pivotIndex(int[] nums) { int sum = 0; for(int i = 0;i&lt;nums.length;i++){ sum += nums[i]; } int sum_right = sum; for(int j = 0;j&lt;nums.length;j++){ sum_right = sum_right - nums[j]; if((sum-nums[j])==sum_right*2){//如果j是中心点，那么左边和等于右边和，那么总和sum-nums[j]是sum_right的2倍 return j; } } return -1; } } 或者这样写
class Solution { public int pivotIndex(int[] nums) { int sum = 0; for(int i = 0;i&lt;nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/613bbbf567c3cf04457bba923d6e5345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e3fd0dc5f83ae4831dcf420696dfef/" rel="bookmark">
			【Rocky Linux】Rocky Linux 8.5版本全新图文安装教程并更换阿里镜像源等配置操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、参考链接说明二、什么是Rocky Linux？三、Rocky Linux系统安装步骤1、下载Rocky Linux官方镜像2、进入Rocky Linux的初始安装界面3、选择安装过程中的 语言4、设置相关安装信息摘要(1)修改本地化中的时间和日期(2)设置软件中软件选择。(3)设置系统中的磁盘分区(4)在用户设置中设置ROOT密码 5、安装信息设置完成后，开始安装6、安装完成，重启系统7、重启系统后，进行初始化操作(1)勾选✔许可条款(2)结束配置(3)设置用户名(4)设置用户名密码 8、初始化完成，开始使用 三、Rocky Linux系统配置步骤1、修改主机名2、配置网络信息(1)修改ifcfg-ens160网络配置文件(2)重启网络并查看状态(3)检查网络配置是否已正确应用(4)查看所有接口详细信息(5)测试网络连通性 3、使用阿里云Rocky Linux镜像源替换默认源(1)打开终端，备份默认源(2)更换阿里云镜像源 一、参考链接说明 文章涉及镜像下载和参考资料如下：
Rocky Linux官网：
https://rockylinux.org/
Rocky Linux官网安装手册文档：https://docs.rockylinux.org/zh/guides/installation/
Rcoky Linux 8.5版本镜像下载链接：https://www.rockylinux.org/download/
阿里巴巴开源镜像站：
https://developer.aliyun.com/mirror/
阿里巴巴Rocky Linux镜像源链接：
https://developer.aliyun.com/mirror/rockylinux?spm=a2c6h.13651102.0.0.46951b11x4Qj3N
二、什么是Rocky Linux？ Rocky Linux是一个社区企业操作系统，旨在100%兼容美国顶级企业Linux发行版，因为其下游合作伙伴已经改变了方向。它正在由社区密集开发。Rocky Linux由CentOS项目的创始人Gregory Kurtzer领导。请贡献者使用此站点上提供的通信选项进行联系。
Rocky Linux 是 CentOS 的一个分支，它位于 Red Hat Enterprise Linux（RHEL） 的下游。与 CentOS 一样，它提供了非常适合服务器的稳定版 Linux。它旨在作为 CentOS 的完全兼容替代品。
三、Rocky Linux系统安装步骤 1、下载Rocky Linux官方镜像 Rocky-8.5-x86_64-dvd1.iso
根据需要选择对应的版本进行下载安装即可。
本实验使用Rocky-8.5-x86_64-dvd1.iso镜像进行安装操作。
（此镜像大小约为9.98 GB ,可提前下载准备至本地。）
2、进入Rocky Linux的初始安装界面 选择install Rocky Linux 8后，按下回车键enter，开始安装Rocky Linux。
3、选择安装过程中的 语言 本实验采用中文安装。单击“继续”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e3fd0dc5f83ae4831dcf420696dfef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69368ac0efb12075a08fb199ae3ce4ad/" rel="bookmark">
			itextpdf html转pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		itextpdf html转pdf ************** 相关类与接口
HtmlConverter
public class HtmlConverter { private HtmlConverter() { } *********** 转换为pdf public static void convertToPdf(String html, OutputStream pdfStream) { public static void convertToPdf(String html, OutputStream pdfStream, ConverterProperties converterProperties) { public static void convertToPdf(String html, PdfWriter pdfWriter) { public static void convertToPdf(String html, PdfWriter pdfWriter, ConverterProperties converterProperties) { public static void convertToPdf(String html, PdfDocument pdfDocument, ConverterProperties converterProperties) { public static void convertToPdf(File htmlFile, File pdfFile) throws IOException { public static void convertToPdf(File htmlFile, File pdfFile, ConverterProperties converterProperties) throws IOException { public static void convertToPdf(InputStream htmlStream, OutputStream pdfStream) throws IOException { public static void convertToPdf(InputStream htmlStream, OutputStream pdfStream, ConverterProperties converterProperties) throws IOException { public static void convertToPdf(InputStream htmlStream, PdfDocument pdfDocument) throws IOException { public static void convertToPdf(InputStream htmlStream, PdfWriter pdfWriter) throws IOException { public static void convertToPdf(InputStream htmlStream, PdfWriter pdfWriter, ConverterProperties converterProperties) throws IOException { public static void convertToPdf(InputStream htmlStream, PdfDocument pdfDocument, ConverterProperties converterProperties) throws IOException { *********** 转换为document public static Document convertToDocument(String html, PdfWriter pdfWriter) { public static Document convertToDocument(InputStream htmlStream, PdfWriter pdfWriter) throws IOException { public static Document convertToDocument(String html, PdfWriter pdfWriter, ConverterProperties converterProperties) { public static Document convertToDocument(InputStream htmlStream, PdfWriter pdfWriter, ConverterProperties converterProperties) throws IOException { public static Document convertToDocument(String html, PdfDocument pdfDocument, ConverterProperties converterProperties) { public static Document convertToDocument(InputStream htmlStream, PdfDocument pdfDocument, ConverterProperties converterProperties) throws IOException { *********** 转换为element public static List&lt;IElement&gt; convertToElements(String html) { public static List&lt;IElement&gt; convertToElements(InputStream htmlStream) throws IOException { public static List&lt;IElement&gt; convertToElements(String html, ConverterProperties converterProperties) { public static List&lt;IElement&gt; convertToElements(InputStream htmlStream, ConverterProperties converterProperties) throws IOException { static IMetaInfo createPdf2HtmlMetaInfo() { private static IMetaInfo resolveMetaInfo(ConverterProperties converterProperties) { private static class HtmlMetaInfo implements IMetaInfo { Converterproperties
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69368ac0efb12075a08fb199ae3ce4ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36588b993d920d21fb5cf7461488b0f/" rel="bookmark">
			学习笔记 辗转相除法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。
算法简介 欧几里得算法是用来求两个正整数最大公约数的算法。古希腊数学家欧几里得在其著作《The Elements》中最早描述了这种算法,所以被命名为欧几里得算法。
扩展欧几里得算法可用于RSA加密等领域。
假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：
1997 / 615 = 3 (余 152)
615 / 152 = 4(余7)
152 / 7 = 21(余5)
7 / 5 = 1 (余2)
5 / 2 = 2 (余1)
2 / 1 = 2 (余0)
至此，最大公约数为1
以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。
代码实现 //递归实现 #include&lt;stdio.h&gt; int gcd(int n, int m) { if (n % m == 0) { return m; } else { return gcd(m, n % m); } } int main() { int n = 0, m = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36588b993d920d21fb5cf7461488b0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc8a79b7366f44febbd09797f582d313/" rel="bookmark">
			容器云系列之Docker Swarm集群管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Swarm是Docker的集群管理工具，它提供了标准的Docker API，所有任何已经与Docker守护程序通信的工具都可以使用Swarm轻松地扩展到多个主机。支持的工具包括Dokku、Docker Compose、Docker Machine和Jenkins等。
1、Swarm原理 Swarm集群由多个运行在swarm mode的docker主机组成，这些docker主机分为管理节点（manager）和工作节点（work node）。Swarm mananger节点负责整个集群的管理工作包括集群配置、服务管理等；Work node节点主要负责运行相应的服务来执行任务（task）。
Swarm集群和standalone部署的docker有以下优点：1）在线修改Service的配置，包括networks和volumes，不需要重启docker服务；2）Swarm集群时候，可以将其它standalone模式的docker主机加入到Swarm集群。
Swarm中有几个基本概念，包括nodes、Service和tasks以及load balancing：
Node Node是加入到Swarm集群中的Docker实例，也可以认为是一个docker节点，包括管理节点和工作节点。在部署应用到Swarm集群的时候，会向管理节点提交service定义，管理节点会将这些这些work也就是tasks分发到work节点中。Work节点接收并执行管理节点分配的任务，work节点也会将当前tasks的状态通知到管理节点以维护节点的状态信息。
Service and tasks Service是manage和work节点上执行的task的定义，当创建service的时候可以指定使用哪个container image以及执行的命令。在replicated service模式下，swarm管理节点会根据desired state中设置的scale分发replica tasks；对于global service模式，swarm集群会向每个可用的节点运行tasks。
Load balancing Swarm集群使用ingress loading balancing提供集群服务，Swarm集群会自动为service分配PublishedPort，默认使用30000-32767范围。
1.1 Node节点 Swarm中node节点包括manage管理节点和work工作节点。
Manager node Manager使用raft算法维护整个集群和运行的service的internal状态，主要完成以下tasks：
维护cluster statescheduling服务service swarm mode集群服务 Docker建议使用基数manager节点以保证可用性，最大使用7个manager节点。
Work node Work节点是容器实际运行的实例，在Swarm集群中必须存在manager节点。默认情况下manager节点也是work节点，但在多节点的Swarm集群中为了避免调度任务运行在manager节点，可以将manager节点设置为Drain模式，这样调度不会将任务分配到Drain模式，只会在Active模式的节点上分配任务。
Role变化 通过运行命令docker node promote可以将worker节点变为manager节点，同样也可以将manager节点转换为worker节点。
1.2 Service 当Service部署到Swarm集群的时候，swarm管理节点会将service定义作为service的理想状态，然后会将service调度到集群的节点上，以一个或多个tasks执行，这些nodes上运行的tasks之间是相互独立的。
如图所示，在三个HTTP listener实例中实现负载均衡，service中有三个replica tasks，每个实例是Swarm集群中的一个task。Task是Swarm集群中调度的最小单元，当创建或更新service时候给定了desired state，集群会调度tasks来实现这种理想状态。Task是一种单向机制，在它的整个周期过程中会完成一系列的状态，如assigned、prepared和running等。如果tasks失败了，集群会remove这个tasks并创建新的tasks来替代。
上图展示了Swarm集群中service创建请求并将tasks调度到worker节点的过程：
Client发送创建service请求
Swarm manager节点
a) API：接收到命令并创建service
b) Orchestrator：协调者为service循环创建tasks
c) Allocater：为tasks分配ip地址
d) Dispatcher：将tasks分配到node
e) Scheduler：引导worker节点运行tasks
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc8a79b7366f44febbd09797f582d313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91241f824ffd4f0188a0ea30ab8577fa/" rel="bookmark">
			Jmeter学习笔记之聚合报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、聚合报告的添加不做赘述，右键添加即可。
2、聚合报告中各参数的分析。
lable：线程组的名称Samples（样本）：一共发出去多少个请求Average（平均值）：平均响应时间（ms）Medium（中位数）：中位数响应时间，50%请求响应的时间（ms）90%line：90%的请求响应不会超过该时间（ms）95%line：95%的请求响应不会超过该时间（ms）99%line：99%的请求响应不会超过该时间（ms）Min（最小值）：最小响应时间（ms）Max（最大值）：最大响应时间（ms）Error%（异常率）：错误的请求数量Throughput（吞吐量）：默认情况下表示每秒完成的请求数Received KB/sec：每秒接收数据量Sent KB/sec：每秒发送数据量 3、Medium、90%line、95%line、99%line，这几个参数涉及到的是数学中的百分位数，从中位数可以看出，它表示的不仅仅是简单随机的50%个请求，是将这些请求的响应时间按大小顺序排列后，50%line处的响应时间，相同的其他line也是这样理解。
4、聚合报告中有average和medium，他们的计算方法不同；
平均数更容易受所有线程响应时间值的影响，和每一个数据都有关，一定会随之变化而变化，信息充分从而也能更好的反应出整个线程组的响应时间情况；
中位数不易受线程组中其他线程响应时间值的影响，所以当线程组中的有比较极端的值出现时，偏大或者偏小，用中位数来表示整体数据的集中趋势就比较合适；
5、Throughput（吞吐量）
在jmeter中，大多数情况下，Throughput吞吐率被认为等于TPS，这里提供一个参考：Jmeter的Throughput和平均响应时间计算方法整理 - 雾火 - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3edb5cde599285467ee63b01fbdf8495/" rel="bookmark">
			线程池ThreadPoolTaskExecutor实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. ThreadPoolTaskExecutor是什么2. 为什么使用ThreadPoolTaskExecutor2.1直接使用ThreadPoolExecutor2.2 使用ThreadPoolTaskExecutor 3. 如何使用ThreadPoolTaskExecutor3.1 配置3.2 业务中使用3.3 TaskDecorator 1. ThreadPoolTaskExecutor是什么 ThreadPoolTaskExecutor是Spring基于java本身的线程池ThreadPoolExecutor做的二次封装，主要目的还是为了更加方便的在spring框架体系中使用线程池。
2. 为什么使用ThreadPoolTaskExecutor 一句话：可以让使用线程池的编码更方便更优雅。
使用线程池时，主要有两种方式：ThreadPoolExecutor和ThreadPoolTaskExecutor；
2.1直接使用ThreadPoolExecutor 原始的使用线程池，要么直接new ThreadPoolExecutor，要么使用jdk中的Executors工具类，此工具类提供了一些常用的api来创建线程池。
但是，都需要在业务代码中显式的编程，代码不够简洁。
2.2 使用ThreadPoolTaskExecutor 目前大家都在使用spring全家桶编写服务代码。也都习惯了使用注解式编程方式。ThreadPoolTaskExecutor本身相当于一个普通的bean，他只是基于ThreadPoolExecutor做了一定的封装，线程池的核心逻辑还是ThreadPoolExecutor来实现的，一些线程池的基本配置参数，也和原始的ThreadPoolExecutor的保持一致。
下面来直接通过使用demo来直观的感受下。
3. 如何使用ThreadPoolTaskExecutor ThreadPoolTaskExecutor在spring体系中，就是一个普通的bean，所以支持bean的各种配置方式，本文demo中，就直接介绍最常用的java配置类方式。
3.1 配置 直接写一个配置类即可：
@EnableAsync @Configuration public class TaskConfiguration { @Bean("taskExecutor") public Executor schedulingTaskExecutor() { return initExecutor(4, 4, 1, new ThreadPoolExecutor.AbortPolicy(), "taskExecutor-"); } private Executor initExecutor(int corePoolSize, int maxPoolSize, int queueCapacity, RejectedExecutionHandler rejectedExecutionHandler, String threadNamePrefix) { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(corePoolSize); executor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3edb5cde599285467ee63b01fbdf8495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509fe3fbcefbf69e06211729bf14e08d/" rel="bookmark">
			Jmeter学习笔记之响应断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简述
jmeter中的响应断言即判断接口请求的返回值是否包含（或等于、不等于）测试人员所预期的数据；响应断言作为一个测试过程中的检查点，不仅可以判断请求是否发送成功，还可以针对具体的返回值判断请求成功与失败，在测试过程中可以有针对性的进行添加。
2、添加响应断言
选择想要添加断言的线程组--添加--断言--响应断言。
3、响应断言内容
应用范围：Main sample only仅当前主线程组使用（比较常见），Main sample and sub-samples当前主线程组和与之相关联的线程组使用。测试字段：【响应文本】即响应的数据，比如json等文本（常用），【响应代码】即http响应状态码，比如200,404等（常用），【响应信息】即http响应状态码对应的响应信息，比如OK,Found等。模式匹配规则：【包括】即测试字段包含于请求结果中；【匹配】即测试字段完全匹配请求结果，不区分大小写；【相等】即测试字段完全匹配请求结果，区分大小写。测试模式：想要匹配的请求结果，http响应状态码或者响应文本等信息。自定义失败信息：请求结果汇总没有想要的结果信息时，及失败时提示的信息，添加响应断言结果后可展示。 4、断言结果
每个线程组可添加单独的多个响应断言和结果树，也可以在最外层添加结果树，统一查看信息。线程组--添加--监听器--断言结果，在断言结果页面可查看请求后的响应结果，添加的断言是否响应；也可在察看结果树页面双击请求，查看断言情况，下面是一个响应断言失败的小例子。
发送线程组请求后，如果失败则会：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d8d7bcba7386082d11d6416644bf8d/" rel="bookmark">
			C&#43;&#43; 最大子序和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [0] 输出：0 这道题确实没想明白。后来看的解析才知道的，先说说自己的思路，想到的是用for循环做，从第一个数字加到数组的最后一个数字，并用临时变量记录最长的那个和对应的末位数所在位置。然后从最后一个数字加到第一个数字。用临时变量记录最大和对应的开头数字所在位置。
代码测试了两次增加了很多判定但是最后还是错掉了，思路上有点偏差，代码如下：
int maxSubArray(vector&lt;int&gt;&amp; nums) { int a=0,b; int i,j,k; int length = nums.size(); b=length-1; //int len=length-1; int temp1=0,temp2=0; int sum=0,sum1,sum2; sum1=nums[0]; sum2=nums[length-1]; //sum2=0; //cout&lt;&lt;sum1&lt;&lt;sum2&lt;&lt;endl; if(length==1) { sum=nums[0]; return sum; } else if(length&gt;1) for(i=0;i&lt;length;i++) { temp1=temp1+nums[i]; if(temp1&gt;sum1) { sum1=temp1; a=i; } } for(j=length-1;j&gt;=0;j--) { temp2 += nums[j]; if(temp2&gt;sum2) { sum2=temp2; b=j; } } if(a&lt;b) sum=max(sum1,sum2); for(k=b;k&lt;=a;k++) { sum+=nums[k]; } cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; return sum; } 正确解答方式： #include &lt;iostream&gt; #include &lt;vector&gt; #include&lt;algorithm&gt; using namespace std; class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int pre = 0, maxAns = nums[0]; for (const auto&amp; x : nums) { pre = max(pre + x, x); maxAns = max(maxAns, pre); } return maxAns; } }; int main() { Solution S; vector&lt;int&gt; num= { -2, 1, -3, 4, -1, 2, 1, -5, 4 } ; int temp = S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64d8d7bcba7386082d11d6416644bf8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98342054f2c100457a78762ae9143c88/" rel="bookmark">
			redis分布式锁实践 并实现看门狗锁续期机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis分布式锁最佳实践（并实现锁续期机制） 文章目录 redis分布式锁最佳实践（并实现锁续期机制）1. 分布式锁是什么？2. setnx 和 AQS state3. jedis完成分布式锁得设计#3.1 v1版本3.2 v2版本3.3 v3版本 4. 测试 1. 分布式锁是什么？ 在单体项目进入分布式项目之后，各个业务被拆分成多个微型服务，核心微服务还可以搭建集群，那么搭建集群之后问题就来了，以前是单体项目，如果涉及共享资源得一些操作我们可以使用ReentrantLock来进行加锁，那么如今微服务集群项目下，做不到了，那么我么其实就可以使用一些中间件，基于中间件得原子性操作来实现分布式锁，今天我们就来使用redis搭建分布式锁实践。
2. setnx 和 AQS state 在redis中有setnx命令 ，该命令使用逻辑如下：
可以看到我们使用setnx添加一个key-value得值，第一次增加之后，第二次再去增加发现返回值变成了0。意味着setnx命令就如同Java中unsfae类得CAS操作一样。
这里简单说一下AQS得机制，AQS是Java同步器得基石，如我们常用得ReentranLock和ReadWriteReetranLock还有seameple信号量等都是基于AQS来实现，在AQS有一个state得状态值，当state状态值为0时表示没有人获取该锁，=1 表示有线程获取了该锁，其他线程lock时会进入阻塞队列中等待。
而redis中得setnx和javaAQS得state就有异曲同工之处，我们就可以借助setnx来实现分布式锁，当然这一前提是建立在redis得业务处理是单线程模式执行。
3. jedis完成分布式锁得设计 #3.1 v1版本 package com.xzq.lock; /** - @Author xzq - @Description // 分布式锁实践 - @Date 2021/11/27 9:45 - @Version 1.0.0 **/ public class RedisLock { private Logger logger = LoggerFactory.getLogger(RedisLock.class); private Jedis jedis = JedisPoolManager.getJedis(); static class JedisPoolManager{ private static JedisPool jedisPool; static { JedisPoolConfig config = new JedisPoolConfig(); config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98342054f2c100457a78762ae9143c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b95d7d4db2bc5a2b2a634c0b49934f/" rel="bookmark">
			laravel8实现用passport实现接口的登录和jwt生成(生成token)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装passport插件
composer require laravel/passport 2.执迁迁移文件，生成数据表，保存token数据 （会直接生成5张表）
php artisan migrate 3.生成客户端授权码,必须的操作，没有会报错找不到配置文件
php artisan passport:install 4.修改接口账号模型
use Laravel\Passport\HasApiTokens; 5.修改config/auth.php文件中的api配置
6.令牌的有效期，在app/Proivders/AuthServiceProvide.php文件中的boot方法添加有效期
use Laravel\Passport\Passport; // token认证有效期2小时 Passport::tokensExpireIn(now()‐&gt;addHour(2)); // 刷新token认证有效期30天 Passport::refreshTokensExpireIn(now()‐&gt;addDays(30)); 7.解决auth在接口中登录没有attempt问题
8.验证账号
public function login(Request $request) { $validator=\Validator::make($request-&gt;all(),[ 'username'=&gt;'required', 'password'=&gt;'required', ]); if ($validator-&gt;fails()){ return ['code'=&gt;500,'msg'=&gt;$validator-&gt;errors()-&gt;first()]; } //dd(get_class_methods(auth())); //应为基于auth登录，所匹配的字段不能出现中文 $bool=auth()-&gt;guard('apiss')-&gt;attempt($request-&gt;all()); if ($bool){ $user=auth()-&gt;guard('apiss')-&gt;user(); //在这里生成token $token=$user-&gt;createToken('api')-&gt;accessToken; $data=['token'=&gt;$token,'expire'=&gt;7200]; return ['code'=&gt;200,'msg'=&gt;'登录成功','data'=&gt;$data]; } return ['code'=&gt;500,'msg'=&gt;'账号密码错误']; } 9.在hearder中加入token key=Authorization
value=Bearer xxx此处为tokenxxxxxxxxx 千万记得Bearer 后面是有一个空格的 千万记得Bearer 后面是有一个空格的 千万记得Bearer 后面是有一个空格的
10.测试中间件拦截功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f418af0d4afc0e309f4ac2b12e30c8/" rel="bookmark">
			491.递增子序列【回溯】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		491.递增子序列
题目链接：https://leetcode-cn.com/problems/increasing-subsequences/
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
示例:
输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
说明:
* 给定数组的长度不会超过15。
* 数组中的整数范围是 [-100,100]。
* 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。
思路：
这个递增子序列比较像是取有序的子集。而且本题也要求不能有相同的递增子序列。
这又是子集，又是去重，是不是不由自主的想起了刚刚的90.子集II【回溯】。
就是因为太像了，更要注意差别所在，要不就掉坑里了！
在90.子集II【回溯】中我们是通过排序，再加一个标记数组来达到去重的目的。
而本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了。
**所以不能使用之前的去重逻辑！**
本题给出的示例，还是一个有序数组 [4, 6, 7, 7]，这更容易误导大家按照排序的思路去做了。
为了有鲜明的对比，我用[4, 7, 6, 7]这个数组来举例，抽象为树形结构如图：
回溯三部曲：
* 递归函数参数
本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。
代码如下：
```
List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
List&lt;Integer&gt; path = new ArrayList();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f418af0d4afc0e309f4ac2b12e30c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab9d9922c25ef4d2933832b65c6b0b6/" rel="bookmark">
			css实现三角形的6种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一些面试经验中，经常能看到有关css的题目都会有一道如何使用css绘制三角形，而常见的回答通常也只有使用border进行绘制一种方法。
而css发展到今天，其实有很多有意思的仅仅使用css就能绘制出来的三角形的方式，本文将展示6中使用css绘制三角形的方式，而且它们都很好掌握。
当然本文是抛砖引玉，css日新月异，可能还有一些有意思的方法本文遗漏了，欢迎大家在留言区补充。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;实现三角形的6种方法&lt;/title&gt; &lt;style type="text/css"&gt; #border { border-top: 50px solid greenyellow; border-bottom: 50px solid deeppink; border-left: 50px solid bisque; border-right: 50px solid chocolate; height: 0; width: 0; } #lg { width: 100px; height: 100px; background: linear-gradient(45deg, deeppink, deeppink 50%, yellow 50%, yellow 100%); } #cg { width: 100px; height: 100px; background: conic-gradient(from 90deg at 50% 0, deeppink 0, deeppink 45deg, transparent 45.1deg); } #triangle { width: 150px; height: 100px; position: relative; overflow: hidden; } #triangle:before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: deeppink; transform-origin: right top; transform: rotate(45deg); } #clip { width: 100px; height: 100px; background: deeppink; clip-path: polygon(0 0, 100% 0, 0 100%, 0 0); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab9d9922c25ef4d2933832b65c6b0b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd66e2ee4fd590a684f94f848fff00c8/" rel="bookmark">
			EasyExcel填充模板及图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：https://www.yuque.com/easyexcel/doc/fill
其实参考官网文档已经可以正常使用了，这里主要是记录如何在模板中填充图片
请求参数 注意：sheetNo 能帮助我们定位数据是哪个sheet
{ "fileId": 804, "data": [ { "sheetNo": 0, "content": "简单说明", "test_image": 907, "test2_image": 908 }, { "sheetNo": 1, "name": "名称" } ] } 解析页面表单 /** * 解析页面表单，根据Map填充 * * @param map * @return */ @Override public AjaxResult parse(Map&lt;String, Object&gt; map) { // 1. 获取前端的传值 -&gt; cn.hutool.json Map&lt;String, Object&gt; jsonMap = JSONUtil.parseObj(map); // 1.1 获得 fileId 数据 // 这里理论上直接传 fileId 即可，即可找到模板对应的文件 Integer fileId = (Integer) jsonMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd66e2ee4fd590a684f94f848fff00c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a139960ec8bc1dfca6fbf9d8e30b15c/" rel="bookmark">
			无法将“node.exe”项识别为 cmdlet、函数、脚本文件或可运行程序的名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows10 报错信息：
&amp; : 无法将“node.exe”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。 所在位置 C:\Users\Mr.Sun\AppData\Roaming\npm\npm.ps1:24 字符: 7 + &amp; "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args + ~~~~~~~~~~ + CategoryInfo : ObjectNotFound: (node.exe:String) [], CommandNotFoundException 解决方法：
1 去C盘查看用户下npm里是否有node.exe文件 ，大概路径
C:\Users\xxxx(your win name)\AppData\Roaming\npm 2 如果少了node.exe，找到node安装路径目录，复制node.exe文件到上面文件路径下，重启即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d8db7f092654b0769ef1769b016141/" rel="bookmark">
			CEC2021基础测试函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用于群智能优化算法性能测试的测试函数：CEC2021基础测试函数 下载地址：
https://download.csdn.net/download/Vertira/46236811https://download.csdn.net/download/Vertira/46236811
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880832389a9a680bbafe8ce87aba5051/" rel="bookmark">
			如何在Vue3.0中引入jQuery并使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装jQuery
需要在项目根目录下使用 npm 命令：
npm install jquery --save 2、vue.config.js文件
在项目根目录下创建一个 vue.config.js 文件（如果已经存在无需创建），进行如下配置：
const webpack = require('webpack') module.exports = { configureWebpack: { plugins: [ new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery', 'windows.jQuery': 'jquery' }) ] } } 3、.eslintrc.js文件
在项目目录中找到 .eslintrc.js 文件，在 env 中配置 jquery：true
4、最后在 main.js 文件中导入 jQuery
至此完成 jQuery 的引入和配置，可以全局使用。
使用例子
&lt;template&gt; &lt;div class="home"&gt; &lt;div class="d"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', date() { return {} }, mounted() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/880832389a9a680bbafe8ce87aba5051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899d2a5645785081c6a75675e0652cd3/" rel="bookmark">
			微服务常见问题整理（2021）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务常见问题 什么是微服务 （把传统服务拆分至最小服务单元，每个服务专注一件事，服务之间高内聚，松耦合）
技术维度理解 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。
微服务是如何通讯的 1、远程调用基于HTTP的RESTful API2、 消息 ，通过消息中间件来做服务通信，比如rabitmq springcloud 与dubbo有哪些区别？ 相同点：SpringCloud 和Dubbo可以实现RPC远程调用框架，可以实现服务治理。不同点：SpringCloud是一套目前比较网站微服务框架了，整合了分布式常用解决方案遇到了问题注册中心Eureka、负载均衡器Ribbon ，客户端调用工具Rest和Feign，分布式配置中心Config，服务保护Hystrix，网关Zuul Gateway ，服务链路Zipkin，消息总线Bus等。 优点: 把客户端和服务端解耦，更松耦合 提高可用性，因为消息中间件缓存了消息，直到消费者可以消费，支持很多通信机制比如通知、请求/异步响应、发布/订阅、发布/异步响应
缺点：消息中间件有额外的复杂性
dubbo内部实现功能没有SpringCloud强大（全家桶），只是实现服务治理，缺少分布式配置中心、网关、链路、总线等，如果需要用到这些组件，需要整合其他框架。
请谈谈对SpringBoot 和SpringCloud的理解 SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务
SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系.
分布式系统面临的问题 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。服务雪崩：多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”. 一般情况对于服务依赖的保护主要有以下三种解决方案： 1、熔断模式：这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。隔离模式：这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。限流模式：上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。 什么事服务熔断，什么是服务降级 服务熔断：熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。 在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。
Hystrix服务降级：其实就是线程池中单个线程障处理，防止单个线程请求时间太长，导致资源长期被占有而得不到释放，从而导致线程池被快速占用完，导致服务崩溃。 整体资源快不够用了，忍痛将某些服务先关掉，待度过难关，再回来开启。
所谓降级，就是一般是从整体符合考虑，就是当某个服务熔断之后，服务器将不再被调用，此刻客户端可以自己准备一个本地的fallback回调，返回一个缺省值，这样做，虽然服务水平下降，但好歹可用，比直接挂掉要强。
请求超时降级，线程资源不足降级，降级之后可以返回自定义数据
微服务的优缺点，项目中遇到的坑 优点 每个服务专注一件事，更小 更内聚，开发简单，效率高每个服务可以使用不同语言开发每个服务独立，服务建松耦合易于第三方集成 缺点 维护成本增加，系统复杂性增加分布式一致性问题数据一致性问题服务通信成本增加服务依赖性能监控 什么是 Eureka服务注册与发现 Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。服务注册与发现对应微服务架构来说非常重要，有了服务发现和注册，值需要使用服务的标志符，就可以访问到服务，而不需要更改调用的配置文件。 Eureka的基本架构是什么？ eureka 比zookepper 好在哪 AP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。
Zookeeper 保证的是CP, Eureka 则是AP。
zk服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。
问题在于，选举leader的时间太长，30~120s,且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。
分布式更注重可用，最终一致性
Ribbon负载均衡 Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。
Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。
feign能干什么 Feign旨在使编写Java Http客户端变得更容易。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/899d2a5645785081c6a75675e0652cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ada9a42e4be14cdcc77617a47531b3f/" rel="bookmark">
			pytest 测试类的实例变量初始化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 pytest 编写测试用例，碰到场景如下：
class Test: def setup_class(self): print("exec setup class") self.a = 1 def setup(self): self.a += 1 print("exec setup -", self.a) def test_1(self): print(self.a) def test_2(self): print(self.a) def test_3(self): print(self.a) 我的目的是每条测试用例执行前，self.a 变量的值都自增 1，于是就取巧，通过 setup_class 和 setup 结合来实现，但是执行结果却跟我想的预期不同。
&gt;&gt;&gt; exec setup class exec setup - 2 2 exec setup - 2 2 exec setup - 2 2 每次 setup 的时候，都会重新初始化，得到的 self.a 的值为 1，所以每条用例执行的 a 都是 2。
到执行 case 2 前面的 setup 时，实例对象就变了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7b227a5abe78bc4133fa8ad31f6ac4/" rel="bookmark">
			requests&#43;re-爬取豆瓣电影top250，看看都有哪些电影上榜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 这是一个很简单的获取豆瓣网文本内容的爬虫，涉及到requests模块get方法的使用，正则表达式re模块的对数据进行抽取，得到我们关注的内容（电影名，影片上映时间，评分，评论人数），最后保存到csv文件中
前期准备 python模块： re模块,requests模块,csv模块
豆瓣电影top250地址：https://movie.douban.com/top250
请求数据 1、使用requests模块的get()方法获取网页源码。
# 请求头 import requests headers={ "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36" } #resp接收get请求响应的数据 resp=requests.get("https://movie.douban.com/top250",headers=headers) #text查看响应的内容 print(resp.text) resp.close() 使用requests获取的网页源码（开头）
网页开发者模式看到的源码（开头）
注意：
为什么get()需要headers参数：模拟网站的正常访问，绕开反爬机制
headers如何找到：F12，开发者工具。requests下
resp.close():关闭你的请求，如果你不关掉你的请求，时间长了或者多次执行代码后就会限制访问这个网页(亲测)
数据处理 2、使用正则表达式，对筛选我们需要的内容
#预加载 import requests import re headers={ "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36" } reStr=re.compile( r'&lt;li&gt;.*?&lt;em class=""&gt;(?P&lt;topnum&gt;.*?)&lt;/em&gt;.*?' # top榜排名 r'&lt;span class="title"&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?' # 电影名 r'.*?&lt;br&gt;(?P&lt;year&gt;.*?)&amp;nbsp' # 上映年份 r'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7b227a5abe78bc4133fa8ad31f6ac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83200aaff0e787f1d5c5d5a27255a667/" rel="bookmark">
			VOT Toolkit工具配置和使用--Python版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、可以先参考下以下几个博客内容，熟悉下配置方法
（1）VOT Toolkit工具使用说明（Python版）
（2）vot-toolkit-python测试DiMP50在VOT2018上的表现
（3） 用vot-toolkit-python测试可见光-红外模态融合跟踪算法mfdimp
（4） vot toolkit python配置
（5） vot toolkit python配置（有图有真相）
2、首先是环境的配置，参考vot官方 VOT Toolkit ，就是在选择的环境下输入以下代码安装vot toolkit：
pip install git+https://github.com/votchallenge/vot-toolkit-python ps：python版本和matlab版本不同，python版本vot toolkit只需要输入这一句就可以了
至于这两个工具，可以将代码下载到本地：
（1）vot-toolkit python版 github：
GitHub - votchallenge/toolkit: The official VOT evaluation toolkit
这个可以说就是vot toolkit使用的代码，就是在使用toolkit过程中，一些初始化、evaluate、analysis、报错提示等都在这个代码中，最重要的还有trax通信代码等，通过上面pip一条指令，这个包就直接安装到环境中了
ps:可以自己手动修改如 timeout改为300000等，但是记得修改的位置是该环境下载的包的位置，不是自己下载的代码位置（我一开始就改错了。。。）
（2）vot-toolkit 调试用基本跟踪器NCC
GitHub - votchallenge/integration: Integration examples and utilities for VOT toolkit
这个的话感觉就是一个对于vot toolkit 使用的例子，可以参考 python_ncc.py和vot.py来写自己的算法接口文件（通常是复制vot.py到自己的算法同目录文件夹下，只参考python_ncc.py修改自己的算法接口）
ps:修改自己的算法接口其实就是分为：（1）初始化首帧
（2）后续每一帧按照自己的算法返回预测的坐标
如果配置过got10k的话，其实几乎一样
3、在使用过程中，首先通过
vot initialize &lt;stack-name&gt; --workspace &lt;workspace-path&gt; --nodownload 来初始化目录，具体含义可以参考第一部分的几个博客，这里说明一点：
（1）如果不在线下载数据集的话，就按照所需要的格式自己去整理vot2014、2015数据集，就是把图片放在color文件夹下，其余文件和color文件夹同目录，不过2014的话建议在线下载，因为
1、看下所需格式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83200aaff0e787f1d5c5d5a27255a667/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/169/">«</a>
	<span class="pagination__item pagination__item--current">170/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/171/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>