<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2076c86399e10012d0ba4dd28d1d6d08/" rel="bookmark">
			relion 的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		relion是最有名的冷冻电镜三维重构图像处理软件之一，官方给出的安装教程有两处，一是来自官网：https://www3.mrc-lmb.cam.ac.uk/relion/index.php/Download_%26_install
官网上的教程非常详细，但有些繁琐，可能会对新手造成一些困扰，因此推荐官方在github上提供的教程，非常简洁：https://github.com/3dem/relion
本人使用Ubuntu 20.04.2 LTS系统，
需要的关键操作如下：
但是在安装完成后可能无法直接使用，提示：
relion: command not found 这是因为官方在github教程中没有加设置环境变量的步骤，过程如下：
vim ~/.bashrc 在底部添加一行语句：
export PATH="/your/path/to/relion/build/bin:$PATH" 使生效：
source ~/.bashrc 这样就设置完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4da40f0912c515f1a5fd7a96ef6a3a8/" rel="bookmark">
			麒麟系统V10-sp1安装cloud-init
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V10-sp1离线源码编译安装cloud-init-18.5 cloud-init源码下载地址：https://launchpad.net/cloud-init/+download
参考：https://cloud.tencent.com/document/product/213/12587
1.准备 1.1 上传cloud-init源码包 # mkdir /usr/local/sources 将cloud-init-18.5.tar.gz上传到/usr/local/sources目录下 1.2 上传依赖包 # 上传依赖包到/tmp下 # ls /tmp/cloud-init-soft.tar.bz2 1.3 配置本地yum源安装依赖 # mv kylin_x86_64.repo kylin_x86_64.repo.bak # tar -xf /tmp/cloud-init-soft.tar.bz2 -C /media/ # yum-config-manager --add-repo=file:///media/cloud-init-soft/ # echo "gpgcheck=0" &gt;&gt; media_cloud-init-soft_.repo # yum clean all &amp;&amp; yum list # yum -y install python* #一定要把本机自带的repo备份移走，用上面我们自己创建的！ 2.安装并配置cloud-init 2.1 解压源码包并安装 # cd /usr/local/sources/ &amp;&amp; tar -xf cloud-init-18.5.tar.gz # cd cloud-init-18.5/ # python setup.py build #输出如下： ..... running build_scripts creating build/scripts-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4da40f0912c515f1a5fd7a96ef6a3a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2d4035af1085e783079d78e67e56d1/" rel="bookmark">
			threejs 初始化封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		threejs 初始化封装 vue 中使用示例 对threejs场景进行初始封装，以便多项目复用。自用学习记录仅供参考，欢迎留言。
初始化包括以下：
场景初始化相机初始化灯光初始化，点光源，平行光，环境光初始化渲染器初始化鼠标控制器 通过new Web3DRenderer() 实例化以后可以拿到以上所有初始化对象。
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js' import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js' import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js' import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js' import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js' import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js' import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js' // import { TWEEN } from 'three/examples/jsm/libs/tween.module.min.js' import { GUI } from 'three/examples/jsm/libs/dat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2d4035af1085e783079d78e67e56d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76fae2fd4d099e953260dbca5ea4ca1a/" rel="bookmark">
			vite构建项目步骤以及所遇到的坑，要注意的事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装与启动步骤安装yarn安装vite项目并启动 vite配置创建路由安装路由：创建路由文件并配置路由引用路由 接口代理配置常见的报错问题开源demo下载总结 安装与启动步骤 安装yarn 首先用yarn命令进行安装，没有这个命令的同学可以先安装一下
npm install yarn -g
安装vite项目并启动 yarn create vite-app &lt;project name&gt; cd 项目名称 进入目录即可 yarn install yarn dev vite配置 配置文件为vite.config.js
启动配置文件和webpack方式一样 package.json里 “dev”: “vite --config ./vite.config.js”
const {resolve} = require('path') export default { alias: { '/@/': resolve(__dirname, './src') } } 注意： 这里定义@目录时，前面必须要添加斜杠/表示从根目录进来获取组件。而根据上面的定义则表示/@这个符号直接会指向根目录下的src文件夹
vue中路由的配置使用时如下
component: () =&gt; import('@/components/HelloWorld2.vue'),
改为
component: () =&gt; import('/@/components/HelloWorld2.vue'),
如果没有这个/@则调用的位置会自动从@node_module里去查找目录，导致路径始终获取失败。
创建路由 文件目录配置好之后我们就可以创建路由
安装路由： yarn add vue-router@next // 先安装路由
创建路由文件并配置路由 根目录下创建文件夹router,在到router里创建路由文件router.js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76fae2fd4d099e953260dbca5ea4ca1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d9b08a301b2c5f25950cc8ef58cc0c/" rel="bookmark">
			高级检索js获取文本框中的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html代码结构：
&lt;table class="addel" id="searchPlusTable"&gt; &lt;tr class="target"&gt; &lt;td class="jia"&gt;&lt;img src="/img/dyda/g1.png" alt=""&gt;&lt;/td&gt; &lt;td class=" jian"&gt;&lt;img src="/img/dyda/g2.png" alt=""&gt;&lt;/td&gt; &lt;td class="mohu"&gt; &lt;div class="select-container filter-box"&gt; &lt;span&gt;&lt;img src="/img/dyda/icon_arrow_down_x2.png" alt=""&gt;&lt;/span&gt; &lt;input class="filter-title" type="text" readonly="readonly" value="模糊" /&gt; &lt;ul class="filter-list"&gt; &lt;li&gt; &lt;a&gt;模糊&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="javascript:;"&gt;精确&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/td&gt; &lt;td class="zuozhe"&gt; &lt;div class="select-container filter-box"&gt; &lt;span&gt;&lt;img src="/img/dyda/icon_arrow_down_x2.png" alt=""&gt;&lt;/span&gt; &lt;input class="filter-title" type="text" readonly="readonly" value="正题名" /&gt; &lt;ul class="filter-list"&gt; &lt;li&gt; &lt;a&gt;正题名&lt;/a&gt; &lt;/li&gt; &lt;li th:each="ca,caStat : ${@initialCache.searchFieldList}" th:if="${ca.fieldName != '档号' and ca.fieldName !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d9b08a301b2c5f25950cc8ef58cc0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec6b1ebaf314ae15f6fed5261dfdbcf/" rel="bookmark">
			[python爬虫]爬取电影，电视剧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 影视作品存储格式爬取方法实际操作 影视作品存储格式 网页中的小视频往往以 &lt;video src="#"&gt;&lt;/video&gt;存在，拿到src中的视频地址即可下载; 大视频如电视剧，电影则先由厂商转码做清晰度处理，然后再进行切片，每片只有几秒钟，视频的播放顺序一般存储在m3u8文件中;
爬取方法 爬取m3u8文件;根据m3u8文件爬取视频;合并视频; 实际操作 以91看剧网的《名侦探柯南》电影迷宫的十字路口为例子!
查看页面源码找到包含m3u8的信息（有坑）
抓包工具找到的m3u8接口
https://m3api.awenhao.com/index.php?note=kkRq89j3mnaxf2bgp1sk5&amp;raw=1&amp;n.m3u8 https://m3api.awenhao.com/index.php?note=kkRpk9hzr2ay6g75et8nd&amp;raw=1&amp;n.m3u8 note是服务端生成随机码，且具有过期时间；
所以需要先爬取页面源码，再正则筛选生成的m3u8接口url;
获取m3u8 import requests import os # 正则匹配 re_obj = re.compile(r"url: '(?P&lt;url&gt;.*?)',", re.S) url = 'https://91kanju.com/vod-play/60608-1-1.html' res1 = requests.get(url, headers=headers) m3u8_url = re_obj.search(res.text).group('url') res1.close() # 下载m3u8文件 if not os.path.exists('./m3u8D'): os.mkdir('./m3u8D') res2 = requests.get(url=m3u8_url, headers=headers) with open('./m3u8D/名侦探柯南.m3u8', 'wb') as f: f.write(res2.content) res2.close() 根据m3u8中的视频url进行爬取 def get_url(): urls = [] with open('./m3u8D/名侦探柯南.m3u8', 'r', encoding='utf-8') as f: for line in f: # 去掉空格，换行符 line = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec6b1ebaf314ae15f6fed5261dfdbcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0e3187fecad4769e15d999c912e667/" rel="bookmark">
			Flowable集成mysql启动时报错 java.time.LocalDateTime cannot be cast to java.lang.String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Caused by: java.lang.ClassCastException: java.time.LocalDateTime cannot be cast to java.lang.String at liquibase.changelog.StandardChangeLogHistoryService.getRanChangeSets(StandardChangeLogHistoryService.java:287) ~[liquibase-core-3.5.5.jar:na] at liquibase.changelog.AbstractChangeLogHistoryService.upgradeChecksums(AbstractChangeLogHistoryService.java:64) ~[liquibase-core-3.5.5.jar:na] at liquibase.changelog.StandardChangeLogHistoryService.upgradeChecksums(StandardChangeLogHistoryService.java:258) ~[liquibase-core-3.5.5.jar:na] at liquibase.Liquibase.checkLiquibaseTables(Liquibase.java:1126) ~[liquibase-core-3.5.5.jar:na] at liquibase.Liquibase.update(Liquibase.java:205) ~[liquibase-core-3.5.5.jar:na] at liquibase.Liquibase.update(Liquibase.java:192) ~[liquibase-core-3.5.5.jar:na] at liquibase.Liquibase.update(Liquibase.java:188) ~[liquibase-core-3.5.5.jar:na] at liquibase.Liquibase.update(Liquibase.java:181) ~[liquibase-core-3.5.5.jar:na] at org.flowable.dmn.engine.impl.db.DmnDbSchemaManager.initSchema(DmnDbSchemaManager.java:61) ~[flowable-dmn-engine-6.4.0.jar:6.4.0] ... 97 common frames omitted 由于mysql依赖版本过高
&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.26&lt;/version&gt; &lt;/dependency&gt; 正确引用
&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; 将其将至8.0.18该问题就解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626fb418812dca16813da4b38b65e4a6/" rel="bookmark">
			elmentui&#43;vue的折叠面板默认打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 elmentui+vue 中将el-collapse折叠面板默认全部展开 这是el-collapse
&lt;el-collapse v-model="activeNames2" @change="handleChange"&gt; &lt;template v-for="(item,index) in docList"&gt; &lt;el-collapse-item :title="item.docName" :name="index"&gt; &lt;div v-html="item.content"&gt;&lt;/div&gt; &lt;div style="width:100%;"&gt; &lt;div v-for="item1 in item.attachList" style="width:100%;height:30px;"&gt; &lt;el-link type="primary" @click="getOssUrl(item1.ossName,item1.fileName)" target="_blank"&gt;{{ item1.fileName }} &lt;/el-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-collapse-item&gt; &lt;/template&gt; &lt;/el-collapse&gt; 这是写到methods
panelExpand(){ for(var i = 0; i &lt; this.docList.length; i++) { this.activeNames2.push(i) } }, 因为el-collapse中的v-model中的数，其实是个数组，我们又是写的动态的，因此不知道需要循环多少次
所以将其循环，默认打开所有折叠面板
此写法类似于
activeNames2 ：['1','2','3','4'，........] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f592dad0fa497d0becee346cd8e4f87/" rel="bookmark">
			力扣76. 最小覆盖子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
示例 1：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：
输入：s = "a", t = "a"
输出："a"
示例 3:
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
提示：
1 &lt;= s.length, t.length &lt;= 105
s 和 t 由英文字母组成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f592dad0fa497d0becee346cd8e4f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356f8fb0ae1fc6a0d1eef848f5bb035f/" rel="bookmark">
			UVM项目之二：验证计划的编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AHB_SRAMC验证计划 1.文档信息 1.1版本
版本
日期
描述
作者
V1.0
2021/8/14
从sramc_top层直接验证
Zhangshuhuai
V2.0
2021/8/24
内部模块ahb_slave_if的验证
Zhangshuhuai
1.2参考文档
名称
日期
作者
基于AHB总线的SRAM控制器设计的需求分析.doc
未知
未知
基于AHB总线的SRAM控制器架构设计.doc
未知
未知
基于AHB总线的SRAM控制微架构设计.doc
未知
未知
基于AHB总线的SRAM控制器继承需求.doc
未知
未知
2.模块设计 2.1 设计架构
2.2 功能点
1.支持8bit、16bit、32bit的SRAM数据读写操作
2.支持SRAM的单周期读写
3.支持低功耗工作（8bit/16bit）：在多块SRAM组成的存储器中，根据不同的地址，系统选择一块或者多块SRAM，未被选中的SRAM片处于low-power standby模式；
4.支持bist/dft功能
2.3 接口信号
信号名
方向
位宽
详细说明
SRAM控制器输入信号
Hclk
Input
1
AHB总线时钟信号
Sram_clk
Input
1
Sram core时钟信号
Hresetn
Input
1
AHB总线复位信号
Hsel
Input
1
Sram控制器片选信号
Hwrite
Input
1
写使能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/356f8fb0ae1fc6a0d1eef848f5bb035f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ffea37f462ce54c5c074af3f83201c/" rel="bookmark">
			数据库之删除表数据drop、truncate和delete的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库中删除表数据的关键字,最常用的可能就是delete了，另外其实还有drop和truncate两个关键字。
老大：drop 命令格式：drop table tb ---tb表示数据表的名字,下同。
说明：删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表。
老二：truncate 命令格式：drop table tb 说明：删除内容、释放空间但不删除定义，也就是数据表的结构还在。与drop不同的是,它只是清空表数据而已,它比较温柔。
至于释放空间,看下面两幅图就会明白：
上图Id标识列中，因之前delete过行数据,所以会出现标识列不连续(体现了delete删除是不释放空间的)。
上图是经过truncate table Teacher 之后又新增了三条数据，发现Id标识列插入数据的时候,标识列连续了(体现了truncate删除是释放空间)。
注意:truncate 不能删除行数据,要删就要把表清空。
老三：delete 命令格式：delete table tb 或 delete table tb where 条件
说明：删除内容不删除定义，不释放空间。其中，delete table tb 虽然也是删除整个表的数据,但是过程是痛苦的(系统一行一行地删,效率较truncate低)。
【关于truncate的总结】 1、truncate table 在功能上与不带 WHERE 子句的 delete语句相同，二者均删除表中的全部行，但 truncate 比 delete速度快，且使用的系统和事务日志资源少。
2、delete 语句每次删除一行，并在事务日志中为所删除的每行记录一项，所以可以对delete操作进行roll back。
3、truncate 在各种表上无论是大的还是小的都非常快。如果有ROLLBACK命令Delete将被撤销，而 truncate 则不会被撤销。
4、truncate 是一个DDL语言，向其他所有的DDL语言一样，它将被隐式提交，不能对 truncate 使用ROLLBACK命令。
5、truncate 将重新设置高水平线和所有的索引。在对整个表和索引进行完全浏览时，经过 truncate 操作后的表比Delete操作后的表要快得多。
6、truncate 不能触发任何Delete触发器。
7、当表被清空后表和表的索引讲重新设置成初始大小，而delete则不能。
8、不能清空父表。
原文连接：https://www.cnblogs.com/zhangwuji/p/8303353.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9797644cd4c1567ef18ecb161b2604d2/" rel="bookmark">
			UVM项目自学笔记之一：阅读design specification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IC验证流程
二、design specification
一、IC验证流程 在此次UVM项目中，笔者将使用UVM的平台架构和编码风格实现AHB—SRAMC的验证工作。
将IC验证的整个流程划分为如下阶段，并按照流程完成整个项目：
1.阅读design specification，目的：
（1）学习设计的架构：包括整个soc架构，待验的IP架构
（2）掌握设计功能：对功能的理解和把握至关重要，这影响了我们整个验证的正确性
（3）数据流向：掌握接口的数据流向，了解该使用什么样的协议
（4）如何使用该DUT：DUT该如何配置，影响了我们灌入激励和收集响应的操作
2.编写verification plan：
提取验证的功能点，明确DUT的接口信号（包括所有信号的名称、位宽、功能、时序），TB的结构，检查点，功能覆盖率，测试用例规划（testcase），验证工作结束的标准。
3.搭建验证平台：
依据计划搭建验证平台，debug，并做到通过第一个testcase
4.编写testcase：
依据验证计划编写testcase。这是我们主要的验证阶段。检查RTL的每个功能点。TB/RTL debug。
5.起regresstion
周期往复性地起regression，为随机测试案例提供不同的seed。
6.分析代码、功能覆盖率：
分析覆盖率、新增测试用例
7.写测试报告：
覆盖率报告，测试用例的结果（pass/fail），覆盖率的结果
二、design specification 这个阶段，我们要熟悉整个SOC的架构，以及待验IP的架构：
（1）SOC的整体架构如下
由总线将各个IP联系起来，片上总线是通过仲裁和译码的方式来完成不同主、从部件的互连及总线复用，比较常见的有ARM的AMBA总线、IBM的CoreConnect总线以及Silicore公司的Wishbone总线等等。
以AMBA 2.0总线为例，AMBA 2.0提供了三种不同类型的总线：AHB、ASB和APB。其中AHB支持多主机从机，采用流水线的工作方式，其上挂载着高性能、高数据吞吐的IP，包括处理器IP：CPU，负责内存与外设之间数据转移的IP：DMA控制器，存储器IP：CPU内的Cache，片内的Pflash和SRAM等，也包括扩展的存储器接口ExtSRAM，算法IP：RSA加密解密算法，以及各种高速的I/O口：SD I/O口，USB串行总线等等。APB则为系统的低速外部设备提供低功耗的简单互连，APB里面唯一的主机就是bridge，APB采用非流水线的工作方式，要两个时钟周期实现一笔读写操作。APB上挂载着System controller（含上电复位控制、中断控制、时钟振荡器、时钟锁相等），WDT（计时器看门狗）、Timer（计时器），以及各种低速外设接口例如UART异步通信串行总线，SPI同步串行总线，以及IIC；
每个IP对应着不同的地址空间，对每个IP进行寻址时，不可超出地址空间的边界。
（2）AHB_SRAMC的设计需求
1）要支持低功耗，由多块SRAM构成的存储器中，根据地址选择一块或者多块SRAM，未被选中的SRAM块处在low power standby状态
2）支持单周期读写
3）根据AHB总线的读写宽度进行相应的SRAM位宽选择，支持8bit，16bit和32bit的SRAM数据读写操作
4）能够支持DFT/BIST测试
（3）AHB_SRAMC的架构设计
整个SRAM的微结构可以统分为两个部分：接口和核心的存储单元，对应的RTL代码名称分别为ahb_slave_if.v和sram_core.v。我们在做白盒验证时，需要验证IP的内部的每个设计部分，也就是说，这两个RTL代码都需要验证。此外，RTL代码sramc_top.v是两个代码的顶层，在top层对两个模块直接进行了调用。当我们做黑盒验证时，只需要验证sramc_top.v，模拟ahb总线的行为，从顶层将信号灌入，并检测相应的输出信号即可。 其中AHB slave interface模块微结构设计如下：ahb_slave模块负责将AHB时序转化为SRAMC的时序，其架构如下：
我们可以 注意到，输入信号主要还是AHB的输入控制信号，值得说明的是sram的读写使能控制信号是由hwrite信号控制的，在ahb总线上，hwrite为高时表示读，需要将sram_o_en拉低（低有效）。而片选信号bank0_csn和bank1_csn则是通过地址的最高位判断，为0时选中bank0，为1时选中bank1，而每个bank内部的小sram通过addr的低两位进行片选，并生成了独热码，共3个有效位宽。
信号名
方向
位宽
详细说明
Ahb_slave_if模块输入信号
hclk
Input
1
AHB总线时钟信号
hresetn
Input
1
AHB总线复位信号
hsel
Input
1
Sram控制器片选信号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9797644cd4c1567ef18ecb161b2604d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b86b66e05f647890ee8fec993f4db784/" rel="bookmark">
			毫米波雷达识别问题分析及解决措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言
近年来，随着人工智能的兴起无人驾驶汽车获得了越来越多的关注，而无人驾驶车辆想要真正上路行驶，最关键的技术在于精确掌握现实中复杂的交通状况，这样一来就必须使用雷达装置。由于毫米波雷达相对于摄像头及激光雷达，其感知特性具有距离远、可靠性高、不受光线及尘埃影响等特点 [1]，特别是不会受恶劣天气的影响并且能够全天候工作，因此是无人驾驶技术的最佳选择。
毫米波雷达是利用目标对电磁波的反射来发现并测定目标位置，而充满杂波的外部环境给毫米波雷达感知带来无法避免的虚警问题。为此，本文针对 L3 级自动驾驶样车所配备的 77 GHz 长距毫米波雷达和中距毫米波雷达在感知识别中的主要问题进行了分析并提出了解决对策，为后续毫米波雷达的应用和测试提供参考。
2. 毫米波雷达识别问题解析
2.1 毫米波雷达工作原理
图 1 毫米波雷达系统整车布置示意
L3 级自动驾驶样车车身周围布置了 2 枚长距毫米波雷达和 4 枚中距毫米波雷达，可实现车身 360° 环境感知范围覆盖。毫米波雷达系统整车布置方案及探测范围如图 1 所示。
图 2 毫米雷达系统网络架构示意
毫米波雷达通过 CAN 信号与自动驾驶控制器进行交互（图 2），将其感知结果输入至下一级规划控制模块，其输出参数如表 1 和表 2 所列。
表 1 长距毫米波雷达输出参数
表 2 中距毫米波雷达输出参数
由表 1 和表 2 可知，相对其它传感器（如视觉传感器、激光雷达传感器），毫米波雷达具有速度精度较高、角分辨率相对较低等特点。由于中距雷达、长距雷达的短距模式角度覆盖范围相对更大，其角分辨率进一步下降。
2.2 毫米波雷达识别目标虚警干扰问题
2.2.1 问题描述
在长距毫米波雷达使用过程中，发现前长距雷达有大量虚警信号出现。通过观察发现：
图 3 试验场景及第 1、2 类虚警
第 1 类虚警信号通常与金属护栏信号同时出现，为一系列连续点，其回波点相对车辆的距离与护栏回波点相对车辆的距离接近，夹角相对护栏回波点偏右，特征是由远及近、从右向左穿过车辆所在点上的水平轴，在接近车辆的过程中突然消失，其与车的相对速度与道路护栏与车的相对速度一致（图 3 中虚线圆圈）；
第 2 类虚警信号通常与车辆同时出现，车辆虚警信号的目标距离与目标车辆回波点接近，方位角相对目标车辆回波点偏右，其相对速度与目标车辆一致（图 3 中实线圆圈），而后置长距毫米波雷达图像中没有出现这些虚警信号。将前、后毫米波雷达调换后重新在该路段进行了测试，发现虚警信号依然存在，预测是车辆前、后保险杠不同所导致。将前保险杠拆除后再次在该路段进行了测试，发现两种虚警信号均消失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b86b66e05f647890ee8fec993f4db784/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad5a816ffb5d165bce17fd69aa5482d/" rel="bookmark">
			java.nio.charset.MalformedInputException: Input length = 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 应用程序和nacos配置中心集成后，在windows的idea中正常，打完包，在windows系统上，通过控制台启动，报错下面的错
org.yaml.snakeyaml.error.YAMLException: java.nio.charset.MalformedInputException: Input length = 1
at org.yaml.snakeyaml.reader.StreamReader.update(StreamReader.java:218) ~[snakeyaml-1.25.jar!/:na]
at org.yaml.snakeyaml.reader.StreamReader.ensureEnoughData(StreamReader.java:176) ~[snakeyaml-1.25.jar!/:na]
at org.yaml.snakeyaml.reader.StreamReader.ensureEnoughData(StreamReader.java:171) ~[snakeyaml-1.25.jar!/:na]
at org.yaml.snakeyaml.reader.StreamReader.peek(StreamReader.java:126) ~[snakeyaml-1.25.jar!/:na]
at org.yaml.snakeyaml.scanner.ScannerImpl.scanToNextToken(ScannerImpl.java:1177) ~[snakeyaml-1.25.jar!/:na]
at org.yaml.snakeyaml.scanner.ScannerImpl.fetchMoreTokens(ScannerImpl.java:287) ~[snakeyaml-1.25.jar!/:na]
at org.yaml.snakeyaml.scanner.ScannerImpl.checkToken(ScannerImpl.java:227) ~[snakeyaml-1.25.jar!/:na]
at org.yaml.snakeyaml.parser.ParserImpl$ParseImplicitDocumentStart.produce(ParserImpl.java:195) ~[snakeyaml-1.25
然后把程序部署到linux系统上，也能正常启动。这就奇怪了，因为在windows的idea中能启动，linux中也能正常启动，而偏偏windows的控制台启动不了，这个时候想到了编码问题！
解决方法 # 指定-Dfile.encoding=UTF-8 java -jar -Dfile.encoding=UTF-8 mydemo-1.0.0.jar 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366ef63b8dbde3daecc889633fdf4200/" rel="bookmark">
			mmdetection多卡训练中报警告semaphore_tracker: There appear to be 14 leaked semaphores to clean up at shutdow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近自己写了个模型，采用mmdetection框架去训练coco数据集。由于数据集较大，单卡情况下预计需要一个月时间才能完成1x的训练。这无法容忍，于是采用多卡分布式训练。
首先，第一次由于batchsize过大，导致显存爆了。
调整batchsize后，报如下错误：
显示有信号泄露警告，起初以为只是警告忽略就可，主要关注其中的error错误，百度这个错误，网上并没有关于这个问题的解答。于是关注于警告的部分，这个警告的解决方案，可以参考相关博文：
UserWarning: semaphore_tracker: There appear to be 4 leaked semaphores to clean up at shutdown
但是并不能解决我的问题，通过请教openmmlab的大佬，得到如下回答：“你这是上一次跑出错或者暂停了，然后没清理上次的残留进程。如果不太会的话，每次跑之前killall python一下(确保没其他有用的python程序在跑）。”
我之前batchsize过大时暂停过一次，后续又暂停多吃，残留的线程太多了，最终kill掉之后，完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de52e9d86ae9bf55f869e102270f62b/" rel="bookmark">
			java Bigdecimal的加减乘除运算及保留小数位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、运算 java.math.BigDecimal。BigDecimal一共有多种够造方法，让我先来看看其中的两种用法：
第一种：BigDecimal(double val)
第二种：BigDecimal(String val) //通常采用这种方式
来看看BigDecimal的四则运算：
BigDecimal的四则运算 加法bigDecimal1.add(bigDecimal2)减法bigDecimal1.subtract(bigDecimal2)乘法bigDecimal1.multiply(bigDecimal2)除法bigDecimal1.divide(bigDecimal2) 代码：
/** * 加减乘除 */ @Test public void BigdecimalTest1(){ BigDecimal bignum1 = new BigDecimal("10"); BigDecimal bignum2 = new BigDecimal("5"); BigDecimal bignum3 = null; //加法 bignum3 = bignum1.add(bignum2); System.out.println("和 是：" + bignum3); //减法 bignum3 = bignum1.subtract(bignum2); System.out.println("差 是：" + bignum3); //乘法 bignum3 = bignum1.multiply(bignum2); System.out.println("积 是：" + bignum3); //除法 bignum3 = bignum1.divide(bignum2); System.out.println("余 是：" + bignum3); } 结果：
和 是：15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7de52e9d86ae9bf55f869e102270f62b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6da5f8fa381ef31c75149436a09579/" rel="bookmark">
			git commit提交代码时的代码校验pre-commit 如何去除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，当我用git进行代码管理的时候，执行git commit -m"样式修改"会出现如下信息：
&gt; running pre-commit hook: lint-staged ❯ Running tasks for *.js ✖ vue-cli-service lint → 2 errors and 2 warnings found. git add ❯ Running tasks for *.vue ✖ vue-cli-service lint → 31 errors found. git add 出现如此状态，真是让人头疼，接下来看看解决方式：
解：
进入 项目所在文件夹&gt;.git&gt;hooks
删除hooks目录下的内容！没错，你没有看错，是删除！
然后再重新执行git commit命令，至此大功告成
————————————————
版权声明：本文为CSDN博主「我的孤单不寂寞」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_35457469/article/details/102949831
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299a52559294e83c0b9783eeb0f517a3/" rel="bookmark">
			点云PCL学习笔记-分割segmentation-RANSAC随机采样一致性算法&amp;&amp;欧式聚类提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机采样一致性算法RANSAC 程序实例参考网址：
https://pcl.readthedocs.io/projects/tutorials/en/latest/random_sample_consensus.html?highlight=console#the-explanation
PCLAPI文档：
https://pointclouds.org/documentation/
应用主要是：
1、对点云进行分割，根据设定不同的几何模型（PCL中主要支持的模型有：空间平面、直线、二维或三维圆周、圆球、锥体），估计对应的几何模型参数，在一定允许误差范围内分割出在模型上的点云。
2、点云的配准对的剔除，见点云配准内容
简介 从样本中随即抽选一个样本子集——最小方差估计算法对这个子集计算模型参数——计算所有样本与该模型的偏差——使用一个设定好的阈值与偏差比较——偏差&lt;阈值，样本点属于模型内样本点（inliers）;偏差&gt;阈值，模型外样本点（outliers）——记录下当前inliers的个数，重复这一过程，记录当前最佳模型参数（即inliers个数最多，对应的inliers称为best_ninliers)——每次迭代后计算：期望的误差率、best_ninliers、总样本个数、当前迭代次数，——计算迭代结束评判因子，决定是否结束迭代——结束迭代，最佳模型参数为最终模型参数的估计值
问题：
1、预先设定的阈值，模型如果抽象不好设定
2、RANSAC的迭代次数未知
RANSAC优缺点 RANSAC 的一个优点是它能够对模型参数进行鲁棒估计，即，即使数据集中存在大量异常值，它也可以高度准确地估计参数。 RANSAC 的一个缺点是计算这些参数所需的时间没有上限。当计算的迭代次数有限时，获得的解可能不是最佳的，甚至可能不是很好地拟合数据的解。通过这种方式，RANSAC 提供了一种权衡；通过计算更多的迭代次数，可以增加生成合理模型的概率。 RANSAC 的另一个缺点是它需要设置特定于问题的阈值。
RANSAC 只能为特定数据集估计一个模型。对于存在两个（或更多）模型时的任何一种模型方法，RANSAC 可能无法找到任何一个。
PCL中RANSAC算法实现类 class pcl::RandomSampleConsensus
应用实例 学习如何用RandomSampleConsensus类获得点云的拟合平面模型
初始化点云 // initialize PointClouds pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);//存储源点云 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr final (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);//存储提取的局内点inliers //填充点云数据，作为处理前的原始点云 cloud-&gt;width = 5000;//设置点云数目 cloud-&gt;height = 1;//设置为无序点云 cloud-&gt;is_dense = false; cloud-&gt;points.resize (cloud-&gt;width * cloud-&gt;height); for (size_t i = 0; i &lt; cloud-&gt;points.size (); ++i) { if (pcl::console::find_argument (argc, argv, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/299a52559294e83c0b9783eeb0f517a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540f928c51eb8da6426f563d7259edb5/" rel="bookmark">
			【超详细】CentOS 7安装zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7安装zookeeper 0、顺利完成安装需要的知识储备1、系统环境2、单机安装步骤①下载并解压安装包②修改配置文件并启动单机节点 3、搭建zookeeper集群①修改配置文件②克隆虚拟机③启动集群 0、顺利完成安装需要的知识储备 1. 基础的Linux系统知识 2. 基本的Vim编辑器使用方法 1、系统环境 操作系统：Linux CentOS 7 64位 JDK版本：1.8.0_262 2、单机安装步骤 ①下载并解压安装包 官网下载zookeeper最新稳定版本
复制上图红框中的地址，选择一个路径打开终端下载压缩包。这里我选择的是在/home/&lt;username&gt;/Software目录下安装
使用如下命令解压压缩文件
$ wget https://mirrors.bfsu.edu.cn/apache/zookeeper/zookeeper-3.6.3/apache-zookeeper-3.6.3-bin.tar.gz $ tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz ②修改配置文件并启动单机节点 首先删除多余的压缩包
$ ll 总用量 12224 drwxrwxr-x 6 vm1 vm1 133 8月 24 14:38 apache-zookeeper-3.6.3-bin -rw-rw-r-- 1 vm1 vm1 12516362 4月 13 03:06 apache-zookeeper-3.6.3-bin.tar.gz $ rm apache-zookeeper-3.6.3-bin.tar.gz 接下来把zookeeper路径命改得简单一些
$ mv apache-zookeeper-3.6.3-bin zookeeper $ ll 总用量 0 drwxrwxr-x 6 vm1 vm1 133 8月 24 14:38 zookeeper 复制配置文件并启动zookeeper（这里直接改配置文件名字也可以，但是保险起见还是复制一份比较好）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/540f928c51eb8da6426f563d7259edb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8d3b9c6d9002570c8cf32386d02984/" rel="bookmark">
			selenium根据文本匹配定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜了半圈，都是扯，都用的是这种错误的。
driver.find_element_by_xpath(’//text()=“新闻”’).click()
这个不是按文本匹配的。
下面这个才是按页面文本匹配的 driver.find_element_by_link_text("新闻").click() 一个个的标题党，错了都硬抄了一大片。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68e91f7601e134cbf6b94234c0ef9ab/" rel="bookmark">
			Vuex之命名空间namespace用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在store中的用法
import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const sumInfo = { namespaced: true, actions: { jiaOdd (store, payload) { if (store.state.sum % 2) { store.commit('JIA', payload) } }, WATIEadd (store, payload) { setTimeout(() =&gt; { store.commit('JIA', payload) }, 500) } }, state: { sum: 999, school: '北京大学', subject: '软件技术' }, mutations: { JIA (state, payload) { console.log('mutations的方法被调用了。。。', state, payload) state.sum += payload }, jian (state, num) { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a68e91f7601e134cbf6b94234c0ef9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d614129420c5ec371400d467a232909/" rel="bookmark">
			Element UI关于 input禁止编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法1: 添加 readonly 属性 readonly规定输入字段为只读可复制，但是，用户可以使用Tab键切换到该字段，可选择,可以接收焦点，还可以选中或拷贝其文本。
&lt;el-form-item label="部门" prop="departmentName"&gt; &lt;el-input readonly v-model="formData.departmentName" style="width:50%" placeholder="请选择部门" @focus="hFocus" /&gt; &lt;/el-form-item&gt; 方式2: v-model变为 :value &lt;el-form-item label="部门" prop="departmentName"&gt; &lt;el-input :value="formData.departmentName" style="width:50%" placeholder="请选择部门" @focus="hFocus" /&gt; &lt;/el-form-item&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ab44774c33d9196e62baa632bbae21/" rel="bookmark">
			龙芯平台stream编译错误问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行命令：
gcc -O2 stream.c 报错如下：
Dump relocate record: stack top relocation name symbol at /tmp/ccn99HNZ.o(.text+0x90): ... 0xffffffffffffffa0 R_LARCH_SOP_POP_32_S_10_16_S2 `&lt;nameless&gt;' at /tmp/ccn99HNZ.o(.text+0x94): 0x0000000080007414 R_LARCH_SOP_PUSH_PCREL `.LC1' + 2048(0x800) 0x0000000000001194 R_LARCH_SOP_PUSH_ABSOLUTE `&lt;nameless&gt;' + 12(0xc) 0x000000000000000c R_LARCH_SOP_SR `&lt;nameless&gt;' 0x0000000000000001 R_LARCH_SOP_POP_32_S_5_20 `&lt;nameless&gt;' at /tmp/ccn99HNZ.o(.text+0x98): 0x00000000000073e4 R_LARCH_SOP_PUSH_PCREL `.LC1' + 4(0x4) 0x0000000000000994 R_LARCH_SOP_PUSH_PCREL `.LC1' + 2052(0x804) 0x0000000000001194 R_LARCH_SOP_PUSH_ABSOLUTE `&lt;nameless&gt;' + 12(0xc) 0x000000000000000c R_LARCH_SOP_SR `&lt;nameless&gt;' 0x0000000000000001 R_LARCH_SOP_PUSH_ABSOLUTE `&lt;nameless&gt;' + 12(0xc) 0x000000000000000c R_LARCH_SOP_SL `&lt;nameless&gt;' 0x0000000000001000 R_LARCH_SOP_SUB `&lt;nameless&gt;' 0xfffffffffffff994 R_LARCH_SOP_POP_32_S_10_12 `&lt;nameless&gt;' at /tmp/ccn99HNZ.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ab44774c33d9196e62baa632bbae21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbb0521cf4feaaa5ebcfc827558e9a5/" rel="bookmark">
			HIVE设置连接用户名和密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive设置连接用户名和密码，操作相关步骤如下：
Hive-site.xml,缺省为NONE。此处改为CUSTOM
&lt;property&gt; &lt;name&gt;hive.server2.authentication&lt;/name&gt; &lt;value&gt;CUSTOM&lt;/value&gt; &lt;description&gt; Expects one of [nosasl, none, ldap, kerberos, pam, custom]. Client authentication types. NONE: no authentication check LDAP: LDAP/AD based authentication KERBEROS: Kerberos/GSSAPI authentication CUSTOM: Custom authentication provider (Use with property hive.server2.custom.authentication.class) PAM: Pluggable authentication module NOSASL: Raw transport &lt;/description&gt; &lt;/property&gt; 配置自定义验证类 hive-site.xml
&lt;property&gt; &lt;name&gt;hive.server2.custom.authentication.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hive.contrib.auth.CustomPasswdAuthenticator&lt;/value&gt; &lt;/property&gt; 自定义验证类代码：
package org.apache.hadoop.hive.contrib.auth; import javax.security.sasl.AuthenticationException; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.hive.conf.HiveConf; import org.slf4j.Logger; public class CustomPasswdAuthenticator implements org.apache.hive.service.auth.PasswdAuthenticationProvider{ private Logger LOG = org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbb0521cf4feaaa5ebcfc827558e9a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543a60622254060da18a9afa968b3be2/" rel="bookmark">
			5G UPF与MEC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主题：5G UPF与MEC
简介：介绍了UPF在不同场景下的配置方案以及UPF的功能
参考：
TS23.501 5.8
5G核心网规划与应用
5G UPF分流技术和部署方式（CM Labs）
5G MEC分流方案
5G UPF用户面功能
5G Tutorial
作者：ybb
时间：2021年8月22日
一、5G核心网规划与应用（5.5.6） 1.UPF配置方案 UPF主要负责数据包的路由和转发、数据包的检测、用户面策略的实施、Qos的执行等。
UPF的能力指标包括同时处理的吞吐量和流数量；
2.UPF网络组织 5G UPF需要满足eMBB、URLLC以及大带宽的MEC场景，需要具备灵活的网络部署机制。
（1）eMBB场景：核心UPF。
针对移动用户，UPF的设置还需要考虑4G/5G的互操作和融合组网的需求，即UPF与PGW-U融合设置，5G的语音业务由IMS解决，而IMS的接入设备SBC/P-CSCF通常会设置在省会城市，为了将语音业务接入IMS，UPF也需要同SBC/P-CSCF一样相对集中的设置在省会城市。
（2）针对MEC场景，考虑到MEC的低时延、大带宽需求，UPF需要就近接入MEC，一般UPF需要与MEC紧密关联部署在一起，此类UPF称为边缘UPF，UPF需要像MEC一样部署在网络的边缘。
eMBB场景和MEC场景下UPF组网方式对比如下图
5G网络支持上行链路分类器和分支点功能，允许用户的业务刘静多个UPF，即为不同的业务设置不同的锚点UPF。
对于边缘计算的业务直接由边缘UPF到DN;
对于用户的语音业务，可由边缘UPF到核心UPF，再由核心UPF到IMS网络。
5G 不同场景下UPF的流量示意图如下图所示
注：5G为什么需要MEC
在工业园区的网络还存在数据安全，以及内网访问的需求，MEC可以作为运营商和企业内网之间的桥梁，实现内网数据不出园区，本地流量本地消化。
MEC和UPF联合起来可以进行灵活的数据分流，内网数据直接走内网通道，私密数据不出园区；外网数据也可直通互联网
二、5G核心网规划与应用（6.2） 6.2UPF功能 UPF是处理PDU会话的用户平面路径的网元，支持UE业务数据的转发、通过N4接口受SMF的控制和管理、依据SMF下发的各种策略执行业务面业务流的处理。
主要诸恶的功能如下：
RAT内/间移动性锚点
响应SMF为UE分配IP地址
PDU会话和数据网络的连接点
数据包路由和转发
数据包家名册
合法拦截
用户面策略执行
QoS处理
6.2.1用户面功能 1.移动性管理
UPF能辅助AMF、SMF完成以下移动性管理流程：
基于Xn接口的切换；
基于N2接口的切换；
5GC和EPS之间的切换；
2.IP地址分配
UE IP地址管理包括UE IP地址的分配和释放以及IP地址分配之后的更新。UPF由SMF控制没在PDU会话建立过程中为UE分配IP地址，支持IPv4、IPv6
11.数据包转发及路由
UPF具有把来自外部数据网的PDU用GTP包头和UDP/IP包头进行封装的功能，并以包头的相关地址信息作为标识。利用一条点到点的双向隧道来传输封装数据给终端，对于去往外部数据网的GTP-U PDU，应该去除其封装包头后在转发给外部数据网。
UPF应支持静态路由、策略路由、备份路由。备份路由之间可以进行负荷分担。
UPF应支持OSPF、BGP等开放的标准路由协议。
UPF应支持路由映像定义、路由引入、分发定义，以及路由的前缀、自治系统路径、团体属性、访问列表等限制规则。
12.用户面数据转发
SMF向UPF提供FAR，从而根据PDR流量检测信息控制用户面数据包转发。
FAR中包括转发操作信息和转发目标信息，因此UPF应具备下列功能：
N3/N9隧道相关处理，例如封装;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/543a60622254060da18a9afa968b3be2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0acf74f93f808cfdc3931af62210e4/" rel="bookmark">
			运行echarts的官方示例显示为空白的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 原因总结详细说明问题一（与原因对应）问题二问题三： 效果显示相关资源吐槽 原因总结 echarts路径错误没有相关的json数据没有引入jQuery 详细说明 举个例子，我在Echarts的官方示例中找到了它
网址：https://echarts.apache.org/examples/zh/editor.html?c=custom-gantt-flight
点击右上角的下载示例，将下载好的文件放入pycharm中（只要是编译器就可以，但不能直接点开，因为数据文件需要渲染）
问题一（与原因对应） 先看这一行代码
&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"&gt;&lt;/script&gt; echarts.min.js的路径需要更改，我们先把echarts.min.js放入当前文件夹下，然后修改路径
&lt;script type="text/javascript" src="echarts.min.js"&gt;&lt;/script&gt; 问题二 $.get(ROOT_PATH + '/data/asset/data/airport-schedule.json', function (rawData) 首先我们要拿到这个json的数据文件，怎么拿呢？
进入刚才的链接，F12找到network
刷新一下，找到我们所需的文件
双击：
这就是我们所需的json数据，我是创建个txt，将内容复制进去，再将后缀名改为json（感觉笨了，大家有什么更简单的方法可以发在评论区）
同时修改代码：
$.get('airport-schedule.json', function (rawData) 问题三： $.get('airport-schedule.json', function (rawData) 改完后的代码其实还有问题，我们可以试运行一下，F12查看一下：
这说明目前无法识别‘$’这个符号
其实这是jQuery的符号，如果不引入jQuery自然就无法成功显示
相关方法详见这篇文章：关于$ is not defined的原因和解决办法（看文章里的情况1即可）
将下载后的文件放入同一文件夹
最后引入jQuery即可：
&lt;script type="text/javascript" src="jquery-3.6.0.min.js"&gt;&lt;/script&gt; 效果显示 在解决掉上面三个问题后，我们再尝试运行一下，点击右上角的浏览器：
成功了，好耶！
相关资源 我已经将图中的四个文件压缩后上传了，大家点击下面的链接就可以下载到原文件了！
Ecahrts的官方示例（航班甘特图，可拖拽）
吐槽 网上真的没有详细的讲解，从官网下完示例后运行不出来真的很着急，好在最后还是搞定了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1032b96973b41bf52223a4e0463a5319/" rel="bookmark">
			Python 爬虫进阶必备 | 某音乐网站查询参数加密逻辑分析（分离式 webpack 的加密代码扣取详解）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“咸鱼学Python”，选择“加为星标”
第一时间关注Python技术干货！
今日网站 aHR0cDovL3d3dy5rdXdvLmNuL3NlYXJjaC9saXN0P2tleT0lRTQlQjglOEIlRTUlQjElQjE=
首先声明，本网站的这个参数不是必要的参数，通过 postman 测试不带参数也可以返回数据，那么这篇文章讲什么？
之前分析了一篇 webpack 加密的网站，讲了大概一个使用了 webpack 的网站他的参数应该如何扣取。
本篇是他的续篇，主要讲述当模块分发器不在同一个文件的 webpack 应该如何扣取
Python 爬虫进阶必备 | 某游戏网站密码加密逻辑分析（webpack 的 js 加密代码怎么扣 -思路分析）
加密参数定位 首先看下我们需要的分析的参数是什么
这里的 reqId 就是需要分析的参数，这个参数看着是不是特别像 uuid
直接检索参数名可以找到下面这个文件
在文件里再次检索可以定位到下面几个位置
这里的reqId的值分别等于r和n，但是这里的r和n的逻辑都指向下面这个逻辑c()()
所以我们需要断点一下看下reqId是否就是在这里生成的，如果是这里再看看c的具体逻辑
这里打上断点刷新可以看到，确实断点的位置在上面标记的两个位置中，并且参数也是c()()生成的
加密参数分析 经过上面的定位已经可以知道参数是由c()()生成的，那么c的逻辑分析出来就完成了。
往上翻下代码可以看到下面的逻辑
l = n(109) c = n.n(l) reqId = c()() 所以这里的关键参数就是l，l是n(109)生成的，这里的n就是我们今天的重点webpack整出来的。
按照前一篇的介绍，要看下模块分发器的位置把他扣取出来，然后把加密逻辑用到的模块都塞到分发器里调用就可以了。
但是在开始的位置没有看到分发器
所以现在要在l的位置单步到分发器的位置，原来在另一个文件中
这里就是分发器的位置了，这里的e存的就是全部的模块
代码运行到函数 d 的时候会把所有方法都塞到这个列表里，然后就可以用n(xxx)调用了，我们要做的就是和这里一样把reqId的逻辑组成一个这样的函数，我们直接调用d(xxx)这样的代码就可以直接生成 reqId
现在就是把分发器还有reqId用到的模块都扣出来然后组装到一起。
代码扣取 先扣模块的分发器，把除了d之外的全删了
因为d里面用到了t，所以在d前面补一个var t={}
这个时候剩下的代码应该是下面这样的
接下来就是找l用到的代码了
可以看到l用到的是n(109)，所以我们需要找到109对应的代码
“ 注意：这里最好是在模块分发器里找 109 对应的代码像下图这样，如果将断点打在 l 的位置单步进去可能会出现偏差
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1032b96973b41bf52223a4e0463a5319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b806e2f4939a31a3eb12b4dec629e8/" rel="bookmark">
			咸鱼学 Python  技术交流群又双叒满了！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是鱼哥
如题，就是我发这篇文章的原因
不知道是那个大佬推荐了我的公众号，突然很多读者想入群一块交流
所以开一个技术交流 4 群，提供一个平台给大家交流
不过在公布加入方式之前有几点需要大家知道
入群必看 1、谢绝广告党，拼夕夕砍一刀等 别打广告了，想想多少群给你们这样搞没的
2、不开车，绿色交流，开着开着群里人就走光了 3、敢于交流，善用百度 进群交流，重要的是进群吗？不是！！
是交流啊！！！
进群不说话？那我怀疑你是来偷我表情包的
还有问问题之前看看下面这段公式
问题描述应该包含问题主体陈述 + 包含行号的代码截图 + 报错截图 + 这个问题你尝试了哪些操作
别光问，发报错截图啊，没图说个 xx
4、再看一遍上面的 3 点内容，谢谢~ 群服务有那些？ 1、快乐就完事了（男孩子的快乐就这么简单） 虽然说是技术交流群，不过吹水，摸鱼，水友赛当然必不可少了
2、Python 爬虫技术讨论 这个更多的是大家对遇到的一些问题，拎出来一块讨论
群里经常有大佬直接甩代码，对于这种行为我是抱谴责态度的，主要是甩的太多一下看不完 ，这里点名批评一下
@南山大佬@翻身大佬@花哥@哲哥
。。。
3、爬虫招聘资源共享 我经常逛交流群看到有爬虫招聘就会随手甩到群里或者直接把招聘的老哥安排进来，快速高效
以上就是我要说的大部分内容了
如何加群？ 1、扫下面的二维码，备注【咸鱼666】，不备注不通过
2、已经有我好友的私聊我就行，已经在交流群的老哥就不要加了，哪个群服务都一样，都可以碰到有趣的灵魂
以上~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e745bc75da9db8f186e6d58fa87f10d6/" rel="bookmark">
			ubuntu清理空间技巧 包含【系统日志、缓存、无用包、内核、VScode、conda、snap、pip】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过在ubuntu18.04中打开左下角9个点的显示应用程序-&gt;工具-&gt;Disk usage Analyzer查看空间大小，或者终端输入下面指令查看：
baobab 或者通过
du -sh * 命令查看文件夹下的软件占用内存
方法一 在/var/log/journal/垃圾日志文件，可以看到他的内存占用是比较大的，那么我们可以通过如下命令来清除这些日志文件
journalctl --disk-usage # 检查日志大小 sudo journalctl --vacuum-time=1w # 只保留一周的日志 sudo journalctl --vacuum-size=500M # 只保留500MB的日志 rm -rf /var/log/journal/askd342fh35aewfhagf67iuro1（垃圾文件） # 直接删除/var/log/journal/目录下的日志文件 du -sh ~/.cache/thumbnails # 检查缩略图缓存的大小 rm -rf ~/.cache/thumbnails/* # 清除缩略图缓存 方法二 如果是虚拟机的话，可以删除.cache/vmware/drag_and_drop/路径下缓存区数据，因为通过vmware安装的虚拟机时会安装vmware tools,其中为了方便拷贝数据，会在ubuntu系统.cache/vmware/drag_and_drop/路径下创建一些缓存目录，从windows中拷贝过来会先存储在这里，粘贴完了我们自然可以把他删除。
方法三 下三个命令主要清理升级缓存以及无用包
sudo apt-get autoclean # 删除旧版本软件缓存 sudo apt-get clean # 删除系统内所有软件缓存 sudo apt-get autoremove # 删除系统不再使用的孤立软件 方法四 如果电脑装有VScode可以删除VScode中ipch文件（可以在磁盘分析器baobab中查看下面路径内容）
/home/用户名/.cache/vscode-cpptools/ipch Cache：在计算机存储系统的层次结构中，介于中央处理器和主存之间的高速小容量存储器。它和主存储器一起构成一级的存储器。高速缓存存储器和主存存储器之间信息的调度和传送是由硬件自动进行的。
Ipch：这些文件是Visual Studio用来保存预编译版的头文件和Intellisense用的。如果删除后，重新加载项目会重建这些文件，但VSCode中设定范围后就不会产生超过这个数的缓存大小。
ipch文件内包含缓存的预编译头文件（PCH），vscode使用的时间越长，那么这个文件夹内的缓存就越多，最终会造成较大的内存占用。当我们不用来运行很大的文件时，只是利用它来敲代码，用不到预编译头文件时可以关闭这个功能。
操作
在VSCode菜单栏中 文件-&gt;首选项-&gt;设置（ctrl+，），然后搜索C_Cpp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e745bc75da9db8f186e6d58fa87f10d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582dd13138b17e4947192781c1608152/" rel="bookmark">
			Hive错误--＞由于lateral view explode() 导致的空指针错误 FAILED: NullPointerException null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误:
代码:
select videoId,category from gulivideo_orc where videoId in ( select relatedId_name from ( select relatedId, `views` from gulivideo_orc order by `views` desc limit 50 ) t1--找到top50 lateral view explode(relatedId) tmp as relatedId_name ) t2 --找出top50对应的相关视频Id 原因:经过多种测试发现是因为lateral view explode() 函数导致的,
解决方法:通过子查询再进行一次封装即可
select videoId,category from gulivideo_orc where videoId in ( select * from ( select relatedId_name from ( select relatedId, `views` from gulivideo_orc order by `views` desc limit 50 ) t1--找到top50 lateral view explode(relatedId) tmp as relatedId_name ) t2 --找出top50对应的相关视频Id ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ebcb07312ad1191a52f8bdcb315179/" rel="bookmark">
			ArrayList和LinkedList有哪些区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个区别：
首先查看一下ArrayList和LinkedList部分源码：
ArrayList： LinkedList：
可以看出它们都实现了list接口但是LinkedList多实现了一个Deque接口，那么LinkedList多了一个双端队列的特性，可以从前面插入数据（addFirst）也可以从末尾插入数据（addLast）
第二个区别：
ArrayList：
LinkedList：
可以看到ArrayList底层是使用数组进行实现的，LinkedLis底层是通过链表的方式进行实现，
当数组在指定位置添加一个元素的时候，需要将后面的元素下标进行更改，效率比较低。而LinkedList只需要找到指定元素，更改一下指针指向的地址位置就可以进行添加。
那么可以得到如下区别：
ArrayList比LinkedList在随机访问的时候效率要高，因为LinkedList是线性的数据存储方式，需要移动指针从前往后依次查找。
在非首尾的增加和删除操作，LinkedList要比ArrayList效率要高，因为ArrayList增删操作要影响数组内其他数据的下标。
综合来说，在需要频繁读取集合中的元素时候，更推荐使用ArrayList，而在插入和删除操作较多的时候，更推荐使用LinkedList
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80dd5efc6456e955b64f5b4479522d8/" rel="bookmark">
			简单了解String，StringBuffer，StringBuilder的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于这段程序来说并没有真正修改aaa这个字符串常量，而是创建了一个新的字符串常量bbb
而StringBuffer和StringBuilder是可以改变的，修改时他不会创建一个新的对象。
那么StringBuilder和StringBuffer什么区别呢？
我们从他的源码进行分析，拿他们的append方法为例：
StringBuider：
StringBuffer：
可以看出StringBuffer比StringBuilder多了一个synchronized的修饰符，增加了锁的机制，所以StringBuffer是线程安全的
总结：
1.String是不可变的，如果要尝试修改，它会生成一个新的字符串对象，StringBuffer和StringBuilder是可变的。
2.StringBuffer是线程安全的，StringBuilder是线程不安全的，在单线程情况下StringBuilder效率更高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a886f0766439059d86e80b213e250f5e/" rel="bookmark">
			new一个String对象到底进行了那些步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		new一个String对象到底进行了那些步骤？
new String("abc")可以理解为创建了两个对象，第一个对象是字符串常量"abc"对象，它放在字符串常量池中，第二个对象是new String（"abc"），它放在堆中。
对于s2，这种方式会首先从字符串常量池中检查是否有"abc"这个字符串
对于s3,使用intern方法，首先会从字符串常量池中检查是否存在"abc",如果存在则返回字符串引用，如果不存在，则把"abc"添加到字符串常量池中，并返回该字符串的引用。
执行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea17848205c0d037a595026ffb38950/" rel="bookmark">
			JAVA如何不改变字符串变量地址来修改变量内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
问题解决：使用反射的方式
代码解释：
getClass（）方法作用： 获取一个(类)Class，进而通过返回的Class对象获取s的相关信息，比如：获取s的方法，属性有哪些等等信息。
getDeclaredField（）：获取S的value字段，至于为什么是Value，查看一下String的源码，按住ctrl鼠标点击String，可以看到
value才是我们需要改变的内容，而在String中value是私有的并且是一个字符数组
这也是更改值为"bbb"的时候为什么要先SetAccessible然后再toCharArray一下
代码运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50db8434e5100a22b876288496a9e496/" rel="bookmark">
			【大数据开发】供应链之CRM、OMS、WMS、SRM、SCM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在市场上常常会出现CRM、OMS、WMS、SCM等产品概念，实际显示的是供应链不同阶段的反应。
CRM、OMS、WMS、SRM、SCM分别面向客户销售、订单、库存、采购、供应链几个不同个环节，严格意义上来说一套完整的业务流程都需要用到的，但是一些企业的业务流程不需要进销存的全部功能，接下来就简单的来介绍各系统的特点。
(1)CRM系统
CRM是客户关系管理系统，主要记录从客户的录入到商机跟进的过程，以生成订单作为节点，一般情况只要销售人员使用，主要模块有：客户维护、商机进度、绩效管理等业务模块。
CRM只反映销售从客户意向到签订订单的过程，不涉及存储、出入库业务。
1575267543666_CRM.jpg
(2)OMS介绍
OMS是订单管理系统，以订单管理为核心工作，为企业提供订单从开始销售到完成交易全生命周期的监控和管理。OMS系统可能记录的订单信息有：产品详细信息(描述性信息、属性、型号、在仓库中的位置等)、库存情况(库存中、采购途中等等)、需交货的日期、价格和折扣情况等等。OMS系统包含的主要功能是有：订单接收、订单拆分与合并、合约管理、商品目录管理、库存查询等。
OMS主要面对的业务环节是企业销售与客户之间的订单关系管理，其中客户的类型可以是个人客户也可以是企业客户。在主体信息方面会以订单为核心。
(3)WMS介绍
WMS是库存管理系统，它将企业仓储的货品信息进行详细的记录和管理。WMS系统通常记录的信息有：产品详细信息、入库时间、入库批次及编号、商品分类、所在仓库中的位置、库存量等等。WMS包含的核心功能有：出/入库管理、退货管理、发货管理、库存调整、仓库调拨等等。
WMS主要面对的业务环节是库存商品存储和调配的关系管理，以库存商品为核心。其中是出库和入库缓解可能是与订单管理系统和供应链管理系统有一些交集，但WMS更加强调对库存商品的全生命周期的管理。
(4)SRM系统
SRM是供应商管理系统，主要面向从采购洽谈到采购订单签订的过程，一般有采购人员管理，主要功能模块：供应商维护、采购意向、采购订单、入库申请等。
SRM常常与CRM向对应，只体现从意向到订单的业务，不体现实际仓储、出入库业务。
(5)SCM介绍
SCM系统是供应链管理系统，是通过将供应链信息化的手段，将企业供应链资源信息进行详尽的记录和管理，最终尽可能实现企业的整个采购流程的可控性。SCM系统通常记录的信息有：采购单商品列表、供应商详情、发货日期、物流信息等等。SCM包含的功能有：采购订单管理、采购退货管理、采购换货管理等等。
SCM系统面向的业务环节是，供应商与企业的关系管理，以采购单或供应商为核心。一些SCM还可以对物流信息进行跟踪，随时查看采购单的物流目前的状态和位置信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86bf562873f268aec1a6f183e3b480f/" rel="bookmark">
			出现 “java”不是内部或外部命令，也不是可运行程序或批处理文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析原因如下： 第一是Java配置：是否下载jdk,jre即Java的开发工具和运行环境。 一般下载jdk时是自动携带下载jre的；位置在Program Files里面 如果一切下载安装没问题，那就是环境变量配置问题 第二种：选择属性打开，选择高级系统设置 环境变量配置 1.新建系统变量JAVA_HOME
变量名：JAVA_HOME
变量值：C:\Program Files\Java\jdk1.8.0_131 (默认安装的JDK根目录) 注意变量值，按你的电脑路径配置。
2.修改系统变量Path Path的变量值就是JDK的bin目录: C:\Program Files\Java\jdk1.8.0_131\bin 有就选择编辑；
3.新建系统变量CLASS_PATH 变量名：CLASS_PATH
变量值：C:\Program Files\Java\jdk1.8.0_291\lib; (是JDK安装的lib目录) 配置完3个环境变量,点击确定即可,如下: 总结：我报错的原因是真的没有单独的新建一个CLASS_PATH和指定lib目录路径 后来我才明白之前那些根本算不上配置，是我太自以为是了。总觉得自己以前配置过的，没什么大毛病，一看不知道，仔细看了吓一跳。老是报错的我还是静下了心来发现问题。最终解决了
最后，查看是否完成JDK配置 1.Win图标+R,出现运行窗口
2.打开的输入栏里面输入命令：cmd 3，按回车即可进入系统命令行。
检验命令：java -version
javac
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e315f85aba4c9aa302eaa3a9f8cccbae/" rel="bookmark">
			归一化和标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归一化和标准化 归一化和标准化归一化标准化Batch Normalization原理步骤训练与测试时的区别优点缺点注意BN与Dropout影响 各种标准化区别 归一化和标准化 最小最大归一化（减最小值，除最大最小的差值）和均值方差归一化（减均值，除方差）
作用
1）统一量纲，加快模型收敛速度，（不做归一化，梯度下降时，各数据对模型的贡献不一致，导致模型不稳定，收敛性不好，错过最优解）
2）提高模型精度
归一化 一般用于线性模型
适用范围：对输出结果范围有要求的，数据较为稳定，不存在极端的最大最小值
缺点：当有新数据加入时，可能导致max和min的变化，需要重新定义。
另外，最大值与最小值非常容易受异常点影响，所以这种方法鲁棒性较差，只适合传统精确小数据场景
标准化 存在异常值和较多噪音，用标准化。
Batch Normalization 原理 参数根据梯度下降在不断变化，每经过一个网络层数据的分布都会发生不同的改变。我们将这种由于网络参数更新造成的数据分布变化称为Internal Covariate Shift。Internal Covariate Shift会导致输入数据分布向某一个方向偏移，从而造成网络数据训练缓慢。以sigmoid为例，sigmoid函数的导数在输入为0时变化大，梯度下降最快，假如分布偏移到6以上，则大部分数据落入饱和区，梯度下降会非常缓慢。解决在训练中，中间层数据分布发生改变的情况，于是就有了Batch Normalization
步骤 1）计算均值和方差；2）进行标准化；3）进行scale和shift
需要学习参数γ,β：找到一个线性和非线性的平衡点，既能享受非线性较强的表达能力，有可以避免非线性饱和导致网络收敛变慢问题。如果不加，分布一直都是正太分布，学不到东西。
描述过程就是：在batch上进行标准化，即将batch上的所有图片的通道R作为1组，进行标准化；将batch上的所有图片的通道G作为1组，进行标准化
训练与测试时的区别 训练时均值和方差为计算所得，γ,β进行学习
测试时，γ,β为学习到的，均值方差为训练过程中的平均值，或者指数加权移动平均值，pytorch默认用的指数加权移动平均
优点 1）对模型初始化和超参不敏感，减少超参数调整，允许使用更大的学习率。
2）可以加快模型收敛速度
因为神经网络本质上是学习数据的分布情况，而mini-batch每次都会有不同的分布，也就是说，每次训练的数据都有不同的分布，数据抖动很大，所以权重变化也会很大。而batch norm会将数据归一化，减少不同batch间数据的抖动情况，从而提高训练速度
3）提高模型泛化能力，抑制模型过拟合，起到正则化的作用，类似dropout的功能。
dropout在训练阶段引入随机性，防止过度匹配；在测试阶段去除掉这种随机性， 从而获得确定而准确的结果。BN也是一样，训练阶段的随机性为随机batch的方差均值，在测试阶段通过求期望等方式在全局去除掉这种随机性获得准确的结果。
与L1、L2正则化方法概念有区别
4）避免深层网络的梯度消失或爆炸问题
BN通过固定网络层输入的均值和方差，即使网络较深层的响应或梯度过小或过大时，也可通过BN的规范化作用将其缩放到一个比较合理的取值范围，从而避免梯度消失或爆炸问题
5）允许网络使用饱和性激活函数(例如sigmoid，tanh等)，缓解梯度消失问题
缺点 1）不适合小batch；
2）有可能训练的结果跟测试的不一样
3）对于在线学习可能有影响，因为在线学习改变数据分布太大
4）不是适合所有任务，盲目使用可能效果并不好
注意 使用BN的过程中，作者发现Sigmoid激活函数比Relu效果要好
对于sigmoid函数而言，拉回到非饱和区域。
对于relu函数而言，gamma作用不大，beta很重要，否则0均值1方差会导致一半的数值在负半轴失活
BN与Dropout影响 BN或Dropout单独使用能加速训练速度并且避免过拟合，但是倘若一起使用，会产生负面效果。BN在某些情况下会削弱Dropout的效果
BN与Dropout最好不要一起用，若一定要一起用，有2方法：
1 在所有BN层后使用Dropout
2 修改Dropout公式（如使用高斯Dropout）使得它对方差不是那么敏感
总体思路是降低方差偏移
Dropout 与BN之间冲突的关键是网络状态切换过程中存在神经方差的（neural variance）不一致行为。
各种标准化区别 各种标准化区别
标准化层，目前主要有这几个方法
1）Batch Normalization（2015年）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e315f85aba4c9aa302eaa3a9f8cccbae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb53db99df3b7f7524d9d8090ad583f1/" rel="bookmark">
			Java网络编程模型之阻塞与非阻塞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.阻塞I/O模型 阻塞IO模型是常见的IO模型，在读写数据时客户端会发生阻塞。阻塞IO模型的工作流程为：
1.1在用户线程发出IO请求之后，内核会检查数据是否就绪，此时用户线程一直阻塞等待内存数据就绪；
1.2在内存数据就绪后，内核将数据复制到用户线程中，并返回I/O执行结果到用户线程，此时用户线程将解除阻塞状态并开始处理数据。
典型的阻塞I/O模型的例子为data= socket.read（），如果内核数据没有就绪， Socket线程就会一直阻塞在 reado中等待内核数据就绪。
2.非阻塞I/O模型 非阻塞I/O模型指用户线程在发起一个操作后，无须阻塞便可以马上得到内核返回的一个结果。如果内核返回的结果为fase，则表示内核数据还没准备好，需要稍后再发起I/O操作。一旦内核中的数据准备好了，并且再次收到用户线程的请求，内核就会立刻将数据复制到用户线程中并将复制的结果通知用户线程。
在非阻塞IO模型中，用户线程需要不断询问内核数据是否就绪，在内存数据还未就绪时，用户线程可以处理其他任务，在内核数据就绪后可立即获取数据并执行相应的操作。典型的非阻塞IO模型一般如下：
import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class Test7 { public static void main(String[] args) throws IOException { ServerSocket socket=new ServerSocket(); while(true){ Socket data=socket.accept(); if (data!=null) { //数据处理完毕 break;} else { //内核数据未处理完成，进行其他线程业务 } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27b0c8f7cd62dad93b6e6a0c9a22661/" rel="bookmark">
			二维 Arnold 的图像置乱加密及解密——Matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维 Arnold 的图像置乱加密及解密——Matlab实现
二维 Arnold 的图像置乱加密及解密（1）：RGB图像的处理
基于Arnol变换的图像置乱
Arnold变换是俄国数学家Vladimir I. Arnold提出的一种变换,一幅N ×N的数字图像的二维Arnold
变换定义为:
注意：x,y是原图像的像素坐标，x',y'是变换后的像素坐标。保证｜ad-bc｜＝1，如置换矩阵系数设为a＝b＝1,c＝2，d=3，置换次数n=20，则他们被当作密钥key，用于解密。Arnol变换的图像类型只能是N*N的图片。
RGB图像的二维 Arnold 的图像置乱加密及解密
（1）编写一个arnold.m文件与iarnold.m文件（见上一篇日志《二维 Arnold 的图像置乱加密及解密——Matlab实现(1)》）
（2）图像处理程序
图像加密置乱：
a=imread('flower.jpg'); %取预处理图像
R=a(:,:,1); %取图像的R层像素
G=a(:,:,2); %取图像的G层像素
B=a(:,:,3); %取图像的B层像素
subplot(2,2,1);imshow(a);title('original');
subplot(2,2,2);imshow(R);title('R');
subplot(2,2,3);imshow(G);title('G');
subplot(2,2,4);imshow(B);title('B');
keyR=[5,5,2,7,3];keyG=[3,1,1,2,1];keyB=[6,3,2,4,3]; %分别为RGB三层设计三个不同密钥
aR=arnold(R,keyR);aG=arnold(G,keyG);aB=arnold(B,keyB);%对各层用不同的密钥加密
figure;subplot(2,2,1);imshow(aR);title('aR')；%加密后的图像
subplot(2,2,2);imshow(aG);title('aG');
subplot(2,2,3);imshow(aB);title('aB');
aa=cat(3,aR,aG,aB); %各层加密后在合成彩色图像
subplot(2,2,4); imshow(aa); title(' Permuted');%RGB图像加密后的结果
imwrite(aa,'aflower.bmp'); 图像解密还原：
b=imread('aflower.bmp'); %取加密后的图像
aR1=b(:,:,1); %取图像R层的像素
aG1=b(:,:,2); %取图像R层的像素
aB1=b(:,:,3); %取图像R层的像素
subplot(2,2,1);imshow(b);title('original');
keyR=[5,5,2,7,3];keyG=[3,1,1,2,1];keyB=[6,3,2,4,3];%由加密方提共的密钥
iaR=iarnold(aR1,keyR);iaG=iarnold(aG1,keyG);iaB=iarnold(aB1,keyB);%对各层进行解密
subplot(2,2,2);imshow(iaR);title('iaR');
subplot(2,2,3);imshow(iaG);title('iaG');
subplot(2,2,4);imshow(iaB);title('iaB');
c=cat(3,iaR,iaG,iaB); %将RGB三层合成彩色图像
figure; imshow(c); title(' Decrypted'); %最后还原的图像
imwrite(c,'jiemi.bmp');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27b0c8f7cd62dad93b6e6a0c9a22661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b68e7cfe113efec78db5e94f55e6f2f/" rel="bookmark">
			雷神Spring实验10～14笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记参考雷神上课的印象笔记和源码
实验10：创建带有生命周期方法的bean 实验11：测试bean的后置处理器 实验12：引用外部属性文件★（spring管理连接池）； 实验13：基于XML的自动装配（自定义类型自动赋值） javaBean（基本类型） （自定义类型的属性是一个对象，这个对象在容器中可能存在） 实验14：[SpEL测试I] 在SpEL中使用字面量、 引用其他bean、 引用其他bean的某个属性值、 调用非静态方法 调用静态方法、 使用运算符 实验10：创建带有生命周期方法的bean
&lt;!-- 实验10：创建带有生命周期方法的bean 生命周期：bean的创建到销毁； ioc容器中注册的bean； 1）、单例bean，容器启动的时候就会创建好，容器关闭也会销毁创建的bean 2）、多实例bean，获取的时候才创建； 我们可以为bean自定义一些生命周期方法；spring在创建或者销毁的时候就会调用指定的方法； 自定义初始化方法和销毁方法 init-method和destroy-method ：The method must have no arguments,but may throw any exception ConfigurableApplicationContext有close()方法	单例bean的生命周期 （容器启动）构造器-初始化方法-（容器关闭）销毁方法 多实例bean的生命周期 获取bean（构造器）-初始化方法- 容器关闭 不会调用bean的销毁方法 --&gt; &lt;bean id="book01" class="com.atguigu.bean.Book" destroy-method="myDestory" init-method="myInit" &gt;&lt;/bean&gt; 实验11：测试bean的后置处理器
&lt;!--实验11：测试bean的后置处理器:BeanPostProcessor Spring有一个接口：后置处理器：作用是可以在bean的初始化前后调用方法； 创建一个接口文件MyBeanPostProcessor.class 里面有两种方法 public Object postProcessBeforeInitialization(Object bean,String beanName){} 初始化之前调用 public Object postProcessAfterInitialization(Object bean,String beanName){} 初始化之后调用 Object bean String beanName ：bean在xml中配置的id （容器启动）构造器-后置处理器before-初始化方法-后置处理器after-（容器关闭）销毁方法 无论bean是否有初始化方法，后置处理器都会默认其有，还会继续工作 比如car 就没有初始化方法 --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b68e7cfe113efec78db5e94f55e6f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0808760242f1f1f238a3dd65b86056fe/" rel="bookmark">
			vue element-plus中collapse折叠面板默认全部展开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景 将图中所有的collapse全部默认展开
代码：
activeNames是个数组，存放的是要展开的collapse的name
注意事项：这里的activeNames不能动态去改变，要一次性赋值
这样写默认是不能展开的
正确的写法：(我理解的，这样写实现了)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd71e5eae360563bd8a32fa3bb63f74/" rel="bookmark">
			数据结构/C&#43;&#43;实习：作业完成情况管理程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码（含数据），实习论文，实习计划书，实习汇报PPT：下载链接 https://download.csdn.net/download/weixin_43042683/21354783
任务内容 题目内容：作业完成情况管理程序
具体要求：假设某门课程一学期要留10次作业，每次老师要进行批改，给出分数后还要进行登记。学期期末要根据每次作业的成绩计算出最终的平时成绩（满分100）。
该程序应该具有下列功能：
(1) 通过键盘输入某位学生某次作业的分数；
(2) 给定学号，显示某位学生作业完成情况；
(3) 给定某个班级的班号，显示该班所有学生的作业完成情况；
(4) 给定某位学生的学号，修改该学生的作业完成信息；
(5) 给定某位学生的学号，删除该学生的信息；
(6) 提供一些统计各类信息的功能。
程序设计框图 程序设计流程图 进入系统可进行的操作，可以在系统中输入学生的各项信息和成绩，也可以从文件中直接导入（文件中保存的信息应该依次是姓名、学号、班级号、连续十次的成绩，各个信息用空格隔开）。
详细设计说明 Mian()主函数包括：（实习论文更详细）
Printf_help();//显示主菜单
input(st,qt);// 通过键盘输入某位学生某次作业的分数
readfile(st,fp);// 从文件导入学生信息
sno_search(st);// 给定学号，显示某位学生作业完成情况
cno_search(st);// 给定某个班级的班号，显示该班所有学生的作业完成情况
sno_change(st);// 给定某位学生的学号，修改该学生的作业完成信息
sno_delete(st);// 给定某位学生的学号，删除该学生的信息
statistics_result(st);// 显示各类统计信息
system("CLS");//清屏
creat_files(st,fp);// 导出文件
程序使用说明 步骤一：首次运行之后会出现一个主菜单：
步骤二：然后可以根据不同的数字字符的输入，进行不同的操作。每一步操作也有下一步相应的文字提示。
在主菜单中选择‘1’后，就是进行键盘输入某位学生某次作业的分数的操作：
在主菜单中选择‘2’后，进行文件导入学生信息操作：
在主菜单中选择‘3’，就是对给定学生学号进行该学生作业完成情况的一个查询工作：
在主菜单中选择‘4’，可通过班级号，对该班学生的作业完成情况进行查询：
在主菜单中选择‘5’，可修改给定学号的学生作业完成信息： 在主菜单中选择‘6’，可删除给定学号的学生作业完成信息：
在主菜单中选择‘7’，可显示各类统计信息：
在副菜单下选择‘1’，可以按学号查看学生平时成绩：
在副菜单下选择‘2’，可以按班级查看学生平时成绩：
在副菜单下选择‘3’，输出降序的平时成绩的排列：
在主菜单中选择‘8’，执行清屏功能；
步骤三：
在主菜单中选择‘9’，导出文件：
在主菜单中选择‘0’，退出系统：
参考代码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;io.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; #include &lt;conio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dd71e5eae360563bd8a32fa3bb63f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2c8190ad2c109d165fb2cc950c4ebb/" rel="bookmark">
			Ubuntu系统中根目录占用了大量内存后清理步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近经常用pycharm跑python程序，后来发现根目录的被占用的越来越大，看了有一个网友的是因为mysql 日志过大使得自己的/目录过大，但是我自己查了一下自己并不是那种情况。后来几番查询才得知是pycharm下有一个cashes居然占了35G，我根目录一共才40G。因为自己上次也是遇到这个问题，没有搞定，把系统重装了，这次又遇到这个问题，果断记录。可能你不是pycharm的问题，但可能是其他软件缓存问题，本文供参考。
查询步骤如下：
查询自己的内存使用情况，命令为：
df -lm
进入/目录查询
du -sh *|sort -h
1
查询各个目录大小，发现/root占了35G
进到/root中看了一下，基本没什么能占用内存的，除了Pycharm的文件
于是进入.PycharmCE2018.2文件查询，发现cashes占了35G，应该就是这个罪魁祸首了
进入cashes有几个文件，其中content.dat.storageData 占用内存最大，将近35G，我天！不知道为什么占用这么大内存，缓存应该无妨，于是删除
重启电脑后发现，/目录的使用率变为5%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d3e3e1d523907667108c0bf0407cda/" rel="bookmark">
			【数据结构与算法】内排序算法全解析（附C语言代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导览 0 预备知识0.1 排序的概念0.2 排序的稳定性0.3 内排序与外排序0.4 排序算法的性能0.5 常见排序算法的性能 1 比较排序1.1 插入排序1.1.1 直接插入排序1.1.2 折半插入排序1.1.3 希尔排序 1.2 交换排序1.2.1 冒泡排序1.2.2 快速排序 1.3 选择排序1.3.1 简单选择排序1.3.2 堆排序 1.4 归并排序1.4.1二路归并排序 2 非比较排序2.1 基数排序2.2 计数排序2.3 桶排序 0 预备知识 0.1 排序的概念 排序：将一个记录的无序序列调整成为一个有序序列，使之按关键字递增或递减有序排列的过程。为了提高数据的查找效率，预先排序可以减少获得查找结果的时间。
关键字：对记录进行排序时的依据。
如：可以按学生姓名首字母对学生记录进行排序，也可以按学号对学生记录进行排序。
0.2 排序的稳定性 稳定的排序：如果待排序的记录中存在多个关键字相同的数据，排序后这些具有相同关键字的数据之间的相对次序保持不变。
不稳定的排序：如果待排序的记录中存在多个关键字相同的数据，排序后这些具有相同关键字的数据之间的相对次序发生变化。
0.3 内排序与外排序 内排序：排序过程中，排序数据在内存中处理，不涉及数据的内、外存交换。适用于数据量小的数据。
外排序：排序过程中，涉及数据的内、外存交换。
内排序是外排序的基础。
0.4 排序算法的性能 排序算法的性能由算法的时间和空间确定。
算法时间复杂度：求出算法所有原操作的执行次数T(n)，与算法的执行时间成正比，即可以用T(n)来表示算法的执行时间。算法的时间复杂度一般作为问题规模n的函数，使用T(n)的数量级表示，即
T ( n ) = O ( f ( n ) ) T(n)=O(f(n)) T(n)=O(f(n))
常数阶O(1)：一般一个没有循环（或有循环，但循环次数与问题规模n无关）的算法中原操作执行次数与问题规模n无关，执行时间看成O(1)。如定义变量、赋值、输入输出语句。
线性阶O(n)：一个只有一重循环的算法中原操作执行次数与问题规模n的增长呈现线性增大的关系，执行时间看成O(n)。
其余常用的还有平方阶O(n2)、立方阶O(n3)、对数阶O(log2n)、指数阶O(2n)等。
不同时间复杂度的大小关系：
O ( 1 ) ＜ O ( l o g 2 n ) ＜ O ( n ) ＜ O ( n l o g 2 n ) ＜ O ( n 2 ) ＜ O ( n 3 ) ＜ O ( 2 n ) ＜ O ( n !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d3e3e1d523907667108c0bf0407cda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008a0f95aad5f6d11f7404431c1f2427/" rel="bookmark">
			8-18日报博文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正交实验法
在软件测试过程中，我们会遇到一些可能的输入数据或者这些输入数据的组合数量很大的情况，由于不可能为每个输入组合都创建测试用例，而使用一般的测试方法会产生大量的冗余测试，因此我们想到了一种新的测试用例设计方法——正交试验法。
正交表测试策略是一种成对测试交互的系统的统计的方法。它提供了一种能对所有变量对的组合进行典型覆盖（均匀分布）的方法。正交排列法能够使用最小的测试过程集合获得最大的测试覆盖率。
正交表是由行数、因素数、水平数构成的。
行数（Runs）：正交表中的行的个数，即试验的次数。
因素数（Factors）：正交表中列的个数。
水平数（Levels）：任何单个因素能够取得的值的最大个数。正交表中的包含的值为从0到数“水平数-1”或从1到“水平数”。
正交表的表示形式：
正交表具有以下特性：
整齐可比性在同一张正交表中，每个因素的每个水平出现的次数是完全相同的。由于在试验中每个因素的每个水平与其它因素的每个水平参与试验的机率是完全相同的，这就保证在各个水平中最大程度的排除了其它因素水平的干扰。因而，能最有效地进行比较和作出展望，容易找到好的试验条件。
均衡分散性在同一张正交表中，在任意2列其横向组成的数字对中，每种数字对出现的次数相等。这样就保证了试验条件均衡地分散在因素水平的完全组合之中，因而具有很强的代表性，容易得到好的试验条件。
用正交表设计测试用例的步骤：
1 确定交互测试中有多少个相互独立的变量，这映射到表中的因素数（Factors）
2 确定每个变量可以取值的的个数的最大数，这映射到表中的水平数（Levels）
3 选择一个次数（Run）数最少的最适合的正交表。一个最合适的正交表是至少满足第一步说明的因素数且至少满足第二步说明的水平数
4 把因素和值映射到表中
5 为剩下的水平数选取值
6 把次数中所描述的组合转化成测试用例，再增加一些没有生成的但可疑的测试用例
如何选择正交表：
考虑因素（变量）的个数 考虑因素水平（变量的取值）的个数 考虑正交表的行数 取行数最少的一个
查询正交表
http://support.sas.com/techsup/technote/ts723_Designs.txt
一个简单的例子：水平数（变量的取值）相同、因素数（变量）刚好符合正交表 假设查询某个人时有三个查询条件：根据“姓名”、“身份证号码”、“手机号码”查询
考虑查询条件要么不填写，要么填写，此时可用正交表进行设计 有三个因素： 姓名、身份证号、手机号码 每个因素有两个水平 姓名：填、不填 身份证号：填、不填 手机号码：填、不填
表中的因素数＞＝3 表中至少有三个因素的水平数＞＝2 行数取最少的一个 结果： 姓名：0 填写，1 不填写 身份证号：0 填写，1 不填写 手机号码： 0 填写，1 不填写
测试用例如下： 1：填写姓名、填写身份证号、填写手机号 2：填写姓名、不填身份证号、不填手机号 3：不填姓名、填写身份证号、不填手机号 4：不填姓名、不填身份证号、填写手机号 增补测试用例 5：不填姓名、不填身份证号、不填手机号
测试用例减少数： 8→5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd58395a9f9c48954627fa3d933ed50/" rel="bookmark">
			word转pdf时图片模糊/分辨率不高解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般我们进行文件传输时，为了保持格式的稳定性，经常会将doc格式转为pdf格式，但是有时会发现转换后图片会变得异常模糊，分辨率不高。
网上有很多解决办法，但大多比较复杂且最终效果不好。
这里介绍一种简单有效的解决方案。
以word2016为例。首先打开word，进入文件&gt;选项&gt;高级&gt;图像大小和质量，勾选【不压缩文件中的图像】，并将默认目标输出设置为330ppi，并应用于所有新文档，最后点击确定。
最后进行pdf导出设置。进入文件&gt;导出&gt;创建pdf文档，勾选【标准(联机发布和打印)】，选项中勾选【符合ISO 标准】，最后确定即可。
切记不要勾选【无法嵌入字体情况下显示文本位图】
最后即可获得较高分辨率的图片
转自本人新浪博客：http://blog.sina.com.cn/cugigg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac61087989daf8b49d6a068152d5a395/" rel="bookmark">
			docker搭建Nextcloud服务器并挂栽samba共享文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建本地文件夹，用来存储实际文件
mkdir /home/Nextcloud mkdir /home/Nextcloud/apps /home/Nextcloud/data /home/Nextcloud/theme /home/Nextcloud/config 二、使用docker构建Nextcloud服务
docker run -itd --name nextcloud \ -v /home/Nextcloud:/var/www/html \ -v /home/Nextcloud/apps:/var/www/html/custom_apps \ -v /home/Nextcloud/config:/var/www/html/config \ -v /home/Nextcloud/data:/var/www/html/data \ -v /home/Nextcloud/theme:/var/www/html/themes/&lt;YOUR_CUSTOM_THEME&gt; \ nextcloud 三、打开服务器ip地址，填写管理员账号、密码，做好初始设置
3.1 删除docker容器删除后多余的卷
# 先用下列命令看一下那些卷没有用处 docker volume ls -qf dangling=true # 具体的删除操作 docker volume rm 卷的代码 #通常是一长串字符，和容器镜像类似，但是要更长 四、添加外部存储的支持性插件
五、通常默认是不支持SMB协议的
六、进入容器，安装smbclient
docker exec -it nextcloud bash apt update apt install smbclient libsmbclient-dev pecl install smbclient docker-php-ext-enable smbclient 七、退出容器，重启容器
八、增加存储，填写相关的外部samba共享信息即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81a74f94f926c6a3e383315748cf400/" rel="bookmark">
			【Java】再谈java乱码：GBK和UTF-8互转尾部乱码问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以为，java中任意unicode字符串，可以使用任意字符集转为byte[]再转回来，只要不抛出异常就不会丢失数据，事实证明这是错的。
经过这个实例，也明白了为什么 getBytes()需要捕获异常，虽然有时候它也没有捕获到异常。
言归正传，先看一个实例。
用ISO-8859-1中转UTF-8数据
设想一个场景：
用户A，有一个UTF-8编码的字节流，通过一个接口传递给用户B；
用户B并不知道是什么字符集，他用ISO-8859-1来接收，保存；
在一定的处理流程处理后，把这个字节流交给用户C或者交还给用户A，他们都知道这是UTF-8，他们解码得到的数据，不会丢失。
下面代码验证：
public static void main(String[] args) throws Exception { //这是一个unicode字符串，与字符集无关 String str1 = "用户"; System.out.println("unicode字符串："+str1); //将str转为UTF-8字节流 byte[] byteArray1=str1.getBytes("UTF-8");//这个很安全，UTF-8不会造成数据丢失 System.out.println(byteArray1.length);//打印6，没毛病 //下面交给另外一个人，他不知道这是UTF-8字节流，因此他当做ISO-8859-1处理 //将byteArray1当做一个普通的字节流，按照ISO-8859-1解码为一个unicode字符串 String str2=new String(byteArray1,"ISO-8859-1"); System.out.println("转成ISO-8859-1会乱码："+str2); //将ISO-8859-1编码的unicode字符串转回为byte[] byte[] byteArray2=str2.getBytes("ISO-8859-1");//不会丢失数据 //将字节流重新交回给用户A //重新用UTF-8解码 String str3=new String(byteArray2,"UTF-8"); System.out.println("数据没有丢失："+str3); } 输出：
unicode字符串：用户 6 转成ISO-8859-1会乱码：ç”¨æˆ· 数据没有丢失：用户 用GBK中转UTF-8数据
重复前面的流程，将ISO-8859-1 用GBK替换。
只把中间一段改掉：
//将byteArray1当做一个普通的字节流，按照GBK解码为一个unicode字符串 String str2=new String(byteArray1,"GBK"); System.out.println("转成GBK会乱码："+str2); //将GBK编码的unicode字符串转回为byte[] byte[] byteArray2=str2.getBytes("GBK");//数据会不会丢失呢？ 运行结果：
unicode字符串：用户 6 转成GBK会乱码：鐢ㄦ埛 数据没有丢失：用户 好像没有问题，这就是一个误区。
修改原文字符串重新测试
将两个汉字 “用户” 修改为三个汉字 “用户名” 重新测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b81a74f94f926c6a3e383315748cf400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72228858755562d26f126dc13bd5339/" rel="bookmark">
			LDPC译码原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.LDPC译码的背景及内容 LDPC译码分为硬判决译码和软判决译码。
硬判决译码又称代数译码，主要代表是比特翻转（BF）译码算法，它的实现比较简单，但是译码性能很差。硬判决译码的基本假设是当校验方程不成立时，说明此时必定有比特位发生了错误，而所有可能发生错误的比特中不满足检验方程个数最多的比特发生错误的概率最大。在每次迭代时翻转发生错误概率最大的比特并用更新之后的码字重新进行译码。
软判决译码是一种基于概率论的译码算法，通常需要与迭代译码进行结合，才能体现成译码性能的优势，基本算法是置信传播（BP）译码算法，它的实现比代数译码方法的复杂度高很多，但译码性能非常好。
为了解决BP译码算法实现困难问题，在学术界牵起了优化算法的浪潮，对数域置信传播译码（LLR BP）算法、最小和（Min-Sum）译码算法、Normalized Min-Sum译码算法、Offset Min-Sum译码算法等相继涌现。
在迭代译码的过程中，信息调度方式分为两种：泛滥式调度和分层式调度。泛滥式调度的特点在于每一次译码迭代过程中，首先计算从变量节点到校验节点的所有软信息，然后计算从校验节点到变量节点的所有软信息。分层调度的特点是在计算每层软信息时，更新此次迭代中的相关的节点信息，用于下一层的软信息计算。
LDPC译码结构的设计方面主要分为三种：全并行译码结果、行并行译码结构、块并行译码结构。泛滥式的调度比较适合全并行结构，但是译码器的硬件复杂度始终是一个技术瓶颈。分层式的调度适合行并行和块并行结构，可以减少译码所需的迭代次数。
2.LDPC码设计 LDPC码是一种分组码，其校验矩阵只含有很少量非零元素（稀疏矩阵）。
码的设计是以设计一个校验矩阵开始的，然后才通过它确定一个生成矩阵进行后续编码。而LDPC的编码就是本文所要讨论的主体内容。对于LDPC码而言，校验矩阵的选取十分关键，不仅影响LDPC码的纠错性能力，也影响LDPC编译码的复杂度及硬件实现的复杂度。准循环LDPC码（Quasi-Cycle,QC-LDPC）是LDPC码中重要的一类，是指一个码字以右移或左移固定位数的符号位得到的仍是一个码字。QC-LDPC码的校验矩阵是由循环子矩阵的阵列组成，相对于其他类型的LDPC码，在编码和解码的硬件实现上具有许多优点。
置信传播（BP）译码算法，置信传播算法是基于Tanner图的迭代译码算法。在迭代过程中，可靠性消息，即“消息”通过Tanner图上的边在变量节点和校验节点中来回传递，经多次迭代后趋于稳定值，然后据此进行最佳判决，BP译码算法有着非常好的译码性能。
校验矩阵：
对应Tanner 图：
n个码字比特顶点（称为比特节点），分别与校验矩阵的各列相对应；
m个校验方程顶点（称为校验节点），分别与校验矩阵的各行对应。
循环以这群顶点中的一个同时作为起点和终点，且只经过每个顶点一次。循环的长度定义为它所包含的连线的数量，而图形的围长，也可叫做图形的尺寸，定义为图中最小的循环长度。上图围长为6。
2.1置信传播算法 置信传播算法（Belief Propagation）译码算法是消息传递（Message Passing）算法在LDPC译码中的运用。消息传递算法是一个算法类，最初运用于人工智能领域，人们将其运用到LDPC码的译码算法中，提出来LDPC码的置信传播算法。置信传播算法是基于Tanner图的迭代译码算法。在迭代过程中，可靠性消息，即“消息”通过Tanner图上的边在变量节点和校验节点中来回传递，经过多次迭代后区域稳定值，然后据此进行最佳判决。
置信传播译码算法的基本流程如下：
在迭代前，译码器接收到信道传送过来的实值序列y = (y1,y2,…,yn)，所有变量节点接收到对应的接收值yi。
第一次迭代：每个变量节点给所有与之相邻的校验节点传送一个可靠消息，这个可靠消息就是信道传送过来的值；每个校验节点接收到变量节点传送过来的可靠消息之后，进行处理，然后返回一个新的可靠消息信息给与之相邻的变量节点，这样就完成第一次迭代；此时可以进行判决，如果满足校验方程，则不需要再迭代，直接输出判决结果，否则进行第二次迭代。
第二次迭代：每个变量节点处理第一次迭代完成时校验节点传送过来的可靠消息，处理完成后新的消息发送给校验节点，同理，校验节点处理完后返回给变量节点，这样就完成了第二次迭代。完成后同样进行判决，如果满足校验方程则结束译码，否则如此反复多次迭代，每次都进行判决，直到达到设定的最大迭代次数，译码失败。在每次迭代过程中，无论是变量节点传送给校验节点的信息或者校验节点传送给变量节点的信息，都不应该包括前次迭代中接收方发送给发送方的信息，这样是为了保证发送的信息与接受节点已得到的信息相互对立。
译码结束：
如果或者达到最大译码迭代次数时，译码停止。
2.2对数域置信传播算法 置信传播算法中包含大量乘法运算，乘法运算结果稳定性比较差，波动性高，且复杂度高，运算时间较长，因而出现了对数域置信传播算法，将概率消息用对数似然比进行表示，概率域的乘法转换成对数域的加法。
根据以上，LLR BP译码算法的迭代译码步骤如下：
（主要是根据3-9对数域、概率域之间的转换）
以上可知，LLR BP相较于BP译码算法在保证译码性能的同时也大大减少了运算的复杂度。
2.3最小和译码算法 最小和译码（MS，Min-Sum）算法是以LLR BP算法译码为基础，对校验节点信息更新的表达式进行的简化，其余步骤均与LLR BP译码算法一致。
Tanh函数：
由上图，可以知道tanh的一些特点。tanh函数是奇函数，定义域内单调增加，值域在（-1,1）之间。
比较LLR BP译码算法和Min-Sum译码算法的校验节点信息更新过程，可以看到他们的主要区别在于LLR BP译码算法中的tanh(.)运算和加法运算在Min-Sum译码算法中被最小值和运算符号进行替换，MS译码简化了LLR BP译码算法，降低了译码算法的复杂度。 2.4改进的最小和译码算法 Min-Sum算法的简化方案不是精确计算而是近似方案，因而计算出的校验节点信息值和原始的实际值会存在误差，即过大估计问题。这将会导致译码过程的收敛速度减慢，译码性能也会有所损失。因此，研究人员提出了两种有效的方案：Normalized Min-Sum算法和Offset Min-Sum算法。
（1）Normalized Min-Sum算法
算法主要思想是在MS算法计算校验节点信息更新的步骤中对计算结果乘一个修正因子进行调整，缩小两者之间的差距。
（2） Offset Min-Sum算法
算法主要思想是在MS算法计算校验节点更新信息的步骤中对计算结果减一个修正因子进行误差补偿。
这两种改进方案复杂度差不多，但在译码性能方面远超MS译码算法，具有比较接近LLR BP译码算法的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923dee48f38f19e1162efa71c4a9ed85/" rel="bookmark">
			Git场景命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git根据场景而用到的命令行
stash 场景：临时拉取最新线上仓库代码，但是又不想提交已修改的代码到本地仓库，可以先缓存本地修改过的代码（没有commit），拉取最新代码完成，再恢复缓存的代码。步骤： 1. git stash - 把本次修改的代码加入缓存，本地仓库代码恢复到上次拉取的时间节点。2. git pull - 通过pull拉取最新代码，这时候本地的仓库和线上仓库最新代码一致。3. git stash pop - 把本次修改的代码缓存重新恢复到本地仓库，就可以在比提交的情况下，继续开发了。fetch 场景一：git branch -a 无法显示所有分支，因为本地没有拉取所有远程仓库信息场景二：checkout 切换分支，报错fatal: Cannot update paths and switch to branch ‘xxx’ at the same time.
Did you intend to checkout ‘origin/xxx’ which can not be resolved as commit? 意思就是找不到路径解决：git fetch origin 拉取远程仓库信息，再执行其他命令，事半功倍。checkout 场景：同事在远程仓库新建了一个分支，你需要拉取，并保持本地名字和远程分支名字一直。 代码：git checkout -b dev（本地分支名） origin/dev（远程分支名）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/178/">«</a>
	<span class="pagination__item pagination__item--current">179/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/180/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>