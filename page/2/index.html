<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24aa0614229ebfd7f5d75390c49de354/" rel="bookmark">
			对html骨架的详细解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html的骨架结构
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt;
文档声明 告诉浏览器我们写的代码是按照html文档类型来写的，浏览器在编译代码时，也要按照html规范来编译，防止出现怪异模式
&lt;html lang="en"&gt;&lt;/html&gt;
html根标签，一个页面就一个根标签 所有的内容都要写在根标签开始标签和结束标签中间，lang="en"向搜索引擎表示语言为英文的网站
&lt;head&gt;&lt;/head&gt;
head标签 帮助浏览器编译代码，里面的内容，用户一般看不到
&lt;meta charset="UTF-8"&gt;
编码类型为万国码
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
与移动端的适配相关
&lt;title&gt;Document&lt;/title&gt;
网站的标题,可以帮助推广部门进行网站推广，非常重要，一般具体内容都是推广部门来定的
&lt;body&gt;&lt;/body&gt;
body标签 是书写网页主体内容，用户看到的所有内容文字，图片，音视频等等都写在body
&lt;!-- 文档声明 告诉浏览器我们写的代码是按照html文档类型来写的 浏览器在编译代码时，也要按照html规范来编译，防止出现怪异模式--&gt; &lt;!DOCTYPE html&gt; &lt;!--html根标签，一个页面就一个根标签 所有的内容都要写在根标签 开始标签和结束标签中间，lang="en"向搜索引擎表示语言为英文的网站--&gt; &lt;html lang="en"&gt; &lt;!-- head标签 帮助浏览器编译代码，里面的内容，用户一般看不到 --&gt; &lt;head&gt; &lt;!--编码类型为万国码--&gt; &lt;meta charset="UTF-8"&gt; &lt;!--与移动端的适配相关--&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;!--网站的标题,可以帮助推广部门进行网站推广，非常重要，一般具体内容都是推广部门来定的--&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;!-- body标签 是书写网页主体内容，用户看到的所有内容文字，图片，音视频等等都写在body--&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b70b5fe2668d1be5de997514f2d777/" rel="bookmark">
			ChatGPT在金融财务领域的10种应用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.生成报告 在金融领域中，最耗时的任务之一是报告生成。通过ChatGPT，您可以在一定程度上自动化这个过程。这款人工智能工具可以获取关于公司财务表现的结构化数据，并生成一份书面摘要，详细说明关键点、趋势和观察结果。这个功能在制作定期报告，如季度收益摘要，方面特别有用。
我希望你使用附加的结构化财务数据生成一份详细的报告。这份报告应包括对关键绩效指标的分析，趋势的识别，以及关于我们公司上个季度财务表现的观察。
2. 分析文本数据 财务数据不仅仅是数字。文本信息，如新闻文章、分析报告和社交媒体帖子，通常蕴含有价值的见解。
ChatGPT可以分析这些文本数据，并提取对财务决策有用的见解。例如，它可以评估市场对特定公司或行业的情绪，提供对财务格局更全面的视角。
我有一批与科技行业相关的新闻文章和财务报告。你能分析这些文本并提取表明整体市场对这个行业情绪的见解吗？
3. 问答系统 您可以利用ChatGPT构建一个用于财务数据的问答系统。您可以向它提问问题，比如“上个季度总收入是多少？”或者“运营费用的趋势是什么？”它可以基于其训练数据生成响应，提供快速而准确的见解。
我有一个包含ABC公司财务数据的数据集。基于这些数据，你能回答以下问题吗：上个季度总收入是多少？在过去一年中运营费用有什么明显的趋势吗？
4. 交互式数据分析 ChatGPT的潜力不仅仅在于回答问题，它还可以帮助创建一个用于探索财务数据的交互式系统。您可以要求它执行特定的分析，请求可视化，或者询问各种指标，并且它会基于其访问的数据作出响应。
我有两家公司的财务数据，XYZ 公司和QRS 公司。你能执行一项比较这两家公司过去五年中营收表现的分析吗？同时，建议一些能有效说明这种比较的可视化。
5. 制作投资摘要 ChatGPT能够消化大量关于各种投资选择的数据，并生成简明易懂的人类可读摘要。这个应用对于希望为客户提供易于理解的潜在投资信息的财务顾问特别有用。
我有关于几种投资选择的数据，包括股票、债券和交易所交易基金。你能为每种投资生成简要的人类可读摘要吗，突显关键特征和绩效指标？
6. 生成财经新闻简报 通过分析财经新闻、股市走势、市场趋势和经济指标，ChatGPT能够生成提供对金融世界快速洞察的简报。这个功能对于需要随时了解市场状况和变化的交易员和投资者尤其有价值。
基于最新的财经新闻文章、股市数据和经济指标，你能生成一份简要摘要，提供对当前金融世界状况的见解吗？
7. 自动化客户互动 ChatGPT的能力扩展到构建复杂的聊天机器人，能够处理与客户财务数据相关的查询。在银行场景中，客户可以询问关于他们的账户余额、最近的交易或信用卡奖励的问题，并即时获得准确的回复。
想象一下你是银行的聊天机器人。如果一个客户问以下问题，你会如何回应：“我的当前账户余额是多少？”、“你能展示我最近的交易吗？”和“我当前信用卡上有多少积分？”
8. 预测叙述 虽然ChatGPT本身不执行预测性分析，但可以与预测模型一起使用，为预测的财务数据生成叙述。例如，如果一个预测模型预测公司下个季度的销售额将增长10%，ChatGPT可以生成以通俗语言解释这一预测的叙述，帮助非专业人士理解其影响。
我有一个预测模型的预测，表明DEF公司下个季度销售额将增长10%。你能生成一个以通俗语言解释这一预测的叙述吗？
9. 翻译财经术语 金融领域充满了对普通人难以理解的术语。ChatGPT可以将复杂的财经术语翻译成简单的语言，使财务数据对非专业利益相关者或普通公众更易理解，有助于弥合知识鸿沟。
示例提示：你能用通俗易懂的语言解释以下财经术语吗：“投资回报率”、“流动性”、“资本增值”和“多元化”？
10. 培训和模拟 ChatGPT的用途还扩展到培训场景。它可以根据财务数据提供响应或生成场景，对培训新分析师或模拟不同的财务情况进行战略开发尤为有用。这就像有一个全天候可用的虚拟教练。
你能生成一个涉及股市突然下跌的假设场景吗？然后，提供关于财务分析师如何应对这种情况的指导。
原文链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def953ebac3fde7a2e56e63d834009a6/" rel="bookmark">
			nginx反向代理走https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cat nginx.conf
#user nobody;
worker_processes 1;
#error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;
events {
worker_connections 1024;
}
http {
include mime.types;
default_type application/octet-stream;
sendfile on;
keepalive_timeout 65;
server {
listen 80;
server_name hzou.i.sinotest.com;
location /test {
root html;
index index.html index.htm;
}
}
server {
listen 443 ssl;
server_name hzou.i.sinotest.com;
ssl_certificate keys/i.sinotest.com_bundle.crt;
ssl_certificate_key keys/i.sinotest.com.key;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_session_timeout 5m;
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
ssl_prefer_server_ciphers on;
location /oms {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def953ebac3fde7a2e56e63d834009a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e773175938a3ab3a059c1b38f7c9e0d/" rel="bookmark">
			linux 内核编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置
默认配置
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- omap2plus_defconfig 原配置
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- oldconfig 重新配置
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig 二 kernel zImage
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage 三 驱动模块
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules 四 devicetree
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- omap4-droid4-xt894.dtb 二三四可合并
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules omap4-droid4-xt894.dtb -j 8 git内核版本会有一段很长的后缀 .config
CONFIG_LOCALVERSION_AUTO=y 把y改成n，或删除这一行然后
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- oldconfig 这时后面只余个+号 如6.1.17+ 如果还想把+号去掉，重定义LOCALVERSION=
或修改scripts/setlocalversio
res=“ r e s res res{scm:++}”
也可以
make LOCALVERSION= ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules omap4-droid4-xt894.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e773175938a3ab3a059c1b38f7c9e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e78a556ad82fa0c06a3eee428574020/" rel="bookmark">
			如何使用JMeter测试https请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP与HTTPS略有不同，所以第一次使用JMeter测试https请求时遇到了问题，百度一番后找到解决方法：加载证书。
下面内容主要记录这次操作，便于后续参考：
操作浏览器：谷歌
（1）下载被测网站证书，点击安全锁，选择​​​​​​安全证书
（2）查看证书的详细信息，显示所有后点击复制到文件
（3）依次下一步，选择DER 编码二进制X.509(.CER)
导出到指定路径，如D盘根目录（文件名以.cer结尾），如下图
（4）将已导出的证书打成.store格式的文件，使用 keytool -import -alias "woqu.store" -file "D:\woqu.cer" -keystore woqu.store命令
执行完后，输入是确定信任该证书
D盘根目录下显示已生成的.store文件
（5）将此证书导入JMeter：选项-SSL管理器，选择woqu.store确定导入
（6）导入成功后，再次运行登录请求时便可成功。
行动吧，在路上总比一直观望的要好，未来的你肯定会感谢现在拼搏的自己！如果想学习提升找不到资料，没人答疑解惑时，请及时加入群：1150305204 ，里面有各种测试开发资料和技术可以一起交流哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dca247401600225f0c1817ad974513d/" rel="bookmark">
			机器学习与深度学习——使用paddle实现随机梯度下降算法SGD对波士顿房价数据进行线性回归和预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 机器学习与深度学习——使用paddle实现随机梯度下降算法SGD对波士顿房价数据进行线性回归和预测一、任务二、流程三、完整代码四、代码解析五、效果截图 机器学习与深度学习——使用paddle实现随机梯度下降算法SGD对波士顿房价数据进行线性回归和预测 随机梯度下降（SGD）也称为增量梯度下降，是一种迭代方法，用于优化可微分目标函数。该方法通过在小批量数据上计算损失函数的梯度而迭代地更新权重与偏置项。SGD在高度非凸的损失表面上远远超越了朴素梯度下降法，这种简单的爬山法技术已经主导了现代的非凸优化。
一、任务 使用Paddle实现随机梯度下降（SGD）算法对波士顿房价数据进行线性回归的训练，给出每次迭代的权重、损失和梯度，并进行房价预测值与真实房价值对比。
二、流程 1、导入必要的库和模块：PaddlePaddle深度学习框架、numpy、os等常用的包和库。
2、读取数据并进行预处理。将数据进行归一化处理，将训练集和测试集划分为7:3的比例。
3、定义线性回归模型。自定义类 Regressor 继承自 paddle.nn.Layer ，初始化函数中定义了一个全连接层。该全连接层的输入维度为13，输出维度为1。
4、构建模型并训练。调用 Regressor() 函数生成模型，使用随机梯度下降法进行训练。。
5、模型预测。运用之前训练好的模型进行前向计算得到预测结果。
6、反归一化处理。进行反归一化处理，得到原始的房价估计值。
输出结果。将得到的预测结果和真实标签值进行比较，并输出预测房价的结果和真实房价结果。
三、完整代码 使用Paddle实现随机梯度下降（SGD）算法对波士顿房价数据进行线性回归的训练，给出每次迭代的权重、损失和梯度，并进行房价预测值与真实房价值对比。
#导入必要的包和库 import paddle from paddle.nn import Linear import paddle.nn.functional as F import numpy as np import os import random def load_data(): # 从文件导入数据 datafile = './work/housing.data' data = np.fromfile(datafile, sep=' ', dtype=np.float32) # 每条数据包括14项，其中前面13项是影响因素，第14项是相应的房屋价格中位数 feature_names = ['CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', \ 'DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV'] feature_num = len(feature_names) # 将原始数据进行Reshape，变成[N, 14]这样的形状 data = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dca247401600225f0c1817ad974513d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca8c11aa898b09f038a101d74f4929a/" rel="bookmark">
			【每日试题】2024最新.net高级面试题！！！！！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是.NET？ .NET是一种由微软开发的软件框架，用于开发和运行各种类型的应用程序。它提供了一个统一的编程模型，使开发人员能够使用多种编程语言（如C#、VB.NET等）来创建跨平台的应用程序。
什么是面向对象编程？ 面向对象编程（OOP）是一种编程方法，它将程序组织为对象的集合，每个对象都有自己的数据和行为。面向对象编程的特点包括封装、继承和多态。
请解释封装的概念。 封装是一种将数据和方法打包在一起的机制，以便对外部隐藏数据的细节。它可以通过访问修饰符来控制对数据的访问权限，只有通过定义的方法才能访问和修改数据。
请解释继承的概念。 继承是一种机制，允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。子类可以使用继承的属性和方法，并可以添加自己的额外属性和方法。
请解释多态的概念。 多态是指同一个方法可以根据不同的对象类型执行不同的操作。多态可以通过继承和接口来实现。
什么是接口？ 接口定义了一组方法和属性的契约，但不提供实现。它允许多个类实现相同的接口，以实现代码的重用和扩展。
请解释委托的概念。 委托是一种引用类型，用于封装一个或多个方法，并允许以相同的签名调用这些方法。委托可以作为参数传递给其他方法，也可以用于事件处理和回调函数。
什么是LINQ？ LINQ（Language Integrated Query）是一种用于查询和操作各种数据源的统一查询语法。它提供了一种简化和统一的方法来查询和操作数据，包括集合、数据库、XML和对象。
请解释异步编程的概念。 异步编程是一种编程模型，允许在执行长时间运行的操作时保持应用程序的响应性。它使用异步方法和任务来处理非阻塞的并发操作，并允许应用程序在操作完成之前执行其他任务。
什么是异常处理？ 异常处理是一种处理程序中发生的错误或异常情况的机制。它允许开发人员识别并捕捉异常，并提供适当的处理逻辑以处理异常或恢复程序的正常执行。
请解释泛型的概念。 泛型是一种允许在编写代码时指定类型的机制。它提供了一种类型安全和重用代码的方式，使开发人员能够编写通用和可扩展的代码。
请解释反射的概念。 反射是一种机制，允许在运行时检查和修改程序的结构和行为。它提供了一种动态访问和操作程序集、类型、方法和属性的方式。
请解释如何进行单元测试。 单元测试是一种测试方法，用于验证代码中的单个单元（如方法或类）是否按照预期工作。它通常包括编写测试用例、运行测试、验证结果和修复错误。
请解释如何进行调试。 调试是一种用于分析和修复代码错误的方法。它允许开发人员在运行时检查代码的状态、执行流程和变量的值，并通过断点、日志和观察面板来跟踪代码的执行。
请解释如何进行性能优化。 性能优化是一种优化代码和系统资源以提高应用程序性能的方法。它包括使用高效的算法和数据结构、减少资源的使用、并行化操作以及进行代码优化。
请解释如何进行安全编程。 安全编程是一种编写代码以保护应用程序和用户数据安全性的方法。它包括验证用户输入、防止代码注入、使用安全密码和加密算法以及实施访问控制和权限管理。
请解释并发编程的概念。 并发编程是一种通过多个线程或进程同时执行来提高应用程序性能和响应性的方法。它涉及到同步和协调线程的执行，以避免竞态条件和死锁等问题。
请解释面向服务编程的概念。 面向服务编程（SOA）是一种将应用程序分解为独立的、可重用的服务的方法。它允许通过网络调用服务来实现分布式系统和业务流程的集成。
请解释微服务架构的概念。 微服务架构是一种基于独立部署的小型服务的方法，每个服务都负责执行特定的业务功能。它提供了一种分解复杂系统和实现可伸缩性的方式。
请解释容器化的概念。 容器化是一种将应用程序及其依赖项打包到独立的、可移植的容器中的方法。容器可以在任何支持容器引擎的环境中运行，提供一致的开发和部署体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e769fb4bbc6c0061aa22fd31d634639/" rel="bookmark">
			大数据领域相关术语总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 01、PGC02、UGC03、CTR04、CVR05、留存率06、UV07、PV08、DAU09、ROI10、KPI11、RFM 01、PGC PGC 是 Professionally Generated Content 的缩写，意为专业生产的内容。PGC 的内容通常由专业的内容创作者、媒体机构或者公司进行创作和生产，具有较高的质量和专业性。PGC 的内容形式多样，包括文章、视频、音频、图片等，通常需要经过严格的审核和筛选，符合一定的标准和要求。PGC 的受众面相对较广，适合于传播各种类型的信息和知识。
02、UGC UGC 是 User Generated Content 的缩写，意为用户生成的内容。UGC 的内容是由普通用户或者消费者自行创作和生产的，通常不经过严格的审核和筛选，质量和专业性相对较低。UGC 的内容形式多样，包括照片、视频、文字、音频等，通常具有一定的个性化和创新性。UGC 的受众面相对较窄，通常更适合于分享个人经验、生活感悟、创意作品等。
03、CTR CTR 是 Click-Through Rate 的缩写，意为点击率。CTR 指的是广告被点击的次数与广告被展示的次数之间的比例，通常以百分比的形式表示。CTR 是衡量广告吸引力和效果的重要指标之一，它可以帮助广告主评估广告的质量和效果，优化广告投放策略。
04、CVR CVR 是 Conversion Rate 的缩写，意为转化率。CVR 指的是广告被点击后，用户进行了期望的行为（比如购买、注册、订阅等）的次数与广告被点击的次数之间的比例，通常以百分比的形式表示。CVR 是衡量广告转化效果的重要指标之一，它可以帮助广告主评估广告的实际效果，优化广告投放策略。
05、留存率 留存率（Retention Rate）指的是在一定时间内，用户或客户继续使用产品或服务的比率。留存率通常是以百分比的形式表示，它是一个重要的用户活跃度指标，可以帮助企业评估产品或服务的质量和用户忠诚度。常用的有次日留存率，3日留存率，7日留存率，30日留存率等
06、UV UV 是 Unique Visitor 的缩写，意为独立访客数。UV 指的是在一定时间范围内，访问网站或应用的独立用户数量，同一用户多次访问只计算一次。UV 是衡量网站或应用受众面和影响力的重要指标之一，它可以帮助企业评估品牌知名度和用户忠诚度。
07、PV PV 是 Page View 的缩写，意为页面浏览量。PV 指的是在一定时间范围内，网站或应用页面被访问的次数，同一用户多次访问同一页面计算多次。PV 是衡量网站或应用流量和用户活跃度的重要指标之一，它可以帮助企业评估网站或应用的流量质量和用户参与度。
08、DAU 日活（Daily Active Users，DAU）是指在一天内使用某个产品或服务的独立用户数量，通常用于衡量产品或服务的日常活跃度和受众规模。日活通常以独立用户数的形式表示，是一个重要的互联网指标之一。
09、ROI ROI 是 Return on Investment 的缩写，意为投资回报率。ROI 是一个用于衡量投资收益的指标，通常用于评估投资的效果和收益。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e769fb4bbc6c0061aa22fd31d634639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421a8654ab984038c8c7354b31f5cd4e/" rel="bookmark">
			selenium实现UI自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.selenium简介 selenium是支持web浏览器自动化的一系列工具和库的综合项目。具有支持linux、windows等多个平台，支持Firefox、chrome等多种主流浏览器；支持Java、Python等多种语言。
主要包括的三大工具有：
WebDriver（rc 1.0)、IDE、Grid
selenium webDriver 它是selenium2.0之后的核心，webDriver通过原生浏览器支持或者浏览器扩展直接控制浏览器，webDriver通过各个浏览器开发，取代了嵌入到被测web中的javaScript(selenium 1.0)
webDriver的核心方法和属性：
浏览器的名称：driver.name当前的url: driver.current_url当前页面标题：driver.title当前页面源码：driver.page_source窗口句柄：driver.current_window_handle当前窗口所有句柄：driver.window_ handles selenium IDE 录制回放工具。提供记录和回放功能。允许开发测试人员以Java、Python等多种语言导出录制的脚本。可以在selenium rc或者webDriver中使用这些脚本
selenium grid 允许我们在多台计算机上并行测试，并集中管理不同浏览器版本和浏览器配置
配图……
2.UI自动化实现 webDriver的工作原理如下： 对于每一条Selenium脚本，一个http请求会被创建并发送给浏览器的驱动浏览器驱动中包含了一个http server ，用来接收这些http 请求Http Server 接收到请求后根据请求来具体操控对应的浏览器浏览器执行具体的步骤浏览器将步骤执行结果返回给http serverHttp server 又将结果返回给Selenium的脚本，如果是错误的http代码我们就会在控制台看到对应的报错信息 webDriver的核心方法和属性 属性如下：
——
核心方法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2127426901bcb7a0df7933081190bd7e/" rel="bookmark">
			exec、execFile、fork、spawn的区别与使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Node.js中，通过子进程可以实现并行执行任务，处理复杂的操作，以及与外部命令或文件进行交互。Node.js提供了多种子进程创建方法，包括exec、execFile、fork和spawn。本文将对这些方法进行比较，并介绍它们的适用场景和示例。
一、方法概览 以下是exec、execFile、fork和spawn方法的简要概述：
exec:
执行 shell 命令创建新的 shell 进程获取命令的输出和错误信息 execFile:
执行指定的可执行文件不通过 shell 执行命令获取命令的输出和错误信息 fork:
衍生新的 Node.js 子进程执行 JavaScript 文件支持父子进程间通过消息进行通信 spawn:
执行命令不创建 shell 进程支持流式处理输入输出 二、exec、execFile、fork、spawn使用场景 exec 适用场景：执行简单的 shell 命令，获取命令的输出和错误信息。
const { exec } = require('child_process'); exec('ls -l', (error, stdout, stderr) =&gt; { if (error) { console.error(`Error: ${error.message}`); return; } console.log(`Command output: ${stdout}`); }); execFile 适用场景：执行可执行文件，获取输出和错误信息。
const { execFile } = require('child_process'); execFile('myapp.exe', (error, stdout, stderr) =&gt; { if (error) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2127426901bcb7a0df7933081190bd7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9952a19e1367386999500618e7fd71c/" rel="bookmark">
			maven-插件开发(idea)-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package gitlab; import org.gitlab4j.api.Constants; import org.gitlab4j.api.GitLabApi; import org.gitlab4j.api.GitLabApiException; import org.gitlab4j.api.models.Branch; import org.gitlab4j.api.models.MergeRequest; import org.gitlab4j.api.models.MergeRequestParams; import org.gitlab4j.api.models.Project; import java.util.List; public class GitMain { String gitLabUrl = "域名"; static String projectId = "rcs/项目名"; static GitLabApi gitLabApi; GitMain(String gitLabUrl,String projectId ){ gitLabApi = new GitLabApi(GitLabApi.ApiVersion.V4, "https://git.com", "wfG-_kDzzxkqrts8mz5L"); } public static Project getGitLabApi() throws GitLabApiException { // String personalAccessToken = "_C-xfqXrp3dfqUWjTy4y"; // GitLabApi gitLabApi = new GitLabApi(gitLabUrl, personalAccessToken); // Project project = gitLabApi.getProjectApi().getProject(projectId); // 创建 GitLabApi 实例 // 获取项目列表 Project project = gitLabApi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9952a19e1367386999500618e7fd71c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d153c4dd7e992556c082470f2448a99/" rel="bookmark">
			基于多反应堆的高并发服务器【C/C&#43;&#43;/Reactor】（中）在EventLoop的任务队列中添加新任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务队列是一个链表，每个节点包含channel类型、文件描述符和操作类型。在添加节点时，需要考虑线程同步，并确保节点被正确地添加到链表中。节点的操作可以写到另一个函数中，以便于程序的维护。在添加任务节点时，需要加互斥锁，因为有可能是当前线程或主线程进行添加操作。 本文主要介绍了在dispatcher中的处理流程，包括线程同步以及节点的添加和操作。其中，任务队列是一个链表，每个节点包含channel类型、文件描述符和操作类型。在添加节点时，需要考虑线程同步，并确保节点被正确地添加到链表中。
EventLoop.h // 添加任务到任务队列 int eventLoopAddTask(struct EventLoop* evLoop,struct Channel* channel,int type); EventLoop.c (1) 为什么在上面添加链表节点的时候需要加互斥锁？
因为有可能是当前线程去添加，也有可能是主线程去添加。 (2) 如果当前的线程是主线程，那么我们能够让主线程进行节点的处理吗？
肯定不能，因为你当前主线程它只能负责和客户端建立连接，如果这个连接建立好了，剩下的事情都是需要由这个子线程来完成的。所以主线程肯定不会给你去处理任务队列里边的节点。在主线程里边，其实它是有一个反应堆模型的，在当前的这个子线程里边也有一个反应堆模型。每个反应堆模型里边都有一个Dispatcher。关于这个Dispatcher就是epoll、poll、或者select模型，所以主线程去处理的话，这个任务就放到主线程的那个Dispatcher里边了，这样很显然是不对的。故在子线程的任务队列里边有了任务之后，还需要交给子线程的Dispatcher去处理。因此这个节点的处理，还需要判断当前线程到底是什么线程。如果它是主线程不能让它去处理，如果是子线程，直接让它去处理。 // 添加任务到任务队列 int eventLoopAddTask(struct EventLoop* evLoop,struct Channel* channel,int type) { // 加锁，保护共享资源 pthread_mutex_lock(&amp;evLoop-&gt;mutex); // 创建新节点,后添加到任务队列中去 struct ChannelElement* node = (struct ChannelElement*)malloc(sizeof(struct ChannelElement)); node-&gt;channel = channel; node-&gt;type = type; node-&gt;next = NULL; // 链表为空 if(evLoop-&gt;head == NULL) { evLoop-&gt;head = evLoop-&gt;tail = node; }else { evLoop-&gt;tail-&gt;next = node; // 添加 evLoop-&gt;tail = node; // 后移 } pthread_mutex_unlock(&amp;evLoop-&gt;mutex); // 处理节点 /** * 这个描述假设了一个前提条件，就是当前的EventLoop反应堆属于子线程 * 细节： * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d153c4dd7e992556c082470f2448a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4573b489d2d39296d6e9bc6dd21ce8/" rel="bookmark">
			并发编程(高并发、多线程) 第二篇章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		暂时没有内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e743846436d64a41f7f2a64be0eda3c/" rel="bookmark">
			UnityRenderStreaming使用记录（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnityRenderStreaming 地址https://github.com/Unity-Technologies/UnityRenderStreaming
一、客户端相关 1、unity工程添加Package 2、WebRTC选Version 3.0.0-pre.6，升级会报错 导入Samples
3、打开Broadcast场景 二、服务器相关 这里使用github上的源码，方便以后修改
1、下载https://github.com/Unity-Technologies/UnityRenderStreaming/archive/refs/tags/3.1.0-exp.7.zip 解压后使用WebApp文件夹
2、安装Node.js 下载地址https://nodejs.org/ 3、在WebApp目录执行 npm install npm run build npm run pack 目录下打包出webserver.exe
三、最后 运行webserver.exe
然后编辑器运行Broadcast场景
浏览器打开127.0.0.1
我的工程地址https://gitee.com/awnuxcvbn/UnityRenderStreaming.git
参考文章https://blog.csdn.net/qq_22955617/article/details/127052164
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22fe1f4e99e8088afb3a7a865f415f3/" rel="bookmark">
			AI&#43;金融：大模型引爆金融科技革命
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅供机构投资者使用
证券研究报告|行业深度研究报告
AI+金融：大模型引爆金融科技革命
“AI+应用”系列（二）
华西计算机团队
2023年7月28日
分析师：刘泽晶 联系人：刘波
SAC NO：S1120520020002 邮箱：liubo1@hx168.com.cn
邮箱：liuzj1@hx168.com.cn
请仔细阅读在本报告尾部的重要法律声明核心逻辑
 金融科技迎来强催化，AI+金融迎来发展良机
 根据新华社消息，中共中央政治局24日召开会议，分析研究当前经济形势，部署下半年经济工作。会议指出，要活跃资本市场，提振投资
者信心。金融科技行业迎来强催化。
 Al+金融更侧重于为传统行业的模式创新和流程再造提供新的思路和方法，从而催生新的商业模式，提高运营效率，带来整个产业的全面升
级。AI应用场景涵盖前中后台中的市场营销、产品设计、风险管控、客户服务、运营支持等。
 据艾瑞咨询统计测算，2021年AI+金融核心市场规模达到296亿元，带动相关产业规模677亿元，到2026年，核心市场规模达到666亿元，
CAGR为17.6%，带动相关产业规模1562亿元，CAGR为18.2%。
 金融行业数据、场景丰富，大模型走上金融大舞台
 我们认为，金融行业数据丰富且数据质量高，具备大模型训练的良好基础。同时，金融行业细分领域众多，且大量产品最终服务于C端用户，
大模型应用场景丰富。随着大模型与金融业务的融合，创新应用将层出不穷。
 金融行业数字化需求刚性，投入巨大，是大模型应用落地的大舞台：根据艾瑞咨询的数据，2022年，以银行、保险、证券为主的金融机构
技术资金投入预计将超过4000亿元。2022年中国银行与保险机构前沿科技采购支出将达到170亿元。
 相关行业已有大量应用案例：Bloomberg GPT、Morgan Stanley、Lemonade、苏黎世保险、度小满、瑞穗金融集团等。
 新一轮金融科技革命，产品&amp;商业模式均有望革新
 我们认为，随着大模型技术与业务的深度融合，头部金融科技企业有望实现产品和商业模式的革新，实现从产品+服务收费向SaaS订阅收
费、运营分润收费的转变。
 我们认为，金融科技细分领域众多，各细分领域龙头具备技术、行业Know-How等要素，与头部金融机构的长期合作关系有利于补齐数据、
场景等要素，相关产品有望率先落地。
 行业受益标的：
 我们认为，在各细分领域深耕多年，在AI领域早有布局，且积极拥抱大模型技术变革的公司具有先发优势，行业受益标的包括：同花顺、
指南针、恒生电子、财富趋势、新致软件、宇信科技、金证股份等。
 风险提示：1） AI技术发展不及预期；2）相关政策落地不及预期；3）中美博弈突发事件；4）AI伦理风险；5）市场系统性风险等。
1目录
01 金融科技迎来强催化，AI+金融迎来发展良机
02 数据、场景均丰富，大模型走上金融大舞台
03 新一轮金融科技革命，产品&amp;商业模式均有望革新
04 行业受益标的及风险提示
2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/140432846de8c0a386db0036665ce18a/" rel="bookmark">
			解决vim退格键无法使用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近遇到一个奇怪的问题，在容器linux环境下使用vim编辑器，发现某几台容器下的vim部分功能突然无法正常使用，比如在insert模式下按退格键不能正常删除字符。
经过查资料，终于找到该问题的解法~
解法 编辑vimrc文件（如果没有则创建）
vim ~/.vimrc 将以下行添加到文件顶部
set nocompatible 保存文件，重新进入vim测试，发现问题解决。
参考资料1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c37d897f00582f2c2e7bfe32c9e8be/" rel="bookmark">
			Java：表单生成excel文档 poi 通用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用java 写数据库应用的时候, 通常会生成各种报表，而这些报表可能会被导出为各种格式的文件，比如Excel文档，pdf 文档等等. 今天先做了一个生成Excel 文档的例子，主要解决以下问题：
1. 生成 Excel 文档.
2. 自动对生成的Excel 文档第一行标题栏设置成filter 过滤形式, 方便用户使用.
导入依赖： &lt;!--依赖的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; Excel转换通用类：
package com.kingbal.king.dmp; import org.apache.poi.hssf.usermodel.HSSFCellStyle; import org.apache.poi.hssf.usermodel.HSSFFont; import org.apache.poi.hssf.usermodel.HSSFSheet; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.hssf.util.HSSFColor; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.text.SimpleDateFormat; import java.util.Date; import java.util.List; /** * &lt;b&gt;Function: &lt;/b&gt; todo * * @program: ExcelUtil * @Package: com.kingbal.king.dmp * @author: dingcho * @date: 2023/12/30 * @version: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45c37d897f00582f2c2e7bfe32c9e8be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3463841753af8519da9cb5f420cfbcae/" rel="bookmark">
			el-upload 上传.pdf文件，并读取文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;el-upload class="upload-demo" :action="/file/upload/" accept=.pdf" name="upfile" :on-success=" (response, file, fileList) =&gt; { return handleImgSuccess(response, file, fileList) } "&gt; &lt;el-button size="small" type="primary"&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; &lt;div v-html="pdfContent"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import pdfjsLib from "pdfjs-dist"; export default { data() { return { pdfContent: "", }; }, methods: { handleImgSuccess(res, file) { console.log(res, file); const fileObj = file.raw; if (fileObj.type === "application/pdf") { const reader = new FileReader(); reader.onload = (e) =&gt; { const arrayBuffer = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3463841753af8519da9cb5f420cfbcae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f98f96ce8dfa7a2cfab57eb25f11b5/" rel="bookmark">
			MIT_线性代数笔记：第 22 讲 对角化和矩阵的幂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 对角化矩阵 Diagonalizing a matrix S−1AS = Λ矩阵的幂 Powers of A重特征值 Repeated eigenvalues差分方程 Difference equations u k + 1 u_{k+1} uk+1​=A u k u_k uk​斐波那契数列 Fibonacci sequence 本讲中将学习如何对角化含有 n 个线性无关特征向量的矩阵，以及对角化是怎样简化计算的。 对角化矩阵 Diagonalizing a matrix S−1AS = Λ 如果矩阵 A 具有 n 个线性无关的特征向量，将它们作为列向量可以组成一个可逆方阵 S，并且有：
这里的矩阵 Λ 为对角阵，它的非零元素就是矩阵 A 的特征值。因为矩阵 S 中的列向量线性无关，因此逆矩阵 S-1存在。在等式两侧左乘逆矩阵，得到 S-1AS=Λ。同样地，A=SΛS-1。
对于消元法而言，矩阵有 LU 分解，对于施密特正交法，矩阵有 QR 分解，而上面的推导是一种新的矩阵分解。
矩阵的幂 Powers of A 特征值给矩阵的幂计算提供了方法。
如果 Ax=λx，则有 A 2 A^2 A2x=λAx= λ 2 λ^2 λ2x。说明矩阵 A 2 A^2 A2 有着和 A 一样的特征向量，而特征值为 λ 2 λ^2 λ2。我们将写成对角化形式则有： A 2 A^2 A2=SΛ S − 1 S^{-1} S−1SΛ S − 1 S^{-1} S−1=S Λ 2 Λ^2 Λ2 S − 1 S^{-1} S−1。做相同的处理还可以得到： A k A^k Ak =S Λ k Λ^k Λk S − 1 S^{-1} S−1。这说明 A k A^k Ak 有着和 A 一样的特征向量，而特征值为 λ k λ^k λk。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f98f96ce8dfa7a2cfab57eb25f11b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3525b20b83a57d687401e124366c6f4f/" rel="bookmark">
			2024年 AI在供应链安全方面的应用浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年供应链安全的发展趋势主要包括以下几个方面：
数字化转型与技术创新： 随着供应链的数字化程度提升，企业将更加依赖先进技术来保障安全性。人工智能、区块链、物联网等技术的广泛应用将帮助企业提高供应链的可见性和反应速度。风险管理与合规性： 供应链安全将更加强调风险管理和合规性。企业将加强对供应商的审核，确保其符合相关法规，并采取更加主动的措施来应对潜在的安全威胁。人工智能应用： 人工智能在供应链安全中的应用将进一步增加。通过利用机器学习算法来分析大量数据，企业可以更好地识别潜在的安全威胁，并采取预防措施。透明度与可追溯性： 消费者对产品的透明度和可追溯性要求逐渐增加，因此企业将更加注重建立可追溯的供应链体系，以提高产品的质量和信誉。协作与信息共享： 供应链各方之间的协作与信息共享将变得更加密切。通过建立有效的沟通渠道和信息共享机制，可以更快速地应对潜在的安全威胁。 2024年的供应链安全发展趋势将更加注重技术创新、风险管理、人工智能应用以及协作与信息共享。这些趋势将有助于提升整个供应链体系的安全性和可靠性。那么，2023你如火如荼的AI在供应链安全方面有许多具体应用，大概有一下几个方面：
风险管理： AI可以通过分析大量数据来识别供应链中的潜在风险，包括地理风险、政治风险、天气影响等，帮助企业采取相应的风险管理措施。实时监测： AI系统能够实时监测供应链中的活动，识别异常情况并及时发出警报。这有助于迅速应对潜在问题，减少损失。预测性分析： 基于历史数据和趋势，AI可以进行预测性分析，帮助企业预测供应链中可能发生的问题，从而提前采取措施避免损失。货物跟踪： 利用物联网（IoT）和AI技术，可以实时跟踪货物在供应链中的位置和状态，提高货物运输的可视性和透明度。供应链网络优化： AI可以优化供应链网络，提高效率和降低成本。通过分析数据，AI可以提供优化建议，例如最佳的物流路径、库存水平等。识别欺诈： AI可以帮助识别供应链中的欺诈行为，包括虚假订单、伪造产品等，从而确保供应链的诚信性。合规性管理： AI系统可以监测和确保供应链活动符合法规和行业标准，降低合规风险。 总体而言，AI在供应链安全方面的应用有助于提高供应链的可靠性、透明度和效率，从而降低潜在的风险和损失。
（智能创作）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7657a40e61bcfab8f21890ebbf9629d/" rel="bookmark">
			el-upload 上传.doc(.docx)文件，并读取文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;el-upload class="upload-demo" :action="/file/upload/' name="upfile" :show-file-list="false" accept=".docx,.doc" :on-success="(response, file, fileList) =&gt; { return handleImgSuccess(response, file, fileList) } "&gt; &lt;el-button size="small" type="primary"&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; &lt;/template&gt; &lt;script&gt; import mammoth from "mammoth"; export default { data() { return { inputValue: "", }; }, methods: { handleImgSuccess(response, file, fileList) { const arrayBuffer = file.raw; mammoth .extractRawText({ arrayBuffer: arrayBuffer }) .then((result) =&gt; { const text = result.value; // 读取的 .doc 文件内容 console.log(text); }) .catch((error) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7657a40e61bcfab8f21890ebbf9629d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1fb71f6b5499825113cf000d478596/" rel="bookmark">
			微信小程序开发系列-12label组件使用理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序开发系列目录 《微信小程序开发系列-01创建一个最小的小程序项目》
《微信小程序开发系列-02注册小程序》
《微信小程序开发系列-03全局配置中的“window”和“tabBar”》
《微信小程序开发系列-04获取用户图像和昵称》
《微信小程序开发系列-05登录小程序》
《微信小程序开发系列-06事件》
《微信小程序开发系列-07组件》
《微信小程序开发系列-08自定义组件模版特性》
《微信小程序开发系列-09自定义组件样式特性》
《微信小程序开发系列-10组件间通信01》
《微信小程序开发系列-11组件间通信02》
文章目录 微信小程序开发系列目录前言checkboxcheckbox-groupwx:forLabel总结 前言 对于组件label的作用，看官方的文字描述，不知道到底是啥作用。本着“If you can’t explain it to a six year old, you don’t understand it yourself.”的原则，我还是想把这个组件弄明白并记录于本文中。
checkbox 多选项目。
属性类型默认值必填说明最低版本valuestring否checkbox标识，选中时触发checkbox-group的 change 事件，并携带 checkbox 的 value1.0.0disabledbooleanfalse否是否禁用1.0.0checkedbooleanfalse否当前是否选中，可用来设置默认选中1.0.0colorstring#09BB07否checkbox的颜色，同css的color1.0.0 checkbox-group 多项选择器，内部由多个checkbox组成。
属性类型默认值必填说明最低版本bindchangeEventHandle否checkbox-group中选中项发生改变时触发 change 事件，detail = {value:[选中的checkbox的value的数组]}1.0.0 checkbox必须和checkbox-group一起使用；当选中或取消checkbox-group中的checkbox时，会触发checkbox-group的change事件，在事件处理函数中会获取到所有checkbox的value。 从运行结果可以看出，只要点击一次checkbox，checkboxChange函数就会被调用；如果checkbox-group中只有要checkbox是“选中”状态，那么checkboxChange函数中就可以获取到checkbox的value值。如果都没有“选中”，则e.detail.value为空数组。
wx:for 在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。
默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item。
为了更好地动态显示多个checkbox，可以使用wx:for控制属性。
如上图所示示例中，产生了一个问题，为什么当我选中多个checkbox后，checkboxChange函数返回的e.detail.value数组中的元素总是只有一个。我想看到的情况应该是 每新增一个选中，value数组中的元素值就多一个水果名。似乎每次触发都是“一种独立事件”。
问题出在， wx:for写错了位置，上图中的逻辑是将checkbox-group进行列表渲染，因此每个checkbox确实是独立的，每个group一个box，而不是一个group多个box。
接下来，需要修改下代码，新增一个view容器来渲染checkbox和text。
OK，这次正常啦！
Label 用来改进表单组件的可用性。
使用for属性找到对应的id，或者将控件放在该标签下，当点击时，就会触发对应的控件。 for优先级高于内部控件，内部有多个控件的时候默认触发第一个控件。 目前可以绑定的控件有：button, checkbox, radio, switch, input。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1fb71f6b5499825113cf000d478596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b091061fbf54733ff87a57d1cc2c295c/" rel="bookmark">
			关于torch、Pytorch_lightning、torchvision版本的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # CUDA 11.3 pip install torch==1.11.0+cu113 torchvision==0.12.0+cu113 torchaudio==0.11.0 --extra-index-url https://download.pytorch.org/whl/cu113 安装lightning
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pytorch-lightning==1.7.6 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65b30060fd8559fb0f34aeb93138886/" rel="bookmark">
			C#使用纯OpenCvSharp部署yolov8-pose姿态识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【源码地址】 github地址：https://github.com/ultralytics/ultralytics
【算法介绍】
Yolov8-Pose算法是一种基于深度神经网络的目标检测算法，用于对人体姿势进行准确检测。该算法在Yolov8的基础上引入了姿势估计模块，通过联合检测和姿势估计的方式来实现准确的姿势检测。
Yolov8-Pose算法的基本思想是将姿势检测任务转化为多个关键点的检测任务。人体姿势可以看作是由多个关键点组成的，例如头部、肩膀、手肘、手腕等。Yolov8-Pose算法通过在Yolov8的基础上增加额外的关键点检测层，来实现对这些关键点的检测和定位。
Yolov8-Pose算法的网络结构是在Yolov3的基础上进行改进和优化得到的。它采用了Darknet作为主干网络，并在其上添加了一系列的卷积层、上采样层和连接层，以提取更丰富的特征信息。同时，为了实现人体姿态点的检测和估计，Yolov8-Pose在输出层上引入了关键点检测的任务分支。
通过以上原理，Yolov8-Pose算法能够在保持检测速度的同时，实现对人体姿势的准确检测，从而在人体姿态估计领域具有一定的应用价值。
【效果】
​
【部分实现代码】
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Diagnostics; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using OpenCvSharp; namespace FIRC { public partial class Form1 : Form { Mat src = new Mat(); Yolov8PoseManager ypm = new Yolov8PoseManager(); public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { OpenFileDialog openFileDialog = new OpenFileDialog(); openFileDialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65b30060fd8559fb0f34aeb93138886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117a8eb853bebdca30984f3a05db04f3/" rel="bookmark">
			前端八股文（HTML篇）二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.说一下web worker
2.iframe有哪些优点和缺点
3.label的作用是什么？如何使用？
4.script标签中defer和async的区别
5.Canvas和SVG的区别
6.head标签有什么作用，其中什么标签必不可少？
7.浏览器是如何对HTML5的离线储存资源进行管理和加载？
8.img的srcset属性的作用？
9.浏览器乱码的原因是什么？如何解决？
10.说一下 HTML5 drag API
1.说一下web worker 在HTML页面中，如果在执行脚本时，页面的状态时不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的js，独立于其他脚本，不会影响页面的性能。并且通过postMessage将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。
如何创建web worker：
检测浏览器对于web worker的支持性创建web worker文件（js，回传函数等）创建web worker对象 2.iframe有哪些优点和缺点 iframe元素会创建包含另外一个文档的内联框架（即行内框架）
优点：
用来加载速度较慢的内容（如广告）可以使脚本可以并行下载可以实现跨子域通信 缺点：
iframe会阻塞主页面的onload事件无法被一些搜索引擎识别会产生很多页面，不容易管理 3.label的作用是什么？如何使用？ label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。
使用方法1：
&lt;label for="mobile"&gt;Number:&lt;/label&gt; &lt;input type="text" id="mobile"/&gt; 使用方法2：
&lt;label&gt;Date:&lt;input type="text"/&gt;&lt;/label&gt; 4.script标签中defer和async的区别 如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。他不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。
下图可以直观的看出三者之间的区别：
其中蓝色代表js脚本网络加载事件，红色代表js脚本执行时间，绿色代表html解析时间。
defer和async属性都是去异步加载外部的js脚本文件，它们都不会阻塞页面的解析，其区别如下：
执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行时并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载时并行进行的，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。 5.Canvas和SVG的区别 1.SVG：SVG可缩放矢量图标是基于可扩展标记语言xml描述的2D图形的语言，SVG基于xml就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加JavaScript事件处理器。在SVG中，每个被绘制的图形均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形。
其特点如下：
不依赖分辨率支持事件处理器最适合带有大型渲染区域的应用程序复杂度高会减慢渲染速度不适合游戏应用‘ 2.Canvas：Canvas是画布，通过JavaScript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。
其特点如下：
依赖分辨率不支持事件处理器弱的文本渲染能力能够以.png或.jpg格式保存结果图像最适合图像密集型的游戏，其中的许多对象会被频繁重绘 注：矢量图，也称为面向对象的图像或绘制图像，在数学上定义为一系列由线连接的点。矢量挖金中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色，形状，轮廓，大小和屏幕位置等属性。
6.head标签有什么作用，其中什么标签必不可少？ head标签用于定义文档的头部，它是所有头部元素的容器。标签中的元素可以引用脚本，指示浏览器在哪里找到样式表，提供元信息等。
文档的头部描述了文档的各种属性和信息，包括文档的标题，在web中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。
下面这些标签可用在head部分：&lt;base&gt;,&lt;link&gt;,&lt;meta&gt;,&lt;script&gt;,&lt;style&gt;,&lt;title&gt;.
其中&lt;title&gt;定义文档的标题，它是head部分唯一必需的元素。
7.浏览器是如何对HTML5的离线储存资源进行管理和加载？ 在线的情况下：浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问页面，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器会直接使用离线存储的资源。 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/117a8eb853bebdca30984f3a05db04f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b2f6adf45edc1f039df8e1cd7260c9/" rel="bookmark">
			【SSL证书更换】：已拦截跨源请求：同源策略禁止读取位于 https://xxxxxx.top:8181/staff/login?xxx的远程资源（原因：CORS 请求未能成功）问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总览 1.问题出现：出现了CORS请求不能成功的问题，原因是因为 SSL 证书过期了。
2.在更换 前端 SSL 证书之后，问题并不能得到解决。
3.解决办法：必须同时更换后端的 SSL - tomcat 版本的证书。
一、SSL 证书准备 1.SSL 免费证书下载 首先去 阿里云 下载免费的 SSL证书 （下载 nginx 版本 和 tomcat 版本）
有3个月的（免费），也有12个月的（68元）。
2.txt 打开刚才下载的证书压缩包中的 SSL 的 nginx 文件 将 key 中的内容放到 KEY 中，将 PEM 中的内容放到 PEM 中
二、后端 SSL 证书更新 1.txt 打开刚才下载的证书压缩包中的 SSL 的 tomcat 目录 将 .pfx 文件保存好，我们要在后端中进行修改了。
2.打开后端，修改 application.yml 文件，并且把 新的 .pfx 文件放入 resources 目录 3.直接从 JAVA 项目 中开始运行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4196252f5bd995fcef9b1405cd0379/" rel="bookmark">
			题解 | #明明的随机数# C&#43;&#43;暴力解法 没有使用迭代器容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邮储发座谈会了
求问:华为24k是14a还是14b
offer比较（华为无线，美团，招银，建信金科，30所）
offer选择
决赛圈
Java学习路线总结
华子开奖
滴滴 网约车部门 测开实习面经
小丑来咯
春招时间线：银行and互联网大厂
滴滴测开实习一面
滴滴北京测开面经
学习
滴滴服务端测开
滴滴测试开发24届实习一面（凉）
年终总结：2023年总共冲了148次
华为-硬件工程师-硬件通用机考
题解 | #KiKi和酸奶#
#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(){ int n,h,m; whil
QT开发用的网络通信协议
QT网络通信协议 ├── TCP协议 │ ├── 面向连接的协议 │ ├── 三次握手过程 │ ├── 信息发送与接收 │ │ ├
题解 | #小乐乐找最大数#
#include&lt;stdio.h&gt;int main() { int a, max = 0; while (scanf("%d&amp;
QT开发的软件和其他软件怎么通信
QT开发的软件和其他软件之间的通信可以通过以下几种方式实现：使用共享内存（Shared Memory）：实现方式：QT提供了QSharedMemory类，可以用
题解 | #小乐乐找最大数#
#include&lt;stdio.h&gt;int main() { int a,b,c,d,x,y; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b4196252f5bd995fcef9b1405cd0379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19638aeff9f89a75aa4fcef647f872f3/" rel="bookmark">
			DataX部署及迁移操作说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataX安装部署 1、 DataX简介 DataX 是阿里巴巴开源的一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。
源码地址：https://github.com/alibaba/DataX
2、DataX架构原理 2.1 DataX设计理念 为了解决异构数据源同步问题，DataX将复杂的网状的同步链路变成了星型数据链路，DataX作为中间传输载体负责连接各种数据源。当需要接入一个新的数据源的时候，只需要将此数据源对接到DataX，便能跟已有的数据源做到无缝数据同步。
2.2 DataX框架设计 DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader/Writer插件，纳入到整个同步框架中。
2.3 DataX调度决策思路 举例来说，用户提交了一个DataX作业，并且配置了总的并发度为20，目的是对一个有100张分表的mysql数据源进行同步。DataX的调度决策思路是：
1）DataX Job根据分库分表切分策略，将同步工作分成100个Task。
2）根据配置的总的并发度20，以及每个Task Group的并发度5，DataX计算共需要分配4个TaskGroup。
3）4个TaskGroup平分100个Task，每一个TaskGroup负责运行25个Task。
3、DataX部署 1）下载DataX安装包并上传到qianyi-ecs的/data 下载地址：https://github.com/alibaba/DataX/tree/master
2）解压datax.tar.gz到/data [root@qianyi-ecs data]$ tar -zxvf datax_v202309.tar -C /data
3）自检，执行如下命令 [root@qianyi-ecs data]$ python /data/datax/bin/datax.py /data/datax/job/job.json
出现如下内容，则表明安装成功
…… 2021-10-12 21:51:12.335 [job-0] INFO JobContainer - 任务启动时刻 : 2021-10-12 21:51:02 任务结束时刻 : 2021-10-12 21:51:12 任务总计耗时 : 10s 任务平均流量 : 253.91KB/s 记录写入速度 : 10000rec/s 读出记录总数 : 100000 读写失败总数 : 0 4、DataX使用 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19638aeff9f89a75aa4fcef647f872f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6378f35cfa2416d71547dbc819102fde/" rel="bookmark">
			CSS-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识 CSS CSS：层叠样式表
引入方式 方式一 CSS代码，直接写在 HTML 的 style 标签里
&lt;style&gt; p { color:red; /* 颜色大小控制 */ font-size:30px; /* 字号大小 */ } &lt;/style&gt; 方式二 在 HTML 使用 link 标签引入
&lt;link rel="stylesheet" href="./test.css"&gt; rel 属性（了解） 1. rel 属性规定当前文档与被链接文档之间的关系 2. 只有 rel 属性的 "stylesheet" 值得到了所有浏览器的支持。其他值只得到了部分地支持 方式三 CSS代码，直接写在标签的 style 属性值里（不推荐）
&lt;div style="color:red; font-size:20px;"&gt; 这是div标签 &lt;/div&gt; 行内样式，配合 JavaScript 使用 CSS 注释 /* 这是注释，CSS代码 */ CSS 特性 继承性、层叠性、优先级
作用：简化代码 ( 定位问题 )，并解决问题
1.继承性： 子级默认继承父级的文章控制属性，当然，如果子级自己有则生效自己的样式，不继承。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6378f35cfa2416d71547dbc819102fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd031ad1026eb5aa74207123a200d174/" rel="bookmark">
			Python-扫雷游戏【附完整源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷游戏 《扫雷》是一款大众类的益智小游戏，游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子，同时避免踩雷，踩到一个雷即全盘皆输。这个游戏的玩法很简单，雷区中随机布置一定数量的地雷，玩家需要尽快找出所有不是地雷的方块，如果玩家翻开的方块有地雷，则游戏结束。
运行效果：
一：主程序： import cfg import sys import time import pygame from modules import * '''主函数''' def main(): # 游戏初始化 pygame.init() screen = pygame.display.set_mode(cfg.SCREENSIZE) pygame.display.set_caption('扫雷') # 导入所有图片 images = {} for key, value in cfg.IMAGE_PATHS.items(): if key in ['face_fail', 'face_normal', 'face_success']: image = pygame.image.load(value) images[key] = pygame.transform.smoothscale(image, (int(cfg.GRIDSIZE*1.25), int(cfg.GRIDSIZE*1.25))) else: image = pygame.image.load(value).convert() images[key] = pygame.transform.smoothscale(image, (cfg.GRIDSIZE, cfg.GRIDSIZE)) # 载入字体 font = pygame.font.Font(cfg.FONT_PATH, cfg.FONT_SIZE) # 导入并播放背景音乐 pygame.mixer.music.load(cfg.BGM_PATH) pygame.mixer.music.play(-1) # 实例化游戏地图 minesweeper_map = MinesweeperMap(cfg, images) position = (cfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd031ad1026eb5aa74207123a200d174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae66f70143453b1076582b171b7539fc/" rel="bookmark">
			宣传照（私密）勿转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		精美的海报通常都是由UI进行精心设计的，现在有100 件商品需要进行宣传推广，如果每个商品都出一张图显然是不合理的，且商品信息各异。因此需要通过代码的形式生成海报。对此，我也对我宣传一波，企图实现我一夜暴富的伟大宏图。
生成的海报放在最前面，扫描下方二维码，手机上更好的实时阅读小咸鱼的技术窝。
代码实现 需要的依赖
&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; 完整Java 代码 需要你准备一张背景图、封面图、二维码图、以及对应的文字描述，我这里全部搞成静态的了。各位织入自己的业务即可。用到的技术是 Graphics2D。我们使用的时候只需要知道三个概念就行。
x 坐标：横坐标y 坐标：纵坐标width：坐标点向右，的宽度height：坐标点向下的，高度 为了保证图片的美观性，你需要去向 ui 询问，字体的配色参数、图片的尺寸参数。然后进行排版。里面需要自己去理解一下，都是些数学加减法的计算。这里不过多 bb。本文海报用到的图片尺寸是 610*633 的。
public class ImageUtils { public static String createPoster(String content) throws Exception { if (content.length() &gt; 300) { content = StringUtils.substring(content, 0, 300) + "..."; } //封面 File petImg = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae66f70143453b1076582b171b7539fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c29df8c9670705981c70634c57c04c9/" rel="bookmark">
			生态系统服务构建生态安全格局中的实践技术应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生态安全是指生态系统的健康和完整情况。生态安全的内涵可以归纳为：一，保持生态系统活力和内外部组分、结构的稳定与持续性；二，维持生态系统生态功能的完整性；三，面临外来不利因素时，生态系统具有相当的抵抗性。这三方面实际是生态系统健康、服务功能和风险问题。当前构建指标研究仍处于不断探索与完善的阶段，模型和方法层出不穷，构建方法已从简单的层次分析和适宜性分析转变为复杂的生态过程动态模拟，而“源地识别—阻力面构建—廊道提取”的研究框架是构建生态安全格局的典型范式。本课程将从生态安全的内涵入手，讲解如何根据区域生态环境存在的实际问题，收集与研究相关的资料和研究成果及多类型、多时相遥感数据；如何清洗数据，对数据进行处理和信息挖掘识别影响生态环境安全的因素；讲解如何对5种关键的生态系统服务（水源涵养、土壤保持、防风固沙和生境质量、固碳量）进行定量评估，如何在评价结果基础上识别出能够保障区域生态安全的生态源地；如何根据研究区生态系统服务重要性构建基本阻力面，如何运用最小累积阻力等模型识别潜在生态廊道；如何构建生态安全格局，如何实施生态安全格局的优化策略，本课程将为开发建设生态城市、保障区域生态安全提供空间指引。
第一章、生态安全评价理论及方法介绍
一、生态安全评价简介
二、生态服务能力简介
三、生态安全格局构建研究方法简介
第二章、平台基础
一、ArcGIS Pro介绍
1.ArcGIS Pro简介
2.ArcGIS Pro基础
3.ArcGIS Pro数据编辑
4.ArcGIS Pro空间分析
5.模型构建器
6.ArcGIS Pro符号制作
7.ArcGIS Pro制图布局与出图
二、Python环境配置
1.Python软件下载与安装
2.程序编写与运行
3.Python代码书写规则
4.文件读写
文件对象、文本文件的读写、JSON文件读写、二进制文件读写、HDF文件读写、Excel文件读写、文件系统和路径操作
5.ArcPy简介
基本情况
利用ArcPy运行工具
工具运行环境
空间参照
6.访问和管理空间数据
对表格数据（table）、要素类（feature class）、栅格数据（raster）、数据集（dataset）的访问与管理
第三章、数据获取与清洗
一、数据获取：
数据主要包括土地利用数据、社会经济数据、基础地理信息数据、自然环境数据（地形、土壤以及气候数据）：
二、数据预处理（ArcGIS Pro及Python环境） 1.土地利用数据进行拼接、裁剪、重投影（桌面端与云计算）
2.将社会经济数据、植被指数数据进行裁剪、重投影及重采样处理（桌面端与云计算）
3.将基础地理信息数据进行拼接、投影转换，矢量数据栅格化
4.气象数据裁剪、重投影及重采样处理；站点数据提取及地统计分析
5.DEM数据投影变换和影像裁剪
数据清洗：去除重复数据、填补缺失值、处理异常值和转换数据格式等操作
第四章、基于USLE模型的土壤侵蚀评价
一、生态系统服务功能评估技术规范简介
二、生态系统服务功能评估的内容和流程、评估指标体系、评估方法等
水土保持功能主要与气候、土壤、地形和植被有关，主要考虑土壤可蚀性、地形、降雨等因子。
通用土壤流失方程(USLE)的计算公式如下：
A=R*K*L*S*（1-C）
式中：
A：任一坡耕地在特定的降雨、作物管理制度及所采用的水土保持措施下，单位面积年平均土壤流失量，t/ha
R：降雨侵蚀力因子，是单位降雨侵蚀指标，如果融雪径流显著，需要增加融雪因子，MJ*mm/(ha*h)
K：土壤可蚀性因子，标准小区上单位降雨侵蚀指标的土壤流失率
L：坡长因子；
S：坡度因子，等于其它条件相同时实际坡度与9%坡度相比土壤流失比值；由于L和S因子经常影响土壤流失，因此，称LS为地形因子，以示其综合效应；
C：植被覆盖和经营管理因子，等于其它条件相同时，特定植被和经营管理地块上的土壤流失与标准小区土壤流失之比；
第五章、基于风蚀修正模型的防风固沙功能评估
防风固沙是生态系统（如森林、草地等）通过其结构与过程减少由于风蚀所导致的土壤侵蚀的作用，是生态系统提供的重要调节服务之一。防风固沙功能主要与风速、降雨、温度、土壤、地形和植被等因素密切相关。以防风固沙量（潜在风蚀量与实际风蚀量的差值）作为生态系统防风固沙功能的评估指标。
式中：SR 为固沙量（t km-2 a-1）；SL 潜为潜在风力侵蚀量（t km-2 a1）；SL 为实际风力侵蚀量（t km-2 a-1）；QMAX 为最大转移量（kg/m)；Z 为 最大风蚀出现距离（m)，本次实验设定为 50m；WF 为气候因子（kg/m）；K'为 地表糙度因子；EF 为土壤可蚀因子；SCF 为土壤结皮因子；C 为植被覆盖因子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c29df8c9670705981c70634c57c04c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c61b1ba4d1784f1cdf0694722fbc08/" rel="bookmark">
			大白话IDE：入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是IDE？ IDE，即集成开发环境（Integrated Development Environment），是帮助程序员进行软件开发的应用程序。它通常包括代码编辑器、编译器、调试器和图形用户界面等工具。
为什么使用IDE？ 省时省力：写代码、查错、运行程序全都在一个地方搞定。
编码助手：IDE提供语法高亮、代码提示、AI自动完成等插件和功能，优雅的代码就是这样产生的。
Debug：内置的调试工具可以帮助快速定位和修复代码中的问题。
新手推荐：Visual Studio Code 插件生态系统：VS Code有一个庞大的插件生态系统，用户可以根据需要安装各种插件来扩展功能。
多语言支持：VS Code支持多种编程语言，如JavaScript、Python、C++、Java等，非常适合多语言开发者。Git集成：内置的Git支持使得版本控制变得简单易用。定制化和扩展性：用户可以自定义界面、快捷键等，满足个性化需求。轻量级且高效：VS Code相比其他IDE更轻量，启动和运行速度快。智能代码补全：通过IntelliSense功能，VS Code提供智能的代码补全、参数信息等。跨平台：支持Windows、macOS和Linux操作系统。 特别优势：学生免费 GitHub Copilot插件
GitHub Copilot：GitHub提供的AI编程助手，可以在VS Code中作为插件使用。它能够根据代码上下文自动生成代码片段和整个函数，极大地提高编码效率。
学生免费使用：可以用学生邮箱白嫖。
其他IDE选择 IntelliJ IDEA：适用于Java开发，功能全面，但相对较重。Eclipse：另一款适用于Java的IDE，功能强大，插件众多。PyCharm：专为Python开发设计，提供智能代码助手和代码分析功能。Xcode：苹果官方IDE，专为macOS和iOS应用开发。Vim：大学时期最爱 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a863853cd613aa3e0fb7f8570a1f58/" rel="bookmark">
			HTTPS是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS（全称：Hypertext Transfer Protocol Secure），是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。
HTTPS在HTTP的基础下加入SSL层，其安全基础是SSL。SSL层利用加密技术为传输的数据提供了加密保护，确保数据在传输过程中的安全。同时，通过SSL/TLS协议，HTTPS还提供了对网站服务器身份的认证，确保了数据来源的可靠性和准确性。
HTTPS的存在也不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间），这使得数据在传输过程中更加难以被窃取或篡改。
HTTPS被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。启用HTTPS加密连接的网站会在浏览器地址栏显示一个绿色的锁形图标，这有助于提升用户对网站的信任度，从而增加用户的粘性和转化率。
总的来说，HTTPS是一种提供加密保护和身份认证的通信协议，被广泛应用于保护互联网上的数据传输安全。
申请免费SSL证书升级成HTTPS协议 https://www.joyssl.com/certificate/select/free.html?nid=5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ccd1bcf37dfcd2ea5b564d80c05d89/" rel="bookmark">
			Flink实时电商数仓（十）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		common模块回顾 app BaseApp: 作为其他子模块中使用Flink - StreamAPI的父类，实现了StreamAPI中的通用逻辑，在其他子模块中只需编写关于数据处理的核心逻辑。BaseSQLApp: 作为其他子模块中使用Flink- SQLAPI的父类。在里面设置了使用SQL API的环境、并行度、检查点等固定逻辑。 bean：存放其他子模块中使用到的javaBean对象，因为如果一直使用jsonObject对象调用数据的话，需要使用类似getString("字段名")的方式，没有直接使用javaBean对象那么方便。constant 存储字符串常量为了保证一致性，如果某个常量修改时，只需在这里修改即可对整个项目进行修改 function DorisMapFunction：将javaBean对象转换为对应的json字符串对象，并且将驼峰式命名方式修改为蛇形命名方式。便于写入doris。 util DateFormateUtilFlinkSinkUtilFlinkSourceUtilHBaseUtilIkUtilJdbcUtilSQLUtil getUpsertKafakaSQL: 一定要声明主键，支持撤回流getDorisSinkSQL: 用于写入Doris dim层回顾 Flink-cdc监控mysql中的维度配置表将监控的数据流做成广播流将广播流和读取数据的主流进行connect主流数据根据广播流的配置信息进行分流，注意需要先提前缓存一次配置表信息达到动态拆分数据表的效果 dwd层FlinkSQL回顾 注意join时会将所有数据都存储到内存中，需要考虑设置TTL大表join小表时，可以考虑使用lookup join如果数据流有明确的先后关系时，考虑使用Interval join 在支付成功模块，由于订单详情表处理时已经存在撤回流，但支付成功模块也是使用left join方式调用订单详情数据，会导致产生两次撤回流。在后续dws层处理时，要注意对数据进行去重过滤。
dws层回顾 如何判断使用FlinkSQL还是StreamAPI 如果比较标准化, 比如简单的开窗聚合，一般使用FlinkSQL如果需要使用状态处理数据，比如判断是否为独立用户，使用StreamAPI 交易域sku粒度订单下单各窗口汇总 需求分析：从Kafka订单明细主题读取数据，过滤null数据并按照唯一键对数据去重，按照SKU维度分组，统计原始金额、活动减免金额、优惠券减免金额和订单金额，并关联维度信息，将数据写入Doris交易域SKU粒度下单各窗口汇总表
思路分析：
方案一：按照订单ID进行分组，根据业务逻辑设置定时器取最后一个数据进行发送方案二：将度量值存放到状态中，每次新数据到达时，将新的度量值减去状态中的度量值 具体实现
因为需要使用状态，故使用BaseApp; 设置端口号10029，并发度4，消费者组为类名，消费者主题名称为dwd订单详情读取dwd下单主题数据， stream.print()过滤清洗: 去掉null数据, stream.flatMap(new FlatMapFunction&lt;&gt;())ts: 水位线，不能为空；进行位数的修正，如果是10位的，使用 jsonObj.put("ts", ts*1000)id: keyby的关键字，不能为空sku_id: group by的粒度关键字，也不能为空 添加水位线 网络延迟5L添加数据的泛型，提取数据中的ts，作为水位线（注意观察ts的位数，需要为13位，毫秒级） 修正度量值，转换数据结构 使用id关键字进行分组使用process算子中的状态来进行处理stream.process(new KeyedProcessFunction&lt;&gt;)，返回值为对应的javabean对象在状态中存储上一次的度量值大小，只保存30秒在processElement()方法中获取状态中的度量值，使用前需要判空，如果为空设置为0，之后才能进行数值计算。创建对应的bean对象，度量值都减去状态中的度量值和更新状态中当前的度量值 分组开窗聚合 使用skuId进行keyby分组后使用window算子进行开窗,设置窗口时间，注意Time属于org.apache.flink.streaming.api.windowing.time.Time.seconds()使用reduce算子进行聚合计算, 聚合时需要累积所有度量值new ProcessWindowFunction()获取窗口信息, startTime, EndTime, curTime, 获取到后写入javaBean对象中 关联维度信息 先分组聚合再关联维度信息的原因：关联维度信息需要join操作，是很耗费性能的大操作。先聚合数据能大幅度减少数据量。启动HBase，查看对的sku_info表中是否存储着对应的维度信息获取外部连接，需要使用生命周期方法(open，close在整个算子执行过程中只运行一次);对应的关联维度信息，即RichMapFunction()在map方法中使用HBase的API读取表格数据，使用读取到的字段补全原本的信息 创建HBase的API：读取表格数据 get 获取table创建get对象调用get方法获取数据写入jsonObj 写出到Doris 维度关联优化 旁路缓存：独立缓存服务有（redis, memcache）.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ccd1bcf37dfcd2ea5b564d80c05d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40c5699ee9477870e674f6483aa0b04/" rel="bookmark">
			（node-red）pm2的日志管理及使用pm2-logrotate进行日志分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pm2的日志管理及使用pm2-logrotate进行日志分割 一、说明二、pm2-logrotate安装及配置2.1 安装2.2 配置2.3 停止 pm2-logrotate服务 一、说明 pm2的自带日志管理功能:
pm2的日志模块默认是每一个服务进程都分配两个默认的日志文件两个日志文件 (Linux: /root/.pm2/logs)
(Windows: C:Users\Administratorl\pm2\logs) ，一个错误记录 xxx-errot.log,
，一个正常记录 xxx-out.log。启动项目后，可以通过pm2 logs命令查看，此时屏幕上会同时输出error log和 实时 out log，同时会打印出日志文件的路径，类似:
但是pm2自带的日志功能是不支持自动分割的，这就会导致随之时间的推移，日志文件会越来越大，不但会影响性能，在后期排查问题的时候也会很麻烦，这时我们就可以使用pm2-logrotate插件来解决上面的问题。
pm2-logrotate插件
pm2-logrotate是一个Node.js进程管理器PM2的模块，主要用于增强pm2的日志管理功能。它可以根据日志文件的大小自动轮换日志文件。它可以用于防止日志文件过大，导致磁盘空间或性能问题。
使用pm2-logrotate，可以配置日志文件轮换的频率、每个日志文件的最大大小以及轮换后的日志文件应该存储在哪里。该模块还提供了在旋转日志文件之前压缩和截断旧日志文件的选项。
二、pm2-logrotate安装及配置 2.1 安装 执行安装命令：pm2 install pm2-logrotate
安装完成后模块列表，执行命令：pm2 list
2.2 配置 查看详细的配置，执行命令：pm2 conf pm2-logratate
设置配置属性，执行命令：pm2 set pm2-logrotate:属性名称 值 pm2-ogrotate可设置参数如下： max_size：默认10M，当一个文件的大小超过这个值时，它将会对文件进行分割。可以在最后指定单位，如10G\10M\10Kretain：保留日志文件数量，默认为30个文件日志，当文件数量超过时，自动清理前面的日志文件compress：是否启用 gzip 压缩处理日志文件，默认为falsedateFormat：日志文件名称格式，默认格式 YYYY-MM-DD_HH-mm-ss。如设置的日志文件名为 out.log，就会自动分割生成 out-YYYY-MM-DD_HH-mm-ss.log 的日志文件。rotateModule：是否把 pm2 本身的日志文件也进行分割，默认trueworkerInterval：检查日志大小的时间间隔，默认30秒，最小值为 1。rotateInterval：定时执行选择，默认每天午夜0 0 * * * ，（类似于 Linux 中的 cron 定时任务） 示例修改如下： # 设置日志文件最大的大小为10KB pm2 set pm2-logrotate:max_size 10K # 设置日志保留数量为10个 pm2 set pm2-logrotate:retain 10 # 设置日志文件名称格式 pm2 set pm2-logrotate:dateFormat "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40c5699ee9477870e674f6483aa0b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f78c75ad4be15eb173d00530008d326/" rel="bookmark">
			桌面天气预报软件 Weather Widget free mac特点介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Weather Widget free for Mac多种吸引人的小部件设计可供选择，可以随时了解天气！还可以在Dock和菜单栏中为您提供简短的天气预报或当前状况的概述。
Weather Widget free for Mac软件介绍
始终在桌面上使用时尚的天气小部件来随时了解天气！多种吸引人的小部件设计可供选择。
使用小部件可以为您提供天气概况，或者要获得更深入的天气预报，您可以打开详细的天气窗口。
Weather Widget free for Mac还可以在Dock和菜单栏中为您提供简短的天气预报或当前状况的概述。
苹果：Weather Widget free for Mac(时尚桌面天气预报) 5.1.0中文版
Win：EarthTime(世界时钟桌面)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a1a0f9645969277ac9a525440d2913/" rel="bookmark">
			C# visual studio COM创建及调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.visual studuio操作
1.1visual Studio创建类库项目ClassLibrary1。
1.1.1ClassLibrary1项目Class1.cs内容如下：
using System; using System.Collections.Generic; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; namespace ClassLibrary1 { [ComVisible(true)] [Guid("D8C1EAA7-C829-46EF-A42E-2C9130467DB4")] interface IClass1 { string Class1Property { get; set; } [DispId(1)] string Class1Function1(); [DispId(1)] void Class1Function2(string message); } [ComVisible(true)] [Guid("CB5F70B2-3F6C-4410-B5B8-BD9C97042396")] [ProgId("ClassLibrary1.Class1")]//通过这个调用该COM组件 public class Class1: IClass1 { public string Class1Property { get; set; } public string Class1Function1() { Console.WriteLine($"Function1"); return "Function1Result"; } public void Class1Function2(string message) { Console.WriteLine($"Function1:{message}"); } } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a1a0f9645969277ac9a525440d2913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7b628b6196892314add685c90139b4/" rel="bookmark">
			密码学安全攻击分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码学安全攻击一般可以分为以下几类：
无条件安全攻击（Unconditional Security Attacks）：这类攻击是指攻击者拥有无限的计算能力和存储空间，可以直接破解加密算法。无条件安全攻击通常被认为是不可能的，因为其需要攻击者拥有极其强大的计算能力和资源。
条件安全攻击（Conditional Security Attacks）：这类攻击是指攻击者只拥有有限的计算能力和存储空间，但利用特定的漏洞或弱点来破解加密算法。条件安全攻击包括以下几种形式：
密文攻击（Ciphertext-Only Attack）：攻击者只能获得加密数据，无法获取加密密钥或其他信息。明文攻击（Known-Plaintext Attack）：攻击者同时拥有明文和对应的密文，通过对比明文和密文的差异，进而推算出加密密钥。选择明文攻击（Chosen-Plaintext Attack）：攻击者可以选择特定的明文并获得对应的密文，通过多次尝试不同的明文，进而推算出加密密钥。选择密文攻击（Chosen-Ciphertext Attack）：攻击者可以选择特定的密文并获得对应的明文，通过对比不同的密文和明文之间的关系，进而推算出加密密钥。 边信道攻击（Side-Channel Attacks）：这类攻击是指攻击者通过侧面渠道获取加密信息，如电磁波、功耗、时钟频率等，从而推算出加密密钥。边信道攻击是一种相对隐蔽且高效的攻击方式，通常需要特定的硬件设备或技术来实施。
社会工程学攻击（Social Engineering Attacks）：这类攻击是指攻击者通过欺骗、诱骗、威胁等手段，获取加密密钥或其他敏感信息。社会工程学攻击通常需要攻击者具有一定的心理学和社交技巧，是一种相对难以预防和防御的攻击方式。
总之，在进行密码学安全设计时，需要综合考虑各种不同的攻击方式和安全要求，采用多层次的安全措施来保护数据的机密性、完整性和可用性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c8fd729ba31e1a6d76b2f305a08732/" rel="bookmark">
			三、C#面向对象编程（类与对象）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 是一种面向对象的编程语言，这意味着在 C# 中，我们主要与对象打交道，而对象是由类定义的。面向对象编程（OOP）是一种编程范式，它使用“对象”来设计软件和应用程序。以下是关于 C# 中类与对象的基本概念：
类（Class）：类是对象的模板或蓝图。它定义了对象的属性（字段）和方法。类定义了对象的数据和行为。例如： public class Person { public string Name { get; set; } public int Age { get; set; } public void Greet() { Console.WriteLine("Hello, my name is " + Name); } } 在这个例子中，Person 是一个类，它定义了一个人的姓名和年龄属性，以及一个问候方法。
2. 对象（Object）：对象是类的实例。它是类的一个具体实体。当我们创建一个类的实例时，我们得到一个对象。例如：
Person person1 = new Person(); // 创建一个 Person 类的实例 person1.Name = "Alice"; // 设置对象的属性 person1.Age = 25; // 设置对象的属性 person1.Greet(); // 调用对象的方法 在这个例子中，person1 是 Person 类的一个实例，也就是一个对象。我们通过这个对象来设置它的属性（如姓名和年龄）并调用它的方法（如问候）。
3. 封装（Encapsulation）：封装是面向对象编程的三大基本特性之一。它指的是隐藏对象的内部状态并防止直接访问。我们通过访问器（getter）和设置器（setter）来控制对类中字段的访问。在上面的 Person 类中，Name 和 Age 字段就是封装的例子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c8fd729ba31e1a6d76b2f305a08732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75e0a31b226c7c672b072600c4dfef4/" rel="bookmark">
			【SpringBoot】文件上传到阿里云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;form action="/upload" method="post" enctype="multipart/form-data"&gt; 头像：&lt;input type="file" name="image"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; package com.heo.utils; import com.aliyun.oss.ClientException; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import com.aliyun.oss.OSSException; import com.aliyun.oss.model.PutObjectRequest; import com.aliyun.oss.model.PutObjectResult; import java.io.FileInputStream; import java.io.InputStream; public class AliOssUtil { // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。 private static final String ENDPOINT = "https://oss-cn-beijing.aliyuncs.com"; // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。 //EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider(); private static final String ACCESS_KEY_ID = "xxxxx"; // 替换成自己的ACCESS_KEY_ID private static final String ACCESS_KEY_SECRET = "xxxxx"; // 替换成自己的ACCESS_KEY_SECRET // 填写Bucket名称，例如examplebucket。 private static final String BUCKET_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75e0a31b226c7c672b072600c4dfef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f7223e36a2d0350f6b735cf6ca2fb5/" rel="bookmark">
			Python爬虫——使用代理IP池维护虚拟用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、什么是代理IP池？
二、爬取代理IP
三、验证代理IP的可用性
四、维护代理IP池
五、使用代理IP池进行爬取
六、总结
前言 在进行Web爬取时，使用代理IP是一种常见的策略，它可以帮助我们隐藏真实IP地址，绕过网站的访问限制，提高爬取效率。本文将介绍如何使用代理IP池维护虚拟用户，以在爬取过程中保持匿名性和稳定性。
一、什么是代理IP池？ 代理IP池是一个包含多个代理IP的集合。这些代理IP通常是从公开或付费的代理IP供应商那里获取的，也可以通过自己搭建代理服务器来获取。代理IP池可以提供多个不同的IP地址，用于隐藏真实IP，避免被网站封禁或限制访问。
二、爬取代理IP 首先，我们需要从代理IP供应商或其他可靠的来源中获取代理IP。这些代理IP通常以文本格式提供，每行一个代理IP，格式如下：
IP地址:端口 我们可以使用Python中的requests库来发送HTTP请求获取代理IP列表，并将其保存到本地文件中。以下是一个获取代理IP列表的示例代码：
import requests def get_proxy_ips(): url = 'http://example.com/proxy_ips.txt' # 代理IP列表文件的URL response = requests.get(url) proxy_ips = response.text.split('\n') return proxy_ips 三、验证代理IP的可用性 获取到代理IP列表后，我们需要验证这些代理IP的可用性。我们可以使用requests库来发送带有代理IP的请求，并检查响应状态码来确定是否可用。以下是一个验证代理IP可用性的示例代码：
import requests def check_proxy_ip(proxy_ip): url = 'http://example.com' # 需要访问的URL proxies = { 'http': 'http://' + proxy_ip, 'https': 'https://' + proxy_ip } try: response = requests.get(url, proxies=proxies, timeout=10) if response.status_code == 200: return True else: return False except: return False 四、维护代理IP池 在获取和验证代理IP之后，我们需要维护一个代理IP池，以便在爬取过程中动态地切换代理IP。我们可以使用Python中的列表或队列来实现代理IP池。以下是一个简单的代理IP池实现示例代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f7223e36a2d0350f6b735cf6ca2fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48dc1079c75532dc8d33604a8f26fd3/" rel="bookmark">
			二、C#基础语法（ 委托与事件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		委托（Delegate）
委托是一种类型安全的函数指针，它可以引用具有相同签名的方法。委托可以看作是方法的类型，它定义了一种类型，该类型的对象可以引用任何具有相同签名的方法。
委托的声明使用 delegate 关键字，后跟委托的返回类型和参数列表。例如：
public delegate int MyDelegate(int x, int y); 这个声明定义了一个名为 MyDelegate 的委托，它可以引用一个返回类型为 int 并且接受两个 int 参数的方法。
要使用委托，需要先定义一个方法，然后将其分配给委托变量。例如：
public int Add(int x, int y) { return x + y; } MyDelegate del = new MyDelegate(Add); 这里将 Add 方法分配给了 MyDelegate 类型的委托变量 del。现在，del 可以被用来调用 Add 方法：
int result = del(1, 2); // result 的值为 3 事件（Event）
事件是委托的特殊类型，它允许外部类向内部类发送消息。事件使用 event 关键字声明，可以看作是委托的成员变量。事件可以被订阅和取消订阅，当事件被触发时，所有订阅了该事件的委托都会被调用。
以下是声明和使用事件的示例：
public class MyClass { // 声明一个事件 public event EventHandler MyEvent; // 触发事件的方法 protected virtual void OnMyEvent() { MyEvent?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c48dc1079c75532dc8d33604a8f26fd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd11b821dff31207cbeba5215b3a616e/" rel="bookmark">
			k8s的声明式资源管理（yaml文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、声明式管理的特点 （1）适合对资源的修改操作 （2）声明式管理依赖于yaml文件，所有的内容都在yaml文件当中 （3）编辑好的yaml文件，还是要依靠陈述式的命令发布到k8s集群当中 kubectl create 只能创建，不能更新，从指定的yaml文件中读取配置，创建服务，不能更新
kubectl apply -f
（使用最多）
既可以创建资源对象，也可以更新资源对象，如果yaml文件更改了，apply可以直接更新资源对象
kubectl delete -f
删除yaml文件中声明的资源对象（声明deployment、pod、service）
2、生成yaml文件 （1）手动输入 （2）可以根据已有的资源直接生成 修改yaml文件：kubectl edit deployment nginx
查看yaml文件：kubectl get deployments.apps nginx -o yaml
导出yaml文件：kubectl get deployments.apps nginx -o yaml &gt; /opt/test.yaml
3、修改yaml文件（基于已有的资源生成yaml） （1）基于已有的资源生成yaml：kubectl get deployments.apps nginx -o yaml &gt; /opt/test.yaml （2）修改，重新创建更新资源对象：kubectl apply -f test.yaml --force 4、常见的yaml文件 （1）deployment的yaml文件（daemonset、statefulset） （2）service的yaml文件 （3）不基于控制器的pod的yaml文件 5、k8s中支持两种声明式的资源管理方式 （1）yaml格式：用于配置和管理资源对象 （2）json格式：主要用于在api接口之间消息的传递 6、配置deployment的yaml文件（daemonset、statefulset） （1）kubectl explain deployment （2）kubectl explain service/kubectl explain pod （3）配置deployment的yaml文件 ①创建deployment的yaml文件 ②kubectl apply -f nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd11b821dff31207cbeba5215b3a616e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e014262211a70d467c28fec187042d/" rel="bookmark">
			Danil Pristupov Fork(强大而易用的Git客户端) for Mac/Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今软件开发领域，团队协作和版本控制是非常重要的方面。在这个过程中，Git成为了最受欢迎的版本控制工具之一。然而，对于Git的使用，一个好的客户端是至关重要的。
今天，我们要为大家介绍一款强大而易用的Git客户端——Danil Pristupov Fork。它不仅提供了基本的Git功能，还额外提供了一些独特的特性，帮助团队在开发过程中更高效地协作。
首先，Danil Pristupov Fork具有直观的用户界面，使得Git操作变得简单而直观。无论是新手还是有经验的开发者，都可以轻松掌握它的使用。此外，它还支持多个Git仓库的管理，让您可以同时处理多个项目。
其次，Danil Pristupov Fork提供了一些强大的协作工具，如分支管理和合并请求。您可以轻松地创建、切换和合并分支，方便地与团队成员进行协作。合并请求功能使得代码审查变得更加高效，团队成员可以轻松地评论和讨论代码的更改。
此外，Danil Pristupov Fork还提供了强大的搜索功能，让您可以快速找到特定的代码片段或文件。无论您在哪个分支上工作，只需几秒钟就能找到所需的代码，提高了工作效率。
最后，Danil Pristupov Fork支持跨平台使用，无论您是使用Windows、Mac还是Linux系统，都可以方便地使用它。此外，它还与其他常用的开发工具，如Jira和Slack等，集成，进一步提高了团队协作效率。
总结来说，Danil Pristupov Fork是一款强大而易用的Git客户端，为团队提供了高效的协作工具和直观的用户界面。无论你是初学者还是有经验的开发者，它都将成为你的得力助手。试试Danil Pristupov Fork，提升你的团队协作效率吧！
Mac安装：Fork for Mac(Git客户端) v1.0.93最新版
Win安装：Danil Pristupov Fork(Git客户端)1.88.2 激活版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2133263deda7670f5db2c3060be30a7/" rel="bookmark">
			CSS animation动画和关键帧实现轮播图效果HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS animation动画和关键帧实现轮播图效果HTML 这轮播图效果使用h5和css3实现效果，不需要js控制，但是其中的缺点就是不能使用鼠标进行切换效果。
具有代码如下 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;CSS animation动画和关键帧实现轮播图效果&lt;/title&gt; &lt;style type="text/css"&gt; * { margin: 0; padding: 0; } #contianer { width: 800px; height: 500px; overflow: hidden; position: relative; margin: 0 auto; } ul { width: 4000px; position: absolute; animation: animationContent 10s infinite normal; list-style: none; } li { float: left; position: relative; } li&gt;img { width: 800px; height: 500px; } li .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2133263deda7670f5db2c3060be30a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dad658ef323a79679e1012683521050/" rel="bookmark">
			【Java】SpringBoot整合xxl-job学习使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍作用如何使用下载项目中央仓库地址环境调度中心初始化“调度数据库”配置部署“调度中心”部署项目调度中心集群（可选）其他：Docker 镜像方式搭建调度中心配置部署“执行器项目” 执行器maven依赖执行器配置执行器组件配置执行器集群（可选） 执行效果编写业务代码新建调度规则启动一次启动 细说策略路由策略 总结总结 介绍 Xxl-Job是一款优秀的开源调度平台，用于管理和调度各种类型的任务，报告定时任务、分布式任务。
作用 分布式任务调度：XXL-JOB允许您在分布式环境中调度任务，这些任务可以在不同的节点上执行。它通过分布式协调和管理任务的执行，确保任务按计划运行。
Web界面：XXL-JOB提供了一个易于使用的Web界面，用于管理任务、查看任务执行日志、监控任务状态等。用户可以通过Web界面方便地创建、编辑和删除任务。
任务类型：XXL-JOB支持多种任务类型，包括定时任务（Cron表达式）、Bean任务（Java类方法）、分片任务（适用于数据分片处理）、流程任务（执行多个任务步骤的工作流程）等。
动态任务调度：XXL-JOB允许在运行时动态添加、修改和删除任务，而无需停止整个应用程序。这使得任务调度非常灵活。
任务依赖关系：您可以定义任务之间的依赖关系，确保某个任务在另一个任务成功执行后才能运行。
任务执行器：任务可以在不同的执行器上运行，例如Java、Shell、Python等。这样可以根据任务的类型和需求选择合适的执行器。
分片任务支持：XXL-JOB提供了分片任务的支持，允许将大任务分成多个小任务，每个小任务在不同的节点上并行执行，从而提高任务的执行效率。
任务日志：任务执行的日志可以在Web界面中查看，帮助用户跟踪任务的执行情况，排查问题。
报警和通知：XXL-JOB支持任务执行失败时发送报警通知，以及成功或失败后发送通知邮件。
权限管理：XXL-JOB提供了角色和权限管理功能，可以限制用户对任务调度的访问和操作。
历史任务记录：平台会保留任务执行的历史记录，用户可以随时查看历史任务的状态和日志。
集成和扩展性：XXL-JOB可以与Spring、Spring Boot、Quartz等框架集成，并提供了RESTful API，以便与其他系统进行集成。
高可用性和容错性：XXL-JOB的分布式架构支持高可用性和容错性，当某个节点出现故障时，任务可以在其他可用节点上执行。
开源和社区支持：XXL-JOB是一个开源项目，拥有活跃的社区支持，用户可以参与贡献和获取帮助。
如何使用 下载项目 可以科学上网的可以去github上clone项目，我这里是用的国内的码云进行下载项目。
我们可以从目录结构可以看出有以下三个项目子模块。
xxl-job-admin: 这个是xxl-job调度中心，这里我们不得不提一下，xxl-job其实本质是一个调度中心+执行器组成的一个框架。xxl-job本身不关注具体业务，它只负责调度。执行器启动之后要注册到调度中心，由调度中心配置具体的动作最后通信到指定的执行器上去执行具体的Handler。所以这里我们得把xxl-job-admin项目配置好启动起来，相当于一个中台了。
xxl-job-core: 这个应该就是xxl-job的核心源码，后续直接使用依赖直接注入就可以。要么你也可以打包，maven中央仓库应该有这个打包好的。
xxl-job-executor-samples:这个是xxl-job的执行样例，可以看这个上面的例子来实践，告诉你客户端的具体代码如何去写，然后调度中心就可以执行到具体的业务代码上。
中央仓库地址 &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;${最新稳定版本}&lt;/version&gt; &lt;/dependency&gt; 这里是用的最新的2.4.0
环境 Maven3+Jdk1.8+Mysql5.7+ 调度中心 初始化“调度数据库” 请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。
“调度数据库初始化SQL脚本” 位置为:
/xxl-job/doc/db/tables_xxl_job.sql 调度中心支持集群部署，集群情况下各节点务必连接同一个mysql实例;
如果mysql做主从,调度中心集群节点务必强制走主库;
配置部署“调度中心” 调度中心配置文件地址：
/xxl-job/xxl-job-admin/src/main/resources/application.properties 调度中心配置内容说明：
### 调度中心JDBC链接：链接地址请保持和 2.1章节 所创建的调度数据库的地址一致 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai spring.datasource.username=root spring.datasource.password=root_pwd spring.datasource.driver-class-name=com.mysql.jdbc.Driver ### 报警邮箱 spring.mail.host=smtp.qq.com spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dad658ef323a79679e1012683521050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352932e22c1b8771746e79983ebe423d/" rel="bookmark">
			vs code导入excel文件并且解析excel文件数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实习工作需要通过vs code导入excel文件并且解析excel文件数据，学习整理了一下相关方法分享给大家^_^
VS Code 中导入和解析 Excel 文件 要在 VS Code 中导入和解析 Excel 文件，你可以使用一些库和扩展来帮助你完成这个任务。以下是一种常用的方法：
安装必要的库和扩展：
安装 pandas 库：在终端窗口中运行 pip install pandas 命令。安装 openpyxl 库：在终端窗口中运行 pip install openpyxl 命令。在 VS Code 中安装 Python 扩展。 创建一个新的 Python 文件并导入所需的库：
import pandas as pd 使用 pandas 库加载 Excel 文件：
df = pd.read_excel('path/to/your/file.xlsx') 请将 path/to/your/file.xlsx 替换为你的 Excel 文件的实际路径。
解析 Excel 文件数据：
# 显示 Excel 文件的前几行数据 print(df.head()) # 访问特定的列 column_data = df['column_name'] # 迭代遍历每一行数据 for index, row in df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/352932e22c1b8771746e79983ebe423d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ae6bb8cdb5714c0644d6f166f8b25c2/" rel="bookmark">
			鸿蒙OpenHarmony开发实战-0开始做游戏渲染引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先实现了一个通用的画廊组件来作为练手项目，它主要使用了四个基础组件和容器组件：
我们放置一个按钮来触发 showGallery 方法，该方法控制 panel 弹出式组件的显示和隐藏，这里的 div 和 button 标签就是 hml 内置的组件，跟我们平常写 html 很相似，它支持我们大部分的常规属性如 id ，class 和 type 等，方便我们用来设置组件基本标识和外观特征显示。
&lt;div class="btn-div"&gt; &lt;button type="capsule" value="Click Here" onclick="showGallery"&gt;&lt;/button&gt; &lt;/div&gt; 然后我们 panel 组件中放置可变更的画廊内容展示窗口，并让 mode 和 src 变成可设置的变量，这样画廊组件就能根据模式让画廊组件显示不同的形态，根据传入的图片地址显示不同的图片内容，这里的语法跟微信小程序很和 Vue 框架相似，都可以使用 Mustache 语法来控制属性值。
&lt;panel id="gallery" class="gallery" type="foldable" mode="{{modeFlag}}}" onsizechange="changeMode" &gt; &lt;div class="panel-div" onclick="closeGallery"&gt; &lt;image class="panel-image" onclick="closeGallery" src="{{galleryUrl}}}"&gt;&lt;/image&gt; &lt;button class="panel-circle" onclick="closeGallery" type="circle" icon="/common/images/close.svg" &gt;&lt;/button&gt; &lt;/div&gt; &lt;/panel&gt; 实现完视图和布局之后，我们就可以在同级目录下 index.js 中补充画廊组件的逻辑，由于支持 ES6 语法，我们写的也很舒服很高效，这里的 data 是画廊组件的数据模型，类型可以是对象或者函数，如果类型是函数，返回值必须是对象，注意属性名不能以 $ 或 _ 开头，不要使用保留字，我们在这里给 modeFlag 和 galleryUrl 设置默认值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ae6bb8cdb5714c0644d6f166f8b25c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c047bb6d8bf4f173e4a05b18e597691e/" rel="bookmark">
			openJDK下找不到jar命令（jar command is not found）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文官网地址：How can I get the jar command? - Red Hat Customer Portal
我们在准备服务器环境的时候一般喜欢删除掉openJDK，然后重新下载配置oracleJDK，并且配置相关的环境变量。但是其实有些时候openJDK也能满足我们的一些要求了，这个时候就不需要再去安装oracleJDK。我就是在这个环境下，执行jar命名报错找不到这个命令：jar command is not found。
究其原因是
jar命名是java-XXX-openjdk-devel这个包提供的。
“jar command is provided by java-XXX-openjdk-devel package”
而java-XXX-openjdk这个包，并不依赖于java-XXX-openjdk-devel，所以默认安装的openjdk，可能并没有包含devel包，导致jar命令找不到。
“java-XXX-openjdk-devel package is not required by the OpenJDK packages in dependency relationship”
# yum deplist java-1.*.0-openjdk | grep openjdk-devel &lt;no output&gt; 所以为了修复这个问题，只需要查看当前的openjdk的安全信息，并且安装相同版本的devel包就可以了。
Check current installed version of OpenJDK
# rpm -qa | grep openjdk java-1.8.0-openjdk-headless-1.8.0.252.b09-3.el8_2.x86_64 &lt;----==== 1.8.0.252.b09-3.el8_2 java-1.8.0-openjdk-1.8.0.252.b09-3.el8_2.x86_64 &lt;----==== 1.8.0.252.b09-3.el8_2 Install same version of java-XXX-openjdk-devel as above
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c047bb6d8bf4f173e4a05b18e597691e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/">«</a>
	<span class="pagination__item pagination__item--current">2/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/3/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>