<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f8ca320fa97a180d462eca2babfd55/" rel="bookmark">
			宏集方案 | 物联网HMI的关键驱动力—SCADA级功能库和控件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：宏集科技 工业物联网 宏集方案 | 物联网HMI的关键驱动力—SCADA级功能库和控件库
原文链接：https://mp.weixin.qq.com/s/UEPtpTehdbFrw3MUCnuR2A
欢迎关注虹科，为您提供最新资讯！
01 前言 在这个数字化时代，物联网HMI已成为连接人与设备之间的关键纽带，为用户提供直观、智能的交互体验，背后强大的关键驱动力扮演着至关重要的角色，其中SCADA级功能库和控件库的引入成为了物联网HMI设计和开发的核心要素。
SCADA级功能库为物联网HMI带来了出色的数据可视化和边缘计算能力，能够实现对复杂系统和设备的实时监测与控制，协助用户快速制定和执行生产决策；SCADA级控件库为物联网HMI提供了丰富的交互元素和可视化控件，创建出直观、个性化的可视化界面，满足不同应用场景的需求，提供更好的用户体验。
关键驱动力的引入不仅提升了物联网HMI的功能性，也帮助企业加快智能化生产和数字化转型的进程。本文将重点介绍宏集物联网HMI的关键驱动力及其在实际应用中的核心价值。
02 宏集物联网HMI解决方案 01 一站式解决方案 凭借着强大的功能库和控件库，宏集物联网HMI为用户提供从底层设备到云端的一站式解决方案，帮助用户构建设备的全局连接，消除信息孤岛，实现企业数据的互联互通。
宏集一站式物联网HMI解决方案系统框架图如下所示：
02 SCADA级功能库 海量数据标签和通讯协议
宏集物联网HMI支持1万点基础数据标签或者基于客户需求的特定标签点数，200+通讯协议，包括OPC UA、Modbus、MQTT和西门子、欧姆龙、AB、三菱、施耐德、倍福、基恩士等主流PLC协议，支持批量导入PLC设备标签文件，减少项目的开发时间;最多同时运行8种通讯协议，用户可以根据需求增减协议驱动。
此外，用户无需选购协议包和标签点数包，一次授权，上述所有标签点数和通讯协议都可使用，无需复购，帮助企业规避由于产线升级引起的原有通讯协议/标签点数不足带来的产品复购风险，以及由于企业规划需要预留足够的通讯协议/标签点数带来的成本浪费风险。
数据可视化
宏集物联网HMI支持趋势、报警及邮件通知、报表、配方、多语言、调度器、数据映射、审计追踪及电子签名、用户及权限管理等功能，结合功能专属控件，用户只需简单配置功能参数即可高效实现设备及系统数据的监测和控制。
百种宏指令
宏集物联网HMI提供百种便捷宏指令，包括页面加载、数据库增删改查、报表打印、邮件通知、用户管理和FTP上传/下载等指令，用户可以直接将指令链接到按钮等控件，便可快速实现实际项目所需的功能操作。
边缘计算
宏集物联网HMI支持运算公式功能，用户可以使用数据运算符、逻辑运算符、比较运算符和字符串运算符等运算符完成基本的数据运算。
此外，宏集物联网HMI支持JavaScript编程语言，用户可以编写JavaScript脚本实现诸如设备OEE/KPI分析、设备故障时间/次数统计、数据断点续传、读写CSV文件数据、数据库增删改查以及其他用户定制化功能，实现边缘侧的数据存储、分析和处理，减小主服务器的算力负载。同时，宏集物联网HMI提供JavaScript分析器开发工具，加快复杂项目的分析速度。
远程监控
宏集物联网HMI内置Web/VNC/SSH/FTP服务器，用户可以通过Web浏览器(PC/平板/手机)和VNC客户端即可实现局域网内设备的远程监控。
PLC &amp; HMI一体机
宏集物联网HMI内部集成CODESYS V3 PLC Runtime，支持Modbus、Profinet、EtherCAT、EtherNet/IP、J1939等现场总线，结合宏集本地/远程IO模块可作为PLC &amp; HMI一体机使用，帮助用户实现现场IO数据的采集和控制。
OT与IT融和
宏集物联网HMI支持OPC UA、MQTT等协议，可以将采集到的设备数据上传到用户管理系统(如SCADA/MES系统)，或者云平台(如阿里云/华为云/AWS)，实现企业数据的统筹管理。另外，宏集物联网HMI提供SQL数据库接口，支持将数据存储到MySQL、SQL Server、PostgreSQL和支持ODBC接口的数据库，用于后续历史数据的分析和处理。
Corvina云平台
宏集物联网HMI提供配套Corvina云平台，支持Dashboard、VPN、报警及通知、审计追踪、用户管理等功能，帮助用户实现底层设备数据的上云和云端的数据可视化，以及PLC设备的远程管理和维护，提高技术人员的工作效率，减少人员工作成本。
项目安全
宏集物联网HMI支持项目加密，用户可以自定义项目密码，一旦项目文件被加密，其他用户无法打开和运行项目工程。
与此同时，宏集物联网HMI支持通过x.509证书为项目签名，保护设备的正常运行，防止用户随意更改设备当前的运行程序。
03 SCADA级控件库 宏集物联网HMI预置2000+现代风格控件库，包括数字/文本/按钮/开关等基本控件，网格/选项栏/表格/仪表盘等智能控件，警报/趋势/审计追踪等专属功能控件以及IP摄像头/堆栈/二维码等特殊控件，为用户提供了丰富的控件，使得用户创建出直观、个性化的可视化界面。同时，结合拖拽式页面组态，可以极大程度地加快用户开发速度，快速实现项目落地。
03 总结 凭借两大关键驱动力——SCADA级功能库和控件库，宏集物联网HMI解决方案为用户带来了卓越的交互体验和智能控制能力，使得用户能够定制直观、个性化的可视化界面，高效实现设备数据的采集、边缘计算和实时监控，为企业数字数字化转型提供从底层设备到云端的一站式解决方案，推动企业的智能化生产。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a385dc6ef2069c716a0305b8779223ab/" rel="bookmark">
			信号与线性系统翻转课堂笔记11——连续LTI系统频域分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号与线性系统翻转课堂笔记11——连续LTI系统频域分析 The Flipped Classroom11 of Signals and Linear Systems 对应教材：《信号与线性系统分析（第五版）》高等教育出版社，吴大正著
一、要点 （1，重点）LTI连续系统频率响应的概念及其物理含义，理解滤波器的概念及其作用；
（2，重点）熟练掌握LTI系统频率响应与其他系统模型之间的相互转换；
（3）基于频域分析的方法，求LTI连续系统的零状态响应（含周期和非周期激励信号）；
（4）无失真传输的概念，信号通过线性系统不失真的条件；
（5）了解理想低通滤波器及其冲激响应和阶跃响应的特点。
二、问题与解答 1、 将一个信号输入到系统，并得到相应输出信号的过程，就是对信号的处理。根据系统频率响应的物理含义，结合教材例题4.8-1，从频域的角度讨论：如果用一个LTI系统来处理信号，其实质是什么（与输入信号相比，处理的结果即输出信号的频率、幅度、相位等发生了什么变化，这些变化是由系统的什么特性决定的）？
2、根据预备训练二的内容，讨论：①从频域的角度来看，预备训练中给出的RC电路是一种什么类型（低通、高通、带通、带阻）的滤波器（可参考课件141页的幅频响应曲线来回答）？如果想利用一个电阻和一个电容来构建一个高通滤波器，电路应该如何连接？②RLC电路处于过阻尼状态时，是一种什么类型的滤波器？③RLC电路处于欠阻尼状态时，又属于什么类型的滤波器？
3、
4、
5、
6、
1、系统的频率响应 将一个信号输入到系统，并得到相应输出信号的过程，就是对信号的处理。根据系统频率响应的物理含义，结合教材例题4.8-1，从频域的角度讨论：如果用一个LTI系统来处理信号，其实质是什么（与输入信号相比，处理的结果即输出信号的频率、幅度、相位等发生了什么变化，这些变化是由系统的什么特性决定的）？
系统频率响应的物理含义：是LTI系统的一种系统模型，是系统冲激响应的h(t)的傅里叶变换。
实质：
2、RC/RLC电路构建滤波器 根据预备训练二的内容，讨论：①从频域的角度来看，预备训练中给出的RC电路是一种什么类型（低通、高通、带通、带阻）的滤波器（可参考课件141页的幅频响应曲线来回答）？如果想利用一个电阻和一个电容来构建一个高通滤波器，电路应该如何连接？②RLC电路处于过阻尼状态时，是一种什么类型的滤波器？③RLC电路处于欠阻尼状态时，又属于什么类型的滤波器？
（1）
在基本的RC滤波电路中：C做输出瑞就是低通滤波器，R做输出就是高通滤波器。
当电源频率由0变大时，电容两端电压由大变小，因而低通；而在高通电路中，电阻两瑞的电压由0慢慢变大，因而高通。
因此给出的RC电路为为低通滤波器。
构建高通滤波器，需要将电阻作为输出端。
（2）
处于过阻尼状态时是低通滤波器。
（3）
处于欠阻尼状态时可以是低通滤波器，也可以是高通滤波器。
3、求频率响应、冲激响应、零状态响应 4、由冲激响应求微分方程 5、无失真传输 syms t w f=cos(t)+cos(2*t); y1=2*cos(t)+cos(2*t); y2=cos(t+pi/4)+cos(2*t+pi/3); y3=2*cos(t+pi/4)+cos(2*t+pi/2); subplot(2,2,1); fplot(t,f,[-10,10]); grid on;title('f=cos(t)+cos(2*t)') subplot(2,2,2); fplot(t,y1,[-10,10]) ;grid on;title('y1=2*cos(t)+cos(2*t)') subplot(2,2,3); fplot(t,y2,[-10,10]); grid on;title('y2=cos(t+pi/4)+cos(2*t+pi/3)') subplot(2,2,4); fplot(t,y3,[-10,10]); grid on;title('y3=2*cos(t+pi/4)+cos(2*t+pi/2)') y1(t)相对于f(t)产生了幅度失真，即只有前面的cost变成了2cost，高频分量产生幅度失真，未产生相位失真。
y2(t)相对于f(t)产生了相位失真，cost发生线性移动π/4，cos2t发生线性移动π/3，未产生幅度失真。
y3(t)相对于f(t)既产生了相位失真，cost发生线性移动π/4，cos2t发生线性移动π/3，也产生了幅度失真，只有前面的cost变成了2cos(t+4/π)。
6、理想低通滤波器的冲激响应和阶跃响应 （1）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a385dc6ef2069c716a0305b8779223ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb34e790ab37a6c140fe53a6d4c8839/" rel="bookmark">
			神经网络介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 知识点介绍 知识点介绍 前馈神经网络：（前馈网络的数据只向一个方向传播）
RNN循环神经网络，下图中多个 RNN 层都是“同一个层”，这一点与之前的神经网络是不一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3e4b75b392000cf0e79653589c7962/" rel="bookmark">
			数据清洗概念，方法及流程等等要点初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据清洗(Data Cleaning)是把数据记录中的错误数据辨认识别出来，然后将其去除，是对数据重新进行检查和校验的过程。数据清洗的目标是去除重复记录，消除异常数据，修正错误数据，确保数据一致性，并提高数据质量。数据仓库是关于特定主题的数据集合，数据来自不同类型的业务系统，并包含历史性数据，这样，在数据仓库中就会出现错误数据或者冲突数据的情况，将这类数据称为“脏数据”。根据确切的清洗规则和算法“洗掉”“脏数据”，这就是数据清洗。 近年来，数据库钻研团队对数据清洗非常关注，并且常常将数据清洗与数据仓库、数据挖掘以及数据关联关系联系在一起。钻研团队整合视图的研究目标是调和概念层面的差异，对整合框架、调解制度、原则冲突等综合性学习进行研究。对于数据清洗过程的下一步，分层和数据差异的例子几乎没有被注意。研究数据清洗和视图集成工作相辅相成，并实现了全局性的调和架构。但是，实例级别的数据调整面临着挑战，当需要将来自多个数据源的数据进行整合时，比如，在网络信息系统或数据仓库中，数据清洗的意义变得尤为重要，因为不同类型的数据源通常以不同的形式出现。剖析“脏数据”出现的原因以及其存在的形式就是数据清洗的原理，使用相关的清洗软件或工具清洗数据，把“脏数据”变为“干净数据”，提高数据质量。从“脏数据”产生的源头对数据进行剖析，对数据集进行全盘考察，进而提取数据清洗规则，最终，利用所提取的清洗规则发现数据集中的“脏数据”，然后对该类数据进行清洗。 数据清洗方式主要分为手动清洗，全机清洗，人机同步清洗和人机异步清洗四种类型。 (1)手动清洗：对较大的数据集来说，因为人工的限制，对数据清洗的准确性和速率会有所下降，所以，在公司业务体系中较小的数据集上通常会使用这种清洗方式。优点是准确率相对较高，缺点是执行速度较慢。 (2)全机清洗：依据具体清洗方案，编写清洗程序，自动清洗数据。优点是清洗自动化，把人解脱出来，缺点是实现过程复杂，后期维护困难。 (3)人机同步清洗：对于某些特殊的清洗，只能通过数据清洗程序才能实现，设计人机交互的界面，采取人工和机器辅助的方式，当清洗程序无法处理数据时，将通过人工干预等方式进行处理。优点是降低编写程序复杂度，减少大量人工操作，缺点是需人工实时参与。 (4)人机异步清洗：在对数据进行清洗的过程中，当遇到程序不能处理的问题时，不需人工直接参与，只需将异常情况记录下来生成相应的报告，然后继续进行清洗工作，人工则只需按照报告在后期进行相应的处理便可。优点是节约人力，提高清洗效果，是一种可行的清洗方式。 一般情况下，需要进行清洗的数据包括下列几种数据类型。 (1)缺损数据 缺损数据是指数据的一些信息缺失损坏，比如，业务体系中的主表与明细表不匹配、分公司的名称信息缺失损坏等，这些数据将从数据集中过滤出来，按照缺失内容的差异性将其分别写到不同类型的文档中，而后提交给客户，要求其在指定的时间内，根据所提出来的数据清洗框架、清洗规则和清洗算法进行补全，然后将其写入数据仓库。 缺 失 数 据 清 洗 ( missing values imputation) 。完善缺失数据是数据清洗领域面临的另一个重要问题。如图 2 所示，在现实世界中，由于手动输入的失误操作、部分信息需要保密或者数据来源不可靠等各种各样的原因，使得数据集中的内容残缺不完整。比如某条记录的属性值被标记为 NULL \、空缺或“未知”等。一旦不完整、不准确的数据用于挖掘，则会影响抽取模式的正确性和导出规则的准确性。当错误的数据挖掘模型应用于前端的决策系统时，就会导致分析结果和执行决策出现严重偏差。
当前有很多方法用于缺失值清洗，可以分为两类:
( a) 忽略不完整数据。直接通过删除属性或实例，忽略不完整的数据。在数据集规模不大、不完整数据较少的情况下，常常利用该方法来实现数据清洗。
该方法因为执行效率高，因此经常作为缺省方法，但缺点也相当明显。如果不完整数据集较大，一旦删除了若干记录之后，因为剩余的数据集规模较小，使得模型的构建不具备普适性和代表性，无法让人信赖，可靠度大大降低。另外，因为删除不完整数据带来的数据集偏差也使得数据挖掘的分类、聚类模型产生严重倾斜，进而影响最终的挖掘结果，产生重大决策性误导。
( b) 基于填充技术的缺失值插补算法。上一种忽略法很有可能将潜在的有价值信息也一并删除。因此更多的时候选择填充不完整的数据。为了填充缺失值，用最接近缺失值的值来替代它，保证可挖掘数据的数量和质量。填充方法保留了潜在的有用数据，和删除属性或记录相比，保留了更多数据样本，不易于产生数据分析偏差，由此构建的模型更可靠，更有说服力。目前常用的缺失值填充算法大体分为两大类，一类是统计学方法，另一类是分类、聚类方法。
采用统计学方法填充缺失值。分析数据集，获取数据集的统计信息，利用数值信息填充缺失值。其中最简单的方法是平均值填充方法。它把所有完整数据的算术平均值作为缺失数据的值。这种方法的弊端在于有可能会影响缺失数据与其他数据之间原本的相关性。如果规模较大的数据集的缺失值全部采用平均值填充法进行填充，因为过多的中值存在，更多的尖峰态频率分布有可能会误导挖掘结果。
采用分类、聚类方法填充缺失值。分类是在已有类标号的基础上，通过输入训练样本数据集，构造出分类器( 如分类函数或者分类模型) 。常用的数据分类技术包括决策树、神经网络、贝叶斯网络、粗糙集理论、最临近分类法等。利用完整记录与缺失记录之间的记录相似度，通过最大相似度的计算，结合机器学习的相关技术，建立最大可能的完整的数据模型。聚类是在不考虑类标号的前提下，寻求类间的相似性，目的也是在海量的数据聚集的基础上，构建较小的代表性的数据集，并基于该集合进一步分析和研究。常见的缺失值填充算法包括 EM 最大期望值算法( expectation－maximization algorithm ) 、MI 算 法 ( multiple imputation) 和 KNNI 算法( k－nearest neighbor imputation) 等。其中最大期望算法通过创建概率模型，寻找参数最大似然估计值或者最大后验估计值，概率模型的成功与否依赖于无法观测的隐藏变量( latent variable)。
(2)错误数据 错误数据出现的原因主要是不够完善的业务体系，没有判别所接收到的输入数据是否与业务准则相符，直接将其写入到后台数据库中。先对错误数据进行分类，而后经过 SQL 语句寻找出来，根据客户请求在业务体系中修改，最终再对其进行抽取。数据类型不一致或日期格式不正确等问题同样会导致数据清洗失败，对于此类型的错误问题，需要在业务系统的数据库中通过 SQL 语句将其找出，交给业务部门进行修改，然后再对其进行抽取。 噪声数据处理( noise treatment) 。数据挖掘前，往往假设数据集不存在任何数据干扰。然而，实际应用中却因为各种原因，在数据收集、整理的过程中，产生大量的噪声数据，即“离群点”。因为噪声数据不在合理的数据域内，所以分析、挖掘过程中输入和输出数据的质量难以保证，容易造成后续的挖掘结果不准确、不可靠，如图 3 所示。常用的消除噪声数据的方法分为两种。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3e4b75b392000cf0e79653589c7962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a259532642d4a239b5142a4c103449/" rel="bookmark">
			交换机端口镜像技术原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络维护的过程中会遇到需要对报文进行获取和分析的情况，比如怀疑有攻击报文，此时需要在不影响报文转发的情况下，对报文进行获取和分析。镜像技术可以在不影响报文正常处理流程的情况下，将镜像端口的报文复制一份到观察端口，用户利用数据监控设备来分析复制到观察端口的报文，进行网络监控和故障排除。 数据采集的作用 业务实时监控：大型网络或数据中心一般会在汇聚点设置监控系统实时监测网络数据流量信息，防范和防止业务的异常。故障处理分析：一些疑难杂症的故障需通过采集实际的报文信息来找到更加明显的线索。网络流量优化：当网络系统发展到一定规模，对数据流量地精细化控制变的尤为重要。只有实际采集现网的真实数据流量，通过专业的流量分析系统定位出网络的各种问题，并为此提出优化解决方案。 数据采集的方法 分光器物理采集：利用物理器件分光器插入连接的链路当中，复制出正常的数量流到采集器上面。采集的数据完整可靠，只在中间链路上操作，完全不影响被采集设备的性能，也不占用链路带宽。缺点是每次采集要做物理动作切入，相对繁琐且有风险。适合网络业务出入口大型设备的数据流采集，常用于连接IDS设备的网络环境。NMS集中采集：利用通用标准协议SNMP协议传送标准的MIB数据，采集整网的配置信息和设备端口数据流信息。优点是可以采集整网设备节点信息。缺点是针对接口的数据流信息采集不够精细和完整，大部分是统计信息。适合网管中心查看设备的参数和性能以及业务信息统计。 镜像概述 镜像定义将镜像端口（源端口）的报文复制一份到观察端口（目的端口）。镜像作用获取完整报文用于分析网络状况。镜像优点不影响原有网络，快捷方便。采集的是实时数据流，真实可靠。镜像的特点：在网络维护的过程中会遇到需要对报文进行获取和分析的情况，比如怀疑有攻击报文，此时需要在不影响报文转发的情况下，对报文进行获取和分析。镜像可以在不影响报文正常处理流程的情况下，将镜像端口的报文复制一份到观察端口，用户利用监控设备来分析复制到观察端口的报文，进行网络监控和故障排除。镜像支持将多端口的流量镜像到同一个观察端口，配置时没有数量限制，但是需要考虑观察端口实际的流量是否超过其转发能力，即实际流量是否超过此观察端口的最大带宽。如果在主接口做端口镜像，会将子接口流量也镜像到观察端口。 镜像的角色 镜像端口：镜像端口是被监控的端口，从镜像端口流经的所有报文或匹配流分类规则的报文将被复制到观察端口。观察端口：观察端口是连接监控设备的端口，用于输出从镜像端口复制过来的报文。 本地端口镜像配置需求 某企业中，办公区1和办公区2用户分别通过接口Eth2/0/1、Eth2/0/2接入Router。一台监控设备接在Router的接口Eth2/0/3上，用于数据分析监控。为保证企业的信息安全，用户希望通过监控设备对办公区1和办公区2发送的所有报文进行监控。 配置思路：在Router上将接口Eth2/0/3配置为本地观察端口。 在Router上将接口Eth2/0/1和Eth2/0/2配置为镜像端口，实现对接口报文进行监控。 本地端口镜像配置实现 配置命令： observe-port interface Ethernet2/0/3 // 将 E2/0/3 接口配置为观察端口。 # interface Ethernet2/0/1 mirror to observe-port inbound // 将 E2/0/1 接口配置为镜像端口，镜像所有入方向报文。 # interface Ethernet2/0/2 mirror to observe-port inbound // 将 E2/0/2 接口配置为镜像端口，镜像所有入方向报文。 流镜像配置需求 某企业中，市场部用户通过接口Eth2/0/0接入路由器RTA。一台监控设备接在RTA的接口Eth2/0/1上，用于数据分析监控。用户希望监控市场部IP地址为192.168.1.10的主机发出的所有报文。流镜像：将镜像端口上特定业务流的报文传送到监控设备进行分析和监控。在流镜像中，镜像端口应用了特定的流策略。如果从镜像端口流经的报文匹配流策略，则将被复制并传送到监控设备。配置思路：将接口Eth2/0/1配置为本地观察端口。 配置流镜像策略，并在接口Eth2/0/0入方向上应用流策略，将匹配源IP地址为192.168.1.10的报文复制到本地观察端口。 流镜像配置实现 配置命令： observe-port interface Ethernet2/0/1 // 将端口 E2/0/1 定义为观察端口。 # acl number 2000 // 用 ACL 匹配 IP 为 192.168.1.10 主机。 rule 5 permit source 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a259532642d4a239b5142a4c103449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf636c52c8f189376a0ed946e61b51d4/" rel="bookmark">
			C#基础语法的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习基础 已经学过一门面向对象的语言和C语言基础
本文按找基本介绍,物质,运动,类的顺序进行介绍
.NET 概述 什么是 .NET .NET(dotnet)是微软公司发布的应用程序框架 ,用以减轻软件开发人员的工作 .它包括一系列类库、运行时等内容 .
在生成一个 .NET 程序时 ,代码翻译成微软中间语言 (MSIL, Microsoft Intermediate Language)的可执行文件 .
执行该可执行文件时 ,将启动对应 .NET 框架的“公共语言运行时 (CLR, Common Language Runtime)” ,由该 CLR 将 MSIL 编译为机器码执行 ,称作 JIT 编译 (just-in-time compilation) .
所以,由.net开发的程序的优点
可以跨平台(使用不同的CLR编译)可以通过一些工具,如dnspy,反编译出其源代码轻松实现垃圾回收 (GC, Garbage Collection) .NET历史 .NET Framework: 微软推出的框架名字叫“.NET Framework” ,闭源且只能在 Windows 上运行
.NET Core: 后来,微软拥抱开源与跨平台 ,推出了“.NET Core”框架 ,该框架开源 ,并且支持多种操作系统 ,
.NET: 并且随着 .NET Core 版本的更迭 ,.NET Framework 支持的功能也逐渐向 .NET Core 迁移 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf636c52c8f189376a0ed946e61b51d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6715b94850276a0c955be226b8fd27/" rel="bookmark">
			web前端项目-七彩夜空烟花【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web前端项目-七彩动态夜空烟花【附源码】 本项目仅使用了HTML，代码简单，实现效果绚丽，且本项目代码直接运行即可实现，无需图片素材，接下来让我们一起实现一场美丽的烟花秀叭
运行效果：鼠标点击和移动可控制烟花方向，烟花颜色自动变化
HTML源码 &lt;!DOCTYPE html&gt; &lt;html dir="ltr" lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width" /&gt; &lt;title&gt;Enjoy fireworks&lt;/title&gt; &lt;script type="text/javascript" src="http://g.huceo.com/weixin/qw/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var dataForWeixin = { appId: "gh_ff79a97cd7f3", url: "http://g.huceo.com/weixin/yh/en/", title: "Lonely fireworks shows, if you feel good, please share the wechat！", desc: "Lonely fireworks shows, if you feel good, please share the wechat！" }; var onBridgeReady = function(){ WeixinJSBridge.on('menu:share:appmessage', function(argv){ var infos = $("#infos").text(); WeixinJSBridge.invoke('sendAppMessage', { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6715b94850276a0c955be226b8fd27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8e0707cd5b11bce60fce617cea2f8e/" rel="bookmark">
			Spring Boot3 Web开发技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期回顾 springboot项目常见的配置文件类型有哪些？哪种类型的优先级最高 yml properties yaml
读取配置文件里的数据用什么注解？ @value
restful风格 RESTful 风格与传统的 HTTP 请求方式相比，更加简洁，安全，能隐藏资源的访问行为，无法从访问地址得知对资源是何种操作
可见很多 RESTful 风格的访问地址都是一样的，只用行为动作区分了不同的访问，对外隐藏了真实的操作。此外，资源描述部分一般用复数，如 books，当然这种操作是只是一种约定，不是规范，但大多数人都这样做。
@RestController @RequestMapping("/users") public class UserController { @PostMapping public String addUser(@RequestBody UserInfo userInfo){ System.out.println("新增用户信息："+userInfo); return "新增用户成功"; } @DeleteMapping("/{id}") public String del(@PathVariable Integer id){ System.out.println("删除用户ID："+id); return "删除用户成功"; } @PutMapping public String update(@RequestBody UserInfo userInfo){ System.out.println("修改后"); return "修改用户成功"; } @GetMapping("/{id}") public String getUser(@PathVariable Integer id){ System.out.println("用户ID："+id); return "查询用户ID成功！"; } @GetMapping public String getUsers(){ System.out.println("查询所有的用户"); return "查询所有的用户"; } } 利用postman测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc8e0707cd5b11bce60fce617cea2f8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9059fb13211a6c2ed23ea2b7057397c3/" rel="bookmark">
			【Image】GAN的超详细解释（以及奇怪的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GAN原理 工作流程 下面是生成对抗网络（GAN）的基本工作原理
在GAN的架构中，有两个关键的组件：生成器（Generator）和鉴别器（Discriminator）。
生成器（Generator）：其功能是从随机噪声生成数据。在这个上下文中，它试图生成类似于真实数据的新数据。目的是创建足够真实的数据以欺骗鉴别器。
鉴别器（Discriminator）：它的任务是鉴别输入数据是真实的还是由生成器生成的假数据。简言之，它需要决定输入数据是“真”还是“假”。
工作过程：
真实数据会被输入到鉴别器中。同时，生成器产生的数据也会被送入鉴别器。鉴别器会对这两种数据进行分类，将其标记为“真”或“假”。 学习方式：生成器和鉴别器是以对抗的方式进行学习的。生成器试图生成越来越真实的数据来欺骗鉴别器，而鉴别器则试图变得更加精确以区分真实数据和生成的数据。这个过程会不断循环，随着时间的推移，生成器产生的数据会越来越接近真实数据，而鉴别器的判断能力也会越来越强（有点类似于左脚踩右脚原地起飞）。
数学解释 当然，上面的解释只是语言层面的，GAN的原理同样可以从数学上进行解释
min ⁡ G max ⁡ D V ( D , G ) = E x ∼ p data ( x ) [ log ⁡ D ( x ) ] + E z ∼ p z ( z ) [ log ⁡ ( 1 − D ( G ( z ) ) ) ] \min_{G} \max_{D} V(D, G) = \mathbb{E}_{x \sim p_{\text{data}}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_{z}(z)}[\log(1 - D(G(z)))] Gmin​Dmax​V(D,G)=Ex∼pdata​(x)​[logD(x)]+Ez∼pz​(z)​[log(1−D(G(z)))]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9059fb13211a6c2ed23ea2b7057397c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7335e737927a188b0b40be6a9ba23482/" rel="bookmark">
			ts相关笔记（类型层级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刷了本ts小册，对一些知识点做下笔记。以输出的方式来输入！
type VerboseTypeChain = never extends 'abc' ? 'abc' extends 'abc' | 'bca' ? 'abc' | 'bca' extends string ? string extends {} ? string extends String ? String extends {} ? {} extends object ? object extends {} ? {} extends Object ? Object extends {} ? object extends Object ? Object extends object ? Object extends any ? Object extends unknown ? any extends unknown ? unknown extends any ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7335e737927a188b0b40be6a9ba23482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8752f5c5b6878a6f17a55c53514fecd/" rel="bookmark">
			django的通知和信号量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通知 Django 本身并没有内置的通知系统，但有一些第三方库提供了通知的实现，其中比较常用的是 django-notifications。下面是关于 Django 通知的实现方式和一些基本概念：
安装 django-notifications：
pip install django-notifications 添加应用到 INSTALLED_APPS： # settings.py INSTALLED_APPS = [ # ... 'notifications', ] 运行迁移： python manage.py makemigrations python manage.py migrate 使用 notifications 库：
发送通知： from django.contrib.auth.models import User from notifications.signals import notify 发送通知
recipient_user = User.objects.get(username='recipient_user') actor_user = User.objects.get(username='actor_user') notify.send(actor_user, recipient=recipient_user, verb='You have a new message.') 接收通知
# 在视图或其他地方获取用户的通知 notifications = Notification.objects.filter(recipient=request.user) 渲染通知模板：
# 在模板中渲染通知 {% for notification in notifications %} {{ notification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8752f5c5b6878a6f17a55c53514fecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa300000b08a98537317108f01b87d7b/" rel="bookmark">
			Java毕业设计174例，包含部署视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包含部署视频：
1、基于ssh的婴幼儿产品销售系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
2、基于jsp的医院管理住院系统毕业设计（项目报告+答辩PPT+源代码+数据库+部署视频）
3、基于ssh的医院在线挂号系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
4、基于jsp的项目管理平台系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
5、基于jsp的物流信息网系统毕业设计(项目报告+答辩PPT+源代码+数据库+部署视频)
6、基于jsp的影视创作论坛系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
7、基于jsp的银行柜员业务绩效考核系统毕业设计（项目报告+源代码+数据库+部署视频）
8、基于ssh的任务调度系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
9、基于jsp的洋酒销售系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
10、基于jsp的物资管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
11、基于java的机场航班起降与协调管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
12、基于jsp的高校固定资产管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
13、基于java的土地档案管理系统毕业设计(项目报告+答辩PPT+源代码+数据 库+部署视频)
14、基于jsp的电脑彩票销售管理系统毕业设计(项目报告+答辩PPT+源代码+部署视频)
15、基于java的网络版坦克大战游戏系统毕业设计(项目报告+答辩PPT+源代码+数据库+部署视频)
16、基于java的个人博客系统毕业设计(项目报告+答辩PPT+源代码+数据库+部署视频)
17、基于jsp的城市公交查询系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
18、基于java的推箱子游戏系统毕业设计(项目报告+答辩PPT+源代码+部署视频)
19、基于jsp的网上体育商城系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
20、基于jsp的电子服务网站系统毕业设计（项目报告+源代码+数据库+部署视频）
21、基于java的愤怒的小鸟游戏系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
22、基于jsp的网上购物系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
23、基于jsp的超市积分管理系统毕业设计（项目报告+源代码+数据库+部署视频）
24、基于jsp的网上购书系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
25、基于java的俄罗斯方块游戏系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
26、基于jsp的车辆管理系统毕业设计(项目报告+源代码+数据库+部署视频)
27、基于java的陶瓷工厂进销存管理系统毕业设计（项目报告+答辩PPT+源代码+数据库+部署视频）
28、基于jsp的网上订餐管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
29、基于java的飞机大战游戏系统毕业设计(项目报告+源代码+部署视频)
30、基于jsp的产品售后服务管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
31、基于java的商品供应管理系统毕业设计（项目报告+答辩PPT+源代码+数据库+部署视频）
32、基于jsp的网络spider技术的网络新闻分析系统毕业设计（项目报告+源代码+数据库+部署视频）
33、基于jsp的财务管理系统与实现(项目报告+中期报告+答辩PPT+源代码+数据库+部署视频)
34、基于java的搜索引擎系统毕业设计（项目报告+开题报告+答辩PPT+源代码+数据库+部署视频）
35、基于jsp的企业快信系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
36、基于jsp的采购管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
37、基于jsp的挖掘机配件营销系统毕业设计( 项目报告+答辩PPT+源代码+数据库+截图+部署视频)
38、基于java的私人牙科诊所管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+ 截图+部署视频)
39、基于java的宠物管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
40、基于java的出租车计价器系统毕业设计(项目报告+答辩PPT+源代码+数 据库+截图+部署视频)
41、基于jsp的企业员工信息管理系统毕业设计（项目报告+答辩PPT+源代码+数据库+部署视频）
42、基于jsp的web仓库管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
43、基于java的保险业务管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
44、基于java网站即时通讯系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
45、基于jsp的农产品销售管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
46、基于java的扫雷游戏系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
47、基于java的病历管理系统毕业设计(项目报告+源代码+数据库+部署视频)
48、基于jsp的百货中心供应链管理系统毕业设计(项目报告+源代码+数据库+部署视频)
49、基于java的模拟写字板系统毕业设计(项目报告+开题报告+答辩PPT+源代码+部署视频)
50、基于jsp的企业电子投票系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
51、基于java的超级玛丽游戏系统毕业设计(项目报告+答辩PPT+源代码+部署视频)
52、基于java的聊天室系统毕业设计(项目报告+ 开题报告+答辩PPT+源代码+部署视频)
53、基于java的web停车场管理系统毕业设计(项目报告+开题报告+答辩PPT+ 源代码+数据库+部署视频)
54、基于java的旅游网站系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
55、基于jsp的酒店管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+部署视频)
56、基于java的qq屏幕截图工具系统毕业设计(项目报告+答辩PPT+源代码+部署视频)
57、基于jsp的码头船只出行管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
58、基于java的web校园二手平台系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
59、基于jsp的进销存管理系统毕业设计(项目报告+答辩PPT+源代码+数据库+截图+部署视频)
60、基于java的敬老院管理系统毕业设计(项目报告+ 答辩PPT+源代码+数据库+截图+部署视频)
61、基于java+ssh的医院在线挂号系统毕业设计(项目报告+答辩PPT+源代码+数据库+部署视频)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa300000b08a98537317108f01b87d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14724aa37927e95362398aa83cec713f/" rel="bookmark">
			毕业设计：热门旅游景点大数据分析系统&#43;可视化 &#43;贝叶斯预测模型 旅游大数据 （附源码）✅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毕业设计：2023-2024年计算机专业毕业设计选题汇总（建议收藏）
毕业设计：2023-2024年最新最全计算机专业毕设选题推荐汇总
🍅感兴趣的可以先收藏起来，点赞、关注不迷路，大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助同学们顺利毕业 。🍅
1、项目介绍 技术栈： Flask框架、requests爬虫、Echarts可视化、MySQL数据库、贝叶斯预测模型
利用网络爬虫技术从马蜂窝网站爬取各城市的景点旅游数据，根据马蜂窝旅游网的数据综合分析每个城市的热度、热门小吃和景点周边住宿，
可以很方便的通过浏览器端找到自己所需要的信息，获取到当前的热门目的地，根据各城市景点的数据，
周围小吃，住宿等信息，制定出适合自己的最佳旅游方案。
贝叶斯预测模型 （基于贝叶斯网络的热门城市预测模型）
根据城市的热门景点的数量、景点的评论人数、城市的小吃数量等特征，构建贝叶斯网络机器学习模型，通过对模型的训练，可实现对一个城市是否是热门旅游城市的预测。
2、项目界面 （1）各省份热门城市分析
（2）首页–注册登录
（3）热门城市的景点分析
（4）热门城市美食分析
（5）贝叶斯预测模型 （基于贝叶斯网络的热门城市预测模型）
（6）数据爬虫页面
3、项目说明 旅游大数据采集分析系统是基于Flask框架搭建的Web应用程序，主要用于采集、分析和可视化旅游相关的大数据。系统主要包括以下模块：
数据采集模块：使用requests爬虫库，通过爬取各种旅游相关网站的数据，包括景点信息、酒店信息、交通信息等，并将数据存储到MySQL数据库中。
数据处理模块：使用MySQL数据库进行数据的存储和管理，包括数据清洗、数据整合、数据分析等操作。可以使用贝叶斯预测模型对旅游数据进行预测和分析。
数据可视化模块：使用Echarts可视化库，将从数据库中提取的数据进行可视化展示，包括各种统计图表、地图等，以便用户更直观地了解旅游数据。
用户可以通过系统的前端界面，选择需要的数据分析和可视化功能，系统将根据用户的选择，从数据库中提取相应的数据进行处理和展示。用户可以通过系统的搜索功能，查找特定的旅游数据，并进行数据分析和预测，以便做出更好的决策。系统还提供导出数据的功能，用户可以将分析结果导出为Excel或CSV文件，以便进行进一步的分析或报告生成。
通过这个系统，用户可以更方便地获取和分析旅游相关的大数据，从而更好地理解市场需求、优化旅游产品和服务，提升旅游业的发展和竞争力。
4、核心代码 #!/usr/bin/python # coding=utf-8 import sqlite3 from flask import Flask, render_template, jsonify import json from collections import Counter import pandas as pd app = Flask(__name__) app.config.from_object('config') login_name = None # --------------------- html render --------------------- @app.route('/') def index(): return render_template('index.html') @app.route('/hot_city') def hot_city(): return render_template('hot_city.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14724aa37927e95362398aa83cec713f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a33e320521dbd17449287c6360c25b4/" rel="bookmark">
			ts相关笔记（extends、infer、Pick、Omit）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刷了本ts小册，对一些知识点做下笔记。
extends extends 是一个关键字，用于对类型参数做一些约束。
A extends B 意味着 A 是 B 的子类型，比如下面是成立的
‘abc’ extends string599 extends number 看下面例子：
type MyType&lt;T extends number&gt; = { value: T; }; const example: MyType&lt;number&gt; = { value: 42 }; 联合类型子集均为联合类型的子类型，即 1、 1 | 2 是 1 | 2 | 3 | 4 的子类型
type MyType&lt;T extends number | string&gt; = { value: T; }; const example1: MyType&lt;number&gt; = { value: 42 }; const example2: MyType&lt;string&gt; = { value: 'hello' }; 通过接口进行约束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a33e320521dbd17449287c6360c25b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239cb0cb5e1d10bffd57be4357ff73af/" rel="bookmark">
			深入剖析PyPy，解锁Python比C还快的秘诀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源丨网络
「如果想让代码运行得更快，您应该使用 PyPy。」 - Python 之父 Guido van Rossum
对于研究人员来说，迅速把想法代码化并查看其是否行得通至关重要。Python 是能够实现这一目标的出色语言，它能够让人们专注于想法本身，而不必过度为代码格式等无聊的事情困扰。
但是，Python 有一个致命的缺点：速度比 C、C ++ 等语言慢很多。那么，构建一个 Python 原型测试想法之后，如何将其转变为快速且高性能的工具？通常来说，人们还要再进行一步工作：将 Python 代码手动转换为 C 语言的代码。但如果 Python 原型本身就可以运行得很快，那么转换代码的时间就可以做一些更有意义的事情。
而 PyPy，恰好可以解决这一问题。它能够让 Python 代码运行得比 C 还快。
import time from termcolor import colored start = time.time() number = 0 for i in range(100000000): number += i print(colored("FINISHED", "green")) print(f"Ellapsed time: {time.time() - start} s") 为了证明 PyPy 的速度，使用默认的 Python 解释器和 PyPy 运行上述代码，执行一个从整数 0 加到 100,000,000 的循环, 然后打印出运行时间。运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239cb0cb5e1d10bffd57be4357ff73af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92616c63a8901cfd523ecb5674ba86a/" rel="bookmark">
			024、数据库管理之数据同步工具TiCDC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TiCDC TiCDCTiCDC介绍架构与原理适用场景对已有TiDB进行扩容部署TiCDC管理工具TiCDC同步任务查询所有TiCDC同步任务查询TiCDC指定的同步任务管理TiCDC同步任务动态更新任务监控TiCDC 实验数据同步完整实操缩容当前TiCDC节点 TiCDC TiCDC介绍 TiCDC 是一款通过拉取 TiKV 变更日志实现的 TiDB 增量数据同步工具，具有将数据还原到与上游任意 TSO 一致状态的能力，同时提供开放数据协议 (TiCDC Open Protocol)，支持其他系统订阅数据变更。
架构与原理 每个Capture: 不是收集所有TiKV当中的日志，只是负责部分TiKV，然后会选择一个Caputre作为owner将所有的日志进行处理排序，然后供给下游系统订阅
适用场景 TiCDC适合上游数据库是TiDB,下游数据库支持Mysql兼容的任何数据库和kafka, 适合异步复制的场景。
有效索引的相关要求
TiCDC 只能同步至少存在一个有效索引的表，有效索引的定义如下：
主键 (PRIMARY KEY) 为有效索引。同时满足下列条件的唯一索引 (UNIQUE INDEX) 为有效索引： 索引中每一列在表结构中明确定义非空 (NOT NULL)。索引中不存在虚拟生成列 (VIRTUAL GENERATED COLUMNS)。
TiCDC 从 4.0.8 版本开始，可通过修改任务配置来同步没有有效索引的表，但在数据一致性的保证上有所减弱。具体使用方法和注意事项参考同步没有有效索引的表。 TiCDC 暂不支持的场景如下：
暂不支持单独使用 RawKV 的 TiKV 集群。暂不支持在 TiDB 中创建 SEQUENCE 的 DDL 操作和 SEQUENCE 函数。在上游 TiDB 使用 SEQUENCE 时，TiCDC 将会忽略掉上游执行的 SEQUENCE DDL 操作/函数，但是使用 SEQUENCE 函数的 DML 操作可以正确地同步。 对已有TiDB进行扩容部署 TiCDC环境部署
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92616c63a8901cfd523ecb5674ba86a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311b00fdec9a1f828bb1e51039acaac3/" rel="bookmark">
			软件测试面试八股文——基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5）错误推测法：是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法
6）正交实验法
7）判定表法
8）测试大纲法
3、提交缺陷的八大要素
1）缺陷编号：缺陷的唯一标识，在禅道之类的缺陷管理工具中一般会自动生成。
2）缺陷状态：缺陷跟踪过程的进展情况，缺陷工具都会有相应的流程和状态标识。
3）缺陷标题：揭示出该缺陷的本质。
4）缺陷类型：根据缺陷产生的来源和根源划分出的缺陷种类。代码错误、界面优化、设计缺陷、配置相关、程序非法退出、死循环、通讯中断或异常，数据破坏丢失或数据库异常
5）严重程度：缺陷对软件系统的影响程度。关键的、主要的、次要的、和无关紧要的。
6）优先级：修复缺陷的重要性或紧迫性。紧急、高、中和低。
7）重现步骤：要求开发人员按照步骤能重现bug。
8）测试环境：测试环境的配置，包括操作系统和浏览器。
4、软件开发的周期(软件开发阶段)?
1)需求分析阶段 产出物:《需求规格说明书》
2)设计阶段 产出物:《概要设计说明书》《 详细设计说明书》
3)编码阶段 产出物:程序
5、get和post请求的优缺点、区别
get和post是http请求的两种基本方法。HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样的。
相同点：GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
1.post请求包含更多的请求头因为post需要在请求的body部分包含数据，所以会多了几数据描述部分的首部字段（如：content-type）,这其实是微乎其微的。
2.最重要的一条，post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据
post请求的过程：
（1）浏览器请求tcp连接（第一次握手）
（2）服务器答应进行tcp连接（第二次握手）
（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）
（4）服务器返回100 Continue响应
（5）浏览器发送数据
（6）服务器返回200 OK响应
get请求的过程：
（1）浏览器请求tcp连接（第一次握手）
（2）服务器答应进行tcp连接（第二次握手）
（3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）
（4）服务器返回200 OK响应
6、测试步骤流程
1）测试需求分析阶段：阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议。
2）测试计划阶段：主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围（来自需求文档），进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。
3）测试设计阶段：主要是编写测试用例，会参考需求文档（原型图），概要设计，详细设计等文档，用例编写完成之后会进行评审。
4）测试执行阶段：搭建环境，执行冒烟测试（预测试）-然后进入正式测试，bug管理直到测试结束。
5）测试评估阶段：出测试报告，确认是否可以上线。
7、测试模型
V模型
V模型的价值在于它非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间各阶段的对应关系。局限性：把测试作为编码之后的最后一个活动，需求分析等前期产生的错误直到后期的验收测试才能发现。
W模型
W模型是V模型的发展，强调的是测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、功能和设计同样要测试。测试与开发是同步进行的，从而有利于尽早地发现问题。
W模型也有局限性。W模型和V模型都把软件的开发视为需求、设计、编码等一系列串行的活动，无法支持迭代、自发性以及变更调整。
X模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成最终成为可执行的程序，然后再对这些可执行程序进行测试。
H模型揭示了一个原理:软件测试是一个独立的流程,贯穿产品整个生命周期,与其他流程并发地进行。H模型指出软件测试要尽早准备, 尽早执行。不同的测试活动可以是按照某个次序先后进行的,但也可能是反复的,只要某个测试达到准备就绪点,测试执行活动就可以开展。
总结：
V 模型——非常明确地标注了测试过程中存在的不同类型的测试。
W模型——非常明确地标注了生产周期中开发与测试之间的对应关系。
X 模型——这个模型指出整个测试过程是在探索中进行的。
H 模型——软件测试是一个独立的流程，贯穿产品整个生命周期，与其他流程并发地进行。
总结 如果你对此文有任何疑问，如果你也需要接口项目实战，如果你对软件测试、接口测试、自动化测试、面试经验交流感兴趣欢迎加入我们，加入方式在文章的最后面 自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311b00fdec9a1f828bb1e51039acaac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7291b582a17d83f48c7992426c89519e/" rel="bookmark">
			【C&#43;&#43;初阶】九、STL容器中的string类（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=========================================================================
相关代码gitee自取：
C语言学习日记: 加油努力 (gitee.com)
=========================================================================
接上期：
【C++初阶】八、初识模板（泛型编程、函数模板、类模板）-CSDN博客
=========================================================================
目录 一 . STL简介
什么是STL
STL的版本
HP 原始版本：
P.J. 版本：
RW 版本：
SGI 版本：
STL的六大组件
图示：
二 . string类
C语言中的字符串
C++标准库中的string类
string类（了解）
总结：
string类的常用接口说明（重点）
string类对象的常见构造函数：
图示 -- 第1个构造函数：
图示 -- 第2、3个构造函数：
图示 -- 第4、5个构造函数：
图示 -- 第6、7个构造函数：
补充 -- operator= ：（赋值“=”运算符重载函数）
string类对象的容量操作：
使用注意事项：
string类对象的访问即遍历操作：
operator[] ：（下标运算符"[ ]"重载函数）
begin + end ：（通过迭代器进行遍历）
rbegin + rend ：（通过迭代器进行反向遍历）
范围for循环 -- 完成字符串遍历：
本篇博客相关代码：
Test.cpp文件 -- C++文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7291b582a17d83f48c7992426c89519e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38b3db8f9b7fd63839d516a2865c1e3/" rel="bookmark">
			2023-12-22 回溯算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回溯思想 回溯模版三部曲： ① 回溯函数模版返回值以及参数
② 回溯终止条件
③ 回溯搜索的遍历过程
分析完过程，回溯算法模板框架如下：
void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 这份模板很重要，后面做回溯法的题目都靠它了！
77. 组合 思想：对于这种回溯的问题，其实可以看成一棵树，就是穷举每一种可能的！在此的基础之上然后进行剪枝！ 剪枝：可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。 如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。 class Solution: def combine(self, n: int, k: int) -&gt; List[List[int]]: result = [] self.backtracking(n, k, 1, [], result) return result # 回溯的参数以及返回 n k p [] result def backtracking(self, n, k, startIndex, path, result): # 回溯终止条件 if len(path) == k: result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d38b3db8f9b7fd63839d516a2865c1e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4f0dc4611567a1c88ec37b892034e2/" rel="bookmark">
			SQL实践篇（三）：什么是Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介Redis是什么，为什么这么快？Redis的数据类型字符串Hash字符串列表字符串集合有序字符串集合其他数据类型 总结参考文献 简介 Redis是一种基于内存的键值数据库，键值数据库会使用哈希表存储key和value。其中key和value可以是任何内容，无论是简单对象还是复杂对象。
键值数据库是NoSQL思想，其规则是"只提供你想要的"，因此模型很灵活，查询效率也高，成本也低。
而RDBMS是建立在关系模型的基础上，强调的是数据的一致性和各种约束条件，成本很高。
本节我们将从以下几个方面，简单了解下Redis：
Redis是什么，为什么它这么快？Redis支持的数据类型都有哪些？ Redis是什么，为什么这么快？ Redis，全称是REmote Dictionary Server。
Redis的查询效率非常高，根据官方的数据，Redis每秒最多处理的请求可以达到10w次。
为什么这么快呢？
Redis是采用ANSI C语言编写的，跟SQLite一样。这样的好处是底层代码执行效率更高，相比面向对象的语言，依赖性也更低。系统兼容性好，稳定性高。
另外，Redis是基于内存的数据库，没有磁盘IO的限制，自然快的飞起。
其次，数据结构简单，采用key-value的方式进行存储，也就是使用Hash结构进行操作，数据的操作复杂度为O(1)。
但是Redis快的原因远不止这些，还有很多各种各样的原因，比如说它采用单进程单线程的模型，避免了上下文切换和不必要的线程资源争抢问题。
在技术上，Redis还采用了多路IO复用技术。这里的多路指的是多个socket网络连接，复用指的是复用同一个线程。这样的好处是可以在同一个线程中处理多个IO请求，尽量减少网络IO的损耗。
可以看到，Redis可以说是把效率做到了极致，各方各面可能存在的时间消耗都被优化过。
2023-11-10 00:47:47 不过，在2020年新推出的Redis6.0版本里，还是引进了多线程模型，来提高Redis的性能和并发能力。不过Redis默认情况下不会开启多线程模式，官方建议是除非达到了性能瓶颈，否则没必要开启多线程。
Redis的数据类型 Memcached也是一个键值型数据库，但与它相比，Redis还有一个非常大的优势，就是支持多种数据类型。
Redis支持的数据类型包括字符串、哈希、列表、集合、有序集合等。
字符串 字符串类型是Redis提供的最基本的数据类型。对应的结构是key-value
如果我们想要设置某个键的值，可以使用set key value，如果想要获取某个值，那就用get key。如图：
Hash 哈希（hash）进一步提供了字段和字段值的映射，对应的结构是key-field-value。
设置某个键的哈希值：hset key field value。
比如说要给user1设置username为zhangfei，设置age为28，可以写成：
hset user1 username zhangfei hset user1 age 28 或者可以连写成：
Hmset user1 username zhangfei age 28 取出某个键的某个field字段：hget key field
比如说hget user1 username。
一次性取出某个键的多个field字段： hmget key field_1 field_2...。
比如说hmget user1 usename age。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4f0dc4611567a1c88ec37b892034e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74760212ec0d421dc90e512048046f53/" rel="bookmark">
			SQL实践篇（二）：为什么微信用SQLite存储聊天记录？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介什么是SQLite在python中使用SQLite通过SQLite查询微信的聊天记录参考文献 简介 SQLite是一个嵌入式的开源数据库引擎，大小只有3M左右，因此我们可以将整个SQLite嵌入到应用中，而不再需要采用传统的客户端/服务器（CS）架构。这样的好处在于非常轻便，很多智能设备和应用中都可以使用SQLite，比如说微信和QQ就采用了SQLite作为本地聊天记录的存储。
本节将从以下几个方面，深入了解一下SQLite：
什么是SQLite？它有哪些优点和不足？如何在Python中使用SQLite？如何编写SQL，来通过SQLite查找微信的聊天记录？ 什么是SQLite SQLite是2000年左右发布的，其采用C语言编写，而不是C++，从而一定程度上尽量提升底层代码的执行效率
它的优势在于非常轻量级，存储数据非常高效，查询和操作也很方便。而且它不需要安装和配置，很方便迁移，也方便嵌入到很多应用程序中。相比需要托管在服务器上的RDBMS，SQLite的约束更加少，更容易操作。
不足也很明显，它不适用高并发的情况，一般常用于小型或者中型的数据存储。比如说在微信本地可以使用SQLite，即时是几百M的数据文件，对SQLite来讲也是信手拈来，但是微信本身的服务器就不能用SQLite了，缺点太明显了，比如说影响最大的一点：SQLite同一时间只允许一个写操作，吞吐量非常有限。
而且，作为一个简化版的数据库，SQLite没有用户管理功能，在语法上也跟常规的SQL有所不同，充斥了一部分的"方言"。
比如说SQLite 不支持right join，仅支持只读视图（只能创建、读取和删除，不能修改）
但总体来讲，基本还是支持SQL标准的。
在python中使用SQLite python中集成了SQLite3，直接加载相应的包就可以使用。
import sqlite3 创建数据库连接：
conn = sqlite3.connect("wucai.db") 如果没有这个文件，那么这一步会在相应的工程路径里创建指定的文件，用来存放数据。否则会直接连接现有文件。
然后我们可以使用conn来操作连接，创建游标：
cur = conn.cursor() 得到游标之后，我们就可以通过游标来调用execute()执行各种各样的SQL语句。
比如说创建一个heros数据表：
cur.execute("CREATE TABLE IF NOT EXISTS heros (id int primary key, name text, hp_max real, mp_max real, role_main text)") 再插入一条数据：
cur.execute('insert into heros values(?, ?, ?, ?, ?)', (10000, '夏侯惇', 7350, 1746, '坦克')) 或者使用executemany()来批量插入数据：
cur.executemany('insert into heros values(?, ?, ?, ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74760212ec0d421dc90e512048046f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2bed491847258cf9956b3aa4f52ca8/" rel="bookmark">
			Servlet技术之Filter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
例如：第一章 Python 机器学习入门之pandas的使用
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、什么是Filter过滤器？二、FIlter过滤器的使用三、FilterChain（过滤器链）四、基于注解式开发Filter五、Filter的生命周期总结 前言 提示：这里可以添加本文要记录的大概内容：
Filter 过滤器则是 Servlet 技术的一个重要组成部分。它可以拦截请求和响应，在它们到达 Servlet 之前或之后进行预处理和后处理。Filter 过滤器的作用包括权限验证、日志记录、数据加密、缓存处理等。通过使用 Filter，我们可以增强博客系统的安全性、性能和可扩展性。
通过阅读本博客，读者将不仅了解 Servlet 技术和 Filter 过滤器的基本原理，还将掌握如何将它们应用于实际的博客开发中。无论是博客新手还是有经验的开发者，都可以从中受益，并提升自己的技能水平。
让我们一起探索 Servlet 技术的 Filter 过滤器的世界，为构建更优秀的博客系统而努力吧！
提示：以下是本篇文章正文内容，下面案例可供参考
一、什么是Filter过滤器？ Filter（过滤器）是一种 Java 服务器端技术，用于拦截和处理 HTTP 请求和响应。它是 Java Servlet 规范的一部分，允许开发者在请求到达 Servlet 之前或响应离开 Servlet 之后对其进行预处理和后处理。
Filter 过滤器就像是网站或者应用程序的门卫。它会检查每一个进出的请求和响应，决定是否允许它们通过。想象一下，你有一个房子，你想让只有你认识的人才能进来。那么你可以在门口设置一个 Filter，当有人来敲门时，Filter 会先检查这个人是否是你认识的，如果是，就放他进来；如果不是，就把他拦住。
在网站或者应用程序中，Filter 也会做类似的事情。它会检查每一个请求和响应，看看它们是否符合某些条件。如果符合，就允许它们通过；如果不符合，就进行一些处理，比如拒绝请求、修改响应等。
二、FIlter过滤器的使用 创建一个Class实现Filter接口，并实现接口中三个抽象方法。
init()方法：初始化方法，在创建Filter后立即调用。可用于完成初始化动作。doFilter()方法：拦截请求与响应方法，可用于对请求和响应实现预处理。destroy()方法：销毁方法，在销毁Filter之前自动调用。可用于完成资源释放等动作。 下面是一个简单的示例，展示了如何创建一个 Filter 并在项目中使用它：
1.创建一个名为CustomFilter的类，实现Filter接口：
import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; public class CustomFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws ServletException, IOException { // 在这里编写过滤逻辑 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2bed491847258cf9956b3aa4f52ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69824b319e2b921b7a175ff9af1b3e0/" rel="bookmark">
			Android---Kotlin 学习009
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承 在 java 里如果一个类没有被 final 关键字修饰，那么它都是可以被继承的。而在 kotlin 中，类默认都是封闭的，要让某个类开放继承，必须使用 open 关键字修饰它，否则会编译报错。此外在子类中，如果要复写父类的某个方法，需要用到关键字 Override（在 kt 中就不是注解了）。并且被复写的方法也需要用 open 关键字来修饰。
open class Product(var name : String){ fun description() = "Product: $name" open fun load() = "Nothing..." } class LuxuryProduct : Product("Luxury"){ override fun load(): String = "LuxuryProduct loading...." } fun main() { val luxuryProduct : Product = LuxuryProduct() println(luxuryProduct.load()) } 类型转换
kotlin 的 is 运算符是个不错的工具，可以用来检查某个对象的类型。
val p : Product = LuxuryProduct() println(p.load()) // is 类型检测 println(p is Product) println(p is LuxuryProduct) println(p is File) 类型转换，用到关键字 as 智能类型转换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a69824b319e2b921b7a175ff9af1b3e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0faf8c76fab378e98fed06be5b0568d4/" rel="bookmark">
			性能测试工具Jmeter你所不知道的东西····
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈到性能测试，大家一定会联想到Jmeter和LoadRunner,这两款工具目前在国内使用的相当广泛，主要原因是Jmeter是开源免费，LoadRunner 11在现网中存在破解版本。商用型性能测试工具对于中小型企业很难承担相关的费用。国内的性能测试工具有：CPTS(华为）、kylinTOP（奇林）、PTS（阿里）等，国外的性能测试工具LoadRunner相对比较出名。Loadrunner在国内出名的原因主要还是因为LoadRunner 进入中国的市场比较早，而且网上还存在破解版本。现在我们主要研究一下Jmeter工具。网络上经常看到网友们抱怨Jmeter工具测试的结果不准，而为什么不准都是丈二的和尚摸不着头脑。那么今天我就和网友们分享一下Jmeter工具在使用上到底有什么限制，以期对网友们有帮助，提高对Jmeter工具的认知。
Apache软件基金会（ASF）是一家总部位于美国的非营利性慈善组织。ASF的所有产品都通过公共论坛的在线协作开发，并从美国境内的中央服务器分发。Jmeter是ASF的一款开源免费软件 ，在国内被很多中小公司当作性能测试工具广泛使用。该款工具的本意不是用于性能测试，而是用于开发人员的接口功能调试使用。
Jmeter做性能或压力测试，首先要建立一个线程组，如果需要事务在线程组内再添加事务，然后根据需要可以设置并发的虚拟用户数。Jmeter构造并发虚拟用户的技术路线是通过构造线程，每个线程同时运行相同的线程组。为了弄清楚jmeter统计结果不准确，首先我们要搞清楚Jmeter对线程组中的HTTP请求运行的机制。
1、 测试思路
步骤1：使用Jmeter录制一个web页面
步骤2:建立测试计划，各自运行脚本一次，运行的过程通过（wireShark抓包）
步骤3：通过对wireShark网络抓包结果分析HTTP请求的顺序。
步骤4：wireShark抓包获得的HTTP请求顺序与浏览单独访问URL时的幕布对比。
2、选择被测试对象
基于以上思路我们从网络上选取一个web URL(HTTP://cloud.10oa.com/trial/view/catalogue.aspx)作为被测试对象
3、脚本录制同时F12打开Chorme的network选项
通过Jmeter 5.1工具自带的代理录制功能，录制上述URL，在录制的过程中按F12键，切换到network选项。
注意：Jmeter录制时必须按F12,把chrome的network打开才录制到完整的HTTP请求，否则可能只能录制到第1条请求。
Jmeter脚本录制时的页面HTTP瀑布图
4、执行性能测试计划 单击Jmeter的测试计划启动按钮，单用户启动执行一次脚本
注：此图通过wireShark的网络抓包获得HTTP请求的开始与结束时间，再通过excel画出瀑布图
5、测试结果分析
从Jmeter的测试计划执行结果的wireShark抓包分析的瀑布图看，Jmeter对HTTP请求是按串行下发请求（前一个请求返回结束，下一请求才开始下发请求），并发数为1个HTTP,从开始执行到最后执行结束，用时超过3秒钟，真实浏览器单独访问URL时长在1秒左右。
Jmeter可用于开发人员在产品开发中的功能调试使用并做一些非定量的性能测试，不适用于测试人员做定量的性能测试，更不能以此测试结果输出测试结论误导他人。
如果web服务器对外提供的服务是纯HTTP接口功能(非web页面），且用户的访问是线性的（串行该问），则可以考虑使用Jmeter测试。即使web服务器对外提供的服务是纯HTTP接口功能(非web页面）,如果用户访问是非线性，那么测试的结果也是不可靠的。记住一点，只有线性的接口请求模型才适用于Jmeter。
总结： 感谢每一个认真阅读我文章的人！！！
作为一位过来人也是希望大家少走一些弯路，如果你不想再体验一次学习时找不到资料，没人解答问题，坚持几天便放弃的感受的话，在这里我给大家分享一些自动化测试的学习资源，希望能给你前进的路上带来帮助。
软件测试面试文档 我们学习必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba51662f8115551750aa0f8f2953ec8/" rel="bookmark">
			W5500-EVB-Pico评估版介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 概述2 板载资源2.1 硬件规格2.2 硬件规格2.3 工作条件 3 参考资料3.2 原理图3.3 尺寸图 (单位 : mm)3.4 参考例程 4 硬件协议栈优势 1 概述 W5500-EVB-Pico是基于树莓派RP2040和完全硬连线TCP/IP控制器W5500的微控制器开发板-基本上与树莓派Pico板相同，但通过W5500芯片增加了以太网功能。
2 板载资源 2.1 硬件规格 RP2040规格参数 双核Arm Cortex-M0 + @133MHz264KB 高速SRAM和2MB板载内存通过专用QSPI总线最高支持16MB的片外闪存DMA控制器30个GPIO引脚，其中4个可用作模拟输入（12位精度）2路UART、2个SPI控制器和2个I2C控制器、16路PWM通道、1个定时器、1个RTC8个可编程I/O(PIO)状态机 W5500是一款高性价比的以太网芯片，其全球独一无二的全硬件TCPIP协议栈专利技术，解决了嵌入式以太网的接入问题，简单易用，安全稳定，是物联网设备的首选解决方案。
W5500芯片规格参数 全硬件TCPIP协议栈 支持TCP,UDP,ICMP,IPv4,ARP,IGMP,PPPoE协议硬件协议栈不受网络攻击，安全稳定 8个独立的硬件Socket，各路通信互不影响32KB片上缓存供TCP/IP包处理集成802.3以太网MAC集成10BaseT / 100Base-T以太网PHY主机接口:SPI高速串行外设接口（最高80Mhz ）低功耗，工作温度40℃左右支持嵌入式操作系统：Linux &amp; RTOS支持掉电模式 &amp; UDP网络唤醒工作电压3.3V，I/O 5V耐压支持自动协商（全/半双工，10M/100M) Micro-USB B接口，用于供电和下载程序3针ARM串行线调试(SWD)端口内置RJ45接口内置LDO 2.2 硬件规格 如上图所示，W5500-EVB-Pico引脚直接连接到RP2040的GPIO。它具有与树莓派Pico板相同的引脚。但是，GPIO16、GPIO17、GPIO18、GPIO19、GPIO20、GPIO21连接在板内的W5500上。这些引脚使SPI通信与W5500使用以太网功能。如果您正在使用以太网功能，这些引脚不能用于任何其他目的。
W5500-EVB-Pico内部使用的RP2040 GPIO如下表所示:
I/O引脚名描述IGPIO16连接W5500的MISO接口OGPIO17连接W5500的CS接口OGPIO18连接W5500的SCLK接口OGPIO19连接W5500的MOSI接口OGPIO20连接W5500的RSTn接口IGPIO21连接W5500的INTn接口IGPIO24VBUS检测接口OGPIO25用户LED口IGPIO29用于ADC模式检测VSYS/3 除了GPIO和接地引脚外，还有7个其他引脚接口：
引脚号引脚名描述PIN40VBUSMicro-USB输入电压，连接到Micro-USB接口引脚1。理论上支持5V。PIN39VSYS主系统输入电压，可在4.3V到5.5V的允许范围内变化，由板载LDO产生3.3V。PIN373VE_EN连接到板载LDO使能引脚。要禁用3.3V(也使RP2040和W5500断电)，将此引脚短至低。PIN363V3主3.3V电源给RP2040和W5500，由板载LDO产生。PIN35ADC_VREFADC电源(和参考)电压，并在W5500-EVB-Pico上通过滤波3.3V电源产生。PIN33AGNDGPIO26-29接地参考。PIN30RUNRP2040使能引脚，复位RP2040，将该引脚短至低。 2.3 工作条件 属性参数工作温度-20℃~85℃Micro-USB输入电压DC 5V（+/- 10%)输入电压DC 4.3V~5.5V 3 参考资料 RP2040 数据手册：RP2040 datasheet
W5500数据手册：W5500 datashee
3.2 原理图 3.3 尺寸图 (单位 : mm) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eba51662f8115551750aa0f8f2953ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f0f83523ff8e28a02d20a43143fdff/" rel="bookmark">
			实用性极强的MySQL查询优化策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在程序上线运行一段时间后，一旦数据量上去了，或多或少会感觉到系统出现延迟、卡顿等现象，出现这种问题，就需要程序员或架构师进行系统调优工作了。 其中，大量的实践经验表明，调优的手段尽管有很多，但涉及到 SQL调优的内容仍然是非常重要的一环，本文将结合实例，总结一些工作中可能涉及到的 SQL优化策略。 一、查询优化 可以说，对于大多数系统来说，读多写少一定是常态，这就表示涉及到查询的SQL是非常高频的操作。
前置准备：给一张测试表添加10万条数据。
使用下面的存储过程给单表造一批数据，将表换成自己的就好了。
create procedure addMyData() begin declare num int; set num =1; while num &lt;= 100000 do insert into XXX_table values( replace(uuid(),'-',''),concat('测试',num),concat('cs',num),'123456' ); set num =num +1; end while; end ; 然后调用该存储过程：
call addMyData(); 本篇准备了3张表，分别为学生（student）表，班级（class）表，账户(account)表，各自有50万，1万和10万条数据用于测试。
二、分页查询优化 分页数量非常大时，查询比较耗时，比如查询student表，使用下面的sql查询，耗时达到0.2秒。
一般越往后，分页查询效率越低，这就是分页查询的问题所在， 因为，当在进行分页查询时，如果执行 limit 400000,10 ，此时需要 MySQL 排序前4000 10 记录，仅仅返回400000 - 4 00010 的记录，其他记录丢弃，查询排序的代价非常大。
优化思路：
一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。
1.在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容
SELECT * FROM student t1,(SELECT id FROM student ORDER BY id LIMIT 400000,10) t2 WHERE t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f0f83523ff8e28a02d20a43143fdff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1c3162d98511a5c00152af9fa12826/" rel="bookmark">
			【c&#43;&#43;】入门2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数重载 函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这
些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型
不同的问题。
c++区分重载函数是根据参数的不同，个数的不同，类型的不同，顺序的不同。
1.参数的类型不同 int Add(int left, int right) { cout &lt;&lt; "int Add(int left, int right)" &lt;&lt; endl; return left + right; } double Add(double left, double right) { cout &lt;&lt; "double Add(double left, double right)" &lt;&lt; endl; return left + right; } 2.参数的个数不同 void f() { cout &lt;&lt; "f()" &lt;&lt; endl; } void f(int a) { cout &lt;&lt; "f(int a)" &lt;&lt; endl; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1c3162d98511a5c00152af9fa12826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff58d9ff0db638811de7483ee9fc53ad/" rel="bookmark">
			[PyTorch][chapter 8][李宏毅深度学习][DNN 训练技巧]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
DNN 是神经网络的里面基础核心模型之一.这里面结合DNN 介绍一下如何解决
深度学习里面过拟合,欠拟合问题
目录：
DNN 训练常见问题 过拟合处理 欠拟合处理 keras 项目 一 DNN 训练常见问题
我们在深度学习网络训练的时候经常会遇到下面两类问题：
1： 训练集上面很差 ： 欠拟合
2： 训练集上面很好, 测试集上面很差： 过拟合
二 过拟合解决
过拟合解决方案
主要有以下三个处理思路
1 Early Stopped
2 L1 L2 正规化
3 Dropout
4： 增加训练集上面的数据量
2.1 Early Stopping
方案
这个数据集分为3部分： Training Data,validation data,Test Data
1 将训练的数据分为Training Data 和validation data
2 每个epoch结束后（或每N个epoch后)：计算validation data 的 accuracy 3: 更新 最优 validation data accuracy 对应的网络参数
3 随着epoch的增加，如果validation data 连续多次没有提升，则停止训练；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff58d9ff0db638811de7483ee9fc53ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c8b8e0ad82c5b24b46e697cc94884b/" rel="bookmark">
			【深度学习-目标检测】01 - R-CNN 论文学习与总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：Rich feature hierarchies for accurate object detection and semantic segmentation
论文学习 摘要（Abstract） 对象检测性能的现状： 在PASCAL VOC数据集上测量的对象检测性能在过去几年已经达到了一个高点。最佳性能的方法通常是复杂的集成系统，结合了多种低级图像特征和高级上下文。 R-CNN方法的提出： 作者提出了一种简单且可扩展的检测算法，该算法在VOC 2012上的平均精度均值（mAP）比之前的最佳结果提高了30%以上，达到了53.3%。这种方法结合了两个关键见解： 可以将高容量的卷积神经网络（CNN）应用于自下而上的区域提议，以定位和分割对象 （将CNN应用到目标检测领域）。当标记训练数据稀缺时，针对辅助任务的监督预训练，随后进行特定领域的微调，可以显著提升性能。（应用预训练模型+微调 可以显著提高性能） R-CNN的命名与特点： 由于这种方法结合了区域提议（Region Proposal）和CNN，因此被称为R-CNN（带有CNN特征的区域）。论文还展示了一些实验，提供了对网络学习内容的洞察，揭示了一个丰富的图像特征层次结构。 1. 引言（Introduction） 在这部分作者强调了特征在视觉识别任务中的重要性，提出了以CNN为特征提取网络的想法。
特征的重要性 过去十年，视觉识别任务的进展很大程度上依赖于 SIFT（尺度不变特征变换）以及 HOG（方向梯度直方图）等特征的使用，尽管这些特征在多个视觉任务中表现出色，但是在PASCAL VOC这一经典的视觉识别任务中，2010-2012年的进展相对来说比较缓慢。SIFT（尺度不变特征变换）与HOG（方向梯度直方图）与视觉通路中初级皮层区域V1的复杂细胞相关联，但是实际上识别过程发生在多个阶段，通过这两种方式获得的特征还不够拥有足够的信息量。
（过去目标检测用的SIFT以及HOG，发展缓慢，且效果不好）CNN在2012年AlexNet网络中发挥了非常大的作用，展示出了CNN在图像分类上任务的优秀性能，是提取特征的优秀的方式，在提高目标检测性能方面具有很大的潜力。（CNN提取特征效果号，CNN有希望取代这两种方式以获取更有信息量的特征） CNN在对象检测中的应用与关联 CNN的兴起，2012年因为AlexNet的提出，并且在ImageNet竞赛中，展现出了CNN在图像分类上的强大能力，标志CNN在视觉识别领域的重要进展。在ILSVRC 2012研讨会上，展开了激烈的讨论，特别是关于CNN在图像分类上的成果能在多大程度上推广到PASCAL VOC挑战上的对象检测中。作者通过将图像分类和对象检测之间的差距桥接起来，明确的回答了这个问题，在这篇论文中展示了CNN可以显著提高对象检测性能的研究，从而证明了CNN在对象检测任务中的有效性和潜力。 2. 对象检测与R-CNN R-CNN方法概述 R-CNN方法的核心： R-CNN 方法结合了 区域提议（Regin Proposals) 和 卷积神经网络（CNN）的特征。这种方法通过在测试的时候生成大约2000个类别独立的区域提议，然后使用CNN从每个区域提议中提取固定长度的特征向量，并且使用线性SVM（支持向量机）对每个区域进行分类。 R-CNN的设计和效率： R-CNN 使用一种简单的技术（仿射图形变形）从每个提议区域中计算固定大小的CNN输入，不论区域的形状如何。（使用这种技术统一了不同大小尺寸的区域提议的特征向量大小）系统的设计使得类别特定的计算仅包括相对较小的矩阵-向量乘积和贪婪的非最大抑制，这是由于特征在所有类别中共享，并且维度比以前使用的区域特征低两个数量级。 R-CNN的训练挑战： 在对象检测中面临的一个挑战是标记数据稀缺，现有的数据量不足以训练大型CNN模型。作者提出的解决方案是：先在大型辅助数据集上进行监督预训练，然后在特定领域的小数据集上进行微调。（使用预训练+微调可以改善数据稀缺的问题，并且能够提高性能） R-CNN的性能提升： 在PASCAL VOC 2010 数据集上，经过微调后R-CNN系统在平均精度上达到 54%，相比于之前基于HOG的模型 33% ，有显著提升。（R-CNN 比 HOG等模型更优秀） R-CNN的应用拓展： 由于R-CNN在区域上操作，自然可以将其扩展到语义分割任务。经过轻微修改后，R-CNN在PASCAL VOC分割任务上也取得了最先进的结果。（R-CNN也能在分割任务获得不错的表现）
区域提议与特征提取 区域提议（Region Proposals）: R-CNN 首先生成大约2000个类别独立的区域提议，这些提议定义了检测器可用的候选检测集。为了生成这些区域提议，R-CNN 使用了多种方法，主要方式是 选择性搜索（Selective Search）方法。 特征提取（Feature Extraction）: 对于每一个区域提议，R-CNN 使用一个大型卷积神经网络（CNN）来提取固定长度的特征向量。这些特征向量随后被用于后续的分类过程。 特征向量的计算： R-CNN 通过一种简单的技术（仿射图像变形）从每个区域提议中计算固定大小的CNN输入，无论区域的形状如何。这种方法允许从各种形状和大小的区域中提取一致的特征表示。 测试时检测 在测试的时候，会使用选择性搜索（Selective Search）方法在测试图像中提取大约2000个区域提议，这些区域提议定义了检测器可用的候选检测集。对于每个区域提议，通过CNN前向传播来提取特征向量，然后对于每个类别，使用该类别训练的SVM对提取的特征向量进行评分。在得到所有的区域提议的评分后，R-CNN会对每个类别独立的应用非极大抑制（NMS），通过这个步骤排除拒绝那些与得分更高的选定区域具有较高交并比（IOU）重叠的区域。 运行时分析 检测效率的关键属性： 首先，所有CNN参数在所有类别之间共享。CNN计算的特征向量维度较低。 计算时间的分配： 生成区域提议和计算特征的时间在所有类别中被摊销（在GPU上为每张图像13秒，在CPU上为53秒）。类别特定的计算仅包括特征与SVM权重直接按的点积运算和非极大抑制（NMS）。 R-CNN的可拓展性： R-CNN 可以拓展到数千个对象类别，无需使用近似技术（如哈希）即使有10万类别，相关的矩阵乘法在CPU上只需要10秒。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c8b8e0ad82c5b24b46e697cc94884b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7720b96b7f941a2f8074f58910962721/" rel="bookmark">
			相比国科云解析，传统DNS解析技术有哪些局限性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域名系统（DNS）作为互联网的重要基础设施，其解析技术的优劣直接影响到用户访问网站的速度和服务器的性能。传统的DNS解析技术由于其局限性，已经无法满足现代网站的解析需求。国科云解析作为一种基于云技术的新兴DNS解析技术，具有更好的解析性能和安全性。本文对传统解析技术的局限性和云解析的优势做下分析介绍。
一、传统DNS解析技术的局限性
1.查询性能较低
传统解析技术的查询性能较低，解析速度比较慢。传统DNS解析技术往往只有单个服务器，导致用户发起解析请求时，无论距离远近，都由单一服务器给出响应，这就可能导致从发起请求到得到响应，会经过非常多的路由跳数，产生较大的解析时延，进而影响用户访问网站的体验。
2.负载均衡能力不足
传统DNS解析技术缺乏高效的负载均衡能力，只能根据简单的轮询机制将流量随机分配给不同的服务器，无法根据服务器的实际性能作出智能调度，这就可能导致某些服务器过载而有些服务器空闲的情况，容易造成线路的拥堵或宕机，以及服务器资源的浪费，影响网站的稳定性。
安全防护能力较弱
由于DNS协议本身存在安全漏洞，传统DNS解析技术容易受到DNS缓存投毒的威胁，无法应对DNS劫持带来的安全风险。此外，传统DNS解析在应对DDoS攻击、QPS查询攻击等方面防护能力较弱，在遇到大流量请求或DDoS攻击时，很容易发生线路拥堵或宕机。
可扩展性较差
由于DNS服务器中存储了大量域名和IP地址的映射关系，随着网站规模的扩大，DNS服务器必须进行扩容和升级，才能满足解析所需，维护成本非常高。此外，传统解析技术缺乏对动态加载和自动化的支持，无法适应快速变化的互联网环境。
二、云解析服务的优势和应用场景
相比之下，云解析服务具有更好的性能、可扩展性和安全性等方面的优势，能够更好地满足现代网站的需求。
高性能解析
云解析采用分布式架构和缓存机制，能够大幅提升DNS解析的性能和响应速度。通过将域名映射信息分布式存储在多个节点上，云解析服务可以就近响应用户的查询请求，避免了冗余和重复的查询请求，查询效率大幅提升。
安全防护能力更强
云解析采用高防DNS技术，利用流量清洗、弹性带宽和DDoS防火墙等技术，有效应对DDoS攻击、QPS查询等攻击的威胁。此外，云解析支持DNSSEC安全验证，能够对解析记录进行签名，防止攻击者利用DNS缓存投毒进行DNS劫持，确保解析的准确性，避免各种形式的重定向威胁。
良好的扩展性
云解析基于云计算平台构建，可利用云计算平台的弹性伸缩和动态调度能力，进行自动扩容和升级，避免因网站规模扩大而导致服务器压力剧增，造成线路拥堵，无法及时响应请求，同时又降低了维护成本，提高了资源利用率。
智能DNS功能强大
云解析服务可以实现强大的智能DNS功能。它可以根据用户的地理位置、网络环境和访问请求等因素进行智能调度，将用户请求调度到最佳的服务器节点上，提高用户的访问速度和网站的性能。同时，云解析服务还可以根据用户的行为和偏好进行个性化推荐和服务优化，提高用户体验和网站的商业价值。
综合运维管理能力强
云解析服务提供了强大的综合运维管理能力。它支持对域名、子域名、CNAME等资源的全面管理和配置，可以方便地进行域名添加、修改和删除等操作。同时，云解析服务还支持日志监控和告警通知等功能，方便管理员对域名系统的运行状态进行实时监控和管理。这样既提高了运维效率又降低了管理成本。
综上所述，传统解析技术已经无法满足各行业用户对安全解析、智能解析的迫切需求，云解析在解析速度、精度、安全性和稳定性方面有着明显的优势，逐渐替代传统解析应用于一些重点领域之中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3ad581ee463c02281e2ed201150db8/" rel="bookmark">
			外卖管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着外卖订餐在高校越来越普及，传统的电话订餐给顾客跟外卖店带来不方便，如何使订餐更快速，更方便已成为众多高校学生关注的问题了。本外卖订餐管理系统是针对高校外卖店进行具体的需求分析，采用OOA（面向对象分析）和采用UML工具辅助开发分析，基于S2SH（Struts2+Spring+Hibernate）架构进行设计和开发。论文主要描述外卖订餐管理系统的开发流程，分别从需求分析和系统设计、详细设计与系统实现这几个阶段进行描述。
关键词：订餐管理系统 S2SH OOA
ABSTRACT
With more and more popular in universities order take-out, due to the traditional telephone reservation for customers to bring inconvenience take-away meal, how to make more quickly, more convenient has become the concern of the students. The take-away meal management system in colleges and universities is the concrete take-away demand analysis, using object-oriented analysis (OOA) and using UML tools to assist in the development, using Struts2-Spring-Hibernate framework to design and development.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3ad581ee463c02281e2ed201150db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699ad2e7e38a4ee4dbf3116af0fcfcb0/" rel="bookmark">
			Spark生产集群各种使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境配置 1.1 版本说明 要求版本是否必须其他事项Hadoop3.3.4是hadoop3.3.0之后原生支持国内主要对象存储Hive3.1.3否实测没有Hive也可以使用sparksql，使用hive更好的管理HDFS数据spark3.3.1是hive和spark整合后，语法为HSQL，自定义函数按照hive使用即可 1.2 相关介绍官网 Hadoop官网：https://hadoop.apache.org/docs/r3.3.4/hadoop-cos/cloud-storage/index.html
腾讯对象存储cos使用官网：https://cloud.tencent.com/document/product/436/6884
spark使用官网文档：https://spark.apache.org/docs/3.3.1/sql-ref.html
hive使用官网文档：https://cwiki.apache.org/confluence/display/Hive/Home#Home-UserDocumentation
2. 使用实例 2.1 spark集群操作doris集群 脚本实例
vim test.sh #!/bin/bash dori_test=" CREATE TEMPORARY VIEW spark_doris1 USING doris OPTIONS( 'table.identifier'='demo.t1', 'fenodes'='xxx:8030', 'user'='root', 'password'='xxx' ); CREATE TEMPORARY VIEW spark_doris2 USING doris OPTIONS( 'table.identifier'='demo.t2', 'fenodes'='xxx:8030', 'user'='xxx', 'password'='xxx' ); INSERT INTO spark_doris1 select * from spark_doris2; " spark-sql -e "$dori_test" nohup ./test.sh &gt; ./logs.text 2&gt;&amp;1 &amp; 2.2 spark集群同时操作doris集群和hive集群 vim test.sh #!/bin/bash dori_test=" set spark.debug.maxToStringFields=200 set spark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699ad2e7e38a4ee4dbf3116af0fcfcb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c799ee59520cd76b6d352a78c9aabc04/" rel="bookmark">
			图书管理系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
图书管理系统是典型的信息管理系统(MIS),其开发主要包括后台数据库的建立和维护以及前端应用程序的开发两个方面。对于前者要求建立起数据一致性和完整性强、数据安全性好的库。而对于后者则要求应用程序功能完备,易使用等特点。
因此本人结合开入式图书馆的要求，对MS SQL Server2000数据库管理系统、SQL语言原理、.NET应用程序设计进行了较深入的学习和应用，主要完成对图书管理系统的需求分析、功能模块划分、数据库需求分析，并由此设计了数据库结构和应用程序。系统运行结果证明，本文所设计的图书管理系统可以满足借阅者、图书馆工作人员的双方面的需要。
目录
一、 设计的目的和内容 1
二、 系统需求分析 1
三、 系统总体设计 1
3.1 总体功能结构图 1
3.2 系统流程图 2
四、 数据库设计 3
4.1 需求分析及数据字典 3
4.2 概念设计 4
4.3 逻辑设计 5
4.4 物理设计 6
4.5 SQL语句的实现 6
4.6 创建视图 7
4.7 创建存储过程 8
4.8 创建触发器 9
五、 使用ER/STUDIO完成数据库设计 10
六、 代码实现 11
6.1 “图书管理系统”的功能模块图 11
6.2 插入功能的实现 11
6.3修改/删除功能的实现 11
6.4 查询功能的实现 11
七、 总结 30
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c799ee59520cd76b6d352a78c9aabc04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65fc4d6edba6efca9d78832859e900b/" rel="bookmark">
			芯旺微chipon KF32A156系列 IIC（I2C）模块的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文免费开放，也请尊重原创，转载需注明源出处！！！ 芯旺微chipon KF32A156系列 IIC（I2C）模块的基本使用 我们在实际的使用过程中，IIC也是较为常用的通讯方式，像eepron，传感器等会使用到这种通讯方式。
当然啦，很多工程师也会喜欢使用IO口模拟IIC来做通讯，毕竟很多片子的IIC真的很不好用，而且这个IO口模拟的方式可移植性也是比较强，开源的代码也比较多，本文章主要是说说芯旺微CHIPON156型号的硬件IIC外设，以供参考。
**本次主要讲解IIC外设的使用，文章使用中断收发的方式来对芯旺微32位机的KF32A156系列配置为主机、从机进行讲解。**本篇幅较长，需要耐心看完。
如有需要工程代码，还请私聊留下联系方式邮箱等。本文主要是接口函数代码
主机配置（以7位地址配置讲解） 这里强烈建议，做为主机使用时，尽量使用主循环发送接收的方式，同步通讯，可以不用太担心被其他中断打断导致数据不正确。本次主要在讲解这种方式。
**配置步骤：**老生常谈三步骤 1、配置IO口：将对应的IO口进行重映射模式，并重映射为IIC（iic_sck,iic_sda）.本文以PG0和PF15为例，由于demo板没有外部上拉，注意下引脚要配置为开漏模式，并启用内部上拉，程序如下：
void I2c_IO_Init() { GPIO_InitTypeDef GpioConfigPtr; /* Configure GPIO remapping function */ GpioConfigPtr.m_Mode = GPIO_MODE_RMP; /* Configyre GPIO open drain output */ GpioConfigPtr.m_OpenDrain = GPIO_POD_OD; /* PG0,SCL */ GpioConfigPtr.m_Pin = GPIO_PIN_MASK_0; /* Configure pull up */ GpioConfigPtr.m_PullUp = GPIO_PULLUP; /* Configure drop down */ GpioConfigPtr.m_PullDown = GPIO_NOPULL; /* Configure PG0 as I2C0 SCL */ GPIO_Pin_RMP_Config(GPIOG_SFR, GPIO_Pin_Num_0, GPIO_RMP_AF5); GPIO_Configuration(GPIOG_SFR, &amp;GpioConfigPtr); /* PF15,SDA */ GpioConfigPtr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65fc4d6edba6efca9d78832859e900b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba4401f4ba7edbb62933aa710187299/" rel="bookmark">
			芯旺微chipon IDE KF32 IDE的工程编译，工程调试debug的使用基本教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文免费开放，也请尊重原创，转载需注明源出处！！！ 芯旺微chipon IDE KF32 IDE的工程编译，工程调试debug的使用基本教程 使用芯旺微的工程师们你们好，本篇主要介绍一下IDE的基本使用以及常用的功能，比如编译，下载，debug调试。
（一）头文件路径的导入 这是最基础的工作，上一篇我们新建了最小工程但是并没有把固件库添加进来。这里来详细介绍
1、将芯片厂FAE发来的库文件复制粘贴进来，切记保持所有的文件复制都是通过IDE界面操作进来的，而不是直接粘贴到workspace里面。 1 、如下图 芯片厂提供的两个库文件和两个时钟文件
2、 右键工程 ---- 点击粘贴
3、将文件粘贴进来后再次 右键工程 — 属性
4、按照图示步骤，还请选择正确
5、安图操作选择工作空间 ； 可以使用相对路径，这样你发给别人工程的话别人使用也方便。
6、选择inc文件，这里都是库的头文件 ； 如果后续自己增加的H文件也是需要将路径引进来的，不过到那个时候应该使用的很熟悉了。
7 、 切记先 点击应用 ---- 点击确定
好啦，到这里，你就已经把头文件添加完成了，请记住如有其他头文件路径需要添加也请从这里添加哦。
简单介绍一下界面的说明
（二）编译下载 此步骤请确保烧录器和开发板已经连接完毕
1、选中release模式进行编译，点击 编译按钮 等待编译完成，得到如下图
点击下载程序即可将程序下载至芯片中。至此编译下载步骤完成，怎么样，操作很上手吧！
（三）debug调试程序 1、首先编译那里切换为debug模式，点击编译 — 点击 debug按钮
2、选择 是
3、简单介绍一下debug界面
说明一下，当前32位的 IDE 支持断点数为 4 个断点。
好啦，以上就是关于KF32 IDE的基本操作就全部介绍完了，其他还请参考其他两篇。本文时间20221128
欢迎建议或者问题方面的私聊本人 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1506c2397a001cfe4bfa4dbaa7826da1/" rel="bookmark">
			芯旺微chipon IDE KF32 IDE安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创扣字不易，请尊重原创，转载需注明源出处！！！ 芯旺微chipon的编辑环境IDE和编译环境安装教程
使用chipon的小伙伴们大家好，我是阿范，网上关于chipon的资料并不多，本人后续会做芯旺微的IDE使用，外设使用，以及相关的应用进行详细解说。由于时间有限，均以32为为例来说的。关于8位机有疑问可以私聊我讨论，看到都会回。
那今天主要来说说32位机IDE的安装和使用，以方便大家快速入手。本质上也是基于eclipse的编辑环境和GCC编译器，所以熟悉的工程师会更容易上手。其实chipon的安装是比较简单的，无需要license，下一步下一步较多。
安装步骤 先去官网下载IDE的安装包，附上链接：
IDE官网下载链接
选择如图所示的两个，一个是集成环境IDE,一个是批量烧写上位机PRO
两者的理解可以相似理解为ST的STVP和STVD
下载完成后，两个安装包，直接解压，点击对应的EXE文件。
如图片步骤：
1、
2、偶尔会有杀毒软件拦截，建议安装前将杀毒软件关掉。
3 安装路径自己可以选择，尽可能保持不带中文，下一步下一步即可，最后会弹框安装烧录器驱动，这些全部都接受，下一步直到最后即可。
4、双击该图标，
5、弹出，点击 KF32 IDE
6、这里注意 ：
（1）工作空间路径一定不要带中文路径
（2）缺省值尽量不要选中，不要选中，不要选中。选中了切换空间麻烦，虽然无意选中后还能去里面配置但是尽量避免这样的麻烦。
（3）配置ok后点击确定。
7、好啦，你现在所处的位置界面就是芯旺微chipon的IDE界面啦。这将是你使用chipon芯片天天见的软件啦。
最后再提一下PRO软件的，这里不详细说了，因为基本都是下一步下一步。安装完成后的界面如图：
本次安装教程就到此结束啦。本次时间节点20221120 。
欢迎建议或者问题方面的私聊本人 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc83cd8ccd3e203e561f961390f9ffaf/" rel="bookmark">
			0011__三分钟带你快速学习RGB、HSV和HSL颜色空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三分钟带你快速学习RGB、HSV和HSL颜色空间 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a13f54823030614e9a65053849c819/" rel="bookmark">
			开源地震处理软件Seismic Unix（SU）安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Seismic Unix（SU）是著名的开源地震处理软件。
不同版本的SU安装在不同的系统，教程会有一些区别。下面以SU44R18为例，系统为Ubuntu 18.04。
SU44R18安装包可从以下链接下载：cwp_su_all_44R18.tar
其他版本的SU可以从https://nextcloud.seismic-unix.org/s/LZpzc8jMzbWG9BZ下载。
1. 更新源 sudo apt-get update 2. 安装依赖 依次执行以下命令，遇到y/s选y。
sudo apt-get install build-essential -y sudo apt-get install libx11-dev -y sudo apt-get install libxt-dev -y sudo apt-get install freeglut3 -y sudo apt-get install freeglut3-dev -y sudo apt-get install libxmu-dev -y sudo apt-get install libxi-dev -y sudo apt-get install gfortran -y sudo apt-get install csh -y 3. 解压安装包 在home路径下建一个安装文件夹（usrname代表自己的用户名），自己命名，比如cwp:
cd ~ mkdir cwp 将压缩包放在/home/usrname/cwp/路径下，解压：
cd ~/cwp tar -zxvf cwp_su_all_44R18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a13f54823030614e9a65053849c819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c845d0aec44714572c5c882a5388f4/" rel="bookmark">
			提升FTP上传速度的方法（提升FTP下载速度的技巧）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在企业日常经营中，快速上传和下载文件至关重要。然而，在使用FTP（文件传输协议）进行文件传输时，速度可能成为瓶颈。为了提升工作效率，以下是一些建议，可以帮助企业提高FTP上传下载速度。
1、确保网络连接稳定高速，选择具备高带宽和低延迟的网络连接，可以显著提升文件上传和下载速度。同时，使用支持多线程的FTP客户端，能够充分利用带宽，进一步提高传输速度。
2、优化FTP服务器设置，通过配置FTP服务器的数据传输模式，可以显著提升文件传输速度。FTP客户端通常支持主动和被动模式。在网络环境不稳定或上传速度较慢时，切换到被动模式可能改善某些网络问题。
3、合理设置FTP客户端也有助于提升速度。根据需要增加最大连接数和最大传输速率等参数。同时，关闭不必要的功能和服务，如FTP客户端的身份验证和防火墙功能，以减轻网络负担，提高传输速度。
4、使用专业的FTP加速工具是一个不错的选择。这些工具通过优化网络连接、自动选择最佳路径等方式，提高FTP上传和下载速度。一些工具还具备多线程上传和下载功能，能够大幅缩短文件传输时间。
以镭速(私有化部署方案，也可接入公有云，企业、社会组织用户可申请免费试用)为例，其FTP加速产品是一款FTP加速软件，能直接对接现有FTP服务器系统。使用镭速FTP加速后，传输速度可提升10-100倍，特别是对于已部署了FTP服务器和具备权限控制功能的企业，可在现有基础上实现高速传输。
镭速的FTP加速产品有以下优势：
首先，简单易用，客户端使用方式与普通FTP客户端一致，无需专门学习。服务器端无需改造已有的FTP服务器、用户账号、授权、文件配置等信息。
其次，高性能高效率，镭速Proxy采用事件驱动/异步网络处理模型，单个线程在普通CPU上可支持上千条TCP并发连接处理，最大支持1Gbps的数据吞吐量。智能压缩功能可对文本、程序数据等高压缩文件传输进行优化，帮助节省用户带宽。
最后，镭速加速服务可与常见的负载均衡器配合，通过横向扩展提升系统整体处理性能和可靠性。
总之，在使用FTP进行文件传输时，通过综合运用这些方法，相信企业可以获得更快的FTP上传速度，提高工作效率。使用镭速FTP加速产品，为企业提供简单、高效、安全的文件传输解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b5211accf8250b7e64b185079f3e83/" rel="bookmark">
			BERT的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BERT 1.前言 self-supervised learning是一种无监督学习的特殊形式，算法从数据本身生成标签或者目标，然后利用这些生成的目标来进行学习。（也就是说数据集的标签是模型自动生成的，不是由人为提供的。）例如，可以通过在图像中遮挡一部分内容来创建自监督任务，让模型预测被遮挡的内容。self-supervised learning 应用十分广泛，不仅用于文字方面，还可以用于语音和图像上。
self-supervised Learning 自监督学习的一些模型如下：
ELMO（Embeddings from Language Models）—&gt; 最原始的
BERT（Bidirectional Encoder Representations from Transformers）
ERNIE（Enhanced Representation through Knowledge Integration）
Big Bird（Transformers for Longer Sequences）
GPT-3 —&gt; 有 175 billion 个参数
2.BERT结构 BERT 是一个非常巨大的模型，有340 million 个参数。BERT的架构就是 Transformer 的 Encoder 部分（self-attention，residual，normalization）。
训练BERT有俩种方式：Masking Input 和 Next Sentence Prediction
1.Masking Input
BERT 的输入，某些部分被随机的盖住，盖住有两种方式（随机的选择一种盖住方式）：
MASK：将句中的一些符号换为MASK符号。（这个MASK是一个新的符号，字典中没有的，表示盖住）Random：随机把某一个字换为另外一个字（随机从字典中挑选一个词盖住）。 输入通过BERT后就得到了对应的Sequence（但是只关注输入被盖住所输出的 vector），然后通过Linear transformer（Linear transformer的意思就是乘以一个矩阵），并进行Softmax，就可以得到一个有关所有符号的概率分布。在训练的时候，将真实值与预测出来的值进行对比，通过minimize cross entropy不断缩小损失，进而提升模型的ACU。
2.Next Sentence Prediction
从资料库里面随机选两个句子，在句子中间加入一个特殊符号 [SEP] 来代表分割。在最前面加入一个特别的符号 [CLS]。将这个整体送入BERT中，在得到的sequence中只关注 [CLS] 对应输出的vector。然后经过一个Linear transformer，来进行一个二元的预测（Yes or No），表示这两个句子是否是相连接的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b5211accf8250b7e64b185079f3e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a03c6d2fe3053373e50a2ef0872d3b/" rel="bookmark">
			基于gmime2.6库的邮件解码程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libgmime 是一个用于处理 MIME 数据的 C 语言库。它提供了对 MIME 消息的解析、生成和操作等功能。
下载：https://download.csdn.net/download/farsight_2098/88660821?spm=1001.2014.3001.5503
获取去网上下载：https://mirror.tuna.tsinghua.edu.cn/sourceware/cygwin/x86_64/release/gmime2.6/?C=S&amp;O=A
编译 ./configure;make;
会报错
est-pkcs7.c:36:10: fatal error: gpg-error.h: 没有那个文件或目录
36 | #include &lt;gpg-error.h&gt;
| ^~~~~~~~~~~~~
不影响，
gmime2.6-2.6.23-2.src/gmime-2.6.23$ find ./ -name "lib*.so"
./gmime/.libs/libgmime-2.6.so
已经生成了
简单演示一个宏GMIME_IS_PART的用法，
宏GMIME_IS_PART用于检查一个对象是否是 GMimePart 类型。GMimePart 是 libgmime 中用于表示 MIME 消息或消息部分的类。
在使用 libgmime 库处理 MIME 消息，可能会遇到需要检查一个对象是否是 GMimePart 的情况。这时，可以使用 GMIME_IS_PART 宏来方便地进行类型检查。
#include &lt;gmime/gmime.h&gt; void part_bodystructure (GMimeObject *part) { GMimeParam *param; if (GMIME_IS_MULTIPART (part)) { GMimeMultipart *multipart = (GMimeMultipart *) part; GMimeObject *subpart; int i, n; n = g_mime_multipart_get_count (multipart); for (i = 0; i &lt; n; i++) { subpart = g_mime_multipart_get_part (multipart, i); part_bodystructure (subpart); } } else if (GMIME_IS_MESSAGE_PART (part)) { GMimeMessage *message; const char *str; char *nstring; message = GMIME_MESSAGE_PART (part)-&gt;message; nstring = g_mime_message_get_date_as_string (message); printf ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38a03c6d2fe3053373e50a2ef0872d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4c77cb911f015c0bdd60795860a28c/" rel="bookmark">
			spark：RDD编程（Python版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RDD运行原理 RDD设计背景 许多选代目前的MapReduce框架都是把中间结果写入到稳定存储 (比如磁盘)中带来了大量的数据复制、磁盘IO和序列化开销
RDD就是为了满足这种需求而出现的，它提供了一个抽象的数据架构，我们不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，避免中间数据存储。
RDD概念 一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算
RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集创建RDD，或者通过在其他RDD上执行确定的转换操作(如map、join和group by) 而创建得到新的RDD
RDD提供了一组丰富的操作以支持常见的数据运算，分为“动作”(Action)和“转换” (Transformation)两种类型
RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改(不适合网页爬虫)
表面上RDD的功能很受限、不够强大，实际上RDD已经被实践证明可以高效地表达许多框架的编程模型(比如MapReduce、SQL、Pregel)
Spark提供了RDD的API，程序员可以通过调用API实现对RDD的各种操作
RDD运行过程 通过上述对RDD概念、依赖关系和Stage划分的介绍，结合之前介绍的Spark运行基本流程，再总结一下RDD在Spark架构中的运行过程:
(1)创建RDD对象;
(2)SparkContext负责计算RDD之间的依赖关系，构建DAG;
(3)DAGScheduler负责把DAG图分解成多个Stage，每个Stage中包含了多个Task,每个Task会被TaskScheduler分发给各个WorkerNode上的Executor去执行。
RDD编程基础 1. RDD创建 从文件系统中加载数据创建RDD &gt;&gt;&gt; lines = sc.textFile("file:///opt/spark/mycode/rdd/word.txt") &gt;&gt;&gt; lines.foreach(print) Hadoop is good Spark is fast Spark is better 从分布式文件系统HDFS中加载数据 &gt;&gt;&gt;lines = sc.textFile("hdfs://localhost:9000/user/hadoop/word.txt") &gt;&gt;&gt;lines = sc.textFile("/user/hadoop/word.txt") &gt;&gt;&gt;lines = sc.textFile("word.txt") 三条语句等价
通过并行集合（列表）创建RDD 可以调用SparkContext的parallelize方法，在Driver中一个已经存在的集合（列表）上创建。
&gt;&gt;&gt;array = [1, 2, 3, 4, 5] &gt;&gt;&gt;rdd = sc.parallelize(array) &gt;&gt;&gt;rdd.foreach(print) 1 2 3 4 5 2. RDD操作 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b4c77cb911f015c0bdd60795860a28c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10e51a3c0976e14afaef41aea35c23a/" rel="bookmark">
			【RocketMQ】Console页面报错：rocketmq remote exception，connect to xxx failed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 console报错，无法连接该节点，把该节点杀掉，还是继续报错，重启之后，报错的端口变成11911。
分析 正常一个broker会启动三个端口，不同版本的规律不太一样，4.X版本是：
配置文件中的listenPortlistenPort - 2listenPort + 2 查看配置文件，11911为broker的监听端口。
日志正常，无法定位问题：
尝试修改端口为11919后重启，三个端口都正常了，问题解决：
经测试，非正常杀掉该broker，会复现以上问题，导致三个端口中有一个不能正常建立，该虚机之前非正常重启过，怀疑是什么原因导致进程杀掉后端口没有正常释放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be57688e3a3c6c280eb935011f6a7855/" rel="bookmark">
			一文彻底搞懂“内存管理”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V1.0：直接使用物理地址 最开始的时候，计算机只允许运行一个进程，内存也只有几百 KB 大小，那时候的世界很简单也很美好，保留一部分内存空间给 OS 使用，剩下的都是这个进程的专属空间，想怎么用怎么用，如图 1-1。
本文福利， 免费领取C/C++ 开发学习资料包、技术视频/代码，1000道大厂面试题，内容包括（C++基础，网络编程，数据库，中间件，后端开发/音视频开发/Qt开发/游戏开发/Linuxn内核等进阶学习资料和最佳学习路线）↓↓↓↓↓↓见下面↓↓文章底部点击免费领取↓↓
但为了更高效地利用 CPU 的计算资源，OS 需要支持"同时"运行多个进程，此时内存空间按固定大小被瓜分为几块，分属于各个进程使用，如图 1-2。
由于是直接使用内存物理地址，如果这些进程都很"本分"，只访问自己的空间，那么一切都还正常，但如果某个进程闯入他人的领地，胡作非为呢?可控性是个问题。
V2.0：增加抽象转换层，使用虚拟地址 当考虑到增加管控、安全校验、动态分配等问题时，增加一层抽象进行"代理"往往是一个通用的解决方案。
到 2.0，进程不再被允许直接使用物理内存空间，而是使用从 0 开始编码的虚拟地址，经由 MMU(Memory Management Unit)转换得到实际地址，然后才能到内存中获取到数据。
中间层 MMU 会检查虚拟地址的有效性和合法性，从而保证安全性。
考虑到内存空间使用的灵活性，内存按固定大小进行分页(Paging)，通常是 4KB，连续的虚拟地址页(VP，Virtual Page)，映射到物理地址页(PP, Physical Page)上，可以是分散的，这种灵活的设计可以提升物理内存的空间利用率，减少内存碎片。
既然有映射，自然需要存储映射关系表，即页表(Page Table)，Key 值是虚拟地址页号(Virtual Page Number)。
Value 值是包含有物理地址页号(PPN，Physical Page Number)的数据结构(PTE，Page Table Entry)，值得一提的是，页表不存在 MMU 里面，同样也是存在内存里。
图 2-1 简要地展示了虚拟地址到物理地址的转换过程：
为了方便说明，这里页大小设置为 16 字节(2^4，offset 占用 4bit)，总的物理内存大小有 8 页(2^3，PPN 占用 3bit)即 128 字节，虚拟内存至多使用 4 个页(2^2，vpn 占用 2bit)。
MMU 将一个 6bit 的虚拟地址转化为 7bit 的物理地址，其中通过页表完成 vpn 到 PPN 的转换，而 offset 部分保持不动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be57688e3a3c6c280eb935011f6a7855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b465852db306d889c5b99bc55cfa363/" rel="bookmark">
			CLion Nova：全新的C/C&#43;&#43; IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CLion Nova是一款备受期待的集成开发环境（IDE），由JetBrains专门为C/C++开发者设计。这款IDE提供了许多新的功能和改进，使用 ReSharper C++/Rider C++ 语言引擎而不是 CLion “传统” 引擎，以满足C/C++开发者的需求。目前预览版本将免费提供，并且可以与 CLion (Classic) 安装并行安装且只能通过 Toolbox 应用程序获得。
CLion Nova具有以下优点：
快速的编译速度：CLion Nova使用了全新的编译器技术，能够实现快速编译，减少等待时间。智能的代码提示：该IDE通过智能算法提供代码提示，帮助开发者更快速地编写代码，减少错误。强大的调试功能：CLion Nova提供了强大的调试工具，帮助开发者定位和修复代码中的问题。 然而，CLion Nova也存在一些缺点：
占用服务器资源：由于其强大的功能和算法，CLion Nova可能会占用大量的服务器CPU和内存资源。学习曲线：对于初学者来说，由于CLion Nova的功能较为丰富，可能需要一段时间来熟悉和掌握。 总的来说，CLion Nova是一款功能强大、性能卓越的C/C++ IDE，能够为开发者提供更好的开发体验。但是，在使用过程中需要注意其可能存在的资源占用问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a74502b6b4044de3653a70d6e6a832/" rel="bookmark">
			JMeter（十五）-JMeter监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十五、JMeter监听器 1.简介 监听器用来监听及显示JMeter取样器测试结果，能够以树、表及图形形式显示测试结果，也可以以文件方式保存测试结果，JMeter测试结果文件格式多样，比如XML格式、CSV格式。默认情况下，测试结果将被存储为xml格式的文件，文件的后缀: ".jtl"。另外一种存储格式为CSV文件，该格式的好处就是效率更高，但存储的信息不如xml格式详细。
比较常用监听器：
查看结果树、聚合报告、用表格查看结果、响应时间图、
2.预览监听器 首先我们来看一下JMeter的监听器，路径：线程组（用户）-&gt;添加-&gt;监听器；我们可以清楚地看到JMeter5中共有16个监听器（不包括jp@gc开头的监听器，这个是安装的插件），如下图所示：
3.常用监听器详解 3.1 察看结果树 察看结果树，显示取样器请求和响应的细节以及请求结果，包括消息头，请求的数据，响应的数据。
（1）察看结果树，放的位置不同，查看的结果也不同。在线程组下添加察看结果树，查看线程组下所有请求的结果；放在具体某个请求下，只查看此请求的结果；若放在某个控制器节点下，则查看此控制器下节点执行的结果；
（2）该监听器推荐做调试用，在实际运行压测时，应该禁用，因为大量请求时，启用该监听器时打印的日志比较多，会造成大IO消耗，影响压力机性能。
3.1.1新建：线程组 &gt; 添加 &gt; 监听器 &gt; 察看结果树，如下图所示：
3.1.2关键参数说明如下：
文件名：载入文件名
显示日志内容: 仅错误日志、仅成功日志 ；勾选中显示对应的日志信息
配置：定义report中自己所关心的数据项。
取样器结果：
Thread Name: 线组名称Sample Start: 启动开始时间Load time: 加载时长Latency: 等待时长Size in bytes: 发送的数据总大小Headers size in bytes: 发送头大小Body size in bytes: 发送数据的其余部分大小Sample Count: 发送统计Error Count: 错误统计Response code: 返回码Response message: 返回消息Response headers:返回头信息 请求
数据获取方式、路径、地址等以及传递的参数、cookie 响应数据
响应加载的页面html 3.1.3作用
1）查看请求结果，请求成功的测试通常为绿色；红色则代表失败。
注：在没有对请求断言的情况下，显示绿色并不一定是成功，只代表响应码是200或300系列，显示红色说明响应码是400或500系列。所以要想确定请求返回的是正确的，必须要加上断言，只有断言成功才会显示绿色。
2）查看对应Sampler的测试结果的请求、响应数据。
取样器结果：显示的是取样器相关参数（客户端参数与响应参数）
请求：发送请求的具体内容
响应数据：服务器返回的相应参数
3.2 汇总报告 汇总报告，为测试中的每个不同命名的请求创建一个表行。这与聚合报告类似，只是它使用更少的内存。提供了最简要的测试结果信息，同时可以配置将相应的信息保存至指定的文件中（支持xml、csv格式的文件）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1a74502b6b4044de3653a70d6e6a832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3eb4a4efa024f9a2bcc9895b44d8b5/" rel="bookmark">
			vue 后台面包屑导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 gitee 项目地址可以直接下载项目。
如图效果需要用到Element-ui中的Element-ui面包屑和Element-ui Tag组件，再使用vuex进行和sessionStorage做到持久化储存。
先看一下页面结构
1、创建路由 脚手架项目创建的时候选择vue-router或者直接使用命令 npm install vue-router 注意npm下载的话vue2要使用vue-router3版本，vue3使用vue-router4版本，npm install vue-router @3。
import Vue from 'vue' import VueRouter from 'vue-router' import Index from '../views/index.vue' import IndexView from '../views/IndexViews/IndexView' import EchartsZx from '../views/EchartsViews/EchartsZx' import EchartsZz from '../views/EchartsViews/EchartsZz' import EchartsBz from '../views/EchartsViews/EchartsBz' Vue.use(VueRouter) const routes = [ { path:'/', name:'', component:Index, redirect:'/IndexView', children:[ { path: '/IndexView', name: '首页', component:IndexView }, { path: '/EchartsZx', name: '折线图', component:EchartsZx }, { path: '/EchartsZz', name: '柱状图', component:EchartsZz }, { path: '/EchartsBz', name: '饼状图', component:EchartsBz } ] }, ] //解决重复点击路由跳转报错 const VueRouterPush = VueRouter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3eb4a4efa024f9a2bcc9895b44d8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b92ffac542903b676d69e648ff441ca/" rel="bookmark">
			使用 git-cherry-pick 迁移提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 git-cherry-pick
后续补上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d0945c34ad35aefd9f8327800d1018/" rel="bookmark">
			【Java】lambda表达式和方法引用详解（jdk1.8新特性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、lambda表达式（jdk1.8） lambda表达式是用来简化函数式接口的匿名内部类的写法的。
在Java编程语言中，匿名内部类是一个特殊的类，它没有明确的类名，通常用于简化代码和实现接口。匿名内部类的定义位于一个类的局部位置，例如方法中或代码块中。
函数式接口在Java中是指仅有一个抽象方法的接口。这种接口可以用作函数式参数、返回值或者赋值给函数式变量。大部分函数式接口上可能都会有一个@FunctionalInterface的注解。
lambda表达式写法如下：
函数式接口 名称=(参数)-&gt;{ //函数式接口唯一方法的实现 } 当匿名内部类的引用传递给接口类型或者抽象类类型，如果发现类型是函数式接口，那很明显匿名内部类重写的方法必定是函数式接口的唯一方法，因此，匿名内部类的写法可以得到简化。
由此也可以看出，并不是所有匿名内部类都能使用lambda表达式。只有函数式接口才能使用lambda表达式。
一个将函数式接口的匿名内部类化为lambda表达式的完整例子：
//匿名内部类 Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() { @Override public int compare(Integer num1, Integer num2) { // 比较两个整数的大小 return num1 - num2; } }; //函数式接口 Comparator&lt;Integer&gt; comparator = (num1, num2) -&gt; {return num1 - num2;}; lambda表达式在某些情况下可以略写。以下是lambda表达式的省略规则。
参数类型可以省略不写如果只有一个参数，参数的括号可以省略不写如果lambda表达式中的方法体代码中只有一行代码，可以省略方法体的大括号不写（同时要省略这行代码的分号），此时如果这行代码是return语句，也必须要把return语句省略掉。 2、方法引用（jdk1.8） lambda表达式是对函数式接口的匿名内部类的简化，那lambda表达式之中创建的对象、调用的方法是否有机会进行简化呢？这就是方法引用。
方法引用的目的是为了进一步简写lambda表达式。它的标志性符号是::。
方法引用可以分为静态方法引用、实例方法引用、特定类型的方法引用以及构造器引用。
2.1、静态方法引用 如果某个lambda表达式中，只有一个类调用了它的静态方法，并且传入静态方法的参数与lambda表达式的参数类型一致，那么可以使用方法引用进行简化。
public class Main { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d0945c34ad35aefd9f8327800d1018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d912dff59c48c9c2783c9e71591a8b89/" rel="bookmark">
			git log 命令小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git log 用于查找提交记录。
常用命令：
1.直接输出 直接输出： git log
输出结果格式为：
commit 2827c3f04d5da2bba393df87051380b33314b073 Author: username &lt;user email&gt; Date: Fri Apr 23 16:17:49 2021 +0800 add some file commit 2bf031908406da141652cd54791beba26937cf09 Author: username &lt;user email&gt; Date: Fri Apr 23 16:16:52 2021 +0800 fix a ui bug 比较占用屏幕空间。
2.查找 commit 信息中包含关键字的记录 git log --grep=key
3.查找某个 author 的提交记录 git log --author=James
4.查找某个 committer 的提交记录 git log --committer=Tom
author 和 committer 的差异是，某个文件最初是 author （James）创建的，但是是由 committer（Tom）修改并提交了。
5.查看某个 commit_id 的具体内容 git show commit_id ，就会显示具体的修改差异
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d912dff59c48c9c2783c9e71591a8b89/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/19/">«</a>
	<span class="pagination__item pagination__item--current">20/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/21/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>