<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b27c773d6dd96b28789564834066dbc/" rel="bookmark">
			《Perl语言入门》读书笔记（六）哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.哈希特点 哈希是一种数据结构，与数组相同点，能容纳任意多的值；而哈希的检索方式与数组不同。数组是以数字下标检索，而哈希中的值（value）以唯一的名字（key）检索。
key-value一一对应：
乱序排列，类似一桶数据：
由于检索方式不同，当使用哈希时，能提高对大数据量中的读写性能。
2.哈希的使用 %some_hash = ('foo', 35, 'bar', 12.4, 2.5, 'hello', 'wilma' ,1.77878e12, 'da', "ada\n"); #创建一个哈希数组，以前key后value，一一对应 #改进版创建哈希 my %last_name = ( 'fred' =&gt; 'filtstone', # '=&gt;'等效于‘,’，更能区分key与value 'betty' =&gt; 'rubble', 'dino' =&gt; undef, ); $hash{$some_key}; #访问哈希中的元素 @any_array = %some_hash; #以无序形式返回键-值对应的列表，key与它对应的value相邻 3.哈希操作函数 3.1 keys和values函数 keys函数能返回哈希的键列表，values函数能返回对应的值列表。
my %hash = ('foo', 35, 'bar', 12.4, 2.5, 'hello', 'wilma' ,1.77878e12, 'da', "ada\n"); my @k = keys %hash; #返回值包含所有奇数位置的key my @v = values %hash;#返回所有偶数位置的value，返回顺序不固定，但key与value的相对位置保持一致 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b27c773d6dd96b28789564834066dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbdcd248dec6b7c7a4d4ad1fe1fbd8d/" rel="bookmark">
			MySQL中Waiting for table metadata lock的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL中在mysql命令行使用show full processlist；命令即可查看数据库的连接信息（管理员用户可看所有用户的连接，非管理员用户只能看到自己的连接），对于大量出现Waiting for table metadata lock的原因参考如下几篇文章（各篇文章有提到不同的点或排查思路）。
其中最重要的一点是：
show processlist（或show full processlist）查出来的数据的ID列，表示的是数据库的会话ID（session id），不是一个系统进程id，需要在mysql命令行模式下使用“kill 会话ID”的方式结束该会话，其他文章里说kill 进程id，这点对不了解mysql的人来说会误认为是linux进程。
可使用管理员账号查询如下语句得到具体引起锁的会话id：
select * from information_schema.innodb_trx
找到未提交事物的sid (trx_mysql_thread_id)
其他详细说明参考如下内容：
https://blog.csdn.net/haijiege/article/details/78606655
https://blog.csdn.net/u013235478/article/details/68062939
https://blog.csdn.net/aldqjt7468/article/details/101409145
https://blog.csdn.net/banxinggao9210/article/details/101344401
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0950f1ea89b27a1b0d59ccdcd94fb50/" rel="bookmark">
			word图片撑满,word怎么让图片占满整个页面？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时我们在用word编辑文本时，单一的文本内容比较单调，我们通常会加个图片背景，这样内容看起来比较美观。但是有些新手想知道word怎么让图片占满整个页面呢?下面小编给大家讲解下这个问题的具体方法。
第一种方法
1、打开需要的文档。
2、查看纸张大小。依次点击【布局】选项卡&gt;&gt;【页面设置】按钮，点击【纸张】，纸张大小为：宽度29.7cm，高度21.0cm。
3、插入示例图片。依次点击【插入】选项卡&gt;&gt;【图片】，选择要插入的图片，例如“示例.jpg”，点击【插入】。
4、选中图片。依次点击【格式】&gt;&gt;【位置】&gt;&gt;【中间居中，四周型文字环绕】。
5、依次点击【格式】&gt;&gt;【大小】按钮。
6、取消勾选【锁定纵横比】，将高度修改为纸张的高度：21.0cm，将宽度修改为纸张的宽度：29.7cm，点击【确定】。
第二种方法：
1、点击上方菜单栏的“设计”菜单项，打开其下的功能面板。在功能面板中，点击“页面颜色”选项列表中的“填充效果”。
2、在打开的“填充效果”窗口中，选择“图片”页签，然后点击“选择图片”按钮。
3、从本地文件系统中选择一张图片，回到“填充效果”窗口，然后点击“确定”按钮即可。
以上就是word怎么让图片占满整个页面的两种方法，大家记得在选文字环绕时不要选择嵌入型，还不会操作的朋友赶紧多加练习。
本篇文章使用以下硬件型号：联想小新Air15;系统版本：win10;软件版本：word2017。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3651e423211a994f9807b3307b216965/" rel="bookmark">
			HTML中表格跨行跨列深入分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 想要把原来标准的四行四列的表格弄成如下图:
目标单元格：最左侧和最右侧的那个单元格
从目标单元格开始标个箭头到最后的单元格，如下图，画"X"的单元格位置即为你要在代码中删掉的单元格。在本例中，要删掉的单元格为 （1，2）、（1，3）、（3，4）、（4，4）。
&lt;table align="center" border="1" cellpadding="0" cellspacing="0" width="500" height="400"&gt; &lt;tr&gt; &lt;td colspan="3"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan="3"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87961701ee6de187477a395fafc18baa/" rel="bookmark">
			信号与系统——傅里叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于所有涉及到电子、通信、控制等等专业的人来说，傅里叶变换是绕不过去的一个坎。
条件：绝对可和。
傅里叶变换的核心就是：一切的波形都可以由不同频率的正弦波的叠加来表示，这些不同频率的正弦波称为频率分量。
cos（0t）就是一个周期无限长的正弦波，也就是一条直线！所以在频域，0频率也被称为直流分量，在傅里叶级数的叠加中，它仅仅影响全部波形相对于数轴整体向上或是向下而不改变波的形状。
傅里叶变换的作用是将原来难以处理的时域信号转换为易于分析的频域信号，也就是信号的频谱。在频域进行处理和加工之后，还可以利用傅里叶反变换将这些频域信号转换为时域信号。傅里叶变换的另一个作用就是解微分方程。傅里叶变换可以把时域的微分积分化作频域的乘法除法。
傅里叶级数与傅里叶变换的关系：
傅里叶变换与拉普拉斯变换的关系：拉普拉斯变换将傅里叶变换推广到了复数域。当s为纯虚数的时候，拉普拉斯变换就等价于傅里叶变换。
DTFT与z变换的关系：z变换将DTFT推广到了复数域。当z的模为1（在单位圆上时），z变换等价于DTFT。
傅里叶变换是连续谱。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6b16b9d2e0df22790aa0c79c149c7e/" rel="bookmark">
			Logback与Log4j2日志框架性能对比与调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 看到目前线上大多日志框架测评大多从宏观角度，直接对比异步同步的吞吐量，但是没有考量到更深层的淘汰机制、等待策略、队列长度等对性能表现的影响，因此本文将从更多的角度对比及分析两款日志框架的性能表现，通过JProfiler+Jmeter压测及数据采集，从线程占用、锁占用、宏观耗时等多维度可视化数据。
性能测试 logback 同步日志 耗时 未经过任何调优，采用Logback默认配置得出上图，一百万条日志打印耗时(ms)，如图：单线程下性能最佳，耗时随线程数增加而下降。
线程占用 单线程 无阻塞状态
多线程 多线程打印日志时，会产生大量线程阻塞，线程越多阻塞状态越多
四线程 八线程 十六线程 锁占用 线程发生多次占用锁的情况。查看Logback源码可得知，检查容量、放入队列、取出队列都需要在取得锁后进行
异步日志（队列扩容） 样本数100万，队列长度110万
耗时 线程占用 单线程 多线程 四线程 八线程 十六线程 锁占用 每次写入队列都需要占用锁，同时Appender从队列取出也需要占用锁
异步日志（半队列扩容） 样本数100万，队列长度50万，不启用抛弃策略
耗时 线程占用 单线程 多线程 写入耗时明显增长，写入过程仍然发生阻塞状态
四线程 八线程 十六线程 锁占用 log4j2 同步日志 样本数100万，Logger到Appender串行执行，输出到文件
耗时 线程占用 线程产生长时间的等待，主要是缓冲环溢出后无法写入，生产者根据等待策略进入等待状态
单线程 单线程生产不需要争抢锁，因此全程无阻塞
多线程 整体来看，阻塞的时间随着线程增多而增多，因此多线程对同步日志影响极大，性能损失严重
四线程 八线程 十六线程 后续监控因阻塞时间太长跳过
锁占用 阻塞在Appender上的输出流上，输出流是在单线程中执行的
异步日志（队列扩容） 样本数100万，队列长度110万，使用Yield等待策略
耗时 单线程占用最高，耗时随线程数增加而缩短，直到线程数超过CPU核数。单线程耗时与logback相当，多线程耗时比logback缩短了2倍
线程占用 单线程与多线程使用都无阻塞状态，保证足够的队列容量，能使日志操作保持高吞吐和低延迟，避免阻塞等待
单线程 多线程 四线程 八线程 使用与宿主机CPU核数相等的线程数，日志写入过程无阻塞、无线程切换
十六线程 异步日志（日志淘汰策略） 样本数100万，队列长度50万，启用抛弃策略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6b16b9d2e0df22790aa0c79c149c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bb0ff775a658b47580982c2e5bfd79/" rel="bookmark">
			ClickHouse分区操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1， 查询实例的分区信息
可以展示实例下库、表机器对应的分区信息； select partition_id, name,table,database from system.parts ;
2， 删除特定分区
ALTER TABLE tbname DROP PARTITION partition_name;
也可以设置TTL自动删除；
3， 将A表的一个分区数据复制到B表；
可以用于快速写入、多表建数据同步、备份等场景；
ALTER TABLE B REPLACE PARTITION partition_expr A;
4， 重置指定分区的一个列；
如果该列有default值，则给DEFAULT，没有则根据类型清除该自动数据；
eg: alter table zg clear column Job in PARTITION 33;
5， 卸载/装载分区(DETACH/ATTACH)
DEATCH eg:
ALTER TABLE zg DETACH PARTITION 23;
ALTER TABLE zg ATTACH PARTITION 24;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c79c3ab7d63acf7c1b0f73a778bd38/" rel="bookmark">
			代码、文档等资料对比工具 BCompare 的详细使用讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BCompare，是一款最好用的代码对比工具以及文件、文件夹对比工具，
使用他可以很方便的对比出两个文件夹或者文件的不同之处，并把相差的每一个字节用颜色加以表示，查看方便，同时支持多种规则对比。
一、下载 下载地址：http://www.php.cn/xiazai/gongju/1494
安装时 管理员安装，傻瓜式
二、使用 首先，我们运行BCompar，进入了如下所示的软件主界面。然后我们点击功能栏上的【文本比较】按钮，并进入相应的窗口界面。
当然，也可以是其他的比较，比如：文件夹、版本、图片等；
点击之后的界面如下所示：
我们可以点击文件，找到我们要比较的两个文本，如下图所示，然后加入进去：
可以看到，两个文本不一样的地方用红色的字体标出来，非常易于我们查找！
1、并且我们还可以选择只显示差异项等设置 上面的具体图标代表的意思如下：
2、用户可以根据需要对对比的文本类型、语言进行设置，从而获得您需要对比的内容。 3、用户可以点击【查看】按钮，然后根据需要选择查看的比对的功能， 提供了16进制细节、语法加亮、网页、对齐方式细节、行号等功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4816ab2a4158b2cd25e0d1e6ceee2ab9/" rel="bookmark">
			python正则表达式匹配开头,正则表达式系列（一）：匹配开头与结尾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备说明：
1.实例中正则表达式来源于《精通正则表达式》一书
2.正则表达式实现方式为Python3.7
1.匹配开头
表达式"cat"可以匹配cat和wcat，^符会强制要求表达式从字符串开头匹配，"^cat"可以匹配cat，但不能匹配wcat。&gt;&gt;&gt; s = "wcat"
&gt;&gt;&gt; re.search(r"cat", s)
&gt;&gt;&gt; re.search(r"^cat", s)
&gt;&gt;&gt;
2.匹配结尾
与匹配开头类似，"foo"可以配foo和foobar，$符会强制要求表达式结尾字符匹配成功，"foo$"可以匹配foo，但不能匹配foobar。&gt;&gt;&gt; s = "foobar"
&gt;&gt;&gt; re.search(r"foo", s)
&gt;&gt;&gt; re.search(r"foo$", s)
&gt;&gt;&gt;
3.MULTILINE 模式
在MULTILINE模式下，开头匹配^和结尾匹配$会有一些变化。^可以匹配换行后字符，$可以配换行前字符。&gt;&gt;&gt; s = "w\ncat"
&gt;&gt;&gt; re.search(r"^cat$", s)
&gt;&gt;&gt; re.search(r"^cat$", s, re.MULTILINE)
4.完整示例import re
"""
行的起始与结束
"""
def main():
s = 'scat'
pattern = re.compile('^\wcat$')
match = re.match(pattern, s)
print(match)
s = "s\ncat"
m = re.search(r"^cat$", s, re.MULTILINE)
print(m)
if __name__ == '__main__':
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4816ab2a4158b2cd25e0d1e6ceee2ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c194a46b8c26997634157fe8d6f07075/" rel="bookmark">
			《Perl语言入门》读书笔记（五）输入与输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 读取标准输入 使用&lt;STDIN&gt;操作符进行标准输入
chomp($line = &lt;STDIN&gt;); #截掉换行符 2.输出到标准输出 print操作符会读取他后面的参数列表中的所有元素，并把每一项依次送到标准输出。
print @array; #输出数组元素 ， 不会含有空格 ，输出（fredbarybetty） print "@array"; #打印一个字符串，输出（fred bary betty） print &lt;&gt;; #相当于unix的/bin/cat命令 print sort &lt;&gt;; #对输出列表按ASCII码排序输出 print(2+3); #先进行运算，输出为5，若用于表达式中，与函数调用类似，成功执行返回值为1 $n = print(2+3); #$n的值为1 print(2+3)*4; #print的返回值为1，结果5并为保存，显示输出4 print((2+3)*4); #打印20 3.printf格式化输出 printf操作符会格式化输出，类似C的用法。
printf"%d days!\n",17; #输出:17days！ printf"%x days!\n",17; #输出:0x11days! printf"%6d\n",23; #输出：``````23 printf"%-6d\n",23; #输出：23````` printf"%6.3f",2/3; #输出：``````0.667 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28d18eea0082d00aaf3993fca3a08b2/" rel="bookmark">
			python数据分析开发环境搭建,Python中数据分析环境的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：Python中数据分析环境的搭建
无论学习哪一门语言，刚开始入门的时候，语言运行环境的搭建都是一件不轻松的事情，python时下正在“最热门的编程语言榜”上春风得意，今天就让我来带你学习Python的环境搭建吧~
Python的运行环境
要运行或写Python代码，就需要Python的运行环境，主要的Python有以下三类：
1.原生态的Python：就是直接从Python的官网下载，然后安装使用。这类方法最简单直接，但是后期不容易维护；
2.一些其他类型的Python发行本：这种类型的Python一般与一些package和其他工具整合在一起，类似于定制版的Python，易于安装和使用，例如用的比较多的Anaconda发行版；
3.使用docker来提供Python的运行环境：使用该方法，不用在自己电脑上直接安装Python的，只用在docker中构建好相应的Python的image就好了。
回想自己使用Python的过程，一开始也是直接到Python的官网上下载最新版本的安装包。安装完Python后，添加环境变量，在cmd中用pip一个一个安装需要使用的package。每次都是重复这样的过程，有时候会遇到一些莫名其妙的问题，比如某些package无法安装成功；有时候只能下源码自己编译安装。有时候还会需要不同版本的Python，电脑里就会出现多个版本的Python。
现在后面两类方法用的比较多。
关于开发环境
还记得有段时间接触到Java，一直分不清楚JRE和JDK的区别。现在终于搞明白了，JRE是运行是Java运行环境(JavaRuntimeEnvironment)，可以用来运行Java的代码；JDK是Java开发工具包(JavaDeveloper'sKit)，即Java的开发环境，主要用来写代码。
写代码时，有一个好的集成开发环境(integrateddevelopmentenvironment，IDE)会让我们事半功倍，包括但不限于以下这些优点：
语法检查；
提示及命令补全；
好看的配色和字体；
强大的debug功能；
对大型project的管理功能。
我用的比较多的IDE包括：PyCharm，Spyder和Jupyternotebook.
PyCharm在开发大型项目时是首选，但是平时分析数据时就显得有些笨重了；
Spyder主要用于科学计算(与RStudio非常像，可以单行运行)；但是对内存要求比较大，数据量比较大的时候容易崩溃；
Jupyternotebook算是新生代的数据科学界的IDE，非常适合做数据分析。
Anaconda发行版
Anaconda是一种Python语言的免费增值开源发行版，用于进行大规模数据处理,预测分析,和科学计算,致力于简化包的管理和部署。Anaconda使用软件包管理系统Conda进行包管理。——wiki
上面是wiki中对AnacondaPython发行版的介绍，其特点就是：为数据科学而定制的版本，利用conda来管理package比原生态的pip更方便。
完整版本的Anaconda
完整版本的Anaconda比较大，最新版的600多兆(windows,64-Bit,Python3.6)，该版本不仅包括Python，还有预装好的100多个package，省去了自己安装包的麻烦。但是体积比较大，通常很多包都用不到。
Miniconda
Minicoda只包含conda,Python和少量的包，大小只有50几兆。安装好Miniconda后，可以使用condainstall来安装其他python的包
下面以Miniconda为例，安装和配置Python的运行环境及开发环境(windows7,64位)
1.安装miniconda
打开上面的链接，下载想要安装的版本后进行安装。
安装完成后，在开始菜单可以看到下面的标志：
2.安装需要的package
点击上面的AnacondaPrompt，打开anaconda的命令行工具。在这个命令行中可以直接使用conda：
-condaenvlist:列出所有的虚拟环境；
-condalist:列出当前虚拟环境中已经安装的包；
-condasearchpackagex:搜索包packagex，会返回不同版本的包，可以使用"packagex==x.y"来指定安装x.y版；
-condainstallpackagex:安装包packagex.
由上图可以看到，现在只有一个虚拟环境——base，在这个环境中有30个预装的包。
下面安装常用的几个用于数据分析的工具包：
指定安装0.19.1版的scikit-learn:condainstallscikit-learn==0.19.1
3.安装jupyternotebook
安装jupyternotebook的命令：condainstalljupyter
安装后，可以看到开始菜单多了一个图标：
4.运行jupyternotebook
使用时，可以直接从开始菜单中的"JupyterNotebook"启动，或是在命令行中输入jupyternotebook。打开后，会在浏览器中打开一个页面。
界面如下：
点击图中框出来的"New"菜单，选择"Python3"就可以打开一个新的notebook
界面如下：
这时就可以写代码了！
退出时，关闭相应的cmd窗口就可以了。
JupyterNotebook
对于JupyterNotebook，完全值得单独拿出来说说。
jupyternotebook是一个交互式的IDE，虽然不像PyCharm这种重型IDE那么强大，但是仍然可以当做IDE来用，而且有一些特色非常适合用来进行数据分析：
可以单行运行代码，这样就可以一行一行的检查代码，查看运行结果，反复尝试；
每次运行后变量都保存在内存中，因此可以重复使用(这对于一些比较耗时的计算过程，尤其有用)；
可以写markdown格式的注释，这样就可以将整个分析过程非常清晰的表达出来；
可以利用Mathjax展示数学公式；
可以插入图片等，可以制作出图和代码并茂的非常精致的笔记和文档(有很多已经出版的书都是完全使用notebook来写作的).
但是个人感觉jupyternotebook并不适用代码量比较大的工程类项目。
如果有任何疑问，欢迎添加qq群测试入门到大神 755431660 共同学习~返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6712ad43a34bc358387e09bbff7042/" rel="bookmark">
			matlab如何下载a股数据,matlab如何下载a股数据,股票数据爬虫代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容导航：
Q1：MATLAB怎样从新浪财经获取股票交易数据.rar
超跌反弹动力强等诸多优势,最关键的是中小盘股已经2年多牛市了,而经历过5年熊市的蓝筹股才涨一波,距离结束还很远。玉名认为对股民来说,敢入低吸后就更要敢于持股,牛市行情过程复杂,但股民持股策略却很简单,选对主线就是耐心坚守。 超跌反弹动力强等诸多优势,最关键的是中小盘股已经2年多牛市了,而经历过5年熊市的蓝筹股才涨一波,距离结束还很远。玉名认为对股民来说,敢入低吸后就更要敢于持股,牛市行情过程复杂,但股民持股策略却很简单,选对主线就是耐心坚守。
Q2：matlab怎么提取股票复权数据
这和matlab没多少关系，主要看你的行情软件的接口函数，你应该去看下他们的帮助文档。
Q3：如何用MATLAB获取股票数据
该框架可为许多模型和优化方法产生具体的训练方法。本文中，生成模型通过一个多层感知机传递随机噪声，且判别模型也是一个多层感知机。
这个特例称为对抗的网络。这里，仅用反向传播和 Dropout 来训练模型，生成模型通过前向传播来生成样本。不需要近似推理和 Markov 链。
Q4：matlab可以直接获取国内股票或者期货的历史数据吗
貌似不可以，但你可以编程实现。
Q5：如何用matlab读取yahoo网站的股票数据？
matlab如何读取股票数据该框架可为许多模型和优化方法产生具体的训练方法。本文中，生成模型通过一个多层感知机传递随机噪声，且判别模型也是一个多层感知机。这个特例称为对抗的网络。这里，仅用反向传播和Dropout来训练模型，生成模型通过前向传播来生成样本。不需要近似推理和Markov链。
Q6：使用MATLAB分析市场数据和提出投资建议。
方法/步骤
1 确定证券交易所，选择SZ证券交易所或SH证券交易所，也可以选择财经网站的数据。由于百度经验不允许在正文中出现链接，所以不给出链接。
不同的财经网站数据的数据格式不同，但绝大多数均通过表格的方式输出。
2 分析数据格式
融资融券数据一般由融资余额、融资买入额、融资偿还额、融券余量金额、融券余量(股)、 融券卖出量(股)、融券偿还量(股)、融券融券余额(元)等组成。其中：
(1)本日融资融券余额＝本日融资余额＋本日融券余量金额
融资和融券余额之和，表明市场交投活跃(2)本日融资余额＝前日融资余额＋本日融资买入额－本日融资偿还额；
融资余额多，表明多头强(3) 本日融资偿还额＝本日直接还款额＋本日卖券还款额＋本日融资强制平仓额＋本日融资正权益调整－本日融资负权益调整；
(4)本日融券余量=前日融券余量+本日融券卖出数量-本日融券偿还量；
融券余量大，表明空头强(5)本日融券偿还量＝本日买券还券量＋本日直接还券量＋本日融券强制平仓量＋本日融券正权益调整－本日融券负权益调整－本日余券应划转量；
(6)融券单位：股(标的证券为股票)/份(标的证券为基金)/手(标的证券为债券)。
一般情况下，融资融券数据格式如下图。需要注意上海证券交易所和深圳证券交易所提供的融资融券数据有一定差别。
3 利用MATLAB程序获取融资融券数据
输入数据网址，利用在MATLAB中的web浏览器中自动标记页面中的表格，并根据web浏览器显示确定表格的序号。
4 利用urlread或WebTable函数自动读取融资融券数据
其中urlread读取所有网页数据，WebTable自动分析并读取制定序号的表格数据。
如
data = urlread(url);
或
myTableData1 = WebTable(1);
myTableData2 = WebTable(2);
其中：
&gt;&gt; myTableData1
myTableData1 =
'融资融券交易总量' [] [] [] []
'市场' '本日融资余额(元)' '本日融资买入额(元)' '本日融资偿还额(元)' '本日融券余量金额(元)'
'沪市' '460,495,093,484' '65,585,851,063' '61,076,252,272' '0'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a6712ad43a34bc358387e09bbff7042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d84fde1ff45d13fd67f3d052b9ad7f5/" rel="bookmark">
			《Perl语言入门》读书笔记（四）子程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 子程序 1.1 定义子程序 使用关键字sub开头，在写上子程序名（字母、数字和下划线组成，不能以数字开头），大括号框柱子程序主体。子程序可以定义在文件的任意位置，为了方便代码阅读，一般建议放在开头或结尾处。
sub marine{ $n += 1; #全局变量 print"Hello,sailor number $n!\n"; } 1.2 调用子程序 在任意表达式中，子程序名前加与号（&amp;），表示调用这个子程序。
&amp;marine; #调用前面的子函数 1.3 返回值 子程序在被调用时一定是作为表达式的一部分，并且在perl中所有的子程序都有返回值，larry将子程序执行的最后一次运算的结果，自动作为返回值。
sub sum_add{ print"The value is:"; $num1 + $num2; #此结果为返回值 # print“($num1 + $num2)”; 此表达式做最后一次运算结果返回值为1，只会判断是否有输出信息 } #对返回值需要小心确认 1.4 参数 perl支持参数传递，在子程序调用的后面加上括号，并括号内写入列表表达式，比如：
$s = &amp;max(10,17); 1.5 子程序中的私有变量 可以通过my操作符来创建私有变量，私有变量的作用域仅仅局限于封闭语句块中，语句块内的私有变量与外部变量互相不影响。my操作符声明的词法变量可以用在任意语句块中，仅作用于当前语句块。
sub max{ my($m,$n); #新建私有变量 ($m,$n) = @_; #参数赋值给变量 if($m&gt;$n) {$m} else{$n} } 1.6 use strict 编译指令 编译指令，是提供给编译器的某些指示，编译器将遵循你的指示处理接下来的代码。use strict是启用相对严格的编码风格的指令。
建议使用在程序较长的情况下。
1.7 return操作符 return操作符将会终止子程序运行，并返回某个值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d84fde1ff45d13fd67f3d052b9ad7f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78177ee16b5f78148096cc4cf3beb569/" rel="bookmark">
			服务器配置mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器配置mysql 一、1.将mysql5.7压缩包，复制到服务器指定目录并解压 2.将这个文件复制到解压目录，修改里面的mysql目录
3.进入bin目录，在目录唤起cmd窗口
执行mysqld -install命令进行安装，
执行mysqld --initialize-insecure --user=mysql命令初始化
4.执行 net start mysql 命令启动MYSQL
执行mysqladmin -u root -p password 命令设置新密码，root旧密码为空。
内网ip：127.0.0.1 外网ip：就是你服务器ip 账号：root 密码：你设置的新密码 端口：3306 踩坑 1、MySQL找不到MSVCP120.dll 解决方案：下载vcredist_x64安装即可。如果安装还是报这个错。重新下载
ps:我安装2015的不行，然后重新下了个2013的完美解决。官网下载太慢的话直接搜索vcredist下载别人分享的
2、net start mysql 提示mysql 服务正在启动 .mysql 服务无法启动 检查一下mysql路径下的data文件夹中是否有mysql文件夹。
没有的话cmd窗口运行mysqld --initialize
报错一下内容的话。把data文件删除。重新再运行一下 2021-03-26T02:06:25.581627Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details). 2021-03-26T02:06:25.581693Z 0 [Warning] 'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and 'ERROR_FOR_DIVISION_BY_ZERO' sql modes should be used with strict mode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78177ee16b5f78148096cc4cf3beb569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba89f9e70b89dc10faef86f6600af5f/" rel="bookmark">
			python图像腐蚀处理,Python OpenCV实例：图像腐蚀（数学公式基本实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python OpenCV实例：图像腐蚀(数学公式基本实现)
Python OpenCV实例：图像腐蚀(数学公式基本实现)
为什么80%的码农都做不了架构师？&gt;&gt;&gt;
#coding:utf-8
'''
二值图像的腐蚀运算
定义：
g(x,y) = erode[f(x,y),B] = AND[Bf(x,y)]
其中，g(x,y)为腐蚀后的二值图像，f(x,y)为原始二值图像
B为结构元素，Bf(x,y)定义为
Bf(x,y) = {f(x - bx,y-by),(bx,by)∈B}
算子AND(x(i),...,x(n))定义为：当且仅当x(1) = ... = x(n) = 1时，
AND(x(1),...,x(n))等于1，否则为0
结构元素选择的原则往往是具有旋转不变性，或者镜像不变性。也就是说，结构元素
原点在其几何中心处理，并且其他像素关于该原点对你。常用到的结构元素：
1、水平单列；2、垂直单列；3、十字形；4、方形
'''
import cv2
import numpy as np
# 3位水平方向结构元素
def erode_horizontal_3x1(image):
img_gray = cv2.cvtColor(image,cv2.COLOR_RGB2GRAY)
rows,cols = img_gray.shape
gray_flat = img_gray.reshape((rows * cols,))
# 创建空白图像
dist = np.full(img_gray.shape,fill_value=255,dtype=img_gray.dtype).reshape((rows * cols,))
x_coord = np.arange(1,cols-1)
for i in range(rows):
for j in x_coord:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ba89f9e70b89dc10faef86f6600af5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a3a291cff3c06317194593528eb9cc/" rel="bookmark">
			matlab中fplot和ezplot,Matlab中plot、fplot、ezplot的使用方法和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数plot 是绘制二维图形的最基本函数，它是针对向量或矩阵的列来绘制曲线的。也就是说，使用plot 函数之前，必须首先定义好曲线上每一点的x 及y 坐标;
常用格式为：
(1)plot(x) 当x 为一向量时，以x 元素的值为纵坐标，x 的序号为横坐标值绘制曲线。当x 为一实矩阵时，则以其序号为横坐标，按列绘制每列元素值相对于其序号的曲线，当x 为m× n 矩阵时，就有n 条曲线。
(2)plot(x,y) 以x 元素为横坐标值，y 元素为纵坐标值绘制曲线。
(3)plot(x,y1,x,y2,…) 以公共的x 元素为横坐标值，以y1,y2,… 元素为纵坐标值绘制多条曲线。
函数fplot 用来绘制数学函数，其调用格式为： fplot(fun,lims)其中fun 就是所要绘制的函数，可以是定义函数的M 文件名，也可以是以x 为变量的可计算字符串，lims=[XMIN XMAX YMIN YMAX]限定了x,y 轴上的绘图空间。
函数ezplot它无需数据准备，直接画出函数图形，基本调用格式为ezplot(f)，其中f 是字符串或代表数学函数的符号表达式，只有一个符号变量
区别：
plot是绘制二维图形，并且是x，y的表达式是已知的或者是形如y=f(x)这样确切的表达式
而ezplot是画出隐函数图形，是形如f(x,y)=0这种不能写出像y=f(x)这种函数的图形
简单来说，两者都是图形绘制函数，所不同的是，plot针对任意变量x和y都可以绘制，而fplot则需要实现定义函数，用function命令定义函数，然后再fplot命令中引用函数的名字。
fplot(函数表达式,绘 图区间)；
plot(横坐标向量,纵坐标向量,颜色/线形等参数)
fplot比如画某个区间内的正弦函数曲线：fplot('sin(x)',[0,20/pi])
plot:在0≤x≤2?区间内，绘制曲线
y=2e-0.5xcos(4πx)
程序如下：
x=0:pi/100:2*pi;
y=2*exp(-0.5*x).*cos(4*pi*x);
plot(x,y)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a984a88255c77a7e37d8946d2b4f432/" rel="bookmark">
			新买的阿里云服务器ecs绑定域名无法访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近新买了一台阿里云ecs，搞了个网站，折腾了很久终于发布到服务器上，绑定域名了。本以为终于大功告成了，结果网站死活打不开！
按经验，打不开网站的常规步骤：
1、验证本地是否可以打开？在服务器上用域名打不开；再增加一个本地Ip地址，访问正常；说明代码没问题；
2、ping，通的，说明网络是通的；
3、靠，那是什么鬼？满脸无语，又乱折腾N个小时~~~~
无奈之下，最终只能抱着试试看的态度，在阿里云上提交了个工单！2个小时候，终于有回复了！！
靠！竟然是80端口没有放行！！！阿里云的80端口默认不放行！！！我确信以前的阿里云80端口绝对是默认放行的！！哎，无语。
接下来放行80端口吧。
1、ECS实例左下菜单找到 【网络与安全】--- 【 安全组】，点击右上角【创建安全组】
2、懒人可以点击【快速添加】，
3、在弹出的页面里，勾选80 （其他常规的端口按需勾选），直接点击【确定】即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d50812fd004cdce2df5209e97c18cf/" rel="bookmark">
			多线程中sleep、yield、join的用法及sleep与wait区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Object中的wait、notify、notifyAll，可以用于线程间的通信，通过这三个方法完成线程在指定锁（监视器）上的等待与唤醒，这三个方法是以锁（监视器）为中心的通信方法
除了它们之外，还有用于线程调度、控制的方法，他们是sleep、yield、join方法，他们可以用于线程的协作，他们是围绕着线程的调度而来的
1、sleep方法 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），但是，该线程不会释放锁。sleep不会释放锁，不会释放锁，不会释放锁，可以理解为他进入监视器这个房间之后，在这房间里面睡着了sleep方法用static修饰，既然是静态方法，在Thread中的惯例就是针对于：当前线程，当前线程，当前线程与wait类似的是，sleep也是可中断方法（从方法签名可以看得出来，其可能抛出InterruptedException），也就是说如果一个线程正在sleep，如果另外的线程将他中断（调用interrupt方法），将会抛出异常，所以对于sleep方法，要么自己醒来，要么被中断后也会醒来。 对于sleep始终有一个超时时间的设置，所以，尽管他是在监视器内睡着了，但是并不会导致死锁，因为他终究是要醒来的。如下，子线程休眠500毫秒，主线程50毫秒打印一次状态，ps：被挂起线程(在该例子中是调用了sleep的线程)的调用结果为：TIMED_WAITING。
借助于sleep方法，可以模拟线程的顺序执行，比如下面示例，两个阶段，第二个阶段将在第一个阶段执行之后才会执行（哪个线程里使用了Thread.sleep()，则这个线程休眠，比如stepOne这个子线程执行了Thread.sleep(1000),则stepOne这个子线程需要休眠1000ms）
2、yield方法 对于sleep或者wait方法，他们都将进入特定的状态，伴随着状态的切换，也就意味着等待某些条件的发生，才能够继续，比如条件满足，或者到时间等，但是yield方法不涉及这些事情，他针对的是时间片的划分与调度，所以对开发者来说只是临时让一下，让一下他又不会死，就只是再等等（线程礼让）yield也是静态方法，所以，也是针对于当前线程，当前线程，当前线程。yield方法将会暂停当前正在执行的线程对象，并执行其它线程，他始终都是RUNNABLE状态，不过要注意，yield只是一种建议性的，如果调用了yield方法，对CPU时间片的分配进行了“礼让”，它仍旧有可能继续获得时间片，并且继续执行，所以一次调用yield 并不一定肯定会发生什么
借助于while循环以及yield方法，可以看得出来，也能一定程度上达到线程排序等待的效果
3、join方法 3.1 join方法的三个版本 三个版本的join方法
方法的实现过程，与wait也是非常类似，下面两个版本的方法一个调用join（0）,一个参数校验后，调用join（millis），所以根本还是单参数版本的join方法
3.2 举例 目的：一个线程，循环5次，每次sleep 1s，然后是主线程中打印信息。
从结果可以看到，主线程总是在线程执行之后，才会执行，也就是主线程在等待我们创建的这个线程结束，结束了之后才会继续进行：
如果调整下顺序—&gt;start 与 join的先后顺序，再次看下情况，可以发现顺序没有保障了
结论：主线程main中调用启动线程的方法（调用start），然后调用该线程的join方法，可以达到主线程等待工作线程运行结束才执行的效果，并且join要在start调用后
如何做到的？
从上面源代码可以看得出来，内部调用了wait方法，所以也能明白为啥join也会抛出InterruptedException了吧。主线程main中调用thread.join（）方法，join方法相当于join（0），也就是 while (isAlive()) { wait(0); } 而这个wait（0）就相当于是this.wait（0），this就是我们自己创建的那个线程thread，看看方法的签名是不是有一个synchronized。
isAlive（）也是this.isAlive（），也就是如果当前线程thread是alive（已经启动，但是未终止），那么将持续等待，等待的临界资源就是我们创建的这个线程对象本身
所以这两行代码的含义就是：该线程是否还存活？如果存活，调用join的那个线程将会在这个对象上进行等待（进入该线程对象的等待集），也就是说调用一个线程的join方法，就是这个线程在等待，这个线程对象就是我们的锁对象（不要疑惑，Object都可以作为锁，Thread实例对象怎么不可以？）
肯定大家很奇怪，既然是等待，wait又不会自己醒来，那不是出问题了吗？其实线程结束后，会调用this.notifyAll，所以主线程main会被唤醒
如果传递的参数不为0，将会走到下面的分支，或wait指定时长，与上面的逻辑一致，只不过是有指定超时时长而已
long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; 手动版本的等待结束
只是将join方法换成了同步代码块，锁对象为那个线程的实例对象thread，调用他的wait方法，从结果上看，效果一样，（不过此处没有持续监测isAlive（），所以一旦主线程醒来，即使线程没有结束，也会继续，不能百分百确保main肯定等待线程结束）
不过要注意：注释中有说明，自己不要使用Thread类的实例对象作为锁对象，如果是现在这种场景，使用join即可
为什么？从我们目前来看，join方法就是以这个对象为锁，如果你自己在使用，又是wait又是notify（notifyAll）的，万一出现什么隐匿的问题咋办？
所以join方法的原理就是：将指定的Thread实例对象作为锁对象，在其上进行同步，只要那个线程还活着，那么就会持续等待（或者有限时长），线程终止之后会调用自身this.notifyAll，以通知在其上等待的线程。简单说，只要他活着大家就都等着， 他死了会通知，所以效果就是在哪里调用了谁的join，哪里就要等待这个线程结束，才能继续
为什么要在start之后？
如上面所示，将join改造成同步代码块如下所示，如果这段同步代码在start方法之前，看下结果，没有等待指定线程结束，main主线程就结束了
因为如果还没有调用start方法，那么isAlive是false（已开始未结束），主线程根本就不会等待，所以继续执行，然后继续到下面的start，然后主线程结束，所以，为什么join方法一定要在start之前？就是因为这个isAlive方法的校验，你没有start，isAlive就是false，就不会同步等待，所以必须要先start，然后才能join
3.3 总结 对于join方法，有两个关键：
调用的哪个对象的join？在哪里调用的？ 换一个说法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d50812fd004cdce2df5209e97c18cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba51d263ff6cacb6501e1ce7785a3ba9/" rel="bookmark">
			unity2019中虚拟按钮的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本：unity2019.4.12f1，Visual Studio2019
1.window栏加入Vuforia Engine AR，此时可以正常使用AR相机了。
2.利用vuforia码，
建立一个空物体showcube，
然后在空物体上加入Virtual Button Behaviour（系统自带函数），加入Turn Off Behaviour(系统自带函数）
接下来是ShowCube设置，即完成显示和不显示cube
using System.Collections; using System.Collections.Generic; using UnityEngine; using Vuforia; public class ShowCube : MonoBehaviour, IVirtualButtonEventHandler { public GameObject cube; public GameObject sphere; // Use this for initialization void Start() { VirtualButtonBehaviour[] vbs = GetComponentsInChildren&lt;VirtualButtonBehaviour&gt;(); for (int i = 0; i &lt; vbs.Length; i++) { vbs[i].RegisterEventHandler(this); } cube.SetActive(false); sphere.SetActive(false); print("cube关闭"); } // Update is called once per frame void Update() { } public void OnButtonPressed(VirtualButtonBehaviour vb) { /*switch(vb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba51d263ff6cacb6501e1ce7785a3ba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38200dcd1b9de11cfe737b1937537e6d/" rel="bookmark">
			stata令相关系数加显著性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关 皮尔逊相关加显著性 pwcorr a1 a2,sig star(0.01)
为避免多重比较谬误 （multiple comparison fallacy）
讲多重比较纳入考虑，
pwcorr y x1 x2 x3 x4,sidak sig star(.05)
#括号内显著性可自行调整为0.1, 0.05, 0.01
spearman 等级相关 spearman a1 a2
kendall cixuxiangguan ktau a1 a2
协方差 correlation z1 z2 z3 z4,covariance
回归后键入一下命令估计系数之间的相关矩阵，诊断多元共线性 correlation, _coef covriance
若要显示系数的方差协方差矩阵 correlation,_coef covriance
散点图矩阵 graph z1 z2 z3 z4,half msymbol(+) maxis(ylabel(none) xlabel(none))
删除缺失值 !missing
做时滞或者提前 做时滞 gen n = _n
tsset n
gen lx = L.x
gen l2x = L2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38200dcd1b9de11cfe737b1937537e6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d02be5d6fafacd44395b251138df879/" rel="bookmark">
			Python数组转字符串互转详细操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较经常用但感觉大家的博客主要都是介绍用list，而很少用split
1、数组转字符串 使用join
nums=["1","2","3","4","5","6"] s="|".join(nums)	print(s) #===&gt;s="1|2|3|4|5|6" “&lt;分隔数组内的内容&gt;”.join(&lt;数组名&gt;)
返回一个字符串
但是要注意的是，数组内的内容必须是str类型的！
2、字符串转数组 使用list(并不推荐)
s="1,2,3,4,5" n=list(s) print(n) print(s) #===&gt;n=["1",",","2",",","3",",","4",",","5"] #===&gt;s="1,2,3,4,5" list(&lt;数组名&gt;)
返回一个数组
但要注意的是list会把字符串里每个字符串切割成数组内的一个元素
使用split(推荐使用)
s="1,2,3,4,5" n=s.split(",") print(n) print(s) #===&gt;n=["1","2","3","4","5"] #===&gt;s="1,2,3,4,5" &lt;数组名&gt;.split(&lt;切割字符串的标识符&gt;)
返回一个数组
要注意的是，如果括号内的标识符在字符串里找不到，那么整个字符串会被分为数组内一个且唯一的元素
编码不易，有帮助的话点个赞支持一下吧~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277862f6634128520ccaf54816942ced/" rel="bookmark">
			ThinkPHP6.0扩展类库wxBizDataCrypt解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.去微信官方下载示例包 下载
2.把php示例复制到extend 下面，新建目录 wxBizDataCrypt 3.在errorCode.php和wxBizDataCrypt.php文件加入命名空间 namespace wxBizDataCrypt; namespace wxBizDataCrypt; class WXBizDataCrypt { private $appid; private $sessionKey; 4、调用 $errCode = new \wxBizDataCrypt\wxBizDataCrypt(APPID,1); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea836b22d0e3b0f19b65a4f6c2b7da4/" rel="bookmark">
			0.96寸和2.42寸OLED屏幕滚动初始化设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做项目时需要用到OLED屏幕滚动显示的功能，复制其他博主的代码完成了水平滚动显示的功能。http://www.51hei.com/bbs/dpj-180145-1.html
但是，2.42寸OLED的滚动显示和0.96寸初始化设置还是有略微的区别的，如果直接复制粘贴，你会发现屏幕只有一小块地方在动。
网上搜了很久，都是0.96寸的介绍应用，无奈之下自己查阅英文文档，最终解决。
希望为要使用2.42寸屏幕的朋友提供些许帮助。
贴上两者的初始化设置代码。
0.96
void OLED_Init(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);//使能PORTA~E,PORTG时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13 ; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//普通输出模式 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉 GPIO_Init(GPIOD, &amp;GPIO_InitStructure);//初始化 OLED_RST_Set(); delay_ms(100); OLED_RST_Clr(); delay_ms(200); OLED_RST_Set(); OLED_WR_Byte(0xAE,OLED_CMD); //关闭显示 OLED_WR_Byte(0xD5,OLED_CMD); //设置时钟分频因子,震荡频率 OLED_WR_Byte(0x80,OLED_CMD); //[3:0],分频因子;[7:4],震荡频率	OLED_WR_Byte(0xA8,OLED_CMD); //设置驱动路数 OLED_WR_Byte(0X3F,OLED_CMD); //默认0X3F(1/64) OLED_WR_Byte(0xD3,OLED_CMD); //设置显示偏移 OLED_WR_Byte(0X00,OLED_CMD); //默认为0 OLED_WR_Byte(0x40,OLED_CMD); //设置显示开始行 [5:0],行数. //	OLED_WR_Byte(0x8D,OLED_CMD); //电荷泵设置 OLED_WR_Byte(0x14,OLED_CMD); //bit2，开启/关闭 OLED_WR_Byte(0x20,OLED_CMD); //设置内存地址模式 OLED_WR_Byte(0x02,OLED_CMD); //[1:0],00，列地址模式;01，行地址模式;10,页地址模式;默认10; // OLED_WR_Byte(0xA1,OLED_CMD); //段重定义设置,bit0:0,0-&gt;0;1,0-&gt;127; OLED_WR_Byte(0xc8,OLED_CMD); //(0xC0/0xC8) Set COM Output Scan Direction 行扫描顺序：从上到下 //OLED_WR_Byte(0xC0,OLED_CMD); //设置COM扫描方向;bit3:0,普通模式;1,重定义模式 COM[N-1]-&gt;COM0;N:驱动路数 OLED_WR_Byte(0xDA,OLED_CMD); //设置COM硬件引脚配置 OLED_WR_Byte(0x12,OLED_CMD); //[5:4]配置 OLED_WR_Byte(0x81,OLED_CMD); //对比度设置 OLED_WR_Byte(0xcf,OLED_CMD); //1~255;默认0X7F (亮度设置,越大越亮) OLED_WR_Byte(0xD9,OLED_CMD); //设置预充电周期 OLED_WR_Byte(0xf1,OLED_CMD); //[3:0],PHASE 1;[7:4],PHASE 2; OLED_WR_Byte(0xDB,OLED_CMD); //设置VCOMH 电压倍率 OLED_WR_Byte(0x40,OLED_CMD); //[6:4] 000,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ea836b22d0e3b0f19b65a4f6c2b7da4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bff38ae7a9ab6544e7fbfde2c3c2a0/" rel="bookmark">
			Java学习笔记（三）Java面向对象编程 -- 详细的Java基础教程系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 面向对象编程（OOP） 人类思想的方法原则的高深体现：抽象，分类，继承，聚合，多态
基于java尚硅谷教程的学习笔记，以及自己的一些理解和新知识分享
文章目录 Java 面向对象编程（OOP）一、前言（一）**面向对象的三大特征**（二）面向对象核心思想 二、Class--类三、Object对象（一）使用对象（二） 对象的生命周期（三）**对象内存解析**（四）对象内存细致解析（五）匿名对象 二、类的成员（一）属性Field（二）方法Method1、 声明格式2、方法分类3、调用方法时的内存调度4、方法重载（overload）5、可变个数的形参6、方法参数的值传递机制7、两道有趣的题目1、貌似是考察方法的参数传递2、微软面试题 8、递归方法（recursion） 三、面向对象特征：封装和隐藏（一）思想（二）四种访问权限修饰符 四、构造器（3W法讲解）（一）what？（二）why？（三）how? 五、关键字this（3W)（一） what？（二）why？（三）how？ 六、关键字：package、import（一）package1、what and how？2、why？ （二）import 一、前言 （一）面向对象的三大特征 封装继承多态 （二）面向对象核心思想 Object–对象和Class–类是面向对象的核心概念
Class–类是一类事物的抽象定义
Object–对象是实际存在的该类事物的个体，是类的实例化
万事万物皆对象
二、Class–类 Class中的Member（成员）
属性（Field） = 成员变量方法（Method） = 函数/成员方法 类的语法格式
修饰符 class 类名{ 属性声明; 方法声明; } 修饰符：缺省,public,private（这个私有类定义只能是内部或者嵌套类） 类的访问机制
一个类中的访问机制：类中方法直接访问类中成员变量（例外：static方法访问非static，编译不通过）不同类中访问机制：先创建对象，再用对象访问类中定义的成员 三、Object对象 （一）使用对象 Person p1 = new Person(); Person p2 = new Person(); （二） 对象的生命周期 （三）对象内存解析 堆（Heap）：存放对象实例和数组
栈（Stack）：存储局部变量，对象引用（对象在堆内的首地址），方法执行完自动释放
方法区（Method Area）：用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
（四）对象内存细致解析 （五）匿名对象 不定义对象的句柄，直接调用对象的方法 new person().shout(); 使用情况 一个对象只需要进行一次方法调用将匿名对象作为实参传递给一个方法调用（工程思想） 二、类的成员 （一）属性Field 语法格式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16bff38ae7a9ab6544e7fbfde2c3c2a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7164fc8760703f27c1b73b432dad0909/" rel="bookmark">
			[exercises]合并两个有序链表——二级指针在递归中的传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【将两个有序链表合并成一个有序链表】
发现一个递归的实现，与自己的方法有些差别，借鉴后，修改到自己的代码时，出现了一个问题，使得报“无权限访问错误”，后发现在递归时，为含有二级指针参数的函数赋值时，类型不匹配，但是由于传递的都是地址，造成的传参错误的问题。
正确代码如下：
pNode_t MergeLinkRecursion(pNode_t* pHead1, pNode_t* pHead2) { if ((*pHead1) == NULL) { return (*pHead2); } if ((*pHead2) == NULL) { return *pHead1; } if ((*pHead1)-&gt;data &lt; (*pHead2)-&gt;data) { // 传递参数时要注意参数的匹配，尤其是地址；函数参数类型为二级指针，要传一级指针变量的地址 (*pHead1)-&gt;pNext = MergeLinkRecursion((&amp;(*pHead1)-&gt;pNext), pHead2); return *pHead1; } else { (*pHead2)-&gt;pNext = MergeLinkRecursion(pHead1, &amp;((*pHead2)-&gt;pNext)); return *pHead2; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64304d8b12c5338aeea90a6a1fefa697/" rel="bookmark">
			php 读取 3g大文件,PHP读取大文件的SplFileObject类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般读取文件我们用fopen 或者 file_get_contents ,前者可以循环读取，后者可以一次性读取，但都是将文件内容一次性加载来操作
如果加载的文件特别大时，如几百M，上G时，这时性能就降下来了，那么PHP里有没有对大文件的处理函数或者类呢？ 答案是：有的。
PHP真的越来越“面向对象”了，一些原有的基础的SPL方法都开始陆续地实现出class了。
从 PHP 5.1.0 开始，SPL 库增加了 SplFileObject 与 SplFileInfo 两个标准的文件操作类。SplFileInfo 是从 PHP 5.1.2 开始实现的。
从字面意思理解看，可以看出 SplFileObject 要比 SplFileInfo 更为强大。
不错，SplFileInfo 仅用于获取文件的一些属性信息，如文件大小、文件访问时间、文件修改时间、后缀名等值，而 SplFileObject 是继承 SplFileInfo 这些功能的。
/** 返回文件从X行到Y行的内容(支持php5、php4)
* @param string $filename 文件名
* @param int $startLine 开始的行数
* @param int $endLine 结束的行数
* @return string
*/
function getFileLines($filename, $startLine = 1, $endLine=50, $method='rb')
{
$content = array();
$count = $endLine - $startLine;
// 判断php版本(因为要用到SplFileObject，PHP&gt;=5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64304d8b12c5338aeea90a6a1fefa697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d7565b067d2864b1b92abb7eef4767/" rel="bookmark">
			Docker安装Jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.拉取镜像： docker pull jenkinsci/blueocean 2.创建容器： docker create --name jenkins -u root -p 8889:8080 --privileged=true -v jenkins-data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /home/jenkins:/home docker.io/jenkinsci/blueocean 3.启动容器： docker start jenkins 4.输入http://"Yours Server Ip":8889 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb09573562ea1c6b3a81c2469a045b4/" rel="bookmark">
			Flink SQL中可撤回机制解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景案例 先从一个实际业务场景理解Flink SQL中的撤回机制：设备状态上线/下线数量统计，上游采集设备状态发送到Kafka中，最开始是一个上线状态，此时统计到上线数量+1，过了一段时间该设备下线了，收到的下线的状态，那么此时应该是上线数量-1，下线数量+1，现在需要实现这样一个需求，看一下在Flink SQL里面如何实现
val env=StreamExecutionEnvironment.getExecutionEnvironment val tabEnv=TableEnvironment.getTableEnvironment(env) tabEnv.registerFunction("latestTimeUdf",newLatestTimeUdf()) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val kafkaConfig=newProperties() kafkaConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"localhost:9092") kafkaConfig.put(ConsumerConfig.GROUP_ID_CONFIG,"test1") val consumer=newFlinkKafkaConsumer011[String]("topic1",newSimpleStringSchema,kafkaConfig) val ds=env.addSource(consumer) .map(x=&gt;{ val a=x.split(",") DevData(a(0),a(1).toInt,a(2).toLong) }).assignTimestampsAndWatermarks(newBoundedOutOfOrdernessTimestampExtractor[DevData](Time.milliseconds(1000)){ overridedef extractTimestamp(element:DevData):Long= element.times }) tabEnv.registerDataStream("tbl1",ds,'devId,'status,'times,'rt.rowtime) val dw=tabEnv.sqlQuery( """ select st,count(*) from ( select latestTimeUdf(status,times) st,devId from tbl1 group by devId ) a group by st """.stripMargin) dw.writeToSink(newPaulRetractStreamTableSink) env.execute() 自定义udf获取最新的设备状态
public class LatestTimeUdf extends AggregateFunction&lt;Integer,TimeAndStatus&gt;{ @OverridepublicTimeAndStatus createAccumulator(){ returnnewTimeAndStatus(); } publicvoid accumulate(TimeAndStatus acc,Integer status,Long time){ if(time &gt; acc.getTimes()){ acc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb09573562ea1c6b3a81c2469a045b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd81f711c95ad87dbd83e6962c996a8/" rel="bookmark">
			Nginx 启停方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在nginx的安装目录下cmd
1、启动：
start nginx；或者 start nginx.exe
启动后能在任务管理器进程中看到nginx.exe执行进程；
2、停止：
nginx -s stop； 快速停止，但是不保存信息；
nginx -s qiut； 完整停止，并保存信息；
kill -9 nginx； 无法停止的时候，直接kill(Linux)
windows直接在任务管理器结束进程；
3、检查：
nginx -t ；修改后查看配置信息是否正确，或者存在的问题；
nginx -v ；查看当前nginx的版本；
4、重启：
nginx -s reload ； 重新启动nginx；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83bf4ff9cc26d5f7b08649b168181987/" rel="bookmark">
			UnhandledPromiseRejectionWarning: TypeError: Cannot convert object to primitive value
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnhandledPromiseRejectionWarning: TypeError: Cannot convert object to primitive value 主要是这个错误，是类型转化的问题，node好像无法接收前端的json对象，所以我们要转化为json的字符串形式。
如下修改 ：
使用JSON.stringify()进行类型转换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b408fbf7c5caa64dc368f7f9eb85dc2/" rel="bookmark">
			PotPlayer：当前音频无法播放。DirectX 驱动程序未正确安装或音像设备被禁用的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被毕业论文搞炸了，就下载个阿凡达放松下，但是PotPlayer播放阿凡达时出现了问题：
如图：
表现：视频可以正常播放，但是没有声音。
原因：系统无法解码DST音频格式，因为DST格式需要解码才有多声道音频信号出来。安装PotPlayer时，勾选了安装额外的解码包，但是因为网络原因（被墙了），没有下载下来，所以没有安装。
解决办法：
安装解码器OpenCodecSetup64.exe。
链接：https://pan.baidu.com/s/1nsSOliv3tbMfFfE6-xx-XQ
提取码：ix3r
注意要安装到PotPlayer目录！
安装好后重启PotPlayer播放器就可以正常播放了！
2021-07-1817:56:01更新：
该文件禁止分享。
需要的可以在网上搜集，或者关注后私聊我。
2021年10月9日更新： 下载链接：
https://daumpotplayer.com/wp-content/uploads/2019/06/OpenCodecSetup64.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52cb7670ea6af8025e6ba0823cc8fbc8/" rel="bookmark">
			统计一行文本的单词个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是汇总了几个我认为比较好的方法，并进行了优化，仅供学习参考。
本题目要求编写程序统计一行字符中单词的个数。所谓“单词”是指连续不含空格的字符串，各单词之间用空格分隔，空格数可以是多个。
输入格式:
输入给出一行字符。
输出格式:
在一行中输出单词个数。
输入样例:
Let's go to room 209. 输出样例:
5 思路一：利用scanf的特性（使用%s转换说明，scanf会读取除空白以外的所有字符），可以很简单的完成这题。注意两个问题，一是代码虽然能通过PTA的编译器，但是在实际操作时需要输入EOF才能结束循环得到结果。然而Mac端的EOF操作为command+D，在dubug的时候用才能得到结果，在run时直接用会直接结束程序。二是采用了定长数组，可能空间不足或者浪费。
#include &lt;stdio.h&gt; int main() { char ch[100]; int i = 0; while (scanf("%s", ch) == 1) { i++; } printf("%d", i); return 0; } 思路二：利用题目中“单词”的定义。除了最后一个单词以外，其他单词一定结尾有空格，所以利用一个标志来代表单词，若遇到空格则单词数加一。到最后一个单词，结尾可能有空格也可能没有，但是一定有标志。
#include &lt;stdio.h&gt; int main() { int count = 0, flag = 0; char str; str = getchar(); while (str != '\n') { if (str != ' ') //若非空格，标志为1表示单词 flag = 1; if (flag == 1 &amp;&amp; str == ' ') //若是空格且标志为1，表示1个单词的末尾，标志重置为0 //若是空格且标志为0，表示出现连续空格 { count++; flag = 0; } str = getchar(); } //判断最后一个单词 //此时若有单词则标志一定为1，若无单词，标志停留在0 if (flag == 1) { count++; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52cb7670ea6af8025e6ba0823cc8fbc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b1e9a74bdd2e23339d7f5ba8ec1329/" rel="bookmark">
			三款视频下载工具，让你不花钱也有vip的下载速度！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近需要从一些视频网站上下载视频到本地，用到了几款工具，给大家安利下，有了这几款工具，想下载视频简直是太轻松了，这几款工具需要依赖python环境，而且是在命令行下输入命令下载。
这几款工具我最近一直在用，针对它们各自适合的网站给大家做下说明。
1 youtube-dl 顾名思义，看名字就知道这款工具针对youtube视频下载那效果是杠杠地。
安装 pip install youtube-dl 使用 youtube-dl https://www.youtube.com/watch?v=p6PqW8QnE9c 更详细的用法可参考：https://github.com/ytdl-org/youtube-dl
2 you-get 这款工具可适合国内绝大部分网站，包括爱奇艺、bilibili等，但是在用它下载腾讯视频的视频时会中断卡死，所以腾讯视频最好用之后的那个工具。
安装 pip install you-get 使用 you-get http://www.bilibili.com/video/av585499617 更详细的用法可参考：https://github.com/soimort/you-get
3 annie 这款工具我刚才说了，特别适合用于腾讯视频的下载，如果你发现有用you-get搞不定的网站时，就可以用这个来试试，说不定就有惊喜呢。不过这款工具针对不同系统的电脑安装方式不同。
macOS安装 brew install annie Linux安装 xbps-install -S annie Windows安装 scoop install annie 或者
choco install annie 使用 annie https://v.qq.com/x/cover/z8njmlc1opwgxoa/z0020jq459e.html 更详细的用法可参考：https://github.com/iawia002/annie
要是对大家有用的话，点个赞鼓励一下呗！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe2e225fe01b73aaf5768a4a9cf8e59/" rel="bookmark">
			Vivado行为仿真基本流程（入门级）----- 以与非门逻辑功能为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Vivado简介建立工程 Vivado简介 Vivado设计套件是FPGA厂商Xilinx开发的一套集成设计环境，该设计套件功能强大，目前最新的为Vivado Design Suite - HLx 2020.2版本。1
Vivado集成了仿真工具，不像Quartus不自带仿真工具，需要借助第三方仿真工具如Modelsim来查看仿真结果。本设计流程采用的版本为Vivado 2017.4。安装包放在百度网盘内，有需要下载的小伙伴请自取：链接：https://pan.baidu.com/s/1HVIqs1FEz_ugPy9Kwt1Z1Q 提取码：JK82 。
建立工程 首先打开系统菜单栏，点开文件夹Xilinx design tool，双击图标Vivado 2017.4，打开Vivado。
出现Vivado初始界面，然后点击Quick Start里面的Create Project。
出现工程建立向导对话框，点击next：
这个时候你要给整个工程起一个名字，指定该工程所保持的路径。为了整个工程能顺利地编译通过，工程名字最好起英文名字，不要出现中文字符，保存路径也尽量为英文。这个我们将整个工程命名为nand_project。默认勾选create project subdirectory，此时会在保存路径中创建一个以工程名为文件名的子文件夹，用来存放编译工程时所产生的文件，点击next。
默认勾选第一项，创建一个RTL Project。点击next。
进入到add source界面，这里我们点击create file，创建一个Verilog文件。
将Verilog文件命名为nand_gate，点击OK后，可以看到该Verilog文件就被添加到工程里面了。
点击next，为工程添加约束，这里我们不需要添加任何约束。
点击next，选择FPGA型号，这里可以根据实际需要选择具体的FPGA型号，这里我们选择xa7atcpg236-2I，点击next。
这里可以看到整个工程的总结信息，点击finish，完成工程的创建，进入到主界面。
弹出定义模块对话框，为该模块定义输入输出端口，这里我们点击cancel，直接在Verilog文件中定义输入输出端口。
点击yes，进入到工程主界面。
可以看到除了菜单栏外，整个界面分为四个子窗口。
双击source窗口内，design source下的nand_gate.v文件，进入到Verilog文件编辑界面。
与非逻辑的Verilog代码如下：
module nand_gate(data_1, data_2, data_out); //端口列表 input data_1, data_2; //输入 output reg data_out; //输出 //描述一个组合逻辑电路 always @ (*) begin data_out =~ (data_1 &amp;&amp; data_2); //与非逻辑 end endmodule 这里的模块名和Verilog名一致，博主本科用的是quartus，quartus要求工程名，Verilog文件名及模块名必须一致才能编译通过，但是vivado好像不需要满足这一要求，博主试着将模块命名为其他名称，也可以编译通过，仿真结果正确。
编辑好Verilog代码后，点击保存按钮。
接下来我们为工程添加testbench，用来验证结果的正确性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffe2e225fe01b73aaf5768a4a9cf8e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ea556c816eccbba6e3988dda08e08a/" rel="bookmark">
			ArcGIS——计算几何——面积/周长禁用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
在属性表中对字段进行计算几何操作，却发现“面积/周长-已禁用”的问题。如下图：
解决思路：
因为缺少投影，定义一个投影就可以了。
①可利用工具“定义投影”，给数据加上投影坐标系：
②直接给数据框定义投影坐标系
打开数据框的属性，然后选择一个合适的投影坐标系
这个问题，有的文章是说经纬度坐标反了，将经纬度反过来就行。此方法与我碰到的问题不是一种类型，因此在这就不做过多描述。第一种方法不可行的可尝试这种把经纬度反过来的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747e857c14f4e14f0564afd4e21d1888/" rel="bookmark">
			php-common rpm 下载,RPM软件包管理器及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. RPM介绍及其组成：
1.)RPM包简介：
rpm分为源码包，二进制包，Delta包三种。源码包将由rpm自动编译，安装。
2.)Linux中的包管理器：
dpkg: debian发行版本的包管理器。
rpm：redhat发行版的包管理器。
3.)程序包组成部分：
二进制程序:
/bin /sbin, /usr/bin /usr/sbin, /usr/local/bin
有些特殊程序放在/libexec目录中。
有些默认安装在/opt目录下。
库文件(开发库，运行库)：
/lib64, /usr/lib64
配置文件：
/etc
帮助文件：
/usr/share/man
帮助文件：手册man,信息页info。
4.)RPM程序包管理器：
数据库：
程序名及版本号。
软件包依赖关系。
软件包功能说明。
安装生成的各文件路径校验码。
程序组成清单：
文件清单。
安装卸载时运行的脚本。
二.RPM使用操作：
1.)RPM安装软件包命令。*安装过程中会多次显示waring key等信息，在后面会说密钥校验来解决。这里暂时忽略。
-i: 安装程序包。
# rpm -i zsh-4.3.10-7.el6.x86_64.rpm
warning: zsh-4.3.10-7.el6.x86_64.rpm: Header V3 RSA/SHA1 Signature, key ID c105b9de: NOKEY
-v: 安装时显示详细信息。
# rpm -iv zsh-4.3.10-7.el6.x86_64.rpm
Preparing packages for installation...
zsh-4.3.10-7.el6
-vv: 比v更加详细的信息。
# rpm -ivv zsh-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/747e857c14f4e14f0564afd4e21d1888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c803906ccdb54e717dc730596550360a/" rel="bookmark">
			如何应对爬虫请求频繁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多爬虫工作者在进行数据爬取过程中经常会遇到“您的请求太过频繁，请稍后再试”，这个时候心里莫名的慌和烦躁、明明爬虫代码也没有问题啊，怎么突然爬不动了呢？那么，很有可能，你的爬虫被识破了，这只是友好的提醒，如果不降低请求就会拉黑你的ip了。
我们都知道遇到这种情况使用代理就解决了，用代理IP确实不失为一个解决问题的好办法。IP被封了就换新IP继续爬，或者用很多IP同时多线程爬，都很给力的。但是有时候没有爬多久又被提示“您的请求太过频繁，请稍后再试”。再换IP还是被封，再换再封，封的越来越快，效率非常低下，这是为什么呢？
那是因为，你用的代理IP凑巧也是别人用来访问相同的网站的，而且用的还比较频繁。可能你们使用了共享ip池，或者使用的代理ip池很小。所以我们在找代理IP的时候，在保证IP有效率的同时IP池越大越好的，这样可以保证IP的新鲜度。例如亿牛云…列如还有的在使用代理的过程中也出现这样的情况。HTTP\HTTPS代理，系统会返回429 Too Many Requests；但不会对爬虫的运行产生影响，爬虫会根据返回结果自动重新发起请求，这是HTTP\HTTPS的标准应答模式。
所以，当您遇到“您的请求太过频繁，请稍后再试”时，不要慌，要镇定，检查下自己的爬虫策略，是否真的访问太过频繁，检查下自己的代理IP是否真的比较干净，调整自己的策略，选择更加纯净的IP，就能有效的避免这个错误了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f701040f9bb3bc53bf9a4720641fc4f/" rel="bookmark">
			支持UEFI的原装win10安装U盘制作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在电脑主板都是uefi的了。要重装系统就得使用原装win10安装盘且支持uefi，下面我就来介绍一下如何制作。
1，去msdn上下载原版win10镜像。下载
最好使用迅雷下载。
2，下载rufus。下载
3，准备好一个U盘或移动硬盘（建议使用usb3.0U盘或移动硬盘，这样写入和安装系统时会更快）
4,插上U盘或移动硬盘，打开刚刚下载的rufus
如果是移动硬盘，记得展开“显示高级选项”并勾选“显示usb外接硬盘”
5，选择硬盘，选择刚刚下载好的镜像文件(引导类型选择栏的选择按钮），镜像选项为标准Windows安装，分区类型GPT，目标系统类型UEFI(非CSM)，选择完后如下图：
6，点下面开始按钮，等待其写入完成即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f122fd0a09f79bdadd86cb52a7c0e3eb/" rel="bookmark">
			查找子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个字符串查找的简单函数。
函数接口定义：
char *search( char *s, char *t ); 函数search在字符串s中查找子串t，返回子串t在s中的首地址。若未找到，则返回NULL。
裁判测试程序样例：
#include &lt;stdio.h&gt; #define MAXS 30 char *search(char *s, char *t); void ReadString( char s[] ); /* 裁判提供，细节不表 */ int main() { char s[MAXS], t[MAXS], *pos; ReadString(s); ReadString(t); pos = search(s, t); if ( pos != NULL ) printf("%d\n", pos - s); else printf("-1\n"); return 0; } /* 你的代码将被嵌在这里 */ 输入样例1：
The C Programming Language ram 输出样例1：
10 输入样例2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f122fd0a09f79bdadd86cb52a7c0e3eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90f05f0c773b6710dd2b81fffa03a12/" rel="bookmark">
			Quartus II各版本支持的器件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前用的时Quartus9.0版本，因为使用的器件时Stratix II，所以以为只能用老版本的工具。但是从Quartus从13.0开始将器件库独立出来，可让用户选择性的安装。 如下图，Quartus13.0是支持Stratix II的，所以果断卸载老版本。
器件库下载的话，下载Cyclone系列和Stratix系列即可满足我的需要。
器件库是与软件协同的，选择相应的软件版本，然后下载对应的器件库。
器件库的下载地址：https://fpgasoftware.intel.com/18.0/?edition=pro&amp;platform=windows
也可以通过下面的方式安装，不过前提也是要下载好器件库。
下载下来之后不能用，显示找不到qdz文件。
参考下面这篇博客
https://blog.csdn.net/z123459985/article/details/105349357
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d836210b9e1f6031248bcf9657812e4e/" rel="bookmark">
			Flask Mega-Tutorial V2.0 第23章：应用程序编程接口（API）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在Flask Web Development作者博客看到第二版Flask Mega-Tutorial已在2017年底更新，现翻译给大家参考，希望帮助大家学习flask。
这是Flask Mega-Tutorial系列的第二十三章，也是最后一章。其中我将告诉您如何使用应用编程接口（或API）扩展Microblog，客户可以使用它来处理应用，以一种比传统的web浏览器工作流更直接的方式。
供您参考，以下是本系列文章的列表。
第1章：Hello, World！第2章：模板 第3章：Web表单第4章：数据库第5章：用户登录第6章：配置文件页面和头像第7章：错误处理第8章：关注与被关注第9章：分页第10章：电子邮件支持第11章：整容第12章：日期和时间第13章：I18n和L10n第14章：Ajax第15章：大型应用程序结构第16章：全文搜索第17章：在Linux上部署第18章：在Heroku上部署第19章：Docker容器上的部署第20章：一些JavaScript Magic第21章：用户通知第22章：后台工作第23章：应用程序编程接口（API）（本文） 注意1：如果您正在寻找本教程的旧版本，请在此处。
注意2：如果您想在此博客上支持我的工作，或者只是没有耐心等待每周的文章，我将提供完整的本教程版本，打包成电子书或视频集。欲了解更多信息，请访问courses.miguelgrinberg.com。
我为此应用构建的所有功能都只适用于特定类型的客户端：Web浏览器。 但其他类型的客户端呢？ 例如，如果我想构建Android或iOS APP，有两种主流方法可以解决这个问题。 最简单的解决方案是构建一个简单的APP，仅使用一个Web视图组件并用Microblog网站填充整个屏幕，但相比在设备的Web浏览器中打开网站，这种方案几乎没有什么卖点。 一个更好的解决方案（尽管更费力）将是构建一个本地APP，但这个APP如何与仅返回HTML页面的服务器交互呢？
这就是应用编程接口（API）的能力范畴了。 API是一组HTTP路由，被设计为应用程序中的低级入口点。与定义返回HTML以供Web浏览器使用的路由和视图函数不同，API允许客户端直接使用应用的资源，从而决定如何通过客户端完全地向用户渲染信息。 例如，Microblog中的API可以向用户提供用户信息和用户帖子，并且它还可以允许用户编辑现有帖子，但仅限于数据级别，不会将此逻辑与HTML混合。
如果您研究了应用中当前定义的所有路由，会注意到其中的几个符合我上面使用的API的定义。 找到它们了吗？ 我说的是返回JSON的几条路由，比如第十四章中定义的 /translate 路由。 这种路由的内容都以JSON格式编码，并在请求时使用POST方法。 此请求的响应也是JSON格式，服务器仅返回所请求的信息，客户端负责将此信息渲染给用户。
尽管应用中的JSON路由对其具有API的“感觉”，但它们旨在支持在浏览器中运行的Web应用程序。设想一下，如果智能手机APP想要使用这些路由，它将无法使用，因为它们需要用户登录，并且只能通过HTML表单进行。在本章中，我将展示如何构建不依赖于Web浏览器的API，并且不会假设连接到它们的客户端的类型。
本章的GitHub链接为：Browse, Zip, Diff.
REST API设计风格 有些人可能会强烈反对上面提到的 /translate 和其他JSON路由是API路由。 其他人可能会同意，但也会认为它们是一个设计糟糕的API。 那么一个精心设计的API有什么特点，为什么上面的JSON路由不是一个好的API路由呢？
您可能听说过REST API。 REST（Representational State Transfer）是Roy Fielding在博士论文中提出的一种架构。 该架构中，Dr. Fielding以相当抽象和通用的方式展示了REST的六个定义特征。
除了Dr.Fielding的论文外，没有关于REST的权威性规范，从而留下了许多细节供读者解读。 一个给定的API是否符合REST规范的话题往往是REST“纯粹主义者”之间激烈争论的源头，REST“纯粹主义者”认为REST API必须以非常明确的方式遵循全部六个特征，而不像REST“实用主义者”那样，仅仅将Dr. Fielding在论文中提出的想法作为指导原则或建议。Dr.Fielding站在纯粹主义阵营的一边，并在博客文章和在线评论中的撰写了一些额外的见解来表达他的愿景。
目前实施的绝大多数API都遵循“实用主义”的REST实现。 包括来自Facebook，GitHub，Twitter等“大玩家”的大部分API都是如此。很少有公共API被一致认为是纯REST，因为大多数API都没有包含纯粹主义者认为必须实现的某些细节。 尽管Dr. Fielding和其他REST纯粹主义者对评判一个API是否是REST API有严格的规定，但软件行业在实际运用中引用REST是很常见的。
为了让您了解REST论文中的内容，以下各节将介绍Dr. Fielding列举的六项原则。
客户端 - 服务器 客户端-服务器原则 相当简单，因为它简单说明了，在REST API中，客户端和服务器的角色应该明确地区分。实际上，这意味着客户端和服务器处于单独的进程中，这些进程通过传输进行通信，在大多数情况下，传输是通过TCP网络上的HTTP协议进行的。
分层系统 分层系统原则是说，当客户端需要与服务器通信时，它可能最终连接到代理服务器而不是实际的服务器。对于客户端，如果不直接连接到服务器，则发送请求的方式应该绝对没有区别，实际上，它甚至可能不知道它是否连接到目标服务器。同样，这个原则规定服务器兼容直接接收来自代理服务器的请求，所以它绝不能假设连接的另一端一定是客户端。
这是REST的一个重要特性，因为能够添加中间节点的这个特性，允许应用程序架构师使用负载均衡器、缓存、代理服务器等来设计满足大量请求的大型复杂网络。
缓存 该原则扩展了分层系统，通过明确指出允许服务器或代理服务器缓存频繁且相同请求的响应内容以提高系统性能。 有一个您可能熟悉的缓存实现：所有Web浏览器中的缓存。 Web浏览器缓存层通常用于避免一遍又一遍地请求相同的文件，例如图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d836210b9e1f6031248bcf9657812e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4dd4070a3a06c3b2d563a1dd71f3cd4/" rel="bookmark">
			2021-03-22
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、kubenetes镜像包下载地址
https://github.com/kubernetes/kubernetes/releases/tag/v1.17.12
一定要下载amd64位的。
kubernetes.tar.gz https://dl.k8s.io/v1.17.14/kubernetes.tar.gz
kubernetes-src.tar.gz https://dl.k8s.io/v1.17.14/kubernetes-src.tar.gz
kubernetes-client-linux-amd64.tar.gz https://dl.k8s.io/v1.17.14/kubernetes-client-linux-amd64.tar.gz
kubernetes-server-linux-amd64.tar.gz https://dl.k8s.io/v1.17.14/kubernetes-server-linux-amd64.tar.gz
kubernetes-node-linux-amd64.tar.gz https://dl.k8s.io/v1.17.14/kubernetes-node-linux-amd64.tar.gz
https://dl.k8s.io 这个网站一般打不开。
2、bashboard下载地址
kubernetes\kubernetes\cluster\addons\bashboard #模板地址
https://github.com/kubernetes/dashboard/releases
3、dns-yaml的模板路径-k8s1.19
kubernetes\kubernetes\cluster\addons\dns\coredns
下载路径：
https://github.com/coredns/coredns/releases
部署包路径 https://github.com/coredns/deployment/tree/master/kubernetes
4、阿里云的镜像地址
https://developer.aliyun.com/mirror/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76890ff3290a27ddf873a0f819e41f3a/" rel="bookmark">
			Could not load dynamic library ‘libcudart.so.10.1‘； dlerror: libcudart.so.10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CUDA 10.2 使用tensorflow 2.3 报错
解决办法：
建立软链接：
sudo ln -s /usr/local/cuda-10.2/targets/x86_64-linux/lib/libcudart.so.10.2 /usr/lib/x86_64-linux-gnu/libcudart.so.10.1 因为libcudart.so.10.2兼容libcudart.so.10.1，所以用10.2替代10.1。
测试：
import tensorflow as tf tf.test.is_gpu_available() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4a98502b611be7e259b825188166ac/" rel="bookmark">
			ORB-SLAM2 代码（&#43;理论）解析（二）： System.cc 内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、具体代码： 二、主要功能（总管） 三、包含的程序
3.1 mpTracker = new Tracking( )
3.2 SLAM.TrackMonocular(im,tframe)
3.3 System::Shutdown函数
3.4 SLAM.SaveKeyFrameTrajectoryTUM("KeyFrameTrajectory.txt")
一、具体代码： ORB_SLAM2::System SLAM(argv[1],argv[2], ORB_SLAM2::System::MONOCULAR, true)
/** * strVocFile 为词典文件 * strSettingsFile 为设置配置文件 * sensor sensor类型，单目、双目和RGBD * bUseViewer 是否进行相机位姿和图片帧显示 */ System::System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eSensor sensor, const bool bUseViewer):mSensor(sensor), mpViewer(static_cast&lt;Viewer*&gt;(NULL)), mbReset(false),mbActivateLocalizationMode(false), mbDeactivateLocalizationMode(false) { // Output welcome message cout &lt;&lt; endl &lt;&lt; "Welcome to use ORB_SLAM2 project !" &lt;&lt; endl; // 输出当前传感器类型 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df4a98502b611be7e259b825188166ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c168ce77355992347256fe93ad8a5903/" rel="bookmark">
			大数据——MongoDB在大数据场景下的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB在大数据场景下的应用 MongoDB概述MongoDB数据模型与RDBMS对比MongoDB数据模型MongoDB的安装MongoDB client ShellDataBase操作Collection操作Document插入操作Document查询操作（一）Document查询操作（二）Document更新操作Document删除操作Document操作——Bulk-Write 索引副本集（复制）聚集分析管道模式聚集分析MapReduce聚集分析简单聚集函数 写关注（Write Concern）读关注（Read Concern）Java操作MongoDBMongoDB与Hadoop平台整合加载CSV文件到MongoDBMongoDB与Hive整合MongoDB与Spark整合MongoDB认证 MongoDB概述 MongoDB是一个开源的NoSQL数据库 使用C++编写的具有动态模式的面向文档的数据库动态模式支持流畅的多态性将数据存储在类似JSON的文档中（BSON）使用文档（对象） 更趋近于许多编程语言 MongoDB特点 高性能易部署易使用存储数据非常方便 MongoDB数据模型与RDBMS对比 RDBMSMongoDBDataBaseDataBaseTableCollectionIndexIndexRowDocumentColumnField MongoDB数据模型 当个集合中的文档不必具有相同的字段，集合的不同文档的字段的数据类型可能有所不同 最佳实践：一般情况下，集合中的文档具有相似的结构 模式验证 创建集合或更改集合时指定JSON模式，模式验证发生在插入和更新期间，已经存在的文档不接受验证检查，回到被修改 上限集合 固定大小的集合，集合填满分配的空间后，通过覆盖集合中最旧的文档来存放新文档 MongoDB的安装 步骤
配置yum源 vi /etc/yum.repos.d/mongodb.repo [MongoDB] name=MongoDB Repository baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/4.0/x86_64/ gpgcheck=0 enabled=1 下载 yum install mongodb-org 启动 sudo systemctl start mongod.service MongoDB client Shell 启动client shell命令 // 启动client $ mongo // 查看版本 $ mongod --version shell基本操作 // 显示所有数据库 show dbs //查看当前的数据库名字 db //切换数据库 use events //显示所有集合 show collections DataBase操作 DataBase 创建 use命令后跟的数据库名，如果存在就进入此数据库，如果不存在就创建使用命令use命令创建数据库后，并没有真正生成对应的数据文件，如果此时退出，此数据库将被删除，只有在此数据库中创建集合后，才会真正生成数据文件 删除当前数据库 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c168ce77355992347256fe93ad8a5903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b4658e10352681ebd73dd58e7ce6d1/" rel="bookmark">
			判断web访问是内网或是外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目中添加一个支持外网下载的功能。因为内外网不同的下载URL，所以需要判断当前网络是否为外网。
首先方案是在java代码中判断
HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest(); String urlProtocol = request.getScheme(); if (urlProtocol.equals("http")) { // } else { // } 理论上看这个问题，解决的比较完美，但是实际操作下来，还是有些问题，一直是http,从来没有出现过https,应该是应用经过nginx转发，一直都是http,如果想在java中进行判断，需要再nginx中进行配置，这种还是比较麻烦的。
然后我又转换思路，在js中进行判断，然后将判断结果反馈到后端。
var isHttps = 'https:' == document.location.protocol ? 1 : 0; 在js中很容易就实现判断内外网访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba5d8f5afd974fff9a316e927b47f39/" rel="bookmark">
			准确率99.9%的离线IP地址定位库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ip2region是什么？ ip2region - 准确率99.9%的离线IP地址定位库，0.0x毫秒级查询，ip2region.db数据库只有数MB，提供了java,php,c,python,nodejs,golang,c#等查询绑定和Binary,B树,内存三种查询算法。
Ip2region特性 99.9%准确率 数据聚合了一些知名ip到地名查询提供商的数据，这些是他们官方的的准确率，经测试着实比经典的纯真IP定位准确一些。
ip2region的数据聚合自以下服务商的开放API或者数据(升级程序每秒请求次数2到4次):
01, &gt;80%, 淘宝IP地址库, http://ip.taobao.com/
02, ≈10%, GeoIP, https://geoip.com/
03, ≈2%, 纯真IP库, http://www.cz88.net/
**备注：**如果上述开放API或者数据都不给开放数据时ip2region将停止数据的更新服务。
标准化的数据格式 每条ip数据段都固定了格式：
_城市Id|国家|区域|省份|城市|ISP_ 只有中国的数据精确到了城市，其他国家有部分数据只能定位到国家，后前的选项全部是0，已经包含了全部你能查到的大大小小的国家（请忽略前面的城市Id，个人项目需求）。
体积小 包含了全部的IP，生成的数据库文件ip2region.db只有几MB，最小的版本只有1.5MB，随着数据的详细度增加数据库的大小也慢慢增大，目前还没超过8MB。
查询速度快 全部的查询客户端单次查询都在0.x毫秒级别，内置了三种查询算法
memory算法：整个数据库全部载入内存，单次查询都在0.1x毫秒内，C语言的客户端单次查询在0.00x毫秒级别。binary算法：基于二分查找，基于ip2region.db文件，不需要载入内存，单次查询在0.x毫秒级别。b-tree算法：基于btree算法，基于ip2region.db文件，不需要载入内存，单词查询在0.x毫秒级别，比binary算法更快。 任何客户端b-tree都比binary算法快，当然memory算法固然是最快的！
多查询客户端的支持 已经集成的客户端有：java、C#、php、c、python、nodejs、php扩展(php5和php7)、golang、rust、lua、lua_c, nginx。
ip2region快速测试 maven仓库地址 &lt;dependency&gt; &lt;groupId&gt;org.lionsoul&lt;/groupId&gt; &lt;artifactId&gt;ip2region&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; Java实现 public static String getCityInfo(String ip){ //db String dbPath = "src/main/resources/ip2region.db"; File file = new File(dbPath); if ( file.exists() == false ) { System.out.println("Error: Invalid ip2region.db file"); return null; } //查询算法 int algorithm = DbSearcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ba5d8f5afd974fff9a316e927b47f39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4886c8330e76024df1840718c5ac497/" rel="bookmark">
			vcs安装记录 Ubuntu18.04.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vcs安装记录 安装环境：64位Ubuntu18.04.5 LTS
安装时间：2021.3.18
安装包及破解软件：https://blog.csdn.net/huayangshiboqi/article/details/89525723，整个安装需要约10GB的磁盘空间
文章目录 vcs安装记录1. g++ gcc 4.8版本安装2.建立相关文件夹3. 安装4. 激活5. 运行6. More 1. g++ gcc 4.8版本安装 $ ll /usr/bin/gcc* #查看g++ gcc版本 $ sudo apt install gcc-4.8 gcc-4.8-multilib g++-4.8 g++-4.8-multilib #安装4.8，因为vcs要用 # 参考自：https://www.jianshu.com/p/f66eed3a3a25 2.建立相关文件夹 #这是软件要被安装的位置，所以先把终端打开到自己想要安装到的路径下 $ mkdir synopsys $ cd synopsys $ mkdir vcs_2016.06 $ mkdir scl_11.9 $ mkdir verdi_2016.06-1 3. 安装 # 终端路径切换为下载的安装包所在位置 #安装synopsys installer，这是一个安装器，用来安装它自家的软件 $ ./SynopsysInstaller_v3.3.run #要输入路径的时候直接确定就好，会在路径下生成一个setup.sh文件 #安装csh(接下来需要依赖的工具) $ sudo apt install csh #执行sh脚本 $ ./setup.sh 在打开的界面中依次安装scl、vcs、verdi（三个安装步骤一样，如下）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4886c8330e76024df1840718c5ac497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b8cd94068a5397173d51739719d3889/" rel="bookmark">
			SpringBoot父子maven工程执行install出现各种错误总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.maven工程执行install出现： [ERROR] 'dependencies.dependency.version' for org.springframework.cloud:spring-cloud-starter-feign:jar is missing. 解决思路：maven官方已经将spring-cloud-starter-feign改成了spring-cloud-starter-openfeign，旧版本已经作废
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;!-- &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;--&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2.Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.0.5.RELEASE:repackage (default) on project xc-framework-common: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:2.0.5.RELEASE:repackage failed: Unable to find main class： 解决思路父工程pom.xml改成：
&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.whm.SpringbootTestApplication&lt;/mainClass&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt; &lt;/plugin&gt; 3.Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project test-freemarker: There are test failures. 解决思路：在执行install模块的pom.xml加入如下依赖：
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.21.0&lt;/version&gt; &lt;configuration&gt; &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb412c08ad12f3eaf9ee73bdbf2be52/" rel="bookmark">
			visual studio 查看类的uml图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在阅读代码时，一般都想先了解一下一个类的层次结构，比如从哪里继承，有些工具可以提供此功能，但还需要单独安装工具，有的甚至还是付费的，这里我说明一下visual studio的查看类图功能，以visual studio 2019为例，首先需要安装一个组件：类设计器，打开visual studio 2019，点击菜单栏工具，选择获取工具和功能项，在弹出的安装程序窗口中选择 单个组件项，然后在搜索框中输入类设计器或拖动上下进度条来选择，勾选类设计器，点击修改，安装完成后重启visual studio 2019。
打开任一项目，点击菜单 视图，然后选择 类视图，在左侧的类视图中右键选中任意类，点击查看类图即可。效果如下：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/202/">«</a>
	<span class="pagination__item pagination__item--current">203/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/204/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>