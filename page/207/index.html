<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19216d9d295954eda3c29ea291c5e48/" rel="bookmark">
			pyecharts 数据可视化  Bar柱状图生成和颜色优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python pyecharts包之柱形图 基本的柱形图通过循环将数据添加y轴上Jscode包 对pyecharts包中使用js代码的集成，对于会js的，可太友好了，也很实用原始图、、配置项中使用js生成的颜色 基本的柱形图 最基本的使用pyecharts包绘制柱形图
#需要加载的包 #柱形图的包 from pyecharts.charts import Bar #pyecharts配置项的包 from pyecharts import options as opts #pyecharts中使用js的包 from pyecharts.commons.utils import JsCode #Pyecharts图表生成需要一些静态资源文件，通过下面代码更改为kesci提供的资源，提高加载速度 from pyecharts.globals import CurrentConfig CurrentConfig.ONLINE_HOST = "https://cdn.kesci.com/lib/pyecharts_assets/" ''' 需要加载的数据 x 轴和y轴数据 ''' x_data = ['Apple', 'Huawei', 'Xiaomi', 'Oppo', 'Vivo', 'Meizu'] y_data1 = [123, 153, 89, 107, 98, 23] y_data2 = [44,55,66,77,888,99] y_data3 = [173, 103, 989, 607, 98, 10] bar=(Bar() .add_xaxis(x_data) .add_yaxis('数据集1',y_data1) .add_yaxis('数据集2',y_data2) .add_yaxis('数据集3',y_data3) ) #这里通过柱状图的方法来绘制图表 bar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19216d9d295954eda3c29ea291c5e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6487b847ba932394ea8a38622eae2c/" rel="bookmark">
			java黄油刀_github 黄油刀（注解） butterknife
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		butterknife
便捷开发
1、下载
Project-&gt;
dependencies {
...
classpath 'com.jakewharton:butterknife-gradle-plugin:8.5.1'
...
}
2、下载
App-&gt;
dependencies {
...
implementation 'com.jakewharton:butterknife:8.5.1'
annotationProcessor "com.jakewharton:butterknife-compiler:8.5.1"
...
}
3、使用
注意：这里的View不可以是private或static类型
1.代替findViewById()
TextView textView = (TextView) findViewById(R.id.text_view);
直接-&gt;
@BindView(R.id.text_view)
TextView mTextView;
然后在onCreate()的setContentView()下添加ButterKnife.bind(this);
Activity中：
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
ButterKnife.bind(this);
}
Fragment中：
View rootView = inflater.inflate(R.layout.frag_main, container, false);
ButterKnife.bind(this, rootView);//这里有些不同
Adapter中:
static class ViewHolder {
@BindView(R.id.text_view) TextView mTextView;
@BindView(R.id.button) Button mButton;;
public ViewHolder(View view) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed6487b847ba932394ea8a38622eae2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e951feaa63841a6369dfad7d5602e716/" rel="bookmark">
			二建市政
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b8c8569061d67e8db07b2f8b805865/" rel="bookmark">
			大数据——Ubuntu配置docker的阿里云镜像加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu配置docker的阿里云镜像加速 阿里云镜像加速 阿里云镜像加速 由于docker的官方的镜像源速度太慢，在国内可以通过使用阿里云或者网易云的镜像源提高下载速度，通常使用阿里云的镜像源，下面介绍怎么使用阿里云的镜像加速器。
注册阿里云账号 可以使用自己的支付宝账号等号。
登录阿里云控制台 依次点击右上角控制台——&gt;左侧栏的产品与服务——&gt;找到容器镜像服务
点击该服务，再点击最下面的镜像加速器
配置
按照阿里云给的配置命令依次配置即可 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { "registry-mirrors": ["https://5hnbz1fa.mirror.aliyuncs.com"] } EOF sudo systemctl daemon-reload 重启docker
sudo systemctl restart docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c80233856b443c79c5dcfcff32936566/" rel="bookmark">
			搜索的一般过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前学习过很多刘老师的lucene源码分析的课程，结果现在整的都忘了，这次重新梳理一下争取形成自己的东西。
后面就不容易忘掉了。
刘老师的课程是基于lucene2.x的源码分析的，后面lucene迭代了很多版本，也引入了新的数据结构进行优化，但是主体的模块基本上是没有变的。计划是先把之前的lunce的数据结构整理一下，因为可以查阅刘老师的课程，可以有很好的参考作用。在这个基础上再整理和对比新的lucene的优化点，基于lucene7.x在这里主要关注lucene的存储结构，因为了解了存储结构基本上就了解了大体的实现。
1. 搜索的概览 搜索主要是解决用户基于文本进行搜索的问题。比如在很多本书中搜索一些内容，或者搜索一些帖子，博客等等。
一个搜索服务架构分为两大部分：索引+搜索。
1.1 索引 索引的过程又分为数据采集，清洗，进入lucene等等，这里我们不关注数据源的问题，只关注索引在进入lucene会有哪些操作。
1.1.1. 数据处理 在往lucene进行数据存储的时候首先会进行分词，比如"我的家乡是河南"，"this ARE GOOD books " 在下面显示了对应的分词结果
GET user/_analyze { "analyzer": "ik_smart", "text": ["我的家乡是河南"] } 对应的分词结果是 { "tokens" : [ { "token" : "我", "start_offset" : 0, "end_offset" : 1, "type" : "CN_CHAR", "position" : 0 }, { "token" : "的", "start_offset" : 1, "end_offset" : 2, "type" : "CN_CHAR", "position" : 1 }, { "token" : "家乡", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c80233856b443c79c5dcfcff32936566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b8528fc78a6fefb59c9f1f1e3c4bf3/" rel="bookmark">
			elasticsearch index doc过程概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述1.es中的基础概念2.es中的索引过程2.1 一次index请求的大体流程2.2 为什么是near real time2.3 为什么要有translog2.3.1 translog的作用2.3.2 translog的持久化机制2.3.2 commit产生的时机 概述 这里主要讲讲es index的过程，努力揭示es在index过程中具体做了哪些工作。
从而增加我们对es的了解，以便于更好的使用和优化es。
1.es中的基础概念 es的基础支撑是使用lucene,每个es的索引(index)有多个shard，每个shard都是一个独立的lucene实例每个lucene实例通过多个segment来管理自己存储的数据，每个segment可一个认为是独立的存储单元，从存储功能上来说类似于mysql中分表中的一张表每个lucene实例同时引入了一个commit的概念来管理segment,因为segment是要写入磁盘的，如果每产生一个segment都要写入磁盘的话，那么效率会受到影响，所以一般都是多个segment进行一次写磁盘操作，叫做commit，每次commit记录了本次提交的节点的一个快照信息。也就是一个commit check point。这里的每个commit 产生的check point 对应的文件是lucene data存储目录下的segment_N文件，看lucene网上说每个lucene实例中可能有多个segment_N文件(主要是因为有些segment_N文件暂时不能删除，或者使用了自定义的删除策略)
参考这里只有数据进入一个segment当中才能够被搜索到。 2.es中的索引过程 基于上面的基础知识，我们来梳理一下对于客户端通过http请求过来的一个index操作，对应的在elasticsearch的后端会对应的经历哪些操作
2.1 一次index请求的大体流程 请求的路由:请求可能被发往es集群当中的任意一个节点（此时假设为A）。所有在Elasticsearch集群中的节点都包含：有关哪个分片存在于哪个节点上的元数据。根据一定的规则计算该文档需要被发往哪个shard(主要是根绝文档的id来计算),接收请求的节点将请求路由到对应的主分片所在节点(假设为B)。
请求的处理:当节点B接收到来自节点A的请求时，请求被写入到translog（下面会讲到），并将该文档添加到内存缓冲区。如果请求在主分片上成功，则请求将并行发送到副本分片。只有在所有主分片和副本分片上的translog被持久化(fsync’ed)后，客户端才会收到该请求成功的确认。
2.2 为什么是near real time 在经过上面两步介绍，基本上了解了es处理请求的一个大致的套路
那为什么说es是一个近实时(near real time)的搜索引擎呢，因为通过上面的请求写进es的文档并不能立即被搜索到。正常情况下可能会有一秒钟的延迟，也就是在add之后，最长可能需要经过1s以后才能搜索的到。是什么原因导致的呢，我们就来更进一步的深入其中。
上面第2步当中的内存缓冲区中的内容是不能直接被搜索的，因为在lucene，只有一个打开的segment才能被搜索，此时缓冲区的内容还不是在一个段当中，但是缓冲区的内容会以固定的间隔刷新（默认为1秒）刷新的过程是:
将内存缓冲区的内容写入文件系统缓存中的新段。此新段的内容更尚未被写入文件系统，但是分段是打开的，内容可被搜索。清空内存缓冲区。这里解释了搜索问什么是近实时的，也就是默认的情况下会有1s的延迟。 当然，这里的内存缓冲区刷新到文件系统缓存的节奏是可以控制的，我们可以通过设置"refresh_interval": "1s"来设置刷新的时间间隔;或者进行强制刷新POST /${index}/_refresh(但是这个在生产中不太建议频繁使用)
文件系统缓存中的数据会在满足一定的条件下进行持久化操作，写入磁盘，产生一个commit check point。
2.3 为什么要有translog 在前面讲es应对一次写入请求的过程中提到，在主片写入请求之前会先生成一个tranlog并进行持久化。那么为什么要有这个呢。
2.3.1 translog的作用 其实es的translog很好理解，基本上和其他系统中的各种用于记录的log类似，比如mysql中的binlog,redis中的aof日志，都是为了快速记录操作记录，防止因服务宕机等产生数据的丢失，当然binlog和aof log可能更加强大，因为他们保存的时间更久一些，可以直接用来做数据的回溯等操作。
在上面的介绍中我们也可以看到，es除了translog的记录使用的是同步持久化的方式,其他的操作都是对内存的操作，包括内存缓冲区和文件系统缓存都是对内存的操作。假如在这中间产生了一些意外，比如你不小心踢掉了插头(这个理由确实有点烂。。。)，那么内存缓冲区和 文件系统缓存中的内容都丢了，即使你插上了插头，重新启动了服务，也是无济于事啊。这个时候tranlog就要闪亮登场力挽狂澜了。因为tranlog在请求能够给客户端正确返回的时候一般都是保证了已经进行了持久化的(默认是都会持久化，你也可以配置成非同步持久化模式，下面会介绍),所以这个时候就可以将translog中的数据拿出来进行回放就行了（并不是全部回放，只是和已经持久化的最后一次commit check point 对比，将之后的tanslog进行重放就行了）。
2.3.2 translog的持久化机制 同时translog的持久化机制也是可以设置的，主要分为同步和异步两种，设置分别如下
index.translog.durability:request|async request模式:这个是默认的模式，在每次写请求完成之后执行(index, delete, update, bulk)。这个过程在主分片和复制分片都会发生。最终， 基本上，这意味着在整个请求被 fsync 到主分片和复制分片的translog之前，你的客户端不会得到一个 200 OK 响应async模式:会在后台异步的按照一个配置参数"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b8528fc78a6fefb59c9f1f1e3c4bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152f52139d5be4dac85f9de618b9217f/" rel="bookmark">
			【谷歌日语输入法】离线安装包官方下载链接（Windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://dl.google.com/japanese-ime/2.20.2750.0/googlejapaneseinput32.msi
http://dl.google.com/japanese-ime/2.20.2750.0/googlejapaneseinput64.msi
http://dl.google.com/japanese-ime/2.24.3250.0/googlejapaneseinput32.msi
http://dl.google.com/japanese-ime/2.24.3250.0/googlejapaneseinput64.msi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5802df8c219edf30715b967676b401/" rel="bookmark">
			java 100 基础题_java最最基础的题目(满分100分，笔试，不可上机)：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呢？
7.下边的结果是：
public class Test{
public static Collection getSort(){
Collection sort = new LinkedList();
sort.add("B");
sort.add("C");
sort.add("A");
return sort;
}
public static void main(String[] args) {
for(Object o:getSort()){
System.out.println(o);
}
}
} 8.下边代码的结果是：
public class Test{
public static void foo(Listl ){
}
public static void main(String[] args) {
Listl1 = new ArrayList();
foo(l1);
ArrayListl2 = new ArrayList();
foo(l2);
ArrayList l3 = new ArrayList();
foo(l3);
ArrayListl4 = new ArrayList();
foo(l4);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe5802df8c219edf30715b967676b401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3fba6333be90da1dc1241cc13f154bd/" rel="bookmark">
			机器学习基础篇（十二）——多层感知机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习基础篇（十二）——多层感知机 一、概述 多层感知机（MLP：Multi-Layer Perceptron）由感知机(PLA: Perceptron Learning Algorithm)推广而来。它最主要的特点是有多个神经元层，因此也叫深度神经网络(DNN: Deep Neural Networks)。
感知机是单个神经元模型，是较大神经网络的前身。神经网络的强大之处在于它们能够学习训练数据中的表示，以及如何将其与想要预测的输出变量联系起来。从数学上讲，它们能够学习任何映射函数，并且已经被证明是一种通用的近似算法。
神经网络的预测能力来自网络的分层或多层结构。而多层感知机是指具有至少三层节点，输入层，一些中间层和输出层的神经网络。给定层中的每个节点都连接到相邻层中的每个节点。输入层接收数据，中间层计算数据，输出层输出结果。
下面让我们来简单的看一下多层感知机的推导过程吧。
二、多层感知机的定义 首先我们先看一下感知机（PLA）是什么? 如图所示，感知机只有输入和输出层，这两层共同组成了一个简单的神经元。首先加权输入信号，然后使用激活功能，最终产生输出信号。
ω将输入的变量映射到了一个新的维度空间中，b的存在使得映射后的数据具有平移能力。（称为偏置量）
3.显然，PLA是一个线性的二分类器，但它对非线性的数据并不能进行有效的分类。因此我们可以加深这个神经元的网络层次，理论上来说，多层网络可以模拟任何复杂的函数。当我们加深到很多层的时候，我们就得到了一个多层感知机（MLP）。我们将第一层称之为输入层，最后一层称之有输出层，中间的层称之为隐层。MLP并没有限定隐层的数量，对于输出层神经元的个数也没有限制，所以我们可以根据各自的需求选择合适的隐层层数。 举个栗子：我们在输入层输入三个变量[x1,x2,x3]以及一个偏置量b，偏置量的作用是给网络分类增加平移的功能。 然后我们设置隐层为1层，输出神经元个数为3个。可以得到如下的神经网络结构：
三、节点 每层的神经元被称为节点，那么针对于一个多层感知机，我们应该如何选择层数和隐层节点数呢？
通常情况下，我们只需要一个隐层，就可以模拟任何我们想要的函数。所以，大多情况下我们使用一个三层的感知机即可（包含输入层，一个隐层，一个输出层）。
那么，节点又该怎么选择呢？
如果隐层节点过少，网络结构简单，学习能力不够。如果隐层节点过多，不仅会大大增加网络结构的复杂性，而且学习过程中更易陷入局部极小点，学习速度会变得很慢。
我们一般有以下几种方法来选择隐层的节点数：
m:隐层节点数n:输入层节点数I:输入层节点数α：1-10之间的整数 我们一般可以使用以下几个公式来选择节点数（当然也可以自己选择）
对于每个隐层的节点，我们都将会使用激活函数激活此节点。
通常情况下，节点根据前一层节点的加权总和来激活，即每个连接点的权重乘以该节点的激活函数的总和。
每个节点仅从前一层获取输入值，因此权重是同一层中节点的唯一区分依据。
常见的激活函数有：sigmoid函数，tanh函数
sigmoid函数：
tanh函数
四、反向传播 在训练神经网络时，我们预期的输出是输出层中每个节点的激活级别。根据实际激活情况，我们可以找到每个节点的cost（损失成本）。并根据损失成本的不同，相应地调整权重。
反向传播的算法就是根据每个节点的损失成本调整确定每个节点激活的权重。简单来说，在上文中，我们已经了解了如何选择隐层数目和节点数目的相关知识了。那么问题来了，我们应该如何去选择每个节点的权重呢？
这就要用到我们所说的反向传播算法了。
首先可以定义一个损失函数。（损失函数的相关知识见第一节相关知识）然后我们可以计算出每个节点的损失函数（该函数与该点的权重以及偏置量b有关）。选择合适的权重值以及偏置量b，使得损失函数达到最小值。具体的数学知识不再赘述请看下面这张截图，来自tensorflow测试站点。这里正在训练一个神经网络来对蓝色和橙色点进行分类。这里对节点所做的选择是任意的，读者可以做不同的尝试
讨论反向传播，让我们考虑一下这个网络第一步将做什么。它将在网络中测试一些训练数据，期望在(隐藏的)正确输出节点上看到完全激活，而在错误输出节点上没有激活。当模型不正确时，它将从输出层向后查看，发现错误。然后，它会相应地改变权重，所以离得远的权重会比离得近的权重变化更大。在这些前期步骤中，它将具有较高的学习率，这使权重不稳定。经过几次迭代之后，权重会更加稳定。记住这一点，让我们向前跳一步。
现在，网络对如何分类数据有一个模糊的概念。它有一个大致的圆圈，随着步骤的继续，分类会变得更加清晰。让我们再向前跳几步
如你所见，该模型已经开发出了更好的性能，可以准确地对大多数点进行分类。在这一点上，网络减慢了学习速度，因为它经过了足够多的迭代才取得了现在的精确度。 五、小结 在本节中，我们了解了多层感知机（MLP）神经网络以及其他神经网络的相关知识。我们了解了节点是什么，掌握了节点的计算方法。最后我们立即饿了反向传播的含义，知道了如何去选择节点的权重。
自学自用，希望可以和大家积极沟通交流，小伙伴们加油鸭。创作不易，动起可爱的双手，来个赞再走呗 (๑◕ܫ￩๑)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995f6b27f3f23e3107f0205e8d4298d3/" rel="bookmark">
			VUE3（七）vue项目抽离.vue文件中的js、css代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平常再做开发的时候，一般情况下不会将html，js，css代码写到一个文件中。
基本上都会写在各自对应的文件中，然后再引入即可。
那么在VUE中我们如何抽离vue文件中的js，与css代码呢？
1：抽离javascript Home.vue
&lt;template&gt; &lt;div&gt; &lt;div :style="{ padding: '24px', background: '#fff', minHeight: '360px' }"&gt; &lt;h1&gt;This is a home page&lt;/h1&gt; &lt;HelloWorld msg="Hello Vue 3.0 + Vite" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts"&gt; import { defineComponent } from "vue"; // 引入js文件 import home from '/@/assets/js/admin/home'; // 使用js对象 export default defineComponent({ ...home, }); &lt;/script&gt; Home.ts
import { defineComponent } from "vue"; import HelloWorld from "/@/components/HelloWorld.vue"; export default defineComponent({ name: "Home", components: { HelloWorld, }, }); 2：抽离css Admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995f6b27f3f23e3107f0205e8d4298d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e0c481161b40cfbde905a7a99ed9f3/" rel="bookmark">
			前端基础知识概述 -- 移动端开发的屏幕、图像、字体与布局的兼容适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是内部的一次分享沉淀，偏向基础但是涉及了一些有意思的细节，文笔有限，才疏学浅，文中若有不正之处，万望告知。
前端的一大工作内容就是去兼容页面在不同内核的浏览器，不同的设备，不同的分辨率下的行为，使页面的能正常工作在各种各样的宿主环境当中。
而本文的主题 -- 移动端开发的兼容适配与性能优化，就是希望能从一些常见的移动端开发问题出发，厘清 Web 移动端开发的前前后后，一些技术的发展过程，一些问题的优化手段以及给出一些常见的兼容性问题的解决方案。
什么是响应式设计 首先先聊聊响应式设计，这个与移动端开发有着密切的联系。
响应式设计即是 RWD，Responsive Web Design。
这里百度或者谷歌一下会有各种各样的答案。这里一段摘自知乎上我觉得很棒的一个答案：什么是响应式布局设计？[1]
根据维基百科及其参考文献，理论上，响应式界面能够适应不同的设备。描述响应式界面最著名的一句话就是“Content is like water”，翻译成中文便是“如果将屏幕看作容器，那么内容就像水一样”。
为什么要设计响应式界面 为什么要费神地尝试统一所有设备呢？
即便是 PC 或 Mac 用户，有数据显示只有一半的人会将浏览器全屏显示，而剩下的一般人使用多大的浏览器，很难预知；
台式机、投影、电视、笔记本、手机、平板、手表、VR……智能设备正在不断增加，“主流设备”的概念正在消失；
屏幕分辨率正飞速发展，同一张图片在不同设备上看起来，大小可能天差地别；
鼠标、触屏、笔、摄像头手势……不可预期的操控方式正在不断出现。
响应式界面的四个层次 同一页面在不同大小和比例上看起来都应该是舒适的；
同一页面在不同分辨率上看起来都应该是合理;
同一页面在不同操作方式（如鼠标和触屏）下，体验应该是统一的；
同一页面在不同类型的设备（手机、平板、电脑）上，交互方式应该是符合习惯的。
响应式界面的基本规则 可伸缩的内容区块：内容区块的在一定程度上能够自动调整，以确保填满整个页面
可自由排布的内容区块：当页面尺寸变动较大时，能够减少/增加排布的列数
适应页面尺寸的边距：到页面尺寸发生更大变化时，区块的边距也应该变化
能够适应比例变化的图片：对于常见的宽度调整，图片在隐去两侧部分时，依旧保持美观可用
能够自动隐藏/部分显示的内容：如在电脑上显示的的大段描述文本，在手机上就只能少量显示或全部隐藏
能自动折叠的导航和菜单：展开还是收起，应该根据页面尺寸来判断
放弃使用像素作为尺寸单位：用dp(对于前端来说，这里可能是rem)尺寸等方法来确保页面在分辨率相差很大的设备上，看起来也能保持一致。同时也要求提供的图片应该比预想的更大，才能适应高分辨率的屏幕
上面一段我觉得已经涵盖了响应式设计的绝大部分，简单总结起来，可以概括为：
媒体查询，边界断点的规则设定（Media queries &amp;&amp; break point）
内容的可伸缩性效果（Flexibel visuals）
流式网格布局(Fluid grids)
主要内容呈现及图片的高质量(Main content and high quality)
响应式 vs. 自适应 响应式设计是 Responsive Web Design（RWD），自适应设计是 Adaptive Web Design（AWD）。经常有人会将两者混为一谈，或者其实根本也区分不了所谓的响应式与自适应。
其实在我写这篇文章的时候，我也无法很好的去区分两者。
RWD 和 AWD 两者都是为了适配各种不同的移动设备，致力于提升用户体验所产生的的技术。核心思想是用技术来使网页适应从小到大（现在到超大）的不同分辨率的屏幕。通常认为，RWD 是 AWD 的子集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83e0c481161b40cfbde905a7a99ed9f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4eb9434e8f27c9f4404d5a21b0a3410/" rel="bookmark">
			java中invoke方法三个参数_java method.invoke通过反射调用可变参数个数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Reflect {
public static void main(String[] args) throws Exception {
Class&gt; clazz = Single.class;
Single single = (Single) clazz.newInstance();
List list = new ArrayList(){
private static final long serialVersionUID = 1L;
{
add("fuck");
add("ni");
add("mei");
}
};
//获取method两种方式， 在method中 数组的的空间大小是可以随便写的不一定使用0
/* 1 */
Method method = clazz.getDeclaredMethod("method", Array.newInstance(Object.class, 0).getClass());
/* 2 */
method = clazz.getDeclaredMethod("method", (new Object[0]).getClass());
//初始化参数
/* 1 */
Object objs = Array.newInstance(Object.class, 2);
Array.set(objs, 0, list);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4eb9434e8f27c9f4404d5a21b0a3410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea42513669047dc9867ebeb85b9e92e/" rel="bookmark">
			Git log基本使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2232e43d57ed43794013cd38213fb3f/" rel="bookmark">
			【Django】在订单跳转到支付宝支付页面时会出现的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面： 由于CSDN的审查机制的原因，更多博客内容请访问我的个人博客或GitHub：
个人博客地址：个人博客GitHub地址：GitHub 错误一：type error: quote_from_bytes() expected bytes 解决方案：
错误二：invalid-signature 错误原因: 验签出错，建议检查签名字符串或签名私钥与应用公钥是否匹配 解决方案：在确定代码中添加的公钥是支付宝的公钥而不是应用的公钥，私钥是应用的私钥，如果发现不是这个错误则判断以下代码是否书写错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5b551128b807a2f591c2fa2f2e5c22/" rel="bookmark">
			python 关于字典dict的fromkeys方法的巨坑，真的只有踩过之后才知道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 关于字典dict的fromkeys方法的巨坑，真的只有踩过之后才知道 1. 踩坑重现（错误示范）1.1 通过fromkeys初始化一个空的字典1.2 修改某一键下的值 2. 初始化字典的正确方法 本文试验的python版本为3.6.2，先来看下python3.6官方文档上对fromkeys的描述，极其简单：
看似简单方便，实则很坑！
在某些场景下，需要初始化一个字典，键是确定的，但是值是需要等待去填充或修改的，正好字典自带的fromkeys方法似乎刚好可以做到这个事情，并可以初始化所有键的值。
但是fromkeys有一个巨坑，真的只有踩过之后才知道，请耐心往下看
首先先看下这个坑是怎么产生以及如何坑人的。
1. 踩坑重现（错误示范） 1.1 通过fromkeys初始化一个空的字典 d = dict.fromkeys(['a', 'b', 'c'], {'score':0, 'type': []}) print(d) 初始化字典如下：
{ 'a': {'score': 0, 'type': []}, 'b': {'score': 0, 'type': []}, 'c': {'score': 0, 'type': []} } 1.2 修改某一键下的值 d['a']['score'] = 3 d['b']['type'].append('type b') print(d) { 'a': {'score': 3, 'type': ['type b']}, 'b': {'score': 3, 'type': ['type b']}, 'c': {'score': 3, 'type': ['type b']} } 发现没有！通过fromkeys创建的初始字典，当修改某一键下的值时，所有的值都会随之修改！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5b551128b807a2f591c2fa2f2e5c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961d5447ff627d03e57452e15f31f2e4/" rel="bookmark">
			java循环交叉_交叉两个不同对象类型的集合java 8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接等效于嵌套循环
List result = listOne.stream()
.flatMap(one -&gt; listTwo.stream()
.filter(two -&gt; one.getMyFirstProperty().equals(two.getMyOtherProperty()))
.map(two -&gt; new RootSampleClass(one, two)))
.collect(Collectors.toList());
重点是直接等效,其中包括做n×m操作的不良表现.
更好的解决方案是将其中一个列表转换为支持有效查找的数据结构,例如,哈希映射.此考虑因素与您使用的API的问题无关.既然您要求Stream API,您可以这样做：
Map&gt; tmp=listOne.stream()
.collect(Collectors.groupingBy(SampleClassOne::getMyFirstProperty));
List result = listTwo.stream()
.flatMap(two -&gt; tmp.getOrDefault(two.getMyOtherProperty(), Collections.emptyList())
.stream().map(one -&gt; new RootSampleClass(one, two)))
.collect(Collectors.toList());
请注意,两种解决方案都会创建所有可能的配对,以便在一个或两个列表中多次出现属性值.如果属性值在每个列表中都是唯一的,例如ID,则可以使用以下解决方案：
Map tmp=listOne.stream()
.collect(Collectors.toMap(SampleClassOne::getMyFirstProperty, Function.identity()));
List result = listTwo.stream()
.flatMap(two -&gt; Optional.ofNullable(tmp.get(two.getMyOtherProperty()))
.map(one -&gt; Stream.of(new RootSampleClass(one, two))).orElse(null))
.collect(Collectors.toList());
如果您不介意可能执行双重查找,则可以使用以下更易读的代码替换最后一个解决方案：
Map tmp=listOne.stream()
.collect(Collectors.toMap(SampleClassOne::getMyFirstProperty, Function.identity()));
List result = listTwo.stream()
.filter(two -&gt; tmp.containsKey(two.getMyOtherProperty()))
.map(two -&gt; new RootSampleClass(tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/961d5447ff627d03e57452e15f31f2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c4a16836d1733b2735922e88469e19/" rel="bookmark">
			时间序列的特征工程——针对Hurst指数的Python计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间序列的特征工程——针对Hurst指数的Python计算(附Github代码) Github地址：Hurst指数计算Python脚本
最近两天为了整一个Hurst指数的计算翻了不少资料，百度到好多代码算出来结果不是大于1就是为负数，遂硬着头皮自己重造了个轮子，分享之。
以下为一些简单的科普，不明白的小伙伴可以百度Hurst了解这是什么玩意儿。
·什么是Hurst指数？
赫斯特指数(Hurst Exponent)是用来衡量时间序列是否有长期记忆的一个指标，这一指标最初由英国水利学家Harold Edwin Hurst提出，也以他的名字命名。哈罗德最初提出这个指数是为了研究尼罗河发洪水和干旱的时间序列规律从而决定最优的大坝尺寸，然而金融界人士却发现这个指数对于金融市场也有作用，被广泛用于资本市场的混沌分形分析。
Hurst指数&gt; 0.5，序列具有长期记忆性，未来的增量和过去的增量相关，继续保持现有趋势的可能性强。
Hurst 指数&lt; 0.5，很有可能是记忆的转弱，趋势结束和反转的开始(mean reversion)。
Hurst指数= 0.5，序列接近随机游走(Random Walk)，无定向运动。
·参考文献
1.叶中行, 曹奕剑. Hurst指数在股票市场有效性分析中的应用[J]. 系统工程, 2001, 3(19): 21-24
2.Hurst exponent - Wikipedia
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8779ef190522e434d552e7d1783dd1d/" rel="bookmark">
			SigFit—光—机—热耦合分析软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美国Sigmadyne公司的SigFit软件是光机热耦合分析工具，可以将有限元分析得到的光学表面变形等结果文件通过多项式拟合或插值转化为Zemax/CodeV等光学分析软件的输入文件，还可实现动态响应分析、光程差分析、设计优化和主动控制光学系统的促动器布局及优化等。SigFit帮助用户解决了不同学科间的数据传递难题，缩短了研发周期，节省了研发成本，有效提升了光学设计仿真精度，一定程度上提高了光机产品的成像质量与环境适应性。目前，SigFit已广泛应用于成像光学镜头、光学传感器、激光通信、显微光刻等产品的研发。
经纬恒润针对客户需求，提供了成熟的光—机—热集成分析与优化设计解决方案，基于多学科集成与设计优化的思路，实现设计光、机械、电、热等跨学科综合系统的自动化仿真与设计优化。
产品介绍
• 基本功能
♦ 面型拟合：
将热与机械分析得到的温度、应力及面形变化等分析结果导入SigFit，通过多项式拟合或插值，转换为光学分析软件可以读取的格式，直接在光学分析软件中考虑系统受到外界热、机械作用后的光学性能变化。
多项式拟合：将多种输入格式的数据拟合为多项式，拟合类型包括标准和边缘Zernike多项式、非球面多项式、XY多项式等九种格式；
表面变形插值：将光学测试的试验数据或有限元仿真的网格数据插值为一个数组或者另一种网格结果，以用于仿真预测结果与光学测试结果的对比，或用于拟合 Zernike多项式无法准确描述的光学表面变形。
该模块可以很好地解决光学成像镜头组在不同学科间数据传递的难题。
• 高级功能
♦ 主动控制：
分析光学面形RMS值随激励源数目的变化关系，分析如何布置激励源使光学表面RMS值更小，为施加激励源的位置和大小提供参考；根据一定约束自动优化、计算施加激励源的位置。
该模块用于主动控制 / 自适应光学系统的设计过程。
♦ 动态响应：
基于有限元固有频率分析结果、通过用户在SigFit中指定的激励载荷和阻尼等计算面形由于谐波振动 / 随机振动 / 瞬态载荷引起的刚体位移、曲率变化、RMS误差、传递函数变化、LOS晃动及各阶模态对RMS的影响等。
该模块可帮助用户将机械振动与光学性能分析指标联系起来，对于光学透镜组有重要的意义，可预测不同工况下对光学成像镜头组成像影响较大的模态，为设计提供参考，有效提升光机系统环境适应性。
♦ 设计优化：
将光学表面的Zernike系数、面形RMS值、PV值等参数转变为Nastran格式的方程，利用Nastran的优化求解器对光学表面的面型、支撑结构、材料参数等进行优化，获得更佳的光学系统设计方案。
该模块使得用户可以在考虑光学性能的前提下调用Nastran求解器进行优化，对于光学成像镜头组，可实现系统的多学科综合优化，能有效提升产品综合性能。
♦ 光程差分析：
包括热光分析，应力光学分析及气动光学分析三大类。利用有限元分析 / 流体分析得到的应力、温度分析结果 / 流体的密度分析结果，根据温度、应力、密度与折射率之间的关系，计算得到对应的光程差及双折射等光学特性。
该模块提供了热光分析、应力光学分析、气动光学分析的实现途径，在设计阶段对热、应力、气体密度通过影响光学系统的折射率对光学性能带来的影响进行分析，对于光学成像镜头组有重要的意义。
拓展
针对现有的研发流程和设计方法以无满足应未来快速的竞争要求的问题，借鉴计算机辅助优化（CAO, Computer Aided Optimization）的设计思想，引入多学科集成优化设计平台Optimus，提升光机系统研发能力，固化光机系统设计流程。
Optimus能够进行光机系统的光、机、热子学科仿真分析、各子学科之间集成分析、权衡各学科设计指标要求的优化设计、多学科仿真分析及优化设计自动化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c240e39667065b1ec1eb91079947ada/" rel="bookmark">
			java写出 基数_在任何基数（基数）中排序整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我应该在C中编写一个算法，它在任何基数(基数)中取一个整数数组，并使用Radix Sort将它们按升序排列 . 我的算法不能对数组的长度，位数和基数施加任何限制 . 当我说整数时，我并不是说我总是会收到一个 int 的数组，它可以是一个 long int ， char ， char 指针等数组 .
看来，我虽然处理对我的算法施加尽可能少的限制的最佳方法是通过访问它的位置来处理向量并将类型转换为 long unsigned int ，因此这种方法的局限性在于用户必须使用符合代码编译的编码选项的数字"weight"，即ASCII编码 x 十进制基数为120且 a 为97，所以如果给定的基数使用数字 x 和 a ， x 必须更大比 a .
这是我的算法：
/*!
* @function radixSort
* @abstract Sort a vector using Radix Sort.
* @discussion This function take a vector of positive
* integers in any base (radix) and sorts
* it in ascending order using the Radix
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c240e39667065b1ec1eb91079947ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0f10c96fffe8b14d0350f7308d5fce/" rel="bookmark">
			java 自定义表达式_表达式语言(含自定义)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 表达式语言的内置对象
使用表达式语言可以直接获取请求参数，可获取页面中某个JavaBean的属性值，获取请求头及获取session属性值等，这些都得益于表达式语言的内置对象。
表达式语言包含如下11 个内置对象。
pageContext:代表该页面的 pageContext对象，与 JSP 的 pageContext 内置对象相同。
pageScope: 用于获取 page 范围的属性值。
requestScope: 用于获取 request 范围的属性值。
sessionScope: 用于获取 session 范围的属性值。
applicationScope: 用于获取 application 范围的属性值。
p缸am: 用于获取请求的参数值。
paramValues: 用于获取请求的参数值，与param 的区别在于，该对象用于获取属性值为数组的属性值。
header: 用于获取请求头的属性值。
headerValues: 用于获取请求头的属性值，与 header 的区别在于，该对象用于获
取属性值为数组的属性值。
initParam: 用于获取请求 Web 应用的初始化参数。
cookie: 用于获取应用的 Cookie 值。
看下面的 JSP 页面代码:
〈 contentType="text/html;charset=gb23l2"%〉
表达式语言-内置对象
表达式语言"内置对象
请输入你的名字:
\${initParam["author"]}
丰{initParam["author"] }
reverse
java.
lang.String reverse( java.lang.String )
countChar
〈 prefix="my" uri="/tags/mytag"在〉
表达式语言-自定义函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b0f10c96fffe8b14d0350f7308d5fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e6da01ffa2cbe469139120ec869475/" rel="bookmark">
			python之git----- GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python之git----- GitHub 一：github原文链接
https://guides.github.com/activities/hello-world/
二：What is GitHub?
GitHub 是一个版本控制和协作的代码托管平台
1，创建仓库
仓库通常是用来组织一个项目的。仓库可以存放文件夹、文件、图片、视频、电子表格还有数据集 —— 任何你的项目需要的内容
a&gt;在页面的右上角，点击头像隔壁的“+”号，选择 New repository
b&gt;将你的仓库命名为 hello-world
c&gt; 为该项目写上一段简短的描述
d&gt;勾选 Initialize this repository with a README（为该仓库初始化一个 README 文件）
e&gt;最后点击 Create repository
2,创建分支
通过分支的方式，允许你在同一时间对仓库不同版本的内容进行操作;建立不同的分支进行测试和编辑，完善以后再提交至 master；master 建立一个分支时，你拷贝的是当时 master 分支里的内容。
master 分支:主分支
a&gt; 来到你的新仓库 hello-world 中
b&gt;点击那个叫做 main: 下拉按钮 输入readme-edits
c&gt;单击 Create branch 或直接回车键走起
现在你拥有了两个分支：master 和 readme-edits
3,提交修改
位于 readme-edits 分支的代码视图,它是拷贝自 master 分支的
GitHub 上，保存修改被称为提交（commits）。每次提交都有一个关联的提交信息，用于描述你做所的修改。
a&gt;点击 README.md 文件
b&gt;点击文件视图右上角的铅笔图标进行编辑
c&gt; 在编辑框中，随便写一些东西
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34e6da01ffa2cbe469139120ec869475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e7f6e1d66f9285301ebad8883f9c34/" rel="bookmark">
			UVA1326 Jurassic Remains
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UVA1326 Jurassic Remains 知识点：集合的整数表示 + 折半枚举 +异或 一.题意 选择最多的串，使得这些串中出现的每一位大写字母都是出现了偶数次，并且输出串的个数，和按照升序说出选择了哪几个串
二.题解 把二进制上的每一位当作是一个大写字母(A-&gt;1,B-&gt;2,C-&gt;4……)，然后通过异或来判断出现的次数是奇次还是偶次，并且通过折半枚举，将n分成两半来枚举
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;set&gt; #include&lt;map&gt; #include&lt;string&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; int n,a[30]; map &lt;int,int&gt; table; int bitcount(int x){	//求x对应二进制中1的个数 return (x == 0 ? 0 : (x &amp; 1) + bitcount(x&gt;&gt;1)); } int main(){ while(cin&gt;&gt;n){ string s; for(int i = 0; i &lt; n; i++){ cin&gt;&gt;s; a[i] = 0; for(int j = 0; j &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e7f6e1d66f9285301ebad8883f9c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec10b17c3fa9397633d5093069d3e5c7/" rel="bookmark">
			linux Shell学习（二）Bash的基本功能1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 历史命令与命令补全命令别名与常用快捷键输入输出重定向 历史命令与命令补全 1、历史命令
用法：[root@localhost ~]# history [选项] [历史命令保存文件]
选项：
-c：清空历史命令
-w：把缓存中的历史命令写入历史命令保存文件（~/.bash_history）
注意：
历史命令默认会保存1000 条,可以在环境变量配置文件/etc/profile中进行修改
历史命令的调用：
使用上、下箭头调用以前的历史命令使用!n重复执行第n 条历史命令（命令的序号n可以用history查看到）使用!!重复执行上一条命令使用!字串重复执行最后一条以该字串开头的命令 2、命令补全
在Bash 中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按
Tab键就会自动进行补全。
在有多个符合的前缀的时候，快速摁两次tab可以显示所有选项。
命令别名与常用快捷键 1、命令别名
用法：[root@localhost ~]# alias 别名='原命令' #设定命令别名
[root@localhost ~]# alias #查询命令别名
命令执行时顺序
第一顺位执行用绝对路径或相对路径执行的命令。第二顺位执行别名。第三顺位执行Bash 的内部命令。第四顺位执行按照$PATH 环境变量定义的目录查找顺序找到的第一个命令。 永久修改别名
[root@localhost ~]# vi /root/.bashrc
删除别名
[root@localhost ~]# unalias 别名
2、Bash常用快捷键
常用：
ctrl + U：清楚光标前的所有命令
ctrl + R：在历史命令中搜索（快捷调用之前输入的长命令）
输入输出重定向 1、标准输入输出
2、输出重定向
用的较多的是命令 &amp;&gt;&gt;文件以追加的方式，将正确和错误输出就保存到文件中；
ls &amp;&gt;&gt; log
注意错误输出中，错误命令 2和&gt;&gt;之间不能有空格
lst 2&gt;&gt; error.log（2和&gt;&gt;之间不能有空格）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec10b17c3fa9397633d5093069d3e5c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f10a8844e047753190dd373f960e9a/" rel="bookmark">
			控制工程中的数学建模（6）——典型环节的数学模型（之二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⑵一阶惯性环节——电加热炉
电加热炉是常见的热处理设备。如下图所示：
u为电热丝两端电压， 为炉内温度。电热丝质量为m，比热容为C，传热系数为H，传热面积为A，未加温前炉内温度为 ，加温后的温升为T1 ，电热丝产生热量Q(t)，单位时间内电热丝产生的热量（功率）为P。
根据热力学原理，有
①电热丝自身发热比热容方程
②电热丝向周围传热热阻R=HA，传热功率为
③根据能量守恒
④线性化处理
电热丝功率
r——电热丝电阻，
在平衡点 附近满足： ， 为电压变化量，于是
说明在平衡点附近，P和u近似线性化。
⑤平衡点微小增量微分方程
以平衡点为参考点，设温升 ，则有
物理意义：新增加的功率都用于电热丝自身温度升高和向外传热。
化简得
令
化成一般形式
⑥拉氏变换
电加热炉传递函数
其中， ——温度变化量， ——电压变化量，T——时间常数，K——传递系数。
这就是典型的一阶惯性环节传递函数。
一阶惯性环节代表的装置中，只含有一个独立的惯性元件，如本例中的电热丝温度不会突变（功率是有限的），而是需要一定时间过渡；其他惯性元件还有：电容——电压不会突变（充放电电流是有限的），电感——电流不会突变（电压是有限的），质量实体——速度不会突变（作用力是有限的）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3081926d183a42666f1671e904c35f/" rel="bookmark">
			mac 下 python 批量删除 PDF 中的某些页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去网上找 python 处理pdf的库，大多都会给你推荐 PyPDF2，其实这个库早已经过时了。
这里展示下如何用Python3删除pdf文件中的某些页面：
import pikepdf with pikepdf.open('input.pdf') as pdf: num_pages = len(pdf.pages) # 计算 PDF 的页数 del pdf.pages[0] # 删除 PDF 的第一页 pdf.save('output.pdf') 这里需要先安装 pikepdf这个库：
pip install pikepdf 更多信息：https://github.com/pikepdf/pikepdf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1eb01d5442df3432e86ad919757e0a/" rel="bookmark">
			iview filterable在搜索时，只按照 label 进行搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;Select v-model="deptId" filterable :only-filter-with-text="true"// //用来控制是否启用自定义的originValidateOption函数。true代表启用 clearable &gt; &lt;Option v-for="item in deptList" :value="item.conCode" :key="item.conCode" &gt;{{ item.conName }}&lt;/Option &gt; &lt;/Select&gt; iView.Select.props.onlyFilterWithText = { type: Boolean, default: false }; iView.Select.methods.originValidateOption = iView.Select.methods.validateOption; iView.Select.methods.validateOption = function ({children, elm, propsData}) { if (this.onlyFilterWithText) { const textContent = (elm &amp;&amp; elm.textContent) || (children || []).reduce((str, node) =&gt; { const nodeText = node.elm ? node.elm.textContent : node.text; return `${str} ${nodeText}`; }, '') || ''; const query = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1eb01d5442df3432e86ad919757e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b6ab67e6e217a0dd8751474a3cf824/" rel="bookmark">
			java tomcat jvm内存_Tomcat中JVM内存溢出及合理配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from http://blog.csdn.net/ye1992/article/details/9344807
Tomcat本身不能直接在计算机上运行，需要依赖于硬件基础之上的操作系统和一个Java虚拟机。Tomcat的内存溢出本质就是JVM内存溢出，所以在本文开始时，应该先对Java JVM有关内存方面的知识进行详细介绍。
一、Java JVM内存介绍
JVM管理两种类型的内存，堆和非堆。按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中，它和堆不同，运行期内GC不会释放其空间。
(1). 堆内存分配
JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指 定，默认是物理内存的1/4。默认空余堆内存小于 40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC 后调整堆的大小。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行堆内存设置，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值，建议堆的最大值设置为可用内存的最大值的80%。
初始化堆的大小是JVM在启动时向系统申请的内存的大小。一般而言，这个参数不重要。但是有的应用程序在大负载的情况下会急剧地占用更多的内存，此时这个参数就是显得非常重要，如果JVM启动时设置使用的内存比较小而在这种情况下有许多对象进行初始化，JVM就必须重复地增加内存来满足使用。由于这种原因，我们一般把-Xms和-Xmx设为一样大，而堆的最大值受限于系统使用的物理内存。一般使用数据量较大的应用程序会使用持久对象，内存使用有可能迅速地增长。当应用程序需要的内存超出堆的最大值时JVM就会提示内存溢出，并且导致应用服务崩溃。所以，如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。
(2). 非堆内存分配
也叫永久保存的区域，用于存放Class和Meta信息,Class在被Load的时候被放入该区域。它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理。JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 GC不会对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。
(3). JVM内存限制(最大值)首先JVM内存限制于实际的最大物理内存(废话！，呵呵)，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB(一般来说Windows系统下为1.5G-2G，Linux系统 下为2G-3G)，而64bit以上的处理器就不会有限制了。
二、三种内存溢出异常介绍
1. OutOfMemoryError： Java heap space 堆溢出
内存溢出主要存在问题就是出现在这个情况中。当在JVM中如果98％的时间是用于GC且可用的 Heap size 不足2％的时候将抛出此异常信息。
2. OutOfMemoryError： PermGen space 非堆溢出(永久保存区域溢出)
这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。如果web app用了大量的第三方jar或者应用有太多的class文件而恰好MaxPermSize设置较小，超出了也会导致这块内存的占用过多造成溢出，或者tomcat热部署时侯不会清理前面加载的环境，只会将context更改为新部署的，非堆存的内容就会越来越多。
3. OutOfMemoryError： unable to create new native thread. 无法创建新的线程
这种现象比较少见，也比较奇怪，主要是和jvm与系统内存的比例有关。这种怪事是因为JVM已经被系统分配了大量的内存(比如1.5G)，并且它至少要占用可用内存的一半。
三、Java JVM内存配置
1. JVM内存分配设置的参数有四个
-Xmx Java Heap最大值，默认值为物理内存的1/4；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b6ab67e6e217a0dd8751474a3cf824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1a3dd3232f7d27a56f4c1691e4f90d/" rel="bookmark">
			Mac中git ssh的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac中git ssh的配置（GitLab) 一、查看是否已配置 cd ～/.ssh //进入ssh目录 如果不能进入该目录，说明没生成过，进入步骤二重新配置。
如果ssh文件夹中有id_rsa，id_rsa.pub，说明之前生成过ssh 秘钥，可以直接使用
二、重新配置 重新配置，也要在Terminal终端进行：
1. 配置账户 git config --global user.name "account name" //用户名，建议拼音或英文 git config --global user.email "account email" //邮箱地址 2. 生成秘钥 ssh-keygen -t rsa -C "account email" //上面的邮箱地址 注意这儿的空格 “ssh-keygen” 连续按3次enter，出现下面的截图
1、2步骤后，就完成了账户创建、秘钥生成，.ssh文件夹下就多了id_rsa（私有秘钥）和id_rsa.pub（公有密钥）,下一步 查看
3. 查看公有密钥，全部复制，添加到github或gitlab中 cd ~/.ssh ls cat id_rsa.pub 4. GitLab中添加SSH Key 打开GitLab，点击右上角头像，选择“Settings”，然后在左侧导航栏选择“SSH Keys” 添加上述查看到的公有密钥。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ce2da63bea6a618e7578fa50690040/" rel="bookmark">
			React
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1811@TOC
React react 是一个用于构建用户界面的库，但是由于react拥有一系列的生态技术（react-router、react-redux），所以，我们一般也会把 react 当做是一个框架。
react 是由 facebook 开发的，最早是 facebook 的一个内部项目。原因就是因为该公司对当时市场上所有的 js 框架都不满意，因为当时所有的 js 框架基本都是基于节点的操作。
特点 声明式设计 : 前端多了一个 vm 层，vm 一变化，v 就自动更新。；高效: 主要是针对对比之前的 jquery 时代，因为不用手动操作节点了。JSX: 在 react 中，通过 JSX 来描述视图。虚拟DOM : 如果每次有一点更新，就立马去操作真实的DOM，这个开销是很大的，所以在 react中，提出了虚拟DOM 的概念，通过 js 对象来描述DOM树结构.单项数据流：state： 驱动应用的数据源.view： 以声明方式将 state 映射到视图actions: 响应在 view 上的用户输入导致的状态变化diff 算法： 当用户对视图进行更新的时候，先去更新虚拟 DOM，这里说的进行更新，不是在原来的树上面进行更新，而是生成一颗新的树，接下来两棵树就可以进行对比，从而找到不一样的地方，进行更新。 react 安装 通过cdn安装： &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入 React 核心库 --&gt; &lt;script src="https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"&gt;&lt;/script&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ce2da63bea6a618e7578fa50690040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8e72bc0090dfe254f592288f1c3699/" rel="bookmark">
			java cityhash_Java HashMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java HashMap
你从上一章了解到，ArrayList把数据存储为有序列表，使用索引号(int类型)访问它们。
而HashMap将数据存储为“键/值”对，通过键(例如：字符串，键类似索引)访问它们。
HashMap的键值对中，键是一个对象，对应的值也是一个对象，通过键可以访问到值。
示例
创建一个名为capitalCities的HashMap对象，键和值都是字符串类型:
import java.util.HashMap; // 导入HashMap类
HashMap capitalCities = new HashMap();
如果你不知道“包”是什么，请参考我们的Java包教程。
添加项目
HashMap类有许多方法。例如，要添加项目，可以使用put()方法:
示例
// 导入HashMap类
import java.util.HashMap;
public class MyClass {
public static void main(String[] args) {
// 创建一个名为capitalCities的HashMap对象
HashMap capitalCities = new HashMap();
// 添加键和值(Country, City)
capitalCities.put("England", "London");
capitalCities.put("Germany", "Berlin");
capitalCities.put("Norway", "Oslo");
capitalCities.put("USA", "Washington DC");
System.out.println(capitalCities);
}
}
访问项目
要访问HashMap中的值，使用get()方法，传入键:
示例
capitalCities.get("England");
删除项目
要删除一个项目，使用remove()方法，传入键:
示例
capitalCities.remove("England");
要删除所有项目，请使用clear()方法:
示例
capitalCities.clear();
HashMap大小
要知道有多少项，可以使用size()方法:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba8e72bc0090dfe254f592288f1c3699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c8009fab9aff1e29e995decfa76dce/" rel="bookmark">
			java运行环境32位jre_JAVA环境如何搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先安装JDK，然后配置环境(没JDK或者不会下就留邮箱我，发你)
配置环境步骤如下：
首先右键点我的电脑,打开属性。然后选择“高级”里面的“环境变量”，在新的打开界面中的系统变量里需要设置三个属性:
“java_home”、 “path”、“classpath”
其中在没安装过jdk的环境下，path属性是本来存在的。
而java_home和classpath是不存在的。
首先在“Administrator的用户变量”区点“新建”，然后在变量名写上java_home，其含义就是java的安装路径，呵呵，然后在变量值写入刚才安装的路径“C:\Program Files\Java\jdk1。
6。0_10”(不含引号)
其次在“系统变量”里面找到path，然后点编辑，(里面已经有很多了，但千万不要把他们给删了！！！！！！)
path变量的含义就是系统在任何路径下都可以识别java命令，
在原有的最前面插入“C:\Program Files\Java\jdk1。
6。0_10\bin;”(不含引号)，此处“C:\Program Files\Java\jdk1。6。0_10”不可替换为“%java_home%”,具体原因我也不清楚
最后在“系统变量”区点“新建”，在变量名上写classpath,该变量的含义是为java加载类(class或lib)路径，只有类在classpath中，java命令才能识别。
其值为“。;%java_home%\lib\tools。jar;%java_home%\lib\dt。jar;”(不含引号)
以上三个变量设置完毕，则按“确定”(别忘了确定！呵呵)直至属性窗口消失，下来是验证看看安装是否成功。
先打开“开始”-&gt;“运行”，输入“cmd”，进入
然后打“java -version”，如果安装成功。
系统会显示java的版本信息。
注:
也可不建java_home，但所有出现“%java_home%”的地方都要完整填写“C:\Program Files\Java\jdk1。6。0_10” 。
全部
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c518c02c6da8b46d64eb86202144e7/" rel="bookmark">
			Webots中构建简单的环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Webots是什么？ Webots作为一款移动机器人的仿真软件包，它能够快速的原型制作环境。Webots的开源时间比较晚，因此国内关于Webots的学习资料比较少，只能通过官方文档来进行学习，官方文档提供了两个手册，一个是User Guide（用户指南），一个是Reference Manual(参考手册)。Webots由Cyberbotics公司开发，是一款开源的多平台机器人仿真软件，为机器人的建模、编程和仿真提供了完整的开发环境。
目前，Webots已经开源，支持Windows、Linux、Mac系统。并且支持多种编程语言，包括C、C++、Matlab、Java、Python等。Webots提供了一些现有的机器人，我们也可以根据自己的需求创建自己的机器人。Webots提供一些传感器：GPS、DistanceSensor、Lidar、PositionSensor、Camera等，Webots软件自带一些demo，可以根据需求利用官方提供的demo来进行学习。
二、创建一个简单的世界 进入Webots需要点击暂停按钮，然后点击Reload World按钮，使Webots世界回到0。Webots的界面分布主要如下：
创建一个新的项目：
Wizards -&gt; New Project Directory
点击Next继续。
选择合适的路径，点击Next继续。
Webots中的项目格式为.wbt，给该项目取一个名称，第四个Add a rectangle arena选中为创建完项目，在世界中会有一个方形的区域，点击Next继续。
点击Finish完成。
完成以后，界面如下。
我们没有选中Add a rectangle arena，因此世界中没有对象。场景树中的四个节点为：
WorldInfo：包含模拟的全局参数。
Viewpoint：定义主要视点相机参数。
TexturedBackground：定义场景的背景
TexturedBackroundLight：定义与上述背景关联的光。
点击加号按钮或者在场景树中右键选择Add new即可进入Add a node界面来选择添加结点。
首先我们选择添加一个地板，点击PROTO nodes(Webots Projects)，选择objects，选择floors，选择UnevenTerrain(solid)，最后点击Add即可添加成功。
右侧有对该节点的介绍文字，点击蓝色部分网站可以进入官网来更加详细的了解该节点的内容。
进入场景树来对该节点的参数进行修改，调整size来修改大小，Appearance SandyGround来修改floors的颜色。
然后添加一个e-puck机器人，点击加号按钮或者在场景树中右键选择Add new即可进入Add a node界面来选择添加结点。点击PROTO nodes(Webots Projects)，选择robots，选择gctronic，选择e-puck，选择E-puck(Robot)，最后点击Add即可添加成功。
双击3D场景中的该机器人，可以看到该机器人的8个距离传感器，左右两个电机，还有摄像机等信息。运动开始时，在该界面可以看到传感器、电机的详细数字显示。该机器人是通过距离传感器来进行避障，左上角方框显示机器人上摄像机拍摄的画面。
在Webots中构建环境时，一定要记住及时保存！！！
在Webots中构建环境时，一定要记住及时保存！！！
在Webots中构建环境时，一定要记住及时保存！！！
Webots的安装包：
链接：https://pan.baidu.com/s/1W_K02E373Wk3AttOLRwoBw
提取码：x51i
最后欢迎大家关注微信公众号：深度学习与路径规划 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c2336b0f71cb324ffd9f5c03f015378/" rel="bookmark">
			安装的java怎么看是多少位的_64位-如何检测安装了哪种JRE-32位与64bi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我正在使用NSIS和Launch4j包装Java桌面应用程序。 因此，我不仅需要检测任何JRE，而且还需要使用它的搜索算法找到一个Launch4j。 唯一有意义的方法是在NSIS安装程序中运行一个简短的Java程序。 这是Java：
public class DetectJVM {
private static final String keys [] = {
"sun.arch.data.model",
"com.ibm.vm.bitmode",
"os.arch",
};
public static void main (String [] args) {
boolean print = args.length &gt; 0 &amp;&amp; "-print".equals(args[0]);
for (String key : keys ) {
String property = System.getProperty(key);
if (print) System.out.println(key + "=" + property);
if (property != null) {
int errCode = (property.indexOf("64") &gt;= 0) ? 64 : 32;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c2336b0f71cb324ffd9f5c03f015378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8076b2bd3d115709d0ac5aa2935dac8d/" rel="bookmark">
			安装win10不求人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己动手安装win10，超级简单
1、准备一个大于4G的优盘，格式化为fat32格式
2、去微软网站下载制作安装工具，用最新版的
3、执行这个工具，选择制作U盘安装工具，工具会从网上下载最新版本做成启动U盘
4、把做好的U盘插到，需要安装的电脑里，选择U盘启动
5、启动后面就是一步步的安装界面，没啥好注意的，放心大胆的试吧，弄错了大不了重来，多弄几次就会了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8034c0b92c6f8d7b36a911ae656297bc/" rel="bookmark">
			Vue前端之路(一)---入坑前的准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.序言
2.准备工作
2.1.安装运行环境
2.1.1.nodejs安装（必做）
2.1.2.npm淘宝源配置（选做）
2.1.3.vue的安装（必做）
2.2.vue-cli3脚手快速架构建vue项目
2.3.开发环境（IDE）的安装
前端常用插件 (ps: 必备 &gt; 推荐 &gt; 了解)
1.序言 最近由于工作需要加上没有前端工程师，本着兴趣广泛，开始了小白踏上前端vue入坑之旅，自从出现前后端分离的流行趋势之后，很久不再写js+css了，都说vue算是三大前端框架中（Angular、React、Vue）最简单的，我也亲自尝试了一下，写本文的目的，一个是本着分享，一个是加深一下记忆，写的不好的地方，欢迎留言探讨和指教。
2.准备工作 2.1.安装运行环境 2.1.1.nodejs安装（必做） 这里采用的是Windows 安装包(.msi)，node-v12.18.3-x64.msi，不一定最新的，最新的请参考http://nodejs.cn/download/
安装过程不多说了，就是下一步，点点点，个人习惯，安装位置不要放在C盘就是了，检测是否安装成功命令如下：
node -v或者node --version
npm -v或者npm --version
新版的nodejs已经集成了npm，所以之前npm也一并安装好了
截图如下：
2.1.2.npm淘宝源配置（选做） 由于我不太喜欢cnpm命令，如果有喜欢的cnpm的，安装命令如下
npm install -g cnpm --registry=https://registry.npm.taobao.org
由于node下载第三方依赖包是从国外服务器下载，下载速度慢，永久使用淘宝的镜像源还是有必要的，命令如下：
npm config set registry https://registry.npm.taobao.org
查看npm配置的镜像源，命令如下：
npm config get registry
截图如下：
如果想还原成初始的镜像源，命令如下：
npm config set registry https://registry.npmjs.org/
2.1.3.vue的安装（必做） 这里采用npm安装vue的方法，Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用，这里用的是vue-cli3.0+，命令如下：
//默认最新版本
npm install -g @vue/cli
//指定版本3.6.0
npm install @vue/cli@3.6.0 -g
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8034c0b92c6f8d7b36a911ae656297bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf53c3a1bdb84a2f5641a802f0958c4/" rel="bookmark">
			honeyselect身高补丁_honey select姿势mod最新补丁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏介绍
honey select姿势mod最新补丁：非常绅士的日系养成游戏，细腻的游戏画质，多种互动式的交流还是非常带感的。你可以去各种地方享受预约的生活，各式各样的服装MOD更加的刺激带感啦！在这里掌通小编带来了honey select游戏下载，下面一起来看看相关的信息介绍。
honey select游戏介绍：
你可以简单的对你的角色进行化妆，当然你技术达标也是可以很美的。大量的场景也算是这个版本的特色了，注重了角色皮肤和衣服的质感。
全新的制作技术，从角色设计，表情，动作以及H场景进行了全部的进化。玩家们将化身绅士来和游戏中的妹纸们来一场热情的恋爱物语~~！
honey select游戏玩法：
【安装步骤】
1、解压缩，解压后路径如“D:\HoneySelect”，路径中请勿含中文字符。
2、双击“★绿化游戏.bat”，程序将自动安装及。
3、运行“InitSetting.exe”开始游戏(如果无法启动，请直接运行以下程序)：
“HoneySelect_32.exe / HoneySelect_64.exe”：游戏本体 启动程序.
“HoneyStudio_32.exe / HoneyStudio_64.exe”：摄影工作室 启动程序.
“StudioNEO_32.exe / StudioNEO_64.exe”：NEO摄影工作室 启动程序.
“HoneySelectVR.exe / HoneySelectVR_Vive.exe”：VR模式 启动程序.
“BattleArena_32.exe / BattleArena_64.exe”：竞技场特典 启动程序.
存档位置：存档保存在“游戏安装目录\UserData\save”文件夹下。
honey select游戏特点：
妹子会根据你的互动方法改变心情都会有不同表现，心情变化会影响到女孩子对你的反应。
可以去各种地方享受预约的生活，当然你技术达标也是可以很美的，游戏流畅也是非常赞的。
更多的泳装款式和其他的衣着可以自由选择，妹子会根据你的互动方法改变心情更加的带感。
整个游戏玩起来还是非常到位的，分分钟的享受无与伦比的日系养成盛宴，整玩起来超靠谱。
请记住本站网址 zhangton.com，浏览器点击收藏掌通 ，方便下次再玩。 《honey select姿势mod》app由掌通科技提供，手机访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36504eb3ee5562423d27ac90e0ab9ab5/" rel="bookmark">
			cookie实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;head&gt; &lt;script&gt; function setCookie(cname,cvalue,exdays){ var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = "expires="+d.toGMTString(); document.cookie = cname+"="+cvalue+"; "+expires; } function getCookie(cname){ var name = cname + "="; var ca = document.cookie.split(';'); for(var i=0; i&lt;ca.length; i++) { var c = ca[i].trim(); if (c.indexOf(name)==0) { return c.substring(name.length,c.length); } } return ""; } function checkCookie(){ var user=getCookie("username"); if (user!=""){ alert("欢迎 " + user + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36504eb3ee5562423d27ac90e0ab9ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47052fda984af93d095e5cb53624e83c/" rel="bookmark">
			Hutool是一个小而全的Java工具类库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Hutool简介 Hutool 是一个小而全的 Java 工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使 Java 拥有函数式语言般的优雅，让 Java 语言也可以“甜甜的”。
Hutool 中的工具方法来自每个用户的精雕细琢，它涵盖了 Java 开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；
文档
官方网站
中文文档
API文档
包含组件 一个 Java 基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：
模块介绍hutool-aopJDK动态代理封装，提供非IOC下的切面支持hutool-bloomFilter布隆过滤，提供一些Hash算法的布隆过滤hutool-cache简单缓存实现hutool-core核心，包括Bean操作、日期、各种Util等hutool-cron定时任务模块，提供类Crontab表达式的定时任务hutool-crypto加密解密模块，提供对称、非对称和摘要算法封装hutool-dbJDBC封装后的数据操作，基于ActiveRecord思想hutool-dfa基于DFA模型的多关键字查找hutool-extra扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）hutool-http基于HttpUrlConnection的Http客户端封装hutool-log自动识别日志实现的日志门面hutool-script脚本执行封装，例如Javascripthutool-setting功能更强大的Setting配置文件和Properties封装hutool-system系统参数调用封装（JVM信息等）hutool-jsonJSON实现hutool-captcha图片验证码实现hutool-poi针对POI中Excel和Word的封装hutool-socket基于Java的NIO和AIO的Socket封装 可以根据需求对每个模块单独引入，也可以通过引入hutool-all方式引入所有模块。
2、Hutool安装与使用 安装 使用Maven在pom.xml配置信息文件中，添加相关依赖文件：
&lt;!-- Hutool工具类库 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.8&lt;/version&gt; &lt;/dependency&gt; 判断字符串是否为空 @Test public void strTest() { String name = "pan_junbiao的博客"; //字符串格式化的使用 System.out.println(StrUtil.format("字符串内容：{}",name)); //判断字符串是否为空 System.out.println("字符串是否为空：" + StrUtil.isEmpty(name)); } 执行结果：
使用md5加密 @Test public void md5Test() { String content = "您好，欢迎访问 pan_junbiao的博客"; String encrypt = SecureUtil.md5(content); System.out.println("加密前的内容：" + content); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47052fda984af93d095e5cb53624e83c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcedeb80f61bf207ecf33451ec66211c/" rel="bookmark">
			初学1：SNAP加载哨兵数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.sentinel2数据介绍：
数据下载
一般从欧空局和earthdata可以下载
欧空局：https://scihub.copernicus.eu/dhus/#/hom；
详细教程可参考https://blog.csdn.net/weixin_43898892/article/details/101990073；
数据分为两种：
2018年以前的数据：原始数据2018年以后的数据：预处理过的（即处理过大气校正） 2.使用SNAP软件加载sentinel-2数据：
#首先是snap软件的下载地址：http://step.esa.int/ ；为了后续的方便，建议下载All Toolboxes版。#
如图1所示，File-&gt;Import-&gt;Optical Sensors-&gt;Sentinel-2-&gt;S2-MSI L2A.
图1 以加载sentinel2号数据为例 加载完成后，snap界面左上角窗口中会显示加载的数据，如图2所示：
然后右击所选影像-&gt;Open RGB Image Window:然后会跳出下图3所示窗口。
图3 根据个人要求，选择合适波段进行彩色合成，完成影像加载。下图是sentinel-2卫星的波段参数以及和landsat8卫星。
比如若想加载假彩色合成影像，分别选择8，4，3三波段。 结果如下图所示：
以上便是本篇的全部内容，后续会继续学习有关snap的图像处理，批处理等操作。
参考文章：https://blog.csdn.net/weixin_43562878/article/details/106016954
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b32808c382d82088a63c03a1732d645/" rel="bookmark">
			dell笔记本外接显示器_戴尔笔记本怎样外接显示器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
1.首先，将显示器连接到电源，如下图所示，然e68a8462616964757a686964616f31333433633363后进行下一步。
2.其次，完成以上步骤后，将显示器数据线连接到笔记本电脑上的VGA接口，如下图所示，然后进行下一步。
3.然后，完成以上步骤后，打开外部显示屏，按快捷键组合点亮液晶显示屏Fn+F3，如下图所示，然后进行下一步。
4.然后，完成以上步骤后，关闭笔记本电脑屏幕，如下图所示，继续下一步。
5.然后，完成以上步骤后，右键单击计算机桌面，然后选择[properties]选项，如下图所示，然后继续下一步。
6.完成以上步骤后，在“properties”界面找到“Settings”选项，找到如下【display】，如下图所示，然后进行下一步。
7.然后，在完成以上步骤后，在“显示”下选择即插即用监视器，然后选中下面可以选中的所有选项，然后点击“应用”，不关闭此页面，如下图所示，继续下一步。
8.最后，完成以上步骤后，在同一页面上，选择“显示”下的“多显示器”选项，点击“确定”完成设置，如下图所示。这样，问题就解决了。
注意事项：
戴尔笔记本电脑可分为家用和商用产品。其中家居产品包括灵越经济模型系列、Studio娱乐模型系列、XPS游戏模型系列。商用产品包括Vostro系列经济机型、Latitude系列安全可靠机型和精密系列工作站机型。
戴尔最家用笔记本和部分商用笔记本型号命名规则都比简单好，基本是“品牌名称”、“系列”、屏幕尺寸、“什么代产品”和“配置码”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98b1f466008765440fcb1fcb0ca4c34/" rel="bookmark">
			Ansoft HFSS——ANSYS Electronics Suite 2020R1 Install Guidance
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ansoft HFSS——HFSS 20R1破解版下载及安装教程 ANSYS Electronics Suite 2020R1 Install Guidance
Part 1：名词解析 Ansoft HFSS：Ansoft 公司推出的一款三维电磁仿真软件
HFSS：High Frequency Structure Similator（高频结构仿真器）
Part 2：安装步骤 1.打开下载好的安装包并解压
2.目录是这样的，解压的时候最好不要解压到C盘，注意：这个解压出来的整个的文件都是下载文件，与之后的安装文件夹是两码事
3.打开解压出的ANSYS_Electronics_Suite_2020R1，点击下图中红色圆圈框住的内容
4.点击后进入下图文件，点击autorun进行安装
5.点击黄色圆圈框住的内容
6.如果之前已经安装过一次，但是修改了整个程序的安装路径或其它原因需要重新安装，则点击remove，如果第一次安装请忽略此步骤
7.选择安装程序的路径：最好不要安装到C盘，安装路径最好无中文路径，可以提前在安装路径的位置新建一个有辨识度的文档，然后选择在该文档里安装
之后一路next
8.最关键的步骤：license！先点击第一个选项即“I have a new license file”
找到破解文件里面的license放进去
9.系统显示安装完成，点击finish！
10.其余两个画黄色小圈圈的安装步骤同上，最好都新建一个文件夹然后各自安装，注意：一旦安装之后千万不能随意修改路径！
11.然后还没有完！这个时候先不要打开软件（也打不开），复制下图的“crack”里面的“shared files”
粘贴到你的安装路径之中（就像我选择的I盘作为安装路径，然后系统自动分配了一个文件夹安装），这个时候会显示安装好的文件夹里面有同名文件，选择全部替换掉！
12.然后就破解安装成功啦！打开图标是这个样子的
Part 3：下载路径 https://pan.baidu.com/s/1T8BpjLkbz_md3MZANgUXVQ
提取码：ngt6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bec586d8e632cb15ee97f4a14d1171/" rel="bookmark">
			git log参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git log参数详解 例子展示两个提交之间的所有提交筛选提交历史简化排序提交格式化提交`--pretty[=]``--format=``--abbrev-commit``--no-abbrev-commit``--oneline``--encoding=``--expand-tabs = ``--expand-tabs``--no-expand-tabs``--notes [= ]``--no-notes``--show-signature``--relative-date``--date=``--date=relative``--date=local``--date=iso`（或`--date=iso8601`）`--date=iso-strict`（或`--date=iso8601-strict`）`--date=rfc`（或`--date=rfc2822`）`--date=short``--date=raw``--date=human``--date=unix``--date=format`:`--date=default``--parents``--children``--left-right``--graph``--show-linear-break[=]` 漂亮的打印样式`oneline``short``medium``full``fuller``reference``email``mboxrd``raw``format:`占位符扩展为单个文字字符：影响以后的占位符格式的占位符：`％Cred ``％Cgreen ``％Cblue ``%Creset ``％C（…）``％m``%w([[,[,]]])``％&lt;（ [，trunc | ltrunc | mtrunc]）` 占位符扩展为从提交中提取的信息：`％H``％H``％T``％t``％P``％p``%an``%aN``%ae``％aE``％al``％aL``%ad``%aD``％ar``%at``％ai``％al``％as``％cn``％cN``％ce``％cE``％cl``％cL``%cd``%cD``％cr``％ct``％ci``％cI``％CS``％d``％D``％S``％e``％s``％F``％b``％B``％N``％GG``％G？``％GS``％GK``％GF``％GP``％GT``％gD``％gd``％gn`reflog`％gN`reflog`％ge`reflog`％gE`reflog`％gs`reflog tformat 例子 例子
git log --no-merges
显示整个提交历史，但跳过任何合并
git log v2.6.12… include/scsi drivers/scsi
显示自v2.6.12版本以来所有更改include/scsi或drivers/scsi子目录中 任何文件的提交
git log --since=“2 weeks ago” – gitk
显示最近两周对文件gitk的更改。在–避免与混乱是必要的分公司名为 gitk
git log --name-status release…test
显示在“测试”分支中但尚未在“发布”分支中的提交，以及每个提交修改的路径列表。
git log --follow builtin/rev-list.c
显示更改的提交builtin/rev-list.c，包括在为文件提供其当前名称之前发生的那些提交。
git log --branches --not --remotes=origin
显示在任何本地分支中但不在任何远程跟踪分支中的所有提交的提交。
git log master --not --remotes=*/master
显示所有在本地master中但不在任何远程存储库master分支中的提交。
git log -p -m --first-parent
仅从“主分支”角度显示包括更改差异的历史记录，跳过来自合并分支的提交，并显示合并引入的更改的完整差异。仅当在一个集成分支上遵循严格的合并所有主题分支的策略时，这才有意义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98bec586d8e632cb15ee97f4a14d1171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01e7da8faffc49a81d926485ae28e72/" rel="bookmark">
			No PostCSS Config found in...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错解决 No PostCSS Config found in…
git clone
npm install
npm run dev
问题：上传GitHub，clone到本地，运行报错
解决：根目录新建文件postcss.config.js
module.exports = { plugins: { 'autoprefixer': {browsers: 'last 5 version'} } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e1416d950f7a6a97d5a916e9691659/" rel="bookmark">
			Python 爬虫进阶必备 | 某工业超市加密 header 参数分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日网站 aHR0cHM6Ly93ZWIuemtoMzYwLmNvbS9saXN0L2MtMjYwMTg2Lmh0bWw/c2hvd1R5cGU9cGljJmNscD0x
这个网站是在某交流群看到的，随手保存下来作为今天的素材
抓包分析与加密定位 先看看抓包的结果，可以看到请求的header中包含两个未知的参数，分别是zkhs和zkhst
进一步检索参数zkhst和zkhs，可以发现这两个参数的值没有做过混淆
并且都有对应的搜索结果
根据搜索结果的提示inde，进一步在文件中检索zkhst和zkhs
可以在文件中找到下面这几个关键位置
加密分析 在逻辑里比较明显的是
e.headers.zkhs = o,e.headers.zkhst = r 这行代码预示我们要分析的是o和r这两个变量
这两个变量的赋值分别可以在上面的 js 逻辑中找到
o = u()("body=".concat(i, "&amp;params=").concat(o, "&amp;sign_token=").concat(r), r) r = Object(s.f)("zkhst") 接下来只要单点调试即可，先来看o的生成
o的逻辑是将所有的参数拼接，传入u()中计算
这里的参数是一个逗号表达式，最后得到的传入参数是r
r = ("body=".concat(i, "&amp;params=").concat(o, "&amp;sign_token=").concat(r) 这里较为明显的未知参数是body以及sign_token
可以通过断点分析得到下面的结果，这个结果就是计算后的r
body={"brandId":"","catalogueId":"260186","cityCode":350100,"clp":true,"extraFilter":{"inStock":false,"showIndustryFeatured":false},"from":0,"fz":false,"keyword":"","productFilter":{"brandIds":[""],"properties":{}},"rangeFilter":null,"searchType":{"notNeedCorrect":false},"size":20,"sort":0}&amp;params={"traceId":"213681131613962067063"}&amp;sign_token=799c9842f09c490196047064e10dead8 网站的开发很贴心了，还在逻辑里加了console.log
body和parmas都是查询参数，body中包含了城市信息之类的内容，这个需要根据要爬取的内容修改
除此之外还有sign_token未知，这个就是另一个要分析的参数zkhst
zkhst 获取 经过调试得到下面这个结果，在定位的js中有一个switch控制流
在918行，会进行一次判断，如果r = Object(s.f)("zkhst")没有获取到值，会进入到Object(l.i)();这个逻辑。如果有值会break进入926行的逻辑。
所以需要先把Object(s.f)("zkhst")的值变为undefinde，进入s.f中，可以看到下面这段逻辑
h = function(t) { t = document.cookie.match(new RegExp("(^| )".concat(t, "=([^;]*)(;|$)"))); return null != t ? decodeURIComponent(t[2]) : null } 可以得到zkhst是从cookie中得出的，直接清除cookie中的zkhst就能进入生成的逻辑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37e1416d950f7a6a97d5a916e9691659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57568f37c3b5c9f9e87cf98b60ade7ba/" rel="bookmark">
			vue项目中src引入相对路径的图片不显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下所示：
&lt;template&gt; &lt;img :src="img" alt=""&gt; &lt;/template&gt; export default { data () { img: './logo.png' } } 这样动态引入图片，在页面会显示不出, 在这里有两种方法可以解决，造成这种现象的原因，我最后会说明
解决方法 第一种：直接 import 导入图片
&lt;template&gt; &lt;img :src="img" alt=""&gt; &lt;/template&gt; import img from './logo.png' export default { data () { img } } 第二种方法： 将图片放到静态资源目录下 也就是 static 文件夹下，然后引入相对路径，也可以完美规避这种问题
好了，说了解决方法，下面来看看造成这种情况的原因，先了解一下 下面两个文件夹
assets: 一般我们会将图片，字体图标放到该文件夹下，在项目编译的过程中，该文件夹会被webpack处理解析为模块依赖，只支持相对路径形式。build的时候由Webpack解析为模块依赖。
static：该文件夹一般放置一些静态资源（第三方文件），这个目录下的文件不会被webpack处理，不会被webpack解析，它会直接放到最终的打包目录之下，一般没有做任何更改的情况下会在dist/static下。所以必须使用相对路径引用这些文件，这里是通过config.js文件中的build.assetsPublic和build.assertsSubDirectory链接来确定的。任何放在static/下的文件都是需要以相对路径的形式引入。
根据webpack的特性，放在static下的文件是不会变动的静态资源，asserts下放可能会变动的文件
总结一下原因：在动态加载的情况下，webpack会将图片当做模块来用，所以url-loader无法解析图片的相对路径，导致路径丢失，显示不出图片。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f2f087d7f5c7230460ed985be4195d/" rel="bookmark">
			MySQL8.0忘记密码了如何修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：关闭Mysql服务 首先先停止mysql服务。可通过net stop mysql或者任务管理器中关闭。
以管理员权限操作：
第二步：跳过Mysql密码验证 进入命令提示符（管理员登陆）操作，进入mysql目录中bin文件夹下，mysql8.0与其他版本不同的地方在于无法直接使用mysqld --skip-grant-tables来跳过密码登录。在这我们使用mysqld -console --skip-grant-tables --shared-memory来跳过权限验证。
输入执行后没有反馈，新开一个管理员窗口重新执行。
进入目录后，确保自己已经关闭了Mysql的服务：net stop mysql
关闭Mysql服务之后，继续在D:\mysql-8.0.19-winx64\bin目录下进行操作：
输入
mysqld --console --skip-grant-tables --shared-memory 在输入这行代码之后，如下显示，我们就已经成功跳过Mysql的密码登录了：
第三步：无密码方式进入Mysql 在上述步骤之后，再打开一个管理员模式运行的cmd.exe
进入mysql下的bin目录后，直接登录mysql
不需要通过net start mysql打开mysql服务
在命令行中输入以下代码
d: cd D:\mysql-8.0.19-winx64\bin(此处输入自己电脑上的安装目录) mysql -u root -p 如图：
此时会显示让你输入密码，直接回车，就可以成功连接Mysql。
第四步：将登陆密码设置为空 输入代码，将密码设置为空（此时还不能直接修改密码，必须先设置为空，否则会报错）
输入：
use mysql; (使用mysql数据表) update user set authentication_string='' where user='root';（将密码置为空） quit; (然后退出Mysql) 操作如图：
第五步：更改自己的登陆密码 这里分为两个部分
1.关闭第一个cmd窗口(一定要关闭！)； 2.在第二个窗口中输入代码； net stop mysql(关闭mysql服务,虽然会显示没有开启服务，但是以防万一) net start mysql(再打开mysql服务) (这里不要嫌麻烦，如果上一个mysql服务没关闭,我们依旧是无密码登陆)
操作如图：
接着输入：
cd D:\mysql-8.0.19-winx64\bin (此处输入自己电脑上的安装目录) mysql -u root -p (此处会显示输入密码，直接回车就好了，第四步我们已经将他置为空了) ALTER USER 'root'@'localhost' IDENTIFIED BY 'root';（更改密码） 如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f2f087d7f5c7230460ed985be4195d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16de40b057342efe62221c2e6d94cc5d/" rel="bookmark">
			ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: NO)解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年12月20日。本文可收藏可转载可抄袭，但是麻烦抄袭的时候抄全点，别删的不成样子，让人瞎踩坑，这是在害人。我的博客大多比较详细，也可以说是啰嗦，因为用CSDN的大多是小白，将心比心，想想自己当初被垃圾博客搞得焦头烂额的时候。
2021年11月25日修改，标示打开的CMD窗口次序。
问题：ERROR 1045 (28000): Access denied for user ‘root’@‘localhost’ (using password: NO) 很久没用这台电脑的mysql了，今天需要连接数据库，启动数据库报错：
ERROR 1045 (28000): Access denied for user ‘root’@‘localhost’ (using password: NO)
解决方法： 查阅资料后知道了，应该使用已知的用户名和密码登陆
mysql -u root -p
然而密码忘了，试了好几遍终于试出来了：
然后修改成通用的密码，不乱折腾了：
发现很多教程都过时了，我的版本是Server version: 8.0.19 MySQL ，最新的方法：
mysql&gt; use mysql; mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY '123'; mysql&gt; flush privileges; 退出验证下看看有没有成功：
可以看到修改密码成功了。
然后呢，我又假装密码忘了，把忘记密码的修改密码方法演示一下： 第一步：关闭Mysql服务 首先先停止mysql服务。可通过net stop mysql或者任务管理器中关闭。
以管理员权限操作：（这是第一个窗口）
第二步：跳过Mysql密码验证 进入命令提示符（管理员登陆）操作，进入mysql目录中bin文件夹下，mysql8.0与其他版本不同的地方在于无法直接使用mysqld --skip-grant-tables来跳过密码登录。在这我们使用mysqld -console --skip-grant-tables --shared-memory来跳过权限验证。
输入执行后没有反馈，新开一个管理员窗口重新执行。（这是第二个窗口）
进入目录后，确保自己已经关闭了Mysql的服务：net stop mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16de40b057342efe62221c2e6d94cc5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc306197314fe9829883fd3d2a9682a6/" rel="bookmark">
			thrift序列化 java_[thrift]thrift中的对象序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文炒冷饭.说实话,一直挺看好Thrift,支持的语言又多,代码写的有很清晰,效率又不低,为啥研究Protocol Buffer的人那么多.不管那么多了....
Thrift中的对象序列化是我很看好的东西,他用compiler+类库,让你高效的完成任务,而且可以少犯错误.试想,有谁可以保证自己设计的对象,不会再改变呢?数据库的schema改了,你可以改改查询语句,但是如果你对象改了,之前序列化好的东西,有时候就很难搞回来了.(哎.....)
废话不说,看Thrift里面怎么搞的.
1. Thrift支持的数据类型
Thrift支持的数据类型定义在TProtocol.h这个头文件中,有一个TType的枚举:
enumTType {
T_STOP=0,
T_VOID=1,
T_BOOL=2,
T_BYTE=3,
T_I08=3,
T_I16=6,
T_I32=8,
T_U64=9,
T_I64=10,
T_DOUBLE=4,
T_STRING=11,
T_UTF7=11,
T_STRUCT=12,
T_MAP=13,
T_SET=14,
T_LIST=15,
T_UTF8=16,
T_UTF16=17};
而每一种Protocol都不一定全部支持这么多数据格式,T_LIST之前的都是被支持的.T_STRING是c string,可以和utf-8兼容.
2. Thrift对各种数据类型的读写
Thrift把对象序列化抽象成TProtocol这样一个抽象类,这个类的成员非常多,但是思路很明显,就是对各种数据类型的读写操作:
classTProtocol {public:virtual~TProtocol() {}
uint32_t writeMessageBegin(conststd::string&amp;name,constTMessageType messageType,constint32_t seqid);
uint32_t writeMessageEnd();
uint32_t writeFieldBegin(constchar*name,constTType fieldType,constint16_t fieldId) ;
uint32_t writeFieldEnd();
uint32_t writeFieldStop();//写各种类型的数据uint32_t writeBool(constboolvalue);
uint32_t writeByte(constint8_tbyte);
uint32_t writeI16(constint16_t i16);
uint32_t writeStructBegin(constchar*name);
uint32_t writeStructEnd();//此处省略若干行uint32_t readMessageBegin(std::string&amp;name,
TMessageType&amp;messageType,
int32_t&amp;seqid);
uint32_t readMessageEnd();
uint32_t readFieldBegin(std::string&amp;name,
TType&amp;fieldType,
int16_t&amp;fieldId);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc306197314fe9829883fd3d2a9682a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58ed3fd49f6a5afd142decf13e3bae1/" rel="bookmark">
			lotus notes java_Lotus Notes邮件开发——JAVA（2） | 学步园
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Notes的JAVA api发送邮件(代码片段)
最近要编写一个利用Notes自动发送邮件的程序,研究一天终于OK了``在这里跟大家分享代码
import lotus.domino.AgentBase;
import lotus.domino.NotesException;
import lotus.domino.NotesFactory;
import lotus.domino.Session;
public abstract class EclipseAgentBase extends AgentBase {
public abstract void sendMail(String text);
public Session getSession() {
try {
return NotesFactory.createSession();
} catch (NotesException e) {
throw new RuntimeException("Unable to create session", e);
}
}
}
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import lotus.domino.NotesThread;
import lotus.domino.Session;
import lotus.domino.*;
public class MyAgent extends EclipseAgentBase {
private String sendname;
private String servername;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b58ed3fd49f6a5afd142decf13e3bae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4be2e27eae1063d07fc1cf3f27950b/" rel="bookmark">
			npm和cnpm混用导致错误:不是内部或外部命令，也不是可运行的程序或批处理文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 众所周知npm的下载速度十分稳定，所以项目之初我就使用cnpm（npm即使是修改了源地址速度也无法与cnpm相比）
然后在对一个依赖进行安装时少打了一个字母c，使用了npm安装此时意外发生了，安装好依赖后整个项目直接崩溃，出现了不是内部或外部命令，也不是可运行的程序或批处理文件的错误
原因 cnpm为了让npm安装快速和容易默认使用npminstall进行下载，此时再使用npm下载可能会导致npm下载失败，并且这种混乱会影响到node_modules文件夹
解决方法 删除node_modules文件夹重新使用cnpm下载，若使用install -save进行安装可以通过cnpm install快速安装
为了防止再次出错，使用命令cnpm i --by=npm react-native，将安装程序更改为原始npm，但您将失去最快的安装速度—官方解释
npm install命令参数 npm install moduleName 命令
安装模块到项目node_modules目录下。不会将模块依赖写入devDependencies或dependencies 节点。运行 npm install 初始化项目时不会下载模块。 npm install -g moduleName 命令
安装模块到全局，不会在项目node_modules目录中保存模块包。不会将模块依赖写入devDependencies或dependencies 节点。运行 npm install 初始化项目时不会下载模块。 npm install -save moduleName 命令
安装模块到项目node_modules目录下。会将模块依赖写入dependencies 节点。运行 npm install 初始化项目时，会将模块下载到项目目录下。运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。 npm install -save-dev moduleName 命令
安装模块到项目node_modules目录下。会将模块依赖写入devDependencies 节点。运行 npm install 初始化项目时，会将模块下载到项目目录下。运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/206/">«</a>
	<span class="pagination__item pagination__item--current">207/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/208/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>