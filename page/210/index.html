<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6e6ea006ceb61aba5cefdec59757e4/" rel="bookmark">
			econnrefused MySQL_解决Node.js使用MySQL出现connect ECONNREFUSED 127.0.0.1:3306的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近用 Node 写一个小玩意，需要用到 MySQL 数据库，现在用得最广泛的是 mysql 这个库。然后呢，现在 ORM 这么火，干脆也上 ORM 吧，正好我也不会可以学习一下，于是找到了 Sequelize.js 这个 ORM 库。
发现问题
看看 Sequelize 的文档，so easy，两分钟搞定~
import Sequelize from 'sequelize';
let sequelize = new Sequelize('database', 'username', 'password', {
host: 'localhost',
port: 3306,
dialect: 'mysql',
pool: {
max: 5,
min: 0,
idle: 10000
}
});
// ...后面还有一堆懒得贴了
运行一下
SequelizeConnectionRefusedError: connect ECONNREFUSED 127.0.0.1:3306
什么鬼，为什么会出现这个错误呢？我明明设置的是 localhost，为什么会变成 127.0.0.1？
解决问题
照例先谷歌，确实发现了很多人也遇到了这个问题，解决方法大概有这么几种：
1、你丫以为不用装 MySQL 就能跑了么？快去装数据库！
2、你数据库运行了么你？赶紧 /etc/init.d/mysqld start 运行起来
3、端口写错了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6e6ea006ceb61aba5cefdec59757e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba142e29d7926e209b1dcd10d2d04dee/" rel="bookmark">
			Git clone 常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git clone 常见用法 git clone 可以帮我们拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 1、如果你想拷贝一个git仓库到本地，我们可以先在本地创建一个文件夹
mkdir demo //基于当前目录创建一个子目录 2、进入demo这个目录
cd demo 3、 开始拷贝git仓库到本地，默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下
git clone &lt;远程仓库的网址&gt; 4、如果你想指定本地仓库的目录，可以使用如下命令：
git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt; 5、默认是克隆的是master分支，想要克隆指定的分支，需要 -b 指定要克隆的分支
git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt; 示例 可以看到成功拷贝一个 git仓库到本地
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a976949b59921d98cf93ca3722a3ccb/" rel="bookmark">
			anconda安装pulp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开terminal，输入：
anaconda search -t conda pulp
anaconda show conda-forge/pulp
conda install --channel https://conda.anaconda.org/conda-forge pulp
遇到“ WARNING conda.gateways.disk.delete:unlink_or_rename_to_trash(139) ”，输入
conda clean --all
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8198abc609f6b7747a738d19de8cd9/" rel="bookmark">
			3-8-1 实现两个数加减乘除运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//有两个参数的函数，实现加减乘除运算
int add(int a,int b)
{
int z;
z = a + b;
return z;
}
int jian(int a,int b)
{
int z;
z = a - b;
return z;
}
int chen(int a,int b)
{
int z;
z = a * b;
return z;
}
float chu(float a,int b)
{
float z;
z = a / b; //不同类型数据运算时，比如两个整数相除，必须将除数或者将被除数强制转换成小数，否则小数后面的小数点后面的数据会被忽略
printf("%f\n",z);
return z;
}
int main()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8198abc609f6b7747a738d19de8cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482ebfffa066ed4c505ba37ddeb977ce/" rel="bookmark">
			一台电脑能运行两个mysql数据库_一台电脑可以同时装两个带有SQL数据库的软件吗...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
可以的，但是前提是必须不同版本e69da5e6ba903231313335323631343130323136353331333431356565的软件，如果是相同版本的肯定是不行的
SQL是英文Structured Query Language的缩写，意思为结构化查询语言。SQL语言的主要功能就是同各种数据库建立联系，进行沟通。按照ANSI(美国国家标准协会)的规定，SQL被作为关系型数据库管理系统的标准语言。SQL Server是由Microsoft开发和推广的关系数据库管理系统
扩展资料：
特点
1．真正的客户机/服务器体系结构。
2．图形化用户界面，使系统管理和数据库管理更加直观、简单。
3．丰富的编程接口工具，为用户进行程序设计提供了更大的选择余地。
4．SQL Server与Windows NT完全集成，利用了NT的许多功能，如发送和接受消息，管理登录安全性等。SQL Server也可以很好地与Microsoft BackOffice产品集成。
5．具有很好的伸缩性，可跨越从运行Windows 95/98的小型电脑到运行Windows 2000的大型多处理器等多种平台使用。
6．对Web技术的支持，使用户能够很容易地将数据库中的数据发布到Web页面上。
7．SQL Server提供数据仓库功能，这个功能只在Oracle和其他更昂贵的DBMS中才有。
SQL Server 2000与以前版本相比较，又具有以下新特性 ：
1．支持XML(Extensive Markup Language，扩展标记语言)
2．强大的基于Web的分析
3．支持OLE DB和多种查询
4．支持分布式的分区视图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c996dbafa678104696578710e0b40f2/" rel="bookmark">
			sqoop mysql导入hive报错_[Hadoop] Sqoop 从MySQL导入数据到hive表报错“Could not load org.apache.hadoop.hive.conf.Hiv...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sqoop从MySQL导入数据到Hive表报错：ERROR hive.HiveConfig: Could not load org.apache.hadoop.hive.conf.HiveConf. Make sure HIVE_CONF_DIR is set correctly.
[hadoop@hadoop01 ~]$ sqoop create-hive-table --connect jdbc:mysql://localhost:3306/db_1 --username root --password root --table city_info --hive-table city_info --fields-terminated-by ',' --hive-overwrite;
Warning: /home/hadoop/app/sqoop-1.4.6-cdh5.7.0/../hbase does not exist! HBase imports will fail.
Please set $HBASE_HOME to the root of your HBase installation.
Warning: /home/hadoop/app/sqoop-1.4.6-cdh5.7.0/../hcatalog does not exist! HCatalog jobs will fail.
Please set $HCAT_HOME to the root of your HCatalog installation.
Warning: /home/hadoop/app/sqoop-1.4.6-cdh5.7.0/../accumulo does not exist!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c996dbafa678104696578710e0b40f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7abd2c97466fa2172ccc26403e0de2/" rel="bookmark">
			redis和mysql数据一致性怎么保证_redis如何与mysql保持一致性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis与mysql保持一致性的方法有两种，分别是：1、在写库前后都进行【redis.del(key)】操作，并且设定合理的超时时间；2、通过基于订阅binlog的同步机制实现redis与mysql保持一致性。
redis与mysql保持一致性的方法有采取延时双删策略，先删除缓存再写数据库；第二种方法是异步更新缓存，先读取读Redis再写mysql再更新Redis数据
缓存和数据库一致性解决方案如下：
方法一：采用延时双删策略
在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
伪代码如下public void write(String key,Object data){ redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key); }
具体的步骤就是：
(1)先删除缓存
(2)再写数据库
(3)休眠500毫秒
(4)再次删除缓存
那么，这个500毫秒怎么确定的，具体该休眠多久呢？
需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。
设置缓存过期时间
从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。
该方案的弊端
结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。
方法二：异步更新缓存(基于订阅binlog的同步机制)
技术整体思路：
MySQL binlog增量订阅消费+消息队列+增量数据更新到redis
1)读Redis：热数据基本都在Redis
2)写MySQL:增删改都是操作MySQL
3)更新Redis数据：MySQ的数据操作binlog，来更新到Redis
Redis更新
(1)数据操作主要分为两大块：
一个是全量(将全部数据一次写入到redis)一个是增量(实时更新)
这里说的是增量,指的是mysql的update、insert、delate变更数据。
(2)读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。
这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。
其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。
这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。
当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2e1cc0a4366710c44a70b15ff73982/" rel="bookmark">
			正则匹配第一个符合的_这份正则表达式速查表，实力与颜值并存！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者| GitPython
来源| GitPython
字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求无处不在。 正则表达式是一种匹配字符串的强有力的武器。 它的设计思想是用一种描述性的语言来给字符串定义一个规则。凡是符合规则的字符串，我们就认为它匹配了；否则该字符串就是不合法的。 re 模块，使 Python 语言拥有全部的正则表达式功能。 本文主要包括以下内容： 1.一图总结正则表达式的核心知识点 2.正则表达式的案例实战 3.文章汇总 1.一图学会正则表达式 1)基础字符 2)匹配单个字符 3)匹配多个字符 4)具体的实例 5)贪婪匹配和非贪婪匹配 6)re模块的几个函数 长按图片，快捷保存 2.正则表达式的案例实战 1)re模块的基本使用 import reret = re.match('复仇者联盟\d','复仇者联盟5')ret.group()#输出结果：'复仇者联盟5' 2)贪婪匹配和非贪婪匹配 # 非贪婪匹配 (匹配最短的 以a开头以b结尾 的字符串)ret_ft = re.match('a.*?b', 'aabab') # 贪婪匹配ret_t = re.match('a.*b', 'aabab') print(ret_ft.group(), ret_t.group())# aab aabab 3)案例1：判断变量名是否合法 变量名的命名规范： - 变量名只有由数字、字母、下划线组成。 - 变量名开头不能是数字。 # 案例1# 判断变量名是否合法names = ['age_1', '1age_', 'age-1', '/age', 'get_ipython']for name in names: ret3 = re.match('^[a-zA-Z_][a-zA-Z0-9_]*$', name) if ret3: print('{}:符合规范,匹配结果:{}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2e1cc0a4366710c44a70b15ff73982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f5a42cefbb58aa7952d500a5a426a7/" rel="bookmark">
			HTTP超全详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP协议简介 超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。
HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：
HTTP工作流程 一次HTTP操作称为一个事务，其工作过程可分为四步：
客户机与服务器建立TCP连接。只要单击某个超级链接/输入网址/提交表单等。建立连接后，客户机发送http请求给服务器.服务器接到请求后，响应信息。客户端接收服务器所返回的信息，然后客户机与服务器断开TCP连接。 HTTP发展及各版本 版本产生时间内容发展现状HTTP/1.11997年持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码2015年前使用最广泛HTTP/22015年多路复用、服务器推送、头信息压缩、二进制协议等逐渐覆盖市场 HTTP1.1 版本 HTTP 1.1 新增了delete options 等几种请求数据的方式，客户端和服务端三次握手后，建立tcp链接，一个tcp链接可以传送多个请求和响应，这样就减少了握手和建立tcp和关闭tcp链接的消耗，传输更快
HTTP 1.1 支持持久链接 请求头有一个connection 参数，参数值是close/keep-alive 意思是本次请求处理完后，服务器是关闭该tcp链接还是继续使用该链接
HTTP 2.0 版本 HTTP2.0使用了多路复用的技术，做到同一个链接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
HTTP主要特点 简单快速
客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。灵活
HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。无连接
无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 1. 无连接？有连接？
HTTP不是字面意义上的没有连接，事实上，这个定义也符合HTTP短连接的定义，但无连接强调的是HTTP的特性，短连接可理解为一种实现。
无连接的含义也可以结合HTTP无状态的含义在应用层面上去理解：每一个请求都拥有自己的请求体，期望接收到唯一的对应的响应体，而每一次的请求都相互独立，与上一次或下一次的请求毫无关系，哪怕是在同一条连接中（后面说的长连接）。
&gt; 2. 什么是长连接、短连接？
在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。
无状态
无状态是指协议对于事务处理没有记忆能力。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。
支持B/S及C/S模式
TCP三次握手 HTTP属于应用层协议，传输层使用TCP协议。HTTP协议是建立在TCP协议之上的一种应用。
为什么要三次握手?
为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。
【1】seq：序号，占4个字节,由于TCP是面向字节流的，在一个1个TCP连接中传送字节流中国的每一个字节都按照顺序编号，此外序号是循环使用的
【2】ACK：仅当ACK=1时确认字段才有效，当ACK=0时确认字段无效，并且TCP规定，在连接建立后所有的传送报文段都必须要把ACK置为1
【3】SYN：同步序列号，用来发起一个连接。当SYN=1而ACK=0时表明这是一个请求报文段；若对方同意连接，则响应报文中SYN=1，ACK=1
第一次握手:
服务器端处于LISTEN(收听)状态，等待客户端连接请求。
客户端发送连接请求报文段，将SYN=1，初始序号seq=x。(SYN报文段不能携带数据，但消耗一个序号)
客户端进入SYN_SENT(同步已发送)状态，等待服务器的确认；第二次握手:
服务器收到客户端请求的SYN报文段。需要对这个SYN报文段进行确认，确认号ack=x+1(seq+1)；
服务器发送SYN请求信息，将SYN=1，ACK=1，并为自己选择一个初始序号seq=y；
服务器端发送确认报文段(SYN+ACK报文段)给客户端（报文段不能携带数据，但消耗一个序号）
服务器进入SYN_RECV（同步收到）状态；第三次握手:
客户端收到服务器的SYN+ACK报文段。将确认号ack设置为y+1，序列号为seq=x+1。
客户端向服务器发送ACK报文段(ACK报文段可以携带数据，如果不携带数据则不消耗序号)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f5a42cefbb58aa7952d500a5a426a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1462c7284227ccdd04edd58ae586faf2/" rel="bookmark">
			nginx监听非80端口，转发地址端口丢失！解决方案！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nginx监听非80端口，转发地址端口丢失！解决方案！！！！！
问题场景：
登录成功后，跳转主页，端口丢失，无法访问。nginx监听端口：81，tomcat访问端口：9004。例如：登录地址：http://xxx:81/login，登录成功后跳转地址：http://xxx:81/index，但实际跳转地址变为：http://xxx/index，nginx代理端口(81)无故消失，导致无法访问。
nginx配置如下：
location /xxx/{
proxy_pass http://127.0.0.1:9004/xxx/;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-Proto https;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $ host:$server_port;
proxy_redirect http:// https://;
}网上提供的方案：
1) proxy_set_header Host $ host:$server_port;
改为
proxy_set_header Host $host:81;（写死监听端口，经测试无效）最终解决方案：
增加配置：proxy_set_header X-Forwarded-Port $server_port;
最终配置如下：
location /xxx/{
proxy_pass http://127.0.0.1:9004/xxx/;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-Proto https;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $ host:$server_port；
proxy_set_header X-Forwarded-Port $server_port;（这个配置是重点）
proxy_redirect http:// https://;
}
重启nginx，成功进入主页；
参考连接：[https://www.95id.com/oauth2-client-nginx-bugs.html]总结：
目前只解决问题，具体原因未知，欢迎大佬指正！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e87efb8870b6d57a65c40ab74f608174/" rel="bookmark">
			python入门爬虫案例_10个python爬虫入门实例(小结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天带伙伴萌学习python爬虫，准备了几个简单的入门实例
涉及主要知识点:
web是如何交互的
requests库的get、post函数的应用
response对象的相关函数，属性
python文件的打开，保存
代码中给出了注释，并且可以直接运行哦
如何安装requests库(安装好python的朋友可以直接参考，没有的，建议先装一哈python环境)
windows用户，Linux用户几乎一样:
打开cmd输入以下命令即可，如果python的环境在C盘的目录，会提示权限不够，只需以管理员方式运行cmd窗口
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests
Linux用户类似(ubantu为例): 权限不够的话在命令前加入sudo即可
sudo pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests
1.爬取强大的BD页面，打印页面信息
# 第一个爬虫示例,爬取百度页面
import requests #导入爬虫的库，不然调用不了爬虫的函数
response = requests.get("http://www.baidu.com") #生成一个response对象
response.encoding = response.apparent_encoding #设置编码格式
print("状态码:"+ str( response.status_code ) ) #打印状态码
print(response.text)#输出爬取的信息
2.常用方法之get方法实例，下面还有传参实例
# 第二个get方法实例
import requests #先导入爬虫的库，不然调用不了爬虫的函数
response = requests.get("http://httpbin.org/get") #get方法
print( response.status_code ) #状态码
print( response.text )
3. 常用方法之post方法实例，下面还有传参实例
# 第三个 post方法实例
import requests #先导入爬虫的库，不然调用不了爬虫的函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e87efb8870b6d57a65c40ab74f608174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd50075c23ec00cb054c2239d3dded6/" rel="bookmark">
			python3.0关键字详解_Python 使用 _________________ 关键字来定义类。 (3.0分)_学小易找答案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【填空题】在 Python 中定义类时,与运算符“ // ”对应的特殊方法名为 _______________ 。 (3.0分)
【计算题】编写函数,判断一个数字是否为素数,是则返回字符串 YES ,否则返回字符串 NO 。
【计算题】阅读下面的代码,分析其执行结果。 def demo(a, b, c=3, d=100): return sum((a,b,c,d)) print(demo(1, 2, 3, 4)) print(demo(1, 2, d=3)) (4.0分)
【计算题】计算小于 100 的最大素数。(此题的各种变型) (4.0分)
【计算题】编写程序,在 D 盘根目录下创建一个文本文件 test.txt ,并向其中写入字符串 hello world 。 (10.0分)
【计算题】编写函数 demo(t) ,接收一个整数 t 为参数,打印杨辉三角前 t 行。 (4.0分)
【计算题】编写程序,计算组合数 C(n,i) ,即从 n 个元素中任选 i 个,有多少种选法。 (4.0分)
【计算题】编写函数 demo(lst) ,接收一个包含若干整数的列表参数 lst ,返回一个元组,其中第一个元素为列表 lst 中的最小值,其余元素为最小值在列表 lst 中的下标。 (4.0分)
【判断题】定义类时所有实例方法的第一个参数用来表示对象本身,在类的外部通过对象名来调用实例方法时不需要为该参数传值。 (3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd50075c23ec00cb054c2239d3dded6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6450491f8f02e50147a7ae0093e3975a/" rel="bookmark">
			hadoop HA集群搭建发现journalnode没有启动起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这时先去查看Hadoop目录下的logs日志目录中的hadoop-hadoop-journalnode-master.out
查看出错的原因，然后进行修改即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4331bb6f704dad1c5debf792a7be9d4f/" rel="bookmark">
			helm部署zookeeper&#43;kafka集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		helm部署zookeeper+kafka集群 系统环境下载zookeeper kafka的helm包安装zookeeper kafka测试集群卸载应用 系统环境 一个k8s集群，安装helm，实现动态PV供给（非必须），并且设置为默认storageclass
k8s集群信息
[root@master ~]# kubectl get node -A NAME STATUS ROLES AGE VERSION master Ready &lt;none&gt; 52d v1.17.11 node1 Ready &lt;none&gt; 52d v1.17.11 node2 Ready &lt;none&gt; 52d v1.17.11 node3 Ready &lt;none&gt; 52d v1.17.11 动态PV（后端为nfs存储）
[root@master ~]# kubectl get storageclass NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE nfs-storage (default) nfs-storage Retain Immediate false 31h helm版本
[root@master ~]# helm version version.BuildInfo{Version:"v3.4.1", GitCommit:"c4e74854886b2efe3321e185578e6db9be0a6e29", GitTreeState:"clean", GoVersion:"go1.14.11"} 下载zookeeper kafka的helm包 添加bitnami仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4331bb6f704dad1c5debf792a7be9d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e410940d44d12b9ecf062e7de3b0854/" rel="bookmark">
			C#中如何使用Chart图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chart控件可以用来绘制波形图、柱状图、饼图、折线图等，用来进行数据表现是很不错的，现在简单说一下这个控件的使用方法
效果图
我们首先要加载Chart控件，
然后打开控件的属性窗口
在这个窗口里面我们可以修改曲线的名称，名称在【数据》Name】里面修改
讲一下属性窗口里面我们用到的几个选项的作用吧
数据
XValueType是X轴的数据类型，Y同理，这里我们选Time，可以随时间改变
图表
ChartType是图表的类型，我们可以选出我们想要用的类型，这里选曲线
外观
Color可以选择曲线的颜色，这里我选了红色
左边的成员 框，是我们要显示的曲线，可以添加多个
其他属性如果有需要自行修改，修改好之后确定，回到窗口设计界面
在工具箱添加Timer
在Timer的事件窗口双击时钟事件
代码如下，请自行对照填到对应的事件里面去
public partial class Form1 : Form { int cnt = 0; public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { timer1.Enabled = true; } private void timer1_Tick(object sender, EventArgs e) { chart1.Series[0].Points.AddY(cnt*cnt); label1.Text = cnt.ToString(); cnt++; } private void chart1_Click(object sender, EventArgs e) { } } cnt是个自变量，曲线显示的是cnt为底的2次指数曲线
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3858e7e0559e28207423aa1bc5a1a0/" rel="bookmark">
			Kafka实战：KafkaConsumer#seek方法不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 背景2. 示例3. 结论 1. 背景 现需要在Kafka管理平台中加入数据预览功能，浏览topic最新的10条数据，我们需要用startOffset = HighWatermark - 10公式求出起始startOffset，从startOffset开始查询分区中的数据。
但是，在使用KafkaConsumer#seek方法设置offset时不生效，KafkaConsumer#poll始终无法拉取到历史数据，更精确地说，始终只能拉取到最新插入的数据。
环境：
CDH 6.3.2
Kafka 2.2.1
kafka-client 2.2.0
2. 示例 现有如下示例，示例中启动了一个KafkaConsumer并尝试从指定位置消费制定分区
public class KafkaConsumerKerberos { public static void main(String[] args) throws InterruptedException { String bootstrapServers = System.getProperty("bootstrapServers"); String topic = System.getProperty("topic"); Properties consumerConfig = new Properties(); consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); // consumerConfig.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"); consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getCanonicalName()); consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getCanonicalName()); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(consumerConfig); TopicPartition topicPartition = new TopicPartition(topic, 0); Set&lt;TopicPartition&gt; assignments = consumer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3858e7e0559e28207423aa1bc5a1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90563133a91ebce14ae0521eb417176/" rel="bookmark">
			idea 安装插件后 启动报错 无法进入主界面  org.picocontainer.PicoRegistrationException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea 安装插件后 启动报错 无法进入主界面 org.picocontainer.PicoRegistrationException: Key com.itangcent.idea.plugin.settings.SettingBinder duplicated
解决方法：手动删除之前安装的插件包，再重启即可 idea 插件包的路径为：
Examples for IntelliJ IDEA 2020.3:
插件包在Plugins路径下
Windows: Configuration (idea.config.path): C:\Users\&lt;user&gt;\AppData\Roaming\JetBrains\IntelliJIdea2020.3 Plugins (idea.plugins.path): C:\Users\&lt;user&gt;\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins System (idea.system.path): C:\Users\&lt;user&gt;\AppData\Local\JetBrains\IntelliJIdea2020.3 Logs (idea.log.path): C:\Users\&lt;user&gt;\AppData\Local\JetBrains\IntelliJIdea2020.3\log macOS: Configuration (idea.config.path): ~/Library/Application Support/JetBrains/IntelliJIdea2020.3 Plugins (idea.plugins.path): ~/Library/Application Support/JetBrains/IntelliJIdea2020.3/plugins System (idea.system.path): ~/Library/Caches/JetBrains/IntelliJIdea2020.3 Logs (idea.log.path): ~/Library/Logs/JetBrains/IntelliJIdea2020.3 Linux: Configuration (idea.config.path): ~/.config/JetBrains/IntelliJIdea2020.3 Plugins (idea.plugins.path): ~/.local/share/JetBrains/IntelliJIdea2020.3 System (idea.system.path): ~/.cache/JetBrains/IntelliJIdea2020.3 Logs (idea.log.path): ~/.cache/JetBrains/IntelliJIdea2020.3/log 我的办公电脑是Linux,如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c499861e32e7ec815afe2f8e5039a87/" rel="bookmark">
			2.算法-贪心算法，分配问题（leetcode455发饼干，135发糖果），区间问题（435无重叠区间），练习（605种花，452射气球，122 买卖股票）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 算法解释 保证每次操作都是局部最优，局部结果互不相干，全局结果是局部结果的简单求和，从而使最后得到的结果是全局最优的。
二 分配问题 例1：leetcode题455，分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
1.题目分析：
从胃口小（数组g中最小的）的开始分配，在饼干里找能满足其胃口的且最小的（即数组中大于g【i】且最小的）分给他，然后再考虑剩下的。
贪心策略：每次给剩余孩子里胃口最小的分配能满足胃口的最小饼干
2.优化：
由于两个数组都需找出最小的，且需获得大小关系，如果直接循环遍历两次，容易一开始取到胃口最大的小孩，所以应在开始判定之前，将两个数组都由小到大排序。这样 就可以从头开始分别遍历。
然后这里如果用双层for 的话，情况会很复杂，首先两个数组谁长谁短，每个循环何时结束？都不好判断，而且可能会重复遍历。
所以这个题目用while(numchild&lt;g.size() &amp;&amp; numcookie&lt;s.size() )，一旦有一个遍历结束就结束，即要么孩子先没了，要么第一个孩子胃口大于最大的饼干，后面的孩子就都吃不了。
然后符合情况的numchild++，否则就一直numcookie++
3.sort（）排序函数：
sort(first_pointer,first_pointer+n,cmp) 3.2 功能：该函数可以给数组，或者链表list、向量排序。
3.3 实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。
3.4参数：
此函数有3个参数：
参数1：第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。
参数2：第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。
参数3：默认可以不填，如果不填sort会默认按数组升序排序。也就是1,2,3,4排序。也可以自定义一个排序函数，改排序方式为降序什么的，也就是4,3,2,1这样。
3.5使用
使用此函数需先包含：
#include &lt;algorithm&gt; 并且导出命名空间：
using namespace std; 简单例子：对数组A的0~n-1元素进行升序排序，只要写sort(A,A+n)即可；对于向量V也一样，sort(v.begin(),v.end())即可。题目中给的是两个向量gs，所以我们使用向量排序。
4.代码
class Solution { public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(),g.end());//排序 sort(s.begin(),s.end()); int numchild=0; int numcookie=0; while(numchild&lt;g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c499861e32e7ec815afe2f8e5039a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269d24934ea25beb410c7fb65f5c40cb/" rel="bookmark">
			数据库命令速记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大的原则 前提：登录数据库后才能执行下面的操作
两种登录方式： mysql –uroot –pmysql –h121.234.324.324 –P3306 –uroot –p 操作数据库：增、删、查、进入操作数据库中的表：增、删、改、查操作表中的数据：增、删、改、查 项目增删改查数据库create databasedrop database [数据库名称];use [数据库名称]; （进入数据库）show databases;数据库中的表create tabledrop tablealter table [数据表名称] modify/change [列名] [数据格式];show/desc表中的数据insert into [表名]delete from [表名]update [表名]select from 一、操作数据库 1. 创建数据库（create database） 编号动作命令格式举例1创建数据库create database [数据库名称];create database crm9;2创建数据库，并指定编码方式create database [数据库名称] character set [编码方式];create database crm9 character set utf8;3创建数据库，并指定编码方式和排序规则create database [数据库名称] character set [编码方式] collate [排序规则];create database crm9 character set utf8 collate utf8_general_ci; 2. 查看数据库（show databases） 编号动作命令格式举例1查看数据库show databases;show databases;2模糊查询数据库show databases like ‘模糊匹配字符’;show databases like ‘%crm%’;3查询某个数据库的创建语句、编码方式show create database [数据库名称];show create database crm9; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269d24934ea25beb410c7fb65f5c40cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7b7615f998b105492f40e93405b6de/" rel="bookmark">
			Luminar AI for Mac (AI照片编辑软件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Luminar AI可以识别照片的内容，建议最好的“模板”以加快编辑过程。这些编辑可以应用和完善到完美。有更多方法可以改善您的图像。您将找到一个完整的“编辑”模块，该模块具有完美组织的工具和精巧的界面，减少了混乱。
Luminar AI Mac版软件简介
Luminar AI Mac版全新的人工智能引擎。触手可及的速度和控制。要创建所有这些出色的结果，需要花很多力气。这就是为什么我们构建了一个全新的人工智能引擎。Luminar AI的核心既更快又更智能。您可以在更少的时间内获得更高质量的结果。Luminar AI是照片编辑的进化步骤。如果您的目标是在更短的时间内获得精美的图像-而又不牺牲创造力或控制力-您将需要Luminar AI
Luminar AI Mac功能介绍
人像摄影
•人体AI和脸部AI –轻柔地雕刻和完善人像
•虹膜AI –创造富有表情的眼睛
•皮肤AI –去除瑕疵和瑕疵，以获得更自然的人像摄影
风景摄影
•大气AI和天空增强器–在风景摄影中为天空增添深度和细节
•黄金时段和阳光–在照片中带来温暖并增强阳光
•天空AI 2.0 –变换照片并在几秒钟内添加全新的天空–还包括水反射
专业修饰
•结构AI –增强细节和纹理
•构图AI –获得完美的裁剪并修复弯曲的图像
•口音AI –获得完美的曝光和色彩
以上就是小编今天为大家分享的内容，希望对您有所帮助，想了解更多关于Mac相关知识，请关注macz吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4af94a2af0c56a8632580b4f0976e4e/" rel="bookmark">
			Linux下无人值守安装脚本kickstart
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下无人值守安装脚本kickstart Linux下无人值守安装脚本kickstart Linux下无人值守安装脚本kickstart1.实验环境准备实验环境搭建在VM的虚拟机中进行虚拟化部署搭建网络安装源部署虚拟化NAT模式与桥接模式网桥的搭建使用脚本进行虚拟化部署 2.无人值守安装脚本生成ks文件并共享文件到httpd服务中编写kickstart文件设定kickstart文件权限利用虚拟机安装脚本测试kickstart文件内容 1.实验环境准备 实验环境搭建 在VM的虚拟机中进行虚拟化部署 1.在系统中对硬盘进行扩容处理，虚拟机中添加硬盘（本机安装已为80GB）
（假若VM中安装的Linux系统的硬盘容量过小为20GB，可进行以下操作扩容）
对安装好的硬盘进行格式化，使设备进行使用
对虚拟机硬件信息进程调整让虚拟机可以支持虚拟化
2.在虚拟机中配置软件安装环境
3.在虚拟机中安装虚拟化
搭建本地软件源
下载虚拟化部署组件
4.在虚拟机中格式化硬盘并挂载虚拟机目录中
5.调整虚拟机硬件，开启全虚拟化功能，并调整cpu和内存
搭建网络安装源部署虚拟化 1.vim编辑网卡配置文件，进行网络配置
2.编辑虚拟机设置，将虚拟机内存调整到大于6GB，重启虚拟机
3.安装阿帕奇软件
4.关闭防火墙，开启阿帕奇
5.关闭原有设备挂载（默认），新挂载到软件源目录上(使之可以共享)
若为扩容硬盘后的虚拟机，需要执行
建立虚拟机需要正在这个目录中用qemu用户建立硬盘，不设定无法建立文件
NAT模式与桥接模式 虚拟机默认NAT模式：
真实主机的内核开启路由器vbr0，vbr0一端连接vnet0，一端连接真实网卡
数据传给Vnet0，vnet0通过vbr0将数据传送给物理网卡。
网桥的搭建 BRIDGE网桥模式：
br0作用：建立桥梁使虚拟机和物理网卡(原本不能通信的两端)建立连接
网桥的搭建
1.进入网卡配置目录，ls查看到物理主机的真实网卡
2.复制真实网卡信息，生成br0网桥配置文件
vim编辑 ，删除IP，添加BRIDGE=yes
不能通过vbr0传输数据到物理网卡，无法获得IP，正常读取网络资源
解决：在真实主机搭建dhcp服务，虚拟机获得IP
通过网桥模式时，可以正常部署虚拟化
1.安装dhcp服务
2.开启dhcp服务
3.成功完成虚拟化部署
使用脚本进行虚拟化部署 完成硬件选择 1.使用参数 virt-install虚拟化创建脚本 Virt-install man virt-install ##查看帮助 帮助查看时直接搜索 EXAMPE 注意事项： \换行符 ##使编辑更加明了，每行后面都有空格！换行符不能有字符，否则不代表换行 只能建立一次，再次执行时，提示已经建立##脚本解释器 $1 执行脚本输入替换的输出 脚本后输入什么，输出就替换为什么 ##简化建立步骤的繁琐 #!/bin/bash ##脚本解释器 virt-install \ ##虚拟机安装命令 --location http://172.25.254.111/westos \ ##指定安装资源 --os-variant rhel8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4af94a2af0c56a8632580b4f0976e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1078c88331c97533691a0715440245/" rel="bookmark">
			手把手 Flutter 混合开发 -- 基于 FlutterBoost 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.FlutterBoost 简介
2.FlutterBoost 集成 ( 版本 1.17.1 )
2.1 Flutter 端集成
2.2 Android 端集成
3.FlutterBoost 使用
3.1 FlutterBoost 初始化
3.2 Native 传参启动 Flutter 页面，并接收返回结果
3.3 Flutter 传参启动 Native / Flutter 页面，并接收返回结果
4.最后
本文未提供 iOS 端集成与使用示例
当一个成熟的产品/项目，想要开始 Flutter 开发，同时又不想从零开始全面使用 Flutter 开发，最后选择保留原有 Native 项目代码和功能，在新业务或变动上使用 Flutter 进行开发，这种以 既有原生，又有 Flutter 的开发模式就称之为 Flutter 混合开发模式。该开发模式的好处体现在，不用全面推翻 APP 项目的原有积累， Native 端就可以无感接入 Flutter ，开始 Flutter 开发，拥抱 Flutter 的特性特点。
1.FlutterBoost 简介 FlutterBoost 是阿里系闲鱼技术团队开源的 Flutter 插件，它可以轻松为现有原生应用程序提供 Flutter 混合集成方案。其理念是将 Flutter 像 WebView 那样来使用。FlutterBoost 帮开发者处理 Native 与 Flutter 页面的映射和跳转，开发者只需关心页面的名字和参数即可 ( 通常可以是 URL ) 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1078c88331c97533691a0715440245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89a60881a28a0124bb3cac622e19d30/" rel="bookmark">
			element ui中改变某一行或者单元格的颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element 官网讲解 row-class-name行的 className 的回调方法，也可以使用字符串为所有行设置一个固定的 className。Function({row, rowIndex})/String——row-style行的 style 的回调方法，也可以使用一个固定的 Object 为所有行设置一样的 Style。Function({row, rowIndex})/Object——cell-class-name单元格的 className 的回调方法，也可以使用字符串为所有单元格设置一个固定的 className。Function({row, column, rowIndex, columnIndex})/String——cell-style单元格的 style 的回调方法，也可以使用一个固定的 Object 为所有单元格设置一样的 Style。Function({row, column, rowIndex, columnIndex})/Object—— 1、根据条件改变某一单元格的颜色
&lt;el-table :data="rowData" border size="mini" :cell-style="styleBack"&gt; &lt;el-table-column label="row1"&gt;11111&lt;/el-table-column&gt; &lt;el-table-column property="" label="row2"&gt;22222&lt;/el-table-column&gt; &lt;el-table-column property="" label="row3"&gt;33333&lt;/el-table-column&gt; &lt;el-table-column property="" label="row3"&gt;44444&lt;/el-table-column&gt; &lt;el-table-column property="" label="row3"&gt;55555&lt;/el-table-column&gt; &lt;el-table-column property="" label="row3"&gt;66666&lt;/el-table-column&gt; &lt;/el-table&gt; rowData: [ { id: 1, num: 2 }, { id: 2, num: 3 }, { id: 3, num: 4 }, ], styleBack({ row, column, rowIndex, columnIndex }) { if (columnIndex == 1 &amp;&amp; row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d89a60881a28a0124bb3cac622e19d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d327e7f9cbb9df864c9481de2e42b087/" rel="bookmark">
			mysql成绩是什么数据类型_MySql数据类型分析（数值(小数型)类型） Part2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.小数型 包括两种类型：
1.浮点型 Float(M,D)
2.定点型 decimal(M,D)
二.M,D分析
1.小数型中的M和整数中的M 大不相同；
2.整数中的M 与所存数据的大小没有关系，只在有ZEROFILL修饰符时，控制显示填充零的为数有关。
3.小数中的M与所存数据的大小有必然关系，假如 申请类型为：float(6,2)：其中，6代表小数类型为 不包括小数点在内为6为，其中2代表小数位，因此，能存入-9999.99到+9999.99
4.如果Float(6,2) 带有标示符 Unsigned，则此数据类型的存储范围为：0.00到+9999.99
举例:
创建表goods：
create table goods
(
name varchar(10) not null default ' ',
price float(6,2) not null default 0.00
) charset utf8;
插入一条数据：
insert into goods
(name,price)
values
('跑步机'，688.896)；
点击回车，执行成功；
三.大家可以看到，已经成功插入到goods表中，
其中，小数 688.896 经舍入法 进行了截取，
Mysql中默认的舍入法 是 银行家舍入法，下一篇将说明 银行家舍入法。
四.定点类型
decimal(M,D)
分析：
1.定点类型和浮点类型 用法差不多，区别就是定点类型的精度比浮点类型的精度高。
举例：
在foods表中增加两列
alter table foods
add
bigprice float(9,2) not null default 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d327e7f9cbb9df864c9481de2e42b087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635d48617ee2274ffe97ea458afbf501/" rel="bookmark">
			nuxtjs开发的ssr网站，如何在后退时返回到上次滚动位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nuxtjs开发的服务端渲染网站，默认刷新或者返回的时候，会自动滚动到顶部的位置； 要想去掉这个特性，我们可以在跟目录下添加app/router.scrollBehavior.js文件 其中注释掉了前进后退返回顶部的代码，编译后会覆盖默认行为 import { getMatchedComponents, setScrollRestoration } from "./utils"; if (process.client) { if ("scrollRestoration" in window.history) { setScrollRestoration("manual"); // reset scrollRestoration to auto when leaving page, allowing page reload // and back-navigation from other pages to use the browser to restore the // scrolling position. window.addEventListener("beforeunload", () =&gt; { setScrollRestoration("auto"); }); // Setting scrollRestoration to manual again when returning to this page. window.addEventListener("load", () =&gt; { setScrollRestoration("manual"); }); } } export default function(to, from, savedPosition) { // If the returned position is falsy or an empty object, will retain current scroll position let position = false; const Pages = getMatchedComponents(to); // Scroll to the top of the page if.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/635d48617ee2274ffe97ea458afbf501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f24dcf77cc61a9533da7fdf113b760/" rel="bookmark">
			python 什么场景使用python的__new__魔法方法，以及__new__作用和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么场景使用python的__new__魔法方法，以及__new__作用和原理 1. `__new__`是什么2. `__new__`的使用2.1 参数`cls``*args, **kwargs` 2.2 返回值 3. `__new__`的使用场景单例模式构建元类 1. __new__是什么 __new__是python内置的魔术方法，并且是一个类方法，作用也很简单，就是在python的类进行实例化的时候，创建实例。并且__new__的执行是一定在__init__之前的
class T: def __new__(cls, *args, **kwargs): print("__new__ is executing") return super().__new__(cls) def __init__(self): print("__init__ is executing") self.a = 1 &gt;&gt; t = T() __new__ is executing __init__ is executing 所以可以在构造函数__init__运行之前，可通过__new__方法对实例的创建进行一些改造。
2. __new__的使用 2.1 参数 cls 先来讲第一个参数，也是最重要的参数：
__new__的第一个参数一定是会传递需要被实例化的类，这是在python底层就写死了的。通常来说，其约定俗成的参数名是cls
熟悉类方法修饰器的 @classmethod一定也熟悉这个约定俗成的参数名，在类方法修饰器修饰的函数中，第一个参数一般也是cls，代表类本身
所以，如果你要把super().__new__(cls)中的cls变量换成类名本身，当然也是没问题的；
class T: def __new__(cls, *args, **kwargs): print("__new__ is executing") # 这里的 T 即是该类的类名，等同于这里的cls，即类本身 return super().__new__(T) def __init__(self): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2f24dcf77cc61a9533da7fdf113b760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8bfd2c85ba17a3c6e62fadd80baa5b/" rel="bookmark">
			LFU算法族：window-LFU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LFU算法族相关文章目录汇总：
LFU算法
LFU-Aging算法
window-LFU算法（本文）
1、LFU算法的不足 LFU（Least Frequently Used）是一种缓存淘汰算法。LFU算法是根据缓存的访问频率，去淘汰访问次数最低的缓存。这样就给LFU带来了两个问题：
不可避免的问题：对于每个缓存项，LFU都需要记录其访问次数，这导致了LFU需要一笔不小的额外内存开销；可一定程度避免的问题：对于记录的访问次数，LFU要对其进行排序，用于淘汰访问次数最低的算法。而对大量数据的排序，则会带来一定的处理器开销。当然，这个开销可以通过在每次操作时调整排序顺序，来避免在内存淘汰时一次发生。 同时，由于LFU记录的是缓存生成以来访问频率，如果一条缓存曾经访问了很多次，但是如果服务的逻辑发生了改变，这条缓存已经很少甚至不再会被访问，这条缓存由于其历史访问次数很高，依然不会被淘汰。这就导致了缓存污染的问题：
缓存污染：系统将不常用的数据存入到缓存，造成常用数据的挤出，降低了缓存效率的现象。 总结来说，LFU算法有两个不可避免的问题：
对于每个缓存项，LFU都需要记录其访问次数，需要不小的额外内存开销；近期不再访问的历史数据无法清理，导致缓存污染。 2、window-LFU算法描述 Window-LFU被用来一定程度上解决LFU上述两步不可避免的问题。
Window是用来描述算法保存的历史请求数量的窗口大小的。Window-LFU并不记录所有数据的访问历史，而只是记录过去一段时间内的访问历史。即当请求次数达到或超过window的大小后，每次有一条新的请求到来，都会清理掉最旧的一条请求，以保证算法记录的请求次数不超过window的大小。
2.1 缓存访问记录的维护 在实现时，Window-LFU一般会维护一个定长队列，或者用数组实现环形缓存区来存储访问历史。
例如：一个缓存场景，window = 9，现在有9条缓存访问记录，按时间顺序从先到后分别是：A,B,C,D,A,B,C,D,A，即缓存队列
此时又来了一条新的缓存请求B，这是Window-LFU算法就会把第一条缓存访问记录A删掉，并将B加到队尾：
2.2 缓存淘汰 Window-LFU的缓存淘汰方式和LFU是一致的。
Window-LFU首先会计算window条记录中各条缓存项的访问次数，然后根据访问次数排序，淘汰次数最少的缓存项。当然，计算缓存想访问次数的操作，也可以放到每次缓存访问记录更新的同时，这样就避免了每次缓存操作的耗时长的问题。
一般来说，Window-LFU会使用哈希结构来存储“缓存项 &lt;---&gt; 访问次数”的映射，因为哈希的时间复杂度低，为o(1)。
3、Window-LFU的优缺点 3.1 优点 由于Window-LFU不存储全部历史数据，所以其额外内存开销要明显低于LFU算法，同时由于数据量明显减少，Window-LFU排序的处理器成本也要低于LFU。
另外，由于早于前window次的缓存访问记录会被清理掉，所以Window-LFU也可以避免缓存污染的问题，因为过早时间访问的缓存已经被清理掉了。
在缓存命中率方面，Window-LFU一般会由于LFU，因为Window-LFU一定程度上解决了缓存污染的问题，缓存的有效性更高了。缓存污染问题越严重的场景，Window-LFU的命中率就比LFU高的越多。
另外，和LFU-Aging相比，Window-LFU对缓存污染问题的解决更彻底一些，所以在缓存使用场景产生改变时，命中率会优于LFU-Aging。
3.2 缺点 但是Window-LFU需要维护一个队列去记录历史的访问流，复杂度略高于LFU。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc92ac0db75afad8cc344000cccb166/" rel="bookmark">
			mysql mts_MySQL5.7 union all &#43; jdbc预编译参数useServerPrepStmts=true Bug 踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题背景
生产环境Percona MySQL 5.7.19 执行SQL报错 如下：java.sql.SQLException: Unknown type '14 in column 0 of 1 in binary-encoded result set.
at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:965)
at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:898)
at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:887)
at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:861)
at com.mysql.jdbc.MysqlIO.extractNativeEncodedColumn(MysqlIO.java:4558)
at com.mysql.jdbc.MysqlIO.unpackBinaryResultSetRow(MysqlIO.java:4472)
at com.mysql.jdbc.MysqlIO.nextRow(MysqlIO.java:2045)
at com.mysql.jdbc.MysqlIO.readSingleRowSet(MysqlIO.java:3400)
at com.mysql.jdbc.MysqlIO.getResultSet(MysqlIO.java:470)
at com.mysql.jdbc.MysqlIO.readResultsForQueryOrUpdate(MysqlIO.java:3112)
at com.mysql.jdbc.MysqlIO.readAllResults(MysqlIO.java:2341)
at com.mysql.jdbc.ServerPreparedStatement.serverExecute(ServerPreparedStatement.java:1368)
at com.mysql.jdbc.ServerPreparedStatement.executeInternal(ServerPreparedStatement.java:783)
at com.mysql.jdbc.PreparedStatement.executeQuery(PreparedStatement.java:1966)
at JDBCClient.main(JDBCClient.java:39)
2. 排查问题
该Bug复现条件：应用程序使用jdbc连接MySQL数据库，并且打开jdbc预编译参数useServerPrepStmts=true
应用程序中执行了含有UNION ALL的SQL，并且SQL执行返回的数据中包含有DATE类型的字段。Metadata from result sets for UNION ALL queries could say NEWDATE rather than DATE. (Bug #27422376)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc92ac0db75afad8cc344000cccb166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee7e9bb288b76d55de62e575d688c3c/" rel="bookmark">
			CentOS发行版号和RHEL版本对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详情地址：https://wiki.centos.org/Download 存档版本
CentOS Linux 7
发布
基于RHEL Source（版本）
存档的树
7（1804）
7.5
树
7（1708）
7.4
树
7（1611）
7.3
树
7（1511）
7.2
树
7（1503）
7.1
树
7（1406）
7
树
CentOS Linux 6
发布
基于RHEL Source（版本）
存档的树
6.10
6.10
树
6.9
6.9
树
6.8
6.8
树
6.7
6.7
树
6.6
6.6
树
6.5
6.5
树
6.4
6.4
树
6.3
6.3
树
6.2
6.2
树
6.1
6.1
树
6
6
树
CentOS Linux 5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee7e9bb288b76d55de62e575d688c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1614f0ffb0c8e6ef9783a6bcf5960c8f/" rel="bookmark">
			打印机自定义纸张找不到_金蝶账无忧如何设定自定义纸张大小打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在凭证录入完成后，金蝶账无忧是支持凭证打印的。一共有2种凭证打印方式，第一种是套打。套打是根据系统设置好的模板，用金蝶专用的凭证纸进行打印，打印纸张规格为240mmX140mm，KP-J103模板。暂时不支持KP-Z103。另一种打印是根据大家手里的纸张规格设定打印。现在咱们就介绍一下自定义纸张大小的打印。
我用客户实际纸张规格演示。纸张规格210mmX297mm。
一、在控制面板打印机中增加纸张规格。控制面板→打印机→选定打印机右鼠标键：打印首选项→自定义纸张大小，设定名称为：KINGDEE。纸张规格设定为210mm；297mm。
二、在打印选项中选择输出尺寸为KINGDEE的纸型。
三、在账无忧凭证查询中→打印→凭证打印→PDF打印，选择自定义纸张，规格设定为短边210毫米 长边297毫米
四、打印预览后是这个样子，我们先打印一张凭证看一下效果，里面的参数根据打印机不同，分别设置就可以，案例中的截图仅供参考。
凭证打印相关的配置基本上就是这些，在实际设置中，每个打印机的品牌和设置方法略有不同。此办法作为一个参考，大家可以自己设置下看看，如果设定不好，可以找我远程协助大家设定下。
金蝶姜-18940982658
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968f4feb301d2ef568ed386fa464d1da/" rel="bookmark">
			【Django】Specifying a namespace in include() without providing an app_name is not supported
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题所在： 问题分析 include需要两个参数，arg和namespace, 当namespace不为空时，arg参数必须是一个2元组，除了urlpatterns不能为空之外，app_name也必须填写
解决方案 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f44a653c8e236fee59b813f917b61a/" rel="bookmark">
			vue利用a标签点击下载保存图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue前端a标签点击下载保存图片 想不调用接口直接下载保存图片，翻csdn把手都翻出血了。
亲测一行代码搞定：
把图片地址设在download属性上，而不是放在href中:
关键代码：
&lt;a href="" :download="item.src" class="download"&gt;&lt;/a&gt; &lt;template&gt; &lt;div class="contain"&gt; &lt;el-dialog title="图片预览" :visible.sync="dialogVisible" width="790px" height="554px" :show-close="true" :autoplay="false" :close-on-click-modal="false"&gt; &lt;el-carousel indicator-position="outside"&gt; &lt;el-carousel-item v-for="item in imgList" :key="item.id"&gt; &lt;a href="" :download="item.src" class="download"&gt;&lt;/a&gt; &lt;img :src="item.src" alt="" /&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import xiazai from '@/assets/icons/xiazai.svg'; export default { name: 'Carousel', props: { imgList: { type: Array, default: [], required: true, }, }, data() { return { downloadImg: [], dialogVisible: false, }; }, methods: {}, }; &lt;/script&gt; &lt;style lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f44a653c8e236fee59b813f917b61a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c22ca92e70598a69e702c8cbec76f0d/" rel="bookmark">
			docker(2)仓库：Registry 、harbor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Docker hubRegistry工作原理，一次docker pull 或 push背后发生的事情 2.搭建私有仓库1)安装,解决速度和依赖性:阿里云-》容器-》docker新建server12，作docker 2)加密3）认证login登陆 3.docker-compose.同时管理多个1)创建 harbor仓库2）网页新建用户westos维护人员能上传，访客不能上传，只能拉取 3)镜像签名tag网页扫描启动内容信任 官方docker hub：https://hub.docker.com/Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器 （Register）来保存多个仓库，每个仓库又可以包含多个具备不同 tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。registry 是镜像和图表的仓库，它不具有本地数据库以及不提供用户认证，通过 Index Auth service的Token的方式进行认证。 1.Docker hub [root@server11 ~]# docker rmi 4bb46517cac3 [root@server11 ~]# docker images [root@server11 ~]# docker search registry [root@server11 ~]# docker pull registry#下载registry镜像 [root@server11 ~]# docker history registry:latest #查看端口 [root@server11 ~]# docker run -d --name registry -p 5000:5000 -v /opt/registry:/var/lib/registry registry #运行容器。-d打入后台；-p端口映射；-v手工指定数据卷挂载点，宿主机路径：容器路径 0966e368a427b2eb1bd30f49b356ebf386e38dec06bcca28098b489064f67ffd [root@server11 ~]# docker ps [root@server11 ~]# ll -d /opt/registry/ [root@server11 ~]# yum install tree -y [root@server11 ~]# tree /opt/registry/ [root@server11 ~]# docker tag webserver:v4 localhost:5000/webserver:latest #tag给镜像打标签 [root@server11 ~]# docker images [root@server11 ~]# docker push localhost:5000/webserver#上传镜像到本地仓库 [root@server11 ~]# tree /opt/registry/ [root@server11 ~]# curl localhost:5000/v2/_catalog {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c22ca92e70598a69e702c8cbec76f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ba103528be213ba27ad51939346f4b2/" rel="bookmark">
			wia驱动程序正在使用中 无法安装_如果Windows无法加载驱动程序，请关闭“内存完整性”设置...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存完整性是Windows安全功能，可确保在Windows内核级别运行的任何代码都是可信赖的。该功能使用硬件虚拟化和Hyper-V来保护内核，防止其注入和执行恶意或未经验证的代码。驱动程序专门设计为在内核级别运行，因此OS可以与硬件对话。如果收到错误消息- 该设备无法工作，因为Windows无法加载该设备所需的驱动程序，则表明该驱动程序现在允许该驱动程序加载到您的设备上。在本文中，我们将分享替代方法来解决此问题。
如果Windows无法加载驱动程序，请关闭“内存完整性”设置 如果您的Windows 10设备无法正常工作，因为Windows无法加载该设备所需的驱动程序，请按以下步骤关闭“内存集成”，然后查看：
转到设置&gt;更新和安全&gt; Windows安全。单击以启动它。单击左上方的汉堡菜单，然后单击“ 设备安全性”。在“ 核心隔离”下，选择“ 核心隔离详细信息”。切换内存完整性。您需要重新启动计算机才能使更改生效。 当您禁用核心分离和存储器的完整性，有没有完整性检查，Windows启动，并加载驱动程序时尤其如此。尽管您可以继续使用而不解决驱动程序问题，但是您会；发现某些功能不再起作用。它可能不会造成问题，但是在某些情况下，结果可能很严重。
有两种其他方法可以解决此设备管理器错误代码。第一种是从OEM安装替代或更新的驱动程序，因为当前驱动程序可能已过时或不兼容。第二种方法是安装通用驱动程序。
从OEM安装替代或更新的驱动程序：当前正在使用的驱动程序可能已过时或存在漏洞，因为Windows无法加载该驱动程序。如果Windows Update无法为您找到合适的驱动程序，则应联系OEM以获取最新的驱动程序。安装通用驱动程序： Microsoft为任何硬件提供通用驱动程序。这将确保您可以使用设备，但功能有限。这比禁用完整性检查更好。这是安装通用驱动程序的方法。 我希望该帖子易于理解，并且关闭“内存”完整性可以帮助您加载驱动程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d8cf1718941ec0948d25381b1e7fe8/" rel="bookmark">
			系统学习 Zabbix 系统监控（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章介绍了zabbix 基本概念及其特点，阐述 zabbix 系统环境搭建与基础安装，如何实现对各类操作系统、硬件设备、应用软件监控告警。本文为系列第二篇，内容包括Windows 系统硬件信息获取、Linux 系统监控、Linux 系统硬件信息获取。前文点此：系统学习 Zabbix 系统监控（一）
5 windows 系统硬件信息获取 本文通过在 OS 操作系统层面上，主要获取 windows 服务器下 CPU 信息、内存信息、硬盘信息、操作系统、服务器信息。信息获取的实现方式是通过在 windows 系统下部署自定义 bat 脚本，执行脚本获取数据，再将获取的信息发送给 zabbix 服务端， zabbix 界面创建相应的监控项，触发器等，最终将信息展示出来。监控项内容如下：
CPU 信息：型号、个数、内核数、逻辑核、 CPU 健康状态，及状态告警。
内存信息：容量、个数、厂商、型号、序列号；主板支持内存最大容量和个数。
硬盘信息：厂商、个数、容量、序列号、接口类型、硬盘健康状态，及状态告警。
操作系统信息：主机名、操作系统版本、运行时长、统线程数、系统时间。
服务器信息：品牌、型号、序列号。
说明：一些特殊数据需要实现监控，例如 CPU 温度、硬盘状态、 Raid 卡状态、风扇转速等， windows 没有提供检测硬件温度组件，需要借助第三方工具如 IPMI tools ， fan-speed 等，也可以使用 IPMI 协议等其他方法来丰富 windows 系统硬件监控项，对于虚拟机并不适用，此时，推荐使用服务器的管理口，如 HPE 服务器的 iLO 、 DEll 服务器的 iDRAC ，联想服务器 XCC 等开启 snmp 功能，再进行 zabbix 配置，实现对服务器硬件全面监控。如果服务器未配置管理口，当然不能适用。
5.1 CPU 信息获取 应用集：CPU 硬件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d8cf1718941ec0948d25381b1e7fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab147a05e25d3fd2602618808b6114b/" rel="bookmark">
			Shader的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管线渲染
定义：图形数据在GPU上经过运算处理，最后输出到屏幕的过程
1. 顶点处理： 接收模型顶点数据、坐标系装换
2. 图元装配： 组装面、连接相邻的顶点，绘制为三角面
3. 光栅化 ：计算三角面上的像素，并为后面着色阶段提供合理的插值参数（以及深度值）
4. 像素处理： 对每个像素区域进行着色、写入到缓存
5. 缓存：一个存储像素数据的内存块，最重要的缓存是帧缓存与深度缓存
帧缓存：存储每个像素的色彩（缓冲）
深度缓存Z-buffer：前后排序（深度信息，物体到摄像机的距离）
6. Draw Call 绘制调用：每帧调用显卡渲染物体的次数
什么是缓冲？
一个像素有如下缓冲
颜色缓冲Color buffer/prixel buffer: 储存该点即将显示的颜色，RGBA值
深度缓存 depth buffer/Z buffer: 储存该点的深度Z
模板缓存stencil buffer ： 通常作用限制渲染区域。更高级用法需结合深度缓存，例如某像素的模板缓冲值会随着其是否通过深度缓冲测试而改变
什么是图元装配（Primitive Assembly）
经过变换的顶点 被装配成几何（三角形等）图集
什么是光栅化(栅格化)（Rasterization）
栅格化这个术语：可以用于任何将矢量图形转化成栅格图像的过程
在3D渲染中主要是指，三角形等图元（矢量）转化成像素碎片的过程。或者说决定哪些像素几何图元覆盖的过程。栅格化的结果是像素位置的集合和片段的集合
什么是光栅操作（Raster Operation）
指在碎片fragment处理后，在更新帧缓存前最后执行的一系列操作。通过包括裁剪，深度测试，alpha测试，alpha混合等。
Shader常见术语
Alpha 透明的（黑透白不透、灰色半透半不透）
Bump凹凸 （法线贴图）
Specular (高光)
Shader主要看Game视窗
Shader显示名称与Shader名不冲突
什么是GPU?
GPU：Graphic Processing Unit,中文翻译为“图形处理器”。显卡包括（GPU,显存，显卡BLOS，显卡PCB板）
什么是Shader?
Shader程序：GPU执行的，针对3D对象进行操作的程序
Shader编程有那几种？
CG：与DirectX 9.0 以上以及OpenGL 完全兼容。运行时或事先编译成GPU汇编代码
HLSL: 主要用于Direct3D。平台：Windows
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ab147a05e25d3fd2602618808b6114b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9629a63e66905c4828ff2c4f46bcdbc4/" rel="bookmark">
			[git]mac的github头像突然显示不出来，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 复制自己头像的链接地址
https://avatars.githubusercontent.com/u/22430436?s=460&amp;u=d615b6f55b01116874abc4229369ba6cf70d7f04&amp;v=4
如上述； 2. ping一下这个地址
使用https://www.ipaddress.com/ 来进行ping操作
https://githubusercontent.com.ipaddress.com/avatars.githubusercontent.com
拿到ip地址
199.232.96.133 3.更改mac host
sudo vi /etc/hosts
4.使host生效
sudo killall -HUP mDNSResponder 解决问题
Others: 因为网上还有其他办法,加了很多hosts
如果ip到时候变了,换起来很麻烦;
比如下述,记得改变前面的ip; # GitHub Start 199.232.96.133 assets-cdn.github.com 199.232.96.133 raw.githubusercontent.com 199.232.96.133 gist.githubusercontent.com 199.232.96.133 cloud.githubusercontent.com 199.232.96.133 camo.githubusercontent.com 199.232.96.133 avatars1.githubusercontent.com 199.232.96.133 avatars0.githubusercontent.com 199.232.96.133 avatars1.githubusercontent.com 199.232.96.133 avatars2.githubusercontent.com 199.232.96.133 avatars3.githubusercontent.com 199.232.96.133 avatars4.githubusercontent.com 199.232.96.133 avatars5.githubusercontent.com 199.232.96.133 avatars6.githubusercontent.com 199.232.96.133 avatars7.githubusercontent.com 199.232.96.133 avatars8.githubusercontent.com # GitHub End done！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d4608ac93ac6021fce3e57ff60d6ec/" rel="bookmark">
			查看kafka topic的消息offset范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看各个patition消息的最大Offset bin/kafka-run-class.sh kafka.tools.GetOffsetShell \ --topic topic_name \ --time -1 \ --broker-list host1:9092,host2:9092,host3:9092 查看各个partition消息的最小Offset bin/kafka-run-class.sh kafka.tools.GetOffsetShell \ --topic topic_name \ --time -2 \ --broker-list host1:9092,host2:9092,host3:9092 计算可消费的消息个数 max=`sh kafka-run-class.sh kafka.tools.GetOffsetShell --topic topic_name --time -1 --broker-list host1:9092,host2:9092,host3:9092|awk -F':' '{print $3}'| awk ' { SUM += $1 } END { print SUM }'` min=`sh kafka-run-class.sh kafka.tools.GetOffsetShell --topic topic_name --time -2 --broker-list host1:9092,host2:9092,host3:9092|awk -F':' '{print $3}'| awk ' { SUM += $1 } END { print SUM }'` echo $(($max-$min)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b57d3f95c3e12a5e7f1ec1e23f2c7d3/" rel="bookmark">
			node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。已解决！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是电脑新加了一个机械硬盘，发现原来的项目不能用了，查看node版本发现： node报错:node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。 所在位置 行:1 字符: 1 + node -v + ~~~~ + CategoryInfo : ObjectNotFound: (node:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException
解决办法: 重新下载node.js
https://nodejs.org/zh-cn/
重新启动VScode就好啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419671436de4a12babe13745fc6be6ca/" rel="bookmark">
			Sentinel-1 A/B 预处理需要注意的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sentinel-1 A/B 是一对双胞胎，提供的数据都是SAR数据，常用的数据源还有高分三号 。
Sentinel-1 A/B 的数据不像Landsat 数据那样可以用ENVI直接打开，所以需要用SNAP预处理。SNAP对于电脑配置要求比较高，至少是16G，所以如果配置不够高可以单独截取一块影像进行分析。
预处理后，如果需要用面向对象法进行分割，ENVI5.3会卡死的，可以使用ENVI5.1。EMVI的多个版本可以共存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983f846dd521c3a952c6fd32d469d6a0/" rel="bookmark">
			vue 使用el-dialog调用高德地图，无法显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 高德地图在页面中引用能够正常显示，但是想在el-dialog中显示高德地图并进行操作，地图无法显示
1、主要原因是当前生命周期mounted执行完成后，页面el-dialog元素并不存在，所有无法显示地图。
解决方法：兼听el-dialog 显示时 创建地图
setTimeout(function(){ _self.map = new AMap.Map("mapContainer", { resizeEnable: true, zoom: 13, center:_self.mapCenter }); _self.map.on('movestart',function(){ //地图开始移动事件 }); _self.map.on('mapmove',function(){ //地图移动中事件 }); },500) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd8dc499e734002741982ba1de90f86/" rel="bookmark">
			tapable详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tapable详解 tapable是webpack内部使用的一个流程管理工具，主要用来串联插件，完善事件流执行。
1.安装tapable yarn add tapable 2. 常用hooks import { SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook } form 'tapable'; [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gBgy8rW0-1611562755204)(D:\download\tapable.png)]
tapable通过tap注册一个事件，通过call执行该钩子注册的所有事件。
tapable的每个hooks都tap一个或多个事件。
tapAsync/callAsync、tapPromise/Promise用于注册同步执行的异步事件，callAsync用在并行执行的异步钩子完成后再执行该函数。
用法示例：
new SyncHook([arg1,arg2,...]) hooks接收一个数组参数，参数为执行回调事件所需的参数名。
call:(...args) =&gt; void当你的钩子触发之前,(就是call()之前),就会触发这个函数,你可以访问钩子的参数.多个钩子执行一次
tap: (tap: Tap) =&gt; void 每个钩子执行之前(多个钩子执行多个),就会触发这个函数
loop:(...args) =&gt; void 这个会为你的每一个循环钩子(LoopHook, 就是类型到Loop的)触发,具体什么时候没说
register:(tap: Tap) =&gt; Tap | undefined 每添加一个Tap都会触发 你interceptor上的register,你下一个拦截器的register 函数得到的参数 取决于你上一个register返回的值,所以你最好返回一个 tap 钩子.
2.1 SyncHook 同步串行，在触发事件之后，会依次执行注册的所有事件处理函数。其原理是将监听(订阅)的函数存放到一个数组中, 发布时遍历数组中的监听函数并且将发布时的 arguments传递给监听函数。
不关心返回值,从上到下依次执行注册事件。
const hook = new SyncHook(['name', 'sex']) /* tap(options,function): options是事件描述，可以为一个字符串，也可以为一个对象,为对象时必须包含name属性，描述该插件名称。 function:回调函数 */ // 打印我的名字 hook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd8dc499e734002741982ba1de90f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0955a0be86e718cbb31c964ee478d7b/" rel="bookmark">
			vue之echart表中datazoom配置用于左右滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dataZoom: [ { // start: 0, //默认为0 // end: 100 - 1500 / 31, //默认为100 endValue: 7, // 一次性展示7个。 type: "slider", show: true, xAxisIndex: [0], handleSize: 0, //滑动条的 左右2个滑动条的大小 height: 10, //组件高度 left: "10%", //左边的距离 right: "10%", //右边的距离 bottom: 26, //右边的距离 borderColor: "#000", fillerColor: "#269cdb", borderRadius: 5, backgroundColor: "#33384b", //两边未选中的滑动条区域的颜色 showDataShadow: false, //是否显示数据阴影 默认auto showDetail: false, //即拖拽时候是否显示详细数值信息 默认true realtime: true, //是否实时更新 filterMode: "filter", }, //下面这个属性是里面拖到 { type: "inside", show: true, xAxisIndex: [0], start: 0, //默认为1 end: 100 - 1500 / 31, //默认为100 }, ], 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62829caf86f152d0baef60612934d6bf/" rel="bookmark">
			css预编译方式 vue cli 选不选_Vue、Spring Boot开发小而完整的Web前后端分离项目实战03...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第03讲 前端Vue项目创建 1.1、vue cli 官网 https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create
1.2、在自己电脑本地磁盘新建一个文件夹，用于保存项目 ，文件夹命名最好使用英文名称，如下， D:0_teachUI
1.3、cd 进入文件夹，vue create 项目名称，输入 vue create project-vue 回车 1.3.1、 进入到项目保存的目录，输入 vue create project-vue 回车
1.3.2、回车进入到如下界面，键盘上、下键选择需要的创建方式，我们这里选择 manually select features，手动选择配置的方式，然后 回车
1.3.3、回车进入到如下界面，键盘上、下键移动选择需要的项，按 空格 键可以选中。我们选择如下带*的项目，然后 回车
选项说明 Babel：将ES6编译成ES5
TypeScript：使用TypeScript
Router和Vuex`：路由和状态管理
Linter/ Formatter：代码检查工具
CSS Pre-processors：css预编译
1.3.4、Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) y
路由使用历史模式? 这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面
1.3.5、 Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): 使用什么css预编译器？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62829caf86f152d0baef60612934d6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f97e85295e9f0ed2be865abd51e577a/" rel="bookmark">
			【C】为什么使用srand&#43;rand()后每次产生的随机数都一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/buku2010/article/details/19404885?%3E
当我把srand（time（0））放入for循环中时，rand每次生成的都一样：
for(int i=0;i&lt;100000;i++)
{
srand( (unsigned)time( NULL ) );
cout&lt;&lt;rand()&lt;&lt;endl;
}
答：你的程序是有问题的，你每产生一个随机数之前，都调用一次srand，而由于计算机运行很快，所以你每次用time得到的时间都是一样的（time的时间精度较低，只有55ms）。这样相当于使用同一个种子产生随机序列，所以产生的随机数总是相同的。你应该把srand放在循环外：
什么是伪随机数
如何生成不重复的随机数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5becffb986c727e6c1d99615d80dfafa/" rel="bookmark">
			Gerrit 环境搭建（基于Docker）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网：https://www.gerritcodereview.com
文档：https://review.gerrithub.io/Documentation/index.html
插件文档：https://www.gerritcodereview.com/plugins.html
源码：https://github.com/GerritCodeReview
镜像库：https://hub.docker.com/r/gerritcodereview/gerrit
运行命令
docker run -d \ --name gerrit3.3 \ -p 7001:8080 \ -p 7002:29418 \ -e CANONICAL_WEB_URL=http://10.8.6.179:7001 \ gerritcodereview/gerrit:3.3.1 关键参数解释：
-p 7001:8080 -p 7002:29418：8080为http端口；29418为ssh端口-e CANONICAL_WEB_URL=http://10.8.6.179:7001： CANONICAL_WEB_URL 为外部访问地址（体现在git clone地址上） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f871ba7bb525329e5eef240d944335f9/" rel="bookmark">
			C语言经典100题（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在复习数据库和Java，现在也在开始启动复习C语言，我准备写个专题，关于自己见到的关于C的一些题目，方便自己迎接考试。
题目：假设今天是星期日 则a的b次方天是星期几
这道题目的本质就是求除以7的余数是多少，如果直接算出a的b次方，有可能会超出C的存储范围，所以为了避免这种情况，要每计算一次，就要取一下余数
#include&lt;stdio.h&gt; int main(){ int a; int b; int i; int temp = 1; scanf("%d%d",&amp;a,&amp;b); //关键代码 for(i=1;i&lt;=b;i++){ temp = temp*a; temp = temp%7; } switch(temp){ case 0:printf("sunday");break; case 1:printf("monday");break; case 2:printf("tuesday");break; case 3:printf("wednesday");break; case 4:printf("thursday");break; case 5:printf("friday");break; case 6:printf("saturday");break;	} return 0; } 易出错点如下面的代码所示，刚开始，我直接在a上连乘，刚写完我就意识到自己写错了，又加一个变量temp。 for(i=1;i&lt;=b;i++){ a = a*a; a= a%7; } 题目：分数a/b换成小数之后，求第n为小数，0&lt;a&lt;b&lt;100，1&lt;=n&lt;=10000
这道题目我刚开始的思路是这样的，比如1/3，结果为1.3333333......，我先让结果乘以10，然后变成13，然后取%10，也就是取最后一位数字，也就找到了第一位小数数字。这种方法思路正确，操作性也行，但是会超出数据类型的存储范围，导致解决方法不成功，自己写的方法如下：
错误解法！
#include&lt;stdio.h&gt; int main(){ int a; int b; int n; double result; int x; int mul; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f871ba7bb525329e5eef240d944335f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65421c5511a8b2ac79fad5fdb211b7b3/" rel="bookmark">
			springboot文件上传和访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot文件上传和访问 一：文件上传需要的类MultipartFile（任意选择下面一种） 有两种jar包中有这个类:
（1）第三方的包
&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; （2）或者用springboot自己的包
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 二：保存文件，保存路径 @PostMapping("/admin/adminUserUpdateInfo") public String adminUserUpdateInfo( String username, String trueName, String gender, String qq, String wechat, String signature,//signature个人信息 @RequestParam("filename") MultipartFile file) { //管理员用户的原始头像url User user = userService.queryAdminUser(); String realPath = user.getAvatarImgUrl();//放入数据库的真实地址 以便前端使用 /* 上传头像图片到静态资源文件夹中 */ if (!file.isEmpty()) { //获取文件名 String fileName = file.getOriginalFilename(); // 获取文件的后缀名 String suffixName = fileName.substring(fileName.lastIndexOf(".")); // 文件上传路径 String filePath = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65421c5511a8b2ac79fad5fdb211b7b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655e0f7342661955142bf331a3bfed80/" rel="bookmark">
			【C】cannot convert ‘＜brace-enclosed initializer list＞‘ to ‘int‘ in assignment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载：https://blog.csdn.net/modi000/article/details/108180978
原因：数组定义与初始化分开时，只能进行单个元素的赋值，而不能进行统一赋值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7bd06edafcfc2ada83338b3d5412ce/" rel="bookmark">
			白话-设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		------------------- 23种设计模式分类 ---------------------- 创建型模式 (共5种)：工厂方法模式 抽象工厂模式 建造者模式 单例模式 原型模式结构型模式 (共7种)：适配器模式 桥接模式 ；装饰器模式 代理模式 ； 组合模式 外观模式 享元模式行为型模式 (共11种)：策略模式 模板方法模式 责任链模式 观察者模式 迭代子模式 命令模式 状态模式 备忘录模式 访问者模式 中介者模式 解释器模式 ------------------- 创建型 ---------------------- 简单工厂模式(静态工厂模式) ：用一个专业类（工厂类）来负责一种产品的对象创建。它不属于23种设计模式之一，但它是工厂模式的基础。（多工厂模式）
工厂方法模式：将工厂类抽象出一个接口，对象的创建方法延迟到工厂子类去实现。每一种产品都对应一个工厂子类。当新增一个产品类型时，新加对应的工厂子类即可，不再需要修改既有类。
抽象工厂模式：当一个类别的产品还有多个系列区分时，按系列生产商品。
建造者模式：当对象的创建比较复杂时，按步骤一块块创建，让创建过程模板化。
原型模式：通过拷贝原型对象来创建新的对象 （克隆）
注意：1 通过实现Cloneable 接口的原型模式在调用clone函数构造实例时并不一定比通过new 操作速度快，只有当通过new 构造函数 创建对象耗时时, clone 方式才能获得效率上的提升。
2 通过clone 拷贝对象时，不会再执行构造方法，一些在构造函数需要初始化的对象使用clone 拷贝需要注意
3 数值拷贝没有深浅拷贝之分，引用类型默认使用浅拷贝（影子拷贝），对于集合类型 一定要使用深拷贝。
开发中，也建议使用深拷贝，避免操作副本时影响原始对象。
------------------- 结构型 ---------------------- 适配器模式 已知两个不兼容的对象，将它们融合在一起。适配器模式把一个类的接口变换成客户端需要的另一种接口，从而使因接口不匹配而无法在一起工作的类能够在一起工作。
使用场景：
Android:ListView Adapter
桥接模式 定义：将两个维度变化的功能组合起来，目的是两个维度独立变化。
主要维度，附属维度，再将附属维度接口注入到主要维度所在对象。
适配器模式和桥接模式异同：
都是把两个对象组合起来配合工作。桥接模式的目标是分离，适配器模式的目标是合并。
装饰器模式（包装模式） 定义：不影响主流程的前提下，某个环节动态地给一个对象增加一些额外的职责。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc7bd06edafcfc2ada83338b3d5412ce/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/209/">«</a>
	<span class="pagination__item pagination__item--current">210/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/211/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>