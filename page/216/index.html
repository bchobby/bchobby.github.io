<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec55d28d9fd2243360ad8054ba038eb3/" rel="bookmark">
			visual studio 2019安装后添加工作负载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动visual studio 2019
2、如下图选中工具-获取工具和功能
3、点击工作负载-勾选要添加的负载—点击修改
4、等待安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad36539bfafcade89286c5b27e4156af/" rel="bookmark">
			echart多个柱状图 设置y轴显示_【软件应用】怎样把多组拟合柱状图，画在3D瀑布图中？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ORIGIN教程 【导读】西南交大的王博士提问：怎样绘制拟合柱图的3D瀑布图？有三组柱图及其拟合曲线，我们通常绘制出2D的柱线图(图1a)，怎样将三组拟合的柱状图绘制在一张3D瀑布图中，大多数同学可能绘制出图1b~d的效果，无论怎样设置，都不能将拟合曲线跟柱子拼在一起。 图1谭编尝试了双矩阵叠加绘制出图1e，一个采用3D柱图，一个采用3D散点图。由于矩阵要求严格的XY行列矩阵，要求两个矩阵XY严格对应，而拟合曲线是1000行数据，柱状图的行数约24行，在统一转成矩阵后，拟合曲线就被压缩为24个散点。最后，将绘图方案确定为图1f，今天就推出图1f的origin教程。 1. 软件版本本教程采用Origin9.5(2018C)，适合2018版以上版本。 2. 数据结构准备数据表结构为XYXYXY型，每个样品(柱图+拟合)共4列数据(AB为柱状图数据，CD为拟合数据)，共3个样品(如图2)。注释行依据不同样品名称编排。本教程提供“练习文件”，文末有下载方式。选择数据，点击下方工具栏“Z数据颜色映射3D瀑布图”，可以得到一字排开的瀑布图。 图2 3. 绘制修改3D瀑布图 要想将柱状图和拟合曲线堆叠在一起，我们需要将两者按照“注释”分组。具有相同注释文本的数据列将被分在同一组。 3.1 建立分组双击前述绘制的瀑布图中的曲线，在“组”标签页，选择“按列标签”-“注释”分组，具体步骤如图3。 图3 3.2 按分组“堆叠”曲线如图4，点击左边“Layer1”图层1，再点击“堆叠”选项页，选中“累积”，勾选“对使用“累积”……“分组”设置”，最后点击“确定”。 图4得到的曲线已经按照注释分组堆叠了，但是已经超出坐标系范围，需要一键调整(图5)。 图5得到的图中，拟合曲线在0附近出现了异常(图6)，我们可以调整X轴范围，将0改为“2E15”(即1×10^15)，避免这个异常。 图6 3.3 修改3D柱条图经过上述操作，得到了3组(每组2条)曲线，怎样将其中一条改为柱条图？双击曲线，在弹窗中，将左下方的类型改为“3D柱条图”(图7) 图7得到下图效果： 图8 4. 图文格式的修改 4.1 柱条颜色映射的修改双击上图的柱条，在弹窗的“组”选项页中，对“填充颜色”和“边框颜色”进行相同的设置，将“增量”改为“分格”，将“细节”的颜色改为七彩色(色号：Q03)，点击右边三个点点“…”选择橙、黄、绿或者其他颜色顺序，保持边框色与填充色的顺序一致。 图9 4.2 刻度值的修改横轴刻度值类似“2.00E+016”这种科学记数法表达式，显得繁杂，我们可以将刻度值除以10^16，与横轴标题中的单位一致(图10)。 图10 4.3 刻度标签的修改右侧的Z轴一般是三个样品的样品名称，双击刻度值“Frequency”，按照列名或标签，选择“注释”(图11)。 图11 4.4 刻度的修改上图中Z轴主刻度只有1个，双击Z轴，将主刻度按增量0.33设置，且第一个刻度位置为“1”，确定后，即可得到三个主刻度(图12)。 图12 4.5 自定义刻度标签由于分组重排，Z轴刻度标签的文本不再按照“注释”内容布局。多数同学就困扰在这个地方了，一般删除标签文本，手动添加文本，当然这个办法能解决问题。双击Z轴刻度标签，弹窗中将“显示-类型”改为“刻度索引字符串”，在“字符串”中输入三个样品的名称(用空格隔开，如果名称中有空格，则需要用引号)，具体步骤如图13所示。 图13如果要将图13中Z轴刻度的标签文本旋转，跟Z轴平行，则需要按下图步骤操作(图14)。 图14得到下图的效果 图15图15中，Y轴不是从0开始的，所以图中柱子比较高，我们需要将Y轴最小刻度改为0。双击Y轴刻度，弹窗中Scale最小值改为0(图16)。 图16得到下图的效果。 图17 4.6 3D瀑布图底面颜色的修改双击底面，点击“平面”选项页，修改ZX面(底面)颜色。当然也可以修改另外两个面的颜色。 图18最终得到下图的效果。 声明：壹砼壹世界使用的图片、音频、视频，来源于互联网。如有侵权，请后台联系删除。壹砼壹世界感谢你的关注。壹砼壹世界，带你在建材的天空中翱翔。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55cc4d283c589a36878ab97dfa4867f9/" rel="bookmark">
			杰里之静电处理方法【篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）摸底测试 所谓摸底测试，就是设计好的 PCB 板子，贴好片后的 PCBA，不加入 ESD 管子的情况下，进行静电枪 打击测试，测试本 PCBA 的抗 ESD 水平，这个期间多测试几个 PCBA 板子。蓝牙耳机的静电测试，看 ESD 后的蓝牙距离效果即可。 这个步骤是很重要的，对我们下一步的整改起到指导作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc27889769d6c537d48477cf99721e7a/" rel="bookmark">
			python 指定证书验证_Python通过OpenSSL获取指定域名对应的SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同一台服务器上配置了不同的虚拟主机域名证书也可以获取到，直接上代码了：
def get_certificate(hostname, port):
import idna
from socket import socket
from OpenSSL import SSL
sock = socket()
# sock.settimeout(10) # 不要开启
sock.setblocking(True) # 关键。。
sock.connect((hostname, port), )
ctx = SSL.Context(SSL.SSLv23_METHOD)
ctx.check_hostname = False
ctx.verify_mode = SSL.VERIFY_NONE
sock_ssl = SSL.Connection(ctx, sock)
sock_ssl.set_tlsext_host_name(idna.encode(hostname)) # 关键: 对应不同域名的证书
sock_ssl.set_connect_state()
sock_ssl.do_handshake()
cert = sock_ssl.get_peer_certificate()
sock_ssl.close()
sock.close()
return cert
for u in ['https://www.baidu.com/', 'https://mp.weixin.qq.com/', 'https://www.qq.com/']:
from urllib import parse
rs = parse.urlparse(u)
cert = get_certificate(rs.hostname, int(rs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc27889769d6c537d48477cf99721e7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a3a1d4d7dc4cee9cd6db194cc8a67e/" rel="bookmark">
			element——弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来以为弹窗挺简单的，结果自己想多了。这几天的使用碰到了好多问题。
在组件中使用弹窗 &lt;div id="app"&gt; &lt;el-button type="primary" @click="open=true"&gt;打开弹窗&lt;/el-button&gt; &lt;test :visible.sync="open" :table="tableData"&gt;&lt;/test&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; //定义组件 Vue.component('test',{ template:` &lt;el-dialog title="收货地址" :visible.sync="visible" @close="clone"&gt; &lt;el-table :data="table"&gt; &lt;el-table-column property="date" label="日期" width="150"&gt;&lt;/el-table-column&gt; &lt;el-table-column property="name" label="姓名" width="200"&gt;&lt;/el-table-column&gt; &lt;el-table-column property="address" label="地址"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-dialog&gt; `, props:{ //visible父组件传给子组件的值，控制是否显示弹窗 visible:{ type:Boolean, default:false }, table:{ type:Object, default:()=&gt;{ return {} } } }, methods:{ clone(){ this.$emit('update:visible',false) } } }) new Vue({ el:'#app', data:{ //是否打开弹窗 open:false, tableData:[{ date:'2020-10-01', name:'张三丰', address:'武当山' }] } }) 注意点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6a3a1d4d7dc4cee9cd6db194cc8a67e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86caaf76e3fcef7650c9cbdcb4b50183/" rel="bookmark">
			MQTT移植笔记及源码分析（基于w601）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MQTT嵌入式源码获取 MQTT官方源码地址：https://os.mbed.com/teams/mqtt/code/MQTTPacket/
eclipse源码地址：https://github.com/eclipse/paho.mqtt.embedded-c
eclipse源码中包含linux和freertos的移植文件，使用起来比较方便。
二、mqtt源码移植需要实现的函数接口 mqtt移植需要实现的函数接口主要有两类，一类是倒计时相关的接口函数，一类是网络连接相关的函数。
typedef struct Timer_{ struct timeval end_time; }Timer; void TimerInit(Timer*); //初始化时间 char TimerIsExpired(Timer*);//判断时间是否用尽 void TimerCountdownMS(Timer*, unsigned int);//以ms为单位进行倒计时 void TimerCountdown(Timer*, unsigned int);//以秒为单位进行倒计时 int TimerLeftMS(Timer*);//查看倒计时剩余时间 网络相关的接口函数
int linux_read(Network*, unsigned char*, int, int);//读socket数据 int linux_write(Network*, unsigned char*, int, int);//向socket写数据 void NetworkInit(Network*);//网络初始化 int NetworkConnect(Network*, char*, int);//连接mqtt服务器 void NetworkDisconnect(Network*);//断开socket连接 三、移植踩过的坑 3.1、tcp recv返回ENOTCONN和EAGAIN错误 初次移植好mqtt之后，mqtt连接上服务器大约20s左右，recv函数就会报ENOTCONN，后来才发现mqtt心跳开关c-&gt;keepAliveInterval为0。在keepalive函数中，如果这个值为0，系统是不会向服务器发送心跳包的。修改c-&gt;keepAliveInterval的值即可；EAGAIN是因为recv超时，属于正常情况，这时linux_read需要返回0； 3.2、mqtt订阅消息回调打印消息内容时间太长 出现这个问题的主要原因是w601的printf函数在mqtt的回调函数中使用有问题，导致系统在topic的回调函数中停留了5s左右的时间，使用rtthread内容的rt_kprintf函数可以避免这个问题。 3.3、发布qos大于0的消息时，publish函数经常返回-1 这时因为我在主函数中有如下代码：
while (!toStop) { MQTTYield(&amp;c, 1000);//轮训接收和处理mqtt消息	} MQTTYield会不停的调用lwip的recv函数读取网络中的消息，,如果qos大于0，publish函数会调用waitfor等待服务器的回复，而waitfor中也会调用lwip的recv函数等待网络消息，这就会产生两个线程同时访问同一个socket的问题。这个问题的解决方法有很多，比如可以使用mqtt源码本身提供的加锁功能，也可以修改源码，使用队列或邮箱的方式通知publish的结果。
3.4、源码本身存在一些bug 源码在处理mqtt的ping消息回复时，每一次调用MQTTYield都会检查服务器是否回复了ping消息。有时候因为网络不好等因素，服务器回复ping包的时间会大于一次MQTTYield的时间，这时代码中会认为ping失败，而实际上这种情况属于正常现象。解决办法是对源代码的几处代码进行简单的修改即可。 四、MQTT源代码分析 首先我们看下官方提供的基于linux的例程，此处省略了部分无关代码： Network n; MQTTClient c; NetworkInit(&amp;n);//初始化mqtt客户端的网络参数 NetworkConnect(&amp;n, opts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86caaf76e3fcef7650c9cbdcb4b50183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c453f07801f1e94649f0d84828947fc/" rel="bookmark">
			如何通过Anaconda创建虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做深度学习的同学们应该都受到配置环境的困扰（我也是饱受摧残）本文介绍几个踩过的坑。 在anaconda下创建一个虚拟环境 文件名为’pytorch’,python版本是 3.8 conda create -n pytorch python=3.8 在目录 ‘/home/YHT/anaconda3/envs/’可以找到该文件夹2.进入刚出创建的环境每次跑深度学习代码都要进入对应的环境 conda activate pytorch 3.使用清华镜像源 安装 pytorch
清华镜像源安装pytorch
4 退出Anaconda虚拟环境
conda deactivate 5.Anaconda 环境下安装各种包
anaconda配置包
大多数情况是可以用 pip install （你需要的包的名字）或 pip3 install但有时不好用，这样就借助anaconda环境 conda list #列出你的python所对应的包 conda install （你的包名称） 注意：可以要重复好多次 conda install pytorch torchvision torchaudio cudatoolkit=10.1,进度条拉满了就不用管了。
如果很慢，或总是失败就是用 pip安装
enjoy~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c89a01e7181cf0f81bd58b61cdd1d9f/" rel="bookmark">
			创建自定义控件Kotlin.Android
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建自定义控件 自定义控件代码 其实就是把这段代码加载到了主活动里
inflate(R.layout.title,this)//获取布局
//第一个参数加载布局id 第二个参数父布局
button.setOnClickListener{//操作布局按钮
val activity=context as Activity//那个活动转为当前活动
activity.finish()//关闭这个活动
}
button1.setOnClickListener {//操作布局按钮
Toast.makeText(context,"怎么了",Toast.LENGTH_SHORT).show()
}
LayoutInflater.from(context)就是在当前活动创建了对象
package com.example.uilayout import android.app.Activity import android.content.Context import android.util.AttributeSet import android.view.LayoutInflater import android.widget.LinearLayout import android.widget.Toast import kotlinx.android.synthetic.main.title.view.* //context那个活动 class TitleLayout(context:Context,attrs:AttributeSet):LinearLayout(context,attrs ) { init { //那个活动创建一个LayoutInflater对象inflate LayoutInflater.from(context).inflate(R.layout.title,this)//获取布局 //第一个参数加载布局id 第二个参数父布局 button.setOnClickListener{//操作布局按钮 val activity=context as Activity//那个活动转为当前活动 activity.finish()//关闭这个活动 } button1.setOnClickListener {//操作布局按钮 Toast.makeText(context,"怎么了",Toast.LENGTH_SHORT).show() } } } xml文件 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#E12525 "&gt; &lt;Button android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c89a01e7181cf0f81bd58b61cdd1d9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0d5e26172a5fcf8a20bcf5458a894b/" rel="bookmark">
			SHA256:FlR9BwwrmAxEX7QaQZMv1ejf8l0kwHvSzFlzqu8/VYM. Please contact your system administrator. Add co
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 之前一直用linux ssh连接服务器，今天因为需要用windows 连接服务器
问题描述： window 终端ssh 命令连接服务器
ssh admin@192.168.3.1
出现如下错误：
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is SHA256:FlR9BwwrmAxEX7QaQZMv1ejf8l0kwHvSzFlzqu8/VYM. Please contact your system administrator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa0d5e26172a5fcf8a20bcf5458a894b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5575309a6085181f35e1ed4050bb8f55/" rel="bookmark">
			python函数五要素_GeoPandas入门 | 01-地理数据介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01-地理数据介绍
源代码请看此处
1.1 Python地理空间矢量数据简介
%matplotlib inline
import pandas as pd
import geopandas
导入地理数据
地理空间数据通常可以从特定的GIS文件格式或数据存储中获得，如ESRI shapefiles、GeoJSON文件、geopackage文件、PostGIS(PostgreSQL)数据库、...
我们可以使用GeoPandas库中的geopandas.read_file函数，来读取其中的很多GIS文件格式(依靠的是fiona库，它是GDAL/OGR的python接口)。
例如，我们先读取一个包含世界所有国家边界的shapefile文件，zip文件放到在/data目录下)。
countries=geopandas.read_file("zip://data/ne_110m_admin_0_countries.zip")
countries.head()
featureclascalerankLABELRANKSOVEREIGNTSOV_A3ADM0_DIFLEVELTYPEADMINADM0_A3...NAME_KONAME_NLNAME_PLNAME_PTNAME_RUNAME_SVNAME_TRNAME_VINAME_ZHgeometry0Admin-0 country16FijiFJI02Sovereign countryFijiFJI...피지FijiFidżiFijiФиджиFijiFijiFiji斐濟MULTIPOLYGON (((180.00000 -16.06713, 180.00000...1Admin-0 country13United Republic of TanzaniaTZA02Sovereign countryUnited Republic of TanzaniaTZA...탄자니아TanzaniaTanzaniaTanzâniaТанзанияTanzaniaTanzanyaTanzania坦桑尼亚POLYGON ((33.90371 -0.95000, 34.07262 -1.05982...2Admin-0 country17Western SaharaSAH02IndeterminateWestern SaharaSAH...서사하라Westelijke SaharaSahara ZachodniaSaara OcidentalЗападная СахараVästsaharaBatı SahraTây Sahara西撒哈拉POLYGON ((-8.66559 27.65643, -8.66512 27.58948...3Admin-0 country12CanadaCAN02Sovereign countryCanadaCAN...캐나다CanadaKanadaCanadáКанадаKanadaKanadaCanada加拿大MULTIPOLYGON (((-122.84000 49.00000, -122.9742...4Admin-0 country12United States of AmericaUS112CountryUnited States of AmericaUSA...미국Verenigde Staten van AmerikaStany ZjednoczoneEstados UnidosСоединённые Штаты АмерикиUSAAmerika Birleşik DevletleriHoa Kỳ美国MULTIPOLYGON (((-122.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5575309a6085181f35e1ed4050bb8f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b415d94453ead8f73de7a76b6cc623/" rel="bookmark">
			python进行数组合并的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python的数组合并在算法题中用到特别多，这里简单总结一下：
假设有a1和a2两个数组：
a1=[1,2,3]
a2=[4,5,6]
合并方式 1. 直接相加
#合并后赋值给新数组a3 a3 = a1 + a2 2. extend
#调用此方法，a1会扩展成a1和a2的内容 a1.extend(a2) 3. 列表表达式
#先生成新的二维数组 a3 = [a1, a2] #列表推导形成新的数组 a4 = [ y for a in a3 for y in a ] 合并性能 下面分别测试下三种数组合并方式的性能
import time a1=range(100000000) a2=range(100000000) start=time.time() new_a = a1 + a2 end=time.time() cost = end - start print cost a1=range(100000000) a2=range(100000000) start=time.time() a1.extend(a2) new_a = a1 end=time.time() cost = end - start print cost a1=range(100000000) a2=range(100000000) a3=[a1,a2] start=time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b415d94453ead8f73de7a76b6cc623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82783e98e348742a509dcc8d4d2af8c/" rel="bookmark">
			SpringCloud Alibaba组件使用简单流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Nacos注册中心 SpringCloud Alibaba-Nacos:注册中心(服务发现/注册)
使用方法 ：
1、首先引用Nacos相关依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; 2、注册中心 （下载Nacos服务器文件、启动）
3、在properties文件里配置注册中心的地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 #将服务注册到注册中心 暴露服务的端口 ip 4、启动类 注解开启注册中心
@SpringBootApplication @EnableDiscoveryClient #开启注册中心 在Nacos可视化 界面 可以看到注册的服务名称（服务注册到服务中心）
二、Feign远程调用 SpringCloud- Feign:声明式HTTP客户端(调用远程服务)
简介:
远程调用别的服务 Feign是一个声明式的Http客户端，让远程调用更加简单。
Feign整合了Ribbon(负载均衡)和Hystrix（服务熔断）。 只需要创建一个接口并用注解的方式来配置，即可完成对服务提供方的接口绑定。
使用方法 ：
1、首先引用Feign相关依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、开启Feign 远程调用功能
@EnableFeignClients 3、编写一个接口 告诉SpringCloud 这个接口需要调用远程服务(一般来说写在调用者服务)
4、接口：@FeigClint(“需调用服务 注册中心的服务名”)
三、Nacos配置中心 SpringCloud Alibaba-Nacos:配置中心 使用流程: 1、引入依赖 Nacos Config Starter &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; 2、创建bootstrap.properties
spring.application.name=nacos-config-example #当前 应用的服务名称 spring.cloud.nacos.config.server-addr=127.0.0.1:8848 #配置中心的服务地址 3、给配置中心默认添加一个数据集 (DataId) 默认规则 应用名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82783e98e348742a509dcc8d4d2af8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df3f25d2f8b2826828080a2a06d2d1b8/" rel="bookmark">
			python import找不到so库的可能原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gen
在import一个so库里的类或函数时，有时发现so文件分明就在那路径下，可是总是报错ModuleNotFoundError: No module named ***，这种错误的可能原因有:
1.首先要确保so所在的路径已经包含在sys.path里了，如果so所在目录已经是在python默认的系统路径里，例如/usr/lib/python3.6/dist-packages/或者/usr/local/lib/python3.6/dist-packages/之下的任何层级的目录，不用做任何设置，如果是其他路径，可以通过设置PYTHONPATH或者程序里使用sys.path.insert()或sys.path.append()把路径添加到sys.path里来。
2.路径包含正确了，检查so库的命名的前缀和import是否不一致，这种so库的命名是有一定规则的，例如，Linux上一般是&lt;so_name&gt;.cpython-&lt;python-version&gt;-&lt;cpu-platform&gt;-linux-gnu.so，在import时指定的名字需要和&lt;so_name&gt;保持一致。
3.命名正确了，检查后面的后缀cpython-&lt;python-version&gt;-&lt;cpu-platform&gt;-linux-gnu.so是否在你当前使用的python版本的支持范围内，例如，你的so库是python3的，可你在误操作下在使用python2运行程序，或者你的so库是针对python3.5的(so后缀里的python-version=35m)，但你当前使用的是python3.6，也不行，所以如果不是在只安装了一种版本的python的环境里，运行python程序前，最好检查一下python版本是否是你所希望的，这个是在安装了多个版本的python的环境下或者升级了python版本后经常不经意下易犯的错误，有时还被坑浪费很多时间查找原因，除了so库分明在那里却总是报ModuleNotFoundError，还有其他七七八八奇怪的错误，查找原因最后发现是python版本用错了，气得血冲脑门。
怎么确认你当前使用的python版本支持哪些后缀的库能被import呢，很简单，执行下面的代码:
import importlib.machinery print(importlib.machinery.all_suffixes()) Windows下输出的示例：
Linux下输出的示例:
arm64 arch:
x86_64 arch:
4.路径存在冲突，so分明在某个已包含的目录下存在，没有其他的错误，可还总是报错ModuleNotFoundError，这种情况也是很坑人的，花费了很久时间想不出原因来，就是没想到可能路径上存在重名的冲突，例如，我第一次使用python代码调用mediapipe时出现报错ModuleNotFoundError: No module named 'mediapipe.python._framework_bindings'，其他什么错误原因都没发现，郁闷地熬夜，最后发现虽然/usr/local/lib/python3.6/site-packages/mediapipe/python/_framework_bindings.cpython-36m-x86_64-linux-gnu.so是存在的，但是在运行程序的工作目录下也有个使用过用来build出meaidpipe的wheel包的源码目录，由于当前工作目录加入了sys.path里最前面，于是python搜索路径时自然是优先找的/workspace/mediapipe/python/...，这个下面确实是没有那个so文件，于是把这里的mediapipe目录改名或者移走，问题就消失了。
5.最后，如果是自己实现的so库，要想能被python import，so库的内部实现按规范来。
例如，使用g++编译代码的话要必须使用extern "C"限制编译生成的名字不会被改变，对要import的函数需要以对应的initxxx()来命名(使用g++编译时会把函数名字增加前后缀导致函数名被改变，编译出来的so被python import 时，会报类似下面的错误
ImportError: dynamic module does not define init function (initmyModule) )，https://csl.name/post/c-functions-python/这里有个很简单好懂的例子(注意里面是使用gcc编译的，所以没有加extern "C"约束，另外对于这种so库的编译，除了加-shared参数，最好加上-fPIC参数以去掉位置依赖,更多规则可参考python文档，例如https://docs.python.org/3.6/extending/extending.html):
from myModule import *
#include &lt;Python.h&gt; /* * Function to be called from Python */ static PyObject* py_myFunction(PyObject* self, PyObject* args) { char *s = "Hello from C!"; return Py_BuildValue("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df3f25d2f8b2826828080a2a06d2d1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d1fd7f70482483fe2dd4c874edee1f/" rel="bookmark">
			手机拨出等待时间长_华为手机拨号键还有这么神奇的功效，现在才知道！真是涨知识了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到手机拨号键，你能够想到什么呢？我想大部分人想到的都是拨打电话，其实手机拨号键能做的事情多着呢！它能实现很多神奇的功效，现在知道也不晚。小伙伴们，话不多说，赶紧往下看吧！
今天以华为手机为例，向大家介绍一些拨号键的神奇功效。
1. 查询手机真假/翻新机
现在什么东西可能都有假的，为了以防万一。你想要查询手机真假、翻新机的话，可以在手机拨号键界面输入【*#06#】，查询出来后将IMEI1码和购买手机背面贴的进行对比，就能知道此手机的真假了。
2. 查看手机使用记录
在日常的生活中，我们可能想查询一部手机的使用情况，除了可以检查手机APP电量消耗来推测外，其实我们还可以直接输入这串代码进行查看。
方法：拨号界面输入【*#*#6130#*#*】，点击使用情况统计数据，就可以看到手机的使用情况了。
3. 给手机补电
有的小伙伴可能会有这方面的困扰，手机用久了电池却变得不耐用了。其实我们可以使用这串代码让电池焕发活力，给手机电池补一补电。
方法：拨号界面输入【*#*#2846579#*#*】，就会进入工程菜单界面，接着点击补电就可以了。
4. 快速拨号
快速拨号功能一定要给家里的老人小孩设置一下，这样也会省很多事情。万一发生个什么比较紧急的事情，可直接长按设置好的"快捷键"就能拨出给紧急联系人了。
方法：长按一个数字键，点击设置接着选择一个联系人，就设置成功了。
5. 玩机技巧
虽然华为手机的备忘录可以记录灵感，但如果有中英文互译的需求就难以实现。我们想要实现的话就只能依靠【录音转文字助手】这种工具了，不仅功能强大且能快速提高效率。
方法：去手机应用市场搜索"录音转文字助手"——打开工具——选择一个功能使用，就能轻松实现音频转文字、中英文翻译的效果了。
华为手机拨号键居然还有这么神奇的功效，现在才知道！真是涨知识了。小伙伴们，看了以上的所有利用拨号键就能实现的功能，是不是觉得很强大呢？感兴趣的小伙伴赶快去试试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220e360ea2d302921588c21fe7fc3355/" rel="bookmark">
			手机拨出等待时间长_华为手机一键拨号真好用，设置起来也方便，你还不知道吗？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小马，不给马儿吃草，还想让马儿跑。这里没有花里胡哨，只有最实用的手机功能分享，不求多少点赞，只愿以我所学所做为你所用，便是我最开心的事情啦。
言归正传，开始我们今天的分享：
相信不少人都有发现，身边的那谁谁谁怎么只在拨号盘按了一个数字就把电话打出去了？这是什么神技能？我的手机可以吗？怎么设置呢？
其实，这个就是快捷拨号，也就是一键拨号，下面我来跟大家分享下这个一键拨号是怎么设置的？下面我以华为手机为例为大家讲解下：
直接从手机的主界面点击拨号图标
进入到拨号盘的主界面
长按界面上除了“1”和“0”之外的其他数字，我们以“3”为例，长按后就出弹出设置快捷拨号的窗口如下图
我们点击确定，则会直接进入到选择联系人界面，如下图
然后我们点击某个需要添加的联系人，即可设置成功，界面返回到拨号界面并在拨号盘下方显示“已设置”
接着我们就可以直接使用一键拨号进行拨打电话了，当我们需要给该联系人拨打电话时，直接在拨号盘上，长按数字“3”即可将电话拨出，是不是很方便？
注：在设置一键拨号之前，需要先将要添加至一键拨号的联系人电话添加至手机通讯录中，方可进行一键拨号的设置。
在键盘上除了1/0两个数字外，其他的2/3/4/5/6/7/8/9等8个数字键均可以设置一键拨号。
今天的一键拨号/快速拨号内容就分享到这里，大家平时在使用手机中有什么基础功能方面的操作，有不懂的可以留言或私信，我得空为大家进行解答。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f670b32da0318354b82eddc08ca93227/" rel="bookmark">
			学习：博客资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select、poll、epoll之间的区别(搜狗面试)
https://www.cnblogs.com/aspirant/p/9166944.html
IO多路复用之select总结
https://www.cnblogs.com/Anker/p/3258674.html
O多路复用之poll总结
https://www.cnblogs.com/Anker/p/3261006.html
IO多路复用之epoll总结
https://www.cnblogs.com/Anker/p/3263780.html
【原创】分布式之数据库和缓存双写一致性方案解析
https://www.cnblogs.com/aspirant/p/9166944.html
Reactor模式详解
https://www.cnblogs.com/winner-0715/p/8733787.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c547365748de22d77de58eb93c939f/" rel="bookmark">
			群辉NAS&#43;KODI （二）----NAS文件配置&#43;电视安装kodi安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号：IT酱油瓶
作者：网工紫电
一个IT行业技术创业者
1
电视端安装kodi
1.下载地址：http://www.kodiplayer.cn/download/
选择一个版本下载即可。
2.设置kodi中文界面，这个步骤百度一下有很多，略。
3.若kodi里面没有简体中文选项，需要把电视连接网络，在线下载，在System选项下，选择Add-ons，再选择Running，再选择 Look and feel，再选择Languages，下载完字库，再重新设置中文字库。
2
NAS配置：
1.登录设备
2.新建RAID，我只有一块硬盘所以我选择Basic选项，若有多块硬盘可选择其他RAID
3.新建存储空间，如下图，我的是已经建完，再截的图。
4.新建共享文件夹
可根据是否加密选择加密，下一步完成
5.新建完成后即可以在左侧看到共享文件夹，下一步在共享文件夹下新建目录即可。
6.创建用户
然后一直点下一步完成。
注意开启smb服务和设置
3
电视端kodi连接NAS：
打开kodi，选择添加添加视频
点击浏览
选择smb的选项
找到workgroup，然后找到视频目录确定即可。
至此 我们可以将以前保存的或者网上下载的电影电视剧放到NAS上，用电视调用播放了，速度很快不会卡顿。
附QQ资料群：
扫码关注我们
今天因为你的分享，让我元气满满！
因为你的分享、点赞、在看
我足足的精气神儿！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e26f73a89a5ffd4dcba9273c652139/" rel="bookmark">
			爬虫实战7：豆瓣影视爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、页面解析二、代码展示 1.引入库2.主要代码展示总结 前言 一、页面解析 第一步：本次爬取的内容是豆瓣下电影标签，涉及到的热门主要如下所示，爬取的字段主要有：
['电影名','评分','上映时间','导演','编剧','演员1','演员2','演员3','演员4','演员5','类型1','类型2'] 第二步：对页面解析，得出使用哪个解析工具比较方便，对字段进行处理，右键检查元素
二、代码展示
1.引入库 import requests import json import csv import time from lxml import etree 2.代码书写 1、对动态加载的链接进行分析，可以发现，只有page_start在发生变化，变化的规律是0*20，可以构造链接对数据进行爬取
https://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0
https://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=20
def get_parse(result): items = result['subjects'] for it in items: id = it['id'] # 电影名称 movie = it['title'] # 评分 pingfen = it['rate'] # 链接 link = it['url'] data = [id, movie, pingfen, link] get_content(movie,pingfen,link) time.sleep(1) # print(data) 2、对详情页进行爬取，其中涉及到的字段比较多，每个国家的电影的字段没有规律，没有获取全部字段，只爬取了导演，编辑，主演，类型，播放时间等字段
def get_content(movie,pingfen,link): D=[] res = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e26f73a89a5ffd4dcba9273c652139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4fbbbecdee2959a95ac26d0cb8e9e5/" rel="bookmark">
			echarts y轴四等分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 let optionWago = { xAxis: { data: this.wagon.XPosition, }, yAxis: { minInterval: 1,//坐标轴是整数 max:eval(`Math.max(${this.wagon.curveDatas})`)+3//数据最大值加3 }, series: [ { data: this.wagon.curveDatas, }, ], }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2dc4bb96880777f395d7a381c1a25e/" rel="bookmark">
			web 打印条码 有虚线_条码打印机走纸不准怎么办？解决办法都在这了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近经常接到客户反映条码打印机走纸不准，每次都是走一张半，或者打一张空一张，还有客户反映打印后的撕纸位置不对，这就是条码打印机的校准或者是打印模式出了问题，遇到这种情况我们该怎么解决呢，砹石科技给大家做了个简单的总结：
1、请先确定纸张和碳带是否装好?
一般在打印机的内部都有实线和虚线的标注，分别代表了标签的色带的走纸通道，如果出现走纸不准首先确定一下耗材的安装有无问题
2、确定介质类型和打印模式是否正确
条码打印机的打印介质分为连续纸和不连续纸两种类型，如果设置为连续纸类型，打印机是不识别纸张位置的，可以进入打印机
或者驱动查看相应设置，打印模式则分为回卷Rewind、撕纸Tear off、剥离Peel off、切刀Cutter等模式，最常用的是撕纸模式Tear off，
如果设置为剥离模式会造成打印之后回退的现象造成撕下位置不对，同样可以在驱动和打印机之中做确认，优先确认驱动，因为一般
驱动设置是会覆盖打印机的设置的。如果是打印方式不对，比如热转印选择成了热敏是不会影响打印机找纸的，只是在打印过程中可能会
报错，所以您在使用过程中注意区分。
2、检查纸张感应器是否调在纸的宽度范围内(吊牌纸请调在洞上纸边)。
如果您是桌面机的话感应器一般都是固定的，如果您是打孔耗材请确认耗材绕向有无问题，确认一下孔的位置和耗材留孔位置
是否对的上，如果您是台式机的话稍微复杂一点，以斑马105sl PLUS为例，感应器为上下一对，您需要确认感应器在纸张范围内
，而且上下正对，有些纸张比较窄有可能避开了感应通道，需要您手动移动一下感应器的位置，上下反射式感应器，所以需要上下
位置一致。
3、检查感应器是否被纸粘到或有脏东西。如果有请将纸张清掉或拿吹气球或者小毛刷清理感应器。
4、查看页面设置的标签长度是否与实际纸张相同。如果设置不同也会造成条码打印机走纸不准的情况
5、感应器灵敏度调整
如果上述几种方法都不能解决的话，可以尝试一下手动校准，具体操作步骤请查看相应机器的用户手册
如果以上几种方法还不能排除故障极有可能是硬件出了问题，这边建议您联系您的采购商做保处理
如果您有标签需求或者您在标签使用过程中有任何问题，都可以随时联系我们，会有专人为您答疑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8590719b004e63a37a7877aac67c8d16/" rel="bookmark">
			pythonfor循环文件写入失败_Python文件循环写入行时防止覆盖的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存在问题：
利用写入代码
with open(r'F:PythonFilesPycharmFilessq.csv', 'w', encoding='utf-8-sig', newline='') as csvFile:
csv.writer(csvFile).writerow([col1,col2,col3,col4,col5,col6,col7,col8,col9,col10,col11]) # 给csv文件中插入一行
向CSV文件中循环写入行时，后面的数据总是把前面的数据覆盖掉
解决方案：
将写入属性“w”改为属性“a”，表示循环写入
with open(r'F:PythonFilesPycharmFilessq.csv', 'a', encoding='utf-8-sig', newline='') as csvFile:
csv.writer(csvFile).writerow([col1,col2,col3,col4,col5,col6,col7,col8,col9,col10,col11]) # 给csv文件中插入一行
以上这篇Python文件循环写入行时防止覆盖的解决方法就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持软件开发网。
您可能感兴趣的文章:Python创建文件和追加文件内容实例Python文件操作,open读写文件,追加文本内容实例python覆盖写入,追加写入的实例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c9fc02821bb34c9bb6425da2806998/" rel="bookmark">
			Python爬虫爬取HTML文件没有显示图片的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析 网页上图片的网址与书苑的网址是不一样的，我们使用request.get()只是单纯爬取了书苑网址，但是图片的网址还需要另外打开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b328b2ba8a94dbc928f45349c74c2e/" rel="bookmark">
			从硬件到软件玩转Nordic nRF52840 低功耗蓝牙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电路板设计 nRF52840在数据手册中给出了几种不同供电方案下的参考电路，其外围电路相对简单。对个人而言，开发过程中尽可能的降低成本，简化电路，在业余时间中完成快速开发。
考虑到元器件购买数量较小的情况下，其最小系统成本大约30元，然而nRF52840的封装需要开钢网，增加成本和焊接难度。因此，在某宝找了一个很便宜的模组，约30多一些吧，感觉挺划算的，其电路如图：
从商品描述中可以看到实物的尺寸和预留的引脚如下：
上述两张图为商品描述，暂不添加链接，避免广告嫌疑。如有侵权，请及时相告。
到此为止，主芯片已经搞定，接下来是芯片的供电方式，避免额外使用稳压器，直接从USB供电，同时，将芯片VDD作为输出电压，预留一些测试IO口即为原理图方案，绘制PCB如图：
将模组正下方开槽，露出模组底下焊盘，输出gerber文件。打板回来的板子如图所示，测试电源地是否短路，测试开槽孔的连接性是否完好，接下来完成焊接。
至此，焊接好的电路板如图所示：
确认好电路板焊接无误后接上USB线，测试nRF52840的电源输出正确。
开发环境准备 工具名称开发环境Keil 523PacknRF_DeviceFamilyPack.8.35.0.packSDKnRF5SDK160098a08e2.zipJlink驱动V630AppnRF Connect SDK 下载地址
Jlink驱动 下载地址
从点灯开始 打开nordic提供的例程，nRF5SDK160098a08e2\examples\peripheral\blinky\pca10056\blank\arm5_no_packs，发现找不到相应的pack，幸好发现网上有同样的问题，解决方法参考CSDN文章《nRF52840（一） 环境搭建》。在pca10056.h中修改例程中对应LED的引脚位置，编译工程。
该工程中不存在协议栈，直接下载程序，下载后装上LED灯，可以看到LED闪烁。
直奔串口蓝牙 打开nordic提供的例程，
nRF5SDK160098a08e2\examples\ble_peripheral\ble_app_uart\pca10056\s140\arm5_no_packs，先下载协议栈，然后下载应用程序，终于到了见证奇迹的时刻，打开nRF connect开始搜索附近的蓝牙，该例程中的蓝牙名称始终没有出现，从此开始了查找bug之路。
借助CSDN中的一些文章，总算拨开云雾见青天。现总结一下，在调试的过程中，主要是由于官网例程与硬件结合紧密，在初始化时会进行相关检查，程序容易出现APP_CHECK_ERROR，所以针对当前硬件电路板，去掉不相关的LED和BUTTON初始化，配置好串口，另外协议栈始采用外部晶振，需要设置为内部RC时钟。
再次打开搜索蓝牙设备，Nordic_UART出现了，终于看见了曙光。
做一些简单的测试，在手机端发送字符串如图：
在串口助手中可以接收到手机端发送的数据。
在这里感谢CSDN中一些介绍蓝牙串口的相关文章，才得以实现本DIY。
化繁为简 该蓝牙DIY要应用在实际中时，为避免冗余，将去除串口和按键功能，该项工作需要以下操作：
去除下列5个文件不做编译
nrf_drv_uart.c
nrfx_uart.c
nrfx_uarte.c
app_uart_fifo.c
retarget.c注释main.c中串口按键相关代码
nus_data_handler函数中串口发送代码
uart_event_handle函数定义
uart_init函数定义
main函数中uart_init和printf设置sdk_config.h中宏定义
将nRF_Libraries中串口相关宏定义置位0设置boards.h中宏定义
设置BSP_INIT_BUTTONS为0 经上述修改，可以保留源代码中的4个LED指示灯，这里可以通过蓝牙发送控制命令点亮或者熄灭LED灯。
上图为即将完成的蓝牙控制跑马灯。
nRF52840驱动0.96寸OLED 在nRF52840蓝牙实现了LED灯的状态之后，可以说该DIY没有什么大的毛病，接下来就是根据兴趣实现一些想实现的东西。
闲暇之余，不经意间发现了之前用过的OLED显示屏，于是有一种点亮它的冲动。该OLED模块出厂默认配置为并行通信方式，考虑到该DIY模块预留的IO数量有限，接线困难，在这里通过修改电路板上BS1和BS2的为低电平，设置为SPI通信方式。
其实不管是SPI还是并行通信方式，字符和图片的显示代码是一致的，仅仅是底层驱动方式不一样。网上基于STM32和51单片机的代码很多，可参考CSDN文章《OLED驱动 0.96寸 模拟SPI驱动（STM32）》。
除了可以显示最近本的字符之外，还可以通过Img2LCD软件和取字模软件实现图片和汉字的显示，相关操作也很多。
上图为OLED显示效果，其中显示了年份、月份和二维码图片。个人通过手机蓝牙发送自己的姓名之后，在OLED上即可显示自己的毕业年份和简单的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b385613eea695d655d65e3e2a47530/" rel="bookmark">
			定时切换图片的bat代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定时切换图片的bat代码 只支持同类型文件, 有数字规律的同一个文件下的图片
@echo off ::循环的内容 :loop ::图片的名称要有规律 set /a a = 1 + %random% %%(32) echo 当前图片名称 %a% ::按规律设置指定文件 reg add "hkcu\control panel\desktop" /v Wallpaper /d "C:\Users\SD\Desktop\壁纸\%a%.jpg" /f reg add "hkcu\control panel\desktop" /v WallpaperStyle /t REG_DWORD /d 2 /f RunDll32.exe USER32.DLL,UpdatePerUserSystemParameters ::10分钟一换, 单位s timeout 600 &gt; nul goto loop exit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9164d6a4f9f2e362b89a67f36bc520e/" rel="bookmark">
			pytorch——冻结某层参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：
https://blog.csdn.net/qq_41368074/article/details/107860126
https://blog.csdn.net/Code_Mart/article/details/88254444
首先，我们知道，深度学习网络中的参数是通过计算梯度，在反向传播进行更新的，从而能得到一个优秀的参数，但是有的时候，我们想固定其中的某些层的参数不参与反向传播。比如说，进行微调时，我们想固定已经加载预训练模型的参数部分，指向更新最后一层的分类器，这时应该怎么做呢。
方法一 首先我们的模型定义为：
class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d() self.conv2 = nn.Conv2d() self.fc1 = nn.Squential( nn.Linear(), nn.Linear(), ReLU(inplace=True), ) self.classifier = nn.Linear() 我们通过设置参数param的requires_grad属性为False，来冻结该层参数。我们可以定义如下函数：
def freeze(layer): for child in layer.children(): for param in child.parameters(): param.requires_grad = False 这里的layer，即为我们需要冻结的某层。如果我们要冻结fc1层，则： class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d() self.conv2 = nn.Conv2d() self.fc1 = nn.Squential( nn.Linear(), nn.Linear(), ReLU(inplace=True), ) freeze(self.fc1)######### self.classifier = nn.Linear() 当然这样还不够，我们要在定义优化器的时候，告诉优化器，哪些需要更新，那些不需要，这一步至关重要，即：
optimizer.SGD(filter(lambda p: p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9164d6a4f9f2e362b89a67f36bc520e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e4e821dd8dd3298300115d867ebb000/" rel="bookmark">
			stm32烧录软件_stm32怎么烧录程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32烧录程序目前笔者知道的有三种：JLink ，Ulink和串口烧录，使用工具分别为：JLink，ULink以及USB转TTL线。
ULink 烧录程序
在安装MDK过程中，会有提示是否安装驱动，该驱动就为ULink驱动，如果选择是就不需要再安装驱动了，否则就需要自己手动下载驱动并安装，驱动安装完毕之后我们需要告诉我们的MDK我们使用的是什么烧录工具，右键Target目录选择Options for Target…。。，在弹出的Options for target 选项卡中选择Debug选项，在其右上方的下拉框中选择ULink/ME Cortex Debugger 即是选择了ULink进行程序烧录。
这里需要注意的是ULink接上电脑之后不一定能被安装的MDK正确识别，我们点击下拉框右边的Setting按钮将会弹出Cortex-M Target Driver Setup界面，在该界面下，如果在JTAG Device Chain区域显示No ULink Device Found 或者就是一片空白都表示我们的MDK没有识别到你已经接到电脑上的ULink，此时就需要你查找一下ULink端的原因了。
JLink 烧录程序
JLink驱动并没有集成在MDK安装程序中所以一定需要我们手动下载Jlink驱动并安装，驱动安装完毕之后我们需要告诉我们的MDK我们使用的是什么烧录工具，右键Target目录选择Options for Target…。。，在弹出的Options for target 选项卡中选择Debug选项，在其右上方的下拉框中选择JLink/J-TRACE Cortex 即是选择了JLink进行程序烧录。
同样的，需要注意的是JLink接上电脑之后不一定能被安装的MDK正确识别，我们点击下拉框右边的Setting按钮将会弹出Cortex JLink/JTrace Target Driver Setup界面，在该界面下，如果在JTAG Device Chain区域显示Cannot redad JLink version number 或者就是一片空白都表示我们的MDK没有识别到你已经接到电脑上的JLink，如果右边J-Link / J-Trace Adaper下方的ort下拉框可选，选择成为另外一个试试(原本JTAG选为SWD，原本SWD选为JTAG)，如果可以识别就代表可以进行程序烧录了。
串口烧录程序
我们使用串口烧录程序，使用USB转TTL线，USB转TTL驱动根据我们内部的转换芯片安装相应的驱动，常见的有一下几种：CH340，PL2303，FTDI，CP210x等，驱动完成之后，右键Target目录选择Options for Target…。。，在弹出的Options for target 选项卡中选择Output选项，勾选上Create Hex File复选框，这样我们在编译代码时，便会在工程目录下生成Hex文件，我们串口烧录程序其实就是使用外部工具将该Hex文件中的内容，烧录到STM32 FLASH中去。需要使用到的烧录软件可以使用JLink 官方提供的串口烧录软件，也可以使用mcuisp USB一键下载工具也叫作FlyMcu进行烧录。
使用FlyMCU时，首先需要指定软件使用的串口号和波特率，在进行程序烧录之前必须设置我们STM32的烧录模式，需要将STM32 BOOT0设置为高电平，BOOT1设置为低电平，然后复位STM32，在FlyMcu中首先选择好要下载的HEX文件(编译生成的HEX文件在工程目录下生成)，然后选择STMISP选项卡，点击开始编程按钮，便可以进行程序烧录了。
为了方便大家更好的学习，畅学电子网特别增加了针对单片机和EDA的公众号，每天推送相关知识，希望能对你的学习有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778aa0f8d9f175add724c2347cb3434f/" rel="bookmark">
			DDD下的目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e1c31a0bfbb895daf82025b1ab07859/" rel="bookmark">
			python怎么建立矩阵的方法_如何创建一个3x3矩阵并填充它
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有多种方法可以解决这个问题。正如评论中所提到的，你要做的是让每一个组合都装满9个空桶中的3个。然后将这些存储桶表示为一个矩阵，然后就只需要改变存储桶的存储方式。你可以很容易地创建矩阵from itertools import permutations
import numpy as np
# Gets all possible combinations of non-zero indices
non_zero_index_sets = permutations(range(9), 3)
# Turn these sets of 3 non-zero indices into length 9 vectors just containing
# zeros and ones, e.g. [2, 7, 8] becomes [0, 0, 1, 0, 0, 0, 0, 1, 1]
vectors = []
for non_zero_set in non_zero_index_sets:
vector = np.zeros(9)
vector[list(non_zero_set)] = 1
vectors.append(vector)
# Turn each length-nine vector into a 3x3 matrix, e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e1c31a0bfbb895daf82025b1ab07859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e6c1e9ea1d323ce25e8e70a1c5c8ef/" rel="bookmark">
			Android 腾讯 Matrix 原理分析（一）：Matrix 概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 近期开始 Android Framework 层的学习，然而较为庞大的 Framework 让人感觉无从下手。碰巧看到一篇文章说到腾讯的 性能监控框架 Matrix 用到了大量 Framework 相关的知识，所以试着分析下该框架的源码实现。
在学习大佬们代码的同时主要关注该框架用到了哪些、是怎么使用的 Framework 的内容。
文章目录 写在前面一、Matrix 简介官方说明Matrix for Android 二、使用 Matrix三、Matrix 结构初始化插件 PluginMatrix 构造器AppActiveMatrixDelegateController Issue总结 一、Matrix 简介 官方说明 Matrix 是一款微信研发并日常使用的应用性能接入框架，支持iOS, macOS和Android。 Matrix 通过接入各种性能监控方案，对性能监控项的异常数据进行采集和分析，输出相应的问题分析、定位与优化建议，从而帮助开发者开发出更高质量的应用。
大公司就是大气，直接双端都给你整一套。
Matrix 地址
Matrix for Android Matrix-android 当前监控范围包括：应用安装包大小，帧率变化，启动耗时，卡顿，慢方法，SQLite 操作优化，文件读写，内存泄漏等等。
APK Checker: 针对 APK 安装包的分析检测工具，根据一系列设定好的规则，检测 APK 是否存在特定的问题，并输出较为详细的检测结果报告，用于分析排查问题以及版本追踪Resource Canary: 基于 WeakReference 的特性和 Square Haha 库开发的 Activity 泄漏和 Bitmap 重复创建检测工具Trace Canary: 监控界面流畅性、启动耗时、页面切换耗时、慢函数及卡顿等问题SQLite Lint: 按官方最佳实践自动化检测 SQLite 语句的使用质量IO Canary: 检测文件 IO 问题，包括：文件 IO 监控和 Closeable Leak 监控 好家伙，功能还真不少。看样子是个大工程，排个计划吧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e6c1e9ea1d323ce25e8e70a1c5c8ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784ecafdef50b72642aa5ac40c1b3d85/" rel="bookmark">
			一道单调栈的题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一道单调栈的题目 背景思路 背景 今天偶然遇到一道单调栈的题目，顺便复习下闲置已久的算法知识，题目的意思大致就是给你一个区间，找到子段和&gt;=K的一个最小子段。
思路 子段问题的关键是前缀和，先求一下
int sum[50005]={0}; for(int i=0;i&lt;len;i++) sum[i+1] = sum[i] + A[i]; 紧接着，关键就是维持一个单调栈，下面解释一下什么是单调栈，先给一段代码
deque&lt;int&gt; dq; //双端队列数据结构 for(int i=0;i&lt;=len;i++){ while(!dq.empty() &amp;&amp; sum[i]&lt;=sum[dq.back()]){ //当前前缀小于 dq.pop_back(); } dq.push_back(i); } 举个例子 [1,3,-4,5,-7] 前缀和[1,4,0,5,-2]
单调栈遍历过程中变化(记录下标）
i=0: 0
i=1: 单调上升 push 1，deque中为0,1
i=2: 不单调了，重新来 pop掉0和1，push 2 即deque中的数为下标2
i=3: 单调，push 3，deque中为2，3
i=4:不单调，pop掉2，3，push进4，即deque中为4
基于单调栈，如何找到子段和&gt;=K的一个最小子段呢，如下所示：
class Solution { public: int shortestSubarray(vector&lt;int&gt;&amp; A, int K) { int len = A.size(); int sum[50005]={0}; // sum[0]=A[0]; for(int i=0;i&lt;len;i++) sum[i+1] = sum[i] + A[i]; deque&lt;int&gt; dq; int ans = len+1; for(int i=0;i&lt;=len;i++){ while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/784ecafdef50b72642aa5ac40c1b3d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9fcfab95e0e915deea4c6b9f48ca18/" rel="bookmark">
			计算机视觉python pdf_《深度学习实践：计算机视觉》PDF&#43;缪鹏分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《深度学习实践:计算机视觉》主要介绍了深度学习在计算机视觉方面的应用及工程实践，以Python 3为
开发语言，并结合当前主流的深度学习框架进行实例展示。主要内容包括：OpenCV入门、深度学习框架
介绍、图像分类、目标检测与识别、图像分割、图像搜索以及图像生成等，涉及到的深度学习框架包括
PyTorch、TensorFlow、Keras、Chainer、MXNet等。通过本书，读者能够了解深度学习在计算机视觉各个
方向的应用以及新进展。
《深度学习实践:计算机视觉》主要关注计算机视觉领域，基于开源项目介绍最新的算法：
第1章对深度学习与计算机视觉进行简要介绍，也会简单介绍开发环境的搭建。
第2章主要介绍OpenCV的基本操作及部分高级操作，包括人脸和人眼的检测与识别。
学习参考：
《深度学习实践:计算机视觉》PDF，255页，带书签目录，彩色配图，文字可以复制，缪鹏 著。
下载地址：
链接: https://pan.baidu.com/s/1mrZ7dUv97eKsNC2Cs5_RDQ 提取码: y8m3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c29be9e8e0088c7a2a2dfb8879dfc9/" rel="bookmark">
			python epoll多路复用技术_python：多路复用＋零拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为通信模块目前比较热的2个词：零拷贝，多路复用，都是性能提升较多的词，发送方利用零拷贝技术减少内存拷贝的时空开销，提升性能，接收方利用I/O多路复用技术，加速数据接受。
零拷贝
一种高效的数据传输机制，在追求低延迟的传输场景中十分常用。同样零拷贝由于数据不再进入用户空间，直接从kernel层进行处理，故在拷贝时，需要连续处理，不能中断，同时传输的数据无法修改。
零拷贝技术主要应用在文件发送环节，在kafka、Spark、Netty等高性能组件中均有使用。以下通过数据拷贝、上下文切换、时序图进行差异化比对，从标准化通信到零拷贝Block DMA，再到Scatter/Gather，数据拷贝次数不断减少，上下文切换也不断减少，随着文件增大，性能差异越来越明显，对于CPU和IO的消耗都是成倍减少。
kafka大吞吐低性能的首选队列，内含分区并行、ISR机制、顺序写入、页缓存等机制。kafka消息设计海量数据的读写，通过零拷贝能显著降低延迟，提供性能和效率。利用java NIO API中FileChannel.transferTo()方法，实现缓存数据的零拷贝。
spark在进行内存计算时，常用零拷贝来处理溢写， Shuffle过程中的溢写逻辑。由于Shuffle过程涉及大量的数据交换，因此效率当然是越高越好。零拷贝来快速合并溢写文件的分片，有一个专门的配置项来控制是否启用零拷贝(默认当然是true)
Netty提供了零拷贝的buffer，在传输数据时，最终处理的数据会需要对单个传输的报文，进行组合和拆分，Nio原生的ByteBuffer无法做到，netty通过提供的Composite(组合)和Slice(拆分)两种buffer来实现零拷贝。Netty的接收和发送ByteBuffer使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。如图：
不同的操纵系统对内核缓冲区到Socket缓冲区的复制操作，多有不同，linux中为sendfile()，java中主要通过fileChannel.transferTo完成。
RocketMQ采用零拷贝mmap+write的方式。
ps：关于sendfile与mmap+write差异及原理，参考https://zhuanlan.zhihu.
com/p/88789697。
I/O多路复用
IO多路复用：句柄描述符发生变化后，通知进程进行处理，通过回调实现进程的多路复用。多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。目前支持I/O多路复用的系统调用有 select，pselect，poll，epoll，I/O多路复用就是监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
select
select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。由于可提升扫描上限，轮询线性扫描性能较低，数据结构传递时开销太大。不建议应用于大并发操作。
poll
poll本质上和select没有区别，链式结构，无最大连接数限制，遍历文件描述符状态获取socket，拷贝内核等待就绪，若存在就绪资源较少时，大量请求时，内核数组会变得很大，性能会线性下降。
ps：select和poll都是轮询方式，最大的连接数有限制，都有等待拷贝到内核的开销，等待资源过多时，效率线性下降。
epoll
相对于select和poll来说，epoll更加灵活，没有描述符限制，就绪状态触发回调，同时使用mmap的零拷贝。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。回调模式，在就绪状态大量情况下，大量回调可能存在性能问题。
最终选择，在连接少、或越多情况下，select和poll的性能比epoll好，epoll回调触发较多。连接较少的情况下，适合poll，大量的情况下还是epoll好。
oup实践
oup方案中的oup-flask公共模块部分，为对select、poll、epoll及多线程、多进程均作为高复用模块，固化。关于o_server.py，分享出来：
https://kdocs.cn/l/cg4T0assBHFk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193ef21005bcf7b72e8be3d8ed206cec/" rel="bookmark">
			text生成pdf之ctex&amp;winedit&amp;miktex&amp;gbk2uni的安装使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为工作原因，需要将.tex文件转成pdf文档。于是进行了winedit及ctex文件安装，但发现走了一些弯路。为了避免再有同行走相同的弯路，于是我将相关的经验写下来，供大家参考。
一：误区
从www.winedt.com网站上下载winedt安装。这个安装后不携带ctex可执行文件。从winedt官网上携带的ctex链接下载软件后，是用的在线安装，安装速度特别慢，安装30分钟后，刚完成1/10的进度。
二：正道
1：从国内镜像下载离线完整版本
从http://www.ctex.org/CTeXDownload/上面下载CTex2.9.3版本，我是从清华TUNA镜像上下载的。用迅雷下载不到10分钟就下载完毕，然后用3分钟左右时间安装完毕。
安装完成后，winedit和ctex和mitex工具都具备了。
2.安装gbk2uni
这是由cxterm/张林波/hooklee共同开发的支持GBK中文pdf书签的小工具，下载地址是：http://www.hooklee.com/tex/gbk2uni.zip（若CTeX系统已经集成此工具可以不用下载）。
3.配置
配置Path环境变量，将ctex执行程序的目录增加到此环境变量中。
4.生成pdf步骤
用winedt打开tex文件，在console窗口中选择“Command Prompt”按钮
按以下步骤执行，中间若有执行不下去的地方且不是严重语法问题可输入r并回车，【main】指tex文件名，不带后缀。
编译过程1：
pdflatex main
gbk2uni main
pdflatex main
或
编译过程2：
latex main
gbk2uni main
latex main
dvipdfm main
TIPS:
我在使用winedit时发现提示要注册，从下面的博客上看到了一个破解方法，以供参考。
https://blog.csdn.net/weixin_30793735/article/details/81234823
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88de115d17420eebd43b6677f9c5fe38/" rel="bookmark">
			知晓当前是在哪一个 Activity  Kotlin.Android
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知晓当前是在哪一个 Activity open class BaseActiviyt :AppCompatActivity(){ override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d("获取当前实例的Class对象",javaClass.simpleName) } } 不管是哪个类继承了这个类打印的就是当前这个类
这里我创建了三个Activity分别都继承了BaseActivity这个类
主活动自己创建里面只有按钮 注意都不要继承AppCompatActivity这个父类，因为BaseActivity这个类已经继承
运行程序主活动FirstActivity点击按钮进入SeconfActivity在点击按钮进入ThirdActivity
我们看打印结果: 只要进入哪个Activity就会打印出该Activity的类名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5290c67e5fb34daf30f82cee8ae7ef3/" rel="bookmark">
			1136 字符串替换(语言入门)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字符串替换(语言入门) 1.描述 编写一个程序实现将字符串中的所有"you"替换成"we"
输入
输入包含多行数据
每行数据是一个字符串，长度不超过1000
输出
对于输入的每一行，输出替换后的字符串
样例输入
you are what you do
样例输出
we are what we do
2.代码 #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; int main() { char a[1001]; int i,x,s,j; gets(a); x=strlen(a); for(i=0; i&lt;x; i++) { if(a[i]=='y'&amp;&amp;a[i+1]=='o'&amp;&amp;a[i+2]=='u') { a[i]='w'; a[i+1]='e'; a[i+2]=2; } } for(i=0; i&lt;x; i++) { if(a[i]==2) { continue; } printf("%c",a[i]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8acc8affec122654b154067dc253a81d/" rel="bookmark">
			Centos8.2环境下docker安装配置Kafka和zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos8.2环境下docker安装配置Kafka和zookeeper 1.下载kafka和Zookeeper镜像 docker pull wurstmeister/kafka docker pull wurstmeister/zookeeper 2.查看镜像 [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE wurstmeister/kafka latest 40094a582680 3 months ago 435MB wurstmeister/zookeeper latest 3f43f72cb283 22 months ago 510MB 3.运行zookeeper docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper ## 4.运行kafka ``docker run --name kafka \ -p 9092:9092 \ -e KAFKA_BROKER_ID=0 \ -e KAFKA_ZOOKEEPER_CONNECT=192.168.200.129:2181 \ -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.200.129:9092 \ -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \ -d wurstmeister/kafka ## 5.查看容器状态 ```java [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b18d4e2c2f7 wurstmeister/kafka "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8acc8affec122654b154067dc253a81d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef2dc119048ec15643dbfb95b5c15e32/" rel="bookmark">
			解决Ubuntu检测到系统程序出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次开机都会提示系统程序出现问题，但是报告问题也依旧会跳出来，干脆直接禁用Apport，方法如下：
sudo su #切换root用户 sudo gedit /etc/default/apport 把里面的enabled=1改成enabled=0 Ubuntu发生了一个内部错误是个Apport（LCTT 译注：Apport是Ubuntu中错误信息的收集报告系统，详见Ubuntu Wiki中的Apport篇），它将会进一步的打开网页浏览器，然后你可以通过登录或创建Launchpad帐户来填写一份漏洞（Bug)报告文件。除非你愿意填写错误报告（填写了其实不一定有用），我建议直接禁用Apport，之后系统中任何程序错误也不会再弹窗提示你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3fed532d5821b69b9c32fe1db43a57/" rel="bookmark">
			汇编语言sub指令用法_汇编语言（Assembler Language）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试着记住下面这些字符串：“ADD 1，2”、“SUB 1，2”、“1011011000000000”、“1011010100000000”，你先记住了谁？显然是前面两个。它们就是汇编语言的加法和减法语句。由于以二进制编码产生的机器语言既难懂又难记，人们为了便于阅读记忆，就将原来的机器代码以英文字符串的形式来表示，这就是汇编语言。例如用汇编语言“ADD 1，2”中的“ADD”代表机器语言“1011011000000000”，表示要求计算机做一次加法；用汇编语言“SUB 1，2”中的“SUB”代表机器语言“1011010100000000”，表示要求计算机做一次减法等等。比起那两串长长的二进制代码，“ADD”和“SUB”是不是简单好记得多？
​
汇编语言的出现大大方便了程序员的程序编写和记忆，使计算机语言的发展向前迈进了一大步。但实际上，汇编语言仍然是一种低级语言，仍然是面向机器硬件的程序设计语言。不过也正因为如此，汇编语言今天仍被广泛用于编写面向机器硬件的实时控制程序和系统程序。例如机器自检、系统初始化、实际的输入和输出设备的操作等等。
​
机器语言
机器语言是最早的计算机语言，也是计算机唯一可以识别和接受的语言。谈到机器语言，我们就不得不再一次谈到“指令”。在第三章中我们曾讲过什么是指令，这里，我们要说的是指令与机器语言的关系。
​
同军舰上的旗语一样，人们在设计某一类型计算机的同时也为它设计了一套“旗语”——“指令系统”。指令系统就是一台计算机所能执行的全部指令。在指令系统中，人们事先规定好了某一个二进制代码代表的是哪一种操作。例如在16位机上，人们规定：用1011011000000000作为一条加法指令，计算机在接收到此指令后就执行一次加法，用1011010100000000作为减法指令，命令计算机去执行一次减法等等。16个“0”和“1”的排列组合可以形成65 536条指令，这些指令通过一定的逻辑电路转换为不同的电信号，就可以“指挥”计算机执行各种不同的操作了。这种由“0”和“1”组成的指令，就叫做“机器指令”。一种计算机系统的全部机器指令的集合就称为该计算机的“机器语言”。瞧，我们很轻易地就搞清了指令与机器语言的关系。
​
实际上，机器语言就是用二进制代码编写的、机器能够直接识别的指令。机器语言看上去仍然既抽象又乏味，在计算机技术发展的初期，它曾使早期的程序员苦不堪言，而今天的程序员对待它的态度也是——敬而远之。
重要的信息：机器语言是计算机唯一可识别和接受的语言。“我自己是一名从事了10年的老程序员，辞职目前在做讲师，今年年初我花了一个月整理了一份最适合2018年学习的c++干货，从最基础的到深入的都有整理，送给每一位编程小伙伴，这里是小白聚集地，欢迎初学和进阶中的小伙伴。"加企鹅群：648778840(招募中)
学习思路：
学习资料：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a4d5ae02a2d41e8f2d59b09ade6394/" rel="bookmark">
			计算机专业大学排名_计算机专业大学排名公布：大连大学、辽宁师范大学冲进前一百...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1】国内大学排名重新“洗牌”，清华北大无缘榜首，“山东大学、四川大学、吉林大学”完美逆袭。
【2】计算机专业大学排名公布：大连大学、辽宁师范大学冲进前一百。
【3】武汉理工大学和华中农业大学这两所高校属于实力强劲的211高校，均有全国排名第一的学科，备受20届考生青睐。
专业科普 水产养殖学
水产养殖学专业培养具备水产动、植物增养殖科学等方面的基本理论、基本知识和基本技能，能在水产养殖生产、教育、科研和管理等部门从事科学研究、教学、水产养殖开发、管理等工作的高级科学技术人才。
就业前景：毕业生可以到大专院校、各级水产研究、生产开发和管理以及水产环保、外贸海关等部门。
院校解读 大连海洋大学
大连海洋大学是国家首批卓越农林人才教育培养计划改革试点高校、辽宁省一流大学重点建设高校，学校原为农业部直属的四所水产类高等院校之一，是一所以海洋和水产学科为特色的高等院校。
优势专业：水产养殖、水生生物学、港口航道与海岸工程
综合排名：第345名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000c66f7fbb9e2bb7dbd07fad200a473/" rel="bookmark">
			编写函数，逆置字符数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逆置字符数组 逆置字符数组非递归函数体：具体实现： 递归函数体具体实现： 逆置字符数组 编写一个函数 reverse_string(char * string)（递归实现）
实现：将参数字符串中的字符反向排列。
要求：不能使用C函数库中的字符串操作函数。
非递归 函数体： 该函数的主要思路：
逆置字符串，循环的方式实现非常简单
给两个指针，left放在字符串左侧，right放在最后一个有效字符位置交换两个指针位置上的字符left指针往后走，right指针往前走，只要两个指针没有相遇，继续2，两个指针相遇后，逆置结束 void reverse_string1(char* arr) { char *left = arr; char *right = arr + strlen(arr) - 1; while (left&lt;right) { char tmp = *left; *left = *right; *right = tmp; left++; right--; } } 具体实现： #include &lt;stdio.h&gt; #include&lt;string&gt; void reverse_string1(char* arr) { char *left = arr; char *right = arr + strlen(arr) - 1; while (left&lt;right) { char tmp = *left; *left = *right; *right = tmp; left++; right--; } } int main() { char str[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000c66f7fbb9e2bb7dbd07fad200a473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f20ecc708ab247c7cc1ecf6afa625aa/" rel="bookmark">
			工程伦理 清华大学 MOOC 期末答案 2020冬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：答案是本人自己查阅。不保证其完全正确性，仅供参考
点个赞再走呗 ：）
1.单选题 (1分)
以下不属于安全文化的核心的是(D)。 A
人的安全知识
B //
人的安全意识
C //
人的安全技能
D //
人的安全装备
2.单选题 (1分)
人的身份用来界定一个人是谁或者是什么,具有可识别性、独特性、唯一 性。与人的身份不一样,数字身份具有多样性与(B),具有容易被盗用、容易 被追溯等特点。 A //
一致性
B //
可变性
C //
不变性
D //
虚假性
3.单选题 (1分)
人与自然和谐发展是处理工程与自然关系的基本原则,其要求工程的决策 者、设计者、实施者以及使用者都要了解和尊重自然的内在发展规律,不 仅注重自然规律,更要注重(D) A //
技术规律
B //
经济规律
C //
社会规律
D //
生态规律
4.单选题 (1分)
当某项工程在施工期间出现了技术规范所不允许的断层、裂缝、倾斜、倒 塌、沉降、强度不足等情况时,监理工程师首先需要做的是?(B) A //
对承包人提出的处理方案予以审查、修正、批准,并指令恢复该项工程施工。
B //
暂停该项工程的施工,并采取有效的安全措施。
C //
要求承包人尽快提出质量事故报告并报告业主。
D //
对承包人提出的有争议的质量事故责任予以判定。
5.判断题 (1分)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f20ecc708ab247c7cc1ecf6afa625aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b030d3aa73a7124b55fba7f6e69252/" rel="bookmark">
			vuex，简单易懂！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex 为什么会有Vuex ?
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
vuex是采用集中式管理组件依赖的共享数据的一个工具，可以解决不同组件数据共享问题。
结论（提前总结，往下慢慢看!）
修改state状态必须通过mutations
mutations只能执行同步代码，类似ajax，定时器之类的代码不能在mutations中执行
执行异步代码，要通过actions，然后将数据提交给mutations才可以完成
state的状态即共享数据可以在组件中引用
组件中可以调用action
vuex基础-初始化功能 建立一个新的脚手架项目, 在项目中应用vuex
$ vue create demo 开始vuex的初始化建立，选择模式时，选择默认模式
初始化：
第一步：npm i vuex --save =&gt; 安装到运行时依赖 =&gt; 项目上线之后依然使用的依赖 ,开发时依赖 =&gt; 开发调试时使用
开发时依赖 就是开开发的时候，需要的依赖，运行时依赖，项目上线运行时依然需要的
第二步： 在main.js中 import Vuex from 'vuex'
第三步：在main.js中 Vue.use(Vuex) =&gt; 调用了 vuex中的 一个install方法
第四步：const store = new Vuex.Store({...配置项})
第五步：在根实例配置 store 选项指向 store 实例对象
import Vue from 'vue' import Vuex from 'vuex' Vue.use(vuex) const store = new Vuex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b030d3aa73a7124b55fba7f6e69252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c39ea0eb441c47bc5578b2e1d84d5fb/" rel="bookmark">
			转载：充分条件、必要条件、充分必要条件的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始链接：https://www.jianshu.com/p/9783ed0bb89b
充分条件、必要条件、充分必要条件的解释
（一）先看看概念 假设A是条件，B是结论。
（1）如果由A可以推出B，由B可以推出A，则A是B的充分必要条件，这种情况下B也是A的充分必要条件，简称充要条件。
（2）由A可以推出B，由B不可以推出A，则A是B的充分条件，但是，不是必要条件。
（3）由A不可以推出B，由B可以推出A，或者还可以说，没有A就没有B，则A是B的必要条件，但是，不是充分条件。
（4）当然还有第四种情况，就是由A不可以推出B，由B也不可以推出A，那么A是B的既不充分也不必要条件，反之亦然，可能只是某些情况下的条件之一或者一定程度的相关而已，没有固定的必然的联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8282be8dbbf028cc9f452960ce0491d4/" rel="bookmark">
			matlab条形图添加误差线_带误差线的条形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		误差线可以反应数据有多精确，或者说，(无误差)真实值与观察值之间的距离有多远。对于条形图而言，如果图形反应的是综合的结果(如均值等)，就可能需要添加误差线。本文将对此进行展示。
为了画出带误差线的条形图，我们需要先画出一个条形图。然后，或使用ggplot2中的geom_errorbar()添加误差线。
geom_errorbar()函数需要设定三个参数：
ymin 和ymax错误线的底部和顶部的位置
x：在x轴上的位置
现假设对于同一变量，有5组被试得分如下：
library(ggplot2)# 创建数据data name=letters[1:5], value=sample(seq(4,15),5), sd=c(1,0.2,3,2,4))data 共有5组平均值及其标准差
画出带误差线的条形图
ggplot(data) + geom_bar( aes(x=name, y=value), stat="identity", fill="skyblue", alpha=0.7) + geom_errorbar( aes(x=name, ymin=value-sd, ymax=value+sd), width=0.4, colour="orange", alpha=0.9, size=1.3) ‍
此外，还可以使用：
geom_crossbar()：用于绘制箱形的误差线
ggplot(data) + geom_bar( aes(x=name, y=value), stat="identity", fill="skyblue", alpha=0.5) + geom_crossbar( aes(x=name, y=value, ymin=value-sd, ymax=value+sd), width=0.4, colour="orange", alpha=0.9, size=1.3) geom_linerange()：用于绘制直线形的误差线
ggplot(data) + geom_bar( aes(x=name, y=value), stat="identity", fill="skyblue", alpha=0.5) + geom_linerange( aes(x=name, ymin=value-sd, ymax=value+sd), colour="orange", alpha=0.9, size=1.3) geom_pointrange()：用于绘制带点的误差线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8282be8dbbf028cc9f452960ce0491d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3ac10046c8f3cdf2775b54976bd158/" rel="bookmark">
			Error: No PostCSS Config found in... 报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目在本地运行不报错，上传到 GitHub 之后，再 clone 到本地，执行：
npm install
安装完成之后再执行：
npm run dev
这时报错 Error: No PostCSS Config found in…
本以为是 GitHub 上传的问题，后开又试了两回，发现问题依然存在，于是就开始网上寻找办法。
解决方案
在项目根目录新建postcss.config.js文件，并对postcss进行配置：
module.exports = { plugins: { 'autoprefixer': {browsers: 'last 5 version'} } } 好了 试试
npm run dev 果然好了
项目在本地运行时本来不报错的，但是为什么上传到 GitHub 之后，再 clone 下来，再运行就得单独写一个 postcss.config.js 的文件并配置一下呢？
在npm上查到的postcss配置在webpack.config.js，postcss.config.js是针对webpack3.0做的特殊处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a88e04291c30ac8ae7727cc999a14ce/" rel="bookmark">
			STM32 Cubemonitor 修改变量数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 Cubemonitor 修改变量 话不多说，上图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871a60b3cf158324e6c6de22f96184f4/" rel="bookmark">
			SQL Server添加字段注释表注释comments，Oracle与Sql Server添加注释语法区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server添加字段注释，添加表注释comments 在SQL Server语法中，给表字段与表添加注释与Oracle语法有的很大的区别。
Oracle语法添加字段注释 语法
COMMENT on column 表.字段 is '字段注释'; COMMENT ON table 表 IS '表注释'; 示例
--添加userTest表的userName字段注释为"用户姓名" COMMENT on column userTest.userName is '用户姓名'; --添加userTest表的表注释为"用户信息表" COMMENT ON table userTest IS '用户信息表'; --对于删除、更新注释语法一样，直接更改即可。 --删除userTest表的userName字段注释 COMMENT on column userTest.userName is ''; --删除userTest表的表注释 COMMENT ON table userTest IS ''; Sql Server语法添加字段注释 语法
--添加字段注释 execute sp_addextendedproperty 'MS_Description','填写你的字段注释','user','DB schema','table','填写表名','column','字段名'; --修改字段注释 execute sp_updateextendedproperty 'MS_Description','填写你的字段注释','user','DB schema','table','填写表名','column','字段名'; --删除字段注释 execute sp_dropextendedproperty 'MS_Description','user','DB schema','table','填写表名','column','字段名'; -- 添加表注释 execute sp_addextendedproperty 'MS_Description','填写你的表注释','user','DB schema','table','填写表名',null,null; -- 修改表注释 execute sp_updateextendedproperty 'MS_Description','填写你的表注释','user','DB schema','table','填写表名',null,null; -- 删除表注释 execute sp_dropextendedproperty 'MS_Description','user','DB schema','table','填写表名',null,null; 示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871a60b3cf158324e6c6de22f96184f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/986d4d27abecfa04f0a914bc8e51c50e/" rel="bookmark">
			python3配置PyOpenGL环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为计算机图形学课程需要使用OpenGL画图，不习惯用C++写代码，所以我发现了python也有PyOpenGL库可以实现画图，于是开始了长达半个小时的安装，这里把踩的坑写一下。
首先如果直接pip install PyOpenGL PyOpenGL_accelerate
我直接是安装成功了，然后就以为可以使用了，跑了一下测试代码：
from OpenGL.GL import * from OpenGL.GLU import * from OpenGL.GLUT import * def Draw(): glClear(GL_COLOR_BUFFER_BIT) glRotatef(0.5, 0, 1, 0) glutWireTeapot(0.5) glFlush() glutInit() glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA) glutInitWindowSize(400, 400) glutCreateWindow("test") glutDisplayFunc(Draw) glutIdleFunc(Draw) glutMainLoop() if __name__ == '__main__': Draw() 结果报错：
这个错误网上也很多人说过，我的电脑是64位的，而这个错误无非是直接pip安装只能安装32位的库，因此报错。所以需要手动去下载whl文件安装PyOpenGL。
这里我附上网址：
https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyopengl
我这里也把我自己的配置的whl文件放在这儿，我是win10 + python3.7 + 64位，
PyOpenGL_accelerate-3.1.5-cp37-cp37m-win_amd64
提取码:hglu
将压缩包下载解压，然后进入PyOpenGL-3.1.5-cp37-cp37m-win_amd64.whl对应目录，pip install PyOpenGL-3.1.5-cp37-cp37m-win_amd64.whl等待安装完成即可，这样就可以在python中使用OpenGL。
示例代码结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62eee3379327d73cb79cfd5e593079eb/" rel="bookmark">
			vantUI在vue2.x项目中的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 第一步：npm i vant --save
第二步安装vant plugin：npm i babel-plugin-import -D
第三步： 配置样式
// vue2.x在.babelrc文件中添加： "plugins":[ ["import", { "libraryName": "vant", "libraryDirectory": "es", "style": true }] ] // 如果本身有plugins了，则应该为： "plugins":[ "transform-vue-jsx", "transform-runtime", // 这里要保留，否则会报错 ["import", { "libraryName": "vant", "libraryDirectory": "es", "style": true }] ] 使用 https://www.w3cschool.cn/vantlesson/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d73a26589f4c80ad91c2a7dd341e93a/" rel="bookmark">
			石头剪刀布程序流程图_连“石头剪刀布”，人类也玩不过AI了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果说有一种解决问题的方法能跨域文化、种族和地域，那么除了抽签这种纯靠运气的方式，恐怕只剩下猜拳了。
人们普遍认可 “石头-剪刀-布” 三者之间的克制关系。“公平+随机” 的特性使其不仅是活跃气氛的小游戏，更能作为一种相对公平的解决问题的手段，广泛应用在解决分歧，决定顺序，或者确定归属的关键时刻。
更不用说，在谁洗碗、谁拖地、谁做饭之类的家务活上，猜拳自带的 “愿赌服输” 可以有效维系家庭和睦，堪称随叫随到的家庭关系调解员。
在大多数人的认知里，猜拳是随机事件，玩家获胜的概率应该是一样的且恒定在三分之一，但事实可能并非如此。
近日，浙江大学何赛灵教授的研究团队开发了一个基于马尔可夫链的 AI 模型，专门用来玩猜拳游戏。在和 52 名人类玩家分别大战 300 回合之后，AI 击败了 95% 的玩家。
图 | AI 模型净胜场数变化
对于人类玩家来说，规则是赢 +2 分，平 +1 分，输不得分。在与 AI 对战之前，参与者知道获胜会获得金钱奖励，总分越高，赢的钱越多。因此玩家故意放水或者随便乱选的概率极低。
即便如此，AI 仍然大胜人类。在最悬殊的一场较量中，AI 获得了 198 次胜利，55 次平手，仅输了 47 次，胜率超过人类对手 4 倍。全部 15600 回合详尽的原始博弈数据，在论文的补充资料中给出（详见参考文献）。如果猜拳胜负真的是随机概率，那么从统计学的角度来讲，15600 场比赛下来，AI 获得如此大优势的概率非常低。
拥有“智囊团”的Multi-AI模型 本质上来看，猜拳属于博弈问题，其背后蕴藏着经典的纳什均衡，而每个个体的习惯、认知、策略和策略变化都会影响实际胜率。比如你和对手很熟悉，那么你可能知道他/她经常出布，因此可以多出剪刀来克制。
浙江大学何赛灵教授团队提出的 AI 模型就是利用了类似的方法，证明了猜拳真的存在针对不同个体的长期制胜策略，可以有效提高胜率。
这套 AI 模型基于 n-阶马尔可夫链设计，拥有记忆性，能够向前追溯最多 n 个历史状态并加以利用。
为了在实战中应对人类玩家的不同性格和策略，研究团队还发明了一套 Multi-AI 模型。
“建立对每个人都有效的单一模型很困难，因此我们决定将单个模型结合起来，使其能够区分和适应更多不同的竞争策略。” 研究人员在论文中解释称。在与人类对战的第一套 Multi-AI 模型中，他们放入了 1-5 阶马尔可夫链，即 5 个独立的 AI 模型，分别参考之前 1-5 个动作。Multi-AI 会从整体上参考 5 个 AI 模型各自的决策，至于选择哪个，还要看它们最近 5 次的表现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d73a26589f4c80ad91c2a7dd341e93a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/215/">«</a>
	<span class="pagination__item pagination__item--current">216/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/217/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>