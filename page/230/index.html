<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd2e8e5624979d28b977bdec495e293/" rel="bookmark">
			大数据——一维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一维数组 理解数组定义数组数组元素的表示和赋值数组的初始化遍历数组示例一示例二示例三示例四示例五 增删改查数组增加元素数组删除元素 理解数组 在Java中，数组是用来存储一组相同类型数据的数据类型。当数组初始化完毕后，java为数组在内存中分配一段连续的空间，其在内存中开辟的空间也将之固定，此时数组的长度就不能再发生改变。即使数组中没有保存任何数据，数组所占据的空间依然存在。（现在所说的数组暂时都是一维数组）
定义数组 在Java中，定义数组的语法有如下两种。
数据类型[] 数组名=new 数据类型[数组长度];
或者：
数据类型 数组名[]=new 数据类型[数组长度]
定义数组时一定要指定数组名和数组类型。
必须书写“[]”，表示定义了一个数组，而不是一个普通的变量。
“[数组长度]”决定连续分配的空间的个数，通过数组的length属性可获取此长度。
数组的类型数据用于确定分配的每个空间的大小。
//声明 int[] a; String b[]; double []c; //分配空间,使用new关键字来分配空间， //new关键字是java中优先级最高的。 a=new int[5]; b=new String[6]; c=new double[4]; 数组元素分配的初始值
1.数组元素的类型是基本类型中的整数类型（byte、short、int和long），则数组元素的值是0。
2.数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是0.0。
3.数组元素的类型是基本类型中的字符类型（char），则数组元素的值是’\u0000’。
4.数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是false。
5.数组元素的类型是引用类型（类、接口和数组），则数组元素的值是null。
数组元素的表示和赋值 由于定义数组时内存分配的是连续的空间，所以数组元素在数组里顺序排列编号，该编号即元素下标，它标明了元素在数组中的位置。首元素的编号规定为0，因此，数组的下标依次为0、1、2、3、4······依次递增，每次增长数是1。数组中的每个元素都可以通过下标来访问。
获得数组元素的语法格式如下。
数组名[下标值]
//赋值 a[0]=10; a[1]=14; a[2]=18; a[3]=24; a[4]=33; a[5]=45; 数组的初始化 所谓的数组的初始化，就是在定义数组的同时一并完成赋值的操作。
数组初始化的语法格式如下、
数据类型[]数组名={值1，值2，值3，······，值n}；
或者：
数据类型[]数组名=new 数据类型[]{值1，值2，值3，······，值n}；
//声明的同时分配空间 char[] ch=new char[10]; float f[]={11.1f,22.2f};//声明、分配空间并赋值 int []d=new int[]{1,2,3}; 遍历数组 在编写程序时，数组和循环往往结合在一起使用，可以大大的简化代码，提高程序编写效率。通常使用for循环遍历数组。
示例一 Text1：计算30位同学的平均分，同时打印每一个分数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd2e8e5624979d28b977bdec495e293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4271a469514c46b0b47e8e8074214020/" rel="bookmark">
			解决MAC上网速度慢的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/u014544346/article/details/51347285
现象描述：
LZ平时用Mac上网速度一直不错
直到最近出差，那网速简直无法使用
奇怪的是，用LZ的华为手机上网速度还可以，Windows笔记本连上手机开的热点速度也还可以
唯独Macbook Pro连上手机开的热点速度特别烂
解决方法：
打开系统偏好设置，选择网络
在当前连接WiFi的情况下，选择高级
切换到DNS选项卡，若您的DNS服务器列表中有“8.8.8.8”域名，直接删除即可
点击好，应用即可
原因解释：
8.8.8.8DNS服务器的解析结果常将用户引导到较慢的网站
原因是大中型网站目前都使用CDN做内容分发，确保用户就近接入而提高访问速度
同样的内容如淘宝网页，深圳宽带用户访问的是淘宝在广东的服务器，北京宽带用户访问的是淘宝在北京的服务器
CDN是怎么做到就近接入的呢？关键就在于你用的DNS，你用哪个地方的DNS，互联网公司基本认为你就是那个地方的宽带用户
如果你将DNS写错了，比如深圳宽带用户将DNS填写成北京的DNS，那么无论你访问淘宝、新浪你都被引导到北京去，网速自然慢了许多
所以说，DNS是流量牵引器，必须选合适的
说回国内使用8888的坏处（8888是谷歌DNS服务器），你将DNS填8888，互联网公司都以为你是国外的用户，无法给你选出就近的服务器，随便给你个能用的就行了，你的网速自然慢了许多
如果你无法忍受国内运营商的DNS劫持，又想访问一些用国内运营商的DNS无法访问的网页，那可以使用114.114.114.114，它在国内有几十个点，能引导你到最近的网站，没有8.8.8.8的弊端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbb7857cb44e02f6d938fb0852e97678/" rel="bookmark">
			ValueError: The two structures don‘t have the same sequence length.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 环境： windows10
cuda 10.0
tensorflow 2.0
操作步骤 根据tf2.0模型导出导入学习，把训练好的模型导出来。
把刚刚导出的模型导入，进行测试
测试导入模型的时候，报错如下 报错摘要：ValueError: The two structures don’t have the same sequence length. Input structure has length 1, while shallow structure has length 2.
Traceback (most recent call last): File "F:\Anaconda\install\lib\site-packages\tensorflow\python\eager\function.py", line 1204, in _convert_inputs_to_signature expand_composites=True) File "F:\Anaconda\install\lib\site-packages\tensorflow\python\util\nest.py", line 833, in flatten_up_to check_subtrees_length=check_subtrees_length) File "F:\Anaconda\install\lib\site-packages\tensorflow\python\util\nest.py", line 718, in assert_shallow_structure input_length=len(input_tree), shallow_length=len(shallow_tree))) ValueError: The two structures don't have the same sequence length. Input structure has length 1, while shallow structure has length 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbb7857cb44e02f6d938fb0852e97678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9364111176271d99b0ae6bff5c656b/" rel="bookmark">
			一个三节点的PVE 6.1&#43;CEPH集群，因为系统损坏，全部重新安装。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：
逐一重装系统／重新加入PVE集群／重新加入CEPH集群；
先禁用ceph的recover，避免其因OSD丢失重建：任一节点执行：
for i in noout nobackfill norecover;do ceph osd set $i;done
重新加入pve集群前确保已经从集群中删除
步骤
备份配置和证书 备份到/root/bak/目录下，然后打包拷贝到其他地方保存(别忘了，否则就不能还原了)：
systemctl stop pvestatd.service
systemctl stop pvedaemon.service
systemctl stop pve-cluster.service
tar -czf /root/bak/pve-cluster-backup.tar.gz /var/lib/pve-cluster
tar -czf /root/bak/ssh-backup.tar.gz /root/.ssh
tar -czf /root/bak/corosync-backup.tar.gz /etc/corosync
cp /etc/hosts /root/bak/
cp /etc/network/interfaces /root/bak/
tar cjvf bak-$(hostname).tgz /root/bak
从pve集群删除节点 节点xxx关机，然后在其他节点删除该节点，下面的xxx就是节点名：
pvecm nodes
pvecm delnode xxx
pvecm updatecerts
重新安装PVE 尽量和以前一致，尤其主机名/IP地址。
恢复备份的配置和证书 把刚才的备份拷贝回来还原，按照原来的目录
tar xjvf bak-xxx.tgz
cp /root/bak/hosts /etc/hosts
cp /root/bak/interfaces /etc/network/interfaces
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d9364111176271d99b0ae6bff5c656b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989a33b4e2e5f94cd699c2a2bbc98943/" rel="bookmark">
			vue实现两个区域滚动条同步滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目开发中，遇到一个比较两个form差异的需求，但当item过多就需要滚动条，这里就用到了滚动条同步的地方，其实原理和git的差异比较差不多，这里来做一下分析。这是效果图
要点分析：
其实主要是通过ref属性来操控两个div的scrollTop属性
&lt;div class="customer-span" ref="systemForm" @scroll="sysHandleScroll()" @mouseover="changeFlag(false)"&gt; &lt;div class="customer-span-form"&gt; &lt;el-form label-suffix=":" class="form-static" label-position="right" label- width="100px"&gt; &lt;el-form-item v-for="(item, index) in formItem" :key="index" :label="item.label"&gt; {{ systemFormData[item.model] }} &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="customer-span" ref='externalForm' @scroll="exterHandleScroll()" @mouseover="changeFlag(true)"&gt; &lt;div class="customer-span-form"&gt; &lt;el-form label-suffix=":" class="form-static" label-position="right" label- width="100px"&gt; &lt;el-form-item v-for="(item, index) in formItem" :key="index" :label="item.label"&gt; {{ externalFormData[item.model] }} &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt; js部分
data() { return { flag: false } }, method: { changeFlag(flag) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989a33b4e2e5f94cd699c2a2bbc98943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c959fcdd707d8fd36b3c81fedb01226a/" rel="bookmark">
			sqlalchemy-自定义数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
实现原理
案例
前言 sqlalchemy包含了mysql支持的所有的数据类型，我们平时的使用基本上都能够满足了。
但是，有一种情况比较特殊，就是mysql不能存储json数据，自然，sqlalchemy也没有对应json的数据类型。
这次在项目中，我需要在mysql中存储一个结构化的数据：JSON数据。那么，能实现吗？
实现原理 是可以实现的，因为sqlalchemy提供了一个类：TypeDecorator。这个类可以定义某个现存的数据类型的行为，文档原话：
Allows the creation of type which add addtional functionality to an existing type
TypeDecorator提供了两个方法作为存入mysql前 与 从mysql取出数据后 的两个操作，有点钩子函数的意思。分别为：
def process_bind_param(self, value, dialect): pass def process_result_value(self, value, dialect): pass 正是通过这两个函数改变了基本类型的表现方式。可以看下面的例子
案例 为一个数据类型添加前缀
from sqlalchemy import TypeDecorator, String class MyType(TypeDecorator): impl = String # impl必须存在，指定基于的数据类型 def process_bind_param(self, value, dialect): return "PREFIX:" + value def process_result_value(self, value, dialect): return value[7:] 由于它可以改变数据行为，我就想到了我们可以基于String或者Text类型来实现json数据，配合json包的dumps和loads即可。具体实现代码如下：
import json from sqlalchemy import Text, TypeDecorator class Json(TypeDecorator): impl = Text def process_bind_param(self, value, dialect): return json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c959fcdd707d8fd36b3c81fedb01226a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3a48af57950300a6d2baf6b40bd123/" rel="bookmark">
			华为云OBS配合laravel文件上传解决composer安装时候与框架依赖冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为云OBS配合laravel文件上传解决composer安装时候与框架依赖冲突问题 Tp5框架测试也是适用的
1.在vendor目录下新建obs文件夹 结构如下图 sdk下载地址
链接: php sdk链接.
2.在public目里下index.php文件中加入以下代码
require __DIR__.'/../vendor/obs/vendor/autoload.php'; require __DIR__.'/../vendor/obs/obs-autoloader.php'; use Obs\ObsClient; use Obs\ObsException; 3.在上传文件控制器UploadController中加入以下代码
use Obs\ObsClient; //头部加入这段代码 /** * 上传图片 * @param Request $request * @return \Symfony\Component\HttpFoundation\Response */ public function uploadImage(Request $request) { $localfile = $request-&gt;file()['image']-&gt;getPathname(); // 创建ObsClient实例 $obsClient = new ObsClient([ 'key' =&gt; 'PRMKOZAQCQTQPL39U5CGN', 'secret' =&gt; 'q5O6k88LUPnAQbBNIXykkjOEP3UM3VjlqE1ztrzm', 'endpoint' =&gt; 'obs.cn-east-3.myhuawicl3oud.com', ]); $resp = $obsClient-&gt;putObject([ 'Bucket' =&gt; 'cmsobs20200713', 'Key' =&gt; date("Y-m-d H:i:s").".png", 'SourceFile' =&gt; $localfile // localfile为待上传的本地文件路径，需要指定到具体的文件名 ]); $response['code'] = 0; $response['msg'] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b3a48af57950300a6d2baf6b40bd123/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20cae2e27418645b9cd1d4bf3e5f2200/" rel="bookmark">
			java获取客户端ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解详情请看原文
总结：
无反向代理直接访问的使用这个
request.getRemoteAddr()
多层Nginx代理的使用这个
request.getHeader(“X-Forwarded-For”)
只有一层网络代理的使用这个
request.getHeader(“X-Real-IP”) 192.168.238.218
涉及网络代理的需要设置，详情请看原文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d28fcf1e6e74c76137cdff702ac1af/" rel="bookmark">
			定义一个学生类CStudent,私有数据成员包括name (姓名)、id(学号)、math (数学成绩) 和english(英语成绩)，私有静态数据成员包括 count (学生总人数）（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个学生类CStudent,私有数据成员包括name (姓名)、id(学号)、math (数学成绩)
t题目要求
#include
#include&lt;string.h&gt;
using namespace std;
class CStudent
{
private:
int id;
string name;
int math;
int english;
static int count;
static int mathc;
static int englishc;
public:
void setms()
{
cout &lt;&lt; "name id math english" &lt;&lt; endl; cin &gt;&gt; name &gt;&gt; id &gt;&gt; math &gt;&gt; english; count++; mathc = mathc + math; englishc = englishc + english; } int add() { return math + english; } void outms() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d28fcf1e6e74c76137cdff702ac1af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f8255fab159a93cb3c21fbfe1c38e3/" rel="bookmark">
			力扣解题思路：分割数组/背包问题（动态规划）纠错记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		416. 分割等和子集 思路：题目：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。举个例子： Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. 显然这就是一个0-1背包问题背包问题的讲解可以参考这里o(￣▽￣)ブ首先我们的目的是确定背包的容量，也就是sum / 2，而且不多不少刚好sum / 2，当然sum也必须是个偶数，否则返回false，每个物品也就是数组里的每个元素，可以放也可以不放，那么我们用二位动态规划数组来记录更新过程，dp[m][n] 考虑是否将第m个数字放入容量为n的背包，那么状态转移方程：
dp[m][n] = dp[m-1][n] || dp[m-1][n-nums[m]]
当然我们还需要对数组进行初始化（这里写一个循环是为了避免nums[0]比c大的这种情况，但测试用例中似乎没有出现这种情况）：
for(int i=0; i&lt;=c; i++){ if(i!=nums[0]){ dp[0][i] = false; }else{ dp[0][i] = true; } } 当然初始化也可以这样：
dp[0][0] = true; dp[0][nums[0]] = true; 因为i=0时只有这两种可能，就是放一个nums[0]刚好满了，或者不放nums[0]（什么都不妨）也能刚好满（因为背包大小为0）。完整代码如下：
public boolean canPartition(int[] nums) { //动态规划，背包问题，从nums中选择一部分数字组合，填满容量为sum/2的背包 int n=nums.length; if(n == 0){ return false; } int sum = 0; for(int i=0; i&lt;n; i++){ sum+=nums[i]; } int c = sum/2; if(sum%2==1){ return false; } boolean[][] dp = new boolean[n][c+1]; //状态初始化 for(int i=0; i&lt;=c; i++){ if(i!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f8255fab159a93cb3c21fbfe1c38e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08111020faec2474b7445fbd45cfe923/" rel="bookmark">
			WebRTC网络基础 九、第四节 STUN协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来介绍一些STUN协议。
STUN存在的目的就是进行NAT穿越 STUN 存在的目的就是进行NAT穿越，NAT有四种类型，每种类型如何穿越它的基本原理是什么，都是属于STUN协议中的一部分。
STUN是典型的客户端/服务器模式。客户端发送请求，服务端进行响应 RFC STUN规范 RFC STUN规范中，实际上有两套STUN规范
第一套叫做RFC3489/STUN Simple Traversal of UDP Through NAT
它就是将STUN定义成简单的通过UDP进行NAT穿越的一套规范，也就是告诉你如何一步一步通过UDP进行穿越，但是这套规范在穿越的过程中还是存在很多问题，尤其是现在的网络路由器对UDP的限制比较多，有的路由器甚至不允许进行UDP传输，所以这就导致了我们通过RFC3489这套规范进行NAT穿越的时候它的失败率会非常高。所以为了 解决这个问题，又定义了另一套标准，RFC5389.
第二套叫做RFC5389/STUN Session Traversal Utilities for NAT
RFC5389是在RFC3489的基础上又增加了一些功能，但是它对整个STUN的描述就不一样了, 它是把STUN描述成一系列穿越NAT的工具，所以都叫STUN，但是他们的含义完全就不一样了。RFC5389在UDP尝试可能失败的情况下，尝试使用TCP，也就是说RFC5389是包括UDP和TCP的两种协议进行NAT穿越的，这是两套规范最本质的区别。当然在协议的具体内容上，包括协议头还有协议体中的属性都有很多的变化，但是那些都不是最关键的，最关键的是RFC5389里面将TCP纳入进来。你可以通过TCP进行穿越。
这是STUN 的RFC的两套规范。大家一定要清楚，尤其是查文档的 时候一定要清楚查询的是哪一套规范。
下面我们就具体看看这个STUN协议 包括20字节的STUN header
Body中可以有0个或多个Attribute
STUN这个协议它是包括了消息头和消息体，消息头是20字节固定的消息头，Body中可以有0个或者多个Attribute属性，后面我们会 介绍属性的作用。
那么这20字节头是由哪些组成呢？
其中2个字节（16bit）类型
2个字节(16bit)消息长度，不包括消息头
在网络协议中有很多的协议规范，它的这个消息头中都有长度，有的是包括这个头的有的是不包括这个头的，这个大家一定要记清楚 。
对于STUN来说，消息头的长度length是不包括消息头的；
16个字节(128bit)事物 ID，请求与响应事物ID相同
第三个是事物ID，它是16字节或128bit组成，它的作用就是请求和响应事物是相同的ID，用于请求与响应的匹配的；比如我客户端 发送了好几个请求，那服务端对于每一个请求都要返回一个响应 ，那怎么知道某个响应是对应到的请求呢，就通过这个事物ID。
如果它事物ID号相同，说明这两是匹配的，整个逻辑就知道怎么做了，否则的话就很难判断。所以它有三部分组成，第一是两个字节的类型，第二是两个类型的消息长度，不包括这个消息头，第三个是16字节的128位的事物ID，请求与响应的匹配。这个是消息头。
我们再来看消息头的格式
上图的格式是最新的RFC5389的格式，刚刚我们上面说三个的是RFC3489，那么RFC5389和RFC3489之间有什么区别呢？
首先我看消息类型，消息类型的最低两位必须是 0 0，就是RFC5389最新的协议 ，这是第一点的不同；第二点的不同是，事物ID，老的里面是128位事物ID，在新的里面是 96位，其中有32位单独划出来了单独作为 Magic Cookie，一个魔法树，这就是RFC3489和5389的STUN消息头的区别。
下面我们再来看每一项，首先是这个Massage Type
STUN Message Type 前两位必须是00，以区分复用同一端口时STUN协议
就是不同的协议复用同一个端口的时候，用它来区分哪个是STUN协议哪个不是STUN协议，这是两位00的作用。
2位用于分类，即C0和C1
剩下的14位中有两位用于分类，就是C0和C1，C0和C1是占两位，所以它有四种类型，也就是四个分类，第一种是请求，第二种 是指示，第三种是成功，第四种是错误应答，所以它将Message Type消息类型分成了四类。
12位用于定义请求/指示
剩下的12位是用于不同请求的定义，比如1代表绑定，2代表私有消息隐私数据，……，但是在STUN 3489里面定义了两个，就是用 这12位定义了两种，但是5389里面就一种，一种就够了。下图就是STUN Message Type的结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08111020faec2474b7445fbd45cfe923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe88717b1d7e03228c1e82fcab8cfdc4/" rel="bookmark">
			2.策略梯度（Policy Gradient）&#43;Gradient Ascent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 深度强化学习目录
简介 策略梯度，顾名思义，就是优化策略的梯度。我们之前讲了Policy-based和Value-based，而Policy-based方法就是直接训练策略的一组参数。如何训练？策略梯度就是一种方法。
基本思路 要训练一个Policy-based的方法，其实只需要三步。
第一步，用一个神经网络作为策略自身，神经网络的参数为 θ \theta θ。第二步，设置一个Loss function，告诉神经网络什么样的策略是好的。第三步，得到最佳策略。 符号 τ \tau τ：一轮游戏中的具体过程（trajectory）， τ = { s 1 , a 1 , r 1 , s 2 , a 2 , r 2 , … , s T , a T , r T } \tau=\{s_1,a_1,r_1,s_2,a_2,r_2,\ldots,s_T,a_T,r_T\} τ={s1​,a1​,r1​,s2​,a2​,r2​,…,sT​,aT​,rT​}，是状态-行为-奖赏的时间序列。 p ( τ ∣ θ ) p(\tau \vert \theta) p(τ∣θ)：参数为 θ \theta θ时，采取过程 τ \tau τ的概率。 τ n \tau^n τn：根据 p ( τ ∣ θ ) p(\tau \vert \theta) p(τ∣θ)采样出来的过程 τ \tau τ，上标 n n n代表是采样第 n n n次的得到的过程。 R θ R_\theta Rθ​：参数为 θ \theta θ时在一轮游戏中的累积奖赏， R θ = ∑ r t R_\theta=\sum r_t Rθ​=∑rt​。 R ( τ ) R(\tau) R(τ)：游戏过程中所获取的奖赏的总和， R ( τ ) = ∑ t = 1 T r t R(\tau)=\sum_{t=1}^{T} r_t R(τ)=∑t=1T​rt​ π θ \pi_\theta πθ​：使用参数 θ \theta θ的策略 π \pi π。由于我们采取神经网络，所以实际上策略 π \pi π和参数 θ \theta θ是基本可以看作绑定在一起的。 目标函数 J ( θ ) J(\theta) J(θ) 第一步没什么好说的，输入状态，输出对每一个动作的选取概率，这就是神经网络，至于具体用CNN还是ResNet之类的，看实际情况来决定，我们先来说说Loss function。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe88717b1d7e03228c1e82fcab8cfdc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6ab3dd6fcabf0c2d777279a4b64975/" rel="bookmark">
			vue（21）：前后端交互（获取后台数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口调用方式
原生ajax基于jQuery的ajaxfetchaxios Promise 概述
Promise时异步编程的一种解决方案，从语法上将，Promise是一个对象，从它可以获取异步操作的消息
优点：
可以避免多层异步调用嵌套问题（回调地狱）Promise对象提供了简介的API，使得异步操作更加容易 基本用法：
实例化Promise对象，构造函数中传递函数，该函数用于处理异步任务resolve和reject两个参数用于处理成功和失败两种情况，并通过then函数获取处理结果 格式：
var p=new Promise(function(resolve,reject){ //成功调用resolve() //失败调用reject }) p.then(function(ret){ //从resolve得到正常结果 },function(ret){ //从reject得到错误信息 }) 实例：基本使用格式
var p = new Promise(function(resolve, reject) { setTimeout(function() { var flog = true if (flog) { //正常情况 resolve('Hello') } else { //异常情况 reject('错误') } }, 100) }) p.then(function(ret) { console.log(ret) }, function(ret) { console.log(ret) }) 实例：基于Promise发送Ajax请求
function queryData(url) { var p = new Promise(function(resolve, reject) { //ajax var xml = new XMLHttpRequest(); xml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f6ab3dd6fcabf0c2d777279a4b64975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4089e1c19bfbc4a0c59c72a3134e19/" rel="bookmark">
			EMC | 静电放电抗扰度试验与整改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
概 述
静电放电是一种自然现象，当两种不同介电强度的材料互相摩擦时就会产生静电电荷，如果其中一种材料的静电电荷积累到一定程度，并与另外一个物体接触时，就会通过这个物体到大地的阻抗进行放电，当设备发生接触或者空气放电后，附着在设备内部电路板或者元器件的阻抗较小，所以二次放电的危害有可能比一次放电更大。静电放电及其影响是电子设备的一个主要干扰源。
静电放电多发生于人体接触半导体器件时，有可能导致半导体材料击穿，产生不可逆的损坏，静电放电及有此产生的电磁场变化可能危害电子设备的正常工作。
静电放电抗扰度试验模拟了以下两种情况：
1.设备操作人员直接触摸设备时对设备的放电和放电对设备的影响（直接放电）
2.设备操作人员在触摸附近设备时对所关心的设备的影响（间接放电）
接触放电
电路中150pF电容代表人体的储能电容，330Ω电阻代表人体的手握钥匙和其他金属工具时的人体电阻，标准认为用这种人体放电模型（包括电容容量和电阻值）来描述静电放电时足够严酷的。
1.直接放电：人手可以触摸到部位都要进行静电放电试验
2.间接放电：间接放电即对耦合板进行放电
空气放电
静电放电可能造成的后果：
1.直接放电可引起设备中半导体器件损坏，从而造成设备的永久性失效；
2.设备的误动作，这是由放电（可能是直接放电，也可能是间接放电）而引起的近场电磁场变化造成的；
不接地设备
关于不接地的设备或者设备中不接地的部件不能直接进行连续放电试验，如果下一次ESD脉冲施加之前不能将电荷释放，就有可能使EUT达到所施加电压的两倍，因此这样连续打几次之后EUT可能被不切实际的充电至很多电荷，最终以非常高的能量在绝缘体的击穿电压点上放电；因此为了保证两次静电放电试验之间电荷已经完全释放需要在EUT上加泄放电阻或者静置时间够长使电荷自然衰减；
整 改
静电放电抗扰度不通过整改主要从两方面
泄放：PCB布局时要留有良好的泄放路径，让从插件，外壳，按键等人体可以接触的地方受到的静电快速泄放掉，并且绕开敏感器件比如CPU的复位电路；
消除：所有对外的接口都要加ESD /TVS器件防护；
生命不息、学习不止，加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0bb57bc513d911986c85cd17aab0993/" rel="bookmark">
			CAP理论-分布式系统的基础理论-------CP、AP案例场景分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言： CAP理论作为分布式系统的基础理论,它描述的是一个分布式系统在以下三个特性，只能满足其中两个特性，一致性、可用性、分区容错性三者不可兼得：
一致性（Consistency）可用性（Availability）分区容错性（Partition tolerance） 如何做到分布式系统具备高可用？？
常规的思路就是冗余，增加节点，当A节点挂掉，还有B节点提供服务，但是节点多了之后，数据一致性又很难保障了！！！
如何提升数据一致性？？
减少节点，最好就是单点服务，但是节点少了，可用性又很难保障，这么看一致性和高可用就是一个对立面。
二、案例分析()： 1、AP案例分析-SpringCloud-Eureka 图示，注册中心采用集群部署，满足高可用的特性，当订单服务在扩容的时候，新增订单服务实例4，数据注册到Eureka A节点，在其余的两个节点没有订单服务4这个实例信息，这种情况下，用户服务获取服务列表，可能获取不到订单实例4，这就是最简单的数据不一致情况。
Eureka集群本身，各个节点都处于平等的地位，完全是为了冗余，提升高可用。
2、CP案例分析-Zookeeper 知识点预热：
ZooKeeper 集群中的角色简介：
Leader： 负责发起投票和决议，更新系统状态
Follower：用于接收客户端请求并向客户端返回结果，在选主过程中参与投票
Observer： 可以接收客户端连接，将写请求转发给 Leader 节点，但不会参与 Leader 发起的投票，也不会被选举为 Leader，Observer 的目的是为了扩展系统，提高读取速度
在第二步，当Follower发现Leader节点挂了之后，Follower会拒绝现有的客户端连接，参与主从选举，在成功选举出leader之前，zk将不可用；这个时候如果ZK作为注册中心，注册中心将不可用。
注：图片来自百度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf209beb13a0177b99b48e2738cc130/" rel="bookmark">
			webrtc NACK 抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/CrystalShaw/article/details/81218394
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb29417fb4042770dafa51fb2d9e60b/" rel="bookmark">
			css checkbox_如何使用CSS Checkbox Hack构建简单的幻灯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css checkbox
在这个新教程中，我们将学习如何从头开始创建具有缩略图的功能齐全的响应式图像幻灯片。 为此，我们不需要编写任何JavaScript代码。 实际上，再次利用“ CSS复选框黑客技术”，我们将仅使用HTML和CSS。 我们的响应式CSS幻灯片 这是我们将在本教程中创建的幻灯片 （请确保查看完整的CodePen版本以防止页面跳至顶部）： 1.从HTML标记开始 在本练习中，我们将从Unsplash中获取三张图像。 然后，我们将创建相应的单选按钮，并将其分组在image关键字下： &lt;input type="radio" id="image1" name="image" checked&gt;&lt;input type="radio" id="image2" name="image"&gt;&lt;input type="radio" id="image3" name="image"&gt; 接下来，我们将.featured-wrapper和.thumb-list元素放入容器中。 .featured-wrapper元素将包含三个列表： 第一个列表将保存幻灯片图像。 一次只会显示一个图像。 其他两个相同的列表将用于在图像/幻灯片之间导航。 两个列表都将包含其for值与上述单选按钮的id值匹配的标签。 提示：在我们的示例中，我们将单选按钮与多个标签相关联。 这是完全有效的 。 .thumb-list元素还将包括幻灯片图像及其描述。 但是，与.featured-list元素的图像不同，这些图像将始终可见并用于缩略图导航。 简而言之，我们的幻灯片演示将使用户能够通过点，箭头和缩略图在幻灯片之间切换。 Niiice！ 最终HTML结构 默认情况下，第一张图像应该是可见/活动的。 考虑到这一点，我们将checked属性添加到第一个单选按钮。 放在一起，这是我们容器的结构： &lt;div class="container"&gt;&lt;div class="featured-wrapper"&gt;&lt;ul class="featured-list"&gt;&lt;li&gt;&lt;figure&gt;&lt;img src="IMG_SRC" alt=""&gt;&lt;/figure&gt;&lt;/li&gt;&lt;!-- other two list items here --&gt;&lt;/ul&gt;&lt;ul class="arrows"&gt;&lt;li&gt;&lt;label for="image1"&gt;&lt;/label&gt;&lt;/li&gt;&lt;li&gt;&lt;label for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb29417fb4042770dafa51fb2d9e60b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02097b0e98c994e5e9481c57b08c353/" rel="bookmark">
			css实现贝塞尔静态图_使用高级CSS条形图构建静态投资组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css实现贝塞尔静态图
在上一篇文章中 ，我向您展示了如何构建漂亮的全屏投资组合页面。 在该教程中，我们还学习了如何创建响应式CSS柱形图。 在本教程中，我们将构建另一个吸引人的静态投资组合页面，这次以纯CSS条形图为特色，而无需使用任何外部JavaScript库，SVG或canvas元素！ 我们正在建设什么 这是我们将创建的项目： 我们有很多令人兴奋的事情要介绍，所以让我们开始吧！ 1.从页面标记开始 页面标记由标题和三个全屏部分组成： &lt;header class="position-fixed text-lightblue page-header"&gt;...&lt;/header&gt;&lt;section class="d-flex justify-content-center align-items-center vh-100"&gt;...&lt;/section&gt;&lt;section class="d-flex vh-100 bg-lightwhite"&gt;...&lt;/section&gt;&lt;section class="d-flex flex-column justify-content-center align-items-center vh-100 position-relative"&gt;...&lt;/section&gt; 注意 ：除了元素的特定类之外，我们的标记还包含许多实用程序（帮助程序）类。 我们将使用这种方法使CSS尽可能保持DRY 。 但是，出于可读性考虑，在CSS内，我们将不对通用CSS规则进行分组。 2.定义一些基本样式 按照上面刚刚讨论的内容，我们首先指定一些重置规则以及一些帮助程序类： :root {--gray: #cbcfd3;--white: white;--black: #1a1a1a;--lightwhite: whitesmoke;--lightblue: #009dd3;--peach: #ff9469;--transition-delay: 0.3s;--transition-delay-step: 0.3s;--skills-width: 120px;}* {padding: 0;margin: 0;box-sizing: border-box;}ul {list-style: none;}a {text-decoration: none;color: inherit;}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02097b0e98c994e5e9481c57b08c353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a698805a457e2946aecbabe95d1f8a/" rel="bookmark">
			css 加载动画_使用CSS动画增强网页加载的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css 加载动画
在上一个教程中，我们使用flexbox创建了一个全屏响应页面。 今天，我们将通过添加一些CSS动画来使此页面更具吸引力。 这是我们要构建的： 1. HTML 为了添加所需的动画，我们将略微更新初始页面标记。 在上一个教程中，我们main元素的标记如下所示： &lt;main class="page-main"&gt;&lt;div&gt;&lt;h1&gt;...&lt;/h1&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;&lt;/main&gt; 出于本教程的目的，我们将添加一些额外的包装器，将其更改为： &lt;main class="page-main"&gt;&lt;div&gt;&lt;div class="text-wrapper"&gt;&lt;h1&gt;...&lt;/h1&gt;&lt;/div&gt;&lt;div class="text-wrapper p-wrapper"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;&lt;div class="text-wrapper p-wrapper"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/main&gt; 以下是修改后的整体页面标记： &lt;div class="wrapper"&gt;&lt;header class="page-header"&gt;&lt;nav&gt;&lt;h2&gt;...&lt;/h2&gt;&lt;ul&gt;...&lt;/ul&gt;&lt;button class="cta-contact"&gt;...&lt;/button&gt;&lt;/nav&gt;&lt;/header&gt;&lt;main class="page-main"&gt;&lt;div&gt;&lt;div class="text-wrapper"&gt;&lt;h1&gt;...&lt;/h1&gt;&lt;/div&gt;&lt;div class="text-wrapper p-wrapper"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;&lt;div class="text-wrapper p-wrapper"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; &lt;/main&gt;&lt;footer class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a698805a457e2946aecbabe95d1f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e5bcc90ad9ecf876dbc884341941d7/" rel="bookmark">
			mariadb日志报错：error while loading shared libraries: libjemalloc.so.2处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下找不到so文件的解决办法
rznice 2016-03-11 16:39:27 19494 收藏 1
分类专栏： linux
版权
最近在安装完tengine，在启动tengine时报找不到libjemalloc.so.2的提示，即：
[root@localhost tengine]# sbin/nginx
sbin/nginx: error while loading shared libraries: libjemalloc.so.2:
cannot open shared object file: No such file or directory
首先找找系统中有没有这个文件：
sudo find / -name libjemalloc.so.2
得到如下结果
[root@localhost tengine]# sudo find / -name libjemalloc.so.2
/usr/local/lib/libjemalloc.so.2
/usr/jemalloc/lib/libjemalloc.so.2
上面的那个是系统本身安装的，下面的这个是我自己安装的。
既然有这个文件，我们就把他加入到/etc/ld.so.conf中，打开这个文件发现里面内容如下：
将.so文件路径的目录添加到/etc/ld.so.conf
[root@localhost ld.so.conf.d]# cat /etc/ld.so.conf
include ld.so.conf.d/*.conf
看看/etc/ld.so.conf.d目录下的文件：
[root@localhost ld.so.conf.d]# ls /etc/ld.so.conf.d
kernel-3.10.0-327.4.4.el7.x86_64.conf
dyninst-x86_64.conf
libiscsi-x86_64.conf
kernel-3.10.0-229.20.1.el7.x86_64.conf
mariadb-x86_64.conf
kernel-3.10.0-229.el7.x86_64.conf
kernel-3.10.0-327.10.1.el7.x86_64.conf
vmware-tools-libraries.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98e5bcc90ad9ecf876dbc884341941d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9d27c4818302f802864a3943fb7ff2/" rel="bookmark">
			vscode 常用插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下所用的插件
1. auto close tag 自动关闭标签，在开始标记的结束括号中键入后，将自动插入结束标记
2. Auto Comment Blocks 自动插入注释行
3. Auto Rename Tag 自动重命名配对的HTML / XML标记
4. Auto Complete Tag 结合了自动关闭标签与同时修改同步标签
5. Beautify 美化代码参考资料
6. Code Runner 可以直接运行多种语言的代码片段和文件
7. Code Spell Checker 代码拼写检查工具
8. Document This 自动为TypeScript和JavaScript文件生成详细的JSDoc注释。
9. Debugger for Chrome 从VS Code调试在Google Chrome中运行的JavaScript代码。
10. EditorConfig for VS Code EditorConfig帮助开发人员定义和维护一致的编码风格在不同的编辑器和IDE。
EditorConfig项目包含一个文件格式定义编码风格和文本编辑器插件的集合。
EditorConfig文件易于阅读并且他们与版本控制器很好地合作。
11. ESLint 代码检查工具
12. filesize 实时查看当前文件的大小
13. Quokka.js 一边编写代码一遍编译，实时编译
14. Git History 查看git历史与log，搜索等（包括git log）
15. GitLens — Git supercharged GitLens只是帮助您更好地理解代码。快速浏览一下，为什么以及何时更改了行或代码块。跳过历史记录，以获得有关代码演变的方式和原因的进一步见解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c9d27c4818302f802864a3943fb7ff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c58b86bfe9e334491d67db58127f021f/" rel="bookmark">
			sleep、wait、yield、join——简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sleep、wait、yield、join——简介 1 sleep sleep()方法是Thread类的静态方法，是线程用来控制自身流程的。sleep 过程中线程不会释放锁，会进入阻塞状态（所以线程在指定的时间内肯定不会被执行），让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。sleep 给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会。
2 wait wait 方法属于Object 类，用于线程间的通信。wait 过程中线程会释放对象锁，只有当其他线程调用 notify或 notifyALL()才能唤醒此线程。wait 使用时必须先获取对象锁，即必须在 synchronized 修饰的代码块中使用，并且必须采用synchronized中的对象，那么相应的 notify 方法同样必须在 synchronized 修饰的代码块中使用，如果没有在synchronized 修饰的代码块中使用时运行时会抛出IllegalMonitorStateException的异常。
void waitForSignal() throws InterruptedException { Object obj = new Object(); synchronized(obj) { obj.wait(); obj.notify(); } } 注：
notify方法调用后，只有notify所在的方法执行完后，才释放锁。
3 yield 和 sleep 一样都是 Thread 类的静态方法，都是暂停当前正在执行的线程对象，不会释放资源锁，和 sleep 不同的是 yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态（所以线程有可能在进入到可执行状态后马上又被执行），它只需要等待重新获取CPU执行时间，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。还有一点和 sleep 不同的是 yield 方法只能使同优先级或更高优先级的线程有执行的机会。
区别：
sleep()方法可以放在任何地方使用。wait 使用时必须先获取对象锁，即必须在 synchronized 修饰的代码块中使用。sleep()方法必须捕获异常，而wait()方法不需要捕获异常。wait()被notify()或者notifyAll()唤醒后，先进入阻塞状态（先获得锁），然后进入就绪状态；sleep()被唤醒后，直接就可进入就绪状态（因为sleep没有释放锁，所以无需去获得锁）；yield()不需要唤醒，一直处于就绪状态，获得CPU后继续运行。 4 join join属于Thread类，等待调用join方法的线程结束之后，当前程序再继续执行，一般用于等待异步线程执行完结果之后才能继续运行的场景。例如：主线程创建并启动了子线程，如果子线程中要进行大量耗时运算计算某个数据值，而主线程要取得这个数据值才能运行，这时就要用到 join 方法了。
参考博客：浅谈sleep、wait、yield、join区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e1976be509bfe4c77c8fb5541f9078/" rel="bookmark">
			Cannot uninstall ‘numpy‘问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装excel处理库的时候碰到numpy报错，具体如下
[IT-C02Z2CAXLVCF:temp shaolishuai$ pip install Pandas DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won't be maintained after that date. A future version of pip will drop support for Python 2.7. More details about Python 2 support in pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support Collecting Pandas Using cached https://files.pythonhosted.org/packages/52/ff/912fe03a623a70bcf297d466013a0b4f4c68c3b60f86bf226682d061fc09/pandas-0.24.2-cp27-cp27m-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.macosx_10_10_x86_64.whl Requirement already satisfied: pytz&gt;=2011k in /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python (from Pandas) (2013.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e1976be509bfe4c77c8fb5541f9078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6053c0fcb0722fb93a775e1bc1c98974/" rel="bookmark">
			C&#43;&#43;中的排序函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.sort 头文件：#include &lt;algorithm&gt;
1.1使用sort对数组进行排序 #include&lt;iostream&gt; #include&lt;algorithm&gt; int main() { int a[10] = { 9,6,3,8,5,2,7,4,1,0 }; std::cout &lt;&lt; "before sort: " &lt;&lt; std::endl; for (int i = 0; i&lt;10; i++) std::cout &lt;&lt; a[i] &lt;&lt; " "; std::sort(a, a + 10); std::cout &lt;&lt; std::endl &lt;&lt; "after sort: " &lt;&lt; std::endl; for (int i = 0; i&lt;10; i++) std::cout &lt;&lt; a[i] &lt;&lt; " "; return 0; } ----运行结果： before sort: 9 6 3 8 5 2 7 4 1 0 after sort: 0 1 2 3 4 5 6 7 8 9 请按任意键继续.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6053c0fcb0722fb93a775e1bc1c98974/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1b2fb369b7a554c96ef809511ca992/" rel="bookmark">
			Harbor 重启失败--已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		harbor版本：
v1.10.2
遇到问题：
使用 docker-compose down命令关闭harbor，然后使用./install.sh --with-chartmuseum命令重新安装带chart仓库的harbor，然后发现启动不了，报以下错误：
[Step 5]: starting Harbor ... Creating network "harbor_harbor" with the default driver Creating network "harbor_harbor-chartmuseum" with the default driver Creating harbor-log ... done Creating redis ... Creating registryctl ... Creating harbor-portal ... error Creating chartmuseum ... Creating harbor-db ... Creating registryctl ... error ERROR: for harbor-portal Cannot start service portal: failed to initialize logging driver: dial tcp 127.0.0.1:1514: connect: connection refused ERROR: for chartmuseum Cannot start service chartmuseum: failed to initialize logging driver: dial tcp 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c1b2fb369b7a554c96ef809511ca992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221d0362f9414907752d2bb0530d2bb2/" rel="bookmark">
			Java后端通过代理服务器请求网络资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求 部署在内网服务器的JavaWeb项目，后端需要访问互联网，通过有网络访问权限的另一台服务器的代理转发实现互联网访问。
2.实现 内网设备——设为A，通过外网设备——设为B，访问互联网，需要分别在A和B上进行代理配置。此时它们的相对关系是，A为客户端，B为服务端，A的所有互联网请求均发送给B，B代为转发给目标站点——设为X。X返回的数据亦由B代为转发给A。
后端Java程序一般都使用apache的httpClient进行网络资源请求。通过查资料得知，httpClient使用代理服务器进行网络请求的配置方法大致可以分为两种：
1.配置httpClient参数；
2.配置JVM系统代理（注意，不是操作系统）。
第二种可能主要用于开发环境，如IDEA或eclipse等。这里主要讨论第一种方式。
配置httpClient参数 1.极简模式
// proxyHost -- 代理ip; proxyPort -- 代理端口号;HTTP -- 通讯协议 HttpHost httpProxy = new HttpHost(proxyHost, proxyPort, "HTTP"); CloseableHttpClient httpClient = HttpClients.createDefault(); // url -- 资源路径 HttpPost request = new HttpPost(url); request.setEntity(new StringEntity("上送的报文", "utf-8")); CloseableHttpResponse response = httpClient.execute(httpProxy, request); “这种方式要注意一点：new HttpHost()是支持指定协议类型的，但是httpClient不默认支持socks协议，所以如果我们把上面代码中的协议改成new HttpHost("proxyHost", proxyPort, "SOCKS")，会报错。”——引用自：Richard_易 2018.03.15
2.官方推荐
A. 使用RequestConfig配置类：
// proxyHost -- 代理ip; proxyPort -- 代理端口号;HTTP -- 通讯协议 HttpHost httpProxy = new HttpHost(proxyHost, proxyPort, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/221d0362f9414907752d2bb0530d2bb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4832673acbc8120de60af0c1089f2f8c/" rel="bookmark">
			Docker自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从根本上说，一个容器不过是一个正在运行的进程，并对其应用了一些附加的封装功能，以使其与主机和其他容器隔离。 容器隔离的最重要方面之一是每个容器都与自己的专用文件系统进行交互。 该文件系统由Docker映像提供。 映像包括运行应用程序所需的一切-代码或二进制文件，运行时，依赖项以及所需的任何其他文件系统对象
容器在Linux上本地运行，并与其他容器共享主机的内核。 它运行在一个单独的进程，不占用任何其他进程的内存，从而使其轻巧。
相比之下，VM会产生大量开销，超出了应用程序逻辑所消耗的开销
看一下两者的架构对比图，docker运行在操作系统之上，依赖于宿主机的操作系统，而虚拟机内部则有自己的操作系统
安装docker 之后测试 docker run hello-world ,前提是保证docker已经运行
查看image - docker image ls 或docker images 查看所有容器 docker ps -all
安装好docker环境之后，就可以开发docker 应用了，一般分为三步
1 为容器创建一个镜像
2 组装容器及其依赖的架构成为一个完整的应用
3 测试，分享，部署你创建的容器化应用
1 创建一个docker镜像
# Use the official image as a parent image. FROM node:current-slim from结点代表 依赖的父镜像 的标签 node 冒号后是版本号
# Set the working directory. WORKDIR /usr/src/app workdir指定了之后所有动作从哪个路径执行，这个路径是镜像文件系统的路径，而不是你客户机的文件系统路径 # Copy the file from your host to your current location.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4832673acbc8120de60af0c1089f2f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fdbb2f955f860e0a46c801c34364202/" rel="bookmark">
			react&#43;typescript&#43;高德地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react项目中使用高德地图 基本项目使用create-react-app创建项目，并引入typescript
1. 申请高德key 2. 在index.html中引入高德地图 &lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=申请的key&amp;plugin=AMap.Geocoder"&gt;&lt;/script&gt; 3. 在页面中使用 因为使用了ts所以需要先声明一下高德地图的AMap
不声明的话会出现下图错误
import React, { Component } from 'react'; // 声明AMap，也可以选择在d.ts中声明 declare let AMap: any; 接下来就能愉快的使用高德地图了
const carImg = require('@/assets/img/car.png'); componentDidMount() { // console.log('window.AMap', window.AMap); const map = new AMap.Map('container', { // zoom:11,//级别 // center: [116.4,39.92], resizeEnable: true // viewMode:'3D'//使用3D视图 }); map.clearMap(); // 清除地图覆盖物 // 创建一个 Icon var carIcon = new AMap.Icon({ // 图标尺寸 size: new AMap.Size(35, 35), // 图标的取图地址 image: carImg, // 图标所用图片大小 imageSize: new AMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fdbb2f955f860e0a46c801c34364202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0496e89dfa27c0d20625dfd9bc0bb3e/" rel="bookmark">
			策略模式(Strategy)与状态模式(State)到底有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 世界上并没有完美的程序，但是我们并不因此而沮丧，因为写程序就是一个不断追求完美的过程。
策略模式与状态模式有什么区别呢?
策略模式的意图：定义一系列算法，把它们一个个封装起来，并且相互之间可以替换。
状态模式的意图：允许一个对象在其内部状态改变的情况下，改变其行为。
这两个意图从表面上看好像没什么关系，其实实现过的小伙伴们都知道，它们之间还是很相似的。它们都有一个Context，并且都是Context加载不同的类，并且调用时也都是通过Context调用。并且以上两个意图只是描述了其形式，潜在的目的并没有指出。
对于策略模式，为什么要封装成多个可以相互替换的算法对象呢？就是为了统一调用，即实现接口回调。这样，算法有了，统一的调用框架有了。在使用时只要根据需求，填充需要的算法对象就可以。
对于状态模式，为什么能够在对象内部状态改变时改变其行为呢？是因为在状态改变时，加载了不同的对象，不同的对象当然会有不同的行为了。前提是什么呢？承载状态的框架是稳定的。
策略模式和状态模式都提到了框架，为什么呢？其实他们最主要的意图都是将变化的部分提取出来，封装成各种对象，然后将不变的部分固定成框架，这样形成了一种可插拔的标准模式，使用起来就方便了，而且解耦合，易于扩展。
相同的地方：策略模式通过改变其算法对象，做出不同的行为；状态模式根据状态改变，做出不同的行为。两者都是通过元素的改变，做出不同的行为。
不同的地方：那么区别是什么呢？策略模式需要根据需求来选择实现的策略，而状态模式是根据状态变化而自动改变行为。即策略模式的算法需要被动的被设置，而状态模式的状态是根据条件自动转换的。一个改变是来自于外部选择，另一个的改变是来自于内部的自动判断。
从大的思想上来说，都是取其静，外挂其动。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f6202fbd5573cc3a49cceb0f985b01/" rel="bookmark">
			Hadoop-The variance for this alert is **MB which is 20% of the **MB average (**MB is the limit)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**The variance for this alert is **MB which is 20% of the **MB average (MB is the limit)
1、调整如下阀值
2、检查HDFS文件系统使用率，清空HDFS上的.trash垃圾数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1c451aa6327658f942bc97d3ccd2a0/" rel="bookmark">
			工艺角，PVT, TT,SS,FF,FS,SF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与双极晶体管不同，在不同的晶片之间以及在不同的批次之间，MOSFETs参数变化很大。为了在一定程度上减轻电路设计任务的困难，工艺工程师们要保证器件的性能在某个范围内，大体上，他们以报废超出这个性能范围的芯片的措施来严格控制预期的参数变化。
通常提供给设计师的性能范围只适用于数字电路并以“工艺角”（ProcessCorner）的形式给出。如图，其思想是：把NMOS和PMOS晶体管的速度波动范围限制在由四个角所确定的矩形内。这四个角分别是：快NFET和快 PFET，慢NFET和慢PFET，快NFET和慢PFET，慢NFET和快PFET。例如，具有较薄的栅氧、较低阈值电压的晶体管，就落在快角附近。
从晶片中提取与每一个角相对应的器件模型时，片上NMOS和PMOS的测试结构显示出不同的门延时，而这些角的实际选取是为了得到可接受的成品率。
各种工艺角和极限温度条件下对电路进行仿真是决定成品率的基础。
所以我们所说的ss、tt、ff分别指的是左下角的corner，中心、右上角的corner。
--------------------------------------快乐的分割线------------------------------------
工艺极限 (Process Corner)
如果采用5-corner model会有TT,FF,SS,FS,SF 5个corners。如TT指NFET-Typical corner &amp; PFET-Typicalcorner。其中,Typical指晶体管驱动电流是一个平均值，FAST指驱动电流是其最大值，而SLOW指驱动电流是其最小值（此电流为Ids电流）这是从测量角度解释，也有理解为载流子迁移率(Carrier mobility)的快慢.载流子迁移率是指在载流子在单位电场作用下的平均漂移速度。至于造成迁移率快慢的因素还需要进一步查找资料。单一器件所测的结果是呈正态分布的，均值在TT，最小最大限制值为SS与FF。从星空图看NFET，PFET所测结果,这5种覆盖大约+-3 sigma即约99.73%的范围。对于工艺偏差的情况有很多，比如掺杂浓度，制造时的温度控制，刻蚀程度等，所以造成同一个晶圆上不同区域的情况不同，以及不同晶圆之间不同情况的发生。这种随机性的发生，只有通过统计学的方法才能评估覆盖范围的合理性。
PVT (process, voltage,temperature)
设计除了要满足上述5个corner外，还需要满足电压与温度等条件,形成的组合称为PVT (process, voltage,temperature) 条件。电压如：1.0v+10% ,1.0v,1.0v-10% ; 温度如：-40C, 0C 25C,125C。设计时设计师还常考虑找到最好最坏情况.时序分析中将最好的条件(BestCase)定义为速度最快的情况, 而最坏的条件(WorstCase)则相反。最好最坏的定义因不同类型设计而有所不同。最坏的延迟也不都出现在SS[19] 。至于延迟随PVT发生怎样的变化，还需要进一步查找资料。
根据不同的仿真需要，会有不同的PVT组合。以下列举几种标准STA分析条件[16]：
WCS (Worst Case Slow) : slow process, hightemperature, lowest voltage
TYP (typical) : typical process, nominaltemperature, nominal voltage
BCF (Best Case Fast ) : fast process, lowesttemperature, high voltage
WCL (Worst Case @ Cold) : slow process,lowest temperature, lowest voltage
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f1c451aa6327658f942bc97d3ccd2a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b0b077e2f31269aee210dc60606fb8/" rel="bookmark">
			Docker安装采坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 在windows ubuntu 子系统上安装docker时要选择ubuntu 18.04，如果选择20会出现各种问题
2 为了保证后续不出错 先检查自己的windows版本是不是符合要求
https://docs.microsoft.com/zh-cn/windows/wsl/install-win10 -- 非常重要，否则即使安装成功也会出现
docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "process_linux.go:319: getting the final child's pid from pipe caused \"EOF\"": unknown
的类似错误。
如何是在wsl上安装dokcer，参考
https://nickjanetakis.com/blog/setting-up-docker-for-windows-and-wsl-to-work-flawlessly
这篇帖子，否则参考官网
3 之前看网上教程 如果使用 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 阿里云的镜像安装的话会在/etc/apt/sources.list.d 下创建一个docker.list文件，里面存储了http://mirrors.aliyun.com/docker-engine/apt/repo docker-engine 的 阿里的镜像，这样你之后无论做什么操作，都会从这个镜像安装，然后提示失败，所以如果需要将该条数据删除
4 新手建议严格按照https://docs.docker.com/engine/install/ubuntu/#installation-methods 官方文档安装，英文差的同学可以参考
https://www.runoob.com/docker/ubuntu-docker-install.html 的翻译
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b41afc64181a1e51499b6e80ef3ff34/" rel="bookmark">
			Hadoop用法记录(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建文件夹
在hadoop中创建文件夹
import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; import java.net.URI; import java.net.URISyntaxException; public class ClientDemo1 { public static void main(String[] args) throws Exception { //指定hdfs的位置 URI uri = new URI("hdfs://linux01:9000"); //用户的配置设置对象 Configuration conf = new Configuration(); //当前操作客户端的用户名 String username = "root"; /* 参数1 URI 指定HDFS文件系统的位置 参数2 配置对象 用户的自定义设置 文件上传的副本个数 参数3 用户名 root */ FileSystem fs = FileSystem.newInstance(uri, conf, username); //创建一个文件夹 new File(""); new Path(""); //Path对象是hdfs中对路径的抽象 Path path = new Path("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b41afc64181a1e51499b6e80ef3ff34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78f0c9c2e57d43445d18857dd970e36b/" rel="bookmark">
			调用百度ai接口实现图片文字识别技术DEMO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、第一步，到https://console.bce.baidu.com/
二、创建应用
三、pom.xml里面加入依赖 &lt;!-- json依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20160810&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 四、下面是代码Sample3类的代码 import java.util.HashMap; import org.json.JSONObject; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.baidu.aip.ocr.AipOcr; import com.baidu.aip.run.mapper.KeyWordMapper; @Component public class Sample3{ @Autowired private KeyWordMapper keyWordMapper; // 设置APPID/AK/SK public static final String APP_ID = "自己申请的APP_ID"; public static final String API_KEY = "自己申请的API_KEY"; public static final String SECRET_KEY = "自己申请的SECRET_KEY "; // 初始化用户对象 public static AipOcr init() { // 初始化一个AipOcr AipOcr client = new AipOcr(APP_ID, API_KEY, SECRET_KEY); // 可选：设置网络连接参数 client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78f0c9c2e57d43445d18857dd970e36b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e462e632e38f1e5c6f7296dc0eda084/" rel="bookmark">
			(C#) (.NET)  Spire.XLS读写Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 传统插件过于依赖微软com,可能因服务器没环境而导致报错，所有推荐用Spire.XLS不会过于依赖环境
Spire.XLS特点
Spire.XLS for .NET 支持所有Excel格式类型(97-2003, 2007, 2010)文件。支持Excel文件的新建，修改编辑，单元格拆分合并，属性设置，加锁加密等等excel操作支持数据库导出到Excel工作表，或者把数据从Excel数据导入到数据库；.支持向Excel文件里面写入公式，表格，图片，不同类型的文字，链接，注释甚至VBA等内容；支持将Excel文件转换成PDF, HTML, CSV, Text, XML以及图片格式 咱直接上代码：
//创建1个工作簿，相当于1个Excel文件 //Excel的文档结构是 Workbook-&gt;Worksheet（1个book可以包含多个sheet） using (Workbook workbook = new Workbook()) { Worksheet sheet = workbook.Worksheets["sheet1"]; //添加工作表 workbook.Worksheets.Add("addsheet"); //删除工作表 workbook.Worksheets.Remove("addsheet"); //向A1单元格写入文字 sheet.Range["A1"].Text = "测试数据!"; //将Excel文件保存到指定文件,还可以指定Excel版本 workbook.SaveToFile("Test.xlsx", ExcelVersion.Version2016); } Console.WriteLine("文件写入完成！"); Console.ReadKey(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ba791e3aedf86dc5c4a73676ef9569/" rel="bookmark">
			GoFrame——请求校验Parse()方法返回err之坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GoFrame请求校验Parse方法返回err之坑 代码示例错误分析坑解决办法 学了一部分GoFrame的使用，自己尝试去写项目练习，但是有个知识点搞混了，导致程序异常。
Debug时，发现请求参数是有的，而且也能将参数转换为结构体，但是总是得不到预期结果。
首先去排查err值，但是竟然是个空字符串，就让人摸不着头绪，不知道错误在哪，以下是场景复现。
代码示例 错误代码，标签和消息中间的正确分隔符不是|，而是#。：
// LoginRequest 登录参数 type LoginRequest struct { UserName string `p:"username" v:"required|账号不能为空"` // 分隔符写错 Password string `p:"password" v:"required|密码不能为空"` } func (a *Admin) Login(r *ghttp.Request) { var ( data *LoginRequest err error admin *admin.Entity ) // 问题就出现在这里 err 并没有返回我们期望的错误，而是返回了一个空字符串 if err = r.Parse(&amp;data); err != nil { fmt.Printf("-----err[%s]-----\n", err.Error()) response.FailJSON(true, r, err.Error()) } // 验证登录 admin, err = service.LoginCheck(data.UserName, data.Password) fmt.Println("admin", admin) response.SusJSON(true, r, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ba791e3aedf86dc5c4a73676ef9569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07808eb412445b3bfacc01ac1484bf9c/" rel="bookmark">
			未授权访问漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、resin 1 任意文件读取 默认下Resin的/webapps目录下/resin-doc中包含有一个扩展war文件，远程攻击者可能利用此漏洞读取Web主目录下的任意文件，包括JSP源码或类文件。
payload # viewfile任意文件读取 http://localhost/resin-doc/viewfile/?file=index.jsp # jndi-appconfig inputFile任意文件读取/SSRF http://localhost/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd /resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=远端服务器(Ceye)/内网IP # %20任意文件读取, 通过此漏洞可以读取到串口设备的信息以及网站任意目录的文件遍历。 http://www.example.com:8080/[path]/[device].[extension] http://www.example.com:8080/%20../web-inf http://www.example.com:8080/%20 http://www.example.com:8080/[path]/%20.xtp file参数可读任意文件，index.jsp通常是扫描器扫出，无危害，要读到敏感文件，造成敏感文件泄露的危害，定级为中危。若只能读取无敏感信息的样例文件，定级低危或不收。
敏感文件（系统文件）
/etc/passwd /etc/shadow shadow和passwd都是存用户密码 WEB-INF/web.xml Java servlet文件，通过web.xml文件推测应用组件相关类的名字, 然后在src目录下查找代码, 如果没有源代码可以直接下载class文件反编译即可. /etc/hosts /opt/nginx/conf/nginx.conf /etc/sysconfig/network-scripts/ifcfg-eth1 ~/.bashrc_history /root/.bashrc_history /opt/www/nagios/WEB-INF/nagios.conf /opt/nagios/etc/hostgroup.cfg 修复： 从系统中删除resin-doc.war文件，不要使用默认的配置文件部署。
2 Resin Windows远程目录遍历漏洞 CVE-2006-1953
受影响版本：
Resin v3.0.18 for Windows Resin v3.0.17 for Windows 访问C盘根目录及其之下的任意文件。攻击者还可以指定任意盘符
payload http://victim.com/C:%5C/ http://victim.com/D:%5C/ http://victim.com/E:%5C/ http://victim.com/F:%5C/ Resin viewfile远程文件读取漏洞
针对resin服务的攻击向量整理
二、redis 未授权访问+getshell 原理 redis默认端口6379没有配置账号密码
复现 漏洞靶机需满足两个条件：
用户以root权限使用redisredis客户端连接服务端拥有写权限 -p 参数指定端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07808eb412445b3bfacc01ac1484bf9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d6d14596171d6bb6e78aef3e14e8d5/" rel="bookmark">
			解决flask路由调用函数的尴尬问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 遇到一个问题，之前写了创建评估任务–调用扫描–结果提交漏洞这么一个功能，运行的时候发现创建完评估任务提交一个请求直接执行扫描，不扫完就没有return结果，所以造成了没扫描完不能成功创建评估任务的尴尬局面。
脚本的正常逻辑应该是提交请求–判断合法性–返回结果–执行扫描–提交漏洞
解决办法 先说最后解决的方法
1、最终解决办法–异步调用 参考：python调用异步函数执行
写个装饰器定义多线程函数，在扫描脚本前加装饰器。
scan函数能跟接收请求的svnaddr函数异步执行，这样也能达到先return再scan的效果
def myasync(f): def wrapper(*args, **kwargs): thr = Thread(target=f, args=args, kwargs=kwargs) thr.start() return wrapper @app.route('/svnaddr', methods=['POST']) def svnaddr(): if flag == False: # 判断参数合法性 code = 1 message = str(taskid)+' create success !' handleScan(taskid, repo, model, scantime, status) return_info = {'code':code, 'message':message} return jsonify(return_info) # 扫描 @myasync def handleScan(taskid, repo, model, scantime, status): scan... 搞定！
2、错误方法–全局变量上下文引用 度娘告诉我的。。也许是我问问题的方式不对，这个思路完全误导我。思路是定义一个全局变量，路由接收到请求后传递给全局变量，下面写个scan函数调用这个全局变量
但是写了发现，路由执行完之后并不会接着执行下面的函数。。。下面是错误的写法
def handleScan(taskid, repo, model, scantime, status): scan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d6d14596171d6bb6e78aef3e14e8d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/672f83dc42763fa2b34733d2adb2132f/" rel="bookmark">
			Flutter Another exception was thrown: NoSuchMethodError: The method ‘toDouble‘ was called on null.错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ListView，Column，Row出现这个错误是因为子元素没有设置宽高
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f9fb24d3b9bc68e8638952d7855806/" rel="bookmark">
			springboot注解方式读取配置文件，创建配置文件常量类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、读取配置文件方式 @Value("${...}") private String property; 2、创建配置文件常量类 以创建阿里云OSS常量类为例：
// 当项目已启动，spring接口，spring加载之后，执行接口一个方法 @Component // 实现一个接口 public class ConstantPropertiesUtils implements InitializingBean { // 读取配置文件内容 @Value("${aliyun.oss.file.endpoint}") private String endPoint; @Value("${aliyun.oss.file.keyid}") private String keyId; @Value("${aliyun.oss.file.keysecret}") private String keySecret; @Value("${aliyun.oss.file.bucketname}") private String bucketName; //spring把属性初始化之后会执行此方法 //定义公开静态常量 public static String END_POINT; public static String ACCESS_KEY_ID; public static String ACCESS_KEY_SECRET; public static String BUCKET_NAME; @Override public void afterPropertiesSet() throws Exception { END_POINT = endPoint; ACCESS_KEY_ID = keyId; ACCESS_KEY_SECRET = keySecret; BUCKET_NAME = bucketName; } } 要点： @Component：把配置文件常量类交给SpringBoot容器管理实现InitializingBean接口，重写afterPropertiesSet函数。这个接口的作用是，在初始化bean的时候会执行重写方法，这样就把成员属性赋值给了常量类的静态成员属性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed260fba4af022f5da8409787eae85d8/" rel="bookmark">
			Linux OTA升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux OTA升级，yocto上平台不提供，是需要客户自己集成的，目前yocto上有swupdate、Mender.io、RAUC，swupdate是免费的使用的相对多一些。不过要是有钱的话最好还是用mender.io，mender根据数量不同收费价格不一样。现在介绍一下swupdate的使用。
1.根据当前基线版本，下载相应的swupdate软件。比如我目前用的是morty的基线，下载方法：
git clone https://github.com/sbabic/meta-swupdate.git -b morty
2.将swupdate meta数据添加到layer层
echo "BBLAYERS += \" \${BSPDIR}/sources/meta-swupdate \"" &gt;&gt; $BUILD_DIR/conf/bblayers.conf
3.编译
bitbake swupdate 由于ota升级会涉及到修改uboot环境变量，所以还需要添加 u-boot-fw-utils软件
bitbake u-boot-fw-utils
根据swupdate官网的说明，uboot需要至少2016.05以上的版本，因为我之前用的分支krogoth对应的uboot版本是2016.03，所以后来我就升级了基线，将uboot版本升级到2017.03版本，否则的话编译swupdate时会报错。
cxt@ubuntu:~/code/nxp/imx6ull_morty/imx6ullevk_build/tmp/work/cortexa7hf-neon-poky-linux-gnueabi/swupdate/2017.01-r0/git$ ls
archival corelib handlers Kconfig Makefile.flags parser scripts swupdate_unstripped tags
COPYING doc include Makefile Makefile.help progress_client suricatta swupdate_unstripped.map www
core examples ipc Makefile.deps mongoose README.md swupdate swupdate_unstripped.out
成功编译之后 会生成swupdate的bin文件，对编译结果打包放进rootfs文件系统。
IMAGE_INSTALL_append += "cmake python3 python3-pip swupdate swupdate-www u-boot-fw-utils”
配置完成开机会默认启动swupdate，启动信息：
Starting swupdate ...
Swupdate v2017.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed260fba4af022f5da8409787eae85d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30fe6636608533b1183b07873529b9b/" rel="bookmark">
			%02x与%2x 之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出最小宽度
用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0(当最小宽度数值以0开头时)。
X 表示以十六进制形式输出
02 表示不足两位，前面补0输出；如果超过两位，则实际输出
举例：
printf("%02X", 0x345); //打印出：345
printf("%02X", 0x6); //打印出：06
而如果直接写为 %2x，数据不足两位时，实际输出，即不额外补0输出； 如果超过两位，则实际输出。
printf("%2X", 0x345); //打印出：345
printf("%2X", 0x6); //打印出：6
例子：
#include &lt;stdio.h&gt;
int main()
{
int i = -20;
for(i = -20; i &lt; 21; i++)
{
printf("%2x\n", i);
printf("%02x\n", i); }
return 0;
}
输出结果：
ffffffec
ffffffec
ffffffed
ffffffed
ffffffee
ffffffee
ffffffef
ffffffef
fffffff0
fffffff0
fffffff1
fffffff1
fffffff2
fffffff2
fffffff3
fffffff3
fffffff4
fffffff4
fffffff5
fffffff5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30fe6636608533b1183b07873529b9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec0b5061021ff52fe634ea34a27560a/" rel="bookmark">
			springboot &#43; shiro 开发api，小程序添加业务域名 校验文件设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次开发小程序api ，得知需要下载校验文件到服务器。 自己采用的springboot+shiro 访问静态文件配置太繁琐。域名又绑定了自己的api ，所以文件存放在哪里 一直比较头疼。 值得庆幸的是 校验文件可以配置一次，校验成功以后可以删除。 那就使用nginx先配置二级域名指定校验文件， 当校验通过以后，再将二级域名指向自己的api
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73ef5d0b1e49fdcf08fb1a121b3ec30/" rel="bookmark">
			web页面uri唤醒应用_带有数据URI的高性能Web设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web页面uri唤醒应用
我们最近在Webdesigntuts +上介绍了Web设计中的数据URI的内容，原因和方式 ，在其中研究了使用数据URI进行性能友好的界面设计的一些可能性。 在今天的Premium教程中，我们将采用介绍性文章中介绍的一些理论，以一些用于开发完全实现的用户界面的示例为基础。 为了使事情有趣，我们还将使我们的设计具有响应性，并且将使用Dribbble API和jQuery从Envato Dribbble feed中提取一些图像。 有很多要讲的内容，所以让我们开始吧！ 开始之前 正如我已经提到的那样，本教程基于Web设计教程中的数据URI的内容，原因和方式 。 即使您对数据URI的了解已经扎实，我还是强烈建议您在开始此处之前先阅读本文。 我将使用初始文章中的练习中的一些代码来节省时间，因此，我将要求您在以下几点上跳回到原始文章。 其次，在该项目中，我们将严重依赖数据URI，以便为您提供大量使用此技术的实践。 是否实际在生产中大量使用数据URI还是有争议的（尤其是如果支持&lt;IE7），因此请记住，数据URI只是工具箱中的另一个工具，这些技术不一定适合每种情况。 最后，该项目在Webkit，Firefox和Internet Explorer的最新版本中进行了测试。 您可以放心地假定此接口在IE7及以下版本中将无法完全发挥作用（尽管如果需要，可以很容易地将后援应用于旧版IE版本）。 此外，在本教程中，我将引用-webkit和CSS3元素的通用前缀，但是源文件将包含所有供应商前缀。 关于数据URI的两分钟回顾 在开始破解之前，让我们快速回顾一下数据URI方案是什么，以及为什么它可以作为向浏览器提供元素的好选择，这些元素通常会消耗资源并降低性能。 数据URI是一种将二进制数据编码为ASCII文本字符串的方式，现代浏览器可以读取和呈现该字符串。 数据URI通常用于替换图像文件，但是可以对任何二进制数据进行编码，包括SVG，多媒体，字体等。 使用数据URI的主要好处是减少了在浏览器窗口中加载页面所需的HTTP请求数量。 简而言之，每增加一个HTTP请求（通常）都会对网站的整体性能产生负面影响。 数据URI比标准文件类型（例如JPG图像）大33％左右，但通过压缩和gzip压缩，该数量通常减少到5％以下。 这个额外的文件大小通常不是一个大问题，但是在选择最佳技术以将资产包含到设计中时要牢记这一点。 数据URI冗长，毫无意义，看起来也不是很漂亮，使得标记和样式表难以阅读，浏览和维护。 最好在文本编辑器中使用代码折叠！ 进攻计划 本教程将分为三个单独的阶段，我们将按以下顺序进行处理： 使用HTML和CSS中的参考图片设计“全角”网站。 从Dribbble API和jribbble jQuery插件中提取图像 添加媒体查询以使站点在较小的视口中响应。 好的！ 聊够了！ 让我们开始编码吧！ 步骤1：初始标记 对于我们的设计，我们将以最新HTML5 Boilerplate作为起点。 我们不会在项目中使用样板的所有功能（例如，现代化脚本或分析），但是最好在初始阶段保持“原样”，然后在项目后期返回以减少我们最终没有使用的功能（或者将来可能不会使用）。 在还包含css和js文件夹的目录中创建一个新的index.html文件。 在文档的&lt;body&gt;中，添加&lt;header&gt; ，精选内容&lt;div&gt;和&lt;footer&gt; 。 我们将继续进行充实。 &lt;!DOCTYPE html&gt;&lt;!-- HTML5 Boilerplate content goes here --&gt;&lt;head&gt;&lt;title&gt;Albireo: Designing With Data URIs&lt;/title&gt;&lt;link rel="stylesheet" href="css/style.css"&gt;&lt;!-- HTML5 Boilerplate content goes here --&gt;&lt;/head&gt;&lt;body&gt;&lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73ef5d0b1e49fdcf08fb1a121b3ec30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23e12867d0a98889836292b20298103/" rel="bookmark">
			Java：compareTo()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先compareTo()是String的比较方法，int类型不可用，直接用大于小于等于基本符号比较。如果有特殊需要，可以把int用String.valeOf(int num)转换成String类型，比如说leetcode的179题“最大数”。
调用compareTo()一般可以分为以下的几种情况：
s1.compareTo(s2)：
1.首字母不同，返回首字母的asc码差值，s1 - s2的值
2.首字母相同就继续往下比较，如果比较到了一个不同的asc码值，比如s1 = “abc”,s2 = “abb”，就返回c - b的asc码差值
3.在上一情况中，如果比较到了其中一个字符串的结束（比如s1 = “abc”,s2 = “abc12293”），还没有找到对应不同的asc码，就返回字符串的长度之差：s1.length() - s2.length()
总的来说，如果可以按asc码值来规定大小，那么：
compareTo() &gt; 0，说明s1 &gt; s2【可能是asc码值之差，也可能是部分相等后的长度之差（情况3）】；compareTo()==0，说明是上述第三种情况，且两个字符串长度也相等，即完全相等；compareTo() &lt; 0，说明s1 &lt; s2【三个情况都有可能】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c185355a985295615f6480417968b0e/" rel="bookmark">
			Leetcode 421. 数组中两个数的最大异或值 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Leetcode 421. 数组中两个数的最大异或值 题目 给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai &lt; 231 。
找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i, j &lt; n 。
你能在O(n)的时间解决这个问题吗？
示例: 输入: [3, 10, 5, 25, 2, 8] 输出: 28 解释: 最大的结果是 5 ^ 25 = 28. 测试样例 前缀树
我们可以根据每个数位建立一个前缀数。对于当前的数，从高位到低位，我们尽可能的遍历和自己数位不同的结点，显然就是得到当前数异或的最大值。详细过程见代码
代码 struct Tree{ Tree* zero; Tree* one; int value; Tree(){ zero = NULL; one = NULL; } }; class Solution { public: int findMaximumXOR(vector&lt;int&gt;&amp; nums) { int n = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c185355a985295615f6480417968b0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/568a37ba4e2718a341510be8ee49378a/" rel="bookmark">
			K8s &#43; Docker 部署ELK日志系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8s + Docker 部署ELK日志系统，分布式/微服务架构下必备技能！
前提：假定你已经安装并集成好docker、docker私服和k8s基础环境！
部署Elasticsearch
1、基于官方docker部署的文档进行k8s集成，官方文档地址如下：
https://www.elastic.co/guide/en/elasticsearch/reference/7.8/docker.html ELK集成需要配套版本号，这里统一为：7.8.0版本（如果不想使用官方的镜像，自己制作也是可以的）。
2、确定运行es的节点服务器，例如node7，给对应的节点打上运行es的标签，执行如下命令：
kubectl label nodes node7 deploy.elk=true 3、在node7节点创建绑定目录，并授权：
mkdir -p /opt/apps-mgr/es/ chmod -R 777 /opt/apps-mgr/es 4、系统内核优化，使之符合es的生产模式：
vi /etc/security/limits.conf，然后末尾追加：--ulimit - nofile 65535 vi /etc/security/limits.conf，然后末尾追加：--ulimit - nproc 4096 vi /etc/fstab，然后注释所有包含swap的行 vi /etc/sysctl.conf，然后末尾追加：vm.max_map_count=262144，执行sysctl -p生效 5、从docker官方私服拉取镜像，并推送镜像到内部私服：
docker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.0 docker tag docker.elastic.co/elasticsearch/elasticsearch:7.8.0 10.68.60.103:5000/elasticsearch:7.8.0 docker push 10.68.60.103:5000/elasticsearch:7.8.0 注意：10.68.60.103:5000修改为你自己的私服地址。
6、编写es-deployment.yaml文件，内容如下：
apiVersion: apps/v1 kind: Deployment metadata: name: es-deployment namespace: my-namespace labels: app: es-deployment spec: replicas: 1 selector: matchLabels: app: es-pod template: metadata: labels: app: es-pod spec: nodeSelector: deploy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/568a37ba4e2718a341510be8ee49378a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b19902e57ecd646393bcc89bd5e65b0/" rel="bookmark">
			小程序canvas绘制图片并保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇小程序分享，体验不是很好。因为用户点击去分享时，canvas绘制并转换成图片需要一定的时间，用户视觉等待的时间有点长。为了更好的优化这一体验，我们可以这么做：
1、用户点击去分享，先用页面标签将海报图绘制出来；
2、当用户点击保存的时候，我们执行绘制canvas绘制，canvas转换图片，保存图片的过程。
一、用页面标签把海报图画出来，这个不需要讲解了，前端都能做到；
二、我们详细讲解一下canvas绘制的思路：
1、配置海报上的信息，需要绘制什么内容
2、用户点击保存按钮
// 点击保存事件
saveImgHandler() {
if(this.data.shareInviteImage){
this.saveInviteCanvas()
}else{
this.drawInviteCanvas(this.data.InviteOption).then( () =&gt; {
this.saveInviteCanvas() // canvas保存本地相册
})
}
},
// 绘制
drawInviteCanvas (params) {
let that = this
return new Promise(function (resolve, reject) {
CanvasInvite.call(that,params).then((url) =&gt; {
if (url) {
resolve(url)
that.setData({
shareInviteImage: url,
})
} else {
reject(0)
}
},this);
})
},
// canvas保存本地相册
saveInviteCanvas() {
let that = this
wx.showLoading({
title: ‘’,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b19902e57ecd646393bcc89bd5e65b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ba31364c0b5f10da2f1fe1fa8a0ae9/" rel="bookmark">
			cocos vscode&#43;luaide 断点调试配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
每次都被调试，搞得头大，记忆力不好，每次也都忘记配置流程，写个博客，帮助大家也帮助自己。
需要的软件：vscode 、luaide、vsstudio(这个可要，可不要，我的配置并没有用到)
1、安装vscode 这个官网直接下载就可以了
2、安装luaide (卸载或关闭其他的lua工具) 直接在vscode商城里下载即可
注意的地方：
exepath，填写exe生成的地方。换成自己的路径
ide点击调试的时候，加入LuadegJni文件
3、调试代码，在入口文件里第一句就加入
local breakSocketHandle,debugXpCall = require("src/LuaDebugjit")("localhost",7003)
再在__G__TRACKBACK__ 函数里，加入debugXpCall()
4、打断点，启动调试
5、启动自己的exe或者启动vsstudio，程序在断点处会调试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97007d48d8fc4a8923f1250829cde2aa/" rel="bookmark">
			Qt学习之路——Qt软件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于未来用到Qt的可能性 比 VSS 更高，下载Qt 来学习学习 未雨绸缪，话不多说，先安个软件。
Qt安装 1、Qt安装网址（http://download.qt.io/archive/qt/5.14/5.14.2/）
Windows下安装，话说官网下安装也没感觉很慢（10min）
2、安装教程（http://c.biancheng.net/view/3858.html） 安装教程很详细（5.9版）简单通用就是点点点。不过开始安装的时候记得断网，那样不需要登录。安装勾选、文件介绍，教程里有
3、安装完成
Qt Creator ：一大堆文件 请认准Qt Creator 4.11.1 然后就移步看Qt Creator初步使用
Qt Creator初步使用 1、界面介绍（http://c.biancheng.net/view/1804.html）
嗯...自带的设置都是对的 主要是要看一下编译器有没有问题
2、睡一觉想想
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/229/">«</a>
	<span class="pagination__item pagination__item--current">230/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/231/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>