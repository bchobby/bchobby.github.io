<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f798eb656ab18387179da9b5a1ca2820/" rel="bookmark">
			解决WPF中关闭子窗体时，其父窗体自动最小化的问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WinShowTest wintest = new WinShowTest ()；
wintest .Show();
这样的代码，在关闭wintest 时，会把其父窗体自动最小化。
解决办法：在关闭子窗体时，激活其父窗体，如下代码：
WinShowTest wintest = new WinShowTest ()；
wintest .Closed += (a, b) =&gt; { this.Activate(); };
wintest .Show();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ce3f0f0e0f1b40d26cdea3e7e7bbed/" rel="bookmark">
			STS设置字体大小颜色，背景色，编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 STS设置字体大小，背景色，编码 设置字体大小 第一步：
菜单选项：window ====&gt; preference
第二步：General ===&gt; Appearance =&gt; Colors and Fonts =&gt; Basic
第三步：Basic =&gt; Text Font
背景色 workspace编码设置为UTF-8 JSP文件编码设置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9657e2dc98a5a9c5cf9bba12b19873fe/" rel="bookmark">
			TensorFlow2.x 学习笔记(八)过拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过拟合与欠拟合 Model capacity 当模型的复杂度增强时，模型的表达性也随之增强，以多项式为例
y = β 0 + β 1 x + β 2 x 2 + . . . + β n x n + ϵ y = \beta_0 + \beta_1x + \beta_2x^2 + ... + \beta_nx^n + \epsilon y=β0​+β1​x+β2​x2+...+βn​xn+ϵ
随着阶数的增加，可表示的模型也就越多，模型的表示能力也就越强。
Underfitting model capacity &lt; ground truthtrain loss/acc is badtest loss/acc is bad as well Overfitting model capacity &lt; ground truthtrain loss/acc is goodtest loss/acc is badgeneralization performance is bad detect and reduce Splitting Train/Val/Test Set (x, y), (x_test, y_test) = datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9657e2dc98a5a9c5cf9bba12b19873fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f4bd73cf94dfefb01882f89e101c69/" rel="bookmark">
			北大陆俊林计算机组成原理第五章知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.1
略
5.2
第一版4位乘法器
使用了八位被乘数寄存器 四位乘数乘数寄存器 八位积寄存器 八位ALU
工作过程：
首先检查乘数寄存器的最后一位，如果为1则积寄存器和被乘数寄存器相加存入积积寄存器，如果为0则跳过，将被乘数寄存器左移，乘数寄存器右移，最后判断是不是到了第4次循环，到4次循环则完成退出
5.3 5.4
优化1：
同时进行移位和内容相加操作
优化2:
被乘数寄存器缩减为4位且取消移位操作
8位ALU改为4位
取消乘数寄存器
初始将乘积寄存器高4位，低4位存乘数寄存器，随着运算过程不断右移
5.5 5.6
第一版4位除法器
一个八位除数寄存器 一个四位商寄存器 一个八位余数寄存器 一个八位ALU
工作过程：
首先将被除数放入余数寄存器 将除数放入除数寄存器高四位，用ALU执行余数-除数运算，若小于0则回退该操作商左移添0，否则商左移添1，除数右移1位，判断是否是第N+1次循环，是则结束
5.7
优化：
缩小除数寄存器，取消右移操作
缩小ALU
取消商寄存器
余数寄存器的低32位改为存储商，增加左移功能，增加右移功能为进行回退操作
----个人自用整理分享 仍在学习之中 有错误与不足欢迎指正交流----
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f89fabb5c0bc387c3584056e6f4f6a3/" rel="bookmark">
			贪心法——TSP问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最邻近点策略 /* * problem: TSP（最邻近点策略） * method: 贪心法 * date: 2020/05/12 */ #include&lt;iostream&gt; using namespace std; const int INF=10e5; const int MAX_N=20; int arc[MAX_N][MAX_N]= {{INF,3,3,2,6}, {3,INF,7,3,2}, {3,7,INF,2,5}, {2,3,2,INF,3}, {6,2,5,3,INF} }; int flag[MAX_N]; int n=5; int TSP(int x) { int tsp=0,i,j,k,u,v; u=x;//从x出发 flag[u]=1; for(i=0; i&lt;n-1; i++) { int min=INF; for(j=0; j&lt;n; j++) { if(flag[j]==0&amp;&amp;arc[u][j]&lt;min) { min=arc[u][j]; v=j; } } tsp+=min; flag[v]=1; cout&lt;&lt;u+1&lt;&lt;"--&gt;"&lt;&lt;v+1&lt;&lt;endl; u=v; } tsp+=arc[v][x]; cout&lt;&lt;v+1&lt;&lt;"--&gt;"&lt;&lt;x+1&lt;&lt;endl; return tsp; } int main() { cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f89fabb5c0bc387c3584056e6f4f6a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198609abf57f146f839f37ab468d4e65/" rel="bookmark">
			C&#43;&#43; 变量‘XXX’不是类型名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++有时会报 变量‘XXX’不是类型名 的bug，如下：
主要原因是：
c语言中不允许在函数外部给全局变量赋值
把变量赋值写到函数里就解决了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca66aabf1909fab3d9e90690e70e2bc0/" rel="bookmark">
			oracle连接失败的原因总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置错误
尤其需要注意URL地址是否正确。再次注意用户名及密码。
详细配置 jdbc.driver:oracle.jdbc.driver.OracleDriver jdbc.url:jdbc:oracle:thin:@url地址:端口号（1521常用）:orcl 例：jdbc.url:jdbc:oracle:thin:@192.168.9.165:1521:orcl jdbc.username:用户名 jdbc.password:密码 2、如果是远程服务器，查看是否防火墙关闭
远程服务器的话，可能因为防火墙拦截，导致oracle数据库连接不上。
不关闭防火墙的话，也可设置服务器的入站或者出站规则，放行。
3、查看服务器Oracle监听是否开启
在服务中查看Oracle监听服务是否开启。
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
如有不准确或需要补充的，可以评论区留言。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4998d58a175bdad474fd876e089dbe2c/" rel="bookmark">
			代码执行流水之循环展开优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
流水线定义
指令执行流水
指令流水图
循环展开优化
引言 详细的流水线分析大家可以参考：计算机体系结构——流水线技术（Pipelining）。本篇只是由探讨循环展开如何提高代码执行效率延申过来的，因此只说明基本的流水线定义以及关于循环展开的部分。
流水线定义 计算机中的流水线是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。由于这种工作方式与工厂中的生产流水线十分相似， 因此称为流水线技术，从本质上讲，流水线技术是一种时间并行技术。
流水线工作设计 基本思想：延伸重叠方式，使指令解释过程进一步细化，提高各部件的利用率，以提高指令执行速度理想目标：完成任务的时间与其中某个指令执行时间无关，只与指令执行的频率有关（假设一个任务有n个指令，将完成一个指令分为m个段，每段执行时间为△t ，则理想目标是完成任务的时间是T=m△t+(n-1)△t；当n &gt;&gt; m时，T=(n-1)△t。 指令执行频率为 1 / △t： 即 与m无关，只和指令执行的速度△t有关） 指令执行流水 取指：
指令取指（InstrucTIon Fetch）是指将指令从存储器中读取出来的过程。
译码：
指令译码（InstrucTIon Decode）是指将存储器中取出的指令进行翻译的过程。经过译码之后得到指令需要的操作数寄存器索引，可以使用此索引从通用寄存器组（Register File，Regfile）中将操作数读出。
执行：
指令译码之后所需要进行的计算类型都已得知，并且已经从通用寄存器组中读取出了所需的操作数，那么接下来便进行指令执行（InstrucTIon Execute）。指令执行是指对指令进行真正运算的过程。譬如，如果指令是一条加法运算指令，则对操作数进行加法操作；如果是减法运算指令，则进行减法操作。
在“执行”阶段的最常见部件为算术逻辑部件运算器（ArithmeTIc Logical Unit，ALU），作为实施具体运算的硬件功能单元。
访存：
存储器访问指令往往是指令集中最重要的指令类型之一，访存（Memory Access）是指存储器访问指令将数据从存储器中读出，或者写入存储器的过程。
写回：
写回（Write-Back）是指将指令执行的结果写回通用寄存器组的过程。如果是普通运算指令，该结果值来自于“执行”阶段计算的结果；如果是存储器读指令，该结果来自于“访存”阶段从存储器中读取出来的数据。
指令流水图 横坐标：表示时间，即各个任务或指令在流水线中 所在该时刻所对应的子过程
纵坐标：表示某个任务或某条指令，即流水线依次 处理的任务或指令
循环展开优化 在流水线中，往往因为指令顺序安排不合理而导致CPU等待空转，产生延迟，影响流水线效率。
解决办法：循环展开和指令调度
前提假设：假设采用MIPS的5段整数流水线：
 分支的延迟：1个时钟周期。
 整数load指令的延迟：1个时钟周期。
 整数运算部件是全流水或者重复设置了足够的份数。
从例题入手理解：
例: 对于下面的源代码，转换成MIPS汇编语言， 在不进行指令调度和进行指令调度两种情况下，分析其代码一次循环所需的执行时间。
for (i=1024； i&gt;=0； i--) x[i] = x[i] + s; Loop：L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4998d58a175bdad474fd876e089dbe2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa24c0ee52fcef35f54661961bf5f001/" rel="bookmark">
			RS485通信与Modbus协议 附源码下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RS485通信与Modbus协议 附源码下载 RS485通信的特点 1、采用差分信号。
2、RS485通信速率快，最大传输速率可以达到10Mb/s以上。
3、RS485内部采用平衡驱动器和差分接收器的组合，抗干扰能力大大增加。
4、传输距离最远可以达到1200米左右。
5、可以在总线上进行联网多机通信。
6、RS485接口非常简单。
常用硬件接口 为MAX485,电路见下图
RS-485采用平衡发送和差分接收，因此具有抑制共模干扰的能力。RS-485采用半双工工作方式，任何时候只能有一点处于发送状态，因此，发送电路须由使能信号加以控制。RS-485用于多点互连时非常方便，可以省掉许多信号线。应用RS-485可以联网构成分布式系统，其允许最多并联32台驱动器和32台接收器。在RS232或RS485设备联成的设备网中，如果设备数量超过2台，就必须使用RS485做通讯介质，RS485网的设备间要想互通信息只有通过“主（Master）”设备中转才能实现，这个主设备通常是PC，而这种设备网中只允许存在一个主设备，其余全部是从（Slave）设备。
RS485现在多采用的是两线制接线方式，这种接线方式为总线式拓朴结构在同一总线上最多可以挂接32个结点。在RS485通信网络中一般采用的是主从通信方式，即一个主机带多个从机。很多情况下，连接RS-485通信链路时只是简单地用一对双绞线将各个接口的“A”、“B”端连接起来。而忽略了信号地的连接，这种连接方法在许多场合是能正常工作的，但却埋下了很大的隐患，这有二个原因：
(1)共模干扰问题：RS-485接口采用差分方式传输信号方式，并不需要相对于某个参照点来检测信号，系统只需检测两线之间的电位差就可以了。但人们往往忽视了收发器有一定的共模电压范围，RS-485收发器共模电压范围为-7～+12V，只有满足上述条件，整个网络才能正常工作。当网络线路中共模电压超出此范围时就会影响通信的稳定可靠，甚至损坏接口。
(2)EMI问题：发送驱动器输出信号中的共模部分需要一个返回通路，如没有一个低阻的返回通道（信号地），就会以辐射的形式返回源端，整个总线就会像一个巨大的天线向外辐射电磁波。由于PC机默认的只带有RS232接口，有两种方法可以得到PC上位机的RS485电路：（1）通过RS232/RS485转换电路将PC机串口RS232信号转换成RS485信号，对于情况比较复杂的工业环境最好是选用防浪涌带隔离珊的产品。（2）通过PCI多串口卡，可以直接选用输出信号为RS485类型的扩展卡。
Modbus通信协议介绍 1、Modbus产生的背景。
2、Modbus协议特点。
3、RTU协议帧数据
4、Modbus功能码
读保持寄存器数据结构
文件 列表:.
│ MAX485.pdf
│ MODBUS协议中文版.pdf
│ Modbus注意要项.pdf
│ Modbus通信协议.pdf
│ ├─Modbus调试精灵
│ └─例程源代码
├─1
│ │ 51单片机串口驱动实现功能示例
│ │ ├─2
│ RS485的Modbus通讯收发功能示例
│ │ ├─3(CRC低字节在前)
│ 基于RS485的Modbus通信示例 │ 支持Modbus协议的寄存器读取和单寄存器写入操作
│ └─4
│ 描 述：Modbus协议实现校时 │ 利用Modbus调试精灵的写寄存器功能，可修改日期时间的每一个字节 │ 寄存器地址0x0000～0x0006分别对应“年/月/日/时/分/秒/星期” │ RS485方向控制信号由原来的P1.7改为P2.0，因本例使用了DS1302而未使用按键
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a5579445245e817adca3fbf3852bc6/" rel="bookmark">
			十九、CombineTextInputFormat切片机制源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CombineTextInputFormat切片机制 1、思考？ 框架默认的TextInputFormat切片机制是对任务按文件规划切片，不管文件多小，都会是一个单独的切片，都会交给一个MapTask，这样如果有大量小文件，就会产生大量的MapTask，处理效率极其低下。
2、CombineTextInputFormat应用场景 CombineTextInputFormat用于小文件过多的场景，它可以将多个小文件从逻辑上规划到一个切片中，这样，多个小文件就可以交给一个MapTask处理
3、虚拟存储切片最大值设置 它决定了切块与切片：
CombineTextInputFormat.setMaxInputSplitSize(job, 4194304);// 4m
注意：虚拟存储切片最大值设置最好根据实际的小文件大小情况来设置具体的值。
4、切片机制过程 生成切片过程包括：虚拟存储过程和切片过程二部分。
（1）虚拟存储过程：将输入目录下所有文件大小，依次和设置的setMaxInputSplitSize值比较，如果不大于设置的最大值，逻辑上划分一个块。如果输入文件大于设置的最大值且大于两倍，那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值2倍，此时将文件均分成2个虚拟存储块（防止出现太小切片）。
例如setMaxInputSplitSize值为4M，输入文件大小为8.02M，则先逻辑上分成一个4M。剩余的大小为4.02M，如果按照4M逻辑划分，就会出现0.02M的小的虚拟存储文件，所以将剩余的4.02M文件切分成（2.01M和2.01M）两个文件。
（2）切片过程：
a）判断虚拟存储的文件大小是否大于setMaxInputSplitSize值，大于等于则单独形成一个切片。 （b）如果不大于则跟下一个虚拟存储文件进行合并，共同形成一个切片。 （c）测试举例：有4个小文件大小分别为1.7M、5.1M、3.4M以及6.8M这四个小文件，则虚拟存储之后形成6个文件块，大小分别为： 1.7M，（2.55M、2.55M），3.4M以及（3.4M、3.4M） 最终会形成3个切片，大小分别为： （1.7+2.55）M，（2.55+3.4）M，（3.4+3.4）M 二、代码实操 1、只是在简单mr中设置如下两个步骤，就不在这里放出代码了，给出代码地址。主要是演示文件 （a）驱动类中添加代码如下： // 如果不设置InputFormat，它默认用的是TextInputFormat.class job.setInputFormatClass(CombineTextInputFormat.class); //虚拟存储切片最大值设置4m CombineTextInputFormat.setMaxInputSplitSize(job, 4194304); 三、源码阅读注释 1、CombineTextInputFormat重写了切片函数，在切片之前先进行了切块操作 //必须设置如下参数 //job.setInputFormatClass(CombineTextInputFormat.class); //CombineTextInputFormat.setMaxInputSplitSize(job, 4194304); 2、进入CombineTextInputFormat 类中发现没有太多代码，需要进去父类CombineFileInputFormat中，这里重写了切片机制 //1.进入切片函数，省略非部分非主要代码 public List&lt;InputSplit&gt; getSplits(JobContext job) throws IOException { long maxSize = 0L; Configuration conf = job.getConfiguration(); if (this.maxSplitSize != 0L) { maxSize = this.maxSplitSize; } else { //2.获取分块界限值 maxSize = conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1a5579445245e817adca3fbf3852bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2a7d6b36b3bf8e314074c8029d52bf/" rel="bookmark">
			Fortran编程：（一）认识Fortran
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Fortran
Fortran语言是Formula Translation的缩写，意为“公式翻译”，是一种编译型语言。
Fortran语言是世界上第一个被正式推广使用的高级语言。它是1954年被提出来的，1956年开始正式使用，直到2014年已有六十年的历史，但仍历久不衰，它始终是数值计算领域所使用的主要语言。
经过长期的发展，Fortran出现许多的版本，F77，F90，F95，F2003等，每一个版本都经过了完善和改进。
二、特点
优点 •简单，相比C++而言更易于掌握 •接近自然的数学语言 •矩阵运算功能强大，自有复数运算 •语法严格，适合严谨的科学计算 •编译型语言，执行效率高 •并行计算的最佳选择 缺点 •可视化开发效率低，效果不理想 •比较底层，各种算法功能都需要自己实现 相比于C/C++、Python、Java和PHP等主流编程语言，Fortran有着其稳定的受众，即科学计算领域。
三、适用领域
一般而言，由于Fortran的设计初衷是为解决科学数值计算问题，有着强大的矩阵运算能力和复数运算，因此其适用领域也注定了。
主要的领域有：物理（核物理、凝态物理等）、气象、流体、地震（地震勘探、地球物理等）……这些领域有个共同特点就是需要进行大规模的数值计算。
四、尾言
Fortran作为一种古老的编程语言，有着其独特的魅力和作用，现在网上有很多人说Fortran是一门过时的语言，应该被时代淘汰，笔者认为Fortran语言被淘汰还为时过早，它仍然在其独特的领域发挥着其作用，散发着它的光芒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1d9a565951382c6e58c2c9d9f59fc3/" rel="bookmark">
			javascript学习笔记（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、学习资料 https://wangdoc.com/javascript/index.html
二、学习笔记 javascript学习笔记（2）
9、事件 1）监听函数内部的this，指向当前事件所在的那个对象。
2）JavaScript 有三种方法，可以为事件绑定监听函数：
①HTML 的 on- 属性：只会在冒泡阶段触发。完整的监听代码（doSomething () ）。不利于代码分工，因此不推荐使用。
②元素节点的事件属性：只会在冒泡阶段触发。值是函数名（doSomething）。缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。
③EventTarget.addEventListener()：同一个事件可以添加多个监听函数。能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。推荐！
3）事件的传播：捕获阶段-》目标阶段-》冒泡阶段
4）事件的代理：父元素统一处理子元素的事件（因为冒泡向上传播）
5）如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。
6）如果想要彻底取消该事件，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。
7）事件的原始触发节点（Event.target），事件当前正在通过的节点（Event.currentTarget）。e.currentTarget总是等同于监听函数内部的this。
8）点击鼠标触发顺序：mousedown、mouseup、click、dblclick
9）mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。两者的区别是，mouseenter事件只触发一次，而只要鼠标在节点内部移动，mouseover事件会在子节点上触发多次。
10）如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下：
keydown
keypress（有值才会触发这个事件）
keydown
keypress
…（重复以上过程）
keyup
11）error事件有一个特殊的性质，就是不会冒泡。所以，子元素的error事件，不会触发父元素的error事件监听函数。
12）input事件在元素的值发生变化后立即发生，而change在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，input事件会触发多次，而change事件只在失去焦点时触发一次。
13）拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。
10、浏览器模型 1）脚本的执行顺序由它们在页面中的出现顺序决定，加载顺序是并行的。
2）一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。
3）Cookie 不是一种理想的客户端储存机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端储存应该使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。
4）浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。
5）两个网址只要域名相同和端口相同（不要求协议相同），就可以共享 Cookie。
6）cookie同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。
7）cookie规避同源限制：如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置document.domain共享 Cookie。
8）对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题：片段识别符、
跨文档通信API（postMessage）
9）除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），AJAX有三种方法规避同源限制：
①JSONP：callback，只能发GET请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。
②WebSocket：Origin
③CORS：允许任何类型的请求。实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba1d9a565951382c6e58c2c9d9f59fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32fcf7d141db6a078b11faf2cf97206/" rel="bookmark">
			html css 实现自定义复选框 checkbox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html 默认的复选框样式很难看，于是想着自定义实现checkbox样式
思路是：通过字体图标实现
效果图：
步骤：
1 https://www.iconfont.cn/ 字体图标网站，选择复选框 选中和未选中时的图标，并下载下来
2 下载下来解压后文件如下图，把iconfont.ttf 复制到 工程 /font/iconfont.ttf 3 html 页面 引入字体文件
@font-face {font-family: "iconfont"; src:url('/fonts/iconfont.ttf?t=2020051102') format('truetype'); } 上面步骤完成了字体图标的准备，下面开始 实现复选框的样式
4 去除checkbox自带边框 input[type=checkbox]{ background: none !important; background-color: transparent !important; outline: none !important; -webkit-appearance: none !important; } 5 设置选中和未选中时图标 input[type=checkbox]:checked:before { content: '\edaf'; font-size: 23px; color: #e4393c; font-family: "iconfont" !important; -webkit-font-smoothing: antialiased; } input[type=checkbox]:before{ content: '\e62c'; font-size: 23px; color: #AAAAAA; font-family: "iconfont" !important; -webkit-font-smoothing: antialiased; } 6 说明 伪类 before里的 content: '\e62c' 用的是字体图标，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d32fcf7d141db6a078b11faf2cf97206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d351014f8c960a3bf6f69b3363f190/" rel="bookmark">
			vmware虚拟机运行速度卡慢原因分析及解决办法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自品略图书馆 http://www.pinlue.com/article/2020/01/0915/369887500707.html
虚拟机能在现有的系统上虚拟出多个独立的系统，尤其是开发人员测试人员经常会使用，但是大家经常对虚拟机的运行速度不甚满意，甚至经常很恼火。虚拟机速度慢有很多原因，需要根据自己的情况具体分析，本文根据笔者的使用经验将从17个方面进行分析和总结，以期能尽量优化虚拟机的运行速度。
由于本专题文章较长，分成系列一和系列二两个部分，日后系列二发布的时候会在文章末尾添加跳转链接以方便阅读（戳这里）。
1、 主机本身的硬件配置
首先任何一种虚拟机对真机来说都是一个比较吃资源的大型任务系统，如果你的真机本身运行速度都很一般，那你再装一个虚拟机简直就是无本之木啊，哪有富裕的资源给虚拟机用呢？
真机CPU最好是双核2.5G以上，内存最少也得4G以上，最好8G以上，硬盘空间其实没什么太大影响够用就行，但硬盘速度要跟得上，如果普通机械硬盘最起码也得是7200RPM以上的，硬盘传输率最好在200MB/s以上。
当然每种虚拟机系统对硬件的要求是不一样的，比如装个win95系统，资源占用很少的，但如果装个win10企业版，硬件要求肯能就要翻好几番了。所以主机本身的配置肯定是越高越好，主机（真机）的配置是对虚拟机性能影响最大的因素。当然了，这个因素也是最不好解决的，因为要花钱啊~ ~
对于那些常年使用虚拟机的，建议还是要适当花点钱搞一下配置的。要不然硬伤太大了，谁也救不了你~~
2、 虚拟化技术硬件加速
这个功能需要主板支持的，现在主流的主板都是支持该功能的，如果你的主板不支持我只能说你的主板可能该换了。主板支持的同时虚拟化软件也得支持才行，现在的vmware版本都是支持该技术的，不过不同vmware对该技术的利用程度是不一样的。
首先在主板BIOS中开启该功能，不同的主板开启路径略有不同，但基本上都在“高级设置”“cpu设置”“虚拟化技术”类似这样的地方，然后把disable改成enable就可以了。最后别忘了按F10保存重启。
下图是华硕主板的设置路径，拍的不是很清楚，仅供参考：
然后在vmware里进行相应的设置，首先打开vmware点击菜单“虚拟机”，点其中的“设置”，如下所示：
打开设置界面如下，在“硬件”里选中“处理器”，在右边“虚拟化引擎”中勾选相应支持的虚拟化技术。
3、 Vmware的设置优化
1）Vmware本身也有很多设置会影响到速度性能，首先按上面介绍的方法进入到虚拟机的设置界面，看下面的图。这个是虚拟机内存，一般情况2G内存是够用的，但你要是在里面玩游戏或运行大型系统，比如数据库系统，代理服务器，媒体服务器这些系统都是比较吃内存的，那可能就不够了。
内存富裕的情况下，可以设置大一点，但不要超过蓝色箭头处的值。如果是技术人员自己可以到虚拟系统看看内存到底够不够，下面以Ubuntu为例给出简单的说明。从图中可以看出一个空的Ubuntu16已经占用了1.1G内存。一旦内存用完速度会明显变慢的。
2）继续往下设置，在虚拟机设置面板上选择“显示器”，右边“加速3D图形”一定要选上，除非你只用文字窗口不用图形界面，这里是说linux类的系统，windows系统必须选上。
图形内存一般情况768M也是够用的，玩游戏那肯定是不够的，另外要注意一个问题这里的内存是与前面的2G内存共享的，也就是这里用多了，那边实际上就会变少，虚拟机中的实际应用占用资源多了也会挤占这里的图形内存，一当出现这种情况速度必然会变慢。解决办法只能是增大内存（增大内存的规则请参考上文）。总之内存富裕的情况下可以适当多分一点。具体的数据分析也可以自己到虚拟机系统里去看。
3）继续往下设置，在虚拟机设置面板上切换到“选项”标签，如下图所示。将“抓取输入内容”调为高，同时可以禁用内存页面修正（但是要注意一旦勾选这项，极少概率会发生系统异常，当发生异常请取消这一项）。
4）继续往下设置，在vmware界面上点菜单“编辑”，然后点“首选项”，如下所示：
在首选项界面选中“优先级”，如下所示。抓取内容优先级设为高，快照处理勾选上后台处理。
5）继续往下设置，在首选项界面选中“内存”，如下所示。右边第一方框表示可以给虚拟机用的内存，这个值尽量设大一点，但是，要注意不能超过真机的空闲内存，否则将会发生不可预见的后果。下面三个选项选第一项，表示虚拟机将尽量使用真机留出来的的内存。
4、 删除不必要的配置项
这个道理就像你在真机上装了很多软件，有很多软件用几天就不用了，但是你不卸载不清理，时间长了你装的软件越来越多，你就发现你电脑越来越卡。既然我们要优化那就做彻底一点把没必要的都删了。虽然这一项的优化效果不会那么明显，但是一只蚂蚁也有肉的啊~ ~
1）首先按上面介绍的方法进入到虚拟机的设置界面，看下面的图。
图中两项对绝大多数人来说都是没用的，可以删掉，你也没必要在虚拟机中去打印，要打印你拷贝到真机中来打印就好了。其他的声卡、USB控制器根据情况也可以删掉，反正我都删掉了。
2）继续在设置界面选中“CD/DVD”去掉右边的勾。
3）继续在设置界面选中“USB控制器”去掉右边的勾（如果你已经删掉USB了，就当我没说）。
4）继续在设置界面选中“声卡”去掉右边的勾（如果你已经删掉声卡了，就当我没说）。
5、 硬盘存放问题、碎片问题
硬盘问题或者说虚拟机文件的存放问题，牵扯到的因素也很多。虚拟机系统的底层是一个文件实时处理系统，虚拟机中的一切都对应到文件中某些数据，对IO的还是有要求的。
1）如果你有两块硬盘，建议单独将虚拟机存在另一块中，不要跟真机系统混用一块。如果有条件给虚拟机单独配置一个SSD固态硬盘，那效果还是很明显的。对于经常使用虚拟机的人建议还是单独配一块SSD，毕竟一个普通虚拟机也就20-30G，一块SSD能装好几个虚拟机了。
2）如果没有SSD最好用SATA3最起码SATA2，如果 SCSI最好是一万转的，普通机械硬盘如果低于7200转，本人的经验认为硬伤太大，请自求多福~ ~
3）如果只有一块硬盘建议单独弄一个区给虚拟机用，一个干净连续的区对速度是很有好处的。
4）如果你不方便拿一个区出来，那请你在装虚拟机之前把磁盘碎片好好整理两边。
5）如果你连碎片也不愿意整理，爷，请您略过本文，你的系统慢点就慢点吧，别管它了……
6）另外，虚拟机本身也是可以整理磁盘碎片的，在虚拟机设置界面选中“硬盘”，点击右边的“碎片整理”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f64735863117b469e5486fe952755f/" rel="bookmark">
			ArrayList和LinkedList区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArrayList和LinkedList区别是什么？
这是一个非常常见的面试题。
区别如下：
数据结构实现： ArrayList 底层是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。
随机访问效率： ArrayList 比 LinkedList 在随机访问的时候效率要高。
ArrayList为数组实现，数组在存储数据时是按顺序存储的，存储数据的内存也是连续的，所以寻址读取数据比较容易，直接通过下标访问数据，时间复杂度为O(1)。LinkedList 是线性的数据存储方式，存储数据的内存是不连续的，所以需要移动指针从前往后依次查找。时间复杂度为O(n)。 增加和删除效率： 在尾部增加删除效率，两者开销是一样的。
在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高。
ArrayList 增删操作要影响数组内的其他数据的下标。因为这些存储数据的内存是连续的，要插入和删除元素，则要插入或删除的位置之后的所有元素都要往后移动或往前移动一个位置，效率很慢。对于LinkedList来说，不需要移动其他元素，只需将要插入的元素与左右两元素连接起来就好了。 综合来说： 在需要频繁读取集合中的元素时，更推荐使用 ArrayList，
而在插入和删除操作较多时，更推荐使用 LinkedList。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750c70188b33ebb7234a9cd67523fb56/" rel="bookmark">
			软通动力机考题目汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软通动力机考题目汇总 编程题整理的很少，编程是一个仁者见仁智者见智的过程，按照需求来，最终把需求实现就ok了。
一、选择题
1．下列选项不能创建一个字典的是( C ):
A dict ={ }
B dict={ 3:5 }
C dict={ [3,4] }: ”test” }
D dict={ (1,2) : ”test” }
2．关于python内存管理，下列说法错误的是( B )：
A 变量不必事先声明
B 变量无需实现创建和赋值而直接使用
B 变量无需指定类型
D 可以用del 释放资源
3. 下列哪个语句在Python中是非法的？（ B ）
A、x = y = z = 1 B、x = (y = z + 1)
C、x, y = y, x D、x += y
4. 下面哪个不是Python合法的标识符（ B ）
A、int32 B、40XL C、self D、name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750c70188b33ebb7234a9cd67523fb56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47dd243deadbe3d835ca7bfa16f8828b/" rel="bookmark">
			操作系统进程调度（动态优先级调度算法---ready、waiting、running三态）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境为 Ubuntu，Linux系统，C语言 本算法思想：
首先创建进程的时候，就按照优先级高低把进程插入正确的顺序中。
之后的调度：运行完一个进程时间片，重新衡量它的优先级并插入到合适的地方。
一开始老师给的参考代码是只有ready和running态（最后面也贴出了此代码）；老师做实验让我们加入waiting态，最好的方法应该是要把waiting态单独放在一个队列中，我当时觉得太麻烦了，就想直接放在末尾，奈何我想的太简单了，直接放末尾也超级麻烦，打算后期有时间写一下把waiting态单独放在队列中的代码！！！！！！
要考虑很多东西：
1.如何保证waiting态始终在末尾？答：每次重新衡量running态进程时，必须要绕过waiting态，不管waiting态的优先级多高，放在waiting态前面。
2.如何保证唤醒的进程重新插入队列？答：先把该唤醒进程摘取出来，再按照优先级插入。还要考虑队列中是否只剩下waiting态的进程，专门加一个if条件，还有执行操作。
//三态（ready/running/waiting） #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;memory.h&gt; #include &lt;unistd.h&gt; #include &lt;termios.h&gt; #include &lt;fcntl.h&gt; typedef struct pcb { int pid; /*Process ID*/ int prior; /*进程优先级*/ char status[10]; /*状态:ready,running,waiting*/ int time; //运行需要的时间 struct pcb *next; }PCB; FILE *fp = NULL; int sort(PCB **pstPCBHead,int *iNumProc); int printProc(PCB *pstPCBHead); int kbhit(void); int insert_waiting(PCB **pstPCBHead); int insert_ready(PCB **pstPCBHead,PCB **pstPCBNode); int main() { int iNumProc = 0; //进程的数量 int i = 0; PCB *stPCBHead = NULL; //头进程 PCB *stPCB = NULL; //链表指针 PCB *stPCBFront = NULL; //进程前驱 PCB *stPCBNode = NULL; char filename[128]; memset(filename,0x00,sizeof(filename)); //初始化文件内容 //sprintf(filename,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47dd243deadbe3d835ca7bfa16f8828b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91dff755ecb7945cbc5cc8961dbe713/" rel="bookmark">
			Flume拦截器-UUID拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.uuid.conf a1.sources = r1 a1.sinks = k1 a1.channels = c1 a1.sources.r1.type = exec a1.sources.r1.channels = c1 a1.sources.r1.command = tail -F /opt/plus a1.sources.r1.interceptors = i1 #type的参数不能写成uuid，得写具体，否则找不到类 a1.sources.r1.interceptors.i1.type = org.apache.flume.sink.solr.morphline.UUIDInterceptor$Builder #如果UUID头已经存在,它应该保存 a1.sources.r1.interceptors.i1.preserveExisting = true a1.sources.r1.interceptors.i1.prefix = UUID_ #如果sink类型改为HDFS，那么在HDFS的文本中没有headers的信息数据 a1.sinks.k1.type = logger a1.channels.c1.type = memory a1.channels.c1.capacity = 1000 a1.channels.c1.transactionCapacity = 100 a1.sources.r1.channels = c1 a1.sinks.k1.channel = c1 2.启动命令： bin/flume-ng agent -c conf/ -f jobconf/uuid.conf -n a1 -Dflume.root.logger==INFO,console 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10cf8d76c10d06d61f14e3f335d4ecd/" rel="bookmark">
			文本匹配论文及pytorch版复现（一）：DRCN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模型
1、模型总图
2、实施细则
二、相关公式
1、词表示层：字符卷积cp，静态预训练词嵌入ep（fix），可训练预训练词嵌入ep（tr）
fp代表，两句中字是否在另一句中出现，若是为1，若否为0
2、层次RNN和互注意力机制
原始输入x，通过RNN获取隐层表示h，将两句的隐层表示hi，hj通过互注意力机制，获取注意力表示ai，aj
3、自动编码器auto-encoder
全连接层，将高维度表示转化为低维度表示
4、交互层和分类层
More specifically, if the output of the final RNN layer is a 100d vector for a sentence with 30 words, a 30 × 100 matrix is obtained which is max-pooled column-wise such that the size of the resultant vector p or q is 100.
将p，q向量通过maxpooling获取特征。再进入如下融合
最终表示
最终通过线性变换和激活函数，得到输出结果。
三、代码实现
1、模型model.py
from torch import nn, tensor import numpy as np import torch import joblib # 总体模型 class DRCN(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c10cf8d76c10d06d61f14e3f335d4ecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d939697c3c92459bc422fdf753672e/" rel="bookmark">
			js代码如何断点debug调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍的过程还是以一个测试例子来演示，这样更直观也更容易理解
使用谷歌浏览器打开一个测试的html文件，里面包含简单的js代码（只做演示）
按F12打开网页调试工具，默认打开的是Elements，显示的是网页标签元素，如下图
给js代码打断点，首先需要找到js资源文件，选择Source的tab标签，出现资源文件目录，选择对应的js代码文件
在js代码文件左侧栏单击可以添加断点，再点击可以移除断点
断点添加完成之后，F5刷新浏览器，可以看到代码执行到断点位置停了下来。光标放在变量名上，可以显示出变量值
还可以选择一个表达式，可以直接显示出这个表达式执行的结果
点击右侧单步跳转，可以逐行调试，也可以点击进入某个函数方法内部，可以从某个函数方法直接跳出，也可以点击第一个按钮，直接跳转到下一个断点或直接结束。下方可以看到断点的详细信息，如监控变量、调用栈、事件等。如下图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d73ee2ae998708e37bc3703f6702af6/" rel="bookmark">
			Seismic Unix安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Seismic Unix安装 自己写的一键安装的脚本 从GitHub上下载后安装
其实从GitHub上下载后，配置环境变量应该直接就可以用了，脚本也经常报错，目前没时间改了，主要是自己用来复制代码方便。。。。
似乎segd模块在Ubuntu 18.04版本上会报错，只能在16.04用（20200516尝试，在Ubuntu18.04上，segd模块会安装失败，Ubuntu16.04上无问题，并且从16.04命令行升级至18.04，segd模块仍然可用,继续升级至ubuntu20.04，segd模块可用; 20211111尝试，在Ubuntu20.04上，segd模块不可安装）
在centos7和Redhat 7.4,7.9版本上均可正常安装，在Redhat8.1和8.4版本上，不能正常安装。
#!/bin/sh # Install su on Ubuntu16.04LTS from github # Zhangkun #update source echo " ****** update source ******" sudo apt update echo " ****** install git ****** " sudo apt install git make -y echo "******install desired components" # 实际上可以直接把这几个依赖包一起安装了，但是libmotif4包好像没了，经常报错，就还是单独输入了，加上-y省的再点确认 #sudo yum install gcc gcc* libx* openmotif openmotif* freeglut-devel libXt-devel-1.1.5-3.el7.x86_64 #centos7.7 和 Redhat7 下需要安装的依赖 #sudo yum install gcc gcc* libx* openmotif openmotif* freeglut-devel libXt-devel* -y #centos8 和 Redhat8下需要安装的依赖（安装失败） # sudo apt install libx11-dev libxt-dev gfortran freeglut3-dev libxmu-dev libxi-dev libc6 libxt6 libmotif-dev csh -y sudo apt install libx11-dev -y sudo apt install libxt-dev -y sudo apt install gfortran -y sudo apt install freeglut3-dev -y sudo apt install libxmu-dev libxi-dev -y sudo apt install libc6 -y sudo apt install libmotif4 # 这步经常报错，可以不安装 sudo apt install libxt6 -y sudo apt install x11proto-print-dev -y sudo apt install libmotif-dev -y sudo apt install csh -y #make installation directory echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d73ee2ae998708e37bc3703f6702af6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78f902604a20d8eb52f76c74cb39e0db/" rel="bookmark">
			R语言-随机森林整理（自留）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 randomForest重要参数解释其他参数变量的重要性Do MDS on 1 - proximity查看节点数预测ROC曲线 randomForest重要参数解释 Ntree：森林中树的个数，默认500
Mtry：每棵树（每个节点？）使用的特征个数，默认为2
Importance：默认false，是否计算变量的特征重要性
Proximity:是否计算各观测之间的相似性
set.seed(71) iris.rf &lt;- randomForest(Species ~ ., data=iris, importance=TRUE ,mtry=3, proximity=TRUE) #importance参数是看样本重要性的，proximity是样本之间距离 print(iris.rf) 其他参数 这里参考：原文
formula指定模型的公式形式，类似于y~x1+x2+x3…;data指定分析的数据集；subset以向量的形式确定样本数据集；na.action指定数据集中缺失值的处理方法，默认为na.fail，即不允许出现缺失 值，也可以指定为na.omit，即删除缺失样本；x指定模型的解释变量，可以是矩阵，也可以是数据框；y指定模型的因变量，可以是离散的因子，也可以是连续的数值，分别对应于随机森林的分类模型和预测模型。这里需要说明的是，如果不指定y值，则随机森林将是一个无监督的模型；xtest和ytest用于预测的测试集；ntree指定随机森林所包含的决策树数目，默认为500；mtry指定节点中用于二叉树的变量个数，默认情况下数据集变量个数的二次方根（分类模型）或三分之一（预测模型）。一般是需要进行人为的逐次挑选，确定最佳的m值；replace指定Bootstrap随机抽样的方式，默认为有放回的抽样classwt指定分类水平的权重，对于回归模型，该参数无效；strata为因子向量，用于分层抽样；sampsize用于指定样本容量，一般与参数strata联合使用，指定分层抽样中层的样本量；nodesize指定决策树节点的最小个数，默认情况下，判别模型为1，回归模型为5；maxnodes指定决策树节点的最大个数；importance逻辑参数，是否计算各个变量在模型中的重要性，默认不计算，该参数主要结合importance()函数使用；proximity逻辑参数，是否计算模型的临近矩阵，主要结合MDSplot()函数使用；
-oob.prox是否基于OOB数据计算临近矩阵；norm.votes显示投票格式，默认以百分比的形式展示投票结果，也可以采用绝对数的形式；do.trace是否输出更详细的随机森林模型运行过程，默认不输出；keep.forest是否保留模型的输出对象，对于给定xtest值后，默认将不保留算- 法的运算结果 变量的重要性 变量的重要性：
在随机森林中变量的重要性计算时通过将相应变量替换成一列随机的数后，计算模型准确率或者GINI系数的降低。
上图的意思是（0,1分类）：0：表示变量替换后对分类为0的数据的影响；1：表示表示变量替换后对分类为1的数据的影响；MeanDecreaseAccuracy：表示变量替换后准确率的下降；MeanDecreaseGini：表示变量替换后GINI系数的降低。数值越大表示变量越重要。
像下图，如果是iris数据集有三类，那么就是一共5列，前三列是对每一列的影响。
round(importance(iris.rf), type=2) #type=1是以准确率递减方法得到维度重要性值。type=2为基尼系数方法 #直方图直观查看系数重要性，下边两个好像没啥区别 varImpPlot(iris.rf, main = "variable importance") varImpPlot(iris.rf, sort=TRUE,n.var=nrow(iris.rf$importance), main = "variable importance") Do MDS on 1 - proximity 调用cmdscale 函数进行样本之间的距离，proximity 是样本之间的相似度矩阵，所以用1减去之后得到样本的类似距离矩阵的一个矩阵。
iris.mds &lt;- cmdscale(1 - iris.rf$proximity, eig=TRUE) 在iris.mds 中points可以看做每个样本映射到2维空间中的坐标
head(iris.mds$points) #画散点图可以看一下分类情况 plot(iris.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78f902604a20d8eb52f76c74cb39e0db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9cceac4ae8e2e4a966c0656b8f7f963/" rel="bookmark">
			利用Wireshark软件抓包深入分析HTTP，Web缓存。加计算机网络课后实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wireshark软件的下载 为了运行Wireshark，您需要一台支持Wireshark和libpcap或WinPCap（这个在一定要安装）分组捕获库的计算机。当您安装Wireshark时，如果您的操作系统中未安装libpcap软件，它将会自动安装。有关支持的操作系统和下载站点的列表，请访问http://www.wireshark.org/download.html
Wireshark软件的启动 运行Wireshark
当您运行Wireshark程序时，您将看到一个类似下面的启动界面：
选择你要抓取的接口，如果是使用以太网上网就选择对应的接口。双击打开就开始进行抓包了。
HTTP和Web缓存的理论基础 HTTP中文名超文本传输协议（HyperText Transfer Protocol）,是web的应用层协议，使用TCP作为它的支撑运输协议，因为http请求对于数据的可靠性要求比较高所以选择TCP而不选择UDP进行传输。
HTTP连接的过程：第一步HTTP客户端进程向目标服务（www.qq.com）发起一个TCP连接，由TCP套接字来完成。
第二步：HTTP客户端（一般是你自己所使用的浏览器）经它的套接字向服务器发送一个HTTP请求报文。
第三步：HTTP服务器进程经由它的套接字接收请求报文，从自己的存储器里或者磁盘里检索出你所需要的内容（www.qq.com)，封装成HTTP响应报文，并通过套接字向HTTP客户端。
第四步：HTTP服务器断开TCP连接。
第五步：HTTP客户端接受到响应报文后，TCP连接关闭。然后你的客户端即浏览器提取HTML文件，一个HTTP请求流程到此结束。
HTTP请求报文
HTTP响应报文
抓包分析 1.基本HTTP GET/response交互我们开始探索HTTP，方法是下载一个非常简单的HTML文件 非常短，并且不包含嵌入的对象。
启动Wireshark数据包嗅探器，在display-filter-specification窗口中输入“http”（只是字母，不含引号标记），这样就在稍后的分组列表窗口中只捕获HTTP消息。（我们只对HTTP协议感兴趣，不想看到其他所有的混乱的数据包）。
稍等一会儿（我们将会明白为什么不久），然后开始Wireshark数据包捕获。
在浏览器中输入以下内容 http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html，或直接复制这个链接搜索， 您的浏览器应显示非常简单的单行HTML文件。停止Wireshark数据包捕获。
在这里我们访问了书上提供的一个简单的网页。
2.在display-filter-specification窗口输入http,显示所抓到的http
3.双击第一行具体分析
GET报文的分析
我们发现抓取的报文中
GET /wireshark-labs/HTTP-wireshark-file1.html HTTP/1.1\r\n，与书上的报文一一对应。
GET报文比较简单，接下来看一下服务器回复的报文，多了服务器发送的HTML文件。
至此我们了解了整个请求和回复的过程。要注意的是在请求之前，客户端先要与服务器进行TCP连接有一个三次握手的过程。
Web缓存的概念 Web缓存（或HTTP缓存）是用于临时存储（缓存）Web文档（如HTML页面和图像），以减少服务器延迟的一种信息技术。Web缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。 Web缓存系统既可以指设备，也可以指计算机程序。
从上面一个例子来讲，假设我们连续输入
http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html，然后再利用抓包软件来分析这两次的请求与回复报文是否一样？我们会有惊奇的发现
回复的报文中不再是HTTP/1.1 200 OK (text/html)，而是 HTTP/1.1 304 Not Modified ，这个是什么意思的？Modified是改进修改的意思，Not Modified意思是服务器告诉客户端你请求的HTML并没有改变，请从Web缓存中或者代理服务器中得到。我们从报文中可以看到此时服务器并没有向客户端发送HTML文件。可以与第一次所抓到的报文做对比。!
所以当我们对某一个服务器发出连续的HTTP请求时，如果服务器检查资源没有被修改就回复304 Not Modified,直接从本地缓存中调出数据，方便快捷。
优点：缓存的优点通过缓存可以减少冗余的数据传输，从而达到节省流量的效果。缓存还能够缓解带宽的瓶颈问题和瞬间拥塞问题。加载页面的时候不需要更多的带宽，对原始服务器的要求也降低了。缓存降低了距离延时， 因为从较远的地方加载页面会更慢一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bb3e5115889ca7587c48e53eec903a/" rel="bookmark">
			C语言简答题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言简答汇总 根据网上常见的一些面试题整理，用于考研复试备考，大部分是C语言问答，但不仅仅限于C语言问答，也包括计网和操作系统相关的一些问答，内容如有错误，欢迎指正
1、c语言的特点以及C语言与Python的比较？
c语言的数据类型丰富，具有现代语言的各种数据结构，能实现复杂的运算。c语言使，用灵活方便，便于实现程序的结构化，节省内存。
C语言与Python的比较：
（1）首先Python的使用要更加简单灵活，要实现相同的功能，Python的代码量通常只有C语言的30%
（2）C语言是面向过程的语言，很多时候需要自己手动实现函数来完成一些功能，Python中引入了类和对象，是面向对象编程的语言。
（3）Python拥有许多优秀的第三方库，在编程的时候更加的简单。
（4）c语言的数据类型丰富，Python的数据类型只有数字、字符串、列表、元组、集合、字典6种，不需要事先定义变量类型，使用更加简便。
2、c语言为什么要规定，对所有使用的变量要“先定义，后使用”？
凡是未被事先定义的变量，在使用过程中不会被当作变量名，这样能够保证程序中的变量名使用正确。每一个变量被指定一个确定的数据类型，在编译时就能为其分配相应的存储单元。指定一个变量属于一个类型，在编译的时候就能检查该变量是否使用正确。通俗来讲，给变量一个存储位置，方便操作。
3、根据自己的认识，写出c语言的特点
语言简洁，使用灵活方便，具有丰富的运算符和数据类型，便于实现程序的结构化，用c语言编写的程序可移植性好，c语言可以作为系统设计语言、应用程序设计语言，c语言具有绘图能力和强大的数据处理能力，它是数值计算的高级语言
4、c 语言的主要用途：
c语言主要用于程序的编程开发，和其他的高级语言相比，都采用符号形式，提供许多高级的程序结构，供编写人员组织复杂的程序。都是面向问题的语言，独立于具体的机器，比较接近人的语言习惯，能更有效的描述各种算法。c语言具有绘图能力和可移植性，有更强的数据处理能力，适用于编写系统软件、二维、三维图形和动画。
5、写出一个程序的组成
程序名、预编译指令、标准的输入输出、c语言的主函数、函数开始标志、定义变量、给变量赋值、输出结果、程序正常结束、函数结束标志
6、C 语言以函数为程序的基本单位，有什么好处？
函数是程序的基本组成单位，可以用函数作为程序模块来实现c语言程序。利用函数不仅可以使程序模块化，而且可以使程序设计的简单和直观，提高程序的可读性和可维护性。还可以把程序中的一些计算编成通用函数，以供随时使用。
7、关键字和一般标识符有什么不同？
标识符用来标识源程序中的某个对象的名字，一个标识符由字母、数字和下划线组成。关键字可以定义变量、表达式语句功能和对一些文件进行预处理，关键字已被编译系统本身使用，所以用户编写程序时不能够使用这些关键字来作为标识符，如int，if，for等。
8、if语句中的条件表达式可以是任意的合法表达式吗？Switch语句中break的作用是什么？
可以是任意数值。在switch语句中，break语句可使流程立即跳出switch语句体不执行其他的case。
9、三种循环结构中的条件是循环进行的条件还是循环结束的条件？循环结构中break语句和continue语句的作用是什么，二者有何区别？
for语句、while语句：循环进行的条件;do-while语句：循环结束的条件；break可用于switch语句，表示跳出整个switch块，而continue则不能用于switch语句，它们都可用于循环语句的循环体，break用于立即退出当前循环，而continue仅跳过当次循环，本次循环体内不执行continue语句后的其他语句，但下次循环还会执行。
10、字符数组与字符串是否相同？若不相同，有何区别？
不相同，C语言中没有专门的字符串变量，如果要将一个字符串存放在变量中，必须使用字符数组，即用一个字符型数组来存放一个字符串，数组中每一个元素放一个字符。字符串必须以’\0’结尾，字符数组可以包含多个’\0’
11、函数的嵌套调用与递归调用有什么区别？
函数嵌套允许在一个函数中调用另外一个函数，递归调用是调用本身的函数。函数嵌套就是函数调用函数，是普遍的，递归就是函数调用自身，是函数嵌套的一个特例。
12、结构体类型与我们前面学过的基本类型有哪些区别？
结构体是一个可以包含不同数据类型的一个结构，它是一种可以自己定义的数据类型。特点：1、结构体可以在一个结构体中声明不同的数据类型；2、相同的结构的结构体变量可以相互赋值，而数组不行，因为数组是单一数据类型的数据集合，它本身不是数据类型（而结构体是），数组名称是常量指针，所以不可以做为左值进行运算，所以数组之间就不能通过数组名称相互复制，即使数据类型和数组大小完全相同。3、节省内存空间。第四、高效率。
13、指针与地址有什么联系？在使用指针的过程中应注意哪些细节？指针类型对于程序设计有哪些意义？
指针保存了某个变量的地址，指针本身是一个变量，它也有自身的地址，而指针的内容是某个变量的地址。注意细节：要初始化、正确的传递地址方式、使用时要判断。指针可以用来有效地表示复杂的数据结构，可以用于函数参数传递并达到更加灵活使用函数的目的，使C语言程序设计具有灵活、实用、高效的特点。
14、描述一下gcc的编译过程？
gcc编译过程分为4个阶段：预处理、编译、汇编、链接。
预处理：头文件包含、宏替换、条件编译、删除注释
编译：主要进行词法、语句、语义分析等，检查无误后将预处理好的文件编译成汇编文件。
汇编：将汇编文件转换成二进制目标文件
链接：将项目中的各个二进制文件+所需的库+启动代码链接成可执行文件。
15、内存的最小存储单位以及内存的最小计量单位分别是？
内存的最小存储单位为二进制，内存的最小计量单位是字节
16、#include&lt;&gt;与#include””的区别？
Include&lt;&gt;到指定的目录找头文件，#Include””先到项目所在目录找头文件，如果没有找到再到系统指定的目录下寻找
17、描述一下变量的命名规则？
变量名必须以字母或者下划线开始，其后为字母数字下划线
18、变量的声明与定义有什么区别
声明变量 不需要建立存储空间，变量的定义需要建立存储空间。为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。
19、谈谈c语言中有符号和无符号的区别？
有符号：数据的最高位为符号位，0表示正数，1表示负数
无符号：数据的最高位不是符号位，而是数据的一部分
20、谈谈计算机中补码的意义？
统一了零的编码；将符号位与其他位统一处理将减法运算转换成加法运算
21、谈谈数组的特点？
同一个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的
22、数组的分类？
数组的分类主要是：静态数组、动态数组两类。
静态数组：类似int arr[5]；在程序运行就确定了数组的大小，运行过程不能更改数组的大小。
动态数组：主要是在堆区申请的空间，数组的大小是在程序运行过程中确定，可以更改的大小。
23、描述一下一维数组的不初始化、部分初始化、完全初始化的不同点
不初始化：如果是局部数组 数组元素的内容随机 如果是全局数组，数组的元素内容为0
部分初始化：未被初始化部分自动补0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38bb3e5115889ca7587c48e53eec903a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50794453df68bb729b24680ff3861d5/" rel="bookmark">
			http协议详解(新手必看)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介
http协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
http是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
http是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
http协议工作于客户端-服务端架构为上。浏览器作为http客户端通过URL向http服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。
讲到http协议，我们首先简单了解什么是url
。
在浏览器输入URL，会经历以下过程：
①浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址。
②解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接。
③浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器。
④服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器。
⑤释放 TCP连接。
⑥浏览器将该 html 文本并显示内容
2.http协议特点
HTTP 协议一共有五大特点：1、支持客户/服务器模式；2、简单快速；3、灵活；4、无连接；5、无状态。(重点介绍无连接和无状态)
无连接
无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。
随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。
Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。市场上的大部分 Web 服务器，包括 iPlanet、IIS 和 Apache，都支持 HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep-Alive 功能对资源利用的影响尤其突出。
协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive，而HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d50794453df68bb729b24680ff3861d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1635fc498a849f61d135c7d8d6b180/" rel="bookmark">
			C语言排序函数—qsort函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在一些编程题中经常需要你按照某个指标按照从小到大或从大到小输出一些数据，这时你可以自己写一个排序函数进行排序，但是其实C语言函数库中就有一个排序函数——qsort函数，使用它可以节省你单独写排序函数所耗费的时间，因而在一些比赛中广泛应用。
qsort函数介绍： 定义于头文件 &lt;stdlib.h&gt;
void qsort( void *ptr, size_t count, size_t size,int (*comp)(const void *, const void *) ); 对 ptr 所指向的数组以升序排序。数组包含 count 个长度为 size 字节的元素。用 comp 所指向的函数比较对象。同 (1) ，除了传递给 comp 附加环境参数 context ，还会在运行时检测下列错误，并调用当前安装的制约处理函数：
count 或 size 大于 RSIZE_MAX
key 、 ptr 或 comp 是空指针（除非 count 为零）
同所有边界检查函数， qsort_s 仅若实现定义了 STDC_LIB_EXT1 ，且用户在包含 stdlib.h 前定义 STDC_WANT_LIB_EXT1 为整数常量 1 才保证可用。
若 comp 指示两元素相等，则它们排序后的结果是未指定的。 参数 ptr - 指向待排序的数组的指针
count - 数组的元素数目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca1635fc498a849f61d135c7d8d6b180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70085882d539b17fc9f1987a48790538/" rel="bookmark">
			图（2）图的深度优先和广度优先遍历算法及求简单路径和最短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 图的遍历 定义：从给定图中任意指定的顶点出发，按照某种搜索方法沿着图的边访问图中的所有顶点，使每个顶点仅被访问一次。
图的遍历得到的顶点序列称为图的遍历序列。
图的遍历方式有两种：深度优先遍历（DFS）和广度优先遍历（BFS）。
深度优先遍历算法 过程：
（1）从图中某个初始顶点 v v v出发，首先访问初始顶点 v v v；
（2）选择一个与顶点 v v v相邻且没被访问过的顶点 w w w，再从 w w w出发进行深度优先搜索，直到图中与当前顶点 v v v邻接的所有顶点都被访问过为止。
算法设计思路：
#include &lt;iostream&gt; using namespace std; #define MaxV 100 typedef char VertexType; typedef int InfoType; int visited[MaxV] = {0}; //图的邻接表存储类型定义 struct ArcNode{//边节点类型 int adjvex;//边的终点编号 ArcNode* nextarc;//指向下一条边的指针 InfoType info;//边的信息，如：权 }; struct VNode{//头节点类型 VertexType data;//顶点信息 ArcNode* firstarc;//指向第一条边 }; struct ALGraph{//图邻接表类型 VNode adjlist[MaxV];//邻接表 int n,e;//顶点数和边数 }; //建立图的邻接表 void CreateAdjListGraph(ALGraph &amp;G) { ArcNode *e; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70085882d539b17fc9f1987a48790538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8d042a67678f3832fea470d8e59f11/" rel="bookmark">
			LeetCode 例题精讲 | 15 最长公共子序列：二维动态规划的解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注上方“五分钟学算法”，
设为“置顶或星标”，第一时间送达干货。
转自面向大象编程
本期例题：LeetCode 1143. Longest Common Subsequence 最长公共子序列（Medium）
给定两个字符串 s 和 t，返回这两个字符串的最长公共子序列的长度。若这两个字符串没有公共子序列，则返回 0。
一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，"ace" 是 "abcde" 的子序列。
在上一篇文章中，我们以打家劫舍（House Robber）问题为例讲解了动态规划问题的一般解题步骤。不过，打家劫舍问题是一维动态规划问题，而还有很多题目属于二维动态规划。今天我们就以一道经典的「最长公共子序列」问题讲解二维动态规划的解法。
最长公共子序列问题经典到什么程度呢？经典到有自己的专用缩写 —— LCS (Longest Common Subsequence)。如果你在别的地方看到 LCS 的缩写，要能够知道这是最长公共子序列的问题。
如果说打家劫舍问题是动态规划的最佳入门题，那么 LCS 问题就是二维动态规划的最佳入门题，问题经典，方法典型。本文会在一步步求解 LCS 问题的过程中，讲解二维动态规划问题的解题要领。
本文假设你已经了解了打家劫舍问题的解法以及动态规划问题的基本解题步骤。对此不是很清楚的同学可以回顾一下上一篇文章：
LeetCode 例题精讲 | 14 打家劫舍问题：动态规划的解题四步骤
一维与二维动态规划 首先我们要清楚一维动态规划与二维动态规划的含义。对于打家劫舍问题，我们定义 为偷前 间房子的最大金额。这里子问题只有一个参数 ，因此是一维动态规划问题，参数只会在一个维度上变化。而如果子问题有两个参数，则为二维动态规划问题，参数会在两个维度上变化。
为什么要区分子问题的维度呢？这是因为子问题的维度会直接影响 DP 数组的维度。二维的 DP 数组不仅空间复杂度变大，DP 数组的计算顺序也更复杂。
一般来说，绝大多数动态规划问题的维度不会超过二维。必须使用三维以上子问题的题目属于难题，不需要掌握。
使用四步骤解题 在上一篇文章中，我们讲解了动态规划题目的的四个基本解题步骤：
定义子问题
写出子问题的递推关系
确定 DP 数组的计算顺序
空间优化（可选）
二维动态规划问题同样遵循这四个解题步骤，不过每个步骤可能会更复杂。下面我们使用四步骤方法一步步解决 LCS 问题。
步骤一：定义子问题 要定义子问题，我们还是抓住这样一个子问题的基本性质：子问题是和原问题相似，但规模较小的问题。
对于 LCS 问题，原问题是「s 和 t 的最长公共子序列」。那么子问题可以缩小字符串 s 或者 t 的规模，变成「s 的前 个字符（s[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8d042a67678f3832fea470d8e59f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ccd90f336786b36f898cd7fba8128a/" rel="bookmark">
			week11-三角形的仿射变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机图形学中，人们一直都在处理变形的三角形，因为任何3D表面都可以由三角形近似。图像可以分解为三角形并变形。但是，在OpenCV中，没有封装好的方法可以将三角形内的像素变换到另一个三角形内的像素。
仿射变换 仿射变换是一组3个点（即三角形）来转换到另一组的任意3个点的最简单的方法。
下图说明了仿射变换如何用于更改正方形的形状。请注意，使用仿射变换可以将正方形的形状更改为任何方向和比例的平行四边形。但是，仿射变换的灵活性不足以将正方形变换为任意四边形。
换句话说，在进行仿射变换之后，平行线继续平行。
opencv封装了仿射变换用的函数：https://www.cnblogs.com/nipan/p/4174271.html
代码效果：
import cv2 import numpy as np # Warps and alpha blends triangular regions from img1 and img2 to img def warpTriangle(img1, img2, tri1, tri2) : # Find bounding rectangle for each triangle计算边界框 r1 = cv2.boundingRect(tri1) r2 = cv2.boundingRect(tri2) # Offset points by left top corner of the respective rectangles裁剪图像并更改坐标 tri1Cropped = [] tri2Cropped = [] for i in range(0, 3): tri1Cropped.append(((tri1[0][i][0] - r1[0]),(tri1[0][i][1] - r1[1]))) tri2Cropped.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ccd90f336786b36f898cd7fba8128a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf83bbf5ba68a486d677cf9c7df71bb/" rel="bookmark">
			MACOS Dock栏自动显示和隐藏取消延迟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用OS X的时候都会选择将Dock隐藏（可以在系统偏好设置—Dock中选择），等使用时将光标向下划Dock会自动弹出显示。这个显示或隐藏会有一点点（大概1秒左右）的延迟，使用下面的方法可以消除这个延迟：
打开 应用程序——实用工具——终端
输入代码：
defaults write com.apple.Dock autohide-delay -float 0 &amp;&amp; killall Dock 当Dock再次隐藏或显示时会立即执行
如想恢复默认的延迟速度，在终端输入以下代码即可
defaults delete com.apple.Dock autohide-delay &amp;&amp; killall Dock 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5279464bdaad5c9a77473b2ebf4c065c/" rel="bookmark">
			Mac使用Microsoft-Remote-Desktop-for-Mac远程桌面Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如你有两台电脑甚至更多电脑用来工作、学习，当你从一台电脑换到另一台电脑上的时候，你需要移开当前视线，当前键盘、鼠标，甚至是换个椅子等，这样的操作来切换工作，这样来来回回非常的麻烦。所以就有两台以及多台电脑共享一套键盘鼠标的操作，切换的时候，你只需要眼睛看向另一屏幕即可，继续在当前鼠标、键盘上操作。
然而，现在你连视线也懒得移动，但同时也要满足你在当前屏幕使用另一电脑的操作，此时远程桌面就可以派上用场了，像远程桌面控制软件一般有 TeamViewer、向日葵远程桌面等这些，由于现在我们场景是在同一局域网下比如两台电脑连接的是同一个路由器 Wi-Fi 所以使用 Microsoft-Remote-Desktop 还是比较顺畅的。
今天我们讨论的是，如何在 Mac 上远程连接 Windows 桌面。当前我使用的两台电脑版本是Windows：win10 专业版 1903，Mac：MacbookAir 10.15.3
安装 Microsoft-Remote-Desktop-For-Mac 在 Mac AppStore 搜索 Microsoft Remote Desk 选择 Microsoft Remote Desk 10 安装，查看版本是 10.3.9(1767)版本，我使用的是中国区的 APPLE ID这里可以直接下载 Microsoft-Remote-Desktop-For-Mac 最新版本，我在这里下载是 10.4.0 (1774) Beta 版本 两个版本都可以使用。
连接 Windows 首先在 Windows 上需要开启远程桌面连接，允许远程连接到此计算机。如图，打开此电脑—远程设置—选择允许远程连接到此计算机。可能会提示电源选项，先确定应用一会儿再去设置。
此时我们在 Mac 上打开我们刚才下载的 Microsoft-Remote-Desktop-For-Mac 点击 add PC 填上 Windows 电脑的是 IP地址，我这里是 192.168.188.221 你可以打开控制面板—网络和 Internet —网络和共享中心— WLAN —详细信息— ipv4 地址，或者 win键+r 输入 ipconfig 回车即可看到当前 IPv4 地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5279464bdaad5c9a77473b2ebf4c065c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4f4f99b73bf36194a108e57cd1f3952/" rel="bookmark">
			离散数学之数理逻辑——第2章 命题逻辑等值演算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 等值式 定义2.1
设A,B是两个命题公式，若A，B构成的等价式 A ↔ B A\leftrightarrow B A↔B为重言式，则称A与B是等值的，记作 A ⇔ B A\Leftrightarrow B A⇔B.
⇔ \Leftrightarrow ⇔不是连接符，它是用来说明A与B等值的一种记法，因而它是元语言符号。
本书给出16组重要的等值式，应牢牢记住：
上述16组等值式共包含了24个重要等值式。这样的等值式称为等值式模式，具体的等值式被称为原来等值式模式的待入实例
我们称由已知的等值式推演出另外一些等值式的过程为等值演算，等值演算是布尔代数或逻辑代数的重要组成部分。在等值演算过程中，要不断地使用一条重要的规则，它的内容如下：
置换规则
设 ϕ ( A ) \phi(A) ϕ(A)是含公式 A A A的命题公式， ϕ ( B ) \phi(B) ϕ(B)是用公式 B B B置换了 ϕ ( A ) \phi(A) ϕ(A)中所有的A后得到的命题公式，若 B ⇔ A B\Leftrightarrow A B⇔A,则 ϕ ( B ) ⇔ ϕ ( A ) \phi(B)\Leftrightarrow \phi(A) ϕ(B)⇔ϕ(A).
2. 析取范式与合取范式 定义2.2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4f4f99b73bf36194a108e57cd1f3952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3da23c176f85554e1d49ee99684d1e3/" rel="bookmark">
			idea中gitignore文件作用、修改gitignore文件忽略指定文件的提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如图：箭头所指的地方为红色则，还未被忽略
接下来在gitignore文件中添加忽略规则后，保存，可以看到文件颜色已改变
提交代码时可以看到，已经不再显示该文件
如果文件已经被提交过，后续想要忽略也是一样的
ps:图中test.iml文件已经提交过了，而且目前内容还没被修改,所以添加绿框中的规则，文件test.iml也不会改变颜色，可以修改文件内容后再添加绿框中的规则（记得保存），就能发现文件名变色了，下次提交代码就被忽略了，注意每次修改后需要手动保存，才能生效，另一个是.gitignore文件要提交到远程仓库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fe85e130fe435346101793310edc64/" rel="bookmark">
			【小白教程】Java POI的下载及导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java POI的下载及导入 本人做IT对日外包的，所有的框架都是别人搭好的，自己就是往里面填东西，所以有些特别基本的东西都不会，
最近接到一个日本的Java项目，里面有一模块儿就是涉及Excel读取和写入的，想先回家试试，结果发现自己连导POI的包都不会。
在查阅相关资料后，终于弄明白大概怎么弄了，送给像我一样的小白们。如有不正，望各位大神指点。
官网下载最新的POI 官网链接：http://poi.apache.org/download.html
具体步骤如下：
最新版POI下载（poi4.1以上需要jdk1.8以上版本支持！）
下载完解压。
打开Eclipse导入jar包。
选择工程右键
把文件夹和外面的jar包都选中添加
以上都可以引用了
最后，不怕小白就怕不努力的小白
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8224b01b72057edc1a27908590ae7a8e/" rel="bookmark">
			idea新建项目上传到git仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在gitHub上创建一个仓库​​
​​​​创建后复制好clone连接
注意上图，仓库中已经有一个证书协议文件了，因此在提交新建项目的时候会被拒绝，没关系继续往下看。回到IDEA中创建git仓库（VCS -&gt; Import into Version Control -&gt; Create Git Repository…），一般我们项目仓库创建在项目文件根目录下，如图
创建成功后，项目中文文件会变成红色（红色代表文件没有add到本地git仓库）在add到本地仓库之前，先修改好.gitignore文件（.gitignore文件用法），配置好哪些文件需要提交，哪些文件不需要提交commit项目文件到本地仓库（使用快捷键ctrl+k，弹出框后选择要提交的文件，然后点击commit,会再弹出一个框，不用管，之间点击commit）提交到远程仓库（使用快捷键ctrl+shift+k提交代码到远程仓库）
push后会发现，失败，因为上面有提到过，远程仓库中已经存在一个文件了，再提交就出现冲突，如图：
解决方法有两种： （1）push代码前先删除远程仓库的所有的文件 （2）先从远程仓库clone项目下来然后再在项目中添加文件 （3）最推荐的一种方法： 击IDEA工具底部terminal 输入下面的指令 git pull origin master --allow-unrelated-histories 可能会要求输入账号密码，输入即可。指令的意思是，允许更新不相关的历史记录，也就是将远程仓库的文件更新过来了，此时便可push到远程了。如果失败，可以依次尝试下面的指令： git pull git pull origin master git pull origin master --allow-unrelated-histories 看到line13这句话，表示项目已经更新 D:\javaProject\TestPushGit2&gt;git pull origin master --allow-unrelated-histories warning: no common commits remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8224b01b72057edc1a27908590ae7a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617cbc110740d38890e22c0936dd09fa/" rel="bookmark">
			SSH&#34;connection reset by ip_address port 22&#34;问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前提是安装好了openssh，但是客户端无法连接，出现了
connection reset by (server_ip_address) port 22
可以试试重置ssh的配置。我是通过这个直接解决的，网上的教程很多都不行，就这个可以直接解决，我查看了log文件，说我是缺少了.key文件
重置一下重新创建key文件就能解决
rm /etc/ssh/ssh_host_* sudo dpkg-reconfigure openssh-server 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f495d18f0fc7e8ee6cadf30a8c88f55f/" rel="bookmark">
			angularjs-解析分组的json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I have this JSON structure:
{
“2014”: [
“2014-01”,
“2014-02”,
“2014-03”,
…
],
“2015”: [
“2015-01”,
“2015-02”,
“2015-03”,
…
]
}
… and a need parse that JSON to an HTML structure like this, with or without Jquery.
Thank you!
UPDATE: I updated the JSON
收起翻译
译文
我有这个JSON结构：&lt;/ p&gt;
{
“ 2014”：[
“ 2014-01”，
“ 2014-02”，
“ 2014-03”，
…
]，
“ 2015”：[
“ 2015-01”，
“ 2015-02”，
“ 2015-03”，
…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f495d18f0fc7e8ee6cadf30a8c88f55f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3135164eea837beed933f4d792fb854/" rel="bookmark">
			idea快捷键使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理了这篇文章，开发效率提升了30%。
psvm+Tab键：快速输出main方法
效果
public static void main(String[] args) { } sout+Tab键：快速输出System.out.println();
对象.sout+Tab键
"狗哥".sout + Tab键 -&gt; System.out.println("狗哥"); 任意对象.var+Tab键：快速声明对象
"".var+Tab键 -&gt; String s = ""; new Object().var+Tab键 -&gt; Object o = new Object(); 任意布尔表达式.if+Tab键：快速输出if块
object1.equals(object2).if+Tab键 效果
if (object1.equals(object2)) { } 任意布尔表达式.while+Tab键：快速输出while块
object1.equals(object2).while+Tab键 效果
while (object1.equals(object2)) { } fori+Tab键：快速输出for代码块
for (int i = 0; i &lt; ; i++) { } Ctrl+Alter+T：代码包裹，很牛逼的功能
比如我们相对一段代码执行下面操作：
使用 if 包裹
使用 if / else 包裹
使用 while 包裹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3135164eea837beed933f4d792fb854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7f59edb4b005ddc4471f7d8ea675a2/" rel="bookmark">
			项目人力资源管理之编制项目人力资源管理计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念及定义 通过编制项目人力资源管理计划，确定项目的角色、职责以及汇报关系，并编制人员配备管理计划。任务、职责和回报关系可以分配到个人或团队。这些个人和团队可能属于组织内，也可能属于组织外部，或者两者的结合。内部团队通常与专职部门如工程部、市场部、或会计 部等有联系。
在大多数项目中，编制项目人力资源管理计划过程主要作为项目最初阶段的一部分。但是，这一过程的结果应当在项目的整个生命周期中进行经常性的复查，以保证它的持续实用性。如果最初的项目人力资源管理计划不再生效，就应当立即修正。
在编制项目人力资源管理计划时，要注意到与项目成本、进度、风险、质量及其他因素间的相互影响，同时也应注意到其他项目对同类人员的争夺，所以项目要有备选人员。
二、编制项目人力资源管理计划的工具和技术 组织理论 描述了如何招募合适的人员、如何构建组织以及构建什么样的组织。项目管理团队应该熟悉这些组织 理论以快速的明确项目职责和回报关系。下面就是用于描述组织的几种有效工具
1.组织结构图和职位描述
可使用多种形式描述项目的角色和职责，最常用的有三种：层次结构图、责任分配矩阵 和文本格式。除此之外，还有一些分计划（如风险、质量和沟通计划）中也可以列出某些项目的工作分配。无论 采用何种形式，都要确保每一个工作包有一个明确的责任人 ，而且每一个项目团队成员都非常清楚自己的角色和职责。
2.人际交往
人际交往是指在组织、行业、或职业环境中与他人的非正式或正式的互动。
通过在本单位内或本行业内的人际交流，有助于了解那些能影响人员配备方案的人际因素。
成功的人际交往还可以增长与人力资源相关 的 知识，如胜任力、专门经验和外部合作机会，增加获取人力资源的途径，从而改进人力资源管理。
人际交往活动的例子包括写信、午餐会、非正式对话（如会议和活动）、贸易洽谈会和座谈会。
人际交往在项目初期特别有用，并可在项目期间及项目结束后有效促进项目管理职业的发展 。
3.组织理论
组织理论说明了个人、团队和组织部门的关系 ，以及他们之间互动的方式。
有效利用组织理论中的通用知识，可以节约编制人员资源管理计划的时间、成本及 人力 投入，提高规划工作的效率。
在不同的组织结构中，人们可能有不同的表现、不同的业绩，可能展现出不同的人际特点。认识到这一点非常重要的。此外，可以根据组织 理论灵活使用领导风格，以适应项目生命周期中项目成熟度的变化。
有很多文献描述了如何构建组织以及构建什么样的组织。项目管理团队应该熟悉这些组织 理论从而能将这些知识应用于项目职责和汇报关系、项目团队的创建、项目团队和项目团队的管理。
4.专家判断 在编制人力资源管理计划时，在 下列情况下，可以借助于专家判断：
列出对人力资源的初步要求 ；根据项目所在组织的标准角色 描述，分析项目所需的角色；确定项目所需的初步投入 水平和资源数量 ；根据项目所在组织的文化确定所需的报告关系；根据经验教训和市场调节，指导提前配备人员；识别与人员 招募 、留用和遣散相关的 风险；为了符合规如《劳动法》等的要求，在人员招聘、工作安排、解雇等方面制定并推荐标准作业程序。 4.会议
在编制项目人力资源管理计划时，项目管理团队将会举行相关会议。在这些会议 中，应该综合使用其他工具和技术，使项目管理团队成员 对人力资源管理计划达成共识 。
三、编制人力资源管理计划的输入 1.项目管理计划
要编制人力资源管理计划、得先参考项目管理计划。
项目管理 计划包括了编制人力资源管理计划所需的一些信息，例如对项目活动及其所需资源的描述、质量保证、风险管理、采购管理等，从这些活动中，项目管理团队可以找出所有必须的角色和职位。
用于指定人力资源管理计划的信息包括但不限于：
项目生命周期和拟用于每个阶段的过程；为完成项目目标，如何执行各项工作； 变更管理计划 ，规定如何监控变更；配置管理计划，规定如何开展配置管理；如何维持项目基准的变更；干系人之间的沟通需求和方法； 2.活动资源需求
3.事业环境因素
对于编制项目人力资源管理计划过程产生重要影响的事业环境因素有以下几个
（1）组织、文化和结构：那些组织或部门参与该项目？他们目前的工作安排 是什么？他们之间存在何种正式或分正式的关系？
关于组织类型的项目的影响：例如一个弱举证的组织结构就意味着项目经理的权利相对较弱。
（2）现有的人力资源与人力资源政策
（3）后勤保障：项目成员之间相隔多远？是否有人在不同的城市 、国家或时区？
（4）人事管理政策：这些政策对人员的招聘、项目团队建设等将产生直接影响。
（5）市场条件：人才市场的供求关系直接决定了人员招聘的难易程度以及人员薪资的待遇。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af7f59edb4b005ddc4471f7d8ea675a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de65c4a475640b712e631bd3d4c99395/" rel="bookmark">
			云班课js脚本解除视频不可快进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**最新文章会在我的个人网站发布：http://www.xiaokai1999.cn/
**
由于疫情，我们学校的课程通过云班课来进行。
原因 老师设置视频不能拖动，导致不能直接看想看的部分，降低了效率
效果 问题：
因为网络的问题，加载的有点慢。不能快进的太快，虽然他已经记录好了看过的时间，但是会回弹（烦躁） 开插件前：
开插件后：
操作 1.添加controls属性 2.删除云班课自带的视频控制器 大功告成
我只不过用油猴自己写了一个脚本。
脚本下载地址 GitHub下载
greasyfork官方
下载完脚本直接导入油猴即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd592968e9d628fddf15744dad47382/" rel="bookmark">
			Parallels Desktop的windows虚拟机无法打开iso文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于某些原因不得不用老古董的vs2008来解决问题，结果发现iso文件打不开，如下：
经过一番查找，发现解决办法：把iso文件放入到windows虚拟机下的c盘中：
参考: https://blog.csdn.net/lbzhao_28/article/details/79732012
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0848b10602a9e63aae6c6ea6a4464bd8/" rel="bookmark">
			eclipse导入项目出现红叉解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、导入项目之前，请确认工作空间编码已设置为utf-8
window-&gt;Preferences-&gt;General-&gt;Wrokspace-&gt;Text file encoding-&gt;Other 选择UTF-8，应用。
2、由于开发环境知中JRE以及Tomcat Library名称可能和源代码中的不一致，可能会出现Build Path的错误，解决方法如下：
右键project-&gt;Build Path-&gt;Configure Build Path-&gt;选择Libraries -&gt;删除带小红叉的Library-&gt;点击Add Library-&gt;选择JRE System Library(删了Tomcat Library的话就选择Server Runtime)-&gt;选择一个JRE后-&gt;Finish，如果是mysql的jar包错误，则导入自己版本的jar包。
3、进入项目包下的.settings目录，找到org.eclipse.wst.common.project.facet.core.xml文件，用记事本打道开后查看《runtime name=“Apache Tomcat v8.0”/》，看是否与你eclipse设置的tomcat版本一致，如果不一致，则修改成自己Tomcat版本，然后点击项目的错误包!
点击进入web.xml。然后把里面的内容全部裁剪，然后进行空保存，等系统刷新之后再把裁剪内容又复制进去，保存。
之后就好了，没有红叉，没有错误包提示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d961a598be1adb8d2b1fbb38084d896b/" rel="bookmark">
			渣渣机器学习零碎笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		渣渣机器学习零碎笔记 支持向量机 1、在线性可分情况下，训练数据集的样本点与分离超平面距离最近的样本点的实例称为：支持向量机
2、线性可分支持向量机：给定线性可分训练数据集，通过间隔最大为目标，求解相应的凸二次规划问题，从而学习得到的最优分离超平面，此时解是唯一的
3、算法一：
线性可分支持向量机学习算法–最大间隔法：
输入：线性可分训练数据集。输出：最大间隔分离超平面和分类决策函数。
step1:构造并求解约束最优化问题：
min 1/2||w||^2 s.t. yi(w*xi+b)-1&gt;=0 求解最优解w,b 由此得到分离超平面：
w*x+b = 0 分类决策函数
f(x) = sign(w*x+b) SVM的效率依赖于：核函数的选择，核参数，软间隔参数
利用核技巧时，对于给定的核，特征空间和映射函数的取法是唯一的。（错）
序列最小最优化算法（SMO）的基本思路是：如果所有变量的解都满足此最优化问题的KKT条件，那么得到解；否则，选择两个变量，固定其他变量，针对其构建一个二次规划问题，称为子问题。SMO算法在每个子问题中选择两个变量优化，其中至少一个是违反KKT条件的。
不可分的样本，通过核函数映射到新的高维特征空间，使得样本变得可分，常见的核函数有多项式，高斯和sigmoid核函数
一般地，在不知道更多信息的时候使用高斯核函数是最稳妥的，高斯函数（RBF,径向基函数）是一个映射到无穷维的函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1161982a13c57b34953a499215a83c0/" rel="bookmark">
			最优化作业第6章——无约束多维非线性规划方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
#导入模块 from sympy import * import sympy as sp #将导入的模块重新定义一个名字以便后续的程序进行使用 from numpy import * import numpy as np #定义主要的处理函数 def main(): #x1,x2：目标函数变量；alpha：步长因子；f:目标函数；a,b:目标函数不同变量的解；dif_x1,dif_x2：目标函数偏导函数 #x_solver:目标函数变量解组成的矩阵；x_fun：包含alpha的迭代解函数组成的矩阵 # dif_x11，dif_x22：目标函数偏导函数；f_x_diff：目标函数偏导函数值组成的矩阵； # f_alpha_diff：对alpha求偏导得到的函数；alpha_solver：α的解;k:迭代的次数 #x_solver_k1:作为第k+1次迭代的解；x_solver_k：作为第k次迭代的解 k = 0 x1,x2,alpha = symbols("x1,x2,alpha",real = True)#将变量符号化，否则会出错 f = 8*x1**2 + 4*x1*x2 + 5*x2**2 #定义目标函数 a = 10 b=10 #定义目标函数的初始解的两维解 f_solver = 8*a**2 + 4*a*b + 5*b**2#得到给定初始解下的目标函数值 dif_x1 = sp.diff(f,x1) dif_x2 = sp.diff(f,x2) #目标函数对不同变量进行求偏导，得到偏导函数 dif_x11 = dif_x1.subs({x1: a, x2: b}) dif_x22 = dif_x2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1161982a13c57b34953a499215a83c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e953903a3e51551c74b34e6a6160c2/" rel="bookmark">
			图解---电脑连接wifi，显示无法连接到这个网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 无法连接到这个网络 解决办法 右键"此电脑"，点击属性
点击"控制面板主页"点击"网络和Internet"
点击"网络共享中心"
此时我的电脑显示：还没有连接任何网络。
大家在此时可以选择在此进行wifi连接，就会出现。然后点击
点击"属性"
若此处显示空白，请往下看其解决过程
进行勾选后，点击确定即可。此时wifi就能连接成功
解决点击"属性"，出现界面不正常 右键"此电脑"，点击管理
2.点击系统工具
3.点击系统
4.点找到Network Setup Service
并设置为手动方式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0d9fdc0178ae5fd28f76f08e495282/" rel="bookmark">
			Ubuntu 20.04安装过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 20.04安装过程 下载地址：http://releases.ubuntu.com/20.04/ubuntu-20.04-desktop-amd64.iso
使用VMware workstation进行安装操作
步骤1：选择语言，单击“安装Ubuntu”。如图所示。
步骤二：选择键盘布局，采用默认模式即可。单击“继续”。
步骤三：选择安装模式，默认即可，单击“继续”。
步骤四：选择安装类型，选择“清除整个磁盘并安装Ubuntu”，单击“现在安装”。
单击“继续”。
步骤五：选择时区，单击“继续”。
步骤六：设置用户名和密码，单击“继续”。
步骤七：等待下载安装完毕重启即可。
安装完成，点击“现在重启”。
安装vmware-tools工具参考Ubuntu18.04版本的安装过程操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa7c753f7cf3402bf2c3094fc564a95/" rel="bookmark">
			bin.tar.gz和bin.zip以及src.tar.gz和src.zip以及rpm和dmg的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载maven的时候，有很多个文件不知道下哪一个，今天记录一下对其做个解释：
文件后缀含义：
（1）bin代表二进制class文件(由java文件编译而成)，src代表源码（java源码），源码source比binary大一些，一般正常使用下载bin类型即可，如果要学习源码下载src类型。
（2）.tar.gz是linux的压缩包，.zip是windows的压缩包
因此：
bin.tar.gz是适用于linux、MacOsX系统的二进制文件
bin.zip是适用于windows的二进制文件
src.tar.gz是linux下的源码
src.zip是windows的源码
其他官网后缀含义：
Java
（1） .rpm(RedHat Linux Packages Manager)，是readhat linux 软件回二进制包管理答器。
（2）.dmg苹果电脑Mac OS 系统的安装包
（3）.exe应该都不用说了吧，win下的可执行程序
所以，根据自己的需要下载相对应的文件即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6730acc376741d68da26f9c631a97b83/" rel="bookmark">
			将vue打包项目集成到springboot项目中 使用thymeleaf模板实现后端启动直接调试接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 vue打包项目并集成到springboot项目中部署简单说明 vue打包项目并集成到springboot项目中 最近在研究，怎么把前后端分离的项目整合到一个包中，达到部署最简化的过程，于是乎研究把vue打包的项目集成到springboot项目中，这样就在打包springboot项目的时候就直接把前段的静态页面都携带进去了，部署就只需要启动一个jar包就可以实现页面访问及数据调取了。现在把自己的研究成果展示一下，希望能帮助有需要的人。
部署简单说明 本人使用的webstorm进行前端页面的开发，页面开发好以后，将项目打包，然后将目录dist下的statrc及index.html文件拷贝到springboot下resources下。如图及说明：
1、打包vue项目：命令，npm run build
打包好的项目如图：
2、将打包好的项目拷贝到springboot项目下，如图：
（这里需要注意的是，springboot项目resources目录下是没有static及templates文件夹的，在拷贝之前需要自己手动创建一下）。
3、以上步骤就已经把vue项目集成到springboot项目中了，接下来是怎么在springboot项目是使用集成的vue静态页面。
4、在yml文件下增加thymeleaf模板配置，如下
spring: #thymeleaf模板配置 thymeleaf: cache: false # 这个开发配置为false，避免改了模板还要重启服务器 prefix: classpath:/templates/ #模板文件视图前缀，默认是classpath:/templates/，可不用配置 suffix: .html #模板文件视图后缀，默认是.html，可不用配置 check-template-location: true #检查模板位置，可不用配置 encoding: utf-8 #编码字符集，默认为utf-8，可不用配置 servlet: content-type: text/html	#模板的内容类型，默认为text/html，可不用配置 mvc: static-path-pattern: /static/** 5、在pom文件中添加thymeleaf依赖，如下：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 6、启动项目，直接访问当前yml文件中配置的端口号，我的是8989。
http://localhost:8989
7、以上是我把前端项目打包后集成到springboot中的全过程，希望能对需要的人有用。同时也是为自己做个笔记，在整理的过程中来加固一下，欢迎大家指出问题，共同进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6c131a3e3c3b672ecb3846459f54aa/" rel="bookmark">
			ks8的数据管理---PV/PVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 所谓容器的Volume,其实就是将一个宿主机上的目录跟一个容器里的目录绑定挂载在了一起；volume 提供了非常好的数据持久化方案，不过在可管理性上还有不足:
要使用 Volume，Pod 必须事先知道Volume来自哪儿，需要提前创建；Pod 通常是由应用的开发人员维护，而 Volume 则通常是由存储系统的管理员维护。开发人员要获得上面的信息：要么询问管理员;要么自己就是管理员。 这样就带来一个管理上的问题：应用开发人员和系统管理员的职责耦合在一起了。如果系统规模较小或者对于开发环境这样的情况还可以接受。但当集群规模变大，特别是对于生成环境，考虑到效率和安全性，这就成了必须要解决的问题。
2、PV 1）介绍 PersistentVolume（PV）是集群中已由管理员配置的一段网络存储。集群中的资源就像一个节点是一个集群资源。PV是诸如卷之类的卷插件，但其生命周期独立于使用PV的任何单个pod。该API对象捕获存储的实现细节，即NFS，iSCSI或云提供商特定的存储系统。
PersistentVolumeClaim（PVC）是由用户进行存储的请求，PersistentVolumeClaim (PVC) 是对 PV 的申请 (Claim)， 它类似于pod。 Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。声明可以请求特定的大小和访问模式（例如，可以一次读/写或多次只读）。
PVC和PV是一一对应的，有了 PersistentVolumeClaim，用户只需要告诉 Kubernetes 需要什么样的存储资源，而不必关心真正的空间从哪里分配，如何访问等底层细节信息。这些 Storage Provider 的底层信息交给管理员来处理，只有管理员才应该关心创建 PersistentVolume 的细节信息。
虽然PersistentVolumeClaims允许用户使用抽象存储资源，但PersistentVolumes对于不同的问题，用户通常需要具有不同属性（例如性能）。群集管理员需要能够提供各种PersistentVolumes不同的方式，而不仅仅是大小和访问模式，而不会让用户了解这些卷的实现方式。对于这些需求，有StorageClass 资源。
StorageClass为管理员提供了一种描述他们提供的存储的“类”的方法。 不同的类可能映射到服务质量级别，或备份策略，或者由群集管理员确定的任意策略。 Kubernetes本身对于什么类别代表是不言而喻的。 这个概念有时在其他存储系统中称为“配置文件”。
2）生命周期 PV是群集中的资源。PVC是对这些资源的请求，并且还充当对资源的检查。PV和PVC之间的相互作用遵循以下生命周期：
Provisioning ——&gt; Binding ——&gt;Using——&gt;Releasing——&gt;Recycling
step1：供应准Provisioning—通过集群外的存储系统或者云平台来提供存储持久化支持。 静态提供Static：集群管理员创建多个PV。 它们携带可供集群用户使用的真实存储的详细信息。它们存在于Kubernetes API中，可用于消费。动态提供Dynamic：当管理员创建的静态PV都不匹配用户的PersistentVolumeClaim时，集群可能会尝试为PVC动态配置卷。此配置基于StorageClasses：PVC必须请求一个类，并且管理员必须已创建并配置该类才能进行动态配置。要求该类的声明有效地为自己禁用动态配置。 step2：绑定Binding—用户创建pvc并指定需要的资源和访问模式。在找到可用pv之前，pvc会保持未绑定状态。 step3：使用Using—用户可在pod中像volume一样使用pvc。 step4：释放Releasing—用户删除pvc来回收存储资源，pv将变成“released”状态。 由于还保留着之前的数据，这些数据需要根据不同的策略来处理，否则这些存储资源无法被其他pvc使用。
step5：回收Recycling—pv可以设置三种回收策略：保留（Retain），回收（Recycle）和删除（Delete）。 保留策略：当删除与之绑定的PVC时候，这个PV被标记为released（PVC与PV解绑但还没有执行回收策略）且之前的数据依然保存在该PV上，但是该PV不可用，需要手动来处理这些数据并删除该PV。删除策略：当删除与之绑定的PVC时候。回收策略：这个在1.14版本中以及被废弃，取而代之的是推荐使用动态存储供给策略，它的功能是当删除与该PV关联的PVC时，自动删除该PV中的所有数据。 注：
1&gt; PV必须先与POD创建，而且只能是网络存储不能属于任何Node，虽然它支持HostPath类型但由于你不知道POD会被调度到哪个Node上，所以你要定义HostPath类型的PV就要保证所有节点都要有HostPath中指定的路径。
2&gt; 目前只有NFS和HostPath类型卷支持回收策略，AWS EBS,GCE PD,Azure Disk和Cinder支持删除(Delete)策略。
3）PV 支持的类型 GCEPersistentDisk、NFS 、CephFS 、HostPath、Glusterfs 等
4）PV卷阶段状态 Available：资源尚未被claim使用
Bound：卷已经被绑定到claim了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6c131a3e3c3b672ecb3846459f54aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0cf71f0de53825ac5e7a209399d29d/" rel="bookmark">
			MFC中dlg.DoModal()返回-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天新加一个登陆对话框，替换主对话框之后居然显示不出来，经查，MFC中dlg.DoModal()返回-1，后来在网上查到各种原因，对比后发现，我可能在对话框上用了 RICHEDIT 控件，然后添加 AfxInitRichEdit(); 果然解决了问题。
特此记录！
参考：
https://zhidao.baidu.com/question/307199776.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/234/">«</a>
	<span class="pagination__item pagination__item--current">235/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/236/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>