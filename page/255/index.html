<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543a6f7b40ed5892ddb34e0fe13a0b6f/" rel="bookmark">
			WPF RichTextBox控件用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF RichTextBox控件用法 1. 取得已被选中的内容： (1)使用RichTextBox.Document.Selection属性 (2)访问RichTextBox.Document.Blocks属性的“blocks”中的Text 2.WPF RictTextBox内容清空方式 txtXml.Document.Blocks.Clear(); 3. 从文件中读出纯文本文件后放进RichTextBox或直接将文本放进RichTextBox中: private void LoadTextFile(RichTextBox richTextBox, string filename) { richTextBox.Document.Blocks.Clear(); using (StreamReader streamReader = File.OpenText(filename)) { Paragraph paragraph = new Paragraph(); paragraph.Text = streamReader.ReadToEnd(); richTextBox.Document.Blocks.Add(paragraph); } } private void LoadText(RichTextBox richTextBox, string txtContent) { richTextBox.Document.Blocks.Clear(); Paragraph paragraph = new Paragraph(); paragraph.Text = txtContent; richTextBox.Document.Blocks.Add(paragraph); } 取得指定RichTextBox的内容： private string GetText(RichTextBox richTextBox) { TextRange textRange = new TextRange(richTextBox.Document.ContentStart, richTextBox.Document.ContentEnd); return textRange.Text; } 将RTF (rich text format)放到RichTextBox中： private static void LoadRTF(string rtf, RichTextBox richTextBox) { if (string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/543a6f7b40ed5892ddb34e0fe13a0b6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8ba1675df3c3ec4b38871273d45408/" rel="bookmark">
			Unity全方位观察物体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的项目中遇到了一个需求：要求能全方位并细致的观察物体。
一开始我的想法是物体旋转，然后相机能够缩放视角，
于是立马着手写出了以下的代码:
float x; float y; float xSpeed; float ySpeed; private void Update() { if (Input.GetMouseButton(0))	//一般是鼠标右键控制，但是工程要打包成Web版本按键会有冲突所以此处用鼠标左键 { x = Input.GetAxis("Mouse X") * xSpeed; y = Input.GetAxis("Mouse Y") * ySpeed; transform.Rotate(new Vector3(y, x, 0),Space.World);	//此处遇到了问题，如果没有Space.World物体旋转180度之后旋转轴会反向旋转 } else if (Input.GetAxis("Mouse ScrollWheel") != 0) { float ViewValue=0; if (ViewValue&lt; 0) { //范围值限定 if (Camera.main.fieldOfView &lt;= 100) Camera.main.fieldOfView += 2; if (Camera.main.orthographicSize &lt;= 20) Camera.main.orthographicSize += 0.5F; } //Zoom in if (ViewValue &gt; 0) { //范围值限定 if (Camera.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef8ba1675df3c3ec4b38871273d45408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b2a3dd4ea4ab6504c60c0c71081a54a/" rel="bookmark">
			如何使用JGIT在远程仓库获取提交详情记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用JGIT在远程仓库获取提交详情记录 第一步：获取一个GIT对象第二步：根据GIT对象获取所有的版本号第三步：根据筛选的版本号获取指定的记录 这个是JGIT的API：https://download.eclipse.org/jgit/docs/jgit-2.0.0.201206130900-r/apidocs/org/eclipse/jgit/lib/Ref.html
第一步：获取一个GIT对象 在远程获取GIT时，大部分的时候第一步操作就是将远程仓库的项目克隆到本地，然后对本地的项目进行操作。不同与SVN，SVN可以无需将远程项目克隆到本地。
克隆分为两种，
第一：未使用JGIT之前，所需要的项目已经在本地GIT仓库存在了。
这种情况，需要使用Git.open(new File(“D:\GitCloneRepository” + File.separator + this.pjName));这个方法打开本地的GIT库获取一个GIT对象。
第二：本地没有，这时候就需要去远程仓库获取，代码在下面。克隆的时候需要设置远程的url、远程git的用户名和密码，然后指定本地仓库的位置即可。
下面的代码里，我还获取了，克隆下来项目的所有分支。并展示当前所使用的是哪个分支
！！！！！！JGIT远程获取时，默认获取master分支，使用setCheckFetchedObjects(true)方法，可以克隆所有分支到本地，然后从本地切换分支来操作。（本人使用）
切换分支方法： git.checkout().setCreateBranch(false).setName(branch).call();
public class GitUtil { private Git git;// git对象 private String userName;// 资源库账户 private String pwd;// 密码 private String giturl;// git地址 private String pjName;// 项目名 private String branch;// 分支名 public GitUtil2(String userName, String pwd, String giturl, String pjName, String branch) throws Exception { this.userName = userName; this.pwd = pwd; this.giturl = giturl; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b2a3dd4ea4ab6504c60c0c71081a54a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed62e068725c3932f867d7a8bd32d82a/" rel="bookmark">
			【Akka】入门Demo分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司用到spary+akak，然后从官网找了一个入门的例子，现在分析一下
1.简单demo 首先akka给我的感觉就是一个异步的发送消息的机制，如果我用java来解释，那就是重新起一个新线程，然后调用一个类的方法。
//简单定义一些用到的消息类 object Greeter { //#greeter-messages def props(message: String, printerActor: ActorRef): Props = Props(new Greeter(message, printerActor)) //#greeter-messages final case class WhoToGreet(who: String) case object Greet } //继承Actor，实现receive方法，printerActor这也是个actor，这里省略 class Greeter(message: String, printerActor: ActorRef) extends Actor { import Greeter._ import Printer._ var greeting = "" def receive = { case WhoToGreet(who) =&gt; greeting = message + ", " + who case Greet =&gt; //#greeter-send-message printerActor ! Greeting(greeting) //#greeter-send-message } } //相当于主函数 object AkkaQuickstart extends App { import Greeter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed62e068725c3932f867d7a8bd32d82a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04bf208d353fae085f4209a24cd6b5fd/" rel="bookmark">
			halcon里union1与union2的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 threshold(image, Region, 128, 255) connection(Region, ConnectedRegions) union1(ConnectedRegions, RegionUnion) 它是将所有区域变成一个整体，选择一个即为所有 union2(ConnectedRegions, RegionUnion) 它是将两个区域合并成一个整体，仅限两个 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ca3056b37c6ad90ae59e43ce88171a/" rel="bookmark">
			Could not transfer metadata      Not authorized , ReasonPhrase:Unauthorized. -
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在idea中终端里使用阿里云私有库的时候遇到了一个问题,记录一下,问题如下:
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 7.349 s
[INFO] Finished at: 2019-07-14T17:02:48+08:00
[INFO] Final Memory: 13M/47M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy (default-deploy) on project spring_l: Failed to retrieve remote metadata com.yeung:spring_l:1.0
-SNAPSHOT/maven-metadata.xml: Could not transfer metadata com.yeung:spring_l:1.0-SNAPSHOT/maven-metadata.xml from/to rdc-snapshots (https://repo.rdc.aliyun.com/repository/79018-snaps
hot-Y0ZSYe/): Not authorized , ReasonPhrase:Unauthorized. -&gt; [Help 1]
查了很多方法都没有什么用, 后来在某一篇文章的评论里看到了一条命令
mvn -s "path:/.m2/settings.xml" deploy
这条命令使指定mvn使用的settings.xml文件, 我也尝试在给我的命令 指定settings.xml文件, 没想到成功了(前提是你仓库的配置信息都没有问题)
mvn -s "d:/Users/setting.xml文件的路径" clean deploy -DskipTests
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47ca3056b37c6ad90ae59e43ce88171a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc9e56874f1fcb2c3bb992f622b2a8b/" rel="bookmark">
			百度网盘打不开解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行输入：rm -rf ~/baidunetdisk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c3cda960f387f07cf0cff610369c34/" rel="bookmark">
			Linux（Apache）Httpd服务器安装，启动及httpd.conf配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转载：https://blog.51cto.com/itwish/2160492
pache HTTP Server（简称Apache或httpd）是Apache软件基金会的一个开放源代码的网页服务器软件，旨在为unix，windows等操作系统中提供开源httpd服务。由于其安全性、高效性及可扩展性，被广泛使用，自1996年4月以来，Apache一直是Internet上最流行的HTTP服务器。它快速、可靠并且可通过简单的API扩充，将Perl／Python等解释器等编译到httpd的相关模块中。
HTTPD特性及功能 Apache支持许多特性，大部分通过编译的模块实现，这些特性从服务器端的编程语言支持到身份认证方案。通用的语言接口支持Perl，Python，Tcl 和 PHP；流行的认证模块包括mod_access，mod_auth和mod_digest；其他的有SSL和TLS支持（mod_ssl），代理服务器（proxy）模块，很有用的URL重写（由mod_rewrite实现），定制日志文件（mod_log_config），以及过滤支持（mod_include和mod_ext_filter）等。主要特性如下：
高度模块化设计： core + modules 支持DSO：Dynamic Shared Object ，动态共享库 支持MPM模块：Multipath Processing Modules，多道处理模块 。 同时支持以下功能：虚拟主机 virtual host ；CGI：Common Gateway Interface，通用网关接口；丰富的用户认证机制：basic；digest；用户站点等。
MPM包含的机制 prefork机制：预先生成进程，服务器启动时会生产多个进程，并且每一个进程处理一个请求，比较稳定，任何一个进程崩溃了都不会影响到其他的进程 。如：select（）函数
worker机制：这是一种基于线程来工作，服务器启动时生成多个进程，每一个进程要生成多个线程，一个线程用来处理一个请求
event机制：基于事件驱动机制来工作的，这种机制可以使用一个进程来响应多个请求。它的并发能力是最强的。它在httpd-2.4以后得到支持。如event-driven ——事件驱动
Httpd yum安装与编译安装
1）Installing on CentOS6.x , yum源安装
yum install httpd -y 安装 chkconfig --add httpd 加入启动服务 chkconfig httpd on 默认启动级别自启动 service httpd start 启动httpd服务 httpd相关配置文件： 主配置文件：/etc/httpd/conf/httd.conf ，这个是httpd最主要的配置文档
扩展配置文件：/etc/httpd/conf.d/*.conf ，这个是httpd的额外配置文档
文档根目录： /var/www/html ，这个是apache 首页的文档目录 ，即输入http://127.0.0.1 显示页面所在的目录
服务脚本：/etc/rc.d/init.d/httpd
错误目录：/var/www/error ，服务器设定错误，请求的资源错误或浏览器访问出现错误等错误文件的存储目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c3cda960f387f07cf0cff610369c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57fe2e3ce5fd3ef15ee37e1fae95d728/" rel="bookmark">
			verilog之门级相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、veriog中有关门的关键字总共有26个，本篇只介绍简单的几个
（1）and-------与门
（2）nand-------与非门
（3）nor ---------或与门
（4）or-----------或门
（5）xor---------异或门
（6）xnor--------同或
（7）buf---------缓冲器
（8）not--------非门
2、门的声明语句格式：
&lt;门的类型&gt;[&lt;驱动能力&gt;&lt;延时&gt;]&lt;门实例1&gt;[,&lt;门实例2&gt;，........，&lt;门实例n&gt;]
门的类型：26个关键字之一
驱动能力、延时：可选项
门实例：类似于例化
实例：
nand #10 nd1（a，data，clock，clear）
名为nd1的与非门
输入为：data、clock和clear
输出为a
输入与输出的延时为10个时间单位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863b103239db7a0463312c09d52ad803/" rel="bookmark">
			python opencv提取指定颜色区域及图像腐蚀、膨胀简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以提取红色区域为例，红色有两个区域范围，HSV基本颜色分量范围参考博客:【OpenCV】HSV颜色识别-HSV基本颜色分量范围
原图为：
import cv2 import numpy as np img = cv2.imread('/home/yasin//book.png') # range of red lower_red = np.array([160, 60, 60]) upper_red = np.array([180, 255, 255]) lower_red2 = np.array([0, 60, 60]) upper_red2 = np.array([10, 255, 255]) # thers is two ranges of red # range of yellow # lower_yellow = np.array([10,100,100]) # upper_yellow = np.array([45,255,255]) # range of grenn # lower_yellow = np.array([36,25,25]) # upper_yellow = np.array([70,255,255]) # change to hsv model hsv = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863b103239db7a0463312c09d52ad803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25dd8dcf67ef3c14348e836ba3c44e7/" rel="bookmark">
			JDK实现动态代理，以及InvocationHandler接口invoke()方法的三个参数的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码：
首先是要被代理的接口：
/** * 被代理的主体需要实现的接口 */ public interface Subject { String doSomething(String thingsNeedParm); String doOtherNotImportantThing(String otherThingsNeedParm); } 然后是代理接口的实现类：
public class SubjectIpml implements Subject { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String doSomething(String thingsNeedParm) { System.out.println("使用" + thingsNeedParm + "做了一些事情"); return "调用成功"; } @Override public String doOtherNotImportantThing(String otherThingsNeedParm) { System.out.println("使用" + otherThingsNeedParm + "做了一些事情"); return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25dd8dcf67ef3c14348e836ba3c44e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d06fc71123d1743fd79f00c6c929e01/" rel="bookmark">
			shell中的if语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本语法:
if [ command ]; then 符合该条件执行的语句 fi 2、扩展语法：
if [ command ];then 符合该条件执行的语句 elif [ command ];then 符合该条件执行的语句 else 符合该条件执行的语句 fi 3、语法说明：
bash shell会按顺序执行if语句，如果command执行后且它的返回状态是0，则会执行符合该条件执行的语句，否则后面的命令不执行，跳到下一条命令。
当有多个嵌套时，只有第一个返回0退出状态的命令会导致符合该条件执行的语句部分被执行,如果所有的语句的执行状态都不为0，则执行else中语句。
返回状态：最后一个命令的退出状态，或者当没有条件是真的话为0。
注意：
1、[ ]表示条件测试。注意这里的空格很重要。要注意在'['后面和']'前面都必须要有空格
2、在shell中，then和fi是分开的语句。如果要在同一行里面输入，则需要用分号将他们隔开。
3、注意if判断中对于变量的处理，需要加引号，以免一些不必要的错误。没有加双引号会在一些含空格等的字符串变量判断的时候产生错误。比如[ -n "$var" ]如果var为空会出错
4、判断是不支持浮点值的
5、如果只单独使用&gt;或者&lt;号，系统会认为是输出或者输入重定向，虽然结果显示正确，但是其实是错误的，因此要对这些符号进行转意
6、在默认中，运行if语句中的命令所产生的错误信息仍然出现在脚本的输出结果中
7、使用-z或者-n来检查长度的时候，没有定义的变量也为0
8、空变量和没有初始化的变量可能会对shell脚本测试产生灾难性的影响，因此在不确定变量的内容的时候，在测试号前使用-n或者-z测试一下
9、? 变量包含了之前执行命令的退出状态（最近完成的前台进程）（可以用于检测退出状态）
常用参数：
文件/目录判断：
常用的： [ -a FILE ] 如果 FILE 存在则为真。 [ -d FILE ] 如果 FILE 存在且是一个目录则返回为真。 [ -e FILE ] 如果 指定的文件或目录存在时返回为真。 [ -f FILE ] 如果 FILE 存在且是一个普通文件则返回为真。 [ -r FILE ] 如果 FILE 存在且是可读的则返回为真。 [ -w FILE ] 如果 FILE 存在且是可写的则返回为真。（一个目录为了它的内容被访问必然是可执行的） [ -x FILE ] 如果 FILE 存在且是可执行的则返回为真。 不常用的： [ -b FILE ] 如果 FILE 存在且是一个块文件则返回为真。 [ -c FILE ] 如果 FILE 存在且是一个字符文件则返回为真。 [ -g FILE ] 如果 FILE 存在且设置了SGID则返回为真。 [ -h FILE ] 如果 FILE 存在且是一个符号符号链接文件则返回为真。（该选项在一些老系统上无效） [ -k FILE ] 如果 FILE 存在且已经设置了冒险位则返回为真。 [ -p FILE ] 如果 FILE 存并且是命令管道时返回为真。 [ -s FILE ] 如果 FILE 存在且大小非0时为真则返回为真。 [ -u FILE ] 如果 FILE 存在且设置了SUID位时返回为真。 [ -O FILE ] 如果 FILE 存在且属有效用户ID则返回为真。 [ -G FILE ] 如果 FILE 存在且默认组为当前组则返回为真。（只检查系统默认组） [ -L FILE ] 如果 FILE 存在且是一个符号连接则返回为真。 [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则返回为真。 [ -S FILE ] 如果 FILE 存在且是一个套接字则返回为真。 [ FILE1 -nt FILE2 ] 如果 FILE1 比 FILE2 新, 或者 FILE1 存在但是 FILE2 不存在则返回为真。 [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 老, 或者 FILE2 存在但是 FILE1 不存在则返回为真。 [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则返回为真。 字符串判断
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d06fc71123d1743fd79f00c6c929e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5215fb6e65b10526437404e2f7c63f78/" rel="bookmark">
			Python_爬虫_爬取豆瓣Top250电影排行榜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 模块准备
（1）Requests：简化了urllib的许多操作，在爬虫程序中最受欢迎。通过get()方法从服务器上下载网页，但是下载的为网页的源代码，需要进行解析。通过pip install requests进行安装。
（2）BeautifulSoup4 (BS4)：是一个网页解析利器。通过pip install bs4进行安装。
2. 程序实现
（1）核心程序
import requests import bs4 #获取榜单 res = requests.get('https://movie.douban.com/top250') #解析网页内容 soup = bs4.BeautifulSoup(res.text, 'html.parser') targets = soup.find_all('div', class_='hd') for each in targets: print(each.a.span.text) （2）完整程序
import requests import bs4 import re def open_url(url): # 使用代理 # proxies = {"http": "127.0.0.1:1080", "https": "127.0.0.1:1080"} headers = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36'} # res = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5215fb6e65b10526437404e2f7c63f78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81c89bdd3480bf766a19a027dab9502/" rel="bookmark">
			python爬虫动态HTML处理（Selenium &#43; PhantomJS 快速入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. HTML介绍 1.1 javaScript JavaScript 是网络上最常用也是支持者最多的客户端脚本语言。它可以收集 用户的跟踪数据，不需要重载页面直接提交表单，在页面嵌入多媒体文件，甚至运行网页游戏。 我们可以在网页源代码的
&lt;script type="text/javascript" src="https://statics.huxiu.com/w/mini/static_2015/js/sea.js?v=201601150944" &gt;&lt;/script&gt; 1.2 jQuery jQuery 是一个十分常见的库，70% 最流行的网站（约 200 万）和约 30% 的其他网站 （约 2 亿）都在使用。一个网站使用 jQuery 的特征，就是源代码里包含了 jQuery 入口，比如:
&lt;script type="text/javascript" src="https://statics.huxiu.com/w/mini/static_2015/js/jquery-1.11.1.min.js?V =201512181512"&gt;&lt;/script&gt; 如果你在一个网站上看到了 jQuery，那么采集这个网站数据的时候要格外小心。jQuery可以动态地创建 HTML 内容，只有在JavaScript 代码执行之后才会显示。如果你用传统 的方法采集页面内容，就只能获得 JavaScript 代码执行之前页面上的内容。
1.3 Ajax 我们与网站服务器通信的唯一方式，就是发出 HTTP 请求获取新页面。如果提交表单之后，或从服务器获取信息之后，网站的页面不需要重新刷新，那么你访问的网站就在用 Ajax 技术。
Ajax 其实并不是一门语言，而是用来完成网络任务（可以认为它与网络数据采集差不多）的一系列技术。
Ajax 全称是 Asynchronous JavaScript and XML（异步 JavaScript 和 XML），网站不需要使用单独的页面请求就可以和网络服务器进行交互 （收发信息）。
1.5 DHTML 和Ajax 一样，动态 HTML（Dynamic HTML， DHTML）也是一系列用于解决网络问题的技术集合。
DHTML 是用客户端语言改变页面的 HTML 元素（HTML、CSS，或者二者皆被改变）。比如页面上的按钮只有当用户移动鼠标之后才出现，背景色可能每次点击都 会改变，或者用一个 Ajax 请求触发页面加载一段新内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81c89bdd3480bf766a19a027dab9502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4adb9c4bf6892fa4aa35546617dbd9e9/" rel="bookmark">
			单机监控-shell脚本监测java应用程序是否宕机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于工作中很多项目需要java应用程序在后台执行任务，但是有些时候后台运行的java应用程序会莫名其妙的死掉，此时运维/运营人员无法及时发现宕机的应用程序，只能够通过业务流程不正常才能够发现宕机的应用，对业务有很大的影响，由于公司服务器资源比较有限，无法部署统一的监测系统，特采用shell脚本的方式来监测java的应用进程是否正常运行，无须在业务代码中嵌入监控代码，做到低耦合，高内聚。
监测原理 原理图
java应用启动时，采用自定义脚本方式启动，然后将应用的当前进程号进行应用的根目录下生成pid.txt文件shell脚本执行的时候查找指定目录下的所有pid.txt文件，然后根据每个pid.txt中的进程号判断当前的进程是否存活如果根据进程号没有找到指定的进程则认为进程死掉，主动发送告警（此处采用钉钉群机器人的方式告警） 监控脚本 java应用启动脚本
#!/bin/sh root_dir=$(dirname $(readlink -f "$0")) class_path=$root_dir/bin:$root_dir/lib/* pid_file=$root_dir/pid.txt console_file=$root_dir/logs/console.out error_file=$root_dir/logs/errors.out echo "Starting channel app in $root_dir ..." if [ ! -f $pid_file ]; then nohup java -cp $class_path com.xxx.StartUp &gt;&gt; $console_file 2&gt;&amp;1 &amp; echo $! &gt; $pid_file echo "[$(date)]: app in $root_dir started successful!" &gt;&gt; $console_file echo "pid = $!" &gt;&gt; $console_file echo "[$(date)]: app in $root_dir started successful!" echo "pid = $!" else echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4adb9c4bf6892fa4aa35546617dbd9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce4f67db5ce3e4117b28fa84d6519db/" rel="bookmark">
			SpringBoot 集成 Spring Security（9）——解决 UserNotFoundException 不抛出问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 《SpringBoot 集成 Spring Security》系列文章，原本只是我自己学习后写的笔记，没想到受到大家的欢迎，能够对大家带来帮助，让我感到十分高兴。但说起来我也只是初学者，这一系列文章中可能也存在错误，本文是为了解决 UserNotFoundException 这个异常无法抛出而写出。
这个问题大致是这样的，我们知道 Spring Security 的验证处理是由某个 Provider 处理的，在 Provider 中通过对应的 UserDetailsService 的 loadUserByUsername() 来决定如何加载数据库中的用户信息。
以 《SpringBoot集成Spring Security（3）——异常处理》 代码为例，采用默认的用户名密码登陆方式，我们在 CustomUserDetailsService 类中，有这么一行代码：
@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { ... // 判断用户是否存在 if(user == null) { throw new UsernameNotFoundException("用户名不存在"); } ... } 但是实际运行后你会发现，当用户不存在时，只会抛出 BadCredentialsException，而不是 UsernameNotFoundException，百度下后发现这个问题的人不在少数。在本文中，我将介绍为什么会无法抛出 UsernameNotFoundException，以及如何解决这个问题。
二、导致的原因是什么？ 首先说明，出现这种情况只有在你使用默认的用户名密码登陆方式，且没有自定义 Provider 的情况下，才会发生！如果你有自定义 Provider，仍然出现这个问题，说明代码写的有问题，这一点在后面我会说。
由提供的源码地址中，第三章和第四章两篇文章是一个项目。分别是 springboot_security03 和 springboot_security03_filter。由于前者是自定义 Provider 实现，因此理论上不会出现这个问题，所以我们以后者代码为例。
运行 springboot_security03_filter 项目，发现当用户不存在时，的确抛出的是 BadCredentialsException。我们给抛出异常那行代码加断点，进行调试。
@Service("userDetailsService") public class CustomUserDetailsService implements UserDetailsService { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce4f67db5ce3e4117b28fa84d6519db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226ac49673d3206613e69fa50761860f/" rel="bookmark">
			MFC获得当前应用程序目录的GetCurrentDirectory()和GetModuleFileName()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 开发过程中经常需要获得程序当前的运行目录，这时就可以使用GetCurrentDirectory()和GetModuleFileName()函 数，GetCurrentDirectory只是返回当前进程的当前目录,而并不是进程的镜像文件(.exe)所在的目 录，GetCurrentDirectory()适用于XP等系统，,在WinCE上不能使用，GetModuleFileName()适用于 WinCE2.0以后. 函数说明:
DWORD WINAPI GetModuleFileName(
HMODULE hModule,
LPTSTR lpFileName,
DWORD nSize
);
函数功能
此函数得到当前应用程序的运行目录，还包括应用程序的文件名。
参数说明
hModule：要获取文件名的模块名柄，可以是运用LoadLiberary得到的句柄,null表示当前模块
lpFileName:输出参数，存放取得的文件名
nSize:lpFileName参数的长度
DWORD GetCurrentDirectory(
DWORD nBufferLength, // size of directory buffer
LPTSTR lpBuffer // directory buffer
);
函数功能
找到当前进程的当前目录
参数说明
nBufferLength：lpBuffer缓冲区的长度
lpBuffer：指定一个预定义字串，用于装载当前目录
返回值
调用成功 返回装载到lpBuffer的字节数。
使用方法:
//下面的一段代码主要是获得当前程序的运行目录(.exe)所在的目录
{
CString path;
GetModuleFileName(NULL,path.GetBufferSetLength(MAX_PATH+1),MAX_PATH);
path.ReleaseBuffer();
int pos = path.ReverseFind('\\');
path = path.Left(pos);
}
GetModuleFileName函数
WINAPI DWORD GetModuleFileName(
HMODULE hModule,
LPWSTR lpFilename,
DWORD nSize
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226ac49673d3206613e69fa50761860f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a958fbb57943f3c7356a1c53a3a6111e/" rel="bookmark">
			Android动态申请权限（一次申请多个动态权限）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android动态申请权限（一次申请多个动态权限） Android 6.0也就是API等级23之后，获取权限需要动态申请，否则程序无法正常使用。
以录像功能为例，录像需要读写、相机和麦克风3个权限。下面是一次申请多个权限的代码，单个权限申请也是差不多的。另外，在用户禁止后弹出对话框引导用户跳转到设置界面去设置。
package com.barrage.barragetest; import android.Manifest; import android.content.DialogInterface; import android.content.Intent; import android.content.pm.PackageManager; import android.net.Uri; import android.os.Build; import android.os.Bundle; import android.provider.Settings; import android.support.annotation.NonNull; import android.support.v4.app.ActivityCompat; import android.support.v7.app.AlertDialog; import android.support.v7.app.AppCompatActivity; import android.widget.Toast; public class MainActivity extends AppCompatActivity { //录像需要的权限 private static final String[] VIDEO_PERMISSIONS = {Manifest.permission.CAMERA,Manifest.permission.RECORD_AUDIO,Manifest.permission.WRITE_EXTERNAL_STORAGE}; private static final int VIDEO_PERMISSIONS_CODE = 1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); requestPermission(); } //申请权限 private void requestPermission() { // 当API大于 23 时，才动态申请权限 if (Build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a958fbb57943f3c7356a1c53a3a6111e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be8905a225e3c52c0544f3a34fa3136/" rel="bookmark">
			153、有效三角形的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。
示例 1:
输入: [2,2,3,4]
输出: 3
解释:
有效的组合是:
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
注意:
数组长度不超过1000。
数组里整数的范围为 [0, 1000]。
先排序然后用指针
class Solution { public int triangleNumber(int[] nums) { Arrays.sort(nums); int result = 0; for (int i = 0; i &lt; nums.length - 2; i++) { for (int j = i + 1; j &lt; nums.length - 1; j++) { for (int k = j + 1; k &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be8905a225e3c52c0544f3a34fa3136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e22403eb05a61f695484e6966d1541/" rel="bookmark">
			VS2017配置QT环境（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近用QT Creator老是莫名其妙的卡死，想想还是VS来编写QT程序稳定点。
1.打开vs2017，点击工具-扩展和更新 2.搜索框输入QT，在联机里搜索，选择QT Vsiual Studio Tools并安装（安装需要关闭VS，之后开始安装） 3.装好重新打开VS，菜单栏多出个QT VS Tools，点击QT Options 4.1点击Add，添加路径，选择QT目录里的MSVC，如图在QT的安装目录下找（根据自己电脑QT安装的位置） 4.2 很多人找不到QT安装路径，或者有个误区，VS能写QT前提是QT编程工具Qt Creator 和库已经安装好了，QT 有大几个G，不是VS装个小插件QT VS Tools就能省去装Qt 的，VS只是调用Qt Creator。 QT最新版下载，现在只能在线安装了，有点慢：
http://download.qt.io/official_releases/online_installers/
5.14.2还有离线安装包
http://download.qt.io/archive/qt/
忘了装哪了，右键QT Creator快捷方式属性，打开文件所在位置就能找到QT安装路径。 5.QT会自动识别版本 6.新建项目-&gt;Vsiual C++ -&gt; QT -&gt; Qt Gui Application 7.导航菜单直接next，finish，这些配置后面可再更改。 8.一个VS下的QT工程就建好了，目录和QT Creator里基本一致，点击xx.ui能够弹出QTdesigner来设计界面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10801cf8ddfbfbd972feee613084b48/" rel="bookmark">
			VS code_修改代码&amp;系统界面字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装好VS code后，要安装以下几个扩展
Ctrl + Shitf + p，输入 settings，选择 “首选项：打开设置（json）”
输入Font Size，进行查找
Editor: Font Size 用于修改代码的大小
Debug › Console: Font Size和Terminal › Integrated: Font Size
分别对应修改第二个图下方的调试控制台和终端中字体的大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e20bc2ef1e6dd9c130f5d048eba86ec/" rel="bookmark">
			简单使用栈实现队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;cstdio&gt; using namespace std; stack&lt;int&gt; stack1; stack&lt;int&gt; stack2; void appendTail(int ele) { stack1.push(ele); } int deleteHead() { int head; if(stack2.size()&lt;=0) { while(stack1.size()&gt;0) { int data = stack1.top(); stack1.pop(); stack2.push(data); } } if(stack2.size()==0)//这里不知道怎么处理，就返回了一个负一，抛异常不知道为什么不好使 return -1; head = stack2.top(); stack2.pop(); return head; } int main() { appendTail(1); appendTail(2); appendTail(3); int head=deleteHead(); cout&lt;&lt;head&lt;&lt;endl; head=deleteHead(); cout&lt;&lt;head&lt;&lt;endl; appendTail(4); head=deleteHead(); cout&lt;&lt;head&lt;&lt;endl; appendTail(5); head=deleteHead(); cout&lt;&lt;head&lt;&lt;endl; head=deleteHead(); cout&lt;&lt;head&lt;&lt;endl; return 0; } 转载于:https://www.cnblogs.com/xiaofeiwang/p/3825008.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3736887dad7f99e81d6e03533b3a84f1/" rel="bookmark">
			C&#43;&#43; 获取时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 两种获取时间的方式 使用 #include &lt;sys/time.h&gt; 下面的 gettimeofday函数 // 获取微秒 long GetCurrentMicroseconds(){ timeval time; gettimeofday(&amp;time,nullptr); return (time.tv_sec * 1000000 + time.tv_usec); } 如果需要毫秒,则 return (time.tv_sec * 1000 + time.tv_usec/1000)
使用 #include 下面的 chrono库
// 获取微秒 int64_t CurrentTimeMillis(){ auto now = chrono::system_clock::now(); return chrono::duration_cast&lt;chrono::microseconds&gt;(now.time_since_epoch()).count(); } 如果需要的是毫秒,则 return chrono::duration_cast&lt;:milliseconds&gt;(now.time_since_epoch()).count();
转载于:https://www.cnblogs.com/daihanlong/p/8663238.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb99d4bc257950b0c1e59671b07c526/" rel="bookmark">
			netlink2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发和维护内核是一件很繁杂的工作，因此，只有那些最重要或者与系统性能息息相关的代码才将其安排在内核中。其它程序，比如GUI，管理以及控制部分的代 码，一般都会作为用户态程序。在linux系统中，把系统的某个特性分割成在内核中和在用户空间中分别实现一部分的做法是很常见的(比如linux系统的 防火墙就分成了内核态的Netfilter和用户态的iptables)。然而，内核程序与用户态的程序又是怎样行通讯的呢？
答案就是通过各种各样的用户态和内核态的IPC(interprocess communication )机制来实现。比如系统调用，ioctl接口，proc文件系统以及netlink socket,本文就是要讨论netlink socekt并向读者展示这种用网络
通讯接口方式实现的IPC机制的优点。
介绍：
netlink socekt是一种用于在内核态和用户态进程之间进行数据传输的特殊的IPC。它通过为内核模块提
供一组特殊的API，并为用户程序提供了一组标准的socket 接口的方式，实现了一种全双工的通讯连接。类似于TCP/IP中使用AF_INET地址族一样，netlink socket使用地址族AF_NETLINK。每一个netlink
socket在内核头文件
include/linux/netlink.h 中定义自己的协议类型。
下面是netlink socket 目前的特性集合以及它支持的协议类型：
NETLINK_ROUTE 用户空间的路由守护程序之间的通讯通道，比如BGP,OSPF,RIP以及内核数据转发模块。用户态的路由守护程序通过此类型的协议来更新内核中的路由表。
NETLINK_FIREWALL:接收IPV4防火墙代码发送的数据包。
NETLINK_NFLOG:用户态的iptables管理工具和内核中的netfilter模块之间通讯的通道。
NETLINK_ARPD:用来从用户空间管理内核中的ARP表。 为什么以上的功能在实现用户程序和内核程序通讯时，都使用netlink方法而不是系统调用，ioctls
或者proc文件系统呢？原因在于：为新的特性添加一个新的系统调用,ioctls或者一个proc文件的做法并不是很容易的一件事情，因为我们要冒着污染内核代码并且可能破坏系统稳定性的风险去完成这件事情。
然而，netlink socket却是如此的简单，你只需要在文件netlink.h中添加一个常量来标识你的协议类型，然后，内核模块和用户程序就可以立刻使用socket风格的API进行通讯了！
Netlink提供了一种异步通讯方式，与其他socket API一样，它提供了一个socket队列来缓冲或者平滑
瞬时的消息高峰。发送netlink消息的系统调用在把消息加入到接收者的消息对列后，会触发接收者的接收处理函数。接收者在接收处理函数上下文中，可以 决定立即处理消息还是把消息放在队列中，在以后其它上下文去处理它(因为我们希望接收处理函数执行的尽可能快)。系统调用与netlink不同，它需要一 个同步的处理，因此，当我们使用一个系统调用来从用户态传递消息到内核时，如果处理这个消息的时间很长的话，内核调度的粒度就会受到影响。
内核中实现系统调用的代码都是在编译时静态链接到内核的，因此，在动态加载模块中去包含一个系统调用的做法是不合适的，那是大多数设备驱动的做法。 使用netlink socket时,动态加载模块中的netlink程序不会和linux内核中的netlink部分产生任何编译时依赖关系。
Netlink优于系统调用，ioctls和proc文件系统的另外一个特点就是它支持多点传送。一个进程可以把消息传输给一个netlink组地址，然 后任意多个进程都可以监听那个组地址(并且接收消息)。这种机制为内核到用户态的事件分发提供了一种近乎完美的解决方案。
系统调用和ioctl都属于单工方式的IPC，也就是说，这种IPC会话的发起者只能是用户态程序。但是，如果内核有一个紧急的消息想要通知给用户态程序 时，该怎么办呢？如果直接使用这些IPC的话，是没办法做到这点的。通常情况下，应用程序会周期性的轮询内核以获取状态的改变，然而，高频度的轮询势必会 增加系统的负载。Netlink 通过允许内核初始化会话的方式完美的解决了此问题，我们称之为netlink socket的双工特性。
最后，netlink socket提供了一组开发者熟悉的BSD风格的API函数，因此，相对于使用神秘的系统调用API或者ioctl而言，netlink开发培训的费用会更低些。
与BSD的Routing socket的关系
在BSD TCP/IP的协议栈实现中，有一种特殊的socket叫做Routing socket.它的地址族为AF_ROUTE, 协议族为PF_ROUTE, socket类型为SOCK_RAW. 这种Routing socket是用户态进程用来向内核中的路由表增加或者删除路由信息用的。在Linux系统中，netlink socket通过协议类型NETLINK_ROUTE实现了与Routing socket相同的功能，可以说，netlink socket提供了BSD Routing socket功能的超集。
Netlink Socket 的API
标准的socket API函数-
socket(), sendmsg(), recvmsg()和close() - 都能够被用户态程序直接调用来访问netlink socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb99d4bc257950b0c1e59671b07c526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b52a057d6f369958306b9d90f12a7f/" rel="bookmark">
			nfs使用mount -o传递用户名和密码参数需要修改的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		挂在的信息一般通过 nfs_parse_mount_option。可以直接打印。会有很多信息。
1.修改的地方在super.c该文件涉及到获取超级快等操作。
修改enum{}；在里面添加 Opt_username, Opt_passwd,
2.修改另一个枚举类型，添加：
Opt_username,"username=%s"
Opt_passed,"passwd=%s",
转载于:https://www.cnblogs.com/xindufresne/p/3777266.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89861d0c6b60cb8d5ac4735f20ebd3d7/" rel="bookmark">
			js创建函数的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般一下这三种方式
第一种（函数声明）： function sum1(num1,num2){
return num1+num2;
}
没啥好说的
第二种（函数表达式）：
var sum2 = function(num1,num2){
return num1+num2;
}
没啥好说的
第三种（函数对象方式）：
var sum3 = new Function("num1","num2","return num1+num2");
前面是参数，最后是函数体，随便写
第四种
(function(args){})(args)
匿名函数的定义，主要是不污染全局变量
转载于:https://www.cnblogs.com/benchan2015/p/5057667.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e193927bda09b955455a6bbc810b896d/" rel="bookmark">
			Java 通配符泛型例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请看下面的代码，其中会发生错误的代码已经注释掉，并且写明了错误类型
总体来说，泛型通配符就是为了支持多态时父子类，接口扩展类之间的相互转换而生
package test; import java.util.ArrayList; import java.util.List; public class GenericTester { public static void main(String[] args){ GenericTester genericTester=new GenericTester(); List&lt;TestA&gt; list=new ArrayList&lt;GenericTester.TestA&gt;(); GenericTester.TestA tester=genericTester.new TestA(); list.add(tester); TryGeneric1(list); TryGeneric2(list); // TryGeneric3(list); has compile error // TryGeneric4(list); has compile error } private interface ITest{ public void Test(); } private class TestA implements ITest{ @Override public void Test() { // TODO Auto-generated method stub System.out.println("TestA"); } } private static void TryGeneric1(List&lt;? extends ITest&gt; testList){ for(ITest tester:testList){ tester.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e193927bda09b955455a6bbc810b896d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c3c47eb3f690fec92c15a8766ab5f0/" rel="bookmark">
			【Python】opencv显示图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cv2 img = cv2.imread("lena.jpg") cv2.namedWindow("Image") cv2.imshow("Image", img) cv2.waitKey(0) cv2.destroyAllWindows() 转载于:https://www.cnblogs.com/tiandsp/p/8504204.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c12bd6a5b53a1df12f4bb1573c55406/" rel="bookmark">
			Linux编程（获取系统时间）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;time.h&gt; int main() { time_t now; struct tm *w; time(&amp;now); w=localtime(&amp;now); printf("%04d/%02d/%02d\n%02d:%02d:%02d\n",w-&gt;tm_year+1900, w-&gt;tm_mon+1,w-&gt;tm_mday,w-&gt;tm_hour,w-&gt;tm_min,w-&gt;tm_sec); return 0; } 转载于:https://www.cnblogs.com/tiandsp/p/7467885.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0436675160facbc9abae5099310cb1ba/" rel="bookmark">
			【JavaScript学习笔记】hello world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt; &lt;body&gt; &lt;script language="JavaScript"&gt; alert("Hello world"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 转载于:https://www.cnblogs.com/tiandsp/p/7467804.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0693cc7ca46aba699aac42b5433139/" rel="bookmark">
			【C#学习笔记】List容器使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections.Generic; namespace ConsoleApplication { class Program { static void Main(string[] args) { List&lt;int&gt; a = new List&lt;int&gt;(); a.Add(10); //顺序增加 a.Add(34); a.Insert(2, 1); //第2个位置插入1 foreach (int i in a) Console.Write(i + " "); Console.WriteLine(); a.Sort(); //从小到大排序 for (int i = 0; i &lt; a.Count;i++ ) Console.Write(a[i] + " "); a.Contains(10); //是否包含10 a.IndexOf(1); //返回元素1的下标 a.Remove(1); //删除1这个元素 a.RemoveAt(0); //删除位置在0的元素 a.Clear(); Console.Read(); } } } 转载于:https://www.cnblogs.com/tiandsp/p/7440410.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13090d481a24489c6fbe594bc4c93b04/" rel="bookmark">
			多媒体指令（内存拷贝加速）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来自己写了一个，不过性能竟然和memcpy一样，一点提升都没有，所以有就去网上找了一个性能好的。
下面的程序是对100MB数据进行内存拷贝.
我测试了一下。
直接调用memcpy时间为100ms左右，而asm中的程序能把时间能缩短到80ms左右。
性能提高的还是很明显的。
#include &lt;iostream&gt; #include &lt;ctime&gt; #define N 100*1024*256 using namespace std; int main(int argc, char* argv[]) { float *a; float *b; a=(float*)malloc(N*sizeof(float)); b=(float*)malloc(N*sizeof(float)); for (unsigned long i=0;i&lt;N;++i) { a[i]=rand(); } unsigned long n=N*sizeof(float); void *tbuf; tbuf=(void*)malloc(2048); time_t start,end; start=clock(); // memcpy(b,a,N*sizeof(float)); __asm { mov esi, [a] mov ecx, n mov ebx, ecx shr ebx, 11 // 2048 bytes at a time mov edi, [b] loop2k: // Copy 2k into temporary buffer push edi mov edi, tbuf mov ecx, 2048 shr ecx, 6 loopMemToL1: prefetchnta 64[esi] // Prefetch next loop, non-temporal prefetchnta 96[esi] movq mm1, 0[esi] // Read in source data movq mm2, 8[esi] movq mm3, 16[esi] movq mm4, 24[esi] movq mm5, 32[esi] movq mm6, 40[esi] movq mm7, 48[esi] movq mm0, 56[esi] movq 0[edi], mm1 // Store into L1 movq 8[edi], mm2 movq 16[edi], mm3 movq 24[edi], mm4 movq 32[edi], mm5 movq 40[edi], mm6 movq 48[edi], mm7 movq 56[edi], mm0 add esi, 64 add edi, 64 dec ecx jnz loopMemToL1 pop edi // Now copy from L1 to system memory push esi mov esi, tbuf mov ecx, 2048 shr ecx, 6 loopL1ToMem: movq mm1, 0[esi] // Read in source data from L1 movq mm2, 8[esi] movq mm3, 16[esi] movq mm4, 24[esi] movq mm5, 32[esi] movq mm6, 40[esi] movq mm7, 48[esi] movq mm0, 56[esi] movntq 0[edi], mm1 // Non-temporal stores movntq 8[edi], mm2 movntq 16[edi], mm3 movntq 24[edi], mm4 movntq 32[edi], mm5 movntq 40[edi], mm6 movntq 48[edi], mm7 movntq 56[edi], mm0 add esi, 64 add edi, 64 dec ecx jnz loopL1ToMem pop esi // Do next 2k block dec ebx jnz loop2k emms; } end=clock(); cout&lt;&lt;end-start&lt;&lt;endl; for (unsigned long i=N-10;i&lt;N;i++) { cout&lt;&lt;a[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13090d481a24489c6fbe594bc4c93b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b6d2e26c279ac87cc4188554c44d7b/" rel="bookmark">
			matlab练习程序（c/c&#43;&#43;调用matlab&lt;engine&gt;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就我目前了解的c++调用matlab有两种方法。
第一种是通过matlab引擎调用，也就是这里用到的方法。
第二种是用matlab将m文件编译为相应的h/lib/dll文件再加以调用。
使用engine所用到的h和lib文件基本在D:\Program Files\MATLAB\R2010b\extern里面，当然不同的机器安装的地方都不一样。
头文件只需engine.h即可。lib文件需要这三个：libmx.lib/libmat.lib/libeng.lib。至于如何配置我就不介绍了，方法很多。
引擎相应的部分函数如下：
engOpen：启动Matlab引擎
engClose：关闭Matlab引擎
engGetArray：从Matlab引擎中获得一个Matlab矩阵，用于数据交换
engPutArray：从应用程序向Matlab引擎发送一个Matlab矩阵，用于数据交换
engEvalString：执行一个Matlab命令
engOutputBuffer：创建一个用于存储Matlab文本输出的字符缓冲区
相应例程：
#include &lt;iostream&gt; #include &lt;math.h&gt; #include "engine.h" using namespace std; void main() { Engine *ep; //定义Matlab引擎指针。 if (!(ep=engOpen(NULL))) //测试是否启动Matlab引擎成功。 { cout &lt;&lt;"Can't start Matlab engine!" &lt;&lt;endl; exit(1); } //下面是将c++格式数据转换为matlab格式可用数据 double data[4]={1.0,2.0,3.0,4.0}; mxArray *Y=mxCreateDoubleMatrix(1,4,mxREAL); memcpy(mxGetPr(Y),data,sizeof(data)); engPutVariable(ep,"Y",Y); engEvalString(ep,"plot(Y,'o')"); //显示数据 mxDestroyArray(Y); engEvalString(ep,"figure"); //开一个新的显示窗口 // //下面是从matlab格式数据转换为c++格式可用数据 // mxArray *filename=NULL; // const char *name="D:/Program Files/MATLAB/R2010b/bin/win32/lena.jpg"; // filename=mxCreateString(name); // engPutVariable(ep,"filename",filename); engEvalString(ep,"X=imread('D:/Program Files/MATLAB/R2010b/bin/win32/lena.jpg');"); //在engine中读取一张图片 engEvalString(ep,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b6d2e26c279ac87cc4188554c44d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c181fc8bdab12c5b1614721ecf49037a/" rel="bookmark">
			matlab练习程序（摄像头获取数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上好多文章都好坑爹，配置麻烦死了，一点也不简洁，我这里给一个最简洁并且很好用的版本。
clear all; close all; clc; obj=videoinput('winvideo',1,'YUY2_320x240'); %一般的家用摄像头第三个参数这样就可以，不能运行直接去掉第三个参数也可以 h1=preview(obj); %预览视频，同时获取句柄 h2=figure(2); %新建显示图像figure,同时获取句柄 while ishandle(h1) &amp;&amp; ishandle(h2) %两个句柄有一个关闭就结束程序 frame=getsnapshot(obj); %捕获图像 frame=ycbcr2rgb(frame); %转成彩色,这个frame就可以按照自己意愿处理了 imshow(frame); %显示图像 drawnow; % 实时更新图像 end delete(obj); %删除对象 转载于:https://www.cnblogs.com/tiandsp/archive/2012/11/22/2782682.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b8adba209b86d47f772910d4075407/" rel="bookmark">
			vim一般设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果不知道配置文件及脚本的位置，可以在vim中使用命令 :scriptnames ，将显示如下路径 /etc/vimrc /usr/share/vim/vim72/syntax/syntax.vim /usr/share/vim/vim72/syntax/synload.vim /usr/share/vim/vim72/syntax/syncolor.vim /usr/share/vim/vim72/filetype.vim /usr/share/vim/vim72/ftplugin.vim /home/kdj/.vimrc ~$ cat .vimrc """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 一般设定
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 设定默认解码
set fenc=utf-8
set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936
" 不要使用vi的键盘模式，而是vim自己的
set nocompatible
" history文件中需要记录的行数
set history=100
" 在处理未保存或只读文件的时候，弹出确认
set confirm " 侦测文件类型
filetype on
" 载入文件类型插件
filetype plugin on
" 为特定文件类型载入相关缩进文件
filetype indent on
" 保存全局变量
set viminfo+=!
" 语法高亮
syntax on
" 状态行颜色
highlight StatusLine guifg=SlateBlue guibg=Yellow
highlight StatusLineNC guifg=Gray guibg=White " 在状态行上显示光标所在位置的行号和列号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b8adba209b86d47f772910d4075407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e17f9d9e21db89a1f4704033132cb4e/" rel="bookmark">
			matlab练习程序（白平衡&lt;动态阈值&gt;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clear all; close all; clc; im=imread('2.png'); im2=im; im1=rgb2ycbcr(im);%将图片的RGB值转换成YCbCr值% Lu=im1(:,:,1); Cb=im1(:,:,2); Cr=im1(:,:,3); [x y z]=size(im); tst=zeros(x,y); %计算Cb、Cr的均值Mb、Mr% Mb=mean(mean(Cb)); Mr=mean(mean(Cr)); %计算Cb、Cr的均方差% Db=sum(sum(Cb-Mb))/(x*y); Dr=sum(sum(Cr-Mr))/(x*y); %根据阀值的要求提取出near-white区域的像素点% cnt=1; for i=1:x for j=1:y b1=Cb(i,j)-(Mb+Db*sign(Mb)); b2=Cr(i,j)-(1.5*Mr+Dr*sign(Mr)); if (b1&lt;abs(1.5*Db) &amp; b2&lt;abs(1.5*Dr)) Ciny(cnt)=Lu(i,j); tst(i,j)=Lu(i,j); cnt=cnt+1; end end end cnt=cnt-1; iy=sort(Ciny,'descend');%将提取出的像素点从亮度值大的点到小的点依次排列% nn=round(cnt/10); Ciny2(1:nn)=iy(1:nn);%提取出near-white区域中10%的亮度值较大的像素点做参考白点% %提取出参考白点的RGB三信道的值% mn=min(Ciny2); for i=1:x for j=1:y if tst(i,j)&lt;mn tst(i,j)=0; else tst(i,j)=1; end end end R=im(:,:,1); G=im(:,:,2); B=im(:,:,3); R=double(R).*tst; G=double(G).*tst; B=double(B).*tst; %计算参考白点的RGB的均值% Rav=mean(mean(R)); Gav=mean(mean(G)); Bav=mean(mean(B)); Ymax=double(max(max(Lu)))/15;%计算出图片的亮度的最大值% %计算出RGB三信道的增益% Rgain=Ymax/Rav; Ggain=Ymax/Gav; Bgain=Ymax/Bav; %通过增益调整图片的RGB三信道% im(:,:,1)=im(:,:,1)*Rgain; im(:,:,2)=im(:,:,2)*Ggain; im(:,:,3)=im(:,:,3)*Bgain; %显示图片% figure,imshow(im2,[]),title('原图'); figure,imshow(im,[]),title('白平衡后的效果图'); 别人的程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e17f9d9e21db89a1f4704033132cb4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f3978f1f6003218f41a6633c28736e4/" rel="bookmark">
			matlab练习程序（线性分类器&lt;伪逆法&gt;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clear all; close all; clc; num=7; X=[ 1 0.4 0.05; 1 -0.2 0.75; 1 0.5 0.1; 1 -0.1 0.7; 1 0.3 0.2; 1 -0.15 0.9; 1 0.5 0.2]; d=[1 -1 1 -1 1 -1 1]; %同一类的的数据正负号相同 for i=1:num plot(X(i,2),X(i,3),'ro'); hold on; end axis([-0.5 0.5 0 1]); Y=X'*X; inv_Y=inv(Y); w=inv_Y*X'*d'; x=-0.5:0.1:0.5; y=(-w(1)-w(2)*x)/w(3); plot(x,y); 参考：
1.http://read.pudn.com/downloads102/ebook/420359/chapter%203/3.doc
转载于:https://www.cnblogs.com/tiandsp/archive/2012/05/04/2482936.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4784ea37590d3fdd45c57a667cefc992/" rel="bookmark">
			matlab练习程序（PCA&lt;SVD&gt;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clear all; close all; clc; img1=imread('Corner.png'); img2=imread('Corner1.png'); img3=imread('Corner2.png'); img1=imresize(img1,[35 90]); %Matlab的svd不支持太大的数据，我把数据变小了. img2=imresize(img2,[35 90]); img3=imresize(img3,[35 90]); [height width]=size(img2); a=reshape(double(img1),1,35*90); b=reshape(double(img2),1,35*90); c=reshape(double(img3),1,35*90); ma=mean(a); mb=mean(b); mc=mean(c); a=a-ma; b=b-mb; c=c-mc; x=[a' b' c']; x=double(x); %y=x'*x/(height*width); %[v d]=eig(y); [u s w]=svd(x); %w相当于排序后的d,用svd就不用求x'*x了 ed=x*w;%v; img4=zeros(height,width); img4=reshape(ed(:,1),height,width); img5=zeros(height,width); img5=reshape(ed(:,2),height,width); img6=zeros(height,width); img6=reshape(ed(:,3),height,width); imshow(mat2gray(img4)); figure,imshow(mat2gray(img5)); figure,imshow(mat2gray(img6)); 参考：
1.http://iiec.cqu.edu.cn/wiki/index.php/SVD%E4%B8%8EPCA%E7%9A%84%E7%93%9C%E8%91%9B
转载于:https://www.cnblogs.com/tiandsp/archive/2012/05/02/2478991.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a09f95ba320d38bf47e9dff60b8d15/" rel="bookmark">
			最小二乘直线拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt;
using namespace std;
int nihe(double *x,double *y,int N)
{
double a0=0;
double a1=0;
double sum_x_square=0;
double sum_x=0;
double sum_y=0;
double sum_x_y=0;
double x_sum_square=0;
for (int i=0;i&lt;N;i++)
{
sum_x_square+=x[i]*x[i];
sum_y+=y[i];
sum_x+=x[i];
sum_x_y+=x[i]*y[i];
}
x_sum_square=sum_x*sum_x;
a0=((sum_x_square*sum_y)-(sum_x*sum_x_y))/(N*sum_x_square-x_sum_square);
a1=((N*sum_x_y)-(sum_x*sum_y))/(N*sum_x_square-x_sum_square);
cout&lt;&lt;a0&lt;&lt;endl;
cout&lt;&lt;a1&lt;&lt;endl;
return 0;
}
int main()
{
double x[]={1,2,3,4,5};
double y[]={1,3,3,5,5};
int s;
s=nihe(x,y,5);
system("pause");
return 0;
} 转载于:https://www.cnblogs.com/tiandsp/archive/2012/03/21/2409962.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f01f2a908485c381ca61ae81d08db6/" rel="bookmark">
			随机化快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
using namespace std;
int random(int a,int b)
{
srand(NULL);
return rand()%(b-a)+a;
}
void exchange(int &amp;a,int &amp;b)
{
int temp;
temp=a;
a=b;
b=temp;
}
int partition(int *a,int p,int r)
{
int x=a[r];
int i=p-1;
for (int j=p;j&lt;r;j++)
{
if (a[j]&lt;=x)
{
i=i+1;
exchange(a[i],a[j]);
}
}
exchange(a[i+1],a[r]);
return i+1;
}
int randomized_partition(int *a,int p,int r)
{
int i=random(p,r);
exchange(a[r],a[i]);
return partition(a,p,r);
}
void randomized_quicksort(int *a,int p,int r)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24f01f2a908485c381ca61ae81d08db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd107a9380bee4ec6abeecd220deca4f/" rel="bookmark">
			matlab练习程序（图像加噪，各种滤波）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cl;
img=imread('3.17.tif');
imgn=imnoise(img,'salt &amp; pepper',0.02);
[m n]=size(img);
%h=fspecial('average',[3 3]); % 3*3的均值滤波
%imgn1=imfilter(imgn,h,'replicate');
%imgn=medfilt2(imgn,[3 3]); % 3*3的中值滤波
%%%%自己编写3*3均值滤波
%{
tem=0;
for i=2:1:m-1
for j=2:1:n-1 for p=i-1:1:i+1
for q=j-1:1:j+1
tem=tem+double(imgn(p,q));
end
end
tem=tem/9;
imgn(i,j)=tem;
tem=0;
end
end
%}
%%%%自己编写3*3中值滤波
%{
s=zeros(1,9);
for i=2:1:m-1
for j=2:1:n-1 he=1;
for p=i-1:1:i+1
for q=j-1:1:j+1 s(he)=imgn(p,q);
he=he+1; end
end
s=sort(s);
imgn(i,j)=s(5);
end
end
%}
imshow(imgn) 转载于:https://www.cnblogs.com/tiandsp/archive/2012/01/07/2316098.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88699b4d1dcb668199843831c61a8979/" rel="bookmark">
			回调函数c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
typedef void (* FP)(unsigned int a,unsigned int b);
//void DataDeal(FP PCB);
//void PointerReceive(unsigned int a,unsigned int b);
//void Pointer(unsigned int a,unsigned int b);
////
void Pointer(unsigned int a,unsigned int b)
{
a = (a&gt;b)?a : b;
printf("THE BIG ONE IS = %d",a);
}
void PointerReceive(unsigned int a,unsigned int b)
{
Pointer(a,b);
}
void DataDeal(FP PCB)
{
unsigned int m,n;
m = 5;
n = 8;
PCB(m,n);
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88699b4d1dcb668199843831c61a8979/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be6ae047f6af6e147889508f7723f6f/" rel="bookmark">
			matlab练习程序（生成加密p文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实就生成加密文件这种事情是有违自己的人生哲学的，不过作为一个技巧倒也无所谓了，反正我自己是不会对代码加密什么的（半年前做kinect项目的时候，我就很不情愿的把代码加密了）。
代码就下面一句话：
pcode yourfile.m
生成的 yourfile.p就是你的加密文件，别人是看不到代码的，调用和m文件调用一样。
转载于:https://www.cnblogs.com/tiandsp/archive/2012/11/13/2768662.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47eddcec3664a9e72508646b165a09d1/" rel="bookmark">
			MATLAB中的rand()和randn()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Matlab中，rand是0-1的均匀随机分布，而randn是均值为0方差为1的正态分布。
1.rand()是0-1的均匀随机分布 介绍 例子 举个例子：X = rand 产生一个在（0，1）区间内的随机数。
X = rand(n)或X = randn(n)产生一个n*n的随机变量矩阵。
X = rand(m,n)或X = randn(m,n)产生一个m*n的随机变量矩阵。
2.randn()是均值为0方差为1的标准正态分布 介绍 例子 3.正态分布（Normal Distribution） 正态分布（Normal distribution），也称“常态分布”，又名高斯分布（Gaussian distribution），最早由A.棣莫弗在求二项分布的渐近公式中得到。C.F.高斯在研究测量误差时从另一个角度导出了它。P.S.拉普拉斯和高斯研究了它的性质。是一个在数学、物理及工程等领域都非常重要的概率分布，在统计学的许多方面有着重大的影响力。
正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线。
若随机变量X服从一个数学期望为μ、方差为σ^2的正态分布，记为N(μ，σ^2)。其概率密度函数为正态分布的期望值μ决定了其位置，其标准差σ决定了分布的幅度。当μ = 0,σ = 1时的正态分布是标准正态分布。
3.1 正态分布标准化变换 3.2 正态分布公式 3.3 正态分布性质 3.4 正态分布的应用 1.频数分布以及概率估计。2.制定参考值范围，包括正态分布法和百分位数法。3.质量控制，SPC技术应用的核心。4.正态分布是检验、方差分析、相关和回归分析等多种统计方法的理论基础。 3.5 中心极限定理（Central Limit Theorem） 中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，对这n个抽样取平均值，总共抽取关计算 m 次。 则这m个平均值数据分布接近正态分布。正态分布的直观理解请参考正态分布初步理解。
4.正态分布MATLAB画法 首先给出正态分布概率密度函数（The normal distribution probability density function）的公式和标准正态分布概率密度函数的公式，然后通过normpdf( )生成标准正态分布概率密度函数的数据，然后通过plot( )绘制标准正态分布概率密度函数的图形。
4.1 正态分布概率密度函数的公式如下图。其中，μ为平均值（mean），σ为标准差（standard deviation）。 4.2 当μ=0，σ=1时，第一步中的正态分布为标准正态概率密度函数，如下图。 4.3 启动MATLAB，新建脚本（Ctrl+N），输入如下代码： 其中normpdf(x,0,1)是用来产生μ=0，σ=1的标准正态分布概率密度函数的数据。
close all; clear all; clc x=-1:.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47eddcec3664a9e72508646b165a09d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63661af1970cc4a8f372038508612302/" rel="bookmark">
			MATLAB中的乘除法 “ * ” 和 “ .* ”  and  “ / ” 和 “ ./ ”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、* 和 .* 的区别
（1）* 就是通常我们在线性代数中使用的矩阵乘法的符号，设A是m*n矩阵，B是n*t矩阵，则A*B是m*t矩阵（A*B只要求A的列数=B的行数）。
举例：
则：
（2）.* 和平时所使用的* 是不同的，.* 只能应用在同型的矩阵中，若A是m*n矩阵，则B也必须是m*n矩阵，A.* B的(i，j)个值是A的(i，j)的值*B的(i，j)的值。
举例：
则：
2、/ 和./的区别
（1）A/B和线性代数中A*B逆是一样的。但是要求A与B是同型矩阵。
举例：
则：
（2）./是与.*相逆的运算，./的矩阵A和B也要求是同型矩阵。
举例：
则：
3、 ".\"的x = B.\A解释如下
x=b.\a ：将a的每个元素除以b的相应元素。
如果A和B是数组，那么它们的大小必须相同；如果a或b是一个标量，那么matlab会将该标量值扩展到适当大小的数组中。
x=ldivide（b，a）是将a除以b的另一种方法，但很少使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/600d1d5886508dc4ddd0eefb4f242208/" rel="bookmark">
			代码提交到Github的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们平时做的一些东西，开发的一些东西想放到网上去提供给别人查看，下载，放到github上是比较好的选择,你也可以去github上去查看别人分享的源代码
以前上传的时候经常出错，在这里我总结了几种把代码上传到github上去的方法，希望可以帮助大家
准备工作 首先你得有一个github的账号，没有的话去注册一个吧 github官网如果没下安装git那是不行的，下载一个git git官网最好能熟悉一下git的相关命令 推荐廖雪峰讲的git 代码上传到github步骤(方法一) 首先打开github官网，登录到github点击 your repositories，创建一个新的工写好项目名称这时候一个项目就创建好了(这里只是一个空的工程)增加README.md 文件，有时候没有这个文件，工程是提交不了代码的然后使用git clone命令把你自己的工程路径复制，然后在你本地想要放的目录执行，然后项目就可以下载到你的本地在这里进行一些修改，然后提交(修改前的图片)提交的时候，如果是没有设置git 的全局用户名和邮箱，那里会提示你设置然后把代码提交，这时会提示你输入github账号名和密码，输入成功，代码提交成功
新增的test.txt和main文件夹提交成功 代码上传到github步骤(方法二) echo "# CommandProject" &gt;&gt; README.md git init git add README.md git commit -m "first commit" git remote add origin https://github.com/xusong0621/CommandProject.git git push -u origin master 首先在本地创建一个文件夹，进入这个文件夹使用 git init 初始化这个文件夹，成功后就会多一个.git的文件夹。增加README.md文件，git add README.md把新建的文件本地提交 git commit -m “first commit”然后在github新建一个工程，可以参考 方法一的步骤 2和3工程创建之后，复制工程的地址 执行命令 git remote add origin https://github.com/xusong0621/CommandProject.git，你自己创建的工程，使用自己的地址然后新增工程的相关文件信息提交 代码上传到github步骤(方法三) github有桌面版本，这个是下载地址github desktop,这个是傻瓜式的
如果有兴趣可以去查看它的使用github desktop使用
gitthub使用总结 这里有三种方法都是可行的，个人强制推荐前二种方法，因为现在大多数的公司使用的同步工具都是
git, 做复杂一点的合并，打分支，打tag,等等都是用命令行工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/600d1d5886508dc4ddd0eefb4f242208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c902ff6f884e2f7f3c9502d8309a03b7/" rel="bookmark">
			最全Pycharm教程（43）——Pycharm扩展功能之UML类图使用 代码结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，转载时麻烦注明源文章链接，谢谢合作 https://blog.csdn.net/u013088062/article/details/50353202
1、什么是UML
UML类图能够快速检查代码结构。
2、主题
UML类图在Pycharm中的用法。
3、准备工作
（1）Pycharm版本为2.7或更高
（2）安装Python解释器
（3）UML插件以及UML类图插件安装并能正常使用
4、准备一个例子
创建一个Animals模块以及 Mammal.py文件（Alt+Insert→Python Package, Python File），输入以下代码：
继续向其中添加更多类，例如Carnivore和Herbivore。
5、通过UML类图浏览程序结构
假设我们想查看mammals的派生结构，在Project tool window窗口中，右击Mammal.py，指向快捷菜单中的 Diagrams节点，选择如下可用命令：
（1）Show Diagram：在当前编辑选项卡内打开UML类图
（2）Show Diagram Popup：在单独窗口中显示UML类图
选择mammals中的一个类（例如marsupials），用UML类图查看它：
也可以使用快捷键Ctrl+Alt+U（当前窗口）或Ctrl+Alt+Shift+ U（独立窗口）。
单击和按钮查看详细信息：
也可以使用快捷菜单：
更多工具栏及快捷菜单的功能参见Class Diagram Toolbar and Context Menu页。
接下来向其中加入注释。选择想要注释的元素，按下Alt+Insert：
回车，输入注释内容：
单击OK，注释添加完毕：
6、结构图与源码间导航
如何从结构图跳转到响应的源码位置？
在结构图中选择一个节点元素，按下F4或者右键快捷菜单选择Jump to Source命令：
7、UML结构图作用
8、查找所有引用
在结构图中选择一个节点元素，右击，在快捷菜单中选择Find Usages，或者使用Alt+F7快捷键：
9、重构
可以直接在类图中对类或者成员就行重构（重命名等）。
在类图中右击待修改的节点，指向Refactor命令，在子菜单中选择对应命令。
例如你希望对一个类进行重命名，需要在类图中选中它，然后选择Refactor→Rename快捷菜单命令或者按下Shift+F6：
10、向模型中添加元素
按下Space，在弹出的窗口中输入类型和名称：
添加Carnivore：
接下来手动创建更多类，如 Carnivore或Herbivore，指定mammal类型。例如Cow继承了Herbivore 和Eutherian。Tiger继承了Carnovire 和Eutherian。 Duckbill 继承了Herbivore 和Marsupial，TasmanianDevil继承了Carnivore 和Marsupial：
按下Space，将这些类加入类图：
单击按钮，优化显示风格：
11、从类图中移除元素
在类图中选中一个元素，Delete：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c902ff6f884e2f7f3c9502d8309a03b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f25fa456a4dd0635966c67fa8756f900/" rel="bookmark">
			约束与索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非空约束 Not Null create table emp (emp_id nvarchar(9) not null, emp_name nvarchar(50) not null, ) 当一列被创建时，可以使用not null约束，空值null 等于没有或未知道，该表的两个列不允许插入null或者不设置值。 主键约束 primary key 用于标识表中一行数据是唯一的，主键通常由一列组成，但也可以多列共同组成主键。主键是一个隐性约束 create table emp (emp_id nvarchar(9) not null primary key, emp_name nvarchar(50) not null, ) alter table emp add constraint emp_name_pk primary key(emp_name) 改变一个表的约束 唯一约束 UNIQUE 是指约束在指定列上的值必须唯一，它和主键约束类似，当在一个表上的一列放置主键约束时，可以在另一列上放置唯一约束。主键比约束唯一多了数据提供顺序和在查询中用于连接表之外，主键约束和唯一约束没有太大区别。 create table emp (emp_id nvarchar(9) not null primary key , emp_name nvarchar(50) not null unique,) 外键约束 foreign key (父子表) create table emp_pay (emp_id nvarchar(9) not null, posititon varchar(15) not null, pay_rate nvarchar(50) not null, ) go alter table emp_pay add constraint emp_id_fk foreign key(emp_id) references emp(emp_id); go 校验约束 用来检查输入到表中某一特定列的数据的有效性，一般应用程序在前台也要校验数据是否有效，数据库的校验提供了另一种实现数据的保护方式。 ADD CONSTRAINT CK_stuAge CHECK(stuAge BETWEEN 15 AND 40) add constraint chk_emp_zip check ( emp_zip = '050021') add constraint chk_emp_zip check ( emp_zip in ( '050021','050000',021111')) add constraint chk_emp_pay check (pay_rate &gt; 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f25fa456a4dd0635966c67fa8756f900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856b3d36692d0dc4b80c6a450fa963d8/" rel="bookmark">
			ASP.NET几种传值方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、QueryString
特点：值参数显示在地址栏中。
适用于安全性不高和简单的数值，但是长度有限。
例如：
传值方式：Response.Redirect("../Login.aspx?UserName=" + this.txt_UserName.Text.Trim());
取值方式：Request.QueryString["UserName"]
2、Session
特点：存放在服务器端，占用服务器资源。
传值方式：Session["UserName"] = this.txt_UserName.Text.Trim();
取值方式：this.txt_UserName.Text = Session["UserName"] != null ? Session["UserName"].ToString() :"";
3、Cookie
特点：存放在客户端，不占服务器资源，需要配合Request使用。
传值方式：
HttpCookie _cookie = new HttpCookie("UserName");
_cookie.Value = "Tim";
Response.AppendCookie(_cookie);
Server.Transfer("../Login.aspx");
取值方式：
string userName = Request.Cookies["UserName"]!=null?Request.Cookies["UserName"].ToString():"";
4、Application
特点：全局变量，使用时配合Lock和Unlock方法。
传值方式：Application["username"] = "Tim";
取值方式：Application.Lock();string username = Application["username"].ToString();Application.UnLock();
5、Server.Transfer
特点：将当前页面引导到另一个页面，新的页面使用前页面的应答流。
传值方式：
Server.Transfer("Login.aspx");
取值方式：
方法1、TextBox txt = (TextBox)PreviousPage.FindControl("TextBox1");
方法2、当前页面public string username{return this.textbox1.text;};
另一个页面头部引用&lt;%@ Reference Page="~/Login.aspx" %&gt;
页面内
Login webForm = Context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856b3d36692d0dc4b80c6a450fa963d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1ed7aadf30ba7bfa4f6fc153175b86/" rel="bookmark">
			获取不到Gist id？解决gist.github.com无法访问的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		办法超简单，如下图：
在编辑器打开HOSTS文件，在最后一行添加192.30.253.118 gist.github.com，如下图：
HOSTS文件的作用？
Hosts是将一些常用的网址域名与其对应的IP地址建立关联的”数据库”——用户在浏览器输入网址时，系统优先从Hosts文件中寻找对应的IP地址，找到后自动打开对应网页；若没有找到，则再将网址提交DNS域名解析服务器进行IP地址的解析。（更多关于HOSTS文件的详细说明可自行百科） *欢迎关注前端小讴的github，阅读更多原创技术文章
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/254/">«</a>
	<span class="pagination__item pagination__item--current">255/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/256/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>