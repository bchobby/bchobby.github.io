<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0877821ef0bd0cc9976ec21304cf9c4e/" rel="bookmark">
			js的精确计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//加法函数，用来得到精确的加法结果 //javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 function accAdd(arg1,arg2){ var r1,r2,m; try{r1=arg1.toString().split(".")[1].length}catch(e){r1=0} try{r2=arg2.toString().split(".")[1].length}catch(e){r2=0} m=Math.pow(10,Math.max(r1,r2)); return (accMul(arg1,m)+accMul(arg2,m))/m; } //javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 function accMul(arg1,arg2){ var m=0,s1=arg1.toString(),s2=arg2.toString(); try{m+=s1.split(".")[1].length}catch(e){} try{m+=s2.split(".")[1].length}catch(e){} return Number(s1.replace(".",""))*Number(s2.replace(".",""))/Math.pow(10,m) } (function () { var calc = { /* 函数，加法函数，用来得到精确的加法结果 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 参数：arg1：第一个加数；arg2第二个加数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数） 调用：Calc.Add(arg1,arg2,d) 返回值：两数相加的结果 */ Add: function (arg1, arg2) { arg1 = arg1.toString(), arg2 = arg2.toString(); var arg1Arr = arg1.split("."), arg2Arr = arg2.split("."), d1 = arg1Arr.length == 2 ? arg1Arr[1] : "", d2 = arg2Arr.length == 2 ? arg2Arr[1] : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0877821ef0bd0cc9976ec21304cf9c4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b85cd5595a7093868b4daa7dd66e1c8/" rel="bookmark">
			关于css盒子模型和BFC的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS盒子模型
包含元素内容（content）、内边距（padding）、边框（border）、外边距（margin）
一般元素总宽度 = element的width+padding的左右边距+margin左右边距值+border的左右宽度
高度同理
外边距合并
上下外边距会合并一般发生在普通文档流中，行内框，浮动框或绝对定位之间外边距不会合并
一般合并的外边距会取那个较大的值
Box-sizing属性（content-box|border-box|inherit）
Content-box: 总宽度 = margin+border+padding+width
Border-box:总宽度 = width+margin 其中盒子的width包含padding+border+element
inherit:规定从父元素继承box-sizing的属性值
实践中的问题
Margin越界（第一个子元素的margin-top和最后一个子元素的margin-bottom） -&gt;父元素没边框，设置第一个子元素的margin-top的值会加在父元素上，解决方法如下： 给父元素加边框给父元素设置padding父元素添加overflow：hidden父元素加前置内容生成（推荐） 例子：.parent{
Width:500px;
Height:500px;
Background:red
}
.parent : before{
Content:””;
Display:table
}
.child{
Width:200px;
Height:200px;
Background:green;
Margin-top:50px
}
&lt;div class=“parent”&gt;
&lt;div class=“child”&gt;
&lt;/div&gt;
&lt;/div&gt;
浏览器间的盒子模型
ul在MOzillz中默认有padding值，而在IE中只有margin值标准盒子模型与IE盒子模型之间差异，IE更像box-sizing：border-box，解决方法就是在HTML模板加上doctype 盒子模型画三角形
.triangle{
Width:0;
Height:0;
Border:20px solid transparent;
Border-top:20px solid red;
}//向下的箭头
BFC理解（块级格式化上下文，独立的渲染区域，规定了内部的BFC如何布局，并与这个区域的外部互不相干）
BOX、Formatting Context的缩写
Box：CSS布局的基本单位
box常用盒子：(根据display的你属性区分盒子) -&gt; block-level box:display属性为 block,list-item,tabel的元 素，并且参与BFC；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b85cd5595a7093868b4daa7dd66e1c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ebcb0903539fb456906175be1436c5/" rel="bookmark">
			交通事故致因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、挖掘背景 随着时代的发展，我们的出行变的越来越便利的同时，也带来的越发严重的交通安全事故。我国的经济高速发展，全国汽车保有量，交通道路，人口等都在不断的增加，同时道路交通安全事故也进入高发期。分析事故发生的原因，找到事故发生的内在规律，对交通部门进行道路交通的改进和提高民众的出行安全具有重大意义。
本次提供了交通事故相关的多维度数据，通过对事故类型、事故人员、事故车辆、事故天气、驾照信息、驾驶人员犯罪记录数据以及其他和交通事故有关的数据进行深度挖掘，从中找到交通事故致因，分析事故发生的规律，形成交通事故成因分析的方案。
2、数据需求 现有的数据包括：交通事故的数据，包含事故时间、事故地点、发生者车辆类型、颜色、驾校和出生日期等字段。交通违法数据，包含驾驶证号、违法编号、违法类型、违法内容等字段。天气数据，包含了5月1日至12月8日的天气情况，有日期、天气、气温、风力风向等字段。
在现有的数据中，各个数据的形式不一，难以对其直接进行分析，故进行数据的合并。将事故数据、天气及违法数据整合为一个表，变成方便进行分析的数据格式。
3、数据探索及预处理 一、数据格式
通过探索发现，事故的数据格式是包含两个事故发生者各自的信息，需要对其进行处理，数据只包含事故肇事者的信息类型，即剔除事故责任为不负责任的类型。
二、日期格式处理
（1）事故数据的事故发生时间为日期和时间格式，而天气数据的时间格式为日期，故对事故的时间处理为，单独划分日期和事故发生时间点，即某个小时；
（2）初次发证时间也为日期和时间格式，考虑到后续的分析，只需对其转成日期格式即可。数据中存在“-1”，“0001-01-01 00:00:00”这些无效数据，先将其修改为NA，然后计算驾龄。
（3）年龄数据，现按最高驾龄为75岁计算，即保留75以下的数据，其余的赋值为NA，计算出年龄保存。
（4）气温数据是“15℃ / 9℃ ”，“12℃ / 6℃”格式，现计算其均值作为后续分析的数据。
（5）天气数据是“多云 /阴”，“多云 /阵雨”的格式，现将含有小雨中雨的字段定义为“中雨及以下”，含大雨暴雨阵雨字段定义为“大雨及以上”，含有冻雨和雪的字段定义为“下雪”，含有多云阴晴字段的定义为“晴”，方便后续的分析。
4、交通事故分析及可视化 一、肇事者性别分析
对于交通事故，“女司机”、“马路杀手”、“所到之处寸草不生”等词语都是用来形容女性司机的。原因是人们一直认为女性司机最容易引发交通安全事故，然而事实是什么呢？通过下图，我们发现男性肇事者在交通事故中的比例远比女性要大，而且差距很大。但是这种差距是可以解释的，因为男性司机的比例是高于女性司机的。
二、男性女性事故类型分析 对事故发生的类型进行分析，可以发现，事故发生的类型主要是7和1，即未按规定让行和追尾，且男性和女性女性司机在事故类型上没有多大区别。所以，认为女性司机是“马路杀手”这个说法其实是不合理的。对于这种现象，应该提高民众的出行文明，遵守交通规则主动让行。
三、事故发生的年龄分析
对肇事者的年龄分析，从成年开始，随着年龄的增大，出于对自己车技的肯定，越容易发生事故，40岁左右达到高峰，30至40岁之间是事故高发的年龄段，40岁之后因为比较成熟，事故发生的情况逐渐减少。
四、事故发生的驾龄分析
从驾龄上分析，刚拿到驾驶执照的前面6年，事故发生的人数上升；经过3-6年的平缓期，10年以上驾龄的司机事故发生的概率又会上升；跟年龄相对应，20年以上的驾龄司机出事故的概率会减小，也就是我们常说的老司机。因为老司机的技术比较娴熟，开车经验丰富，可以避免许多事故。
五、事故发生的时间点分析
通过对事故发生的时间点分析，可以看出，事故的发生主要集中在上下班高峰，即上午8点下午18点左右的时间点，8-18点由于是工作时间，相比其他时间的人流量车流量增多，也是事故多发的。我们还可以看到，1月份2月份的事故发生较少，因为1-2月是春节假期，司机驾驶更加谨慎或者由于城市车流量减少，事故的发生大大减少，这是符合事实的。
六、肇事车辆类型分析
考虑车辆的类型。通过对肇事者车辆类型的频数统计及画词云，可以知道，长安、五菱这些货车类型发生交通事故的概率比较高，可能跟货车运货的情况或者这类车型存在比较大的安全隐患有关。
七、事故驾校分析
然而，再好的司机也是从驾校出来的，我们假设驾校的好坏会影响驾驶者的驾驶水平。对肇事者的驾校进行分析，发现通过自培拿到驾照的司机发生事故的人数很多，所以，生命无价，选择正规的驾校培训很重要。当然，要规避十一培这种学生出事故较多的驾校。
八、事故天气分析
从天气的分析中，得到2个结论：
（1）、该城市经常下雨，日常下雨天气占60%左右；
（2）、该城市64%的交通事故发生在雨天。
5、肇事者特征提取 我们希望通过对事故责任人的属性进行分析，总结出发生不同事故类型的特征人群。通过kmeans聚类的方法，对事故责任人的年龄、驾龄、违法次数进行聚类，初步分析导致事故发生的分类结果。
类
age
year
freq
1
-0.773427819
-0.672224362
-0.368067664
2
0.675471089
0.725751781
1.583014712
3
0.669054199
0.483409404
-0.574087967
第1类，年龄较小，驾龄低，违法次数也少，定义为安全驾驶人群 ；第2类年龄稍大，驾龄也稍高，违法次数很多，定义为高危驾驶人群；第3类年龄大驾龄高违法次数较少，定义为潜在威胁驾驶人群。
但是我们发现效果并不是很好，故试着选取其他属性进行聚类分析。
思考：
在这个数据中，运用聚类方法怎样识别碰瓷、骗保（违规次数，扣分、事故责任人次数，事故次数）。
文章未经博主同意，禁止转载！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f269a8ebb1df96eca23aaefc4d1c597/" rel="bookmark">
			LaTex学习笔记（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
至此我们已经基本学习了如何排版文档中的标题、章节等待，今天我们接着上一篇博客继续学习LaTex的使用。这篇博客主要学习排版样式的设定，比如字体、字号、分栏已经参考文献。
一、设置页面参数
在默认的页面参数下，文档的pdf效果如下：
geometry 宏包提供了设置页面参数的简便方法，在 pdflatex 和 xelatex 编译命令下，我们既可以调用 geometry 宏包然后用其提供的 \geometry 命令设置页面参数，也可以将参数指定为宏包的选项。
比如，符合 Microsoft Word 习惯的页面设定是 A4 纸张，上下边距1英寸（2.54cm），左右边距 1.25英寸，于是我们可以通过如下两种等效的方式之一设定页边距：
\documentclass{ctexart} \usepackage[left=1.25in,right=1.25in, top=1in,bottom=1in]{geometry} % 设置页面参数的第一种方法 %\usepackage{geometry} % 等效的设置页面参数的第二种方法 %\geometry{left=1.25in,right=1.25in, top=1in,bottom=1in} \title{LaTeX入门} \author{小明\thanks{第一作者} \and 小红\thanks{第二作者} \and 隔壁老王\thanks{通讯作者}} \date{2018年7月7日} \begin{document} \maketitle \section*{第一章 LaTex介绍} LATEX是一个文档准备系统 (Document Preparing System)，它非常适用于生成高印刷质量的科技类和数学类文档。 \subsection*{1.1 概述} TEX是高德纳 (Donald E.Knuth) 开发的、以排版文字和数学公式为目的的一个计算机软件。 高德纳从1977年开始开发TEX，以发掘当时开始用于出版工业的数字印刷设备的潜力。 \par 在开始示例编译过程之前，有必要澄清几个概念：\par 引擎：全称为排版引擎，是读入源代码并编译生成文档的程序。\par 格式：是定义了一组命令的代码集。 \subsubsection*{1.1.1 LaTex的优缺点} 专业的排版输出，产生的文档看上去就像“印刷品”一样。\par 方便而强大的数学公式排版能力，无出其右。\par 绝大多数时候，用户只需专注于一些组织文档结构的基础命令，无需（或很少）操心文档的版面设计。\par 很容易生成复杂的专业排版元素，如脚注、交叉引用、参考文献、目录等。 \subsection*{1.2 安装} 在ctex.org下载ctex套装(203Mb或1.3Gb)（含MikTeX及WinEdt）。 \subsection*{1.3 概述} TEX是高德纳 (Donald E.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f269a8ebb1df96eca23aaefc4d1c597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6055491e81e1b473523eb02173e885/" rel="bookmark">
			WebGL学习笔记（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据上篇笔记，在对3D对象可进行普通的控制后，以及学习了http://hiwebgl.com的教程第10章内容：世界模型的载入以及控制镜头移动，经过多次调试矩阵代码，已经可以实现在世界中旋转镜头/控制移动，并添加3D对象在世界模型中进行相对移动
测试代码如下，拷贝到您的浏览器打开，方向键控制镜头旋转与移动
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
* {margin:0;padding:0;overflow:hidden;}
&lt;/style&gt;
&lt;script id="vertex-shader" type="x-shader/x-vertex"&gt;
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;
uniform mat4 uPMatrix;
uniform mat4 uTranslateMatrix;
uniform mat4 uScaleMatrix;
uniform mat4 uRotateYMatrix;
uniform mat4 uRotateXMatrix;
uniform mat4 uRotateZMatrix;
varying vec2 vTextureCoord;
void main(void){
gl_Position = uPMatrix * uRotateZMatrix * uRotateYMatrix * uRotateXMatrix *uTranslateMatrix * uScaleMatrix * vec4(aVertexPosition, 1.0);
vTextureCoord = aTextureCoord;
}
&lt;/script&gt;
&lt;script id="fragment-shader" type="x-shader/x-fragment"&gt;
precision mediump float;
varying vec2 vTextureCoord;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba6055491e81e1b473523eb02173e885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60379e4f2238b1b276ed531948848c4c/" rel="bookmark">
			Es6中的模块化Module,导入(import)导出(export)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽互不曾谋面,但希望能和你成为笔尖下的朋友
以读书,技术,生活为主,偶尔撒点鸡汤
不作,不敷衍,意在真诚吐露,用心分享
点击左上方,可关注本刊
前言 在Es6之前,javascript没有模块系统,它无法将一个大程序拆分成若干个互相依赖的小文件,然后在用简单的方法拼装起来.为了做到模块化,在Es6之前,引入了AMD(Asynchronous module definition)与CMD(common module definition)
前者典型代表是requireJS(外国人搞出来的),后者是seajs(国内) 共同点:都是对模块定义的不同规范,都是异步加载模块,并且解决文件之间的依赖重命名冲突等问题。 不同点:模块定义的方式和模块加载机制是不同的,前者AMD(requirejs)是将所有文件同时加载,一次性引入,推崇依赖前置,也就是在定义模块时要先声明其依赖的模块,加载完模块后会立马执行该模块(运行时加载)
而CMD(seajs)强调的是一个文件一个模块,可按需引入,推崇依赖就近,加载完某个模块后不会立即执行,而是等遇到了require语句的时候在执行 .
两者的使用加载机制不同,也就导致了AMD(requirejs)模块会提前执行,用户体验好,而CMD(seajs)性能好,因为只有在需要时候才执行,在服务器端,nodejs使用的就是cmd规范,也就是需要什么包,就引入什么包,按需加入(编译时加载)
而在Es6的语言规格中引入了模块化功能,也就很好的取代了之前的commonjs和AMD规范了,成为了浏览器和服务器的通用的模块解决方案,在现今(vuejs,ReactJS)等框架大行其道中,都引入了Es6中的模块化(Module)机制,一些自动化打包工具webpack或者微信小游戏中也同样如此
您将在本文中学习到什么是模块,以及模块的导入导出,理解了这个,在一些基于脚手架搭建的项目里或者自动化构建工具中,就不觉得写法怪怪和迷路了的
正文从这里开始~
什么是模块？ 在Es6中引入let,const定义变量是解决访问变量的全局作用域问题,从而引入块级作用域,解决命名冲突,同名全局污染,安全等问题
模块可以理解为函数代码块的功能,是封装对象的属性和方法的javascript代码,它可以是某单个文件,变量或者函数,
在Es6模块中,无论有没有加"use strict",都会自动采用严格模式,而且在模块顶部创建的变量不会自动被添加全局作用域中,这个变量仅在模块的顶级作用域中存在,而且模块必须导出一些外部代码可以访问的元素,如变量或者函数,模块也可以从其他模块导入绑定
在模块与模块之间的特性与作用域关系不大(例如微信小程序或者小游戏中的各个文件就是不同的模块,在该文件定义的变量或者函数只在该文件内作用),但也很重要,在模块的顶部,this的值是undefined,另外,模块不支持HTML风格的代码注释
模块实质上是对业务逻辑分离实现低耦合高内聚,也便于代码管理而不是所有功能代码堆叠在一起,模块真正的魔力所在是仅导出和导入你需要的绑定,而不是将所有的东西都放到一个文件
引入模块与引入脚本是有区别的,前者更多是按需引入加载,后者而是无论有没有用,全部一次性引入和加载,类似于通过script标签引入jQuery等库都是一次性载入
Node中模块的导出与导入 在Node模块中,采用的是commonjs规范,也就是使用require方式引入模块,而使用module.exports导出接口,在node中,例如如下代码example.js,当然你也是可以把属性值定义到外面去的,把下面这段代码存储脚本为example
/*
* 通过module.exports将数据进行对外暴露
*/
module.exports = {
name:"随笔川迹",
funA:function(){
return `我是${this.name}`
}
}
// 或者把变量函数值定义在外面，例如,与上面等价，以下是常见写法
var name = "随笔川迹";
var funA = function(){
return `我是${name}`
}
module.exports = {
name:name, // 至于前面的变量名可以任意,但是在另外一模块中引入时要与该变量名保持一致,否则就会报错，也可以只写一个name
funA:funA // 也可以只写一个funA
} 而在另外一文件命名requireExample.js中使用require方式引入
/*
*
* 通过require()的方式将外部模块引入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60379e4f2238b1b276ed531948848c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be8b17cc9a9538b7d4dc1509834c9a4e/" rel="bookmark">
			Pyinstaller打包多个.py文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、多文件打包为单一文件时，即pyinstaller 命令中加入了-F，也可能会导致错误。尽量不要使用-F。
二、尽量把打包后的文件放在英文目录下。
多个.py文件打包命令格式如下：
pyinstaller [主文件] -p [其他文件1] -p [其他文件2] --hidden-import [自建模块1] --hidden-import [自建模块2] 三、使用pyinstaller打包的时候，仅打包.py文件，其余依赖项只需在打包完成后，拷入打包生成的根目录即可。
四、举例说明：
我的文件构成 其中VIPCracker.py是主程序入口文件，其他.py文件是自建模块，需要在主文件中使用，zh_CN.qm和JygoxigmJ.db文件是程序中需要用到的额外文件(将它们放在打包后生成的.exe文件的同一个目录下即可)
以上文图中结构为例，在根目录打开命令窗口并进入根目录下，输入命令：
pyinstaller -F -i crack.ico -w VIPCracker.py -p CholenSql.py -p ImgICon.py -p VIPGUI.py --hidden-import CholenSql --hidden-import ImgICon --hidden-import VIPGUI拓展知识：pyinstaller 中的-i crack.ico 可以设置生成.exe文件的图标。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e32ac60c8db6cd420f97432b4d0ffed/" rel="bookmark">
			Tkinter学习-LabelFrame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Tkinter LabelFrame Widget
LabelFrame 组件是 Frame 组件的变体。默认情况下，LabelFrame 会在其子组件的周围绘制一个边框以及一个标题。
何时使用 LabelFrame 组件？
当你想要将一些相关的组件分为一组的时候，可以使用 LabelFrame 组件，比如一系列 Radiobutton（单选按钮）组件。
用法
为组件分组，需要先创建一个 LabelFrame，然后像往常一样将子组件添加进去。LabelFrame 组件会自动绘制一个边框将子组件包围起来，并在它们上方显示一个文本标题。
1. from tkinter import *
2. 3. master = Tk()
4. 5. group = LabelFrame(master, text="你从哪里得知鱼C？", padx=5, pady=5)
6. group.pack(padx=10, pady=10)
7. 8. v = IntVar()
9. r1 = Radiobutton(group, text="同学/同事介绍", variable=v, value=1).pack(anchor=W)
10. r2 = Radiobutton(group, text="老婆大人介绍", variable=v,value=2).pack(anchor=W)
11. r3 = Radiobutton(group, text="老师/学长介绍", variable=v, value=3).pack(anchor=W)
12. 13. mainloop()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e32ac60c8db6cd420f97432b4d0ffed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa00f203cd3c13ead38d60cb7fab98ad/" rel="bookmark">
			DES对称加密 并发引起的 java.lang.IllegalStateException: Cipher not initialized 异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目在做高并发测试的时候，出现了异常如下，由于加密解密频繁 javax. crypto.Cipher 每次都要实例化，大量的实例化导致 Cipher 实例化失败。 解决办法：将已经实例化的Cipher对象，放在hashmap中，每次实例化的时候从MAP 获取，不存在的时候再进行实例化，问题解决。 2018-07-07 10:45:39.543 DEBUG org.mybatis.spring.SqlSessionUtils - Creating a new SqlSession 2018-07-07 10:45:39.544 DEBUG org.mybatis.spring.SqlSessionUtils - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@1dce97a4] was not registered for synchronization because synchronization is not active 2018-07-07 10:45:39.544 DEBUG org.mybatis.spring.transaction.SpringManagedTransaction - JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@2e065a9e] will not be managed by Spring 2018-07-07 10:45:39.544 DEBUG com.jufengad.insurance.server.dao.InsuranceCategoryMapper.queryPageByparams - ==&gt; Preparing: SELECT id, unique_code, parent_id, parent_code, category_name, description, category_key, category_level,pic_path, status, create_time, create_person from insurance_category where 1 = 1 order by category_level asc 2018-07-07 10:45:39.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa00f203cd3c13ead38d60cb7fab98ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d36434d0f1558c9d7682ecf4f1a55b6/" rel="bookmark">
			CDN通俗原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CDN通俗原理
背景：面对高速增加的互联网带宽，人们对网络速度的要求也越来越高，从从前只需要看文字的简版QQ，到后面看图文，在到现在可以看抖音之类的短视频，带宽的增加是翻倍在增加，未来对网速的需求只增不减。
CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
原始访问模式：用户根据路由到用户服务器端，中间有经过可能复杂的路由，也可能是简单优质的路由，网络存在不稳定的因素，会导致访问质量变差
加速后，一个源站的文件，发布到各个分布式服务器上，当不同地区的用户访问的时候，就近取到文件，进行访问，减少了中间链路的冗余。
常规的加速文件有，图片以及视频类的最为多，最近比较火的主播也是加速的类型之一，可谓是赚足了眼球。
CDN，通过这种方式对互联网行业起到了推掉的作用，帮助广大的网民实现网络需求。对应的CDN服务商也是在迅猛发展，阿里云，腾讯云，网宿、蓝汛、七牛云等。都在这个行业中群雄逐鹿。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2141b87c8429d88ffdb74f85e66aa71/" rel="bookmark">
			PDF电子发票内容提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以点击这里使用发票提取软件：发票解析
请参考最新的实现方案： 浅谈电子发票识别方案
在线使用：发票提取
摘要 本文介绍如何提取PDF版电子发票的内容。
1. 加载内容 首先使用Python的pdfplumber库读入内容。
FILE=r"data/test-2.pdf" pdf=pb.open(FILE) page=pdf.pages[0] 接着读取内容并提取线段。
words=page.extract_words(x_tolerance=5) lines=page.lines # 获取线段（不包括边框线） for word in words: print(word) # 坐标换算 for index,word in enumerate(words): words[index]["y0"]=word["top"] words[index]["y1"]=word["bottom"] for index,line in enumerate(lines): lines[index]["x1"]=line["x0"]+line["width"] lines[index]["y0"]=line["top"] lines[index]["y1"]=line["bottom"] 2. 还原表格 为了将内容划分到合理的位置，需要还原出表格。
首先，把线段分类为横线和竖线，并且剔除较短的两根。
hlines=[line for line in lines if line["width"]&gt;0] # 筛选横线 hlines=sorted(hlines,key=lambda h:h["width"],reverse=True)[:-2] #剔除较短的两根 vlines=[line for line in lines if line["height"]&gt;0] #筛选竖线 vlines=sorted(vlines,key=lambda v:v["y0"]) #按照坐标排列 将线段展示出来如下图。
此时的线段是不闭合的，将缺少的线段补齐得到表格如下。
# 查找边框顶点 hx0=hlines[0]["x0"] # 左侧 hx1=hlines[0]["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2141b87c8429d88ffdb74f85e66aa71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7879bdec497aafdc84a5cbbf2c43ce7b/" rel="bookmark">
			SpringBoot - 声明式事务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢作者: http://blog.720ui.com/2017/springboot_02_data_transactional/
讲解 Spring Boot 如何使用声明式事务管理。
声明式事务Spring 支持声明式事务，使用 @Transactional 注解在方法上表明这个方法需要事务支持。此时，Spring 拦截器会在这个方法调用时，开启一个新的事务，当方法运行结束且无异常的情况下，提交这个事务。 Spring 提供一个 @EnableTransactionManagement 注解在配置类上来开启声明式事务的支持。使用了 @EnableTransactionManagement 后，Spring 会自动扫描注解 @Transactional 的方法和类。 Spring Boot默认集成事务Spring Boot 默认集成事务，所以无须手动开启使用 @EnableTransactionManagement 注解，就可以用 @Transactional注解进行事务管理。 数据库准备 CREATE TABLE `t_author` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户ID', `real_name` varchar(32) NOT NULL COMMENT '用户名称', `nick_name` varchar(32) NOT NULL COMMENT '用户匿名', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 添加依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7879bdec497aafdc84a5cbbf2c43ce7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2bbc51cbea3a769c561b1300f4eeeb/" rel="bookmark">
			Spring Boot整合JdbcTemplates
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据准备
创建tb_user表 DROP TABLE IF EXISTS `tb_user`; CREATE TABLE `tb_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID', `username` varchar(50) NOT NULL COMMENT '用户名', `age` int(11) NOT NULL COMMENT '年龄', `ctm` datetime NOT NULL COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 插入数据 INSERT INTO `db_springboot`.`tb_user` (`username`, `age`, `ctm`) VALUES('张三啊', '18', NOW()) ; INSERT INTO `db_springboot`.`tb_user` (`username`, `age`, `ctm`) VALUES('李四', '20', NOW()) ; INSERT INTO `db_springboot`.`tb_user` (`username`, `age`, `ctm`) VALUES('王五', '19', NOW()) ; 2、在pom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2bbc51cbea3a769c561b1300f4eeeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c157a981bdc87e0e71db7fbe1b7ee1/" rel="bookmark">
			人体各部分英语 图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人体各部分英语：
Skeleton – 骷髅，骨架
Bone – 骨头
Joint – 关节
Vein – 静脉
Artery – 动脉
Nerve – 神经
Blood – 血液
Muscle – 肌肉
Hair 头发，体毛，寒毛
Blonde – 黄发
Brunette – 棕发
Tips of your hair or end of your hair – 发尖
Root of your hair or hair follicles – 发根
Skull – 头骨
Brain – 大脑
Forehead – 额头
Eye Brow – 眉毛
Eye Lashes – 眼睫毛
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56c157a981bdc87e0e71db7fbe1b7ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8934de5d7557c574b8b1baf5cc2c2e90/" rel="bookmark">
			java List复制：浅拷贝与深拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址: https://blog.csdn.net/demonliuhui/article/details/54572908
List浅拷贝 众所周知，list本质上是数组，而数组的是以地址的形式进行存储。 如上图将list A浅拷贝给list B，由于进行的是浅拷贝，所以直接将A的内容复制给了B，java中相同内容的数组指向同一地址，即进行浅拷贝后A与B指向同一地址。造成的后果就是，改变B的同时也会改变A，因为改变B就是改变B所指向地址的内容，由于A也指向同一地址，所以A与B一起改变。
几种浅拷贝 1、遍历循环复制
List&lt;Person&gt; destList=new ArrayList&lt;Person&gt;(srcList.size()); for(Person p : srcList){ destList.add(p); } 2、使用List实现类的构造方法
List&lt;Person&gt; destList=new ArrayList&lt;Person&gt;(srcList); 4、使用System.arraycopy()方法
Person[] srcPersons=srcList.toArray(new Person[0]); Person[] destPersons=new Person[srcPersons.length]; System.arraycopy(srcPersons, 0, destPersons, 0, srcPersons.length); 测试及结果
printList(destList); //打印未改变B之前的A srcList.get(0).setAge(100);//改变B printList(destList); //打印改变B后的A //打印结果 123--&gt;20 ABC--&gt;21 abc--&gt;22 123--&gt;100 ABC--&gt;21 abc--&gt;22 List深拷贝 如图，深拷贝就是将A复制给B的同时，给B创建新的地址，再将地址A的内容传递到地址B。ListA与ListB内容一致，但是由于所指向的地址不同，所以改变相互不受影响。
深拷贝的方法 1.使用序列化方法
public static &lt;T&gt; List&lt;T&gt; deepCopy(List&lt;T&gt; src) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8934de5d7557c574b8b1baf5cc2c2e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2175fff82595b8ae7f57cf019c23df49/" rel="bookmark">
			SpringBoot 轻松搞定数据验证 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢作者: http://www.spring4all.com/article/1224
对于任何一个应用而言，客户端做的数据有效性验证都不是安全有效的，而数据验证又是一个企业级项目架构上最为基础的功能模块，这时候就要求我们在服务端接收到数据的时候也对数据的有效性进行验证。为什么这么说呢？往往我们在编写程序的时候都会感觉后台的验证无关紧要，毕竟客户端已经做过验证了，后端没必要在浪费资源对数据进行验证了，但恰恰是这种思维最为容易被别人钻空子。毕竟只要有点开发经验的都知道，我们完全可以模拟 HTTP 请求到后台地址，模拟请求过程中发送一些涉及系统安全的数据到后台，后果可想而知....
本章目标 通过 Spring Boot 完成参数后台数据校验，轻松搞定数据有效性验证，留出更多的时间来和小姐姐聊天...
创建项目 查看依赖 &lt;dependencies&gt; &lt;!-- 默认就内嵌了Tomcat 容器，如需要更换容器也极其简单--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试包,当我们使用 mvn package 的时候该包并不会被打入,因为它的生命周期只在 test 之内--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; JSR-303 介绍 JSR 是Java Specification Requests 的缩写，是指向 JCP(Java Community Process) 提出新增一个标准化技术规范的正式请求。
任何人都可以提交 JSR，以向 Java 平台增添新的 API 和服务，已审核通过的规范涉及 Java 各个领域，有兴趣可以了解一下。
Bean Validation 是一个运行时的数据验证框架，为 JavaBean 验证定义了相应的元数据模型和 API。
默认的元数据是 Java Annotations，当然也可以使用 XML 可以对已存在的元数据信息进行覆盖和扩展。
在应用中通过使用 Bean Validation 或是你自己定义的 constraint，例如 @NotNull, @Max, @ZipCode， 就可以确保数据模型的正确性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2175fff82595b8ae7f57cf019c23df49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e06688d059b0cb9e541b91356ac075a/" rel="bookmark">
			学习反向传播算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考这里，请点击
最近有个项目，需要用到深度学习，为此学了一点神经网络，而反向传播算法为神经网络中最基础也最重要的算法，特此编辑出来，记录自己的学习经历。
从最早的模式识别（Pattern Recongnition）时期开始，研究者的目标就是用可训练的多层网络取代人工特征工程。但该解决方案并没有得到广泛认可，直到上世纪80年代中期，多层架构可以通过SGD训练。只要模块是其输入金额内部权值的相对平滑函数，就可以使用反向传播步骤计算梯度。在20世纪七八十年代，几个不同的研究小组分别独立发现该思路可行且的确可用。如下图所示
从输入单元到第一个隐层H1计算如下：
对H1层的每个单元 j j j,其值 y j = f ( z j ) , z j = ∑ i ( w i j x i ) y_j=f(z_j),z_j=\sum_{i}(w_{ij}x_i) yj​=f(zj​),zj​=∑i​(wij​xi​),其中 i i i取值遍历所有输入层节点， z j z_j zj​是对前一层所有节点的加权和，这里省略了偏置项。网络中使用非线性函数 f f f对 z j z_j zj​进行非线性变换，得到改成输出 y j y_j yj​
从H1到H2计算如下:
对H2层的每个单元 k k k,其值 y k = f ( z k ) , z k = ∑ j w j k y j y_k=f(z_k),z_k=\sum_{j}w_{jk}y_j yk​=f(zk​),zk​=∑j​wjk​yj​,其中 j j j遍历去所有H1层节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e06688d059b0cb9e541b91356ac075a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0dc8386a07a5cb1f5c23beecff93f5/" rel="bookmark">
			常见的蔬菜（vegetables）英语单词：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常见的蔬菜（vegetables）英语单词： pepper 胡椒 hot pepper; chilli 辣椒 sweet pepper; bell pepper; pimiento; capsicum 甜椒, 柿子椒 tomato 番茄,西红柿 asparagus 芦笋 cucumber 黄瓜 aubergine, eggplant 茄子 bean 菜豆 beet, beetroot 甜菜 potato 马铃薯 carrot 卜胡萝卜 cauliflower 菜花,花椰菜 pumpkin 西葫芦 broad bean 蚕豆 cabbage 圆白菜,卷心菜 garlic 蒜 chive 细香葱 fennel 茴香 cos lettuce 莴苣 marrow 嫩葫芦 melon 香瓜,甜瓜 celery 芹菜 onion n. 洋葱(头) leek 韭菜 radish 萝卜 tarragon 狭叶青蒿 thyme 百里香 mushroom 蘑菇 artichoke 洋蓟 broccoli, brocoli 硬花甘蓝 Brussels sprouts 芽甘蓝 caper 刺山柑,老鼠瓜 cardoon 刺菜蓟 chervil 雪维菜,细叶芹 chick-pea 鹰嘴豆 chicory 苣荬菜 cress 水田芥 cumin, cummin 孜然芹,枯茗 dandelion 蒲公英 French bean 法国菜豆 gherkin 嫩黄瓜 horseradish 辣根 Jerusalem artichoke 洋姜,鬼子姜 kale 无头甘蓝 kohlrabi 甘蓝 laurel 月桂 lentil 兵豆 lettuce 莴苣 lupin 羽扇豆 (美作:lupine) parsley 欧芹 parsnip 欧防风 pea 豌豆 rhubarb 大黄 salsify 婆罗门参 sorrel 掌叶大黄 truffle 块菌 turnip 芜菁 watercress 豆瓣菜 Potato 马铃薯 Carrot 红萝卜 Onion 洋葱 Aubergine 茄子 Celery 芹菜 White Cabbage 包心菜 Red cabbage 紫色包心菜 Cucumber 大黄瓜 Tomato 蕃茄 Radish 小红萝卜 Mooli 白萝卜 Watercress 西洋菜 Baby corn 玉米尖 Sweet corn 玉米 Cauliflower 白花菜 Spring onions 葱 Garlic 大蒜 Ginger 姜 Chinese leaves 大白菜 Leeks 大葱 Mustard &amp; cress 芥菜苗 Green Pepper 青椒 Red pepper 红椒 Yellow pepper 黄椒 Mushroom 洋菇 Broccoliflorets 绿花菜 Courgettes 绿皮南瓜，形状似小黄瓜，但不可生食 Coriander 香菜 Dwarf Bean 四季豆 Flat Beans 长形平豆 Iceberg 透明包心菜 Lettuce 莴苣菜 Swede or Turnip 芜菁 Okra 秋葵 Chillies 辣椒 Eddoes 小芋头 Taro 大芋头 Sweet potato 蕃薯 Spinach 菠菜 Beansprots 绿豆芽 Peas 碗豆 Corn 玉米粒 Sprot 高丽小菜心 water chestnut荸荠 water shield莼菜 wax gourd冬瓜 yam山药 spinach菠菜 straw mushroom草菇 string bean刀豆 lettuce 莴苣 marrow 西葫芦 laver 紫菜 eggplant 茄子 the (edible) snake gourd 蛇瓜 the melabar gourd 黑子南瓜(无花果叶瓜) the serpent gourd 蛇瓜 the spanish gourd 南瓜 the sponge[towel] gourd 丝瓜 the teasel gourd 刺瓜 buttom mushroom 蘑菇 brown mushroom 鲜冬菇 enoki mushroom 金针菇 straw mushroom 草菇 oyster mushroom 油菇 abalone mushroom 鲍鱼菇 zucchini 小西葫芦 angled luffa 丝瓜 aloe 芦荟 clove 丁香 aniseed 八角 cinnamon 肉桂 licorice 草 honeydew 甜瓜 cantaloup 香瓜 choysum 菜心 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf752fb89a6c45a754d44c943d8b70f/" rel="bookmark">
			Java 8-Stream API-练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交易员类
public class Trader { private final String name; private final String city; public Trader(String name, String city) { this.name = name; this.city = city; } public String getName() { return name; } public String getCity() { return city; } @Override public String toString() { return "Trader{" + "name='" + name + '\'' + ", city='" + city + '\'' + '}'; } } 交易类
public class Transaction { private final Trader trader; private final int year; private final int value; private Currency currency; public Currency getCurrency() { return currency; } public void setCurrency(Currency currency) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf752fb89a6c45a754d44c943d8b70f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09558858b894ef89ee77bff0bc084d58/" rel="bookmark">
			flume自定义Interceptor的UUID和其他逻辑处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.meme.flume.interceptor; import com.google.common.base.Charsets; import org.apache.flume.Context; import org.apache.flume.Event; import org.apache.flume.interceptor.Interceptor; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.List; import java.util.UUID; /** * Created by root on 7/3/18. */ public class MyInterceptor implements Interceptor { private static final Logger logger = LoggerFactory .getLogger(MyInterceptor.class); public MyInterceptor(){ } @Override public void initialize() { } @Override 可以在该方法里写自己拦截器的逻辑 我这里就只添加了UUID public Event intercept(Event event) { try{ String body = new String(event.getBody(), Charsets.UTF_8); StringBuffer bodyoutput = new StringBuffer(); bodyoutput.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09558858b894ef89ee77bff0bc084d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43482c7f3ae8d4986e3491350ef702fe/" rel="bookmark">
			英语句子成分分析（三）-- 主语＋谓语＋宾语 ＋宾语补足语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五种基本句型之 主语＋谓语＋宾语 ＋宾语补足语 这个句型在有的语法书上又叫做主语＋谓语＋复合宾语，这里的复合宾语=宾语＋宾语补足语，这里又新增加一个“东东”：宾语补足语。 说起宾语补足语来，我们先从初中你熟悉的三个句型说起 ：ask somebody to do something （邀请某人做某事） tell somebody to do something （告诉某人做某事） want somebody to do something （要求某人做某事） 你不会告诉我，这三个句型那里熟悉呀，根本没见过，那我只能说,你的英语不是一般的“菜”，上过三年初中，不知道这三位“赫赫有名”的短语，你该是恶补英语的时候了，闲话少说，我们再看由这三个句型构成的例句： 1、 I asked him to have dinner. 谓语 宾语 宾语补足语 2、 He told me to clean the room. 谓语 宾语 宾语补足语 3、 Tom wanted me to meet him . 谓语 宾语 宾语补足语 我们看第一个句子，我邀请他吃饭，他（him）是作邀请（asked）的宾语，如果后面没有to have dinner ，句子意思就不完整，我邀请他，干什么呢？没说清楚，于是就有 to have dinner 来帮助说清楚，是吃饭的，在这里的to have dinner 就是宾语补足语，这是动词不定式短语作宾补。（你又在疑惑什么是动词不定式短语呢？大家知道，to do 是动词不定式，但是如果动词不定式中的动词带有宾语或者动词不定式中的动词有副词来修饰，这时的动词不定式就成为不定式短语了。比如 to do something 就是动词不定式短语，换句话说：这里 to have(动词不定式) to have dinner（动词不定式短语）。又比如：to run是 动词不定式to run fast 是动词不定式短语）。 上面的三个句子都是不定式短语作宾语不足语来帮助宾语来补充说明，那么除了动词不定式（短语）作宾补之外，还有什么可以作宾补呢 ？ 实际上，能够作宾补的有很多，我们这里只学习几种常见的： doing \不带to的动词不定式\介词短语\形容词等等。请看下面的例句，注意观察划线的部分是有什么作的宾语补足语。： 1、I saw a thief stealing something.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43482c7f3ae8d4986e3491350ef702fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87543f58e96fbb295ba365efe73f222f/" rel="bookmark">
			mac安装python库报openssl文件找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mac上安装一些python库报错，如下：
SWIG/_m2crypto.i:54: Error: Unable to find 'openssl/opensslv.h'
SWIG/_m2crypto.i:60: Error: Unable to find 'openssl/safestack.h'
SWIG/_evp.i:12: Error: Unable to find 'openssl/opensslconf.h'
SWIG/_rc4.i:5: Error: Unable to find 'openssl/opensslconf.h'
SWIG/_ec.i:7: Error: Unable to find 'openssl/opensslconf.h'
error: command 'swig' failed with exit status 1
或：
build/temp.macosx-10.11-intel-2.7/_openssl.c:493:10: fatal error: 'openssl/opensslv.h' file not found
#include &lt;openssl/opensslv.h&gt;
^
1 error generated.
error: command 'cc' failed with exit status 1
此原因产生，应该是openssl版本过低或位置未找到。
查看版本命令：openssl version
版本升级：
brew update
brew install openssl
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87543f58e96fbb295ba365efe73f222f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad10de735d92ed7c7e959af44815a003/" rel="bookmark">
			爬虫学习之8：使用网站API获取数据（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多网站提供了API供开发者获取数据用，通常返回的数据为JSON格式，本文以百度开放者平台为例对通过API进行数据获取进行实验，由于百度API接口很多，后续会把实验的接口陆续补充上去，都是很简单的程序，以后可以以此为基础编写更综合的应用程序。
百度API的使用步骤都差不多，注册百度开发者平台-&gt;获得免费的AppID和Key-&gt;构造开发者文档中提供的URL-&gt;GET获取Json数据-&gt;解析展示。以下小程序简单不做过多解释，屏蔽了我自己的AppID和Key。
1、百度翻译的使用
支持26中语言的翻译，翻译准确性还是很不错的。
import requests import random import hashlib import json import pprint appid = '12345678' key = 'dasd457dawgjj54j01qf' url = 'http://api.fanyi.baidu.com/api/trans/vip/translate?' #需要翻译的文本 q = '建设中国特色社会主义' #原语言 from_language ='zh' #目的语言 to_language = 'en' #随机数 salt = random.randint(32768, 65536) #签名 sign = appid+q+str(salt)+key sign = sign.encode('utf-8') sign_new = hashlib.md5(sign).hexdigest() #生成URL new_url = url + 'q='+q+'&amp;from='+from_language+'&amp;to='+to_language+'&amp;appid='+appid+'&amp;salt='+str(salt)+'&amp;sign='+sign_new res = requests.get(new_url) print(res.text) json_data = json.loads(res.text) #translate_result = json_data["trans_result"]["dst"] pprint.pprint(json_data["trans_result"]) [{'dst': 'Building socialism with Chinese characteristics', 'src': '建设中国特色社会主义'}] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad10de735d92ed7c7e959af44815a003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd2717c3be59aaf3df1812294cc6be2/" rel="bookmark">
			maven多module项目的引用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述:当建一个多module的maven项目时,我们想要的效果是:
当子项目引用父项目时,我们可以根据需要引用其他子项目,而不是全部其他子项目.当别的项目引用我们这个父项目时,应该引用了全部子项目.
那我们如何达到这个目标.
首先,我们知道maven的pom文件里面,如果我们想引用另一个项目就需要这样: &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 这样引用后,我们就可以从项目的Maven Dependencies里面看到引用的jar包.
而在我们开发多模块项目时,我们每个子项目都是在父项目的管理下,一般我们的子项目pom像这样继承父项目:
&lt;parent&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;parent-example&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/parent&gt; 因为我们的子项目肯定是需要引用别的子项目的,那我们父项目比如这样:
&lt;modules&gt; &lt;module&gt;child-A&lt;/module&gt; &lt;module&gt;child-B&lt;/module&gt; &lt;module&gt;child-C&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;child-A&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;child-B&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;child-C&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 这时候假如我们child-A需要引入child-B,那么我们肯定会在child-A的pom里面这样写:
&lt;parent&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;parent-example&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/parent&gt; &lt;dependency&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;child-B&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; 没问题是不是,我也觉得很ok,可是实际你会发现,child-A的Maven Dependencies里面包含了所有的子项目的jar包.这就尴尬了,我们不需要别的子项目呀.
这点怎么解决了.如果有经验的同学肯定会用这个dependencyManagement标签来解决.于是,我们修改父项目的pom文件:
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;child-A&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;child-B&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xiaoyu&lt;/groupId&gt; &lt;artifactId&gt;child-C&lt;/artifactId&gt; &lt;version&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd2717c3be59aaf3df1812294cc6be2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4db38804898ae80701f1a6d61955cf/" rel="bookmark">
			html相对定位和绝对定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相对定位：该元素相对于自己原有位置，偏移一定距离。相对的是自己。
绝对定位：该元素相对于其父元素，偏移一定距离。相对的是父元素，重点是这个父元素也需要是设置了position属性。从最近的父元素开始找，直到找到body位置为止。
1）相对定位
&lt;div id="test"&gt; &lt;p class="p1"&gt;相对定位：相对于自己原来的位置，偏移一些距离&lt;/p&gt; &lt;p class="p2"&gt;相对定位,相对的是自己&lt;/p&gt; &lt;/div&gt; 对应的css样式：
#test{ height: 300px; width: 300px; background: gray; } /*p标签本身会有padding和margin值*/ p{ margin: 0px; padding: 0px; } .p1{ height: 100px; width: 100px; background: blue; } .p2{ height: 80px; width: 80px; background: red; } 运行后效果是：(这时没有设置position属性呢)
然后，给p1设置相对定位
.p1{ height: 100px; width: 100px; background: blue; /*设置相对定位*/ position: relative; /*相对于左边偏移20px,相对于上边偏移20px*/ left: 20px; top:20px; } 运行后效果如下： 2）绝对定位
再增加一個div
&lt;body&gt; &lt;div id="test"&gt; &lt;p class="p1"&gt;相对定位：相对于自己原来的位置，偏移一些距离&lt;/p&gt; &lt;p class="p2"&gt;相对定位,相对的是自己&lt;/p&gt; &lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d4db38804898ae80701f1a6d61955cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70e5a9de40977abe161030a8c72cee2/" rel="bookmark">
			贪心法求解TSP问题 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述 TSP问题是指旅行家要旅行n个城市然后回到出发城市，要求各个城市经历且仅经历一次，并要求所走的路程最短。
2.算法思想
贪心法求解TSP问题有两种贪心策略。
1）最近邻点策略：从任意城市出发，每次在没有到过的城市中选择最近的一个，直到经过了所有的城市，最后回到出发城市。
给定初始的城市a，寻找与其邻接的最短距离的城市b，记录二者之间的路径并增加总路径长度；下一次从城市b开始，寻找与b邻接的最短距离的城市,循环查找，直到找到n-1条路径（n为城市个数），最后加上终点回到起点的边即可。
2）最短链接策略：每次在整个图的范围内选择最短边加入到解集合中，但是，要保证加入解集合中的边最终形成一个哈密顿回路。
首先按照城市之间距离远近进行排列，从距离最近的两个城市开始，如果这两个城市不在一个联通分量中并且度数均小于等于2，那么记录二者之间的路径，将它们划分到一个联通分量并将度数增加1；然后从距离第二小的两个城市开始，重复上述操作直到记录的路径有n-1条，最后找到度数为1的两个城市，作为最后一条路径。
3.参考代码
最近邻点策略：
/*TSP问题采用贪心法的最近邻点策略*/ /* TSP问题是指旅行家需要旅行n个城市，要求各个城市经过且仅经过一次， 然后回到出发城市，并且所走的路径最短。 */ /* 最近邻点策略：从任意城市出发，每次在没有到过的城市中选择最近的一个， 直到经过了所有的城市，最后回到出发城市 */ #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;iomanip&gt; using namespace std; //类TSP class TSP { private: int city_number;	//城市个数 int **distance;	//城市距离矩阵 int start;	//出发点 int *flag;	//标志数组，判断城市是否加入汉密顿回路 int TSPLength;	//路径长度 public: TSP(int city_num);	//构造函数 void correct();	//纠正用户输入的城市距离矩阵 void printCity(); //输出用户输入的城市距离 void TSP1();	//贪心法的最近邻点策略求旅行商问题 }; //构造函数 TSP::TSP(int city_num) { int i=0,j=0; int start_city; city_number=city_num; //初始化起点 cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70e5a9de40977abe161030a8c72cee2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6f7003665ea85e81fb9aaec75b1a88/" rel="bookmark">
			$.ajax()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$.ajax()函数 一般在前端html和服务器交互，又要异步提交表单时，我们通常会用到$.ajax(){}函数，这是封装到ajax里的一个函数，相比于XMLHTTPRequest做页面局部刷新更方便，但最终还是使用的XMLHTTPRequest，下面记录下$.ajax()函数，以备日后回顾。
$.ajax(){}函数格式如下：
$.ajax({
url: "test.aspx?r=" + Math.random(),
type: "GET",
data: {},
dataType: "json",
async: false,
success: function (result) {
var coin = result["coin"];
var stage = result["stage"];
document.write("金币：" + coin + "个，身份：" + stage);
}
});
参数具体意思：
url：请求的服务器地址，默认是当前页面，数据类型是String
type：请求的方式，有POST和GET两种，默认是GET，数据类型是String
data：发送到服务器的数据，数据类型是Object或者String，大括号里的对象必须为key/value格式，比如：data:{boy:"LiLei",girl:"HanMeimei",boyage:18,girlage:16}
dataType：预期服务器返回的数据类型，数据类型是String，参数值有：
xml：返回XML文档，可用JQuery处理。
html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。
script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。
json：返回JSON数据。
jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。
text：返回纯文本字符串。
async：所有请求是同步还是异步，当值是true时是异步请求，为false时是同步请求。同步请求会锁住浏览器，即进入页面假死状态，用户其他操作必须等待请求完成才可以执行，请求完成以后页面假死状态解除。我们看一个例子：
$.ajax({
url: "test.aspx?r=" + Math.random(),
type: "GET",
data: {},
dataType: "json",
async: true,
success: function (result) {
function1();
function2();
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c6f7003665ea85e81fb9aaec75b1a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9acb848741f57fe3a76be168703473b8/" rel="bookmark">
			快速排序解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序解析 快速排序用到的知识点，递归，分制。
思想，如果将数列要从小到大的排列，先取一个数做为比较数a（一般取要数列或者拆开数列的第一个数，也看个人习惯），先从右往左找比a小的数据，并交换数据。交换完数据后，在交互数据的位置从左往右找比a大的数据，找到后，再交换数据。这算是一轮结束。这一轮结束后，左索引会将数组分成两半，然后将0到左索引与左索引到末尾变成两组数组，然后递归分制，上面的循环。直到每个数组的左索引和右索引相同了，说明这个数组就排好了。
算法担心的问题：一个数组被索引分开后，会担心前半部分的最大数会比后半部分的最小数要大。
解疑： 不会出现这样问题的，算法设计是（比如从小到大排），先从左边第一个作为比较数a,左索引为l=0,右索引为r=数组的长度。先从右索引往左找比a小的数，找不到就r--,直到在r1位置找到了比a小的数据，就将r1位置的与l位置的数据互换（此时l位置的数据就是0，也是比较数a,）换完之后此时，r1+1位置到r的位置都比a要大，上半轮结束。下半轮开始，从左索引（l）往右找比r1（此时的r1位置就是a）位置大的数，找不到就l++,直到在l1位置找到比r1位置大的数然后交换r1与l1位置的数，此时l1位置的数就是a,下半轮结束。这一轮结束后，这个数列从0位置到l1位置的数都是比l1位置的数（即a）都小或等于（等于性质放在左右边都可以），然后从l1到末尾的数都是比l1位置（即a）都大的数。这样由l1位置将这个数组分成两组（不拆数组），每组进行单独排序（分制递归）。就可保障这个数组从小到大排列。
代码实现 package src.main.lib; public class 快速排序 { public static void main(String[] args) { int[] arr = { 5, 9, 7, 4, 3, 5, 1, 6 }; // int[] arr = {5,9,7}; quick_sort(arr, 0, 7); } // 快速排序 public static void quick_sort(int s[], int l, int r) { // int[] arr = {5,9,7,4}; if (l &lt; r) { // Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1 int i = l, j = r, x = s[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; s[j] &gt;= x) { // 从右向左找第一个小于x的数 j--; } if (i &lt; j) { int temp = s[i]; s[i] = s[j]; s[j] = temp; i++; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9acb848741f57fe3a76be168703473b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b73024bd0aebacdde8efd7c9057dca/" rel="bookmark">
			Web Worker API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Web Worker可以理解为js在后台线程中运行的方法，它可以执行js代码而不阻塞用户UI界面。一个Web Worker可以将消息发送到创建它的JavaScript代码（只要运行在同源的父页面中，workers可以依次生成新的workers）, 反之也可以从主线程接收消息
注意：worker运行在另一个全局上下文中,不同于当前的window。因此，使用window快捷方式获取当前全局的范围，在一个Worker内将返回错误（直接访问你需要访问的属性即可！如：console而不是window.console）。
worker中可用函数和接口 在WebWorker中有些方法和属性是不能被访问的，比如BOM的一些API和DOM相关的一些API，localStorage，SessionStorage等，但是大部分的window对象是可以被访问的比如：Websocket，XMLHttpRequest（同样不能跨域☹）Console Api，Array，Date，Math，String等等，就是说涉及到页面操作和页面中的对象统统不能被访问，它的应用场景是替代主线程执行需要消耗页面性能的代码。这里有一份关于WebWorker允许访问的方法及属性清单
主要wroker类型 常用worker为专用worker（仅在单一脚本中被使用）和共享worker（以同时被多个脚本使用）；DedicatedWorkerGlobalScope和SharedWorkerGlobalScope对象分别代表它们的上下文
使用 为了更好的错误处理控制及向下兼容需要做些兼容检测
if (window.Worker) { some codes ... } 生成Worker 调用Worker()构造函数创建一个Worker对象，该对象接收指定的URL脚本（脚本必须遵守同源策略否则将抛出错误）
var myWorker = new Worker('worker.js'); 数据传递 主线程和worker线程都使用postMessage()方法发送各自的消息，使用onmessage事件处理函数来响应消息（消息被包含在Message事件的data属性中），这个过程中数据并不是被共享而是被复制。在主线程中使用时，onmessage和postMessage() 必须挂在worker对象上，而在worker中使用时不用这样做。原因是，在worker内部，worker是有效的全局作用域。
/*主线程*/ //发送数据至worker myWorker.postMessage('can you hear me?'); //从worker线程监听接收数据 myWorker.onmessage = function(e) { console.log(e.data);//'I can hear you！' } /*worker线程*/ //从主线程监听接收数据 onmessage = function(e) { console.log(e.data);//'can you hear me?' //发送数据至worker e.data &amp;&amp; postMessage('I can hear you！'); } 终止worker 如果你需要从主线程中立刻终止一个运行中的worker，可以调用worker的terminate方法：
myWorker.terminate();//worker 线程会被立即杀死 在worker线程中，workers 也可以调用自己的close方法进行关闭：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b73024bd0aebacdde8efd7c9057dca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16d544600e985f2d7f8d9429d8643e0/" rel="bookmark">
			git did not exit cleanly (exit code 128)  的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
在新建一个空的本地git仓库后，打算将远程仓库中的代码Pull到本地时异常，具体异常内容如下：
git.exe pull --progress -v --no-rebase "origin" master
POST git-upload-pack (275 bytes)
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (6/6), done.
warning: no common commits
remote: Total 7 (delta 0), reused 3 (delta 0), pack-reused 0
From https://github.com/Jackson-AndyLau/CMSManager
* branch master -&gt; FETCH_HEAD
* [new branch] master -&gt; origin/master
fatal: refusing to merge unrelated histories
git did not exit cleanly (exit code 128) (4469 ms @ 2018-07-01 11:13:35)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c16d544600e985f2d7f8d9429d8643e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e534b23ca4837a2a72fe83a290f1fd9f/" rel="bookmark">
			git did not exit cleanly (exit code 1)  的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
关于Git的使用，在通常情况下，习惯于先在本地创建一个本地仓库，然后将项目提交到本地master，再将本地master中的项目Push 到远程仓库中，这样问题就来了。
具体错误信息如下：
git.exe push --progress "origin" master
To https://github.com/Jackson-AndyLau/CMSManager.git
! [rejected] master -&gt; master (non-fast-forward)
error: failed to push some refs to 'https://github.com/Jackson-AndyLau/CMSManager.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
git did not exit cleanly (exit code 1) (12359 ms @ 2018-07-01 09:41:24)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e534b23ca4837a2a72fe83a290f1fd9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7ff4aea8a3dc4d37ce59d55f9c3b5a/" rel="bookmark">
			【感知】卡尔曼滤波与目标追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：申泽邦（Adam Shan），兰州大学在读硕士研究生，主攻无人驾驶，深度学习；
本文来源：http://blog.csdn.net/AdamShan/article/details/78248421
首先我将带大家了解无人驾驶汽车系统感知模块的重要技术——卡尔曼滤波，卡尔曼滤波部分我打算分三节（三次博客的内容）：
卡尔曼滤波与行人状态估计扩展卡尔曼滤波（EKF）与传感器融合处理模型，无损卡尔曼滤波（UKF）与车辆状态轨迹 本节为卡尔曼滤波，主要讲解卡尔曼滤波的具体推导，卡尔曼滤波在行人状态估计中的一个小例子。
为什么要学卡尔曼滤波？ 卡尔曼滤波以及其扩展算法能够应用于目标状态估计，如果这个目标是行人，那么就是行人状态估计（或者说行人追踪），如果这个目标是自身，那么就是车辆自身的追踪（结合一些地图的先验，GPS等数据的话就是自身的定位）。在很多的无人驾驶汽车项目中，都能找到卡尔曼滤波的扩展算法的身影（比如说EKF，UKF等等）。本节我们从最简单的卡尔曼滤波出发，完整的理解一遍卡尔曼滤波的推导过程，并实现一个简单的状态估计Python程序。
卡尔曼滤波是什么？ 我们通常要对一些事物的状态去做估计，为什么要做估计呢？因为我们通常无法精确的知道物体当前的状态。为了估计一个事物的状态，我们往往会去测量它，但是我们不能完全相信我们的测量，因为我们的测量是不精准的，它往往会存在一定的噪声，这个时候我们就要去估计我们的状态。卡尔曼滤波就是一种结合预测（先验分布）和测量更新（似然）的状态估计算法。
一些概率论的知识基础 下面是一些概率论的基础知识，如果之前有这方面的知识储备那当然是最好的，很有利于我们理解整个博客内容，如果没有这方面的基础而且也看不懂下面的内容也没关系，我会以一个相对直观的方式来展现整个理论部分。
先验概率 P(X)：仅仅依赖主观上的经验，事先根据已有的只是的推断后验概率 P(X|Z)：是在相关证据或者背景给定并纳入考虑以后的条件概率似然 P(Z|X)：已知结果区推测固有性质的可能性 贝叶斯公式：
P ( A ∣ B ) = P ( A ) × P ( B ∣ A ) P ( B ) P(A|B)=\frac{P(A)×P(B|A)}{P(B)} P(A∣B)=P(B)P(A)×P(B∣A)​
后验分布正比于先验分布乘以似然。
卡尔曼滤波完整推导 一个简单的例子 若干年后，我们的可回收火箭要降落到地球，我们比较关心的状态就是我们的飞行器的高度了，飞行器的高度就是我们想要估计的状态，我们会通过一些传感器去测量我们当前的高度信息，比如说使用气压计。假如我们每一次测量，当前高度都变成上一次测量的 95%，那么我们就可以得到如下关系：
H e i g h t ( t ) = 0.95 × H e i g h t ( t − 1 ) Height^{(t)}=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7ff4aea8a3dc4d37ce59d55f9c3b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d28fd85dc87a11f34bcdaf05c561a3/" rel="bookmark">
			Vue里this指向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、普通函数中的this 这是vue文档里的原话：
All lifecycle hooks are called with their 'this' context pointing to the Vue instance invoking it.
意思是：在Vue所有的生命周期钩子方法（如created，mounted， updated以及destroyed）里使用this，this指向调用它的Vue实例，即（new Vue）。 &lt;div id="app"&gt; &lt;button class="btn btn-primary" v-on:click="on()"&gt;点击添加并查看this&lt;/button&gt; &lt;ul class="list-group" v-for="item in list"&gt; &lt;li class="list-group-item"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: "#app", data: { list: ["banner", "orange", "apple"] }, methods: { on: function() { alert(this.list); this.list.push("Potato") } }) &lt;/script&gt; 实例：这里的this指向的是new Vue这个对象。new Vue也可以写成var C=new Vue({}).所以这里的this指向的是C。
二、箭头函数中的this
箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20d28fd85dc87a11f34bcdaf05c561a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6ae104ca6d7d0c8cb6900b723e180b/" rel="bookmark">
			Pandas Nan &amp; None 处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在处理数据的时候遇到这个问题。
数据库里的值 是null 然后读取数据库后得到的dataframe 里显示的事None.
想把这些None 装换成0.0 但是试过很多方法都不奏效。
使用过
df['PLANDAY'].replace('None',0) 未奏效
这个判断句是生效的
df.loc[0,'PLANDAY'] is None:后来发现这个数据类型是Nan 不是None 因此使用解决了上诉问题。
df['PLANDAY'] = df['PLANDAY'].fillna(0.0) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ae89fdbcf3edabe6c3cb237a8a7f97/" rel="bookmark">
			如何快速查看颜色的RGB或者十六进制代码(QQ截图，最方便)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个前端人员经常用的就是查看颜色的十六进制，虽然能够使用ps查看，但是把图片载入ps就比较麻烦了，或者安装一个软件每次使用打开也很麻烦。其实qq截图就能够实现这些需求，相信很多人电脑都有qq的，而且工作时qq也是在线的！
快捷键是Ctrl+Alt+A
然后发现光标下就有 rgb(); 三原色格式的
如果想查看十六进制的格式，按完Ctrl+Alt+A快捷键之后按住 Ctrl 光标下就显示为十六进制的颜色代码。
如果对你有帮助的话，给我点个赞，让我分享一些技术的时候更有动力。
另外我建了一个公众号，会不时分享前端的一些技术，或者遇到的难题和解决办法，欢迎大家关注。
搜索：钱端工程师 或 Money-end-engineer 或 扫描下方图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0440eee645ba93404188a576f7720512/" rel="bookmark">
			Error: No PostCSS Config found in... 报错 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目clone下来后，在本地怎么也运行不起来，总是报错 后来终于找到了解决方法，成功运行。 解决方案: 在项目根目录新建postcss.config.js文件，并对postcss进行配置：
module.exports = { plugins: { 'autoprefixer': {browsers: 'last 5 version'} } } 然后npm run dev,果然成功运行 原因：postcss.config.js是针对webpack3.0做的特殊处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aad33bea7db7feb2164aa1471ae7dd9/" rel="bookmark">
			基于神经网络的意图识别 - 基础版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Github: https://github.com/yjfiejd/Text_Classification_NN/blob/master/text_classification_6.28.py # -*- coding:utf8 -*- # @TIME : 2018/6/28 下午10:34 # @Author : Allen # @File : text_classification_6.28.py import nltk from nltk.stem.lancaster import LancasterStemmer import os import json import datetime stemmer = LancasterStemmer() #3种意图 training_data = [] training_data.append({"class":"greeting", "sentence":"how are you?"}) training_data.append({"class":"greeting", "sentence":"how is your day"}) training_data.append({"class":"greeting", "sentence":"good day"}) training_data.append({"class":"greeting", "sentence":"how is it going today?"}) training_data.append({"class":"goodbye", "sentence":"have a nice day"}) training_data.append({"class":"goodbye", "sentence":"see you later"}) training_data.append({"class":"goodbye", "sentence":"have a nice day"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aad33bea7db7feb2164aa1471ae7dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439f7b093b6a778a35984d60f188d255/" rel="bookmark">
			[Matlab] Simulink 串口接收详解1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，欢迎转载。转载请注明：转载自 祥的博客
原文链接：https://blog.csdn.net/humanking7/article/details/80851223
1. 接收uint8数据 1.1. 接收端设置 2. 接收double数据 2.1. 接收端设置2.2. 发送端设置 3.模块讲解 3.1. 模块 Serial Receive3.2. 模块 Serial Configuration 3. 接收更加复杂的情况4.程序下载 1. 接收uint8数据 用串口调试助手给 Matlab 发送两个字节a和A，用ASCII码展示就是97和65。
1.1. 接收端设置 因为发送方只发送了2个uint8类型的数据，所以设置如下：
2. 接收double数据 我用Qt写了一个串口发送程序(上图右)，这个程序的单值测试发送程序是一次发送2个double类型的数据，用的是union进行发送，实际上就是一次发送16个uint8 数据( 1个double占用8个字节)。
2.1. 接收端设置 主要是对于Data type进行了修改，现在我们传的的是uint8 buf[16] ，但是其意义是两个double类型的数值（double num[2]）。
对于Serial Receive模块的设置，其实是让这个模块完成了两件事情：
接收数据。数据只有2个；解析数据。这两个数据是double类型的，也就是接收了16个uint8类型的数据，然后解析为2个double类型的数据。 2.2. 发送端设置 //-------------------- // 发送类型数据定义 //-------------------- typedef union { char buf[16];//用于发送和接收 double number[2];//用于解码 }Un_sendData; //-------------------- // 发送部分代码展示 //-------------------- qint64 ret, len; Un_sendData sendData; double num1, num2; //获取两个数值 num1 = ui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439f7b093b6a778a35984d60f188d255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a36b99682eeaea94cd1141ac2ef3e30/" rel="bookmark">
			linux 下ab压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ab的简介 ab是apachebench命令的缩写。
ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。
ab的原理 ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。
ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机。
ab的安装 yum -y install httpd-tools 测试安装是否成功： [root@vic html]# ab -V This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ ab的参数说明 [root@vic html]# ab --help ab: wrong number of arguments Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform -c concurrency Number of multiple requests to make -t timelimit Seconds to max.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a36b99682eeaea94cd1141ac2ef3e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc1ff0273adc1a88f52f46d3ac09c1c/" rel="bookmark">
			Linux下部署NFS服务   (*￣︶￣)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、 NFS 简介和架构图 NFS是Network File System的缩写，即网络文件系统。一种使用于分散式文件协定，功能是通过网络让不同的机器、不同的操作系统能够分享个人数据，让应用程序通过网络可以访问位于服务器磁盘中的数据。 NFS在文件传送或信息传送的过过程中，依赖于RPC协议。RPC，远程过程调用（Remote Procedure Call）,是使客户端能够执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，就是因为NFS使用了RPC提供的传输协议，可以说NFS就是使用PRC的一个程序。
NFS 存储 服务器主要用于用户上传的数据 ，图片 音频 、等信息 NFS服务端、RPC协议、客户端三者可以理解为房源、中介、租客之间的关系： 二、NFS 适用场景 ； 2.1 NFS 最好是部署在局域网 ，不要在公网上 ； 2.2 NFS 只能在 linux 上使用 （如果想让 windows 和 Linux 之间实现数据共享建议使用 FTP 或者 samba）； 2.3 NFS 适合在中小型企业使用 ； ② ，大型网站不会用 NFS 的， 用的都是 分布式存储 ====================================
三、 NFS 服务端干的三件事 ；
NFS 客户端干的三件事 ；
==========================NFS 部署 环境准备=========================
四 、 服务端配置
4.1 环境准备2台 CentOS 6.9 ，IP可以自定义 ；
[root@NFS ~]# cat /etc/redhat-release CentOS release 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfc1ff0273adc1a88f52f46d3ac09c1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c83995cfa03089fbc8c433d58a6c35/" rel="bookmark">
			《Graph Learning》| 图传播算法（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从本章开始，我们就会陆续讲一些图算法。本文首先给大家聊一聊图传播算法，对于图传播算法，并没有确切的定义，但是这类算法都有着十分明确和统一的范式，理解了这一范式之后，就能迅速掌握此类算法。
给定图G={V,E}，V表示节点集合，E表示边集合，设N(Vi)表示节点Vi的邻居节点构成的集合，若G为有向图：
其中Nin(Vi)表示Vi的入边节点集合，Nout(Vi)表示Vi的出边节点集合。
假设我们对Vi节点的衡量指标表示为Rvi（比如后面会具体谈到的指标PageRank值、hub值、Authority值等）衡量指标的更新规则为函数f，则图传播算法的一般步骤执行如下：
1、初始化Rvi
2、While（不满足停止条件）
3、
上述步骤的核心在于第三行中的更新函数f，一般来说f具有以下两个特点：
a. f是无参的，就是说f是直接进行量化计算的，不需要参数学习过程。这样的特点就决定了f的设计需要十分精巧，符合一定的基本经验直觉，总结来说就是：
b. f是作用在节点一阶邻域上的。这一点是很多以节点为中心的算法的共同特点，每一次节点在更新过程中，只有邻居节点参与运算，但是随着更新次数的增加，信息的流通也变得更Global。
另外，停止条件一般选取一个最大的迭代轮数或者Rvi不再变化。下面，我们结合4个经典的图传播算法来看看该范式是怎么发挥实际作用的。
第一个：PageRank
如果将每一个网页都抽象成一个节点，网页A有链接指向B，则存在一条有向边从节点A指向节点B，那么整个Web网页就抽象成为一张有向图。PageRank算法要做的就是对图中的每个节点进行重要性排名。
经验假设：
数量假设——被更多网页链接到的网页更重要；
权重假设——有更少外链的网页将会传递更高的权重。
数量假设表示重要性的计算是加和的，权重假设是说重要性的计算是加权的，因此，如果要量化重要性的计算，其在数学形式上一定是加权求和的。
下面我们直接给出更新函数的向量化形式：
Rvi表示节点Vi的重要度排名
Vj的权重
下面我们举个经典的例子来说明PageRank算法是怎么计算的。假设有A,B,C,D四个网页，其构成的有向图如下：
邻接矩阵
Adj(ij)=1,则表示有节点从j指向节点i的边，对Adj按列进行归一化得到：
我们称M为转移矩阵（Transition,Matrix）Mij表示从节点j跳转到节点i的概率，可以看到：
初始时设每个网页的排名都是1/N
依据上面更新函数，将其写成矩阵形式则更新后：
之后，不断重复这个过程会发现，R最终是收敛的。这里我们需要注意到一个重要的性质，如果R初始化后加和为1，则R在之后的迭代过程中，R的加和永远保持为1，我们可以证明下：
R=MR，两边求和，我们看右边
Mcol为M矩阵列向量之和组成的向量，由M的定义可知，M矩阵每一列加和为1，所以这里Mcol是一个全1向量，因此：
由于R初始化后加和为1，则上式恒等于1。更严格来说，如果有向图是强连通的（任意两个节点之间至少存在一条路径可达），R的初始化加和为1，则可证明R是收敛的。实际上，Web网页并不是强连通的图，存在以下两种情况导致PageRank计算失败：
1、DeadEnds，有节点不存在外链。这会导致什么问题呢？我们举个例子：
D节点不存在任何外链，如果我们进行迭代计算，由于上面的性质可得：
可以看到，新得到的R的求和是不断减小的，这个过程如果一直不断迭代下去，R全部都会变成0，使得计算失效。
2、Spider traps：有些节点只存在指向自己的外链，这又会导致什么问题呢？同样举个例：
节点D只存在指向自己的外链，首先
符合R永远是加和为1的，但是注意
可以看到D的排名R4永远比上一轮大，因此计算下去会快速的发现最后D的R值为1，其他节点都为0。
在实际应用中，为了有效避免上述两个问题，会使用到一个小技巧，就是假设每个节点都有一个假想的外链指向其它任一节点，这样整个图就变成了一个强连通图了。当然，为了尽量不影响最终计算的PageRank值，节点通过假想外链传递的PageRank值会乘一个权重因子β，β一般取0.2或者更小。因此，实际中PageRank的更新公式变成了：
如果按照这个更新公式下去，每个页面都会得到一个合理的排名值。
关于其他的算法，我们会在下篇中继续介绍。
相关阅读：
《Graph Learning》| 第一章：缤纷的图世界
《浅析图卷积神经网络》
关注微信公众号geetest_jy 获取更多关于图学习的资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b51ccc7998863a7161dea53dcb8ee351/" rel="bookmark">
			利用python计算个人所得税
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.算出应纳税所得额 应纳税所得额=扣除三险一金后月收入-扣除标准，
且三险一金缴纳 的基准工资上限为7662 ；超过，就按照7662缴纳。
salary = int(input('工资')) if salary&gt;=7662: money = salary - 7662 * 0.225 else: money = salary * 0.775 nashuie=money - 3500 2.计算个人所得税
因为有纳税所得额可能小于3500要先判断纳税所得额是否为负数；
若为正数根据公式：应纳个人所得税税额=全月应纳税所得额×适用税率-速算扣除数个税。
计算出个人所得税。
if nashuie&lt;=0: print('null') else: if nashuie &lt;= 1500: print(nashuie * 0.03) elif nashuie &lt;= 4500: print(nashuie * 0.1 - 105) elif nashuie &lt;= 9000: print(nashuie * 0.2 - 555) elif nashuie &lt;= 35000: print(nashuie * 0.25 -1005) elif nashuie &lt;= 55000: print(nashuie * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b51ccc7998863a7161dea53dcb8ee351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c93c6bff488237f6f6deb602f2c8805/" rel="bookmark">
			利用三局两胜制石头剪刀布练习python条件判断与循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以字符串'石头','剪刀','布'的方式计算出胜负，需把每种方法一一列举，此方法较为繁琐，因此我们用012分别代替石头剪刀布
我们需要分别将用户，电脑赢的次数，平局的计数，以便于我们通过他们计算出胜负平局。并且我们需要一个随机函数来模拟电脑所出的方式。因此可以先写出如下代码：
from random import randint user_win = 0 computer_win = 0 deuce = 0 我们需要进行三局游戏，所以需要通过for循环实现，并且要把游戏代码放入循环体中，游戏的胜负可以通过用户与电脑的差值计算得出。
for index ,value in enumerate(range(3)): user_num = input('012') user_num = int(user_num) computer_num = randint(0,2) sum = user_num - computer_num if sum == -1 or sum == 2: print('第{}局玩家胜'.format(index + 1)) user_win += 1 elif sum == 0: print('第{}局平局'.format(index + 1)) deuce += 1 else: print('第{}局电脑胜'.format(index + 1)) computer_win += 1 print('--------------第{}局结束------------'.format(index + 1)) 此时可以通过玩家与电脑的获胜次数来判断胜负，但此方法需要执行三次循环之后才能计算出，因此要写在循环体外：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c93c6bff488237f6f6deb602f2c8805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd31817a92e2de37370fed22c297f4bf/" rel="bookmark">
			SpringBoot声明式事务的简单运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于事物的基本概念等这里就不介绍了。
Spring声明式事物的实现，有两种方式；第一种是配置xml，第二种是使用相关注解(这两种方式可详见《程序员成长笔记(一)》的相关章节)。SpringBoot中默认配置了第二种方式，所以，SpringBoot直接使用注解即可。下面介绍SpringBoot通过注解开启事物的使用。
SpringBoot使用事物的步骤： 第一步：在启动类上开启事物支持
提示：@EnableTransactionManagement注解其实在大多数情况下，不是必须的，因为SpringBoot在
TransactionAutoConfiguration类里为我们自动配置启用了@EnableTransactionManagement注
解。不过自动启用该注解有两个前提条件，分别是：
@ConditionalOnBean(PlatformTransactionManager.class)
和@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)，而一
般情况下，这两个条件都是满足的，所以一般的，我们在启动类上写不写
@EnableTransactionManagement都行。本人这里还是建议写出来。
第二步：在业务逻辑层接口的实现类中的相关方法上声明事物
给出Transactional 注解的常用属性表： 属性
说明
propagation
事务的传播行为，默认值为 REQUIRED。
isolation
事务的隔离度，默认值采用 DEFAULT
timeout
事务的超时时间，默认值为-1，不超时。
如果设置了超时时间(单位秒)，那么如果超过该时间限制了但事务还没有完成，则自动回滚事务。
read-only
指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。
rollbackFor
用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。{xxx1.class, xxx2.class,……}
noRollbackFor
抛出 no-rollback-for 指定的异常类型，不回滚事务。{xxx1.class, xxx2.class,……}
……
注意事项： service实现类(一般不建议在接口上)上添加@Transactional，可以将整个类纳入spring事务管理，在每个业务方法执行时都会开启一个事务，不过这些事务采用相同的管理方式。
Transactional 注解只能应用到 public 可见度的方法上。 如果应用在protected、private或者 package可见度的方法上，也不会报错，不过事务设置不会起作用。
默认情况下，Transactional 注解的事物所管理的方法中，如果方法抛出运行时异常或error，那么会进行事务回滚；如果方法抛出的是非运行时异常，那么不会回滚。
注：SQL异常属于检查异常（有的框架将SQL异常重写为了运行时异常），但是有时我们写SQL时，检查异常并
不会提示；而默认情况下，事物对检查异常不会作出回滚处理。
注：在很多时候，我们除了catch一般的异常或自定义异常外，我们还习惯于catch住Exception异常；然后再抛出
Exception异常。但是Exception异常属于非运行时异常(即：检查异常)，因为默认是运行时异常时事物才进
行回滚，那么这种情况下，是不会回滚的。我们可以在@Transacional注解中，通过
rollbackFor = {Exception.class} 来解决这个问题。即：设置当Exception异常或Exception的所有任意子
类异常时事物会进行回滚。
注：被catch处理了的异常，不会被事物作为判断依据；如果异常被catch 了，但是又在catch中抛出了新的异
常，那么事物会以这个新的异常作 为是否进行回滚的判断依据。
事务的传播机制(行为)： 事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。
即：在执行一个@Transactinal注解标注的方法时，开启了事务；当该方法还在执行中时，另一个人也触发了该方法；
那么此时怎么算事务呢，这时就可以通过事务的传播机制来指定处理方式。
在TransactionDefinition定义中包括了如下几个表示传播行为的常量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd31817a92e2de37370fed22c297f4bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa0c2bfdd5644db8a9d96ddb27411fe/" rel="bookmark">
			最新版WebStorm2018激活码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://idea.youbbs.org 亲测可用
7月9日晚，发现突然用不了了，但可以网上搜索了一波，通过破解补丁进行破解，点开下面链接即可查看，也非常简单
WebStorm 2018版本破解方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e1699a6d8213247e1d0c349d84ef41/" rel="bookmark">
			比赛 解题报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比赛 题目描述 有两个队伍A和B，每个队伍都有n个人。这两支队伍之间进行n场1对1比赛，每一场都是由A中的一个选手与B中的一个选手对抗。同一个人不会参加多场比赛，每个人的对手都是随机而等概率的。例如A队有A1和A2两个人，B队有B1和B2两个人，那么(A1 vs B1,A2 vs B2)和(A1 vs B2,A2 vs B1)的概率都是均等的50%。
每个选手都有一个非负的实力值。如果实力值为X和Y的选手对抗，那么实力值较强的选手所在的队伍将会获得(X-Y)^2的得分。
求A的得分减B的得分的期望值。
输入输出格式 输入格式： 第一行一个数n表示两队的人数为n。 第二行n个整数，第i个数A[i]表示队伍A的第i个人的实力值。 第三行n个整数，第i个数B[i]表示队伍B的第i个人的实力值。
输出格式： 输出仅包含一个实数表示A期望赢B多少分。答案保留到小数点后一位（注意精度）。
说明 对于30%的数据，n≤50。
对于100%的数据,n≤50000;A[i],B[i]≤50000。
昨天刚学期望今天就考了，喵喵喵
如果把\(b\)队看成位置，把\(a\)队的人往里面放，一共可以产生\(n!\)种情况。
则对任意的二元配对组\(A_i\)与\(B_j\)，它们产生的答案即为
\((A_i-B_i)*(n-1)!/n!\)，乘上的\((n-1)!\)即为它的出现次数
则总答案为
\((\sum_{i=1}^{n} \sum_{j=1,A[i]&gt;=B[j]}^{n} {(A[i]-B[j])}^2-\sum_{i=1}^{n} \sum_{j=1,A[i]&lt;B[j]}^{n} {(A[i]-B[j])}^2)/n\)
将A,B两个数组排序，递推统计即可。把完全平方公式拆开多维护一点信息即可。
注意精度问题，此题输入全为整数，所以最后再转double
#include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #define ld long long const int N=50010; int n,pos=0; ld a[N],b[N],s1=0,s2=0,ans=0,sum1=0,sum2=0; void init() { std::sort(a+1,a+1+n); std::sort(b+1,b+1+n); while(pos&lt;n&amp;&amp;a[1]&gt;=b[pos+1]) pos++; for(int i=1;i&lt;=pos;i++) { s1+=(a[1]-b[i])*(a[1]-b[i]); sum1+=b[i]; } for(int i=n;i&gt;pos;i--) { s2+=(b[i]-a[1])*(b[i]-a[1]); sum2+=b[i]; } ans+=s1-s2; } void work() { for(int i=2;i&lt;=n;i++) { int las=pos+1; while(pos&lt;n&amp;&amp;a[i]&gt;=b[pos+1]) pos++; for(int j=las;j&lt;=pos;j++) sum2-=b[j]; for(int j=las;j&lt;=pos;j++) { s1+=(a[i]-b[j])*(a[i]-b[j]); s2-=(b[j]-a[i-1])*(b[j]-a[i-1]); } s1+=(a[i]-a[i-1])*((las-1)*(a[i]+a[i-1])-2*sum1); s2+=(a[i]-a[i-1])*((n-pos)*(a[i]+a[i-1])-2*sum2); ans+=s1-s2; for(int j=las;j&lt;=pos;j++) sum1+=b[j]; } } int main() { //freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7e1699a6d8213247e1d0c349d84ef41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b2110910c1ebbb58c693b0be31ece7/" rel="bookmark">
			laravel使用中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又有一段时间没有学习了!迷茫，除了迷茫还是在迷茫！最近，公司接了一个laravel的项目，可惜没有phper，于是开始学习laravel，现在的情况就是还没学会走路就要开始跑了，所以遇到坑会摔得很痛！ 安装出现的问题 安装步骤(5.3.*)
composer global require "laravel/installer" composer create-project --prefer-dist laravel/laravel blog "5.3.*" 出现的问题
①无法安装composer依赖 报错: php.ini 缺少mbstring
laravel/framework v5.4.9 requires ext-mbstring * -&gt; the requested PHP extension mbstring is missing from your system. 解决: 放开注释extension=php_mbstring.dll
②php artisan ser能运行但页面报错 报错: The only supported ciphers are AES-128-CBC and AES-256-CBC
解决: 先运行这个命令
php artisan key:generate 再运行
php artisan config:clear ③同事安装php出现的问题:php.ini启用openssl时报错openssl.dll找不到 错误显示他的配置默认去C:/php/ext/下去找openssl.dll文件
解决: 他开的是虚拟机，修改extension_dir = "./" 路径为绝对路径
④本地运行时post请求报错 报错:
TokenMismatchException in VerifyCsrfToken.php line 68: in VerifyCsrfToken.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b2110910c1ebbb58c693b0be31ece7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df512a000b78cee6aeb5782a19113bc/" rel="bookmark">
			Redis分页排序业务详细实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司由于业务中需要将帖子,评论,视频等加入缓存，以前没怎么操作过缓存得分页，看了一下源码，这里主要用到redis两个数据类型：SortedSet（Zset）和hash两种数据类型，至于为什么选择这两个后面再说。
SortedSet（Zset）数据类型
SortedSet（Zset）是有序的集合类型，但是它和LinkedHashSet还不一样，LinkedHashSet维护的是插入时的顺序，而SortedSet维护的是元素之间大小关系的顺序（比如升序、降序等，是根据大小关系来维护顺序的)，简单就是说我们可以根据我们需求对其排序，有分页就肯定有排序所以这里我选择的用sortset。 这里主要用到该数据类型的Zrevrangebyscore和zadd两种类型，zadd负责向里面插入对应数据，Zrevrangebyscore负责分页。
hash数据类型
hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。
思路: 主要思路就是在数组中放入需要分页的key和排序的元素，在hash存放key所对应对象详细信息。
排序测试
第一步:向hash中插入数据对象。每一个对象都有一个uuid（为了模拟数据库表对应的主键），同时插入数据时候向SortedSet member属性插入对应对象的uuid和sort插入需要排序的字段（排序的一个属性，这里先用1234排序测试）
写个测试类测试一下
public static void main(String[] args) { //存数据 Jedis jedis = new Jedis("ip", "port", 10000); jedis.auth("123456"); jedis.select(9); for (int i = 0; i &lt; 10; i++) { String s = IdGenerator.generateId(); for (int j = 10 - i; j &gt; 0; j--) { System.out.println(j); //数组中存值 j:排序值，s:对应数组里key jedis.zadd("list", j, s); break; } Date date = new Date(); SolrBean solrBean = new SolrBean(); solrBean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df512a000b78cee6aeb5782a19113bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b49be539c574b4b179da03e09996203e/" rel="bookmark">
			Python查看当前版本支持包格式,cp27,cp35等.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开cmd输入python或者ipython 输入
import pip print(pip.pep425tags.get_supported()) 如下:
[('cp27', 'cp27m', 'win32'), ('cp27', 'none', 'win32'), ('py2', 'none', 'win32') , ('cp27', 'none', 'any'), ('cp2', 'none', 'any'), ('py27', 'none', 'any'), ('py 2', 'none', 'any'), ('py26', 'none', 'any'), ('py25', 'none', 'any'), ('py24', ' none', 'any'), ('py23', 'none', 'any'), ('py22', 'none', 'any'), ('py21', 'none' , 'any'), ('py20', 'none', 'any')] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b67a698eeebb012026512ec2462e156/" rel="bookmark">
			手把手教你用R处理常见的数据清洗问题（附步骤解析、R语言代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：James D. Miller;翻译：王雨桐;校对：万文菁
本文约5300字，建议阅读10+分钟。
本文将介绍数据清洗过程的主要步骤，并通过案例和代码演示如何利用R语言进行数据清洗。 R是进行运算、清洗、汇总及生成概率统计等数据处理的一个绝佳选择。此外，由于它独立于平台、短期内不会消失，所以生成的程序可以在任何地方运行。并且，它具备非常棒的辅助资源。
本文摘录自James D.Miller撰写的《数据科学统计学》（Statistics for Data Science）一书，该书由Packt Publishing出版。
R是一种易上手的语言和环境，它本身很灵活且专注于统计计算，因此成为运算、清洗、汇总及生成概率统计等数据处理的一个绝佳选择。
此外，以下是用R进行数据清洗的其他原因：
由于大量数据科学家都在使用R，所以它短时间内不会消失。
R独立于平台，因此可以在任意地方运行程序。
R有绝佳的辅助资源---Google一下，你就可以看到。
注：尽管作者将示例数据命名为“赌博数据”（Gamming Data），它只是用来演示代码的赌博数据。
离群点 对离群点最简单的解释是：离群点是和其余数据不匹配的数据点。按照惯例，任何过高、过低或者异常（基于项目背景）的数据都是离群点。作为数据清洗的一部分，数据科学家通常要识别出离群点并用通用的方法解决它：
删除离群点的值，甚至是离群点对应的实际变量。
转换变量值或变量本身。
让我们来看一下实际案例中如何用R识别并解决数据离群点。
老虎机在赌博界十分流行（老虎机的操作方法是把硬币投入到机器中，并拉动把手来决定回报）。如今大部分老虎机都电子化了，编程使它们的所有活动都能被持续追踪。在本文的案例中，赌场的投资者希望利用这些数据（以及各种补充数据）来调整盈利策略。换句话说，什么能让老虎机赚更多钱？是机器的主题还是类型？新机器比旧机器或老式机器更有利可图吗？机器的位置会产生怎样的影响？低面额的机器会赚更多钱吗？我们尝试用离群点来找到答案。
给定一个集合或赌博数据库（格式为逗号分隔或CSV文本文件），其中包括的数据如老虎机的位置、钱的面额、月份、日、年、机器类型、机器的年龄、促销、优惠券、天气和投币量（投币量是放入机器的钱币总额减去支付的数额）。
作为一个数据科学家，第一步要对数据进行综评（有时称为概述），此时我们要确定是否存在异常值，第二步是解决这些离群点。
步骤一 数据概述
R使这一步骤变得非常简单。尽管可以通过很多方式编程求解，但我们要尝试用最少的程序代码或脚本来解决问题。将CSV文件定义为R的变量（命名为MyFile）并将文件读入为数据框（命名为Mydata）：
MyFile&lt;-"C:/GammingData/SlotsResults.csv" MyData&lt;- read.csv(file=MyFile, header=TRUE, sep=",")
在统计学上，箱型图是一种简单的方式以得到统计数据集的分布、变异性和中心（或中位数）相关信息，所以我们将用箱型图来研究我们能否识别出中位数Coin-in以及能否找到离群点。为了达成这些，我们可以让R画出文件中每个老虎机的Coin-in值，绘制箱型图的函数如下：
boxplot(MyData[11],main='GammingData Review', ylab = "Coin-in")
注：Coin-in是文件中的第11列，所以直接将它作为boxplot函数的参数。此外还添加了一个可选择的参数（再次强调，本文已尽量保持代码的简洁度），以便在可视化图中添加标题。
执行前文的代码可以得到下图效果，包括中位数（中位数在箱型图中是中间横穿的线）以及四个离群点：
步骤2-处理离群点
现在我们发现数据中确实存在离群点，我们要解决这些点以保证它们不会对本研究产生负面影响。首先，我们知道Coin-in有负值是不合理的，因为机器输出的钱币一定不会比投入到机器中的硬币多。基于这个原则，我们可以从文件中删除Coin-in为负值的记录。此外，R可以帮助我们用subset生成一个新的数据框，新数据集中只有Coin-in中的非负值。
我们要将subset数据框命名为noNegs：
noNegs&lt;- subset(MyData, MyData[11]&gt;0)
接下来，我们要再一次画图以确定已经删除负值离群点:
boxplot(noNegs[11],main='GammingData Review', ylab = "Coin-in")
这就产生了新的箱型图，如下图中所示：
我们可以用同样的方法去除Coin-in中极端的正值（大于1500美元）得到另一个数据子集并再次画图：
noOutliers&lt;-subset(noNegs, noNegs[11]&lt;1500)
boxplot(noOutliers[11],main='GammingData Review', ylab = "Coin-in")
当你对数据进行不同的迭代后，建议你保存大部分版本的数据（如果不是最重要的）。你可以用write.csv这个R函数：
write.csv(noOutliers,file="C:/GammingData/MyData_lessOutliers.csv")
注：大部分数据科学家在整个项目中采取通用的命名规律。文件的名字应该尽可能清晰以便今后帮助你节省时间。此外，特别是在处理大量数据时，你需要注意内存空间的问题。
以上代码的输出结果如下：
领域知识
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b67a698eeebb012026512ec2462e156/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/274/">«</a>
	<span class="pagination__item pagination__item--current">275/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/276/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>