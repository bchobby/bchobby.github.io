<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adbcce2b2e741a5100b8373461a0533/" rel="bookmark">
			伺服电机原点位置在运行一段时间后发生偏移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发送1000个脉冲，驱动器只接收到了998个，基本是干扰问题 ，将驱动器与机壳隔离下监控接收的脉冲数，是否依然丢步。
我之前给一家客户做设备 大概是13年的时候 将近200台设备 一台接近40万 全部丢脉冲 我去了2天才找到原因 独家秘方 ：提示下找干扰源 处理干扰源
多从马达分辨率和电子齿轮相关的参数。加减速等去检查。信号线要做屏蔽外理，机柜单独接地试下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29cca79cb2663caa34fa58c501273249/" rel="bookmark">
			Docker 入门笔记 9  - Namespace 简介（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		User Namespace 用户命名空间（ CLONE_NEWUSER，在Linux 2.6.23中启动，并在Linux 3.8中完成 ）隔离了安全相关的标识符（identifiers）和属性（attributes），包括用户ID、用户组ID、root目录、key（指密钥）以及特殊权限。。
说得通俗一点，一个普通用户的进程通过clone()创建的新进程在新user namespace中可以拥有不同的用户和用户组。这里最有趣的情况是，一个进程可以在用户名空间之外拥有普通的非特权用户ID，同时在名字空间内具有0的用户ID。这意味着该进程对用户命名空间内的操作具有完全的root权限，但是对于命名空间之外的操作没有特权。
User namespace是目前的六个namespace中最后一个支持的，并且直到Linux内核3.8版本的时候还未完全实现（还有部分文件系统不支持）。因为user namespace实际上并不算完全成熟，很多发行版担心安全问题，在编译内核的时候并未开启USER_NS。实际上目前Docker也还不支持user namespace，但是预留了相应接口，相信在不久后就会支持这一特性。所以在进行接下来的代码实验时，请确保你系统的Linux内核版本高于3.8并且内核编译时开启了USER_NS 。
从Linux 3.8开始，未经授权的进程可以创建用户名空间，这为应用程序开辟了一系列有趣的新可能性：因为另外一个没有特权的进程可以在用户名空间内保存根特权，所以非特权应用程序可以访问之前只属于root用户的功能。 Linux 如何处理权限 进一步讨论User Namespace之前，我们先简单了解一下Linux 的权限处理
文件权限 谈到权限问题，首先想到的是文件的权限。Linux一个文件的信息是保存在文件的“inode”数据结构中的。inode里面的第一组数据项叫模(mode)
file mode +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |o o 0 0 0 0|0 0 0|0 0 0|0 0 0|0 0 0| | | | | | | | | | |-- rwx for other user | | | |-- rwx for group | | |-- rwx for user | |--suid, sgid, sticky bit |--type:reguar(-),dir(d),char(c),block(b),pipe(p),link(l),socket(s) 通常在UNIX下可以用ls -l 命令来看到文件权限。 用ls命令所得到的表示法的格式是类似这样的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29cca79cb2663caa34fa58c501273249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316ce453a397e094d32f14e7448beece/" rel="bookmark">
			myslq删除指定行后的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		delete from table where id&gt;10; 我这里是id号大于10 ，大家可以扩展到大于10或小于100等，自己发挥想象吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76be09aff3f24f2206718d30977c5b4b/" rel="bookmark">
			38、Selenium 之 WebDriverWait
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前有篇文章介绍过Selenium的等待知识，可惜当时水平有限，只介绍了sleep和implicitly_wait的用法。今天还是补充一下WebDriverWait的知识吧。
一、webdrivewait 示例代码
from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import time driver = webdriver.Chrome() driver.get("http://www.baidu.com/") locator = (By.ID,"kw") try: ele = WebDriverWait(driver,10).until(EC.presence_of_element_located(locator)) driver.find_element_by_id("kw").send_keys('abc') time.sleep(1) #为了看效果 except: print("ele can't find") finally: driver.quit()接下来一点点分析下这个语句 WebDriverWait(driver,10).until(EC.presence_of_element_located(locator)) （1）WebDriverWait 方法
driver: 传入WebDriver实例，即我们上例中的driver timeout: 超时时间，等待的最长时间（同时要考虑隐性等待时间） poll_frequency: 调用until或until_not中的方法的间隔时间，默认是0.5秒 ignored_exceptions: 忽略的异常，如果在调用until或until_not的过程中抛出这个元组中的异常， 则不中断代码，继续等待，如果抛出的是这个元组外的异常，则中断代码，抛出异常。默认只有NoSuchElementException。 （2）WebDriverWait 方法后面有两种等待方式
until
method: 在等待期间，每隔一段时间（__init__中的poll_frequency）调用这个传入的方法，直到返回值不是False message: 如果超时，抛出TimeoutException，将message传入异常 until_not 与until相反，until是当某元素出现或什么条件成立则继续执行， until_not是当某元素消失或什么条件不成立则继续执行，参数也相同，不再赘述。 看了以上内容基本上很清楚了，调用方法如下：
WebDriverWait(driver, 超时时长, 调用频率, 忽略异常).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76be09aff3f24f2206718d30977c5b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d235bb60ea57ee13ca8812834c494bf6/" rel="bookmark">
			Error: No PostCSS Config found in... 报错 踩坑记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目在本地运行不报错，上传到 GitHub 之后，再 clone 到本地，执行：
npm install 安装完成之后再执行：
npm run dev 这时报错 Error: No PostCSS Config found in... 本以为是 GitHub 上传的问题，后开又试了两回，发现问题依然存在，于是就开始网上寻找办法。
解决方案 在项目根目录新建postcss.config.js文件，并对postcss进行配置：
module.exports = { plugins: { 'autoprefixer': {browsers: 'last 5 version'} } } 好了 试试
npm run dev 我靠 果然好了 项目在本地运行时本来不报错的，但是为什么上传到 GitHub 之后，再 clone 下来，再运行就得单独写一个 postcss.config.js 的文件并配置一下呢？
在npm上查到的postcss配置在webpack.config.js，
postcss.config.js是针对webpack3.0做的特殊处理
转载于:https://www.cnblogs.com/sichaoyun/p/8243273.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06912016073be1f06e087ef8125241e3/" rel="bookmark">
			unity 制作拼图游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity中material.mainTextureOffset和material.mainTextureScale的作用和用法
mainTextureOffset和mainTextureScale是Material类中的两个方法
mainTextureOffset指的是主纹理偏移
mainTextureScale指的是主纹理缩放
默认一个material的mainTextureOffset是0,0，mainTextureScale是1,1
表示原图正常显示，没有缩放，如下图
当我们改变mainTextureScale的值时纹理只会显示一部分，其范围是[0,1];
如我们将mainTextureScale.x设置为0.5时，可以看到纹理只显示u方向的50%
同理，我们将mainTextureScale.y设置为0.5时，可以看到纹理只显示v方向的50%
mainTextureOffset属性表示纹理的起始偏移，为0时没有偏移，mainTextureOffset.x指u方向的偏移量，mainTextureOffset.y指v方向的偏移量。其范围也是[0,1]。这里要注意：偏移的起点在图像的左下角
我们设置mainTextureOffset.x为0.2，如下图：
可以看到纹理向左偏移了20%
我们设置mainTextureOffset.y为0.2，如下图：
可以看到纹理向下偏移了20%
应用这两个属性，我们可以只截取图片的一部分来显示，如：
mainTextureOffset = new Vector2(0.5, 0.5)；
mainTextureScale= new Vector2(0.5, 0.5)；
将只显示原图的右上角1/4区域，如下图：
有了对以上两个属性的了解，我们可以来制作一个简单的拼图游戏
思路：
1.将一张图片切分为raw*volumn的raw*volumn张碎片
2.每一张碎片只显示图片的一部分
3.将它们按一个顺序和位置排列，使其看起来像一张完整的图片
玩法：
点击Start按钮后，开始游戏。选中碎片并将其拖放在正确的位置上，如放置正确则不可再被拖动。直到所有碎片放置正确。
点击Next Texture按钮可切换背景和碎片显示的图片
制作流程：
新建一个游戏场景Test,设置摄像机属性如下(采用正交摄像机(2D)将其标签设置MainCamera)：
创建两个plane，其中一个改名为Background并为其选择一个材质；另一个plane也选择一个材质要和前一个不同，选择shader为Unlit/Transparent (自发光)，将其设为不可见。创建一个空对象，起名为Body，如下图：
创建一个c#脚本main.cs,绑定在Body对象下。Inspector设置如下：
main.cs脚本如下：
using UnityEngine;
using System.Collections;
public class main : MonoBehaviour {
public GameObject _plane; //用来实例碎片的对象
public GameObject _planeParent; //碎片对象所要绑定的父节点
public GameObject _background; //显示暗色的背景图
public Texture2D[] _texAll; //用来更换的纹理
public Vector3[] _RandomPos; //开始时, 碎片随机分布的位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06912016073be1f06e087ef8125241e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81d9c959c45084a84eeb90394bd74d6/" rel="bookmark">
			python最简单的爬取图片并保存本地指定路径！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚学python不久，所以先记录一个爬取图片的方式，并保存本地指定路径下。当然不一定会是最简单的方式，就是习惯这么起标题。但，肯定是我使用起来感觉最简单的。 需要单独安装的第三方模块有三个：
pip install requests pip intsall BeautifulSoup4 pip install pillow 其它模块都是内建模块，可以直接使用。
具体代码如下：
import requests from bs4 import BeautifulSoup from PIL import Image import os from io import BytesIO import time url = "http://www.yestone.com/gallery/1501754333627" headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36"} r = requests.get(url, headers=headers) soup = BeautifulSoup(r.content, 'html.parser') items = soup.find_all('img', class_='img-responsive') folder_path = './photo' if os.path.exists(folder_path) == False: os.makedirs(folder_path) for index, item in enumerate(items): if item: html = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81d9c959c45084a84eeb90394bd74d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e89954abaa393ac141182527fb1ccc/" rel="bookmark">
			基于模糊集的图像增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Github个人博客：https://joeyos.github.io
基于模糊集的图像增强主要有以下三个步骤：图像模糊特征提取、隶属函数值的修正和模糊域反变换。
x=imread('lena.jpg'); x=rgb2gray(x); [M,N]=size(x); x1=double(x); % 基本参数 Fd=0.8; FD=-1*Fd; % Fe=128; Fe=128; Xmax=255; % 模糊特征平面 for i=1:M for j=1:N P(i,j)=(1+(Xmax-x1(i,j))/Fe)^FD; end end % 模糊增强 times=1; for k=1:times for i=1:M for j=1:N if P(i,j) &lt;= 0.5000 P1(i,j)=2*P(i,j)^2; else P1(i,j)=1-2*(1-P(i,j))^2; end end end P=P1; end % 反模糊化 for i=1:M for j=1:N I(i,j)=Xmax-Fe*((1/P(i,j))^(1/Fd)-1); end end X=uint8(I); figure,imshow(x); figure,imshow(X); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b392c07c8d789aa16072d8a8276b70/" rel="bookmark">
			Longest Palindromic Substring 最长回文串 python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 题目：
输入字符串s,输出该字符串中包含的最长回文串。回文串，指的是正着看和倒着看都一样的字符串，例如’abdba’。
二、几种解法
1、 Brute-force解法
(1)、思路：
第一步，通过两层for循环得到输入字符串s的所有可能子串。
第二步，逐个判断子串是否为回文串。若当前子串为回文串且长度大于之前得到的回文串，更新当前最长回文串。
(2)、代码
''' Brute-force解法 ''' class Solution1(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ lens=len(s) if lens&lt;2: return s maxlen=0 start=0 for i in range(lens): for j in range(i+1,lens): begin=i end=j while begin&lt;end: if s[begin]!=s[end]: break begin+=1 end-=1 if begin&gt;=end and j-i&gt;maxlen: maxlen=j-i+1 start=i if maxlen&gt;0: return s[start:maxlen] return None (3)、复杂度分析:
时间复杂度：
得到字符串所有子串的时间复杂度为O(n^2),判断子串是否为回文串的时间复杂度为O(n),二者相乘得到暴力解法的时间复杂度为O(n^3).
空间复杂度:
该方法没有使用额外空间,空间复杂度为O(n)
2、 动态规划方法
(1)、思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b392c07c8d789aa16072d8a8276b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a8905d90943ff984cefc0d27f46c05/" rel="bookmark">
			Dev GridControl详解（一）控件层次和数据绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来想写GridControl的文章，发现网上已经有系统的讲解了，直接粘过来，C博找不到转载按钮我也是醉了我。
感谢nanchuan以及nanchuan文章的原作者。我会在你们的基础上随时补充。
以下【转载】：
使用时拖拽过来，如下所示即使拖拽过来原封不动的样子：
绑定数据源 在程序中写入构建一个表格的代码：
private DataTable InitDt() { DataTable dt = new DataTable("个人简历"); dt.Columns.Add("id",typeof(int)); dt.Columns.Add("name", typeof(string)); dt.Columns.Add("sex", typeof(int)); dt.Columns.Add("address", typeof(string)); dt.Columns.Add("aihao", typeof(string)); dt.Columns.Add("photo", typeof(string)); dt.Rows.Add(new object[] { 1, "张三", 1, "东大街6号", "看书", "" }); dt.Rows.Add(new object[] { 1, "王五", 0, "西大街2号", "上网,游戏", "" }); dt.Rows.Add(new object[] { 1, "李四", 1, "南大街3号", "上网,逛街", "" }); dt.Rows.Add(new object[] { 1, "钱八", 0, "北大街5号", "上网,逛街,看书,游戏", "" }); dt.Rows.Add(new object[] { 1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a8905d90943ff984cefc0d27f46c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6ebac1f3183da30e2b0f976068ecbc/" rel="bookmark">
			LeetCode 5. Longest Palindromic Substring 最长回文子串 Python 四种解法(Manacher 动态规划)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Longest Palindromic Substring 最长回文子串 学习笔记 1. Brute method 第一种方法：直接循环求解， o(n2) class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ l = len(s) max_length = 0 palindromic = '' if len(s) == 1: return s for i in range(l): for j in range(i + 1, l): is_palindromic = True for k in range(i, int((i + j) / 2) + 1): if s[k] != s[j - k + i]: is_palindromic = False break if is_palindromic and (j - i + 1) &gt; max_length: max_length = j - i + 1 palindromic = s[i:j + 1] if palindromic == '': palindromic = s[0] return palindromic 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6ebac1f3183da30e2b0f976068ecbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a06c55d3db96228f251153465e6462/" rel="bookmark">
			ansible远程切换用户执行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ansible test -l 10.0.10.1 -e "ansible_become_user=www" -m shell -a "/data/publish/publish.sh /" 转载于:https://www.cnblogs.com/mikeluwen/p/8213476.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1092a89d93f20ee4a0b7963f871673b/" rel="bookmark">
			一次完整的网络请求过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从地址栏输入http://www.gaxis.cn这个URL之后，直到我的个人主页加载完成，中间到底发生了什么呢？ 大概经历了以下过程： 1. 分析域名（gaxis） 2. TCP三次握手（嘿，我能连你吗？/完全OjbK啊。/那我连了啊。） 3. 建立TCP连接 4. 浏览器发起HTTP请求 5. 服务器响应请求（哇兄弟你找我了，我收拾一下给你的数据和应答码——这里可以展开讲服务器如何响应） 6. 浏览器解析html代码并请求html中的js/css/图片等资源 7. 浏览器进行页面渲染呈现给用户
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a25c65ff2678940880b6e8ed64b5e2/" rel="bookmark">
			解决Laravel 5.5 header[&#39;X-CSRF-TOKEN&#39;,&#39;Authorization&#39;]请求问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、解决 "CSRF-TOKEN"，需要在主模板里更改：
In header
&lt;meta name="csrf-token" content="{{ csrf_token() }}" /&gt; 2、解决 "X-CSRF-TOKEN"，需要在主模板里更改：In header
&lt;meta name="csrf-token" content="{{ csrf_token() }}" /&gt; In script（Ajax）
&lt;script type="text/javascript"&gt; $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content') } }); &lt;/script&gt; In vue2.5window.axios = require('axios');window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';let token = document.head.querySelector('meta[name="csrf-token"]');if (token) {window.axios.defaults.headers.common['X-CSRF-TOKEN'] = token.content;} else {console.error('CSRF token not found: https://laravel.com/docs/csrf#csrf-x-csrf-token');}3、如果使用Vue2.5 Axios api Token，则需要如下更改（记得在数据库中设置token值）：
In header
&lt;meta name="api-token" content="{{ Auth::check() ? 'Bearer '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a25c65ff2678940880b6e8ed64b5e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da2c319cf4505e251067322d05213eb1/" rel="bookmark">
			Eclipse中 sysout 按alt&#43;/不出System.out.println();
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要重新设置快捷键
按快捷键ctrl+shirt+L查看发现Word Completion在用这个快捷键，Content Assist 这个设置为alt+/
1、myeclpse–&gt;Preferences–&gt;General–&gt;Keys 删掉word completion的快捷键设置alt+/ 2、把Content Assist的快捷键由ctrl+space改成alt+/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/937659a339cab31c4523c46dbe33e574/" rel="bookmark">
			matlab之.*点乘和*乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、a*b就是矩阵乘法
2、a.*b就是a,b的对应元素相乘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c1d031f3cf9a132e80735c3f3950fe/" rel="bookmark">
			append、appendTo、appendChild、prepend
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		append、appendTo、appendChild、在父节点中的最后一个子节点后面插入。
append和appendTo区别是append的前面是对象，后面是要插入的节点对象。
比如append var wrap=document.getElementById('wrap'); wrap.append('&lt;p&gt;111111&lt;/p&gt;');
而appendTo $('&lt;p&gt;1111&lt;/p&gt;').appendTo($('wrap'));
appendChild 是JS方法，和append一样，插入到父节点中最后一个子节点之后。
上面的 都是在插入父元素中的子节点最后。
prepend、prependTo 上面两个的 都是在插入父元素中的子节点最前面。
after 、insertafter
上面两个的 都是在插入当前元素之后。
before 、insertbefore
上面两个的 都是在插入当前元素之前。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf8bf40efac9c1cfbe4889d9100d99e/" rel="bookmark">
			Matlab之isfield函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、函数功能：判断输入是否是结构体数组的成员
2、调用格式
f = isfield (s，'fieldname')检查结构体S是否包含由fieldname指定域，如果包含，返回逻辑1；如果不包含fieldname域或者S不是结构体类型的，返回逻辑0.
tf = isfield(S, C) 其中C是一个包含多个字符串的cell array，isfield判定由这些字符串表示的域是否是struct的域。返回值是个逻辑型数组。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38d42c4bf2efd87f1409e69933e392e/" rel="bookmark">
			思沃大讲堂总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思沃大讲堂第一课总结 第一课主要从文化，敏捷方法，演讲技巧和反馈四个方面进行讲解，以下我将对这四个方面的所学所思进行总结。
文化 做正确的事情：自我驱动去做一些对公司及个人成长有益的事情。态度、能力、诚信：怀揣一颗真诚谦逊的心去工作，并从多个方面去提升自己的能力。团结互助：在自己成长的同时，也积极帮助周围小伙伴，乐于分享。公平公正：通过技术手段为慈善提供助力，贡献一份力量。全球化：全球15个管家，42间办公室，人才的流动，提供了一个全球化的视野。有趣：举办各种主题活动，给生活增添乐趣，工作更高效。 以小组为单位展现一个文化主题 敏捷方法 今年6月份有幸参加了TW的open day活动，进行了为期两天的结对编程活动，了解到TW在软件开发中非常注重敏捷开发和TDD。
随着软件开发的持续发展，瀑布流、螺旋模型、快速迭代等各种各样的软件开发流程如雨后春笋般涌现。虽然不断变化和完善，但互联网的加速发展让传统方法显得笨重，难以快速适应变化。于是，敏捷开发应运而生。
敏捷主要是为了提高项目开发的效率，减少多次打补丁。敏捷开发的宣言如下：
在我们实际做敏捷转型的过程中，左右两项通常情况下也是共存的，不过我们更重视左项。
其中，敏捷的含义是迅速响应需求，快速反馈结果。敏捷方法包括极限编程(XP)和 Scrum，它们的主要区别包括：
区别一： 迭代长度的不同 XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周.
区别二: 在迭代中, 是否允许修改需求
XP在一个迭代中，如果一个User Story(用户素材, 也就是一个需求)还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队受到干扰
区别三: 在迭代中，User Story是否严格按照优先级别来实现 XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做，Scrum这样处理的理由是： 如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10.
区别之四:软件的实施过程中，是否采用严格的工程方法，保证进度或者质量
这四个区别显见的是： Scrum非常突出Self-Orgnization, XP注重强有力的工程实践约束。
举个通俗理解Scrum的例子，Scrum:指的是英式橄榄球中一股脑争球这一战术或行为。
scrum 即为这样一种方式，大家一拥而上，团队是球员，球是产品目标，人员环环相扣，围绕着产品目标进行工作。这里面多少有点“统筹法”的影子，人员深入协作以达到最优化效果。
演讲技巧 从以下几个方面进行有效的表达
1.演讲要抑扬顿挫，有感染力，与听众互动。观察听众的反应，从而了解听众的接受程度，适当调节自己的演讲节奏。
2.根据听众的不同准备不同的内容，比如听众为客户，可介绍项目进行过程中克服的困难，所做的努力。若为其他项目组的技术人员，可介绍新技术实践过程中所踩的坑。
3.PPT尽可能简洁，只显示核心内容。关于ppt某一页上所呈现的东西只是一个提示的作用，更多信息需要我们讲给听众。
4.保持微笑，与听众有眼神交流。通过肢体语言拉近与听众的距离。
5.万事开头难。当我们需要做一个重要演讲时，通过蹦跳，深呼吸等方式来避免紧张。在演讲过程中，避免一些无意识的小动作。
6.讲故事。不要一味的讲一些理论上的东西，将需要表达的观点与工作，生活中的例子相结合，更通俗易懂，听众也更印象深刻。
7.通过声音传达感情。平平淡淡的叙述很容易使听众瞌睡，我们可以通过调节自己声音的高低起伏来唤醒听众的热情。
8.使用一些肢体语言。一些得体的肢体表达可使听众更容易理解我们所要表达的意思
9.放松，深呼吸，轻松的享受整个过程。 当我们演讲一会儿后，整个人的非常专注的投入到自己的演讲中，刚开始的紧张也消失不见，整个人更加轻松自如。
10.提前准备。充分的准备是演讲的关键，我们需要多查资料，多演练几遍，及时改正自我的不足，最终有一个完美的呈现。
如何进行有效的演讲 反馈 反馈是TW文化中最有特色的一个方面，通过自由平等地向周围人提意见，可促使大家共同快速进步。俗话说：“当局者迷，旁观者清”。结对编程就是反馈文化的一个投影，一个coder，一个观察者，彼此之间互相指出问题，共同高效地完成一个任务。
反馈分为有效的反馈和无效的反馈。无效的反馈是指对接受反馈的人来说无意义的反馈。我们应尽可能给出有意义的反馈，并且在私密的环境下，一次给出一到两条建议即可。根据三圈原理，行为和人的层面的反馈可以提，生理和信仰方面的反馈不能提。
在session结束后的retro环节，大家均对本次思沃大讲堂第一课的各个环节给出了自己的反馈，包括好的反馈，不好的反馈，建议三大类，然后对所有的反馈分门别类，并在solution那一栏给出对应的解决方法，并找到对应的执行人，确保它发生。这种做法非常高效，可以将它应用在我们的生活工作中，提高我们的行动力。
大家对第一期思沃大讲堂的反馈 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98451f5eafc33f64864ed5a2a0fe67b9/" rel="bookmark">
			Matlab之options的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Matlab提供options向量来对优化函数进行参数设置，有18个元素
2、介绍该18个元素
Options(1)=0(默认值) 功能:控制显示,优化过程中控制输出信息。0表示不显示; 1表示显示; -1表隐藏信息。 Options(2)=1e-4 功能:控制x的精度,自变量x的最低精度终止条件。当所有终止条件都满足的时候,优化终止。
Options(3)=1e-4 功能:控制 f 精度,目标函数f的最低精度终止条件。当所有终止条件都满足的时候,优化终止。
options(4)=1e-7 功能:约束g的最低精度终止判别条件。当所有的终止条件都满足的时候,优化终止。
options(5)=0 功能:选择主要优化算法。
options(6)=0 功能:SD算法控制。选择搜索方向算法。
options(7)=0 功能:搜索算法控制。选择线性搜索算法。 options(8)=N/A 功能:函数值,算法结束时极值点的函数值,attgoal和minimax而言,它包含一个到达因子。
options(9)=0 功能:梯度检查控制.当值为1时,在最初的几个迭代周期,梯度将与有限差分计算的结果比较,此时,梯度函数必须存在。 options(10)=N/A 功能:函数计算计数。
options(11)=N/A 功能:梯度计算计数。 options(12)=N/A 功能:限定计数,限定函数梯度计算或差分梯度计算的次数。
options(13)=0 功能:等式约束个数,等式约束必须放在g的前几个元素中。
options(14)=0*n 功能:最大迭代次数,该值缺省时被置为n的100倍,n为自变量x的个数,在fmins中,缺省为n的200倍,在fminu中,为500n。 options(15)=0 功能:目标数,尽可能接近goals的目标数,由函数attgoal使用.
options(16)=1e-8 功能:最小摄动控制.有限差分梯度计算中的最小变化.对函数的梯度计算而言, 实际使用的摄动将自动调整以提高精度,它将在最小摄动和最大摄动之间变化。 options(17)=0,1 有限差分梯度计算中变量的最大变化。
options(18)=N/A 功能:步长控制,在第一步迭代被赋值为1或更小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0b13c7d071a8272242c4e7525d700d/" rel="bookmark">
			elasticsearch资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es先行版 https://github.com/medcl/elasticsearch-rtf 启动不了，但可以学习学习 直接下的6.1.1版本，自己配置。
head插件： http://www.cnblogs.com/xuxy03/p/6039999.html
ik分词器： https://github.com/Sevenkili/elasticsearch-analysis-ik
学习资料： http://www.cnblogs.com/aaanthony/p/7380643.html
使用Elasticsearch组件实现对word、pdf、excel、ppt等的文本内容进行全文检索。http://kms.h3c.com/View.aspx?id=51556
目前mapper-attachment插件已经被ingest-attachment所代替了，具体可见文档：https://www.elastic.co/guide/en/elasticsearch/plugins/5.6/mapper-attachments.html https://www.elastic.co/guide/en/elasticsearch/plugins/6.1/ingest-attachment.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26cf9c469e52dcff2f79576846d5ad0/" rel="bookmark">
			spring boot 剔除和替换默认jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 剔除或替换springboot 默认jar，可以下如下方式： 思路是，先根据maven pom.xml 的effective pom 知道所要剔除的jar在什么依赖下，然后使用 exclusions 剔除。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8a93d5a77c2be5db37743fe9847fbe/" rel="bookmark">
			Centos7开机启动图形界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用下面命令查看查看是哪个模式
# systemctl get-default 开机启动图形界面 # systemctl set-default graphical.target（图形界面模式） # reboot（重启系统） 如果想转回开机启动字符界面模式 # systemctl set-default multi-user.target（字符界面模式） # reboot（重启系统） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fbbaa3f207bec2698fd15ff21d7bc3/" rel="bookmark">
			CSS实现隐藏滚动条同时又可以滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动端页面为了更接近原生的体验，是否可以隐藏滚动条，同时又保证页面可以滚动？
使用 overflow:hidden 隐藏滚动条，但存在的问题是：页面或元素失去了滚动的特性。
由于只需要兼容移动浏览器（Chrome 和 Safari），于是想到了自定义滚动条的伪对象选择器
::-webkit-scrollbar。
关于这个选择器的介绍可以参考：
Styling Scrollbars
Custom Scrollbars in WebKit
应用如下 CSS 可以隐藏滚动条：
.element::-webkit-scrollbar {display:none} 如果要兼容 PC 其他浏览器（IE、Firefox 等），可以在容器外面再嵌套一层 overflow:hidden 内部内容再限制尺寸和外部嵌套层一样，就变相隐藏了。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSS实现隐藏滚动条同时又可以滚动&lt;/title&gt; &lt;style type="text/css"&gt; body{margin: 0;background: #ddd;} .header{width:100%;height: 100px;overflow-x:scroll;overflow-y:hidden;} .content{height: 100px;width: 5000px;background: linear-gradient(to right, green , blue);} .header::-webkit-scrollbar {display:none} .outer-container {width: 500px; height: 700px;position: relative;overflow: hidden;} .inner-container {height: 700px;position: absolute; left: 0;overflow-x: hidden;overflow-y: scroll;} .inner-container::-webkit-scrollbar {display: none;} .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27fbbaa3f207bec2698fd15ff21d7bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7259a2e5ff2608d2fc7c70fc9d854cf/" rel="bookmark">
			C语言之左移和右移运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、左移运算符
格式：a&lt;&lt;b
将a这个数的各二进制位左移b位，要求b必须是非负整数，移动过程中，右边空出的位用0填补，高位左移溢出则舍弃该高位。
举例来看：
a=5,二进制位：0000 0000 0000 0000 0000 0000 0000 0101
a&lt;&lt;3后结果为：0000 0000 0000 0000 0000 0000 0010 1000
即，右边空出来的三位补0，左边的0都舍弃，左右两边的三个0没有关系。
2、右移运算符
格式：a&gt;&gt;b
将a这个数的各二进制位右移b位，要求b必须是非负整数，移到右端的低位被舍弃。其中，①对于无符号数，高位补0;②对于有符号数，如果采用算术移位，则空出部分用符号位填补，如果采用逻辑移位，则用0填补。
举例来看：采用算数移位
a=-5,其二进制位：1111 1111 1111 1111 1111 1111 1111 1011
a&gt;&gt;3后的结果为：1111 1111 1111 1111 1111 1111 1111 1111
即，-5为负数，它的符号位为1，因此左边填补三个符号位1，右边011依次被移出而舍弃。
3、注意，C语言中没有无符号右移 (&gt;&gt;&gt;)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96743132a3745cd30f4d5a16a633728/" rel="bookmark">
			three.js 06-03 之 ExtrudeGeometry 高级几何体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇介绍 three.js 中的 ExtrudeGeometry 拉伸几何体。它是从一个二维图形创建出一个三维图形。譬如，我们可以先通过 THREE.Shap 对象，先创建一个二维的图形，然后通过 ExtrudeGeometry 将它拉伸为一个三维图形。也可以先通过 THREE.PlaneGeometry 对象创建一个二维平面，然后再利用 ExtrudeGeometry 进行拉伸。关于 ExtrudeGeometry 的几个常用属性，如下表所示：
属性描述amount（数量）可选。此属性定义图形可以拉多高。默认值是 100bevelThinkness（斜角厚度）可选。此属性定义图形斜角的厚度。斜角是指前后面和拉伸体之间的倒角。默认值是 6bevelSize（斜角尺寸）可选。此属性定义图形斜角的高度。默认值是 bevelThickness - 2bevelSegments（斜角分段数）可选。此属性定义图形斜角的分段数。默认值是 3bevelEnabled（是否启用斜角）可选。此属性定义图形是否启用斜角。默认值是 truecurveSegments（曲线分段数）可选。此属性定义图形拉伸时曲线分成多少份。默认值是 12steps（拉伸体段数）可选。此属性定义图形拉伸体被分成多少段extrudePath（拉伸路径）可选。此属性定义图形沿着什么路径拉伸。如果未指定，默认就会沿着 z 轴拉伸frames可选。此属性定义一种沿着 extrudePath 路径的每一步包含有 tangents, normals, binormals 数组的对象UVGenerator（UV生成器）可选。此属性定义一种提供UV生成器功能的对象 光看这些属性似乎不太好理解，下面我们给出一个具体示例以便帮助读者进行理解，代码如下所示： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;示例 06.03 - ExtrudeGeometry&lt;/title&gt; &lt;script src="../build/three.js"&gt;&lt;/script&gt; &lt;script src="../build/js/controls/OrbitControls.js"&gt;&lt;/script&gt; &lt;script src="../build/js/libs/stats.min.js"&gt;&lt;/script&gt; &lt;script src="../build/js/libs/dat.gui.min.js"&gt;&lt;/script&gt; &lt;script src="../jquery/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;style&gt; body { /* 设置 margin 为 0，并且 overflow 为 hidden，来完成页面样式 */ margin: 0; overflow: hidden; } /* 统计对象的样式 */ #Stats-output { position: absolute; left: 0px; top: 0px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f96743132a3745cd30f4d5a16a633728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ddc5ed892c701b4e5b81065f3347d3/" rel="bookmark">
			图文描述VS2015&#43;Qt5.9.3使用QtChart的详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关QtChart的介绍在这就不详谈了，想要具体了解的百度就可以，官网和网站大多数都是介绍如何在QtCreator中使用QtChart，而本文主要介绍如何在vs中使用。
使用工具：VS2015+Qt5.9.3
创建过程：
1、新建一个Qt的gui工程，一路next
2、打开ui文件，在designer中拖动一个widget，并提升窗口部件为QChartView
3、接下来先不要编译，因为我们还没有把QtChart的库文件包含进来，首先打开项目的属性，注意在添加包含目录的时候，要把QtCharts那个路径添加进去，这样ui文件中提升的那个头文件就不会报错
下面添加附加依赖库：
设置完了之后就可以点击确定，并进行编译，此时编译之后会出现错误，这是因为没有写命名空间：
4、那么我们在添加命名空间的时候不要在ui_xxx.h文件里面进行添加，因为这是自动生成的文件，每一次添加新的控件并编译的时候就把你添加的信息给删除掉，这时我们可以添加到刚开始新建的文件中去，见下图；
如果图中的命名空间不能用，（试过在头文件中不能用），则可以换另外一个：using namespace QtCharts;
此时，再进行编译就不会出现错误
5、然后，我们在这个cpp文件下面，写上简单的函数进行编译运行验证，见图：
自此，构建成功，谢谢！
我踩过的坑，希望大家不要再踩一遍，仔细按照上面的进行，运行不了你找我！
后续探索，有时间写...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f31ed1b61abeedfb06353e34fec1998/" rel="bookmark">
			linux中lost&#43;found目录的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、该目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当系统发生错误时，将一些遗失的片段放置在这个目录下。
这个目录通常会在分隔槽的最顶层存在。如/lost+found
2、该目录一般情况是空的。只有root用户才能打开。
3、lost+found目录的文件通常是未链接的文件，这些文件还被一些进程使用（数据没有删除）。
4、每个分区默认都有一个lost+found目录，用来存放fsck过程中部分修复的文件的。
5、inode 11,/* First non-reserved inode for old ext2 filesystems */ 即第一个非预留的inode,通常是指lost+found
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e93d58fc430d45e8b0509df77590d4/" rel="bookmark">
			VS2017  MFC的Picture Control控件显示opencv3.3图片的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：Win10 Vs2017 opencv3.3 文中涉及 MatToCImage(rgbImageL1, rgbImageL2);//OpenCV中Mat对象转MFC的CImage类的函数 见我另一篇博文OpenCV中Mat对象转MFC的CImage类的函数 http://blog.csdn.net/weixin_39449570/article/details/78901208
方法一： 下面是实现图片显示的程序，亲测可用：
int cxl, cyl; Mat rgbImageL1;//opencv图片 CImage rgbImageL2; CRect rectl, pic_rectl; int widthl, heightl; //改变图片大小适应picture控件 GetDlgItem(IDC_pl)-&gt;GetClientRect(&amp;pic_rectl); widthl = pic_rectl.right; heightl = pic_rectl.bottom; resize(rgbImageL, rgbImageL1, Size(widthl, heightl)); MatToCImage(rgbImageL1, rgbImageL2);//OpenCV中Mat对象转MFC的CImage类的函数（见我另一篇博文） //获取图片的宽 高度 cxl = rgbImageL2.GetWidth(); cyl = rgbImageL2.GetHeight(); //获取Picture Control控件的大小 GetDlgItem(IDC_pl)-&gt;GetWindowRect(&amp;rectl); //将客户区选中到控件表示的矩形区域内 ScreenToClient(&amp;rectl); //窗口移动到控件表示的区域 GetDlgItem(IDC_pl)-&gt;MoveWindow(rectl.left, rectl.top, cxl, cyl, TRUE); CWnd *pWnd = NULL; pWnd = GetDlgItem(IDC_pl);//获取控件句柄 pWnd-&gt;GetClientRect(&amp;rectl);//获取句柄指向控件区域的大小 CDC *pDc = NULL; pDc = pWnd-&gt;GetDC();//获取picture的DC rgbImageL2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e93d58fc430d45e8b0509df77590d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc977ea83db083fac47dd4ba22e4d22d/" rel="bookmark">
			Docker 入门笔记 5  - 在Stack中部署多个service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记参考 https://docs.docker.com/get-started/part5/
ContainersServicesSwarmsStacks 什么是stack 在docker中，stack指的是一组相互关联的服务，它们可以共享依赖关系，并且可以一起协调和缩放。一个stack 能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个stack）
添加一个新服务 在之前的练习中我们已经用制作的image部署了一个web service，现在我们修改 docker-compose.yml， 添加一个叫做visualizer的service 到stack。
编辑 docker-compose.yml version: "3" services: web: #service called web image: misterchi/repositorytest:hello #Pull the image deploy: replicas: 5 #five instances resources: limits: cpus: "0.1" #one instance at most 10% of the CPU memory: 50M #one instance at most 50M memory restart_policy: condition: on-failure #Immediately restart containers if one fails ports: - "80:80" #map host port 80 with service port 80 networks: - webnet #share 80 via a load-balanced network called webnet visualizer: image: dockersamples/visualizer:stable ports: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc977ea83db083fac47dd4ba22e4d22d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88729858c0a07dffdaddeb133dcb317/" rel="bookmark">
			Laravel5.5源码详解 -- 中间件MiddleWare分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Laravel5.5源码详解 – 中间件MiddleWare分析 启动流程 首先，我们从/public/index.php开始，程序正是从这里启动的。Middleware正是在这里启动，如下
$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture() ); 注意到这个Kernel，本质上是/app/Http/Kernel.php，其handle函数在其父类Illuminate\Foundation\Http\Kernel中，
public function handle($request) { try { $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); } catch (Exception $e) { $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); } catch (Throwable $e) { $this-&gt;reportException($e = new FatalThrowableError($e)); $response = $this-&gt;renderException($request, $e); } $this-&gt;app['events']-&gt;dispatch( new Events\RequestHandled($request, $response) ); return $response; } protected function sendRequestThroughRouter($request) { $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter()); } 这里有必要解释最后这几句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88729858c0a07dffdaddeb133dcb317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8374885911508eadd8e34ee83aa758/" rel="bookmark">
			VS2017  C&#43;&#43; MFC CString怎么转换成int,double
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先要确定你的工程字符集用的是多字节而不是unicode才能用下面的方法, 因为vs2017默认使用的是unicode编码. 修改方式为: 在解决方案窗口右键工程名–&gt;属性-&gt;General项(我用的是英文的)–&gt;字符集, 选择多字节那个就行了
2、例程： CString str; 转成int: ;int a = atoi(str.GetBuffer()); 转成double: double b = atof(str.GetBuffer()); // 如果坚持要用unicode的话, 就用下面两个函数: 转成int: ;int a = _wtoi(str.GetBuffer()); 转成double: double b = _wtof(str.GetBuffer());
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13c9b99a790f4e9061d8192123c7568/" rel="bookmark">
			关于 Error: No PostCSS Config found in 的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 项目在本地运行不报错，上传到 GitHub 之后，再 clone 到本地，
npm install 安装完成之后再执行
npm run dev 这时报错 Error: No PostCSS Config found in... 本以为是 GitHub 上传的问题，后开又试了两回，发现问题依然存在，于是就开始网上寻找办法。
解决方案： 在项目根目录新建postcss.config.js文件，并对postcss进行配置：
module.exports = { plugins: { 'autoprefixer': {browsers: 'last 5 version'} } } 好了，大功告成，试一试：
npm run dev 完美运行。
依然存在疑问： 项目在本地运行时本来不报错的，但是为什么上传到 GitHub 之后，再 clone 下来，再运行就得单独写一个 postcss.config.js 的文件并配置一下呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5465e8a8000d1cdd180085cd2eb842/" rel="bookmark">
			_u32是干嘛的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从知乎上看过来的，自己也总结一下。
1、在驱动开发中，建议使用_u32或者u_int32_t代替unsigned int等默认的数据类型。目的在于：清晰的说明这个变量占用多大内存，即32。
原因：不能确定你的代码以后是否只在一个平台上运行，有可能会移植到非Linux平台，不同的CPU平台，比如64位环境、非x86环境。而C语言中并未明确规定int占多少字节，所以_u32就是告诉别人，这变量占4字节。
2、这是一种良好的编程风格。
typedef unsigned int _u32 其它类推
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecacfe6902cfd1314e486cd2aa93f578/" rel="bookmark">
			将mysql中的数据导为.sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运用mysqldump 1.导出整个数据库(包括数据)
mysqldump -u username -p dbname &gt; dbname.sql
2.导出数据库（只有建表语句，不含数据）
mysqldump -u username -p -d dbname &gt; dbname.sql
3.导出数据库中的某张表（包括数据）
mysqldump -u username -p dbname tablename &gt; tablename.sql
4.导出表结构（不包括表结构）
mysqldump -u username -p -d dbname tablename &gt; tablename.sql
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97663176e34842399d992d92857d5423/" rel="bookmark">
			SVG基础十一：放射性渐变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVG 渐变必须在 &lt;defs&gt; 标签中进行定义。
放射性渐变 &lt;radialGradient&gt; 用来定义放射性渐变。
&lt;radialGradient&gt; 标签必须嵌套在 &lt;defs&gt; 中。&lt;defs&gt; 标签是 definitions 的缩写，它允许对诸如渐变等特殊元素进行定义。
请把下面的代码拷贝到记事本，然后把文件保存为 "radial1.svg"。把此文件放入您的 web 目录：
&lt;?xml version="1.0" standalone="no"?&gt; &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt; &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;defs&gt; &lt;radialGradient id="grey_blue" cx="50%" cy="50%" r="50%" fx="50%" fy="50%"&gt; &lt;stop offset="0%" style="stop-color:rgb(200,200,200); stop-opacity:0"/&gt; &lt;stop offset="100%" style="stop-color:rgb(0,0,255); stop-opacity:1"/&gt; &lt;/radialGradient&gt; &lt;/defs&gt; &lt;ellipse cx="230" cy="200" rx="110" ry="100" style="fill:url(#grey_blue)"/&gt; &lt;/svg&gt; 代码解释： &lt;radialGradient&gt; 标签的 id 属性可为渐变定义一个唯一的名称，fill:url(#grey_blue) 属性把 ellipse 元素链接到此渐变，cx、cy 和 r 属性定义外圈，而 fx 和 fy 定义内圈 渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 &lt;stop&gt; 标签来规定。offset 属性用来定义渐变的开始和结束位置。 查看例子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97663176e34842399d992d92857d5423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6353b128226aff10fe97699bca8eecbd/" rel="bookmark">
			SVG基础十：线性渐变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVG 渐变必须在 &lt;defs&gt; 标签中进行定义。
SVG 渐变 渐变是一种从一种颜色到另一种颜色的平滑过渡。另外，可以把多个颜色的过渡应用到同一个元素上。
在 SVG 中，有两种主要的渐变类型：
线性渐变放射性渐变 线性渐变 &lt;linearGradient&gt; 可用来定义 SVG 的线性渐变。
&lt;linearGradient&gt; 标签必须嵌套在 &lt;defs&gt; 的内部。&lt;defs&gt; 标签是 definitions 的缩写，它可对诸如渐变之类的特殊元素进行定义。
线性渐变可被定义为水平、垂直或角形的渐变：
当 y1 和 y2 相等，而 x1 和 x2 不同时，可创建水平渐变当 x1 和 x2 相等，而 y1 和 y2 不同时，可创建垂直渐变当 x1 和 x2 不同，且 y1 和 y2 不同时，可创建角形渐变 请把下面的代码拷贝到记事本，然后把文件保存为 "linear1.svg"。把此文件放入您的 web 目录：
&lt;?xml version="1.0" standalone="no"?&gt; &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt; &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;defs&gt; &lt;linearGradient id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6353b128226aff10fe97699bca8eecbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a639538ccc7eaef073e4d9e42c57d4c6/" rel="bookmark">
			Dev ButtonEdit控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是buttonEdit控件。
一般用它选路径。
Text属性：用于显示文本。（DEV所有控件通用的属性）
ButtonClick事件： 是点击三个点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17427b8636817ac919f98e54eb8e463/" rel="bookmark">
			SVG基础二：SVG编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVG 使用 XML 编写。
SVG 实例 下面的例子是一个简单的 SVG 文件的例子。SVG 文件必须使用 .svg 后缀来保存：
&lt;?xml version="1.0" standalone="no"?&gt; &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt; &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red"/&gt; &lt;/svg&gt; 代码解释： 第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是“独立的”，或含有对外部文件的引用。
standalone="no" 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。
第二和第三行引用了这个外部的 SVG DTD。该 DTD 位于 “http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd”。该 DTD 位于 W3C，含有所有允许的 SVG 元素。
SVG 代码以 &lt;svg&gt; 元素开始，包括开启标签 &lt;svg&gt; 和关闭标签 &lt;/svg&gt; 。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a17427b8636817ac919f98e54eb8e463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3c2048f8190e4f8b0f8d314db2de96/" rel="bookmark">
			Linux下的 command not found错误(解决方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在 Linux下执行一个命令时，报 -bash: XXXX: command not found，这和Windows是相同的道理，都是环境变量惹的祸，
就是说你的 命令的 执行文件不在 /usr/bin 或者 /etc/init.d 中，他就找不到 执行该命令的 文件来执行.
思路是将 该应用的 bin 目录 放入到 profile 文件中就OK了
1、find / -name profile #找到该文件（这个文件相当于 你在Windows 中加入环境变量那块）,一般该文件在 /etc/profile 这里
2、vim profile #编辑该文件
3、export PATH="$PATH:/phpstudy/mysql/bin" #在该文件中加入 command not found 的应用 bin 目录,这里我是将 mysql 的 bin 放到这里，因为 我是因为 mysqld / mysqldump / mysqladmin 命令用不了
4、source /etc/profile // 更新配置(不用重启系统)
之后你在执行 就 OK啦！如果有什么问题，留言告诉我，我会尽快回复
【end】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbf2a4309cd1e9d1b172d929f900c0a/" rel="bookmark">
			CSDN现在绑定手机还送下载积分吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 收到短信,说绑定手机送50积分,但是并没有到账. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2be84c4209431bf211728a2ff2ec069/" rel="bookmark">
			基于神经网络的2D摄像头的手势识别系统实现（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、手势识别的分类 若按照摄像头的种类（2D摄像头、深度摄像头）来分，可分为两类，1）基于2D摄像头的二维手势识别 和 2）基于3D摄像头（如微软的kinnect）三维手势识别。早期的手势识别识别是基于二维彩色图像的识别技术，所谓的二维彩色图像是指通过普通摄像头拍出场景后，得到二维的静态图像，然后再通过计算机图形算法进行图像中内容的识别。二维的手型识别的只能识别出几个静态的手势动作，而且这些动作必须要提前进行预设好。相比较二维手势识别，三维手势识别增加了一个Z轴的信息，它可以识别各种手型、手势和动作。三维手势识别也是现在手势识别发展的主要方向。不过这种包含一定深度信息的手势识别，需要特别的硬件来实现。常见的有通过传感器和光学摄像头来完成。　手势识别中最关键的包括对手势动作的跟踪以及后续的计算机数据处理。关于手势动作捕捉主要是通过光学和传感器两种方式来实现。手势识别推测的算法，包括模板匹配技术（二维手势识别技术使用的）、通过统计样本特征以及深度学习神经网络技术。本文着重于2D摄像头的手势识别。
二、基于2D摄像头的手势识别 1. 2D摄像头的手势识别分类 2D摄像头的手势识别分类又分为：1）静态手势识别（手型识别）也称静态二维手势识别，识别的是手势中最简单的一类。只能识别出几个静态的手势动作，比如握拳或者五指张开，这种技术只能识别手势的“状态”，而不能感知手势的“持续变化”。说到底是一种模式匹配技术，通过计算机视觉算法分析图像，和预设的图像模式进行比对，从而理解这种手势的含义。因此，二维手型识别技术只可以识别预设好的状态，拓展性差，控制感很弱，用户只能实现最基础的人机交互功能。其代表公司是被Google收购的Flutter。使用他家的软件之后，用户可以用几个手型来控制播放器。2）动态手势识别，仍不含深度信息，停留在二维的层面上。这种技术比起二维手型识别来说稍复杂一些，不仅可以识别手型，还可以识别一些简单的二维手势动作，比如对着摄像头挥挥手。二维手势识别拥有了动态的特征，可以追踪手势的运动，进而识别将手势和手部运动结合在一起的复杂动作。这种技术虽然在硬件要求上和二维手型识别并无区别，但是得益于更加先进的计算机视觉算法，可以获得更加丰富的人机交互内容。在使用体验上也提高了一个档次，从纯粹的状态控制，变成了比较丰富的平面控制。其代表公司是来自以色列的PointGrab，EyeSight和ExtremeReality。
2. 2D摄像头的手势识别的原理 手势有三个主要特征：手型，方向，运动轨迹，一个基于视觉手势识别系统的构成应包括：图像的采集，预处理，特征提取和选择，分类器的设计，以及手势识别。其流程大致如下： 其中有三个步骤是识别系统的关键，分别是预处理时手势的分割，特征提取和选择，手势跟踪，以及手势识别算法。不管是手势检测，或者手势跟踪，识别，特征提取和选择是关键:手势本身具有丰富的形变，运动以及纹理特征，选取合理的特征对于手势的识别至关重要。目前 常用的手势特征有:轮廓、边缘、图像矩、图像特征向量以及区域直方图特征等等。其中，手势检测（手势分割），主要受复杂背景，遮挡，直接光源的亮度变化，外部反射等，常见手部检测特征选取有基于肤色，基于表观，基于模型三种手部检测。手势跟踪，主要受快速运动，双手遮挡，非刚体，非线性，非高斯，多模态。通俗的讲，就是 手势非刚体运动，受到缩放，形变，缺少，模糊，旋转，亮度，视角等因素影响，建议使用基于肤色的SIFT+肤色（ROI）+HOG,粒子滤波，MeanShift,基于Sift特征，基于EKF,基于SVM，基于模板匹配等。手势识别，受尺度，角度，光照，同一手势每次演示的差异。目前基于2D视觉的静态手势识别技术主要有三大类，第一类为模板匹配技术，这是一种最简单的识别技术；第二类为统计分析技术，这是一种通过统计样本特征向量来确定分类器的基于概率统计理论的分类方法；第三类为神经网络技术，这种技术具有自组织和自学习能力，具有分布性特点，能有效的抗噪声和处理不完整模式以及具有模式推广能力。基于2D视觉的动态手势识别技术，主要有基于神经网络，基于HMMs,CRFs等。
3.基于神经网络2D摄像头静态手势识别实现 本文主要实现基于2D摄像头的静态手势识别系统，由于是静态所以不用考虑手势追踪，重点关注手势分割、手势识别两部分。其中手势分割采用局部自适应阈值的图像二值化和高斯肤色模型算法提取手掌轮廓；手势识别采用CNN网络进行分类。 3.1 手势分割算法实现 局部自适应阈值的图像二值化
def binaryMask(self, frame, x0, y0, width, height): # print('use binaryMask model ...') minValue = 70 # 创建矩形框 cv2.rectangle(frame, (x0, y0), (x0 + width, y0 + height), (0, 255, 0), 1) roi = frame[y0:y0 + height, x0:x0 + width] # 获取灰度图像 gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY) # 高斯模糊:高斯滤波器中像素的权重与其距中心像素的距离成比例 blur = cv2.GaussianBlur(gray, (5, 5), 2) # 图像的二值化提取目标,动态自适应的调整属于自己像素点的阈值，而不是整幅图像都用一个阈值 th3 = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2be84c4209431bf211728a2ff2ec069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ecc01d2899ac99fae303cfd620dd8e8/" rel="bookmark">
			wxWidgets学习 - 双缓冲技术解决屏幕闪烁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是双缓冲？实例代码运行效果 有经验的开发者应该知道，当我们频繁直接在窗口绘图时，会出现图像闪烁的现象，因此需要利用双缓存技术来绘图。
什么是双缓冲？ 所谓双缓冲即在内存中创建一个与屏幕绘图区域一致的对象，先将图形绘制到内存中的这个对象上，再一次性将这个对象上的图形拷贝到屏幕上，这样能大大加快绘图的速度。
具体在wxWidgets中的就是建立一个wxMemoryDC，在wxMemoryDC中绘图完成后再将数据复制到wxPaintDC或者wxClientDC。
实例代码 说明：OnPaint已经绑定到窗口Paint事件
void wxTestDialog::OnPaint(wxPaintEvent&amp; event) { /* wxPaintDC */ wxPaintDC dc(this); /* 准备wxMemoryDC */ wxMemoryDC memDC; wxRect rect = this-&gt;GetRect(); wxBitmap bitmap(rect.GetSize()); memDC.SelectObject(bitmap); /* 开始绘图 */ memDC.SetBackground(*wxRED_BRUSH); memDC.Clear(); double r = 5; wxCoord x, y, lstX, lstY; memDC.SetPen(*wxWHITE_PEN); for (int a = 0; a &lt;= 720; ++ a) { double b = a * 3.1415 / 180; x = cos(b) * r; y = sin(b) * r; if(a !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ecc01d2899ac99fae303cfd620dd8e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f108f51ee000958981501d8affddaae/" rel="bookmark">
			golang 使用 strings.Split 切割的注意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		s := strings.Split("", "") fmt.Println(s, len(s)) s = strings.Split("abc,abc", "") fmt.Println(s, len(s)) s = strings.Split("", ",") fmt.Println(s, len(s)) s = strings.Split("abc,abc", ",") fmt.Println(s, len(s)) s = strings.Split("abc,abc", "|") fmt.Println(s, len(s)) fmt.Println(len("")) fmt.Println(len([]string{""})) str := "" fmt.Println(str[0]) 运行结果:
[] 0 //返回空数组 [a b c , a b c] 7 //返回7个数组元素 [] 1 //返回一个包含空字符元素的数组, 数组长度是1 [abc abc] 2 [abc,abc] 1 0 1 panic: runtime error: index out of range 本文转载自开源中国文章：golang 使用 strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f108f51ee000958981501d8affddaae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda9908d612649fc7cd78d504d7bc713/" rel="bookmark">
			卡尔曼滤波原理快速理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在看本文章之前请先保证自己明白什么是协方差，它有什么含义，什么叫最小均方误差估计，什么是多元高斯分布，以及什么是最大似然估计。
引言 1960年，卡尔曼发表了他著名的用递归方法解决离散数据线性滤波问题的论文。从那以后，得益于数字计算技术的进步，卡尔曼滤波器已成为推广研究和应用的主题，尤其是在自主或协助导航领域。 卡尔曼滤波器由一系列递归数学公式描述。它们提供了一种高效可计算的方法来估计过程的状态，并使估计均方误差最小。卡尔曼滤波器应用广泛且功能强大：它可以估计信号的过去和当前状态，甚至能估计将来的状态，即使并不知道模型的确切性质。 本质上来讲，滤波就是一个信号处理与变换（去除或减弱不想要的成分，增强所需成分）的过程，这个过程既可以通过硬件来实现，也可以通过软件来实现。 卡尔曼滤波属于一种软件滤波方法，其基本思想是：以最小均方误差为最佳估计准则，采用信号与噪声的状态空间模型，利用前一时刻的估计值和当前时刻的观测值来更新对状态变量的估计，求出当前时刻的估计值，算法根据建立的系统方程和观测方程对需要处理的信号做出满足最小均方误差的估计。
1 离散线性卡尔曼滤波
最初的卡尔曼滤波算法被称为基本卡尔曼滤波算法，适用于解决随机线性离散系统的状态或参数估计问题。 1.1被估计的过程信号 卡尔曼滤波器用于估计离散时间过程的状态变量x∈R^n。这个离散时间过程由以下离散随机差分方程描述: (1.1) 定义观测变量z∈R^m，得到量测方程: (1.2) 随机信号w_k和v_k分别表示过程激励噪声和观测噪声。假设它们为相互独立，正态分布的白色噪声（服从如下多元高斯分布，要问为什么服从高斯分布请把文章看完）: p(w)~N(0,Q) (1.3) p(v) ∼ N(0,R) (1.4) 实际系统中， 过程激励噪声协方差矩阵Q和观测噪声协方差矩阵R可能会随每次迭代计算而变化。但在这儿我们假设它们是常数。 当控制函数或过程激励噪声为零时，差分方程1.1中的n × n阶增益矩阵A将上一时刻k-1的状态线性映射到当前时刻k的状态。实际中A可能随时间变化，但在这儿假设为常数。n × l 阶矩阵 B 代表可选的控制输入u∈R^l的增益。量测方程1.2中的m × n阶矩阵 H表示状态变量对测量变量的增益。实际中H可能随时间变化，但在这儿假设为常数。
1.2滤波器的计算原型 定义 （−代表先验，ˆ代表估计）为在已知第k步以前状态情况下第k步的先验状态估计。定义为已知测量变量时第k步的后验状态估计。由此定义先验估计误差和后验 估计误差: 先验估计误差的协方差为: (1.5) 后验估计误差的协方差为: (1.6) 式1.7构造了卡尔曼滤波器的表达式:先验估计和加权的测量变量及其预测之差的线性组合构成了后验状态估计。 (1.7) 式1.7中测量变量及其预测之差被称为测量过程的革新或残余 。残余反映了预测值和实际值之间的不一致程度。残余为零表明二者完全吻合。 式1.7中n × m阶矩阵K叫做残余的增益或混合因数，作用是使1.6式中的后验估计误差协方差最小。可以通过以下步骤计算K:首先将1.7式代入的定义式，再将代入1.6式中，求得期望后，将1.6式中的对K求导。并使一阶导数为零从而解得K值。K的一种表示形式为: (1.8)（具体推导见文章最后附录！！） 由1.8式可知，观测噪声协方差 R 越小，残余的增益越大 K 越大。特别地， R 趋向于零时，有: 另一方面， 先验估计误差协方差越小，残余的增益 K 越小。特别地，趋向于零时，有: 增益 K 的另一种解释 （这种解释比较好理解，在估计值与测量值之间权衡，选择更相信哪个）是随着测量噪声协方差 R 趋于零，测量变量的权重越来越大，而的预测的权重越来越小。另一方面，随着先验估计误差协方差趋于零，测量变量的权重越来越小，而的预测的权重越来越大。
1.3滤波器的概率原型解释 1.7式的解释来源于贝叶斯规则:的更新取决于在已知先前的测量变量的情况下的先验估计的概率分布。卡尔曼滤波器表达式中包含了状态分布的前二阶矩。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda9908d612649fc7cd78d504d7bc713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2f2b5fbb23d7d641cbf206c98b542f/" rel="bookmark">
			Hadoop多次格式化出现17/12/19 00:19:51 WARN hdfs.DataStreamer: DataStreamer Excep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		####在进行Hadoop伪分布式安装的时候我格式化一次，后来又修改了core-site.xml，又进行了一次格式化，然后使用MapReduce 进行测试计算的时候抛出下面的异常：
[hadoop@zydatahadoop001 hadoop]$ bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.1.jar pi 5 10 Number of Maps = 5 Samples per Map = 10 17/12/19 00:19:51 WARN hdfs.DataStreamer: DataStreamer Exception org.apache.hadoop.ipc.RemoteException(java.io.IOException): File /user/hadoop/QuasiMonteCarlo_1513613989668_1586732403/in/part0 could only be replicated to 0 nodes instead of minReplication (=1). There are 0 datanode(s) running and no node(s) are excluded in this operation. at org.apache.hadoop.hdfs.server.blockmanagement.BlockManager.chooseTarget4NewBlock(BlockManager.java:1738) at org.apache.hadoop.hdfs.server.namenode.FSDirWriteFileOp.chooseTargetForNewBlock(FSDirWriteFileOp.java:265) at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getAdditionalBlock(FSNamesystem.java:2496) at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.addBlock(NameNodeRpcServer.java:828) at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolServerSideTranslatorPB.addBlock(ClientNamenodeProtocolServerSideTranslatorPB.java:506) at org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos$ClientNamenodeProtocol$2.callBlockingMethod(ClientNamenodeProtocolProtos.java) at org.apache.hadoop.ipc.ProtobufRpcEngine$Server$ProtoBufRpcInvoker.call(ProtobufRpcEngine.java:447) at org.apache.hadoop.ipc.RPC$Server.call(RPC.java:989) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2f2b5fbb23d7d641cbf206c98b542f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc25beaccf8b135adb9d54010e003ec/" rel="bookmark">
			在线短视频秒播优化之视频文件格式之MP4文件Moov box的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前我们介绍了在线短视频秒播优化的方方面面，从服务器，cdn部署接入，数据连接/获取，客户端缓存，出帧策略，到视频文件I帧位置等。
今天从视频文件格式的另外一个角度介绍，MP4文件的box排列顺序是如何影响，在线短视频的播放以及秒播优化的。
MP4文件中的所有数据都装在box中 (iso-14496-12/14)
(QuickTime中为atom)即mp4是由若干个box组成的
先简单介绍几个重要的box，以便诸位在后续学习时心中有数：
1、 ftyp box，在文件的开始位置，描述的文件的版本、兼容协议等；
2、 moov box，这个box中不包含具体媒体数据，但包含本文件中所有媒体数据的宏观描述信息，moov box下有mvhd和trak box。
mvhd中记录了创建时间、修改时间、时间度量标尺、可播放时长等信息。 trak中的一系列子box描述了每个媒体轨道的具体信息。 3、 moof box，这个box是视频分片的描述信息。并不是MP4文件必须的部分，但在我们常见的可在线播放的MP4格式文件中（例如Silverlight Smooth Streaming中的ismv文件）确是重中之重。 4、 mdat box，实际媒体数据。我们最终解码播放的数据都在这里面。 5、 mfra box，一般在文件末尾，媒体的索引文件，可通过查询直接定位所需时间点的媒体数据。 MP4文件的生成与解析，播放 两个重要的box,moov and mdat 1.生成：先写入mdat后写入moov，因此绝大多数工具都会把moov数据放到mdat后边，比如android的mp4writer，ffmpeg等工具 2.解析：解析播放的时候，先读取moov，才能解析mdat 播放影响 1.本地播放，没有影响，播放软件可以先seek到末尾，读取moov 2.在线播放 (1).需要http服务器支持seek (2).服务器不支持seek，是个非常不友好的方案，要先把数据下载完成才能播放(无论下载到哪里，新服务器，本地内存或存储) (3).(1)和(2)多多少少会引入延时，尤其(2)，影响秒开 市面上短视频mp4 box排列 抖音，火山等小视频moov排在前边，不用seek； 快手，360等moov排在后边需要seek； 可以看出前者小视频在这方面更专业。 在线短视频MP4 moov box排在后边的解决方案 1.修改文件把moov box排在前面，在MP4在设备上生成的时候或传到服务器上后进行 这个方法一劳永逸，还能提升秒开的速度 工具: ffmpeg option faststart qt-faststart Thanks
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facf2e58e08d021f3d9683a4de79b2d8/" rel="bookmark">
			基于ES6的移动（拖动）元素的插件(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载&amp;说明地址：https://github.com/gonghongchen/MoveJS DEMO地址：https://gonghongchen.github.io/MoveJS/
这个相对于上一个移动元素的插件有如下区别： 1.上一个插件固定了移动元素的移动范围为浏览器可视窗口内，而这个版本可以通过设置移动元素的父级元素以实现自定义的移动范围； 2.上一个插件可以自定义移动时光标的放置位置，而这个版本则直接设置了在移动时光标的位置即移动元素本身；（这句话我估计没表达清楚，请详见于两个插件的DEMO） 3.上一个是基于ES5的，这个是基于ES6的，所以在用这个的时候注意（可能）需要使用Babel（可见DEMO源码）进行编译哦，当然，建议直接使用另一个ES5的版本； 4.上一个插件的兼容在IE中做到了IE7，至于这个嘛，目前IE9+。
当然了，两个插件的共同点就是：JS源码里面都有注释，都有注释，注释……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7498876d404e4b3e6cdefd82a11cd7e1/" rel="bookmark">
			three.js 05-05 之 SphereGeometry 几何体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇将要介绍的 SphereGeometry 球体是 three.js 中较简单的另一种几何体。先看看球体常用的几个属性，如下表所示：
属性描述radius可选。此属性定义球体的半径。widthSegments可选。此属性定义球体竖直（维度）方向上的分段数。默认值是 8，最小值是 3heightSegments可选。此属性定义球体水平（经度）方向上的分段数。默认值是 6，最小值是 2phiStart可选。此属性定义从 x 轴的什么地方开始绘制。取值范围是 0 到 2*πphiLength可选。此属性定义从 phiStart 开始绘制多少。取值范围是 0 到 2*πthetaStart可选。此属性定义从 y 轴的什么地方开始绘制。取值范围是 0 到 πthetaLength可选。此属性定义从 thetaStart 开始绘制多少。取值范围是 0 到 π。一个 π 是整球，0.5*π只绘制上半球 这个几何体也是比较简单，下面给出具体示例，代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;示例 05.05 - SphereGeometry&lt;/title&gt; &lt;script src="../build/three.js"&gt;&lt;/script&gt; &lt;script src="../build/js/controls/OrbitControls.js"&gt;&lt;/script&gt; &lt;script src="../build/js/libs/stats.min.js"&gt;&lt;/script&gt; &lt;script src="../build/js/libs/dat.gui.min.js"&gt;&lt;/script&gt; &lt;script src="../jquery/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;style&gt; body { /* 设置 margin 为 0，并且 overflow 为 hidden，来完成页面样式 */ margin: 0; overflow: hidden; } /* 统计对象的样式 */ #Stats-output { position: absolute; left: 0px; top: 0px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7498876d404e4b3e6cdefd82a11cd7e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8c4950cc0cdf438ae0876b1fa2acee/" rel="bookmark">
			Multer 文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		express 默认并不会处理HTTP请求体中的数据，对于普通请求体(JSON、二进制、字符串)数据，可以使用 body-parse 中间件。而文件上传(multeipart/form-data请求),可以基于请求流处理，也可以使用 formidable 模板或者 Multer 中间件。
multer中间件 Multer 是express官方推出的，用于 Node.js multipart/form-data 请求数据处理的中间件。它可以高速的处理文件上传，但并不处理 multipart/form-data 之外的用户请求。
安装
npm install multer --save Multer 在解析完请求体后，会向 request 对象添加一个body对象和一个file或者files对象（上传多个文件时使用files对象）。其中body对象包含所提交表单中的文本字段（如果有），而file（或files）对象中包含通过表单上传的文件。
基本用法如下
var express = require("express") var multer = require("multer") var upload = multer({dest:'uploads/'})//告诉Multer将上传文件保存在哪里 var app = express() app.post('/profile',upload.single('avatar'),(req,res,next)=&gt;{ //req.file 'avatar'文件的信息 //req.body 将具有文本域数据，如果存在的话 }) app.post('/photos/upload',upload.array('photos',12),function(req,res,next) =&gt; { //req.files 是 'photos' 文件数组的信息 //req.body 将具有文本域数据，如果存在的话 }) var cpUpload = upload.fields([{name:'avatar',maxCount:1},{name:'gallery',maxCount:8}]) app.post('/cool-profile',cpUpload,(req,res,next) =&gt; { //req.files 是一个对象(String -&gt; Array) 键是文件名，值是文件数组 //例如： //req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8c4950cc0cdf438ae0876b1fa2acee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/281/">«</a>
	<span class="pagination__item pagination__item--current">282/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/283/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>