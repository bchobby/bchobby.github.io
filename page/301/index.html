<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05da4809e1a07edf6db7aa8b0dc5ec6b/" rel="bookmark">
			字符串中的最长回文字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.felix021.com/blog/read.php?2040可以看下这篇文章的分析
求一个字符串的最长回文子串有几种方法：
1、最容易想到的就是遍历整个字符串，然后求出以每个字符为中心的最长回文串（要考虑奇数和偶数问题），这样的时间复杂度为o(n^2);
2、还有一种就是用后缀数组的方法，将字符串倒转过来然后接到原字符串的后面构造一个新串，中间用一个原字符串中没出现的字符做分隔符，求原字符串最长回文字串就相当于求新串后缀数组的最长公共前缀了，代码较复杂，时间复杂度为o（nlgn);
3、另一种方法时用manacher算法：这个算法有一个很巧妙的地方，它把奇数的回文串和偶数的回文串统一起来考虑了。这一点一直是在做回文串问题中时比较烦的地方。这个算法还有一个很好的地方就是充分利用了字符匹配的特殊性，避免了大量不必要的重复匹配。
算法大致过程是这样。先在每两个相邻字符中间插入一个分隔符，当然这个分隔符要在原串中没有出现过。一般可以用‘#’分隔。这样就非常巧妙的将奇数长度回文串与偶数长度回文串统一起来考虑了（见下面的一个例子，回文串长度全为奇数了），然后用一个辅助数组P记录以每个字符为中心的最长回文串的信息。P［id］记录的是以字符str［id］为中心的最长回文串，当以str［id］为第一个字符，这个最长回文串向右延伸了P［id］个字符。
原串： w aa bwsw f d
新串： # w# a # a # b# w # s # w # f # d #
辅助数组P： 1 2 1 2 3 2 1 2 1 2 1 4 1 2 1 2 1 2 1
由于这个算法是线性从前往后扫的。那么当我们准备求P［i］的时候，i以前的P［j］我们是已经得到了的。我们用mx记在i之前的回文串中，延伸至最右端的位置。同时用id这个变量记下取得这个最优mx时的id值。（注：为了防止字符比较的时候越界，我在这个加了‘#’的字符串之前还加了另一个特殊字符‘$’，故我的新串下标是从1开始的）
void pa(char *str,int n,int p[])
{
int i;
int mx = 0;
int id=0;
for(i=1; i&lt;n; i++)
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05da4809e1a07edf6db7aa8b0dc5ec6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4151849d3187eca878436397f7fa8ca4/" rel="bookmark">
			机器学习平台 GraphLab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GraphLab 是一个机器学习平台，主要是图模型方面的计算。
GraphLab 是另一种有趣的MapReduce抽象实现，侧重机器学习算法的并行实现。GraphLab中，Map阶段定义了可以独立执行（在独立的主机上）的计算，Reduce阶段合并这些计算结果。
Designing and implementing efficient and provably correct parallel machine learning (ML) algorithms can be very challenging. Existing high-level parallel abstractions like MapReduce are often insufficiently expressive while low-level tools like MPI and Pthreads leave ML experts repeatedly solving the same design challenges. By targeting common patterns in ML, we developed GraphLab, which improves upon abstractions like MapReduce by compactly expressing asynchronous iterative algorithms with sparse computational dependencies while ensuring data consistency and achieving a high degree of parallel performance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4151849d3187eca878436397f7fa8ca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4306768d97b79eb77248bbef4523bc61/" rel="bookmark">
			南阳理工OJ  一个简单的数学题 模拟除法，找循环节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 连接： http://acm.nyist.net/JudgeOnline/problem.php?pid=330
一个简单的数学题 时间限制： 3000 ms | 内存限制： 65535 KB 难度： 3 描述 zyc最近迷上了数学，一天，dj想出了一道数学题来难住他。算出1/n,但zyc一时答不上来希望大家能编程帮助他。 输入 第一行整数T，表示测试组数。后面T行，每行一个整数 n (1&lt;=|n|&lt;=10^5). 输出 输出1/n. (是循环小数的,只输出第一个循环节). 样例输入 4 2 3 7 168 样例输出 0.5 0.3 0.142857 0.005952380 #include&lt;stdio.h&gt; #include&lt;string.h&gt; bool p[1000001]; int main() { int T,n,term; scanf("%d",&amp;T); while(T--) { memset(p,0,sizeof(p)); term=10; scanf("%d",&amp;n); if(n&lt;0) { printf("-"); n=-n; } if(n==1) { printf("1\n"); continue; } printf("0."); while(p[term]==false) { printf("%d",term/n); p[term]=true; term=(term%n)*10; if(term==0)break; } printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5168b857d020b077e27ff59fb7d20d/" rel="bookmark">
			总结下在离开教育网后公网各种接入IPV6的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 最简单的，，也是我强烈推荐的。不管你是不是使用路由器拨号（NAT用户）还是不经过路由器直连的ADSL用户，都适用，就是Tunnel broker。 是 gogo6 家的产品，需要注册后才能下载和使用，但是使用是免费的，基本没啥限制，速度很ok，我记得这个默认的服务器 anonymous.freenet6.net 没有被方校长认证。自己刚刚毕业的时候除了交大隧道就是靠他活了。 用这个连CG，无锡电信延迟基本在400-500ms，虽然有点高，但是访问网页没有想象中的那样卡，可以接受。下载基本也可以把我家2M小水管盛满。 除了默认的服务器，你可以试试其他你们tunnel broker隧道服务器， 比如亚太电信的 。这个你们可以放Google搜索。很多的。 选择你们自己最合适的服务器。 montreal.freenet6.net amsterdam.freenet6.net sydney.freenet6.net anon-taipei.freenet6.net (这是台湾服务器) 亚太电信集团：tb.ipv6.apol.com.tw（有可能不稳定） Seednet IPv6 Tunnel Broker：goipv6.seed.net.tw TWNIC IPv6 Tunnel Broker(備援)：192.72.72.17 复制代码 我选的是默认服务器，速度很快。大家自己斟酌。 官网要注册才能下载，同志们，赏我两个辛苦钱 客户端在此，包括32位和64位。 gogoc1.2-client-tunnel-broker.zip (3.04 MB, 下载次数: 4081, 售价: 1 金币) Linux客户端也有，源代码，高端用户肯定不屑于从这里下载，你们自己去gogo6官网下载吧。 软件虽然是英文的，但是都是大学生，connetc这个按钮总认得把。其他照图设置就行。 —————————————————————————————————————————————— 2 . 如果你不使用路由器通过ADSL拨号直连，而且你是中国电信和中国联通这种主流电信运营商的用户（FTTB小区宽带有可能例外），基本上你ADSL拨号博取的就是公网IP。确认办法就是你拨号后，查看ADSL拨号连接的状态，看下IP地址是不是和你在 http://www.123cha.com 看到的一致，如果一致，基本就是公网用户了，这个时候你可以考虑使用上海交大的公网isatap隧道。（广电，移动等小众运营商用户洗洗睡吧） 使用方法和普通的isatap隧道是一样的。打开开始菜单-&gt;管理员权限运行cmd命令提示符（记得关闭Windows防火墙） （XP用户第一次使用记得先运行ipv6 install） netsh interface 6to4 set stat dis netsh interface teredo set stat dis sc config iphlpsvc start= auto net start iphlpsvc netsh interface ipv6 isatap set router isatap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f5168b857d020b077e27ff59fb7d20d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6cd8066c7c43efa3011353aa120ef0/" rel="bookmark">
			kindeditor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近老师讲了在线编辑器的使用，在这里简单介绍一下kindeditor 软件介绍 KindEditor是一套开源的HTML可视化编辑器，主要用于让用户在网站上获得所见即所得编辑效果，兼容IE、Firefox、Chrome、Safari、Opera等主流浏览器。KindEditor使用JavaScript编写，可以无缝的于Java、.NET、PHP、ASP等程序接合。 KindEditor非常适合在CMS、商城、论坛、博客、Wiki、电子邮件等互联网应用上使用，2006年7月首次发布2.0以来，KindEditor依靠出色的用户体验和领先的技术不断扩大编辑器市场占有率，目前在国内已经成为最受欢迎的编辑器之一。
主要特点 1. 体积小，加载速度快，但功能十分丰富。2. 内置自定义range，完美地支持span标记。 3. 基于插件的方式设计，所有功能都是插件，增加自定义和扩展功能非常简单。 4. 修改编辑器风格很容易，只需修改一个CSS文件。 5. 支持大部分主流浏览器，比如IE、Firefox、Safari、Chrome、Opera。 使用说明 简单使用方法 1. 下载KindEditor。下载地址在上边 2. 解压文件，并把所有文件上传到您的网站程序目录下，例如：http://你的域名/editor/。 3. 要添加编辑器的页面头部添加以下代码，id为textarea控件的ID。 ----------------------------------------------------------------------- &lt;script type="text/javascript" charset="utf-8" src="/editor/kindeditor.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; KE.show({ id : 'content_1' }); &lt;/script&gt; ----------------------------------------------------------------------- 4. 要显示编辑器的位置添加TEXTAREA输入框。 &lt;textarea id="content_1" name="content" style="width:700px;height:300px;visibility:hidden;"&gt;&lt;/textarea&gt; &lt;!-- 注意: 如果原来有TEXTAREA，属性里只加id,width,height即可。 版本更新 Ver 4.1.6 (2013-03-24)： 新增: 韩国语语言包，感谢Github用户composite贡献。 新增: allowImageRemote初始化参数，可隐藏网络图片标签。 改善: 插入程序代码添加是否为空的判断。 Bugfix: [IE9] 在frame里调用编辑器，关闭批量上传dialog时浏览器会崩溃。 Bugfix: 插入图片后输入文字，文字加粗后取消加粗，图片会被删除。 Bugfix: [IE] 工具栏被图片选中标记覆盖时有时候无法操作，比如居中对齐后再左对齐。 Bugfix: 全屏ESC快捷键默认未开启，但图标提示还包含ESC。 Bugfix: 图片上传后的url包含&amp;时会被转换成&amp;amp;。 Bugfix: [IE] 移除编辑器后点击页面出现没有权限错误。 Bugfix: [IE] 输入几个文字，调用editor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a6cd8066c7c43efa3011353aa120ef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e55821b6c157574601c54f3d0ee22d/" rel="bookmark">
			创建可扩展性系统-8-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌的Bigtable
Bigtable是管理结构化数据的分布式存储系统。 BigTable的设计宗旨是让系统可靠地扩展到PB级的数据和数千台机器；其设计理念是：广泛的适用性，可扩展性，高性能和高可用性。谷歌很多重要的产品使用 BigTable ，其中包括谷歌财经，和谷歌地球。
BigTable是一个“稀疏的，分布式的，持久的多维排序图”。索引关键词包括行关键词，列关键词，和一个时间戳； 对应的每个值是一个字节数组：
（行字符串，列字符串，时间：INT64） - &gt;字符串
数据模型优化后用于存储网页和类似文件的多个版本，主要便于对于列(而不是行）的快速读取。在一个表中的行关键字是任意字符串（目前高达64KB的大小），客户程序通常会在把各种结构化或者半结构化的数据串行化到这些字符串里。对行关键字的每次读取或写入是一个原子操作。
Bigtable的数据按照行关键字的字典顺序排序。表中的每个行都可以动态分区 ；每一个分区被称为小表格（Tablet)，这是计算分布和负载平衡的单元。小表格使用的未公开的算法BMDiff的Zippy进行压缩。这些算法虽然不具有高的压缩比（LZW），但有很好的计算效率。
BigTable是建立在谷歌文件系统（GFS)之上，底层的文件格式是SSTable。 SSTables的一个重要特点是使每次数据访问最多只需要单个磁盘访问。一个SSTable一旦被创建，是永远不会改变的。添加新的数据会创建一个新的SSTable， 而不改变已有的SSTable。不再需要的SSTable可以被垃圾收集程序收集。 SSTable的不变性是BigTable的数据检查和恢复程序的基础。
Chubby是分布式锁管理的服务器， 支持拥有数千的集群节点的Big​​table保持协调。Chubby本身就是一个集群的应用程序，维持着非常低量的锁管理通讯。Chubby控制服务器的生命周期，存储访问控制列表，数据架构和BigTable的数据的引导位置。
主服务器管理工作服务器及其负载平衡，检测的工作服务器的变化（损失或增加），以及对保存在GFS上的文件进行垃圾收集 和其他一些杂务。和很多Single-Master类型的分布式存储系统类似 ，客户端的数据不通过主服务器。事实上，大多数客户端永远不会与主站进行通信，这有助于在实践中保持主服务器较轻的负载。
每片服务器通常管理10至1000小表格（Tablet)。平均每个小表格约100-200 MB。每一个的BigTable的表通常由多个小表格组成。每个小表格中包含了某个范围内的行的所有相关数据 。新创建的表包含一个小表格。小表格增长后动态分解成多个小表格。这允许系统自动的支持横向扩展。此外，Bigtable中三个层次的命名方案和类似B+树的存储结构也支持实现系统的可扩展性。
分布式计算中的查询，如过滤，聚合，统计数据收集都是使用Sawzall语言。谷歌公开BigTable论文后，对NoSQL发展产生重要影响。突出的是Apache的HBase和Hypertable。 总结:
NoSQL为我们提供了传统RDBMS以外的不同的数据存储方案。系统需要处理的数据量，数据的事务特性，数据的使用方式（读写操作的比例），数据之间的关联性，包括开发和维护成本，都影响到存储方式的选择。
附： Merkle Tree
Merkle Tree, 经常直接称为 Hash Tree，是一个Ralph Merkle在1979年发明，用于有效的处理大量Lamport一次性签名。后来主要被用于验证数据的完整性。
【图片出自http://en.wikipedia.org/wiki/Hash_tree 】
Merkle树是关于哈希的树形结构，叶子节点是文件等数据的哈希值，而非叶节点是子节点的哈希值。比如上图中 hash 0 = hash( hash 0-0 || hash 0-1 ) 。
在P2P的数据传输中，Merkle 树的任何分支可以独立传输，而数据的完整性可以用分支树的根节点的哈希值直接验证。
Dynamo使用Merkle树来减少同步机制中的网络传输开销。Dynamo首先比对Merkle树根节点的哈希值，如果一致则表示两者完全一致，否则分别比较子节点, 直到定位到有差异的数据块. 这种同步方式的时间复杂度为O（lgn）， 避免了可能出现的线性时间比较 ， 同时每次只要传输比较哈希值，而不是数据本身，在分布式中有着节省网络传输量的优点. 附: 开源代码：JGroup
Dynamo 使用一种相互交谈（gossip)的机制监测服务器成员的增减变化。作者在公司内部的一个项目中使用JGroup同步Memcached文件，达到了相似的效果。
JGroup是当前被广泛使用的可靠组间通信的工具之一，例如OSCache以及JBoss的TreeCache。JGroups可以用来创建一个组，在一个组中的所有主机使用一个相同的组播地址 ，这个组中的成员可以给其他成员发送并接受消息；组中的成员关系是动态的，成员可以随时加入或者离开组 。JGroup最大的特点就是支持协议栈的可配置性 。
JGroups的主要功能如下：
1）创建和删除组，组成员可以分布在局域网或广域网中。 2）组的加入和离开 3）成员关系的自动侦测并通知成员的加入，离开和故障 4）监测并删除故障 的成员 5）发送和接收成员到组的消息（点到多点） 6）发送和接收成员到成员的消息（点到点） 转载于:https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e55821b6c157574601c54f3d0ee22d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0deeeb6048248e07a15ffb92f595446e/" rel="bookmark">
			FAT32文件系统--For TF卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. TF卡空间是如何分配的? 下面以4GB TF卡为例，通过WinHex工具进行分析，其空间分配如下图所示：
FAT32把目录当做文件来管理，所以没有独立的目录区，所有的文件目录项都是在数据区里面的。
2. 启动扇区 (DBR) DBR（DOS BOOT RECORD，DOS引导记录），位于柱面0，磁头1，扇区1，即逻辑扇区0 ;
DBR包括：
• 一个引导程序: DOS 引导程序完成DOS系统文件（IO.SYS，MSDOS.SYS）的定位与装载
• 一个BPB: BPB用来描述本DOS分区的磁盘信息，比如：本分区的起始扇区、 结束扇区等等
注意：搜索DBR的标志：
• FAT16的DBR:EB 3C 90，无备份的DBR
• FAT32的DBR:EB 58 90，有备份的DBR，通常在该分区的第6扇区
• NTFS的DBR: EB 52 90，有备份的DBR，通常在该分区的最后一个扇区
2.1 DBR组成 偏移量 长度/字节 组成部分 00H 3 跳转指令 03H 8 操作系统厂商标识及版本号 08H 80 分区参数表(又称BPB),里面存放着对该 分区进行读写操作时所必备的参数 5AH 420 DOS引导代码,它负责把DOS引导文件 IO.SYS、MSDOS.SYS装入内存 FEH 2 结束标志字 ” 55AA ” 2.2 BPB(BIOS Parameter Block)的组成 3. FAT(File Allocation Table)文件分区表 • 簇(Cluster)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0deeeb6048248e07a15ffb92f595446e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0536e9b0fed2409092619b29d469a822/" rel="bookmark">
			win7用户目录多了一个Administrator.xxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ghost安装64位的win7后，发现c:/users有两个目录，一个是Administrator, 一个Administrator.UCRWXDW7RTD。不管它先，但是启动命令行发现使用的目录是：C:\Users\Administrator.UCRWXDW7RTD, 这个目录才是真正的工作目录，而且该目录无法重命名删除操作，看着十分不爽，得想办法改成Administrator目录。
解决方法：
删除Administrator目录，复制Administrator.UCRWXDW7RTD后重命名为Administrator。打开注册表编辑器，编辑键值让其指向Administrator目录：
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList]
修改ProfileImagePath： C:\Users\Administrator
重启计算机，发现其不认我们的Administrator目录，竟然在当前建立Temp目录，注册表也自动指向了Temp目录。也就是说原Administrator.xxx目录有些文件无法拷贝过来，导致系统无法识别。F8启动安全模式后，强制性命名Administrator.xx成Administrator目录，重新修改ProfileImagePath。 重启一切OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706e1cf8089e7741467e451f184732c6/" rel="bookmark">
			jgit版本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//历史记录
package example; import java.io.File; import java.io.IOException; import org.eclipse.jgit.api.Git; import org.eclipse.jgit.api.errors.GitAPIException; import org.eclipse.jgit.api.errors.NoHeadException; import org.eclipse.jgit.revwalk.RevCommit; public class JgitGetVersion { static Git git; public static void main(String[] args) { getHistoryInfo(); } //历史记录 public static void getHistoryInfo() { File gitDir = new File("D:/cfrManage/ConfigFile/.git"); try { if (git == null) { git = Git.open(gitDir); } Iterable&lt;RevCommit&gt; gitlog= git.log().call(); for (RevCommit revCommit : gitlog) { String version=revCommit.getName();//版本号 revCommit.getAuthorIdent().getName(); revCommit.getAuthorIdent().getEmailAddress(); revCommit.getAuthorIdent().getWhen();//时间 System.out.println(version); } }catch (NoHeadException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706e1cf8089e7741467e451f184732c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40afb91d7a6f4783d97e160c783ea620/" rel="bookmark">
			C&#43;&#43;中的good函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在stream流类型中，有一个成员函数good().用来判断当前流的状态（读写正常（即符合读取和写入的类型)，没有文件末尾）
对于类 读写文件 fstream ifstream ofstream 以及读写字符串流stringstream istringstream ostringstream等类型。都用good()成员函数来判断当前流是否正常。
转载于:https://blog.51cto.com/lihaichuan/1160603
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46894de7793d05696c08382ba7d0e35/" rel="bookmark">
			关于进程间通信的学习心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程：进程是指独立地址空间的指令序列
进程的五种状态：新建，就绪，运行，睡眠，僵死
进程间通信：是不同进程之间进行一些"接触"，这种接触有简单，有复杂。机制不同，复杂度也不同。通信是一个广义上的意义，不仅指大批量数据传送，还包括控制信息的传送，但使用方法是基本相同的。
基本的进程通信机制
1.传统UNIX-IPC机制：信号和管道
2.SystemV的IPC机制：共享内存、信号量和消息队列
3.起源于Unix BSD版本的套结字（Socket）
4.远程过程调用（RPC）
信号：Unix系统中使用的最古老的进程间通讯的方法之一，用于向一个或多个进程发送异步事件的信号。信号可以类比于DOS下的INT或者是Windows下的事件。在有一个信号发生的时候，相应的信号就会发送给相应的进程。
信号机制的实现
1.信号包括待处理信号和被阻塞信号
2.如果产生了一个被阻塞的信号，它一直保留待处理，直到被解除阻塞。
3.系统保存每一个进程如何处理每一种可能的信号的信息。
4.系统判断进程是希望忽略这个信号还是让内核处理。进程通过执行系统调用改变缺省的信号处理。
对信号的处理
1.初始化信号集，只有在信号集里面的信号才会被考虑
2.安装信号处理器。所谓信号处理器，就是指定了一些对信号的处理方法。在安装的时候，一定要对特定的信号赋予正确的信号处理函数。
信号相关函数
int sigaction(int signo, const struct sigaction *act, struct sigaction *oact)；为进程安装信号处理器，struct sigaction数据结构是用来保存信号处理器的相关信息。
int sigemptyset(sigset_t *set)；将信号集合清空。
int sigfillset(sigset_t *set)；将信号集合设置成包含所有的信号，在对信号进行操作以前一定要对信号集进行初始化。
int sigaddset(sigset_t *set, int signo)；向信号集中加入signo对应的新信号。
int sigdelset(sigset_t *set, int signo)；从信号集中删除signo对应的一个信号。
int sigismember(const sigset_t *set, int signo)；判断某个信号是否在信号集中。
int sigprocmask(int how,const sigset_t *set, sigset_t *oset)；设置进程的信号屏蔽码。信号屏蔽码可以用来在某段时间内阻塞一些信号集中的信号。
管道通信：是最古老的Unix IPC工具，一个进程从管道一头写数据，另一个进程从管道另一头读数据，以实现它们之间通信的共享方式，又称pipe文件。由于发送和接收都是利用管道进行通信的，故称为管道通信。通信方式是单向的。管道类型分为：无名管道、命名管道
管道通信的思想
1.发送进程可以源源不断的从pipe一端写入数据流，在规定的pipe文件的最大长度（如4096字节）范围内，每次写入的信息长度是可变的。
2.接收进程在需要时可以从pipe的另一端读出数据，读出单位长度也是可变的。
基本管道调用函数
int do_pipe(int *fd)；创建管道
static int pipe_release(struct inode *inode, int decr, int decw)；管道释放
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a46894de7793d05696c08382ba7d0e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc95f3347a78b40bcabd8623fd34a2c7/" rel="bookmark">
			hadoop搭建教程之五（Pig安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、解压与安装
解压pig-0.10.0.tar.gz到/opt/目录下：
tar -zxvf pig-0.10.0.tar.gz -C /opt/mv /opt/pig-0.10.0 /opt/pigchown -R hadoop:hadoop /opt/pigsu hadoop2、配置/opt/pig/bin/pig文件
打开pig文件
# # The Pig command script
#
# Environment Variables
#
# JAVA_HOME The java implementation to use. Overrides JAVA_HOME.
#
# PIG_CLASSPATH Extra Java CLASSPATH entries.
#
# HADOOP_HOME/HADOOP_PREFIX Environment HADOOP_HOME/HADOOP_PREFIX(0.20.205)
#
# HADOOP_CONF_DIR Hadoop conf dir
#
# PIG_HEAPSIZE The maximum amount of heap to use, in MB. # Default is 1000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc95f3347a78b40bcabd8623fd34a2c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a7e1f715a6d4ded25132eda6d434d2/" rel="bookmark">
			曲线救国的就业路线是否合理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原帖：http://www.cnblogs.com/begtostudy/archive/2013/03/16/2962454.html
首先大概说一下我的问题。本人博士毕业，很多人说博士应该去做研究，但是种种原因没有办法找到满意的研发职位。谁都想直达目的，但是有时候就是这样难以实现。
所以我就想了一个曲线救国实现理想的办法，不知道是否合理，请各位前辈指正。
下面我做具体的说明。记录我现在的想法，也为以后自己困惑的时候，拿出来看看，让自己不要在庐山中迷失方向。
本人某上海高校博士毕业，应届，32岁。外地人。
女朋友上海某合资车厂工作，待遇不错。
专业机械设计，方向是数字化智能设计，主要从事设计自动化（基于CAD软件的二次开发）、设计优化（针对产品设计、加工的优化）。
由于目前国内的技术水平较为落后，许多企业以劳动力成本低廉运作代工模式，不需要搞什么二次开发以提高效率，更不需要什么优化改进性能。许多企业即不懂，也没有这方面的需求。说到底，我的研究也是一种技术服务性工作。
而且许多核心技术掌握在外企手里，比如许多CAD软件都是外资公司开发。由于这些公司都是成熟的产品，因此进去之后工作内容也多是维护软件，软件的核心功能全部掌握在外国人手里，工作性质还是低端。最重要的是我一直找不到机会进去，个别机会的薪资待遇又不好，在上海生计压力大。
处于上述困境，偶然间我了解到产品数字化管理行业。其主要是利用成熟的数据管理软件，对企业现有设计流程进行信息化改造，使得企业设计规范化。某甲方有这样的职位，我就申请了。
但是，这是个非常成熟的行业。我找了好多同行业的前辈，他们都认为这个行业，主要是类似于销售的性质，跟客户沟通为主，主要还是实施为主，不需要研发类技术攻关，因此博士去有点浪费。
我相信前辈的劝说是有道理的。这个行业发展很多年了，基础工具也相当的成熟，比如SAP、Teamcneter、Windchill等等，企业也相当熟悉，因此推广起来容易，项目多。
由于该信息系统也需要与企业设计部门打交道，更容易获得企业的更为细节的需求，加上都是与CAD软件打交道，我觉得将来可以推广我的所学：设计自动化，设计优化。
这也许可能成为近水楼台先得月。
如果我直接跟他们说，我可以解决设计问题，别人根本就不信，因为我不懂需求，谁会相信一个陌生人呢。但如果我先懂了需求，再跟他们说，我能解决，还能讲通方案，比如做出辅助设计工具，或者帮助他们优化产品设计，我觉得我推广我原来本行的机会将大大增加。
这样，我既可以做信息系统设计，同时我还有得天独厚的优势：解决企业设计当中的细节难题；既可以方便找到工作，拿到合适的薪水，又能够做我喜欢和擅长的设计当中技术问题攻关。
这就是我目前构思的曲线救国就业想法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be8cd929e07260a9dc3d13539eef375/" rel="bookmark">
			有没有技术管理岗的朋友？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚上基层技术管理岗，以前在乙方做技术，现在要带人管理，想找些前辈交流。
有技术管理岗的朋友吗？求留言，我加您。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc16496ade39864778580d9afa3530b/" rel="bookmark">
			C语言指针作为形参的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中指针是个非常麻烦的事件，本人大学学了几年指针，用起来还是丈二和尚，摸不着头脑，特别是在函数中作为参数传递，申请空间什么的，一头雾水，看到这篇文件写的还比较详尽，因此转载存档！！！！！！！！！
程序1： void myMalloc(char *s) //我想在函数中分配内存,再返回 { s=(char *) malloc(100); } void main() { char *p=NULL; myMalloc(p); //这里的p实际还是NULL,p的值没有改变，为什么？ if(p) free(p); } 程序2：void myMalloc(char **s) { *s=(char *) malloc(100); } void main() { char *p=NULL; myMalloc(&amp;p); //这里的p可以得到正确的值了 if(p) free(p); } 程序3： #include&lt;stdio.h&gt; void fun(int *p) { int b=100; p=&amp;b; } main() { int a=10; int *q; q=&amp;a; printf("%d/n",*q); fun(q); printf("%d/n",*q); return 0; } 结果为 10 10 程序4： #include&lt;stdio.h&gt; void fun(int *p) { *p=100; } main() { int a=10; int *q; q=&amp;a; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bc16496ade39864778580d9afa3530b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa2cf87b9db9e5d3283c6fc9afe5a0a/" rel="bookmark">
			关于dedecms织梦后台的三个问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 织梦DEDECMS网站后台广告管理无法添加广告 添加不显示解决方法 昨天给一个DEDECMS升级程序，数据库和模板保留，升级最新的DEDE内核。升级后更新文章的时候不出现编辑框。应该是编辑器没有调用。 找到解决方法：系统-核心设置 -Html编辑器选项(仅支持 dede 和 fck)填写成：ckeditor 问题解决。 二 DEDECMS织梦后台添加文章不出现编辑框解决方法 织梦DEDECMS网站后台广告管理无法添加广告 最近发现在使用织梦dedecms v5.7版本的时候，在后台模块广告管理里面，添加广告提示添加成功，但是在前台中却不显示。查看了数据库发现其实并没有添加成功。在本地可以看到程序有Error代码，具体如下： Error page: /dede/ad_main.php Error infos: Unknown column 'ad.clsid' in 'on clause' Error sql: SELECT COUNT(*) AS dd FROM `dede_myad` ad LEFT JOIN `dede_arctype` tp on tp.id=ad.typeid LEFT JOIN `dede_myadtype` ap on ap.id=ad.clsid WHERE 1=1 LIMIT 0,1; 解决的办法还是官方提供的： 登入dedecms网站的后台，点击系统设置 -&gt; SQL命令行工具 -&gt; 执行SQL命令 -&gt; 单行命令(支持简单查询)，在文本框输入以下SQL语句： ALTER TABLE `dede_myad` ADD COLUMN `clsid` int(10) NOT NULL DEFAULT 0 AFTER `aid`; 然后点击“确定”，就可以了。 试试吧!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa2cf87b9db9e5d3283c6fc9afe5a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623a7d8b550965c7176e6f5f94f27576/" rel="bookmark">
			Jgit 获取单个文件历史记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git.log().addpath().call 单个文件历史记录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f37dd8b30e7dd3997f29f29001a628/" rel="bookmark">
			python判断一个进程是否正在运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import os,sys
import win32com
def proc_exist(process_name):
is_exist = False
wmi = win32com.client.GetObject('winmgmts:')
processCodeCov = wmi.ExecQuery('select * from Win32_Process where name=\"%s\"' %(process_name))
if len(processCodeCov) &gt; 0:
is_exist = True
return is_exist 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6390573b54f52922ef34a12062105af/" rel="bookmark">
			“java.io.IOException: error=12, 无法分配内存”解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天在做图片压缩测试的时候，发现了这样的一个异常“2013-03-07 17:15:20,723 [//10.14.27.30/1362378799715.0 - /testGraphicMagic.htm] ERROR home.TestGraphicMagicController - org.im4java.core.CommandException: java.io.IOException: Cannot run program "gm": java.io.IOException: error=12, 无法分配内存”，后来在网上查询资料，发现可能是跟swap(虚拟内存)有关，然后执行top指令，发现swap的总大小为0，后让asa重新设置其大小解决此问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85cb5b99f81e76b18126cf9610501f26/" rel="bookmark">
			trac用户管理和身份验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面文章介绍了怎么安装trac，但是新安装的trac虽然可以在浏览器访问到，login按钮点击后，会提示： Authentication information not available. Please refer to the installation documentation. 无法登录。 下面介绍如何为项目设置用户、分配密码和权限。 1. 创建用户，分配权限 首先启动trac项目： $ tracd --port 8000 /var/www/trac/svn/AJS 用trac-admin命令 先看一下命令说明： [root@localhost ~] trac-admintrac-admin - Trac管理控制台 0.12.3
用法: trac-admin &lt;/path/to/projenv&gt; [command [subcommand] [option ...]]
不带命令调用trac-admin将启动交互模式。
help Show documentationinitenv Create and initialize a new environment 先进入交互模式： [root@localhost ~] trac-admin /var/www/trac/svn/AJS
Welcome to trac-admin 0.12.3Interactive Trac administration console.Copyright (C) 2003-2012 Edgewall Software
Type: '?' or 'help' for help on commands.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85cb5b99f81e76b18126cf9610501f26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0932c926821a04240e400b9c103f8e9a/" rel="bookmark">
			Mcrypt响应慢的一个原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.laruence.com/2012/09/24/2810.html
上午的时候, 有同事来找我说上周新上线的一个使用mcrypt的脚本, 响应非常慢, 但是服务器的各项指标都正常, 不知道是什么原因.
经过了解, 一个简单的可重现的脚本如下:
&lt;?php$dmcryptText = "dummy";$key = "foobar";$size = mcrypt_get_iv_size(MCRYPT_BLOWFISH,MCRYPT_MODE_ECB); $iv = mcrypt_create_iv($size); //注意这里 $m = mcrypt_ecb(MCRYPT_BLOWFISH, $key, $dmcryptText, MCRYPT_DECRYPT, $iv);var_dump($m); 当20个并发请求这个脚本的时候, 我们会发现Apache的响应时间急剧上升…
考虑到这个问题可能具有一定的普遍性, 于是我想我还是写一篇文章来介绍下这个坑, 防止后来人再次踩到.
PHP的Mcrypt扩展的mcrypt_create_iv, 如果你不指定的话, 默认使用/dev/random(Linux上), 作为随机数产生器. (也许有的同学已经知道原因了, 呵呵, 那就可以略过了)
这里的问题就在于/dev/random, 它的random pool依赖于系统的中断来产生. 当系统的中断数不足, 不够产生足够的随机数, 那么尝试读取的进程就会等待, 也就是会hang住, 来看一个简单的例子:
$ dd if=/dev/random bs=1024k count=1 当你的机器不够繁忙的时候, 你会发现, 输出的速度很慢, 偶尔还有停顿…
问题就出在了这里, 当你20个并发请求的时候, 服务器的中断数不够, 产生不了足够的随机数给mcrypt, 继而导致PHP进程等待, 从而表现出, 响应时间变长
解决的办法就是, 改用/dev/urandom, /dev/urandom也是一个产生随机数的设备, 但是它不依赖于系统中断.
&lt;?php$dmcryptText = "dummy";$key = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0932c926821a04240e400b9c103f8e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e02f351f670d5be4c6d7dc4e7a718e4b/" rel="bookmark">
			php yii 小计：获取module controller action id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在控制器里
$name = $this-&gt;getModule()-&gt;id; // module
$name = $this-&gt;getId(); // controller
$name = $this-&gt;getAction()-&gt;id; // action
在视图里，除了上述2个方法还可：
$name = $this-&gt;module-&gt;id; // module
$name = Yii::app()-&gt;controller-&gt;id; // controller
$name = $this-&gt;getAction()-&gt;getId(); // action
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85926711d8306c7d1fd75b1b0acd427/" rel="bookmark">
			简析IIS写权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在搞网站，不小心把几个站给搞垮了，具体就不说了，过程也无非是扫描，我用的方法是IIS写权限 跟平常的注入也不一样，大家如果没有找到注入点的话，可以试试IIS写权限， 下面的文章是网上转载来的，大家了解一下过程 //上个月给黑手投去了，人家既然没有发表，我就发出来吧，毕竟文章的原创内容太少，技术含量也没有多高。 最近对IIS的一些安全设置做了下总结，在查找配置写权限漏洞得时候，网上介绍的资料不多，现在就只有自己动手配置了。配置写权限漏洞的时候又对写权限有了一些新的认识。网上对写权限得介绍一般都为，由于服务器得配置不当，用户可以匿名上传一些文件或者是代码。常用的利用工具有zwell的IIS put scanner和老兵的写权限利用工具，本文就不再对利用方法进行介绍了，介绍得文章或者是动画已经很烂了。 写权限漏洞主要跟IIS的webdav服务扩展还有网站的一些权限设置有关系。下面我们先看下webdav的一些官方介绍 允许客户发布、锁定和管理 Web 上的资源，它允许客户端执行以下操作： * 处理资源，处理服务器上 WebDAV 发布目录中的资源。例如，具有正确权限的用户可以在 WebDAV 目录中复制和移动文件。 * 修改属性，修改与某些资源相关联的属性。例如，用户可写入并检索文件的属性信息。 * 锁定资源和解除资源锁定，以便多个用户可以同时读取一个文件。不过，每次只有一个用户能修改该文件。 * 搜索位于 WebDAV 目录中的文件的内容和属性。 WebDAV的全称是（Web-based Distributed Authoring and Versioning，基于Web的分布式创作和版本控制）这是一套扩展HTTP协议允许用户共同编辑和管理上的文件远程网络服务器。使应用程序可以直接写文件在web服务器上，在内容管理系统方面应用得比较多。官方网站是 我们如果在IIS--web服务扩展下开启webdav服务的话IIS put scan就会返回存在漏洞,否则就返回没有漏洞。 写权限漏洞除了跟webDAV服务扩展有关还跟网站的写入权限和脚本资源访问有关，介绍写权限还有脚本资源访问之前我们有必要了解一下网站的其他权限，在IIS--网站属性--主目录下设置。 读取权限：用户可以访问网站的文件，建立网站的时候默认开启读取权限。 写入权限：用户可以写入文件到网站目录，也就是我们所说的写权限漏洞。 脚本资源访问：用户可以对网站目录的脚本文件有操作的权限，前提是开启读取或者写入权限，开启读取权限就有读取脚本文件（源代码）的权限，开启写入权限就有写入脚本文件的权限。 目录浏览：用户可以查看网站目录的所有文件和目录。前提是开启读取权限。 webDAV服务是http协议的扩展服务，用来协同工作的，是用来替代FTP的产物，它不能直接上传脚本文件，IIS映射的所有脚本后缀都不能直接上传。只有先上传一个文本文件后缀的脚本代码（例如txt或者是其它）之后再把它改为脚本文件，我们用老兵的写权限利用工具来演示。 如果开启webDAV服务不开启写入权限则没有上传任何文件的权限，提交后返回下图。 如果开启写入权限不开启脚本资源访问权限，则只有上传普通文件的权限，没有修改为脚本文件后缀的权限。c:inetpubwwwroot为网站目录，提交后如下图。 如果开启了写入权限和脚本资源访问，没有开启webDAV服务扩展，也就没有写权限漏洞可言，感觉用老兵或者其他的工具太麻烦也可以用IE浏览器，文件—打开，输入网站地址，选中以“web文件夹方式打开”则可以像操作本地文件一样的去上传、读取，如下图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aff7049111e2481de9e3f07af947df0/" rel="bookmark">
			求空间中2条线段的最短距离（用osg&#43;C&#43;&#43;写的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2条线段的最短距离
float DistanceLineToLine( const osg::Vec3d&amp; p1,const osg::Vec3d&amp; p2,const osg::Vec3d&amp; p3,const osg::Vec3d&amp; p4 ) { float distance; float x1 = p1.x(); //A点坐标（x1,y1,z1） float y1 = p1.y(); float z1 = p1.z(); float x2 = p2.x(); //B点坐标（x2,y2,z2） float y2 = p2.y(); float z2 = p2.z(); float x3 = p3.x(); //C点坐标（x3,y3,z3） float y3 = p3.y(); float z3 = p3.z(); float x4 = p4.x(); //D点坐标（x4,y4,z4） float y4 = p4.y(); float z4 = p4.z(); float a = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1); float b = -((x2-x1)*(x4-x3)+(y2-y1)*(y4-y3)+(z2-z1)*(z4-z3)); float c = -((x1-x2)*(x1-x3)+(y1-y2)*(y1-y3)+(z1-z2)*(z1-z3)); float d = -((x2-x1)*(x4-x3)+(y2-y1)*(y4-y3)+(z2-z1)*(z4-z3)); float e = (x4-x3)*(x4-x3)+(y4-y3)*(y4-y3)+(z4-z3)*(z4-z3); float f = -((x1-x3)*(x4-x3)+(y1-y3)*(y4-y3)+(z1-z3)*(z4-z3)); if ((a*e-b*d)==0&amp;&amp;(b*d-a*e)==0) //平行 { float d1 = (p1-p3).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aff7049111e2481de9e3f07af947df0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccbd078225e0c94df3beb8b02ffd0133/" rel="bookmark">
			Asterisk 11的Web RTC功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WEBRTC简介 WEBRTC是一个开源项目，其宗旨是让WEB浏览器通过简单的JavaScript具备实时通信(Real-Time Communications (RTC) )的能力。WEBRTC目前支持JS和HTML5，项目由Google、Mozilla和Opera支持。 其官方网址是：http://www.webrtc.org/ WebRTC主要是让Web开发者能够基于浏览器（Chrome\FireFox\...）轻易快捷开发出丰富的实时多媒体应用，而无需下载安装任何插件，Web开发者也无需关注多媒体的数字信号处理过程，WebRTC提供了实时通信的核心技术，包括音视频的采集、编解码、网络传输、显示等功能，并且还支持跨平台：windows，linux，mac，android。
Asterisk 11 的WEBRTC支持
详见社区链接：
https://wiki.asterisk.org/wiki/display/AST/Asterisk+WebRTC+Support
安装libsrtp
因为WEBRTC要求用SRTP，而asterisk的SRTP模块依赖于libsrtp包，所以要先安装它。
#wgethttp://sourceforge.net/projects/srtp/files/srtp/1.4.4/srtp-1.4.4.tgz/download
# tar vzxf srtp-1.4.4.tgz # cd srtp
# ./configure
# make
# make install
安装Asterisk11 # wgethttp://downloads.asterisk.org/pub/telephony/asterisk/asterisk-11-current.tar.gz
# tar vzxf asterisk-11-current.tar.gz #cd asterisk-11.2.1/
#./configure # make
# make install 检查res_srtp 模块和 res_http_websocket 是否选中，如果没有，添加上这两个模块，保存退出(按x保存退出)。
asterisk配置 配置SIPUSER：
[1000] deny=0.0.0.0/0.0.0.0 secret=s1ptest1234 dtmfmode=rfc2833 canreinvite=no context=from-internel host=dynamic trustrpid=yes sendrpid=no type=friend nat=no port=5060 qualify=no qualifyfreq=60 transport=udp encryption=no callgroup= pickupgroup= dial=SIP/1000 mailbox=1000@default permit=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccbd078225e0c94df3beb8b02ffd0133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e613b996350b86f4e1200c0c4a66bb14/" rel="bookmark">
			32位嵌入式处理器编程：warning: integer constant is too large for &#39;long&#39; type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		疑问描述 Keywords: EDK, long long integer, 64-bit, SW, mb-gcc, powerpc-eabi-gcc, compiler, C/C++ , g++
When I define a long long integer data type in SW application in EDK, a warning / error similar to the following occurs:
"warning: integer constant is too large for 'long' type".
Example:
int main ()
{
long long int test = 0x0008888000000000;
},
解决方案 The warning message can be safely ignored, as mb-gcc is not doing anything wrong; the 64-bit computing is in fact correct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e613b996350b86f4e1200c0c4a66bb14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a64942a263b37c44dadbcd57eecdf97/" rel="bookmark">
			遍历二叉树的非递归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种次序的寻访路线，它是从根结点开始沿左子树深入直到最左下端时，返回进入刚刚遇到结点的右子树；在右子树中，也是先深入到它的最左下结点时返回刚遇到结点的右子树······如此深入和返回，直到从根结点的右子树返回根结点止。在这一过程中，返回结点的顺序恰与深入结点的顺序相反，先深入的后返回，正好符合栈的特点。所以可以用栈来保存遍历过程中的结点信息来实现遍历二叉树的非递归算法，并且假定栈空间足够大不会发生栈上溢以简化算法。
1.前序遍历二叉树的非递归算法：
思想：从二叉树的根结点开始，沿左子树一直深入到最左下结点时为止，在深入的过程中访问所遇到的结点，并把所遇到结点的非空右孩子进栈，当左子树结点全部处理完之后，从栈顶退出当前最近访问过结点的右孩子，再按上述过程遍历该结点的右子树；如此重复，直到栈空为止。
在下面的算法中，二叉树以二叉链表存储，用一维数组stack[MAXSIZE]作为栈来保存结点的右孩子信息，top为栈顶指针，p始终指向寻访过程中当前要处理的结点。
#define MAXSIZE 100 void nrpreorder(bitree bt)//非递归前序遍历二叉树bt { bitree stack[MAXSIZE],p;//定义局部变量 int top=0;//栈指针初始化 p=bt;//让p指向二叉树 do { while(p!=NULL)//当p不为空时一直深入到最左下结点 { printf("%d\n",p-&gt;data);//访问结点，假定data域为整型 if(p-&gt;rchild!=NULL) //如果右子树不空 stack[++top]=p-&gt;rchild;//右孩子进栈 p=p-&gt;lchild;//继续搜索p的左子树 } if(top&gt;0) p=stack[top--];//右孩子出栈赋p,准备搜索右子树 }while(top&gt;0);//当栈不空时继续遍历 } 2.中序遍历二叉树的非递归算法思想：基本与前序遍历相同，只是沿左子树向下搜索的过程中先将所遇结点进栈，待遍历完左子树返回时从栈顶退出结点并访问，然后再遍历右子树。
#define MAXSIZE　100 void nrinorder(bitree bt)//非递归中序遍历二叉树bt { bitree stack[MAXSIZE],p;//定义局部变量并初始化 int top=0; p=bt; do { while(p!=NULL)//一直深入到最左下结点 { stack[++top]=p;//所遇结点进栈 p=p-&gt;lchild;//继续搜索p的左子树 } if(top&gt;0) { p=stack[top--];//出栈一个结点 printf("%d\n",p-&gt;data);//访问结点 p=p-&gt;rchild;//继续搜索右子树 } }while(top&gt;0);//当栈不空时继续遍历 } 3.后序遍历二叉树的非递归算法
后序遍历二叉树的非递归算法要比前序和中序稍微复杂些。后序遍历中，当搜索指针指向一个结点时，不能马上访问，需要遍历先遍历左子树，所以结点需要进栈保存；当遍历完左子树返回再次搜索该结点时还不能进行访问，还需要遍历其右子树，所以结点需要再次进栈保存；即一个结点在两次进栈两次出栈之后才能访问。为了区别某一结点指针的两次出栈，需设置一标志flag同结点同时进出栈，flag定义如下：
flag={ 0, (结点第一次进出栈，不访问)；
{ 1, (结点第二次进出栈，出栈后访问)；
栈中数据类型可定义为指向结点的指针和flag组成的结构体类型：
typedef struct stackelem
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a64942a263b37c44dadbcd57eecdf97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154607f7e87cd36fac738fd96567a623/" rel="bookmark">
			ubuntu History命令显示操作时间、用户和登录IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 背景
在ubuntu系统的维护中，经常会用到history命令。
但是考虑到同事误操作责任追究以及被入侵后的线索追查，ubuntu系统中默认提供的history命令难以满足我们的需求。
经过一番调研，发现可以通过修改/etc/profile 文件 一定程度上满足需求。
0x02 需求
执行history命令时能够实现以下效果：
（1）显示命令执行的时间
（2）显示执行命令的用户名
（3）显示执行命令的用户的源IP
（4）A用户可以方便的查看B用户的历史记录
0x03 配置实现
要实现第二小节中的前两个需求，只需要简单配置/etc/profile文件即可，即在/etc/profile文件尾追加以下内容：
export HISTTIMEFORMAT="%F %T `whoami` " 要实现第三个需求，稍微复杂一点，需要首先通过 以下命令来获取登录源IP： USER_IP=`who -u am i 2&gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g'` if [ "$USER_IP" = "" ] then USER_IP=`hostname` 然后再export HISTTIMEFORMAT时，将USER_IP作为参量写入HISTTIMEFORMAT，即： export HISTTIMEFORMAT="%F %T $USER_IP:`whoami` " 而要实现第四个需求，则需要修改历史记录的存放位置，默认情况下，历史记录是存储在用户目录下的.bash_history（完整路径为/home/用户名/.bash_history）文件中的，所以A用户要访问B用户的历史记录必须先提升自己为root权限，否则是无法打开B用户的home目录的，即使拥有了root权限，如果系统有10个用户，则需要进入10个不同的文件夹查看各个文件夹下的.bash_history文件，从而实现查找所有拥有所有历史记录的目的。 为了方便，可以利用HISTFILE环境变量，将所有用户的历史记录，集中到一个目录下，通过用户名区分各自的历史记录文件： export HISTFILE="/opt/history/${LOGNAME}" 综合以上所以小技巧，我们不难得到以下脚本： USER_IP=`who -u am i 2&gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g'` if [ "$USER_IP" = "" ] then USER_IP=`hostname` fi if [ !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154607f7e87cd36fac738fd96567a623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b61caa6db50aa3e2337b04d02b76e85/" rel="bookmark">
			Matlab中plot、fplot、ezplot的使用方法和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数plot 是绘制二维图形的最基本函数，它是针对向量或矩阵的列来绘制曲线的。也就是说，使用plot 函数之前，必须首先定义好曲线上每一点的x 及y 坐标，常用格式为：
（1）plot(x) 当x 为一向量时，以x 元素的值为纵坐标，x 的序号为横坐标值绘制曲线。当x 为一实矩阵时，则以其序号为横坐标，按列绘制每列元素值相对于其序号的曲线，当x 为m× n 矩阵时，就有n 条曲线。
（2）plot(x,y) 以x 元素为横坐标值，y 元素为纵坐标值绘制曲线。
（3）plot(x,y1,x,y2,…) 以公共的x 元素为横坐标值，以y1,y2,… 元素为纵坐标值绘制多条曲线。
函数fplot 用来绘制数学函数，其调用格式为： fplot(fun,lims)其中fun 就是所要绘制的函数，可以是定义函数的M 文件名，也可以是以x 为变量的可计算字符串，lims=[XMIN XMAX YMIN YMAX]限定了x,y 轴上的绘图空间。
函数ezplot它无需数据准备，直接画出函数图形，基本调用格式为ezplot(f)，其中f 是字符串或代表数学函数的符号表达式，只有一个符号变量
区别：
plot是绘制二维图形，并且是x，y的表达式是已知的或者是形如y=f(x)这样确切的表达式
而ezplot是画出隐函数图形，是形如f(x,y)=0这种不能写出像y=f(x)这种函数的图形 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e64c6ed65c7fb1e322183d8ea163ff4/" rel="bookmark">
			安装gcc包时报 configure: error: no acceptable C compiler found in $PATH错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天安装nginx时，报错说少gcc包，结果在网上下了gcc源码进行编译、安装时报了“configure: error: no acceptable C compiler found in $PATH”这个错误，原来编译gcc源代码时也需要用到gcc包，需要下载一个rpm的二进制包进行安装，然后才可以编译之前下载的源代码。网上gcc的二进制包很难找，找了好久找到了一个：http://pkgs.org/ubuntu-11.10/ubuntu-main-i386/gcc_4.6.1-2ubuntu5_i386.deb/download/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171d2f186191cad22f3b899be1bb1549/" rel="bookmark">
			单链表的逆置-C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于单链表的逆置有两种方法可以实现：
（1）利用辅助指针
基本思想：在遍历结点过程中，设置辅助指针，用于记录先前遍历的结点。这样依次编译的过程中只需修改其后继结点的next域即可。
实现代码：
[cpp] view plain copy print ? typedef int DataType; //类型定义 typedef struct node{ //单链表定义 DataType data; struct node* next; }LinkedNode,*LinkList; void ReverseList(LinkList&amp; ListHead) { cout&lt;&lt;"Begin to Reverse the List"&lt;&lt;endl; if( (NULL==ListHead)||(NULL==ListHead-&gt;next) )return ; //边界检测 LinkedNode* pPre=ListHead; //先前指针 LinkedNode* pCur=pPre-&gt;next; //当前指针 LinkedNode* pNext=NULL; //后继指针 while(pCur!=NULL) { pNext=pCur-&gt;next; pCur-&gt;next=pPre; pPre=pCur; pCur=pNext; } ListHead-&gt;next=NULL; ListHead=pPre; //记录下新的头结点 } 示意图：
（2）递归
基本思想：在对当前结点逆置时，先递归地逆置其后继结点，然后将后继结点指向当前结点。
实现代码：
写了两个版本
I、返回值为空
[cpp] view plain copy print ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171d2f186191cad22f3b899be1bb1549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48fe5dcf2a8708788c9516fd326d31d/" rel="bookmark">
			SSH框架搭建小例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH环境搭建
目录
一、概述 2
1.资源下载 2
2.开发环境安装 2
2.1 JDK的安装 3
2.2 Eclipse的安装 5
2.3 Tomcat的安装 5
2.4 将Tomcat导入到Eclipse中 7
2.4 将SVN导入到Eclipse中 12
二、 SSH框架实例 14
1.SSH基本原理 14
2.例程简介 15
3.创建工程搭建框架 17
3.1 新建一个工程 17
3.2 在Eclipse中配置数据源 18
3.3 SSH框架搭建 25
3.3.1 映射数据库 25
3.3.2 建立Dao接口和接口的应用文件 26
3.3.3 业务逻辑层配置 30
3.3.4 struts层配置 31
3.3.6 测试文件 37
3.3.7 登陆测试 38
一、概述 1.资源下载 所需安装文件下载列表
l jdk-7u5-windows-i586.exe
Oracle官方网站：http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1637583.html
l eclipse-jee-indigo-SR1-win32.zip
Eclipse官方网站：http://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/indigo/SR1/eclipse-jee-indigo-SR1-win32.zip
l apache-tomcat-7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48fe5dcf2a8708788c9516fd326d31d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060473789dec6d44e7982ef59c623901/" rel="bookmark">
			构建WCF单一到多服务器之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构建WCF单一到多服务器之路 第一部wcf一个服务 一、新建一个项目，名称：WcfServerice，如图(1)
（图1）
二、初始界面，如图（2），
将原来IService1接口类重新改成名称IServiceFirst，将Service1 改成ServiceFirst，这是第一个服务。
重新修改其内容
// 注意: 使用“重构”菜单上的“重命名”命令，可以同时更改代码和配置文件中的接口名“IService1”。
[ServiceContract]
public interface IServiceFirst
{
// TODO: 在此添加您的服务操作
[OperationContract]
/* 获得表名称 */
string GetTableName();
[OperationContract]
/* 获得表中数据 */
DataSet GetTableData(string tablename);
}
// 使用下面示例中说明的数据约定将复合类型添加到服务操作。
[DataContract]
public class Product
{
string _TablenName ;
/* 数据库中表的名称 */
[DataMember]
public string TableName
{
get { return _TablenName ; }
set { _TablenName = value; }
}
string _Connstring;
/* 数据库连接字符串 */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/060473789dec6d44e7982ef59c623901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b61aa58c6a835141dd2a912073314a0/" rel="bookmark">
			Python Exception Name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		An exception is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions. In general, when a Python script encounters a situation that it can't cope with, it raises an exception. An exception is a Python object that represents an error.
When a Python script raises an exception, it must either handle the exception immediately otherwise it would terminate and come out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b61aa58c6a835141dd2a912073314a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e5c0f5721afe3cb3515dcab2965d85/" rel="bookmark">
			python国际化(i18n)和中英文切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python通过gettext模块支持国际化(i18n),可以实现程序的多语言界面的支持,下面是我的多语言支持实现:
1. 在python安装目录下的./Tools/i18n/(windows下例 D:\Program Files\Python25\Tools\i18n)目录中找到pygettext.py运行之,生成翻译文件模版messages.pot,内容大概是这个样子:
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR ORGANIZATION
# FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2007-01-24 15:05+China Standard Time\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n"
"Language-Team: LANGUAGE &lt;LL@li.org&gt;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING\n"
"Generated-By: pygettext.py 1.5\n"
改之,charset=gb2312 Content-Transfer-Encoding: utf8如下:
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR ORGANIZATION
# FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e5c0f5721afe3cb3515dcab2965d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05591f17dcf97885c0af8619a6e361e4/" rel="bookmark">
			python split分隔字符串之分隔次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用格式：
str.split("char",num)
char：表示分隔标识符
num：表示分隔最大次数，为空表示分隔所有
python 示例代码split.py：
#!/usr/bin/python # -*- coding: UTF-8 -*- str="www.baidu.com.cn" strtemp=str.split(".",1) print strtemp[0] print strtemp[1] print strtemp print str strtemp=str.split(".",3) print strtemp[0] print strtemp[1] print strtemp[2] print strtemp[3] print strtemp print str 执行split.py，结果如下：
~$ sudo python split.py www baidu.com.cn ['www', 'baidu.com.cn'] www.baidu.com.cn www baidu com cn ['www', 'baidu', 'com', 'cn'] www.baidu.com.cn 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba64db013efc0c0561a1bd2005a6531/" rel="bookmark">
			Linux kernel启动参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://smilejay.com/2011/10/kernel_parameters/
在Linux中，给kernel传递参数以控制其行为总共有三种方法：
1.build kernel之时的各个configuration选项。
2.当kernel启动之时，可以参数在kernel被GRUB或LILO等启动程序调用之时传递给kernel。
3.在kernel运行时，修改/proc或/sys目录下的文件。
这里我简单讲的就是第二种方式了，kernel在grub中配置的启动参数。
首先，kernel有哪些参数呢？ 在linux的源代码中，有这样的一个文档Documentation/kernel-parameters.txt，它介绍了kernel的各个参数及其意义。
其次，kernel启动参数以空格分隔，而且是严格区分大小写的（如：mem和MEM是不一样的）。
再次，对于module特有的kernel参数写法是这样的，[module name].[parameter=XX]，例如，igb.max_vfs=7这个kernel启动参数的效果就是相当于这样来动态加载module: modprobe igb max_vfs=7
另外，kernel是怎样处理这些启动参数的呢？ 启动参数通常是这样的形式： name[=value_1][,value_2]…[,value_10]
“name”是关键字，内核用它来识别应该把”关键字”后面的值传递给谁，也就是如何处理这个值，是传递给处理进程还是作为环境变量或者抛给”init”。值的个数限制为10，你可以通过再次使用该关键字使用超过10个的参数。 首先，kernel检查关键字是不是 ‘root=’, ‘nfsroot=’, ‘nfsaddrs=’, ‘ro’, ‘rw’, ‘debug’或’init’，然后内核在bootsetups数组里搜索于该关键字相关联的已注册的处理函数，如果找到相关的已注册的处理函数，则调用这些函数并把关键字后面的值作为参数传递给这些函数。比如，你在启动时设置参数name＝a,b,c,d，内核搜索bootsetups数组，如果发现”name”已注册，则调用”name”的设置函数如name_setup()，并把a,b,c,d传递给name_setup()执行。 所有型如”name＝value”参数，如果没有被上面所述的设置函数接收，将被解释为系统启动后的环境变量，比如”TERM=vt100″启动参数就会被作为一个启动后的环境变量。所有没有被内核设置函数接收也没又被设置成环境变量的参数都将留给init进程处理，比如”single”。
下面简单总结一下我在工作中常用到的一些kernel启动参数吧。
根磁盘相关启动参数：
root #指出启动的根文件系统 如：root=/dev/sda1
ro #指定根设备在启动过程中为read-only，默认情况下一般都是这样配的
rw #和ro类似，它是规定为read-write，可写
rootfstype #根文件系统类型，如：rootfstype=ext4
Console和kernel log相关启动参数：
console #console的设备和选项，如：console=tty0 console=ttyS0
debug #enable kernel debugging 启动中的所有debug信息都会打印到console上
quiet #disable all log messages 将kernel log level设置为KERN_WARNING，在启动中只非常严重的信息
loglevel #设置默认的console日志级别，如：loglevel=7 （0~7的数字分别为：KERN_EMERG,..,KERN_DEBUG）
time #设置在每条kernel log信息前加一个时间戳
内存相关的启动参数：
mem #指定kernel使用的内存量，mem=n[KMG]
hugepages #设置大页表页（4MB大小）的最多个数，hugepages=n
CPU相关的启动参数：
mce # Enable the machine check exception feature.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba64db013efc0c0561a1bd2005a6531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b84baab84c2582ebe100bec112cb212/" rel="bookmark">
			BroadcastReceiver中使用自定义Permission
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BroadcastReceiver中使用自定义Permission
对于权限的使用，我想进行过android开发的都用过，比如：我们需要进行与网络相关的操作时，就必须在manifest中声明android.permission.INTERNET的权限；又或者我们需要对SDCard进行操作时，就需要声明如下的权限：android.permission.WRITE_EXTERNAL_STORAGE（写入数据的权限）和 android.permission.MOUNT_UNMOUNT_FILESYSTEMS（创建和删除文件的权限）。
如果创建自定义的permission，其实也是一件很简单的事情；但是再创建自定义的permission之后，需要在广播接收器BroadcastReceiver中使用，就必须注意如下的问题：
①、发送具有权限的广播
②、具有权限的广播接收器
接下来我们就通过一个例子，来说明如何在BroadcastReceiver中使用自定义的permission，首先需要创建一个应用SelfPermissionBroadcastReceiver，下面1-2-3的操作都在该应用中。
1、需要创建自定义的permission。在manifest中创建自定义permission的配置如下： &lt;!-- 创建自定义授权 --&gt; &lt;permission android:name="com.android.study.permission.MYRECEIVER" android:protectionLevel="dangerous"&gt; &lt;/permission&gt; 自定义permission中的name必须是唯一的，而protectionLevel则可以自己选择。
2、声明自定义的permission。只有在有用到该权限的时候才需要声明，在manifest中声明自定义permission的配置如下： &lt;!-- 声明自定义权限 --&gt; &lt;uses-permission android:name="com.android.study.permission.MYRECEIVER"/&gt; 3、创建广播接收类，一个具有自定义的权限，另一个则任何权限都没有。其实接收处理的代码大体一样，只是在manifest或在代码中registerReceiver进行注册时，一个授予了权限，另一个则没有授予。两个类的核心代码以及注册（这里采用的是manifest中静态注册）配置如下：
①、具有权限的广播接收类PermissionBroadcastReceiver 代码：
@Override public void onReceive(Context context, Intent intent) { //TO DO System.out.println("具有自定义权限的广播接收类——" + intent.getStringExtra("data"));	//TO DO } 配置文件注册：
&lt;!-- 在receiver中使用自定义权限 --&gt; &lt;receiver android:name="com.android.study.receiver.PermissionBroadcastReceiver" android:permission="com.android.study.permission.MYRECEIVER"&gt; &lt;intent-filter&gt; &lt;action android:name="com.android.study.action.IRECEIVER" /&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; ②、没有权限的广播接收类NoPermissionBroadcastReceiver
代码：
@Override public void onReceive(Context context, Intent intent) { //TO DO System.out.println("没有自定义权限的广播接收类——" + intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b84baab84c2582ebe100bec112cb212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d764a3b14522d368bfab44d2733f001/" rel="bookmark">
			避免内存泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android应用程序堆最大为16MB，至少在G1之前是这样（博主补充：Droid为24MB，Nexus One为32MB，Xoom为48MB）。对于手机而言已经是很大的内存空间了，但对于部分开发者而言还是很少的。即便没有将这些内存用完的打算，开发者也应尽量减少内存开销以便其他应用能够在后台运行而不会被强制关闭。这样的话，Android在内存中保存的应用越多，用户在应用间的切换就越快。我工作的一部分就是深入探索Android应用程序的内存泄露问题，大部分时间里，这些问题都是源自同一个错误：对Context（上下文环境）的长时间引用。
在Android上，Context用于多种操作，但最多的还是用来加载和访问资源。这也是为什么所有的Widges在其构造函数中都有一个Context参数。常规的Android应用中，有两类Context：Activity Context和Application Context，通常前者被开发者传递给需要Context的类和方法。
[java] view plain copy @Override protected void onCreate(Bundle state) { super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); setContentView(label); } 这就意味着那些视图引用了整个Activity及其所拥有的一切：一般是整个视图层和所有资源。因此，如果泄露了这类Context（这里的泄露指的是引用Context，从而阻止了GC（垃圾回收）操作），就泄露了很多内存空间。如果不小心，泄露整个Activity是非常容易的事。 在进行屏幕方向改变的时候，系统默认做法是保持状态不变的情况下，销毁当前Activity并重新创建一个新的Activity。这样做，Android会从资源文件中重新装载当前应用的UI。现在假设你写了一个带有很大一幅位图的应用，但你不想在每次屏幕旋转时都装载一次位图，最简单的做法就是将其保存在一个静态区域中：
[java] view plain copy private static Drawable sBackground; @Override protected void onCreate(Bundle state) { super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) { sBackground = getDrawable(R.drawable.large_bitmap); } label.setBackgroundDrawable(sBackground); setContentView(label); } 这段代码执行的快，同时也很有问题：在进行第一次屏幕方向改变的时候泄露了第一个Activity所占的内存空间。当一个Drawable连接到一个视图上时，视图被设置为Drawable上的一个回调，在上面的代码片段中，这就意味着Drawable引用了TextView，而TextView又引用了Activity Context，Activity Context又进一步引用了更多的东西（依赖与你的代码）。 上面这段示例是最简单的泄露Activity Context的情况，你可以到Home Screen's Source Code（查看unbindDrawables()方法）中看看我们是如何通过在Acitivity销毁时将存储Drawable的回调置为null来解决该问题的。如果再有兴趣的话，某些情况下会产生一个由泄露的Context形成的链，这很糟糕，会很快使得内存耗尽。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d764a3b14522d368bfab44d2733f001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1247babc65d190389567c3f39d35525b/" rel="bookmark">
			DNS--2--cache only DNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在安装好BIND软件的前提下，来创建一个只有缓存的DNS服务器。 ----BIND安装说明：yum install bind bind-chroot 2.为了系统的安全，应该进行chroot。确保/etc/sysconfig/named中配置了： ROOTDIR=/var/named/chroot 3.什么时候需要搭建cache only DNS： 在公司为了限制员工利用公司的网络资源做自己的事情，都会针对Internet的连接进行各种限制。当然连port 53这个DNS会用到的port也可能被挡在防火墙之外。这个时候可以在防火墙的那台机器上面，加装一个cache-only 的DNS服务。利用防火墙主机上的DNS服务去帮助client进行hostname&lt;--&gt;IP。因为防火墙主机可以放行自己的DNS功能，而Client端就设置该防火墙IP为DNS服务器的IP即可。这通常都是为了系统安全。 4.实际设置cache only DNS： ----编辑主要配置文件/etc/named.conf: options { listen-on port 53 { any; }; //监听端口，any表示全部接受，也可加入特定的ip directory "/var/named"; //数据库主目录 dump-file "/var/named/data/cache_dump.db"; //一些统计信息 statistics-file "/var/named/data/named_stats.txt"; memstatistics-file "/var/named/data/named_mem_stats.txt"; allow-query { any; }; //是否允许查询，any表示全部接受 recursion yes; //将自己视为客户端的一种查询模式 forward only; //让DNS服务器仅进行转发请求 forwarders{ //转发到的服务器 119.233.255.229; 58.22.96.66; };
}; ----启动DNS: /etc/init.d/named start ----检查/var/log/messages的日志信息,是否正常。 tail -n 30 /var/log/messages | grep named 5.测试： dig www.baidu.com @127.0.0.1
整理自：鸟哥的linux私房菜服务器篇
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1247babc65d190389567c3f39d35525b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac997d27f5b0451b0256d3257244979/" rel="bookmark">
			Java ByteBuffer用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java ByteBuffer用法总结 http://www.whoslab.me/blog/?p=469 最近用SocketChannel进行网络编程比较多，中间也遇到了几个问题，出现的bug也主要来自于对于ByteBuffer的使用不当。现在终于调通了，对ByteBuffer及Socket网络编程也有了更深的认识，特此总结一下。
对于ByteBuffer主要需要注意的是几个标志的含义：position,limit,capability,mark.几个操作的影响：flip(),clear(),rewind().还有就是在读取或者写入时，标志的变化,比如get()方法导致position加1.
SocketChannel采用的是非阻塞异步读取流数据，在读取的时候，通常是
ByteBuffer.clear();SocketChannel.read(ByteBuffer); 如果流中有数据，就会把数据从position开始读到ByteBuffer中，在读取之前ByteBuffer的clear操作会把position置为0,limit置为capability,也就是相当于清空了之前的内容，但是ByteBuffer中数组的内容在read之前是没有改变的.
read之后，通常就是开始从ByteBuffer中提取读到的数据，如果你的数据是以自己定义的数据包的格式进行发送的，那你还需要判断是否读到了数据包的结尾，因为对流数据本身来说是没有结尾这一说的。在提取数据之前，要先把position放到开始读取时的位置,把limit放到当前位置，所以要flip一下,表示从position到limit的位置都是需要的数据。
ByteBuffer.flip();while(ByteBuffer.hasRemaining()){	byte c=ByteBuffer.get();	if (b == PACKAGE_END) {	//you can return the package here	}else{	//you can append the byte here.like StringBuilder.append().	}} 这样以来也存在一个问题，当一次读到的ByteBuffer不包含完整的数据包或者包含多个数据包.那么就需要在下一次继续把这些包分拆出来.那么在读取数据的代码处就可以改为,这样就把之前读取到的未完整的包保留了下来:
if(!ByteBuffer.hasRemaining){	ByteBuffer.clear();	SocketChannel.read(ByteBuffer);} 另外一个可能会用到的操作就是ByteBuffer.rewind(),他会把position置为0，limit保持不变，可以用于重复读取一段数据.
ByteBuffer是nio中一个非常方便的工具.设计思想也非常值得借鉴.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e062d76ca2be3ff9140f2e49f776227/" rel="bookmark">
			读书笔记 Pro Android 3  第2章 节选 StrictMode 严苛模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 2.3提供一个称为严苛模式（StrictMode）的调试特性，Google称该特性已经使数百个Android上的Google应用程序受益。那它都做什么呢？它将报告与线程及虚拟机相关的策略违例。一旦检测到策略违例（policy violation），你将获得警告，其包含了一个栈trace显示你的应用在何处发生违例。你可以强制用警告代替崩溃（crash），也可以仅将警告计入日志，让你的应用继续执行。策略的细节尚难确定，可以期待随Android的成熟Google将增加更多策略。 目前有2种策略可用，第一个和线程相关，它主要针对主线程（或UI线程）。由于在主线程中读写磁盘和进行网络访问都不是好的做法，Google已经在磁盘和网络代码中添加了严苛模式（StrictMode）钩子（hook）。如果你对某个线程打开严苛模式（StrictMode），当那个线程进行磁盘和网络访问，你将获得警告。你可以选择警告方式。一些违例包含用户慢速调用（custom slow calls 这么翻译行吗？），磁盘读写，网络访问。你能选择将警告写入LogCat，显示一个对话框，闪下屏幕，写入DropBox日志文件，或让应用崩溃。最通常的做法是写入LogCat或让应用崩溃。列表2-9显示了一个为线程策略设置严苛模式（StrictMode）的例子。
列表2-9 设置严苛模式（StrictMode）的线程策略
StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectDiskReads() .detectDiskWrites() .detectNetwork() .penaltyLog() .build()); Builder类使得设置变得很简单，Builder函数定义所有策略都返回Builder对象，从而这些函数能像列表2-9那样串连在一起。最后调用build()函数返回一个ThreadPolicy对象作为StrictMode对象的setThreadPolicy()函数的参数。注意到setThreadPolicy()是一个静态函数，因此不需要实例化StrictMode对象。在内部，setThreadPolicy()将对当前线程应用该策略。如果不指定检测函数，也可以用detectAll()来替代。penaltyLog()表示将警告输出到LogCat，你也可以使用其他或增加新的惩罚（penalty）函数，例如使用penaltyDeath()的话，一旦StrictMode消息被写到LogCat后应用就会崩溃。
你不需要频繁打开严苛模式（StrictMode），你可以在主活动的onCreate()函数中打开它，你也可以在Application派生类的OnCreate()函数中设置严苛模式（StrictMode）。线程中运行的任何代码都可以设置严苛模式（StrictMode），但你的确只需要设置一次，一次就够了。
类似于线程策略（ThreadPolicy），严苛模式（StrictMode）有虚拟机策略（VmPolicy）。虚拟机策略（VmPolicy）能检查内存泄漏，譬如，当关闭一个SQLite对象前的完结操作，或其他任何类似可关闭对象在关闭前的完结操作。虚拟机策略（VmPolicy）由一个类似的Builder类创建，如列表2-10所示。和线程策略（ThreadPolicy）不同的是，虚拟机策略（VmPolicy）不能通过一个对话框提供警告。
列表2-10 设置严苛模式（StrictMode）的虚拟机策略
StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectLeakedSqlLiteObjects() .penaltyLog() .penaltyDeath() .build()); 因为设置发生在线程中，严苛模式（StrictMode）甚至能在从一个对象到另一个对象的控制流中找到违例事件。当违例发生，你会惊奇地注意到代码正运行于主线程，而栈trace将帮助你发现它如何发生。于是你能单步调试解决问题，或是将代码移到它自己的后台线程，或是就保持原来的处理方式。这都取决与你。当然，你可能希望适时关闭严苛模式（StrictMode），当你的程序作为产品发布时，你可不希望它仅为了一个警告在你的用户手里崩溃。
有两个方法可以关闭严苛模式（StrictMode），最直接的就是移除相应代码，但这样做不利于持续开发的产品。你通常可以定义一个应用级别布尔变量来测试是否需要调用严苛模式（StrictMode）代码。在发布产品前将这个值定义为FALSE。更优雅的方式是利用调试模式（debug mode）的特点，在AndroidManifest.xml中定义这个布尔变量。&lt;application&gt;字段的属性之一是android:debuggable，其义自明。列表2-11给出了利用该特性的控释方法。
列表2-11 仅在调试模式设置严苛模式（StrictMode）
// Return if this application is not in debug mode ApplicationInfo appInfo = context.getApplicationInfo(); int appFlags = appInfo.flags; if ((appFlags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) { // Do StrictMode setup here StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectLeakedSqlLiteObjects() .penaltyLog() .penaltyDeath() .build()); } 使用Eclipse调试环境，ADT自动为你设置debuggable属性，使项目更易于管理。当你在模拟器上或直接在设备上部署应用，debuggable属性为TRUE，当你导出应用建立一个产品版本，ADT将该属性置为FALSE。注意，如果你另行设置了这个属性值，ADT不会改变它。 严苛模式（StrictMode）很不错，不过在Android 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e062d76ca2be3ff9140f2e49f776227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe94ad0ce48df6e66b5fbb096e6859da/" rel="bookmark">
			./autogen.sh: line 44: libtoolize: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ./autogen.sh + aclocal + libtoolize --copy --force ./autogen.sh: line 44: libtoolize: command not found 是因为缺少libtool软件包 make 时 出现的错误 configure: creating ./config.status cd &amp;&amp; /bin/sh ./config.status Makefile /bin/sh: ./config.status: No such file or directory make: *** [Makefile] Error 127 安装libtool* 在重新执行 就ok了 ./autogen.sh autoconfig 这个也要执行 生成make 需要的文件 然后 configure 开始吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff57155999450769a5c906bb270bf547/" rel="bookmark">
			[eclipse] Open type (Ctrl-Shift-T)找不到类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：《http://www.eoeandroid.com/blog-91715-5053.html》
有时（我极少遇到），通过ctrl + shift + t找对应的类时，类明明存在，并且也在编译路径下，但就是查找不到，一个可能的原因就是eclipse为类建立的索引出了问题。
解决的方法是：找到项目所在工作空间下的.metadata/.plugins/org.eclipse.jdt.core文件夹，将里面的*.index文件和savedIndexNames.txt文件删除，重启eclipse，然后eclipse会重建索引，这时问题就可以解决了。 解决方法来自这里： http://www.java-forums.org/eclipse/6513-open-type-ctrl-shift-t-does-not-find-types.html Sometimes, the indexes that Eclipse use for searching the types, get corrupted. You can clear the Open Type indexes by going to &lt;Workspace&gt;/.metadata/.plugins/org.eclipse.jdt.core and deleting all files there. The indexes will be re-built the next time you use open type. Note that this is a empirical observation, and you may delete some JDT saved data that you don't want to delete.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff57155999450769a5c906bb270bf547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bcf2a07b7149050865282fe085aac7/" rel="bookmark">
			优秀开源代码解读之JS与iOS Native Code互调的优雅实现方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本篇为大家介绍一个优秀的开源小项目：WebViewJavascriptBridge。
它优雅地实现了在使用UIWebView时JS与ios 的ObjC nativecode之间的互调，支持消息发送、接收、消息处理器的注册与调用以及设置消息处理的回调。
就像项目的名称一样，它是连接UIWebView和Javascript的bridge。在加入这个项目之后，他们之间的交互处理方式变得很友好。
在native code中跟UIWebView中的js交互的时候，像下面这样：
//发送一条消息给UI端并定义回调处理逻辑 [_bridge send:@"A string sent from ObjC before Webview has loaded." responseCallback:^(id error, id responseData) { if (error) { NSLog(@"Uh oh - I got an error: %@", error); } NSLog(@"objc got response! %@ %@", error, responseData); }]; 而在UIWebView中的js跟native code交互的时候也变得很简洁，比如在调用处理器的时候，就可以定义回调处理逻辑：
//调用名为testObjcCallback的native端处理器，并传递参数，同时设置回调处理逻辑 bridge.callHandler('testObjcCallback', {'foo': 'bar'}, function(response) { log('Got response from testObjcCallback', response) }) 一起来看看它的实现吧，它总共就包含了三个文件：
WebViewJavascriptBridge.h WebViewJavascriptBridge.m WebViewJavascriptBridge.js.txt 它们是以如下的模式进行交互的：
很明显：WebViewJavascriptBridge.js.txt主要用于衔接UIWebView中的web page，而WebViewJavascriptBridge.h/m则主要用于与ObjC的native code打交道。他们作为一个整体，其实起到了一个“桥梁”的作用，这三个文件封装了他们具体的交互处理方式，只开放出一些对外的涉及到业务处理的API，因此你在需要UIWebView与Native code交互的时候，引入该库，则无需考虑太多的交互上的问题。整个的Bridge对你来说都是透明的，你感觉编程的时候，就像是web编程的前端和后端一样清晰。
简单地罗列一下它可以实现哪些功能吧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bcf2a07b7149050865282fe085aac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e7872fd3f18601a313af04e966857e/" rel="bookmark">
			MySQL最大连接数设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/wooshn/article/details/8069900
在使用MySQL数据库的时候，经常会遇到这么一个问题，就是“Can not connect to MySQL server. Too many connections”-mysql 1040错误，这是因为访问MySQL且还未释放的连接数目已经达到MySQL的上限。通常，mysql的最大连接数默认是100, 最大可以达到16384。 在Windows下常用的有两种方式修改最大连接数。
第一种：命令行修改。
&gt;mysql -uuser -ppassword(命令行登录MySQL)
mysql&gt;show variables like 'max_connections';(查可以看当前的最大连接数)
msyql&gt;set global max_connections=1000;(设置最大连接数为1000，可以再次查看是否设置成功)
mysql&gt;exit(推出)
这种方式有个问题，就是设置的最大连接数只在mysql当前服务进程有效，一旦mysql重启，又会恢复到初始状态。因为mysql启动后的初始化工作是从其配置文件中读取数据的，而这种方式没有对其配置文件做更改。
第二种：修改配置文件。
这 种方式说来很简单，只要修改MySQL配置文件my.ini 或 my.cnf的参数max_connections，将其改为max_connections=1000，然后重启MySQL即可。但是有一点最难的就是my.ini这个文件在哪找。通常有两种可能，一个是在安装目录下（这是比较理想的情况），另一种是在数据文件的目录下，安装的时候如果没有人为改变目录的话，一般就在C:/ProgramData/MySQL往下的目录下。
与连接数相关的几个参数：
在修改最大连接数的时候会有这样一个疑问—这个值是不是越大越好，或者设置为多大才合适？这个参数的大小要综合很多因素来考虑，比如使用的平台所支持的线程库数量（windows只能支持到2048）、服务器的配置（特别是内存大小）、每个连接占用资源（内存和负载）的多少、系统需要的响应时间等。可以在global或session范围内修改这个参数。连接数的增加会带来很多连锁反应，需要在实际中避免由此引发的负面影响。
首先看一下MySQL的状态：
mysql&gt; status;
--------------
mysql Ver 14.14 Distrib 5.5.15, for Win32 (x86)
Connection id: 1
Current database:
Current user: root@localhost
SSL: Not in use
Using delimiter: ;
Server version: 5.5.15 MySQL Community Server (GPL)
Protocol version: 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37e7872fd3f18601a313af04e966857e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5e478bf3848c5162883f9c6bf95b15/" rel="bookmark">
			【Boost】boost::timer库用法与实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// boost::timer库, 用于性能测试等需要计时的任务。 // boost::timer不适合高精度的时间测量任务。 它的精度依赖于操作系统或编译器，难以做到跨平台。 // boost::timer也不适合大跨度时间段的测量，可提供的最大跨度只有几百个小时，如果需要以天、月甚至年作为时间的单位则不能使用timer。 应该使用 date_time库。 void test_timer() { // 声明一个计时器对象，并开始计时! boost::timer t; long long sum = 0; for (int i = 0; i &lt; 1000000 ; i++) sum = sum + i; // 计算时间差, 测量自对象创建后所流逝的时间。 double dl = t.elapsed(); std::cout &lt;&lt; "now time elapsed:" &lt;&lt; dl &lt;&lt; std::endl; //可度量的最大时间，以秒为单位	std::cout &lt;&lt; "max timespan:" &lt;&lt; t.elapsed_max() /3600 &lt;&lt; "h" &lt;&lt; std::endl; //可度量的最小时间，以秒为单位 std::cout &lt;&lt; "min timespan:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5e478bf3848c5162883f9c6bf95b15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00298a4bed0fb3efaf2e34b1cc3b2f12/" rel="bookmark">
			【Poco】Poco::NumberParser的例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include "../tmain.hpp" // Poco::NumberParser类提供静态方法将字符串转换成数字 // parse: 将字符串转换int // parse64: 将字符串转换int64 // parseFloat: 将字符串转换小数 // parseHex: 将字符串转换16进制数 // ... void test_NumberParser() { assert(Poco::NumberParser::parse("123") == 123); assert(Poco::NumberParser::parse("-123") == -123); assert(Poco::NumberParser::parseHex("ABCD") == 0xabcd); assert(Poco::NumberParser::parseFloat("12.34") - 12.34 &lt; 0.01); } void test_NumberParserError() { try { Poco::NumberParser::parse(""); } catch (...) { } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38981b13feb5c4959cd3f32fa88a51db/" rel="bookmark">
			【Poco】Poco::NumberFormatter的例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "../tmain.hpp" void test_NumberFormatter_Format() { // 整数的格式化 assert (Poco::NumberFormatter::format(123) == "123"); assert (Poco::NumberFormatter::format(-123) == "-123"); assert (Poco::NumberFormatter::format(-123, 5) == " -123"); assert (Poco::NumberFormatter::format((unsigned) 123) == "123"); assert (Poco::NumberFormatter::format((unsigned) 123, 5) == " 123"); assert (Poco::NumberFormatter::format0((unsigned) 123, 5) == "00123"); assert (Poco::NumberFormatter::format((long) 123) == "123"); assert (Poco::NumberFormatter::format((long) -123) == "-123"); assert (Poco::NumberFormatter::format((long) -123, 5) == " -123"); assert (Poco::NumberFormatter::format((unsigned long) 123) == "123"); assert (Poco::NumberFormatter::format((unsigned long) 123, 5) == " 123"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38981b13feb5c4959cd3f32fa88a51db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d325da23a824d90a57fd1a17e731bb02/" rel="bookmark">
			使用html5 canvas 画一台小单车动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直在搞前端，不过没用过canvas，呵呵！就想试一下，也刚刚好我图形学的作业就是做一台小单车动画（不限语言），所以我就在一个蛋疼的下午写了一台很蛋疼的单车了，呵呵！样子很丑，不过可以美化，大家可以参考参考！高手勿进虐我这小菜菜，菜鸟共同分享也可以参考当课堂作业，呵呵！ 废话不说，先看代码: HTML: &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="../css/text.css" /&gt; &lt;script type="text/javascript" src="../js/canvas.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas class="mycanvas" id="mycanvas"&gt; &lt;/canvas&gt; &lt;button οnclick="start()"&gt;神啊！赐予我小单车神奇的力量吧!&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; CSS: #mycanvas{ width: 1300px; height: 700px; background-color: #d1fffe; border: 1px solid #000; } JS: var model; var bike; var incremental=0; var timer; if(!model) model={}; model.create = function(){}; model.create.prototype = { cxt : null, canvas : null, init: function (){ canvas = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d325da23a824d90a57fd1a17e731bb02/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/300/">«</a>
	<span class="pagination__item pagination__item--current">301/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/302/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>