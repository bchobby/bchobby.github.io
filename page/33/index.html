<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b9f06a96126fc9c7c131fce46b4e86/" rel="bookmark">
			CentOS虚机给root扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、VirtualBox设置-&gt;存储，添加一个VDI虚拟盘，假设100G
2、进入系统，切换到root用户，fdisk -l，查看新加的硬盘，假设为/dev/sdc，创建物理卷pvcreate /dev/sdc
3、给centos卷组加上新的物理卷/dev/sdc，vgextend centos /dev/sdc，centos卷组名称可通过pvs查看
4、扩容root逻辑卷容量，lvextend -L +100G /dev/mapper/centos-root，或者lvextend -L +100%FREE /dev/mapper/centos-root，将所有可用容量都用来扩容
5、扩展逻辑卷，xfs_growfs /dev/mapper/centos-root
如果一切顺利，那root应该已经成功扩容100G了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784b48c40b4df62ba28268ea45aee501/" rel="bookmark">
			Simulink 的代数环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代数环, 就是由于模型的输出反馈到模块或子系统先的某个输入端, 如果这个输入是直接馈入的, 那么二者在同一个采样点内需得到求解, 但又互相依赖, 哪一方都不能完成求解过程, 使得解算器无法解算导致错误产生, 这样的情况称为代数环。
一旦 Simulink 遇到代数环, 将根据 Configuration Pararmeters 中的诊断设定执行动作, 是警告或报错。打开 Configuration Paramters 的 Diagnostics 页面, 如图所示:
当选择 none 时, Simulink 遇到代数环尝试继续求解, 如无法求解则报错; 选择为 warning 时, simulink 遇到代数环时报警, 尝试求解无果时报错; 选择 error 时, simulink 遇到代数环时直接报错, 并将代数环部分标红。也可以通过 M 代码在 Command window 中实现该设置:
set_param(gcs, 'AlgebraicLoopMsg', 'error'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758c6525914460fa738ca016dafded7a/" rel="bookmark">
			【Yocto】yocto编译系统Image优化笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yocto编译系统Image优化笔记 使用yocto编译出来的Image文件(比如ext4格式）有时候根据业务需求，是要进行剪裁以缩小Image的Size。
比如系统有OTA需求，系统预留的OTA分析大小是500M。但是Image（ext4格式）是1G大小。即使使用压缩文件，也未达到500M。这种情况下，可能就需要进行剪裁了。
这里记录下一下，Yocto Image剪裁时可能会用到的一些知识点。
是否进行了strip 对于编译系统来说，strip操作可理解为对编译生成的成果物（so、bin之类的）剔除其用于Debug的symbol等。strip后成果物的size会变下。
Yocto系统默认对Image的成果物进行Strip操作，但可以通过设置下述变量让Yocto对成果物不进行strip。
# If set to “1”, causes the build to not strip binaries in resulting packages and prevents the -dbg package from containing the source files INHIBIT_PACKAGE_STRIP #Prevents the OpenEmbedded build system from splitting out debug information during packaging. #By default, the build system splits out debugging information during the do_package task. INHIBIT_PACKAGE_DEBUG_SPLIT #If set to “1”, causes the build to not strip binaries in the resulting sysroot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/758c6525914460fa738ca016dafded7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2ffd3f48d4ad69f942393fa12c6de5/" rel="bookmark">
			tensorflow(00)——CPU版与GPU版安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.参考博客
2. CPU版安装的基本步骤
2.1 创建虚拟环境
2.2 安装cpu版本的TensorFlow 2.3 测试tensorflow
2.4 Pycharm &amp;Tensorflow 2.5 Tensorflow &amp; Hello world
3. GPU版本安装教程
3.1 查看CUDA版本
3.2 查看官网对应版本
3.3 将tensorflow装到虚拟环境中
1.参考博客 (1条消息) Tensorflow 2.0 最新版(2.4.1) 安装教程_ZSYL的博客-CSDN博客_pip安装tensorflow2.0
(1条消息) Win11-Tensorflow2.0（GPU）最新版安装_ZSYL的博客-CSDN博客_tensorflow-gpu最新版本
2. CPU版安装的基本步骤 2.1 创建虚拟环境 同样在Anaconda Prompt中利用Anaconda创建一个python3.9的环境，环境名称为tensorflow ，输入下面命令： conda create -n tensorflow_cpu python=3.9 在Anaconda Prompt中启动tensorflow环境
格式：activate 虚拟环境名
activate tensorflow
注：当不使用tensorflow时，关闭tensorflow环境，命令为：deactivate 虚拟环境
2.2 安装cpu版本的TensorFlow 利用下面的命令安装，强制安装CPU版本。
pip install tensorflow-cpu
最后 完美的安装了最新的tensorflow 2.4.1 cpu版本。
注意：一定要在 刚刚创建的tensorflow的环境下安装！
2.3 测试tensorflow 在Anaconda Prompt 中启动tensorflow环境，并进入python环境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b2ffd3f48d4ad69f942393fa12c6de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a63fae1c6fd5a78ba8fb94311ba7de/" rel="bookmark">
			limit 1000,10 和 limit 10一样快吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select * from page where id &gt;=(select id from page order by id limit 6000000, 1) order by id limit 10; 这种情况也能通过一些方式去优化。比如 select * from page t1, (select id from page order by user_name limit 6000000, 100) t2 WHERE t1.id = t2.id; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2231ee9609d012be3d621b65d5df4ada/" rel="bookmark">
			说一下HashMap的实现原理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说一下HashMap的实现原理？ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; transient HashMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2231ee9609d012be3d621b65d5df4ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1563e3273fc32ef0885ad76a65f2012/" rel="bookmark">
			WebStorm/IDEA上传本地项目到GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 目录：Java 目录_jav目录大全-CSDN博客
在使用 WebStorm/IDEA 上传本地项目到 GitHub 之前，先要做一些相关配置。
以 WebStorm 为例，IDEA 同。
1、首先打开 WebStorm ，依次点击File -&gt; Settings... 打开系统设置面板，在上面搜索 github 配置 GitHub 相关参数
如下图所示，在1处搜索 github ，如果2处是 Token 则点击3处的 Create API Token 打开4处的弹窗，输入用户名密码
2、如下图所示，如果1处是 Password ，直接在下面输入用户名密码即可
3、登录完成后，可以点击下图1处 Test 按钮，测试一下，出现2处所示弹窗，表示连接成功
4、连接成功后，我们还要连接我们下载的 Git，依旧，在1处搜索 git ，在2处输入 Git 安装路径，一般情况下这里能自动获取，然后点击3处 Test 按钮，出现4处弹窗，说明连接成功
5、因为我们本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息
使用以下命令生成 SSH Key：
$ ssh-keygen -t rsa -C "youremail@example.com" -keygen -t rsa -C "youremail@example.com" 后面的 youremail@youremail.com 为你在 GitHub 上注册的邮箱，运行命令后会要求确认路径和输入密码，这里 我们无需输入，一路回车就行。成功的话会在C:\Users\Administrator\ 下生成.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1563e3273fc32ef0885ad76a65f2012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330771becf93b4bcdac27dc8e2b58526/" rel="bookmark">
			Activemq 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Activemq 使用 引入依赖： &lt;!--SprngBoot集成ActiveMQ的起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;version&gt;5.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.messaginghub&lt;/groupId&gt; &lt;artifactId&gt;pooled-jms&lt;/artifactId&gt; &lt;/dependency&gt; 2、使用
public void SendTopicMessage(String text, String topic,Long time) throws Exception { //获取连接 Connection connection = null; Session session = null; MessageProducer producer = null; Destination destination = null; try { //获取连接 connection = getActiveMqConnection(); //获取session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); // 创建一个消息队列目标 destination = getDestination(topic, session, destination); // 创建生产者 producer = session.createProducer(destination); producer.setDeliveryMode(DeliveryMode.PERSISTENT); // 创建消息 TextMessage message = session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/330771becf93b4bcdac27dc8e2b58526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5107e66478c2ba6303785ee671c24a/" rel="bookmark">
			Altium Designer学习笔记12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把几个层理解下：
layer名称功能说明信息Toplayer信号层铜箔层，电气连接的层Bottomlayer信号层铜箔层，电气连接的层Internal Planes内层连接地和电源上，一般情况下不布线，是由整片铜膜组成的Mechanical 1机械层电路板机械结构，设计双面板只需要使用默认选项Machanical layer 1层即可Top Overlay丝印层silkscreen layer Bottom Overlay
丝印层silkscreen layerTop paste顶层锡膏防护层掩膜层保护铜线。Bottom Paste底层锡膏防护层掩膜层保护铜线。Top Solder顶层阻焊层放置零件被焊到不正确的地方。 Bottom Solder
底层阻焊层放置零件被焊到不正确的地方。DrillGuide钻孔钻孔图和钻孔位置KeepOutLay禁布层具有电气特性的布线不可以超过禁止布线层的边界。MultiLayer多层横跨所有信号板层 层堆栈管理器：
dielectric：绝缘层。
两种典型的绝缘层是指Core（填充层）、和Prepreg（塑料层）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791c833e2b5ecd6827b4fbe61f292876/" rel="bookmark">
			Altium Designer学习笔记13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0603电容封装的画法：
再画下三极管SOT-23的三极管的封装图：
画出三极管的封装图：
在画图的过程中，遇到了一个问题，画闭环线路的时候，就会被自动删除，查出是这个地方的配置需要进行修改。
那这个地方的闭环问题就得到了解决。
另外有一个量尺寸的方法：
按r 和m键开始量。
最后是按shift+c键进行取消。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e434401b42842abb29efa438e17f440/" rel="bookmark">
			【GPT-3.5】通过python调用ChatGPT API与ChatGPT对话交流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、AIGC简介三、OpenAI介绍四、GPT-3.5介绍五、获得OpenAI API Key六、调用ChatGPT API实现与ChatGPT对话七、参考链接 一、引言 ChatGPT 的火爆，成功带火了AIGC，让它进入大众的视野。
ChatGPT 和Whisper API
开发者现在可以通过API将ChatGPT和Whisper模型集成到应用程序和产品之中。
二、AIGC简介 ​ AIGC即AI Generated Content，利用人工智能技术来生成内容，是继UGC、PGC之后的新型内容生产方式，AI写作、AI绘画、AI作曲、AI剪辑、AI动画、AI交互等都属于AIGC的分支。AIGC是一种利用机器智能创作内容的新技术，它不同于UGC，它有自己的技术特点，比如数据量化、创造力、跨模态融合和认知交互等。这些技术特点使得AIGC成为不可替代的新一代内容生成方式。
三、OpenAI介绍 OpenAI是一个非营利性研究公司，致力于推动人工智能的发展和应用，创造出对人类有益的技术和成果。OpenAI由多位顶尖人工智能专家创立，包括伊隆·马斯克（Elon Musk）、塞巴斯蒂安·索特（Sebastian Thrun）、萨姆·阿尔特曼（Sam Altman）等。
OpenAI的目标是研究和开发通用人工智能，以实现强人工智能的梦想。为了实现这个目标，OpenAI聚集了全球最优秀的研究人员，致力于推动人工智能的前沿研究，并将研究成果转化为对人类有益的应用。
OpenAI已经在多个领域取得了显著的成就，例如在自然语言处理、图像识别、机器学习、深度学习等方面。OpenAI还推出了一系列开源工具和技术，以促进人工智能的发展和应用，包括GPT系列模型、DALL·E、Gym等。
总的来说，OpenAI致力于打造人工智能的可持续发展生态，推动人工智能的进一步发展，为人类创造更美好的未来。
四、GPT-3.5介绍 GPT-3.5：一组改进 GPT-3 的模型，可以理解并生成自然语言或代码。GPT-3.5 模型可以理解和生成自然语言或代码。gpt-3.5-turbo功能最强大、最具成本效益的模型是针对聊天进行了优化，但也适用于传统的完成任务。
五、获得OpenAI API Key 1、登录https://openai.com/api
2、选择“View API keys”
三、创建API key，点击“Create new secret key”
四、创建API key成功，复制保存。
sk-bUQeskc00tsTp************5i5Dop8BxAL1n7 六、调用ChatGPT API实现与ChatGPT对话 import openai # 从这里开始，通向AI的大门，获取AI的能量源泉 输入代码
# 导入OpenAI的Python SDK import openai # 设置OpenAI API的密钥，该密钥必须在OpenAI的网站上注册并获取 openai.api_key = "sk-bUQeskc00tsTp************5i5Dop8BxAL1n7" # 创建一个新的对话生成请求，并将响应存储在名为“response”的变量中 response = openai.ChatCompletion.create( # 创建一个新的对话生成请求，并将响应存储在名为“response”的变量中 model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e434401b42842abb29efa438e17f440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3636805828a1fb4cff0e039c2a226d99/" rel="bookmark">
			linux初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux是什么？ 要学习Linux，首先我们需要知道Linux是什么? 通俗来讲，Linux是一款操作系统的品类，诸如Debian，centos之类则是具体的Linux操作系统。
Linux内核版本&amp;&amp;发行版本 内核版本 &gt;&gt; Linux内核版本内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环：稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。开发版：由于要试验各种解决方案，所以变化很快。内核源码网址：http://www.kernel.org所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中。
发行版本 &gt;&gt; Linux发行版本Linux发行版(也被叫做GNU/Linux发行版)通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS等。
操作系统的品类都有什么呢？
Linux，Windows，ios等等，但Linux与它们有一个本质的区别，那就是Linux是开源的操作系统。
也就是说，Linux的源码是向全世界公开的，而Windows，ios等则是闭源。
Linux目录 Linux的目录呈树状结构，在Linux中，文件夹都被称为目录。
关于文件：文件 = 内容＋属性。所谓对文件的操作，无外乎对属性和内容的操作。
Linux下路径分隔符 /
Windows下路径分隔符 \
Linux 没有盘符这一概念，只有一个根目录 / ，所有的文件都在 / 下面，比如 /root/Desktop 就是从 / 进入 root 然后从 root 进入 Desktop ,与Windows中的路径等同。
Linux目录中存放的内容 绝对路径和相对路径 Linux中，. 表示当前目录，.. 表示上一目录。
从 / 目录开始描述的路径交绝对路径，从当前目录开始描述的路径叫相对路径。
家目录 绝对路径：/var/log/message
相对路径：log/message
Linux下文件的颜色 Xshell 学习Linux的日子将与Xshell相伴，Xshell是一款远程终端软件，我们将使用它远程登录Linux。
XShell 下的复制粘贴 复制: ctrl + insert (有些同学的 insert 需要配合 fn 来按)
粘贴: shift + insert
ctrl + c / ctrl + v 是不行的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3636805828a1fb4cff0e039c2a226d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92b957d267df12a80e7b5ce024def38/" rel="bookmark">
			数据结构-归并排序&#43;计数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.归并排序 基本思想：
归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序核心步骤：
相当于每次把待排数据分为两个子区间，如果每个子区间有序，再让两个子区间归并起来也有序，那整体就有序了。我们可以按照二叉树的思想，把子区间再分为两份，使子区间的子区间有序.......直到子区间分无可分为止。
具体过程如下：
那该如何让两个有序子区间归并呢？
直接在数组中肯定不行，这样会发生数据的覆盖。所以我们可以像之前合并两个有序数组一样，另外开辟一个空间tmp，依次比较两个有序子区间的值，每次比较后把较小的放在tmp中，如果其中一个子区间提前结束，就把另外一个子区间的剩余的数据全放进tmp，最后把tmp中的数据拷贝回原数组。
使用递归实现：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void _MegeSort(int* a, int begin, int end,int*tmp) { //只剩一个数据，递归结束 if (begin == end) { return; } int mid = (begin + end) / 2; //递归子区间，分为两部分 _MegeSort(a, begin, mid, tmp); _MegeSort(a, mid+1, end, tmp); int begin1 = begin, end1 = mid; int begin2 = mid + 1, end2 = end; int j = begin; //两部分比较，每次小的放入tmp while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (a[begin1] &lt; a[begin2]) { tmp[j++] = a[begin1++]; } else { tmp[j++] = a[begin2++]; } } //哪部分有剩余，全部放入tmp while (begin1 &lt;= end1) { tmp[j++] = a[begin1++]; } while (begin2 &lt;= end2) { tmp[j++] = a[begin2++]; } //拷贝到原数组 memcpy(a + begin, tmp + begin, sizeof(int) * (end - begin + 1)); } void MegeSort(int* a, int n) { int* tmp = (int*)malloc(sizeof(int) * n); _MegeSort(a, 0, n - 1, tmp); free(tmp); } void Print(int* a, int n) { for (int i = 0; i &lt; n; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d92b957d267df12a80e7b5ce024def38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42636857eff3f592f0b7450620884f0/" rel="bookmark">
			uniapp 隐私政策弹框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		然后根目录新建文件androidPrivacy.json
{ "version" : "1", "prompt" : "template", "title" : "服务协议与隐私政策", "message" : "\t请务必审慎阅读、充分理解“服务协议与 隐私政策”各条款，包括但不限于：为了 向你提供即时通讯、内容分享等服务，我 们需要收集你的设备信息、操作日志等个 人信息。你可以在“设置”中查看、变更、删除个人信息并管理你的授权。&lt;br/&gt;\r \t你可以阅读 &lt;a href=\"https://shop.baihuitimes.com/register.html\"&gt;《用户协议》&lt;/a&gt; 与 &lt;a href=\"https://shop.baihuitimes.com/protocol.html\"&gt;《隐私政策》&lt;/a&gt;了解详细信息。如你同意，请点击“我同意”开始接受我们的服务。", "buttonAccept" : "同意并接受", "buttonRefuse" : "暂不同意", "second" : { "title" : "确认提示", "message" : "进入应用前，你需先同意&lt;a href=\"https://shop.baihuitimes.com/register.html\"&gt;《用户协议》&lt;/a&gt; 与 &lt;a href=\"https://shop.baihuitimes.com/protocol.html\"&gt;《隐私政策》&lt;/a&gt;，否则将退出应用。", "buttonAccept" : "同意并继续", "buttonRefuse" : "退出应用" }, "styles" : { "backgroundColor" : "#fff", "borderRadius" : "5px", "title" : { "color" : "#000" }, "buttonAccept" : { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42636857eff3f592f0b7450620884f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159f749de2d98bb47a94cb3135e29a19/" rel="bookmark">
			【容器】docker基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、image镜像相关命令二、docker容器常见命令1. 镜像相关命令：2. 容器相关命令：3. 日志和输出相关命令：4. 网络和端口相关命令： 三、注意事项Reference 一、image镜像相关命令 以下是一些常用的Docker镜像操作命令：
docker pull &lt;image&gt;：从Docker仓库下载（拉取）一个镜像到本地。
docker images：列出本地已下载的镜像列表。
docker rmi &lt;image&gt;：删除本地的一个镜像。
docker run &lt;image&gt;：运行一个镜像创建的容器。
docker build -t &lt;image&gt;:&lt;tag&gt; &lt;Dockerfile路径&gt;：根据Dockerfile构建一个新的镜像。
docker push &lt;image&gt;：将本地的镜像推送到Docker仓库。
docker save &lt;image&gt; -o &lt;输出文件路径&gt;：将一个镜像保存为一个压缩文件。
docker load -i &lt;输入文件路径&gt;：从一个压缩文件中加载镜像。
docker tag &lt;image&gt; &lt;新的标签&gt;：为一个现有的镜像打标签。
docker inspect &lt;image&gt;：查看一个镜像的详细信息。
二、docker容器常见命令 docker是一个容器化平台。
Docker介绍：（官网：https://www.docker.com/get-started）
Docker 是一个开源的应用容器引擎，你可以把它当作一个轻量级的虚拟机。它可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的操作系统，比如 Linux/Windows/Mac 的机器上。Docker 容器相互之间不会有任何接口，而且容器本身的开销极低，这就让 Docker 成为了非常灵活、安全、伸缩性极强的计算资源平台。
以下是一些常见的 Docker 命令：
1. 镜像相关命令： docker images：列出本地的镜像。docker pull &lt;image&gt;：从 Docker 镜像仓库中下载镜像。docker push &lt;image&gt;：将本地的镜像推送到镜像仓库。docker rmi &lt;image&gt;：删除本地的镜像。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159f749de2d98bb47a94cb3135e29a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c87458e5a72af143d00798cd4ad7957/" rel="bookmark">
			aliyun MQTT ：纯透传配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 定义主题 2.添加设备
在阿里平台拷贝连接参数（客户ID，用户名，密码，域名等），配置自己的设备（或者模拟设备的MQTTX客户端）。请参考其它网上资料，具体过程略。
3.下发消息 如果设备上线成功，平台会显示在线。如果设备还订阅了规定的主题，也会显示出来。
只连接，不订阅的，就没有这个主题的显示。
主题右边，有个发布消息按钮。点进入。
输入消息内容，点击确认。设备就会收到数据。这里有个傻逼的设计，阿里的蠢货只允许输入文本，不能输入二进制数据。例如我尝试0x1234，对方设备收到的是"0x1234"字符串。而且另外一个傻逼的设计，回车换行，对方设备只能收到0x0A，收不到0x0D.
4. 消息上行 设备可以发布预定义的主题（在产品的自定义主题时设置的）。
在日志服务，可以查看到设备上行的消息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978f7ad67ddfb43a9e1e0c8b448ec5ac/" rel="bookmark">
			mysql事务隔离级别实现原理全面解读？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 2022-10-17 修正版～2023-02-16 新增～夺命6连call，本文高能全是干货！！！！莫慌本文一一来探究～～～～～来自大三时候码的文章解决不可重复读演示Readview可见性算法规避幻读的演示及解读特殊情况下发生的幻读 探究完了幻读，顺便提一嘴mysql中的锁机制，mysql中的锁有很多大体如下：间隙锁区间详解思考**面试专栏**小咸鱼的技术窝 2022-10-17 修正版～ 修正内容（工作后修正的内容）：
可重复度没有解决幻读，只是极大程度避免了快照读下会发生的幻读情况增加 Mvcc Readview、版本控制链条内容的诠释，帮助读者更好的理解可重复度与幻读的关系增加实验，验证RR隔离级别下，幻读还是有可能发生的，以及诠释发生的原因 2023-02-16 新增～ 更新点：结合自己阅读源码的经验，新增面试专栏，后续会一直更新，如果回答的造成了误解，望斧正。看到并采纳会及时修成。
夺命6连call，本文高能全是干货！！！！ 天天用事务可是你知道事务是怎么来实现的吗？什么叫做事务？事务是什么？mysql中的锁了解嘛？mysql中有哪些锁？mysql中的锁和事务有什么联系？事务有什么特性呢？事务隔离级别有哪几种？不同事务隔离级别解决了什么问题？spring中的事务与mysql中的事务有什么区别？开启事务的方式有哪几种？ 莫慌本文一一来探究～～～～～来自大三时候码的文章 什么叫做事务？事务是什么？
事务： java硬编码角度：保证代码片段伪原子性执行的一种手段sql角度：保证sql语句伪原子执行的一种手段 事务有什么特性？（基本概念不过多解读）
原子性、持久性、一致性、 隔离性 事务隔离级别有哪些？（基本概念不过多解读）
读已经提交、读未提交、可重复读（mysql默认隔离级别）、串行化 不同事务隔离级别解决了什么问题？（先搞清楚有什么问题！下文着重有研究）
事务能解决的问题 脏读：一个事务读取到另一个事务未提交的数据幻读：情况一：开启一个事务，第一次查 name =1 的数据查不到，第二次查到了。情况二：开启一个事务：第一次查 name =1 的数据只有一条，第二次查到了多条。情况三：开启一个事务：第一次查所有数据只有一条，第二次查到了一条以上的数据不可重复读：一个事务内，对于同一条数据的读取，读取 内容 前后不一致（mvcc解决了） 读未提交：啥问题都没解决，不愧是地主家的傻儿子啊💩读已提交：解决了脏读可重复读：极大的避免了 当前读 下幻读的发生、解决了脏读、不可重复读串行化：解决了幻读、脏读、不可重复读 可能很多读者很疑惑，到底可重复度解决了幻读还是没解决呢？我在刚入坑mysql的时候也为此疑惑过，毕竟当初也是看着网上的教程一步步走过来的（网上的资源鱼龙混杂）。要搞明白这个问题首先就要知道什么是幻读？如上事务能解决的问题二
为什么说可重复读隔离级别下极大的避免当前读下幻读的发生、解决了不可重复读呢？（严谨点来说是这一切都是针对mysql下的innodb存储引擎来说的）
解决不可重复读演示 先后开启事务一、事务二，事务一查询 id 为 3 的数据，查到结果如下图一，然后切换事务二查 id 为 3 的数据，查到的结果和下图一一致，紧接着事务一执行下图一中的更新操作，并且提交事务一，事务二接着查 id 为 3 的数据，查到的结果依然和下图一一致。
事务一
事务二
剖析上述图片是如何：解决不可重复读的： 可重复读隔离级别是基于MVCC（版本控制链）解决了不可重复读的问题，而所谓的MVCC即版本控制链，可以这么来理解这个版本控制链：某条数据的各个历史版本的链条，且内部根据修改时间排序。可重复读只会在第一次 select 的时候生成一个 Readview，后续的快照读，都要做判断，是否满足 Readview 可见性，满足才读取反之不读取，这其中的Readview 算法保证了可重复读，解决了不可重复读的问题 不知道读者思考过：快照读、拍快照 Readview 是个什么东西？其实不管是什么高深抽象的名字，在开发上一定都是有他自己的一套运作逻辑的，其实 Readview 就是一个类，里面装载了：Readview 生成时刻的活跃事务id列表、Readview 生成时刻的活跃事务最小id、Readview 生成时刻的已出现过的事务id+1、生成 Readview 的事务id，然后根据这些条件，去版本控制链上依次去做条件判断，找出当前事务可见的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/978f7ad67ddfb43a9e1e0c8b448ec5ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1f6f8c27365a51980c70eee14943a1/" rel="bookmark">
			Laya 在控制面板暴露属性汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//隐藏控制 @property({ type: Boolean }) a: boolean; @property({ type: String, hidden: "!data.a" })//将条件表达式!data.a放在了字符串中，如果a为true（在IDE中为勾选状态），则!data.a返回false，此时hidden属性表示的是显示 hide: string = ""; // 只读控制 @property({ type: Boolean }) b: boolean; @property({ type: String, readonly: "data.b" })//将条件表达式data.b放在了字符串中，如果b为true（在IDE中为勾选状态），则data.b就返回true，此时readonly属性表示只读 read: string = ""; //数据检查机制 @property(String) text1: string; @property({ type: String, validator: "if (value == data.text1) return '不能与a值相同' " }) text2: string = ""; //密码输入 @property({ type: String, password: true }) password: string; //如果true或者缺省，文本输入每次输入都提交；否则只有在失焦时才提交 @property({ type: String, submitOnTyping: false }) submit: string; //输入文本的提示信息 @property({ type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1f6f8c27365a51980c70eee14943a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d689a6dc9c139695d0fe1c2bd80bcb/" rel="bookmark">
			Laya中的脚本与外部的Js之间相互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Laya调用Js
要在LayaAir游戏引擎中调用JavaScript代码，你可以使用LayaAir提供的JavaScript接口。下面是一个简单的示例，展示了如何在LayaAir项目中调用JavaScript函数：
创建一个LayaAir项目，并确保你已经设置好了项目的基本结构。在LayaAir项目中的任意一个类（例如主入口类）中添加以下代码： // 导入JavaScript接口 declare function jsFunction(param: any): any; class Main { constructor() { // 调用JavaScript函数 this.callJSFunction(); } private callJSFunction(): void { // 调用JavaScript函数并传递参数 const result = jsFunction("Hello from LayaAir!"); console.log(result); } } 编译和运行LayaAir项目，确保你的项目能够正常启动。在LayaAir项目的HTML文件中添加一个JavaScript脚本标签，定义jsFunction函数的实现： &lt;script&gt; // 定义JavaScript函数 function jsFunction(param) { console.log("JavaScript function called with parameter: " + param); return "Response from JavaScript"; } &lt;/script&gt; 刷新浏览器，你将在浏览器的控制台中看到如下输出： JavaScript function called with parameter: Hello from LayaAir! Response from JavaScript 这样，你就成功地在LayaAir项目中调用了JavaScript函数并获取了返回值。请根据你的实际需求修改和扩展这个示例代码。
Js调用Laya
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37d689a6dc9c139695d0fe1c2bd80bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d79473148cb7dc3ef83fd3addcb21e/" rel="bookmark">
			mysql中的各种索引大总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为啥不用二叉搜索树？为啥不用平衡二叉（avl）树？为啥不用b-树？为啥用b+树？（重点）索引聚簇索引聚簇索引的局限聚集的数据的优点非聚簇索引介绍组合索引覆盖索引前缀索引前缀索引选择算法全文索引hash索引b-tree索引自适应哈希索引小咸鱼的技术窝 b-tree索引使用的是b+树的数据结构，树有这么多种，那为啥就选择b+树呢？那就从为啥使用b+树开始，到分析其原理的思路一步步分析吧。以下内容针对innodb来说 为啥不用二叉搜索树？ 二叉搜索树定义：
非空左子树的所有键值小于其根结点的键值。非空右子树的所有键值大于其根结点的键值。左、右子树都是二叉搜索树。就是左节点&lt;根节点&lt;右节点。 看下图树太高了。查询效率太低，故不推荐。 为啥不用平衡二叉（avl）树？ 平衡二叉（avl）树定义：
非叶子节点最多拥有两个子节点。非叶子节值大于左边子节点、小于右边子节点。树的左右两边的层级数相差不会大于1。没有值相等重复的节点。 虽然avl树对于二叉树来说是平衡了降低了树的高度，虽然提高了性能，但是数据量大一点的时候，高度依旧很高。毕竟定义一摆在那，非叶子节点怎么找最多也只能有俩个子节点，故不推荐。
为啥不用b-树？ b-树定义：
在一个节点中，存放着数据（包括key和data）以及指针，且相互间隔。
同一个节点，key增序。
一个节点最左边的指针不为空，则它指定的节点左右的key小于最左边的key。右边同理。中间的指针指向的节点的key位于相邻两个key的中间。
B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。
每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。
简单点来说呢，b-树又称多路查找树相对于avl树来说就是每个节点下面可以有多个分叉。至少多于2个叉撒，对于百万级别的数据又是降低了树的高度，虽然提高了性能，但是由于每个索引节点都有存放
data域的指针，而我们计算机每次从磁盘读取数据时以页（4kb）为单位，每次读取4096byte的数据，导致读取单个节点时，可能由于节点过大，每次读出的数据有限，从而增大io次数，故在mysql这种关系型数据库中不推荐。但是b-树还是有它自己的优点的，如果查找的节点，离根节点很近那么查找的效率还是很高的
为啥用b+树？（重点） b+树定义：
内节点不存储data，只存储key和指针；叶子节点不存储指针，存key和data。内节点和叶子节点大小不同。每个节点的指针上限为2d而不是2d+1 b+树相对与b-树来说好的地方就是：
数据只在叶子节点上面才有。解决了b-树非叶子节点过大导致io次数过多的问题。树高更低同时由于非叶子节点不放数据，单个节点能存的关键字更多了，极大的降低了树的层级高度。可以范围查找由于叶子节点之间是有一个有序链表来维护的，进行范围查找十分方便，单向的还是双向的不清楚，先搁着下面测试在来看。全节点遍历更快b+树只需扫描叶子节点，而不是像b-树那样逐层扫描每个节点查询速度更稳定如果是b-树，查离根节点近的速度就快，远的就慢，而b+树数据全在叶子节点，每次查找的速度都相同
到此为啥使用b+树就有底了。那么开始正文。。。。。 索引 索引定义：一种数据结构
按照范围从大到小来说吧，最大的是聚簇索引、非聚簇索引。接着是我们常说的b-tree索引、hash索引，而我们的覆盖索引、前缀索引、组合索引、复合索引、全文索引是基于b-tree、hash索引来说的，还有的就是Innodb引擎独有的自适应哈希索引下面一一展开了来说。
聚簇索引 聚簇索引定义：是一种存储数据的方式，数据与索引在一个文件中。它的辅助索引的叶子节点存储的是指向行的指针。
一般来说innodb是按照主键来进行聚集的，这就意味着被索引的列就是主键列。如果主键不存在，其次就是按照非空唯一性约束来进行聚集，如果这个约束都没得，其次就是按照Innodb它自己生成的一个隐藏主键列来聚集。那么使用聚簇索引有什么优缺点吗？当然是有的。
聚簇索引的局限 如果我们往聚簇索引中插入非顺序的数据时的情况下面
由于新行的主键不一定比前一个大，Innodb不能总是把数据插入到最后一行，因此需要为新行进行寻找位置，从而进行多次随机的io更新数据时innodb有时不得不进行分页，为新行开辟内存空间，这会导致移动大量的数据页面会因为分页变得稀疏不规则从而就会导致一些不规则的碎片产生在没有覆盖索引的情况下，查辅助索引的时候，经常需要回表
而且如果我们按照主键顺序插入行的情况下，使用uuid來聚集也是不好的。也会产生写，到磁盘上的数据被重新读取出来，并且由于位置的不确定，也会导致大量的数据移动 聚集的数据的优点 聚集索引把数据和索引全部放到一个b-tree下面，从聚集索引中取得数据通常比非聚集索引取得的数据更快，因为不需要二次查找。对于范围查询的效率很高，因为数据是有序的 非聚簇索引介绍 非聚簇索引是什么呢？其实我们所说的辅助索引、第二索引啊啥的其实可以理解为就是非聚簇索引。非聚簇索引就是叶子节点的data域中存的不是完整的数据，而是指向磁盘数据的指针。
组合索引 定义：单列索引的组合。我感觉和覆盖索引没啥差别，假设现在有一张表（test）有a,b,c,d,e这么几个字段，其中我们为a，b，c列添加一个索引叫a_b_c，这个就是组合索引。
覆盖索引 定义：索引列已经包含了我们需要查询的数据。其实就是组合索引（复合索引）在特定情况下的又一别称。假设现在有一张表（test）有a,b,c,d,e这么几个字段，其中我们为a，b，c列添加一个索引叫a_b_c，现在select a,b,c from test where a = x1 and b = x2 and c = x3;我们需要查询的数据在辅助索引上面已经有了，此时使用的就是复合索引。
前缀索引 定义：为数据的前面几个字段创建的索引。我个人理解其实就是单列索引的变种。那为什么要为前几个字符创建索引而不是为其全部来创建索引呢？原因也是很简单，这个得结合应用场景来说了。现在有这么一张表，专门是存储家庭地址的，一个地址动不动就是十来个字的长度，如果我们以全部长度来创建索引，那么这个索引文件是超级的大啊。此时创建前缀索引是个不错的选择，可以大幅度压缩索引的大小，那么我们该如何确定前缀索引的长度的呢？这就是涉及到一个算法了。
前缀索引选择算法 不重复的索引值/所有行 = 比值，这个比值接近7的时候，所得到的结果就会越加精确。
全文索引 参考
https://blog.csdn.net/Samdy_Chan/article/details/78138420?utm_medium=distribute.pc_relevant.none-task-blog-blogcommendfrommachinelearnpai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-blogcommendfrommachinelearnpai2-1.edu_weight
hash索引 使用的场景：一些读操作密集的表建议使用hash索引，因为hash索引的查找速度是很快的。但是也有一些局限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d79473148cb7dc3ef83fd3addcb21e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda421d5dedc59fc92051ecedceea31c/" rel="bookmark">
			一文搞懂分库分表算法，通俗易懂（基因法、一致性 hash、时间维度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文搞懂分库分表算法，通俗易懂（基因法、一致性 hash、时间维度）目录 前言分库分表算法-时间维度分库分表算法-基因替换法（使用）分库分表算法-基因替换法（缺点之扩容难）分库分表算法-基因替换法（缺点之容易生成重复订单号）分库分表算法-基因拼接法介绍分库分表算法-基因拼接法使用基因拼接、替换法生成重复订单号数量对比测试分库分表算法之一致性 Hash 法（使用）分库分表算法之一致性 Hash 优缺点小咸鱼的技术窝 前言 最近手上一个系统的访问速度有点慢，老早前用多线程优化过一些接口,将一些复杂 sql 改成单表查询，走内存处理，成功的将 一些 10 多秒的接口优化到 500 ms，但是数据量上来了单表查询效率也有点慢了，不得不考虑进行分库分表了，当然我这里只进行分表，没分库，问就是服务器资源紧张！并借此深入总结一下主流的几种分库还有分表算法。分库分表最繁琐的地方在于迁移数据和比对数据！！！！！！
分库分表算法-时间维度 其实分库分表配置很简单，复杂的是旧数据的迁移还有校对。以及后续需要考虑的扩容。举个例子按时间维度扩容很简单，分库算法：按年对库的总数进行取模。分表算法：按月对表的总数进行取模。用代码实现如下
static int DB_COUNT = 17; static int TABLE_COUNT = 12; public static void main(String[] args) { for (int year = 2023; year &lt; 2040; year++) { System.err.println(year + "年的数据对应：" + getDbIndex(year) + "库"); } System.err.println("---------------"); for (int month = 1; month &lt;= 12; month++) { System.err.println(month + "月的数据对应：" + getTableIndex(month) + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda421d5dedc59fc92051ecedceea31c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad3f19138a9183744e07832603effc7/" rel="bookmark">
			修改mysql的密码（每一步都图文解释哦）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当你想要连接本机数据库时，是不是有可能突然忘记了自己的数据库密码?
在此文中，我们来详细解决一下如何去修改自己的数据库密码，并使用Navicat来连接测试
1.停止mysql服务 打开终端，键入命令,将mysql服务先停止掉，可能会需要密码
sudo /usr/local/mysql/support-files/mysql.server stop 或者打开咱们的系统偏爱设置（有可能停不掉，具体原因为未知）
点击stop后，需要输入本机密码。
2.进入mysql的bin目录 cd /usr/local/mysql/bin/ 3. 调用root账户（这一步要输入mac密码） sudo su 4.安全验证 ./mysqld_safe --skip-grant-tables &amp; 回车以禁止mysql验证功能，mysql会自动重启，偏好设置中的mysql状态会变成running
5.输入./mysql，进入mysql命令模式 ./mysql 6.刷新一下权限 分号不可以少，不然报格式错误
flush privileges; 7.修改并重置密码 这里的' ' 不可以删除
ALTER USER 'root'@'localhost' IDENTIFIED BY '你的新密码'; 列如 ALTER USER 'root' @'localhost' IDENTIFIED BY ‘123456’; 分号不可以丢，所以的引号必须是英文！！！！推荐直接复制
我这里错误就是因为分号是中文符号 。
8.登录mysql 先后执行代码，输入密码看到如下即可
quit exit /usr/local/mysql/bin/mysql -u root -p navicat连接成功
9.常见错误 如果失败报错2003 那么就重新启动一下mysql 执行命令先关闭在开启
sudo /usr/local/mysql/support-files/mysql.server stop cd /usr/local/mysql sudo ./support-files/mysql.server start 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85be7d6bcc60f0527c5b69e7f050d2c/" rel="bookmark">
			Hadoop发行版 Cloudera CDH 6.3.2及CM 安装包下载（阿里云盘 不限速）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CDH（全称Cloudera’s Distribution, including Apache Hadoop）是由Cloudera公司构建的Hadoop稳定发行版，不仅含有 Apache Hadoop，还整合了Hive、Spark等组件。 由于CDH已停止维护，且Cloudera不再为CDH提供免费的下载服务，因此网上很难直接下载到CDH和管理工具CM的安装包。
百度云盘上的资源下载速度极慢，开了会员才下载下来。
现已上传至不限速的阿里云盘：
Cloudera-CDH-6.3.2阿里云盘分享提取码: 2m7a 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08c19292d47e15a6e5cdee60685ec1b/" rel="bookmark">
			yum的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yum YUM ， Yellowdog Updater Modified ，⻩狗升级器 软件仓库：集中分发 .rpm 软件包资源，并解决软件之间的依赖关系 客⼾机：使⽤ yum 查询 / 安装 / 卸载软件 1、准备软件仓库⽬录 CentOS7 安装盘已预先配置成软件仓库，可以直接使⽤ [root@bogon ~]# mkdir -p /repo/cos7dvd [root@bogon ~]# mount /dev/cdrom /repo/cos7dvd //将cdrom⽂件(镜像⽂件)挂载到/repo/cos7dvd mount: /dev/sr0 写保护，将以只读⽅式挂载 [root@bogon ~]# ls /repo/cos7dvd/ CentOS_BuildTag EULA images LiveOS repodata RPM-GPG-KEY-CentOS-Testing-7 EFI GPL isolinux Packages RPM-GPG-KEY-CentOS-7 TRANS.TB //repodata：仓库档案资料 //Packages：软件包⽬录 [root@bogon ~]# vim /etc/fstab //配置开机挂载 /dev/cdrom /repo/cos7dvd iso9660 defaults 0 0 2、更改yum软件源 第 1 步，禁⽤⽆效源 对于⽤不到 / 不能⽤的源（⽐如官⽅源），可以直接删除 配置位置： /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08c19292d47e15a6e5cdee60685ec1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc923ca6cb2d3efd2b406ff9db725b5a/" rel="bookmark">
			SSA-SVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import random from matplotlib import pyplot as plt import scipy.io as scio from sklearn import svm from sklearn import preprocessing from sklearn.metrics import accuracy_score '''优化函数''' #定义适应函数，以测试集的错误率为适应度值 def fun(X): #3.训练svm分类器 classifier=svm.SVC(C=X[0],kernel='rbf',gamma=X[1]) # ovr:一对多策略 classifier.fit(train_wine,train_label.ravel()) #ravel函数在降维时默认是行序优先 #4.计算svc分类器的准确率 #tra_label=classifier.predict(train_wine) #训练集的预测标签 tes_label=classifier.predict(test_wine) #测试集的预测标签 output = 1 - accuracy_score(test_label,tes_label)#计算错误率，如果错误率越小，结果越优 return output ''' 种群初始化函数 ''' def initial(pop, dim, ub, lb): X = np.zeros([pop, dim]) for i in range(pop): for j in range(dim): X[i, j] = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc923ca6cb2d3efd2b406ff9db725b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9351d15750fead384e21b4394eb85de7/" rel="bookmark">
			带submodule的git仓库自动化一键git push、git pull脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 很久没写博客了，今天难得闲下来写一次。
不知道大家在使用git的时候有没有遇到过这样的问题：发现git submodule特别好用，适合用于满足同时开发和部署的需求，并且结构清晰，方便我们对整个代码层次有一个大概的了解。但是很烦人的一点就是每次做完开发都要一个一个进入仓库提交更改，很浪费时间，也浪费力气。
（尤其是我这种子模块里带子模块的重度用户）
（这只是顶层模块，一共大概有10多个仓库）
于是哥们奋发图强，为了一劳永逸，终于是憋了两坨大的出来，大家只要把下面的两个脚本放在顶层的仓库目录下就可以开开心心地使用了
首先是自动pull脚本（如果有merge冲突还是不要用为好，纯部署用用就行了）
#!/bin/bash # 配置凭据帮助器，使用可自动提供凭据的方式（例如使用 cache，store，或者其他支持的方式） git config --global credential.helper store # 获取当前目录下的所有子模块路径 submodules=$(git submodule foreach --recursive --quiet 'echo "$PWD/$path"') # 移除路径中的最后一个文件夹 submodules=$(echo "$submodules" | xargs -I{} dirname {} | sort | uniq) # 去掉根目录 root_dir=$(git rev-parse --show-toplevel) submodules=$(echo "$submodules" | sed "s|$root_dir/||") # 循环遍历子模块并执行 git pull for submodule in $submodules; do echo "Updating submodule: $submodule" ( cd "$submodule" # 执行 git pull，注意：这里假设你的凭据已经被缓存 git pull ) done git pull echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9351d15750fead384e21b4394eb85de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf63aa5b218c03e0d0d08a50bb4f322/" rel="bookmark">
			OmniGraffle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 在mac上安装OmniGraffle，找一个正版或者啥的都行，安装好后，可以直接在网上找一个激活码，然后找到软件的许可证，进行添加即可。
使用 新建空白页
然后图形啥的看一眼工具栏就知道了，颜色形状还是挺多的。
输入公式 OmniGraffle不能直接输入公式，可以安装MacTeX(安装包约5G)，官网下载，然后直接安装即可。安装后，会有如下三个软件，点击第一个：
打开后，输入latex公式即可，最后将公式复制或者直接拖入到OmniGraffle中需要的版面即可.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd9e3ee4edfa482cc471a4a5ff98540/" rel="bookmark">
			TableStructureRec: 表格结构识别推理库来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言lineless_table_rec: 无线表格识别库安装使用结果 wired_table_rec：有线表格识别库安装使用结果 写在最后 引言 TableStructureRec 仓库是用来对文档中表格做结构化识别的推理库，包括来自 PaddleOCR 的表格结构识别算法模型、来自阿里读光有线和无线表格识别算法模型等。
该仓库将表格识别前后处理做了完善，并结合 OCR，保证表格识别部分可直接使用。
该仓库会持续关注表格识别这一领域，集成最新最好用的表格识别算法，争取打造最具有落地价值的表格识别工具库。
欢迎大家持续关注。
在这里，我们做的工作主要包括以下两点：
将模型转换为 ONNX 格式，便于部署完善后处理代码，与 OCR 识别模型整合，可以保证输出结果为完整的表格和对应的内容 lineless_table_rec: 无线表格识别库 lineless_table_rec库源于阿里读光-LORE 无线表格结构识别模型。
该模型主要解决无线表格结构识别问题，具体包括文档中涉及到一些三线表之类表格结构识别。对于有线的表格支持较差。
安装 pip install lineless_table_rec 使用 from lineless_table_rec import LinelessTableRecognition engine = LinelessTableRecognition() img_path = "tests/test_files/lineless_table_recognition.jpg" table_str, elapse = engine(img_path) print(table_str) print(elapse) 结果 wired_table_rec：有线表格识别库 wired_table_rec库源于阿里读光-表格结构识别-有线表格。
该模型主要解决拍照和截屏场景下有线结构识别问题。
安装 pip install wired_table_rec 使用 from wired_table_rec import WiredTableRecognition table_rec = WiredTableRecognition() img_path = "tests/test_files/wired/table_recognition.jpg" table_str, elapse = table_rec(img_path) print(table_str) print(elapse) 结果 写在最后 目前 PaddleOCR 中表格识别暂未整理到这个仓库中，后续会整理进来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bd9e3ee4edfa482cc471a4a5ff98540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d0f80112040039746541d09ca2d507/" rel="bookmark">
			com.baomidou.dynamic.datasource.exception.CannotFindDataSourceException: dynamic-datasource can not
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们开发的过程中，可能遇到这种数据源找不到的报错，具体报错示例如下所示：
导致下面报错的原因是因为在pom文件中引入了多数据源依赖
&lt;!-- mybatis-plus 多数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; 可能我们自己没有主动引入这个依赖，但是引入别的jar包的时候，被动引入了这个依赖，引入这个依赖，但是我们并没有使用，或者是没有指定primary，在我们执行代码时，涉及数据库操作，例如调用一个查询接口，去查询数据库，就会报这个错
解决的方式有两种，第一种若是我们不需要使用多数据源，那么我们直接在pom删掉这个依赖即可，第二种，若是我们需要使用多数据源，那么在yaml文件中新增多数据源的配置即可，数据源配置如下：
spring:
application:
name: xxx
datasource:
dynamic:
primary: master
strict: true
datasource:
master:
url: xxxxx
username: xxx
password: xxx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb346d588b689203ee7fb237c24ef5c/" rel="bookmark">
			前端工程、静态代码、Html页面 打包成nginx 的 docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建一个 mynginx的目录
2. 将前端代码文件夹（比如叫 front ）复制到 mynginx 目录下
3. 在mynginx 目录下创建一个名为Dockerfile 的文件（文件名不要改），文件内容如下：
# 使用官方的 Nginx 镜像作为基础镜像 FROM nginx:latest RUN mkdir -p /app # 将工作目录设置为 /app WORKDIR /app # 将宿主机 front目录下的文件复制到容器的 /app 目录 # 注意这里不要写绝对路径 COPY front/* /app # 删除nginx容器中代码目录中自带的文件 RUN rm /usr/share/nginx/html/* # 将/app 中所有文件复制到 /usr/share/nginx/html/ RUN cp /app/* /usr/share/nginx/html/ # 暴露 80 端口供外部访问 EXPOSE 80 # 容器启动时运行 Nginx CMD ["nginx", "-g", "daemon off;"] 一定要注意，COPY 这一步 ，将宿主机上front文件夹中的文件复制到容器中，front目录一定不要写成绝对路径，我之前写的是绝对路径（/opt/myimages/mynginx/front/*）报错如下：
ERROR: failed to solve: lstat /var/lib/docker/tmp/buildkit-mount2707332014/opt/myimages/mynginx/front: no such file or directory
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb346d588b689203ee7fb237c24ef5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d45dd4bfa2814f4f718eb38acb377e1/" rel="bookmark">
			Ubuntu分区空间调整方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于安装ubuntu系统空间分配不合理，导致使用一段时间后系统/分区空间不足，因此希望在原有数据不丢失的情况下，将/home分区空间转移一部分到/分区。
搜索一段时间后终于找到了方法，具体步骤如下：
一、在ubuntu系统中安装gparted 转移空间使用gparted工具，安装命令
sudo apt-get install gparted 使用sudo gparted启动后，界面如下
图片来自
如何使用GParted扩展Ubuntu系统根目录
可以查看各个分区大小，但带有钥匙图标的分区并不能使用resize来调整大小，因此需要在使用U盘作为启动盘，在ubuntu试用模式中操作
二、制作ubuntu启动盘 在win系统中操作，参见链接使用UltraISO制作ubuntu安装u盘启动盘图文教程，需要自行下载UltraISO（软碟通)、相应ubuntu系统ISO文件。
三、重新分配空间 u盘启动盘制作成功后，需要在BIOS中设置BIOS选项，将其设置为U盘启动。
设置成功并进入ubuntu试用模式后，启动gparted软件，可以发现钥匙图标已经不见了。
此时可以使用resize来缩小/扩大相应空间，但要注意前后方向，最后apply即可。可参考Ubuntu 分区空间调整 —— gparted的第三部分：gparted使用
若不清楚各个分区对应挂载点，可以提前使用df、fdisk等命令提前记下名称和大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025ced98edb56f27f5bbc43486198838/" rel="bookmark">
			【论文解读】在上下文中学习创建任务向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简要介绍
大型语言模型（LLMs）中的上下文学习（ICL）已经成为一种强大的新的学习范式。然而，其潜在的机制仍未被很好地了解。特别是，将其映射到“标准”机器学习框架是具有挑战性的，在该框架中，人们使用训练集S在某些假设类中找到最佳拟合函数f (x)。在这里，论文通过展示ICL学习到的函数通常有一个非常简单的结构：它们对应于transformerLLM，它的唯一输入是查询x和从训练集计算出的单个“任务向量”。因此，ICL可以看作是将S压缩为一个单个的任务向量θ(S)，然后使用这个任务向量来调制transformer以产生输出。论文通过对一系列模型和任务的全面实验来支持上述主张。
二、研究背景
大型语言模型在过去的几年中有了显著的改进。这些模型的一个显著特性是，它们可以从很少的演示中学习新的规则。例如，一个模型可以提示输入“苹果→红色，石灰→绿色，玉米→”，并产生输出“黄色”。因此，该模型仅学习了一个基于两个例子的映射，它可以正确地应用于新的例子。这种能力，被称为上下文学习（ICL），已被广泛使用，产生了令人印象深刻的实证结果。
目前还不清楚ICL是否以这种方式运行，因为预测是通过T（[S，x]）执行的，其中T通常是一个自回归transformer，而[S，x]是S和x中的令牌的连接。因此，在一般情况下，它可以是一个任意的函数，通过这个函数来产生输出。这可以包括“非参数”方法，如最近邻方法。最近的工作已经开始探索这个问题。例如，研究表明，当从头训练transformer在上下文中执行线性回归时，新兴的学习算法类似于随机梯度下降。然而，对于执行更复杂的自然语言任务的LLM，论文根本不清楚假设空间可能是什么。
论文的观点也与软提示有关，因为这两种方法都针对特定的任务调节transformer的功能。然而，在ICL中，任务向量是通过正向传递来计算的，而不是进行微调。
论文的贡献包括提出一个基于假设类的ICL机制观点，并进行实验来验证论文对一系列公开的LLM和一组不同的任务的看法。论文的研究结果进一步加深了对ICL的理解，并可能对LLM有效适应执行特定任务具有实际意义。
三、ICL的假设类视图（A Hypothesis Class View of ICL）
受学习理论的假设类观点的启发，论文的目标是了解ICL是否将演示集S映射到查询x上的一个函数，以及这个映射是如何发生的。具体来说，论文试图看看ICL是否将S转换为θ——某个假设空间内的函数的“参数”。论文的实证研究结果表明，这一观点是适用的，阐明了假设空间的结构，其中ICL可以被看作是运作的。
3.1理论框架
论文使用T表示仅限解码器的transformerLLM，S表示用作ICL输入的演示集（即训练示例）集，x表示要求ICL提供输出的查询。论文使用T（[S，x]）来表示ICL在S和x的连接上的输出。
为了证明ICL在一个假设空间内运作，论文的目的是证明其潜在的机制可以分为两部分：
一种“学习算法”（用A表示），它将S映射到一个“任务向量”θ，独立于查询x。考虑到注意层可以同时访问S和x，这种独立性并非简单。
一个“规则应用程序”（用f表示），它基于θ≡A (S)将查询x映射到输出，而不直接依赖于S。同样，这种独立性并非简单。
因此，论文考虑从一组演示和查询到预测输出的以下映射：
3.2一个被提出的假设类
上述框架有许多可能的实现，它们对应于A和f的不同选择。接下来，论文将描述论文所关注的实现，这自然地遵循transformer架构。论文考虑一个如图1所示的ICL设置，其中输入以一个查询x（即Corn）结束，后面跟着一个“→”符号。如上所述，论文认为学习由两个步骤组成：基于训练样本S计算一个参数向量θ，并将由该参数向量定义的规则应用于查询x。对于transformer来说，一个大概简单的方法是让→表示的第一个L层计算θ，然后让剩下的层将θ和x作为输入并产生一个输出。见图1。回想一下，S和x在任何层都可以访问transformer，这对论文的观点是一个挑战。
在下面的章节中，作者将解决这个挑战，并提出实验来验证论文的观点。也就是说，论文证明了可以在执行ICL的LLMs的正向传递中隔离A和f。论文还表明，θ向量是可解释的，并对应于学习到的任务。
四、假设类视图的有效性（Validity of the Hypothesis Class View）
论文首先证明，将前向传递分离成3.2中定义的两个不同的分量A和f，保持了ICL的高精度。
4.1分离A和f
论文在常规的正向传递中面临着一些挑战：首先，对应于A的初始L层，更新→的表示来创建θ，可以处理查询x。因此，它们可能依赖于x，产生θ对x的不必要的依赖。第二，对应于f的其余层可以直接访问S，而不是只使用x和θ。
4.2任务和模型
论文考虑了横跨4个类别的18个任务：算法、翻译、语言和事实知识。为简单起见，论文将自己限制在单令牌输出中。在表1中描述了这些任务的一个具有代表性的子集。A.1提供了一个完整的详细表，以及关于数据的更多信息。
论文使用多个开放LLMs： LLaMA 7B、13B、30B和Pythia 2.8B、6.9B和12B。
4.3查找L
论文在3.2中描述的机制有一个自由参数——a结束和f开始的L层。论文使用不同选择L的（A，f）实现，并在开发集上评估准确性，以找到最佳层。
图3显示了L不同选择的开发集上的精度。论文在这里关注LLaMA模型。有趣的是，所有模型在相似的中间层都表现出性能峰值，而不管它们的参数和层数差异。
4.4基于假设的预测的准确性
接下来，论文比较（A，f）机制与执行ICL的准确性。对于每个模型和任务，论文评估了以下三个过程：
常规：LLM对演示S和查询x的应用程序。即T（[S，x]），如常规ICL。
假设：论文从4.1中提出的过程，其中A使用一个虚拟x'生成θ，f（·；θ）通过在[x，→]上运行transformer，并在→的L层打θ补丁。
基线：LLM仅在x上的向前传递，没有演示s，即T（[x，→]）。这与论文分离的程序中f的应用相同，但没有修补θ。
图4显示了每个模型的所有任务的平均精度。完整的结果将在表6和A.2中报告。在所有模型中，论文的程序保持了常规ICL的80-90%左右的准确性，而基线仅达到10-20%。这表明论文提出的A和f分离提供了ICL的过程很好的经验近似。
五、任务向量的鲁棒性（Robustness of Task Vectors）
在论文的设置中，θ来自于S和一个虚拟查询x'。检查θ对这些输入的变化的鲁棒性是很自然的。直观地说，如果它代表任务，它应该在不同的S和x'值之间保持稳定。
为了验证这一点，论文使用LLaMA 7B生成每个任务50个不同的任务向量，并进行了两次分析。
θ的几何形状 t-SNE降维（图5）显示，任务向量形成了不同的集群，每个集群都包含单个任务的任务向量。图9进一步显示了同一类别任务之间的接近性，强化了它们封装任务理解的概念。
θ的可变性 图8显示了任务内和任务之间的距离的直方图。可以看出，同一任务中的向量比不同任务之间的向量更接近，说明θ在任务中是稳定的，不受x'或S的高度影响。
六、θ补丁的控制（Dominance of θ Patching）
论文阻止f直接访问S。然而，在ICL的常规向前传递中，最后一个令牌可以注意到S。论文验证了即使在这种情况下，f主要使用任务向量θ，而没有直接访问演示S。论文使用一对任务，a和B，共享输入空间但不同的输出。论文首先使用一个“常规”向前传递，其中论文为模型提供了任务A（表示为SA）的演示S，以验证模型是否可以使用ICL执行这个任务。然后，论文做一个“冲突”向前传递，仍然提供SA，同时注入θB。详见A.1中的图6。
在表2“常规”向前传递在任务A上显示出较高的准确性（90%+）。然而，“冲突”向前传递在任务B上产生较高的精度，对应于注入的任务向量θ。这意味着该模型主要依赖于θ，在很大程度上忽略了任务A的演示S。论文注意到任务B的准确性略低，可能与图6中看到的性能下降一致，并可能进一步受到S的影响。
七、解释θ（Interpreting θ）
学习到的向量θ直观地捕获了关于S所证明的任务的信息。在这里，论文提供了支持这种解释的证据。由于θ是transformer的中间隐藏状态，论文可以使用词汇投影方法。也就是说，论文检查了由隐藏状态引起的词汇表分布中的顶部令牌。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/025ced98edb56f27f5bbc43486198838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcfc5692f2b6a7bbc87c6bf42af3657/" rel="bookmark">
			Altium Designer学习笔记11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画一个LED的封装：
使用这个SMD5050的封装。
我们先看下这个芯片的功能说明：
5050贴片式发光二极管：
XL-5050 是单线传输的三通道LED驱动控制芯片，采用的是单极性归零码协议。
数据再生模块的功能，自动将级联输出的数据整形转发，保证数据串联传输过程不衰减。
XL-5050 芯片采用自动整形转发技术，使得该芯片的级联个数不受信号传送的限制，仅仅受限刷屏速度要求.例如我们设计一个 1024 级联，它的刷屏时间 1024 X0.4 X2＝ 0.8192ms（芯片的数据延迟时间为0.4 µs），不会有任何闪烁的现象。
3号引脚是接地的。 查看下外形尺寸：
我们根据这个尺寸图来画封装图：
然后将封装库放置到PCB板上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e9bf6dcb5f5af1f3b1418c90e76509/" rel="bookmark">
			一文叫你如何对css 降级兼容老旧浏览器| postcss 后处理css优雅降级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。
PostCSS 在工业界被广泛地应用，其中不乏很多有名的行业领导者，如：维基百科，Twitter，阿里巴巴， JetBrains。PostCSS 的 Autoprefixer 插件是最流行的 CSS 处理工具之一。
PostCSS 接收一个 CSS 文件并提供了一个 API 来分析、修改它的规则（通过把 CSS 规则转换成一个抽象语法树的方式）。在这之后，这个 API 便可被许多插件利用来做有用的事情，比如寻错或自动添加 CSS vendor 前缀。
安装 npm install -D postcss postcss-cli postcss-preset-env 编辑配置文件 安装的同级目录下，新建postcss.config.js 并配置如下内容
const postcssPresetEnv = require('postcss-preset-env') module.exports = { plugins: [ postcssPresetEnv(/* 配置的参数 */) ] } 新建src文件夹，并将你需要处理的css放到该目录 如 src/index.css
cmd 执行命令处理 npx postcss-cli src/index.css -o dist/index.css 参考 postcss github中文文档 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6982637e742798d1a51f153623a831c/" rel="bookmark">
			模拟量采集----测量输入的电流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生活中的模拟量有很多
大多都为电压信号和电流信号
今天讲如何测量输入的电流信号
通过欧姆定律可知
电流测量的测量：是将电流加载在固定阻值的电阻上，来测量这个电阻二端的电压
最后反算出电流的大小
所用的公式是I=U/R
我们使用仿真软件来看测量电路
通过这个电路图的蓝色线可知构成电压跟随器
通过这个电路图的红色线可知电流大部分通过R4到地
所以在R4的上端形成1.49V的电压
6*249/1000=1.494V
这个1.494V的电压经过49.9和32.4的分压得到587毫伏的电压
和分压计算的值一致
根据反相运放的输出公式
输出电压/输入电压=-（R2/R1）
将图中的电阻值带入公式中得
输出电压=（32.4/49.9）*输入电压1.49
输出电压=1.49*0.649299=967毫伏
和仿真的结果一致
同理
细心的小伙伴可能已经发现输出和输入的电压已经不是倍数关系了
原因就在于输入的电压已经超过运放的电源电压
3.72&gt;3.3V
所以运放输出不到那么高的电压
接上示波器就可以看到这种情况
我们将运放的供电电源增加看下
所以
最终的仿真电路图如下：
满量程情况下
输出等于4.96*0.649299=3.2205V和仿真结果一致
注意：这个位置的电阻的封装和耐压尤其需要注意哈
小心成功的点燃一颗电阻！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cfe3463c06bf29c07329193d437bc57/" rel="bookmark">
			关于WSL安装、修改安装位置、修改镜像源等的记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装过程二、更换安装位置1. 查看所有分发版本2. 导出分发版为tar文件到H盘3. 注销当前分发版4. 重新导入并安装分发版在H:\wsl:\ubuntu5. 设置默认登陆用户为安装时用户名（在powershell中输入） 三、更换镜像源1. 进入wsl，再进入该目录2. 复制一份源文件备份3. 更改sources.list中的内容 四. 更改github的访问地址1. 更改hosts文件2. 测试ping通 总结 前言 wsl中ubuntu的安装、更换安装位置、更换镜像源等过程的记录，以供下次安装参考。
一、安装过程 官方描述的很详细，见设置 WSL 开发环境
二、更换安装位置 1. 查看所有分发版本 wsl -l -v 2. 导出分发版为tar文件到H盘 wsl --export Ubuntu H:\ubuntu.tar 3. 注销当前分发版 wsl --unregister Ubuntu 4. 重新导入并安装分发版在H:\wsl:\ubuntu wsl --import Ubuntu H:\ubuntu H:\wsl\ubuntu.tar --version 2 完成之后重新进入该分发版。
5. 设置默认登陆用户为安装时用户名（在powershell中输入） ubuntu config --default-user &lt;你之前的用户名&gt; 三、更换镜像源 1. 进入wsl，再进入该目录 cd /etc/apt/ 2. 复制一份源文件备份 cp -a sources.list sources.backup.list 3. 更改sources.list中的内容 sudo vim sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cfe3463c06bf29c07329193d437bc57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8da2acebc0a516cecbebe7c57eb074b/" rel="bookmark">
			Promise.all如果其中之一失败，怎么能够拿到其他成功的结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Promise.all 的基础介绍 作用：Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
参数：由多个Promise实例组成的数组
const p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况。
（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
Demo–Promise.all如果其中之一失败，怎么能够拿到其他成功的结果 该实例的最终结果被Promise.all的catch方法捕获 如果f3没有自己的catch方法，就会调用Promise.all()的catch方法。
let f1 = new Promise((resolve,reject)=&gt; { setTimeout(()=&gt; { resolve('f11111') },2000) }) let f2 = new Promise((resolve,reject)=&gt; { setTimeout(()=&gt; { resolve('f22222') },1000) }) let f3 = new Promise((resolve,reject)=&gt; { setTimeout(()=&gt; { reject('err-f33333') },3000) }) let a = [f1,f2,f3] // promise.all中的异步请求是并发执行的，但是最终的返回结果是按照最初的顺序执行排列好的 Promise.all(a).then(data=&gt; { console.log(data) }).catch(err=&gt; { console.log('糟糕出错了') }) //执行结果：糟糕出错了 如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8da2acebc0a516cecbebe7c57eb074b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44910ded4d3bbf710618ce32ec31626b/" rel="bookmark">
			rocketmq 集群搭建 rocketmq最新版本集群，rocketmq双主双从异步集群 rocketmq三台机器集群 虚拟机搭建rocketmq5.1.4集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. rocketmq 版本：5.1.4
集群规划：
介绍：
2. 准备三台虚拟机机器，分配2g内存。（内存够用可以3g。2g用到了1.7g）：三台机器的/etc/hosts修改 worker1. worker2. worker3
可查看之前文章设置别名的
3. ssh免密登录设置,
可以查看我之前的文章
# cd ~ # 进入ssh文件夹 如果没有。可以ssh 下别的机器，就会生成 cd .ssh # woker1 设置好之后，就copy到其他机器 # 同理 去设置woker2, worker3 ssh-keygen -t rsa #copy ssh-copy-id worker2 # ssh-copy-id worker3 4. 在上篇文章中，设置了虚拟机的第一台服务器。将其中的rocketmq 文件发送到其他两台服务器；
5. 文件路径：
文件路径
/opt/module/rocketmq-all-5.1.4-bin-release
# 日志 /opt/module/rocketMQ
6. worker2机器 broker-a设置：
# Licensed to the Apache Software Foundation (ASF) under one or more # contributor license agreements. See the NOTICE file distributed with # this work for additional information regarding copyright ownership.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44910ded4d3bbf710618ce32ec31626b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbbd8ef8fed4ad6be9c6a26cfa5d9ae/" rel="bookmark">
			JavaScript 用循环绑定事件制作tab栏切换 ，点赞加关注更多内容持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个用for循环，循环绑定事件事件来制作的tab栏切换模板，用事件委托制作当然也可以
先来看看效果： 思路： 其实这里面最重要的一个思想就是“排他思想”。意思就是将别人的样式都去除，然后再加上自己的样式，这样就可以实现点击相应的tab栏按钮，其它按钮的样式全部消失，加上自己的样式。
直接附上全部代码，全部拷贝到自己的编辑器里就可以运行，我这里只是提供一个模板一个实现思路，感兴趣的小伙伴可以拷贝到自己的电脑上，更改样式和内容，实现更丰富的效果。 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="style.css" rel="stylesheet" type="text/css" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; /* 设置全局样式 */ * { margin: 0; padding: 0; list-style: none; } /* 设置导航条样式 */ ul { width: 500px; height: 50px; margin: 0px auto; } /* 设置内容容器样式 */ ol{ margin: 0px auto; } /* 设置每个导航tab的样式 */ ul li { float: left; width: 100px; height: 50px; line-height: 50px; text-align: center; cursor: pointer; } /* 设置导航tab hover时的样式 */ ul li:hover { background-color: rgb(228, 228, 228); } /* 设置内容项容器的样式 */ ol { width: 500px; height: 100px; } /* 设置每个内容项的样式 */ ol li { display: none; width: 500px; height: 100px; background-color: rgb(238, 238, 238); box-shadow: -5px 5px 5px rgb(197, 197, 197); text-align: center; line-height: 100px; } /* 设置选中tab的样式 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbbd8ef8fed4ad6be9c6a26cfa5d9ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fa513c9600711176cc80cf5877f859/" rel="bookmark">
			RGMII回环：IDDR&#43;ODDR&#43;差分接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、实验内容二、原理解释三、程序1、顶层文件：2、子模块2.1 oddr模块2.2、iddr顶层模块2.3、iddr子模块 3、仿真4、注意5、下载工程及仿真 一、实验内容 1、通过IDDR和ODDR的方式完成RGMII协议；
2、外部接口使用OBUFDS、IBUFDS转换成差分接口；
3、数据转换及传输：顶层文件自己产生100次数，每个数都是8bit，传给oddr模块，oddr模块经过转换再传出4bit，这4bit数据再输出到外部（仿真的时候，可以接到输入，实际板测可以用跳线帽短接，也可以传给另一块板子，进行回环实验），4bit数据重新从顶层输入到iddr模块，iddr模块经过转换，输出8bit数据，输出到外部。
二、原理解释 本实验参考了部分文章，一些原理请直接看以下文章：
1、VIVADO IDDR与ODDR原语的使用
2、Xilinx 差分信号 LVDS传输实战
三、程序 1、顶层文件： 这里面的diff定义=lvds，之所以定义成diff，是老大说这样对于IO的适用范围更大。
顶层模块例化了一个iddr_top模块，一个PLL模块（输入50mhz系统时钟，输出125mhz高速时钟采集数据），一个oddr模块。
`timescale 1ns / 1ps module I_ODDR_ETH_DIFF_TOP( //System Interfaces input sclk , input rst_n , input rx_clk_p ,//IDDR IN CLK input rx_clk_n ,//IDDR IN CLK input [ 3:0] rx_data_p ,//IDDR IN DATA input [ 3:0] rx_data_n ,//IDDR IN DATA output tx_clk_p ,//ODDR CLK output tx_clk_n ,//ODDR CLK output [ 3:0] tx_data_p ,//ODDR DATA output [ 3:0] tx_data_n ,//ODDR DATA output gb_out_clk_p ,//IDDR OUT CLK output gb_out_clk_n ,//IDDR OUT CLK output [ 7:0] gb_out_data_p ,//IDDR OUT DATA output [ 7:0] gb_out_data_n //IDDR OUT DATA ); wire [3:0] rx_data; wire [3:0] tx_data; reg [ 7:0] gb_tx_data ; wire phy_rst_n ; wire tx_data_ctrl ; reg gb_tx_data_en ; reg [ 7:0] gb_tx_cnt ; wire gb_tx_clk ; wire gb_out_clk ; wire [7:0] gb_out_data ; clk_wiz_1 clk_wiz_1_inst ( // Clock out ports .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fa513c9600711176cc80cf5877f859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe83711c7b51caa3a27cd067308cb132/" rel="bookmark">
			基于融合多策略的混沌灰狼搜索算法MSGWO求解单目标优化问题cec2005函数测试附matlab代码 论文实验报告皆可参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 灰狼算法是一种基于群体智能的优化算法，它模拟了灰狼群体的捕食行为，通过模拟狼群的社会结构和行为特点来进行优化搜索。在实际应用中，灰狼算法已经被证明在解决单目标优化问题方面具有很好的效果。
在灰狼算法的基础上，研究人员提出了一种新的算法——混沌灰狼搜索算法（MSGWO），它通过引入混沌序列来增加搜索的多样性，从而提高了算法的全局搜索能力。同时，MSGWO算法还融合了多种策略，使得算法更加灵活和高效。
本文将重点介绍基于融合多策略的混沌灰狼搜索算法在求解单目标优化问题cec2005函数测试原理方面的应用。cec2005函数集是一个常用的测试函数集合，用于评估优化算法的性能。我们将以cec2005函数测试原理为基础，探讨MSGWO算法在解决这些函数测试中的优化效果。
首先，我们需要了解cec2005函数测试原理。cec2005函数测试是一种常用的测试方法，它包含了一系列的标准测试函数，用于评估优化算法在处理不同类型问题时的性能表现。这些测试函数涵盖了单峰函数、多峰函数、旋转函数等不同类型的函数，可以全面地评估优化算法的搜索能力和收敛速度。
接下来，我们将介绍混沌灰狼搜索算法MSGWO在应用cec2005函数测试原理时的优化过程。MSGWO算法通过融合多种策略和引入混沌序列，能够在搜索过程中快速收敛到全局最优解，并具有较强的鲁棒性和稳定性。我们将以具体的算法流程和优化实例来展示MSGWO算法在cec2005函数测试中的优化效果，从而验证其在单目标优化问题中的实用性和有效性。
最后，我们将对MSGWO算法在应用cec2005函数测试原理中的优化效果进行总结和分析。通过对比实验结果和分析算法性能，我们可以得出结论：基于融合多策略的混沌灰狼搜索算法在解决单目标优化问题cec2005函数测试中具有较好的优化效果和实用性，能够有效地应用于实际工程和科研领域。
总之，基于融合多策略的混沌灰狼搜索算法MSGWO在求解单目标优化问题cec2005函数测试原理方面具有较好的应用前景和研究价值。随着优化算法领域的不断发展和深入研究，MSGWO算法将会在实际应用中发挥越来越重要的作用，为解决实际问题提供更加有效的优化方案。
📣 部分代码 %% 清空环境变量warning off % 关闭报警信息close all % 关闭开启的图窗clear % 清空变量clc % 清空命令行​%% 导入数据res = xlsread('数据集.xlsx');​%% 划分训练集和测试集temp = randperm(357);​P_train = res(temp(1: 240), 1: 12)';T_train = res(temp(1: 240), 13)';M = size(P_train, 2);​P_test = res(temp(241: end), 1: 12)';T_test = res(temp(241: end), 13)';N = size(P_test, 2);​%% 数据归一化[p_train, ps_input] = mapminmax(P_train, 0, 1);p_test = mapminmax('apply', P_test, ps_input);t_train = ind2vec(T_train);t_test = ind2vec(T_test ); ⛳️ 运行结果 🔗 参考文献 本程序参考以下中文EI期刊，程序注释清晰，干货满满。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe83711c7b51caa3a27cd067308cb132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d79960ab14b01f78c5aaaf107bc0b2/" rel="bookmark">
			[OpenAirInterface-01]什么是OAI？OAI在github中源代码的存放结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：什么是软件无线电SDR第1章 什么是OAI（OpenAirInterface）1.1 来自官网的概述1.2 来自github的概述1.3 来自我的解读 第2章 什么是OSA2.1 OSA概述：2.2 OSA联盟职责2.3 OpenAirInterface github成员的角色 第3章 常见的其他问题3.1 OAI包括哪几部分3.2 OAI 支持哪些无线技术和无线系统？（1）LTE（2）5G 3.3 支持哪些射频硬件平台？3.4 谁可以使用OAI？3.5 谁在建设OAI？3.6 OpenAirInterface与ETTUS N210 RF一起工作吗？3.7 运行OAI需要考虑哪些射频因素？3.8 CPU要求是什么？3.9 平台软件需求是什么？3.10 UE的要求是什么？3.11 有教程吗？3.12 我如何贡献/报告错误？3.13 有持续集成框架吗？3.14：是否需要在手机上启用任何特定设置？3.15 使用什么配置文件作为起点？3.16：可以为任何波段使用上述配置文件吗？3.17：有时手机不想连接到OAI。有什么问题 第4章 OAI在github中源代码的存放结构4G/5G RAN目标系统的架构LTE数据处理、仿真流程协议栈说明build目标代码nfapi openair1 PHY与openair2 MAC接口openair1 (L1: PHY+RF）openair2 （L2 + L3)openair3 前言：什么是软件无线电SDR 软件定义的无线电(Software Defined Radio，SDR) 是一种无线电广播通信技术，它基于软件定义的无线通信协议而非通过硬连线实现。
频带、空中接口协议和功能可通过软件下载和更新来升级，而不用完全更换硬件。
OpenAirInterface是软件无线电SDR的一种实现。
第1章 什么是OAI（OpenAirInterface） 1.1 来自官网的概述 OpenAirInterface是一种开放软件，汇集了来自世界各地的开发人员，他们共同构建无线蜂窝接入网络（RAN）和核心网络（CN）技术.
1.2 来自github的概述 OAI是一个开源的硬件和软件无线技术平台（模拟、仿真和实时），用于部署具有高度真实感的模拟无线蜂窝网络。
OAI github源代码：oai / openairinterface5G · GitLab
1.3 来自我的解读 OpenAirInterface不仅仅包括无线空口, 还包括整个无线接入网RAN，也包括核心网Core。
OpenAirInterface不仅仅包括4G LTE, 还包括5G，也包括未来的6G
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6d79960ab14b01f78c5aaaf107bc0b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82370459158167e312052cc7825db0f1/" rel="bookmark">
			Intellij IDEA sbt 依赖分析插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可分析模块和传递依赖，还能显示JAR包大小
安装完插件后，由于IDEA BUG，会出现两个分析按钮，一个是gradle的，后者是新安装的sbt。
选择需要分析的模块
下载地址 https://plugins.jetbrains.com/plugin/22427-sbt-dependency-analyzer
支持Intellij IDEA 2023.1及以上
文档地址：https://github.com/bitlap/intellij-sbt-dependency-analyzer/blob/master/README-CN.md
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8596ad094734b3ae12de62d2ada59c/" rel="bookmark">
			SDN软件定义网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SDN理解
网络测试命令
高级命令（netperf，iperf，postmen）netperf：
iperf:
tcpdump：
开源软件和协议OVS
什么是OVS
源码安装
常用命令
实现VLAN隔离和互通
mininet
mininet是什么
mn命令的用法，
修改host的ip，
测试联通
利用Python创建主机，交换机，连线
OpenDayLight
是什么:
源码安装部署
modular按照顺序部署
下发流表，1.0和1.3版本有什么区别
厂商SDN：VxLAN，EVPN
VxLAN：
静态隧道，
集中网关：
EVPN
BGP基本配置：
建立EBGP
IBGP邻居，
单选20，判断10：SDN基础常识
问答20：对SDN一些理解，开放题型，常识问题
实验50：vxlan，bgp程序命令填空，
ovs，minninet安装部署流程
SDN理解 即软件定义网络，通过网络设备控制面与数据面分离
实现网络流量的灵活控制，api接口——网络可编程化
网络测试命令 Wirshark抓包工具的使用Expression过滤器，正则表达式
高级命令（netperf，iperf，postmen）
netperf： 网络性能测量工具，主要TCP或UDP传输
netserver -p 9999
netperf -H ip -p 9999 -- -m 1024
netperf -t UDP_STREAM -H ip -p 9999 -- -m 1024
与iperf相比netperf可以指定具体协议，但是iperf显示的信息更为具体
iperf: 网络性能测试工具，可以测试TCP和UDP带宽质量。
也可以通过UDP测试报告网丢包率或者发包性能
iperf -s服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8596ad094734b3ae12de62d2ada59c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb24201960f9421ef8cf885d322d8d7a/" rel="bookmark">
			axios封装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌼未封装 在项目中往往一个页面存在着要联调好几个接口，此时用下面的写法就会显得代码很冗余
// 向给定ID的用户发起请求 axios.get('/user?ID=123456',{ params: { //发送请求的数据 ID: 123456 } }) .then(function (response) { // 处理成功情况 console.log(response); }) .catch(function (error) { // 处理错误情况 console.log(error); }) .finally(function () { // 总是会执行 }); // 支持async/await用法 async function getUser() { try { const response = await axios.get('/user?ID=123456'); console.log(response); } catch (error) { console.error(error); } } 🌼封装一下 errorCode.js
export default { '401': '认证失败，无法访问系统资源', '403': '当前操作没有权限', '404': '访问资源不存在', 'default': '系统未知错误，请反馈给管理员' } request.js
一般会在utils文件夹下创建request.js文件。封装的好处：统一处理请求和响应、简化API调用、提高代码的可维护性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb24201960f9421ef8cf885d322d8d7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4054776c720db13bd3d4ec5716e40d/" rel="bookmark">
			斯坦福发布 最新 GPT 模型排行榜 AlpacaEval【AI工具免费使用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📌提炼❓什么是 AlpacaEval🔎AlpacaEval 排行榜 包含的 测试 模型 和数据💯在不同的测试集上各个大模型的能力评分🚀AlpacaEval Leaderboard 大模型的能力综合评分💼 普遍国内白领 如何快速应用 大模型👑 TomChat（https://www.tomchat.fun）🤖 支持gpt4 / gpt-3.5 / claude /code-llm🎨 支持 AI绘画🆓 每天十次免费使用机会🪄 无需魔法 📌提炼 GPT-4 登顶商用模型微软 WizardLM 登顶开源模型 ❓什么是 AlpacaEval AlpacaEva 是来自斯坦福的团队发布的一款 大语言模型 自动评测系统，它是一种基于 LLM 的全自动评估基准，且更加快速、廉价和可靠。同时包含了应的 AlpacaEval Leaderboard（大语言模型排行榜）。AlpacaEval 是一个模拟沙盒，能够快速、廉价地对从人类反馈中学习的方法进行实验。它用API LLMs模拟人类反馈，提供一个经过验证的评估协议，并提供一套参考方法的实现。虽然仅基于 GPT-4 进行自动评估，但与基于 1.8 万条真实人类标注排序结果之间高达 0.94 的皮尔逊相关系数，证明了 AlpacaEval 榜单 排名的高可靠性。 🔎AlpacaEval 排行榜 包含的 测试 模型 和数据 选择了目前在 商用领域 和 开源社区 很火 的模型 ，包括但不限于以下模型
GPT-4 (open ai)Claude (anthropic)PaLM 2 (google)WizardLM (microsoft) 甚至还开设了一个 「准中文」 排行榜
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4054776c720db13bd3d4ec5716e40d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd8062941797da4b5a9ea2d2c6ca240/" rel="bookmark">
			LATEX页眉的横线不够长\一边长一边短
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如图所示，是我编码的过程中遇到的排版瑕疵问题 原因：是因为我的纸张大小设置放在了页眉设置的后面，应该是程序编译的过程中没发使页眉去匹配纸张大小
调整后： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7da73a1a6915483bbb412957fd72185/" rel="bookmark">
			Hadoop完全分布集群搭建及高可用搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Hadoop完全分布式搭建（Centos 7系统）1、关闭防火墙2、设置主机名3、配置主机名映射hosts文件3、设置静态IP4、配置jdk环境变量5、配置SSH免密登录6、配置Hadoop环境变量7、修改Hadoop配置文件8、分发文件9、格式化namenode10、启动集群并测试 二、Hadoop安装zookeeper（Centos 7系统）1、安装zookeeper2、配置环境变量3、更改文件名字zoo.cfg4、修改zoo.cfg配置文件6、分发zookeeper7、zookeeper基本命令 三、Hadoop高可用搭建(Centos 7系统)1、修改配置文件2、分发文件3、第一次启动顺序3、其次启动顺序4、查看节点个数 一、Hadoop完全分布式搭建（Centos 7系统） 1、关闭防火墙 systemctl stop firewalld #关闭防火墙 systemctl start firewalld #开启防火墙 systemctl disable firewalld #设置开机禁用防火墙 systemctl enable firewalld #设置开机启用防火墙 systemctl status firewalld #查看防火墙状态 2、设置主机名 hostnamectl set-hostname master &amp;&amp; bash #设置主机名为master，立即生效. hostnamectl set-hostname worker1 &amp;&amp; bash #设置主机名为worker1，立即生效. hostnamectl set-hostname worker2 &amp;&amp; bash #设置主机名为worker2，立即生效. 3、配置主机名映射hosts文件 vim /etc/hosts #进入hosts文件 192.168.10.100 master #IP地址 主机名 192.168.10.101 worker1 #IP地址 主机名 192.168.10.102 worker2 #IP地址 主机名 3、设置静态IP vim /etc/sysconfig/network-scripts/ifcfg-ens33 #进入配置IP文件 TYPE="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7da73a1a6915483bbb412957fd72185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ffe7ae200a85a4421977740d0a49f5d/" rel="bookmark">
			mysql 存储过程 存储函数 游标 事件 视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysqldump 备份还原表 1.导出所有(包括结构&amp;数据&amp;存储过程&amp;函数&amp;事件&amp;触发器)(不写-R -E默认仅导出结构和数据) -- 注意这里不要加分号(密码随后输入即可) mysqldump -h192.168.2.252 -uroot -p -R -E ipvacloud &gt; d:2.sql 2.导入数据库 mysql&gt;use voice; mysql&gt;source d:xxx.sql; 再次出现mysql&gt;并且没有提示错误即还原成功 这里为什么要用mysqldump呢? 因为速度快啊,数据库5个G用它比直接用navicat导出sql文件快100倍, 原来，mysqldump默认导出的就有table和view，而且view还是作为temp table导出来的，而且在导出来的sql文件里面，你看不到create view这样类似的字眼。但是，你执行source 2.sql命令时，会在视图里找到aaa这个视图
1.存储过程 CREATE DEFINER=`root`@`%` PROCEDURE `test_procedure`(IN `age` int,OUT `result_out` int) BEGIN DECLARE user_name VARCHAR (64) -- 声明变量，但不使用 #Routine body goes here... SELECT * FROM employee; -- 返回结果集 SET result_out=age *2; -- out结果 END 点击运行按钮，只要输入输入参数就可以啦
--navicat中使用call来调用 存储过程 1个输入参数， 1个输出参数 CALL test_procedure(6, @a); 2.存储函数（必须要有返回值，且入参只有IN, 没有OUT） CREATE DEFINER=`root`@`%` FUNCTION `test_function`(`age` int) RETURNS int(11) -- 表示返回值的类型 BEGIN RETURN age * 2; END navicat中使用如下语句，调用存储函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ffe7ae200a85a4421977740d0a49f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a52e4075e7ed6fa1959f1f289943302/" rel="bookmark">
			Java并发编程第12讲——cancelAcquire()流程详解及acquire方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章介绍了AQS的设计思想以及独占式获取和释放同步状态的源码分析，但是还不够，一是感觉有点零零散散，二是里面还有很多细节没介绍到——比如cancelAcquire()方法（重点），迫于篇幅原因，今天就把它放到这篇文章里，继续深入AQS！
一、acquire方法 源码的分析在上一篇文章，感兴趣的同学可以去看一下，我的建议是两篇文章一起看。
1.1 几个状态（重点） ps：waitStatus&gt;0说明等待状态时CANCELLED，waitStatus&lt;0为其它状态。
//表示线程已取消：由于在同步队列中等待的线程等待超时或中断 //需要从同步队列中取消等待，节点进入该状态将不会变化（即要移除/跳过的节点） static final int CANCELLED = 1; //表示后继节点处于park，需要唤醒：后继节点的线程处于park，而当前节点 //的线程如果进行释放或者被取消，将会通知（signal）后继节点。 static final int SIGNAL = -1; //表示线程正在等待状态：即节点在等待队列中，节点线程在Condition上， //当其他线程对Condition调用signal方法后，该节点会从条件队列中转移到同步队列中 static final int CONDITION = -2; //表示下一次共享模式同步状态会无条件地传播下去 static final int PROPAGATE = -3; //节点的等待状态，即上面的CANCELLED/SIGNAL/CONDITION/PROPAGATE，初始值为0 volatile int waitStatus; 1.2 acquire()流程图及分析 基本流程描述：
调用子类重写的tryAcquire方法尝试获取同步状态，若成功则返回，反之进入addWaiter方法。基于当前线程新建一个Node节点，若队列不为空则将Node节点CAS操作挂在队列尾部，队列为空或CAS失败进入enq方法。查看队列是否已经初始化，若没有则优先初始化队列（自旋），随后将Node节点以CAS的方式插入队列，CAS失败则继续自旋，反之进入acquireQueued方法。若Node的前驱节点为头节点，且再次tryAcquire()成功，则将Node设置为头节点，并结束自旋。若两个条件任意一个失败则进入shuoldParkAfterFailedAcquire方法。若Node的前驱节点等待状态为SIGNAL，则调用parkAndCheckInterrupt方法将当前线程阻塞，若当前线程的中断状态为ture则将acquireQueued的返回值置为true，并继续自旋；反之则判断Node的前驱节点的等待状态是否为CANCELLED，若不是则CAS尝试将Node的前驱节点等待状态改为SIGNAL，并继续自旋；若是则说明这个前驱节点无效，直接跳过该节点并找一个非CANCELLED节点作为Node的前驱节点，并结束自旋（acquireQueued方法结束）。若acquireQueued方法返回ture则说明当前线程需要被中断（也就是Node节点的前面还有节点在排队，还没轮到Node节点）。若在acquireQueued方法中出现异常，则会调用cancelAcquire方法进行该节点的取消逻辑，这也是我们今天的重点，下面会具体分析。 二、cancelAcquire方法 上篇文章在分析它的源码时就感觉有点懵懵的，很多地方都不太理解（那面试的时候怎么跟面试官battle啊😁），那么今天就深入的分析一下。
2.1 源码 再次附上源码，方便观看。
在acquireQueued方法中出现异常会走cancelAcquire方法取消正在进行acquire的尝试，以防止死锁或长时间的等待。这里我把它分为两个红框，下面图解流程时会用到。
2.2 流程图 解释一下颜色代表的意思：
紫色——方法开始和结束。橙色——断开与取消结点联系的执行逻辑。黄色——node结点为tail结点执行的逻辑。蓝色——node结点不为tail结点执行的逻辑（为head结点的后继结点或中间结点）。其它——一般逻辑。 2.3 Node为尾节点 初始状态：即N1为Node节点
执行第一个红框： 将Node结点Thread置空。Node节点的前驱结点N2的等待状态为CANCELLED，所以断开N1到N2的联系，并与N3建立联系。将pred指向N3结点，predNext指向N2（这里不是node节点）并把Node结点的等待状态置为CANCELLED。 执行第二个红框：
将pred设置为tail节点。断开N3到N2结点的联系。最后N1和N2节点会被GC回收。 2.4 node为中间节点 2.4.1 N3节点取消流程 初始状态：Node节点为中间节点，既不是tail节点，也不是head节点的后继节点。
执行第一个红框：
将node的Thread置为null。pred指向N4，preNext指向N3，也就是node节点。将node的等待状态置为CANCELLED。 执行第二个红框：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a52e4075e7ed6fa1959f1f289943302/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/34/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>