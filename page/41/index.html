<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc742c2839101c02f8645a9e53cec3c/" rel="bookmark">
			齐鲁工业大学 觅幂小程序打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		齐鲁工业大学 觅幂小程序打卡 github 地址 可以去github看一眼
https://github.com/wanan0red/qlu_mimi_sport 操作有点复杂 不过一次操作 一直方便 系统不重启可以用两年 当然用模拟器也是可以的
用到的软件我都传到了 百度网盘 如果不放心软件 可以自行下载安装 其中的poc.exe 中有 .py源码 可以以源码形式运行
还不会的可以联系我(有想学网安的也可以哦) 1498032121@qq.com
链接：https://pan.baidu.com/s/1a6aiF2rYJSjt5HJddqboeA?pwd=6rjx 提取码：6rjx 首先我们需要先下载一个电脑版的微信
我们首先需要安装 burpsuite
https://portswigger.net/burp/releases 可以去官网下载
一定要选择社区版
双击安装 一直下一步就行了
没有给我们创建快捷方式 我们点击开始菜单打开
成功启动 接着我们 点击proxy 点击 intercept 接着点击 open brower 在打开的浏览器里面输入 打开一个网站之后 点击 ca certificate
http://burpsuite/ 接着我们双击 按照这个der
接着点击完成 点是即可
安装 proxifier.exe
双击proxifier.exe 安装一直下一步就行
接着打开 proxifier 选择代理服务器
依次填入即可
接着点击代理规则
这里选择 直接连接 接着点击添加
接着填入下面的域名 然后确定即可
admin.report.mestallion.com 最后的代理规则
接着我们来登录微信
搜索觅幂并打开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bc742c2839101c02f8645a9e53cec3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1ab0552875d2ca83069bff0692e720/" rel="bookmark">
			说说防蚊子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为千防万防还是被咬，所以突然想说说这个话题。
蚊子咬人会引起过敏反应，就是起包，很痒，并且很多种类的蚊子会传播疾病，所以比较讨厌。讨厌就要防。
其实所谓的“防”，有三个方向。第一，杀掉蚊子。就是先发制人，提前干掉作案人就不会有案件发生。第二，我不杀你，但你也不要跨过底线，别咬我就行，大家争取有个佛系的和平。第三，隔离。周围没有蚊子。所以，一直以来，大家都在这几个方向上想招儿。下面说一些自己用过的。
1、住高层。这算是隔离法。不过可能不太管用。直观上讲，蚊子那么小，一口气就可以吹走，能飞到很高的楼层吗？当然，理论上讲，居住环境到达一定的高度就肯定不会再有蚊子了。就个人经历而言，在试过23层不管用后，又搬到了31层，结论是有效果，但还是有蚊子，所以还得高！
2、蚊帐。这也是隔离法。感觉是最简单、100%管用的。不管用什么其它方法，这个一定要安排上，多少是个保底。
3、开空调冻死蚊子。这个管用，类似于先发制人吧，虽然不至于真的冻死达成一劳永逸，但温度低了蚊子的活性就低了，就不怎么咬人了。不过不一定能实现。
4、杀虫剂，比如常用的杀虫喷雾。亲测管用，喷上了保证1s生效。小强都受不了这个，更何况蚊子。只是一般杀虫剂都有毒性，大概率对家里宠物不友好，另外，比如杀虫喷雾，这味儿也太大了！综合起来，大概算是杀敌一千自损八百。
5、高压灭蚊灯。管用，但可惜是被动的，引诱不会达到100%成功，总有漏网之鱼。感觉是更适合于蚊子很多的场合，作用是降低密度。
6、电蚊拍。这个当然管用，但前提是得先发现目标。蚊子那么小，而且总有比较鬼的，猫起来找不到。
7、蚊香和电蚊香。原理似乎都是用除虫菊酯，管用。但普遍认为对家里得猫猫狗狗不太友好，而且有些蚊香确实烟儿比较大。不过主打是价格低廉使用方便。你去露营也能点一盘蚊香不是。
8、住高层，开窗睡觉，屋里空气流动比较快，能把蚊子吹跑吗？答案是如果风不影响你睡觉的话，就不管用。
9、驱虫香包。亲测不管用。香包都是放一些晒干的植物进去，气味很好，不过文字似乎也不怎么怕。
10、驱蚊啫喱。和驱蚊香包差不多原理。主要芳香物质据说是香茅提取物，不过亲测不怎么管用，还是被咬。
11、驱蚊喷雾、驱蚊香水。亲测管用，不过都是管几个小时，而且作用范围比较小。你在胳膊上涂了，脚上没涂，蚊子就会咬你脚。而且过几个小时就失效了。最关键的是生效时间也就2~3小时吧，还没睡醒呢。
12、驱蚊贴。管用，但是似乎作用范围比驱蚊香水还小，比较鸡肋。而且贴上这玩意儿，感觉自己像自杀小队2里的圆点人，偏搞笑。
13、开着灯睡觉。亲测不管用。而且如果不习惯的话还有附加伤害：睡不好，困。
所以，鉴于家里有喵星人，最终的方法就是：蚊帐+电蚊拍+手电。关灯，支上蚊帐，然后手电+电蚊拍打一遍，齐活儿！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd123a8b8de9a43c9ac02b7158ea12a/" rel="bookmark">
			惊天营救2，那啥锤哥就是一样NB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就是爽片泡泡糖电影啦。总得来说就是讲个爽的故事，不过比什么这个那个赘婿呢，呵呵。说不能比其实也是有道理的：你带宠物去参加狗狗比赛，它首先得是修构才行。
就说说两句台词。
最后，桑德罗说：sorry，i'm so sorry！应该说sorry有用，还要警察干嘛，就别装了。这是什么TM玩意儿。
最后，锤哥说：i've not stop！然后就是PENG！说实在的，这才像话！这才是玩意儿！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e07f0f8d6a606cae7f93261202c665/" rel="bookmark">
			测绘屠夫报表系统V1.0.0-beta
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 简介 测绘屠夫报表系统，能够根据变形监测数据：水准、平面、轴力、倾斜等数据，生成对应的报表，生成报表如下图。如需进一步了解，可以加QQ：3339745885。视频教程可以在bilibili观看。
2. 软件主界面 3. 生成报表效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b231833f20c02fde5a215b8f77cd35b3/" rel="bookmark">
			美术如何创建 skybox 贴图资源？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的PS手绘+Panorama To CubemapPS手绘+Pano2VRSkybox &amp; Cubemap Tutorial (Maya &amp; Photoshop)Unity 中使用 ReflectionProbe 生成 Cubemap 然后再 PS 调整PS直接手绘 cubemapBlender 导入 Panorama，然后烘焙到 cubemap，再导入unity中使用Blender cube-&gt;to sphere-&gt;再绘制模型上的纹理 (50s教程)其他的References 目的 学习新的自定义天空的做法
可以再日后，自己制作，或是教会美术如何制作
这篇文章只有 美术相关的内容
程序的可以是 连连看，或是 自己撸代码实现 程序化天空盒
PS手绘+Panorama To Cubemap 参考视频：Create Custom Skybox for Unity with Photoshop - 这个是直接使用 PS 手绘 + Panorama to cubemap
PS手绘-Panorama图
方法很简单
暗灰 填充 地板暖白 填充 顶部使用画笔工具+SHIFT健 绘制水平面上的晚霞：橙红、橙色、蓝色，然后高斯模糊 最后生成这种的一张图：
Panorama To Cubemap，将刚刚PS手绘的的天空盒转为Cubemap
使用在线将全景图转为Cubemap 图
在线工具：Panorama to Cubemap
PS手绘+Pano2VR PS手绘-Panorama图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b231833f20c02fde5a215b8f77cd35b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da29c630f3baa270957583f1bf4d7d9d/" rel="bookmark">
			【Windows】安装Microsoft Store，Microsoft Store离线包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用了大半年的Windows，今天发现没有Microsoft store
离线包下载：https://wwon.lanzout.com/i4xPL1atnotc离线包下载：https://www.123pan.com/s/Kol7Vv-5VuG.html
上面的离线包要求操作系统版本 10、0、18363、0 或更高。 如果系统版本比要求的低，上边的离线包用不了，需要自己到这里下载：https://store.rg-adguard.net/ ，在4种搜索方式中选择PackageFamilyName，并输入Microsoft.WindowsStore_8wekyb3d8bbwe进行搜索，下载的文件共5个（选版本号小的）：
这个方法的步骤： 1、打开「旁加载应用」
使用 Windows + I 快捷键打开「设置」应用；
到「更新和安全」—「针对开发人员」；
将单选项调整选中「旁加载应用」
2、离线包解压后，逐个双击运行【. AppX 】后缀的程序；
如果不能双击运行，打开Windows Powershell，逐个通过Add-AppPackage运行
如
Add-AppPackage xxx1. AppX
Add-AppPackage xxx2. AppX
3、运行 【.MSIXBundle 】后缀的程序，并按照屏幕上的说明继续进行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1251fab637f5344065f3291e9f275f/" rel="bookmark">
			彻底关闭Win10的杀毒软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		彻底关闭Win10的杀毒软件 关闭Win10的杀毒软件通过Windows Defender设置临时关闭修改注册表永久禁用Windows Defender禁用行为监控禁用访问保护禁用实时扫描启用 禁用Windows Defender 安全中心：禁用Windows 安全中心服务(wscsvc)禁用Windows Defender 防火墙服务(mpssvc)禁用Windows Defender 防漏洞入侵服务(WdNisSvc) 通过组策略禁用Windows Defender禁用右下角图标立即生效 恢复Defender启用行为监控、访问保护、实时扫描。 关闭Win10的杀毒软件 通过Windows Defender设置临时关闭 打开Windows Defender操作界面，依次打开“病毒和威胁防护”—“病毒和威胁防护设置”；
在“病毒和威胁防护”设置界面，关闭“实时保护”，关闭“云提供的保护”，关闭“自动提交样本”这三项。 如果按钮是灰色无法修改，那么可能你的第三方软件已通过其他方式为您已经关闭了。
修改注册表永久禁用Windows Defender 适用windows10家庭版用户，非家庭版用户可以使用组策略禁用。
按WIN + R 组合键，打开运行，输入regedit，点击确定，快速打开注册表
在注册表编辑器窗口中，依次打开到： HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender 3. 在右侧空白处，右键点击鼠标–新建—》DWORD(32位)值，将其命名为DisableAntiSpyware
双击新建的值，将值设置为1。
确定； 0代表False，1代表True。
禁用行为监控 定位注册表。
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection 新建Real-Time Protection这个KEY,用鼠标右键单击Real-Time Protection（文件夹）键，选择新建----》然后单击DWORD（32位）值。
将该键命名为DisableBehaviorMonitoring，然后确定保存
双击新建的值，将值设置为1。
确定； 0代表False，1代表True。
禁用访问保护 定位注册表。
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection 用鼠标右键单击Real-Time Protection（文件夹）键，选择新建----》然后单击DWORD（32位）值。
将密钥命名为DisableOnAccessProtection，然后按Enter键。
双击新建的值，将值设置为1。
确定； 0代表False，1代表True。
禁用实时扫描启用 定位注册表。
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection 用鼠标右键单击Real-Time Protection（文件夹）键，选择新建----》然后单击DWORD（32位）值。
将该键命名为DisableScanOnRealtimeEnable，然后按Enter键。
双击新建的值，将值设置为1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1251fab637f5344065f3291e9f275f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17a6022af98647f6422afbd41679d60/" rel="bookmark">
			【路径规划】基于matlab粒子群算法栅格地图最短路径规划【含Matlab源码 018期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、粒子群算法及栅格地图简介 1 粒子群算法
1.1 引言
自然界中的鸟群和鱼群的群体行为一直是科学家的研究兴趣所在。生物学家Craig Reynolds在1987年提出了一个非常有影响的鸟群聚集模型，在他的仿真中，每一个个体都遵循：避免与邻域个体相撞：匹配邻域个体的速度；飞向鸟群中心，且整个群体飞向目标。仿真中仅利用上面三条简单的规则，就可以非常接近地模拟出鸟群飞行的现象。1990年， 生物学家Frank Heppner也提出了鸟类模型， 它的不同之处在于：鸟类被吸引飞到栖息地。在仿真中，一开始每一只鸟都没有特定的飞行目标，只是使用简单的规则确定自己的飞行方向和飞行速度，当有一只鸟飞到栖息地时，它周围的鸟也会跟着飞向栖息地，最终整个鸟群都会落在栖息地。
1995年， 美国社会心理学家James Kennedy和电气工程师RussellEberhart共同提出了粒子群算法(ParticleS warm Optimization， PSO) ， 该算法的提出是受对鸟类群体行为进行建模与仿真的研究结果的启发。他们的模型和仿真算法主要对Frank Heppner的模型进行了修正，以使粒子飞向解空间并在最优解处降落。粒子群算法一经提出，由于其算法简单，容易实现，立刻引起了进化计算领域学者们的广泛关注， 形成一个研究热点。2001年出版的J.Kennedy与R.Eberhart合著的《群体智能》将群体智能的影响进一步扩大[] ， 随后关于粒子群优化算法的研究报告和研究成果大量涌现，继而掀起了国内外研究热潮[2-7]。
粒子群优化算法来源于鸟类群体活动的规律性，进而利用群体智能建立一个简化的模型。它模拟鸟类的觅食行为，将求解问题的搜索空间比作鸟类的飞行空间，将每只鸟抽象成一个没有质量和体积的粒
子，用它来表征问题的一个可能解，将寻找问题最优解的过程看成鸟类寻找食物的过程，进而求解复杂的优化问题。粒子群优化算法与其他进化算法一样，也是基于“种群”和“进化”的概念，通过个体间
的协作与竞争，实现复杂空间最优解的搜索。同时，它又不像其他进化算法那样对个体进行交叉、变异、选择等进化算子操作，而是将群体中的个体看作在l维搜索空间中没有质量和体积的粒子，每个粒子以一定的速度在解空间运动， 并向自身历史最佳位置P best和邻域历史最佳位置g best聚集， 实现对候选解的进化。粒子群算法具有很好的生物社会背景而易于理解，由于参数少而容易实现，对非线性、多峰问题均具有较强的全局搜索能力，在科学研究与工程实践中得到了广泛关注。目前，该算法已广泛应用于函数优化、神经网络训练、模式分类、模糊控制等领域。
1.2 粒子群算法理论
1.2.1粒子群算法描述
鸟类在捕食过程中，鸟群成员可以通过个体之间的信息交流与共享获得其他成员的发现与飞行经历。在食物源零星分布并且不可预测的条件下，这种协作机制所带来的优势是决定性的，远远大于对食物
的竞争所引起的劣势。粒子群算法受鸟类捕食行为的启发并对这种行为进行模仿，将优化问题的搜索空间类比于鸟类的飞行空间，将每只鸟抽象为一个粒子，粒子无质量、无体积，用以表征问题的一个可行解，优化问题所要搜索到的最优解则等同于鸟类寻找的食物源。粒子群算法为每个粒子制定了与鸟类运动类似的简单行为规则，使整个粒子群的运动表现出与鸟类捕食相似的特性，从而可以求解复杂的优化问题。
粒子群算法的信息共享机制可以解释为一种共生合作的行为，即每个粒子都在不停地进行搜索，并且其搜索行为在不同程度上受到群体中其他个体的影响[8]，同时这些粒子还具备对所经历最佳位置的记
忆能力，即其搜索行为在受其他个体影响的同时还受到自身经验的引导。基于独特的搜索机制，粒子群算法首先生成初始种群，即在可行解空间和速度空间随机初始化粒子的速度与位置，其中粒子的位置用于表征问题的可行解，然后通过种群间粒子个体的合作与竞争来求解优化问题。
1.2.2粒子群算法建模
粒子群优化算法源自对鸟群捕食行为的研究：一群鸟在区域中随机搜索食物，所有鸟知道自己当前位置离食物多远，那么搜索的最简单有效的策略就是搜寻目前离食物最近的鸟的周围区域。粒子群算法
利用这种模型得到启示并应用于解决优化问题。在粒子群算法中，每个优化问题的潜在解都是搜索空间中的一只鸟，称之为粒子。所有的粒子都有一个由被优化的函数决定的适应度值，每个粒子还有一个速度决定它们飞翔的方向和距离。然后，粒子们就追随当前的最优粒子在解空间中搜索[9]。
粒子群算法首先在给定的解空间中随机初始化粒子群，待优化问题的变量数决定了解空间的维数。每个粒子有了初始位置与初始速度，然后通过迭代寻优。在每一次迭代中，每个粒子通过跟踪两个“极值”来更新自己在解空间中的空间位置与飞行速度：一个极值就是单个粒子本身在迭代过程中找到的最优解粒子，这个粒子叫作个体极值：另一个极值是种群所有粒子在迭代过程中所找到的最优解粒子，这个粒子是全局极值。上述的方法叫作全局粒子群算法。如果不用种群所有粒子而只用其中一部分作为该粒子的邻居粒子，那么在所有邻居粒子中的极值就是局部极值，该方法称为局部粒子群算法。
1.2.3粒子群算法的特点
粒子群算法本质是一种随机搜索算法，它是一种新兴的智能优化技术。该算法能以较大概率收敛于全局最优解。实践证明，它适合在动态、多目标优化环境中寻优，与传统优化算法相比，具有较快的计
算速度和更好的全局搜索能力。
(1)粒子群算法是基于群智能理论的优化算法，通过群体中粒子间的合作与竞争产生的群体智能指导优化搜索。与其他算法相比，粒子群算法是一种高效的并行搜索算法。
(2)粒子群算法与遗传算法都是随机初始化种群，使用适应值来评价个体的优劣程度和进行一定的随机搜索。但粒子群算法根据自己的速度来决定搜索，没有遗传算法的交叉与变异。与进化算法相比，粒子群算法保留了基于种群的全局搜索策略，但是其采用的速度-位移模型操作简单，避免了复杂的遗传操作。
(3)由于每个粒子在算法结束时仍保持其个体极值，即粒子群算法除了可以找到问题的最优解外，还会得到若干较好的次优解，因此将粒子群算法用于调度和决策问题可以给出多种有意义的方案。
(4)粒子群算法特有的记忆使其可以动态地跟踪当前搜索情况并调整其搜索策略。另外，粒子群算法对种群的大小不敏感，即使种群数目下降时，性能下降也不是很大。
1.3 粒子群算法种类
1.3.1基本粒子群算法
1.3.2标准粒子群算法
引入研究粒子群算法经常用到的两个概念：一是“探索”，指粒子在一定程度上离开原先的搜索轨迹，向新的方向进行搜索，体现了一种向未知区域开拓的能力，类似于全局搜索；二是“开发”，指粒子在一定程度上继续在原先的搜索轨迹上进行更细一步的搜索，主要指对探索过程中所搜索到的区域进行更进一步的搜索。探索是偏离原来的寻优轨迹去寻找一个更好的解，探索能力是一个算法的全局搜索能力。开发是利用一个好的解，继续原来的寻优轨迹去搜索更好的解，它是算法的局部搜索能力。如何确定局部搜索能力和全局搜索能力的比例， 对一个问题的求解过程很重要。1998年， Shi Yuhui等人提出了带有惯性权重的改进粒子群算法[10]，由于该算法能够保证较好的收敛效果，所以被默认为标准粒子群算法。其进化过程为：
在式(6.7)中，第一部分表示粒子先前的速度，用于保证算法的全局收敛性能；第二部分、第三部分则使算法具有局部收敛能力。可以看出，式(6.7)中惯性权重w表示在多大程度上保留原来的速度：W
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a17a6022af98647f6422afbd41679d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb585c60c4a9425544efb46e28322fee/" rel="bookmark">
			js逆向七麦网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大数据时代的到来,人们对于数据的需求越来越大,但对于数据的获取不再像以前那么简单。
各大网站都对数据进行了加密处理来保护数据的安全。但是上有政策，下有对策。
今天带来逆向的第一个案例。
Let's Go!
目标网址：七麦数据 -专业移动产品商业分析平台-关键词优化-ASA优化-七麦科技
按F12进行常规抓包，发现这是一个url参数加密，analysis=eDUjFCk/Nw9UaXUMBlMMWgIlJRQiOEcIcRRMFgBXXU4LDQAdAToWAAJaVlUAB1ZbV1A4Wkk=
只要我们破解了该参数，就可以正常获取数据啦！
一般查找加密位置有三种基本方法：
关键字搜索
Hook方法
XHR断点
当前前提是网站走的XHR（XMLHttpRequest）请求，今天我们采取XHR断点方式来找加密位置。
先点击源代码（source），右侧有个XHR断点点击+号，把analysis添加到方框中去。
而后刷新网页，看如下图，这样就被断住啦。然后我们一定要取消XHR断点，在进行调试，否则后面调试会遇到各种问题。
后面就是常规的调试，发现如下图.then回调方法（后台服务器返回数据给浏览器）
我们点击这个向下的箭头进行下一步。发现我们要的数据就在后台返回的t中。
后面我们再点击向上的箭头出栈。走到如下位置。发现Kt是个interceptors拦截器，Xt是response响应，因此我们可以断定拦截器请求（request）一定在这上面。
再次按向上的箭头，来到如下图位置。然后我们进行打断点，看原始数据的请求是怎么进行加密的，然后找到加密的位置，并把对应代码拿下来，我们就能自己进行模拟加密了。
如下图我们发现：
e = (0,i[jt])((0,i[qt])(a, d)) 经过分析e通过函数加密形成analysis加密参数
(0, i[jt])这种形式，我们可以把看它C语言中的逗号操作符，以最后的那位数的结果作为结果，因此我们改写成：args =i[qt](a, d)，analysis=i[jt](args)
a='MTEyMDIzLTAxLTE3MzZjbmZyZWVpcGFk@#/rank/indexSnapshot@#12700680949@#3' 第一次
a='MTEyMDIzLTAxLTE3MzZjbmZyZWVpcGFk@#/rank/indexSnapshot@#12701166844@#3' 第二次
d='xyz517cda96abcd'第一次
d='xyz517cda96abcd'第二次
通过多次分析，d参数是写死的，而a是动态的参数
而a的生成就是如下三个代码生成的：
a = a[Ot]()[I1](_), a = (0,i[jt])(a), a = (a += v + t[Jt][T](t[Mt], _)) + (v + r) + (v + 3) 现在开始我们就是扣代码啦。
var obj = {} obj.xx = v function o(n) { //o是我们h中要o具体函数的实现 t = '', ['66', '72', '6f', '6d', '43', '68', '61', '72', '43', '6f', '64', '65']['forEach'](function (n) { t += unescape('%u00' + n) }); var t, e = t; return String[e](n) } function h(n, t) { // h就是i[qt]，n就是a加密的数据,t就是要传入的d t = t || 'a12c0fa6ab9119bc90e4ac7700796a53'; for (var e = (n = n['split'](''))['length'], r = t["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb585c60c4a9425544efb46e28322fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897ed90d640f5a9b69bdf5c6d8a9cffb/" rel="bookmark">
			Windows 11&#43;Ubuntu双系统（安装、删除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Ubuntu系统 0. 准备工作 1）系统镜像文件（点此链接下载历史版本的Ubuntu镜像文件）
2）烧盘软件（点此链接下载启动盘制作软件Win32Disk Imager）
1. 制作启动盘 注意：U盘需要具有4G以上的容量大小，制盘完成U盘将失去存储功能，如有文件提前备份。
打开下载好的制盘工具，映像文件一栏打开系统镜像文件所在的存储盘和路径，注意右下角。
点击写入，继续执行。跳出“写入完成”的弹窗之后，启动盘就制作好了。
（图中的示例是Ubuntu20.04版本，这个操作过程各个版本均一致）
2. 磁盘分区 打开磁盘管理，从空盘中压缩出一个未分配的空间用于安装Ubuntu。建议分配空间的大小为100G
以上。具体的挂载分配方案如下（以100G为例）：
swap交换空间：10G，efi：500MB，/ 挂载点：25G， /home：剩下所有
如果分区多于100G，swap和efi固定，部分划分给/ 挂载点，绝大部分划分给/home。磁盘分配的过程将在安装系统时进行，这里是对磁盘划分的安排。接下来查看磁盘格式，目前大部分都是GPT格式，所以接下来的教程也以GPT分区格式为例。
3. BIOS设置 插入启动盘，进入电脑BIOS设置界面，找到启动设置的选项，把disk磁盘启动放在第一的位置，保存后退出。再次启动，进入开启选项，选择磁盘，就会进入到引导安装界面。（以上操作需要在开机过程中快捷键进入，不同品牌电脑之间存在差异，BIOS的ui界面也会有差异。某些电脑直接进入的是简单模式，选项卡要在高级模式下操作）
4. 安装界面 安装引导大部分是默认选项，到安装类型这一步时，点击其他选项，手动进行磁盘的分配挂载。
“用于”一栏，分别选择EFI系统分区，交换空间，EXT4系统日志文件（/挂载点，/home在此项下）
按照上面提到的分区方案分配对应大小的空间即可。
分配好空间后，下面“安装启动引导器的设备”选项栏要于efi空间前的设备编号一致。
继续按照引导进行就完成了Ubuntu系统的安装，接下来会有提示重启，重启。黑屏后，屏幕上会有拔出磁盘并点击Enter重启的提示，一定要按照提示进行操作！
5. 完结 重启开机，系统就已经安全安装好了。
----------------------------------------------------------------------------------------------------------------------------
二、卸载Ubuntu系统 1. 工具 DiskGenius（下载链接）
2. 操作 删除分配给Ubuntu的磁盘分区，然后点击保存更改
接着删除图示路径下的Ubuntu文件夹，至此Ubuntu系统就完全删除了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ea80f6aac08c3677e0d84e25458625/" rel="bookmark">
			springboot web项目中 Set-Cookie 失败 办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 目前有个项目 线上环境 使用spring session管理的登录
项目中有两个接口
一个用来登录的 登录成功后会设置cookie 后续请求就会使用该cookie （cookie的键值就是session Id 和 登录后的信息 例如菜单，权限等）
一个用来检查是否登录的 根据session id 来判断是否登录 没有登录信息的 直接返回未登录
调用登录成功后 发现Set-Cookie 出现响应头中 但是 调用检查接口发现还是还是未登录
如下图 模拟登录接口 响应中正确返回了 session
但是检查登录却未将 模拟登陆返回的接口携带上 导致登录校验失败
2. 问题排查 刚开始怀疑两次请求的session id 不一致导致无法使用 模拟登录返回的cookie 但是在测试环境时 可以校验登录接口正常使用 模拟登陆返回的session
模拟登录的接口
验证登录的接口
那问题好像不是session不一致的问题。
因为目前使用spring-session来管理session 如果登录成功后 会将session id 以及登录信息 设置到cookie 同时存入到浏览器 应用的 cookie中 同时会将session 存入到 redis中 其他的接口就会携带
那目前设置没问题 那登录成功后是否 将session 存入到到浏览器应用的cookie 直接去检查 发现没有设置上
这里发现 模拟登录成功后 并没有将session 存入到 浏览器应用的cookie中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ea80f6aac08c3677e0d84e25458625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5ef208c5066f336d9b1982bd258727/" rel="bookmark">
			3、STM32EXIT外部中断（STM32）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32中断 （中断，对于引脚来说，相当于引脚发生了电平跳变，对于定时器来说，可以是定时的时间到了。 中断嵌套：把中断程序再次中断，就叫做中断嵌套）
（被暂停的地方称为断点）
为了程序能在中断返回时继续原来的工作，在中断执行前，会对程序的现场进行保护，中断执行后，会再还原现场，这样可以保证主程序即使被中断了，回来后也能继续运行，当然我们用c语言编程，保护现场和还原现场的工作并不需要我们去做，编译器自动帮我们做好了，这里了解一下即可。
一般中断程序都是在一个子函数里的，这个函数不需要我们调用，当中断来临时，由硬件自动调用这个函数。
STM32中断：有68个可屏蔽中断通道（中断通道即中断源，68格是F1系列最多的中断数量），stm32包含EXTI外部中断、TIM定时器、ADC模数转换器、USART串口、SPI通信、I2C通信、RTC实时时钟等多个外设；
使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级。（NVIC是STM32用来管理中断、分配优先级的，NVIC的中断优先级总共有16个等级，还可以设置抢占优先级，这个是非常灵活的）
下面就是STM32里的中断资源了，了解一下即可，灰色为内核中断（比较高深），其他就是STM32的外设中断了，比如第一个，窗口看门狗，这个是用来监测程序运行状态的中断，那比如你的程序卡死了，没有及时喂狗，窗口看门狗就会申请中断，让你的程序跳到窗口看门狗的中断程序里，那你在中断程序里就可以进行一些错误检查，看看出现什么问题了。
然后PVD电源电压检测，如果你的供电电压不足，PVD电路就会申请中断，在中断里就知道，现在供电不足，是不是电池没电了，要赶紧保存一下重要数据......
总之外设电路检测到有什么异常或事件，需要进一步提示CPU的时候，它就可以申请中断，让程序跳到对应的中断函数里运行一次，用来处理这个异常或事件，表里面的这7个是这节要学的。
（地址的作用：程序中的中断函数的地址是由编译器来分配的，是不固定的，但是我们的中断跳转，由于硬件的限制，只能跳到固定的地址执行程序，所以为了能让硬件跳转到一个不固定的中断函数里，这里就需要在内存中定义一个地址的列表，这个列表的地址是固定的，中断发生后，就跳到这个固定位置，然后在这个固定位置，由编译器再加上一条跳转到中断函数的代码，这样中断跳转就可以跳转到任意位置了，这个中断地址的列表就叫中断向量表，相当于中断跳转的一个跳板，不过我们用c语言编程的话是不需要这个中断向量列表的，因为编译器已经做好了）
NVIC(嵌套中断向量控制器) 接下来看NVIC的基本结构
在STM32中，使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级。（NVIC是STM32用来管理中断、分配优先级的，NVIC的中断优先级总共有16个等级，还可以设置抢占优先级，这个是非常灵活的），它是一个内核外设（CPU小助手）。
图中中断与NVIC连接的地方有一斜杠加一个n，表示一个外设可能会同时占用多个中断通道，所以这里有n条线，然后NVIC只有一个输出口，NVIC根据每个中断的优先级分配中断的先后顺序，最后通过右边一个输出口告诉CPU要处理哪一个中断。
NVIC优先级分组 优先级分为响应优先级和抢占优先级：
（1）响应优先级：相当于插队的优先级（例子：上一个人在看病，外面排队了很多病人，当上一个病人看完后，紧急的病人即使是后来的，也会最先进去看病，这种相当于插队的优先级叫做响应优先级）
（2）抢占优先级：（例子：上一个人在看病，外面排队了很多病人，当上一个病人看完甚至还在看的时候，如果下一个病人更加紧急，那他甚至可以不等上一个人看完，他可以直接冲进去让上一个病人靠边站，先给他看病，等他看完后，然后上一个病人再继续。这种形式的优先级就是中断嵌套，这种决定是不是可以中断嵌套的优先级就叫抢占优先级，抢占优先级高的可以进行中断嵌套）
补充：响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号（表里第二列）排队，数值小的优先响应。
由于每个中断有16个优先级，为了把这个优先级再区分为抢占优先级和响应优先级，就需要对这16个优先级进行分组了
（值越小，优先级越高，0是最高级优先级）
接下来开始第一个病人：
一、EXIT（Extern Interrupt）外部中断： 1、简介 （简单来说，就是引脚电平变化，申请中断）
（1）触发方式：
上升沿：就是电平从低电平变到高电平的瞬间触发中断。
下降沿：就是电平从高电平变到低电平的瞬间触发中断。
双边沿：上升沿和下降沿都可以触发中断
软件触发：就是引脚啥事没有，程序里执行一句代码就能触发中断。
注意：•支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断，意思比如PA0和PB0不能同时用。
（2）通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒；总共有20个中断线路，前16个为外部中断的主要功能，后四个相当于“蹭网”（一、因为外部中断有一个功能，就是从低功率模式的停止模式下唤醒STM32，那对于PVD电源电压监测，当电源从电压过低恢复时，就需要PVD借助一下外部中断退出模式；二、有时为了省电，RTC定一个闹钟后，STM32会进入停止模式，等到闹钟饷时候再唤醒，这也需要借助外部中断......知道一下就行）
（3）触发响应方式：
中断响应：正常的流程，引脚电平变化触发中断。
事件响应：不会触发中断，而是触发别的外设操作，属于外设之间的联合工作。
（4）EXIT外部中断的基本结构
AFIO：实际是数据选择器，将前面3个外设的GPIO外设引脚里选择其中一个连接到后面EXTI的通道里，（所以前面说”所有GPIO口可以触发中断，相同的PIN不能同时触发中断“，因为这些只有其中一个能被接到EXTI的通道0上）
EXTI连接NVIC通道中，9到5被放在用一个通道会触发同一个中断函数，15到10也会触发同一个中断函数，在编程的时候，我们在这两个中断函数，需要再根据标志位来区分到底是哪个中断进来。下面20那连的其他外设就是事件响应。
2、AFIO复用IO口 这里的重定义即把这些默认复用功能的引脚换到重定义的这个位置来：
（右边两列）
3、EXTI框图 这里说一下，中间第二个“请求挂起寄存器”相当于一个中断标志位，我们可以读取这个寄存器判断是哪个通道触发的中断，如果中断挂起寄存器，它就会继续向左走，和中断屏蔽寄存器共同进入一个与门，然后是NVIC中断控制器。（这里的与门相当于开关的作用，中断屏蔽寄存器给1，那么另一个输入就是直接输入，也就是允许中断；中断屏蔽器给0，那另一个输入无论是什么，都为0，相当于屏蔽了这个中断）下面事件屏蔽寄存器同理，最后通过脉冲发生器连接其他外设，这个脉冲发生器就是给一个电平脉冲，用来触发其他外设的动作。
EXTI配置
AFIO口的库函数包含在GPIO函数文件里，打开之前12个函数附近，可以看到后面六个函数，其中后五个是AFIO口的配置，加上之前第二个函数一共六个AFIO配置函数：
这个函数是用来复位AFIO口的。
后六个函数名如下：（只用第五个）
第一个（361）GPIO_PinLockConfig函数是设定GPIO配置的，调用这个函数，参数指定某个引脚，防止意外更改；
第二个和第三个（362-363）GPIO_EventOutputConfig和GPIO_EventOutputCmd函数是用来配置AFIO的事件输出功能的
第四个（364）GPIO_PinRemapConfig函数可以用来进行引脚重映射
第五个是重点， GPIO_EXTILineConfig函数可以配置AFIO的数据选择器，来选择我们想要的中断引脚，打开这个函数可以看到里面是操作的AFIO的寄存器。
第六个是以太网外设
开始用EXIT中断：
只需要把这个外部中断，从GPIO到NIVC这一路出现的外设模块都配置好，把这条信号电路打通即可，外部中断配置步骤如下：
第一步：配置RCC，把我们这里涉及的外设时钟都打开，让其工作；
第二步：配置GPIO，选择我们的端口为输入模式；
第三步：配置AFIO，选择我们用的这一路GPIO，连接到后面的EXTI；
第四步：配置EXTI，选择边沿触发方式，比如上升沿、下降沿或者双边沿，还有选择触发响应方式，可以选择中断响应和事件响应（一般中断响应）；
第五步：配置NVIC，给我们这个中断选择一个合适的优先级，最后通过NVIC，外部中断信号就能进入CPU了。CPU收到中断信号，会跳到中断函数里执行中断程序
**配置EXTI:
1、void EXTI_DeInit(void);//把EXTI的配置调整，恢复成上电默认状态
2、void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);//EXTI外设参数配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e5ef208c5066f336d9b1982bd258727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c411c68fdca0229b7328c4b6af2aa1ea/" rel="bookmark">
			【路径规划】基于matlab遗传算法光伏实验室小车栅格地图路径规划【含Matlab源码 2572期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、栅格地图简介 1 栅格法应用背景
路径规划时首先要获取环境信息， 建立环境地图， 合理的环境表示有利于建立规划方法和选择合适的搜索算法，最终实现较少的时间开销而规划出较为满意的路径。一般使用栅格法在静态环境下建立环境地图。
2 栅格法实质
将AGV的工作环境进行单元分割， 将其用大小相等的方块表示出来，这样栅格大小的选取是影响规划算法性能的一个很重要的因素。栅格较小的话，由栅格地图所表示的环境信息将会非常清晰，但由于需要存储较多的信息，会增大存储开销，同时干扰信号也会随之增加，规划速度会相应降低，实时性得不到保证；反之，由于信息存储量少，抗干扰能力有所增强，规划速随之增快，但环境信息划分会变得较为模糊，不利于有效路径的规划。在描述环境信息时障碍物所在区域在栅格地图中呈现为黑色，地图矩阵中标为1，可自由通行区域在栅格地图中呈现为白色，地图矩阵中标为0。路径规划的目的就是在建立好的环境地图中找到一条最优的可通行路径，所以使用栅格法建立环境地图时，栅格大小的合理设定非常关键。
3 10乘10的静态环境地图
10乘10的静态环境地图代码
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%建立环境地图%%%%%%%%%%%%%%%%%%%%%%%%%%%% function DrawMap(map) n = size(map); step = 1; a = 0 : step :n(1); b = 0 : step :n(2); figure(1) axis([0 n(2) 0 n(1)]); %设置地图横纵尺寸 set(gca,'xtick',b,'ytick',a,'GridLineStyle','-',... 'xGrid','on','yGrid','on'); hold on r = 1; for(i=1:n(1)) %设置障碍物的左下角点的x,y坐标 for(j=1:n(2)) if(map(i,j)==1) p(r,1)=j-1; p(r,2)=i-1; fill([p(r,1) p(r,1) + step p(r,1) + step p(r,1)],.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c411c68fdca0229b7328c4b6af2aa1ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90108aa538ce4206ab24de6826e954b7/" rel="bookmark">
			【路径规划】基于matlab强化学习Q-Learing栅格地图路径规划【含Malab源码 2720期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、强化学习Q-Learing 使用强化学习中的Q-Learning算法路径规划的步骤如下：
定义状态(State)：将栅格地图划分为离散的状态间。每个栅格可以是一个状态，或者根据需求进一步细分。
定义动作(Action)：定义智能体可以采取的动作集合，例如上、下、左、右等。每个动作对应智能体在当前状态下执行的操作。
定义奖励(Reward)：为每个状态和动作定义奖标是让智能体通过选择动作最大化累积奖励。
初始化Q值：创建一个Q表，其行状态，列表示动作。初始化Q表中的Q值为零或随机数。
迭代过程：
a. 选择动作：基于当前状态选择动作。可以使用ε-greedy策略，在ε概率下选择一个随机动作，以便探索未知的状态；否则(1-ε)概率下选择具有最大Q值的动作。
b. 执行动作：在环境中执行选择的动作，观察下一个状态和获得的奖励。
c. 更新Q值：使用Q-Learning更新规则更新Q值。根下一个状态的最大Q值和当前状态的奖励计算新的Q值。
d. 更新状态：将下一个状态设置为当前状态。
e. 重复步骤a-d，直到达到停止条件（例如达到最大迭代次数或收敛）。
使用训练好的Q表选择最佳路径：在训练完成后，使用训练好的Q表选择具有最高Q值的动作作为最佳路径规划方案。
需要注意的是，以上步骤是基本的Q-Learning过程，你可能需要根据具体的栅格地图问题进行相应的调整和优化。
⛄二、部分源代码 function varargout =PathPlanning(varargin)
% 移动机器人路径规划仿真平台接口：仿真平台提供了机器人工作环境的仿真界面，利用inf=load(‘inf’),sp=inf.StartPoint,
% EP=inf.EndPoint,WS=inf.env得到机器人工作环境的出发点、目标点位置及障碍物位置信息，工作空间边界及障碍物区域设置为1，自由空间
%设置为0。
gui_Singleton = 1;
gui_State = struct(‘gui_Name’, mfilename, …
‘gui_Singleton’, gui_Singleton, …
‘gui_OpeningFcn’, @Simulation_OpeningFcn, …
‘gui_OutputFcn’, @Simulation_OutputFcn, …
‘gui_LayoutFcn’, [] , …
‘gui_Callback’, []);
if nargin &amp;&amp; ischar(varargin{1})
gui_State.gui_Callback = str2func(varargin{1});
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90108aa538ce4206ab24de6826e954b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726cd6deaf2bd827e4dd03d8a6c3fa78/" rel="bookmark">
			docker应用部署---Tomcat的部署配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 搜索tomcat镜像 docker search tomcat 2. 拉取tomcat镜像 docker pull tomcat 3. 创建容器，设置端口映射、目录映射 # 在/root目录下创建tomcat目录用于存储tomcat数据信息 mkdir ~/tomcat cd ~/tomcat docker run -id --name=c_tomcat \ -p 8080:8080 \ -v $PWD:/usr/local/tomcat/webapps \ tomcat ● 参数说明：
○ -p 8080:8080：将容器的8080端口映射到主机的8080端口
-v $PWD:/usr/local/tomcat/webapps：将主机中当前目录挂载到容器的webapps
4. 创建一个html页面（用于后面的测试） touch test cd test vi index.html &lt;h1&gt;hello docker tomcat&lt;/h1&gt; &lt;p&gt;nihao&lt;/p&gt; 5. 使用外部机器访问tomcat 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c05a47899dd6fc406ec25b9ae06723f/" rel="bookmark">
			C语言初阶-数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、一维数组的创建和初始化
1.数组的创建
2.数组的初始化
不完全初始化：
不初始化：
3.一维数组的使用
4.一维数组在内存中的存储
通过指针访问数组元素：
二、二维数组的创建和初始化
1.二维数组的创建
2.二维数组的初始化
​编辑
3.二维数组的使用
4.二维数组在内存中的存储
三、数组越界
四、数组作为函数参数
1.冒泡排序函数的错误设计
2.数组名是什么？
1. sizeof(数组名)
2. &amp;数组名
3.冒泡排序函数的正确设计
一、一维数组的创建和初始化 1.数组的创建 数组是一种相同元素类型的集合。
数组的创建：
type_t arr_name [const_n];
/ / type_t 是指数组的元素类型
/ / const_n 是一个常量表达式，用来指定数组的大小
举例：
int arr1[10]; char arr2[10]; float arr3[1]; double arr4[20]; 其中，int，char，float，double就是数组的元素类型，10，10，1，20分别是数组的大小。
下面是一个错误示例：
int main() { int n = 0; int arr[n] = { 0 }; return 0; } 运行时编译器会报错：
这个原因其实前面也讲过：有些编译器在定义数组时，数组的大小必须是一个常量表达式，而上述代码中的n是变量。
注意：C99中引入了变长数组的概念，允许数组的大小用变量来指定，如果编译器不支持C99中的变长数组，那就不能使用，相反，支持C99的编译器可以使用变量来指定数组的大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c05a47899dd6fc406ec25b9ae06723f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e4a09970e23472eb5557e5fdccee2d/" rel="bookmark">
			VCS的使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VCS VCS是一个编译型Verilog仿真器，用于验证数字电路设计的正确性。VCS可以进行逻辑仿真、时序仿真和功耗仿真。
VCS的工作流程如下：
将Verilog或SystemVerilog代码转化为C代码。在Linux环境下使用C编译器编译C代码，并链接库文件，生成可执行文件。运行生成的可执行文件，对设计进行仿真。 vcs source_files [compile_time_options]命令：用于编译Verilog代码，并生成可执行文件(simv)用于仿真。
其中，source_files 指定了要编译的源文件列表，可以是多个文件，文件名之间用空格分隔。 compile_time_options 是编译时的选项，指定VCS如何进行编译，例如优化级别、调试信息等。
常见的[compile_time_options] -Mupdate:增量编译。当需要对一个或多个文件进行修改并重新编译时，使用-Mupdate命令可以避免重复编译，从而节省时间。
-R：编译后立即执行。
-gui:图形化界面
-l &lt;filename&gt;：保存一些运行时的log文件
-sverilog：支持SystemVerilog
-v lib_file：表示将库文件lib_file加入vcs的库搜索路径中。如果RTL代码中有IP，vcs会在lib_file这个文件中去搜索这个IP
-y lib_dir: 添加一个路径，用于搜索模块定义
+libext+:在lib库中搜索指定后缀名的文件
+incdir+&lt;directory&gt;:将 &lt;directory&gt; 添加到头文件搜索路径中，以便编译器可以找到在源代码中使用 ``include 包含的文件。 假设有一个名为 'example.v'的 Verilog 源代码文件包含：include “header.h”,而header.h在/home/user/include目录下，则可以使用命令：vcs +incdir+/home/user/include example.v`
-f file:指定一个文件作为VCS命令行参数的输入源。每个参数占据文件中的一行。
-o filename:改变生成的可执行的文件的名字，不叫simv了
仿真过程 simv [run_time_options]：[run_time_options]制定了vcs如何执行仿真
常见的[run_time_options] -s:停止仿真
-l logfile:把仿真时的输出和日志存到logfile文件中
在VCS中使用DesignWare库 DesignWare 库是 Synopsys 公司提供的一个硬件 IP 核库，包含了许多用于 SoC 设计的可重用 IP 核和子系统。
vcs -v $DW_ROOT/dw/sim_ver/:把DW库的路径添加到搜索路径中，其中DW_ROOT就是DW库的根目录。
当然verilog代码中也要include的所用的模块，比如：``include “dw/axi_master/verif/dw_axi_master.sv”`
VCS debugging 命令行debug：UCLI，不好用、不常用
verdi：专门用于debug
DVE：vcs的GUI界面
要考虑的方面：仿真速度、信号可见性、信号可追踪性tractability、可用性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e4a09970e23472eb5557e5fdccee2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05d1545f94b5172d19886e7f32fbd36/" rel="bookmark">
			C语言初阶--初识C语言(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、第一个C语言程序
二、数据类型
1.常见的数据类型
2.计算机的基本单位
三、认识变量与常量
1.定义变量的方法
2.变量的分类：
3.变量的作用域与生命周期
3.1变量的作用域
3.2变量的生命周期
一、第一个C语言程序 以上为程序的代码及运行结果，注意：
1.一个程序中main函数是程序的入口，有且只有一个。
2.程序中所有的符号如：“” ；（）等不能忘记，且应该用英文符号。
3.“\n”是换行符。如不使用，运行结果应该是hello worldhehe。
main函数有三种写法：
这是最常见的写法。
旧式的写法，不建议使用。
这种写法也是对的，括号中的void表示mian函数不需要参数。
二、数据类型 1.常见的数据类型 以上就是常见的数据类型，那么计算机为什么要搞这么多数据类型呢？
因为每种数据类型所占空间不同，选择合适的类型可以提高空间利用率。
下面我们用代码来验证一下每个数据类型的大小
代码中sizeof是一个操作符，用来计算类型和变量的大小，由运行结果可知图中各数据类型的大小分别为1byte、2byte、4byte、4byte、8byte、4byte、8byte。
C语言标准规定：sizeof(long)&gt;=sizeof(int).
2.计算机的基本单位 bit :比特位
byte :字节 1byte=8bit
KB: 1KB=1024byte
MB: 1MB=1024KB
GB: 1GB=1024MB
TB: 1TB=1024GB
PB: 1PB=1024TB
三、认识变量与常量 变量：用来描述变化的数据（例如：身高、体重、血压等）
常量：用来描述不变的数据（例如：圆周率、性别、身份证号码等）
1.定义变量的方法 数据类型+变量名=给变量名赋的初值
如图：
代码中55.5f代表数据是单精度浮点数，如果不加f，编译器默认为双精度浮点数 。
注意：定义字符时用单引号（即‘’），定义字符串时用双引号（即“”）。
2.变量的分类： 全局变量
局部变量
区分全局变量和局部变量的方法：看它的位置，在{}里面为局部变量，在{}外面为全局变量。
图中的b为全局变量，a为局部变量。
注意：当全局变量和局部变量名字相互冲突下，局部变量优先。图中定义全局变量a=15,同时定义局部变量a=10,最终运行结果是10。
3.变量的作用域与生命周期 3.1变量的作用域 局部变量作用域：变量所在的局部范围
全局变量作用域：整个工程
局部变量使用示例：
变量在局部范围内可以正常输出 。
局部范围外输出就会出现报错。
全局变量使用示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c05d1545f94b5172d19886e7f32fbd36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d1d7471a71f9198376831b4ab19fb68/" rel="bookmark">
			双态IT乌镇用户大会——数据中心业务连续性国标专题研讨会成功举办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年10月13日-15日，由ITSS分会、证券基金行业信息技术应用创新联盟指导，ITSS数据中心运营管理组（DCMG）、双态IT论坛、智能运维国标工作组主办，ITSS媒体组、AI范儿协办的“2023第六届双态IT乌镇用户大会”于浙江乌镇召开。政府、央企、金融各行业精英齐聚大会现场。双态IT联盟成员单位同创永益受邀参加本次大会，并举办「“数智觉醒，韧性新生”，数据中心业务连续性国标专题研讨会」专场会议。
全球经济蓬勃发展，为保障企业生产管理平稳运行，业务连续性的体系建设对于金融行业至关重要。业务连续性保障业务连续不间断平稳运营，在经济发展大环境下，金融企业提供的服务业务可以促进经济平稳运行，因此维持金融体系的业务连续性对支撑经济快速发展起到至关重要的作用。
本次“数智觉醒，韧性新生”，数据中心业务连续性国标专题研讨会，邀请到银行、保险、证券的专家围绕《数据中心业务连续性等级评价准则》GB/T42581-2023，展开讨论，分享业务连续性建设工作实践经验与未来发展趋势。
会议伊始，ITSS数据中心运营管理组组长肖建一对《数据中心业务连续性等级评价准则》国标进行内容解读。他表示，国家标准化管理与行业监管已逐渐系统化，系列标准的制定为业务连续性管理提供了的支持，但在为数据中心提供业务连续性的指导时不够准确。本标准的制定，给出了数据中心业务连续性等级定义、等级评价模型，并提出评价办法及操作方法。本标准为生产环境业务连续性水平提供了评价依据和关键指标，有利于推动业务规范化及业务连续性能力提升。同时，考虑到多方需求，在各行业进行试点实验，为本标准的落实与使用奠定夯实的基础。
中国质量认证中心作为头部认证机构依据《数据中心业务连续性等级评价准则》，首次推出《数据中心业务连续性等级认证》项目，该项目是数据中心领域，唯一针对业务连续性的特定认证项目。陈凯介绍，认证单位的业务连续性应用阶段与基础设施阶段都是重要的考核项目，中国质量认证中心拥有系统化的审核架构可以叠加计算层、应用层连续性，使认证单位更加便捷了解自身业务连续性的水平，帮助认证单位快速定位，完成认证。
会上，金融机构代表、企业专家代表对业务连续性管理体系建设相关实践，进行充分的经验分享。
中国建设银行运营数据中心灾备运维处协助负责人王雪萌分享了建行的《业务连续性体系建设实践与探索》。为确保业务连续性平稳运行，需要构建灾备组织架构和高效的管理机制，持续优化管理流程，针对不同架构形成个性化标准方案，并在灾备建设的过程中形成灾备演练与运维的管理工具。建立高可用架构标准，明确高可用管理要求和标准架构模型能力，在高可用模型、运维对象、应用系统间建立管理视图，通过自动化手段对应用及基础设施对象进行高可用能力检核，主动发现高可用风险，生成演练报告，形成管理闭环。
北京银行西安灾备中心室副经理尤晓青作《守正创新，银行灾备能力平台化实践探索》分享。他表示，近年来银行行业普遍存在业务连续性管理痛点，应用预案风险场景覆盖度、常态化演练都存在欠缺。通过管理梳理提升以及引入平台化的落地、建立流程规范，同时达到监管制度要求以及行内风险管理要求，提升灾备有效性，实现预案模块化管理。
同创永益CTO郑阳作《与数智化共舞·业务稳定性保障新动力》主题分享。他表示，随着乌卡（VUCA）时代突然到来，易变性、不确定性、复杂性、模糊性加剧，全球数字化转型进入到关键阶段。随着新技术的引入，AI技术的发展，业务稳定性技术已由传统走向智能化，可以更加便捷地帮助客户理解业务连续性相关的知识、方法论，并能够根据演练场景智能推荐演练方案和应急预案。
太保科技业务连续性管理负责人刘强，以太保科技实践为基础分享了《保险数字韧性敏捷创新》。目前，业务连续性已成为系统性的社会风险，业务连续性的建设工作与概念普及恰逢其时。业务连续性不仅要关注灾备管理，业务管理也是其中重要环节。在当前大环境下，需要通过技术不断创新，精细化演练管理、自动化灾备与生产配置校验比对。在生产故障发生后，快速分析故障原因，排除故障，恢复IT服务，保证业务连续运行，提升业务稳定性。
申万宏源信息技术保障总部总经理助理张浩作《变更风险管控助力业务连续性》分享。业务连续性覆盖方面广阔，业务系统、基础设施、人员团队培养都是不可或缺的因素。对于证券公司来看信息科技服务业务广泛，使得信息技术迭代频繁，通过多维度的“全网测试”对于重大的变更与信息系统，将故障演练作为质量门禁在上线前进行探测，保障实际项目平稳进行。
同创永益副总裁郑星作《数据中心业务连续性等级评价准则》国标能力体系建设要点分享。加强基础设施，建立面向应用和未来的双态IT融合的灾备体系。面向客户数字化转型带来的业务连续性挑战。充分提升IT价值和业务连续性，建立混沌工程体系化方法，提供成熟的实践场景和丰富的故障注入手段，帮助企业发现更多影响业务连续性问题。在开发、测试、运营各个阶段提升系统稳定性，助力企业机构治理现代化和服务智慧化。
运维与维护作为数据中心全生命周期中历时最长的一个环节，其重要性不言而喻，“三分建设，七分管理”的观念得到行业普遍认可。本次会议还进行了数据中心基础设施运维评价授牌仪式，太平洋保险的数据中心通过运维评价，获得中国质量认证中心签发的认证证书。
数据中心基础设施运维评价 授牌仪式
会议还评选出首批《数据中心业务连续性等级评价准则》国标试点单位，他们分别是交通银行、吉林银行、昆仑银行、太平洋保险、申万宏源证券。能够成为第一批试点单位并通过评估，是数据中心管理单位有效证明当前业务连续性工作已经在标准化、规范化方面行业领先。
《数据中心业务连续性等级评价准则》国标试点单位启动仪式
本次“数智觉醒 韧性新生 数据中心业务连续性国标专题研讨会”，为金融业业务连续性管理发展提供了沟通交流的平台，帮助金融机构对建立、管理、维护业务连续性有了更加深入的体悟。此外，会议推动了《数据中心业务连续性等级评价准则》国标的宣传与普及，以金融为起点，让更多行业、领域在数据中心业务连续性建设上更全面、更有效，促进各行业在数字化浪潮中稳定前行。
同创永益简介
北京同创永益科技发展有限公司成立于2009年，是国高新技术企业、专精特新“小巨人”企业、信创工委会技术活动单位、中国信通院混沌工程实验室副理事长单位。公司深耕企业用户数字韧性服务，业务覆盖灾难恢复、业务连续性、IT应急管理、容量管理、混沌工程等产品和解决方案，拥有自主知识产权和全栈服务能力，致力于帮助客户建设数字化系统的全领域韧性体系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e414f808041e99409b5d389f4eab8a76/" rel="bookmark">
			vscode中如何配置prettier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{ "workbench.startupEditor": "none", "files.eol": "\n", "[html]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[css]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[scss]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[javascript]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[json]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[jsonc]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[vue]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "js/ts.implicitProjectConfig.experimentalDecorators": true, "vetur.format.options.tabSize": 2, "explorer.confirmDelete": false, "editor.multiCursorModifier": "ctrlCmd", "editor.guides.bracketPairs": true, "editor.codeActionsOnSave": { // 保存时使用 ESLint 修复可修复错误 "source.fixAll": true, "source.fixAll.eslint": true }, "git.openRepositoryInParentFolders": "always", "eslint.quiet": false, // 忽略 warning 的错误 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e414f808041e99409b5d389f4eab8a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d854318c325c72e8101828b0377137/" rel="bookmark">
			【爬虫】charles手机抓包环境设置（设置系统证书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说明 想要对手机抓包，最关键的是需要设置好根证书，用户证书在安卓7.0之后就不受信任了，想要对手机app抓包，就需要把用户证书设置为系统证书（根证书）
注意，想要设置为根证书，你的安卓需要获取到root权限，但是root会有风险，很大app（如银行类app）都不能在已root的设备上运行，所以一般推荐使用模拟器操作，此处以雷电模拟器9和charles为例进行演示
2.charles设置 设置ssl抓包类型，菜单栏Proxy–SSL Proxy Settings，勾选“Enable SSL Proxying”，新增一个类型，IP端口都设置为“*”（表示全部）
设置远程端口，菜单栏Proxy–Proxy Settings，Http Proxy这里设置一个端口号，例如8888，勾选下面两个传输类型
查看远程安装证书信息，点击菜单栏Help–SSL Proxying–Install Charles Root Certificate on a Mobile Device or Remote Browser，它弹出一个窗口，显示本机代理的IP端口（我这里是10.10.66.1:8888），以及证书下载URL（chls.pro/ssl）
3.模拟器设置 打开模拟器的设置页面，找到root选项把它开启，大多数模拟器都支持root，都是在设置界面可以打开root开关，如果有写入设置也需要开启
打开系统设置，找到WLAN设置，然后把点击当前网络右上角的编辑按钮，把代理设置为Charles帮助信息显示的IP端口即可
4.设置用户证书 打开系统自带的浏览器，它会弹出证书不受信任的问题，不管它，一路点击“继续”知道不弹出提示。现在访问一下chls.pro/ssl，此时Charles那边应该会有一个确认按钮，确认之后模拟器就会下载证书，下载完完成之后点击安装，模拟器会提醒设置一个锁屏（图案或pin都可以），这时候就可以安装证书了，证书名可以随便写
5.设置系统证书 现在设置的是用户证书，在安卓7之后app是不信任用户证书的，所以我们还需要把它设置为系统证书，其实就是把这个证书文件复制到系统证书目录里就行
用户证书目录：/data/misc/user/0/cacerts-added/
系统证书目录：/system/etc/security/cacerts/
这个操作很容易，只要获取到root权限就行，你可以直接在文件管理器里把系统证书复制到用户证书的文件夹里，证书是一个.0结尾的文件，我这里是ca499da3.0，如果以前没有安装过用户证书，那用户证书文件夹里只有一个文件，很好找到的
如果你有adb，也可以使用adb的shell操作
adb devices adb shell su mount -o remount,rw /system cp /data/misc/user/0/cacerts-added/ca499da3.0 /system/etc/security/cacerts/ 另外我们可以发现，其实证书文件的文件名就是一个哈希值，你也可以直接从charles导出证书，然后复制到安卓的证书文件夹里就行，但这种做法前提是你能使用openssl
首先，导出Charles证书文件（pem格式）
然后使用openssl生成哈希（证书文件名）
openssl x509 -subject_hash_old -in 证书文件路径 之后把Charles证书文件改名为哈希.0，最后使用adb把它push到对应的证书文件夹里即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78aa81dd02ef76b0ceb01fbf24f6f77c/" rel="bookmark">
			python 字符串str与字典dict转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 python 字符串str与字典dict转换 字典转字符串字符串转字典 带引号不带引号 python 字符串str与字典dict转换 字典转字符串 c = {'a': '1', 'b': '1'} b=str(c) print(b,type(b)) 字符串转字典 字符串转字典分两种情况，需要根据你的字符串内容是否带引号决定，如
# 带引号 c = {'a': '1', 'b': '1'} #不带引号 c = {a: 1, b: 1} 带引号 带引号的可以用json处理将字符串转成字典，下面案例的str是从一个文件中获取，也可以直接赋值
import json #a = '{"a":"1", "b":"1"}' with open(f".aaa.txt","r") as f: a = f.readline().strip() c=json.loads(a) print(c, type(c)) 不带引号 不带引号的可以用ast处理
import ast a = {a:1, b:1} c=ast.literal_eval(a) print(c, type(c)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693ede63858da80ac82211e94fbd0f1c/" rel="bookmark">
			springboot &#43; redis实现签到与统计功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在很多项目中都会有签到与统计功能，最容易想到的方案是创建一个签到表来记录每个用户的签到记录，比如设计一个mysql数据库表：
CREATE TABLE tb_sign id bigint(20) unsigned NOT NULL AUTOINCREMENT COMMENT '主键', user_id bigint(20) unsigned NOT NULL COMMENT '用户ID', sign_date date NOT NULL COMMENT '签到的日期', is_backup tinyint(1) unsigned DEFAUL TNULL COMMENT '是否补签', PRIMARY KEY (id) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW FORMAT=COMPACT; 用户签到一次就可以往表里添加一条记录；但是这样有一个坏处，就是占用的内存太大了，会极大的消耗内存空间；比如有1万用户，每个用户每个月签到10次，那么一个月就是10万条记录，一年就是120万条；如果用户更多并且签到的次数越多，那么数据量就会更大哦。
签到一次需要使用8+8+3+1 = 20个字节，如果使用redis中的bitmap来实现，每次签到与未签到用1与0来表示，那么只需要2个字节即可了，这样极大的节约了内存；那么接下来认识与使用bitmap。
1.bitmap基本操作指令 SETBIT：向指定位置（offset）存入一个0或1
GETBIT：获取指定位置（offset）的bit值
BITCOUNT：统计BitMap中值为1的bit位的数量
BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值
BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回
BITOP：将多个BitMap的结果做位运算（与 、或、异或）
BITPOS：查找bit数组中指定范围内第一个0或1出现的位置
1.1 新增 1.2 查询 1.3 统计值为1的数量 1.4 查询1 和 0 第一次出现的坐标 2.springboot整合redis 创建一个spring boot项目，这里比较简单，不用过多介绍；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/693ede63858da80ac82211e94fbd0f1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6da7ed005f387f61264909d623e8e52/" rel="bookmark">
			el-select 、el-option 常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt;
&lt;div&gt; // 可以多选 // 添加小叉，点击清空选择器
&lt;el-select v-model="selectedValue" multiple disabled clearable filterable &gt;
&lt;el-option // 整个选择器禁用 // 启用搜索功能,在label们中找 v-for="item in options"
:key="item.value"
:label="item.label"
:value="item.value" // value 可以为某一个属性，也可以为对象 如：value = "item"
// disabled 禁用效果，某一项显示但不可选择
:disabled="item.disabled"&gt;
&lt;span style="float: left"&gt;{{ item.label }}&lt;/span&gt; // 自定义选项样式
&lt;span style="float: right"&gt;{{ item.selfDefiningValue }}&lt;/span&gt;
&lt;/el-option&gt;
&lt;/el-select&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
data() {
return {
selectedValue: '', // 存储用户选择的值
options: [
{ value: 'option1', label: '选项1',selfDefiningValue:'自定义值' },
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6da7ed005f387f61264909d623e8e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c6e68f33dec478f7e6016b439f0f7b/" rel="bookmark">
			office 2010 由于本机的限制,该操作已被取消。请与系统管理员联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下，免得下次再遇到去找方法：
office超链接遇到这样的问题：
处理办法：
修改注册表：cmd-&gt;regedit
地址：HKEY_CURRENT_USER\SOFTWARE\Classes.html
修改为:htmlfile
关闭office，再重新打开，问题解决；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d778b9b011e651f19e4312e6e2d502/" rel="bookmark">
			修改谷歌浏览器标签页名字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 背景 在开发过程中，有时我们会对同一个网站打开很多的浏览器标签页，比如 百度首页 页面，用来同时保存多个开发窗口，多个标签页内有不同的内容，但是多个标签页的名称是根据网站自动提取的，完全一样，我们可能无法区分，如下图：
此时我们很难区分每个标签页中的内容是什么，只能靠自己去记住顺序，很麻烦。如果能够修改每个标签页的名字，那就非常方便了。但是谷歌浏览器并没有提供标签页名称的修改功能，因此需要我们自己手动去执行一些步骤来操作。
2. 修改步骤 在自己要修改的标签页的页面，按 F12 键，打开开发者模式。
在上图中指示的 控制台 下面输入如下代码，然后按 回车 键执行。
javascript:void(function(){document.title=prompt('新标签页名称')}()) 执行成功后出现如下界面
在图中指示的地方输入自己想要的标签页名称，然后点击 确定。
修改完之后，效果如下。
其他标签页也可以根据这个方法一一修改，修改完之后效果如下。
3. 注意 每次执行修改一个标签页的名称。标签页名称修改完之后不要刷新标签页面，否则标签页名称又会变成原来的网站名称。 上面控制台运行的 javascript 代码，其实就是修改了页面 html 代码中的 title 标签中的内容，可以自己点击开发者工具中的 元素 查看具体的代码。直接修改 title 标签中的内容，也可以达到一样的效果，所以不能刷新页面，因为刷新页面之后，title 标签中的内容就又变回原来的了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b764e7e94c818233a5f796ae0e5e6a1/" rel="bookmark">
			jmeter生成的HTML报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解读HTML报告 .图形化HTML压测报告Dashboard讲解
1）Test and Report informations
source file:生成的jtl文件名 Start Time:压测起始时间 End Time:压测结束时间 Filter for display:过滤器 Lable:sampler采样器名称（http请求的名称）
2)APDX(Application performance Index)
apdex:应用程序性能指标，范围在0~1之间，1表示到达所有用户均满意， T(Toleration threshold):可接受阀值 F(Frustration threshold):失败阀值
3)Requests Summary
FALL:失败率 PASS：通过率，成功率
4)Statistics 统计数据
lable:sampler采样器名称（http请求的名称） samples:请求总数，并发数*循环次数 FALL:失败次数 Error%:失败率
Average:平均响应的时间 min：最小响应的时间 max：最大响应的时间 90th pct:90%的用户响应不会超过这个值（建议关注这个） 95th pct:95%的用户响应不会超过这个值 99th pct:99%的用户响应不会超过这个值（到达这个值已经够高了）
throughput:Request per Second吞吐量 qps
吞吐量=并发数/平均响应时间
吞吐量=请求总数/总时长 received:每1秒从服务器接收的数据量 send：每1秒发送的数据量
2.图形化HTML压测报告 Chats报表讲解 1.Charts讲解
1)Over Time(随时间的变化)
Response Times Over time:响应时间变化趋势 Response Time Percentiles Over Time(successful responses):最大，最小，平均，用户响应时间分布
Active Threads Over Time:并发用户数趋势
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b764e7e94c818233a5f796ae0e5e6a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c61feff0b09a65cadce1224505e90c/" rel="bookmark">
			4步实现Android中的Websocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍如何在Android应用中使用WebSocket实现实时通信，并通过示例入门。
微信搜索关注《Java学研大本营》
1 介绍 WebSockets彻底改变了Web平台上的实时通信，实现了客户端和服务器之间的双向数据交换。在Android应用开发中，集成WebSocket为构建响应式和交互式应用提供了强大的工具。本文将介绍WebSocket的基础知识，并指导你在Android平台上实现WebSocket，同时提供一些代码示例以帮助你入门。
2 什么是WebSocket？ WebSocket是一种全双工通信协议，它为客户端和服务器之间提供了一种双向通信渠道，通过单个长连接实现数据传输。区别于传统的HTTP请求，WebSocket允许实时事件驱动通信，从而使服务器能够立即向客户端推送数据，避免频繁的请求和响应，减少了网络开销。 WebSocket的优势在于它能够更快地传输数据，节省带宽，同时实现实时通信。 WebSocket的出现为构建响应式和交互式应用程序提供了强有力的工具，为实现更好的用户体验和更高的应用程序效率带来了便利。这种能力对于需要实时更新或实时数据流的应用程序特别有用，通过建立长连接，WebSocket可实现更快的数据传输速度，避免反复的HTTP请求和响应，从而在实时通信场景下具有显著的优势。
3 设置项目 首先，在集成开发环境（IDE）中创建一个新的Android项目，并确保已经配置了必要的依赖项。在Android中，用于WebSocket实现的常用库之一是java-websocket。通过将以下行添加到应用程序级别的build.gradle文件中，将该库包含在项目中：
implementation 'org.java-websocket:Java-WebSocket:1.5.1' 3.1 建立WebSocket连接 在Android中建立WebSocket连接，需要创建一个新类，继承自java-websocket库中的WebSocketClient类。该类充当客户端和服务器之间的中介。为处理WebSocket事件，需要覆盖onOpen，onMessage，onClose和onError等必要的方法。
以下是建立WebSocket连接的示例：
import org.java_websocket.client.WebSocketClient; import org.java_websocket.handshake.ServerHandshake; import java.net.URI; import java.net.URISyntaxException; public class MyWebSocketClient extends WebSocketClient { public MyWebSocketClient(String serverUrl) throws URISyntaxException { super(new URI(serverUrl)); } @Override public void onOpen(ServerHandshake handshake) { // WebSocket连接已成功建立 // 在此执行任何必要的操作 } @Override public void onMessage(String message) { // 处理来自服务器的传入消息 } @Override public void onClose(int code, String reason, boolean remote) { // WebSocket连接已关闭 // 在此执行任何必要的清理操作 } @Override public void onError(Exception ex) { // 处理WebSocket连接期间发生的任何错误 } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c61feff0b09a65cadce1224505e90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203a3451beff55c8b466a1fc18048f1c/" rel="bookmark">
			linq join on 多个关联条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlserver语句：
select * from Table1 join Table2 on Table1.Col1=Table2.Col1 and Table1.Col2=Table2.Col2
对应linq写法：
一：
var Infos = from a in Table1 join b in Table2 on new { a.Col1 , Col2 } equals new { b.Col1 , b.Col2}
select new { a.Col1, b.Col2 };
二：
var userInfos = from a in Table1
from b in Table2
where a.Col1 == b.Col1 &amp;&amp; a.Col2 == b.Col2
select new { a.Col1, b.Col2 };
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e72a23240f9a02a311f65a1101092d0/" rel="bookmark">
			转：java 属性赋值（驼峰-＞驼峰，驼峰-＞下划线，下划线-＞驼峰）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：java中如何快速优雅的把一个对象的属性赋值到另一个对象中（驼峰-＞驼峰，驼峰-＞下划线，下划线-＞驼峰）_如何快速赋予对象属性内容-CSDN博客
/** * ConvertUtil 转换工具类 */ public class ConvertUtil { /** * 驼峰对象转换为下划线对象 * @param source 驼峰对象 * @param target 下划线对象 * @return */ public static void humpObj2UlObj(Object source, Object target) { Map&lt;String,Object&gt; map1 = obj2Map(source); Map&lt;String,Object&gt; map2 = new HashMap&lt;&gt;(); for(String key : map1.keySet()){ map2.put(hump2Ul(key),map1.get(key)); } Object obj = map2Obj(map2, target.getClass()); BeanUtils.copyProperties(obj,target); } /** * 下划线对象转换为驼峰对象 * @param source 下划线对象 * @param target 驼峰对象 * @return */ public static void ulObj2HumpObj(Object source, Object target) { Map&lt;String,Object&gt; map1 = obj2Map(source); Map&lt;String,Object&gt; map2 = new HashMap&lt;&gt;(); for(String key : map1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e72a23240f9a02a311f65a1101092d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b58b2dec265380ebeee0a2a88caf56/" rel="bookmark">
			java多线程中，关于Thread类的join()方法释放锁的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【精选】JAVA多线程：狂抓 join()方法到底会不会释放锁，给你彻底介绍清楚（三）_join会释放锁吗-CSDN博客
java线程join方法会释放锁吗_wait和join哪个会释放锁_王者生辉的博客-CSDN博客
关于join()方法是否释放锁的问题搜了一下，大概看了这两篇文章，但是感觉都没有提到我理解的那个点，结合源码和自己的理解，补充一下。
首先join()方法调用的是native方法wait()，wait()方法是释放锁的。那么关键就是释放的什么锁？
public class JoinTest { public static void main(String[] args) { Object object = new Object(); MyThread myThread = new MyThread("MyThread", object); myThread.start(); synchronized (myThread){ //synchronized (MyThread.class){ //synchronized (object){ for (int i = 0; i &lt; 100; i++) { if (i == 20){ try { System.out.println("myThread start join"); myThread.join(); System.out.println("myThread finish join"); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + i); } System.out.println("main方法执行完毕！"); } } } class MyThread extends Thread { private String name; private Object object; public MyThread(String name, Object object) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b58b2dec265380ebeee0a2a88caf56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f65a357aadf487b1685c7a49b17a069/" rel="bookmark">
			Python 实现粒子群算法（PSO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粒子群算法 1. 题目介绍 粒子群算法，其全称为粒子群优化算法 (Particle Swarm Optimization, PSO) 。它是通过模拟鸟群觅食行为而发展起来的一种基于群体协作的搜索算法。粒子群算法属于启发式算法也叫智能优化算法，其基本思想在于通过群体中个体之间的协作和信息共享来寻找最优解。
我们的目标是寻找一个函数的全局最小值或最大值，这个函数可以是二维或三维的，也可以是多维的。为了方便理解，下面通过一张图来直观地理解这个算法（也是本实验的结果）：
可以看到，一开始图中有很多点，它们随机地分布在三维图像中，随着算法的进行，这些点会逐渐往全局最小值的方向靠拢，这个过程就像鸟类觅食一样，找到食物的鸟会带着其它鸟往食物靠拢。有的点移动得快，到达全局最小值后就不怎么动了；有些点移动得慢，会在局部来回震荡，始终也无法到达目标位置。但是不管怎样，只要有一个点到达了最优位置，就可以认为算法已经成功找到了最优解。
上图中这个三维函数的定义为：
f ( x , y ) = { 30 x − y ; x &lt; m , y &lt; m 30 y − x ; x &lt; m , y ≥ m x 2 − y / 2 ; x ≥ m , y ≤ m 20 y 2 − 500 x ; x ≥ m , y ≥ m f(x, y) =\begin{cases} 30x-y; &amp; x&lt;m, y&lt;m \\ 30y-x; &amp; x&lt;m,y≥m \\ x^2-y/2; &amp; x≥m,y≤m \\ 20y^2-500x; &amp; x≥m, y≥m \end{cases} f(x,y)=⎩ ⎨ ⎧​30x−y;30y−x;x2−y/2;20y2−500x;​x&lt;m,y&lt;mx&lt;m,y≥mx≥m,y≤mx≥m,y≥m​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f65a357aadf487b1685c7a49b17a069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4e48958689d586e7d59355b5f3642a/" rel="bookmark">
			使用HAL库完成LED流水灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用HAL库完成LED流水灯 目录 **使用HAL库完成LED流水灯****一.HAL库安装****二.配置HAL库****三.代码编写****三.烧录代码****四.观察波形****五.总结** 一.HAL库安装 搭载HAL库的软件为stm32cubemx，下载地址为https://www.st.com/en/development-tools/stm32cubemx.html
下载后在HELP处安装自己需要的HAL库
二.配置HAL库 1.选择需要的stm32芯片
2.选择SYS
3.选择RCC
4.选择GPIO，配置需要的PIN
5.选择CLock Configuration 6.选择PROJECT MANAGER
7.点击右上方的GENERATE CODE
8.然后打开文件
三.代码编写 1.在main.c中的while循环中加入以下代码
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); HAL_Delay(1000); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET); HAL_Delay(1000); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_RESET); HAL_Delay(1000); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_SET); 2.进行编译:
三.烧录代码 1.进入串口助手
2.结果
四.观察波形 1.设置debug
2.点击调试
3.选择逻辑分析仪，并点击setup logic analy
4.添加管脚
5.点击运行并观察图像 五.总结 这次实验学习了hal库的使用方法，理清了GPIO的使用原理，观察到了较精准的图像，但对代码编写掌握不足。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce818b929d864e946a03b07b4565fd8/" rel="bookmark">
			加上boot程序,FreeRTOS就跑不起来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述
bootloader跳转到APP时，app执行完初始化程序后死机
二、分析问题
第一步，执行app时死机死到哪里？通过DEBUG调试发现死到hardfault_handler()函数中，硬件错误，导致硬件错误的原因一般都是中断异常引起的。
第二步，找到问题，然后分析什么原因导致硬件错误？一般bootloader跳转到APP时要关闭app中用到的中断，那么查看系统中用到的中断：串口中断、滴答定时器中断，所以，跳转之前要关闭这两个中断：_disable_irq()和systick。
三、解决问题
1.办法1
关闭中断之后，跳转执行app正常。
void iap_load_app(u32 appxaddr)//
{ SysTick-&gt;CTRL = 0X00;//禁止SysTick
SysTick-&gt;LOAD = 0;
SysTick-&gt;VAL = 0;
__disable_irq();
jump2app=(iapfun)*(vu32*)(appxaddr+4); //用户代码区第二个字为程序开始地址(复位地址) MSR_MSP(*(vu32*)appxaddr); //初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)
jump2app(); //跳转到APP.
}
2.办法2
如下图，要打勾，不然就无法运行
四，结论
1.bootloader跳转到app之前要关闭app中用到的中断，不然就会出现硬件错误导致死机；
2.对app的内部机制要比较了解，比如：用到哪些中断、外设，这样遇到问题才能更好分析，不要停留在会用层面，一定要了解透彻，这样无论遇到什么问题，都能有一个正确的分析思路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772ab748bbafbc10ec8ef543b0c068d8/" rel="bookmark">
			k8s 1.28版本：使用StorageClass动态创建PV，SelfLink 问题修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s中提供了一套自动创建 PV 的机制，就是基于 StorageClass 进行的，通过 StorageClass 可以实现仅仅配置 PVC，然后交由 StorageClass 根据 PVC 的需求动态创建 PV。
问题：
使用 k8s 1.28版本，通过 kubectl get pvc，发现 PVC一直处于 Pending 状态。通过kubectl describe pvc [pvc名称]描述，发现如下错误：Waiting for a volume to be created either by the external provisioner 'fuseim.pri/ifs' or manually by the system administrator. If volume creation is delayed, please verify that the provisioner is running and correctly registered.
原因：
在 k8s 1.20 之后，出于对性能和统一 apiserver 调用方式的初衷，k8s 移除了对 SelfLink 的支持，而默认上面指定的 provisioner 版本需要 SelfLink 功能，因此 PVC 无法进行自动制备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772ab748bbafbc10ec8ef543b0c068d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fb14a294d69644d604d02f7c49b018/" rel="bookmark">
			SpringBoot&#43;WebSocket&#43;Vue&#43;PeerJs实现WebRTC视频通话功能，Vue视频通话，web视频通话，webrtc视频通话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发背景 博主正在担任一款电商app的全栈开发，其中涉及到一个视频通话功能。但是由于业务需求及成本考虑，不能使用第三方提供的SDK进行开发。所以博主选择使用PeerJs+WebSocket来实现这个功能。
专业名词、术语解释 WebSocket WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。
WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
WebRTC WebRTC(Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能
PeerJs PeerJS simplifies WebRTC peer-to-peer data, video, and audio calls.
PeerJS wraps the browser’s WebRTC implementation to provide a complete, configurable, and easy-to-use peer-to-peer connection API. Equipped with nothing but an ID, a peer can create a P2P data or media stream connection to a remote peer.
以上内容来源于PeerJs官网介绍，大概的意思如下（仅供参考，博主英语不好）：
PeerJS简化了WebRTC点对点数据、视频和音频呼叫。
PeerJS封装了浏览器的WebRTC实现 提供一个完整 可配置且易于使用的点对点连接API，只需要一个id就能创建到远程的P2P数据或媒体流连接。
PeerJs官网：https://peerjs.com
PeerJs官方文档：https://peerjs.com/docs/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07fb14a294d69644d604d02f7c49b018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31291a97925e0d91d8c82dfa56444c49/" rel="bookmark">
			PKU 概率论&#43;数理统计&#43;建模 期中考复习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 计算条件概率计算概率（放回与不放回）生成随机数算法Linear Congruential Method判断是否是full period Uniformity (test of frequency)1.Chi-Square testmethodreminderexample 2.Kolmogorov-Sminov testmethodexample Independence (test of autocorrelation)Runs test Acceptance-rejection methodmethod较好理解版 methodexample方法1：建议函数使用指数分布方法2：双指数分布生成正态分布方法3： 使用Acceptance-Rejection method对连续型随机变量有效，证明处处都有 P ( X ≤ x ) = F X ( x ) P(X≤x)=F_X(x) P(X≤x)=FX​(x) Empirical distribution 经验分布The Empirical Distribution ProcedureUngrouped dataconditionmethodconstruction method生成U去寻找x grouped dataconditionconstruction methodexampleHow about discrete empirical distribution? 经验分布的优点与缺点example Maximum Likelihood Estimator 最大似然估计判断数据是否相互独立 计算条件概率 【作业题】
Suppose that Die-Hardly-Ever battery has an exponential time-to-failure
distribution with a mean of 48 months.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31291a97925e0d91d8c82dfa56444c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfa97d2f87f782319d4ea886765f94f/" rel="bookmark">
			Mysql常用字段类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://zhuanlan.zhihu.com/p/348469225
1.数值类型
整型经常被用到，比如 tinyint、int、bigint 。默认是有符号的，若只需存储无符号值，可增加 unsigned 属性。
int(M)中的 M 代表最大显示宽度，并不是说 int(1) 就不能存储数值10了，不管设定了显示宽度是多少个字符，int 都是占用4个字节，即int(5)和int(10)可存储的范围一样。
浮点型主要有 float，double 两个，浮点型在数据库中存放的是近似值，例如float(6,3)，如果插入一个数123.45678，实际数据库里存的是123.457，但总个数还以实际为准，即6位，整数部分最大是3位。
定点型字段类型有 DECIMAL 一个，主要用于存储有精度要求的小数。 2.字符串类型
3.日期时间类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8a942bf56a0227b4458e432321c8a1/" rel="bookmark">
			Redis基础（含下载安装）与数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Redis基础 1.NoSQL概述 问题现象
在春运使用12306买票，与在淘宝买东西等情况时会出现春节期间买票进不去，进去了刷不着票，原因是以为用户量太大
特征
1.海量用户
2.高并发
这两个现象出现以后，对应的就会造成我们的服务器瘫痪，其实并不是我们的应用服务器，而是我们的关系型数据库。关系型数据库才是最终的罪魁祸首
造成原因
1.性能瓶颈：磁盘IO性能低下
​关系型数据库在存取数据的时候和读取数据的时候他要走磁盘IO。磁盘这个性能本身是比较低的
2.扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群 关系型数据库，它里面表与表之间的关系非常复杂，就是一张表，通过它的外键关联了七八张表，这七八张表又通过它的外键，每张又关联了四五张表。要想拿到数据，你就要从A到B、B到C、C到D的一直这么关联下去，最终非常影响查询的效率。同时，你想扩展下，也很难
解决思路
1.降低磁盘IO次数，越低越好 ——用内存存储
​2.去除数据间关系，越简单越好 ——不存关系，只存数据
把这两个特征一合并一起，就出来了一个新的概念：NoSQL
NoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题
特征
可扩容，可伸缩。SQL数据关系过于复杂，扩容一下难度很高，那Nosql 这种的，不存关系，所以它的扩容就简单一些。
​大数据量下高性能。当数据非常多的时候，它的性能高，因为不走磁盘IO，走的是内存，性能肯定要比磁盘IO的性能快一些。
​灵活的数据模型、高可用。他设计了自己的一些数据存储格式，这样能保证效率上来说是比较高的，最后一个高可用，我们等到集群内部分再去它
常见 Nosql 数据库
目前市面上常见的Nosql产品：Redis、memcache、HBase、MongoDB
应用场景
2.Redis概述 Redis (Remote Dictionary Server：远程词典服务器) 是用 C 语言开发的一个开源的高性能（内存型）键值对（key-value）数据库
特征
1.数据间没有必然的关联关系；
2.内部采用单线程机制进行工作；
3.高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。
4.多数据类型支持
字符串类型 string
列表类型 list
散列类型 hash
集合类型 set
有序集合类型 zset/sorted_set
5.支持持久化，可以进行数据灾难恢复
redis的应用场景
1.为热点数据加速查询（主要场景）。如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。
2.即时信息查询。如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。
3.时效性信息控制。如验证码控制、投票控制等。
4.分布式数据共享。如分布式集群架构中的 session 分离。
5.消息队列
3.Redis下载 下载安装包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8a942bf56a0227b4458e432321c8a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d00588712541e4e5ac26dcabf13b8f/" rel="bookmark">
			Android Studio基础工作流程-xml布局文件如何调用显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说起安卓开发，很多小伙伴在刚开始入门的时候会有些云里雾里，觉得很混乱，这很正常，大多数是因为不太清楚安卓开发的基本流程，以及各个文件之间是怎样去相互作用的。我会在这篇文章里面向你介绍一下Android studio工作的基本流程，很基础很基础的那种。
1.两个重要的文件 一个完整的安卓开发工程，里面的文件有很多很多很多，但是为了说清楚基本的工作流程，我们先关注两个重要的文件。比如，当我们先创建一个empyt的工程，android会自动给我们生成已下的一些文件。
记住，左上角要选择android，才会出现以下的目录结构
而我们需要关注的，一个是layout文件下的.xml文件
打开之后，可以看到这样的画面
xml文件及其作用 调整成split视图，我们不难看出，我们可以在这个xml文件里面来实现界面的布局。仔细观察，我们可以看到：
&lt;TextView android:id="@+id/tv1" android:layout_width="match_parent" android:layout_height="40dp" android:background="#225252" android:textColor="#00ff00" android:layout_gravity="center" android:gravity="center" /&gt; &lt;Button android:id="@+id/main_bt01" android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="next" android:layout_gravity="center" android:textSize="16dp" android:background="#300000ff" /&gt; 类似于这种的代码，这个就代表了一个一个的组件。而这些组件具体的功能以及一些特性，我会在后面的博客中去介绍，这一次我们先关注如何跑起来一个安卓程序，并且从一个基础的角度去了解他的工作流程。
上面我们提到了组件，而组件是什么东西呢？我们打开一个应用程序：
比如这个计算器，我们可以看到计算器上面有很多按钮，还有输入框等等东西，这些东西我们叫他组件。比如按钮组件，输入框组件等等，我们稍作了解。
所以，这里的xml文件是用来实现界面的布局。你想让你的界面呈现成什么样的效果，可以在xml文件里面设置。如果你学过前端，可以发现xml文件类似于前端里面的html和css。
MainActivity文件 说完了xml布局文件，现在有一个很重要的问题。我们已经将我们的页面布局设置好了，并且也写成了xml文件，那么，我们的布局文件在哪里才能够调用显示出来呢？答案就在我们的MainActivity文件里面。文件目录如下：
打开之后我们可以看到：（不同版本的Android Studio可能会有一些小小小小小的差异）
下面我就对这段代码进行一个简单的介绍
package com.example.test01; import android.annotation.SuppressLint; import android.os.Bundle; import android.widget.Button; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity {//继承AppCompatActivity来调用安卓程序 @SuppressLint("MissingInflatedId") @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);//这里输入刚刚xml文件的路径。直接写R.layout.xxx } } 可以看出来，我们是在
setContentView(R.layout.activity_main);//这里输入刚刚xml文件的路径。直接写R.layout.xxx
这行代码里面去调用我们刚刚创建的xml布局文件。代码其余的部分我们后面再详细介绍。通过这篇文章，我们可以了解到xml布局文件以及如何调用布局文件。那这里呢，我提供一个小小的代码，大家可以小试牛刀一下。
xml布局文件：
&lt;?xml version="1.0" encoding="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d00588712541e4e5ac26dcabf13b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dfe1ff193a2056bf43e165a351fb9eb/" rel="bookmark">
			子切片的长度和容量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 子切片的长度和容量 在Go语言中，切片有两个属性，长度和容量。
长度：切片中元素的个数。容量：从切片的第一个元素开始到底层数组元素末尾的个数。 下面我们来看一份范例：
func main() { a := [4]int{0, 1, 2, 3}	// len: 4, cap: 4 s := a[1:2]	// len: 1, cap: 3 s[0] = 11 s = append(s, 12) s = append(s, 13) s[0] = 21 fmt.Println(a)	// 输出：[0 21 12 13] fmt.Println(s)	// 输出：[21 12 13] } 当创建一个切片a[1:2]，它的长度是1，因为它只有一个元素，即a[1]；容量是3，因为从a[1]开始到底层数组的末尾有三个元素。append 函数可以将元素添加到切片，如果容量允许，它会在原始数组上进行修改。如果容量不足，则会创建一个新的数组，并复制现有元素到新数组，然后在新数组上追加。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025391df3894a1c716780e73f8450ba1/" rel="bookmark">
			麒麟9000s处理器，类似A13和骁龙8gen1的水平
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户们普遍对麒麟9000s处理器与A系列芯片的对比感到好奇，想要知道它等同于A系列中的哪一款芯片。根据实际性能表现，麒麟9000s处理器的性能大致在骁龙8gen1和苹果A13之间，但究竟等于A系列中的哪一款芯片呢?
首先，麒麟9000s可以被视为类似于苹果的A13芯片。这意味着它在性能方面表现出色，但并未采用A系列的命名方式。
从性能角度来看，麒麟9000s的表现类似于骁龙8gen1，这表明它在多任务处理、高性能应用和图形性能等方面都表现良好。然而，与上一代麒麟9000相比，性能改进并不显著。
尽管麒麟9000s的具体信息尚未完全披露，但我们了解到它采用了12核的CPU架构，包括6个A78AE核心、4个A510核心和2个A34核心。值得一提的是，麒麟9000s使用了一款定制版本的A78AE核心，其最高频率可达2.62 GHz，这在CPU性能方面提供了一定的优势。
另外，麒麟9000s在温度控制方面表现良好，这表明采用了一些独特的技术来保持芯片的稳定运行温度。
总的来说，麒麟9000s处理器在性能和技术方面有着引人注目的特点，虽然具体性能还需要等待正式发布会的测试，但对于寻求高性能智能设备的用户来说，它是一个值得期待的选择。
本文来源于：麒麟9000s处理器性能综述：与A系列相似，类似A13和骁龙8gen1的水平-下载集 (xzji.com)https://www.xzji.com/news/13678.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc5d40d4f68135d2f957f7156354eac/" rel="bookmark">
			Kotlin 如何确定协程是否启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Kotlin中，你可以确定协程是否已启动并正在运行，可以使用Job接口来管理协程，并使用一些函数来检查协程的状态。以下是一些常见的方法：
1.launch 函数返回一个 Job 对象，可以使用这个对象来确定协程的状态。例如：
import kotlinx.coroutines.* fun main() = runBlocking { val job = launch { // 协程的逻辑 } if (job.isActive) { println("协程已经启动并正在运行") } job.join() // 挂起等待协程完成 } 在上面的示例中，isActive 函数用于检查协程是否处于活动状态，也就是是否已启动但尚未完成。在这之后，你可以使用 join 函数等待协程完成。
你还可以使用 Job 对象的 cancel 方法来取消协程，如果协程已经启动，但你想中止它的执行。例如：
val job = launch { // 协程的逻辑 } // 取消协程 job.cancel() 请注意，取消协程是一种控制协程生命周期的方式，但要小心处理取消，以确保资源得到释放。
这些是确定协程是否已启动的一些常见方法，你可以根据自己的需求使用不同的方式来管理和监控协程的状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7116779136ceda7d8a0fdb71ca20ae53/" rel="bookmark">
			Ubuntu20.04安装&#43;ORB_SLAM3环境配置运行【包含所有安装包】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、Ubuntu 安装： 参考博客：ubuntu安装
参考博客：orb-slam3顺风版
1. ubuntu20.04镜像地址：https://pan.baidu.com/s/1hEx-rASvDbgLRwOJsYZVUQ?pwd=9791 提取码: 9791
2. 启动盘烧制工具下载： https://pan.baidu.com/s/1Du7MHGchRqWc-J6R-ElpvQ?pwd=1234 提取码: 1234
二、ORB-SLAM3安装： 2.1环境库安装 2.1.1安装git、g++ sudo apt-get install git sudo apt install g++ 2.1.2安装cmake cmake安装包： https://pan.baidu.com/s/1zO8AadBNc-IKTX3gpYaJ9A?pwd=1234 提取码: 1234
1.将压缩包解压到主目录，并将该解压后的文件移动到/opt目录下，执行以下命令：
mv cmake-3.23.2-linux-x86_64 /opt/cmake-3.23.2 移动成功后/opt/cmake-3.23.2目录下应该有以下文件：
2.建立连接：
ln -sf /opt/cmake-3.23.2/bin/* /usr/bin 3.查看cmake版本
cmake --version 执行后显示：
--------------------------------------------------------------------------cmake安装结束------------------------------------------------------------------------------------------
2.1.3安装eigen3 eigen3安装包：https://pan.baidu.com/s/1fk_OLOF4Iq3PQYpAHMcO7w?pwd=1234 提取码: 1234
1.将安装包解压到主目录下，进入该目录下并执行：
cd eigen-3.3.7 mkdir build cd build cmake .. sudo make install 最后查看eigen3版本：
pkg-config --modversion eigen3 eigen版本显示为3.3.7：
-------------------------------------------------------------------------eigen3安装结束------------------------------------------------------------------------------------------
2.1.4安装opencv 提示：opencv最好安装稳定版本，我的是3.4.10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7116779136ceda7d8a0fdb71ca20ae53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e219bfc4d0d95da5814a5bd800b04c/" rel="bookmark">
			python—openpyxl操作excel详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 openpyxl属于第三方模块，在python中用来处理excel文件。
可以对excel进行的操作有：读写、修改、调整样式及插入图片等。
但只能用来处理【 .xlsx】 后缀的excel文件。
使用前需要先安装，安装方法：
pip install openpyxl 注：一个excel文件可看做是一个工作簿，工作簿中的一个Sheet就是一个工作表。
详细使用方法 1、创建一个excel工作簿对象 进行读写、修改等操作前，需要创建一个可供操作的excel工作簿对象。
分以下2种情况和方法：
第一种：新建一个excel工作簿对象
情况1：写入数据，本地没有现成可直接写入的excel工作簿时。
使用Workbook类，新建一个excel工作簿对象，用来后续进行读写等处理。​​​​​​​​​​​​​​
from openpyxl import Workbook # 新建一个excel工作簿对象 wb = Workbook() # 保存新建的excel工作簿 wb.save('excel_test.xlsx') 注：（1）该类在新建excel工作簿的同时，也会新建了一个工作表（默认名为：Sheet）。
（2）.save（保存路径）方法，对excel进行保存，写入或修改excel后，都需要保存。
（3）如果当前保存路径下，已经有一个同名excel文件，不会提示且原文件被覆盖。
上述代码，.save（）保存，运行后，如下图：
第二种：读取已有excel
情况2：读取本地已存在的excel，用来后续进行读写等处理。
方法：load_workbook(已有excel文件路径)，如果路径中excel文件不存在，将会报错。​​​​​​​
from openpyxl import load_workbook # 读取已存在的excel工作薄 wb = load_workbook('excel_test.xlsx') ​​​​​​​​​​​​​​2、创建excel工作簿中的工作表 openpyxl提供了可自定义工作表的方法。
工作表，即是常见说法的【Sheet】。
创建自定义名称的工作表，语法如下：
Workbook.create_sheet(title,index) title：工作表的名称，可省略，系统自动命名（Sheet, Sheet1, Sheet2, ...）。 index：工作表的位置，可省略，默认插在工作表末尾，0表示插在第一个。​​​​​​ # 自定义工作表 ws1 = wb.create_sheet('test') ws2 = wb.create_sheet() # 保存 wb.save('excel_test.xlsx') 3、查看excel工作簿中的所有工作表 查看excel工作簿中已存在的所有工作表，有以下3种方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80e219bfc4d0d95da5814a5bd800b04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a9f8adb6572de419af97f3687d151a/" rel="bookmark">
			记录一下浏览器缓存&amp;前端缓存&amp;http缓存方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HTTP缓存简介
浏览器缓存是指在本地缓存，HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。
HTTP缓存可以缩短网页请求资源的距离，减少延迟，节省网络流量，并且由于缓存文件可以重复利用，降低网络负荷，提高客户端响应。
完整流程图如下：
二、强缓存和协商缓存
根据是否需要重新向服务器发起请求，可分为强缓存和协商缓存
2.1 强缓存
定义：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。
强制缓存，在响应头由 Expires、Cache-Control 和 Pragma控制，
优先级Expires &lt; Cache-Control &lt; Pragma
Expires：值为服务器返回的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。（HTTP1.0的属性，缺点是客户端和服务器时间不一致会导致命中误差）
Cache-Control：HTTP1.1属性，优先级更高，以下为常用属性
no-store： 禁用缓存
no-cache：不使用强缓存，每次需向服务器验证缓存是否失效
private/public：private指的单个用户，public可以被任何中间人、CDN等缓存
max-age=：max-age是距离请求发起的时间的秒数
must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
Pragma
no-cache：效果和cache-control等no-cache一致。
强缓存的资源存储位置
Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面(from memory cache和from disk cache区别)
2.2 协商缓存
定义：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源
协商缓存，响应头中有两个字段标记规则
Last-Modified / If-Modified-Since
Last-Modified是浏览器第一个请求资源，服务器响应头字段，是资源文件最后一次更改时间(精确到秒)。
下一次发送请求时，请求头里的If-Modified-Since就是之前的Last-Modified
服务器更加最后修改时间判断命中，如果命中，http为304且不返回资源、不返回last-modify
Etag / If-None-Match：Etag 的校验优先级高于 Last-Modified
Etag是加载资源时，服务器返回的响应头字段，是对资源的唯一标记，值是hash码。
浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头里的If-None-Match里
服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。
在精确度上，Etag要优于Last-Modified，Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 在优先级上，服务器校验优先考虑Etag。
四、常见操作
4.1 设置不缓存的方法
1.html文件设置meta；
&lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="Cache-Control" content="no-cache, must-revalidate"&gt; &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59a9f8adb6572de419af97f3687d151a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ef2e6a4d19fac626b762e8a7bb4a0d/" rel="bookmark">
			SSM常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM面试题个人笔记 SpringMVC什么是Spring MVC？简单介绍下你对Spring MVC的理解？SpringMVC的请求流程SpringMVC中常用注解SpringMVC参数传递 Spring1.谈谈你对spring的理解Spring的优点Spring的核心模块IOC的理解AOP的理解BeanFactory和ApplicationContext有什么区别？Spring Bean的生命周期Spring支持的几种bean的作用域Spring框架中的单例Beans是线程安全的吗？Spring基于xml注入bean的几种方式Spring的自动装配Spring 框架中都用到了哪些设计模式？Spring事务的实现方式和实现原理Spring中的隔离级别：Spring框架中有哪些不同类型的事件？Spring AOP里面的几个名词Spring通知有哪些类型？ Mybatis使用Mybatis的mapper接口调用时有哪些要求？#{}和${}的区别 SpringMVC 什么是Spring MVC？简单介绍下你对Spring MVC的理解？ SpringMVC是一个基于Java实现了MVC设计模式的请求驱动类型的web框架，通过把模型-视图-控制器分离，将web层进行指责解耦，把复杂的web应用分成逻辑清晰的几个部分，简化开发减少出错，也方便协作开发。
SpringMVC的请求流程 用户发送请求至前端控制器dispatcherServlet，前端控制器接收到请求后，调用处理器映射器handleMapping，请求获取Handle；处理器映射器HandleMapping根据请求的URL生成处理器对象及处理器拦截器一并返回给前端控制器；前端控制器调用处理器适配器HandleAdapter，根据处理器映射器返回的结果找到后端控制器；后端控制器处理相关的业务逻辑，将处理后的结果ModelAndView返回；处理器适配器将后端控制器的ModelAndView结果返回给前端控制器；前端控制器将ModelAndView传递给视图解析器ViewResolver解析视图，返回视图对象；前端控制器进行视图渲染；前端控制器响应用户。
SpringMVC中常用注解 @PostMapping（“/user”）等价于@RequestMapping（value=“/user”，method = RequestMethod.Post）
@GetMapping（“/user”）
@ControllerAdvise拦截Controller
@ExceptionHandle（Exception.class）异常拦截
@ResponseBody返回实体对象
@CrossOrigin允许跨域访问
SpringMVC参数传递 /user/{page}/{size}用@PathVariable接收
/user?id=1用@RequestParam接收
/user的form表单接收一个实体{key:value…}形式的，用RequestBody接收
上传文件，用@RequestParam接收
Spring 1.谈谈你对spring的理解 spring是一个轻量级的开源框架，它的根本使命是用来简化java开发。所谓的轻量级是相对重量级而言的，轻量级一般就是非入侵的、所依赖的东西非常少、资源的占用也非常少，并且它部署简单，易使用。spring的理念是IOC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming，面向切面编程）。
其中，IOC控制反转就是把对象的创建反转给Spring框架来创建和管理，其过程是程序运行时，通过new一个ClassPathXmlApplicationContext工厂读取配置文件（老版本是通过new一个XmlBeanFactory来读取配置文件），spring进行一系列文件解析，根据Bean注册表通过反射机制实例化对象，然后将对象保存到一个Map的spring容器中。当程序中需要创建对象时，从容器中拿到对象，注入到所需的位置。IOC是Spring的核心，主要目的是为了削减程序之间的耦合度。
AOP面向切面编程，和传统的OOP（Object Oriented Programming，面向对象编程不同），OOP的思想结构为纵向结构，而AOP为横向结构。AOP一般用来日志记录、事务处理、异常处理、权限控制等。例如：在做日志处理时，假如没有AOP，我们需要在每个方法中添加日志处理，但大多数的日志处理代码是相同的，为了重复代码的使用率，我们可以把日志处理抽离成一个方法，但还是要在方法内引用日志处理的方法。这样就会增加代码的耦合，假若要修改或者弃用这个方法，就要去原先调用的方法中一个一个修改，不利于维护。通过动态代理的技术，在指定的位置执行相应的流程，这样就可以将一些横向的功能抽离出来，形成一个独立的模块，然后在指定位置插入这些功能，也就是找到切入点，并加入通知。
Spring的优点 （1）spring属于低侵入式设计，代码的污染极低；
（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；
（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。
（4）spring对于主流的应用框架提供了集成支持。
Spring的核心模块 Spring Core：核心类库，提供IOC服务；
Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；
Spring AOP：AOP服务；
Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；
Spring ORM：对现有的ORM框架的支持；
Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；
Spring MVC：提供面向Web应用的Model-View-Controller实现。
IOC的理解 1）IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。
（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。
（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。
IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。
AOP的理解 OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ef2e6a4d19fac626b762e8a7bb4a0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c249243e64727c823748a4b4536a56f8/" rel="bookmark">
			笔记 | MySQL 运维常用语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导出整个库 mysqldump -u 用户名 -p –default-character-set=latin1 数据库名 &gt; 导出的文件名(数据库默认编码是latin1) mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql 2.导出一个表 mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql 3.导出一个数据库结构 mysqldump -u wcnc -p -d –add-drop-table smgp_apps_wcnc &gt;d:wcnc_db.sql 参数说明：-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table
4.导入数据库 第1种：常用，source 命令 进入mysql数据库控制台，
如mysql -u root -p
mysql&gt;use 数据库
然后使用source命令，后面参数为脚本文件(如这里用到的.sql)
mysql&gt;source wcnc_db.sql
第2种：使用mysqldump命令 mysqldump -u username -p dbname &lt; filename.sql
第3种：使用mysql命令 mysql -u username -p -D dbname &lt; filename.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c249243e64727c823748a4b4536a56f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc20498c14289b9f6f53312fcc833fc/" rel="bookmark">
			C#编程学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#简介：
- C#是一种现代的、面向对象的编程语言，由Microsoft开发。
- 它是.NET框架的一部分，用于开发Windows应用程序、Web应用程序和服务等。
开发环境：
- 你可以使用Visual Studio或Visual Studio Code等集成开发环境（IDE）来编写、调试和运行C#代码。
- C#可以在Windows平台上进行开发，也可以通过.NET Core/.NET 5+在跨平台上进行开发。
基本语法：
- C#是一种强类型语言，需要声明变量的数据类型。
- 语句以分号结尾，代码块用大括号括起来。
- 主要的数据类型包括整数、浮点数、字符串、布尔值等。
控制流：
- 使用条件语句（如if、else、switch）来进行逻辑控制。
- 循环结构（如for、while）用于重复执行代码块。
面向对象编程：
- C#是一种面向对象的语言，支持类、对象、继承和多态。
- 类是用来封装数据和行为的模板，对象是类的实例。
方法和函数：
- 方法是用于执行特定任务的代码块。
- C#提供了许多内置的方法，你也可以创建自己的方法。
数组和集合：
- 数组用于存储多个相同类型的数据项。
- 集合类提供了更强大的数据结构，如List、Dictionary、HashSet等。
异常处理：
- 使用try-catch块来处理异常，以确保程序在出现错误时能够优雅地处理异常情况。
文件操作：
- C#提供了许多用于读取和写入文件的类，如FileStream、StreamReader、StreamWriter等。
多线程编程：
- 通过使用多线程，你可以实现并发执行，提高程序性能。
- C#提供了Thread和Task等类来管理多线程操作。
LINQ：
- Language-Integrated Query（LINQ）允许你使用类似SQL的查询语法来操作集合和数据。
ASP.NET和WinForms：
- 了解ASP.NET和WinForms，这些是用于开发Web应用和桌面应用的C#框架。
调试和测试：
- 学习如何使用调试工具来诊断和修复代码中的错误。
- 编写单元测试来确保代码的质量。
学习资源：
- 利用在线教程、书籍、视频课程和C#社区来不断提高你的编程技能。
实际项目：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc20498c14289b9f6f53312fcc833fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8162acafb431b172638ecaf51cfa94c/" rel="bookmark">
			《MySQL DBA：学习导图》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《MySQL DBA：学习导图》 收费博客禁止转载、贩卖收益！ 定期排查，发现一律举报封号！更新中 ... 《MySQL DBA： MySQL数据库前景介绍》https://blog.csdn.net/yexiangCSDN/article/details/106118466
《MySQL DBA： MySQL官网介绍与下载》https://blog.csdn.net/yexiangCSDN/article/details/106119507
《MySQL DBA： MySQL 5.6,5.7安装》https://blog.csdn.net/yexiangCSDN/article/details/106122214
《MySQL DBA： my.cnf 配置》https://blog.csdn.net/yexiangCSDN/article/details/106142082
《MySQL DBA： 升级/参数/连接/权限》https://blog.csdn.net/yexiangCSDN/article/details/106147187
《MySQL DBA： 权限拾遗与角色模拟》https://blog.csdn.net/yexiangCSDN/article/details/106147418
《MySQL DBA： 体系、Workbench、Utilities介绍》https://blog.csdn.net/yexiangCSDN/article/details/106230567
《MySQL DBA： 存储引擎特性》https://blog.csdn.net/yexiangCSDN/article/details/106147633
《MySQL DBA： 慢查询日志进阶》https://blog.csdn.net/yexiangCSDN/article/details/106147609
《MySQL DBA： 官网测试数据库安装》https://blog.csdn.net/yexiangCSDN/article/details/106257185
《MySQL DBA： 多实例安装》https://blog.csdn.net/yexiangCSDN/article/details/106147640
《MySQL DBA： SSL连接》https://blog.csdn.net/yexiangCSDN/article/details/106147646
《MySQL DBA： 数据类型进阶》https://blog.csdn.net/yexiangCSDN/article/details/106147672
《MySQL DBA： MySQL 5.7 JSON数据类型》https://blog.csdn.net/yexiangCSDN/article/details/106147734
《MySQL DBA： 表进阶》https://blog.csdn.net/yexiangCSDN/article/details/106288772
《MySQL DBA： CURD进阶》https://blog.csdn.net/yexiangCSDN/article/details/106288840
《MySQL DBA： Rank/视图/UNION》https://blog.csdn.net/yexiangCSDN/article/details/106288871
《MySQL DBA： 触发器》https://blog.csdn.net/yexiangCSDN/article/details/106288916
《MySQL DBA： 存储过程/自定义函数进阶》https://blog.csdn.net/yexiangCSDN/article/details/106288952
《MySQL DBA： 索引进阶》https://blog.csdn.net/yexiangCSDN/article/details/106147861
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8162acafb431b172638ecaf51cfa94c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/40/">«</a>
	<span class="pagination__item pagination__item--current">41/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/42/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>