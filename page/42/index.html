<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ba8533720c62f7adfc69ef818b6f91/" rel="bookmark">
			STM32内存分配以及堆栈、变量、代码等的存储位置理解与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文中不足之处，欢迎各位同仁批评指正！
前言 STM32的程序存储器、数据存储器、寄存器和输入输出端口被组织在同一个4GB的线性地址空间内, 地址范围为0x0000 0000至0xFFFF FFFF。其中FLASH为ROM类型，储存的数据掉电不易失；RAM中存储的数据掉电易失。以STM32F103系列为例，最多有512KB的FLASH空间以及最多64KB的RAM空间，另外还包含一个512字节的用于标准USB和CAN通信的SRAM。如下图所示：
一、FLASH分段 FLASH主要是存放代码和只读数据的，细分图如下：
如上图所示，Flash又可以细分为文本段、只读数据段、数据复制段。其中文本段包含代码和代码中的常量部分，只读数据区通常存放程序中以const关键字修饰的数据，数据复制段存放的则是程序中初始化不为0的全局变量的数据，在每次单片机复位后要对这些变量重新赋值。
二、RAM分段 RAM主要用来存储数据，如下是STM32的RAM分区：
data段：存放初始化非0的全局变量；
bss段：存放未初始化或初始化为0的全局变量；
Heap（堆）段：由程序员通过malloc/free申请和释放；
Stack（栈）段：存放局部变量和函数的入口地址；
其中栈的方向是由栈顶自上而下的，堆的方向则是自下而上的，如果RAM空间有限而且一个程序中局部变量较多或申请的堆空间过大，便会造成堆和栈冲突，并造成系统崩溃（自己暂时写的程序较小，暂时没有遇到过类似问题）。
栈，也叫堆栈，是一种先进后出，插入和删除操作都在栈顶操作的线性表。栈的作用通常是保存函数返回地址及保存局部变量。每个函数在运行时都有自己的栈空间，局部变量越多，占空间占用越大，函数间调用越深，栈空间也越大。CPU将打断前的程序运行到的地址、寄存器的值保存到栈中，即保护现场；当打断执行完以后，又从栈中读取之前保存的值，即恢复现场。
如下是STM32启动文件（.s）中对栈和堆的定义，其中栈大小为0x400即1KB，堆大小为0x200即512Byte。
; &lt;h&gt; Stack Configuration ; &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ; &lt;/h&gt; Stack_Size	EQU 0x400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp ; &lt;h&gt; Heap Configuration ; &lt;o&gt; Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt; ; &lt;/h&gt; Heap_Size EQU 0x200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit 三、kei中的map文件 如图在keil中编写如下程序代码，验证各变量的存储位置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10ba8533720c62f7adfc69ef818b6f91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc10de50841e40d7e91504ea1b66e5ca/" rel="bookmark">
			K8S实战笔记--7（容器损坏 &#43; 负载均衡原理简述 &#43; 线上Linux服务器优化经验）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习K8S时，系统管理人员需要了解有哪些Disruption（损坏）可能发生在Pod上。
1. 容器损坏 1.1 非自愿的损坏 包括：节点资源耗尽、管理员操作失误、集群硬件损坏等等。为了弥补此类损失，我们应当确保Pod申请合适的计算资源并为程序准备足够的副本数目，若想保证更高的高可用，需要将副本分布在多个机架上。
1.2 自愿的损坏 集群中自愿的Pod损坏不同于我们常规意义上的“损坏”，它指的是由集群管理员或应用管理员主动执行的导致Pod删除、停止或重启的操作。这些操作包括：删除Pod的控制器、修改Pod定义致其重启、删除Pod（以便重新调度或单纯的删除）、排空节点（以便升级维护或集群收缩），这些操作可能是管理员执行的，也可能是由设定的脚本执行的。自愿发生的损坏频率不定，所以K8S提供了Disruption Budget用于在有可能高频次地发生自愿毁坏的情况下，仍能运行高可用的应用程序。
1.3 Disruption Budget 管理员可以为每个应用创建一个PodDisruptionBudget对象，此对象限制了在应用程序发生自愿的损坏时，有多少个副本可以被同时停止。例如：一个前端应用程序应当保证在可用的副本数目不能低于总副本数目的一定比例，若某应用程序有5个副本，而该应用的PodDisruption对象规定了最小副本数目为4（副本期望值），则此时系统只会允许1个而不是更多的副本进行自愿损毁。鉴于此保护特性，管理员在集群维护时，应当使用兼容PodDisruptionBudget的工具，避免Pod或Deployment被直接删除。兼容PodDisruptionBudget的工具例如kubectl drain，该工具会尝试将节点上的所有Pod全部驱逐，在驱逐指令遭到拒绝时，将会周期性地请求直到该节点上的所有Pod都被终止或超出了设定的超时时间。
那么PodDisruptionBudget如何完成此操作呢？PDB通过Pod的.metadata.ownerReferences查找到其对应的控制器；通过 控制器的.spec.replicas字段来确定期望的副本数；通过控制器的abel selector来确定哪些Pod属于同一个应用程序。但是PDB并不能阻止非自愿毁坏的发生，当这类毁坏发生时，会被计入当前毁坏数里，通过kubectl drain驱逐Pod时，Pod将被gracefull terminate。举个例子：假设某集群中共有三个节点，每个节点的资源可容纳两个Pod。node01上拥有Podpod-a与pod-x，node02上拥有pod-b，node03上拥有pod-c。其中，pod-a、pod-b与pod-c同属一个应用程序，且具有对应的PDB对象，限制了其最少Pod数目为2，pod-x为独立于此应用程序的Pod，没有PDB与之对应。在管理员想要进行集群维护升级时，需要排空节点中的Pod以便更新机器。首先排空node01，在使用kubectl drain进行节点的排空时，该节点上的Pod会被驱逐，pod-a与pod-x都进入了terminating状态。管理pod-a与pod-x的控制器检测到Pod正在停止，立刻做出决策分别创建新的Podpod-a1与pod-x1，由于当前节点资源已不可用，需要将Pod调度到集群中的其它节点，于是pod-a1被调度到了node02，pod-x1被调度到了node03。此时，考虑到节点资源限制，集群中剩余两台节点已无法支持调度更多的Pod。此时，若管理员继续选择排空node02，kubectl drain按照顺序依次驱逐pod-b与pod-a1。在驱逐pod-b时，操作将被接受，在驱逐pod-a1时，操作将被拒绝，因为该应用程序的PDB规定了同一时刻至少要有两个Pod可用，否则其可用Pod将只剩一个。在进行pod-b的驱逐操作中，控制器创建一个pod-b1来代替pod-b，但由于集群已无剩余可用资源，没有办法进行pod-b1的调度，所以此时的kubectl drain将再次被拒绝。如此，集群的维护操作将无法继续，除非管理员将更多的节点添加入集群。在此时，我们将不得不接受更新所导致的停机，或故障转移至另外的集群副本，但这样带来的代价将是极大的，所以我们最好编写容错的应用程序并使用PDB。
在我们无法防止应用被自愿损坏时，我们应当思考如何应对应对此类损坏。对于常见的应用，可以分为：
无状态的前端：最低可用不得低于90%；单实例有状态的应用：未经允许不得随意关闭应用程序，可以不使用PDB并容忍偶尔的停机；或使用PDB设置最大不可用为0，与集群管理员达成一致，做好应对后续处理的准备；多实例有状态的应用：不能将实例数降低至某个值，否则会写入失败，可以将最大不可用设为1，或设置最小可用数目为最低数目可以重新开始的批处理任务：在发生自愿损坏时，Job仍需要完成其任务，此时不需要设置PDB，Job会新建一个Pod用于替换已损坏的Pod。 在指定可用或不可用比例时，我们有时很难判断在计算结果不是整数时究竟应当如何取值，此时系统将选择向上取整。
2. 集群的LVS负载均衡 系统扩展方式 向上扩展 升级机器向外扩展 增加机器 集群类型 LB 负载均衡HA 高可用HPC 高性能 均衡负载的实现 硬件 购买机器软件 LVS Nginx等 会话保持的负载均衡 session stickycookie绑定session replicationsession复制session serversession服务器 keepalived + LVS用于避免会话调度器单点失败LVS由章文嵩博士开发 后来被Linux服务器集成至内核中 工作原理为 VS根据请求报文的目标IP和目标协议及端口将其调度转发至某RS 根据调度算法来选择RS VS 即virtual server 用于调度RS 即Real server 用于真正提供服务L4 四层路由器或交换机CIP 客户端IPVIP VS的外网IPDIP VS的内网IPRIP RS的IP访问流程 CIP &lt;–&gt; VIP == DIP &lt;–&gt; RIP LVS集群的类型 lvs-nat 修改请求报文的目标IP 多目标IP的DNAT(变目标IP)lvs-dr LVS默认模式 操纵封装新的MAC地址(变MAC)lvs-tun 在原请求IP报文之外新加一个IP首部lvs-fullnat 修改请求报文的原和目标IP LVS工作模式 VS/NAT 服务器类型 任意类型网络模式 私网地址服务器数量 10-20服务器网关 load balancer VS/TUN 服务器类型 支持Tunneling网络模式 LAN/WAN服务器数量 100服务器网关 自己的路由器 VS/DR 服务器类型 无ARP设备网络模式 LAN服务器数量 100服务器网关 自己的路由器 静态调度算法 RR 轮询WRR 加权调度SH 原哈希 用于实现session绑定 将来自于同一个IP的请求始终法网第一次挑中的RSDH 目标地址哈希 正向代理 将发往同一个目标地址的请求始终发往第一次挑中的RS　如宽带运营商 动态调度算法 考虑后端负载情况 overhead负载 activeconns活动连接数 inactiveconns非活动连接数 LC least connections 适用于长连接 ovh = act * 256 + ina 值越小 调度越多WLC 加权的LC 根据性能为机器设置好权重 ovh(LC)/weight 值越小 调度越多SED shortest expection delay 初始权重高者优先 用于解决加权LC集群使用初期act为0的情况 ovh = (act + 1) * 256 / weightNQ never queue 第一轮均匀分配 后续使用SEDLBLC locality-based LC 动态D 适用于根据负载状态实现正向代理LBLCR　LBLC with replication 带复制的LBLC 用于解决LBLC负载不均衡问题　从负载重的复制到负载轻的RS 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc10de50841e40d7e91504ea1b66e5ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f147a4b324184931d82f891a704d3c/" rel="bookmark">
			Pytest（一）：pytest的使用简介、jenkins&#43;allure报告生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0、最新总结：
Jenkins的安装：
Jenkins在windows环境下的下载与安装_冷凝娇的博客-CSDN博客
一、pytest的安装及简介
二、pytest使用规则
三、pytest初始化
3.0.fixture(最推荐conftest+fixture)
3.1 模块级
3.2 类级别
3.3 方法级别
3.4 目录级别
四、 断言assert（与unitest的断言有差异）
五、pytest的执行
六、报告展示
0、最新总结： pytest-html#生成html报告 pytest-xdist # 测试用例的分布式执行。多线程 pytest-ordering # 改变用例执行顺序 pytest-rerunfailures #重新执行 allure-pytest # 生成较为美观的测试报告 pytest-repeat # 指定重复用例执行次数 --pytest文件命名的基本规则： 1.模块名必须以test_开头or_test结尾 2.测试类必须以Test开头，而且，类不允许含有__init__方法 3.测试方法默认以test开头 --目标：使用pytest执行基本的单元测试 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 0.首先了解pytest运行都有哪些常用的入参，各自是什么意思，如何使用？ -s:输出调试信息，其中包含在代码中print的内容 -v:显示更为详细的信息（相对与-s而已，-vs更详细），备注：-vs这两个参数一起使用 -n:支持多线程、更或者分布式运行测试用例 --reruns {num}:失败用例重新执行测试设置 -m:指定装饰器装饰的case的运行用例(注意：1.装饰器装饰case,@pytest.mark.o; 2.pytest.ini中配置 markers = o: TTT smoke: just a smoke test login: login api 3.执行时，加上参数 -m 模块) -k:根据测试用例的部分字符串指定要执行测试用例，eg:pytest -vs ./testcase -n 2 -x -k 'test' --html path：生成html报告 -x:只要有一个case失败，所有case停止 --maxfail=2:出现2个用例失败就停止；即：--maxfail={num}设置用例最大失败次数 --alluredir path:临时json报告，再生成allure报告：os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f147a4b324184931d82f891a704d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f91082c9b36079079fa7928339d4726/" rel="bookmark">
			基于自动化工具autox.js的抢票（猫眼）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.看到朋友圈抢周杰伦、林俊杰演唱会票贼难信息，特研究了一段时间，用autox.js写了自动化抢票脚本，购票页面自动点击下单（仅限安卓手机）。
2.脚本运行图
3.前期准备工作
（1）autox.js社区官网：AutoX.js
（2）b站上学习资料：10分钟学会AutoX.js hello world_哔哩哔哩_bilibili
AutoX.js控件操作_哔哩哔哩_bilibili
4.源码
// 检查无障碍服务是否已经启用，如果没有启用则跳转到无障碍服务启用界面，并等待无障碍服务启动；当无障碍服务启动后脚本会继续运行。 auto.waitFor(); //打开猫眼app app.launchApp("猫眼"); openConsole(); console.setTitle("猫眼 go!","#ff11ee00",30); main(); //获取输入的场次信息 function getPlayEtc(){ var playEtc = rawInput("请输入场次关键字(按照默认格式)", "周六"); if (playEtc == null || playEtc.trim()=='') { alert("请输入场次信息!"); return getPlayEtc(); } console.log("手动输入的场次信息："+playEtc); return playEtc; } //获取输入票价信息 function getTicketPrice(){ var ticketPrice = rawInput("请输入票价关键字(按照默认格式)", "788"); if (ticketPrice == null || ticketPrice.trim()=='') { alert("请输入票价信息!"); return getTicketPrice(); } console.log("手动输入的票价信息："+ticketPrice); return ticketPrice; } //获取输入的抢票时间 function getSellTime(){ var sellTime = rawInput("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f91082c9b36079079fa7928339d4726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98a23727b7e359f9f0bd3d86cb34b23/" rel="bookmark">
			Python10.24
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# class Car: # def __init__(self, color): # self.color = color # # auto = True # brand = "" # size = "" # mod = "刹车" # # def __del__(self): # print("del") # # def set_color(self): # print(f"车的颜色为：{self.color}") # # # car_one = Car("红色") # car_one.set_color() # car_one.brand = "a123" # car_one.size = "s456" # car_one.auto = False # car_one.mod = "启动汽车" class Car: def __init__(self, brand, model, auto_drive=False): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98a23727b7e359f9f0bd3d86cb34b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df0d5647be5ff66486943b76eb5a66d/" rel="bookmark">
			Occupancy占据网络论文讲解与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MonoScene 1.概要 a.使用单目相机，不用深度估计和点云来实现占据网络。
b.提出了一种2D-3D的一种转换方法。
c.在3D-unet底部加入3DCRP来捕获长距离的一个信息。
2.模型结构 图像先经过一个2D的unet结构，这里论文里用的预训练的EfficientNet，然后经过一个论文里提出的FLOSP模块，从2D到3D，不过是一个多尺度的投影，再上采样concate。这里的转换模块个人感觉和FastBEV一样。后续3Dunet是一个简单的编解码网络，加入了空洞卷积和作者提出的一个3DCRP的结构。最后加入一个head完成多类别的一个语义分割 。
3.2D到3D转换(FLoSP) 说实话我感觉这个和FastBEV一样，这个多尺度的图片投影到不同的尺度的3D体素中，然后再聚合不同尺度的3D特征。 4.3D CRP 因为语义分割场景高度依赖于上下文的一个关系，所以论文里在3Dunet底部加入了一个CRP的结构，从而为网络提供了一个全局的感受野。这里因为全局语义分割存在极度的不均衡，所以单纯的二分类其实是次要的，论文里提出了体素与体素之间的一个关系，从而增强模型的上下文之间的关联。这里怎么划分体素之间的关系我有点看不懂原文的描述，原文这里很乱。
二、 VoxFormer 1.摘要 a.提出一种两阶段的框架，使用图像生成完整的3D体素化语义场景。
b.预测图像深度，再生成稀疏的体素，使用transformer进一步得到完整的体素语义场景 。
2.模型结构 先对图像的特征进行提取，同时对其深度也进行估计，根据相机内外参投影到体素里，得到一个稀疏的Q,这个Q与图像特征进行交叉注意力机制，加上mask token后再做一个自注意力的操作，相当于对语义场景进行补全，最后上采样做多类别语义分割。
3. 第一阶段的query 初始化定义的query是忽略类别的，h*w*z*d，这个尺度相较于最终的语义分割尺度进行了2倍降采样，主要是为了提高模型的一个鲁棒性，防止因为深度预测误差过大，像素点没有落到该有的体素内。
根据深度估计和相机内外参，我们可以得到许多3D空间的点云，但此时这个点云是非常不可靠的，特别是在远处，几个点云决定了一大片区域的深度。为了降低深度容错和提高模型的鲁棒性，使用了一个简化版的unet网络对Min(H*W*D)进行卷积占据预测，输出Mout(h*w*d)表示是否占据。
根据是否占据，我们在q里面选择占据的query出来，组成Qp。这里有个疑问Qp的个数会变化呀？不是固定数量的query也可以吗？这里的好处是跳过空白的区域，只对图像上看到的地方进行query。
4.第二阶段补全query后的语义分割 使用deformable交叉注意力机制，Qp有一个3D坐标，投到图像上有一个参考点，根据偏移和权重，在多个时序图上进行特征的提取。经过几层可变形交叉注意力之后，我们把Qp与mask token结合得到完整的体素特征。然后使用可变形自注意力机制，对完整的体素特征进行细化。然后再上采样到原始的分辨率，对其进行多类别语义分割。
这里的mask token是一个d维的可学习向量，主要用于填充第一阶段没有对应图像的一些体素，同时这些mask token也加入了位置编码，来让其对自己的位置有一定的了解。
三、TPVFormer 1.摘要 a.提出了一种新颖的三维空间表示方法，相较于体素，计算量大大下降，相较于BEV，其对空间的细粒度三维结构表示更加丰富。
b.使用可变形注意力机制生成空间三视图，可以完成任意分辨率的空间占据表示。
2.模型结构 图像先通过backbone和Neck提取相应的特征，然后TPV query向图像进行可变形注意力机制查询，再加上三个平面之间的特征交互，最终生成TPV的特征，我们根据这个图，可以插值得到最终3D空间的占据预测。这里的TPV query是最终三个视图里面的每个像素点，t∈T。
3.Image cross attention 在进入这个模块时，先对TPV query添加位置编码。 考虑到TPV query的个数以及图像像素的个数，所以我们不进行全局注意力机制，而使用可变形注意力机制。比如一个俯视图的TPV query，他有一个xy，那么我们对z进行间隔采样，会得到许多3D点，然后我们对这些3D点向一张图像做投影，可以得到一些有效投影点，对这些有效投影点做可变形注意力机制，最后对六张图像的可变形注意力机制结果求平均。
4.Cross-View Hybrid-Attention 因为上面每个视图单独查询图像特征，他们之间并没有充分的交互，所以提出交叉视图混合注意力机制，有利于上下文特征的提取。比如俯视图上一个点，我们直接在其周围生成一些参考点，然后沿着z生成几个3D点，投影到前视图和左视图，又能得到几个参考点，对这些参考点做可变形注意力机制，得到最终的特征。 四、SurroundOcc 1.摘要 a.使用由粗到细的思想策略，先生成小分辨率的体素特征，再逐步上采样，生成密集的体素特征。
b.针对占据网络稀疏的GT监督，论文提出了一种生成密集占据标签的方法。
2.模型结构 首先提取图像的多尺度特征信息，然后使用类似于bevformer的思想，使用可变形交叉注意力机制，完成2D到3D的特征转换，后续再加一些3D卷积。把低分辨率的3D体素特征逐层上采样合并，最后加head完成预测。我们对不同尺度的3D体素都施加监督，不过监督权重呈衰减形式，从上到下由大到小。
3.密集占据真值生成 多帧点云拼接，将点云分为动静态，静态根据车身位姿变化堆叠在一起，然后动态的根据track id合并填充进去。这样聚合完还是会存在一些空洞的区域，根据其邻域中的空间分布计算法向量，使用poisson曲面重建算法来进行补全。最后使用最近邻算法来对空白网格的语义进行填充。
五、OpenOcc 1.摘要 a.使用AAP(Augmenting And Purifying)方法对nuScenes数据生成密集的占用语义标签。
b.提出lidar和camera结合的占用网络，同时采用由粗到细的cascade策略提升性能。
2.模型结构 LiDAR分支先对点云进行体素化操作，然后使用3D稀疏卷积得到(D/S, H/S,W/S)特征 ，后续解码器将其降采样再上采样合并，最终softmax进行3D语义预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df0d5647be5ff66486943b76eb5a66d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffce48e256adf8efc90b17cbe8c366ed/" rel="bookmark">
			windows中Oracle： ORA-01031 insufficient privileges主机验证失败 主机sqlplus / as sysdba需要用户名密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作oracle需要管理员sys权限进行配置，但是主机上输入sqlplus / as sysdba还是要密码，不能直接连接 1，第一种情况 家庭版的Windows系统的解决办法：
第一步：在开始菜单拦找到Oracle-×××，在里面选择
Administration Assistant for Windows
第二步：进入了orammcadm11ZHS-[Administration Assistant for Windows]
第二种情况 找到oracle的安装目录
一、检查sqlnet.ora（WINDOWS下位于%ORACLE_HOME%NETWORK/ADMIN目录）是否包含这句：SQLNET.AUTHENTICATION_SERVICES=(NTS)经检查，该配置文件没问题
如：
E:\app\Administrator\product\11.2.0\dbhome_1\NETWORK\ADMIN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52199c25e887428202869800a6807b1d/" rel="bookmark">
			【运筹优化】最短路算法之Floyd算法 &#43; Java代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Floyd算法简介二、Floyd算法思想2.1 路径矩阵2.2 状态转移方程 三、Floyd算法 java代码四、测试五、优缺点分析 一、Floyd算法简介 Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。
在计算机科学中，Floyd-Warshall算法是一种在具有正或负边缘权重（但没有负周期）的加权图中找到最短路径的算法。算法的单个执行将找到所有顶点对之间的最短路径的长度（加权）。
二、Floyd算法思想 2.1 路径矩阵 通过一个图的权值矩阵求出它的每两点间的最短路径矩阵。
从图的带权邻接矩阵A=[a(i,j)] n×n开始，迭代地进行n次更新，即由矩阵D(0)=A，按一个公式，构造出矩阵D(1)；又用同样地公式由D(1)构造出D(2)；……；最后又用同样的公式由D(n-1)构造出矩阵D(n)。矩阵D(n)的i行j列元素便是i号顶点到j号顶点的最短路径长度，称D(n)为图的距离矩阵，同时还可引入一个后继节点矩阵path来记录两点间的最短路径。
采用松弛技术（松弛操作），对在i和j之间的所有其他点进行一次松弛。所以时间复杂度为O(n^3);
2.2 状态转移方程 其状态转移方程如下： map[i,j]:=min{map[i,k]+map[k,j],map[i,j]}；
map[i,j]表示i到j的最短距离，K是穷举i,j的断点，map[n,n]初值应该为0，或者按照题目意思来做。
当然，如果这条路没有通的话，还必须特殊处理，比如没有map[i,k]这条路。
三、Floyd算法 java代码 @Data public class Floyd { // 距离矩阵 double[][] distance; /** * @param distance * @Description 构造函数 * @Author WSKH */ public Floyd(double[][] distance) { this.distance = distance; } /** * @Description 进行求解 * @Author WSKH */ public void solve() throws IOException, ClassNotFoundException { double[][] cloneDistance = copy2DArr(distance); // 中间点 for (int i = 0; i &lt; distance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52199c25e887428202869800a6807b1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075bd23bffd7ab22a86bb24fcd4fbd75/" rel="bookmark">
			Vue中使用Web Serial API连接串口，实现通信交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中使用Web Serial API连接串口，实现通信交互 Web Serial API，web端通过串口与硬件通信;
该API是JS本身 navigator 对象上就独有的，所以与Vue和React框架开发都没有太大的关系，
串口是一个双向通信接口，允许字节发送和接收数据。
Web Serial API为网站提供了一种使用JavaScript对串行设备进行读写的方法。串行设备可以通过用户系统上的串行端口连接，也可以通过模拟串行端口的可移动USB和蓝牙设备连接。
换句话说，Web Serial API通过允许网站与串行设备(如微控制器和3D打印机)通信来连接网络和物理世界。
这个API也是WebUSB的好伙伴，因为操作系统要求应用程序使用它们的高级串行API而不是低级的USB API与一些串行端口通信。
Web Serial API 是一项 Web 技术，用于在浏览器中访问串行端口设备（如 Arduino、传感器等）并与之通信。它提供了一组 JavaScript 接口，使得 Web 应用程序可以通过 USB 串行端口连接到硬件设备，并进行数据发送和接收操作。
判断浏览器支持串口通信 if ("serial" in navigator) { console.log(true); } else { console.log(false); } 常用的API requestPort----获取授权串口open-----打开串口close—关闭串口(串口关闭前，需要释放锁住的流)cancel—立即退出读取的循环，然后去调用releaseLock，最后调用close方法releaseLock—Reader和.Writer的释放方法read—port.readable.getReader()的读取字节数组方法write—port.writable.getWriter()的写入方法 参考文档 Web Serial API
MDN Web Docs Web Serial API
示例完整代码 &lt;template&gt; &lt;div class="serial-port"&gt;测试串口&lt;/div&gt; &lt;el-button type="primary" @click="connectToSerialPort"&gt;连接串口&lt;/el-button&gt; &lt;el-input v-model="inputData" maxlength="50" placeholder="输入发送数据内容" show-word-limit type="textarea" /&gt; &lt;el-button type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/075bd23bffd7ab22a86bb24fcd4fbd75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16164e4d40901ee8915705c628fc055b/" rel="bookmark">
			程序员纪念日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1024这一特殊的节日，爱自己
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fcab848f7ba6cbf16ca97d3f028757/" rel="bookmark">
			Unity - 导出的FBX模型，无法将 vector4 保存在 uv 中（使用 Unity Mesh 保存即可）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的问题解决方案验证保存为 Unity Mesh 结果 - OK保存为 *.obj 文件结果 - not OK，但是可以 DIY importer注意References 目的 备忘，便于日后自己索引
问题 为了学习了解大厂项目的效果：
上周为了将 王者荣耀的 杨玉环 的某个皮肤的头发效果还原
所以我想直接抓模型，再还原 shader
我使用的还是以前的老方法： GPA + 夜神模拟器，具体可以查看以前的另一篇教程，具体参考：教你如何使用GPA导出模型，另送一个 GPA CSV2MESH Tool in unity
抓出来的数据，导出 FBX 后，我看不出什么异常
直到，我逐行的 shader 还原效果的时候
发现 vertex input 数据有 float4 uv1 : TEXCOORD1; float4 uv2 : TEXCOORD2;
但是发现 shader 调试发现，uv1, uv2 使用颜色输出都发现了数据不对的 BUG
然后我还想在 unity Game 视图下，使用 RenderDoc 抓帧分析一下
结果 Load RenderDoc 之后，直接导致 unity 闪退
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68fcab848f7ba6cbf16ca97d3f028757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a5629afc25588e9cf4c27c43485840b/" rel="bookmark">
			编写自己的strcmp函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先理解strcmp函数的实现过程 strcmp（字符串1，字符串2）实现过程是从左到右对字符串元素逐个比较其ASCII码的大小比较，遇到不一样的字符或者‘\0‘结束比较，str1=str2,返回0，str1&lt;str2,返回负整数，srt1&gt;str2返回正整数。
2.利用函数来实现 #include&lt;stdio.h&gt; void my_stecmp(char * s1,char * s2)//无返回值函数 形参类型为字符指针 { char * one = s1;//将指针指向s1 不修改字符串常量 char * two = s2; whlie (*one !='\0' &amp;&amp; *two ！= '\0' ){ //当两个字符串不是空时 if(*one == *two){ //如果两个字符串对应位置元素相等 注意要写== one++;//字符串1移动到下一个元素 two++;//字符串2移动到下一个元素 continue；回到循环 } break; 跳出循环 此时指针指向两数组第一个不同元素 } int i = *one - *two;//用i来记录字符串1和字符串2对应元素的ASCII码差值 if（i&lt;0）{ printf（"s1 &lt; s2"; } else if(i&gt;0){ printf("s1 &gt; s2"); } else if(i==0){ printf("s1 == s2"); } return ; } int main(int argc,const char*argv[]) { char s1 [20];//定义一个字符串数组 用来输入字符串 char s2 [20]; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a5629afc25588e9cf4c27c43485840b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b395bc2710a9c546a0b3b7575106c2ba/" rel="bookmark">
			又是一年猿好日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一转眼又到了一年一度的程序员节，1024
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80c1a7d9e7b1acee54cbe30a1adb40c/" rel="bookmark">
			【Python小练习】使用Python编写POC 脚本-下篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常用库通用脚本模版 常用库 urllib – 用于操作URL的模块
urllib.request -- 打开和读取url urllib.error -- 包含 urllib.request 抛出的异常 urllib.parse -- 解析 URL requests – 实现的简单易用的HTTP库，比urllib更加简洁
requests.get(url,headers,data,verify=False,proxies=proxy,timeout=10) url —— 请求的url headers —— 请求时构造的请求头 data —— 请求时带入的数据 verify —— 取消https告警 proxies —— 代理设置 timeout —— 请求响应超时处理 re – 正则表达式模块，使用简洁的字符表达式，匹配字符串中想要的结果
使用的正则语法，建议将请求源码复制到在线正则匹配网站，进行正则语法构造。 正则在线测试：https://c.runoob.com/front-end/854 json – 将Python数据处理成json格式或者将json数据处理成Python数据格式
json.dumps 将 Python 对象编码成 JSON 字符串 json.loads 将已编码的 JSON 字符串解码为 Python 对象 lxml – XML和HTML的解析器，其主要功能是解析和提取XML和HTML中的数据，也可以定位特定元素及节点的信息
lxml 定位元素节点涉及到Xpath语法 from lxml import etree html = etree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80c1a7d9e7b1acee54cbe30a1adb40c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d03e8bd83ab209e153a4723b77a3de1/" rel="bookmark">
			HTML 显示本地电脑时间（精确到毫秒）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;实时显示本地电脑时间（精确到毫秒）&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;本地电脑时间（精确到毫秒）：&lt;/h1&gt; &lt;h1 id="clock"&gt;&lt;/h1&gt; &lt;script&gt; function updateClock() { const now = new Date(); const year = now.getFullYear(); const month = String(now.getMonth() + 1).padStart(2, '0'); const day = String(now.getDate()).padStart(2, '0'); const hours = String(now.getHours()).padStart(2, '0'); const minutes = String(now.getMinutes()).padStart(2, '0'); const seconds = String(now.getSeconds()).padStart(2, '0'); const milliseconds = String(now.getMilliseconds()).padStart(3, '0'); const timeString = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${milliseconds}`; document.getElementById('clock').textContent = timeString; } // 每毫秒更新一次时间 setInterval(updateClock, 1); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4f6b664ccec5f4f7eb75d4baa5cf48/" rel="bookmark">
			java特殊文件 属性文件properties和XML文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 属性文件propertiesXML文件 属性文件properties 后缀为.properties的文件，称之为属性文件，它可以很方便的存储一些类似于键值对的数据。经常当做软件的配置文件使用。
首先我们要掌握属性文件的格式：
1.属性文件后缀以.properties结尾 2.属性文件里面的每一行都是一个键值对，键和值中间用=隔开。比如: admin=123456 3.#表示这样是注释信息，是用来解释这一行配置是什么意思。 4.每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。 5.键不能重复，值可以重复 那么如何读取.properties文件呢？需要使用到Properties类，Properties是Map接口下面的一个实现类，所以Properties也是一种双列集合，用来存储键值对。 但是一般不会把它当做集合来使用。Properties类的对象，用来表示属性文件，可以用来读取属性文件中的键值对。需要用到的方法如下。
Properties读取属性文件的步骤如下:
1、创建一个Properties的对象出来（键值对集合，空容器） 2、调用load(字符输入流/字节输入流)方法(哪个都行,读文本还是建议用前者)，开始加载属性文件中的键值对数据到properties对象中去 3、调用getProperty(键)方法，根据键取值 注意这里管道资源不需要我们手动关闭，api内部自动关 public class PropertiesTest1 { public static void main(String[] args) throws Exception { // 1、创建一个Properties的对象出来（键值对集合，空容器） Properties properties = new Properties(); System.out.println(properties);//输出{} // 2、开始加载属性文件中的键值对数据到properties对象中去 properties.load(new FileReader("properties-xml-log-app\\src\\users.properties")); System.out.println(properties);//输出{admin=123456,...} // 3、根据键取值 System.out.println(properties.getProperty("赵敏")); System.out.println(properties.getProperty("张无忌")); // 4、遍历全部的键和值。 //获取键的集合 Set&lt;String&gt; keys = properties.stringPropertyNames(); for (String key : keys) { //再根据键获取值 String value = properties.getProperty(key); System.out.println(key + "----&gt;" + value); } properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4f6b664ccec5f4f7eb75d4baa5cf48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c238877fdb3f9eeefcc7f70b2a85c96c/" rel="bookmark">
			手把手带你构建一个现代化的 python 项目结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 最近在搞一堆开源项目，同时面临着不断创建 python 项目的需求，故特意在 github 上逛了一圈，找到一个特别完善的 python-package-template，因源作者不再维护，因此笔者将其进行二次开发，对 windows 环境下做了特别的适配优化，并且完善了原有项目存在的一些问题。需要说明的是，这个项目可以很好地提升 python 开发的工程能力，含金量极高，下面笔者将介绍一下这个项目。
python-package-template 内置了单元测试、代码检查、格式化、包管理、pre-commit 配置、Github Actions 等众多方便的工具，可以很方便的管理 Python 项目
python-package-template 仓库地址：https://github.com/Undertone0809/python-package-template
快速上手 cookiecutter gh:Undertone0809/python-package-template --checkout v1.0.1 你只需要安装最新版本的 cookiecutter 😉
🚀 功能 在这个 cookiecutter 🍪 模板中，我们结合了最先进的库和 Python 最佳开发实践。
开发功能 支持 Python 3.7 及更高版本。使用 Poetry 作为依赖管理器。请查看 pyproject.toml 和 setup.cfg 中的配置。使用 black、isort 和 pyupgrade 进行自动代码格式化。预配置的 pre-commit 钩子，用于代码格式化。使用 mypy 进行类型检查，使用 darglint 进行文档字符串检查，使用 safety 和 bandit 进行安全检查。使用 pytest 进行测试。预配置的 .editorconfig、.dockerignore 和 .gitignore 文件。你不需要担心这些事情。 部署功能 GitHub 集成：问题和 PR 模板。使用预定义的 构建工作流程 作为默认的 CI/CD。已经设置好安全检查、代码格式检查、代码格式化、测试、linting、Docker 构建等的所有内容，使用 Makefile。更多细节请参阅 makefile-usage。为你的包提供 Dockerfile。使用 @dependabot 始终保持依赖项最新。你只需要启用它。使用 Release Drafter 自动生成发布说明。你可以在 release-drafter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c238877fdb3f9eeefcc7f70b2a85c96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ab930e25f7e338c8033ee9ccda1b79/" rel="bookmark">
			将本地文件复制到docker容器中并执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要：在搭建docker容器时，需要把所需要的包全部安装上，但为了保证是否安装完全，可以将本地的项目文件复制到docker容器中运行，及时将缺的包安装上。
在上一篇创建docker容器并发布远程服务器平台第二节安装好一些所需的常用包之后，退出容器，开始复制本地文件
一、复制本地文件到docker容器 1.查看正在使用的容器的ID 命令：docker ps -a
2.将本地文件先上传xftp（建立与当前创建容器的服务器的连接），然后复制到docker容器 命令：docker cp 【在xftp中的路径】【容器ID】:【要复制到容器的路径】
例子：docker cp /home/ubuntu/rpg_e2depth-master 47dbcce9fce4:/workspace
二、 在容器中运行代码 1.启动容器 命令：docker start 【容器ID】
2.进入容器 命令：docker exec -it 【容器名称】 bash
ls命令显示目标路径中的全部文件
cd 【文件夹】跳转到该文件夹，再ls查看文件是否都复制成功
3.在项目文件中运行训练代码 命令：python 【训练文件】
报错ImportError表示包没有安装（正好对应我们此篇文章的目的，检查包是否安装完全）
4.安装缺的包(这里导入cv2出错） 命令：pip install opencv-python-headless -i https://pypi.tuna.tsinghua.edu.cn/simple
5.重复3.4. 直到不再报导入包的错为止 6.删除本地文件 cd ..（有空格）：返回上一级目录，退出本地文件
删除命令：rm -rf 【文件名】
7.退出容器 三、镜像发布 到这里，我们的所需的包就都安装完成啦，就可以打包镜像了！ 1.修改镜像名称 不修改名称在发布镜像的时候一直报错找不到镜像Error response from daemon: No such image: pytorch_ddhm
nvidia-docker commit pytorch_ddhm ddhm_pytorch
2.将镜像保存成tar文件 nvidia-docker save ddhm_pytorch -o ddhm_pytorch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ab930e25f7e338c8033ee9ccda1b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d08339de400491b43e1e31d56f5f659/" rel="bookmark">
			el-datepicker赋值之后不能再修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赋值需改用$set赋值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b401dcbaf1ba2ea6db1351def2c9e1b/" rel="bookmark">
			Tomcat和HTTP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 1.Java EE 规范 JavaEE（java Enterprise Edition）：java企业版
JavaEE 规范是很多的java开发技术的总称。这些技术规范都是沿用自J2EE的。一共包括了13个技术规范
2.WEB概述 WEB在计算机领域中代表的是网络
像我们之前所用的WWW，它是World Wide Web三个单词的缩写，称为：万维网
网络相关的技术的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，叫做网站
我们通过输入网站的地址（网址），就可以访问网站中提供的资源（不区分局域网或广域网）
3.资源分类 静态资源
网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的
作为开发者来说，编写的HTML，CSS，JavaScript都属于静态资源
动态资源
网站中提供给人们展示的资源是由程序员产生的，在不同的时间或不同的人由于身份的不同，所看到的内容是不一样的，作为开发者来说，我们编写的JSP，servlet等都属于动态资源
4.系统结构 之前开发的都是java工程。这些工程在企业中称为项目或者产品。它都是有系统架构的
基础结构划分
CS结构
BS结构
技术选型划分
Model1模型
Model2模型
MVC模型
三层架构+MVC模型
部署方式划分
一体化结构
垂直拆分结构
分布式结构
微服务结构
CS结构：（Client Server） 客户端+服务器方式
BS结构：（Browser Server） 浏览器+服务器的方式
2.tomcat 1.服务器介绍 服务器是计算机的一种，它比普通计算机运行更快，负载更高，价格更贵。服务器在网络中为其他客户机（PC机，智能设备等）提供计算或者应用服务。服务器具有高速度CPU运算能力，长时间的可靠运行，强大的I/O外部数据吞吐能力以及更好的扩展性
这里所说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，通过和硬件的相结合，从而达到帮助我们来发布应用的功能，让用户通过客户机访问我们的应用
2.Tomcat概述 Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。
下载：
Apache Tomcat® - Welcome!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b401dcbaf1ba2ea6db1351def2c9e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1a0fc0bd8cb5a36da60eca393c98cf/" rel="bookmark">
			sklearn-5模型评估与改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过前述章节可以发现，可调用模型的.score方法获取测试集评分，还有其他方法可以更好的评估模型，有交叉验证和网格搜索
1 交叉验证 特点 1数据被多次划分，且需要训练多个模型
k折交叉验证 k由用户指定，通常取5-10， 将数据均分为k份，每份叫做折，然后开始训练数据，训练k次，每第k次训练时，取第k折数据作为测试集，其他数据均为训练集，最后可以得到k个模型训练的打分，一般可以用k次训练的平均值作为交叉验证的结果
1.1 优缺点 优点
1 验证次数多，验证均匀，不会像train_test_split一样，可能偶尔某个测试集异常数据较多，导致测试结果不稳定
2 训练集比例不同。RFE训练数据比例高于train_test_split的划分比例（75%）
缺点
1 交叉验证多次训练，更消耗时间，大约比单次训练验证慢k倍
2 交叉验证只是验证，不会返回经过数据训练的数据模型，只能获取得分
1.2 k折交叉验证和其他策略 1.2.1 分层k折交叉验证 分层k折和一般k折不同点在于，一般k折直接按顺序k分支一取测试集，如果原始数据分布不均匀，k折会不太稳定，一种解决方法是分层k折。分层k折是保证每个测试集和训练集的分类的百分比占比都为k分之一。cross_val_score默认使用的k折是一般k折交叉验证
1.2.2 交叉验证分离器 可将一些参数传给交叉分离器，交叉分离器可作为cv参数传入，类似于一种解耦
默认使用3折交叉验证iris时效率为0，因为数据已经有序分为3类，所以每次训练集都是一样的，只有一个种类，就啥也学不到
1.2.2.1 默认k折分离器 def test_cross_kfold(self): kfold = KFold(n_splits=5) logreg = LogisticRegression().fit(self.iris.data, self.iris.target) print(f'5 fold cross score: {cross_val_score(logreg, self.iris.data, self.iris.target, cv=kfold)}') print(f'3 fold cross score: {cross_val_score(logreg, self.iris.data, self.iris.target, cv=KFold(n_splits=3))}') 1.2.2.2 留一法交叉验证 概念 每次k折保留单个样本（集测试集只有一个样本）
优点 适合小型数据集，准确度高
缺点 耗时，需很多次模型创建与训练
def test_cross_leave_one(self): loo = LeaveOneOut() logreg = LogisticRegression().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a1a0fc0bd8cb5a36da60eca393c98cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7488d080ca8ec309776772f86105cfcd/" rel="bookmark">
			sknearl-7处理文本数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章代码大部分没跑，只供学习
第四节特征工程里提到，有连续特征和离散特征，对于文本数据，文本特征可以看作第三种特征
1 用字符串表示的数据类型 2 例子 电影评论情感分析 给定一个影评（输入），输出影评是正面还是负面
sklearn无法处理文本数据，需要将文本数据转换为数值表示，然后再用机器学习算法处理
3 将文本数据表示为词袋 词袋 即统计每个单词出现的频率
词袋构造步骤
1 划分原始字符串：将原始字符串用空格或标点负号分隔，获取单词拼写
2 构建词表，可进行编号
3 统计单词频率
3.1 词袋应用于玩具数据集 通过sklearn.feature_extraction.text.CountVectorizer构造词袋。构造完了可访问.vocabulary_访问词表，然后调用transform获取词袋，看下词表和词袋
def test_workds_bag(self): bards_words = ['the fool doth think he is wise,', 'but the wise man knows himself to be a fool'] vect = CountVectorizer().fit(bards_words) print(f'vocabulary type: {type(vect.vocabulary_)}, vocabulary: {vect.vocabulary_}') bag_words_trans = vect.transform(bards_words) print(f'words bag transform type:{type(bag_words_trans)},\n' f'words bag transfrom shape:{bag_words_trans.shape},\n' f'words bag transform repr: {repr(bag_words_trans)}\n' f'words bag transform:\n {bag_words_trans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7488d080ca8ec309776772f86105cfcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40b994dcb52bf69b8a19ff09634c933/" rel="bookmark">
			CSP认证 202212-01 现值计算 满分题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个题目思路比较清晰，就是把后几年的盈利或者亏损转换到今年，看看总体具体是盈利还是亏损，确实读题目要花点时间，但是理解了题目敲代码就很快，O(n)时间就可以解决。
#include&lt;iostream&gt; using namespace std; double pow(double base, int pow){ //定义一个求base的pow次方的函数，直接调用。 double result = 1; for(int i = 0; i &lt; pow; i++){ result *= base; } return result; } int main(){ int n; double i,totle = 0; cin &gt;&gt; n &gt;&gt; i; //输入年数，和利率 int money_change; for(int j = 0; j &lt; n + 1; j++){ cin &gt;&gt; money_change; totle += money_change * 1 / pow(1 + i,j); } cout &lt;&lt; totle; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86f5e305f453647feca1596fcc2f719/" rel="bookmark">
			DNS入门学习：什么是TTL值？如何设置合适的TTL值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TTL值是域名解析中的一个重要参数，TTL值设置的合理与否对于域名解析的效率和准确性有着非常重要的影响，因此对于网站管理者而言，了解什么是TTL值以及如何设置合理的TTL值对于做好域名解析管理，确保网站的安全稳定运行至关重要。
TTL是Time To Live的缩写，翻译过来就是生存时间，用于DNS解析之中就是指DNS解析记录（DNS缓存）在DNS服务器上的保留时间。要想了解TTL的原理，需要先弄清楚DNS解析工作中的DNS缓存机制。
在实际的域名解析过程中，用户访问域名后，并不是每次都需要向权威解析服务器去请求最新的解析记录，这样不但会产生比较大的解析时延，同样也会对权威解析服务器造成较大的解析压力，因此在DNS解析的多个环节中都使用了DNS缓存技术用来提高DNS解析的效率。
当用户第一次访问域名时，由于DNS服务器中还不存在DNS缓存，所以最终会请求到负责该域名的权威解析服务器，获得该域名的解析记录。DNS服务器（递归解析服务器）将该结果返回给用户的同时，也会在自身储存一段时间，这就是DNS缓存，而储存的这段时间就是TTL值。
在DNS缓存失效前即TTL值有效期内，如果有用户再次请求相同的域名，DNS服务器不会再请求权威解析服务器，而是直接从自身缓存中找到结果告知用户，这样就省去了每次请求权威服务器的繁琐过程，解析效率大幅提升。
那既然这样，是不是TTL值越大越好呢？当然不是，因为TTL值除了和DNS解析的速度有关外，还影响着DNS解析的安全性和准确性。
DNS缓存虽然能够提升解析的速度，但是也存在很大的安全隐患。DNS服务器在缓存了域名解析记录之后，无法实时监测权威解析服务器的记录，这就会导致权威解析服务器的DNS记录发生变化时，DNS缓存中的记录不能实时同步更新。如果在这段时间中，有用户请求域名，DNS服务器就会从DNS缓存中将过期的解析记录返回给用户，从而导致解析出错，站点不可达或者用户请求到错误的服务器。
此外，DNS缓存也为攻击者利用DNS机制进行攻击提供了可能。利用DNS服务器向权威服务器请求的间隙时间，攻击者可以将错误的解析记录注入DNS缓存之中，当用户请求域名，DNS服务器就会不加核实地将DNS缓存中错误的解析记录告知用户，从而将用户引导至受攻击者控制的钓鱼网站，造成个人信息的泄露和财产的损失。
因此，从DNS解析安全和准确性来讲，TTL值不能设置得太大。那如果TTL设置得太小又有什么影响呢？
TTL值越小，DNS服务器就会越频繁地请求权威服务器，就能更及时地同步权威服务器中的解析记录变化，获取最新的记录结果，确保DNS解析的准确性。同时TTL值越小，请求权威服务器的间隙越小，攻击者进行DNS缓存投毒的可能性越小。
当然TTL值设置得太小，也有一定的弊端。因为TTL值越小，请求权威服务器越频繁，对权威服务器造成的压力越大，甚至可能造成权威服务器的线路拥堵和宕机。而且TTL值太小，会经常发起全球迭代查询，经历多个环节的解析过程，产生较大的解析时延，反而失去了DNS缓存的原本作用。
综上所述，TTL值并没有适用于所有企业的固定标准，而是要根据网站自身情况而定。如果网站服务器稳定，轻易不会更换服务器，那么就可以设置比较大的TTL值，以解析速度为先。如果网站的解析经常变，服务器经常换，或者是网站对解析安全要求比较高，那么可以设置比较小的TTL值，这样就可以提升DNS解析的安全性和准确性。如果没有特殊的要求，一般不会单独设置TTL值，采用服务商默认的TTL值即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de68f6df70dc5319da160e015b07c9c/" rel="bookmark">
			7、TS内容学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期背景TS是什么？js和java区别为什么学习TSTypeSscript类型 1、基础类型2、数组类型3、类型别名4、函数类型5、void类型 &amp;&amp; never类型voidnever 6、可选参数7、对象8、接口interfaceinterface VS type接口继承type 如何和 interface 一样实现继承的效果？ 9、元组Tuple10、字面量11、枚举类型enum数字枚举字符串枚举枚举实现原理 12、any类型13、类型断言 | 交叉类型交叉类型 14、泛型泛型约束多个类型变量泛型接口 知识总结参考相关的面试题interface和type的区别 前期背景 TS是什么？ TS是JS的类型的超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。
js和java区别 JS：解释型，弱类型，动态语言Java：编译型，强类型，静态语言 解释：
解释型：我们写的代码，无需进行编译，直接运行，也需要一个翻译器，一遍翻译一边执行编译型：人类写的是英语，机器不认识，需要一个编译器，将人们写的语言转换成机器识别的语言，这个过程叫编译弱类型：声明变量时无需指定类型强类型：声明变量时必须指定类型动态语言：在代码执行的过程中可以动态添加对象的属性静态语言：不允许在执行过程中随意添加属性 结论：js的特点是灵活、高效，很短的代码就能实现复杂功能，缺点是没有代码提示，容易出错且编辑工具不会给任何提示，而Java则相反。
TS可以简单理解为将JavaScript转变为Java一类语言的过程。
为什么学习TS 从编译语言的动静来区分，TS属于静态类型的编程语言，JS属于动态类型的编程语言。 静态类型：编译期做类型检查动态类型：执行期做类型检查 对于JS来说，需要等到代码真正去执行的时候才能发现错误（晚）， 对于TS来说，在代码编译的时候（代码执行前）就可以发现错误（早）； 并且，配合VSCode等开发工具，TS可以提前到在编写代码的同时就发现代码中的错误，减少找Bug，改Bug时间，另外还支持代码提示。
Vue3的源码使用TS重写，Angular默认支持TS、React与TS完美配合，TypeScript已经成为大中型前端项目的首选变成语言。
注意：Vue2对TS的支持不好~
TypeSscript类型 类型注解总结：
将来不能将其他类型的值赋予这个变量代码有提示，在变量后面.可以直接看到当前类型所支持的所有属性和方法 可以将TS中的常用基础类型细分为两类：
JS已有类型 原始类型，简单类型（number、string、boolean、null、undefined）复杂数据类型（数组、对象、函数等） TS新增类型 联合类型自定义类型（类型别名）接口元组字面量类型枚举voidanynever名字空间 1、基础类型 // 字符串类型 let a:string = '123'; // 数字类型 let num: number = 123; // 与 void 的区别是，undefined 和 null 是所有类型的子类型。 // 也就是说 undefined 类型的变量，可以赋值给 string 类型的变量： //这样是没问题的 let test: null = null let num2: string = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de68f6df70dc5319da160e015b07c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e1bb6a4b216fd552e97be5db448fe4/" rel="bookmark">
			js给一段话，遇到的第一个括号处加上换行符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 list.forEach((item,index0)=&gt;{ const productName = item.name; const index = productName.indexOf('（'); if (index == -1) { return productName; } const before = productName.slice(0, index); const after = productName.slice(index); item.name=before + '\n' + after; }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8a012a8d4d9f75d04bc55e11b80d7c/" rel="bookmark">
			java: 无法访问org.springframework.context.ApplicationContext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学Spring遇到如下报错：
java: 无法访问org.springframework.context.ApplicationContext
错误的类文件: /E:/Maven/repository/org/springframework/spring-context/6.0.9/spring-context-6.0.9.jar!/org/springframework/context/ApplicationContext.class
类文件具有错误的版本 61.0, 应为 52.0
请删除该文件或确保该文件位于正确的类路径子目录中。
找了半天原因，尝试过重新安装和删除文件夹，都没改变，最后发现是因为跟jdk版本不匹配造成的。
解决办法：到file——project Structure内，看自己的sdk版本，我用的是jdk8，因此不能用spring6.x开头，只能用spring5以下，修改spring依赖版本后可以正常使用
修改前：
修改后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c889de807a59afb643eb21fd99e5389/" rel="bookmark">
			git stash 问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下采坑记录
我在本地仓库做了一些修改，但还没有进行提交和推送。当我尝试使用git pull拉取最新代码时，Git会拒绝操作，提示你使用git stash命令。git stash命令的作用是将当前的修改暂存起来，以便我可以切换到其他分支或者拉取最新代码。
然后我可以使用git stash pop命令将之前暂存的修改重新应用到你的工作目录中。
这个过程是正确的，但是有一些细节需要注意：
在执行git stash之前，确保你的工作目录是干净的，没有未提交的修改。你可以使用git status命令来检查工作目录的状态。
如果你的修改涉及到新创建的文件，这些文件可能不会被git stash命令暂存起来。你可以使用git add命令将这些文件添加到暂存区，然后再执行git stash。
在执行git stash pop之前，确保你当前的工作目录是干净的，没有未提交的修改或者未解决的冲突。如果有冲突，你需要先解决冲突，然后使用git stash drop命令丢弃之前的暂存记录，再执行git stash pop。
总结一下，使用git stash命令可以将当前的修改暂存起来，以便你可以切换分支或者拉取最新代码。然后使用git stash pop命令将之前暂存的修改重新应用到工作目录中。在执行这些命令之前，确保工作目录是干净的，没有未提交的修改或者未解决的冲突。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff8903b0ced295b1544e365c06df54c/" rel="bookmark">
			算法刷题总结 (七) 双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法总结7 双指针 一、双指针的概念1.1、什么是双指针？1.2、常见类型1.2.1、快慢指针1.2.2、左右端点指针（相向双指针）* 详解二分法（二分查找 / 二分答案） 1.2.3、区间指针 - 滑动窗口（同向双指针）汇总 二、经典例题2.1、快慢指针（1）、链表判环141. 环形链表142. 环形链表 II287. 寻找重复数876. 链表的中间结点 （2）、读写指针26. 删除有序数组中的重复项 - 仅保留一次80. 删除有序数组中的重复项 II - 保留两次重复递推：删除且保留k次重复202. 快乐数 2.2、左右端点指针（相向双指针）（1.1）、二分法34. 在排序数组中查找元素的第一个和最后一个位置33. 搜索旋转排序数组 - （非有序序列）162. 寻找峰值 - （非有序序列）475. 供暖器 （使用python库 bisect） （1.2）、二分答案购物系统的降级策略875. 爱吃香蕉的珂珂组装最大可靠性设备最佳植树距离食堂供餐数据最节约的备份方法 - 二分答案+dfs （2）、有序数组暴力枚举 - N数和问题167. 两数之和 II - 输入有序数组1. 两数之和15. 三数之和18. 四数之和递推：N数之和16. 最接近的三数之和881. 救生艇 （3）、其他暴力枚举75. 颜色分类 - 类似于荷兰国旗问题977. 有序数组的平方11. 盛最多水的容器42. 接雨水 2.3、区间指针 - 滑动窗口 （同向双指针）（1）、定长滑动窗口1456. 定长子串中元音的最大数目剑指 Offer 22. 链表中倒数第k个节点 （2）、变长滑动窗口1004. 最大连续1的个数 III209. 长度最小的子数组 - （从符合条件到不符合条件）713.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fff8903b0ced295b1544e365c06df54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec719b5cd399228c355bc2247627e80/" rel="bookmark">
			R-CNN(目标检测算法)介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是目标检测 1.1 目标检测概念 目标检测 (Object Detection) 是计算机视觉领域中的一项任务，旨在从图像或视频中准确地定位和识别多个感兴趣的目标物体。目标检测不仅需要确定目标的类别，还要找到目标在图像中的位置.由于各类目标不同的外观，颜色，大小以及在成像时光照，遮挡等具有挑战性的问题，目标检测一直处于不断的优化和研究中.
1.2 目标检测步骤: 数据收集和标注：首先，需要收集包含目标对象的图像或视频数据集。这些数据集应该覆盖所需检测的目标类别，并且需要进行手动标注，即为每个目标在图像中标记边界框及对应的类别标签。
候选区域生成：通过使用候选区域生成算法（如选择性搜索、边缘框架、基于深度学习的区域建议网络等），从输入图像中生成一组可能包含目标的候选区域。这些候选区域是用来进一步分析和检测目标的区域。
特征提取：对于每个候选区域，使用卷积神经网络（CNN）或其他特征提取方法来提取区域的特征表示。这些特征通常是在预训练的网络上提取得到的，可以捕捉到图像中的局部和全局信息。
目标分类与回归：基于提取的特征，使用分类器（如支持向量机(SVM)、softmax分类器）进行目标分类，确定候选区域中的目标类别。同时，还进行边界框回归，以更准确地定位目标在候选区域中的位置和尺寸。
非极大值抑制：由于一个目标可能会在多个候选区域中被检测到，需要进行非极大值抑制。该过程通过选择具有最高置信度的目标检测结果，并消除重叠的检测结果来排除冗余。
后处理和可视化：最后，对于每个被保留的目标检测结果，可以进行后处理操作，如去除低置信度的检测结果、进一步分析目标属性等。同时，还可以将检测结果以边界框或标签的形式可视化，使其易于理解和解释。
边界框是什么?
边界框（bounding box）是在目标检测和物体识别中经常使用的一种表示方法，用于定位目标在图像中的位置和范围。边界框是一个矩形框，通常由左上角和右下角两个点的坐标表示。
边界框提供了目标在图像中的大致位置信息，并且可以通过其坐标来确定目标的尺寸和形状。在目标检测任务中，边界框通常与目标类别关联，用于表示检测到的目标及其对应的类别。
边界框可以简洁地描述目标的位置和区域，使得我们可以准确地标记、跟踪和定位目标。它是许多目标检测算法的核心组成部分，例如RCNN系列、YOLO、SSD等算法。
边界框通常用一组数值来表示，其中最常见的是四个浮点数或整数，分别表示左上角和右下角点的(x, y)坐标。有时候还会包括目标的类别标签和置信度得分等附加信息。
通过边界框，我们可以方便地进行目标的定位、裁剪、划分和测量等操作，为目标检测和物体识别任务提供了重要的信息基础。
1.3 目标检测算法分类 1.传统方法与深度学习方法:
传统方法：传统的目标检测方法主要基于手工设计的特征和机器学习算法，如Haar特征、HOG（Histogram of Oriented Gradients）和SIFT（Scale-Invariant Feature Transform）等。这些方法通常在目标检测性能方面存在一定的限制。深度学习方法：近年来，随着深度学习的发展，基于深度神经网络的目标检测方法取得了显著的进展。这些方法通过端到端的训练，自动学习图像特征表示和目标分类器，例如RCNN系列、YOLO系列、SSD、RetinaNet和EfficientDet等。 2.两阶段方法与单阶段方法:
两阶段方法(Tow Stage)：两阶段方法将目标检测任务分为候选区域生成和目标分类定位两个阶段。首先，通过选择性搜索、区域建议网络（RPN）等方法生成候选区域，然后对每个候选区域进行分类和边界框回归。典型的两阶段方法有RCNN系列和Faster R-CNN等。单阶段方法(One Stage)：单阶段方法直接在图像上密集地预测目标的类别和边界框，通常通过将图像分割为网格单元，并为每个单元生成预测来实现。常见的单阶段方法包括YOLO系列和SSD等。 3.基于特征金字塔(Feature Pyramid)的方法:
特征金字塔是指在不同尺度上提取特征并融合它们以检测不同大小的目标。基于特征金字塔的方法可以更好地处理多尺度目标。例如，FPN（Feature Pyramid Network）和RetinaNet就是基于特征金字塔的目标检测算法。 4.单目标检测与多目标检测：
单目标检测：单目标检测算法旨在检测和定位图像中的单个目标实例。多目标检测：多目标检测算法能够同时检测和定位图像中的多个目标实例，例如目标检测中的行人、车辆、动物等. 二、什么是R-CNN 2.1 R-CNN概念 RCNN（Region-based Convolutional Neural Networks）是一种经典的目标检测算法，最初由Girshick等人在2014年提出。它通过将图像分割成多个候选区域，并对每个候选区域进行分类和边界框回归来实现目标检测。
2.2 R-CNN结构 整体步骤:
候选区域生成：在图像中提取候选区域，这些候选区域通常是通过选择性搜索（Selective Search）等算法生成的。选择性搜索将图像分割为多个不同尺度和形状的区域，并根据颜色、纹理、大小等特征进行合并，以产生可能包含目标的候选区域。
特征提取：对每个候选区域应用卷积神经网络（CNN）来提取特征表示。通常使用预训练的CNN模型，如AlexNet、VGGNet或ResNet等，在候选区域上进行前向传播，以获得固定长度的特征向量。
目标分类:提取的特征向量作为输入，经过一个支持向量机（Support Vector Machine，SVM）分类器进行目标类别的分类。在训练阶段，SVM使用正负样本对模型进行训练，学习区分目标和非目标的能力。
非极大值抑制：由于选择性搜索算法可能会生成重叠的候选区域，为了消除冗余的检测结果，R-CNN使用非极大值抑制（Non-Maximum Suppression，NMS）来筛选最终的检测边界框。NMS通过比较检测框之间的重叠程度和得分，并保留最具有代表性的框。
边框位置修正 Boundingbox Regression
2.2.1 候选区域生成-----选择性搜索（Selective Search)算法: 选择性搜索（Selective Search）是一种用于生成候选区域的图像分割算法，常用于目标检测任务中。它通过分割和合并策略生成多个大小、形状和纹理不同的候选区域，以涵盖可能包含目标对象的各种可能性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec719b5cd399228c355bc2247627e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7957f0d2e362a973aba56d12e02ced7/" rel="bookmark">
			c语言中的-100和~100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是一个程序：
int num1=100,num2=-num1; printf("%d,%d,%d",num1,num2,~num1); return 0; 运行结果： 100,-100,-101 num2还是很好理解的这里主要了解一下 ~num1
首先100的二进制是：0110 0100然后与1111 1111相与得到1001 1011 （正确数值的补码）
然后1001 1010(正确数值的反码)最后是1110 0101（二进制原码）最后变成十进制是：-101
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee8a9451b0f77f9bdc9e69fa21c653f/" rel="bookmark">
			WSL下gcc for arm交叉编译链的系统配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下交叉编译工具名称和就都是举例 1. 永久生效 如需永久修改，请修改用户配置文件。
注意：如果不会使用vim命令，可以使用图形化的编辑工具，执行：
gedit ~/.bashrc vim ~/.bashrc 在行尾添加或修改，加上下面几行(第3行第4行为一行命令)：
export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- export PATH=$PATH:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin 设置完毕后，要执行 source ~/.bashrc 命令使其生效，这条命令是加载这些设置的环境变量。 设置完毕后，要执行 source ~/.bashrc 命令使其生效，这条命令是加载这些设置的环境变量。
source ~/.bashrc 使用这条指令查询，如果版本等信息打印出来则表示配置成功
arm-buildroot-linux-gnueabihf-gcc -v 2. 临时生效 也可以手工执行“export”命令设置环境变量，该设置只对当前终端有效(另开一个终端需要再次设置)。
执行以下3个命令，第3个命令很长，需要包含第四行全部复制：
export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- export PATH=$PATH:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin 3. 手动指定 先设置PATH环境变量，然后在make编译时指定ARCH架构 CROSS_COMPILE交叉编译工具链(执行make命令时指定的参数，只对当前命令有效；下次执行make时仍需要再次指定那些参数)
export PATH=$PATH:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-gnueabihf- export PATH=$PATH:/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 参考链接
【精选】配置交叉编译工具链和环境变量_交叉编译环境变量如何设置_宁静致远2021的博客-CSDN博客
WSL下安装gcc for arm交叉编译链_wsl 安装gcc-arm-none-eabi-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2b66619e7ba323bba256d686e9e46f/" rel="bookmark">
			【论文阅读】（2019）Enhanced Pseudo-polynomial Formulations for Bin Packing and Cutting Stock Problems
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、摘要二、介绍三、BPP和CSP的著名MILP公式3.1 问题描述和符号3.2 基于方案（Pattern）的公式3.3 伪多项式公式 四、模型之间的关系五、Reflect，一种改进的 Arc-Flow 公式5.1 Adapting Reflect 以解决大尺寸实例 : Reflect+5.1.1 列生成5.1.2 节点去激活和对偶切割5.1.3 弧失活 六、可变大小的BPP七、带有项目碎片的BPP八、计算结果8.1 关于BPP和CSP的结果8.2 VSBPP的结果8.3 BPPIF的结果 九、结论和未来研究 论文来源：（2019）Enhanced Pseudo-polynomial Formulations for Bin Packing and Cutting Stock Problems
作者：Maxence Delorme 等人
一、摘要 我们研究经典装箱和下料问题的伪多项式公式。我们首先从文献中提出了主要的基于模式和伪多项式公式之间的优势和等价关系的概述。然后我们引入reflect，这是一个新的公式，它只使用一半的bin容量来建模一个实例，并且比经典模型需要更少的约束和变量。当面元容量过高时，我们提出了利用列生成和对偶信息来补偿反射弱点的上限和下限技术。我们还提出了解决两个有趣的问题变体的技术的非平凡的修改，即可变大小的装箱问题和带有物品碎片的装箱问题。在基准实例上的大量计算测试表明，我们的算法在所有问题上都达到了最先进的结果，改进了以前的算法，并找到了几个新的经证明的最优解。 二、介绍 在本文中，我们继续伪多项式模型的研究，提出了理论和计算的兴趣结果。我们首先关注存在于众所周知的基于模式和伪多项式公式之间的关系，第一次提供了它们之间等价和支配的完整图像。然后，我们提出了一个新的有效的公式，称为反射，它只需要一半的bin容量来建模一个CSP实例。
与所有伪多项式公式一样，reflect在解决容量非常大的实例时也有困难。因此，我们用几种技术对其进行了改进，从而产生了一种叫做reflect+的算法，它具有出色的计算性能。具体而言，我们提供了以下贡献。
我们证明了CSP的一次切割和弧流公式是等价的(即，它们具有相同的连续松弛值)。我们扩展了以前的结果，并提供了一个存在于主要的基于模式和伪多项式MILP公式之间的优势和等价关系的清晰图像，这些公式已被提出用于BPP和CSP。我们介绍了我们的新公式，反映，并表明，它改善了经典弧流需要明显更少的约束和变量。我们开发了基于反射与列生成、双重切割和启发式的结合使用的改进技术。我们表明，我们的启发式算法比传统的方法更快和更有效的解决方案的集合覆盖模型与限制集合的列。我们通过设计公式和算法来解决两个重要的BPP变量，即可变大小的BPP和带有项目碎片的BPP，从而扩展了reflect和reflect+。我们进行了大量的计算测试，并表明我们的算法达到了最先进的结果，改进了文献中以前的算法，为BPP和CSP找到了几个新的最优解，并最优地解决了可变大小的BPP和带有项目碎片的BPP的所有尝试实例。 三、BPP和CSP的著名MILP公式 在本节中，我们正式描述了BPP和CSP，给出了必要的符号，并介绍了文献中为其解决方案开发的主要公式。
3.1 问题描述和符号 在BPP中，给定一组n个项目，每个项目的权重为 w j ( j = 1 , . . . , n ) w_j (j = 1,...,n) wj​(j=1,...,n) 以及容量为 c c c 的无限个相同箱子。目标是将所有物品装入最少数量的箱柜中，使得任何箱柜中物品重量的总和不超过容量。
为了更好地适应包装或切割的概念，在下文中，当提到 w j w_j wj​时，我们交替使用重量和宽度这两个术语。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca2b66619e7ba323bba256d686e9e46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb30093440a3c29eb9340d0770b0890c/" rel="bookmark">
			在Word中，图片显示不全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天交作业的时候，发现了一个非常SB的事情，把图片复制过去显示不完全：
使用文心一言查看搜索了一下，发现可能是以下几种原因：
图片所在行的行高设置不正确。可以重新设置行高，具体步骤包括打开图片显示不完全的word文档，选中图片，然后点击“段落”右下方的拓展小箭头，调出“段落对话框”，可以看到图片的行距太小，需要调大行距数值。图片格式设置不正确。在某些情况下，部分图片格式可能无法正确显示，因此建议使用常见且广泛支持的图片格式，比如JPEG或PNG。这样可以减少兼容性问题，从而避免图片显示不全的情况发生。“段落行距设置了固定值”。把行距设置为单倍行距即可解决问题。图片大小与文档布局不匹配。如果图片的尺寸过大，而文档的布局无法容纳整个图片，就会出现显示不全的情况。此时可以考虑调整图片的大小，使其适应文档的布局。 我排除了以下，初步确定为段落设置了固定值：
将固定值改为单倍行距，问题解决：
仅供参考。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da923d2aa1f04b4c9e9b4ff7eb25aaf9/" rel="bookmark">
			syn锁深入了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
一：syn主要实现方式和基本原理：
1.1实现原理
1.2syn特征：
二. synchronized底层存储
2.1 对象结构
2.2 对象头的组成
2.2.2 class pointer
2.3 Monitor监视器锁
2.3.1 monitor介绍
2.3.2 Java对象Object的Monitor机制
前言： 上次多线程锁使用写到了syn和lock的基本使用；
以及一篇线程的代码测试：线程池、可重入锁、读写锁、信号量、循环栅栏，编码测试
本次，再多了解一些syn锁，（源码分析，还没看完，下次补充）
syn锁：就是解决某个代码想要达到同步的效果，某一个线程在执行和过程中，不希望这个代码收到别的线程的影响；
例如：一个公共类，负责生成整体的流水号，简单理解就是，要保证多线程情况下，生成的流水号不要有重复的，当然实现方式有很多，这里就不多写了，本文主要在学习一些syn锁
syn锁特点
独占锁
可重入锁
非公平锁
syn1.6之前是重量级锁，之后进行优化，多线程情况下锁升级：无锁、偏向锁、轻量级锁、重量级锁，锁粗化、锁消除等手段，这也算是后来同步的map实现锁方式，更改为syn+CAS实现的一部分原因；
锁升级和参考实现参考 syn和lock的基本使用；
一：syn主要实现方式和基本原理： 1.1实现原理 1.修饰代码块
使用字节码指令，进行获取monitor和释放
通过使用monitorenter和monitorexit指令实现的，当线程执行monitorenter的时候就会尝试获取monitor的所有权，如果当前对象的monitor的进入计数器为0，就可以获取到这个对象锁，如果当前对象已经拥有了这个monitor的持有全，那么就可以重入这个monitor，重入的时候计数器也会加一。如果其他线程已经拥有了monitor的持有权，那么他就会阻塞，直到正在执行的线程执行完毕，即monitorexit指令执行，释放掉对象锁，并且把计数器设置为0
2.修饰方法
借助方法头中是否有同步标识，没有的话，进行获取monitor和释放
通过指令monitorenter和monitorexit来完成，而是通过ACC_SYNCHRONIZED标识符，放在常量池中。当方法调用的时候会检查方法的ACC_SYNCHRONIZED标识符是否已经被设置了，如果被设置了，执行的线程会先获取monitor，获取成功了才能执行方法体，方法执行完毕之后再释放monitor。在方法执行期间，任何其他线程都无法再获得同这个monitor对象。 其实和代码块本质上么有区别，只是方法同步是一种隐性的方式实现的，无需字节码来完成。
代码块是隐式的使用monitor,方法是显示的使用字节码指令指令进行操作monitoe,
关于ACC_SYNCHRONIZED 、monitorenter、monitorexit指令，可以看下面的反编译代码
参看网上截图 public class SynchronizedTest { public void get(){ synchronized (this){ // 这个是同步代码块 System.out.println("你好呀"); } } public synchronized void f(){ //这个是同步方法 System.out.println("Hello world"); } public static void main(String[] args) { } } 可以通过javap -verbose SynchronizedTest 对代码进行反编译，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da923d2aa1f04b4c9e9b4ff7eb25aaf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d120e79e35068bdfcd12a06c77c1bfe/" rel="bookmark">
			windows11系统VBS安全功能关闭方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Windows系统上的VBS安全功能，不知道大家以前是否有所了解。VBS中文意思是基于虚拟化的安全，全称Virtualization-Based Security。它构建于Hyper-V之上，使用软硬件虚拟化来增强系统安全性。
简单来说，就是开启后，主机会运行在虚拟机上，相当于多了一层屏障。如此一来，黑客仅通过远程攻击将很难窃取主机数据，更加安全。但是这样做，计算机性能势必会出现损失，导致游戏、跑分性能下降。
根据UL benchmarks公司报告，开启VBS后，其降幅最多可达30%。也有人实测，RTX 4090显卡关闭VBS后，某游戏帧率竟然提升了37.7%。因此，关于Windows到底要不要关VBS，网上争论一直没停过。
(系统信息)
其实，这是需要分情况来看的，对于普通用户来说，VBS确实没啥用。因为它并不能防住，自己下载到病毒和流氓软件，该出问题还是出问题。黑客也没理由专门来攻击你，一堆学习资料的电脑，有啥好看的。
但如果你是保密级别非常高的单位电脑，有商业价值，那最好不要关。考虑部分小伙伴会有些强迫症，不想让这种几乎用不到的安全，影响性能。所以这次下载集分享下win10和win11系统，关闭VBS方法。
具体步骤如下 1、打开开始菜单，在搜索框搜索“系统信息”，点击进入系统信息窗口。
2、找到“基于虚拟化的安全性”这一项，如果显示正在运行，说明VBS已开启。
(关闭VBS)
3、右键开始菜单，选择“终端管理员”，复制输入以下命令，按回车。
bcdedit /set hypervisorlaunchtype off
4、重启电脑后，再次进入“系统信息”窗口，你会发现，VBS已经顺利关闭。
本文来源于：关闭Win10和Win11系统VBS功能，可大幅提升游戏帧率-下载集 (xzji.com)https://www.xzji.com/news/12486.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d359ffa839f678a6b963579c83718329/" rel="bookmark">
			加快make编译速度的另一种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始之前，先供上大佬的加快编译速度的方法：
转载
上述方法中，个人感觉，普通人能用的，估计就加上-j参数了。
不过在我的项目中，我发现了另一种大佬没有提的方法，那就是在makefile中，为每个c文件指定好INCLUDE_PATH变量，然后在编译每个c文件时，只让make去该文件的INCLUDE_PATH中取找头文件，经过实际测试，使用这种方法编译，可以将编译时间从30分钟下降到8分钟，效果杠杆的。
我的项目是一个汽车域控制器的项目，大约有400多个c文件需要编译。在优化makefile之前，指定头文件查找路径的方式就是使用一个INCLUDE_PATH变量，将所有头文件的路径全部添加到这个变量中，然后make在编译每一个c文件时，都会在这个庞大的路径集合中取找当前c文件中包含的每个头文件，变量INCLUDE_PATH中的路径大约有上百个，一个c文件中包含的头文件，少则几个，多则几十个，这样找头文件找起来自然是很费时间的。
想到这一点后，我们对makefile进行了优化，事先生成每个c文件包含的头文件的的路径，这个路径是gcc生成的，是绝对最简化的，没有任何多余的路径。然后在编译每个c文件时，将对应的头文件路径文件包含进来，只让make在这些几个路径中找头文件。
后续有时间补充一个示例makefile，来作为示例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea069604f2564b01e57ed97c7e0e67b0/" rel="bookmark">
			CANOE CAPL编程采坑记录---capl中的函数中的变量，默认是静态局部变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个capl文件中，我需要写一个checksum校验的函数，用来在发送报文时给最后一个字节checksum字段赋值，函数大体如下：
byte Send_CheckSum(word msgId, byte data[], byte len) //data为数组，len为数组长度 { byte i, crc = 0; crc += msgId &amp; 0xff; crc += (msgId &gt;&gt; 8) &amp; 0xff; for(i=0; i&lt;len; i++) { crc += data[i]; } crc = ~crc; return crc; } 代码看起来没啥问题，但是实际发送报文的checksum总是错误的。而且我发现有两个奇怪的现象，一是只有第一帧报文的checksum是对的，后面的全是错误的；二是，就算报文前面的数据没变化，checksum也在变，哈哈哈。
最终我仔细翻看了介绍capl的博客后，才发现里面有介绍，capl中函数内部定义的变量默认是静态的，会保留上一次的值，如果不想用这个特性，必须要显式地初始化，例如在上述代码的第四行加上crc=0;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f3a91d8889de3c33db40e17d0d7a88/" rel="bookmark">
			Edge浏览器打开控制台后程序总是提示已在调试程序中暂停
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要如何解决 概要 当我们需要在网页中下载一些内容时，进入edge 开发者模式，此时会在上方提示“已在调试程序中暂停”，导致我们无法在原网页中进行操作。
如何解决 这其实是检测debug功能中断点被触发，只要关掉就好了，在元素-网络-源代码标签中选择源代码，
下方有个停用断点，只要将其点成激活状态就好：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e022f4b1683798d75bcd10515296c5f/" rel="bookmark">
			Vue基础与常用指令，Element基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vue快速入门 vue概述
Vue是一套构建用户界面的渐进式前端框架
只关注视图层，并且非常容易学习，还可以很方便的与其它库或已有项目整合
通过尽可能简单的API来实现响应数据的绑定和组合的视图组件
特点
易用：在有HTMLCSSJavaScript的基础上，快速上手。
灵活：简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。
性能：20kbmin+gzip运行大小、超快虚拟DOM、最省心的优化
快速入门
1.下载和引入vue.js文件
2.编写入门程序
视图：负责页面渲染，主要由HTML+CSS构成
脚本：负责业务数据模型（Model）以及数据的处理逻辑
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;快速入门&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 视图 --&gt; &lt;div id="div"&gt; {{msg}} &lt;/div&gt; &lt;/body&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script&gt; //脚本 new Vue({ el:"#div", data:{ msg:"Hello Vue" } }); &lt;/script&gt; &lt;/html&gt; Vue 核心对象：每一个 Vue 程序都是从一个 Vue 核心对象开始的
let vm = new Vue({ 选项列表; }); 选项列表
el选项：用于接收获取到页面中的元素。(根据常用选择器获取)
data选项：用于保存当前Vue对象中的数据。在视图中声明的变量需要在此处赋值
methods选项：用于定义方法。方法可以直接通过对象名调用，this代表当前Vue对象 数据绑定
在视图部分获取脚本部分的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e022f4b1683798d75bcd10515296c5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80498ca3d7c0a7cf1997e68db538f88c/" rel="bookmark">
			AJAX与JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.AJAX 1.AJAX概述 AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML
本身不是一种新技术，而是多个技术综合。用于快速创建动态网页的技术
一般的网页如果需要更新内容，必需重新加载个页面。
而 Ajax通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页 面的情况下，对网页的部分内容进行局部更新。
同步：服务器端在处理过程中，无法进行其他操作。
异步：服务器端在处理过程中，可以进行其他操作
总结：异步的处理网络请求的工具，可以实现局部刷新
2.原生JS实现AJAX 与详解 package Servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet("/userServlet") public class UserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应的乱码 req.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); //1.获取请求参数 String username = req.getParameter("username"); //模拟服务器处理请求需要5秒钟 /*try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }*/ //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80498ca3d7c0a7cf1997e68db538f88c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16b4aa6ea33872bea0e545b8a574cf24/" rel="bookmark">
			Android 特权应用 privapp-permissions 权限解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特权应用 官网说明
特权应用是位于系统映像某个分区上 priv-app 目录下的应用，如 system/priv-app/ 。
特权应用
相比安装在 system/app/ 目录的应用，具有更高的权限。基本都是系统预装，不可卸载。可以不是系统签名。 源码预制 源码下预制到 priv 分区，根据编译规则配置即可。
Android.mk 配置 LOCAL_PRIVILEGED_MODULE := true ，如
LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := LuoDemo LOCAL_MULTILIB := 32 LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_CERTIFICATE := platform LOCAL_PRIVILEGED_MODULE := true LOCAL_SRC_FILES := $(LOCAL_MODULE)$(COMMON_ANDROID_PACKAGE_SUFFIX) include $(BUILD_PREBUILT) include $(call all-makefiles-under,$(LOCAL_PATH)) Android.bp 配置 privileged: true
android_app { name: "LuoDemo", srcs: ["src/**/*.java"], certificate: "platform", privileged: true, platform_apis: true, static_libs: [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16b4aa6ea33872bea0e545b8a574cf24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4121deba3e3f44218416b8fad93d3614/" rel="bookmark">
			sklearn-6算法链与管道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思想类似于pipeline，将多个处理步骤连接起来。
看个例子，如果用MinMaxScaler和训练模型，需要反复执行fit和tranform方法，很繁琐，然后还要网格搜索，交叉验证
1 预处理进行参数选择 对于放缩的数据，一定要最先开始放缩，否则会导致数据放缩不一致，比如SVM+网格交叉，网格需要放缩数据，数据放缩需要带上测试集，否则性能下降，准确率打折扣
2 构造管道 注意 管道每次会调用scaler的fit方法，注意，可以对同一个scaler调多次fit，但不可以用两个或多个scaler单独放缩数据！！！
只需要几行代码，很简便
def test_chain_basic(self): xtr, xte, ytr, yte = train_test_split(self.cancer.data, self.cancer.target, random_state=0) pipe = Pipeline([('scaler', MinMaxScaler()), ('svm', SVC())]).fit(xtr, ytr) print(f'predict score: {pipe.score(xte, yte)}') 注意，给pipeline传参是个列表，列表项是长度为2的元组，元组第一个是字串，自定义，类似于一个名字，元组第二个参数是模型对象
3 网格搜索中使用管道 用法
1类似于上一节的scaler+监督模型的用法
2有个注意点是网格搜索需要给训练的模型传参，需要改下给grid对象传参字典的键名
3注意网格搜索是pipe作为参数传给GridSearchCV，二补数把pipe作为参数传给pipe
例子
def test_chain_scale_train_grid(self): xtr, xte, ytr, yte = train_test_split(self.cancer.data, self.cancer.target, random_state=0) pipe = Pipeline([('scaler', MinMaxScaler()), ('svm', SVC())]).fit(xtr, ytr) print(f'predict score: {pipe.score(xte, yte)}') params_grid = {'svm__C': [0.001, 0.01, 0.1, 1, 10, 100], 'svm__gamma': [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4121deba3e3f44218416b8fad93d3614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0411e2c6a22ecb9c9dcf4a4b522c5879/" rel="bookmark">
			es : java 查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. POM 配置 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt; &lt;/dependency&gt; 2. 建立ES集群连接 RestHighLevelClient client = new RestHighLevelClient( RestClient.builder( new HttpHost(IP, PORT, "http"))); 同样，如果我们要连接集群中多个ES节点时，只需要在RestClient 的 builder 方法中多添加几个HttpPost对象即可 String ipPort = "10.xx:9200,10.xx:9200,10.xx:9200"; String[] ipPortArry = ipPort.split(","); List&lt;HttpHost&gt; httpHostsList = new ArrayList(); for(String ips : ipPortArry){ String[] ipArray = ips.split(":"); httpHostsList.add(new HttpHost(ipArray[0], Integer.parseInt(ipArray[1]), "http")); } RestHighLevelClient client = new RestHighLevelClient( RestClient.builder(httpHostsList.toArray(new HttpHost[httpHostsList.size()]))); 补充： Java配置多个ES节点时，请求的时候会随机选一个节点作为协调节点负责分发请求和处理结果，所以Java链接ES节点数量的多少，不会影响到Java请求ES查询结果的速度，只是其中某个节点宕机时，其他节点可以保证正常的查询和操作。 ES 端口9200与9300的区别： 9200作为Http协议，主要用于外部通讯 9300作为Tcp协议，jar之间就是通过tcp协议通讯 ES集群之间是通过9300进行通讯 3. 简单的查询并获取查询结果 RestHighLevelClient client = new RestHighLevelClient( RestClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0411e2c6a22ecb9c9dcf4a4b522c5879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995d58481f0b8991f97d7ad002dffded/" rel="bookmark">
			Jmeter —— 常用的几种断言方法（基本用法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用JMeter进行性能测试或者接口自动化测试工作中，经常会用到的一个功能，就是断言，断言相当于检查点，它是用来判断系统返回的响应结果是否正确，以此帮我们判断测试是否通过，本文 主要介绍几种常用的断言：响应断言、JSON断言、BeanShell 断言 一、响应断言 1. 响应断言是最常用的一种断言方法，它可以对各种返回类型的结果进行断言，比如Test、html、application/json等
2. 在需要进行断言的Sample，点击右键》添加》断言》响应断言
3. Apply to选项默认即可，Main sample only(仅作用于父节点取样器)
4. 测试字段常用的有响应文本（对响应结果进行断言）、响应头（对响应头文件进行断言）
5. 模式匹配规则常用有包括（响应结果包括断言的内容），相等（响应结果和断言结果相同）
6. 测试模式可以添加你需要断言的部分，如果是包括，就可以添加多个
7. 执行测试，断言通过则显示绿色
8. 把断言改成响应结果不存在的字段，执行结果，显示红色，断言结果显示系统响应结果不包含“测试断言”字段
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：110685036 二、JSON断言 1. JSON断言也是测试工作中经常用到的一种断言方法，它只能针对响应结果是applicaton/json格式的请求进行断言
2. 在需要进行断言的Sample，点击右键》添加》断言》JSON断言
3. 我们使用json断言，一般是断言某个字段值是否返回的是我们需要的，所以需要写JSON PATH（不会写的看本人另外一篇文章有介绍如何写），下图使用正则模式匹配返回的结果包含40就认为响应结果满足要求，断言配置和响应结果如下所示：
4. 下面展示断言结果为常量时，如何进行断言设置，如下图所示
三、BeanShell断言 1. BeanShell断言支持各种开发语言，本文介绍使用java编写断言，使用BeanShell断言的好处是可以自由发挥，比如当断言失败，提示预期结果、实际结果，或者失败时把结果输出到日志
2. 在需要进行断言的Sample，点击右键》添加》断言》BeanShell断言
3. 如果使用包含匹配，只需要修改预期结果即可，预期结果需要写在双引号之间，中间的双引号需要添加\转义，如下：
String response = ""; String Str = "{\"errNo\":\"403\""; //预期结果，需要校验的字段 response = prev.getResponseDataAsString(); //获取当前请求响应结果 if(response == ""){ Failure = true; FailureMessage = "系统无响应，获取不到响应数据！"; //对比数据库内容和响应内容，私用euqals方法判断是否一致 } else if(response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995d58481f0b8991f97d7ad002dffded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e019d4dd7a5b53e790406731feb621aa/" rel="bookmark">
			【Matlab】二维绘图函数汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文用于汇总 Matlab 二维绘图函数。plot() 函数是 Matlab 中最常用的绘图函数，用于在平面直角坐标系中绘制直线或曲线。subplot() 函数用于创建绘图网格，并指定当前绘图的位置，在调用绘图函数之前使用。fplot() 函数用于符号绘图或者参数方程绘图。polarplot() 函数用于极坐标绘图。
目录
1. plot()
2. subplot()
3. fplot()
4. polarplot()
1. plot() plot() 函数是 Matlab 中最常用的绘图函数，用于在平面直角坐标系中绘制直线或曲线。
用法：
plot(X,Y)
plot(X,Y,LineSpec)
plot(X1,Y1, ... ,Xn,Yn)
说明：
plot(X,Y)
· 如果 X 和 Y 都是向量，则它们的长度必须相同。plot() 函数绘制一条曲线，曲线上点的坐标由 X 与 Y 对应位置的元素决定。
· 如果 X 和 Y 都是矩阵，则它们的大小必须相同。plot() 函数绘制多条曲线，每条曲线上点的坐标由 X 与 Y 列方向上对应位置的元素决定。
plot(X,Y,LineSpec)
· 绘制一条曲线，LineSpec 是一个字符向量或字符串，用于指定曲线的线型、标记或颜色，表示线型、标记或颜色的字符可以按任意顺序组合。
plot(X1,Y1, ... , Xn,Yn)
· 在同一坐标轴中绘制多条曲线，X1,Y1, ... , Xn,Yn 是长度相同的向量。
示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e019d4dd7a5b53e790406731feb621aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a2c3e1fda5812613358bb782e6fda2/" rel="bookmark">
			1&#43;（-1）=？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因是看到了下面这个问题：
1+(-1) = 0001 + 1001 = 怎么算
计算机计算方式 源码-&gt;反码（源码符号位不变其他取反）-&gt;补码（反码+1）-&gt;得到结果的补码-&gt;结果的反码(补码-1)-&gt;结果的源码（反码符号位不变其他位取反）
正常开始算（计算机一般用反码进行计算）：
源: 0001 +1001 反：0001+1110 补码：0001+1111 = 10000
最高位1溢出舍弃
0的源码反码补码都是0
所以结果为 0
扩展延伸：
根据冯·诺依曼提出的经典计算机体系结构框架。一台计算机由运算器，控制器，存储器，输入和输出设备构成。其中运算器，只有加法运算器，没有减法运算器。所以如果我们要计算1-1，不能直接算，需要把1-1变成1+（-1）来计算。这要就需要知道一个反数如何表达。符号位就依此需求出现了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1736273df7b2253e886c3d6f7801ae/" rel="bookmark">
			Chrome浏览器免费广告拦截器插件 —— Adblock
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：我们在浏览网页的过程中经常会有看到一些广告，这些广告不仅影响正常浏览，甚至会遮挡主要内容，给用户造成极大困扰。今天分享一去除广告或者指定元素的优秀插件——Adblock
屏蔽广告前：页面中总是会出现一些广告
屏蔽后：页面上带关闭按钮的广告都给屏蔽了
安装步骤：
1.需要打开 Chrome 应用商店 2.搜索 Adblock ，便可搜索到
3.点击添加至Chrome即可
4.添加扩展程序即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc12f9e61d47011f061767e9cb42253/" rel="bookmark">
			echars 设置滚动条演示，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dataZoom: [ // 滑动条 { zoomLock:true, xAxisIndex: 0, // 这里是从X轴的0刻度开始 type: "slider", // 这个 dataZoom 组件是 slider 型 dataZoom 组件 startValue: 0, // 从头开始。 endValue: 20, // 一次性展示几个。 // fillerColor: "#023661", // 选中范围的填充颜色 // borderColor: "#023661", // 边框颜色。 height: 21, //组件高度 left: 0, //左边的距离 right: 0, //右边的距离 bottom: 0, //右边的距离 handleStyle: { borderColor: "#cacaca", borderWidth: "5", shadowBlur: 2, background: "#ddd", shadowColor: "#ddd" }, backgroundColor: "#ddd", //两边未选中的滑动条区域的颜色 showDataShadow: false, //是否显示数据阴影 默认auto showDetail: false, //即拖拽时候是否显示详细数值信息 默认true moveHandleSize: 0 //两侧滑块宽度 }, { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc12f9e61d47011f061767e9cb42253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837387519cff673ac88b6d158cfb8046/" rel="bookmark">
			k8s 1.28版本二进制安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 二进制安装Kubernetes（k8s）v1.28.0介绍1.环境1.0.环境准备1.Linux网卡没有eth0显示ens33或者其它（以ens33为例）方法一：修改网卡配置方法二：重新安装机器(本文为虚拟机) 2.克隆的虚拟机，修改UUID，保证k8s集群每台机器UUID唯一 1.1.k8s基础系统环境配置1.配置IP2.设置主机名3.配置yum源4.安装一些必备工具4.1 下载离线所需文件(可选)CentOS7CentOS8Ubuntu 下载包和依赖 5.选择性下载需要工具(可选)6.关闭防火墙7.关闭SELinux8.关闭交换分区9.网络配置（俩种方式二选一）10.进行时间同步11.配置ulimit12.配置免密登录13.添加启用源14.升级内核至4.18版本以上15.安装ipvsadm16.修改内核参数17.所有节点配置hosts本地解析 2.k8s基本组件安装2.1.安装Containerd作为Runtime （推荐）2.1.1 配置Containerd所需的模块2.1.2 加载模块2.1.3 配置Containerd所需的内核2.1.4 创建Containerd的配置文件2.1.5 启动并设置为开机启动2.1.6 配置crictl客户端连接的运行时位置 2.2 安装docker作为Runtime （不推荐）2.2.1 解压docker程序2.2.2 创建containerd的service文件2.2.3 准备docker的service文件2.2.4 准备docker的socket文件2.2.5 配置加速器2.2.6 启动docker2.2.7 解压cri-docker2.2.8 写入启动cri-docker配置文件2.2.9 写入cri-docker的socket配置文件2.2.10 启动cri-docker 2.3.k8s与etcd下载及安装（仅在master01操作）2.3.1 解压k8s安装包2.3.2 查看版本2.3.3 将组件发送至其他k8s节点 2.3 创建证书相关文件(获取打包后文件的tar包) 3.相关证书生成3.1.生成etcd证书3.1.1 所有master节点创建证书存放目录3.1.2 master01节点生成etcd证书3.1.3 将证书复制到其他节点 3.2.生成k8s相关证书3.2.1 所有k8s节点(master+slave节点)创建证书存放目录3.2.2 master01节点生成k8s证书3.2.3 master01节点生成apiserver聚合证书3.2.4 master01节点生成controller-manage的证书3.2.5 master01节点生成kube-scheduler的证书3.2.6 master01节点生成admin的证书配置3.2.7 master01节点创建kube-proxy证书3.2.8 master01节点创建ServiceAccount Key ——secret3.2.9 将证书发送到其他master节点3.2.10 查看证书 4.k8s系统组件配置4.1.etcd配置4.1.1 master01配置4.1.2 master02配置4.1.3 master03配置 4.2.创建service4.2.1 创建etcd.service并启动4.2.2 创建etcd证书目录4.2.3 查看etcd状态 5.高可用配置5.1 NGINX高可用方案 (推荐)5.1.1 master01节点进行编译5.1.2 写入启动配置 5.2 keepalived和haproxy 高可用方案 (不推荐)5.2.1 安装keepalived和haproxy服务5.2.2 修改haproxy配置文件（配置文件一样）5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837387519cff673ac88b6d158cfb8046/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/43/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>