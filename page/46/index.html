<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd34aa3d1e6dd9d35e1d3f5308046ee/" rel="bookmark">
			重磅！2024泰晤士世界大学排名发布！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：硕博情报局
编辑：研路科研人Sci
“研路漫漫，伴你同行”
北京时间2023年9月27日，全球高等教育研究机构泰晤士发布了2024年世界大学排名。
作为留学风向标之一的泰晤士，此次排行榜的绩效指标分为5个方面，分别为：教学、研究环境、研究质量、国际展望和产业。
整体排名情况来看，牛津大学大学位列榜首，斯坦福排在第二，麻省理工和哈佛大学紧跟其后，剑桥从第二滑到了第五。
普林斯顿排在第六，加州理工大学位列第七，帝国理工排在第八名，加州伯克利则在第九名，耶鲁大学是第10名。
芝加哥大学再次掉出美国前十阵容...（真·回不去了）
在本次排名中，清华大学亚洲排名第一，也是中国大陆高校表现最好的高校(第12位)，北京大学紧随其后，位列世界第14位，再次力压宾大、哥大、UCLA、康奈尔大学等一众美国名校。
接下来我们来看看前200的排名榜单吧！ 2023年THE世界大学排名Top200
对比QS、US News、ARWU
泰晤士的排名规则有何不同
众所周知，全球四大高校排行榜分别是：QS世界大学排名、US News世界大学排名、THE世界大学排名、ARWU世界大学学术排名，不同排名的指标，即排名依据自然不同。
今年6月，QS率先发布了2023年世界大学排名，美国方面继续强势，MIT继续创造历史，连续12年稳坐QS综排霸主，地位无人能敌。
哈佛大学排名第4，斯坦福紧跟其后，加州伯克利和康奈尔太给力了，前者从去年的27名冲到Top10，后者直接从20名前进至12名！
加州理工和耶鲁大学并列15名，公立大校——加州洛杉矶终于冲进Top30！
剑桥大学依旧稳坐英国第一宝座，它的身后分别是排在第三的牛津大学、第六的帝国理工和第九的伦敦大学学院。
曼彻斯特大学跌出前30，排在了第32名（心碎2024）
澳洲大学排名震惊主页君！集体携手冲冲冲！
曾经的新南威尔士大学排名在40名开外，如今摇身一变，和悉尼大学并列冲进Top20！
墨尔本大学从33名跑到了第14名！
狂欢吧！澳洲留学生们！母校比我还争气系列。
今年亚洲地区的排名也很有看头。
新加坡国立大学居然排在了第八名！
北大和普林斯顿并列17名，清华大学在第25名。
除此之外，上个月，软科也正式发布了“世界大学学术排名”，又是美国大学霸榜的一年！
Top100中，美国上榜了38所高校，占据了差不多40%的名额。
在今年的排名中，哈佛大学仍然稳坐头把交椅，连续21年蝉联全球第一，斯坦福大学和麻省理工大学紧随其后，继续名列二到三位。
加州伯克利排在了第五名，普林斯顿紧跟其后，第八、第九、第十分别是哥大、加州理工和芝加哥大学，而耶鲁则被挤到了第11名。
而软科的排名依据，几乎都围绕学术科研这一项来进行评估。就比如非常看重校友、教职员工获得诺奖的人数，以及在 Nature 和 Science 期刊上发表的文章数量等等。
至于US News的世界大学排名，按照往年的时间，估计得再等等了。
写在最后
主页君向来认为，排名不能说明一切，第1名和第10名不一定就有很大差别。
数字的确可以体现一些问题，但并不是选校的唯一依据，学校的教学质量、学习氛围以及校园环境，学校提倡的价值观，对国际生的态度等，都是需要我们仔细思考、认真考量的。
参考排名，但不要被排名所绑架，主页君真心希望各位小伙伴们选择一所最适合你的好学校，度过你生命里美好且重要的四年时光。
版权声明
本文来源：除特别注明原创授权转载文章外，其他文章均为转载，版权归原作者或平台所有，仅用于学术分享。如有侵权请联系小编删除。编辑：研路科研人Sci
哎呦，不错哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e33ed87579c4c6ddcd0a1cd4f8dabdc/" rel="bookmark">
			openvpn搭建与简单配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，openvpn概念 OpenVPN是一个开源的虚拟专用网络（VPN）解决方案，可用于建立安全的远程连接。它通过在公共网络上创建加密的隧道来保护数据传输的安全性和隐私性。下面是一些与OpenVPN相关的概念：
虚拟专用网络（VPN）：VPN是一种通过公共网络（如互联网）在不同位置的计算机之间创建私密连接的技术。它使得远程用户可以安全地访问私有网络资源，并且可以加密数据以保护隐私。
服务器和客户端：在OpenVPN中，有一个OpenVPN服务器和一个或多个OpenVPN客户端。服务器负责接收和处理客户端的连接请求，而客户端则连接到服务器以获得安全的网络访问。
配置文件：OpenVPN使用配置文件来定义服务器和客户端的行为。配置文件包含了各种参数和选项，如连接协议、加密算法、证书和密钥的位置等。
证书和密钥：OpenVPN使用证书和密钥来进行身份验证和加密通信。服务器和客户端都需要拥有自己的证书和密钥，以确保只有合法的用户可以建立连接并加密数据传输。
加密和身份验证：OpenVPN使用不同的加密算法来保护数据的安全性，如AES、DES、SHA等。此外，它还支持使用证书和用户名/密码进行身份验证，以确保只有授权用户可以连接到服务器。
隧道：OpenVPN通过在公共网络上创建加密的隧道来传输数据。这个隧道使得数据在互联网上的传输过程中变得不可见和不可读，从而保护了数据的安全性。
通过使用OpenVPN，用户可以在不安全的公共网络上建立一个安全的私有网络连接。无论是远程办公、远程访问公司资源，还是保护个人隐私，OpenVPN提供了一个可靠和灵活的解决方案。
二，openvpn安装配置 安装和配置OpenVPN的详细流程如下：
安装OpenVPN软件包：
sudo yum install epel-release -y sudo yum install openvpn easy-rsa -y 创建OpenVPN配置文件：
sudo cp /usr/share/doc/openvpn-x.x.x/sample/sample-config-files/server.conf /etc/openvpn/ 生成Easy-RSA CA（证书颁发机构）：
sudo cp -r /usr/share/easy-rsa/ /etc/openvpn/ cd /etc/openvpn/easy-rsa/3.x/ 编辑vars文件，设置必要的变量：
sudo nano vars 在文件底部找到以下行并进行修改：
export KEY_COUNTRY="US" export KEY_PROVINCE="CA" export KEY_CITY="SanFrancisco" export KEY_ORG="MyOrganization" export KEY_EMAIL="admin@example.com" export KEY_OU="MyOrganizationalUnit" 保存并关闭文件。
初始化证书颁发机构：
sudo ./easyrsa init-pki sudo ./easyrsa build-ca 生成服务器证书和密钥：
sudo ./easyrsa gen-req server nopass sudo .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e33ed87579c4c6ddcd0a1cd4f8dabdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802125395813e0bec35472d0403ab94e/" rel="bookmark">
			Jupyter Notebook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Jupyter Notebook启动文件 （1）安装好Anaconda后，打开Anaconda Prompt，输入jupyter notebook，浏览器就会自行打开Jupyter Notebook。
（2）每次输入命令行太麻烦，我们可以建一个.bat脚本文件，新建一个记事本，输入jupyter notebook，另存为.bat文件。双击运行.bat文件即可启动Jupyter notebook。
（3）看着不舒服，搞个好看的图标。右击.bat文件，发送到桌面快捷方式。
（5）右击，点击“属性-快捷方式-更改图标”，网上找到自己喜欢的图片，对图片抠图，转为ico图标。将快捷方式图标更换为ico图标。
2、设置Jupyter Notebook工作目录 （1）打开Anaconda Prompt，输入jupyter notebook --generate-config，找到jupyter_notebook_config.py文件的位置。
（2）记事本打开jupyter_notebook_config.py文件，点击“编辑-查找”，输入NotebookApp.notebook_dir找到所在行，删除前面的#，在单引号内输入Jupyter Notebook工作位置，例如，我是将Jupyter Notebook的文件存放在G:\jupyterproj。
修改后保存
（3）开始菜单找到Jupyter Notebook，点击鼠标右键，点击“更多-打开文件位置”。右击Jupyter Notebook快捷方式，点击属性。删除"%USERPROFILE%/"，点击确定。之后Jupyter Notebook都工作在G:\jupyterproj目录下。
3、Jupyter Notebook找不到conda配置的环境 打开Jupyter Notebook后，发现右上角说没内核或者找不到conda配置的环境。在Anaconda Prompt 中，输入anaconda activate +环境名，进入配置的环境。输入conda install ipykernel。再输入python -m ipykernel install --name pytorch（环境名）。然后打开Jupyter Notebook，就可以看到pytorch环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125fd2000df7afdd85b9eb77d7f0192a/" rel="bookmark">
			微信小程序开发：实现地图导航功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
如今，地图导航成为了现代人日常出行不可或缺的工具，而随着移动互联网的发展，地图导航也已经成为了手机应用的核心功能之一。本文将围绕微信小程序开发，详细介绍地图导航功能的实现。
二、微信小程序的基础知识
微信小程序是一种轻量级应用，仅需基础的HTML、CSS、JavaScript编程知识即可进行开发。由于微信小程序不需要下载安装，可以直接在微信客户端中使用，因此具有无需安装、无需升级、快速开发等特点。微信小程序的开发语言主要有两种：WXML和JavaScript，其中WXML是一种类似于HTML的标记语言，用于描述页面的结构，而JavaScript则用于描述页面的逻辑。
三、实现地图导航功能的前置准备
1.获取地理位置
开发地图导航功能的前置条件是获取用户的地理位置。在微信小程序中，可以通过wx.getLocation()方法获取用户的地理位置，该方法的调用方式如下：
wx.getLocation({ type: 'gcj02', //返回可以用于wx.openLocation的经纬度 success: function(res) { var latitude = res.latitude var longitude = res.longitude var speed = res.speed var accuracy = res.accuracy } }) 2.引入地图API
实现微信小程序中的地图导航功能，需要引入相关的地图API，如腾讯地图API、高德地图API等。以腾讯地图API为例，需要在微信小程序的app.json文件中进行如下配置：
{ "pages": [ "pages/index/index" ], "window": { "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "Demo", "navigationBarTextStyle": "black" }, "permission": { "scope.userLocation": { "desc": "你的位置信息将用于小程序位置接口的效果展示" } }, "plugins": { "myPlugin": { "version": "1.0.0", "provider": "wxidxxxxxxxxxxxxxxxx" } }, "usingComponents": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125fd2000df7afdd85b9eb77d7f0192a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64b172da7bddbcfe18e2ef6b15e3385/" rel="bookmark">
			Python与PDF文件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一种高级编程语言，主要用于数据分析、机器学习、图像处理等领域。在PDF文件处理方面，Python有许多强大的库和工具，可以方便地对PDF文件进行读取、写入、编辑、转换等操作。本文将详细介绍Python在PDF文件处理方面的应用。
一、Python中常用的PDF文件处理库
PyPDF2库 PyPDF2是一个纯Python库，用于操作PDF文件。它能够读取、分割、合并、水印以及加密和解密PDF文件。使用PyPDF2库，我们可以轻松地检索、添加、删除和修改PDF文件的元数据、书签和链接等。此外，它还支持旋转和缩放PDF页面，可以从PDF文件中提取文本和图片，并可以将PDF文件转换为图像格式。
安装方式：
pip install PyPDF2 使用方式：
import PyPDF2 # 打开PDF文件 pdf_file = open('example.pdf', 'rb') # 创建一个PDF阅读器对象 pdf_reader = PyPDF2.PdfFileReader(pdf_file) # 获取PDF文件总页数 num_pages = pdf_reader.getNumPages() # 获取PDF文件第一页 first_page = pdf_reader.getPage(0) # 从PDF文件第一页提取文本 text = first_page.extractText() # 关闭PDF文件 pdf_file.close() pdfrw库 pdfrw库是一个Python PDF库，用于读取、写入和操作PDF文件中的内容。它支持创建、合并、拆分、旋转和缩放PDF文件。pdfrw库还可以帮助我们修改PDF文件中的表单字段、注释和元数据等。此外，pdfrw库还允许我们将PDF文件中的某些部分以文本或图像格式提取出来。
安装方式：
pip install pdfrw 使用方式：
import pdfrw # 打开PDF文件 pdf_file = open('example.pdf', 'rb') # 读取PDF文件中的内容 pdf_content = pdfrw.PdfReader(pdf_file) # 修改PDF文件中的某些内容 pdf_content.Info.Title = 'New Title' # 保存修改后的PDF文件 pdfrw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a64b172da7bddbcfe18e2ef6b15e3385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf93583d5dbb6fb39d90bd66ec12781/" rel="bookmark">
			Anaconda配置GPU版本的pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA11.6，cuDNN8.6.0，conda配置了python3.9的环境，pytorch=1.12.0
1、查看电脑是否有GPU （1）搜索计算机管理。点击“设备管理器-显卡适配器”，就可看到是否有GPU。
如下图，显卡是NVIDIA显卡，才可以安装GPU版本的pytorch。
显卡是AMD显卡，只能安装CPU版本的pytorch。
2 、查看是否安装cuda （1）按下win+R，输入cmd进入命令提示符。输入nvcc -V，查看是否安装cuda。目前尚未安装cuda。
3、 Pytorch，CUDA及python对应的版本 以下两张截图来自 Pytorch，CUDA及python对应的版本
4、 安装并配置cuda 4.1查看NVIDA兼容的CUDA版本 （1）点击桌面右下角的“^”，进入NVIDA控制面板。（没有的话，可在）
4.2 安装CUDA （1）我的安装版本是CUDA11.6，conda配置了python3.9的环境，pytorch=1.12.1。
CUDA官方下载地址
（2）win10选10，win11选11.
（3）双击.exe文件，选择文件存放位置，等待。
（4）同意继续。
（6）自定义，下一步。
（7）下一步。
（8）在之前的安装目录D:\CUDA中新建文件夹，目录为：
D:\CUDA\v11.6
D:\CUDA\Samples
选择安装位置，如下图，下一步。
（9）勾选，next。
（10）下一步，关闭。
4.3 配置CUDA环境变量 （1）搜索“编辑系统环境变量”，打开。
（2）高级-环境变量。
（3）CUDA_PATH和CUDA_PATH_V11_6这两个系统变量一般会自动生成，值为D:\CUDA\v11.6（没有的话自己添加）。NVCUDASAMPLES_ROOT和NVCUDASAMPLES11_6_ROOT需要自己添加，点击新建，输入变量名和值，其值为D:\CUDA\Samples。（这里的值就是你之前自己设置的安装位置）
4.4 验证CUDA是否安装成功 cmd中输入nvcc -V，出现下图即安装成功。
5、安装并配置cuDNN 5.1 安装cuDNN cuDNN 历史版本（1）cuDNN 历史版本可以看到所有版本的cuDNN，及其与CUDA版本对应关系。
（2）我选择安装cuDNN8.6.0版本，点击Windows 本地安装程序（Zip）下载文件。
（3）解压后，复制文件中的bin，include，lib三个文件。
（4）粘贴到D:\CUDA\v11.6中，覆盖三个同样名字的文件。
5.2 配置cuDNN系统变量 （1）搜索“编辑系统环境变量”，打开。点击“高级-环境变量”，在系统变量中点击Path。
（2）点击“新建-浏览”，将以下路径添加进来。
D:\CUDA\v11.6\bin
D:\CUDA\v11.6\include
D:\CUDA\v11.6\lib
D:\CUDA\v11.6\libnvvp
5.3 验证cuDNN是否安装成功 （1）在D:\CUDA\v11.6\extras\demo_suite路径下启动终端。
（2）输入.\deviceQuery.exe，运行deviceQuery程序，出现以下画面。
（3）输入.\bandwidthTest.exe，运行bandwidthTest程序，出现以下画面，cuDNN安装成功。
6、Anaconda配置的环境下安装GPU版本pytorch 之前，在这篇博客中，我们已经利用anaconda创建了名为pytorch的conda环境。
（1）在Previous Pytorch Versions查看相应的conda版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf93583d5dbb6fb39d90bd66ec12781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e496525dbdbed88e22a19f66284d8f3/" rel="bookmark">
			VScode配置Jupyter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 安装步骤 1、插件安装
2、更改pip加速源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 参考：vscode python配置pip源
​​​​​​​ 【Python学习】Day-00 Python安装、VScode安装、pip命令、镜像源配置、虚拟环境
3、建立虚拟环境
4、安装ipykernel
5、设置Python解释器
4、测试
print("Do you want to install the recommended 'Python' extension from Microsoft for the Python language?") 参考：python venv pip和vscode+Jupyter编码环境准备 ​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707c279d156611c5d146122d891cc267/" rel="bookmark">
			mapshaper在线的地图编辑器命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mapshaper Mapshaper是一个强大的地图数据处理工具，它可以将复杂的地理数据转换成各种形状和颜色，以可视化地图的形式呈现出来。
Mapshaper的功能非常丰富，主要包括地图编辑、属性编辑、裁剪、擦除、合并、过滤等。具体来说，Mapshaper可以用来进行以下操作：
地图编辑：Mapshaper提供了多种地图编辑功能，如裁剪、融合、擦除、简化、连接、合并等，用户可以利用这些功能对地图进行修改和完善。例如，使用“clip”命令可以将地图中的某个区域裁剪出来，使用“dissolve”命令可以将多个多边形融合成一个多边形，使用“erase”命令可以擦除地图中的某个区域，使用“simplify”命令可以简化地图中的复杂部分，使地图更加简洁明了。属性编辑：Mapshaper可以管理地图的属性信息，包括名称、描述、坐标等。用户可以利用Mapshaper的属性编辑功能来添加、修改或删除地图的属性信息。数据转换：Mapshaper支持多种数据格式的输入和输出，如shapefile、GeoJSON、CSV等。用户可以利用Mapshaper的数据转换功能，将不同格式的数据转换成自己需要的格式。投影信息：Mapshaper可以获取和设置地图的投影信息，帮助用户更好地了解地图数据的坐标系和投影方式。版本信息：Mapshaper还可以获取和处理地图数据集的版本信息。 除了以上功能，Mapshaper还具有以下特点：
在线编辑：Mapshaper是一个在线工具，用户可以直接在浏览器中打开并编辑地图数据，无需下载任何软件。交互式界面：Mapshaper具有直观的交互式界面，用户可以轻松上手并快速掌握各种操作。支持大规模数据：Mapshaper可以处理大规模的地图数据集，并提供了高效的计算和渲染方法。开放式API：Mapshaper提供了开放式的API，允许用户根据自己的需求定制和扩展功能。数据安全保障：Mapshaper注重用户数据的安全性，采用了多种加密和安全措施来保护用户的数据。 总的来说，Mapshaper是一个功能强大、使用方便、安全可靠的地图数据处理工具，适用于各种需要处理和可视化地图数据的场景。
其命令可以根据功能大致分为三类：编辑命令、信息类命令以及其他常用命令。
编辑命令： -clip &lt;裁剪&gt;: 移除裁剪范围外的要素或部分要素。-cluster &lt;聚类&gt;: 将多边形分成简洁的聚簇组。-dissolve &lt;合并&gt;: 合并多边形或点要素。-each: 利用js表达式创建、更新或删除数据项。-erase &lt;擦除&gt;: 移除落在多边形范围内的要素或部分要素。-explode &lt;打散&gt;: 将图层中的每个多部件要素打散成几个独立部分的要素。-filter &lt;过滤要素&gt;: 通过条件过滤掉不满足条件的要素。-filter-fields &lt;过滤字段&gt;: 删除属性表中的字段（可指定保留的字段）。-filter-islands &lt;过滤孤岛/环&gt;: 移除小的独立的环状多边形/孤岛。-filter-silvers &lt;过滤面积&gt;: 通过面积过滤掉多边形小碎片。-graticule &lt;格网&gt;: 创建经度为0度、覆盖世界的网格图层。-linerlines &lt;共享边界&gt;: 创建由共享边界构成的线状图层（无属性）。-join &lt;连接&gt;: 将源图层或文件的属性数据连接到目标图层。-lines &lt;边界&gt;: 将多边形转成有拓扑的边界。-merge-layers &lt;融合&gt;: 将几个图层的多个要素融合到一个图层中。-point-grid: 创建矩形网格点。-points &lt;点要素&gt;: 从多边形或属性表创建点要素图层。-proj &lt;投影&gt;: 利用proj4字符串或别名投影数据集。-rename-fields: 重命名数据域。-rename-layers: 重命名图层。-simplify &lt;简化&gt;: 利用道格拉斯或其他两种方法对数据进行简化。-sort &lt;排序&gt;: 利用js表达式对要素进行排序。-split &lt;拆分&gt;: 基于属性值将目标层的数据拆分到多个输出层中，如果没有指定数据域，每个要素都将成为独立的图层。-slpit-on-grid &lt;切块&gt;: 指定行列数将要素分割成独立的图层。-subdivide: 二维图形分割为几个部分。-svg-style: 为svg格式输出和在web UI中的展现添加通用svg样式属性。-target: 设置默认目标图层。-uniq &lt;唯一化&gt;: 删除与前面要素id重复的要素。 信息类命令: call：利用js表达式计算并展现数据表的基本描述性统计结果。 其他常用命令:
注：这部分命令可用来进行文件和地图的相关操作，例如打开和保存文件、导出地图等，详情可查看Mapshaper的官方文档。 在使用Mapshaper的命令时，需要注意命令的参数和使用方法，以确保能正确执行命令并获得预期的结果。
项目工具 标准的geojson文件；mapshaper plus在线工具；geojson.io在线工具； dissolve合并步骤 导出乡镇geojson文件 需要合并的乡镇数据换成统一的名称 将“name”字段改为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707c279d156611c5d146122d891cc267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52289f363892c9020f6daba973b702fd/" rel="bookmark">
			大并发小号平台（AXB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用opensips开发通过控制信令的方式完成AXB绑定解绑关系。
2、采用mysql+redis组合让绑定解绑速度更快。
3、使用自定义编辑的方式可视化编写接口参数。
4、落地管理，对接管理。
性能测试描述：8核心16G生产环境测试3万并发，16核心32G压力测试5万并发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5cd19f8eb471f166137c0bf8f6c6449/" rel="bookmark">
			【LLM】Windows10环境部署阿里通义千问大模型(Qwen-14B-Chat-Int4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境文件准备项目代码模型相关文件 运行准备工作运行demo Tips 环境 系统版本：Windows 10 企业版
版本号：20H2
系统类型：64 位操作系统, 基于 x64 的处理器
处理器：Intel® Core™ i7-13700K CPU @ 3.40GHz
机带 RAM：16.0 GB
显卡：NVIDIA RTX 4080（16G）
Python版本：3.10.11
文件准备 项目代码 Git地址：https://github.com/QwenLM/Qwen
创建好归档的文件夹，直接克隆即可：
git clone https://github.com/QwenLM/Qwen.git 模型相关文件 地址：https://huggingface.co/Qwen/Qwen-14B-Chat-Int4
注意：从huggingface.co上克隆，需要魔法、cmd命令行设置代理
魔法软件端口信息：
在cmd命令行执行：
set https_proxy=https://127.0.0.1:8001 完成上述配置后可以开始克隆了
模型文件比较大，需要使用git-lfs，下载git-lfs并安装：https://git-lfs.com，安装完配置好环境变量，
完成上述配置后，执行：
git lfs install git clone https://huggingface.co/Qwen/Qwen-14B-Chat-Int4 运行 准备工作 安装所需的依赖，进入下载好的项目代码代码根目录，执行：
pip install -r requirements.txt pip install auto-gptq optimum 所有文件下载完成后，修改web_demo.py中模型文件路径：
运行demo 尝试执行：python web_demo.py，看看是否会报错，如果报错，就根据提示改：
提示需要设置share=True，在web_demo.py中找到对应位置：
再运行试试：
日志显示已启动成功，打开页面，可以正常进行问答，运行比较流畅：
Tips 从别的机器上访问，连接是拒绝的，查看日志，生成了一个临时的分享地址，可以提供给局域网内其他人使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5cd19f8eb471f166137c0bf8f6c6449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb45529a4afd720304a3966fc451ee8f/" rel="bookmark">
			计算机竞赛 题目：基于机器视觉opencv的手势检测 手势识别 算法 - 深度学习 卷积神经网络 opencv python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 简介2 传统机器视觉的手势检测2.1 轮廓检测法2.2 算法结果2.3 整体代码实现2.3.1 算法流程 3 深度学习方法做手势识别3.1 经典的卷积神经网络3.2 YOLO系列3.3 SSD3.4 实现步骤3.4.1 数据集3.4.2 图像预处理3.4.3 构建卷积神经网络结构3.4.4 实验训练过程及结果 3.5 关键代码 4 最后 1 简介 🔥 优质竞赛项目系列，今天要分享的是
基于机器视觉opencv的手势检测 手势识别 算法
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
2 传统机器视觉的手势检测 普通机器视觉手势检测的基本流程如下：
其中轮廓的提取，多边形拟合曲线的求法，凸包集和凹陷集的求法都是采用opencv中自带的函数。手势数字的识别是利用凸包点以及凹陷点和手部中心点的几何关系，简单的做了下逻辑判别了（可以肯定的是这种方法很烂），具体的做法是先在手部定位出2个中心点坐标，这2个中心点坐标之间的距离阈值由程序设定，其中一个中心点就是利用OpenNI跟踪得到的手部位置。有了这2个中心点的坐标，在程序中就可以分别计算出在这2个中心点坐标上的凸凹点的个数。当然了，这样做的前提是用人在做手势表示数字的同时应该是将手指的方向朝上（因为没有像机器学习那样通过样本来训练，所以使用时条件要苛刻很多）。利用上面求出的4种点的个数(另外程序中还设置了2个辅助计算点的个数，具体见代码部分)和简单的逻辑判断就可以识别出数字0~5了。其它的数字可以依照具体的逻辑去设计（还可以设计出多位数字的识别），只是数字越多设计起来越复杂，因为要考虑到它们之间的干扰性，且这种不通用的设计方法也没有太多的实际意义。
2.1 轮廓检测法 使用 void convexityDefects(InputArray contour, InputArray convexhull,
OutputArray convexityDefects) 方法
该函数的作用是对输入的轮廓contour，凸包集合来检测其轮廓的凸型缺陷，一个凸型缺陷结构体包括4个元素，缺陷起点坐标，缺陷终点坐标，缺陷中离凸包线距离最远的点的坐标，以及此时最远的距离。参数3即其输出的凸型缺陷结构体向量。
其凸型缺陷的示意图如下所示：
第1个参数虽然写的是contour，字面意思是轮廓，但是本人实验过很多次，发现如果该参数为目标通过轮廓检测得到的原始轮廓的话，则程序运行到onvexityDefects()函数时会报内存错误。因此本程序中采用的不是物体原始的轮廓，而是经过多项式曲线拟合后的轮廓，即多项式曲线，这样程序就会顺利地运行得很好。另外由于在手势识别过程中可能某一帧检测出来的轮廓非常小（由于某种原因），以致于少到只有1个点，这时候如果程序运行到onvexityDefects()函数时就会报如下的错误：
​
int Mat::checkVector(int _elemChannels, int _depth, bool _requireContinuous) const { return (depth() == _depth || _depth &lt;= 0) &amp;&amp; (isContinuous() || !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb45529a4afd720304a3966fc451ee8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ca2d3b99454a348a84dd1ef8755e19/" rel="bookmark">
			工程派工单，建筑工程派工单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 工程派工单是指建设项目管理人员或工程维修人员发出的文件，用于标明工人或维修人员在建设项目或设备中处理或维修问题的任务。派工单包括建设项目的实际维护任务、所需材料、工具等信息，以及具体的执行人员和完成时间。工程派工单是保证建设项目顺利开展和今后安全运行的重要工具。
工程维修派工单是建筑工程和建筑工程中最常用的派工单类型之一。通常用于工程项目中各种工业设备、电子产品和配件的维护和修复。维修人员可根据工程维修派工单中的详细描述进行操作，以便在最短时间内完成维修任务。
工程派工单种类繁多，但一般包括项目名称、工作内容、工作地点、执行人员、工作时间、工作注意事项等信息。在建设项目中，工程派工单还应提高工程负责人、设计师等其他信息。
无论是建筑工程还是建筑工程，工程派工单都是保证建筑工程正常运行和安全的重要工具。根据工程派工单的规范使用，可以避免建筑工程的延误和质量问题，提高效率，降低工作成本。
派工单是一种高效的工单系统软件，旨在满足学校、行政、企业、机房等各个领域的工单管理需求。该产品拥有集成化、定制化、可视化管理等多项特点，能够为用户提供一站式的全流程的工单管理服务。
集成化的工单系统软件&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作为一个集成化的工单系统软件，派工单让用户可以在一个平台上完成工单的全生命周期管理，包括工单创建、自动运转、处理和管理等。用户可以随时了解工单的进展情况，通过数据统计，更好地掌握项目的进度和质量。 具备强大的定制化能力&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 派工单具备强大的定制化能力，可以根据各个行业不同的需求，为用户提供专属的定制化服务，以满足用户的精准需求。而且，还可以根据不同用户的权限来设置操作和管理的权限，保证信息的安全性和保密性。 可视化的管理界面&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 派工单可视化的管理界面，方便用户直观地查看和处理工单。用户可以通过图表和分析结果，直观地展现工单的情况和趋势，为决策提供数据参考。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a4c9ad8dd27d5d5aa65dff32810f9a/" rel="bookmark">
			10.7Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元组
menus = ('东坡肉', '佛跳墙', '狮子头', '酱大骨', '猪肘子') print('修改前的菜单为：', end='') for i in menus: print(i, end=" ") print('') menus_list = list(menus) menus_list[3] = '杏仁豆腐' menus = tuple(menus_list) print('修改后的菜单为：', end='') for i in menus: print(i, end=" ") 集合
existed_usernames = {'viv', 'apple', 'sky', 'apple'} while 1: new_username = input('请输入用户名：') tem = {new_username} if tem.isdisjoint(existed_usernames): print('可以使用该用户名') existed_usernames.add(new_username) break else: print('已有用户名请重新输入') print(existed_usernames) 随机十个三位数
import random num = set() while len(num) &lt; 10: num_ = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a4c9ad8dd27d5d5aa65dff32810f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e389277c8943a561f6973c4a10f505dc/" rel="bookmark">
			维修派工单，为什么要使用维修派工单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维修派工单是一种至关重要的管理工具，主要用于分配维修人员对设备进行维护和维修。根据派工单，可以快速清晰地分配维修任务，掌握设备维护的进度和效果，提升设备维护的效率和效果。
良好的维修工单应具有清晰的格式，包括设备名称、设备维护内容、工作地点、工作时间、维修人员及其负责人等信息。这些数据的准确性和完整性非常重要，可以帮助维修人员快速了解工作内容和工作计划，并做好准备。
维修派工单还应注意对派工单的监督，包括对已完成的派工单进行归档，实时了解维修中存在的问题和维修人员的工作效果，并及时反馈和改进。
维修派工单的优秀管理不仅体现在详细的派工单格式和精细的管理工作上，更注重人员的培训和管理。维修人员必须具有优秀的专业能力和较高的工作责任感，还需要定期接受培训和评估，以确保设备维护的质量和效率。
维修工单是企业管理中不可缺少的一部分。根据制定标准化的维护工单，加强维护人员的培训和管理，可以提高维护工作的质量和效率，降低成本，提高效率，创造更安全、高效、可靠的工作氛围。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;派工单，是一种高效的工单系统软件，旨在满足学校、行政、企业、机房等各个领域的工单管理需求。该产品拥有集成化、定制化、可视化管理等多项特点，能够为用户提供一站式的全流程的工单管理服务。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作为一个集成化的工单系统软件，派工单让用户可以在一个平台上完成工单的全生命周期管理，包括工单创建、自动运转、处理和管理等。用户可以随时了解工单的进展情况，通过数据统计，更好地掌握项目的进度和质量。
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 派工单具备强大的定制化能力，可以根据各个行业不同的需求，为用户提供专属的定制化服务，以满足用户的精准需求。而且，还可以根据不同用户的权限来设置操作和管理的权限，保证信息的安全性和保密性。
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 派工单可视化的管理界面，方便用户直观地查看和处理工单。用户可以通过图表和分析结果，直观地展现工单的情况和趋势，为决策提供数据参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beeaaee9daaad8afb7651bf13604f3c7/" rel="bookmark">
			如何查看k8s版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用kubectl version 命令即可查看
[root@node6 ~]# kubectl version Client Version: v1.28.2 Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3 The connection to the server localhost:8080 was refused - did you specify the right host or port? [root@node6 ~]# 输出信息详解：
client代表kubectl版本信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbd186721f18c484f6e432e885d895d/" rel="bookmark">
			ShardingSphereJDBC5.4.0支持Nacos配置（SpringCloud版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在ShardingSphere在5.3.0版本之前，我们可以通过依赖shardingsphere-jdbc-core-spring-boot-starter模块，在application.yml文件里配置数据库连接信息。再结合spring-cloud-starter-alibaba-nacos-config，在项目启动时，从Nacos后台动态的拉取数据库配置，实现了配置文件和代码分离，避免了改配置需要重新打包。在5.3.0之后（包含），ShardingSphere由于兼容各个spring版本造成工作量巨大，而放弃了对spring的支持，提供了另一种方式ShardingSphere Driver来连接数据库（ issue-22469）。但使用ShardingSphere Driver后，也就无法通过spring-cloud-starter-alibaba-nacos-config自动载入数据库配置。
ShardingSphere Driver为什么无法支持Nacos ShardingSphere Driver的核心是自己提供了ShardingSphereDriver，从而支持这种格式的JDBC URL：jdbc:shardingsphere:${path}/config.yaml。我们可以把ShardingSphere的规则写到config.yaml文件里，然后通过ShardingSphereDriverURLProvider（5.4.1后改名ShardingSphereURLProvider）接口来支持不同的${path}的文件寻址方式。默认支持
absolutepath（服务器绝对路径）、classpath、apollo（5.4.1把功能挪到了ShardingSphere plugin仓库里）。所以在官方实现里，并不支持通过Nacos获取config.yaml信息。需要在Spring Boot项目里支持Nacos，就要自定义Nacos的ShardingSphereURLProvider。
Nacos的ShardingJdbcURLProvider ShardingSphereDriverURLProvider是通过SPI的方式实现扩展，我们在自定义ShardingJdbcNacosURLProvider后，要把ShardingJdbcNacosURLProvider类信息放到META-INF/services/org.apache.shardingsphere.driver.jdbc.core.driver.ShardingSphereDriverURLProvider文件里，这样就被ShardingSphere找到。自定义支持Nacos的ShardingSphereURLProvider 大概长这样：
public final class ShardingJdbcNacosURLProvider implements ShardingSphereDriverURLProvider {
private static final String CLASSPATH_TYPE = "nacos:";
private static final String URL_PREFIX = "jdbc:shardingsphere:";
@Override
public boolean accept(final String url) {
return !Strings.isNullOrEmpty(url) &amp;&amp; url.contains(CLASSPATH_TYPE);
}
@SneakyThrows
@Override
public byte[] getContent(String url) {
String configPath = url.substring(URL_PREFIX.length(), url.contains("?") ? url.indexOf('?') : url.length());
String dataId = configPath.substring(CLASSPATH_TYPE.length());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fbd186721f18c484f6e432e885d895d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4621f184fcd95253e4538a465d0dae34/" rel="bookmark">
			it端到端运营监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 公司的运维监控已成为确保业务顺利运行的关键。特别是对于IT部门，端到端运维监控不仅可以帮助企业及时发现和解决问题，还可以提高业务效率，优化客户体验。端到端运维监控的概念、重要性及其实施方法。
端到端操作监控的概念 端到端操作监控，顾名思义，是通过一系列监控工具和技术，从业务端（如操作界面或设备）逐步监控到业务另一端（如数据库或服务器）的全过程。这种监控方法可以确保企业的每个部门都能在稳定状态下运行，从而提高整体业务效率。 端到端操作监控的必要性 及时发现和解决问题：根据端到端运行监控，企业可以实时监控业务状态。一旦发现问题，就可以立即解决，防止问题扩大，减少损失。 提升业务效率：端到端运维监控帮助企业发现工作过程中的瓶颈和消耗，进而优化，提升业务效率。 优化客户体验：根据端到端运维监控，企业可以实时了解客户需求和反馈，提供更好的服务，提升客户体验。 端到端操作监控的实施方法 选择合适的监控工具：市场上有许多优秀的监控工具，如Zabbix、Nagios等，企业应根据自己的需要和预算，选择合适的工具。 设计合理的监管对策：企业应根据自身的业务特点和需要，设计合理的监管对策，包括监控内容、频率、方法等。 建立和完善报案制度：当监控系统检测到问题时，应立即发出声音，让相关人员妥善处理。 建立可持续改进的制度：公司应经常对监控系统进行评估和改进，以确保其始终能够有效地适用于业务运行。 端到端运行监控是保证企业业务顺利运行的关键。企业应重视并投入资源选择监控工具、设计监管战略、建立报告制度和不断完善的制度建设，实现业务高效运行，提升客户体验，最终促进企业的长远发展。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c27a931843529af59aaaae00db8cac6d/" rel="bookmark">
			从php页面插入MySQL的数据变为乱码如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 PHP 页面中向 MySQL 数据库插入数据时，如果数据出现乱码，可能是因为字符集设置不正确或者字符编码不匹配。
数据库字符集设置不正确：
确保数据库的字符集设置与您的应用程序所使用的字符集一致。通常情况下，UTF-8 是一个通用的字符集，适用于多种语言。您可以在 MySQL 中执行以下查询来查看和更改数据库的字符集设置： -- 查看数据库的字符集设置 SHOW VARIABLES LIKE 'character_set_database'; -- 更改数据库的字符集设置（以UTF-8为例） ALTER DATABASE your_database_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 数据库连接字符集设置：
在 PHP 中，您可以通过设置连接的字符集来确保与数据库进行通信时使用相同的字符集。可以使用以下代码在 PHP 中设置连接的字符集： // 在连接到数据库后，设置连接的字符集 mysqli_set_charset($connection, "utf8mb4"); 表的字符集设置：
确保数据库表也使用正确的字符集。您可以在创建表时指定字符集，或者在已有的表上更改字符集。 数据编码和存储：
在插入数据之前，确保 PHP 中的数据以正确的字符编码表示。通常情况下，使用 UTF-8 编码会比较安全。确保插入数据时，数据与表的字符集一致。如果需要转换数据，可以使用 PHP 中的编码转换函数，例如 iconv() 或 mb_convert_encoding()。 输出字符集：
最后，确保从数据库中检索和输出数据时，也使用正确的字符集。在 PHP 页面中设置响应头部的字符编码也是一个好做法： header("Content-Type: text/html; charset=utf-8"); 通过确保数据库、连接、表、数据编码和输出都使用一致的字符集和编码，您可以解决从 PHP 页面插入数据导致乱码的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d402be02c141db3ecb5d9c918bae6fcc/" rel="bookmark">
			01_MySQL下载、安装与配置(以MySQL8.0.31版本为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 下载MySQL（MySQL的官网地址：https://www.mysql.com/）
1.进入官网 点击DOWNLOADS
2.这里我们选择社区免费版本，对于个人开发者而言够用
3.点击MySQL Community Server
4.操作系统选择windows，然后点击go to download page
5.这里我们选择离线的安装包(推荐)
第一个是在线安装 第二个是离线安装
6.选择最下面的No thanks，just start my download 就会弹出下载界面啦
7.下载成功后，指定目录会有一个mysql的安装包
二、安装MySQL
1.点击下载好的mysql安装包 进入到mysql installer界面
选择custom(可以自己选择路径或配置)点击next 2.选择MySQL Servers选项 一直下拉
选中MySQL Server 8.0.31 -x64 然后点击绿色箭头选项就被拖过去了 3.选择安装路径
- 点击被拖过去的mysql选项(1)
- 然后选择安装路径(2) 再点击next
(1)
(2)
install Directory是MySQL软件的安装路径
Data Directory是MySQL数据库数据存放的路径
注：如果选择安装路径时下面警告选择路径已经存在，这是因为该路径下已经有此文件夹（建议是直接在路径中输入文件夹的名字 让它自动生成）
4.点击Execute
5.继续next
6.默认选择Development Computer 然后next
7.默认选择 点击next
8.输入数据库密码(一定要自己能记住)
9.可以修改数据库服务名字(名字默认有MySQL80 因为版本是8.0版本) 然后next
10.继续next
11.点击Execute
12.全都绿了表示成功 点击finish结束
13.接下里就默认next和finish结束MySQL的安装
三、配置环境变量
1.右键此电脑 属性(win11为例)
或者打开此电脑后在上方的工具栏中找到属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d402be02c141db3ecb5d9c918bae6fcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a21ead69495edea72f7f07811c54217/" rel="bookmark">
			Bad owner or permissions on C:\\Users\\tab.wei/.ssh/config
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How can I fix bad owner or permissions on SSH config? 2 Ways to Fix bad Owner or Permissions on SSH Config (windowsreport.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844f67b33810b6dddc0d0b34000dc9a0/" rel="bookmark">
			vue3 访问 public 内文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、访问 JSON 文件 方法：使用 axios 读取文件 （1）在 public 文件夹下创建 json 文件
（2）在需要自定义配置的页面使用 axios 读取此 json 文件：
axios.request({ url: '/app/app-config.json', // 直接填写json文件在public下的路径即可 method: 'get', }).then(res =&gt; { this.appData = res.data }).catch(err =&gt; { alert("抱歉，服务出错！") }) （3）实际项目中会将 axios 方法进行封装，可直接使用调用接口方法：
// api 文件： getAppConfig() { const url = '/app/app-config.json' return fetchGet(url) } // 实际使用： const appConfigRes = await api.getAppConfig() const appConfig = appConfigRes.data 如果有问题，如果部署之后有可能会访问不到 json 文件。需要在 路径前面添加 BASE_URL 地址
const url = process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844f67b33810b6dddc0d0b34000dc9a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f725b72b02140891484bf14cfd884136/" rel="bookmark">
			vscode 配置默认shell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode 配置默认shell 最简单方式
"terminal.integrated.defaultProfile.osx": "zsh",
也可以自定义，参考 https://code.visualstudio.com/docs/terminal/profiles
terminal 修改默认shell
change your default shell to zsh
chsh -s /bin/zsh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e0ad82703412ec265bec77ea05b98c/" rel="bookmark">
			rpm包制作脚本spec文件书写指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、软件包描述1.1、Name：1.2、Version1.3、Release1.4、Vendor1.5、Summary1.6、License/Copyright1.7、URL1.8、Source1.9、Group1.10、Patch1.11、BuildRoot1.12、Requires1.13、Packager1.14、`%description`1.15、BuildArch 二、软件包生成各阶段操作2.1、`%prep`2.2、`%build`2.3、`%install`2.4、`%clean`2.5、`%check` 三、包的应用性脚本3.1、`%pre`3.2、`%post`3.3、`%preun`3.4、`%postun` 四、包配置信息4.1、`%files`4.2、`%changelog`4.3、`%doc`4.4、`%dir`4.5、`%config(noreplace)`4.6、`%attr` 参考文档 spec 文件用于制作rpm包，包含了软件包的诸多信息，如软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。示例如下： Name: myprogram Version: 1.0 Release: 1 Vendor: Jaun Summary: My program License: GPL URL: http://myprogram.com Source0: myprogram-1.0.tar.gz Group: Development/Tools BuildRequires: gcc %description My program is a simple example program. %prep %setup -q %build ./configure make %install make install DESTDIR=%{buildroot} %clean rm -rf %{buildroot} %files %defattr(-,root,root) /sbin/myprogram %post /sbin/ldconfig /sbin/myprogram %preun /sbin/ldconfig /sbin/myprogram %postun /sbin/ldconfig %changelog 以下就各个参数分类介绍
一、软件包描述 1.1、Name： 软件包的名称，之后可以使用%{name}的方式进行引用,最终RPM软件包是用该名字与版本号，释出号及体系号来命名软件包的。
1.2、Version 软件包的版本号,之后可以使用%{version}的方式进行引用,仅当软件包比以前有较大改变时才增加版本号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e0ad82703412ec265bec77ea05b98c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222c761e2a09b802f0b8ca744d808e2b/" rel="bookmark">
			KF32 PWM与IC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 PWM(脉冲调制)利用mcu的数字输出实现对模拟电路的控制，来输出不同的电压。可以用来控制灯的亮度，输出不同占空比，灯的亮度不同，可实现呼吸灯的功能；还可以输出不同占空比控制电机的转速。
使用pwm实现呼吸灯功能，在低电平灯会灭，只是时间短，肉眼观察不到。
IC输入捕获模块，可测量PWM的频率和占空比。
二、重要参数 频率（f）
单位时间内完成高低电平变化的次数。
占空比
一个脉冲周期内，高电平的时间占整个周期时间的比例。例：占空比为50%，25%，如下图：
三、定时器与PWM 1.先了解一下定时器计数模式（以Timer_A为例）
比较器TAxCCR0为16位周期寄存器，最大值为0FFFFh。
（1）增计数
计数器TAR可以增计数到TAxCCR0的值，增加到的最大值由TAxCCR0的值决定，增加到TAxCCR0后，再重新从0开始计数。例TA0CCR0=5000；计数器TAR由0增加到5000，再从0重新计数。
（2）连续计数
计数器TAR可以增计数到0FFFFh的值，再重新从0开始计数。
（3）增减计数
计数器TAR可以增计数到TAxCCR0的值，增加到的最大值由TAxCCR0的值决定，由0增加到TAxCCR0后，然后从TAxCCR0开始减少到0，再重新计数，周期为增模式的2倍。例TA0CCR0=5000；计数器TAR由0增加到5000，再从5000减少到0。
2.使用定时器产生PWM波形（增模式）
占空比调节（捕获/比较值）ccpx。
计数器TAR的值小于ccpx的值时，IO 输出高电平 ，计数器TAR的值大等于ccpx的值时，IO 输出低电平 ，这样就输出了方波。
改变ccpx的值就可以改变占空比的大小，而改变比较器TAxCCR0值，即改变周期。
四、程序 PWM 1.初始化 //配置为 重映射IO口功能模式 ，以PA0为例
GPIO_Write_Mode_Bits(GPIOA_SFR, GPIO_PIN_MASK_0, GPIO_MODE_RMP);
//引脚映射AF选择，需要查询手册确认
GPIO_Pin_RMP_Config(GPIOA_SFR, GPIO_Pin_Num_0 ,GPIO_RMP_AF11);
2.输出不同占空比波形 //入参为ccpx，通道，选择需要查手册，周期，占空比（0—100）
void CCPx_PWM_PPX_Duty(CCP_SFRmap *CCPx, uint32_t Channel, uint16_t Period, uint16_t Duty)
{
/* 定时器外设复位，启用外设时钟*/
TIM_Reset(CCPx);
/* PWM功能通道模式*/
CCP_PWM_Mode_Config(CCPx, Channel, CCP_PWM_MODE);
/* 配置CCP通道输出以控制PWM输出，高效 */
CCP_Channel_Output_Control(CCPx, Channel, CCP_CHANNEL_OUTPUT_PWM_ACTIVE);
/* 设置PWM占空比 */
CCP_Set_Compare_Result(CCPx, Channel, Duty);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/222c761e2a09b802f0b8ca744d808e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd884ea5cba8836c334f6ec1d1deca91/" rel="bookmark">
			初识数据结构与算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、什么是算法 算法定义
「算法 algorithm」是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性
问题是明确的，包含清晰的输入和输出定义。具有可行性，能够在有限步骤、时间和内存空间下完成。各步骤都有确定的含义，相同的输入和运行条件下，输出始终相同。 二、什么是数据结构 数据结构定义
「数据结构 data structure」是计算机中组织和存储数据的方式，具有以下设计目标
空间占用尽量减少，节省计算机内存。数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。提供简洁的数据表示和逻辑信息，以便使得算法高效运行。 数据结构设计是一个充满权衡的过程。如果想要在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子：
链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。 三、数据结构与算法的关系 数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及用于操作数据的方法。算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。算法通常可以基于不同的数据结构进行实现，并往往有对应最优的数据结构，但最终执行效率可能相差很大。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f0c90cf2886c19733862b866c366d9/" rel="bookmark">
			jquery 下拉菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html中有下拉的组件，但是样式不太好看并且还不能修改原有的样式，于是乎就准备自己写一个。
1.html的下拉组件select使用。
选择城市 &lt;select &gt; &lt;option value=""&gt;城市1&lt;/option&gt; &lt;option value=""&gt;城市2&lt;/option&gt; &lt;option value=""&gt;城市3&lt;/option&gt; &lt;option value=""&gt;城市4&lt;/option&gt; &lt;option value=""&gt;城市5&lt;/option&gt; &lt;/select&gt; 2.直接手撸一个，大致思路就是一个input点击下面的列表显示，点击选中元素拿到值赋给input的val让后隐藏下拉。这是单个，多个的话就需要拿到$(this)和id传递给方法让后隐藏或者显示就是当前元素再拿到选中的值赋值给传递过来的input就ok了。
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt; &lt;title&gt;下拉菜单&lt;/title&gt; &lt;meta name="keywords" content="关键词" /&gt; &lt;meta name="description" content="描述" /&gt; &lt;script type="text/javascript" src="/static/js/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/static/js/jquery.SuperSlide.2.1.1.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; .content { display: flex; justify-content: space-between; margin: 37px auto 180px; } input{ outline-style: none; } input:focus { border: 1px solid red !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f0c90cf2886c19733862b866c366d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe27bc772d220cbcfe8009a11955a7d/" rel="bookmark">
			用 VS Code 运行 C 语言（安装 VS Code，mingw 的下载和安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载并安装 VS code。
安装扩展包：
此时，写完代码右键之后并没有运行代码的选项，如图：
接下来安装编译器 mingw。
下载链接：
https://sourceforge.net/projects/mingw-w64/
得到压缩包：
解压：
给电脑添加环境变量：
添加成功：
检验下安装是否成功：
VS Code 内再安装扩展 code runner：
此时右键有运行代码的选项：
运行成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0fa731784212ed1850b01686950f40/" rel="bookmark">
			Pandas库学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas的Series相当于添加了序号的一维array，Dataframe相当于添加了序号的二维array。(默认序号是从0开始计数)
1、Pandas属性 Series import pandas as pd import numpy as np a = pd.Series([1,2,3,np.nan,4],index=['a','b','c','d','e']) print(a) 结果： a 1.0 b 2.0 c 3.0 d NaN e 4.0 dtype: float64 Dataframe import pandas as pd import numpy as np np.random.seed(1) a = pd.DataFrame(np.random.randint(0,5,(4,3)), index=['a','b','c','d'], columns=['cat', 'dog', 'car']) print('DataFrame:\n',a) print('DataFrame行名:\n',a.index) print('DataFrame列名:\n',a.columns) print('DataFrame值:\n',a.values) print('DataFrame每列的统计特征:\n',a.describe()) print('DataFrame按index排序:\n',a.sort_index(axis=1)) print('DataFrame按值排序:\n',a.sort_values(by='car',ascending=False)) print('DataFrame翻转:\n',a.T) 结果: DataFrame: cat dog car a 3 4 0 b 1 3 0 c 0 1 4 d 4 1 2 DataFrame行名: Index(['a', 'b', 'c', 'd'], dtype='object') DataFrame列名: Index(['cat', 'dog', 'car'], dtype='object') DataFrame值: [[3 4 0] [1 3 0] [0 1 4] [4 1 2]] DataFrame每列的统计特征: cat dog car count 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c0fa731784212ed1850b01686950f40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85957a78b002040d74c7c61e4675159/" rel="bookmark">
			jQuery 菜鸟教程学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jQuery 是一个 JavaScript 库。jQuery 极大地简化了 JavaScript 编程。
$(document).ready() $(document).ready() 方法允许我们在文档完全加载完后执行函数。
jQuery 选择器 jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。
jQuery 选择器基于元素的 id、类、类型、属性、属性值等"查找"（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。
jQuery 中所有选择器都以美元符号开头：$()。
$(this).hide() 演示 jQuery 的 hide() 函数，隐藏当前的 HTML 元素。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.0.0/jquery.min.js"&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $("button").click(function(){ $(this).hide(); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 标签选择器$("p").hide() 演示 jQuery 的 hide() 函数，隐藏所有 &lt;p&gt; 元素。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85957a78b002040d74c7c61e4675159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699eeeb6ce1e4dbfb2fc3e0bdf191cff/" rel="bookmark">
			【Oracle点滴积累】Error ORA-01031 Insufficient Privileges
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象： sqlplus / as sysdba ora-01031:insufficient privileges
1． 检查sqlnet.ora 文件
sqlnet.ora 文件损坏或格式不对可以导致出现该问题。 sqlnet.ora 文件可能存放路径为
$ORACLE_HOME/network/admin/sqlnet.ora 或 $HOME/sqlnet.ora (1). 可以从别的机器拷贝一个文件过来，注意备份原来的sqlnet.ora。 ---检查sqlnet.ora 文件内容 (2). 检查SQLNET.AUTHENTICATION_SERVICES 如果没有使用dblink.检查该行并设置 Windows Server:SQLNET.AUTHENTICATION_SERVICES = (NTS) Linux Server: SQLNET.AUTHENTICATION_SERVICES = (ALL)
(3). SQLNET.CRYPTO_SEED 在unix 下不需要该参数。如果存在该行，注释掉或删掉 (4).AUTOMATIC_IPC 如果该参数为 ON，将强制使用"TWO_TASK" 连接 最好设置为OFF AUTOMATIC_IPC = OFF 2． 检查相关文件的权限配置找到$ORACLE_HOME/network/admin/* $ cd $ORACLE_HOME/network/admin/ $ chmod 644 sqlnet.ora tnsnames.ora listener.ora $ ls -l sqlnet.ora tnsnames.ora listener.ora -rw-r--r-- 1 oracle dba 1628 Jul 12 15:25 listener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699eeeb6ce1e4dbfb2fc3e0bdf191cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcd0d684e2935f8b68d7ec1051d6dc8/" rel="bookmark">
			Jmeter(五十四) - 从入门到精通高级篇 - 如何在linux系统下运行jmeter脚本 - 上篇（详解教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 上一篇已经介绍了如何在Linux系统中安装Jmeter，想必各位小伙伴都已经在Linux服务器或者虚拟机上已经实践并且都已经成功安装好了，那么今天宏哥就来介绍一下如何在Linux系统下运行Jmeter脚本。
2.具体步骤 2.1创建Jmeter测试脚本 你要在Linux系统中运行Jmeter脚本首先要有Jmeter。在Windows系统中启动jmeter，创建Jmeter测试脚本，这里以访问我博客首页为例
1.启动Jmeter后，添加线程组，如下图所示：
如果你想学习自动化测试，我这边给你推荐一套视频，这个视频可以说是B站播放全网第一的自动化测试教程，同时在线人数到达1000人，并且还有笔记可以领取及各路大神技术交流：798478386 【已更新】B站讲的最详细的Python接口自动化测试实战教程全集（实战最新版）_哔哩哔哩_bilibili【已更新】B站讲的最详细的Python接口自动化测试实战教程全集（实战最新版）共计200条视频，包括：1、接口自动化之为什么要做接口自动化、2、接口自动化之request全局观、3、接口自动化之接口实战等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV17p4y1B77x/?spm_id_from=333.337 2.选中“线程组”，添加取样器“HTTP请求”，如下图所示：
3.选中“HTTP请求”，添加监听器“察看结果树”，如下图所示：
4.点击保存按钮，脚本保存为test.jmx，运行脚本进行调试直到调试成功，如下图所示：
5.将线程组修改成100，然后保存，将文件上传至linux服务器。
2.2运行脚本 1.在Linux服务器的usr目录下创建一个test文件夹，如下图所示：
2.将在Windows调试好的基本上传到此文件夹中，如下图所示：
3.将脚本上传至linux服务器，然后就在当前的test目录下，输入命令 jmeter -n -t test.jmx -l log.jtl ，运行jmeter脚本。运行结果，如下图所示：
4.将脚本上传至linux服务器，或者进入jmeter的bin目录下，输入命令 jmeter -n -t /usr/test/test.jmx -l /usr/test/log.jtl ，运行jmeter脚本。运行结果，如下图所示： PS：常用命令解析：
# 常见命令说明 -h 帮助：打印出有用的信息并退出 -n 非 GUI 模式：在非 GUI 模式下运行 JMeter -t 测试文件：要运行的 JMeter 测试脚本文件 -l 日志文件：记录结果的文件 -r 远程执行：启动远程服务 -H 代理主机：设置 JMeter 使用的代理主机 -P 代理端口：设置 JMeter 使用的代理主机的端口号 5.跑完之后，在test目录下，生成两个文件：一个是jmeter.log(jmeter运行日志)，一个是我们的性能结果文件(log.jtl)，我们用命令把log.jtl文件导入windows系统就能查看结果了,如下图所示：
2.3查看测试报告 1.在windows上启动jmeter，添加所需的监听器，导入脚本运行产生的log.jtl文件，查看测试结果，(注：察看结果树的请求内无信息，后边宏哥会给出解决方案)，如下图所示：
从上图可以看出：前边线程组设置的是100，这里的聚合报告的样本也是100，说明没有问题，运行的是宏哥上传的脚本。
以上，即为在linux环境中运行jmeter脚本，并生成测试报告的的过程，具体操作，请自行实践，本文仅供参考。
2.4解决结果树查看无请求信息 1.在windows上启动jmeter，添加察看结果树监听器，导入脚本运行产生的log.jtl文件，查看测试结果，发现察看结果树的请求内无信息。如下图所示：
2.解决linux下运行jmeter脚本，导出的jtl文件，用结果树查看无请求信息问题，解决方法:在linux的jmeter安装目录下bin/user.properties 加入如下参数： jmeter.save.saveservice.output_format=xml jmeter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bcd0d684e2935f8b68d7ec1051d6dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fad8ba43ee750eb12370ed5c0d358f3/" rel="bookmark">
			android frameworks之zygote进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zygote进程是各个应用进程的鼻祖，每个app的进程是由zygote进程创建出来的，即app进程的父进程为zygote进程。
在系统启动时，加载bootloader，启动内核，创建init进程，在init进程中，解析init.rc，init.rc包含启动zygote进程的服务，进而启动zygote进程。
在linux中，进程是由fork()创建的，fork出的子进程除了一些内核的核心数据跟父进程不同外，其余的数据、内存都是和父进程共享的，fork()出的子进程返回值为0，父进程的返回值为父进程的pid
1、init.rc
init.rc中是通过import方式引入文件的，引入的文件通过ro.zygote的属性来控制
\system\core\rootdir\init.rc import /init.${ro.zygote}.rc ro.zygote的属性值可设置的值有：zygote32,zygote32_64,zygote64,zygote64_32，因此在system/core/rootdir/目录下有四个和zygote相关的rc文件
zygote32：32位模式
zygote32_64:以32位模式为主，64位模式为辅
zygote64:64位模式
zygote64_32:以64位模式为主，32位模式为辅
zygote32和zygote64一样，只是zygote64执行的是app_process64的进程；zygote32和zygote32_64的区别在宇zygote32_64多了启动zygote_secondary的进程
init.zytote32.rc
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks init.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fad8ba43ee750eb12370ed5c0d358f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc63ccec73a6324fc70d92be4d614b1/" rel="bookmark">
			Lambda表达式特性之延迟执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么需要延迟执行 问题引出：有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。如何解决：Lambda表达式是可以延迟执行的，这正好可以作为解决方案，提升性能。
二、延迟执行造成的性能浪费的案例 典型的场景：就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出： public class LoggerDemo { private static void log(int level, String msg) { //条件判断 if (level == 1) { System.out.println(msg); } } public static void main(String[] args) { String msgA = "Hello"; String msgB = "World"; String msgC = "Java"; //方法调用，必须提前拼接字符串造成性能浪费 log(1, msgA + msgB + msgC); } } 问题说明：这段代码存在问题，无论级别level是否满足要求，log 方法的第二个参数，也就是**三个字符串(msgA + msgB + msgC)**无论如何一定先会被拼接，然后再传入方法内进行级别判断if (level == 1)。问题进一步分类分析：
a.如果判断通过，那么好，这种情况不会对性能产生影响；
b.如果判断不通过，那么我们之前在传入参数时进行三个字符串 (msgA + msgB + msgC)的操作不就是白做了吗，因为又不需要打印，那么用在拼接字符串上的时间不就等于白白浪费了，也就造成了性能浪费。问题解决：那么如何不浪费这些性能呢？于是lambda表达式挺身而出，来拯救这些不应该被浪费的性能。
三、使用lambda表达式进行优化（延迟执行） 情况一：未使用lambda表达式的情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc63ccec73a6324fc70d92be4d614b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea3ed5431fd8e17711b9a66d2ddd6b3/" rel="bookmark">
			Cinema4D 2024软件详细安装教程&#43;官方中文正版安装包（永久使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装步骤
1软件安装包下载解压打开（下载软件安装包之前务必将杀毒软件以及防火墙关闭，避免将破解补丁或注册机删除）
(图 1)
将软件安装包下载到电脑本地之后，选择安装包鼠标右键进行使用解压工具解压（注意：如果解压需要解压码的话，请换一个解压工具解压即可，无压缩密码）
2运行安装程序
(图 2)
选择安装程序Cinema4D_2024_2024.0.0_Win.exe，鼠标右键以管理员身份运行
3欢迎使用安装向导
(图 3)
欢迎使用安装向导，点击前进
4更改安装位置
(图 4)
更改安装位置，直接在路径上更改或者点击文件夹图标进去更改（注意：更改安装位置不能带有中文或者特殊符号），然后点击前进
5安装准备完毕
(图 5)
安装准备完毕，点击前进
6软件正在安装中
(图 6)
软件正在安装中，请耐心等候安装成功
7软件安装成功
(图 7)
软件安装成功，将启动的选项取消勾选，然后点击完成
8在电脑左下角开始菜单里面找到Maxon Cinema 4D 2024打开文件位置
(图 8)
在电脑左下角开始菜单里面找到Maxon Cinema 4D 2024，鼠标右键更多-打开文件位置
9继续打开Maxon Cinema 4D 2024所在位置
(图 9)
选择Maxon Cinema 4D 2024，继续鼠标右键打开文件所在的位置进入安装目录
10替换安装目录corelibs文件夹文件
(图 10)
将替换文件C4D 2024.0.0文件夹的破解文件全部复制到刚才打开的安装目录的corelibs下替换
11双击运行安装包的Maxon_App_2024.0.0_Win.exe应用程序
(图 11)
双击运行安装包的Maxon_App_2024.0.0_Win.exe应用程序
12Maxon App 2024.0.0 安装
(图 12)
Maxon App 2024.0.0 安装，点击Install
13正在安装中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fea3ed5431fd8e17711b9a66d2ddd6b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c5f3b62f3b3fc0c08acd789a84f8de/" rel="bookmark">
			海洋数据资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库网址Global Colour 水色及光学参数https://hermes.acri.fr/index.phpOC CCIhttps://www.oceancolour.org/OC CCIhttps://www.oceancolour.org/thredds/catalog-cci.html?dataset=CCI_CHL-v3.1-Geographic-1kmArgo混合层深度数据http://mixedlayer.ucsd.edu/OA-Flux海洋大气耦合https://oaflux.whoi.edu/WOA 温盐MLD气候态https://www.ncei.noaa.gov/products/world-ocean-atlasNOAA NAOIhttp://www.cpc.ncep.noaa.gov/data/teledoc/telecontents.shtmlCALIPSOhttps://search.earthdata.nasa.gov/search?fdc=Atmospheric%20Science%20Data%20Center%20(ASDC) https://asdc.larc.nasa.gov/data/CALIPSO/LID_L1-Standard-V4-10/RSS红外微波ftp.remss.com/https://www.remss.com/Hycome UVhttp://ncss.hycom.org/thredds/ncss/grid/GLBu0.08/expt_19.1/2012/dataset.htmlNOAA OISSThttps://www.esrl.noaa.gov/psd/data/gridded/data.noaa.oisst.v2.highres.htmlOSTIAhttp://ghrsst-pp.metoffice.com/pages/latest_analysis/ostia.htmlOSTIAftp://podaac.jpl.nasa.gov/GHRSST/data/L4/GLOB/UKMO/OSTIA碳和叶绿素http://satellite.nsmc.org.cn/portalsite/default.aspx碳和叶绿素https://www.socat.info/碳和叶绿素https://oceandata.sci.gsfc.nasa.gov/CRAS数据https://www.marine.csiro.au/~dunn/cars2009/index.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ae159c474d89e80acec0c85bbc3653/" rel="bookmark">
			Fushion 360齿轮组制作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本教程总结 Kevin小哥的教程，原视频教程点击这里，笔者录制的教程视频见fushion 360齿轮制作
Fushion 360齿轮组制作教程 基本步骤添加齿轮工具相关设置绘制底板创建演示动画掏空较大的齿轮 视频教程及成品展示 基本步骤 添加齿轮工具 选择使用工具，选择添加附件，选择SpurGear，选择运行即可。
选择实体，即可看到齿轮工具
相关设置 使用快捷键s查找spurgear，调出工具设置页面，选择如下参数
新建第一个齿轮，其中Module与Number of Teeth 共同决定你齿轮的大小
新建第二个齿轮
选择较小的齿轮，X轴移动32+16，然后选择11.3度即可得到如下所示的结构
绘制底板 选择底面，绘制绘制草图，绘制比齿轮较大的两个圆，然后做两个圆的切线，向下偏移选3，厚度选3mm的一个底板。做底面的投影，以圆心为投影，向内偏移0.2mm，然后做向上做10mm的圆柱，在向外偏移分别根据大小齿轮，选择10mm，5mm
创建演示动画 选择装配，快速连接，将圆柱与各自对应的齿轮连接在一起，然后建立运动链接，设置如下；
演示效果如下所示：
掏空较大的齿轮 视频教程及成品展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882d21d65ad79e9936f829f6e14a66b4/" rel="bookmark">
			【C&#43;&#43;】类②
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、类访问修饰符 public(公有)： 类的内部和类的外部都能访问共有成员 private(私有)：只有类的内部和类外的友元函数可以访问私有成员 protected(受保护)：类的内部和类外的友元函数可以访问受保护成员，并且受保护成员在派生类（即子类）中是可访问的 二、构造函数与析构函数 1. 类的 构造函数 是类的一种特殊的成员函数，它会在每次创建类的新对象时执行
构造函数可用于为某些成员变量设置初始值
它与普通的成员函数在形式上有两个区别：构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void 注：构造函数可以带有参数
class student { int score; student(); }; student::student() { cout&lt;&lt;score; } 2. 类的 析构函数 是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行
析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源
它与普通的成员函数在形式上有三个区别：析构函数的名称与类的名称是完全相同的，它不会返回任何值，只是在前面加了个波浪号（~）作为前缀
注：析构函数不能带有任何参数
class student { int score; ~student(); }; student::~student() { cout&lt;&lt;score; } 3. 拷贝构造函数
拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：
通过使用另一个同类型的对象来初始化新创建的对象。
复制对象把它作为参数传递给函数。
复制对象，并从函数返回这个对象。
如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数
拷贝构造函数在类内的声明：classname (const classname &amp;obj)；
拷贝构造函数在类外的定义：classname::classname (const classname &amp;obj) { 拷贝构造函数的主体 }
4. 总结
类中的成员函数有三种：
a.普通函数b.构造函数c.拷贝构造函数d.析构函数 而每种成员函数都有两种定义方法：
a.在类内声明函数，在类外定义函数b.直接在类内定义函数 三、友元函数 友元函数既可以是不属于任何类的非成员函数，也可以是另一个类的成员函数。友元函数不是当前类的成员函数，但它可以访问该类的所有成员，包括私有成员、保护成员和公有成员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/882d21d65ad79e9936f829f6e14a66b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede8ce94a403766b825b4c379f1646eb/" rel="bookmark">
			sheng的学习笔记-【中文】【吴恩达课后测验】Course 2 - 改善深层神经网络 - 第二周测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程2_第2周_测验题 目录：目录
第一题 1.当输入从第8个mini-batch的第7个的例子的时候，你会用哪种符号表示第3层的激活？
A. 【 】 a [ 3 ] { 8 } ( 7 ) a^{[3]\{8\}(7)} a[3]{8}(7)
B. 【 】 a [ 8 ] { 7 } ( 3 ) a^{[8]\{7\}(3)} a[8]{7}(3)
C. 【 】 a [ 8 ] { 3 } ( 7 ) a^{[8]\{3\}(7)} a[8]{3}(7)
D. 【 】 a [ 3 ] { 7 } ( 8 ) a^{[3]\{7\}(8)} a[3]{7}(8)
答案：
A.【 √ 】 a [ 3 ] { 8 } ( 7 ) a^{[3]\{8\}(7)} a[3]{8}(7)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ede8ce94a403766b825b4c379f1646eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a8e54c794970900d3b4c24ec9c975a/" rel="bookmark">
			sheng的学习笔记-【中英】【吴恩达课后测验】Course 1 - 神经网络和深度学习 - 第四周测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程1_第4周_测验题 目录：目录
第一题 1.在我们的前向传播和后向传播实现中使用的 “缓存” 是什么？
A. 【 】它用于在训练期间缓存成本函数的中间值。
B. 【 】我们用它将在正向传播过程中计算的变量传递到相应的反向传播步骤。它包含了反向传播计算导数的有用值。
C. 【 】它用于跟踪我们正在搜索的超参数，以加快计算速度。
D. 【 】我们用它将反向传播过程中计算的变量传递到相应的正向传播步骤。它包含用于计算正向传播的激活的有用值。
答案：
B.【 √ 】我们用它传递前向传播中计算的变量到相应的反向传播步骤，它包含用于计算导数的反向传播的有用值。
note：“cache” 记录来自正向传播单元的值并将其发送到反向传播单元，因为需要链式计算导数。
第二题 2.以下哪些是“超参数”？(选出所有正确项)
A. 【 】隐藏层规模 n [ l ] n^{[l]} n[l]
B. 【 】神经网络的层数 L L L
C. 【 】激活向量 a [ l ] a^{[l]} a[l]
D. 【 】权重矩阵 W [ l ] W^{[l]} W[l]
E. 【 】学习率 α \alpha α
F. 【 】迭代次数
G. 【 】偏置向量 b [ l ] b^{[l]} b[l]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9a8e54c794970900d3b4c24ec9c975a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b86e410c16975c80aadb70eac197ba/" rel="bookmark">
			sheng的学习笔记-【中文】【吴恩达课后测验】Course 1 - 神经网络和深度学习 - 第三周测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程1_第3周_测验题 目录：目录
第一题 1.以下哪一项是正确的？
A. 【 】 a [ 2 ] ( 12 ) a^{[2](12)} a[2](12)是第12层，第2个训练数据的激活向量。
B. 【 】X是一个矩阵，其中每个列都是一个训练示例。
C. 【 】 a 4 [ 2 ] a^{[2]}_4 a4[2]​ 是第2层，第4个训练数据的激活输出。
D. 【 】 a 4 [ 2 ] a^{[2]}_4 a4[2]​ 是第2层，第4个神经元的激活输出。
E. 【 】 a [ 2 ] a^{[2]} a[2] 表示第2层的激活向量。
F. 【 】 a [ 2 ] ( 12 ) a^{[2](12)} a[2](12)是第2层，第12个数据的激活向量。
G. 【 】 X X X是一个矩阵，其中每个行是一个训练数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b86e410c16975c80aadb70eac197ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5804b902fcdac476115e0f23ee6ac44f/" rel="bookmark">
			JMM &amp; JVM &amp; 垃圾回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、JMM内存模型 1、定义
2、JMM的三大特性(可见性+原子性+有序性)
2.1 可见性
2.2 原子性
2.3 有序性
3、JMM中的8种原子操作
二、JVM
1、JVM体系结构（类加载子系统+运行时数据区+执行引擎）
1.1 类装载子系统
（1）类加载器(ClassLoader)
（2）JVM类加载机制(全盘负责+父类委托+双亲委派模型)
1.2 运行时数据区
（1）方法区
（2）Java堆
（3）JVM栈
（4）本地方法栈
（5）程序计数器
1.3 字节码执行引擎
2、JVM参数调优
2.1 三大参数类型
2.2 九个调优参数
三、垃圾回收器
1、GCRoot和可达性分析
1.1 垃圾：内存中已经不再被使用的空间1.2 如何判断垃圾(引用计数法、可达性分析)
2、4种GC算法(引用计数 /复制拷贝/标记清除/标记整理)
3、4种垃圾回收器
3.1 主要4个(Serial / Parallel / CMS / G1)
3.2 其它3个(ParNew / ParallelOld / SerialOld)
4、使用范围
本文通过学习：周阳老师-尚硅谷Java大厂面试题第二季 总结的JMM,JVM,GC垃圾回收相关的笔记
一、JMM内存模型 1、定义 JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式
JMM关于同步的规定：
（1）线程解锁前，必须把共享变量的值刷新回主内存
（2）线程解锁前，必须读取主内存的最新值，到自己的工作内存
（3）加锁和解锁是同一把锁
主内存计算机的内存，也就是经常提到的8G内存，16G内存工作内存实例化 new student，那么 age = 25 也是存储在主内存中。当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝 2、JMM的三大特性(可见性+原子性+有序性) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5804b902fcdac476115e0f23ee6ac44f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b829619e01a16dee1736d10f3e109f/" rel="bookmark">
			使用Anaconda创建Python虚拟环境并在Pycharm项目中调用该环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用Anaconda创建Python虚拟环境 1.使用cmd创建虚拟环境
在cmd中输入命令：
conda create -n your_env_name python=3.7 其中：your_env_name为要创建的虚拟环境名，python=3.7为指定python版本为3.7，不加则默认为 Anaconda 的 python 版本
输入命令后，需要输入一个y并回车。输入完成后，一个python虚拟环境就创建好了。
2.查看虚拟环境
有时候我们需要查看我们的虚拟环境，可以在 cmd 里面输入：
conda env list 就可以查看所有的python虚拟环境了。
如下图所示，目前共有两个虚拟环境
*号表示目前所处的环境位置
3.激活虚拟环境
如果想要使用你所创建的python虚拟环境，首先就要激活你想用的虚拟环境
激活虚拟环境的命令：
conda activate your_env_name 可以看到，在激活虚拟环境temperature_change之后，在cmd的前面会显示所激活虚拟环境的名称。
注意：首次使用conda activate temperature_change激活虚拟环境时报错
提示：IMPORTANT: You may need to close and restart your shell after running 'conda init'.
原因：当前使用的 shell 没有配置好 conda activate，需要运行 conda init 初始化 shell
解决方法：根据提示运行conda init，重启shell后即可正常使用conda activate激活虚拟环境的指令
4.为虚拟环境安装包
可以看到，在新建虚拟环境后，一个包都没有。那怎么去安装包呢？
这里提供两种方法：
(1)激活了虚拟环境
如果激活了虚拟环境，使用 pip install xxx 或 conda install xxx ，就可以安装包了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b829619e01a16dee1736d10f3e109f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3c24e172644a2a4a7a25d8f69e6923/" rel="bookmark">
			C&#43;&#43;快读和快写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 虽然读入优化好像用处不大，但是还是能够在读入数据规模较大的时候提供较大的优化，比如：
用cin输出2000个100000000
用快输输出2000个100000000
单位都是毫秒。可以直观的发现，用快输的话输出时间优化了很多，那么快读是如何做到这样的呢？
原理 众所周知，在c++中，用putchar和getchar输入输出字符的速度是很快的，因此，我们可以考虑把数字转化为字符，按位输出；把字符读入后转化为数字的每一位。
快读 普通快读： 可以读入任意整数类型的变量
template&lt;typename T&gt;inline void readT(T &amp;x){ bool f=1;x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-') f=!f;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();} x=(f?x:-x);return; } 读入__int128： __int128只能用快读读入
inline void read128(__int128 &amp;x){ bool f=1;x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-') f=!f;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();} x=(f?x:-x);return; } 超级快读： 经实测，只能读入整数
char buf[1&lt;&lt;20],*p1,*p2; #define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf,1,1&lt;&lt;20,stdin), p1 == p2) ? 0 : *p1++) template&lt;typename T&gt;inline void readT(T &amp;x){ bool f=1;x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-') f=!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3c24e172644a2a4a7a25d8f69e6923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab3a04ce4c749e9551d5c037e17c5c3/" rel="bookmark">
			实现 Windows 系统定时关机或重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 1. 下载大量内容需要挂机？想要下载完成后自动关机？
2. 想要电脑长期运行后自动重启？
3. 亦或是有其他原因需要让你的 Windows 电脑定时关机或重启？
教程 实现原理：利用 bat 脚本进行处理
具体步骤：
1. 在桌面新建一个TXT文本文件
2. 双击打开，然后将本文章底部的"源码"的内容全部复制并粘贴进去
3. 点击左上角的"文件"，然后点击"另存为"
4. 在弹出的框中，编码处选择：ANSI（注意: 不要使用其他编码，否则会出现乱码的情况）
5. 文件名随意，本文使用：shutdown 。在选择好保存的位置后，点击保存即可
6. 保存后，会出现一个名为：shutdown.txt 的文本文件
7. 修改该文件的后缀名为 bat，即：将该文件的名字改为：shutdown.bat
8. 当提示警告时，点击确认修改即可
8. 双击即可运行
9. 教程结束
源码 @echo off rem 以管理员的身份运行该脚本 &gt;nul 2&gt;&amp;1 "%SYSTEMROOT%\system32\cacls.exe" "%SYSTEMROOT%\system32\config\system" if '%errorlevel%' NEQ '0' ( goto UACPrompt ) else ( goto gotAdmin ) :UACPrompt echo Set UAC = CreateObject^("Shell.Application"^) &gt; "%temp%\getadmin.vbs" echo UAC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab3a04ce4c749e9551d5c037e17c5c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0dc91f42d78f88de1d21746bc7a3c14/" rel="bookmark">
			shell获取应用程序和函数的返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 获取应用程序的返回值：获取函数的返回值： Shell脚本中，你可以使用特殊变量 $? 来获取上一个命令的返回值。这个变量将包含上一个命令的退出状态码。
下面是一些示例：
获取应用程序的返回值： # 运行应用程序 ./my_application # 获取应用程序的返回值 return_value=$? # 打印返回值 echo "应用程序的返回值是：$return_value" 获取函数的返回值： # 定义函数 my_function() { # 在此处执行一些操作 # ... return 5 # 返回值为5 } # 调用函数 my_function # 获取函数的返回值 return_value=$? # 打印返回值 echo "函数的返回值是：$return_value" 在上述示例中，return_value 变量将包含应用程序或函数的返回值。你可以根据需要对其进行进一步处理或打印出来。请注意，$? 变量将获取上一个命令的返回值，因此请确保在获取返回值之前只运行你想要监视的命令或函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbdd9c9057105256f0b6e31b3d193978/" rel="bookmark">
			React Native 中实现打字机效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接运行即可
import React, { Component } from 'react'; import { View, Text, StyleSheet } from 'react-native'; export default class TypewriterText extends Component { constructor(props) { super(props); this.state = { text: '', }; } componentDidMount() { this.getUrlsFromApi(); } getUrlsFromApi() { // 假设这里从后端接口获取URLs的数据，并模拟一个异步请求 fetch('https://api.test.com/frontapi/get_app_list') .then((response) =&gt; response.json()) .then((data) =&gt; { // 假设这里获取到了URLs的数据，将 "Data initialization successful" 作为文字内容 const successText = 'Data initialization successful'; let currentText = ''; let currentIndex = 0; const typeNextLetter = () =&gt; { if (currentIndex &lt; successText.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbdd9c9057105256f0b6e31b3d193978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6aa8913fb5aa530475ec9f30c49a330/" rel="bookmark">
			Pulumi对比terraform管理cloud公有云总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pulumi 用Pulumi实现IAAS，管理公有云资源，实际生产环境下，难免手动对公有云资源手动增删改，导致实际资源与Pulumi code和state file不一致，以下介绍不一致的情况下如何处理，以及相比于Terraform管理公有云资源有何异同和优势。
azure portal上，手动改变vm size大小，由Dv2扩为Dv3 pulumi code和state file不做update，运行pulumi apply后，没有change发生；改变pulumi代码中的vm size，由Dv2改为Dv3。此时pulumi code和实际的资源都是Dv3，,Pulumi state file仍然是Dv2，此时运行pulumi up，state file会同步为Dv3，“三方”状态保持一致；假设此时pulumi code中的size假设改为Dav4，实际vm size是手动更为为Dv3，state file仍然是Dv2。三方都不一样，此时pulumi up，azure 中的 vms size和state file中的size都会被updated和code中的size保持一致，以code为准。
通过以上可以说明，被pulumi管理的资源，手动更改某些配置后，然后同步pulumi 代码，不会出现把旧的删除，然后再添加新的情况，这点要比tf好。 手动删除Azure vm pulumi code和state file不做update，运行pulumi apply后，没有change发生；删除code中对应vm资源，同步代码，运行pulumi apply后，资源自动同步； 手动增加Azure vm pulumi code和state file不做update，运行pulumi apply后，没有change发生，即新添加的资源不受pulumi管理如果需要纳入到pulumi来管理，直接用pulumi import同步state file文件和实际资源一致即可，此处和terraform import类似，同步完state file后，还需要在pulumi code中加入相应资源，如下例子，手动建了一个Azure resource group后：
2.1. 导入资源同步state file# pulumi import command 导入azure资源组，以下以导入Azure resource group资源为例 pulumi import azure-native:resources:ResourceGroup Pulumi-Test /subscriptions/67aa02ec-a43c-4b62-808a-12113f131ee8/resourceGroups/Pulumi-Test # terraform import command 以下以添加一个GCP instance 为例，对比pulumi import terraform import 'google_compute_instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6aa8913fb5aa530475ec9f30c49a330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9eaeabb613d9c274d486beeb43ff9ff/" rel="bookmark">
			anaconda安装&#43;创建python3.7&#43;安装pytorch1.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装anaconda
1.1 我们需要首先赋权再执行安装程序，依次输入下面两句命令:
chmod +x Anaconda3-5.3.0-Linux-x86_64.sh
./Anaconda3-5.3.0-Linux-x86_64.sh
然后出现下面图所示:
1.2 此时显示Anaconda的信息，并且会出现More，继续按Enter，直到如下图所示 输入 yes, 继续往后输入安装位置，若是默认位置直接按回车:
1.3 添加环境变量 输入yes
2、创建环境
先测试conda是否安装成功,输入以下命令显示base conda环境
conda env list 创建新的python3.7环境
conda create -n py3.7-torch1.7 python=3.7 3、安装pytorch1.7 (参考：)
pip install torch1.7.1+cu110 torchvision0.8.2+cu110 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html
参考：https://pytorch.org/get-started/previous-versions/ （官方）
https://blog.csdn.net/wyf2017/article/details/118676765
https://blog.csdn.net/yup1212/article/details/124277058（不同版本参考）
另：安装pytorch1.9(使用国内镜像更快)
pip install torch==1.9.1+cu111 torchvision==0.10.1+cu111 torchaudio==0.9.1 -f https://download.pytorch.org/whl/torch_stable.html -i https://pypi.douban.com/simple/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4cb148c539f95862ca05acccaee9c32/" rel="bookmark">
			vue 路由判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决的一个问题分享。我的需求是从特定的页面进入当前页面会执行一个定时器来增加阅读人数，当进入该页面15秒后浏览人数会增加1。
话不多说直接上代码。先在methods里定义一个定时器方法和一个修改浏览人数方法。
​ methods: { // 增加阅读人数 setpeople(){ console.log('定时器开启'); // overTimer 这个值可以写在data里面 //也可以直接用 const overTimer = setTimeout(() =&gt;{},15000) this.overTimer = setTimeout(() =&gt; { this.artical_peo = this.artical_peo + 1 this.setpeo() }, 15000) }, // 修改阅读人数 setpeo(){ let params = `artical_peo=${this.artical_peo}&amp;&amp;id=${this.id}` this.axios.put('/read',params).then(res=&gt;{ // console.log(res); }) }, 写完之后要用到一个钩子函数beforeRouteEnter来进行路由的相关操作
// 超时定时器 overTimer: 15000, sname:'' } }, // 监测路由跳转 beforeRouteEnter (to, from, next) { console.log('要跳到的页面',to.name) console.log('从那个页面跳过来',from.name) // console.log(next) next(vm =&gt;{ //这里把获取到的from.name给到data里面定义的sname vm.sname = from.name // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4cb148c539f95862ca05acccaee9c32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5953fb15c100720b920d4dc1593c9aac/" rel="bookmark">
			导出docker镜像并压缩、解压并导入镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导出镜像并压缩：
docker save &lt;myimage&gt;:&lt;tag&gt; | gzip &gt; &lt;myimage&gt;_&lt;tag&gt;.tar.gz 解压并导入镜像：
gunzip -c &lt;myimage&gt;_&lt;tag&gt;.tar.gz | docker load 2022年10月21日：
我这边再增加一个例子：
docker save centos:latest -o /root/centos_latestimage docker rmi docker:latest docker images docker load -i /root/centos_latestimage docker images 还有一个问题需要注意的是：
对于容器，可以使用import和export 进行导入导出操作。
对于已有镜像，可以使用docker命令行的save和load命令来创建压缩包tarball。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/47/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>