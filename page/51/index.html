<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadd503314b168b353ca935397fe2290/" rel="bookmark">
			从ReentrantLock来学习AQS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，AQS是Java用来构建同步工具的基本组件，我们常用的ReentrantLock，Semaphore等同步器都是基于AQS来构建的，这里我们从ReentrantLock这个最简单的同步锁来入手，学习AQS的基本思想。JDK源码基于JDK17，对比一下与JDK1.8在细节上有一些不同。
这里假定各位对AQS有一些基本了解，不再对AQS的原理进行介绍。
ReentrantLock#lock() @ReservedStackAccess final void lock() { if (!initialTryLock()) acquire(1); } initialTryLock方法会尝试去获取锁，这里公平锁和非公平锁有一些不同，公平锁会先判断当前队列是否为空，为空才会尝试获取
// NonfairSync final boolean initialTryLock() { Thread current = Thread.currentThread(); if (compareAndSetState(0, 1)) { // first attempt is unguarded setExclusiveOwnerThread(current); return true; } else if (getExclusiveOwnerThread() == current) { int c = getState() + 1; if (c &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(c); return true; } else return false; } //FairSync final boolean initialTryLock() { Thread current = Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fadd503314b168b353ca935397fe2290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8e026102b5a265434c694931d4f5e4/" rel="bookmark">
			SQL数据分析实战：从导入到高级查询的完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当进行SQL数据分析实战时，有一些关键步骤和技巧可以帮助你更好地理解和利用数据。在本文中，我们将探讨数据分析的一些基本概念，并提供一些SQL示例来说明这些概念。我们将使用一个虚构的电子商务数据库作为示例数据源。
步骤1：数据导入 首先，你需要将数据导入数据库中。假设你有一个包含订单、产品和客户信息的数据库。以下是一个示例SQL语句，用于创建这些表并将数据导入其中：
-- 创建订单表 CREATE TABLE orders ( order_id INT PRIMARY KEY, customer_id INT, order_date DATE, total_amount DECIMAL(10, 2) ); -- 创建产品表 CREATE TABLE products ( product_id INT PRIMARY KEY, product_name VARCHAR(255), unit_price DECIMAL(10, 2) ); -- 创建客户表 CREATE TABLE customers ( customer_id INT PRIMARY KEY, customer_name VARCHAR(255), email VARCHAR(255) ); -- 导入数据 INSERT INTO customers (customer_id, customer_name, email) VALUES (1, 'John Smith', 'john@example.com'), (2, 'Jane Doe', 'jane@example.com'); INSERT INTO products (product_id, product_name, unit_price) VALUES (101, 'Laptop', 800.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8e026102b5a265434c694931d4f5e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc46b7f2d8574fa88e143649b7b44ac/" rel="bookmark">
			Linux之使用LAMP搭建私有云存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Linux之使用LAMP搭建私有云存储
恢复快照，关闭安全软件
搭建LAMP环境
下载安装依赖包
下载nextcloud软件
解压nextcloud
设置nextcloud安装命令权限
数据库配置
设置数据库
重启数据库
配置httpd
重启httpd服务
安装
打开浏览器后输入服务器IP地址，进入nextcloud安装向导
管理员的用户名即密码自定
存储与数据库：选择MySQL/MariaDB，设置数据库用户为nextcloud，密码：123456，数据库名：nextcloud，主机名：localhost Linux之使用LAMP搭建私有云存储 恢复快照，关闭安全软件 [root@www ~]# setenforce 0 [root@www ~]# systemctl stop firewalld 搭建LAMP环境 下载安装依赖包 [root@www ~]# yum install httpd mariadb-server php* -y 注意：如果出现安装冲突可更改为以下命令
[root@www ~]# yum install httpd mariadb-server php* -y --allowerasing 下载nextcloud软件 [root@www /]# wget https://download.nextcloud.com/server/releases/nextcloud-25.0.1.zip 建议 --- 下载好后，再通过xftp传输到Linux中
解压nextcloud [root@www /]# unzip nextcloud-25.0.1.zip 设置nextcloud安装命令权限 [root@www /]# chmod -Rf 777 /nextcloud 数据库配置 设置数据库 [root@www ~]# systemctl start mariadb [root@www /]# mysql -uroot -p Enter password: #默认初始没有密码 # 数据库设置 MariaDB [(none)]&gt; create database nextcloud; # 创建数据库 MariaDB [(none)]&gt; create user 'nextcloud'@'localhost' identified by '123456'; # 创建用户及密码 MariaDB [(none)]&gt; grant all on nextcloud.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc46b7f2d8574fa88e143649b7b44ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d346b0a3e62261f8497a9da5de7f50/" rel="bookmark">
			Linux常见面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是 Linux？ Linux 是一种开源操作系统内核。它最初由 Linus Torvalds 在 1991 年创建，以稳定、可靠和安全为设计原则。Linux 被广泛用于服务器、嵌入式设备以及个人计算机等领域。
2、如何查看 Linux 的版本？ 要查看 Linux 发行版的版本信息，可以使用 lsb_release -a 命令。这个命令会显示发行版的详细信息，包括版本号、发行日期等。另外，可以使用 uname -r 命令查看内核版本。
3、如何在 Linux 中创建用户？ 可以使用 useradd 命令来创建用户。例如，要创建一个名为 “john” 的用户，可以运行 useradd john。创建用户后，还需要为其分配密码和设定其他设置。
4、如何修改用户的密码？ 可以使用 passwd 命令修改用户的密码。例如，要修改用户 “john” 的密码，可以运行 passwd john。然后按照提示输入新的密码即可。
5、如何查看文件的内容？ 在 Linux 中，可以使用 cat 命令来查看文件的内容。只需简单地运行 cat filename 命令，其中 “filename” 是你想要查看的文件名。
6、如何列出当前目录的文件和子目录？ 要列出当前目录的文件和子目录，可以使用 ls 命令。运行 ls 命令即可显示当前目录中的所有文件和文件夹。
7、如何在 Linux 中安装软件？ 在大多数 Linux 发行版中，都有自己的包管理器来安装软件。例如，在 Ubuntu 中可以使用 apt 命令，而在 CentOS 中可以使用 yum 命令。使用适当的包管理器，运行类似 sudo apt install package_name 的命令即可安装所需的软件包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d346b0a3e62261f8497a9da5de7f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e01afe9a9678e296c8d979f992aef9/" rel="bookmark">
			不同场景下的JMETER设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同场景下的JMETER设置 1.基准测试
验证主要业务在单用户运行下的性能指标，为多用户并发并发和混合场景的性能分析提供基础参考。
基准测试JMETER线程组设置(在1秒内执行5个线程循环一次)：
2.并发测试
多用户在同一时间访问某一个模块或则应用的场景，验证用户在多并发情况的性能指标。
并发测试JMETER线程组设置（在达到并发数100时同时释放请求）：
3.负载测试
对所测试的模块或应用，不断的增加模拟用户数，判断在不同模拟用户下响应时间，TPS，服务器相关资源运行情况，找到系统可能存在的性能瓶颈。找到系统支持的最大用户数和最大TPS。
4.压力测试
检验系统在高压的状态下，系统的稳定性和容错率，压力测试分为：稳定性测试（24小时以上），极限负载情况下导致系统崩溃下的压力测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f17ee707aff4d520369f68dbe53da7/" rel="bookmark">
			05_css选择器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、css选择器的类型 1、标签选择器 用法：直接写 写标签名：标签名{}
示例：
&lt;!-- &lt;!DOCTYPE html --&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标签选择器&lt;/title&gt; &lt;style type="text/css"&gt; div { text-align: center; width: 600px; height: 400px; color: blue; background: blanchedalmond; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 标签名是：div --&gt; &lt;div&gt;使用标签选择器添加样式&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2、id选择器 用法：元素的id属性：#id名{}
示例：
&lt;!-- &lt;!DOCTYPE html --&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;id选择器&lt;/title&gt; &lt;style type="text/css"&gt; #type { text-align: center; width: 600px; height: 400px; color: blue; background: blanchedalmond; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- id名是：type --&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2f17ee707aff4d520369f68dbe53da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c241ca2c18a041c2bb55ec4b131b89/" rel="bookmark">
			02_CSS样式之背景参数设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设置背景颜色 设置背景颜色可用参数：
**可用参数一： background ** **可用参数二：background-color ** 注意参数一和参数二 ：任意选择一个使用即可 例如：
&lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;背景颜色设置&lt;/title&gt; &lt;style type="text/css"&gt; div { height: 600px; /* 1.设置背景颜色:background 或者 background-color */ background:red; background-color:yellowgreen } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;背景设置的使用&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 二、设置背景图片 把图像设置为背景：
可用参数一： background-image 属性的默认值是 none,表示背景上没有放置任何图像 如果需要设置一个背景图像,必须为这个属性设置一个 URL 值 例如：
&lt;!-- &lt;!DOCTYPE html --&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div { height: 600px; /* 2.设置图像为背景图像:background-image */ background-image: url(./600.jpg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;设置背景图片&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 三、设置背景平铺 需要在页面上对背景图像进行平铺：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68c241ca2c18a041c2bb55ec4b131b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fa702c43e54edf3b3b57761d862d74/" rel="bookmark">
			程序员必须掌握的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为程序员，掌握一些基本的算法是非常重要的，因为它们可以帮助你更高效地解决编程问题。以下是一些程序员必须掌握的基本算法：
1. 搜索算法 （1）线性搜索：最简单的搜索算法，从数组的第一个元素开始搜索，直到找到目标元素或搜索到最后一个元素为止。
（2）二分搜索：在有序数组中，通过将目标值与数组中间元素进行比较，每次可以排除一半的元素，直到找到目标元素或确定目标元素不存在于数组中。
（3）递归搜索：通过将问题分解为更小的子问题来解决问题，直到子问题可以直接解决为止。
（4）广度优先搜索：在图或树中，从根节点开始，遍历所有相邻节点，然后再遍历它们的相邻节点，直到找到目标节点或遍历完整个图/树。
2. 排序算法 （1）冒泡排序：通过比较相邻元素的大小，每次将两个相邻元素交换位置，直到整个序列有序为止。
（2）选择排序：每次从未排序的部分中找到最小（或最大）元素，放到已排序部分的末尾，直到未排序部分为空。
（3）插入排序：将未排序的元素一个个插入到已排序部分的正确位置。
（4）快速排序：通过选择一个基准元素将数组分为两部分，左边的元素都小于基准，右边的元素都大于基准，然后对左右两部分递归地进行快速排序。
（5）归并排序：采用分治策略，将序列分成两个子序列，分别进行排序，然后将两个有序子序列合并成一个有序序列。
3. 图算法 （1）最短路径算法：在图中找到两个节点之间的最短路径，如 Dijkstra 算法和 Bellman-Ford 算法。
（2）最小生成树算法：在连通图中找到一棵包含所有节点的树，并且所有边的权值之和最小，如 Prim 算法和 Kruskal 算法。
（3）拓扑排序算法：在有向无环图中找到一种线性顺序，使得每个节点的前驱节点按照该顺序出现在它的前面，如 Kahn 算法和 topological-sort 函数。
（4）强连通分量算法：在有向图中找到强连通分量的个数及它们之间的关系，如 Tarjan 算法和 Kosaraju 算法。
4. 动态规划算法 动态规划是一种通过将问题分解为子问题来解决问题的方法。它将每个子问题的解存储起来，以便在需要时可以重复使用它们，而不是重新计算它们。以下是一些常见的动态规划算法：
（1）斐波那契数列：使用递归或循环计算斐波那契数列中的第 n 个数。使用动态规划可以避免重复计算。
（2）背包问题：给定一组物品，每个物品都有自己的重量和价值，要求在不超过背包总重量的情况下，选择一组物品使得它们的总价值最大。可以使用动态规划求解。
（3）最长公共子序列：给定两个序列，找到它们的最长公共子序列。可以使用动态规划进行求解。
这些算法是程序员必须掌握的基本算法。当然还有许多其他的算法也很重要，比如分治算法、回溯算法等等。总之，程序员应该不断学习和掌握新的算法，以便更好地解决编程问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7611a42fbe1f59975396d22951b601f6/" rel="bookmark">
			7、NoClassDefFoundError: sun/misc/BASE64Encoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 Caused by: java.lang.NoClassDefFoundError: sun/misc/BASE64Encoder 原因分析： sun/misc/BASE64Encoder，只有在jdk1.8之前的版本存在，jdk9以后的版本，就不存在了。如果出现这样的错误，检查自己当前的jdk版本。
解决方案： 使用 import org.apache.commons.codec.binary.Base64对原先sun/misc/BASE64Decoder进行替换
加密改为：Base64.encodeBase64String(xxx);
解密改为：Base64.decodeBase64(xxx);
导包改为：import org.apache.commons.codec.binary.Base64;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36f2aea35419c54c12684d0e647cc07/" rel="bookmark">
			基于STM32智能环境系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本系统采用stm32f407作为主控芯片，实现对环境的监测。并且通过和手机通信，获取当前的天气预报信息，结合当前测得的温湿度，可以为用户提供出行建议。利用stm32自带的RTC可以实现时间及闹钟功能。此外RTC还可以用于电子日历的制作。从机主控芯片是STM32f103，其主要功能是测取当前的温湿度信息和语音识别。主从机通过nrf24l01无线通信。
引言 科技发展越来越快，我们将要进入物联网的世界。利用已经成熟的温湿度传感器技术，可以获得当前的温湿度信息；利用已经很成熟的光敏传感器技术可以获得当前的光照强度。如果我们将这些信息搜集起来，通过微处理器分析，从而给出控制信息，实现智能控制。我们所要做的事情就是：通过微处理器丰富的外设，来获取周围信息。再分析这些数据，利用自动控制算法，控制外围器件，实现环境的调控。
系统方案 一、温湿度监测模块：1.与数字温度传感器通信，获取当前的温湿度信息。
2.将获得温湿度信息进行滤波处理
3.将温湿度数据打包传送给上位机
4.上位机接受下位机传输数据，将数据解包存储
5.上位机数据分析
该模块中最关键的算法是数据滤波，代码如下：
#define N 11
char filter()
{
char value_buf[N];
char count,i,j,temp;
for ( count=0;count&lt;N;count++)
{
value_buf[count] = get_ad();
delay();
}
for (j=0;j&lt;N-1;j++)
{
for (i=0;i&lt;N-j;i++)
{
if ( value_buf[i]&gt;value_buf[i+1] )
{
temp = value_buf[i];
value_buf[i] = value_buf[i+1];
value_buf[i+1] = temp;
}
}
}
return value_buf[(N-1)/2];
}
二、光照强度监测模块
本模块比较简单。通过监测光敏电阻两端的电压，来获得电压数据。再将电压数据转化成光照强度数据。检测电压的方法是采用STM32F407的AD模块来实现。同上一个模块一样，要对数据进行滤波处理。算法如上。
三、2.4G无线通信模块
本模块是连接主从机的关键模块。采用的通信芯片是NRF24L01。该芯片内部包括频率发生器、增强型ShockBurst模式控制器、功率放大器、晶体振荡器、调制器、解调器等功能模块。通信接口为SPI，待机电流22uA。
该模块的使用主要是通过对其进行初始化、再选择工作状态（RX/TX）、发送或接收数据。通过软件查询方式，来通信。前期调试时，下位机由于以前调试过，没有遇到什么问题。主要是在STM32F407上由于干接触，还不太了解该SPI库函数的使用方法，犯了一些低级错误。后期调好之后没有出现过大的问题。
蓝牙通信模块 蓝牙通行模块是用于与智能手机及电脑通信的。本系统通过该模块与手机通信，获取当前的天气预报信息。此外，还可通过智能手机、电脑等获取本系统当前的信息以及控制本系统。该模块与ＳＴＭ３２ｆ４０７通过ＵＳＡＲＴ通信。主要难点是：控制指令是ＡＴ指令。由于此前没有学习过该指令，学习该指令花费了几天时间。该模块稳定性高，调试成功后一直没有出现过大的问题。
五、SYN6288合成语音模块
本模块采用ＵＳＡＲＴ进行通信。该语音合成芯片，支持多种编码的数据。如：ＡＳＩＣ　ＧＢＫ　ＵＴＦ等。语音合成数据通过打包发送到该模块。
支持多音字及人名的智能识别。该模块控制命令多大几十条，可以很好的实现对输出音量、语速、背景音、多音字识别、强制连读等调控。该模块实现时遇到两个难题：１、多指令的学习使用问题　２、电流干扰问题。第一个问题通过学习该芯片使用手册很快得到了解决。第二个问题的现象是，每当播放语音时，显示屏上就会乱码。经过多次检测，发现问题是该模块播音时电流变化大，对开发板上的电源产生了干扰。解决办法是采用外界电源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f36f2aea35419c54c12684d0e647cc07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a734a63fd15d5c671cbaab20f6f7d6/" rel="bookmark">
			Anaconda配置虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写此博客只为记录自己的学习生活，若有不当之处，还望指出，本人定当好好学习 为什么需要配置虚拟环境 为了更有序的管理环境； 1、当我们遇到不同的项目时，他们可能需要的环境也是不同的，比如有的项目需要python3.6，有的需要python3.8，等等，如果我们只有一个环境的话，那意味着我们需要另一种环境的话，就必须删除当前版本，安装另一种版本，这当让然很麻烦了；
2、Acaonda集成的conda包就能解决这个问题，它可以创造出不同的环境，并且相互隔离，当我们需要哪一个版本的环境时，选择它就可以了。
如何配置虚拟环境 前提是已经安装了Anaconda； 1、打开Anaconda命令窗口，如下图：
注意：前面的base表示的Anaconda当前的环境，也是起始位置下的默认环境；
（2）创建一个虚拟环境：
以上是创建虚拟环境的基本语法，
其中***表示所要创建的环境名称；3.X表示所要python的具体版本；
（3）举例：
创建一个环境名为：test， python版本为：3.6的虚拟环境；
①
②
按Enter等待…
出现以上页面时，输入Y即可，表示同意安装所需要的一些package；
此时表示已经虚拟环境已经创建完成；
③激活所创建的虚拟环境：
注意：test是我刚刚创建的虚拟环境的名称；
④按Enter即可跳转到test这个虚拟环境下：
注意：此时最左边的（base）已经转换成了（test），表示已经处于我们的test环境中了；
⑤此时需要在这个虚拟环境中安装什么package的话，就按照Anaconda安装package的方式进行安装就可以了；并且安装的package都只会装在我们的虚拟环境下，而不会影响到其他的环境；
（4）关闭虚拟环境：
（5）删除虚拟环境：
注意：是在base下进行操作的；（test我刚刚创建的虚拟环境名称）
====================== 分割线======================
如何将虚拟环境配置到指定目录下 conda create --prefix=F:\conda\py35 python=3.5 若想要知道是否在其他盘符下存在虚拟环境？ 还是在base下输入命令：conda env list 激活指定目录下的虚拟环境 conda activate F:\conda\py35 删除指定目录下的虚拟环境 参考：https://blog.csdn.net/black000shirt/article/details/129791807 *写此博客只为记录自己的学习生活，若有不当之处，还望指出，本人定当好好学 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299b11d54f482767adff934fbcba2196/" rel="bookmark">
			Java特性之设计模式【抽象工厂模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、抽象工厂模式 概述
抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式
在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象
抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类。通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品
主要解决：主要解决接口选择的问题
何时使用：我们明确地计划不同条件下创建不同实例时
优缺点
优点：
当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象
缺点：
产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码
1. 各个角色介绍 1.1 抽象工厂（Abstract Factory） 声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类
1.2 具体工厂（Concrete Factory） 实现了抽象工厂接口，负责创建具体产品对象的实例
1.3 抽象产品（Abstract Product） 定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法
1.4 具体产品（Concrete Product） 实现了抽象产品接口，定义了具体产品的特定行为和属性
2. UML图 将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer
AbstractFactoryPatternDemo 类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型
3. 具体例子和代码 角色分配
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/299b11d54f482767adff934fbcba2196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c2946cf72fcc96bf823b00d816a2b3/" rel="bookmark">
			Java特性之设计模式【建造者模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、建造者模式 概述
建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式
一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的
主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定
何时使用：一些基本部件不会变，而其组合经常变化的时候
优缺点
优点：
分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示可以更好地控制构建过程，隐藏具体构建细节代码复用性高，可以在不同的构建过程中重复使用相同的建造者 缺点：
如果产品的属性较少，建造者模式可能会导致代码冗余建造者模式增加了系统的类和对象数量 1. 各个角色介绍 我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中
我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中
然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal
2. UML图 3. 具体例子和代码 角色分配
Item：食物条目接口 Burger：汉堡抽象类（实现食物条目接口） VegBurger：素食汉堡（继承汉堡抽象类）ChickenBurger：鸡肉汉堡（继承汉堡抽象类） ColdDrink：冷饮抽象类（实现食物条目接口） Coke：可口可乐（继承冷饮抽象类）Pepsi：百事可乐（继承冷饮抽象类） Packing：食物包装接口 Wrapper：纸盒包装（实现食物包装接口）Bottle：瓶包装（实现食物包装接口） Meal：套餐（包含食物条目列表）MealBuilder：套餐建造者（建造套餐） 3.1 食物条目接口以及实现类 Item package com.vinjcent.prototype.builder; /** * @author vinjcent * @description 食物条目接口 */ public interface Item { /** * 获取食物名称 * * @return 返回食物名称 */ String name(); /** * 打包方式 * * @return 包装接口 */ Packing packing(); /** * 食物价格 * * @return 返回食物价格 */ float price(); } Burger package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c2946cf72fcc96bf823b00d816a2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dce710bcd32ccb73ce7b3906ccc38a4/" rel="bookmark">
			数分面试题2-牛客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录标题 1、参数估计和假设检验分别是什么？区别在哪里？3、怎么降低第一类错误，如何同时降低第一类和第二类错误4、SQL、Python、R等分析工具，分别有什么用？5、说一下显著性水平、置信区间、假设检验6、Union和Join的区别7、SQL窗口函数并举例8、SQL里面的like的用法9、SQL语句求单日留存及一个月的每日留存10、sql如何进行优化11、数据分析流程12、游戏内数据分析涉猎的少，如何证明自己有能力胜任？--学习话术13、你认为字节小游戏平台分析需要涉及哪些指标？---看思路14、你对数据分析的认知是什么，那你是如何学习数据分析的15、你觉得数据分析应该具备的能力是什么16、以往经历中，你是怎么做数据分析报表17、对做数据分析做了哪些准备18、SVM19、说一个无监督学习算法，阐述原理，优缺点，实际应用点 1、参数估计和假设检验分别是什么？区别在哪里？ 参数估计：通过样本统计量来对总体参数进行估计，包括点估计和区间估计。
假设检验：通过对总体参数提出一个假设，然后利用样本统计量来验证假设是否成立，从而做出拒绝或者接受原假设的决定。### 2、假设检验的显著性水平
AB测试是假设检验的应用。
两者联系：参数估计和假设检验都是样本去估计总体，都是建立在概率基础上的统计，可以相互转换
两者区别是：1，参数估计是用样本统计量估计总体参数的方法；假设检验是先对总体参数提出一个假设，然后利用样本信息去检验这个假设是否成立 2，参数估计是以置信区间(大概率)估计总体参数；假设检验是利用小概率事件是否发生来判断假设是否成立
3、怎么降低第一类错误，如何同时降低第一类和第二类错误 当样本容量n固定时，α、β不能同时都小，α变小时β就变大，而β变小时α就变大。
只有当样本容量n增大时，才有可能使两者变小。在实际应用中，一般原则是控制犯第一类错误的概率，即给定α，然后通过增大样本容量n来减小β。
这种着重对第一类错误的概率α加以控制的假设检验称为显著性检验，α就是显著性水平。
统计功效=1-第二类错误，也即当AB两组实际有差异时,能被我们检测出来差异的概率
4、SQL、Python、R等分析工具，分别有什么用？ EXCEL用于小样本量中基本的数据处理操作，
而SQL用于从数据库中取数操作，做一些简单的数据处理工作，通过表连接、嵌套查询等动作完成最终的数据统计工作。
Python和R可以借助多种多样的工具库，可以通过数据建模，可用于有监督或无监督模型的训练，解决分类或预测问题。
5、说一下显著性水平、置信区间、假设检验 显著性水平：其实就是第一类错误也叫弃真错误，也即原假设为真时被拒绝的概率
置信区间：在区间估计中，由样本统计量所构造的总体参数的估计区间称为置信区间
假设检验：先对总体要估计的值提出一个假设，然后利用样本信息去检验这个假设是否成立
6、Union和Join的区别 UNION是两张表进行上下拼接，产生的两个记录集(字段要一样的)并在一起，成为一个新的记录集，分为UNION和UNION ALL两种方法；
JOIN 是两张表进行左右连接，条件匹配的记录将合并产生一个记录集，有LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN等多种方法。
7、SQL窗口函数并举例 聚合函数：sum，count，avg，max，min；排序函数：row_number，rank，dense_rank;偏移函数，lead，向后偏移，lag向前偏移，nitile函数，等份分割
8、SQL里面的like的用法 like的作用是模糊查询，
“%”（百分号）：代表任意字符序列（包括空字符序列）。
“_”（下划线）：代表任意单个字符
可以用在where子句中限定查询结果的条件
9、SQL语句求单日留存及一个月的每日留存 1.统计每个用户首次访问的日期；
2.按用户首次访问的日期分组，统计每个日期的单日留存用户数和30日留存用户数及当前日期的新增用户数；
3.单日留存率=单日留存用户数/当前日期下的新增用户数
10、sql如何进行优化 用groupby代替distinct 去重，
表关联之前先用where过滤，防止数据倾斜
建立合适的索引，
减少不必要的字段查询；
少使用like,减少模糊查询
用临时表with as,
如果是并集，多使用union all,
在Oracle中可以使用decode代替case when
合理利用分区
11、数据分析流程 第一步：与业务方沟通问题，明确分析目标；
第二步：对目标进行拆解，可以采用两步分析法，也可以采用人货场分析法，通过数据定位问题源头； 第三步：与产品、运营和技术沟通，找到问题原因。
1.发现问题，明确问题；2.收集数据；3.数据清洗；4.数据统计、数据分析；5.可视化；6.报告撰写。
12、游戏内数据分析涉猎的少，如何证明自己有能力胜任？–学习话术 虽然我对游戏数据分析的经验较少，但是我认为对于应届生而言，更重要的是学习能力以及对该行业的热情。我的学习能力不错（举例说明，最好结合实习的例子，其次是在学校学习的例子等）；并且我非常热爱网络游戏，自身职业规划也和游戏相关，希望能在这个行业里深耕；最后我认为数据分析的方法是相通的，我学习的其他数据分析方法论也可以应用其中。
13、你认为字节小游戏平台分析需要涉及哪些指标？—看思路 从产品自身出发、从用户角度出发、
从游戏自身出发：核心玩法的参与度，游戏留存等； 从游戏玩家出发：ARPU，DAU，留存率； 从游戏性能出发：闪退率，卡顿率等。 最重要的是游戏的渗透率，因为字节游戏主要依靠从字节跳动或今日头条引流用户，如何把内容用户转变为游戏用户，是字节游戏现在最重要的事情
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dce710bcd32ccb73ce7b3906ccc38a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d958ac481c748228abb4357b89c3d7c8/" rel="bookmark">
			Gof23设计模式之责任链模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 责任链模式又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
2.结构 职责链模式主要包含以下角色：
抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 3.案例实现 现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。
/** * @author 晓风残月Lx * @date 2023/7/27 21:15 * 请假条类 */ public class LeaveRequest { // 姓名 private String name; // 请假天数 private int num; // 请假内容 private String content; public LeaveRequest(String name, int num, String content) { this.name = name; this.num = num; this.content = content; } public String getName() { return name; } public int getNum() { return num; } public String getContent() { return content; } } /** * @author 晓风残月Lx * @date 2023/7/27 21:17 * 抽象处理者 */ public abstract class Handler { protected final static int NUM_ONE = 1; protected final static int NUM_THREE = 3; protected final static int NUM_SEVEN = 7; // 该领导处理的请求天数区间 private int numStart; private int numEnd; // 声明后继者（声明上级领导） private Handler nextHandler; public Handler(int numStart) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d958ac481c748228abb4357b89c3d7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bfe15632e687e29cbff03fd75a7738/" rel="bookmark">
			CPP的uint32_t类型简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在C++中，uint32_t是一种无符号整数类型，它表示的是32位无符号整数。
uint32_t是由uint和32_t两个部分组成的。其中，uint表示无符号整数类型，即只能表示非负整数；32_t表示该类型的位数为32位。因此，uint32_t表示的是32位无符号整数类型。
在C++中，可以使用头文件&lt;cstdint&gt;来引入uint32_t类型的定义。这个头文件中还定义了其他一些常见的整数类型，如int8_t、int16_t、int32_t、int64_t等。
下面是一个示例代码，演示了如何声明和使用一个uint32_t类型的变量：
#include &lt;cstdint&gt; #include &lt;iostream&gt; int main() { uint32_t num = 12345; std::cout &lt;&lt; "The value of num is: " &lt;&lt; num &lt;&lt; std::endl; return 0; } 在这个示例中，我们声明了一个名为num的uint32_t类型的变量，并将其初始化为12345。然后，我们使用std::cout将该变量的值输出到屏幕上。
uint32_t 内存中的存储方式 在C++中，uint32_t类型的变量在内存中以32位二进制数的形式存储。由于它是一个无符号整数类型，因此它的取值范围是0到4294967295。
在内存中，uint32_t类型的变量以大端序（big-endian）或小端序（little-endian）的方式存储，这取决于计算机系统的架构。在大端序中，最高位字节存储在内存中的最低地址处，而在小端序中，最低位字节存储在内存中的最低地址处。
无论使用哪种存储方式，uint32_t类型的变量在内存中占据4个字节的空间，并且按照二进制数的形式进行存储。例如，十进制数12345在内存中以二进制数的形式00000000 00000000 00110000 00111001存储。
uint32_t 在算法中的应用 uint32_t在C++中是一种无符号32位整数类型，由于其取值范围和存储特性，它在算法中有着广泛的应用。以下是一些常见的应用场景：
计数和迭代：由于uint32_t是无符号的，它不会表示负数，这使其成为计数和迭代的理想选择。例如，你可能会使用uint32_t来实现一个计数器，跟踪程序运行的次数或者跟踪循环的迭代次数。数组和数据结构的大小：在处理大量数据或大型数据结构时，你可能需要一种类型来安全地存储数组或数据结构的大小。uint32_t可以安全地存储这些大小，因为它可以表示的范围足够大。位操作：uint32_t的另一个常见用途是位操作。由于它的大小是固定的32位，你可以用它执行各种位操作，如位移、位与、位或等。这在处理网络协议、硬件交互和其他底层编程任务时非常有用。哈希函数：许多哈希函数的设计要求使用一个固定大小的整数类型。uint32_t是这种用途的常见选择，因为它的大小足够大，可以提供一个广泛的哈希值范围，同时保持计算效率。加密算法：许多加密算法需要使用固定大小的整数类型。uint32_t在这种情况下也是一个常见的选择，因为它的大小和性质使得它可以有效地支持加密算法的操作。模型参数：在机器学习或深度学习应用中，模型参数通常需要大量的整数类型来存储。uint32_t可以用于存储这些参数，因为它可以表示的范围足够大。 请注意，虽然uint32_t在许多情况下是有用的，但在选择使用它时，你应该考虑你的特定应用是否真正需要32位的整数。如果你的应用不需要处理那么大的数值范围，那么使用更小的类型（如uint16_t或uint8_t）可能会更有效率。
水平有限，有问题随时联系；
彩蛋 更多干货内容欢迎关注公众号SLearningAI，欢迎CSDN与公众号同步交流~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2087fc822368c97c96046d9738d0e308/" rel="bookmark">
			Gof23设计模式之命令模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。
2.结构 命令模式包含以下主要角色
抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 3.案例 服务员： 就是调用者角色，由她来发起命令。
资深大厨： 就是接收者角色，真正命令执行的对象。
订单： 命令中包含订单。
/** * @author 晓风残月Lx * @date 2023/7/27 0:58 * 抽象命令类 */ public interface Command { void execute(); // 只需要定义一个统一的执行方法 } import java.util.Map; import java.util.Set; /** * @author 晓风残月Lx * @date 2023/7/27 1:04 * 具体的命令类 */ public class OrderCommand implements Command { // 持有接收者对象 private SeniorChef receiver; private Order order; public OrderCommand(SeniorChef receiver, Order order) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2087fc822368c97c96046d9738d0e308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38305ffd46f30c5e7aebe59ac8eb5441/" rel="bookmark">
			STM32CubeMx教程---LED闪烁实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写作目的:
开发环境:
Stm32三种开发模式:
寄存器开发
标准库开发
HAL库开发
项目实战:
新建一个工程
选择单片机型号
RCC时钟配置
时钟树配置
GPIO配置
工程管理
Project Manager---Project
Project Manager---Code Generator
Keil中代码编写
开源万岁:
参考文献:
结语:
写作目的: 构建知识体系;提升写作能力;
开发环境: 硬件平台:正点原子探索者stm32f4开发板
软件平台:Keil+Stm32CubeMx
Stm32三种开发模式: 寄存器开发 与51单片机类似，直接操作寄存器。这个过程需要开发者对照手册，一行一行把代码敲出来。明显的优点是:执行效率高；明显的缺点是:寄存器数量相对51单片机多的太多，编程效率太低，对开发者要求太高。
一般不会选择基于寄存器开发，但这种开发模式背后要求的:对开发手册的阅读能力，对芯片架构的理解能力等，是开发者在往后的进阶学习中必须要掌握的。钱老说过:"手里没剑和有剑不用是两码事"。
标准库开发 ST官方将寄存器操作封装成标准库函数，通过提供的现成的接口函数，开发者不用去管寄存器到底是如何操作的，直接调用接口函数即可。相对于直接的寄存器开发，大大提升了开发效率，降低了开发难度。
这也是过去一个时代主流的开发模式，如博主最早接触的正点原子教程就是采用标准库函数开发的(当然现在也都有推出HAL库开发的教程，在这里也是非常感谢原子哥的入门教程)。近年来，ST官方对标准库的更新十分缓慢，而是主力推HAL库的开发方式。时代在进步，技术在发展。HAL库开发无疑在不久的将来会成为主流的开发模式，然后也必将被新的开发模式所取代。我们无需争论哪种方式更好，因为这对每个具体的人来说早已有答案。至于博主，那当然是全都要了，小孩子才做选择。
HAL库开发 那么重点来说下HAL库开发吧。全称就是Hardware Abstraction Layer(硬件抽象层)，库如其名，相当抽象。同标准库一样，HAL库的出现也是为了缩短程序的开发周期，而且HAL库显得更加有效。主要体现在以下几个方面:
它们都将实现功能需要配置的寄存器做了集成，不同的是，对于某些功能，标准库可能要用几句话，HAL库只需用一句话就够了。只针对于某些功能，这点博主自身没感觉到太大区别。
HAL库很好的解决了不同型号芯片间的移植问题，简单来说就是，在目前的开发模式中，用HAL库移植需要更改的地方最少。这点可真是太棒了，博主个人最讨厌移植，最最讨厌的就是在不同厂商的芯片间移植。简直是噩梦！强扭的瓜不甜啊，无法接受。
HAL库作为目前的主推开发模式，会一直更新，稳定性有足够的保障。人么，图个安稳。
HAL库+Stm32CubeMx结合开发，速度简直跟开挂一样，真是泰酷辣！
当然，缺点也是有的，比如编译后代码偏大，执行效率偏低。这些就看个人了，俗话说快与持久不可兼得，博主本人倾向于这种方式，毕竟开发速度快。
项目实战: 以一个实战项目来感受一下:利用STM32CubeMx+ Hal库新建一个工程,实现LED每隔1S翻转一次状态。
新建一个工程 File-&gt;New Project
选择单片机型号 1.搜索需要的单片机型号
2.点击选中相应的单片机，同时可以点击"星号"收藏,以便下次能够快速找到
3.点击"Start Project"创建工程 注意:如果第2步中没有点击选择相应的单片机，第3步中的"Start Project"无法点击哦
RCC时钟配置 System Core-&gt;RCC-&gt;High Speed Clock(HSE)-&gt;Crystal/Ceramic Resonator
时钟相关配置可以参考stm32的参考手册，后期也有计划记录下时钟相关的配置博客。这里先挖个坑，后面来填。
时钟树配置 时钟树的配置仔细核对与下图一致即可。
注意:鼠标需要先点击"Clock Configuration"切换到时钟树配置界面
为了核对方便
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38305ffd46f30c5e7aebe59ac8eb5441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b74e00a46deb23bdc1cb9a568ca583/" rel="bookmark">
			03_css的文本样式设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、css 的文字文本样式设置 1、设置文字的颜色: color 颜色设置的方式：
red（红色）颜色名表示#RRGGBB十六进制法rgb(16, 78, 139)rgb表示法（红-绿-蓝（red-green-blue ））rgba(16, 78, 139,0.5)RGBa 扩展了 RGB 颜色模式，它包含了阿尔法通道，允许设定一个颜色的透明度。a 表示透明度：0=透明；1=不透明 示例：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;设置文字的颜色&lt;/title&gt; &lt;style type="text/css"&gt; div { /* 1.设置文字的颜色:color */ color: red; color:#00ff00; color:rgb(0,0,255); color:rgba(0,0,255,0.6); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是设置了文本样式&lt;/div&gt; &lt;h4&gt;这是没有设置文本样式&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2、设置文字的大小: font-size &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;设置文字的大小&lt;/title&gt; &lt;style type="text/css"&gt; div { /* 2.设置文字的大小:font-size*/ font-size: 30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是设置了文本样式&lt;/div&gt; &lt;h4&gt;这是没有设置文本样式&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 3、设置文字是否加粗: font-weight(加粗/ 不加粗 属性值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b74e00a46deb23bdc1cb9a568ca583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129150468872dee882058b3ca9d6388e/" rel="bookmark">
			数分笔试题-牛客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 小红书2020校招数分笔试题一1、P(AB)&lt;=(P(A)+P(B))/2 是对的，等号在A与B重合的时候成立2、回访数据可以用于评估用户黏性3、评估模型之后得出模型存在偏差，解决方法4、0到1000当中有多少个数字带有15、在EXCEL输入以零开头的文本型数字时需在输入的数据前面加‘6、抽样调查遵循的原则是随机原则7、散点图可以用来刻画两个变量之间是否具有相关关系8、均值=中位数=众数：正态分布9、模型选择就是选择在未知数据集上预测性能较好的模型，两种常用的模型选择方法：正则化与交叉验证10、正态分布的偏度为0，峰度为311、sum(a, b) 指的是a+b12、假设一个元组在子查询1中出现m次，在子查询2中出现n次，该元组在“子查询1 Union ALL 子查询2”中出现m + n次。在“子查询1 Union 子查询2”中出现1次。13、抽样估计的优良标准14、常见的聚类算法15、substring('109.120.59.63',5,3) = 120 截取字符串16、 SQL 中，函数 "percentile(totalgmv, 0.5)" 表示计算变量 "totalgmv" 的第 50 百分位数。 小红书2020校招数分笔试题一 1、P(AB)&lt;=(P(A)+P(B))/2 是对的，等号在A与B重合的时候成立 P(AB)=P(A)*P(B|A)=P(B)*P(A|B)
2P(AB)=P(A)*P(B|A)+P(B)*P(A|B)
P(AB)=(P(A)*P(B|A)+P(B)*P(A|B))/2
由于：P(B|A)&lt;=1,P(A|B)&lt;=1
所以：P(A)*P(B|A)+P(B)*P(A|B)&lt;=P(A)+P(B)
因此：P(AB)&lt;=(P(A)+P(B))/2
2、回访数据可以用于评估用户黏性 回访数据是指在客户服务或市场调研过程中，记录和收集的关于已经进行过一次交互或交流的客户或受访者的相关信息。它主要用于评估和跟踪客户满意度、市场反馈或调研结果。
通过分析回访数据，可以获取以下关于用户黏性的相关信息：频率和持续时间、反馈和问题解决、交叉使用和推荐、留存率和重新访问率
3、评估模型之后得出模型存在偏差，解决方法 增加模型规模（比如神经元/层的数量、、减少或去除正则化（L2正则化，L1正则化，dropout)
加入更多训练数据通常可以解决方差问题，但对偏差问题帮助不大
4、0到1000当中有多少个数字带有1 除了1000，把所有数都看成三位数，个位、十位、百位都可以取0，2，3，4，，，9一共9种情况，所以是9的3次方
不包含1的数字有9的3次方=729个，所以包含1的数字有1001-729=272个
5、在EXCEL输入以零开头的文本型数字时需在输入的数据前面加‘ 6、抽样调查遵循的原则是随机原则 7、散点图可以用来刻画两个变量之间是否具有相关关系 8、均值=中位数=众数：正态分布 均值&gt;中位数&gt;众数：负偏态分布（右偏）
均值&lt;中位数&lt;众数：正偏态分布（左偏）
9、模型选择就是选择在未知数据集上预测性能较好的模型，两种常用的模型选择方法：正则化与交叉验证 10、正态分布的偏度为0，峰度为3 11、sum(a, b) 指的是a+b sum(a:b) 才是a-b的所有值之和
12、假设一个元组在子查询1中出现m次，在子查询2中出现n次，该元组在“子查询1 Union ALL 子查询2”中出现m + n次。在“子查询1 Union 子查询2”中出现1次。 13、抽样估计的优良标准 抽样估计的优良标准：无偏性、一致性、有效性
影响时间序列的因素有四个：长期趋势、季节变动、循环波动、不规则波动
14、常见的聚类算法 K-means聚类：K均值聚类是一种基于距离的划分聚类方法。它将数据集分成K个簇，每个簇以其簇中心（质心）为代表。在算法的迭代过程中，通过最小化数据点与其所属簇质心的距离来优化聚类效果。
层次聚类（Hierarchical Clustering）：层次聚类是一种分层式的聚类方法，根据对象之间的相似性逐步生成聚类层次。它可以通过自底向上（凝聚层次聚类）或自顶向下（分裂层次聚类）的方法构建聚类层次结构。层次聚类的结果可以表示为树状结构（聚类树或树状图）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/129150468872dee882058b3ca9d6388e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b20d60451ed5e464a55399067528f8a/" rel="bookmark">
			芯片设计中的ECO是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		芯片设计中的ECO是什么？-腾讯云开发者社区-腾讯云 如标题所写，我们今天聊一聊IC设计种的ECO。在展开关于ECO的概念之前，我们先大致捋下数字IC设计的流程，有助于我们后面的讨论。
数字IC设计流程简述
1、确定项目需求
根据市场或者芯片功能要求，设计芯片的spec，得到可行的芯片设计方案。
2、系统级设计
用系统建模语言对各模块进行描述
3、前端设计
RTL设计、功能仿真、硬件原型验证、电路综合、DFT、STA
4、后端设计
版图设计、物理验证、后仿真
在复杂的设计流程中，bug是难以避免的。对于芯片设计而言，bug自然是越早发现越好。但是仿真验证差不多，进入RTL freeze阶段后，一旦发现新的bug，就变得有些麻烦。
因为RTL freeze前，你可以通过修改RTL来更正你发现的bug。然而RTL freeze之后，后端人员做好了floorplan，或者已经开始布局布线，这个时候再去重新做一遍，既耗时耗力，又会惹怒后端。这显然不是好的选择。
如果这个时候即将tapeout，甚至已经tapeout，根本就没有机会修改RTL了。
这个时候，我们就需要ECO，来修正我们的失误了。
什么是ECO？
ECO，即Engineering Change Order的缩写，指工程改变命令。
什么意思呢？简单来说就是手动修改集成电路的过程，换句话说，就是直接手动修改netlist。
一般应用于数字芯片版图设计。
对于数字IC设计而言，ECO这一步实际上是正常设计流程的一个例外。它是对设计的layout进行局部的小范围的修改和重新布线，而不影响到设计的其它部分的布局布线，所以其它部分的时序信息没有改变。
根据功能的不同，ECO可以分为功能改变和非功能改变。功能改变是指由于来自客户对设计的追加需求（spec改变）或者设计的最后阶段发现芯片存在 bug 的情况下进行的 ECO；而非功能改变则是为了在不改变 RTL 网表的基础上修复部分时序以及串扰等问题而做的 ECO。
说到底，ECO的目的就是省钱省时间。
那么在不同阶段，进行ECO，有什么样的区别呢？
在阶段上，数字IC设计中的ECO大体可以分为：tapeout前的ECO，tapeout过程的ECO，tapeout后的ECO。
Tapeout前的ECO
在RTL freeze后，tapeout前这一阶段，RTL已经没法修改，但是好歹也没有进入tapeout，还有补救的机会。
此时数字前端负责写coding的工程师需要在final RTL的基础上，通过写ECO脚本的方式来实现功能上的ECO。
ECO代价：时间成本，相对较小
Tapeout过程中的ECO
当数字后端实现后的design，timing已经符合signoff标准，DRC已经clean，LVS已经pass，IR drop，MVRC，Formality，DRCPLUS等都已经pass。
但是，数字前端设计工程师还没来得及做完大部分case的后仿，而且芯片又面临着Timing-TO-Market的压力。此时，进入tapeout阶段。
为什么不给自己留更多余地呢？因为foundary会先做base layer的加工。只要后期仿真发现的问题，不需要再添加额外的cell，就不耽误之前的tapeout（此处有点像流水线）。即使发现需要新加几个cell，这个时候仍然可以通过替换后端实现过程中所加的ECO cell或者spare cell来实现。
ECO代价：时间成本较大
Tapeout后的ECO
当芯片已经tapeout回来，我们在测试过程中却发现了必须修复的bug。这个时候做ECO的代价相对前面两种，就要大很多。
改动少的可能仅需要改几层Metal layer，改动大的话可能需要动十几层Metal layer，甚至重新流片。在此阶段，前端设计工程师需要出具ECO方案，同时让后端工程师进行评估，主要评估需要改动的层数，timing 是否能快速收敛等方面的风险。
在一次次确认后，敲定方案，进行ECO。
ECO代价：时间与金钱成本巨大
由此可见，即使ECO能够亡羊补牢，但是为了节省更多的时间和金钱成本，还是尽早发现问题，尽早解决吧。
关于ECO的分类：
常见的ECO可以分为pre mask ECO和post mask ECO，也就是任何layer都可以动到的ECO和只修改metal layer的ECO。
两者的区别在于，pre mask ECO的晶体管和布线层都还没有开始做出mask，此时可以往netlist里面添加cell。而post mask ECO的晶体管层已经开始进行加工了，但是布线层还没有加工，还能修改，可以通过ECO改变各种已有cell的连线关系，但是不能添加新的cell，有一定局限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b20d60451ed5e464a55399067528f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56368ff5c44de7b735571db3fe68e087/" rel="bookmark">
			Firebase常用功能和官方Demo简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Firebase简介 Firebase刚开始是一家实时后端数据库创业公司，它能帮助开发者很快的写出Web端和移动端的应用。自2014年10月Google收购Firebase以来，用户可以在更方便地使用Firebase的同时，结合Google的云服务。现在的Firebase算是谷歌旗下的一个强大的工具，不过使用Firebase需要翻墙。
二、Firebase功能介绍 Firebase docs: https://firebase.google.com/docs/android/setup?hl=zh-cn
App埋点：Analytics : 应用内数据上报，帮助分析用户在app内的行为 开发文档： https://firebase.google.com/docs/analytics?hl=zh-cn
Firebase 的核心是 Google Analytics，这是一种免费提供的无限分析解决方案。 Analytics 集成了多个 Firebase 功能，可为您提供最多 500 个不同事件的无限报告，您可以使用 Firebase SDK 定义这些事件。分析报告可帮助您清楚地了解用户的行为方式，从而使您能够就应用营销和性能优化做出明智的决策。
云消息推送：Firebase Cloud Message 即：FCM，帮助app推送通知 开发文档：https://firebase.google.com/docs/cloud-messaging?hl=zh-cn
Firebase 云消息传递 (FCM) 是一种跨平台消息传递解决方案，可让您免费可靠地发送消息。
使用 FCM，您可以通知客户端应用程序有新的电子邮件或其他数据可供同步。您可以发送通知消息以推动用户重新参与和保留。对于即时消息传递等用例，消息可以将高达 4000 字节的有效负载传输到客户端应用程序。重点是：FCM 支持Android,IOS，WEB,Flutter,Unity
身份验证：Authentication : 集成了多个三方登录 开发文档：https://firebase.google.com/docs/auth/?hl=zh-cn
方便的实现google登录，facebook登录，twitter登录，github登录，邮箱登录，电话登录以及自定义验证登录。大多数应用程序需要知道用户的身份。了解用户身份后，应用程序可以将用户数据安全地保存在云中，并在用户的所有设备上提供相同的个性化体验。
Firebase 身份验证提供后端服务、易于使用的 SDK 和现成的 UI 库来对应用的用户进行身份验证。它支持使用密码、电话号码、流行的联合身份提供商（如 Google、Facebook 和 Twitter 等）进行身份验证。
Firebase 身份验证与其他 Firebase 服务紧密集成，并利用 OAuth 2.0 和 OpenID Connect 等行业标准，因此可以轻松与自定义后端集成。
当您使用 Identity Platform 升级到 Firebase 身份验证时，您会解锁其他功能，例如多重身份验证、阻止功能、用户活动和审核日志记录、SAML 和通用 OpenID Connect 支持、多租户和企业级支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56368ff5c44de7b735571db3fe68e087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f039014af9e779a74bbc8d3426a4ff/" rel="bookmark">
			批量修改文件名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据文件名对应表，批量修改文件名
tt.txt
原文件名1,新文件名1 原文件名2,新文件名2 test.bat
@echo off @echo off &amp;setlocal enabledelayedexpansion rem echo 当前目录:%~dp0 set DestPath=%~dp0 rem 查找的扩展名 set DestExt=*.* rem 不提示删除之前生成的问题，不存在也不提示 del /Q /F /A list.csv 2&gt;nul rem 循环文件目录里所有的文件(包括子文件夹里的文件) for /f "usebackq delims=" %%i in (`dir /b/a-d/s "%DestPath%\%DestExt%"`) do ( rem 输出文件路径及文件名到list.csv文件里 set "t=%%~nxi" rem echo !t! setlocal enabledelayedexpansion for /f "delims=, tokens=1-2" %%i in (tt.txt) do ( rem echo %%i.jpg rem echo %%~nxi rem echo %%i set "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f039014af9e779a74bbc8d3426a4ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707fe2356d2164000c2787ad70ab6299/" rel="bookmark">
			VUE3项目生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装 qrcode.vue
yarn add qrcode.vue //安装完成以后package.json如下 //"qrcode.vue": "^3.4.1", 2.直接CV如下代码，即可生成
&lt;template&gt; &lt;div&gt; &lt;el-row :gutter="20"&gt; &lt;el-col :span="6"&gt; &lt;el-input v-model="codeVal" placeholder="请输入二维码的值"&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;el-col :span="6"&gt; &lt;el-button @click="changeCode"&gt; 生成二维码的值 &lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;qrcode-vue v-if="shouldGenerateQRCode" :value="value" :size="120" :margin="2" :level="level" :render-as="renderAs" /&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref, computed } from 'vue'; import QrcodeVue, { Level, RenderAs } from 'qrcode.vue'; const value = ref(''); const codeVal = ref(''); const level = ref&lt;Level&gt;('M'); const renderAs = ref&lt;RenderAs&gt;('svg'); const changeCode = () =&gt; { if (codeVal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707fe2356d2164000c2787ad70ab6299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2dbc2cd9cad0cd80fc1ab1718fe72f3/" rel="bookmark">
			操作系统原理与实践 第2章 习题【附答案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第2章进程管理作业 题量: 19 满分: 100
一. 单选题（共10题，50分） 1. (单选题, 5分)进程和程序的一个本质区别是( )。 A. 前者为动态的,后者为静态的B. 前者存储在内存,后者存储在外存C. 前者在一个文件中,后者在多个文件中D. 前者分时使用CPU,后者独占CPU 我的答案: A:前者为动态的,后者为静态的;正确答案: A:前者为动态的,后者为静态的;
5分
2. (单选题, 5分)进程在系统中是否存在的唯一标志是( )。 A. 数据集合B. 目标程序C. 源程序D. 进程控制块 我的答案: D:进程控制块;正确答案: D:进程控制块;
5分
3. (单选题, 5分)处理器执行的指令被分成两类,其中有一类成为特权指令,它只允许( )使用。 A. 操作员B. 联机用户C. 操作系统D. 目标程序 我的答案: C:操作系统;正确答案: C:操作系统;
5分
4. (单选题, 5分)进程所请求的一次打印输出结束后,将使进程状态从( )。 A. 运行态变为就绪态B. 运行态变为等待态C. 就绪态变为运行态D. 等待态变为就绪态 我的答案: D:等待态变为就绪态;正确答案: D:等待态变为就绪态;
5分
5. (单选题, 5分)下述( )不属于多道程序运行的特征。 A. 多道B. 运行速度快C. 宏观上并行D. 实际上多道程序是串插运行的 我的答案: B:运行速度快;正确答案: B:运行速度快;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2dbc2cd9cad0cd80fc1ab1718fe72f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df91ef19f8e3278f69b5e468d3f8ec99/" rel="bookmark">
			visioFox使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BROWSE LAST --查看最后一个文件
close all --关闭显示
● brow for fxywlb=‘FXA6’
● brow for inlist(fxzqdm,‘159100’,‘169100’)
从右边查询3位字符
brow for right(Jgtgdy,3)=‘321’
select right(Jgtgdy,3), from Sjsjg0123zb.dbf
从左边查询3位字符
brow for left(Jgtgdy,3)=‘321’
select left(Jgtgdy,3), from Sjsjg0123zb.dbf
截取指定位置指定长度
brow for substr(Jgzqdm,1,3)=‘161’
select substr(Jgzqdm,1,3), from Sjsjg0123zb.dbf
*修改
update Jsmx03_js961 set Ywlx=‘812’ where Ywlx=‘811’
*删除
delete for Ywlx=‘811’ and Qsbz=‘232’
pack
delete for Ywlx&lt;&gt;‘811’ and Ywlx&lt;&gt;‘812’
pack
*替换
replace Ywlx with ‘811’ for Ywlx=‘812’
replace all Rq with ‘20200327’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df91ef19f8e3278f69b5e468d3f8ec99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5648187ef05b7e3405caaac49dcee3f5/" rel="bookmark">
			echarts实现横向和纵向滚动条、dataZoom及其滚动条设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts实现横向和纵向滚动条、dataZoom 前言 使用echarts会遇到这种情况，以柱状图为例子，当数据过多时，echarts图就会堆叠在一起，看起来十分难看。通常解决办法是通过减小barWidth值来缩小柱子宽度，但是若数据达到上百条，这场面是相当壮观。另一个很常用的就是在外部容器div添加overflow: scroll;，这确实能解决一些问题，但是若是数据量过少，就会显的非常稀疏，经历过的都懂。言归正传，以上都不是最佳解决方式，echarts其实已经为提供好相应的API配置了，无论是横向滚动还是纵向滚动，dataZoom都能满足。
1、横向滚动条 dataZoom: [ { // 设置滚动条的隐藏与显示 show: true, // 设置滚动条类型 type: "slider", // 设置背景颜色 backgroundColor: "rgb(19, 63, 100)", // 设置选中范围的填充颜色 fillerColor: "rgb(16, 171, 198)", // 设置边框颜色 borderColor: "rgb(19, 63, 100)", // 是否显示detail，即拖拽时候显示详细数值信息 showDetail: false, // 数据窗口范围的起始数值 startValue: 0, // 数据窗口范围的结束数值（一页显示多少条数据） endValue: 5, // empty：当前数据窗口外的数据，被设置为空。 // 即不会影响其他轴的数据范围 filterMode: "empty", // 设置滚动条宽度，相对于盒子宽度 width: "50%", // 设置滚动条高度 height: 8, // 设置滚动条显示位置 left: "center", // 是否锁定选择区域（或叫做数据窗口）的大小 zoomLoxk: true, // 控制手柄的尺寸 handleSize: 0, // dataZoom-slider组件离容器下侧的距离 bottom: 3, }, { // 没有下面这块的话，只能拖动滚动条， // 鼠标滚轮在区域内不能控制外部滚动条 type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5648187ef05b7e3405caaac49dcee3f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26554b6595b627b0b41dd7d2227fe06/" rel="bookmark">
			JAVA多态（instance of与类型转换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多态 1. 同一个方法可以根据发送对象不同而采用多种不同的行为方式 2. 一个对象的实际类型是确定的，但可以指向对象的引用类型有很多（父类或者有关系的类） 3. 多态存在的条件： - 有继承关系 - 子类重写父类的方法 - 父类引用指向子类对象（Father f1 = new son();） 4. 注意： - 多态是方法的多态，属性没有多态性 - instance of 类型转换 引用类型 - 父类和子类有联系，转换异常（ClassCastEeception！） 示例1 测试类 public class Application { public static void main(String[] args) { /* 一个对象的实际类型是确定的 new Student(); new Person(); 可以指向的引用类型就不确定，父类的引用指向子类 */ // student 能调用的方法都是自己的或者继承父类的！ Student s1 = new Student(); //Person 父类型，可以指向子类，但不能调用子类独有的方法 Person s2 = new Student(); // Object 祖宗类 Object s3 = new Student(); s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26554b6595b627b0b41dd7d2227fe06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e25b9acb22ef06aadabd1f541813c60/" rel="bookmark">
			SAM &#43; YOLOv8 图像分割及对象检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAM(Segment Anything Model）是由 Meta 的研究人员团队创建和训练的深度学习模型。该创新成果发表在 2023 年 4 月 5 日发表的一篇研究论文中，它立即引起了公众的广泛兴趣——相关的 Twitter 帖子迄今为止已累积超过 350 万次浏览：
计算机视觉专业人士现在将注意力转向 SAM——但为什么呢？
推荐：用 NSDT编辑器 快速搭建可编程3D场景
1、什么是SAM？ 在 Segment everything 研究论文中，SAM 被称为“基础模型”。
基础模型是在大量数据上训练的机器学习模型（通常通过自监督或半监督学习），其目的是在更具体的任务上使用和重新训练。
换句话说，SAM 是一个预训练模型，旨在适应其他任务（特别是通过微调）。
例如，SAM 可以重新训练并用于仅对数据集中的人员进行分割。
人物分割是 SAM 可以执行的一项附件任务，因为它已经在包含此类对象的数据集上进行了训练 - 但不仅如此！
2、SAM 是如何训练的？ SAM 在 SA-1B 数据集上进行了训练，该数据集由 Meta 与 Segment Anything 研究论文并行引入。
Facebook 母公司的数据集包含超过 1100 万张几乎在整个地球上收集的图像——这是开发具有泛化能力的模型的一个重要方面。
几乎在整个地球上收集的图像 – SA-1B 数据集
这些高质量图像（平均 1500×2250 像素）伴随着与数据集标签相对应的 11 亿个分割掩模。
Meta 使用此数据集的目的是为AI博士创建细分参考。 它已获得官方免费许可用于研究目的。
尽管信息量很大，但值得注意的是，掩模与类别无关。 换句话说，即使SAM可以生成一个人的掩模，它也无法表明这个掩模代表一个人。
这是需要牢记的重要一点，因为这意味着 SAM 必须与其他算法结合才能真正发挥作用。
让我们仔细看看。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e25b9acb22ef06aadabd1f541813c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfecae1ae9cd4be7bbf2d7cb34f99ab/" rel="bookmark">
			使用 iText 库给PDF文件加水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 iText 库介绍需要的依赖水印样式封装封装工具类内容笔记 iText 库介绍 iText 是一款流行的 Java PDF 库，它可以用来创建、读取、修改和提取 PDF 内容。iText 提供了许多 API，包括添加文本水印的功能。
注释：创建一个Springboot来测试 iText的使用，创建项目不做过多介绍
需要的依赖 &lt;!-- iText 是一款流行的 Java PDF 库--&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hutool --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.8&lt;/version&gt; &lt;/dependency&gt; 水印样式封装 创建 ITextAttributes 用于封装pdf水印样式
package com.test.testdemo.itext; import com.itextpdf.text.BaseColor; import com.itextpdf.text.DocumentException; import com.itextpdf.text.Element; import com.itextpdf.text.pdf.BaseFont; import lombok.Data; import java.io.IOException; /** * @Author Chenry.r * @Date 9/9/2023 下午10:11 * @Version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dfecae1ae9cd4be7bbf2d7cb34f99ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a6ee1a22e5c467858b6888688ed701/" rel="bookmark">
			pip安装pytorch报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WARNING: Retrying (Retry(total=4, connect=None
时隔将近一年再去安装pytorch报错，在服务器linux环境下，
看了很多分享，最后试成功举例说：
pip install torch==1.8.0+cu111 torchvision==0.9.0+cu111 torchaudio==0.8.0 -f https://download.pytorch.org/whl/torch_stable.html 不行，去了以下地址找安装包
https://download.pytorch.org/whl/torch_stable.html 又看了博客还发现，这包还需要和python版本适配，系统装的是python3.9
cu101/torch-1.7.1%2Bcu101-cp39-cp39-linux_x86_64.whl
就是和这里的cp39对应起来，最后找到1.7.1版本的torch，
对应怎么去找torchvision，就是去官网找1.7.1的安装命令，
# CUDA 10.1 pip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html 给出了torchvision的版本，再去下包，同样对应pthon3.9版本
cu101/torchvision-0.8.2%2Bcu101-cp39-cp39-linux_x86_64.whl
最后用命令安装，按分享博客里说的，先装torch后装torchvision，
pip install torch-1.7.1+cu101-cp39-cp39-linux_x86_64.whl
pip install torchvision-0.8.2+cu101-cp39-cp39-linux_x86_64.whl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e32643a959d27b7c2660619c279d576/" rel="bookmark">
			最新keil安装出现的无数问题记录及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错问题现象如下：
*** Target 'Target 1' uses ARM-Compiler 'Default Compiler Version 5' which is not available.
安装最新keil 5 出现无数个问题。
我使用GD32去跑，或者STM32去跑，都是这个问题。
一、我先解决了GD32的问题： 在第2步中，切换一下，再进入keil，就OK了！
二、再解决STM32的问题： 我先参考的这篇博文【Keil5】*** Target ‘xxx‘ uses ARM-Compiler ‘Default Compiler Version 5‘ which is not available.解决方法_*** target 'flash' uses arm-compiler 'default comp_Minion_R的博客-CSDN博客
1、第一步点击这里
2、第二步
3、第三步
4、进去后，找到ARM下的ARMCC，可能很多人没有，我参考上面文章的评论区。
但我也保存了，共享链接：https://pan.baidu.com/s/1rUQOoSo4XgQWbM1CMChSuw 提取码：kyky
5、点击后，它会出现如下图所示情况，点击close即可，到正常界面。
6、这个时候，你再来选择，锤子里的这个ARM，你试下编译，就不会报错了
以上经验分享，希望对相同问题的小伙伴，有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c5b97616004d5870bdda1695ef9217/" rel="bookmark">
			【Redis】Redis如何保证和MySQL数据库的数据一致性（带你一文了解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
方法一：采用事务
方法二：订阅Mysql的Binlog文件(可借助Canal来进行)
方法三：基于消息队列的同步方案
方法一：采用事务 MySQL 支持事务，在需要保证一致性的操作中使用事务。通过将 Redis 和 MySQL 操作放在同一个事务中，并使用 ACID（原子性、一致性、隔离性和持久性）的特性，可以保证 Redis 和 MySQL 数据的一致性。
方法二：订阅Mysql的Binlog文件(可借助Canal来进行) CanalServer会伪装成MysqlServer从库，去订阅MysqlServer主库的Binlog文件
Canal启动的时候会配置对应的消息MQ(RabbitMQ, RocketMQ, Kafka), 监听到Binlog文件有变化是，会把变化的sql语句转换成json格式，并作为消息内容发送到MQ中
项目中只要监听对应MQ，就能拿到Binlog改动的内容，Json数据中有明确的操作类型(CURD), 以及对应的数据。把对应数据同步到redis即可
缺点1：canal订阅Binlog的整个操作过程是单线程的，所以面临超高并发的情况下，性能可能不太出色。当然可以部署多个Canal 与 多个消费者，但是要注意消息重复消费问题，做好幂等性校验
优点1：即使人为改数据库，也会监听到，并且也会同步
优点2：异步同步，不会对接口返回有格外延迟
方法三：基于消息队列的同步方案 基于消息队列的同步方案，通常是将 MySQL 的更新操作通过消息队列发送到一个或多个 Redis 服务器，然后 Redis 服务器根据消息队列中的消息更新缓存中的数据。这种方案相对较为灵活，可以根据实际需求选择合适的消息队列，比如 RabbitMQ、Kafka、RocketMQ 等。 具体实现可以分为以下步骤：
配置消息队列，比如 RabbitMQ。可以参考 RabbitMQ 官方文档 进行配置。
在 MySQL 数据库中配置触发器，将更新操作通过消息队列发送出去。以下是一个 MySQL 触发器的示例代码：
CREATE TRIGGER sync_data AFTER INSERT ON table1 FOR EACH ROW BEGIN INSERT INTO rabbitmq_queue (message) VALUES (NEW.message); END; 上述代码将在 table1 表中插入新数据时，向名为 rabbitmq_queue 的消息队列中插入一条消息，消息内容为 NEW.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c5b97616004d5870bdda1695ef9217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f4c201af3f711614afabb7791d7091/" rel="bookmark">
			IDEA配置web运行环境巨详细操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，创建java工程。我之前已经创建工程了，所以现在还停留在之前工程的界面，要新建java工程，先在之前工程的左上角点击File，再点击New，接着点击Project
出现New Project界面，首先把项目名字Name改一下，指定一下项目的路径（这两个都是自定义，不同人有不同的方式），下面的几项一般都不需要修改了，如果jdk没指定路径的话，需要指定一下，方法可以看我前面的文章。最后，点击Create，至此，工程创建完成。
接下来点击项目名称，右键，寻找add framework support，一般在倒数第四个，然而我这里并没有找到，大家可能也会遇到这问题。这个问题我已经在之前的文章里写了如何解决，这里就不赘述了。
文章链接如下：
http://t.csdn.cn/jj67n
出现页面后，勾选Web Application(4.0)，然后点击OK进行确认 。
可以看到左测出现之前没有的web模块：
接着在WEB-INF下面新建两个目录，一个是classes，另一个是lib。
首先新建classes，点击WEB-INF，然后点击New，接着点击Directory。
输入目录名:classes，回车。
lib的创建和classes一样，大家照着classes的创建方法操作就行，最后名字改为lib。
接着，我们要往lib放一些配置文件，在次之前需要大家去下载Tomcat，下载之后解压就行，记住文件路径，别的操作暂时不需要。
解压文件之后点击进入，接着点击进入lib文件夹。
我们可以看到有很多文件，我们需要做的是将其中的jsp-api.jar和servlet-api.jar复制进项目文件夹里我们新建的lib。
首先，对jsp-api.jar进行复制，复制之后点击lib，右键，点击Paste。
会出现这样一个页面，点击OK。
servlet-api.jar的操作相同，不再赘述。
接下来对项目进行相应的配置，点击File，再点击Project Structure：
出现这样一个界面：
首先，配置Modules模块，先点击Modules，再点击Paths
选择第二项，接下来将classes文件的路径放在Output path处，Text Output path也一样，两者路径相同。（注意：大家文件的路径不一样，不要照着我写一模一样，除非路径和我的一样，大家记得关注自己文件存放的路径）
接下来点击Libraries模块，再点击+，接着点击Java
指定lib目录所在位置，点击OK
点击OK
点击Artifacts模块，接着点击Fix...
点击第一项：
先点击Apply，再点击OK
至此web已经配置完成，接下来是和tomcat交互的配置。
找到Current File，点击，接下来点击第一项：
点击+，接着找到TomEE Server，点击Local
点击Condigure...，再点击TomeEE Home右侧的文件夹标识，找到tomcat的位置
找到位置后点击，接着点击OK进行确认
再次点击确认
将名字改为Tomcat
找到jre的路径，jdk包含jre，找不到jre的话，找jdk就行
点击第二个选项卡，再点击+，接着点击第一个选项：
将后面多余的字母删掉，此处是将_war_exploded删掉
变成下面这样：
点击回到第一个模块，点击On 'update' action选项卡，点击Redeploy：
接着点击On frame deactivation选项卡，点击最后一项。
最后咱们需要配置一下指定浏览器，当然不配置也行，我就不介绍了，如果大家需要的话，可以在下面评论，我后来再介绍。（如果不需要我之后就不再写了）
先点击Apply，再点击OK，至此配置完成。
接着我们点击右上方的绿色小虫子启动：
等待一段时间，可以看到跳出一个网页，这说明我们配置成功了，网站启动了。
为了让大家体会第一次运行网站的快乐，我们在index.jsp里写一些html语句（下面的图是本来的）
修改如下：
刷新网站，可以看到：
我们到这里就成功运行了一个自己搭建的网站，虽然很简单，但是"不积跬步无以至千里，不积小流无以成江海"，一步步来，咱们总有一天能搭建出一个属于我们自己的酷炫网站。
如果觉得有用，别忘了关注收藏点赞哟，如果效果还行的话，我再出下期。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d36ecfd63cae58dee27ac72dee144a/" rel="bookmark">
			php将数组中的最后一个元素放到第一个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		array_unshift($firstStepResult, array_pop($firstStepResult)); 转换之后
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a1c7963a8eb28f76fa11fc92c0834e/" rel="bookmark">
			WebServer 解析HTTP 响应报文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础API部分，介绍stat、mmap、iovec、writev、va_list 1.1 stat​ 作用：获取文件信息
#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; // 获取文件属性，存储在statbuf中 int stat(const char *pathname, struct stat *statbuf); struct stat { mode_t st_mode; /* 文件类型和权限 */ off_t st_size; /* 文件大小，字节数 */ }; 返回值：成功返回0，失败返回-1；参数：文件路径（名），struct stat 类型的结构体 struct stat 结构体详解：
struct stat { dev_t st_dev; /* ID of device containing file */文件使用的设备号 ino_t st_ino; /* inode number */ 索引节点号 mode_t st_mode; /* protection */ 文件对应的模式，文件，目录等 nlink_t st_nlink; /* number of hard links */ 文件的硬连接数 uid_t st_uid; /* user ID of owner */ 所有者用户识别号 gid_t st_gid; /* group ID of owner */ 组识别号 dev_t st_rdev; /* device ID (if special file) */ 设备文件的设备号 off_t st_size; /* total size, in bytes */ 以字节为单位的文件容量 blksize_t st_blksize; /* blocksize for file system I/O */ 包含该文件的磁盘块的大小 blkcnt_t st_blocks; /* number of 512B blocks allocated */ 该文件所占的磁盘块 time_t st_atime; /* time of last access */ 最后一次访问该文件的时间 time_t st_mtime; /* time of last modification */ /最后一次修改该文件的时间 time_t st_ctime; /* time of last status change */ 最后一次改变该文件状态的时间 }; stat结构体中的st_mode 则定义了下列数种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74a1c7963a8eb28f76fa11fc92c0834e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09accec319a25ab5e9486ca75907be7b/" rel="bookmark">
			矩阵的求导运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b1ea83d2f6b388494f10d6eeeebb28/" rel="bookmark">
			python3.8,3.9,3.10,3.11特性比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近计划将python2迁移到python3，由于本人学习时用的3.7版本，所以仅作大于3.7版本的比较。
3.8 文档地址：python3.8
新增赋值表达式:=（海象运算符） 作用：避免重复调用，使代码更加简洁。PS：别当GO写，它不支持声明并赋值变量
import re # 3.8 if match := re.search(r"python", "I love python! \r\n And python love me! \r\n", re.I | re.M | re.DOTALL): print(match.group()) # 3.7 match = re.search(r"python", "I love python! \r\n And python love me! \r\n", re.I | re.M | re.DOTALL) if match: print(match.group()) 仅限位置形参 作用：
新增了一个函数形参语法 / 用来指明某些函数形参必须使用仅限位置而非关键字参数的形式。/区分了前后用什么传参方式 # *号代表e,f必须用键值 # /号代表a,b必须用位置 def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) # 合法调用 f(10, 20, 30, d=40, e=50, f=60) # 不合法调用 f(10, b=20, c=30, d=40, e=50, f=60) # b不能是关键词参数 f(10, 20, 30, 40, 50, f=60) # e必须是关键字参数 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b1ea83d2f6b388494f10d6eeeebb28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b75584a861676ab4a3ebcfea69cffa0/" rel="bookmark">
			vscode终端字体放大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		左下角设置按钮，选Settings，输入font size，
往下翻，有一个是 Terminal&gt;Integrated: Font size，
改数值即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4164665d9aa3f3f423053fa8e3b1aaf9/" rel="bookmark">
			SpringAOP面向切面编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. AOP是什么？二. AOP相关概念三. SpringAOP的简单演示四. SpringAOP实现原理 一. AOP是什么？ AOP（Aspect Oriented Programming）：面向切面编程，它是一种编程思想，是对某一类事情的集中处理；它能够在不改原有代码的前提下对其功能进行增强，就是你代码已经写好了，使用 AOP 可以在不改动代码的前提下增强功能，如对于一个功能，可以基于 AOP 完成对该功能执行效率的计算，能够在功能正式执行前或者执行后，添加其他的功能执行，能够在该功能发生异常后，对其异常进行处理。
想象一个场景，我们在做后台系统时，除了登录和注册等几个功能不需要做用户登录验证之外，其他几乎所有页面都需要先验证用户登录的状态，那这个时候我们要怎么处理呢？
如果不使用 AOP，我们就需要在每一个 Controller 层都写一遍验证用户是否已经登录的逻辑，如果你实现的功能有很多，并且这些功能都需要进行登录验证，那你就需要编写大量重复的代码， 这样代码修改和维护的成本也会很高。
但如果使用 AOP，在进入核心的业务代码之前会做统一的一个拦截，去验证用户是否登录，验证通过的就可以继续请求，此时就不需要每一处都写相同的用户登录逻辑了。
除了登录验证功能之外，还有很多功能也可以使用 AOP，比如：
统一日志记录与持久化。统一方法执行时间统计。统一数据返回格式。统一处理程序中的异常。统一事务的开启与提交。 也就是说使用 AOP 可以扩充多个对象的某个能力，所以 AOP 可以说是 OOP （Object Oriented Programming，面向对象编程）的补充和完善，它可以将横切关注点从应用程序的主业务逻辑中分离出来，使得这些关注点可以集中处理，从而提高代码复用性、可维护性和系统可扩展性。
SpringAOP 是一个框架，提供了对 AOP 的实现，与 IOC 与 DI 的关系类似。
二. AOP相关概念 切面（Aspect）–&gt; 类：某一方面的具体内容处理（AOP实现的某个功能的集合）就是一个切面，由切点（Pointcut）和通知（Advice）组成 ；比如用户登录判断就是一个切面（接口对于登录权限的校验）。切点（Pointcut）–&gt;方法：定义拦截规则；比如切面对于哪些接口需要进行判断拦截。连接点（Joinpoint）：所有可能触发切点的点就是连接点（被这个切面所处理的点）。通知（方法的具体实现）：执行 AO P业务（具体需要执行的拦截方法）。 在 Spring 切面类中，可以在方法上使用以下注解，会设置方法为通知方法，在满足条件后会调用对应满足条件的方法：
前置通知使用 @Before∶通知方法会在目标方法调用之前执行。后置通知使用 @After∶通知方法会在目标方法返回或者抛出异常后调用。返回之后通知使用 @AfterReturning∶ 通知方法会在目标方法返回后调用。抛异常后通知使用 @AfterThrowing∶ 通知方法会在目标方法抛出异常后调用。环绕通知使用 @Around∶通知包裹了被通知的方法，在被通知的方法通知之前和调用之后执行自定义的行为。 AOP 整个组成部分的概念如下图所示，以多个⻚⾯都要访问⽤户登录权限为例：
三. SpringAOP的简单演示 1️⃣第一步，添加 Spring Boot AOP 依赖支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4164665d9aa3f3f423053fa8e3b1aaf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b5c51cf105808f5a4062e772de1ab5/" rel="bookmark">
			VSCode&#43;Keil5&#43;cubeMX开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载 1、VSCode下载 下载链接：
Download Visual Studio Code - Mac, Linux, Windows
VSCode官网 这里是VSCODE官网的下载界面，选择自己需要的配置及版本即可（一般情况下点击Windows即可）。
官网下载速度较慢，所以这里推荐一个新的下载地址：VSCodeUserSetup-x64-1.54.2.exe - 蓝奏云
一般点击普通下载就可以了。
2、Keil下载 下载链接：Keil Product Downloads
Keil官网 3、STM32CubeMX下载 下载链接：STM32CubeMX - STM32Cube initialization code generator - STMicroelectronics
STM32CubeMX官网 4、百度网盘下载 下载链接：https://pan.baidu.com/s/1g0nE2yQiRYioQ_4IjLctbA 提取码：ykk8
注意：网盘失效可联系QQ获取下载链接：3501969901
软件的安装及搭建 为了方便管理，现在任意一个盘（不推荐C盘）新建一个文件节夹，用于管理安装的所有文件。
1、VS Code安装 （这里以下载好的百度网盘文件为例）
第一步：打开文件
第二步：安装
2、Keil安装 （这里以下载好的百度网盘文件为例）
第一步:打开文件
第二步：安装软件
下面会弹出在线安装，我们一般采用离线安装的方式，所以都×掉。
3、STM32CubeMX安装 （这里以下载好的百度网盘文件为例）
第一步：打开文件
第二步：安装
环境配置 Keil环境配置 1、打开License生成工具，复制CID码，生成License Key 第一步：打开文件
第二步：打开（建议将电脑静音）
第三步：打开Keil（以管理员身份运行），打开后X掉在线安装界面，然后进行如下操作
第四步：返回到Keygen
第五步：返回keil5
2、安装固件库/支持包 （以网盘下载好的支持包为例）
网站下载链接：Arm Keil | Devices
第一步：打开文件
第二步：安装软件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b5c51cf105808f5a4062e772de1ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965d6796aec30ba940fe6237a93c461e/" rel="bookmark">
			thinkPhp5返回某些指定字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //去除掉密码 $db = new UserModel(); $result = $db-&gt;field('password',true)-&gt;where("username='{$params['username']}' AND password='{$params['password']}'")-&gt;find(); 或者指定要的字段的数组 $db = new UserModel(); $result = $db-&gt;field(['username','create_time'])-&gt;where("username='{$params['username']}' AND password='{$params['password']}'")-&gt;find(); 查询符合条件的多条数据
$db2 = new RoleRightModel(); $result2 = $db2-&gt;field('right_id')-&gt;where('role_id',1)-&gt;select(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a25a411d61cd1ab8ae21556c1d94459/" rel="bookmark">
			光伏并网逆变器低电压穿越MATLAB仿真模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整资源请查看主页置顶博客（专享优惠）
使用MATLAB 2017b搭建
光伏逆变器低电压穿越仿真模型，boost加NPC拓扑结构，基于MATLAB/Simulink建模仿真。具备中点平衡SVPWM控制，正负序分离控制，pll，可进行低电压穿越仿真。
控制结构完整，波形完美！！
主体模块：
PV Array模块
boost模块
inverter模块
控制模块
扰动设置：
输出波形
%%%%%%%%%%
#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
int main()
{
double x, y, a;
for (y = 1.5; y &gt; -1.5; y -= 0.1)
{
for (x = -1.5; x &lt; 1.5; x += 0.05)
{
a = x * x + y * y - 1;
if (a * a * a - x * x * y * y * y &lt;= 0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a25a411d61cd1ab8ae21556c1d94459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9751932709208231f3edcad66563f558/" rel="bookmark">
			基于webjava的宠物救助领养系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临近学期结束，还是毕业设计，你还在苦苦思考该怎么做或是卡bug在了哪一步等等。这里，你想解决的问题，可以私信我，我上线后看到会回复的~代码太多就不一一往上po啦。
原始SpringBoot、Web以及HTML+CSS+JS页面设计, web大学生网页毕设或者平时码的一个平面html设计作业源码等等都可以参考得到解决。
使用：IDEA、Bootstrap、C、Session、jdk、MYSQL、HTML、CSS、JS
以宠物救助领养系统来举例：
分为前端页面和管理系统 ：
系统有三种用户，分别为游客、注册/登录用户、管理员
游客只可以查看宠物照片；
注册/登录用户可以进行评论、发帖、申请领养等功能；
管理员主要的权限是管理用户，审核用户的评论、帖子，修改宠物的信息等；
前端页面展示：
注册、登录
前端主页展示：
管理系统管理员页面：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb1eab6c00291c50a4e5e8d1300cebcd/" rel="bookmark">
			浏览器跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 什么是跨域跨域的原理跨域出现的场景跨域的解决 什么是跨域 违背同源策略就是跨域。
同源策略: 网页的url 和 该网页请求的url 的协议、域名、端口必须保持一致。
协议、域名、端口必须保持一致.
同源策略存在的原因: 保护用户隐私和防范网络攻击(https://editor.csdn.net/md?not_checkout=1&amp;spm=1011.2415.3001.6217&amp;articleId=132763789)
即如果网页请求的url 和 网页的url 的协议、域名、端口任意一项不同就是跨域。
跨域的原理 跨域是请求发出去了，服务器接收并返回了结果，只是浏览器没有接收响应结果。
跨域出现的场景 html中的跨域：图像加载（img的src，background的url）、脚本引用（script的src）。但是通过这些标签访问的资源虽然即使是跨域资源，但浏览器仍然会允许资源的加载和显示。—— jsonp的原理windows跨域：window.open(”跳转的地址“)，当跳转的地址和项目的地址不满足同源策略的时候可能会出现跨域问题。js中的跨域：XML请求（XMLHttpRequest），XMLHttpRequest是一种常见的通过 JavaScript 发起跨域请求的方式。浏览器会基于同源策略对XMLHttpRequest发起的跨域请求进行限制。 —— 最常见的形式 跨域的解决 分上面三种情况分别解决
html中的跨域：html中的跨域浏览器并不会限制，所以不用处理windows跨域： windows跳转出现的跨域问题可以使用rel="noopener noreferrer" 属性进行解决 window.open("https://www.example.com", "_blank", "rel=noopener,noreferrer"); 这个属性指示浏览器不要在打开的新窗口中传递引用到原始页面，从而限制了对原始页面的访问，从而不会出现跨域问题。
使用服务器中间页：创建一个位于自己域名下的服务器中间页，该中间页作为跳转页，用于将用户重定向到目标页面。CORS方式（下面说） js中的跨域：一般说的就是XML跨域（ajax跨域） jsonp方式解决——利用script标签的跨域不限制性
前端需要定义函数，而且后端需要调用该函数
jsonp只能解决GET请求跨域，所以jsonp请求很少用CORS方式解决
CORS通过设置响应头来实现跨域请求，由后端人员添加响应头 response.setHeader('Access-Control-Allow-Origin','*'); 浏览器一看到后端携带的响应头就不拦截数据了，就可以实现跨域请求。
造成的问题是任何人都可以向该后端要数据，是不安全的。
(可以通过使用浏览器的开发者工具来查看HTTP响应头部中是否包含Access-Control-Allow-Origin字段来判断该资源是否设置了Access-Control-Allow-Origin共跨域使用)
jsonp和CORS方法的使用详见：https://blog.csdn.net/mantou_riji/article/details/124767753?ydreferer=aHR0cHM6Ly9tcC5jc2RuLm5ldC9tcF9ibG9nL21hbmFnZS9hcnRpY2xlP3NwbT0xMDAxLjIxMDEuMzAwMS41NDQ4
最后一种解决方法就是代理服务器。
代理服务器的原理：
设置一个代理服务器，它的协议名、主机名、端口号和前端页面的一模一样，这样前端访问该代理服务器就没有跨域问题了。
当该代理服务器收到前端的请求，再向其他服务器发送该请求，获取数据，之后将数据返回给前端。
（服务器之间不是通过ajax请求发送信息自然也没有跨域这个问题了）
代理服务器的实现： nginx实现代理服务器： niginx配置代理转发的文件，当用户访问这个网址的时候就将代理进行转发node实现代理服务器：。。。如果是vue项目直接配置vue.config.js：
配置代理服务器需要对vue.config.js做如下配置： module.exports = { devServer: { // 这里配置的是向哪台服务器发送请求 // （代理服务器的地址不用管他会自动配置） proxy: '协议名://主机名:端口号' } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71665716f6e1285d18c52812a65c0a36/" rel="bookmark">
			ntpd 和ntpdate 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ntpd 和 ntpdate 都是用于进行网络时间同步的工具，但在功能和使用方式上有所不同。
ntpd（Network Time Protocol daemon）是 NTP 守护进程，用于在计算机网络中持续同步系统时钟与全球标准时间。ntpd 可以在计算机启动时自动启动，并通过与外部 NTP 服务器进行通信来获取时间同步信息并进行时间调整。它可以使用配置文件（例如 /etc/ntp.conf）指定要使用的 NTP 服务器和其他参数，并提供许多高级特性，例如选择最佳时间源、跟踪时钟漂移等。ntpd 适合用于需要高精度和长期稳定的时间同步场合。
ntpdate 是一个简单的命令行工具，可以手动或自动同步系统时钟。它是一个单次工具，即当执行完后，它就会停止，并将系统时间设置为指定的时间。ntpdate 可以从指定的 NTP 服务器获取时间信息，然后将系统时间调整到与该服务器时间尽可能接近的状态。ntpdate 适合用于需要手动同步时间或在计划任务中使用的场合。
ntpd 适合长期稳定的时间同步需求，而 ntpdate 更适合在需要手动控制时间同步或进行一次性同步的场合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2078d6bd26a851d4faeacdcc4551ae8/" rel="bookmark">
			使用多线程监听模型训练过程中实际显存占用nvidia-smi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用torch.cuda.max_allocated_memory时只能返回torch tensor占用显存大小，需要加上模型的大小，而模型的加载大小也不是单纯的model文件夹的大小，此时只能使用watch -n 0.1 nvidia-smi的指令进行人肉监听。
除此外，TRT等运行时也不支持torch.cuda的方法。
这里我开了个线程用于监听内存。
import nvidia_smi from threading import Thread from multiprocessing import Process import time class Monitor(Thread): def __init__(self, delay, index): super(Monitor, self).__init__() self.stopped = False self.index=index self.delay = delay # Time between calls to nvidia-smi # st mem nvidia_smi.nvmlInit() handle = nvidia_smi.nvmlDeviceGetHandleByIndex(index) info = nvidia_smi.nvmlDeviceGetMemoryInfo(handle) self.st_mem=info.used print( "start used memory is {} GiB".format(info.used* 1.0 / 1024**3)) nvidia_smi.nvmlShutdown() #st_end self.max_mem=0 time.sleep(self.delay) self.start() def run(self): while not self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2078d6bd26a851d4faeacdcc4551ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8d8108cef2a15084af43885e8b7959/" rel="bookmark">
			关闭win10自动更新四种方法 永久关闭win10自动更新教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：服务中关闭Win10自动更新
1、首先按下“win+R”开启运行功能，然后输入“services.msc”并点击确定;
2、随后找到“Windows Update”并双击;
3、重启电脑即可完成设置。
方法二：设置中关闭win10自动更新
1、打开windows更新
2、点击“高级选项”
3、重启电脑即可完成设置。
方法三：组策略关闭Win10自动更新服务
1、首先在WIN10电脑中运行输入gpedit.msc点击确定，如下图所示：
2、然后点击计算机配置里的管理模板，如下图所示：
3、接下来点击管理模板下面的 Windows 组件，如下图所示：
4、然后找到Windows 更新并点击进去，如下图所示
6、最后点击左上角的“已禁用”功能就彻底关闭win10自动更新了，如下图所示：
7、重启电脑即可完成设置。
方法四：注册表中关闭Win10自动更新
1、为了防止Win10自动更新还会死灰复燃，我们还需要在注册表设置中巩固一下。首先使用 Win + R 组合快捷键，打开运行对话框，然后输入命名 regedit，然后点击下方的「 确定 」打开注册表，如图所示。
2、在注册表设置中，找到并定位到 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\UsoSvc]。然后在右侧找到“Start”键，右键点击修改，把start值改成16进制，值改为“4”，然后点击「 确定 」保存数据，如图所示。
3、继续在右侧找到“FailureActions”键，右键点击修改该键的二进制数据，将“0010”、“0018”行的左起第5个数值由原来的“01”改为“00”，完成后，点击下方的“确定”即可，如图所示。
4、重启电脑即可完成设置。
以上的全部内容就是今天小编给大家带来的四种可以有效的关闭win10自动更新的方法，用户可以自由的进行选择，选择最适合自己的办法来操作就好，希望能够帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab72bc4fbae06b03cf554b72db8215d/" rel="bookmark">
			Git忽略文件的几种方法，以及.gitignore文件的忽略规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 .gitignore文件Git忽略规则以及优先级.gitignore文件忽略规则常用匹配示例： 有三种方法可以实现忽略Git中不想提交的文件。1、在Git项目中定义 .gitignore 文件（优先级最高，推荐！）2、在Git项目的设置中指定排除文件3、定义Git全局的 .gitignore 文件（个人使用方便，但是团队的话不适用，因为是在自己电脑设置的全局）如何检查自己写的ignore规则是否有效？gitignore规则不生效 .gitignore文件 在使用Git的过程中，我们喜欢有的文件比如日志，临时文件，编译的中间文件等不要提交到代码仓库，这时就要设置相应的忽略规则，来忽略这些文件的提交。
注意：如果你创建.gitignore文件之前就push了某一文件，那么即使你在.gitignore文件中写入过滤该文件的规则，该规则也不会起作用，git仍然会对该文件进行版本管理。
Git忽略规则以及优先级 详细的忽略规则可以参考官方英文文档。
在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：
从命令行中读取可用的忽略规则当前目录定义的规则父级目录定义的规则，依次递推，目录结构较高的.gitignore文件被较近的.gitignore文件中相同的配置所覆盖.git/info/exclude文件中定义的规则core.excludesfile中定义的全局规则 .gitignore文件忽略规则 空格不匹配任意文件，可作为分隔符，方便阅读。#用于注释，\表示转义（如需使用实体\，则要加引号"\"）。*可以匹配任何字符（0或多个）。?可以匹配单个字符。（不可以匹配/）/用于分隔目录： 当/在开头时，表示从.gitignore文件所在的根目录开始匹配。当/在末尾时，只匹配目录及该目录下面的全部内容，否则同名的目录和文件都将匹配。 !开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用!也不会再次被包含。[]通常用于匹配一个字符列表，如：a[mn]z可匹配amz和anz。**用于匹配多级目录，如a/**/b可匹配a/b，a/x/b，a/x/y/b。
注意：git 对于 .gitignore配置文件是按行从上到下进行规则匹配的。 常用匹配示例： #: 表示此为注释,将被Git忽略。*:表示忽略所有。*/:表示忽略所有目录。1.txt: 忽略任意目录（当前目录即根目录及其子文件夹）下的1.txt的文件夹或同名文件，例如1.txt，/pojo/1.txt，/pojo/a/1.txt，若是文件夹则该文件夹下的所有内容都会被忽略。*.txt: 忽略任意目录（当前目录即根目录及其子文件夹）下的所有以.txt结尾的文件夹或文件，若是文件夹则该文件夹下的所有内容都会被忽略。/1.txt:忽略根路径下的1.txt的文件夹或同名文件，若是文件夹则该文件夹下的所有内容都会被忽略。/*.txt: 忽略根路径下的所有以.txt结尾的文件夹或文件，若是文件夹则该文件夹下的所有内容都会被忽略，不忽略 /pojo/1.txt。pojo:忽略任意目录（当前目录即根目录及其子文件夹）下的pojo文件夹或同名文件，若是文件夹则该文件夹下的所有内容都会被忽略。/pojo: 忽略根目录下的pojo文件夹或同名文件，若是文件夹则该文件夹下的所有内容都会被忽略。pojo/: 忽略目录 pojo下的全部内容；注意，不管是根目录下的/pojo/目录，还是某个目录下的 /child/pojo/，以及pojo文件夹里面的全部内容都会被忽略，同时忽略pojo文件夹，以pojo命名的文件不会忽略。pojo/*:忽略当前路径下pojo文件夹下的全部内容，pojo文件夹不忽略。/pojo/: 忽略根目录下的pojo文件夹，该文件夹下的所有内容都会被忽略，以pojo命名的文件不会忽略。pojo/1.txt:忽略当前路径下的pojo下的1.txt的文件夹或同名文件，若是文件夹则该文件夹下的所有内容都会被忽略，不忽略pojo文件夹。/pojo/1.txt:忽略根目录下的pojo文件下的1.txt的文件夹或同名文件，若是文件夹则该文件夹下的所有内容都会被忽略，不忽略pojo文件夹。pojo/*.txt: 忽略当前路径下的pojo文件夹下所有以.txt结尾的文件夹或文件，若是文件夹则该文件夹下的所有内容都会被忽略，不忽略pojo/common/1.txt，不忽略/a/pojo/1.txt，不忽略pojo文件夹。pojo/1.txt/*:忽略当前路径下的pojo文件夹下的1.txt文件夹中的所有文件，1.txt文件夹不忽略。**/pojo: 忽略任意目录下的pojo文件夹或同名文件，若是文件夹则该文件夹下的所有内容都会被忽略。/pojo，/pojo/1.txt，/a/pojo，/a/pojo/1.txt，a/b/pojo等。a/**/b: 忽略当前路径下的以a文件夹为开始，中间可以有0个或任意个目录的b文件夹或同名文件，若是文件夹则该文件夹下的所有内容都会被忽略，a/b，a/x/b，a/x/y/b，a/x/y/b/1.txt等。/pojo/*和!/pojo/1.txt: 忽略pojo目录下的所有文件但不忽略pojo目录下的1.txt文件，pojo文件夹不忽略。
注意上面的/pojo/*不能写为/pojo/，否则父目录被前面的规则排除掉了，1.txt文件虽然加了!过滤规则，也不会生效！ 有三种方法可以实现忽略Git中不想提交的文件。 1、在Git项目中定义 .gitignore 文件（优先级最高，推荐！） 这种方式通过在项目的某个文件夹下定义 .gitignore 文件，在该文件中定义相应的忽略规则，来管理当前文件夹及其子文件夹下的文件的Git提交行为。
.gitignore 文件是可以提交到公有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。
在 .gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如：
样例一：
HELP.md target/ !.mvn/wrapper/maven-wrapper.jar !**/src/main/**/target/ !**/src/test/**/target/ ### STS ### .apt_generated .classpath .factorypath .project .settings .springBeans .sts4-cache ### IntelliJ IDEA ### .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab72bc4fbae06b03cf554b72db8215d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b2fa4358f51b3439784cb08de17e3c/" rel="bookmark">
			CUDA Toolkit多版本安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA Toolkit多版本安装目的是为了将CUDA Toolkit支持多个版本，并将当前版本更新到后续支持常见pytorch的版本（即cuda11.6），目前该系统默认安装的是cuda10.2，cuda11.0和cuda11.2。CUDA一般有两种API，一个是驱动API（Driver Version），依赖NVIDIA驱动，由nvidia-smi查看; 另一个是运行API（Runtime Version）是软件运行所需要的，比如python环境需要的cuda api版本等。一般驱动API版本&gt;=运行API版本即可。
0.cuda版本查询命令
运行API(runtime api)：nvcc -V
驱动API(driver api)：nvidia-smi，循环监控：watch -n 1 -d nvidia-smi
运行环境："Red Hat Enterprise Linux Server7.5，python3.10，cuda11，torch1.13.1
1.下载：https://developer.nvidia.com/ 选择对应的版本进行下载
2.安装：sudo sh cuda_11.6.2_510.47.03_linux.run
选择accept，只选择CUDA Toolkit 11.6，其他都去掉，选择Install，详见下图
3.建立cuda的软链接，一般默认安装完成后会自动创建，后续可根据需要进行软连接的调整，比如改为cuda-11.2等等
进入/usr/local/目录
sudo rm -rf cuda # 删除之前创建的软链接
sudo ln -s /usr/local/cuda-11.6/ /usr/local/cuda # 建立新的软链接（指定软链接版本为11.6）
4.配置PATH，打开.bashrc文件添加如下两行
export PATH="/usr/local/cuda/bin:/root/anaconda3/bin:$PATH"
export LD_LIBRARY_PATH="/usr/local/cuda/extras/CUPTI/lib64:/usr/local/cuda/lib64:$LD_LIBRARY_PATH"
5.配置文件生效：source .bashrc
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/50/">«</a>
	<span class="pagination__item pagination__item--current">51/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/52/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>