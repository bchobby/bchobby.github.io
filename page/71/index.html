<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbcf989633e30fa03f2a890959b59255/" rel="bookmark">
			【C语言】实现简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.实现逻辑
2.运行过程
3.优化前代码分析
主函数
计算函数
4.优化后代码分析
主函数
计算方法函数
输入操作数的函数
5.完整代码展示
1.实现逻辑 实现一个简易的计算器，可以计算两个整数的加减乘除
2.运行过程 3.优化前代码分析 主函数 int main() { int x = 0; int y = 0; int ret = 0; int input = 0; do { menu(); printf("请选择："); scanf("%d", &amp;input); switch (input) { case 0: printf("退出计算器\n"); break; case 1: printf("请输入两个操作数："); scanf("%d %d", &amp;x, &amp;y); ret = Add(x, y); printf("%d\n", ret); break; case 2: printf("请输入两个操作数："); scanf("%d %d", &amp;x, &amp;y); ret = Sub(x, y); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbcf989633e30fa03f2a890959b59255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ddac1abaa09bd29cb77b665362ba042/" rel="bookmark">
			Pixel2XL解锁BL-刷入Twrp-获取Root权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pixel2XL解锁BL-刷入Twrp-获取Root权限 前提: 手机账号退出，不插卡，不联网，删除pin指纹以及开机密码
【一】解锁BL(如已解锁，该步骤不需要) (1) bootloader是什么？ bootloader 中文翻译为启动引导程序。打个比方来说，当我们启动手机的时候，最先开始执行的就是这段程序，然后对手机进行一些基本的初始化，然后进入手机系统 (2) 什么是BL锁 所谓的BL锁 也就是bootloader锁。这是手机厂商对手机系统的一种保护方式，目前大部分的手机都有BL锁，在未解锁的情况下，用户不能修改手机系统或者底层，也就是无法刷机和Root。这就是为什么刷机前需要先解锁BL了 (3) BL锁解除 一般带BL锁的手机都是可以进如fatsboot模式的 常见按键操作就是关机状态音量下键+开机键 注意：
欧版才能解锁美版不能解锁(美版淘宝付费有人解锁) 欧版判断
点击Settings(设置) -&gt; System(系统) -&gt; About phone(关于手机) -&gt; Regulatory labels(监管标签) 查看。
MODEL:
G-2PW4200 4200 表示欧版4100 表示美版演示的是G011C，是美版 【二】Pixel解BL锁步骤 (1)开启usb调试 1 点击Settings(设置) -&gt;
About phone(关于手机) -&gt;版本号(最底部)---&gt;点击7次(开启usb调试) 2 点击Settings(设置) -&gt;
系统---&gt;
高级---&gt;
开发者选项---&gt;
进入
开启OEM解锁
开启USB调试
(2)在电脑上配置 adb 环境(win,mac或Linux机器和一根数据线) 「adb」即 Android Debug Bridge ，亦称安卓调试桥，是谷歌为安卓开发者提供的开发工具之一，可以让你的电脑以指令窗口的方式控制手机。
可以在安卓开发者网页中的 SDK 平台工具页面下直接下载对应系统的 adb 配置文件，大小只有几十MB 1 下载地址(下载对应平台的adb)最新版：
https://developer.android.com/studio/releases/platform-tools?hl=zh-cn
2 各平台历史版本下载地址： https://androidmtk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ddac1abaa09bd29cb77b665362ba042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f249501412bbfedf8ae28b8c185fc59/" rel="bookmark">
			Es索引中时间字段是字符串Range查询的正确姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc] 1. 问题2. Es索引的mapping模式2.1 dynamic动态宽松模式（动态映射）2.2 strict严格模式（静态映射） 3. text类型和keyword类型的区别3.1 text类型3.2 keyword类型 4.正确姿势5. 总结 1. 问题 由于之前搞了一个使用flink-cdc将mysql表中的数据同步到es的索引中，例子中数据库中的orders表中的order_date的字段类型是datetime类型，flink-sql建表orders、enriched_orders中的order_date 字段是TIMESTAMP(0)类型，同步到es的enriched_orders索引中的order_date的类型是：
查询索引的mapping结构语句： GET enriched_orders/_mapping enriched_orders索引的order_date字段类型如下： "order_date" : { "type" : "text", "fields" : { "keyword" : { "type" : "keyword", "ignore_above" : 256 } } } 数据被同步到enriched_orders索引的时候不需要我们创建索引，该索引会自动创建，自动创建的也是可以使用的，如果业务的数据模型有特殊格式要求，可以自己重新设计下数据模型，然后自己先把索引创建好，然后使用cdc同步数据到索引中，需要注意的就是三边的字段的类型的对应，如果字段类型不对应估计是会报错的，这种方式我还没有试过的，哪哈具体的业务上在试下看看，然后就写了下面一个语句根据这个order_date字段查询一个时间范围的数据，DSL语句如下：
GET enriched_orders/_search { "query": { "range": { "order_date": { "gte": "2020-07-30 10:00:00", "lte": "2020-07-31 10:38:11" } } } } 这种方式居然查不到数据，这也是有点奇葩的，这个问题是分词的问题。
2. Es索引的mapping模式 Elasticsearch 索引映射类型及mapping属性详解
https://www.knowledgedict.com/tutorial/elasticsearch-index-mapping.html 2.1 dynamic动态宽松模式（动态映射） Es默认索引的mapping是 dynamic：动态宽松模式，也就是随便写，数据自动冗余，es会根据你写入索引的字段数据进行自动推断该是什么类型，这种方式会导致：字段爆炸（字段膨胀）这种操作在有的时候是很危险的，也就是可以在mapping里面随意加字段，一个不小心随意加了字段可能就导致业务代码报错了，这种方式默认大小为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f249501412bbfedf8ae28b8c185fc59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aac769593e5db6e9ebea4271a5f53b7/" rel="bookmark">
			GPT-4已来，Python API使用最新版GPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenAI在3月发布了GPT-4，本文介绍如何使用Python访问最新版的GPT-4。
微信搜索关注《Python学研大本营》，加入读者群，分享更多精彩
GPT-4 简介 GPT-4是OpenAI最新、最先进的语言模型。GPT-4拥有无可比拟的自然语言处理能力，是开发者的重要资源。本文将探讨如何将GPT-4 API纳入你的Python项目，用于各种应用，包括聊天机器人、编程和内容创作。
GPT-4在多模式、性能和多语言支持方面达到了新高度，是计算机技术的一次跨越，GPT-4在回答问题、生成文本和各种任务方面具有很大潜力。
值得注意的是，GPT-4的字数限制已从ChatGPT的3,000字增加到25,000字。该模型在要求高级推理、复杂的教学理解和增强创造力的任务中表现出色。
如何访问GPT-4？ 概述： 设置环境
登录OpenAI
向GPT-4的API发出请求
1. 设置你的环境 首先，你需要获得API访问凭证。在GPT-4的等待名单上登录，以获得访问权并收到你的API密钥。确保安装OpenAI Python库，以便与GPT-4 API互动。
pip install openai 如果你过去已经使用过openai包，请确保你用以下方法将其更新到最新版本：pip install - upgrade openai。
2. 登录到OpenAI 导入已安装的openai包。此外，还要引入os包和Markdown扩展，这么做可以使输出更加美观。导入之后，需要输入API密钥。
import openai import os from IPython.display import Markdown openai.api_key = "YOUR_KEY" 3. 向GPT-4的API发出请求 最后，告诉GPT-4应该如何使用system_intel参数。这里，我们指示GPT-4要像该领域的专家一样回答问题。作为提示，我们要求GPT-4写一篇关于如何在Python Jupyter笔记本中使用GPT-4的博客。接下来，让我们做一个函数，接收system_intel和提示，并返回结果。
system_intel = "You are GPT-4, answer my questions as if you were an expert in the field." prompt = "Write a blog on how to use GPT-4 with python in a jupyter notebook"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aac769593e5db6e9ebea4271a5f53b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bce9ff9a0a5a6428b289a8063cfce3e/" rel="bookmark">
			开发注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.定义常量类必须加上私有构造 例：定义以下按钮常量类
必须提供一个私有构造，虽然没有私有构造不会报错，但是常量类提供私有构造，这样可以防止类被实例化，防止常量发生被外部改变。提高安全性。
public class ButtonConstant { //私有构造 private ButtonConstant(){} //保存按钮 public static final String SAVE_BUTTON = "save" //取消按钮 public static final String CANCEL_BUTTON = "cancel"; } 2.返回值Boolean类型的结果判断 在if语句中判断Boolean类型的值时，需用Boolean.TRUE.equals()方法，可以防止出现空指针异常
例：
public class TestBoolean { public static void main(String[] args) { TestBoolean testBoolean = new TestBoolean(); if (Boolean.TRUE.equals(testBoolean.method(3))){ System.out.println("测试空指针异常"); } //以下判断出现空指针异常 if (testBoolean.method(3)){ System.out.println("测试空指针异常"); } } public Boolean method(int num){ if (num == 1){ return true; } else if (num == 2){ return true; } else { return null; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ade85d8a49b40e852e1bf9eb6af7f4b/" rel="bookmark">
			08-Mybatis 动态sql查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态 SQL 是 MyBatis 的强大特性之一。使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。
MyBatis 动态 SQL 查询是一种可以根据不同的查询条件生成不同 SQL 语句的功能，方便实现灵活的查询操作。
ifchoose (when, otherwise)trim (where, set)foreach 一、 if &lt;if&gt; 标签是 MyBatis 动态 SQL 查询中使用最为广泛的一个标签，在查询条件比较复杂时，能够有效地帮助我们生成所需的 SQL 语句。
1.使用条件判断语句生成 SQL 片段 &lt;select id="getUserList" resultMap="userResultMap"&gt; SELECT * FROM user &lt;where&gt; &lt;if test="name != null"&gt; AND name = #{name} &lt;/if&gt; &lt;if test="age != null"&gt; AND age = #{age} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 在上述代码中，我们使用了 &lt;if&gt; 标签来生成 SQL 片段，该标签内的 test 属性值为条件判断语句，当符合条件时就会执行 SQL 语句块内的内容。在上述代码中，我们通过判断 name 和 age 是否为 null，来动态生成 SQL 条件语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ade85d8a49b40e852e1bf9eb6af7f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cefd4127251859b4339846fd6ba3f44/" rel="bookmark">
			RocketMQ TLS Client-initiated 重协商攻击(CVE-2011-1473)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境信息 rocketmq:4.8.0
docker镜像 foxiswho/rocketmq:4.8.0
安全漏洞 服务器支持 TLS Client-initiated 重协商攻击(CVE-2011-1473)
SSL 重协商攻击（SSL renegotiation attack）是一种安全漏洞攻击，它利用了 SSL/TLS 协议的重协商功能，通过与服务器重新协商密钥，来发起攻击。
SSL 重协商攻击的危害主要体现在以下两个方面：
密码重置：攻击者可以利用 SSL 重协商攻击来重置 SSL/TLS 会话密钥，从而能够窃取会话中的敏感信息，如用户名、密码等。
DoS 攻击：攻击者可以通过 SSL 重协商攻击来占用服务器的计算资源，从而导致服务器性能下降，甚至崩溃。
因此，SSL 重协商攻击是一种非常危险的攻击方式，需要及时采取措施来防范。
漏洞验证 访问装了mq的服务器，涉及到了3个端口，默认端口9876、9709、9711
openssl s_client -connect 192.168.68.200:9876
输入R触发重协商,可重协商10次以上且连接未断开,重协商成功,漏洞存在。
漏洞修复 方式一 修改启动脚本 2种方式修改启动脚本，启动脚本中添加 -Djdk.tls.rejectClientInitiatedRenegotiation=true
mqnamesrv 对应修改启动脚本 runserver.sh
mqbroker 对应修改启动脚本 runbroker.sh
执行脚本替换。
基于以上修改原理，所以针对docker容器中修改方式
1、直接在mq容器启动时，替换启动脚本
2、可以发现执行脚本都使用到了JAVA_OPT_EXT，可以启动容器时，设置JAVA_OPT_EXT达到目的。
这里采用成本较小的设置JAVA_OPT_EXT达到目的
设置 JAVA_OPT_EXT 使用dockerfile方式 ENV JAVA_OPT_EXT="-Djdk.tls.rejectClientInitiatedRenegotiation=true" CMD [ "sh", "mqnamesrv", "-c", "/home/rocketmq/rocketmq-4.8.0/conf/namesrv.properties ${JAVA_OPT_EXT}"] 使用 docker-compose.yml，在配置中添加 environment: JAVA_OPT_EXT: '-Djdk.tls.rejectClientInitiatedRenegotiation=true' 当同时使用到了dockerfile和docker-compose.yml时，要注意不要同时设置JAVA_OPT_EXT，会存在覆盖情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cefd4127251859b4339846fd6ba3f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb63a71606ff6d819b040142553ac3f3/" rel="bookmark">
			Jetpack Compose — 让Composable具备生命周期感知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetpack Compose — 让Composable具备生命周期感知 我们将研究不同的方法来实现可组合（Composable）的生命周期感知。我们还将了解可组合生命周期和视图（View）生命周期之间的区别。
我们将逐步探索不同的解决方案，以寻找一种更好的方式来观察“Jetpack Compose-Way”中组件生命周期事件。
Composable的生命周期是什么？ 在官方文档中已经清楚地解释了Composable的生命周期。在本文中，我将简要介绍一下。
https://developer.android.com/jetpack/compose/lifecycle
组合的 lifecycle由以下阶段定义：
Enter the Composition - 当Jetpack Compose第一次运行组合时，它会跟踪用于描述UI的组合，并构建所有组合的树形结构，称为组合。
Recomposition - 当任何状态发生变化最终影响UI时，Jetpack Compose聪明地识别出这些组合，并仅对它们进行重新组合，而无需更新所有组合。
Leave the Composition - 当UI不再可见时，它是最后一个阶段，因此会删除所有已使用的资源。
以下图表（源自官方文档）很好地展示了这些阶段。
https://developer.android.com/jetpack/compose/lifecycle
View的生命周期是什么？ 在移动开发中，视图的生命周期是一个非常基本的概念，它是UI层许多功能依赖的核心模式。通过控制视图的不同状态，我们可以执行所需的工作。这些不同的状态包括onCreate、onStart、onPause、onResume、onStop和onDestroy。
在不同的使用情境下，我们必须对这些生命周期事件做出相应的反应。例如，如果用户离开页面，可能有一些资源不再需要，我们可以释放它们；或者如果用户从后台返回到前台，可能希望重新获取最新的信息以展示更新的内容等等。这样的使用情境还有很多。
Composable的 生命周期 vs View的生命周期 可组合（Composable）的生命周期与视图（View）的生命周期是两种不同的模式。
Jetpack Compose 引入了可组合的生命周期，与视图的生命周期无关。可组合的生命周期涉及创建 UI 组件树结构、跟踪状态变化并提供高效的 UI 更新。而视图的生命周期则与用户在我们的应用程序/屏幕中的交互方式触发的事件有关，例如切换到另一个屏幕、切换到后台、切换到前台等。
为了满足许多用例，我们仍然需要使我们的可组合具有生命周期感知的能力。这意味着我们必须监听视图的生命周期事件并对其做出相应的反应，以提供更好的用户体验。
用例 当用户从后台切换到前台时，我们希望重新获取我们应用程序的数据，从后端获取最新信息并使用该信息更新用户界面。
首先，让我们看一下未实现此行为时的代码样式。
// MainViewModel class NewsViewModel ( private val newsRepository: NewsRepository = NewsRepositoryImpl() ) : ViewModel() { init { fetchNews() } private fun fetchNews() { viewModelScope.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb63a71606ff6d819b040142553ac3f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595d73d4d4a902a4c49fc7d822989419/" rel="bookmark">
			数据库原理与应用第7章作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库原理与应用第7章作业 一. 单选题（共10题，40分）二. 填空题（共3题，15分）三. 简答题（共1题，15分）四. 论述题（共2题，30分） 一. 单选题（共10题，40分） (单选题, 4分)在数据库设计中,在概念设计阶段可用E-R方法,其设计出的图称为 。
A. 实物示意图
B. 实用概念图
C. 实体表示图
D. 实体联系图
(单选题, 4分)
概念模型独立于 。
A. E-R模型
B. 硬件设备和DBMS
C. 操作系统和DBMS
D. DBMS
(单选题, 4分)
在数据库的概念设计中,最常用的数据模型是 。
A. 形象模型
B. 物理模型
C. 逻辑模型
D. 实体联系模型
(单选题, 4分)
从E-R模型关系向关系模型转换时,一个M∶N联系转换为关系模型时,该关系模式的关键字是 。
A. M端实体的关键字
B. N端实体的关键字
C. M端实体关键字与N端实体关键字组合
D. 重新选取其他属性
(单选题, 4分)
数据库物理设计完成后,进入数据库实施阶段,下列各项中不属于实施阶段的工作是 。
A. 建立库结构
B. 扩充功能
C. 加载数据
D. 系统调试
(单选题, 4分)数据流程图(DFD)是用于描述结构化方法中 阶段的工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595d73d4d4a902a4c49fc7d822989419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a2904b7c2b5999da7ee922393d3d54/" rel="bookmark">
			更新公告：Airtest更新至1.2.10.2版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 本次是Airtest库更新，版本提升至1.2.10.2，内容主要是Android录屏功能的改动。
2. 更改部分 在Airtest1.2.9中提供的cv2模式已经被舍弃，因为容易引发错误，效果也不如ffmpeg；
只有Android需要mode参数，默认为yosemite模式；Window/iOS的start_recording 不再需要有mode参数；
录屏的ffmpeg模式增加了max_size参数，能够指定录屏结果的图像大小，因为屏幕图片越大，在录屏时造成的系统负载越大（CPU和内存占用）；
代码示例：
dev = connect_device("android:///") dev.start_recording(output="test.mp4", mode="ffmpeg", max_size=800) # Android 支持mode指定使用ffmpeg模式 3. 其他改动 去掉了numpy 的版本号限制
如果Android出现了屏幕有一半黑屏的情况，可以再次重连
4. 如何更新 1）使用本地python环境的同学 可以直接更新本地python环境的Airtest库：
pip install -U airtest 2）使用AirtestIDE的同学 目前最新的Airtest1.2.15内置Airtest版本为1.2.10，所以我们只能在AirtestIDE中设置使用本地python环境，之后将本地python环境的Airtest更到最新的1.2.10.2来体验新版：
5. Android录屏功能介绍【重点】 1.2.10.2版本的Airtest支持2种录屏模式，yosemite和ffmpeg，默认情况下，都是使用yosemite录屏模式 。
1）如何选择合适的Android录屏模式 上述两种录屏模式的区别如下：
yosemite ：原有的默认模式，录屏清晰度和质量较高，但兼容性较差，部分机型可能有问题；
支持的参数：max_time, orientation, bit_rate, bit_rate_level ffmpeg : 在1.2.9之后加入的新模式，录屏帧率和质量较低，但兼容性更好，能兼容绝大多数设备;
支持的参数：max_time, orientation , max_size,fps, snapshot_sleep 由此可见，如果对录屏清晰度有要求的话，可以使用默认的录屏模式 yosemite (前提是设备能使用这种录屏方式)，不用额外指定录屏模式的参数；
如果对录屏清晰度没有很高要求的话，可以指定录屏模式为 ffmpeg ：
dev = connect_device("Android:///") dev.start_recording(mode="ffmpeg",output="test.mp4") pass dev.stop_recording() 2）重要参数：指定录屏时长 max_time 2种录屏模式均有一个默认的录屏时长：1800s，也就是半小时；用户可以自由修改这个默认的录屏时长：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a2904b7c2b5999da7ee922393d3d54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/937e94ccd122916f086e48f65fed839c/" rel="bookmark">
			Oracle11gRAC安装JVM组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 安装前检查：安装JVM组件：方式一（图形化安装）方式二（执行脚本安装） 检查DB JVM状态脚本 安装前检查： 检查角色：
select * from dba_roles where ROLE in ('JAVAIDPRIV','JAVAUSERPRIV'); 检查DBMS_JAVA：
select * from dba_procedures where OBJECT_NAME= 'DBMS_JAVA'; 检查组件：
-- Start of File full_jvminst_ceshi.sql spool full_jvminst_ceshi.log; set echo on select obj#, name from obj$ where type#=28 or type#=29 or type#=30 or namespace=32; select count(*), object_type from all_objects where object_type like '%JAVA%' group by object_type; select count(*), object_type from all_objects where object_type like '%JAVA%' group by object_type; select count(*), object_type from all_objects where object_type like '%JAVA%' group by object_type; select count(*), object_type from all_objects where object_type like '%JAVA%' group by object_type; select count(*), object_type from all_objects where object_type like '%JAVA%' group by object_type; set echo off spool off exit -- End of File full_jvminst_ceshi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/937e94ccd122916f086e48f65fed839c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3a7a53997037672ea549daf529f7aa/" rel="bookmark">
			ORA-00600: internal error code, arguments: [kcm_headroom_warn_1]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 故障描述：问题处理： 故障描述： 一台老物理服务器搬迁，启动操作系统后尝试启动数据库报错
SQL&gt; startup ORACLE instance started. Total System Global Area 2.0176E+10 bytes Fixed Size	2261928 bytes Variable Size	5167385688 bytes Database Buffers	1.4965E+10 bytes Redo Buffers	41463808 bytes Database mounted. ORA-00600: internal error code, arguments: [kcm_headroom_warn_1], [], [], [], [], [], [], [], [], [], [], [] 数据库告警日志如下:
Wed Jan 01 15:14:49 2014 Errors in file /u01/app/oracle/diag/rdbms/ORCL/ORCL/trace/ORCL_p022_8900.trc: ORA-01578: ORACLE data block corrupted (file # 9, block # 2966543) ORA-01110: data file 9: '/oracle/oradate/nsfw_date1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b3a7a53997037672ea549daf529f7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3720d80bab36f29500f81acd078bf4/" rel="bookmark">
			WPF_MVVM简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVVM即Model-View-ViewModel Model：Class（实体类）View：UI（User Interface）ViewModel：Model for View（逻辑代码） MVVM模式实例 Command internal class DelegateCommand : ICommand { //命令可执行性发生变化时，发送通知 public event EventHandler? CanExecuteChanged; //判断委托执行函数 public bool CanExecute(object? parameter) { //未设置判断委托则默认可执行 if (this.CanExecuteFunc == null) { return true; } return this.CanExecute(parameter); } //执行委托执行函数 public void Execute(object? parameter) { //未设置执行委托则默认不执行 if (this.ExecuteAction == null) { return; } this.ExecuteAction(parameter); } //创建委托属性（执行委托 与 判断委托） public Action&lt;object&gt; ExecuteAction { get; set; } public Func&lt;object,bool&gt; CanExecuteFunc { get; set; } } Model层 根据需要添加实体类（此处仅演示MVVM模式，不涉及数据库）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b3720d80bab36f29500f81acd078bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6071cee35b905e33ef3b101dfffdd7a8/" rel="bookmark">
			【群智能算法】哈里斯鹰优化算法 HHO算法【Matlab代码#19】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【`获取资源`请见文章第6节：资源获取】1. 算法简介2. 探索行为3. 开发行为4. 部分代码展示5. 仿真图展示6. 资源获取 【获取资源请见文章第6节：资源获取】 1. 算法简介 HHO算法通过模仿哈里斯鹰的群体狩猎行为和突袭围捕策略实现优化算法的全局寻优，其捕猎过程分为全局探索和局部开发两个阶段。
哈里斯鹰优化算法（Harris’ Hawk Optimization，简称HHO）是一种基于鹰的行为策略的启发式优化算法。该算法模拟了鹰群中鹰之间的合作行为，通过模拟狩猎过程来寻找最优解。
HHO算法的工作原理如下：
初始化鹰的位置和速度，这些位置和速度代表了解空间中的候选解。
计算每只鹰的适应度值，适应度值代表了候选解的优劣程度。
根据适应度值选择一只"领导鹰"，通常是适应度最好的鹰。
根据一定的概率，随机选择其他鹰作为"跟随鹰"，这些鹰将采用领导鹰的行动策略。
根据鹰的行为策略（如搜索、追捕、聚集等），更新鹰的位置和速度。
判断是否达到终止条件，如果满足则输出最优解；否则返回步骤2。
HHO算法通过模拟鹰群的协作行为，将优化问题转化为搜索过程，并通过迭代来逐步改进解的质量。相比于传统的优化算法，HHO算法具有以下优点：
多样性：HHO算法通过引入随机选择的"跟随鹰"，增加了解空间的多样性，有助于避免陷入局部最优解。
协作性：领导鹰和跟随鹰之间的协作有助于信息共享和全局搜索，有助于更快地找到最优解。
简单性：HHO算法的实现相对简单，易于理解和应用。
然而，需要注意的是，HHO算法并不是适用于所有类型的优化问题，其性能可能受到问题特性的影响。在实际应用中，需要根据具体问题的特点选择合适的优化算法。
2. 探索行为 3. 开发行为 4. 部分代码展示 %% Exploitation: % Attacking the rabbit using 4 strategies regarding the behavior of the rabbit %% phase 1: surprise pounce (seven kills) % surprise pounce (seven kills): multiple, short rapid dives by different hawks r=rand(); % probablity of each event if r&gt;=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6071cee35b905e33ef3b101dfffdd7a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee26ca8f0a9b66829df41467f572a096/" rel="bookmark">
			K8S之istio流量控制管理（十七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，istio介绍
1、istio架构
结合上图我们来理解Istio的各组件的功能及相互之间的协作方式。
1. 自动注入：在创建应用程序时自动注入 Sidecar代理Envoy程序。在 Kubernetes中创建 Pod时，Kube-apiserver调用控制面组件的 Sidecar-Injector服务，自动修改应用程序的描述信息并注入Sidecar。在 真正创建Pod时，在创建业务容器的Pod中同时创建Sidecar容器。
2. 流量拦截：在 Pod 初始化时设置 iptables 规则，基于配置的iptables规则拦截业务容器的Inbound流量和Outbound流量到Sidecar上。而应用程序感知不到Sidecar的存在，还以原本的方式 进行互相访问。上图中，流出frontend服务的流量会被 frontend服务侧的 Envoy拦截，而当流量到达forecast容器时，Inbound流量被forecast 服务侧的Envoy拦截。
3. 服务发现：服务发起方的 Envoy 调用控制面组件 Pilot 的服务发现接口获取目标服务的实例列表。上图中，frontend 服务侧的 Envoy 通过 Pilot 的服务发现接口得到forecast服务各个实例的地址。
4. 负载均衡：服务发起方的Envoy根据配置的负载均衡策略选择服务实例，并连接对应的实例地址。上图中，数据面的各个Envoy从Pilot中获取forecast服务的负载均衡配置，并执行负载均衡动作。
5. 流量治理：Envoy 从 Pilot 中获取配置的流量规则，在拦截到 Inbound 流量和Outbound 流量时执行治理逻辑。上图中， frontend 服务侧的 Envoy 从 Pilot 中获取流量治理规则，并根据该流量治理规则将不同特征的流量分发到forecast服务的v1或v2版本。
6. 访问安全：在服务间访问时通过双方的Envoy进行双向认证和通道加密，并基于服务的身份进行授权管理。上图中，Pilot下发安全相关配置，在frontend服务和forecast服务的Envoy上自动加载证书和密钥来实现双向认证，其中的证书和密钥由另一个管理面组件 Citadel维护。
7. 服务监测：在服务间通信时，通信双方的Envoy都会连接管理面组件Mixer上报访问数据，并通过Mixer将数据转发给对应的监控后端。上图中，frontend服务对forecast服务的访问监控指标、日志和调用链都可以通过这种方式收集到对应的监控后端。
8. 策略执行：在进行服务访问时，通过Mixer连接后端服务来控制服务间的访问，判断对访问是放行还是拒绝。上图中，Mixer 后端可以对接一个限流服务对从frontend服务到forecast服务的访问进行速率控制等操作。
9. 外部访问：在网格的入口处有一个Envoy扮演入口网关的角 色。上图中，外部服务通过Gateway访问入口服务 frontend，对 frontend服务的负载均衡和一些流量治理策略都在这个Gateway上执行。
实际上Istio 就是 Service Mesh 架构的一种实现，服务之间的通信（比如这里的 Service A 访问 Service B）会通过代理（默认是 Envoy）来进行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee26ca8f0a9b66829df41467f572a096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf1c9a6a188ce18197d00a341babced/" rel="bookmark">
			caj文件在线转换成pdf方法，看这个就会了!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当需要将Caj文件转换为PDF格式时，有多种方法可供选择。本文将介绍三种常用的方法，以帮助您完成这个任务。
第一种方法：使用记灵在线工具
一种常用的方法是利用记灵在线工具，它是一款提供免费文件转换服务的在线工具。以下是使用记灵进行Caj转PDF的步骤：
打开记灵在线工具网站，可以通过搜索引擎查找并访问官方网站。在记灵网站上，找到文件转换功能或搜索框。输入关键词"Caj转PDF"，或直接在搜索框中输入"caj"。记灵网站将列出相关的文件转换选项，找到"Caj to PDF"或类似选项，点击进入该功能页面。在该页面中，您会看到一个文件上传或选择的功能区域。点击选择文件按钮，并从您的计算机中选择要转换的Caj文件。选择文件后，记灵将开始处理并转换您的Caj文件。这可能需要一些时间，具体取决于文件的大小和记灵的性能。在转换完成后，记灵网站通常会提供一个下载链接，您可以使用该链接下载转换后的PDF文件。 记灵是一个方便易用的在线工具，可以帮助您将Caj文件快速转换为PDF格式。请注意，记灵可能会有一些限制，例如文件大小限制或转换次数限制，您可以根据自己的需求选择适合的在线工具。无论您选择哪种方法，都要确保选择一个可信的网站，并注意您的文件的隐私和机密性。
第二种方法：使用专业的Caj转PDF软件
除了在线工具，您还可以使用专业的Caj转PDF软件。这些软件通常提供更多的功能和选项，可以更好地处理和转换Caj文件。以下是使用专业软件的步骤：
在互联网上搜索并选择一款可靠的Caj转PDF软件，例如"Wondershare PDF Converter"或"VeryPDF PDFcamp Printer"。下载并安装所选软件，按照安装向导的指示进行操作。打开软件并导入要转换的Caj文件。一般来说，您可以通过"文件"菜单或类似的选项来选择要转换的文件。配置转换选项。根据软件的不同，您可能可以选择PDF的输出路径、页面设置、图像压缩等选项。点击"转换"或"开始"按钮，软件将开始处理并转换Caj文件为PDF格式。转换完成后，您可以在指定的输出路径中找到生成的PDF文件。 使用专业软件可以提供更多的自定义选项和更好的转换质量，但有时可能需要付费购买软件许可。
第三种方法：使用Adobe Acrobat Pro
如果您有安装了Adobe Acrobat Pro的计算机，您也可以使用该软件来进行Caj到PDF的转换。以下是使用Adobe Acrobat Pro的步骤：
打开Adobe Acrobat Pro软件。在工具栏上选择"文件"，然后选择"创建"，再选择"PDF from File"。在文件浏览器中选择要转换的Caj文件，并点击"打开"。Acrobat Pro将自动开始处理并转换所选的Caj文件为PDF格式。一旦转换完成，您可以保存生成的PDF文件。 Adobe Acrobat Pro是一种功能强大的PDF处理软件，除了文件转换功能，还提供许多其他高级功能，例如PDF编辑、合并、加密等。
总结：
将Caj文件转换为PDF格式有多种可行的方法。您可以选择使用记灵在线工具，这是一个简单快捷的解决方案，适用于一次性转换文件。如果您需要更多的选项和更好的转换质量，可以考虑使用专业的Caj转PDF软件。另外，如果您拥有Adobe Acrobat Pro，那么您也可以利用它来完成转换任务。根据您的具体需求和软件可用性，选择最适合您的方法，并开始将Caj文件转换为PDF格式。记得在处理文件时保护您的隐私和安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f6ab8f60ed801b1d3a7276cdae8e38/" rel="bookmark">
			运算放大器与比较器有哪些差异，看完秒懂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较器是一种带有反相和同相两个输入端以及一个输出端的器件，该输出端的输出电压范围一般在供电的轨到轨之间。运算放大器同样如此。乍看似乎可以互换，实际上，两者之间还是存在一些重要差异…
比较器用于开环系统，旨在从其输出端驱动逻辑电路，以及在高速条件下工作，通常比较稳定。
运算放大器过驱时可能会饱和，使得恢复速度相对较慢。施加较大差分电压时，很多运算放大器的输入级都会出现异常表现，实际上，运算放大器的差分输入电压范围通常存在限制。运算放大器输出也很少兼容逻辑电路。
但是仍有很多人试图将运算放大器用作比较器。这种做法在低速和低分辨率时或许可行，但是大多数情况下结果并不理想。今天小编就给大家说说这“结果并不理想”的原因~
1
速度不同
大多数比较器速度都很快，不过很多运算放大器速度也很快。为什么将运算放大器用作比较器时会造成低速度呢？
比较器用于大差分输入电压，而运算放大器工作时，差分输入电压一般会在负反馈的作用下降至最低。当运算放大器过驱时，有时仅几毫伏也可能导致过载，其中有些放大级可能发生饱和。这种情况下，器件需要相对较长的时间从饱和中恢复，因此，如果发生饱和，其速度将比始终不饱和时慢得多(参见图1)。
图1：放大器用作比较器时的放大器速度饱和效应
过驱运算放大器的饱和恢复时间很可能远远超过放大器的正常群延迟，并且通常取决于过驱量。由于仅有少数运算放大器明确规定从不同程度过驱状态恢复所需的时间，因此，一般说来，有必要根据特定应用的具体过驱情况，通过实验确定放大器的特性。
对这类实验的结果应持谨慎态度，通过比较器(运算放大器)的传播延迟值(用于最差条件下的设计计算)应至少为所有实验中最差值的两倍。
2
输出作用不同
比较器的输出端用于驱动特定逻辑电路系列，运算放大器的输出端则用于在供电轨之间摆动。
通常，运算放大器比较器驱动的逻辑电路不会共用运算放大器的电源，运算放大器轨到轨摆动可能会超出逻辑供电轨，很可能会破坏逻辑电路，引起短路后还可能会破坏运算放大器。
有三种逻辑电路必须考虑，即ECL、TTL和CMOS——
ECL是一种极快的电流导引逻辑系列。基于上述原因，当应用中涉及ECL的最高速度时，运算放大器不太可能会用作比较器，因此，通常只需注意从运算放大器的信号摆幅驱动 ECL逻辑电平，因杂散电容造成的额外速度损失并不重要。只需采用三个电阻即可，如图 2所示。
图2：驱动ECL逻辑电路的运算放大器比较器
图中选用了R1、R2和R3，当运算放大器输出为正值时，栅级电平为–0.8 V，当输出较低 时，栅级电平为–1.6 V。ECL有时候采用正电源而不是负电源(即另外一个供电轨接地)，采用的基本接口电路相同，但是数值必须重新计算。
虽然CMOS和TTL输入结构、逻辑电平和电流差别很大(尽管有些CMOS明确规定可以采用 TTL输入电平工作)，但由于这两种逻辑电路都在逻辑0(接近0 V)和逻辑1(接近5 V)时工作，因此非常适合采用相同的接口电路。
图3：驱动TTL或CMOS逻辑电路的运算放大器比较器
最简单的接口采用单个N沟道MOS晶体管和一个上拉电阻RL，如图3所示。用NPN晶体管、RL ，外加一个晶体管和二极管也可以组成类似的电路。这些电路简单、廉价且可靠，还可以连接多个并联晶体管和一个RL ，实现“线或”功能，但是0-1转换的速度取决于RL 值和输出节点的杂散电容。RL 值越低，速度越快，但是功耗也会随之增加。通过采用两个 MOS器件、一个P沟道和一个N沟道，可以组成一个只需两个器件的CMOS/TTL接口，每种状态下都没有静态功耗(参见图4)。
图4：内置CMOS驱动器的运算放大器比较器
此外，只需改变器件的位置，就可以设置成反相或同相。但是，当两个器件同时打开时，开关过程中势必会产生较大的浪涌电流，除非采用集成高通道电阻的MOS器件，否则就可能需要使用限流电阻来减小浪涌电流的影响。该图和图3中的应用所采用的MOS器件栅源击穿电压VBGS在每个方向都必须大于比较器的输出电压。MOS器件中常见的栅源击穿电压值VBGS &gt; ±25 V，这一数值通常绰绰有余，但是很多MOS器件内置栅级保护二极管，会减小这一数值，所以这些器件不应采用。
3
输入考虑因素
对于用作比较器的运算放大器，还需考虑与其输入相关的多种影响因素。工程师对所有运算放大器和比较器做出的第一级假设是：它们具有无穷大的输入阻抗，并且可视为开路(电流反馈(跨导)运算放大器除外，这种运算放大器同相输入端具有高阻抗，但反相输入端只有几十欧姆的低阻抗)。
但是很多运算放大器(尤其是偏置补偿型运算放大器，如OP-07及其很多后继产品)都内置保护电路，以防止大电压损坏输入器件。
其它运算放大器则内置更复杂的输入电路，在施加的差分电压小于几十毫伏时只具有高阻抗，或者在差分电压大于几十伏时可能会损坏。因此，将运算放大器用作比较器时，如果施加大差分电压，必须仔细研究数据手册，才能确定输入电路的工作方式。(采用集成电路时，务必研究数据手册，确保其非理想特性(每个集成电路都存在一些非理想特性)兼容推荐的应用——本文中这点尤为重要。)图5所示为内置防止大差分电压输入二极管的运算放大器。
图5：具有保护功能的运算放大器输入结构
当然，有一些比较器应用不存在大差分电压，即使存在，比较器输入阻抗相对而言也不太重要。这种情况适合将运算放大器用作比较器，其输入电路表现为非线性，但是涉及的问题必须考虑，不能忽视。
对BIFET运算放大器而言，如果其输入接近其中一个电源(通常为负电源)，几乎都会表现异常。其反相和同相输入可以互换。如果运算放大器用作比较器时发生这种情况，涉及的系统相位将会反转，造成极大不便。要解决这一问题，还是必须仔细阅读数据手册，确定合适的共模范围。
而且，没有负反馈意味着与运算放大器电路不同，输入阻抗不必乘以开环增益。因此，输入电流会随着比较器开关而变化。因此，驱动阻抗和寄生反馈对影响电路稳定性起着重要作用。负反馈往往会使放大器保持在线性区域内，正反馈则会使其饱和。
最后的建议
运算放大器设计的目的不是用作比较器，因此，不太建议这种做法。尽管如此，在某些应用中，将运算放大器用作比较器却是正确的设计决策，关键是要慎重考虑后再做出决策，并确保所选运算放大器能达到预期的性能。因此，必须仔细阅读数据手册，认真考虑非理想运算放大器性能的影响，并计算出运算放大器参数对应用的影响。由于运算放大器以非标准方式使用，可能还必须进行某些实验——实验所用的放大器不一定具有典型性，因此，解读实验结果时不宜过于乐观。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4145a6d11b6d50938d3475aa084512aa/" rel="bookmark">
			Linux下p4 拉取卡顿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 p4 IP和端口号
命令：p4 info
二、查看linux 电脑信息
1、 linux下 netstat 查看 所有相关线程状态
2、netstat -apn|grep 1666
其中1666 为端口号
可以看到当前p4 端口号下的线程状态。
3、top -h 查看当前CPU 情况，包括内存情况。
4、free -h 可以看Mem 内存的情况。
三、清理电脑缓存。
清理之前：
清理后：
清理命令：
echo 3 &gt; /proc/sys/vm/drop_caches 四、清理删掉某个或多个版本
命令行是
p4 obliterate -y //depot/file#1,#2000 记录下，以备后用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8816bc5fd2c66f6f05e8bf21718249b3/" rel="bookmark">
			Java策略模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		策略模式是一种行为型设计模式，它允许在运行时动态地改变对象的行为。在Java中，策略模式通常由一个接口和多个实现该接口的类组成。
下面是一个简单的例子，假设有一个计算器类，它可以执行加、减、乘、除四种操作。我们可以使用策略模式来实现这个计算器类，使得它可以在运行时动态地改变操作。
首先，我们定义一个接口`Operation`，它包含一个`calculate`方法，用于执行具体的操作：
public interface Operation {
double calculate(double num1, double num2);
}
然后，我们实现四个具体的操作类，分别是加、减、乘、除：
public class AddOperation implements Operation {
@Override
public double calculate(double num1, double num2) {
return num1 + num2;
}
}
public class SubOperation implements Operation {
@Override
public double calculate(double num1, double num2) {
return num1 - num2;
}
}
public class MulOperation implements Operation {
@Override
public double calculate(double num1, double num2) {
return num1 * num2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8816bc5fd2c66f6f05e8bf21718249b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0200732ff767bb3f06de5506da0fad83/" rel="bookmark">
			图像处理实战02-yolov5目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov5 YOLOv5 是一种目标检测算法，它是 YOLO (You Only Look Once) 系列算法的最新版本。YOLOv5 采用了一种新的架构，它包括一个基于 CSPNet (Cross Stage Partial Network) 的主干网络以及一系列改进的技巧，如多尺度训练、数据增强、网络混合精度训练等，从而实现了更快的检测速度和更好的检测精度。
YOLOv5 支持多种类型的目标检测任务，如物体检测、人脸检测、车辆检测等，可以应用于各种实际场景，如智能安防、自动驾驶、机器人视觉等。同时，YOLOv5 还提供了预训练的模型和开源代码，方便开发者进行模型的训练和应用。
github地址：https://github.com/ultralytics/yolov5/blob/master/README.zh-CN.md
官网：https://ultralytics.com/
发展历程 YOLO（You Only Look Once）是一系列的目标检测模型，由Joseph Redmon等人开发。以下是YOLO系列的发展历程：
YOLOv1：于2015年首次提出，是YOLO系列的第一个版本。YOLOv1通过将目标检测任务转化为回归问题，将图像划分为网格并预测每个网格的边界框和类别概率。然而，YOLOv1存在定位不准确和对小目标敏感的问题。
YOLOv2（YOLO9000）：于2016年提出，是YOLO系列的第二个版本。YOLOv2通过引入Darknet-19网络结构、使用anchor boxes和多尺度预测来改进检测性能。同时，YOLOv2还引入了目标类别的语义分割，可以检测更多类别的目标。
YOLOv3：于2018年提出，是YOLO系列的第三个版本。YOLOv3针对YOLOv2存在的问题进行了改进，引入了多尺度预测、使用FPN结构和使用更小的anchor boxes等技术，提高了检测精度和对小目标的检测能力。
YOLOv4：于2020年提出，是YOLO系列的第四个版本。YOLOv4在YOLOv3的基础上引入了一系列改进，包括CSPDarknet53作为主干网络、使用SAM和PANet模块来提取特征、使用YOLOv3和YOLOv4的预训练权重进行初始化等，提高了检测性能和速度。
YOLOv5：于2020年提出，是YOLO系列的第五个版本。YOLOv5采用了轻量化的网络结构，提高了检测的速度，并引入了一些新功能，如YOLOv5-seg分割模型、Paddle Paddle导出功能、YOLOv5 AutoCache自动缓存功能和Comet日志记录和可视化集成功能。
总体而言，YOLO系列模型通过不断的改进和优化，提高了目标检测的性能和速度，并在计算机视觉领域取得了重要的突破。
yolov8 YOLOv8是YOLO系列模型的一个变种，它在YOLOv5的基础上进行了改进和优化。YOLOv8模型包含了检测（Detect）、分割（Segment）和姿态估计（Pose）、跟踪（Track）以及分类（Classify）等功能。下面是对这些功能的简要说明：
检测（Detect）：YOLOv8模型能够对图像或视频中的目标进行实时的物体检测。它通过预测目标的边界框和类别信息来完成检测任务。
分割（Segment）：YOLOv8模型还支持目标分割的功能，即将图像中的每个像素进行分类，将不同的目标区域进行分割。这个功能可以用于识别图像中的不同物体，并进行更精确的定位和分析。
姿态估计（Pose）：YOLOv8模型还可以对检测到的目标进行姿态估计，即推断目标在三维空间中的姿态信息。这对于一些需要了解目标的方向和位置的应用非常有用，比如人体姿态分析、机器人导航等。
跟踪（Track）：YOLOv8模型还具有目标跟踪的功能，即在视频中连续追踪相同目标的位置和轨迹。这对于视频监控、自动驾驶等应用非常重要。
分类（Classify）：除了目标检测和分割功能之外，YOLOv8模型还可以对检测到的目标进行分类，即给出目标的类别信息。这对于了解目标的属性和进行更细粒度的分析非常重要。
总而言之，YOLOv8模型综合了多种功能，包括检测、分割、姿态估计、跟踪和分类等，使其具备了更广泛的应用领域和更强大的功能。
github地址：https://github.com/ultralytics/ultralytics
v5入门示例 安装 克隆 repo，并要求在 Python&gt;=3.7.0 环境中安装 requirements.txt ，且要求 PyTorch&gt;=1.7 。
micromamba create prefix=d:/python380 python=3.8 #创建3.8的虚拟环境 micromamba activate d:/python380 git clone https://github.com/ultralytics/yolov5 # clone cd yolov5 pip install -r requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0200732ff767bb3f06de5506da0fad83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1caf30fde32bc6d40226372fe09f7e/" rel="bookmark">
			Flink SQL之Interval Joins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Interval Joins（区间Join） 区间是双流join的优化，基于处理时间或事件时间，在一定时间区间内数据，相同的key进行join（支持 Batch\Streaming）。Interval Join 可以让一条流去 Join 另一条流中前后一段时间内的数据。
对于stream查询，时间区间join只支持有时间属性的 append-only表。由于时间属性是准单调递增的，Flink可以从其状态中删除旧值，而不会影响结果的正确性。
优点：由于给定了关联的区间，因此只需要保留很少的状态，内存压力较小。
缺点：如果关联的数据晚到或者早到，导致落不到 JOIN 区间内，就可能导致结果不准确。只支持普通 Append 数据流，不支持含 Retract 的动态表。支持事件时间和处理时间 区间join支持基本特征如下：
支持INNER、LEFT、RIGHT、FULL OUT JOIN语义语法和传统sql join一致左右流都会触发更新state根据时间区间保留，自动清理输出流保留时间属性 2.语法 语法和sql join一致。
SELECT * FROM Orders [INNER|RIGHT|LEFT|FULL OUTER] JOIN Product ON Orders.productId = Product.id 区别在于join连接条件，有效的join连接条件如下：
ltime = rtimeltime &gt;= rtime AND ltime &lt; rtime + INTERVAL '10' MINUTEltime BETWEEN rtime - INTERVAL '10' SECOND AND rtime + INTERVAL '5' SECOND 3.Interval Join实例 如果订单在收到订单10小时后发货，则此查询将把所有订单与其相应的发货联系起来
# 两表有时间戳字段，并且作为 watermark。或者使用PROCTIME() 函数来生成一个处理时间戳 SELECT * FROM Orders o, Shipments s WHERE o.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1caf30fde32bc6d40226372fe09f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fbc9e48611142b139c8e769f3234d2/" rel="bookmark">
			MMSegmentation系列之训练与推理自己的数据集（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、准备数据目录结构 mstsc VOCdevkit
│ │ ├── VOC2012
│ │ │ ├── JPEGImages（原始影像）
│ │ │ ├── SegmentationClass（掩膜影像）
│ │ │ ├── ImageSets
│ │ │ │ ├── Segmentation（数据划分）
2、下载预训练模型 model的预训练模型
deeplabv3plus
3、修改配置文件（deeplabv3plus_r50-d8_512x512_40k_voc12aug.py） 1、 设置修改类别数​(模型架构配置文件deeplabv3plus_r50-d8_512x512_40k_voc12aug.py) _base_ = [ '../_base_/models/deeplabv3plus_r50-d8.py', '../_base_/datasets/pascal_voc12_aug.py', '../_base_/default_runtime.py', '../_base_/schedules/schedule_40k.py' ] model = dict( decode_head=dict(num_classes=21), auxiliary_head=dict(num_classes=21))#按照自己的数据进行修改 2、修改数据信息（数据类型、数据主路径等和batch-size）（…/base/datasets/pascal_voc12_aug.py、pascal_voc12.py） # dataset settings dataset_type = 'PascalVOCDataset' #按照需要修改数据类型 data_root = 'data/VOCdevkit/VOC2012' #按照需要修改数据主路径 img_norm_cfg = dict( mean=[123.675, 116.28, 103.53], std=[58.395, 57.12, 57.375], to_rgb=True) crop_size = (512, 512) train_pipeline = [ dict(type='LoadImageFromFile'), dict(type='LoadAnnotations'), dict(type='Resize', img_scale=(2048, 512), ratio_range=(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46fbc9e48611142b139c8e769f3234d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9573e12ab05edd071722cf162ff577/" rel="bookmark">
			（二）一文带你了解KITTI数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（二）一文带你了解KITTI数据集 KITTI官网网址：https://www.cvlibs.net/datasets/kitti/index.php
KITTI数据集论文：Are we ready for Autonomous Driving? The KITTI Vision Benchmark Suite
KITTI3D AP Metric：Disentangling Monocular 3D Object Detection
第一章：KITTI数据集介绍 1.1 KITTI数据集简介 KITTI数据集是由德国卡尔斯鲁厄理工学院 Karlsruhe Institute of Technology (KIT) 和美国芝加哥丰田技术研究院 Toyota Technological Institute at Chicago (TTI-C) 于2012年联合创办，是目前国际上最为常用的自动驾驶场景下的计算机视觉算法评测数据集之一。该数据集用于评测立体图像(stereo)，光流(optical flow)，视觉测距(visual odometry)，3D物体检测(object detection)和3D跟踪(tracking)等计算机视觉技术在车载环境下的性能。KITTI数据集包含市区、乡村和高速公路等场景采集的真实图像数据，每张图像中最多达15辆车和30个行人，还有各种程度的遮挡与截断。 KITTI数据集针对3D目标检测任务提供了14999张图像以及对应的点云，其中7481组用于训练，7518组用于测试，针对场景中的汽车、行人、自行车三类物体进行标注，共计80256个标记对象。
1.2 KITTI数据集采集车 KITTI数据集采集车的传感器布置平面如上图所示，车辆装配有2个灰度摄像机，2个彩色摄像机，一个Velodyne 64线3D激光雷达，4个光学镜头，以及1个GPS导航系统，在上图中使用了红色标记。
2个一百四十万像素的PointGray Flea2灰度相机2个一百四十万像素的PointGray Flea2彩色相机1个64线的Velodyne激光雷达，10Hz，角分辨率为0.09度，每秒约一百三十万个点，水平视场360°，垂直视场26.8°，至多120米的距离范围4个Edmund的光学镜片，水平视角约为90°，垂直视角约为35°1个OXTS RT 3003的惯性导航系统（GPS/IMU），6轴，100Hz，分别率为0.02米，0.1° 注意：双目相机之间的距离为0.54米，点云到相机之间的距离为0.27米，在上图中使用了蓝色标记。
1.3 KITTI数据集坐标系表示 图中蓝色的坐标系表示激光点云的坐标系，红色的坐标系表示相机的坐标系。
第二章：准备KITTI数据集 2.1 官网下载KITTI数据集 在KITTI 3D object detection dataset下载KITTI数据集安装包。
当然，如果在官网下载麻烦的话，我已经下载好了，使用百度网盘可以直接进行下载。
百度网盘链接：https://pan.baidu.com/s/1K-UaIFUt_bibjC6ZtLUKYA
提取码：7jq1
道路平面信息是由 AVOD 生成的，其在训练过程中作为一个可选项，用来提高模型的性能，点击下载道路平面信息。
2.2 官网下载KITTI数据集后的组织结构 在官网下载KITTI数据集后，并在mmdetection3d文件夹下组织成以下所示的结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9573e12ab05edd071722cf162ff577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a92006a4cf2851d3d6e1de628ec37d/" rel="bookmark">
			python语音识别whisper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 最近想提取一些视频的字幕，语音文案，研究了一波
二、whisper语音识别 Whisper 是一种通用的语音识别模型。它在不同音频的大型数据集上进行训练，也是一个多任务模型，可以执行多语言语音识别以及语音翻译和语言识别。
stable-ts在 OpenAI 的 Whisper 之上修改并添加了更大的破解代码发布，生成更准确的阶段时间切换，并在无须额外推介的情况下获得申领
安装pip install openai-whisper pip install stable-ts SizeParametersEnglish-only modelMultilingual modelRequired VRAMRelative speedtiny39 Mtiny.entiny~1 GB~32xbase74 Mbase.enbase~1 GB~16xsmall244 Msmall.ensmall~2 GB~6xmedium769 Mmedium.enmedium~5 GB~2xlarge1550 MN/Alarge~10 GB1x 三、示例 模型越大，越精确，相应话费的时间越长
自带语言识别功能，language最好加上，下面歌曲识别为英语，加后为中文
stable_whisper 是 whisper 进化版 即 python的这个包stable-ts
import whisper import stable_whisper as whisper class WhisperTranscriber(object): def __init__(self, model_name): self.model = whisper.load_model(model_name) def whisper_transcribe(self, audio_path): audio = self.model.transcribe(audio_path, fp16=False, language='Chinese') return audio['text'] if __name__ == '__main__': transcriber = WhisperTranscriber("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a92006a4cf2851d3d6e1de628ec37d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7edd0cce4a6524f1803c8a4d0043f7/" rel="bookmark">
			docker容器 - 卷（volume）- 挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
参考文档：Volumes | Docker Documentation
什么是卷（volume）？
什么是挂载，它的作用是什么？
一台机器里的多个容器之间共享数据（使用挂载）
首先我们可以使用最简单的docker cp命令复制文件给容器，来实现跟挂载相似的功能
docker容器挂载文件的命令
docker容器挂载卷（volume）的命令
多台机器之间共享数据（NFS挂载的使用）
可查看参考文档：(45条消息) 搭建NFS服务器_Claylpf的博客-CSDN博客
然后可以直接使用docker容器的卷直接挂载nfs服务器
参考文档：Volumes | Docker Documentation 什么是卷（volume）？ 在容器化应用程序开发和部署过程中，卷（Volume）是一个非常常见的概念，它可以将主机文件系统或其他容器的文件系统挂载到容器内部的特定路径上，从而为容器提供额外的持久化存储。因此，容器里卷起到的作用主要有以下几个方面：
持久化存储：容器中的文件系统是短暂且易变的，当容器被删除后，容器内数据也会随之消失。而通过使用卷，可以将需要持久化的数据存储在卷中，从而保证数据的持久化。
数据共享：容器化应用程序通常由多个容器组成，这些容器需要分享数据或配置信息。通过使用卷，不同的容器之间可以共享相同的卷，从而实现数据共享。
数据备份：通过使用卷，可以将数据备份到独立的存储设备中，例如网络附加存储（NAS）或云存储等。这有助于防止数据丢失、数据损坏或其他故障，提高了数据的可靠性。
总的来说，卷是容器化应用程序中提供持久化存储和数据共享的关键组件之一，可以提高应用程序的稳定性和可靠性，同时也有助于简化应用程序的开发和管理。
我们可以通过docker inspect查看每个容器对应的卷（volume）（mysq会自带卷，nginx不会，需要我们挂载卷） [root@mysql _data]# docker inspect sc-mysql-1 | egrep "volume" #查找sc-mysql-1容器里对应的vloume卷 "Type": "volume", "Source": "/var/lib/docker/volumes/6167418cb7d0a3dfacef4439f410e1860c088d297cf47aeceaf88d3e56528219/_data", [root@mysql _data]# 什么是挂载，它的作用是什么？ 在计算机中，挂载（Mount）通常指将一个文件系统（如硬盘分区、光盘或NFS共享）连接到另一个系统的目录树上，使得该文件系统中的文件和目录可以被访问。具体来说，挂载可以将文件系统加入到Linux中的虚拟文件系统树中，使得用户可以使用标准的文件操作命令（如ls、cp、mv等）来访问文件系统中的数据。
在实际应用中，挂载的作用有以下几个方面：
扩展文件系统：通过将新的文件系统挂载到现有的目录中，可以扩展现有文件系统的容量。
访问远程文件系统：通过挂载远程文件系统，例如NFS、CIFS/SMB文件共享，可以在本地计算机上访问位于远程计算机上的文件。
分离文件系统：通过挂载和卸载文件系统，可以将不同的文件系统隔离开来，以便于管理和维护，也可以帮助隔离不同的应用程序或用户之间的文件系统。
简化文件管理：通过挂载，可以将不同的文件系统组织成一个逻辑文件树，并可以使用标准文件操作命令来访问其中的所有文件和目录，简化了文件管理操作。
总的来说，挂载是计算机中一个非常常见的操作，它可以将不同的文件系统组织成一个逻辑文件树，并将它们与应用程序所使用的目录进行连接，扩展了文件系统的存储能力，并且使得用户可以通过统一的界面来管理和访问文件系统中的数据。
一台机器里的多个容器之间共享数据（使用挂载） 首先我们可以使用最简单的docker cp命令复制文件给容器，来实现跟挂载相似的功能 [root@mysql html]# cat index.html #创建html文件 welcome to sc web!!! [root@mysql html]# [root@mysql html]# docker cp /html/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec7edd0cce4a6524f1803c8a4d0043f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50ee8b9b456df27e47126d7da25dff8/" rel="bookmark">
			WebSocket之socket.io的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Socket.IO 是一个WebSocket库，可以在客户端和服务器之间实现低延迟、双向和基于事件的通信。它建立在 WebSocket 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。
基本使用 安装socket.io
yarn add socket.io
新建js文件与html文件内容如下
var http = require('http'); var io = require('socket.io'); var server = http.createServer((req,res)=&gt;{ }); server.listen(2183); // 监听 connection io.listen(server).on('connection',(user)=&gt;{ setInterval(()=&gt;{ user.emit('test','哥们我主动来了'+Math.random()); },1000); }); &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; // 引用脚本，固定写法 &lt;script type="text/javascript" src='http://localhost:2183/socket.io/socket.io.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 连接服务 let connection = io.connect('ws://localhost:2183'); connection.on('test',(str)=&gt;{ console.log(str) }) &lt;/script&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 这个时候启动node后，浏览器打开html可以看到服务器推送的信息：
现在来看一下上面代码，
on('connection',(user)=&gt;{
setInterval(()=&gt;{
user.emit('test','哥们我主动来了'+Math.random());
},1000);
})
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50ee8b9b456df27e47126d7da25dff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f3a52811b1039135832f79bd0d8b48/" rel="bookmark">
			Vue中如何进行颜色选择与调色板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中如何进行颜色选择与调色板 颜色选择和调色板是Web开发中常用的功能，它们可以帮助用户选择或调整颜色。Vue作为一个流行的JavaScript框架，提供了一些工具和库，可以方便地实现颜色选择和调色板功能。本文将介绍如何在Vue中进行颜色选择和调色板。
颜色选择 颜色选择是指用户从一组颜色中选择一个颜色的过程。在Vue中进行颜色选择可以使用以下两种方法：
1. 使用Vue的v-model指令 Vue的v-model指令可以将表单元素和Vue实例的数据绑定起来，从而实现双向数据绑定。在颜色选择中，我们可以使用v-model指令将颜色选择器和Vue实例的数据绑定起来。下面是一个使用v-model指令进行颜色选择的示例代码：
&lt;template&gt; &lt;div&gt; &lt;input type="color" v-model="color"&gt; &lt;p&gt;你选择的颜色是：{{ color }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { color: '#000000' } } } &lt;/script&gt; 在上面的代码中，我们使用了input[type=color]元素作为颜色选择器，并使用v-model指令将其与color数据进行双向绑定。当用户选择颜色时，color数据将会自动更新，并在页面上显示出来。
2. 使用vue-color库 vue-color是一个用于颜色选择的Vue组件库，它提供了多种颜色选择器和调色板，可以轻松地集成到Vue应用中。下面是一个使用vue-color库进行颜色选择的示例代码：
&lt;template&gt; &lt;div&gt; &lt;sketch-picker v-model="color" /&gt; &lt;p&gt;你选择的颜色是：{{ color }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { SketchPicker } from 'vue-color'; export default { components: { SketchPicker }, data() { return { color: { r: 0, g: 0, b: 0, a: 1 } } } } &lt;/script&gt; 在上面的代码中，我们使用了vue-color库中的SketchPicker组件作为颜色选择器，使用v-model指令将其与color数据进行双向绑定。当用户选择颜色时，color数据将会自动更新，并在页面上显示出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f3a52811b1039135832f79bd0d8b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd0050d5c294d403af60d655d0f591c/" rel="bookmark">
			Linux操作系统学习——启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 Linux操作系统内核是服务端学习的根基，也是提高编程能力、源码阅读能力和进阶知识学习能力的重要部分，本文开始将记录Linux操作系统中的各个部分源码学习历程。
1. 理解代码的组织结构 以Linux源码举例，首先你得知道操作系统分为哪几个部分，他们单独做了什么功能，如何进行配合完成更为具体的功能。建立整体的印象有助于后续深入学习的时候方便理解，毕竟代码是用的不是看的，理解他的作用有利于理解为什么要这么做。
2. 深入各个模块学习 模块接口：这里推荐微软的画图工具visio或者思维导图xmind，用其画图可以将各个模块的接口列出，并绘制各个模块之间的关系，通过了解接口可以清楚各个模块之间的关系，即绘制模块组织图
工作流程：通过上面一步得到各模块间的关系，然后实际用断点或log等方式看一看整体的工作流程，在模块组织图的基础上绘制程序流程图
模块粘合层：我们的代码有很多都是用来粘合代码的，比如中间件（middleware）、Promises 模式、回调（Callback）、代理委托、依赖注入等。这些代码模块间的粘合技术是非常重要的，因为它们会把本来平铺直述的代码给分裂开来，让你不容易看明白它们的关系。这些可以作为程序流程图的补充，让其中本来无法顺畅衔接的地方变得通畅无阻。
模块具体实现 ：这是最难得地方，涉及到大量具体源码的学习。深入细节容易迷失在细节的海洋里，因此需要有一些重点去关注，将非重点的内容省略。通过学习绘制模块具体架构图和模块的算法时序图，可以帮助你更好的掌握源码的精髓。
3. 需要关注的包括 代码逻辑。代码有两种逻辑，一种是业务逻辑，这种逻辑是真正的业务处理逻辑；另一种是控制逻辑，这种逻辑只是用控制程序流转的，不是业务逻辑。比如：flag 之类的控制变量，多线程处理的代码，异步控制的代码，远程通讯的代码，对象序列化反序列化的代码等。这两种逻辑你要分开，很多代码之所以混乱就是把这两种逻辑混在一起了。
重要的算法。一般来说，我们的代码里会有很多重要的算法，我说的并不一定是什么排序或是搜索算法，可能会是一些其它的核心算法，比如一些索引表的算法，全局唯一 ID 的算法、信息推荐的算法、统计算法、通读算法（如 Gossip）等。这些比较核心的算法可能会非常难读，但它们往往是最有技术含量的部分。
底层交互。有一些代码是和底层系统的交互，一般来说是和操作系统或是 JVM 的交互。因此，读这些代码通常需要一定的底层技术知识，不然，很难读懂。
4. 可以忽略的包括 出错处理。根据二八原则，20% 的代码是正常的逻辑，80% 的代码是在处理各种错误，所以，你在读代码的时候，完全可以把处理错误的代码全部删除掉，这样就会留下比较干净和简单的正常逻辑的代码。排除干扰因素，可以更高效地读代码。
数据处理。只要你认真观察，就会发现，我们好多代码就是在那里倒腾数据。比如 DAO、DTO，比如 JSON、XML，这些代码冗长无聊，不是主要逻辑，可以不理。
忽略过多的实现细节。在第一遍阅读源码时，已弄懂整体流程为主，至于具体的实现细节先简单的理清处过一遍，不用过于纠结。当梳理清楚全部的框架逻辑后，第二遍再深入的学习研究各个模块的实现，此时应该解决第一遍中的疑惑。第三遍可以跳出代码的实现，来看Linux的设计思路、编程艺术和演进之路。
重在实践。Linux的代码都是可以调试的，看很多遍也许不如跟着调试走一遍，然后再自己修改修改做一些小测试。
传授知识。当你能将知识讲述给别人听，并让别人听懂时，你已经可以自豪的说洞悉了这些知识。所以不妨从一个小的例子开始自说自话，看能不能自圆其说，甚至写成博客、做成PPT给大家讲解。
说了一大堆的废话，下面就正式开始操作系统的深入学习记录之旅了。
5. 混沌初开 本文分析从按下电源键到加载BIOS以及后续bootloader的整个过程。犹如盘古开天辟地一般，该过程将混沌的操作系统世界分为清晰的内核态和用户态，并经历从实模式到保护模式的变化。这里先简单介绍一下名词，便于后续理解。
实模式（Real Mode)：又名 Real Address Mode，在此模式下地址访问的是真实地内存地址所在位置。在此模式下，可以使用20位（1MB）的地址空间，软件可以不受限制的操作所有地址的空间和IO设备。
保护模式（Protected Mode)：又名 Protected Virtual Address Mode，采用虚拟内存、页等机制对内存进行了保护，比起实模式更为安全可靠，同时也增加了灵活性和扩展性。
5.1 从启动电源到BIOS 当我们按下电源键，主板会发向电源组发出信号，接收到信号后，电源会提供合适的电压给计算机。当主板收到电源正常启动的信号后，主板会启动CPU。CPU重置所有寄存器数据，并设置初始化数据，这个初始化数据在X86架构里如下所示：
1IP 0xfff0 2CS selector 0xf000 3CS base 0xffff0000 4IP/EIP (Instruction Pointer) : 指令指针寄存器，记录将要执行的指令在代码段内的偏移地址 5CS（Code Segment Register）：代码段寄存器，指向CPU当前执行代码在内存中的区域（定义了存放代码的存储器的起始地址） 实模式采取内存段来管理 0 - 0xFFFFF的这1M内存空间，但是由于只有16位寄存器，所以最大地址只能表示为0xFFFFF（64KB)，因此不得不采取将内存按段划分为64KB的方式来充分利用1M空间。也就是上所示的，采取段选择子 + 偏移量的表示法。这种方法在保护模式中对于页的设计上也沿用了下来，可谓祖传的智慧了。具体的计算公式如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd0050d5c294d403af60d655d0f591c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1530a35575c4e05456c5e85aa7c3ff1/" rel="bookmark">
			C#11新特性学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
支持Json字符串
保留空格
支持内插字符
泛型属性
UTF-8 字符串字面量
列表模式
支持Json字符串 static void Main(string[] args) { // 无需转义符 处理 json 字符串 var json = """ { "name": "Andy", "age": 18 } """; Console.WriteLine(json); Console.ReadLine(); } 还支持 html 和 xml 原始字符串的使用，无需转义符
static void Main(string[] args) { // 无需转义符 处理 html 字符串 var json = """ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;p&gt;我是段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; """; Console.WriteLine(json); Console.ReadLine(); } 保留空格 C# 11 保留原始字符串的空格及其位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1530a35575c4e05456c5e85aa7c3ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d94e43b29efe8da559aa21182b978a/" rel="bookmark">
			将打开的网页批量保存为PDF（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省力，但不多，需要安装python模块bs4和工具wkhtmltopdf
1. 在cmd运行以下命令安装bs4
pip install bs4 -i https://pypi.tuna.tsinghua.edu.cn/simple 2. 安装工具wkhtmltopdf，并将安装目录下的bin目录添加到环境变量
下载地址：https://wkhtmltopdf.org/downloads.html
文件管理器-此电脑右键属性-高级系统设置-环境变量-系统变量-变量path
3. 右键浏览器标签栏，将打开的网页全部保存到收藏夹然后导出
4. 编辑导出的html文件，只保留需要的链接
5. 将html文件和pdf.py放到同一个目录下，并在当前目录新建文件夹命名为pdf，注意更换代码中的html文件名（bookmarks.html）
# pdf.py from bs4 import BeautifulSoup import re import subprocess # 将html文件中链接的url和标题提取出来分别保存在urls.txt和titles.txt文件中，注意更换html文件名（bookmarks.html） # 读取 HTML 文件内容 with open('bookmarks.html', 'r', encoding='utf-8') as f: html_str = f.read() # 解析 HTML 字符串 soup = BeautifulSoup(html_str, 'html.parser') # 获取所有的链接列表 links = soup.find_all('a') # 将链接 URL 和标题保存到文件中 with open('urls.txt', 'w', encoding='utf-8') as f1, open('titles.txt', 'w', encoding='utf-8') as f2: for link in links: url = link.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9d94e43b29efe8da559aa21182b978a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f634642fa1c30db386f1248174417ac6/" rel="bookmark">
			【linux】在Ubuntu下部署nginx——nginx的反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
这里是小编成长之路的历程，也是小编的学习之路。希望和各位大佬们一起成长！
以下为小编最喜欢的两句话：
要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，山高水远，路远马亡。
一个人为什么要努力？ 我见过最好的答案就是：因为我喜欢的东西都很贵，我想去的地方都很远，我爱的人超完美。因此，小编想说：共勉！
本篇文章是小编记录Linux的系统学习
目录
一、什么是代理服务器
二、正向代理
1、什么是正向代理
2、正向代理的作用
三、反向代理
1、什么是反向代理
2、反向代理的作用
注意：
四、Nginx的配置
1、配置文件包含的六个部分：
2、大概解释一下各个模块的代码意思：
1）main模块
2）event 模块
3）http模块
4）server模块
5）location模块
3、uwsgi配置
6）upstream模块
五、反向代理的操作步骤
第一步：修改配置文件
第二步：将上图红框位置改为要代理的地址
第三步：让配置文件生效
第四步：IP地址加端口号访问（ip+port）
一、什么是代理服务器 代理服务器（Proxy Server），也称代理或代理器，是一种充当客户端与上游服务器之间的中间层服务器，用于转发客户端请求的服务器。
代理服务器的作用是扮演中间人的角色，隐藏客户端的真实 IP 地址，同时对客户端的请求进行代理，使得客户端能够通过代理服务器访问 Internet 上的资源，提高了访问的安全性、可靠性和速度。
代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。
二、正向代理 1、什么是正向代理 正向代理（Forward Proxy），是指代理服务器代理客户端的请求，从而使客户端无法直接访问所需资源。简而言之，正向代理是代表客户端进行访问的中间层服务器，可以控制客户端的访问行为，隐藏客户端的真实 IP 地址和身份。
正向代理类似一个跳板机，代理访问外部资源。比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了
2、正向代理的作用 （1）访问原来无法访问的资源，如google (翻墙)
（2）可以做缓存，加速访问资源
（3）对客户端访问授权，上网进行认证
（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息
三、反向代理 1、什么是反向代理 反向代理（Reverse Proxy），是指代理服务器代理服务端的请求和响应，从而使服务端无法直接被客户端访问到。简而言之，反向代理是代表服务端进行访问的中间层服务器，可以控制服务端的访问行为，隐藏服务端的真实 IP 地址和身份。
反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。
客户端不需要任何配置就能访问，只需要将请求发送到 反向代理服务器，由反向代理服务器去选择目标服务器 ，获取数据后再返回给客户端。对外就一个服务器，暴露的是反向代理服务器地址，隐藏了真实服务器IP地址。代理对象是服务端，不知道客户端是谁。
2、反向代理的作用 （1）防止攻击：保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网
（2）负载均衡：可以将客户端的请求分配给多台服务端，从而均衡服务端的负载，提高系统的可用性和性能（通过反向代理服务器来优化网站的负载，提高网站的可用性和性能）
（3）访问控制：可以根据访问者的身份和权限对资源进行权限控制，防止资源被未授权的用户访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f634642fa1c30db386f1248174417ac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4529d33f30b280e41c8e57f1cba54fb7/" rel="bookmark">
			Java中Thread类的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、创建线程的方式
1、继承Thread类
2、实现Runnable接口
3、匿名内部类中创建Thread子类对象
4、匿名内部类中创建Runnable子类对象
5、lambda表达式创建Runnabl子类对象
二、Thread的常见构造方法
三、启动一个线程
四、获取当前线程 五、等待一个线程
六、休眠当前线程
七、中断当前线程
线程中断的方法：
一、创建线程的方式 1、继承Thread类 创建一个自定义的线程类并继承标准库中的Thread类：
class MyThread extends Thread{ @Override //重写父类的run方法 public void run() { System.out.println("这是继承Thread类创建的线程"); } } public class Thread1 { public static void main(String[] args) { //创建实例 MyThread thread = new MyThread(); //调用start方法后才会在系统上创建一个线程 thread.start(); } } 其中，重写父类的run()方法是给MyThread类创建的线程安排任务，main()方法中创建一个MyThread实例后，调用父类的start()方法，新创建的线程就会执行子类的run()方法中的逻辑(此处发生了动态绑定)。
代码运行结果：
2、实现Runnable接口 class MyThread2 implements Runnable{ @Override public void run() { System.out.println("这是实现Runnable接口创建的线程"); } } public class Thread2 { public static void main(String[] args) { Runnable runnable = new MyThread2(); //需要将Runnable实例作为Thread构造方法的参数 Thread thread = new Thread(runnable); thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4529d33f30b280e41c8e57f1cba54fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9488acc4a19e5299b494b0abc71d5898/" rel="bookmark">
			干掉复杂的工具类，Hutool 工具库确实香
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hutool 大家已经比较熟悉了，这是一个超全的 Java 工具库，深受国内开发者的喜爱。
我之前其实是不太喜欢使用这种功能太多的工具类的，也比较担心稳定性和安全性，后面慢慢接受了就感觉其实也还好。而且，我们还可以按需只引入自己需要的功能模块，相对也比较灵活。
Hutool 的官方文档介绍的已经比较清晰了，奈何其提供的功能实在太多，我这里列举一些我个人觉得比较实用的功能，供大家学习参考。
Hutool 介绍 Hutool 真心是一个不错的国产 Java 工具类库，功能全面，对文件、流、加密解密、转码、正则、线程、XML 等 JDK 方法进行了封装，开箱即用！
官方是这样介绍 Hutool 的：
Hutool 介绍
Hutool 包含的组件以及组件提供的功能如下表所示：
Hutool 包含的组件
你可以根据项目需求对每个模块单独引入，也可以通过引入hutool-all方式引入所有模块。不过，还是不建议引入所有模块，因为绝大部分功能项目可能都用不上，建议只引入你需要的模块。
另外，Hutool 也有一个比较明显的缺点，很多功能实现的比较简单比如图片验证码、Excel 工具类，很可能无法满足项目的实际需求。像这样情况，还是建议你选择在某一方面更优秀的工具库比如 Excel 工具库 MyExcel、EasyExcel、图片处理库 Imglib。
Hutool 实战 引入依赖 Maven 仓库地址：https://mvnrepository.com/artifact/cn.hutool 。
这里为了方便，我们直接引入所有模块，实际项目中还是建议只引入自己需要的模块。
Maven：
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.16&lt;/version&gt; &lt;/dependency&gt; Gradle：
implementation 'cn.hutool:hutool-all:5.8.16' 功能演示 Hutool 提供的功能实在太多，这里只列举一些我个人觉得比较实用的功能，供大家学习参考。
类型转换
Convert 类封装了针对 Java 常见类型的转换。
long[] b = {1,2,3,4,5}; String bStr = Convert.toStr(b);//"[1, 2, 3, 4, 5]" double a = 67556.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9488acc4a19e5299b494b0abc71d5898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9face04866164dc9d325c302823a6e3/" rel="bookmark">
			基于MATLAB的车牌识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
车牌识别系统的介绍与展示 车牌定位
1.灰度处理
2.边缘检测 车牌分割
1.图像腐蚀
2.图像平滑
3.移除对象
4.图像切割
车牌识别
1.灰度处理
2.直方图均衡化
3.二值化
4.中值滤波
5.字符识别
车牌识别系统的介绍与展示 车牌识别技术的推广普及对加强道路管理、城市交通事故、违章停车、处理车辆被盗案件、保障社会稳定等方面有非常重大的影响。恰逢今年学习了《数字图像处理》课程，利用一些数字图像处理的知识并借鉴网络上诸多算法开发了一个车牌识别系统，并且借用MATLAB的APP designer平台搭建了一个车牌识别的app。（此app目前对一部分图片可以准确识别，但是其他图片效果一般，正在持续改进中......如有进展，后续会进行更新）
一个完整的车牌号识别系统要完成从图像采集到字符识别输出，过程相当复杂，基本可以分成硬件部分和软件部分，硬件部分包括系统触发、图像采集，软件部分一般包括车牌定位、车牌分割和车牌识别三个部分。本文主要介绍软件处理部分，下面是一个车牌识别后的运行结果图：
车牌定位 1.灰度处理 由于彩色图不易确定车牌边界，将彩色图转换为灰度图以进一步处理图片。这里使用了rgb2gray函数，该函数接收一个rgb图像变量作为参数，返回该图像转换为灰度图后的图像数据，并将该数据赋值给变量I1。
若想得到该灰度图的灰度分布情况，可使用imhist函数画出该灰度图的灰度值分布直方图。（此处不再展示）
%% 灰度处理 img1 = rgb2gray(img); % RGB图像转灰度图像 figure; subplot(1, 2, 1); imshow(img1); title('灰度图像'); subplot(1, 2, 2); imhist(img1); title('灰度处理后的灰度直方图'); 2.边缘检测 在将彩色图转换为灰度图后，便可用edge函数识别该图像的边界，edge函数通过使用一阶导数和二阶导数检测亮度的不连续来确定图像的边界，它可以使用Sobel,Prewitt,Roberts,Canny,LoG,零交叉等多种算子，这里使用Roberts算子进行边缘检测。
%% 边缘检测 img4 = edge(img1, 'roberts', 0.15, 'both'); figure('name','边缘检测'); imshow(img4); title('roberts算子边缘检测'); 车牌分割 1.图像腐蚀 由于边缘检测后的图像中无关结构太多，这里需对图像进行腐蚀处理，实现腐蚀处理的函数为imerode，它接收一个图像数据和一个结构子，图像中背景与结构子完全重合的像素点输出值为1，不完全重合的和完全不重合的像素点输出值为0，最后返回使用该结构子腐蚀过后的图像数据，以此实现削减无关结构的目的。
%% 图像腐蚀 se=[1;1;1]; img5 = imerode(img4, se); figure('name','图像腐蚀'); imshow(img5); title('图像腐蚀后的图像'); 2.图像平滑 腐蚀后的图像结构大多呈分散状分布，不连贯。为了方便之后确认车牌位置，这里需对该图像进行平滑处理，在此我们使用闭操作使车牌平滑，并减小噪音，闭操作可以理解为先膨胀后腐蚀，实现函数为imclose。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9face04866164dc9d325c302823a6e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d31f1fa22bd1005e22bdf041fef3f9/" rel="bookmark">
			记录一下js中substring方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍
substring方法用于从一个字符串中提取一个子的字符串；
2、用法
stringObject.substring(start,stop)； 3、参数介绍
start（必填）：要提取的子字符串，在原始字符串中的起始位置；
stop（可选）：要提取的子字符串，在原始字符串中的结束位置；
注意事项：起始包含start，但是结束不包含stop；如果不填写stop，那么要提取的子字符串就是从start开始，到原始字符串的最后一个字符；
（要记住下标是从0开始，而非从1开始）
4、例子
1、只有一个参数的例子
&lt;script type="text/javascript"&gt; var str="Hello world!" document.write(str.substring(3)) &lt;/script&gt; 输出：lo world!
2、包含两个参数的例子
&lt;script type="text/javascript"&gt; var str="Hello world!" document.write(str.substring(3，5)) &lt;/script&gt; 输出：lo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e0205389c9e89b8284609a0c07d3dcf/" rel="bookmark">
			物联网工程施工心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单片机又称单片微控制器，它不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一个芯片上。概括的讲：一块芯片就成了一台计算机。它的体积小、质量轻、价格便宜、为学习、应用和开发提供了便利条件。同时，学习使用单片机是了解计算机原理与结构的最佳选择。而STM32是意法半导体（ST）推出一款32位的单片机。STM32具有超低的价格、超多的外设、丰富的型号、优异的实时性、极低的开发成本等优势。STM32凭借其产品线的多样化、极高的性价比、简单易用的库开发方式，迅速在众多32位单片机中脱颖而出。
在我们学习的过程中第一步就是要新建一个工程文件，然后选择我们需要的cpu就完成我们的框架建立，我们还需要添加启动文件和.c文件等。这些文件我们需要在官方文件库里面或在网上寻找，来获取帮助。
然后将一个一个的文件复制回我们自己建的工程文件里并将复制来的文件添加到工程去算完成准备工作了。
接下来从简单的开始学习点亮led灯，在按下某个按钮后，要能使发光二极管发亮，而我们在对led输出高低电平时，我们还需要设置寄存器对引脚进行初始化处理，才能使引脚具备有数字输入和输出输出功能，可以发现，多出了一个工具条，这就是 Debug 工具条，这个工具条在我们仿真的时候是非 常有用的，下面简单介绍一下 Debug 工具条相关按钮的功能。Debug 工具条部分按钮的功能如 Debug 工具条 复位：其功能等同于硬件上按复位按钮。相当于实现了一次硬复位。按下该按钮之后，代 码会重新从头开始执行。 执行到断点处：该按钮用来快速执行到断点处，有时候你并不需要观看每步是怎么执行的， 而是想快速的执行到程序的某个地方看结果，这个按钮就可以实现这样的功能，前提是你在查 看的地方设置了断点
而后就是学习更深层次的知识，我们学会定时器的使用，就能够用单片机实现时序电路，时序电路的功能是强大的，在工业、家用电气设备的控制中有很多应用，例如，能够用单片机实现一个具有一个按钮的楼道灯开关，该开关在按钮按下一次后，灯亮3分钟后自动灭，当按钮连续按下两次后，灯常亮不灭，当按钮按下时间超过2s，则灯灭。数字集成电路能够实现时序电路，可编程逻辑器件（PLD）能够实现时序电路，可编程控制器（PLC）也能够实现时序电路，可是仅有单片机实现起来最简单，成本最低。定时器的使用是十分重要的，逻辑加时间控制是单片机使用的基础。
在学习过程中很单调，有些知识学起来很抽象，不容易理解，只能慢慢适应，一边学习理论知识，一边编写程序，将程序刷入单片机进行调试，刚开始编程序时喜欢套用书上的语句，却对语句的理解不够。于是当程序出现问题时，不知道如何修改，眼前的程序都是一块一块的被拼凑整合起来的，没法知道哪里错了。但是编程是一件很严肃的事情，容不得半点错误。在错误中不断摸索中前行。在开始时感觉很吃力，在这其中基础知识掌握牢固是非常重要的，然后在学习过程中要学会提问题和自己解决问题，慢慢的对于学习单片机你也会产兴趣。虽然在开始学习单片机时感觉很青涩，但只要坚定自己的学习信心，在付出持之以恒的努力，我相信自己能进一步加深对单片机的了解，在单片机的学习道路上走得更远！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b440c343c0fc4d556ca58f27281624c2/" rel="bookmark">
			Vue项目中各个文件夹意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.build——[webpack配置]
build文件主要是webpack的配置，主要启动文件是dev-server.js，当我们输入npm run dev首先启动的就是dev-server.js，它会去检查node及npm版本，加载配置文件，启动服务。
2.node_modules——[依赖包]
node_modules里面是项目依赖包，其中包括很多基础依赖，自己也可以根据需要安装其他依赖。
3.src——[项目核心文件]
1.accets用来存图片
2.components用来存组件
3.router用来配置路由
4.static页面配置
4.index.html——[主页]
一个简单的html页面，这里id='app'，是为后面的设置vue作用域有关的。
index.html如其他html一样，但一般只定义一个空的根节点，在main.js里面定义的实例将挂载在根节点下，内容都通过vue组件来填充
5.components中的.vue文件
说明：在*.vue文件，template标签里写html代码，且template直接子级只能有一个标签。style标签里写样式，script里面写js代码。
6.App.vue——[根组件]
一个vue页面通常由三部分组成:模板(template)、js(script)、样式(style)：
【template】
其中模板只能包含一个父节点，也就是说顶层的div只能有一个
&lt;router-view&gt;&lt;/router-view&gt;
是子路由视图，后面的路由页面都显示在此处。打一个比喻吧，&lt;router-view&gt;类似于一个插槽，跳转某个路由时，该路由下的页面就插在这个插槽中渲染显示
【script】
vue通常用es6来写，用export default导出，其下面可以包含数据data，生命周期(mounted等)，方法(methods)等。
【style】
样式通过style标签&lt;style&gt;&lt;/style&gt;包裹，默认是影响全局的，如需定义作用域只在该组件下起作用，需在标签上加scoped，&lt;style scoped&gt;&lt;/style&gt;
如要引入外部css文件，首先需给项目安装css-loader依赖包，打开cmd，进入项目目录，输入npm install css-loader，回车。安装完成后，就可以在style标签下import所需的css文件，例如：
&lt;style&gt;
import './assets/css/public.css'
&lt;/style&gt;
这样，我们就可以把style下的样式封装起来，写到css文件夹，再引入到页面使用，整个vue页面也看上去更简洁。
7.文件：main.js——[入口文件]
这个js文件是主页面配置的主入口。主要是利用ES6的模块化引入模板
main.js主要是引入vue框架，根组件及路由设置，并且定义vue实例
后期还可以引入插件，当然首先得安装插件。
8.router——[路由配置]
router文件夹下，有一个index.js，即为路由配置文件
我们可以设置多个路由，‘/index’,'/list'之类的，当然首先得引入该组件，再为该组件设置路由。
说明：如果需要增加组件那就在components文件下定义xx.vue文件并编写代码即可；
如果需要配置路由就要在index.js进行路由“路径”配置；还需要点击跳转就要用到&lt;router-link&gt;&lt;/router-link&gt;标签了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45870b982d0c6d7b310fe734209d63fe/" rel="bookmark">
			修改mysql密码的四种方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速修改mysql密码的四种方法 方法1： 用SET PASSWORD命令 首先登录MySQL。 格式：mysql&gt; set password for 用户名@localhost = password('新密码'); 例子：mysql&gt; set password for root@localhost = password('123'); 方法2：用mysqladmin 格式：mysqladmin -u用户名 -p旧密码 password 新密码 例子：mysqladmin -uroot -p123456 password 123 方法3：用UPDATE直接编辑user表 首先登录MySQL。 mysql&gt; use mysql; mysql&gt; update user set password=password('123') where user='root' and host='localhost'; mysql&gt; flush privileges; 方法4：在忘记root密码的时候，可以这样 以windows为例： 1. 关闭正在运行的MySQL服务。 2. 打开DOS窗口，转到mysql\bin目录。 3. 输入mysqld --skip-grant-tables 回车。--skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。 4. 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\bin目录。 5. 输入mysql回车，如果成功，将出现MySQL提示符 &gt;。 6. 连接权限数据库： use mysql; 。 6. 改密码：update user set password=password("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45870b982d0c6d7b310fe734209d63fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287ca258a5026facd039c1da070383ec/" rel="bookmark">
			MySQL知识点整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据模型的概念
1，层次模型
2，网状模型
3，关系模型
二、E-R图的组成要素及其画法
三.关系数据库范式理论
1，第一范式
2，第二范式
3，第三范式
四，创建与管理数据库
1，创建数据库
2，打开数据库
3，修改数据库
4，删除数据库
五，创建与管理数据库表
1，创建表
2，查看数据表
3，删除数据表
4，修改表结构
六，数据操作
1，数据插入
2，数据修改
3，数据删除
4，删除表数据
七，数据查询
1，基础查询
2，WHERE子句
3，多表查询
一、数据模型的概念 1，层次模型 这种模型描述的数据组织形式像一颗倒置的树，它由节点和连线组成，其中节点表示实体。
2，网状模型 这种模型描述事物及其联系的数据组织形式像一张网，节点表示数据元素，节点间的连线表示数据间的联系。
3，关系模型 关系模型使用的存储结构是多个二维表格，即反映事物及其联系的数据描述是以平面表格形式体现的。
二、E-R图的组成要素及其画法 1，实体(entity)是现实世界中客观存在并且可以互相区别的事物和活动的抽象。具有相同特征和性质的同一类实体的集合称为实体集，可以用实体名以及属性名集合来抽象和刻画。
2，属性（attribute）即实体所具有的某一特性，一个实体可由若干个属性来刻画。
3，联系（relationship)即实体集之间的互相关系。
三.关系数据库范式理论 关系数据库范式理论是数据库设计的一种理论指南和基础。它不仅能够作为数据库设计优劣的判断依据，还可以预测数据库可能出现的问题。
范式按照规范化的级别分为五种，即第一范式（1NF），第二范式（2NF），第三范式（3NF），第四范式（4NF），第五范式（5NF）。在实际的数据库设计过程中，通常需要用到的是前三类范式，下面对它们分别进行介绍：
1，第一范式 第一范式要求每一个数据项都不能拆分成两个或两个以上的数据项，即数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整理、实数、字符型、逻辑性及日期型等。
2，第二范式 如果第二个表已经满足第一范式，而且该数据表中的任何一个非主键字段的数值都依赖于该数据表的主键字段，那么该数据表满足第二范式。
3，第三范式 如果第一个表已经满足第二范式，而且该数据表中的任何两个非主键字段的数值之间不窜在函数依赖关系，那么该数据表满足第三范式。
四，创建与管理数据库 1，创建数据库 使用CREATE DATABASE或CREATE SCHEMA命令就可以创建数据库
语法格式如下:
CREATE DATABASE (数据库名) CREATE SCHEMA (数据库名) 语句中的大小写单词为命令动词，输入命令时，不能更改命令动词含义，但MySQL命令解释器对大小写不敏感，所以输入命令动词时只要词义不变，与大小写无关。
DEFAULT:指定默认值
CHARACTER SET:指定数据库字符集
COLIATE:指定字符集的校对规则
2，打开数据库 创建了数据库之后，使用USE命令可指定当
语法格式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287ca258a5026facd039c1da070383ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4c35870bc9d038761d23562b4103e4/" rel="bookmark">
			上位机C#设计制作简单计算器程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1设计要求
根据老师要求具体界面如下
（1）设计一个四则运算计算器
（2）通过计算器界面上的按钮输入计算数据，支持整型和小数输入
（3）可以进行加、减、乘、除操作
（4）支持退格(删除输入框内的最后一个字符)、CE(清空输入框)、C(清空输入框并重置计算器)
（5）有一个历史记录文本框，可以显示计算过的内容
2代码内容具体如下
1先设置声明
2退格
3+号组件
4-号组件
5*号组件
6/号组件
7.号组件
8数字组件每个数字更改里面数字即可
9全部清空
10等于号组件
总结
代码仅供参考 在老师指导下完成的一个简单的计算器代码 有很多不足或者可以说有更简单的代码形式，大家一起学习
上位机程序设计是一门综合性很强的课程，涉及到了计算机网络、数据库、操作系统等多方面的知识，并且具有较强的实践性。在这门课中，我们首先学习了关于上位机程序设计的基本概念，了解了上位机程序设计与普通应用程序设计之间的区别，以及上位机程序设计与数据库之间的关系；其次介绍了使用C#进行上位机程序设计的基本步骤。通过这部分课程的学习，我们了解了使用C#进行上位机程序设计的基本概念和基本方法，并且能够运用C#进行上位机程序设计。
在这部分课程中，我们首先学习了关于上位机程序设计的基本概念以及其主要应用；其次介绍了使用C#进行上位机程序设计的基本步骤；最后学习了使用C#进行上位机程序设计中常用到的控件以及常用命令。
在这一部分中，我们首先学习了关于计算机网络、数据库、操作系统等方面的知识；然后介绍了使用C#进行上位机程序设计中常用到的控件以及常用命令；接着以一个简单的上位机程序为例，详细介绍了使用C#进行上位机程序设计的步骤；最后学习了如何运用C#进行上位机控件开发。
1设计要求 实现计算器的功能。在“操作数”填写上两个数字，并选择“运算符”，单击“计算”按钮之后，可以在“结果文本框”中显示计算结果
根据老师要求具体界面如下 （1）设计一个四则运算计算器 （2）通过计算器界面上的按钮输入计算数据，支持整型和小数输入 （3）可以进行加、减、乘、除操作 （4）支持退格(删除输入框内的最后一个字符)、CE(清空输入框)、C(清空输入框并重置计算器) （5）有一个历史记录文本框，可以显示计算过的内容 2代码内容具体如下 1先设置声明 public partial class Form1 : Form { Double Rnum, Lnum, Ans; String flag; 2退格 private void button1_Click(object sender, EventArgs e) //退格 { string old = textBox1.Text;//取得当前的数据 if (old.Length &gt; 0) textBox1.Text = old.Remove(old.Length - 1); } 3+号组件 private void button5_Click(object sender, EventArgs e) { Lnum = Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f4c35870bc9d038761d23562b4103e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c36fa68a5ad97ef33cbd8a1b8217852/" rel="bookmark">
			C#的低频卡门禁系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
准备工作
首先我们要设置一个门禁卡的界面
设置完界面接下来是代码部分
1主程序要添加一个串口件
2还要添加命名空间
3设置串口部分代码还有选项框设置初值
4打开串口
5组件发送部分
6手动接收
7定时器组件代码
8写卡
9注销
10读卡
11查卡
总结
准备工作 1我们要准备好NewLab实验台并放上M3模块和LF 天线模块 ，把实验台调整到"通讯模式"
2在设备管理器中查找本机的串口号 ，默认是COM1
3打开串口调试助手，打开NewLab实验台看是否接收一串数据该数据为随机数
若测试不成功则有可能是
1、电脑自带的串口故障
2、串口线故障
先将串口线插入电脑后端的RS232接口，然后在串口线的另一头，用导线短接2、3脚，用“串口助手”发送一串数据，看是否能正常接收，若正常则RS232接口和串口线正常
3、若无法接收，再更换几条串口线测试，以判断是端口坏还是串口线坏。
首先我们要设置一个门禁卡的界面 1界面样貌如下
2 然后我们要在编辑器里面输入内容
端口号“COM1,COM2,COM3,COM4”（其实端口号要看电脑端口号具体是多少）
波特率添加“2400,9600,19200，115200”
数据位宽填写“7,8,9”
奇偶校验“None，Odd,Even”
停止位“One，Two，OnePointFive，None”
设置完界面接下来是代码部分 1主程序要添加一个串口件 public partial class Form1 : Form { SerialPort com1 = new SerialPort(); Timer t = new Timer(); 2还要添加命名空间 using System.Windows.Forms; using System.IO.Ports; 3设置串口部分代码还有选项框设置初值 private void Form1_Load(object sender, EventArgs e) { SerialPort com1 = new SerialPort(); String[] port = SerialPort.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c36fa68a5ad97ef33cbd8a1b8217852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84942153c412fca7058a759ef50ee2bd/" rel="bookmark">
			STM32F10X系列基于标准库——CLASSB库移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司在弄一些软件上认证工作，刚好需要到了ST的一个自检库，CLASSB库。就是对MCU的一个自检，启动时、运行时，对MCU的寄存器、RAM\ROM等进行自检，如果不通过，则进入故障函数。在移植CLASSB时，遇到了几个问题，在这里记录一下哈哈~
是基于STM32F103VC标准库 移植的CLASSB。移植的第一步，先去ST官网下载相关的例程以及相关的说明文档CLASSB - 工具与软件 - Search STMicrocontrollers，我用的是STM32-CLASSB-SPL：
下载完成后，解压后，安装F1的驱动，自动生成一个例程文件夹，里面有官方提供的一个自测库STM32F10x_SelfTestLib，只需要移植这个库到我们的实际工程即可。
把这个文件夹的.c文件全部添加到实际工程中：
1、加载文件的修改
添加完成后，把例程中的加载文件也加载到实际工程中，并按照实际工程程序的地址进行修改 ：
按照实际工程的程序开始地址与大小进行修改。将存放FLASH 32CRC检验值的CHECKSUM存放在程序末尾，*.o (CHECKSUM, +Last)。将ST CLASSB库例程中的相关bat中设置的移植过来 2、 CPU启动测试文件修改
一开始，按照例程中的来运行，发生在Stack pointer (Register R13)这个步骤，会进入FailSafePOR，后面看了一下F4的例程，运行没问题，就直接把F4检测Stack pointer (Register R13)这个步骤的检测代码直接复制过来，神奇的事情发生了，竟然检测通过！！！！！！！这个步骤检测的是MSP指针，其实也可以参考上一个检测PSP来修改。另一种方式就是我上图注释掉的那种方式，把MOVS指令，换成MOV指令，也可以测试通过。具体什么原因MOVS指令不行，我也不清楚，百度了好久都查不出什么原因。。。。。。。。
3 、系统启动文件修改 根据实际工程需要的启动文件，移植例程相对应的启动文件，我的工程用到的是hd.s，直接移植整个文件即可。
4 、SysTick_Handler()函数修改
将例程中SysTick_Handler()的内容全部复制到实际工程的SysTick_Handler()函数中使用。
5 、调试相关代码修改
实际工程中没有使用到屏幕，以及串口，将上图所述代码屏蔽掉。
6 、RAM自检相关代码修改
这部分自检，需要把RAM的数据全部清0，所以需要先把RAM的数据备份，自检完成后，重新写入。F1的RAM自检运行时，有点问题，后面参考了F4的RAM自检部分代码，下面是RAM自检第一个步骤的代码，其他步骤原理一样：
ErrorStatus STL_FullRamMarchC(void) { ErrorStatus Result = SUCCESS; uint32_t *p; /* RAM pointer */ uint32_t j; /* Index for RAM physical addressing */ uint32_t RAM_Val = 0; /* ---------------------------- STEP 1 ----------------------------------- */ /* Write background with addresses increasing */ for (p = RAM_START; p &lt;= RAM_END; p++) { /* Scrambling not important when there's no consecutive verify and write */ RAM_Val = *p; *p = BCKGRND; if ( *p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84942153c412fca7058a759ef50ee2bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f9b1ba19a7a79a2638fe9f3db1e912/" rel="bookmark">
			物联网工程施工STM32芯片的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：一、STM32芯片基础知识（1）STM32芯片的概述（2） STM32芯片的特点（3） STM32芯片的系列和型号 二、STM32芯片在物联网工程中的应用（1） STM32芯片在物联网中的优势（2） STM32芯片在物联网中的应用 三、心得体会 前言： 在如今的互联网时代，物联网技术已经成为新一代互联网发展的重要趋势之一，而STM32芯片则是物联网工程中最为常用的控制芯片之一，其可靠性和稳定性被广泛认可。本文将为您详细介绍STM32芯片的特点、使用方法和应用范围，希望能够帮助您更好地理解和应用STM32芯片，从而更好地开展物联网工程项目。
一、STM32芯片基础知识 （1）STM32芯片的概述 STM32是意法半导体公司（STMicroelectronics）推出的一系列32位微控制器产品。这些芯片具有高度的集成度、低功耗、高性能和低成本的特点。STM32芯片采用ARM Cortex-M内核，是一种高性能、低功耗的嵌入式微处理器。
（2） STM32芯片的特点 STM32芯片具有以下特点：
1.高度集成：STM32芯片集成了微控制器所需的各种外设，如ADC、DAC、PWM、UART、SPI、I2C等。
2.低功耗：STM32芯片采用了低功耗技术，能够在高性能的同时实现低功耗的运行。
3.高性能：STM32芯片采用了ARM Cortex-M内核，具有高性能的特点。
4.低成本：STM32芯片采用了先进的制造技术和晶圆级封装技术，能够实现低成本的生产。
（3） STM32芯片的系列和型号 STM32芯片有多个系列和型号，包括STM32F0系列、STM32F1系列、STM32F2系列、STM32F3系列、STM32F4系列、STM32F7系列等。每个系列都有多个型号，如STM32F103C8T6、STM32F407ZGT6等。不同的系列和型号在外设种类、内存容量、性能指标等方面有所差异。
二、STM32芯片在物联网工程中的应用 （1） STM32芯片在物联网中的优势 STM32芯片在物联网中具有以下优势：
1.高度集成：STM32芯片集成了多种外设，能够满足物联网设备的各种需求。
2.低功耗：物联网设备通常需要长时间运行，低功耗是物联网设备的重要指标。
3.高性能：物联网设备通常需要高性能的处理器来完成各种复杂的任务。
4.网络支持：STM32芯片支持多种网络通信协议，如Wi-Fi、蓝牙、LoRa等。
（2） STM32芯片在物联网中的应用 STM32芯片在物联网中的应用非常广泛，包括智能家居、智能城市、智能医疗、智能交通等领域。以下是一些常见的应用场景：
1.温度、湿度、光照等传感器数据采集和处理。
2.控制家庭电器，如智能灯光、智能窗帘等。
3.智能安防，如智能门锁、智能摄像头等。
4.智能交通，如智能车牌识别、智能停车等。
三、心得体会 在STM32芯片的应用过程中，我有以下体会：
1.熟悉芯片规格：在使用STM32芯片之前，需要对其规格进行了解和熟悉，包括芯片的引脚布局、时钟频率、内存大小、功耗等。
2.熟悉编程语言：STM32芯片的编程语言主要为C语言，需要对C语言进行熟悉和掌握，可以借助在线教程和参考书籍进行学习。
3.利用开发工具：在开发过程中，可以使用STM32CubeMX等开发工具进行开发和调试，提高开发效率和代码质量。
4.注意硬件设计：在进行物联网设备的硬件设计时，需要考虑STM32芯片的电源管理、引脚分配等问题，保证硬件设计的合理性和可靠性。
以上就是我在物联网工程施工STM32芯片的知识与应用心得，希望对大家有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad3a512c676e0581c110e8955f36a51/" rel="bookmark">
			vue3-实现父子组件之间的通信（详解&#43;源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：vue3相对于vue2的父子传参方式有所改变，本文介绍三种：父组件给子组件传参、父组件调用子组件内的方法、子组件调用父组件的方法，如果不需要一种一种看可以直接下滑看全部代码，有注释也蛮好理解
一、父组件给子组件传参： 1、父组件给子组件传参时，父组件这边的方式没有改变，还是在子组件上用 :xxx=“要传的参数”
2、子组件接收时要用defineProps方法来接收，接收时要用父组件定义的那个xxx一样
3、和vue2一样，在defineProps里面接收到的参数可以直接在html里面使用，相当于已经定义过
父组件代码： &lt;template&gt; &lt;div :style="{ border: '1px solid red', }"&gt; 我是首页，父组件 &lt;Title :parMsg="myMsg"&gt;&lt;/Title&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "dashboard", }; &lt;/script&gt; &lt;script setup&gt; import Title from "@/components/title/index.vue"; import { ref } from "vue"; //传给子组件的参数 const myMsg = ref("我来自父组件"); &lt;/script&gt; &lt;style lang="scss" scoped&gt;&lt;/style&gt; 子组件代码： &lt;template&gt; &lt;div :style="{ border: '1px solid green', }" &gt; &lt;div&gt;子组件组件&lt;/div&gt; &lt;div&gt;父组件传过来的参数：{{ parMsg }}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad3a512c676e0581c110e8955f36a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ab7affb957e1108d2ec570597f5ac5/" rel="bookmark">
			Java解压RAR文件的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种： public class fileZipUtil { /** * zip文件解压 * @param inputFile 待解压文件夹/文件 * @param destDirPath 解压路径 */ public static void unZipFiles(String inputFile,String destDirPath) throws Exception { File srcFile = new File(inputFile);//获取当前压缩文件 // 判断源文件是否存在 if (!srcFile.exists()) { throw new Exception(srcFile.getPath() + "所指文件不存在"); } ZipFile zipFile = new ZipFile(srcFile, Charset.forName("GBK"));//创建压缩文件对象 //开始解压 Enumeration&lt;?&gt; entries = zipFile.entries(); while (entries.hasMoreElements()) { ZipEntry entry = (ZipEntry) entries.nextElement(); // 如果是文件夹，就创建个文件夹 if (entry.isDirectory()) { String dirPath = destDirPath + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47ab7affb957e1108d2ec570597f5ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71362b3c2184255b364ffd8f08ede6a/" rel="bookmark">
			【MySQL】SQL的高阶用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 条件查询使用关系运算符查询使用IN关键字查询使用BETWEEN AND关键字查询使用空值查询使用AND关键字查询使用OR关键字查询使用LIKE关键字查询(模糊查询)使用LIMIT分页查询使用GROUP BY进行分组查询GROUP BY和聚合函数一起使用GROUP BY和聚合函数以及HAVING一起使用 使用ORDER BY对查询结果排序 组合查询(UNION、UNION ALL)别名设置(AS)为表起别名为字段取别名 多表关系表的关联关系数据准备关联查询删除外键的数据交叉连接查询(CROSS JOIN)内连接查询([INNER] JOIN)外连接查询(LEFT | RIGHT [OUTER] JOIN) 子查询数据准备带比较运算符的子查询带EXISTS关键字的子查询带ANY关键字的子查询带ALL关键字的子查询 总结 条件查询 数据准备
-- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建student表 CREATE TABLE student ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) DEFAULT 'male' ); -- 向student表插入数据 INSERT INTO student (sid,sname,age,gender) VALUES ('S_1001', 'lili', 14, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1002', 'wang', 15, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1003', 'tywd', 16, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1004', 'hfgs', 17, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1005', 'qwer', 18, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1006', 'zxsd', 19, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1007', 'hjop', 16, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1008', 'tyop', 15, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1009', 'nhmk', 13, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1010', 'xdfv', 17, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1012', 'lili', 14, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1013', 'wang', 15, 'female'); 使用关系运算符查询 关系运算符说明=等于&lt;&gt;不等于!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e71362b3c2184255b364ffd8f08ede6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec1471438f63e069542c9b214f6494d/" rel="bookmark">
			Matlab分析FFT数据，采用录波器记录数据，采样10M/s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xlsread()函数读取.CSV格式的文件；
num = xlsread(‘C:\Users\guochangfeng\Desktop\有源阻尼\系数9\tek0050CH1.csv’,1,‘B22:B400000’);
在利用fft()函数对读取的数据进行FFT分析；
plot(num);
y = fft(num);
采样1M；
fs=10e6; N=length(num); %采样频率和数据点数
n=0:N-1; %时间序列
mag=abs(y);
f=n*fs/N;
最后在画出频谱分析图；
length(f);
length(mag);
bar(f(10:1000),mag(10:1000));
% %% 例1：x=0.5sin(2pi15t)+2sin(2pi40t)。采样频率fs=100Hz，分别绘制N=128、1024点幅频图。
% clf;
% fs=100;N=128; %采样频率和数据点数
% n=0:N-1;t=n/fs; %时间序列
% x=0.5sin(2pi15t)+2sin(2pi40t); %信号
% y=fft(x,N); %对信号进行快速Fourier变换
% mag=abs(y); %求得Fourier变换后的振幅
% f=nfs/N; %频率序列
% subplot(2,2,1),plot(f,mag); %绘出随频率变化的振幅
% xlabel(‘频率/Hz’);
% ylabel(‘振幅’);title(‘N=128’);grid on;
% subplot(2,2,2),plot(f(1:N/2),mag(1:N/2)); %绘出Nyquist频率之前随频率变化的振幅
% xlabel(‘频率/Hz’);
% ylabel(‘振幅’);title(‘N=128’);grid on;
% %对信号采样数据为1024点的处理
% fs=100;N=1024;n=0:N-1;t=n/fs;
% x=0.5sin(2pi15t)+2sin(2pi40t); %信号
% y=fft(x,N); %对信号进行快速Fourier变换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec1471438f63e069542c9b214f6494d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29eec7fccff9e80422be2eebb0d08311/" rel="bookmark">
			十分钟搞懂MySQL 如何实现四大隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脏读、不可重复读、幻读理解 1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
例如：
张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
与此同时， 事务B正在读取张三的工资，读取到张三的工资为8000。
随后， 事务A发生异常，而回滚了事务。张三的工资又回滚为5000。
最后， 事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。
2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
例如：
在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。
与此同时， 事务B把张三的工资改为8000，并提交了事务。
随后， 在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
3、幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
例如：
目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。
此时， 事务B插入一条工资也为5000的记录。
这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。
4、提醒 不可重复读的重点是修改： 同样的条件，你读取过的数据，再次读取出来发现值不一样了
幻读的重点在于新增或者删除： 同样的条件，第 1 次和第 2 次读出来的记录数不一样
5、第一类丢失更新
A事务撤销时，把已经提交的B事务的更新数据覆盖了。例如： 这时候取款事务A撤销事务，余额恢复为1000，这就丢失了更新。
6、第二类丢失更新
A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失 什么是MVCC？ MVCC的全称是“多版本并发控制”。这项技术使得InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值。这是一个可以用来增强并发性的强大的技术，因为这样的一来的话查询就不用等待另一个事务释放锁。这项技术在数据库领域并不是普遍使用的。一些其它的数据库产品，以及mysql其它的存储引擎并不支持它。 在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。
读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用）
读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。
可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。
串行化：事务串行执行。避免了以上所有问题。
以上是SQL-92标准中定义的四种隔离级别。在MySQL中，默认的隔离级别是REPEATABLE-READ（可重复读），并且解决了幻读问题。简单的来说，mysql的默认隔离级别解决了脏读、不可重复读问题。
不可重复读重点在于update和delete，而幻读的重点在于insert。
在Mysql中MVCC是在Innodb存储引擎中得到支持的，Innodb为每行记录都实现了三个隐藏字段：
6字节的事务ID（DB_TRX_ID ）
7字节的回滚指针（DB_ROLL_PTR）
隐藏的ID（DB_ROW_ID）
6字节的事物ID用来标识该行所述的事务，7字节的回滚指针需要了解下Innodb的事务模型。
事务ID 事务ID是一个递增的整数，唯一的标识一个事务。ID的大小可以用来表示事务的串行化顺序，用于事务可见性的判断。
多版本存储 MySQL InnoDB实现了多版本并发控制（MVCC），在多版本存储上，MySQL采用从新到旧（Newest To Oldest）的版本链。B+Tree叶结点上，始终存储的是最新的数据（可能是还未提交的数据）。而旧版本数据，通过UNDO记录（做DELTA）存储在回滚段（Rollback Segment）里。每一条记录都会维护一个ROW HEADER元信息，存储有创建这条记录的事务ID，一个指向UNDO记录的指针。通过最新记录和UNDO信息，可以还原出旧版本的记录。
如下图， V1被一个事务更新为V2，V2被另一个事务更新为V3，Δ1存储V1到V2的更新，Δ2存储V2到V3的更新。此时，如果一个事条定位到B+Tree叶子节点的记录V3，则通过V3+Δ2可以还原出V2，通过V3+Δ2+Δ1可以还原出V1。
ReadView （或者可以称之为Snapshot）
ReadView是某一个时间点，事务执行状态的一个快照，可以用来判断事务的可见性。ReadView的基本结构如下：
ReadView { creator_trx_id low_limit_id up_limit_id ids .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29eec7fccff9e80422be2eebb0d08311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d94bf0fe29bf0db77829f02f710abc7/" rel="bookmark">
			git的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、git简介 git是一款免费、开源的版本控制系统，用于高效地处理任何或大或小的项目。
作用：
文件存档备份
文件版本管理
多人协同合作（自动合并）
二、git的三个区域 工作区：处理工作的区域
暂存区：临时存放的区域
本地git仓库：最终的存放区域
1.在文件夹📁的体现 工作区：在你的电脑💻看到的目录
暂存区：在.git文件夹📁内的index中，以二进制记录📝
版本库：整个.git文件夹📁，也认为是本地仓库
2.在代码中的体现 三、配置全局的用户名和邮箱📮 配置全局的用户名和邮箱的作用：在以后的提交中，可以查看本次提交的记录是谁提交的。
git config 固定命令：设置git相关配置
--global 全局配置：一次配置，整机在使用git时都生效
git config --global user.name 你的用户名 git config --global user.email 你的邮箱地址 配置后，查看是否配置成功
git config --list 举例：
以后想要修改，可以重新执行一次配置命令覆盖即可
四、git基础命令 1.在本地新建一个文件夹📁 2.在新建的文件夹📁，运行以下命令，得到一个.git文件夹，即可让git开始准备管理 # 初始化git 仓库，产物：.git文件夹 git init .git是个隐藏文件夹
举例：
3.一次性把所有改变的文件放入暂存区 本地创建一些文件
举例：
# 这里.的意思是：当前目录下所有改变都暂存 git add . 举例：
4.把暂存区的内容提交到版本库 git commit -m "提交的内容的说明" 相当于存档了一次，在版本库中产生一次提交记录（并生成版本号）
本次存档，不耽误我们在工作区继续编写项目。
举例：
五、git查看日志和状态 查看所有提交日志 git log 举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d94bf0fe29bf0db77829f02f710abc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903288fb0b823631ace7bdc50c9a230d/" rel="bookmark">
			python RSASHA1加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from Crypto.PublicKey import RSA from Crypto.Signature import PKCS1_v1_5 from Crypto.Hash import SHA import base64 import warnings warnings.filterwarnings("ignore") def get_signature(test1, test2): private_key = """MIICXQIBAAKBgQCVRVDNAAPMk3vHrh9KIdr3LRptz2vuq6XH5DQiZq5fPYjD6nm8 fMrL9gk+VJiANTj77Y3kN75SXjpYj2Ptx/vmsuDffZvGEMK7vHHVWbURCaZUTEbM CfIw5/94a56R51fS5X6mgBVryqLenUy+y5VfsYcRZn50XWId/3c9T7UQdQIDAQAB AoGAW3h+ayD3MwWtdE9fHS5h39XjvCa/HSJSFIvi5rHFaNdsV6H3t2lBXHsIbwmn 6eizYq3PpWoDVrYnSt2TfsJtuaGKFxYogPO50J91onxqHoCF1hIHED88/XTZdYDb PeKN5SQU+nOTV+fF1SWJsXhN7CncW0K8d+hJ9fJM/M+LcoECQQDGD70GVYZdPjIi Plu2C/WRRs2NJU6A9O5KR0/a7i0oVkzC9RX1M4VNfXhO4rD32ZZU7MardWbWE1Da 8bmmngZnAkEAwO/HfMja9Qer6h946Yv4US444GYDt2nNAe721E4UzGTQrbElma9x buGyUeOvkt7X5aAswDAMRjmZJors8DpQwwJAUgFsM3Yv1uWMnm8RS/PxrkARlZJP yccf7rNOFgitu9jXmZUejVLSq736lTb5LPXzb6BFtfI7LQH8ZVrWkm01mwJBAI48 d2nkPZ+k/zWD7ETpHrDijaXJL3Y5Npz1Sdzsj2K79CgIz/qEH/EpzKeYXqi9RpcP xc4N3g6rid+jTdgwdbcCQQCLMw/BSJJsKe8Croqgo8e3mfcTelC+jiXWVm1G/HkL GCtgsC7VRGsoyj3hMaiujCu16eg0hAMPWd15PDRvWxHj""" sign_str = "test1=" + "%s" % test1 + "&amp;" + \ "test2=" + "%s" % test2 private_key_bytes = base64.b64decode(private_key) pri_key = RSA.importKey(private_key_bytes) signer = PKCS1_v1_5.new(pri_key, ) hash_obj = SHA.new(sign_str.encode('utf-8')) signature1 = base64.b64encode(signer.sign(hash_obj)) signature = signature1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903288fb0b823631ace7bdc50c9a230d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/70/">«</a>
	<span class="pagination__item pagination__item--current">71/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/72/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>