<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb14b8ffad626cd41f389a7b4ac3d14/" rel="bookmark">
			Java课程设计——贪吃蛇小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.项目简介
二.项目构架图
三.团队成员以及任务简介
四.代码和git链接
五.项目运行图片 一.项目简介：设计目标及完成功能本软件是针对贪吃蛇小游戏的JAVA程序，利用上、下、左、右方向键来改变蛇的运动方向，在随机的地方产生食物，吃到食物就变成新的蛇体，碰自身则游戏结束，否则正常进行游戏。
二.项目构架图
三.团队成员任务简介
队长：张德群
任务：贪吃蛇游戏界面，贪吃蛇图像的引用，团队博客以及git的书写，以及贪吃蛇的移动；
队员：李连崧
任务：贪吃蛇长度的增加以及食物的生成，以及贪吃蛇的死亡条件。
四.代码。
1.Startgame类
import javax.swing.*;
public class Startgame {
public static void main(String[] args) {
/*
绘制一个静态窗口
*/
JFrame frame = new JFrame("贪吃蛇by张德群，李连崧");//创建一个窗口，参数是窗口标题显示的文字
frame.setBounds(430, 180, 900, 720);//设置一个窗口的大小
frame.setResizable(false);//窗口大小不可以改变
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口可以关闭，此处填写参数3可以
frame.add(new GamePanel());//添加组件
frame.setVisible(true);//打开窗口
}
}
import javax.swing.*;
2.date类
public class date {
/*
此类用于存储图片信息
image和src是同一个级别的文件夹
*/ public static ImageIcon right = new ImageIcon("image/right.png");
public static ImageIcon body = new ImageIcon("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb14b8ffad626cd41f389a7b4ac3d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f423803840b476594ed0a508e9782ee/" rel="bookmark">
			【Haproxy 搭建Web 群集】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Haoroxy 基础了解1、常见的Web集群调度器2、Haproxy 应用分析 二、Haproxy 调度算法原理三、HAProxy的主要特性四、HAProxy负载均衡策略五、LVS、Nginx、HAproxy的区别1、Nginx的优点，缺点2、LVS的优点和缺点3、HAProxy的优点 六、Haproxy搭建 Web 群集实验1、Haproxy 服务器部署2、节点服务器设置3、为 rsyslog 添加 haproxy 日志的配置 一、Haoroxy 基础了解 HAProxy是可提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，是免费、快速并且可靠的一种解决方案。HAProxy非常适用于并发大（并发达1w以上）web站点，这些站点通常又需要会话保持或七层处理。HAProxy的运行模式使得它可以很简单安全的整合至当前的架构中，同时可以保护web服务器不被暴露到网络上。
1、常见的Web集群调度器 目前常见的Web 集群调度器分为软件和硬件
软件通常使用开源的LVS、Haproxy、Nginx
LVS 性能最好，但是搭建相对复杂;Nginx 的 upstream模块支持群集功能，但是对群集节点健康检查功能不强，高并发性能没有 Haproxy好。
硬件一般使用比较多的是F5、Array，也有很多人使用国内的一些产品，如梭子鱼、绿盟等
2、Haproxy 应用分析 LVS在企业应用中抗负载能力很强，但存在不足
·LVS不支持正则处理，不能实现动静分离
·对于大型网站，LVS的实施配置复杂，维护成本相对较高
Haproxy是一款可提供高可用性、负载均衡、及基于TCP和HTTP应用的代理的软件
·适用于负载大的Web站点
·运行在硬件上可支持数以万计的并发连接的连接请求
二、Haproxy 调度算法原理 Haproxy支持多种调度算法，最常用的有三种
1、RR
·RR算法是最简单最常用的一种算法，即轮询调度
·理解举例
有三个节点A、B、C 第一个用户访问会被指派到节点A 第二个用户访问会被指派到节点B 第三个用户访问会被指派到节点C 第四个用户访问继续指派到节点A，轮询分配访问请求实现负载均衡效果 2、LC (Least Connections)
·最小连接数算法，根据后端的节点连接数大小动态分配前端请求
·理解举例
有三个节点A、B、C，备节点的连接数分别为A:4、B:5、C:6 第一个用户连接请求，会被指派到A上，连接数变为A:5、B:5、C:6 第二个用户请求会继续分配到A上，连接数变为A:6、B:5、C:6;再有新的请求会分配给B，每次将新的请求指派给连接数最小的客户端 由于实际情况下A、B、C的连接数会动态释放，很难会出现一样连接数的情况 此算法相比较rr算法有很大改进，是目前用到比较多的一种算法 3、SH (Source Hashing)
·基于来源访问调度算法，用于一些有Session会话记录在服务器端的场景，可以基于来源的IP、Cookie等做集群调度
·理解举例
有三个节点A、B、C，第一个用户第一次访问被指派到了A ，第二个用户第一次访问被指派到了B 当第一个用户第二次访问时会被继续指派到A，第二个用户第二次访问时依旧会被指派到B，只要负载均衡调度器不重启，第一个用户访问都会被指派到A，第二个用户访问都会被指派到B，实现集群的调度 此调度算法好处是实现会话保持，但某些IP访问量非常大时会引起负载不均衡部分节点访问量超大，影响业务使用 三、HAProxy的主要特性 ●可靠性和稳定性非常好，可以与硬件级的F5负载均衡设备相媲美；
●最高可以同时维护40000-50000个并发连接，单位时间内处理的最大请求数为20000个，最大处理能力可达10Git/s；
●支持多达8种负载均衡算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f423803840b476594ed0a508e9782ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea371d0e2c7cb246f4a2f5a4064e8507/" rel="bookmark">
			突然出现K8s中pod无法通过Service的ClusterIP访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该内容仅供出现同类问题参考。
K8S的集群通过k3s部署。
突然出现K3s中pod无法通过Service的ClusterIP访问。
通过curl ip:port 请求，出现No Route to Host 的问题。
参考文章K8s常见问题：Service 不能访问排查流程 排除后，发现所有配置都是正确的。
通过"sudo iptables-save |grep xxxxxx"命令在所有节点上查看配置后发现，能正常访问的服务在所有节点上配置均一致，不能正常访问的服务存在部分节点上配置不一致的情况。
处理处理办法，重启k3s或k3s-agent。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b029cab4df84036184c640848a8eb093/" rel="bookmark">
			个人对几个IDE的看法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（说明：本文仅表达个人看法，实际上文中的几个IDE功能不同，不能互相取代。截图上的程序均已发布）
个人认为一款IDE在功能完整的前提下，应当做到操作简便。另外，对缩放的兼容性也会影响观感。以下对本人用过的几款IDE进行分析。
1.Visual Studio（目前已经不使用了，不截图）
本人以前在电脑课上学过C语言，但由于不记得新建工程的流程，就另找了一个视频教程。视频上用的IDE是Visual Studio。个人感觉Visual Studio偏向多个文件的项目的管理，对于单个文件的项目来说新建工程的流程比较复杂。Visual Studio对缩放的兼容性不错。另一个问题是弃用了scanf（）等函数，给开发造成不便。后来发现安装的是试用版，过期了就换成Code Blocks了。后来了解到Visual Studio的社区版免费，但由于已经换了IDE，就没有换回Visual Studio。
2.Code Blocks
Code Blocks的主要优势是可以直接打开和运行.c文件，方便开发单个文件的程序；也提供了管理多个文件组成的程序的功能。不过据说在大型项目中Visual Studio的使用更为广泛，由于本人没有开发过PC上的大型项目，暂不对这一方面进行评论。Code Blocks对缩放的兼容性一般，界面会比较模糊。
3.VS Code（由于装在另一个系统，暂不截图）
本人使用VS Code主要是开发ROS程序。VS Code通过CMake进行工程管理，虽然通用性强但配置流程比较复杂，实际使用时还可能出现操作没问题但无法编译的情况。VS Code对缩放兼容性较好，界面清晰。
4.Keil5
本人使用Keil5开发stm32程序。Keil5内置管理多文件工程的功能，但在文件较多时添加文件还是比较麻烦。Keil5对缩放兼容性一般，有缩放时界面较模糊。
5.Thonny
本人使用Thonny开发Python和MicroPython程序。Thonny操作简便，可以直接打开.py文件，导入文件时只需要添加相应的代码，不需要另外的导入步骤。Thonny对缩放的兼容性好，界面清晰。
结语：
IDE对开发体验是有明显影响的。本人认为理想的IDE应当实现直接打开文件、直接使用include／import语句导入文件（C／Ｃ＋＋应该也可以采用这样的方式来确定文件的包含关系）、一键运行程序和兼容缩放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9395370a3ef9e79383bd17c42b4d5f3f/" rel="bookmark">
			基于大数据的农产品价格数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接下来让我分享一下我们近期所完成的一个大数据农产品价格数据分析平台，主要是分为三部分来实现，后端：python+flask，爬虫：python，前端：vue。
环境：Ubuntu
虚拟机软件：VMware17
所用技术：Hadoop、Spark、Vue、Python，Mysql
所用语言：Python、Vue
本系统是基于 hadoop+spark+vue 为主要技术研发的,使用 Ubuntu 作为平台支持， 前端使用虚拟机浏览器，采用前后端分离开发的模式，提高开发效率，对此相关技术支 持很多并且已经很成熟，所以在技术可行性方面上没有任何问题。
大概功能流程图如下：
系统使用流程基本如下：首先先打开虚拟机进去，然后先启动hadoop和spark。然后就进入python虚拟环境然后就可以进行运行后端。
启动方法：
配置号网络后：就在里面打开一个终端，先运行Hadoop和spark启动代码如下：
hadoop启动：
start-all.sh
启动spark /usr/local/spark/sbin/start-all.sh
启动完后就去打开pycharm
在这里面，打开pycharm后就进行运行代码：
点击到这个文件：
然后在下面的命令行启动py环境：conda activate py3.8
这样就是已经进入了
进入后就可以点击上面那个运行的三角形
这样的话就是运行成功了，然后就可以打开vscode，位置也是在
这个里面，打开vscode后就可以直接启动前端:npm run serve
然后前端启动成功后，直接点击那个运行成功的端口即可。
实现效果图大致如下：
核心后端代码如下：
sprak.py：
import yaml from pyspark import SparkConf from pyspark.sql import SparkSession app_name = "agri-analysis-spark" master = "local[*]" conf = SparkConf().setAppName(app_name).setMaster(master) spark = SparkSession.builder.config(conf=conf).getOrCreate() spark.conf.set("spark.sql.execution.arrow.pyspark.enabled", "true") mysql_config = {} mysql_url = "" def init_sql(config_name): global mysql_config global mysql_url mysql_config = yaml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9395370a3ef9e79383bd17c42b4d5f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7faa1a2781e8b921cb39d2d7e9ea202e/" rel="bookmark">
			TXT文件怎么转换成PDF这种格式?分享给大家三个方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你是经常阅读电子小说的朋友，对于TXT格式的文档一定不会陌生。尽管TXT文档只包含纯文本，无法插入图片和表格等内容，但它仍然是一种非常重要的文档格式。有时候我们想使用某些只支持PDF格式的软件打开TXT文档，这时就需要将TXT转换为PDF格式。幸运的是，将TXT转换为PDF并不复杂，它与其他文档格式转换为PDF的方法类似，可以利用一些工具来实现快速转换。
一、记灵在线工具 首先推荐给大家的是记灵在线工具，它是一款专业的办公软件，提供了多种常用功能，包括文档转换为PDF、PDF分割合并、为PDF添加水印和密码等功能。只需要将TXT文档上传到记灵在线工具，就可以轻松实现一键转换。此外，记灵在线工具还支持同时处理多个文档，因此可以高效地一次性转换多个文档。
使用记灵在线工具非常方便，你可以通过浏览器直接访问其官网，在操作平台中选择所需的【TXT转PDF】选项。按照提示上传文档，然后点击【开始转换】即可完成转换。转换成功后，你可以自定义下载PDF文档到电脑上，随时使用。
二、万兴PDF转换器 万兴PDF转换器是另一个推荐的工具，它需要先下载并安装在电脑上。该软件的转换方式是先创建一个空白PDF文档，然后从本地文件中导入其他格式的文档，最后保存为PDF文档。
运行万兴PDF转换器后，点击菜单栏的【文件】-【创建】-【空白PDF文档】，然后再点击【打开文档】，将TXT格式的文档上传到软件中，就可以将TXT文档转换为PDF文档了。
万兴PDF转换器提供了简单而直观的操作界面，使得转换过程更加便捷。通过按照上述步骤，你可以轻松地将TXT文档转换为PDF格式。
三、电脑打印机 除了使用专业的转换工具外，还可以利用电脑自带的打印功能将TXT文档保存为PDF。首先，使用Windows系统电脑的默认程序打开TXT文档，然后点击【文件】下方的打印选项。在打印选项中选择“Wondershare PDF Expert”作为打印机，这样在正式打印之前可以先将文档保存为PDF。需要注意的是，这种方法需要先安装虚拟打印机才能操作，并且一次只能转换一份文档，相比专业的转换工具，效率较低。
一旦将TXT转换为PDF文档，其内容将保持不变，并且可以在许多软件中打开，更加方便阅读和分享。掌握TXT转PDF的方法对我们来说非常重要，因为它可以一次性成功转换多份文档。希望上述实用工具能帮助到大家，使用后可以将它们收藏起来，以备将来使用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9f956c9f2aedad615fd48b94be2e0a/" rel="bookmark">
			vue3&#43;ts 使用qrcode(解决了找不到qrcode类型声明文件问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装
全局安装：npm install -g qrcode安装类型声明：npm i --save-dev @types/qrcode 2.在所需处引用
import QRcode from "qrcode"; 3.配合canvas 生成二维码
&lt;canvas id="canvas" &gt;&lt;/canvas&gt; //-----------------生命周期 onMounted(() =&gt; { generateQRCode(qrCodeText.value) }) //-----------------自定义方法 //生成二维码 const qrCodeText = ref('https:xxxxx') const generateQRCode = (text: string) =&gt; { const canvas = document.getElementById('canvas') QRcode.toCanvas(canvas, text, { margin: 0, width: 115 //自定义宽度 } ); return canvas //记得返回canvas } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e349d1ab6d96172c591631888578cc5c/" rel="bookmark">
			项目: 使用卷积神经网络CNN进行植物叶子分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、引言
1.1、什么是深度学习？
1.2、项目的背景
1.3、数据集的选择与其意义
2、文献回顾
3、方法论
4、数据集预处理
5、实验设置
6、结果分析
1、叶片处理结果，image_size[224,224]:
2、测试集的模型准确率(accuracy)和损失(loss)的变换情况:
3、训练过程
4、模型分析评价
1、引言 1.1、什么是深度学习？ 深度学习 (DL，Deep Learning) 是机器学习 (ML，Machine Learning) 领域中的一种新的研究方向, 它通过学习样本数据的内在规律和表示层次，对文字、图像和声音等数据进行解释提供了重要帮助。作为一种复杂的机器学习算法，深度学习在语音和图像识别方面的效果远远超过以前的相关技术。在搜索技术、数据挖掘、机器翻译、自然语言处理、多媒体学习、语音识别、推荐系统、个性化技术等领域，深度学习已经取得了许多成果。
1.2、项目的背景 而近年来，深度学习技术的快速发展极大地推动了图像处理领域的研究进展。其中，植物叶片分类是一项具有挑战性且具有广泛应用前景的任务，如植物学和农业等领域。通过精确识别植物叶片的形态、硬度、颜色和纹理等特征，植物叶片分类有助于植物分类和疾病监测。本项目旨在使用卷积神经网络（CNN）算法构建植物叶片分类模型，以实现对不同种类植物叶片的准确分类。
1.3、数据集的选择与其意义 本项目的目标是使用深度学习方法对瑞典叶子数据集（Swedish leaf dataset）,该数据集包含了1125张叶片图片, 涵盖了15种不同的植物物种. 通过植物进行分类，对不同植物叶片的自动识别, 有助于我们更好地了解和监测植物物种的多样性和分布情况, 这对植物研究、生态学、评估生物多样性变化和环境监测等方面具有重要意义！
2、文献回顾 植物叶片分类的任务已经被广泛研究。例如，Khamparia等人（2019）使用SIFT（Scale-Invariant Feature Transform）算法提取叶片图像的特征，并结合支持向量机（SVM）对九种植物进行了分类。Landi等人（2019）则采用深度卷积神经网络对15种植物的叶子进行了分类。Elharrouss等人（2020）则通过应用深度卷积神经网络成功识别了三种水果叶子，并取得了高度精确的结果。
对于植物叶子分类任务，卷积神经网络（CNN）是一种常用且有效的方法。
3、方法论 在本项目中，我们采用了一种基于卷积神经网络（CNN）的模型结构来进行图像分类任务。该模型的结构由多个卷积层、池化层和全连接层组成。
首先，我们添加了一个卷积层，使用32个大小为3x3的卷积核对输入图像进行卷积操作。卷积操作可以提取图像中的局部特征。接着，我们应用了ReLU激活函数，用来引入非线性性质，增强模型的表达能力。 然后，我们添加了一个2x2的最大池化层，用于降低特征图的尺寸，减少计算量，并提取最显著的特征。
model = Sequential() model.add(Conv2D(32, (3, 3), input_shape=X.shape[1:])) model.add(Activation('relu')) model.add(MaxPooling2D(pool_size=(2, 2))) 然后，我们重复添加了几个类似的卷积层和池化层。这些层的目的是逐渐提取图像的更高级特征。我们通过增加卷积核的数量和深度，分别为64、128和64个，来捕捉图像中更丰富的信息。
model.add(Conv2D(64, (3, 3))) model.add(Activation('relu')) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Conv2D(128, (3, 3))) model.add(Activation('relu')) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Conv2D(64, (3, 3))) model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e349d1ab6d96172c591631888578cc5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088e1ba6de86fd6eaed1b01bfddd1670/" rel="bookmark">
			JAVA实现压缩解压文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、源码运行前准备好文件夹 2、源码 package com.els.modules.inquiry.service.impl; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.nio.file.attribute.FileTime; import java.time.Instant; import java.util.Arrays; import java.util.Objects; import java.util.zip.Deflater; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; import java.util.zip.ZipOutputStream; public class xc { public static void main(String[] args) { // 测试压缩和解压缩单文件ZIP // 被压缩的单文件 File inputFile = new File("C:\\Users\\HLT\\Desktop\\cs\\cs.docx"); // 压缩文件保存ZIP文件路径名称 File zipFile = new File("C:\\Users\\HLT\\Desktop\\cs\\cs.zip"); // 解压缩ZIP保存路径 File unzipFile = new File("C:\\Users\\HLT\\Desktop\\cs\\unzip"); long start = System.currentTimeMillis(); // 压缩文件 zipCompress(inputFile, zipFile); long end = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/088e1ba6de86fd6eaed1b01bfddd1670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0ec9893c0f4c11760c2f4ed0397398/" rel="bookmark">
			python AI工具库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		instructpix2pix，一种编辑图片的算法，输入图片和需求，生成对应结果。
在线使用：https://huggingface.co/spaces/timbrooks/instruct-pix2pix
musiclm，ai music， 音乐生成，图片或文字出音乐。
在线：
https://huggingface.co/spaces/Mubert/Text-to-Music
https://huggingface.co/spaces/fffiloni/img-to-music
chatgpt，聊天工具。
rome，人头3d建模。
在线使用：https://huggingface.co/spaces/Pie31415/rome
gfpgan，图片修复和抠图工具。
adrenaline，代码debug工具。
在线试用：https://useadrenaline.com/
facedancer，ai换脸。
在线使用：https://huggingface.co/spaces/felixrosberg/face-swap
novelai，画画。
lama cleaner，去水印修复图片。
minigpt-4，就是基于图片的chatgpt，上传一个图后可以依图提出各种要求和问题。
在线试用：https://minigpt-4.github.io/
inpaint-anything，傻瓜ps神器。
https://github.com/geekyutao/inpaint-anything
这个是导航网站，但大多可能用不了，姑且记录一下：
http://www.aigcget.com/
1
1
1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c864588da97c823886961510712d6ea7/" rel="bookmark">
			适用于ts的防抖方法，防止打包编译报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;van-search clearable :modelValue="searchValue" @update:modelValue="changeSearchValue" placeholder="请输入搜索关键词" /&gt; const searchValue = ref(''); let changeSearch = (value: string) =&gt; { searchValue.value = value; // 值变化时处理逻辑 }; /** * 防抖函数 */ let debounce = (fn: Function, delay: number) =&gt; { let timer:NodeJS.Timeout; const func = function () { if(timer) clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apply(func, arguments); }, delay); }; return func }; let changeSearchValue = debounce(changeSearch, 500); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9c943f445f2e76af59fe07bccd0485/" rel="bookmark">
			【无标题】List去重常见方法效率比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中List去重的多种方案有以下几种：
使用Set进行去重
使用Set集合是非常常见的方法，因为Set具有不允许元素重复的特性，当我们把List的元素存放到Set中时，就自动实现了去重。这种方式简单易行，代码量少，但是由于需要将List中的数据存储到Set中，再转化为List，因此效率相对较低。
java
List list = Arrays.asList(1, 2, 1, 3, 4, 2);
List newList = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(list));
借助Map实现去重
这种方式的原理是利用HashMap的key不重复的特性，遍历List时将List中的元素存放到HashMap中，这样重复的元素就自动被去掉了。这种方式比使用Set集合稍微复杂一些，但是处理效率却相对较高。
java
List list = Arrays.asList(1, 2, 1, 3, 4, 2);
Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
for (Integer i : list) {
map.put(i, i);
}
List newList = new ArrayList&lt;&gt;(map.values());
Java8 Stream流去重
Java8中Stream流提供了很多便捷的API，包括去重。这种方式也非常简单，只需要使用Stream的distinct()方法即可。
java
List list = Arrays.asList(1, 2, 1, 3, 4, 2);
List newList = list.stream().distinct().collect(Collectors.toList());
下面是三种方法的效率比较：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba9c943f445f2e76af59fe07bccd0485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03d9c1070ff28178eb5f2bc5cf00814/" rel="bookmark">
			Ansible Copy 模块使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ansible copy模块是用于将文件从控制节点复制到远程服务器的模块。它可以将文件、目录或文本从控制节点复制到远程服务器，也可以创建目标目录。
下面是一些EXAMPLE：
- name: Copy a single file to remote host copy: src: /path/to/local/file.txt dest: /path/to/remote/directory/ owner: username group: usergroup mode: '0644' backup: yes 上面的example使用了copy模块将本地文件/path/to/local/file.txt复制到远程服务器的/path/to/remote/directory/目录下。owner和group参数指定目标文件的所有者和组，mode参数设置文件权限，backup参数启用备份。
以下是一些copy模块的常见用例：
1. 复制文件到远程服务器
- name: Copy a single file to remote host copy: src: /path/to/local/file.txt dest: /path/to/remote/directory/ 上述例子使用了copy模块将本地文件/path/to/local/file.txt复制到远程服务器的/path/to/remote/directory/目录下。
2. 复制多个文件到远程服务器
- name: Copy multiple files to remote host copy: src: "{{ item }}" dest: /path/to/remote/directory/ with_items: - /path/to/local/file1.txt - /path/to/local/file2.txt - /path/to/local/file3.txt 上面的example使用了copy模块将多个本地文件复制到远程服务器的/path/to/remote/directory/目录下。with_items参数指定了要执行的多个拷贝任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03d9c1070ff28178eb5f2bc5cf00814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd76b88a877b536b23d77427081f6ca/" rel="bookmark">
			Chrome浏览器中热搜推荐消失术——AdBlock插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chrome浏览器中热搜推荐消失术——AdBlock插件 想用Chrome浏览器给自己一个清净，
结果躲得过广告，躲不过热搜推荐？
说好高效学习，总是下次一定？
一不留神深陷“瓜田”？
不妨试试这个“热搜消失术”！！！
1.下载AdBlock插件 点击：插件下载
2.解压AdBlock插件 3.点击Chrome浏览器右上角三个点图标—》更多工具—》扩展程序 4.开启开发者模式 5.打开刚才解压的AdBlock插件，选中红框所示文件，将其拖拽到如图所示的空白区 6.弹出如下窗口，点击添加扩展程序 7.弹出如下窗口，别害怕，是自愿募捐，可以直接关闭这个页面，不影响后续使用 8.点击扩展程序中加载的AdBlock的详情—》下拉点击扩展程序选项—》点击左边的“自定义”—》点击“手动拦截规则”右边的“编辑按钮”—》输入www.baidu.com##DIV[class=“FYB_RD”]—》点击“手动拦截规则”右边的“保存按钮” 9.重启Chrome浏览器后，使用百度搜索，发现右边的热搜推荐消失 后记 本文参考: chrome浏览器关闭百度热搜——AdBlock插件
感谢这篇文章的作者，其实他（她）已经写得很好了，但我操作的时候，还是有几个细节不清楚，比如开发者模式的开启，弹出付费页面吓得直接卸载插件，还好填卸载理由时，插件官方大大说明了可以免费使用，是自愿募捐，这才没有放弃。
写这篇文章的目的是给自己打个备忘录，同时也希望能稍稍地帮助到别人，自利利他，感恩所有无私分享的人，帮助别人就是帮助你自己！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f936f138bdeb00ba538beded81204b1/" rel="bookmark">
			Ubuntu 18.04系统编译安装PHP教程。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是Ubuntu 18.04系统编译安装PHP的教程：
更新系统软件包：
sudo apt update sudo apt upgrade 安装编译所需的依赖项：
sudo apt install build-essential libxml2-dev libssl-dev libbz2-dev libjpeg-dev libpng-dev libcurl4-openssl-dev libfreetype6-dev libgmp-dev libkrb5-dev libpq-dev libzip-dev 下载PHP源代码：
mkdir ~/php cd ~/php curl -O https://www.php.net/distributions/php-7.4.21.tar.gz tar -zxvf php-7.4.21.tar.gz cd php-7.4.21 配置编译参数：
./configure --prefix=/usr/local/php --with-apxs2=/usr/bin/apxs2 --with-config-file-path=/etc/php/7.4 --with-config-file-scan-dir=/etc/php/7.4/conf.d --enable-bcmath --with-bz2 --enable-calendar --enable-exif --enable-ftp --with-gd --with-jpeg --with-png --with-freetype --with-gettext --with-gmp --with-imap --with-imap-ssl --with-kerberos --enable-mbstring --with-mysqli --enable-opcache --enable-pcntl --with-pdo-mysql --with-zlib --with-openssl --enable-soap --enable-sockets --with-xmlrpc --enable-zip 编译和安装PHP：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f936f138bdeb00ba538beded81204b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f152d99f42c839de92ac2ce75da25723/" rel="bookmark">
			idea导入import javax.servlet.http.HttpServletRequest；爆红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述： import javax.servlet.http.HttpServletRequest; 2、解决办法： 第一步：
选中左侧项目 → 右键 → 选择 Open Module Settings 第二步：
在 Project Structure 窗口, 选择左侧的 Modules ，在选中中间的项目，点击右侧的＋号，选择Library
第三步：
在Choose Libraries 窗口，选择New Library... ,在下拉框选择Java
第四步：
在Select Library Files 窗口，选择Tomcat的lib文件夹下的servlet-api.jar
第五步：
可以正常导入HttpServletRequest类了，需要注意一下，我在本地操作的以上步骤后，项目的导入还是爆红，并且在代码使用HttpServletRequest爆红出并未提示import javax.servlet.http.HttpServletRequest; 我一直以为是导入方式错误了，但是又在External Libraries 中按路径找到了HttpServletRequest，于是我又把类上面爆红的import javax.servlet.http.HttpServletRequest;给删掉了，重写点出HttpServletRequest，于是就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b109f391397c412a3fe251039ca9f16/" rel="bookmark">
			链表的运用：多项式加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过链表来实现两个多项式的加法。
1.创建节点类型
用链表储存多项式则链表的一个节点就代表多项式的某一项。所以一个节点应该包含多项式的系数、多项式的指数以及指向下个节点的指针。
2.打印多项式
传入一个指向多项式链表的指针，遍历该链表，依次打印链表内容，此时采用科学计数法的形式。
3.尾插
申请一个新节点，将要求的系数和指数赋值给这个新节点，并将新节点的指针域置空，然后遍历整个链表，将新节点链接到最后一个节点的next指针上。
4.多项式相加
从两个待相加的多项式表头开始，比较两个节点的指数大小，将结果存储到第一个多项式的链表中。若节点指数相同，则将两个节点系数相加，并将结果存放到第一个节点的系数中；若节点指数不同，将指数小的节点链接到结果链表中，改变指针指向以更新链表遍历状态。
#include&lt;stdio.h&gt; #include&lt;malloc.h&gt; typedef struct LinkNode { int coefficient; int exponent; struct LinkNode* next; } *LinkList, * NodePtr; LinkList initLinkList() { LinkList tempHeader = (LinkList)malloc(sizeof(struct LinkNode)); tempHeader-&gt;coefficient = 0; tempHeader-&gt;exponent = 0; tempHeader-&gt;next = NULL; return tempHeader; }// Of initLinkList void printList(LinkList paraHeader) { NodePtr p = paraHeader-&gt;next; while (p != NULL) { printf("%d * 10^%d + ", p-&gt;coefficient, p-&gt;exponent); p = p-&gt;next; }// Of while printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b109f391397c412a3fe251039ca9f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84eb68c0c92eb787f3ad92da3ebfa8fa/" rel="bookmark">
			vscode编辑器常用插件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用插件列表，助力你更高效的开发 chiness vscode编辑器改为中文模式。有一定水平的人还是保持使用英文吧，毕竟对英语学习有用。
auto rename tag 修改开始标签时会同步修改结束标签
live server 可以将html文件以本地服务器的方式运行到浏览器，修改完代码，浏览器会自动刷新。
open in browser 在vscode的.html文件中，右击空白区域，在菜单中选择open in browser，即可直接跳转到浏览器中开打html文件。
vetur 提供vue代码的语法高亮，智能提示等
vscode-icons 文件夹及文件的图标
auto close tag 自动闭合html/xml标签
Markdown All in One（书写Markdown） 可以在vscode中抒写markdown
常用快捷键：
ctrl+shift+v 实时预览
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0d7cdbc8487c86d0e38d3aad99f46b/" rel="bookmark">
			Spring Cloud常用组件介绍(Netflix、Alibaba）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud常用组件介绍 文章目录 **Spring Cloud常用组件介绍**一、说明**1.1.什么是Spring Cloud**1.2.Spring Cloud的组件选型 **二、组件介绍****2.1.服务注册与发现****2.1.1.Netflix Eureka****1）分布式模型****2）主要组件****3）工作过程****4）集群部署****5）高可用机制** **2.1.2.Alibaba Nacos****1）分布式模型****2）体系架构****3）高可用****4）与Eureka对比** **2.2.流量控制****2.2.1.Netflix Feign+Ribbon+Hystrix****1）Netflix Feign介绍****2）Netflix Ribbon介绍****3）Netflix Hystrix介绍****4）Feign+Ribbon+Hystrix之间的关系** **2.2.2.Alibaba Sentinel****1）流量控制****2）负载保护****3）实时监控和控制面板****4）与Netflix Hystrix的对比** **2.3.网关****2.3.1.Spring Cloud Gateway****1）主要概念****2）工作流程****3）主要功能及实现方式** **2.3.2.Netflix Zuul****1）主要概念****2）工作流程****3）与Spring Cloud Gateway的对比** **2.4.服务监控****2.4.1.Spring Boot Admin****2.4.2.Netflix Hystrix Dashboard + Turbine****2.4.3.Spring Cloud Sleuth+Zipkin****1）Sleuth原理****2）主要概念****3）Zipkin介绍** **2.5.配置中心****2.5.1.Spring Cloud Config****2.5.2.Apollo****2.5.3.Alibaba Nacos** 一、说明 随着近些年来互联网业务的蓬勃发展，以及微服务技术体系的不断完善成熟，越来越多的系统建设开始朝着微服务的方向发展，其中基于Spring Boot配合Spring Cloud服务治理框架的组合，也得到了越来越多开发团队的认可，逐渐成为企业级微服务建设的标准解决方案。
1.1.什么是Spring Cloud Spring Cloud是一系列框架的有序集合。它基于Spring Boot的开发便利性简化了分布式系统基础设施的开发，如服务发现注册、配置中心、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。
Spring Cloud将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。Spring Cloud的主要支持和贡献者中包括了许多国内外的著名互联网科技公司，如Netflix和Alibaba，这大大推动了Spring Cloud的持续进步和发展。
1.2.Spring Cloud的组件选型 Spring Cloud家族拥有众多组件，既有作为单个服务独立部署的，又有可作高可用集群分布式部署的，也有作为插件集成于应用服务的。随着使用场景的丰富和社区开发者的不断贡献，Spring Cloud中实现同一类功能的组件也逐渐衍生出各分支子项目，各子项目设计思路和功能各有侧重。此外，Spring Cloud家族之外也有一些开源组件由于功能的契合，经常与Spring Cloud组件配合使用。这就需要使用者根据自身使用场景灵活选用，而作为企业用户，在进行组件选型时则更多需要考虑组件的成熟度和未来支持情况。
下面就简要介绍Spring Cloud常用组件的功能及使用场景，以便开发人员和设计者进行组件选型和应用。
二、组件介绍 下面就Spring Cloud关键的几类组件分别进行介绍。
2.1.服务注册与发现 服务注册与发现是服务治理的基础，Spring Cloud Netflix子项目中的Eureka是目前最常用的Spring Cloud服务注册组件，此外也有Spring Cloud Alibaba的子项目Nacos，以及Zookeeper等注册中心方案，下面分别对其中被广泛使用的Netflix Eureka和Alibaba Nacos进行介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f0d7cdbc8487c86d0e38d3aad99f46b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8174e5d0ec60008b9ca58ba74281d8/" rel="bookmark">
			linux红帽系统、图形化界面详细安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.挂载光盘 mount /dev/cdrom /mnt/ #挂载光盘到/mnt/目录下 mkdir /opt/package/ #创建package目录 cp -rf /mnt/* /opt/package/ #将mnt目录下的所有文件拷贝到/opt/RH/ mount: /dev/sr0 is write-protected, mounting read-only
这条消息表示您正在尝试挂载一个只读设备，该设备被保护防止写入。这通常是CD或DVD-ROM驱动器，其中的磁盘被保护免受意外修改。因此，您只能以只读方式挂载该设备，无法写入或修改其中的任何内容。如果您想要在该设备上进行写入或修改，请检查设备是否被正确插入并完全解除保护。
可以用 df -hT 命令查看是否挂载成功, 如下图所示：
看到 /dev/sr0 ios9660 4.2G 0 100% /mnt 则表示已经成功挂载。
df -hT 接来下是创建目录，将mnt目录下的所有文件拷贝到 /opt/RH/ 。使用命令 cd /opt/package/ 进入到 package 目录下 在用 ls 查看目录下的文件 如下图所示：已经成功的拷贝。
cd 命令的使用：cd /文件名/文件名/ 这样使用的
2.配置本地yum源 cd /etc/yum.repos.d/ #切换到/etc/yum.repos.d/目录 vi local.repo #vi 新建local.repo配置，并添加以下内容到文件 编辑 local.repo 文件，输入 i 进入 vi 编辑模式。编辑完成后按Esc退出编辑模式，然后输入:wq 回车保存退出
[rh] name=rh baseurl=file:///opt/package gpgcheck=0 enable=1 输入:wq 回车保存退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e8174e5d0ec60008b9ca58ba74281d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb103b06228acce693b5f9f91daa722/" rel="bookmark">
			VRRP虚拟路由器冗余技术学习与实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：VRRP技术简述
上图是网络经典故障中的单点故障，网关路由器的故障影响了整个网段的主机，通过使用VRRP的方法可以有效解决上述问题。VRRP是虚拟路由器冗余协议，通过把几台路由设备联合组成一台虚拟的路由设备，将虚拟路由设备的IP地址作为用户的默认网关实现与外部网络通信。当网关设备发生故障时，VRRP能够选举新的网关设备承担数据流量，从而保障网络的可靠性，保障网络不中断，在实现多个真实网关的冗余备份的同时完成了数据转发的负载均衡。
2：VRRP组成员及选举规则
主路由器：Master →负责承担数据报文转发任务
备份路由器：Backup →负责监控主路由器状态
虚拟路由器 ：Virtual → 又称VRRP备份组，作为局域网中主机的默认网关
VRRP主备选举原则：
首先比较优先级，优先级大的为master
如果优先级一致，其次比较ip地址，IP地址大的为master
3：VRRP工作过程
1）VRRP备份组中的设备根据优先级选举出”Master-主路由器“
2）“Master-主路由器”发送“免费ARP报文”，将虚拟MAC地址通知给与它连接的设备，承担数据转发任务
3）“Master-主路由器”周期性发送VRRP通告报文（三层心跳报文）
4）通告报文发送的周期时间：默认情况下是1秒
5）通告报文发送的目的地址是组播地址：224.0.0.18
6）“Backup-备份路由器”监控“主路由器”状态，在3倍的"发送周期"后，如果无法收到“主路由器”发送的VRRP 通告报文，备份路由器升级为“新的Master-主路由器”，新的Master-路由器会立即发送免费ARP报文，刷新与它连接设备中的MAC表项，从而把用户流量引到新的Master设备上来。
7）“原Master”设备故障恢复时，首先切换至Backup状态：
&amp;：如果“原Master”已开启抢占模式，并且对比优先级，发现自己的优先级高，则主动将自己切换成Master。
&amp;：如果”原Master“没有开启抢占模式，即便优先级高，也不会进行抢占，依然保持Backup状态
4：VRRP负载分担综合实验
实验需求：
1）PC1属于vlan10 ,PC2属于vlan20
2）vlan10的主网关是SW1，备份网关是SW2，vlan10的数据流量默认由SW1转发
3）vlan20的主网关是SW2，备份网关是SW1，vlan20的数据流量默认由SW2转发
4）SW1和SW2部署MSTP和VRRP，既要实现负载分担，又要互为备份
配置步骤：
第一步：配置PC和server的IP地址，掩码，网关
第二步：配置SW3交换机
1）创建vlan
2）配置MSTP
第三步：配置SW1和SW2
1）创建vlan，配置vlanif
2）配置VRRP,MSTP
第四步：SW1/SW2/R3配置静态路由 第五步：验证VRRP
详细配置命令：
第一步：配置PC和server的IP地址，掩码，网关 第二步：在sw3交换机 SW3配置： [SW3]vlan batch 10 20 [SW3]int g0/0/1 [SW3-GigabitEthernet0/0/1]port link-type access [SW3-GigabitEthernet0/0/1]port default vlan 10 [SW3-GigabitEthernet0/0/1]int g0/0/2 [SW3-GigabitEthernet0/0/2]port link-type access [SW3-GigabitEthernet0/0/2]port default vlan 20 [SW3-GigabitEthernet0/0/2]quit [SW3]port-group group-member g0/0/3 g0/0/4 [SW3-port-group]port link-type trunk [SW3-port-group]port trunk allow-pass vlan all [SW3-port-group]quit [SW3]stp region-configuration [SW3-mst-region] region-name vrrptest [SW3-mst-region] instance 10 vlan 10 [SW3-mst-region] instance 20 vlan 20 [SW3-mst-region] active region-configuration 第三步：SW1和SW2配置VRRP和MSTP和静态路由 SW1配置： [SW1]vlan batch 10 20 [SW1]int g0/0/2 [SW1-GigabitEthernet0/0/2]port link-type trunk [SW1-GigabitEthernet0/0/2]port trunk allow-pass vlan all [SW1-GigabitEthernet0/0/2]qui [SW1]vlan batch 13 [SW1]int vlanif 10 [SW1-Vlanif10]ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fb103b06228acce693b5f9f91daa722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7c16218873d67b5c0080c9ca56a120/" rel="bookmark">
			Vue多国语言实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装
vue2.6.10版本，不知道为什么不加-S 就找不到vue-i18n
i18n官网明确了使用版本，vue2和vue3分别不一样，vue2使用8版本，vue3使用9版本，安装时需要注意版本号
所以vue2.6.10版本
npm install vue-i18n@8.27.0 vue3或者以上直接使用命令
npm install vue-i18n -S 2.在main.js里配置il8n
import Vue from 'vue' import VueI18n from 'vue-i18n' Vue.use(VueI18n) 3.创建il8n实例在main.js中挂载
3-1.实例文件夹：
import VueI18n from 'vue-i18n' const i18n = new VueI18n({ // 双语 locale: 'zh', messages: { 'zh': require('./components/lang/zh'), 'en': require('./components/lang/en') }, }) export default i18n; 3-2.main.js里引用挂载
import i18n from '@/lang' var vue = new Vue({ el: '#app', i18n, }) 4.实现切换语言
4-1.vue2
Language(lan){ this.$i18n.locale = lan localStorage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e7c16218873d67b5c0080c9ca56a120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f650436be7f94f194fadc8d418bd142e/" rel="bookmark">
			Vue配置代理(devServer)，解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、作用： Vue官方文档的解释是：
如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在开发环境下将 API 请求代理到 API 服务器。这个问题可以通过 vue.config.js 中的 devServer.proxy 选项来配置。
通俗的说，就是为了解决跨域问题。
2、用法： 本篇都以axios发请求为例,样例如下：
axios.get("/abc/def"); axios.get("/abc/ghi"); axios.post("/abc/jkm"); axios发送的请求是本地的服务器地址拼接上发送的请求，如 http://xxx:8080/abc/def
2.1 指定请求开头配置 如果发送的请求都以 /abc 开头，代理配置：
devServer: { proxy: { "/abc": { target: "http://XX.XX.XX.XX:8081", changeOrigin: true, ws: true, secure: false, }, } }, “/abc”:{} : 引号中代表，本代理配置，会检测以 /abc 开头的访问target : 代表检测到以 /abc 开头的接口后，将请求中端口、地址，修改为后端接口地址，从而避免发生跨域问题changeOrigin : 是否修改数据包中host参数，默认为truews : 是否代理 websockets
该代理请求为： http://localhost:8080/abc/def —&gt; http://XX.XX.XX.XX:8081/abc/def
2.2 代理多个接口 请求示例：
// http://localhost:8080/zzz/one axios.get("/zzz/one"); // http://localhost:8080/xxx/two axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f650436be7f94f194fadc8d418bd142e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7234f59b30d9833c9c5a6a13d14d21ca/" rel="bookmark">
			用户行为数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用户行为数据分析1 项目描述2 项目需求3 数据准备1、创建user_data数据表用于导入user_data.csv中的数据2、加载user_data.csv中的数据到user_data表3、接下来进行数据清洗，包括：删除重复值，时间戳格式化，删除异常值。 4 统计分析1、查询总访问量PV，总用户量UV2、查询日均访问量，日均用户量3、查询每个用户的购物情况4、根据user_behavior_count的结果查询复购率5、统计转化率6、统计一天内活跃时段点击数、收藏数、加购物车数、购买数的分布7、统计周用户点击数、收藏数、加购物车数、购买数的活跃分布8、统计用户最近一次的购买时间，降序排序只显示前10条记录9、统计消费频率最高的前10名用户 用户行为数据分析 1 项目描述 user_data.csv是一份用户行为数据，时间区间为2017-11-25到2017-12-03，总计29132493条记录，大小为1.0G，包含5个字段。数据集的每一行表示一条用户行为，由用户ID、商品ID、商品类目ID、行为类型和时间戳组成，并以逗号分隔。关于数据集中每一列的详细描述如下：
列名称字段名数据类型说明用户IDuser_idstring用户ID商品IDitem_idstring商品ID商品类目IDcategory_idstring商品类目ID行为类型behavior_typestring行为类型，包括(pv, buy, cart, fav)时间戳create_timeint行为时间戳 用户行为类型共有四种，它们分别是
行为类型说明pv商品详情页pv，等价于点击buy商品购买cart将商品加入购物车fav收藏商品 2 项目需求 1、查询总访问量PV，总用户量UV
2、查询日均访问量，日均用户量
3、查询每个用户的购物情况（统计点击、商品购买、加入购物车、收藏的次数），统计结果放入表user_behavior_count
4、根据user_behavior_count的结果查询复购率：产生两次或两次以上购买的用户占购买用户的比例
5、统计用户各环节行为转化率，分别统计从“点击”到“(加购物车+收藏)”的转化率，和从“(加购物车+收藏)”到“购买”的转化率
6、统计一天内活跃时段点击数、收藏数、加购物车数、购买数的分布
7、统计周用户击数、收藏数、加购物车数、购买数的活跃分布
8、统计用户最近一次的购买时间，降序排序只显示前10个记录
9、统计消费频率最高的前10名用户
3 数据准备 将数据加载到hive，然后通过hive对数据进行处理
1、创建user_data数据表用于导入user_data.csv中的数据 -- 创建表 create table if not exists user_data ( user_id string COMMENT '用户ID', item_id string COMMENT '商品ID', category_id string COMMENT '商品类目ID', behavior_type string COMMENT '行为类型', create_time int COMMENT '行为时间戳' ) row format delimited fields terminated by ',' stored as textfile; 2、加载user_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7234f59b30d9833c9c5a6a13d14d21ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4a2758e7deb3c7fe57d8dbeefa5d91/" rel="bookmark">
			Java通过Ip2region实现IP定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在一些短视频平台上可以看到,视频作者或评论区可以显示IP地址,这其实就是根据IP获取到的我们可以通过一些在线网站就可以看到我们当前的公网IP和IP定位,最近有个需求也需要通过请求获取客户端的IP和IP的定位,于是通过一系列的百度,最终选择使用Ip2region这个工具库来进行定位
Ip2region简介 Ip2region是一个开源工具库,是一种用于IP地址定位的工具。 它是基于B树数据结构的数据库，可用于将IP地址转换为国家、省、市、区县等信息。 使用Ip2region工具，您可以轻松地查找某个IP地址所在的区域信息，从而帮助您进行定位和分析。
目前Ip2region有1.0和2.0两个版本,p2region 1.0和Ip2region 2.0之间的主要区别在于数据的更新频率和精度。 Ip2region 2.0在原有版本的基础上增加了更多的数据，例如更详细的地图信息和更准确的IP地址定位。 Ip2region 2.0的数据更新频率也更高，这意味着它将提供更精确的信息。此外， Ip2region 2.0还提供了Java、Python和PHP等语言的版本，这使得它更加适用于不同类型的应用程序。
GitHub地址(CSDN镜像地址,非原地址):https://gitcode.net/mirrors/lionsoul2014/ip2region
Ip2region使用 前面提到Ip2region分为1.0和2.0两个版本,此处我是用的是2.0版本,如需1.0版本此文章并不适用,可以参考如下文章
(153条消息) Java根据ip地址获取归属地_java通过ip地址获取地区_java技术媛的博客-CSDN博客
Ip2region2.0版本引入依赖 2.7.0是当前最新版本,使用Ip2region2.0引入2.6.0版本及以上应该是都可以的
&lt;dependency&gt; &lt;groupId&gt;org.lionsoul&lt;/groupId&gt; &lt;artifactId&gt;ip2region&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 下载ip2region.xdb文件 下载链接;https://gitcode.net/mirrors/lionsoul2014/ip2region/-/blob/master/data/ip2region.xdb
如果链接失效:进入上文github地址然后选在data文件夹,里面就有ip2region.xdb文件
下载后将其放在resources文件夹下,注意在pom文件里添加排除配置,防止maven将文件编译
&lt;plugin&gt; &lt;configuration&gt; &lt;nonFilteredFileExtensions&gt; &lt;nonFilteredFileExtension&gt;xdb&lt;/nonFilteredFileExtension&gt; &lt;/nonFilteredFileExtensions&gt; &lt;/configuration&gt; &lt;/plugin&gt; Searcher介绍 ip2region核心类就是Searcher,在2.0的版本中它有三种创建方式,三种方式使用方式不太一样,接下来逐一介绍
newWithFileOnly(String dbPath) 此种创建方式,只有一个参数,顾名思义,我们可以知道入参其实就是ip2region.xdb文件的路径,此种创建方式是最基础的创建方式,不支持并发,每次创建都需要进行一次IO,读取本地ip2region.xdb文件
newWithVectorIndex(String dbPath, byte[] vectorIndex) 此种创建方式多出来一个vectorIndex参数,它是一个字节数组我们可以提前从 xdb 文件中加载出来 VectorIndex 数据，然后全局缓存，每次创建 Searcher 对象的时候使用全局的 VectorIndex 缓存可以减少一次固定的 IO 操作，从而加速查询，减少 IO 压力。此种方式也不支持并发,每个线程需要重新new一个Searcher对象
newWithBuffer(byte[] cBuff) 此种创建方式只有一个cBuff参数,它可以预先加载整个 ip2region.xdb 的数据到内存，然后基于这个数据创建查询对象来实现完全基于文件的查询无IO压力,而且仅占用11M内存,最重要的是它支持并发,全局只需要创建一次即可,也是查询效率最高的一种方法,下面我自己封装了一个工具类,就是采用的这种方式
工具类代码 /** * ip解析工具 * * @author zzt * @version v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a4a2758e7deb3c7fe57d8dbeefa5d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b4503bd8e1e5712d883e38d118b9a9/" rel="bookmark">
			理解和创建Windows和Linux下的动态和静态库区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 在计算机编程的世界中，库是一个非常重要的改变。它的出现提供了一种共享和重用代码的可能性，复杂的程序因为动态库的出现而变得简洁和方便。然而，库并不是单一的：它们可以是动态的，也可以是静态的，每一种类型都有其使用场景。在本文中，我们将深入探讨动态库和静态库的概念，每种类型都有其优点和使用场景。讨论的范围将会集中两种最为常见的平台——Windows和Linux，主要内容还是帮助读者创建一个在自己平台下使用的动态库。
二、静态库和动态库基础知识 在顺利创建并使用动态库之前，让我们先来了解一下关于这两个库的概念。
2.1 动态库 动态库在程序实际运行时才会被加载到内存，多个程序可以共用这个动态库；Windows动态库以.dll结尾，而在Linux下则以.so结尾，其优点在于：
节省内存。多个程序如果使用到了同一个动态库，仅需加载一次内存，从而达到节省内存的作用；模块化设计。动态库是一个模块化设计，每个库专注其特定的功能，增加了代码的可读性和维护性；简化更新和修复过程：因为是运行时才加载，如果符号保持不变，更新功能只需要替换掉原来的动态库即可；剥离常用函数，使得维护变得容易。这一个和模块化不同，模块化的功能单一，而剥离这个功能，主要是为了维护不同功能；跨语言兼容。不同语言也可以通过动态库使用对应的功能，使得其变得与语言无关；降低磁盘空间。同一个功能只需要存储一份动态库，而不需要每个程序都带有相应的代码段； 2.2 静态库 静态库在程序进行编译之时就被链接到程序中，每个程序都独占这部分功能代码。Windows中以.lib结尾，而Linux则以 .a结尾。一般而言[1]，静态库含有对应功能的所有实现，其优点在于：
独立性。静态库被链接到应用程序，将内容直接“注入”应用程序，不再需要存放着内容的动态库.dll，程序的部署和分发变得简单，无需担心目标系统是否具有对应的动态库；兼容性。版本冲突基本上不会出现，因为每个程序在编译之时就已经完成了版本冲突检查，如果有兼容性问题，编译器就被暴露出来了；性能。使用静态库的应用程序无需在运行时进行加载，降低了程序开销；安全性。静态库在编译时已经确定，攻击者更加难以通过替换库中的函数进恶意程序注入；（这就是为什么破解替换动态库就可以完成，大概率是因为替换掉了验证部分函数） 下面是一张比较动态库和静态库优缺点的表格：
动态库静态库优点1. 节省内存 2. 支持模块化设计 3. 代码重用 4. 简化更新和修复过程 5. 跨语言兼容性 6. 减少磁盘空间的使用1. 独立性 2. 兼容性 3. 性能 4. 安全性缺点1. 可能导致版本冲突 2. 运行时需要加载和链接库，可能影响性能1. 如果库代码更新，所有使用此库的程序都需要重新编译和链接 2. 程序文件大小通常比动态链接的程序更大 三、Windows下动态库和静态库的创建 3.1 如何创建一个动态库？（VS2022为例） 新建一个项目，选择Dynamic-Link Library(DLL)，VS自动帮我们写了工程配置和部分用于优化的代码。对应源代码和头文件：
#include "pch.h" #include "addition.h" int AddNumbers(int a, int b) { return a + b; } #ifndef ADDITION_H #define ADDITION_H __declspec(dllexport) int AddNumbers(int a, int b); #endif 在Windows平台上，默认情况下，函数和变量不会被自动导出为动态链接库（DLL）的一部分。如果你想要将函数或变量导出为DLL可见的导出项，需要显式地使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b4503bd8e1e5712d883e38d118b9a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420e0897549dc6aa7ef846b32a97c4ee/" rel="bookmark">
			[SpringBoot]Spring Security框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于Spring Security框架
Spring Security框架的依赖项
Spring Security框架的典型特征
关于Spring Security的配置
关于默认的登录页
关于请求的授权访问（访问控制）
使用自定义的账号登录
使用数据库中的账号登录
关于密码编码器
使用BCrypt算法
关于伪造的跨域攻击
使用前后端分离的登录
关于认证的标准
未通过认证时拒绝访问
识别当事人（Principal）
实现根据权限限制访问
补充解释（关于使用resultMap标签）：
基于方法的权限检查
添加Token 首先添加Token-JWT的依赖项：
生成JWT：
解析JWT
补充：
在项目中使用JWT识别用户的身份
核心流程
验证登录成功时响应JWT
解析客户端携带的JWT
我们这次选择去继承Spring系列框架提供的OncePerRequestFilter这个类。
关于认证信息中的当事人
处理解析JWT时的异常
处理复杂请求的跨域问题
单点登录
关于Spring Security框架 Spring Security框架主要解决了认证与授权相关的问题。 认证信息（Authentication）：表示用户的身份信息
认证（Authenticate）：识别用户的身份信息的行为，例如：登录
授权（Authorize）：授予用户权限，使之可以进行某些访问，反之，如果用户没有得到必要的授权，将无法进行访问
Spring Security框架的依赖项 在Spring Boot中使用Spring Security时需要添加spring-boot-starter-security依赖。 Spring Security框架的典型特征 当添加了spring-boot-starter-security依赖后，在启动项目时执行一些自动配置，具体表现有：
所有请求（包括根本不存在的）都是必须要登录才允许访问的，如果未登录，会自动跳转到框架自带的登录页面（1.项目重启之后需要重新登录，2.原来想去的页面会要求登录，登录完成之后回到原来的位置）
当尝试登录时，如果在打开登录页面后重启过服务器端，则第1次的输入是无效的 默认的用户名是user，密码是在启动项目是控制台提示的一段UUID值，每次启动项目时都不同(同一时空的唯一性，即同一时间同一空间的值都不同)
UUID是通过128位算法（运算结果是128个bit）运算得到的，是一个随机数，在同一时空是唯一的，通常使用32个十六进制数来表示，每种平台生成UUID的API和表现可能不同，UUID值的种类有2的128次方个，即：3.4028237e+38，也就是340282366920938463463374607431768211456
当登录成功后，会自动跳转到此前尝试访问的URL
当登录成功后，可以通过 /logout 退出登录
默认不接受普通POST请求，如果提交POST请求，将响应403（Forbidden）
关于Spring Security的配置 在项目的根包下创建config.SecurityConfiguration类，作为Spring Security的配置类，此类需要继承自WebSecurityConfigurerAdapter，并重写void configure(HttpSecurity http)方法，例如：
@Slf4j @Configuration public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { // super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420e0897549dc6aa7ef846b32a97c4ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a9043a03b2b9063e437623e460b5ca/" rel="bookmark">
			更新 deployment 解决 field is immutable 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 在执行./deploy.sh -s | kubectl apply -f -升级CoreDNS过程中，如果遇到以下提示：
The Deployment "coredns" is invalid: spec.selector: Invalid value: v1.LabelSelector{MatchLabels:map[string]string{"app.kubernetes.io/name":"coredns", "k8s-app":"kube-dns"}, MatchExpressions:[]v1.LabelSelectorRequirement(nil)}: field is immutable 问题分析 则是因为原来CoreDNS的.spec.selector字段与./deploy.sh -s产生yaml的.spec.selector字段一致，所以产生此错误。因为在 apps/v1版本中，Deployment 创建后 .spec.selector 是不可变的。所以需要将旧与新yaml的.spec.selector字段相同才可以更新。
解决方法 方法有两种：
./deploy.sh -s产生yaml导出到文件中，把.spec.selector改成与原来相同的内容。同时.spec.selector必须能够匹配到.spec.template.metadata.labels，否则请求会被 API 拒绝。同时需要修改Service下的.spec.selector，要与.spec.template.metadata.labels一样。删除原来的CoreDNS这个deployment，直接创建新的CoreDNS。 参考：https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#selector
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b18fde927125dd3ef3d3c45f5ed58e0/" rel="bookmark">
			Nacos认证绕过漏洞修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos认证绕过漏洞修复 1 漏洞描述及复现1.1 漏洞描述1.2 漏洞复现 2 漏洞修复3 修复后验证 1 漏洞描述及复现 1.1 漏洞描述 Nacos 官方在 github 发布的 issue 中披露 Alibaba Nacos 存在一个由于不当处理 User-Agent 导致的认证绕过漏洞。通过该漏洞，攻击者可以进行任意操作，包括创建新用户并进行登录后操作。
1.2 漏洞复现 请求头设置User-Agent，值为Nacos-Server，那么不需要认证，就可以随意创建用户，比如，访问http://ip:port/nacos/v1/auth/users?username=xxx&amp;password=xxx，如下图，用户创建成功：
或者访问http://ip:port/nacos/v1/auth/users?pageNo=1&amp;pageSize=10，也可以查询到已创建的用户信息。
2 漏洞修复 编辑nacos的配置文件（ /&lt;nacos安装目录&gt;/conf/application.properties ），修改以下配置信息并保存：
nacos.core.auth.enabled=true nacos.core.auth.enable.userAgentAuthWhite=false nacos.core.auth.server.identity.key=serverIdentity nacos.core.auth.server.identity.value=security 保存后，重启nacos。
如果项目中没有配置nacos的用户名密码信息，会影响服务，配置过的可忽略。如springboot的配置文件中，需要配置nacos的用户名及密码信息：
spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 username: nacos password: nacos 3 修复后验证 修复之后，再次访问，如下，显示403，则漏洞修复成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca93db96641f5f81c2bd32d9379efe8/" rel="bookmark">
			彻底搞懂浏览器和node.js中的this指向问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		彻底搞懂JavaScript中的this指向问题！ 之前遇到this指向问题总是一知半解，今天花了一些时间深入了解了一下，接下来我会把我的理解通俗易懂的讲出来，希望以后大家都能明白this指向。
首先搞明白this的定义：this为代码运行时所处的环境！本质上所有的函数都是通过对象调用，所以最终是谁调用的函数，函数内部的this就是谁。
this在浏览器中的指向 node.js中大部分的指向和普通运行环境一致，所以此处先说明大部分情况，最后node.js差异部分单独说明。 1.普通函数的this指向他的调用者
let name='window' let obj={ name:'obj' getName:function() { console.log('getName:',this.name) } } obj.getName()	//getName:obj 2.箭头函数的this:箭头函数没有自己的this，所以指向定义时所在环境
var name='window' let obj={ name:'obj', getName:()=&gt; { console.log('getName:',this.name) } } obj.getName()	//getName：window 可以看到此处getName声明为箭头函数，函数体中的this定义时的调用者环境，即obj所处环境的this（window对象），可以简单理解为：对比普通函数来说，箭头函数指向他外层的this（普通函数的this的外一层this）。
3.定时任务，setTimeout，无论是否为箭头函数，this都指向的是window，因为定时任务是浏览器调用的，所以指向最顶层的window对象。
let name='window' setTimeout(function() { console.log('getName:',this.name)	//getName:window }, 200); let name='window' setTimeout(()=&gt; { console.log('getName:',this.name)	//getName:window }, 200); 4.构造函数的this指向他的构造对象
function user() { this.name='name' this.id=00000000 } let lucy=new user(); console.log('name:',this)	//name: user {name: 'name', id: 00000000} 值得注意的一点是：如果构造函数返回体中return非对象类型，则构造函数创建的实例对象不变，否则会发生改变
function user() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca93db96641f5f81c2bd32d9379efe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542fb6de9b656c851e6802eb7c04bd8a/" rel="bookmark">
			Prettier &#43; Vetur 进行Vue2项目代码格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prettier 是一个代码格式化工具，它可以支持 js/jsx/ts/flow/json/css/less/scss 等文件格式。 为什么要使用 Prettier？ 用来替代 lint 中的一些场景，比如说分号/tab缩进/空格/引号，这些在lint工具检查出问题之后还需要手动修改，而通常这样的错误都是空格或者符号之类的，这样相对来说不太优雅，利用格式化工具自动生成省时省力。
安装插件 1. 在 VSCode 的扩展搜索 Prettier - Code formatter 和 Vetur 插件并进行安装。
Vetur 是 Vue 专用插件，Prettier 格式化后的 template 排版真是丑，所以 Vue 相关的格式化我们用专业的 Vetur。
2. 创建 Prettier 配置文件
在项目根目录新建 .prettierrc 文件：
{ "printWidth": 100, // 单行代码字符数量最长100，超过自动折行 "tabWidth": 2, // tab使用2个空格 "singleQuote": true, // 单引号 "trailingComma": "es5", // 默认none, 可选 none|es5|all。es5 包括es5中的数组、对象最后一个元素后会加逗号, all 包括函数对象等所有可选 "bracketSpacing": true, // 对象左右两侧都需要空格 "semi": true, // 是否在行尾加分号 "arrowParens": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542fb6de9b656c851e6802eb7c04bd8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39e5be7b4c788a09673064b5dcc0ba0/" rel="bookmark">
			MATLAB 之 线性方程组求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、线性方程组求解1. 线性方程组的直接解法1.1 利用左除运算符的直接解法1.2 利用矩阵的分解求解线性方程组 2. 线性方程组的迭代解法2.1 Jacobi 迭代法2.2 Gauss-Serdel 迭代法 3. 求线性方程的通解 一、线性方程组求解 在 MATLAB 中，关于线性方程组的解法一般分为两类：一类是直接法，就是在没有舍入误差的情况下，通过有限步的矩阵初等运算来求得方程组的解；另一类是迭代法，就是先给定一个解的初始值，然后按照一定的迭代算法进行逐步逼近，求出更精确的近似解。 1. 线性方程组的直接解法 线性方程组的直接解法大多基于高斯消元法、主元素消元法、平方根法和追赶法等。在 MATLAB 中，这些算法已经被编成了现成的库函数或运算符，因此，只需调用相应的函数或运算符即可完成线性方程组的求解。 1.1 利用左除运算符的直接解法 线性方程组求解最简单的方法就是使用左除运算符 \，系统会自动根据输入的系数矩阵判断选用哪种方法进行求解。对于线性方程组 A x = b Ax=b Ax=b，可以利用左除运算符 \ 求解： x = A ∖ b x=A\setminus b x=A∖b当系数矩阵 A A A 为 N × N N×N N×N 的方阵时，MATLAB 会自行用高斯消元法求解线性方程组。若右端项 b b b 为 N × 1 N×1 N×1 的列向量，则 x = A ∖ b x=A\setminus b x=A∖b 可获得方程组的数值解 x x x（ N × 1 N×1 N×1 的列向量）。若右端项 b b b 为 N × M N×M N×M 的矩阵，则 x = A ∖ b x=A\setminus b x=A∖b 可同时获得系数矩阵 A A A 相同的 M M M 个线性方程组的数值解 x x x（为 N × M N×M N×M 的矩阵），即 x ( : , j ) = A ∖ b ( : , j ) , j = 1 , 2 , … , M x(:,j)=A\setminus b(:,j), j=1, 2, …, M x(:,j)=A∖b(:,j),j=1,2,…,M。这里需要注意的是，如果矩阵 A A A 是奇异的或接近奇异的，则 MATLAB 会给出警告信息。例如，我们用直接解法求解下列线性方程组。 { 2 x 1 + x 2 − 5 x 3 + x 4 = 13 x 1 − 5 x 2 + 7 x 4 = − 9 2 x 2 + x 3 − x 4 = 6 x 1 + 6 x 2 − x 3 − 4 x 4 = 0 \left\{\begin{matrix}2x_{1}+x_{2}-5x_{3}+x_{4}=13 \\x_{1}-5x_{2}+7x_{4}=-9 \\2x_{2}+x_{3}-x_{4}=6 \\x_{1}+6x_{2}-x_{3}-4x_{4}=0 \end{matrix}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39e5be7b4c788a09673064b5dcc0ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd1e8ce808621047923a3b1e42f7b26/" rel="bookmark">
			一文看懂python如何执行cmd命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 “ 在进行Python编程时，经常需要使用到操作系统的命令行，这就要求我们学会如何使用Python执行cmd命令。”
Python执行cmd命令的几种方法 Python是一种强大而灵活的编程语言，它可以很方便地执行系统命令，与操作系统进行交互。本文将介绍Python执行cmd命令的几种常用方法，以及它们的优缺点和使用场景。
1. 使用os模块的os.system()函数 os模块是Python标准库中的一个模块，它提供了一些与操作系统相关的函数和变量。其中，os.system()函数可以将字符串转化成命令在服务器上运行，返回值是命令的退出状态码，0表示成功，1表示失败，256表示没有返回结果。例如：
import os a = os.system("ping 192.168.1.101") # 使用a接收返回值 print(a) 这种方法的优点是简单易用，不需要额外的模块导入。缺点是无法获取命令的输出内容，只能获取返回值；而且每次执行命令都会创建一个新的子进程，在资源消耗上比较大。
2. 使用os模块的os.popen()函数 os.popen()函数也是os模块中的一个函数，它可以通过管道的方式来执行系统命令，返回值是一个文件对象，可以读或者写。如果需要读取输出内容，可以调用read()或readlines()方法。例如：
import os a = os.popen("ipconfig") # 使用a接收返回值 print(a.read()) # 读取输出内容 这种方法的优点是可以获取命令的输出内容，并对其进行处理；缺点是无法获取命令的返回值，而且也会创建新的子进程。
3. 使用subprocess模块 subprocess模块是Python从2.4版本开始引入的模块，主要用来取代一些旧的模块方法，如os.system、os.spawn、os.popen、commands.*等。官方推荐使用该模块执行系统命令，subprocess模块通过子进程来执行外部指令，并通过input/output/error管道，获取子进程的执行结果。常用的函数有subprocess.Popen()、subprocess.call()、subprocess.run()等。
3.1 使用subprocess.Popen() 使用Popen可以创建进程，并与进程进行复杂的交互。它接受一个命令或者一个命令列表作为参数，并返回一个Popen对象。通过调用Popen对象的communicate()方法可以获取输出和错误信息。例如：
import subprocess # 使用Popen创建进程，并与进程进行复杂的交互 proc = subprocess.Popen( 'ipconfig', # cmd特定的查询空间的命令 stdin=None, # 标准输入 键盘 stdout=subprocess.PIPE, # -1 标准输出（演示器、终端) 保存到管道中以便进行操作 stderr=subprocess.PIPE, # 标准错误，保存到管道 shell=True) outinfo, errinfo = proc.communicate() # 获取输出和错误信息 print(outinfo.decode('gbk')) # 外部程序 (windows系统)决定编码格式 print(errinfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbd1e8ce808621047923a3b1e42f7b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c602ed9dae812d5f3ce378edde416d/" rel="bookmark">
			Task Add-in Sample (C#)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下例显示了用 C# 编写Task Add-in 的完整源代码。 使用 C# 类库 （.NET Framework） 创建 Visual Studio 中的项目。实现 IEdmAddIn5。在“任务属性”对话框中创建自定义页。自定义任务详细信息页面。 注意： 若要填充下面的 GUID 属性，请在 IDE 中单击“工具”&gt;“创建 GUID”，选择“GUID 格式 5”，单击“复制”，然后单击“退出”。用复制的字符串替换 [Guid("")]。
启动VS。新建项目，选择类库。 在“解决方案资源管理器”中右键单击项目名称 ，然后单击添加引用。 在 左侧面板单击 浏览 ，选择EPDM.Interop.epdm，然后单击添加。
如果需要，引入相关的程序集。在“解决方案资源管理器”中右击项目名称，然后单击“属性”。 “应用程序&gt;程序集信息”。 取消勾选“使程序集 COM 可见（M）”。 修改Class1.cs。这里修改类名为TaskAddin.cs。 添加和创建GUID。修改代码 using System; using System.Runtime.InteropServices;//添加 using System.Windows; using EPDM.Interop.epdm; namespace Task_Add_in { [Guid("6EC3D9F8-D202-45A5-8F12-3EB5DED97A7E"), ComVisible(true)] public class TaskAddin : IEdmAddIn5 { } } 对EdmCmdType.EdmCmd_TaskSetup、EdmCmd_TaskSetupButton、EdmCmd_TaskRun、EdmCmd_TaskDetails进行处理 using System; using System.Runtime.InteropServices;//添加 using System.Windows; using EPDM.Interop.epdm; namespace Task_Add_in { [Guid("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c602ed9dae812d5f3ce378edde416d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2dcb2af1ac9e92f6edd490ccfa7a79/" rel="bookmark">
			python - 爬取证券信息并填入excel做处理 （打包后项目依旧能够对相对路径文件做处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 单功能分块实现并做好注释没有学过python但能明显感觉代码是很垃圾的，仅做学习备份没有设计ui界面 可参考地方 对于python项目打包后，依然能够实现对相对路径文件做处理获取tushare数据对单excel内多表格进行访问和处理使用sqlite3轻量数据库 - 项目做了mysql数据库到sqlite数据库的迁移，使得打包后的exe文件不需要其他依赖 不足之处 没能做好虚拟环境的管理，导致打包后的文件大小偏大
代码 # This is a sample Python script. # Press Shift+F10 to execute it or replace it with your code. # Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings. import sys try: import pymysql from openpyxl import load_workbook import tushare as ts from datetime import datetime, timedelta import os import re import pandas as pd import sqlite3 current_dir = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2dcb2af1ac9e92f6edd490ccfa7a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a63924255f0951919397c761b308cc6/" rel="bookmark">
			Java设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java设计模式 单例模式 什么是单例模式 每使用一次new关键字创建一个对象，就在内存中新增加一个内存地址，如果创建的次数多了，那可是很耗费内存空间的。单例模式就是来解决这样的问题的，单例模式保证一个对象在程序中只创建一次，那么在内存中也就只有一份。
单例模式简单来说就是保证某一个类在程序中只实例化一次，以后调用这个类时始终是指向同一个内存地址的类。
单例模式的分类 单例模式的创建分为懒汉式、饿汉式两种模式。饿汉式就是当类以加载时就创建这个的实例，懒汉式是当第一次调用时才会创建这个类的实例；
饿汉式 public class StudentSingle1 { private static final StudentSingle1 studentSingle1 = new StudentSingle1(); private StudentSingle1() { } public static StudentSingle1 getInstance() { return studentSingle1; } } 懒汉式 懒汉式只有在使用时才创建对象，而且只创建一次。在懒汉单例模式中如果只是使用if语句来判断对象是否创建，那么会出现线程安全问题；
多线程不安全 // 多线程不安全 public class StudentSingle2 { private static StudentSingle2 studentSingle2; private StudentSingle2() { } public static StudentSingle2 getInstance() { if (studentSingle2 == null) { /** * 线程1执行到这里时,cpu切换线程2也执行到这里， * 此时的线程被1迫暂停， * 线程2创建对象后,线程1开启创建对象,创建了两个对象 * 这样就出现多线程安全问题 */ studentSingle2 = new StudentSingle2(); } return studentSingle2; } } 多线程安全 双重判断：也就是进行两次判断，但在进第二次判断时会采用synchronized来进行线程排队，会影响一定的性能；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a63924255f0951919397c761b308cc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5dfe702bb63753ee0d764d747e5f629/" rel="bookmark">
			怎么在命令行里运行python脚本 （合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在命令行里运行python脚本的方法
工具/原料
python;CMD命令行;windows操作系统
方法/步骤
首先下载安装python，建议安装2.7版本以上，3.0版本以下，由于3.0版本以上不向下兼容，体验较差。
打开文本编辑器，推荐editplus，notepad等，将文件保存成 .py格式，editplus和notepad支持识别python语法。
脚本第一行一定要写上 #!usr/bin/python
表示该脚本文件是可执行python脚本
如果您的python目录不在usr/bin目录下，则替换成当前python执行程序的目录
编写完脚本之后注意调试、可以直接用editplus调试。调试方法可自行百度。脚本写完之后，打开CMD命令行，前提是python 已经被加入到环境变量中，如果没有加入到环境变量，请百度
在CMD命令行中，输入 python + 空格，即 python ;
将已经写好的脚本文件拖拽到当前光标位置，然后敲回车运行即可
python如何配置环境变量
python如何配置环境变量
方法/步骤
选中我的电脑，按快捷键，弹出计算机系统属性的窗口。
在计算机系统右侧导航栏中选择高级系统设置，弹出对话框。
在系统属性对话框的高级选项卡中单击环境变量按钮。
此时弹出环境变量对话框，在系统变量里选择 Path 进行编辑。
在编辑系统变量中变量值增加一项为Python的安装目录。
快捷键运行 cmd，进入命令行提示符，打开命令行。
其中输入python，出现python的版本信息，配置环境变量成功。
python调用外部exe程序
python调用外部exe程序
工具/原料
python3
exe程序
方法/步骤
使用python自带的subprocess库。
导入库(很简单)。
指定外部exe程序的路径。并指定传入参数，注意使用二进制格式传入。
这一步很关键。subprocess的Popen方法有很多的参数，对于初学者而言，不必深究。这里我以 后缀表达式的转换程序为例。传入参数为字符串，传出也是字符串。两个进程建立pipe管道通信。请仔细体会参数的使用。p.communicate()方法返回的是元组，可根据自己需求选取元素。该方法同时传入参数，input=，就是传参。
程序运行，显示出exe程序执行的结果。相关结果已经处理，去掉不需要的部分，并且转换成字符串格式。
win10系统怎么安装python win10系统安装python的方法
先到python的官方网站下载软件，打开官网后，选择downlad项目，然后选择需要下载的大版本，2.7还是3.4。
选择完版本后，进入后一个页面，在这个页面可以选择操作系统及对应的版本，win下注意分64位和32位版本，不要下错了。
32位的程序大约为17.5M，建议非官网下载的还是要比对下MD5以防万一，在上一个页面就有MD5值。核对完成后双击安装，首先是询问是为所有用户还是为当前用户安装，用缺省的就行。
下一步后是选择安装目录，这个看个人喜好了，不过还是要记一下目录，因为缺省的代码也会放在这个目录下。
下面继续缺省配置选择就开始安装了，python在安装过程中要执行一些角本，因些需要至少有system的权限才可以安装。
安装完成，但在win10在任务栏和桌面上都未生成图标，使用起来麻烦些，在开始窗口打开所有应，按字母找到python程序项，右键选择固定在任务栏或屏幕。
Windows下Python环境的配置和Dos界面的调用
Windows下Python环境的配置和Dos界面的调用
工具/原料
python2.7
方法/步骤
没有设置环境变量的时候，在dos下输入python，效果如下：
然后，点击我的电脑的属性，进入系统面板。
然后在右上角找到高级系统设置，
然后选择右下角的环境变量，如下图步骤，将python的exe所以在路径添加到系统变量的PATH中
进行上述修改之后，还是只能通过python*.py运行python运行再修改领一个环境变量
PATHEXT：
PATHEXT=PATHEXT;.PY;.PYM
然后这时候，在dos界面输入python，会进入python编辑的页面，如下：
对于一般的python代码运行，我们直接在dos中输入python *.py便可运行。
有时候有些python程序不适合上面的方法，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5dfe702bb63753ee0d764d747e5f629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68832e2009c75e2d96f7b293714d005/" rel="bookmark">
			百度翻译API使用教程（前端&#43;后端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.资格获取 首先我们需要登录百度翻译开放平台，获取开发者资格：
访问
百度翻译开放平台
然后进行注册（如果有百度账号的话可以直接登录）
注册成功后点击“产品服务”：
跳转到通用文本API界面：
在页面底部点击“立即使用”即可选择服务进行使用
通用文本API有三种服务可供选择：
个人用户可以使用前两种，高级版的使用需要个人认证（实名认证）
2.简单使用 点击“管理控制台”，打开“开发者信息”界面：
即可看到你的APP ID和密钥信息，在调用接口的时候需要用到；
点击“我的服务”中的通用文本翻译，即可看到服务使用情况及明细
如果对于翻译的术语有特殊要求，可以点击“我的语料库”，并新建术语库：
这样我们设置的术语即可干预翻译结果；
3.编程实现 百度翻译开放平台
前往以上网址查看通用翻译API的开发文档
3.1 前端代码 开发环境：Vue.js + Uniapp
（uniapp快速上手：uni-app官网）
通过一个文本输入框接受输入内容，然后调用后端接口，进行翻译：
&lt;template&gt; &lt;view&gt; &lt;!--输入框--&gt; &lt;uni-easyinput type="textarea" v-model="translate_source" placeholder="请输入想要翻译的内容" suffixIcon="search" borderColor="grey" @input="input"&gt;&lt;/uni-easyinput&gt; &lt;!--翻译按钮--&gt; &lt;button type="primary" class="translate_button" @click="translate"&gt;开始翻译&lt;/button&gt; &lt;!--翻译内容展示--&gt; &lt;view style="margin-top: 50rpx;"&gt; &lt;uni-section title="翻译内容如下:" type="line" class="translate_line"&gt; &lt;view class="translate_answer"&gt; &lt;textarea disabled="true" :value="translated_content"&gt;&lt;/textarea&gt; &lt;/view&gt; &lt;/uni-section&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { translate_source:"", translated_content:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d68832e2009c75e2d96f7b293714d005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4b41491a87f84fa77c12831973c649/" rel="bookmark">
			AI-Prompt 1.0 版简介&amp;公测！你的AI提示词网站！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示词（Prompt） 是什么？
在 AI 大模型中，一个 prompt 是一个输入文本，用于触发模型生成输出。例如，当我们向一个 AI 大模型提交需求时，我们的需求就是一个 prompt。
在介绍产品之前，我们先简单重申一下 Prompt 为什么有用？
首先，研究显示一个 Prompt 的信息量相当于100个真实数据样本，这清楚地展示了 Prompt 所包含的巨大信息量。(https://arxiv.org/abs/2103.08493)
其次，在下游任务中，尤其是在数据稀缺或零样本场景中，Prompt 具有无与伦比的优势。由于大型模型通常难以在少量数据上进行微调，因此，基于 prompt 的微调技术成为了首选方法。
大佬们对于 Prompt 的看法
ChatGPT之父 Sam Altman:“编写一个非常出色的聊天机器人角色 Prompt 是一个惊人的高杠杆技能，也是早期自然语言编程的一个例子”
​
百度李彦宏：“我做一个大胆预测：10年后全世界所有工作当中50%的内容恐怕是写 Promt”
吴恩达教授：“使用 Prompt 来开发模型, 只需要花费几分钟到几个小时。”
以下为正文
我们认为，新的时代已经开始。
ai-prompt.cn —— 一切，从提出问题开始！
🚀 提示词编辑器
提示词编辑器用于编写各种类型的提示词，目前支持图像提示词和聊天提示词
图像提示词中胶囊左侧工具集内可提供权值的修改
​
编辑
切换为居中
添加图片注释，不超过 140 字（可选）
编辑区右侧可以点击“中英文对照”按钮决定使用中文或英文 ​
编辑区右侧可以点击“中英文对照”按钮决定使用中文或英文
胶囊右侧内容区域可展示元信息的详情和英文对照信息
编辑区右侧可以点击“添加空胶囊”按钮创建一个空的胶囊，如果你想用工具集里面的内容，这会是一个不错的功能
编辑区右侧可以点击“记点”按钮记住创作好的 Prompt
下方目前接入 Midjourney 的可视化选项配置，后续会接入其它大模型的配置（如果有）
右侧为 Prompt 结果区域，当我们创作好 Prompt 后可以在右侧看实际会发送给大模型的 Prompt，点击复制即可。
元信息——期望AIGC生成内容的信息描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d4b41491a87f84fa77c12831973c649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf00fa2d65c09a87f6605763f4fcf640/" rel="bookmark">
			Flowable工作流入门&amp;完整SpringBoot案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 、Flowable 的出现是为了什么二、Flowable 的优势三、常见的Java类/实例3.1 ProcessEngine3.2 RepositoryService3.3 ProcessDefinition3.4 Deployment3.5 RuntimeService3.6 ProcessInstance3.7 TaskService3.8 JavaDelegate3.9 其他 四、核心数据库表4.1 数据库4.2 通用数据表（2个）4.3 历史表（8个，HistoryService接口操作的表）4.4 用户相关表（4个，IdentityService接口操作的表）4.5 流程定义、流程模板相关表（3个，RepositoryService接口操作的表）4.6 流程运行时表（6个，RuntimeService接口操作的表） 五、在SpringBoot中简单使用5.1 Flowable入门之表的生成5.2 请假审批案例的实现5.2.1 项目结构5.2.2 application.yml5.2.3 holiday-request.bpmn20.xml5.2.4 HolidayRequestDTO5.2.5 HolidayRequestProcessService5.2.6 HolidayRequestProcessServiceImpl5.2.7 CallExternalSystemDelegate5.2.8 SendRejectionMail5.2.9 HolidayRequestProcessController5.2.10 运行&amp;结果展示 附录参考文章项目地址 一 、Flowable 的出现是为了什么 工作流（Workflow），是指对于一项业务，按照规定的流程，逐级传递、申请、执行等，并且受到了严格控制的一种业务过程。
BPM（Business Process Management）是指对于某项业务的整个生命周期进行全面管理的一种模式，最核心的内容包括了工作流、决策、交互等。在这些管理过程中，人员、系统等资源都是可以被自动调度的，以致达到更高效、完善的管理目的。
Flowable工作流是一款基于Java的轻量级开源工作流引擎，它支持BPMN2.0规范、CMMN规范，同时也提供REST API以及JavaAPI，支持Spring，Spring Boot等框架。借助Flowable工作流，企业可以快速构建出符合自己实际业务的工作流。
二、Flowable 的优势 1、轻量级：Flowable工作流是一款轻量级的工作流引擎，启动快、体积小，且可以嵌入Java应用中使用。
2、开放源代码：Flowable工作流是一个开源的工作流引擎，保证企业在使用过程中不会受到第三方的监控与限制。
3、商用友好：Flowable工作流允许企业在商业环境下进行使用，并且提供Flowable Task一类的额外服务。
三、常见的Java类/实例 3.1 ProcessEngine 流程引擎实例，线程安全，一般一个工作流只需要初始化一次。
代码示例见本文的 5.1 小节。
3.2 RepositoryService 可以通过流程引擎（ProcessEngine）获取到。使用RepositoryService可以根据xml文件路径创建一个新的部署（Deployment），并调用 Deployment#deploy() 实际执行。
代码示例如下（其中xml是放在src/main/resources中）：
RepositoryService repositoryService = processEngine.getRepositoryService(); Deployment deployment = repositoryService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf00fa2d65c09a87f6605763f4fcf640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbe06b1c6b6e1d48e94ca84cbf83ba1/" rel="bookmark">
			白嫖一年免费的亚马逊云服务器搭建小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.注册亚马逊云账户 地址：https://aws.amazon.com/cn/
一路下来资料照填，邮箱用QQ邮箱就行，地址邮箱编码什么的随便填填。需要注意的是，注册过程需要绑定信用卡，说好是免费的，怎么还要绑定信用卡扣费呢？所谓免费，就是在你没有用超的情况下。
2.创建AWS实例 登录控制台，这里可以选服务器的地址，在右上角导航栏上，搜索EC2，点击后进入EC2页面
进入后点击启动实例
勾选仅免费套餐，默认是Amazon Linux AMI，Linux系统，也可以选择Ubuntu什么的。
实例类型选择t2 micro，符合条件的免费套餐即可，接下来需要创建新密钥对
输入密钥对名称，后面配置默认，系统会自动把密钥对文件下载，例如key.pem
配置安全组的时候，默认只有SSH流量，建议先允许所有流量，开放所有端口，方便后续测试。
这个安全组配置创建完成还可以改的，担心不安全创建完可以再做修改。
之后就可以启动实例了
3.连接到服务器 如果你使用的是Windows，这一步参考亚马逊自己文档即可：putty链接服务器
Linux和Mac参考亚马逊的文档：SSH链接服务器
文档里的 instance-user-name 使用 ec2-user 即可，Amazon Linux AMI默认的是 ec2-user ，
instance-public-dns-name 使用 实例的 公有 DNS 既可以
示例：ec2-user@ec2-11-111-11-111.ap-northeast-1.compute.amazonaws.com
但是这样登录进去后，你并不是管理员的权限，无法修改文件，修改至root用户权限参考文档：
https://www.blog-china.cn/blog/liuzaiqingshan/home/10/1537109672890
1.在用密钥登陆ec2后，为root用户创建密码：
sudo passwd root 系统会让你输入两次密码
2.切换为root用户，并且编辑sshd_config文件，PasswordAuthentication no，把no改成yes。使系统允许密码登陆
su root 这样你就是root用户了
之后你就可以操作云服务器做一些你想做的事情了
4.调试——无法使用怎么办 1.打开防火墙
如果你的 VPS 有外部防火墙，请确保你已经开放了端口
测试端口是否能连接上：打开 https://ping.sx/check-port
Target 写你的 VPS服务器的 IP，Port 写服务端的端口，然后点击 Check。
如果 REACHABILITY 显示 Timeout，那是无法连接上端口
需要打开防火墙，对于亚马逊云来说，需要修改你的EC2实例的安全组规则，入站规则改为对所有流量开放
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9aa8bccdad6d18fcd01230359b18661/" rel="bookmark">
			【嵌入式学习-STM32F103-TIM-编码器接口】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编码器接口 本质手册编码器接口简介编码器接口基本结构工作细节和例子 编码器接口测速硬件接线图编程步骤实验现象测位置极性问题 测速度 代码main.cEncoder.cEncoder.hTimer.cTimer.h 本质 编码器测速相当于测频法测正交脉冲的频率，CNT计次，每隔一段时间取一次计次。高级，它是带方向的计次。
手册 编码器接口简介 通过定时器的编码器接口来实现自动计次。之前的代码是通过触发外部中断，然后在中断函数里手动进行计次。使用编码器接口的好处就是节约软件资源。对于频繁执行，操作简单的任务，一般设计一个硬件电路模块来自动完成。
使用定时器的编码器接口，再配合编码器，就可以测量旋转速度和旋转方向。编码器测速一般应用在电机控制的项目上。使用PWM驱动电机，再使用编码器测量电机的速度，然后再使用PID算法进行闭环控制。
编码器的工作流程：根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而只是编码器的位置、旋转方向和旋转速度
这是一个编码器，它有两个输出，一个是A相，一个是B相，然后接入到stm32，定制起的编码器接口，编码器接口自动控制定时器时基单元中的CNT计数器进行自增或自减。比如初始化后，CNT初始值为0，然后编码器右转，CNT就++，右转产生一个脉冲，CNT就加一次，比如右转产生10个脉冲停下来，那么CNT就由0自增到10，停下来。编码器左转，CNT就–，左转产生一个脉冲，CNT减一次，如编码器左转产生5个脉冲，CNT就在原来10的基础上自减5停下来。
正交编码器(输出两个相位相差90°的方波信号)一般可以测量位置，或者带有方向的速度值，它一般有两个信号输出引脚，一个是A相，一个是B相，当编码器的旋转轴转起来，A和B相会输出方波信号，转的越快，方波的频率就越高，所以方波的频率就代表了速度。取出任意一相的信号来测量频率，就能知道旋转速度。
方向：当正转时，A相提前B相90度，反转时，A相滞后B相90度。接口：一个带有方向控制的外部时钟
使用正交信号精度更高，AB相都可以计次，相当于计次频率提高了一倍，还可以加抗噪声电路。
首先把A相和B相的所有边沿作为计数器的计数时钟，出现边沿信号时，就计数自增或自减，自增或自减的计数方向由另一相的状态来决定。查下表即可。
编码器接口有两个输入端，分别要接到编码器的A相和B相，有两个网络标号分别写的是TI1FP1和TI2FP2
可以看出这个编码器接口的两个引脚，借用了输入捕获单元的前两个通道，所以最终编码器的输入引脚是定时器的CH1和CH2这两个引脚
信号的通路如下（与CH3和CH4无关 ），编码器接口使用CH1和CH2的输入捕获滤波器和边沿检测，但没有使用后面的是否交叉、预分频器和CCR寄存器
编码器接口的输出部分就相当于从模式控制器，去控制CNT的计数时钟和计数方向，如果出现了边沿信号，并且对应另一相的状态为正转，则控制CNT自增，否则控制CNT自减。
注意：72MHZ内部时钟（CK_PSC）和在时基单元初始化设置的计数方向(上图的+/-)并不会使用，因为此时计数时钟和计数方向都处于编码器接口托管的状态，计数器的自增和自减受编码器的控制
编码器接口基本结构 输入捕获的前两个通道，通过GPIO口接入编码器A、B相，通过滤波器和边沿检测极性选择，产生TI1FP1和TI2FP2，通向编码器接口，编码器接口通过预分频器控制CNT计数器的时钟，同时，编码器接口还根据编码器的旋转方向，控制CNT的计数方向，编码器正转时，CNT自增，编码器反转时，CNT自减，ARR有效，一般我们设置ARR为65535，最大量程。补码：65535对应-1，依此类推（读出数据，得到负数的技巧）
工作细节和例子 在两相边沿计数，计数精度高（一般使用该模式）
正转
正转的状态都向上计数，反转的状态的都向下计数。
实例图1（向上计数、向下计数、正交编码器抗噪声）
如果出现了一个引脚不变，另一个引脚连续跳变多次的毛刺信号，计数器就会加、减、加、减来回摆动，最终计数值还是原来那个数，并不受毛刺噪声的影响。正交编码器抗噪声的原理
实例2（TI1反相，TI2不反相）极性
编码器接口测速 硬件接线图 计划用TIM3接编码器，所以需要接在PA6和PA7这两个引脚上。
编程步骤 第一步，RCC开启时钟，开启GPIO和定时器的时钟
第二步，配置GPIO，将PA6和PA7配置成输入模式
第三步，配置时基单元，这里预分频一般选择不分频
第四步， 配置输入捕获单元，只需要配置滤波器和极性两个参数
第五步，配置编码器接口模式
最后，调用TIM_Cmd启动定时器
电路初始化完成后，CNT就会随着编码器旋转而自增自减，如果想要测量编码器的位置，直接读出CNT的值即可，如果想要测量编码器的速度和方向，那就需要每隔一段固定的闸门时间，取出CNT，然后把CNT清零。
上拉输入还是下拉输入的选择
一般可以看一下接在这个引脚的外部模块输出的默认电平，如果外部模块空闲默认输出高电平，我们就选择上拉输入，默认输入高电平，如果外部模块默认输出低电平，我们配置下拉输入，默认输入低电平。总结，将需要配置电平的位置和外部模块保持默认状态一致，防止默认电平打架。
如果不确定外部模块输出的默认状态或者外部信号输出功率非常小，这时尽量选择浮空输入，浮空输入没有上下拉电阻去影响外部信号，缺点是当引脚悬空时，没有默认电平，输入就会受噪声干扰，来回不断跳变。
实验现象 测位置 A、B相各出现了一个下降沿和上升沿，所以计次总共加了4次。
如果转到0，再往左转，0自减，计数器反向溢出，回到自动重装值，65535，然后继续往下减。
如果我们想让0自减为-1，直接把uint16_t类型强制转换成int16_t即可
极性问题 硬件方面：对换AB相接线即可
软件方面：通过修改两个输入通道的极性，把任意一个极性反转一下，方向就会反过来
测速度 如果想让编码器测速度，可以在固定的闸门时间读一次CNT，然后把CNT清零，此时CNT的值代表速度，单位是脉冲个数/S
代码 1、通过Delay实现闸门时间，如果程序没有其他东西，可以这么做
2、如果有其他东西，最好不要在主循环加入过长的Delay函数，这样会阻塞主循环的执行，比较好的方法时使用定时中断，这里的定时中断是每隔1s执行一次，可修改定时中断的时间，来调整闸门时间。
main.c #include "stm32f10x.h" // Device header #include "Delay.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9aa8bccdad6d18fcd01230359b18661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf39fc45a9a415c5ce14fd6ea987b82/" rel="bookmark">
			计算机视觉领域英文SCI期刊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉和模式识别领域的代表就是四大顶会了：ICCV、ECCV、CVPR、NIPS，还有就是难度最高的PAMI了，这些都让人望而生畏。那么除了这些耳熟能详的期刊和会议之外，还有哪些该领域的期刊呢？
下面我收集了一些该领域的代表性期刊，并介绍了他们的影响因子以及投稿难度和审稿周期。希望对大家有帮助吧，后期大家还有发现的可以留言，补充哦。
首先介绍计算机视觉领域的4个顶级代表性期刊吧。
(1) IEEE Transactions on Pattern Analysis and Machine Intelligence，IEEE模式分析与机器智能汇刊，简称PAMI，是IEEE最重要的学术性汇刊之一。在各种统计中，PAMI被认为有着很强的影响因子（2011年影响因子为4.9）和很高的排名。显然，这个期刊的中稿难度那是相当的大，一般先投中CVPR之后再加点东西投该期刊会比较好中一点。
(2) ACM Transactions on Graphics。美国计算机协会图形汇刊，简称TOG，该刊侧重于计算机图形的处理，影响因子在该领域也比较高，2011年为3.5。中稿的难度也极大，一般该刊对每年的SIGGRAPH(Special Interest Group for Computer GRAPHICS,计算机图形图像特别兴趣小组）会议论文全文收录。
(3) International Journal of Computer vision，该刊也是该领域的顶级期刊之一，相比于PAMI来讲，该刊侧重于理论的推导。2011年影响因子为3.7，中稿难度也相当大。
(4) IEEE Transactions on Image Processing，该刊也是图像处理领域的代表性期刊之一，相比于上面三个期刊来讲，该刊稍微低一点层次。2011年影响因子为3.042，中稿难度也比较大。审稿周期一年左右。
除了上述让人望而生畏的顶级期刊之外，我们再看看一般的期刊吧。
(1)Pattern recognition letters, 从投稿到发表，一年半时间;
(2)Pattern recognition 不好中，时间长;
(3)IEICE Transactions on Information and Systems， 作者中有一个必须是会员。收费高，审稿快。影响因子0.4;
(4)International Journal of Pattern Recognition and Artificial Intelligence ， 审稿周期一般6–12周，影响因子偏低，容易中;
(5)Computational Intelligence， 中等偏上，要求较高，杂志级别不错，关注人数偏少，比较冷门;
(6)information processing letters, 影响因子低0.5左右，接搞量大，容易发表，审稿周期一般3–6个月;
(7)Computer vision and image understanding, 9个月审稿期，平均投稿命中率20%，业内比较认可;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cf39fc45a9a415c5ce14fd6ea987b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da73d6a1125040541d80da2ab4622515/" rel="bookmark">
			java 泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、泛型概述和定义 泛型就是将 数据类型参数化，例如我们实现一个存储对象的容器时，并不是直接定义好只能存储一种类型，好的办法就是定义时将类型参数化，也就是泛型，在真实使用时再传入真正的参数，这种参数化类型可以用在类、接口和方法中，分别被称为 泛型类、泛型接口、泛型方法。
1、泛型类 类中成员为泛型的类称为泛型类。最典型的就是各种容器类，如：List、Set、Map等。定义语法如下：
class 类名称 &lt;泛型标识&gt; { private 泛型标识 变量名; ..... } } 其中的T表示类型参数，可以表示任何包装类型（基本类型不涉及泛型），这里的 T 就是泛型标识可以任意设置Java 常见的泛型标识以及其代表含义如下： T ：代表一般的任何类。 E ：代表 Element 元素的意思，或者 Exception 异常的意思。 K ：代表 Key 的意思。 V ：代表 Value 的意思，通常与 K 一起配合使用。 S ：代表 Subtype 的意思，文章后面部分会讲解示意。 public class FanXing &lt;T&gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return this.value = value; } } 当创建一个 Generic&lt; T &gt; 类对象时，会向尖括号 &lt;&gt; 中传入具体的数据类型。 public static void main(String[] args){ FanXing fanXing1 = new FanXing&lt;&gt;(); // 不传时相当于默认 Object 类型 FanXing fanXing2 = new FanXing(); // 同上 FanXing fanXing3 = new FanXing&lt;String&gt;(); FanXing fanXing4 = new FanXing&lt;Integer&gt;(); } 2、泛型接口 public interface 接口名&lt;泛型标识&gt; { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da73d6a1125040541d80da2ab4622515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d64399949f9d7aa00171b5755fcabdd/" rel="bookmark">
			计算机网络1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章计算机网络概述
一 填空题:
1在D实际5年代，计算机和通信技术的相互结合，为计算机网络的产生奠定了理论基础。
2从传输范围的角度来划分计算机网络，计算机网络可以分为局域网.
城域网和广域网。其中Intenet属于广域网。
3从资源共享的角度来定义计算机网络，计算机网络指的是利用 通信线
路将不同地理位置的多个独立的自治计算机系统连接起来以实现资源共
享的系统。
4 从逻辑功能上，计算机网络可以分成资源子网和通信子网两个部分。
5APPAnet的诞生是计算机网络发展历史中的一个里程碑事件，为Intenet
的形成奠定了理论和技术的基础。
6 局域网的主要技术要素包括网络拓扑、传输介质和介质访问控制方法。
7hternet是由分布在世界各地的计算机网络借助于路由器相互连接而形
成的全球性互联网。
8在通信技术中，通信信道的类型有两类:点对点式和广播式。在点对
点式通信信道中，一条通信线路只能连接一对结点。而在 广播式通信信
道中，多个结点共享一个通信信道，一个结点广播信息，其他结点必须接收信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b666ac5f312655e31bf174ba1887300/" rel="bookmark">
			ESXI安装MacOS系统，VMware安装MacOs系统，MacOs10.14.iso下载，MacOS10.13下载，MacOS10.12下载，unlocker下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESXI安装MacOs系统 一、用到的工具和软件系统版本一、用到的工具二、需要用到的安装包 二、安装过程1.连接远程ESXI服务器2.上传iso文件和几个文件到ESXI服务器3.给VmWare打补丁，支持安装MacOS虚拟机4.给MacOS虚拟安装VmWare Tools 一、用到的工具和软件系统版本 一、用到的工具 ESXI 6.5.0VMware Workstation 15 Pro 15.5.0
自己本机装的一个，可以"连接远程服务器"方便远程操控ESXI 二、需要用到的安装包 MacOs镜像 要ISO格式的镜像,下面提供三个ISO镜像，随意使用。 macOS.Mojave10.14版本(本人使用的就是当前版本)
链接：https://pan.baidu.com/s/1PC98hV-urGjZnwT3v8pr-A
提取码：vepy
macOS High Sierra 10.13版本
链接：https://pan.baidu.com/s/1gC1DmT72Q6qxDIzqPx7esQ?pwd=c3rd
提取码：c3rd
Install-macOS-Sierra-10.12.6版本
链接：https://pan.baidu.com/s/1jWobf9oErg6ezVQolxW2qQ?pwd=i5m8
提取码：i5m8
unlocker-4.1.3.tar
用来给VMWare打补丁，来支持安装MacOs虚拟机，如果没有这个，在创建虚拟机时候，没有MacOS这个选项。
链接：https://pan.baidu.com/s/1TOY37mY8BJm8HxNP_LJ8VA?pwd=kaib
提取码：kaibesxi-unlocker-302 ESXI需要添加补丁，因为macOS只能安装在Apple硬件上。unlocker将修改ESXi以接受macOS VM的非Apple硬件，如果不执行这个程序，会报错。
链接：https://pan.baidu.com/s/1aqoSZLllMqLw0KADO54xKQ
提取码：z027
或者下载链接：
https://download.csdn.net/download/RGBBB/72130224
4. VMware Tools (darwin.iso)
VMware Tools组件，是VMware官方对虚拟机提供的一个组件包，能改善鼠标移动性、视频和性能，虚拟机显示没有黑边，屏幕会根据窗口大小自动调整，还能实现文件无缝拖入
链接: https://pan.baidu.com/s/1r-tOG2enKOxuhHpkFsB5lA
提取码: dong
或者：
链接：https://pan.baidu.com/s/14yz4JrG5UuXmRs4gLywK1Q
提取码：w9cg
二、安装过程 1.连接远程ESXI服务器 打开VMWare,连接远程服务器
192.168.1.100 就是ESXI服务器ip，然后输入用户名密码，就能连接上。
当然可以访问：https://192.168.9.100/ 网页端控制页面，也能使用。
此处使用VMWare是方便后面更舒服的访问MacOs系统，比网页端访问系统更舒服。
2.上传iso文件和几个文件到ESXI服务器 打开自己的ESXi网页端地址：https://192.168.9.100/(这是我的地址)
登录后点击左侧的 “存储”–数据存储浏览器
创建目录：ISO
然后将 macOS.Mojave10.14、esxi-unlocker-302、darwin.iso 上传至此目录，后面依次要用到。
3.给VmWare打补丁，支持安装MacOS虚拟机 给VmWare打补丁，从而支持安装MacOs虚拟机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b666ac5f312655e31bf174ba1887300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4630bc2415998ade9826110719e1cc27/" rel="bookmark">
			Calling Add-ins (C#)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本范例展示如何通过实现 IEdmAddIn5::GetAddInInfo 和 IEdmAddIn5::OnCmd 去创建一个当用户在数据卡中点击一个按钮时被调用的Visual C# add-in程序。这个add-in在用户浏览文件时打开一个对话框. add-in 将所选文件的路径复制到 文件的数据卡。
注意： 因为 SOLIDWORKS PDM Professional 无法强制重新加载 .NET 中编写的Add-in程序。必须重新启动所有客户端计算机，以确保使用最新版本的外接程序。 启动VS。新建项目，选择类库。 在“解决方案资源管理器”中右键单击项目名称 ，然后单击添加引用。 单击 COM 在 左侧面板，单击PDMWorks Enterprise 2019 Type Library，然后单击添加。
如果需要，引入相关的程序集。设置Interop.EdmLib的嵌入互操作类型为False。在“解决方案资源管理器”中右击项目名称，然后单击“属性”。 “应用程序&gt;程序集信息”。 取消勾选“使程序集 COM 可见（M）”。 修改Class1.cs。这里修改类名为CallAddin.cs。 添加和创建GUID。修改代码 using System; using EdmLib;//添加 using System.Runtime.InteropServices;//添加 namespace Calling_Add_ins { [Guid("20637265-0AAC-4730-BA59-43C4395B2D2A"),ComVisible(true)] public class CallAddin : IEdmAddIn5 { } } 实现 IEdmAddIn5::GetAddInInfo 和IEdmAddIn5::OnCmd ​​using System; using EdmLib;//添加 using System.Runtime.InteropServices;//添加 namespace Calling_Add_ins { [Guid("20637265-0AAC-4730-BA59-43C4395B2D2A"),ComVisible(true)] public class CallAddin : IEdmAddIn5 { public void GetAddInInfo(ref EdmAddInInfo poInfo, IEdmVault5 poVault, IEdmCmdMgr5 poCmdMgr) { //Specify information to display in the add-in's Properties dialog box poInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4630bc2415998ade9826110719e1cc27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799da9bafcb039058ac540324574237a/" rel="bookmark">
			Creating Serial Numbers (C#)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此示例展示如何使用Visual C#编写的Add-ins为文件数据卡生成序列号。
注意事项：
SOLIDWORKS PDM Professional无法强制重新加载用.NET编写的Add-ins，必须重新启动所有客户端计算机，以确保使用Add-ins的最新版本。
SOLIDWORKS PDM Professional建议使用内置格式字符串或列表生成序列号。它们提供了比Add-ins生成的序列号或文件序列号更好的性能。仅当内置格式字符串或列表不足时，才编写Add-ins以生成序列号。
序列号编码器与其他类型挂钩的区别在于：
在IEdmAddIn5:：GetAddInInfo方法中注册你的钩子。在IEdmAddIn5:：OnCmd方法中编写内容。 启动VS。新建项目，选择类库。在“解决方案资源管理器”中右键单击项目名称 ，然后单击添加引用。 单击 COM 在 左侧面板，单击PDMWorks Enterprise 2019 Type Library，然后单击添加。
如果需要，引入相关的程序集。设置Interop.EdmLib的嵌入互操作类型为False。在“解决方案资源管理器”中右击项目名称，然后单击“属性”。 “应用程序&gt;程序集信息”。取消勾选“使程序集 COM 可见（M）”。修改Class1.cs。这里修改类名为MySerial.cs。 添加和创建GUID。修改代码 using System; using System.Runtime.InteropServices;//添加 using EdmLib;//添加 namespace Creating_Serial_Numbers​​ { [Guid("90C81B4A-560D-4FBF-9F08-E670D4ABB892"), ComVisible(true)] public class MySerial:IEdmAddIn5 { } } 实现 IEdmAddIn5::GetAddInInfo 和IEdmAddIn5::OnCmd ​​ using System; using System.Runtime.InteropServices;//添加 using EdmLib;//添加 namespace Creating_Serial_Numbers​​ { [Guid("90C81B4A-560D-4FBF-9F08-E670D4ABB892"), ComVisible(true)] public class MySerial:IEdmAddIn5 { public void GetAddInInfo(ref EdmAddInInfo poInfo, IEdmVault5 poVault, IEdmCmdMgr5 poCmdMgr) { //Return information about this add-in to the Administrate Add-ins dialog poInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/799da9bafcb039058ac540324574237a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff03144a4565896065dc02764ba7113/" rel="bookmark">
			a标签下载图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法：在下载链接 url 后面加上 ?response-content-type=application/octet-stream 这个参数可以实现点击下载功能
&lt;a href="http://pic/item/6a63f629f9a16a.jpg?response-content-type=application/octet-stream" download&gt;下载&lt;/a&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aea7e4a68d5b3e785ff9e986fb46653/" rel="bookmark">
			Docker宿主机复制(单个文件夹/多个文件/单个文件)到容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 复制单个文件夹到容器指定目录下 我的JPEGImages里面包含了多张图片，下面的指令将宿主机JPEGImages目录下的所有文件和子目录复制到7a7608e0bf84容器的/home/PaddleSeg/input/目录下
docker cp JPEGImages/. 7a7608e0bf84:/home/PaddleSeg/input/ 复制多个宿主机文件到容器指定目录下 使用多行docker cp指令
docker cp JPEGImages/a.png 7a7608e0bf84:/home/PaddleSeg/input/ \ docker cp JPEGImages/b.png 7a7608e0bf84:/home/PaddleSeg/input/ 从容器复制单个文件到宿主机： docker cp &lt;容器ID或名称&gt;:&lt;容器源路径&gt; &lt;宿主机目标路径&gt;
docker cp 7a7608e0bf84:/home/PaddleSeg/input/a.png JPEGImages/ 从宿主机复制单个文件到容器 docker cp &lt;宿主机目标路径&gt; &lt;容器ID或名称&gt;:&lt;容器源路径&gt;
docker cp JPEGImages/a.png 7a7608e0bf84:/home/PaddleSeg/input/ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/73/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>