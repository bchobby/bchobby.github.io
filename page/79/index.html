<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28054ffc52315a243852e79c80522fd7/" rel="bookmark">
			如何将 Docker 镜像大小从 1.43 GB 减少到 22.4 MB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你正在从事 Web 开发，那么你可能已经了解过容器化的概念以及它的优点。
但是，当使用 Docker 时，镜像大小是一个很大的问题。仅仅是从 create-react-app 中得到的样板项目就通常超过 1.43 GB。
今天我们将会容器化一个 ReactJS 应用程序，并学习一些关于如何减小镜像大小以及同时提高性能的技巧。
这些技巧将会展示给 ReactJS，但它同样适用于任何 NodeJS 应用程序。
步骤1：创建您的项目 把你的终端打开，输入以下命令：
npx create-react-app docker-image-test 然后create-react-app将为您提供基本的 React 应用程序。
之后，进入根目录并运行项目。
cd docker-image-testyarn installyarn start 然后转到http://localhost:3000查看您的应用程序是否已启动并正在运行。
步骤2：构建您的第一个图像 在项目的根目录中，创建一个名为Dockerfile的文件并将以下代码粘贴到其中。
FROM node:12 WORKDIR /app COPY package.json ./ RUN yarn install COPY . . EXPOSE 3000 CMD ["yarn", "start"] 请注意，我们正在从 docker hub 获取基本映像 node:12，安装依赖项并运行基本命令。（这里不深入docker命令的细节）
现在从您的终端，为您的容器构建图像。
docker build -t docker-image-test . Docker 将构建您的映像。完成后，您可以使用此命令查看您的图像。
docker images 列表顶部是我们新创建的图像，在最右侧，我们可以看到图像的大小。现在是1.43GB 。
我们可以使用以下命令运行图像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28054ffc52315a243852e79c80522fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87916e26afaa6d6d3c9b37975f1124c8/" rel="bookmark">
			kubernetes网络隔离(Networkpolicy)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Kubernetes 里，网络隔离能力的定义，是依靠一种专门的 API 对象来描述的，即：NetworkPolicy。
一个完整的 NetworkPolicy 对象的示例，如下所示：
apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: matchLabels: role: db policyTypes: - Ingress - Egress ingress: - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978 Kubernetes 里的 Pod 默认都是“允许所有”（Accept All）的即：Pod 可以接收来自任何发送方的请求；或者，向任何接收方发送请求。而如果你要对这个情况作出限制，就必须通过 NetworkPolicy 对象来指定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87916e26afaa6d6d3c9b37975f1124c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8eb469ed8270fcf42080e8e96a20ad/" rel="bookmark">
			【自制视频课程】C&#43;&#43;OpnecV基础35讲——第一章 前言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么要学习OpenCV？ 首先，opencv是一个广泛使用的计算机视觉库，它提供了丰富的图像处理和计算机视觉算法，可以帮助我们快速地开发出高质量的图像处理应用程序；
其次，opencv是一个开源库，可以免费使用和修改，这为我们提供了一个学习和研究计算机视觉的良好平台；
最后，opencv是一个跨平台的库，支持多种操作系统和编程语言，包括C++、Python和Java等，这使得我们可以在不同的平台上开发出具有高度可移植性的图像处理应用程序。
学习opencv可以帮助我们掌握各种图像处理和计算机视觉算法，如图像滤波、特征提取、目标检测、人脸识别等。这些算法可以应用于各种领域，如医疗、安防、交通、娱乐等。例如，在医疗领域，我们可以使用opencv中的图像分割算法来分割医学图像，以便医生更好地诊断疾病。在安防领域，我们可以使用opencv中的目标检测算法来检测和跟踪人员和车辆，以保障公共安全。在交通领域，我们可以使用opencv中的车辆识别算法来实现智能交通系统，提高交通效率。以及我们可以使用opencv中的人脸识别算法来实现人脸识别门禁系统，提高安全性。
因此，学习opencv它可以帮助我们掌握各种图像处理和计算机视觉算法，应用于各种领域。同时，opencv是一个开源跨平台的库，可以免费使用和修改，为我们提供了一个学习和研究计算机视觉的良好平台。
C++OpenCV学习规划 1. OpenCV基础知识：首先，学生应该了解OpenCV的基础知识，包括图像的读取、显示、保存以及像素操作等基本操作。
2. 图像处理算法：接学生应该学习一些常见的图像处理算法，例如滤波、边缘检测、二值化、形态学操作等。
3. 特征提取与描述：学生应该学习如何提取图像中的特征，并将其描述为向量或描述符。这包括SIFT、SURF、ORB等算法。
4. 目标检测与跟踪：学生应该学习如何使用OpenCV实现目标检测和跟踪。这包括Haar特征检测、HOG+SVM、卡尔曼滤波等算法。
5. 深度学习与计算机视觉：最后，学生应该学习如何使用深度学习来解决计算机视觉问题。这包括使用OpenCV和TensorFlow/Keras实现卷积神经网络、循环神经网络等算法。
课程地址 传统图像算法：c++OpenCV从算法原理基础到项目实战 (lizhiweike.com)https://m.lizhiweike.com/channel2/1396545 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92f14b6ec38f0f8682f3bd2268e5a91/" rel="bookmark">
			python加入环境变量sys.append
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://docs.python.org/3.11/tutorial/modules.html
import sys sys.path.append('/ufs/guido/lib/python') 若是提示找不到相应的.py档案，不能正确导入import，可以使用这个加入到环境变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db93074781b0a4a944008ad52c8299e7/" rel="bookmark">
			Oracle：RHEL7.5安装Oracle19C单实例（图形界面版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 夜说
个人公众号 | 夜说的数据库笔记
原文链接 | Oracle：RHEL7.5安装Oracle19C单实例（图形界面版）
目录
01前言
02安装说明
03安装前配置
3.1关闭防火墙和SELINUX
3.2禁用numa和透明大页
3.3修改hosts文件
3.4修改login文件
3.5创建用户和用户组
3.6创建数据库软件目录和数据文件目录
3.7修改用户限制
3.8修改内核参数
3.9修改network文件
3.10修改Oracle用户环境变量
3.11配置yum源
3.12解压Oracle安装包
3.13补充安装以下rpm包
04安装数据库软件
4.1打开xmanager调出图形化界面
4.2安装数据库软件
05安装数据库
06确认安装正常
01前言 本文基于红帽7.5系统安装Oracle19C单实例，使用图形界面进行安装。
02安装说明 一、系统版本(带GUI安装） [root@oracle19c ~]# cat /etc/redhat-release Red Hat Enterprise Linux Server release 7.5 (Maipo) 二、磁盘大小 [root@oracle19c ~]# df -Th Filesystem Type Size Used Avail Use% Mounted on /dev/mapper/rhel-root xfs 71G 3.4G 68G 5% / devtmpfs devtmpfs 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db93074781b0a4a944008ad52c8299e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791e1d75fea2337e17acc9def58e353e/" rel="bookmark">
			赫夫曼树和赫夫曼编码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
何为赫夫曼树？
赫夫曼树算法
赫夫曼编码
编程实现赫夫曼树
编程实现赫夫曼编码
编程实现WPL
总代码及分析
何为赫夫曼树？ 树的路径长度：从树根到每一结点的路径长度之和
结点的带权路径长度：从树根到该结点的路径长度与结点上权的乘积
树的带权路径长度：树中所有叶子结点的带权路径长度之和
假设有n个权值(w1.w2,,,Wn),试构造一棵有n个叶子结点的二叉树，每个叶子结点带权为Wi,则其中WPL最小的二叉称做最优二叉树或赫夫曼树。
赫夫曼树算法 (1)根据给定的n个权值(w1，w2，…，Wn，)构成n棵二叉树的集合F=(T1，T2，…，Tn，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均空。
(2)在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。
(3)在F中删除这两棵树，同时将新得到的二叉树加入F中。
(4)重复(2)和(3)，直到F只含一棵树为止。这棵树便是赫夫曼树。
如下图：
赫夫曼编码 设一课二叉树为：
其3个叶子结点分别表示a、b、c3个字符， 约定左分支表示字符‘0’，右分支表示字符‘1’。则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。如上图可以得到a、b、c的二级制前缀编码分别为：0、10、11。
如何得到使电文总长最短的二级制编码？假设每种字符在电文中出现的次数为i,编码长度为j,而电文只有n种字符，则电文总长为n种i*j的和。对应到二叉树上，若i表示叶子结点的权值，j为从根到叶子的路径长度。则电文总长恰为二叉树带权路径长度。所以，设计电文总长最短的二级制前缀编码即以N种字符出现的频率作为权值，设计一颗赫夫曼树的问题
编程实现赫夫曼树 //哈夫曼树的存储表示 typedef struct { int weight; //节点的权值 int parent, lchild, rchild; //节点的双亲，左孩子和右孩子 } HTNode, * HuffmanTree; typedef char** HuffmanCode; //查权值最小且双亲为0的节点 void Select(HuffmanTree HT, int len, int&amp; s1, int&amp; s2) { int i, min1 = 0x3f3f3f3f, min2 = 0x3f3f3f3f; //先赋予最大值 for (i = 1; i &lt;= len; i++) { if (HT[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/791e1d75fea2337e17acc9def58e353e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3b68bb2e18c29fde848e358f1fdc26/" rel="bookmark">
			【MATLAB】基于S-Function的RFID ASK调制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
在MATLAB代码中调用用户自定义的S-Function.m文件
编写S-Function实现ASK调制
使用MATLAB语言编写S-Function源文件
在Simulink中调用S-function
在MATLAB代码中调用用户自定义的S-Function.m文件
1. 将S-Function.m 文件添加到MATLAB搜索路径中。
a. 在MATLAB命令窗口中使用addpath函数将S-Function.m文件所在的目录添加到MATLAB搜索路径中。例如：addpath('C:\MySfuncFolder')
b. 可以将文件夹路径添加到MATLAB搜索路径中。在MATLAB窗口下，单击Set Path，然后选择Add Folder，将S-Function.m文件所在的文件夹添加到搜索路径中。
2. 在MATLAB代码中使用s-function构造函数创建S-Function对象，并设置输入、输出和参数属性。例如：
s = sfunction('mySfunc'); s.InputPortWidth = 1; s.InputPort(1).DatatypeID = 0; s.OutputPortWidth = 1; s.OutputPort(1).DatatypeID = 0; s.NumDialogPrms = 0; 这将创建一个名为"mySfunc"的S-Function对象，并设置输入和输出端口的数据类型和宽度属性。
3. 调用set函数设置S-Function对象的输入端口数据。例如：
set(s, 'Inputs', {1}); 这将设置S-Function对象的一个输入端口数据为1。
4. 调用evaluate函数运行S-Function对象，并获取输出结果。例如：
y = evaluate(s); disp(y); 这将运行S-Function对象并获取输出结果y，并在命令窗口中打印输出结果。
需要注意的是，S-Function.m文件需要遵循特定的S-Function接口规范，包括输入和输出参数及执行函数。开发人员需要了解如何编写或使用S-Function代码，并按照规范实现S-Function接口。在MATLAB中调用S-Function.m时，需要创建S-Function对象并设置相关属性，然后运行evaluate函数以获取输出结果。
编写S-Function实现ASK调制 1. 创建S-Function模板。可以使用MATLAB提供的S-Function模板创建S-Function。在MATLAB命令窗口中输入以下代码即可创建一个基本的S-Function模板：
sfcn_template 2. 编写S-Function函数。
a. 打开生成的S-Function源文件（sfun_template.c），可以在S-Function函数中实现ASK调制。
b. 在S-Function函数中定义输入、输出和参数，以便从Simulink模型中获取输入数据，执行ASK调制算法，并将输出数据返回模型。
c. 实现S-Function函数的输出函数，在这里可以进行ASK调制。例如：
static void mdlOutputs(SimStruct *S, int_T tid) { double *y = (double *)ssGetOutputPortSignal(S, 0); double *u = (double *)ssGetInputPortSignal(S, 0); double fc = *mxGetPr(ssGetSFcnParam(S,0)); double f = 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3b68bb2e18c29fde848e358f1fdc26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51812d8588a1d1b33a78240a2f95f840/" rel="bookmark">
			微信聊天记录导出(华为手机版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 背景 关于微信记录导出的有比较多的方法, 在这里进行汇总下, 以下都是经过我亲测可行的, 不要去买一些付费的软件, 自己手动操作下就好啦
2 步骤 主要参考这两篇文章:
微信聊天记录导出为电脑txt文件教程
微信聊天记录导出(2020新版)
具体步骤:
1.先登录电脑版微信
2.备份与迁移, 选择备份聊天记录到电脑
3.手机上选择聊天对象,之后开始备份
4.安装mumu模拟器, 在上面安装 微信和ES文件浏览器
5.在模拟器上登录微信(手机上退出),在电脑微信上选择备份与迁移, 将聊天记录恢复到手机上
6.使用es文件浏览器将聊天数据库导出,名字为EnMicroMsg.db
7.使用sqlcipher读取db文件并导出为csv
8.csv数据处理, 将聊天记录根据id进行分类
后续数据处理(生成词云)以及代码见代码
3 踩坑记录 登录电脑版微信 -&gt; 选择备份聊天记录 -&gt; 下载安装MuMu模拟器(坑1) -&gt; 安装微信和es文件浏览器(坑2)
-&gt; 登录微信并还原聊天记录 -&gt; 开启root -&gt; 找到com.tencent.mm文件夹压缩后导出 -&gt; 找到数据库密码(坑3) -&gt; 导出message表
坑0: 此部分参考链接,不再赘述 https://zhuanlan.zhihu.com/p/111802776坑1:这个模拟器比较好用,其他像什么夜神(不好找文件,安装不了es),vmos(手机版,运行太慢,很卡)都不太行坑2:模拟器上面的IMEI编码好像设不设置都没关系坑3:数据库密码,规则网上都很清楚,这里有几个注意点,1是IMEI编码的问题,如果你的手机是双卡双待的话,可能两个IMEI都没用,而是使用默认的字符串 1234567890ABCDEF, 2.注意最终密码应该是全小写字母 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ce76a4ba9ea53f0f441aab770fe94a/" rel="bookmark">
			雷达目标识别最常用的聚类算法之一——密度聚类DBSCAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当雷达检测目标点的数据达到一定程度，基于原始检测点目标的跟踪算法耗时耗力，且容易导致目标分裂，所以常见的处理方式是在建立目标的关联航迹之前，先对点目标进行聚类预处理，比如200个目标检测点，经过DBSCAN聚类之后，产生50个左右的聚类目标，在50个聚类目标的基础上再去进行航迹的关联跟踪，这样做有几点好处：
1） 大大减少了目标跟踪的复杂度和时间；
2） 对大目标的分裂问题友好；
3） 通过聚类的结果对单一的虚假点进行过滤，减少虚假航迹；
4） 通过类内的点的特征与分布，可以帮助估计目标的特征与运动形态；
本文提供了DBSCAN的matlab代码实现，但在具体应用的过程中，需要根据实际雷达检测点的质量、精度、分辨率等信号的指标特性，动态调整DBSCAN的代码逻辑或者聚类门限，以下代码仅供大家学习和研究。
%----------------DBSCAN聚类算法----------------- % 基于密度聚类，不需要设定类的数量 % 优势：首先，它根本不需要pe-set数量的簇。 它还将异常值识别为噪声，而不像mean-shift，即使数据点非常不同， % 它们也会将它们引入群集中。 另外，它能够很好地找到任意大小和任意形状的簇。 % 缺点：当簇的密度不同时，DBSCAN的性能不如其他组织。 这是因为当密度变化时，用于识别邻近点的距离阈值ε和 % minPoints的设置将随着群集而变化。 对于非常高维的数据也会出现这种缺点，因为距离阈值ε再次难以估计。 %----------------------------------------------------- function [IDX, isnoise]=DBSCAN(X,epsilon,MinPts) C = 0; n = size(X,1); IDX = zeros(n,1); D = pdist2(X,X); % 计算向量之间的距离 visited = false(n,1); isnoise = false(n,1); for i = 1:n if ~visited(i) visited(i) = true; Neighbors = RegionQuery(i); % 找到第i个点epsilon范围内的点 if numel(Neighbors) &lt; MinPts % numel()返回满足条件的元素个数 % X(i,:) is NOISE isnoise(i) = true; else C=C+1; ExpandCluster(i,Neighbors,C); end end end function ExpandCluster(i,Neighbors,C) IDX(i) = C; k = 1; while true j = Neighbors(k); if ~visited(j) visited(j) = true; Neighbors2 = RegionQuery(j); if numel(Neighbors2) &gt;= MinPts Neighbors=[Neighbors Neighbors2]; %#ok end end if IDX(j) == 0 IDX(j) = C; end k = k + 1; if k &gt; numel(Neighbors) break; end end end function Neighbors = RegionQuery(i) Neighbors = find(D(i,:) &lt;= epsilon); end end clc; clear; close all; %% test Data % 这里使用的iris数据的一部分，由于第3维和第4为数据数据区分度好，因此用3、4维数据测试 % Iris-setosa X1 = [5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55ce76a4ba9ea53f0f441aab770fe94a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aad11efa75eb8969fb3609669ab6c03/" rel="bookmark">
			STM32_HAL库_点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用HAL库点亮一个LED灯
编程思路，代码，代码理解
芯片型号：
STM32F407ZGT6
参考文件：
F4 HAL库官方文档、STM32F4xx中文参考手册
基本思路：
点亮一个LED的最主要的就是控制LED对应的引脚的电平高低，如原理图可知：例如点亮LED_R,LED正极外界3.3V电压，则需要对PF6口输出低电平，即控制PF6_IO口输出低电平，形成电压差，从而点亮LED。
如原理图可知LED_R负极接芯片PF6口。
1、运用STM32CubeMX初始化
具体步骤：
①点击ACCESS TO　MCU　SELECTOR
②按上图所示步骤
在１处输入自己单片机型号　例如：STM32F407ZGT6。
在２处单机选择
在３处点击start　project创建文件进入到配置界面
③初始化界面配置
１处可以搜索需要配置的功能，例如我需要配置ＩＯ口即可在此输入搜索ＧＰＩＯ
２处可以查看所有配置的列表
３处可视化芯片所有引脚
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
这种颜色表示不可配置引脚 电源专用引脚以黄色突出显示。其配置不能更改
这种颜色表示你配置了一个I/O口的功能，但是没有初始化相对应的外设功能 引脚处于no mode 状态 绿色表示配置成功
来源：【STM32】STM32CubeMX教程二--基本使用(新建工程点亮LED灯)_Z小旋的博客-CSDN博客
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
４处可以搜索要用的引脚，搜索到后会在３处闪烁　例如搜索ＰＦ６，会出现如下左图
－－＞
点击相应的引脚会显示出该引脚可配置的功能，点击所需要配置的功能即可，点击后出现如上右图。当右图可视化引脚冒绿光代表配置完成，可在中间框点击ＰＦ６配置更多参数。
（有需要可配置时钟初始化Clock　Configuration；默认时钟选择的是内部ＨＳＩ　ＲＣ
－１６Ｍｈｚ）
１可配置时钟
２配置文件
根据自己的需要配置Name、文件位置、ＩＤＥ
配置完Project后配置Code　Generator
（我的一般配置）
配置的大致说明：
【STM32】STM32CubeMX教程二--基本使用(新建工程点亮LED灯)_Z小旋的博客-CSDN博客
配置完成后点击右上角GENERATE　ＣＯＤＥ生成文件如下图所示：
打开ＭＤＫ－ＡＲＡＭ里的程序，进行第一次编译，可能会发现会有如下报错：
想要解决问题，需要在右侧Ｐｒｏｊｅｃｔ处做如下操作：
双击Ｄｒｉｖｅｒｓ／ＣＭＳＩＳ文件，在官方下载的STM32Cube_FW_F4_V1.27.0文件夹里选择Ｄｒｉｖｅｒｓ，然后选择ＣＭＳＩＳ，然后选择Device，无脑点到底到有一个Ｓｏｕｒｃｅ文件的目录下，点击Source，再无脑点到有三个文件夹构成的目录下，点击ａｒｍ，寻找和自己型号匹配的启动文件，双击添加，搞定。
至此配置的初始化差不多了，可以开始写简单的电灯程序了：
③正式电灯：
ｍａｉｎ函数中的ｗｈｉｌｅ循环（已经自动生成）
while (1) { ／／对ＰＦ６口设置低电平 HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_RESET); } 搞定！！
④由于我是第一次用ＨＡＬ找不到看的爽的教程，所以尝试自己分析里面的内容。
附上主函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aad11efa75eb8969fb3609669ab6c03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324f330d578be7abed211eb5b0ae790a/" rel="bookmark">
			使用docker构建并部署MySQL5.7镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用docker构建并部署MySQL5.7镜像 前言一、docker中部署MySQL主要有哪几种方式？二、CentOS 镜像中构建 MySQL 容器1.编写Dockerfile2.初始化MySQL 三、MySQL 官方镜像中构建容器1. 拉取官方镜像2. 运行镜像3. 配置镜像外网访问 四、MySQL 容器初始化脚本1. 将sql文件放入docker2. 执行sql文件 五、MySQL 容器本地化部署1. 打包mysql镜像2. 部署MySQL镜像 总结 前言 这几天在研究如何将服务器和数据库迁移至docker容器，中间遇到了许多问题，特此写篇博客记录一下。
提示：本篇文章主要讲解如何在docker容器中构建及部署MySQL
一、docker中部署MySQL主要有哪几种方式？ 从 CentOS 镜像中构建 MySQL 容器从 MySQL 官方镜像中构建容器 从 CentOS 镜像中构建 MySQL 容器可以更好地控制操作系统的版本和配置，而从 MySQL 官方镜像中构建容器则可以更方便地获取最新版本的 MySQL。具体选择哪个镜像，可以根据自己的需求和实际情况来决定。
下面我们来尝试上面两种构建MySQL容器的方式
二、CentOS 镜像中构建 MySQL 容器 1.编写Dockerfile Dockerfile（示例）：
# 1. 镜像基于centos7 FROM centos:7 # 2. 更改镜像时区 RUN echo 'Asia/Shanghai' &gt;/etc/timezone MAINTAINER 作者 # 3. 安装必要的软件包 RUN yum -y install epel-release RUN yum install initscripts -y # 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/324f330d578be7abed211eb5b0ae790a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd724f6b627fc0e8866546ba3682d4b/" rel="bookmark">
			6、内存泄漏和内存溢出有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、内存溢出 内存溢出 （out of memory），指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。
内存溢出原因：
1、内存中加载的数据量过于庞大，如一次从数据库取出过多数据
2、集合类中有对对象的引用，使用完后未清空，使得不能回收
3、代码中存在死循环或循环产生过多重复的对象实体
4、使用的第三方软件中的 BUG
5、启动参数内存值设定的过小
举例：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出.。
二、内存泄漏 内存泄露 （memory leak），是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
memory leak会最终会导致out of memory！
举例：内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。
分类：
★以发生的方式来分类，内存泄漏可以分为4类： 1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 ★几种内存泄漏的情况：
1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过 malloc，realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free 或者 delete 删掉。如果程序
的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生 Heap Leak。
2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap，handle ，SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不
是 virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露。
从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf4e0c74f2036fe01469a04a03772a2/" rel="bookmark">
			十分钟读懂Stable Diffusion运行原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：symon
AIGC 热潮正猛烈地席卷开来，可以说 Stable Diffusion 开源发布把 AI 图像生成提高了全新高度，特别是 ControlNet 和 T2I-Adapter 控制模块的提出进一步提高生成可控性，也在逐渐改变一部分行业的生产模式。惊艳其出色表现，也不禁好奇其背后技术。本文整理了一些学习过程中记录的技术内容，主要包括 Stable Diffusion 技术运行机制，希望帮助大家知其所以然。
一 背景介绍 AI 绘画作为 AIGC（人工智能创作内容）的一个应用方向，它绝对是 2022 年以来 AI 领域最热门的话题之一。AI 绘画凭借着其独特创意和便捷创作工具迅速走红，广受关注。举两个简单例子，左边是利用 controlnet 新魔法把一张四个闺蜜在沙滩边上的普通合影照改成唯美动漫风，右边是 midjourney v5 最新版本解锁的逆天神技， 只需输入文字“旧厂街风格，带着浓浓 90 年代氛围感”即可由 AI 一键生成超逼真图片！
图1 两个stable diffusion例子 Stable Diffusion，是一个 2022 年发布的文本到图像潜在扩散模型，由 CompVis、Stability AI 和 LAION 的研究人员创建的。要提到的是，Stable Diffusion 技术提出者 StabilityAI 公司在 2022 年 10 月完成了 1.01 亿美元的融资，估值目前已经超过 10 亿美元。本文会在第二部分着重介绍 Stable Diffusion 的技术思路，第三部分深入分析各个重要模块的运行机制，最后总结下 AI 绘画。
二 原理简介 Stable Diffusion 技术，作为 Diffusion 改进版本，通过引入隐向量空间来解决 Diffusion 速度瓶颈，除了可专门用于文生图任务，还可以用于图生图、特定角色刻画，甚至是超分或者上色任务。作为一篇基础原理介绍，这里着重解析最常用的“文生图（text to image）”为主线，介绍 stable diffusion 计算思路以及分析各个重要的组成模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bf4e0c74f2036fe01469a04a03772a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3035d02fd07f947470b86b8a9a406f6f/" rel="bookmark">
			分布式搜索引擎Elasticsearch基础入门学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch介绍# Elasticsearh 是 elastic.co 公司开发的分布式搜索引擎。
Elasticsearch（简称ES）是一个开源的分布式、高度可扩展的全文搜索和分析引擎。它能够快速、近乎实时的存储、搜索和分析大量数据。适用于包括文本、数字、地理空间、结构化和非结构化数据等在内的所有类型数据。
它通常为具有复杂搜索功能的应用提供底层搜索技术。
当然，它也可以用来实现分布式数据存储、日志统计、分析、系统监控、地理空间查询等功能。
Elasticsearch 最底层的搜索引擎技术是 Apache 基金会开源的搜索引擎类库 Lucene，Lucene 提供了搜索引擎核心 API 。
Lucene 地址：Apache Lucene - Welcome to Apache Lucene ES 在 Lucene 的基础上提供了分布式支持，可以水平扩展，提供了 Restful 这种简洁的访问接口，能被任何语言调用。
Elasticsearch 官网：Elastic Observability and Security — built on Elasticsearch | Elasticgithub：GitHub - elastic/elasticsearch: Free and Open, Distributed, RESTful Search Engine Elasticsearch能做什么# 应用搜索，常见的 github 的代码搜索，滴滴，美团，点评，银行等各种搜索网站搜索日志记录和日志分析基础设置指标和容器监控应用性能监控地理空间数据分析和可视化商业分析安全分析 二、ELK 是什么# ELK 是 Elasticsearch、Logstash 和 Kibana 的第一个字母组合，也叫 ELK Stack。是一套用于数据采集、存储、分析和可视化的开源工具集。
Elasticsearch：存储、索引、计算、搜索、分析数据。
Logstash：用于收集、转换数据，然后将它存储在 ES 中。后面还开发新的收集数据软件 Beats。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3035d02fd07f947470b86b8a9a406f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e2289ce7d12020aba189214521750c/" rel="bookmark">
			记一次tomcat、gateway配置SSL，使用https访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前置条件： 外网对应服务器的nginx已配置跳转，并给到了域名对应的ssl相关文件 xxx.pfx 和密码串
前端访问
http://域名:8081
解析到： http://IP:8081
后端接口
http://域名:88
解析到： http://IP:88
2、服务器配置SSL 架构使用了前后端分离，所以前后端访问都需要配置SSL
2.1、前端 前端正式环境url访问配置 https://域名:8081
前端正式环境url调用访问后台配置 https://域名:88
前端部署在tomcat，tomcat 的conf/server.xml文件配置 &lt;Connector port="8081" protocol="org.apache.coyote.http11.Http11NioProtocol" SSLEnabled="true" scheme="https" secure="true" keystoreFile="conf/cert/xxx.pfx" keystorePass="xxx" clientAuth="false" SSLProtocol="TLSv1+TLSv1.1+TLSv1.2" ciphers="TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256"/&gt; 2.2、后端 使用springcloud gateway作为网关
gataway微服务配置 pom.xml添加插件
&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!-- 过滤后缀为pkcs12、jks的证书文件 --&gt; &lt;nonFilteredFileExtensions&gt; &lt;nonFilteredFileExtension&gt;pfx&lt;/nonFilteredFileExtension&gt; &lt;nonFilteredFileExtension&gt;jks&lt;/nonFilteredFileExtension&gt; &lt;/nonFilteredFileExtensions&gt; &lt;/configuration&gt; &lt;/plugin&gt; 配置文件bootstrap.yml配置
server: port: 88 ssl: key-store: classpath:xxx.com.pfx key-store-type: PKCS12 enabled: true key-store-password: xxx 配置文件application.yml配置（每个微服务都配置） uri: lb:http://微服务名称
- id: xxx_route uri: lb:http://微服务名称 predicates: #- Host=域名 - Path=/api/** filters: - RewritePath=/api/(?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e2289ce7d12020aba189214521750c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47488304f3b5a8a14af551bc24f2c3a8/" rel="bookmark">
			小程序使用Image对象预加载图片·获取图片信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信和支付宝等小程序目前都没有直接调用Image的接口, 但可以借用canvas曲线救国，在页面设置个不可见的canvas,再通过canvas的接口能力就能调用到image了
微信案例 wx.createSelectorQuery() .select('#myCanvas') // 在 WXML 中填入的 id .fields({ node: true, size: true }) .exec((res) =&gt; { // Canvas 对象 const canvas = res[0].node // 图片对象 const image = canvas.createImage() // 图片加载完成回调 image.onload = () =&gt; { // 将图片绘制到 canvas 上 console.log({image, width: image.width, height: image.height}); } image.src = 'https://open.weixin.qq.com/zh_CN/htmledition/res/assets/res-design-download/icon64_wx_logo.png' }) 支付宝案例 Page({ // 一定要在 canvas 的 onReady 中调用，否则获取到的 context 可能不正确 onCanvasReady() { // 通过 SelectorQuery 获取 Canvas 实例 my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47488304f3b5a8a14af551bc24f2c3a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07bf1c6d8c9290e26ead68e4935836b7/" rel="bookmark">
			wine 源码中 .spec 文件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在源码查看过程中，涉及到dll 和 so 文件的导入和导出，此时就必须要了解各种函数的跳转过程和导入导出过程，也就必须要彻底了解 .spec 文件。其中尤其ntdll.spec 和user32.spec 为甚，涉及非常多的常用函数接口。
关于spec 文件的详细注释查阅官方文档 https://www.winehq.org/docs/winebuild
通用语法 spec规范文件应该包含一个有序声明的列表。通用语法如下：
ordinal functype [flags] exportname ( [args...] ) [handler] ordinal variable [flags] exportname ( [data...] ) ordinal extern [flags] exportname [symbolname] ordinal stub [flags] exportname [ (args...) ] ordinal equate [flags] exportname data # comments 声明必须放在一行上，除非在行的末尾使用反斜杠字符转义。一行中任何位置的#字符都会导致该行的剩余部分作为注释被忽略。
序数（ordinal ）指定与入口点相对应的序数，或“@”用于自动序数分配（仅Win32）。
flags是一系列可选的标志，前面有一个“-”字符。支持的标志如下：
-norelay
中继调试跟踪中(WINEDEBUG=+relay 时)不显示入口点（仅Win32）。
-noname
入口点将按序号而不是按名称导出。该名称仍然可用于导入。
-ret16
该函数返回一个16位值（仅限Win16）。
-ret64
该函数返回一个64位值（仅限Win32）。
-register
函数使用CPU寄存器来传递参数。
-private
该函数无法从其他dll导入，只能通过GetProcAddress访问。
-ordinal
入口点将按序号而不是按名称导入。该名称仍将被导出。
-thiscall
该函数使用thiscall调用约定（i386上%ecx寄存器中的第一个参数）。
-fastcall
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07bf1c6d8c9290e26ead68e4935836b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd487d92e56306907c04ae3a8527193/" rel="bookmark">
			AdBlock插件，在谷歌浏览器中屏蔽百度热搜或其他广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 通过该插件可以将谷歌浏览器中的任何网址中的特定元素过滤掉，比如百度搜索后右侧的百度热搜，看着就很烦人，每次都忍不住看两眼，少则浪费十几秒，多则浪费个把小时。同时也可以屏蔽其他网站中的元素，让你在浏览网站时可以尽可能的
下载插件(AdBlock) 插件地址：https://www.chromedownloads.net/extensions/456.html#google_vignette
下载解压后将文件夹添加到谷歌浏览器扩展程序中，扩展程序位置：谷歌浏览器右上角三个点 &gt; 设置 &gt; 扩展程序。然后直接将刚才下载的AdBlock文件夹拖拽进去即可。
使用方法 方法一 打开有百度热搜的页面。 右击空白区域在 " AdBlock-最佳广告拦截工具" 中选择隐藏此页面上的区域，然后移动鼠标找到对应元素隐藏即可。
方法二 打开有百度热搜的页面 &gt; 右击空白区域，选择"查看" 或 直接按f12打开控制台 &gt; 找到你想要隐藏的元素，查看他的class类名。
进入AdBlock插件页面，将网站的域名加上需要隐藏的元素的类名即可。保存后再打开百度的页面，就会发现百度热搜已经被隐藏。www.baidu.com##DIV[class=“FYB_RD”]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3137fd0c885877c8a3b7bcd7062c48/" rel="bookmark">
			搭建高可用kafka集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建高可用kafka集群 一、环境准备 搭建集群至少需要三台机器，奇数节点Kafka的安装需要Java环境，JDK1.8以上本次离线安装包包括 jdk1.8.0_161.tar.gz 、kafka_2.12-3.4.0.tgz假设3台服务器分别为：ip1、ip2、ip3 二、安装jdk环境 解压jdk安装文件： tar -zxvf /app/jdk1.8.0_161.tar.gz 设置环境变量： export JAVA_HOME=/app/jdk1.8.0_161 export PATH=$JAVA_HOME/bin:$PATH 添加环境变量至/etc/profile文件： export JAVA_HOME=/app/jdk1.8.0_161 PATH=$JAVA_HOME/bin:$PATH 查看Java版本 java -version 三、zookeeper集群搭建 编辑Zookeeper配置文件 #解压 tar -zxvf /app/kafka_2.12-3.4.0.tgz #进入目录 cd /app/kafka_2.12-3.4.0 #创建zookeeper数据目录 mkdir zk_kfk_data #更换名称 mv kafka_2.12-3.4.0 kafka #进入kafka目录 cd kafka #更改zookeeper配置,添加以下配置 vim config/zookeeper.properties zookeeper配置文件如下(三台机器上的zookeeper.properties文件配置相同)：
#Zookeeper数据文件的目录 dataDir=/app/kafka/zk_kfk_data #Zookeeper保存日志文件的目录 dataLogDir=/app/kafka/logs # the port at which the clients will connect clientPort=2181 # disable the per-ip limit on the number of connections since this is a non-production config maxClientCnxns=0 tickTime=2000 initLimit=10 syncLimit=5 # Disable the adminserver by default to avoid port conflicts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3137fd0c885877c8a3b7bcd7062c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb422374064ca42dc882fcf57ec4d50/" rel="bookmark">
			“超越”(MMCU)中文通用大语言模型测试集--国内首个多领域多任务数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自：甲骨易
进NLP群—&gt;加入NLP交流群
近期，中文大语言模型蓬勃发展，但却一直没有出现可应用于评测大模型能力的测试。甲骨易AI研究院提出一种衡量中文大模型处理多任务准确度的测试，并在此基础上制作了一套适配测试中文大模型的数据集，并将其命名为“超越”。
数据集的测试内容涵盖四大领域：医疗、法律、心理学和教育。通过综合评估模型在多个学科上的知识广度和深度，能够帮助研究者更精准地找出模型的缺陷，并对模型的能力进行打分。
简介
自ChatGPT发布以来，大语言模型(LLMs)保持着在计算机科学技术与自然语言处理领域的热度，并且仍不断升温。ChatGLM、 MOSS、文心一言、通义千问、商量、星火等众多具备中文能力的大模型也接连发布。这些模型有着庞大的数据规模，通过广泛的预训练以达到能够正确理解人类话语和指令并生成类似人类语言的文本的能力。
目前，针对英文大语言模型已经有较为完善的评测方式，如2021年由Dan Hendrycks等人发布的MMLU。然而，针对中文大语言模型能力的测试仍然缺失，推出高质量中文评测数据集已经迫在眉睫。
于是，甲骨易AI研究院制作了一个大规模的多任务测试数据集——“超越”(Massive Multitask Chinese Understanding)。“超越”的意义是希望中文大语言模型“超”出多数模型只能基于英文数据集测试的现状，通过发现大模型的缺陷，从而促进大模型理解中文语言的能力，使其“越”来越强大。
“超越”所包含的题目由来自不同知识分支的单项和多项选择题组成。数据集中的问题是由专业人员从公开免费资源中收集，覆盖学科面广，专业知识难度高，适合用来评估大模型的综合能力。
为了测试数据集的可行性和效果，甲骨易AI研究院在正式公开前已经使用其对目前开源的大模型进行了评测。“超越”数据集预计于2023年5月20日正式公开发布获取方式，具体发布相关信息详见文末。
接下来，将对“超越”数据集(MMCU)中所收录的题目进行介绍，并基于测试结果分析数据在语言模型训练过程中的重要性。
多任务测试
“超越”数据集(MMCU)的测试内容来自医疗、法律、心理学和教育四个大类的题目，包含单项选择和多项选择题，目的旨在使测试过程中模型更接近人类考试的方式。
数据集共收集了11900个问题，将其分成 few-shot开发集和一个测试集。few-shot开发集每个主题有5个问题，共有55个问题；测试集共有11845个问题。
下面分别对不同领域测试题目的学科和子任务示例进行展示。
医疗
医疗类题目来自大学医学专业考试，包括医学三基、药理学、护理学、病理学、临床医学、传染病学、外科学、解剖学等，共有2819个问题。
示例：
首次急性发作的腰椎间盘突出的治疗方法首选：
A. 绝对卧床休息，3 周后戴腰围下床活动
B. 卧床休息，可以站立坐起
C. 皮质类固醇硬膜外注射
D. 髓核化学溶解
法律
法律类题目来自国家统一法律职业资格考试，包括中国特色社会主义法治理论、宪法、中国法律史、国际法、刑法、民法、知识产权法、商法、经济法、劳动与社会保障法等，共有3695个问题。
示例：
根据法律规定，下列哪一种社会关系应由民法调整？
A. 甲请求税务机关退还其多缴的个人所得税
B. 乙手机丢失后发布寻物启事称：“拾得者送还手机，本人当面酬谢”
C. 丙对女友书面承诺：“如我在上海找到工作，则陪你去欧洲旅游”
D. 丁作为青年志愿者，定期去福利院做帮工
心理学
心理学类题目来自心理咨询师考试和研究生入学考试心理学专业基础综合考试，包括心理学概论、人格与社会心理学、发展心理学、心理咨询概论、心理评估、咨询方法等，共有2000个问题。
示例：
把与自己本无关系的事情认为有关，这种临床表现最可能出现于：
A. 被害妄想
B. 钟情妄想
C. 关系妄想
D. 夸大妄想
教育
教育学题目来自中国普通高等学校招生全国统一考试（中国高考），包括语文、数学、物理、化学、政治、历史、地理、生物，共有3331个问题。
示例：
若圆锥的侧面积等于其底面积的3倍，则该圆锥侧面展开图所对应扇形圆心角的度数为（ ）。
A. 60°
B. 90°
C. 120°
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb422374064ca42dc882fcf57ec4d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ea8b784b0df519b39311e0fd7b5042/" rel="bookmark">
			天玑9200&#43;相当于骁龙哪个处理器 天玑9200&#43;和天玑9000有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天玑9200+主频是3.0GHz，与骁龙 8Gen 2 相同，跑分要比骁龙 8Gen 2高一点点
天玑 9200+ 处理器与天玑 9200 同架构，但所有核心频率增加，主频来到了 3.0GHz，与骁龙 8Gen 2 相同。跑分数据，天玑 9200+ 在 Geekbench v6 平台单核得分 2121 分，多核得分 5655 分。作为对比，骁龙 8Gen 2 的单核跑分成绩在大约 2000，多核成绩大约 5400。
选玑9200+还是天玑9000这些点很重要看过你就懂了 http://www.adiannao.cn/7
天玑9200+的安兔兔跑分大约为 136 万分，骁龙8Gen2 安兔兔跑分大约是128万分。
天玑9200+和天玑9000有什么区别？
核心频率不同，CPU型号不同
天玑9200+和天玑 9000 都是联发科的5G旗舰级芯片，天玑9200+和天玑9000都是采用台积电4nm工艺制程。天玑9200+的CPU最高主频为3.3GHz，而天玑 9000 的CPU最高主频为3.2GHz。两款芯片都支持双模5G、WiFi 6E和蓝牙5. 2 等技术。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eec10bc2ec33101dac550b9374d6cd4/" rel="bookmark">
			Centos 解决执行 yum install...... 出现[Errno 14] curl#60 - “Peer‘s Certificate issuer is not recognized.“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当执行 yum install...... 出现[Errno 14] curl#60 - "Peer's Certificate issuer is not recognized." 如图所示
解决方法：
修改配置文件/etc/yum.conf，在其中加入sslverify=0，保存即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5fb2de50441b12e743da3308bea7042/" rel="bookmark">
			MATLAB三维曲面作图（六）等高线绘图（填色）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章中，我们介绍了如何绘制等高线
但上一篇用到的contour函数绘制的等高线只有区域没有颜色
如果想要填充颜色，我们需要用到contourf函数
代码如下
close all [X,Y] = meshgrid(-8:0.5:8); R = sqrt(X.^2+Y.^2)+eps; Z = sin(R)./R; [C,h]=contourf(X,Y,Z); colormap gray colorbar set(h,'ShowText','on','TextStep',get(h,'LevelStep')) 我们只替换函数本身，就可以得到图示的效果
如果注释掉gray的语句
%colormap gray 可以得到如图的效果：
另一种方法是用pcolor绘制，但此时没有等高线：
pcolor(X,Y,Z); %colormap gray colorbar 结果：
可以看出，这是将图形均匀地分为小正方形色块，并对每一个小正方形填充同样的颜色，有些类似我们在前几篇文章中介绍过的surf函数
同样的，添加下列语句使得颜色过渡更平滑：
shading interp 结果：
参考《高等光学仿真——光波导、激光》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c50a4b5ace5415efc3e0f93396872c/" rel="bookmark">
			使用vscode编写shell和python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用vscode在linux环境编写shell和python脚本 对于经常编写脚本的人来说，编写shell一般都会在vim或记事本中，这样的方式没什么问题，但遇到需要测试的时候，就没有IDE那样的方便，而且使用IDE对shell的自动补全会让效率翻倍。
此文章将讲述如何在vscode中配置Linux运行环境，让你run code即可看到输出。
安装vscode 安装vscode的方式在这就不做大篇的叙述了，百度vscode，下载安装包，点击下一步安装即可
下载地址点我
安装WSL 简单讲下WSL，这里我们将使用WSL作为脚本的运行环境
WSL是一个在Windows 10\11上能够运行原生Linux二进制可执行文件的兼容层。注意它并不是虚拟机。
步骤
右键单击windows徽标，打开Powershell（管理员），执行
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 即可将WSL功能激活。
接着在微软商店中挑一个你想用的Linux发行版
这里我选择了Ubuntu 20，直接点击安装即可。安装成功后，在开始菜单中点击运行，看看是否正常，一般第一次都需要设置用户和密码
这就是wsl Ubuntu的界面，当你正常设置好用户名和密码，出现这个节目后，说明你的WSL安装正常了
安装插件 想必大家肯定不是第一次使用vscode的人了，就直接开门见山，直说需要安装什么插件好了
Code RunnerWSLRemote - SSHShellCheckShellmanShell-format 更多好用的脚本可自行安装
这里核心的插件是WSL，这里的wsl只是一个插件，和刚才安装的不一样，这个是用来连接WSL的
此时，在新建终端时，就可以看到刚才安装的WSL，这里我把它设置成了默认
新建一个终端看看是不是WSL
此时就可以在这里的终端直接输入各类命令使用了，目录也是windows下的目录，比如上图中当前的目录为/mnt/e，就代表现在在windows 中的E盘，这里需要注意的是，访问windows的文件管理器时，都要在mnt目录下寻找，WSL将windows 下的各个盘挂载在mnt下，当然你也可以使用WSL环境的linux目录结构。
vscode中setting.json部分配置如下
Code Runner插件配置 在vscode安装好linux环境后还不能优雅的调试写好的脚本，我们希望在点击run code按钮后，终端直接执行脚本，但现在还无法做到，现在执行脚本会有如下报错：
这是因为code runner 在执行shell时不能识别WSL，这时我们就要对code runner做一些修改。
找到code runner的安装目录，插件一般放在C:\Users\用户名\.vscode\extensions
code runner的文件名是formulahendry.code-runner，进入out\src 下，找到codeManager.js，在编辑器中打开。
找到
else if (windowsShell &amp;&amp; windowsShell.toLowerCase().indexOf("bash") &gt; -1 &amp;&amp; windowsShell.toLowerCase().indexOf("windows") &gt; -1) { command = command.replace(/([A-Za-z]):\\/g, this.replacer).replace(/\\/g, "/");} 这段代码需改改成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45c50a4b5ace5415efc3e0f93396872c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b560a6154e9a41df2c68565ce73734/" rel="bookmark">
			基于趋动云部署秋葉aaaki的Stable Diffusion整合包v4--linux版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B站大V秋葉aaaki的Stable Diffusion整合V4版发布了，集成度比较高，在windows下解压缩直接就可以使用，整合的非常好。但是笔人没有RTX4090这样级别的显卡，又希望有个高速运行的效果。
所以索性到云GPU主机上来用秋叶aaaki的Stable Diffusion webui，一番研究后，在趋动云部署成功。运行良好，速度飞快。
特此分享。
一、安装包分析 秋叶aaaki的Stable Diffusion安装包下载下来后，目测主要进行了python环境的集成，以及windows下的git工具集成。这样再加上一个windows的启动器程序，就可以很好的控制环境变量的加载和一些安装包扩展组件的安装、升级等。
但是启动器在linux下是不能运行的，所以本文主要是把秋叶的V4版整合包，拿来主义的方式，在云端部署起来用起来。整体过程还算顺利。
为了减小上传云端的文件量首先要改版一下，秋叶的安装包，把里面的py310文件夹和git文件夹删掉，因为这些通常在云平台得用云平台环境的python环境和git环境。并且这2个主要是支持windows下作业的环境，上云之后都是linux，就没必要了。
干掉之后。压缩包从9.44G降到6.58G。这样就比较轻巧了！
二、思路 我们主要是希望在云平台直接使用秋叶集成好的Stable Diffusion WebUI ，并且主要是垂涎pyTorch2.0更高的性能，和秋叶用心对webui的集成成果。所以核心并不是将启动器移植到linux。而是将webui在趋动云的linux平台跑起来。
那么就要选择合适的云平台镜像，进行改造之后，操作起来就方便了！
但是和大多数AI GPU云平台一样，趋动云的GPU主机都是docker镜像的，docker镜像的开发环境都是基于python来运行jupyter来支撑在线多用户的隔离开发。而sd-webui要基于python3.10+pyTorch2.0的环境来跑，这与大多数云平台提供的python3.8/3.9存在冲突，很多奋战在一线的AIGC战友估计都有自己试过，但python的改变，往往会导致保存之后，镜像再也无法启动等问题。
所以最关键的问题就是，以官方最接近的镜像为基础，要进行miniconda的整合，并且要确保整合后形成一个带visual env条件的python环境，这样我们就可以在官方3.8或者3.9的python环境中，起一个3.10的python环境。还互不影响。
三、官方镜像分析&amp;基础镜像制作 目标确定后，我们开始研究官方镜像。目前趋动云只有一版PyTorch2.0的官方镜像，之所以要选这个，是因为我们是要跑torch to GPU的，而如果官方没有提供一个整合好CUDA和显卡驱动的基础镜像的话，由于云硬件的未知性，想要从显卡驱动+CUDA开始往上一路做到miniconda的基础镜像，是不具备信息条件的。所以只能借力发力。
经过分析，最关键是miniconda安装完成后的最后一步，会向/root/.bashrc写入conda的init环境信息，以确保镜像启动后，进入命令行就进入conda的env环境体系。但是就是这个，会破坏趋动云官方的镜像的启动机制，导致镜像保存后就无法再启动。
so，怎么办呢？
办法就是，安装完成之后，把.bashrc里最后miniconda增加的部分，剪切出来，保存到code路径下，以后每次手动运行。避开保存环节，不破坏镜像。
conda在bashrc的末尾就增加了这段儿，一定要删掉，或者剪切掉。保存到自己的code区，随便一个文本文件。注意“/usr/miniconda3”这个路径，是安装miniconda时指定的，根据你得安装路径的不同。可能会不同。
# &gt;&gt;&gt; conda initialize &gt;&gt;&gt; # !! Contents within this block are managed by 'conda init' !! __conda_setup="$('/usr/miniconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)" if [ $? -eq 0 ]; then eval "$__conda_setup" else if [ -f "/usr/miniconda3/etc/profile.d/conda.sh" ]; then . "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b560a6154e9a41df2c68565ce73734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfaf6f6f3f6b2328b981bdb38d9bd6b/" rel="bookmark">
			【Vue工程】009-Plop 代码生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Vue工程】009-Plop 代码生成器 文章目录 【Vue工程】009-Plop 代码生成器一、概述1、简介2、官方文档 二、基本使用1、安装2、根目录创建 `plopfile.js`3、创建 plop-templates 目录4、`package.json` 增加脚本5、使用 一、概述 1、简介 Plop 是一个用于生成代码文件的可配置的脚手架工具。它可以帮助开发人员自动创建代码文件、模板和代码片段，从而提高开发效率。
Plop 的工作原理是通过定义称为 “生成器”（generators）的脚本来生成代码文件。每个生成器定义了一组操作和模板，用于生成特定类型的文件或代码片段。当你运行 Plop 命令时，它会根据你的选择执行相应的生成器，并根据模板和操作的定义创建文件。
2、官方文档 https://plopjs.com/documentation/
二、基本使用 1、安装 pnpm add plop -D 2、根目录创建 plopfile.js module.exports = function (plop) { plop.setWelcomeMessage('请选择需要创建的模板：') plop.setGenerator('page', require('./plop-templates/page/prompt.cjs')) // 增加其他模板 // plop.setGenerator('page1', require('./plop-templates/page1/prompt.cjs')) // plop.setGenerator('page2', require('./plop-templates/page2/prompt.cjs')) } 3、创建 plop-templates 目录 模板文件：plop-templates/page/page.hbs
&lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; // 一、引入 // 二、数据 // 三、逻辑 // 四、钩子 // 五、其他 &lt;/script&gt; &lt;style lang="scss" scoped&gt;&lt;/style&gt; 脚本文件：plop-templates/page/prompt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cfaf6f6f3f6b2328b981bdb38d9bd6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0eb6ca0b746e3bc4166435839355bbe/" rel="bookmark">
			23种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 引言:什么是设计模式1.创建型模式1.1 单例模式1.1.1 饿汉式1.1.2 懒汉式 1.2 工厂方法模式1.2.1 简单工厂模式1.2.2 工厂方法模式 1.3 抽象工厂模式1.4 建造者模式1.4.1 普通的创建方案1.4.2 建造者模式的解决方案 2.结构型模式2.1 适配器模式2.2 引言:什么是设计模式 设计模式是解决软件开发某些特定问题而提出的一些解决方案, 也可以理解为解决特定问题的思路, 通过设计模式可以增强代码的可重用性、可扩充性、可维护性、灵活性等等. 使用设计模式的目的是实现代码的解耦和高内聚
设计模式的三大类以及关键点
设计模式概述 以及 23种设计模式的介绍
1.创建型模式 对象实例化的模式，创建型模式用于解耦对象的实例化过程。
单例模式：某个类智能有一个实例，提供一个全局的访问点。工厂模式：一个工厂类根据传入的参量决定创建出哪一种产品类的实例。抽象工厂模式：创建相关或依赖对象的家族，而无需明确指定具体类。建造者模式：封装一个复杂对象的创建过程，并可以按步骤构造。原型模式：通过复制现有的实例来创建新的实例。 1.1 单例模式 一、单例模式常见的三种实现方法
饿汉式懒汉式 二、单例模式的特点
单例类只能有一个实例单例类必须自己创建这个实例单例类必须向整个系统提供这个实例 三、单例模式的应用场景
单例模式确保某个类有且只有一个实例, 且自行实例化后向整个系统提供这个实例.
在计算机系统中, 线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计为单例. 这些应用都或多或少的具有资源管理器的功能, 每台计算机可以有若干个打印机, 但只能有一个PrinterSpooler, 避免两个打印作业同时输出到打印机中. 总而言之, 单例模式就是为了避免不一致的状态.
1.1.1 饿汉式 一、优点:
没有任何锁, 执行效率高, 用户体验比懒汉式更好
二、缺点:
类加载的时候就初始化, 不管用不用都占用内存空间
三、建议: 适用于单例模式较少的场景
如果我们在项目启动后, 一定会加载到类, 那么用饿汉式既简单又实用,
如果我们是写一些工具类, 则优先考虑懒汉模式, 可以避免提前被加载到内存, 占用系统资源
四、代码案例:
public class HungryMan { /** * static保证类加载时成员变量, 静态成员变量存放于方法区 * *局部变量:在方法内部声明的变量, 只在这个方法内部有效, 出了这个方法就无法使用了, 可以理解为销毁了 * *实例变量:没有使用static修饰的成员变量, 它在每一个实例化对象中都是独立的, 每个对象修改其值后, 只是修改了自己的实例变量, 其他对象 * 中的实例变量不受影响(每个对象的实例对象都有独立的内存, 它们互不影响) * *类变量(静态变量):使用static修饰的成员变量, 所有实例对象共享此变量(所有实例对象使用的类变量, 都指向同一个内存) * final保证此实例对象不支持被重新赋值 */ private final static HungryMan hungryMan = new HungryMan(); static { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0eb6ca0b746e3bc4166435839355bbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595ceba85d46b241a410a2d0c91cf736/" rel="bookmark">
			vue3使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3使用指南 主要介绍vue3的使用，同时会涉及到vue2，并会讲解其中的一些差异。
安装 CDN引入 如果想快速体验，可以直接通过cdn进行引入。
&lt;div id="app"&gt;{{msg}}&lt;/div&gt; &lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt; &lt;script &gt; Vue.createApp({ data() { return { msg: 'Vue3' } } }).mount('#app') &lt;/script&gt; 通过 CDN 引入 Vue 时，由于不涉及到构建步骤，可以使得设置更加简单，并且可以用于增强静态的 HTML 或与后端框架集成。但是这也意味着无法使用SFC（单文件）语法。
使用es模块构建 现代浏览器大多都已原生支持 ES 模块，可以像这样通过 CDN 以及原生 ES 模块使用 Vue。
&lt;div id="app"&gt;{{msg}}&lt;/div&gt; &lt;script type="module"&gt; import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js' createApp({ data() { return { msg: 'Vue3' } } }).mount('#app') &lt;/script&gt; 使用import maps &lt;div id="app"&gt;{{msg}}&lt;/div&gt; &lt;script type="importmap"&gt; { "imports": { "vue": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595ceba85d46b241a410a2d0c91cf736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22601f45b7f6444b9f4660efb346591/" rel="bookmark">
			Linux 进程管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps查看当前系统进程状态
1)基本语法
ps aux | grep xxx 功能描述:查看系统中所有进程
ps -ef | grep xxx 功能描述:可以查看子父进程之间的关系
2)选项说明 选项功能a列出带有终端的所有用户的进程x列出当前用户的所有进程 包括没有终端的进程u面向用户友好的现实风格-e列出所有进程-u列出某个用户关联的所有进程-f现实完整格式的进程列表 3)功能说明
①ps aux显示信息说明
USER:该进程是由哪个用户产生的
PID:进程的ID号
%CPU 占用的CPU资源的百分比 占用越高 进程越耗费资源
%MEN 占用的内存使用率 占用越高 进程越耗费资源
VSZ Virtual Memory Size 占用虚拟内存大小 单位KB
RSS Resident Set Size 占用实际内存大小 单位KB
TYY 该进程是在哪个终端中运行的 对于centos来说 tty1是图形化终端 tty2-tty6是本地的字符界面终端 pts/0-255代表虚拟终端
STAT: 进程状态
R:运行状态
S: 睡眠状态
T: 暂停执行
Z: 不存在但暂时无法消除(僵尸状态)
s:包含子进程
l:多线程
+：前台显示
START:该进程的启动时间
TIME:该进程占用CPU的运算时间 注意不是系统时间
COMMAND:产生此进程的命令名
②ps -ef显示信息说明
UID: 该进程执行的用户id
PID: 进程id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a22601f45b7f6444b9f4660efb346591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852081c7e01062b65adbfc32f037d062/" rel="bookmark">
			【shell脚本里的命令】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、sort命令1.1、命令演示 二、unip命令1、命令演示1、列题:2、使用脚本来查看用户有没有被恶意登录，查看登录用户的对应ip地址 三、tr命令1.1、命令演示1.2、使用tr命令对数组进行排序 四、从Windows里拉文件到Linux系统中要做的潜在条件五、cut命令六、split命令1.1、文件拆分 七、paste命令八、eval命令 一、sort命令 sort命令—以行为单位对文件内容进行排序，也可以根据不同的数据类型来排序比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。
语法格式: sort [选项] 参数（文件排序） cat 文件名 | sort 选项 常用选项命令解释-n按照数字进行排序-r反向排序-u等同于unig，表示相同的数据仅显示一行-t指定字段分隔符，默认使用 [Tab]键分隔-k指定排序字段-o &lt;输出文件&gt;将排序后的结果转存至指定文件-f忽略大小写，会将小写字母都转换为大写字母来进行比较-b忽略每行前面的空格 1.1、命令演示 1、不加上-n，只会看首个字符来排序
[root@dz666 ~]# sort shuzi.txt 1 10 100 155 177 2 3 333 333 35 444 444 75 2、加上-n后就会按大小来排序
[root@dz666 ~]# sort shuzi.txt -n 1 2 3 10 35 75 100 155 177 333 333 444 444 3、加上-r后就是用反向排序
[root@dz666 ~]# sort shuzi.txt -n -r 444 333 333 177 155 100 75 35 10 3 2 1 4、使用-u后将重复的行内容都压缩在一行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852081c7e01062b65adbfc32f037d062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea230ab534b177a4c4bca733a586c79e/" rel="bookmark">
			怎么把图片变清晰？图片变清晰方法分享。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么把图片变清晰？图片变清晰可以指的是一种利用图像处理技术，对低质量或模糊的图片进行增强和改善的过程，这种技术可以通过各种算法和方法来实现，包括锐化、去噪、缩放、超分辨率等，那么小伙伴们该选择什么软件进行我们的图片变清晰呢，下面一起来看看吧！​
选择：一键抠图​
一键抠图APP是一款基于计算机视觉和深度学习技术，能够自动快速地将图片中的前景和背景分离，实现抠图功能的手机应用程序，当然里面的功能也是非常多的，像我们的照片变清晰就完全可以做到，需要我们找到图片变清晰功能，打开上传我们的照片就可以了！​
选择二：迅捷图片转换器​
迅捷图片转换器是一款能够将各种常见图像格式之间相互转换的工具软件，它可以支持将多种不同格式的图像文件进行批量转换，如JPEG、PNG、BMP、GIF、TIFF等，当然其中的功能也是非常多的，我们可以直接用它的“几乎人脸修复”功能，专门用来修复模糊的照片。​
选择三：jpgHD​
这是一个在线人工智能照片修复网站，不仅可以修复模糊的照片，还支持自定义照片的分辨率，并且图片上色、去噪等功能都不是问题。​
照片变清晰是一种非常实用的技术，可以提高图像质量和可读性，使我们更好地处理和管理数字照片，并发掘出更多有价值的信息和细节​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45db51ef2c746f9620e5d7ccfb200bbb/" rel="bookmark">
			【论文阅读】SAM医学图像分割近期工作综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How Segment Anything Model (SAM) Boost Medical Image Segmentation?
论文：[2305.03678] How Segment Anything Model (SAM) Boost Medical Image Segmentation? (arxiv.org)
仓库：https://github.com/yichizhang98/sam4mis
摘要： 在这项工作中，我们总结了近期工作中以扩展 SAM 医疗图像分割的任务，包括经验基准和方法的调整，并讨论了潜在的未来方向的 SAM 在医疗图像分割。
SAM：略
SAM在医学图像上分割效果： 病理图像分割：在WSI图像上肿瘤分割、非肿瘤组织分割、细胞核分割。单个正点提示、20正+10负、每个实例所有的点/框，在大型联通物体上效果好，密集实例物体效果差。可能的原因包括 WSI 的图像分辨率明显高于 SAM 的训练图像分辨率，以及数字病理学中不同组织类型的多尺度。
基于CECT的肝肿瘤分割：提示点越多，性能越好，但是和UNet相比仍有差距。
结肠镜图像中的息肉分割：低于现有方法。可能是由于息肉和周围粘膜界限模糊。
大脑MRI分割：SAM 可以获得与 BET 相当甚至更好的性能。
腹部CT器官分割：随机选1，3，10个点，抖动为0.01，0.05，0.1，0.25，0.5以模拟不同用户的不确定性。尽管使用点提示的 SAM 表现不佳，平均 Dice 相似系数(DSC)下降20.3% 至40.9% ，但使用方框提示，即使在中度(0.1)抖动的情况下也能获得高度竞争性的表现。
内窥镜手术器械分割：缺乏提示时分割结果较差，当仪器重叠或者只有一个点作为提示时，SAM 无法预测仪器的某些部分。此外，SAM 在复杂的手术情况下也不能识别器械，如血液、反射、模糊和阴影。
其他多数据集评估：略
另外，segment anything model for medical images【11】收集了52个公开数据集，建立了一个大规模数据集COSMOS 553K，包括16种模式，68个目标和553K张图。研究发现，当背景点与前景点相似时，负面点的加入会使任务绩效略有下降。
如何更好的将SAM适配到医学图像分割？ 扩展 SAM 在医学图像中的可用性。与传统的自然图像不同，医学图像大多采用 NII 和 DICOM 等特定格式。[ A 3d slicer integration to sam ]将 SAM 扩展到常用的医学图像查看器中，使用3D Slicer ，使研究人员能够在仅0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45db51ef2c746f9620e5d7ccfb200bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b6a5bd146f01f801f388af0764c01f/" rel="bookmark">
			(vue)el新增弹窗关闭清空文件上传列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(vue)el新增弹窗关闭清空文件上传列表 ： // 1.绑定ref &lt;el-upload ref="mYupload"&gt; // 2.清空列表方法 clearFiles() { this.$refs["mYupload"].clearFiles(); //延伸-清空表单 //this.$refs["ruleForm"].resetFields(); }, // 3.成功后调用 addDocument(this.uploadForm, fd).then((res) =&gt; { if (res.data.code == 200) { this.clearFiles(); } }); 效果 ：
修改后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f7619fab9ded6275920e2a0fbee696/" rel="bookmark">
			SpringSecurity的自定义授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补充一个小问题 @PreAuthorize("hasAuthority('sys:admin:list')") @RequestMapping("/more") public String more(){ return "success"; } 这段权限代码中，必须使用public修饰符，如果使用private则权限设置会失效
1.1 思路分析 LoginUser类 1.在LoginUser类中新增一个List&lt;String&gt;属性一个List&lt;GrantedAuthority&gt;属性，包含着权限信息
2.重写getAuthorities()方法（因为权限信息需要从该方法中取得），将List&lt;String&gt;封装到List&lt;GrantedAuthority&gt;中对应getAuthorities方法的返回值。
3.对List&lt;GrantedAuthority&gt;属性取消JSON序列化，否则反序列化会出错
UserDetailServiceImpl类 1.补充获取权限方法，这里先给出权限，后续会从数据库中查询。返回loginUser对象
JwtAuthoriTokenFilter类 1.在对应权限获取的构造方法中，利用getAuthorities()方法传递权限，封装到SecurityContextHolder中等待被访问。
SecurityConfig 1.开启权限。@EnbaleGlobalMethodSecurity(prePostEnabled=true)
SecurityController类
1.添加注解权限@PreAuthorize("hasAuthority('sys:test')")
1.2 实现 在domain类中新增权限集合属性
去权限并封装带LoginUser中
将获取LoginUser中权限信息并封装到Authentication对象中，最终封装到 SecurityContextHolder中。因为其他过滤器会从中取得用户信息
开启权限校验
设置权限字符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f67998f96a2d94aa93258d2b14db04e/" rel="bookmark">
			Apache的运行过程和参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是ApacheApache 使用的协议Apache的每次资源访问的工作原理 （也就是三次握手和四次挥手）Apache的工作模式Apache的一次完整的请求过程Apache的进程模型和特性配置文件详解 什么是Apache Apache是一种开源的Web服务器软件，它可以在不同的操作系统上运行，如Linux、Unix、Windows等。Apache可以处理HTTP请求，并将Web页面发送给客户端浏览器。它也可以支持动态内容的生成，如PHP、Perl等脚本语言。Apache具有高度的可配置性和扩展性，因此被广泛用于Web应用程序的开发和部署
Apache 使用的协议 Apache使用的是HTTP协议，即超文本传输协议。HTTP协议是一种应用层协议，它是Web应用程序的基础。HTTP协议定义了客户端和服务器之间的通信规则，包括请求和响应的格式、状态码、缓存机制等。Apache作为Web服务器，可以处理HTTP请求，并将Web页面发送给客户端浏览器，以实现Web应用程序的功能。
apache默认占用的端口是80端口也可以进行 修改
/etc/httpd/conf/httpd.conf
·
Apache的每次资源访问的工作原理 （也就是三次握手和四次挥手） 三次握手和四次挥手是 TCP 协议中的两个重要概念。
三次握手 三次握手是指在 TCP 连接建立时，客户端和服务器之间需要进行三次交互，以确保双方都能收到对方的信息。具体步骤如下：
第一次握手：客户端向服务器发送 SYN 报文段，并设置初始序列号（ISN）。第二次握手：服务器收到客户端的 SYN 报文段后，向客户端发送 SYN+ACK 报文段，并设置确认序列号（ACK）为客户端的 ISN+1，同时设置自己的 ISN。第三次握手：客户端收到服务器的 SYN+ACK 报文段后，向服务器发送 ACK 报文段，并设置 ACK 序列号为服务器的 ISN+1。 通过三次握手，双方都能确认对方的 IP 地址、端口号和初始序列号，建立起可靠的 TCP 连接。
四次挥手 四次挥手是指在 TCP 连接关闭时，客户端和服务器之间需要进行四次交互，以确保双方都能正常关闭连接。具体步骤如下：
第一次挥手：客户端向服务器发送 FIN 报文段，表示客户端已经没有数据要发送了。第二次挥手：服务器收到客户端的 FIN 报文段后，向客户端发送 ACK 报文段，表示已经收到客户端的 FIN 报文段。第三次挥手：服务器向客户端发送 FIN 报文段，表示服务器已经没有数据要发送了。第四次挥手：客户端收到服务器的 FIN 报文段后，向服务器发送 ACK 报文段，表示已经收到服务器的 FIN 报文段。 通过四次挥手，双方都能正常关闭连接，释放相关资源。
需要注意的是，三次握手和四次挥手是 TCP 协议中保证可靠性的重要机制，但也会造成一定的延迟和资源浪费
用一个搞笑的案例来说明三次握手
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f67998f96a2d94aa93258d2b14db04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147702a6b85dd8fb3e3c8585dab54346/" rel="bookmark">
			scala基础编程案例--定义一个类Rational支持有理数的运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、案例要求2、实现思路3、完整代码4、总结 1、案例要求 1）定义一个类Rational，分子与分母作为类参数；
2）重写toString方法；
3）前提条件检查（分母是否为0检查）；
4）定义add方法实现两个有理数相加；
5）为 Rational 定义一个辅助构造函数，当分母为1时调用该辅助构造函数；
6）定义一个求分子分母最大公约数的方法，用于有理数的简化。
2、实现思路 1）定义一个类Rational，分子与分母作为类参数；
//有理数类 class Rational(n: Int, d: Int) {} 2）重写toString方法；
//重写打印函数 override def toString: String = { if (denominator != 1) numerator + "/" + denominator else numerator+"" } 3）前提条件检查（分母是否为0检查）；
//分母要求不能为0 require(d != 0) 4）定义add方法实现两个有理数相加；
//实现分数加法函数 def add(that: Rational): Rational = { new Rational(numerator * that.denominator + denominator * that.numerator, denominator * that.denominator) } 5）为 Rational 定义一个辅助构造函数，当分母为1时调用该辅助构造函数；
//辅助构造函数：若只传入一个参数，则构建n/1 def this(n:Int) = this(n, 1) 6）定义一个求分子分母最大公约数的方法，用于有理数的简化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/147702a6b85dd8fb3e3c8585dab54346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2d54bc4f6a1a7e2ddf2e19d21f96e1/" rel="bookmark">
			ppt出现图片无法裁剪的现象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅作为记录，大佬请跳过。
背景 博主想将图片裁剪，右键后发现没有裁剪的选项。
解决 图片是组合状态，右键点击图片，取消组合即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408052bb7174f46df9b6a9ce8f032085/" rel="bookmark">
			贪心算法【TSP问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心简介： 只看下一次选择，比如：我需要做完一张数学试卷，我哪到试卷后做题，就先选择我最熟悉的，做完后选择我会的，最后尝试难题！每一个阶段都选择当前最优的解；
注意：我们选择的只是当前阶段的最优解，所有整体上不一定是最优解；
TSP+贪心 题目简介： TSP问题（旅行家问题）：旅行家旅行n个城市，要求每个城市仅经过一次，最后返回出发城市
选择算法：贪心算法 选择原因：每次选取到达城市代价最小的城市，当城市数量教下时，算法将近似最优解。
方便实现、复杂度较低
解决问题： 第一步：（建图） TSP问题需要用到图，因此第一步为建图
建图（建立代价矩阵）
例：
∞ 3 3 2 6
3 ∞ 7 3 2
3 7 ∞ 2 5
2 3 2 ∞ 3
6 2 5 3 ∞
第二步： 确定起点和终点，并且将终点标记，下次选择不再选择
例：
标记 : 1
1 -&gt; 4 代价：2 标记 ：4
4 -&gt; 3 代价：2 3
3 -&gt; 5 代价：5 5
5 -&gt; 2 代价：2 2
回到起点 ：
（因为第一步就将1标记，无法返回需要单独添加）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/408052bb7174f46df9b6a9ce8f032085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36873308aae9723bce2975eb8e15926a/" rel="bookmark">
			ppt快速回到某页（幻灯片放映时）【实测成功】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅作为记录。
感谢大佬博主文章：传送门
即“在幻灯片放映过程中，在键盘按一下需要跳转的页面编号，再按回车键就会快速跳转到那一页。”
在未放映时，点击office的ppt的右下角图标，在所有幻灯片中进行选择，双击即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc521576e10750f21903cc0a075992ba/" rel="bookmark">
			32【简单】颠倒二进制位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目描述 颠倒给定的 32 位无符号整数的二进制位。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
二、解题思路过程 class Solution: def reverseBits(self, n: int) -&gt; int: s = str(bin(n)[2:].zfill(32)) # 将n转为32位字符 return int(s[::-1], base=2) # 反转后转为10进制 三、复杂度分析 时间复杂度：
空间复杂度：，使用的额外空间复杂度为常数。
四、题目来源 来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/reverse-bits
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce152ddbdbe015313e9ae7d1b2bb93a3/" rel="bookmark">
			scoop提速：解决scoop软件下载慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 安装scoop2 使用scoop加速下载软件2.1 如何加速下载软件2.2 编写powershell函数2.2.1 安装、更新、搜索软件2.2.2 卸载软件2.2.3 查看已安装软件 相比于linux系统，windows缺少一个比较好用的包管理器，而第三方包管理器scoop则在一定程度上解决了这个问题，但是在使用scoop的过程中，往往会由于网络的原因使得软件的安装失败。下面介绍一个方法解决这个问题。
1 安装scoop 打开 powershell
Set-ExecutionPolicy Bypass -Scope CurrentUser iwr -useb https://gitee.com/fanyi-ff/poocs/raw/master/install-scoop.ps1 | iex 2 使用scoop加速下载软件 2.1 如何加速下载软件 PS &gt; scoop help install Usage: scoop install &lt;app&gt; [options] e.g. The usual way to install an app (uses your local 'buckets'): scoop install git To install an app from a manifest at a URL: scoop install https://raw.githubusercontent.com/ScoopInstaller/Main/master/bucket/runat.json To install an app from a manifest on your computer scoop install \path\to\app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce152ddbdbe015313e9ae7d1b2bb93a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b38d8ab18e82c8f8ff84b937aa62b6a/" rel="bookmark">
			三种方法教你让模糊照片秒变高清图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在随着数字相机和智能手机的普及，我们拍摄的照片数量越来越多，但是有些照片可能因为环境或技术等原因导致模糊不清，这时候我们就需要使用一些软件或工具来让照片变得清晰，以满足我们的需求。
下面介绍三种常用的照片变清晰的方法：
1.使用记灵在线工具 记灵在线工具提供了图片变清晰的工具，具体操作如下：
第一步，打开记灵在线工具，选择“图片变清晰”工具打开。
第二步，进入新的页面，点击“选择文件”选择需要变清晰的图片文件。
第三步，等待服务器处理完成，下载处理变清晰后的图片文件。
2.使用Photoshop Photoshop是一款非常强大的图像处理软件，也可以用于照片的修复和变清晰，具体操作如下：
第一步，将图层转换为智能对象。根据界面提示，选择“滤镜”-“锐化”-“USM锐化”，然后对参数进行调整。
第二步，相应还原对比度，可以对数据和半径进行调整，控制像素的对比度指的是数量，图像边缘像素的调整指的是半径，可以调整“阈值”参数，也就是对“数量”和“半径”的修复。从而达到图片变清晰的功效。
3.使用WPS（电脑端） WPS也提供了照片变清晰的功能，具体操作如下：
第一步，选择一张模糊图片，右击选择功能“查看更多图片工具”。
第二步，点击图片工具里面的裁剪，选择相应色彩。调整参数（调整亮度，增强视觉效果。调整对比度，直到调整到合适的值为止，对比图片，调整饱和度），设置成功之后，打开即可。
以上就是三种常用的照片变清晰的方法，使用这些软件或工具可以轻松地修复模糊的照片，让它们变得更加清晰，更好地满足我们的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe6f06acf7ff399a77482647c5e01c2/" rel="bookmark">
			GET http://pcapi-xiaotuxian-front-devtest.itheima.net/category--post请求却变成get请求的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写项目时被这个错误给整懵了，刚开始以为是接口的问题，后来测试发现接口没有问题，就离谱，错误如下图，
经过分析，我的代码是post请求，并且这个接口也只能使用post请求，使用get请求就会报错，如下，说明我的post没起作用，那么错误应该出现在request.js里面，果然，由于自己粗心，回车时method写成的methods,导致post请求失败。
原代码:
修改后： 结果：
就好了，哎，自己真的太粗心了，希望我这个错误对你们有帮助~ 奥利给！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026709c482862c9ab80146b0905ddb1f/" rel="bookmark">
			NS-3 优化技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Logging系统
（1）通过环境变量修改记录系统等级
通过修改脚本代码的方法可以起到修改Logging等级的效果，但是每一次都要修改代码，对于用户来说是不愿看到的，Logging系统模块提供了通过修改环境变量的方法来修改记录系统等级。使用方法就是在编译脚本前使用export命令修改NS_LOG的值，比如针对first.cc，在终端输入：export 'NS_LOG=UdpEchoClientApplication=level_all:UdpEchoServerApplication=level_all'
export是命令，第一个“=”为复制符号，“=”左面NS_LOG为要设置的环境变量，“=”右面的UdpEchoClientApplication=level_all是要复制给左值的字符串，使用level_all等级意味着要显示全部的调试信息。
（2）添加附加前缀
首先添加prefix_func来为每一条信息显示其产生函数，在每一条信息前都会有一个函数前缀
export 'NS_LOG=UdpEchoClientApplication=level_all|prefix_func:UdpEchoServerApplication=level_all|prefix_func' 通过记录系统的输出信息来分析仿真程序中各个函数调用的时间以及各个事件的发生时间，每一条信息的最前面会显示其产生时间
export 'NS_LOG=UdpEchoClientApplication=level_all|prefix_func|prefix_time:UdpEchoServerApplication=level_all|prefix_func|prefix_time' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfa4a1def51bd8df75803a569f459f2/" rel="bookmark">
			Nginx配置反向代理时排除指定路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx配置反向代理时排除指定路径，示例配置如下：
location /api/ { return 404; } 以上配置将匹配所有以 /api/ 开头的请求，并返回 404 响应，从而实现排除该路径下的所有请求。
如果需要同时排除多个路径，可以在 location 指令中使用正则表达式。例如，以下配置将排除以 /api/ 或 /admin/ 开头的所有请求：
location ~ /(api|admin)/ { return 404; } 其中，~ 表示使用正则表达式进行匹配，| 表示或者的意思。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/568ca90f6f99deaa6ea9dd9b7e633340/" rel="bookmark">
			学习PCL库：PCL库中的geometry模块介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号致力于点云处理，SLAM，三维视觉，高精地图等领域相关内容的干货分享，欢迎各位加入，有兴趣的可联系dianyunpcl@163.com。未经作者允许请勿转载，欢迎各位同学积极分享和交流。
geometry模块介绍
PCL库中的geometry模块主要提供了点云几何计算的工具，geometry模块提供了点云和三维网格（mesh）处理的一些基本算法和数据结构。
学习PCL库：PCL库中filters模块
学习PCL库：PCL库中surface模块
学习PCL库：PCL库中实现了哪些分割算法？
学习PCL库需要知道哪些知识？
学习PCL库：基于LOD的大规模点云可视化
学习PCL库你应该知道的C++特性
学习PCL库：PCL库中的IO模块介绍
主要内容
pcl::LineIterator
用于在3D点云中沿直线迭代遍历点，它的原理是根据输入的起点和终点，计算出沿直线的总距离，并将该距离分为多个步长,在每个步长中，通过线性插值计算出当前迭代位置的坐标，并在点云中查找最近的点。该类的实现方法使用了线性插值、最近邻搜索等算法。主要成员函数包括：
pcl::LineIterator(const PointT &amp;start, const PointT &amp;end, double distance = 0.005)：构造函数，输入起点和终点坐标以及迭代的步长距离。
bool isValid() const：判断当前迭代位置是否合法。
const PointT&amp; operator*() const：返回当前迭代位置的3D坐标。
LineIterator&amp; operator++()：将迭代器推进到下一个位置。
其中，isValid()函数用于判断当前迭代位置是否越界，operator*()函数用于返回当前迭代位置的点云坐标，operator++()函数用于将迭代器推进到下一个位置。
pcl::geometry::MeshBase
用于表示三维网格模型的基础类，该类是一个抽象类，提供了访问和操作三角形网格模型的接口，如获取点云、三角形面片、法线等。pcl::geometry::MeshBase类的数据结构是基于半边结构的（Half-Edge Structure），该数据结构用于描述三角形网格的拓扑关系，包括点、边和面的关系，使得对网格模型的操作更加高效。其中，半边（Half-Edge）是一个有向的边，从一个顶点指向相邻的另一个顶点，并指向下一条半边，组成了一个环（Loop）。在pcl::geometry::MeshBase中，使用Vertex表示网格模型中的顶点，其中包含了三维坐标信息和一些额外的属性；使用HalfEdge表示网格模型中的半边，其中包含了顶点索引、边的索引和相邻的下一条半边的索引；使用Face表示网格模型中的三角形面片，其中包含了三个半边的索引和面片法向量。该类提供了一系列用于访问和操作三角形网格模型的接口函数，包括：
* getPointCloud()：获取网格模型的点云数据；
* getTriangles()：获取网格模型的三角形面片数据；
* computeBoundingBox()：计算网格模型的边界框；
* computeNormals()：计算网格模型的法线；
* triangulate()：对网格模型进行三角剖分；
* mergeVertices()：合并重复的顶点；
* removeVertices()：删除指定的顶点；
* removeFaces()：删除指定的面片；
* removeDegenerateFaces()：删除包含重复顶点或长度为0的边的面片。
此外，pcl::geometry::MeshBase还提供了一些用于获取和设置网格模型数据结构的接口函数，如获取点、半边和面的数量，获取指定索引的点、半边和面，以及添加新的点、半边和面等。
pcl::geometry::VertexAroundVertexCirculator
pcl::geometry::VertexAroundVertexCirculator 实现点云网格处理的重要类之一，用于迭代遍历给定点的所有相邻点。该类的实现基于半边数据结构 (Half-Edge Data Structure) ，半边数据结构是一种用于表示三维多面体和网格的数据结构。通过构建这种数据结构，可以轻松访问点、边、面以及相邻的实体，并对它们进行操作。半边数据结构中的每条半边都存储了以下信息：
该半边的起始点
该半边所在的面
该半边的下一条半边
该半边的对称半边
pcl::geometry::VertexAroundVertexCirculator 封装了半边数据结构的迭代器，以实现点云网格处理的相关操作。通过使用 pcl::geometry::VertexAroundVertexCirculator 迭代器，可以轻松遍历给定点的所有相邻点，实现点云网格处理中的相关操作，例如法向量计算和邻域点云特征提取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/568ca90f6f99deaa6ea9dd9b7e633340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30633337d966a57548c5ced18b6f7305/" rel="bookmark">
			golang标准库之log日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、log包简介 golang内置了log包，通过调用log包的函数，可以实现简单的日志打印功能。
log包还定义了Logger类型，提供了一些格式化输出的方法。也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用,比自行创建一个logger对象更容易使用,它们会将日志信息打印到终端界面;
二、log包使用 2.1 log.Print/Println/Printf函数 仅打印日志。
package main import ( "log" ) func main() { log.Print("Print: hello") //直接打印 log.Println("Println: hello pob") //打印并换行 log.Printf("Printf:hello %s", "alice") //格式化打印（可加变量） } 运行结果
@deMacBook-Pro learning % go run go_package.go 2023/05/09 09:37:45 Print: hello 2023/05/09 09:37:45 Println: hello pob 2023/05/09 09:37:45 Printf:hello alice Printf格式化输出，%(占位符)字母解析:
占位符说明举例输出%v相应值的默认格式name := “张三”, fmt.Printf(“%v”, name)张三%+v打印结构体时，会添加字段名Printf(“%+v”, people){Name:zhangsan}%%字面上的百分号，并非值的占位符Printf(“%%”)%%t布尔值 ，true 或 falsePrintf(“%t”, true)true%d整数,十进制表示Printf(“%d”, 0x12)18%s字符串和字节片（string类型或[]byte),输出字符串表示Printf(“%s”, []byte(“Go语言”))Go语言％f打印float类型，默认宽度，默认精度log.Printf(“%.2f”, 11.222222)11.22 eg：
package main import ( "log" ) func main() { type peplo struct { Name string Age int } var ppp peplo ppp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30633337d966a57548c5ced18b6f7305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ace25313ac42924280024c66a92d870/" rel="bookmark">
			Microsoft Edge崩溃，错误代码: status_stack_buffer_overrun
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：Edge浏览器升级后，打开网页都报错，如何解决？ - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e310c2fb6be67d367b7a1de81727722d/" rel="bookmark">
			西南交通大学算法分析与设计实验5.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅给出实现的代码，代码仅经过简单的样例测试，不保证逻辑完全正确。
#include "iostream" using namespace std; int n, m, result; // 标记该位置是否为大厦 int house[1001][1001]; // dp数组 int dp[1001][1001]; // 两个点是否被大厦阻挡 int Check(int x, int y, int x1, int y1) { bool left_up_1 = house[x - 1][y - 1]; bool left_down_1 = house[x][y - 1]; bool right_up_1 = house[x - 1][y]; bool right_down_1 = house[x][y]; bool left_up_2 = house[x1 - 1][y1 - 1]; bool left_down_2 = house[x1][y1 - 1]; bool right_up_2 = house[x1 - 1][y1]; bool right_down_2 = house[x1][y1]; if (x == 0) { left_up_1 = false; right_up_1 = false; } if (y == m) { right_up_1 = false; right_down_1 = false; } if (x1 == 0) { left_up_2 = false; right_up_2 = false; } if (y1 == m) { right_up_2 = false; right_down_2 = false; } // 两个点有一个在大厦内部 if ((left_up_1 &amp;&amp; left_down_1 &amp;&amp; right_up_1 &amp;&amp; right_down_1) || (left_up_2 &amp;&amp; left_down_2 &amp;&amp; right_up_2 &amp;&amp; right_down_2)) { return 1; } // 左右阻挡 if ((left_up_1 &amp;&amp; left_down_1 &amp;&amp; right_up_2 &amp;&amp; right_down_2) || (left_up_2 &amp;&amp; left_down_2 &amp;&amp; right_up_1 &amp;&amp; right_down_1)) { return 1; // 上下阻挡 } else if ((right_up_1 &amp;&amp; left_up_1 &amp;&amp; right_down_2 &amp;&amp; left_down_2) || (right_up_2 &amp;&amp; left_up_2 &amp;&amp; right_down_1 &amp;&amp; left_down_1)) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e310c2fb6be67d367b7a1de81727722d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c579e8922b3757107df43250ee0924a6/" rel="bookmark">
			Vue项目启动报错：error:cannot find module xxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：无法找到项目依赖的某个模块
解决办法：
1、删掉存放模块的文件夹node_module；
2、执行清除缓存命令 npm cache clean；
如果报错，使用强制清除npm cache clean --force；
如果还报错，删除package-lock.json文件；
3、重新安装模块，npm install；（会重新自动生成package-lock.json文件）
然后npm run serve重启就可以了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/78/">«</a>
	<span class="pagination__item pagination__item--current">79/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/80/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>