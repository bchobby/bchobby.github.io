<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/073070b3ca0c269d65ff24f0dfd676ff/" rel="bookmark">
			阿里linux体验馆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天发现了一个好玩的东西跟大家分享一下
可以做linux实验 例如配置zabbix 下面的命令是阿里云给的配置
1 安装 Zabbix 仓库 rpm -Uvh https://repo.zabbix.com/zabbix/5.4/rhel/8/x86_64/zabbix-release-5.4-1.el8.noarch.rpm 2 . 安装 Zabbix Server、Web 前端、Agent yum install zabbix-server-mysql zabbix-web-mysql zabbix-apache-conf zabbix-sql-scripts zabbix-agent -y 3 安装 MySQL 数据库 yum install -y mariadb-server systemctl start mariadb systemctl enable mariadb 4 执行如下命令，初始化数据库。 mysql_secure_installation 5 创建 Zabbix 所用数据库 在命令行中输入 mysql -uroot -p ，并输入密码，登录 MySQL 数据库。 在 mysql shell 当中输入如下代码，创建一个名为 zabbix 的数据库，并创建一个名为zabbix，密码为 password 的用户，用于管理 zabbix 数据库。 create database zabbix character set utf8 collate utf8_bin; create user zabbix@localhost identified by 'password'; grant all privileges on zabbix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/073070b3ca0c269d65ff24f0dfd676ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01038800228bcc81e28d0e4c08d00d67/" rel="bookmark">
			Apache的安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：官网下载Apache 官网地址：Welcome! - The Apache HTTP Server ProjectWelcome! - The Apache HTTP Server ProjectWelcome! - The Apache HTTP Server Project
将安装包下载到自己提前创建的wamp目录 将安装包解压到wamp目录中 下载成功！
二：启动Apache的详细教程 1.
wamp--&gt;Apache24--&gt;bin--&gt;双击ApacheMonitor.exe
即启动Apache。
2.
打开windows自带的搜索栏，搜索“服务”，找到Apache2.4，进行手动开启。
三：关闭Apache的详细教程 四：Apache环境配置的详细教程 1.将安装Apache的路径复制
我的路径是E:\wamp\Apache24
2.环境配置
方法1：找到Apache软件下面的bin文件：路径为E:\wamp\Apache24\bin
此电脑--&gt;属性--&gt;高级系统设置--&gt;环境配置--&gt;在path路径下面新建路径E:\wamp\Apache24\bin
方法2：此电脑--&gt;属性--&gt;高级系统设置--&gt;环境配置--&gt;
--新建系统变量名：CATALINA_HMOE,变量值：E:\wamp\Apache24
--在系统变量Path中添加：%CATALINA_HMOE%\bin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c19ca3d00607e388b5afe6e4b91b5931/" rel="bookmark">
			位运算1 a^b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 求 a 的 b次方对 p取模的值。
输入格式
三个整数 a,b,p在同一行用空格隔开。
输出格式
输出一个整数，表示a^b mod p的值。
数据范围
0≤a,b≤10^9
1≤p≤10^9
输入样例：
3 2 7 输出样例：
2 #include&lt;iostream&gt; using namespace std; int main(){ long long a,b; cin&gt;&gt;a&gt;&gt;b; long long p; cin&gt;&gt;p; long long sum=1; while(b){ if(b&amp;1){ sum=sum*a%p; } b=b&gt;&gt;1; a=a*a%p; //cout&lt;&lt;a&lt;&lt;" dfefwe "&lt;&lt;b&lt;&lt;endl; } sum=sum%p; cout&lt;&lt;sum&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99c6d8ada061fb446aab0e6567cea93/" rel="bookmark">
			【接口自动化测试】selenium旗舰版Web测试理论篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【接口自动化测试】selenium旗舰版Web测试理论篇
一、Web自动化测试
1.1 简介
1.2 优势 1.3 E2E测试
二、主流的Web自动化测试工具
三、SeleniumWeb自动化测试
3.1 conda终端一键搭建命令
3.2 测试Web步骤①：自动打开浏览器
3.3 测试Web步骤②：元素的定位：八大定位策略分三组
3.3.1 分组①：根据文本定位标签
3.3.2 分组②：根据属性，定位任意元素
3.3.3 分组③：通用定位策略：可以定位到任意元素👑
3.3 测试Web步骤③：元素的操作
四、 牛刀小试！CSS定位百度搜索框
一、Web自动化测试 1.1 简介 Web自动化测试是指使用自动化工具模拟用户在浏览器中的操作，例如点击、输入文本、登陆账号等，以验证Web应用程序是否按照预期工作。这种测试可以大量的节省时间和人力成本。本文将讲解Web自动化测试，并简单的测试百度功能。
1.2 优势 Web自动化测试的优点有很多，这里只列出几个重要的优势：
提高测试效率：自动化测试可以快速的同时模拟多个用户进行测试；提高测试覆盖率：自动化测试可以重复执行测试用例，确保每一个功能都被检测到；提高软件质量：可以发现软件缺陷得以关闭； 1.3 E2E测试 Web自动化测试属于E2E测试，是软件质量保证的探测器。
E2E测试是指端到端测试（End-to-End Testing），它是一种软件测试方法，用于测试整个系统在实际运行环境中的功能和性能。
E2E测试从开始到结束测试整个系统，包括所有的组件、服务和系统之间的交互。这种测试方法旨在模拟真实的用户场景和使用情况，以便发现系统中的任何问题和潜在的缺陷。
E2E测试是软件开发过程中最关键的测试之一，它可以确保软件系统的正确性、稳定性和可靠性。
二、主流的Web自动化测试工具 Web自动化测试的主流框架有：
Selenium: selenium是最早出现的自动化测试框架之一，它支持多种浏览器和多种编程语言。目前世界各地使用它的公司是最广的，它拥有着丰富的社区和文档，遇到的问题几乎都有人遇到过，一搜既有大量的经验借鉴。Cypress:cypress是一个新的自动化测试框架，它的特点是速度快、稳定性高、易用性强。它可以在Chrome、Firefox和Electron中运行，支持JavaScript语言。它使用了类似于React的虚拟DOM管理页面元素，可以提高测试效率。但是，Cypress不支持多浏览器测试。Playwright:playwright是由Microsoft开发的自动化测试框架，也支持多种浏览器和编程语言，可以运行多种操作系统上。它支持多浏览器测试，而且执行速度比Selenium还有快，也比Cypress更灵活、支持更多的浏览器操作。但是，Playwright还比较新，社区和文档方面还不够成熟，可能遇到错误没有地方查找资料。 掌握任何一个Web自动化测试工具都可以进行自动化测试，所以我们需要选择一个来专研。Selenium我们有许多们选择它的理由：
浏览器支持最多，兼容最好最新的Selenium4综合各方面都非常棒生态成熟，文档丰富，历史悠久同时还可以进行App端的自动化测试 三、SeleniumWeb自动化测试 3.1 conda终端一键搭建命令 pip install webdriver_helper==1.0.1 -i https://pypi.mirrors.ustc.edu.cn/simple 必须设定版本号为1.0.1🥒
不然会出现以下错误：
ImportError: cannot import name 'get_webdriver' from 'webdriver_helper' (unknown location)
这是因为，更高版本的webdriver_helper是要收费的，而pip自动下载的是最高版本的库。
3.2 测试Web步骤①：自动打开浏览器 from webdriver_helper import * ''' with .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f99c6d8ada061fb446aab0e6567cea93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb2700360dd0dcb9999e87e9c2b17f8/" rel="bookmark">
			AnyLabeling加载模型时闪退
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载语义分割模型就闪退了，模型已经正确放入‘C//user//你电脑用户名”这个路径下，并且控制台报错如下：
RuntimeError: D:\a\_work\1\s\onnxruntime\core\session\provider_bridge_ort.cc:1106 onnxruntime::ProviderLibrary::Get [ONNXRuntimeError] : 1 : FAIL : LoadLibrary failed with error 126 "" when trying to load "
C:\ProgramData\Anaconda3\envs\alabel\lib\site-packages\onnxruntime\capi\onnxruntime_providers_tensorrt.dll"
应该是onnxruntime安装出错或者没有安装。
解决方法；重新安装onnxruntime
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/687817c47c9d6f0a00a522a128697aff/" rel="bookmark">
			vue3怎样获取绑定页面dom元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和vue2一样，vue3也可以在页面上通过ref绑定一个变量，
&lt;div ref="domRef"&gt;&lt;/div&gt; 但vue2使用this.$refs可以获取绑定的变量，而vue3虽然已经删除了this，但可以用以下方法绑定元素
在setup方法中使用vue提供的ref绑定元素，网上大部分是使用
import { onMounted, ref } from "vue"; export default{ setup() { const domRef = ref(null) onMounted(() =&gt; { console.log(domRef.value) }) retrurn { domRef } } } 其实这还有优化的空间，我们使用vue3比较重要的是使用ts语法，那么怎么指定ref绑定的dom的class对象呢，我们可以不用在ref中写null，在ref中指定某个类的原型，那么value就是这个类的对象，我们可以使用js本身就有的Element对象，也可以自定义一个，最终代码如下所示：
①Ele.ts文件，用于声明class类局部使用，也可以使用.d.ts文件直接全局声明
export default class Ele { // eslint-disable-next-line @typescript-eslint/no-empty-function constructor() {} clientHeight!: number; clientWidth!: number; style!: { top: number | string; left: number | string; bottom: number | string; right: number | string; display: "inline-block" | "none"; }; } ②通过Ele绑定ref
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/687817c47c9d6f0a00a522a128697aff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dec7a07d14b1d42656a9d41890e5d99/" rel="bookmark">
			MySQL: 运算符使用练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 练习运算符的使用，加强记忆。
案例目的： 在已建数据库中创建数据表，并对表中数据进行处理，练习运算符（包括数据运算符、逻辑运算符、位运算符）的使用。
操作过程： 创建名为 tb15 的数据表，包含 VARCHAR(100) 类型的字段 note， 以及INT 类型的字段 price。
注意创建表的语句格式注意分号位置 表格式如下： 答案：
向表内插入值： note : 'Thisisgood'
price: 50
答案：
INSERT INTO &lt;&gt; VALUES (&lt;&gt;, &lt;&gt;);
对表内值price进行运算操作： 取出原值，加10，减10，乘2，除2，除3取余数
取出原值，+10，-10， *2，/2，%3
# 这里注意，我们在表中取值，一定要在结尾标明来源于哪个表。
对表内值进行运算： 取出原值，判断：是否大于10，是否小于20，是否不等于80，是否等于60，使用安全等于符号比较price是否等于30，是否不等于10（使用符号不能与80相同）
取出原值， &gt;10, &lt; 20, != 80, = 60, &lt;=&gt; 30, &lt;&gt; 10;
判断price是否在 30~80 区间，返回price与 30 和 70 相比最大的值，判断 price是否为（10，20，30，40，50）中的某一个值：
BETWENN AND; GREATEST(); IN();
判断note字段是否为空，判断首字母是否为t，判断是否包含字母g或m
IS NULL, LIKE, REGEXP
将price 与 NULL 和 0 进行 逻辑与运算 和 逻辑或运算：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dec7a07d14b1d42656a9d41890e5d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0a8072f4cb6d677ed75723328de1b4/" rel="bookmark">
			MySQL：常见运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 五一过后，我又来啦！狂玩五天，放松好心情~
MySQL中的运算符有以下4类，分别是：算数运算符，比较运算符，逻辑运算符，位操作运算符。
算数运算符： 有一定python基础的话，应该对”算数运算符“并不陌生，包括：+ - * / %。加减乘除取余数。
我们可以选择表内某一数据进行加法运算，并输出运算结果。
这里我们先创建一个新的表，tb5，字段名为 num，字段属性为INT。
向表内添加数值 55：
我们得到的表是这样的：
对该值进行加法运算，并输出：
发现，输出的结果也形成了一个表。那么我们看看原数据是否会有变化：
并不会。
# 其实做到这里，我有一个疑问，是否可以通过运算符改变原表的数值呢？SELECT * FROM &lt;TABLE&gt; 语句相当于把表内的值拷贝一个出来，进行数值运算。
# 具体更改原表数值中的内容需要等到学习UPDATE语句。这里的运算并不能改变原表中的值。
其他的运算也是如此。
# 0除任何数都为NULL
比较运算符： 比较运算符的结果：1，0，NULL
往往用于SELECT 查询条件中。
字符串和数字进行比较，会先将字符串转化为数字如果一个（或一个以上的）参数为NULL，那么所得结果为NULL如果两个比较类型是字符串，按照字符串类型进行对比大于等于，小于等于，不等于，这些就不再一一进行比较了接下来注意一下安全等于运算符（&lt;=&gt;） 除了判断NULL的地方不一样之外，和=的作用相同。
检验是否为NULL 的语句：
IS NULL == ISNULL 为NULL
IS NOT NULL 不为NULL
注意，使用ISNULL 的时候，判断的值要放在后面的括号里。
BETWEEN &lt;&gt; AND &lt;&gt;：
判断值是否在区间内。（字符串也是可以实现的）
LEAST &lt;（数值）&gt; ：
筛选输入数据中的最小值。
浮点数也是可以的，看一下字符串：
在既有数字，又有字符串的情况下，优先数字大小。
既然有挑选最小值的语句，那么也一定有挑选最大值的语句。
GREATEST&lt;&gt;;
挑选所给数据中最大的一项。
&lt;&gt; LIKE &lt;&gt;;
用来匹配字符串有两个通配符，% 和 _ ，%代表任意个数字符；_ 代表一个任意字符%可以匹配NULL # %d 表示的就是以d结尾的任意单词。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0a8072f4cb6d677ed75723328de1b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52189e40be93452badbd1830716e184c/" rel="bookmark">
			element-ui中el-switch相关样式操作，等比例缩小、靠右对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 等比例缩小 .el-switch { transform: scale(0.5); } 靠右对齐 在element-ui中el-tree的树根上有个el-switch开关，我想将开关移动到外层的div最右侧并对齐，我的代码框架大概如下：
&lt;div&gt; &lt;el-tree&gt; &lt;span slot-scope="{node,data}"&gt; &lt;span&gt; {{node.label}} &lt;/span&gt; &lt;el-switch&gt;&lt;/el-switch&gt; &lt;/span&gt; &lt;/el-tree&gt; &lt;div&gt; 实现方法：
外层div增加style=“position: relative;”，
el-switch增加：style=“position: absolute; right: 0;”
&lt;div style="position: relative;"&gt; &lt;el-tree&gt; &lt;span slot-scope="{node,data}"&gt; &lt;span&gt;{{node.label}}&lt;span&gt; &lt;el-switch style="position: absolute; right: 0;"&gt; &lt;/el-switch&gt; &lt;/span&gt; &lt;/el-tree&gt; &lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ff520430664bd98679ef3446a4d9bf/" rel="bookmark">
			【Git】Git(分布式项目管理工具)在Windows本地/命令行中的基本操作以及在gitee中的操作，使用命令行、图形化界面，进行提交，同步，克隆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
这里是小编成长之路的历程，也是小编的学习之路。希望和各位大佬们一起成长！
以下为小编最喜欢的两句话：
要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，山高水远，路远马亡。
一个人为什么要努力？ 我见过最好的答案就是：因为我喜欢的东西都很贵，我想去的地方都很远，我爱的人超完美。因此，小编想说：共勉！
目录
一、开发注意事项
二、 Git
网址：
1、什么是git？
2、 Git 与 SVN 区别
3、Git、Gitee、Github、Gitlab的区别以及功能
1、Git
2、gitee
3、github
4、gitlab
5、不同点
4、Git工作流程
5、Git原理
三、码云新建仓库
了解码云中一些名词的意义
1、进入码云官网，注册一个账号并登录​编辑
2、创建仓库
3、仓库创建步骤
1）在创建仓库的时候，先不初始化仓库
1、创建仓库
2、将全局设置保存，进行初始化readme文件​编辑
3、进入仓库页面 4、将仓库改为公有仓库（开源仓库）
看是否是开源仓库
2）在创建仓库的时候，初始化仓库
1、创建仓库
2、初始化readme文件
3） 在创建仓库时，选择readme模板
四、在gitee中进行基本操作
1、文件上传
2、创建Issue
3、添加仓库成员
五、在Windows中进行基本操作
方式一：使用图形化界面直接操作
1、克隆——将远程仓库的项目下载到本地
如果没有绿色的图标（如果还是无效的话，建议去看看其他博主的文章）
git关联的的文件没有绿色、红色小图标按步骤处理，然后重启电脑即可。
2、文件上传——将本地文件上传到远程服务器中
3、文件拉取，更新/同步pull
4、文件更新时发生冲突
1、为什么会发生冲突？
2、制造冲突
第二步：在本地文件中创建一个新的文件one，并进行提交
第三步：提交成功，推到远程仓库
第四步：发生冲突​编辑
解决冲突
第一步: 点击上图的拉取,进行同步
第二步：拉取成功，将远程仓库同步到本地
第三步：查看文件，已经同步
第五步：推送成功​编辑
第六步：查看远程仓库是否和本地同步
方式二：使用命令行进行操作
1、克隆
首先在gitee仓库中复制git URL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ff520430664bd98679ef3446a4d9bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65dbec2fe13988234e4dd1969efca6a7/" rel="bookmark">
			4.EMC整改案案例解析及分析（静电&amp;辐射发射&amp;快速脉冲群）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：静电ESD 静电是生活中常见的问题，设备在进行EMC设计时候，静电放电是不能缺少的项目，静电问题直接影响到设备的使用。
减轻静电放电现象影响的一些常用方法包括：
1.绝缘 2.正确接地 3.抑制/过滤 4.电隔离 5.固件 6.绝缘
下面就一个设备的问题进行分析，基本概况
设备类型：手持设备 设备领域：工业用品 外壳类型：塑料 放电点：外部充电口，外部通讯口，外部连接口。
问题点：放电后设备出现死机、花屏等显现象。
问题分析：设备出现花屏和死机现象可能是由于静电引起的电路复位和异常保护。花屏一般当设备固定刷新且flash和单片机无死机情况下是可以恢复的，这种在EMC静电实验是允许的，当不可恢复的时候需考虑设备的内部电路是否出现了异常，或者局部闩锁的现象。
死机问题就复杂了，手持设备牵扯到电池，供电电路，内部软件控制等，当静电导致关机可以重启，说明硬件电路没有受到损伤，后续可以进行排除法，排除硬件闩锁和防护问题后，可对敏感信号进行查询，因为静电会导致地电平异常，对于地参考电平敏感的部分控制信号需特别关注，千万注意电路中软件防抖的设计。这是嵌入式工程师不可或缺的。
问题解决：死机问题系电路中的敏感信号触发，导致关机现象。对于常见的USB,LAN口等已经有了完备的防护电路，可以从ADI,TI等获取成熟的防护方案。
二：辐射发射 射发射主要测试设备在正常工作时自身对外界的辐射干扰强度，按照在客户端的典型安装要求对受试设备进行布置，线材要遵从规格书规定的长度和型号；除了36.201.1a规定的设备外，其他设备和系统应根据GB4824（工业、科学和医疗（ISM）射频设备骚扰特性限值和测量方法）进行分组、分类和测试。当高频信号如时钟，高速信号线等通讯时候，由于寄生电容，寄生电感等参数，很容易产生谐波等，白盒显示状态的设备的上升和下降沿时间过长，震荡，过冲和下冲等，都是EMI产生的主要源头，还有开关电源在开关切换过程中产生的问题。
PCB布线如何避免？
线长：当引出线缆达到高频信号波长λ的1/20，就会发生辐射发射。如100MH的信号，根据波长速度关系，V/f=λ λ/20=0.15m。意味着线长需要控制在15cm,这是非常严苛的要求，对于大多数设备都是无法实现的，但是对于高速信号线最好按照此要求控制线长。以及后端设备接线的方式最好是使用屏蔽线缆。
布线：对于高频信号布线就需要考虑PCB设计，包括走线和阻抗设计等
屏蔽？如何屏蔽？
λ = V/f = 3*10^8 /500*10^6 = 0.6m r&lt;λ/4 r = 15cm时候，才能阻挡传播。所以当设备的EMI严重时候，可以根据需求进行屏蔽，或者使用品屏蔽材料进行屏蔽。对于PCB设计中板子边缘保持20H的原则，减少电路板对外的辐射发射，可以采用金属包边，地包天设计减少EMI的影响。
吸收？如何吸收？
现阶段市面上有很多成熟的高磁导率的吸波材料，可以对不同频段的有所减少，但是受到温度和实际应用的限制，可以在消费品中常见。
问题分析：设备辐射发射超标B级别，A级别符合。由于设备是手持产品，无可靠接地，设备内部有高频信号线，如果信号完整性不好，那么高频信号很容易产生高次谐波，谐波分量成比例增加，是引起指标超标的主要问题，所以抑制信号中的高频分量非常重要，设备内部特别是显示屏接地和显示屏时钟信号线是问题多发点，需要在结构和电路设计中充分考虑电流回路面积尽可能小和接地良好性，对应对静电放电也有很大帮助。对于部分设备还可以使用导电泡棉或者接地弹片优化接地回路，进而减少设备的EMI影响。
下图是一个参考值。一般情况下在高频时候的辐射发射幅值一般都是倍数关系，如250MHZ 500MHZ 750MHZ 等。可以根据频点检查设备那块存在此频点的基频，当确定基频信号时候进行白盒复测使用示波器进行测试，进而使用频谱分析功能进行进一步评估，对于设备全的公司可使用近场探测仪器进行测试。
问题解决：达到B级别测试需求
1：时钟线增加磁珠，可以将匹配电阻更换为有效磁珠测试，或者采用阻容吸收电路在保证信号的前提下，吸收高频噪声，磁珠需要根据频率阻抗特征曲线选取。
2：增加液晶接地的可靠性，对液晶背部进行有效接地，不单纯依靠FPC软线连接。
补充： 对于台式带接地的设备，进行发射发射整改时候，也需要注意液晶接地和液晶排线的处理，设备内部接地保证低阻抗，对特殊对外的端口，如网口和usb需在PCB设计中做处理，一般情况下外部通讯地和内部电路板的地式隔离的，通过电容或者电阻进行单点连接，如下，两个隔离地通过隔离变压器处的电容或者电阻进行连接，根据实际情况，一般就放电容即可。信号线和电源线在走线中需要避免一起捆扎。
液晶上的始终信号和其他通讯信号，在高频情况下，通过液晶排线和连接器，由于液晶排线和连接器上的等效电感和回路阻抗较大，对原有的信号造成干扰，高频信号极易容易产生谐波分量。造成辐射发射的超标。一般液晶组件后面都有接地屏蔽面，需进行有效的接地。在涉及软排线时候最好加一层地平面。
三：快速脉冲群EFT 电快速脉冲群具有突发，高压，宽频的特征，几乎可以覆盖EMS测试中除了浪涌，电压跌落之外大部分频率，是高频测试非常典型的代表。电快速脉冲群主要针对电源线或者信号线进行耦合的。在测试中由于寄生参数的存在，高频信号耦合到线缆上，会导致电路内部信号异常，当干扰信号流经电路板中有生命的地方时候，造成敏感信号的误触发等，如敏感的kill信号，reset信号，sw信号，pwm信号，对时序要求高的信号等，造成设备出现异常。
如何消除？如何屏蔽？
对于电源线，信号线等，必要的滤波电路非常重要，针对电源和信号的滤波电路常有差模滤波共模滤波器等安装在机器电源入口处，实现对干扰信号的就近处理，对于电源的滤波器需要可靠的接设备机壳，对于线缆的接地线需要就近接入机壳，做可靠连接。
将可以注入干扰信号的线缆和其它线缆分开捆绑或者在PCB上单独特殊走线，详细请参考《信号完整性和电源完整性分析》这本书。
手持设备如何避免？
对于手持设备针对电源和信号线的快速脉冲群测试更难处理，因为滤波器的体积等限制无法安装。只能依靠设备内部的滤波电路，PCB布线和芯片自身的噪声抑制能力等。同时兼容软件的容错机制，可以最大化的降低风险。当然手持设备是可以独立脱离电源适配器使用的，可以不进行快速脉冲群的认证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756be7f66c94d116b11e0e7f88b7d101/" rel="bookmark">
			二叉树所有节点转换成大于该节点的平均值，没有最大值就转换成0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.ArrayList; import java.util.List; import java.util.function.ToIntFunction; import java.util.stream.Collectors; public class Test { static class Node implements Cloneable { int val; Node left; Node right; public Node(int val, Node left, Node right) { this.val = val; this.left = left; this.right = right; } @Override protected Node clone() throws CloneNotSupportedException { Node node = new Node(val, left == null ? null : left.clone(), right == null ? null : right.clone()); return node; } } /** * 3 * 2 5 * 1 4 6 * * 转换成 * 5 * 4 6 * 5 5 0 */ public static void main(String[] args) throws CloneNotSupportedException { Node node1 = new Node(1, null, null); Node node2 = new Node(2, node1, null); Node node4 = new Node(4, null, null); Node node6 = new Node(6, null, null); Node node5 = new Node(5, node4, node6); Node root = new Node(3, node2, node5); updateNode(root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756be7f66c94d116b11e0e7f88b7d101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586fc7f498a1afbbcf496f30d678db9f/" rel="bookmark">
			maven 项目引入本地jar包方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven 项目引入本地jar包方式 一、在resources 中创建lib 文件夹，并把需要引入的jar包粘进去 本文以aspose中的 word转pdf的jar包举例
二、在pom.xml 文件中添加依赖 &lt;!-- 引入本地jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;aspose-words&lt;/groupId&gt; &lt;artifactId&gt;aspose-words&lt;/artifactId&gt; &lt;version&gt;15.8.0&lt;/version&gt; &lt;classifier&gt;jdk16&lt;/classifier&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/aspose-words-15.8.0-jdk16.jar&lt;/systemPath&gt; &lt;/dependency&gt; 三、pom.xml build -&gt; plugin中要添加includeSystemScope为true,不然本地不报错，部署到服务器上会报找不到包的错 报错信息如：java.lang.NoClassDefFoundError
true
完成上面三步 即可使用引入的jar 包了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b2ddb7d4b052c715d16abf2ee83138/" rel="bookmark">
			1、防火墙的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1、防火墙的概念 一种网络安全设备，通过各种配置，拒绝非授权的访问，保护网络安全。
通过访问控制、身份验证、数据加密、VPN技术等安全功能，形成一个进出屏障。
1.2、防火墙的发展历史 主要经历了包过滤防火墙、代理防火墙和状态检测防火墙等三代，统一威胁管理和下一代防火墙是最近几年提出的概念。
1.2.1 包过滤防火墙 第一代防火墙。通过配置访问控制列表（ACL）对数据报文进行过滤，并根据策略转发或丢弃数据报文，设计简单易于实现。
包过滤不检查会话状态且不分析数据，攻击者可以使用假冒地址进行欺骗，然后通过防火墙。
包过滤仅能审核处于网络层和传输层的协议首部信息，对每个数据包执行允许和禁止的操作。这种过滤能够基于下列基本标准制定访问决策：
（1）源IP地址和目的IP地址
（2）源和目的地端口号码
（3）协议类型
（4）进出的流量方向。
1.2.2 代理防火墙 第二代防火墙。代理检查来自用户的请求，匹配安全策略后代表外部用户与真正的服务器建立连接，转发外部用户请求。
代理防火墙安全性较高，但软件限制处理速度，同时需要为每一种应用开发对应的代理服务，开发周期长且升级困难。
代理是一个中间人。设置在可信任网络和不可信任网络之间，总是代表数据来源建立连接。
代理防火墙断开了通信信道，两个通信设备之间不能直接连接。
有两种类型的防火墙，工作在OSI模型底层（会话层）的代理防火墙称为电路级代理，工作在应用层的代理防火墙叫应用级代理。
1、电路级防火墙 创建了客户端计算机和服务器之间的一个电路，仅能看到会话层，从网络角度监控流量。
这种代理不能看到数据包的内容，不执行深层次的检查。只是基于它能看到的协议首部和会话信息做访问决策。不理解应用层协议，因此是独立于应用层的程序代理。
提供的保护强度没有应用级代理大。但是能提供更宽泛的保护。
电路级代理的工作方式类似于包包过滤，它基于地址、端口和协议类型的首部值来做访问决策。电路级代理检查包首部内的数据，而不是检查应用层数据。不检查包内数据是否安全。
2、应用级代理 可以检查通过应用层的数据包。应用级代理可以理解整个数据包，因为可以根据数据包的内容作出访问决策。
应用级代理可以区分FTP的GET和PUT命令，并且根据这种细粒化的信息作出访问决策。包过滤防火墙和电路级代理只可以允许或者拒绝FTP的整个请求，而不是通过FTP协议内部所使用的命令进行决策。
应用级代理防火墙需要为每个协议都配备一个代理。因此，提供应用级代理保护比较难。代理必须完全理解特定协议的工作方式以及该协议内的合法命令。
应用级防火墙的特征如下：
（1）检查整个网络包，不仅是网络地址和端口，因此有强大的日志记录功能。
（2）能够之间对用户进行身份验证，包过滤防火墙和状态检查防火墙是不可以的。
（3）不仅仅是第三层设备，因此能够抵御欺骗攻击和其它复杂的攻击。
应用级防火墙的缺点：
（1）通常不适合高带宽或实时应用。
（2）支持新网络应用和协议的能力有限。
（3）由于逐包处理的要求，会产生性能问题。
应用级和电路级代理防火墙的特征：
1、应用级代理防火墙的特征如下：
（1）每个被监控的协议都需要一个独特的代理。
（2）比电路级代理防火墙提供更多的保护。
（3）对每个包都要进行更多处理，速度比电路级代理防火墙慢。
2、电路级代理防火墙的特征如下：
（1）不需要为每个协议设置一个代理。
（2）不提供应用级代理防火墙的更深层次的检查。
（3）为更广范围的协议提供安全性。
1.2.3 状态检测防火墙 第三代防火墙。状态检测属于包过滤技术的延伸，对基于连接状态的数据报文进行检查时，它会考虑数据报文前后的关系，这意味着每个数据报文都不是独立存在的，而是前后有状态联系的。基于这样的状态联系，发展处了状态检测技术。于1994年提出。
状态检测防火墙通过动态分析激活的TCP会话和UDP会话状态采取动作，处理速度快且安全性高。
数据包通过包过滤防火墙时，就会忘记接收过该包，因此称为无状态的。状态过滤检查，它能跟踪记录包到达什么位置，直到特定的连接关闭。
状态检测防火墙比常规的过滤路由器更好管闲事，因为它跟踪计算机之间说了什么。这就需要防火墙维护一个状态表，以记录谁对谁说了什么，就像一张记分表那样。
状态检测防火墙记录着通信的每一个步骤。它知道协议应该如何工作，如果出现不合常规的情况，它不会允许流量通过。
当两个系统之间的连接开始时，防火墙调查数据包的所有层（所有首部、有效载荷和尾部）。有关这个具体连接的所有必要信息都存储在状态表中（源IP地址和端口，目的IP地址和端口、协议乐西、首部标志、序列号和时间戳等）。一旦这个数据包通过了这个深入的检查，一切都被认为是安全的，防火墙会审核网络，为剩下的会话传输首部部分。每一个数据包都会语当前状态表中的值做对比，这个表被更新以反映通信进程的进展情况。把检查整个数据包缩减为只检查每个数据包的首部可以提高性能。
状态检测防火墙的特征：
（1）维护一个状态表，以跟踪每一个通信会话。
（2）它提供了高度的安全性，而且不会像代理防火墙那样引入性能问题。
（3）可升级，对用户透明。
1.2.4 统一威胁管理防火墙 统一威胁管理（UTM）防火墙属于新一代防火墙。除了具备基本防火墙功能外，它将入侵检测、访问控制、防病毒、URL过滤等功能集成于一身，实现全面的安全防护功能。
1.2.5 下一代防火墙 下一代防火墙概念在2008年提出，最初目的是解决UTM防火墙运行多个功能后性能下降的问题。2009年明确了定义，明确了下一代防火墙除了具有UTM防火墙功能外，还可以基于用户、应用、内容进行管控。
1.3 华为USG6000系列防火墙介绍 2013年9月发布。
USG6000系列防火墙将安全能力与应用识别进行深度融合，实现安全防护一体化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b2ddb7d4b052c715d16abf2ee83138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8a1be2ceca5ecbb98c11901bc4dee7/" rel="bookmark">
			关于Context.startForegroundService() did not then call Service.startForeground()的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关于Context.startForegroundService() did not then call Service.startForeground()的解决办法第一处：停止服务第二处：超时结论参考 关于Context.startForegroundService() did not then call Service.startForeground()的解决办法 有天突然报了以下错误android.app.RemoteServiceException: Context.startForegroundService() did not then call Service.startForeground() 顺着这个提示文本，我搜索了下，发现在com.android.server.am.ActiveServices里有两处地方 第一处：停止服务 第一处如下 //android-30 void serviceForegroundCrash(ProcessRecord app, CharSequence serviceRecord) { mAm.crashApplicationWithType(app.uid, app.getPid(), app.info.packageName, app.userId, "Context.startForegroundService() did not then call Service.startForeground(): " + serviceRecord, false /*force*/, ForegroundServiceDidNotStartInTimeException.TYPE_ID); } 看看是谁调用它的，原来在com.android.server.am.ActivityManagerService里
那就接着看看什么时候发出了SERVICE_FOREGROUND_CRASH_MSG事件，于是又来到ActiveServices.bringDownServiceLocked方法里
根据以下这行注释大概意思就是说在 显示前台服务通知之前就关闭前台服务这个操作是不允许的
那么就有可能是我们启动前台服务，然后前台服务还没执行到android.app.Service#startForeground(int, android.app.Notification) 时就又执行了停止服务，因此才出现了这个奔溃
于是我们可以验证下在startForeground调用之后立马执行stopSelf,看看会不会报同样的错
可惜无法复现，再看看产生这个奔溃的手机，全是android 10这个版本
于是对android 10的设备一番尝试后发现无法复现，那么可能产生的问题就是超时了
后期发现如果是这里产生的奔溃，那么异常是ForegroundServiceDidNotStartInTimeException,如下
android.app.ForegroundServiceDidNotStartInTimeException: Context.startForegroundService() did not then call Service.startForeground(): ServiceRecord{...} 而且从代码看在这个异常产生之前就会把超时的那个消息从消息队列移除，也就是不会产生两次异常后来继续思考，会不会是未调用startForeground就先调用了stopSelf导致的呢，这种情况应该也有可能，马上着手试验，果然立马就崩了 第二处：超时 第二处如下 android-30 void serviceForegroundTimeout(ServiceRecord r) { ProcessRecord app; synchronized (mAm) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc8a1be2ceca5ecbb98c11901bc4dee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f92ce2e9a06cffe23ad5836d390a84/" rel="bookmark">
			webots机器人仿真(0)→目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲解关于SLAM-ROS2算法移植、部署与工程落地一系列文章汇总链接:SLAM-ROS2算法移植、部署与工程落地 - 总目录，针对于本栏目讲解webots机器人仿真链接如下:
webots机器人仿真(0)→目录：https://blog.csdn.net/weixin_43013761/article/details/130488157
文末正下方中心提供了本人 联系方式， 点击本人照片即可显示 W X → 官方认证 {\color{blue}{文末正下方中心}提供了本人 \color{red} 联系方式，\color{blue}点击本人照片即可显示WX→官方认证} 文末正下方中心提供了本人联系方式，点击本人照片即可显示WX→官方认证
请注意本人使用环境为 U b u n t u 18.04 \color{red}{Ubuntu18.04} Ubuntu18.04,另外本人现在的时间点为 20230504 \color{red}{20230504} 20230504 无法保证你现在的时间点,相应的依赖库或者工程作者是否有更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35448804b7394b790e305c2d3b4aec0/" rel="bookmark">
			第六节：使用three.js材料【Three.js整理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		材质的定义：
1，ThreeJs的定义：材料描述物体的外观。它们以（大部分）独立于渲染器的方式定义，因此如果您决定使用不同的渲染器，则不必重写材质。
2，OpenGL的定义：材质是环境色、 漫反射色、镜面反射色和发射色以及光泽度的组合。
three.js中的材质及性能：
模拟现实世界中的物体：MeshBasicMaterial➡ MeshLambertMaterial➡ MeshPhongMaterial
更高级的计算实现物理材质：MeshStandardMaterial➡ MeshPhysicalMaterial
各种标准材料从最快到最慢 MeshBasicMaterial➡ MeshLambertMaterial➡ MeshPhongMaterial➡ MeshStandardMaterial➡ MeshPhysicalMaterial
MeshBasicMaterial
这是一个基本的材料，你可以用来给你的几何图形一个简单的颜色或显示你的线框几何形状。（平面）
//新建材质 const material = new THREE.MeshBasicMaterial({ color: 0xFF0000, // 设置颜色 }); MeshLambertmaterial
这是一种考虑到照明并使用的材料创建无光泽的无光泽物体（哑光材质）
//新建材质 const material = new THREE.MeshLambertmaterial({ color: 0xFF0000, // 设置颜色 }); MeshPhongmaterial
这是一种还考虑到照明的材料可用于创建闪亮的对象。（漆面）
//新建材质 const material = new THREE.MeshPhongmaterial({ color: 0xFF0000, // 设置颜色 }); 更复杂的材料需要更多的 GPU 能力来绘制。在较慢的 GPU（例如手机）上，您可能希望通过使用一种不太复杂的材质来降低绘制场景所需的 GPU 功率。同样，如果您不需要额外的功能，请使用最简单的材料。如果您不需要照明和镜面高光，请使用.MeshBasicMaterial，MeshLambertMaterial，MeshBasicMaterial
--------------------------------------------------------升级------------------------------------------------
材质的组成：网格Mesh = Geometry 几何 + Material 材质。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35448804b7394b790e305c2d3b4aec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4749c6cd372e7a6435e3ca408a3a85d/" rel="bookmark">
			vue路由·配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法· 在Vue中使用路由一般需要引入Vue Router库，可以通过Vue CLI脚手架来快速生成webpack打包的Vue项目。
在Vue项目中使用路由，通常需要先定义路由规则，再在组件中引入路由来进行跳转等操作。以下是一个简单的Vue Router的用法示例：
首先，你需要在项目中通过npm安装Vue Router：
npm install vue-router 然后在main.js中引入Vue Router并创建一个VueRouter实例，代码类似这样：
import Vue from 'vue' import VueRouter from 'vue-router' import App from './App.vue' import Home from './views/Home.vue' import About from './views/About.vue' Vue.use(VueRouter) const router = new VueRouter({ routes: [ { path: '/', component: Home }, { path: '/about', component: About } ] }) new Vue({ router, render: h =&gt; h(App) }).$mount('#app') 在上述代码中，我们首先通过import引入了Vue、Vue Router和两个组件App.vue、Home.vue、About.vue。然后通过Vue.use()语句来安装Vue Router插件，接着我们用VueRouter实例来定义路由规则（路由的配置项），有两个路由/和/about，它们分别对应了两个组件：Home和About，最后通过new Vue()语句创建了Vue实例，并将VueRouter实例挂载在Vue实例上的router属性上。
接下来，我们就需要在App.vue组件中使用路由，代码类似这样：
&lt;template&gt; &lt;div&gt; &lt;h1&gt;My App&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'app' } &lt;/script&gt; 在上述代码中，我们通过&lt;router-view&gt;标签来渲染当前路由对应的组件。此外，你还可以通过&lt;router-link&gt;标签来添加路由链接，如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4749c6cd372e7a6435e3ca408a3a85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576f8d83b9fed31f1d6ab0a8bfdcfc7e/" rel="bookmark">
			Gradio学习笔记--Gradio基本用法和简单案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​​
目录
1--配置Gradio
2--Hello World案例
2-1--基本使用
2-2--进阶使用
3--图像案例
3--常用类 Interface 和 Blocks
1--配置Gradio 使用 pip 安装 Gradio：
pip install gradio 2--Hello World案例 2-1--基本使用 import gradio as gr def greet(name): return "Hello " + name + "!" demo = gr.Interface(fn=greet, inputs="text", outputs="text") demo.launch(share = True) 类 gr.Interface()可以包含任何 Python 函数，其通过以下三个必需的参数进行初始化：
① fn：封装好的 Python 函数，即上例中的 greet() 函数；
② inputs：用于输入的组件，可以为 “text”、“image” 或 “audio”，上例中为 “text”；
③ outputs：用于输出的组件，可以为 “text”、“image” 或 “audio”，上例中为 “text”；
通过 launch() 运行定义的类对象，运行结果包括两个 url，第一个 local url 可以在本地打开和运行；第二个 public url 需要通过设置 share = True 才可生成，可用于分享在其它机器上打开和运行；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576f8d83b9fed31f1d6ab0a8bfdcfc7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432c22b06cb356350a3f1138fd512601/" rel="bookmark">
			数据库从入门到精通01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据库应用概念什么是数据库关系型和非关系型关系型数据库 Mysql数据库MySQL数据存放在哪里？MySQL服务端MySQL客户端1：DOS窗口MySQL客户端2：可视化工具 数据库的结构数据库结构 SQL语句定义分类 数据库常用操作建库删库查看所有数据库 表的常用操作表设计创建表修改表删除表查看所有表查看表结构/设计表 表记录的常用操作插入记录查询记录修改记录删除记录排序记录总数 数据类型命名规则字符数字日期图片 准备数据部门表 dept员工表 emp 字段约束主键约束非空约束唯一约束 数据库应用 dy同名: cgblpx
概念 什么是数据库 简而言之，就是存储数据，管理数据的仓库。
常见的数据库分为：
关系型数据库， Oracle、MySQL、SQLServer、Access非关系型数据库， MongoDB、Redis、Solr、ElasticSearch、Hive、HBase
关系型和非关系型 早期发展的数据库建立在数据的紧密关系基础之上（如：父子关系、师生关系），我们称其为关系型数据库，也称为传统数据库；现今数据库建立在数据的松散关系基础之上（如：中国人和美国人、中国人和印度人、视频、音频），我们称其为非关系型数据库nosql（not only sql）。业界总在争论nosql能否干掉传统数据库，很多初学者也有这个困惑。以我来看，两者没有矛盾，它们各有特点，根据业务情况互补才是真谛。但总的来说原来关系型数据库一统天下的格局早被打破，领土不断被蚕食，规模一再的缩小，虽然无法全面被替代，但却早已风光不在，沦落到一偶之地，Oracle的衰落就是最好的证明，早期只要是全球大企业无一例外都是部署Oracle，但现在都在去Oracle化，阿里就已经全面排斥Oracle。
既然干不掉，很多传统项目的还是围绕关系型数据库的居多，所以我们先来学习关系型数据库，目前最流行的关系型数据库是MySQL。
关系型数据库 关系型数据库有特定的组织方式，其以行和列的形式存储数据，以便于用户理解。关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据集合。
Mysql数据库 mysql服务端，它来处理具体数据维护，保存磁盘mysql客户端，CRUD新增，修改，删除，查询 MySQL数据存放在哪里？ 在MySQL的配置文件my.ini中会进行默认配置
MySQL服务端 mysql-5.5.27-winx64.msi
Mysql数据库默认的编码是latin1等价于iso-8859-1，修改为utf-8
注意：配置完，mysql开始执行，最后一步出错有时仍可以使用，使用SQLyog工具测试，如不行，再执行安装程序，选择remove，删除，然后重新安装。同时注意必须是管理员权限。
MySQL客户端1：DOS窗口 mysql -uroot -proot
语法：mysql.exe执行文件
代表参数
-u 用户名，紧接着写的
-p 密码，紧接着写的
MySQL客户端2：可视化工具 数据库的结构 数据库结构 SQL语句 定义 结构化查询语言(Structured Query Language)简称SQL(发音：/ˈes kjuː ˈel/ "S-Q-L")，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。
SQL 是1986年10 月由美国国家标准局（ANSI）通过的数据库语言美国标准，接着，国际标准化组织（ISO）颁布了SQL正式国际标准。
分类 DML（Data Manipulation Language）数据操纵语言 如：insert，delete，update，select（插入、删除、修改、检索）简称CRUD操新增Create、查询Retrieve、修改Update、删除Delete
DDL（Data Definition Language）数据库定义语言 如：create table之类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432c22b06cb356350a3f1138fd512601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27de799b11ae63e54161df22b70670a6/" rel="bookmark">
			python-pandas库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 目录
目录
1.pandas库简介（https://www.gairuo.com/p/pandas-overview）
2.pandas库read_csv方法（https://zhuanlan.zhihu.com/p/340441922?utm_medium=social&amp;utm_oi=27819925045248）
1.pandas库简介（https://www.gairuo.com/p/pandas-overview） 用途：
Pandas 可以用来进来各种表格数据处理，实现复杂的处理逻辑，这些往往是 Excel 等工具无法处理的，还可以自动化、批量化，对于相同的大量的数据处理我们不需要重复去工作。
适用的数据：
Pandas 适合处理一个规正的二维数据（如图），即有 N 行 N 列，类似于 SQL 执行后产出的，或者无合并单元格Excel 表格这样的数据。它可以把多个文件的数据合并在一起，如果结构不一样，也可以经过处理进行合并。
基本功能：
从 Excel、CSV、网页、SQL、剪贴板等读取数据合并多个文件或者 sheet 数据，拆分数据为独立文件数据清洗，如去重、缺失值、填充默认值、格式补全、极端值处理等建立高效的索引支持大体量数据按一定业务逻辑插入计算后的列、删除列灵活方便的数据查询、筛选分组聚合数据，可独立指定分组后的各字段计算方式数据的转置，如行转列列转行变更处理连接数据库，直接 SQL 查询数据并进行处理对时序数据进行分组采样，如按月、按季、按工作小时，也可以自定义周期，如工作日窗口计划，移动窗口统计、日期移动等灵活的可视化图表输出，支持所有的统计图形融合在表格的样式风格，提高数据识别效率 2.pandas库read_csv方法（https://zhuanlan.zhihu.com/p/340441922?utm_medium=social&amp;utm_oi=27819925045248） pandas.read_csv方法函数用来读取CSV格式数据文件，默认返回DataFrame格式的数据DataFrame格式： 是Pandas库中的一种数据结构，类似excel或者sql中的表 参数解析： 1. filepath_or_buffer：数据输入的路径：可以是文件路径、可以是URL，也可以是实现read方法的任意对象。这个参数，就是我们输入的第一个参数
import pandas as pd pd.read_csv("girl.csv") # 还可以是一个URL，如果访问该URL会返回一个文件的话，那么pandas的read_csv函数会自动将
该文件进行读取。比如：我们用fastapi写一个服务，将刚才的文件返回。
pd.read_csv("http://localhost/girl.csv") # 里面还可以是一个 _io.TextIOWrapper，比如：
f = open("girl.csv", encoding="utf-8") pd.read_csv(f) 2. 索引列 index_col： 我们在读取文件之后所得到的DataFrame的索引默认是0、1、2……，我们可以通过set_index设定索引，但是也可以在读取的时候就指定某列为索引
pd.read_csv('girl.csv', delim_whitespace=True, index_col="name") # int, str, sequence of int / str, or False, default None # 默认为 `None`, 自动识别索引 pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27de799b11ae63e54161df22b70670a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bdd166c205cb20cde20dce6c604443/" rel="bookmark">
			Solidworks PDM二次开发---文件夹相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 好久没有更新Solidworks PDM的操作了，今天我们来学习一下文件夹的几个常用操作。 新建文件夹 可以参考api中的帮助 Add Folder Example (C#) —这里面有相关的卡设置
//new 一个库对象 var vault = new EdmVault5(); //登陆到库中 vault.LoginAuto("PDM2020Default", this.Handle.ToInt32()); var vault2 = (IEdmVault7)vault; //本地根目录 var rootPath = vault2.RootFolderPath; var rootFolder = vault2.RootFolder; //新建子文件夹 //这里路径可以多个子层级 如A\B\C var newFolder = rootFolder.CreateFolderPath($@"\newTempFolder", this.Handle.ToInt32()); IEdmFolder5 parentFolder = default(IEdmFolder5); parentFolder = vault2.GetFolderFromPath(ListBox.Items[0].ToString()); dynamic folderName = "Temp"; IEdmUserMgr5 usrMgr = default(IEdmUserMgr5); usrMgr = (IEdmUserMgr5)parentFolder.Vault; EdmFolderData data = default(EdmFolderData); data = new EdmFolderData(); data.SetUserRights(usrMgr.GetUser("Engineer1").ID, (int)EdmRightFlags.EdmRight_Read | (int)EdmRightFlags.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bdd166c205cb20cde20dce6c604443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4391e5d20ad61f8dc043e7ef72b06cb0/" rel="bookmark">
			Blender启动场景的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Blender启动场景的修改 1 使用版本2 现象描述3 解决方法4 启动场景路径5 清理场景资源5.1 空场景大小5.2 清理图片资源5.2.1 断开数据块关联5.2.2 断开伪用户关联5.2.3 断开多用户关联5.2.4 清理数据块5.2.6 文件校验 5.3 使用自建资源库 6 数据块类型 1 使用版本 Blender 3.3
2 现象描述 每次打开大纲视图会出现其他模型节点，应该是无意改写了默认启动场景。
相机、灯光节点之外的节点，某模型每次打开场景都会出现；
场景不是空场景或者模板场景，每次进入需要删除多余模型。
3 解决方法 修改Blender对应场景文件 startup.blend
4 启动场景路径 C:\Users\本机用户名\AppData\Roaming\Blender Foundation\Blender\3.3\config\startup.blend
这里 3.3 是Blender的对应版本，3.x版本都有这个默认场景文件,打开修改即可。
5 清理场景资源 5.1 空场景大小 一般空场景大小在 1MB以内，如果超过50MB那是因为本地有关联或者未清理的数据块，比如：材质、贴图等资源。 通常数据块会保存到本地是有引用关系，这些资源需要先取消关联然后再去清理。
5.2 清理图片资源 5.2.1 断开数据块关联 Shift+左键点击 断开关联
5.2.2 断开伪用户关联 零用户数据块若想保存到.blend工程文件，需要标记为伪用户，伪哦用户文件取消关联需要取消伪用户即可。
只要点击盾牌按钮即可设置/取消伪用户
5.2.3 断开多用户关联 资源被多次使用则会被标记为多用户（显示共享次数），资源也可以被标记为独立数据处理（点击创建副本），会额外创建一个图片文件
Shift+左键点击 断开关联
5.2.4 清理数据块 取消关联后清理数据块 [递归]再保存，工程文件会变为正常大小，同时会有清理提示显示。
文件 – 清理 – 选择递归项清除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4391e5d20ad61f8dc043e7ef72b06cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008ea7b9a4b9823698287f84efe004d5/" rel="bookmark">
			C#反射学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义：反射就是动态获取程序集中的元数据和类型并创建对象调用成员
要点：先获取指定类的Type对象，然后再通过Type类对象获取类的属性，方法，字段，事件，接口等
1、关键类：Type
Type类可以获取类中的所有信息包括方法、属性等。可以动态调用类的属性方法，Type是对类的描述，主要针对类
2、如何获取一个类的Type对象：
1）如果该类有实例化的对象，则通过对象.GetType方法获取
2）如过该类没有创建对象，则通过typeof(类名)获取 3、通过Type可以获取当前类型的父类、字段、属性 、方法、事件及所有成员等
通过Type类获取对象：
using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace Person { public class PersonC { public string _age; public int _shengao; public string name { set; get; } public int age { get; set; } public string email { set; get; } public void SayHi() { Console.WriteLine("Hello"); } public void test(int a, int b) { Console.WriteLine(a + b); } } } using System; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/008ea7b9a4b9823698287f84efe004d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b22d37cd193204339fab1f2d4a323c/" rel="bookmark">
			C语言基础-数组，排序，函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、一维数组
1、一维数组定义
数据类型 变量名 = [元素个数]
int a[10];
//数组 int a[10]; int data; for(data = 0;data&lt;10;data++) { a[data] = data * 10; } puts("数组初始化完成"); for(data = 0;data&lt;10;data++) { printf("%d ",a[data]); } 2、数组的初始化赋值keyi
int a[10] = {0,1,2,3,4,5,6,7,8,9}; 可以只给前部分赋值，后面数据系统自动赋值为0
int a[10] = {1,2,3} 在对全部数据赋值时，中括号内的元素个数可以省略不写(如下代码，5即可不写)
int a[] = {1,2,3,4,5} 3、sizeof关键字（不是函数！！！）
计算数组内元素的个数，利用sizeof求出整个数组的内存空间大小和一个元素的内存空间大小，两数相除即可得出数组内元素的个数。
int size; size = sizeof(array)/sizeof(array[0]); 4、练习
//数组初始化练习 //赋值并逆序输出 int a[] = {0,1,2,3,4,5,6,7,8,9}; int i; for(i = 9;i&gt;=0;i--) { printf("%d ",a[i]); } 斐波那契数列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7b22d37cd193204339fab1f2d4a323c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d44523890c532591fa04544d3e4998/" rel="bookmark">
			c语言基础-条件语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、流程控制
1、if语句
//输入两个数，输出结果为从小到大 int a; int b; int c; printf("请输入两个数："); scanf("%d %d",&amp;a,&amp;b); if(a&gt;b) { c = a; a = b; b = c; } printf("%d %d",a,b); //输入三个数，按从小到大排序 int a; int b; int c; int d; printf("请输入三个数："); scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if(a&gt;b) { d = a; a = b; b = d; } if(a&gt;c) { d = a; a = c; c = d; } if(b&gt;c) { d = b; b = c; c = d; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d44523890c532591fa04544d3e4998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294d19a33d32fae81fa63993c92adb92/" rel="bookmark">
			如何解决keil界面模糊的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Keil快捷图标点击右键，选择属性。
2、在属性的弹出菜单里，选到“兼容性”页面，在其下面找到并点击“更改高DPI设置”。
3、勾选“替代高DPI缩放行为”选项，如下图，然后确定，确定。
4、重新打开软件，发现变清晰了，此方法同样适用其他软件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f246a3bfe2e6d57102f3beaad33c0a6/" rel="bookmark">
			python 制作简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 if __name__ == "__main__": date1,date2,op=split(" ") date1=int(date1) date2=int(date2) if op=="+": print(date1+date2) elif op=="-": print(date1-date2) elif op=="*": print(date1*date2) elif op=="-": a=date1/date2 if date1%date2==0: print(a) else: print('{:.2f}'.format(a)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a529680d0459453dd742a8fa5f5d4259/" rel="bookmark">
			Pandoc 从入门到精通，你也可以学会这一个文本转换利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandoc 简介 如果你需要在不同的文件格式之间相互转换，多半听说或使用过文档转换的瑞士军刀——Pandoc。事实上，不仅人类知道 Pandoc，最近很火的人工智能 ChatGPT 也知道「将 Markdown 转换为 docx」，首选方案是使用 Pandoc。
​
如何「将 Markdown 转换为 docx」，ChatGPT 回答使用 Pandoc，并给出了转换命令
Pandoc 是一个基于 GPL 协议开源的免费命令行软件 ，由加州大学伯克利分校哲学系教授 John MacFarlane使用 Haskell语言开发，目前另一位核心开发者是来自德国的Albert Krewinkel 。截止 2022 年 12 月 10 日，Pandoc 的 GitHub 仓库拥有超过 27,000 个 Star，3,000 次 Fork。
根据 John MacFarlane 教授的介绍 ，Pandoc 这个名称是一个组合单词： Pan是希腊神话里的牧神，指的是一切掌管树林、田地和羊群的神，doc 则是 document 的缩写，意为文档。因此从字面意思来看，可以说 Pandoc 是一个「无所不能的文档转换利器」 (universal markup converter)，而它的确也拥有名副其实的功能。
作为一个始于 2006 年的个人项目，经过 16 年的发展，现在的 Pandoc 已经变得非常庞杂，拥有相当丰富的功能，可以实现 几十种 文件格式的转换，各种调整细节的选项也不计其数，除了基础的文档转换功能外，还能通过 Lua、Python 等脚本语言实现高度自定义的文档转换，甚至成为其他很多现代文档工具的依赖，例如R Markdown、Quarto​。正因如此，它的功能非常复杂，仅PDF 版使用手册 就超过了 150 页。一方面，这使得 Pandoc 上手门槛比较高，容易劝退新手，但另一方面，丰富的功能也让它具有极强的可玩性和无限的可能性，甚至可以不仅限用于文档格式转换，还能实现一些「意料之外」的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a529680d0459453dd742a8fa5f5d4259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965bf4ba6825f3777104120a143d0820/" rel="bookmark">
			【ElasticSearch】EQL操作相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 EQL操作基础语法数据准备数据窗口搜索统计符合条件的事件事件序列 安全检测数据准备查看数据导入情况获取 regsvr32 事件的计数检查命令行参数检查恶意脚本加载检查攻击成功可能性 EQL操作 EQL 的全名是 Event Query Language (EQL)。事件查询语言（EQL）是一种用于基于事件的时间序列数据（例如日志，指标和跟踪）的查询语言。
EQL的优点
EQL 使你可以表达事件之间的关系
许多查询语言允许您匹配单个事件。EQL 使你可以匹配不同事件类别和时间跨度的一系列事件。
EQL 的学习曲线很低
EQL 语法看起来像其他常见查询语言，例如 SQL。 EQL 使你可以直观地编写和读取查询，从而可以进行快速，迭代的搜索。
EQL 设计用于安全用例
尽管你可以将其用于任何基于事件的数据，但我们创建了 EQL 来进行威胁搜寻。 EQL不仅支持危害指标（IOC）搜索，而且可以描述超出 IOC 范围的活动。
前置条件
要运行 EQL 搜索，搜索到的数据流或索引必须包含时间戳和事件类别字段。 默认情况下，EQL 使用 Elastic 通用模式（ECS）中的 @timestamp 和 event.category 字段。
@timestamp 表示时间戳event.category 表示事件分类。 基础语法 数据准备 # 创建索引 PUT /gmall # 批量增加数据 PUT _bulk {"index":{"_index":"gmall"}} {"@timestamp":"2022-06-01T12:00:00.00+08:00","event":{"category":"page"},"page":{"session_id":"42FC7E13-CB3E-5C05-0000-0010A0125101","last_page_id":"","page_id":"login","user_id":""}} {"index":{"_index":"gmall"}} {"@timestamp":"2022-06-01T12:01:00.00+08:00","event":{"category":"page"},"page":{"session_id":"42FC7E13-CB3E-5C05-0000-0010A0125101","last_page_id":"login","page_id":"good_list","user_id":"1"}} {"index":{"_index":"gmall"}} {"@timestamp":"2022-06-01T12:05:00.00+08:00","event":{"category":"page"},"page":{"session_id":"42FC7E13-CB3E-5C05-0000-0010A0125101","last_page_id":"good_list","page_id":"good_detail","user_id":"1"}} {"index":{"_index":"gmall"}} {"@timestamp":"2022-06-01T12:07:00.00+08:00","event":{"category":"page"},"page":{"session_id":"42FC7E13-CB3E-5C05-0000-0010A0125101","last_page_id":"good_detail","page_id":"order","user_id":"1"}} {"index":{"_index":"gmall"}} {"@timestamp":"2022-06-01T12:08:00.00+08:00","event":{"category":"page"},"page":{"session_id":"42FC7E13-CB3E-5C05-0000-0010A0125101","last_page_id":"order","page_id":"payment","user_id":"1"}} {"index":{"_index":"gmall"}} {"@timestamp":"2022-06-01T12:08:00.00+08:00","event":{"category":"page"},"page":{"session_id":"42FC7E13-CB3E-5C05-0000-0010A0125102","last_page_id":"","page_id":"login","user_id":"2"}} {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965bf4ba6825f3777104120a143d0820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df5bba9da7558f3b73a4ffe22673b16/" rel="bookmark">
			MySQL数据库中，在读已提交和可重复读这两个不同事务隔离级别下幻读的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 1. 前 言1.1 并发事务存在的问题1.2 事务的隔离级别1.3 快照读和当前读 2. 不同事务隔离级别下幻读的区别2.1 读已提交下的幻读2.2 可重复读下的幻读2.2.1 情况一，无幻读2.2.2 情况二，有幻读2.2.3 情况三，有幻读 3. 小 结 1. 前 言 在正式开始之前，先简单回顾一下并发事务存在的问题以及事务的隔离级别等内容。
1.1 并发事务存在的问题 当两个或者两个以上事务同时开启去处理同一个表的数据时，可能会存在以下的问题：
丢失修改脏读不可重复读幻读 丢失修改
丢失修改是指当两个或多个事务更新同一行记录，产生更新丢失的现象，事务回滚覆盖和事务提交覆盖都会导致这种现象的产生。
脏读
一个事务能读取到另一个事务已经修改但还没有提交的数据。
不可重复读
在一个事务中多次执行同一条查询语句，读取到的数据内容前后不一致。
幻读
在一个事务中多次执行同一条查询语句，读取到的数据记录在数量上前后不一致，可能多了几条记录也可能少了几条记录。
1.2 事务的隔离级别 为了解决并发事务存在的问题，大佬们想到了一个手段，那就是对事务进行隔离，最好是做到各个事务各干各的，互不干涉，但理想很丰满，现实很骨感，哪可能一步到位呢。
为了应对不同的需要，解决不同的问题，于是决定将事务的隔离分成四个级别，分别是：
读未提交读已提交可重复读串行化 它们各自能解决的并发事务问题如下表所示：
隔离级别 \ 事务问题事务回滚覆盖脏读不可重复读事务提交覆盖幻读读未提交能解决不能解决不能解决不能解决不能解决读已提交能解决能解决不能解决不能解决不能解决可重复读能解决能解决能解决能解决不能完全解决，可能发生串行化能解决能解决能解决能解决能解决 1.3 快照读和当前读 快照读
快照读是基于 MVCC 和 undo log 来实现的，读取数据的历史版本，得到一个 ReadView (事务视图) ，不对数据加锁，适用于简单 select 语句。
这里提一句，所谓 MVCC 并发版本控制，就是靠 ReadView (事务视图) 来实现的，多个 readView 组成 undo log（回滚日志）。
当前读
当前读是基于行锁 + 间隙锁来实现的，读取数据的最新版本，并对数据进行加锁，适用于 insert，update，delete， select .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df5bba9da7558f3b73a4ffe22673b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa853b435dabc381e7e6ab1b1cb16ef/" rel="bookmark">
			json-server 实现简单接口mock
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json-server 实现简单接口mock 工具介绍 Json-server 是一个非常方便的mockserver工具,通俗来说，就是模拟服务端接口数据
开发人员可以不依赖API开发，而在本地搭建一个JSON服务，自己产生测试数据
解决问题 在开发时，若依赖另一方的接口，可以使用mock工具模拟一个服务端的api接口，不依赖API接口的实现，继续开发本模块的功能
优点 1、本地部署
不同于主流的mockserver，json-server不使用外部服务器，不会泄露数据到外部环境
​ PS：postman集成更强大的mockserver能力，但需要登录外部的个人账号，有泄露公司开发信息的风险，IT部门已禁止使用
2、体积小
json-server容量很小，npm全局安装，仅依赖node.js 环境
3、自带数据库
json-server内置了数据存储结构，可以解析json数据作为数据库的内容，可以实现简单的CRUD
安装 ​ 使用npm全局安装json-server：
npm install -g json-server ​ 可以通过查看版本号，来测试是否安装成功：
json-server -v 工具使用 服务器部署 1、创建json-server的数据库目录
在项目或者自定义目录新建文件夹，在文件夹目录下，执行启动命令默认端口为3000，可修改 json-server --host "本地IP" db.json 结果如下：
命令扩展参数： json-server [options] &lt;source&gt; 数简写默认值说明–config-c指定配置文件[默认值: “json-server.json”]–port-p设置端口 [默认值: 3000]Number–host-H设置域 [默认值: “0.0.0.0”]String–watch-wWatch file(s)是否监听–routes-r指定自定义路由–readonly–roAllow only GET requests[布尔]–delay-dAdd delay to responses(ms)–version-v显示版本号[布尔]–help-h显示帮助信息[布尔] 接口和数据自定义 启动server服务器后，若目录下没有对应的json文件，会按照模板创建json
xxx.json 包含了数据库的所有对象信息 ​ 数据库模板文件的参数：
每个json的Key是一个URL路径，json-server这里认为的含义是查询对象表示这里作为示范，修改db.json中url和响应
​ 这里表示，server在端口3000，存在接口 /queryDevice，会返回所有对象
request: /queryDevice response: [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa853b435dabc381e7e6ab1b1cb16ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9ebb390bc8b63f93ae9747fbfc4c74/" rel="bookmark">
			51单片机-433M无线模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、433M无线发射接收模块
2、通过433M模块来控制继电器
接线：单片机VCC、GND给433M、继电器供电，D0接到P1.2，D1接到P1.3，继电器IN接到P1.1。
当A按下时，D0收到高电平，当B按下时，D1收到高电平；判断D0、D1高低电平，若D0为高电平，则给IN赋低电平，从而导通继电器；若D1为高电平，则给IN赋高电平，从而断开继电器。
代码如下：
#include "reg52.h" sbit D0_ON = P1^2; sbit D1_OFF = P1^3; sbit switcher = P1^1;//继电器IN接到P1.1口 void main() { //查询方式判断哪个按键被按下 while(1){ if(D0_ON == 1)//收到遥控信号A，D0表现为高电平 { //A被按下，给继电器IN一个低电平，导通继电器 switcher = 0; } if(D1_OFF == 1)//收到遥控信号B，D1表现为高电平 { //B被按下，给继电器IN一个高电平，断开继电器 switcher = 1; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75af6dd31d9037f5020e36c104ca9a4/" rel="bookmark">
			Halcon轮廓的分割，合并及圆&amp;矩形&amp;线拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变换
平滑轮廓：smooth_contours
算子：smooth_contours_xld(Contours : SmoothedContours : NumRegrPoints : )
示例：smooth_contours_xld (Border, SmoothedContours, 11)
Border（输入对象）：输入轮廓对象
SmoothedContours（输出对象）：输出平滑后的轮廓
11（输入控制参数）：数值越大越平滑
形状变换：shape_trans_xld
算子：shape_trans_xld(XLD : XLDTrans : Type : )
示例：shape_trans_xld (ContCircle, XLDTrans, 'rectangle1')
ContCircle（输入对象）：输入轮廓对象
XLDTrans（输出对象）：输出变形后的轮廓
'rectangle1'（输入控制参数）：输入需要变形的类型
注意：区域圆变形为椭圆 结果还是圆 轮廓圆变形为椭圆 结果是点
封闭轮廓：close_contours_xld
算子：close_contours_xld(Contours : ClosedContours : : )
示例：close_contours_xld (Contours, ClosedContours)
Contours（输入对象）：输入轮廓对象
ClosedContours（输出对象）：输出封闭后的轮廓对象
对轮廓排序：sort_contours_xld
算子：sort_contours_xld(Contours : SortedContours : SortMode, Order, RowOrCol : )
示例：sort_contours_xld (ContoursSplit, SortedContours, 'upper_left', 'true', 'column')
ContoursSplit（输入对象）：输入包含多个轮廓的对象
SortedContours（输出对象）：输出排序轮廓对象
'upper_left'（输入控制参数1）：排序方法
'true'（输入控制参数2）：升序true或者是降序false
'column'（输入控制参数3）：按照行或者列排序
分割
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75af6dd31d9037f5020e36c104ca9a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02aaa2b331478dac9c8e2a210a1373c1/" rel="bookmark">
			Vue组件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：什么是Vue组件？干什么用的？
二：组件的使用 1.非单文件组件
（1）定义：一个文件中包含有n个组件
（2）非单文件组件的使用步骤
（非单文件组件扩展知识点）
1.关于组件名:
2.关于组件标签
3.一个简写方式:
2.单文件组件 ：实际开发中大部分使用的都是单文件组件
一：什么是Vue组件？干什么用的？ 1.Vue组件的定义：实现应用中局部功能代码和资源的集合。
局部就是只控制一小块的地方，比如header组件，就只负责顶部这一块，其他的都不归他管，每个部分都有组件控制
代码包括 HTML ，CSS，JS等，资源比如视频，音频，图片等。
2.作用：复用代码，简化项目编码，提高运行效率。
组件化：当应用中的功能都是多组件的方式来编写的，那这个应用就是组件化的应用。
二：组件的使用 组件分为非单文件组件和单文件组件
1.非单文件组件 （1）定义：一个文件中包含有n个组件 （2）非单文件组件的使用步骤 分为三步： 1.定义组件
2.注册组件
3.使用组件
&lt;script&gt; Vue.config.productionTip = false; //第一步: 定义组件（创建组件） const vc = Vue.extend({ // el:'',//不可以写el,因为最终都是为vm实例对象选择的容器服务 // 模板代码 template:` &lt;div&gt; &lt;h1&gt;创建组件的步骤&lt;/h1&gt; &lt;h3&gt;{{type1}}&lt;/h3&gt; &lt;h3&gt;{{type2}}&lt;/h3&gt; &lt;h3&gt;{{type3}}&lt;/h3&gt; &lt;/div&gt; `, data(){ return { type1:'1.定义组件', type2:'2.注册组件', type3:'3.使用组件' } } }) // 创建实例对象 new Vue({ el:'.box', // 第二步: 注册组件（局部注册） components:{ // aaa是使用时的名字,vc是组件的名字,这两个可以一样比如vc:vc, aaa:vc, } }) &lt;/script&gt; 使用组件可以直接在容器中写&lt;组件名&gt;&lt;/组件名&gt;,也可以在实例中new的时候传入template
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02aaa2b331478dac9c8e2a210a1373c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28159f989d026f699866131e9e3b6e50/" rel="bookmark">
			初学Vue2框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2的使用和基本结构 &lt;script&gt; // 取消一个开发者提示 Vue.config.productionTip = false; // 创建Vue实例 参数是对象 一个实例只能对应一个容器（先到先得） const vm = new Vue({ // el是element缩写 用于指定当前Vue实例为哪个容器服务器，值通常为css选择器 el: '.demo', data: {//data中存储数据供el所制定的容器使用 name: 'ldh', age: 18, }, computed: {//计算属性,当data中的属性被读取时触发回调函数(getter/setter) uname: { get() { console.log('uname被读取'); return this.name; }, set(value) { this.name = value; } } }, methods: {//存放用到的函数 tanchuang() { alert('弹窗提示函数'); } }, watch: {//检测data中数据发生改变时触发回调函数（handler） name: { handler(newValue, oldValue) { console.log(this.name + '被修改了', newValue, oldValue); } } } }); &lt;/script&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28159f989d026f699866131e9e3b6e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2138855a969827fa167dcf7b8968ca2/" rel="bookmark">
			Vue2中的绑定事件和事件修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：绑定事件 事件的基本使用
1.使用v-on:xxx或者@xxx （@等同于v-on） 例如绑定一个点击事件v-on:click(@click)
2.事件的回调需要配置在methods对象中，最终会在实例对象上
3.methods中的配置的函数，不要使用箭头函数（不然this指向会出现问题）
4.methods中的函数都是Vue管理的，函数中的this指向vm或者组件实力对象
5.@click = "demo"和@click ="demo($event, 实参)"
代码如下
&lt;body&gt; &lt;div class="box"&gt; &lt;h3&gt;欢迎来到{{name}}&lt;/h3&gt; &lt;!-- 绑定事件 v-on:click --&gt; &lt;button v-on:click="showInfo1"&gt;点我提示信息&lt;/button&gt; &lt;!-- 简写 @click --&gt; &lt;button @click="showInfo2($event,66)"&gt;点我提示信息&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; new Vue({ el: '.box', data: { name: '尚硅谷', address: '北京' }, methods: { showInfo1() { alert('同学你好!'); }, showInfo2(e, num) { alert('同学你好!!' + num); console.log(e.target); } } }) &lt;/script&gt; 绑定点击事件调用的函数都写在methods属性里面，模板代码才可以调用
！！！注意 当使用到event事件时，需要在函数参数中写$event占位
二：事件修饰符 Vue中的事件修饰符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2138855a969827fa167dcf7b8968ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f4901e800816a7a2c60267c00089576/" rel="bookmark">
			python操作word——python-docx和python-docx-template模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：项目用到了导出文档，综合考虑使用python-docx模块
目录 python-docx安装docx文档布局词汇三个部分文档段落文字块 四级结构（表格） 使用导入word读操作获取段落获取段落文本内容获取文字块文本内容遍历表格表格设置字体样式 写操作保存文件添加标题添加段落添加文字块添加空白页添加图片设置样式 word转pdf,htmlword----&gt;htmlword----&gt;pdf 实例实际案例按顺序读取word文档中的所有信息（文本，图片，表格）写入表格并增加边框最后是用到的包 python-docx-template安装模板语法插入图片操作表格 合并word文档docxcompose安装使用 字体文件ttflinux中存放位置windows中存放位置 python-docx 安装 pip install python-docx
docx文档布局词汇 三个部分 文档Document 段落Paragraph 文字块Run
文档 就是docx文档
段落 就是寻常段落
文字块 如下，短句子中有多种不同的样式，则会被划分成多个文字块。
如果所示，这个paragraph一共四个run。
四级结构（表格） Document - Table - Row/Column - Cell四级结构
使用 导入word from docx import Document # 只要不指定路径，就默认为创建新Word文件 wordfile = Document(path) 读操作 获取段落 三个部分：一个doc由多个paragraph组成
paragraphs = wordfile.paragraphs # 得到一个段落对象列表 # [ p1,p2,p3...] print(paragraphs) 获取段落文本内容 for paragraph in wordfile.paragraphs: print(paragraph.text) 获取文字块文本内容 一个paragraph段落由一个或者多个run文字块组成
for paragraph in wordfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f4901e800816a7a2c60267c00089576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098dbef3d7383e9123ebf4cbe221d48a/" rel="bookmark">
			java-常用类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java-常用类 java-常用类引出----API一）什么是API二）如何使用API帮助文档1. API来源1.1 自己去下载对应离线版本JDK-API1.2 jdk-api在线帮助文档 一、Object类一）常用方法构造方法常用方法1、 getClass()2、 toString()方法3、hashCode()方法4、 equals()方法5、 finalize()方法（6）clone方法 二、Objects类equals()方法如何使空对象调用也能调用equals方法呢？Objects具体方法可以自行查看帮助文档 三、System类成员变量常用方法 四、Math类一）常用方法 五、Random类六、Arrays类常用方法 七、BigInteger类常用方法 八、BigDecimal类常用方法 九、DecimalFormat类常用方法特殊模式字符(`占位符`)应用场景（1）实现四舍五入保留n位小数（2）把数字转换为货币的格式（3）显示数字的百分比（4）设置特定的符号 常用RoundingMode java-常用类 引出----API 一）什么是API API (Application Programming Interface) ：应用程序编程接口
Java API是一本程序员的字典 。java中的API指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。
二）如何使用API帮助文档 1. API来源 1.1 自己去下载对应离线版本JDK-API 双击打开api
找到索引选项卡中的输入框
查看类信息
1.2 jdk-api在线帮助文档 链接：jdk-api在线帮助文档
在线文档与离线文档差不多
一、Object类 java.lang.Object类是Java语言中的根类，是所有java类的父类，即所有类都直接或间接的继承自该类。在对象实例化的时候，最终找的父类就是Object。Object类中所定义的方法，是所有对象都具备的方法。Object类型可以存储任何对象。 作为参数，可接受任何对象。作为返回值，可返回任何对象。 如果一个类没有特别指定父类， 那么默认则继承自Object类。 public class MyClass /*extends Object*/ { // ... } 一）常用方法 Object类中包含的方法有11个，我们主要记录常用的方法：
构造方法 public Object();
子类的构造方法默认访问的是父类的无参构造方法
常用方法 1、 getClass() public final Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098dbef3d7383e9123ebf4cbe221d48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77afcdf1fb2c7a5bc15c1a0639e0986a/" rel="bookmark">
			双指针技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、双指针技巧——情景1 通常，我们只需要一个指针进行迭代，即从数组中的第一个元素开始，最后一个元素结束。然而，有时我们会使用两个指针进行迭代。
双指针的典型场景
(1)从两端向中间迭代数组。
(2)一个指针从头部开始，而另一个指针从尾部开始。
1.反转字符串 解法：双指针 c
void swap(char *a, char *b) { char t = *a; *a = *b, *b = t; } void reverseString(char *s, int sSize) { for (int left = 0, right = sSize - 1; left &lt; right; ++left, --right) { swap(s + left, s + right); } } c++
class Solution { public: void reverseString(vector&lt;char&gt;&amp; s) { int n = s.size(); for (int left = 0, right = n - 1; left &lt; right; ++left, --right) { swap(s[left], s[right]); } } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77afcdf1fb2c7a5bc15c1a0639e0986a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2091925e4482e493af1126f22314c8/" rel="bookmark">
			实现Newton方法的最小化函数(pytorch)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们要明确需求
def newton(theta, f, tol = 1e-8, fscale=1.0, maxit = 100, max_half = 20)
● theta是优化参数的初始值的一个向量。
● f是要最小化的目标函数。该函数应将PyTorch张量作为输入，并返回一个张量。
● tol是收敛容忍度。
● fscale 粗略估计最佳状态下f的大小–用于收敛性测试。
● maxit 在放弃之前尝试的牛顿迭代的最大数量。
● max_half 一个步骤在得出该步骤未能改善目标的结论之前应该被减半的最大次数。
目标。
1.函数需检查初始θ是否有限，并计算目标值f0。然后，使用“torch.autograd.functional”计算f在初始θ处的雅可比和hessian（同时检查它们是否是有限的）。
2.当Hessian不是正定时，使用变量“time” * 10。
3.变量“try_half”确保只输出一个关于达到最大减半次数的警告
4.更重要的是，它使用牛顿步长和方向迭代更新θ，直到达到收敛或最大迭代次数。
5.在每次迭代过程中，函数检查目标或导数在当前或新θ下是否是有限的，以及该步骤是否导向较小的目标。如果步骤未能减少目标，则函数会将步骤大小减半，直到目标减少或达到步骤减半的最大次数。如果达到步骤减半的最大次数，该功能将发出警告。
6.该函数还通过评估梯度向量的范数以及Hessian是否是正定的来检查收敛性。如果梯度向量足够接近零，函数会检查Hessian是否是正定的。如果Hessian不是正定的，函数将单位矩阵的一个小倍数（10^-8）加到Hessian上，然后重试（time*10）。
7.如果在没有收敛的情况下达到最大迭代次数，则函数会发出错误。该函数返回一个dict，其中包含theta的最终值、目标值f0、迭代次数iter_count和f在最终theta处的梯度。
def newton(theta, f, tol=1e-8, fscale=1.0, maxit=100, max_half=20): # check if the initial theta is finite if not torch.isfinite(theta).all(): raise ValueError("The initial theta must be finite.") # initialize variables iter_count = 0 #theta is a vector of initial values for the optimization parameters f0 = f(theta) #f is the objective function to minimize， which should take PyTorch tensors as inputs and returns a Tensor #autograd functionality for the calculation of the jacobian and hessians grad = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f2091925e4482e493af1126f22314c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c206c5dc1a608febe4ba6cb0d343dfc/" rel="bookmark">
			使用Selenium控制Chrome浏览器 --工作自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Selenium控制Chrome浏览器 --工作自动化
背景： 最近朋友在用秒账做帐时，由于销售单量很大，重复录入工作一天一录就近五个小时，寻求帮助，问能不能把这重复劳动减少些，看后分析，使用web自动化，应能解决问题，特此记录如下：
Selenium 简介：Selenium 是一套完整的web应用程序测试系统，包含了测试的录制（Selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。Selenium 支持的语言包括C#，Java，Perl，PHP，Python 和 Ruby。目前，Selenium Web 驱动程序最受 Python 欢迎。 Selenium 测试脚本可以使用任何支持的编程语言进行编码，并且可以直接在大多数现代 Web 浏览器中运行。
安装Selenium： pip install selenium
查看Chrome版本，下载安装chromedriver chromedriver的Windows版本分为32位和64位，用的32位Windows操作系统的同学请下载Windows x86版本，用64位Windows操作系统的同学请下载Windows x86-64版本。
下载地址：http://chromedriver.storage.googleapis.com/index.html
根据自身浏览器选择：
下载后是一个压缩包，解压后只有一个文件：chromedriver.exe，将它放到python安装目录的scripts目录。我调试时直接放在了指定目录中，增加了代码：
chrome_driver = os.path.join(os.getcwd(), "chromedriver.exe") 调试前装备： # -*- coding: utf-8 -*- # @Time : 2023年04月30日 20时51分 # @File : 秒帐.py # @notice ： import os from selenium import webdriver from selenium.webdriver.chrome.options import Options chrome_options = Options() # chrome_options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c206c5dc1a608febe4ba6cb0d343dfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1aabc302f23d35bbb4fb7a712a7fc5/" rel="bookmark">
			337. 打家劫舍 III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树形DP。
DP数组的含义，这个已经不再是数组了，不过含义和之前相同遍历顺序，下面单独讲初始值，也不需要了打印DP数组，打印递归不是个明智的选择 得用递归，递归函数要求获取算当前节点和不算当前节点时最大的dp结果。
直接看代码吧，如果不选当前节点，不一定leftresult就一定得选择has，右节点同理；如果选了当前节点，左右就肯定得选nothas了
class result { public: int has_; int notHas_; result() : has_(0), notHas_(0) {} result(int has, int notHas) : has_(has), notHas_(notHas) {} int getMax() { return max(has_, notHas_); } }; result treeRob(TreeNode *cur) { if (nullptr == cur) { return {0, 0}; } auto leftResult = treeRob(cur-&gt;left); auto rightResult = treeRob(cur-&gt;right); result curResult; curResult.notHas_ = leftResult.getMax() + rightResult.getMax(); curResult.has_ = cur-&gt;val + leftResult.notHas_ + rightResult.notHas_; return curResult; } int rob(TreeNode *root) { if (nullptr == root) { return 0; } auto ret = treeRob(root); return ret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1aabc302f23d35bbb4fb7a712a7fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58418ff7db2ffa7b11921749bd18eef/" rel="bookmark">
			arcgis 图例变灰无法添加图例的处理方式（同样适用于指北针、比例尺等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在此点一下这里的焦点数据框，就可以顺利处理图例了
这时插入中的图例可以变黑，成为可操作模式
点击“插入”，点击“图例”即可插入图例
指北针、比例尺等插入方式同上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0f61a51e1739b11a1923e1cd2786fb/" rel="bookmark">
			背包问题题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 0-1背包步骤2. 完全背包步骤3. 三种遍历顺序的关系3.1 0-1背包和普通完全背包3.2 考虑顺序的完全背包和不考虑顺序的完全背包 4. **关于背包满不满的问题。** 1. 0-1背包步骤 dp数组的含义：纯0-1背包：有若干种物品，每种选一个，一个背包最多能装多大价值（可以不用装满）设置初始值：我见过的一般都是0，只有dp[j]+=dp[j-nums[i]]这种才是1，因为如果是0就始终是0了遍历顺序：纯0-1先正向遍历物品，再逆向遍历容量打印dp数组 dp数组含义：
纯0-1：这个容量的背包的最大价值
分割等和子集：这个包能装满吗？（价值等于重量）
最后一块石头的重量：这个背包最多能装多少（这一道和上面那道差不多）
目标和：这个背包最多能有多少种方法
一和零：这个背包最多能装多少个物品
初始化：上面这些题初始化只有那个目标和第一个参数不是0，因为目标和时+=，其它都是max，目前先按照这个规律记着，后续出问题再说。
0-1背包遍历顺序：
第一个for用于遍历物品，自然是把数组从头遍历到尾
第二个for用于倒序遍历容量，初始值自然是数组的最大值，退出情况就是数组越界的情况。
不是计算次数，单纯计算大小的：
vector&lt;int&gt;product;//&lt;物品 int capacity;//&lt;容量 vector&lt;int&gt;dp(capacity+1,0);//&lt;dp大小为容量+1 for(int i=0;i&lt;product.size();++i)//&lt;先遍历物品 { for(int j=dp.size()-1;j-product[i]&gt;=0;--j)//&lt;再遍历容量，倒序遍历，满足不越界条件 { dp[j] = max(dp[j],dp[j-product[i]]+product[i]); } } 计算次数
vector&lt;int&gt;product;//&lt;物品 int capacity;//&lt;容量 vector&lt;int&gt;dp(capacity+1,0);//&lt;dp大小为容量+1 dp[0]=1; for(int i=0;i&lt;product.size();++i)//&lt;先遍历物品 { for(int j=dp.size()-1;j-product[i]&gt;=0;--j)//&lt;再遍历容量，倒序遍历，满足不越界条件 { dp[j] += dp[j-product[i]]+product[i]; } } 2. 完全背包步骤 dp数组的含义：纯完全背包：有若干种物品，每种无限个，一个背包，最多能装多大的价值（当然可以不装满）设置初始值：我见过的一般都是0，只有+=这种才是1，因为如果是0就始终是0了遍历顺序：纯完全背包不在乎遍历顺序，都是物品和容量都是正序遍历。不过遍历容量的时候都得是0到size大小，判断数组是否越界单加一个if。如果是先遍历物品再遍历容量，和0-1一样的时候，是组合数（无序），先遍历容量再遍历物品是排列数（有序）打印dp数组 完全背包：
和0-1背包几乎一样，传统的完全背包先遍历物品还是先便利容量是无所谓的。
组合数，122和221不再重复计算。
vector&lt;int&gt;product;//&lt;物品 int capacity;//&lt;容量 vector&lt;int&gt;dp(capacity+1,0);//&lt;dp大小为容量+1 for(int i=0;i&lt;product.size();++i)//&lt;先遍历物品 { for(int j=0;j&lt;dp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea0f61a51e1739b11a1923e1cd2786fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11a2929eea0efc49e5eff0c5d239d2b/" rel="bookmark">
			Github.com-Host修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #github 140.82.112.3 github.com # by ipaddress.com 140.82.112.4 github.com # by guess 140.82.114.3 github.com # by guess 140.82.114.4 github.com # by https://raw.hellogithub.com/hosts 199.232.69.194 github.global.ssl.fastly.net # by https://raw.hellogithub.com/hosts 20.205.243.166 github.com #新加坡 微软云 # by https://ip.chinaz.com/ #时间 2023-04-30 16:53 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bd763026af87cdfed3026422b6a9e5/" rel="bookmark">
			海康威视监控下载下来的mp4格式的视频,小类别MPEG-PS格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康下载视频格式：用mediainfo查看
普通mp4格式用mediainfo查看
**
视频流中ES，PES，PS，TS，RTP概念说明 ES:又称为原始流，直接从编码器出来，可以是编码过的H264，MJPEG，音频AAC，音频G711等。ES只包含一种内容的视频，如只含视频或者只含音频。
PES: ES流经PES打包器形成，将ES流分组，打包，加入包头。PES包由包头和payload组成。PES包是PES流的基本单位。
PTS(Decoding Time Stamp)/DTS(Presentation Time Stamp)：打在PES包的包头里面，用于表示时间，是音视频同步的关键。在ffmpeg中，PTS表示显示的时间，DTS表示的是解码的时间。同时，用ffmpeg处理的时候PTS必须大于或等于DTS，否则会返回-22的错误。
PS(节目流)：由PS组成，而一个PS包又由若干个PES包组成，到这里，ES经过了两层的封装。PS包头包含了同步信息与时钟恢复信息。
关于PS流的具体格式以及具体分析可以参考博客：作者写的很好，我看的时候和我获取的海康的PS流有一些出入，但大体上都差不多https://blog.csdn.net/chen495810242/article/details/39207305
**TS(传输流)?*由定长的TS包包组成(188字节)，而TS包是对PES包的一个重新封装(到这里，ES也经过了两层封装)。TS流较PS流的优势是信息丢失情况更好。TS包中的数据可以是视频数据，音频数据，填充数据，PSI/SI表格数据等。
**RTP(实时传输协议)：**是一种针对互联网上多媒体码流的传输协议。RTP协议时长用于互联网点播，视频会议，视频监控等应用。RTP使用的包为RTP包，作用域传输层。
其他人给出的方案：
1、需要海康编解码库。
2、直接用 url 拉取 h264,用 ffmpeg 转成 MP4 封装就行了。
微信浏览器不能播放mp4视频的问题 H.264有四种画质级别,分别是baseline, extended, main, high：
1、Baseline Profile：基本画质。支持I/P 帧，只支持无交错（Progressive）和CAVLC；
2、Extended profile：进阶画质。支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC；(用的少)
3、Main profile：主流画质。提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），
也支持CAVLC 和CABAC 的支持；
4、High profile：高级画质。在main Profile 的基础上增加了8x8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；
H.264 Baseline profile、Extended profile和Main profile都是针对8位样本数据、4:2:0格式(YUV)的视频序列。在相同配置情况下，High profile（HP）可以比Main profile（MP）降低10%的码率。
根据应用领域的不同，Baseline profile多应用于实时通信领域，Main profile多应用于流媒体领域，High profile则多应用于广电和存储领域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6340128101a77143a562ce15dfa0b0/" rel="bookmark">
			SpringBoot整合dubbo以及nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot整合dubbo以及nacos 一、引入依赖 注意，我们这边整合的时候分为消费者，生产者和中间服务接口层
1、父POM文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fly&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dubbo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;spring-boot-dubbo-interface&lt;/module&gt; &lt;module&gt;spring-boot-dubbo-provider&lt;/module&gt; &lt;module&gt;spring-boot-dubbo-consumer&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;dubbo.version&gt;3.0.7&lt;/dubbo.version&gt; &lt;spring-boot.version&gt;2.6.7&lt;/spring-boot.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- nacos作注册中心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 2、生产者依赖 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b6340128101a77143a562ce15dfa0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b0cd00065ad8e6d53b22617b8f8552/" rel="bookmark">
			Python系列： pyapollo连接apollo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 pyapollo库使用时会报链接超时，所以这里不再使用。
功能类 #! /usr/bin/env python3 #-*- coding:utf-8 -*- import json import logging import sys import threading import time import requests class ApolloClient(object): def __init__(self, app_id, cluster='default', config_server_url='http://localhost:8080', interval=60, ip=None): self.config_server_url = config_server_url self.appId = app_id self.cluster = cluster self.timeout = 60 self.interval = interval self.init_ip(ip) self._stopping = False self._cache = {} self._notification_map = {'application': -1} def init_ip(self, ip): if ip: self.ip = ip else: import socket try: s = socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b0cd00065ad8e6d53b22617b8f8552/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2fa97ea1411ce5973fedd62921aea8e/" rel="bookmark">
			Linux命令(9)之telnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux命令之telnet
Linux telnet命令，主要用于：
1.验证端口的连通性
2.telnet远端登入(不常用)
telnet语法格式：telnet 主机名称[或IP地址[&lt;通信端口&gt;]]
telnet常用参数 参数说明-l &lt;用户名称&gt;要登入远端主机的用户名称 实例：
1.验证端口的连通性 说明端口连通性正常。
2.登录远程主机(不常用) telnet 192.168.10.101
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/82/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>