<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4078f4411da4e4ac7f7a40846f6234c1/" rel="bookmark">
			你知道plot、fplot 和 ezplot 的区别吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 plot、fplot 和 ezplot 都是 MATLAB 中用于绘制函数图像的三个函数，它们的主要区别如下：
1.plot 函数是 MATLAB 中最基本的绘图函数，用于绘制在二维坐标系中的数据点或曲线。需要手动指定自变量和因变量的向量或矩阵，并可以通过设置各种属性来调整绘图效果。
2.fplot 函数可以绘制函数的图像，输入一个函数的句柄或者字符串，然后绘制该函数在给定区间内的图像。fplot 可以绘制一些在直角坐标系中难以表达的曲线，比如极坐标和参数方程。
3.ezplot 函数也可以绘制函数的图像，输入一个函数的字符串，而不是句柄，然后绘制该函数在默认区间内的图像。ezplot 相比于 fplot 更加简单易用，不需要手动指定区间等参数，但同时也不支持一些高级的绘图功能。
总体来说，plot 函数适用于简单的数据点和曲线绘制，fplot 可以绘制更加复杂的函数图像，而 ezplot 则是最简单的绘图函数，适用于快速绘制简单函数的图像。
%画出sinx的图像 clear all x=linspace(-5,5,100);y=sin(x); subplot(1,3,1);plot(x,y,'displayname','sinx'); legend('show'); subplot(1,3,2);fplot(@sin,[-5,5]); title('sin(x)'); subplot(1,3,3);ezplot('sin(x)',[-5,5]); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1032ae851cafbf240fb4029020cfc6f/" rel="bookmark">
			Mac的日常操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于mac查找指定路径下文件的方法： 打开访达快捷键 command+shift+G 打开前往文件夹的窗口粘贴指定路径前往指定文件位置 关于mac中复制文件路径的方法： 打开访达找到指定文件/文件夹将文件/文件夹拖至浏览器的地址栏地址栏显示文件路径，复制即可用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f772f6c3132229b2f36390fd46359e8a/" rel="bookmark">
			Python将数组直接转化为可读字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果希望将一个NumPy数组转换为可读的字符串，可以使用numpy.array2string()函数。该函数可以指定一系列选项对数组输出格式进行设置，包括指定小数点后的位数、是否打印数组边界、是否换行等等。
import numpy as np arr = np.array([1, 2, 3, 4, 5, 6]) # 将数组转换为可读字符串 target_arr = np.array2string(arr, separator=', ', formatter={'all': lambda x: '{:.5f}'.format(x)}, suppress_small=True) print(target_arr) print(type(target_arr)) 在这个例子中，我们使用了一个’options’参数字典来设置输出格式的选项。formatter选项使用lambda表达式对每个元素进行格式化，而suppress_small选项则指定小数点后的位数。
输出结果如下：
[1.00000, 2.00000, 3.00000, 4.00000, 5.00000, 6.00000] &lt;class 'str'&gt; 进程已结束,退出代码0 注意：这个操作会把数组转化成字符串格式，同时会保留数组的[ ]，如果介意请用下面的形式：
import numpy as np # 创建包含5个整数的数组 arr = np.array([1, 2, 3, 4, 5]) # 将数组转换为字符串 str_arr = np.array_str(arr) # 或者使用 np.ndarray.tostring() # str_arr = arr.tostring() # 删除方括号和换行符 str_arr = str_arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f772f6c3132229b2f36390fd46359e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0dadb879818d696f1f4dd74a900680/" rel="bookmark">
			nacos登录 提示权限认证失败 没有命名空间的访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 环境：centos7.9 nacos-2.2.2
问题描述 最近在部署nacos-2.2.2版本的时候，这是目前2023年4月份最新版本，发现按照start.out日志给出的登录地址，http://192.168.158.128:8848/nacos/index.html登录，发现总是提示一个"user not found！权限认证失败，没有命名空间的访问权限" 这个弹窗，如下所示：
即使登录进去给所有的命名空间绑定ROLE_ADMIN角色，还是一样。后来发现使用http://192.168.158.128:8848/nacos/index.html时，URL会自动补全http://192.168.158.128:8848/nacos/index.html#/login?namespace=&amp;pageSize=&amp;pageNo= ，怀疑就是由于后面补全的这段URL造成的。
而且登录进去后，重新退出来，发现URL变成了http://192.168.158.128:8848/nacos/#/login，没有那个权限不足的弹窗了，
后来直接使用http://192.168.158.128:8848/nacos/#/login就再也没有弹窗提示了。
以上问题的原因，怀疑是不是nacos-2.2.2这个版本有bug，因为官方说从 nacos-2.2.1版本之后，配置文件里面的auth相关的用户认证的参数需要自己填写值，这个地址https://nacos.io/zh-cn/docs/v2/guide/user/auth.html说明了认证相关的参数怎么配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19a0a5e429f2fadc8194d2280faa09e/" rel="bookmark">
			jmeter生成html测试报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先把测试脚本写好
二、利用命令生成html报告
命令：jmeter -n -t 【Jmx脚本位置】-l 【结果文件result.jtl存放的位置】-e -o 【生成HTML报告指定文件夹】
参数解释：
-n：表示non gui mode，就是非图形化模式。
-t：指定JMX脚本路径，即test plan（测试计划）。后面跟需要运行的JMeter 脚本的路径和脚本名称。
-l：指定结果文件路径。后面跟输出结果文件路径和结果文件名称。
1）若没有指定指定结果文件路径，则自动创建，可以生成.csv文件或者.jtl文件。
2）若只写脚本名称，则默认是在当前目录查找或创建。
-e：设置测试完成后生成测试报表。
-o：指定测试报表生成文件夹。文件夹必须为空或不存在。
例如：jmeter -n -t C:\Users\yuhaiyan\HTTP请求.jmx -lC:\Users\yuhaiyan\result.jtl -e -oC:\Users\yuhaiyan\report
分布式压测：
https://www.cnblogs.com/wuyy353558733/articles/16329847.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690959b072aa7adddabb55ce64bb19d5/" rel="bookmark">
			【SQLserver】使用openrowset方法导入EXCEL表格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
在之前的一篇博文中记录了用OPENDATASOURCE函数将EXCEL数据写入SQLserver表中的方法。这一方法需要表名sheet1为固定名称不可更改。实际业务中可能会遇到表名随着日期而改动的情况，如果excel表名和写入SQL语句里的表名不一致就会出错。这篇博文介绍了如何跳过表名sheet1直接读取数据的方式。
--导入整张表语句
--SELECT * FROM OPENDATASOURCE('Microsoft.ACE.OLEDB.12.0','Data Source=C:\Data\qaz\123.xlsx;Extended Properties="Excel 8.0;HDR=YES;IMEX=1"')...Sheet1$
二、SQL语句
--导入指定行列语句 SELECT * FROM openrowset( 'Microsoft.ACE.OLEDB.12.0','Excel 8.0;Database=C:\Data\qaz\123.xlsx','select * from [Sheet1$A1:BC1048576]') 说明：
① database：这部分填写excel文件存放路径；
②select * from[sheet1$A1:BC1048576]:读取表格的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1117e3168d220272aa6c97baa490fc/" rel="bookmark">
			CPU架构简介（ARM、X86/Atom、MIPS、PowerPC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM、MIPS、PowerPC 均是基于精简指令集RISC机器处理器的架构
X86是基于复杂指令集的架构，Atom则基于是x86指令集的精简版
ARM架构 ARM架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于行动通讯领域，符合其主要设计目标为低耗电的特性。
优势：价格低；能耗低；ARM 授权方式：ARM 公司本身并不靠自有的设计来制造或出售 CPU ，而是将处理器架构授权给有兴趣的厂家。生产厂商：TI （德州仪器）/Samsung（三星）/Freescale（飞思卡尔）/Marvell（马维尔）/Nvidia（英伟达） ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设
x86系列/Atom处理器 x86是英代尔Intel首先开发制造的一种微处理器体系结构的泛称。
x86架构是重要地可变指令长度的CISC（复杂指令集电脑，Complex Instruction Set Computer）。
常见的CISC微指令集CPU主要有AMD、Intel、VIA 等的 x86 架构CPU那为何称为 x86 架构呢？ 这是因为最早的那颗 Intel 发展出来的 CPU 代号称为 8086，后来依此架构又开发出 80286, 80386…， 因此这种架构的 CPU 就被称为 x86 架构了。不同的 x86 架构的 CPU 有什么差异呢？除了 CPU 的整体结构(如第二层快取、每次运作可执行的
指令数等)之外，主要是在于微指令集的不同。新的x86的 CPU 大多含有先进的微指令集， 这些微
指令集可以加速多媒体程序的运作，加强虚拟化的效能。 Intel Atom（中文：凌动，开发代号：Silverthorne）是Intel的一个超低电压处理器系列。处理器采用45纳米工艺制造，集成4700万个晶体管。L2缓存为512KB，支持SSE3指令集，和VT虚拟化技术（部份型号）。
MIPS系列 MIPS是很流行的一种RISC处理器。MIPS的意思是“无内部互锁流水级的微处理器”(Microprocessor without interlocked piped stages)，其机制是尽量利用软件办法避免流水线中的数据相关问题。
与英特尔采用的复杂指令系统计算结构(CISC)相比，RISC具有设计更简单、设计周期更短等优点，并可以应用更多先进的技术，开发更快的下一代处理器。
MIPS自己只进行CPU的设计，之后把设计方案授权给客户，使得客户能够制造出高性能的CPU。
PowerPC系列 PowerPC 是一种精简指令集（RISC）架构的中央处理器（CPU）
PowerPC架构的特点是可伸缩性好、易嵌入、方便灵活、能耗低。PowerPC 处理器有广泛的应用范围（如任天堂 Gamecube 使用了 PowerPC）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1117e3168d220272aa6c97baa490fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443e8be9ac1d85a179abc83bced16882/" rel="bookmark">
			看完这篇，保证你学网络安全一帆风顺！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全入门很难吗？总有人抱怨黑客入门太难了，然后仔细了解之后却发现，觉得难是因为看的视频教程都不是配套的，都是这里学一点、那里学一点，脑子里连基本的框架都没有。更过分的是，有的人学了好几个月，甚至都不知道网络安全是干嘛的。
网络安全入门，入门就是要把知识讲的逻辑清晰、言简意赅、通俗易懂，把复杂的东西简单化，才是有能力的体现。我们的詹老师就非常擅长用生动形象的例子来解释一些复杂难懂的知识。
网络安全是什么呢？是不是学会了就可以随便攻击别人的的系统了？随便窃取别人的信息了？
其实并不是，并没有电视剧里面那种中二、热血。虽然学习完网络安全技术之后，从理论上来说可以做到如此中二、热血的事情，但是这些都是违法的。千万不要踩到这个红线了，否则三年五年都是比较轻的。
我们现在所说的网络安全基本上都是指白帽子，也就是网络安全工程师，主要的工作是调试和分析计算机安全系统。真正从事网络安全的人从来不称自己是黑客，都会说是做网络安全的，只会一些皮毛的菜鸟才自称黑客。
想要成为一名网络安全工程师，就要学会渗透测试这一核心技术。也就是通过模拟黑客恶意攻击的方法，来评估计算机网络安全的安全性。
网络安全入门需要掌握的技术
1、网络安全术语基础
在这个圈子里面混，一定要搞清楚他们的常用术语，否则会被贻笑大方。木马、注入、肉鸡、水坑攻击、端口、webshell、DDoS等等都是需要学会的。当然还有一些常用工具的名字术语，都需要了解。
关于专业术语方面的学习资料可以找我们，基本所有的网络安全术语都有涉及，对计算机网络原理也有一定基础要求，不会的还可以去百度学习一下。
当然，这部分学习结束也仅仅是开始，是最基础的部分。想要攻击别人的电脑还有很长的一段路要走，还要掌握协议、了解渗透技术和技巧等等。
2、网络协议
入门黑客前的重要一步，就是了解网络协议：TPC/IP。你只要懂了个大概，对后期做渗透测试以及了解一些漏洞原理帮助是非常大的，比如SSRF漏洞，他支持一些http、ftp、file...等等！
网站的重要性就不需要多说了吧，要想成为一名网络安全，不懂网站怎么可以。http、www、html、css、JavaScript等建站所需的技术都要会，这算是基本功！！
3、编程
这部分可能对于新手来说不是特别友好，但是依旧是非常重要的，还是需要多学习多练习的。新手可以从Python开始学，练习编程、练习编程思想学会用计算机的思维去思考问题。而且这种计算机语言是通的，只要你入门了其中一门语言，那么其他语言学起来也不会很困难。所以一开始选择一个更容易入门的语言，不用纠结什么语言更好。
4、网络安全工具
不是简单的远控软件，而是作为一名专业的网络安全工程师必须要知道的Hydra、medusa、sqlmap、AWVS、Burpsuite、Beef-XSS、Metasploit、Nessus、wireshark等安全工具，这些都是在这个圈子里比较常用的。而且一定要学会sqlmap、burpsuite和metasploit这三款工具！
5、漏洞原理
当你已经熟悉编程，有了编程思维、并且熟悉网络安全工具之后，你就可以去学习漏洞原理了。比如：XSS、sql注入、文件上传、文件包含等等。
学会编程之后，这些漏洞原理学起来会非常快。然后就可以去实战演练端口爆破。找好工具，用虚拟机搭建爆破环境，用物理机爆破目标虚拟机。
在学习漏洞原理时，一定要精通一个漏洞之后再去学习下一个新的漏洞，这样才能打好基础。
说到这里，如果你仅仅是对网络安全感兴趣，那么这些知识完全够你拿去玩了。但是如果是想转行从事网络安全行业，这点知识就不够用了。
这仅仅是入门级别的水平，想要成为一名有价值的网络安全工程师，那就要学习更多的知识内容、掌握更多的黑客技术，让能力得到提升。这时候就需要系统的学习，长期的辅导。
随着大数据、物联网、人工智能等新技术的发展，信息技术与经济社会各领域的融合肯定会更加深入，网络安全与每个人的生活都息息相关。时代在不断发展，网络安全也在不断面对挑战，所以网络安全的知识永远也学不完，并且会越学越多。
所以即便以后工作了，成为大佬级别的人物了，也是需要不断学习新知识、新技术的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfa53091ebd096e93f978496fd8391e/" rel="bookmark">
			【vue3&#43;elementPlus】在el-table中使用popconfirm、popover、tooltip、select时，出现placement错位或者框被table的列遮挡的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，第一种情况，项目设置了zoom，会导致el-popconfirm、el-popover、el-tooltip、el-select位置不对
解决方案：
:temported="false"	// 给以上标签加该属性，意思是不插入body，el-popconfirm、el-popover、el-tooltip、el-select的节点会放在当前所写的页面的相应位置 如果不设置temported，el-popconfirm是放在body下面的
这是设置了temported="false"的，可见此时el-popconfirm已经放到了相应的位置
然后通过css调整即可，最简单的就是：子绝父相，用定位控制popconfirm的位置，top: 0, left: 0 就可以一直固定在需要的位置上
其次，其实这个问题已经解决了大半，只有在el-table中使用popconfirm、popover、tooltip时，会出现一个新的问题：表格的单元格会遮挡popconfirm、popover、tooltip的显示，无论怎么设置z-index，都不生效
解决方案：
// 设置每一行的定位 &lt;el-table :data="tableData" style="width: 100%" :row-style="{ position: 'relative' }" &gt; /* 获取每一行, 排他思想, 除了被点击的那一行, 其他zIndex都设为2022, 提高pop父盒子的层级 */ const del = (index: number, event: any) =&gt; { let listDom = document.querySelectorAll('.elp-table__row') listDom?.forEach((item: any) =&gt; { item.style.zIndex = 0 }) event.path[4].style['z-index'] = 2011	// listDom[index].style['z-index'] = 2011 /* event.path[4]是当前行的dom节点 如果只有一个简单的表格，用 listDom[index]去设置即可，但是我的场景是表格的每一行下面还有二 级表格，所以用event.path[4] */ }; 我的场景是：点击操作列的删除，弹出el-popconfirm，所以在删除按钮上绑定上述事件并传入当前是第几行
&lt;el-popconfirm title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfa53091ebd096e93f978496fd8391e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a1bd3e909cf44e2ae87302fb79e51f/" rel="bookmark">
			如何获取想要的颜色值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode想换一个护眼的主题色，但是vscode可选的主题色中并无法找到合适的护眼的浅绿色，小筛在百度上找了好久也没能找到合适的颜色。
后来用迅捷PDF翻阅电子书，设置护眼背景色，喜欢上了他的浅绿色主题，盲试了好久，没能找到极其相似的颜色。用网页的颜色吸取器也没能成功，不得不采用笨办法，虽然笨，但是解决了小筛的问题。
第一步：打开电脑自带的“画图”应用
第二步：截取目标颜色部分为图片
第三步：将截取的图片粘到“画图”应用画布中
第四步：用“画图”应用中，工具栏部分的“颜色选取器”吸取图片中的颜色
第五步：点击工具栏中的“编辑颜色”，可以看到如下界面
该界面的RGU可以作为颜色RGB的值，如果需要转成十六进制，在网页进行在线转换即可。
https://www.sioe.cn/yingyong/yanse-rgb-16/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d0e52a6db0d740945c646b723a9c2ce/" rel="bookmark">
			UE DS服务器Attach后添加断点不能命中问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑器模式下，单独的DS服务器窗口，Visual studio 附加到进程后，断点不能正常进入。
DS服务器Attach后添加断点不能命中问题处理
如下设置后， 重启电脑即可；
记录一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465e10178d565868bf4102d01202cd3f/" rel="bookmark">
			Flutter 滚动组件ListView,GridView,Sliver以及滚动监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 身是菩提树 心是明镜台 时时勤拂拭 模式染尘埃 这玩意不难，就是东西多。。。
1 看一下继承关系 class GridView extends BoxScrollView
abstract class BoxScrollView extends ScrollView
abstract class ScrollView extends StatelessWidget
2 下面是scroll_view.dart 中的代码 这个注释就是很清楚了 ，子类就是要重写buildSlivers这个方法，这是个抽象的方法。
/// Build the list of widgets to place inside the viewport. /// /// Subclasses should override this method to build the slivers for the inside /// of the viewport. @protected List&lt;Widget&gt; buildSlivers(BuildContext context); 这是BoxScrollView 中 buildSlivers 的实现方法
@override List&lt;Widget&gt; buildSlivers(BuildContext context) { Widget sliver = buildChildLayout(context); EdgeInsetsGeometry?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/465e10178d565868bf4102d01202cd3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484cd617314f33e49672d33dce7e8307/" rel="bookmark">
			Vue3&#43;Springboot图片下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端图片下载接口
@ApiOperation(value = "下载图片") @GetMapping("download/{pictureId}") public void download(@PathVariable("pictureId") @NotNull(message="参数错误") Long id, HttpServletResponse response) { PicturePo picturePo = pictureService.getById(id); if(Objects.isNull(picturePo)) BusinessException.throwException(ResultVo.notFound()); Path path = FolderInitRunner.FOLDER_PATH.resolve(picturePo.getPath()); if (!Files.exists(path)) { log.warn("图片丢失：{}", picturePo.toString()); BusinessException.throwException(ResultVo.notFound()); } try (OutputStream os = response.getOutputStream()) { response.setHeader("Content-Disposition", "attachment;filename=" +URLEncoder.encode(picturePo.getTitle() + "." + picturePo.getType(), "UTF-8")); response.setContentType("application/octet-stream"); Files.copy(path, os); } catch (Exception e) { log.error("图片传输异常：{}",picturePo.toString()); BusinessException.throwException(ResultVo.error()); } } 前端代码
在&lt;template&gt;代码块中加入以下代码
&lt;a :href="link" download="" id="a-download"&gt; &lt;img :src="link" alt=""/&gt; &lt;/a&gt; 在&lt;style&gt;标签中加入以下代码
#a-download{ display: none; } 在&lt;script&gt;标签中加入以下代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/484cd617314f33e49672d33dce7e8307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81823817c88e285a7f24e263cf4c85cc/" rel="bookmark">
			【Linux】线程互斥详解：多线程会有什么问题？什么是互斥锁？C&#43;&#43;怎么封装使用互斥锁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程可以提高程序的并发性和运行效率，充分利用计算机的多核资源. 前面的几篇文章已经介绍了, Linux线程的基本概念、基本控制等内容.
我们已经看到了多线程可以提升运行效率等. 但是, 也发现了问题, 多线程可能会导致输出混乱、访问共享资源混乱、竞争等问题.
输出混乱只是小问题, 而像访问资源混乱、错误的问题 就比较大了.
线程互斥 在正式分析线程互斥之前. 以线程的角度再介绍三个概念, 这三个概念在介绍共享内存时就已经简单的提过.
临界资源和临界区 临界资源: 不同执行流都可以看到的同一资源, 就叫做临界资源临界区: 访问临界资源的代码, 就叫就临界区原子性: 一个操作, 如果只存在两种状态: 未完成、已完成, 而没有中间状态, 就称这个操作是具有原子性的. 那么, 一下面这段代码为例:
#include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; using std::cout; using std::endl; int tickets = 10000; // 查票 void* inqureTicket(void* args) { const char* name = static_cast&lt;const char*&gt;(args); int cnt = 10; while (cnt--) { if (tickets &gt; 0) { usleep(100000); printf("%s: %lu 查到剩余票了, 还有: %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81823817c88e285a7f24e263cf4c85cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4feb46258d6e5d2a75410e03d280132d/" rel="bookmark">
			python setattr/getattr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对照字典的get/update用于获取/更新键值：
test_dic = {"Lisa": 18, "Tom": 17, "Lus": 16} k1 = test_dic.get("Lisa") print(k1) test_dic.update({"Lisa": 16, "Pite": 19}) print(test_dic) # 18 # {'Lisa': 16, 'Tom': 17, 'Lus': 16, 'Pite': 19} setattr/getattr用于获取/更新对象的属性值
def setattr(x, y, v): # real signature unknown; restored from __doc__ """ Sets the named attribute on the given object to the specified value. setattr(x, 'y', v) is equivalent to ``x.y = v'' """ pass def getattr(object, name, default=None): # known special case of getattr "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4feb46258d6e5d2a75410e03d280132d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f0b6e9e719a247120df10cf7c19857/" rel="bookmark">
			python @property setter/deleter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取/更新对象属性：getattr/setattr，但是没有办法检查检查参数，导致可以任意设置对象属性.
为了解决这个问题，引入property：
Python内置的@property装饰器就是负责把一个方法变成属性调用
用property来获取/更新/删除属性
class property(object): """ Property attribute. fget function to be used for getting an attribute value fset function to be used for setting an attribute value fdel function to be used for del'ing an attribute doc docstring Typical use is to define a managed attribute x: class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f0b6e9e719a247120df10cf7c19857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cacef195a8e9b2342af05ae33b786660/" rel="bookmark">
			[C#]自制简易计算器窗体应用程序（仿windows自带计算器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 C#学习过程中，遇到一个作业：仿照windows自带计算器编写一个窗体应用程序。经过学习、编写、不断试错和优化，做出了一个满意度较高的成品。
结果展示 程序界面与功能如下：
算法讲解： 要能够实现按钮的输入操作，在这一步，可以将多个按钮的Click函数合并，用一个函数来控制多个不同但功能类似的按钮。
private void Numbtn_Click(object sender, EventArgs e)//数字部分 { Button btn = (Button)sender; if (output)//连等结束后的处理 { left_num = right_num = result = 0; textBox1.Text = ""; flag = ' '; output = false; } if (btn.Text.Equals("0")) { if (start || textBox2.Text == "0")//计算结束后重新输入，输入框清零 { textBox2.Text = ""; textBox2.Text += "0"; put0 = false; } if (put0)//只有允许输出0时才能输出0 { textBox2.Text += "0"; } } else { if (start || textBox2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cacef195a8e9b2342af05ae33b786660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58663a5e256182f2372b77d0424b2a44/" rel="bookmark">
			python3.9.6 windows安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载安装 python官网打不开，从如下网址下载：
CNPM Binaries Mirror
python-3.9.6-amd64.exe
测试： python --version
Python 3.9.6
pip --version # Python2.x 版本命令
pip3 --version # Python3.x 版本命令
pip改为国内镜像源 1.C:\Users\Administrator\pip下新建文件pip.ini，内容如下
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = pypi.tuna.tsinghua.edu.cn 2.查看
d:\now&gt;pip3 config list global.index-url='https://pypi.tuna.tsinghua.edu.cn/simple' install.trusted-host='pypi.tuna.tsinghua.edu.cn' d:\now&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ed8e71540e1253541e406b3d7a3676/" rel="bookmark">
			firewalld高级配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、IP地址伪装 masquerade：伪装
通过地址伪装，NAT设备将经过设备的包转发到指定接收方，同时将通过的数据包的原地址更改为NAT的接口地址转发到不同步目的地。当是返回数据包是，会将目的地之修改为原始主机地址并路由。
2、端口转发
也叫端口映射。通过端口转发，将指定IP地址及端口的流量转发到相同计算机上不同端口，或不同计算机上的端口。
firewall-cmd高级配置 firewalld（Dynamic Firewall Manager of Linux systems，Linux 系统的动态防火墙管理器）服务是默认的防火墙配置管理工具
它拥有基于 CLI（命令行界面）和基于 GUI（图形用户界面）的两种管理方式。
相较于传统的防火墙管理配置工具，firewalld 支持动态更新技术并加入了区域的概念。简单来说，区域就是 firewalld 预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。
firewalld 中常见的区域名称（默认为 public）以及相应的策略规则如表 所示。public是默认的。
直接规则 就是将指定网段或某一具体ip加入到同一区域，从而达到批量化限制用户行为！
1）直接只用iptables或firewalld语句规则写入管理区域
2）执行优先级最高。优先级：直接规则→富规则→区域规则
3）不会iptables语句的用户不建议直接使用直连接口
4）适用于服务或应用程序
firewalld中的直接规则设置的是一种流程性的规则选项，描述在过程中要做那些事。配置难度相对较高，不建议初学者设置。
语句：
firewall-cmd --direct 例1：启用黑名单 firewall-cmd --direct --permanent --add-chain ipv4 raw blacklist --direct：直接规则 --permanent：将规则写入防火墙配置文件，永久执行【需要使用firewalll-cmd --reload加载配置文件才能生效。如果不使用此选项，所有新添加的规则都是临时使用~】 --add-chain：添加一个新区域 ipv4 raw blacklist：以ipv4地址格式构建区域，读取raw表进行追踪，区域名称为blocklist（黑名单） 例2：将1.0.0.0网段加入到黑名单 firewall-cmd --direct --add-rule ipv4 raw PREROUTING 0 -s 1.0.0.0 -j blacklist 解释：添加直连规则，临时生效（永久生效），添加规则，目标地址转换之前的数据包中：源地址为1.0.0.0网段加入blocklist区域。 例3：设置访问日志记录 firewall-cmd --direct --permanent --add-rule ipv4 raw blacklist 0 -m limit --limit 1/min -j LOG --log-prefix "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ed8e71540e1253541e406b3d7a3676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83aa1979e916c64cbc6d063e595aac46/" rel="bookmark">
			cesium 自定义动态标记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 效果 图中效果源代码在下面的封装栏中
效果展示：https://www.bilibili.com/video/BV1db4y167z7 # 基本思路 将DOM元素渲染到cesium容器中，并利用cesium中提供的 viewer.scene.postRender 实时更新坐标位置。思路很简单，接下来我们进行实现。
# 实现方法 首先我们需要生成一个球体做我们标记的容器。
viewer = new Cesium.Viewer('cesiumContainer',{ // terrainProvider: Cesium.createWorldTerrain(), // animation: false, // 控制场景动画的播放速度控件 // baseLayerPicker: true, // 底图切换控件 // baselLayerPicker:false,// 将图层选择的控件关掉，才能添加其他影像数据 // // fullscreenButton: false, // 全屏控件 // geocoder: false, // 地理位置查询定位控件 // homeButton: true, // 默认相机位置控件 // timeline: false, // 时间滚动条控件 // infoBox: false, //是否显示信息框 // sceneModePicker: false, //是否显示3D/2D选择器 // selectionIndicator: false, // 点击点绿色弹出 是否显示选取指示器组件 // sceneMode: Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83aa1979e916c64cbc6d063e595aac46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2a3744078ed52cb41a1a9b3b9efcb4/" rel="bookmark">
			Table Transformer做表格检测和识别实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉方面的三大顶级会议：ICCV,CVPR,ECCV.统称ICE
CVPR 2022文档图像分析与识别相关论文26篇汇集简介
论文： PubTables-1M: Towards comprehensive table extraction from unstructured documents是发表于CVPR上的一篇论文
作者发布了两个模型，表格检测和表格结构识别。
论文讲解可以参考【论文阅读】PubTables- 1M: Towards comprehensive table extraction from unstructured documents
hugging face Table Transformer 使用文档
hugging face Table DETR 使用文档
检测表格 from huggingface_hub import hf_hub_download from transformers import AutoImageProcessor, TableTransformerForObjectDetection import torch from PIL import Image file_path = hf_hub_download(repo_id="nielsr/example-pdf", repo_type="dataset", filename="example_pdf.png") image = Image.open(file_path).convert("RGB") image_processor = AutoImageProcessor.from_pretrained("microsoft/table-transformer-detection") model = TableTransformerForObjectDetection.from_pretrained("microsoft/table-transformer-detection") inputs = image_processor(images=image, return_tensors="pt") outputs = model(**inputs) # convert outputs (bounding boxes and class logits) to COCO API target_sizes = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d2a3744078ed52cb41a1a9b3b9efcb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc91130b66415001d994f9b0c772d341/" rel="bookmark">
			mac系统下使用clion调试redis源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取源代码
有两种方式，第一种是从官网下载 Redis 源码压缩包，如图 1-1 所示。
图1-1
将压缩包解压得到一个文件夹。
第二种方式，通过 git clone 获取源码。
从 Github 上，使用 git clone https://github.com/redis/redis.git指令下载，下载完成后你会得到如下文件。
图 1-2
进入 redis 目录，使用 git checkout 切换到 7.0.5 这个 tag 。
复制
gir checkout tags/7.0.5 -b 7.0.5 1. 编译 Redis
在编译之前，需要安装一些环境依赖，Redis 是 C 语言编写的，所以还需要 gcc 编译器。
执行 gcc -v判断是否安装了编译器。
图 1-3
没有安装的话，使用如下指令安装。
复制
xcode-select --install 1. 一切准备就绪，进入 redis 的源码目录，执行 make命令就可以了，你可以类比成 Java 中的 mvn 命令。
复制
make CFLAGS="-g -O0" MALLOC=jemalloc 1. 命令后边的 “-O0” 参数表示告诉编译器不要优化代码，防止你在 Debug 的时候， IDE 里面的 Redis 源码与实际运行的代码对应不上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc91130b66415001d994f9b0c772d341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4694db939a374f6e2d47ecbcff8ace01/" rel="bookmark">
			shell脚本基础之详解脚本数据的输入与输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据的展示 理解输入与输出标准文件描述符STDIN（标准输入）STDOUT（标准输出）STDERR（标准错误） 重定向错误只重定向错误重定向错误和数据 在shell脚本中重定向输出临时重定向永久重定向 在shell脚本中重定向输入创建自己的重定向创建输出文件描述符重定向文件描述符创建输入文件描述符创建读写文件描述符关闭文件描述符 列出打开的文件描述符阻止命令输出创建临时文件创建本地临时文件在/tmp 目录创建临时文件创建临时目录 记录消息 截至到现在，我们所写的shell脚本都是通过将数据打印在屏幕上或将数据重定向到文件中来显示信息的，下面我们会学习如何将脚本的输出重定向到Linux系统的其它位置，并深入了解重定向 理解输入与输出 目前我们已经学习到两种显示脚本输出的方法： 在显示器屏幕上显示输出将输出重定向到文件，查看文件 上述两种方法，要么是将数据全部显示到屏幕上，要么是什么都不显示。如果可以将一部分数据展示到显示器上，一部分保存到文件中，这个方法看起来是个更优解，对此我们需要了解Linux如何处理输入输出，才能够帮助我们将脚本输出放到正确位置 标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符（0、1、2），如下表： 文件描述符英文缩写描述0STDIN标准输入1STDOUT标准输出2STDERR标准错误 这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置，如下介绍： STDIN（标准输入） STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符，它会读取文件并提取数据，就好像是从键盘上键入的许多bash命令能接受STDIN的输入，尤其是没有在命令行上指定文件的话。如下是使用cat命令处理STDIN输入的数据的例子：
当在命令行上只输入cat命令时，它会从STDIN接受输入（键盘）。键盘输入一行，cat命令就会显示出一行，但我们也可以通过STDIN重定向符号强制cat命令接受来自另一个STDIN文件的输入，如下：
如上cat命令会用cat_txt文件中的行作为输入。我们还可以使用这种技术将数据输入到任何能从STDIN接受数据的shell命令中 STDOUT（标准输出） STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器
默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，如下，我们可以用输出重定向来改变标准输出：
通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。我们也可以将数据追加到某个文件。这可以用&gt;&gt;符号来完成，如下：
who命令生成的输出会被追加到ls_txt文件中已有数据的后面，但是如果你对脚本使用了标准输出重定向，你还可能遇到一个特殊的问题，如下：
当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示new_ls文件的内容时并没有任何错误。new_ls文件创建成功了，只是没有内容而已
shell对于错误消息的处理是跟普通输出分开的。如果我们创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些错误信息也是不会出现在日志文件中的，需要换种方法来处理
STDERR（标准错误） shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中但是从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，我们常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候，如下介绍 重定向错误 我们已经学习了如何用重定向符号来重定向STDOUT数据。重定向STDERR数据也没太大差别，只要在使用重定向符号时定义STDERR文件描述符即可。有如下几种办法实现 只重定向错误 STDERR文件描述符被设成2。选择只重定向错误消息时，只需要将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作，如下： ls -l badTXT 2&gt; err.txt 如上，错误消息不会出现在屏幕上了。只需要注意：文件描述符值紧贴在重定向符号前，二者之间没有空白符，该命令生成的任何错误消息都会保存在输出文件中。用这种方法，shell会只重定向错误消息，而非普通数据。这里是另一个将STDOUT和STDERR消息混杂在同一输出中的例子，如下：
ls命令的正常STDOUT输出仍然会发送到默认的STDOUT文件描述符，也就是显示器。由于该命令将文件描述符2的输出（STDERR）重定向到了一个输出文件，shell会将生成的所有错误消息直接发送到指定的重定向文件中 重定向错误和数据 如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件，如下： ls -l err.txt new_ls badTXT 2&gt; err01.txt 1&gt; succ01.txt shell利用1&gt;符号将ls命令的正常输出重定向到了succ01.txt文件，而这些输出本该是进入STDOUT的。所有本该输出到STDERR的错误消息通过2&gt;符号被重定向到了err01.txt文件使用这种方法可以将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松方便地查看错误信息也可以将STDERR和STDOUT的输出重定向到同一个输出文件。为此bash shell提供了特殊的重定向符号&amp;&gt;，如下： ls -l err.txt new_ls badTXT &amp;&gt; normal.txt 当使用&amp;&gt;符时，命令生成的所有输出都会发送到同一文件，包括数据输出和错误。我们注意到其中错误消息出现的位置和预想中的不一样。badTXT文件（列出的最后一个文件）的这条错误消息出现在输出文件中的第一行。这是为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级。这样就可以集中查看错误信息 在shell脚本中重定向输出 可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出： 临时重定向行输出永久重定向脚本中的所有命令 临时重定向 如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加&amp;，如下： echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4694db939a374f6e2d47ecbcff8ace01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2c4d9673c380da0e719bba8db7ccad/" rel="bookmark">
			国内超算中心官网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前国家级超算中心总共有10个，依次是
国家超级计算天津中心
中山大学国家超级计算广州中心
国家超算深圳中心
湖南大学国家超级计算长沙中心
国家超级计算济南中心
国家超级计算无锡中心
国家超级计算郑州中心
国家超级计算昆山中心暂时未找到
国家超算中心成都中心暂时未找到
国家超级计算西安中心
其他超算中心：
北京超级云计算中心
陕西空天超算中心有限公司
上海超级计算中心
乌镇之光超算中心(暂未找到)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05bbfd35986c81cad51cb6844ece280/" rel="bookmark">
			mac如何升级node版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装@vue-cli时被提示node版本低，那好吧，升级一下：
在这里我用的Node.js的多版本管理器n来升级的
1、sudo npm cache clean -f //清除nodejs的cache 2、sudo npm install -g n //使用npm安装n模块 3、npm view node versions // node所有版本 4、sudo n latest // 升级到最新版本 sudo n stable #升级到稳定版本 sudo n xx.xx #升级到具体版本号 在这里我升级到了15版本：sudo n 15.0.0
5、node -v查看一下 果然是v15.0.0，嘻嘻 结束啦。
转至：https://www.jianshu.com/p/acd316dceeb8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105ad34023345acd82f53a71fb616d4a/" rel="bookmark">
			【Kafka】记录一次基于connect-mirror-maker做的Kafka集群迁移完整过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景环境工具选型实操MM1MM2以MM2集群运行以Standalone模式运行 验证附录MM2配置表其他TODO 背景 一个测试环境的kafka集群，Topic有360+，Partition有2000+，部署在虚拟机上，由于多方面原因，要求迁移至k8s容器内（全量迁移），正好可以拿来练一下手。本文主要记录对MM1和MM2的实际操作过程，以及使用过程中遇到的问题及解决方案。
环境 source集群：kafka-2.6.0、2个broker、虚拟机
target集群：kafka-2.6.0、3个broker、k8s
工具：MM1（kafka-mirror-maker.sh）、MM2（connect-mirror-maker.sh）
需求：Topic名称不能改变、数据完整
条件：target集群需要开启自动创建Topic：auto.create.topics.enable=true
工具选型 本质上MM1是Kafka的消费者和生产者结合体，可以有效地将数据从源群集移动到目标群集，但没有提供太多其他功能。
并且在MM1多年的使用过程中发现了以下局限性：
静态的黑名单和白名单Topic信息不能同步，所有Topic同步到目标端都只有一个Partition必须通过手动配置来解决active-active场景下的循环同步问题（MM2为解决这个问题，也做了体验很不好的改动）rebalance导致的性能问题缺乏监控手段无法保证Exactly Once无法提供容灾恢复无法同步Topic列表，只能同步有数据的Topic MM2是基于kafka connect框架开发的。与其它的kafka connecet一样MM2有source connector和sink connetor组成，可以支持同步以下数据：
完整的Topic列表Topic配置ACL信息（如果有）consumer group和offset（kafka2.7.0之后版本才行）其他功能： 支持循环同步检测多集群自定义同步（同一个任务中，可以多集群同步：A-&gt;B、B-&gt;C、B-&gt;D）提供可监控Metrics可通过配置保证Exactly Once… 实操 秉着实操前先演练的原则，我自己搭建了一个和目标集群相同配置的集群，用于验证不同工具的操作结果。有足够把握之后，再对目标集群实际操作。
MM1 执行 --help 查看参数选项：
[root@XXGL-T-TJSYZ-REDIS-03 bin]# ./kafka-mirror-maker.sh --help This tool helps to continuously copy data between two Kafka clusters. Option Description ------ ----------- --abort.on.send.failure &lt;String: Stop Configure the mirror maker to exit on the entire mirror maker when a send a failed send.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/105ad34023345acd82f53a71fb616d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff3a8cc70fb073bc04c78b23bdc682ef/" rel="bookmark">
			WSL使用图形界面（ubuntu）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		换源
首先更换Ubuntu的安装源，使用国内的源更快些，可以用清华源：
https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/
换好源之后，执行以下命令
sudo apt update
sudo apt upgrade
安装xfce4
sudo apt install xfce4
（先前使用过apt install build-essential安装开发必要的工具，不知道是否有影响）
此处安装xfce4图形界面有两个原因：
一是因为该界面安装耗费的空间小，不到1GB，具体的没截图，相比其它图形界面动辄2GB而言……
二是因为用该界面主要是有一个图形界面可以使用spacemacs
安装xrdp
sudo apt install xrdp 配置 xrdp 端口
sudo sed -i ‘s/port=3389/port=3390/g’ /etc/xrdp/xrdp.ini
这里面 3389 是默认配置，这里将其改为 3390 是避免和 windows 的端口冲突。因为两边的端口号是通的，在 wsl 中开一个 8080 端口的 WebServer，在 windows 可以直接访问。
配置 xsession
sudo echo xfce4-session &gt;~/.xsession
这一步其实是在告诉系统，开启桌面环境的时候开启什么桌面环境。
启动 xrdp
sudo service xrdp restart
远程连接
在 win10 开始菜单中搜远程桌面，或按win+r 后输入mstsc
在计算机后面输入 localhost:3390 点击连接，用户名这里用root。首次连接可能需要较长时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff3a8cc70fb073bc04c78b23bdc682ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56010f8318a27ed65b6668c4a60c47e2/" rel="bookmark">
			Java——合并两个排序的链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接 牛客在线oj题——合并两个排序的链表
题目描述 输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。
数据范围： 0≤n≤1000，−1000≤节点值≤1000
要求：空间复杂度 O(1)，时间复杂度 O(n)
如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：
或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：
题目示例 示例1 输入：
{1,3,5},{2,4,6}
返回值：
{1,2,3,4,5,6}
示例2 输入：
{},{}
返回值：
{}
示例3 输入：
{-1,2,4},{1,3,4}
返回值：
{-1,1,2,3,4,4}
解题思路一 构造一个新的head和end指针，第一次比较list1的val和list2的val，如果list1的val小于list2的值，head和end等于list1节点，list1 = list1.next
否则head和end等于list2节点，list2 = list2.next
接下来继续遍历，如果list1的val小于list2的值，end.next = list1，end = end.next, list1 = list1.next
否则head和end等于list2节点，end.next = list2，end = end.next, list2 = list2.next
如果list1或者list2遍历到空了，那么就让end.next = 没空的那个链表
例如：
此时list1.val &lt; list2.val，head 和 end等于list1, list1 = list1.next
继续比较，list2.val &lt; list1.val, 则end.next = list2, end = end.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56010f8318a27ed65b6668c4a60c47e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fb94aec2addb512bfa0792bab5f7fc/" rel="bookmark">
			linux shell命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、shell基本系统维护命令 （一）、man命令 1、使用man命令可以找到特定的联机帮助页，并提供简短的命令说明。一般语法格式为：
man commandname
2、联机帮助页提供了指定命令commandname的相关信息，包括：名称、函数、语法以及可选参数描述等。
无论帮助有多长，都遵循这个格式显示。在页面很多的情况下使用PageUp和PageDown键翻页。最后，使用“：q”退出帮助页面。
3、通常联机帮助信息包括以下几个部分：
(1)NAME：命令的名称
(2）SYNOPSIS：命令的语法格式
(3)DESCRIPTION：命令的一般描述以及用途
(4)OPTIONS：描述命令所有的参数或选项
(5)SEE ALSO：列出联机帮助页中与该命令直接相关或功能相近的其他命令
(6)BUGS：解释命令或其输出中存在的任何已知的问题或缺陷
(7)EXAMPLES：普通的用法示例
(8)AUTHORS：联机帮助页以及命令的作者
4、man 3 printf 查库函数
man 2 open 查系统调用
man -a open 会将系统中与open相关的都列出来
（二）、password命令 1) passwd
a. 出于系统安全考虑，Linux系统中的每一个帐号都必须同时具备用户名和密码。
b. 可以使用passwd命令，为已有账户重新修改用户口令。
c. 需要说明的是，超级用户root可以修改所有其他用户的口令，而普通用户只能修改自己的用户口令，
如果确要修改超级用户或其他用户口令的话，需要具有超级用户的权限。
d. passwd命令的一般语法格式为：
passwd username
2) 单独使用passwd命令，意为修改当前用户自己的口令。下面命令实例用于修改用户自己的口令。
linux@ubuntu:~$ passwd
Changing password for linux #修改当前用户口令
(current) UNIX password: #用户输入旧口令
Enter new UNIX password: #用户输入新口令
Retype new UNIX password: #确认新口令
passwd：已成功更新密码
（三）、su命令 a. su命令用于临时改变用户身份，具有其他用户的权限。普通用户可以使用su命令临时具有超级用户的权限；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fb94aec2addb512bfa0792bab5f7fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8575d8c37da9ecf9b729e17593014c7c/" rel="bookmark">
			Redis 6.0的多线程是如何工作的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来了解下 6.0 版本中新出的多线程特性。
1、多线程处理网络IO，单线程执行命令 Redis 一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF 重写），但是，从网络 IO 处理到实际的读写命令处理，都是由单个线程完成的。
随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 IO 的处理上，也就是说，单个主线程处理网络请求的速度跟不上底层网络硬件的速度。
为了应对这个问题，一般有两种方法。
第一种方法是，用用户态网络协议栈取代内核网络协议栈，让网络请求的处理不用在内核里执行，直接在用户态完成处理就行。
对于高性能的 Redis 来说，避免频繁让内核进行网络请求处理，可以很好地提升请求处理效率。但是，这个方法要求在 Redis 的整体架构中，添加对用户态网络协议栈的支持，需要修改 Redis 源码中和网络相关的部分（例如修改所有的网络收发请求函数），这会带来很多开发工作量。
而且新增代码还可能引入新 Bug，导致系统不稳定。所以，Redis 6.0 中并没有采用这个方法。
第二种方法就是采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。Redis 6.0 就是采用的这种方法。
但是，Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。
Redis 处理请求时，网络处理经常是瓶颈，通过多个 IO 线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥机制了。
这样一来，Redis 线程模型实现就简单了。
2、主线程和IO线程如何写作 我们来看下，在 Redis 6.0 中，主线程和 IO 线程具体是怎么协作完成请求处理的。
为了方便你理解，我们可以把主线程和多 IO 线程的协作分成四个阶段。
阶段一：服务端和客户端建立 Socket 连接，并分配处理线程
首先，主线程负责接收建立连接请求。当有客户端请求和实例建立 Socket 连接时，主线程会创建和客户端的连接，并把 Socket 放入全局等待队列中。紧接着，主线程通过轮询方法把 Socket 连接分配给 IO 线程。
阶段二：IO 线程读取并解析请求
主线程一旦把 Socket 分配给 IO 线程，就会进入阻塞状态，等待 IO 线程完成客户端请求读取和解析。因为有多个 IO 线程在并行处理，所以，这个过程很快就可以完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8575d8c37da9ecf9b729e17593014c7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7127127a3ca8cfb76c5a9d106b8ee086/" rel="bookmark">
			kubeadm证书过期更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[root@k8s01 ~]# openssl x509 -in /etc/kubernetes/pki/ca.crt -noout -text |grep Not
Not Before: Jan 10 09:56:12 2022 GMT
Not After : Jan 8 09:56:12 2032 GMT
[root@k8s01 ~]# openssl x509 -in /etc/kubernetes/pki/apiserver.crt -noout -text |grep Not
Not Before: Jan 10 09:56:12 2022 GMT
Not After : Jan 10 09:56:13 2023 GMT
#ca证书有效期10年，apiserver证书有效期1年
kubeadm 生成的证书有效期为 1 年，该脚本可将 kubeadm 生成的证书有效期更新为 10 年
该脚本只处理 master 节点上的证书，node 节点的 kubelet 证书默认自动轮换更新，无需关心过期问题，只需关心 master 节点上的证书即可
该脚本仅需要在 master 节点执行，无需在 node 节点执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7127127a3ca8cfb76c5a9d106b8ee086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a178b66ece7f32e4afc8d36bc1b7968/" rel="bookmark">
			Redis高可用之哨兵挂了，主从库还能切换吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过部署多个实例，就形成了一个哨兵集群，哨兵集群中的多个实例共同判断，可以降低对主库下线的误判率。
考虑一个问题：如果有哨兵实例在运行时发生了故障，主从库还能正常切换吗？
实际上，一旦多个实例组成了哨兵集群，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作，包括判定主库是不是处于下线状态，选择新主库，以及通知从库和客户端。
支持哨兵集群关键机制，包括：
基于 pub/sub 机制的哨兵集群组成过程基于 INFO 命令的从库列表，这可以帮助哨兵和从库建立连接基于哨兵自身的 pub/sub 功能，这实现了客户端和哨兵之间的事件通知 1、基于 pub/sub 机制的哨兵集群组成 哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。
哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。
除了哨兵实例，我们自己编写的应用程序也可以通过 Redis 进行消息的发布和订阅。所以，为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。
在主从集群中，主库上有一个名为“sentinel:hello”的频道，不同哨兵就是通过它来相互发现，实现互相通信的。
在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到“sentinel:hello”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。
然后，哨兵 2、3 可以和哨兵 1 建立网络连接。通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。
有了 pub/sub 机制，哨兵和哨兵之间、哨兵和从库之间、哨兵和客户端之间就都能建立起连接了，基本可以正常工作了。
2、由哪个哨兵执行主从切换？ 确定由哪个哨兵执行主从切换的过程，和主库“客观下线”的判断过程类似，也是一个“投票仲裁”的过程。
哨兵集群要判定主库“客观下线”，需要有一定数量的实例都认为该主库已经“主观下线”了。
任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a178b66ece7f32e4afc8d36bc1b7968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289cb08b621543cfdac7eef964a5f683/" rel="bookmark">
			S4 HANA 1511的BP角色创建及供应商数据的创建方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文部分 创建BP角色：BAPI_BUPA_CREATE_FROM_DATA
单独添加BP角色：BAPI_BUPA_ROLE_ADD_2
创建供应商数据的方法：
LO_DATA-&gt;CREATE_VENDOR_DATA
VMD_EI_API=&gt;MAINTAIN_BAPI
S4版本一版接着一版更新
所以，不要深究那么多，因为下一个版本又不一样了
从后勤物流角度来看，后勤主要主数据是客户主数据和供应商主数据。我们在S/4HANA中学到的第一件事是客户 - 供应商集成（CVI），也称为业务合作伙伴（BP)。
在传统SAP ERP中，客户和供应商是作为两个不同的功能存在的。而在SAP S/4 HANA中，将两者统一维护为Business partner。所以传统的ERP系统中的事务代码都将被废弃，在SAP S/4 HANA 中统一通过事务代码BP使用角色的方式来实现的。
所以，传统SAP ERP 用户在转换为SAP S/4 HANA时，是需要对客户和供应商的主数据做调整的。
一，什么是业务伙伴(Business Partner)？
正如我们在SAP ECC解决方案中所知道的，客户和供应商主数据分为三个视图。
客户主数据
一般视图 General view
财务视图 Finance view
销售视图 Sales view
供应商主数据
一般视图 General view
财务视图 Finance view
采购视图 Purchasing view
两者都是业务伙伴，例如：房地产行业，谁是他们的业务合作伙伴。
房东是业务伙伴
租户是业务伙伴
经纪人是业务伙伴
贷款人是他们的业务伙伴。
所有这些都可能不需要销售数据，财务数据或采购数据。可能需要不同的数据集。像CRM，SCM，SRM这样的新的维度模块需要所有业务伙伴的更加集成的视图。
所以SAP已经围绕客户和供应商数据创建了一个名为业务伙伴的外壳。首先，我们创建了一个业务伙伴，其中存储了诸如名称，地址等基本数据，如果我们希望将此业务合作伙伴扩展为客户/供应商，则我们将该业务伙伴的角色扩展到客户/供应商或两者。 S/4HANA的业务合作伙伴并不是一个新概念，在S/4HANA之前就已经有了。唯一的区别是S/4HANA是业务合作伙伴是强制性的。这是先决条件。
在ECC中
客户和供应商的主数据创建了使用以下方式：
客户主数据使用事务XD01，VD01，FD01创建
供应商主数据使用事务Xk01，Fk01，Mk01创建
与之交易的业务合作伙伴使用事务“BP”
在S/4HANA中
“BP”仍然保留，但客户XD01，VD01，FD01和创建供应商的Xk01，Fk01，Mk01的事务已过时。当您尝试使用这些事务码创建客户或供应商时，系统将重定向到事务“BP”。
主要的区别是S/4HANA是业务合作伙伴 BP 是强制性的。
二，为客户和供应商创建业务合作伙伴
创建客户或供应商的第一步是创建业务合作伙伴。 创建业务伙伴的交易事务码是 “BP”。 您可以通过三种方式创建业务伙伴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/289cb08b621543cfdac7eef964a5f683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39705d58a867c195988d4665dc51deb7/" rel="bookmark">
			如何在Java中使用同步回调和异步回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 （一）同步回调（1）匿名内部类回调（2）Lambda 回调 （二）异步回调（1）简单的线程回调（2）异步并行回调（3）CompletableFuture 回调 小结完整代码 Java 中的回调操作是一个函数传递给另一个函数并在某个操作完成后执行。回调可以同步或异步执行。在同步回调的情况下，一个函数紧接着另一个执行。在异步回调的情况下，一个函数在不确定的时间段后执行，并且与其他函数没有特定的顺序发生。 （一）同步回调 同步回调函数将始终在执行某些操作后立即执行。这意味着它将与执行该操作的函数同步。
在观察者设计模式中可以找到回调函数的示例。在需要单击按钮以启动某些操作的应用界面中，我们可以将回调函数作为该按钮单击的监听器传递。监听器函数等待按钮被单击，然后执行监听器回调。
（1）匿名内部类回调 每当我们将带有方法实现的接口传递给 Java 中的另一个方法时，我们都在使用回调函数的概念。在下面的代码中，我们将通过 Consumer 功能接口和一个匿名内部类（没有名称的实现）来实现 accept() 方法。
实现 accept() 方法后，我们将执行 performAction 方法中的操作；然后我们将从 Consumer 接口执行 accept() 方法：
import java.util.function.Consumer; /** * 同步场景下匿名内部类的方式实现回调 * * @author zhangyu * @date 2023/4/16 */ public class AnonymousClassCallback { public static void main(String[] args) { performAction(new Consumer&lt;String&gt;() { @Override public void accept(String s) { System.out.println(s); } }); } public static void performAction(Consumer&lt;String&gt; consumer) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39705d58a867c195988d4665dc51deb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa2f278745e4f033c911fcfda31eb91/" rel="bookmark">
			Prometheus&#43;Grafana从0到1搭建jvm监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 1. 准备工作2. 添加配置2.1 添加maven依赖2.2 application.properties增加配置2.3 新增配置类2.4 配置Prometheus2.5 配置Grafana 3. 小结 在上一篇博客《 Prometheus+Mysqld_exporter+Grafana从0到1搭建MySQL的可视化监控》，我们完成了对数据库的可视化监控搭建，今天我们接着实现对 jvm 的监控，废话不多说，下面开整。 1. 准备工作 对于 jvm 的监控，我们不需要数据库数据采集工具 Mysqld_exporter ，因此如果只是搭建对 jvm 的监控，那这个东西是可以去掉。
安装Prometheus安装Grafana使用 IDEA 新建一个 springboot 项目 由于在上一篇博客我已经安装了 Prometheus 和 Grafana ，这里就不再重复安装了，直接跳过。
至于 springboot 项目，我这里也直接使用一个我以前创建的项目《Springboot整合MybatisPlus》，服务能正常启动就行，不需要太复杂。
2. 添加配置 2.1 添加maven依赖 在 springboot 项目的 pom.xml 文件中，添加对普罗米修斯的依赖，将依赖包导入到项目中。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt; &lt;/dependency&gt; 2.2 application.properties增加配置 #搭建jvm监控的配置信息 spring.application.name=spring-boot-mybatis-plus management.endpoints.web.exposure.include=* management.metrics.tags.application=${spring.application.name} 2.3 新增配置类 新增一个配置类 JvmMonitorConfig.java ，如下所示
package com.yuhuofei.config; import io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aa2f278745e4f033c911fcfda31eb91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16fc3d410c13cd8920c45af1a19be39a/" rel="bookmark">
			STM32 gpio外部中断详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是中断？ 打断CPU执行正常的程序，转而处理紧急程序，然后返回原暂停的程序继续运行，就叫中断
中断的作用和意义 中断的意义：高效处理紧急程序，不会一直占用CPU资源
STM32 GPIO外部中断简图 NVIC 什么是 NVIC？NVIC 即嵌套向量中断控制器，全称 Nested vectored interrupt controller。它
是内核的器件。
M3/M4/M7 内核都是支持 256 个中
断，其中包含了 16 个系统中断和 240 个外部中断，并且具有 256 级的可编程中断设置。然而芯
片厂商一般不会把内核的这些资源全部用完，如 STM32F407 的系统中断有 10 个，外部中断有
82 个。
关于 82 个外部中断部分在《STM32F4xx 参考手册_V4（中文版）.pdf》的 10.2 小节有详细
的列表，这里就不列出来了。STM32F407 的中断向量表在 stm32f407xx.h 文件中被定义。
NVIC 寄存器 NVIC 相关的寄存器定义了可以在 core_cm4.h 文件中找到。我们直接通过程序的定义来分
析 NVIC 相关的寄存器，其定义如下：
typedef struct { __IOM uint32_t ISER[8U]; /*!&lt; Offset: 0x000 (R/W) Interrupt Set Enable Register */ uint32_t RESERVED0[24U]; __IOM uint32_t ICER[8U]; /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16fc3d410c13cd8920c45af1a19be39a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c3e1ef29079c5b0e183d8f5dbc13e1/" rel="bookmark">
			Samba文件共享服务器的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Samba服务：
1）SMB（Server Message Block）协议实现文件共享，也称为CIFS（Common Internet File System）
2）是Windows和类Unix系统之间的共享文件的一种协议。NFS是Linux和Linux之间的文件共享。
3）客户端是Windows，支持多节点同时挂载以及并发写入。
4）主要是用于windows和linux下的文件共享，打印共享。
5）实现匿名和本地用户的文件共享。
二、Samba的主要进程:
1）smbd进程：控制发布共享目录与权限、负责文件的权限 TCP 139 445
2）nmbd进程：用于名称解析netbios，UDP 137 138 基于NetBIOS协议获得计算机名称
解析为相应的IP地址，实现信息通讯。
NetBIOS：是Network Basic Input/Output System的简称，一般指用于局域网通信的一套API。
三、Samba环境的准备：
1）从模板机中克隆一台Linux的服务器，叫做SAMBA服务器：
注意是管理，克隆，在其中选完整克隆。
2）更改主机名和IP地址：
hostnamectl set-hostname samba.chang.cn vim /etc/sysconfig/network-scripts/ifcfg-ens33 BOOTPROTO=none IPADDR=192.168.17.107 NETWORK=255.255.255.0 GATEWAY=192.168.17.2 DNS1=114.114.114.114 DNS2=8.8.8.8 ONBOOT=yes # systemctl restart network 扩展：如果是多网卡，建议使用ifdown ens33以及ifup ens33实现重启网络操作。这样操作，对其他业务没有影响。
3）关闭防火墙和SElinux：
systemctl stop firewalld &amp;&amp; systemctl disable firewalld # 临时关闭 setenforce 0 # 永久关闭 vim /etc/selinux/config SELINUX=disabled 4）配置yum源：
yum clean all yum makecache 四、Samba软件的安装：（服务器搭建）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c3e1ef29079c5b0e183d8f5dbc13e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0636991fded972576ab02b2ad041a0ba/" rel="bookmark">
			【1】如何安装和卸载tensorflow-CPU和GPU各版本-简单清晰版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、tensorflow-cpu指定版本的卸载二、tensorflow-gpu指定版本的卸载三、tensorflow-cpu指定版本的安装1、创建虚拟环境2、激活虚拟环境3、安装指定版本的tensorflow 四、tensorflow-gpu指定版本的安装安装CUDA安装cuDNN安装tensorflow_gpu-2.1.0测试tensorflow安装成功可能遇到的问题 总结 前言 学习随笔，权作记录。
一、tensorflow-cpu指定版本的卸载 &gt;&gt; pip uninstall tensorflow==版本号 例如： &gt;&gt; pip uninstall tensorflow==2.1.0 二、tensorflow-gpu指定版本的卸载 &gt;&gt; pip uninstall tensorflow==版本号 例如： &gt;&gt; pip uninstall tensorflow-gpu==2.1.0 三、tensorflow-cpu指定版本的安装 1、创建虚拟环境 打开Anaconda prompt（Anaconda3）
检查当前环境下python的版本
&gt;&gt; python --version 根据python的版本，创建虚拟环境pachong
&gt;&gt; conda create -n pachong python==3.7.4 按“y”，再按回车即可。
输入conda info -e，查看全部的环境，可以看到pachong环境已经创建完成。
&gt;&gt; conda info -e 2、激活虚拟环境 在base环境下输入conda activate pachong，即可进入pachong环境
&gt;&gt; conda activate pachong 3、安装指定版本的tensorflow 讲镜像源切换为清华大学的镜像
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0636991fded972576ab02b2ad041a0ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75eaf6a42bb1c5a33187041b626854b9/" rel="bookmark">
			MyBatisPlus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatisPlus 今日目标
基于MyBatisPlus完成标准Dao的增删改查功能
掌握MyBatisPlus中的分页及条件查询构建
掌握主键ID的生成策略
了解MyBatisPlus的代码生成器
1，MyBatisPlus入门案例与简介 这一节我们来学习下MyBatisPlus的入门案例与简介，这个和其他课程都不太一样，其他的课程都是先介绍概念，然后再写入门案例。而对于MyBatisPlus的学习，我们将顺序做了调整，主要的原因MyBatisPlus主要是对MyBatis的简化，所有我们先体会下它简化在哪，然后再学习它是什么，以及它帮我们都做哪些事。
1.1 入门案例 MybatisPlus(简称MP)是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提供效率。
开发方式
基于MyBatis使用MyBatisPlus基于Spring使用MyBatisPlus基于SpringBoot使用MyBatisPlus SpringBoot刚刚我们学习完成，它能快速构建Spring开发环境用以整合其他技术，使用起来是非常简单，对于MP的学习，我们也基于SpringBoot来构建学习。
步骤1:创建数据库及表 create database if not exists mybatisplus_db character set utf8; use mybatisplus_db; CREATE TABLE user ( id bigint(20) primary key auto_increment, name varchar(32) not null, password varchar(32) not null, age int(3) not null , tel varchar(32) not null ); insert into user values(1,'Tom','tom',3,'18866668888'); insert into user values(2,'Jerry','jerry',4,'16688886666'); insert into user values(3,'Jock','123456',41,'18812345678'); insert into user values(4,'传智播客','itcast',15,'4006184000'); 步骤2:创建SpringBoot工程 步骤3:勾选配置使用技术 说明: 由于MP并未被收录到idea的系统内置配置，无法直接选择加入，需要手动在pom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75eaf6a42bb1c5a33187041b626854b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03fcbe5df88035551b62dd82f0cf7c28/" rel="bookmark">
			Anaconda中如何配置国内镜像源安装外部库（含conda永久配置和pip临时配置方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda中如何配置国内镜像源安装外部库 文章目录 Anaconda中如何配置国内镜像源安装外部库一、conda下添加国内镜像源（window下）（永久添加）1.配置清华镜像源2.配置中科大镜像源3、配置上海交通大学镜像源4、显示添加的镜像源 二、pip配置国内镜像源（window下，临时修改）1、配置pip镜像源 三、删除镜像源，换回默认源 一、conda下添加国内镜像源（window下）（永久添加） 1.配置清华镜像源 直接在anaconda prompt下输入以下代码即可。
代码如下：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ #设置搜索时显示通道地址 conda config --set show_channel_urls yes 2.配置中科大镜像源 代码如下：
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ #设置搜索时显示通道地址 conda config --set show_channel_urls yes 3、配置上海交通大学镜像源 命令如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03fcbe5df88035551b62dd82f0cf7c28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a803bfcec532698a8dbbafd47b028a/" rel="bookmark">
			【PyQt开发手册】QTimer的使用介绍以及简单用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 QTimer是一个定时器，设定定时器可以定时调用函数，如果想要调用定时器来定时调用函数，我们需要先了解一下必要的实例方法
2.使用QTimer的简单流程如下 首先先创建一个QTimer对象–&gt;通过QTimer中的start方法让它开始计时（start方法可以设定定时运行的时间）–&gt;每当计时的时间超过了给定的时间后，就会调用一次timeout.connect(xx)中的xx函数–&gt;使用完后调用stop方法关闭计时器
3.详细流程 这里我们设计这样一个项目，通过点击button来开始计时。我们创建一个编辑定义类，来对用Qtdesigner创建好的UI界面进行编辑
Qtdesigner与底层代码分开实现的模板：pyqt中代码与qtdesigner如何分离编写代码
（1）先建立好一个简单的编辑定义类，继承UI界面
class Edit(Ui_Form, QWidget): # 定义初始化进程 def __init__(self): # 继承 super().__init__() # 往空QWidget中放置UI内容 self.setupUi(self) #初始化各种功能 self.init() # 初始化各种功能 def init(self): pass if __name__ == '__main__': app = QApplication(sys.argv) myshow = Edit() myshow.show() sys.exit(app.exec_()) （2）在init方法中创建Qtimer对象
# 初始化各种功能 def init(self): # 创建一个QTimer对象 self.send_time = QTimer(self) （3）将button事件连接QTimer开始计时事件
# 初始化各种功能 def init(self): # 创建一个QTimer对象 self.send_time = QTimer(self) # QTimer开始计时 self.pushButton_start.clicked.connect(self.beginShowTime) def beginShowTime(self): # 设置QTimer开始计时，且设定时间为1000ms self.send_time.start(1000) （3）设置需要周期性运行的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a803bfcec532698a8dbbafd47b028a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca595e43abc281a96281e2586a54e685/" rel="bookmark">
			【django开发手册】如何使用select_related进行一次连表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💖 作者简介：大家好，我是Zeeland，全栈领域优质创作者。📝 CSDN主页：Zeeland🔥📣 我的博客：Zeeland📚 Github主页: Undertone0809 (Zeeland) (github.com)🎉 支持我：点赞👍+收藏⭐️+留言📝📣 系列专栏：django开发手册🍁💬介绍：The mixture of software dev+Iot+ml+anything🔥 Django系列专栏 【django开发手册】Django 中使用自定义用户模型：一个比自带 User 更强的选择【django开发手册】如何使用select_related进行一次连表查询【django开发手册】drf通过添加自定义字段优化DRF序列化器，轻松实现高速API【django开发手册】解决admin添加外键下拉显示外键的问题【Django Rest Framework优化实践】ResponseResult、异常处理方法详解【DRF】深度分析枚举类型在DRF中的序列化问题及解决方案【django开发手册】关于django admin添加表信息的时候外键无法为空的问题解决方案【django开发手册】django admin如何显示外键对应的字段【django开发手册】DRF外键模型查询没有信息？教你实现序列化返回 前言 Django是一款Python Web框架，致力于充分利用Python的简洁语法和语言特性来提高Web开发的效率。其中一个强大的特性是ORM（Object-Relational Mapping），它使开发者可以使用Python代码而不是SQL查询语言来访问数据库。ORM不仅使得数据库访问变得简单，还使得关系数据模型的操作非常方便。
在这篇博客中，我们将讨论Django ORM 中的关键特性——外键，以及如何使用Django REST Framework（DRF）来实现外键关联查询。同时，我们还将探讨如何优化DRF接口，以适应大量数据的情况。
快速上手 假设我们有三个模型：MeasuringPoint、Project和ElementPoint。MeasuringPoint 拥有两个外键——Project和 ElementPoint。现在我们需要编写一个DRF接口，该接口需要从数据库中获取 MeasuringPoint，并返回两个外键对应的 Project和 ElementPoint 信息。此外，该接口还需要支持查询参数 project_id，以便对查询进行筛选。
对于以上要求，我们编写了以下代码：
class MeasuringPointSerializer(serializers.ModelSerializer): class Meta: model = MeasuringPoint fields = '__all__' depth = 2 # 用于展示外建对应的信息 class MeasuringPointListAPIView(APIView): serializer_class = MeasuringPointSerializer def get(self, request): project_id = request.query_params.get('project_id', None) if project_id: queryset = MeasuringPoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca595e43abc281a96281e2586a54e685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a54b91559a4af488a8857c82e0b796/" rel="bookmark">
			RapidOCR调优尝试教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言常见错例种类个别字丢失调优篇个别字识别错误调优篇情况一：轻量中英文模型识别对个别汉字识别错误情况二：轻量中英文模型对个别英文或数字识别错误 相关链接 引言 由于小伙伴们使用OCR的场景多种多样，单一的参数配置往往不能满足要求，这就涉及到基于现有模型，通过调节参数来达到正确识别的目的。基本的原则是尽量不去动模型内部，降低使用成本。本篇文章就来说说在识别效果不好时，如何去调优。因此博客为一家之言，难免会挂一漏万，希望小伙伴多多指出，共同维护这份教程。✨以下尝试情况，均已经在在线demo中实现，看完之后，可移步那里去尝试。 常见错例种类 本地使用过程中，识别结果：
个别字丢失个别字识别错误 个别字丢失调优篇 查看图像是否shape太小，导致文本检测丢失。
对于长度较长，高度较小的图像，可尝试对该图像高度做上下补充，来减小文字在原始图像中比例，利于文本检测。类似下图这种，左侧一条为原始图像，右侧为上下补边的图像。
padding代码参考：
from typing import Tuple import cv2 import numpy as np def padding_img(img: np.ndarray, padding_value: Tuple[int, int, int, int], padding_color: Tuple = (0, 0, 0)) -&gt; np.ndarray: padded_img = cv2.copyMakeBorder(img, padding_value[0], padding_value[1], padding_value[2], padding_value[3], cv2.BORDER_CONSTANT, value=padding_color) return padded_img img = cv2.imread('xxx.jpg') # padding_value: (top, bottom, left, right) # 对该图像上下各补充10像素的白边 padded_img = padding_img(img, (10, 10, 0, 0), (255, 255, 255)) 将padding之后的图像再次送入RapidOCR中尝试，查看是否仍然出现上述问题。 将该图像上传到在线demo中，查看能否复现问题？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a54b91559a4af488a8857c82e0b796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c98bd4549521bc5b30b51f139e9807/" rel="bookmark">
			离线搭建IDEA项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于离线搭建项目
idea 依赖爆红问题，
1、打包依赖包，到指定目录下，并查找目录下_remote.repositories 文件，全部删除
2、idea中。setting-》Maven-》设置指定依赖路径包
3、清除缓存 File-》Invalidate Caches / Restart
4、进行Maven reload
即可完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e96c8d7c2b73f270064bb86e825cba3/" rel="bookmark">
			Visual Studio Code 配置Shell环境（第1次更新：20230416）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前置 1.1 安装Visual Studio Code（VSCode） 下载地址：https://code.visualstudio.com/Download
安装：略
1.2 安装Git 下载地址：https://git-scm.com/downloads
安装：略
2. 安装插件 2.1 进入应用市场 打开VSCode后，点击左侧的"Extensions"扩展面板，并在搜索栏输入扩展插件的名字。
2.2 安装shellman 简介
智能提示和自动补全
搜索、安装插件
搜索栏输入shellman，点击"install"按钮
​ 安装完毕
查看效果
点击"explorer"资源管理器面板，右键单击红框处，点击"New File"新建文件。
​ 新建"shellmanTest.sh"文件，输入case，显示代码提示。
​ 选中第一个后，效果如下
2.3 安装shellcheck 简介
语法、错误检查
搜索、安装插件
搜索栏输入shellman，点击"install"按钮
安装完毕
查看效果
2.4 安装shell-format 简介
格式化代码
搜索、安装插件
搜索栏输入shell-format，点击"install"按钮
​ 安装完毕
下载shfmt 网址：https://github.com/mvdan/sh/releases
点击“shfmt_v3.6.0_windows_amd64.exe”下载（可能需要科学上网才能下载）
存放文件 将下载的exe文件，存放到任意目录
配置 依次点击"File"——&gt;“Preferences”——&gt;“Settings”
​ 进入Settings，输入"shell-format"，点击"Edit in settings json"
将shfmt.exe的路径配置到shellformat.path中，并保存
“shellformat.path”: “D:/Program Files/shfmt/shfmt_v3.6.0_windows_amd64.exe”（根据自己的存放路径，并注意路径中斜杠方向）
查看效果 在代码的任意地方，单击鼠标右键，选择"Format Document"
效果如图
备注：如果无法下载shfmt，也可使用在线格式化工具
https://tool.lu/shell/ http://web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e96c8d7c2b73f270064bb86e825cba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86588c949d37a76808051ff3bf4d12bd/" rel="bookmark">
			JavaScript操作数组的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#JavaScript操作数组的常用方法
push()：在数组的末尾添加一个或多个元素，并返回新的长度。pop()：移除并返回数组中的最后一个元素。shift()：移除并返回数组中的第一个元素。unshift()：在数组的开头添加一个或多个元素，并返回新的长度。splice()：从数组中添加或删除元素。slice()：返回数组的指定部分，不会改变原数组。concat()：将两个或多个数组合并成一个新数组，不会改变原数组。reverse()：反转数组中的元素，改变原数组。sort()：对数组元素进行排序，改变原数组。indexOf()：返回指定元素在数组中第一次出现的位置，未找到返回 -1。lastIndexOf()：返回指定元素在数组中最后一次出现的位置，未找到返回 -1。join() 把数组中的所有元素转换为一个字符串split() 把一个字符串分割成字符串数组:every()：检测数组中所有元素是否符合指定条件，如果全部符合则返回 true，否则返回 false。some()：检测数组中是否有元素符合指定条件，如果有则返回 true，否则返回 false。forEach()：对数组中的每个元素执行指定操作。map()：对数组中的每个元素执行指定操作，返回一个新数组。filter()：对数组中的每个元素进行测试，并返回一个新数组，该数组包含所有测试通过的元素。reduce()：对数组中的每个元素执行指定操作，返回一个累计值。reduceRight()：对数组中的每个元素从右到左执行指定操作，返回一个累计值。find()：查找符合条件的第一个元素，并返回该元素。findIndex()：返回符合条件的第一个元素在数组中的位置，未找到返回 -1。fill()：使用指定的值填充数组中从起始索引到终止索引内的所有元素。includes()：检测数组是否包含指定元素，如果存在则返回 true，否则返回 false。flat()：将数组展开一层，返回一个新数组。flatMap()：对数组中的每个元素执行指定操作，并展开结果为一维数组。copyWithin()：将数组中指定位置的元素复制到另一个指定位置，返回改变后的数组。 // push()：在数组的末尾添加一个或多个元素，并返回新的长度。 let arr = [1, 2, 3, 4, 5, 6] let a = arr.push(1, 2, 3) console.log(arr, a) //pop()：移除并返回数组中的最后一个元素。 let brr = [1, 2, 3, 4, 5] const b = brr.pop() console.log(brr, b) //shift()：移除并返回数组中的第一个元素。 let crr = [1, 2, 3, 4, 5] const c = crr.shift() console.log(crr, c) //unshift()：在数组的开头添加一个或多个元素，并返回新的长度。 let drr = [1, 2, 3, 4, 5] const d = drr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86588c949d37a76808051ff3bf4d12bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea891280b48ef2cd143722ad970f775/" rel="bookmark">
			while (in.hasNextInt())因无法结束输入,得不到输出结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用ctrl+D结束输入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb4bcbc88783367bbd1baeafae1e8bd/" rel="bookmark">
			网络通信，UDP通信，TCP通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络通信3要素 要素1：IP地址 IP地址操作类: InetAddress package com.heima.test; import java.net.InetAddress; import java.net.UnknownHostException; public class InetAddressDemo { public static void main(String[] args) throws Exception { //获取本机地址对象 InetAddress ip1 = InetAddress.getLocalHost(); //本机局域网ip地址 System.out.println(ip1); //主机名 System.out.println(ip1.getHostName()); //局域网ip地址 System.out.println(ip1.getHostAddress()); //获取域名ip对象 InetAddress ip2 = InetAddress.getByName("www.baidu.com"); System.out.println(ip2.getHostName()); System.out.println(ip2.getHostAddress()); //获取公网ip对象 InetAddress ip3 = InetAddress.getByName("119.63.197.151"); System.out.println(ip3.getHostName()); System.out.println(ip3.getHostAddress()); //判断是否能通：ping 5s之内测试是否可通 System.out.println(ip3.isReachable(5000)); } } 要素2：端口号 要素3：协议 连接和通信数据的规则被称为网络通信协议 UDP通信 基础知识 package com.heima.test.TCP; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //接收端 public class ServerDemo { public static void main(String[] args) throws Exception { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb4bcbc88783367bbd1baeafae1e8bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c63c62a4bbc9291690695cce19aa7781/" rel="bookmark">
			Prometheus&#43;Mysqld_exporter&#43;Grafana从0到1搭建MySQL的可视化监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 1. 准备工作1.1 安装MySQL1.2 安装Prometheus1.3 安装Mysqld_exporter1.4 安装Grafana 2. 更改配置2.1 配置Mysqld_exporter2.2 配置Prometheus2.3 配置Grafana 3. 小 结 1. 准备工作 安装 MySQL 数据库安装 Prometheus安装 Mysqld_exporter安装 Grafana 在正式开始搭建之前，我们需要提前做好上面几个东西的安装，下面简单介绍一下这几个东西。
1.1 安装MySQL MySQL 数据库，这个就不过多赘述了，必须要有的，下载一个适合自己系统的版本，安装即可。
1.2 安装Prometheus Prometheus，中文名叫普罗米修斯，一个开源的系统监控和告警系统，我们用到这个，所以可以到它的官网下载获得。
我这里用的是 Window 系统，所以就下载当前最新的 Window 版本的压缩包，不需要安装，下载后解压就可以了。
1.3 安装Mysqld_exporter 因为我们搭建的是对 MySQL 数据库的监控，所以需要一个数据采集工具去采集数据库的信息，并将这些信息给到 Prometheus ，那这里，我用到的数据采集工具就是 Mysqld_exporter。
同样的，去官网下载下来，完成解压就可以了，需要注意的是，选对适合自己系统的版本。
1.4 安装Grafana Grafana 是一个可视化工具，简单地说就是用来展示数据的，像监控大屏那样，因此它需要配置数据来源。它的数据来源可以由 Prometheus 提供，也可以是其它类似的，如 Zabbix ，我们这里用 Prometheus 。
先到官网将这个东西下载下来，我这里下载需要安装的版本，也有解压的，看自己喜好。
安装完成后，打开浏览器，输入 http://localhost:3000 ，就能打开登录页面，默认的登录用户是 admin ，密码也是 admin ，可以改密码也可以直接跳过，下面就是我登录后的样子。
到这里，我们的准备工作，基本就完成了，后面就是改配置，整合各个组件，实现监控效果，这一小节最后，附上我下载下来的几个东西，供参考。
2. 更改配置 2.1 配置Mysqld_exporter 1、在前面的解压目录 mysqld_exporter-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c63c62a4bbc9291690695cce19aa7781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc37f63681b2c299d9df8f685ea0552/" rel="bookmark">
			jumpserver部署恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		别名：跳板机、堡垒机 （登录你们企业的服务器的）
jumpserver部署恢复 jumpserver官网：JumpServer 文档
用与数据恢复和版本容灾，对企业jumpserver堡垒机做高可用方案
一、前提 企业现用jumpserver有数据备份，即mysql数据库的数据备份，依据该备份文件进行堡垒机的数据恢复
二、流程 1.本机恢复jumpserver数据： 使用jumpserver自带恢复功能即可
##进入安装目录 cd /opt/jumpserver-installer-v2.28.6/ ##查看管理脚本 ./jmsctl.sh -h ##数据备份 ./jmsct.sh backup_db ##数据恢复 ./jmsctl.sh restore_db 备份文件路径 备份
恢复
2.异地恢复jumpserver堡垒机数据 首先记录老版本的认证文件和数据备份信息，然后再操作恢复
1、前提操作 #记录老版本的 SECRET_KEY 和 BOOTSTRAP_TOKEN，否则会无法连接和读取数据。安全认证 cat /opt/jumpserver/config/config.txt | egrep "SECRET_KEY|BOOTSTRAP_TOKEN" 2.搞定数据文件 #备份老版本数据 cd /opt/jumpserver-installer-v2.18.0/ ./jmsctl.sh backup_db #修改备份sql的字符集，最好操作以防导入数据时报错！（jumpserver.sql 为上一步操作备份下来的数据） if grep -q 'COLLATE=utf8_bin' /opt/jumpserver.sql; then cp /opt/jumpserver.sql /opt/jumpserver_bak.sql sed -i 's@ COLLATE=utf8_bin@@g' /opt/jumpserver.sql sed -i 's@ COLLATE utf8_bin@@g' /opt/jumpserver.sql else echo "备份数据库字符集正确"; fi 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc37f63681b2c299d9df8f685ea0552/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/84/">«</a>
	<span class="pagination__item pagination__item--current">85/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/86/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>