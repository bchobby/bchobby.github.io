<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5675db04f6598131820c76a148189580/" rel="bookmark">
			使用reposync在CentOS下搭建YUM源服务器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：要求 1.这个yum源服务器要能够定期自动更新自身源
2.使用CentOS官方标准源version6和version7的两个版本保持更新
3.linux(mini)客户端可以在使用的时候直接使用源，比如直接命令：yum –y install pcre*
二、思路 1.能够定期更新的源，肯定是需要计划任务通过执行命令脚本来实现
2.国内的不错的源
http://mirrors.aliyun.com/ （阿里云）
http://centos.ustc.edu.cn/centos/ （中国科学技术大学，教育网线路 -官方镜像）
在我安装的时候，我特意去查找了一下资料，大部分的这类镜像服务，都关闭了rsync的直接同步功能，为的是节省公用带宽。包括目前的中国科学技术大学，有明确的通知。
所以我最终会使用reposync来实现同步。
3.要让客户端可以直接使用源，只用更改其/etc/yum.repo.d/下repo文件内容就可以了，后面会有讲到。
三、搭建yum源的server端 0. 简介
reposync 命令简单来说就是可以把指定外网源（repo id）的包同步到本地文件中
1. 安装 reposync 命令
[root@V10SP1-1 ~]# yum install -y dnf-plugins-core
2. 常用选项以及参数
选项
含义
-c [file]
指定配置文件运行（默认配置文件是 /etc/yum.conf ）
-q
静谧运行
-v
显示详细操作
-h
获取帮助
-b
尝试使用最佳的软件包版本
-C
只从系统缓存中运行，不更新缓存
-R [min]
最大命令等待时间
-y
所有回答都是 yes
-x [package]
排除哪些包
-n repoid=[]
只下载最新的包，相同的跳过
-p
指定下载路径
--delete
删除已不在仓库中的本地软件包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5675db04f6598131820c76a148189580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf8c7633bd0fd1048b5e5e8b0fa4323/" rel="bookmark">
			软考高项第4版教程-差异点解析来啦（第18章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续高项信息系统项目管理师第4版教程的差异点解析，今天带来第18章的解析。
估计还会有朋友问，上次解析到了第5章，这次怎么直接跳到了第18章呢？中间的章节不解析了吗？
其实上次已经预报过了，这次在开头再解释下，咱们这次解析的重点在“差异点”3个字，我先把差异变化比较大的章节解析完成，再回头看是否有必要把变化不大的16章也依次做个重要考点的解析。
“项目绩效域”文字版 可以看出来，第18章是第4版教程完全新增加的章节和考点，这一章的结构非常整齐一致，每一个绩效域都分成了3部分，分别是“绩效要点” 、“与其他绩效域的相互作用”和“执行效果检查” 。我对知识点的梳理和考点的把控也是按照这3部分，针对每个绩效域展开的。
不过我对先后顺序做了调整，把绩效域的目标和执行效果检查放在一起学习，之后才是绩效要点。
这样调整顺序后，更加符合我们认知和学习的习惯。你想想，我们先学目标，学完目标后紧跟着学习目标如何实现，也就是执行效果检查，最后学习绩效要点。
绩效要点我个人认为是本章的学习重点，而与其他绩效域的相互作用部分，最多会在论文中考到，但是谁也不知道会不会考，所以呢，目前看边书理解下就好了，暂时先不作为考试重点。
好，分析完这一章的学习方法和侧重点之后，咱们逐个快速过一下8个项目绩效域。
1. 第1个绩效域是干系人绩效域
干系人绩效域有4个目标，分别是：与干系人建立高效的工作关系、干系人认同项目目标、支持项目的干系人提高了满意度，并从中收益、反对项目的干系人没有对项目产生负面影响
这些目标如何衡量有没有实现呢？我建议你学习的时候直接跳到后面的“执行效果检查”表格，对照着学习和理解（其他绩效域相同，后面不再赘述）
干系人绩效域和目标对应的指标及检查方法有：干系人参与的连续性、变更的频率、干系人行为/干系人满意度/干系人相关问题和风险
干系人绩效域的绩效要点，第4版教程用了一个闭环图来描述，分别是识别、理解、分析、优先级排序、参与和监督。
2. 第2个绩效域是团队绩效域
团队绩效域有3个目标，分别是：共享责任、建立高绩效团队、所有团队成员都展现出相应的领导力和人际关系技能
与之对应的，团队绩效域有3个指标及检查方法：目标和责任心、信任与协作程度/适应变化的能力/彼此赋能和管理和领导力风格适宜性
干系人绩效域的绩效要点也有3部分，分别是项目团队文化、高绩效项目团队和领导力技能。每个要点都讲了比较多的条目，这么多条目不用刻意去记忆，理解就好。
3. 第3个绩效域是开发方法和生命周期绩效域
团队绩效域有3个目标，分别是：开发方法与项目可交付物相符合、将项目交付与干系人价值紧密关联、项目生命周期由促进交付节奏的项目阶段和产生项目交付物所需的开发方法组成
与之对应的，团队绩效域有3个指标及检查方法：产品质量和变更成本、价值导向型项目阶段、适宜的交付节奏和开发方法
干系人绩效域的绩效要点包含4部分，分别是交付节奏、开发方法的选择、开发方法、协调交付节奏和开发方法。
其中交付节奏分为 一次性交付、多次交付、定期交付和持续交付，多次交付和定期交付的区别是个很小的知识点，看一眼就能掌握；
开发方法分为预测型方法、适应型方法和混合型方法，你需要掌握3种方法的区别和适用场景。
4. 第4个绩效域是规划绩效域
规划绩效域有6个目标，相对比较多，分别是：项目以有条理、协调一致的方式推进、应用系统的方法交付项目成果、对演变情况进行详细说明、规划投入的时间成本是适当的、规划的内容对管理干系人的需求而言是充分的、可以根据新出现的和不断变化的需求进行调整
与之对应的，规划绩效域也有6个指标及检查方法：绩效偏差 ，绩效偏差处于临界值范围内；规划的整体性，没有差距或不一致之处；规划的详尽程度；规划适宜性；规划的充分性；可适应变化
规划绩效域的绩效要点更多，包含8部分，分别是规划的影响因素、项目估算、项目团队组成和结构规划、沟通规划、实物资源规划、采购规划、变更规划、度量指标和一致性
5. 第5个绩效域是项目工作绩效域
项目工作绩效域有7个目标，相对比较多，分别是：高效且有效的项目绩效、适合项目和环境的项目过程、干系人适当的沟通和参与、对实物资源进行了有效管理、对采购进行了有效管理、有效处理了变更、通过持续学习和过程改进提高了团队能力
与之对应的，项目工作绩效域也有7个指标及检查方法：状态报告、过程的适宜性/过程相关性和有效性、沟通有效性、资源利用率、采购过程适宜、变更处理情况、团队绩效
项目工作绩效域的绩效要点更多，包含8部分，分别是项目过程、项目制约因素、专注于工作过程和能力、管理沟通和参与、管理实物资源、处理采购事宜、监督新工作和变更、学习和持续改进
6. 第6个绩效域是交付绩效域
交付绩效域有5个目标，分别是：项目有助于实现业务目标和战略、项目实现了预期成果、在预定时间内实现了项目收益、项目团队对需求有清晰的理解、干系人接受项目可交付物和成果，并对其满意
与之对应的，交付绩效域也有5个指标及检查方法：目标一致性、项目完成度、项目收益、需求稳定性、干系人满意度、质量问题
交付绩效域的绩效要点包含3部分，分别是价值的交付、可交付物和质量
7. 第7个绩效域是度量绩效域
度量绩效域有4个目标，分别是：对项目状况充分理解、数据充分，可支持决策、及时采取行动，确保项目最佳绩效、能够基于预测和评估作出决策，实现目标并产生价值
度量绩效域的指标及检查方法主要是围绕度量结果和工作绩效数据展开
度量绩效域的绩效要点包含6部分，分别是制定有效的度量指标、度量内容及相应指标、展示度量信息和结果、度量陷阱、基于度量进行诊断和持续改进
8. 第8个绩效域是不确定性绩效域
不确定性绩效域有7个目标，分别是：了解项目的运行环境，包括技术、社会、政治、市场和经济环境等；积极识别、分析和应对不确定性；了解项目中多个因素之间的相互依赖关系；能够对威胁和机会进行预测，了解问题的后果；最小化不确定性对项目交付的负面影响；能够利用机会改进项目的绩效和成果；有效利用成本和进度储备，与项目目标保持一致等
与之对应的，不确定性绩效域也有7个指标及检查方法：环境因素、风险应对措施、应对措施适宜性、风险管理机制或系统、项目绩效处于临界值内、利用机会的机制和储备使用
不确定性绩效域的绩效要点包含4部分，分别是风险、模糊性、复杂性、不确定性的应对方法
好，这8个绩效域说完了，不知道你有什么感觉，反正我最大的感觉是，这一章一马平川看到底，和第1-5章形成了强烈的反差。
第1-5章的章节结构比较复杂，如果你想用一句话来介绍，还真不太容易。但是第18章介绍起来就很容易：第18章介绍了8个绩效域，每个绩效域介绍了目标、检查方法和绩效要点。
介绍起来就是这样简单，但是学习起来可能困难在于记忆，而非理解
不知道你是否和我的感受一样？
“项目绩效域”脑图版 除了上面介绍的差异点之外，我还结合我的理解，制作了第18章的重点考点的思维导图
我在思维导图中，不仅把本章重要知识点摘录出来，而且也提供了新版教程的差异点及我的备考建议，这样你可以在复习学习时，对照思维导图进行学习。
由于图片上传时会被自动压缩，如果图片看不清，或者想要全高清的思维导图PDF版，为遵守平台纪律，请勿再私信索要。真想要PDF等资料的话，你也可以试试到其他地方找找我。
找到我是咱们的缘分，找不到我就在这里也挺好，一起加油，谢谢支持和理解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c671a657bb0320107a6beb0135395e0/" rel="bookmark">
			React项目开发代码格式化规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目搭建规范 一. 代码规范 1.1. 集成editorconfig配置 EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。 项目根目录中创建 .editorconfig 文件 复制代码：
# http://editorconfig.org root = true [*] # 表示所有文件适用 charset = utf-8 # 设置文件字符集为 utf-8 indent_style = space # 缩进风格（tab | space） indent_size = 2 # 缩进大小 end_of_line = lf # 控制换行类型(lf | cr | crlf) trim_trailing_whitespace = true # 去除行尾的任意空白字符 insert_final_newline = true # 始终在文件末尾插入一个新行 [*.md] # 表示仅 md 文件适用以下规则 max_line_length = off trim_trailing_whitespace = false VSCode需要安装一个插件：EditorConfig for VS Code
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c671a657bb0320107a6beb0135395e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0bbf44243cef587c6926056d3cf637d/" rel="bookmark">
			【Git】更改本地仓库的URL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更新现有的远程仓库URL，使用以下Git命令
git remote set-url &lt;remote_name&gt; &lt;new_url&gt; &lt;remote_name&gt;是你要更改的远程仓库的名称&lt;new_url&gt;是新的远程仓库URL 可以使用以下命令查看当前存储库中已配置的所有远程仓库的名称 git remote 如果你要将名为origin的远程仓库的URL从https://github.com/olduser/oldrepo.git更改为https://github.com/newuser/newrepo.git，则可以运行以下命令 git remote set-url origin https://github.com/newuser/newrepo.git "origin" 是一个本地 Git 仓库中对远程仓库的默认引用名。换句话说，当您在本地克隆一个 GitHub 仓库时，Git 会自动将远程仓库的默认名称设置为 "origin"
👍点赞，你的认可是我创作的动力 ！
🌟收藏，你的青睐是我努力的方向！
✏️评论，你的意见是我进步的财富！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7895e4a51a5c7798530dde9ff84b7041/" rel="bookmark">
			error: character constant too long for its type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天碰到 C++ 的一个基础问题，让我一时有点懵。网上查询后才意识到哪里出错了，我相信大部分刚开始接触 C/C++ 的人应该都遇到过在 linux 环境下 printf 输出一个字符串的时候编译失败，给出一个error：error: character constant too long for its type 这个错误是因为在printf内使用了单引号' '导致的。将其更改为双引号 " " 即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03608b6929ac05a4e6c6fe98e3fdd370/" rel="bookmark">
			github连接超时、提交（push）代码失败解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设置Git的user name和email（默认已安装Git） git config --global user.name "yourname" git config --global user.email "youremail" 2. 生成SSH密钥 查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 生成密钥： ssh-keygen -t rsa -C “458079442@qq.com” 按3个回车，密码为空。 Your identification has been saved in /home/tekkub/.ssh/id_rsa. Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub. The key fingerprint is: ……………… 最后得到了两个文件：id_rsa和id_rsa.pub 添加密钥到ssh：ssh-add 文件名,需要之前输入密码. 3. 登陆github系统 点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了 注意：在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。 4. 接着打开git ，测试连接是否成功 $ ssh -T git@github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03608b6929ac05a4e6c6fe98e3fdd370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed324110eedecab2b3ec3bc41718e19/" rel="bookmark">
			C语言的数组长度能用变量指定吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言的数组长度能用变量指定吗？
C++可以使用变量作为数组长度吗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1203fa8e0eea277d09dcc1cb6ef0200c/" rel="bookmark">
			【20230407】NVIDIA显卡算力、Jetson比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 基本概念 1.1 算力单位 TOPS：指的是每秒钟可以执行的整数运算次数，它代表着计算机在处理图像、音频等任务时的处理能力。TOPS的单位是万亿次每秒（trillion operations per second）。一般是指整数运算能力INT8。
TFLOPS：指的是每秒钟可以执行的浮点运算次数，它代表着计算机在处理科学计算、机器学习等任务时的处理能力。TFLOPS的单位是万亿次每秒（trillion floating point operations per second)。一般是指单精度性能FP32。
MFLOPS：等于每秒一百万次浮点运算。（megaFLOPS）
GFLOPS：等于每秒十亿次浮点运算。(gigaFLOPS)
PFLOPS：等于每秒一千万亿次浮点运算。(petaFLOPS)
1.2 内存带宽 内存带宽是指从计算机主板到内存之间传输数据的速度。它通常用作衡量内存性能的指标之一，以确定计算机可以快速读取和写入内存中的数据量。
内存带宽的大小取决于内存总线的宽度和内存频率的乘积。例如，如果内存总线宽度为64位，内存频率为1600 MHz，则内存带宽为64位 x 1600 MHz = 12.8 GB/s。
内存带宽的大小会直接影响计算机的算力，因为它可以限制计算机能够快速读取和写入数据的数量。如果内存带宽不足，计算机可能需要等待更长的时间才能读取或写入数据，从而降低了计算机的效率。特别是在处理大规模数据集和运行需要大量内存的应用程序时，内存带宽的大小会更加重要。因此，在选择计算机配置时，需要考虑内存带宽和其他关键指标，以确保计算机能够满足特定的计算需求。
1.3 DMIPS DMIPS（Dhrystone Million Instructions Per Second，每秒处理的百万级的机器语言指令数），描述的是 CPU 的运算能力。
自动驾驶多传感器融合的滤波算法，激光点云的配准算法，多数的路径规划和决策算法考验的都是 CPU 的运算能力。
1.4 ASIC ASIC（Application-Specific Integrated Circuit）是指应用特定集成电路，是一种定制的、用于特定应用的集成电路。与通用集成电路（如微处理器）不同，ASIC是针对特定应用进行设计和制造的，可以优化电路的性能和功耗，从而满足特定应用的要求。ASIC通常用于高性能计算、通信、图形处理等领域。
ASIC设计需要经过电路设计、逻辑设计、物理设计、验证等多个步骤，因此制造成本较高，但在高端应用中可以获得很高的性能和可靠性。与FPGA相比，ASIC在性能、功耗和面积等方面都具有优势，但缺乏FPGA的灵活性和可编程性。
ASIC 加速器包括 CVP（Computer Vision Processors，计算机视觉处理器），DLA 和 MA（Multithreaded Accelerator，多线程加速器)，其中 18 颗 CVP 是 Mobileye 的下一代针对传统计算机视觉算法设计的 ASIC 芯片。芯片整体的 AI 算力设计只有 24TOPS。
例如：Jetson中的DLA深度学习加速就是一种ASIC。
2 GeForce 30x系列 3 Jetson 参考1：AI芯片，自动驾驶里的「水浒卡」 参考2：芯参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e51d391011d8b01f28ddcf996b4bb88/" rel="bookmark">
			ubuntu磁盘空间不足解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		df -h后发现/目录下空间很少
点击左下角
搜索disk
点击“disk usage…”
看各个目录下占用的空间，删除空间。
2、在ubuntu 使用Windows的磁盘空间
发现/media/liao/软件/ 下还有空间，则在/media/liao/软件/下，新建文件夹work，在/home/liao下建立work，
建立两者的软连接：
ln -s /media/liao/软件/work work
3、删除/home/用户名/.local/share/Trash/下的一些东西。
删除/home/liao/.config/Code/User/workspaceStorage/ 下的东西
删除.conan ，这是 公司编译产出用的工具。
4、把Windows不用的空间，转到ubuntu里。
Windows压缩空间，ubuntu安装gparted图形工具，确保Windows压缩的空间与ubuntu的空间连续，在gparted里拖拽即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8825e368999653620d8ad9e8a455312/" rel="bookmark">
			最新JavaFx JDK17如何正确的打出可以使用的exe软件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、提前需要准备？二、打包步骤1.现将module-info.java删除 选中module-info.java 鼠标右键 Refactor 然后选择safe deleted2.编辑设置 路径 Run/edit Configurations3.设置Artifacts 快捷键 ctrl+alt+shift+s 也可以通过file /Project Structure4.打jar包5.将jar包打包成exe 前言 最近有一个工作中需要开发一款可视化的行为树的配置工具，因为我呢一直用的java语言，所有就选择了用JavaFx进行桌面程序的开发，但是呢开发后打包却出现各种问题，那么这篇文章就记录一下我们成功打包的经验！供大家参考！
一、提前需要准备？ 1.确保电脑上已经安装好jdk17,以及环境变量也配置好
2.下载javafx SDK 解压后，将路径添加到环境变量中 点击跳转下载页面
3.下载javafx jmods 下载后解压 后面打包的时候需要用到 点击跳转下载页面
4.下载wix311 并安装好，然后配置环境变量
配置好后的环境变量如下【用户变量】Java17的环境变量在系统变量 这个大家应该都会我就不贴图了
二、打包步骤 1.现将module-info.java删除 选中module-info.java 鼠标右键 Refactor 然后选择safe deleted 2.编辑设置 路径 Run/edit Configurations 先将Application下面的配置全部删除，然后点击左上角的+号，选择Application,具体的设置如下 点击Modify options Add VM options 将下面的内容添加
--module-path "C:\Program Files\Java\javafx-sdk-17.0.6\lib" --add-modules javafx.controls,javafx.fxml 选择好程序启动类
3.设置Artifacts 快捷键 ctrl+alt+shift+s 也可以通过file /Project Structure 现将默认的Artifacts 下面的配置 删除点击+号
3.选择好启动类 点击ok
4.然后点击O吐葡萄LayOut 下的+号 选择file 路径选择javafx skd 的bin路径，将bin文件下的所有文件选择中 然后点击OK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8825e368999653620d8ad9e8a455312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d437292e0ea87d1776bd55094e20a222/" rel="bookmark">
			nn.AdaptiveAvgPool1d(1)是用来干嘛的，例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nn.AdaptiveAvgPool1d(1)是PyTorch中的一个函数，用于对输入信号进行一维自适应平均池化操作。对于任何输入大小的输入，可以将输出尺寸指定为1，但是输入和输出特征的数目不会变化。这个函数通常用于将一维信号转换为一个标量值。
例如，如果您有一个长度为10的一维张量，您可以使用nn.AdaptiveAvgPool1d(1)将其转换为一个标量值。这个标量值是这个张量的平均值。
下面是一个使用nn.AdaptiveAvgPool1d(1)的例子：
import torch.nn as nn import torch input = torch.randn(1, 10, 5) pool = nn.AdaptiveAvgPool1d(1) output = pool(input) print(output) 这个例子中，我们首先创建了一个大小为(1, 10, 5)的张量。然后，我们使用nn.AdaptiveAvgPool1d(1)将其转换为一个大小为(1, 10, 1)的张量。最后，我们打印输出结果。
注意：它和nn.Linear一样，如果你输入了一个三维的数据，他只会对最后一维的数据进行处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd0a1946926b957dc6bb2bd8e0ad5af/" rel="bookmark">
			免费的语音质检系统分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能技术近些年的迅速发展为各行业带来了巨大变化，其中之一就是自然语言处理，在这个自然语言处理发展过程中出现了很多专业的公司例如：讯飞、BAT也都有涉及这块业务，包含了声纹识别，说话人识别，年龄，性别，情绪等等，我们今天要介绍的是基于自然语言处理和关键词识别过滤技术打造的智能语音质检系统。
目前苏州磐石云公司的智能语音质检插件2.0，
1、可以通过vos或者呼叫中心系统同服务器安装插件的方式提供语音质检服务，插件安装免费仅需要ASR识别费用。根据预警关键词触发预警，推送到手机
2、通过独立部署针对电话信道进行录音并进行质检。
3、通过API调用提供ASR能力
优势：
1、安装使用软件免费。
2、根据电话信道研发的识别模型准确率更高。
3、ASR识别引擎完全自主研发，在识别费用上有绝对定价权。
4、支持大并发处理，计算资源充足。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6986fc43f3811637053accae3b6ac55/" rel="bookmark">
			语音识别whisper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Whisper是一个通用的语音识别模型，它使用了大量的多语言和多任务的监督数据来训练，能够在英语语音识别上达到接近人类水平的鲁棒性和准确性1。Whisper还可以进行多语言语音识别、语音翻译和语言识别等任务2。Whisper的架构是一个简单的端到端方法，采用了编码器-解码器的Transformer模型，将输入的音频转换为对应的文本序列，并根据特殊的标记来指定不同的任务2。
要使用Whisper模型，您需要安装Python 3.8-3.10和PyTorch 1.10.1或更高版本，以及一些其他的Python包，如HuggingFace Transformers和ffmpeg-python2。您还需要在您的系统上安装ffmpeg命令行工具2。您可以使用pip命令来安装或更新Whisper包，如下所示：
pip install -U openai-whisper
安装完成后，您可以使用edge_tts.Communicate类来创建一个Whisper对象，并调用其transcribe方法来对音频文件进行语音识别3。例如，以下代码可以对一个英语音频文件进行语音识别，并打印出结果：
import edge_tts tts = edge_tts.Communicate() result = tts.transcribe(‘english_audio.wav’) print(result)
如果您想对其他语言的音频文件进行语音识别或翻译，您可以在创建Whisper对象时指定language参数，如下所示：
tts = edge_tts.Communicate(language=‘zh-CN’) # for Chinese speech recognition tts = edge_tts.Communicate(language=‘zh-CN-en’) # for Chinese to English speech translation
更多关于Whisper模型和使用方法的细节，请参考以下链接：
Blog
Paper
Model card
Code
Colab example
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b048c5153af9edd0d8b0abcf7c2ffe3c/" rel="bookmark">
			OSError: We couldn‘t connect to ‘https://huggingface.co‘ to load this file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSError: We couldn't connect to 'https://huggingface.co' to load this file, couldn't find it in the cached files and it looks like THUDM/chatglm-6b is not the path to a directory containing a file named configuration_chatglm.py.
Checkout your internet connection or see how to run the library in offline mode at 'https://huggingface.co/docs/transformers/installation#offline-mode
因为网络的无法连接到 https://huggingface.co 然后提示我们有离线模式
https://huggingface.co/docs/transformers/installation#offline-mode
THUDM/chatglm-6b-int4 at main
在这找到我们需要的文件并一个一个的下载
我们下载了这些文件并放到我们指定的文件里。
然后修改 cli_demo.py 文件就行了。
这样就从我们本地目录读取 ChatGLM-6B-INT4 是 ChatGLM-6B 量化后的模型权重。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fdef4aef2f94b8407420a9d310dcf6/" rel="bookmark">
			【超简便的Python】 提取两个列表的共同元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以直接食用的代码👑 def duplicate_removal(self, A, B): return set(A).intersection(set(B)) Python如何提取两个列表的共同元素？也就是取两个集合的交集。除了常规的循环外，Python提供了一些更简洁更美的表达法，比如可以用列表解析的方法，或者用 Python 内置的集合运算。
比如已有如下两个列表，Python如何提取两个列表的共同元素？
[1, 2, 3, 4, 5] 和 [4, 5, 6, 7, 8] 希望能得到
[4, 5] 方法一，列表解析 🍉 可以用列表解析， List comprehension 下的方法：
A = [1, 2, 3, 4, 5] B = [4, 5, 6, 7, 8] print([x for x in A if x in B]) # [4, 5] 方法二，集合运算 🍉 还可以用Python 的集合（set）运算，s.intersection(t) 返回s与t的交集
A = [1, 2, 3, 4, 5] B = [4, 5, 6, 7, 8] print(set(A).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1fdef4aef2f94b8407420a9d310dcf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add1432346dbc9a68ef3a6b24235594e/" rel="bookmark">
			⭐蓝桥杯高频题单——1.子串分值和（枚举 / 计算贡献 / 前缀数组 / 哈希思想）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐子串分值和⭐ 方法一： 暴力 在做这道题的时候我想到了以前力扣做的一道Leetcode.78. 子集__DFS算法剖析讲解。初始我的想法是通过深搜找到所有可能的子串，再对他们分别计算f(S)，从而得到所有的f(S)之和。但是经过思考发现，这里找子串的过程和找子集的方式是完全不同的，问题就在于子集可以是不连续的几个数字组成，而子串这里一定是连续的。因此可知，这里就不需要麻烦的深搜来帮助完成了，因为找连续序列情况下的枚举是非常简单的，我们只需要对子串的起点和终点进行枚举即可实现对所有可能的序列进行搜寻，因此这里我们通过两个for循环即可解决问题，搭配哈希思想计算每一个序列的f(S)值即可。
Code: #include &lt;iostream&gt; #include &lt;string&gt; #define int long long // #include &lt;bits/stdc++.h&gt; using namespace std; signed main() { string s; cin &gt;&gt; s; int sum = 0; int len = s.size(); for(int i=0;i&lt;len;i++){ for(int j=i;j&lt;len;j++){ int hash[26] = {0}; for(int index=i;index&lt;=j;index++){ hash[s[index] - 'a']++; } for(int temp=0;temp&lt;26;temp++){ if(hash[temp] != 0) sum++; } } } cout &lt;&lt; sum; return 0; } 方法二： 前缀和 + 数学法分析 我们不妨先对题目所给定的ababc序列进行简要的分析，可以看到其子序列及每个子序列对应的f(S)一共为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add1432346dbc9a68ef3a6b24235594e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ebdb822fbf8312d4f7ee2a5d827fc9/" rel="bookmark">
			定位——h5原生/高德/腾讯定位（城市搜索、自动补全、定位按钮和logo修改）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目添加新功能时，使用cdn方式引入使用地图功能，使用功能只用到了地图的定位、点标记、详细地址查询、poi搜索和输入提示、计算两点之间的距离；因为在寻找高德地图问题时发现h5 和 web 端的好少，因此记录一下方便以后查找。
h5的navigator 原生定位 // 在导入js的时候添加插件AMap.Geocoder &lt;script src="https://webapi.amap.com/maps?v=1.4.15&amp;key=你的WEBjs的key&amp;plugin=AMap.Geocoder"&gt;&lt;/script&gt; let geocoder = new AMap.Geocoder({}); // 获取地理编码与逆地理编码类 实例 // 判断是否存在navigator.geolocation if(navigator &amp;&amp; navigator.geolocation) { // 开始定位 navigator.geolocation.getCurrentPosition(function(position) { let latitude = position.coords.latitude;// 获取纬度 let longitude = position.coords.longitude;// 获取经度 // 获取到的是gps 定位 使用高德的经纬度转换 // https://lbs.amap.com/api/webservice/guide/api/convert 这是经纬度转换的地址可以看下有什么参数 $.ajax({ url: 'https://restapi.amap.com/v3/assistant/coordinate/convert?key=必须是web服务的key', type: 'get', data: { locations: longitude+','+latitude, coordsys: "gps", }, success:function(res){ // 根据转换的经纬度 查询当前位置的详细地址 geocoder.getAddress(res.locations.split(','),function(status, result) { // 查询详细地址 alert(result.regeocode.formattedAddress) }); } }) },function(err){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ebdb822fbf8312d4f7ee2a5d827fc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/932d243124eb0c1fab1f2e087d6b8c48/" rel="bookmark">
			git报错，error: You have not concluded your merge (MERGE_HEAD exists). hint: Please,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git报错
error: You have not concluded your merge (MERGE_HEAD exists). hint: Please,
解决办法一：保留本地的更改,中止合并-&gt;重新合并-&gt;重新拉取 （推荐） git merge --abort git reset --merge git pull 解决办法二：舍弃本地代码,远端版本覆盖本地版本(慎重) git fetch --all git reset --hard origin/master git fetch 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8068723434b2a92d687f17f7ef0ff45/" rel="bookmark">
			outputStream（输出流）转inputstream（输入流）以及输入流如何复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 需求：准备： 文件、流之间的转换MultipartFile 转 inputstream（输入流）outputStream（输出流）转为 inputstream（输入流）inputstream （输入流）转 ByteArrayOutputStreamMultipartFile 文件直接转输入流上传和生成摘要MultipartFile 文件需要转为pdf 再进行上传和生成摘要文件上传源码文件hash 摘要算法docx或doc转pdf文件上传 需求： 通过MultipartFile 上传文件到文件服务器，上传前要把文件转为pdf格式进行上传,并生成文件摘要用来验证服务器中的文件是否被篡改。
准备： 需要涉及到 inputstream（输入流）或outputStream（输出流）要使用两次 。
一、如果该文件本身就是pdf格式则直接进行上传。第一次是通过输入流去上传文件；第二次是通过输入流去生成文件摘要。
二、如果该文件不是pdf则需要工具类把文件转为pdf再上传。转pdf的工具类 返回的为outputStream（输出流）。上传的工具类以及生成摘要的工具类则需要inputstream（输入流）。
则需要把输出流进行转化变为输入流，然后再第一次是通过输入流去上传文件；第二次是通过输入流去生成文件摘要
注：流读过一次就不能再读了，而InputStream对象本身不能复制
文件、流之间的转换 MultipartFile 转 inputstream（输入流） byte [] byteArr=file.getBytes(); InputStream inputStream = new ByteArrayInputStream(byteArr); outputStream（输出流）转为 inputstream（输入流） ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); InputStream inputStream2 = new ByteArrayInputStream(outputStream.toByteArray()); inputstream （输入流）转 ByteArrayOutputStream //InputStream 转 ByteArrayOutputStream //获取到一个inputstream后，可能要多次利用它进行read的操作。由于流读过一次就不能再读了，而InputStream对象本身不能复制，而且它也没有实现Cloneable接口 public static ByteArrayOutputStream cloneInputStream(InputStream input) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len = input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8068723434b2a92d687f17f7ef0ff45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1408b99bdc8d0a72875ae70d99b56c2/" rel="bookmark">
			IDEA启动项目发现端口一直被占用，但是没有进程在使用该端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 某一次强制关闭IDEA后，再次打开IDEA，启动项目的时候，显示端口被占用
win+R输入cmd，查看端口是否被占用
但是没有显示端口被占用
电脑重启多次也显示被占用，网上试了好多种方法也没有解决
最后：
以管理员身份打开 终端 输入 netsh winsock reset 重启电脑，就ok了 某一次刚开机启动本地nacos，同样显示端口被占用
最后还是以上面的方式解决：
以管理员身份打开 终端 输入 netsh winsock reset 重启电脑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c57fefa0bb19902c5a36c720b8fb2c5/" rel="bookmark">
			shell脚本格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次写shell脚本报错，记录错误原因。
本地直接用 notepas++ 创建了一个 .cfg 文件。表写好后上传到linux服务器运行，然后报错。
脚本格式 windows系统本地新创建脚本时，需检查文本格式。
需使用Unix（LF），其换行符为’LF’；
若使用了Windows（CR LF）格式，其换行符为’CR LF’（notepad++：视图-&gt;显示符号-&gt;显示行尾符），在Linux系统中读取编译时，会导致错误的换行判断，从而引起执行错误。
notepad++右下角中显示，鼠标右击切换：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e4df3f194b0e66d14b481715e2718d/" rel="bookmark">
			将python项目(django/flask)打包成exe和安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 打包Flask项目写一个简单的Flask项目下载pyinstaller进入到项目路径下，执行运行exe，测试 使用nsis把文件夹打包成windows的安装包下载安装nsis把dist文件夹下的run文件夹压缩成zip使用nsis把压缩包，做成windows安装文件 打包Django项目写一个简单的django项目，准备静态文件使用 pyinstaller打包执行打包成的exe把templates和static文件夹copy到dist/manage文件夹下运行项目注意一些坑 打包其他项目（小工具）准备一个多文件的小工具源码执行打包程序生成.spec配置文件修改.spec配置文件重新打包 .spec脚本参数介绍其他打包工具（cx_Freeze，PyOxidizer，Py2exe，Briefcase）pyinstallercx_FreezePyOxidizerPy2exe Q&amp;A打包过程找不到自己自建模块.spec文件Analysis OptionsBuild OptionsDeployment Options 一个应用有多个文件夹要如何打包成一个exe且不要多余的依赖文件 Python是解释型语言，Flask或Django项目如果部署，源码可能会泄露，因此可以把项目打包成exe，来保护源码。需要用到的工具： pyinstaller：把python项目打包成不同平台的可执行文件nsis：NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序，它提供了安装、卸载、系统设置、文件解压缩等功能。这如其名字所指出的那样，NSIS 是通过它的脚本语言来描述安装程序的行为和逻辑的 打包Flask项目 写一个简单的Flask项目 下载pyinstaller pip install pyinstaller 可选参数示例说明-Fpyinstaller -F demo.py只在dist文件夹中生成一个程序demo.exe文件，适用于一个模块没有多依赖.py文件-Dpyinstaller -D demo.py默认选项，除了主程序demo.exe外，还会在在dist文件夹中生成很多依赖文件，推荐使用这个-cpyinstaller -c demo.py默认选项，只对windows有效，使用控制台-wpyinstaller -w demo.py只对windows有效，不使用控制台-ppyinstaller -p D:\project\demo.py设置导入路径-ipyinstaller -i D:\demo.ico demo.py给生成的demo.exe文件设置一个自定义的图标 进入到项目路径下，执行 # run.py 是flask项目的执行文件，app.run所在py文件 pyinstaller -D run.py # 可以看到项目路径下有 -build文件夹 -dist文件夹：重要，下有run文件夹(py文件名字)，有个run.exe(py文件的名字) -run.spec # 把pro_flask这个文件夹，拷贝到dist下的run文件夹 -因为flask项目有静态文件和html文件，如果不拷贝过去，静态文件和html文件会找不到 -我们为了隐藏代码，可以把所有python的代码都删除，只留static和templates文件夹 运行exe，测试 # 到dist/run文件夹下，双击 run.exe,启动 # 浏览器访问 使用nsis把文件夹打包成windows的安装包 下载安装nsis nsis:NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序，它提供了安装、卸载、系统设置、文件解压缩等功能。这如其名字所指出的那样，NSIS 是通过它的脚本语言来描述安装程序的行为和逻辑的 利用 nsis 把刚刚的dist的run文件夹打包成windows的安装包 把dist文件夹下的run文件夹压缩成zip 使用nsis把压缩包，做成windows安装文件 打包Django项目 写一个简单的django项目，准备静态文件 # 在django项目的配置文件中修改settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e4df3f194b0e66d14b481715e2718d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bbb1a06224bac711c184dbd41577633/" rel="bookmark">
			【已解决】关于visual studio 2022 PerfWatson2.exe进程关闭问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装SQL时候出现了下图情况
在将后台 visual studio关闭后，仍然还有下图情况发生
由于2022版本用的人比较少，所以从网上找到教程并不能关闭该程序，后经过尝试，可通过隐私设置，选择否，点击确定，即可关闭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f1ea50c43dc39bf449fe8248784943/" rel="bookmark">
			notepad&#43;&#43; 运行 C 程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载并安装Mingw, 使用的编译器是Windows环境下的gcc, 支持C11.
配置notepad++环境下用Mingw运行C程序, 设置运行C程序的快捷键, 比如ctrl+shift+c.
运行的命令：
cmd /k gcc -o "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" "$(FULL_CURRENT_PATH)" &amp;&amp; CLS &amp;&amp; "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" &amp; PAUSE &amp; EXIT 字体建议设为Consolas, 方便区分字母o和数字0.
设置一些常用快捷键:
整体缩进: tab
整体取消缩进: shift+tab
块注释: alt+;
取消块注释: alt+’
行注释: alt+,
取消行注释: alt+.
快速添加上一新行: ctrl+shift+enter
快速添加下一新行: ctrl+enter
上移选中的块或当前行: ctrl+shitf+up
下移选中的块或当前行: ctrl+shitf+down
设置为GB2312: Ctrl+G
使用UTF-8编码： Ctrl+U
建议将背景设为白色，在选中部分代码，右键选择Plugin Commands，再选择Copy text with syntax highlighting，即可连着格式和高亮复制到Word中。
格式化代码：插件——NppAStyle——format code
快捷键是Alt+z
只支持部分语言，如C和C++
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89f56bb002da5e398db398857682ba3d/" rel="bookmark">
			网络模块AT指令集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一． 一般命令
1．AT+CGMI 给出模块厂商的标识。
2．AT+CGMM 获得模块标识。这个命令用来得到支持的频带（GSM 900，DCS 1800 或
PCS 1900）。当模块有多频带时，回应可能是不同频带的结合。
3．AT+CGMR 获得改订的软件版本。
4．AT+CGSN 获得GSM 模块的IMEI（国际移动设备标识）序列号。
5．AT+CSCS 选择TE 特征设定。这个命令报告TE 用的是哪个状态设定上的ME。ME
于是可以转换每一个输入的或显示的字母。这个是用来发送.读取或者撰写短信。
6．AT+WPCS 设定电话簿状态。这个特殊的命令报告通过TE 电话簿所用的状态的ME。
ME 于是可以转换每一个输入的或者显示的字符串字母。这个用来读或者写电话簿的入口。
7．AT+CIMI 获得IMSI。这命令用来读取或者识别SIM 卡的IMSI （国际移动签署者标识）。
在读取IMSI 之前应该先输入PIN（如果需要PIN 的话）。
8．AT+CCID 获得SIM 卡的标识。这个命令使模块读取SIM 卡上的EF-CCID 文件。
9．AT+GCAP 获得能力表。（支持的功能）
10．A/ 重复上次命令。只有A/命令不能重复。这命令重复前一个执行的命令。
11．AT+CPOF 关机。这个特殊的命令停止GSM 软件堆栈和硬件层。命令AT+CFUN=0
的功能与+CPOF 相同。
12．AT+CFUN 设定电话机能。这个命令选择移动站点的机能水平。
13．AT+CPAS 返回移动设备的活动状态。
14．AT+CMEE 报告移动设备的错误。这个命令决定允许或不允许用结果码“+CME
ERROR:”或者“+CMSERROR:”代替简单的“ERROR”。
15．AT+CKPD 小键盘控制。仿真ME 小键盘执行命令。
16．AT+CCLK 时钟管理。这个命令用来设置或者获得ME 真实时钟的当前日期和时间。
17．AT+CALA 警报管理。这个命令用来设定在ME 中的警报日期/时间。（闹铃）
18．AT+CRMP 铃声旋律播放。这个命令在模块的蜂鸣器上播放一段旋律。有两种旋律可
用：到来语音.数据或传真呼叫旋律和到来短信声音。
19．AT+CRSL 设定或获得到来的电话铃声的声音级别。
二． 呼叫控制命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89f56bb002da5e398db398857682ba3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dae9d6f3bdb413db9579d71662c5722c/" rel="bookmark">
			Vscode插件SQLTools无法链接mysql： ERROR: Error opening connection connect ECONNREFUSED 127.0.0.1:3306
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我在用下面的VS插件SQLTools链接mysql的时候，遇到了无法链接的问题：
MYSQL版本我用的是8.0，经过下面的配置会报如下错误：
配置信息如下：
报错信息如下：ERROR (ls): Connecting error: {"code":-1,"data":{"driver":"MySQL","driverOptions":{"mysqlOptions":{"authProtocol":"default"}}},"name":"Error"} 解决方法： 先确保下载了mysql:
Linux 安装Mysql 详细教程（图文教程）-CSDN博客
如果确认mysql已经下载完成，那么大概率该问题是因为打开了skip-networking。开启该选项可以彻底关闭 MySQL 的 TCP/IP 连接方式，如果 WEB 服务器是以远程连接的方式访问 MySQL 数据库服务器则不要开启该选项！否则将无法正常连接！ 如果所有的进程都是在同一台服务器连接到本地的 mysqld, 这样设置将是增强安全的方法。
我们可以先进入到mysql中来查看skip-networking是否是ON状态。
show variables like 'skip_networking'; show variables like 'port'; 如果是ON那么这就是为什么vs无法链接的原因，我们需要关闭skip_networking。
我们可以用show variables like 'port';查看端口信息,目前大概率是0。
知道了问题出在哪后我们就可以来修改my.cnf配置文件，由于我使用的是mysql8.0该版本在/etc/目录下是没有自动生成的my.cnf配置文件，该配置文件在/etc/mysql目录下，所以我们需要进入/etc/mysql运行下面语句
sudo vim my.conf 将下面内容复制到你的my.conf文件中
[mysqld] bind-address=0.0.0.0 port=3306 user=mysql basedir=/usr/local/mysql datadir=/data/mysql socket=/tmp/mysql.sock log-error=/data/mysql/mysql.err pid-file=/data/mysql/mysql.pid #character config character_set_server=utf8mb4 symbolic-links=0 explicit_defaults_for_timestamp=true skip_networking=off 这里需要注意请确保你的/etc目录下没有你自己创建的my.conf，否则你要把内容加到该文件中，因为。MySQL读取各个my.cnf配置文件的先后顺序是：
/etc/my.cnf
/etc/mysql/my.cnf
/usr/local/mysql/etc/my.cnf
~/.my.cnf
这时我们再运行如下sql语句：
show variables like 'skip_networking'; show variables like 'port'; 可以看到目前已经设置成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dae9d6f3bdb413db9579d71662c5722c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a400490843b7e994281948bbc4895e72/" rel="bookmark">
			vue3.0 ts 前端利用HTML2canvas与JSpdf插件实现将页面保存为pdf格式下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3.0 ts 前端利用HTML2canvas与JSpdf插件实现将页面保存为pdf格式下载 话不多说 先看效果
安装html2Canvas 与JsPDF npm install --save html2canvas
npm install --save jspdf
html 代码 &lt;a-button @click="weeklyReport(‘周报’)"&gt;周报&lt;/a-button&gt; &lt;div id="capture"&gt; &lt;!-- 页面组件 --&gt; &lt;WeeklyReport&gt;&lt;/WeeklyReport&gt; &lt;/div&gt; js代码 &lt;script lang="ts" setup&gt; import { reactive, ref, createVNode, onMounted } from 'vue' import htmlToPdf from '@/utils/pdf'//引入封装好的ts文件 const weeklyReport = (text:string) =&gt; { console.log('生成周报') htmlToPdf(text, '#capture') } &lt;/script&gt; 这里我封装了一个ts 直接将此ts引入即可 import html2Canvas from 'html2canvas' import JsPDF from 'jspdf' // title:下载文件的名称 htmlId:包裹的标签的id const htmlToPdf = (title: string, htmlId: string) =&gt; { var element = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a400490843b7e994281948bbc4895e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49096abae411125c345f7f1634389dfe/" rel="bookmark">
			三十四、java中的引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存呢空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。
在JDK1.2半之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种强度一次逐渐减弱。
除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。
1.强引用（StrongReFerence）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
2.软引用(SoftReference)：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
3.弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
4.虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个通知。
5.在JAVA程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。
6.当在Java语言中使用new操作创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。
7.强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。
8.对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式的将相应引用赋值为null,就是可以当作垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。
9.相对的，软引用、弱引用和虚引用的对象是软可触及的、弱可触及的和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用时造成Java内存泄漏的主要原因之一。
强引用
/** * 强引用的测试 * * @author * @create */ public class StrongReferenceTest { public static void main(String[] args) { StringBuffer str = new StringBuffer ("Hello"); StringBuffer str1 = str; str = null; System.gc(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(str1); } } 软引用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49096abae411125c345f7f1634389dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c0dd00d875c94ca91d2337c70b81b4/" rel="bookmark">
			UWB高精度定位落地：UWB助力体育领域的应用探索（足球比赛，体能测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、UWB体育运动场景测试 来源：Experimental Evaluation of UWB Indoor Positioning for Sport Postures（比利时根特大学）
UWB室内定位系统在运动员复杂运动过程中跟踪运动员的能力，分析了人体标签放置位置和人体运动模式对定位精度和通信可靠性的影响。 标签放置位置影响
测试方案：标签佩戴人体不同的9个部位，周围有8个固定的锚节点(编号从0到7)，标签位于半径为2m的圆的中心。
由于人体会对电磁波产生吸收和反射的效应，同时每个标签的天线和接收天线的角度差异性，导致不同部位的标签表现不同。采用三个指标进行评估：精度、丢包率和可见锚的数量。
当标签位于用户头上时，所有锚节点上的平均丢包率为1.45%。而当标签放在胸部时，UWB信号被人体阻挡，在某些情况下，超过50%的测距包丢失。
以丢包率小于10%来定义锚节点的可用性，大多数标签位置可以有至少6个锚节点可用，这使得这些标签位置适合用于位置估计。
通过放置在头部的标签来进行来进行精度测试，可以研究所有可见锚节点是否具有同等质量。如果将丢包率与平均测距误差相结合，高丢包率并不一定会导致较低的精度。在标签放置在头部的情况下，锚4在测距过程中的丢包率最高，为4.8%，但在平均测距误差为16.85cm的情况下，它的测距精度并不是最差的。
体育运动的影响
评估当标签贴在身体的不同部位时不同姿态对测距误差的影响。关注四种姿态：站立，深蹲，弯腰，俯卧在地上。
实验收集了标签和所有8个锚节点之间的测距测量值。然后对数据进行处理，并从精度和丢包率的角度分析结果。
标签放置在头部的性能是最优的，该位置的丢包率和平均测距误差都是最小的。因此，针对头部的标签，还进行了加速跑和跳跃两项额外的测试。虽然与静止情况相比，丢包率从8%提升到了17%，但测距误差是相当的，加速情况下的平均误差为14.5cm，跳跃和静止情况下的平均误差分别为14.8cm和13.9cm。
UWB定位算法 使用卡尔曼和粒子滤波融合来自不同传感器（如UWB和IMU）的信息，实现对物体或人的跟踪。卡尔曼滤波不适合于非线性系统，通常采用扩展卡尔曼滤波和无迹卡尔曼滤波对非线性系统进行建模。另一方面，粒子滤波虽然能更好地处理非线性系统，但它需要更多的计算能力。
为了评估粒子和卡尔曼滤波的性能，实现采用一条8字形的路径，同时用UWB标签和动作捕捉系统采集测量数据。
粒子和卡尔曼滤波都能够遵循正确的路径。另外，对于粒子滤波来说，大多数的测量误差在30cm以下，有50%的时间误差小于10cm。另一方面，卡尔曼滤波有50%的时间误差小于17cm。
大场景的测试
为了覆盖整个赛道，需要28个锚节点。自行车运动员在头盔上佩戴移动标签，对运动员的表现几乎没有影响。骑行一圈参考时间约为27s，近似速度为9m/s。
室内跑步
在一条长60米，有三条赛道的直线跑道上进行测试。部署的锚的数量减少到10个，运动员将标签佩戴在侧臂上。根据之前的研究结果，侧壁从丢包率和精度来看是第三好的选择。虽然在跑步过程中，手臂相对于身体重心移动得更明显，但这个位置确保了跑步者的最佳舒适感。
可以看出运动员显然处于第一条赛道（4m&lt;y&lt;5m）。由于标签位于手臂上，估计值略偏向上。即使在这种情况下，算法也可以精确地跟踪跑步者。然而，粒子滤波似乎不太精确，估计值有时比卡尔曼滤波更分散。
结论
UWB被认为是获得厘米级位置估计值最有前途的技术之一。随着价格低廉的UWB芯片的商业化，这项技术得到了更多的普及。UWB是一个很好的体育分析和跟踪市场的候选。
原文信息
Matteo R , Stef V , Jense D , et al. Experimental Evaluation of UWB Indoor Positioning for Sport Postures[J]. Sensors, 2018, 18(2):168. DOI: 10.3390/s18010168
二、UWB产品体育领域实际应用 UWB和足球训练
采用了超宽带无线通信技术（UWB）进行数据传输，将定位精确度精准到厘米级，这一技术利用足球人工智能算法，准确的计算出在训练和比赛中球员的体能负荷、运动表现、技战术配合等等上百项足球数据，将科技带入校园足球 。
通过多维度数据监测，评估球员体能与运动表现，分析团队及战术数据，以此为选拔优秀足球人才提供依据、为教练制定足球训练教案提供参考。
通过先进的精准定位技术、核心精确算法、世界级球队数据分析经验，以可视化图表数据形式呈现足球训练与赛事。
通过技术的创新，提升了足球运动的乐趣性与专业化，让每一个有足球梦想的青少年都能够使用。同时，我们为每一位使用者建立了永久性的数据档案，进而建立整个足球领域的大数据，为中国足球产业带来革命性的变化。
通过先进的科学技术，让足球运动数字化、专业化、科学化、趣味化。建立健全校园足球及各个球员的档案，为科学的训练，客观的评定和选拔人才做数据标准，更全面、科学的数据为教练的临场指挥和比赛总结提供科学依据。
UWB应用于世界杯官方用球
这一技术由一家名为KINEXON的德国物联网公司提供，通过每秒500次自动提供准确的足球相关信息，如足球的初始速度、运行速度、运动角度等，使比赛裁判和官员能够快速查看现场数据，并将有助于通知越位情况，并协助检测有争议的冲撞，从而最终提高VAR决策过程的质量和速度。
作为物联网技术厂商，KINEXON为足球比赛提供了一整套物联网解决方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c0dd00d875c94ca91d2337c70b81b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44eb1840aec9545ebb4ee20d8d84d46d/" rel="bookmark">
			vue3中的全局防抖节流指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用场景，一般业务当中存在查询、新增、编辑等操作类型，使用防抖有效防止疯狂点击增加多条数据问题
// 定义全局自定义指令 app.directive("antiShake", { // 在元素的 attribute 或事件监听器被应用之前调用 created(el, binding,) { let cbFun: NodeJS.Timeout|null = null; el.addEventListener("click", (event:any) =&gt; { event &amp;&amp; event.stopImmediatePropagation(); if (!cbFun) { cbFun = setTimeout(() =&gt; { binding.value() }, 2000); } else { clearTimeout(cbFun); cbFun = setTimeout(() =&gt; { binding.value() }, 2000); } }, true) }, }); //节流函数 app.directive("throttle", { created(el, binding,) { let throtTime = binding.value; if (!throtTime) { throtTime = 2000 } let cbFun: NodeJS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44eb1840aec9545ebb4ee20d8d84d46d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fccdf717ad3ab45da3c642f22000bad/" rel="bookmark">
			uni中使用vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在根目录下创建store文件夹，并创建index.js文件
2.index.js文件和vue中的store的index.js文件一样
import Vue from 'vue'; import Vuex from 'vuex' Vue.use(Vuex) const store = new Vuex.Store({ state: { data:"data" }, getters: { }, mutations: { }, actions: { }, modules: { } }) export default store 3.在main.js文件中引入store,并添加到实例中
import store from "store/index.js" const app = new Vue({ ...App, store }) 4.使用方法和vue一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366d2d40ef614711d4674f19c4b16866/" rel="bookmark">
			pytorch安装失败，torch.cuda.is_available()报错False
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说下配置
笔记本 3060
安装时间，2023年4月5日14:44:25
根据网上教程安装
史上最成功安装Pytorch快速方法【亲测绝对有效，很好用很好用】_曲线的拐点_逆风飞扬fei的博客-CSDN博客
Windows环境下快速安装anaconda和pytorch、cuda、cuDNN_一只不爱晒太阳的猫的博客-CSDN博客
结果安装失败，失败结果直接上图
直接报错，False
研究了半天。
首先输入
pip list 看一下我们的torch和torchvision 版本
然后去官网查看一下版本对应关系，发现python支持3.7.2以上
而我的是 3.7.12版本....... 下面直接尝试安装 3.8的python
自己看上边的教程，安装即可
结果，，，，还是报错，等我再研究研究
参考
torch.cuda.is_available()返回false——解决办法_Nefu_lyh的博客-CSDN博客
RTX3060（30系显卡）Windows10部署Pytorch深度学习环境步骤与心得_30系显卡安装pytorch_普通网友的博客-CSDN博客
主要是参考这俩 最后安装whl困扰了我好半天
如果不行的话
pip3 试试
最后放个成功的截图，头秃。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610c932139fd1f4cbc5cb93dd1ffb05d/" rel="bookmark">
			IDEA工具避坑指南(十)：git拉取java项目后，拉取后的工程目录下只有.git和.idea文件，没有src或java目录|拉取的maven工程不被识别为maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 用以上标题，找不到合适方案，经过多篇帖子的阅读和反复尝试，遂有下文！ 说明：本机IDEA版本是2019，其他版可能略有差异。
二、错误描述 从git上拉取项目后，目录结构如下，缺失想要的src目录
三、期望效果 四、原因分析 原因可能是多方面的，但是首先想到的应该是拉取工程本身就是这个目录结构。
1）当前拉取的分支是默认分支，需要拉取的是其他分支，比如master 此时就需要登录git远程仓库看一下（把git的http地址，复制到浏览器地址栏），
如上图所示验证猜想，该main分支确实什么都没有，通过git自然拉不到所需代码。
2）切换分支，验证猜想 此时，就足以说明刚才拉取的是默认main分支，实际需要的是master分支。
五、解决方案 温馨提示：优先选择方案一！
方案一 如下图所示，点击IDEA右下角“Git:main”图标，依次点击：选择origin/master（自己所需分支）--&gt;Checkout，稍等片刻，关闭IDEA重新打开就可以看到完整的目录了，或者进入项目所在workspace也可以看到完整的目录。
方案二 使用git clone命令操作
1) 在workspace下的工程目录下，打开cmd窗口，执行下面git命令
2) git clone -b 分支名称 git地址
git clone -b master http://56.122.220.7/root/demo-java.git 方案三 1）选择IDEA菜单栏的VCS，依次操作 VCS--&gt;Git--&gt;Pull--&gt;弹出小窗口--&gt;在Branches to merge:选项下，勾选自己要拉取的分支--&gt;点击下面的pull，正常情况稍等片刻就可以了。
不出意外的话，意外还是来了……
2）拉取失败，报refusing to merge错误 错误信息，如下图所示
Git pull failed refusing to merge unrelated histories （拒绝合并不相关的历史）
3）解决方法 打开Terminal窗口，执行如下命令：
git pull origin master --allow-unrelated-histories
反之，如果在push的时候报refusing to merge unrelated histories （拒绝合并不相关的历史）
这个错误时，执行如下命令：
git push origin master --allow-unrelated-histories
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610c932139fd1f4cbc5cb93dd1ffb05d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d493c24372d3f980f86dfd65ac3c6b7/" rel="bookmark">
			Dubbo的基本使用（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Dubbo的基本介绍
1.1、基本概念
1.2、RPC
1.2.1、序列化和反序列化
2、zookeeper（注册中心）
2.1、zookeeper 下载
2.2、zookeper安装使用（window版）
2.3、zookeper安装使用（Linux版）
2.3.1、查看ZooKeeper状态
3、提供者消费者示例
3.1、spring搭建dubbo示例
3.2、Springboot搭建dubbo示例
3.2.1、搭建dubbo-interface 模块
3.2.2、搭建dubbo-provider模块
3.2.3、搭建dubbo-consumer模块
4、zookeeper管理控制台（dubbo-admin）
4.1、dubbo-admin的安装使用
4.1.1、dubbo-admin下载打包
4.1.2、启动前后端
4.2、dubbo-admin的基本使用
参考资料：
​​​​​​​1、Dubbo的基本介绍 Dubbo 是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。 它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 dubbo 的作用简单来说就是给消费端提供接口。
当前dubbo版本: 3.0.4
模块名称模块介绍dubbo-registry-api包含注册中心所有API和抽象实现类dubbo-registry-kubernetes在kubernetes中注册中心的实现dubbo-registry-dns使用dns作注册中心的实现dubbo-registry-multicastmulticast模式的服务的注册和发现dubbo-registry-multiple多注册中心模式下服务的注册和发现dubbo-registry-nacos使用Nacos作为注册中心的实现dubbo-registry-xdsService-mesh模式下服务的注册和发现（Service mesh）dubbo-registry-zookeeper使用ZooKeeper作为注册中心的实现 1.1、基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明：
服务容器负责启动，加载，运行服务提供者。服务提供者在启动时，向注册中心注册自己提供的服务。服务消费者在启动时，向注册中心订阅自己所需的服务。注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 1.2、RPC RPC（Remote Procedure Call）是一种进程间通信方式。简单地说就是能使应用像调用本地方法一样的调用远程的过程或服务，可以应用在分布式服务、分布式计算、远程服务调用等许多场景。业界有很多开源的优秀 RPC 框架，例如 Dubbo、Thrift、gRPC、Hprose 等等。
RPC 与 HTTP、RMI、Web Service 都能完成远程调用，但是实现方式和侧重点各有不同。
RPC是一种协议规范，可以把HTTP看作是一种RPC的实现，也可以把HTTP作为RPC的传输协议来应用。与HTTP相比，RPC的缺点就是相对复杂，学习成本稍高。
1.2.1、序列化和反序列化 什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或对象的过程为什么需要序列化？转换为二进制串才好进行网络传输嘛为什么需要反序列化？将二进制串转换成对象才好进行后续处理嘛 2、zookeeper（注册中心） Zookeeper是一个高性能的，分布式的，开放源码的分布式应用程序协调服务，简称zk。
2.1、zookeeper 下载 下载可在官网下载，如 3.4.11 地址参考：Index of /dist/zookeeper/zookeeper-3.4.11
2.2、zookeper安装使用（window版） ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d493c24372d3f980f86dfd65ac3c6b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709217766c7628d9091b372917732d30/" rel="bookmark">
			[功能点]IDEA导入SQL脚本文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb04da1fe73ec7e8721e59fa8d25cc0/" rel="bookmark">
			UEFI基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UEFI基本概念 UEFI 1. BIOS UEFI和之前的BIOS作用一样，只不过更先进了。一般我们自己装系统都会进BIOS，开机按F12等等，然后设置启动路径为U盘，用U盘装系统，不过现在windows支持在线更新系统了，估计U盘启动以后不需要再学了。
BIOS “Basic Input Output System” “基本输入输出系统”。 BIOS是启动时加载的第一个软件。
是固化到计算机内主板上一个ROM芯片上的程序，比如我们安了内存条，固态，开机自检就是BIOS负责的。
明确记住，BIOS也是一个程序，一个软件，只不过能和硬件直接交互。
2. UEFI 2.1 概念 统一可扩展固件接口（Unified Extensible Firmware Interface，UEFI）是一种电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。主要负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。
一般认为，UEFI由以下几个部分组成：
Pre-EFI初始化模块EFI驱动程序执行环境EFI驱动程序兼容性支持模块（CSM）EFI高层应用GUID磁盘分区表 先大致了解基本概念，这里需要强调的是UEFI只是一种规范，并没有具体的实现！是一种详细描述类型接口的标准。
所以定义了标准，实现就有各种各样的实现了。不同的厂商对UEFI有不同的实现，用的最多就是edk2，高通的ABL侧也是edk2，EDK2是一个遵循UEFI标准和PI标准的跨平台固件开发环境，EDK2支持多种操作系统, 也支持跨平台编译。
edk2 github官网文件夹叫tianocore/edk2。
源代码下bootable/bootloader/edk2 , 然后在此基础上做自己的改动。
2.2 SOC和UEFI SOC和UEFI的关系可以看英特尔官网的这个对比，准确来说应该是SOC和BootLoader的关系：
https://www.intel.cn/content/www/cn/zh/support/programmable/support-resources/design-guidance/soc-bootloader.html
UEFI也属于一种bootloader的规范。fastboot就是一个UEFI应用。
2.3 高通的UEFI 这篇文章也写的不错，高通的uefi分为xbl和abl两部分，abl侧就是edk2，xbl比较麻烦，包括以前老的lk也在xbl里面。
https://www.cnblogs.com/schips/p/qualcomm_about_uefi.html
3. UEFI的编译 有几个错误，
3.1 首先需要编译 编译代码的工具
参考：https://blog.csdn.net/Lq19880521/article/details/82788367
然后又报错找不到文件，看了一下报错的文件夹是空的，应该得单独下载，网上百度了一下，果然是最近版本有问题
3.2 build 有了工具就能使用build了，build前需要先source一下，配置一下路径
编译错误，还是缺少上面那个文件夹，单独clone
JZ是累加器A判零条件转移指令
这汇编指令错误，看错误像是指令不支持，百度了一下，是nasm版本不匹配导致，但是这个报错信息完全没用啊
错误解答：https://edk2.groups.io/g/devel/topic/89637409#87359
百度nasm是什么，
Netwide Assembler （简称 NASM）是一款基于x86架构的汇编与反汇编软件。它可以用来编写16位（8086、80286等）、32位（IA-32）和64位（x86_64）的程序。 NASM被认为是Linux平台上最受欢迎的汇编工具之一。
终端无法更新nasm，只能去网站下载，本地编译安装
https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/
再次build，成功，哦对了，我这里修改了默认的编译平台，如果不修改的话，估计还是报错，需要指定平台和架构，看edk2官网的教程就可以。
3.3 文件后缀的含义 fdf：flash definitionfile，描述flash分区地址范围
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb04da1fe73ec7e8721e59fa8d25cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e11313cbe70f803f0ac356571225aa/" rel="bookmark">
			全景拼接python旗舰版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在这个项目中，您将构建一个管道，将几幅图像拼接成一个全景图。您还将捕获一组您自己的图像来报告最终的结果。
步骤1 特征检测与描述🍉 本项目的第一步是对序列中的每幅图像分别进行特征检测。回想一下我们在这个类中介绍过的一些特征探测器：哈里斯角、Blob探测器、SIFT探测器等。与检测步骤相结合，就进行了特征描述。您的特性必须对某些转换是不变的。想想你将收集数据集的方式。你需要什么样的不变性？探索在OpenCV中可用的特性描述符实现： SIFT、SURF、ORB等
1.使用cv2.imread读取输入的图像。
2.将图像转换为灰度（例如，使用cv2.cvtColor）以进行特征提取。您也可以通过cv2.resize调整图像的大小（例如，在参考约塞米蒂序列中那样的480像素的高度），以使以下步骤运行得更快。
3.选择您的特征检测器。cv2是一个很好的开始。SIFT_create(或cv2.xfeatures2d。SIFT_Creve在旧的OpenCV版本中)。
4.使用检测和计算方法提取关键点和关键点特征。
5.图1使用cv2.drawKeypoints可视化了检测到的关键点：
def flt_show(image, title='sift detects'): plt.figure(figsize=(10,10)) # Canvas 10x magnification plt.title(title,fontsize=20) # title plt.axis('off') # Hidden axis plt.imshow(cv2.cvtColor(image,cv2.COLOR_BGR2RGB)) # print image plt.show() # Display canvas # 1. Read the input images using cv2.imread. def feature_detection_and_description(image_path): image = cv2.imread(image_path) # RGB to Gray image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) # Create detector sift_detecter = sift = cv2.SIFT_create() # Detection picture kp,des = sift.detectAndCompute(image,None) # Keypoints and descriptors # Plot key points img2 = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e11313cbe70f803f0ac356571225aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c334734ecfd7482cace35ba1405a82f3/" rel="bookmark">
			机器人学习-关于经典路径规划（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.内容简介
识别不同类型的路径规划算法理解一组算法的内部工作原理评估算法对特定应用的适用性实现搜索算法 2.路径规划示例
术语
完整性——如果一个算法能够在起点和目标之间找到一条路径，那么这个算法就是完整的。
最优性——如果一个算法能够找到最佳的解决方案，那么它就是最优的。
bug算法
下面的问题演示一个有解决方案，但bug算法无法找到它的例子：
机器人会无休止地穿越在障碍物的外墙周边，但bug算法的一些变体可以弥补这个错误，大部分路径规划算法依赖于本文将介绍的其他原则。在研究新的算法时，我们将在分析算法对任务的适用性时重新考虑完整性和最优性的概念。
3.路径规划方法
路径规划方法
在本文中，将学习三种不同的路径规划方法。第一种称为离散(或组合)路径规划，是三种方法中最直接的。另外两种方法，称为基于样本的路径规划和概率路径规划，建立在离散规划的基础上，以开发更广泛适用的路径规划解决方案。
离散规划
离散规划是将机器人的工作空间显式离散化为一个连通图，并应用graph-search（图搜索）算法来计算最佳路径。这个过程非常精确(实际上，可以通过改变离散空间的精细程度来显式地调整精度)，而且非常彻底，因为它离散了整个工作空间。因此，离散规划的计算成本可能非常高——对于大型路径规划问题来说，这可能令人望而却步。
下图显示了应用于二维工作空间的离散路径规划的一种可能实现。
离散路径规划在其精确性上是优雅的，但最适合于低维问题。对于高维问题，基于样本的路径规划是一种更合适的方法。
基于样本的规划
基于样本的路径规划探测工作空间以增量地构造一个图。与离散工作空间的每个部分不同，基于样本的规划采用许多样本并使用它们来构建工作空间的离散表示。生成的图不如使用离散规划创建的图精确，但由于使用的样本数量相对较少，因此构造起来要快得多。
使用基于样本的规划生成的路径可能不是最佳路径，但在某些应用中——快速生成可行路径比等待数小时甚至数天生成最优路径要好。
下图显示了使用基于样本的规划创建的二维工作空间的图形表示。
概率路径规划
在本模块中学习的最后一种路径规划是概率路径规划。前两种方法一般地考虑路径规划问题——不了解谁或什么可能在执行动作——概率路径规划考虑了机器人运动的不确定性。
虽然这在某些环境中可能不会提供显著的好处，但在高度受限的环境或具有敏感或高风险区域的环境中尤其有用。
下图显示了应用于包含危险的环境(右上方的湖泊)的概率路径规划：
Multi-Lesson地图
在本文中，学习几种离散路径规划算法及基于样本和概率规划，然后应用到路径规划实验中，并使用C++编写搜索算法。
4.连续性表示
为了考虑机器人的几何形状并简化路径规划的任务，工作空间中的障碍物可以膨胀以创建一个称为配置空间(或C空间)的新空间。障碍物的边缘随着机器人的半径大小膨胀，机器人本体可以被视为一个点，使算法更容易搜索路径。C空间是所有机器人姿态的集合，可以分解为C_Free和C_Obs。
5.Minkowski求和
Minkowski求和
Minkowski之和是一种数学性质，可用于计算给定障碍物和机器人几何的配置空间。
Minkowski之和计算方法的直觉可以通过想象用一个形状像机器人的画笔绘制一个障碍物的外部来理解，机器人的原点是画笔的尖端。涂漆面积为C_obs。下图显示了这一点。
为了创建配置空间，对工作空间中的每一个障碍物都用这种方法计算Minkowski之和。下图显示了由三个不同大小的机器人从一个工作空间创建的三个配置空间。如您所见，如果机器人只是一个点，那么工作空间中的障碍物只会膨胀少量来创建C空间。随着机器人体积的增大，障碍物也会膨胀得越来越大。
对于凸多边形，计算卷积是很简单的，可以在线性时间内完成-然而对于非凸多边形(即存在间隙或空洞的多边形)，计算要昂贵得多。
如果有兴趣更详细地了解Minkowski之和，可参见以下资源:
A blog post on Minkowski sums and differences,
An interesting read on how collisions are detected in video games.
小测验:Minkowski求和
如下图所示：
以下哪个图像代表上面所示的机器人(紫色)和障碍物(白色)的配置空间? 答案：B
6.Minkowski求和的C++实现
现在已经学习了Minkowski求和，请尝试在C++中编写代码!
图示如下： 在这个例子中，可以看到两个三角形——一个蓝色的，一个红色的。假设机器人用一个蓝色三角形表示，障碍物用一个红色三角形表示。任务是用C++计算机器人A和障碍物B的配置空间C。
机器人:蓝色三角形，用A表示障碍物:红色三角形，用B表示 下面是在C++中编写Minkowski和的步骤:
Non-shifted(未转换)图例
以上用C++编写了Minkowski求和代码，并生成了配置空间。注意到红色的障碍物并没有充分膨胀，蓝色的机器人仍然可以撞到障碍物。这是因为配置空间仍然需要转移到障碍物上。
首先将机器人转换为障碍物，计算配置空间后，再转化为机器人和障碍物。
转换后图例
上图是转换后最终的图像，其中蓝色的机器人和绿色的配置空间都发生了转化。可以看到黄色填充，它代表转换后的配置空间围绕在红色障碍物周围。蓝色的机器人不会再撞到红色的障碍物，因为它膨胀得很好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c334734ecfd7482cace35ba1405a82f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b7f574b93891d4973553f784cbbb35/" rel="bookmark">
			MATLAB绘制三维点云并且根据给不同点云簇添加不同颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点云格式： 第七列为点云簇序号
程序：
% 读取点云数据 load('pointCloudData.mat'); % 取出点云簇标记列 cluster_labels = pointCloudData(:, 7); % 将点云簇标记列转化为离散的整数值 unique_labels = unique(cluster_labels); label_int = zeros(size(cluster_labels)); for i = 1:length(unique_labels) label_int(cluster_labels == unique_labels(i)) = i; end % 将不同簇的点赋予不同的颜色 colors = lines(length(unique_labels)); % 绘制点云 figure; scatter3(pointCloudData(:, 1), pointCloudData(:, 2), pointCloudData(:, 3), ... 10, colors(label_int, :), 'filled'); axis equal; xlabel('X'); ylabel('Y'); zlabel('Z'); title('3D Point Cloud'); 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f61687949c3e6b6b08a5e2b51ccc3aa/" rel="bookmark">
			NexNoSQL Client：Elasticsearch、Redis、MongoDB三合一的可视化客户端管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 工作中我们使用了Elasticsearch作为存储，来支持内容的搜索，Elasticsearch这个软件大家都耳熟能详，它是一个分布式、高扩展、高实时的搜索与数据分析引擎，不仅仅支持文本索引，还支持聚合操作，使用它既可以做数据搜索，还可以做报表分析，非常的方便。
痛点： 在使用过程中我们也遇到了很多的痛点，主要有以下几个：
1、写入的数据不能立马搜索出来：Elasticsearch有一个刷新间隔，只有刷新之后的数据才能被搜索到，如果要在插入数据之后立马想搜索到，就需要程序进行等待，想想挺尴尬的。当然如果你插入的数据想里面查询出来也是有办法的，那就是通过_id进行查询，只有这一个途径。
2、找不到友好的可视化客户端：原来开发的项目都是基于MySQL和Redis的，它们都有比较优秀的可视化客户端软件进行支持，比如navicat for mysql,Redis Desktop Manager等等，它能降低我们学习和使用的难度，让我们即使对MySQL和Redis了解甚少，也不妨碍我们便捷的使用它们。可对于Elasticsearch来说，好长时间我们并没有发现类似的工具，虽然网上搜索有Elasticsearch-Head，可它仅仅支持简单的查询，不能进行数据更新操作；Kinaba是ES的官方作品，功能非常强大，但需要编写DSL语句，操作复杂，不利于小白直接入手，也不利于工作中的快捷使用。
NexNoSQL Client 最近在网上终于搜到一款Elasticsearch可视化的客户端软件，最最关键的是它是免费的，那就赶快薅起来吧。客户端的下载地址：
https://github.com/NexNoSQL/NexNoSQLClient/releases/download/v1.0.0/NexNoSQL-Client-1.0.0-setup.exe​github.com/NexNoSQL/NexNoSQLClient/releases/download/v1.0.0/NexNoSQL-Client-1.0.0-setup.exe
它集成了Elasticsearch、Redis、MongoDB三种存储的数据管理，如果大家项目中使用了这三种，那么就不需要安装三种软件了，安装它一款即可，我主要是用它的ES功能。
1、连接集群： 软件安装之后，直接点击new按钮，就会跳出新增集群的对话框，选择type=elasticsearch，填入对应的名字、IP和端口号，就可以连接到该节点对应的集群上了，ES集群里面有多个节点，我们只需要填写某一个节点的IP和端口号即可。
2、ES功能：索引、索引模板、索引别名、管理监控、高级操作 连接之后我们就能看到该软件具备的elasticsearch功能
3、索引操作 本次我就讲一讲对索引的操作
3.1、建立索引：
点击索引目录旁边的+，右侧就显示出建索引相关的设置，上部分是索引的基础设置，比如索引的名称、类型，分片数、副本数，返回结果大小。下部分是索引字段的mapping设置，比如字段的名称，字段的类型，是否可以检索，看起来是不是很熟悉的味道，和Navicat中设置MySQL表一样简单，再也不用去写复杂的ES脚本了。另外在右侧的“脚本”TAB还有对应的脚本展示，可以供我们学习之用。比如我们设置一个类型，然后看看脚本是怎生成的。
3.2、插入索引数据
当我们建立索引之后，肯定想做的是往索引里面插入数据，ES里面的数据都是JSON格式的，那么我们怎么插入数据呢？点击索引目录，然后就能看到集群里面所有的索引，然后点击我们刚刚新增的test2索引，就出现了下图的界面：
单击“新增文档”就跳出对应的对话框，然后我们就可以输入JSON格式的内容了:
3.2、查询索引数据
这是这个软件的最大的优点，查询数据特别的简单，可以选择的查询条件非常多：
支持all、id、must、most not、should，另外还支持sort排序操作。
我们选择all查看一下，就能查询出相关的数据，并且还能展示该索引的总数，
3.3、修改和删除索引数据
查询出数据之后，就可以对数据进行修改和删除了，就在上图的右边有操作按钮，是不是特别的方便。
最后： 今天先写到这里，这里仅仅是索引相关的操作，还有其他的内容大家自行探索吧，另外还有Redis和MongoDB的功能，我后续再写几篇文章来跟大家分享使用心得。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d6037dd9b938dc15c3d0b79945aeb43/" rel="bookmark">
			三十三、垃圾回收的并行与并发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.操作系统的并行与并发
1。在操作系统中，是指一个时间段中有几个程序都处于已启动到运行完毕之间，且这几个程序都是在用一个处理器上运行。
2.并发不是正真意义上的”同时进行“，只是CPU把一个时间段划分成几个时间片段（时间区间），然后再这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时再进行。
3.当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行。
4.其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。
5.适合科学计算，后台处理等弱交互场景。
并行vs并发
二者对比：
并发，指的是多个事件，再同一时间段内同时发生了。
并行，指的是多个事情，在同一时间点上同时发生了。
并发的多个任务之间是相互抢占资源的。
并行的多个任务之间是不互相抢占资源的。
只有在多个CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。
2.垃圾回收的并发与并行
1.并行和并发，在谈论垃圾收集器的上下文语境中，它们可以解释如下：
1.并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
2.串行：
1)相较于并行的概念，单线程执行。
2）如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。
3.安全点
程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为”安全点“。
Safe Point 的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部指令的执行时间都非常短暂，通常会根据”是否具有让程序长时间执行的特征“为标准。比如：选择一些执行时间较长的指令作为Safe point,如方法调用、循环跳转和异常跳转等。
如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？
1.抢先式中断：（目前没有虚拟机采用了）
首先中断所有线程。如果还有宪曾不在安全点，就恢复线程，让线程跑到安全点。
2.主动式中断：
设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。
Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断亲求，“走”到安全点去中断挂起，JVM也不太可能线程被唤醒。对于这种情况，就需要安全区域来解决。
安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Regin看作是被扩展了的safepoint。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fefc48bdafb17e4e33e9fdb792f762/" rel="bookmark">
			uview2.0封装网络请求(微信小程序最新登录方式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络请求和相应拦截器
// 此vm参数为页面的实例，可以通过它引用vuex中的变量 module.exports = (vm) =&gt; { // 初始化请求配置 uni.$u.http.setConfig((config) =&gt; { config.baseURL = 'http://127.0.0.1:8080/'; return config }) // 请求拦截 uni.$u.http.interceptors.request.use((config) =&gt; { //根据custom参数中配置的是否需要token，添加对应的请求头 if(config?.custom?.auth) { config.header.token = uni.getStorageSync("token") } return config }, config =&gt; { // 可使用async await 做异步操作 return Promise.reject(config) }) uni.$u.http.interceptors.response.use((response) =&gt; { /* 对响应成功做点什么 可使用async await 做异步操作*/ if (response.data.code !== 200) { // 服务端返回的状态码不等于200，则reject() return Promise.reject(response) }	// return Promise.reject 可使promise状态进入catch if (response.config.custom.verification) { // 演示自定义参数的作用 return response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7fefc48bdafb17e4e33e9fdb792f762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a1b58ed4ed95b9f07c3b8da5f1d2ee/" rel="bookmark">
			Axure rp9一个简单的滑块循环播放/轮播图原型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1678172447766
开始步骤： 1.在空白画布中直接拖入一个动态面板
2.点击这个动态面板，然后新创建几个状态副本
3.切换到每一个面板，然后在空白处放上需要展示的内容
4.设置交互，给这个动态面板先设置一个‘载入’的动作，然后再设置动态面板状态，状态改为下一个，然后勾选‘在最后1个到第1个状态之间循环’。然后设置一下如何展示图片的样式，点击更多选项，勾选循环间隔时间，点击完成，就可以按F5展示看效果了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ff7ba92013cbc2bd881abd2f5ac4a0/" rel="bookmark">
			将图片的小写属性改为大写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.将图片拖到桌面，然后右击，选择属性，进行查看该图片的文件类型
发现文件类型后缀是小写，我需要改成大写
2.右击图片，选择编辑
3.然后选择另存为，将文件名的后缀改成自己需要的大写属性，就完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377df2333f16d532ac518424d14bd58d/" rel="bookmark">
			React中实现富文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React中实现富文本编辑器 前言
在React中实现富文本编辑器，我们可以使用现有的第三方库，如react-quill、draft-js等。这里以react-quill为例进行介绍。
首先需要安装react-quill库：
npm install react-quill --save 然后在需要使用富文本编辑器的组件中引入并使用：
import React, {useState} from "react"; import ReactQuill from "react-quill"; import "react-quill/dist/quill.snow.css"; function RichTextEditor() { const [editorContent, setEditorContent] = useState(""); const handleEditorChange = (content, delta, source, editor) =&gt; { setEditorContent(content); }; return ( &lt;div className="rich-text-editor"&gt; &lt;ReactQuill value={editorContent} onChange={handleEditorChange} modules={{ toolbar: [ [{ header: [1, 2, false] }], ["bold", "italic", "underline", "strike", "blockquote"], [ { list: "ordered" }, { list: "bullet" }, { indent: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377df2333f16d532ac518424d14bd58d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b0a23654bba1c3415778b11993bcd1/" rel="bookmark">
			前端vue 教程（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 1. 什么是Vue Vue是一款渐进式JavaScript框架 Vue是一款渐进式JavaScript框架，可以用于构建用户界面。Vue具有简单易学、轻量级、高效、灵活等特点。Vue采用了MVVM模式，通过数据驱动视图的方式实现了组件化开发。Vue具有丰富的生态系统，如Vue Router、Vuex、Vue CLI等。Vue支持服务端渲染、TypeScript等特性，可以满足不同的开发需求。 Vue可以用于构建用户界面 Vue是一套用于构建用户界面的渐进式框架，它采用MVVM模式，通过数据驱动视图，并且提供了响应式和组件化的思想，使得开发者可以更加轻松地构建交互式的应用程序。
Vue可以用于构建用户界面，它提供了一系列的指令和组件，包括v-bind、v-model、v-if、v-for等等，同时也支持自定义指令和组件。通过这些指令和组件，开发者可以快速地搭建各种类型的用户界面，例如表单、列表、导航等等。
Vue的核心库只关注视图层- Vue的核心库只关注视图层，因此它易于学习和集成到其他项目中。
Vue使用虚拟DOM来优化性能，并提供了响应式和组件化的开发方式。Vue支持模板语法和JSX语法，可以与其他库和框架无缝集成。 2. Vue的特点 渐进式框架数据驱动视图组件化开发轻量级易上手 3. Vue的基础语法 模板语法
插值表达式：{{ }}&lt;div&gt;{{ message }}&lt;/div&gt; v-bind指令：将数据绑定到HTML元素的属性上&lt;img v-bind:src="imageSrc"&gt; v-if指令：根据表达式的值的真假来有条件地渲染元素&lt;div v-if="isShow"&gt;显示的内容&lt;/div&gt; v-for指令：渲染列表&lt;ul&gt; &lt;li v-for="item in items"&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; v-on指令：绑定事件&lt;button v-on:click="handleClick"&gt;点击&lt;/button&gt; 计算属性：computed&lt;div&gt;{{ reversedMessage }}&lt;/div&gt; ... computed: { reversedMessage: function () { return this.message.split('').reverse().join('') } } 监听属性：watchwatch: { message: function (newVal, oldVal) { console.log('message changed from', oldVal, 'to', newVal) } } 生命周期：created、mounted、updated、destroyedcreated: function () { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b0a23654bba1c3415778b11993bcd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f9a237a0b514c9b7fe6ba96256bbae/" rel="bookmark">
			C# 使用反射进行反射程序集下的某个文件夹下的所有类 或者 某程序集下的所有类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是反射？ 反射是指在运行时通过程序对类型、对象等信息进行访问和操作的能力。在C#中，反射可以通过System.Reflection命名空间中的类来实现，比如Type、MethodInfo和PropertyInfo等。通过反射，可以在程序运行时获取类型的信息，创建对象实例、调用方法、设置属性等。反射常用于动态加载程序集、编写通用代码以及实现一些高级功能。
二、本文章例子是在什么情况下形成的？ 本文章是在使用sqlsugar的情况下使用，具体需求是如下：
1、开发人员通过创建“实体类”，实体类中已经定义好数据库中需要使用的字段名称与类型。
2、程序启动时，通过Assembly进行获取某个程序集中的所有类（或者某个程序集中某个文件夹中的所有类）。
3、通过反射，把获取的类进行反射，可变成可使用的类。
三、程序实例： var basicScope = GetScope(UserDataBase.Basics);//获取连接postgeoSql的字段 GetScope(UserDataBase.Basics)一个方法，里面定义了连接postgeosql的方法 var currentAssembly = Assembly.LoadFrom("DBManagement.Common.dll");//DBManagement.Common.dll 这个就是你要获取的程序集，也就是你想要获取的类在哪个程序集下面 var geoEntityTypes = currentAssembly.ExportedTypes.Where(p =&gt; p.FullName.StartsWith("DBManagement.Common.Entities")).ToList(); //这个是指定到某个程序集中的指定文件夹下，更加精准到准确位置 ///进行便利获取的所有的程序集中的类 foreach (var geoEntityType in geoEntityTypes) { var methods = basicScope.CodeFirst.GetType().GetMethods(); //C# GetMethods是一种反射方法，可以用于获取指定对象或类型的方法信息 foreach (var method in methods) { if (method.IsGenericMethod) //IsGenericMethod 是 C# 中的一个方法，它用于检查给定的方法是否为泛型方法。如果是泛型方法，则返回 true，否则返回 false。当使用泛型类型或方法时，它允许在不指定具体类型或方法参数的情况下创建通用代码。 { //C# 中的 StringComparison.OrdinalIgnoreCase 表示不区分大小写的字符串比较方式，它适用于任何语言，包括中文。即使字符串中有汉字，使用该比较方式也会忽略其大小写差异，只比较它们的字符编码值。 if (string.Equals(method.ToString(), "void InitTable[T]()", StringComparison.OrdinalIgnoreCase)) { //MakeGenericMethod是 C# 中的一种方法，它允许您通过动态指定泛型方法的类型参数在运行时创建泛型方法。当您事先不知道参数的类型并且需要生成可以处理传入的任何类型的代码时，这很有用。该函数是命名空间的一部分，可以在表示泛型方法定义的 MethodInfo 对象上调用。 var genMethod = method.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1f9a237a0b514c9b7fe6ba96256bbae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c1826cf480cdc0df5aa32a7691f073/" rel="bookmark">
			【信息系统项目管理师教程（第4版）】目录（附大纲）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思维导图 https://www.mubucm.com/doc/qbBKiiPRMK（2023第4版目录）
https://www.mubucm.com/doc/ND7nxVh4u-（2023第4版大纲）
目录 第1章信息化发展1
1.1信息与信息化1 1.1.1信息2 1.1.2信息系统2 1.1.3信息化4 1.2现代化基础设施7 1.2.1新型基础设施建设7 1.2.2工业互联网8 1.2.3车联网10 1.3现代化创新发展12 1.3.1农业农村现代化12 1.3.2两化融合与智能制造13 1.3.3消费互联网15 1.4数字中国16 1.4.1数字经济17 1.4.2数字政府20 1.4.3数字社会23 1.4.4数字生态27 1.5数字化转型与元宇宙28 1.5.1数字化转型28 1.5.2元宇宙34 1.6本章练习35 第2章信息技术发展37
2.1信息技术及其发展37 2.1.1计算机软硬件37 2.1.2计算机网络38 2.1.3存储和数据库41 2.1.4信息安全47 2.1.5信息技术的发展48 2.2新一代信息技术及应用49 2.2.1物联网49 2.2.2云计算51 2.2.3大数据55 2.2.4区块链57 2.2.5人工智能60 2.2.6虚拟现实63 2.3本章练习65 第3章信息系统治理67
3.1IT治理67 3.1.1IT治理基础67 3.1.2IT治理体系69 3.1.3IT治理任务73 3.1.4IT治理方法与标准74 3.2IT审计80 3.2.1IT审计基础80 3.2.2审计方法与技术83 3.2.3审计流程88 3.2.4审计内容89 3.3本章练习91 第4章信息系统管理93
4.1管理方法93 4.1.1管理基础93 4.1.2规划和组织94 4.1.3设计和实施98 4.1.4运维和服务100 4.1.5优化和持续改进104 4.2管理要点107 4.2.1数据管理107 4.2.2运维管理119 4.2.3信息安全管理125 4.3本章练习127 第5章信息系统工程129
5.1软件工程129 5.1.1架构设计129 5.1.2需求分析131 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c1826cf480cdc0df5aa32a7691f073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ecc041ed670e04e6d2743f39154926/" rel="bookmark">
			ab性能测试工具的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ab介绍 ab，是Apache Benchmark的缩写，是一个种用于测试Apache的超文本传输协议（http）服务器的工具。
二、ab原理 ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问，它的测试目标是基于URL的。因此，它既可以用来测试Apache的负载压力，也可以 测试nginx、lighthttp、tomcat等其它Web服务器的压力。
ab命令对发出负载的计算机要求很低，既不会占用很高的CPU，也不会占用很多的内存，但却会给目标服务器造成巨大的负载，其原理类似CC攻击，自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源消耗完，严重时甚至导致死机。
注：
CC攻击=Challenge Collapsar（挑战黑洞），是针对Web服务在 OSI 协议第七层协议发起的攻击，攻击者极力模仿正常用户的网页请求行为，发起方便、过滤困难，极其容易造成目标服务器资源耗尽无法提供服务。
CC攻击算得上是应用层的DDoS，而且是经过TCP握手协议之后，CC的攻击原理很简单，就是模拟多个用户对一些资源消耗较大的页面不断发出请求，从而达到消耗服务器资源的目的，当服务器一直都有处理不完的大量数据请求时，服务器资源浪费过多，就会造成堵塞，而正常用户的访问也会被终止，网站陷入瘫痪状态。
三、ab安装 1、安装网址：http://httpd.apache.org/
2、安装步骤：Window版本
下载完直接解压即可！
四、ab使用 1、找到Apache的bin目录进入cmd进入到该目录
2、进入之后输入要压测的网址
使用 ab -n 数字 -c 数字 url 路径的命令即可（n为测试总数，c为并发数）
例：测试总次数为1000，并发数为10(相当于10个用户同时访问，他们总共访问1000次)。
以上就是对ab性能测试工具简单的操作和安装介绍啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758a0ff12e178155a26c877d116ed386/" rel="bookmark">
			mpShare小程序分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引入uview组件(省略)查看或编辑mpShare.js module.exports = { onLoad() { // 设置默认的转发参数 uni.$u.mpShare = { title: '', // 默认为小程序名称 path: '', // 默认为当前页面路径 imageUrl: '' // 默认为当前页面的截图 } }, onShareAppMessage() { return uni.$u.mpShare }, // #ifdef MP-WEIXIN onShareTimeline() { return this.$u.mpShare } // #endif } 3.在main.js中打开小程序分享功能
// 引入uView对小程序分享的mixin封装 let mpShare = require('@/uni_modules/uview-ui/libs/mixin/mpShare.js'); Vue.mixin(mpShare); 页面自定义分享标题
在被分享页面的onLoad()函数中自定义标题 onLoad() { uni.$u.mpShare.title = '天苍苍野茫茫，风吹草低见牛羊'; }, 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/87/">«</a>
	<span class="pagination__item pagination__item--current">88/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/89/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>