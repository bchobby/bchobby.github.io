<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb43f1c59e99d3ba6dd025b903db18a/" rel="bookmark">
			Sqlmap的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，sqlmap支持的六种注入方式 1，基于布尔的盲注 通过返回页面判断条件真假的注入
2，基于时间的盲注 不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加来判断）
3，基于报错注入 页面会返回报错信息，或者直接把注入的语句直接返回在页面中
4，联合查询注入 使用union情况下的注入
5，堆查询注入 可以同时执行多条语句的执行时的注入
6，内联查询注入 在sql语句中执行sql语句
二，sqlmap的基本使用 1，检查是否存在注入点 python sqlmap.py -u "http://127.0.0.1/sql/Less-1/?id=1"
2，查看所有数据库 python sqlmap.py -u "http://127.0.0.1/sql/Less-1/?id=1" --dbs
3，查看当前使用的数据库 python sqlmap.py -u "http://127.0.0.1/sql/Less-1/?id=1" --current-db
4，查看表名 python sqlmap.py -u "http://127.0.0.1/sql/Less-1/?id=1" -D security --tables -D指定数据库，--tables列出表名
5，列出表中所有字段名 python sqlmap.py -u "http://127.0.0.1/sql/Less-1/?id=1" -D security -T users --columns
-D指定数据库，-T指定表名，-columns列出所有字段
6，列出字段内容（数据） python sqlmap.py -u "http://127.0.0.1/sql/Less-1/?id=1" -D security -T users -C username,password --dump
-D指定数据库，-T指定数据表，-C指定要列出的字段，--dump列出字段内容，转存数据
根据提示内容找到转存的数据：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d742cc4656fc557c40dcb237e47313f/" rel="bookmark">
			【FOC无刷电机控制】六步换向、FOC，STM32cubemx从零开始搭建BLDC六步换相代码、FOC代码（基于霍尔传感器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 O、前言1 个人经验2 软硬件介绍 一、六步换相1 新建cubemx工程2 工程基础配置（1）RCC时钟配置（2）SYS 调试接口（3）工程设置，生成MDK工程 3 串口（1）cubemx配置（2）printf重映射（3）测试 4 霍尔传感器（1）Cubemx配置（2）初始化启动（3）测试定时中断（4）测试霍尔中断 4 开环控制（1）普通PWM cubemx配置（2）普通GPIO配置（3）开环控制 二、FOC O、前言 用作备忘录，也希望能帮助正在入门摸索的朋友少走弯路，从外设开始，到开环，到闭环。参考文章代码：正点原子、野火、硬石，三家文档几乎一样。（个人感觉原子文档写的好） 1 个人经验 刚开始学无刷电机控制时是直接去看的FOC，网上理论一大堆，看了几天，理论大概明白了，想去实践编程，发现都是大多都是电机库，或者一些别人的完整代码，没有步骤教学。经过一顿摸索，我的结论是把理论化为单片机代码实际去控制电机的过程，某种程度上比学习理论更困难。我个人做一些单片机小项目的习惯是从头开始做。从一个空白工程开始，一个外设一个外设的调，调通一个测试一个，要用的所有外设调完再去加入控制代码，由开环到闭环，一步一步的来。直接用别人写好的一套代码总感觉心里没底。对于无刷电机控制，我的步骤是这样的：1调霍尔传感器，2调PWM，3调开环控制，4调闭环 2 软硬件介绍 软件：STM32cubemx+keil5硬件：网上买的一块无刷电机驱动板，芯片是STM32G070。要注意的是我的电机是BLDC，2对极，间隔60度安装的霍尔传感器。所以我现在实现的都是 基于霍尔传感器的开闭环控制。暂时没整过基于编码器的、基于无感的。 一、六步换相 六步换向用到的单片机外设：（根据个人板子引脚要做一些修改） TIM3：选择霍尔传感器模式，用于获取3个霍尔值。TIM1：通道123，普通PWM模式，用于驱动半桥电路的3个上半桥。（因为我这边用的是HPWM-LON的控制。）普通IO：3个，推挽输出，用于驱动半桥电路的3个下半桥。USART2：用于调试用。RTC：用于闭环控制。（这个用RTC中断可能不太合适，但是暂时这样…） 代码整体的调用流程： 开环：电机转动换相时，触发霍尔中断，在霍尔中断回调函数里读取当前的相位值，然后根据相位值进行换相。闭环：在开环的基础上，再开一个定时器，在里边做PID运算，更改占空比设定值。 六步换向-开环控制代码：https://github.com/wyfroom/BLDC_LiuBu_KaiHuan_hall六步换向-闭环控制代码： 1 新建cubemx工程 2 工程基础配置 （1）RCC时钟配置 选择时钟源，我这块板子只有外部8M晶振。
手动输入最大时钟频率，然后回车。我这块板子是64M。
（2）SYS 调试接口 我的下载器是SWD两根线的，所以我选这个。
（3）工程设置，生成MDK工程 点击生成代码
3 串口 这快板子没显示屏，调试中串口还是很有必要。我这块板子是串口2，看好引脚，串口自动配置的引脚不一定是板子上的。比如我这块板子，就不是这两引脚。 （1）cubemx配置 （2）printf重映射 添加如下代码到工程的 usart.c 文件中的 /* USER CODE BEGIN 0 / 和 / USER CODE END 0 */之间。 #include &lt;stdio.h&gt; #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { //具体哪个串口可以更改huart1为其它串口 HAL_UART_Transmit(&amp;huart2, (uint8_t *)&amp;ch, 1 , 0xffff); return ch; } 在main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d742cc4656fc557c40dcb237e47313f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43aae2748c9dd53b22375795a974cab/" rel="bookmark">
			CentOS8提高篇18：防火墙高级使用 命令备忘 批量开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos6 使用的是iptables，Centos7 以后使用的是filewall（-cmd）
iptables 用于过滤数据包，属于网络层防火墙。
firewall 能够允许哪些服务可用，那些端口可用...属于更高一层的防火墙。
1.firewalld的基本使用 启动： systemctl start firewalld
查看状态：systemctl status firewalld
停止： systemctl disable firewalld
禁用： systemctl stop firewalld
在开机时启用一个服务：systemctl enable firewalld.service
在开机时禁用一个服务：systemctl disable firewalld.service
查看服务是否开机启动：systemctl is-enabled firewalld.service
查看已启动的服务列表：systemctl list-unit-files|grep enabled
查看启动失败的服务列表：systemctl --failed
2.配置firewalld-cmd 查看版本： firewall-cmd --version
查看帮助： firewall-cmd --help
显示状态： firewall-cmd --state
查看防火墙规则： firewall-cmd --list-all
查看所有打开的端口： firewall-cmd --zone=public --list-ports
更新防火墙规则： firewall-cmd --reload
查看区域信息: firewall-cmd --get-active-zones
查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0
拒绝所有包：firewall-cmd --panic-on
取消拒绝状态： firewall-cmd --panic-off
查看是否拒绝： firewall-cmd --query-panic
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f43aae2748c9dd53b22375795a974cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a2d7cf000a2e68d7764d3e5c56ae10/" rel="bookmark">
			js基础之构造函数和类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS的构造函数和ES6的类是JS中很重要的概念，也是面向对象编程的核心。在本文中，我们将探讨JS的构造函数和ES6的类的基础知识，包括它们的定义、使用方法以及它们之间的区别。
JS的构造函数 JS中的构造函数是一种特殊的函数，用于创建对象。它们是通过使用new关键字调用的函数，并且在函数内部使用this关键字来引用新创建的对象。构造函数可以包含属性和方法，这些属性和方法可以在创建对象时被调用。
以下是一个简单的JS构造函数的例子：
function Person(name, age) { this.name = name; this.age = age; this.sayHello = function() { console.log("Hello, my name is " + this.name + " and I am " + this.age + " years old."); } } var person1 = new Person("John", 30); person1.sayHello(); // 输出：Hello, my name is John and I am 30 years old. // 原型上添加方法 Person.prototype.getName = function() { return this.name } 在上面的例子中，我们定义了一个名为Person的构造函数，并将其用于创建一个名为person1的新对象。我们传递了两个参数，即name和age，这些参数用于设置person1对象的属性。此外，我们还定义了一个名为sayHello的方法，该方法将输出一个问候语，其中包括person1对象的名称和年龄。
ES6的类 ES6引入了类的概念，这是一种更简洁、更易于阅读和理解的面向对象编程方式。类是一种特殊的函数，用于创建对象。与构造函数不同，类的定义中包含了构造函数以及其他方法和属性的定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a2d7cf000a2e68d7764d3e5c56ae10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e729624c1da61bdb1c10f14ead1317/" rel="bookmark">
			D2L，Pytorch win10下使用dataloader时出现runtimeerror: dataloader worker (pid(s) ) exited unexpectedly的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是用python3.8+pytorch1.11，在李沐老师的课程展示中使用的环境是linux没有报错，但win10下在dataloader使用前需要加上
if __name__ == "__main__": 例如：
batch_size = 256 if __name__ == "__main__": train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) 即可成功运行
网上还有其他方法将num_worker设为0也可以单线程成功运行,不过直接导入d2l的dataloader没有对应的参数
可能原因：
程序在运行时启用了多线程，而多线程的使用用到了freeze_support()函数。
freeze_support()函数在linux和类unix系统上可直接运行，在windows系统中需要跟在main后边。
更新：可以直接改包内代码
找到此文件…\Anaconda\Lib\site-packages\d2l\torch.py
编辑其中的def get_dataloader_workers():
改为return 0
或者return 0 if sys.platform.startswith('win') else 4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e426fe1f347ce58d57f52ab64b41fa49/" rel="bookmark">
			Redis 和 MySQL 如何保持数据一致性?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高并发的场景下，大量的请求直接访问MySQL很容易造成性能问题。所以，我们都会用Redis来做数据的缓存，削减对数据库的请求。但是，MySQL和Redis是两种不同的数据库，如何保证不同数据库之间数据的一致性就非常关键了。 一、导致数据不一致的原因？ 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库；读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新，数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题；这个业务场景，主要是解决读数据从Redis缓存，一般都是按照下图的流程来进行业务操作。 二、缓存先后删除问题 “ 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。
1. 先删除缓存 1)、如果先删除Redis缓存数据，然而还没有来得及写入MySQL，另一个线程就来读取；
2)、这个时候发现缓存为空，则去Mysql数据库中读取旧数据写入缓存，此时缓存中为脏数据；
3)、然后数据库更新后发现Redis和Mysql出现了数据不一致的问题。
2. 后删除缓存 1)、如果先写了库，然后再删除缓存，不幸的写库的线程挂了，导致了缓存没有删除；
2)、这个时候就会直接读取旧缓存，最终也导致了数据不一致情况；
3)、因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。
更多内容请关注公众号【程序员Style】，获取更多精彩内容！
三、解决方案 1. 延时双删策略 1). 基本思路 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
伪代码如下：
public void write( String key, Object data ){ redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key); } 2). 具体步骤 先删除缓存；再写数据库；休眠500毫秒；再次删除缓存。 “ 问题：这个500毫秒怎么确定的，具体该休眠多久时间呢？
需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。 比如：休眠1秒。
3). 设置缓存过期时间是关键点 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案；所有的写操作以数据库为准，只要到达缓存过期时间，缓存删除；如果后面还有读请求的话，就会从数据库中读取新值然后回填缓存。 4). 方案缺点 结合双删策略+缓存超时设置，这样最差的情况就是：
在缓存过期时间内发生数据存在不一致；同时又增加了写请求的耗时。 2. 异步更新缓存（基于Mysql binlog的同步机制） 1). 整体思路 1&gt;、涉及到更新的数据操作，利用Mysql binlog 进行增量订阅消费；
2&gt;、将消息发送到消息队列；
3&gt;、通过消息队列消费将增量数据更新到Redis上。
2). 操作情况 读取Redis缓存：热数据都在Redis上；
写Mysql：增删改都是在Mysql进行操作；
更新Redis数据：Mysql的数据操作都记录到binlog，通过消息队列及时更新到Redis上。
3). Redis更新过程 数据操作主要分为两种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e426fe1f347ce58d57f52ab64b41fa49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d096db96e081b75d80d88ae175ade0d4/" rel="bookmark">
			js简单实现轮播图效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这里将会用js简单实现轮播图的效果
提示：以下是本篇文章正文内容，下面案例可供参考
一、静态页面 代码如下（示例）：
&lt;div id="box"&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt; &lt;img src="./images/1.jpg" alt=""&gt; &lt;img src="./images/2.jpg" alt=""&gt; &lt;img src="./images/3.jpg" alt=""&gt; &lt;img src="./images/4.jpg" alt=""&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="ulList"&gt; &lt;ul&gt; &lt;li style="background-color: red;"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="leftBtn"&gt;左&lt;/div&gt; &lt;div id="rightBtn"&gt;右&lt;/div&gt; &lt;/div&gt; 二、css代码 代码如下（示例）：
* { padding: 0; margin: 0; } #box { margin: 100px auto; width: 600px; height: 400px; position: relative; } #parent { width: 600px; height: 400px; border: 1px solid red; overflow: hidden; } #child { width: 2400px; height: 400px; } #child img { float: left; width: 600px; height: 400px; display: block; } #ulList { position: absolute; left: 50px; bottom: 20px; } #ulList ul { list-style: none; overflow: hidden; } ul li { float: left; padding: 10px 15px; border: 1px solid black; border-right: 0; } ul li:last-child { border-right: 1px solid black; } #leftBtn, #rightBtn { position: absolute; top: 185px; padding: 10px 10px; border: 1px solid black; } #leftBtn { left: 0; } #rightBtn { right: 0; } 三、js代码 var parent = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d096db96e081b75d80d88ae175ade0d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea656f71b43f47e207d35f47650a737/" rel="bookmark">
			SpringBoot集成Mybatis-Plus最新代码自动生成器v3.5.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、概述二、导入依赖三、运行类（放在测试类中即可）四、配置说明4.1 数据库配置(DataSourceConfig)4.2 全局配置(GlobalConfig)4.3 包配置(PackageConfig)4.4 模板配置(TemplateConfig)4.5 注入配置(InjectionConfig)4.6 策略配置(StrategyConfig)4.6.1 Entity 策略配置4.6.2 Controller 策略配置4.6.3 Service 策略配置4.6.4 Mapper 策略配置 五、使用自定义格式输出文件（FreeMarkerTemplate模板引擎）5.1 存放模板文件位置如下 一、概述 官方原话
AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率
配置环境
开发工具 IDEAJDK 15数据库Mysql基于SpringBoot开发框架 二、导入依赖 &lt;!--使用Controller注解需要使用--&gt; &lt;dependencies&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;!--Lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--自动生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--pagehelper分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ea656f71b43f47e207d35f47650a737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc496de3b36d12d5c64faa791321c4b/" rel="bookmark">
			两篇2023 ICLR多模态论文分享(模态互补性对多模态鲁棒性影响 与 对多模表示学习有效的单模学习)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modality Complementariness Towards Understanding Multi modal Robustness 本文讨论了模态互补性在多模态鲁棒性中的重要性，并基于信息论提出了一种数据集层面量化度量，用于量化不同模态之间有多少互补信息，以及这些信息对预测标签有多大贡献。该指标基于互信息神经估计器（MINE）来计算。提出了一个两阶段pipeline，分成数据生成阶段和度量计算阶段。在数据生成阶段，作者生成具有受控模态互补性的数据集。在度量计算阶段，作者使用生成的数据集计算度量并分析结果。，并通过实验验证了其有效性。此外，本文还讨论了各种相关主题，如变压器、对抗性示例和深度学习模型。
这篇论文的主要贡献是提供了一个统一且可操作的方法来评估和优化多模态学习系统，以及提出了一些有趣且具有启发性的发现，例如：不同任务下最佳模态组合可能不同；单一模态可能包含足够或过剩信息；增加噪声或缺失值可以提高某些情况下的互补性等。本文还为量化多模态和缺失模态或噪声模态的贝叶斯错误率之间的差异提供了理论保证。
这篇论文的局限性或未来方向有：
这篇论文的理论分析框架只适用于多模态分类任务，对于其他类型的多模态任务，如生成、检索、对话等，还需要进一步扩展和验证。
这篇论文的指标计算依赖于互信息神经估计器（MINE），而MINE本身可能存在一些问题，如估计偏差、不稳定性、超参数敏感性等，这些问题可能影响到指标的准确性和可靠性。
这篇论文的实验设置较为简单，只考虑了两种模态（视觉和语言）以及两种噪声类型（高斯噪声和缺失值），对于更复杂和更真实的多模态场景，还需要进行更多的探索和分析。
互信息神经估计器（MINE）是一种基于神经网络的方法，用于估计高维连续随机变量之间的互信息。互信息是衡量两个随机变量之间相关性的一个指标，它等于两个随机变量的联合分布与边缘分布之间的KL散度1。MINE利用了一个重要的定理，即最大化一个函数关于联合分布和边缘分布的期望差等价于最大化该函数与互信息之间的下界23。因此，MINE可以通过梯度下降来训练一个神经网络，使其输出接近互信息的下界，并且具有线性可扩展性、灵活性和强一致性。
MINE的优势有：
它可以有效地估计高维连续随机变量之间的互信息，而不需要对分布做任何假设或近似。
它可以通过梯度下降来训练一个神经网络，使其输出接近互信息的下界，而不需要计算复杂的积分或优化问题。
它具有线性可扩展性、灵活性和强一致性，即它可以处理任意维度和样本大小的数据，并且在样本趋于无穷时，它的估计值会收敛到真实值。
MINE的缺点有：
它依赖于一个超参数，即神经网络的结构和激活函数，这些选择可能影响到估计值的准确性和稳定性。
它可能存在一些估计偏差，即它的估计值可能低于或高于真实值，这取决于神经网络的初始化和训练过程。
它可能受到样本相关性、噪声、离群点等因素的干扰，导致估计值不准确或不可靠。
有很多方法可以估计互信息，其中一些常见的有：
直接方法：这种方法通过呈现来自p(S)的刺激，并从重复呈现相同刺激来估计hΔ(R|S)，从而估计hΔ®和hΔ(R|S)。由于估计p(R|S)所需的数据量通常很大，因此大多数研究者采用一些技术来给I(S;R)设置上下界。
基于k最近邻的方法：这种方法通过利用k最近邻距离来估计熵和互信息，不需要对数据进行分箱或假设分布的形式。它具有非参数性、鲁棒性和一致性，但也存在一些缺点，如高维空间中距离度量的困难、超参数k的选择和样本相关性的影响。
基于几何k最近邻的方法：这种方法是基于k最近邻的方法的改进，它通过在流形上定义距离度量来克服高维空间中欧氏距离失效的问题。它利用了流形学习中的局部线性嵌入（LLE）算法，将数据映射到一个低维空间，然后在该空间中使用k最近邻算法来估计互信息。、
论文的3.1节主要讲了多模态互补性度量（Modality Complementarity Metric），这是一个用来评估多模态数据中不同模态之间信息互补程度的指标。该指标基于信息熵（Entropy）和互信息（Mutual Information）的概念，可以反映出多模态数据中每个模态对整体信息的贡献和冗余。该指标可以用来预测多模态模型在不同场景下的鲁棒性，例如缺失某个模态、某个模态受到噪声或对抗攻击等
论文的3.2节主要讲了多模态互补性度量的理论分析（Theoretical Analysis of Modality Complementarity Metric），这是一个用来证明该指标与多模态鲁棒性之间关系的数学推导。该分析基于贝叶斯风险（Bayesian Risk）和最小化期望损失（Minimizing Expected Loss）的原则，给出了在不同场景下，多模态互补性度量与多模态模型性能之间的上下界。该分析表明，当某个模态缺失或受到噪声或对抗攻击时，多模态互补性度量越高，多模态模型的性能下降越小。
这篇论文的3.3节主要讨论了如何在真实世界的多模态数据集上计算模态互补性度量，并展示了不同数据集的模态互补性和多模态鲁棒性之间的关系。
论文中的图2显示了在不同设置下，模态互补性和多模态鲁棒性之间的关系。模态互补性是一种度量每种模态对其他模态增加多少信息的指标。多模态鲁棒性是指一个模型在某些模态缺失或受损时能够表现良好的能力。
图2的作用是说明论文的主要思想：模态互补性影响多模态鲁棒性。互补性越高，模型对缺失或噪声模态越敏感。互补性越低，模型对这种情况越鲁棒 。
I(X; Y, Z)表示X和(Y, Z)之间的互信息，即X减少了对(Y, Z)的不确定性的程度。它等于(Y, Z)的熵减去给定X时(Y, Z)的熵。
I(Z; Y, X) 表示 Z 和 (Y, X) 之间的模态互补性，即 Z 在 (Y, X) 缺失或受损时能够减少对 (Y, X) 的不确定性的程度。它等于 (Y, X) 的熵减去给定 Z 时 (Y, X) 的熵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc496de3b36d12d5c64faa791321c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8969622b8e9cf83da3adbc4942ebe40/" rel="bookmark">
			platform架构完成，在应用层通过ioctl控制LED灯流水，当按键KEY1按下让风扇转动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现过程：
驱动代码:
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/of_gpio.h&gt; #include &lt;linux/of_irq.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/list.h&gt; #include &lt;linux/stddef.h&gt; #include &lt;linux/spinlock.h&gt; #include &lt;asm/current.h&gt; #include &lt;uapi/linux/wait.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/poll.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/mod_devicetable.h&gt; // 开关灯命令码 #define LED1 _IOW('a', 1, int) #define LED2 _IOW('a', 2, int) #define LED3 _IOW('a', 3, int) struct cdev *cdev; // 驱动设备对象 dev_t devno; // 设备号 unsigned int major = 0; // 动态态指定主设备号 unsigned int minor = 0; // 次设备号 struct class *cls; // 目录信息 struct device *dev; // 设备节点信息 struct device_node *led_node, *interrupt_node, *fnode; // 灯节点,中断节点，灯节点的子节点 struct gpio_desc *gpio_num[4] = {0}; // gpio编号 char *led[4] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8969622b8e9cf83da3adbc4942ebe40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dd01f184eba2b19c00ad7e33910502/" rel="bookmark">
			CAN总线 标准帧/扩展帧滤波器设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在CAN协议里，报文的标识符不代表节点的地址，而是跟报文的内容相关的。因此，发送者以广播的形式把报文发送给所有的接收者。节点在接收报文时,根据标识符(CAN ID)的值决定软件是否需要该报文；如果需要，就拷贝到SRAM里；如果不需要，报文就被丢弃且无需软件的干预。
为满足这一需求，bxCAN为应用程序提供了14个位宽可变的、可配置的过滤器组(13~0)，以便只接收那些软件需要的报文。硬件过滤的做法节省了CPU开销，否则就必须由软件过滤从而占用一定的CPU开销。每个过滤器组x由2个32位寄存器，CAN_FxR0和CAN_FxR1组成。
//标准帧 T_CAN_Filter gtCan1Filter[] = {{0,(0x305 &lt;&lt; 21), (0x07FF &lt;&lt; 21)},}; //ID = 0x305 //扩展帧 T_CAN_Filter gtCan1Filter[] = {{0, (0x0000FF00 &lt;&lt; 3), (0x0000FF00 &lt;&lt; 3)},};// ID = 0xFF #define CAN_FILTER_NUM (sizeof(gtCan1Filter) / sizeof(gtCan1Filter[0])) for(; uIndex &lt; CAN1_FILTER_NUM; uIndex++) { CAN_FilterInitStructure.CAN_FilterNumber = gtCan1Filter[uIndex].uFilterNumber; CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask; CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit; CAN_FilterInitStructure.CAN_FilterIdHigh = gtCan1Filter[uIndex].uFilterId&gt;&gt; 16; CAN_FilterInitStructure.CAN_FilterIdLow = gtCan1Filter[uIndex].uFilterId; CAN_FilterInitStructure.CAN_FilterMaskIdHigh = gtCan1Filter[uIndex].uFilterMaskId&gt;&gt; 16; CAN_FilterInitStructure.CAN_FilterMaskIdLow = gtCan1Filter[uIndex].uFilterMaskId; CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0; CAN_FilterInitStructure.CAN_FilterActivation = ENABLE; CAN_FilterInit(&amp;CAN_FilterInitStructure); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ca249dd25fd9316d8941036cb694dc/" rel="bookmark">
			Element-UI表格自定义背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记
1.如图所示
2. 自定义样式
此处自定义设置时要加 /deep/、important，否则不生效；
&lt;style scoped="scoped"&gt; // 更改表头背景颜色 /deep/.el-table thead tr&gt;th{ background-color: #FFDAB9; } // 更改表格每行背景颜色 /deep/.el-table tbody tr&gt;td{ background-color: #FFEFD5; } // 设置鼠标经过时背景颜色 /deep/.el-table tbody tr:hover&gt;td{ background-color:#FFFFF0!important; } &lt;/style&gt; 清除鼠标经过时的背景颜色：
/deep/.el-table tbody tr:hover&gt;td{
background-color: unset !important;
}
* 如果未设置!important该效果不生效
自定义样式时使用f12查看元素，找到对应元素的标签或者类名，如果&lt;style scoped="scoped"&gt;设置scoped就需要加/deep/，有的还需要!important才会生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e59ec4b4e1496b410fbfaf43656b9a1/" rel="bookmark">
			springboot：整合rabbitmq之重试机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们消息消费失败的时候，可以进行重试，
什么情况下会重发消息
1、网络抖动
2、程序抛出异常没有try-catch
RabbitMQ自动补偿机制触发:(多用于调用第三方接口)
1.当我们的消费者在处理我们的消息的时候,程序抛出异常情况下(默认无限次数重试),如果这里的异常try-catch后自己配置的重试机制是不生效的
2.应该对我们的消息重试设置间隔重试时间,比如消费失败最多只能重试5次,间隔3秒(防止重复消费,幂等问题)
如果重试5次,也就是15秒内重试还是失败情况下应该如何处理
1.默认情况下,重试多次还是失败的话,会自动删除该消息(消息可能会丢失)
解决思路:
A:如果重试多次还是失败的情况下,最终存放到死信队列.
B:采用表日志记录,消费失败错误的日志记录 后期人工自动对消息实现补偿.
一、项目准备
依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 配置类
spring.rabbitmq.port=5672 spring.rabbitmq.username=rabbit spring.rabbitmq.password=123456 spring.rabbitmq.addresses=192.168.23.145 spring.rabbitmq.virtual-host=/rabbit 二、案例重现
# 声明队列 @Configuration public class HelloWorldConfig { @Bean public Queue setQueue() { return new Queue("helloWorldqueue"); } } # 生产者 @Slf4j @RestController public class ProducerController { @Autowired private RabbitTemplate rabbitTemplate; //helloWorld 直连模式 @ApiOperation(value="helloWorld发送接口",notes="直接发送到队列") @GetMapping(value="/helloWorldSend") public Object helloWorldSend(String message) throws AmqpException, UnsupportedEncodingException { //设置部分请求参数 MessageProperties messageProperties = new MessageProperties(); messageProperties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e59ec4b4e1496b410fbfaf43656b9a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d349f2cc69f1d7393d0c0bba4263929e/" rel="bookmark">
			在Linux上JMeter压测报错java.lang.OutOfMemoryError: Java heap space 解决方法【纯干货，无废话】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux上压测报错JMeter内存溢出：java.lang.OutOfMemoryError: Java heap space 解决方法【纯干货，无废话】
问题： 使用jmeter进行压测过程中,并发数过大时会导致内存溢出,jmeter卡死，内存泄露是指使用资源后没有及时释放, 导致内存中持有了不需要的资源; 内存溢出是指应用的内存已经不能满足正常使用了，堆栈已经达到系统设置的最大值，进而导致Crash；用JMeter压测，有时候当模拟并发请求较大或者脚本运行时间较长时，JMeter会停止，报OOM（内存溢出）错误， 并发线程高，内存溢出问题
Uncaught Exception java.lang.OutOfMemoryError: Java heap space in thread Thread[StandardJMeterEngine,5,main]. See log file for details.
原因是：JMeter是一个纯Java开发的工具，内存由java虚拟机JVM管理，当内存回收不及时，堆内存不足时，就会报内存溢错误。 # 概念补充： 内存泄露：应用使用资源之后没有及时释放，导致应用内存中持有了不需要的资源。 内存溢出：应用的内存已经不能满足正常使用了，堆栈已经达到系统设置的最大值，进而导致崩溃。 通常都是由于内存泄露导致堆栈内存不断增大，从而引发内存溢出。 对JMeter而言也是如此，JMeter测试过程中，如果内存溢出的话，一般会出现上图中的提示：java.lang.OutOfMemoryError: Java heap space：意思就是堆内存溢出，不够用了 答案： 1.Linux下jmeter jvm参数修改,打开jmeter安装目录/bin/jmeter （非jmeter.sh 文件）
2.解决方法如下：
解决： 编辑jmeter 搜索 : "${HEAP:="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m"}" 改变初始堆内存和最大堆内存 根据自己的机器内存修改，我改的是： “${HEAP:=”-Xms2g -Xmx5g -XX:MaxMetaspaceSize=2024m"}" “${HEAP:=”-Xms2g -Xmx6g -XX:MaxMetaspaceSize=2024m"}" “${HEAP:=”-Xms4g -Xmx10g -XX:MaxMetaspaceSize=3000m"}" 3.发布后正常启动。
注意 这个值不是越大越好，要根据压测使用的机器而定，一般而言，堆内存的最大值不要超过物理内存的一半，否则容易导致jmeter运行变慢、
卡顿甚至内存溢出（因为java本身的垃圾回收机制是动态分配内存，调整的时候其本身会占用很多内存），NEW分配的内存，不宜太大。
2、修改完成后保存，重启JMeter，即可生效。
小结 1、这种修改堆大小的方法只适用一部分情况，并不是万能的，当需要模拟的线程数较大时，就需要根据具体情况采用分布式压测的方式了。
2、命令行运行JMeter时，一定要禁用“查看结果树”、“聚合报告”等监听器，因为真的真的真的很消耗内存。
jmeter压测结束出现java_pid58971.hprof from chatGp answer: jmeter压测结束出现java_pid58971.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d349f2cc69f1d7393d0c0bba4263929e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6841739ab8dae9f2b0da899035b2e315/" rel="bookmark">
			软考高项第4版教程-差异点解析来啦（第4章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周已经开始啦！我结合拿到的新版教程，陆续展开的更加深入和细致的解读，帮助你精准把握考试大纲及教程的变化，进而在接下来的考试中旗开得胜！
上周带来了第1章和第2章，前天带来了第3章，没有看到的疯友可以去翻历史文章，这次给你带来的是第4章“信息系统管理”的差异点解读，不好意思，写着写着没控制住，一下写了3000多字，以后我多注意
“信息系统管理”文字版 第4章信息系统管理，一共包含2小节的知识块，分别是“管理方法”和“管理要点”。
除了信息安全管理之外，这一章绝大部分内容都是第4版教程新增加的，特别是数据管理部分，是本章的重头戏。这也呼应了这版新教程向数字化和数字中国倾向的目的，值得你认真学习。
这一章给我的感受和上一章很类似，包含的信息量太多了，每个都是面面俱到，但是每个都是蜻蜓点水，甚至连水都没碰到就飞走了，其中信息含量如果完全展开，大概是5本左右的专业书籍。
咱们考高项肯定不需要学这么深入，但是到底学到什么层面就可以了呢？我会在后续的第4版教程加餐视频课中详细说给你听，不过这里如果简要讲，你只需要理解其中的概念名词就好了。
下面我带你一起逐个小节分析下第4版教程的考试重点
“管理方法”知识块，包含了全生命周期管理中的“规划和组织”、“设计和实施”、“运维和服务”和“优化和持续改进”4大阶段。
1.信息系统层次架构图
这个小节一开始给你展示了信息系统层次架构图，这个图很简单，但是理解了这个图，你也就理解了管理的精髓，这个一点都不夸张。
信息系统之上是管理，说明信息系统是为管理服务，信息系统之下是信息系统的4个要素：人员、技术、流程和数据。
回想下你或者你老板在公司做管理时，是不是提到最多的是人力资源、技术能力、流程改进和数据资产？
2.战略三角
规划和组织提到了战略三角，信息系统战略三角突出了业务战略、信息系统和组织机制之间的必要一致性。
你需要掌握三角是哪三个角，应对可能出选择题的可能，最好你也能够理解这3个角之间的关系，也许能帮助你在公司踏上高管之路也不一定哦。
3. 竞争力优势模型
描述业务战略的经典框架是波特的竞争力优势模型，你没看错，还是那个熟悉的波特，那个提出了经典竞争力五力模型的迈克尔波特，而且更为传奇的是，波特竟然还健在，还和我们一样活在2023年，被誉为“活着的传奇”。
波特提到的3种竞争力优势模型比较好理解，分别是：总成本领先战略、差异性战略和专注化战略。记住这3个战略的名字和含义，可能选择题或者选择中的判断题会考到
4.钻石模型
这一章有特别多的管理学模型，钻石模型将组织计划的关键组成部分标识为：信息与控制、人员、结构和任务，4个部分形成一个钻石的形状，也是用来考选择题比较好的考点，因为选择题有4个选项，钻石模型也有4个要素，多好的出题点：）
5.信息系统战略矩阵
信息系统战略矩阵用来理解组织必须做出的与信息系统相关的决策。其中包含的四个基础结构组件可以了解，分别是硬件、软件、网络和数据，这个没什么好说的，你应该都熟悉
回顾下，以上提到的竞争力优势模型、钻石模型和信息系统战略矩阵，其实都是在讲战略三角的3条边，在这之后，第4版教程开始进入第2个阶段“设计和实施”
6.设计和实施阶段
“设计和实施”阶段有2个相对重要的考点。
1个考点是使用转换框架，将业务战略转化为信息系统架构，然后再将该架构转化为信息系统设计
另外1个考点是信息系统体系架构。传统上，信息系统体系架构有三种常见模式：1）集中式架构；2）分布式架构；3）面向服务的系统架构。这3种架构的特点以及彼此之间的区别，你需要在学习的时候重点关注和掌握。
第3个阶段是运维和服务阶段。这个小节，第4版教程在不到4页的篇幅内，讲了其中包含的8类管理活动，你可以想象得到，只有讲的非常非常浅，才能做到吧。
这长达8类的管理活动包括：运行管理和控制、IT服务管理、运行与监控，终端侧管理、程序库管理、安全管理、介质控制和数据管理。
7.IT服务管理
我个人建议你把学习的重心放在前面5个活动上，特别是IT服务管理活动。IT服务管理包含了11个活动，让我情不自禁想到了俄罗斯套娃。
这11个活动分别是：服务台、事件管理、问题管理、变更管理、配置管理、发布管理、服务级别管理、财务管理、容量管理、服务连续性管理和可用性管理。
8.DMAIC/DMADV
最后一个阶段是“ 优化和持续改进”，第4版教程 从PDCA 循环切入，重心却落到了六西格玛的五阶段方法 DMAIC/DMADV，其中包含的5个阶段（定义 、度量、分析 、改进/设计 、控制/ 验证 ）
每个阶段的目标你需要认真复习，我会在第4版教程的加餐视频课也会重点讲解。理解了各个阶段的目标，其实就理解了DMAIC/DMADV。
有没有发现，我前面不知不觉已经写了1000多字，都是在分析第1个“管理方法”知识块，这个知识块就是按照4个阶段来组织教程结构的。
接下来，进入第2个知识块“管理要点”。第2个知识块只有1个大块头知识点：数据管理。
这里面的数据管理，提到的是数据管理能力成熟度评估模型DCMM，DCMM一共有 8个核心能力域，又是“8”这个熟悉数字，前面的“运维和服务阶段”也是8个活动。
9.DCMM8个核心能力域
DCMM的8个核心能力域，分别是数据战略、数据治理、数据架构、数据应用、数据安全，数据质量、数据标准和数据生存周期。
首先要提到的是，第4版教程非常明显的特点是求大而全，这里的数据管理一共才12页，但是其中包含的内容是好几本数据类专业书的内容，你学习起来会感觉很抽象是不可避免的，不过我还是建议你要坚持学下去，
另外一个小建议是提前了解下数据类的专业术语，比如什么是主数据、什么是参考数据、什么是元数据，什么又是数据元。这几个专业术语我会在加餐视频课讲到，了解这几个专业术语后，有助于你对接下来8个核心能力域的理解。
8个核心能力域，你需要掌握每个能力域的能力项。我简单数了下，大概每个能力域有3-4个能力项，一共加起来是28个能力项。
看起来的确是挺多的，多也需要掌握，但是呢，并不意味着你要背诵的滚瓜烂熟，而是需要理解中记忆，能记忆到什么程度就是什么程度，关键还是要去理解。
10.理论框架与成熟度
接下来就是一些小知识点了，比如DCMM 将组织的管理成熟度划分为5个等级，分别是：初始级、受管理级、稳健级、量化管理级和优化级。
至于接下来提到的数据治理框架、数据管理能力评价模型、数据管理模型，教程中只有寥寥几笔，我个人建议暂时不用作为重点，一带而过。
11.运维管理
“运维管理”小节提到了IT运维能力模型，这个模型包含治理要求、运行维护服务能力体系和价值实现3个组成部分。
这里的重点是人员、过程、技术、资源能力四要素。接下来教程里面提到了智能运维，智能运维我认为你主要结合图来理解即可。
12.信息系统安全管理
也许习惯了第3版教程把安全独立成章，在第4章最后加入安全管理总感觉有些违和感，特别是篇幅也少的可怜，也就2页多的内容。
信息系统安全管理，你需要掌握CIA三要素、网络安全等级保护五级、安全保护能力等级五级。
以上就是我对第4章信息系统管理的新版教程差异点（重点）的分析。
最后预报下我对第5章的安排：第5章内容巨多，篇幅顶得上2章内容，为了能够分析透彻，同时文章控制2000字以内，我计划将第5章差异点分析拆分成上下两篇，敬请期待，谢谢。
“信息系统管理”脑图版 除了上面介绍的差异点之外，我还结合我的理解，制作了第4章的重点考点的思维导图，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6841739ab8dae9f2b0da899035b2e315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6644da1da9642a6fda4c49c5825ca56/" rel="bookmark">
			Jetson Xavier NX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetson Xavier NX `提示：记录学习过程，倘若有抄袭请原谅
文章目录 Jetson Xavier NX前言一、安装系统二、烧镜像三、启动系统打开风扇先 四、配置VNC（此处借鉴）五、安装中文输入法六、安装cuda七、安装pytorch跟torchvision八、试试，以nandet试试九、其它扩展-安装ros十、格式化NX跟nano的sd卡 前言 例如：小编作为智能专业学生，虽然现在工作嵌入式，但是玩转ai的心一直都有，所以手头有一块Jetson Xavier NX ，所以来玩玩。
一、安装系统 小编是从别人那里拿来的，当然我也用科学上网去下载过，一样的
这是Jetson NX 的镜像
链接：https://pan.baidu.com/s/1YSXiZFcMvNRpYnc5gKwifg
提取码：ages
这是Jetson nano b01的镜像
这里是引用
nano的镜像是小编处理过的，所以比较大，但是可以直接烧入进去
二、烧镜像 这里很简单 ，NX找个最少64G的内存卡，128g最佳，nano最低16G,小编分别用的是128G跟32G,
然后下载
链接：https://pan.baidu.com/s/1A0I-nVf68n7FnXYdBJDy-A
提取码：wpfa
上面是内存卡格式化工具跟烧入工具
格式化
烧入
这里时间比较久，建议打一局王者，或者该干嘛干嘛去，打完就会出现write successful
三、启动系统 nani跟nx都是内存卡启动，这里需要外接键盘跟显示器跟鼠标，对于初始化系统自己设置就行默认，然后就看到英伟达的标志界面，还是挺好看的对吧
打开风扇先 sudo sh -c “echo 150 &gt; /sys/devices/pwm-fan/target_pwm”
四、配置VNC（此处借鉴） VNC是啥，就是一款远程的方式，可以说软件，也可以说协议
这里我们为了方便我们用putty远程他们之间用wifi相连或者网线，然后ifconfig获取ip，
远程过去后我们先
sudo passwd root
输入的密码还可以跟以前的一样
su: Authentication failure
hiden@hiden:~$ sudo apt-get update
Reading package lists… Done
E: Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6644da1da9642a6fda4c49c5825ca56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854b79c91fd9e6d5ff9106f6daa637c9/" rel="bookmark">
			在vue中给组件设置name报错` Component name “Head“ should always be multi-word.eslint`
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue中给组件设置name报错Component name "Head" should always be multi-word.eslintvue/multi-word-component-names 报错的原因： 在组件命名的时候未按照 ESLint 的官方代码规范进行命名，根据 ESLint 官方代码风格指南，除了根组件（App.vue）以外，其他自定义组件命名要使用大驼峰命名方式或者用“-”连接单词进行命名；
解决： 1.配置 .eslintrc.js文件 关闭命名规则
找到 .eslintrc.js 文件在 rules 里面加上这么一句
// 关闭名称校验 'vue/multi-word-component-names': "off" 建议使用这种方法，更加正确合理； 2.如果没有找到.eslintrc.js文件 可以把"vue/multi-word-component-names": "off" 加在packsge.json–&gt;eslintConfig–&gt;rules里面
原文地址：添加链接描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e4737a3e4e9f8f3619fb6ad8ef21b7a/" rel="bookmark">
			超前进位加法器 verilog代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超前进位加法器（Carry LookAhead Adder） 设计思想
由于行波进位加法器具有明显的延迟，从图中可以看出延迟主要是由进位传播链引起的，因此如何可以快速得到每一位的进位信号是加速计算的关键，这里提出了一种新的设计思想，即让每一位进位的产生近依赖于同一输入信号，这样便可以同时计算得到每一位的进位信号。
公示推导
这里引入两个信号位：进位产生位（gi）和进位传递位（pi），使得所有各位的进位都不依赖于低位的进位，每一位的进位可以同时产生，因而得到结果的延迟与运算位数无关，逻辑表达式如下：
四位加法器的计算公式：
架构图 理论上对于64位加法器的设计同样可以按照上面的推导全部展开，然而此时ci的表达式太长，意味着对逻辑门扇入和扇出的要求太大，电路的实现会变得十分复杂。因此设计64位的超前进位加法器可以采用多级分层实现的方案。将64位输入分解为16组4位的超前进位加法器，第一级得到得到的16组为超前进位的第二级，该级组间仍然使用超前进位的逻辑进行实现，可以进一步再分为4组，形成第三级。因此这里设计的64位超前进位加法器由3级超前进位逻辑实现。
上图为32位加法器示意图，64位架构与其相同。
关键路径分析
图中红色路径为此加法器的关键路径，可以看出此加法器的延迟为3级超前进位的产生延迟，与操作数位数的延迟关系为T=Log(N)*t(CLA)
verilog代码
module adder_nocarry( input A,B,C_in, output S, output g,p ); assign S = A ^ B ^ C_in; assign g = A &amp; B; assign p = A ^ B; endmodule module adder_LKAHD_4bit( //超前三位计算进位信号 input [3:0]A,B, input C_in, output [3:0]Y, output G,P ); wire [3:0]c,g,p; adder_nocarry add0 (A[0],B[0],C_in,Y[0],g[0],p[0]); adder_nocarry add1 (A[1],B[1],c[0],Y[1],g[1],p[1]); adder_nocarry add2 (A[2],B[2],c[1],Y[2],g[2],p[2]); adder_nocarry add3 (A[3],B[3],c[2],Y[3],g[3],p[3]); CLA_4bit cla (g,p,C_in,c); assign G = g[3] | (p[3]&amp;g[2]) | (p[3]&amp;p[2]&amp;g[1]) | (p[3]&amp;p[2]&amp;p[1]&amp;g[0]) ; assign P = p[0]&amp;p[1]&amp;p[2]&amp;p[3]; endmodule module CLA_4bit( input [3:0]g,p, input C_in, output [3:0]C ); assign C[0] = g[0] | (p[0]&amp;C_in); assign C[1] = g[1] | (p[1]&amp;g[0]) | (p[0]&amp;p[1]&amp;C_in) ; assign C[2] = g[2] | (p[2]&amp;g[1]) | (p[2]&amp;p[1]&amp;g[0]) | (p[2]&amp;p[1]&amp;p[0]&amp;C_in); assign C[3] = g[3] | (p[3]&amp;g[2]) | (p[3]&amp;p[2]&amp;g[1]) | (p[3]&amp;p[2]&amp;p[1]&amp;g[0]) | (p[3]&amp;p[2]&amp;p[1]&amp;p[0]&amp;C_in) ; endmodule module adder_LKAHD_16bit( input [15:0] A,B, input C_in, output [15:0]S, output GX,PX ); wire [3:0] C,G,P; adder_LKAHD_4bit Add3 (A[15:12],B[15:12],C[2],S[15:12], G[3], P[3]); adder_LKAHD_4bit Add2 (A[11:8], B[11:8], C[1],S[11:8], G[2], P[2]); adder_LKAHD_4bit Add1 (A[7:4], B[7:4], C[0],S[7:4], G[1], P[1]); adder_LKAHD_4bit Add0 (A[3:0], B[3:0], C_in,S[3:0], G[0], P[0]); CLA_4bit cla1 (G,P,C_in,C); assign GX = G[3] | (P[3]&amp;G[2]) | (P[3]&amp;P[2]&amp;G[1]) | (P[3]&amp;P[2]&amp;P[1]&amp;G[0]) ; assign PX = P[0]&amp;P[1]&amp;P[2]&amp;P[3]; endmodule module adder_LKAHD_64bit( input [63:0] A,B, input C_in, output [63:0]S, output C_out ); wire [3:0] C,GX,PX; adder_LKAHD_16bit Add7 (A[63:48], B[63:48], C[2], S[63:48], GX[3], PX[3]); adder_LKAHD_16bit Add6 (A[47:32], B[47:32], C[1], S[47:32], GX[2], PX[2]); adder_LKAHD_16bit Add5 (A[31:16], B[31:16], C[0], S[31:16], GX[1], PX[1]); adder_LKAHD_16bit Add4 (A[15:0], B[15:0], C_in, S[15:0], GX[0], PX[0]); CLA_4bit cla2 (GX,PX,C_in,C); assign C_out = C[3]; endmodule 测试文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e4737a3e4e9f8f3619fb6ad8ef21b7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68097656e19586cd880f1d7ac182265d/" rel="bookmark">
			芯旺微 chipon 型号KF32A156的flash驱动flash driver放置在ram的操作方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		申明：原创扣字不易，转载还请注明源出处 芯旺微 chipon 型号KF32A156的flash驱动flash driver放置在ram的操作方式介绍：
敲重点 目前很多主机厂对于flash驱动有要求：在平时不需要的时候，并不会将flash擦写函数放在程序中，这样可以防止在单片机异常环境下进行了flash的不当操作导致程序或者数据损坏。故而需要将flash驱动单独拎出来，在需要的时候再拷进去。 针对这个要求，我们可以进行如下操作 1、将flash擦写函数定义好（156的擦写函数是已经封好的，内部我们看不到，151系列目前可以查看），并在主函数中进行引用（防止被优化）。
2、建立一个数组，将相关的擦写函数进行提取，本质上就是将擦写函数编译生成二进制数复制下来放置在数组中。
3、创建一个接收usigned int32 类型的空函数指针，注意要加上形参，根据擦写函数实际要传入的参数进行定义。然后再定义两个该类型的空函数，正常都是一个擦，一个写。
4、将第2步的数组的起始地址赋值给第3步的空函数，这样就完成了以上操作。
这里要说明的是，在实际的使用中，为了防止异常跑到flash驱动函数里面，这个数组里面的数据并不是长期存储在flash上面，或者ram上面。 下面是图示步骤： 1、flash的驱动函数在默认的库里面，位置如下，一般只需要擦和写的即可。读是可以指针直接获取的。然后在main函数中随便调用一下，防止优化。
2、编译完成后，我们找到对应的二进制数据
3、将这些数据提取出来，创建数组，放到数组里面。（这里没有使用通讯传输，客户如果需要通讯测试可自行创建空数组通过通讯的方式将数据发送至数组里面）
4、创建unsigned int 类型的空函数指针，且附上参数，再将存放数据的数组进行赋值。操作如下图：
总结：这样我们再调用定义的函数即可实现flash driver的功能啦。
本文实现已经将程序打包,本人客户可直接向我获取。
18726993984
本次更新日期：2023-3-28
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b89be02fcf4edc8a29e3b1acc1f31c6/" rel="bookmark">
			编写驱动，应用层程序，在应用层通过ioctl控制LED灯流水，当按键KEY1按下让风扇转动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现过程：
驱动代码：
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/of_gpio.h&gt; #include &lt;linux/of_irq.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/list.h&gt; #include &lt;linux/stddef.h&gt; #include &lt;linux/spinlock.h&gt; #include &lt;asm/current.h&gt; #include &lt;uapi/linux/wait.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/poll.h&gt; // 开关灯命令码 #define LED1 _IOW('a', 1, int) #define LED2 _IOW('a', 2, int) #define LED3 _IOW('a', 3, int) struct cdev *cdev; dev_t devno; unsigned int major = 0; // 动态态指定主设备号 unsigned int minor = 0; struct class *cls; struct device *dev; struct device_node *led_node, *interrupt_node, *fnode; // 灯节点,中断节点，灯节点的子节点 struct gpio_desc *gpio_num[4] = {0}; // gpio编号 char *led[4] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b89be02fcf4edc8a29e3b1acc1f31c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56048809455a63ccbe28b4d2b012f63e/" rel="bookmark">
			第一章 Linux系统服务：Apache安装及配置应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章HTTP 1.1http与html 1.2浏览器访问网站的过程 1.3HTTP工作机制
1.4版本 1.5HTTP方法 1.6.http状态码 1.7请求报文 1.8 响应报文 第二章Apache的简单介绍 1.Apache基础知识 2.Apache配置文件位置 三.LAMP架构 1.LAMP平台概述 2.LAMP各组件主要作用 3.构建LAMP平台顺序 四.Apache的三种工作模式 1. prefork模式（默认模式） 2. worker模式 3. event模式 五.LAMP架构与搭建论坛实验 实验准备：将所需软件安装包下载到/opt目录下、关闭防火墙、配置本地yum源仓库（此处已安装不再演示） 第一章HTTP 1.1http与html HTTP：为解决"用什么样的网络协议来实现整个因特网上的万维网文档”这一难题，就要使万维网客户程序（以浏览器为主，但不限于浏览器）与万维网服务器程序之间的交互遵守严格的协议，即超文本传送协议（HyperText Transfer Protocol）。HTTP是处于应用层的协议，使用TCP传输层协议进行可靠的传送。因此，需要特别提醒的是，万维网是基于因特网的一种广泛因特网应用系统，且万维网采用的是HTTP（80/TCP）和 HTTPS（443/TCP）的传输协议，但因特网还有其他的网络应用系统（如：FTP、SMTP等等）。
HTML：为了解决"怎样使不同作者创作的不同风格的万维网文档，都能在因特网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接”这一问题，万维网使用超文本标记语言（HyperText Markup Language），使得万维网页面的设计者可以很方便地用链接从页面的某处链接到因特网的任何一个万维网页面，并且能够在自己的主机品目上将这些页面显示出来。HTML与txt一样，仅仅是是一种文档，不同之处在于，这种文档专供于浏览器上为浏览器用户提供统一的界面呈现的统一规约。且具备结构化的特征，这是txt所不具备的强制规定
1.2浏览器访问网站的过程 一次完整的http请求处理过程
1.建立连接
2.接收请求，接收客户端请求报文中对某项资源的一次请求的过程
3.处理请求，解析，得到处理方法
4.访问资源。
5.构建响应报文（响应实体，url重定向，mime类型）
6.发送响应报文
7.记录日志
1.3HTTP工作机制 Web资源：web resource， 一个网页由多个资源（文件）构成，打开一个页面，通常会有多个资源展示出来，但是每个资源都要单独请求。因此，一个"Web 页面”通常并不是单个资源，而是一组资源的集合
资源类型：
静态文件：无需服务端做出额外处理,服务器端和客户端的文件内容相同
文件后缀：.html, .txt, .jpg, .js, .css, .mp3, .avi 动态文件：服务端执行程序，返回执行的结果,服务器端和客户端的文件内容不相同
文件后缀：.php, .jsp ,.asp 提高HTTP连接性能
并行连接：通过多条TCP连接发起并发的HTTP请求
持久连接：keep-alive，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接
管道化连接：通过共享TCP连接，发起并发的HTTP请求
复用的连接：交替传送请求和响应报文（实验阶段）
1.4版本 0.9/http 只能下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56048809455a63ccbe28b4d2b012f63e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb62cfce91027744246db2f588fae782/" rel="bookmark">
			Linux Web服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web服务 Web服务是Internet应用最流行，最受欢迎的服务之一。它是实现信息发布、资料查询、数据处理、网络办公和远程教育的平台。
一、Web服务简介 Web服务器也称为WWW服务器，主要功能是提供网上信息浏览服务。WWW代表万维网，WWW是Internet的多媒体信息查询工具。起源于1989年3月，由欧洲量子物理实验室CERN（the European Laboratory for Particle Physics）发展出来的主从结构分布式超媒体系统。通过万维网，人们只要使用简单的方法，就可以和迅速、方便地去的丰富的信息资料。
目前的常用的Web服务器有以下几种：
1、Microsoft IIS
IIS（Internet Information Services，互联网信息服务）是由微软公司提供的基于Windows平台的互联网基本服务。是目前流行的Web服务器产品之一。
2、IBM WebSphere
WebSpahere（WebSpahere Application Server）是IBM公司推出的一种功能完善、开放的WEB应用程序服务器，基于Java的应用环境。
3、Apache
Apache（Apache HTTP Server）是一种开放源码的Web服务器软件，可在大多数的操作系统中运行，由于其多平台和安全性被广泛应用。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。是目前流行的Web服务器产品之一。
4、Tomcat
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web 应用服务器
5、Nginx
Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名，是目前流行的Web服务器软件之一。
二、Apache概述 Apache是一种开放源代码的Web服务器软件。因其具有良好的跨平台和安全特性，目前几乎是主流Unix、Linux和BSD系统（如FreeBSD）选用的唯一Web服务器软件。
Apache服务器具有下列功能特性：
（1）简单、速度快、性能稳定、可配置。
（2）静态与动态内容支持。Apache同时支持静态和动态内容。动态内容是由一组相关技术提供的，其中包括SSI、CGI、PHP、Perl以主服务器API等。
（3）模块支持。采用模块化的定制方式，能够动态扩展Apache服务器的功能。软件模块可以直接连接到核心服务器程序，或根据需要动态加载到服务器中。
（4）支持SSL和虚拟主机。采用基于主机名或基于IP地址的虚拟主机技术与概念，利用单个或多个IP地址同时支持多个网站，同时利用SSL支持HTTPS。
（5）日志。Apache具有完整的日志功能，能够定义信息记录的级别，能够把客户机的请求和服务器的相应信息详细地记录到日志文件中。方便管理员用专门程序分析日志文件，收集服务器的使用统计信息。
（6）支持用户认证机制。在访问重要资源前，需要先通过用户和密码认证。
三、Apache服务实践 案例1：
某公司新购一台服务器，服务器上已安装Linux操作系统，现要求将服务器配置成Apache服务器，为公司员工提供基本Web服务。具体要求如下:
（1）启用默认WEB服务的根目录/var/www/html，默认首页为index.html，内容为“Welcome to www.test.com”，使用IP地址和域名均可访问。
（2）在Apache服务器中创建名为/vfolder的虚拟目录，它对应的物理路径是/var/tfolder，虚拟目录默认首页为default.html，内容为“Welcome to www.test.com/vfolder”。
（1）启用默认WEB服务的根目录/var/www/html，默认首页为index.html，内容为“Welcome to www.test.com”，使用IP地址和域名均可访问。
1、实验环境 角色主机名操作系统网卡IP地址备注web服务器webserver.gc.comCentOS7.4vmnet1（仅主机）192.168.92.11虚拟机web客户端webclient.gc.comCentOS7.4vmnet1（仅主机）192.168.92.101虚拟机 2、环境准备 web服务器
[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens32 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none IPADDR=192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb62cfce91027744246db2f588fae782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae78eadcc1dd687af855bffb44e13d7/" rel="bookmark">
			Javascript操作数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、数组方法1.join() 数组 =&gt; 字符串2.push() 数组末尾添加元素，并且返回长度3.pop() 删除数组的最后一个元素并返回删除的元素。4.shift() 删除数组的d第一个元素并返回删除的元素。5.unshift() 数组头部添加元素，并且返回长度6.sort() 数组排序7.reverse() 翻转整个数组并且改变原数组8.concat() 合并数组（不改变原数组并返回新的数组）9.slice() 截取数组（不改变原数组并返回新的数组）10.splice() 删除数组元素11.indexOf() lastIndexOf() 查找数组元素12.forEach()13.map() 返回一个新数组 为原始数组元素`调用函数处理`后的值14.filter() 返回一个新数组 为满足`过滤条件`的值15.every() 返回一个布尔值 所以项满足才为`true`,否则`false`16.some() 返回一个布尔值 有一项满足就为`true`,否则`false`17.includes() 返回一个布尔值 一个数组是否包含一个指定的值18.reduce() 迭代数组的所有项，构建一个`最终返回`的值19.flat() 和 flatMap() es6 新增 HTML 指的是超文本标记语言 (Hyper Text Markup Language)是用来描述网页的一种标记语言，而不是编程语言。
一、数组方法 1.join() 数组 =&gt; 字符串 对应字符串=&gt;数组 split()
var arr = [1,2,3]; console.log(arr.join("-")); // 1-2-3 2.push() 数组末尾添加元素，并且返回长度 3.pop() 删除数组的最后一个元素并返回删除的元素。 var arr = [1,2,3]; console.log(arr.pop()); // 3 4.shift() 删除数组的d第一个元素并返回删除的元素。 var arr = [1,2,3]; console.log(arr.shift()); // 1 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae78eadcc1dd687af855bffb44e13d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08fa7ff222e51395ce57abff97617b59/" rel="bookmark">
			Python Numpy loaded morethan1 DLL from .libs 报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python Numpy loaded morethan1 DLL from .libs 报错解决方案 前言错误记录解决方案1解决方案2 鸣谢 前言 装Pytorch环境的时候遇到两个错误记录一下.
错误记录 C:\Users txsimoson Anaconda3 envs env ovthon 37 lib site-packages numpyl distributor initpy:32: UserWarning; loaded morethan1 DLL from .libs: C:\Uers txsimpson Anaconda3envs env python 3.7 lib site-packages numpyl. ibs libopenblas,YOHXLWVO7VESDPUVUADXEVJ0BGHIPAY.gfortran-win amd64.d11 C:\Users tximoson Anaconda3 envs env pvthon 3.7 lib site-packaees numov ,libs libopenblas,MCDJNK7WMPZ02ME277HJJRJ3JIKNDB7.efortran-win amd64.dll stacklevel=1) 核心问题是
UserWarning; loaded morethan1 DLL from .libs:
解决方案1 重装numpy包
pip uninstall numpy pip install numpy pip install --upgrade numpy 解决方案2 找到Python路径下的Lib\site-packages\numpy\.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08fa7ff222e51395ce57abff97617b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3812bd5f0af5483e16c113f7e6a8102/" rel="bookmark">
			ADBMS1818菊花链通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADBMS1818是一款多通道电池堆监控器，可测量多 达18串电池电压，总测量误差(TME)小于3.0 mV。ADBMS1818具有0V至5V的电池测量范围，适合大多数电池应用。可在290 μs内完成所有18个电池电压测量，并可以选择较低的数据采集速率以实现高降噪抑制。
当电芯数高于18时，可将多个ADBMS1818器件串联，以便同时监测更长 串的高压电池组。每个ADBMS1818都有一个isoSPITM 接口，用于实高速抗干扰局域通信。多个器件以菊 花链形式连接，通过最顶端或底端的器件连接到主 处理器。该菊花链可双向操作，即使通信路径出错，也能确保通信完整性。
ADBMS1818引脚图：
ADBMS1818串联菊花链通信电路可采用容性耦合isoSPI，电路图如下：
同时，ADBMS1818的9个GPIO可以有用来采集电芯温度，S引脚可用来控制被动均衡电路中的MOS管开关。通过软件去配置1818的寄存器进行初始化，再通过发相关指令去读取电芯电压，具体的bsp层驱动可在官网上下载，
下载地址:ADBMS1818 Datasheet and Product Info | Analog Devices.
首先初始化1818的相关寄存器
在官网上下载完成后，在这两个文件夹中的.C\.H都是1818相关的底层驱动，找到配置CFGAR\CFGBR的函数，进行初始化。
#define TOTAL_IC 3 //1818串联个数 static cell_asic BMS_IC[TOTAL_IC]; void ADBMS1818_Task_Init(void) {	ADBMS1818_Reg_Param_Init(); Status_Param_Init(); ADBMS1818_init_cfg(TOTAL_IC, BMS_IC); ADBMS1818_init_cfgb(TOTAL_IC, BMS_IC); ADBMS1818_set_cfg_reg(); ADBMS1818_reset_crc_count(TOTAL_IC, BMS_IC); ADBMS1818_init_reg_limits(TOTAL_IC, BMS_IC); } TOTAL_IC就是ADBMS1818串联的个数，用到多少个，修改宏定义即可；BMS_IC是缓存cell数据的结构体，类型为cell_asic，在官网下载的文件中可找到。
初始完寄存器后，通过数据手册的命令，触发1818ADC转换，以及读取电压值。
#define ADBMS1818_CHIP_MAX_CELL_CHANNELS 18 void ADBMS1818_Sample_Task(void) { #define TASKE_TIME120MS 80 #define TASKE_TIME10MS 20 static T_Sample_Status tADBMS1818Sampling = BIO_TASK_IDLE; static u32 SampleTaskTicker = 0; static u8 TaskTime = TASKE_TIME10MS; E_Bool eState = False; u8 nIc = 0; eState = Ticker_Out(&amp;SampleTaskTicker, (u32)TaskTime);	if(True == eState) { Ticker_Out(&amp;SampleTaskTicker, 0); switch (tADBMS1818Sampling) { case BIO_TASK_IDLE: //初始化寄存器 ADBMS1818_Wakeup_Sleep(TOTAL_IC); Confirm_Ref_On(); Check_Reg_Data(0xFFu); tADBMS1818Sampling = BIO_BAT_MEAS_CMD;	break;	case BIO_BAT_MEAS_CMD: //发生ADC转换命令 ADBMS1818_Wakeup_Sleep(TOTAL_IC); ADBMS1818_adcv(ADC_CONVERSION_MODE, ADC_DCP, CELL_CH_TO_CONVERT); tADBMS1818Sampling = BIO_BAT_WAIT; break; case BIO_BAT_WAIT: tADBMS1818Sampling = BIO_BAT_RD; break; case BIO_BAT_RD://读取电压 ADBMS1818_Wakeup_Sleep(TOTAL_IC); ADBMS1818_rdcv(SEL_ALL_REG, TOTAL_IC, BMS_IC); tADBMS1818Sampling = BIO_TASK_IDLE;	for (nIc = 0; nIc &lt; TOTAL_IC; nIc++) { memcpy(&amp;tAdbms1818InfoBuf[nIc].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3812bd5f0af5483e16c113f7e6a8102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833df562b0564256f44d4464f9ee505f/" rel="bookmark">
			简单两招教会您，电脑怎么录屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例：不会电脑录屏，电脑录屏难不难？ “从来没有尝试过电脑录屏，但是工作上确实有很多东西需要对电脑进行屏幕录制，所以想要学习如何录制电脑屏幕。有小伙伴知道电脑怎么录屏吗？难不难呀，有没有简单的方法？”
在日常工作和学习中，电脑录屏已经成为了一种非常常见的操作。如果您需要在屏幕上进行展示或演示操作，录屏能够让您更加直观地展示您的思路和操作过程。电脑怎么录屏？接下来小编将介绍两种简单的方法，帮助您轻松地录制电脑屏幕。
一、电脑录屏难不难 很多电脑小白觉得电脑上录屏是一件很复杂、很难的事情。电脑录屏怎么录？其实电脑录屏很简单，我们可以借助电脑录屏工具轻松对电脑屏幕进行录制。下文是两种有手就能学会的方法，快来看看吧！
二、电脑怎么录屏（教您两招） 电脑录屏工具有很多，今天小编针对两种录制需求，分别给大家带来了数据蛙录屏软件和QQ录屏这两种电脑录屏工具。
如果您比较注重录屏的质量、想要录制清晰、精美的录屏文件可以了解下文的第1招；如果您只想简单录制、不要在意录屏的质量，可以了解第2招。
电脑录屏第1招、使用数据蛙录屏软件 数据蛙录屏软具有简单易用、功能全面、录制稳定等特点。
温馨提示：数据蛙录屏软件绝大部分功能免费，免费的功能可以满足日常录制需求。
使用数据蛙录屏软件解决电脑怎录屏（推荐指数★★★★☆）
步骤1.电脑怎么录屏Win10？在您的Win10电脑上下载数据蛙录屏软件。
步骤2.选择“视频录制”模式，录制前可以如下图所示从左到右进行基础的录屏设置；如需进一步设置，可以点击下图按钮进入【设置】页面。
备注：这里以“视频录制”为例进行操作，其他录制模式的操作逻辑大致相同。
步骤3.点击REC按钮进行录制，录制结束后，可以对视频进行剪辑，需要点击“完成”按钮结束录制。
电脑录屏第2招、使用QQ录屏 QQ录屏只是QQ这个应用附带的功能，不需要专门再下载一个软件，使用起来比较方便。但是它存在以下缺点：
不能录摄像头、不能录制多种格式的视频；录屏画质很差，录屏观看体验差；录制不稳定；功能太少，仅适合最基础的录制。 使用QQ录屏解决电脑怎么录屏（推荐指数★★☆☆☆）
点击电脑桌面上的QQ，登录账号；按下Ctrl+Alt+S这3个键，直接打开QQ录屏功能；调整录制的内容，开始录制。 看了上述关于电脑怎么录屏的小妙招，您是不是已经学会了电脑录屏的方法了呢？下面小编再给大家补充一下电脑录屏常见的问题。
电脑怎么录屏并保存？录制完成之后，数据蛙录屏软件会自动保存文件（您可以在【设置】页面，自定义文件保存的路径）。QQ录屏结束之后您可以选择直接保存文件，或者另存到其他位置。
电脑怎么录屏截图？在录屏过程中，点击“相机”图标，数据蛙录屏软件可以对录屏的任何一帧进行截图，而QQ录屏不具有此功能。因此需要此功能的小伙伴，可以选择数据蛙录屏软件。
本文介绍了两种方法来录制电脑屏幕，分别是使用数据蛙录屏软件和QQ录屏。电脑怎么录屏？数据蛙录屏软件和QQ录屏都是比较好用的录屏软件，它们都具有操作简单、功能齐全等特点。但是，从使用体验和录制效果上来看，数据蛙录屏软件更加稳定，推荐大家使用数据蛙录屏软件来录制电脑屏幕。
往期回顾：
电脑自带录屏怎么使用？教您2招，快速搞定
3种笔记本录快捷键分享
苹果电脑录屏，掌握这两种方法就足够
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9937032c303d4ab68d0c12077d560af3/" rel="bookmark">
			vue&#43;element UI Excel导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.终端执行命令 npm i xlsx -s 2.script中导入 import FileSaver from "file-saver"; import * as XLSX from "xlsx"; 3.单表头效果图 4.html代码： &lt;div&gt; &lt;el-upload action="/上传文件的接口" :on-change="onChange" :auto-upload="false" :show-file-list="false" accept=".xls, .xlsx" ref="upload" :multiple="true"&gt; &lt;el-button type="warning" icon="el-icon-folder-add"&gt; 导入 &lt;/el-button&gt; &lt;/el-upload&gt; &lt;el-button @click="exportClick" type="primary" icon="el-icon-folder-opened" class="export"&gt; 导出 &lt;/el-button&gt; &lt;/div&gt; &lt;div class="table"&gt; &lt;el-table :data="tableData" border style="width: 100%" id="mainTable"&gt; &lt;el-table-column v-for="item in tableHeader" :key="item.id" :prop="item.prop" :label="item.label" align="center" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column label="操作" align="center" min-width="200px" fixed="right"&gt; &lt;template slot-scope="scope"&gt; &lt;span @click="edit(scope.row.id)" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9937032c303d4ab68d0c12077d560af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34321088228b153e9491529c5029c92/" rel="bookmark">
			ViewModel - Mark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ViewModel 1. 是什么？2. 有什么作用？3. 为什么可以管理UI数据？4. 为什么可以用作Aty-Fgm间通信？5. 为什么横竖屏切换后仍然保持同一对象？5.1 研究 ViewModelProvider获取ViewModel流程5.2 研究 getLastNonConfigurationInstance 流程5.3 研究 Activity.mLastNonConfigurationInstances数据来源5.4 研究横竖屏切换下通过ActivityClientRecord缓存数据ViewModelStore的详情5.5. 总结 6. 生命周期管理6.1 正常构建6.2 横竖屏切换6.3 用户back键退出 1. 是什么？ ViewModel 类是一种业务逻辑或屏幕级状态容器。它用于将状态公开给界面，以及封装相关的业务逻辑。 它的主要优点是，它可以缓存状态，并可在配置更改后持久保留相应状态。这意味着在 activity 之间导航时或进行配置更改后（例如旋转屏幕时），界面将无需重新提取数据。
2. 有什么作用？ 管理UI数据；发生横竖屏切换时仍能保持唯一，避免重复请求数据；Activity - Fragment 间通信 （ViewModel + LiveData）； 3. 为什么可以管理UI数据？ ViewModel + LiveData + ViewBinding，支持在ViewModel中请求数据并做逻辑处理，之后通过LiveData将数据更新通知给ViewBinding，ViewBinding收到数据刷新消息之后刷新UI。 4. 为什么可以用作Aty-Fgm间通信？ 通过ViewModelProvider指定一个Activity构建出来的ViewModel，在Activity生命周期内是唯一的（横竖屏切换后也能保持唯一）
Activity 会实现 ViewModelStoreOwner 的 getViewModelStore 返回 ViewModelStore，ViewModelStore内部有HashMap用于保存在Activity作用域下构建的ViewModel；通过ViewModelProvider获取ViewModel，会先向Activity获取ViewModelStore，然后通过ViewModel的类名作为key从HashMap容器中检查是否存在该ViewModel对象，有就直接拿出来用，没有就通过工厂新建；因此，通过ViewModelProvider获得的Activity的ViewModel，在作用域生命周期内是唯一的（包括横竖屏切换） 5. 为什么横竖屏切换后仍然保持同一对象？ ViewModel 类是一种屏幕级状态容器，即使发生横竖屏切换导致Activity重建，ViewModel都能保持唯一，为什么？猜测是Framework层针对Activity作用域下的全体ViewModel进行了缓存，那是逐个将ViewModel缓存吗？显然不是，通过缓存作用域的ViewModelStore是更好的选择。
下面就来研究怎么个缓存法：
5.1 研究 ViewModelProvider获取ViewModel流程 ViewModelProvider获取ViewModel方式 mainViewModel = ViewModelProvider(MainActivity.this).get(MainViewModel::class.java) ViewModelProvider 构造函数 public ViewModelProvider(@NonNull ViewModelStoreOwner owner) { this(owner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c34321088228b153e9491529c5029c92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7f7cc7de5d8cc0135a017404dcc516/" rel="bookmark">
			总结 | 神经网络训练不收敛或训练失败的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 编者荐语
文章分别从数据方面和模型方面分析了导致模型训练不收敛或失败的原因，数据方面总结了四种可能的原因，模型方面总结了九种可能的问题。除此之外，文章介绍了每种潜在问题的产生后果或现象，并提供了常规做法。
作者丨风影忍着@知乎
链接丨https://zhuanlan.zhihu.com/p/285601835
在面对模型不收敛的时候，首先要保证训练的次数够多。在训练过程中，loss并不是一直在下降，准确率一直在提升的，会有一些震荡存在。只要总体趋势是在收敛就行。若训练次数够多（一般上千次，上万次，或者几十个epoch）没收敛，再考虑采取措施解决。
一、数据与标签方面
1. 没有对数据进行预处理。数据分类标注是否准确？数据是否干净？
2. 没有对数据进行归一化。由于不同评价指标往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。此外，大部分神经网络流程都假设输入输出是在0附近的分布，从权值初始化到激活函数、从训练到训练网络的优化算法。将数据减去均值并除去方差。
3. 样本的信息量太大导致网络不足以fit住整个样本空间。样本少只可能带来过拟合的问题，你看下你的training set上的loss收敛了吗？如果只是validate set上不收敛那就说明overfitting了，这时候就要考虑各种anti-overfit的trick了，比如dropout，SGD，增大minibatch的数量，减少fc层的节点数量，momentum，finetune等。
4. 标签的设置是否正确。
二、模型方面
1. 网络设定不合理。
如果做很复杂的分类任务，却只用了很浅的网络，可能会导致训练难以收敛。应当选择合适的网络，或者尝试加深当前网络。总体来说，网络不是越深越好，开始可以搭建一个3~8层的网络，当这个网络实现的不错时，你可以考虑实验更深的网络来提升精确度。从小网络开始训练意味着更快，并且可以设置不同参数观察对网络的影响而不是简单的堆叠更多层。
2. Learning rate不合适。
如果太大，会造成不收敛，如果太小，会造成收敛速度非常慢。
在自己训练新网络时，可以从0.1开始尝试，如果loss不下降的意思，那就降低，除以10，用0.01尝试，一般来说0.01会收敛，不行的话就用0.001. 学习率设置过大，很容易震荡。不过刚刚开始不建议把学习率设置过小，尤其是在训练的开始阶段。在开始阶段我们不能把学习率设置的太低否则loss不会收敛。
我的做法是逐渐尝试，从0.1,0.08,0.06,0.05 ......逐渐减小直到正常为止。有的时候候学习率太低走不出低估，把冲量提高也是一种方法，适当提高mini-batch值，使其波动不大。
learning rate设大了会带来跑飞（loss突然一直很大）的问题。这个是新手最常见的情况——为啥网络跑着跑着看着要收敛了结果突然飞了呢？可能性最大的原因是你用了relu作为激活函数的同时使用了softmax或者带有exp的函数做分类层的loss函数。
当某一次训练传到最后一层的时候，某一节点激活过度（比如100），那么exp(100)=Inf，发生溢出，bp后所有的weight会变成NAN，然后从此之后weight就会一直保持NAN，于是loss就飞起来辣。如果lr设的过大会出现跑飞再也回不来的情况。这时候你停一下随便挑一个层的weights看一看，很有可能都是NAN了。对于这种情况建议用二分法尝试。0.1~0.0001.不同模型不同任务最优的lr都不一样。
3. 隐层神经元数量错误。
在一些情况下使用过多或过少的神经元数量都会使得网络很难训练。太少的神经元数量没有能力来表达任务，而太多的神经元数量会导致训练缓慢，并且网络很难清除一些噪声。
隐层神经元数量可以从256 到1024中间开始设置，然后可以看看研究人员使用的数字，可以用作参考。如果他们使用的数字与这个大不相同，那么可以想象一下这其中的原理。在决定使用隐层的单元数量之前，最为关键的是考虑你需要通过这个网络表达信息的实际值的最少数量，然后再慢慢增加这个数字。
如果你做回归任务可以考虑使用的神经元数量为输入或输出变量的2到3倍。实际上，与其它因素相比，隐藏单元的数量通常对于神经网络的性能影响相当小。并且在很多情况下，增大所需要隐藏单元的数量仅仅是减慢了训练速度。
4. 错误初始化网络参数。
如果没有正确初始化网络权重，那么网络将不能训练。
通常使用的比较多的初始化权重的方法有‘he’,’lecun’,’xavier’在实际应用中这些方法有非常好的性能而网络偏差通常初始化为0，你可以选择一个最适合你任务的初始化方式。
5. 没有正则化。
正则化典型的就是dropout、加噪声等。即使数据量很大或者你觉得网络不可能出现过拟合，但是对网络进行正则化还是很有必要的。
dropout 通常从设定参数为0.75或0.9开始，根据你认为网络出现过拟合的可能性来调整这个参数。另外，如果你确定这个网络不会出现过拟合，那么可以将参数设定为0.99。正则化不仅仅可以防止过拟合，并且在这个随机过程中，能够加快训练速度以及帮助处理数据中的异常值并防止网络的极端权重配置。对数据扩增也能够实现正则化的效果，最好的避免过拟合的方法就是有大量的训练数据。
6. Batch Size 过大。
Batch size 设置的过大会降低网络的准确度，因为它降低了梯度下降的随机性。另外，在相同情况下batch size 越大那么要达到相同的精确度通常需要训练更多的epoch。
我们可以尝试一些较小的batch size 如 16 ，8 甚至是1。使用较小的batch size 那么一个epoch就可以进行更多次的权值更新。这里有两个好处，第一，可以跳出局部最小点。其二可以表现出更好的泛化性能。
7. 学习率设的不对。
许多深度学习的框架默认开启了gradient clipping ,这个可以处理gradient explosion问题，这个是非常有用的，但是在默认情况下它也很难找到最佳学习率。如果你正确的清理了数据，删除了异常值，以及设定了正确的学习率，那么可以不需要使用gradient clipping，偶尔你也会遇到gradient explosion问题，那么你可以开启gradient clipping。但是，出现这种问题一般情况下表明数据有其它问题，而gradient clipping只是一个临时的解决方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7f7cc7de5d8cc0135a017404dcc516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd2d8fb7f162ac98590e20eac682291/" rel="bookmark">
			Word中公式自动编号及交叉引用：简单、详细、可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、公式自动编号 第一步： "Alt" + "=" 键入所需公式，并在公式输入完成后键入"#"，注意，中间不加空格：
第一步： 选择 “插入” - “文本” - “文档部件” - “域”：
在域设置框中依次选择 “编号”、“listnum” 和 “NumberDefault”，点确定：
此处域选项中可以自定义勾选“列表中级别”，默认是一级列表；“起始值”可以设定编号的初始值。
这个时候可以发现公式后添加了编号值，并按回车：
到此，编号添加完毕。后续公式采用相同的方法，编号值会自动往上加。
二、交叉引用 （配合上面的编号使用） 第一步： 在Word中选择依次 “插入” - “交叉引用”
选项框中引用类型选择 “编号项” ,发现列表中多出一个编号“（1）”，引用内容选择 “段落编号”，点击插入即可。
这个时候，发现 “（1）” 已经被插入至文中，自行在前面加上想要的文字即可。
三、自定义列表样式 如前所述，在插入域的时候，列表样式是可调的。列表名称中 “LegalDefault”、“NumberDefault”、“OutlineDefault”为系统默认，此处的 “Equation” 是我自己添加的，主要是去掉了默认添加编号时的括号。
具体方法为 “开始” - “多级列表” - “定义新的多级列表”
更改下图中关键的两处，“输入编号的格式” 里可以在序号周围添加想要的括号“（）”、“【】”等。“ListNum域列表名” 就是插入域时可以看到的列表里的样式名称（这里取为Equation，见上上图）。
四、根据章节选择公式 如果是根据论文的标题级别，生成带章节的公式，先去看这两个连接：
Word 中利用“多级列表“功能实现章节标题自动编号_多级符号对章名小节名进行自动编号_他人是一面镜子，保持谦虚的态度的博客-CSDN博客
word中按照章节为图表插入题注，生成图表目录、交叉引用_交叉引用 图表_他人是一面镜子，保持谦虚的态度的博客-CSDN博客
步骤： 引用 -- 插入题注 -- 标签（公式）--- 选择从题注中排除标签
选着 编号，根据要求选择想相应的信息（格式、分隔符、章节起始），
当然，公式的 交叉引用和图片、表格一样
根据章节实现自动编号，可借鉴下面的链接：
Word论文中关于章、节、图、表、公式自动编号及引用_word引用章节编号_YHCANDOU的博客-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd2d8fb7f162ac98590e20eac682291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6729d29c225aa802e2fae83c9545f49a/" rel="bookmark">
			AI写代码 GitHub Copilot &#43; Idea 安装和使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、GitHub Copilot订阅服务二、Idea安装Copilot插件三、插件使用四、参考文档 GitHub Copilot 是微软与OpenAI共同推出的一款AI编程工具，基于GitHub及其他网站的源代码，根据上文提示为程序员自动编写下文代码，可以极大地提高编写代码的效率。 根据已有上下文补全代码根据函数名和参数，生成方法体根据注释自动生成代码代码优化生成测试代码 一、GitHub Copilot订阅服务 首先需要一个GitHub账号，没有的参考 GitHub申请账号
进入官网 ，点击申请。前两个月免费试用，第三个月开始付费，每月10 ，每年 100 ，每年100 ，每年100；或者某宝购买，很便宜，不过有概率封禁，建议用小号。
购买完成后，按下图配置，点save保存
二、Idea安装Copilot插件 Idea版本应不低于2021.2，否则无法搜到Copilot插件。
安装后重启，点击右下角图标，登录到GitHub，点击Copy and Open，浏览器会自动打开Copilot的激活页面。
输入复制的设备码，点击Continue按钮
授权页中点击Authorize GitHub Copilot即可激活成功。
三、插件使用 使用方法
四、参考文档 官方文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/503ca919e5c1f00d9141fda800358307/" rel="bookmark">
			如何把Python脚本导出为exe程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意 只能在windows 平台下使用 一.pyinstaller简介 pyinstaller将Python脚本打包成可执行程序，使在没有Python环境的机器上运行
最新版是pyinstaller 3.1.1。支持python2.7和python3.3+。
可运行在Windows，Mac和Linux操作系统下。
但它不是跨编译的，也就是说在Windows下用PyInstaller生成的exe只能运行在Windows下，在Linux下生成的只能运行在Linux下。
二.pyinstaller在windows下的安装 使用命令pip install pyinstaller即可
在windows下，pyinstaller需要PyWin32的支持。当用pip安装pyinstaller时未找到PyWin32，会自动安装pypiwin32
三.打包 打包的app里并不包含任何源码，但将脚本的.pyc文件打包了。
四.小实例（windows下） 写好游戏文件guess_exe.py，代码如下
程序不是关键，重要的是如何打包成exe
注意 只能在windows 平台下使用 就会在当前文件下形成build文件夹、dist文件夹和.spec文件。
dist里就是guess_exe.exe可执行文件。
如果有打包错误，具体看build里的warn*.txt文档，里面详细记载了错误的原因。一般都是库丢失。
spec文件告诉PyInstaller如何去处理脚本。它对脚本名以及大多数pyinstaller的可选参数进行加密。PyInstaller就是通过执行spec文件的内容来build the app。
实在不行就复制下来命令，每次运行就修改一下
“”"
pyinstaller --onefile --nowindowed --icon=" D:\Queena\PyCharmProjects\dist1\computer_three.ico" guess_exe.py “”"
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
三、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4d17112582044bd89294da26cf463c/" rel="bookmark">
			学习Spring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Spring 1.1 简介 1.2 优点 Spring是一个开源的免费的框架(容器)
Spring是一个轻量级的,非入侵式的框架!
控制反转 (IOC) ,面向切面编程(AOP)
支持事务的处理, 对框架整合的支持
总结: Spring就是一个轻量级的控制反转(IOC)和面向切面编程(AOP)的框架!
1.3 组成 1.4 拓展 官网介绍: 现代化的java开发! 基于spring开发!
SpringBoot 一个快速开发的脚手架基于SpringBoot可以快速的开发单个微服务约定大于配置! SpringCloud ​ SpringCloud是基于SpringBoot实现的 因为大多数公司都在使用SpringBoot进行快速开发, 学习SpringBoot的前提,需要完全掌握Spring一级SpringMVC!承上启下的作用!
弊端: 发展了太久之后, 违背了原来的理念!
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UvvEYp0D-1679916395534)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321105450006.png)]
2. IOC理论推导 IOC本质 3. HelloSpring 4. IOC创建对象的方式 使用无参构造创建对象, 默认!假设我们要使用有参构造创建对象! 总结: 在配置文件加载的时候, 容器中管理就已经初始化了!
5.Spring配置 5.1 别名 &lt;!-- 如果使用了别名, --&gt; &lt;alias name="user" alias="userNew"/&gt; 5.2 Bean的配置 5.3 import 6. 依赖注入 6.1 构造器注入 6.2 Set方式注入 依赖注入: Set注入 ​ bean对象创建依赖 容器bean对象中的所有属性, 有 容器来注入!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e4d17112582044bd89294da26cf463c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb59cabc9157ba7a385dcef16d7ac9cd/" rel="bookmark">
			Windows如何开启子系统Linux手把手教(ubuntu22)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows如何开启子系统Linux手把手教
第一步 win + i 开启windows 设置找到应用（也叫卸载和更改程序）
第二步找到程序和功能
第三步启用和关闭Windows功能点进去
第四步选择“适用于Linux的windows 子系统”
第五步重启系统
二、安装Linux Ubuntu22作为Windows10子系统
完成上一步的操作并且重新启动之后，通过左下角的放大镜搜索应用商店（microsoft store)。
打开Microsoft Store，搜索Linux，会出来一些结果，点击需要的版本（根据自己需要选择要安装的Ubuntu版本），我选了最新的22.04LTS，出现安装按钮，最后点击安装按钮，应用商店会自动下载，安装。安装完成会出现打开按钮。
首次安装要求登录，有一个邮箱就行，要求数据在国外处理，同意就好了，如果把windows 更新给关了需要打开，win + r 输入services.msc找到
点击“打开”按钮，Windows终端会弹出，首次安装需要等待几分钟。
安装完成后，需要输入用户名和密码，用户名和密码自行设置即可。
密码看不见，自己记住就好
至此，Windows子系统的安装就已经完成了。默认的Linux子系统不具备图形桌面，全命令行运行模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d8ad91f18f4d397a59beca36888065/" rel="bookmark">
			Vue创建首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上图是要实现的首页界面
一、创建首页页面
1.在前台components里创建Layout.vue组件，作为首页页面。
&lt;template&gt; &lt;div&gt;首页&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 二、配置路由
1.去router下的index.js文件中去配置路由地址
{ path: "/", name: "layout", component: Layout, } 2.把Layout.vue组件引入到router下的index.js文件中
import Layout from "../components/Layout.vue"; 三、搭建首页页面结构
1.搭建首页页面结构
&lt;template&gt; &lt;div&gt; &lt;div class="header"&gt;头&lt;/div&gt; &lt;div class="navbar"&gt;左&lt;/div&gt; &lt;div class="main"&gt;主&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "Layout" } &lt;/script&gt; &lt;style&gt; .header { position: absolute; line-height: 50px; background-color: cornflowerblue; padding: 0px; top: 0px; width: 100%; } .navbar { position: absolute; width: 230px; top: 50px; left: 0px; background-color: rgb(182, 243, 39); height: 100%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2d8ad91f18f4d397a59beca36888065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7ee63b11469d7f2dcb792eb8077f1c/" rel="bookmark">
			vscode配置C/C&#43;&#43;常用插件，亲测好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、VScode插件是什么？二、C++ 常用插件问题总结总结 前言 一、VScode插件是什么？ Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。它内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。Visual Studio Code是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义快捷键、括号匹配和颜色区分、代码片段、代码对比 Diff、GIT命令 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。
VS Code提供强大的扩展，版本更新很及时，功能丰富且强大。而且官网提供了丰富的说明文档和视频等支持。安装扩展以添加新语言、主题、调试器并连接到其他服务。 扩展在单独的进程中运行，不会减慢编辑器的速度。
二、C++ 常用插件问题总结 1&gt; C/C++，必选； 2&gt; C/C++ Extension Pack , C/C++扩展包 ； 3&gt; C/C++ Snippets，C/C++重用代码块; 4&gt; C/C++ Advanced Lint, C/C++静态检测; 5&gt; Better C++ Syntax， C/C++语法高亮； 6&gt; Code Runner， 代码运行; 7&gt; Include AutoComplete， 自动头文件包含; 8&gt; GBKtoUTF8，自动将 GBK 转换为 UTF8; 9&gt; compareit，比较插件，可以用于比较两个文件的差异; 10&gt; TabNine，一款 AI 自动补全插件，强烈推荐，非常好使； 11&gt; C/C++ Themes, C/C++图标颜色主题； 12&gt; Prettier - Code formatter， 自动调整代码格式； 13&gt; vscode-icons，VSCode 图标插件，主要是资源管理器下各个文件夹的图标，喜欢mac风格的可以安装vscode-icons-mac； 14&gt;CMake、 CMake Integration、CMake Language Support、CMake Tools、cmake-format 这几个插件用于在vscode中支持cmake编译。​ 总结 选择合适的插件，能够大大提高开发的速度，工欲善其事,必先利其器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d1011151ecb11b4c58f79128bc12d8/" rel="bookmark">
			使用 Python实现录音功能 (实用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来介绍一个好玩且实用的东西，我们使用python来实现一个录音的功能，废话不多说，让我们直接开始。
安装 使用 PIP 安装 PvRecorder：
pip3 install pvrecorder 查找可用的麦克风 一台计算机可以有多个麦克风, 例如，笔记本电脑有一个内置麦克风，可能还连接了一个耳机， 第一步是找到我们要录音的麦克风。
from pvrecorder import PvRecorder for index, device in enumerate(PvRecorder.get_audio_devices()): print(f"[{index}] {device}") 在 Dell XPS 笔记本电脑上运行上面的代码可以得到：
[0] Monitor of sof-hda-dsp HDMI3/DP3 Output [1] Monitor of sof-hda-dsp HDMI2/DP2 Output [2] Monitor of sof-hda-dsp HDMI1/DP1 Output [3] Monitor of sof-hda-dsp Speaker + Headphones [4] sof-hda-dsp Headset Mono Microphone + Headphones Stereo Microphone [5] sof-hda-dsp Digital Microphone 记下目标麦克风的索引，我们将其传递给 PvRecorder 的构造函数， 不确定时，可以将 -1 传递给构造函数以使用默认麦克风。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d1011151ecb11b4c58f79128bc12d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874cd41590589c82c83443fe2ecd0e1b/" rel="bookmark">
			【已解决】535 Login Fail. Please enter your authorization code to login. More information in http://servi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
这里是小编成长之路的历程，也是小编的学习之路。希望和各位大佬们一起成长！
以下为小编最喜欢的两句话：
要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，山高水远，路远马亡。
一个人为什么要努力？ 我见过最好的答案就是：因为我喜欢的东西都很贵，我想去的地方都很远，我爱的人超完美。因此，小编想说：共勉！ 目录
前言
问题：
问题意思：
解决方法：
方法一：(原因：可能是POP3/SMTP的服务没有开启)
方法二：（原因：可能是你之前申请的授权码过期，需要重新申请）
如何使用SpringBoot发送邮箱
SpringBoot的配置 application.properties
问题： 给邮箱发布邮件时报错535 Login Fail. Please enter your authorization code to login. More information in http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256
问题意思： 535 登入失敗。请输入您的授权码登录。更多信息 http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256
当你点进连接就会进入到QQ邮箱的帮助页面
解决方法： 方法一：(原因：可能是POP3/SMTP的服务没有开启) 登录QQ邮箱 设置===》账户====》POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务
===》查看POP3/SMTP服务是否开启，如果没有开启，就开启并去获取授权码
（注意：获取授权码的时候需要手机辅助验证）
方法二：（原因：可能是你之前申请的授权码过期，需要重新申请） 重复上面的步骤，去获取授权码
如何使用SpringBoot发送邮箱 请看小编这篇博客
SpringBoot三种方法实现定时发送邮件的案例_determine ZandR的博客-CSDN博客
SpringBoot的配置 application.properties # 发件人邮件服务器相关配置 spring.mail.host=smtp.qq.com spring.mail.port=587 # 配置个人QQ账户和密码（这里需要大家修改为自己的QQ账号和密码，密码是加密后的授权码，授权码的获得后继讲解） spring.mail.username=获取授权码的QQ@qq.com spring.mail.password=获取的授权码 spring.mail.default-encoding=UTF-8 # 邮件服务超时时间配置 spring.mail.properties.mail.smtp.connectiontimeout=5000 spring.mail.properties.mail.smtp.timeout=3000 spring.mail.properties.mail.smtp.writetimeout=5000 yam的配置可以根据上面去配置
最后，希望各位大佬多多指教，共同进步！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a55ea128f8e8a286da466e82e238f24/" rel="bookmark">
			群智能优化算法改进-学习策略总结与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		群智能优化算法改进-学习策略总结与分析 一、随机反向学习（Random opposition-based Learning, ROBL）二、准反向学习（Quasi-opposition-based learning）三、准反射学习（Quasi-reflection-based learning）四、动态反向学习五、总结 一、随机反向学习（Random opposition-based Learning, ROBL） 反 向 学 习 策 略 （ Opposition-based Learning, OBL） 是 Tizhoosh H R 等人提出的一种群智能优化算法改进策略，其思想是：在种群寻优的过程中，根据当前解产生一个反向解，比较当前解与反向解的目标函数值，择优进入下一次迭代。 由于反向学习策略生成的反向解与当前解距离为一定值，缺乏随机性，无法有效增强搜索空间内种群多样性。因此，Long W 等人提出了改进的随机反向学习策略（Random Opposition-based Learning, ROBL），计算公式如下：
X r a n d = L B + U B − r ∗ X . Xrand= LB+UB-r*X. Xrand=LB+UB−r∗X.
r为0到1之间的随机数。
二、准反向学习（Quasi-opposition-based learning） Rahnamayan提出了OBL的一种变体，称为准反向学习（QOBL），定义为：
x i o = l b i + u b i − x i .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a55ea128f8e8a286da466e82e238f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af701328b74d100cd4141d59a6f1f6e4/" rel="bookmark">
			vue3学习之路-项目启动自动打开浏览器以及server配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
项目启动自动打开浏览器
server配置的说明
配置server时的报错
vue2项目启动自动打开浏览器的配置
正常情况下，刚创建的项目在执行npm run dev命令后不会自动打开浏览器，为了方便可以设置项目启动自动打开浏览器。
项目启动自动打开浏览器 方法一：
在package.json文件夹下在dev和build命令后面添加--open，重新执行npm run dev命令即可
"scripts": { "dev": "vite --open", "build": "vite build --open", "preview": "vite preview" }, 方法二：
在vite.config.js文件中配置server
export default defineConfig({ plugins: [vue()], server: { host: '127.0.0.1', port: '8888', open: true, https: false }, }) server配置的说明 server: { host: '127.0.0.1',// 指定服务器应该监听哪个 IP 地址 port: '8888', // 指定开发服务器端口 strictPort: false, // 设为 true 时若端口已被占用则会直接退出，而不是尝试下一个可用端口 open: true, // 开发服务器启动时，自动在浏览器中打开应用程序 https: false // 是否开启 https }, ps:关于proxy的配置后面会单独进行说明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af701328b74d100cd4141d59a6f1f6e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85577bc026e1d5bcda35f7f3926f82e6/" rel="bookmark">
			VSCode插件keil编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装插件
VScode中搜索插件Keil Assistant并安装。
二、使用方法
插件下方介绍非常详细，并且都是中文的。
1.插件设置
1.插件设置
进入插件设置，添加Keil可执行文件的路径。
2.打开工程打开资源管理器，会出现KEIL UVISION PROJECT点击后面的打开keil工程按钮，选择你想打开的工程的**.uvprojx**文件。
下方会有编译，下载，重编译按钮。
如果上面没有添加Keil可执行文件的路径(UV4.exe)，这里会报错，不能编译。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7554142d3dbb913800573eb704998f8f/" rel="bookmark">
			Vue基础知识总结 10：使用vue-cli（vue脚手架）快速搭建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
目录
一、什么是VueCLI
1、如果你只是简单写几个Vue的Demo程序，那么你不需要VueCLI脚手架。
2、如果你在开发大型项目，那么你需要，并且必然需要使用VueCLI。
3、CLI是什么意思？
4、脚手架长什么样？
5、脚手架依赖于node.js和webpack
二、安装Vue CLI脚手架
三、runtime-compiler和runtime-only的区别
1、runtime-compiler加载过程
2、runtime-only加载过程：（性能更高，代码更少）
3、小结
4、代码实例
5、npm run build执行过程
6、npm run dev执行过程
四、认识Vue CLI3
1、vue-cli 3 与 vue-cli 2 版本的区别？
2、通过脚手架3构建项目
五、箭头函数
1、定义函数的三种方式
2、箭头函数参数和返回值
3、什么时候使用箭头函数
4、箭头函数与this
六、前端路由vue-router
1、维基百科
2、路由的机制
3、后端渲染
4、后端路由阶段
5、前后端分离
6、单页面富应用阶段
7、SPA页面
8、前端路由
七、改变URL，但是页面不进行整体的刷新
1、URL的hash
2、HTML5的history 一、什么是VueCLI 1、如果你只是简单写几个Vue的Demo程序，那么你不需要VueCLI脚手架。 2、如果你在开发大型项目，那么你需要，并且必然需要使用VueCLI。 使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。如果每个项目都要手动完成这些工作，那么无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。 3、CLI是什么意思？ CLI是Commond-Line Interface，翻译为命令行界面，俗称脚手架。VueCLI是一个官方发布vue.js项目脚手架。使用VueCLI可以快速搭建vue开发环境以及对应的webpack配置。 4、脚手架长什么样？ 5、脚手架依赖于node.js和webpack 二、安装Vue CLI脚手架 //默认安装脚手架3 npm install -g @vue/cli //安装脚手架2 npm install -g @vue/cli-init //脚手架2创建项目 vue init webpack my-project //脚手架3创建项目 vue create my-project 三、runtime-compiler和runtime-only的区别 1、runtime-compiler加载过程 template -&gt; ast -&gt; render -&gt; vdom -&gt; UI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7554142d3dbb913800573eb704998f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e814b9556318a5f17d0ab3b1205619cd/" rel="bookmark">
			Vue基础知识总结 11：前端路由vue-router
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
目录 ​一、前端路由vue-router
1、维基百科
2、路由的机制
3、后端渲染
4、后端路由阶段
​5、前后端分离
6、单页面富应用阶段
7、SPA页面
8、前端路由
二、改变URL，但是页面不进行整体的刷新
​1、URL的hash
2、HTML5的history 三、安装和使用vue-router
1、安装vue-router
2、在模块化工程中使用它（因为它是一个插件，所以可以通过Vue.use()来安装路由功能）
3、使用vue-router的步骤
4、router-link与router-view
5、vue-router代码实例
四、router-link的其它属性补充
五、vue-router动态路由的使用
六、vue-router打包文件的解析
七、路由懒加载
1、什么是懒加载
2、懒加载的方式
3、代码实例
八、路由嵌套
1、嵌套路由是一个很常见的功能
2、实现嵌套路由的两个步骤
3、嵌套路由代码实例
九、vue-router参数传递
1、传递参数主要有两种类型: params和query
2、代码实例
十、vue-router全局导航守卫
1、生命周期函数
2、前置守卫
十一、keep-alive与vue-router
​一、前端路由vue-router 1、维基百科 路由就是通过互联的网络把信息从源地址传输到目的地址的活动。
2、路由的机制 路由包括路由和转发。
路由器 -&gt; 公网IP -&gt; 映射表 -&gt; 内网IP
映射表：[内网ip1:电脑标识1，内网ip2:电脑标识2]
3、后端渲染 JSP：java server page
后端渲染 == html + css + java
java代码的作用是从数据库中读取数据，然后将他们动态的放在页面中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e814b9556318a5f17d0ab3b1205619cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4341c758b29137f1611150ed65caf751/" rel="bookmark">
			Vue基础知识总结 9：vue webpack打包原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
目录
一、前端模块化
二、打包
三、安装webpack
1、安装node.js
2、安装webpack
四、webpack打包js
1、普通打包方式
2、webpack.config.js配置和package.json配置
3、理解开发时依赖和运行时依赖
五、loader
1、loader简介
2、使用 loader
3、配置[Configuration]允许你在 webpack 配置中指定多个 loader
六、less与url-loader
1、安装less
2、less示例
4、url-loader用法
5、file-loader
七、加载图片代码实例
1、项目目录
2、index.html
3、main.js
4、info.js
5、mathUtils.js
6、normal.css
7、special.less
八、ES6语法处理
1、安装babel-loader
2、在 webpack 配置对象中，需要添加 babel-loader 到 module 的 loaders 列表中，
九、webpack使用vue的配置过程
1、安装vue的三种方式
2、npm安装vue
十、el和template区别
1、正常运行之后，我们要考虑一个问题
2、解决方法 --&gt; 定义template属性
十一、认识plugin
1、plugin是什么？
2、loader和plugin的区别？
3、plugin的使用过程
4、代码实例
5、htmlWebpackPlugin
6、第三方插件uglifyjs-webpack-plugin
7、webpack-dev-server搭建本地服务器
一、前端模块化 webpack是让我们可以进行模块化开发，并且会帮助我们处理模块间的依赖关系。
并且不仅仅是JavaScript文件，还有CSS、图片、json文件等等，在webpack中都可以被当做模块来使用。
二、打包 webpack中的各种资源模块进行打包合并成一个或多个包（Bundle）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4341c758b29137f1611150ed65caf751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca6d217d142461ed88711eb9ee873a9/" rel="bookmark">
			微信小程序是什么？如何快速搭建一个微信小程序？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 专栏导读一、微信小程序是什么二、安全管理三、微信小程序的功能四、快速开发一个微信小程序APP1、集成即构实时音视频SDK2、初始化SDK引擎3、创建房间与登录房间4、房主创建房间5、推流与拉流6、拉流预览7、播放实时画面统一封装8、其他工作 五、观众如何得知房主的视频流ID ？1、如何获取房主ID？直播间的商品信息？直播间的名称信息？2、源码分享 专栏导读 🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹篇，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。 🏆全部订阅后，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
🏆面试福音：10万字208道Java经典面试题总结(附答案)。
大家好，我是哪吒。
一、微信小程序是什么 微信小程序是一种不用下载就能使用的应用，也是一项创新，经过将近两年的发展，已经构造了新的微信小程序开发环境和开发者生态。微信小程序也是这么多年来中国IT行业里一个真正能够影响到普通程序员的创新成果，已经有超过150万的开发者加入到了微信小程序的开发，与我们一起共同发力推动微信小程序的发展，微信小程序应用数量超过了一百万，覆盖200多个细分的行业，日活用户达到两个亿，微信小程序还在许多城市实现了支持地铁、公交服务。微信小程序发展带来更多的就业机会，2017年小程序带动就业104万人，社会效应不断提升。
二、安全管理 微信小程序在产品功能设计上给用户更多控制力。在微信小程序的设置页,为用户提供了数据权限开关,一旦用户授权之后又关闭,微信小程序再次使用该用户数据时需要重新获得授权,为用户提供更方便的数据控制权。用户在微信小程序的资料页还可以看到隐私数据保护的提示以及投诉入口。
微信小程序在收集、获取用户数据上,微信小程序坚持“必要+合理”原则。必要是指只有在微信小程序的具体业务中,确实有场景需要获取用户数据的情况下,开发者才能去获取用户的同意授权；合理是指开发者获取数据的范围不应该超出具体场景所需要的数据范围。例如一个提供外卖服务的微信小程序,可能需要获得电话、地址等数据,但没有必要获取性别、年龄等数据,否则平台会认为微信小程序收集用户数据的行为违反了“必要并且合理”的原则,会对这类微信小程序进行处理。
三、微信小程序的功能 微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。对于开发者而言，微信小程序开发门槛相对较低，难度不及APP，能够满足简单的基础应用，适合生活服务类线下商铺以及非刚需低频应用的转换。微信小程序能够实现消息通知、线下扫码、公众号关联等七大功能。其中，通过公众号关联，用户可以实现公众号与微信小程序之间相互跳转。由于微信小程序不存在入口。
四、快速开发一个微信小程序APP 今天以Android版本为例快速实现一个小程序开发APP，一起深入理解整个小程序开发开发流程。我们最终实现效果如下：
按照惯例，为了快速实现，我们继续基于即构实时通话SDK进行开发。在正式开发之前，我们先理一下小程序开发开发流程。
初始化即构SDK，房主创建房间ID，并进入房间。 观众根据房间ID进入房间房主推实时视频流，观众拉实时视频流 1、集成即构实时音视频SDK SDK集成方式请直接参考官方文档https://doc-zh.zego.im/article/195, 这里不过多描述。
2、初始化SDK引擎 这里我们把所有调用即构SDK的API封装到Zego类中，并使用单例模式调用。其中初始化SDK引擎工作放入到构造函数中：
private Zego(Application app) { ZegoEngineProfile profile = new ZegoEngineProfile(); profile.appID = KeyCenter.APPID; profile.scenario = ZegoScenario.GENERAL; // 通用场景接入 profile.application = app; mEngine = ZegoExpressEngine.createEngine(profile, null); } 3、创建房间与登录房间 登录画面如下：
4、房主创建房间 （1）验证房间ID的有效性
在创建房间之前，需要房主提供房间号，当然了，这一步可以由后台自动生成。作为一个Demo，我们暂时让房主自己设置。为了避免房间号冲突，我们需要先验证当前房间号是否已存在，如果有个人服务器自然很轻松判断。如果没有个人服务器，可以调用即构提供的服务器端API接口查询当前房间的人数。
简单来说，使用服务器端API就是访问一个http址，返回对应的JSON参数。
（2）使用ID创建房间并登录
我们将登录房间函数封装到Zego类里面。登录房间代码如下。
注意，无须显式创建房间，如果指定的房间ID不存在，则会自动创建。
public boolean loginRoom(String userId, String userName, String roomId, String token) { ZegoUser user = new ZegoUser(userId, userName); ZegoRoomConfig config = new ZegoRoomConfig(); config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca6d217d142461ed88711eb9ee873a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b4f658cec3f721963d4a0861275d995/" rel="bookmark">
			Java学习路线总结（思维导图篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪
，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
最近也有很多好友在群里问我，Java知识体系庞大，按照什么顺序学习才是最高效的呢？
之前出过一期Java学习路线总结❤️搬砖工逆袭Java架构师❤️（全网最强，建议收藏）
反响很好，很多好友问我，有没有思维导图啊，自学起来没有头绪，丈二和尚摸不着头脑。
本期内容是Java学习路线总结（思维导图版）
目录
一、JavaSE
二、JavaWeb
三、数据库
四、Spring + SpringMVC + MyBatis
五、Spring Boot
六、数据结构与算法
七、JVM
八、Linux
九、SpringCloud
十、中间件
十一、计算机网络
十二、Vue
一、JavaSE 二、JavaWeb 三、数据库 四、Spring + SpringMVC + MyBatis 五、Spring Boot 六、数据结构与算法 七、JVM 八、Linux 九、SpringCloud 十、中间件 十一、计算机网络 十二、Vue 🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪
，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于，Java基础教程系列，目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆姐妹篇，Java基础教程（入门篇），包含面向对象、基本数据类型、数组、继承和多态、泛型、枚举等Java基础知识点。
🏆姐妹进阶篇，Java基础教程（进阶篇），包含Java高并发、Spring、MySQL等Java进阶技术栈。
🏆全部订阅，可加入Java学习星球，完成Java从入门、实战、进阶全方位的Java知识体系学习。
下一篇：【Java基础知识 1】Java入门级概述 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa25befc56ef3dccde674fb5c1e80de/" rel="bookmark">
			k8s是如何实现资源隔离的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道虚拟机使用的是 Hypervisor（KVM、Xen 等），那么，容器是怎么实现和下层计算机硬件和操作系统交互的呢？为什么它会具有高效轻便的隔离特性呢？
其实奥秘就在于 Linux 操作系统内核之中，为资源隔离提供了三种技术：namespace、cgroup、chroot，虽然这三种技术的初衷并不是为了实现容器，但它们三个结合在一起就会发生奇妙的“化学反应”。
namespace 是 2002 年从 Linux 2.4.19 开始出现的，和编程语言里的 namespace 有点类似，它可以创建出独立的文件系统、主机名、进程号、网络等资源空间，相当于给进程盖了一间小板房，这样就实现了系统全局资源和进程局部资源的隔离。
cgroup 是 2008 年从 Linux 2.6.24 开始出现的，它的全称是 Linux Control Group，用来实现对进程的 CPU、内存等资源的优先级和配额限制，相当于给进程的小板房加了一个天花板。
chroot 的历史则要比前面的 namespace、cgroup 要古老得多，早在 1979 年的 UNIX V7 就已经出现了，它可以更改进程的根目录，也就是限制访问文件系统，相当于给进程的小板房铺上了地砖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cebdef3f8f0f4354dee138acdddb8638/" rel="bookmark">
			为什么要用kafka（新手向，含业务场景）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天和一个哥们讨论了一下kafka的性能问题，感觉现在要想干实时项目，还得把kafka捡起来好好学一遍，今天就简单来说一说自己对于kafka的一点了解，也是让自己再重新复习一遍，希望能对各位有所帮助
kafka在业务场景中最重要的功能其实主要就是两个方面：削峰和异步通讯，当然什么解耦呀，减少冗余啊，业务代码的健壮性啊，也是有的，可是生产环境中，主要看的还是削峰和异步通讯这两个方面的功能
一、削峰 先来说一说削峰，削峰的应用场景主要是上游数据某些时候有突发大流量数据，比如电商系统的双十一双十二这种情况，这个时候下游可能扛不住，或者下游没有足够多的机器来保证冗余，这个时候，kafka就可以在中间起到一个缓冲的作用，它可以把消息暂存在kafka中，下游服务就可以按照自己订单节奏进行慢慢处理，这就是所谓的消息中间件，顾名思义嘛
二、异步 说到异步通讯，这里举个简单例子，很多时候，用户不想也不需要立刻处理消息，消息队列就提供了异步处理机制，允许用户把一个消息放入队列，但是并不立即处理，等啥时候需要了再去处理这些消息，这样可以极大程度的缓解性能问题，放到电商的具体下单业务场景中，就是用户从下单到付款这个过程，中间可能会有满减优惠，抵用券折扣，积分累计，金币抵用等等等好多个系统，但是一个请求每经过一个系统都会花费一定的时间（即延长了整个流程的时长），但是实际上用户等不了所有流程都结束才能完成订单，为了加快订单完成的时间，所以可以直接跳过那些流程，直接完成订单，但是直接完成订单并不是就不管那些流程到底完不完成，那些流程也会同时处理，只是相当于多线程完成一样
三、补充 其实在kafka异步通讯过程中，很有可能会出现数据一致性的问题，这个其实是分布式服务本身就存在的一个问题，实际场景中所有的系统流程都成功才能算这一次下单是成功的，所以很多时候需要用到分布式事务，其实就是把下单，优惠券，积分累计，都放在一个事务里面一样，要成功一起成功，要失败一起失败
以上就是工作场景中为啥要用kafka了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b68bd29abb0a0354fd691b7c72fe3e/" rel="bookmark">
			node 安装 ，淘宝镜像配置，webpack 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node 安装
1. 下载
下载 | Node.js 中文网
2.选择和安装
根据自己的操作系统选择下载安装，安装只需要下一步，下一步就可以了；（注意电脑使用习惯，尽量别安装到C盘，选择一个自己的盘符安装各种软件和环境）
3.安装完毕，查看版本和切换淘宝镜像
(1) 按 win+r = 输入cmd =出现命令行界面 =输入 node -v =出现 v14.0.0 (这里是你安装的版本) 这里的操作证明你node 安装成功了
（2）查看自己安使用的镜像地址并切换淘宝镜像 npm config get registry
https://registry.npmjs.org/ 这是国外镜像地址，有时候会比较慢，所以要切换为“淘宝”镜像
输入= npm config set registry https://registry.npm.taobao.org
输入=npm config get registry 查看切换成功了没有；
（4）全局安装 webpack 在DOS命令窗口中输入npm install webpack@3.6.0 -g 安装webpack，其中的-g代表webpack的全局安装方式，那么我们可以在电脑上任意一个终端上面执行webpack指令,稍等一下，别去关闭窗口，之后出现让你可以输入的命令行说明你就安装完成了，
验证是否安装成功： webpack -version 如下图
（5）局部安装webpack
上面是全局安装webpack，你可能会想既然已经全局安装了webpack，那为什么还要局部安装呢，这是因为我们需要的项目可能是从网上下载下来的，项目中使用的webpack和我们本地的webpack可能版本不同，这就需要在局部安装webpack了，不过在此之前需要先生成package.json文件，这需要使用npm init命令，当然在此之前你肯定已经做好了全部的准备，我这里用到的工具是webstrom，在webstrom中的Terminal终端中输入npm install webpack@3.6.0 --save-dev就可以了，其中--save-dev的作用就是在开发时依赖，在项目打包后不会在继续使用的
(6) 使用vue 命令创进行脚手架
解决办法： （1）查看node 安装目录 是否有“vue ” 相关命令 如果没有安装执行下面命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b68bd29abb0a0354fd691b7c72fe3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e43eb65edd4107aa63c1925bb3d8f70/" rel="bookmark">
			c语言计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟简单运算器的工作，可以支持带括号的数学表达式计算，遵循数学运算的优先级规则：
先计算括号内的运算；
其次计算乘除法；
最后计算加减法。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int calc(int num1, int num2, char op) { switch(op) { case '+': return num1 + num2; case '-': return num1 - num2; case '*': return num1 * num2; case '/': return num1 / num2; default: return 0; } } int main() { int num1 = 0, num2 = 0, result = 0; char op = 0; char c = getchar(); // 先读取一个数字 if(c &gt;= '0' &amp;&amp; c &lt;= '9') { num1 = c - '0'; } else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e43eb65edd4107aa63c1925bb3d8f70/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/89/">«</a>
	<span class="pagination__item pagination__item--current">90/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/91/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>