<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HIve中的查询语句 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HIve中的查询语句" />
<meta property="og:description" content="文章目录 Hive中的查询语句1. 基础语法2. 基本查询（Select…From）2.1 数据准备（0）原始数据（1）创建部门表（2）创建员工表（3）导入数据 2.2 全表和特定列查询1）全表查询2）选择特定列查询 2.3 列别名1）为什么要给列起别名？2）如何给列其别名？3）案例实操 2.4 Limit语句2.5 Where语句2.6 关系运算函数2.7 逻辑运算函数1）基本语法（and/or/not）2）案例实操 2.8 聚合函数1）语法2）案例实操 3 分组3.1 Group By语句3.2 Having语句1）having与where不同点2）案例实操 4 Join语句4.1 等值Join4.2 表的别名1）好处2）案例实操 4.3 内连接4.4 左外连接4.5 右外连接4.6 满外连接4.7 多表连接0）数据准备1）创建位置表2）导入数据3）多表连接查询 4.8 笛卡尔集1）笛卡尔集会在下面条件下产生2）案例实操 4.9 联合（union &amp; union all）1）union&amp;union all上下拼接2）案例实操 5 排序5.1 全局排序（Order By）1）使用Order By子句排序2）基础案例实操3）按照别名排序案例实操4）多个列排序案例实操 5.2 每个Reduce内部排序（Sort By）5.3 分区（Distribute By）5.4 分区排序（Cluster By） Hive中的查询语句 1. 基础语法 1）官网地址
https://cwiki.apache.org/confluence/display/Hive/LanguageManual&#43;Select
2）查询语句语法：
SELECT [ALL | DISTINCT] select_expr, select_expr, ... FROM table_reference -- 从什么表查 [WHERE where_condition] -- 过滤 [GROUP BY col_list] -- 分组查询 [HAVING col_list] -- 分组后过滤 [ORDER BY col_list] -- 排序 [CLUSTER BY col_list| [DISTRIBUTE BY col_list] [SORT BY col_list]] [LIMIT number] -- 限制输出的行数 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/0101440c44b3dac961c2e188cd00661c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-04T19:31:22+08:00" />
<meta property="article:modified_time" content="2023-07-04T19:31:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HIve中的查询语句</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Hive_3" rel="nofollow">Hive中的查询语句</a></li><li><ul><li><a href="#1__5" rel="nofollow">1. 基础语法</a></li><li><a href="#2_SelectFrom_24" rel="nofollow">2. 基本查询（Select…From）</a></li><li><ul><li><a href="#21__26" rel="nofollow">2.1 数据准备</a></li><li><ul><li><a href="#0_28" rel="nofollow">（0）原始数据</a></li><li><a href="#1_73" rel="nofollow">（1）创建部门表</a></li><li><a href="#2_86" rel="nofollow">（2）创建员工表</a></li><li><a href="#3_101" rel="nofollow">（3）导入数据</a></li></ul> 
    </li><li><a href="#22__112" rel="nofollow">2.2 全表和特定列查询</a></li><li><ul><li><a href="#1_114" rel="nofollow">1）全表查询</a></li><li><a href="#2_124" rel="nofollow">2）选择特定列查询</a></li></ul> 
    </li><li><a href="#23__146" rel="nofollow">2.3 列别名</a></li><li><ul><li><a href="#1_148" rel="nofollow">1）为什么要给列起别名？</a></li><li><a href="#2_153" rel="nofollow">2）如何给列其别名？</a></li><li><a href="#3_158" rel="nofollow">3）案例实操</a></li></ul> 
    </li><li><a href="#24_Limit_171" rel="nofollow">2.4 Limit语句</a></li><li><a href="#25_Where_188" rel="nofollow">2.5 Where语句</a></li><li><a href="#26__206" rel="nofollow">2.6 关系运算函数</a></li><li><a href="#27__228" rel="nofollow">2.7 逻辑运算函数</a></li><li><ul><li><a href="#1andornot_230" rel="nofollow">1）基本语法（and/or/not）</a></li><li><a href="#2_238" rel="nofollow">2）案例实操</a></li></ul> 
    </li><li><a href="#28__273" rel="nofollow">2.8 聚合函数</a></li><li><ul><li><a href="#1_275" rel="nofollow">1）语法</a></li><li><a href="#2_284" rel="nofollow">2）案例实操</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3__346" rel="nofollow">3 分组</a></li><li><ul><li><a href="#31_Group_By_348" rel="nofollow">3.1 Group By语句</a></li><li><a href="#32_Having_387" rel="nofollow">3.2 Having语句</a></li><li><ul><li><a href="#1havingwhere_389" rel="nofollow">1）having与where不同点</a></li><li><a href="#2_395" rel="nofollow">2）案例实操</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4_Join_432" rel="nofollow">4 Join语句</a></li><li><ul><li><a href="#41_Join_434" rel="nofollow">4.1 等值Join</a></li><li><a href="#42__458" rel="nofollow">4.2 表的别名</a></li><li><ul><li><a href="#1_460" rel="nofollow">1）好处</a></li><li><a href="#2_466" rel="nofollow">2）案例实操</a></li></ul> 
    </li><li><a href="#43__481" rel="nofollow">4.3 内连接</a></li><li><a href="#44__497" rel="nofollow">4.4 左外连接</a></li><li><a href="#45__513" rel="nofollow">4.5 右外连接</a></li><li><a href="#46__529" rel="nofollow">4.6 满外连接</a></li><li><a href="#47__545" rel="nofollow">4.7 多表连接</a></li><li><ul><li><a href="#0_549" rel="nofollow">0）数据准备</a></li><li><a href="#1_565" rel="nofollow">1）创建位置表</a></li><li><a href="#2_577" rel="nofollow">2）导入数据</a></li><li><a href="#3_585" rel="nofollow">3）多表连接查询</a></li></ul> 
    </li><li><a href="#48__605" rel="nofollow">4.8 笛卡尔集</a></li><li><ul><li><a href="#1_607" rel="nofollow">1）笛卡尔集会在下面条件下产生</a></li><li><a href="#2_615" rel="nofollow">2）案例实操</a></li></ul> 
    </li><li><a href="#49_union__union_all_628" rel="nofollow">4.9 联合（union &amp; union all）</a></li><li><ul><li><a href="#1unionunion_all_630" rel="nofollow">1）union&amp;union all上下拼接</a></li><li><a href="#2_640" rel="nofollow">2）案例实操</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5__658" rel="nofollow">5 排序</a></li><li><ul><li><a href="#51_Order_By_660" rel="nofollow">5.1 全局排序（Order By）</a></li><li><ul><li><a href="#1Order_By_664" rel="nofollow">1）使用Order By子句排序</a></li><li><a href="#2_670" rel="nofollow">2）基础案例实操</a></li><li><a href="#3_698" rel="nofollow">3）按照别名排序案例实操</a></li><li><a href="#4_716" rel="nofollow">4）多个列排序案例实操</a></li></ul> 
    </li><li><a href="#52_ReduceSort_By_735" rel="nofollow">5.2 每个Reduce内部排序（Sort By）</a></li><li><a href="#53_Distribute_By_781" rel="nofollow">5.3 分区（Distribute By）</a></li><li><a href="#54_Cluster_By_813" rel="nofollow">5.4 分区排序（Cluster By）</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 
<img src="https://images2.imgbox.com/34/35/7823flDS_o.jpg" alt=""> 
<p></p> 
<h2><a id="Hive_3"></a>Hive中的查询语句</h2> 
<h3><a id="1__5"></a>1. 基础语法</h3> 
<p>1）官网地址</p> 
<p>https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select</p> 
<p>2）查询语句语法：</p> 
<pre><code class="prism language-hive">SELECT [ALL | DISTINCT] select_expr, select_expr, ...
  FROM table_reference       -- 从什么表查
  [WHERE where_condition]    -- 过滤
  [GROUP BY col_list]        -- 分组查询
  [HAVING col_list]          -- 分组后过滤
  [ORDER BY col_list]        -- 排序
  [CLUSTER BY col_list| [DISTRIBUTE BY col_list] [SORT BY col_list]]
  [LIMIT number]                -- 限制输出的行数
</code></pre> 
<h3><a id="2_SelectFrom_24"></a>2. 基本查询（Select…From）</h3> 
<h4><a id="21__26"></a>2.1 数据准备</h4> 
<h5><a id="0_28"></a>（0）原始数据</h5> 
<p>①在/opt/module/datas/路径上创建dept.txt文件</p> 
<pre><code class="prism language-sh">vim dept.txt
</code></pre> 
<p>并赋值如下内容：</p> 
<p>部门编号 部门名称 部门位置id</p> 
<pre><code>10	行政部	1700
20	财务部	1800
30	教学部	1900
40	销售部	1700
</code></pre> 
<p>②在/opt/module/datas/路径上创建emp.txt文件</p> 
<pre><code class="prism language-sh">vim emp.txt
</code></pre> 
<p>并赋值如下内容：<br> 员工编号 姓名 岗位 薪资 部门</p> 
<pre><code>7369	张三	研发	800.00	30
7499	李四	财务	1600.00	20
7521	王五	行政	1250.00	10
7566	赵六	销售	2975.00	40
7654	侯七	研发	1250.00	30
7698	马八	研发	2850.00	30
7782	金九	\N	2450.0	30
7788	银十	行政	3000.00	10
7839	小芳	销售	5000.00	40
7844	小明	销售	1500.00	40
7876	小李	行政	1100.00	10
7900	小元	讲师	950.00	30
7902	小海	行政	3000.00	10
7934	小红明	讲师	1300.00	30
</code></pre> 
<h5><a id="1_73"></a>（1）创建部门表</h5> 
<pre><code class="prism language-hive">create table if not exists dept(
    deptno int,    -- 部门编号
    dname string,  -- 部门名称
    loc int        -- 部门位置
)
row format delimited fields terminated by '\t';
</code></pre> 
<p><img src="https://images2.imgbox.com/5c/ca/EHduPWsX_o.png" alt="image-20230608144109210"></p> 
<h5><a id="2_86"></a>（2）创建员工表</h5> 
<pre><code class="prism language-hive">create table if not exists emp(
    empno int,      -- 员工编号
    ename string,   -- 员工姓名
    job string,     -- 员工岗位（大数据工程师、前端工程师、java工程师）
    sal double,     -- 员工薪资
    deptno int      -- 部门编号
)
row format delimited fields terminated by '\t';
</code></pre> 
<p><img src="https://images2.imgbox.com/0b/ca/dtEOc3Er_o.png" alt="image-20230608144154083"></p> 
<h5><a id="3_101"></a>（3）导入数据</h5> 
<pre><code class="prism language-hive">load data local inpath '/opt/module/datas/dept.txt' into table dept;
load data local inpath '/opt/module/datas/emp.txt' into table emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/1d/9a/zUGFwrkI_o.png" alt="image-20230608144353976"></p> 
<blockquote> 
 <p>注意：路径要正确。</p> 
</blockquote> 
<h4><a id="22__112"></a>2.2 全表和特定列查询</h4> 
<h5><a id="1_114"></a>1）全表查询</h5> 
<p>查询表中的所有数据：</p> 
<pre><code class="prism language-hive">select * from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/2e/7f/abwr2Zq8_o.png" alt="image-20230608144542990"></p> 
<h5><a id="2_124"></a>2）选择特定列查询</h5> 
<p>查询员工表的员工编号、员工姓名字段：</p> 
<pre><code class="prism language-hive">select empno, ename from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/59/73/9W9JwuXt_o.png" alt="image-20230608150602270"></p> 
<p>注意：</p> 
<p>（1）SQL 语言大小写不敏感。</p> 
<p>（2）SQL 可以写在一行或者多行。</p> 
<p>（3）关键字不能被缩写也不能分行。</p> 
<p>（4）各子句一般要分行写。</p> 
<p>（5）使用缩进提高语句的可读性。</p> 
<h4><a id="23__146"></a>2.3 列别名</h4> 
<h5><a id="1_148"></a>1）为什么要给列起别名？</h5> 
<ul><li>便于理解</li><li>如果查询的字段有重名的情况，可以用起别名的方法来区分</li></ul> 
<h5><a id="2_153"></a>2）如何给列其别名？</h5> 
<ul><li>SELECT 字段 AS 别名 FROM 表名;</li><li>SELECT 字段 别名 FROM 表名;</li></ul> 
<h5><a id="3_158"></a>3）案例实操</h5> 
<p>查询名称和部门。</p> 
<pre><code class="prism language-hive">select 
    ename AS name, 
    deptno dn 
from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/64/b6/m5uh7Da8_o.png" alt="image-20230608151449753"></p> 
<h4><a id="24_Limit_171"></a>2.4 Limit语句</h4> 
<p>典型的查询会返回多行数据。limit子句用于限制返回的行数。</p> 
<pre><code class="prism language-hive"># 查看前5条数据
select * from emp limit 5;
</code></pre> 
<p><img src="https://images2.imgbox.com/28/85/WPEQVhRk_o.png" alt="image-20230608152223392"></p> 
<pre><code class="prism language-hive">select * from emp limit 2,3; -- 表示从第2行开始，向下抓取3行
</code></pre> 
<p><img src="https://images2.imgbox.com/42/ec/1NhDSg8P_o.png" alt="image-20230608152417876"></p> 
<h4><a id="25_Where_188"></a>2.5 Where语句</h4> 
<p>使用where子句，将不满足条件的行过滤掉。</p> 
<p>案例：查询出薪水大于1000的所有员工。</p> 
<pre><code class="prism language-hive">select * from emp where sal &gt; 1000;
</code></pre> 
<p><img src="https://images2.imgbox.com/34/5f/oyT9vVsl_o.png" alt="image-20230608152632015"></p> 
<blockquote> 
 <p>注意：where子句中不能使用字段别名。</p> 
 <p>在Hive中，不能在 WHERE 子句中直接使用字段别名，这是因为 Hive 的语法顺序限制了 WHERE 子句的启动时间早于 SELECT 子句中列别名的解析时间，所以在 WHERE 子句中，列别名是未知的。</p> 
 <p>可以使用子查询或者使用HAVING子句替代在 WHERE 子句中使用字段别名的方法。</p> 
</blockquote> 
<h4><a id="26__206"></a>2.6 关系运算函数</h4> 
<p>1）基本语法</p> 
<p>如下操作符主要用于where和having语句中。</p> 
<table><thead><tr><th>操作符</th><th>支持的数据类型</th><th>描述</th></tr></thead><tbody><tr><td>A=B</td><td>基本数据类型</td><td>如果A等于B则返回true，反之返回false</td></tr><tr><td>A&lt;=&gt;B</td><td>基本数据类型</td><td>如果A和B都为null或者都不为null，则返回true，<br>如果只有一边为null，返回false</td></tr><tr><td>A&lt;&gt;B, A!=B</td><td>基本数据类型</td><td>A或者B为null则返回null；<br>如果A不等于B，则返回true，反之返回false</td></tr><tr><td>A&lt;B</td><td>基本数据类型</td><td>A或者B为null，则返回null；<br>如果A小于B，则返回true，反之返回false</td></tr><tr><td>A&lt;=B</td><td>基本数据类型</td><td>A或者B为null，则返回null；<br>如果A小于等于B，则返回true，反之返回false</td></tr><tr><td>A&gt;B</td><td>基本数据类型</td><td>A或者B为null，则返回null；<br>如果A大于B，则返回true，反之返回false</td></tr><tr><td>A&gt;=B</td><td>基本数据类型</td><td>A或者B为null，则返回null；<br>如果A大于等于B，则返回true，反之返回false</td></tr><tr><td>A [not] between B and C</td><td>基本数据类型</td><td>如果A，B或者C任一为null，则结果为null。<br>如果A的值大于等于B而且小于或等于C，则结果为true，反之为false。<br>如果使用not关键字则可达到相反的效果。</td></tr><tr><td>A is null</td><td>所有数据类型</td><td>如果A等于null，则返回true，反之返回false</td></tr><tr><td>A is not null</td><td>所有数据类型</td><td>如果A不等于null，则返回true，反之返回false</td></tr><tr><td>in（数值1，数值2）</td><td>所有数据类型</td><td>使用 in运算显示列表中的值</td></tr><tr><td>A [not] like B</td><td>string 类型</td><td>B是一个SQL下的简单正则表达式，也叫通配符模式，<br>如果A与其匹配的话，则返回true；反之返回false。<br>B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母‘x’结尾，而‘%x%’表示A包含有字母‘x’,可以位于开头，结尾或者字符串中间。<br>如果使用not关键字则可达到相反的效果。</td></tr><tr><td>A rlike B, A regexp B</td><td>string 类型</td><td>B是基于java的正则表达式，如果A与其匹配，则返回true；反之返回false。<br>匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。<br>例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。</td></tr></tbody></table> 
<h4><a id="27__228"></a>2.7 逻辑运算函数</h4> 
<h5><a id="1andornot_230"></a>1）基本语法（and/or/not）</h5> 
<table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>and</td><td>逻辑并</td></tr><tr><td>or</td><td>逻辑或</td></tr><tr><td>not</td><td>逻辑否</td></tr></tbody></table> 
<h5><a id="2_238"></a>2）案例实操</h5> 
<p>（1）查询薪水大于1000，部门是30</p> 
<pre><code class="prism language-hive">select 
    * 
from emp 
where sal &gt; 1000 and deptno = 30;
</code></pre> 
<p><img src="https://images2.imgbox.com/8f/a7/b4MdqJUQ_o.png" alt="image-20230608153239467"></p> 
<p>（2）查询薪水大于1000，或者部门是30</p> 
<pre><code class="prism language-hive">select 
    * 
from emp 
where sal&gt;1000 or deptno=30;
</code></pre> 
<p><img src="https://images2.imgbox.com/af/33/KRvnm7Wy_o.png" alt="image-20230608153333184"></p> 
<p>（3）查询除了20部门和30部门以外的员工信息</p> 
<pre><code class="prism language-hive">select 
    * 
from emp 
where deptno not in(30, 20);
</code></pre> 
<p><img src="https://images2.imgbox.com/56/e6/4rc6omGv_o.png" alt="image-20230608153614804"></p> 
<h4><a id="28__273"></a>2.8 聚合函数</h4> 
<h5><a id="1_275"></a>1）语法</h5> 
<ul><li>count(*)，表示统计所有行数，包含null值；</li><li>count(某列)，表示该列一共有多少行，不包含null值；</li><li>max()，求最大值，不包含null，除非所有值都是null；</li><li>min()，求最小值，不包含null，除非所有值都是null；</li><li>sum()，求和，不包含null。</li><li>avg()，求平均值，不包含null。</li></ul> 
<h5><a id="2_284"></a>2）案例实操</h5> 
<p>（1）求总行数（count）</p> 
<pre><code class="prism language-hive">select count(*) cnt from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/ed/ae/eFj0ofvo_o.png" alt="image-20230608154350146"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/3f/e5/NXORGxHW_o.png" alt="image-20230608154258185"></p> 
<p>（2）求工资的最大值（max）</p> 
<pre><code class="prism language-hive">select max(sal) max_sal from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/20/6c/4lCGP1L4_o.png" alt="image-20230608154447679"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/c6/5c/zeBPBZxg_o.png" alt="image-20230608154514163"></p> 
<p>（3）求工资的最小值（min）</p> 
<pre><code class="prism language-hive">select min(sal) min_sal from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/6e/af/wR85KMgL_o.png" alt="image-20230608154604732"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/e6/19/iQYUULQC_o.png" alt="image-20230608154620449"></p> 
<p>（4）求工资的总和（sum）</p> 
<pre><code class="prism language-hive">select sum(sal) sum_sal from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/38/06/4EpwgiV7_o.png" alt="image-20230608154656559"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/07/45/jXEx5pkx_o.png" alt="image-20230608154840484"></p> 
<p>（5）求工资的平均值（avg）</p> 
<pre><code class="prism language-hive">select avg(sal) avg_sal from emp;
</code></pre> 
<p><img src="https://images2.imgbox.com/91/ff/V0YeaD4b_o.png" alt="image-20230608154955973"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/27/1f/j8KQY2xI_o.png" alt="image-20230608154916073"></p> 
<h3><a id="3__346"></a>3 分组</h3> 
<h4><a id="31_Group_By_348"></a>3.1 Group By语句</h4> 
<p>Group By语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</p> 
<p>1）案例实操：</p> 
<p>（1）计算emp表每个部门的平均工资。</p> 
<pre><code class="prism language-hive">select 
    t.deptno, 
    avg(t.sal) avg_sal 
from emp t 
group by t.deptno;
</code></pre> 
<p><img src="https://images2.imgbox.com/ac/f6/bhGd0PZh_o.png" alt="image-20230608155249107"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/b8/20/XolxxBg2_o.png" alt="image-20230608155410550"></p> 
<p>（2）计算emp每个部门中每个岗位的最高薪水。</p> 
<pre><code class="prism language-hive">select 
    t.deptno, 
    t.job, 
    max(t.sal) max_sal 
from emp t 
group by t.deptno, t.job;
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/42/VRJt2CFB_o.png" alt="image-20230608155552045"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/88/b6/R6pFColQ_o.png" alt="image-20230608155636311"></p> 
<h4><a id="32_Having_387"></a>3.2 Having语句</h4> 
<h5><a id="1havingwhere_389"></a>1）having与where不同点</h5> 
<p>（1）where后面不能写分组聚合函数，而having后面可以使用分组聚合函数。</p> 
<p>（2）having只用于group by分组统计语句。</p> 
<h5><a id="2_395"></a>2）案例实操</h5> 
<p>（1）求每个部门的平均薪水大于2000的部门</p> 
<p>①求每个部门的平均工资。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> 
    deptno<span class="token punctuation">,</span> 
    <span class="token function">avg</span><span class="token punctuation">(</span>sal<span class="token punctuation">)</span> 
<span class="token keyword">from</span> emp 
<span class="token keyword">group</span> <span class="token keyword">by</span> deptno<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/4a/0cXrv8hE_o.png" alt="image-20230608160926916"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/7d/ef/UnZ9RKeN_o.png" alt="image-20230608160756356"></p> 
<p>②求每个部门的平均薪水大于2000的部门。</p> 
<pre><code class="prism language-hive">select 
    deptno, 
    avg(sal) avg_sal 
from emp 
group by deptno  
having avg_sal &gt; 2000;
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/8c/W6qzA8TD_o.png" alt="image-20230608161009619"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/d5/c0/uSa2pzEx_o.png" alt="image-20230608161028488"></p> 
<h3><a id="4_Join_432"></a>4 Join语句</h3> 
<h4><a id="41_Join_434"></a>4.1 等值Join</h4> 
<p>Hive支持通常的sql join语句，但是只支持等值连接，不支持非等值连接。</p> 
<p>1）案例实操</p> 
<p>（1）根据员工表和部门表中的部门编号相等，查询员工编号、员工名称和部门名称。</p> 
<pre><code class="prism language-hive">select 
    e.empno, 
    e.ename, 
    d.dname 
from emp e 
join dept d 
on e.deptno = d.deptno;
</code></pre> 
<p><img src="https://images2.imgbox.com/b1/49/tbfvDfEP_o.png" alt="image-20230608162724736"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/a6/78/kElmc1Wk_o.png" alt="image-20230608162652364"></p> 
<h4><a id="42__458"></a>4.2 表的别名</h4> 
<h5><a id="1_460"></a>1）好处</h5> 
<p>（1）使用别名可以简化查询。</p> 
<p>（2）区分字段的来源。</p> 
<h5><a id="2_466"></a>2）案例实操</h5> 
<p>合并员工表和部门表。</p> 
<pre><code class="prism language-hive">select 
    e.*,
    d.* 
from emp e 
join dept d 
on e.deptno = d.deptno;
</code></pre> 
<p><img src="https://images2.imgbox.com/1c/c1/azvNABSm_o.png" alt="image-20230608163104575"></p> 
<h4><a id="43__481"></a>4.3 内连接</h4> 
<p>内连接：只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</p> 
<pre><code class="prism language-hive">select 
    e.empno, 
    e.ename, 
    d.deptno 
from emp e 
join dept d 
on e.deptno = d.deptno;
</code></pre> 
<p><img src="https://images2.imgbox.com/96/90/YtNPYbWM_o.png" alt="image-20230608163431041"></p> 
<h4><a id="44__497"></a>4.4 左外连接</h4> 
<p>左外连接：join操作符左边表中符合where子句的所有记录将会被返回。</p> 
<pre><code class="prism language-hive">select 
    e.empno, 
    e.ename, 
    d.deptno 
from emp e 
left join dept d 
on e.deptno = d.deptno;
</code></pre> 
<p><img src="https://images2.imgbox.com/92/e6/QMEmdfrF_o.png" alt="image-20230608163512745"></p> 
<h4><a id="45__513"></a>4.5 右外连接</h4> 
<p>右外连接：join操作符右边表中符合where子句的所有记录将会被返回。</p> 
<pre><code class="prism language-hive">select 
    e.empno, 
    e.ename, 
    d.deptno 
from emp e 
right join dept d 
on e.deptno = d.deptno;
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/70/Xsdcczra_o.png" alt="image-20230608163641652"></p> 
<h4><a id="46__529"></a>4.6 满外连接</h4> 
<p>满外连接：将会返回所有表中符合where语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用null值替代。</p> 
<pre><code class="prism language-hive">select 
    e.empno, 
    e.ename, 
    d.deptno 
from emp e 
full join dept d 
on e.deptno = d.deptno;
</code></pre> 
<p><img src="https://images2.imgbox.com/0e/0b/8lE4T3YZ_o.png" alt="image-20230608163733179"></p> 
<h4><a id="47__545"></a>4.7 多表连接</h4> 
<p>注意：连接n个表，至少需要n-1个连接条件。例如：连接三个表，至少需要两个连接条件。</p> 
<h5><a id="0_549"></a>0）数据准备</h5> 
<p>在/opt/module/datas/下：</p> 
<pre><code class="prism language-hive">vim location.txt
</code></pre> 
<p>部门位置id 部门位置</p> 
<pre><code>1700	北京
1800	上海
1900	深圳
</code></pre> 
<h5><a id="1_565"></a>1）创建位置表</h5> 
<pre><code class="prism language-hive">create table if not exists location(
    loc int,           -- 部门位置id
    loc_name string   -- 部门位置
)
row format delimited fields terminated by '\t';
</code></pre> 
<p><img src="https://images2.imgbox.com/cd/3e/vf5cIEvJ_o.png" alt="image-20230608163943916"></p> 
<h5><a id="2_577"></a>2）导入数据</h5> 
<pre><code class="prism language-hive">load data local inpath '/opt/module/datas/location.txt' into table location;
</code></pre> 
<p><img src="https://images2.imgbox.com/6b/e7/TCmXIry7_o.png" alt="image-20230608164034082"></p> 
<h5><a id="3_585"></a>3）多表连接查询</h5> 
<pre><code class="prism language-hive">select 
    e.ename, 
    d.dname, 
    l.loc_name
from emp e 
join dept d
on d.deptno = e.deptno 
join location l
on d.loc = l.loc;
</code></pre> 
<p><img src="https://images2.imgbox.com/d7/90/IoMD3tRq_o.png" alt="image-20230608164130150"></p> 
<p>大多数情况下，Hive会对每对join连接对象启动一个MapReduce任务。本例中会首先启动一个MapReduce job对表e和表d进行连接操作，然后会再启动一个MapReduce job将第一个MapReduce job的输出和表l进行连接操作。</p> 
<p>注意：为什么不是表d和表l先进行连接操作呢？这是因为Hive总是按照从左到右的顺序执行的。</p> 
<h4><a id="48__605"></a>4.8 笛卡尔集</h4> 
<h5><a id="1_607"></a>1）笛卡尔集会在下面条件下产生</h5> 
<p>（1）省略连接条件</p> 
<p>（2）连接条件无效</p> 
<p>（3）所有表中的所有行互相连接</p> 
<h5><a id="2_615"></a>2）案例实操</h5> 
<pre><code class="prism language-hive">select 
    empno, 
    dname 
from emp, dept;
</code></pre> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/ba/98/u5BK13fY_o.png" alt="image-20230608164508862"></p> 
<h4><a id="49_union__union_all_628"></a>4.9 联合（union &amp; union all）</h4> 
<h5><a id="1unionunion_all_630"></a>1）union&amp;union all上下拼接</h5> 
<p>union和union all都是上下拼接sql的结果，这点是和join有区别的，join是左右关联，union和union all是上下拼接。union去重，union all不去重。</p> 
<p>union和union all在上下拼接sql结果时有两个要求：</p> 
<p>（1）两个sql的结果，列的个数必须相同</p> 
<p>（2）两个sql的结果，上下所对应列的类型必须一致</p> 
<h5><a id="2_640"></a>2）案例实操</h5> 
<p>将员工表30部门的员工信息和40部门的员工信息，利用union进行拼接显示。</p> 
<pre><code class="prism language-hive">select 
    *
from emp
where deptno=30
union
select 
    *
from emp
where deptno=40;
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/46/gBwtFpvu_o.png" alt="image-20230608164706981"></p> 
<h3><a id="5__658"></a>5 排序</h3> 
<h4><a id="51_Order_By_660"></a>5.1 全局排序（Order By）</h4> 
<p>Order By：全局排序，只有一个Reduce。</p> 
<h5><a id="1Order_By_664"></a>1）使用Order By子句排序</h5> 
<p>asc（ascend）：升序（默认）</p> 
<p>desc（descend）：降序</p> 
<h5><a id="2_670"></a>2）基础案例实操</h5> 
<p>（1）查询员工信息按工资升序排列</p> 
<pre><code class="prism language-hive">select 
    * 
from emp 
order by sal;
</code></pre> 
<p><img src="https://images2.imgbox.com/bf/61/ZEUnQFcW_o.png" alt="image-20230608164937647"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/9d/0f/zoqCBqQr_o.png" alt="image-20230608164955092"></p> 
<p>（2）查询员工信息按工资降序排列</p> 
<pre><code class="prism language-hive">select 
    * 
from emp 
order by sal desc;
</code></pre> 
<p><img src="https://images2.imgbox.com/7e/fb/dCLXnoHx_o.png" alt="image-20230608165052926"></p> 
<h5><a id="3_698"></a>3）按照别名排序案例实操</h5> 
<p>按照员工薪水的2倍排序。</p> 
<pre><code class="prism language-hive">select 
    ename, 
    sal * 2 twosal 
from emp 
order by twosal;
</code></pre> 
<p><img src="https://images2.imgbox.com/b5/21/xK4fTyFz_o.png" alt="image-20230608165144497"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/45/eb/ErrhTm8O_o.png" alt="image-20230608165201111"></p> 
<h5><a id="4_716"></a>4）多个列排序案例实操</h5> 
<p>按照部门和工资升序排序。</p> 
<pre><code class="prism language-hive">select 
    ename, 
    deptno, 
    sal 
from emp 
order by deptno, sal;
</code></pre> 
<p><img src="https://images2.imgbox.com/eb/18/jDjK1Wyq_o.png" alt="image-20230608165259907"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/b9/0f/Ms5QcxEY_o.png" alt="image-20230608165320257"></p> 
<h4><a id="52_ReduceSort_By_735"></a>5.2 每个Reduce内部排序（Sort By）</h4> 
<p>Sort By：对于大规模的数据集order by的效率非常低。在很多情况下，并不需要全局排序，此时可以使用Sort by。</p> 
<p>Sort by为每个reduce产生一个排序文件。每个Reduce内部进行排序，对全局结果集来说不是排序。</p> 
<p>1）查看默认reduce个数</p> 
<pre><code class="prism language-hive">set mapreduce.job.reduces;
</code></pre> 
<p><img src="https://images2.imgbox.com/11/05/QSMMQMHS_o.png" alt="image-20230608165501024"></p> 
<p>2）设置reduce个数</p> 
<pre><code class="prism language-hive">set mapreduce.job.reduces=3;
</code></pre> 
<p><img src="https://images2.imgbox.com/e4/b8/KA2UxbFO_o.png" alt="image-20230608165748772"></p> 
<p>3）根据部门编号降序查看员工信息</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> 
    <span class="token operator">*</span> 
<span class="token keyword">from</span> emp 
sort <span class="token keyword">by</span> deptno <span class="token keyword">desc</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/d7/tqd0AQXN_o.png" alt="image-20230608165911169"></p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/d3/c1/tYbXCw2Y_o.png" alt="image-20230608165926193"></p> 
<p>4）将查询结果导入到文件中（按照部门编号降序排序）</p> 
<pre><code class="prism language-sql"><span class="token keyword">insert</span> overwrite <span class="token keyword">local</span> directory <span class="token string">'/opt/module/datas/sortby-result'</span>
 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp sort <span class="token keyword">by</span> deptno <span class="token keyword">desc</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/80/7e/AKtO6XyC_o.png" alt="image-20230608172117134"></p> 
<h4><a id="53_Distribute_By_781"></a>5.3 分区（Distribute By）</h4> 
<p>Distribute By：在有些情况下，我们需要控制某个特定行应该到哪个Reducer，通常是为了进行后续的聚集操作。distribute by子句可以做这件事。distribute by类似MapReduce中partition（自定义分区），进行分区，结合sort by使用。</p> 
<p>对于distribute by进行测试，一定要分配多reduce进行处理，否则无法看到distribute by的效果。</p> 
<p>案例实操：先按照部门编号分区，再按照员工编号薪资排序</p> 
<pre><code class="prism language-sql"><span class="token keyword">set</span> mapreduce<span class="token punctuation">.</span>job<span class="token punctuation">.</span>reduces<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>

<span class="token keyword">insert</span> overwrite <span class="token keyword">local</span> directory 
<span class="token string">'/opt/module/datas/distribute-result'</span> 
<span class="token keyword">select</span> 
    <span class="token operator">*</span> 
<span class="token keyword">from</span> emp 
distribute <span class="token keyword">by</span> deptno 
sort <span class="token keyword">by</span> sal <span class="token keyword">desc</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/17/b5/JgkaAei8_o.png" alt="image-20230608172216819"></p> 
<p>注意：</p> 
<ul><li>distribute by的分区规则是根据分区字段的hash码与reduce的个数进行相除后，余数相同的分到一个区。</li><li>Hive要求****distribute by****语句要写在sort by语句之前。</li><li>演示完以后mapreduce.job.reduces的值要设置回-1，否则下面分区or分桶表load跑MapReduce的时候会报错。</li></ul> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/9d/9b/ZYAWBaHY_o.png" alt="image-20230608172308517"></p> 
<h4><a id="54_Cluster_By_813"></a>5.4 分区排序（Cluster By）</h4> 
<p>当distribute by和sort by字段相同时，可以使用cluster by方式。</p> 
<p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是升序排序，不能指定排序规则为asc或者desc。</p> 
<p>（1）以下两种写法等价</p> 
<pre><code class="prism language-hive">select 
    * 
from emp 
cluster by deptno;

select 
    * 
from emp 
distribute by deptno 
sort by deptno;
</code></pre> 
<p>注意：按照部门编号分区，不一定就是固定死的数值，可以是20号和30号部门分到一个分区里面去。</p> 
<p>hive sql执行过程：</p> 
<p><img src="https://images2.imgbox.com/d0/60/EOFtAhPG_o.png" alt="image-20230608172512706"></p> 
<p>参考资料：</p> 
<pre><code>尚硅谷大数据Hive 3.x教程全新升级版（基于hive3.1.3）p31-p45
https://www.bilibili.com/video/BV1g84y147sX/?p=31&amp;share_source=copy_web&amp;vd_source=e6e32ebc65d9be6b5ec630207a388b36
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/038d760425d65cd3a79a5264b39c94d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过mars3d1.8&#43;cesium1.6根据坐标获取对应坐标在3dtiles模型上的高度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dddcfd02ae932c5880a40a5ee2c0e577/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat 启动与乱码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>