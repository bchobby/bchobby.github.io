<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>期望与概率DP专题/高斯消元 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="期望与概率DP专题/高斯消元" />
<meta property="og:description" content="高斯消元
总结：概率和期望问题的求解都要依靠递推式，概率问题按照递推式进行dp，期望问题根据递推式化简的难易程度通过化简再dp或高斯消元求解，该类问题大部分仍属于各个类型的dp求解问题
2018.9.3-概率与期望dp学习
Discovering Gold
一排1到n的格子，每个格子上有黄金 ai ,你最开始在 1 号,每一次投骰子决定到哪一个格子，超出1~n范围则重新投掷，你到了哪个格子就得到哪个格子的金币，问最终在n 能得到金币的期望
#include&lt;stdio.h&gt; #include&lt;string.h&gt; const int MAX=1e2&#43;5; int a[MAX]; double dp[MAX]; int t,n; int main() { scanf(&#34;%d&#34;,&amp;t); for(int tc=1;tc&lt;=t;&#43;&#43;tc) { memset(dp,0,sizeof(dp)); scanf(&#34;%d&#34;,&amp;n); for(int i=1;i&lt;=n;&#43;&#43;i) scanf(&#34;%d&#34;,&amp;a[i]); dp[1]=1.0; for(int i=1;i&lt;n;&#43;&#43;i) { for(int j=1;j&lt;=6&amp;&amp;i&#43;j&lt;=n;&#43;&#43;j) { int tmp=6; if(i&#43;6&gt;n) tmp=n-i; dp[i&#43;j]&#43;=dp[i]/tmp; } } double ans=0; for(int i=1;i&lt;=n;&#43;&#43;i) ans&#43;=dp[i]*a[i]; printf(&#34;Case %d: %f\n&#34;,tc,ans); } return 0; } HDU3366 Passage
有n扇门和m枚金币，每扇门后有3种可能：1.出路概率p，2.另一扇门概率1-p-q，3.失去一枚金币并且出现另一扇门概率q，门可选择，求在最优选择情况下找到出路得概率
根据p/q从大到小对每扇门排序即为最优策略，注意q可能的值为0，需eps处理
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAX=1e3&#43;5; const double eps=1e-16; double dp[MAX][15],ans; int t,n,m; struct P { double p,q; }a[MAX]; inline bool cmp(P&amp; x,P&amp; y) { return (x." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/0301eb5a5aa0828555765da26927d20a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-19T14:16:40+08:00" />
<meta property="article:modified_time" content="2018-08-19T14:16:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">期望与概率DP专题/高斯消元</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83-toc" style="margin-left:0px;"><a href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83" rel="nofollow">高斯消元</a></p> 
<hr id="hr-toc"> 
<p>总结：概率和期望问题的求解都要依靠递推式，概率问题按照递推式进行dp，期望问题根据递推式化简的难易程度通过化简再dp或高斯消元求解，该类问题大部分仍属于各个类型的dp求解问题</p> 
<p>2018.9.3-概率与期望dp学习</p> 
<p id="b-discovering-gold"><a href="https://vjudge.net/problem/LightOJ-1030" rel="nofollow">Discovering Gold</a></p> 
<p>一排1到n的格子，每个格子上有黄金 ai ,你最开始在 1 号,每一次投骰子决定到哪一个格子，超出1~n范围则重新投掷，你到了哪个格子就得到哪个格子的金币，问最终在n 能得到金币的期望</p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
const int MAX=1e2+5;
int a[MAX];
double dp[MAX];
int t,n;
int main()
{
    scanf("%d",&amp;t);
    for(int tc=1;tc&lt;=t;++tc)
    {
        memset(dp,0,sizeof(dp));
        scanf("%d",&amp;n);
        for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]);
        dp[1]=1.0;
        for(int i=1;i&lt;n;++i)
        {
            for(int j=1;j&lt;=6&amp;&amp;i+j&lt;=n;++j)
            {
                int tmp=6;
                if(i+6&gt;n) tmp=n-i;
                dp[i+j]+=dp[i]/tmp;
            }
        }
        double ans=0;
        for(int i=1;i&lt;=n;++i) ans+=dp[i]*a[i];
        printf("Case %d: %f\n",tc,ans);
    }
    return 0;
}</code></pre> 
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3366" rel="nofollow">HDU3366 Passage</a></p> 
<p>有n扇门和m枚金币，每扇门后有3种可能：1.出路概率p，2.另一扇门概率1-p-q，3.失去一枚金币并且出现另一扇门概率q，门可选择，求在最优选择情况下找到出路得概率</p> 
<p>根据p/q从大到小对每扇门排序即为最优策略，注意q可能的值为0，需eps处理</p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=1e3+5;
const double eps=1e-16;
double dp[MAX][15],ans;
int t,n,m;
struct P
{
    double p,q;
}a[MAX];
inline bool cmp(P&amp; x,P&amp; y)
{
    return (x.p+eps)/(x.q+eps)&gt;(y.p+eps)/(y.q+eps);
}
int main()
{
    scanf("%d",&amp;t);
    for(int tc=1;tc&lt;=t;++tc)
    {
        memset(dp,0,sizeof(dp));
        scanf("%d%d",&amp;n,&amp;m);
        for(int i=0;i&lt;n;++i) scanf("%lf%lf",&amp;a[i].p,&amp;a[i].q);
        sort(a,a+n,cmp);
        dp[0][m]=1.0;ans=0;
        for(int i=0;i&lt;n;++i)
        {
            for(int j=m;j&gt;=0;--j)
            {
                ans+=dp[i][j]*a[i].p;
                if(i&lt;n-1&amp;&amp;j&gt;=1)dp[i+1][j-1]+=dp[i][j]*a[i].q;
                if(i&lt;n-1)dp[i+1][j]+=dp[i][j]*(1.0-a[i].p-a[i].q);
            }
        }
        printf("Case %d: %.5f\n",tc,ans);
    }
    return 0;
}</code></pre> 
<p><a href="https://vjudge.net/problem/LightOJ-1265" rel="nofollow">Island of Survival</a></p> 
<p>小岛上有man\tiger\deer三种生物，每天都有两种相遇：1.tiger-<s>man</s>  2.<s>tiger-tiger</s>  3.tiger-<s>deer</s>  4.man-deer/<s>deer</s>  5.deer-deer</p> 
<p>求man活下来的概率，当且仅当tiger==0。：本题求的是man能活下来的最终概率而不是某种情况下仍存活的概率，题中3\4\5种情况只能延长man的存活时间，而不能影响man的存活概率，因此只需要对1\2情况进行讨论。</p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
const int MAX=1e3+5;
double dp[MAX];
int t,n,m;
int main()
{
    scanf("%d",&amp;t);
    for(int tc=1;tc&lt;=t;++tc)
    {
        memset(dp,0,sizeof(dp));
        scanf("%d%d",&amp;n,&amp;m);
        if(n==0) {printf("Case %d: 1\n",tc);continue;}
        if(n%2==1) {printf("Case %d: 0\n",tc);continue;}
        dp[n]=1;
        for(int i=n;i&gt;=2;i-=2) dp[i-2]=dp[i]*(i-1)/(i+1);
        printf("Case %d: %.6f\n",tc,dp[0]);
    }
    return 0;
}
</code></pre> 
<p><a href="https://vjudge.net/problem/CodeForces-148D" rel="nofollow">Bag of mice </a></p> 
<p>有n只白鼠m只黑鼠，小D和小P二人随机各抓1只并且小D先手，小P抓完后会有1只小鼠出逃，求小D先抓到白鼠的概率</p> 
<p>与上题相似，抓到白鼠则游戏结束，只需讨论2人都抓不到的概率和2种小鼠随机出逃的概率，答案为各种情况下抓到白鼠的概率之和：  本题我的解法中用eps忽略不会到达的情况，需要注意eps精度的设置，题中精度偏差不超过1e-9，eps=1e-11可AC</p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=1e3+1;
const double eps=1e-11;
double dp[MAX][MAX];
int n,m;
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    memset(dp,0,sizeof(dp));
    dp[n][m]=1;
    double ans=0,tmp;
    for(int i=n;i&gt;0;--i)
    {
        for(int j=m;j&gt;=0;--j)
        {
            if(dp[i][j]&lt;eps) continue;
            ans+=dp[i][j]*i/(i+j);
            if(j&gt;=2)tmp=dp[i][j]*j*(j-1)/(i+j)/(i+j-1);
            if(i&gt;=1&amp;&amp;j&gt;=2)dp[i-1][j-2]+=tmp*i/(i+j-2);
            if(j&gt;=3)dp[i][j-3]+=tmp*(j-2)/(i+j-2);
        }
    }
    printf("%.9f\n",ans);
    return 0;
}
</code></pre> 
<p><a href="https://vjudge.net/problem/POJ-3744" rel="nofollow">Scout YYF I </a></p> 
<p>一维路径上有N个地雷，有2种情况：1.走一步概率p，2.走两步概率1-p，求从1走到MAX不踩到雷得概率（n&lt;=10,MAX=1e8）</p> 
<p>由于地雷少且路径长，考虑矩阵快速幂优化，区间状态转移矩阵为        <img alt="\begin{vmatrix} 0 &amp;1 \\ q&amp;p \end{vmatrix}*\begin{bmatrix} f(n)\\f(n+1) \end{bmatrix}= \begin{bmatrix} f(n+1)\\ f(n+2) \end{bmatrix}" class="mathcode" src="https://images2.imgbox.com/2a/1e/daXnkTqW_o.gif"></p> 
<p>把地雷看作区间间断点，假设 <img alt="f(n+1)" class="mathcode" src="https://images2.imgbox.com/6f/8f/BbJZq16W_o.gif">为间断点<img alt="f(n+2)=f(n)*q" class="mathcode" src="https://images2.imgbox.com/23/0c/mIlrZoTS_o.gif">,走两步到达，进行区间概率统计即可</p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[11],n;
double p,q;
struct Mat
{
    double m[2][2];
    Mat(){memset(m,0,sizeof(m));}
    inline void init()
    {
        m[0][0]=0;m[0][1]=1;m[1][0]=q;m[1][1]=p;
    }
};
inline Mat multi(const Mat &amp;a,const Mat &amp;b)
{
    Mat c;
    for(int i=0;i&lt;2;++i)
    for(int j=0;j&lt;2;++j)
    for(int k=0;k&lt;2;++k)
    c.m[i][j]+=a.m[i][k]*b.m[k][j];
    return c;
}
Mat pow(Mat &amp;a,int k)
{
    Mat b;
    for(int i=0;i&lt;2;++i) b.m[i][i]=1;
    while(k)
    {
        if(k&amp;1) b=multi(b,a);
        a=multi(a,a);
        k&gt;&gt;=1;
    }
    return b;
}
double ans;
int main()
{
    while(~scanf("%d%lf",&amp;n,&amp;p))
    {
        q=1.0-p;
        for(int i=0;i&lt;n;++i) scanf("%d",&amp;a[i]);
        sort(a,a+n);
        n=unique(a,a+n)-a;
        if(a[0]==1) {printf("%.7f\n",0.0);continue;}
        Mat m1;m1.init();
        ans=pow(m1,a[0]-1).m[0][1]*q;
        for(int i=0;i&lt;n-1;++i)
        {
            m1.init();
            ans=ans*pow(m1,a[i+1]-a[i]-1).m[0][1]*q;
        }
        printf("%.7f\n",ans);
    }
    return 0;
}
</code></pre> 
<p><a href="https://vjudge.net/problem/LightOJ-1408" rel="nofollow">Batting Practice</a></p> 
<p>每次投1个球投不中概率为p，连中n球或连失m球则停止，求投球次数的期望</p> 
<p>关键词：马尔可夫链、正向推概率反向推期望</p> 
<p><img alt="E(i,0)=(E(i+1,0)+1)*(1-p)+(E(0,1)+1)*p" class="mathcode" src="https://images2.imgbox.com/6c/9a/6xbn6JLk_o.gif"></p> 
<p><img alt="E(0,j)=(E(0,j+1)+1)*p+(E(1,0)+1)*(1-p)" class="mathcode" src="https://images2.imgbox.com/76/8e/cV4oXklg_o.gif"></p> 
<p><img alt="E(n,0)=E(0,m)=0" class="mathcode" src="https://images2.imgbox.com/d9/1c/4BYfDDgH_o.gif"></p> 
<p>设<img alt="q=1-p" class="mathcode" src="https://images2.imgbox.com/ca/e1/hGcdF8vZ_o.gif">,<img alt="a=1-q^{n-1}" class="mathcode" src="https://images2.imgbox.com/b0/a0/MbI8CMOx_o.gif">,<img alt="b=(1-p^{m-1})" class="mathcode" src="https://images2.imgbox.com/11/47/1mn3Kh9q_o.gif"></p> 
<p>1.      <img alt="E(0,0)=(E(1,0)+1)*q+(E(0,1)+1)*p" class="mathcode" src="https://images2.imgbox.com/a7/c7/cpQ39JNQ_o.gif"></p> 
<p>2.     <img alt="E(1,0)=(1-p^{n-1})E(0,1)+\sum_{i=0}^{n-2}p^i -&gt;E(1,0)=aE(0,1)+b/q" class="mathcode" src="https://images2.imgbox.com/76/2d/R5IuUi17_o.gif"></p> 
<p>3.     <img alt="E(0,1)=(1-(1-p)^{m-1})E(1,0)+\sum_{i=0}^{m-2}(1-p)^i-&gt;E(0,1)=bE(1,0)+a/p" class="mathcode" src="https://images2.imgbox.com/2a/d2/F98z5NYv_o.gif"></p> 
<p>由23得  <img alt="E(1,0)=\frac{ab/q+a/p}{1-ab}" class="mathcode" src="https://images2.imgbox.com/85/53/dRrJQx3c_o.gif">,<img alt="E(0,1)=\frac{ab/p+b/q}{1-ab}" class="mathcode" src="https://images2.imgbox.com/1b/e6/gmimHeE8_o.gif">，代入1</p> 
<pre class="has"><code class="language-cpp">#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=51;
const double eps=1e-8;
int t,n,m;
double p,q;
int main()
{
    scanf("%d",&amp;t);
    for(int tc=1;tc&lt;=t;++tc)
    {
        scanf("%lf%d%d",&amp;p,&amp;n,&amp;m);
        q=1.0-p;
        if(p&lt;eps||q&lt;eps) {printf("Case %d: %.8f\n",tc,p&lt;eps?n*1.0:m*1.0);continue;}
        double a=1.0-pow(q,n-1),b=1.0-pow(p,m-1);
        double e10=(a*b/q+a/p)/(1.0-a*b),e01=(a*b/p+b/q)/(1.0-a*b);
        printf("Case %d: %.8f\n",tc,e10*q+e01*p+1.0);
    }
    return 0;
}</code></pre> 
<p style="margin-left:0cm;"><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=3754" rel="nofollow">ZOJ 3329 One Person Game</a></p> 
<p style="margin-left:0cm;">有三个骰子，分别有K1,K2,K3个面，点数都在[1,K1]\[1,K2]\[1,K3]之间，同时掷出三个骰子：若点数分别为a,b,c则sum=0;否则sum+=点数之和，当sum&gt;n结束，求掷骰子次数的期望</p> 
<p style="margin-left:0cm;"><img alt="E(i)= \sum_{x=3}^{K1+K2+k3}E(i+x)p(x)+E(0)p0+1" class="mathcode" src="https://images2.imgbox.com/89/41/6Y2csjOP_o.gif"></p> 
<p style="margin-left:0cm;">同上，概率公式中有环，每一个<img alt="E[i]" class="mathcode" src="https://images2.imgbox.com/98/97/OsL6WzvK_o.gif">都可以转化到<img alt="E[0]" class="mathcode" src="https://images2.imgbox.com/9d/ea/yY8GZIOM_o.gif">，不妨设<img alt="E[i]=a[i]E[0]+b[i];" class="mathcode" src="https://images2.imgbox.com/28/da/i0JNBJDZ_o.gif">代入迭代化简得</p> 
<p style="margin-left:0cm;"><img alt="a[i]=\sum_{x=3}^{K1+K2+K3}a[i+x]+p0" class="mathcode" src="https://images2.imgbox.com/71/1e/zOZszpmG_o.gif">           <img alt="b[i]=\sum_{x=3}^{K1+K2+K3}b[i+x]+1" class="mathcode" src="https://images2.imgbox.com/b6/9f/rMdKUxG1_o.gif"></p> 
<p style="margin-left:0cm;">问题化简为求<img alt="a[0]" class="mathcode" src="https://images2.imgbox.com/5f/83/B60rmfAk_o.gif">和<img alt="b[0]" class="mathcode" src="https://images2.imgbox.com/5f/92/PbJaJZQT_o.gif"></p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAX=5e2+1;
const double eps=1e-8;
double p[MAX],pa[MAX],pb[MAX],p0;
int t,n,K1,K2,K3,a,b,c;
int main()
{
    scanf("%d",&amp;t);
    while(t--)
    {
        memset(p,0,sizeof(p));
        memset(pa,0,sizeof(pa));
        memset(pb,0,sizeof(pb));
        scanf("%d%d%d%d%d%d%d",&amp;n,&amp;K1,&amp;K2,&amp;K3,&amp;a,&amp;b,&amp;c);
        p0=1.0/K1/K2/K3;
        for(int i=1;i&lt;=K1;++i)
        for(int j=1;j&lt;=K2;++j)
        for(int k=1;k&lt;=K3;++k)
            p[i+j+k]+=p0;
        p[a+b+c]-=p0;
        for(int i=n;i&gt;=0;--i)
        {
            pa[i]+=p0;
            pb[i]+=1;
            for(int j=3;j&lt;=K1+K2+K3&amp;&amp;i+j&lt;=n;++j)
            {
                pa[i]+=pa[i+j]*p[j];
                pb[i]+=pb[i+j]*p[j];
            }
        }
        printf("%.8f\n",pb[0]/(1.0-pa[0]));
    }
    return 0;
}
</code></pre> 
<p style="margin-left:0cm;"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4336" rel="nofollow">HDU 4336 Card Collector</a></p> 
<p style="margin-left:0cm;">买魔法士干脆面收集袋中卡牌，共有n张卡牌，袋中有i卡牌得概率为pi，<img alt="\sum {}pi&lt;=1" class="mathcode" src="https://images2.imgbox.com/a1/ed/qlke4A1B_o.gif">,求买干脆面的期望</p> 
<p style="margin-left:0cm;">n张卡牌形成1&lt;&lt;n种状态，考虑通过状态压缩列状态转移方程：</p> 
<p style="margin-left:0cm;"><img alt="E[i]=E[i]*ps+\sum_{j=0}^{j&lt;n}(i\&amp;1&lt;&lt;j)E[i]*pj+\sum_{j=0}^{j&lt;n}(!i\&amp;1&lt;&lt;j)E[i]*pj+1" class="mathcode" src="https://images2.imgbox.com/ea/07/71VOJWp0_o.gif"> ， <img alt="ps=1-\sum_{j=0}^{j&lt;n}pi" class="mathcode" src="https://images2.imgbox.com/06/19/7VkdJLKe_o.gif"></p> 
<p style="margin-left:0cm;">设<img alt="p1=\sum_{j=0}^{j&lt;n}(i\&amp;1&lt;&lt;j)pj" class="mathcode" src="https://images2.imgbox.com/23/9b/0K23oxVa_o.gif">  ,  <img alt="p2=\sum_{j=0}^{j&lt;n}(!i\&amp;1&lt;&lt;j)pj+1" class="mathcode" src="https://images2.imgbox.com/5d/c8/73LzR3Qg_o.gif">,化简得</p> 
<p style="margin-left:0cm;"><img alt="E[i]=p2/(1.0-ps-p1)" class="mathcode" src="https://images2.imgbox.com/e9/92/VgY3mKWP_o.gif"></p> 
<p style="margin-left:0cm;">根据递推式反向求期望</p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAX=1&lt;&lt;20|1;
double dp[MAX],p[21],ps,p1,p2;
int n;
int main()
{
    while(~scanf("%d",&amp;n))
    {
        memset(dp,0,sizeof(dp));ps=1.0;
        for(int i=0;i&lt;n;++i) {scanf("%lf",&amp;p[i]);ps-=p[i];}
        for(int i=(1&lt;&lt;n)-2;i&gt;=0;--i)
        {
            p1=p2=0;
            for(int j=0;j&lt;n;++j)
            {
                if(i&amp;1&lt;&lt;j) p1+=p[j];
                else p2+=dp[i|1&lt;&lt;j]*p[j];
            }
            p2+=1.0;
            dp[i]=p2/(1.0-p1-ps);//1&lt;&lt;n-1,1.0-p1-ps==0
        }
        printf("%.4f\n",dp[0]);
    }
    return 0;
}
</code></pre> 
<p style="margin-left:0cm;"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4870" rel="nofollow">HDU4870 Rating </a></p> 
<h2 id="%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83" style="margin-left:0cm;">高斯消元</h2> 
<p style="margin-left:0cm;">有两个账号，每次选取一个分数最低的账号进行游戏，有p得概率得1分,1-p得概率失2分，最低0分，求1个号到达20的期望</p> 
<p style="margin-left:0cm;">由题意得，两个号的分差必定不超过1，当一个号为20分时，另一个为19</p> 
<p style="margin-left:0cm;"><img alt="E[i]=E[i+1]*p+E[i-2]*q+1" class="mathcode" src="https://images2.imgbox.com/5e/d1/gNpgK6EC_o.gif"></p> 
<p style="margin-left:0cm;">按递推式建立矩阵，套用高斯消元函数，得到解集<img alt="x" class="mathcode" src="https://images2.imgbox.com/9f/45/oKFg1vZB_o.gif"></p> 
<p style="margin-left:0cm;"><img alt="x[i]" class="mathcode" src="https://images2.imgbox.com/0e/54/j9Mpys0b_o.gif">表示从i分到20分的期望,所以答案即为<img alt="x[0]*2-x[19]" class="mathcode" src="https://images2.imgbox.com/61/be/5IqnnMJZ_o.gif">：两倍的0~20减去19~20</p> 
<p style="margin-left:0cm;">该题的递推式也可以通过换元<img alt="s[i]=E[i]-E[i-1]" class="mathcode" src="https://images2.imgbox.com/82/97/sRMovuNw_o.gif">进行化简</p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAX=2e2+5;
const double eps=1e-11;
double a[MAX][MAX],x[MAX],p,q;
int equ,var,n=20;
bool gauss()
{
    int i,j,k,col,max_r;
    for(k=0,col=0;k&lt;equ&amp;&amp;col&lt;var;++k,++col)
    {
        max_r=k;
        for(i=k+1;i&lt;equ;++i)
            if(fabs(a[i][col])&gt;fabs(a[max_r][col]))
                max_r=i;
        if(fabs(a[max_r][col])&lt;eps) return 0;
        if(k!=max_r)
        {
            for(j=col;j&lt;var;++j) swap(a[k][j],a[max_r][j]);
            swap(x[k],x[max_r]);
        }
        x[k]/=a[k][col];
        for(j=col+1;j&lt;var;++j) a[k][j]/=a[k][col];
        a[k][col]=1.0;
        for(i=0;i&lt;equ;++i)
            if(i!=k)
            {
                x[i]-=x[k]*a[i][col];
                for(j=col+1;j&lt;var;++j) a[i][j]-=a[k][j]*a[i][col];
                a[i][col]=0.0;
            }
    }
    return 1;
}
int main()
{
    equ=var=n;
    while(~scanf("%lf",&amp;p))
    {
        memset(a,0,sizeof(a));
        q=1.0-p;
        a[0][0]=p;a[0][1]=-p;a[0][n]=x[0]=1.0;
        a[1][0]=-q;a[1][1]=1.0;a[1][2]=-p;a[1][n]=x[1]=1.0;
        for(int i=2;i&lt;n;++i)
        {
            a[i][i-2]=-q;
            a[i][i]=1.0;
            a[i][i+1]=-p;
            a[i][n]=x[i]=1.0;
        }
        gauss();
        printf("%.6f\n",x[0]*2-x[19]);
    }
    return 0;
}
</code></pre> 
<p style="margin-left:0cm;"><a href="http://acm.zjut.edu.cn/ShowProblem.aspx?ShowID=1423" rel="nofollow">ZJUT 1423 地下迷宫</a></p> 
<p style="margin-left:0cm;"><a href="http://acm.zjut.edu.cn/ShowProblem.aspx?ShowID=1317" rel="nofollow">ZJUT 1317 掷飞盘</a></p> 
<p style="margin-left:0cm;"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4418" rel="nofollow">HDU 4418 Time travel</a></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><a href="http://kicd.blog.163.com/blog/static/126961911200910168335852/" rel="nofollow">转载</a></p> 
<p style="margin-left:0cm;">对离散型随机变量x，其概率为p，有<img alt="E[x]=\sum pi*xi" class="mathcode" src="https://images2.imgbox.com/15/e8/Yscq4JHK_o.gif"></p> 
<p style="margin-left:0cm;">对随机变量A、B,有 <img alt="E[ax+by]=aE[x]+bE[y]" class="mathcode" src="https://images2.imgbox.com/59/dd/DLRuh5qF_o.gif"></p> 
<p style="margin-left:0cm;">第二条式子是今天的主角，他表明了期望有线性的性质，简单理解就是期望之间可根据关系，简单运算（不严谨的理解）。 这就为我们解决一个期望问题，不断转化为解决另外的期望问题，最终转化到一个已知的期望上。</p> 
<p style="margin-left:0cm;">举一个求期望最简单的例子，见下图。</p> 
<p style="margin-left:0cm;">假设有个人在 1号节点处，每一分钟他会缘着边随机走到一个节点或者在原地停留，问他走到4号节点需要平均几分钟？</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="153" src="https://images2.imgbox.com/1b/e2/EBmCYv2L_o.png" width="242"></p> 
<p style="margin-left:0cm;">这是个简单的期望问题，我们用Ei(i=1,2,3,4) 表示从i号节点走到4号节点的数学期望值。根据题意对1号节点有</p> 
<p style="margin-left:0cm;">E1=（1/3）*E1+（1/3）*E2+（1/3）*E3+1 ①</p> 
<p style="margin-left:0cm;">表示 他下一分钟可以走到2或者3或在原地1，每个可能概率是1/3 ,注意是下一分钟，故要加上1.</p> 
<p style="margin-left:0cm;">同理我们对节点2，3同样可以列出</p> 
<p style="margin-left:0cm;">E2=(1/3)*E1+(1/3)*E2+(1/3)*E4+1 ②</p> 
<p style="margin-left:0cm;">E3=(1/3)*E1+(1/3)*E3+(1/3)*E4+1 ③</p> 
<p style="margin-left:0cm;">那E4等于多少呢？ 很明显E4=0 ④，因为他就是要到点4</p> 
<p style="margin-left:0cm;">这样上面1234式其实就是组成了一组方程组，解方程组就可得出E1！！，用高斯消元，复杂度是O(n^3)</p> 
<p style="margin-left:0cm;">从上述例子，我们可总结出如何解决期望类问题，根据题意，表示出各个状态的期望（上例的Ei，1234）,根据概率公式，列出期望之间的方程，解方程即可。</p> 
<p style="margin-left:0cm;">下面看用上述思路如何解决一道题（poj2096）</p> 
<p style="margin-left:0cm;">题意简述： 一个人受雇于某公司要找出某个软件的bugs和subcomponents，这个软件一共有n个bugs和s个subcomponents，每次他都能同时随机发现1个bug和1个subcomponent,问他找到所有的bugs和subcomponents的期望次数。</p> 
<p style="margin-left:0cm;">我们用E(i,j)表示他找到了i个bugs和j个subcomponents，离找到n个bugs和s个subcomponents还需要的期望次数，这样要求的就是E(0,0),而E(n,s)=0,对任意的E(i,j),1次查找4种情况，没发现任何新的bugs和subcomponents，发现一个新的bug，发现一个新的subcomponent，同时发现一个新的bug和subcomponent，用概率公式可得：</p> 
<p style="margin-left:0cm;">E(i,j)=1+(i*j/n/s)*E(i,j)+(i*(s-j)/n/s)E(i,j+1)+((n-i)*j/n/s)*E(i+1,j)+(n-i)*(s-j)/n/s*E(i+1,j+1);</p> 
<p style="margin-left:0cm;">这样根据边界就可解出所有的E(i,j),注意因为当我们找到n个bugs和s个subcomponents就结束，对i&gt;n||j&gt;s均无解的情况，并非期望是0.(数学上常见问题，0和不存在的区别)</p> 
<p style="margin-left:0cm;">那这题是否也是要用高斯消元呢？ 用高斯消元得话复杂度是O(n^3)，达到10^18 根本是不可解的！！</p> 
<p style="margin-left:0cm;">但其实，注意观察方程，当我们要解E(i,j)的话就需要E(i+1,j),E(I,j+1),E(i+1,j+1), 一开始已知E(n,s)，那其实只要我们从高往低一个个解出I,j就可以了！ 即可根据递推式解出所有的E(I,j) 复杂度是O(n),10^6 ，完美解决。</p> 
<p style="margin-left:0cm;">从上面这道题，我们再次看到了解决期望问题的思路，而且是用到了递推解决问题，其实可递推的原因，当我们把各个状态当成是一个个节点时，概率关系为有向边，我们可看到，可递推的问题其实就是这个关系图是无环的！！那必须要用方程组解决的问题其实就是存在环！！！！ 而且我还要指出的是用高斯消元的时候，要注意误差的问题，最好把式子适当的增大，避免解小数，否则误差太大，估计也会卡题。</p> 
<p><strong><a href="http://wenku.baidu.com/view/1c41152de2bd960590c677a8.html" rel="nofollow">《信息学竞赛中概率问题求解初探》</a></strong></p> 
<p><a href="http://wenku.baidu.com/view/90adb02acfc789eb172dc8a8.html" rel="nofollow"><strong>《浅析竞赛中一类数学期望问题的解决方法》</strong></a></p> 
<p><a href="http://wenku.baidu.com/view/56147518a8114431b90dd81e.html" rel="nofollow"><strong>《有关概率和期望问题的研究 》</strong></a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5277e2e394b7158dfe3f61dc14180ff5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">html基础笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/895eb38350e0092395ad994a60887c4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">无法启动此程序，因为计算机中丢失 api-ms-win-crt-runtime-l1-1-0.dll 的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>