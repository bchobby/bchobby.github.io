<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zookeeper  Curator 事件监听 - 10分钟看懂 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Zookeeper  Curator 事件监听 - 10分钟看懂" />
<meta property="og:description" content="文章很长，建议收藏起来，慢慢读! 备注：持续更新中…
疯狂创客圈 经典图书 ： 《Netty Zookeeper Redis 高并发实战》 面试必备 &#43; 大厂必备 &#43; 涨薪必备疯狂创客圈 经典图书 ： 《SpringCloud、Nginx高并发核心编程》 面试必备 &#43; 大厂必备 &#43; 涨薪必备疯狂创客圈 价值1000元 百度网盘资源大礼包，免费拿 【博客园总入口 】 文章目录 价值连城：2021春招月薪过5万 面试题 系列万字长文： 疯狂创客圈 springCloud 高并发系列写在前面1.1. **Curator 事件监听**1.1.1. Watcher 标准的事件处理器1.1.2. NodeCache 节点缓存的监听1.1.3. PathChildrenCache 子节点监听1.1.4. Tree Cache 节点树缓存写在最后疯狂创客圈 亿级流量 高并发IM 实战 系列 价值连城：2021春招月薪过5万 面试题 系列 搞定下面这些面试题，2021春招月薪过5万(猛！)阿里、京东、美团、头条… 随意挑、横着走！！！Java基础1： JVM面试题（史上最强、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14365820.html2：Java基础面试题（史上最全、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14366081.html3：死锁面试题（史上最强、持续更新）[https://www.cnblogs.com/crazymakercircle/p/14323919.html]4：设计模式面试题 （史上最全、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14367101.html5：架构设计面试题 （史上最全、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14367907.html还有 10 几篇 篇价值连城 的面试题具体… 请参见【 疯狂创客圈 高并发 总目录 】 万字长文： 疯狂创客圈 springCloud 高并发系列 springCloud 高质量 博文 nacos 实战（史上最全） sentinel （史上最全&#43;入门教程） springcloud &#43; webflux 高并发实战 Webflux（史上最全） SpringCloud gateway （史上最全）还有 10 几篇 万字长文 的高质量 博文具体… 请参见【 疯狂创客圈 高并发 总目录 】 写在前面 ​ 大家好，我是作者尼恩。目前和几个小伙伴一起，组织了一个高并发的实战社群【疯狂创客圈】。正在开始高并发、亿级流程的 IM 聊天程序 学习和实战" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/0452ea8d438f23bba9542ebe1f3c29b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-06T12:57:08+08:00" />
<meta property="article:modified_time" content="2019-01-06T12:57:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Zookeeper  Curator 事件监听 - 10分钟看懂</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>文章很长，建议收藏起来，慢慢读! 备注：持续更新中…</p> 
<ul><li><strong>疯狂创客圈 经典图书 ： <a href="https://www.cnblogs.com/crazymakercircle/p/11397271.html" rel="nofollow">《Netty Zookeeper Redis 高并发实战》</a> 面试必备 + 大厂必备 + 涨薪必备</strong></li><li><strong>疯狂创客圈 经典图书 ： <a href="https://www.cnblogs.com/crazymakercircle/p/13878143.html" rel="nofollow">《SpringCloud、Nginx高并发核心编程》</a> 面试必备 + 大厂必备 + 涨薪必备</strong></li><li><strong>疯狂创客圈 价值1000元 百度网盘资源大礼包，免费拿 【<a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow">博客园总入口</a> 】</strong></li></ul> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#20215___13" rel="nofollow">价值连城：2021春招月薪过5万 面试题 系列</a></li><li><a href="#__springCloud___26" rel="nofollow">万字长文： 疯狂创客圈 springCloud 高并发系列</a></li><li><a href="#_35" rel="nofollow">写在前面</a></li><li><a href="#11_Curator__51" rel="nofollow">1.1. **Curator 事件监听**</a></li><li><a href="#111_Watcher__67" rel="nofollow">1.1.1. Watcher 标准的事件处理器</a></li><li><a href="#112_NodeCache__207" rel="nofollow">1.1.2. NodeCache 节点缓存的监听</a></li><li><a href="#113_PathChildrenCache__352" rel="nofollow">1.1.3. PathChildrenCache 子节点监听</a></li><li><a href="#114_Tree_Cache__542" rel="nofollow">1.1.4. Tree Cache 节点树缓存</a></li><li><a href="#_735" rel="nofollow">写在最后</a></li><li><a href="#___IM___749" rel="nofollow">疯狂创客圈 亿级流量 高并发IM 实战 系列</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="20215___13"></a>价值连城：2021春招月薪过5万 面试题 系列</h3> 
<table><thead><tr><th align="left">搞定下面这些面试题，2021春招月薪过5万(猛！)</th><th>阿里、京东、美团、头条… 随意挑、横着走！！！</th></tr></thead><tbody><tr><td align="left"><strong>Java基础</strong></td><td></td></tr><tr><td align="left">1： JVM面试题（史上最强、持续更新、吐血推荐）</td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14365820.html" rel="nofollow">https://www.cnblogs.com/crazymakercircle/p/14365820.html</a></td></tr><tr><td align="left">2：Java基础面试题（史上最全、持续更新、吐血推荐）</td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14366081.html" rel="nofollow">https://www.cnblogs.com/crazymakercircle/p/14366081.html</a></td></tr><tr><td align="left">3：死锁面试题（史上最强、持续更新）</td><td>[https://www.cnblogs.com/crazymakercircle/p/14323919.html]</td></tr><tr><td align="left">4：设计模式面试题 （史上最全、持续更新、吐血推荐）</td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14367101.html" rel="nofollow">https://www.cnblogs.com/crazymakercircle/p/14367101.html</a></td></tr><tr><td align="left">5：架构设计面试题 （史上最全、持续更新、吐血推荐）</td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14367907.html" rel="nofollow">https://www.cnblogs.com/crazymakercircle/p/14367907.html</a></td></tr><tr><td align="left">还有 <strong>10 几篇</strong> 篇<strong>价值连城</strong> 的面试题</td><td>具体… 请参见【<a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow"> 疯狂创客圈 高并发 总目录</a> 】</td></tr></tbody></table> 
<hr> 
<h3><a id="__springCloud___26"></a>万字长文： 疯狂创客圈 springCloud 高并发系列</h3> 
<table><thead><tr><th align="left">springCloud 高质量 博文</th><th></th></tr></thead><tbody><tr><td align="left"><a href="https://www.cnblogs.com/crazymakercircle/p/14231815.html" rel="nofollow"> nacos 实战（史上最全）</a></td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14285001.html" rel="nofollow"> sentinel （史上最全+入门教程）</a></td></tr><tr><td align="left"><a href="https://www.cnblogs.com/crazymakercircle/p/14312282.html" rel="nofollow"> springcloud + webflux 高并发实战</a></td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14302151.html" rel="nofollow"> Webflux（史上最全）</a></td></tr><tr><td align="left"><a href="https://www.cnblogs.com/crazymakercircle/p/11704077.html" rel="nofollow"> SpringCloud gateway （史上最全）</a></td><td></td></tr><tr><td align="left">还有 <strong>10 几篇</strong> 万字长文 的高质量 博文</td><td>具体… 请参见【<a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow"> 疯狂创客圈 高并发 总目录</a> 】</td></tr></tbody></table> 
<hr> 
<h3><a id="_35"></a>写在前面</h3> 
<p>​ 大家好，我是作者尼恩。目前和几个小伙伴一起，组织了一个高并发的实战社群【疯狂创客圈】。正在开始<strong>高并发、亿级流程的 IM 聊天程序 学习和实战</strong></p> 
<p>​ 前面，已经完成一个高性能的 Java 聊天程序的四件大事：</p> 
<p>接下来，需要进入到分布式开发的环节了。 分布式的中间件，疯狂创客圈的小伙伴们，一致的选择了zookeeper，不仅仅是由于其在大数据领域，太有名了。更重要的是，很多的著名框架，都使用了zk。</p> 
<p>​ <strong>本篇介绍 ZK Curator 的事件监听</strong>。</p> 
<h3><a id="11_Curator__51"></a>1.1. <strong>Curator 事件监听</strong></h3> 
<p>Curator 事件有两种模式，一种是标准的观察模式，一种是缓存监听模式。标准的监听模式是使用Watcher 监听器。第二种缓存监听模式引入了一种本地缓存视图的Cache机制，来实现对Zookeeper服务端事件监听。</p> 
<p>Cache事件监听可以理解为一个本地缓存视图与远程Zookeeper视图的对比过程。Cache提供了反复注册的功能。Cache是一种缓存机制，可以借助Cache实现监听。简单来说，Cache在客户端缓存了znode的各种状态，当感知到zk集群的znode状态变化，会触发event事件，注册的监听器会处理这些事件。</p> 
<p>Watcher 监听器比较简单，只有一种。Cache事件监听的种类有3种Path Cache，Node Cache，Tree Cache。</p> 
<h3><a id="111_Watcher__67"></a>1.1.1. Watcher 标准的事件处理器</h3> 
<p>在ZooKeeper中，接口类Watcher用于表示一个标准的事件处理器，其定义了事件通知相关的逻辑，包含KeeperState和EventType两个枚举类，分别代表了通知状态和事件类型。</p> 
<p>Watcher接口定义了事件的回调方法：process（WatchedEvent event）。定义一个Watcher的实例很简单，代码如下：</p> 
<pre><code>Watcher w = new Watcher() {
    @Override
    public void process(WatchedEvent watchedEvent) {
        log.info("监听器watchedEvent：" + watchedEvent);
    }
};

</code></pre> 
<p>使用Watcher监听器实例的方式也很简单，在Curator的调用链上，加上usingWatcher方法即可，代码如下：</p> 
<pre><code>byte[] content = client.getData()
        .usingWatcher(w).forPath(workerPath);
</code></pre> 
<p>一个Watcher监听器在向服务端完成注册后，当服务端的一些事件触发了这个Watcher，那么就会向指定客户端发送一个事件通知，来实现分布式的通知功能。客户收到服务器的通知后，Curator 会封装一个WatchedEvent 事件实例，传递给监听器的回调方法process（WatchedEvent event）。</p> 
<p>WatchedEvent包含了三个基本属性：</p> 
<p>（1）通知状态（keeperState）</p> 
<p>（2）事件类型（EventType）</p> 
<p>（3）节点路径（path）</p> 
<p>注意，WatchedEvent并不是直接从ZooKeeper集群直接传递过来的事件实例，而是Curator 封装过的事件实例。WatchedEvent类型没有实现序列化接口java.io.Serializable，因此不能用于网络传输。ZooKeeper集群直接网络传输传递过来的事件实例是啥呢？ 是一个WatcherEvent类型的实例，这个传输实例和Curator 封装过的WatchedEvent实例，在名称上有一个字母之差，而且功能也是一样的，都表示的是同一个事物，都是对一个服务端事件的封装。</p> 
<p>因此，这里只讲Curator 封装过的WatchedEvent实例。下边列举了ZooKeeper中最常见的几个通知状态和事件类型。</p> 
<table><thead><tr><th>KeeperState</th><th>EventType</th><th>触发条件</th><th>说明</th></tr></thead><tbody><tr><td></td><td>None （-1）</td><td>客户端与服务端成功建立连接</td><td></td></tr><tr><td>SyncConnected （0）</td><td>NodeCreated （1）</td><td>Watcher监听的对应数据节点被创建</td><td></td></tr><tr><td></td><td>NodeDeleted （2）</td><td>Watcher监听的对应数据节点被删除</td><td>此时客户端和服务器处于连接状态</td></tr><tr><td></td><td>NodeDataChanged （3）</td><td>Watcher监听的对应数据节点的数据内容发生变更</td><td></td></tr><tr><td></td><td>NodeChildChanged （4）</td><td>Wather监听的对应数据节点的子节点列表发生变更</td><td></td></tr><tr><td>Disconnected （0）</td><td>None （-1）</td><td>客户端与ZooKeeper服务器断开连接</td><td>此时客户端和服务器处于断开连接状态</td></tr><tr><td>Expired （-112）</td><td>Node （-1）</td><td>会话超时</td><td>此时客户端会话失效，通常同时也会受到SessionExpiredException异常</td></tr><tr><td>AuthFailed （4）</td><td>None （-1）</td><td>通常有两种情况，1：使用错误的schema进行权限检查 2：SASL权限检查失败</td><td>通常同时也会收到AuthFailedException异常</td></tr></tbody></table> 
<p>利用Watcher来对节点进行监听操作，但此监听操作只能监听一次。来看一个简单的实例程序：</p> 
<pre><code>@Slf4j

@Data

public class ZkWatcherDemo {

 

    private String workerPath = "/test/listener/node";
    private String subWorkerPath = "/test/listener/node/id-";

 
    @Test
    public void testWatcher() {
        CuratorFramework client = ZKclient.instance.getClient();

        //检查节点是否存在，没有则创建
        boolean isExist = ZKclient.instance.isNodeExist(workerPath);
        if (!isExist) {
            ZKclient.instance.createNode(workerPath, null);
        }

        try {

            Watcher w = new Watcher() {
                @Override
                public void process(WatchedEvent watchedEvent) {
                    System.out.println("监听到的变化 watchedEvent = " + watchedEvent);
                }
            };

            byte[] content = client.getData()
                    .usingWatcher(w).forPath(workerPath);

            log.info("监听节点内容：" + new String(content));

            // 第一次变更节点数据
            client.setData().forPath(workerPath, "第1次更改内容".getBytes());

            // 第二次变更节点数据
            client.setData().forPath(workerPath, "第2次更改内容".getBytes());

            Thread.sleep(Integer.MAX_VALUE);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

		//....

}

</code></pre> 
<p>运行代码，输出的结果如下：</p> 
<pre><code>监听到的变化 watchedEvent = WatchedEvent state:SyncConnected type:NodeDataChanged path:/test/listener/node
</code></pre> 
<p>程序中，对节点路径 “/test/listener/node”注册一个Watcher监听器实例，随后调用setData方法两次改变节点内容，但是，监听器仅仅监听到了一个事件。也就是说，当第二次改变节点内容时，监听已经失效，无法再次获得节点变动事件。</p> 
<p>也就是说，Watcher监听器是一次性的，如果要反复使用，就需要反复的使用usingWatcher提前注册。</p> 
<p>所以，Watcher监听器不能应用于节点的数据变动或者节点变动这样的一般业务场景。而是适用于一些特殊的，比如会话超时、授权失败等这样的特殊场景。</p> 
<p>既然Watcher监听器是一次性的，在开发过程中需要反复注册Watcher，比较繁琐。Curator引入了Cache来监听ZooKeeper服务端的事件。Cache对ZooKeeper事件监听进行了封装，能够自动处理反复注册监听。</p> 
<h3><a id="112_NodeCache__207"></a>1.1.2. NodeCache 节点缓存的监听</h3> 
<p>Curator引入的Cache缓存实现，是一个系列，包括了Node Cache 、Path Cache、Tree Cache三组类。其中Node Cache节点缓存可以用于ZNode节点的监听，Path Cache子节点缓存用于ZNode的子节点的监听，而Tree Cache树缓存是Path Cache的增强，不光能监听子节点，也能监听ZNode节点自身。</p> 
<p>Node Cache，可以用于监控本节点的新增，删除，更新。</p> 
<p>Node Cache使用的第一步，就是构造一个NodeCache缓存实例。</p> 
<p>有两个构造方法，具体如下：</p> 
<pre><code>NodeCache(CuratorFramework client, String path) 

NodeCache(CuratorFramework client, String path, boolean dataIsCompressed) 

</code></pre> 
<p>第一个参数就是传入创建的Curator的框架客户端，第二个参数就是监听节点的路径，第三个重载参数dataIsCompressed 表示是否对数据进行压缩。</p> 
<p>NodeCache使用的第二步，就是构造一个NodeCacheListener监听器实例。该接口的定义如下：</p> 
<pre><code>package org.apache.curator.framework.recipes.cache;

public interface NodeCacheListener {

    void nodeChanged() throws Exception;

}

</code></pre> 
<p>NodeCacheListener监听器接口，只定义了一个简单的方法 nodeChanged，当节点变化时，这个方法就会被回调到。</p> 
<p>在创建完NodeCacheListener的实例之后，需要将这个实例注册到NodeCache缓存实例，使用缓存实例的addListener方法。 然后使用缓存实例nodeCache的start方法，启动节点的事件监听。</p> 
<pre><code>nodeCache.getListenable().addListener(l);

nodeCache.start(); 

</code></pre> 
<p>强调下，需要调用nodeCache的start方法能进行缓存和事件监听，这个方法有两个版本：</p> 
<pre><code>void    start()//Start the cache.

void    start(boolean buildInitial)  //true代表缓存当前节点
</code></pre> 
<p>唯一的一个参数buildInitial代表着是否将该节点的数据立即进行缓存。如果设置为true的话，在start启动时立即调用NodeCache的getCurrentData方法就能够得到对应节点的信息ChildData类，如果设置为false的就得不到对应的信息。</p> 
<p>使用NodeCache来监听节点的事件，完整的实例代码如下：</p> 
<pre><code>    @Test
    public void testNodeCache() {

        //检查节点是否存在，没有则创建
        boolean isExist = ZKclient.instance.isNodeExist(workerPath);
        if (!isExist) {
            ZKclient.instance.createNode(workerPath, null);
        }

        CuratorFramework client = ZKclient.instance.getClient();
        try {
            NodeCache nodeCache =
                    new NodeCache(client, workerPath, false);
            NodeCacheListener l = new NodeCacheListener() {
                @Override
                public void nodeChanged() throws Exception {
                    ChildData childData = nodeCache.getCurrentData();
                    log.info("ZNode节点状态改变, path={}", childData.getPath());
                    log.info("ZNode节点状态改变, data={}", new String(childData.getData(), "Utf-8"));
                    log.info("ZNode节点状态改变, stat={}", childData.getStat());
                }
            };
            nodeCache.getListenable().addListener(l);
            nodeCache.start();

            // 第1次变更节点数据
            client.setData().forPath(workerPath, "第1次更改内容".getBytes());
            Thread.sleep(1000);

            // 第2次变更节点数据
            client.setData().forPath(workerPath, "第2次更改内容".getBytes());

            Thread.sleep(1000);

            // 第3次变更节点数据
            client.setData().forPath(workerPath, "第3次更改内容".getBytes());
            Thread.sleep(1000);

            // 第4次变更节点数据
//            client.delete().forPath(workerPath);
            Thread.sleep(Integer.MAX_VALUE);
        } catch (Exception e) {
            log.error("创建NodeCache监听失败, path={}", workerPath);
        }
    }

</code></pre> 
<p>运行的结果是，NodeCashe节点缓存能够重复的进行事件节点。代码中的第三次监听的输出节选如下：</p> 
<pre><code>\- ZNode节点状态改变, path=/test/listener/node

\- ZNode节点状态改变, data=第3次更改内容

\- ZNode节点状态改变, stat=17179869191,...
</code></pre> 
<p>最后说明一下，如果NodeCache监听的节点为空（也就是说传入的路径不存在）。那么如果我们后面创建了对应的节点，也是会触发事件从而回调nodeChanged方法。</p> 
<h3><a id="113_PathChildrenCache__352"></a>1.1.3. PathChildrenCache 子节点监听</h3> 
<p>PathChildrenCache子节点缓存用于子节点的监听，监控本节点的子节点被创建、更新或者删除。需要强调两点：</p> 
<p>（1）只能监听子节点，监听不到当前节点</p> 
<p>（2）不能递归监听，子节点下的子节点不能递归监控</p> 
<p>PathChildrenCache子节点缓存使用的第一步，就是构造一个缓存实例。</p> 
<p>有多个重载版本的构造方法，选择4个进行说明，具体如下：</p> 
<pre><code>public PathChildrenCache(CuratorFramework client, String path,boolean cacheData)

public PathChildrenCache(CuratorFramework client, String path,boolean cacheData, 
         boolean dataIsCompressed,final ExecutorService executorService)

public PathChildrenCache(CuratorFramework client, String path,boolean cacheData,
         boolean dataIsCompressed,ThreadFactory threadFactory)

public PathChildrenCache(CuratorFramework client, String path,boolean cacheData,
         ThreadFactory threadFactory)

</code></pre> 
<p>所有的构造方法，前三个参数，都是一样的。</p> 
<p>第一个参数就是传入创建的Curator的框架客户端，第二个参数就是监听节点的路径，第三个重载参数cacheData表示是否把节点内容缓存起来。如果cacheData为true，那么接收到节点列表变更事件的同时，会将获得节点内容。</p> 
<p>dataIsCompressed参数（如果有），表示是否对节点数据进行压缩。</p> 
<p>executorService 和threadFactory参数差不多，表示通过传入的线程池或者线程工厂，来异步处理监听事件。</p> 
<p>threadFactory参数（如果有）表示线程池工厂，当PathChildrenCache内部需要开启新的线程执行时，使用该线程池工厂来创建线程。</p> 
<p>PathChildrenCache子节点缓存使用的第二步，就是构造一个子节点缓存监听器PathChildrenCacheListener实例。该接口的定义如下：</p> 
<pre><code>package org.apache.curator.framework.recipes.cache;

import org.apache.curator.framework.CuratorFramework;
 
public interface PathChildrenCacheListener {

   void childEvent(CuratorFramework client, PathChildrenCacheEvent e) throws Exception;

}
</code></pre> 
<p>PathChildrenCacheListener监听器接口中，也只定义了一个简单的方法 childEvent，当子节点有变化时，这个方法就会被回调到。</p> 
<p>在创建完PathChildrenCacheListener的实例之后，需要将这个实例注册到PathChildrenCache缓存实例，使用缓存实例的addListener方法。 然后使用缓存实例nodeCache的start方法，启动节点的事件监听。</p> 
<p>这里的start方法，需要传入启动的模式。可以传入三种模式，也就是API列表中看到的StartMode，其中定义了下面三种枚举：</p> 
<p>（1）NORMAL——异步初始化cache</p> 
<p>（2）BUILD_INITIAL_CACHE——同步初始化cache</p> 
<p>（3）POST_INITIALIZED_EVENT——异步初始化cache，并触发完成事件</p> 
<p>对于start模式的三种启动方式，详细的说明如下：</p> 
<p>BUILD_INITIAL_CACHE：启动时，同步初始化cache，以及创建cache后，就从服务器拉取对应的数据。</p> 
<p>POST_INITIALIZED_EVENT：启动时，异步初始化cache，初始化完成触发PathChildrenCacheEvent.Type#INITIALIZED事件，cache中Listener会收到该事件的通知。</p> 
<p>最后是第一个枚举常量，NORMAL：启动时，异步初始化cache，完成后不会发出通知。</p> 
<p>使用PathChildrenCache来监听节点的事件，完整的实例代码如下：</p> 
<pre><code>
    @Test
    public void testPathChildrenCache() {

        //检查节点是否存在，没有则创建
        boolean isExist = ZKclient.instance.isNodeExist(workerPath);
        if (!isExist) {
            ZKclient.instance.createNode(workerPath, null);
        }

        CuratorFramework client = ZKclient.instance.getClient();

        try {
            PathChildrenCache cache =
                    new PathChildrenCache(client, workerPath, true);
            PathChildrenCacheListener l =
                    new PathChildrenCacheListener() {
                        @Override
                        public void childEvent(CuratorFramework client,
                                               PathChildrenCacheEvent event) {
                            try {
                                ChildData data = event.getData();
                                switch (event.getType()) {
                                    case CHILD_ADDED:

                                        log.info("子节点增加, path={}, data={}",
                                                data.getPath(), new String(data.getData(), "UTF-8"));

                                        break;
                                    case CHILD_UPDATED:
                                        log.info("子节点更新, path={}, data={}",
                                                data.getPath(), new String(data.getData(), "UTF-8"));
                                        break;
                                    case CHILD_REMOVED:
                                        log.info("子节点删除, path={}, data={}",
                                                data.getPath(), new String(data.getData(), "UTF-8"));
                                        break;
                                    default:
                                        break;
                                }

                            } catch (
                                    UnsupportedEncodingException e) {
                                e.printStackTrace();
                            }
                        }
                    };
            cache.getListenable().addListener(l);
            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);
            Thread.sleep(1000);
            for (int i = 0; i &lt; 3; i++) {
                ZKclient.instance.createNode(subWorkerPath + i, null);
            }

            Thread.sleep(1000);
            for (int i = 0; i &lt; 3; i++) {
                ZKclient.instance.deleteNode(subWorkerPath + i);
            }

             } catch (Exception e) {
            log.error("PathCache监听失败, path=", workerPath);
        }

    }

</code></pre> 
<p>运行的结果如下：</p> 
<pre><code>\- 子节点增加, path=/test/listener/node/id-0, data=to set content

\- 子节点增加, path=/test/listener/node/id-2, data=to set content

\- 子节点增加, path=/test/listener/node/id-1, data=to set content

......

\- 子节点删除, path=/test/listener/node/id-2, data=to set content

\- 子节点删除, path=/test/listener/node/id-0, data=to set content

\- 子节点删除, path=/test/listener/node/id-1, data=to set content

</code></pre> 
<p>可以看到，PathChildrenCache 能够反复的监听到节点的新增和删除。</p> 
<p>简单说下Curator的监听原理，无论是PathChildrenCache，还是TreeCache，所谓的监听，都是进行Curator本地缓存视图和ZooKeeper服务器远程的数据节点的对比。</p> 
<p>在什么场景下触发事件呢？</p> 
<p>以节点增加事件NODE_ADDED为例，所在本地缓存视图开始的时候，本地视图为空，在数据同步的时候，本地的监听器就能监听到NODE_ADDED事件。这是因为，刚开始本地缓存并没有内容，然后本地缓存和服务器缓存进行对比，发现ZooKeeper服务器有节点而本地缓存没有，这才将服务器的节点缓存到本地，就会触发本地缓存的NODE_ADDED事件。</p> 
<h3><a id="114_Tree_Cache__542"></a>1.1.4. Tree Cache 节点树缓存</h3> 
<p>前面已经讲完了两个系列的缓存监听。简单回顾一下：</p> 
<p>Node Cache用来观察ZNode自身，如果ZNode节点本身被创建，更新或者删除，那么Node Cache会更新缓存，并触发事件给注册的监听器。Node Cache是通过NodeCache类来实现的，监听器对应的接口为NodeCacheListener。</p> 
<p>Path Cache子节点缓存用来观察ZNode的子节点、并缓存子节点的状态，如果ZNode的子节点被创建，更新或者删除，那么Path Cache会更新缓存，并且触发事件给注册的监听器。Path Cache是通过PathChildrenCache类来实现的，监听器注册是通过PathChildrenCacheListener。</p> 
<p>最后的一个系列，是Tree Cache。Tree Cache可以看做是上两种的合体，Tree Cache观察的是当前ZNode节点的所有数据。而TreeCache节点树缓存是PathChildrenCache的增强，不光能监听子节点，也能监听节点自身。</p> 
<p>Tree Cache使用的第一步，就是构造一个TreeCache缓存实例。</p> 
<p>有两个构造方法，具体如下：</p> 
<pre><code>TreeCache(CuratorFramework client, String path) 
 

TreeCache(CuratorFramework client, String path,
          boolean cacheData, boolean dataIsCompressed, int maxDepth, 
		 ExecutorService executorService, boolean createParentNodes,
		 TreeCacheSelector selector) 
</code></pre> 
<p>第一个参数就是传入创建的Curator的框架客户端，第二个参数就是监听节点的路径，第三个重载参数dataIsCompressed 表示是否对数据进行压缩。maxDepth表示缓存的层次深度，默认为整数最大值。executorService 表示监听的的执行线程池，默认会创建一个单一线程的线程池。createParentNodes 表示是否创建父亲节点，默认为false。</p> 
<p>一般情况下，使用第一个构造函数即可。</p> 
<p>TreeCache使用的第二步，就是构造一个TreeCacheListener监听器实例。该接口的定义如下：</p> 
<pre><code>package org.apache.curator.framework.recipes.cache;

 import org.apache.curator.framework.CuratorFramework;

public interface TreeCacheListener {
    void childEvent(CuratorFramework var1, TreeCacheEvent var2) throws Exception;

}
</code></pre> 
<p>TreeCacheListener 监听器接口中，也只定义了一个简单的方法 childEvent，当子节点有变化时，这个方法就会被回调到。</p> 
<p>在创建完TreeCacheListener 的实例之后，使用缓存实例的addListener方法，将TreeCacheListener 监听器实例注册到TreeCache 缓存实例。 然后使用缓存实例nodeCache的start方法，启动节点的事件监听。</p> 
<p>整个实例的代码如下：</p> 
<pre><code> @Test
    public void testTreeCache() {

        //检查节点是否存在，没有则创建
        boolean isExist = ZKclient.instance.isNodeExist(workerPath);
        if (!isExist) {
            ZKclient.instance.createNode(workerPath, null);
        }

        CuratorFramework client = ZKclient.instance.getClient();

        try {
            TreeCache treeCache  =
                    new TreeCache(client, workerPath);
            TreeCacheListener l =
                    new TreeCacheListener() {
                        @Override
                        public void childEvent(CuratorFramework client,
                                               TreeCacheEvent event) {
                            try {
                                ChildData data = event.getData();
                                if(data==null)
                                {
                                    log.info("数据为空");
                                    return;
                                }
                                switch (event.getType()) {
                                    case NODE_ADDED:

                                        log.info("[TreeCache]节点增加, path={}, data={}",
                                                data.getPath(), new String(data.getData(), "UTF-8"));

                                        break;
                                    case NODE_UPDATED:
                                        log.info("[TreeCache]节点更新, path={}, data={}",
                                                data.getPath(), new String(data.getData(), "UTF-8"));
                                        break;
                                    case NODE_REMOVED:
                                        log.info("[TreeCache]节点删除, path={}, data={}",
                                                data.getPath(), new String(data.getData(), "UTF-8"));
                                        break;
                                    default:
                                        break;
                                }

                            } catch (
                                    UnsupportedEncodingException e) {
                                e.printStackTrace();
                            }
                        }
                    };
            treeCache.getListenable().addListener(l);
            treeCache.start();
            Thread.sleep(1000);
            for (int i = 0; i &lt; 3; i++) {
                ZKclient.instance.createNode(subWorkerPath + i, null);
            }

            Thread.sleep(1000);
            for (int i = 0; i &lt; 3; i++) {
                ZKclient.instance.deleteNode(subWorkerPath + i);
            }
            Thread.sleep(1000);

            ZKclient.instance.deleteNode(workerPath);

            Thread.sleep(Integer.MAX_VALUE);

        } catch (Exception e) {
            log.error("PathCache监听失败, path=", workerPath);
        }

    }

</code></pre> 
<p>运行的结果如下：</p> 
<pre><code>\- [TreeCache]节点增加, path=/test/listener/node, data=to set content

 

\- [TreeCache]节点增加, path=/test/listener/node/id-0, data=to set content

\- [TreeCache]节点增加, path=/test/listener/node/id-1, data=to set content

\- [TreeCache]节点增加, path=/test/listener/node/id-2, data=to set content

 

\- [TreeCache]节点删除, path=/test/listener/node/id-2, data=to set content

\- [TreeCache]节点删除, path=/test/listener/node/id-1, data=to set content

\- [TreeCache]节点删除, path=/test/listener/node/id-0, data=to set content

 

\- [TreeCache]节点删除, path=/test/listener/node, data=to set content

</code></pre> 
<p>最后，说明下事件的类型，对应于节点的增加、修改、删除，TreeCache 的事件类型为：</p> 
<p>（1）NODE_ADDED</p> 
<p>（2）NODE_UPDATED</p> 
<p>（3）NODE_REMOVED</p> 
<p>这一点，与Path Cache 的事件类型不同，与Path Cache 的事件类型为：</p> 
<p>（1）CHILD_ADDED</p> 
<p>（2）CHILD_UPDATED</p> 
<p>（3）CHILD_REMOVED</p> 
<h3><a id="_735"></a>写在最后</h3> 
<p>​</p> 
<p>​ 下一篇：基于zk，实现分布式锁。</p> 
<hr> 
<h3><a id="___IM___749"></a>疯狂创客圈 亿级流量 高并发IM 实战 系列</h3> 
<ul><li><strong>Java (Netty) 聊天程序【 亿级流量】实战 开源项目实战</strong></li></ul> 
<ul><li><strong>Netty 源码、原理、JAVA NIO 原理</strong></li><li><strong>Java 面试题 一网打尽</strong></li><li>疯狂创客圈 <a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow"><strong>【 博客园 总入口 】</strong></a></li></ul> 
<hr> 
<pre><code>
</code></pre> 
<pre><code>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/991a2d0e18b6b0e348097fbbf3383027/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">部署工具(deploy-tool)开源拉！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b544d85c9e254fb52729d3622d138602/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">报错：unrecognized command line option ‘-std=c&#43;&#43;11’</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>