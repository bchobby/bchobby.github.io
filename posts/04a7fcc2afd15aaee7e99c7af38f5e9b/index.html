<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>celery概述 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="celery概述" />
<meta property="og:description" content="目录
1. 问题抛出
celery介绍
1. 快速入门（一）
1.1 Task Queue
1.2 celery 安装
1.3 broker
1.RabbitMQ
2.Redis
1.4 Application
1.创建应用
2.调用任务
3.存储结果
1.5 配置
1.直接通过app来配置
2.专有配置文件
2. 快速入门（二）
2.1 项目中使用celery
2.2 调用任务（Calling Task）
2.3 Designing Work-Flows
1. signature
2. Primitives
2.4 Routing
3. Periodic Tasks
4. Django调用celery
4.1 配置celery
1. 配置celery
4.2 保存任务结果
2. 存储任务结果
4.3 定时任务
3. 定时任务
1. 问题抛出 我们在做网站后端程序开发时，会碰到这样的需求：用户需要在我们的网站填写注册信息，我们发给用户一封注册激活邮件到用户邮箱，如果由于各种原因，这封邮件发送所需时间较长，那么客户端将会等待很久，造成不好的用户体验.
那么怎么解决这样的问题呢?
我们将耗时任务放到后台异步执行。不会影响用户其他操作。除了注册功能，例如上传，图形处理等等耗时的任务，都可以按照这种思路来解决。 如何实现异步执行任务呢？我们可使用celery。celery除了刚才所涉及到的异步执行任务之外，还可以实现定时处理某些任务。
celery介绍 Celery是一个功能完备即插即用的任务队列。它使得我们不需要考虑复杂的问题，使用非常简单。celery看起来似乎很庞大，本章节我们先对其进行简单的了解，然后再去学习其他一些高级特性。 celery适用异步处理问题，当发送邮件、或者文件上传, 图像处理等等一些比较耗时的操作，我们可将其异步执行，这样用户不需要等待很久，提高用户体验。 celery的特点是：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/04a7fcc2afd15aaee7e99c7af38f5e9b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-02T12:19:25+08:00" />
<meta property="article:modified_time" content="2020-11-02T12:19:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">celery概述</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1-问题抛出-toc" style="margin-left:0px;"><a href="#1-%E9%97%AE%E9%A2%98%E6%8A%9B%E5%87%BA" rel="nofollow">1. 问题抛出</a></p> 
<p id="celery介绍-toc" style="margin-left:40px;"><a href="#celery%E4%BB%8B%E7%BB%8D" rel="nofollow">celery介绍</a></p> 
<p id="1.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89-toc" style="margin-left:0px;"><a href="#1.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89" rel="nofollow">1. 快速入门（一）</a></p> 
<p id="1.1%20Task%20Queue-toc" style="margin-left:40px;"><a href="#1.1%20Task%20Queue" rel="nofollow">1.1 Task Queue</a></p> 
<p id="1.2%20celery%20%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#1.2%20celery%20%E5%AE%89%E8%A3%85" rel="nofollow">1.2 celery 安装</a></p> 
<p id="1.3%20broker-toc" style="margin-left:40px;"><a href="#1.3%20broker" rel="nofollow">1.3 broker</a></p> 
<p id="1rabbitmq-toc" style="margin-left:80px;"><a href="#1rabbitmq" rel="nofollow">1.RabbitMQ</a></p> 
<p id="2redis-toc" style="margin-left:80px;"><a href="#2redis" rel="nofollow">2.Redis</a></p> 
<p id="1.4%20Application-toc" style="margin-left:40px;"><a href="#1.4%20Application" rel="nofollow">1.4 Application</a></p> 
<p id="1创建应用-toc" style="margin-left:80px;"><a href="#1%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8" rel="nofollow">1.创建应用</a></p> 
<p id="2调用任务-toc" style="margin-left:80px;"><a href="#2%E8%B0%83%E7%94%A8%E4%BB%BB%E5%8A%A1" rel="nofollow">2.调用任务</a></p> 
<p id="3存储结果-toc" style="margin-left:80px;"><a href="#3%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%9C" rel="nofollow">3.存储结果</a></p> 
<p id="1.5%20%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#1.5%20%E9%85%8D%E7%BD%AE" rel="nofollow">1.5 配置</a></p> 
<p id="1直接通过app来配置-toc" style="margin-left:80px;"><a href="#1%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87app%E6%9D%A5%E9%85%8D%E7%BD%AE" rel="nofollow">1.直接通过app来配置</a></p> 
<p id="2专有配置文件-toc" style="margin-left:80px;"><a href="#2%E4%B8%93%E6%9C%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">2.专有配置文件</a></p> 
<p id="2.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-toc" style="margin-left:0px;"><a href="#2.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89" rel="nofollow">2. 快速入门（二）</a></p> 
<p id="2.1%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8celery-toc" style="margin-left:40px;"><a href="#2.1%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8celery" rel="nofollow">2.1 项目中使用celery</a></p> 
<p id="2.2%20%E8%B0%83%E7%94%A8%E4%BB%BB%E5%8A%A1%EF%BC%88Calling%20Task%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%20%E8%B0%83%E7%94%A8%E4%BB%BB%E5%8A%A1%EF%BC%88Calling%20Task%EF%BC%89" rel="nofollow">2.2 调用任务（Calling Task）</a></p> 
<p id="2.3%20Designing%20Work-Flows-toc" style="margin-left:40px;"><a href="#2.3%20Designing%20Work-Flows" rel="nofollow">2.3 Designing Work-Flows</a></p> 
<p id="1-signature-toc" style="margin-left:80px;"><a href="#1-signature" rel="nofollow">1. signature</a></p> 
<p id="2-primitives-toc" style="margin-left:80px;"><a href="#2-primitives" rel="nofollow">2. Primitives</a></p> 
<p id="2.4%20Routing-toc" style="margin-left:40px;"><a href="#2.4%20Routing" rel="nofollow">2.4 Routing</a></p> 
<p id="3.%20Periodic%20Tasks-toc" style="margin-left:0px;"><a href="#3.%20Periodic%20Tasks" rel="nofollow">3. Periodic Tasks</a></p> 
<p id="4.%20Django%E8%B0%83%E7%94%A8celery-toc" style="margin-left:0px;"><a href="#4.%20Django%E8%B0%83%E7%94%A8celery" rel="nofollow">4. Django调用celery</a></p> 
<p id="4.1%20%E9%85%8D%E7%BD%AEcelery-toc" style="margin-left:40px;"><a href="#4.1%20%E9%85%8D%E7%BD%AEcelery" rel="nofollow">4.1 配置celery</a></p> 
<p id="1-配置celery-toc" style="margin-left:80px;"><a href="#1-%E9%85%8D%E7%BD%AEcelery" rel="nofollow">1. 配置celery</a></p> 
<p id="4.2%20%E4%BF%9D%E5%AD%98%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#4.2%20%E4%BF%9D%E5%AD%98%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C" rel="nofollow">4.2 保存任务结果</a></p> 
<p id="2-存储任务结果-toc" style="margin-left:80px;"><a href="#2-%E5%AD%98%E5%82%A8%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C" rel="nofollow">2. 存储任务结果</a></p> 
<p id="4.3%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-toc" style="margin-left:40px;"><a href="#4.3%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" rel="nofollow">4.3 定时任务</a></p> 
<p id="3-定时任务-toc" style="margin-left:80px;"><a href="#3-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" rel="nofollow">3. 定时任务</a></p> 
<hr id="hr-toc"> 
<h2 id="1-问题抛出"><strong>1. 问题抛出</strong></h2> 
<blockquote> 
 <p>我们在做网站后端程序开发时，会碰到这样的需求：用户需要在我们的网站填写注册信息，我们发给用户一封注册激活邮件到用户邮箱，如果由于各种原因，这封邮件发送所需时间较长，那么客户端将会等待很久，造成不好的用户体验.</p> 
 <p><img alt="" height="249" src="https://images2.imgbox.com/8f/78/OS0uyHa6_o.png" width="1200"></p> 
 <p> </p> 
 <p>那么怎么解决这样的问题呢?</p> 
 <p><img alt="" height="514" src="https://images2.imgbox.com/cd/3f/MDGR0Yqj_o.png" width="1200"></p> 
 <p> </p> 
 <p>我们将耗时任务放到后台异步执行。不会影响用户其他操作。除了注册功能，例如上传，图形处理等等耗时的任务，都可以按照这种思路来解决。 如何实现异步执行任务呢？我们可使用celery。celery除了刚才所涉及到的异步执行任务之外，还可以实现定时处理某些任务。</p> 
</blockquote> 
<h3 id="celery介绍">celery介绍</h3> 
<blockquote> 
 <p>Celery是一个功能完备即插即用的任务队列。它使得我们不需要考虑复杂的问题，使用非常简单。celery看起来似乎很庞大，本章节我们先对其进行简单的了解，然后再去学习其他一些高级特性。 celery适用异步处理问题，当发送邮件、或者文件上传, 图像处理等等一些比较耗时的操作，我们可将其异步执行，这样用户不需要等待很久，提高用户体验。 celery的特点是：</p> 
 <ul><li>简单，易于使用和维护，有丰富的文档。</li><li>高效，单个celery进程每分钟可以处理数百万个任务。</li><li>灵活，celery中几乎每个部分都可以自定义扩展。</li></ul> 
 <p>celery非常易于集成到一些web开发框架中。</p> 
</blockquote> 
<h2 id="1.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89">1. 快速入门（一）</h2> 
<h3 id="1.1%20Task%20Queue">1.1 Task Queue</h3> 
<p>        任务队列是一种跨线程、跨机器工作的一种机制.</p> 
<p>  任务队列中包含称作任务的工作单元。有专门的工作进程持续不断的监视任务队列，并从中获得新的任务并处理.</p> 
<p>  celery通过消息进行通信，通常使用一个叫Broker(中间人)来协client(任务的发出者)和worker(任务的处理者). clients发出消息到队列中，broker将队列中的信息派发给worker来处理。</p> 
<p>  一个celery系统可以包含很多的worker和broker，可增强横向扩展性和高可用性能。</p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/1b/0b/h7MAx1v5_o.png" width="1200"></p> 
<h3 id="1.2%20celery%20%E5%AE%89%E8%A3%85">1.2 celery 安装</h3> 
<blockquote> 
 <p>我们可以使用python的包管理器pip来安装:</p> 
</blockquote> 
<pre><code>pip install -U Celery
</code></pre> 
<blockquote> 
 <p>也可从官方直接下载安装包:<a href="https://pypi.python.org/pypi/celery/" rel="nofollow">https://pypi.python.org/pypi/celery/</a></p> 
</blockquote> 
<pre><code>tar xvfz celery-0.0.0.tar.gz
cd celery-0.0.0
python setup.py build
python setup.py install</code></pre> 
<h3 id="1.3%20broker">1.3 broker</h3> 
<blockquote> 
 <p>Celery需要一种解决消息的发送和接受的方式，我们把这种用来存储消息的的中间装置叫做message broker, 也可叫做消息中间人。 作为中间人，我们有几种方案可选择：</p> 
</blockquote> 
<h4 id="1rabbitmq"><strong>1.RabbitMQ</strong></h4> 
<p>RabbitMQ是一个功能完备，稳定的并且易于安装的broker. 它是生产环境中最优的选择。使用RabbitMQ的细节参照以下链接： <a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/rabbitmq.html#broker-rabbitmq" rel="nofollow">http://docs.celeryproject.org/en/latest/getting-started/brokers/rabbitmq.html#broker-rabbitmq</a></p> 
<p>如果我们使用的是Ubuntu或者Debian发行版的Linux，可以直接通过下面的命令安装RabbitMQ: sudo apt-get install rabbitmq-server 安装完毕之后，RabbitMQ-server服务器就已经在后台运行。如果您用的并不是Ubuntu或Debian, 可以在以下网址： <a href="http://www.rabbitmq.com/download.html" rel="nofollow">http://www.rabbitmq.com/download.html</a> 去查找自己所需要的版本软件。</p> 
<h4 id="2redis"><strong>2.Redis</strong></h4> 
<p>Redis也是一款功能完备的broker可选项，但是其更可能因意外中断或者电源故障导致数据丢失的情况。 关于是用那个Redis作为Broker，可访下面网址： <a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html#broker-redis" rel="nofollow">http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html#broker-redis</a></p> 
<h3 id="1.4%20Application">1.4 Application</h3> 
<p>使用celery第一件要做的最为重要的事情是需要先创建一个Celery实例，我们一般叫做celery应用，或者更简单直接叫做一个app。app应用是我们使用celery所有功能的入口，比如创建任务，管理任务等，在使用celery的时候，app必须能够被其他的模块导入。</p> 
<h4 id="1创建应用"><strong>1.创建应用</strong></h4> 
<p>我们首先创建tasks.py模块, 其内容为:</p> 
<pre><code>from celery import Celery

# 我们这里案例使用redis作为broker
app = Celery('demo', broker='redis://:332572@127.0.0.1/1')

# 创建任务函数
@app.task
def my_task():
    print("任务函数正在执行....")
</code></pre> 
<p>  Celery第一个参数是给其设定一个名字， 第二参数我们设定一个中间人broker, 在这里我们使用Redis作为中间人。my_task函数是我们编写的一个任务函数， 通过加上装饰器app.task, 将其注册到broker的队列中。</p> 
<p>  现在我们在创建一个worker， 等待处理队列中的任务.打开终端，cd到tasks.py同级目录中，执行命令:</p> 
<pre><code>celery -A tasks worker --loglevel=info
</code></pre> 
<p>显示效果如下: </p> 
<p><img alt="" height="1142" src="https://images2.imgbox.com/b3/f0/C2JwMP0B_o.png" width="1200"></p> 
<h4 id="2调用任务">2.调用任务</h4> 
<p>  任务加入到broker队列中，以便刚才我们创建的celery workder服务器能够从队列中取出任务并执行。如何将任务函数加入到队列中，可使用delay()。</p> 
<p>进入python终端, 执行如下代码:</p> 
<pre><code>from tasks import my_task
my_task.delay()
</code></pre> 
<p>执行效果如下: </p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/87/23/d7PnEfn2_o.png" width="1200">我们通过worker的控制台，可以看到我们的任务被worker处理。调用一个任务函数，将会返回一个AsyncResult对象，这个对象可以用来检查任务的状态或者获得任务的返回值。</p> 
<h4 id="3存储结果">3.存储结果</h4> 
<p>  如果我们想跟踪任务的状态，Celery需要将结果保存到某个地方。有几种保存的方案可选：SQLAlchemy、Django ORM、Memcached、 Redis、RPC (RabbitMQ/AMQP)。</p> 
<p>  例子我们仍然使用Redis作为存储结果的方案，任务结果存储配置我们通过Celery的backend参数来设定。我们将tasks模块修改如下:</p> 
<pre><code>from celery import Celery

# 我们这里案例使用redis作为broker
app = Celery('demo',
             backend='redis://:332572@127.0.0.1:6379/2',
             broker='redis://:332572@127.0.0.1:6379/1')

# 创建任务函数
@app.task
def my_task(a, b):
    print("任务函数正在执行....")
    return a + b
</code></pre> 
<p>  我们给Celery增加了backend参数，指定redis作为结果存储,并将任务函数修改为两个参数，并且有返回值。 </p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/9f/a3/NQXMrqjy_o.png" width="1200"></p> 
<p>更多关于result对象信息，请参阅下列网址: <a href="http://docs.celeryproject.org/en/latest/reference/celery.result.html#module-celery.result" rel="nofollow">http://docs.celeryproject.org/en/latest/reference/celery.result.html#module-celery.result</a></p> 
<h3 id="1.5%20%E9%85%8D%E7%BD%AE">1.5 配置</h3> 
<p>Celery使用简单，配置也非常简单。Celery有很多配置选项能够使得celery能够符合我们的需要，但是默认的几项配置已经足够应付大多数应用场景了。</p> 
<p>  配置信息可以直接在app中设置，或者通过专有的配置模块来配置。</p> 
<h4 id="1直接通过app来配置">1.直接通过app来配置</h4> 
<pre><code>from celery import Celery
app = Celery('demo')
# 增加配置
app.conf.update(
    result_backend='redis://:332572@127.0.0.1:6379/2',
    broker_url='redis://:332572@127.0.0.1:6379/1',
)
</code></pre> 
<h4 id="2专有配置文件">2.专有配置文件</h4> 
<p>  对于比较大的项目，我们建议配置信息作为一个单独的模块。我们可以通过调用app的函数来告诉Celery使用我们的配置模块。</p> 
<p>  配置模块的名字我们取名为celeryconfig, 这个名字不是固定的，我们可以任意取名，建议这么做。我们必须保证配置模块能够被导入。 配置模块的名字我们取名为celeryconfig, 这个名字不是固定的，我们可以任意取名，建议这么做。我们必须保证配置模块能够被导入。</p> 
<p>  下面我们在tasks.py模块 同级目录下创建配置模块celeryconfig.py:</p> 
<pre><code>result_backend = 'redis://:332572@127.0.0.1:6379/2'
broker_url = 'redis://:332572@127.0.0.1:6379/1'
</code></pre> 
<p>  tasks.py文件修改为:</p> 
<pre><code>from celery import Celery
import celeryconfig

# 我们这里案例使用redis作为broker
app = Celery('demo')

# 从单独的配置模块中加载配置
app.config_from_object('celeryconfig')
</code></pre> 
<p>更多配置: <a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#configuration" rel="nofollow">http://docs.celeryproject.org/en/latest/userguide/configuration.html#configuration</a></p> 
<h2 id="2.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89">2. 快速入门（二）</h2> 
<h3 id="2.1%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8celery">2.1 项目中使用celery</h3> 
<p>我的项目目录:</p> 
<p>TestCelery/ ├── proj │ ├── celeryconfig.py │ ├── celery.py │ ├── <strong>init</strong>.py │ └── tasks.py └── test.py</p> 
<p>  celery.py内容如下:</p> 
<pre><code>from celery import Celery

# 创建celery实例
app = Celery('demo')
app.config_from_object('proj.celeryconfig')

# 自动搜索任务
app.autodiscover_tasks(['proj'])
</code></pre> 
<p>  celeryconfig.p模块内容如下：</p> 
<pre><code>from kombu import Exchange, Queue
BROKER_URL = 'redis://:332572@127.0.0.1:6379/1'
CELERY_RESULT_BACKEND = 'redis://:332572@127.0.0.1:6379/2'
</code></pre> 
<p>  tasks.py模块内容如下:</p> 
<pre><code>from proj.celery import app as celery_app

# 创建任务函数
@celery_app.task
def my_task1():
    print("任务函数(my_task1)正在执行....")

@celery_app.task
def my_task2():
    print("任务函数(my_task2)正在执行....")

@celery_app.task
def my_task3():
    print("任务函数(my_task3)正在执行....")
</code></pre> 
<p>  启动worker:</p> 
<pre><code>celery -A proj worker -l info
</code></pre> 
<p><img alt="" height="1196" src="https://images2.imgbox.com/45/6b/9D9zAdPS_o.png" width="1200"></p> 
<p> 键入ctrl+c可关闭worker.</p> 
<h3 id="2.2%20%E8%B0%83%E7%94%A8%E4%BB%BB%E5%8A%A1%EF%BC%88Calling%20Task%EF%BC%89">2.2 调用任务（Calling Task）</h3> 
<p>调用任务，可使用delay()方法:</p> 
<pre><code>my_task.delay(2, 2)
</code></pre> 
<p>  也可以使用apply_async()方法，该方法可让我们设置一些任务执行的参数，例如，任务多久之后才执行，任务被发送到那个队列中等等.</p> 
<pre><code>my_task.apply_async((2, 2), queue='my_queue', countdown=10)
</code></pre> 
<p>任务my_task将会被发送到my_queue队列中，并且在发送10秒之后执行。</p> 
<p>  如果我们直接执行任务函数，将会直接执行此函数在当前进程中，并不会向broker发送任何消息。</p> 
<p>  无论是delay()还是apply_async()方式都会返回AsyncResult对象，方便跟踪任务执行状态，但需要我们配置result_backend.</p> 
<p>  每一个被吊用的任务都会被分配一个ID，我们叫Task ID。</p> 
<h3 id="2.3%20Designing%20Work-Flows">2.3 Designing Work-Flows</h3> 
<h4 id="1-signature"><strong>1. signature</strong></h4> 
<p>  我们到目前为止只是学习了如何使用delay()方法，当然这个方法也是非常常用的。但是有时我们并不想简单的将任务发送到队列中，我们想将一个任务函数(由参数和执行选项组成)作为一个参数传递给另外一个函数中，为了实现此目标，Celery使用一种叫做signatures的东西。</p> 
<p>  一个signature包装了一个参数和执行选项的单个任务调用。我们可将这个signature传递给函数。</p> 
<p>  我们先看下tasks.py模块中定义的任务函数:</p> 
<pre><code>from proj.celery import app as celery_app

# 创建任务函数
@celery_app.task
def my_task1():
    print("任务函数(my_task1)正在执行....")

@celery_app.task
def my_task2():
    print("任务函数(my_task2)正在执行....")

@celery_app.task
def my_task3():
    print("任务函数(my_task3)正在执行....")
</code></pre> 
<p>  我们将my_task1()任务包装称一个signature:</p> 
<pre><code>t1 = my_task1.signatures(countdown=10)
t1.delay()
</code></pre> 
<h4 id="2-primitives"><strong>2. Primitives</strong></h4> 
<p>  这些primitives本身就是signature对象，因此它们可以以多种方式组合成复杂的工作流程。primitives如下:</p> 
<p>  group: 一组任务并行执行，返回一组返回值，并可以按顺序检索返回值。</p> 
<p>  chain: 任务一个一个执行，一个执行完将执行return结果传递给下一个任务函数.</p> 
<p>  tasks.py模块如下:</p> 
<pre><code>from proj.celery import app as celery_app

# 创建任务函数
@celery_app.task
def my_task1(a, b):
    print("任务函数(my_task1)正在执行....")
    return a + b

@celery_app.task
def my_task2(a, b):
    print("任务函数(my_task2)正在执行....")
    return a + b

@celery_app.task
def my_task3(a, b):
    print("任务函数(my_task3)正在执行....")
    return a + b
</code></pre> 
<p>  group案例如下(test.py模块):</p> 
<pre><code>from proj.tasks import my_task1
from proj.tasks import my_task2
from proj.tasks import my_task3
from celery import group

# 将多个signature放入同一组中
my_group = group((my_task1.s(10, 10), my_task2.s(20, 20), my_task3.s(30, 30)))
ret = my_group() # 执行组任务
print(ret.get())  # 输出每个任务结果
</code></pre> 
<p><img alt="" height="583" src="https://images2.imgbox.com/dc/a2/x3VCZB8C_o.png" width="1154"></p> 
<p>   chain案例如下(test.py模块):</p> 
<pre><code>from proj.tasks import my_task1
from proj.tasks import my_task2
from proj.tasks import my_task3
from celery import chain

# 将多个signature组成一个任务链
# my_task1的运行结果将会传递给my_task2
# my_task2的运行结果会传递给my_task3
my_chain = chain(my_task1.s(10, 10) | my_task2.s(20) | my_task3.s(30))
ret = my_chain()  # 执行任务链
print(ret.get())  # 输出最终结果</code></pre> 
<p><img alt="" height="567" src="https://images2.imgbox.com/28/0f/W4mMjizt_o.png" width="1128"></p> 
<h3 id="2.4%20Routing">2.4 Routing</h3> 
<p style="text-indent:33px;">假如我们有两个worker,一个worker专门用来处理邮件发送任务和图像处理任务，一个worker专门用来处理文件上传任务。</p> 
<p>  我们创建两个队列，一个专门用于存储邮件任务队列和图像处理，一个用来存储文件上传任务队列。</p> 
<p>  Celery支持AMQP(Advanced Message Queue)所有的路由功能，我们也可以使用简单的路由设置将指定的任务发送到指定的队列中.</p> 
<p>  我们需要配置在celeryconfig.py模块中配置 CELERY_ROUTES 项, tasks.py模块修改如下:</p> 
<pre><code>from proj.celery import app as celery_app


@celery_app.task
def my_task1(a, b):
    print("my_task1任务正在执行....")
    return a + b


@celery_app.task
def my_task2(a, b):
    print("my_task2任务正在执行....")
    return a + b


@celery_app.task
def my_task3(a, b):
    print("my_task3任务正在执行....")
    return a + b


@celery_app.task
def my_task4(a, b):
    print("my_task3任务正在执行....")
    return a + b


@celery_app.task
def my_task5():
    print("my_task5任务正在执行....")


@celery_app.task
def my_task6():
    print("my_task6任务正在执行....")


@celery_app.task
def my_task7():
    print("my_task7任务正在执行....")
</code></pre> 
<p>  我们通过配置，将send_email和upload_file任务发送到queue1队列中，将image_process发送到queue2队列中。</p> 
<p>  我们修改celeryconfig.py:</p> 
<pre><code>broker_url='redis://:@127.0.0.1:6379/1'
result_backend='redis://:@127.0.0.1:6379/2'


task_routes=({
    'proj.tasks.my_task5': {'queue': 'queue1'},
    'proj.tasks.my_task6': {'queue': 'queue1'},
    'proj.tasks.my_task7': {'queue': 'queue2'},
    },
)
</code></pre> 
<p>  test.py:</p> 
<pre><code>from proj.tasks import *

# 发送任务到路由指定的队列中
</code></pre> 
<p>my_task5.delay() my_task6.delay() my_task7.delay()</p> 
<pre><code>&amp;emsp;&amp;emsp;开启两个worker服务器，分别处理两个队列：
```python
celery -A proj worker --loglevel=info -Q queue1
celery -A proj worker --loglevel=info -Q queue2
</code></pre> 
<p>  我们同样也可以通过apply_aynsc()方法来设置任务发送到那个队列中:</p> 
<pre><code>my_task1.apply_async(queue='queue1')
</code></pre> 
<p>  我们也可设置一个worker服务器处理两个队列中的任务:</p> 
<pre><code>celery -A proj worker --loglevel=info -Q queue1,queue2</code></pre> 
<h2 id="3.%20Periodic%20Tasks">3. Periodic Tasks</h2> 
<p>celery beat是一个调度器，它可以周期内指定某个worker来执行某个任务。如果我们想周期执行某个任务需要增加beat_schedule配置信息.  </p> 
<pre><code>broker_url='redis://:@127.0.0.1:6379/1'
result_backend='redis://:@127.0.0.1:6379/2'

# 指定任务发到那个队列中
task_routes=({
    'proj.tasks.my_task5': {'queue': 'queue1'},
    'proj.tasks.my_task6': {'queue': 'queue1'},
    'proj.tasks.my_task7': {'queue': 'queue2'},
    },
)


# 配置周期性任务，　或者定时任务
beat_schedule = {
    'every-5-seconds':
        {
            'task': 'proj.tasks.my_task8',
            'schedule': 5.0,
            # 'args': (16, 16),
        }
}
</code></pre> 
<p>  tasks.py模块内容如下:</p> 
<pre><code>from proj.celery import app as celery_app


@celery_app.task
def my_task1(a, b):
    print("my_task1任务正在执行....")
    return a + b


@celery_app.task
def my_task2(a, b):
    print("my_task2任务正在执行....")
    return a + b


@celery_app.task
def my_task3(a, b):
    print("my_task3任务正在执行....")
    return a + b


@celery_app.task
def my_task4(a, b):
    print("my_task3任务正在执行....")
    return a + b


@celery_app.task
def my_task5():
    print("my_task5任务正在执行....")




@celery_app.task
def my_task6():
    print("my_task6任务正在执行....")



@celery_app.task
def my_task7():
    print("my_task7任务正在执行....")


# 周期执行任务
@celery_app.task
def my_task8():
    print("my_task8任务正在执行....")
</code></pre> 
<p>  启动woker处理周期性任务:</p> 
<pre><code>celery -A proj worker --loglevel=info --beat
</code></pre> 
<p>  如果我们想指定在某天某时某分某秒执行某个任务，可以执行cron任务, 增加配置信息如下:</p> 
<pre><code>beat_schedule = {
    'every-5-minute':
        {
            'task': 'proj.tasks.period_task',
            'schedule': 5.0,
            'args': (16, 16),
        },
    'add-every-monday-morning': {
        'task': 'proj.tasks.period_task',
        'schedule': crontab(hour=7, minute=30, day_of_week=1),
        'args': (16, 16),
    },

}
</code></pre> 
<p>crontab例子: <a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html" rel="nofollow">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a></p> 
<p>  开启一个celery beat服务：</p> 
<pre><code>celery -A proj beat
</code></pre> 
<p>  celery需要保存上次任务运行的时间在数据文件中，文件在当前目录下名字叫celerybeat-schedule. beat需要访问此文件：</p> 
<pre><code>celery -A proj beat -s /home/celery/var/run/celerybeat-schedule</code></pre> 
<h2 id="4.%20Django%E8%B0%83%E7%94%A8celery">4. Django调用celery</h2> 
<h3 id="4.1%20%E9%85%8D%E7%BD%AEcelery">4.1 配置celery</h3> 
<h4 id="1-配置celery">1. 配置celery</h4> 
<p>  创建django项目celery_demo, 创建应用demo:</p> 
<pre><code>django-admin startproject celery_demo
python manage.py startapp demo
</code></pre> 
<p> </p> 
<p><img alt="" height="838" src="https://images2.imgbox.com/5d/7d/dPDCMrHi_o.png" width="1032"></p> 
<p>  在celery_demo模块中创建celery.py模块, 文件目录为:</p> 
<p><img alt="" height="884" src="https://images2.imgbox.com/f0/e7/kxsF4yyw_o.png" width="1022"></p> 
<p>   celery.py模块内容为:</p> 
<pre><code>from celery import Celery
from django.conf import settings
import os

# 为celery设置环境变量
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'celery_demo.settings')

# 创建应用
app = Celery("demo")
# 配置应用
app.conf.update(
    # 配置broker, 这里我们用redis作为broker
    BROKER_URL='redis://:332572@127.0.0.1:6379/1',
)
# 设置app自动加载任务
# 从已经安装的app中查找任务
app.autodiscover_tasks(settings.INSTALLED_APPS)
</code></pre> 
<p>  在应用demo引用创建tasks.py模块, 文件目录为: </p> 
<p><img alt="" height="930" src="https://images2.imgbox.com/ba/82/19VenKbp_o.png" width="908"></p> 
<p>  我们在文件内创建一个任务函数my_task:</p> 
<pre><code>from celery_demo.celery import app
import time

# 加上app对象的task装饰器
# 此函数为任务函数
@app.task
def my_task():
    print("任务开始执行....")
    time.sleep(5)
    print("任务执行结束....")
</code></pre> 
<p>  在views.py模块中创建视图index:</p> 
<pre><code>from django.shortcuts import render
from django.http import HttpResponse
from .tasks import my_task


def index(request):
# 将my_task任务加入到celery队列中
# 如果my_task函数有参数，可通过delay()传递
# 例如 my_task(a, b), my_task.delay(10, 20)
    my_task.delay()

    return HttpResponse("&lt;h1&gt;服务器返回响应内容!&lt;/h1&gt;")
</code></pre> 
<p>  在celey_demo/settings.py配置视图路由:</p> 
<pre><code>from django.conf.urls import url
from django.contrib import admin
from demo.views import index

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^$', index),
]
</code></pre> 
<p>  创建worker等待处理celery队列中任务, 在终端执行命令:</p> 
<pre><code>celery -A celery_demo worker -l info
</code></pre> 
<p><img alt="" height="523" src="https://images2.imgbox.com/71/04/h38uoJn4_o.png" width="1200"></p> 
<p>   启动django测试服务器：</p> 
<pre><code>python manage.py runserver
</code></pre> 
<p> </p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/10/34/2fBfjWD8_o.png" width="1200"></p> 
<h3 id="4.2%20%E4%BF%9D%E5%AD%98%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C">4.2 保存任务结果</h3> 
<h4 id="2-存储任务结果">2. 存储任务结果</h4> 
<p>  此处需要用到额外包django_celery_results, 先安装包:</p> 
<pre><code>pip install django-celery-results
</code></pre> 
<p>  在celery_demo/settings.py中安装此应用:</p> 
<pre><code>INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'demo',
    'django_celery_results',  # 注意此处应用名为下划线
]
</code></pre> 
<p>  回到celery_demo/celery.py模块中，增加配置信息如下:</p> 
<pre><code>from celery import Celery
from django.conf import settings
import os

# 为celery设置环境变量
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'celery_demo.settings')

# 创建应用
app = Celery("demo")
# 配置应用
app.conf.update(
    # 配置broker, 这里我们用redis作为broker
    BROKER_URL='redis://:332572@127.0.0.1:6379/1',
    # 使用项目数据库存储任务执行结果
    CELERY_RESULT_BACKEND='django-db',
)
# 设置app自动加载任务
# 从已经安装的app中查找任务
app.autodiscover_tasks(settings.INSTALLED_APPS)
</code></pre> 
<p>  创建django_celery_results应用所需数据库表, 执行迁移文件：</p> 
<pre><code>python manage.py migrate django_celery_results
</code></pre> 
<p>  我这里使用的是django默认的数据库sqlit, 执行迁移之后，会在数据库中创建一张用来存储任务结果的表: </p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/2d/83/niC0qE2s_o.png" width="802"></p> 
<p> </p> 
<p>  再次从浏览器发送请求， 任务执行结束之后，将任务结果保存在数据库中: </p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/3e/a9/YRFQa16r_o.png" width="1200"></p> 
<h3 id="4.3%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">4.3 定时任务</h3> 
<h4 id="3-定时任务">3. 定时任务</h4> 
<p>  如果我们想某日某时执行某个任务，或者每隔一段时间执行某个任务，也可以使用celery来完成.   使用定时任务，需要安装额外包:</p> 
<pre><code>pip install django_celery_beat
</code></pre> 
<p>  首先在settings.py中安装此应用:</p> 
<pre><code>INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'demo',
    'django_celery_results',
    'django_celery_beat',  # 安装应用
]
</code></pre> 
<p>  在celery_demo/celery.py模块中增加定时任务配置:</p> 
<pre><code>from celery import Celery
from django.conf import settings
import os

# 为celery设置环境变量
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'celery_demo.settings')

# 创建应用
app = Celery("demo")
# 配置应用
app.conf.update(
    # 配置broker, 这里我们用redis作为broker
    BROKER_URL='redis://:332572@127.0.0.1:6379/1',
    # 使用项目数据库存储任务执行结果
    CELERY_RESULT_BACKEND='django-db',
    # 配置定时器模块，定时器信息存储在数据库中
    CELERYBEAT_SCHEDULER='django_celery_beat.schedulers.DatabaseScheduler',

)
# 设置app自动加载任务
# 从已经安装的app中查找任务
app.autodiscover_tasks(settings.INSTALLED_APPS)
</code></pre> 
<p>  由于定时器信息存储在数据库中，我们需要先生成对应表, 对diango_celery_beat执行迁移操作，创建对应表:</p> 
<pre><code>python manage.py migrate django_celery_beat
</code></pre> 
<p> </p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/0d/e5/dJhM3BOI_o.png" width="974"></p> 
<p>  我们可登录网站后台Admin去创建对应任务, 首先我们先在tasks.py模块中增加新的任务，用于定时去执行(5秒执行一次)</p> 
<pre><code>from celery_demo.celery import app
import time

# 用于定时执行的任务
@app.task
def interval_task():
    print("我每隔5秒钟时间执行一次....")
</code></pre> 
<p>  首先创建后台管理员帐号:</p> 
<pre><code>python manage.py createsuperuser
</code></pre> 
<p>  登录管理后台Admin:</p> 
<p><img alt="" height="836" src="https://images2.imgbox.com/b5/1e/AkkJjlN5_o.png" width="1200"></p> 
<p> </p> 
<p>  其中Crontabs用于定时某个具体时间执行某个任务的时间，Intervals用于每隔多久执行任务的事件，具体任务的执行在Periodic tasks表中创建。</p> 
<p>  我们要创建每隔5秒执行某个任务，所以在Intervals表名后面点击Add按钮:</p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/3b/2d/KV4DJEbd_o.png" width="1200"></p> 
<p> </p> 
<p>  然后在Periodic tasks表名后面，点击Add按钮，添加任务:</p> 
<p><img alt="" height="899" src="https://images2.imgbox.com/ae/55/3ldzscU9_o.png" width="1200"></p> 
<p> </p> 
<p>  启动定时任务：</p> 
<pre><code>celery -A celery_demo worker -l info --beat
</code></pre> 
<p> </p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/cc/c8/ywxRc69l_o.png" width="1200"></p> 
<p>  任务每隔5秒中就会执行一次，如果配置了存储，那么每次任务执行的结果也会被保存到对应的数据库中。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aac3cb5496ce6a011f604c70da51c0cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图卷积网络原理（二）【图信号与图的拉普拉斯矩阵】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/93caf57510511585542630b6e1459462/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言设计一个简单的计算器，完成两个数的加、减、乘、除、取余。（根据输入的运算符，选择相应的运算，用switch语句实现。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>