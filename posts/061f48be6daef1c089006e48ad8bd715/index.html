<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于卷积神经网络的高光谱分类 CNN&#43;高光谱&#43;印度松数据集 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于卷积神经网络的高光谱分类 CNN&#43;高光谱&#43;印度松数据集" />
<meta property="og:description" content="基于卷积神经网络的高光谱分类 一、研究现状 只考虑到高光谱图像的光谱特征，即：
1、提取特征(小波变换、Gabor纹理分析、形态学剖面)
2、利用分类方法分类(支持向量机、决策树、随机森林、神经网络)
缺点：这些特征提取方法需要依据先验知识手动设置，且通过设定参数提取的特征信息通常只能
​ 用于区分特定的对象，缺乏灵活性，并且分类性能无法进一步提升。
本文提出：卷积神经网络的高光谱分类
​ 优点：能同时提取图像中的1）光谱信息；2）空间信息；3）能够自动的学习和优化网络中的参数，
​ 而不需要过多的人工调整
二、高光谱图像 ​ 高光谱与RGB三通道图像的最大不同是，其具有上百个通道（就是一个三维的数据立方体）假如一个N X N X B 的图像，RGB图像的B维度有三个通道，高光谱图像的B维度有上百个通道(他的光谱维度)
​ 高光谱的三维：二维几何空间及一维光谱信息
​ 光谱维度展开不仅可以获得图像上每个点的光谱数据，还可以获得任一个谱段的影像信息
三、降维 PCA(主成分分析) ​ 主成分分析（Principal Component Analysis，简称为 PCA）PCA 变换又称为霍特林变换（hotelling transform）和K-L （karhunen-loeve）变换。
是一种用于多变量数据信息提取的降维算法(提取数据的主要特征分量)，离散 K-L 变换是理论基础，PCA 也被称为特征脸方法。其主要思想是通过计算不同维度图像训练样本与各维训练样本均值的差值之间的相关性，评估各维空间特征表征整体空间特征的能力，再将所有图像样本最大特征值对应的特征向量投影到较低维度空间，最终实现降维。
算法具体描述如下：
1、 数据预处理。假设有 M 维图像数据，I1, I2, … … I𝑀，作为训练样本，每个图像由 m 行和 n 列像素组成。假设多维信息各维度数据不相关，将所有图像转换为图像向量Γ1, Γ2, … … Γ𝑀，并且每个图像向量的维度为m × n。
2、计算特征空间。
3、 投影与相似性检验。
四、CNN ​组成：一般包括全连接层、卷积层、&lt;激活函数层&gt;、池化层（有平均池化、最大池化两种）有了这些层使得卷积神经网络有了可以拟合各种函数的能力。
作用：通过卷积运算，将图像进行降维，使其可以进行训练
卷积操作示意(通过3x3的卷积核进行特征提取)
1）卷积层 通过卷积核(kernel)和原始图像上等同大小的区域进行卷积运算，通过计算得到特征图（与图像等同大小的尺寸的像素点进行对应相乘，再将相乘结果相加得到特征图上的特征值）
卷积核的参数不同提取到的特征不同，一个卷积层可以有多个卷积核，低层的卷积层提取到的是边框、颜色等简单特征；中层提取到低层特征的集合；高层提取到图像的全局特征
2）池化层（最大池化Max-Pooling） 池化有：最大池化，均值池化" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/061f48be6daef1c089006e48ad8bd715/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-09T20:45:44+08:00" />
<meta property="article:modified_time" content="2022-05-09T20:45:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于卷积神经网络的高光谱分类 CNN&#43;高光谱&#43;印度松数据集</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>基于卷积神经网络的高光谱分类</h2> 
<h2><a id="_2"></a>一、研究现状</h2> 
<p>只考虑到高光谱图像的光谱特征，即：</p> 
<p>1、提取特征(小波变换、Gabor纹理分析、形态学剖面)</p> 
<p>2、利用分类方法分类(支持向量机、决策树、随机森林、神经网络)</p> 
<p>缺点：这些特征提取方法需要依据先验知识手动设置，且通过设定参数提取的特征信息通常只能</p> 
<p>​ 用于区分特定的对象，缺乏灵活性，并且分类性能无法进一步提升。</p> 
<p>本文提出：卷积神经网络的高光谱分类</p> 
<p>​ 优点：能同时提取图像中的1）光谱信息；2）空间信息；3）能够自动的学习和优化网络中的参数，</p> 
<p>​ 而不需要过多的人工调整</p> 
<h2><a id="_20"></a>二、高光谱图像</h2> 
<p><img src="https://images2.imgbox.com/45/48/Gzb6stJy_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e7/23/RQc8teNg_o.png" alt="在这里插入图片描述"></p> 
<p>​ 高光谱与RGB三通道图像的最大不同是，其具有上百个通道（就是一个三维的数据立方体）假如一个N X N X B 的图像，RGB图像的B维度有三个通道，高光谱图像的B维度有上百个通道(他的光谱维度)</p> 
<p>​ 高光谱的三维：二维几何空间及一维光谱信息</p> 
<p>​ 光谱维度展开不仅可以获得图像上每个点的光谱数据，还可以获得任一个谱段的影像信息</p> 
<h2><a id="_34"></a>三、降维</h2> 
<h3><a id="PCA_36"></a>PCA(主成分分析)</h3> 
<p>​ 主成分分析（Principal Component Analysis，简称为 PCA）PCA 变换又称为霍特林变换（hotelling transform）和K-L （karhunen-loeve）变换。</p> 
<p>是一种用于多变量数据信息提取的<strong>降维算法</strong>(<strong>提取数据的主要特征分量</strong>)，离散 K-L 变换是理论基础，PCA 也被称为特征脸方法。其主要思想是通过计算不同维度图像训练样本与各维训练样本均值的差值之间的相关性，评估各维空间特征表征整体空间特征的能力，再将所有图像样本最大特征值对应的特征向量投影到较低维度空间，最终实现降维。</p> 
<p>算法具体描述如下：</p> 
<p>1、 数据预处理。假设有 <em>M</em> 维图像数据，I1, I2, … … I𝑀，作为训练样本，每个图像由 m 行和 n 列像素组成。假设多维信息各维度数据不相关，将所有图像转换为图像向量Γ1, Γ2, … … Γ𝑀，并且每个图像向量的维度为m × n。</p> 
<p>2、计算特征空间。</p> 
<p>3、 投影与相似性检验。</p> 
<h2><a id="CNN_52"></a>四、CNN</h2> 
<p>​组成：一般包括全连接层、卷积层、&lt;激活函数层&gt;、池化层（有平均池化、最大池化两种）有了这些层使得卷积神经网络有了可以拟合各种函数的能力。<br> 作用：通过卷积运算，将图像进行降维，使其可以进行训练<br> <img src="https://images2.imgbox.com/c4/bb/LoDAyjpr_o.gif" alt="动图形象理解深度学习卷积"><br> 卷积操作示意(通过3x3的卷积核进行特征提取)</p> 
<h5><a id="1_59"></a>1）卷积层</h5> 
<p><img src="https://images2.imgbox.com/06/05/CYmxSUct_o.png" alt="在这里插入图片描述"><br> 通过卷积核(kernel)和原始图像上等同大小的区域进行卷积运算，通过计算得到特征图（与图像等同大小的尺寸的像素点进行对应相乘，再将相乘结果相加得到特征图上的特征值）</p> 
<p>卷积核的参数不同提取到的特征不同，一个卷积层可以有多个卷积核，低层的卷积层提取到的是边框、颜色等简单特征；中层提取到低层特征的集合；高层提取到图像的全局特征</p> 
<h5><a id="2MaxPooling_66"></a>2）池化层（最大池化Max-Pooling）</h5> 
<p>池化有：最大池化，均值池化</p> 
<p>经卷积后，特征表达空间较大，存在较多冗余信息（特征）</p> 
<p>池化操作：缩小参数矩阵（去除冗余信息）；从而减小下一层参数的数量；(防止过拟合，减小计算量)<br> <img src="https://images2.imgbox.com/57/a1/r3Eabdsl_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p>保留特征图中最重要的特征并去除无关的特征。</p> </li><li> <p>减小特征图 (Feature Map) 的维数，从而减小后续的计算量。</p> </li><li> <p>减少了模型需要训练的参数量，降低了模型的复杂度，使得模型更为简单些，起到了稀疏模型的作用，提高了模型的泛化能力。</p> </li><li> <p>引入了一定的不变性，包括平移不变性、旋转不变性以及尺度不变性。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/4c/9b/npIYIFRG_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/aa/ef/HK4CwMr5_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d0/f4/L99trkzy_o.png" alt="在这里插入图片描述"><br> 池化层是对小区域数据(局部区域)进行将维，因此可以同时在水平方向和数值上进行降维（减小特征图尺寸）</p> 
<h5><a id="3_93"></a>3）全连接层</h5> 
<p>​ 在卷积神经网络中，卷积层和池化层等操作可以看做是将原始图片映射到一个低维的隐层特征空间，而全连接层则起到将学习到的分布式特征表示映射到样本标记空间的作用</p> 
<h5><a id="4_97"></a>4）激活函数层</h5> 
<p>1、sigmoid</p> 
<p>2、tanh</p> 
<p>3、ReLu<br> 只保留响应值大于 0 的数值，并将小于等于 0 的响应值置为 0<br> <img src="https://images2.imgbox.com/43/7a/GauP3sSq_o.png" alt="在这里插入图片描述"><br> ReLU 函数的优点在于它会增加前一层网络乃至整个卷积神经网络的非线性特征，同时因为保留了响应为正的值，不会影响到卷积层提取出的特征，当输入比较大时不会存在梯度消失的情况，成功地解决了因梯度消失而造成的卷积神经网络学习收敛慢的问题。并且只需要一个阈值就可以得到神经网络的激活值，不需要复杂度运算，ReLU 主要用在神经网络中的隐藏层作为激活函数。另外数据通常有很多的冗余，而近似程度的最大化地保留数据特征，可以通过一个绝大多数值为 0 的稀疏矩阵来实现。对于 ReLU 而言，神经网络反复迭代训练的过程，实际上相当于在不断试探如何用一个稀疏矩阵表达图像特征，因为数据的稀疏特性的存在，所以这种方法可以在提高训练速度的同时又保证模型的效果。</p> 
<h5><a id="4dropout_108"></a>4）dropout层</h5> 
<p>​ 前向传播时，让某个神经元的激活值以一定概率停止工作（使模型泛化性增，因为这样让其不会对某一特征太过依赖）【针对数据不平衡】</p> 
<h5><a id="5Flatten_112"></a>5）Flatten层</h5> 
<p>Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。</p> 
<p>batch理解：</p> 
<p>CNN train 的样张图片 60 张，设置 batch_size = 15；</p> 
<p>理解：训练数据图片一次取15张同时训练，分4次训练完。</p> 
<h2><a id="_126"></a>五、数据集</h2> 
<h4><a id="_128"></a>印度松</h4> 
<p>​ 该场景由<a href="http://aviris.jpl.nasa.gov/" rel="nofollow">AVIRIS传感器</a>收集在印第安纳州西北部的印第安松树测试点上，由145×145像素和224个光谱反射带组成，其波长范围为0.4–2.5 10 ^（-6）米。此场景是较大场景的子集。印度松树景观包含三分之二的农业，以及三分之一的森林或其他天然多年生植物。有两条主要的双车道高速公路，一条铁路线，以及一些低密度房屋，其他建筑物和较小的道路。由于场景是在6月拍摄的，因此目前的一些农作物（玉米，大豆）处于生长的初期，覆盖率不足5％。现有的地面真理被划分为十六个等级，并且并不都是相互排斥的。通过删除覆盖吸水区域的条带，我们也将条带的数量减少到200条：[104-108]，[150-163]，220。<a href="https://engineering.purdue.edu/~biehl/MultiSpec/hyperspectral.html" rel="nofollow">Pursue的大学MultiSpec网站</a>。</p> 
<p>下载MATLAB数据文件：<a href="http://www.ehu.eus/ccwintco/uploads/2/22/Indian_pines.mat" rel="nofollow">印度松（6.0 MB）</a> | <a href="http://www.ehu.eus/ccwintco/uploads/6/67/Indian_pines_corrected.mat" rel="nofollow">更正的印度松（5.7 MB）</a> | <a href="http://www.ehu.eus/ccwintco/uploads/c/c4/Indian_pines_gt.mat" rel="nofollow">印度松树groundtruth（1.1 KB）</a></p> 
<p><img src="https://images2.imgbox.com/48/df/HdSS0tTm_o.png" alt="在这里插入图片描述"></p> 
<p>印度松树数据集的样本带</p> 
<p><img src="https://images2.imgbox.com/31/f6/VcyOH4dS_o.png" alt="在这里插入图片描述"></p> 
<p>Indian Pines的Groundtruth数据集</p> 
<table><thead><tr><th>Indian Pines场景的Groundtruth类及其各自的样本数</th><th></th><th></th></tr></thead><tbody><tr><td>#</td><td>类</td><td>样品</td></tr><tr><td>1</td><td>紫花苜蓿</td><td>46</td></tr><tr><td>2</td><td>玉米not</td><td>1428</td></tr><tr><td>3</td><td>玉米薄荷</td><td>830</td></tr><tr><td>4</td><td>玉米</td><td>237</td></tr><tr><td>5</td><td>草场</td><td>483</td></tr><tr><td>6</td><td>草树</td><td>730</td></tr><tr><td>7</td><td>割草草</td><td>28</td></tr><tr><td>8</td><td>干草堆</td><td>478</td></tr><tr><td>9</td><td>燕麦</td><td>20</td></tr><tr><td>10</td><td>大豆芥末</td><td>972</td></tr><tr><td>11</td><td>大豆薄荷</td><td>2455</td></tr><tr><td>12</td><td>大豆清洁</td><td>593</td></tr><tr><td>13</td><td>小麦</td><td>205</td></tr><tr><td>14</td><td>树木</td><td>1265</td></tr><tr><td>15</td><td>建筑物-草木-树木驱动器</td><td>386</td></tr><tr><td>16</td><td>石钢塔</td><td>93</td></tr></tbody></table> 
<h2><a id="_164"></a>六、基于卷积神经网络的高光谱分类</h2> 
<h3><a id="1_168"></a>1、分类算法</h3> 
<h4><a id="_172"></a>高光谱图像分类的不同算法</h4> 
<ul><li> <p>K-Nearest Neighbors</p> <p>K最近邻居</p> </li><li> <p>Support Vector Machine</p> <p>支持向量机</p> </li><li> <p>Spectral Angle Mapper</p> <p>光谱角映射器</p> </li><li> <p>Convolutional Neural Networks</p> <p><strong>卷积神经网络</strong></p> </li><li> <p>Decision Trees e.t.c</p> <p>决策树等</p> </li></ul> 
<h4><a id="_197"></a>针对给定输入数据预测类别标签</h4> 
<p>分类可分为：</p> 
<ul><li> <p>Classification Predictive Modeling</p> <p>分类预测建模</p> </li><li> <p>Binary Classification</p> <p>二进制分类</p> </li><li> <p>Multi-Class Classification</p> <p><strong>多类别分类</strong></p> </li><li> <p>Multi-Label Classification</p> <p>多标签分类</p> </li><li> <p>Imbalanced Classification</p> <p>分类不平衡</p> </li></ul> 
<h3><a id="2_223"></a>2、模型搭建</h3> 
<h4><a id="1_225"></a>1）、输入(预处理图像)</h4> 
<h5><a id="1_227"></a>（1）对高光谱图像进行空间取块</h5> 
<p>为了与深度卷积神经网络的输入相匹配</p> 
<p>以空间上的一个像元为中心，取周围N X N大小的块 即每个小块大小为N X N X B ;B为图像的通道数</p> 
<h5><a id="2_233"></a>（2）降维</h5> 
<p>对于N X N X B的高光谱图像，由于其有数百维的光谱波段(观瀑维度 即：B)，增加了网络训练的难度（计算成本高）</p> 
<p>本文采用pca即主成分分析的方法进行降维</p> 
<p>通过1) 2)操作不仅可以去除光谱中的冗余信息同时又保留了图像的空间信息</p> 
<h4><a id="2_241"></a>2）、模型结构</h4> 
<pre><code class="prism language-python">model <span class="token operator">=</span> Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>

model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Conv2D<span class="token punctuation">(</span>C1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">,</span> input_shape<span class="token operator">=</span>input_shape<span class="token punctuation">)</span><span class="token punctuation">)</span>
model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Conv2D<span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>C1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Dropout<span class="token punctuation">(</span><span class="token number">0.25</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Dense<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>numPCAcomponents<span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Dense<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'softmax'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/06/93/Kuynwz7O_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_257"></a>3、代码结构</h3> 
<p><strong>dataset.py</strong></p> 
<p>利用spectral工具包读取数据集,然后对数据集进行预处理,包括进行训练测试集分割 / 序列化和PCA变换,并将其以npy的格式保存到文件中.处理后的数据集保存在predata文件夹中.</p> 
<p><strong>train.py</strong></p> 
<p>利用keras构建卷积神经网络模型,读取与处理的数据集进行训练.</p> 
<p>其中训练过程,使用随机梯度下降法SGD作为优化算法,使用多分类的对数损失函数<em>categorical_crossentropy</em>作为损失函数.</p> 
<p>使用ReduceLROnPlateau回调函数对val_acc（验证集准确率）进行监控,当val_acc不再下降时,减少学习率,直至减少到0.000001.</p> 
<p>使用ModelCheckpoint回调函数,对有好的val_acc的训练过程作为一个检查点保存下来,下一次若有更好的结果则更新.若不好则不更新.</p> 
<p>训练完成后保存模型到文件,并将训练过程中loss和accuarcy的变化情况绘制出来.</p> 
<p><strong>test.py</strong></p> 
<p>对训练的模型的效果进行测试和评价.</p> 
<p>使用sklearn包中的classification_report和confusion_matrix,总结出分类效果报告(包括Test loss Test accuracy以及对测试集中每一类样本的预测结果进行统计)和相应的混淆矩阵.</p> 
<p>使用matplotlib工具包将混淆矩阵可视化,包括原始的混淆矩阵(数据为样本个数)以及标准化后的混淆矩阵(数据为样本比例)</p> 
<p>最后读取原始数据集,对整个数据集进行分类,并使用spectral工具包绘制出预测结果,以高光谱图像的形式表示出来.</p> 
<h3><a id="4_285"></a>4、训练结果</h3> 
<p>下图是训练和测试准确率随着epoch的变化图</p> 
<p><img src="https://images2.imgbox.com/91/a6/gVgn4peB_o.png" alt="在这里插入图片描述"><br> 下图是训练和测试损失随着epoch的变化图</p> 
<p><img src="https://images2.imgbox.com/52/21/0DlFD4M4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5_297"></a>5、测试结果</h3> 
<pre><code class="prism language-python">Test loss <span class="token number">25.945746977841722</span> <span class="token punctuation">(</span><span class="token operator">%</span><span class="token punctuation">)</span>
Test accuracy <span class="token number">94.18536585365854</span> <span class="token punctuation">(</span><span class="token operator">%</span><span class="token punctuation">)</span>

classification result<span class="token punctuation">:</span> 
                              precision    recall  f1<span class="token operator">-</span>score   support

                     Alfalfa       <span class="token number">1.00</span>      <span class="token number">0.91</span>      <span class="token number">0.95</span>        <span class="token number">23</span>
                 Corn<span class="token operator">-</span>notill       <span class="token number">0.92</span>      <span class="token number">0.87</span>      <span class="token number">0.89</span>       <span class="token number">714</span>
                Corn<span class="token operator">-</span>mintill       <span class="token number">0.92</span>      <span class="token number">0.95</span>      <span class="token number">0.94</span>       <span class="token number">415</span>
                        Corn       <span class="token number">0.98</span>      <span class="token number">0.92</span>      <span class="token number">0.95</span>       <span class="token number">118</span>
               Grass<span class="token operator">-</span>pasture       <span class="token number">0.98</span>      <span class="token number">0.98</span>      <span class="token number">0.98</span>       <span class="token number">242</span>
                 Grass<span class="token operator">-</span>trees       <span class="token number">0.99</span>      <span class="token number">0.99</span>      <span class="token number">0.99</span>       <span class="token number">365</span>
         Grass<span class="token operator">-</span>pasture<span class="token operator">-</span>mowed       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>        <span class="token number">14</span>
               Hay<span class="token operator">-</span>windrowed       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>       <span class="token number">239</span>
                        Oats       <span class="token number">0.91</span>      <span class="token number">1.00</span>      <span class="token number">0.95</span>        <span class="token number">10</span>
              Soybean<span class="token operator">-</span>notill       <span class="token number">0.90</span>      <span class="token number">0.91</span>      <span class="token number">0.91</span>       <span class="token number">486</span>
             Soybean<span class="token operator">-</span>mintill       <span class="token number">0.92</span>      <span class="token number">0.95</span>      <span class="token number">0.94</span>      <span class="token number">1228</span>
               Soybean<span class="token operator">-</span>clean       <span class="token number">0.94</span>      <span class="token number">0.90</span>      <span class="token number">0.92</span>       <span class="token number">297</span>
                       Wheat       <span class="token number">1.00</span>      <span class="token number">1.00</span>      <span class="token number">1.00</span>       <span class="token number">102</span>
                       Woods       <span class="token number">0.98</span>      <span class="token number">0.98</span>      <span class="token number">0.98</span>       <span class="token number">633</span>
Buildings<span class="token operator">-</span>Grass<span class="token operator">-</span>Trees<span class="token operator">-</span>Drives       <span class="token number">0.93</span>      <span class="token number">0.90</span>      <span class="token number">0.91</span>       <span class="token number">193</span>
          Stone<span class="token operator">-</span>Steel<span class="token operator">-</span>Towers       <span class="token number">0.92</span>      <span class="token number">1.00</span>      <span class="token number">0.96</span>        <span class="token number">46</span>

                    accuracy                           <span class="token number">0.94</span>      <span class="token number">5125</span>
                   macro avg       <span class="token number">0.96</span>      <span class="token number">0.95</span>      <span class="token number">0.95</span>      <span class="token number">5125</span>
                weighted avg       <span class="token number">0.94</span>      <span class="token number">0.94</span>      <span class="token number">0.94</span>      <span class="token number">5125</span>
</code></pre> 
<p>使用classification_report函数得到：</p> 
<p>（1）support列为每个标签出现的次数</p> 
<p>（2）precision列精确度</p> 
<p>（3）recall列召回率</p> 
<p>（4）f1-score列为f1值即精确度和召回率的调和平均</p> 
<p>（5）avg / total各列的均值 support列是总和</p> 
<p>精确率：精确率越高，代表预测正确的标签的比例越高；【所有预测为这一类的标签中预测正确的标签所占的比例】<br> 召回率：召回率越高，模型分类性能越好；【所有这一类标签中被正确分类出来的标签所占比例】</p> 
<p><strong>下图是没有经过标准化的混淆矩阵</strong><br> <img src="https://images2.imgbox.com/a6/61/fcJHtBlY_o.png" alt="在这里插入图片描述"><br> <strong>下图是经过标准化的混淆矩阵</strong><br> <img src="https://images2.imgbox.com/36/a5/UWSWZMqa_o.png" alt="在这里插入图片描述"></p> 
<p><strong>下图是真实分类的高光谱图像</strong></p> 
<p><img src="https://images2.imgbox.com/75/d1/5U6dh4Wu_o.jpg" alt="在这里插入图片描述"></p> 
<p><strong>下图是经过上述模型分类的得到的高光谱图像</strong><br> <img src="https://images2.imgbox.com/6f/47/rtWlwOlo_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="_358"></a>七、知识补充</h2> 
<h3><a id="1stochastic_gradient_descentSGD_360"></a>1、随机梯度下降（stochastic gradient descent，SGD）</h3> 
<p>用于高维的优化</p> 
<p>出处：https://www.zhihu.com/question/264189719/answer/291167114</p> 
<ul><li>随机梯度下降：在每次更新时用1个样本，可以看到多了随机两个字，<strong>随机也就是说我们用样本中的一个例子来近似我所有的样本，来调整<em>θ</em></strong>，因而随机梯度下降是会带来一定的问题，因为计算得到的并不是准确的一个梯度，**对于最优化问题，凸问题，**虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近。但是相比于批量梯度，这样的方法更快，更快收敛，虽然不是全局最优，但很多时候是我们可以接受的。</li></ul> 
<h3><a id="2_368"></a>2、混淆矩阵</h3> 
<p><img src="https://images2.imgbox.com/f9/55/RUBacKsj_o.jpg" alt="在这里插入图片描述"></p> 
<p>如有150个样本数据，预测为1,2,3类各为50个。分类结束后得到的混淆矩阵为：</p> 
<p>每一行之和表示该类别的真实样本数量，每一列之和表示被预测为该类别的样本数量，</p> 
<p>第一行说明有43个属于第一类的样本被正确预测为了第一类，有两个属于第一类的样本被错误预测为了第二类</p> 
<h3><a id="3__379"></a>3、欠采样 过采样</h3> 
<p>1：为什么类别不平横会影响模型的输出：</p> 
<p>许多模型的输出类别是基于阈值的，例如逻辑回归中小于0.5的为反例，大于则为正例。在数据不平衡时**，默认的阈值会导致模型输出倾向与类别数据多的类别。**</p> 
<p>因此可以在实际应用中，解决办法包括：</p> 
<p>1)调整分类阈值，使得更倾向与类别少的数据。</p> 
<p>2）选择合适的评估标准，比如ROC，AUC或者F1,G-mean，而不是准确度（accuracy）</p> 
<p>3）过采样法（sampling）：来处理不平横的问题。分为欠采样(undersampling)和过采样(oversampling)两种，</p> 
<p><strong>过采样</strong>：重复正比例数据，实际上没有为模型引入更多数据，过分强调正比例数据，会放大正比例噪音对模型的影响。</p> 
<p><strong>欠采样</strong>：丢弃大量数据，和过采样一样会存在过拟合的问题。</p> 
<p>由于随机过采样采取简单复制样本的策略来增加少数类样本，这样容易产生模型过拟合的问题，即使得模型学习到的信息过于特别(Specific)而不够泛化(General)</p> 
<p>小tip：过拟合：大家不必深究过拟合只要知道过拟合了，那么模型预测或者分类就和实际的情况相差甚远了，做机器学习的筒子，宁愿牺牲一些accuracy，也要抑制过拟合的情况产生，是一个令人很头疼的问题。</p> 
<p>4）数据合成：SMOTE（Synthetic Minority Oversampling Technique）即合成少数类过采样技术，它是基于随机过采样算法的一种改进方案，SMOTE算法的基本思想是对少数类样本进行分析并根据少数类样本人工插值合成新样本（）跟大类样本数据相当）添加到数据集中，构成均衡数据集。</p> 
<h3><a id="4___403"></a>4、训练集 验证集 测试集</h3> 
<h4><a id="_405"></a>训练集</h4> 
<h4><a id="_407"></a>验证集</h4> 
<p>1）确定超参数：在训练过程中,检验模型的状态、收敛情况。通常用来调整超参数，通过几组模型在验证集上的表现确定超参数；</p> 
<p>2）判断何时停止训练：在训练过程中，监控模型是否发生过拟合。一般而言，验证集在表现稳定的情况下，若继续训练，训练集的表现还会继续上升，但是验证集会不升反降，这样一般就是发生了过拟合。因此，验证集通常被用作判断合适停止训练。</p> 
<h4><a id="_413"></a>测试集</h4> 
<h3><a id="5__415"></a>5、 回调函数</h3> 
<p>1）ReduceLROnPlateau回调函数</p> 
<p>目的：定义学习率之后，经过一定epoch迭代之后，模型效果不再提升，该学习率可能已经不再适应该模型。需要在训练过程中缩小学习率，进而提升模型。如何在训练过程中缩小学习率呢？我们可以使用keras中的回调函数<strong>ReduceLROnPlateau</strong>。与<strong>EarlyStopping</strong>配合使用，会非常方便。</p> 
<p>为什么初始化一个非常小的学习率呢？因为初始的学习率过小，会需要非常多次的迭代才能使模型达到最优状态，训练缓慢。如果训练过程中不断缩小学习率，可以快速又精确的获得最优模型。</p> 
<pre><code class="prism language-python">monitor：监测的值，可以是accuracy，val_loss<span class="token punctuation">,</span>val_accuracy
factor：缩放学习率的值，学习率将以lr <span class="token operator">=</span> lr<span class="token operator">*</span>factor的形式被减少
patience：当patience个epoch过去而模型性能不提升时，学习率减少的动作会被触发
mode：‘auto’，‘<span class="token builtin">min</span>’，‘<span class="token builtin">max</span>’之一 默认‘auto’就行
epsilon：阈值，用来确定是否进入检测值的“平原区”
cooldown：学习率减少后，会经过cooldown个epoch才重新进行正常操作
min_lr：学习率最小值，能缩小到的下限
 
Reduce<span class="token operator">=</span>ReduceLROnPlateau<span class="token punctuation">(</span>monitor<span class="token operator">=</span><span class="token string">'val_accuracy'</span><span class="token punctuation">,</span>
                         factor<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>
                         patience<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>
                         verbose<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
                         mode<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span>
                         epsilon<span class="token operator">=</span><span class="token number">0.0001</span><span class="token punctuation">,</span>
                         cooldown<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>
                         min_lr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<p>2）ModelCheckpoint回调函数：在每个训练期之后保存模型</p> 
<pre><code class="prism language-python">keras<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>ModelCheckpoint<span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> monitor<span class="token operator">=</span><span class="token string">'val_loss'</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> save_best_only<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> save_weights_only<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span> period<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p>filepath: 字符串，保存模型的路径。<br> monitor: 被监测的数据。<br> verbose: 详细信息模式，0 或者 1 。<br> save_best_only: 如果 save_best_only=True， 被监测数据的最佳模型就不会被覆盖。<br> mode: {auto, min, max} 的其中之一。 如果 save_best_only=True，那么是否覆盖保存文件的决定就取决于被监测数据的最大或者最小值。 对于 val_acc，模式就会是 max，而对于 val_loss，模式就需要是 min，等等。 在 auto 模式中，方向会自动从被监测的数据的名字中判断出来。<br> save_weights_only: 如果 True，那么只有模型的权重会被保存 (model.save_weights(filepath))， 否则的话，整个模型会被保存 (model.save(filepath))。<br> period: 每个检查点之间的间隔（训练轮数）</p> 
<h3><a id="6_456"></a>6、动量</h3> 
<p>Momentum(动量,冲量): 结合当前梯度与上一次更新信息,用于当前更新, 通常取值 momentum=0.9</p> 
<h3><a id="7_460"></a>7、学习率</h3> 
<p>学习率:用于控制更新的步长, 通常取值 lr=0.01</p> 
<h3><a id="8StratifiedShuffleSplit_464"></a>8、StratifiedShuffleSplit函数的使用</h3> 
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedShuffleSplit.html#sklearn.model_selection.StratifiedShuffleSplit" rel="nofollow">官方文档</a><br> 用法：</p> 
<pre><code>from  sklearn.model_selection import StratifiedShuffleSplit
StratifiedShuffleSplit(n_splits=10,test_size=None,train_size=None, random_state=None)12
</code></pre> 
<p>2.1 参数说明</p> 
<p>参数 <strong>n_splits</strong>是将训练数据分成train/test对的组数，可根据需要进行设置，默认为10</p> 
<p>参数<strong>test_size和train_size</strong>是用来设置train/test对中train和test所占的比例。例如：<br> 1.提供10个数据num进行训练和测试集划分<br> 2.设置train_size=0.8 test_size=0.2<br> 3.train_num=num<em>train_size=8 test_num=num</em>test_size=2<br> 4.即10个数据，进行划分以后8个是训练数据，2个是测试数据</p> 
<p>注：train_num≥2，test_num≥2 ;test_size+train_size可以小于1</p> 
<p>参数 <strong>random_state</strong>控制是将样本随机打乱</p> 
<p>2.2 函数作用描述<br> 1.其产生指定数量的独立的train/test数据集划分数据集划分成n组。<br> 2.首先将样本随机打乱，然后根据设置参数划分出train/test对。<br> 3.其创建的每一组划分将保证每组类比比例相同。即第一组训练数据类别比例为2:1，则后面每组类别都满足这个比例</p> 
<p>2.3 具体实现</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> StratifiedShuffleSplit
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
              <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#训练数据集8*2</span>
y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#类别数据集8*1</span>

ss<span class="token operator">=</span>StratifiedShuffleSplit<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>test_size<span class="token operator">=</span><span class="token number">0.25</span><span class="token punctuation">,</span>train_size<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#分成5组，测试比例为0.25，训练比例是0.75</span>

<span class="token keyword">for</span> train_index<span class="token punctuation">,</span> test_index <span class="token keyword">in</span> ss<span class="token punctuation">.</span>split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"TRAIN:"</span><span class="token punctuation">,</span> train_index<span class="token punctuation">,</span> <span class="token string">"TEST:"</span><span class="token punctuation">,</span> test_index<span class="token punctuation">)</span><span class="token comment">#获得索引值</span>
   X_train<span class="token punctuation">,</span> X_test <span class="token operator">=</span> X<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">[</span>test_index<span class="token punctuation">]</span><span class="token comment">#训练集对应的值</span>
   y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> y<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>test_index<span class="token punctuation">]</span><span class="token comment">#类别集对应的值</span>
<span class="token number">12345678910111213</span>
</code></pre> 
<h3><a id="9numpyunique_511"></a>9、numpy.unique</h3> 
<p>numpy.unique（<em>ar</em>，return_index = False，return_inverse = False，return_counts = False，axis = None）</p> 
<p>查找数组的唯一元素。</p> 
<p>返回数组的排序后的唯一元素。除独特元素外，还有三个可选输出：</p> 
<ul><li> <p>输入数组的索引给出唯一值</p> </li><li> <p>重建输入数组的唯一数组的索引</p> </li><li> <p>输入数组中每个唯一值出现的次数</p> </li><li> <p>参量</p> <p>array_like输入数组。除非指定了<em>轴</em>，否则如果它不是一维的，它将被展平。<strong>return_index</strong> bool，可选如果为True，则还返回<em>ar</em>的索引（沿着指定的轴，如果提供的话，或者在展平的数组中），这将导致唯一的数组。<strong>return_inverse</strong> bool，可选如果为True，则还返回可用于重建<em>ar</em>的唯一数组的索引（对于指定的轴（如果提供））。<strong>return_counts</strong> bool，可选如果为True，则还返回每个唯一项出现在<em>ar中的次数</em>。1.9.0版中的新功能。轴int或无，可选要运行的轴。如果为None，则<em>ar</em>将被展平。如果为整数，则由给定轴索引的子数组将被展平并视为具有给定轴尺寸的一维数组的元素，有关更多详细信息，请参见注释。如果使用<em>轴</em>kwarg，则不支持对象数组或包含对象的结构化数组。默认为无。<em>1.13.0版中的新功能。</em></p> </li><li> <p>退货</p> <p><strong>唯一</strong>ndarray排序后的唯一值。<strong>unique_indices</strong> ndarray，可选原始数组中唯一值的首次出现的索引。仅在<em>return_index</em>为True时提供。<strong>unique_inverse</strong> ndarray，可选从唯一数组重建原始数组的索引。仅在<em>return_inverse</em>为True时提供。<strong>unique_counts</strong> ndarray，可选每个唯一值出现在原始数组中的次数。仅在<em>return_counts</em>为True时提供。<em>1.9.0版中的新功能。</em></p> </li></ul> 
<p>也可以看看</p> 
<ul><li> <p>numpy.lib.arraysetops</p> <p>具有许多其他功能的模块，用于对阵列执行设置操作。</p> </li></ul> 
<p>笔记</p> 
<p>指定轴后，将对由该轴索引的子数组进行排序。通过将指定的轴设为数组的第一维（将轴移至第一维以保持其他轴的顺序），然后将子数组按C顺序展平，即可完成此操作。然后，将展平的子数组视为结构化类型，并为每个元素指定了标签，结果是我们最终得到了结构化类型的1-D数组，该数组可以用与其他任何1-D数组相同的方式处理。结果是，展平的子数组从第一个元素开始按字典顺序排序。</p> 
<p>例子</p> 
<p>&gt;&gt;&gt;</p> 
<pre><code>&gt;&gt;&gt; np.unique([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
&gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])
&gt;&gt;&gt; np.unique(a)
array([1, 2, 3])
</code></pre> 
<p>返回二维数组的唯一行</p> 
<p>&gt;&gt;&gt;</p> 
<pre><code>&gt;&gt;&gt; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
&gt;&gt;&gt; np.unique(a, axis=0)
array([[1, 0, 0], [2, 3, 4]])
</code></pre> 
<p>返回给出唯一值的原始数组的索引：</p> 
<p>&gt;&gt;&gt;</p> 
<pre><code>&gt;&gt;&gt; a = np.array(['a', 'b', 'b', 'c', 'a'])
&gt;&gt;&gt; u, indices = np.unique(a, return_index=True)
&gt;&gt;&gt; u
array(['a', 'b', 'c'], dtype='&lt;U1')
&gt;&gt;&gt; indices
array([0, 1, 3])
&gt;&gt;&gt; a[indices]
array(['a', 'b', 'c'], dtype='&lt;U1')
</code></pre> 
<p>从唯一值重建输入数组：</p> 
<p>&gt;&gt;&gt;</p> 
<pre><code>&gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])
&gt;&gt;&gt; u, indices = np.unique(a, return_inverse=True)
&gt;&gt;&gt; u
array([1, 2, 3, 4, 6])
&gt;&gt;&gt; indices
array([0, 1, 4, 3, 1, 2, 1])
&gt;&gt;&gt; u[indices]
array([1, 2, 6, 4, 2, 3, 2])
</code></pre> 
<h3><a id="10_595"></a>10、交叉熵损失函数</h3> 
<h4><a id="_597"></a>熵：</h4> 
<p>是"无序化"的度量</p> 
<h4><a id="_601"></a>信息量</h4> 
<p>一件事发生的概率越小，信息量越大；</p> 
<p>发生的概率越大，信息量越小。</p> 
<p>举例理解：“国足踢进世界杯”信息量大 因为这件事发生的概率小；</p> 
<p>“太阳从东方升起”信息量小 因为这件事大家习以为常，概率为一；</p> 
<h4><a id="_611"></a>信息熵：</h4> 
<p>是“有序化”度量；</p> 
<p>离散随机事件出现的概率</p> 
<p>系统越是有序，信息熵越低；系统越是混乱，信息熵越高；</p> 
<h4><a id="_619"></a>交叉熵原理：</h4> 
<p>交叉熵是用来衡量两个 概率分布 的距离(也可以叫差别)。[概率分布：即[0.1，0.5，0.2，0.1，0.1]，每个类别的概率都在0~1，且加起来为1]。</p> 
<p>若有两个概率分布p(x)和q(x)，通过q来表示p的交叉熵为：(注意，p和q呼唤位置后，交叉熵是不同的)</p> 
<p>只要把p作为正确结果(如[0，0，0，1，0，0])，把q作为预测结果(如[0.1，0.1，0.4，0.1，0.2，0.1])，就可以得到两个概率分布的交叉熵了，交叉熵值越低，表示两个概率分布越靠近。</p> 
<h4><a id="_627"></a>交叉熵计算实例：</h4> 
<p>假设有一个三分类问题，某个样例的正确答案是(1，0，0)，某个模型经过softmax回归之后的预测答案是(0.5，0.4，0.1)，那么他们的交叉熵为：</p> 
<p>如果另一个模型的预测概率分布为(0.8，0.1，0.1)，则这个预测与真实的交叉熵为：</p> 
<p>由于0.1小于0.3，所以第二个预测结果要由于第一个。</p> 
<h4><a id="_635"></a>交叉熵使用背景：</h4> 
<p>通过神经网络解决<strong>分类问题</strong>时，一般会设置k个输出点，k代表类别的个数</p> 
<p>每个输出结点，都会输出该结点对应类别的得分，如[cat，dog，car，pedestrian] 为[44，10，22，5]</p> 
<p>但是输出结点输出的是得分，而不是概率分布，那么就没有办法用交叉熵来衡量预测结果和真确结果了，那怎么办呢，<strong>解决方法是在输出结果后接一层 softmax，softmax的作用就是把输出得分换算为概率分布</strong>。</p> 
<h3><a id="11_643"></a>11、高光谱降维方法</h3> 
<p>现有降维（Dimensionality Reduction, DR）方法总结</p> 
<ul><li> <p>主成分分析（Principal Component Analysis, PCA）</p> </li><li> <p>线性判别分析（Linear Discriminant Analysis, LDA）维基</p> </li><li> <p>局部线性嵌入（Local Linear Embedding, LLE）</p> </li><li> <p>等距特征映射（ISOmetric feature MAPping, ISOMAP）</p> </li><li> <p>拉普拉斯本征映射（Laplacian Eigenmap, LE）</p> </li><li> <p>t-分布随机邻域嵌入（t-distribution Stochastic Neighbor Embedding, t-SNE）</p> </li><li> <p>局部保持投影（Locality Preserving Projections, LPP）</p> </li><li> <p>邻域保持嵌入（Neighborhood Preserving Embedding, NPE）</p> </li><li> <p>参数化监督t-SNE</p> </li><li> <p>图嵌入（Graph Embedding, GE）——尝试统一多种不同的降维方法</p> <p>上述方法的问题是只考虑了光谱信息，没有考虑像元间的空间关联</p> </li><li> <p>空间相干NPE（Spatial Coherence NPE, SC-NPE）</p> </li><li> <p>局部像元NPE（Local Pixel NPE, LP-NPE）</p> </li><li> <p>判别空间-光谱边缘（Discriminate Spectral-Spatial Margins, DSSM) 链接<br> 上述方法或是只利用空间信息来表征相似度，或是在一个特定的空间窗口中考虑空间关系，而没有从邻接图的角度进行考量。</p> </li></ul> 
<h4><a id="_675"></a>精确率和召回率</h4> 
<p>精确率，也被称作查准率，是指<strong>所有预测为正类的结果中，真正的正类的比例</strong>。</p> 
<p>召回率，也被称作查全率，是指所有正类中，被分类器找出来的比例。</p> 
<p>F1值：（readme文档）.assets/gif.latex)]<img src="https://images2.imgbox.com/6f/ac/PJI9PBcN_o.png" alt="在这里插入图片描述"></p> 
<p>对于上述两个公式的符号定义，是在二分类问题中，我们将关注的类别作为正类，其他类别作为负类别，因此，定义：</p> 
<ul><li><code>TP(True Positive)</code>：真正正类的数量，即分类为正类，实际也是正类的样本数量；</li><li><code>FP</code>(False Positive)：假正类的数量，即分类为正类，但实际是负类的样本数量；</li><li><code>FN(False Negative)</code>：假负类的数量，即分类为负类，但实际是正类的样本数量；</li><li><code>TN(True Negative)</code>：真负类的数量，即分类是负类，实际也负类的样本数量。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1dca5004d35b6958825815460c88754/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue使用uuid，请求头headers设置uuid</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3d42742b103e427a9915e8e7f6d1f0c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot用户鉴权以及统一获取用户信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>