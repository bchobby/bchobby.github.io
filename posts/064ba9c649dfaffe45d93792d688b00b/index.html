<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shopping高级篇-1 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shopping高级篇-1" />
<meta property="og:description" content="Elastisearch-介绍及安装 简介 mysql用作持久化存储，ES用作检索 基本概念：
index索引 名词：相当于mysql的db，数据库
Type类型 在index中，可以定义一个或多个类型
类似于mysql的table，每一种类型的数据放在一起
index库&gt;type表&gt;document文档
Document文档 保存在某个index下，某种type的一个数据document，文档是json格式的，
document就像是mysql中的某个table里面的内容。每一行对应的列叫属性
检索机制 102、全文检索-ElasticSearch-简介_哔哩哔哩_bilibili
安装elastic search dokcer中安装elastic search
下载ealastic search（存储和检索）和kibana（可视化检索）
docker pull elasticsearch:7.4.2
docker pull kibana:7.4.2
注意版本要统一
配置
mkdir -p /usr/local/elasticsearch/plugins
mkdir -p /usr/local/elasticsearch/config
mkdir -p /usr/local/elasticsearch/data
# es可以被远程任何机器访问
echo &#34;http.host: 0.0.0.0&#34; &gt;/usr/local/elasticsearch/config/elasticsearch.yml
# 递归更改权限，es需要访问
chmod -R 777 /usr/local/elasticsearch
启动Elastic search
# 9200是用户交互端口 9300是集群心跳端口
# -e指定是单阶段运行
# -e指定占用的内存大小，生产时可以设置32G
sudo docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/064ba9c649dfaffe45d93792d688b00b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-08T13:32:54+08:00" />
<meta property="article:modified_time" content="2022-08-08T13:32:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shopping高级篇-1</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Elastisearch-介绍及安装</h2> 
<p></p> 
<p></p> 
<h3>简介</h3> 
<h3><br> mysql用作持久化存储，ES用作检索</h3> 
<p>基本概念：</p> 
<h3>index索引</h3> 
<p>名词：相当于mysql的db，数据库</p> 
<p></p> 
<h3>Type类型</h3> 
<p><br> 在index中，可以定义一个或多个类型</p> 
<p>类似于mysql的table，每一种类型的数据放在一起</p> 
<p>index库&gt;type表&gt;document文档</p> 
<h3>Document文档</h3> 
<p><br> 保存在某个index下，某种type的一个数据document，文档是json格式的，<br> document就像是mysql中的某个table里面的内容。每一行对应的列叫属性<br>  </p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ac/72/KOU7Geq4_o.png"></p> 
<p></p> 
<h3> 检索机制</h3> 
<p> <a href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=102&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="102、全文检索-ElasticSearch-简介_哔哩哔哩_bilibili">102、全文检索-ElasticSearch-简介_哔哩哔哩_bilibili</a></p> 
<h3>安装elastic search</h3> 
<blockquote> 
 <p>dokcer中安装elastic search<br> 下载ealastic search（存储和检索）和kibana（可视化检索）<br> docker pull elasticsearch:7.4.2<br> docker pull kibana:7.4.2<br> 注意版本要统一</p> 
 <p>配置<br> mkdir -p /usr/local/elasticsearch/plugins<br> mkdir -p /usr/local/elasticsearch/config<br> mkdir -p /usr/local/elasticsearch/data</p> 
 <p># es可以被远程任何机器访问<br> echo "http.host: 0.0.0.0" &gt;/usr/local/elasticsearch/config/elasticsearch.yml</p> 
 <p># 递归更改权限，es需要访问<br> chmod -R 777 /usr/local/elasticsearch</p> 
 <p>启动Elastic search<br> # 9200是用户交互端口 9300是集群心跳端口<br> # -e指定是单阶段运行<br> # -e指定占用的内存大小，生产时可以设置32G<br> sudo docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \<br> -e  "discovery.type=single-node" \<br> -e ES_JAVA_OPTS="-Xms64m -Xmx512m" \<br> -v /usr/local/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \<br> -v /usr/local/elasticsearch/data:/usr/share/elasticsearch/data \<br> -v  /usr/local/elasticsearch/plugins:/usr/share/elasticsearch/plugins \<br> -d elasticsearch:7.4.2 </p> 
</blockquote> 
<p>docker ps 查看</p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/21/73/9ikPwHhV_o.png" width="719"></p> 
<h3>  安装kibana</h3> 
<blockquote> 
 <p>docker pull kibana:7.4.2<br> 启动kibana：<br> sudo docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.142.129:9200  -p 5601:5601 -d kibana:7.4.2</p> 
 <p><img alt="" height="315" src="https://images2.imgbox.com/1a/58/GnZEi3xB_o.png" width="1200"></p> 
 <p></p> 
</blockquote> 
<h2>Elasticsearch-使用入门</h2> 
<p id="1612227992a711dd89afae6b69dd108f">前面介绍说，Elasticsearch 都是通过 REST API 接口来操作数据的，那么下面接通过几个接口的请求来演示它的使用。（当前虚拟机IP为192.168.163.131）</p> 
<h2 id="1oQsr">_cat</h2> 
<h3 id="iC9WB">1. /_cat/nodes：查看所有节点</h3> 
<p id="f369a30795136b57b313f014633249d8">接口：<code>GET http://192.168.163.131:9200/_cat/nodes</code></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/53/3b/PvZ2PMaF_o.png"></p> 
<h3 id="SJWMh">2. /_cat/health：查看ES健康状况</h3> 
<p id="d4ab801a081c388beb825e01856ec146">接口：<code>GET http://192.168.163.131:9200/_cat/health</code></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/53/7BJsqubc_o.png"></p> 
<h3 id="kDIOJ">3. /_cat/master：查看主节点信息</h3> 
<p id="382525c34f83cc0a83033ff71688c377"></p> 
<p id="b2d3ce07e58d4a46d3b695789f6f5b0f">接口：<code>GET http://192.168.163.131:9200/_cat/master</code></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/92/f3/1cYYxUym_o.png"></p> 
<h3 id="yEfIb">4. /_cat/indicies：查看所有索引</h3> 
<p id="bf2dee01a1ccfa76ecb4602d6a8d8461">等价于 mysql 数据库的 show databases;</p> 
<p id="5efc5f8b2fe3c9e7d16c4c909debec95">接口：<code>GET http://192.168.163.131:9200/_cat/indices</code></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/d0/qFSv9Xhf_o.png"></p> 
<h2 id="wi9vo">索引一个文档</h2> 
<p id="a7c79ac0bb2a3710de620e90950d4a8b">即保存一条数据，保存在哪个索引的哪个类型下，指定用哪个唯一标识。</p> 
<h3 id="7VtEU">1. PUT 请求</h3> 
<p id="5dd792182cff2ec5b4ace21b083465f4">接口：<code>PUT http://192.168.163.131:9200/customer/external/1</code></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d6/70/8K3B1dbN_o.png"></p> 
<h3 id="jNkex">2. POST 请求</h3> 
<p id="8a45f202f8abd5ea7ffe346feef6a888">接口：<code>POST http://192.168.163.131:9200/customer/external/</code></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2d/3c/tXB96BF2_o.png"></p> 
<p id="062a5101df517269d0e50af0067326c3">PUT和POST都可以</p> 
<ul><li id="aa4ccd4c30f4e12c3f67ce50b5692374">POST新增，如果不指定id，会自动生成id。指定id就会修改这个数据，并新增版本号；</li><li id="b5bf79414b0c66b3ebe07161640ada90">PUT可以新增也可以修改。PUT必须指定id；由于PUT需要指定id，我们一般用来做修改操作，不指定id会报错。</li></ul> 
<h2>Nginx</h2> 
<p>正向代理和反向代理</p> 
<h3>配置反向代理</h3> 
<p>因为我们之前配置docker的时候将nginx挂载到了   usr/local/nginx 下</p> 
<p>所以我们找到总的配置文件</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/97/0a/2rCkI3YK_o.png" width="429"></p> 
<blockquote> 
 <p> user  nginx;<br> worker_processes  1;</p> 
 <p>error_log  /var/log/nginx/error.log warn;<br> pid        /var/run/nginx.pid;</p> 
 <p><br> events {<!-- --><br>     worker_connections  1024;<br> }</p> 
 <p><br> http {<!-- --><br>     include       /etc/nginx/mime.types;<br>     default_type  application/octet-stream;</p> 
 <p>    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '<br>                       '$status $body_bytes_sent "$http_referer" '<br>                       '"$http_user_agent" "$http_x_forwarded_for"';</p> 
 <p>    access_log  /var/log/nginx/access.log  main;</p> 
 <p>    sendfile        on;<br>     #tcp_nopush     on;</p> 
 <p>    keepalive_timeout  65;</p> 
 <p>    #gzip  on;</p> 
 <p>    <span style="color:#fe2c24;">include /etc/nginx/conf.d/*.conf;</span><br> }<br>  </p> 
</blockquote> 
<p>注意<span style="color:#fe2c24;">include /etc/nginx/conf.d/*.conf，</span><span style="color:#0d0016;">说明也包括这个路径下所有   .conf的配置文件</span></p> 
<p><span style="color:#0d0016;">所以以后我们自定义的配置文件就可以写在</span><span style="color:#fe2c24;">/etc/nginx/conf.d/</span><span style="color:#0d0016;">下，但是这是docker内部的地址，挂载到外面对应的地址应该是 /usr/local/nginx/conf.d/*.conf</span></p> 
<p><span style="color:#0d0016;">所以我们可以看到一个配置文件default.conf</span></p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/2a/ba/nKp51IAo_o.png" width="740"></p> 
<p> 我们复制一份，作为本项目的配置文件</p> 
<pre><code class="language-java"> cp default.conf gulimall.conf</code></pre> 
<p>修改一下 </p> 
<p><img alt="" height="638" src="https://images2.imgbox.com/3d/e9/Bjox3nga_o.png" width="437"></p> 
<p> <img alt="" height="753" src="https://images2.imgbox.com/d6/c6/W0RgzqDb_o.png" width="1200"></p> 
<h3>niginx+网关 -使用网关进行负载均衡</h3> 
<p><img alt="" height="676" src="https://images2.imgbox.com/d7/30/mVCgKmu9_o.png" width="584"><img alt="" height="640" src="https://images2.imgbox.com/f7/ad/gHr6RCM8_o.png" width="637"></p> 
<p> 网关修改，<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">因为nginx反向代理是根据请求地址的host来的，所以这里的断言是host断言</span></span></p> 
<pre><code class="language-XML">        - id: gulimall_nginx_route
          uri: lb://gulimall-product
          predicates:
            - Host=**.gulimall.com</code></pre> 
<p>但是nginx代理给网关的时候，会丢失host信息，需要在nginx中配置一下</p> 
<p><img alt="" height="546" src="https://images2.imgbox.com/d3/8a/f0s0EA9L_o.png" width="560"></p> 
<h2> 压力测试</h2> 
<p>压力测试考察当前软硬件环境下系统所能承受的最大负荷并帮助找出系统瓶颈所在。压测都 是为了系统在线上的处理能力和稳定性维持在一个标准范围内，做到心中有数。 使用压力测试，我们有希望找到很多种用其他测试方法更难发现的错误。有两种错误类型是: 内存泄漏，并发与同步。 有效的压力测试系统将应用以下这些关键条件:重复，并发，量级，随机变化</p> 
<p></p> 
<p>内存泄漏：就是高并发情况下，如果不优化复用对象，那么会疯狂创建对象，使得内存饱满</p> 
<p><a href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=142&amp;spm_id_from=pageDriver&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="142、性能压测-压力测试-Apache JMeter安装使用_哔哩哔哩_bilibili">142、性能压测-压力测试-Apache JMeter安装使用_哔哩哔哩_bilibili</a></p> 
<p>修改端口占用问题</p> 
<p><a href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=143&amp;spm_id_from=pageDriver&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="143、性能压测-压力测试-JMeter在windows下地址占用bug解决_哔哩哔哩_bilibili">143、性能压测-压力测试-JMeter在windows下地址占用bug解决_哔哩哔哩_bilibili</a></p> 
<p></p> 
<p>首先简单优化</p> 
<p>1.mysql优化，增加索引</p> 
<p>2.关闭thymeleaf缓存</p> 
<p>3.关闭日志</p> 
<p>4.业务优化</p> 
<p>①因为我的主页的静态资源和动态请求都放在一个模块中，无论是我查数据库的动态请求，还是静态资源的请求，都是要发给tomcat的<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">=为了解决首页全量数据的获取，采取动静分离</span></span></p> 
<p><span style="color:#0d0016;">②因为有很多查询方法重复使用，提取方法，提高方法的复用性</span></p> 
<pre><code class="language-java">    @Override
    public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJson() {
        List&lt;CategoryEntity&gt; entityList = baseMapper.selectList(null);
        // 查询所有一级分类
        List&lt;CategoryEntity&gt; level1 = getLevel1Categorys();
        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; parent_cid = level1.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(), v -&gt; {
            // 拿到每一个一级分类 然后查询他们的二级分类
            List&lt;CategoryEntity&gt; entities = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, v.getCatId()));
            List&lt;Catelog2Vo&gt; catelog2Vos=null;
            if (entities != null) {
                catelog2Vos = entities.stream().map(l2 -&gt; {
                    Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), null);
                    // 找当前二级分类的三级分类
                    List&lt;CategoryEntity&gt; level3Catelog = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, l2.getCatId()));

                    // 三级分类有数据的情况下
                    if (level3Catelog != null) {
                        List&lt;Catelog2Vo.Category3Vo&gt; catalog3Vos = level3Catelog.stream().map(l3 -&gt; new Catelog2Vo.Category3Vo(l2.getCatId().toString(),l3.getCatId().toString(),l3.getName())).collect(Collectors.toList());
                        catelog2Vo.setCatalog3List(catalog3Vos);
                    }
                    return catelog2Vo;
                }).collect(Collectors.toList());
            }
            return catelog2Vos;
        }));
        return parent_cid;
    }</code></pre> 
<p>我们发现this.list方法调用多次：即查询符合id的数据</p> 
<p>不如我们先查出所有的数据，然后用stream的filter(item-&gt;item.id=条件id)</p> 
<pre><code class="language-java">@Override
    public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJson() {
        List&lt;CategoryEntity&gt; selectList = baseMapper.selectList(null);
        // 查询所有一级分类
        List&lt;CategoryEntity&gt; level1 = getLevel1Categorys();
        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; parent_cid = level1.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(), v -&gt; {
            // 拿到每一个一级分类 然后查询他们的二级分类
//            List&lt;CategoryEntity&gt; entities = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, v.getCatId()));
            List&lt;CategoryEntity&gt; entities = getParent_cid(selectList, v.getCatId());
            List&lt;Catelog2Vo&gt; catelog2Vos=null;
            if (entities != null) {
                catelog2Vos = entities.stream().map(l2 -&gt; {
                    Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName);
                    // 找当前二级分类的三级分类
//                    List&lt;CategoryEntity&gt; level3Catelog = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, l2.getCatId()));
                    List&lt;CategoryEntity&gt; level3Catelog = getParent_cid(selectList, l2.getCatId());

                    // 三级分类有数据的情况下
                    if (level3Catelog != null) {
                        List&lt;Catelog2Vo.Category3Vo&gt; catalog3Vos = level3Catelog.stream().map(l3 -&gt; new Catelog2Vo.Category3Vo(l2.getCatId().toString(),l3.getCatId().toString(),l3.getName())).collect(Collectors.toList());
                        catelog2Vo.setCatalog3List(catalog3Vos);
                    }
                    return catelog2Vo;
                }).collect(Collectors.toList());
            }
            return catelog2Vos;
        }));
        return parent_cid;
    }
    private List&lt;CategoryEntity&gt; getParent_cid(List&lt;CategoryEntity&gt; selectList,Long parentCid) {
        List&lt;CategoryEntity&gt; categoryEntities = selectList.stream().filter(item -&gt; item.getParentCid().equals(parentCid)).collect(Collectors.toList());
        return categoryEntities;
        // return this.baseMapper.selectList(
        //         new QueryWrapper&lt;CategoryEntity&gt;().eq("parent_cid", parentCid));
    }</code></pre> 
<p><span style="color:#fe2c24;">但是这样并不能提供多少吞吐量，这里我们就需要缓存</span></p> 
<h2><span style="color:#0d0016;">缓存</span></h2> 
<p>哪些数据适合放入缓存？</p> 
<p> 即时性、数据一致性要求不高的</p> 
<p> 访问量大且更新频率不高的数据（读多，写少）</p> 
<p>缓存的方式一：在当前机器上使用map来保存，下次取就直接拿</p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/e5/9c/M8C00p4s_o.png" width="831"></p> 
<p>缺点①就是分布式中，一个微服务可能会部署很多服务器，第一次负载均衡到a机器，缓存到本地，但第二次负载均衡到b机器就找不到该缓存了</p> 
<p>②最大的缺点就是，如果修改a机器中的缓存，但是其他机器没有修改，那么后面再次读取缓存会错误</p> 
<p>所以再分布式情况下，应该使用redis</p> 
<p>缓存方法二：redis</p> 
<p><img alt="" height="510" src="https://images2.imgbox.com/a5/be/beTbCsze_o.png" width="1035"></p> 
<p></p> 
<pre><code class="language-java">public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJson2() {
        //给缓存中放json字符串，拿出的json字符串，反序列为能用的对象

        /**
         * 1、空结果缓存：解决缓存穿透问题
         * 2、设置过期时间(加随机值)：解决缓存雪崩
         * 3、加锁：解决缓存击穿问题
         */

        //1、加入缓存逻辑,缓存中存的数据是json字符串
        //JSON跨语言。跨平台兼容。
        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();
        String catalogJson = ops.get("catalogJson");
        if (StringUtils.isEmpty(catalogJson)) {
            System.out.println("缓存不命中...查询数据库...");
            //2、缓存中没有数据，查询数据库
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catalogJsonFromDb = getCatalogJsonFromDbWithRedissonLock();

            return catalogJsonFromDb;
        }

        System.out.println("缓存命中...直接返回...");
        //转为指定的对象
        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = JSON.parseObject(catalogJson,new TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;(){});

        return result;
    }</code></pre> 
<p>注意</p> 
<blockquote> 
 <p>import com.alibaba.fastjson.JSON;<br> import com.alibaba.fastjson.TypeReference;</p> 
</blockquote> 
<h2>缓存穿透 </h2> 
<p><img alt="" height="562" src="https://images2.imgbox.com/1e/f6/Rzi7X8Dw_o.png" width="1021"></p> 
<p> 以上面的缓存为例，本来都是查询缓存中的catalogJson，一切正常，但是突然100w的并发量查<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">不存在的数据</span></span>catalogJson2，就会操作<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">缓存穿透</span></span></p> 
<blockquote> 
 <p>解决缓存穿透的两种常用解决方案：1. 缓存空值，优点：简单粗暴，缺点：占用额外内存，数据不一致 2. 布隆过滤器，好处：额外内存占用较少，没有多余的key 缺点：实现较复杂，不能百分百过滤</p> 
</blockquote> 
<h2>缓存雪崩</h2> 
<p><img alt="" height="523" src="https://images2.imgbox.com/a4/0d/j89QUq6x_o.png" width="958"></p> 
<p><span style="color:#fe2c24;"><span style="background-color:#fef2f0;"> 缓存雪崩：缓存数据大面积过期</span></span></p> 
<p><img alt="" height="544" src="https://images2.imgbox.com/4b/71/C6NUqFLk_o.png" width="980"></p> 
<p>缓存击穿：<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">某一个</span></span>数据过期之后，大量请求查询这个数据 </p> 
<h3>解决问题</h3> 
<h4>1.空结果缓存：解决缓存击穿</h4> 
<h4>2.设置过期时间（加随机值）：解决缓存雪崩</h4> 
<h4>3.加锁(本地锁)，解决缓存击穿</h4> 
<pre><code class="language-java">    @Override
    public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJson() {
        /**
         * 1.空结果缓存：解决缓存击穿
         *
         * 2.设置过期时间（加随机值）：解决缓存雪崩
         *
         * 3.加锁，解决缓存击穿
         */
        ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
        String catelogJson = ops.get("catelogJson");
        if(StringUtils.isBlank(catelogJson)){
            System.out.println("缓存不命中....查数据库");
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catelogJsonFromDb = getCatelogJsonFromDb();
            String s = JSON.toJSONString(catelogJsonFromDb);
            ops.set("catelogJson",s,1, TimeUnit.HOURS);//设置过期时间
            return catelogJsonFromDb;

        }
        System.out.println("缓存命中....直接返回");
        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = JSON.parseObject(catelogJson, new TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() {});
        return result;
    }

//    @Override
    public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJsonFromDb() {
        //加锁解决缓存击穿的问题   springboot中所有容器中的组件都是单例的，这里的this指的是CategoryService
        synchronized (this){
            String catelogJson=redisTemplate.opsForValue().get("catelogJson");
            if(StringUtils.isNotBlank(catelogJson)){
                Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = JSON.parseObject(catelogJson, new TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() {});
                return result;
            }
            System.out.println("查询数据库");
            List&lt;CategoryEntity&gt; selectList = baseMapper.selectList(null);
            // 查询所有一级分类
            List&lt;CategoryEntity&gt; level1 = getLevel1Categorys();
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; parent_cid = level1.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(), v -&gt; {
                // 拿到每一个一级分类 然后查询他们的二级分类
//            List&lt;CategoryEntity&gt; entities = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, v.getCatId()));
                List&lt;CategoryEntity&gt; entities = getParent_cid(selectList, v.getCatId());
                List&lt;Catelog2Vo&gt; catelog2Vos=null;
                if (entities != null) {
                    catelog2Vos = entities.stream().map(l2 -&gt; {
                        Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName());
                        // 找当前二级分类的三级分类
//                    List&lt;CategoryEntity&gt; level3Catelog = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, l2.getCatId()));
                        List&lt;CategoryEntity&gt; level3Catelog = getParent_cid(selectList, l2.getCatId());

                        // 三级分类有数据的情况下
                        if (level3Catelog != null) {
                            List&lt;Catelog2Vo.Category3Vo&gt; catalog3Vos = level3Catelog.stream().map(l3 -&gt; new Catelog2Vo.Category3Vo(l2.getCatId().toString(),l3.getCatId().toString(),l3.getName())).collect(Collectors.toList());
                            catelog2Vo.setCatalog3List(catalog3Vos);
                        }
                        return catelog2Vo;
                    }).collect(Collectors.toList());
                }
                return catelog2Vos;
            }));
            return parent_cid;
        }


    }</code></pre> 
<p>上面这段代码的模型</p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/54/aa/P7ltN1bL_o.png" width="656"></p> 
<p> 压测。。。。</p> 
<p>如果查询数据库会在控制台打印     "查询数据库"</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/52/ec/MGGtGKP1_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"> 我们发现一共查询了3次，这是为什么呢？</span></p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/17/d4/ifRr33au_o.png" width="641"></p> 
<p>所以我们把我们的逻辑改成这样</p> 
<p> <img alt="" height="487" src="https://images2.imgbox.com/e3/36/eewJKTAf_o.png" width="648"></p> 
<p>添加代码</p> 
<blockquote> 
 <p></p> 
 <pre>public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJsonFromDb() {
        //加锁解决缓存击穿的问题   springboot中所有容器中的组件都是单例的，这里的this指的是CategoryService
        synchronized (this){
            String catelogJson=redisTemplate.opsForValue().get("catelogJson");
            if(StringUtils.isNotBlank(catelogJson)){
                Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = JSON.parseObject(catelogJson, new TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() {});
                return result;
            }
            System.out.println("查询数据库");
            List&lt;CategoryEntity&gt; selectList = baseMapper.selectList(null);
            // 查询所有一级分类
            List&lt;CategoryEntity&gt; level1 = getLevel1Categorys();
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = level1.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(), v -&gt; {
                // 拿到每一个一级分类 然后查询他们的二级分类
//            List&lt;CategoryEntity&gt; entities = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, v.getCatId()));
                List&lt;CategoryEntity&gt; entities = getParent_cid(selectList, v.getCatId());
                List&lt;Catelog2Vo&gt; catelog2Vos = null;
                if (entities != null) {
                    catelog2Vos = entities.stream().map(l2 -&gt; {
                        Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName());
                        // 找当前二级分类的三级分类
//                    List&lt;CategoryEntity&gt; level3Catelog = this.list(new LambdaQueryWrapper&lt;CategoryEntity&gt;().eq(CategoryEntity::getParentCid, l2.getCatId()));
                        List&lt;CategoryEntity&gt; level3Catelog = getParent_cid(selectList, l2.getCatId());

                        // 三级分类有数据的情况下
                        if (level3Catelog != null) {
                            List&lt;Catelog2Vo.Category3Vo&gt; catalog3Vos = level3Catelog.stream().map(l3 -&gt; new Catelog2Vo.Category3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName())).collect(Collectors.toList());
                            catelog2Vo.setCatalog3List(catalog3Vos);
                        }
                        return catelog2Vo;
                    }).collect(Collectors.toList());
                }
                return catelog2Vos;
            }));
           <span style="color:#fe2c24;"> String s = JSON.toJSONString(result);
            redisTemplate.opsForValue().set("catelogJson",s,1, TimeUnit.HOURS);</span>

            return result;
        }


    }</pre> 
</blockquote> 
<p>结果</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/0d/08/rAlMnPKK_o.png" width="983"></p> 
<h4> 本地锁缺点</h4> 
<p>我们假设有8台服务器，那么就有8哥容器，那就会有8个锁(this)，就会同时有8个线程去查数据库</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/d3/a3/e3iNpfPS_o.png" width="830"></p> 
<p> 所以我们需要分布式锁</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/ec/51/rSBc2ERD_o.png" width="930"></p> 
<blockquote> 
 <p>基本思想就是：所有线程来查询缓存，如果缓存没有命中，那么就去查询数据库，当第一个线程去查数据库时，在redis存一个数据(Lock-这个随意是什么),这就是锁。以后要来数据库查询时，线程都先去redis中查看有没有lock这个数据，有的话就等待释放锁(拿到锁的线程将Lock删除) </p> 
</blockquote> 
<p></p> 
<pre><code class="language-java">    public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJsonFromDbWithRedisLock() throws InterruptedException {
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent("lock", "111");

        if(ifAbsent){
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = getCatelogJsonFromDb();
            redisTemplate.delete("lock");
            return result;
        }else{
            Thread.sleep(100);
            return getCatelogJsonFromDbWithRedisLock();

        }
    }</code></pre> 
<p><img alt="" height="524" src="https://images2.imgbox.com/6a/c6/tATbpc7t_o.png" width="966"></p> 
<p></p> 
<blockquote> 
 <p>但也存在一个问题，如果getCatelogJsonFromDb()这个方法出现异常，那么就不会执行redisTemplate.delete("lock");就会出现死锁-</p> 
 <p><span style="color:#fe2c24;">解决方法就是将这个锁设置自动过期时间</span></p> 
</blockquote> 
<pre><code class="language-java">    public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJsonFromDbWithRedisLock() throws InterruptedException {
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent("lock", "111");
        if(ifAbsent){
            redisTemplate.expire( 3, TimeUnit.SECONDS);
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = getCatelogJsonFromDb();
            redisTemplate.delete("lock");
            return result;
        }else{
            Thread.sleep(100);
            return getCatelogJsonFromDbWithRedisLock();

        }




    }</code></pre> 
<blockquote> 
 <p>这种写法也会有问题，if(ifAbsent)之后突然宕机，还没来得及设置过期时间，没有保证redis的原子性</p> 
</blockquote> 
<p><img alt="" height="633" src="https://images2.imgbox.com/26/32/TO3udcWC_o.png" width="1172"></p> 
<p></p> 
<pre><code class="language-java">public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJsonFromDbWithRedisLock() throws InterruptedException {
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent("lock", "111", 3, TimeUnit.SECONDS);
        if(ifAbsent){
//            redisTemplate.expire("lock",3,TimeUnit.SECONDS);
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = getCatelogJsonFromDb();
            redisTemplate.delete("lock");
            return result;
        }else{
            Thread.sleep(100);
            return getCatelogJsonFromDbWithRedisLock();

        }

    }
</code></pre> 
<blockquote> 
 <p>但是依旧存在问题，假如我们设置过期时间为20s，但是查询数据库用了30s.线程A开始查询数据库，20s过去了，锁自动释放，线程B拿到锁开始查询数据库，过了10s后线程A的查询结束，redisTemplate.delete("lock");这样就会删除线程B的锁，然后线程C就会拿到锁</p> 
</blockquote> 
<p>修改：</p> 
<pre><code class="language-java">public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJsonFromDbWithRedisLock() throws InterruptedException {
        String UUID= java.util.UUID.randomUUID().toString();
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent("lock", UUID, 3, TimeUnit.SECONDS);
        if(ifAbsent){
//            redisTemplate.expire("lock",3,TimeUnit.SECONDS);
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = getCatelogJsonFromDb();
            String s = redisTemplate.opsForValue().get("lock");
            if(s.equals(UUID)){

                redisTemplate.delete("lock");
            }
            return result;
        }else{
            Thread.sleep(100);
            return getCatelogJsonFromDbWithRedisLock();

        }




    }
</code></pre> 
<blockquote> 
 <p>当然又出现问题了，那就是String s = redisTemplate.opsForValue().get("lock");之后lock过期，另一个线程进来拿锁，设置lock，前一个线程执行redisTemplate.delete("lock");又会误删</p> 
 <p>所以  <span style="color:#fe2c24;"><span style="background-color:#fff5e6;">获取值对比+对比成功册除  一定要是  原子操作  ，要用lua脚本</span></span></p> 
</blockquote> 
<pre><code class="language-java">    public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatelogJsonFromDbWithRedisLock()  {
        String UUID= java.util.UUID.randomUUID().toString();
        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent("lock", UUID, 300, TimeUnit.SECONDS);
        if(ifAbsent){
            System.out.println("获取分布式锁成功");
//            redisTemplate.expire("lock",3,TimeUnit.SECONDS);
            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result=null;

            try {

                result = getCatelogJsonFromDb();
            }finally {

                String script="if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('get',KEYS[1]) else return 0 end";
                redisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script,Long.class),Arrays.asList("lock"),UUID);
            }

            return result;
        }else{
            System.out.println("获取分布式锁失败");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return getCatelogJsonFromDbWithRedisLock();

        }




    }</code></pre> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>总结 获取锁时-保证原子性，释放锁的时候保证原子性</strong></span></p> 
<p></p> 
<h3>Redisson</h3> 
<blockquote> 
 <p><span style="color:#ff9900;">https://github.com/redisson/redisson</span></p> 
 <p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data <br> Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服<br> 务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, <br> BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, <br> CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring <br> cache, Executor service, Live Object service, Scheduler service) Redisson提供<br> 了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的<br> 关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处<br> 理业务逻辑上。</p> 
 <p><br> (1) 环境搭建<br> 导入依赖<br> &lt;dependency&gt;<br>     &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>     &lt;artifactId&gt;redisson&lt;/artifactId&gt;<br>     &lt;version&gt;3.13.4&lt;/version&gt;<br> &lt;/dependency&gt;<br> 这个用作连续，后面可以使用redisson-spring-boot-starter</p> 
 <p><br> 开启配置https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95<br> @Configuration<br> public class MyRedisConfig {<!-- --></p> 
 <p>    @Value("${ipAddr}")<br>     private String ipAddr;</p> 
 <p>    // redission通过redissonClient对象使用 // 如果是多个redis集群，可以配置<br>     @Bean(destroyMethod = "shutdown")<br>     public RedissonClient redisson() {<!-- --><br>         Config config = new Config();<br>         // 创建单例模式的配置<br>         config.useSingleServer().setAddress("redis://" + ipAddr + ":6379");<br>         return Redisson.create(config);<br>     }<br> }</p> 
 <p><span style="color:#fe2c24;">测试</span></p> 
 <p><span style="color:#fe2c24;">    @Autowired<br>     RedissonClient redisson;</span></p> 
 <pre>    @ResponseBody
    @GetMapping(value = "/hello")
    public String hello() {

        //1、获取一把锁，只要锁的名字一样，就是同一把锁
        RLock myLock = redisson.getLock("my-lock");

        //2、加锁
        myLock.lock();      //<span style="color:#fe2c24;">阻塞式等待。默认加的锁都是30s，如果没有拿到锁就在这里一直等待</span>
        
        try {
            System.out.println("加锁成功，执行业务..." + Thread.currentThread().getId());
            try { TimeUnit.SECONDS.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); }
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            //3、解锁  假设解锁代码没有运行，Redisson会不会出现死锁
            System.out.println("释放锁..." + Thread.currentThread().getId());
            myLock.unlock();
        }

        return "hello";
    }

}</pre> 
 <p>然后执行两次<a href="http://localhost:10001/hello" rel="nofollow" title="http://localhost:10001/hello">http://localhost:10001/hello</a></p> 
 <p><img alt="" height="87" src="https://images2.imgbox.com/3c/35/Yw8WhIXm_o.png" width="323"></p> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">myLock.lock();的三点好处</span></span></p> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">①</span>阻塞式等待。如果没有拿到锁就在这里一直等待</span></p> 
 <p><span style="color:#fe2c24;">②自动设置了锁的过期时间，默认加的锁都是30s。如果业务处理过程中宕机，过了过期时间自动释放锁</span></p> 
 <p><span style="color:#fe2c24;">③如果业务时长超过了锁的过期时间，redisson也会自动续费/自动续期</span></p> 
 <p><span style="color:#fe2c24;">综上所述  不会出现死锁</span></p> 
 <p>我总结一波。就是本来锁自动设置了30秒过期，但是我们业务处理超过了30s，不用担心，redis会自动延长过期时间，直到你业务处理完后，30s内给你自动删除锁。 </p> 
 <p><span style="color:#fe2c24;">看门狗机制</span></p> 
 <p>        //2、加锁<br>         myLock.lock();      //阻塞式等待。默认加的锁都是30s<br>         //1）、锁的自动续期，如果业务超长，运行期间自动锁上新的30s。不用担心业务时间长，锁自动过期被删掉<br>         //2）、加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认会在30s内自动过期，不会产生死锁问题<br>         // myLock.lock(10,TimeUnit.SECONDS);   //10秒钟自动解锁,自动解锁时间一定要大于业务执行时间   <span style="color:#fe2c24;">问题：在锁时间到了以后，不会自动续期</span><br>         //<br>         //1、如果我们传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时就是 我们制定的时间<br>         //2、如果我们未指定锁的超时时间，就使用 lockWatchdogTimeout = 30 * 1000 【看门狗默认时间】<br>         //只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】,每隔10秒都会自动的再次续期，续成30秒<br>         // 默认10s是怎么来的：internalLockLeaseTime 【看门狗时间】 / 3， 10s</p> 
 <p>但是还是推荐使用myLock.lock(10,TimeUnit.SECONDS); 这样就不会有自动续期的操作了</p> 
 <p>-------------------------------------------------------------------------------------</p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>(1)公平锁</p> 
 <p>12345线程进入</p> 
 <p>1线程拿到锁，释放锁，接下来就是2拿锁，3，4，5 依次类推  比较公平</p> 
 <p>redisson.getFairLock("my-lock");</p> 
 <p>其他都一样</p> 
</blockquote> 
<blockquote> 
 <p>(2) 可重入锁（Reentrant Lock）<br> 分布式锁：github.com/redisson/redisson/wiki/8.-分布式锁和同步器</p> 
 <p>A调用B。AB都需要同一锁，此时可重入锁就可以重入，A就可以调用B。不可重入锁时，A调用B将死锁<br> // 参数为锁名字<br> RLock lock = redissonClient.getLock("CatalogJson-Lock");//该锁实现了JUC.locks.lock接口<br> lock.lock();//阻塞等待<br> // 解锁放到finally // 如果这里宕机：有看门狗，不用担心<br> lock.unlock();</p> 
 <p>基于Redis的Redisson分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p> 
 <p>锁的续期：大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，<br> 而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情<br> 况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实<br> 例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间<br> 是30秒钟（每到20s就会自动续借成30s，是1/3的关系），也可以通过修改<br> Config.lockWatchdogTimeout来另行指定。</p> 
 <p><br> // 加锁以后10秒钟自动解锁，看门狗不续命<br> // 无需调用unlock方法手动解锁<br> lock.lock(10, TimeUnit.SECONDS);</p> 
 <p>// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁<br> boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);<br> if (res) {<!-- --><br>    try {<!-- --><br>      ...<br>    } finally {<!-- --><br>        lock.unlock();<br>    }<br> }<br> 如果传递了锁的超时时间，就执行脚本，进行占锁;<br> 如果没传递锁时间，使用看门狗的时间，占锁。如果返回占锁成功future，调用future.onComplete();<br> 没异常的话调用scheduleExpirationRenewal(threadId);<br> 重新设置过期时间，定时任务;<br> 看门狗的原理是定时任务：重新给锁设置过期时间，新的过期时间就是看门狗的默认时间;<br> 锁时间/3是定时任务周期;</p> 
 <p><br> Redisson同时还为分布式锁提供了异步执行的相关方法：<br> RLock lock = redisson.getLock("anyLock");<br> lock.lockAsync();<br> lock.lockAsync(10, TimeUnit.SECONDS);<br> Future&lt;Boolean&gt; res = lock.tryLockAsync(100, 10, TimeUnit.SECONDS);</p> 
 <p><br> RLock对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出IllegalMonitorStateException错误。但是如果遇到需要其他进程也能解锁的情况，请使用分布式信号量Semaphore 对象.<br> public Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonDbWithRedisson() {<!-- --><br>     Map&lt;String, List&lt;Catalog2Vo&gt;&gt; categoryMap=null;<br>     RLock lock = redissonClient.getLock("CatalogJson-Lock");<br>     lock.lock();<br>     try {<!-- --><br>         Thread.sleep(30000);<br>         categoryMap = getCategoryMap();<br>     } catch (InterruptedException e) {<!-- --><br>         e.printStackTrace();<br>     }finally {<!-- --><br>         lock.unlock();<br>         return categoryMap;<br>     }<br> }</p> 
 <p><br> (3) 读写锁（ReadWriteLock）<br> 基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了<br> java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了RLock<br> 接口。</p> 
 <p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p> 
 <p>RReadWriteLock rwlock = redisson.getReadWriteLock("anyRWLock");<br> // 最常见的使用方法<br> rwlock.readLock().lock();<br> // 或<br> rwlock.writeLock().lock();</p> 
 <p>// 10秒钟以后自动解锁<br> // 无需调用unlock方法手动解锁<br> rwlock.readLock().lock(10, TimeUnit.SECONDS);<br> // 或<br> rwlock.writeLock().lock(10, TimeUnit.SECONDS);</p> 
 <p>// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁<br> boolean res = rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);<br> // 或<br> boolean res = rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);<br> ...<br> lock.unlock();</p> 
 <p><br> 上锁时在redis的状态<br> HashWrite-Lock<br> key:mode  value:read<br> key:sasdsdffsdfsdf... value:1</p> 
 <p><br><br><br> (4) 信号量（Semaphore）-<span style="color:#fe2c24;">可以用于限流</span><br> 信号量为存储在redis中的一个数字，当这个数字大于0时，即可以调用acquire()方法增加数量，也可以调用release()方法减少数量，但是当调用release()之后小于0的话方法就会阻塞，直到数字大于0</p> 
</blockquote> 
<blockquote> 
 <p>@GetMapping("/park")<br> @ResponseBody<br> public String park() {<!-- --><br>     RSemaphore park = redissonClient.getSemaphore("park");<br>     try {<!-- --><br>         park.acquire(2);//当且仅当redis中park的value大于等于2的时候可以执行<br>     } catch (InterruptedException e) {<!-- --><br>         e.printStackTrace();<br>     }<br>     return "停进2";<br> }</p> 
 <p>@GetMapping("/go")<br> @ResponseBody<br> public String go() {<!-- --><br>     RSemaphore park = redissonClient.getSemaphore("park");<br>     park.release(2);<br>     return "开走2";<br> }</p> 
</blockquote> 
<p>除了acquire()阻塞性，也可以是用tryacquire()，不会阻塞，如果无法执行就返回false</p> 
<blockquote> 
 <p><br> (5) 闭锁（CountDownLatch）</p> 
 <p><a href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=164&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="164、缓存-分布式锁-Redisson-闭锁测试_哔哩哔哩_bilibili">164、缓存-分布式锁-Redisson-闭锁测试_哔哩哔哩_bilibili</a></p> 
 <p><br> 缓存和数据库一致性<br> 双写模式：写数据库后，写缓存<br> 问题：并发时，2写进入，写完DB后都写缓存。有暂时的脏数据<br> 失效模式：写完数据库后，删缓存<br> 问题：还没存入数据库呢，线程2又读到旧的DB了<br> 解决：缓存设置过期时间，定期更新<br> 解决：写数据写时，加分布式的读写锁。<br> 解决方案：</p> 
 <p>如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可<br> 如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式<br> 缓存数据+过期时间也足够解决大部分业务对于缓存的要求。<br> 通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心脏数据，允许临时脏数据可忽略）；<br> 总结：</p> 
 <p>我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。<br> 我们不应该过度设计，增加系统的复杂性<br> 遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。</p> 
</blockquote> 
<h2>SpringCache</h2> 
<p>引入依赖</p> 
<pre><code class="language-java">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<h3 id="mmC7X">添加配置</h3> 
<p id="8108c9980b2f41f98676ba87932aa417">自动配置了：</p> 
<ul><li id="05db00c7e1999a08121eab05ee0e8a2b">CacheAutoConfiguration 会导入 RedisCacheConfiguration;</li><li id="766390ad5cc540f8d7f0ea5699119276">会自动装配缓存管理器 RedisCacheManager;</li></ul> 
<p id="b3bd02f50ad4e926b60169429ccaaa94">手动配置：</p> 
<pre><code>spring.cache.type=redis

#spring.cache.cache-names=qq,毫秒为单位
spring.cache.redis.time-to-live=3600000

#如果指定了前缀就用我们指定的前缀，如果没有就默认使用缓存的名字作为前缀
#spring.cache.redis.key-prefix=CACHE_
spring.cache.redis.use-key-prefix=true

#是否缓存空值，防止缓存穿透
spring.cache.redis.cache-null-values=true</code></pre> 
<pre><code class="language-java">@EnableConfigurationProperties(CacheProperties.class)
@Configuration
@EnableCaching
public class MyCacheConfig {

    /**
     * 配置文件的配置没有用上
     * 1. 原来和配置文件绑定的配置类为：@ConfigurationProperties(prefix = "spring.cache")
     *                                public class CacheProperties
     * &lt;p&gt;
     * 2. 要让他生效，要加上 @EnableConfigurationProperties(CacheProperties.class)
     */
    @Bean
    public RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
        // config = config.entryTtl();
        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));
        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        CacheProperties.Redis redisProperties = cacheProperties.getRedis();
        //将配置文件中所有的配置都生效
        if (redisProperties.getTimeToLive() != null) {
            config = config.entryTtl(redisProperties.getTimeToLive());
        }
        if (redisProperties.getKeyPrefix() != null) {
            config = config.prefixKeysWith(redisProperties.getKeyPrefix());
        }
        if (!redisProperties.isCacheNullValues()) {
            config = config.disableCachingNullValues();
        }
        if (!redisProperties.isUseKeyPrefix()) {
            config = config.disableKeyPrefix();
        }
        return config;
    }
}</code></pre> 
<h3 id="udaQU">常用注解</h3> 
<ul><li id="bb12f224d689951e15fe91e903c4e0ac">@Cacheable ：触发将数据保存到缓存的操作；</li><li id="5e8d7a9cd73bb6bffe2e759754ff303c">@CacheEvict : 触发将数据从缓存删除的操作；</li><li id="45386a91cff14e246b95215edba772a5">@CachePut ：不影响方法执行更新缓存；</li><li id="16201142113da37082c1a29209a83a58">@Cacheing：组合以上多个操作；</li><li id="912c8f04f05facd7a59f84accf1adb7f">@CacheConfig：在类级别共享缓存的相同配置；</li></ul> 
<p>使用：</p> 
<pre><code class="language-java">    //如果缓存有数据，就不再调用这个方法，value指的是放在哪个缓存区域，可以有多个缓存区
    //key就是自定义的存放在redis中的名字
    //sync = true 开启同步
    @Cacheable(value = {"category"},key = "#root.method.name",sync = true)
    @Override
    public List&lt;CategoryEntity&gt; getLevel1Categorys() {
        System.out.println("getLevel1Categorys");
        LambdaQueryWrapper&lt;CategoryEntity&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
        wrapper.eq(CategoryEntity::getCatLevel,1);
         return this.list(wrapper);
    }</code></pre> 
<pre><code class="language-java">    /**
     * 级联更新所有关联的数据
     *
     * @CacheEvict:失效模式
     * @CachePut:双写模式，需要有返回值
     * 1、同时进行多种缓存操作：@Caching
     * 2、指定删除某个分区下的所有数据 @CacheEvict(value = "category",allEntries = true)
     * 3、存储同一类型的数据，都可以指定为同一分区
     * @param category
     */
    // @Caching(evict = {
    //         @CacheEvict(value = "category",key = "'getLevel1Categorys'"), //注意这里的 ' '
    //         @CacheEvict(value = "category",key = "'getCatalogJson'")
    // })
    @CacheEvict(value = "category",allEntries = true)       //删除某个分区下的所有数据
    @Transactional(rollbackFor = Exception.class)
    @Override
    public void updateCascade(CategoryEntity category) {

        RReadWriteLock readWriteLock = redissonClient.getReadWriteLock("catalogJson-lock");
        //创建写锁
        RLock rLock = readWriteLock.writeLock();

        try {
            rLock.lock();
            this.baseMapper.updateById(category);
            categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rLock.unlock();
        }

        //同时修改缓存中的数据
        //删除缓存,等待下一次主动查询进行更新
    }</code></pre> 
<blockquote> 
 <p>    /**<br>      * 每一个需要缓存的数据我们都来指定要放到那个名字的缓存。【缓存的分区(按照业务类型分)】<br>      * 代表当前方法的结果需要缓存，如果缓存中有，方法都不用调用，如果缓存中没有，会调用方法。最后将方法的结果放入缓存<br>      * 默认行为<br>      *      如果缓存中有，方法不再调用<br>      *      key是默认生成的:缓存的名字::SimpleKey::[](自动生成key值)<br>      *      缓存的value值，默认使用jdk序列化机制，将序列化的数据存到redis中<br>      *      默认时间是 -1：<br>      *<br>      *   自定义操作：key的生成<br>      *      指定生成缓存的key：key属性指定，接收一个Spel<br>      *      指定缓存的数据的存活时间:配置文档中修改存活时间<br>      *      将数据保存为json格式<br>      *<br>      *<br>      * 4、Spring-Cache的不足之处：<br>      *  1）、读模式-读取数据时，会出现的问题及其解决方法<br>      *      缓存穿透：查询一个null数据。解决方案：缓存空数据<br>      *      缓存击穿：大量并发进来同时查询一个正好过期的数据。解决方案：加锁 ? <span style="color:#fe2c24;">默认是无加锁</span>的;使用sync = true来解决击穿问题。 @Cacheable(value = {"category"},key = "#root.method.name",sync = true)</p> 
 <p>   加了sync = true，就会执行这个加了锁的方法<img alt="" height="30" src="https://images2.imgbox.com/67/53/UchVRQLI_o.png" width="748"><br>      *      缓存雪崩：大量的key同时过期。解决：加随机时间。加上过期时间<br>      *  2)、写模式：更新数据（缓存与数据库一致）<br>      *      1）、读写加锁。<br>      *      2）、引入Canal,感知到MySQL的更新去更新Redis<br>      *      3）、读多写多，直接去数据库查询就行<br>      *<br>      *  总结：<br>      *      常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用Spring-Cache）：写模式(只要缓存的数据有过期时间就足够了)<br>      *      特殊数据：特殊设计<br>      *<br>      *<span style="color:#fe2c24;">  原理：</span></p> 
 <p></p> 
 <p><span style="color:#fe2c24;">缓存所有功能都是AOP做的</span></p> 
 <p><span style="color:#fe2c24;">              大概：  </span><span style="color:#0d0016;">加了cacheable之后，先查询缓存中有没有想要的数据，有的话就不执行写了注解的方法，没有就执行</span></p> 
 <p><span style="color:#fe2c24;">               </span><span style="color:#0d0016;"> 具体：springcache中有一个缓存管理器CacheManager,帮我们造出很多的缓存组件cache，</span></p> 
 <p><span style="color:#0d0016;">                cache负责缓存的读写。我的项目中使用的是redis作为缓存，所以管理器是redisCacheManager</span></p> 
 <p><span style="color:#0d0016;">                组件是springcache</span><br>      *      <br>      * <br>      */</p> 
</blockquote> 
<h2>异步 </h2> 
<p></p> 
<h3>1. 初始化线程的4种方式</h3> 
<h4><a name="t3"></a><a id="11__Thread_8"></a>1.1 继承 Thread</h4> 
<pre><code class="language-java">public class ThreadTest {
    public static void main(String[] args) {
        System.out.println("main......start...");
        Thread01 thread01 = new Thread01();
        thread01.start();
        System.out.println("main......end...");
    }

    public static class Thread01 extends Thread{
        @Override
        public void run() {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=10/2;
            System.out.println("运行结果:"+i);
        }
    }
}
</code></pre> 
<p>运行结果</p> 
<p><img alt="image-20211122225513596" src="https://images2.imgbox.com/db/66/l5VXD0Dk_o.png"></p> 
<h3> 1.2 实现 Runnable 接口</h3> 
<pre><code class="language-java">public class ThreadTest {
    public static void main(String[] args) {
        System.out.println("main......start...");
//        Thread01 thread01 = new Thread01();
//        thread01.start();

        Thread02 thread02 = new Thread02();
        new Thread(thread02).start();
        System.out.println("main......end...");
    }

    public static class Thread01 extends Thread{
        @Override
        public void run() {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=10/2;
            System.out.println("运行结果:"+i);
        }
    }

    public static class Thread02 implements Runnable{
        @Override
        public void run() {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=12/2;
            System.out.println("运行结果:"+i);
        }
    }
}</code></pre> 
<p><img alt="image-20211122225922053" src="https://images2.imgbox.com/41/14/GPrs6bUp_o.png"></p> 
<h3> 1.3 实现 Callable 接口 + FutureTask （可以拿到返回结果， 可以处理异常）</h3> 
<pre><code class="language-java">public class ThreadTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main......start...");
//        Thread01 thread01 = new Thread01();
//        thread01.start();

//        Thread02 thread02 = new Thread02();
//        new Thread(thread02).start();

        FutureTask futureTask = new FutureTask&lt;&gt;(new Thread03());
        new Thread(futureTask).start();
        Integer i = (Integer) futureTask.get();
        System.out.println("main......end..."+i);
    }

    public static class Thread01 extends Thread{
        @Override
        public void run() {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=10/2;
            System.out.println("运行结果:"+i);
        }
    }

    public static class Thread02 implements Runnable{
        @Override
        public void run() {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=12/2;
            System.out.println("运行结果:"+i);
        }
    }

    public static class Thread03 implements Callable {

        @Override
        public Object call() throws Exception {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=14/2;
            System.out.println("运行结果:"+i);
            return i;
        }
    }
}
</code></pre> 
<p><img alt="image-20211122230756459" src="https://images2.imgbox.com/a8/bb/Ciaoos8e_o.png"></p> 
<h4>1.3.1 注意</h4> 
<p>实现callable的方法可以拿到返回值</p> 
<p>FutureTask继承了Runnable</p> 
<p> <img alt="image-20211122231218541" src="https://images2.imgbox.com/33/3f/05hnS5CA_o.png"></p> 
<h3> 1.4 线程池</h3> 
<blockquote> 
 <p>为什么要用线程池，不直接new Thread？</p> 
 <p>因为系统分配的内存是有限的。在高并发的环境下，如果有100w并发量，1个请求要开启10个异步任务，100w就需要1000w个线程，会导致系统崩溃</p> 
</blockquote> 
<p>所以以后的业务都是用线程池</p> 
<h4>1.4.1 初始化线程池(方式一)</h4> 
<p>因为我们的一个系统必须只能有一个线程池(是这样吗？)，所以要定义为静态</p> 
<pre><code class="language-java">public static ExecutorService service = Executors.newFixedThreadPool(10);</code></pre> 
<p>service有两个方法调用线程，一个是submit，一个是execute。submit有返回值，execute没有返回值<br>  </p> 
<pre><code class="language-java">public static ExecutorService service = Executors.newFixedThreadPool(10);
    public static void main(String[] args) {
        service.execute(new Thread02());
    }
    public static class Thread01 extends Thread{
        @Override
        public void run() {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=10/2;
            System.out.println("运行结果:"+i);
        }
    }

    public static class Thread02 implements Runnable{
        @Override
        public void run() {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=12/2;
            System.out.println("运行结果:"+i);
        }
    }

    public static class Thread03 implements Callable {

        @Override
        public Object call() throws Exception {
            System.out.println("当前线程:"+Thread.currentThread().getName());
            Integer i=14/2;
            System.out.println("运行结果:"+i);
            return i;
        }
    }
}</code></pre> 
<blockquote> 
 <p>总结：① 继承Thread    实现Runable 没有返回值，实现Callable接口 有返回值</p> 
 <p>         ②前三者都不能控制资源，只有线程池可以控制资源，性能稳定</p> 
</blockquote> 
<h4>1.4.2 初始化线程池(方式二) </h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fff5e6;">三种方法，7大参数，4种拒绝策略</span></span></p> 
</blockquote> 
<blockquote> 
 <p>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit unit,workQueue, threadFactory, handler); </p> 
</blockquote> 
<p>1.4.2.1</p> 
<p><span style="color:#fe2c24;"><strong>七大参数</strong></span><br><strong>corePoolSize[5]</strong>:核心线程数，一直存在除非（alLowCoreThreadTimeOut我们给他设置过期时间) ];线程池，创建好以后就准备就绪<br>         5个    Thread thread = new Thread(); thread.start( );<br><strong>maximumPooLSize : [200]</strong>最大线程数量;控制资源<br><strong>keepAliveTime</strong>:存活时间。如果当前的线程数量大于core数量且线程空闲大于指定的keepALiveTime就会释放空闲的线程（数量为：maximumPoolSize-corePoolSize)。</p> 
<p><strong>unit</strong>:时间单位<br><strong>BLockingQueue&lt;Runnable&gt; workQueue</strong>:阻塞队列。如果任务有很多，就会将目前多的任务放在队列里面。只要有线程空闲,就会去队列里面取出新的任务继续执行。<br><strong>threadFactory</strong> :线程的创建工厂。<br><strong>RejectedExecutionHandLer handLer</strong>:如果队列满了，按照我们指定的拒绝策略拒绝执行任务，下图是几种常见的拒绝策略，默认使用AbortPolicy</p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/de/3a/nDIP716Z_o.png" width="594"><br><span style="color:#fe2c24;">工作顺序:</span><br> 1)、线程池创建,准备好core数量的核心线程,准备接受任务<br>         1.1、core满了，就将再进来的任务放入阻塞队列中。空闲的core就会自己去阻塞队列获取 任    务执行；</p> 
<p>        1.2、阻塞队列满了，就直接开新线程执行，最大只能开到max指定的数量<br>         1.3、max满了就用RejectedExecutionHandler拒绝任务<br>         1.4、max都执行完成，有很多空闲.在指定的时间keepAliveTime以后，释放max-core这些线程</p> 
<blockquote> 
 <p>Q：<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">—个线程池core 7;max 20 , queue: 50，100个并发进来怎么分配的;</span></span><br> core=7，所以7并发个会立即得到执行，阻塞队列长度是50，所以50个并发会进入队列，队列满了之后，再开13个线程，这时候达到了最大线程数。队列中13个并发就拿到这13个线程，队列空余13个位置，就是13个并发补上，最后剩下的30个就使用拒绝策略。如果不想丢弃可以使用CallRunsPolicy，直接同步调用方法</p> 
</blockquote> 
<h4>1.4.3 常见的4种线程池</h4> 
<p><br> 1、newCachedThreadPool：核心线程数是0，如果空闲会回收所有线程【缓存线程池】</p> 
<p>​ 创建一个可缓存线程池， 如果线程池长度超过处理需要， 可灵活回收空闲线程， 若无可回收， 则新建线程。</p> 
<p>2、newFixedThreadPool：核心线程数 = 最大线程数，【不回收】</p> 
<p>​ 创建一个定长线程池， 可控制线程最大并发数， 超出的线程会在队列中等待。</p> 
<p>3、newScheduledThreadPool：定时任务线程池，多久之后执行【可提交核心线程数，最大线程数是Integer.Max】</p> 
<p>​ 创建一个定长线程池， 支持定时及周期性任务执行。</p> 
<p>4、newSingleThreadPool：核心与最大都只有一个【不回收】,后台从队列中获取任务</p> 
<p>​ 创建一个单线程化的线程池， 它只会用唯一的工作线程来执行任务， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p> 
<h2></h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8b6f6a5f1d8307b26a34b01231bc900/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Centos 7 用户密码忘记解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf0437ee1e92823713c161645d73df3f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【重铸Java根基】集合相关知识点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>