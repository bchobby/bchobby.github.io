<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MFC串口操作一：显示串口输入信息 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MFC串口操作一：显示串口输入信息" />
<meta property="og:description" content="目录
一、目的
1、想知道：MFC串口输入输出信息
二、参考
1、无
三、问题：
1、当有提示说明：OnComm不准确时候，
①方法一：LONG改为LRESULT
四、操作
1、运行效果：完成MFC获取串口输入信息功能
1、创建新工程：我取名字为：MyComTest
1、SerialPort.h
1、SerialPort.cpp
1、将SerialPort.h和SerialPort.cpp文件复制到项目中
1、头文件添加现有项：SerialPort.h
1、源文件添加现有项：SerialPort.cpp
1、MyComTestDlg.h：创建串口SerialPort类：记得头文件
1、创建编辑框：显示外面发送来的串口信息：名字叫做：IDC_EDIT1
1、添加MFC相应消息事件：为了方便得到外面的信息：（因为我没有找到类向导之类直接导入这个事件的方法，直接填写代码也可以实现同样的功能）
1、初始化：串口类：MyComTestDlg.cpp：OnInitDialog（）中
1、注销和关闭串口：
一、目的 1、想知道：MFC串口输入输出信息 二、参考 1、无 三、问题： 1、当有提示说明：OnComm不准确时候， 答：
①方法一：LONG改为LRESULT afx_msg LRESULT OnComm(WPARAM ch,LPARAM port);//为了有消息给MFC发送后，MFC有变化 LRESULT CFlashAndVideoDlg::OnComm(WPARAM ch,LPARAM port) 四、操作 1、运行效果：完成MFC获取串口输入信息功能 ①我发送了7位的串口信号，它只会读取我设置额度前6个信号。
1、创建新工程：我取名字为：MyComTest 1、SerialPort.h #pragma once #define WM_COMM_BREAK_DETECTED WM_USER&#43;1 // A break was detected on input. #define WM_COMM_CTS_DETECTED WM_USER&#43;2 // The CTS (clear-to-send) signal changed state. #define WM_COMM_DSR_DETECTED WM_USER&#43;3 // The DSR (data-set-ready) signal changed state." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/0772b7cbb2f5ff62f9bd5256a10d0ce7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-26T11:11:31+08:00" />
<meta property="article:modified_time" content="2020-05-26T11:11:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MFC串口操作一：显示串口输入信息</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%9B%AE%E7%9A%84-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%9B%AE%E7%9A%84" rel="nofollow">一、目的</a></p> 
<p id="1%E3%80%81%E6%83%B3%E7%9F%A5%E9%81%93%EF%BC%9AMFC%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%83%B3%E7%9F%A5%E9%81%93%EF%BC%9AMFC%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF" rel="nofollow">1、想知道：MFC串口输入输出信息</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8F%82%E8%80%83-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%8F%82%E8%80%83" rel="nofollow">二、参考</a></p> 
<p id="1%E3%80%81%E6%97%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%97%A0" rel="nofollow">1、无</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%9A" rel="nofollow">三、问题：</a></p> 
<p id="1%E3%80%81%E5%BD%93%E6%9C%89%E6%8F%90%E7%A4%BA%E8%AF%B4%E6%98%8E%EF%BC%9AOnComm%E4%B8%8D%E5%87%86%E7%A1%AE%E6%97%B6%E5%80%99%EF%BC%8C-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%BD%93%E6%9C%89%E6%8F%90%E7%A4%BA%E8%AF%B4%E6%98%8E%EF%BC%9AOnComm%E4%B8%8D%E5%87%86%E7%A1%AE%E6%97%B6%E5%80%99%EF%BC%8C" rel="nofollow">1、当有提示说明：OnComm不准确时候，</a></p> 
<p id="%E2%91%A0%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ALONG%E6%94%B9%E4%B8%BALRESULT-toc" style="margin-left:80px;"><a href="#%E2%91%A0%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ALONG%E6%94%B9%E4%B8%BALRESULT" rel="nofollow">①方法一：LONG改为LRESULT</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C" rel="nofollow">四、操作</a></p> 
<p id="1%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A%E5%AE%8C%E6%88%90MFC%E8%8E%B7%E5%8F%96%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%85%A5%E4%BF%A1%E6%81%AF%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A%E5%AE%8C%E6%88%90MFC%E8%8E%B7%E5%8F%96%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%85%A5%E4%BF%A1%E6%81%AF%E5%8A%9F%E8%83%BD" rel="nofollow">1、运行效果：完成MFC获取串口输入信息功能</a></p> 
<p id="1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%B0%E5%B7%A5%E7%A8%8B%EF%BC%9A%E6%88%91%E5%8F%96%E5%90%8D%E5%AD%97%E4%B8%BA%EF%BC%9AMyComTest-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%B0%E5%B7%A5%E7%A8%8B%EF%BC%9A%E6%88%91%E5%8F%96%E5%90%8D%E5%AD%97%E4%B8%BA%EF%BC%9AMyComTest" rel="nofollow">1、创建新工程：我取名字为：MyComTest</a></p> 
<p id="1%E3%80%81SerialPort.h-toc" style="margin-left:40px;"><a href="#1%E3%80%81SerialPort.h" rel="nofollow">1、SerialPort.h</a></p> 
<p id="1%E3%80%81SerialPort.cpp-toc" style="margin-left:40px;"><a href="#1%E3%80%81SerialPort.cpp" rel="nofollow">1、SerialPort.cpp</a></p> 
<p id="1%E3%80%81%E5%B0%86SerialPort.h%E5%92%8CSerialPort.cpp%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%B0%86SerialPort.h%E5%92%8CSerialPort.cpp%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD" rel="nofollow">1、将SerialPort.h和SerialPort.cpp文件复制到项目中</a></p> 
<p id="1%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%8E%B0%E6%9C%89%E9%A1%B9%EF%BC%9ASerialPort.h-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%8E%B0%E6%9C%89%E9%A1%B9%EF%BC%9ASerialPort.h" rel="nofollow">1、头文件添加现有项：SerialPort.h</a></p> 
<p id="1%E3%80%81%E6%BA%90%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%8E%B0%E6%9C%89%E9%A1%B9%EF%BC%9ASerialPort.cpp-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%BA%90%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%8E%B0%E6%9C%89%E9%A1%B9%EF%BC%9ASerialPort.cpp" rel="nofollow">1、源文件添加现有项：SerialPort.cpp</a></p> 
<p id="1%E3%80%81MyComTestDlg.h%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%B2%E5%8F%A3SerialPort%E7%B1%BB%EF%BC%9A%E8%AE%B0%E5%BE%97%E5%A4%B4%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1%E3%80%81MyComTestDlg.h%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%B2%E5%8F%A3SerialPort%E7%B1%BB%EF%BC%9A%E8%AE%B0%E5%BE%97%E5%A4%B4%E6%96%87%E4%BB%B6" rel="nofollow">1、MyComTestDlg.h：创建串口SerialPort类：记得头文件</a></p> 
<p id="1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BC%96%E8%BE%91%E6%A1%86%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%A4%96%E9%9D%A2%E5%8F%91%E9%80%81%E6%9D%A5%E7%9A%84%E4%B8%B2%E5%8F%A3%E4%BF%A1%E6%81%AF%EF%BC%9A%E5%90%8D%E5%AD%97%E5%8F%AB%E5%81%9A%EF%BC%9AIDC_EDIT1-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BC%96%E8%BE%91%E6%A1%86%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%A4%96%E9%9D%A2%E5%8F%91%E9%80%81%E6%9D%A5%E7%9A%84%E4%B8%B2%E5%8F%A3%E4%BF%A1%E6%81%AF%EF%BC%9A%E5%90%8D%E5%AD%97%E5%8F%AB%E5%81%9A%EF%BC%9AIDC_EDIT1" rel="nofollow">1、创建编辑框：显示外面发送来的串口信息：名字叫做：IDC_EDIT1</a></p> 
<p id="1%E3%80%81%E6%B7%BB%E5%8A%A0MFC%E7%9B%B8%E5%BA%94%E6%B6%88%E6%81%AF%E4%BA%8B%E4%BB%B6%EF%BC%9A%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E5%BE%97%E5%88%B0%E5%A4%96%E9%9D%A2%E7%9A%84%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%B7%BB%E5%8A%A0MFC%E7%9B%B8%E5%BA%94%E6%B6%88%E6%81%AF%E4%BA%8B%E4%BB%B6%EF%BC%9A%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E5%BE%97%E5%88%B0%E5%A4%96%E9%9D%A2%E7%9A%84%E4%BF%A1%E6%81%AF" rel="nofollow">1、添加MFC相应消息事件：为了方便得到外面的信息：（因为我没有找到类向导之类直接导入这个事件的方法，直接填写代码也可以实现同样的功能）</a></p> 
<p id="1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%B2%E5%8F%A3%E7%B1%BB%EF%BC%9AMyComTestDlg.cpp%EF%BC%9AOnInitDialog%EF%BC%88%EF%BC%89%E4%B8%AD-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%B2%E5%8F%A3%E7%B1%BB%EF%BC%9AMyComTestDlg.cpp%EF%BC%9AOnInitDialog%EF%BC%88%EF%BC%89%E4%B8%AD" rel="nofollow">1、初始化：串口类：MyComTestDlg.cpp：OnInitDialog（）中</a></p> 
<p id="1%E3%80%81%E6%B3%A8%E9%94%80%E5%92%8C%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%B3%A8%E9%94%80%E5%92%8C%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3%EF%BC%9A" rel="nofollow">1、注销和关闭串口：</a></p> 
<p id="-toc" style="margin-left:40px;"> </p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81%E7%9B%AE%E7%9A%84">一、目的</h2> 
<h3 id="1%E3%80%81%E6%83%B3%E7%9F%A5%E9%81%93%EF%BC%9AMFC%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF">1、想知道：MFC串口输入输出信息</h3> 
<p> </p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%8F%82%E8%80%83">二、参考</h2> 
<h3 id="1%E3%80%81%E6%97%A0">1、无</h3> 
<p> </p> 
<h2 id="%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%9A">三、问题：</h2> 
<h3 id="1%E3%80%81%E5%BD%93%E6%9C%89%E6%8F%90%E7%A4%BA%E8%AF%B4%E6%98%8E%EF%BC%9AOnComm%E4%B8%8D%E5%87%86%E7%A1%AE%E6%97%B6%E5%80%99%EF%BC%8C">1、当有提示说明：OnComm不准确时候，</h3> 
<p><img alt="" height="18" src="https://images2.imgbox.com/fb/ab/SSQJPCiR_o.png" width="1030"></p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/c8/32/WPdMntqV_o.png" width="815"><img alt="" height="185" src="https://images2.imgbox.com/9d/1a/4C5XBaq6_o.png" width="563"></p> 
<p>答：</p> 
<h4 id="%E2%91%A0%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ALONG%E6%94%B9%E4%B8%BALRESULT">①方法一：LONG改为LRESULT</h4> 
<p><img alt="" height="155" src="https://images2.imgbox.com/15/e0/2CUGkLZv_o.png" width="771"></p> 
<pre><code>afx_msg LRESULT OnComm(WPARAM ch,LPARAM port);//为了有消息给MFC发送后，MFC有变化</code></pre> 
<p><img alt="" height="182" src="https://images2.imgbox.com/2e/11/2OrZjbN5_o.png" width="566"></p> 
<pre><code>LRESULT CFlashAndVideoDlg::OnComm(WPARAM ch,LPARAM port)</code></pre> 
<p> </p> 
<h2 id="%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C">四、操作</h2> 
<h3 id="1%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A%E5%AE%8C%E6%88%90MFC%E8%8E%B7%E5%8F%96%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%85%A5%E4%BF%A1%E6%81%AF%E5%8A%9F%E8%83%BD">1、运行效果：完成MFC获取串口输入信息功能</h3> 
<p>①我发送了7位的串口信号，它只会读取我设置额度前6个信号。</p> 
<p><img alt="" height="560" src="https://images2.imgbox.com/92/cf/ESztOeHt_o.png" width="1003"><img alt="" height="566" src="https://images2.imgbox.com/ce/57/PlrD8APA_o.png" width="1058"></p> 
<p> </p> 
<h3 id="1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%B0%E5%B7%A5%E7%A8%8B%EF%BC%9A%E6%88%91%E5%8F%96%E5%90%8D%E5%AD%97%E4%B8%BA%EF%BC%9AMyComTest">1、创建新工程：我取名字为：MyComTest</h3> 
<p><img alt="" height="660" src="https://images2.imgbox.com/78/2a/Odr8sRtV_o.png" width="955"><img alt="" height="521" src="https://images2.imgbox.com/b5/58/Wa5p4DVU_o.png" width="615"><img alt="" height="521" src="https://images2.imgbox.com/8d/9e/29xvMUIm_o.png" width="615"></p> 
<p> </p> 
<h3 id="1%E3%80%81SerialPort.h">1、SerialPort.h</h3> 
<pre><code>#pragma once

#define WM_COMM_BREAK_DETECTED   WM_USER+1 // A break was detected on input.
#define WM_COMM_CTS_DETECTED     WM_USER+2 // The CTS (clear-to-send) signal changed state. 
#define WM_COMM_DSR_DETECTED     WM_USER+3 // The DSR (data-set-ready) signal changed state. 
#define WM_COMM_ERR_DETECTED     WM_USER+4 // A line-status error occurred. Line-status errors are CE_FRAME, CE_OVERRUN, and CE_RXPARITY. 
#define WM_COMM_RING_DETECTED    WM_USER+5 // A ring indicator was detected. 
#define WM_COMM_RLSD_DETECTED    WM_USER+6 // The RLSD (receive-line-signal-detect) signal changed state. 
#define WM_COMM_RXCHAR           WM_USER+7 // A character was received and placed in the input buffer. 
#define WM_COMM_RXFLAG_DETECTED  WM_USER+8 // The event character was received and placed in the input buffer.  
#define WM_COMM_TXEMPTY_DETECTED WM_USER+9 // The last character in the output buffer was sent. 
class CSerialCom
{
public:
	int m_nWriteSize;
	void ClosePort();
	// contruction and destruction
	CSerialCom();
	virtual  ~CSerialCom();
	// port initialisation           
	BOOL  InitPort(CWnd* pPortOwner, UINT portnr = 1, UINT baud = 9600, char parity = 'N', UINT databits = 8, UINT stopbits = 1, DWORD dwCommEvents = EV_RXCHAR, UINT writebuffersize = 1024);
	HANDLE    m_hComm;
	// start/stop comm watching
	BOOL  StartMonitoring();
	BOOL  RestartMonitoring();
	BOOL  StopMonitoring();
	DWORD  GetWriteBufferSize();
	DWORD  GetCommEvents();
	DCB   GetDCB();
	void  WriteToPort(char* string);
	void  WriteToPort(char* string, int n);
	void  WriteToPort(LPCTSTR string);
	void  WriteToPort(LPCTSTR string, int n);
	void EnumerateSerialPorts(CUIntArray&amp; ports);
protected:
	// protected memberfunctions
	void  ProcessErrorMessage(char* ErrorText);
	static UINT CommThread(LPVOID pParam);
	static void ReceiveChar(CSerialCom* port, COMSTAT comstat);
	static void WriteChar(CSerialCom* port);
	// thread
	CWinThread*   m_Thread;
	// synchronisation objects
	CRITICAL_SECTION m_csCommunicationSync;
	BOOL    m_bThreadAlive;
	// handles
	HANDLE    m_hWriteEvent;
	HANDLE    m_hShutdownEvent;
	// Event array. 
	// One element is used for each event. There are two event handles for each port.
	// A Write event and a receive character event which is located in the overlapped structure (m_ov.hEvent).
	// There is a general shutdown when the port is closed. 
	HANDLE    m_hEventArray[3];
	// structures
	OVERLAPPED   m_ov;
	COMMTIMEOUTS  m_CommTimeouts;
	DCB     m_dcb;
	// owner window
	CWnd*    m_pOwner;
	// misc
	UINT    m_nPortNr;
	char*    m_szWriteBuffer;
	DWORD    m_dwCommEvents;
	DWORD    m_nWriteBufferSize;    
};</code></pre> 
<p> </p> 
<h3 id="1%E3%80%81SerialPort.cpp">1、SerialPort.cpp</h3> 
<pre><code>#include "stdafx.h"

#include "SerialPort.h"
#include &lt;assert.h&gt;
//
// Constructor
//
#pragma warning(disable:4996)
CSerialCom::CSerialCom()
{
    m_hComm = NULL;
    // initialize overlapped structure members to zero
    m_ov.Offset = 0;
    m_ov.OffsetHigh = 0;
    // create events
    m_ov.hEvent = NULL;
    m_hWriteEvent = NULL;
    m_hShutdownEvent = NULL;
    m_szWriteBuffer = NULL;
    m_nWriteSize = 1;
    m_bThreadAlive = FALSE;
}
//
// Delete dynamic memory
//
CSerialCom::~CSerialCom()
{
    do
    {
        SetEvent(m_hShutdownEvent);
    } while (m_bThreadAlive);

    TRACE("Thread ended/n");
    delete[] m_szWriteBuffer;
}
//
// Initialize the port. This can be port 1 to 4.
//
BOOL CSerialCom::InitPort(CWnd* pPortOwner, // the owner (CWnd) of the port (receives message)
    UINT  portnr,  // portnumber (1..8)
    UINT  baud,   // baudrate
    char  parity,  // parity 
    UINT  databits,  // databits 
    UINT  stopbits,  // stopbits 
    DWORD dwCommEvents, // EV_RXCHAR, EV_CTS etc
    UINT  writebuffersize) // size to the writebuffer
{
    assert(portnr &gt; 0 &amp;&amp; portnr &lt; 20);
    assert(pPortOwner != NULL);
    // if the thread is alive: Kill
    if (m_bThreadAlive)
    {
        do
        {
            SetEvent(m_hShutdownEvent);
        } while (m_bThreadAlive);
        TRACE("Thread ended/n");
    }
    // create events
    if (m_ov.hEvent != NULL)
        ResetEvent(m_ov.hEvent);
    m_ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hWriteEvent != NULL)
        ResetEvent(m_hWriteEvent);
    m_hWriteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (m_hShutdownEvent != NULL)
        ResetEvent(m_hShutdownEvent);
    m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    // initialize the event objects
    m_hEventArray[0] = m_hShutdownEvent; // highest priority
    m_hEventArray[1] = m_hWriteEvent;
    m_hEventArray[2] = m_ov.hEvent;
    // initialize critical section
    InitializeCriticalSection(&amp;m_csCommunicationSync);

    // set buffersize for writing and save the owner
    m_pOwner = pPortOwner;
    if (m_szWriteBuffer != NULL)
        delete[] m_szWriteBuffer;
    m_szWriteBuffer = new char[writebuffersize];
    m_nPortNr = portnr;
    m_nWriteBufferSize = writebuffersize;
    m_dwCommEvents = dwCommEvents;
    BOOL bResult = FALSE;
    char *szPort = new char[50];
    char *szBaud = new char[50];
    // now it critical!
    EnterCriticalSection(&amp;m_csCommunicationSync);
    // if the port is already opened: close it
    if (m_hComm != NULL)
    {
        CloseHandle(m_hComm);
        m_hComm = NULL;
    }
    // prepare port strings
    sprintf(szPort, "COM%d", portnr);
    sprintf(szBaud, "baud=%d parity=%c data=%d stop=%d", baud, parity, databits, stopbits);
    // get a handle to the port
    m_hComm = CreateFileA(szPort,      // communication port string (COMX)
        GENERIC_READ | GENERIC_WRITE, // read/write types
        0,        // comm devices must be opened with exclusive access
        NULL,       // no security attributes
        OPEN_EXISTING,     // comm devices must use OPEN_EXISTING
        FILE_FLAG_OVERLAPPED,   // Async I/O
        0);       // template must be 0 for comm devices
    if (m_hComm == INVALID_HANDLE_VALUE)
    {
        // port not found
        delete[] szPort;
        delete[] szBaud;
        return FALSE;
    }
    // set the timeout values
    m_CommTimeouts.ReadIntervalTimeout = 1000;
    m_CommTimeouts.ReadTotalTimeoutMultiplier = 1000;
    m_CommTimeouts.ReadTotalTimeoutConstant = 1000;
    m_CommTimeouts.WriteTotalTimeoutMultiplier = 1000;
    m_CommTimeouts.WriteTotalTimeoutConstant = 1000;
    // configure
    if (SetCommTimeouts(m_hComm, &amp;m_CommTimeouts))
    {
        if (SetCommMask(m_hComm, dwCommEvents))
        {
            if (GetCommState(m_hComm, &amp;m_dcb))
            {
                m_dcb.EvtChar = 'q';
                m_dcb.fRtsControl = RTS_CONTROL_ENABLE;  // set RTS bit high!
                if (BuildCommDCBA(szBaud, &amp;m_dcb))
                {
                    if (SetCommState(m_hComm, &amp;m_dcb))
                        ; // normal operation... continue
                    else
                        ProcessErrorMessage("SetCommState()");
                }
                else
                    ProcessErrorMessage("BuildCommDCB()");
            }
            else
                ProcessErrorMessage("GetCommState()");
        }
        else
            ProcessErrorMessage("SetCommMask()");
    }
    else
        ProcessErrorMessage("SetCommTimeouts()");
    delete[] szPort;
    delete[] szBaud;
    // flush the port
    PurgeComm(m_hComm, PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT);
    // release critical section
    LeaveCriticalSection(&amp;m_csCommunicationSync);
    TRACE("Initialisation for communicationport %d completed./nUse Startmonitor to communicate./n", portnr);
    return TRUE;
}
//
//  The CommThread Function.
//
UINT CSerialCom::CommThread(LPVOID pParam)
{
    // Cast the void pointer passed to the thread back to
    // a pointer of CSerialCom class
    CSerialCom *port = (CSerialCom*)pParam;

    // Set the status variable in the dialog class to
    // TRUE to indicate the thread is running.
    port-&gt;m_bThreadAlive = TRUE;

    // Misc. variables
    DWORD BytesTransfered = 0;
    DWORD Event = 0;
    DWORD CommEvent = 0;
    DWORD dwError = 0;
    COMSTAT comstat;
    memset(&amp;comstat, 0, sizeof(COMSTAT));
    BOOL  bResult = TRUE;

    // Clear comm buffers at startup
    if (port-&gt;m_hComm)  // check if the port is opened
        PurgeComm(port-&gt;m_hComm, PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT);
    // begin forever loop.  This loop will run as long as the thread is alive.
    for (;;)
    {
        // Make a call to WaitCommEvent().  This call will return immediatly
        // because our port was created as an async port (FILE_FLAG_OVERLAPPED
        // and an m_OverlappedStructerlapped structure specified).  This call will cause the 
        // m_OverlappedStructerlapped element m_OverlappedStruct.hEvent, which is part of the m_hEventArray to 
        // be placed in a non-signeled state if there are no bytes available to be read,
        // or to a signeled state if there are bytes available.  If this event handle 
        // is set to the non-signeled state, it will be set to signeled when a 
        // character arrives at the port.
        // we do this for each port!
        bResult = WaitCommEvent(port-&gt;m_hComm, &amp;Event, &amp;port-&gt;m_ov);
        if (!bResult)
        {
            // If WaitCommEvent() returns FALSE, process the last error to determin
            // the reason..
            switch (dwError = GetLastError())
            {
            case ERROR_IO_PENDING:
            {
                // This is a normal return value if there are no bytes
                // to read at the port.
                // Do nothing and continue
                break;
            }
            case 87:
            {
                // Under Windows NT, this value is returned for some reason.
                // I have not investigated why, but it is also a valid reply
                // Also do nothing and continue.
                break;
            }
            default:
            {
                // All other error codes indicate a serious error has
                // occured.  Process this error.
                port-&gt;ProcessErrorMessage("WaitCommEvent()");
                break;
            }
            }
        }
        else
        {    /*
            // If WaitCommEvent() returns TRUE, check to be sure there are
            // actually bytes in the buffer to read.  
            //
            // If you are reading more than one byte at a time from the buffer 
            // (which this program does not do) you will have the situation occur 
            // where the first byte to arrive will cause the WaitForMultipleObjects() 
            // function to stop waiting.  The WaitForMultipleObjects() function 
            // resets the event handle in m_OverlappedStruct.hEvent to the non-signelead state
            // as it returns.  
            //
            // If in the time between the reset of this event and the call to 
            // ReadFile() more bytes arrive, the m_OverlappedStruct.hEvent handle will be set again
            // to the signeled state. When the call to ReadFile() occurs, it will 
            // read all of the bytes from the buffer, and the program will
            // loop back around to WaitCommEvent().
            // 
            // At this point you will be in the situation where m_OverlappedStruct.hEvent is set,
            // but there are no bytes available to read.  If you proceed and call
            // ReadFile(), it will return immediatly due to the async port setup, but
            // GetOverlappedResults() will not return until the next character arrives.
            //
            // It is not desirable for the GetOverlappedResults() function to be in 
            // this state.  The thread shutdown event (event 0) and the WriteFile()
            // event (Event2) will not work if the thread is blocked by GetOverlappedResults().
            //
            // The solution to this is to check the buffer with a call to ClearCommError().
            // This call will reset the event handle, and if there are no bytes to read
            // we can loop back through WaitCommEvent() again, then proceed.
            // If there are really bytes to read, do nothing and proceed.
            */
            bResult = ClearCommError(port-&gt;m_hComm, &amp;dwError, &amp;comstat);
            if (comstat.cbInQue == 0)
                continue;
        } // end if bResult
          // Main wait function.  This function will normally block the thread
          // until one of nine events occur that require action.
        Event = WaitForMultipleObjects(3, port-&gt;m_hEventArray, FALSE, INFINITE);
        switch (Event)
        {
        case 0:
        {
            // Shutdown event.  This is event zero so it will be
            // the higest priority and be serviced first.
            CloseHandle(port-&gt;m_hComm);
            port-&gt;m_hComm = NULL;
            port-&gt;m_bThreadAlive = FALSE;

            // Kill this thread.  break is not needed, but makes me feel better.
            AfxEndThread(100);
            break;
        }
        case 2: // read event
        {
            GetCommMask(port-&gt;m_hComm, &amp;CommEvent);
            if (CommEvent &amp; EV_RXCHAR)
                // Receive character event from port.
                ReceiveChar(port, comstat);
            if (CommEvent &amp; EV_CTS)
                ::SendMessage(port-&gt;m_pOwner-&gt;m_hWnd, WM_COMM_CTS_DETECTED, (WPARAM)0, (LPARAM)port-&gt;m_nPortNr);
            if (CommEvent &amp; EV_BREAK)
                ::SendMessage(port-&gt;m_pOwner-&gt;m_hWnd, WM_COMM_BREAK_DETECTED, (WPARAM)0, (LPARAM)port-&gt;m_nPortNr);
            if (CommEvent &amp; EV_ERR)
                ::SendMessage(port-&gt;m_pOwner-&gt;m_hWnd, WM_COMM_ERR_DETECTED, (WPARAM)0, (LPARAM)port-&gt;m_nPortNr);
            if (CommEvent &amp; EV_RING)
                ::SendMessage(port-&gt;m_pOwner-&gt;m_hWnd, WM_COMM_RING_DETECTED, (WPARAM)0, (LPARAM)port-&gt;m_nPortNr);

            if (CommEvent &amp; EV_RXFLAG)
                ::SendMessage(port-&gt;m_pOwner-&gt;m_hWnd, WM_COMM_RXFLAG_DETECTED, (WPARAM)0, (LPARAM)port-&gt;m_nPortNr);

            break;
        }
        case 1: // write event
        {
            // Write character event from port
            WriteChar(port);
            break;
        }
        } // end switch
    } // close forever loop
    return 0;
}
//
// start comm watching
//
BOOL CSerialCom::StartMonitoring()
{
    if (!(m_Thread = AfxBeginThread(CommThread, this)))
        return FALSE;
    TRACE("Thread started/n");
    return TRUE;
}
//
// Restart the comm thread
//
BOOL CSerialCom::RestartMonitoring()
{
    TRACE("Thread resumed/n");
    m_Thread-&gt;ResumeThread();
    return TRUE;
}

//
// Suspend the comm thread
//
BOOL CSerialCom::StopMonitoring()
{
    TRACE("Thread suspended/n");
    m_Thread-&gt;SuspendThread();
    return TRUE;
}

//
// If there is a error, give the right message
//
void CSerialCom::ProcessErrorMessage(char* ErrorText)
{
    char *Temp = new char[200];

    LPVOID lpMsgBuf;
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR)&amp;lpMsgBuf,
        0,
        NULL
        );
    sprintf(Temp, "WARNING:  %s Failed with the following error: /n%s/nPort: %d/n", ErrorText, (char*)lpMsgBuf, m_nPortNr);
    MessageBoxA(NULL, Temp, "Application Error", MB_ICONSTOP);
    LocalFree(lpMsgBuf);
    delete[] Temp;
}
//
// Write a character.
//
void CSerialCom::WriteChar(CSerialCom* port)
{
    BOOL bWrite = TRUE;
    BOOL bResult = TRUE;
    DWORD BytesSent = 0;
    ResetEvent(port-&gt;m_hWriteEvent);
    // Gain ownership of the critical section
    EnterCriticalSection(&amp;port-&gt;m_csCommunicationSync);
    if (bWrite)
    {
        // Initailize variables
        port-&gt;m_ov.Offset = 0;
        port-&gt;m_ov.OffsetHigh = 0;
        // Clear buffer
        PurgeComm(port-&gt;m_hComm, PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT);
        bResult = WriteFile(port-&gt;m_hComm,       // Handle to COMM Port
            port-&gt;m_szWriteBuffer,     // Pointer to message buffer in calling finction
                                       //       strlen((char*)port-&gt;m_szWriteBuffer), // Length of message to send
            port-&gt;m_nWriteSize, // Length of message to send
            &amp;BytesSent,        // Where to store the number of bytes sent
            &amp;port-&gt;m_ov);       // Overlapped structure
                                // deal with any error codes
        if (!bResult)
        {
            DWORD dwError = GetLastError();
            switch (dwError)
            {
            case ERROR_IO_PENDING:
            {
                // continue to GetOverlappedResults()
                BytesSent = 0;
                bWrite = FALSE;
                break;
            }
            default:
            {
                // all other error codes
                port-&gt;ProcessErrorMessage("WriteFile()");
            }
            }
        }
        else
        {
            LeaveCriticalSection(&amp;port-&gt;m_csCommunicationSync);
        }
    } // end if(bWrite)
    if (!bWrite)
    {
        bWrite = TRUE;

        bResult = GetOverlappedResult(port-&gt;m_hComm, // Handle to COMM port 
            &amp;port-&gt;m_ov,  // Overlapped structure
            &amp;BytesSent,  // Stores number of bytes sent
            TRUE);    // Wait flag
        LeaveCriticalSection(&amp;port-&gt;m_csCommunicationSync);
        // deal with the error code 
        //  if (!bResult)  
        {
            //   port-&gt;ProcessErrorMessage("GetOverlappedResults() in WriteFile()");
        }
    } // end if (!bWrite)
      // Verify that the data size send equals what we tried to send
      // if (BytesSent != strlen((char*)port-&gt;m_szWriteBuffer))
    {
        //  TRACE("WARNING: WriteFile() error.. Bytes Sent: %d; Message Length: %d/n", BytesSent, strlen((char*)port-&gt;m_szWriteBuffer));
    }
    // ::SendMessage((port-&gt;m_pOwner)-&gt;m_hWnd, WM_COMM_TXEMPTY_DETECTED, (WPARAM) RXBuff, (LPARAM) port-&gt;m_nPortNr);
    ::SendMessage((port-&gt;m_pOwner)-&gt;m_hWnd, WM_COMM_TXEMPTY_DETECTED, 0, (LPARAM)port-&gt;m_nPortNr);
}
//
// Character received. Inform the owner
//
void CSerialCom::ReceiveChar(CSerialCom* port, COMSTAT comstat)
{
    BOOL  bRead = TRUE;
    BOOL  bResult = TRUE;
    DWORD dwError = 0;
    DWORD BytesRead = 0;
    unsigned char RXBuff;
    for (;;)
    {
        // Gain ownership of the comm port critical section.
        // This process guarantees no other part of this program 
        // is using the port object. 

        EnterCriticalSection(&amp;port-&gt;m_csCommunicationSync);
        // ClearCommError() will update the COMSTAT structure and
        // clear any other errors.

        bResult = ClearCommError(port-&gt;m_hComm, &amp;dwError, &amp;comstat);
        LeaveCriticalSection(&amp;port-&gt;m_csCommunicationSync);
        // start forever loop.  I use this type of loop because I
        // do not know at runtime how many loops this will have to
        // run. My solution is to start a forever loop and to
        // break out of it when I have processed all of the
        // data available.  Be careful with this approach and
        // be sure your loop will exit.
        // My reasons for this are not as clear in this sample 
        // as it is in my production code, but I have found this 
        // solutiion to be the most efficient way to do this.

        if (comstat.cbInQue == 0)
        {
            // break out when all bytes have been read
            break;
        }

        EnterCriticalSection(&amp;port-&gt;m_csCommunicationSync);
        if (bRead)
        {
            bResult = ReadFile(port-&gt;m_hComm,  // Handle to COMM port 
                &amp;RXBuff,    // RX Buffer Pointer
                1,     // Read one byte
                &amp;BytesRead,   // Stores number of bytes read
                &amp;port-&gt;m_ov);  // pointer to the m_ov structure
                               // deal with the error code 
            if (!bResult)
            {
                switch (dwError = GetLastError())
                {
                case ERROR_IO_PENDING:
                {
                    // asynchronous i/o is still in progress 
                    // Proceed on to GetOverlappedResults();
                    bRead = FALSE;
                    break;
                }
                default:
                {
                    // Another error has occured.  Process this error.
                    port-&gt;ProcessErrorMessage("ReadFile()");
                    break;
                }
                }
            }
            else
            {
                // ReadFile() returned complete. It is not necessary to call GetOverlappedResults()
                bRead = TRUE;
            }
        }  // close if (bRead)
        if (!bRead)
        {
            bRead = TRUE;
            bResult = GetOverlappedResult(port-&gt;m_hComm, // Handle to COMM port 
                &amp;port-&gt;m_ov,  // Overlapped structure
                &amp;BytesRead,  // Stores number of bytes read
                TRUE);    // Wait flag
                          // deal with the error code 
            if (!bResult)
            {
                port-&gt;ProcessErrorMessage("GetOverlappedResults() in ReadFile()");
            }
        }  // close if (!bRead)

        LeaveCriticalSection(&amp;port-&gt;m_csCommunicationSync);
        // notify parent that a byte was received
        ::SendMessage((port-&gt;m_pOwner)-&gt;m_hWnd, WM_COMM_RXCHAR, (WPARAM)RXBuff, (LPARAM)port-&gt;m_nPortNr);//发送消息，对应的消息函数接收数据
    } // end forever loop
}
//
// Write a string to the port
//
void CSerialCom::WriteToPort(char* string)
{
    assert(m_hComm != 0);

    memset(m_szWriteBuffer, 0, sizeof(m_szWriteBuffer));
    strcpy(m_szWriteBuffer, string);
    m_nWriteSize = strlen(string);
    // set event for write
    SetEvent(m_hWriteEvent);
}

void CSerialCom::WriteToPort(char* string, int n)
{
    assert(m_hComm != 0);
    memset(m_szWriteBuffer, 0, sizeof(m_szWriteBuffer));
    // memset(m_szWriteBuffer, 0, n);
    // strncpy(m_szWriteBuffer, string, n);
    memcpy(m_szWriteBuffer, string, n);
    m_nWriteSize = n;
    // set event for write
    SetEvent(m_hWriteEvent);
}


#if 0
void CSerialCom::WriteToPort(LPCTSTR string)
{
    assert(m_hComm != 0);
    memset(m_szWriteBuffer, 0, sizeof(m_szWriteBuffer));
    strcpy(m_szWriteBuffer, string);
    m_nWriteSize = strlen(string);
    // set event for write
    SetEvent(m_hWriteEvent);
}
#endif
void CSerialCom::WriteToPort(LPCTSTR string, int n)
{
    assert(m_hComm != 0);
    memset(m_szWriteBuffer, 0, sizeof(m_szWriteBuffer));
    // strncpy(m_szWriteBuffer, string, n);
    memcpy(m_szWriteBuffer, string, n);
    m_nWriteSize = n;
    // set event for write
    SetEvent(m_hWriteEvent);
}
//
// Return the device control block
//
DCB CSerialCom::GetDCB()
{
    return m_dcb;
}
//
// Return the communication event masks
//
DWORD CSerialCom::GetCommEvents()
{
    return m_dwCommEvents;
}
//
// Return the output buffer size
//
DWORD CSerialCom::GetWriteBufferSize()
{
    return m_nWriteBufferSize;
}

void CSerialCom::ClosePort()
{
    SetEvent(m_hShutdownEvent);
}

void CSerialCom::EnumerateSerialPorts(CUIntArray&amp; ports)
{
    ports.RemoveAll();    //Make sure we clear out any elements which may already be in the array

                        //Determine what OS we are running on
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL bGetVer = GetVersionEx(&amp;osvi);

    //On NT use the QueryDosDevice API
    if (bGetVer &amp;&amp; (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT))
    {
        //Use QueryDosDevice to look for all devices of the form COMx. This is a better
        //solution as it means that no ports have to be opened at all.
        TCHAR szDevices[65535];
        DWORD dwChars = QueryDosDevice(NULL, szDevices, 65535);
        if (dwChars) {
            int i = 0;
            for (;;) {
                TCHAR* pszCurrentDevice = &amp;szDevices[i];    //Add the port number to the array which will be returned
                                                            //If it looks like "COMX" then
                                                            //add it to the array which will be returned
                int nLen = _tcslen(pszCurrentDevice);
                if (nLen &gt; 3 &amp;&amp; _tcsnicmp(pszCurrentDevice, _T("COM"), 3) == 0) {
                    int nPort = _ttoi(&amp;pszCurrentDevice[3]);    //Work out the port number
                    ports.Add(nPort);        //clear out com_0
                }
                // Go to next NULL character
                while (szDevices[i] != _T('\0')) i++;
                i++;    // Bump pointer to the next string
                        // The list is double-NULL terminated, so if the character is
                        // now NULL, we're at the end
                if (szDevices[i] == _T('\0')) break;
            }
        }
        else TRACE(_T("Failed in call to QueryDosDevice, GetLastError:%d\n"), GetLastError());
    }
    else {
        //On 95/98 open up each port to determine their existence
        //Up to 255 COM ports are supported so we iterate through all of them seeing
        //if we can open them or if we fail to open them, get an access denied or general error error.
        //Both of these cases indicate that there is a COM port at that number. 
        for (UINT i = 1; i&lt;256; i++)
        {
            //Form the Raw device name
            CString sPort;
            sPort.Format(_T("\\\\.\\COM%d"), i);

            //Try to open the port
            BOOL bSuccess = FALSE;
            HANDLE hPort = ::CreateFile(sPort, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
            if (hPort == INVALID_HANDLE_VALUE)
            {
                DWORD dwError = GetLastError();
                //Check to see if the error was because some other app had the port open or a general failure
                if (dwError == ERROR_ACCESS_DENIED || dwError == ERROR_GEN_FAILURE)
                    bSuccess = TRUE;
            }
            else {
                bSuccess = TRUE;    //The port was opened successfully                
                CloseHandle(hPort);    //Don't forget to close the port, since we are going to do nothing with it anyway
            }
            if (bSuccess) ports.Add(i);    //Add the port number to the array which will be returned
        }
    }
}</code></pre> 
<p> </p> 
<h3 id="1%E3%80%81%E5%B0%86SerialPort.h%E5%92%8CSerialPort.cpp%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD">1、将SerialPort.h和SerialPort.cpp文件复制到项目中</h3> 
<p><img alt="" height="444" src="https://images2.imgbox.com/0e/bd/l9Q1xlZA_o.png" width="606"></p> 
<p> </p> 
<h3 id="1%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%8E%B0%E6%9C%89%E9%A1%B9%EF%BC%9ASerialPort.h">1、头文件添加现有项：SerialPort.h</h3> 
<p><img alt="" height="473" src="https://images2.imgbox.com/be/99/VBsscShv_o.png" width="672"></p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/71/7a/lQv2owUf_o.png" width="840"></p> 
<p> </p> 
<h3 id="1%E3%80%81%E6%BA%90%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%8E%B0%E6%9C%89%E9%A1%B9%EF%BC%9ASerialPort.cpp">1、源文件添加现有项：SerialPort.cpp</h3> 
<p><img alt="" height="525" src="https://images2.imgbox.com/a7/4b/erv58neB_o.png" width="840"></p> 
<p> </p> 
<h3 id="1%E3%80%81MyComTestDlg.h%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%B2%E5%8F%A3SerialPort%E7%B1%BB%EF%BC%9A%E8%AE%B0%E5%BE%97%E5%A4%B4%E6%96%87%E4%BB%B6">1、MyComTestDlg.h：创建串口SerialPort类：记得头文件</h3> 
<p><img alt="" height="297" src="https://images2.imgbox.com/f6/a2/85Cx6ooV_o.png" width="531"></p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/e3/fc/Nc6h79DM_o.png" width="681"></p> 
<pre><code class="language-cpp">#include &lt;string&gt;

#include "SerialPort.h"</code></pre> 
<pre><code>public:
	CSerialCom m_SerialPort;//串口接收端口号
	BOOL m_bSerialPortOpened;//串口接收端：是否打开

	CSerialCom m_SerialPortsend;//串口发送端端口号
	BOOL m_bSerialPortOpenedsend;//串口发送端：是否打开

	int comMessageLength;//串口信号长度

	std::string str;//串口输入的信息

	//void ReadConfig();//读取配置文件
	int comPortReceive,comPortSend;//端口号</code></pre> 
<p> </p> 
<h3 id="1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BC%96%E8%BE%91%E6%A1%86%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%A4%96%E9%9D%A2%E5%8F%91%E9%80%81%E6%9D%A5%E7%9A%84%E4%B8%B2%E5%8F%A3%E4%BF%A1%E6%81%AF%EF%BC%9A%E5%90%8D%E5%AD%97%E5%8F%AB%E5%81%9A%EF%BC%9AIDC_EDIT1">1、创建编辑框：显示外面发送来的串口信息：名字叫做：IDC_EDIT1</h3> 
<p><img alt="" height="752" src="https://images2.imgbox.com/e8/fa/rMiZs3ig_o.png" width="1200"></p> 
<p> </p> 
<h3 id="1%E3%80%81%E6%B7%BB%E5%8A%A0MFC%E7%9B%B8%E5%BA%94%E6%B6%88%E6%81%AF%E4%BA%8B%E4%BB%B6%EF%BC%9A%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E5%BE%97%E5%88%B0%E5%A4%96%E9%9D%A2%E7%9A%84%E4%BF%A1%E6%81%AF">1、添加MFC相应消息事件：为了方便得到外面的信息：（因为我没有找到类向导之类直接导入这个事件的方法，直接填写代码也可以实现同样的功能）</h3> 
<p>①注意：如果报错</p> 
<p><img alt="" height="24" src="https://images2.imgbox.com/6a/c0/2j3jXU99_o.png" width="1058"></p> 
<p>则：将LONG改为LRESULT</p> 
<p>①头文件中：</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/52/a2/jJAWKFaX_o.png" width="738"></p> 
<pre><code>	afx_msg LONG OnComm(WPARAM ch,LPARAM port);//自己手动添加的一个消息处理函数：为了有消息给MFC发送后，MFC有变化
//afx_msg LRESULT OnComm(WPARAM ch,LPARAM port);//LONG报错就使用LRESULT，自己手动添加的一个消息处理函数，为了有消息给MFC发送后，MFC有变化</code></pre> 
<p>②源文件中：</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/93/8a/sFaXcXxl_o.png" width="508"></p> 
<pre><code>ON_MESSAGE(WM_COMM_RXCHAR,OnComm)</code></pre> 
<p> </p> 
<p><img alt="" height="681" src="https://images2.imgbox.com/0e/03/pbdEexJ3_o.png" width="585"></p> 
<pre><code>//使用配置文件中的：自定义输入串口信息长度
//LRESULT CFlashAndVideoDlg::OnComm(WPARAM ch,LPARAM port)//LONG报错就使用LRESULT，自己手动添加的一个消息处理函数，为了有消息给MFC发送后，MFC有变化
LONG CFlashAndVideoDlg::OnComm(WPARAM ch,LPARAM port)
{
	int length=comMessageLength;

	str += ch;
	if (str.length()&gt;=length)
	{
		int index= str.length() - length;
		if (str[index] == 0x55 &amp;&amp; str[index+1] == ( char )0xaa )
		{
			std::string pp = str.substr(index, length);
			m_SerialPortsend.WriteToPort((char *)pp.c_str(),length);
			char * tempstr = const_cast&lt;char*&gt;(pp.c_str());
			std::string showstr;
			for (unsigned int i = 0; i&lt;length;i++)
			{
				char  buf[10] = {0};
				unsigned char tempchar = tempstr[i];
				sprintf_s(buf, 10,"%02x ",tempchar);
				showstr += buf;
				showstr += " ";
			}
			SetDlgItemText(IDC_EDIT1, (CString)showstr.c_str());
			str.clear();
		}
	}
	return 0;
}
</code></pre> 
<p> </p> 
<p> </p> 
<h3 id="1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%B2%E5%8F%A3%E7%B1%BB%EF%BC%9AMyComTestDlg.cpp%EF%BC%9AOnInitDialog%EF%BC%88%EF%BC%89%E4%B8%AD">1、初始化：串口类：MyComTestDlg.cpp：OnInitDialog（）中</h3> 
<p><img alt="" height="718" src="https://images2.imgbox.com/aa/6f/o5jxor3o_o.png" width="701"></p> 
<pre><code>comPortReceive=3;
	comPortSend=4;
	comMessageLength=6;
	if(m_SerialPort.InitPort(this,comPortReceive,19200,'N',8,1,EV_RXFLAG|EV_RXCHAR,512))
	{
		m_SerialPort.StartMonitoring();
		m_bSerialPortOpened=TRUE;
	}
	else
	{
		AfxMessageBox(L"没有发现接收串口或被占用!");
		m_bSerialPortOpened=FALSE;
		exit(-1);
	}

	if(m_SerialPortsend.InitPort(this,comPortSend,19200,'N',8,1,EV_RXFLAG|EV_RXCHAR,512))
	{
		m_SerialPortsend.StartMonitoring();
		m_bSerialPortOpenedsend=TRUE;
	}
	else
	{
		AfxMessageBox(L"没有发现发送串口或被占用!");
		m_bSerialPortOpenedsend=FALSE;
		exit(-1);
	}</code></pre> 
<p> </p> 
<h3 id="1%E3%80%81%E6%B3%A8%E9%94%80%E5%92%8C%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3%EF%BC%9A">1、注销和关闭串口：</h3> 
<p><img alt="" height="311" src="https://images2.imgbox.com/52/c9/AWkxMBd1_o.png" width="580"></p> 
<p> </p> 
<p><img alt="" height="773" src="https://images2.imgbox.com/81/44/0ChYaERN_o.png" width="816"></p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/3a/99/ZO93qV6c_o.png" width="738"></p> 
<pre><code>void CMyComTestDlg::OnDestroy()
{
	CDialogEx::OnDestroy();

	// TODO: 在此处添加消息处理程序代码
	m_SerialPort.ClosePort();
	m_SerialPortsend.ClosePort();
}</code></pre> 
<p> </p> 
<h3> </h3> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59cac19e051e2fa1762e8c2a23876009/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">十、hive异常记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f94a815963472dceeacaf8ac8a602e11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">十一、行转列、列转行函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>