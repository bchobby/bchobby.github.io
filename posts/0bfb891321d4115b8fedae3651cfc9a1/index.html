<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图-弗洛伊德（FloydWarshall）算法详解（含全部代码） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图-弗洛伊德（FloydWarshall）算法详解（含全部代码）" />
<meta property="og:description" content="目录
适用条件
基本操作函数
功能实现函数
测试使用图
算法讲解
初始化
迭代
弗洛伊德算法代码
全部代码
实验结果
最短路径算法比较
适用条件 图中可以有负权，但不能有负圈（圈中弧或边的权值之和小于0）
基本操作函数 InitGraph(Graph &amp;G) 初始化函数 参数：图G 作用：初始化图的顶点表，邻接矩阵等InsertNode(Graph &amp;G,VexType v) 插入点函数 参数：图G,顶点v 作用：在图G中插入顶点v,即改变顶点表InsertEdge(Graph &amp;G,VexType v,VexType w) 插入弧函数 参数：图G,某弧两端点v和w 作用：在图G两点v,w之间加入弧，即改变邻接矩阵Adjancent(Graph G,VexType v,VexType w) 判断是否存在弧(v,w)函数 参数：图G，某弧两端点v和w 作用：判断是否存在弧(v,w)BFS(Graph G, int start) 广度遍历函数 参数：图G,开始结点下标start 作用：宽度遍历DFS(Graph G, int start) 深度遍历函数（递归形式）参数：图G,开始结点下标start 作用：深度遍历Dijkstra(Graph G, int v) 最短路径 - Dijkstra算法 参数：图G、源点vBellman_Ford(Graph G, int v) 最短路径 - Bellman_Ford算法 参数：图G、源点v 作用：计算不含负圈图的最短路径 返回是否有圈Floyd_Wallshall(Graph G) 最短路径 - Floyd_Wallshall算法 参数：图G 作用：计算不含负圈图的最短路径 返回是否有圈 功能实现函数 CreateGraph(Graph &amp;G) 创建图功能实现函数 参数：图G InsertNode 作用：创建图BFSTraverse(Graph G) 广度遍历功能实现函数 参数：图G 作用：宽度遍历DFSTraverse(Graph G) 深度遍历功能实现函数 参数：图G 作用：深度遍历Shortest_Dijkstra(Graph &amp;G) 调用最短路径-Dijkstra算法 参数：图G、源点vShortest_Bellman_Ford(Graph &amp;G) 调用最短路径- - Bellman_Ford算法 参数：图GShortest_Floyd_Wallshall(Graph &amp;G) 调用最短路径- - Floyd_Wallshall算法 参数：图G 测试使用图 测试使用图 算法讲解 初始化 表格行为i,列为j。D及P后小括号内的值为迭代次数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/0bfb891321d4115b8fedae3651cfc9a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-25T09:51:10+08:00" />
<meta property="article:modified_time" content="2019-10-25T09:51:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图-弗洛伊德（FloydWarshall）算法详解（含全部代码）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6" rel="nofollow">适用条件</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0" rel="nofollow">基本操作函数</a></p> 
<p id="%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0" rel="nofollow">功能实现函数</a></p> 
<p id="%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E5%9B%BE" rel="nofollow">测试使用图</a></p> 
<p id="%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3" rel="nofollow">算法讲解</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">初始化</a></p> 
<p id="%E8%BF%AD%E4%BB%A3-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3" rel="nofollow">迭代</a></p> 
<p id="%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81" rel="nofollow">弗洛伊德算法代码</a></p> 
<p id="%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81" rel="nofollow">全部代码</a></p> 
<p id="%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C" rel="nofollow">实验结果</a></p> 
<p id="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83" rel="nofollow">最短路径算法比较</a></p> 
<hr id="hr-toc"> 
<h2 id="%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6">适用条件</h2> 
<p>图中可以有负权，但不能有负圈（圈中弧或边的权值之和小于0）</p> 
<h2 id="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">基本操作函数</h2> 
<ul><li><strong><span style="color:#f33b45;">InitGraph(Graph &amp;G)             初始化函数 参数：图G 作用：初始化图的顶点表，邻接矩阵等</span></strong></li><li><strong><span style="color:#f33b45;">InsertNode(Graph &amp;G,VexType v) 插入点函数 参数：图G,顶点v 作用：在图G中插入顶点v,即改变顶点表</span></strong></li><li><strong><span style="color:#f33b45;">InsertEdge(Graph &amp;G,VexType v,VexType w) 插入弧函数 参数：图G,某弧两端点v和w 作用：在图G两点v,w之间加入弧，即改变邻接矩阵</span></strong></li><li><strong><span style="color:#f33b45;">Adjancent(Graph G,VexType v,VexType w) 判断是否存在弧(v,w)函数 参数：图G，某弧两端点v和w 作用：判断是否存在弧(v,w)</span></strong></li><li><strong><span style="color:#f33b45;">BFS(Graph G, int start) 广度遍历函数 参数：图G,开始结点下标start 作用：宽度遍历</span></strong></li><li><strong><span style="color:#f33b45;">DFS(Graph G, int start) 深度遍历函数（递归形式）参数：图G,开始结点下标start 作用：深度遍历</span></strong></li><li><strong><span style="color:#f33b45;">Dijkstra(Graph G, int v)  最短路径 - Dijkstra算法 参数：图G、源点v</span></strong></li><li><strong><span style="color:#f33b45;">Bellman_Ford(Graph G, int v)  最短路径 - Bellman_Ford算法  参数：图G、源点v 作用：计算不含负圈图的最短路径 返回是否有圈</span></strong></li><li><strong><span style="color:#f33b45;">Floyd_Wallshall(Graph G)    最短路径 - Floyd_Wallshall算法  参数：图G 作用：计算不含负圈图的最短路径 返回是否有圈</span></strong></li></ul> 
<h2 id="%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0">功能实现函数</h2> 
<ul><li><span style="color:#f33b45;"><strong>CreateGraph(Graph &amp;G) 创建图功能实现函数 参数：图G  InsertNode 作用：创建图</strong></span></li><li><span style="color:#f33b45;"><strong>BFSTraverse(Graph G)  广度遍历功能实现函数 参数：图G 作用：宽度遍历</strong></span></li><li><span style="color:#f33b45;"><strong>DFSTraverse(Graph G)  深度遍历功能实现函数 参数：图G 作用：深度遍历</strong></span></li><li><span style="color:#f33b45;"><strong>Shortest_Dijkstra(Graph &amp;G) 调用最短路径-Dijkstra算法 参数：图G、源点v</strong></span></li><li><span style="color:#f33b45;"><strong>Shortest_Bellman_Ford(Graph &amp;G) 调用最短路径- - Bellman_Ford算法  参数：图G</strong></span></li><li><span style="color:#f33b45;"><strong>Shortest_Floyd_Wallshall(Graph &amp;G) 调用最短路径- - Floyd_Wallshall算法  参数：图G</strong></span></li></ul> 
<h2 id="%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E5%9B%BE">测试使用图</h2> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/9b/3f/Wqp9TD8V_o.jpg"> 
  <figcaption>
    测试使用图 
  </figcaption> 
 </figure> 
</div> 
<h2 id="%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3">算法讲解</h2> 
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</h3> 
<p>表格行为i,列为j。D及P后小括号内的值为迭代次数。</p> 
<p>D矩阵主对角线为0，其余与邻接矩阵相同。</p> 
<p>P矩阵存<span style="color:#f33b45;">-1</span>，在输出最短路径时作为递归出口。</p> 
<h3 id="%E8%BF%AD%E4%BB%A3">迭代</h3> 
<p>D矩阵的状态转移方程：D(m)[i][j]=min{D(m-1)[i][j],D(m-1)[i][k]+D[k][j]},0&lt;&lt;k&lt;&lt;n-1,其中,m为迭代次数，n为节点个数。</p> 
<p>思路：添加一个点Vk,找到Vk的入弧Vi-&gt;Vk，再找到Vk的出弧,Vk-&gt;Vj，比较D[i][j]与D[i][k]+D[k][j]的大小。</p> 
<p>若D矩阵有更新，则对应P矩阵的值为<span style="color:#f33b45;">更新处最短路径第一条弧的终点</span>。</p> 
<p>D(1)</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>0</td><td>4</td><td>-3</td><td>∞</td></tr><tr><td>-3</td><td>0</td><td>-7</td><td>∞</td></tr><tr><td>∞</td><td>10</td><td>0</td><td>3</td></tr><tr><td>5</td><td>6</td><td>6</td><td>0</td></tr></tbody></table> 
<p>P(1)</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:635px;"><tbody><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr></tbody></table> 
<p> D(2)</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>0</td><td>4</td><td>-3</td><td>∞</td></tr><tr><td>-3</td><td>0</td><td>-7</td><td>∞</td></tr><tr><td>∞</td><td>10</td><td>0</td><td>3</td></tr><tr><td>5</td><td>6</td><td><span style="color:#f33b45;">2</span></td><td>0</td></tr></tbody></table> 
<p>加入点V0，V0的入弧有V1-&gt;V0与<span style="color:#f33b45;">V3-&gt;V0</span>，出弧有V0-&gt;V1与<span style="color:#f33b45;">V0-&gt;V2</span>。</p> 
<p>经比较D(1)[3][2]&gt;D(1)[3][0]+D(1)[0][2]，6&gt;5-3=2，所以，将6更新为2。</p> 
<p>P(2)</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:551px;"><tbody><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-1</td><td>-1</td><td><span style="color:#f33b45;">0</span></td><td>-1</td></tr></tbody></table> 
<p>P(2)[3][2]由P(1)[3][2]改为0，因为最短路径为V3-&gt;V0-&gt;V2，第一条弧的终点为V0。</p> 
<p>D(3)</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>0</td><td>4</td><td>-3</td><td>∞</td></tr><tr><td>-3</td><td>0</td><td>-7</td><td>∞</td></tr><tr><td><span style="color:#f33b45;">7</span></td><td>10</td><td>0</td><td>3</td></tr><tr><td><span style="color:#f33b45;">3</span></td><td>6</td><td><span style="color:#f33b45;">-1</span></td><td> <p>0</p> </td></tr></tbody></table> 
<p> 加入点V1，V1入弧有V0-&gt;V1，<span style="color:#f33b45;">V2-&gt;V1</span>以及<span style="color:#f33b45;">V3-&gt;V1</span>，出弧有<span style="color:#f33b45;">V1-&gt;V2</span>,<span style="color:#f33b45;">V1-&gt;V0</span>。</p> 
<p>经比较,D(2)[2][0]&gt;D(2)[2][1]+D(2)[1][0]，∞&gt;10-3=7，所以，将∞更新为7。</p> 
<p>            D(2)[3][0]&gt;D(1)[3][1]+D(2)[1][0]，5&gt;6-3=3，所以，将5更新为3。</p> 
<p>            D(2)[3][2]&gt;D(1)[3][1]+D(2)[1][2]，2&gt;6-7=-1，所以，将2更新为-1。</p> 
<p>P(3)</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:593px;"><tbody><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td><span style="color:#f33b45;">1</span></td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td><span style="color:#f33b45;">1</span></td><td>-1</td><td><span style="color:#f33b45;">1</span></td><td>-1</td></tr></tbody></table> 
<p>P(3)[2][0]改为1，因为最短路径为V2-&gt;V1-&gt;V0，第一条弧的终点为V1。</p> 
<p>P(3)[3][0]改为1，因为最短路径为V3-&gt;V1-&gt;V0，第一条弧的终点为V1。</p> 
<p>P(3)[3][2]改为1，因为最短路径为V3-&gt;V1-&gt;V2，第一条弧的终点为V1。</p> 
<p>下面的由读者根据原理及矩阵自己补充，加深印象。</p> 
<p>D(4)</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>0</td><td>4</td><td>-3</td><td><span style="color:#f33b45;">0</span></td></tr><tr><td>-3</td><td>0</td><td>-7</td><td><span style="color:#f33b45;">-4</span></td></tr><tr><td>7</td><td>10</td><td>0</td><td>3</td></tr><tr><td>3</td><td>6</td><td>-1</td><td> <p>0</p> </td></tr></tbody></table> 
<p>P(4)</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:628px;"><tbody><tr><td>-1</td><td>-1</td><td>-1</td><td><span style="color:#f33b45;">2</span></td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td><span style="color:#f33b45;">2</span></td></tr><tr><td>1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>1</td><td>-1</td><td>1</td><td>-1</td></tr></tbody></table> 
<p>D(5)</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:190px;">0</td><td style="width:216px;">4</td><td>-3</td><td>0</td></tr><tr><td style="width:190px;">-3</td><td style="width:216px;">0</td><td>-7</td><td>-4</td></tr><tr><td style="width:190px;"><span style="color:#f33b45;">6</span></td><td style="width:216px;"><span style="color:#f33b45;">9</span></td><td>0</td><td>3</td></tr><tr><td style="width:190px;">3</td><td style="width:216px;">6</td><td>-1</td><td> <p>0</p> </td></tr></tbody></table> 
<p>P(5)</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:699px;"><tbody><tr><td>-1</td><td>-1</td><td>-1</td><td>2</td></tr><tr><td>-1</td><td>-1</td><td>-1</td><td>2</td></tr><tr><td><span style="color:#f33b45;">3</span></td><td><span style="color:#f33b45;">3</span></td><td>-1</td><td>-1</td></tr><tr><td>1</td><td>-1</td><td>1</td><td>-1</td></tr></tbody></table> 
<p><span style="color:#f33b45;">注意：弗洛伊德算法的最短路径在输出时不是倒着的，我们记录的是第一条弧的终点。例如，p[2][0]=3，P[3][0]=1,P[1][0]=-1，</span></p> 
<p><span style="color:#f33b45;">则V[2]到V[0]的最短路径为2-&gt;3-&gt;1-&gt;0，值为6。也就是看P矩阵的列，这是与前面两篇最短路径算法不同的地方，需注意。</span></p> 
<h2 id="%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81">弗洛伊德算法代码</h2> 
<pre class="has"><code class="language-cpp">//最短路径 - Floyd_Wallshall算法  参数：图G 作用：计算不含负圈图的最短路径 返回是否有圈
bool Floyd_Wallshall(Graph G)
{
	//初始化
	for (int i = 0; i&lt;G.vexnum; i++)
		for (int j = 0; j &lt; G.vexnum; j++)
		{
			if (i == j)F_D[i][j] = 0;
			else F_D[i][j] = G.Edge[i][j];
			P[i][j] = -1;
		}
	//初始化结束，开始迭代
	for(int k=0;k&lt;G.vexnum;k++)
		for (int i = 0; i&lt;G.vexnum; i++)
			for (int j = 0; j&lt;G.vexnum; j++)
				if (F_D[i][j] &gt; F_D[i][k] + F_D[k][j])
				{
					F_D[i][j] = F_D[i][k] + F_D[k][j];
					P[i][j] = k;
				}
	bool flag = true;
	for (int i = 0; i &lt; G.vexnum; i++)
		for (int j = 0; j &lt; G.vexnum; j++)
			if (i==j&amp;&amp;F_D[i][j] &lt; 0)
			{
				flag = false;
				break;
			}
	return flag;
}</code></pre> 
<h2 id="%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81">全部代码</h2> 
<pre class="has"><code class="language-cpp">/*
Project: 图-最短路径-Bellman-Ford算法（可含有负权弧）
Date:    2019/10/24
Author:  Frank Yu
基本操作函数:
InitGraph(Graph &amp;G)             初始化函数 参数：图G 作用：初始化图的顶点表，邻接矩阵等
InsertNode(Graph &amp;G,VexType v) 插入点函数 参数：图G,顶点v 作用：在图G中插入顶点v,即改变顶点表
InsertEdge(Graph &amp;G,VexType v,VexType w) 插入弧函数 参数：图G,某弧两端点v和w 作用：在图G两点v,w之间加入弧，即改变邻接矩阵
Adjancent(Graph G,VexType v,VexType w) 判断是否存在弧(v,w)函数 参数：图G，某弧两端点v和w 作用：判断是否存在弧(v,w)
BFS(Graph G, int start) 广度遍历函数 参数：图G,开始结点下标start 作用：宽度遍历
DFS(Graph G, int start) 深度遍历函数（递归形式）参数：图G,开始结点下标start 作用：深度遍历
Dijkstra(Graph G, int v)  最短路径 - Dijkstra算法 参数：图G、源点v
Bellman_Ford(Graph G, int v)  最短路径 - Bellman_Ford算法  参数：图G、源点v 作用：计算不含负圈图的最短路径 返回是否有圈
Floyd_Wallshall(Graph G)    最短路径 - Floyd_Wallshall算法  参数：图G 作用：计算不含负圈图的最短路径 返回是否有圈
功能实现函数：
CreateGraph(Graph &amp;G) 创建图功能实现函数 参数：图G  InsertNode 作用：创建图
BFSTraverse(Graph G)  广度遍历功能实现函数 参数：图G 作用：宽度遍历
DFSTraverse(Graph G)  深度遍历功能实现函数 参数：图G 作用：深度遍历
Shortest_Dijkstra(Graph &amp;G) 调用最短路径-Dijkstra算法 参数：图G、源点v
Shortest_Bellman_Ford(Graph &amp;G) 调用最短路径- - Bellman_Ford算法  参数：图G
Shortest_Floyd_Wallshall(Graph &amp;G) 调用最短路径- - Floyd_Wallshall算法  参数：图G
*/
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;iterator&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define MaxVerNum 100 //顶点最大数目值
#define VexType char //顶点数据类型
#define EdgeType int //弧数据类型,有向图时邻接矩阵不对称，有权值时表示权值，没有时1连0不连
#define INF 0x3f3f3f3f//作为最大值
using namespace std;
//图的数据结构
typedef struct Graph
{
	VexType Vex[MaxVerNum];//顶点表
	EdgeType Edge[MaxVerNum][MaxVerNum];//弧表
	int vexnum, arcnum;//顶点数、弧数
}Graph;
//迪杰斯特拉算法全局变量
bool S[MaxVerNum]; //顶点集
int D[MaxVerNum];  //到各个顶点的最短路径
int F_D[MaxVerNum][MaxVerNum];//Floyd的D矩阵 记录最短路径
int Pr[MaxVerNum]; //记录前驱
//*********************************************基本操作函数*****************************************//
//初始化函数 参数：图G 作用：初始化图的顶点表，邻接矩阵等
int P[MaxVerNum][MaxVerNum];//最短路径记录矩阵
void InitGraph(Graph &amp;G)
{
	memset(G.Vex, '#', sizeof(G.Vex));//初始化顶点表
									  //初始化弧表
	for (int i = 0; i &lt; MaxVerNum; i++)
		for (int j = 0; j &lt; MaxVerNum; j++)
			G.Edge[i][j] = INF;
	G.arcnum = G.vexnum = 0;          //初始化顶点数、弧数
}
//插入点函数 参数：图G,顶点v 作用：在图G中插入顶点v,即改变顶点表
bool InsertNode(Graph &amp;G, VexType v)
{
	if (G.vexnum &lt; MaxVerNum)
	{
		G.Vex[G.vexnum++] = v;
		return true;
	}
	return false;
}
//插入弧函数 参数：图G,某弧两端点v和w 作用：在图G两点v,w之间加入弧，即改变邻接矩阵
bool InsertEdge(Graph &amp;G, VexType v, VexType w, int weight)
{
	int p1, p2;//v,w两点下标
	p1 = p2 = -1;//初始化
	for (int i = 0; i&lt;G.vexnum; i++)//寻找顶点下标
	{
		if (G.Vex[i] == v)p1 = i;
		if (G.Vex[i] == w)p2 = i;
	}
	if (-1 != p1&amp;&amp;-1 != p2)//两点均可在图中找到
	{
		G.Edge[p1][p2] = weight;//有向图邻接矩阵不对称
		G.arcnum++;
		return true;
	}
	return false;
}
//判断是否存在弧(v,w)函数 参数：图G，某弧两端点v和w 作用：判断是否存在弧(v,w) 
bool Adjancent(Graph G, VexType v, VexType w)
{
	int p1, p2;//v,w两点下标
	p1 = p2 = -1;//初始化
	for (int i = 0; i&lt;G.vexnum; i++)//寻找顶点下标
	{
		if (G.Vex[i] == v)p1 = i;
		if (G.Vex[i] == w)p2 = i;
	}
	if (-1 != p1&amp;&amp;-1 != p2)//两点均可在图中找到
	{
		if (G.Edge[p1][p2] == 1)//存在弧
		{
			return true;
		}
		return false;
	}
	return false;
}
bool visited[MaxVerNum];//访问标记数组，用于遍历时的标记
//广度遍历函数 参数：图G,开始结点下标start 作用：宽度遍历
void BFS(Graph G, int start)
{
	queue&lt;int&gt; Q;//辅助队列
	cout &lt;&lt; G.Vex[start];//访问结点
	visited[start] = true;
	Q.push(start);//入队
	while (!Q.empty())//队列非空
	{
		int v = Q.front();//得到队头元素
		Q.pop();//出队
		for (int j = 0; j&lt;G.vexnum; j++)//邻接点
		{
			if (G.Edge[v][j] &lt; INF &amp;&amp; !visited[j])//是邻接点且未访问
			{
				cout &lt;&lt; "-&gt;";
				cout &lt;&lt; G.Vex[j];//访问结点
				visited[j] = true;
				Q.push(j);//入队
			}
		}
	}//while
	cout &lt;&lt; endl;
}
//深度遍历函数（递归形式）参数：图G,开始结点下标start 作用：深度遍历
void DFS(Graph G, int start)
{
	cout &lt;&lt; G.Vex[start];//访问
	visited[start] = true;
	for (int j = 0; j &lt; G.vexnum; j++)
	{
		if (G.Edge[start][j] &lt;INF &amp;&amp; !visited[j])//是邻接点且未访问
		{
			cout &lt;&lt; "-&gt;";
			DFS(G, j);//递归深度遍历
		}
	}
}
//最短路径 - Dijkstra算法 参数：图G、源点v3
void Dijkstra(Graph G, int v)
{
	//初始化
	int n = G.vexnum;//n为图的顶点个数
	for (int i = 0; i &lt; n; i++)
	{
		S[i] = false;
		D[i] = G.Edge[v][i];
		if (D[i] &lt; INF)Pr[i] = v; //v与i连接，v为前驱
		else Pr[i] = -1;
	}
	S[v] = true;
	D[v] = 0;
	//初始化结束,求最短路径，并加入S集
	for (int i = 1; i &lt; n; i++)
	{
		int min = INF;
		int temp;
		for (int w = 0; w &lt; n; w++)
			if (!S[w] &amp;&amp; D[w] &lt; min) //某点temp未加入s集，且为当前最短路径
			{
				temp = w;
				min = D[w];
			}
		S[temp] = true;
		//更新从源点出发至其余点的最短路径 通过temp
		for (int w = 0; w &lt; n; w++)
			if (!S[w] &amp;&amp; D[temp] + G.Edge[temp][w] &lt; D[w])
			{
				D[w] = D[temp] + G.Edge[temp][w];
				Pr[w] = temp;
			}
	}
}
//最短路径 - Bellman_Ford算法  参数：图G、源点v 作用：计算不含负圈图的最短路径 返回是否有圈
bool Bellman_Ford(Graph G, int v)
{
	//初始化
	int n = G.vexnum;//n为图的顶点个数
	for (int i = 0; i &lt; n; i++)
	{
		D[i] = G.Edge[v][i];
		if (D[i] &lt; INF)Pr[i] = v; //v与i连接，v为前驱
		else Pr[i] = -1;
	}
	D[v] = 0;
	//初始化结束，开始双重循环
	for (int i = 2; i&lt;G.vexnum - 1; i++)
		for (int j = 0; j&lt;G.vexnum; j++) //j为源点
			for (int k = 0; k&lt;G.vexnum; k++) //k为终点
				if (D[k] &gt; D[j] + G.Edge[j][k])
				{
					D[k] = D[j] + G.Edge[j][k];
					Pr[k] = j;
				}
	//判断是否含有负圈
	bool flag = true;
	for (int j = 0; j&lt;G.vexnum - 1; j++) //j为源点
		for (int k = 0; k&lt;G.vexnum - 1; k++) //k为终点
			if (D[k] &gt; D[j] + G.Edge[j][k])
			{
				flag = false;
				break;
			}
	return flag;
}
//最短路径 - Floyd_Wallshall算法  参数：图G 作用：计算不含负圈图的最短路径 返回是否有圈
bool Floyd_Wallshall(Graph G)
{
	//初始化
	for (int i = 0; i&lt;G.vexnum; i++)
		for (int j = 0; j &lt; G.vexnum; j++)
		{
			if (i == j)F_D[i][j] = 0;
			else F_D[i][j] = G.Edge[i][j];
			P[i][j] = -1;
		}
	//初始化结束，开始迭代
	for(int k=0;k&lt;G.vexnum;k++)
		for (int i = 0; i&lt;G.vexnum; i++)
			for (int j = 0; j&lt;G.vexnum; j++)
				if (F_D[i][j] &gt; F_D[i][k] + F_D[k][j])
				{
					F_D[i][j] = F_D[i][k] + F_D[k][j];
					P[i][j] = k;
				}
	bool flag = true;
	for (int i = 0; i &lt; G.vexnum; i++)
		for (int j = 0; j &lt; G.vexnum; j++)
			if (i==j&amp;&amp;F_D[i][j] &lt; 0)
			{
				flag = false;
				break;
			}
	return flag;
}
//输出最短路径
void Path(Graph G, int v)
{
	if (Pr[v] == -1)
		return;
	Path(G, Pr[v]);
	cout &lt;&lt; G.Vex[Pr[v]] &lt;&lt; "-&gt;";
}
// 输出Floyd最短路径 v是终点
void F_Path(Graph G, int v, int w)
{
	cout &lt;&lt; "-&gt;"&lt;&lt; G.Vex[P[v][w]] ;
	if (P[v][w] == -1)
		return;
	F_Path(G, v,P[v][w]);
	
}
//**********************************************功能实现函数*****************************************//
//打印图的顶点表
void PrintVex(Graph G)
{
	for (int i = 0; i &lt; G.vexnum; i++)
	{
		cout &lt;&lt; G.Vex[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}
//打印图的弧矩阵
void PrintEdge(Graph G)
{
	for (int i = 0; i &lt; G.vexnum; i++)
	{
		for (int j = 0; j &lt; G.vexnum; j++)
		{
			if (G.Edge[i][j] == INF)cout &lt;&lt; "∞ ";
			else cout &lt;&lt; G.Edge[i][j] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
}
//创建图功能实现函数 参数：图G  InsertNode 作用：创建图
void CreateGraph(Graph &amp;G)
{
	VexType v, w;
	int vn, an;//顶点数，弧数
	cout &lt;&lt; "请输入顶点数目:" &lt;&lt; endl;
	cin &gt;&gt; vn;
	cout &lt;&lt; "请输入弧数目:" &lt;&lt; endl;
	cin &gt;&gt; an;
	cout &lt;&lt; "请输入所有顶点名称:" &lt;&lt; endl;
	for (int i = 0; i&lt;vn; i++)
	{
		cin &gt;&gt; v;
		if (InsertNode(G, v)) continue;//插入点
		else {
			cout &lt;&lt; "输入错误！" &lt;&lt; endl; break;
		}
	}
	cout &lt;&lt; "请输入所有弧（每行输入起点，终点及权值）:" &lt;&lt; endl;
	for (int j = 0; j&lt;an; j++)
	{
		int weight;
		cin &gt;&gt; v &gt;&gt; w &gt;&gt; weight;
		if (InsertEdge(G, v, w, weight)) continue;//插入弧
		else {
			cout &lt;&lt; "输入错误！" &lt;&lt; endl; break;
		}
	}
	cout &lt;&lt; "图的顶点及邻接矩阵：" &lt;&lt; endl;
	PrintVex(G);
	PrintEdge(G);
}
//广度遍历功能实现函数 参数：图G 作用：宽度遍历
void BFSTraverse(Graph G)
{
	for (int i = 0; i&lt;MaxVerNum; i++)//初始化访问标记数组
	{
		visited[i] = false;
	}
	for (int i = 0; i &lt; G.vexnum; i++)//对每个连通分量进行遍历
	{
		if (!visited[i])BFS(G, i);
	}
}
//深度遍历功能实现函数 参数：图G 作用：深度遍历
void DFSTraverse(Graph G)
{
	for (int i = 0; i&lt;MaxVerNum; i++)//初始化访问标记数组
	{
		visited[i] = false;
	}
	for (int i = 0; i &lt; G.vexnum; i++)//对每个连通分量进行遍历
	{
		if (!visited[i])
		{
			DFS(G, i); cout &lt;&lt; endl;
		}
	}
}
//调用最短路径-Dijkstra算法 参数：图G
void Shortest_Dijkstra(Graph &amp;G)
{
	char vname;
	int v = -1;
	cout &lt;&lt; "请输入源点名称:" &lt;&lt; endl;
	cin &gt;&gt; vname;
	for (int i = 0; i &lt; G.vexnum; i++)
		if (G.Vex[i] == vname)v = i;
	if (v == -1)
	{
		cout &lt;&lt; "没有找到输入点！" &lt;&lt; endl;
		return;
	}
	Dijkstra(G, v);
	cout &lt;&lt; "目标点" &lt;&lt; "\t" &lt;&lt; "最短路径值" &lt;&lt; "\t" &lt;&lt; "最短路径" &lt;&lt; endl;
	for (int i = 0; i &lt; G.vexnum; i++)
	{
		if (i != v)
		{
			cout &lt;&lt; "  " &lt;&lt; G.Vex[i] &lt;&lt; "\t" &lt;&lt; "        " &lt;&lt; D[i] &lt;&lt; "\t";
			Path(G, i);
			cout &lt;&lt; G.Vex[i] &lt;&lt; endl;
		}
	}
}
//调用最短路径- - Bellman_Ford算法  参数：图G
void Shortest_Bellman_Ford(Graph &amp;G)
{
	char vname;
	int v = -1;
	cout &lt;&lt; "请输入源点名称:" &lt;&lt; endl;
	cin &gt;&gt; vname;
	for (int i = 0; i &lt; G.vexnum; i++)
		if (G.Vex[i] == vname)v = i;
	if (v == -1)
	{
		cout &lt;&lt; "没有找到输入点！" &lt;&lt; endl;
		return;
	}
	if (Bellman_Ford(G, v))
	{
		cout &lt;&lt; "目标点" &lt;&lt; "\t" &lt;&lt; "最短路径值" &lt;&lt; "\t" &lt;&lt; "最短路径" &lt;&lt; endl;
		for (int i = 0; i &lt; G.vexnum; i++)
		{
			cout &lt;&lt; "  " &lt;&lt; G.Vex[i] &lt;&lt; "\t" &lt;&lt; "        " &lt;&lt; D[i] &lt;&lt; "\t";
			Path(G, i);
			cout &lt;&lt; G.Vex[i] &lt;&lt; endl;
		}
	}
	else
	{
		cout &lt;&lt; "输入的图中含有负圈，不能使用该算法！" &lt;&lt; endl;
	}
}
//调用最短路径- - Floyd_Wallshall算法  参数：图G
void Shortest_Floyd_Wallshall(Graph &amp;G)
{
	if (Floyd_Wallshall(G))
	{
		cout &lt;&lt; "最短路径值" &lt;&lt; "\t" &lt;&lt; "最短路径" &lt;&lt; endl;
		for (int i = 0; i &lt; G.vexnum; i++)
			for (int j = 0; j &lt; G.vexnum; j++)
		{
			cout &lt;&lt; "     "&lt;&lt;F_D[i][j] &lt;&lt; "   \t";
			cout &lt;&lt; G.Vex[i];
			F_Path(G, i,j);
			cout &lt;&lt; G.Vex[j] &lt;&lt; endl;
		}
	}
	else
	{
		cout &lt;&lt; "输入的图中含有负圈，不能使用该算法！" &lt;&lt; endl;
	}
}
//菜单
void menu()
{
	cout &lt;&lt; "************1.创建图       2.广度遍历******************" &lt;&lt; endl;
	cout &lt;&lt; "************3.深度遍历     4.迪杰斯特拉****************" &lt;&lt; endl;
	cout &lt;&lt; "************5.贝尔曼福特   6.弗洛伊德******************" &lt;&lt; endl;
	cout &lt;&lt; "************7.退出*************************************" &lt;&lt; endl;
}
//主函数
int main()
{
	int choice = 0;
	Graph G;
	InitGraph(G);
	while (1)
	{
		menu();
		printf("请输入菜单序号：\n");
		scanf("%d", &amp;choice);
		if (7 == choice) break;
		switch (choice)
		{
		case 1:CreateGraph(G); break;
		case 2:BFSTraverse(G); break;
		case 3:DFSTraverse(G); break;
		case 4:Shortest_Dijkstra(G); break;
		case 5:Shortest_Bellman_Ford(G); break;
		case 6:Shortest_Floyd_Wallshall(G); break;
		default:printf("输入错误！！！\n"); break;
		}
	}
	return 0;
}</code></pre> 
<h2 id="%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">实验结果</h2> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/82/ef/kEJVAeB2_o.png"> 
  <figcaption>
    实验结果截图 
  </figcaption> 
 </figure> 
</div> 
<h2 id="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83">最短路径算法比较</h2> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:682px;"><tbody><tr><td>算法\比较内容</td><td>适用条件</td><td>算法思想</td><td>时间复杂度</td></tr><tr><td>Dijkstra</td><td>无负权的图，单源或多源</td><td>贪心</td><td>O(v^2)、O(v^3)</td></tr><tr><td>Bellman-Ford</td><td>可以有负权但无负圈的图</td><td>动态规划</td><td>O(v^3)、O(ve)</td></tr><tr><td>Floyd-Warshall</td><td>无负权的图，多源</td><td>动态规划</td><td> <p>O(v^3)</p> </td></tr></tbody></table> 
<p>更多数据结构与算法实现：<a href="https://blog.csdn.net/lady_killer9/article/details/82695895">数据结构（严蔚敏版）与算法的实现（含全部代码）</a></p> 
<p>有问题请下方评论，转载请注明出处，并附有原文链接，谢谢！如有侵权，请及时联系。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c148762b1ec1d0c859360fa6859a883f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设计模式 - state 状态模式 与 strategy 策略模式 分析实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5cb1c77c6c3e41329d8fb83dc1ed2b28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebRTC(八) STUN协议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>