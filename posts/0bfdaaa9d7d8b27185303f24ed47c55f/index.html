<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>样本不平衡问题分析与部分解决办法 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="样本不平衡问题分析与部分解决办法" />
<meta property="og:description" content="最近工作中在处理文本分类问题遇到了分类不均衡的问题，主要还是样本太少还同时非常的不均衡正负样本1:10（类别不平衡比例超过4:1，就会造成偏移），就使用了SMOTE方法。
注意：在进行数据增广的时候一定要将测试集和验证集单独提前分开，扩张只在训练集上进行，否则会造成在增广的验证集和测试集上进行验证和测试，在实际上线后再真实数据中效果可能会非常的差。
目录
什么是样本类别分布不均衡？
问题描述
样本类别分布不均衡导致的危害？
以下以二分类问题为例说明。
1. SMOTE(Synthetic Minority Over-sampling Technique)过采样小样本（扩充小类，产生新数据）
2. 欠采样大样本（压缩大类，产生新数据）
3. 对小类错分进行加权惩罚
4. 分治ensemble
5. 分层级ensemble
6. 基于异常检测的分类
7. 其他...待补充。
解决方法示例：
1.通过过抽样和欠抽样解决样本不均衡
（1）过抽样（over-sampling）：通过增加分类中少数类样本的数量来实现样本均衡，比较好的方法有SMOTE算法。
（2）欠抽样（under-sampling）：通过减少分类中多数类样本的数量来实现样本均衡
2.通过正负样本的惩罚权重解决样本不均衡
后附样本不平衡的问答系列
Jason Brownlee的回答：
类别不均衡问题是现实中很常见的问题
八大解决方法
Sergey Feldman的回答：
Kripa Chettiar的回答：
Roar Nybø的回答：
Dan Levin的回答：
Kaushik Kasi的回答：
Quora User的回答：
Dayvid Victor的回答：
Muktabh Mayank的回答：
Sandeep Subramanian的回答：
Quora User的回答：
Sumit Soman 的回答：
什么是样本类别分布不均衡？ 举例说明，在一组样本中不同类别的样本量差异非常大，比如拥有1000条数据样本的数据集中，有一类样本的分类只占有10条，此时属于严重的数据样本分布不均衡。
问题描述 先举一个“恐怖”的例子，直观的感受一下样本不平衡问题：
你根据1000个正样本和1000个负样本正确训练出了一个准确率90%召回率90%的分类器，且通过实验验证没有欠采样过采样的问题哦~完美的样本，完美的模型，破费，你心里暗自得意。然后模型上线，正式预测每天的未知样本~。
开始一切都很美好，准确率召回率都很好。直到有一天，数据发生了一点变化，还是原来的数据类型和特征，只是每天新数据中正负样本变成了100个正样本，10000个负样本。注意，先前准确率90%的另一种表达是负样本有10%的概率被误检为正样本。好了，模型不变，现在误检的负样本数是10000*0.1=1000个，正样本被检出100*0.9（召回）=90个，好了，这个时候召回率不变仍为90%，但是新的准确率=90/(1000&#43;90)=8.26% 。震惊吗！？恐怖吗！？
结论： 同一个模型仅仅是改变了验证集的正负样本比例，模型已经从可用退化成不可用了！！样本不平衡问题可怕就可怕在这，往往你的模型参数，训练，数据，特征都是对的！能做的都做了，但你的准确率就是上不去！！绝望吧。。。。。。
问题定义：数据集中，每个类别下的样本数目相差很大（数量级上的差距）。
样本类别分布不均衡导致的危害？ 样本类别不均衡将导致样本量少的分类所包含的特征过少，并很难从中提取规律；即使得到分类模型，也容易产生过度依赖与有限的数据样本而导致过拟合问题，当模型应用到新的数据上时，模型的准确性会很差。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/0bfdaaa9d7d8b27185303f24ed47c55f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-20T14:11:03+08:00" />
<meta property="article:modified_time" content="2019-01-20T14:11:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">样本不平衡问题分析与部分解决办法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#f33b45;">最近工作中在处理文本分类问题遇到了分类不均衡的问题，主要还是样本太少还同时非常的不均衡正负样本1:10（</span>类别不平衡比例超过4:1，就会造成偏移<span style="color:#f33b45;">），就使用了SMOTE方法。</span></p> 
<p><span style="color:#f33b45;">注意：在进行数据增广的时候一定要将测试集和验证集单独提前分开，扩张只在训练集上进行，否则会造成在增广的验证集和测试集上进行验证和测试，在实际上线后再真实数据中效果可能会非常的差。</span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%88%AB%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E8%A1%A1%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%88%AB%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E8%A1%A1%EF%BC%9F" rel="nofollow">什么是样本类别分布不均衡？</a></p> 
<p id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" rel="nofollow">问题描述</a></p> 
<p id="%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%88%AB%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E8%A1%A1%E5%AF%BC%E8%87%B4%E7%9A%84%E5%8D%B1%E5%AE%B3%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%88%AB%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E8%A1%A1%E5%AF%BC%E8%87%B4%E7%9A%84%E5%8D%B1%E5%AE%B3%EF%BC%9F" rel="nofollow">样本类别分布不均衡导致的危害？</a></p> 
<p id="%E4%BB%A5%E4%B8%8B%E4%BB%A5%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82-toc" style="margin-left:0px;"><a href="#%E4%BB%A5%E4%B8%8B%E4%BB%A5%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82" rel="nofollow">以下以二分类问题为例说明。</a></p> 
<p id="1.%20SMOTE(Synthetic%20Minority%20Over-sampling%20Technique)%E8%BF%87%E9%87%87%E6%A0%B7%E5%B0%8F%E6%A0%B7%E6%9C%AC%EF%BC%88%E6%89%A9%E5%85%85%E5%B0%8F%E7%B1%BB%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.%20SMOTE%28Synthetic%20Minority%20Over-sampling%20Technique%29%E8%BF%87%E9%87%87%E6%A0%B7%E5%B0%8F%E6%A0%B7%E6%9C%AC%EF%BC%88%E6%89%A9%E5%85%85%E5%B0%8F%E7%B1%BB%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%89" rel="nofollow">1. SMOTE(Synthetic Minority Over-sampling Technique)过采样小样本（扩充小类，产生新数据）</a></p> 
<p id="2.%20%E6%AC%A0%E9%87%87%E6%A0%B7%E5%A4%A7%E6%A0%B7%E6%9C%AC%EF%BC%88%E5%8E%8B%E7%BC%A9%E5%A4%A7%E7%B1%BB%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.%20%E6%AC%A0%E9%87%87%E6%A0%B7%E5%A4%A7%E6%A0%B7%E6%9C%AC%EF%BC%88%E5%8E%8B%E7%BC%A9%E5%A4%A7%E7%B1%BB%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%89" rel="nofollow">2. 欠采样大样本（压缩大类，产生新数据）</a></p> 
<p id="3.%20%E5%AF%B9%E5%B0%8F%E7%B1%BB%E9%94%99%E5%88%86%E8%BF%9B%E8%A1%8C%E5%8A%A0%E6%9D%83%E6%83%A9%E7%BD%9A-toc" style="margin-left:40px;"><a href="#3.%20%E5%AF%B9%E5%B0%8F%E7%B1%BB%E9%94%99%E5%88%86%E8%BF%9B%E8%A1%8C%E5%8A%A0%E6%9D%83%E6%83%A9%E7%BD%9A" rel="nofollow">3. 对小类错分进行加权惩罚</a></p> 
<p id="4.%20%E5%88%86%E6%B2%BBensemble-toc" style="margin-left:40px;"><a href="#4.%20%E5%88%86%E6%B2%BBensemble" rel="nofollow">4. 分治ensemble</a></p> 
<p id="5.%20%E5%88%86%E5%B1%82%E7%BA%A7ensemble-toc" style="margin-left:40px;"><a href="#5.%20%E5%88%86%E5%B1%82%E7%BA%A7ensemble" rel="nofollow">5. 分层级ensemble</a></p> 
<p id="6.%20%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#6.%20%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">6. 基于异常检测的分类</a></p> 
<p id="7.%20%E5%85%B6%E4%BB%96...%E5%BE%85%E8%A1%A5%E5%85%85%E3%80%82-toc" style="margin-left:40px;"><a href="#7.%20%E5%85%B6%E4%BB%96...%E5%BE%85%E8%A1%A5%E5%85%85%E3%80%82" rel="nofollow">7. 其他...待补充。</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow">解决方法示例：</a></p> 
<p id="1.%E9%80%9A%E8%BF%87%E8%BF%87%E6%8A%BD%E6%A0%B7%E5%92%8C%E6%AC%A0%E6%8A%BD%E6%A0%B7%E8%A7%A3%E5%86%B3%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1-toc" style="margin-left:40px;"><a href="#1.%E9%80%9A%E8%BF%87%E8%BF%87%E6%8A%BD%E6%A0%B7%E5%92%8C%E6%AC%A0%E6%8A%BD%E6%A0%B7%E8%A7%A3%E5%86%B3%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1" rel="nofollow">1.通过过抽样和欠抽样解决样本不均衡</a></p> 
<p id="%EF%BC%881%EF%BC%89%E8%BF%87%E6%8A%BD%E6%A0%B7%EF%BC%88over-sampling%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A2%9E%E5%8A%A0%E5%88%86%E7%B1%BB%E4%B8%AD%E5%B0%91%E6%95%B0%E7%B1%BB%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%95%B0%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%B7%E6%9C%AC%E5%9D%87%E8%A1%A1%EF%BC%8C%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89SMOTE%E7%AE%97%E6%B3%95%E3%80%82-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E8%BF%87%E6%8A%BD%E6%A0%B7%EF%BC%88over-sampling%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A2%9E%E5%8A%A0%E5%88%86%E7%B1%BB%E4%B8%AD%E5%B0%91%E6%95%B0%E7%B1%BB%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%95%B0%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%B7%E6%9C%AC%E5%9D%87%E8%A1%A1%EF%BC%8C%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89SMOTE%E7%AE%97%E6%B3%95%E3%80%82" rel="nofollow">（1）过抽样（over-sampling）：通过增加分类中少数类样本的数量来实现样本均衡，比较好的方法有SMOTE算法。</a></p> 
<p id="%EF%BC%882%EF%BC%89%E6%AC%A0%E6%8A%BD%E6%A0%B7%EF%BC%88under-sampling%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87%E5%87%8F%E5%B0%91%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A4%9A%E6%95%B0%E7%B1%BB%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%95%B0%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%B7%E6%9C%AC%E5%9D%87%E8%A1%A1-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E6%AC%A0%E6%8A%BD%E6%A0%B7%EF%BC%88under-sampling%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87%E5%87%8F%E5%B0%91%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A4%9A%E6%95%B0%E7%B1%BB%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%95%B0%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%B7%E6%9C%AC%E5%9D%87%E8%A1%A1" rel="nofollow">（2）欠抽样（under-sampling）：通过减少分类中多数类样本的数量来实现样本均衡</a></p> 
<p id="2.%E9%80%9A%E8%BF%87%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%83%A9%E7%BD%9A%E6%9D%83%E9%87%8D%E8%A7%A3%E5%86%B3%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1-toc" style="margin-left:40px;"><a href="#2.%E9%80%9A%E8%BF%87%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%83%A9%E7%BD%9A%E6%9D%83%E9%87%8D%E8%A7%A3%E5%86%B3%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1" rel="nofollow">2.通过正负样本的惩罚权重解决样本不均衡</a></p> 
<p id="%E5%90%8E%E9%99%84%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97-toc" style="margin-left:0px;"><a href="#%E5%90%8E%E9%99%84%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97" rel="nofollow">后附样本不平衡的问答系列</a></p> 
<p id="%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AE%AD%E7%BB%83%E9%9B%86%E4%B8%AD%E4%B8%8D%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"> </p> 
<p id="jason-brownlee的回答-toc" style="margin-left:80px;"><a href="#jason-brownlee%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Jason Brownlee的回答：</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"> </p> 
<p id="%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98%E6%98%AF%E7%8E%B0%E5%AE%9E%E4%B8%AD%E5%BE%88%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98%E6%98%AF%E7%8E%B0%E5%AE%9E%E4%B8%AD%E5%BE%88%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">类别不均衡问题是现实中很常见的问题</a></p> 
<p id="%E5%85%AB%E5%A4%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%85%AB%E5%A4%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" rel="nofollow">八大解决方法</a></p> 
<p id="sergey-feldman的回答-toc" style="margin-left:80px;"><a href="#sergey-feldman%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Sergey Feldman的回答：</a></p> 
<p id="kripa-chettiar的回答-toc" style="margin-left:80px;"><a href="#kripa-chettiar%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Kripa Chettiar的回答：</a></p> 
<p id="roar-nybø的回答-toc" style="margin-left:80px;"><a href="#roar-nyb%C3%B8%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Roar Nybø的回答：</a></p> 
<p id="dan-levin的回答-toc" style="margin-left:80px;"><a href="#dan-levin%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Dan Levin的回答：</a></p> 
<p id="kaushik-kasi的回答-toc" style="margin-left:80px;"><a href="#kaushik-kasi%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Kaushik Kasi的回答：</a></p> 
<p id="quora-user的回答-toc" style="margin-left:80px;"><a href="#quora-user%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Quora User的回答：</a></p> 
<p id="dayvid-victor的回答-toc" style="margin-left:80px;"><a href="#dayvid-victor%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Dayvid Victor的回答：</a></p> 
<p id="muktabh-mayank的回答-toc" style="margin-left:80px;"><a href="#muktabh-mayank%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Muktabh Mayank的回答：</a></p> 
<p id="sandeep-subramanian的回答-toc" style="margin-left:80px;"><a href="#sandeep-subramanian%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Sandeep Subramanian的回答：</a></p> 
<p id="quora-user的回答-1-toc" style="margin-left:80px;"><a href="#quora-user%E7%9A%84%E5%9B%9E%E7%AD%94-1" rel="nofollow">Quora User的回答：</a></p> 
<p id="sumit-soman-的回答-toc" style="margin-left:80px;"><a href="#sumit-soman-%E7%9A%84%E5%9B%9E%E7%AD%94" rel="nofollow">Sumit Soman 的回答：</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%88%AB%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E8%A1%A1%EF%BC%9F">什么是样本类别分布不均衡？</h2> 
<p>举例说明，在一组样本中不同类别的样本量差异非常大，比如拥有1000条数据样本的数据集中，有一类样本的分类只占有10条，此时属于严重的数据样本分布不均衡。</p> 
<h2 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h2> 
<p>先举一个“恐怖”的例子，直观的感受一下样本不平衡问题：</p> 
<p>你根据1000个正样本和1000个负样本正确训练出了一个准确率90%召回率90%的分类器，且通过实验验证没有欠采样过采样的问题哦~完美的样本，完美的模型，破费，你心里暗自得意。然后模型上线，正式预测每天的未知样本~。</p> 
<p>开始一切都很美好，准确率召回率都很好。直到有一天，数据发生了一点变化，还是原来的数据类型和特征，只是每天新数据中正负样本变成了100个正样本，10000个负样本。注意，先前准确率90%的另一种表达是负样本有10%的概率被误检为正样本。好了，模型不变，现在误检的负样本数是10000*0.1=1000个，正样本被检出100*0.9（召回）=90个，好了，这个时候召回率不变仍为90%，但是新的准确率=90/(1000+90)=8.26% 。震惊吗！？恐怖吗！？</p> 
<p>结论： 同一个模型仅仅是改变了验证集的正负样本比例，模型已经从可用退化成不可用了！！样本不平衡问题可怕就可怕在这，往往你的模型参数，训练，数据，特征都是对的！能做的都做了，但你的准确率就是上不去！！绝望吧。。。。。。<br><strong>问题定义：数据集中，每个类别下的样本数目相差很大（数量级上的差距）。</strong></p> 
<h2 id="%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%88%AB%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E8%A1%A1%E5%AF%BC%E8%87%B4%E7%9A%84%E5%8D%B1%E5%AE%B3%EF%BC%9F">样本类别分布不均衡导致的危害？</h2> 
<p>样本类别不均衡将导致样本量少的分类所包含的特征过少，并很难从中提取规律；即使得到分类模型，也容易产生过度依赖与有限的数据样本而导致过拟合问题，当模型应用到新的数据上时，模型的准确性会很差。<br>  </p> 
<h2 id="%E4%BB%A5%E4%B8%8B%E4%BB%A5%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82">以下以二分类问题为例说明。</h2> 
<h3 id="1.%20SMOTE(Synthetic%20Minority%20Over-sampling%20Technique)%E8%BF%87%E9%87%87%E6%A0%B7%E5%B0%8F%E6%A0%B7%E6%9C%AC%EF%BC%88%E6%89%A9%E5%85%85%E5%B0%8F%E7%B1%BB%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%89">1. SMOTE(Synthetic Minority Over-sampling Technique)过采样小样本（扩充小类，产生新数据）</h3> 
<p>即该算法构造的数据是新样本，原数据集中不存在的。该基于距离度量选择小类别下两个或者更多的相似样本，然后选择其中一个样本，并随机选择一定数量的邻居样本对选择的那个样本的一个属性增加噪声，每次处理一个属性。这样就构造了更多的新生数据。（优点是相当于合理地对小样本的分类平面进行的一定程度的外扩；也相当于对小类错分进行加权惩罚（解释见3））</p> 
<h3 id="2.%20%E6%AC%A0%E9%87%87%E6%A0%B7%E5%A4%A7%E6%A0%B7%E6%9C%AC%EF%BC%88%E5%8E%8B%E7%BC%A9%E5%A4%A7%E7%B1%BB%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%89">2. 欠采样大样本（压缩大类，产生新数据）</h3> 
<p>设小类中有N个样本。将大类聚类成N个簇，然后使用每个簇的中心组成大类中的N个样本，加上小类中所有的样本进行训练。（优点是保留了大类在特征空间的分布特性，又降低了大类数据的数目）</p> 
<h3 id="3.%20%E5%AF%B9%E5%B0%8F%E7%B1%BB%E9%94%99%E5%88%86%E8%BF%9B%E8%A1%8C%E5%8A%A0%E6%9D%83%E6%83%A9%E7%BD%9A">3. 对小类错分进行加权惩罚</h3> 
<p>对分类器的小类样本数据增加权值，降低大类样本的权值（这种方法其实是产生了新的数据分布，即产生了新的数据集，译者注），从而使得分类器将重点集中在小类样本身上。一个具体做法就是，在训练分类器时，若分类器将小类样本分错时额外增加分类器一个小类样本分错代价，这个额外的代价可以使得分类器更加“关心”小类样本。如penalized-SVM和penalized-LDA算法。<br> 对小样本进行过采样（例如含L倍的重复数据），其实在计算小样本错分cost functions时会累加L倍的惩罚分数。</p> 
<h3 id="4.%20%E5%88%86%E6%B2%BBensemble">4. 分治ensemble</h3> 
<p>将大类中样本聚类到L个聚类中，然后训练L个分类器；每个分类器使用大类中的一个簇与所有的小类样本进行训练得到；最后对这L个分类器采取少数服从多数对未知类别数据进行分类，如果是连续值（预测），那么采用平均值。</p> 
<h3 id="5.%20%E5%88%86%E5%B1%82%E7%BA%A7ensemble">5. 分层级ensemble</h3> 
<p>使用原始数据集训练第一个学习器L1；将L1错分的数据集作为新的数据集训练L2；将L1和L2分类结果不一致的数据作为数据集训练L3；最后测试集上将三个分类器的结果汇总（结合这三个分类器，采用投票的方式来决定分类结果，因此只有当L2与L3都分类为false时，最终结果才为false，否则true。）</p> 
<h3 id="6.%20%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E5%88%86%E7%B1%BB">6. 基于异常检测的分类</h3> 
<p>用异常检测算法（如高斯混合模型、聚类等）检测得到离群点或异常点；再对这些异常点为训练集学习一个分类器。</p> 
<h3 id="7.%20%E5%85%B6%E4%BB%96...%E5%BE%85%E8%A1%A5%E5%85%85%E3%80%82">7. 其他...待补充。<br>  </h3> 
<h2 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A">解决方法示例：</h2> 
<h3 id="1.%E9%80%9A%E8%BF%87%E8%BF%87%E6%8A%BD%E6%A0%B7%E5%92%8C%E6%AC%A0%E6%8A%BD%E6%A0%B7%E8%A7%A3%E5%86%B3%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1">1.通过过抽样和欠抽样解决样本不均衡</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E8%BF%87%E6%8A%BD%E6%A0%B7%EF%BC%88over-sampling%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A2%9E%E5%8A%A0%E5%88%86%E7%B1%BB%E4%B8%AD%E5%B0%91%E6%95%B0%E7%B1%BB%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%95%B0%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%B7%E6%9C%AC%E5%9D%87%E8%A1%A1%EF%BC%8C%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89SMOTE%E7%AE%97%E6%B3%95%E3%80%82">（1）过抽样（over-sampling）：通过增加分类中少数类样本的数量来实现样本均衡，比较好的方法有SMOTE算法。</h4> 
<p>SMOTE算法：简单来说smote算法的思想是合成新的少数类样本，合成的策略是对每个少数类样本a，从它的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。具体的过程大家可以自行google。</p> 
<p>附上代码示例：(首先展示示例数据，本篇文章都用此数据)</p> 
<pre class="has"><code class="language-python">    import pandas as pd
    from imblearn.over_sampling import SMOTE       #过度抽样处理库SMOTE
    df=pd.read_table('data2.txt',sep=' ',names=['col1','col2','col3','col4','col5','label'])    
    x=df.iloc[:,:-1]
    y=df.iloc[:,-1]
    groupby_data_orginal=df.groupby('label').count()      #根据标签label分类汇总</code></pre> 
<p><img alt="" class="has" height="129" src="https://images2.imgbox.com/1a/75/AuNdLMKN_o.png" width="348"></p> 
<p>用groupby可以看到该数据label=0的有942个样本，label=1的只有58个，存在严重的不均衡现象，在这里我们用SMOTE算法来解决一下。</p> 
<pre class="has"><code class="language-python">    model_smote=SMOTE()    #建立smote模型对象
    x_smote_resampled,y_smote_resampled=model_smote.fit_sample(x,y)
    x_smote_resampled=pd.DataFrame(x_smote_resampled,columns=['col1','col2','col3','col4','col5'])
    y_smote_resampled=pd.DataFrame(y_smote_resampled,columns=['label'])
    smote_resampled=pd.concat([x_smote_resampled,y_smote_resampled],axis=1)
    groupby_data_smote=smote_resampled.groupby('label').count()</code></pre> 
<p><img alt="" class="has" height="112" src="https://images2.imgbox.com/8a/ef/jzkMVK8E_o.png" width="327"><br> 可以看到通过smote算法将原本只有58个数据的样本补齐成了942。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E6%AC%A0%E6%8A%BD%E6%A0%B7%EF%BC%88under-sampling%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87%E5%87%8F%E5%B0%91%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A4%9A%E6%95%B0%E7%B1%BB%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%95%B0%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%B7%E6%9C%AC%E5%9D%87%E8%A1%A1">（2）欠抽样（under-sampling）：通过减少分类中多数类样本的数量来实现样本均衡</h4> 
<pre class="has"><code class="language-python">    from imblearn.under_sampling import RandomUnderSampler
    model_RandomUnderSampler=RandomUnderSampler()                #建立RandomUnderSample模型对象
    x_RandomUnderSample_resampled,y_RandomUnderSample_resampled=model_RandomUnderSampler.fit_sample(x,y)         #输入数据并进行欠抽样处理
    x_RandomUnderSample_resampled=pd.DataFrame(x_RandomUnderSample_resampled,columns=['col1','col2','col3','col4','col5'])
    y_RandomUnderSample_resampled=pd.DataFrame(y_RandomUnderSample_resampled,columns=['label'])
    RandomUnderSampler_resampled=pd.concat([x_RandomUnderSample_resampled,y_RandomUnderSample_resampled],axis=1)
    groupby_data_RandomUnderSampler=RandomUnderSampler_resampled.groupby('label').count()</code></pre> 
<p><img alt="" class="has" height="68" src="https://images2.imgbox.com/1f/40/6d4Lbpzv_o.png" width="286"><br> 根据数据可看到通过随机欠抽样方法，将原本942条数据的label0删减成为58条。</p> 
<h3 id="2.%E9%80%9A%E8%BF%87%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%83%A9%E7%BD%9A%E6%9D%83%E9%87%8D%E8%A7%A3%E5%86%B3%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1">2.通过正负样本的惩罚权重解决样本不均衡</h3> 
<p>算法思想：对于分类中不同样本数量的类别分别赋予不同的权重，一般是小样本量类别权重高，大样本量类别权重低。</p> 
<p>这里以SVM为例：</p> 
<pre class="has"><code class="language-python">    from sklearn.svm import SVC
    model_svm=SVC(class_weight='balanced')
    model_svm.fit(x,y)</code></pre> 
<p>这里的class_weight选项用其默认方法‘balanced’，即SVM会将权重设置为与不同类别样本数量呈反比的权重来进行自动均衡处理。<br>  </p> 
<h2 id="%E5%90%8E%E9%99%84%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97">后附样本不平衡的问答系列</h2> 
<p id="在分类中如何处理训练集中不平衡问题">原文：<a href="https://www.quora.com/In-classification-how-do-you-handle-an-unbalanced-training-set" rel="nofollow">https://www.quora.com/In-classification-how-do-you-handle-an-unbalanced-training-set</a></p> 
<h3 id="%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AE%AD%E7%BB%83%E9%9B%86%E4%B8%AD%E4%B8%8D%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98"> </h3> 
<h4 id="jason-brownlee的回答"><a name="t2"></a> <a name="t1"></a><a href="http://machinelearningmastery.com/author/jasonb/" rel="nofollow">Jason Brownlee</a>的回答：</h4> 
<p>原文标题：<a href="http://machinelearningmastery.com/tactics-to-combat-imbalanced-classes-in-your-machine-learning-dataset/" rel="nofollow">8 Tactics to Combat Imbalanced Classes in Your Machine Learning Dataset</a> <br>   当你在对一个类别不均衡的数据集进行分类时得到了90%的准确度（Accuracy）。当你进一步分析发现，数据集的90%的样本是属于同一个类，并且分类器将所有的样本都分类为该类。在这种情况下，显然该分类器是无效的。并且这种无效是由于训练集中类别不均衡而导致的。 <br>   首先举几个所收到的邮件中关于类别不均衡的例子：</p> 
<ul><li>在一个二分类问题中，训练集中class 1的样本数比class 2的样本数是60:1。使用逻辑回归进行分类，最后结果是其忽略了class 2，即其将所有的训练样本都分类为class 1。</li><li>在分类任务的数据集中，有三个类别，分别为A，B，C。在训练集中，A类的样本占70%，B类的样本占25%，C类的样本占5%。最后我的分类器对类A的样本过拟合了，而对其它两个类别的样本欠拟合。</li></ul> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98"></h4> 
<h4 id="%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98%E6%98%AF%E7%8E%B0%E5%AE%9E%E4%B8%AD%E5%BE%88%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98"><a name="t3"></a>类别不均衡问题是现实中很常见的问题</h4> 
<p>  大部分分类任务中，各类别下的数据个数基本上不可能完全相等，但是一点点差异是不会产生任何影响与问题的。 <br>   在现实中有很多类别不均衡问题，它是常见的，并且也是合理的，符合人们期望的。如，在欺诈交易识别中，属于欺诈交易的应该是很少部分，即绝大部分交易是正常的，只有极少部分的交易属于欺诈交易。这就是一个正常的类别不均衡问题。又如，在客户流失的数据集中，绝大部分的客户是会继续享受其服务的（非流失对象），只有极少数部分的客户不会再继续享受其服务（流失对象）。一般而已，如果类别不平衡比例超过4:1，那么其分类器会大大地因为数据不平衡性而无法满足分类要求的。因此在构建分类模型之前，需要对分类不均衡性问题进行处理。 <br>   在前面，我们使用准确度这个指标来评价分类质量，可以看出，在类别不均衡时，准确度这个评价指标并不能work。因为分类器将所有的样本都分类到大类下面时，该指标值仍然会很高。即，该分类器偏向了大类这个类别的数据。</p> 
<h4 id="%E5%85%AB%E5%A4%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><a name="t4"></a>八大解决方法</h4> 
<ul><li>可以扩大数据集吗？ <br>   当遇到类别不均衡问题时，首先应该想到，是否可能再增加数据（一定要有小类样本数据），更多的数据往往战胜更好的算法。因为机器学习是使用现有的数据多整个数据的分布进行估计，因此更多的数据往往能够得到更多的分布信息，以及更好分布估计。即使再增加小类样本数据时，又增加了大类样本数据，也可以使用放弃一部分大类数据（即对大类数据进行欠采样）来解决。</li><li> <p>尝试其它评价指标 <br>   从前面的分析可以看出，准确度这个评价指标在类别不均衡的分类任务中并不能work，甚至进行误导（分类器不work，但是从这个指标来看，该分类器有着很好的评价指标得分）。因此在类别不均衡分类任务中，需要使用更有说服力的评价指标来对分类器进行评价。如何对不同的问题选择有效的评价指标<a href="http://machinelearningmastery.com/classification-accuracy-is-not-enough-more-performance-measures-you-can-use/" rel="nofollow">参见这里</a>。 <br>   上面的超链接中的文章，讲述了如何对乳腺癌患者复发类别不均衡数据进行分类。在文中，推荐了几个比传统的准确度更有效的评价指标：</p> 
  <ul><li>混淆矩阵(Confusion Matrix)：使用一个表格对分类器所预测的类别与其真实的类别的样本统计，分别为：TP、FN、FP与TN。</li><li>精确度(Precision)</li><li>召回率(Recall)</li><li>F1得分(F1 Score)：精确度与找召回率的加权平均。</li></ul><p>  特别是：</p> 
  <ul><li>Kappa (<a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa" rel="nofollow">Cohen kappa</a>)</li><li>ROC曲线(ROC Curves)：见<a href="http://machinelearningmastery.com/assessing-comparing-classifier-performance-roc-curves-2/" rel="nofollow">Assessing and Comparing Classifier Performance with ROC Curves</a></li></ul></li><li> <p>对数据集进行重采样 <br>   可以使用一些策略该减轻数据的不平衡程度。该策略便是采样(sampling)，主要有两种采样方法来降低数据的不平衡性。</p> 
  <ul><li>对小类的数据样本进行采样来增加小类的数据样本个数，即过采样（over-sampling ，采样的个数大于该类样本的个数）。</li><li>对大类的数据样本进行采样来减少该类数据样本的个数，即欠采样（under-sampling，采样的次数少于该类样本的个素）。</li></ul><p>  采样<a href="http://lib.csdn.net/base/datastructure" rel="nofollow">算法</a>往往很容易实现，并且其运行速度快，并且效果也不错。更详细的内容参见<a href="https://en.wikipedia.org/wiki/Oversampling_and_undersampling_in_data_analysis" rel="nofollow">这里</a>。 <br>   一些经验法则：</p> 
  <ul><li>考虑对大类下的样本（超过1万、十万甚至更多）进行欠采样，即删除部分样本；</li><li>考虑对小类下的样本（不足1为甚至更少）进行过采样，即添加部分样本的副本；</li><li>考虑尝试随机采样与非随机采样两种采样方法；</li><li>考虑对各类别尝试不同的采样比例，比一定是1:1，有时候1:1反而不好，因为与现实情况相差甚远；</li><li>考虑同时使用过采样与欠采样。</li></ul></li><li>尝试产生人工数据样本 <br>   一种简单的人工样本数据产生的方法便是，对该类下的所有样本每个属性特征的取值空间中随机选取一个组成新的样本，即属性值随机采样。你可以使用基于经验对属性值进行随机采样而构造新的人工样本，或者使用类似朴素贝叶斯方法假设各属性之间互相独立进行采样，这样便可得到更多的数据，但是无法保证属性之前的线性关系（如果本身是存在的）。 <br>   有一个系统的构造人工数据样本的方法SMOTE(Synthetic Minority Over-sampling Technique)。SMOTE是一种过采样算法，它构造新的小类样本而不是产生小类中已有的样本的副本，即该算法构造的数据是新样本，原数据集中不存在的。该基于距离度量选择小类别下两个或者更多的相似样本，然后选择其中一个样本，并随机选择一定数量的邻居样本对选择的那个样本的一个属性增加噪声，每次处理一个属性。这样就构造了更多的新生数据。具体可以参见原始论文。 <br>   这里有SMOTE算法的多个不同语言的实现版本：  
  <ul><li>Python: <a href="https://github.com/fmfn/UnbalancedDataset">UnbalancedDataset</a>模块提供了SMOTE算法的多种不同实现版本，以及多种重采样算法。</li><li>R: <a href="http://blog.csdn.net/heyongluoyao8/article/details/DMwR%20packagehttps://cran.r-project.org/web/packages/DMwR/index.html">DMwR package</a>。</li><li>Weka: <a href="http://weka.sourceforge.net/doc.packages/SMOTE/weka/filters/supervised/instance/SMOTE.html" rel="nofollow">SMOTE supervised filter</a>。</li></ul></li><li>尝试不同的分类算法 <br>   强烈建议不要对待每一个分类都使用自己喜欢而熟悉的分类算法。应该使用不同的算法对其进行比较，因为不同的算法使用于不同的任务与数据。具体可以参见“Why you should be Spot-Checking Algorithms on your Machine Learning Problems”。 <br>   决策树往往在类别不均衡数据上表现不错。它使用基于类变量的划分规则去创建分类树，因此可以强制地将不同类别的样本分开。目前流行的决策树算法有：C4.5、C5.0、CART和Random Forest等。基于R编写的决策树参见<a href="http://blog.csdn.net/heyongluoyao8/article/details/Non-Linear%20Classification%20in%20R%20with%20Decision%20Trees">这里</a>。基于Python的Scikit-learn的CART使用参见<a href="http://blog.csdn.net/heyongluoyao8/article/details/Get%20Your%20Hands%20Dirty%20With%20Scikit-Learn%20Now">这里</a>。</li><li>尝试对模型进行惩罚 <br>   你可以使用相同的分类算法，但是使用一个不同的角度，比如你的分类任务是识别那些小类，那么可以对分类器的小类样本数据增加权值，降低大类样本的权值（这种方法其实是产生了新的数据分布，即产生了新的数据集，译者注），从而使得分类器将重点集中在小类样本身上。一个具体做法就是，在训练分类器时，若分类器将小类样本分错时额外增加分类器一个小类样本分错代价，这个额外的代价可以使得分类器更加“关心”小类样本。如penalized-SVM和penalized-LDA算法。 <br>   Weka中有一个惩罚模型的通用框架<a href="http://weka.sourceforge.net/doc.dev/weka/classifiers/meta/CostSensitiveClassifier.html" rel="nofollow">CostSensitiveClassifier</a>，它能够对任何分类器进行封装，并且使用一个自定义的惩罚矩阵对分错的样本进行惩罚。 <br>   如果你锁定一个具体的算法时，并且无法通过使用重采样来解决不均衡性问题而得到较差的分类结果。这样你便可以使用惩罚模型来解决不平衡性问题。但是，设置惩罚矩阵是一个复杂的事，因此你需要根据你的任务尝试不同的惩罚矩阵，并选取一个较好的惩罚矩阵。</li><li>尝试一个新的角度理解问题 <br>   我们可以从不同于分类的角度去解决数据不均衡性问题，我们可以把那些小类的样本作为异常点(outliers)，因此该问题便转化为异常点检测(anomaly detection)与变化趋势检测问题(change detection)。 <br>   <a href="https://en.wikipedia.org/wiki/Anomaly_detection" rel="nofollow">异常点检测</a>即是对那些罕见事件进行识别。如通过机器的部件的振动识别机器故障，又如通过系统调用序列识别恶意程序。这些事件相对于正常情况是很少见的。 <br>   <a href="https://en.wikipedia.org/wiki/Change_detection" rel="nofollow">变化趋势检测</a>类似于异常点检测，不同在于其通过检测不寻常的变化趋势来识别。如通过观察用户模式或银行交易来检测用户行为的不寻常改变。 <br>   将小类样本作为异常点这种思维的转变，可以帮助考虑新的方法去分离或分类样本。这两种方法从不同的角度去思考，让你尝试新的方法去解决问题。</li><li>尝试创新 <br>   仔细对你的问题进行分析与挖掘，是否可以将你的问题划分成多个更小的问题，而这些小问题更容易解决。你可以从这篇文章<a href="http://www.quora.com/In-classification-how-do-you-handle-an-unbalanced-training-set" rel="nofollow">In classification, how do you handle an unbalanced training set?</a>中得到灵感。例如：  
  <ul><li>将你的大类压缩成小类；</li><li>使用One Class分类器（将小类作为异常点）；</li><li>使用集成方式，训练多个分类器，然后联合这些分类器进行分类；</li><li>….</li></ul></li></ul> 
<p>  这些想法只是冰山一角，你可以想到更多的有趣的和有创意的想法去解决问题。更多的想法参加Reddit的文章<a href="https://www.reddit.com/r/MachineLearning/comments/12evgi/classification_when_80_of_my_training_set_is_of/" rel="nofollow">http://www.quora.com/In-classification-how-do-you-handle-an-unbalanced-training-set</a>。</p> 
<p><a name="t5"></a>选择某一种方法并使用它</p> 
<p>  你不必成为一个精通所有算法的算法奇才或者一个建立准确而可靠的处理数据不平衡的模型的统计学家，你只需要根据你的问题的实际情况从上述算法或方法中去选择一种或两种方法去使用。希望上述的某些方法能够解决你的问题。例如使用其它评价指标或重采样算法速度快并且有效。</p> 
<p><a name="t6"></a>总结</p> 
<p>  记住，其实并不知道哪种方法最适合你的任务与数据，你可以使用一些启发式规则或经验去选择某一个较优算法。当然最好的方法<a href="http://lib.csdn.net/base/softwaretest" rel="nofollow">测试</a>每一种算法，然后选择最好的方法。最重要的是，从点滴开始做起，根据自己现有的知识，并不断学习去一步步完善。</p> 
<p><a name="t7"></a>Further Reading…</p> 
<p>  这里有一些我认为有价值的可供参考的相关资料，让你进一步去认识与研究数据不平衡问题：</p> 
<ul><li>相关书籍  
  <ul><li><a href="http://blog.csdn.net/heyongluoyao8/article/details/Imbalanced%20Learning:%20Foundations,%20Algorithms,%20and%20Applications">Imbalanced Learning: Foundations, Algorithms, and Applications</a></li></ul></li><li>相关论文  
  <ul><li><a href="http://blog.csdn.net/heyongluoyao8/article/details/Data%20Mining%20for%20Imbalanced%20Datasets:%20An%20Overview">Data Mining for Imbalanced Datasets: An Overview</a></li><li><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5128907" rel="nofollow">Learning from Imbalanced Data</a></li><li><a href="http://sci2s.ugr.es/keel/pdf/algorithm/congreso/kubat97addressing.pdf" rel="nofollow">Addressing the Curse of Imbalanced Training Sets: One-Sided Selection (PDF)</a></li><li><a href="http://dl.acm.org/citation.cfm?id=1007735" rel="nofollow">A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data</a></li></ul></li></ul> 
<h4 id="sergey-feldman的回答"> <a name="t8"></a><a href="https://www.quora.com/Sergey-Feldman" rel="nofollow">Sergey Feldman</a>的回答：</h4> 
<ul><li>设超大类中样本的个数是极小类中样本个数的L倍，那么在随机梯度下降（SGD，stochastic gradient descent）算法中，每次遇到一个极小类中样本进行训练时，训练L次。</li><li>将大类中样本划分到L个聚类中，然后训练L个分类器，每个分类器使用大类中的一个簇与所有的小类样本进行训练得到。最后对这L个分类器采取少数服从多数对未知类别数据进行分类，如果是连续值（预测），那么采用平均值。</li><li>设小类中有N个样本。将大类聚类成N个簇，然后使用每个簇的中心组成大类中的N个样本，加上小类中所有的样本进行训练。</li><li>无论你使用前面的何种方法，都对某个或某些类进行了损害。为了不进行损害，那么可以使用全部的训练集采用多种分类方法分别建立分类器而得到多个分类器，采用投票的方式对未知类别的数据进行分类，如果是连续值（预测），那么采用平均值。</li><li>在<a href="http://jmlr.csail.mit.edu/proceedings/papers/v28/vandermaaten13.pdf" rel="nofollow">最近的ICML论文</a>中，表明增加数据量使得已知分布的训练集的误差增加了，即破坏了原有训练集的分布，从而可以提高分类器的性能。这篇论文与类别不平衡问题不相关，因为它隐式地使用数学方式增加数据而使得数据集大小不变。但是，我认为破坏原有的分布是有益的。</li><li>More details than you need: imho, the most interesting of the corrupting distributions is the blankout distribution, where you just zero out a random subset of features. Why is it interesting? Because you are helping your classifier be sturdier/hardier by giving it variations of your data that have essentially missing features. So it has to learn to classify correctly even in adverse conditions. 一个相关的想法是，在神经网络中，随机选择部分隐藏层单元来继续训练（即，随机去掉一部分隐藏层单元，(zeroed-out)）。具体见<a href="http://web.stanford.edu/~sidaw/cgi-bin/home/lib/exe/fetch.php?media=papers:fastdropout.pdf" rel="nofollow">http://web.stanford.edu/~sidaw/cgi-bin/home/lib/exe/fetch.php?media=papers:fastdropout.pdf</a></li></ul> 
<h4 id="kripa-chettiar的回答"> <a name="t9"></a><a href="https://www.quora.com/Kripa-Chettiar" rel="nofollow">Kripa Chettiar</a>的回答：</h4> 
<ul><li>增加新数据，可以使用<a href="http://wiki.pentaho.com/display/DATAMINING/SMOTE" rel="nofollow">SMOTE或SMOTEBoost</a>产生人造数据。</li><li>将大类压缩。压缩比例需要具体情况具体分析，取决于你所拥有的数据。例如，A类中有30个样本，B类中有4000个样本，那么你可以将B类压缩成1000（进行采样）。</li><li>可以结合1与2</li><li>对于那种极小类是异常点的分类任务，因此分类器需要学习到大类的决策分界面，即分类器是一个单个类分类器（One Class Classifier）。<a href="http://webcache.googleusercontent.com/search?q=cache:kZcKQQgbGvwJ:www.cs.waikato.ac.nz/~kah18/occ/%20&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us%5D" rel="nofollow">Weka中有相关的库</a>。</li><li>获得更多的数据。</li></ul> 
<h4 id="roar-nybø的回答"> <a name="t10"></a>Roar Nybø的回答：</h4> 
<ul><li>对小类进行过采样。并且使用集成模式会获得更好的效果。</li></ul> 
<h4 id="dan-levin的回答"> <a name="t11"></a><a href="https://www.quora.com/Dan-Levin-2" rel="nofollow">Dan Levin</a>的回答：</h4> 
<ul><li>一个很好的方法去处理非平衡数据问题，并且在理论上证明了。这个方法便是由Robert E. Schapire于1990年在Machine Learning提出的”The strength of weak learnability” ，该方法是一个boosting算法，它递归地训练三个弱学习器，然后将这三个弱学习器结合起形成一个强的学习器。我们可以使用这个算法的第一步去解决数据不平衡问题。 <br>   首先使用原始数据集训练第一个学习器L1。 <br>   然后使用50%在L1学习正确和50%学习错误的的那些样本训练得到学习器L2，即从L1中学习错误的样本集与学习正确的样本集中，循环一边采样一个。 <br>   接着，使用L1与L2不一致的那些样本去训练得到学习器L3。 <br>   最后，使用投票方式作为最后输出。 <br>   那么如何使用该算法来解决类别不平衡问题呢？ <br>   假设是一个二分类问题，大部分的样本都是true类。让L1输出始终为true。使用50%在L1分类正确的与50%分类错误的样本训练得到L2，即从L1中学习错误的样本集与学习正确的样本集中，循环一边采样一个。因此，L2的训练样本是平衡的。L使用L1与L2分类不一致的那些样本训练得到L3，即在L2中分类为false的那些样本。最后，结合这三个分类器，采用投票的方式来决定分类结果，因此只有当L2与L3都分类为false时，最终结果才为false，否则true。 <br>   自己已经在实践中使用过很多次，并且效果都不错。</li></ul> 
<h4 id="kaushik-kasi的回答"> <a name="t12"></a><a href="https://www.quora.com/Kaushik-Kasi" rel="nofollow">Kaushik Kasi</a>的回答：</h4> 
<ul><li>对小类中的样本进行复制以增加该类中的样本数，但是可能会增加bias。</li><li>对小类中的样本通过调整特征值来人工生成样本，而使得该类中样本个数增多。如在图像中，对一幅图像进行扭曲得到另一幅图像，即改变了原图像的某些特征值。但是该方法可能会产生现实中并存在的样本。</li></ul> 
<h4 id="quora-user的回答"> <a name="t13"></a>Quora User的回答：</h4> 
<ul><li>简单快速的方法：对大类欠采样或者对小类过采样。</li><li>更有效的方法：使用代价函数学习得到每个类的权值，大类的权值小，小类的权值大。刚开始，可以设置每个类别的权值与样本个数比例的倒数，然后可以使用过采样进行调优。</li></ul> 
<h4 id="dayvid-victor的回答"> <a name="t14"></a>Dayvid Victor的回答：</h4> 
<p>  在类别不平衡中，以下几个点需要注意：</p> 
<ul><li>常规的分类评价指标可能会失效，比如将所有的样本都分类成大类，那么准确率、精确率等都会很高。这种情况下，AUC时最好的评价指标。</li><li>你能够使用原型选择技术去降低不平衡水平。选择那些重要的样本。One-Sided Selection (OSS) 是一个预处理技术（模型训练之前使用），能够处理类别不平衡问题。</li><li>从另一个角度，可以增加小类的样本个数，可以使用过采样与原型生成技术（prototype-generation techniques）。</li><li>在K-Fold 校验中，每一份数据集中原则上应该保持类别样本比例一样或者近似，如果每份数据集中小类样本数目过少，那么应该降低K的值，知道小类样本的个数足够。 <br>   一般来说，如果事前不对不平衡问题进行处理，那么对于小类别的样本则会错误率很高，即大部分甚至全部小类样本都会分错。</li></ul> 
<h4 id="muktabh-mayank的回答"> <a name="t15"></a><a href="https://www.quora.com/Muktabh-Mayank" rel="nofollow">Muktabh Mayank</a>的回答：</h4> 
<ul><li>这里有一个类似SVM的方法来处理不平衡问题。<a href="https://hal.inria.fr/hal-01087452/document" rel="nofollow">具体参见这里</a>。</li></ul> 
<h4 id="sandeep-subramanian的回答"> <a name="t16"></a><a href="https://www.quora.com/Sandeep-Subramanian" rel="nofollow">Sandeep Subramanian</a>的回答：</h4> 
<ul><li>使用<a href="http://arxiv.org/pdf/1106.1813.pdf" rel="nofollow">SMOTE（Synthetic Minority Oversampling TEchnique）</a>方法人工生成小类数据。其类似于最近邻算法。</li></ul> 
<h4 id="quora-user的回答-1"> <a name="t17"></a>Quora User的回答：</h4> 
<ul><li>赋予小类样本更高的训练权值</li><li>对小类进行过采样</li><li>某些时候，高不平衡性下仍然可以得到效果较好的训练结果。我认为对于某些评价指标是有意义的，如AUC。</li></ul> 
<h4 id="sumit-soman-的回答"> <a name="t18"></a><a href="https://www.quora.com/Sumit-Soman-1" rel="nofollow">Sumit Soman</a> 的回答：</h4> 
<ul><li>如果你使用SVM分类器进行分类，那么可以使用Twin SVM（<a href="http://blog.csdn.net/heyongluoyao8/article/details/Twin%20Support%20Vector%20Machines%20for%20Pattern%20Classification">Twin Support Vector Machines for Pattern Classification</a>），其能够应付类别不平衡问题。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c27784e98bdd8ce1fb55f750f016937c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UML-组件图-网上书店</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e215ebcb2e13102fb6b9cd20ff06a43f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Teamviewer检测为商业用途的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>