<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1.Kubernetes(K8S)架构1(Master,Node和Pod) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1.Kubernetes(K8S)架构1(Master,Node和Pod)" />
<meta property="og:description" content="简介: K8S是当前主流的容器编排系统, 服务编排系统要想实现服务的自动化部署和运行离不开容器编排系统. 容器目的是解决服务器的异构问题, 解决了部署的时候无需在考虑底层系统环境是否能够满足服务的需要. 但是单独的容器并没有生产的价值, 因为他只是提供了底层应用的托管程序, 并没有处理多个容器容器投入生产的问题, 而容器的编排则是处理多个容器投入生产的痛点问题
容器编排系统是在大范围,动态环境中管理容器生命周期的工具.
容器编排系统价值
容器的提供和部署容器的冗余和可用性, 容器挂掉有自动恢复机制, 或者故障转移应用规模的自动伸缩, 能依据实例的需求自动实现资源的扩容和释放. 提高资源利用率容器资源紧缺的时候能够在用户 毫无感知的情况下资把容器迁移到其他宿主机的节点容器之间实现资源分配能够实现将容器的服务暴露到外部, 实现在外部进行访问容器的负载均衡, 容器的服务注册和发现宿主机和容器的健康状态检测将应用之间的关系配置到容器 K8S是当前最主流的容器编排系统没有之一. (docker swarm被安在地上摩擦). K8S 是Google使用 Go语言按照自己十分成熟的容器编排系统 Borg 的思维重新做了一遍. 最后 K8S 是一个能够实现自动部署,伸缩并且实现应用容器跨主机集群和提供容器基础设施的开源平台
K8S架构 Master和Node K8S中主机(可以是物理机或者虚拟机)主要分为两种 Master和Node
Node 是运行具体容器的主机,负责提供后具体的服务,并且本身具有自我修复能力 --Data Plane 数据平面Master 负责管理Node, 控制Node 具体运行什么容器, 同时还承担外部数据访问的角色-- Control Plane 控制层面 Master和Node都有冗余但是冗余的, 但是目的不同
在容器集群运行中正在运行的Master(ETCD除外, 是一个强一致的分布式存储) 只能有一个,因为只能由一个Master去指挥它下面的多个Node, 所以Master的 冗余用于做灾备, 当Master挂掉, 会有另一个冗余的Master启用,替代原来的Master工作,所以生产环境应该有3个以上Master
集群中的Node的冗余是用于做负载均衡的, 多个Node需要同时工作负责不同的模块和任务, 其中某个Node万一挂掉, 这个Node的任务被分配到其他Node再次运行起来
K8S主体架构 用户可以通过 API接口. UI界面和命令行来访问k8S 的Master, 之后Master依据接収的请求对Node上面的容器做新增,更新或者删除的操作, 同时容器的镜像又依赖于镜像仓库, 需要从镜像仓库拉取所需的镜像, 同时需要将自定义的镜像保存到镜像仓库供容器来使用, 镜像仓库可以考虑 Docker Hub或者搭建私有仓库, 由于Docker Hub 需要公网链接, 所以一般建议搭建私有仓库" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/0e090d84264c5bebdc1608c2f64e759a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-17T10:28:28+08:00" />
<meta property="article:modified_time" content="2022-10-17T10:28:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1.Kubernetes(K8S)架构1(Master,Node和Pod)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>简介:</h3> 
<p>K8S是当前主流的容器编排系统, 服务编排系统要想实现服务的自动化部署和运行离不开容器编排系统. </p> 
<p> 容器目的是解决服务器的异构问题, 解决了部署的时候无需在考虑底层系统环境是否能够满足服务的需要.  但是单独的容器并没有生产的价值, 因为他只是提供了底层应用的托管程序, 并没有处理多个容器容器投入生产的问题,  而容器的编排则是处理多个容器投入生产的痛点问题</p> 
<p>容器编排系统是在大范围,动态环境中管理容器生命周期的工具.</p> 
<p>容器编排系统价值</p> 
<ol><li>容器的提供和部署</li><li>容器的冗余和可用性, 容器挂掉有自动恢复机制, 或者故障转移</li><li>应用规模的自动伸缩, 能依据实例的需求自动实现资源的扩容和释放. 提高资源利用率</li><li>容器资源紧缺的时候能够在用户 毫无感知的情况下资把容器迁移到其他宿主机的节点</li><li>容器之间实现资源分配</li><li>能够实现将容器的服务暴露到外部, 实现在外部进行访问</li><li>容器的负载均衡, 容器的服务注册和发现</li><li>宿主机和容器的健康状态检测</li><li>将应用之间的关系配置到容器</li></ol> 
<p> K8S是当前最主流的容器编排系统没有之一. (docker  swarm被安在地上摩擦).  K8S 是Google使用 Go语言按照自己十分成熟的容器编排系统 Borg 的思维重新做了一遍. </p> 
<p>最后 K8S 是一个能够实现自动部署,伸缩并且实现应用容器跨主机集群和提供容器基础设施的开源平台</p> 
<h3>K8S架构</h3> 
<h4>Master和Node </h4> 
<p>K8S中主机(可以是物理机或者虚拟机)主要分为两种 Master和Node</p> 
<ul><li>Node 是运行具体容器的主机,负责提供后具体的服务,并且本身具有自我修复能力  --Data Plane 数据平面</li><li>Master 负责管理Node, 控制Node 具体运行什么容器, 同时还承担外部数据访问的角色-- Control Plane 控制层面</li></ul> 
<p>Master和Node都有冗余但是冗余的, 但是目的不同</p> 
<p><img alt="" class="has" height="177" src="https://images2.imgbox.com/fa/50/TYQbtMik_o.png" width="520"></p> 
<p>在容器集群运行中正在运行的Master(ETCD除外, 是一个强一致的分布式存储) 只能有一个,因为只能由一个Master去指挥它下面的多个Node, 所以Master的 冗余用于做灾备, 当Master挂掉, 会有另一个冗余的Master启用,替代原来的Master工作,所以生产环境应该有3个以上Master</p> 
<p>集群中的Node的冗余是用于做负载均衡的, 多个Node需要同时工作负责不同的模块和任务, 其中某个Node万一挂掉, 这个Node的任务被分配到其他Node再次运行起来</p> 
<h4>K8S主体架构</h4> 
<h4><img alt="" class="has" height="367" src="https://images2.imgbox.com/aa/bd/uFGMLXhQ_o.png" width="874"></h4> 
<p>用户可以通过 API接口. UI界面和命令行来访问k8S 的Master, 之后Master依据接収的请求对Node上面的容器做新增,更新或者删除的操作, 同时容器的镜像又依赖于镜像仓库, 需要从镜像仓库拉取所需的镜像, 同时需要将自定义的镜像保存到镜像仓库供容器来使用, 镜像仓库可以考虑 Docker Hub或者搭建私有仓库, 由于Docker Hub 需要公网链接, 所以一般建议搭建私有仓库</p> 
<h4>Master详解.</h4> 
<p>Master节点是集群的控制节点,负责整个集群的管理和控制, 基本上所有的控制指令都是发给Master的, 并且他来负责调度Node来具体执行命令, 通常生产环境Master都是部署在单独的服务器, 建议使用3台以上的奇数服务器做冗余, 因为'首脑' 宕机整个集群都会崩溃. </p> 
<p><img alt="" class="has" height="349" src="https://images2.imgbox.com/be/57/Fd3ednA0_o.png" width="791"></p> 
<p>Mater由四个逻辑组件组成, 他们分别由四个独立的守护线程, API Server, Scheduler和Controller是K8S自己做的,etcd则是使用 Core OS的成果</p> 
<ul><li>etcd:用户保存应用程序配置信息的守护进程,是一个k-v存储系统,存储内容为用用户发出的API请求中容器的具体要求, 是一个强一致性的</li><li>API Server: 是K8S开放给用户的唯一入口,接受用户的指令.同时对指令进行规范检查, 将合乎规范的话将其放入etcd中</li><li>Scheduler:是作为调度器 .负责的内容是寻找要部署的容器的最佳Node. 主从模式, 只能有一个正在执行的服务</li><li>Controller: 是作为控制器, K8S提供的API是声明式API. 要运行一个redis容器, 只需要声明要运行一个redis容器即可, 具体的镜像来源以及挂掉后重启等等都有控制器完成. 控制器负责用户指令的具体运行以及保证资源运行一直符合用户的需求, 作为Master的大脑. 也只能有一个正在执行的服务 
  <ul><li>Controller Loop 使用轮询的方式保证每个容器的运行正常, 当某个资源不可用, 会尝试重启, 要是还不行,会尝试初始化资源,比如尝试把容器铲掉,拉取镜像重启运行</li></ul></li></ul> 
<p>各个组件关系如下</p> 
<p><img alt="" class="has" height="218" src="https://images2.imgbox.com/b2/c1/2gU1rUbe_o.png" width="461"></p> 
<p>用户发起一个对容器的操作请求, API Server接受到之后会首先对用户发送的指令进行验证, 没有问题后会把指令存储到etcd. 同时Scheduler和Controller分别监听API Server请求验证成功后如果是新建容器,  Scheduler会寻找最合适的Node用于运行容器,  而Controller通过监听获得指令之后会去完成指令的要求, 完成后会以轮询的方式校验资源(主要是容器)的状态和存储来etcd里面的指令要求的是否一致. 不一致的话进行重新部署资源(重启或者重新运行镜像)</p> 
<h4>Node</h4> 
<p>Node节点是作为K8S中的工作负载节点, Node节点接収Master节点分配的一些任务.同时当前Node节点</p> 
<p>Node的关键组件</p> 
<p>kubelet: 负责对pod(POD是一组  )对应容器的创建,启停等一系列的任务, kubelet时刻watch着Mater中的API Server中的资源变动, 当有和自己相关的任务的时候就会调用Docker执行具体的任务</p> 
<p>kube-proxy: 用于实现 K8S Service(需要提供的服务) 的通信和负载均衡</p> 
<p>Docker Engin: docker引擎, 负责Node于和容器有关的操作, K8S原生支持Docker作为容器引擎, 如果要使用其他容器引擎则需要使用对应接口集成</p> 
<p>Pod : K8S不是直接运行的容器,而是操作Pod, 把Pod作为原子单元管理,一个Pod里面可能会运行多个容器,  Pod里面运行的多个容器被捆绑在一起被统一调度不可分割. 一个Pod的所有容器只能同时运行在一个Node 上</p> 
<p>结构图如下</p> 
<p><img alt="" height="653" src="https://images2.imgbox.com/ce/e4/eR9zostO_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<p>当用户发起一个创建Pod的请求,首先Pod的信息会被存储到 etcd, 随后Master调度器会分析最适合运行这个Pod的Node, 并将信息存储到etcd, 这个时候这个Node的kubelet在Master的API Server 上面 watch到自己有事干了, 就会调用docker引擎把这一组相关的容器启动起来.</p> 
<p>这个时候Pod就运行起来了.</p> 
<p>除此之外Node还会向Master汇报Pod的运行状况, Master中的控制器汇报运行状况和 etcd中存储的Pod的信息对比, 看看是不是期望的运行状况, 不是的话重启Pod的容器, 重启不行就拉群镜像重启运行.</p> 
<p>在Node宕机的时候, Master还会吧这个Node上面的所有Pod通过执行调度器重新寻找适合运行的Node, 重启运行 Pod所包含的容器. </p> 
<h4>Pod</h4> 
<p>Pod是K8S里面操作容器的基本单元,是被K8S统一调度的,  Pod一般是一组联系紧密的容器.</p> 
<p>Pod都有一个特殊的Pause容器用于代表真个Pod的状态, Paus容器的镜像是来源于K8s的平台</p> 
<p>结构如下</p> 
<p>  <img alt="" class="has" height="306" src="https://images2.imgbox.com/f9/0c/jD4u17NQ_o.png" width="247"></p> 
<p>Pod主要要解决的问题有两个, 通常情况下一组容器的关联比较紧密, 可以看做一个在整体, 但是在管理上就出现了麻烦, 这一组业务容器无法进行统一的管理, 比如要求统一的运行启动部署, 引入Pod概念直接对Pod这组容器进行操作就更加简单,    还有运行状态的判断, 在这一组容器的运行的时候, 没有Pod就不能很好的判断整体的运行状态(一个容器挂掉算挂掉还是所有挂掉算挂掉,还是按比例), 引入Pod后, 用Pod的Pause容器状态代表整个Pod的状态, 当Pod挂掉, 重启pod包含的所有容器. </p> 
<p>Pod运行的容器通常联系比较傲紧密, Pod的多个容器可以共享Pod中Pause容器的IP还有Pause容器挂载的 Volume, 这样就简化和业务容器之间的配置. 很简单的解决了容器的通信和文件共享文件问题.</p> 
<p>同时K8S为每个Pod分配了了指定的唯一IP, 称为 Pod IP, Pod里面的容器共享这这个IP. 至于多个Pod之间跨主机的通信就要借助于虚拟二层网络, 例如Open vSwitch等等. 类似于docker使用Open vSwitch跨主机通信.</p> 
<p>更多概念：</p> 
<p><a href="https://blog.csdn.net/qq_21047625/article/details/90416010" title="2.Kubernetes(K8S)架构2--Service,NameSpace,Volume等对象_水淹萌龙的博客-CSDN博客">2.Kubernetes(K8S)架构2--Service,NameSpace,Volume等对象_水淹萌龙的博客-CSDN博客</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d3871b3bda7758551992cf20e18cbfb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用SOLIDWORKS方程式绘制渐开线齿轮</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7dbe70f7c493bca70fe35b9cfb795dac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面试——手撕代码——二分查找——c&#43;&#43;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>