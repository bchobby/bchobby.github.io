<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>集群部署篇--Redis 哨兵模式 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="集群部署篇--Redis 哨兵模式" />
<meta property="og:description" content="文章目录 前言一、哨兵模式介绍：1.1 介绍：1.2 工作机制： 二、哨兵模式搭建：2. 1 redis 主从搭建：2.2 setinel 集群搭建：2.2.1 配置： sentinel.conf ：2.2.2 运行容器：2.2.3 查看容器的信息：2.2.4 故障自动转移：2.2.5 slave 晋升maser：2.2.6 原主节点重新启动： 总结：参考： 前言 虽然有了Reids 的主从模式，但是我们发现它的故障转移能力非常弱，所以在主从模式的基础之上有衍生出了哨兵模式。
一、哨兵模式介绍： 1.1 介绍： 基于主从方案的缺点还是很明显的，假设 Master 宕机，那么就不能写入数据，那么 Slave 也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。
而哨兵（sentinel）的功能比单纯的主从架构全面的多了，哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它独立运行。其原理是哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。因此哨兵模式具备了自动故障转移、集群监控、消息通知等功能。
1.2 工作机制： 哨兵可以同时监视多个主从服务器，并且在被监视的 Master 下线时，自动将某个 Slave 提升为 Master，然后由新的 Master 继续接收命令。整个过程如下：
初始化 sentinel，将普通的 redis 代码替换成 sentinel 专用代码初始化 Masters 字典和服务器信息，服务器信息主要保存 ip:port，并记录实例的地址和 ID创建和 Master 的两个连接，命令连接和订阅连接，并且订阅 sentinel:hello 频道每隔 10 秒向 Master 发送 info 命令，获取 Master 和它下面所有 Slave 的当前信息" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/126391803eba2d404791fa8282a8bba1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T16:55:29+08:00" />
<meta property="article:modified_time" content="2023-12-29T16:55:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">集群部署篇--Redis 哨兵模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">前言</a></li><li><a href="#_12" rel="nofollow">一、哨兵模式介绍：</a></li><li><ul><li><a href="#11__13" rel="nofollow">1.1 介绍：</a></li><li><a href="#12__20" rel="nofollow">1.2 工作机制：</a></li></ul> 
  </li><li><a href="#_35" rel="nofollow">二、哨兵模式搭建：</a></li><li><ul><li><a href="#2_1_redis__38" rel="nofollow">2. 1 redis 主从搭建：</a></li><li><a href="#22_setinel__41" rel="nofollow">2.2 setinel 集群搭建：</a></li><li><ul><li><a href="#221___sentinelconf__43" rel="nofollow">2.2.1 配置： sentinel.conf ：</a></li><li><a href="#222__144" rel="nofollow">2.2.2 运行容器：</a></li><li><a href="#223__157" rel="nofollow">2.2.3 查看容器的信息：</a></li><li><a href="#224__165" rel="nofollow">2.2.4 故障自动转移：</a></li><li><a href="#225_slave_maser_170" rel="nofollow">2.2.5 slave 晋升maser：</a></li><li><a href="#226__189" rel="nofollow">2.2.6 原主节点重新启动：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_201" rel="nofollow">总结：</a></li><li><a href="#_204" rel="nofollow">参考：</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>前言</h2> 
<p>虽然有了Reids 的主从模式，但是我们发现它的故障转移能力非常弱，所以在主从模式的基础之上有衍生出了哨兵模式。</p> 
<hr> 
<h2><a id="_12"></a>一、哨兵模式介绍：</h2> 
<h3><a id="11__13"></a>1.1 介绍：</h3> 
<p>基于主从方案的缺点还是很明显的，假设 Master 宕机，那么就不能写入数据，那么 Slave 也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。</p> 
<p>而哨兵（sentinel）的功能比单纯的主从架构全面的多了，哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它独立运行。其原理是哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。因此哨兵模式具备了自动故障转移、集群监控、消息通知等功能。</p> 
<p><img src="https://images2.imgbox.com/10/05/1IGA0WCr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12__20"></a>1.2 工作机制：</h3> 
<p>哨兵可以同时监视多个主从服务器，并且在被监视的 Master 下线时，自动将某个 Slave 提升为 Master，然后由新的 Master 继续接收命令。整个过程如下：</p> 
<ul><li>初始化 sentinel，将普通的 redis 代码替换成 sentinel 专用代码</li><li>初始化 Masters 字典和服务器信息，服务器信息主要保存 ip:port，并记录实例的地址和 ID</li><li>创建和 Master 的两个连接，命令连接和订阅连接，并且订阅 sentinel:hello 频道</li><li>每隔 10 秒向 Master 发送 info 命令，获取 Master 和它下面所有 Slave 的当前信息<br> 当发现 Master 有新的 Slave 之后，sentinel 和新的 Slave同样建立两个连接，同时每个10秒发送 info 命令，更新 Master 信息</li><li>sentinel 每隔1秒向所有服务器发送 ping 命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态</li><li>选举出领头 sentinel，领头 sentinel 需要半数以上的 sentinel 同意<br> 领 头sentinel 从已下线的的 Master 所有 Slave 中挑选一个，将其转换为 Master</li><li>让所有的 Slave 改为从新的 Master 复制数据</li><li>将原来的 Master 设置为新的 Master 的从服务器，当原来 Master 重新回复连接时，就变成了新 Master 的从服务器</li><li>其中，sentinel 会每隔 1 秒向所有实例（包括主从服务器和其他sentinel）发送 ping 命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的 sentinel 询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。</li></ul> 
<h2><a id="_35"></a>二、哨兵模式搭建：</h2> 
<p>哨兵模式依赖于redis 的主从模式，是在主从模式的基础之上，在部署setinel 集群服务 对所有的redis 节点进行监控（包括主节点和从节点）</p> 
<h3><a id="2_1_redis__38"></a>2. 1 redis 主从搭建：</h3> 
<p>搭建过程可以参考：<a href="https://blog.csdn.net/l123lgx/article/details/135275548">集群部署篇–Redis 主从模式</a></p> 
<h3><a id="22_setinel__41"></a>2.2 setinel 集群搭建：</h3> 
<p>Sentinel是Redis的一部分，因此它包含在标准的Redis镜像中，所有安装时只需要用到 redis 镜像；</p> 
<h4><a id="221___sentinelconf__43"></a>2.2.1 配置： sentinel.conf ：</h4> 
<pre><code class="prism language-conf"># mymaster：自定义集群名，2:投票数量必须2个sentinel才能判断主节点是否失败
sentinel monitor mymaster 192.168.75.128 6379 1
# 指的是超过5000秒，且没有回复，则判定主节点不可达
sentinel down-after-milliseconds mymaster 5000
# 故障转移超时时间
sentinel failover-timeout mymaster 60000
# 表示在故障转移的时候最多有numslaves在同步更新新的master
sentinel parallel-syncs mymaster 1
# sentinel  连接redis 的密码
sentinel auth-pass mymaster 123456
</code></pre> 
<p>参数解释：<br> 1.1 ）sentinel monitor<br> 在Redis Sentinel配置中，<code>sentinel monitor</code>是一个非常重要的指令。它用于定义哨兵要监控的Redis主服务器(master)。这个指令会让哨兵知道主服务器的IP地址、端口以及对该主服务器进行标识的名称，并且指定了启动故障迁移的最少投票数。</p> 
<p><code>sentinel monitor</code>指令的语法如下：</p> 
<pre><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
</code></pre> 
<p>其中：</p> 
<ul><li><code>&lt;master-name&gt;</code>: 是一个自定义名称，用于哨兵之间识别和标识主服务器的逻辑名字。</li><li><code>&lt;ip&gt;</code>: 主服务器的IP地址。</li><li><code>&lt;port&gt;</code>: 主服务器监听的端口。</li><li><code>&lt;quorum&gt;</code>: 最小投票数，它是哨兵在认为主服务器已经不可达并启动自动故障迁移之前需要达到的最小哨兵同意数。例如，如果设置为2，则至少需要两个哨兵同意主服务器无法访问。</li></ul> 
<p>这里有一个具体的示例配置：</p> 
<pre><code>sentinel monitor mymaster 127.0.0.1 6379 2
</code></pre> 
<p>在这个例子中，哨兵将监控运行在<code>127.0.0.1</code>（本地）和<code>6379</code>端口上的Redis服务器，该服务器被命名为<code>mymaster</code>。如果有至少两个哨兵认为<code>mymaster</code>不可达，那么哨兵集群将开始故障迁移的过程。</p> 
<p>在部署Sentinel时，通常会充分分散Sentinel节点，并且部署数量要多于你设置的<code>&lt;quorum&gt;</code>值，以形成一个健壮的监控系统，并避免任何两个Sentinel之间的网络分区问题导致错误的故障迁移。</p> 
<p>要确保哨兵配置生效，需要在每个哨兵实例上设置相同的<code>sentinel monitor</code>配置。这样，每个哨兵都会监控同一个主服务器，并能共同决策是否需要进行故障迁移。</p> 
<p>1.2） sentinel parallel-syncs<br> <code>sentinel parallel-syncs</code> 参数在 Redis Sentinel 配置文件 <code>sentinel.conf</code> 中用于控制在故障转移过程中可以同时与新的主服务器（promoted master）进行同步的从服务器（slaves）的数量。</p> 
<p>当主服务器发生故障而 Sentinel 进行故障转移时，会有一个从服务器被提升为新的主服务器。其他的从服务器需要更新他们的配置以开始从新的主服务器复制数据。由于这个同步操作可能会比较耗时，<code>parallel-syncs</code> 设置决定了有多少个从服务器可以并行地开始同步过程。</p> 
<p>配置项的语法如下：</p> 
<pre><code>sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;
</code></pre> 
<p>其中：</p> 
<ul><li><code>&lt;master-name&gt;</code> 是哨兵配置中用于标识被监控的主服务器逻辑名称。</li><li><code>&lt;numslaves&gt;</code> 是允许与新的主服务器同时进行同步的从服务器的最大数量。</li></ul> 
<p>举个例子：</p> 
<pre><code>sentinel parallel-syncs mymaster 1
</code></pre> 
<p>在这个配置中，名为 <code>mymaster</code> 的主服务器在故障转移过程中，只允许一个从服务器与新的主服务器并行进行同步。如果有多个从服务器，它们将会依次同步，直到所有从服务器完成同步。如果你设置的数值更高，如 <code>2</code> 或 <code>3</code>，则两个或三个从服务器会被允许并行同步。</p> 
<p>选择合适的 <code>parallel-syncs</code> 值需要权衡网络带宽、服务器性能和想要多快地恢复整个 Redis 系统的冗余性。如果你的系统可以同时处理多个从服务器进行同步所需的负载，则可以通过提高 <code>parallel-syncs</code> 的值来加快同步过程，反之亦然。如果设置过高，可能会给新的主服务器带来过多的同步负载，影响其性能。</p> 
<p>1.3） sentinel failover-timeout<br> <code>sentinel failover-timeout</code> 是 Redis Sentinel 配置中控制故障转移超时的参数。这个配置项指定了哨兵在认定主服务器为失效状态、开始执行故障转移操作到操作完成所允许的最长时间。如果在超时时间内故障转移没有完成，哨兵将会取消当前的故障转移操作。</p> 
<p>配置项的语法如下：</p> 
<pre><code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;
</code></pre> 
<p>其中：</p> 
<ul><li><code>&lt;master-name&gt;</code>：是哨兵配置中用于标识被监控的主服务器的逻辑名称。</li><li><code>&lt;milliseconds&gt;</code>：表示故障转移操作的超时时间，以毫秒为单位。</li></ul> 
<p>举例来说：</p> 
<pre><code>sentinel failover-timeout mymaster 30000
</code></pre> 
<p>在上面这个例子中，对于名为 <code>mymaster</code> 的主服务器，哨兵设置了故障转移的超时时间为 30,000 毫秒（即 30 秒）。如果从检测到主服务器失效到完成故障转移（包括从服务器与新的主服务器之间的同步）的时间超过了30秒，哨兵将会放弃这次故障转移操作。</p> 
<p>设置合理的 <code>failover-timeout</code> 值很重要，因为：</p> 
<ul><li>设定值太低可能导致在正常网络延迟或负载较高的情况下故障转移不能成功完成；</li><li>设定值太高会导致系统在主服务器失效时需要更长的时间来恢复。</li></ul> 
<p>默认情况下，Redis Sentinel 的 <code>failover-timeout</code> 设置可能是几分钟。这个值应该根据你的网络环境和主从服务器的同步时间来调整。需要注意的是，故障转移时间也会受到 <code>parallel-syncs</code> 配置的影响，因为它决定了从服务器同步数据的并行度。</p> 
<h4><a id="222__144"></a>2.2.2 运行容器：</h4> 
<pre><code class="prism language-sh"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
<span class="token parameter variable">--name</span> myrsentinel <span class="token punctuation">\</span>
<span class="token parameter variable">-p</span> <span class="token number">26379</span>:26379 <span class="token punctuation">\</span>
<span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /root/redis-sentinel/conf/sentinel.conf:/etc/sentinelRedis/sentinel.conf  <span class="token punctuation">\</span>
redis <span class="token punctuation">\</span>
redis-sentinel /etc/sentinelRedis/sentinel.conf 
</code></pre> 
<p>重复以上步骤可以安装多个 sentinel ，多个sentinel 的集群名称相同，并且都连接到同一个 主库master ，他们之间会互相发现组成集群；</p> 
<h4><a id="223__157"></a>2.2.3 查看容器的信息：</h4> 
<p>连接容器</p> 
<pre><code class="prism language-sh"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myrsentinel redis-cli <span class="token parameter variable">-p</span> <span class="token number">26379</span>
</code></pre> 
<p>通过 sentinel master mymaster 命令查看sentinel集群情况<br> <img src="https://images2.imgbox.com/67/d0/E2MJEzVi_o.png" alt="在这里插入图片描述"><br> 可以看到 redis 的主库信息；已经 num-slaves 有2个从库 redis； num-other-sentinels：可以看到集群中共有2个sentinel 实例；</p> 
<h4><a id="224__165"></a>2.2.4 故障自动转移：</h4> 
<p>如果停掉redis 的主库，sentinel 会从slaver的redis 从库中选举出来一个主库，之前的主库会变成从库；<br> <img src="https://images2.imgbox.com/91/25/ZLWqy9fn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="225_slave_maser_170"></a>2.2.5 slave 晋升maser：</h4> 
<p>1）哨兵的选举：<br> 当确定redis服务器确实挂了以后，哨兵要进行故障转移，并且只能有一个哨兵去完成该操作，所以这时候就要选举出一名哨兵来当此重任。<br> 每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发is-master-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；</p> 
<p>当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；</p> 
<p>如果哨兵3发现自己在选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举…………</p> 
<p>2）slave 的晋升：<br> 如果master被判下线了，大部分哨兵允许主备切换，那么需要选举一个slave，依次考虑如下：</p> 
<ul><li> <p>看slave-priority：选择slave优先级最高的；</p> </li><li> <p>看offset：选择复制offset（偏移量）最大的，指复制最完整的从节点</p> </li><li> <p>看runid：程序id，就选runid最小的，越早开启的</p> </li></ul> 
<h4><a id="226__189"></a>2.2.6 原主节点重新启动：</h4> 
<p>因集群中已有了新主节点，所以在次启动，需要在配置文件中加入主节点信息，然后启动redis：</p> 
<pre><code class="prism language-conf"># 设置 主库ip 端口
slaveof 192.168.75.129 6379
# 设置从库访问主库 密码
masterauth 123456
</code></pre> 
<hr> 
<h2><a id="_201"></a>总结：</h2> 
<p>哨兵模式是在redis 主从复制基础上，通过部署sentinel 服务来对整个redis 的主节点和从节点进行监控，当发现主节点下线，则选举出一个sentinel 然后 对监控下的所有slave 节点选举出来一个slave 将其晋升为新的master。</p> 
<h2><a id="_204"></a>参考：</h2> 
<p>1 <a href="https://www.xjx100.cn/news/5211.html?action=onClick" rel="nofollow">Redis系列：Redis主从、哨兵、集群介绍；</a><br> 2 <a href="https://www.jianshu.com/p/df349be03eb0" rel="nofollow">Redis — 三种模式：主从、哨兵、集群</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d2d18cb2ef135a0f65747f8eff45240/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">集群部署篇--Redis 主从模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a43bc68ead17728ca36ba3daae4091d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flink实时电商数仓（九）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>