<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32 ---- 再次学习STM32F103C8T6/STM32F409IGT6 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32 ---- 再次学习STM32F103C8T6/STM32F409IGT6" />
<meta property="og:description" content="目录
一、环境搭建及介绍
关于STM32基础介绍
新建工程
外设案例
LED流水灯
蜂鸣器
上拉电阻和下拉电阻知识
电压比较器
c语言基础知识 类型、结构体、枚举
类型int8_t int16_t int32_t
宏替换 #define 和typedef用法 结构体两种填充方法 和 命名规则
枚举用法
常用配置
输入输出模式
GPIO常用库函数
中断函数
模块化编程 延时函数 System
LED函数 Hardwore
按键函数 Hardwore
蜂鸣器函数 Hardwore
震动模块 Hardwore
OLED IIC模块Hardwore
调试方法
中断系统
概念：
NVIC中断控制寄存器结构 NVIC分组 抢占优先级和响应优先级​编辑
中断配置 --代码-----------------
两个中断时
定时器
定时器类型
定时器时基----基本定时器
通用定时器时钟输入
​编辑 高级定时器​编辑
代码部分-----------------------------
定时器 ---- PWM
PWM控制呼吸灯 ----------------
PWM控制SG90舵机----------------
PWM驱动电机模块
输入捕获测频率
输入捕获测占空比
输入捕获编码器计数
一、环境搭建及介绍 kile4 开发51单片机（内置芯片包）、kile_v5开发STM32手动添加芯片包、如果要开发51许把51的芯片包放在kile5中 、通过注册机key来破解
对应STM芯片包" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/13c25f4312458c475569f9d2d008f019/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-15T21:25:18+08:00" />
<meta property="article:modified_time" content="2023-10-15T21:25:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32 ---- 再次学习STM32F103C8T6/STM32F409IGT6</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BB%8B%E7%BB%8D" rel="nofollow">一、环境搭建及介绍</a></p> 
<p id="%E5%85%B3%E4%BA%8ESTM32%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E5%85%B3%E4%BA%8ESTM32%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D" rel="nofollow">关于STM32基础介绍</a></p> 
<p id="%C2%A0%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B" rel="nofollow"> 新建工程</a></p> 
<p id="%E5%A4%96%E8%AE%BE%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E5%A4%96%E8%AE%BE%E6%A1%88%E4%BE%8B" rel="nofollow">外设案例</a></p> 
<p id="LED%E6%B5%81%E6%B0%B4%E7%81%AF-toc" style="margin-left:80px;"><a href="#LED%E6%B5%81%E6%B0%B4%E7%81%AF" rel="nofollow">LED流水灯</a></p> 
<p id="%E8%9C%82%E9%B8%A3%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E8%9C%82%E9%B8%A3%E5%99%A8" rel="nofollow">蜂鸣器</a></p> 
<p id="%C2%A0%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E5%92%8C%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E7%9F%A5%E8%AF%86-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E5%92%8C%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E7%9F%A5%E8%AF%86" rel="nofollow"> 上拉电阻和下拉电阻知识</a></p> 
<p id="%E7%94%B5%E5%8E%8B%E6%AF%94%E8%BE%83%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E7%94%B5%E5%8E%8B%E6%AF%94%E8%BE%83%E5%99%A8" rel="nofollow">电压比较器</a></p> 
<p id="%C2%A0c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20%E7%B1%BB%E5%9E%8B%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE-toc" style="margin-left:80px;"><a href="#%C2%A0c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20%E7%B1%BB%E5%9E%8B%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE" rel="nofollow"> c语言基础知识 类型、结构体、枚举</a></p> 
<p id="%E7%B1%BB%E5%9E%8Bint8_t%20int16_t%20int32_t-toc" style="margin-left:120px;"><a href="#%E7%B1%BB%E5%9E%8Bint8_t%20int16_t%20int32_t" rel="nofollow">类型int8_t int16_t int32_t</a></p> 
<p id="%C2%A0%E5%AE%8F%E6%9B%BF%E6%8D%A2%20%23define%20%E5%92%8Ctypedef%E7%94%A8%E6%B3%95%C2%A0%20%C2%A0-toc" style="margin-left:120px;"><a href="#%C2%A0%E5%AE%8F%E6%9B%BF%E6%8D%A2%20%23define%20%E5%92%8Ctypedef%E7%94%A8%E6%B3%95%C2%A0%20%C2%A0" rel="nofollow"> 宏替换 #define 和typedef用法   </a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%A4%E7%A7%8D%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95%20%E5%92%8C%20%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99-toc" style="margin-left:120px;"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%A4%E7%A7%8D%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95%20%E5%92%8C%20%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99" rel="nofollow">结构体两种填充方法 和 命名规则</a></p> 
<p id="%E6%9E%9A%E4%B8%BE%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><a href="#%E6%9E%9A%E4%B8%BE%E7%94%A8%E6%B3%95" rel="nofollow">枚举用法</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE" rel="nofollow">常用配置</a></p> 
<p id="%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F" rel="nofollow">输入输出模式</a></p> 
<p id="GPIO%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#GPIO%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0" rel="nofollow">GPIO常用库函数</a></p> 
<p id="%C2%A0%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0" rel="nofollow"> 中断函数</a></p> 
<p id="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%C2%A0" rel="nofollow">模块化编程 </a></p> 
<p id="%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%C2%A0%20System-toc" style="margin-left:80px;"><a href="#%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%C2%A0%20System" rel="nofollow">延时函数  System</a></p> 
<p id="%C2%A0LED%E5%87%BD%E6%95%B0%C2%A0%20Hardwore-toc" style="margin-left:80px;"><a href="#%C2%A0LED%E5%87%BD%E6%95%B0%C2%A0%20Hardwore" rel="nofollow"> LED函数  Hardwore</a></p> 
<p id="%C2%A0%C2%A0%E6%8C%89%E9%94%AE%E5%87%BD%E6%95%B0%C2%A0%20Hardwore-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%E6%8C%89%E9%94%AE%E5%87%BD%E6%95%B0%C2%A0%20Hardwore" rel="nofollow">  按键函数  Hardwore</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%E8%9C%82%E9%B8%A3%E5%99%A8%E5%87%BD%E6%95%B0%C2%A0%20Hardwore-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%E8%9C%82%E9%B8%A3%E5%99%A8%E5%87%BD%E6%95%B0%C2%A0%20Hardwore" rel="nofollow">   蜂鸣器函数  Hardwore</a></p> 
<p id="%C2%A0%E9%9C%87%E5%8A%A8%E6%A8%A1%E5%9D%97%C2%A0Hardwore-toc" style="margin-left:80px;"><a href="#%C2%A0%E9%9C%87%E5%8A%A8%E6%A8%A1%E5%9D%97%C2%A0Hardwore" rel="nofollow"> 震动模块 Hardwore</a></p> 
<p id="%C2%A0OLED%20IIC%E6%A8%A1%E5%9D%97Hardwore-toc" style="margin-left:80px;"><a href="#%C2%A0OLED%20IIC%E6%A8%A1%E5%9D%97Hardwore" rel="nofollow"> OLED IIC模块Hardwore</a></p> 
<p id="%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95" rel="nofollow">调试方法</a></p> 
<p id="%C2%A0%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F" rel="nofollow"> 中断系统</a></p> 
<p id="%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">概念：</a></p> 
<p id="NVIC%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%C2%A0-toc" style="margin-left:80px;"><a href="#NVIC%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%C2%A0" rel="nofollow">NVIC中断控制寄存器结构 </a></p> 
<p id="%C2%A0NVIC%E5%88%86%E7%BB%84%20%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%C2%A0NVIC%E5%88%86%E7%BB%84%20%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow"> NVIC分组 抢占优先级和响应优先级​编辑</a></p> 
<p id="%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE%20--%E4%BB%A3%E7%A0%81------------------toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE%20--%E4%BB%A3%E7%A0%81-----------------" rel="nofollow">中断配置 --代码-----------------</a></p> 
<p id="%E4%B8%A4%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%97%B6-toc" style="margin-left:80px;"><a href="#%E4%B8%A4%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%97%B6" rel="nofollow">两个中断时</a></p> 
<p id="%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">定时器</a></p> 
<p id="%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB%E5%9E%8B" rel="nofollow">定时器类型</a></p> 
<p id="%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E5%9F%BA----%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E5%9F%BA----%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">定时器时基----基本定时器</a></p> 
<p id="%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%92%9F%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%92%9F%E8%BE%93%E5%85%A5" rel="nofollow">通用定时器时钟输入</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑 高级定时器​编辑</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86------------------------------toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-----------------------------" rel="nofollow">代码部分-----------------------------</a></p> 
<p id="%E5%AE%9A%E6%97%B6%E5%99%A8%20----%20PWM-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%20----%20PWM" rel="nofollow">定时器 ---- PWM</a></p> 
<p id="PWM%E6%8E%A7%E5%88%B6%E5%91%BC%E5%90%B8%E7%81%AF%20-----------------toc" style="margin-left:80px;"><a href="#PWM%E6%8E%A7%E5%88%B6%E5%91%BC%E5%90%B8%E7%81%AF%20----------------" rel="nofollow">PWM控制呼吸灯 ----------------</a></p> 
<p id="PWM%E6%8E%A7%E5%88%B6SG90%E8%88%B5%E6%9C%BA-----------------toc" style="margin-left:80px;"><a href="#PWM%E6%8E%A7%E5%88%B6SG90%E8%88%B5%E6%9C%BA----------------" rel="nofollow">PWM控制SG90舵机----------------</a></p> 
<p id="PWM%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA%E6%A8%A1%E5%9D%97-toc" style="margin-left:80px;"><a href="#PWM%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA%E6%A8%A1%E5%9D%97" rel="nofollow">PWM驱动电机模块</a></p> 
<p id="%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E9%A2%91%E7%8E%87-toc" style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E9%A2%91%E7%8E%87" rel="nofollow">输入捕获测频率</a></p> 
<p id="%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E5%8D%A0%E7%A9%BA%E6%AF%94-toc" style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E5%8D%A0%E7%A9%BA%E6%AF%94" rel="nofollow">输入捕获测占空比</a></p> 
<p id="%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%95%B0" rel="nofollow">输入捕获编码器计数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4></h4> 
<h3 id="%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BB%8B%E7%BB%8D">一、环境搭建及介绍</h3> 
<p>kile4 开发51单片机（内置芯片包）、kile_v5开发STM32手动添加芯片包、如果要开发51许把51的芯片包放在kile5中 、通过注册机key来破解</p> 
<p>对应STM芯片包</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/7c/07/1yCXszNE_o.png" width="919"></p> 
<p>也可以通过 通过在线安装其它芯片包 ---- 可以找到GD 以及其他厂家的芯片包</p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/67/31/DAVHx5gK_o.png" width="1200"></p> 
<p>STLink驱动 和CH340驱动安装</p> 
<p><img alt="" height="510" src="https://images2.imgbox.com/12/38/ONrM3g0n_o.png" width="1200"></p> 
<p> 管理员运行kile5 复制CLD到注册机 破解</p> 
<h3 id="%E5%85%B3%E4%BA%8ESTM32%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D">关于STM32基础介绍</h3> 
<h4></h4> 
<p>片上资源<img alt="" height="692" src="https://images2.imgbox.com/07/d1/pb8ZcfoU_o.png" width="1200"></p> 
<p> 系统结构</p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/df/d2/okZzcvGF_o.png" width="787"></p> 
<p><img alt="" height="642" src="https://images2.imgbox.com/7f/46/f8FMqEi9_o.png" width="1200"> <img alt="" height="658" src="https://images2.imgbox.com/37/59/JzA2L3e5_o.png" width="1155"></p> 
<p>启动过程</p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/c4/77/alFF6GYG_o.png" width="1131"></p> 
<p>新建工程</p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/d4/e3/nueQb3ow_o.png" width="1200"></p> 
<p> GPIO介绍</p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/9d/8f/bbC3yeXm_o.png" width="859"></p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/b1/e3/6aHjcAET_o.png" width="1200"> <img alt="" height="396" src="https://images2.imgbox.com/bd/55/1OCpLwGH_o.png" width="930"></p> 
<p> GPIO八种模式</p> 
<p><img alt="" height="636" src="https://images2.imgbox.com/04/ac/xJWqJ54z_o.png" width="1200"></p> 
<p></p> 
<div> 
 <span style="color:#fe2c24;"><strong>输入配置 </strong></span> 
</div> 
<div> 
 <span style="color:#000000;">当</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">端口配置为输入时： </span> 
</div> 
<div> 
 <span style="color:#000000;">● 输出缓冲器被禁止 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 施密特触发输入被激活 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 根据输入配置</span> 
 <span style="color:#000000;">(</span> 
 <span style="color:#000000;">上拉，下拉或浮动</span> 
 <span style="color:#000000;">)</span> 
 <span style="color:#000000;">的不同，弱上拉和下拉电阻被连接 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 出现在</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">脚上的数据在每个</span> 
 <span style="color:#000000;">APB2</span> 
 <span style="color:#000000;">时钟被采样到输入数据寄存器 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 对输入数据寄存器的读访问可得到</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">状态</span> 
</div> 
<p> <img alt="" height="486" src="https://images2.imgbox.com/e0/f7/Gv74Cy2q_o.png" width="883"></p> 
<div> 
 <span style="color:#fe2c24;"><strong>输出配置 </strong></span> 
</div> 
<div> 
 <span style="color:#000000;">当</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">端口被配置为输出时</span> 
 <span style="color:#000000;">： </span> 
</div> 
<div> 
 <span style="color:#000000;">● 输出缓冲器被激活 </span> 
</div> 
<div> 
 <span style="color:#000000;">─ </span> 
 <span style="color:#000000;">开漏模式：输出寄存器上的</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">0</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">激活</span> 
 <span style="color:#000000;">N-MOS</span> 
 <span style="color:#000000;">，而输出寄存器上的</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">1</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">将端口置于高阻状态</span> 
 <span style="color:#000000;">(P</span> 
</div> 
<div> 
 <span style="color:#000000;">MOS</span> 
 <span style="color:#000000;">从不被激活</span> 
 <span style="color:#000000;">)</span> 
 <span style="color:#000000;">。 </span> 
</div> 
<div> 
 <span style="color:#000000;">─ </span> 
 <span style="color:#000000;">推挽模式：输出寄存器上的</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">0</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">激活</span> 
 <span style="color:#000000;">N-MOS</span> 
 <span style="color:#000000;">，而输出寄存器上的</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">1</span> 
 <span style="color:#000000;">’</span> 
 <span style="color:#000000;">将激活</span> 
 <span style="color:#000000;">P-MOS</span> 
 <span style="color:#000000;">。 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 施密特触发输入被激活 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 弱上拉和下拉电阻被禁止 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 出现在</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">脚上的数据在每个</span> 
 <span style="color:#000000;">APB2</span> 
 <span style="color:#000000;">时钟被采样到输入数据寄存器 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 在开漏模式时，对输入数据寄存器的读访问可得到</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">状态 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 在推挽式模式时，对输出数据寄存器的读访问得到最后一次写的值。</span> 
</div> 
<p> <img alt="" height="454" src="https://images2.imgbox.com/73/30/5IuORRgs_o.png" width="904"></p> 
<p></p> 
<div> 
 <span style="color:#000000;"><strong>复用功能配置 </strong></span> 
</div> 
<div> 
 <span style="color:#000000;">当</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">端口被配置为复用功能时： </span> 
</div> 
<div> 
 <span style="color:#000000;">● 在开漏或推挽式配置中，输出缓冲器被打开 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 内置外设的信号驱动输出缓冲器</span> 
 <span style="color:#000000;">(</span> 
 <span style="color:#000000;">复用功能输出</span> 
 <span style="color:#000000;">) </span> 
</div> 
<div> 
 <span style="color:#000000;">● 施密特触发输入被激活 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 弱上拉和下拉电阻被禁止 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 在每个</span> 
 <span style="color:#000000;">APB2</span> 
 <span style="color:#000000;">时钟周期，出现在</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">脚上的数据被采样到输入数据寄存器 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 开漏模式时，读输入数据寄存器时可得到</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">口状态 </span> 
</div> 
<div> 
 <span style="color:#000000;">● 在推挽模式时，读输出数据寄存器时可得到最后一次写的值</span> 
</div> 
<p><img alt="" height="508" src="https://images2.imgbox.com/51/26/Icz9FZY4_o.png" width="943"></p> 
<div> 
 <span style="color:#000000;"><strong>模拟输入配置 </strong></span> 
</div> 
<div> 
 <span style="color:#000000;">当</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">端口被配置为模拟输入配置时： </span> 
</div> 
<div> 
 <span style="color:#000000;">● 输出缓冲器被禁止； </span> 
</div> 
<div> 
 <span style="color:#000000;">● 禁止施密特触发输入，实现了每个模拟</span> 
 <span style="color:#000000;">I/O</span> 
 <span style="color:#000000;">引脚上的零消耗。施密特触发输出值被强置 </span> 
</div> 
<div> 
 <span style="color:#000000;">为</span> 
 <span style="color:#000000;">’0’</span> 
 <span style="color:#000000;">； </span> 
</div> 
<div> 
 <span style="color:#000000;">● 弱上拉和下拉电阻被禁止； </span> 
</div> 
<div> 
 <span style="color:#000000;">● 读取输入数据寄存器时数值为</span> 
 <span style="color:#000000;">’0’</span> 
</div> 
<p><img alt="" height="567" src="https://images2.imgbox.com/67/5d/TA4cLjvG_o.png" width="957"></p> 
<p> <img alt="" height="397" src="https://images2.imgbox.com/6c/88/TNtvhdfD_o.png" width="1033"></p> 
<h3 id="%C2%A0%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"> 新建工程</h3> 
<p><img alt="" height="830" src="https://images2.imgbox.com/75/52/sYADdfsV_o.png" width="1200"> <img alt="" height="995" src="https://images2.imgbox.com/33/b4/xLUpqkvl_o.png" width="1200"></p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/69/da/BlV9hMnN_o.png" width="782"></p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/55/cc/3EuRgOgE_o.png" width="782"> <img alt="" height="742" src="https://images2.imgbox.com/4e/71/pFAwmitc_o.png" width="971"></p> 
<p> 电灯流程 配置RCC外设时钟</p> 
<p><img alt="" height="651" src="https://images2.imgbox.com/8e/a5/XvN9Vl0D_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="607" src="https://images2.imgbox.com/e8/5d/jtN3ksyz_o.png" width="1200"></p> 
<pre><code>//点亮一个LED
#include "stm32f10x.h"                  // Device header

int main(void)
{
	//APB2 包括A 和B 的IO口并配置各种时钟分频器以生成所需的时钟频率
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	
	//GPIO初始化类型 并配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	
	//把初始化的放进来  输出的三种写法
	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);
	
	
	//GPIOB拉低、拉高、在writeBit中拉高拉低
	GPIO_ResetBits(GPIOB,GPIO_Pin_5);	
	//GPIO_SetBits(GPIOB,GPIO_Pin_5);	
	//GPIO_WriteBit(GPIOB,GPIO_Pin_5,Bit_RESET);	
		//GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);


	while(1){
		
	}
}
</code></pre> 
<h3 id="%E5%A4%96%E8%AE%BE%E6%A1%88%E4%BE%8B">外设案例</h3> 
<h4></h4> 
<h4 id="LED%E6%B5%81%E6%B0%B4%E7%81%AF">LED流水灯</h4> 
<p></p> 
<pre><code>#include "stm32f10x.h"                  // Device header
#include "Delay.h"
int main(void)
{
	//APB2 包括A 和B 的IO口并配置各种时钟分频器以生成所需的时钟频率
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//也可以同时用或初始化AB
	
	//GPIO初始化类型 并配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_All;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;//推挽模式下 高低电平都有驱动能力点亮LED
					     //GPIO_Mode_Out_OD    开漏输出 低电平才有驱动能力点灯 高电平没驱动能力
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	
	//把初始化的放进来  输出的三种写法
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);


	while(1){
		GPIO_Write(GPIOA,~0x0001);//0000 0000 0000 0001 B1引脚低电平
		Delay_ms(500);
		GPIO_Write(GPIOA,~0x0002);//0000 0000 0000 0010 
		Delay_ms(500);
		
		GPIO_Write(GPIOA,~0x0004);//0000 0000 0000 0100
		Delay_ms(500);
		GPIO_Write(GPIOA,~0x0008);//0000 0000 0000 1000
		Delay_ms(500);
		
//		GPIO_Write(GPIOA,~0x0010);//0000 0000 0001 0000
//		Delay_ms(500);
//		GPIO_Write(GPIOA,~0x0020);//0000 0000 0010 0000 
//		Delay_ms(500);
//		
//		GPIO_Write(GPIOA,~0x0040);//0000 0000 0100 0000
//		Delay_ms(500);
//		GPIO_Write(GPIOA,~0x0080);//0000 0000 1000 0000 
//		Delay_ms(500);
		
	}
}
</code></pre> 
<h4 id="%E8%9C%82%E9%B8%A3%E5%99%A8">蜂鸣器</h4> 
<pre><code>#include "stm32f10x.h"                  // Device header
#include "Delay.h"
int main(void)
{
	//APB2 包括A 和B 的IO口并配置各种时钟分频器以生成所需的时钟频率
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//也可以同时用或初始化AB
	
	//GPIO初始化类型 并配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_8;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;//推挽模式下 高低电平都有驱动能力点亮LED
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	
	//把初始化的放进来  输出的三种写法
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);


	while(1){
		//这是因为GPIO_Write函数本身的作用是将PortVal参数的位设置为1
		GPIO_Write(GPIOA,~GPIO_Pin_8);//GPIO_Write默认设置为高电平
		Delay_ms(100);
		GPIO_Write(GPIOA,GPIO_Pin_8);
		Delay_ms(100);
		GPIO_Write(GPIOA,~GPIO_Pin_8);
		Delay_ms(100);
		GPIO_Write(GPIOA,GPIO_Pin_8);
		Delay_ms(700);
		
//		GPIO_WriteBit(GPIOA,GPIO_Pin_8,Bit_RESET);
//		Delay_ms(100);
//		GPIO_WriteBit(GPIOA,GPIO_Pin_8,Bit_SET);
//		Delay_ms(100);
//		GPIO_WriteBit(GPIOA,GPIO_Pin_8,Bit_RESET);
//		Delay_ms(100);
//		GPIO_WriteBit(GPIOA,GPIO_Pin_8,Bit_SET);
//		Delay_ms(700);
		
	}
}
</code></pre> 
<h4 id="%C2%A0%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E5%92%8C%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E7%9F%A5%E8%AF%86"> 上拉电阻和下拉电阻知识</h4> 
<p><img alt="" height="806" src="https://images2.imgbox.com/c9/ff/Us6wapoP_o.png" width="1200"></p> 
<h4 id="%E7%94%B5%E5%8E%8B%E6%AF%94%E8%BE%83%E5%99%A8">电压比较器</h4> 
<p><img alt="" height="477" src="https://images2.imgbox.com/3d/5a/YcWnntfE_o.png" width="870"> <img alt="" height="671" src="https://images2.imgbox.com/30/d5/emPJHbz9_o.png" width="1200"></p> 
<h4 id="%C2%A0c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20%E7%B1%BB%E5%9E%8B%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE"> c语言基础知识 类型、结构体、枚举</h4> 
<h5 id="%E7%B1%BB%E5%9E%8Bint8_t%20int16_t%20int32_t">类型int8_t int16_t int32_t</h5> 
<p><img alt="" height="550" src="https://images2.imgbox.com/b8/85/QxXWSOLa_o.png" width="1200"></p> 
<p> <img alt="" height="576" src="https://images2.imgbox.com/c9/bc/VZuhqN3Z_o.png" width="1079"></p> 
<h5 id="%C2%A0%E5%AE%8F%E6%9B%BF%E6%8D%A2%20%23define%20%E5%92%8Ctypedef%E7%94%A8%E6%B3%95%C2%A0%20%C2%A0"> 宏替换 #define 和typedef用法   </h5> 
<p>typedef相对于更加安全</p> 
<blockquote> 
 <p>关键字：#define</p> 
 <p>用途：用一个字符串代替一个数字，便于理解，防止出错；提取程序中经常出现的参数，</p> 
 <p>           便于快速修改 定义宏定义：   </p> 
 <p>#define ABC 12345 引用宏定义：     int a = ABC;    //等效于int a = 12345;</p> 
</blockquote> 
<blockquote> 
 <p>关键字：typedef 用途：将一个比较长的变量类型名换个名字，便于使用 定义typedef：     typedef unsigned char uint8_t; 引用typedef：      uint8_t a;    //等效于unsigned char a; </p> 
</blockquote> 
<h5 id="%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%A4%E7%A7%8D%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95%20%E5%92%8C%20%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">结构体两种填充方法 和 命名规则</h5> 
<h5 id="%E6%9E%9A%E4%B8%BE%E7%94%A8%E6%B3%95">枚举用法</h5> 
<blockquote> 
 <p>关键字：enum 用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合 定义枚举变量：   </p> 
 <p> enum{FALSE = 0, TRUE = 1} EnumName;     因为枚举变量类型较长，所以通常用typedef更改变量类型名 引用枚举成员：   </p> 
 <p> EnumName = FALSE;     EnumName = TRUE; </p> 
</blockquote> 
<h3 id="%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE">常用配置</h3> 
<h4 id="%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F">输入输出模式</h4> 
<blockquote> 
 <p><code>GPIOMode_TypeDef</code> 枚举类型，该枚举类型包含了多个枚举成员，表示不同的 GPIO 模式。下面是对每个成员的中文注释：</p> 
 <ul><li><code>GPIO_Mode_AIN</code>：模拟输入模式</li><li><code>GPIO_Mode_IN_FLOATING</code>：浮空输入模式</li><li><code>GPIO_Mode_IPD</code>：下拉输入模式</li><li><code>GPIO_Mode_IPU</code>：上拉输入模式</li><li><code>GPIO_Mode_Out_OD</code>：开漏输出模式</li><li><code>GPIO_Mode_Out_PP</code>：推挽输出模式</li><li><code>GPIO_Mode_AF_OD</code>：复用开漏输出模式</li><li><code>GPIO_Mode_AF_PP</code>：复用推挽输出模式</li></ul> 
 <p></p> 
</blockquote> 
<p></p> 
<h4 id="GPIO%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0">GPIO常用库函数</h4> 
<blockquote> 
 <ol><li> <p><code>void GPIO_DeInit(GPIO_TypeDef* GPIOx)</code>：用于将指定GPIO端口的所有配置重置为默认值。</p> </li><li> <p><code>void GPIO_AFIODeInit(void)</code>：用于将AFIO（Alternate Function I/O）寄存器的配置重置为默认值。</p> </li><li> <p><code>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</code>：用于初始化指定GPIO端口的引脚配置。通过<code>GPIO_InitStruct</code>结构体参数传递引脚相关配置，如引脚编号、引脚模式、引脚速度、引脚上拉/下拉等。</p> </li><li> <p><code>void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)</code>：用于将<code>GPIO_InitStruct</code>结构体中的成员设置为默认值。<br>  </p> 
   <hr><p></p> </li><li> <p><code>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</code>：用于读取指定GPIO端口指定引脚号的输入电平（逻辑高或逻辑低）。</p> </li><li> <p><code>uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)</code>：用于读取指定GPIO端口的全部输入引脚的电平状态。</p> </li><li> <p><code>uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</code>：用于读取指定GPIO端口指定引脚号的输出电平（逻辑高或逻辑低）。</p> </li><li> <p><code>uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)</code>：用于读取指定GPIO端口的全部输出引脚的电平状态。<br>  </p> 
   <hr><p></p> </li><li> <p><code>void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</code>：用于将指定GPIO端口中指定引脚置为逻辑高电平。</p> </li><li> <p><code>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</code>：用于将指定GPIO端口中指定引脚置为逻辑低电平。</p> </li><li> <p><code>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)</code>：用于设置指定GPIO端口中指定引脚的输出电平，<code>BitVal</code>参数可设置为<code>Bit_RESET</code>（低电平）或<code>Bit_SET</code>（高电平）。</p> </li><li> <p><code>void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)</code>：用于设置指定GPIO端口的全部输出引脚的电平状态。<code>PortVal</code>参数是一个16位的数值，每个位对应一个引脚，可设置为逻辑低或逻辑高。<br>  </p> 
   <hr><p></p> </li><li> <p><code>void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</code>：用于锁定指定GPIO端口的指定引脚，防止意外改变其配置。</p> </li><li> <p><code>void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)</code>：用于配置GPIO的事件输出功能，将指定的GPIO端口和引脚映射到事件输出信号线上。</p> </li><li> <p><code>void GPIO_EventOutputCmd(FunctionalState NewState)</code>：用于使能或禁用GPIO的事件输出功能。</p> </li><li> <p><code>void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)</code>：用于重新映射GPIO端口的引脚，将其连接到其他IO端口或功能。</p> </li><li> <p><code>void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)</code>：用于配置GPIO的外部中断线路，将指定的GPIO端口和引脚映射到外部中断线上。</p> </li><li> <p><code>void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface)</code>：用于配置GPIO端口的以太网媒体接口（MII或RMII）。</p> </li></ol> 
</blockquote> 
<h4 id="%C2%A0%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"> 中断函数</h4> 
<blockquote> 
 <ol><li> <p><code>void EXTI_DeInit(void)</code>：用于将外部中断配置重置为默认值。</p> </li><li> <p><code>void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)</code>：用于根据指定的配置参数初始化外部中断。</p> </li><li> <p><code>void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)</code>：用于将外部中断配置结构体<code>EXTI_InitStruct</code>的成员设置为默认值。</p> </li><li> <p><code>void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)</code>：用于生成指定外部中断线的软件中断。可以用于模拟外部中断触发。</p> </li><li> <p><code>FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)</code>：用于获取指定外部中断线的中断标志状态。返回值为<code>SET</code>（中断标志置位）或<code>RESET</code>（中断标志未置位）。</p> </li><li> <p><code>void EXTI_ClearFlag(uint32_t EXTI_Line)</code>：用于清除指定外部中断线的中断标志。将中断标志置位。</p> </li><li> <p><code>ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)</code>：用于获取指定外部中断线的中断状态。返回值为<code>SET</code>（中断状态已触发）或<code>RESET</code>（中断状态未触发）。</p> </li><li> <p><code>void EXTI_ClearITPendingBit(uint32_t EXTI_Line)</code>：用于清除指定外部中断线的中断挂起位。将中断挂起位复位。</p> </li></ol> 
</blockquote> 
<hr> 
<h3 id="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%C2%A0">模块化编程 </h3> 
<h4 id="%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%C2%A0%20System">延时函数  System</h4> 
<pre><code>#include "stm32f10x.h"

/**
  * @brief  微秒级延时
  * @param  xus 延时时长，范围：0~233015
  * @retval 无
  */
void Delay_us(uint32_t xus)
{
	SysTick-&gt;LOAD = 72 * xus;				//设置定时器重装值
	SysTick-&gt;VAL = 0x00;					//清空当前计数值
	SysTick-&gt;CTRL = 0x00000005;				//设置时钟源为HCLK，启动定时器
	while(!(SysTick-&gt;CTRL &amp; 0x00010000));	//等待计数到0
	SysTick-&gt;CTRL = 0x00000004;				//关闭定时器
}

/**
  * @brief  毫秒级延时
  * @param  xms 延时时长，范围：0~4294967295
  * @retval 无
  */
void Delay_ms(uint32_t xms)
{
	while(xms--)
	{
		Delay_us(1000);
	}
}
 
/**
  * @brief  秒级延时
  * @param  xs 延时时长，范围：0~4294967295
  * @retval 无
  */
void Delay_s(uint32_t xs)
{
	while(xs--)
	{
		Delay_ms(1000);
	}
} 
</code></pre> 
<h4 id="%C2%A0LED%E5%87%BD%E6%95%B0%C2%A0%20Hardwore"> LED函数  Hardwore</h4> 
<pre><code>#include "stm32f10x.h"                  // Device header

//LED初始化
void LED_Init(void)
{	//配置寄存器A时钟使能
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	//结构体名字 及配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8|GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	
	//配置完初始化  初始化后灯会亮
	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);
	//把该引脚拉高灯灭
	GPIO_SetBits(GPIOB,GPIO_Pin_8|GPIO_Pin_9);
}

//LED1 开
void LED1_ON(void)
{
	GPIO_ResetBits(GPIOB,GPIO_Pin_8);
}
//LED1 关
void LED1_OFF(void)
{
	GPIO_SetBits(GPIOB,GPIO_Pin_8);
}
//LED2 开
void LED2_ON(void)
{
	GPIO_ResetBits(GPIOB,GPIO_Pin_9);
}
//LED2 关
void LED2_OFF(void)
{
	GPIO_SetBits(GPIOB,GPIO_Pin_9);
}
//LED1按键反转
void LED1_Turn(void)
{	//如果是低电平正在亮就灭 拉高
	if(GPIO_ReadOutputDataBit(GPIOB,GPIO_Pin_8) == 0){
		GPIO_SetBits(GPIOB,GPIO_Pin_8);
	}else{//否则就是熄灭状态 就拉低 灯亮
		GPIO_ResetBits(GPIOB,GPIO_Pin_8);
	}
}

void LED2_Turn(void)
{	//如果是低电平正在亮就灭 拉高
	if(GPIO_ReadOutputDataBit(GPIOB,GPIO_Pin_9) == 0){
		GPIO_SetBits(GPIOB,GPIO_Pin_9);
	}else{//否则就是熄灭状态 就拉低 灯亮
		GPIO_ResetBits(GPIOB,GPIO_Pin_9);
	}
}


</code></pre> 
<h4 id="%C2%A0%C2%A0%E6%8C%89%E9%94%AE%E5%87%BD%E6%95%B0%C2%A0%20Hardwore">  按键函数  Hardwore</h4> 
<pre><code>#include "stm32f10x.h"                  // Device header
#include "Delay.h"

//按键 初始化 PA0 PA1 设置为上拉输入 
void Key_Init(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入 看原理图
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0|GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
}

//获取按键值 注意返回类型uint8_t unsigned char  GPIO_ReadInputDataBit读取一个位 返回0或1
uint8_t Key_getNum(void)
{
	uint8_t keyNum = 0;
	//如果按键1 按下 延时消抖 还是按下状态 消抖 keyNum赋值1
	if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0) == 0){
		Delay_ms(20);
		while(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0) == 0);
		Delay_ms(20);
		keyNum = 1;
	}
	//如果按键2 按下 延时消抖 还是按下状态 消抖 keyNum赋值2
	if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1) == 0){
		Delay_ms(20);
		while(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1) == 0);
		Delay_ms(20);
		keyNum = 2;
	}
	return keyNum;
	
}

</code></pre> 
<h4 id="%C2%A0%C2%A0%C2%A0%E8%9C%82%E9%B8%A3%E5%99%A8%E5%87%BD%E6%95%B0%C2%A0%20Hardwore">   蜂鸣器函数  Hardwore</h4> 
<pre><code>#include "stm32f10x.h"                  // Device header

//蜂鸣器初始化
void Buzzer_Init(void)
{	//配置寄存器A时钟使能
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	//结构体名字 及配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	
	//配置完初始化  初始化后灯会亮
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	//把该引脚拉高灯灭
	//GPIO_SetBits(GPIOA,GPIO_Pin_8);
}

//蜂鸣器 开
void Buzzer_ON(void)
{
	GPIO_ResetBits(GPIOA,GPIO_Pin_8);
}
//蜂鸣器 关
void Buzzer_OFF(void)
{
	GPIO_SetBits(GPIOA,GPIO_Pin_8);
}

//蜂鸣器 反转
void Buzzer_Turn(void)
{	//如果是低电平正在亮就灭 拉高
	if(GPIO_ReadOutputDataBit(GPIOA,GPIO_Pin_8) == 0){
		GPIO_SetBits(GPIOB,GPIO_Pin_8);
	}else{//否则就是熄灭状态 就拉低 灯亮
		GPIO_ResetBits(GPIOA,GPIO_Pin_8);
	}
}
</code></pre> 
<h4 id="%C2%A0%E9%9C%87%E5%8A%A8%E6%A8%A1%E5%9D%97%C2%A0Hardwore"> 震动模块 Hardwore</h4> 
<p>输入</p> 
<pre><code>#include "stm32f10x.h"                  // Device header


//震动模块 初始化 PA4 设置为上拉输入 
void Shock_Init()
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入 看原理图
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_4;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
}

//获取震动传感器的值 有震动返回0 没有就是高
uint8_t Shock_getMsg()
{
	return 	GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_4);
	
}

</code></pre> 
<h4 id="%C2%A0OLED%20IIC%E6%A8%A1%E5%9D%97Hardwore"> OLED IIC模块Hardwore</h4> 
<pre><code>#include "stm32f10x.h"
#include "OLED_Font.h"

/*引脚配置*/
#define OLED_W_SCL(x)		GPIO_WriteBit(GPIOB, GPIO_Pin_8, (BitAction)(x))
#define OLED_W_SDA(x)		GPIO_WriteBit(GPIOB, GPIO_Pin_9, (BitAction)(x))

/*引脚初始化*/
void OLED_I2C_Init(void)
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;//开楼输出
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
	
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}

/**
  * @brief  I2C开始
  * @param  无
  * @retval 无
  */
void OLED_I2C_Start(void)
{
	OLED_W_SDA(1);
	OLED_W_SCL(1);
	OLED_W_SDA(0);
	OLED_W_SCL(0);
}

/**
  * @brief  I2C停止
  * @param  无
  * @retval 无
  */
void OLED_I2C_Stop(void)
{
	OLED_W_SDA(0);
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}

/**
  * @brief  I2C发送一个字节
  * @param  Byte 要发送的一个字节
  * @retval 无
  */
void OLED_I2C_SendByte(uint8_t Byte)
{
	uint8_t i;
	for (i = 0; i &lt; 8; i++)
	{
		OLED_W_SDA(Byte &amp; (0x80 &gt;&gt; i));
		OLED_W_SCL(1);
		OLED_W_SCL(0);
	}
	OLED_W_SCL(1);	//额外的一个时钟，不处理应答信号
	OLED_W_SCL(0);
}

/**
  * @brief  OLED写命令
  * @param  Command 要写入的命令
  * @retval 无
  */
void OLED_WriteCommand(uint8_t Command)
{
	OLED_I2C_Start();
	OLED_I2C_SendByte(0x78);		//从机地址
	OLED_I2C_SendByte(0x00);		//写命令
	OLED_I2C_SendByte(Command); 
	OLED_I2C_Stop();
}

/**
  * @brief  OLED写数据
  * @param  Data 要写入的数据
  * @retval 无
  */
void OLED_WriteData(uint8_t Data)
{
	OLED_I2C_Start();
	OLED_I2C_SendByte(0x78);		//从机地址
	OLED_I2C_SendByte(0x40);		//写数据
	OLED_I2C_SendByte(Data);
	OLED_I2C_Stop();
}

/**
  * @brief  OLED设置光标位置
  * @param  Y 以左上角为原点，向下方向的坐标，范围：0~7
  * @param  X 以左上角为原点，向右方向的坐标，范围：0~127
  * @retval 无
  */
void OLED_SetCursor(uint8_t Y, uint8_t X)
{
	OLED_WriteCommand(0xB0 | Y);					//设置Y位置
	OLED_WriteCommand(0x10 | ((X &amp; 0xF0) &gt;&gt; 4));	//设置X位置高4位
	OLED_WriteCommand(0x00 | (X &amp; 0x0F));			//设置X位置低4位
}

/**
  * @brief  OLED清屏
  * @param  无
  * @retval 无
  */
void OLED_Clear(void)
{  
	uint8_t i, j;
	for (j = 0; j &lt; 8; j++)
	{
		OLED_SetCursor(j, 0);
		for(i = 0; i &lt; 128; i++)
		{
			OLED_WriteData(0x00);
		}
	}
}

/**
  * @brief  OLED显示一个字符
  * @param  Line 行位置，范围：1~4
  * @param  Column 列位置，范围：1~16
  * @param  Char 要显示的一个字符，范围：ASCII可见字符
  * @retval 无
  */
void OLED_ShowChar(uint8_t Line, uint8_t Column, char Char)
{      	
	uint8_t i;
	OLED_SetCursor((Line - 1) * 2, (Column - 1) * 8);		//设置光标位置在上半部分
	for (i = 0; i &lt; 8; i++)
	{
		OLED_WriteData(OLED_F8x16[Char - ' '][i]);			//显示上半部分内容
	}
	OLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 8);	//设置光标位置在下半部分
	for (i = 0; i &lt; 8; i++)
	{
		OLED_WriteData(OLED_F8x16[Char - ' '][i + 8]);		//显示下半部分内容
	}
}

/**
  * @brief  OLED显示字符串
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  String 要显示的字符串，范围：ASCII可见字符
  * @retval 无
  */
void OLED_ShowString(uint8_t Line, uint8_t Column, char *String)
{
	uint8_t i;
	for (i = 0; String[i] != '\0'; i++)
	{
		OLED_ShowChar(Line, Column + i, String[i]);
	}
}

/**
  * @brief  OLED次方函数
  * @retval 返回值等于X的Y次方
  */
uint32_t OLED_Pow(uint32_t X, uint32_t Y)
{
	uint32_t Result = 1;
	while (Y--)
	{
		Result *= X;
	}
	return Result;
}

/**
  * @brief  OLED显示数字（十进制，正数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~4294967295
  * @param  Length 要显示数字的长度，范围：1~10
  * @retval 无
  */
void OLED_ShowNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)
{
	uint8_t i;
	for (i = 0; i &lt; Length; i++)							
	{
		OLED_ShowChar(Line, Column + i, Number / OLED_Pow(10, Length - i - 1) % 10 + '0');
	}
}

/**
  * @brief  OLED显示数字（十进制，带符号数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：-2147483648~2147483647
  * @param  Length 要显示数字的长度，范围：1~10
  * @retval 无
  */
void OLED_ShowSignedNum(uint8_t Line, uint8_t Column, int32_t Number, uint8_t Length)
{
	uint8_t i;
	uint32_t Number1;
	if (Number &gt;= 0)
	{
		OLED_ShowChar(Line, Column, '+');
		Number1 = Number;
	}
	else
	{
		OLED_ShowChar(Line, Column, '-');
		Number1 = -Number;
	}
	for (i = 0; i &lt; Length; i++)							
	{
		OLED_ShowChar(Line, Column + i + 1, Number1 / OLED_Pow(10, Length - i - 1) % 10 + '0');
	}
}

/**
  * @brief  OLED显示数字（十六进制，正数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~0xFFFFFFFF
  * @param  Length 要显示数字的长度，范围：1~8
  * @retval 无
  */
void OLED_ShowHexNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)
{
	uint8_t i, SingleNumber;
	for (i = 0; i &lt; Length; i++)							
	{
		SingleNumber = Number / OLED_Pow(16, Length - i - 1) % 16;
		if (SingleNumber &lt; 10)
		{
			OLED_ShowChar(Line, Column + i, SingleNumber + '0');
		}
		else
		{
			OLED_ShowChar(Line, Column + i, SingleNumber - 10 + 'A');
		}
	}
}

/**
  * @brief  OLED显示数字（二进制，正数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
  * @param  Length 要显示数字的长度，范围：1~16
  * @retval 无
  */
void OLED_ShowBinNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)
{
	uint8_t i;
	for (i = 0; i &lt; Length; i++)							
	{
		OLED_ShowChar(Line, Column + i, Number / OLED_Pow(2, Length - i - 1) % 2 + '0');
	}
}

/**
  * @brief  OLED初始化
  * @param  无
  * @retval 无
  */
void OLED_Init(void)
{
	uint32_t i, j;
	
	for (i = 0; i &lt; 1000; i++)			//上电延时
	{
		for (j = 0; j &lt; 1000; j++);
	}
	
	OLED_I2C_Init();			//端口初始化
	
	OLED_WriteCommand(0xAE);	//关闭显示
	
	OLED_WriteCommand(0xD5);	//设置显示时钟分频比/振荡器频率
	OLED_WriteCommand(0x80);
	
	OLED_WriteCommand(0xA8);	//设置多路复用率
	OLED_WriteCommand(0x3F);
	
	OLED_WriteCommand(0xD3);	//设置显示偏移
	OLED_WriteCommand(0x00);
	
	OLED_WriteCommand(0x40);	//设置显示开始行
	
	OLED_WriteCommand(0xA1);	//设置左右方向，0xA1正常 0xA0左右反置
	
	OLED_WriteCommand(0xC8);	//设置上下方向，0xC8正常 0xC0上下反置

	OLED_WriteCommand(0xDA);	//设置COM引脚硬件配置
	OLED_WriteCommand(0x12);
	
	OLED_WriteCommand(0x81);	//设置对比度控制
	OLED_WriteCommand(0xCF);

	OLED_WriteCommand(0xD9);	//设置预充电周期
	OLED_WriteCommand(0xF1);

	OLED_WriteCommand(0xDB);	//设置VCOMH取消选择级别
	OLED_WriteCommand(0x30);

	OLED_WriteCommand(0xA4);	//设置整个显示打开/关闭

	OLED_WriteCommand(0xA6);	//设置正常/倒转显示

	OLED_WriteCommand(0x8D);	//设置充电泵
	OLED_WriteCommand(0x14);

	OLED_WriteCommand(0xAF);	//开启显示
		
	OLED_Clear();				//OLED清屏
}
</code></pre> 
<p> 字库</p> 
<pre><code>#ifndef __OLED_FONT_H
#define __OLED_FONT_H

/*OLED字模库，宽8像素，高16像素*/
const uint8_t OLED_F8x16[][16]=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//  0
	
	0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//! 1
	
	0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//" 2
	
	0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,
	0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//# 3
	
	0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,
	0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$ 4
	
	0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,
	0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//% 5
	
	0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,
	0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&amp; 6
	
	0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//' 7
	
	0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,
	0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//( 8
	
	0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,
	0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//) 9
	
	0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,
	0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//* 10
	
	0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,
	0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+ 11
	
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//, 12
	
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//- 13
	
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//. 14
	
	0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,
	0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,/// 15
	
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,
	0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//0 16
	
	0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//1 17
	
	0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,
	0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//2 18
	
	0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,
	0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//3 19
	
	0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,
	0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//4 20
	
	0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,
	0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//5 21
	
	0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,
	0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//6 22
	
	0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,
	0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//7 23
	
	0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,
	0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//8 24
	
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,
	0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//9 25
	
	0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//: 26
	
	0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
	0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//; 27
	
	0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,
	0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//&lt; 28
	
	0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,
	0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,//= 29
	
	0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,
	0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//&gt; 30
	
	0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,
	0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//? 31
	
	0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,
	0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@ 32
	
	0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,
	0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A 33
	
	0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,
	0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B 34
	
	0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,
	0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C 35
	
	0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,
	0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D 36
	
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,
	0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E 37
	
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,
	0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F 38
	
	0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,
	0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G 39
	
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,
	0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H 40
	
	0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I 41
	
	0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,
	0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J 42
	
	0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,
	0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K 43
	
	0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,
	0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L 44
	
	0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,
	0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M 45
	
	0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,
	0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N 46
	
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,
	0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O 47
	
	0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,
	0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P 48
	
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,
	0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q 49
	
	0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,
	0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R 50
	
	0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,
	0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S 51
	
	0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,
	0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T 52
	
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,
	0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U 53
	
	0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,
	0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V 54
	
	0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,
	0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W 55
	
	0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,
	0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X 56
	
	0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,
	0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y 57
	
	0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,
	0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z 58
	
	0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,
	0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[ 59
	
	0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\ 60
	
	0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,
	0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//] 61
	
	0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^ 62
	
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_ 63
	
	0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//` 64
	
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
	0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a 65
	
	0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,
	0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b 66
	
	0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,
	0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c 67
	
	0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,
	0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d 68
	
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
	0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e 69
	
	0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f 70
	
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
	0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g 71
	
	0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,
	0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h 72
	
	0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i 73
	
	0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,
	0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j 74
	
	0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,
	0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k 75
	
	0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l 76
	
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
	0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m 77
	
	0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,
	0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n 78
	
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
	0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o 79
	
	0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,
	0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p 80
	
	0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,
	0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q 81
	
	0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,
	0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r 82
	
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
	0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s 83
	
	0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,
	0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t 84
	
	0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,
	0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u 85
	
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,
	0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v 86
	
	0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,
	0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w 87
	
	0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,
	0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x 88
	
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,
	0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y 89
	
	0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
	0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z 90
	
	0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,
	0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{ 91
	
	0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//| 92
	
	0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,
	0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//} 93
	
	0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~ 94
};

#endif
</code></pre> 
<p></p> 
<p></p> 
<h3 id="%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95">调试方法</h3> 
<p>串口打印 、oled、 电灯、kile调试 通过各种现象调试</p> 
<p>kile点击放大镜调试、板子实时在跑，若要修改函数则需要先停止调试功能</p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/19/80/aN6vLsMm_o.png" width="1200"></p> 
<h3 id="%C2%A0%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"> 中断系统</h3> 
<h4 id="%E6%A6%82%E5%BF%B5%EF%BC%9A">概念：</h4> 
<p>中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</p> 
<p>中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p> 
<p>中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回</p> 
<h4 id="NVIC%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%C2%A0">NVIC中断控制寄存器结构 </h4> 
<p><img alt="" height="699" src="https://images2.imgbox.com/63/70/N7uAcYxC_o.png" width="1147"></p> 
<p></p> 
<h4 id="%C2%A0NVIC%E5%88%86%E7%BB%84%20%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E2%80%8B%E7%BC%96%E8%BE%91"> NVIC分组 抢占优先级和响应优先级<img alt="" height="646" src="https://images2.imgbox.com/77/af/yyvvaGHK_o.png" width="1200"></h4> 
<p> <img alt="" height="757" src="https://images2.imgbox.com/a7/ee/qt4l5GjT_o.png" width="1200"></p> 
<p> <img alt="" height="709" src="https://images2.imgbox.com/23/11/TLzMNxSc_o.png" width="1101"></p> 
<p></p> 
<h4 id="%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE%20--%E4%BB%A3%E7%A0%81-----------------">中断配置 --代码-----------------</h4> 
<p>中断 oled刷新count的值</p> 
<p>触发中断和触发事件  触发事件不会经过cpu直接反应事件</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/77/95/cSy9ynI3_o.png" width="1119"></p> 
<pre><code>#include "stm32f10x.h"                  // Device header

uint16_t CountSensor_count;
void CountSensor_Init(void)
{

	//RCC 时钟配置
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	
	//GPIO初始化配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_14;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);
	
	//AFIO初始化配置  GPIO引脚到外部中断线的映射配置
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);
	
	//EXTI初始化配置
	EXTI_InitTypeDef EXTI_InitStructure;
	EXTI_InitStructure.EXTI_Line   = EXTI_Line14;//中断线14
	EXTI_InitStructure.EXTI_LineCmd= ENABLE;//使能
	EXTI_InitStructure.EXTI_Mode   = EXTI_Mode_Interrupt;//中断  另一个是事件
	EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling;//触发方式 上升沿 下降沿 上升下降沿都出触发
	EXTI_Init(&amp;EXTI_InitStructure);//指定GPIO端口和引脚映射到外部中断线上
	
	//配置NVIC
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//用于配置中断优先级分组。中断优先级分组决定了中断优先级的划分方式
	
	NVIC_InitTypeDef NVIC_InitStructure;	     //结构体配置
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;//指定中断线
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;//响应中断优先级 0-14
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;//抢占中断优先级 0-14
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//开启
	
	NVIC_Init(&amp;NVIC_InitStructure);//初始化中断控制寄存器
}

//返回count的值
uint16_t CountSensor_Get(void)
{
	return CountSensor_count;
}


//10-15的中断处理函数 当发生中断就跳转到该函数 后要清楚中断标志位
void EXTI15_10_IRQHandler(void)
{	//检测是不是14引脚触发中断 SET触发中断
	if(EXTI_GetITStatus(EXTI_Line14) == SET){//读取该引脚电平是否拉低 0 是count++
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_14) == Bit_RESET){
			CountSensor_count++;
		}

		EXTI_ClearITPendingBit(EXTI_Line14);
	}
}
</code></pre> 
<pre><code>/*
按键中断电灯
*/
#include "stm32f10x.h"                  // Device header
#include "LED.h"  

void CountSensor_Init(void)
{
	

	//rcc 设置PPIOA时钟和复用口时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
		
	//gpio afio配置GPIO和映射到复用口
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0|GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
			
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource1);	
	
	//exti配置exti中断 
	EXTI_InitTypeDef EXTI_InitStructure;
	EXTI_InitStructure.EXTI_Line = EXTI_Line0|EXTI_Line1;//中断映射pin
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;//使能开启中断
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;//产生中断 还是事件
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;//下降延触发
	EXTI_Init(&amp;EXTI_InitStructure);
	
	
	//NVIC_Prior 中断分组 5组 0 1 2（0-3抢占 0-3响应） 3 4 
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	//nvic分组后初始化配置 两个角可以共用一个结构体
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;//中断向量
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;//抢占优先级 -- 根据分来来填写
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;//响应优先级
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//
	NVIC_Init(&amp;NVIC_InitStructure);
	
	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;//中断向量
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;//抢占优先级 -- 根据分来来填写
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;//响应优先级
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//
	NVIC_Init(&amp;NVIC_InitStructure);
	
}

//引脚0外部中断
void EXTI0_IRQHandler(void)
{
	if(EXTI_GetITStatus(EXTI_Line0) == SET){ //检测0是否按下
		LED1_ON();							//开灯
		EXTI_ClearITPendingBit(EXTI_Line0);//清除标志位
	}
}

//引脚1外部中断
void EXTI1_IRQHandler(void)
{
	if(EXTI_GetITStatus(EXTI_Line1) == SET){//检测0是否按下
		LED1_OFF();							//关灯
		EXTI_ClearITPendingBit(EXTI_Line1);//清除标志位
	}
}
</code></pre> 
<pre><code>#include "stm32f10x.h"                  // Device header
#include "Shock.h"
#include "Buzzer.h"
#include "Delay.h"
#include "OLED.h"
#include "CountSensor.h"

int main(void)
{
	OLED_Init();
	CountSensor_Init();
	OLED_ShowString(1, 1, "Count:");
	
	while (1)
	{
		OLED_ShowNum(1, 7, CountSensor_Get(),5);
	}
}

</code></pre> 
<p></p> 
<h4 id="%E4%B8%A4%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%97%B6">两个中断时</h4> 
<pre><code>#include "stm32f10x.h"                  // Device header
int16_t Encoder_Count;

void Encoder_Init(void)
{

	//RCC 时钟配置
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	
	//GPIO初始化配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0|GPIO_Pin_1;//初始化引脚0 和 1
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);
	
	//AFIO初始化配置  GPIO引脚到外部中断线的映射配置
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1);
	
	
	//EXTI初始化配置
	EXTI_InitTypeDef EXTI_InitStructure;
	EXTI_InitStructure.EXTI_Line   = EXTI_Line0|EXTI_Line1;//中断线0 1映射
	EXTI_InitStructure.EXTI_LineCmd= ENABLE;//使能
	EXTI_InitStructure.EXTI_Mode   = EXTI_Mode_Interrupt;//中断  另一个是事件
	EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling;//触发方式 上升沿 下降沿 上升下降沿都出触发
	EXTI_Init(&amp;EXTI_InitStructure);//指定GPIO端口和引脚映射到外部中断线上
	
	//配置NVIC
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//用于配置中断优先级分组。中断优先级分组决定了中断优先级的划分方式
	
	NVIC_InitTypeDef NVIC_InitStructure;	     //结构体配置
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;//指定中断线
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;//响应中断优先级 0-14
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;//抢占中断优先级 0-14
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//开启
	
	NVIC_Init(&amp;NVIC_InitStructure);//初始化中断控制寄存器 引脚0
	
	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;//指定中断线
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;//响应中断优先级 0-14
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;//抢占中断优先级 0-14
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//开启
	
	NVIC_Init(&amp;NVIC_InitStructure);//初始化中断控制寄存器 引脚1
}

int16_t Encoder_Get(void)
{
	int8_t temp;
	temp = Encoder_Count;
	Encoder_Count = 0;
	return temp;
}


//10-15的中断处理函数 当发生中断就跳转到该函数 后要清楚中断标志位
void EXTI0_IRQHandler(void)
{	//检测是不是14引脚触发中断 SET触发中断
	if(EXTI_GetITStatus(EXTI_Line0) == SET){//读取该引脚电平是否拉低 0 是count++
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0) == Bit_RESET){
			Encoder_Count--;
		}

		EXTI_ClearITPendingBit(EXTI_Line0);
	}
}

void EXTI1_IRQHandler(void)
{	//检测是不是14引脚触发中断 SET触发中断
	if(EXTI_GetITStatus(EXTI_Line1) == SET){//读取该引脚电平是否拉低 0 是count++
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1) == Bit_RESET){
			Encoder_Count++;
		}

		EXTI_ClearITPendingBit(EXTI_Line1);
	}
}
</code></pre> 
<hr> 
<h3 id="%E5%AE%9A%E6%97%B6%E5%99%A8" style="background-color:transparent;">定时器</h3> 
<h4 id="%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB%E5%9E%8B">定时器类型</h4> 
<p><img alt="" height="620" src="https://images2.imgbox.com/53/b8/JfZmbbHN_o.png" width="1200"></p> 
<h4 id="%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E5%9F%BA----%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8">定时器时基----基本定时器</h4> 
<p><img alt="" height="698" src="https://images2.imgbox.com/d2/80/WXQMg10T_o.png" width="1200"></p> 
<h4 id="%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%92%9F%E8%BE%93%E5%85%A5">通用定时器时钟输入</h4> 
<p><img alt="" height="793" src="https://images2.imgbox.com/ee/e7/2GGEHEt2_o.png" width="986"></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="613" src="https://images2.imgbox.com/62/b6/Nk3j7flQ_o.png" width="838"> 高级定时器<img alt="" height="712" src="https://images2.imgbox.com/9d/9d/N6YBubdA_o.png" width="836"></h4> 
<p><img alt="" height="670" src="https://images2.imgbox.com/b3/2e/svSIcekS_o.png" width="1200"> <img alt="" height="673" src="https://images2.imgbox.com/ac/75/FM9SabBJ_o.png" width="1200"><img alt="" height="575" src="https://images2.imgbox.com/6a/a8/O1kan7WO_o.png" width="962"><img alt="" height="706" src="https://images2.imgbox.com/1c/0e/5LieilYw_o.png" width="923"></p> 
<h4 id="%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86-----------------------------">代码部分-----------------------------</h4> 
<p>配置STM32F103C8T6标准库的定时器中断需要以下步骤：</p> 
<ol><li>使能时钟。</li><li>配置预分频、自动重装值和重复计数值。</li><li>清除中断标志位（否则会先进一次中断）。</li><li>使能TIM中断，选择中断源。</li><li>设置中断优先级。</li><li>使能TIMx外设。</li></ol> 
<p></p> 
<pre><code>#include "stm32f10x.h"                  // Device header

void Timer_Init()
{
	//使能时钟
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);				//用于配置TIMx定时器的时钟源和分频值
	
	//设置预分频自动重装值和重复计数 定时时间clk_psc/psc+1/次数 72000000/7200-1/10000-1 = 1秒
	TIM_TimeBaseInitTypeDef TIM_TimBaseInitStructure;
	TIM_TimBaseInitStructure.TIM_Prescaler   = 7200 - 1;    //设置定时器的预分频值
	TIM_TimBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数模式
	TIM_TimBaseInitStructure.TIM_Period      = 10000 - 1;   //即定时器需要计数多少次才能溢出一次
	TIM_TimBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//置定时器的时钟分频系数为1，即不分频。
	TIM_TimBaseInitStructure.TIM_RepetitionCounter = 0;     //设置定时器的重复计数器值为0，用于启动定时器和计算定时器溢出时间。
	
	TIM_TimeBaseInit(TIM2,&amp;TIM_TimBaseInitStructure);
	//清除中断标志位
	TIM_ClearFlag(TIM2,TIM_FLAG_Update);				//防止TIM_TimeBaseInit后就进入中断
	
	//使能TIM中断
	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
	
	//设置中断优先级
	NVIC_InitTypeDef NVIV_InitStructure;
	NVIV_InitStructure.NVIC_IRQChannel = TIM2_IRQn;//中断通道
	NVIV_InitStructure.NVIC_IRQChannelCmd = ENABLE;//启动中断
	NVIV_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;//抢占优先级为2
	NVIV_InitStructure.NVIC_IRQChannelSubPriority = 1;  //响应优先级1
	
	NVIC_Init(&amp;NVIV_InitStructure);//中通道配置
	
	//使能TIMx外设
	
	TIM_Cmd(TIM2,ENABLE); //定时器2使能
}

/*
//定时器2中断
void TIM2_IRQHandler(void)
{
	//判断是不是定时器2中断
	if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET){
		
		
		//清楚标志位
		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);
	}
	
}
*/
</code></pre> 
<p>定时器电灯。</p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/17/17/tYff4tev_o.png" width="1089"></p> 
<pre><code>/*
定时器中断点灯
*/

#include "stm32f10x.h"                  // Device header
#include "LED.h" 

void Timer_Init(void)
{	
	
	//设置时钟挂在APB1时钟上 为内部时钟72MHz
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);
	
	//配置时基 72000000/7200/10000 = 1s
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//几分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 10000-1;//周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 7200-1;//psc获取定时器的预分频系数。这个参数决定了定时器的计数频率
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//设置重复计数值 溢出增加计数 高级定时器才能用
    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);
	
	
	//设置运行控制 当指定的更新事件（通常是TIM_UpdateFlag）发生时，使能定时器的中断
	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
	
	//设置中断控制分组
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	//设置中断控制
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;//中断通道
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能中断
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;//抢占优先级 --根据分组
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;//响应优先级
	NVIC_Init(&amp;NVIC_InitStructure);
	
	//启动定时器
	TIM_Cmd(TIM2,ENABLE);
	
}
void TIM2_IRQHandler(void)
{
	if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)
	{
		LED1_Turn();
		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//用于清除定时器的某个中断挂起位的状态 以便重新激活
	}
}
</code></pre> 
<h3 id="%E5%AE%9A%E6%97%B6%E5%99%A8%20----%20PWM">定时器 ---- PWM</h3> 
<p>概念</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/a8/cd/3NRKTSlP_o.png" width="1200">原理图 </p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/6e/b1/VJ3NRhe7_o.png" width="957"> 常用模式<img alt="" height="691" src="https://images2.imgbox.com/4a/f1/T7PXnkJm_o.png" width="1200"></p> 
<p>CNT和CCR以及满刻度占比 </p> 
<p><img alt="" height="665" src="https://images2.imgbox.com/57/81/80hKrDG5_o.png" width="1200"> 计算公式<img alt="" height="555" src="https://images2.imgbox.com/bc/d2/O9m7AcoT_o.png" width="916"></p> 
<p> 电路接线图</p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/9e/0b/fShfutrJ_o.png" width="827"></p> 
<p>引脚复用 ---- 映射</p> 
<p><img alt="" height="744" src="https://images2.imgbox.com/fb/b1/KHeSGUCq_o.png" width="1075"></p> 
<p>计算公式</p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/46/d5/Fv3v7SrT_o.png" width="1029"></p> 
<h4 id="PWM%E6%8E%A7%E5%88%B6%E5%91%BC%E5%90%B8%E7%81%AF%20----------------">PWM控制呼吸灯 ----------------</h4> 
<pre><code>/*
pwm.c    pwm控制呼吸灯
*/
#include "stm32f10x.h"                  // Device header

void PWM_Init(void)
{
	//1.1RCC时钟配置
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);

	//2.1rcc 设置PPIOA时钟和复用口时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//GPIO0配置为复用推挽输出
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	
	//1.2定时器时基初始化
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 100-1;//计数周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 720-1;//psc预分频
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//高级定时器才需要设置
	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);
	
		

	//3.1用于初始化定时器（TIM）的输出比较通道1（TIM_OC1）的功能
	TIM_OCInitTypeDef TIM_OCInitStructure;
	TIM_OCStructInit(&amp;TIM_OCInitStructure);//!!用于初始化定时器的输出比较通道（Output Compare Channel）结构体 防止高级定时器参数过多冲突
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//设置模式为PWM1
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;//高电平有效
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//PWM使能开启 		TIM_OutputNState_Enable
	TIM_OCInitStructure.TIM_Pulse = 0;//占空比百分之10
	
	TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);//定时器通道1PWM初始化
	
	//1.3启动定时器
	TIM_Cmd(TIM2,ENABLE);
	
}



//设置占空比  最后是1 不是L、l
void PWM_SetCompare1(uint16_t Comparel)
{
	TIM_SetCompare1(TIM2,Comparel);//作用是设置 PWM 输出的占空比
}

</code></pre> 
<pre><code>/*
PWM.h
*/
#ifndef _PWM_H
#define _PWM_H

void PWM_Init(void);
void PWM_SetCompare1(uint16_t Comparel);
	
#endif
</code></pre> 
<p></p> 
<pre><code>/*
main
*/
#include "stm32f10x.h"                  // Device header
#include "Shock.h"
#include "Buzzer.h"
#include "Delay.h"
#include "OLED.h"
#include "CountSensor.h"
#include "LED.h"
#include "Timer.h"
#include "PWM.h"

uint16_t i;

int main(void)
{
	OLED_Init();
	PWM_Init();
	
	while (1)
	{
		for (i = 0; i &lt;= 100; i++)
		{
			PWM_SetCompare1(i);
			Delay_ms(10);
		}
		for (i = 0; i &lt;= 100; i++)
		{
			PWM_SetCompare1(100 - i);
			Delay_ms(10);
		}
	}
}

</code></pre> 
<h4 id="PWM%E6%8E%A7%E5%88%B6SG90%E8%88%B5%E6%9C%BA----------------">PWM控制SG90舵机----------------</h4> 
<p> 使用定时器2通道2</p> 
<pre><code>/*
pwm.c pwm.h
*/
#include "stm32f10x.h"                  // Device header

void PWM_Init(void)
{
	//1.1RCC时钟配置
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);

	
	//1.2定时器时基初始化
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 20000-1;//计数周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72-1;//psc预分频
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//高级定时器才需要设置
	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);
	
		
	//2.1rcc 设置PPIOA时钟和复用口时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//GPIO0配置为复用推挽输出
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;		//！！！第二通道对应PA1
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	//3.1用于初始化定时器（TIM）的输出比较通道1（TIM_OC2）的功能
	TIM_OCInitTypeDef TIM_OCInitStructure;
	TIM_OCStructInit(&amp;TIM_OCInitStructure);//!!用于初始化定时器的输出比较通道（Output Compare Channel）结构体
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//设置模式为PWM1
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//PWM使能开启
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;//高电平有效
	TIM_OCInitStructure.TIM_Pulse = 0;//占空比百分之10
	TIM_OC2Init(TIM2,&amp;TIM_OCInitStructure);//----用的定时器2通道 共用CNT寄存器 不同通道设置不同ARR
	
	//1.3启动定时器
	TIM_Cmd(TIM2,ENABLE);
	
}


//设置占空比 用的定时器通道2 接的SG90
void PWM_SetCompare2(uint16_t Compare)
{
	TIM_SetCompare2(TIM2,Compare);//作用是设置 PWM 输出的占空比
}



</code></pre> 
<pre><code>#ifndef _PWM_H
#define _PWM_H

void PWM_Init(void);
void PWM_SetCompare2(uint16_t Compare);
	
#endif
</code></pre> 
<p>SG90.c</p> 
<pre><code>/*
sg90.c
*/
#include "stm32f10x.h"                  // Device header
#include "PWM.h"

//SG90通过PWM初始化成0度
void SG90_Init(void)
{
	PWM_Init();
	PWM_SetCompare2(500);
}

//设置角度
void SG90_SetAngle(uint16_t angle)
{
		PWM_SetCompare2(angle/180*2000 + 500);//2500占空比 180度2500/20000
}
</code></pre> 
<pre><code>/*
sg90.h
*/

#ifndef _SG90_H
#define _SG90_H

//SG90通过PWM初始化成0度
void SG90_Init(void);
//设置角度
void SG90_SetAngle(uint16_t angle);

#endif
</code></pre> 
<h4 id="PWM%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA%E6%A8%A1%E5%9D%97">PWM驱动电机模块</h4> 
<pre><code>/*
pwm.c
*/

#include "stm32f10x.h"                  // Device header

void PWM_Init(void)
{
	//1.1RCC时钟配置
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);

	
	//1.2定时器时基初始化
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 20000-1;//计数周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72-1;//psc预分频
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//高级定时器才需要设置
	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);
	
		
	//2.1rcc 设置PPIOA时钟和复用口时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//GPIO0配置为复用推挽输出
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_2;		//！！！定时器第三通道对应PA2
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	//3.1用于初始化定时器（TIM）的输出比较通道1（TIM_OC2）的功能
	TIM_OCInitTypeDef TIM_OCInitStructure;
	TIM_OCStructInit(&amp;TIM_OCInitStructure);//!!用于初始化定时器的输出比较通道（Output Compare Channel）结构体
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//设置模式为PWM1
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//PWM使能开启
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;//高电平有效
	TIM_OCInitStructure.TIM_Pulse = 0;//占空比百分之10
	TIM_OC2Init(TIM2,&amp;TIM_OCInitStructure);//----用的定时器2通道 共用CNT寄存器 不同通道设置不同ARR
	
	//1.3启动定时器
	TIM_Cmd(TIM2,ENABLE);
	
}


//设置占空比 用的定时器通道3 接的PA2 电机模块
void PWM_SetCompare3(int16_t Compare)
{
	TIM_SetCompare3(TIM2,Compare);//作用是设置 PWM 输出的占空比
}
</code></pre> 
<p><img alt="" height="35" src="https://images2.imgbox.com/e3/5d/SYthPUaY_o.png" width="925"></p> 
<pre><code>/*
Motor.c 电机模块  三根线 正反转PA4 PA5 pwm接PA2定时器2通道3
*/

#include "stm32f10x.h"                  // Device header
#include "PWM.h"

//电机初始化一个接PA4 一个接PA5 一个PWM接PA2
void Motor_Init(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入 看原理图
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_4|GPIO_Pin_5;//接电机正负级
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);//电机初始化
	
	PWM_Init();
	
}

//设置电机速度、一高一低控制方向、pwm控制速度
void Motor_SetSpeed(int16_t Speed)
{
		if(Speed &gt;= 0){
			GPIO_SetBits(GPIOA,GPIO_Pin_4);
			GPIO_ResetBits(GPIOA,GPIO_Pin_5);
			PWM_SetCompare3(Speed);
		}else{
			GPIO_ResetBits(GPIOA,GPIO_Pin_4);
			GPIO_SetBits(GPIOA,GPIO_Pin_5);
			PWM_SetCompare3(-Speed);
		}
}
</code></pre> 
<h4 id="%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E9%A2%91%E7%8E%87" style="background-color:transparent;">输入捕获测频率</h4> 
<p><img alt="" height="455" src="https://images2.imgbox.com/dc/b2/HEu7c6dG_o.png" width="1200"> <img alt="" height="692" src="https://images2.imgbox.com/90/a1/nW9mUuRg_o.png" width="1200"><img alt="" height="680" src="https://images2.imgbox.com/39/6f/EQkA08he_o.png" width="1200"><img alt="" height="652" src="https://images2.imgbox.com/70/61/HpMp6L2n_o.png" width="1200"></p> 
<pre><code>/*
pwm
*/
#include "stm32f10x.h"                  // Device header

void PWM_Init(void)
{
	//1.1RCC时钟配置
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);

	//2.1rcc 设置PPIOA时钟和复用口时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//GPIO0配置为复用推挽输出
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	
	//1.2定时器时基初始化
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 100-1;//计数周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 720-1;//psc预分频
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//高级定时器才需要设置
	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);
	
		

	//3.1用于初始化定时器（TIM）的输出比较通道1（TIM_OC1）的功能
	TIM_OCInitTypeDef TIM_OCInitStructure;
	TIM_OCStructInit(&amp;TIM_OCInitStructure);//!!用于初始化定时器的输出比较通道（Output Compare Channel）结构体 防止高级定时器参数过多冲突
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//设置模式为PWM1
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;//高电平有效
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//PWM使能开启 		TIM_OutputNState_Enable
	TIM_OCInitStructure.TIM_Pulse = 0;//占空比百分之10
	
	TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);//定时器通道1PWM初始化
	
	//1.3启动定时器
	TIM_Cmd(TIM2,ENABLE);
	
}



//设置占空比  最后是1 不是L、l
void PWM_SetCompare1(uint16_t Comparel)
{
	TIM_SetCompare1(TIM2,Comparel);//作用是设置 PWM 输出的占空比
}

//设置PWM的预分频器Perscaler
//允许在运行时修改预分频器的值，而无需重新初始化整个定时器
//参数 TIM2 预分频 TIM_PSCReloadMode_Immediate立即重装载
void PWM_SetPrescaler(uint16_t Perscaler)
{
	TIM_PrescalerConfig(TIM2,Perscaler,TIM_PSCReloadMode_Immediate);
}
	

</code></pre> 
<pre><code>/*
ic输入捕获
*/

#include "stm32f10x.h"                  // Device header

//输入捕获
//PA0发送占空比为50 预分频720的信号到PA6 PA6设置输入捕获获取PA0的频率并显示
void IC_Init(void)
{
	//RCC
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
	TIM_InternalClockConfig(TIM3);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	
	//时基
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;//计数周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;//psc预分频
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//高级定时器才有
	TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);
	
	//GPIO
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;//PA6
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//频率为50嘛MHz
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	//输入捕获单元 用于初始化捕获通道、滤波器、捕获极性、映射关系和分频系数等参数
	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;//通道
	TIM_ICInitStructure.TIM_ICFilter = 0xF;	//滤波器滤除干扰 越大越好
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;//极性 上升沿触发
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;		//不分频
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;//直连输入！！  交叉输入
	TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);
	
	//触发源 定时器3 通过TI1端（PA6）作为外部触发输入引脚的第1个边沿检测输入
	TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);
	
	//从模式用于选择定时器的从模式  复位从模式
	TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);
	
	//开启定时器
	TIM_Cmd(TIM3,ENABLE);
}

//获取频率
uint32_t IC_GetFreq(void)
{
	//fx = fc/N 
	return 1000000 / (TIM_GetCapture1(TIM3) + 1);//N=10000 72MHz/720 TIM_GetCapture1获取定时器3捕获通道1的值
}
</code></pre> 
<p></p> 
<pre><code>#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"


int main(void)
{
	OLED_Init();
	PWM_Init();
	IC_Init();

	
	OLED_ShowString(1,1,"Freq:00000Hz");
	PWM_SetPrescaler(72 - 1);//设置预分频系数 Freq = 72MHz/psc+1/ARR+1 = 10000  PSC = 72000000/(psc+1)/100
	PWM_SetCompare1(50);//设置占空比			Duty = CCR/100;

	
	while (1)
	{
		OLED_ShowNum(1,6,IC_GetFreq(),5);
	}
}

	
</code></pre> 
<h4 id="%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E5%8D%A0%E7%A9%BA%E6%AF%94">输入捕获测占空比</h4> 
<p><img alt="" height="641" src="https://images2.imgbox.com/9e/17/5n1MEaY6_o.png" width="1200"></p> 
<pre><code class="hljs">#include "stm32f10x.h"                  // Device header

void PWM_Init(void)
{
	//1.1RCC时钟配置
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);

	//2.1rcc 设置PPIOA时钟和复用口时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//GPIO0配置为复用推挽输出
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Speed= GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	
	//1.2定时器时基初始化
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 100-1;//计数周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 720-1;//psc预分频
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//高级定时器才需要设置
	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);
	
		

	//3.1用于初始化定时器（TIM）的输出比较通道1（TIM_OC1）的功能
	TIM_OCInitTypeDef TIM_OCInitStructure;
	TIM_OCStructInit(&amp;TIM_OCInitStructure);//!!用于初始化定时器的输出比较通道（Output Compare Channel）结构体 防止高级定时器参数过多冲突
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//设置模式为PWM1
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;//高电平有效
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//PWM使能开启 		TIM_OutputNState_Enable
	TIM_OCInitStructure.TIM_Pulse = 0;//占空比百分之10
	
	TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);//定时器通道1PWM初始化
	
	//1.3启动定时器
	TIM_Cmd(TIM2,ENABLE);
	
}



//设置占空比  最后是1 不是L、l
void PWM_SetCompare1(uint16_t Comparel)
{
	TIM_SetCompare1(TIM2,Comparel);//作用是设置 PWM 输出的占空比
}

//设置PWM的预分频器Perscaler
//允许在运行时修改预分频器的值，而无需重新初始化整个定时器
//参数 TIM2 预分频 TIM_PSCReloadMode_Immediate立即重装载
void PWM_SetPrescaler(uint16_t Perscaler)
{
	TIM_PrescalerConfig(TIM2,Perscaler,TIM_PSCReloadMode_Immediate);
}
	

</code></pre> 
<pre><code class="hljs">#include "stm32f10x.h"                  // Device header

//输入捕获
//PA0发送占空比为50 预分频720的信号到PA6 PA6设置输入捕获获取PA0的频率并显示
void IC_Init(void)
{
	//RCC
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
	TIM_InternalClockConfig(TIM3);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	
	//时基
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//不分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;//计数周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;//psc预分频
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//高级定时器才有
	TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);
	
	//GPIO
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;//PA6
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//频率为50嘛MHz
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	//输入捕获单元 用于初始化捕获通道、滤波器、捕获极性、映射关系和分频系数等参数
	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;//通道
	TIM_ICInitStructure.TIM_ICFilter = 0xF;	//滤波器滤除干扰 越大越好
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;//极性 上升沿触发
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;		//不分频
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;//直连输入！！  交叉输入
	TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);//~~~~!!!!!配置与前面的相反 通道2 下降沿 不分频 交叉输入
	
	TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);
	
	//触发源 定时器3 通过TI1端（PA6）作为外部触发输入引脚的第1个边沿检测输入
	TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);
	
	//从模式用于选择定时器的从模式  复位从模式
	TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);
	
	//开启定时器
	TIM_Cmd(TIM3,ENABLE);
}

//获取频率			 两个一样的标准72频率 占周期N的分之一
uint32_t IC_GetFreq(void)
{
	//fx = fc/N 一格/N格 即周期分之一 就是频率
	return 1000000 / (TIM_GetCapture1(TIM3) + 1);//N=100000 72MHz/720 TIM_GetCapture1获取定时器3捕获通道1的值
}					//TIM_GetCapture1捕获的是计数器的值。当定时器溢出时，计数器的值会被自动重置为0

//获取占空比
uint32_t IC_GetDuty(void)
{
	//获取通道2的N的次数单次		总的次数放在通道1中计数			
	return (TIM_GetCapture2(TIM3) * 100) / (TIM_GetCapture1(TIM3) + 1);
}
</code></pre> 
<p> </p> 
<pre><code class="hljs">#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"

int  main(void)
{
	OLED_Init();
	PWM_Init();
	IC_Init();

	
	OLED_ShowString(1,1,"Freq:00000Hz");
	OLED_ShowString(2,1,"Duty:00%");
	PWM_SetPrescaler(7200 - 1);//设置预分频系数 Freq = 72MHz/psc+1/ARR+1 = 10000  PSC = 72000000/(psc+1)/100
	PWM_SetCompare1(80);//设置占空比			Duty = CCR/100;

	
	while (1)
	{
		OLED_ShowNum(1,6,IC_GetFreq(),5);
		OLED_ShowNum(2,6,IC_GetDuty(),2);
	}
}

	
</code></pre> 
<h4 id="%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%95%B0">输入捕获编码器计数</h4> 
<p><img alt="" height="185" src="https://images2.imgbox.com/c9/90/IvrXmnBo_o.png" width="1037"></p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/a7/f9/tnautEsC_o.png" width="1200"> </p> 
<p><img alt="" height="647" src="https://images2.imgbox.com/2c/42/7WWxEHME_o.png" width="1200"> <img alt="" height="508" src="https://images2.imgbox.com/c2/7a/MVe7lgKy_o.png" width="1143"></p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/ad/d9/R9zEjpJL_o.png" width="1026"> </p> 
<blockquote> 
 <p>TIM_EncoderInterfaceConfig 是一个用于配置定时器编码器接口参数的函数。这个函数通常在STM32微控制器编程中使用，用于设置定时器的编码器模式、分辨率等参数。</p> 
 <p>函数原型：</p> 
 <pre></pre> 
 <p><code>c复制代码</code></p> 
 <p><code>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t EncoderMode, uint16_t IC1Filter, uint16_t IC1Polarity, uint16_t IC1Selection, uint16_t IC2Filter, uint16_t IC2Polarity, uint16_t IC2Selection); </code></p> 
 <p>参数：</p> 
 <ul><li>TIMx：定时器模块的实例，可以是 TIM2、TIM3、TIM4、TIM5 等。</li><li>EncoderMode：编码器模式，可以是 TIM_EncoderMode_TI12、TIM_EncoderMode_TI1、TIM_EncoderMode_TI2 或 TIM_EncoderMode_TI4。</li><li>IC1Filter：输入滤波器1的值，用于设置输入信号的滤波程度。</li><li>IC1Polarity：输入极性1的值，用于设置输入信号的极性。</li><li>IC1Selection：输入选择1的值，用于选择输入通道。</li><li>IC2Filter：输入滤波器2的值，用于设置输入信号的滤波程度。</li><li>IC2Polarity：输入极性2的值，用于设置输入信号的极性。</li><li>IC2Selection：输入选择2的值，用于选择输入通道。</li></ul> 
</blockquote> 
<pre><code class="hljs">#include "stm32f10x.h"                  // Device header

//编码器配置
void Encoder_Init(void)
{
	//RCC时钟配置
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
	TIM_InternalClockConfig(TIM3);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	
	//时基 使用定时器3 因为定时器2到普通时钟了
	TIM_TimeBaseInitTypeDef TIM_TimeBaseIniitStructure;
	TIM_TimeBaseIniitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//预分频因子 不分频
	TIM_TimeBaseIniitStructure.TIM_CounterMode = TIM_CounterMode_Up;//定时器模式为向上计数
	TIM_TimeBaseIniitStructure.TIM_Period = 65536-1;//计数周期为16为寄存器挤满65536
	TIM_TimeBaseIniitStructure.TIM_Prescaler = 1-1;//不分频
	TIM_TimeBaseIniitStructure.TIM_RepetitionCounter = 0;//高级定时器才有
	TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseIniitStructure);
	
	//GPIO初始化配置
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//引脚模式为上拉输入
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	//PWM输入捕获配置
	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_ICStructInit(&amp;TIM_ICInitStructure);//参数过多没有配置 放入结构体中防止冲突
	
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;//输入捕获 定时器通道1
	TIM_ICInitStructure.TIM_ICFilter = 0xF;//滤波器越大越好
	TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);//配置完输入捕获通道1 写入寄存器中
	
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;//输入捕获 定时器通道2
	TIM_ICInitStructure.TIM_ICFilter = 0xF;//滤波器越大越好
	TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);//配置完输入捕获通道2 写入寄存器中
	
	
	//Encoder配置 里面极性TIM_ICPolarity_Rising 会覆盖输入捕获中的极性  必须在后面 前面极性可省略
	TIM_EncoderInterfaceConfig(TIM3,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);
	
	//开启时钟
	TIM_Cmd(TIM3,ENABLE);
	
}

//获取count值
int16_t Encoder_Get(void)
{
	int16_t Temp;
	Temp  = TIM_GetCounter(TIM3);//用于获取定时器计数器的函数
	TIM_SetCounter(TIM3,0);     //用于设置定时器计数器的函数
	return Temp;
}

</code></pre> 
<p> </p> 
<pre><code class="hljs">#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "Timer.h"
#include "Encoder.h"

int16_t Speed;

int  main(void)
{
	OLED_Init();
	PWM_Init();
	Encoder_Init();
	Timer_Init();
	
	OLED_ShowString(1,1,"Speed:");
	while (1)
	{
		OLED_ShowSignedNum(1,7,Speed,5);
	}
}

void TIM2_IRQHandler(void)//每秒钟获取以下speed速度
{
	if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)
	{
		Speed = Encoder_Get();
		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//用于清除定时器的某个中断挂起位的状态 以便重新激活
	}
}

</code></pre> 
<pre><code class="hljs">/*
定时器
*/
#include "stm32f10x.h"                  // Device header
#include "LED.h" 

void Timer_Init(void)
{	
	
	//设置时钟挂在APB1时钟上 为内部时钟72MHz
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	TIM_InternalClockConfig(TIM2);
	
	//配置时基 72000000/7200/10000 = 1s
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//几分频
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 10000-1;//周期
	TIM_TimeBaseInitStructure.TIM_Prescaler = 7200-1;//psc获取定时器的预分频系数。这个参数决定了定时器的计数频率
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;//设置重复计数值 溢出增加计数 高级定时器才能用
    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);
	
	
	//设置运行控制 当指定的更新事件（通常是TIM_UpdateFlag）发生时，使能定时器的中断
	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
	
	//设置中断控制分组
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	//设置中断控制
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;//中断通道
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能中断
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;//抢占优先级 --根据分组
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;//响应优先级
	NVIC_Init(&amp;NVIC_InitStructure);
	
	//启动定时器
	TIM_Cmd(TIM2,ENABLE);
	
}
//void TIM2_IRQHandler(void) 是否在主函数中调用了
//{
//	if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)
//	{
//		LED1_Turn();
//		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);//用于清除定时器的某个中断挂起位的状态 以便重新激活
//	}
//}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53c3251d09eb0a9eed347f1748c06d7f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java课程设计——图书管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fcd69ec3118edfbd60a18f3b6f004a62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">并行Stream的性能测试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>