<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>树子类遍历父类_Java中的屠龙之术——如何修改语法树？ - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="树子类遍历父类_Java中的屠龙之术——如何修改语法树？" />
<meta property="og:description" content="面试终败“高并发”，25天苦心钻研，居然整出一份并发宝典？都是“算法”惹的祸，字节三面处处坑，我的offer要凉了？春招指南之“性能调优”：MySQL&#43;Tomcat&#43;JVM，还怕面试官的轰炸？ JCTree的介绍 JCTree是语法树元素的基类，包含一个重要的字段pos，该字段用于指明当前语法树节点(JCTree)在语法树中的位置，因此我们不能直接用new关键字来创建语法树节点，即使创建了也没有意义。此外，结合访问者模式，将数据结构与数据的处理进行解耦，部分源码如下：
1public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition { 2 3 public int pos = -1; 4 5 ... 6 7 public abstract void accept(JCTree.Visitor visitor); 8 9 ...10} 我们可以看到JCTree是一个抽象类，这里重点介绍几个JCTree的子类
JCStatement：声明语法树节点，常见的子类如下 JCBlock：语句块语法树节点 JCReturn：return语句语法树节点 JCClassDecl：类定义语法树节点 JCVariableDecl：字段/变量定义语法树节点JCMethodDecl：方法定义语法树节点JCModifiers：访问标志语法树节点JCExpression：表达式语法树节点，常见的子类如下 JCAssign：赋值语句语法树节点 JCIdent：标识符语法树节点，可以是变量，类型，关键字等等 TreeMaker介绍 TreeMaker用于创建一系列的语法树节点，我们上面说了创建JCTree不能直接使用new关键字来创建，所以Java为我们提供了一个工具，就是TreeMaker，它会在创建时为我们创建的JCTree对象设置pos字段，所以必须使用上下文相关的TreeMaker对象来创建语法树节点。
具体的API介绍可以参照，TreeMakerAPI，接下来着重介绍一下常用的几个方法。
TreeMaker.Modifiers TreeMaker.Modifiers方法用于创建访问标志语法树节点(JCModifiers)，源码如下
1public JCModifiers Modifiers(long flags) { 2 return Modifiers(flags, List.nil()); 3} 4 5public JCModifiers Modifiers(long flags, 6 List annotations) { 7 JCModifiers tree = new JCModifiers(flags, annotations); 8 boolean noFlags = (flags &amp; (Flags." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/15410d008ff09078c45a63cea8c0af3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-12T18:17:24+08:00" />
<meta property="article:modified_time" content="2021-01-12T18:17:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">树子类遍历父类_Java中的屠龙之术——如何修改语法树？</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <ul><li><strong>面试终败“高并发”，25天苦心钻研，居然整出一份并发宝典？</strong></li><li><strong>都是“算法”惹的祸，字节三面处处坑，我的offer要凉了？</strong></li><li><strong>春招指南之“性能调优”：MySQL+Tomcat+JVM，还怕面试官的轰炸？</strong></li></ul> 
 <h2 class="pgc-h-arrow-right">JCTree的介绍</h2> 
 <p>JCTree是语法树元素的基类，包含一个重要的字段pos，该字段用于指明当前语法树节点(JCTree)在语法树中的位置，因此我们不能直接用new关键字来创建语法树节点，即使创建了也没有意义。此外，结合访问者模式，将数据结构与数据的处理进行解耦，部分源码如下：</p> 
 <pre class="has"><code> 1public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition { 2 3    public int pos = -1; 4 5    ... 6 7    public abstract void accept(JCTree.Visitor visitor); 8 9    ...10}</code></pre> 
 <p>我们可以看到JCTree是一个抽象类，这里重点介绍几个JCTree的子类</p> 
 <ol start="1"><li>JCStatement：<strong>声明</strong>语法树节点，常见的子类如下 JCBlock：<strong>语句块</strong>语法树节点 JCReturn：<strong>return语句</strong>语法树节点 JCClassDecl：<strong>类定义</strong>语法树节点 JCVariableDecl：<strong>字段/变量定义</strong>语法树节点</li><li>JCMethodDecl：<strong>方法定义</strong>语法树节点</li><li>JCModifiers：<strong>访问标志</strong>语法树节点</li><li>JCExpression：<strong>表达式</strong>语法树节点，常见的子类如下 JCAssign：<strong>赋值语句</strong>语法树节点 JCIdent：<strong>标识符</strong>语法树节点，可以是变量，类型，关键字等等</li></ol> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/f6/4e/Yr7mNxc0_o.png" alt="2628c60f78101e605975328ffe735838.png"> 
 </div> 
 <h2 class="pgc-h-arrow-right">TreeMaker介绍</h2> 
 <p>TreeMaker用于创建一系列的语法树节点，我们上面说了创建JCTree不能直接使用new关键字来创建，所以Java为我们提供了一个工具，就是TreeMaker，它会在创建时为我们创建的JCTree对象设置pos字段，所以必须使用上下文相关的TreeMaker对象来创建语法树节点。</p> 
 <p>具体的API介绍可以参照，TreeMakerAPI，接下来着重介绍一下常用的几个方法。</p> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Modifiers</h2> 
 <p>TreeMaker.Modifiers方法用于创建<strong>访问标志</strong>语法树节点(JCModifiers)，源码如下</p> 
 <pre class="has"><code> 1public JCModifiers Modifiers(long flags) { 2    return Modifiers(flags, List.nil()); 3} 4 5public JCModifiers Modifiers(long flags, 6    List annotations) { 7        JCModifiers tree = new JCModifiers(flags, annotations); 8        boolean noFlags = (flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0; 9        tree.pos = (noFlags &amp;&amp; annotations.isEmpty()) ? Position.NOPOS : pos;10        return tree;11}</code></pre> 
 <ol start="1"><li>flags：访问标志</li><li>annotations：注解列表</li></ol> 
 <p>其中flags可以使用枚举类com.sun.tools.javac.code.Flags来表示，例如我们可以这样用，就生成了下面的访问标志了。</p> 
 <pre class="has"><code>1treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL);23public static final</code></pre> 
 <h2 class="pgc-h-arrow-right">TreeMaker.ClassDef</h2> 
 <p>TreeMaker.ClassDef用于创建<strong>类定义</strong>语法树节点(JCClassDecl),源码如下：</p> 
 <pre class="has"><code> 1public JCClassDecl ClassDef(JCModifiers mods, 2    Name name, 3    List typarams, 4    JCExpression extending, 5    List implementing, 6    List defs) { 7        JCClassDecl tree = new JCClassDecl(mods, 8                                     name, 9                                     typarams,10                                     extending,11                                     implementing,12                                     defs,13                                     null);14        tree.pos = pos;15        return tree;16}</code></pre> 
 <ol start="1"><li>mods：访问标志，可以通过TreeMaker.Modifiers来创建</li><li>name：类名</li><li>typarams：泛型参数列表</li><li>extending：父类</li><li>implementing：实现的接口</li><li>defs：类定义的详细语句，包括字段、方法的定义等等</li></ol> 
 <h2 class="pgc-h-arrow-right">TreeMaker.MethodDef</h2> 
 <p>TreeMaker.MethodDef用于创建<strong>方法定义</strong>语法树节点(JCMethodDecl)，源码如下</p> 
 <pre class="has"><code> 1public JCMethodDecl MethodDef(JCModifiers mods, 2    Name name, 3    JCExpression restype, 4    List typarams, 5    List params, 6    List thrown, 7    JCBlock body, 8    JCExpression defaultValue) { 9        JCMethodDecl tree = new JCMethodDecl(mods,10                                       name,11                                       restype,12                                       typarams,13                                       params,14                                       thrown,15                                       body,16                                       defaultValue,17                                       null);18        tree.pos = pos;19        return tree;20}2122public JCMethodDecl MethodDef(MethodSymbol m,23    Type mtype,24    JCBlock body) {25        return (JCMethodDecl)26            new JCMethodDecl(27                Modifiers(m.flags(), Annotations(m.getAnnotationMirrors())),28                m.name,29                Type(mtype.getReturnType()),30                TypeParams(mtype.getTypeArguments()),31                Params(mtype.getParameterTypes(), m),32                Types(mtype.getThrownTypes()),33                body,34                null,35                m).setPos(pos).setType(mtype);36}</code></pre> 
 <ol start="1"><li>mods：访问标志</li><li>name：方法名</li><li>restype：返回类型</li><li>typarams：泛型参数列表</li><li>params：参数列表</li><li>thrown：异常声明列表</li><li>body：方法体</li><li>defaultValue：默认方法(可能是interface中的哪个default)</li><li>m：方法符号</li><li>mtype：方法类型。包含多种类型，泛型参数类型、方法参数类型、异常参数类型、返回参数类型。</li></ol> 
 <blockquote> 
  <p>返回类型restype填写null或者treeMaker.TypeIdent(TypeTag.VOID)都代表返回void类型</p> 
 </blockquote> 
 <h2 class="pgc-h-arrow-right">TreeMaker.VarDef</h2> 
 <p>TreeMaker.VarDef用于创建<strong>字段/变量定义</strong>语法树节点(JCVariableDecl)，源码如下</p> 
 <pre class="has"><code> 1public JCVariableDecl VarDef(JCModifiers mods, 2    Name name, 3    JCExpression vartype, 4    JCExpression init) { 5        JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null); 6        tree.pos = pos; 7        return tree; 8} 910public JCVariableDecl VarDef(VarSymbol v,11    JCExpression init) {12        return (JCVariableDecl)13            new JCVariableDecl(14                Modifiers(v.flags(), Annotations(v.getAnnotationMirrors())),15                v.name,16                Type(v.type),17                init,18                v).setPos(pos).setType(v.type);19}</code></pre> 
 <ol start="1"><li>mods：访问标志</li><li>name：参数名称</li><li>vartype：类型</li><li>init：初始化语句</li><li>v：变量符号</li></ol> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Ident</h2> 
 <p>TreeMaker.Ident用于创建<strong>标识符</strong>语法树节点(JCIdent)，源码如下</p> 
 <pre class="has"><code> 1public JCIdent Ident(Name name) { 2        JCIdent tree = new JCIdent(name, null); 3        tree.pos = pos; 4        return tree; 5} 6 7public JCIdent Ident(Symbol sym) { 8        return (JCIdent)new JCIdent((sym.name != names.empty) 9                                ? sym.name10                                : sym.flatName(), sym)11            .setPos(pos)12            .setType(sym.type);13}1415public JCExpression Ident(JCVariableDecl param) {16        return Ident(param.sym);17}</code></pre> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Return</h2> 
 <p>TreeMaker.Return用于创建<strong>return语句</strong>(JCReturn)，源码如下</p> 
 <pre class="has"><code>1public JCReturn Return(JCExpression expr) {2        JCReturn tree = new JCReturn(expr);3        tree.pos = pos;4        return tree;5}</code></pre> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Select</h2> 
 <p>TreeMaker.Select用于创建<strong>域访问/方法访问</strong>(这里的方法访问只是取到名字，方法的调用需要用TreeMaker.Apply)语法树节点(JCFieldAccess)，源码如下</p> 
 <pre class="has"><code> 1public JCFieldAccess Select(JCExpression selected, 2    Name selector)  3{ 4        JCFieldAccess tree = new JCFieldAccess(selected, selector, null); 5        tree.pos = pos; 6        return tree; 7} 8 9public JCExpression Select(JCExpression base,10    Symbol sym) {11        return new JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);12}</code></pre> 
 <ol start="1"><li>selected：.运算符左边的表达式</li><li>selector：.运算符右边的表达式</li></ol> 
 <p>下面给出一个例子，一语句生成的Java语句就是二语句</p> 
 <pre class="has"><code>1一. TreeMaker.Select(treeMaker.Ident(names.fromString("this")), names.fromString("name"));23二. this.name</code></pre> 
 <h2 class="pgc-h-arrow-right">TreeMaker.NewClass</h2> 
 <p>TreeMaker.NewClass用于创建<strong>new语句</strong>语法树节点(JCNewClass),源码如下：</p> 
 <pre class="has"><code>1public JCNewClass NewClass(JCExpression encl,2    List typeargs,3    JCExpression clazz,4    List args,5    JCClassDecl def) {6        JCNewClass tree = new JCNewClass(encl, typeargs, clazz, args, def);7        tree.pos = pos;8        return tree;9}</code></pre> 
 <ol start="1"><li>encl：不太明白此参数的含义，我看很多例子中此参数都设置为null</li><li>typeargs：参数类型列表</li><li>clazz：待创建对象的类型</li><li>args：参数列表</li><li>def：类定义</li></ol> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Apply</h2> 
 <p>TreeMaker.Apply用于创建<strong>方法调用</strong>语法树节点(JCMethodInvocation)，源码如下：</p> 
 <pre class="has"><code>1public JCMethodInvocation Apply(List typeargs,2    JCExpression fn,3    List args) {4        JCMethodInvocation tree = new JCMethodInvocation(typeargs, fn, args);5        tree.pos = pos;6        return tree;7}</code></pre> 
 <ol start="1"><li>typeargs：参数类型列表</li><li>fn：调用语句</li><li>args：参数列表</li></ol> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Assign</h2> 
 <p>TreeMaker.Assign用户创建<strong>赋值语句</strong>语法树节点(JCAssign)，源码如下：</p> 
 <pre class="has"><code>1ublic JCAssign Assign(JCExpression lhs,2    JCExpression rhs) {3        JCAssign tree = new JCAssign(lhs, rhs);4        tree.pos = pos;5        return tree;6}</code></pre> 
 <ol start="1"><li>lhs：赋值语句左边表达式</li><li>rhs：赋值语句右边表达式</li></ol> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Exec</h2> 
 <p>TreeMaker.Exec用于创建<strong>可执行语句</strong>语法树节点(JCExpressionStatement)，源码如下：</p> 
 <pre class="has"><code>1public JCExpressionStatement Exec(JCExpression expr) {2        JCExpressionStatement tree = new JCExpressionStatement(expr);3        tree.pos = pos;4        return tree;5}</code></pre> 
 <blockquote> 
  <p>TreeMaker.Apply以及TreeMaker.Assign就需要外面包一层TreeMaker.Exec来获得一个JCExpressionStatement</p> 
 </blockquote> 
 <h2 class="pgc-h-arrow-right">TreeMaker.Block</h2> 
 <p>TreeMaker.Block用于创建<strong>组合语句</strong>的语法树节点(JCBlock)，源码如下：</p> 
 <pre class="has"><code>1public JCBlock Block(long flags,2    List stats) {3        JCBlock tree = new JCBlock(flags, stats);4        tree.pos = pos;5        return tree;6}</code></pre> 
 <ol start="1"><li>flags：访问标志</li><li>stats：语句列表</li></ol> 
 <h2 class="pgc-h-arrow-right">com.sun.tools.javac.util.List介绍</h2> 
 <p>在我们操作抽象语法树的时候，有时会涉及到关于List的操作，但是这个List不是我们经常使用的java.util.List而是com.sun.tools.javac.util.List，这个List比较奇怪，是一个链式的结构，有头结点和尾节点，但是只有尾节点是一个List，这里作为了解就行了。</p> 
 <pre class="has"><code> 1public class List extends AbstractCollection implements java.util.List { 2    public A head; 3    public List tail; 4    private static final List&gt; EMPTY_LIST = new List((Object)null, (List)null) { 5        public List setTail(List var1) { 6            throw new UnsupportedOperationException(); 7        } 8 9        public boolean isEmpty() {10            return true;11        }12    };1314    List(A head, List tail) {15        this.tail = tail;16        this.head = head;17    }1819    public static  List nil() {20        return EMPTY_LIST;21    }2223    public List prepend(A var1) {24        return new List(var1, this);25    }2627    public List append(A var1) {28        return of(var1).prependList(this);29    }3031    public static  List of(A var0) {32        return new List(var0, nil());33    }3435    public static  List of(A var0, A var1) {36        return new List(var0, of(var1));37    }3839    public static  List of(A var0, A var1, A var2) {40        return new List(var0, of(var1, var2));41    }4243    public static  List of(A var0, A var1, A var2, A... var3) {44        return new List(var0, new List(var1, new List(var2, from(var3))));45    }4647    ...48}</code></pre> 
 <h2 class="pgc-h-arrow-right">com.sun.tools.javac.util.ListBuffer</h2> 
 <p>由于com.sun.tools.javac.util.List使用起来不方便，所以又在其上面封装了一层，这个封装类是ListBuffer，此类的操作和我们平时经常使用的java.util.List用法非常类似。</p> 
 <pre class="has"><code> 1public class ListBuffer extends AbstractQueue { 2 3    public static  ListBuffer of(T x) { 4        ListBuffer lb = new ListBuffer(); 5        lb.add(x); 6        return lb; 7    } 8 9    /** The list of elements of this buffer.10     */11    private List elems;1213    /** A pointer pointing to the last element of 'elems' containing data,14     *  or null if the list is empty.15     */16    private List last;1718    /** The number of element in this buffer.19     */20    private int count;2122    /** Has a list been created from this buffer yet?23     */24    private boolean shared;2526    /** Create a new initially empty list buffer.27     */28    public ListBuffer() {29        clear();30    }3132    /** Append an element to buffer.33     */34    public ListBuffer append(A x) {35        x.getClass(); // null check36        if (shared) copy();37        List newLast = List.of(x);38        if (last != null) {39            last.tail = newLast;40            last = newLast;41        } else {42            elems = last = newLast;43        }44        count++;45        return this;46    }47    ........48}</code></pre> 
 <h2 class="pgc-h-arrow-right">com.sun.tools.javac.util.Names介绍</h2> 
 <p>这个是为我们创建名称的一个工具类，无论是类、方法、参数的名称都需要通过此类来创建。它里面经常被使用到的一个方法就是fromString()，一般使用方法如下所示。</p> 
 <pre class="has"><code>1Names names  = new Names()2names. fromString("setName");</code></pre> 
 <h2 class="pgc-h-arrow-right">实战演练</h2> 
 <p>上面我们大概了解了如何操作抽象语法树，接下来我们就来写几个真实的案例加深理解。</p> 
 <h2 class="pgc-h-arrow-right">变量相关</h2> 
 <p>在类中我们经常操作的参数就是变量，那么如何使用抽象语法树的特性为我们操作变量呢？接下来我们就将一些对于变量的一些操作。</p> 
 <h2 class="pgc-h-arrow-right">生成变量</h2> 
 <p>例如生成private String age;这样一个变量，借用我们上面讲的VarDef方法</p> 
 <pre class="has"><code>1// 生成参数 例如：private String age;2treeMaker.VarDef(treeMaker.Modifiers(Flags.PRIVATE), names.fromString("age"), treeMaker.Ident(names.fromString("String")), null);</code></pre> 
 <h2 class="pgc-h-arrow-right">对变量赋值</h2> 
 <p>例如我们想生成private String name = "BuXueWuShu"，还是利用VarDef方法</p> 
 <pre class="has"><code>1// private String name = "BuXueWuShu"2treeMaker.VarDef(treeMaker.Modifiers(Flags.PRIVATE),names.fromString("name"),treeMaker.Ident(names.fromString("String")),treeMaker.Literal("BuXueWuShu"))</code></pre> 
 <h2 class="pgc-h-arrow-right">两个字面量相加</h2> 
 <p>例如我们生成String add = "a" + "b";，借用我们上面讲的Exec方法和Assign方法</p> 
 <pre class="has"><code>1// add = "a"+"b"2treeMaker.Exec(treeMaker.Assign(treeMaker.Ident(names.fromString("add")),treeMaker.Binary(JCTree.Tag.PLUS,treeMaker.Literal("a"),treeMaker.Literal("b"))))</code></pre> 
 <h2 class="pgc-h-arrow-right">+=语法</h2> 
 <p>例如我们想生成add += "test"，则和上面字面量差不多。</p> 
 <pre class="has"><code>1// add+="test"2treeMaker.Exec(treeMaker.Assignop(JCTree.Tag.PLUS_ASG, treeMaker.Ident(names.fromString("add")), treeMaker.Literal("test")))</code></pre> 
 <h2 class="pgc-h-arrow-right">++语法</h2> 
 <p>例如想生成++i</p> 
 <pre class="has"><code>1treeMaker.Exec(treeMaker.Unary(JCTree.Tag.PREINC,treeMaker.Ident(names.fromString("i"))))</code></pre> 
 <h2 class="pgc-h-arrow-right">方法相关</h2> 
 <p>我们对于变量进行了操作，那么基本上都是要生成方法的，那么如何对方法进行生成和操作呢？我们接下来演示一下关于方法相关的操作方法。</p> 
 <h2 class="pgc-h-arrow-right">无参无返回值</h2> 
 <p>我们可以利用上面讲到的MethodDef方法进行生成</p> 
 <pre class="has"><code> 1/* 2    无参无返回值的方法生成 3    public void test(){ 4 5    } 6 */ 7// 定义方法体 8ListBuffer testStatement = new ListBuffer&lt;&gt;(); 9JCTree.JCBlock testBody = treeMaker.Block(0, testStatement.toList());1011JCTree.JCMethodDecl test = treeMaker.MethodDef(12        treeMaker.Modifiers(Flags.PUBLIC), // 方法限定值13        names.fromString("test"), // 方法名14        treeMaker.Type(new Type.JCVoidType()), // 返回类型15        com.sun.tools.javac.util.List.nil(),16        com.sun.tools.javac.util.List.nil(),17        com.sun.tools.javac.util.List.nil(),18        testBody,    // 方法体19        null20);</code></pre> 
 <h2 class="pgc-h-arrow-right">有参无返回值</h2> 
 <p>我们可以利用上面讲到的MethodDef方法进行生成</p> 
 <pre class="has"><code> 1/* 2    无参无返回值的方法生成 3    public void test2(String name){ 4        name = "xxxx"; 5    } 6 */ 7ListBuffer testStatement2 = new ListBuffer&lt;&gt;(); 8testStatement2.append(treeMaker.Exec(treeMaker.Assign(treeMaker.Ident(names.fromString("name")),treeMaker.Literal("xxxx")))); 9JCTree.JCBlock testBody2 = treeMaker.Block(0, testStatement2.toList());1011// 生成入参12JCTree.JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER), names.fromString("name"),treeMaker.Ident(names.fromString("String")), null);13com.sun.tools.javac.util.List parameters = com.sun.tools.javac.util.List.of(param);1415JCTree.JCMethodDecl test2 = treeMaker.MethodDef(16        treeMaker.Modifiers(Flags.PUBLIC), // 方法限定值17        names.fromString("test2"), // 方法名18        treeMaker.Type(new Type.JCVoidType()), // 返回类型19        com.sun.tools.javac.util.List.nil(),20        parameters, // 入参21        com.sun.tools.javac.util.List.nil(),22        testBody2,23        null24);</code></pre> 
 <h2 class="pgc-h-arrow-right">有参有返回值</h2> 
 <pre class="has"><code> 1 /* 2    有参有返回值 3    public String test3(String name){ 4       return name; 5    } 6 */ 7 8ListBuffer testStatement3 = new ListBuffer&lt;&gt;(); 9testStatement3.append(treeMaker.Return(treeMaker.Ident(names.fromString("name"))));10JCTree.JCBlock testBody3 = treeMaker.Block(0, testStatement3.toList());1112// 生成入参13JCTree.JCVariableDecl param3 = treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER), names.fromString("name"),treeMaker.Ident(names.fromString("String")), null);14com.sun.tools.javac.util.List parameters3 = com.sun.tools.javac.util.List.of(param3);1516JCTree.JCMethodDecl test3 = treeMaker.MethodDef(17        treeMaker.Modifiers(Flags.PUBLIC), // 方法限定值18        names.fromString("test4"), // 方法名19        treeMaker.Ident(names.fromString("String")), // 返回类型20        com.sun.tools.javac.util.List.nil(),21        parameters3, // 入参22        com.sun.tools.javac.util.List.nil(),23        testBody3,24        null25);</code></pre> 
 <h2 class="pgc-h-arrow-right">特殊的</h2> 
 <p>我们学完了如何进行定义参数，如何进行定义方法，其实还有好多语句需要学习，例如如何生成new语句，如何生成方法调用的语句，如何生成if语句。j接下来我们就学习一些比较特殊的语法。</p> 
 <h2 class="pgc-h-arrow-right">new一个对象</h2> 
 <pre class="has"><code> 1// 创建一个new语句 CombatJCTreeMain combatJCTreeMain = new CombatJCTreeMain(); 2JCTree.JCNewClass combatJCTreeMain = treeMaker.NewClass( 3        null, 4        com.sun.tools.javac.util.List.nil(), 5        treeMaker.Ident(names.fromString("CombatJCTreeMain")), 6        com.sun.tools.javac.util.List.nil(), 7        null 8); 9JCTree.JCVariableDecl jcVariableDecl1 = treeMaker.VarDef(10        treeMaker.Modifiers(Flags.PARAMETER),11        names.fromString("combatJCTreeMain"),12        treeMaker.Ident(names.fromString("CombatJCTreeMain")),13        combatJCTreeMain14);</code></pre> 
 <h2 class="pgc-h-arrow-right">方法调用(无参)</h2> 
 <pre class="has"><code> 1JCTree.JCExpressionStatement exec = treeMaker.Exec( 2        treeMaker.Apply( 3                com.sun.tools.javac.util.List.nil(), 4                treeMaker.Select( 5                        treeMaker.Ident(names.fromString("combatJCTreeMain")), // . 左边的内容 6                        names.fromString("test") // . 右边的内容 7                ), 8                com.sun.tools.javac.util.List.nil() 9        )10);</code></pre> 
 <h2 class="pgc-h-arrow-right">方法调用(有参)</h2> 
 <pre class="has"><code> 1// 创建一个方法调用 combatJCTreeMain.test2("hello world!"); 2JCTree.JCExpressionStatement exec2 = treeMaker.Exec( 3        treeMaker.Apply( 4                com.sun.tools.javac.util.List.nil(), 5                treeMaker.Select( 6                        treeMaker.Ident(names.fromString("combatJCTreeMain")), // . 左边的内容 7                        names.fromString("test2") // . 右边的内容 8                ), 9                com.sun.tools.javac.util.List.of(treeMaker.Literal("hello world!")) // 方法中的内容10        )11);</code></pre> 
 <h2 class="pgc-h-arrow-right">if语句</h2> 
 <pre class="has"><code> 1/* 2    创建一个if语句 3    if("BuXueWuShu".equals(name)){ 4        add = "a" + "b"; 5    }else{ 6        add += "test"; 7    } 8 */ 9// "BuXueWuShu".equals(name)10JCTree.JCMethodInvocation apply = treeMaker.Apply(11        com.sun.tools.javac.util.List.nil(),12        treeMaker.Select(13                treeMaker.Literal("BuXueWuShu"), // . 左边的内容14                names.fromString("equals") // . 右边的内容15        ),16        com.sun.tools.javac.util.List.of(treeMaker.Ident(names.fromString("name")))17);18//  add = "a" + "b"19JCTree.JCExpressionStatement exec3 = treeMaker.Exec(treeMaker.Assign(treeMaker.Ident(names.fromString("add")), treeMaker.Binary(JCTree.Tag.PLUS, treeMaker.Literal("a"), treeMaker.Literal("b"))));20//  add += "test"21JCTree.JCExpressionStatement exec1 = treeMaker.Exec(treeMaker.Assignop(JCTree.Tag.PLUS_ASG, treeMaker.Ident(names.fromString("add")), treeMaker.Literal("test")));2223JCTree.JCIf anIf = treeMaker.If(24        apply, // if语句里面的判断语句25        exec3, // 条件成立的语句26        exec1  // 条件不成立的语句27);</code></pre> 
 <h2 class="pgc-h-arrow-right">总结</h2> 
 <p>纸上得来终觉浅，绝知此事要躬行。希望大家看完此篇文章能够自己在本机上自己试验一下。自己设置几个参数，自己学的Lombok学着生成一下get、set方法，虽然本篇知识在日常开发中基本上不会用到，但是万一用到了这些知识那么别人不会而你会，差距其实就慢慢的给拉开了。</p> 
 <blockquote> 
  <p><br>作者：不学无数的程序员<br>原文链接：https://juejin.im/post/5e7c540ff265da42e16b02fc</p> 
 </blockquote> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c63466b39460e3b6f7fd69b3958e664d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">函数式接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a73b51e433c0fa82b2d2bf137d7d1fa6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分类预测：会员回购预测</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>