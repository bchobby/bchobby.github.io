<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在STM32上使用printf的两种方法 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在STM32上使用printf的两种方法" />
<meta property="og:description" content="单片机的开发中，很多时候我们需要看单片机的工作情况，比如看寄存器的变化，看局部变量或者全局变量，又或者程序的逻辑设计有问题，没有按预设进行某一个步骤，此时要查看程序跑到哪一个步骤里去了，等等，我们都需要查看与验证。通常我们会查用两种办法，一种是debug，一种是把要查看的信息利用某种数据接口打印出来。
debug的好处很多，不足之处也有，好处是直接看内存、看寄存器（要编译器支持，比如keil就支持STM32,51类的），用断点方式查看程序死在哪个位置，但是debug的不足之处，它有时会造成编译器崩掉等，有的编译器看局部变量只能是在打断点时才能看到。所以就要利用别的手段，就是利用某种数据接口把要查看的信息打印出来。
这里的某种数据接口是什么呢？常见的如下：
1.包括RS232、RS422、RS485，其实质都是串口（UART/USART）
2.Jlink调试口
3.Ethernet（以太网接口，即网线接口）
4.WiFi
5.CAN
6.蓝牙
以上6种都是常见的数据接口。这6种接口里，第3至第6种都是属于要配合规范协议使用的接口，在它们上面使用printf会稍显麻烦（对于高手来说却是easy的），必须按规范协议来组织数据帧，自由度不高，所以单片机上常用的是串口和jlink调试口。本文就介绍如何基于串口与Jlink实现printf函数。
第一篇：基于串口的printf
既然是基于串口，当然要把串口部份的代码先调试好，即起码的收一个字节和发一个字节要没有问题才行。如何写串口的收发函数，请自行在网上搜索，这里就不跨界了。
单片机的收发数据有两种方式，一种的用中断实现，一种不用中断，printf使用的是不用中断（划重点）。不要问为什么，照着做就行了。我经常说学东西，有时不要问为什么，先照着做就行了，做多了自然就能领悟为什么。就像我们学拿筷子夹东西，不要问为什么拇指在这个位置，食指在那个位置，要论起其中的力学原理，写好多篇论文都可以。各位想想，小时候学用筷子时老是搞不利索，急得用手抓，学会了后你还会想筷子该怎么拿吗，为什么这样握吗？
下面讲具体步骤：
1.更改编译器的设置，让编译器使用Micro LIB（这一个C语言库，具体干什么的自行搜索）。以keil为例，如图：勾选Micro LIB
2.串口非中断方式的，发一个字节的函数（代码）已调试好
3.printf使用的是非中断方式的、发一个字节的函数
4.包含stdio.h这个头文件。哪一个C文件中要使用printf，就必须要包含﻿stdio.h﻿。﻿如图：
﻿﻿﻿
5.编写代码
先看代码，如下：
#ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE* f) #endif /* __GNUC__ */ #ifdef __cplusplus extern &#34;C&#34; { #endif //__cplusplus PUTCHAR_PROTOTYPE { RS485A_DE = DOsnt; //发送脚使能，RS485为发送数据状态 delay_us(10); //等待发送脚的电平稳定 HAL_UART_Transmit(&amp;huart5, (uint8_t *)&amp;ch, 1, 0xFFFF); //调用STM32的HAL库，发送一个字节 delay_us(10); //避免数据信号震荡造成回环数据 RS485A_DE = DOrec; //发送脚除能，RS485恢复到接收数据状态 return (ch); } #ifdef __cplusplus } #endif //__cplusplus ⑴ 这段代码放在哪里。我只介绍我的经验，我的硬件是STM32的串口5 &#43; RS485，实质是基于串口5的RS485，故这段代码放在了我的RS485." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/15b87b833092c44236826a68b369a949/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-24T17:35:48+08:00" />
<meta property="article:modified_time" content="2019-12-24T17:35:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在STM32上使用printf的两种方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><span style="color:#000000;">       单片机的开发中，很多时候我们需要看单片机的工作情况，比如看寄存器的变化，看局部变量或者全局变量，又或者程序的逻辑设计有问题，没有按预设进行某一个步骤，此时要查看程序跑到哪一个步骤里去了，等等，我们都需要查看与验证。通常我们会查用两种办法，一种是debug，一种是把要查看的信息利用某种数据接口打印出来。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">       debug</span><span style="color:#000000;">的好处很多，不足之处也有，好处是直接看内存、看寄存器（要编译器支持，比如keil就支持STM32,51类的），用断点方式查看程序死在哪个位置，但是debug的不足之处，它有时会造成编译器崩掉等，有的编译器看局部变量只能是在打断点时才能看到。所以就要利用别的手段，就是利用某种数据接口把要查看的信息打印出来。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">这里的某种数据接口是什么呢？常见的如下：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.</span><span style="color:#000000;">包括RS232、RS422、RS485，其实质都是串口（UART/USART）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2.Jlink</span><span style="color:#000000;">调试口</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3.Ethernet</span><span style="color:#000000;">（以太网接口，即网线接口）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4.WiFi</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">5.CAN</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">6.</span><span style="color:#000000;">蓝牙</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        以上6种都是常见的数据接口。这6种接口里，第3至第6种都是属于要配合规范协议使用的接口，在它们上面使用printf会稍显麻烦（对于高手来说却是easy的），必须按规范协议来组织数据帧，自由度不高，所以单片机上常用的是串口和jlink调试口。本文就介绍如何基于串口与Jlink实现printf函数。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">第一篇：基于串口的printf</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        既然是基于串口，当然要把串口部份的代码先调试好，即起码的收一个字节和发一个字节要没有问题才行。如何写串口的收发函数，请自行在网上搜索，这里就不跨界了。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        单片机的收发数据有两种方式，一种的用中断实现，一种不用中断，</span><span style="color:#ff0000;">printf</span><span style="color:#ff0000;">使用的是不用中断（划重点）</span><span style="color:#000000;">。不要问为什么，照着做就行了。</span><span style="color:#3399ea;">我经常说学东西，有时不要问为什么，先照着做就行了，做多了自然就能领悟为什么。就像我们学拿筷子夹东西，不要问为什么拇指在这个位置，食指在那个位置，要论起其中的力学原理，写好多篇论文都可以。各位想想，小时候学用筷子时老是搞不利索，急得用手抓，学会了后你还会想筷子该怎么拿吗，为什么这样握吗？</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        下面讲具体步骤：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.</span><span style="color:#000000;">更改编译器的设置，让编译器使用Micro LIB（这一个C语言库，具体干什么的自行搜索）。以keil为例，如图：勾选Micro LIB</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="328" src="https://images2.imgbox.com/6d/fd/hK4omvzz_o.png" width="501"></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2.</span><span style="color:#000000;">串口非中断方式的，发一个字节的函数（代码）已调试好</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3.</span><span style="color:#ff0000;">printf</span><span style="color:#ff0000;">使用的是非中断方式的、发一个字节的函数</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4.</span><span style="color:#000000;">包含stdio.h这个头文件。哪一个C文件中要使用printf，就必须要包含</span>﻿<span style="color:#000000;">stdio.h</span>﻿<span style="color:#000000;">。</span>﻿<span style="color:#000000;">如图：</span></p> 
<p style="margin-left:0cm;">       ﻿﻿﻿<img alt="" class="has" height="531" src="https://images2.imgbox.com/60/34/Fu7ZEFNC_o.png" width="273"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">5.</span><span style="color:#000000;">编写代码</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">先看代码，如下：</span></p> 
<div style="margin-left:18pt;"> 
 <ol><li><span style="color:#808080;">#ifdef __GNUC__</span>  </li><li><span style="color:#808080;">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span>  </li><li><span style="color:#808080;">#else</span>  </li><li><span style="color:#808080;">#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE* f)</span>  </li><li><span style="color:#808080;">#endif /* __GNUC__ */</span>  </li><li>   </li><li><span style="color:#808080;">#ifdef __cplusplus</span>  </li><li><strong><span style="color:#006699;">extern</span></strong> <span style="color:#0000ff;">"C"</span><span style="color:#000000;"> {  </span></li><li><span style="color:#808080;">#endif //__cplusplus</span>  </li><li>   </li><li><span style="color:#000000;">PUTCHAR_PROTOTYPE  </span></li><li><span style="color:#000000;">{  </span></li><li> <span style="color:#7030a0;">   RS485A_DE = DOsnt;  //</span><span style="color:#7030a0;">发送脚使能，</span><span style="color:#7030a0;">RS485</span><span style="color:#7030a0;">为发送数据状态</span></li><li><span style="color:#7030a0;">    delay_us(10);  //</span><span style="color:#7030a0;">等待发送脚的电平稳定</span></li><li><span style="color:#7030a0;">    HAL_UART_Transmit(&amp;huart5, (uint8_t *)&amp;ch, 1, 0xFFFF);  //</span><span style="color:#7030a0;">调用</span><span style="color:#7030a0;">STM32</span><span style="color:#7030a0;">的</span><span style="color:#7030a0;">HAL</span><span style="color:#7030a0;">库，发送一个字节</span></li><li><span style="color:#7030a0;">    delay_us(10);  //</span><span style="color:#7030a0;">避免数据信号震荡造成回环数据</span></li><li><span style="color:#7030a0;">    RS485A_DE = DOrec;  //</span><span style="color:#7030a0;">发送脚除能，</span><span style="color:#7030a0;">RS485</span><span style="color:#7030a0;">恢复到接收数据状态</span></li><li>  <strong><span style="color:#006699;">return</span></strong><span style="color:#000000;"> (ch);  </span></li><li><span style="color:#000000;">}  </span></li><li>   </li><li><span style="color:#808080;">#ifdef __cplusplus</span>  </li><li><span style="color:#000000;">}  </span></li><li><span style="color:#808080;">#endif //__cplusplus</span>  </li></ol> 
</div> 
<p style="margin-left:0cm;"><span style="color:#000000;">⑴ 这段代码放在哪里。我只介绍我的经验，我的硬件是STM32的串口5 + RS485，实质是基于串口5的RS485，故这段代码放在了我的RS485.C这个文件中，因为在RS485.C文件中，我可以直接调用串口发送函数。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">如果你的硬件是RS232、RS422,甚至是TTL电平（即直接使用串口），那你就自行修改。</span></p> 
<p style="margin-left:0cm;"><span style="color:#c45911;">题外话：RS232、RS422、RS485、TTL均是描述硬件的电平的，而非通常讨论的协议（如ModBus），很多人都这两个搅和在一起，一张口就是RS485协议。所谓的RS485协议也说的是OSI结构的物理层，即电路，切记。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">⑵ 读者要修改的部份：紫色部份。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        因为RS485的半双工通讯的，所以要把发送脚使能脚变成使能，具体的逻辑请看上面代码中的注释。如果你的电路是RS232或者TTL电平的，那这种电路是全双工的，自然就不用这一句。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        关键来了，第15行的代码，它是串口发一个字节的函数。因为我用的是STM32的HAL库，所以我这里调用的是库中发送一个字节的函数：HAL_UART_Transmit()函数，如果你的代码用的是标准库，请用标准库的代码。如果是纯寄存器操作，就调用寄存器的。总之，就像第二点所说，</span><span style="color:#000000;">发一个字节的函数（代码）已调试好。</span><br><br> ﻿﻿</p> 
<p style="margin-left:0cm;">        <span style="color:#000000;">其它单片机请自行修改。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">        <span style="color:#000000;">如此准备工作就已经完成，这时，只要包含了</span><span style="color:#000000;">stdio.h</span><span style="color:#000000;">这个头文件的C文件中，均可以使用printf函数了，你想打印什么信息，就能打印什么，数据、文字、符号都可以。不知道怎么打印数据、文字、符号的小白，请上网搜索，或者去问问你们的计算机课老师，此处不赘述。</span></p> 
<p style="margin-left:0cm;">        <span style="color:#000000;">然后，讲一下为何要包含stdio.h，因为printf实质是int fputc(int ch, FILE* f)函数，见代码的第4行，是在stdio.h文件中，把printf重定向了，指向了fputc()函数；而fputc()函数调用的是你串口发送一个字节（也可称字符）的函数。</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" src="https://images2.imgbox.com/e1/6c/HEmgOdW4_o.jpg"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">第二篇：MDK+stm32+jlink利用swd方式进行printf输出</span></p> 
<p style="margin-left:0cm;">出处：http://www.douban.com/note/248637026/</p> 
<p style="margin-left:0cm;">由xyzjacky补充增加 </p> 
<p style="margin-left:0cm;">-----------------------------------------------------------------------------------------------</p> 
<p style="margin-left:0cm;">作者：prife</p> 
<p style="margin-left:0cm;">感谢：hexlog@gmail.com</p> 
<p style="margin-left:0cm;">-----------------------------------------------------------------------------------------------</p> 
<p style="margin-left:0cm;"><span style="color:#111111;">使用ITM机制实现调试stm32单片机，实现printf与scanf。</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">1. ITM</span><span style="color:#111111;">简介</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        ITM</span><span style="color:#111111;">机制是一种调试机制，是新一代调试方式，在这之前，有一种比较出名的调试方式，称为半主机（semihosting）方式。在pc上编写过C语言的人都知道，printf可以向控制台输出，scanf可以从控制台获取输入，这里的printf/scanf都是标准库函数，利用操作系统的这些函数，我们可以很方便的调试程序。在嵌入式设备上（如stm32单片机平台上）开发工具（如MDK/IAR）也都提供了标准库函，自然也提供了printf/scanf函数，那么这些函数是否可以使用呢？ 问题来了，printf向哪里输出呢？并且大部分情况下，也没有键盘，又如何使用scanf实现输入呢？我们都知道，嵌入式设备一般的使用仿真器，如常见Jlink/ulink，可以实现烧录，单步，下断点，查看变量，等等。仿真器将PC机和单片机连接器来。聪明的设计者们就在考虑是否可以借助仿真器，使得单片机可以借助PC机的屏幕以及PC机的键盘实现printf的输出和scanf的按键获取。也就是说，如下的hello，world程序</span></p> 
<ol><li><span style="color:#454545;">#include &lt;stdio.h&gt;  </span></li><li><strong>int</strong><span style="color:#454545;"> main()  </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">        //</span><span style="color:#454545;">硬件初始化</span>  </li><li><span style="color:#454545;">        //....  </span></li><li><span style="color:#454545;">        printf("hello, world");  </span></li><li><span style="color:#454545;">        for(;;);  </span></li><li><span style="color:#454545;">}  </span></li></ol> 
<div> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#include &lt;stdio.h&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">int main()</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">        //</span><span style="color:#333333;">硬件初始化</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">        //....</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">        printf("hello, world");</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">        for(;;);</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
</div> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        这个程序烧录到单片机中后，仿真器连接接单片机与PC，开始在线调试后，那么这个程序会将"Hello, world"输出到PC机上，在开发工具（MDK/IAR等）的某个窗口中显示。这就相当于，单片机借助了PC机的显示/输入设备实现了自己的输出/输入。这种方式无疑可以方便程序开发者调试。这种机制有多种实现方式，比较著名的就是semihosting（半主机机制）和ITM机制。ITM是ARM在推出semihosting之后推出的新一代调试机制。现在我们来尝试一下这种方式调试。</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2. stm32</span><span style="color:#111111;">使用ITM调试</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">MCU</span><span style="color:#111111;">：stm32f207VG</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">仿真器：Jlink V8</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">IDE</span><span style="color:#111111;">：MDK4.50及以上</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2.1 </span><span style="color:#111111;">硬件连接</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        ITM</span><span style="color:#111111;">机制要求使用SWD方式接口，并需要连接SWO线，一般的四线SWD方式（VCC SDCLK，SDIO，GND）是不行的。标准的20针JTAG接口是可以的，只需要在MDK里设置使用SWD接口即可。</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2.2 </span><span style="color:#111111;">添加重定向文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        将下面的文件保存成任意C文件，并添加到工程中。这里对这个文件简单说明一下，要知道我们的程序是在单片机上运行的，为什么printf可以输出到MDK窗口里去呢？这是因为 标准库中的printf实际上调用 fputc实现输出，所以我们需要自己编写一个fputc函数，这个函数会借助ITM（类似于USART）提供的寄存器，实现数据的发送，仿真器会收到这些数据，并发往PC机。实际上，如果你的单片机和一块LCD连接，那么你只需要重新实现fputc函数，并向LCD上输出即可，那么你调用printf时就会输出到LCD上了。这中机制，就是所谓的重定向机制。</span></p> 
<ol><li><span style="color:#454545;">#include &lt;stdio.h&gt;  </span></li><li>  </li><li><span style="color:#454545;">#define ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000+4*n)))  </span></li><li><span style="color:#454545;">#define ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000+4*n)))  </span></li><li><span style="color:#454545;">#define ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000+4*n)))  </span></li><li><span style="color:#454545;">#define DEMCR           (*((volatile unsigned long *)(0xE000EDFC)))  </span></li><li><span style="color:#454545;">#define TRCENA          0x01000000  </span></li><li>  </li><li><span style="color:#454545;">struct __FILE { int handle; /* Add whatever you need here */ };  </span></li><li><span style="color:#454545;">    FILE __stdout;  </span></li><li><span style="color:#454545;">    FILE __stdin;  </span></li><li>      </li><li><span style="color:#454545;">int fputc(int ch, FILE *f)   </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">    if (DEMCR &amp; TRCENA)   </span></li><li><span style="color:#454545;">    {  </span></li><li><span style="color:#454545;">        while (ITM_Port32(0) == 0);  </span></li><li><span style="color:#454545;">        ITM_Port8(0) = ch;  </span></li><li><span style="color:#454545;">    }  </span></li><li><span style="color:#454545;">    return(ch);  </span></li></ol> 
<ol><li><span style="color:#454545;">}  </span></li></ol> 
<div> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#include &lt;stdio.h&gt;</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#define ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000+4*n)))</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#define ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000+4*n)))</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#define ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000+4*n)))</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#define DEMCR           (*((volatile unsigned long *)(0xE000EDFC)))</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#define TRCENA          0x01000000</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">struct __FILE { int handle; /* Add whatever you need here */ };</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    FILE __stdout;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    FILE __stdin;</span></p> 
 <p style="margin-left:0cm;">   </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">int fputc(int ch, FILE *f) </span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    if (DEMCR &amp; TRCENA) </span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    {<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">        while (ITM_Port32(0) == 0);</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">        ITM_Port8(0) = ch;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    }</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    return(ch);</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
</div> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2.2 </span><span style="color:#111111;">配置JLINK的初始化配置文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">将下面文件放置在你的工程下，并取任意名称，这里笔者取名为 STM32DBG.ini</span></p> 
<ol><li><span style="color:#454545;">/******************************************************************************/  </span></li><li><span style="color:#454545;">/* STM32DBG.INI: STM32 Debugger Initialization File                           */  </span></li><li><span style="color:#454545;">/******************************************************************************/  </span></li><li><span style="color:#454545;">// &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;                           //   </span></li><li><span style="color:#454545;">/******************************************************************************/  </span></li><li><span style="color:#454545;">/* This file is part of the uVision/ARM development tools.                    */  </span></li><li><span style="color:#454545;">/* Copyright (c) 2005-2007 Keil Software. All rights reserved.                */  </span></li><li><span style="color:#454545;">/* This software may only be used under the terms of a valid, current,        */  </span></li><li><span style="color:#454545;">/* end user licence from KEIL for a compatible version of KEIL software       */  </span></li><li><span style="color:#454545;">/* development tools. Nothing else gives you the right to use this software.  */  </span></li><li><span style="color:#454545;">/******************************************************************************/  </span></li><li>  </li><li>  </li><li><span style="color:#454545;">FUNC void DebugSetup (void) {  </span></li><li><span style="color:#454545;">// &lt;h&gt; Debug MCU Configuration  </span></li><li><span style="color:#454545;">//   &lt;o1.0&gt;    DBG_SLEEP     &lt;i&gt; Debug Sleep Mode  </span></li><li><span style="color:#454545;">//   &lt;o1.1&gt;    DBG_STOP      &lt;i&gt; Debug Stop Mode  </span></li><li><span style="color:#454545;">//   &lt;o1.2&gt;    DBG_STANDBY   &lt;i&gt; Debug Standby Mode  </span></li><li><span style="color:#454545;">//   &lt;o1.5&gt;    TRACE_IOEN    &lt;i&gt; Trace I/O Enable   </span></li><li><span style="color:#454545;">//   &lt;o1.6..7&gt; TRACE_MODE    &lt;i&gt; Trace Mode  </span></li><li><span style="color:#454545;">//             &lt;0=&gt; Asynchronous  </span></li><li><span style="color:#454545;">//             &lt;1=&gt; Synchronous: TRACEDATA Size 1  </span></li><li><span style="color:#454545;">//             &lt;2=&gt; Synchronous: TRACEDATA Size 2  </span></li><li><span style="color:#454545;">//             &lt;3=&gt; Synchronous: TRACEDATA Size 4  </span></li><li><span style="color:#454545;">//   &lt;o1.8&gt;    DBG_IWDG_STOP &lt;i&gt; Independant Watchdog Stopped when Core is halted  </span></li><li><span style="color:#454545;">//   &lt;o1.9&gt;    DBG_WWDG_STOP &lt;i&gt; Window Watchdog Stopped when Core is halted  </span></li><li><span style="color:#454545;">//   &lt;o1.10&gt;   DBG_TIM1_STOP &lt;i&gt; Timer 1 Stopped when Core is halted  </span></li><li><span style="color:#454545;">//   &lt;o1.11&gt;   DBG_TIM2_STOP &lt;i&gt; Timer 2 Stopped when Core is halted  </span></li><li><span style="color:#454545;">//   &lt;o1.12&gt;   DBG_TIM3_STOP &lt;i&gt; Timer 3 Stopped when Core is halted  </span></li><li><span style="color:#454545;">//   &lt;o1.13&gt;   DBG_TIM4_STOP &lt;i&gt; Timer 4 Stopped when Core is halted  </span></li><li><span style="color:#454545;">//   &lt;o1.14&gt;   DBG_CAN_STOP  &lt;i&gt; CAN Stopped when Core is halted  </span></li><li><span style="color:#454545;">// &lt;/h&gt;  </span></li><li><span style="color:#454545;">_WDWORD(0xE0042004, 0x00000027);  // DBGMCU_CR  </span></li><li><span style="color:#454545;">_WDWORD(0xE000ED08, 0x20000000);   // Setup Vector Table Offset Register  </span></li><li><span style="color:#454545;">}  </span></li><li>  </li><li><span style="color:#454545;">DebugSetup();                       // Debugger Setup  </span></li></ol> 
<div> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/******************************************************************************/</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/* STM32DBG.INI: STM32 Debugger Initialization File                           */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/******************************************************************************/</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">// &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;                           // </span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/******************************************************************************/</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/* This file is part of the uVision/ARM development tools.                    */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/* Copyright (c) 2005-2007 Keil Software. All rights reserved.                */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/* This software may only be used under the terms of a valid, current,        */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/* end user licence from KEIL for a compatible version of KEIL software       */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/* development tools. Nothing else gives you the right to use this software.  */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">/******************************************************************************/</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">FUNC void DebugSetup (void) {<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">// &lt;h&gt; Debug MCU Configuration</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.0&gt;    DBG_SLEEP     &lt;i&gt; Debug Sleep Mode</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.1&gt;    DBG_STOP      &lt;i&gt; Debug Stop Mode</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.2&gt;    DBG_STANDBY   &lt;i&gt; Debug Standby Mode</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.5&gt;    TRACE_IOEN    &lt;i&gt; Trace I/O Enable </span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.6..7&gt; TRACE_MODE    &lt;i&gt; Trace Mode</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//             &lt;0=&gt; Asynchronous</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//             &lt;1=&gt; Synchronous: TRACEDATA Size 1</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//             &lt;2=&gt; Synchronous: TRACEDATA Size 2</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//             &lt;3=&gt; Synchronous: TRACEDATA Size 4</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.8&gt;    DBG_IWDG_STOP &lt;i&gt; Independant Watchdog Stopped when Core is halted</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.9&gt;    DBG_WWDG_STOP &lt;i&gt; Window Watchdog Stopped when Core is halted</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.10&gt;   DBG_TIM1_STOP &lt;i&gt; Timer 1 Stopped when Core is halted</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.11&gt;   DBG_TIM2_STOP &lt;i&gt; Timer 2 Stopped when Core is halted</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.12&gt;   DBG_TIM3_STOP &lt;i&gt; Timer 3 Stopped when Core is halted</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.13&gt;   DBG_TIM4_STOP &lt;i&gt; Timer 4 Stopped when Core is halted</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">//   &lt;o1.14&gt;   DBG_CAN_STOP  &lt;i&gt; CAN Stopped when Core is halted</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">// &lt;/h&gt;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">_WDWORD(0xE0042004, 0x00000027);  // DBGMCU_CR</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">_WDWORD(0xE000ED08, 0x20000000);   // Setup Vector Table Offset Register</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">DebugSetup();                       // Debugger Setup</span></p> 
</div> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">这里对这个文件做简单的解释， _WDWORD(0xE0042004, 0x00000027); // DBGMCU_CR </span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">这一句表示想 0xE0042004地址处写入 0x000000027，这个寄存器是各个位表示的含义在注释中给出了详细的解释。 0x27即表示:</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        BIT0 DBG_SLEEP</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        BIT1 DBG_STOP</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        BIT2 DBG_STANDBY</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">        BIT5 TRACE_IOEN</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">注意，要使用ITM机制，必须要打开BIT5。打开MDK工程，按照下图修改。</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="446" src="https://images2.imgbox.com/0d/75/I6DVpyTc_o.png" width="600"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2.3 MDK</span><span style="color:#111111;">中对JLINK的配置</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="492" src="https://images2.imgbox.com/5d/aa/3H4hU5O1_o.png" width="600"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">下图中注意两点</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">1). </span><span style="color:#111111;">这里的CoreClock是120M，因为笔者使用的是stm32F207VG这款芯片，并且时钟配置为120M，所以这里填入120M，如果你使用stm32F10x，时钟配置成72M，那么这里需要填入72M。即需要跟实际情况保持一致。</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2). </span><span style="color:#111111;">最后一定要将 0处打勾，并将其他bit位上的勾去掉，最好与此图保持一致，除CoreClock外。</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="353" src="https://images2.imgbox.com/6a/08/RZfilIBQ_o.png" width="537"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2.4 </span><span style="color:#111111;">烧录程序，并启动调试。可以看到，笔者在程序源码中插入了一句printf语句输出，然后按照下图，就可以看到程序的输出了。</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="421" src="https://images2.imgbox.com/96/e9/7zfFrxjn_o.png" width="551"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">3. </span><span style="color:#111111;">综合版本使用scanf和printf</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">3.1 </span><span style="color:#111111;">添加retarget文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">将如下代码保存成retarget.c，然后加入到工程中。</span></p> 
<ol><li><span style="color:#454545;">#pragma import(__use_no_semihosting_swi)  </span></li><li>  </li><li><span style="color:#454545;">struct __FILE { int handle; /* Add whatever you need here */ };  </span></li><li><span style="color:#454545;">    FILE __stdout;  </span></li><li><span style="color:#454545;">    FILE __stdin;  </span></li><li>      </li><li><span style="color:#454545;">int fputc(int ch, FILE *f)   </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">    return ITM_SendChar(ch);  </span></li><li><span style="color:#454545;">}  </span></li><li>  </li><li><span style="color:#454545;">volatile int32_t ITM_RxBuffer;  </span></li><li><span style="color:#454545;">int fgetc(FILE *f)  </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">  while (ITM_CheckChar() != 1) __NOP();  </span></li><li><span style="color:#454545;">  return (ITM_ReceiveChar());  </span></li><li><span style="color:#454545;">}  </span></li><li>  </li><li><span style="color:#454545;">int ferror(FILE *f)  </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">    /* Your implementation of ferror */  </span></li><li><span style="color:#454545;">    return EOF;  </span></li><li><span style="color:#454545;">}  </span></li><li>  </li><li><span style="color:#454545;">void _ttywrch(int c)  </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">    fputc(c, 0);  </span></li><li><span style="color:#454545;">}  </span></li><li>  </li><li><span style="color:#454545;">int __backspace()  </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">    return 0;  </span></li><li><span style="color:#454545;">}  </span></li><li><span style="color:#454545;">void _sys_exit(int return_code)  </span></li><li><span style="color:#454545;">{  </span></li><li><span style="color:#454545;">label:  </span></li><li><span style="color:#454545;">    goto label;  /* endless loop */  </span></li><li><span style="color:#454545;">}  </span></li></ol> 
<div> 
 <p style="margin-left:0cm;"><span style="color:#333333;">#pragma import(__use_no_semihosting_swi)</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">struct __FILE { int handle; /* Add whatever you need here */ };</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    FILE __stdout;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    FILE __stdin;</span></p> 
 <p style="margin-left:0cm;">   </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">int fputc(int ch, FILE *f) </span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    return ITM_SendChar(ch);</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">volatile int32_t ITM_RxBuffer;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">int fgetc(FILE *f)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">  while (ITM_CheckChar() != 1) __NOP();</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">  return (ITM_ReceiveChar());</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">int ferror(FILE *f)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    /* Your implementation of ferror */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    return EOF;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">void _ttywrch(int c)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    fputc(c, 0);</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">int __backspace()</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    return 0;</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">void _sys_exit(int return_code)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">{<!-- --></span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">label:</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    goto label;  /* endless loop */</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">}</span></p> 
</div> 
<p style="margin-left:0cm;"><span style="color:#111111;">3.2 </span><span style="color:#111111;">编译运行</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">编译，烧录，运行，打开Debug (printf) viewer，就可以看到输入，参看下图</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="369" src="https://images2.imgbox.com/42/93/vvJhERqF_o.png" width="561"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">这里对retarget.c文件做几点说明.</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">1). </span><span style="color:#111111;">上面的代码实际是在X:\Keil\ARM\Startup\Retarget.c上修改而成的，scanf依赖的函数共有两个，fgetc和__backspace都需要实现，如果缺少__backespace函数，则scanf胡无法从Debug Viewer Dialog 窗口获取输入。另外上面提供的代码只是个demo，用于演示效果，用于生产时应该处理的更完善一些。见参考文献[1]</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">2). </span><span style="color:#111111;">函数ITM_SendChar，ITM_CheckChar，ITM_ReceiveChar在库文件CMSIS\Include\core_cm3.h中。</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">3) </span><span style="color:#111111;">查看函数的符号引用关系，可以通过生成详细的map文件来查看。命令行增加 --verbose --list rtt.map选项即可生成名为rtt.map的文件。</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">4. ITM</span><span style="color:#111111;">与RTT结合(待实现)</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">grissiom </span><span style="color:#111111;">写道:</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">忽然想到，或许可以把这个半主机做成 device，然后 rt_console_set_device("semi") 就可以直接用半主机做 finsh/rt_kprintf 了…… 不知可行不可行……</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">prife: ITM</span><span style="color:#111111;">的接收不知道是否支持中断，目前接收字符使用是轮询方式。如果是中断才有意义。这样可以把ITM设备做成一个 rtt 的device了，让finsh跑在 Debug printf Viewer窗口上。以后只要接一个jtag/SWD口就可以调试了，不用再接串口线了。</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">参考文献</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">[1] MDK help. Indirect semihosting C library function dependencies</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">[2] MDK help ARM Development Tools.</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">         Debugger Adapter User's Guides</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">             J-Link/J-Trace User's Guide</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">         Libraries and Floating Point Support Referencee</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">         Libraries and Floating Point Support Guide</span></p> 
<p style="margin-left:0cm;"><span style="color:#111111;">         Linker Reference Guide</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">5. <span style="color:#c00000;">另附由xyzjacky亲测过的代码</span></p> 
<p style="margin-left:0cm;">1). 上文中所写的<span style="color:#111111;">retarget.c</span><span style="color:#111111;">，本人定义为debug.c，代码如下：</span></p> 
<ol><li><span style="color:#454545;">/*******************************************************************************</span></li><li><span style="color:#454545;"> * </span><span style="color:#454545;">功能描述：调试相关设置</span><span style="color:#454545;">(</span><span style="color:#454545;">重定向</span><span style="color:#454545;">fputc</span><span style="color:#454545;">、实现</span><span style="color:#454545;">printf</span><span style="color:#454545;">输出</span><span style="color:#454545;">)</span></li><li><span style="color:#454545;"> * </span><span style="color:#454545;">修改日期</span>          <span style="color:#454545;">版本号</span>     <span style="color:#454545;">修改人</span>                   <span style="color:#454545;">修改内容</span></li><li><span style="color:#454545;"> * -----------------------------------------------------------------------</span></li><li><span style="color:#454545;"> * 2014/12/28        V1.0        258264176@qq.com     </span><span style="color:#454545;">创建</span></li><li><span style="color:#454545;">********************************************************************************/</span></li><li> </li><li><span style="color:#454545;">#include "stdio.h"</span></li><li><span style="color:#454545;">#include "stm32f10x.h"</span></li><li> </li><li><span style="color:#454545;">#pragma import(__use_no_semihosting_swi)</span></li><li> </li><li><span style="color:#454545;">#define ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000 + 4*n)))</span></li><li><span style="color:#454545;">#define ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000 + 4*n)))</span></li><li><span style="color:#454545;">#define ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000 + 4*n)))</span></li><li><span style="color:#454545;">#define DEMCR           (*((volatile unsigned long *)0xE000EDFC))</span></li><li> </li><li><span style="color:#454545;">#define TRCENA          0x01000000</span></li><li> </li><li><span style="color:#454545;">struct __FILE {<!-- --></span></li><li><span style="color:#454545;">    int handle;</span></li><li><span style="color:#454545;">};</span></li><li> </li><li><span style="color:#454545;">FILE __stdout;</span></li><li><span style="color:#454545;">FILE __stdin;</span></li><li> </li><li><span style="color:#454545;">/**********************************************************************</span></li><li><span style="color:#454545;"> * </span><span style="color:#454545;">功能描述</span><span style="color:#454545;">: </span><span style="color:#454545;">实现字节输出</span></li><li><span style="color:#454545;"> * </span><span style="color:#454545;">参数</span><span style="color:#454545;">:</span></li><li><span style="color:#454545;"> *      ch: </span><span style="color:#454545;">待发送的数据</span></li><li><span style="color:#454545;"> *      f:  </span><span style="color:#454545;">句柄</span></li><li><span style="color:#454545;"> * </span><span style="color:#454545;">返回值</span><span style="color:#454545;">:</span></li><li><span style="color:#454545;"> *      </span><span style="color:#454545;">发送的数据</span></li><li><span style="color:#454545;"> ***********************************************************************/</span></li><li><span style="color:#454545;">int fputc(int ch, FILE *f) </span></li><li><span style="color:#454545;">{     </span></li><li><span style="color:#454545;">    /*USART_SendData(USART1, (u8)ch);</span></li><li> </li><li><span style="color:#454545;">    while(RESET == USART_GetFlagStatus(USART1, USART_FLAG_TC));</span></li><li> </li><li><span style="color:#454545;">    return ch;*/</span></li><li>    </li><li><span style="color:#454545;">    if(DEMCR &amp; TRCENA){<!-- --></span></li><li><span style="color:#454545;">        while(0 == ITM_Port32(0));</span></li><li>        </li><li><span style="color:#454545;">        ITM_Port8(0) = ch;</span></li><li><span style="color:#454545;">    }</span></li><li>    </li><li><span style="color:#454545;">    return ch;</span></li><li><span style="color:#454545;">}</span></li><li> </li><li> </li><li><span style="color:#454545;">volatile int32_t ITM_RxBuffer;</span></li><li><span style="color:#454545;">int fgetc(FILE *f)</span></li><li><span style="color:#454545;">{<!-- --></span></li><li><span style="color:#454545;">    int cnt = 0;</span></li><li><span style="color:#454545;">  while (ITM_CheckChar() != 1) </span></li><li><span style="color:#454545;">    {<!-- --></span></li><li><span style="color:#454545;">        cnt ++;</span></li><li><span style="color:#454545;">        if(cnt &gt; 100)</span></li><li><span style="color:#454545;">        {<!-- --></span></li><li><span style="color:#454545;">            return 0;</span></li><li><span style="color:#454545;">        }</span></li><li><span style="color:#454545;">        __NOP();</span></li><li><span style="color:#454545;">    }</span></li><li><span style="color:#454545;">  return (ITM_ReceiveChar());</span></li><li><span style="color:#454545;">}</span></li><li> </li><li><span style="color:#454545;">int ferror(FILE *f)</span></li><li><span style="color:#454545;">{<!-- --></span></li><li><span style="color:#454545;">    return EOF;</span></li><li><span style="color:#454545;">}</span></li><li> </li><li><span style="color:#454545;">void _ttywrch(int c)</span></li><li><span style="color:#454545;">{<!-- --></span></li><li> </li><li><span style="color:#454545;">}</span></li><li> </li><li><span style="color:#454545;">int __backspace()</span></li><li><span style="color:#454545;">{<!-- --></span></li><li><span style="color:#454545;">    return 0;</span></li><li><span style="color:#454545;">}</span></li><li> </li><li><span style="color:#454545;">void _sys_exit(int return_code)</span></li><li><span style="color:#454545;">{<!-- --></span></li><li><span style="color:#454545;">label:</span></li><li><span style="color:#454545;">    goto label;</span></li><li><span style="color:#454545;">}</span></li><li> </li></ol> 
<p style="margin-left:0cm;">2). <span style="color:#111111;">STM32DBG.ini</span><span style="color:#111111;">文件内容</span></p> 
<ol><li><span style="color:#454545;">/******************************************************************************/</span></li><li><span style="color:#454545;">/* STM32DBG.INI: STM32 Debugger Initialization File */</span></li><li><span style="color:#454545;">/******************************************************************************/</span></li><li><span style="color:#454545;">// &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt; // </span></li><li><span style="color:#454545;">/******************************************************************************/</span></li><li><span style="color:#454545;">/* This file is part of the uVision/ARM development tools. */</span></li><li><span style="color:#454545;">/* Copyright (c) 2005-2007 Keil Software. All rights reserved. */</span></li><li><span style="color:#454545;">/* This software may only be used under the terms of a valid, current, */</span></li><li><span style="color:#454545;">/* end user licence from KEIL for a compatible version of KEIL software */</span></li><li><span style="color:#454545;">/* development tools. Nothing else gives you the right to use this software. */</span></li><li><span style="color:#454545;">/******************************************************************************/</span></li><li><span style="color:#454545;">FUNC void DebugSetup (void) {<!-- --></span></li><li><span style="color:#454545;">// &lt;h&gt; Debug MCU Configuration</span></li><li><span style="color:#454545;">// &lt;o1.0&gt; DBG_SLEEP &lt;i&gt; Debug Sleep Mode</span></li><li><span style="color:#454545;">// &lt;o1.1&gt; DBG_STOP &lt;i&gt; Debug Stop Mode</span></li><li><span style="color:#454545;">// &lt;o1.2&gt; DBG_STANDBY &lt;i&gt; Debug Standby Mode</span></li><li><span style="color:#454545;">// &lt;o1.5&gt; TRACE_IOEN &lt;i&gt; Trace I/O Enable </span></li><li><span style="color:#454545;">// &lt;o1.6..7&gt; TRACE_MODE &lt;i&gt; Trace Mode</span></li><li><span style="color:#454545;">// &lt;0=&gt; Asynchronous</span></li><li><span style="color:#454545;">// &lt;1=&gt; Synchronous: TRACEDATA Size 1</span></li><li><span style="color:#454545;">// &lt;2=&gt; Synchronous: TRACEDATA Size 2</span></li><li><span style="color:#454545;">// &lt;3=&gt; Synchronous: TRACEDATA Size 4</span></li><li><span style="color:#454545;">// &lt;o1.8&gt; DBG_IWDG_STOP &lt;i&gt; Independant Watchdog Stopped when Core is halted</span></li><li><span style="color:#454545;">// &lt;o1.9&gt; DBG_WWDG_STOP &lt;i&gt; Window Watchdog Stopped when Core is halted</span></li><li><span style="color:#454545;">// &lt;o1.10&gt; DBG_TIM1_STOP &lt;i&gt; Timer 1 Stopped when Core is halted</span></li><li><span style="color:#454545;">// &lt;o1.11&gt; DBG_TIM2_STOP &lt;i&gt; Timer 2 Stopped when Core is halted</span></li><li><span style="color:#454545;">// &lt;o1.12&gt; DBG_TIM3_STOP &lt;i&gt; Timer 3 Stopped when Core is halted</span></li><li><span style="color:#454545;">// &lt;o1.13&gt; DBG_TIM4_STOP &lt;i&gt; Timer 4 Stopped when Core is halted</span></li><li><span style="color:#454545;">// &lt;o1.14&gt; DBG_CAN_STOP &lt;i&gt; CAN Stopped when Core is halted</span></li><li><span style="color:#454545;">// &lt;/h&gt;</span></li><li><span style="color:#454545;">_WDWORD(0xE0042004, 0x00000027); // DBGMCU_CR</span></li><li><span style="color:#454545;">_WDWORD(0xE000ED08, 0x20000000); // Setup Vector Table Offset Register</span></li><li><span style="color:#454545;">}</span></li><li><span style="color:#454545;">DebugSetup(); // Debugger Setup</span></li><li> </li><li><span style="color:#454545;">/**********************************************************************************************/</span></li></ol> 
<p style="margin-left:0cm;"><img alt="" class="has" height="476" src="https://images2.imgbox.com/b1/21/efSvsNZb_o.png" width="640"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#111111;">STM32DBG.ini</span><span style="color:#111111;">文件可直接保存在工程的任意文件夹中，本人一般保存在工程的顶层文件夹中。</span></p> 
<p style="margin-left:0cm;"><strong>实现printf打印信息功能的接线方式</strong></p> 
<p style="margin-left:0cm;">要实现printf信息，就要按照以下方式接线（限STM32F1系列）</p> 
<p style="margin-left:0cm;">TDI – PA15</p> 
<p style="margin-left:0cm;">TMS,SWIO –PA13</p> 
<p style="margin-left:0cm;">TCK,SWCLK----PA14</p> 
<p style="margin-left:0cm;">TDO—PB3</p> 
<p style="margin-left:0cm;">GND----GND（不可忽略）</p> 
<p style="margin-left:0cm;">下面为ST-Link/V2 JTAG/SWD接口定义：</p> 
<table><tbody><tr><td style="width:120.1pt;"> <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">仿真器端口</span></strong></p> </td><td> <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">连接目标板</span></strong></p> </td><td style="width:306.4pt;"> <p style="margin-left:0cm;"><strong><span style="color:#ffffff;">功能</span></strong></p> </td></tr><tr><td> <p style="margin-left:0cm;">　　1. TVCC</p> </td><td style="width:97.4pt;"> <p style="margin-left:0cm;">　　<span style="color:#ff0000;">MCU</span><span style="color:#ff0000;">电源VCC</span></p> </td><td> <p style="margin-left:0cm;">连接STM32目标板的电源VCC</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　2. TVCC</p> </td><td> <p style="margin-left:0cm;">　　<span style="color:#ff0000;">MCU</span><span style="color:#ff0000;">电源VCC</span></p> </td><td> <p style="margin-left:0cm;">连接STM32目标板的电源VCC</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　3. TRST</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　4. UART-RX</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　5. TDI</p> </td><td> <p style="margin-left:0cm;">　　<span style="color:#ff0000;">TDI</span></p> </td><td> <p style="margin-left:0cm;">连接STM32的JTAG TDI</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　6. UART-TX</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　7. TMS, SWIO</p> </td><td> <p style="margin-left:0cm;">　　<span style="color:#ff0000;">TMS, SWIO</span></p> </td><td> <p style="margin-left:0cm;">连接STM32的JTAG的TMS, SWD的SW IO</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　8. BOOT0</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　9. TCK, SWCLK</p> </td><td> <p style="margin-left:0cm;">　　<span style="color:#ff0000;">TCK, SWCLK</span></p> </td><td> <p style="margin-left:0cm;">连接STM32的JTAG的TCK, SWD的SW CLK</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　10. SWIM</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　11. NC</p> </td><td style="width:97.4pt;"> <p style="margin-left:0cm;">　　NC</p> </td><td> <p style="margin-left:0cm;">Unused</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　12. GND</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　13. TDO</p> </td><td> <p style="margin-left:0cm;">　　<span style="color:#ff0000;">TDO</span></p> </td><td> <p style="margin-left:0cm;">连接STM32的JTAG TDO</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　14. SWIM-RST</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　15. STM32-RESET</p> </td><td> <p style="margin-left:0cm;">　　<span style="color:#ff0000;">RESET</span></p> </td><td> <p style="margin-left:0cm;">连接STM32目标板的RESET端口</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　16. KEY</p> </td><td> <p style="margin-left:0cm;">　　NC</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　17. NC</p> </td><td> <p style="margin-left:0cm;">　　NC</p> </td><td> <p style="margin-left:0cm;">Unused</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　18. GND</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　19. VDD</p> </td><td> <p style="margin-left:0cm;">　　NC</p> </td><td> <p style="margin-left:0cm;">VDD (3.3V)</p> </td></tr><tr><td> <p style="margin-left:0cm;">　　20. GND</p> </td><td> <p style="margin-left:0cm;">　　GND</p> </td><td> <p style="margin-left:0cm;">GROUND</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"><strong>下面是</strong><strong>ST-Link/V2 JTAG/SWD</strong><strong>标准的接口排列：</strong></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="207" src="https://images2.imgbox.com/c6/5d/368CA6nF_o.png" width="405"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">ST-Link/V2 JTAG/SWD指定的标准接口</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b323f280ecc91a1645db12153a058077/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea srping boot 加入 钉钉  maven打包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95b9b737ad21695ad933509b8803a83b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">已知向量AB, AC。  AB朝着AC旋转一定角度N, 求B的新坐标</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>