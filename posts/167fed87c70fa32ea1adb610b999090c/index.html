<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>异常检测从入门到应用 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="异常检测从入门到应用" />
<meta property="og:description" content="点击上方“小白学视觉”，选择加&#34;星标&#34;或“置顶”
重磅干货，第一时间送达
作者：成森@知乎
来源：https://zhuanlan.zhihu.com/p/116235115
异常检测(Anomaly Detection), 作为机器学习的一个重要分支，实际应用领域广泛，本文作者通过一些有趣的卡通形象作为例子讲解了异常检测的基本概念及分类，并介绍了带标签与不代表标签的异常检测方法和计算过程。
01
什么是 Anomaly（异常）？
虽然说是异常，但其实是以训练集为核心，判断输入数据是否与训练集中的数据 “类似”。在不同的领域可以有不同的叫法，比如：outlier Detection，novelty Detection，exceptions Detection。
至于什么才是“类似”，它的定义取决于你所用的方法。如下图所示，如果你给的训练集只有雷丘，那么比卡丘就是“异常”；相反，如果你给的训练集是比卡丘，那雷丘就是“异常”。
什么是异常取决于你所给的训练集
1.1 问题定义 Problem Formulation 给定一个训练集 我们要找到一个函数来检测 输入 x 是不是属于训练集（是否和训练集的数据属于同一类）
用来判断是否和训练集属于一类
1.2 为什么不能用二分类来解决这个问题？ 如上面所说的，所谓“异常”，其实就是看是否和训练集“相似”，虽然我们很容易获得正训练集（如上面的雷丘），但是负训练集我们无法来决定，如果我们用 宝可梦 来作为负训练集来训练二分类，那下次输入一个 亚古兽 呢？这时候二分类模型就无法识别这个没见过的 负样本，而这样的负样本实在是太多了，我们没法穷举。如下图所示。
负样本的种类太多反而无法用来训练二分类器
更坏的情况就是，很多情景下，我们没法收集到负样本。比如说刷卡行为，大多数情况都只是正常的交易行为，而盗刷这一类情况就少之又少，甚至（目前）没有。
所以异常检测无法简化成二分类来实现，这是一个独立的研究主题。
1.3 异常检测模型分类 根据给出的训练集，我们可以大致将其分成两大类三小类：
(labeled)训练集中每个样本都有标签，用这些样本来训练一个分类器，这个分类器除了能够识别训练集中已有样本标签外，还能输出 “unknown” 标签，用来表示该输入是“没见过的”、不在训练集中的。我们把它叫做 “open-set recognition（开放式识别）”
(unlabeled)另一种情况是，我的训练集是没有标签的
（clean）但这个训练集是“干净”的，我们可以将这个训练集里所有的样本都视为“正样本“;
（polluted）然而干净的数据集在现实应用中很少，大多数都是或多或少参杂着”异常样本“，而且你无法知道，比如说银行给你大量刷卡数据进行训练，而这些数据里有可能有盗刷的数据且没有标注出来。
异常检测的两大类三小类
02
Labeled（带标签）
在这里就用 辛普森家族 来举例子。这里有一堆辛普森家族的人物形象及其对应的人物名称（视为标签），这样我们就能训练一个“辛普森角色分类器”，输入一个人物的形象，输出该人物的名称（标签）。
辛普森家族的人物形象及其名称标签，训练一个分类器
那我们训练好“辛普森角色分类器”后，这个分类器会输出两类数据：类别（预测的名字）、信心值；然后给定一个阈值 ，当信心度大于这个阈值，就视为“正常值（属于辛普森家族）”，低于则视为“异常值（不属于辛普森家族）”
分类器的使用
分类器的输出其实是一个概率分布(distribution)，输出前经过一个 softmax，使得这个分布中的值之和为1，其输出每一项 表示 每一个类别及其对应的信心值；我们将其中的最大值，视为分类器对该输入的信心值.
除了最高值，我们还可以用 熵（entropy）来决定分类器最后的信心值。
如下图所示，第一个分类器中，霸子的信心值很高（总体熵低），且其他很低，就说明分类器能够很好地把这个人物形象进行分类，故认为该形象是“正常值”；
而第二个分类器中，每一类的信心值都不高且均匀（最大值不高，总体熵高），说明分类器没见过该形象，信心不够，没法很好地区分，则可以认为该形象是“异常值”。
辛普森家族分类器，输出了类别和信心度
除了用分类器与其输出的分布来 判断 该分类器的信心度，当然还有其他的方式，如下图所说的，不仅输出分布（用来分类），还教分类器直接输出其信心度（直接可以判断是否异常）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/167fed87c70fa32ea1adb610b999090c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-30T10:05:53+08:00" />
<meta property="article:modified_time" content="2023-12-30T10:05:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">异常检测从入门到应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;">点击上方“<strong>小白学视觉</strong>”，选择加"星标"或“置顶”</p> 
 <p style="text-align:center;">重磅干货，第一时间送达<img src="https://images2.imgbox.com/e1/53/HdbqfFoI_o.jpg" alt="da702faaf214435ac485295a00955008.jpeg"></p> 
 <p>作者：成森@知乎</p> 
 <p style="text-align:justify;">来源：https://zhuanlan.zhihu.com/p/116235115</p> 
 <p style="text-align:justify;">异常检测(Anomaly Detection), 作为机器学习的一个重要分支，实际应用领域广泛，本文作者通过一些有趣的卡通形象作为例子讲解了异常检测的基本概念及分类，并介绍了带标签与不代表标签的异常检测方法和计算过程。</p> 
 <p style="text-align:center;"><strong>01</strong><br></p> 
 <p style="text-align:center;"><strong>什么是 Anomaly（异常）？</strong></p> 
 <p style="text-align:justify;">虽然说是异常，但其实是以训练集为核心，判断输入数据是否与训练集中的数据 “类似”。在不同的领域可以有不同的叫法，比如：outlier Detection，novelty Detection，exceptions Detection。</p> 
 <p style="text-align:justify;">至于什么才是“类似”，它的定义取决于你所用的方法。如下图所示，如果你给的训练集只有雷丘，那么比卡丘就是“异常”；相反，如果你给的训练集是比卡丘，那雷丘就是“异常”。</p> 
 <img src="https://images2.imgbox.com/60/7f/5tk1zVpw_o.jpg" alt="c2534333d620a44f9ce5b75a046db387.jpeg"> 
 <p style="text-align:center;">什么是异常取决于你所给的训练集</p> 
 <h4><strong>1.1 问题定义 Problem Formulation</strong></h4> 
 <ul><li><p>给定一个训练集 </p></li><li><p>我们要找到一个函数来检测 输入 x 是不是属于训练集（是否和训练集的数据属于同一类）</p></li></ul> 
 <img src="https://images2.imgbox.com/3d/4d/HPPPQHj9_o.jpg" alt="fc77e1234b544ce2d2e58becd97d5ebc.jpeg"> 
 <p style="text-align:center;">用来判断是否和训练集属于一类</p> 
 <h4><strong>1.2 为什么不能用二分类来解决这个问题？</strong></h4> 
 <p style="text-align:justify;">如上面所说的，所谓“异常”，其实就是看是否和训练集“相似”，虽然我们很容易获得正训练集（如上面的雷丘），但是负训练集我们无法来决定，如果我们用 宝可梦 来作为负训练集来训练二分类，那下次输入一个 亚古兽 呢？这时候二分类模型就无法识别这个没见过的 负样本，而这样的负样本实在是太多了，我们没法穷举。如下图所示。</p> 
 <img src="https://images2.imgbox.com/0a/62/sF5eCp4Z_o.jpg" alt="3965e78c987811670349d20a39606885.jpeg"> 
 <p style="text-align:center;">负样本的种类太多反而无法用来训练二分类器</p> 
 <p style="text-align:justify;">更坏的情况就是，很多情景下，我们没法收集到负样本。比如说刷卡行为，大多数情况都只是正常的交易行为，而盗刷这一类情况就少之又少，甚至（目前）没有。</p> 
 <p style="text-align:justify;">所以异常检测无法简化成二分类来实现，这是一个独立的研究主题。</p> 
 <h4><strong>1.3 异常检测模型分类</strong></h4> 
 <p style="text-align:justify;">根据给出的训练集，我们可以大致将其分成两大类三小类：</p> 
 <ul><li><p>(labeled)训练集中每个样本都有标签，用这些样本来训练一个分类器，这个分类器除了能够识别训练集中已有样本标签外，还能输出 “unknown” 标签，用来表示该输入是“没见过的”、不在训练集中的。我们把它叫做 “open-set recognition（开放式识别）”</p></li><li><p>(unlabeled)另一种情况是，我的训练集是没有标签的</p> 
   <ul><li><p>（clean）但这个训练集是“干净”的，我们可以将这个训练集里所有的样本都视为“正样本“;</p></li><li><p>（polluted）然而干净的数据集在现实应用中很少，大多数都是或多或少参杂着”异常样本“，而且你无法知道，比如说银行给你大量刷卡数据进行训练，而这些数据里有可能有盗刷的数据且没有标注出来。</p></li></ul></li></ul> 
 <img src="https://images2.imgbox.com/1f/5e/LmTqXiEP_o.jpg" alt="02ef7e34dd4ae6afb2321b389098ef53.jpeg"> 
 <p style="text-align:center;">异常检测的两大类三小类</p> 
 <h3><br></h3> 
 <p style="text-align:center;"><strong>02</strong><br></p> 
 <p style="text-align:center;"><strong>Labeled（带标签）</strong></p> 
 <p style="text-align:justify;">在这里就用 辛普森家族 来举例子。这里有一堆辛普森家族的人物形象及其对应的人物名称（视为标签），这样我们就能训练一个“辛普森角色分类器”，输入一个人物的形象，输出该人物的名称（标签）。</p> 
 <img src="https://images2.imgbox.com/e5/db/NAupIkB3_o.jpg" alt="06a960812e49d9ecfec1c0074312934c.jpeg"> 
 <p style="text-align:center;">辛普森家族的人物形象及其名称标签，训练一个分类器</p> 
 <p style="text-align:justify;">那我们训练好“辛普森角色分类器”后，这个分类器会输出两类数据：类别（预测的名字）、信心值；然后给定一个阈值  ，当信心度大于这个阈值，就视为“正常值（属于辛普森家族）”，低于则视为“异常值（不属于辛普森家族）”</p> 
 <img src="https://images2.imgbox.com/53/8e/76jiM9Hh_o.jpg" alt="41340dfc1c17e753d788751d2bb04047.jpeg"> 
 <p style="text-align:center;">分类器的使用</p> 
 <p style="text-align:justify;">分类器的输出其实是一个概率分布(distribution)，输出前经过一个 softmax，使得这个分布中的值之和为1，其输出每一项 表示 每一个类别及其对应的信心值；我们将其中的最大值，视为分类器对该输入的信心值.</p> 
 <blockquote> 
  <p>除了最高值，我们还可以用 熵（entropy）来决定分类器最后的信心值。</p> 
 </blockquote> 
 <p style="text-align:justify;">如下图所示，第一个分类器中，霸子的信心值很高（总体熵低），且其他很低，就说明分类器能够很好地把这个人物形象进行分类，故认为该形象是“正常值”；</p> 
 <p style="text-align:justify;">而第二个分类器中，每一类的信心值都不高且均匀（最大值不高，总体熵高），说明分类器没见过该形象，信心不够，没法很好地区分，则可以认为该形象是“异常值”。</p> 
 <img src="https://images2.imgbox.com/4d/e7/IBfqAfv2_o.jpg" alt="5025a9fc2e0a34e3da0afa8a1f248236.jpeg"> 
 <p style="text-align:center;">辛普森家族分类器，输出了类别和信心度</p> 
 <p style="text-align:justify;">除了用分类器与其输出的分布来 判断 该分类器的信心度，当然还有其他的方式，如下图所说的，不仅输出分布（用来分类），还教分类器直接输出其信心度（直接可以判断是否异常）。</p> 
 <img src="https://images2.imgbox.com/57/60/OVKYgvmd_o.jpg" alt="eb6aa2c68f746f16cde501f9265f6bf3.jpeg"> 
 <p style="text-align:center;">可以直接输出分类和信心值的分类器</p> 
 <blockquote> 
  <p>关于上面模型训练部分，一般来说我们有个“验证集”来调节模型的超参数，在“训练集”中，所有的样本都是“正样本“且有各自的标签（如都是辛普森和他们的人物名字），而在”验证集“中就没必要每个样本都有其“人物标签”，只需要判断其“是否属于辛普森家族”就行了（两个标签：属于、不属于）。</p> 
 </blockquote> 
 <h4><strong>2.1 评价标准</strong></h4> 
 <p style="text-align:justify;">在上面的例子中，“辛普森家族异常检测模型“其实是一个普通分类器，那我们是否也可以用准确率（Accuracy）来评估这个模型的好坏呢？答案是：这不是一个好的选择。</p> 
 <p style="text-align:justify;">正如我们前面所说的，异常检测的数据集的标签分布是不均匀的，也就是说我们很大概率能够找到“正样本”而缺少“负样本”；这种情况下，如果模型“无情地”把所有的样本都预测成正样本，那准确率也会很高，这样显然是不对的。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b5/ad/rSc5NhzP_o.jpg" alt="98b5fa2666d3d5e508660a25617d39d8.jpeg">在这里，只有5张“异常图片”，模型准确率却很高</p> 
 <p style="text-align:justify;">准确率对于不平衡数据没法很好地评估，其实也有很多方法来解决，比如说成本积分制：当正常数据没有检测出，则成本为100，异常数据没有检测出，成本为1（见Cost Table A），这时候左边模型的成本则会低于右边模型的成本（红色字体），则左边的模型更优秀； 而如果正常数据没检测出的成本为1，异常数据没检测出的成本为100，这时候右边的模型就更优秀（蓝色字体）；</p> 
 <p style="text-align:justify;">积分制的使用要取决于你对业务的理解：异常数据没检测出、正常数据没检测出，哪个更加重要？比如在医疗上，对于癌细胞的异常检测，宁愿检测错正常人，也不要漏过一个病人，这时候“异常数据没检测出的成本更高”。</p> 
 <p style="text-align:justify;">除了积分制，还有很多方法，比如AUC、Macro-F1等等。</p> 
 <img src="https://images2.imgbox.com/41/01/lDRUbdWv_o.jpg" alt="5cfe694e8746e995286cbb1ae5b7ff24.jpeg"> 
 <p style="text-align:center;">积分制，左边模型和右边模型谁更优秀取决于Cost Table的定制</p> 
 <h4><strong>2.2 存在的问题</strong></h4> 
 <p style="text-align:justify;">分类器也许可以能够对“一般异常”进行“识别”，比如下面猫狗的分类器，就能够把羊驼和马来貘识别为“异常”，然而有一些“异常数据”则没那么容易了，比如说老虎和狼，这就是模型泛化问题；</p> 
 <p style="text-align:justify;">因为模型一般只会抽取出一类图片中的共同特征，而此时“异常数据”无意中也具备了这一共同特征，那么就会出现把狼识别成狗的情况了。</p> 
 <img src="https://images2.imgbox.com/3a/fa/PWCO844Q_o.jpg" alt="ade6322d74d722bfaf4ce3ce8f8a7ff9.jpeg"> 
 <p style="text-align:center;">下面的模型把老虎识别成猫，把狼识别成狗</p> 
 <p style="text-align:justify;">另一个例子就是上面的“辛普森家族分类器”，将人物涂黄后，模型就会进一步识别成“丽莎”，这就说明了模型识别丽莎靠的是颜色，这显然是不正确的。</p> 
 <img src="https://images2.imgbox.com/20/e9/1ZUzWo5h_o.jpg" alt="282f6fa2acdf753d17dc630ffc7aacfd.jpeg"> 
 <p style="text-align:center;">图片涂改后，就会识别成其他人物</p> 
 <p style="text-align:justify;">针对以上存在的问题，也有很多工作试图去解决，比如说收集一些“异常数据”，让分类器去学习给它们更低的信心值；然而我们一开始就说了，异常数据很难获取，那我们就想：能不能自动生成“异常数据”？</p> 
 <p style="text-align:justify;">这时候我们就可以用GAN来尝试生成“有点像正常数据却又没那么像”的异常数据。</p> 
 <p style="text-align:justify;">下面给出了相关文献，有兴趣的可以去了解一下。</p> 
 <img src="https://images2.imgbox.com/10/2d/slMgbql0_o.jpg" alt="c0c8048f8d9c3b0141b1bcf724b5784e.jpeg"> 
 <p style="text-align:center;">解决该问题的相关文献</p> 
 <h3><br></h3> 
 <p style="text-align:center;"><strong>03</strong><br></p> 
 <p style="text-align:center;"><strong>Without Labels(不带标签的)</strong></p> 
 <p style="text-align:justify;">这一部分，就是得到了没有标签的数据。该问题的定义和带标签的分类器一样，都是根据训练集训练模型，然后帮我分析输入数据相较于训练集是否属于异常数据。与分类器给出的信心值不同，这一类的模型给出的是一个概率，如果概率大于某个阈值，才认为是正常值；</p> 
 <p style="text-align:justify;">在这一部分，用一个游戏举个例子：Twitch Plays Pokemon。这个游戏是一个多人同时“玩一个角色”的在线游戏，然而和我们平时玩的网游不一样，在这个游戏中，下一步动作取决于所有在线用户的操作（如下图的右边，是每一个用户按下的指令）。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/f3/fd/NOWwsGxz_o.jpg" alt="b41f71ddd48c312c7eddb53ea0dfbaea.jpeg">众多用户的指令靠某种机制共同决定游戏角色下一步操作</p> 
 <p style="text-align:justify;">然而玩这个游戏的人非常崩溃，因为这个游戏很难进行下去（因为要所有在线玩家都给一个角色发送指令，而每个玩家的指令又不相同，而游戏只会执行其中一个指令）。所以玩家们就在想：是不是有些“恶意玩家”在乱发送指令，阻止游戏进程？也就是说是不是有人不想让这个游戏结束。</p> 
 <p style="text-align:justify;">这样我们就有需求——找出“恶意用户”。在这之前，我们先有个假设：大部分玩家都希望完成这个游戏（也就是说大部分都是正常数据），而这部分数据我们会用来训练。然后我们使用异常检测，找出其中的“恶意玩家”（异常数据）。</p> 
 <img src="https://images2.imgbox.com/83/22/KCK59tZT_o.jpg" alt="9841d2ed8aeff4720ffc93e1d53e66e5.jpeg"> 
 <p style="text-align:center;">由该游戏产生的思考</p> 
 <p style="text-align:justify;">接下来，我们就要对其进行建模。在这里，我们的需求是把一堆“无标签”玩家分为正常用户和异常用户，这时我们需要把用户表示成一个向量，这样才能输入进我们的模型；而向量中的每一项可以表示这个用户的一种行为。</p> 
 <p style="text-align:justify;">如下图，  表示这个用户过去一段时间内说垃圾话的频率（垃圾话是指游戏指令之外的话，多余的，不影响游戏进程）,  表示的是这个用户过去一段时间内，随机机制下的发言频率。</p> 
 <blockquote> 
  <p>这个游戏有两种机制：投票机制和随机机制 投票机制：20秒内最多玩家输入的指令，则作为游戏下一步的指令；随机机制：随机选择在线玩家输入的指令，作为游戏下一步的指令。</p> 
 </blockquote> 
 <img src="https://images2.imgbox.com/da/85/Sea9eexA_o.jpg" alt="1fea7365911f13a7a331f3f99ce1a37f.jpeg"> 
 <p style="text-align:center;">用向量表示用户</p> 
 <p style="text-align:justify;">输入定义好了，我们就可以看看输出：模型会输出一个概率  ，和分类器不一样，无标签训练模型没有对应的Y值（标签）和信心值，只会输出一个概率  ；而和分类器相似的是，我们一样有一个  ，当  时，视为正常数据；当  时，视为异常数据。如下图所示。</p> 
 <img src="https://images2.imgbox.com/2a/89/3KeUCgiE_o.jpg" alt="a65e1bdce770cc85c4bec16d51a94e8f.jpeg"> 
 <p style="text-align:center;">输出一个概率值，需要设定一个阈值</p> 
 <p style="text-align:justify;">假设我们现在已经获取了大量用户的数据，下图是这些数据可视化展示。从可视化中可以获得一些信息：</p> 
 <ul><li><p>在随机机制下，用户就越喜欢发指令（左上图）；</p></li><li><p>大部分用户都会或多或少地乱输入指令（说垃圾话，右下图）。</p></li></ul> 
 <p style="text-align:justify;">这时候，我们就可以很直观地看到，但用户落在左上角的位置，则很大可能这就是一个“正常玩家”，而用户落在靠右或者靠下的位置，则很大可能是“异常玩家”。</p> 
 <img src="https://images2.imgbox.com/9a/34/wjLFCObH_o.jpg" alt="2940d2eacdbf79148e36089c4026d732.jpeg"> 
 <p style="text-align:center;">已知用户行为数据的可视化图</p> 
 <p style="text-align:justify;">然而，我们需要一个数值化的表示方法，给每一个玩家一个分数。</p> 
 <p style="text-align:justify;">假设我们之前看到的图，图上面所有的点都是由一个概率密度函数  生成的（不懂也没关系，就当它是一个函数就行了），  是该函数的参数，决定了这个函数“长什么样”，是未知的，需要从数据中学习。</p> 
 <p style="text-align:justify;">而我们的工作就变成了：  它究竟长什么样？这时候我们就需要一个“Likelihood”的概念，意思就是说，根据我们的概率密度函数  ，能够产生这样的已知数据的概率有多大。</p> 
 <blockquote> 
  <p>如果严格来说，  输出的不是概率，而是概率密度，它的值也不是介于0～1之间，而是有可能大于1的。在这里，为了简化问题，我们简单地认为是概率就好。</p> 
 </blockquote> 
 <p style="text-align:justify;">而这个“Likelihood”要怎么算呢，它其实就等于每项已知数据根据  这个函数所产生出来的概率的乘积；于是我们就有下面这条公式，很显然，这个公式是由  来控制的，不同的  ，就会有不同的  ，就会算出不同的“Likelihood”</p> 
 <p style="text-align:justify;">这时候，我们并不知道  是多少，但我们知道，这个  ，能够使我们的“Likelihood”最大化</p> 
 <img src="https://images2.imgbox.com/3f/4b/9MvqJg5X_o.jpg" alt="1326a515184b78c23d4c50512a57b340.jpeg"> 
 <p style="text-align:center;">我们使用Likelihood来训练模型</p> 
 <p style="text-align:justify;">上面是只是一个抽象的说法。在这里，我们为了让大家更好理解，我们就假设概率密度函数  为常用的高斯分布（Gaussian Distribution），这个概率密度函数并不简单，大家看不懂也没关系，就当它是一个普通函数就可以了，输入一个向量x，输出这个x被采样到的概率  ；而我们前面提到需要学习的  ，在这里就等于这里需要学习的均值  和协方差矩阵。</p> 
 <blockquote> 
  <p>为什么这里选择高斯分布？其实这只是举例子，  甚至可以是一个神经网络，而此时  就是神经网络的参数，所以我们没必要在这里纠结，我们只需要清楚无标签时，异常检测是如何处理的，从而触类旁通。</p> 
 </blockquote> 
 <img src="https://images2.imgbox.com/20/35/XQGWrWws_o.jpg" alt="6ac73a8fe02c887e32e84510d2b3833f.jpeg"> 
 <p style="text-align:center;">高斯分布，及其需要学习的参数</p> 
 <p style="text-align:justify;">这时候，Likelihood方程就会置换成下图的形式，用来找出能使Likelihood最大化的  和  。</p> 
 <p style="text-align:justify;">左图给了一个很好的示例，告诉我们，  的取值，如何影响Likelihood的取值；左上角时，数据落在这个区域的概率就很大，这时候Likelihood就很大，而右下角时，落在这个区域的概率就小，这是Likelihood就小。</p> 
 <p style="text-align:justify;"> 和  其实是有公式算出来的，  就是所有的训练数据的向量做一个平均（输入向量是二维的，所以  也是二维的），而  就看图的右下角这个公式，这里很简单。</p> 
 <img src="https://images2.imgbox.com/87/96/Wjzms92G_o.jpg" alt="abef674583d9364de0a7985926bfde47.jpeg"> 
 <p style="text-align:center;">抽象的概念替换为具体的高斯分布时的计算方法</p> 
 <p style="text-align:justify;">在这里，我们已经得到了  和  ，我们可以用来做异常检测，我们把测试数据代入我们的高斯分布方程，我们就能算出其概率，如果这个概率大于阈值  ，是认为是正常值，否则视为异常值。</p> 
 <p style="text-align:justify;">如果我们用这个训练好的方程，大概就是下图右下角的样子，颜色越深代表这个方程输出的数值就越大，就越代表“正常玩家”，而颜色越浅越蓝的，就代表“异常玩家”；而这个阈值  ，其实其中一条等高线；右下图就给出了正常点和异常点的位置示意。</p> 
 <img src="https://images2.imgbox.com/ab/13/MHPMfdSw_o.jpg" alt="9dbd76ef11e0f4eb085e1deef25c138c.jpeg"> 
 <p style="text-align:center;">根据公式，可以获得其对应的概率，从而判断是否异常</p> 
 <p style="text-align:justify;">以上的例子，我们只是使用了两个特征，也就是输入向量x只是二维；而机器学习的好处就是可以处理更多特征，只要你想到的，都可以加进去。下图就增加到5个特征，再训练一个Likelihood，从而获得“更准确的”异常检测效果。</p> 
 <img src="https://images2.imgbox.com/ae/fb/6iGcnBUF_o.jpg" alt="3c0972a1ab49569ef1bfd9a47dd8fad2.jpeg"> 
 <p style="text-align:center;">我们可以添加更多的特征</p> 
 <h4><strong>3.1 更多的方法</strong></h4> 
 <p style="text-align:justify;">除了上面的方法，还有一种常用方法是：Auto-encoder（自动编码器），如下图所示，Encoder（编码器）先把辛普森的照片编码成一个code（隐含层），然后Decoder（解码器）把code解码回原来的的照片，训练时会同时训练编码器和解码器，尽量让解码后的照片和原照片尽可能相似（甚至相同）。这时候如果用Auto-encoder来识别一张“异常图片”，这时候的解码器是无法重构回原来的照片，通过计算重构后的照片和原照片的“距离”（或者说是相似度、还原度），就可以区分该照片是不是“异常值”。</p> 
 <blockquote> 
  <p>在我看来，Auto-encoder比分类器多了一重保障（指Decoder解码器），在分类器上，找到对应的特征，就进行判断，比如颜色、轮廓等等，上面就有例子说明这样的情况并不可靠；而解码器就是一种利用特征的过程，我利用编码器提取的特征，看是否能够重构回原来照片，就能知道这是不是异常值；</p> 
 </blockquote> 
 <img src="https://images2.imgbox.com/3e/62/RO8wWCyi_o.jpg" alt="53035ea91eb33864d3d3096f9a2a827f.jpeg"> 
 <p style="text-align:center;">自动编码器的工作流程</p> 
 <p style="text-align:justify;">下图是正常的图片，可以看到模型很容易就重构了回来，而且和原图非常接近。因为这个模型看过辛普森，所以非常“擅长”还原辛普森。</p> 
 <img src="https://images2.imgbox.com/d4/71/e3NQqMRU_o.jpg" alt="2ec34b6fccce5bfd2bca48c47fb5c8f3.jpeg"> 
 <p style="text-align:center;">辛普森家族的照片就能很好地复原</p> 
 <p style="text-align:justify;">如下图的Testing阶段，对比原图和重构图，我们可以看到，编码器提取到的应该是“黄色”和“棕色”这两个特征，然而编码器用两个特征构建出来的图片，显然和原图相差甚远，这时候就可以识别为“异常值”。（从重构图可以隐约看到，这大概也是一个辛普森角色）</p> 
 <img src="https://images2.imgbox.com/07/1c/APTUIqSN_o.jpg" alt="87097a454eb3312d7d7095c4a386a958.jpeg"> 
 <p style="text-align:center;">其他图片就会复原到模型所“理解”到的辛普森角色形象</p> 
 <p style="text-align:justify;">除了自动编码器，还有很多其他模型可以做这样的事，比如one-class SVM，Isolated Forest。有兴趣的可以自行进一步学习。</p> 
 <img src="https://images2.imgbox.com/d0/37/inI3FuPF_o.jpg" alt="45c7a9a373d6ed404c231f2868c38037.jpeg"> 
 <p style="text-align:center;">更多的模型</p> 
 <h3><br></h3> 
 <p style="text-align:center;"><strong>04</strong><br></p> 
 <p style="text-align:center;"><strong>应用</strong></p> 
 <p style="text-align:justify;">异常检测的应用非常广泛，下面几项是非常常见的：</p> 
 <ul><li><p>Fraud Detection（欺诈识别）</p> 
   <ul><li><p>训练集：正常的刷卡行为；输入x：盗刷行为？</p></li></ul></li><li><p>Network Intrusion Detection（网络入侵检测）</p> 
   <ul><li><p>训练集：正常的访问；输入x：攻击行为？</p></li></ul></li><li><p>Cancer Detection（癌症检测）</p> 
   <ul><li><p>训练集：正常细胞；输入x：癌细胞</p></li></ul></li></ul> 
 <p style="text-align:justify;">参考文献：</p> 
 <p style="text-align:justify;">https://www.bilibili.com/video/BV1Gb411n7dE?p=8</p> 
 <pre class="has"><code class="language-go">下载1：OpenCV-Contrib扩展模块中文版教程

在「小白学视觉」公众号后台回复：扩展模块中文教程，即可下载全网第一份OpenCV扩展模块教程中文版，涵盖扩展模块安装、SFM算法、立体视觉、目标跟踪、生物视觉、超分辨率处理等二十多章内容。


下载2：Python视觉实战项目52讲
在「小白学视觉」公众号后台回复：Python视觉实战项目，即可下载包括图像分割、口罩检测、车道线检测、车辆计数、添加眼线、车牌识别、字符识别、情绪检测、文本内容提取、面部识别等31个视觉实战项目，助力快速学校计算机视觉。


下载3：OpenCV实战项目20讲
在「小白学视觉」公众号后台回复：OpenCV实战项目20讲，即可下载含有20个基于OpenCV实现20个实战项目，实现OpenCV学习进阶。


交流群

欢迎加入公众号读者群一起和同行交流，目前有SLAM、三维视觉、传感器、自动驾驶、计算摄影、检测、分割、识别、医学影像、GAN、算法竞赛等微信群（以后会逐渐细分），请扫描下面微信号加群，备注：”昵称+学校/公司+研究方向“，例如：”张三 + 上海交大 + 视觉SLAM“。请按照格式备注，否则不予通过。添加成功后会根据研究方向邀请进入相关微信群。请勿在群内发送广告，否则会请出群，谢谢理解~</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4abc184c20db4dad1f64795dfa0f0db0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【SpringCloud】从实际业务问题出发去分析Eureka-Server端源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/536b945c7419f9af14e47cd6fc2fb02b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue、react、angular 区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>