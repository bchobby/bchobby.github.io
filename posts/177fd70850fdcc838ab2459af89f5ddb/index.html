<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>硬盘文件系统系列专题之二 NTFS - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="硬盘文件系统系列专题之二 NTFS" />
<meta property="og:description" content="一、NTFS概述
NTFS (New Technology File System)，是 WindowsNT 环境的文件系统。新技术文件系统是Windows NT家族（如常见的Windows XP、Win7 、Win8、Win10）等的限制级专用的文件系统（操作系统所在的盘符的文件系统必须格式化为NTFS的文件系统，4096簇环境下）。NTFS取代了老式的FAT文件系统。
NTFS可以支持的分区(如果采用动态磁盘则称为卷)大小可以达到2TB。而Windows2000中的FAT32支持分区的大小最大为32GB。
当用户将硬盘的一个分区格式化成NTFS分区时，就建立了一个NTFS文件系统结构。NTFS文件系统与FAT文件系统一样，也是用簇为基本单位对磁盘空间和文件存储进行管理的。
NTFS采用了更小的簇,可以更有效率地管理磁盘空间。FAT32文件系统的情况下，分区大小在2GB～8GB时簇的大小为4KB；分区大小在8GB～16GB时簇的大小为8KB；分区大小在16GB～32GB时,簇的大小则达到了16KB。而NTFS文件系统，当分区的大小在2GB以下时，簇的大小都比相应的FAT32簇小; 当分区的大小在2GB以上时(2GB～2TB),簇的大小都为4KB。相比之下，NTFS可以比FAT32更有效地管理磁盘空间，最大限度地避免了磁盘空间的浪费。
NTFS分区也被称为NTFS卷，卷上簇的大小，又称为卷因子，其大小是用户在创建NTFS卷时确定的。和FAT文件系统一样，卷因子的大小和文件系统的性能有着非常直接的关系。当一样簇占用的空间太小时，会出现太多的磁盘碎片，这样的空间和文件访问时间上会造成浪费；而相反的当一个簇占用的空间太大时，直接造成了磁盘空间的浪费。因此，最大限度地优化系统对文件的访问速度和最大限度地减少磁盘空间的浪费是确定簇的大小的主要因素。簇的大小一定是扇区大小的整数倍，Win7/8/10系统中通常是8（n为整数），也即簇的大小都为4KB。
NTFS文件系统使用了逻辑簇号（LCN）和虚拟簇号（VCN）对卷进行管理。其中LCN是对卷的第一个簇到最后一个簇进行编号，只要知道LCN号和簇的大小以及NTFS卷在物理磁盘中的起始扇区就可以对簇进行定位，而这些信息在NTFS卷的引导扇区中可以找到，在系统底层也是用这种方法对文件的簇进行定位的。找到簇在磁盘中的物理位置的计算公式是：
每簇扇区数*簇号&#43;卷的隐含扇区数（卷之前的扇区总数）=簇的起始绝对扇区号
而虚拟簇号则是将特定文件的簇从头到尾进行编号，这样做的原因是方便系统对文件中的数据进行引用，VCN并不要求在物理上是连续的，要确定VCN的磁盘上的定位需先将其转换为LCN。
二、NTFS文件系统结构
NTFS最基本的原则：
(1)磁盘上任何对象包括目录都是一种文件，都使用文件记录进行管理。
(2)所有与文件相关的项目，包括数据都被认为是属性。
(3)属性分常驻（在记录中）和非常驻两种，非常驻的大文件夹使用B＋树结构进行管理。
(4)簇是NTFS最小的基本单位，一个1字节的文件也要占用一簇的空间。
(5)流是NTFS最基本的存储单元，是文件属性和属性值的集合。
NTFS是以MFT（Master File Table，主文件表或主索引记录）为核心，将整个分区的系统文件和用户文件有机地组织起来的文件系统。
MFT文件和它的备份，位于NTFS分区中部，前后都是数据区，能更好地受到保护。与FAT系统先放文件分配表，后接数据区的做法不同。NTFS分区，大致布局如下图：
DBR
引导区
用户
数据
MFT
区
用户数据
MFT
部分记录备份
用户
数据
DBR
备份
分区所有的文件，其相关的文件信息都保存在MFT中。
a, 小于1K的小文件（目录），其整个内容都保存在MFT中。
b, 大于1K的大文件（目录），只有它的起始信息保存在MFT中。
分区高级格式化成NTFS文件系统时，首先建立了一个主文件表MFT。
在MFT文件中，会预先建立16个重要的文件（MFT记录的ID编号固定为0-15）和8个保留文件（MFT记录的ID编号固定为16-23），这24个文件是被称为元文件（Metafiles）或元数据（metadata）的系统文件（具体内容见后面），NTFS文件系统将这些数据都当做文件进行管理，这些文件用户是不能访问的，它们的文件名的第一个字符都是“$”，表示该文件是隐藏的。
而用户的文件在MFT中的ID编号从24后开始排，用户每添加一个文件，ID号加1。当某文件被删除时，与之对应的MFT记录将被空出来，如果此时再添加文件，系统会优先填充ID小的空位。MFT尽量保持其物理上的连续性，可将磁盘碎片降至最低。
序号
元文件
功能
0
$MFT
主文件表本身
1
$MFTMirr
主文件表的部分镜像
2
$LogFile
日志文件
3
$Volume
卷文件
4
$AttrDef
属性定义列表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/177fd70850fdcc838ab2459af89f5ddb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-10T19:43:27+08:00" />
<meta property="article:modified_time" content="2022-09-10T19:43:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">硬盘文件系统系列专题之二 NTFS</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、NTFS概述</p> 
<p>NTFS (New Technology File System)，是 WindowsNT 环境的文件系统。新技术文件系统是Windows NT家族（如常见的Windows XP、Win7 、Win8、Win10）等的限制级专用的文件系统（操作系统所在的盘符的文件系统必须格式化为NTFS的文件系统，4096簇环境下）。NTFS取代了老式的FAT文件系统。</p> 
<p></p> 
<p>NTFS可以支持的分区(如果采用动态磁盘则称为卷)大小可以达到2TB。而Windows2000中的FAT32支持分区的大小最大为32GB。<br>  </p> 
<p>当用户将硬盘的一个分区格式化成NTFS分区时，就建立了一个NTFS文件系统结构。NTFS文件系统与FAT文件系统一样，也是用簇为基本单位对磁盘空间和文件存储进行管理的。</p> 
<p></p> 
<p>NTFS采用了更小的簇,可以更有效率地管理磁盘空间。FAT32文件系统的情况下，分区大小在2GB～8GB时簇的大小为4KB；分区大小在8GB～16GB时簇的大小为8KB；分区大小在16GB～32GB时,簇的大小则达到了16KB。而NTFS文件系统，当分区的大小在2GB以下时，簇的大小都比相应的FAT32簇小; 当分区的大小在2GB以上时(2GB～2TB),簇的大小都为4KB。相比之下，<strong>NTFS可以比FAT32更有效地管理磁盘空间，最大限度地避免了磁盘空间的浪费</strong>。<br>  </p> 
<p>NTFS分区也被称为NTFS卷，卷上簇的大小，又称为卷因子，其大小是用户在创建NTFS卷时确定的。和FAT文件系统一样，卷因子的大小和文件系统的性能有着非常直接的关系。当一样簇占用的空间太小时，会出现太多的磁盘碎片，这样的空间和文件访问时间上会造成浪费；而相反的当一个簇占用的空间太大时，直接造成了磁盘空间的浪费。因此，最大限度地优化系统对文件的访问速度和最大限度地减少磁盘空间的浪费是确定簇的大小的主要因素。簇的大小一定是扇区大小的整数倍，Win7/8/10系统中通常是8（n为整数），也即簇的大小都为4KB。</p> 
<p></p> 
<p>NTFS文件系统使用了逻辑簇号（LCN）和虚拟簇号（VCN）对卷进行管理。其中LCN是对卷的第一个簇到最后一个簇进行编号，只要知道LCN号和簇的大小以及NTFS卷在物理磁盘中的起始扇区就可以对簇进行定位，而这些信息在NTFS卷的引导扇区中可以找到，在系统底层也是用这种方法对文件的簇进行定位的。找到簇在磁盘中的物理位置的计算公式是：<br> 每簇扇区数*簇号+卷的隐含扇区数（卷之前的扇区总数）=簇的起始绝对扇区号</p> 
<p></p> 
<p>而虚拟簇号则是将特定文件的簇从头到尾进行编号，这样做的原因是方便系统对文件中的数据进行引用，VCN并不要求在物理上是连续的，要确定VCN的磁盘上的定位需先将其转换为LCN。</p> 
<p></p> 
<p>二、NTFS文件系统结构</p> 
<p>NTFS最基本的原则：<br> (1)磁盘上任何对象包括目录都是一种文件，都使用文件记录进行管理。<br> (2)所有与文件相关的项目，包括数据都被认为是属性。<br> (3)属性分常驻（在记录中）和非常驻两种，非常驻的大文件夹使用B＋树结构进行管理。<br> (4)簇是NTFS最小的基本单位，一个1字节的文件也要占用一簇的空间。<br> (5)流是NTFS最基本的存储单元，是文件属性和属性值的集合。</p> 
<p></p> 
<p>NTFS是以MFT（Master File Table，主文件表或主索引记录）为核心，将整个分区的系统文件和用户文件有机地组织起来的文件系统。</p> 
<p></p> 
<p>MFT文件和它的备份，位于NTFS分区中部，前后都是数据区，能更好地受到保护。与FAT系统先放文件分配表，后接数据区的做法不同。NTFS分区，大致布局如下图：</p> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p>DBR</p> <p>引导区</p> </td><td style="vertical-align:top;"> <p>用户</p> <p>数据</p> </td><td style="vertical-align:top;"> <p><strong>MFT</strong></p> <p><strong>区</strong></p> </td><td style="vertical-align:top;"> <p>用户数据</p> </td><td style="vertical-align:top;"> <p><strong>MFT</strong></p> <p><strong>部分记录备份</strong></p> </td><td style="vertical-align:top;"> <p>用户</p> <p>数据</p> </td><td style="vertical-align:top;"> <p>DBR</p> <p>备份</p> </td></tr></tbody></table> 
<p>分区所有的文件，其相关的文件信息都保存在MFT中。</p> 
<p>a, 小于1K的小文件（目录），其整个内容都保存在MFT中。</p> 
<p>b, 大于1K的大文件（目录），只有它的起始信息保存在MFT中。</p> 
<p></p> 
<p>分区高级格式化成NTFS文件系统时，首先建立了一个主文件表MFT。</p> 
<p></p> 
<p>在MFT文件中，会预先建立<strong>16个重要的文件（MFT记录的ID编号固定为0-15）和8个保留文件（MFT记录的ID编号固定为16-23）</strong>，这24个文件是被称为元文件（Metafiles）或元数据（metadata）的系统文件（具体内容见后面），NTFS文件系统将这些数据都当做文件进行管理，这些文件用户是不能访问的，它们的文件名的第一个字符都是“$”，表示该文件是隐藏的。</p> 
<p></p> 
<p>而用户的文件在MFT中的ID编号从24后开始排，用户每添加一个文件，ID号加1。<strong>当某文件被删除时，与之对应的MFT记录将被空出来，如果此时再添加文件，系统会优先填充ID小的空位</strong>。MFT尽量保持其物理上的连续性，可将磁盘碎片降至最低。</p> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>序号</p> </td><td> <p>元文件</p> </td><td> <p>功能</p> </td></tr><tr><td style="vertical-align:top;"> <p>0</p> </td><td style="vertical-align:top;"> <p>$MFT</p> </td><td style="vertical-align:top;"> <p>主文件表本身</p> </td></tr><tr><td style="vertical-align:top;"> <p>1</p> </td><td style="vertical-align:top;"> <p>$MFTMirr</p> </td><td style="vertical-align:top;"> <p>主文件表的部分镜像</p> </td></tr><tr><td style="vertical-align:top;"> <p>2</p> </td><td style="vertical-align:top;"> <p>$LogFile</p> </td><td style="vertical-align:top;"> <p>日志文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>3</p> </td><td style="vertical-align:top;"> <p>$Volume</p> </td><td style="vertical-align:top;"> <p>卷文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>4</p> </td><td style="vertical-align:top;"> <p>$AttrDef</p> </td><td style="vertical-align:top;"> <p>属性定义列表</p> </td></tr><tr><td style="vertical-align:top;"> <p>5</p> </td><td style="vertical-align:top;"> <p>$Root</p> </td><td style="vertical-align:top;"> <p>根目录</p> </td></tr><tr><td style="vertical-align:top;"> <p>6</p> </td><td style="vertical-align:top;"> <p>$Bitmap</p> </td><td style="vertical-align:top;"> <p>位图文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>7</p> </td><td style="vertical-align:top;"> <p>$Boot</p> </td><td style="vertical-align:top;"> <p>引导文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>8</p> </td><td style="vertical-align:top;"> <p>$BadClus</p> </td><td style="vertical-align:top;"> <p>坏簇文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>9</p> </td><td style="vertical-align:top;"> <p>$Secure</p> </td><td style="vertical-align:top;"> <p>安全文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>10</p> </td><td style="vertical-align:top;"> <p>$UpCase</p> </td><td style="vertical-align:top;"> <p>大写文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>11</p> </td><td style="vertical-align:top;"> <p>$Extend metadata directory</p> </td><td style="vertical-align:top;"> <p>扩展元数据目录</p> </td></tr><tr><td style="vertical-align:top;"> <p>12</p> </td><td style="vertical-align:top;"> <p>$Extend\$Reparse</p> </td><td style="vertical-align:top;"> <p>重解析点文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>13</p> </td><td style="vertical-align:top;"> <p>$Extend\$UsnJrnl</p> </td><td style="vertical-align:top;"> <p>变更日志文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>14</p> </td><td style="vertical-align:top;"> <p>$Extend\$Quota</p> </td><td style="vertical-align:top;"> <p>配额管理文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>15</p> </td><td style="vertical-align:top;"> <p>$Extend\$ObjId</p> </td><td style="vertical-align:top;"> <p>对象ID文件</p> </td></tr><tr><td style="vertical-align:top;"> <p>16-23</p> </td><td style="vertical-align:top;"></td><td style="vertical-align:top;"> <p>保留</p> </td></tr><tr><td style="vertical-align:top;"> <p>23＋</p> </td><td style="vertical-align:top;"></td><td style="vertical-align:top;"> <p>用户文件和目录</p> </td></tr></tbody></table> 
<p></p> 
<p><strong>$MFT中前16个文件记录总是元文件的记录，并且这16个文件记录的顺序是固定的</strong>，下面对这16个记录简单做一个介绍：</p> 
<p>第1个记录就是$MFT自身的记录，也就是说$MFT首先对自己进行管理。</p> 
<p></p> 
<p>第2个记录是$MFTMirr的记录，也就是$MFT前4个文件记录的镜像。</p> 
<p></p> 
<p>第3个记录是日志文件（$LogFile）的记录，该文件是NTFS为实现可恢复性和安全性而设计的。当系统运行时，NTFS就会在日志文件中记录所有影响NTFS卷结构的操作，包括文件的创建和改变目录结构的命令，从而可在系统失败时能够恢复NTFS卷。</p> 
<p></p> 
<p>第4个记录是卷文件（$Volume）的记录，它包含卷名、NTFS的版本和一个标明该磁盘是否损坏的标志位，NTFS文件系统以此决定是否需要调用Chkdsk程序来进行修复。</p> 
<p></p> 
<p>第5个记录是属性定义表（$AttrDe，attribute definition table）的记录，其中存放着卷所支持的所有文件属性，并指出它们是否可以被索引和恢复等。</p> 
<p></p> 
<p>第6个记录是根目录（$ROOT）的记录，<strong>其中保存着该卷根目录下的所有文件和目录的索引。</strong>在访问一个文件后，NTFS就保留该文件的MFT引用，第二次就能够直接访问该文件。</p> 
<p></p> 
<p>第7个记录是位图文件（$Bitmap）的记录，NTFS卷的簇使用情况都保存在这个位图文件中，其中每一位（bit）代表卷中的一簇，标识该簇的空间还是已分配。由于该文件可以很容易被扩大，所以，NTFS的卷可以很方便地动态扩大，而FAT格式的文件系统由于涉及FAT表的变化，所以不能随意对分区大小进行调整。</p> 
<p></p> 
<p>第8个记录是引导文件（$Boot）的记录，<strong>该文件中存放着操作系统的引导程序代码。</strong>该文件必须位于特定的磁盘位置才能够正确地引导系统，一般都是位于卷的最前面。</p> 
<p></p> 
<p>第9个记录是坏簇文件（$BadClus）的记录，它记录着该卷中所有损坏的簇号，防止系统对其进行分配使用。</p> 
<p></p> 
<p>第10个记录是安全文件（$Secure）的记录，它存储着整个卷的安全描述符数据库。NTFS文件和目录都有各自的安全描述符，为节省空间，NTFS将文件和目录的相同描述符存放在此公共文件中。</p> 
<p></p> 
<p>第11个记录为大写文件（$UpCase，upper case file）的记录，该文件包含一个大小写字符转换表。</p> 
<p></p> 
<p>第12~15记录解释见上表，</p> 
<p></p> 
<p>MFT文件在创建时非常小（大约16KB），其大小是随着磁盘文件的增加而增加。<strong>MFT文件默认占用该分区12％（1/8）的空间（MFT区域）</strong>。当用户文件空间不足时，系统会把MFT空间分配给用户文件。当有剩余空间时，这些空间又会被重新划分给MFT。</p> 
<p></p> 
<p>MFT的每一编号对应一个MFT的文件记录（File Record，FR），又称文件记录段 (FRS)。<strong>一个MFT文件记录的大小一般为1KB（两扇区）</strong>。每一个或多个文件记录对应本分区一个文件。第一个MFT文件记录就是MFT本身。</p> 
<p></p> 
<p>文件记录由记录头和属性列表组成（见下图）：</p> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td rowspan="7"></td><td colspan="3"> <p>文件记录头</p> </td></tr><tr><td rowspan="6"> <p>文件属性列表</p> </td><td rowspan="2"> <p>属性1</p> </td><td> <p>属性头</p> </td></tr><tr><td> <p>属性体</p> </td></tr><tr><td rowspan="2"> <p>属性2</p> </td><td> <p>属性头</p> </td></tr><tr><td> <p>属性体</p> </td></tr><tr><td rowspan="2"> <p>属性3</p> </td><td> <p>属性头</p> </td></tr><tr><td> <p>属性体</p> </td></tr><tr><td style="vertical-align:top;"></td><td colspan="3" style="vertical-align:top;"> <p>结束标志FF FF FF FF</p> </td></tr></tbody></table> 
<p></p> 
<p>MFT文件记录头：为前部为一个包含几十个字节的具有固定的大小和结构的部分，是每一个MFT记录都有的。<strong>起始字节是46 49 4C 45，相应的ASCII码是FILE。</strong></p> 
<p></p> 
<p>属性列表（list）：为MFT记录的主体，长度可变，起始偏移为0x30（相对于记录首字节的偏移），用于存放文件各种属性（大小、位置、时间等）。常见的是标准属性（0x10）、文件名属性（0x30）、数据流属性（0x80）和位图属性（0xB0）等，一个文件记录至少包含0x10和0x30属性。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4c/b3/LuH6L6fh_o.jpg"></p> 
<p>而<strong>每一属性又都有属性头(header)和属性体（body）的结构</strong>。MFT的结束标志为FF FF FF FF（严格说是上面属性的结束，下一个属性开始）。</p> 
<p></p> 
<p>       </p> 
<p>$MFT文件首扇(0x0~0x1FF)，即MFT自身的记录，属性有0x10 0x30 0x80 0xB0,</p> 
<p>以小编电脑的硬盘为例如下：MFT记录表就长下面的这个样子.</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/da/86/2N9BHuRr_o.jpg"></p> 
<p>MFT记录对照表如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/65/87/egMNl7zD_o.jpg"></p> 
<p></p> 
<p></p> 
<p>◇属性分常驻属性和非常驻属性：</p> 
<p>(1)小文件和目录将全部（内容或索引信息）存储在MFT基本的文件记录里，其属性就称为<strong>常驻属性</strong>（residentattribute）。标准信息、文件名和索引根等属性总是常驻属性。NTFS对常驻属性的访问时间短。</p> 
<p>(2)大文件（目录）如果属性值超过1KB时，在基本的文件记录中就用一个指针指向MFT基本文件记录之外的一个外部簇，以此形成B-Tree（B＋树）结构。值存储在运行中而不是在MFT文件记录中的属性称为<strong>非常驻属性</strong>（nonresidentattribute）。<br>  </p> 
<p>属性头（Header）对照表：</p> 
<p></p> 
<p>常驻属性的属性头分析表:</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c9/cc/0M7MUH3w_o.jpg"></p> 
<p>非常驻属性的属性头分析表：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/d3/Av8mpBlC_o.jpg"></p> 
<p>0xC-0xD flags:</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/26/0f/q7CKY051_o.png"></p> 
<p>属性体（Body）对照表：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/37/35/RdClEPtv_o.jpg"></p> 
<p></p> 
<p>Data Run:</p> 
<p>非常驻属性（nonresidentattribute）的文件（目录）属性值超过1KB，在基本的文件记录中就用一个指针指向MFT基本文件记录之外的一个外部簇，<strong>这些外部簇通常称为一个运行（run或Data Run）或一个盘区（extent），它们可用来存储属性（如索引项）或属性值（如文件数据）</strong>。</p> 
<p></p> 
<p>Data run的格式如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/db/65/wsdk8NvG_o.jpg"></p> 
<p></p> 
<h3>我们再举几个Data run解析的例子：</h3> 
<h3>Data Run Example 1 - Normal, Unfragmented File（正常没有分割的数据）</h3> 
<h4>Data runs:</h4> 
<ul><li> <p>21 18 34 56 00</p> </li><li> <p>21 18 34 56 - 00 (regrouped)</p> </li></ul> 
<h4>Run 1:</h4> 
<ul><li> <p>Header = 0x21 - 1 byte length, 2 byte offset</p> </li><li> <p>Length = 0x18 (1 byte)</p> </li><li> <p>Offset = 0x5634 (2 bytes)</p> </li></ul> 
<h4>Run 2:</h4> 
<ul><li> <p>Header = 0x00 - the end</p> </li></ul> 
<h4>Summary:</h4> 
<ul><li> <p>0x18 Clusters @ LCN 0x5634</p> </li></ul> 
<p>所以, Data1是一个没有分割的数据，大小是0x18个簇，逻辑簇号(LCN)是0x5634,</p> 
<hr> 
<h3></h3> 
<h3>Data Run Example 2 - Normal, Fragmented File(分割的数据)</h3> 
<h4>Data runs:</h4> 
<ul><li> <p>31 38 73 25 34 32 14 01 E5 11 02 31 42 AA 00 03 00</p> </li><li> <p>31 38 73 25 34 - 32 14 01 E5 11 02 - 31 42 AA 00 03 - 00 (regrouped)</p> </li></ul> 
<h4>Run 1:</h4> 
<ul><li> <p>Header = 0x31 - 1 byte length, 3 byte offset</p> </li><li> <p>Length = 0x38</p> </li><li> <p>Offset = 0x342573</p> </li></ul> 
<h4>Run 2:</h4> 
<ul><li> <p>Header = 0x32 - 2 byte length, 3 byte offset</p> </li><li> <p>Length = 0x114</p> </li><li> <p>Offset = 0x363758 (0x211E5 + Run1 0x342573)</p> </li></ul> 
<h4>Run 3:</h4> 
<ul><li> <p>Header = 0x31 - 1 byte length, 3 byte offset</p> </li><li> <p>Length = 0x42</p> </li><li> <p>Offset = 0x393802 (0x300AA + Run2 0x363758)</p> </li></ul> 
<h4>Run 4:</h4> 
<ul><li> <p>Header = 0x00 - the end</p> </li></ul> 
<h4>Summary:</h4> 
<ul><li> <p>0x38 Clusters @ LCN 0x342573</p> </li><li> <p>0x114 Clusters @ LCN 0x363758</p> </li><li> <p>0x42 Clusters @ LCN 0x393802</p> </li></ul> 
<p>所以，Data2是一个分割的数据，大小为0x38+ 0x114+ 0x42 = 0x18E簇，逻辑簇号(LCN)是 0x342573, 0x363758，0x393802.</p> 
<hr> 
<h3></h3> 
<h3>Data Run Example 3 - Normal, Scrambled File(加密文件)</h3> 
<h4>Data runs:</h4> 
<ul><li> <p>11 30 60 21 10 00 01 11 20 E0 00</p> </li><li> <p>11 30 60 - 21 10 00 01 - 11 20 E0 - 00 (regrouped)</p> </li></ul> 
<h4>Run 1:</h4> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x30</p> </li><li> <p>Offset = 0x60</p> </li></ul> 
<h4>Run 2:</h4> 
<ul><li> <p>Header = 0x21 - 1 byte length, 2 byte offset</p> </li><li> <p>Length = 0x10</p> </li><li> <p>Offset = 0x160 (0x100 + Run1 0x60)</p> </li></ul> 
<h4>Run 3:</h4> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x20</p> </li><li> <p>Offset = 0x140 (0xE0= -0x20, + Run2 0x160)</p> </li></ul> 
<h4>Run 4:</h4> 
<ul><li> <p>Header = 0x00 - the end</p> </li></ul> 
<h4>Summary:</h4> 
<ul><li> <p>0x30 Clusters @ LCN 0x60</p> </li><li> <p>0x10 Clusters @ LCN 0x160</p> </li><li> <p>0x20 Clusters @ LCN 0x140</p> </li></ul> 
<p>所以，Data3是一个分割的数据，大小为0x30+ 0x10+ 0x20 = 0x80簇，逻辑簇号(LCN)是 0x60, 0x160，0x140. 其中第三个Data Run具有一个负的offset, 将Data Run3要放在Data Run2之前.</p> 
<hr> 
<h3></h3> 
<h3>此外，Data run layout必须考虑数据压缩, 如果一个file的VCN是一个compressed fileattribute, 那么将VCN以16 cluster为压缩单元组成一个group, VCN0 ~VCN15组成第一个压缩单元, VCN16~VCN31组成第二个, 以此类推, 对于每一个压缩单元,</h3> 
<h3>(1) <strong>如果一个压缩单元全是0, 那么称之为Sparse unit</strong>, 将不占物理存储单元, 只是有一个no offset的field(F=0)和一个长度为16放入runlist当中,</h3> 
<h3>(2) 如果并非全部压缩单元都是0, 那么假设N个不是全0, 剩下的16-N是全0单元, 那么只有N物理存储, 剩下的16-N将会是一个no offset的field(F=0),</h3> 
<h3>(3) 如果unit不是compressed, 那么16个cluster都将都占物理存储, 一个长度为16的单元将放入runlist,</h3> 
<p></p> 
<h3>Data Run Example 4 - Sparse, Unfragmented File</h3> 
<h4>Data runs:</h4> 
<ul><li> <p>11 30 20 01 60 11 10 50 00</p> </li><li> <p>11 30 20 - 01 60 - 11 10 30 - 00 (regrouped)</p> </li></ul> 
<h4>Run 1:</h4> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x30</p> </li><li> <p>Offset = 0x20</p> </li></ul> 
<h4>Run 2:</h4> 
<ul><li> <p>Header = 0x01 - 1 byte length, 0 byte offset (sparse)</p> </li><li> <p>Length = 0x60</p> </li><li> <p>Offset = N/A</p> </li></ul> 
<h4>Run 3:</h4> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x10</p> </li><li> <p>Offset = 0x30</p> </li></ul> 
<h4>Run 4:</h4> 
<ul><li> <p>Header = 0x00 - the end</p> </li></ul> 
<h4>Summary:</h4> 
<ul><li> <p>0x30 Clusters @ LCN 0x20</p> </li><li> <p>0x60 Clusters (sparse)</p> </li><li> <p>0x10 Clusters @ LCN 0x50</p> </li></ul> 
<p>所以，Data4是一个压缩单元全是0的Sparse文件，大小为0xA0簇, 逻辑簇号为0x20, 0x50.</p> 
<hr> 
<h3></h3> 
<h3>Data Run Example 5 - Compressed, Unfragmented File（压缩文件）</h3> 
<h4>Data runs:</h4> 
<ul><li> <p>11 08 40 01 08 11 10 08 11 0C 10 01 04 00</p> </li><li> <p>11 08 40 - 01 08 - 11 10 08 - 11 0C 10 - 01 04 - 00 (regrouped)</p> </li></ul> 
<h4>Run 1:</h4> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x08</p> </li><li> <p>Offset = 0x40</p> </li></ul> 
<h4>Run 2:</h4> 
<ul><li> <p>Header = 0x01 - 1 byte length, 0 byte offset (sparse)</p> </li><li> <p>Length = 0x08</p> </li><li> <p>Offset = N/A</p> </li></ul> 
<h4>Run 3:</h4> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x10</p> </li><li> <p>Offset = 0x48 (0x8 + 0x40)</p> </li></ul> 
<h4>Run 4:</h4> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x0C</p> </li><li> <p>Offset = 0x58 (0x10 + 0x48)</p> </li></ul> 
<h4>Run 5:</h4> 
<ul><li> <p>Header = 0x01 - 1 byte length, 0 byte offset (sparse)</p> </li><li> <p>Length = 0x04</p> </li><li> <p>Offset = N/A</p> </li></ul> 
<h4>Run 6:</h4> 
<ul><li> <p>Header = 0x00 - the end</p> </li></ul> 
<h4>Summary:</h4> 
<ul><li> <p>0x08 Clusters @ LCN 0x40</p> </li><li> <p>0x08 Clusters (sparse)</p> </li><li> <p>0x10 Clusters @ LCN 0x48</p> </li><li> <p>0x0C Clusters @ LCN 0x58</p> </li><li> <p>0x04 Clusters (sparse)</p> </li></ul> 
<p>所以，Data5是一个压缩不连续的文件，文件大小为0x30簇, 逻辑簇号 0x40, 0x48，0x58.</p> 
<p></p> 
<p>三、NTFS文件系统引导原理</p> 
<p>说，电脑启动分几步：</p> 
<p>(1) 按下计算机power键以后，开始执行主板bios程序。</p> 
<p>(2) 进行完一系列检测和配置以后, 开始按bios中设定的系统引导顺序引导系统。</p> 
<p>(3)假定现在是硬盘,Bios执行完自己的程序后把执行权交给硬盘。</p> 
<p>(4) 交给硬盘后执行存储硬盘上的系统程序。</p> 
<p><br> NTFS文件系统的引导扇区是$Boot的第一个扇区，它的结构与FAT文件系统的DBR类似，所以习惯上也称该扇区为DBR扇区。</p> 
<p></p> 
<p>因为文件以引导扇区开始，所以它必须在0物理簇起始（这是NTFS唯一不能移动的簇）。<strong>这样就迫使文件的数据属性是非常驻的</strong>。从而引导扇区的拷贝可以定位于卷上的任何位置。</p> 
<p></p> 
<p>$Boot元文件由分区的第一个扇区（DBR）和后面的15个扇区（NTLDR区域）组成，其中DBR由“跳转指令”、“OEM代号”、“BPB（BIOS参数记录块，记录了分区尺寸、$MFT文件位置等）”、“引导程序”和“结束标志”组成，这里和FAT32文件系统的DBR一样。下图是一个NTFS文件系统完整的DBR。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/68/17/K8jf4HN5_o.jpg"></p> 
<p></p> 
<p>$Boot文件首扇结构（NTFS分区启动扇区。注意：<strong>它虽以55AA结束，但它不是分区表</strong>）：</p> 
<table cellspacing="0"><tbody><tr><th>Offset</th><th>大小</th><th>描述</th></tr><tr><td>0x0000</td><td>3</td><td>跳到引导载入器程序</td></tr><tr><td>0x0003</td><td>8</td><td>系统标识符："NTFS    "</td></tr><tr><td>0x000B</td><td>2</td><td>每个扇区的字节数</td></tr><tr><td>0x000D</td><td>1</td><td><strong>每个簇的扇区数</strong></td></tr><tr><td>0x000E</td><td>7</td><td>未用</td></tr><tr><td>0x0015</td><td>1</td><td>媒体描述符（a）</td></tr><tr><td>0x0016</td><td>2</td><td>未用</td></tr><tr><td>0x0018</td><td>2</td><td>每个磁道的扇区数</td></tr><tr><td>0x001A</td><td>2</td><td>磁头数</td></tr><tr><td>0x001C</td><td>8</td><td>未用</td></tr><tr><td>0x0024</td><td>4</td><td>一般是 80 00 80 00 (b)</td></tr><tr><td>0x0028</td><td>8</td><td>卷的扇区数</td></tr><tr><td>0x0030</td><td>8</td><td>LCN of VCN 0 of the $MFT</td></tr><tr><td>0x0038</td><td>8</td><td>LCN of VCN 0 of the $MFTMirr</td></tr><tr><td>0x0040</td><td>4</td><td>每个MFT记录的簇（c）</td></tr><tr><td>0x0044</td><td>4</td><td>每个索引记录的簇（c）</td></tr><tr><td>0x0048</td><td>8</td><td>卷的系列号</td></tr><tr><td>~</td><td>~</td><td>~</td></tr><tr><td>0x0200</td><td></td><td>Windows NT 载入器</td></tr></tbody></table> 
<p>针对小编手里的硬盘，Winhex解析如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/cf/EJHDMIz5_o.jpg"></p> 
<p>如何定位$MFT文件？</p> 
<p>根据上表可知，$MFT文件第一簇簇号，在$boot首扇偏移0x30处标明（占用8个字节）。</p> 
<p></p> 
<p>以上面硬盘DBR扇区图为例，它的第1簇簇号为00 00 0C 00 00 00 00 00，其十六进制数表示为<strong>0xC0000H（十六进制数为“低位在前，高位在后”），即第786432簇。</strong>NTFS分区的簇大小一般为4K，<em><strong>簇因子（是每簇所包含扇区的数目）为8</strong></em>。<strong>786432簇×8＝6291456扇</strong>， $MFT文件首个记录位于本分区第6291456扇区。</p> 
<p></p> 
<p>利用Winhex的跳转功能Go to Sector, 跳转到<strong>6291456扇</strong>, 我们就看到了$MFT文件的首个记录。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d2/7d/T0rgG0g6_o.jpg"></p> 
<p></p> 
<p>四、NTFS数据恢复</p> 
<p>◇删除的恢复：</p> 
<p>当在NTFS卷中删除一个文件时，系统至少在三个地方做了改变：</p> 
<p>(1)该文件的MFT记录被删除或被改动。</p> 
<p>(2)其父文件夹的90H属性或者A0H属性；</p> 
<p>(3)在位图（$Bitmap）文件中把该文件所占用的簇对应的位置置0，这样好给其他文件腾出空间。</p> 
<p></p> 
<p>我们从删除原理着手，分几步将数据进行恢复：</p> 
<p>第一步：首先要找到MFT。MFT的第一个文件记录称为基本文件记录（大文件还可能有多个记录），当中存储有其他扩展文件记录的一些信息。</p> 
<p>第二步：通过文件记录的INDEX_ROOT索引根、INDEX_ALLOCATION索引分配以及位图Bitmap对被删文件加以确认和定位。找到该文件在数据区中的存储位置。 　　</p> 
<p>第三步：恢复该文件。进行数据恢复时，我们仅仅是将其相关信息复制到了内存，并将相关信息做了修改。为了修复数据而做的修改，其实并没有写回到原文件属性上。这就有效的避免了被访文件的再次破坏。</p> 
<p></p> 
<p>◇DBR（OBR）或EBR的备份和恢复：</p> 
<p>NTFS在其分区最后的扇区上，备份了DBR（OBR）或EBR。</p> 
<p>只需将备份扇区的内容复制到分区引导扇区DBR（OBR）或EBR位置，就可使该分区恢复正常。注意：若DBR扇区损坏，可将DBR改在其它柱面。</p> 
<p>分区表的分区大小包括此扇，而DBR描述的分区大小不包括此扇。DBR描述文件系统大小时，总是比分区表描述的扇区数小1个扇区。</p> 
<p><br> 五、实例：分析NTFS文件系统得到特定文件的内容</p> 
<p>找某一个文件的内容，如要读取文件J:\dir\dir2\NTFStest.txt，具体步骤如下：<br> （1）读取分区表/分区链表信息，找到磁盘J的起始扇区。<br> （2）读取J盘的第一个扇区（分区的BOOTSETOR）取得分区的每簇大小，MFT表起始簇号等信息。<br> （3）读取MFT表的第五个记录（根目录）找到目录索引所在簇号。<br> （4）读取根目录索引，查找dir目录所在的MFT记录号<br> （5）读取dir目录的MFT记录，找到目录索引所在簇号。<br> （6）读取dir目录的索引，查找dir2目录所在MFT记录号<br> （7）读取dir2目录的MFT记录，找到目录索引所在簇号。<br> （8）读取dir2目录的索引，查找NTFStest.txt 所在MFT记录号<br> （9）读取NTFStest.txt文件的MFT记录，找到它的DATA属性。<br> （10）根据DATA属性中指定的文件数据存放位置读取出NTFStest.txt文件的数据。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fc/52/AyNtexR4_o.jpg"></p> 
<p></p> 
<p>下面我们具体执行一下：</p> 
<p>（1）读取分区表/分区链表信息，找到磁盘J的起始扇区。</p> 
<p>因为小编用J盘是一个独立的硬盘，所以J盘的起始扇区为0.</p> 
<p></p> 
<p>（2）读取J盘的第一个扇区（分区的BOOTSETOR）取得分区的每簇大小，MFT表起始簇号等信息。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/85/fc/FaNpdQ5o_o.jpg"></p> 
<p><strong>绿色部分</strong>offset 0xD=0x8, 簇因子（是每簇所包含扇区的数目）为8;</p> 
<p><strong>蓝色部分</strong>offset 0x30~0x37= 00 00 0C 00 00 00 00 00 = 0xC0000H = 786432，$MFT文件记录起始簇号为第786432簇。</p> 
<p></p> 
<p>（3）读取MFT表的序号为5的记录（根目录）找到目录索引所在簇号。</p> 
<p>由第二步的簇因子以及$MFT记录起始簇号得到，</p> 
<p>$MFT文件首个记录位于786432簇×8＝6291456扇。</p> 
<p></p> 
<p>利用Winhex的跳转功能Go to Sector, 跳转到<strong>6291456扇</strong>, 我们就看到了$MFT文件的首个记录。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ba/cb/q3N9osnM_o.jpg"></p> 
<p></p> 
<p></p> 
<p>（4）读取根目录索引，查找dir目录所在的MFT记录号</p> 
<p>MFT 是由一条条 MFT 项(记录)所组成的，而且每项大小是固定的(一般为1KB=0x400)，MFT保留了前16项用于特殊文件记录，称为元数据，</p> 
<p>元数据在磁盘上是物理连续的，编号为0~15；<br>  </p> 
<p>我们从上图可以看到$MFT文件的首个记录偏移为0x0C0000000, 那么：</p> 
<p>根目录记录(序号5)偏移= 0x0C0000000 + 5*0x400 = 0x0C0001400,</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fb/41/PbCctzkR_o.jpg"></p> 
<p>IndexAlloc_header对照表如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/0f/mGlUmp10_o.jpg"></p> 
<p>offset 0x8=0x01, 代表$MFT记录为非常驻属性，</p> 
<p>offset 0x9=0x04，Name长度为4，</p> 
<p>offset 0x20=0x48, 代表data runs距离属性ID A0的距离为0x48,</p> 
<p>所以，data runs所在位置是0x0C00015C8+0x48= 0x0C0001610,</p> 
<p>即，data runs= 11 01 2C</p> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x01</p> </li><li> <p>Offset = 0x2C</p> </li></ul> 
<p>所以，偏移簇数0x2C，长度是0x1簇,</p> 
<p></p> 
<p>跳转到偏移簇数0x2C会看到根目录下的索引项，其中可看到$AttrDef,$BadClus,$Bitmap,$Boot等系统文件的索引项。</p> 
<p></p> 
<p>找到dir的索引项，如下图，粉色部分是本索引项的名称dir。前8字节是文件的MFT索引记录号（只用到前4个字节，0x23）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/83/f3/nhLfMJt9_o.jpg"></p> 
<table cellspacing="0"><tbody><tr><th>Offset</th><th>Size</th><th>Description</th></tr><tr><td>~</td><td>~</td><td>Standard Index Header</td></tr><tr><td>0x00</td><td>8</td><td>MFT Reference of the file</td></tr><tr><td>0x08</td><td>2</td><td>Size of this index entry</td></tr><tr><td>0x0A</td><td>2</td><td>Offset to the filename</td></tr><tr><td>0x0C</td><td>2</td><td>Index Flags</td></tr><tr><td>0x0E</td><td>2</td><td>Padding (align to 8 bytes)</td></tr><tr><td>0x10</td><td>8</td><td>MFT File Reference of the parent</td></tr><tr><td>0x18</td><td>8</td><td>File creation time</td></tr><tr><td>0x20</td><td>8</td><td>Last modification time</td></tr><tr><td>0x28</td><td>8</td><td>Last modification time for FILE record</td></tr><tr><td>0x30</td><td>8</td><td>Last access time</td></tr><tr><td>0x38</td><td>8</td><td>Allocated size of file</td></tr><tr><td>0x40</td><td>8</td><td>Real size of file</td></tr><tr><td>0x48</td><td>8</td><td>File Flags</td></tr><tr><td>0x50</td><td>1</td><td>Length of filename (F)</td></tr><tr><td>0x51</td><td>1</td><td>Filename namespace</td></tr><tr><td>0x52</td><td>2F</td><td>Filename</td></tr><tr><td>2F+0x52</td><td>P</td><td>Padding (align to 8 bytes)</td></tr><tr><td>P+2F+0x52</td><td>8</td><td>VCN of index buffer with sub-node</td></tr></tbody></table> 
<p></p> 
<p>（5）读取dir目录的MFT记录，找到目录索引所在簇号。</p> 
<p>由上面的图可以得到dir MFT记录号为0x23=35,</p> 
<p>之前我们有得到$MFT文件的首个记录偏移为0x0C0000000, 那么：</p> 
<p>dir MFT记录(序号35)偏移= 0x0C0000000 + 35*0x400 = 0x0C0008C00,</p> 
<p></p> 
<p>（6）读取dir目录的索引，查找dir2目录所在MFT记录号</p> 
<p>我们跳转到offset 0x0C0008C00，</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0f/1d/JIuczEtp_o.jpg"></p> 
<p>offset 0xC008D00=0x0, 说明为常驻属性,</p> 
<p>从粉色框中得到dir2的MFT记录项的记录号是0x24=36,</p> 
<p></p> 
<p>（7）读取dir2目录的MFT记录，找到目录索引所在簇号。</p> 
<p>第(5)步有得到dir MFT记录(序号35)偏移= 0x0C0000000 + 35*0x400 = 0x0C0008C00, 那么，</p> 
<p>dir2 MFT记录(序号36)偏移= 0x0C0008C00 + 0x400 = 0x0C0009000,</p> 
<p></p> 
<p></p> 
<p>（8）读取dir2目录的索引，查找NTFStest.txt 所在MFT记录号</p> 
<p>我们跳转到offset 0x0C0009000，</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0d/05/1ctiiH4v_o.jpg"></p> 
<p>offset 0xC009108=0x0, 说明为常驻属性,</p> 
<p>从粉色框中得到dir2的MFT记录项的记录号是0x26=38,</p> 
<p></p> 
<p>（9）读取NTFStest.txt文件的MFT记录，找到它的DATA属性。</p> 
<p>第(7)步有得到dir2 MFT记录(序号36)偏移= 0x0C0008C00 + 0x400 = 0x0C0009000, 那么，</p> 
<p>NTFSTest.txt MFT记录(序号38)偏移= 0x0C0009000 + (38-36)*0x400 = 0x0C0009800,</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/75/p5yJH78t_o.jpg"></p> 
<p>offset 0xC0098A0=0x0, 说明为常驻属性,</p> 
<p>从0x30文件名属性可以看到NTFStest.txt的文件名, 0x80数据属性中可以得到文件内容.</p> 
<p></p> 
<p>（10）根据DATA属性中指定的文件数据存放位置读取出NTFStest.txt文件的数据。</p> 
<p>从0X80数据属性中可以知道此属性是常驻属性，直接看到test.txt的文件内容，“This is a NTFS test file!”.</p> 
<p></p> 
<p>此时，前面的找文件的任务就大功告成啦~~~~</p> 
<p></p> 
<p>另外，我们延伸一下，如果我继续向NFTStest.txt 写入数据，DATA属性中的数据会增加，如下图粉色区域。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d6/e1/fi7tYAR0_o.jpg"></p> 
<p></p> 
<p>但是当文件内容继续增加超过1K时，0x80数据属性从常驻属性改为<strong>非常驻属性</strong>，文件内容不会直接存储在此属性中，而是其他簇中，根据Data run可以定位到。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/23/80/fgptKgNR_o.jpg"></p> 
<p>0x80数据属性；0x01说明是非常驻属性；</p> 
<p>Data runs = 11 01 25 00;</p> 
<p>Run1：</p> 
<ul><li> <p>Header = 0x11 - 1 byte length, 1 byte offset</p> </li><li> <p>Length = 0x01</p> </li><li> <p>Offset = 0x25</p> </li></ul> 
<p>Run 2:</p> 
<ul><li> <p>Header = 0x00 - the end</p> </li></ul> 
<p>所以，偏移簇数0x25，长度是0x1簇,</p> 
<p>打开簇号0x25，可以看到NTFStest.txt的文件内容：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/43/2b/eZxlEcIc_o.jpg"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a4a5c3c3486d7d6706fb63cfd69598a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【智能优化算法-白鲸算法】基于白鲸优化算法求解多目标优化问题附matlab代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe1e552789e4ce7838e8932e50d6a117/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux安装Gitlab15详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>