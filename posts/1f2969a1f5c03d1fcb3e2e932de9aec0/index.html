<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之开篇 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之开篇" />
<meta property="og:description" content="在软件开发的世界里，设计模式有如一本精妙的工程艺术指导准则，为我们提供了解决常见问题的优雅实现方案。然而，有些程序员可能会认为设计模式太过繁琐，一个简单的 if/else 语句就能解决问题，何必费心去学习这些看似复杂的概念呢？在这个系列的文章里，我和大家一起探讨为什么设计模式是值得的，以及如何在实际开发中去融入设计模式的思想。
一、为什么学设计模式 1、代码质量和可维护性 拥有设计模式的思维方式，意味着你不仅仅是在写能够工作的代码，更是在构建具有良好结构的、易于理解和维护的代码。设计模式是过去经验的总结，它们提供了在各种场景下验证过的最佳实践，有助于避免常见的陷阱和错误。
2、可扩展性和灵活性 需求总是在变化的，永远不可能存在一层不变的需求，而设计模式可以为你的代码提供更好的扩展性。通过采用开放封闭等设计原则，你的代码可以更容易地适应新的功能需求，而不需要对原有的代码进行大规模修改。
3、团队协作 设计模式是一种通用的编程语言，它提供了一种共享的术语和理解方式，有助于团队成员更容易理解和协作。当所有人都熟悉常见的设计模式时，交流就会变得更加高效，合作更加顺畅。
二、怎么样学设计模式 1、刻意实践 在日常编码中刻意使用设计模式是学习的最佳途径。不要觉得使用设计模式会让代码变得复杂和难以理解，相反，它会使你的代码更加清晰、模块化，易于维护。逐渐将设计模式的思想融入到自己的编程风格中，形成个性化的代码风格。
2、实战演练 学以致用是掌握设计模式的关键。在实际项目中应用设计模式，从而更好地理解其实际应用场景。实战中的经验往往比理论知识更加深刻和有说服力。
3、逐步演进 不要急于一时，逐步演进是掌握设计模式的关键。从一段已有的代码开始，尝试用设计模式和SOLID原则进行重构。通过对比前后的代码，你将会发现自己在设计和编写代码方面的进步。
4、重点理解设计原则 设计模式的基石是设计原则，例如开放封闭原则、单一职责原则等。深入理解这些原则，能够更好地指导你在实际项目中的设计和编码过程。设计原则是设计模式的根基，也是培养良好代码习惯的关键。
三、设计原则的补充说明 一般的书籍和文章讲到设计原则，都讲的是 SOLID 原则，而我这里要说的是七原则：SOLID &#43; CARP &#43; LoD
1 、SRP（Single responsibility Principle）单一职责原则 SRP 是一项简单易懂且重要的原则，但是在实际过程中往往最容易忽略的，它强调在应用中，一个类应该只有一个引起变化的原因，只有一个职责。
SRP 是基于康威定律的推导结论：软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构，每个软件模块都有且只有一个需要被改变的理由。
优点 降低类之间的耦合：将不同职责分解为不同的类，降低类之间的依赖关系，提高系统的灵活性和可维护性提升类的可维护性和可重用性：当一个类只有一个职责时，修改该职责不会影响到其他职责，使得类更加稳定，易于维护和重用简化设计过程：SRP 原则使得类的设计更加清晰，每个类都专注于解决一个问题，降低了设计的复杂性 示例代码 多职责的类设计
public class UserService { /*** 运营部员工绩效计算 */ public BigDecimal calculateKPIResultForOperation() { } /*** 商务员工绩效计算 */ public BigDecimal calculateKPIResultForBusiness() { } /*** 产品部员工绩效计算 */ public BigDecimal calculateKPIResultForProduct() { } /*** 技术部员工绩效计算 */ public BigDecimal calculateKPIResultForTechnology() { } } SRP 后的类设计" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/1f2969a1f5c03d1fcb3e2e932de9aec0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T14:54:28+08:00" />
<meta property="article:modified_time" content="2023-12-13T14:54:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之开篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"></p> 
<p class="img-center"><img alt="" height="512" id="u528aa52a" src="https://images2.imgbox.com/77/4d/C53t8TaI_o.jpg" width="1200"></p> 
<p id="uc3b37d2c">在软件开发的世界里，设计模式有如一本精妙的工程艺术指导准则，为我们提供了解决常见问题的优雅实现方案。然而，有些程序员可能会认为设计模式太过繁琐，一个简单的 if/else 语句就能解决问题，何必费心去学习这些看似复杂的概念呢？在这个系列的文章里，我和大家一起探讨为什么设计模式是值得的，以及如何在实际开发中去融入设计模式的思想。</p> 
<h2 id="c0ITU">一、为什么学设计模式</h2> 
<h3 id="pWQd3">1、代码质量和可维护性</h3> 
<p id="ua8269a4f">拥有设计模式的思维方式，意味着你不仅仅是在写能够工作的代码，更是在构建具有良好结构的、易于理解和维护的代码。设计模式是过去经验的总结，它们提供了在各种场景下验证过的最佳实践，有助于避免常见的陷阱和错误。</p> 
<h3 id="yovVc">2、可扩展性和灵活性</h3> 
<p id="uea3bbc85">需求总是在变化的，永远不可能存在一层不变的需求，而设计模式可以为你的代码提供更好的扩展性。通过采用开放封闭等设计原则，你的代码可以更容易地适应新的功能需求，而不需要对原有的代码进行大规模修改。</p> 
<h3 id="atSze">3、团队协作</h3> 
<p id="u324b1018">设计模式是一种通用的编程语言，它提供了一种共享的术语和理解方式，有助于团队成员更容易理解和协作。当所有人都熟悉常见的设计模式时，交流就会变得更加高效，合作更加顺畅。</p> 
<h2 id="zCvVZ">二、怎么样学设计模式</h2> 
<h3 id="Lr4Wf">1、刻意实践</h3> 
<p id="u6234c616">在日常编码中刻意使用设计模式是学习的最佳途径。不要觉得使用设计模式会让代码变得复杂和难以理解，相反，它会使你的代码更加清晰、模块化，易于维护。逐渐将设计模式的思想融入到自己的编程风格中，形成个性化的代码风格。</p> 
<h3 id="DP5or">2、实战演练</h3> 
<p id="u30163670">学以致用是掌握设计模式的关键。在实际项目中应用设计模式，从而更好地理解其实际应用场景。实战中的经验往往比理论知识更加深刻和有说服力。</p> 
<h3 id="U2hGR">3、逐步演进</h3> 
<p id="u05cd94b1">不要急于一时，逐步演进是掌握设计模式的关键。从一段已有的代码开始，尝试用设计模式和SOLID原则进行重构。通过对比前后的代码，你将会发现自己在设计和编写代码方面的进步。</p> 
<h3 id="MBwmJ">4、重点理解设计原则</h3> 
<p id="u42c9c10d">设计模式的基石是设计原则，例如开放封闭原则、单一职责原则等。深入理解这些原则，能够更好地指导你在实际项目中的设计和编码过程。设计原则是设计模式的根基，也是培养良好代码习惯的关键。</p> 
<h2 id="KNBN6">三、设计原则的补充说明</h2> 
<p id="ud98671a0">一般的书籍和文章讲到设计原则，都讲的是 SOLID 原则，而我这里要说的是七原则：SOLID + CARP + LoD</p> 
<h4 id="fKHh4">1 、SRP（Single responsibility Principle）单一职责原则</h4> 
<p id="uc48581e1">SRP 是一项简单易懂且重要的原则，但是在实际过程中往往最容易忽略的，它强调在应用中，一个类应该只有一个引起变化的原因，只有一个职责。</p> 
<p id="u387ea088">SRP 是基于康威定律的推导结论：软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构，每个软件模块都有且只有一个需要被改变的理由。</p> 
<h6 id="T7xa8">优点</h6> 
<ul><li id="u55c73fd7">降低类之间的耦合：将不同职责分解为不同的类，降低类之间的依赖关系，提高系统的灵活性和可维护性</li><li id="u68c03123">提升类的可维护性和可重用性：当一个类只有一个职责时，修改该职责不会影响到其他职责，使得类更加稳定，易于维护和重用</li><li id="ub291f0e9">简化设计过程：SRP 原则使得类的设计更加清晰，每个类都专注于解决一个问题，降低了设计的复杂性</li></ul> 
<h6 id="pSgd8">示例代码</h6> 
<p id="uc51c7662">多职责的类设计</p> 
<pre id="q1VmM"><code>public class UserService {
    /*** 运营部员工绩效计算 */
    public BigDecimal calculateKPIResultForOperation() { }
    
    /*** 商务员工绩效计算 */
    public BigDecimal calculateKPIResultForBusiness() { }
    
    /*** 产品部员工绩效计算 */
    public BigDecimal calculateKPIResultForProduct() { }
    
    /*** 技术部员工绩效计算 */
    public BigDecimal calculateKPIResultForTechnology() { }
}</code></pre> 
<p id="u72e624ed">SRP 后的类设计</p> 
<pre id="iZxMJ"><code>public interface UserService {
    public BigDecimal calculateKPIResult();
}

// 不同部门实现接口
public class OperationUserService implement UserService {}
public class BusinessUserService implement UserService {}
public class ProductUserService implement UserService {}
public class TechnologyUserService implement UserService {}
</code></pre> 
<h6 id="SZtT1">注意点</h6> 
<ul><li id="u230ec14f">拆分多职责类：如果一个类承担了多个职责，就一定要拆分为多个类，确保每个类只有一个职责</li><li id="ua8e2bfb2">识别变化原因：识别引起类变化的原因，然后职责分配到对应的类，确保每个类的变化原因是明确的</li><li id="u4ac56dee">避免过度设计：尽可能简单，避免过度设计和复杂性，SRP 的目标是简化设计，而不是增加不必要的结构</li></ul> 
<h4 id="Hdbje">2 、OCP（Open/Close Principle） 开闭原则</h4> 
<p id="u9e1666b4">OCP 的核心思想是通过扩展已有的代码，增加新的行为和功能，而不是修改已有的代码。</p> 
<h6 id="q95av">优点</h6> 
<ul><li id="ufd66d33d">提高代码的可维护性和可重用性：允许系统通过扩展已有的代码来应对新的需求，而不是修改已有的代码，降低引入错误的风险</li><li id="uf7ad4fd8">减少代码的耦合度：模块化的设计使得系统个部分之间的耦合度降低，一个模块的修改不会对其他模块产生影响</li><li id="u443a146e">提高系统的可扩展性和可升级性：新功能可以通过添加新的类或模块来实现，而不是修改已有的代码，使得系统更容易扩展和升级</li></ul> 
<h6 id="XC0Tm">示例代码</h6> 
<p id="ud20e06bd">无 OCP 的代码</p> 
<pre id="g5Ihp"><code>public class Calculator {  
    public int add(int a, int b) {  
        return a + b;  
    }  
      
    public int subtract(int a, int b) {  
        return a - b;  
    }  
      
    public int multiply(int a, int b) {  
        return a * b;  
    }  
      
    public int divide(int a, int b) {  
        return a / b;  
    }  
}
</code></pre> 
<p id="ucf57a344">有 OCP 的代码</p> 
<pre id="ROkUF"><code>public interface Operation {  
    int calculate(int a, int b);  
}  
  
public class AddOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a + b;  
    }  
}  
  
public class SubtractOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a - b;  
    }  
}  
  
public class MultiplyOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a * b;  
    }  
}  
  
public class DivideOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a / b;  
    }  
}</code></pre> 
<h6 id="XR6wi">注意点</h6> 
<ul><li id="u810b1dbc">使用 OCP 原则：把实体设计成可扩展，通过新加类、模块或者函数来扩展功能和行为</li><li id="u430ded1e">抽象化已有代码：对已有代码进行抽象，将具体的实现细节封装，对外仅提供抽象的接口</li><li id="ua55da567">避免过度设计：OCP 原则的目标是简化设计而不是增加不必要的结构</li></ul> 
<h4 id="G0qcE">3 、LSP（Liskov Substitution Principle）里氏替换原则</h4> 
<p id="u6ed43b62">LSP 强调在软件中，子类必须能够替换其父类，即子类应该具有与父类相同的行为和功能，而不仅仅是继承父类的属性和方法。</p> 
<h6 id="sCzd5">优点</h6> 
<ul><li id="u3dda862a">提高代码的可读性和可维护性：子类与父类具有一致的行为和功能，使得代码更易于理解和维护</li><li id="u47751475">减少代码的冗余和复杂性：子类继承父类的方法和属性，可以避免重复编写相似的代码</li><li id="u69161fe7">提高系统的可扩展性和可升级性：新的子类可以无缝地替换父类，不会影响系统的其他部分</li></ul> 
<h6 id="PC3Cx">示例代码</h6> 
<p id="u0e1b20ce">无 LSP 代码</p> 
<pre id="icb5W"><code>class Shape {  
    void draw() {  
        System.out.println("Drawing a shape");  
    }  
}  
  
class Circle extends Shape {  
    void draw() {  
        System.out.println("Drawing a circle");  
    }  
}</code></pre> 
<p id="u93a61266">有 LSP 代码</p> 
<pre id="AyEgq"><code>interface Drawable {  
    void draw();  
}  
   
class Shape implements Drawable {  
    public void draw() {  
        System.out.println( "Drawing a shape");  
    }  
}  
  
class Circle extends Shape {  
    public void draw() {  
        System.out.println("Drawing a circle");  
    }  
} </code></pre> 
<h6 id="PLMWK">注意点</h6> 
<ul><li id="uc89909c1">子类具有一致的行为和功能：子类必须具有与父类相同的行为和功能，但不能改变父类的行为和功能</li><li id="ue6aed12e">抽象类定义抽象方法：抽象类应该定义抽象方法，具体方法在子类中实现</li><li id="uea633106">避免继承滥用：避免使用继承来共享行为，继承是用来实现多态行为的，而不是为了代码的重用。如果子类需要不同的功能和行为，那应该通过重写父类方法来实现</li></ul> 
<h4 id="t5fIb">4 、ISP（Interface Segregation Principle）接口隔离原则</h4> 
<p id="u71ee93a3">ISP 强调在应用中使用多个特定的接口，而不是一个单一的总接口，从而避免端侧就不需要被强制依赖他们不需要的接口。</p> 
<h6 id="INeCt">优点</h6> 
<ul><li id="u6ad07d5d">提高代码的可维护性和可重用性，特定接口提供特定服务，代码可以更加模块化和可定制化</li><li id="uf62770ef">减少端侧的复杂性，端侧只需要依赖实际使用的接口，避免对不相关接口的强制依赖</li><li id="u06d1b1ca">提高系统的可扩展性和可升级性，新的接口可以被添加而不会影响实际使用的接口，使得系统更容易扩展和升级</li></ul> 
<h6 id="FNLxS">示例代码</h6> 
<p id="udc6aad37">无 ISP 代码</p> 
<pre id="C8S6l"><code>interface ShoppingCart {  
    void addItem(Product product, int quantity);  
    void removeItem(Product product);  
    void updateQuantity(Product product, int quantity);  
}  
  
class ShoppingCartImpl implements ShoppingCart {  
    private Map&lt;Product, Integer&gt; items = new HashMap&lt;&gt;();  
      
    @Override  
    public void addItem(Product product, int quantity) {  
        items.put(product, quantity);  
    }  
      
    @Override  
    public void removeItem(Product product) {  
        items.remove(product);  
    }  
      
    @Override  
    public void updateQuantity(Product product, int quantity) {  
        int currentQuantity = items.get(product);  
        items.put(product, currentQuantity + quantity);  
    }  
}</code></pre> 
<p id="u0690c7c5">有 ISP 代码</p> 
<pre id="rmBNx"><code>interface AddToCart {  
    void addItem(Product product, int quantity);  
}  
  
interface RemoveFromCart {  
    void removeItem(Product product);  
}  
  
interface UpdateQuantity {  
    void updateQuantity(Product product, int quantity);  
}  
  
class ShoppingCartImpl implements AddToCart, RemoveFromCart, UpdateQuantity {  
    private Map&lt;Product, Integer&gt; items = new HashMap&lt;&gt;();  
      
    @Override  
    public void addItem(Product product, int quantity) {  
        items.put(product, quantity);  
    }  
      
    @Override  
    public void removeItem(Product product) {  
        items.remove(product);  
    }  
      
    @Override  
    public void updateQuantity(Product product, int quantity) {  
        int currentQuantity = items.get(product);  
        items.put(product, currentQuantity + quantity);  
    }  
}</code></pre> 
<h6 id="MKD1A">注意点</h6> 
<ul><li id="u2a6a68e4">接口定义尽可能小：每个接口提供有限的服务，方法尽可能少，不要妄想一个接口走遍天下</li><li id="ud1947bb8">分离不相关功能：如果接口中提供的功能不相关，需要将接口进行分离操作，形成独立接口，代码可更模块化和可定制化</li><li id="u67432662">避免使用过大的总接口：总接口应该根据需要提供适当的功能，而不是一刀切提供所有功能</li></ul> 
<h4 id="MKzKP">5 、DIP（Dependency Inversion Principle）依赖倒置原则</h4> 
<p id="u1ac5781b">DIP 强调在应用中，高层模块不应该依赖于底层模块，它们应该依赖于抽象。</p> 
<h6 id="a7gyD">优点</h6> 
<ul><li id="u8595a7a0">提高代码的可读性和可维护性：高层模块依赖于抽象，而不是具体实现，使得代码更灵活和易于理解</li><li id="u82bcb850">降低类之间的耦合度：依赖抽象不依赖具体实现，减少了高层模块和底层模块之间的直接依赖，提高了系统的灵活性</li><li id="u476d4a94">提高系统的可扩展性和可升级性：新的实现可以通过实现抽象来引入，不需要修改高层模块的代码</li></ul> 
<h6 id="nTm1r">示例代码</h6> 
<p id="ub9481703">无 DIP 代码</p> 
<pre id="lGDaC"><code>class UserService {  
    private UserDao userDao;  
      
    public UserService(UserDao userDao) {  
        this.userDao = userDao;  
    }  
      
    public User getUserById(int userId) {  
        return userDao.getUserById(userId);  
    }  
}  
  
class UserDao {  
    public User getUserById(int userId) {  
        // 具体实现逻辑，如从数据库中获取用户信息  
        return new User(userId, "John Doe");  
    }  
}</code></pre> 
<p id="u306a4317">有 DIP 代码</p> 
<pre id="PmfYa"><code>interface UserDataAccess {  
    User getUserById(int userId);  
}  
  
class UserDao implements UserDataAccess {  
    @Override  
    public User getUserById(int userId) {  
        // 具体实现逻辑，如从数据库中获取用户信息  
        return new User(userId, "John Doe");  
    }  
}  
  
class UserService {  
    private UserDataAccess userDataAccess;  
      
    public UserService(UserDataAccess userDataAccess) {  
        this.userDataAccess = userDataAccess;  
    }  
      
    public User getUserById(int userId) {  
        return userDataAccess.getUserById(userId);  
    }  
}</code></pre> 
<h6 id="tW0GO">注意点</h6> 
<ul><li id="ub2984211">通过接口或抽象类定义依赖关系：使用接口或抽象类来定义高层模块和底层模块之间的依赖关系</li><li id="u337406f1">避免直接依赖具体类：如果直接依赖具体类，一旦有修改，依赖元就要同步改动，影响和成本都较高</li><li id="u002e6fa2">使用依赖注入解耦：使用依赖注入来解耦类之间的依赖关系，通过注入抽象的实现来实现高层模块对底层模块的依赖</li></ul> 
<h4 id="VA0Uu">6 、CARP（Composition/Aggregation Reuse Principle）合成/聚合复用原则</h4> 
<p id="u84d5dd74">CARP 强调在应用设计过程中优先使用合成/聚合的关系，而不是继承的关系来实现复用。</p> 
<h6 id="cO8Hb">优点</h6> 
<ul><li id="u4affe464">更好地代码封装：通过使用合成/聚合，可以将对象的不同部分封装在不同的类中，更好地隐藏细节，提高代码的模块化和可维护性</li><li id="uf5d645f5">更灵活的代码结构：通过使用合成/聚合，可以更容易地改变对象的行为和结构，只需要修改相关的类，不需要修改整个继承体系</li><li id="u52418c7b">更好的可重用性：通过使用合成/聚合，可以根据需要组合不同的对象来实现代码的可重用性，且合成/聚合本身是一种松耦合，可以更便捷地组装新的对象类型</li><li id="uc70d6cc9">更好的可扩展性：通过使用合成/聚合，更便捷地添加新的功能和行为到应用中，这种灵活的关系，可以更容易适应新的需求和变化</li></ul> 
<h6 id="EQidT">示例代码</h6> 
<p id="u5a813a34">无 CARP 代码</p> 
<pre id="AdnuL"><code>class Car {  
    private Engine engine;  
    private Transmission transmission;  
    private Wheel wheel;  
    private Door door;  
  
    public Car(Engine engine, Transmission transmission, Wheel wheel, Door door) {  
        this.engine = engine;  
        this.transmission = transmission;  
        this.wheel = wheel;  
        this.door = door;  
    }  
  
    public void start() {  
        engine.start();  
    }  
  
    public void shift(int gear) {  
        transmission.shift(gear);  
    }  
  
    public void turn(int degrees) {  
        wheel.turn(degrees);  
    }  
  
    public void open() {  
        door.open();  
    }  
}</code></pre> 
<p id="u04a83cf4">有 CARP 代码</p> 
<pre id="WtUpB"><code>interface Engine {  
    void start();  
}  
interface Transmission {  
    void shift(int gear);  
}  
interface Wheel {  
    // 可以添加一些方法，例如 rotate() 和 brake() 等  
}  
interface Door {  
    void open();  
}  
class Car {  
    private Engine engine;  
    private Transmission transmission;  
    private Wheel wheel;  
    private Door door;  
  
    public Car(Engine engine, Transmission transmission, Wheel wheel, Door door) {  
        this.engine = engine;  
        this.transmission = transmission;  
        this.wheel = wheel;  
        this.door = door;  
    }  
}</code></pre> 
<h6 id="kIgzy">注意点</h6> 
<ul><li id="u5ad63127">封装变化：将变化的部分封装起来，使得变化对其他部分的影响最小</li><li id="u9f4dafbc">强调组合/聚合：首选使用组合/聚合关系，而不是直接继承关系，以提高灵活性和可维护性</li><li id="u5a685cd6">松耦合：合成/聚合是一种松耦合关系，允许系统更容易地适应变化</li></ul> 
<h4 id="ceZtc">7 、LoD（Law of Demeter）迪米特法则</h4> 
<p id="u6b2647c7">LoD 强调在应用中应该尽量减少对象之间的直接依赖关系，降低耦合度，提高可维护性和可重用性。</p> 
<p id="uaff03d23">核心思想是一个对象对其他对象保持最少的了解，并且只和那些和自己最有直接关系的对象进行交互。</p> 
<p id="ua41f2a51">一个对象只暴露必要的接口给其他对象，并且应该通过这些接口与其他对象进行交互。</p> 
<h6 id="Yb3Gd">优点</h6> 
<ul><li id="u03e01cc3">降低耦合度：减少对象之间的直接依赖关系，使得系统更容易扩展和维护</li><li id="u71c480de">提高可维护性：对象之间的松耦合关系使得修改一个对象的内部实现不会影响其他对象</li><li id="ua695ac50">提高可重用性：松耦合关系允许对象更容易地被独立重用在不同的上下文中</li></ul> 
<h6 id="jggoZ">示例代码</h6> 
<p id="u163b5128">无 LoD 代码</p> 
<pre id="qxHpc"><code>class Account {  
    private User user;  
    private List&lt;Transaction&gt; transactions;  
  
    public Account(User user, List&lt;Transaction&gt; transactions) {  
        this.user = user;  
        this.transactions = transactions;  
    }  
  
    public double getBalance() {  
        double balance = 0.0;  
        for (Transaction transaction : transactions) {  
            balance += transaction.getAmount();  
        }  
        return balance;  
    }  
  
    public void debit(double amount) {  
        user.setBalance(user.getBalance() - amount);  
    }  
}</code></pre> 
<p id="u871c291d">有 LoD 代码</p> 
<pre id="JDoYb"><code>interface UserService {  
    double getBalance(User user);  
}  
  
interface TransactionService {  
    void debit(User user, double amount);  
}  
  
class Account {  
    private UserService userService;  
    private TransactionService transactionService;  
  
    public Account(UserService userService, TransactionService transactionService) {  
        this.userService = userService;  
        this.transactionService = transactionService;  
    }  
  
    public double getBalance() {  
        return userService.getBalance(userService.getUser());  
    }  
  
    public void debit(double amount) {  
        transactionService.debit(userService.getUser(), amount);  
    }  
}</code></pre> 
<h6 id="k4cO7">注意点</h6> 
<ul><li id="u0577860f">定义接口：将对象的相关操作定义在接口中，而不是直接依赖于具体的实现</li><li id="u8a497a0f">通过接口交互：对象应该通过接口进行交互，而不是直接调用其他对象的方法</li><li id="u9eb58594">减少依赖关系：一个对象应该只与其直接的朋友发生交互，避免依赖过多的对象</li></ul> 
<p id="uce0c8787">接下来会逐一介绍各个设计模式。</p> 
<p id="u4c8651cc">我在介绍每一个设计模式的时候都会采用统一的框架，如下：</p> 
<p id="u03b7b2f5">1、什么是 XXX 设计模式？</p> 
<p id="ub02c70e8">2、为什么使用 XXX 设计模式？</p> 
<p id="ue28d78b4">3、如何实现 XXX 设计模式？</p> 
<p id="ub96d620d">4、是否存在缺陷和不足？</p> 
<p id="u9466465a">5、如何缓解缺陷和不足？</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c3a243deb82a9aef828e83034fa8c7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Centos7安装nacos教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a152ec05e775f4b9e549cbdf41abfd1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot jpa sql查询条件空值判断</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>