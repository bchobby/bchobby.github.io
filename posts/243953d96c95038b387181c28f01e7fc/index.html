<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android WebSocket状态管理框架 - WebSocketGo - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android WebSocket状态管理框架 - WebSocketGo" />
<meta property="og:description" content="阅读本文需要 Integer.MAX_VALUE 分钟。
故事背景 笔者所在的公司主营业务是智能家居，笔者在公司负责的Android端App的开发。关于智能家居，估计现在百分之八九十的童鞋都听过，但真正了解或者使用过的估计就不占多数了。本文不谈行业前景，只谈技术。
为了方便大家更加了解故事的背景，顺便科普一下智能家居，想直奔WebSocket主题的童鞋可以直接第二章节。
智能家居，算是物联网的一个典型应用场景。什么是物联网呢，字面意思就是把众多物体连接起来组成一个网络，英文是Internet of things（IoT）。小到一个你的手机跟蓝牙耳机，大到一个城市的各个角落，究极形态就是“万物互联”。（为什么突然想起万佛朝宗 -_-!）
IoT其实不在意网络的协议，也不在意连接的到底是什么东东，就这种形态本身而言，就是IoT。其实这个概念其实很早就有了，在笔者上大学那会，不怕暴露年龄的说是在09到10年左右就听说过物联网这个词。还记得实验课的GPRS智能抄表系统么，你可能没有觉得多么高大上，不就是水表上插个SIM卡，定期把值发到客户端上么，再也不怕被人上门查水表啦~ 没错，这也是IoT的一种体现。
但这么多年，物联网但一直不温不火。至于为什么最近几年又被提出来呢，智能家居在其中扮演了很重要的作用。另外AI这把火也起到了推波助澜的作用，任何产品都要加上智能二字。所以有了AI &#43; IoT，也就是AIOT。具体就不详述了，以后可以再单开一文详细介绍下物联网。
说回智能家居，智能家居是家庭为单位的物联网，简单说就是你可以通过家里中控或者App控制制家里的灯、插座、监控、电器等等。
文字算个球，一图解千愁，上架构图
简单解释一下，网关的作用是负责连接屋内的所有设备，网关和设备之间一般不会采用HTTP（个别单品除外），而会采用比如zigbee、lora等近场通信协议（或者直接用有线方式更稳定），因为功耗低，比较省电，你想家里如果装了几十个开关面板，总归每个月也能节约十几二十块钱的电费吧。当然最重要的原因还是因为方案也比较成熟。所以使用这类设备之前需要有个“组网”的操作，把设备组到网关上。如果断开了，网关就认为设备离线了。
网关会将设备的状态上报给云平台，云平台就将状态下发给客户端了。同样，客户端控制设备就是个反向的过程。当然如果以后5G普及了，设备直接通过5G网络连接云平台，因为5G功耗低、延迟低、速度快，就可以不需要网关了。
整体的架构还算是比较简单的，当然中间也有很多复杂的逻辑，涉及到比如设备状态、人员、权限、房屋的管理等等这里就不关注了。
在服务器下发设备状态的时候就涉及到了推送。因为智能家居有情景模式的概念，比如回家模式，执行一个请求，咔咔打开十几个灯，所以靠请求的返回值判断状态是不太现实的，只能依靠推送。
由于业务的特殊性，智能家居的推送需要有较高的实时性，比如用户打开了灯（无论在app上打开或者直接打开），app上的灯的状态都需要立即变成开。如果等个3、5秒状态再发生改变，这样的用户体验很不好。
我们最早使用的是某光推送，发现延迟严重，有时需要等十几秒才收到推送，毕竟适用场景毕竟不一样。所以决定自建长连接当推送。经过选型，决定采用本文的主角，WebSocket。
WebSocket状态管理现存的问题 市面上有很多现成的WebSocket连接库，比较著名的有Java-WebSocket，OkHttp也自带WebSocket支持。
最初因为项目内已经接入了OkHttp，所以直接使用了OkHttp。使用的方式很简单，熟悉OkHttp的童鞋应该很懂，
OkHttpClient client = OkHttpClient.Builder().build(); Request request = new Request.Builder().build(); client.newWebSocket(request, new WebSocketListener() { @Override public void onOpen(okhttp3.WebSocket webSocket, Response response) {} @Override public void onMessage(okhttp3.WebSocket webSocket, String text) {} @Override public void onClosed(okhttp3.WebSocket webSocket, int code, String reason) {} @Override public void onFailure(okhttp3.WebSocket webSocket, Throwable t, Response response) {} }); 复制代码 调用方便，回调状态也很清晰。Java-Websocket也差不多类似，但总体来说有以下几个问题：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/243953d96c95038b387181c28f01e7fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-31T21:47:29+08:00" />
<meta property="article:modified_time" content="2022-05-31T21:47:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android WebSocket状态管理框架 - WebSocketGo</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>阅读本文需要 Integer.MAX_VALUE 分钟。</p> 
<h2><a id="_2"></a>故事背景</h2> 
<p>笔者所在的公司主营业务是智能家居，笔者在公司负责的Android端App的开发。关于智能家居，估计现在百分之八九十的童鞋都听过，但真正了解或者使用过的估计就不占多数了。本文不谈行业前景，只谈技术。</p> 
<p>为了方便大家更加了解故事的背景，顺便科普一下智能家居，<strong>想直奔WebSocket主题的童鞋可以直接第二章节</strong>。</p> 
<p>智能家居，算是物联网的一个典型应用场景。什么是物联网呢，字面意思就是把众多物体连接起来组成一个网络，英文是Internet of things（IoT）。小到一个你的手机跟蓝牙耳机，大到一个城市的各个角落，究极形态就是“万物互联”。（为什么突然想起万佛朝宗 -_-!）</p> 
<p>IoT其实不在意网络的协议，也不在意连接的到底是什么东东，就这种形态本身而言，就是IoT。其实这个概念其实很早就有了，在笔者上大学那会，不怕暴露年龄的说是在09到10年左右就听说过物联网这个词。还记得实验课的GPRS智能抄表系统么，你可能没有觉得多么高大上，不就是水表上插个SIM卡，定期把值发到客户端上么，再也不怕被人上门查水表啦~ 没错，这也是IoT的一种体现。</p> 
<p>但这么多年，物联网但一直不温不火。至于为什么最近几年又被提出来呢，智能家居在其中扮演了很重要的作用。另外AI这把火也起到了推波助澜的作用，任何产品都要加上智能二字。所以有了AI + IoT，也就是AIOT。具体就不详述了，以后可以再单开一文详细介绍下物联网。</p> 
<p>说回智能家居，智能家居是家庭为单位的物联网，简单说就是你可以通过家里中控或者App控制制家里的灯、插座、监控、电器等等。</p> 
<p>文字算个球，一图解千愁，上架构图</p> 
<p><img src="https://images2.imgbox.com/5a/d6/YdCgVQFq_o.png" alt=""></p> 
<p>简单解释一下，网关的作用是负责连接屋内的所有设备，网关和设备之间一般不会采用HTTP（个别单品除外），而会采用比如zigbee、lora等近场通信协议（或者直接用有线方式更稳定），因为功耗低，比较省电，你想家里如果装了几十个开关面板，总归每个月也能节约十几二十块钱的电费吧。当然最重要的原因还是因为方案也比较成熟。所以使用这类设备之前需要有个“组网”的操作，把设备组到网关上。如果断开了，网关就认为设备离线了。</p> 
<p>网关会将设备的状态上报给云平台，云平台就将状态下发给客户端了。同样，客户端控制设备就是个反向的过程。当然如果以后5G普及了，设备直接通过5G网络连接云平台，因为5G功耗低、延迟低、速度快，就可以不需要网关了。</p> 
<p>整体的架构还算是比较简单的，当然中间也有很多复杂的逻辑，涉及到比如设备状态、人员、权限、房屋的管理等等这里就不关注了。</p> 
<p>在服务器下发设备状态的时候就涉及到了推送。因为智能家居有情景模式的概念，比如回家模式，执行一个请求，咔咔打开十几个灯，所以靠请求的返回值判断状态是不太现实的，只能依靠推送。</p> 
<p>由于业务的特殊性，智能家居的推送需要有较高的实时性，比如用户打开了灯（无论在app上打开或者直接打开），app上的灯的状态都需要立即变成开。如果等个3、5秒状态再发生改变，这样的用户体验很不好。</p> 
<p>我们最早使用的是某光推送，发现延迟严重，有时需要等十几秒才收到推送，毕竟适用场景毕竟不一样。所以决定自建长连接当推送。经过选型，决定采用本文的主角，WebSocket。</p> 
<h2><a id="WebSocket_33"></a>WebSocket状态管理现存的问题</h2> 
<p>市面上有很多现成的WebSocket连接库，比较著名的有Java-WebSocket，OkHttp也自带WebSocket支持。</p> 
<p>最初因为项目内已经接入了OkHttp，所以直接使用了OkHttp。使用的方式很简单，熟悉OkHttp的童鞋应该很懂，</p> 
<pre><code>OkHttpClient client = OkHttpClient.Builder().build();
Request request = new Request.Builder().build();
client.newWebSocket(request, new WebSocketListener() {
    @Override
    public void onOpen(okhttp3.WebSocket webSocket, Response response) {}

    @Override
    public void onMessage(okhttp3.WebSocket webSocket, String text) {}

    @Override
    public void onClosed(okhttp3.WebSocket webSocket, int code, String reason) {}

    @Override
    public void onFailure(okhttp3.WebSocket webSocket, Throwable t, Response response) {}
});
复制代码 
</code></pre> 
<p>调用方便，回调状态也很清晰。Java-Websocket也差不多类似，但总体来说有以下几个问题：</p> 
<h3><a id="1__61"></a>1. <strong>心跳机制</strong></h3> 
<p>无论OkHttp还是Java-WebSocket，都是有心跳机制的。但OkHttp的心跳间隔，也就是pingInterval，在创建client时候就已经固定了，是不支持中途调整的。（Jake大神还在github上回复过相关问题，意思是调用者不需要关注这些。但往往确实有这种需求的啊😢😢😢）</p> 
<p>比如应用在前台的时候心跳可能稍微频繁点，但应用出于后台时出于省电的优化，心跳间隔可以设置的稍微长一点。如果需要调整心跳，需要创建新的client，断掉旧的，重新连接。有两种策略：</p> 
<ul><li>先断旧的，再连新的。如果服务端的消息没有做缓存策略，在断掉和新连接的间隔可能会漏掉消息。</li><li>先连新的，再断旧的。这要在一瞬时就会有两个连接连上服务端，服务端对于消息的状态可能会发生异常。</li></ul> 
<p>以上两种策略都需要客户端和服务端先约定好，服务端做额外处理，增加研发成本不说，也有增加出错概率。</p> 
<h3><a id="2__73"></a>2. <strong>断掉重连</strong></h3> 
<p>通常连接断掉有以下这么几种情况：</p> 
<ul><li>客户端主动断（无需重连）</li><li>服务端主动断（无需重连）</li><li>客户端因为网络原因，比如手机断网，非主动段（需要重连）</li><li>运营商因连接空闲导致的连接断开（需要重连）</li></ul> 
<p>对于重连，还需要考虑的问题是重连的时间间隔，如果手机网断了，不停地重连同样是失败，所以需要自己制定一个重连次数和时间间隔关系。</p> 
<p>总之，重连的逻辑和策略是需要我们自己维护的。</p> 
<h3><a id="3__89"></a>3. <strong>多线程</strong></h3> 
<p>OkHttp中关于状态的回调发生在OkHttp创建的子线程中，根据状态我们需要发起重连。如果这时候我们的应用发生了前后台切换又要创建新连接，各种连接（重连）交织在一起，那真是一团乱麻。需要考虑的问题有：</p> 
<ul><li>同时发起多个连接的情况，需要等上一个连接请求执行完，再根据请求发起下一个连接请求。上一个连接如果连上了，那下一个等待的连接请求就可以直接跳过了。</li><li>连接请求的发生在不同线程中，状态的同步</li></ul> 
<h2><a id="_97"></a>解决方案</h2> 
<p>因为笔者项目内用的是OkHttp，所以最初的解决方案都是针对于OkHttp来做的。大致思路如下：</p> 
<h3><a id="1__102"></a>1. <strong>心跳机制</strong></h3> 
<h4><a id="11_OkHttp_WebSocket_105"></a>1.1 OkHttp WebSocket心跳分析</h4> 
<p>前面说到过，OkHttp是不支持动态调整心跳的，那OkHttp是怎么维护心跳的呢，我们来分析一下它的源码：</p> 
<p>分析源码，我们从调用入口client.newWebSocket开始：</p> 
<pre><code>// newWebSocket@OkHttpClient.java

/**
 * 内部使用RealWebSocket类来发起连接
 */
@Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
    // 注意这里的pingInterval，所以在创建RealWebSocket时就已经固定，没法再修改了。
    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
    webSocket.connect(this);
    return webSocket;
}
复制代码

// RealWebSocket@RealWebSocket.java

public RealWebSocket(Request request, WebSocketListener listener, Random random, long pingIntervalMillis) {
    this.originalRequest = request;
    this.listener = listener;
    this.random = random;
    this.pingIntervalMillis = pingIntervalMillis;
    // ...
    // 这里的writerRunnable是用来向服务端发送消息的，在后面详述
    this.writerRunnable = new Runnable() {
      @Override public void run() {
        try {
          while (writeOneFrame()) {
          }
        } catch (IOException e) {
          failWebSocket(e, null);
        }
      }
    };
  }
  
  public void connect(OkHttpClient client) {
    // WebSocket协议相关的header
    client = client.newBuilder()
        .eventListener(EventListener.NONE)
        .protocols(ONLY_HTTP1)
        .build();
    final Request request = originalRequest.newBuilder()
        .header("Upgrade", "websocket")
        .header("Connection", "Upgrade")
        .header("Sec-WebSocket-Key", key)
        .header("Sec-WebSocket-Version", "13")
        .build();
    call = Internal.instance.newWebSocketCall(client, request);
    call.enqueue(new Callback() {
      @Override public void onResponse(Call call, Response response) {
        try {
          checkResponse(response);
        } catch (ProtocolException e) {
          failWebSocket(e, response);
          closeQuietly(response);
          return;
        }

        // Promote the HTTP streams into web socket streams.
        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
        streamAllocation.noNewStreams(); // Prevent connection pooling!
        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);

        // Process all web socket messages.
        try {
          // 连接成功，调用listern的onOpen
          listener.onOpen(RealWebSocket.this, response);
          String name = "OkHttp WebSocket " + request.url().redact();
          // 重点1：创建reader和writer，见下文
          initReaderAndWriter(name, streams);
          streamAllocation.connection().socket().setSoTimeout(0);
          // 重点2：轮询读
          loopReader();
        } catch (Exception e) {
          failWebSocket(e, null);
        }
      }

      @Override public void onFailure(Call call, IOException e) {
        failWebSocket(e, null);
      }
    });
  }
  
   public void initReaderAndWriter(String name, Streams streams) throws IOException {
    synchronized (this) {
      this.streams = streams;
      this.writer = new WebSocketWriter(streams.client, streams.sink, random);
      // 创建Scheduled线程池
      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
      if (pingIntervalMillis != 0) {
        // 利用线程池定期运行PingRunnable，越来越接近真像了
        executor.scheduleAtFixedRate(
            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
      }
      if (!messageAndCloseQueue.isEmpty()) {
        runWriter(); // Send messages that were enqueued before we were connected.
      }
    }
    // 创建reader，用来读取消息
    reader = new WebSocketReader(streams.client, streams.source, this);
  }
复制代码 
</code></pre> 
<p>重点看一下PingRunnable都做了什么</p> 
<pre><code>private final class PingRunnable implements Runnable {
    PingRunnable() {
    }

    @Override public void run() {
      // 发送ping frame
      writePingFrame();
    }
  }

  void writePingFrame() {
    WebSocketWriter writer;
    int failedPing;
    synchronized (this) {
      if (failed) return;
      writer = this.writer;
      // 判断是否在等待pong，如果在等待failedPing置为sentPingCount，否则置为-1
      failedPing = awaitingPong ? sentPingCount : -1;
      sentPingCount++;
      awaitingPong = true;
    }

    if (failedPing != -1) {
      // 运行到此处的条件是上一个pong还没有返回，报错退出
      failWebSocket(new SocketTimeoutException("sent ping but didn't receive pong within "
          + pingIntervalMillis + "ms (after " + (failedPing - 1) + " successful ping/pongs)"),
          null);
      return;
    }

    try {
      // 发送一个ping消息
      writer.writePing(ByteString.EMPTY);
    } catch (IOException e) {
      failWebSocket(e, null);
    }
  }
复制代码 
</code></pre> 
<p>那么怎么判断有没有收到pong了，就需要用到reader了。我们来看一下reader里做了什么。</p> 
<p>还记得前文重点2标记的loopReader么？</p> 
<pre><code>// loopReader@RealWebSocket.java

/** Receive frames until there are no more. Invoked only by the reader thread. */
public void loopReader() throws IOException {
    while (receivedCloseCode == -1) {
        // This method call results in one or more onRead* methods being called on this thread.
        // 处理收到的frame
        reader.processNextFrame();
    }
}

/**
 * 根据header判断是消息帧还是控制帧，心跳pong属于控制帧
 */
void processNextFrame() throws IOException {
    readHeader();
    if (isControlFrame) {
      readControlFrame();
    } else {
      readMessageFrame();
    }
  }

/**
 * 解析opcode
 */
private void readControlFrame() throws IOException {
    // ...
    switch (opcode) {
      case OPCODE_CONTROL_PING:
        frameCallback.onReadPing(controlFrameBuffer.readByteString());
        break;
      case OPCODE_CONTROL_PONG:
        // 注意：收到pong，触发onReadPing
        frameCallback.onReadPong(controlFrameBuffer.readByteString());
        break;
      case OPCODE_CONTROL_CLOSE:
        // ...
        frameCallback.onReadClose(code, reason);
        closed = true;
        break;
      default:
        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
    }
  }
  
  /**
    * 计数器自增，将awaitingPong状态置为false
    */
  @Override public synchronized void onReadPong(ByteString buffer) {
    // This API doesn't expose pings.
    receivedPongCount++;
    awaitingPong = false;
  }
复制代码 
</code></pre> 
<p>一路追下来发现，其实收到pong之后，okhttp就是简单地改变awaitingPong标记位的状态，就代表收到了上一个pong消息。</p> 
<p>总结一下，okhttp的心跳流程，</p> 
<ol><li>ReadWebSocket连接的时候创建schedule线程池，定期地执行PingRunnable发送ping消息；（发送其他的请求消息在WriteRunnable中）</li><li>同时创建一个reader不断接受消息；</li><li>发送ping之前，通过awaitingPong标记，判断上一个pong有没有回来；</li><li>对于收到的消息，进行解析，如果收到的pong，改变awaitingPong状态。</li></ol> 
<h4><a id="12_okhttp_330"></a>1.2 <strong>动态调整okhttp心跳</strong></h4> 
<p>我们发现，只要改变线程池执行PingRunable的delayTime，就能达到在不重新创建OkHttpClient的情况下，动态改变ping的速率。</p> 
<p>所以可以用反射的方式，shutDown原来的线程池，创建新的线程池，用新的pingInterval执行pingRunnable。</p> 
<pre><code>Class clazz = Class.forName("okhttp3.internal.ws.RealWebSocket");
Field field = clazz.getDeclaredField("executor");
field.setAccessible(true);
ScheduledExecutorService oldService = (ScheduledExecutorService) field.get(mWebSocket);

Class[] innerClasses = Class.forName("okhttp3.internal.ws.RealWebSocket").getDeclaredClasses();
for (Class innerClass : innerClasses) {
    if ("PingRunnable".equals(innerClass.getSimpleName())) {
        // 创建新的PingRunnable实例
        Constructor constructor = innerClass.getDeclaredConstructor(RealWebSocket.class);
        constructor.setAccessible(true);
        Object pingRunnable = constructor.newInstance(mWebSocket);

        // 创建新的线程池
        ScheduledThreadPoolExecutor newService = new ScheduledThreadPoolExecutor(1, Util.threadFactory("ws-ping", false));
        newService.scheduleAtFixedRate((Runnable) pingRunnable, interval, interval, unit);
        field.set(mWebSocket, newService);

        // shutdown旧的线程池
        oldService.shutdown();
    }
}
复制代码 
</code></pre> 
<p>这样，我们就达成了动态调整心跳的目的。</p> 
<p>Java-WebSocket的ping是通过外部调用sendPing()来达到发送ping的目的的，内部没有ping/pong状态机制，所以需要我们自己去维护这个关系。其实可以仿照OkHttp那样，利用定时消息去发送ping，然后解析pong来维护心跳状态。这里就不过多阐述了。</p> 
<h3><a id="2__366"></a>2. <strong>断掉重连</strong></h3> 
<p>正如前面提过的，断掉重连只要处理好几种断开状态的逻辑即可。好在绝大多数websocket库都分close、error回调，可以区分异常断开和主动断开。</p> 
<p>需要自己维护的也就是重连的间隔和重试次数的关系，类似指数退避算法。</p> 
<h3><a id="3__373"></a>3. <strong>多线程</strong></h3> 
<p>针对上文说到的多线程问题，主要的问题点就是发生在同时发生多个连接请求的时候，与其对多线程加各种同步，不如并行该串行。采用类似消息队列的方式，消息的处理放在单独的线程中取做。这样就可以省却了线程的同步，同时也能保证状态的有序性。</p> 
<p>其实Android中，利用HandlerThread就可以完美地满足上述两点，最初笔者也确实是利用HandlerThread来做的。后来觉得可以独立于平台，也可以运行在纯Java的平台上，所以还是自己手动实现了。同时自己维护消息队列，也可以更好地自己处理优先级、延迟等。</p> 
<h2><a id="WebSocketGo_380"></a>WebSocketGo</h2> 
<p>之前也说过，笔者的项目是基于OkHttp的，但发现状态管理这部分可以单独抽象出来，所以才会有了本文的标题<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FGnepux%2FWebSocketGo" rel="nofollow">WebSocketGo</a>（以下简称WsGo）。</p> 
<p>数据流如下：</p> 
<p><img src="https://images2.imgbox.com/64/a4/zzylOIMP_o.png" alt=""></p> 
<ol><li> <p>Dispatcher就是前文提到的消息队列，就是生产者-消费者模式，维护两个队列，发送command，接收event。</p> 
  <ul><li> <p>command主要有：CONNECT、DISCONNECT、RECONNECT、CHANGE_PING、SEND</p> </li><li> <p>event主要有：OnConnect、onMessage、onSend、onRetry、onDisConnect、onClose</p> </li></ul> </li><li> <p>Channel Manager主要负责状态管理。</p> </li><li> <p>WebSocket interface可以理解为适配层，负责调用WebSocket库。</p> </li><li> <p>Event Listener就是前台的状态回调。</p> </li></ol> 
<h3><a id="WsGo_403"></a>接入WsGo</h3> 
<pre><code>implementation 'com.gnepux:wsgo:1.0.2'
// use okhttp
implementation 'com.gnepux:wsgo-okwebsocket:1.0.1'
// use java websocket
implementation 'com.gnepux:wsgo-jwebsocket:1.0.1'
复制代码 
</code></pre> 
<h3><a id="_415"></a>初始化</h3> 
<pre><code>WsConfig config = new WsConfig.Builder()
        .debugMode(true)    // true to print log
        .setUrl(pushUrl)    // ws url
        .setHttpHeaders(headerMap)  // http headers
        .setConnectTimeout(10 * 1000L)  // connect timeout
        .setReadTimeout(10 * 1000L)     // read timeout
        .setWriteTimeout(10 * 1000L)    // write timeout
        .setPingInterval(10 * 1000L)    // initial ping interval
        .setWebSocket(OkWebSocket.create()) // websocket client
        .setRetryStrategy(retryStrategy)    // retry count and delay time strategy
        .setEventListener(eventListener)    // event listener
        .build();
WsGo.init(config);
复制代码 
</code></pre> 
<h3><a id="Go_435"></a>Go</h3> 
<pre><code>// 连接
WsGo.getInstance().connect();
// 发送消息
WsGo.getInstance().send("hello from WsGo");
// 断开
WsGo.getInstance().disconnect(1000, "close");
WsGo.getInstance().disconnectNormal("close");
// 改变心跳
WsGo.getInstance().changePingInterval(10, TimeUnit.SECONDS);
// 释放
WsGo.getInstance().destroyInstance();
复制代码 
</code></pre> 
<h3><a id="WsConfig_453"></a>WsConfig的更多配置</h3> 
<h4><a id="setWebSocketWebSocket_socket_456"></a>setWebSocket(WebSocket socket)</h4> 
<p>WsGo 已经支持OkHttp and Java WebSocket</p> 
<pre><code>// for OkHttp (wsgo-okwebsocket)
setWebSocket(OkWebSocket.create());
// for Java WebSocket (wsgo-jwebsocket)
setWebSocket(JWebSocket.create());
复制代码 

</code></pre> 
<p>如果你需要使用其他的WebSocket库或自定义客户端，只需要实现一个WebSocket接口，将对应结果传递给ChannelCallback即可。剩下的连接管理，WsGo会帮你完成。</p> 
<pre><code>public interface WebSocket {
    void connect(WsConfig config, ChannelCallback callback);
    void reconnect(WsConfig config, ChannelCallback callback);
    boolean disconnect(int code, String reason);
    void changePingInterval(long interval, TimeUnit unit);
    boolean send(String msg);
}
复制代码 

</code></pre> 
<h4><a id="setRetryStrategyRetryStrategy_retryStrategy_483"></a>setRetryStrategy(RetryStrategy retryStrategy)</h4> 
<p>对于非正常断开，WsGo会自动重连。RetryStrategy指的是重连次数和延时的关系。</p> 
<p>WsGo默认有一个DefaultRetryStrategy，如果你需要自己调整，实现RetryStrategy接口里的onRetry方法即可。</p> 
<pre><code>public interface RetryStrategy {
    /**
     * 重试次数和延迟的关系
     *
     * @param retryCount 已经重试的次数
     * @return 延时的时间
     */
    long onRetry(long retryCount);
}
复制代码 

</code></pre> 
<h4><a id="setEventListenerEventListener_eventListener_503"></a>setEventListener(EventListener eventListener)</h4> 
<p>添加事件回调。需要注意，回调在WsGo自己创建的一个线程中运行，不在调用线程中。如有必要，需要在会调用手动切换线程。</p> 
<pre><code>public interface EventListener {
    void onConnect();
    void onDisConnect(Throwable throwable);
    void onClose(int code, String reason);
    void onMessage(String text);
    void onReconnect(long retryCount, long delayMillSec);
    void onSend(String text, boolean success);
}
复制代码 

</code></pre> 
<h4><a id="PS_520"></a>PS</h4> 
<p>目前WsGo没有与手机网络的变化通知关联（即断网可以收到回调，网络恢复不会自动重连），因为笔者觉得这部分不属于WebSocket自身的状态管理范畴，而且已经不属于平台无关了。如有有这方便需求，需要自己从外部发起连接。在项目中简单地封装一下就ok啦~</p> 
<h2><a id="_524"></a>后记</h2> 
<p>本文稍显长，从最初的智能家居的场景开始，介绍到websocket状态管理现存的问题，然后给出了笔者的解决方案，最后是通用的状态管理框架WebSocketGo。也算是笔者在工作中的一点思考和总结。其实细想，不光WebSocket，所有的长连接应该都会面临相同的问题。但思考的角度和解决的出发点应该都是一样的。</p> 
<h3><a id="_531"></a>文末</h3> 
<h3><a id="_534"></a>总结</h3> 
<p>要想成为架构师，那就不要局限在编码，业务，要会选型、扩展，提升编程思维。此外，良好的职业规划也很重要，学习的习惯很重要，但是最重要的还是要能持之以恒，任何不能坚持落实的计划都是空谈。</p> 
<p>如果你没有方向，这里给大家分享一套由阿里高级架构师编写的《Android八大模块进阶笔记》，帮大家将杂乱、零散、碎片化的知识进行体系化的整理，让大家系统而高效地掌握Android开发的各个知识点。<br> <img src="https://images2.imgbox.com/77/e8/CvnuFXkL_o.png" alt="在这里插入图片描述"><br> 相对于我们平时看的碎片化内容，这份笔记的知识点更系统化，更容易理解和记忆，是严格按照知识体系编排的。</p> 
<h4><a id="_541"></a>一、架构师筑基必备技能</h4> 
<p>1、深入理解Java泛型<br> 2、注解深入浅出<br> 3、并发编程<br> 4、数据传输与序列化<br> 5、Java虚拟机原理<br> 6、高效IO<br> ……</p> 
<p><img src="https://images2.imgbox.com/a0/62/r1D6GLZd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Android_551"></a>二、Android百大框架源码解析</h4> 
<p>1.Retrofit 2.0源码解析<br> 2.Okhttp3源码解析<br> 3.ButterKnife源码解析<br> 4.MPAndroidChart 源码解析<br> 5.Glide源码解析<br> 6.Leakcanary 源码解析<br> 7.Universal-lmage-Loader源码解析<br> 8.EventBus 3.0源码解析<br> 9.zxing源码分析<br> 10.Picasso源码解析<br> 11.LottieAndroid使用详解及源码解析<br> 12.Fresco 源码分析——图片加载流程</p> 
<p><img src="https://images2.imgbox.com/71/fc/6C37vuFG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Android_566"></a>三、Android性能优化实战解析</h4> 
<ul><li>腾讯Bugly:对字符串匹配算法的一点理解</li><li>爱奇艺：安卓APP崩溃捕获方案——xCrash</li><li>字节跳动：深入理解Gradle框架之一：Plugin, Extension, buildSrc</li><li>百度APP技术：Android H5首屏优化实践</li><li>支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</li><li>携程：从智行 Android 项目看组件化架构实践</li><li>网易新闻构建优化：如何让你的构建速度“势如闪电”？</li><li>…</li></ul> 
<p><img src="https://images2.imgbox.com/5b/e9/mOSW5mZL_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="kotlin_578"></a>四、高级kotlin强化实战</h4> 
<p>1、Kotlin入门教程<br> 2、Kotlin 实战避坑指南<br> 3、项目实战《Kotlin Jetpack 实战》</p> 
<ul><li> <p>从一个膜拜大神的 Demo 开始</p> </li><li> <p>Kotlin 写 Gradle 脚本是一种什么体验？</p> </li><li> <p>Kotlin 编程的三重境界</p> </li><li> <p>Kotlin 高阶函数</p> </li><li> <p>Kotlin 泛型</p> </li><li> <p>Kotlin 扩展</p> </li><li> <p>Kotlin 委托</p> </li><li> <p>协程“不为人知”的调试技巧</p> </li><li> <p>图解协程：suspend</p> </li></ul> 
<p><img src="https://images2.imgbox.com/fd/78/Grr1tKn8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="AndroidUI_602"></a>五、Android高级UI开源框架进阶解密</h4> 
<p>1.SmartRefreshLayout的使用<br> 2.Android之PullToRefresh控件源码解析<br> 3.Android-PullToRefresh下拉刷新库基本用法<br> 4.LoadSir-高效易用的加载反馈页管理框架<br> 5.Android通用LoadingView加载框架详解<br> 6.MPAndroidChart实现LineChart（折线图）<br> 7.hellocharts-android使用指南<br> 8.SmartTable使用指南<br> 9.开源项目android-uitableview介绍<br> 10.ExcelPanel 使用指南<br> 11.Android开源项目SlidingMenu深切解析<br> 12.MaterialDrawer使用指南<br> <img src="https://images2.imgbox.com/c4/55/DDF895cW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="NDK_616"></a>六、NDK模块开发</h4> 
<p>1、NDK 模块开发<br> 2、JNI 模块<br> 3、Native 开发工具<br> 4、Linux 编程<br> 5、底层图片处理<br> 6、音视频开发<br> 7、机器学习</p> 
<p><img src="https://images2.imgbox.com/f8/c2/AXDZwXCn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Flutter_627"></a>七、Flutter技术进阶</h4> 
<p>1、Flutter跨平台开发概述<br> 2、Windows中Flutter开发环境搭建<br> 3、编写你的第一个Flutter APP<br> 4、Flutter开发环境搭建和调试<br> 5、Dart语法篇之基础语法(一)<br> 6、Dart语法篇之集合的使用与源码解析(二)<br> 7、Dart语法篇之集合操作符函数与源码分析(三)<br> …<br> <img src="https://images2.imgbox.com/81/21/J7NoR52T_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_637"></a>八、微信小程序开发</h4> 
<p>1、小程序概述及入门<br> 2、小程序UI开发<br> 3、API操作<br> 4、购物商场项目实战……</p> 
<p><img src="https://images2.imgbox.com/0e/7f/l1bINUZK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_644"></a>全套视频资料：</h4> 
<p><strong>一、面试合集</strong><br> <img src="https://images2.imgbox.com/c2/b2/thKiv8IC_o.png" alt="在这里插入图片描述"><br> <strong>二、源码解析合集</strong></p> 
<p><img src="https://images2.imgbox.com/31/22/ajlc6G8F_o.png" alt="在这里插入图片描述"><br> <strong>三、开源框架合集</strong></p> 
<p><img src="https://images2.imgbox.com/16/ca/N5mXIazE_o.png" alt="在这里插入图片描述"><br> <strong>欢迎大家一键三连支持，若需要文中资料，直接点击文末CSDN官方认证微信卡片免费领取【保证100%免费】↓↓↓</strong><br> <img src="https://images2.imgbox.com/80/7a/gcVjdmtb_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5dbaac390493d71f73b63313231e4dee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">无法获取 dpkg 前端锁 (/var/lib/dpkg/lock-frontend)，是否有其他进程正占用它</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b296a43cb5980275e475b88b8020035/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode-spring-boot YAML_UNKNOWN_PROPERTY 解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>