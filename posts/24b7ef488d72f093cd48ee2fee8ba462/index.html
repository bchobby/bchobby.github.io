<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 数据结构篇 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 数据结构篇" />
<meta property="og:description" content="在众多编程语言里，数据结构与算法都可以说是至关重要的基础。但是对于python而言，因为其本身就是用C实现的，其速度和效率本身较低，因而pyhon没有像其他语言那样那么重视数据结构与算法（python最引以为傲的应该是其功能强大而丰富的各种库和模块）。对于很多像我一样的新手小白，时间复杂度似乎也不是硬要求，实现功能就行了。本节我们主要介绍用python实现数据结构。
对于数据结构，我们将采用以下的思路进行学习：
一、定义对象、节点
1.线性结构：
数组、链表、队列、栈
2.非线性结构：
树、堆、图
二、实现节点之间的互联
在节点属性中增加指针
三、对象由某一节点处开始的遍历
1.线性结构
1）单向遍历
2）双向遍历
2.非线性结构
1）DFS（深度优先搜索）
2）BFS（广度优先搜索）
四、基本操作方法
1.增加节点
2.返回节点数量
3.由遍历结果构建对象
目录
一、线性数据结构（一对一）
1.数组
1）构造一个数组对象
2）查找数组信息
3）删除操作
4）添加操作
5）转换操作
6）文件操作
7)排序
2.链表
1）单向链表
2）双向链表
3）双向循环链表
3.队列（queue模块）
队列方法：（适用于所有的队列）
1）FIFO先入先出队列--Queue
2）LIFO后入先出队列（栈）
3）优先级队列
4）双端队列
二、非线性数据结构
1.树（一对多）
1）二叉树
联动：二叉树与优先级队列--堆
2）树
3）森林
2.图（多对多）
1）图的分类
2）图的实现
邻接矩阵
邻接表
十字链表
邻接多重表
3）图的算法
遍历
最小生成树
最短路径
一、线性数据结构（一对一） 1.数组 数组 python使用其内置的模块array实现数组，python的数组就和C语言一样精简而高效。
1）构造一个数组对象 array.array(typecode[, initializer]) # 例：构造一个空的int类型数组 arr = array(&#39;i&#39;) arr = array(&#39;i&#39;, [0, 1, 2, 3, 4, 6, 7, 8, 9, 100]) 由于python没有对于变量声明的要求，所以在创建数组时需要一个类型代码字符标识该数组的数据类型，这样数组才能像C语言里的数组一样操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/24b7ef488d72f093cd48ee2fee8ba462/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-07T11:02:32+08:00" />
<meta property="article:modified_time" content="2022-07-07T11:02:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 数据结构篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在众多编程语言里，数据结构与算法都可以说是至关重要的基础。但是对于python而言，因为其本身就是用C实现的，其速度和效率本身较低，因而pyhon没有像其他语言那样那么重视数据结构与算法（python最引以为傲的应该是其功能强大而丰富的各种库和模块）。对于很多像我一样的新手小白，时间复杂度似乎也不是硬要求，实现功能就行了。本节我们主要介绍用python实现数据结构。</p> 
<p>对于数据结构，我们将采用以下的思路进行学习：</p> 
<blockquote> 
 <p>一、定义对象、节点<br>     1.线性结构：<br>             数组、链表、队列、栈<br>     2.非线性结构：<br>             树、堆、图<br> 二、实现节点之间的互联<br>             在节点属性中增加指针<br> 三、对象由某一节点处开始的遍历<br>     1.线性结构<br>             1）单向遍历<br>             2）双向遍历<br>     2.非线性结构<br>             1）DFS（深度优先搜索）<br>             2）BFS（广度优先搜索）<br> 四、基本操作方法<br>     1.增加节点<br>     2.返回节点数量<br>     3.由遍历结果构建对象</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%89" rel="nofollow">一、线性数据结构（一对一）</a></p> 
<p id="1.%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#1.%E6%95%B0%E7%BB%84" rel="nofollow">1.数组</a></p> 
<p id="1%EF%BC%89%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1" rel="nofollow">1）构造一个数组对象</a></p> 
<p id="2%EF%BC%89%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%BF%A1%E6%81%AF" rel="nofollow">2）查找数组信息</a></p> 
<p id="3%EF%BC%89%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C" rel="nofollow">3）删除操作</a></p> 
<p id="4%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C" rel="nofollow">4）添加操作</a></p> 
<p id="5%EF%BC%89%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#5%EF%BC%89%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C" rel="nofollow">5）转换操作</a></p> 
<p id="6%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#6%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C" rel="nofollow">6）文件操作</a></p> 
<p id="7)%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#7%29%E6%8E%92%E5%BA%8F" rel="nofollow">7)排序</a></p> 
<p id="2.%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.%E9%93%BE%E8%A1%A8" rel="nofollow">2.链表</a></p> 
<p id="1%EF%BC%89%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow">1）单向链表</a></p> 
<p id="2%EF%BC%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow">2）双向链表</a></p> 
<p id="3%EF%BC%89%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">3）双向循环链表</a></p> 
<p id="3.%E9%98%9F%E5%88%97%EF%BC%88queue%E6%A8%A1%E5%9D%97%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.%E9%98%9F%E5%88%97%EF%BC%88queue%E6%A8%A1%E5%9D%97%EF%BC%89" rel="nofollow">3.队列（queue模块）</a></p> 
<p id="%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9A%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9A%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%89" rel="nofollow">队列方法：（适用于所有的队列）</a></p> 
<p id="1%EF%BC%89FIFO%E5%85%88%E5%85%A5%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97--Queue-toc" style="margin-left:80px;"><a href="#1%EF%BC%89FIFO%E5%85%88%E5%85%A5%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97--Queue" rel="nofollow">1）FIFO先入先出队列--Queue</a></p> 
<p id="2%EF%BC%89LIFO%E5%90%8E%E5%85%A5%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97%EF%BC%88%E6%A0%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#2%EF%BC%89LIFO%E5%90%8E%E5%85%A5%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97%EF%BC%88%E6%A0%88%EF%BC%89" rel="nofollow">2）LIFO后入先出队列（栈）</a></p> 
<p id="3%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">3）优先级队列</a></p> 
<p id="4%EF%BC%89%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97" rel="nofollow">4）双端队列</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">二、非线性数据结构</a></p> 
<p id="1.%E6%A0%91%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.%E6%A0%91%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89" rel="nofollow">1.树（一对多）</a></p> 
<p id="1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">1）二叉树</a></p> 
<p id="%E8%81%94%E5%8A%A8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97--%E5%A0%86-toc" style="margin-left:80px;"><a href="#%E8%81%94%E5%8A%A8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97--%E5%A0%86" rel="nofollow">联动：二叉树与优先级队列--堆</a></p> 
<p id="2%EF%BC%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E6%A0%91" rel="nofollow">2）树</a></p> 
<p id="3%EF%BC%89%E6%A3%AE%E6%9E%97-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E6%A3%AE%E6%9E%97" rel="nofollow">3）森林</a></p> 
<p id="2.%E5%9B%BE%EF%BC%88%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.%E5%9B%BE%EF%BC%88%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89" rel="nofollow">2.图（多对多）</a></p> 
<p id="1%EF%BC%89%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">1）图的分类</a></p> 
<p id="2%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2）图的实现</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-toc" style="margin-left:80px;"><a href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5" rel="nofollow">邻接矩阵</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E9%82%BB%E6%8E%A5%E8%A1%A8" rel="nofollow">邻接表</a></p> 
<p id="%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8" rel="nofollow">十字链表</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8" rel="nofollow">邻接多重表</a></p> 
<p id="3%EF%BC%89%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95" rel="nofollow">3）图的算法</a></p> 
<p id="%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#%E9%81%8D%E5%8E%86" rel="nofollow">遍历</a></p> 
<p id="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-toc" style="margin-left:80px;"><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91" rel="nofollow">最小生成树</a></p> 
<p id="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-toc" style="margin-left:80px;"><a href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" rel="nofollow">最短路径</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%89">一、线性数据结构（一对一）</h2> 
<h3 id="1.%E6%95%B0%E7%BB%84">1.数组</h3> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="164" src="https://images2.imgbox.com/74/61/PkpBxIge_o.jpg" width="376"> 
  <figcaption>
    数组 
  </figcaption> 
 </figure> 
</div> 
<p> </p> 
<p>python使用其内置的模块array实现数组，python的数组就和C语言一样精简而高效。</p> 
<h4 id="1%EF%BC%89%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1">1）构造一个数组对象</h4> 
<pre><code class="language-python">array.array(typecode[, initializer])
# 例：构造一个空的int类型数组
arr = array('i')
arr = array('i', [0, 1, 2, 3, 4, 6, 7, 8, 9, 100])</code></pre> 
<p>由于python没有对于变量声明的要求，所以在创建数组时需要一个类型代码字符标识该数组的数据类型，这样数组才能像C语言里的数组一样操作。</p> 
<figure class="image"> 
 <img alt="" src="https://images2.imgbox.com/8b/e8/zgLEyrsJ_o.png"> 
 <figcaption>
   python中数组的类型代码字符 
 </figcaption> 
</figure> 
<p></p> 
<h4 id="2%EF%BC%89%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%BF%A1%E6%81%AF">2）查找数组信息</h4> 
<pre><code>array.typecode用于创建数组的类型代码字符。
array.typecodes包含所有可用类型代码的字符串。即'bBuhHiIlLqQfd'
array.itemsize内部表示中一个数组项的字节长度。
array.index(x)方法返回x 在数组中第一次出现的下标, 下标从零开始,如果没有找到该元素会报异常.
array.buffer_info() 返回一个表示当前数组存储信息的元组(address, length)
array.count(x)返回 x 在数组中出现的次数,没有该元素则返回0</code></pre> 
<h4 id="3%EF%BC%89%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">3）删除操作</h4> 
<pre><code>array.remove(element)  
    element 是要删除的元素, 该方法会删除第一次出现的元素, 如果有多次出现, 不会删除。
    如果删除的元素的不在 array 中, 则会抛异常 
array.pop()  
    删除元素,默认删除下标-1 的元素, 也可以指定删除的位置,并返回被删除的元素</code></pre> 
<h4 id="4%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C">4）添加操作</h4> 
<pre><code>array.insert (i,v)  
    i 是索引位置, v 是插入的元素
array.append(x) 
    默认从末尾追加元素, 在数组尾部添加元素x
array.extend(可迭代对象)
    通过一个可迭代对象添加元素
array.fromlist (list)
    从一个列表中添加元素到数组</code></pre> 
<h4 id="5%EF%BC%89%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C">5）转换操作</h4> 
<pre><code>array.tolist() 
    把array对象转换成list 
array.frombytes(s)  
    把bytes转换成array对象  
array.tobytes()  
    把array对象转换成bytes</code></pre> 
<h4 id="6%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">6）文件操作</h4> 
<pre><code>array.fromfile(f, n)
    从f中读取n个元素, 如果n&gt; file中的个数,会报异常.
array.tofile(f)
    把array对象写到文件f中. </code></pre> 
<h4 id="7)%E6%8E%92%E5%BA%8F">7)排序</h4> 
<pre><code>array.sorted()排序数组，参数同可迭代对象里的sorted()
array.reverse()反转数组</code></pre> 
<p>由以上的操作方法可知，python中的数组不仅可以像C语言中的数组一样进行操作，还支持像python中的可迭代对象一样的操作，以及一些其他的方法。</p> 
<p>但是数组只能存储相同类型的数据，而列表可以存储不同类型的数据。而数组的存储效率和访问速度要快于列表。因此读者要根据实际情况适当选择。</p> 
<h3 id="2.%E9%93%BE%E8%A1%A8">2.链表</h3> 
<p>链表在python中使用类（相当于C中的结构）实现链表，实现方法也同C语言一样，但是python中没有指针的概念，于是就采用嵌套的方式，将一个实例赋给指针域，效果就同指针一样。但是同C一样，这样的做法，需要实例化对象起指针的作用，这样会降低数据的存储密度。</p> 
<h4 id="1%EF%BC%89%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">1）单向链表</h4> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/f3/af/rekNGv42_o.jpg"> 
  <figcaption>
    单向链表 
  </figcaption> 
 </figure> 
</div> 
<p> </p> 
<pre><code class="language-python">#定义结点：
#数据域：item  存储节点上的信息
#指针域：next  存储下一个节点的变量信息（可以理解为C里面的指针）
class node():
    def __init__(self,item):
        self.item=item
        self.next=None


#定义单链表
class SingleLinkedList():
    def __init__(self):
        self.head=None #存储头结点（指向第一个节点）

    def add(self,item):#向链表头部中加入元素item
        t=node(item)       
        t.next=self.head
        self.head=t

    def append(self,item):#向链表尾部中加入元素item
        t=node(item)
        if self.head==None:
            self.head=t
        else:
            m=self.head
            while m.next:
                m=m.next
            m.next=t

    def insert(self,index,item):#向链表索引为index处中加入元素item
        if index==0:
            self.add(item)
        elif index&gt;=self.size():
            self.append(item)
        else:
            t=node(item)
            c=self.head
            i=0
            while i&lt;index-1:
                c=c.next
                i+=1
            t.next=c.next
            c.next=t

    def delete(self,item):#删除链表中的元素item
        m=self.head
        if m==None:
            return
        elif m.item==item:
            self.head=m.next
            del m
        else:
            while m.next.item!=item:
                m=m.next
            m.next=m.next.next

    def pop(self):#删除链表尾部的元素
        if self.head==None:
            return
        else:
            m=self.head
            while m.next.next:
                m=m.next
            r=m.next.item
            del m.next
            m.next=None
            return r

    def isempty(self):#判断链表是否为空
        return self.head==None

    def size(self):#返回链表的元素数量
        s=0
        t=self.head
        while t:
            t=t.next
            s+=1
        return s

    def printall(self):#遍历链表所有的元素
        t=self.head
        while t:
            print(t.item,end=" ")#遍历操作：打印该元素
            t=t.next</code></pre> 
<h4 id="2%EF%BC%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">2）双向链表</h4> 
<p>由于单向链表只能访问当前节点的下一个节点，于是引出双向链表，便于访问上一个节点。同样，这样会增加实例化对象，进一步降低存储密度。</p> 
<p><img alt="" src="https://images2.imgbox.com/91/dd/zuUsxeMX_o.jpg"></p> 
<pre><code class="language-python">#定义节点：
class node():
    def __init__(self,item):
        self.item=item#数据域
        self.next=None#指针域：指向下一个节点
        self.prev=None#指针域：指向上一个节点

#定义双向链表
class DLinkList():
    def __init__(self):
        self.head=None#头结点

    def size(self):#返回链表中元素数量
        s=0
        m=self.head
        while m.next:
            s+=1
            m=m.next
        return s

    def isempty(self):#判断链表是否为空
        return self.head==None

    def append(self,item):#在链表尾部添加元素item
        t=node(item)
        m=self.head
        if m==None:
            self.head=t
            return
        else:
            while m.next:
                m=m.next
            m.next=t
            t.prev=m

    def add(self,item):#在链表头部添加元素item
        t=node(item)
        m=self.head
        if m==None:
            self.head=t
            return
        else:
            t.next=m
            m.prev=t
            self.head=t

    def insert(self,index,item):#在链表索引index处添加元素item
        t=node(item)
        m=self.head
        if m==None:
            self.head=t
            return
        elif index+1&gt;self.size():
            self.append(item)
        else:
            i=0
            while i&lt;index:
                m=m.next
                i+=1
            t.next=m
            t.prev=m.prev
            if i==0:
                m.prev=t
                self.head=t
            else:
                m.prev.next=t
                m.prev=t

    def pop(self):#删除链表尾部的元素
        m=self.head
        if m==None:
            return
        while m.next.next:
            m=m.next
        r=m.next
        m.next=None
        return r.item

    def delete(self,item):#删除链表中的item元素
        m=self.head
        if m==None:
            return
        elif m.next==None:
            self.head=None
        else:
            while m.item!=item:
                m=m.next
            if m.next==None:
                m.prev.next=None
            elif m.prev==None:
                self.head=m.next
            else:
                m.next.prev=m.prev
                m.prev.next=m.next
                del m

    def find(self,item):#查找链表中item的索引位置
        m=self.head
        s=0
        while m:
            if m.item==item:
                s+=1
            m=m.next
        return s

    def printall(self):#遍历所有节点
        m=self.head
        while m:
            print(m.item,end=" ")#遍历操作：打印
            m=m.next</code></pre> 
<h4 id="3%EF%BC%89%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">3）双向循环链表</h4> 
<p>上面的双向链表同样也只能从头到尾的或者从尾到头的访问，这样会增加访问的时间复杂度。为了提高访问效率，设置双向循环链表，存储密度同双向链表一样，但是会增加函数定义时的麻烦。</p> 
<p>双向循环链表的实现基本同双向链表一样，不同的是双向循环链表的头结点需要和尾节点相连，这样才能达到循环的作用。（部分方法在实现时，可以利用循环的特点简化操作）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/83/QgyjIajf_o.jpg"> </p> 
<pre><code class="language-python">#定义节点：同双向链表
class node():
    def __init__(self,item):
        self.item=item
        self.prev=None
        self.next=None
#定义双向循环链表（除局部方法改进外，大部分同双向链表一样）
class doublelist():
    def __init__(self):
        self.head=None
    def size(self):
        s=0
        m=self.head
        if m:
            s+=1
            m=m.next
            while m!=self.head:
                s+=1
                m=m.next
        return s
    def isempty(self):
        return self.head==None
    def append(self,item):
        t=node(item)
        m=self.head
        if m==None:
            m=t
            m.next=m
            m.prev=m
            self.head=m
            return
        else:
            r=m.prev
            r.next=t
            t.prev=r
            t.next=self.head
            self.head.prev=t
    def add(self,item):
        t=node(item)
        m=self.head
        if m==None:
            m=t
            m.next=m
            m.prev=m
            self.head=m
            return
        else:
            t.next=m
            t.prev=m.prev
            m.prev.next=t
            m.prev=t
            self.head=t
    def insert(self,index,item):
        t=node(item)
        m=self.head
        if m==None:
            m=t
            m.next=m
            m.prev=m
            self.head=m
            return
        elif index+1&gt;self.size():
            self.append(item)
        elif index==0:
            self.add(item)
        else:
            i=0
            while i&lt;index:
                m=m.next
                i+=1
            t.next=m
            t.prev=m.prev
            m.prev.next=t
            m.prev=t
    def pop(self):
        m=self.head
        if m==None:
            return
        else:
            s=m.prev.item
            r=m.prev.prev
            r.next=m
            m.prev=r
            return s
    def delete(self,item):
        m=self.head
        if m==None:
            return
        else:
            while m.item!=item:
                m=m.next
            r=m.prev
            r.next=m.next
            m.next.prev=r
    def find(self,item):
        m=self.head
        s=0
        if m.item==item:
            s+=1
        m=m.next
        while m!=self.head:
            if m.item==item:
                s+=1
            m=m.next
        return s
    def printall(self):
        m=self.head
        if m==None:
            print(None)
        else:
            print(m.item,end=" ")
            m=m.next
            while m!=self.head:
                print(m.item,end=" ")
                m=m.next</code></pre> 
<blockquote> 
 <p>在实现了数组和链表后，我们需要知道在实现数据结构时有顺序存储和链式存储。</p> 
 <p>顺序存储：在C里面用数组实现，所有数据项都是按照内存空间顺序存储的。在python里面一般可以用列表实现。</p> 
 <p>链式存储：用链表的形式存储数据。</p> 
</blockquote> 
<h3 id="3.%E9%98%9F%E5%88%97%EF%BC%88queue%E6%A8%A1%E5%9D%97%EF%BC%89">3.队列（queue模块）</h3> 
<p>python在实现队列时，一般使用其内置的库queue。当然也可以使用自定义数组或者链表实现，但是对于python我们说过，但凡能使用内置方法就使用内置方法，一是方便，二是快，三是功能完善。</p> 
<h4 id="%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9A%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%89">队列方法：（适用于所有的队列）</h4> 
<pre><code>.qsize()：返回队列的大致大小。
    注意，qsize() &gt; 0 不保证后续的 get() 不被阻塞，qsize()&lt;maxsize也不保证put()不被阻塞。
.empty()
    如果队列为空，返回 True ，否则返回 False 。
    如果 empty() 返回 True ，不保证后续调用的 put() 不被阻塞。类似的，如果 empty() 返回 False ，也不保证后续调用的 get() 不被阻塞。
.full()
    如果队列是满的返回 True ，否则返回 False 。
    如果 full() 返回 True 不保证后续调用的 get() 不被阻塞。类似的，如果 full() 返回 False 也不保证后续调用的 put() 不被阻塞。

.put(item, block=True, timeout=None)：将 item 放入队列。
    如果可选参数 block 是 true 并且 timeout 是 None (默认)，则在必要时阻塞至有空闲插槽可用。
    如果 timeout 是个正数，将最多阻塞 timeout 秒，如果在这段时间没有可用的空闲插槽，将引发 Full 异常。
    反之 (block 是 false)，如果空闲插槽立即可用，则把 item 放入队列，否则引发 Full 异常 ( 在这种情况下，timeout 将被忽略)。

.put_nowait(item)：相当于 put(item, False) 。

.get(block=True, timeout=None)：从队列中移除并返回一个项目。
    如果可选参数 block 是 true 并且 timeout 是 None (默认值)，则在必要时阻塞至项目可得到。
    如果 timeout 是个正数，将最多阻塞 timeout 秒，如果在这段时间内项目不能得到，将引发 Empty 异常。
    反之 (block 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 Empty 异常 (这种情况下，timeout 将被忽略)。
.get_nowait()：相当于 get(False) 。
    提供了两个方法，用于支持跟踪排队的任务是否被守护的消费者线程完整的处理。
.task_done()：表示前面排队的任务已经被完成。被队列的消费者线程使用。
    每个 get() 被用于获取一个任务， 后续调用 task_done() 告诉队列，该任务的处理已经完成。
    如果 join() 当前正在阻塞，在所有条目都被处理后，将解除阻塞
    (意味着每个 put() 进队列的条目的 task_done() 都被收到)。
    如果被调用的次数多于放入队列中的项目数量，将引发 ValueError 异常 。
.join()：阻塞至队列中所有的元素都被接收和处理完毕。
    当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者线程调用 task_done() 表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， join() 阻塞被解除。</code></pre> 
<h4 id="1%EF%BC%89FIFO%E5%85%88%E5%85%A5%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97--Queue">1）FIFO先入先出队列--Queue</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/42/43/uxQEtbNL_o.jpg"> </p> 
<p>这是最基本的队列，先输入的元素会先输出。</p> 
<pre><code class="language-python">#创建队列对象
q = Queue(maxsize=0)#maxsize设置队列中数据上限，小于或等于0则不限制，容器中大于这个数则阻塞，直到队列中的数据被消掉
#写入队列数据
for i in range(3):
    q.put(i)
#输出当前队列所有数据
print(type(q.queue),q.queue) 
#队列弹出下一元素
cur = q.get()</code></pre> 
<h4 id="2%EF%BC%89LIFO%E5%90%8E%E5%85%A5%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97%EF%BC%88%E6%A0%88%EF%BC%89">2）LIFO后入先出队列（栈）</h4> 
<p>后入先出队列，后输入的元素会先输出。</p> 
<p>这里的后入先出队列，就是栈。（以下的后入先出队列就先用栈代表）</p> 
<blockquote> 
 <p>栈，添加移除新项总发生在同一端。这一端通常称为“顶部”。与顶部对应的端称为“底部”。</p> 
</blockquote> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="189" src="https://images2.imgbox.com/d9/d2/Bl9PAMzD_o.jpg" width="377"> 
  <figcaption>
    栈 
  </figcaption> 
 </figure> 
</div> 
<p> </p> 
<p>我们先给出栈的queue模块实现：</p> 
<pre><code class="language-python">#创建后入先出队列对象
lq = LifoQueue(maxsize=0)
#队列写入数据
for i in range(3):
    lq.put(i)
#输出队列所有数据
print(type(lq.queue),lq.queue)   
#队列弹出下一元素
cur = lq.get()
 </code></pre> 
<p>当然，栈也可以通过顺序存储或者链式存储实现，由于栈的重要性，我们这里把这两种也实现一下。</p> 
<p>顺序存储（列表实现）：</p> 
<pre><code class="language-python">class Stack:
     def __init__(self):#列表实现栈
         self.items = []
     def isEmpty(self):#判断栈是否为空
         return self.items == []
     def push(self, item):#将item入栈
         self.items.append(item)
     def pop(self):#出栈一次
         return self.items.pop()
     def peek(self):#返回栈顶元素
         return self.items[len(self.items)-1]
     def size(self):#返回栈的大小
         return len(self.items)</code></pre> 
<p>链式存储（链表实现）：</p> 
<pre><code class="language-python">#定义节点
class note():
    def __init__(self,item):
        self.item=item#数据域
        self.next=None#指针域
#定义栈
class stack():
    def __init__(self):
        self.head=None#头结点

    def isempty(self):#判断栈是否为空
        return self.head==None

    def push(self,item):#item入栈
        m=note(item)
        c=self.head
        m.next=c
        self.head=m

    def pop(self):#出栈一次
        c=self.head
        data=c.item
        self.head=c.next
        del c
        return data

    def peek(self):#返回栈顶元素
        return self.head.item

    def size(self):#返回栈的大小
        c=self.head
        s=0
        while c:
            c=c.next
            s+=1
        return s

    def printall(self):#遍历栈中元素
        c=self.head
        while c:
            print(c.item,end=" ")#遍历操作：打印
            c=c.next</code></pre> 
<h4 id="3%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">3）优先级队列</h4> 
<p>优先级队列作为一种特殊的队列，会给各数据设置优先级（决定入栈和出栈的顺序）</p> 
<pre><code class="language-python">#创建优先级队列对象
pq = PriorityQueue(maxsize=0)
#写入队列(优先级会按输入对象的第一个元素排序)
pq.put((9,'a'))
pq.put((7,'c'))
pq.put((1,'d'))
#输出队例全部数据
print(pq.queue)    #[(1, 'd'), (9, 'a'), (7, 'c')]
#队列弹出下一元素(按优先级)
pq.get()
</code></pre> 
<p>当然，通过堆（heapq库）也可以实现优先级队列，但是堆本质上还是一种完全二叉树。下面我们在树的部分会详细地解释堆。</p> 
<h4 id="4%EF%BC%89%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">4）双端队列</h4> 
<p>双端队列也是一种特殊的队列，其入队列和出队列可以在队列的两边同时进行，这样的队列更符合实际问题中一般的模型。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/48/82/JmPpho8M_o.jpg"> 
  <figcaption>
    双端队列 
  </figcaption> 
 </figure> 
</div> 
<p> </p> 
<pre><code class="language-python">#创建双端队列对象
dq = deque(['a','b'])
dq.append('c')#增加数据到队尾 
dq.appendleft('d')#增加数据到队左 

dq.pop()#移除队尾
dq.popleft()#移除队左</code></pre> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">二、非线性数据结构</h2> 
<p>上述的线性数据结构都是一对一类型的结构。但实际生活中往往用到最多的是一对多或者多对多的非线性数据结构。当然，顺序存储显然是不适用于非线性数据结构，所以接下来我们将使用链式存储结构实现非线性数据结构。</p> 
<h3 id="1.%E6%A0%91%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89">1.树（一对多）</h3> 
<p>直观地看，树是数据元素（在树中称为结点）按分支关系组织起来的结构，很像自然界中的树那样。</p> 
<blockquote> 
 <p>树的一些基础概念：<br> 节点的度：一个节点含有的子树的个数称为该节点的度；</p> 
 <p>树的度：一棵树中，最大的节点的度称为树的度；</p> 
 <p>叶节点或终端节点：度为零的节点；</p> 
 <p>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</p> 
 <p>树的高度或深度：树中节点的最大层次；</p> 
 <p>路径：对于一棵子树中的任意两个不同的结点，如果从一个结点出发，按层次自上而下沿着一个个树枝能到达另一结点，称它们之间存在着一条路径</p> 
</blockquote> 
<p>在树里面有一种特殊的树--二叉树，即每个节点最多含有两个子树的树。在数据结构占据着非常重要的地位。有些说法认为二叉树不属于树，但是这里我们暂且放到这里介绍二叉树。因为二叉树的实现，是普通的树以及森林实现的重要基础。</p> 
<h4 id="1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91">1）二叉树</h4> 
<blockquote> 
 <p>完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</p> 
</blockquote> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="198" src="https://images2.imgbox.com/b2/bf/yOfiRmGM_o.jpg" width="306"> 
  <figcaption>
    二叉树 
  </figcaption> 
 </figure> 
</div> 
<p>1.数学性质：<br> 1）在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）<br> 2）深度为k的二叉树至多有2^k - 1个结点（k&gt;0）<br> 3）对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;<br> 4）具有n个结点的完全二叉树的深度必为 log2(n+1)<br> 5）对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</p> 
<p><br> 2.遍历方法<br> 1）深度遍历：沿着树的深度遍历树的节点，尽可能深的搜索树的分支<br>     深度遍历有三种方式：<br>     （1）先序遍历的顺序为：根节点-&gt;左子树-&gt;右子树；<br>     （2）中序遍历为：左子树-&gt;根节点-&gt;右子树；<br>     （3）后序遍历是：左子树-&gt;右子树-&gt;根节点；<br>     其中的序指的是根节点相对于左右节点的遍历位置。<br> 2）广度遍历：从树的根层级开始一层一层的遍历，遍历完上一层再遍历下一层</p> 
<p><br> 3.由遍历构造二叉树（至少需要两组遍历）<br> 后序遍历的第一个字符就是根，因此只需在中序遍历中找到它，就知道左右子树的中序 和后序遍历了。</p> 
<p></p> 
<p>4.实现（链式存储）</p> 
<pre><code class="language-python">#定义树的结点
class node():
    def __init__(self,item,left=None,right=None):
        self.item=item#数据域
        self.left=left#左子树
        self.right=right#右子树
#定义树
class tree():
    def __init__(self,root=None):
        self.root=root

    #每加满一个节点，在其左节点下继续加
    def add(self,item):
        t=node(item)
        if self.root==None:
            self.root=t
            return
        q=[self.root]
        while q:
            c=q.pop()
            if c.left==None:
                c.left=t
                return
            elif c.right==None:
                c.right=t
                return
            else:
                q.append(c.right)
                q.append(c.left)

    #插入节点，order为插入位置，'L'为左子树，'R'为右子树
    def insert(self,root,item=None,order='L'):
        if root==None:
            root=node(item)
            return
        if order=='L':
            if root.left:
                if root.left.item:
                    return
                else:
                    root.left.item=item
            else:
                root.left=node(item)
        elif order=='R':
            if root.right:
                if root.right.item:
                    return
                else:
                    root.right.item=item
            else:
                root.right=node(item)
        else:
            raise ValueError("insert:order error")

    #深度遍历（递归实现）
    def preorder(self,root):#先序遍历
        if not root:
            print("",end="")
        else:
            print(root.item,end=" ")
            self.preorder(root.left)
            self.preorder(root.right)
        
    
    def inorder(self,root):#中序遍历
        if not root:
            print("",end="")
        else:
            self.inorder(root.left)
            print(root.item,end=" ")
            self.inorder(root.right)
        
   
    def postorder(self,root): #后序遍历
        if not root:
            print("",end="")
        else:
            self.postorder(root.left)
            self.postorder(root.right)
            print(root.item,end=" ")
            
    #广度遍历（队列实现）
    def broad(self,root):
        if not root:
            print("",end="")
        q=[root]
        while q:
            for i in range(len(q)):
                t=q.pop(0)
                print(t.item,end=" ")
                if t.left:
                    q.append(t.left)
                if t.right:
                    q.append(t.right)
        
        
    #根据中序遍历和后序遍历构造树，返回树根
    def con(self,mid,post,root):
        if mid==[]:
            return None
        else:
            r=post[-1]
            root=node(r)
            n=mid.index(r)
            leftmid=mid[:n]
            rightmid=mid[n+1:]
            leftpost=find(leftmid,post)
            rightpost=find(rightmid,post)
            root.left=self.con(leftmid,leftpost,root.left)
            root.right=self.con(rightmid,rightpost,root.right)
            return root
        
    #返回由路径元组构成的列表
    def path(self,root):
        def addpath(root,list1,s):
            if not root.left and not root.right:
                s+=(root.item,)
                list1.append(s)
            else:
                s+=(root.item,)
                if root.left:
                    addpath(root.left,list1,s)
                    
                if root.right:
                    addpath(root.right,list1,s)
                    
        list1=[]
        addpath(root,list1,())
        return list1        </code></pre> 
<p>也可以采用嵌套列表的方式实现二叉树，但形式较为复杂（数据项很少很少时可以使用），不建议使用。</p> 
<p>5.应用：</p> 
<ol><li>排序二叉树：用于二叉排序算法</li><li>最优二叉树（赫夫曼树）：用于解决编码问题</li><li>平衡二叉树：应用较广泛，此处不作介绍</li></ol> 
<h4 id="%E8%81%94%E5%8A%A8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97--%E5%A0%86">联动：二叉树与优先级队列--堆</h4> 
<p>堆（heap）是一种优先队列。本质上讲，它是一个完全二叉树，实现的时候不需要建造一个树，改用一个数组即可。若一个节点的索引为i，那么，父节点的索引为（i-1）//2，左孩子节点编号为i*2+1，右孩子节点为i*2+2。</p> 
<p>堆的特点：</p> 
<ol><li>内部数据是有序的</li><li>可以弹出堆顶的元素，大根堆就是弹出最大值，小根堆就是弹出最小值</li><li>每次加入新元素或者弹出堆顶元素后，调整堆使之重新有序，时间复杂度O(logn)</li></ol> 
<figure class="image left"> 
 <img alt="" height="182" src="https://images2.imgbox.com/46/c6/sanj2z3D_o.jpg" width="255"> 
 <figcaption>
   最小堆​ 
 </figcaption> 
</figure> 
<figure class="image"> 
 <img alt="" height="187" src="https://images2.imgbox.com/ca/a2/lYPXUjm6_o.jpg" width="277"> 
 <figcaption>
   最大堆 
 </figcaption> 
</figure> 
<p style="text-align:center;"> </p> 
<p>python实现堆时使用其内置的模块heapq</p> 
<p><strong>heapq模块</strong></p> 
<pre><code>heappush(heap, x)：将x压入堆heap中
    请注意，不能将它用于普通列表，而只能用于使用各种堆函数创建的列表，
    原因是元素的顺序很重要，元素的排列顺序并不像看起来那么随意。
    它们虽然不是严格排序的，但必须保证一点：
    位置i处的元素总是大于位置i // 2处的元素（反过来说就是小于位置2 * i和2 * i + 1处的元素）。
    这是底层堆算法的基础，称为堆特征（heap property）。
heappop(heap)：从堆heap中弹出最小的元素
    最小的元素总是位于索引0处，并确保剩余元素中最小的那个位于索引0处（保持堆特征）。
heapify()：让列表heap具备堆特征
    通过执行尽可能少的移位操作将列表变成合法的堆（即具备堆特征）。
    如果你的堆并不是使用heappush创建的，应在使用heappush和heappop之前使用这个函数。
heapreplace(heap, x)：弹出最小的元素，并将x压入堆中
    相比于依次执行函数heappop和heappush，这个函数的效率更高。
nlargest(n, iter)和nsmallest(n, iter)，:分别用于找出可迭代对象iter中最大和最小的n个元素。
    这种任务也可通过先排序（如使用函数sorted）再切片来完成，
    但堆算法的速度更快，使用的内存更少（而且使用起来也更容易）。</code></pre> 
<p>以上的方法都适用于最小堆，即双亲结点小于孩子节点。</p> 
<p>对于最大堆，即双亲结点大于孩子节点的情况，该模块保留了一些方法：</p> 
<pre><code>_heappop_max(heap)：相当于最小堆的heappop方法
_heapify_max(heap) ：相当于最小堆的heapify方法
_heapreplace_max(heap, x)：相当于最小堆的heapreplace方法
</code></pre> 
<p>注意：对于最大堆的操作没有_heappush_max方法<br> 当然，给数据加负号也可以实现最小堆到最大堆的转化</p> 
<h4 id="2%EF%BC%89%E6%A0%91">2）树</h4> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="208" src="https://images2.imgbox.com/a5/8c/RwI4INtK_o.jpg" width="336"> 
  <figcaption>
    树 
  </figcaption> 
 </figure> 
</div> 
<p> </p> 
<p>实现了二叉树之后，对于树的实现就很容易了。</p> 
<p><strong>实现方法1：孩子双亲表示法</strong></p> 
<pre><code class="language-python">class TreeNode():
    def __init__(self, name, parent=None):
        self.name = name#数据域
        self.parent = parent#双亲结点
        self.child = []#用列表存储所有的子节点</code></pre> 
<p>当然也可以使用单链表代替列表来存储子节点。</p> 
<p><strong>实现方法2：孩子兄弟表示法</strong></p> 
<pre><code class="language-python">class TreeNode():
    def __init__(self, name, child,bro):
        self.name = name#数据域
        self.child = child#第一个孩子结点
        self.bro = bro#第一个兄弟结点</code></pre> 
<p>由孩子兄弟表示法可以发现，树是以二叉树的形式实现的，接下来要说的森林也是一样的实现方法。</p> 
<h4 id="3%EF%BC%89%E6%A3%AE%E6%9E%97">3）森林</h4> 
<p>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林</p> 
<p>实现方法：孩子兄弟表示法</p> 
<p>树的孩子兄弟表示法里，如果根节点为空，则树就是森林。</p> 
<p>这里我们不能发现，二叉树、树、森林之间可以互相转换。</p> 
<h3 id="2.%E5%9B%BE%EF%BC%88%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89">2.图（多对多）</h3> 
<p>在推广一下树的话，就到了多对多的图了。图可以更好地拟合实际问题，但是也最为复杂。</p> 
<p></p> 
<blockquote> 
 <p>图的基本概念：</p> 
 <p id="">边（弧）：两个顶点之间<br> 路径:：通过边连接的顶点序列 <br> 周期：第一个和最后一个顶点相同的路径 <br> 入度:：顶点的度数V是以V为端点的边数 <br> 出度： 顶点的出度v是以v为起点的边的数量 <br> 度：顶点的度数是其入度和出度的总和</p> 
</blockquote> 
<h4 id="1%EF%BC%89%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB">1）图的分类</h4> 
<ol><li>无向图：两个顶点之间可以沿着边互相访问，双向连通。</li><li>有向图：两个顶点之间只能以弧的箭头方向进行访问，单向连通。</li></ol> 
<figure class="image left"> 
 <img alt="" height="134" src="https://images2.imgbox.com/1e/ab/pczcUK4M_o.jpg" width="173"> 
 <figcaption>
   无向图 
 </figcaption> 
</figure> 
<figure class="image"> 
 <img alt="" height="148" src="https://images2.imgbox.com/19/84/33HWlI3N_o.jpg" width="180"> 
 <figcaption>
   有向图 
 </figcaption> 
</figure> 
<blockquote> 
 <p>图的连通性：</p> 
 <p>对于无向图，其连通子图（连通分量）称为连通图</p> 
 <p>对于有向图，其连通子图（强连通分量）称为强连通图</p> 
 <p>若任意节点之间均连通，称为完全图。</p> 
</blockquote> 
<h4 id="2%EF%BC%89%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0">2）图的实现</h4> 
<p> 图的实现有四种方法：</p> 
<ol><li>邻接矩阵</li><li>邻接表</li><li>十字链表</li><li>邻接多重表</li></ol> 
<h4 id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">邻接矩阵</h4> 
<p>用具体的数值表示节点之间的关系，可以使用邻接矩阵，假设这个矩阵是A,Aij就表示第i个节点和第j个节点是否相连，为1表示相连，0表示不相连。当然，该数值也可以是边或者弧的权值。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="182" src="https://images2.imgbox.com/7b/8e/pdAZqA17_o.jpg" width="368"> 
  <figcaption>
    邻接矩阵 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<pre><code class="language-python">class graph:
    def __init__(self,vertex,directed=False):
        vertex=list(set(vertex))
        self.vertex=vertex #顶点列表
        self.num_edge=0 #边的数量
        self.directed=directed#是否有向图
        self.matrix=[[0 for i in range(len(vertex))]for i in range(len(vertex))]#邻接矩阵

    #以邻接矩阵遍历图
    def draw(self):
        print(' ',self.vertex)
        for i in range(len(self.matrix)):
            print(self.vertex[i],self.matrix[i]) 
         
    #加边（权值默认为1）
    def addedge(self,v,w,weight=1):
        if v in self.vertex  and w in self.vertex:
            i=self.vertex.index(v)
            j=self.vertex.index(w)
            self.matrix[i][j]=weight
            if self.directed==False:
                self.matrix[j][i]=weight
            self.num_edge+=1
        else:
            raise Exception("vertex not in the Graph")

    #为图加入节点
    def addvertex(self,v):
        if v in self.vertex:
            return
        self.vertex.append(v)
        for i in self.matrix:
            i.append(0)
        self.matrix.append([0]*len(self.vertex))</code></pre> 
<p> 注意：应当先加入节点，再加入边。</p> 
<p>缺点：浪费存储空间。</p> 
<p>优点：便于访问与遍历。</p> 
<p>适合表示稠密图。</p> 
<h4 id="%E9%82%BB%E6%8E%A5%E8%A1%A8">邻接表</h4> 
<p>对于邻接表来说，一行只代表和他相连的节点。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="152" src="https://images2.imgbox.com/ee/70/E16xWCci_o.jpg" width="370"> 
  <figcaption>
    邻接表 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<pre><code class="language-python">class vertex():
    def __init__(self,item):
        self.item=item
        self.connect={}
class graph():
    def __init__(self,v=[],directed=False):
        v=list(set(v))
        self.vertex={}
        self.directed=directed
        for i in v:
            self.vertex[i]=vertex(i)
    #画图
    def draw(self):
        for i in self.vertex.keys():
            print(i,end=':')
            for j,k in self.vertex[i].connect.items():
                print(j,'(',k,')',sep='',end=' ')
            print('')
    def addvertex(self,item):
        if not item in self.vertex:
            self.vertex[item]=vertex(item)
    def addedge(self,v,w,weight=1):
        if not v in self.vertex:
            self.addvertex(v)
        if not w in self.vertex:
            self.addvertex(w)
        self.vertex[v].connect[w]=weight
        if self.directed==False:
            self.vertex[w].connect[v]=weight
    #深度优先搜索
    def DFS(self,v):
        l=[]
        def f(v,l):
            if v in l:
                return
            print(v,end=' ')
            l.append(v)
            p=self.vertex[v].connect.keys()
            for i in p:
                f(i,l)
        f(v,l)
        print('')
    #广度优先搜索
    def BFS(self,v):
        q=[v]
        l=[v]
        while q!=[]:
            u=q.pop(0)
            print(u,end=' ')
            t=self.vertex[u].connect.keys()
            for i in t:
                if i in l:
                    continue
                l.append(i)
                q.append(i)</code></pre> 
<blockquote> 
 <p>这里我们不妨与二叉树的遍历作对比，发现深度遍历都是采用递归的方法，广度遍历都是采用队列的方式。其实，由此可以看出图可以用树表示出来，我们习惯上将图的极小连通子图称为生成树。</p> 
</blockquote> 
<h4 id="%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8">十字链表</h4> 
<p>十字链表适用于有向图，操作时也较为方便，但是结构较为复杂，整体的时间复杂度和邻接表一样。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/c5/ooM6rklH_o.jpg"></p> 
<blockquote> 
 <p> 十字链表的结点描述：</p> 
 <p>顶点结点：</p> 
 <ol><li>数据域</li><li>两个链域指示以该顶点为弧头、弧尾的第一个弧结点</li></ol> 
 <p>弧结点：</p> 
 <ol><li>数据域指示弧的信息</li><li>两个链域指向弧尾相同的下一条弧和弧头相同的下一条弧</li><li>尾域和头域指示弧头和弧尾这两个结点在图中的位置</li></ol> 
</blockquote> 
<pre><code class="language-python">#定义顶点
class vertex():
    def __inif__(self,data,firstin,firstout):
        self.data=data#数据域
        self.firstin=firstin#以该顶点为弧尾的第一个弧结点
        self.firstout=firstout#以该顶点为弧头的第一个弧结点

#定义弧
class edge():
    def __inif__(self,info,tailvex,headvex,hlink,tlink):
        self.info=info#数据域，一般表示弧的权值
        self.tailvex=tailvex#弧尾结点在图中（顶点链表）的位置
        self.headvex=headvex#弧头结点在图中（顶点链表）的位置
        self.hlink=hlink#弧头相同的下一条弧
        self.tlink=tlink#弧尾相同的下一条弧

#定义十字链表
class crossinglink():
    def __inif__(self):
        self.vertex=[]#顶点列表

    
</code></pre> 
<h4 id="%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8">邻接多重表</h4> 
<p>邻接多重表适用于无向图，但其结构同十字链表一样，唯一的不同是其顶点结点的链域只有第一天依附于该节点的边（显然无向图没有弧头弧尾一说，故只需要一条边）。</p> 
<p>由于与十字链表基本相同，这里不再赘述，读者可自行练习。</p> 
<h4 id="3%EF%BC%89%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95">3）图的算法</h4> 
<p>我们之前有说，算法不是python的特色，这里只是简单介绍一下图里面的基本算法的思路，具体实现可以参考C语言的《数据结构与算法》。</p> 
<h4 id="%E9%81%8D%E5%8E%86">遍历</h4> 
<p>1.深度优先搜索（DFS）--类似于树的先序遍历</p> 
<p>2.广度优先搜索（BFS）</p> 
<h4 id="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</h4> 
<p>1.Prim算法</p> 
<p>适用于求边稠密的图，时间复杂度O（n^2）</p> 
<ol><li>设置辅助数组记录并不断更新具有过程中到达不同顶点最小代价的边</li><li>从一个顶点开始，重复找代价最小的边，并不再考虑到达该边另一顶点，同时更新辅助数组</li></ol> 
<p>2.Kruskal算法</p> 
<p>时间复杂度O(e·loge)</p> 
<p>每个顶点先各成连通分量，再在所有边里选择代价最小的边，若该边的顶点落在不同的连通分量上，则选择该边</p> 
<h4 id="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">最短路径</h4> 
<p>1.Dijkstra算法（单源最短路径）</p> 
<p>时间复杂度O(n^2)</p> 
<ol><li>建立一维辅助数组存储起点到各结点的最短路径的长度</li><li>先将起点到各点路径存入辅助数组，然后循环找到辅助数组中路径的最小值，确定起点到该点的最短路径已找到，同时更新辅助数组</li></ol> 
<p>2.Floyd算法（多源最短路径）</p> 
<p>时间复杂度O(n^3)</p> 
<ol><li>建立二维辅助数组存储各结点到其他结点的最短路径的长度</li><li>先将各点之间路径存入辅助数组，再循环判断各个路径是否为最短路径：循环比较该路径与以其他结点为中间结点得到的路径大小，然后更新该路径值</li></ol> 
<hr> 
<p>以上便是python中数据结构的实现，可能有某些方面讲的有些问题或者不够详细，欢迎私信或者评论区提出您的意见。</p> 
<p>感谢您的阅读！！！</p> 
<p style="text-align:center;"><img alt="" class="left" height="199" src="https://images2.imgbox.com/29/b8/HTp5GjCY_o.jpg" width="204"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb0f4ffdb602ac72cfa95b33638fadd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一些常用的文章写作使用方法和技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21f1975cdab735c57b9c2462291ea67d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">金蝶部署项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>