<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统——虚拟内存和页面置换算法（一文详解操作系统的虚拟内存和页面置换算法） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统——虚拟内存和页面置换算法（一文详解操作系统的虚拟内存和页面置换算法）" />
<meta property="og:description" content="1、虚拟内存 答： 这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？ 正是因为虚拟内存的存在，通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。
虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。
2、内存管理的目的 答： 最主要的就是提高内存的利用率，所谓的提高内存利用率，就是尽可能的在内存中多存储进程，这就涉及到为进程分配内存空间了。分配的方式主要是有两种——连续分配和离散分配。
3、局部性原理 答：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。
局部性原理表现在以下两个方面： 时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 4、虚拟存储器 答：基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。
我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。
5、虚拟内存的技术实现 答：虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：
请求分页存储管理：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。请求分段存储管理：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？ 请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。 6、什么是页面置换算法 答：进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，其中选择调出页面的算法就称为页面置换算法。
好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。
7、为什么要使用页面置换算法 答：当进程运行时，要访问的页面不在内存，则出现缺页中断，需要把该页面调入内存，如果内存中没有空闲物理块，则需要进行页面置换．页面置换算法依据一定策略，把物理块中的某个页面置换出去，送到磁盘交换区，在空出的一个物理块中装入导致缺页中断的页面。
8、最佳置换算法 答：FIFO算法是基于队列实现的，不是堆栈类算法，即未来永远不会再使用的页面 or 未来最长时间不再被访问的页面。该算法保证了可以获得最低缺页率，但无法预知未来页面的使用情况，因此目前无法实现，但通常用来评价其他算法。
优点：可保证最低缺页率。缺点 置换的页面可以是很久以前使用过但现已不再使用的初始化模块；所置换的页面可能包含一个被大量使用的变量，它早就初始化了，但仍在不断使用。对页面的访问时间无法预知，故该算法无法实现。 9、先进先出（FIFO）页面置换算法 答：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。这种页面置换算法确保对于给定数量的帧会产生最低的可能的缺页错误率。
FIFO 和 OPT 算法的区别： 在于除了在时间上向后或向前看之外，FIFO算法使用的是页面调入内存的时间，OPT算法使用的是页面将来使用的时间。
优点： 实现简单缺点：往往与进程实际运行的规律不相符。有些页面，如存放全局变量、常用函数的页面，在整个进程的运行过程中将会被频繁访问。如果频繁将其换进换出，则会产生“抖动”现象，因此，这种算法在实际中应用很少。 10、最近最久未使用（LRU）算法 答：LRU 是堆栈类的算法，堆栈类算法不可能出现Belay异常。该算法以过去预测未来，选择之前最长时间未使用的页面置换。但是由于利用“过去”作为“未来”的近似这一做法并非完全可靠，因此有时会造成缺页率非常高，导致效率会非常低。
Belady现象的描述： 一个进程P要访问M个页，OS分配N(N&lt;M)个内存页面给进程P；对一个访问序列S，发生缺页次数为PE(S,N)。当N增大(且N小于M)时，PE(S, N)时而增大，时而减小。FIFO是最早出现的页置换算法之一。Belady现象的原因是FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的，因而FIFO并不是一个好的置换算法。
优点： 由于考虑程序访问的时间局部性，一般能有较好的性能。实际应用多。缺点： 实现需要较多的硬件支持，会增加硬件成本。 11、Clock 置换算法 答：Clock置换算法是一种LRU的近似算法。由于LRU算法需要较多的硬件支持，采用Clock算法只需相对较少的硬件支持。Clock也称之为最近未用算法NRU。
优点： 可减少磁盘的I/O操作数缺点： 实现该算法本身的开销将有所增加 11.1、执行过程 答：只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置1。在选择页面淘汰时，只需检查页的访问位，如果是0，就选择该页换出；若为1，则重新将它置为0，暂时不换出，而给该页第二次驻留内存的机会，再按照FIFO算法检查下一个页面。当检查到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首去检查第一个页面。由于该算法是循环地检查各页面的使用情况，故称为Clock算法。
11.2、改进型Clock置换算法： 答：由访问位A和修改位M可以组合成下面四种类型的页面：
1类（A=0, M=0）： 表示该页最近既未被访问， 又未被修改， 是最佳淘汰页。2类（A=0, M=1）： 表示该页最近未被访问， 但已被修改， 并不是很好的淘汰页。3类（A=1, M=0）： 最近已被访问， 但未被修改， 该页有可能再被访问。4类（A=1, M=1）： 最近已被访问且被修改， 该页可能再被访问。 12、最少使用置换算法 答：为每个页面配置一个计数器，一旦某页被访问，则将其计数器的值加1，在需要选择一页置换时，则将选择其计数器值最小的页面，即内存中访问次数最少的页面进行淘汰。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/24f792692b0582e50e3aa6035ac9ca39/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-14T09:22:29+08:00" />
<meta property="article:modified_time" content="2023-11-14T09:22:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统——虚拟内存和页面置换算法（一文详解操作系统的虚拟内存和页面置换算法）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1、虚拟内存</h2> 
<p><font color="red"><strong>答：</strong> </font>这个在我们平时使用电脑特别是 <code>Windows </code>系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？ 正是因为虚拟内存的存在，通过<strong>虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间</strong>。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它<strong>让每个进程产生了一种自己在独享主存的错觉</strong>（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p> 
<blockquote> 
 <p><strong>虚拟内存是计算机系统内存管理的一种技术</strong>，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 把内存扩展到硬盘空间。</p> 
</blockquote> 
<h2><a id="2_7"></a>2、内存管理的目的</h2> 
<p><font color="red"><strong>答：</strong></font> <strong>最主要的就是提高内存的利用率</strong>，所谓的提高内存利用率，就是尽可能的在内存中多存储进程，这就涉及到为进程分配内存空间了。<strong>分配的方式主要是有两种——连续分配和离散分配</strong>。</p> 
<h2><a id="3_13"></a>3、局部性原理</h2> 
<p><font color="red"><strong>答：</strong></font>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p> 
<h4><a id="_17"></a>局部性原理表现在以下两个方面：</h4> 
<ul><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ul> 
<h2><a id="4_24"></a>4、虚拟存储器</h2> 
<p><font color="red"><strong>答：</strong></font>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p> 
<blockquote> 
 <p>我觉得虚拟内存同样是一种时间换空间的策略，你用 <code>CPU</code> 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p> 
</blockquote> 
<h2><a id="5_32"></a>5、虚拟内存的技术实现</h2> 
<p><font color="red"><strong>答：</strong></font><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p> 
<ul><li><strong>请求分页存储管理</strong>：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong>：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ul> 
<h4><a id="_40"></a><strong>请求分页与分页存储管理，两者有何不同呢</strong>？</h4> 
<ul><li>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</li><li>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</li></ul> 
<h2><a id="6_47"></a>6、什么是页面置换算法</h2> 
<p><font color="red"><strong>答：</strong></font>进程运行时，若其<strong>访问的页面不在内存而需将其调入</strong>，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，<strong>送入磁盘的对换区</strong>，其中选择调出页面的算法就称为页面置换算法。</p> 
<blockquote> 
 <p>好的页面置换算法应有<strong>较低的页面更换频率</strong>，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。</p> 
</blockquote> 
<h2><a id="7_55"></a>7、为什么要使用页面置换算法</h2> 
<p><font color="red"><strong>答：</strong></font>当进程运行时，要访问的<strong>页面不在内存，则出现缺页中断</strong>，需要把该页面调入内存，如果内存中没有空闲物理块，则需要进行页面置换．页面置换算法依据一定策略，把物理块中的某个页面置换出去，送到磁盘交换区，在空出的一个物理块中装入导致缺页中断的页面。</p> 
<h2><a id="8_61"></a>8、最佳置换算法</h2> 
<p><font color="red"><strong>答：</strong></font><code>FIFO</code>算法是基于队列实现的，不是堆栈类算法，即<strong>未来永远不会再使用的页面 or 未来最长时间不再被访问的页面</strong>。该算法保证了可以获得最低缺页率，但无法预知未来页面的使用情况，因此目前无法实现，但<strong>通常用来评价其他算法</strong>。</p> 
<p><img src="https://images2.imgbox.com/8b/34/1xldFT84_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>优点</strong>：可保证最低缺页率。</li><li><strong>缺点</strong> 
  <ul><li>置换的页面可以是很久以前使用过但现已不再使用的初始化模块；所置换的页面可能包含一个被大量使用的变量，它早就初始化了，但仍在不断使用。</li><li>对页面的访问时间无法预知，故该算法无法实现。</li></ul> </li></ul> 
<h2><a id="9FIFO_76"></a>9、先进先出（FIFO）页面置换算法</h2> 
<p><font color="red"><strong>答：</strong></font>该算法总是<strong>淘汰最先进入内存的页面</strong>，即选择在内存中驻留时间最久的页面予以淘汰。这种页面置换算法确保对于给定数量的帧会产生最低的可能的缺页错误率。</p> 
<p><img src="https://images2.imgbox.com/18/51/hAf69U25_o.png" alt="在这里插入图片描述"></p> 
<p><strong><code>FIFO</code></strong> <strong>和</strong> <strong><code>OPT </code></strong> <strong>算法的区别：</strong> 在于除了在时间上向后或向前看之外，<code>FIFO</code>算法使用的是页面调入内存的时间，<code>OPT</code>算法使用的是页面将来使用的时间。</p> 
<ul><li><strong>优点：</strong> 实现简单</li><li><strong>缺点</strong>：往往与进程实际运行的规律不相符。有些页面，如存放全局变量、常用函数的页面，在整个进程的运行过程中将会被频繁访问。如果频繁将其换进换出，则会产生“抖动”现象，因此，这种算法在实际中应用很少。</li></ul> 
<h2><a id="10LRU_90"></a>10、最近最久未使用（<code>LRU</code>）算法</h2> 
<p><font color="red"><strong>答：</strong></font><strong><code>LRU</code></strong> <strong>是堆栈类的算法</strong>，堆栈类算法不可能出现<code>Belay</code>异常。该算法以过去预测未来，选择之前<strong>最长时间未使用的页面置换</strong>。但是由于利用“过去”作为“未来”的近似这一做法并非完全可靠，因此有时会造成缺页率非常高，导致效率会非常低。</p> 
<p><img src="https://images2.imgbox.com/c6/d7/QfZ6fUMv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>Belady现象的描述：</strong> 一个进程P要访问<code>M</code>个页，<code>OS</code>分配<code>N(N&lt;M)</code>个内存页面给进程<code>P</code>；对一个访问序列<code>S</code>，发生缺页次数为<code>PE(S,N)</code>。当N增大(且<code>N</code>小于<code>M</code>)时，<code>PE(S, N)</code>时而增大，时而减小。<code>FIFO</code>是最早出现的页置换算法之一。<code>Belady</code>现象的原因是<code>FIFO</code>算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的，因而<code>FIFO</code>并不是一个好的置换算法。</p> 
</blockquote> 
<ul><li><strong>优点：</strong> 由于考虑程序访问的时间局部性，一般能有较好的性能。实际应用多。</li><li><strong>缺点：</strong> 实现需要较多的硬件支持，会增加硬件成本。</li></ul> 
<h2><a id="11Clock__104"></a>11、<strong><code>Clock</code></strong> <strong>置换算法</strong></h2> 
<p><strong>答：</strong><code>Clock</code>置换算法是一种<code>LRU</code>的近似算法。由于<code>LRU</code>算法需要较多的硬件支持，采用<code>Clock</code>算法只需相对较少的硬件支持。<code>Clock</code>也称之为最近未用算法<code>NRU</code>。</p> 
<ul><li><strong>优点：</strong> 可减少磁盘的<code>I/O</code>操作数</li><li><strong>缺点：</strong> 实现该算法本身的开销将有所增加</li></ul> 
<h4><a id="111_111"></a>11.1、执行过程</h4> 
<p><font color="red"><strong>答：</strong></font>只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置<code>1</code>。在选择页面淘汰时，只需检查页的访问位，如果是<code>0</code>，就选择该页换出；若为<code>1</code>，则重新将它置为<code>0</code>，暂时不换出，而给该页第二次驻留内存的机会，再按照<code>FIFO</code>算法检查下一个页面。当检查到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首去检查第一个页面。由于该算法是循环地检查各页面的使用情况，故称为<code>Clock</code>算法。</p> 
<h4><a id="112Clock_115"></a>11.2、改进型Clock置换算法：</h4> 
<p><font color="red"><strong>答：</strong></font>由访问位A和修改位M可以组合成下面四种类型的页面：</p> 
<ul><li><strong>1类（<strong><strong><code>A=0</code></strong></strong>, <strong><strong><code>M=0</code></strong></strong>）：</strong> 表示该页最近既未被访问， 又未被修改， 是最佳淘汰页。</li><li><strong>2类（<strong><strong><code>A=0</code></strong></strong>, <strong><strong><code>M=1</code></strong></strong>）：</strong> 表示该页最近未被访问， 但已被修改， 并不是很好的淘汰页。</li><li><strong>3类（<strong><strong><code>A=1</code></strong></strong>, <strong><strong><code>M=0</code></strong></strong>）：</strong> 最近已被访问， 但未被修改， 该页有可能再被访问。</li><li><strong>4类（<strong><strong><code>A=1</code></strong></strong>, <strong><strong><code>M=1</code></strong></strong>）：</strong> 最近已被访问且被修改， 该页可能再被访问。</li></ul> 
<h2><a id="12_126"></a>12、<strong>最少使用置换算法</strong></h2> 
<p><font color="red"><strong>答：</strong></font>为每个页面配置一个计数器，一旦某页被访问，则将其计数器的值加1，在需要选择一页置换时，则将选择其计数器值最小的页面，即内存中访问次数最少的页面进行淘汰。</p> 
<h2><a id="13_132"></a>13、<strong>页面缓冲算法</strong></h2> 
<p><font color="red"><strong>答：</strong></font>规定将一个被淘汰的页放入两个链表中的一个，即如果页面未被修改，就将它直接放入空闲链表中；否则，便放入已经修改页面的链表中的一个。<strong>须注意的是，这时页面在内存中并不做物理上的移动，而只是将页表中的表项移到上述两个链表之一中。</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e2d6ee35703df6bdbc69c296578674f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jenkins Docker Swarm插件 配置的坑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b8755534c5143444cabd6d11dee5bdbb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统——死锁（一文详解死锁，死锁产生的原因和死锁的解决方案）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>