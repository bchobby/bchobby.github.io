<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ElasticSearch分析器解析(十四) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ElasticSearch分析器解析(十四)" />
<meta property="og:description" content="ES在文本字段的索引建立和搜索阶段都会用到分析器。分析器一般用在下面两个场景中：
创建或更新文档时（合称索引时），对相应的文本字段进行分词处理；查询文本字段时，对查询语句进行分词。 ES中的分析器有很多种，但是所有分析器的结构都遵循三段式原则，即字符过滤器、分词器和词语过滤器。其中，字符过滤器可以有0个或多个，分词器必须只有一个，词语过滤器可以有0个或多个。从整体上来讲，三个部分的数据流方向为字符过滤器→分词器→分词过滤器。如下所示为一个分析器的构成示例：
文本先以字符流的形式流经字符过滤器，在本例中，在本例中，由两个子字符过滤器组成一个字符过滤器组合。字符过滤器处理完字符后将结果传递给分词器，分词器对文本进行分词处理后将结果又传递给分词过滤器。在本例中，由两个子分词过滤器组成一个分词过滤器组合。最终，分析器输出分词后每个词的信息，至此，一个分析器的处理流程结束。
对于不同的分析器，上述三部分的工作内容是不同的，为了正确匹配，如果在数据写入时指定了某个分析器，那么在匹配查询时也需要设定相同的分析器对查询语句进行分析。
字符过滤器 字符过滤器是分析器处理文本数据的第一道工序，它接收原始的字符流，对原始字符流中的字符进行添加、删除或者转换操作，进而改变原始的字符流。
例如，原始数据中可能包含来自爬虫的结果，字符过滤器可以去除文本中的HTML标签，也可以将原始文本中的一些特殊字符进行转义，如把“＆”转换为and。
总而言之，字符过滤器就是对原始文本做一些粗加工的工作，为后续的分词做准备。
ES内置了一些字符过滤器，其中常用的字符过滤器及其功能如下表所示：
名称功能映射关系字符过滤器根据配置的映射关系替换字符HTML擦除过滤器去掉HTML元素正则表达式替换过滤器用正则表达式处理字符串 分词器 分词器在分析器中负责非常重要的一环工作——按照规则来切分词语。对于英文来说，简单的分词器通常是根据空格及标点符号进行切分。然而对于中文分词来说，字符之间往往没有空格，因此采用英文的切分规则是不可取的。中文分词有多种切分方案。不同的分词器采用的方案不同，处理后的结果也可能不同。分词器对文本进行切分后，需要保留词语与原始文本之间的对应关系，因此分词器还负责记录每个Token的位置，以及开始和结束的字符偏移量。
在ES中内置了一些分词器，其中常用的分词器及其功能如下表所示：
名称功能标准分词器对英文分词时，基于语法分词；对中文分词时，切分成单字字母分词器使用非字母的字符作为分词标记小写分词器功能上等同于字母分词器，并且把所有分词结果转换为小写形式空格分词器使用空格作为分词标记 分词过滤器 分词过滤器接收分词器的处理结果，并可以将切分好的词语进行加工和修改，进而对分词结果进行规范化、统一化和优化处理。例如，它可以将文本中的字母全部转换为小写形式，还可以删除停用词（如的、这、那等），还可以为某个分词增加同义词。
在ES中内置了一些分词过滤器，其中常用的分词过滤器及其功能如下表所示：
名称功能Lower Case过滤器将所有字母转换为小写形式Stop Token过滤器将停用词从分词结果中移除同义词分词过滤器为分词结果添加同义词 分析器的使用 ES提供了分析器的调用API，使用户可以方便地对比不同分析器的分析结果。另外，ES提供了一些开箱即用的内置分析器，这些分析器其实就是字符过滤器、分词器和分词过滤器的组合体，可以在索引建立时和搜索时指定使用这些分析器。当然，如果这些分析器不符合需求，用户还可以自定义分析器。
测试分析API 为了更好地理解分析器的运行结果，可以使用ES提供的分析API进行测试。在DSL中可以直接使用参数analyzer来指定分析器的名称进行测试，分析API的请求形式如下：
POST _analyze { &#34;analyzer&#34;: &#34;${analyzer_name}&#34;, //指定分析器名称 &#34;text&#34;:&#34;${analyzer_text}&#34;//待分析文本 } 以下示例使用standard分析器分析一段英文：
POST _analyze { &#34;analyzer&#34;: &#34;standard&#34;, &#34;text&#34;: &#34;the hotel is not clean&#34; } 上述文本的分析结果如下：
{ &#34;tokens&#34; : [ { &#34;token&#34; : &#34;the&#34;, &#34;start_offset&#34; : 0, &#34;end_offset&#34; : 3, &#34;type&#34; : &#34;&lt;ALPHANUM&gt;&#34;, &#34;position&#34; : 0 }, { &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/25bb42fafb90d919102eba2bc9274cb7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-23T21:30:00+08:00" />
<meta property="article:modified_time" content="2022-08-23T21:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ElasticSearch分析器解析(十四)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>ES在文本字段的索引建立和搜索阶段都会用到分析器。分析器一般用在下面两个场景中：</p> 
<ol><li>创建或更新文档时（合称索引时），对相应的文本字段进行分词处理；</li><li>查询文本字段时，对查询语句进行分词。</li></ol> 
<p>        ES中的分析器有很多种，但是所有分析器的结构都遵循三段式原则，即字符过滤器、分词器和词语过滤器。其中，字符过滤器可以有0个或多个，分词器必须只有一个，词语过滤器可以有0个或多个。从整体上来讲，三个部分的数据流方向为字符过滤器→分词器→分词过滤器。如下所示为一个分析器的构成示例：</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/48/52/46htZzwm_o.png" width="385"></p> 
<p>         文本先以字符流的形式流经字符过滤器，在本例中，在本例中，由两个子字符过滤器组成一个字符过滤器组合。字符过滤器处理完字符后将结果传递给分词器，分词器对文本进行分词处理后将结果又传递给分词过滤器。在本例中，由两个子分词过滤器组成一个分词过滤器组合。最终，分析器输出分词后每个词的信息，至此，一个分析器的处理流程结束。</p> 
<p>        对于不同的分析器，上述三部分的工作内容是不同的，为了正确匹配，如果在数据写入时指定了某个分析器，那么在匹配查询时也需要设定相同的分析器对查询语句进行分析。</p> 
<h4>字符过滤器</h4> 
<p>        字符过滤器是分析器处理文本数据的第一道工序，它接收原始的字符流，对原始字符流中的字符进行添加、删除或者转换操作，进而改变原始的字符流。</p> 
<p>        例如，原始数据中可能包含来自爬虫的结果，字符过滤器可以去除文本中的HTML标签，也可以将原始文本中的一些特殊字符进行转义，如把“＆”转换为and。</p> 
<p>        总而言之，字符过滤器就是对原始文本做一些粗加工的工作，为后续的分词做准备。</p> 
<p>ES内置了一些字符过滤器，其中常用的字符过滤器及其功能如下表所示：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>名称</td><td>功能</td></tr><tr><td>映射关系字符过滤器</td><td>根据配置的映射关系替换字符</td></tr><tr><td>HTML擦除过滤器</td><td>去掉HTML元素</td></tr><tr><td>正则表达式替换过滤器</td><td>用正则表达式处理字符串</td></tr></tbody></table> 
<h4>分词器</h4> 
<p>        分词器在分析器中负责非常重要的一环工作——按照规则来切分词语。对于英文来说，简单的分词器通常是根据空格及标点符号进行切分。然而对于中文分词来说，字符之间往往没有空格，因此采用英文的切分规则是不可取的。中文分词有多种切分方案。不同的分词器采用的方案不同，处理后的结果也可能不同。分词器对文本进行切分后，需要保留词语与原始文本之间的对应关系，因此分词器还负责记录每个Token的位置，以及开始和结束的字符偏移量。</p> 
<p>在ES中内置了一些分词器，其中常用的分词器及其功能如下表所示：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>名称</td><td>功能</td></tr><tr><td>标准分词器</td><td>对英文分词时，基于语法分词；对中文分词时，切分成单字</td></tr><tr><td>字母分词器</td><td>使用非字母的字符作为分词标记</td></tr><tr><td>小写分词器</td><td>功能上等同于字母分词器，并且把所有分词结果转换为小写形式</td></tr><tr><td>空格分词器</td><td>使用空格作为分词标记</td></tr></tbody></table> 
<h4>分词过滤器</h4> 
<p>        分词过滤器接收分词器的处理结果，并可以将切分好的词语进行加工和修改，进而对分词结果进行规范化、统一化和优化处理。例如，它可以将文本中的字母全部转换为小写形式，还可以删除停用词（如的、这、那等），还可以为某个分词增加同义词。</p> 
<p>在ES中内置了一些分词过滤器，其中常用的分词过滤器及其功能如下表所示：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>名称</td><td>功能</td></tr><tr><td>Lower Case过滤器</td><td>将所有字母转换为小写形式</td></tr><tr><td>Stop Token过滤器</td><td>将停用词从分词结果中移除</td></tr><tr><td>同义词分词过滤器</td><td>为分词结果添加同义词</td></tr></tbody></table> 
<h4>分析器的使用</h4> 
<p>        ES提供了分析器的调用API，使用户可以方便地对比不同分析器的分析结果。另外，ES提供了一些开箱即用的内置分析器，这些分析器其实就是字符过滤器、分词器和分词过滤器的组合体，可以在索引建立时和搜索时指定使用这些分析器。当然，如果这些分析器不符合需求，用户还可以自定义分析器。</p> 
<h4>测试分析API</h4> 
<p>为了更好地理解分析器的运行结果，可以使用ES提供的分析API进行测试。在DSL中可以直接使用参数analyzer来指定分析器的名称进行测试，分析API的请求形式如下：</p> 
<pre><code>POST _analyze
{
  "analyzer": "${analyzer_name}", //指定分析器名称
  "text":"${analyzer_text}"//待分析文本
}</code></pre> 
<p>以下示例使用standard分析器分析一段英文：</p> 
<pre><code>POST _analyze
{
  "analyzer": "standard",
  "text": "the hotel is not clean"
}</code></pre> 
<p>上述文本的分析结果如下：</p> 
<pre><code>{
  "tokens" : [
    {
      "token" : "the",
      "start_offset" : 0,
      "end_offset" : 3,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 0
    },
    {
      "token" : "hotel",
      "start_offset" : 4,
      "end_offset" : 9,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 1
    },
    {
      "token" : "is",
      "start_offset" : 10,
      "end_offset" : 12,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 2
    },
    {
      "token" : "not",
      "start_offset" : 13,
      "end_offset" : 16,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 3
    },
    {
      "token" : "clean",
      "start_offset" : 17,
      "end_offset" : 22,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 4
    }
  ]
}</code></pre> 
<p>根据以上结果可以看到，standard分析器对文本进行分析时，按照空格把上面的句子进行了分词。分析API返回信息的参数说明如下：</p> 
<ul><li>token：文本被切分为词语后的某个词语；</li><li>start_offset：该词在文本中的起始偏移位置；</li><li>end_offset：该词在文本中的结束偏移位置；</li><li>type：词性，各个分词器的值不一样；</li><li>position：分词位置，指明该词语在原文本中是第几个出现的。</li></ul> 
<p>start_offset和end_offset组合起来就是该词在原文本中占据的起始位置和结束位置。</p> 
<p>下面使用standard分析器分析一段中文文本:</p> 
<pre><code class="hljs">POST _analyze
{
  "analyzer": "standard",
  "text":"北京嘉怡假日旅馆"
}</code></pre> 
<p>分析结果如下：</p> 
<pre><code class="hljs">{
  "tokens" : [
    {
      "token" : "北",
      "start_offset" : 0,
      "end_offset" : 1,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 0
    },
    {
      "token" : "京",
      "start_offset" : 1,
      "end_offset" : 2,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 1
    },
    {
      "token" : "嘉",
      "start_offset" : 2,
      "end_offset" : 3,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 2
    },
    {
      "token" : "怡",
      "start_offset" : 3,
      "end_offset" : 4,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 3
    },
    {
      "token" : "假",
      "start_offset" : 4,
      "end_offset" : 5,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 4
    },
    {
      "token" : "日",
      "start_offset" : 5,
      "end_offset" : 6,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 5
    },
    {
      "token" : "旅",
      "start_offset" : 6,
      "end_offset" : 7,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 6
    },
    {
      "token" : "馆",
      "start_offset" : 7,
      "end_offset" : 8,
      "type" : "&lt;IDEOGRAPHIC&gt;",
      "position" : 7
    }
  ]
}</code></pre> 
<p>        使用standard分析器对中文进行分析时，由于中文没有空格，无法根据空格进行切分，因此只能按单字进行切分，并给出了每个单字的词性。</p> 
<p>        在中文里，两个单字的词性和每个单字的词性是不同的，因此使用standard分析器分析中文时给出的词性不具备参考价值，不仅如此，ES内置的其他分析器也不适合分析中文。</p> 
<p>        除了指定分析器进行请求分析外，用户还可以指定某个索引的字段，使用这个字段对应的分析器对目标文本进行分析。下面使用旅馆索引的title字段对应的分析器分析文本。</p> 
<pre><code class="hljs">POST /hotel/_analyze
{
  "field": "title",
  "text": "北京嘉怡假日旅馆"
}</code></pre> 
<p>另外，用户还可以在API中自定义分析器对文本进行分析。比如以下自定义的分析器，该分析器的分词器使用standard，分词过滤器使用Lower Case，其将分词后的结果转换为小写形式：</p> 
<pre><code class="hljs">GET _analyze
{
  "tokenizer": "standard", //标准分词器
  "filter": ["lowercase"], //分词过滤器
  "text":"This is a Test" //待分析文本
}</code></pre> 
<p>结果返回：</p> 
<pre><code class="hljs">{
  "tokens" : [
    {
      "token" : "this",
      "start_offset" : 0,
      "end_offset" : 4,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 0
    },
    {
      "token" : "is",
      "start_offset" : 5,
      "end_offset" : 7,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 1
    },
    {
      "token" : "a",
      "start_offset" : 8,
      "end_offset" : 9,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 2
    },
    {
      "token" : "test",
      "start_offset" : 10,
      "end_offset" : 14,
      "type" : "&lt;ALPHANUM&gt;",
      "position" : 3
    }
  ]
}</code></pre> 
<h4>内置分析器</h4> 
<p>        ES已经内置了一些分析器供用户使用，在默认情况下，一个索引的字段类型为text时，该字段在索引建立时和查询时的分析器是standard。standard分析器是由standard分词器、Lower Case分词过滤器和Stop Token分词过滤器构成的。   </p> 
<p>        standard分析器没有字符过滤器。除了standard分析器之外，ES还提供了simple分析器、language分析器、whitespace分析器及pattern分析器等，这些分析器的功能如下表：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>名称</td><td>功能</td></tr><tr><td>simple分析器</td><td>按非字母字符进行词语拆分，并将所有词语转换为小写</td></tr><tr><td>language分析器</td><td>语言分析器</td></tr><tr><td>whitespace分析器</td><td>按照空白字符拆分词语</td></tr><tr><td>pattern分析器</td><td>使用正则表达式将文本拆分为词语</td></tr></tbody></table> 
<p>    另外，用户也可以自定义分析器，并且可以在索引建立或搜索时指定自定义分析器。</p> 
<h4>索引时使用分析器</h4> 
<p>        文本字段在索引时需要使用分析器进行分析，ES默认使用的是standard分析器。如果需要指定分析器，一种方式是在索引的settings参数中设置当前索引的所有文本字段的分析器，另一种方式是在索引的mappings参数中设置当前字段的分析器。</p> 
<p>        以下示例在settings参数中指定在旅店索引的所有文本字段中使用simple分析器进行索引构建：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "analyzer": {
        "default":{
          "type":"simple"
        }
      }
    }
  },
  "mappings": {
    "properties": {
      ....
    }
  }
}</code></pre> 
<p>以下示例在mappings参数中指定在旅店索引的title字段中使用whitespace分析器进行索引构建。</p> 
<pre><code class="hljs">PUT /hotel
{
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "whitespace"
      }
    }
  }
}</code></pre> 
<h4>搜索时使用分析器</h4> 
<p>为了搜索时更加协调，在默认情况下，ES对文本进行搜索时使用的分析器和索引时使用的分析器保持一致。当然，用户也可以在mappings参数中指定字段在搜索时使用的分析器。如下示例展示了这种用法：</p> 
<pre><code class="hljs">PUT /hotel
{
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "whitespace",
        "search_analyzer": "whitespace"
      }
    }
  }
}</code></pre> 
<p>注意，这里指定的搜索分析器和索引时的分析器是一致的，但是在大多数情况下是没有必要指定的，因为在默认情况下二者就是一致的。如果指定的搜索分析器和索引时的分析器不一致，则ES在搜索时可能出现有不符合预期的匹配情况，因此该设置在使用时需要慎重选择。</p> 
<h4>自定义分析器</h4> 
<p>        当系统内置的分析器不满足需求时，用户可以使用自定义分析器。在有些场景中，某个文本字段不是自然语言而是在某种规则下的编码。</p> 
<p>        例如，在旅馆索引中有个sup_env字段，其值为“APP,H5,WX”，表示当前旅馆可以在App、Web端和微信小程序端上显示。假设当前搜索用户使用的是H5或App客户端，则需要过滤掉不支持在这两个客户端上显示的旅馆。</p> 
<p>        首先，需要在索引创建的DSL中定义分析器comma_analyzer，该分析器中只有一个分词组件，该分词组件使用逗号进行词语切分；然后在mappings中使用analyzer参数指定字段sup_env的分析器为定义好的comma_analyzer分析器。具体的DSL如下：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "analyzer": {
        "common_analyzer":{ //自定义解析器
          "tokenizer":"common_tokenizer"
        }
      },
      "tokenizer":{ //定义分词器
        "common_tokenizer":{
          "type":"pattern",
          "pattern":"," //制定切分分隔符
        }
      }
    }
  }, 
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "whitespace",
        "search_analyzer": "whitespace"
      },
      "sup_env":{
        "type": "text",
        "analyzer": "common_analyzer"
      }
    }
  }
}</code></pre> 
<p>下面向旅馆索引中插入几条数据：</p> 
<pre><code class="hljs">POST /_bulk
{"index":{"_index":"hotel","_id":"001"}}
{"title":"北京嘉怡假日旅馆","city":"北京","sup_env":"APP,H5","price":50.000}
{"index":{"_index":"hotel","_id":"002"}}
{"title":"北京欣欣旅馆","city":"北京","sup_env":"H5,WX","price":50.000}
{"index":{"_index":"hotel","_id":"003"}}
{"title":"北京旅馆","city":"北京","sup_env":"WX","price":50.000}</code></pre> 
<p>当前用户的客户端为H5或App，当搜索“北京”关键词时应该构建的DSL如下：</p> 
<pre><code class="hljs">GET /hotel/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "city": "北京"
          }
        },
        {
          "match": {
            "sup_env": "APP,H5"
          }
        }
      ]
    }
  }
}</code></pre> 
<p>运行上面的DSL后，ES返回的结果如下：</p> 
<pre><code class="hljs">{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : 1.6081687,
    "hits" : [
      {
        "_index" : "hotel",
        "_type" : "_doc",
        "_id" : "001",
        "_score" : 1.6081687,
        "_source" : {
          "title" : "北京嘉怡假日旅馆",
          "city" : "北京",
          "sup_env" : "APP,H5",
          "price" : 50.0
        }
      },
      {
        "_index" : "hotel",
        "_type" : "_doc",
        "_id" : "002",
        "_score" : 0.7015199,
        "_source" : {
          "title" : "北京欣欣旅馆",
          "city" : "北京",
          "sup_env" : "H5,WX",
          "price" : 50.0
        }
      }
    ]
  }
}</code></pre> 
<p>由上面的结果可以看到，索引中有3个文档，只有文档001和文档002对应的旅馆城市中包含“北京”且可以在H5或App客户端显示。使用自定义的分词器可以将以逗号分隔的字段进行分词后建立索引，从而在搜索时也使用逗号分隔符进行匹配搜索。</p> 
<h4>中文分析器</h4> 
<p>        搜索引擎分析器的最终结果都是以分词结果为单位进行输出的。分词工作是搜索引擎的基础性工作，分词结果的质量高低对后面的搜索结果匹配起着非常关键的作用。中文相对于英文等西方语言有独有的一些特点，ES内置的分析器一般很难适用于中文搜索，因此针对中文的ES分词器插件应运而生。</p> 
<p>        对于英文来说，一个文档很容易被切分成关键词的集合，因为除了标点符号外都是由空格把各个英文单词进行分隔的。例如I have a red car，用空格进行切分的结果为I/have/a/red/car。对于中文来说，一般由一个或多个字组合在一起形成一个词语，并且句子中没有词的界限。根据不同的使用场景，对于词语切分颗粒度的需求也是不一样的，请看如下示例。</p> 
<p>例句：我来到北京清华大学。</p> 
<p>分词结果1：我/来到/北京/清华/华大/大学/清华大学</p> 
<p>分词结果2：我/来到/北京/清华大学</p> 
<p>上面的两种分词方式都是正确的，它们可以应用在不同的场景中。</p> 
<p>中文分词根据实现原理和特点，分词的切分算法主要有两种，即基于词典的分词算法和基于统计的机器学习算法。</p> 
<p><strong>1、基于词典的分词算法</strong></p> 
<p>基于词典的分词算法是按照某种策略将提前准备好的词典和待匹配的字符串进行匹配，当匹配到词典中的某个词时，说明该词分词成功。该算法是匹配算法中最简单、速度最快的算法，其分词算法分为3种，即正向最大化匹配法、逆向最大化匹配法和双向最大化匹配法。</p> 
<p><strong>2、基于统计的机器学习算法</strong></p> 
<p>基于统计的机器学习算法的主要思想是事先构建一个语料库，该语料库中是标记好的分词形式的语料，然后统计每个词出现的频率或者词与词之间共现的频率等，基于统计结果给出某种语境下应该切分出某个词的先验概率。后续进行分词时，使用先验概率给出文本应该切分的结果。这类算法中代表的算法有HMM、CRF、深度学习等，比如结巴分词基于HMM算法、HanLP分词工具基于CRF算法等。</p> 
<p>当前，中文分词的难点主要有以下三方面：</p> 
<ul><li>分词标准：不同的分词器使用的分词标准不同，分词的结果也不同。例如，在分词的颗粒度方面，对“中华人民共和国”进行切分时，粗粒度的分词就是“中华人民共和国”，细粒度的分词可能是“中华”“人民”“共和国”。</li><li>分词歧义：使用分词器对文本进行切分，切分后的结果和原来的字面意义不同。例如，在“郑州天和服装厂”中，“天和”是厂名，是一个专有词，“和服”也是一个词，它们共用了“和”字。如果分词器不够精准，则很容易切分成“郑州、和服、服装、服装厂”，但是原文中并没有与“和服”有关的含义，因此这里就产生了歧义。</li><li>新词识别：新词也称未登录词，即该词没有在词典或者训练语料中出现过。在这种情况下，分词器很难识别出该词。目前，新词识别问题的解决依赖于人们对分词技术和中文结构的进一步认识。</li></ul> 
<p>ES通过安装插件的方式来支持第三方分析器。比较常用的第三方中文分析器是HanLP和IK分析器</p> 
<h4>IK分析器</h4> 
<p>IK分析器是一个开源的、基于Java语言开发的轻量级的中文分词工具包，它提供了多种语言的调用库。在ES中，IK分析器通过第三方插件的方式来使用，其代码托管到了GitHub上，项目地址为https://github.com/medcl/elasticsearch-analysis-ik。IK分析器实现了词典的冷更新和热更新，用户可以选择适合自己的方式进行词典的更新。</p> 
<p>ES中IK分析器的安装过程如下：</p> 
<ol><li>进入ES的plugins目录，然后新建目录，目录名称为ik-analysis。</li><li>进入ik-analysis目录，然后运行wget命令下载ES的IK分词插件，下载地址为https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.13.2/elasticsearch-analysis-ik7.13.2.zip。注意，插件版本要和当前的ES版本保持一致，否则可能会导致ES启动报错。</li><li>使用unzip命令对下载的插件文件进行解压缩</li><li>重新启动ES，观察其运行日志，当打印出类似loaded plugin[analysis-ik]的日志内容时，说明IK插件安装成功</li></ol> 
<p>IK分析器提供了两个子分析器，即ik_smart和ik_max_word，另外它还提供了两个和分析器同名的子分词器。安装完成后，可以使用这些分析器或分词器进行验证。</p> 
<p>下例使用ik_max_word分析器对待测试文本进行分析:</p> 
<pre><code class="hljs">POST _analyze
{
  "analyzer": "ik_max_word",
  "text": "北京嘉怡旅馆"
}</code></pre> 
<p>下例使用ik_smart分析器对待测试文本进行分析：</p> 
<pre><code class="hljs">POST _analyze
{
  "analyzer": "ik_smart",
  "text": "北京嘉怡假日旅馆"
}</code></pre> 
<p>从上述两个运行结果中可以看到，ik_max_word和ik_smart分析器的主要区别在于切分词语的粒度上，ik_smart的切分粒度比较粗，而ik_max_word将文本进行了最细粒度的拆分，甚至穷尽了各种可能的组合。</p> 
<p>        另外可以看到“嘉怡”这个词被切分成了“嘉”和“怡”，这个词没有在IK分析器的词典里，因此被切分成了两个单字，这需要为IK分析器添加词典来解决该问题。在IK分析器的安装目录下的config子目录中创建文件my.dict，在其中添加“嘉怡”即可。如果有更多的词语需要添加，则每个词语单独一行，添加示例如下所示：</p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/22/5b/ldQjRQvt_o.png" width="688"></p> 
<p>添加完成后修改IK分析器的配置文件，路径为config/IKAnalyzer.cfg.xml，将新建的字典文件加入ext_dict选项中，如下图所示：</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/9f/c9/QHPhdlHb_o.png" width="1098"> </p> 
<p>配置完成后重启ES，然后使用分析器分析上面的文本，此时“嘉怡”就可以被切分出来。此时可以使用ik_smart分析器进行验证。</p> 
<p>安装完毕后，也可以将IK分析器应用到索引的字段中。下面将ik_max_word分析器设置为旅馆索引中title字段的默认分析器。 </p> 
<pre><code class="hljs">PUT /hotel
{
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "ik_max_word"
      }
    }
  }
}</code></pre> 
<h4>HanLP分析器</h4> 
<p>        HanLP是由一系列模型与算法组成的Java工具包，它从中文分词开始，覆盖词性标注、命名实体识别、句法分析、文本分类等常用的NLP任务，提供了丰富的API，被广泛用于Lucene、Solr和ES等搜索平台。就分词算法来说，它支持最短路分词、N-最短路分词和CRF分词等分词算法。用户可以在ES中安装HanLP分析器插件进行使用。</p> 
<p>        HanLP分析器插件的安装比较简单，在ES的安装目录下执行bin/elasticsearch-plugin install${URL}命令即可，其中的URL是HanLP的安装文件链接。本书使用的ES版本为7.13.2，需要HanLP分析器也使用相同的版本，对应的链接地址为https://github.com/Kenn Falcon/elasticsearch-analysis-hanlp/releases/download/v7.13.2/elasticsearch-analysis-hanlp-7.10.2.zip，安装时可根据当前的版本进行选择。</p> 
<p>        HanLP分析器提供了众多的子分析器，如hanlp、hanlp_standard、hanlp_crf和hanlp_n_short等。下例使用hanlp_standard分析器对待测试文本进行分析。</p> 
<pre><code class="hljs">POST _analyze
{
  "analyzer": "hanlp_standard",
  "text":"北京嘉怡假日旅馆"
}</code></pre> 
<p>        HanLP分析器的分析结果和IK分析器的分析结果类似，而且“嘉怡”这个词也被切分成了“嘉”和“怡”。同样的，解决该问题也需要给HanLP分析器添加用户自定义词典。在${ES_HOME}/plugins/analysis-hanlp/data/dictionary/custom目录中新建字典文件my.dict，然后在该文件中添加需要的词语，当有多个词语需要添加时，每个词语单独一行。</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/6e/07/iv4qqaky_o.png" width="1112"></p> 
<p>       词语添加完成后修改${ES_HOME}config/analysis-hanlp/hanlp.properties配置文件，修改选项CustomDictionaryPath，在后面添加上面新建的字典文件即可，此处使用相对路径。</p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/a6/8b/0nrKsXUN_o.png" width="1200"></p> 
<p>配置完成后等待1min左右，然后再使用HanLP分析器分析上面的文本，“嘉怡”就可以被切分出来了。另外，如果继续在上面的词典文件中添加词语，HanLP分析器会在后台每隔一段时间（大约1min）对分词词典进行自动热更新。每轮更新完成之后，新添加的词语即可被用户使用。</p> 
<p>可以将HanLP分析器设置为索引字段的默认分析器，下例是将hanlp_standard分析器设置为旅馆索引中title字段的默认分析器。 </p> 
<pre><code class="hljs">PUT /hotel
{
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "hanlp_standard"
      }
    }
  }
}</code></pre> 
<h4> 同义词搜索</h4> 
<p>        在搜索场景中，同义词用来处理不同的查询词，有可能是表达相同搜索目标的场景。</p> 
<p>       例如，当用户的查询词为“带浴缸的旅馆”和“带浴池的旅馆”时，其实是想搜索有单独泡澡设施的旅馆。</p> 
<p>        例如，在电商搜索中，同义词更是应用广泛，如品牌同义词Adidas和“阿迪达斯”，产品同义词“投影仪”和“投影机”，修饰同义词“大码”和“大号”等。</p> 
<p>        用户在使用这些与同义词相关的关键词进行搜索时，搜索引擎返回的搜索结果应该是一致的。</p> 
<p>        用户还可以通过ES中的分析器来使用同义词，使用方式分为两种，一种是在建立索引时指定同义词并构建同义词的倒排索引，另一种是在搜索时指定字段的search_analyzer查询分析器使用同义词。  </p> 
<h4>建立索引时使用同义词   </h4> 
<p>在ES内置的分词过滤器中，有一种分词过滤器叫作synonyms，它是一种支持用户自定义同义词的分词过滤器。以下是使用IK分析器和synonyms分词过滤器一起定义索引的DSL：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "filter": {
        "ik_synonyms_filter":{ //定义过滤器
          "type":"synonyms",
          "synonyms":[ //定义近义词
            "北京,首都",
            "天津,天津卫",
            "假日,度假"
            ]
        }
      },
      "analyzer": { //自定义分析器
        "ik_analyzer_synonyms":{
          "tokenizer":"ik_max_word",//指定分词器
          "filter":[ //指定分词过滤
            "lowercase",
            "ik_synonyms_filter"
            ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "ik_analyzer_synonyms"
      }
    }
  }
}</code></pre> 
<h4>查询时使用同义词</h4> 
<p>在ES内置的分词过滤器中还有个分词过滤器叫作synonym_graph，它是一种支持查询时用户自定义同义词的分词过滤器。以下是使用IK分析器和synonym_graph分词过滤器一起定义索引的DSL：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "filter": {
        "ik_synonyms_graph_filter":{
          "type":"synonyms_graph",
           "synonyms":[ //定义近义词
            "北京,首都",
            "天津,天津卫",
            "假日,度假"
            ]
        }
      },
      "analyzer": {
        "ik_analyzer_synonyms_graph":{
          "tokenizer":"ik_max_word",//指定分词器
          "filter":[ //指定分词过滤
            "lowercase",
            "ik_synonyms_graph_filter"
            ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title":{
        "type":"text",
        "search_analyzer": "ik_analyzer_synonyms_graph"
      }
    }
  }
}</code></pre> 
<p>对比两种方式的结果可以看到，命中的结果集和索引时使用的同义词一致，但是结果的排序却不同。这是因为在索引时使用同义词会计算全部的同义词的TF/IDF值，在搜索时进行的相关性计算，是将同义词和其他词同等对待，也就是将其TF/IDF值计算在内。而在搜索时使用同义词，需要ES将同义词转换后再进行相关性计算。</p> 
<p>如果有更新同义词的需求，则只能使用查询时使用同义词的这种方式。首先需要先关闭当前索引：</p> 
<pre><code class="hljs">POST /hotel/_close</code></pre> 
<p>下面更改索引的settings信息，新添加一组近义词“番茄，西红柿”：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "filter": {
        "ik_synonyms_graph_filter":{
          "type":"synonyms_graph",
           "synonyms":[ //定义近义词
            "北京,首都",
            "天津,天津卫",
            "假日,度假",
            "番茄，西红柿"
            ]
        }
      },
      "analyzer": {
        "ik_analyzer_synonyms_graph":{
          "tokenizer":"ik_max_word",//指定分词器
          "filter":[ //指定分词过滤
            "lowercase",
            "ik_synonyms_graph_filter"
            ]
        }
      }
    }
  }
}</code></pre> 
<p>打开索引：</p> 
<pre><code class="hljs">POST /hotel/_open</code></pre> 
<p>如果同义词比较多，在settings中进行配置时将非常烦琐。ES支持用户将同义词放在文件中，文件的位置必须是在${ES_HOME}/config目录及其子目录下，注意该文件必须存在于ES集群中的每一个节点上。在${ES_HOME}/config目录下建立一个子目录mydict，然后在该目录下创建一个名称为synonyms.dict的文件,文件内容如下图所示：</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/16/38/G5FLukIR_o.png" width="496"></p> 
<p>然后在创建旅馆索引时，在settings中指定同义词文件及其路径，DSL如下：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "ik_synonyms_graph_filter":{
        "type":"synonym_graph",
        "synonyms_path":"mydict/synonyms.dict"
      },
      "analyzer": {
        "ik_analyzer_synonyms_graph":{
          "tokenizer":"ik_max_word",//指定分词器
          "filter":[ //指定分词过滤
            "lowercase",
            "ik_synonyms_graph_filter"
            ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_analyzer_synonyms_graph"
      }
    }
  }
}</code></pre> 
<p> 当同义词词典文件内容更新时，执行：</p> 
<pre><code class="hljs">POST /hotel/_reload_search_analyzers</code></pre> 
<p>执行上述请求后，同义词得到更新，后续就可以在查询中使用新添加的同义词了。</p> 
<h4>停用词</h4> 
<p>        停用词也叫停止词，是指文本在被分词之后的词语中包含的无搜索意义的词。什么叫作“无搜索意义”呢？假设文本为“这里的世界丰富多彩”，那么分词结果中的“这里”和“的”对于匹配这个文档来说意义不大，因为这两个词的使用频率非常高，并且没有太多独特的意义。在构建搜索引擎索引时，常常忽略这样的词，这样可以大大提升搜索效率。经常使用的中文和英文停用词可以在网站www.ranks.nl上提取，中文停用词地址为https://www.ranks.nl/stopwords/chinese-stopwords，英文停用词地址为https://www.ranks.nl/stopwords。</p> 
<h4>使用停用词过滤器</h4> 
<p>可以通过创建自定义分析器的方式使用停用词，方法是在分析器中指定停用词过滤器，在过滤器中可以指定若干个停用词。下面使用standard分词器和停用词过滤器组成一个自定义分析器进行索引定义DSL如下：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "filter": {
        "my_stop":{
          "type":"stop",
          "stopwords":[
              "我",
              "的",
              "这"
            ]
        }
      },
      "analyzer": {
        "standard_stop":{
          "tokenizer":"standard",
          "filter":["my_stop"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title":{
        "type": "text",
        "analyzer": "standard_stop"
      }
    }
  }
}</code></pre> 
<p>使用上述分析器进行文本分析，DSL如下：</p> 
<pre><code class="hljs">POST /hotel/_analyze
{
  "field": "title",
  "text": "我的旅馆"
}</code></pre> 
<p>通过运行结果可以看到，“我的旅馆”中的“我”和“的”已经被停用词过滤器过滤，只剩下“旅”和“馆”。但是“旅”的开始位置是2，“馆”的开始位置是3，说明分析结果中“我”和“的”的位置被保留了下来，这种特意保留停用词的方式有助于后续的模糊搜索。</p> 
<h4>内置分析器中使用停用词</h4> 
<p>standard这种常用的分析器都自带有停用词过滤器，只需要对其参数进行相应设置即可。以下示例中使用standard分析器并通过设置其stopwords属性进行停用词的设定：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_standard":{
          "type":"standard",
          "stopwords":["我","的","这"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title":{
        "type":"text",
        "analyzer": "my_standard"
      }
    }
  }
}</code></pre> 
<h4>IK分析器中使用停用词</h4> 
<p>在默认情况下，IK分析器的分词器只有英文停用词，没有中文停用词。如果想要添加中文停用词，需要通过自定义停用词文件的形式进行添加。在${ES_HOME}/plugins/ik-analysis/config目录下创建my_stopword.dict文件，并在其中添加中文停用词即可，如下图：</p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/0a/6b/0x1M0z3i_o.png" width="500"></p> 
<p>添加完停用词后保存文件并退出，然后修改${ES_HOME}/plugins/ik-analysis/config/IKAnalyzer.cfg.xml文件，设置配置项ext_stopwords的值为停用词词典的文件名称，如下图：</p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/00/d8/uc8lDSFl_o.png" width="1100"> 配置完成后重启ES，再使用下面DSL进行分析：</p> 
<pre><code class="hljs">POST _analyze
{
  "analyzer": "ik_max_word",
  "text": "最牛掰的一个旅馆"
}</code></pre> 
<h4> HanLP分析器中使用停用词</h4> 
<p>在默认情况下，HanLP分析器的停用词是不启用的，需要配置自定义分析器并设置其启用停用词，请看如下示例：</p> 
<pre><code class="hljs">PUT /hotel
{
  "settings": {
    "analysis": {
      "tokenizer": {
        "my_tokenizer":{
          "type":"hanlp_standard",
          "enable_stop_dictionary":true
        }
      },
      "analyzer": {
        "my_hanlp":{
          "tokenizer":"my_tokenizer"
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title":"type",
      "analyzer":"my_hanlp"
    }
  }
}</code></pre> 
<p>在上面的示例中，自定义分析器中的my_tokenizer分词器的enable_stop_dictionary属性被设置为true，表示当前分词器启用停用词。下面使用该分析器对待测文本进行分析，DSL如下：</p> 
<pre><code class="hljs">POST _analyze
{
  "analyzer": "ik_max_word",
  "text": "最牛掰的一个旅馆"
}</code></pre> 
<p>当然用户可以在HanLP分析器的停用词词典文件中添加停用词，文件位置为${ES_HOME}/plugins/analysis-hanlp/data/dictionary/stopwords.txt，在该文件中已经有一些HanLP分析器内置的停用词，在该文件末尾追加停用词“一个”即可，如下图：</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/50/d4/66VIU6W7_o.png" width="750"></p> 
<p> 将停用词添加到词典中后保存并退出，然后重启ES，再使用HanLP分析器分析上面的文本，“一个”就会被识别为停用词而过滤掉</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ebfe96dc305480bdde63555cb6cbf32/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2021-07-22</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/133e1dbcc02edfadf01f450f3fd80d78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">离散数学——范式（一）定义与求解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>