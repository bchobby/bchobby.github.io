<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>架构设计系列之基础：基础理论（一） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="架构设计系列之基础：基础理论（一）" />
<meta property="og:description" content="在软件开发和软件架构领域，深厚的理论基础是构建高质量、可维护、可扩展系统的关键，本部分内容将围绕这些基础理论展开。（本部分内容介绍第一部分：编程三范式、架构设计原则、软件设计七原则）
一、编程三范式 编程范式是程序设计的基本思想和方法，对于程序员来说，他是告诉我们在实际编码和设计的过程中不能做什么，而非可以做什么。了解和灵活运用编程范式，有助于构建更加清晰、灵活、可维护的代码。
1 、结构化编程（Structured programming） 是基于过程的一种编程范式，将问题分解为一系列的步骤，每个步骤都由一个过程或函数表示。强调程序的执行过程，是用于简单的任务和流程。
结构化编程是对程序控制权的直接转移进行了限制和规范。
优势 直观且易于理解和实现适用于线性、简单的任务 适用场景 独立脚本编写简单的操作和流程 2、面向对象编程（Object-oriented programming） 是一种以对象为基础的编程范式，将数据和操作封装在对象中，强调对象之间的交互和关系。
核心思想是通过抽象、继承、封装和多态等概念，提高代码的重用性和可维护性。
面向对象编程是对程序控制权的间接转移进行了限制和规范。
优势 模块化，提高代码的可维护性重用性高，减少重复代码 适用场景 复杂系统设计大规模团队协作 3、函数式编程（Funtional programming） 是一种以函数为基础的编程范式，将计算视为数据函数的求值过程。强调纯函数、不可变性和无副作用，通过组合函数来构建复杂的系统。
函数式编程是对程序中的赋值进行了限制和规范。
优势 副作用少，易于调试和测试并行计算友好 适用场景 数据处理和转换并行和分布式系统 了解并灵活运用这三个范式，有助于根据问题的性质选择最合适的编程方式，提高代码的质量和可维护性。在实际项目中，通常会综合运用多种范式，以充分发挥他们的优势。
4、编程范式与架构设计的关系 编程范式和架构设计是有着密切关系的：
结构化编程是在做各个模块设计和实现时的基础要求面向对象编程中比如多态是跨越架构边界的手段函数式编程是用来规范和限制数据存放位置与访问权限的手段 基于上面的分析，你会发现，这三点和架构设计中的功能性、组件独立性、数据管理是密切相关的。
二、架构设计原则 1 、 合适原则 架构设计应该全面考虑时间、人力、能力、效率、成本，选择当前最为合适的方案。
合适的方案并非简单化，而是在充分考虑投资回报率（ROI）的基础上，根据项目需求和实际情况进行权衡和决策。
在实现功能的前提下，追求高效率和降低成本是合适方案的关键。
2 、简单原则 简单原则强调在满足功能需求的前提下，追求简洁和可读性。
简单设计有助于提高研发效率、降低成本、减少错误率，并能够提高系统的可维护性和可扩展性。
核心思想是简单优于复杂。在实现功能的前提下，减少代码量和复杂性，避免过度设计带来的复杂度。
简单的设计更容易理解、测试和部署，同时也易于维护和扩展，减少未来的开发难度和成本。
3 、演化原则 演化原则是指导设计出能够适应未来变化的重要原则，要求技术人员具备前瞻性。
架构设计应该具备灵活性和可扩展性，以便在未来的开发过程中能轻松应对新功能的研发、适应新的需求和变化。
核心思想是演化强于一步到位。任何一个软件产品和系统都需要不断变化和演进，因此在设计过程中要避免过于复杂、难以维护和扩展的结构。
持续的演化有助于保持系统的健康状态，适应业务和技术的不断发展。
三、软件设计七原则 做好一个系统，要先从写出整洁和易维护的代码开始。如果代码质量不佳，那架构能起到的作用就不会太大，多好的架构也绷不住堆砌的烂代码。反之，如果架构设计的不太理想，代码写的再好其实也无太大用处。两者之间是相辅相成，互相成就的。
1 、SRP（Single responsibility Principle）单一职责原则 SRP 是一项简单易懂且重要的原则，但是在实际过程中往往最容易忽略的，它强调在应用中，一个类应该只有一个引起变化的原因，只有一个职责。
SRP 是基于康威定律的推导结论：软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构，每个软件模块都有且只有一个需要被改变的理由。
优点 降低类之间的耦合：将不同职责分解为不同的类，降低类之间的依赖关系，提高系统的灵活性和可维护性提升类的可维护性和可重用性：当一个类只有一个职责时，修改该职责不会影响到其他职责，使得类更加稳定，易于维护和重用简化设计过程：SRP 原则使得类的设计更加清晰，每个类都专注于解决一个问题，降低了设计的复杂性 示例代码 多职责的类设计
public class UserService { /*** 运营部员工绩效计算 */ public BigDecimal calculateKPIResultForOperation() { } /*** 商务员工绩效计算 */ public BigDecimal calculateKPIResultForBusiness() { } /*** 产品部员工绩效计算 */ public BigDecimal calculateKPIResultForProduct() { } /*** 技术部员工绩效计算 */ public BigDecimal calculateKPIResultForTechnology() { } } SRP 后的类设计" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/2af3fceaca7d55c648a19c568d7fb743/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T00:41:47+08:00" />
<meta property="article:modified_time" content="2023-12-13T00:41:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">架构设计系列之基础：基础理论（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p class="img-center"><img alt="" height="427" id="uf69624a4" src="https://images2.imgbox.com/93/05/IB8STaW9_o.jpg" width="1200"></p> 
<p>在软件开发和软件架构领域，深厚的理论基础是构建高质量、可维护、可扩展系统的关键，本部分内容将围绕这些基础理论展开。（本部分内容介绍第一部分：编程三范式、架构设计原则、软件设计七原则）</p> 
<h2 id="EDP6P">一、编程三范式</h2> 
<p id="uf6d17348">编程范式是程序设计的基本思想和方法，对于程序员来说，他是告诉我们在实际编码和设计的过程中不能做什么，而非可以做什么。了解和灵活运用编程范式，有助于构建更加清晰、灵活、可维护的代码。</p> 
<h4 id="j24JK">1 、结构化编程（Structured programming）</h4> 
<p id="u2515d0ae">是基于过程的一种编程范式，将问题分解为一系列的步骤，每个步骤都由一个过程或函数表示。强调程序的执行过程，是用于简单的任务和流程。</p> 
<p id="u086398a0">结构化编程是对程序控制权的直接转移进行了限制和规范。</p> 
<h6 id="Zq5od">优势</h6> 
<ul><li id="u7326f15b">直观且易于理解和实现</li><li id="u093c7798">适用于线性、简单的任务</li></ul> 
<h6 id="ClMY5">适用场景</h6> 
<ul><li id="u9805379f">独立脚本编写</li><li id="u3d0c704b">简单的操作和流程</li></ul> 
<h4 id="farXK">2、面向对象编程（Object-oriented programming）</h4> 
<p id="ue6dce670">是一种以对象为基础的编程范式，将数据和操作封装在对象中，强调对象之间的交互和关系。</p> 
<p id="u7d02f45d">核心思想是通过抽象、继承、封装和多态等概念，提高代码的重用性和可维护性。</p> 
<p id="uc2bb81cd">面向对象编程是对程序控制权的间接转移进行了限制和规范。</p> 
<h6 id="tNDFF">优势</h6> 
<ul><li id="ubedc9fb1">模块化，提高代码的可维护性</li><li id="u1c2aee86">重用性高，减少重复代码</li></ul> 
<h6 id="h15AQ">适用场景</h6> 
<ul><li id="ua1c14ce3">复杂系统设计</li><li id="uf8c19929">大规模团队协作</li></ul> 
<h4 id="cLRyy">3、函数式编程（Funtional programming）</h4> 
<p id="u9a249285">是一种以函数为基础的编程范式，将计算视为数据函数的求值过程。强调纯函数、不可变性和无副作用，通过组合函数来构建复杂的系统。</p> 
<p id="ubb929928">函数式编程是对程序中的赋值进行了限制和规范。</p> 
<h6 id="W38uT">优势</h6> 
<ul><li id="ud6fe8c34">副作用少，易于调试和测试</li><li id="u55396a02">并行计算友好</li></ul> 
<h6 id="QjW8J">适用场景</h6> 
<ul><li id="u528706a1">数据处理和转换</li><li id="ud6656afa">并行和分布式系统</li></ul> 
<p id="u9702ecd6">了解并灵活运用这三个范式，有助于根据问题的性质选择最合适的编程方式，提高代码的质量和可维护性。在实际项目中，通常会综合运用多种范式，以充分发挥他们的优势。</p> 
<h4 id="Y89Es">4、编程范式与架构设计的关系</h4> 
<p id="uded7f243">编程范式和架构设计是有着密切关系的：</p> 
<ul><li id="uef0f822c">结构化编程是在做各个模块设计和实现时的基础要求</li><li id="u5a9d7e3a">面向对象编程中比如多态是跨越架构边界的手段</li><li id="u205ed471">函数式编程是用来规范和限制数据存放位置与访问权限的手段</li></ul> 
<p id="ucb5f8f8b">基于上面的分析，你会发现，这三点和架构设计中的功能性、组件独立性、数据管理是密切相关的。</p> 
<h2 id="Z5Q3g">二、架构设计原则</h2> 
<h4 id="yBBxW">1 、 合适原则</h4> 
<p id="uac073c25">架构设计应该全面考虑时间、人力、能力、效率、成本，选择当前最为合适的方案。</p> 
<p id="u505c52bb">合适的方案并非简单化，而是在充分考虑投资回报率（ROI）的基础上，根据项目需求和实际情况进行权衡和决策。</p> 
<p id="u00e542ae">在实现功能的前提下，追求高效率和降低成本是合适方案的关键。</p> 
<h4 id="dg73W">2 、简单原则</h4> 
<p id="u3b53f973">简单原则强调在满足功能需求的前提下，追求简洁和可读性。</p> 
<p id="u78ebeb66">简单设计有助于提高研发效率、降低成本、减少错误率，并能够提高系统的可维护性和可扩展性。</p> 
<p id="ub4943c3e">核心思想是简单优于复杂。在实现功能的前提下，减少代码量和复杂性，避免过度设计带来的复杂度。</p> 
<p id="u4053346e">简单的设计更容易理解、测试和部署，同时也易于维护和扩展，减少未来的开发难度和成本。</p> 
<h4 id="Edu8x">3 、演化原则</h4> 
<p id="ua17a3529">演化原则是指导设计出能够适应未来变化的重要原则，要求技术人员具备前瞻性。</p> 
<p id="u06a0f8f9">架构设计应该具备灵活性和可扩展性，以便在未来的开发过程中能轻松应对新功能的研发、适应新的需求和变化。</p> 
<p id="udea5ed53">核心思想是演化强于一步到位。任何一个软件产品和系统都需要不断变化和演进，因此在设计过程中要避免过于复杂、难以维护和扩展的结构。</p> 
<p id="u4c58f86e">持续的演化有助于保持系统的健康状态，适应业务和技术的不断发展。</p> 
<h2 id="QYo8U">三、软件设计七原则</h2> 
<p id="u108ef95d">做好一个系统，要先从写出整洁和易维护的代码开始。如果代码质量不佳，那架构能起到的作用就不会太大，多好的架构也绷不住堆砌的烂代码。反之，如果架构设计的不太理想，代码写的再好其实也无太大用处。两者之间是相辅相成，互相成就的。</p> 
<h4 id="fKHh4">1 、SRP（Single responsibility Principle）单一职责原则</h4> 
<p id="uc48581e1">SRP 是一项简单易懂且重要的原则，但是在实际过程中往往最容易忽略的，它强调在应用中，一个类应该只有一个引起变化的原因，只有一个职责。</p> 
<p id="u387ea088">SRP 是基于康威定律的推导结论：软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构，每个软件模块都有且只有一个需要被改变的理由。</p> 
<h6 id="T7xa8">优点</h6> 
<ul><li id="u55c73fd7">降低类之间的耦合：将不同职责分解为不同的类，降低类之间的依赖关系，提高系统的灵活性和可维护性</li><li id="u68c03123">提升类的可维护性和可重用性：当一个类只有一个职责时，修改该职责不会影响到其他职责，使得类更加稳定，易于维护和重用</li><li id="ub291f0e9">简化设计过程：SRP 原则使得类的设计更加清晰，每个类都专注于解决一个问题，降低了设计的复杂性</li></ul> 
<h6 id="pSgd8">示例代码</h6> 
<p id="uc51c7662">多职责的类设计</p> 
<pre id="q1VmM"><code class="language-java">public class UserService {
    /*** 运营部员工绩效计算 */
    public BigDecimal calculateKPIResultForOperation() { }
    
    /*** 商务员工绩效计算 */
    public BigDecimal calculateKPIResultForBusiness() { }
    
    /*** 产品部员工绩效计算 */
    public BigDecimal calculateKPIResultForProduct() { }
    
    /*** 技术部员工绩效计算 */
    public BigDecimal calculateKPIResultForTechnology() { }
}</code></pre> 
<p id="u72e624ed">SRP 后的类设计</p> 
<pre id="iZxMJ"><code class="language-java">public interface UserService {
    public BigDecimal calculateKPIResult();
}

// 不同部门实现接口
public class OperationUserService implement UserService {}
public class BusinessUserService implement UserService {}
public class ProductUserService implement UserService {}
public class TechnologyUserService implement UserService {}
</code></pre> 
<h6 id="SZtT1">注意点</h6> 
<ul><li id="u230ec14f">拆分多职责类：如果一个类承担了多个职责，就一定要拆分为多个类，确保每个类只有一个职责</li><li id="ua8e2bfb2">识别变化原因：识别引起类变化的原因，然后职责分配到对应的类，确保每个类的变化原因是明确的</li><li id="u4ac56dee">避免过度设计：尽可能简单，避免过度设计和复杂性，SRP 的目标是简化设计，而不是增加不必要的结构</li></ul> 
<h4 id="Hdbje">2 、OCP（Open/Close Principle） 开闭原则</h4> 
<p id="u9e1666b4">OCP 的核心思想是通过扩展已有的代码，增加新的行为和功能，而不是修改已有的代码。</p> 
<h6 id="q95av">优点</h6> 
<ul><li id="ufd66d33d">提高代码的可维护性和可重用性：允许系统通过扩展已有的代码来应对新的需求，而不是修改已有的代码，降低引入错误的风险</li><li id="uf7ad4fd8">减少代码的耦合度：模块化的设计使得系统个部分之间的耦合度降低，一个模块的修改不会对其他模块产生影响</li><li id="u443a146e">提高系统的可扩展性和可升级性：新功能可以通过添加新的类或模块来实现，而不是修改已有的代码，使得系统更容易扩展和升级</li></ul> 
<h6 id="XC0Tm">示例代码</h6> 
<p id="ud20e06bd">无 OCP 的代码</p> 
<pre id="g5Ihp"><code class="language-java">public class Calculator {  
    public int add(int a, int b) {  
        return a + b;  
    }  
      
    public int subtract(int a, int b) {  
        return a - b;  
    }  
      
    public int multiply(int a, int b) {  
        return a * b;  
    }  
      
    public int divide(int a, int b) {  
        return a / b;  
    }  
}
</code></pre> 
<p id="ucf57a344">有 OCP 的代码</p> 
<pre id="ROkUF"><code class="language-java">public interface Operation {  
    int calculate(int a, int b);  
}  
  
public class AddOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a + b;  
    }  
}  
  
public class SubtractOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a - b;  
    }  
}  
  
public class MultiplyOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a * b;  
    }  
}  
  
public class DivideOperation implements Operation {  
    public int calculate(int a, int b) {  
        return a / b;  
    }  
}</code></pre> 
<h6 id="XR6wi">注意点</h6> 
<ul><li id="u810b1dbc">使用 OCP 原则：把实体设计成可扩展，通过新加类、模块或者函数来扩展功能和行为</li><li id="u430ded1e">抽象化已有代码：对已有代码进行抽象，将具体的实现细节封装，对外仅提供抽象的接口</li><li id="ua55da567">避免过度设计：OCP 原则的目标是简化设计而不是增加不必要的结构</li></ul> 
<h4 id="G0qcE">3 、LSP（Liskov Substitution Principle）里氏替换原则</h4> 
<p id="u6ed43b62">LSP 强调在软件中，子类必须能够替换其父类，即子类应该具有与父类相同的行为和功能，而不仅仅是继承父类的属性和方法。</p> 
<h6 id="sCzd5">优点</h6> 
<ul><li id="u3dda862a">提高代码的可读性和可维护性：子类与父类具有一致的行为和功能，使得代码更易于理解和维护</li><li id="u47751475">减少代码的冗余和复杂性：子类继承父类的方法和属性，可以避免重复编写相似的代码</li><li id="u69161fe7">提高系统的可扩展性和可升级性：新的子类可以无缝地替换父类，不会影响系统的其他部分</li></ul> 
<h6 id="PC3Cx">示例代码</h6> 
<p id="u0e1b20ce">无 LSP 代码</p> 
<pre id="icb5W"><code class="language-java">class Shape {  
    void draw() {  
        System.out.println("Drawing a shape");  
    }  
}  
  
class Circle extends Shape {  
    void draw() {  
        System.out.println("Drawing a circle");  
    }  
}</code></pre> 
<p id="u93a61266">有 LSP 代码</p> 
<pre id="AyEgq"><code class="language-java">interface Drawable {  
    void draw();  
}  
   
class Shape implements Drawable {  
    public void draw() {  
        System.out.println( "Drawing a shape");  
    }  
}  
  
class Circle extends Shape {  
    public void draw() {  
        System.out.println("Drawing a circle");  
    }  
} </code></pre> 
<h6 id="PLMWK">注意点</h6> 
<ul><li id="uc89909c1">子类具有一致的行为和功能：子类必须具有与父类相同的行为和功能，但不能改变父类的行为和功能</li><li id="ue6aed12e">抽象类定义抽象方法：抽象类应该定义抽象方法，具体方法在子类中实现</li><li id="uea633106">避免继承滥用：避免使用继承来共享行为，继承是用来实现多态行为的，而不是为了代码的重用。如果子类需要不同的功能和行为，那应该通过重写父类方法来实现</li></ul> 
<h4 id="t5fIb">4 、ISP（Interface Segregation Principle）接口隔离原则</h4> 
<p id="u71ee93a3">ISP 强调在应用中使用多个特定的接口，而不是一个单一的总接口，从而避免端侧就不需要被强制依赖他们不需要的接口。</p> 
<h6 id="INeCt">优点</h6> 
<ul><li id="u6ad07d5d">提高代码的可维护性和可重用性，特定接口提供特定服务，代码可以更加模块化和可定制化</li><li id="uf62770ef">减少端侧的复杂性，端侧只需要依赖实际使用的接口，避免对不相关接口的强制依赖</li><li id="u06d1b1ca">提高系统的可扩展性和可升级性，新的接口可以被添加而不会影响实际使用的接口，使得系统更容易扩展和升级</li></ul> 
<h6 id="FNLxS">示例代码</h6> 
<p id="udc6aad37">无 ISP 代码</p> 
<pre id="C8S6l"><code class="language-java">interface ShoppingCart {  
    void addItem(Product product, int quantity);  
    void removeItem(Product product);  
    void updateQuantity(Product product, int quantity);  
}  
  
class ShoppingCartImpl implements ShoppingCart {  
    private Map&lt;Product, Integer&gt; items = new HashMap&lt;&gt;();  
      
    @Override  
    public void addItem(Product product, int quantity) {  
        items.put(product, quantity);  
    }  
      
    @Override  
    public void removeItem(Product product) {  
        items.remove(product);  
    }  
      
    @Override  
    public void updateQuantity(Product product, int quantity) {  
        int currentQuantity = items.get(product);  
        items.put(product, currentQuantity + quantity);  
    }  
}</code></pre> 
<p id="u0690c7c5">有 ISP 代码</p> 
<pre id="rmBNx"><code class="language-java">interface AddToCart {  
    void addItem(Product product, int quantity);  
}  
  
interface RemoveFromCart {  
    void removeItem(Product product);  
}  
  
interface UpdateQuantity {  
    void updateQuantity(Product product, int quantity);  
}  
  
class ShoppingCartImpl implements AddToCart, RemoveFromCart, UpdateQuantity {  
    private Map&lt;Product, Integer&gt; items = new HashMap&lt;&gt;();  
      
    @Override  
    public void addItem(Product product, int quantity) {  
        items.put(product, quantity);  
    }  
      
    @Override  
    public void removeItem(Product product) {  
        items.remove(product);  
    }  
      
    @Override  
    public void updateQuantity(Product product, int quantity) {  
        int currentQuantity = items.get(product);  
        items.put(product, currentQuantity + quantity);  
    }  
}</code></pre> 
<h6 id="MKD1A">注意点</h6> 
<ul><li id="u2a6a68e4">接口定义尽可能小：每个接口提供有限的服务，方法尽可能少，不要妄想一个接口走遍天下</li><li id="ud1947bb8">分离不相关功能：如果接口中提供的功能不相关，需要将接口进行分离操作，形成独立接口，代码可更模块化和可定制化</li><li id="u67432662">避免使用过大的总接口：总接口应该根据需要提供适当的功能，而不是一刀切提供所有功能</li></ul> 
<h4 id="MKzKP">5 、DIP（Dependency Inversion Principle）依赖倒置原则</h4> 
<p id="u1ac5781b">DIP 强调在应用中，高层模块不应该依赖于底层模块，它们应该依赖于抽象。</p> 
<h6 id="a7gyD">优点</h6> 
<ul><li id="u8595a7a0">提高代码的可读性和可维护性：高层模块依赖于抽象，而不是具体实现，使得代码更灵活和易于理解</li><li id="u82bcb850">降低类之间的耦合度：依赖抽象不依赖具体实现，减少了高层模块和底层模块之间的直接依赖，提高了系统的灵活性</li><li id="u476d4a94">提高系统的可扩展性和可升级性：新的实现可以通过实现抽象来引入，不需要修改高层模块的代码</li></ul> 
<h6 id="nTm1r">示例代码</h6> 
<p id="ub9481703">无 DIP 代码</p> 
<pre id="lGDaC"><code class="language-java">class UserService {  
    private UserDao userDao;  
      
    public UserService(UserDao userDao) {  
        this.userDao = userDao;  
    }  
      
    public User getUserById(int userId) {  
        return userDao.getUserById(userId);  
    }  
}  
  
class UserDao {  
    public User getUserById(int userId) {  
        // 具体实现逻辑，如从数据库中获取用户信息  
        return new User(userId, "John Doe");  
    }  
}</code></pre> 
<p id="u306a4317">有 DIP 代码</p> 
<pre id="PmfYa"><code class="language-java">interface UserDataAccess {  
    User getUserById(int userId);  
}  
  
class UserDao implements UserDataAccess {  
    @Override  
    public User getUserById(int userId) {  
        // 具体实现逻辑，如从数据库中获取用户信息  
        return new User(userId, "John Doe");  
    }  
}  
  
class UserService {  
    private UserDataAccess userDataAccess;  
      
    public UserService(UserDataAccess userDataAccess) {  
        this.userDataAccess = userDataAccess;  
    }  
      
    public User getUserById(int userId) {  
        return userDataAccess.getUserById(userId);  
    }  
}</code></pre> 
<h6 id="tW0GO">注意点</h6> 
<ul><li id="ub2984211">通过接口或抽象类定义依赖关系：使用接口或抽象类来定义高层模块和底层模块之间的依赖关系</li><li id="u337406f1">避免直接依赖具体类：如果直接依赖具体类，一旦有修改，依赖元就要同步改动，影响和成本都较高</li><li id="u002e6fa2">使用依赖注入解耦：使用依赖注入来解耦类之间的依赖关系，通过注入抽象的实现来实现高层模块对底层模块的依赖</li></ul> 
<h4 id="VA0Uu">6 、CARP（Composition/Aggregation Reuse Principle）合成/聚合复用原则</h4> 
<p id="u84d5dd74">CARP 强调在应用设计过程中优先使用合成/聚合的关系，而不是继承的关系来实现复用。</p> 
<h6 id="cO8Hb">优点</h6> 
<ul><li id="u4affe464">更好地代码封装：通过使用合成/聚合，可以将对象的不同部分封装在不同的类中，更好地隐藏细节，提高代码的模块化和可维护性</li><li id="uf5d645f5">更灵活的代码结构：通过使用合成/聚合，可以更容易地改变对象的行为和结构，只需要修改相关的类，不需要修改整个继承体系</li><li id="u52418c7b">更好的可重用性：通过使用合成/聚合，可以根据需要组合不同的对象来实现代码的可重用性，且合成/聚合本身是一种松耦合，可以更便捷地组装新的对象类型</li><li id="uc70d6cc9">更好的可扩展性：通过使用合成/聚合，更便捷地添加新的功能和行为到应用中，这种灵活的关系，可以更容易适应新的需求和变化</li></ul> 
<h6 id="EQidT">示例代码</h6> 
<p id="u5a813a34">无 CARP 代码</p> 
<pre id="AdnuL"><code class="language-java">class Car {  
    private Engine engine;  
    private Transmission transmission;  
    private Wheel wheel;  
    private Door door;  
  
    public Car(Engine engine, Transmission transmission, Wheel wheel, Door door) {  
        this.engine = engine;  
        this.transmission = transmission;  
        this.wheel = wheel;  
        this.door = door;  
    }  
  
    public void start() {  
        engine.start();  
    }  
  
    public void shift(int gear) {  
        transmission.shift(gear);  
    }  
  
    public void turn(int degrees) {  
        wheel.turn(degrees);  
    }  
  
    public void open() {  
        door.open();  
    }  
}</code></pre> 
<p id="u04a83cf4">有 CARP 代码</p> 
<pre id="WtUpB"><code class="language-java">interface Engine {  
    void start();  
}  
interface Transmission {  
    void shift(int gear);  
}  
interface Wheel {  
    // 可以添加一些方法，例如 rotate() 和 brake() 等  
}  
interface Door {  
    void open();  
}  
class Car {  
    private Engine engine;  
    private Transmission transmission;  
    private Wheel wheel;  
    private Door door;  
  
    public Car(Engine engine, Transmission transmission, Wheel wheel, Door door) {  
        this.engine = engine;  
        this.transmission = transmission;  
        this.wheel = wheel;  
        this.door = door;  
    }  
}</code></pre> 
<h6 id="kIgzy">注意点</h6> 
<ul><li id="u5ad63127">封装变化：将变化的部分封装起来，使得变化对其他部分的影响最小</li><li id="u9f4dafbc">强调组合/聚合：首选使用组合/聚合关系，而不是直接继承关系，以提高灵活性和可维护性</li><li id="u5a685cd6">松耦合：合成/聚合是一种松耦合关系，允许系统更容易地适应变化</li></ul> 
<h4 id="ceZtc">7 、LoD（Law of Demeter）迪米特法则</h4> 
<p id="u6b2647c7">LoD 强调在应用中应该尽量减少对象之间的直接依赖关系，降低耦合度，提高可维护性和可重用性。</p> 
<p id="uaff03d23">核心思想是一个对象对其他对象保持最少的了解，并且只和那些和自己最有直接关系的对象进行交互。</p> 
<p id="ua41f2a51">一个对象只暴露必要的接口给其他对象，并且应该通过这些接口与其他对象进行交互。</p> 
<h6 id="Yb3Gd">优点</h6> 
<ul><li id="u03e01cc3">降低耦合度：减少对象之间的直接依赖关系，使得系统更容易扩展和维护</li><li id="u71c480de">提高可维护性：对象之间的松耦合关系使得修改一个对象的内部实现不会影响其他对象</li><li id="ua695ac50">提高可重用性：松耦合关系允许对象更容易地被独立重用在不同的上下文中</li></ul> 
<h6 id="jggoZ">示例代码</h6> 
<p id="u163b5128">无 LoD 代码</p> 
<pre id="qxHpc"><code class="language-java">class Account {  
    private User user;  
    private List&lt;Transaction&gt; transactions;  
  
    public Account(User user, List&lt;Transaction&gt; transactions) {  
        this.user = user;  
        this.transactions = transactions;  
    }  
  
    public double getBalance() {  
        double balance = 0.0;  
        for (Transaction transaction : transactions) {  
            balance += transaction.getAmount();  
        }  
        return balance;  
    }  
  
    public void debit(double amount) {  
        user.setBalance(user.getBalance() - amount);  
    }  
}</code></pre> 
<p id="u871c291d">有 LoD 代码</p> 
<pre id="JDoYb"><code class="language-java">interface UserService {  
    double getBalance(User user);  
}  
  
interface TransactionService {  
    void debit(User user, double amount);  
}  
  
class Account {  
    private UserService userService;  
    private TransactionService transactionService;  
  
    public Account(UserService userService, TransactionService transactionService) {  
        this.userService = userService;  
        this.transactionService = transactionService;  
    }  
  
    public double getBalance() {  
        return userService.getBalance(userService.getUser());  
    }  
  
    public void debit(double amount) {  
        transactionService.debit(userService.getUser(), amount);  
    }  
}</code></pre> 
<h6 id="k4cO7">注意点</h6> 
<ul><li id="u0577860f">定义接口：将对象的相关操作定义在接口中，而不是直接依赖于具体的实现</li><li id="u8a497a0f">通过接口交互：对象应该通过接口进行交互，而不是直接调用其他对象的方法</li><li id="u9eb58594">减少依赖关系：一个对象应该只与其直接的朋友发生交互，避免依赖过多的对象</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53d32edc1b63150a704889d164c91125/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最新科研成果：在钻石中存储多比特数据，实现25GB数据密度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bc7a9941ce99807e49f02bb58a44f7d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用Stable Diffusion Web UI API实现高级图像生成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>