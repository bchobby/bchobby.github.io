<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue" />
<meta property="og:description" content="笔记：vue基础 · 语雀
代码：vue基础阶段代码
官网：Vue.js(作者: 尤雨溪)
组件库 Vant2 Vant 2 - Mobile UI Components built on Vue
Vant 3 - Mobile UI Components built on Vue
elementui Element - The world&#39;s most popular Vue UI framework 一、Vue介绍 1、学习前的工具安装 插件名称作用 chrome插件
vue_devtools
可以检测网站是不是Vue开发，如果是图标会亮，如果不是图标是灰暗; 可以在开发阶段帮助我们调试数据；
安装方法：三点 → 更多工具 → 扩展程序 → 打开&#39;开发者模式&#39; → 将插件拖入其中(安装完成) → 工具栏中的&#39;扩展程序&#39;，将其固定 vscode插件
vetur
让vscode能够识别 .vue文件；
还提供了一些vue代码的格式化功能，以及一些简单的代码段；
vue 3 snippets
（选装）
提供更多的vue的代码段
2、Vue及其作用 概念：Vue是一套渐进式的JavaScript框架；
作用：开发快捷；
什么是框架？
内部做了高度封装，并提供了自己的一套语法和开发体系，用框架可能会改变原本的开发模式；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/2d8ec58babcec05d3fe8f712968de749/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-23T15:28:35+08:00" />
<meta property="article:modified_time" content="2022-05-23T15:28:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>笔记：<a href="https://www.yuque.com/zhezhi-zbti5/ef2guu/" rel="nofollow" title="vue基础 · 语雀">vue基础 · 语雀</a></p> 
<p>代码：<a href="https://gitee.com/xpzll/vue142" rel="nofollow" title="vue基础阶段代码">vue基础阶段代码</a></p> 
<p>官网：<a href="https://cn.vuejs.org/" rel="nofollow" title="Vue.js">Vue.js</a>(作者: 尤雨溪)</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td rowspan="2">组件库</td><td> <p>Vant2 </p> <p>      <a href="https://vant-contrib.gitee.io/vant/v2/#/zh-CN" rel="nofollow" title="Vant 2 - Mobile UI Components built on Vue">Vant 2 - Mobile UI Components built on Vue</a></p> <p>      <a href="https://vant-contrib.gitee.io/vant/#/zh-CN" rel="nofollow" title="Vant 3 - Mobile UI Components built on Vue">Vant 3 - Mobile UI Components built on Vue</a></p> </td></tr><tr><td>elementui  <a href="https://element.eleme.cn/#/zh-CN" rel="nofollow" title="Element - The world's most popular Vue UI framework">Element - The world's most popular Vue UI framework</a></td></tr></tbody></table> 
<h2>一、Vue介绍</h2> 
<h3>1、学习前的工具安装</h3> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td style="text-align:center;width:105px;"></td><td style="text-align:center;width:113px;"><strong>插件名称</strong></td><td style="text-align:center;width:461px;"><strong>作用</strong></td></tr><tr><td colspan="1" rowspan="2" style="width:105px;"> <p style="text-align:center;"><strong>chrome插件</strong></p> </td><td style="width:113px;"> <p>vue_devtools</p> </td><td style="width:461px;"> <p>可以检测网站是不是Vue开发，如果是图标会亮，如果不是图标是灰暗; </p> <p>可以在开发阶段帮助我们调试数据；</p> </td></tr><tr><td colspan="2" rowspan="1" style="width:574px;">安装方法：三点 → 更多工具 → 扩展程序 → 打开'开发者模式' → 将插件拖入其中(安装完成) → 工具栏中的'扩展程序'，将其固定</td></tr><tr><td colspan="1" rowspan="2" style="width:105px;"> <p style="text-align:center;"><strong>vscode插件</strong></p> </td><td style="width:113px;"> <p>vetur</p> </td><td style="width:461px;"> <p>让vscode能够识别 .vue文件；</p> <p>还提供了一些vue代码的格式化功能，以及一些简单的代码段；</p> </td></tr><tr><td style="width:113px;"> <p>vue 3  snippets</p> <p>（选装）</p> </td><td style="width:461px;"> <p>提供更多的vue的代码段</p> </td></tr></tbody></table> 
<h3>2、Vue及其作用</h3> 
<p><strong>概念：</strong>Vue是一套渐进式的JavaScript框架；</p> 
<p><strong>作用：</strong>开发快捷；</p> 
<p><strong>什么是框架？</strong></p> 
<p>内部做了高度封装，并提供了自己的一套语法和开发体系，用框架可能会改变原本的开发模式；</p> 
<h3>3、MVVM设计模式</h3> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/66/aa/VXZdN46P_o.png" width="586"></p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/0b/06/4smCiXOR_o.png" width="1085"></p> 
<h2>二、Vue的使用方法</h2> 
<h3>1、举例</h3> 
<pre><code class="language-javascript">&lt;body&gt;
    &lt;div class="box"&gt;
        &lt;p&gt;shy&lt;/p&gt;
3. 插值语法, 将数据放入页面中
        &lt;p&gt;{<!-- -->{msg}}&lt;/p&gt;
    &lt;/div&gt;

1. 引入vue.js文件
    &lt;script src="./vue-2.6.12.js"&gt;&lt;/script&gt;
    &lt;script&gt;
2. 实例化Vue对象
        new Vue({
      2.1 把.box的元素交给vue来管理,可以传任意的css选择器 
          或 new Vue 最后加上 .$mount('.box')
            el: '.box',
      2.2 data是vue里放数据的地方，html中这样写，vue文件中的data是函数
            data: {
                属性名: 属性值,
                msg: '中国',
            }
      2.3 methods是vue里放方法的地方
            methods: {
                函数名() {函数体},
            },
      2.4 过滤器
            filters: { 
                过滤器名字 (原数据) {
                    代码对数据进行操作
                    return 新结果
                },
            },
      2.5 计算属性
            computed: {      
                计算属性名 () {                // 函数的写法
                    经过一系列计算，得到结果
                    return 结果
                }
            },
      2.6 侦听器
            watch: {
                要监测的数据 () {
                    监测的数据变换了，进行的操作
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
<h3>2、插值语法</h3> 
<pre><code class="language-html">语法：{<!-- -->{vue的数据}}

注意：括号里可以写vue里的数据或任意的表达式，但不能写语句
例：
    &lt;p&gt;{<!-- -->{ msg }}&lt;/p&gt;
    &lt;p&gt;{<!-- -->{ msg + ',998' }}&lt;/p&gt;
    &lt;p&gt;{<!-- -->{ age &gt;= 18 ? '成年' : '未成年' }}&lt;/p&gt;</code></pre> 
<h2>三、指令</h2> 
<p><strong>指令</strong>是Vue提供的一套具有特殊功能的<span style="color:#ff9900;">行内属性</span>，一般是 v- 开头；</p> 
<h2>内置指令</h2> 
<h3>1、v-text和v-html</h3> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><th style="text-align:center;">v-text</th><td> <p>不会解析标签，只是当纯文本（类似于 innerText）</p> </td></tr><tr><th style="text-align:center;">v-html</th><td> <p>会解析标签，会解析成dom元素（类似于 innerHTML）</p> </td></tr><tr><th colspan="2" style="text-align:center;">共同特点：都是用来设置<code>双标签里显示的内容</code>，都<span style="color:#ff9900;">会<code>覆盖原本的内容</code></span></th></tr></tbody></table> 
<pre><code class="language-html">v-text和插值语法的区别：
    v-text 不会解析标签,但会覆盖原来的内容;
    插值语法 不会解析标签，并且会保留原本的内容，它只会把写{<!-- -->{}}的地方替换成最终数据;
        &lt;div v-text="msg"&gt;原本的内容1&lt;/div&gt;
        &lt;div&gt;原本的内容2--{<!-- -->{msg}}&lt;/div&gt;</code></pre> 
<h3>2、v-on(绑定事件)</h3> 
<h4>（1）v-on的使用方法</h4> 
<pre><code class="language-html">作用：vue里面绑定元素的事件，用 v-on 指令 
语法：
    &lt;标签 v-on:事件名="函数名/函数体"/&gt;  如果事件函数的代码只有一句话，那么可以把这句话直接写到行内
    &lt;标签 v-on:事件名="一句代码" /&gt;
简写语法：将 v-on 换成 @
    &lt;标签 @事件名="函数"/&gt;
    &lt;标签 @事件名="一句代码"/&gt;

举例：&lt;button v-on:click="fn1"&gt;内容&lt;/button&gt;          点击,调用fn1函数
     &lt;button @click="msg = '鸡杀马'"&gt;内容&lt;/button&gt;    点击,给数据中的msg设置值
    注意：在JS中访问Vue里的数据，前面要加this，在HTML中Vue里的数据，前面不用加this</code></pre> 
<h4> （2）Vue里的this</h4> 
<p><span style="background-color:#ffd900;">Vue里的this，指的是当前它<strong>所在的Vue实例</strong></span>，只不过Vue实例在创建后的某个阶段里，会把<span style="background-color:#ffd900;">所有data中的数据和methods中的所有方法，全部挂载到这个实例的<strong>最外层</strong></span>，所以我们可以直接通过this来调用；</p> 
<pre><code class="language-javascript">this.数据名
this.方法名()

fn() {
    this.msg='SHY',
    this.fn1()
}</code></pre> 
<h4>（3） vue里事件对象($event)</h4> 
<p><strong>总结：</strong></p> 
<ul><li id="ub06bb542">$event 在<code>原生标签</code>中，代表<code>事件对象;</code></li><li id="u2b56517f">$event 在<code>组件</code>中，代表<code>组件传递过来的数据;</code></li><li id="uf56d923f">可以直接把子组件传递过来的数据进行赋值；</li><li> <pre><code class="language-html">&lt;son @getMsg="msg = $event"/&gt;    将子组件传过来的数据赋值给父组件的msg变量</code></pre> </li></ul> 
<pre><code class="language-html">原生代码（APP.vue本身）：
1. 在Vue中，如果事件绑定的函数没加小括号，这个参数就是事件对象
    &lt;button @click="fn1"&gt;按钮&lt;/button&gt;
    fn1 (e) {
           console.log(e)    // 事件对象
    }

2. 在Vue中，如果事件绑定时加了小括号，就代表自己要指定传参数，此时你传什么，参数就是什么
    2.1 如果加了小括号,但并没传实参，那么fn2里函数的参数的返回值是 undefined
        &lt;button @click="fn2()"&gt;按钮&lt;/button&gt;
        fn2 (e) {
           console.log(e)    // undefined
        }

    2.2 如果加了小括号,参数里传的是hello，那么fn3里函数的参数，就是一个 hello
        &lt;button @click="fn3('hello')"&gt;按钮&lt;/button&gt;
        fn3 (e) {
           console.log(e)    // hello
        }

    2.3 既想自己传参，又想拿到事件对象，就用 $event 代表事件对象
        &lt;button @click="fn4('hello', $event)"&gt;加了小括号拿事件对象&lt;/button&gt;
        fn4 (a, b) {
           console.log(a)    // hello
           console.log(b)    // 事件对象e
        }</code></pre> 
<pre><code class="language-html">使用组件时（写在APP.vue中）：
1. 在Vue中，如果事件绑定的函数没加小括号，这个参数就是子组件传递过来的数据
    &lt;son @changeMsg="fn1" /&gt;
    fn1 (e) {
           console.log(e)    // 子组件传递过来的数据
    }

2. 在Vue中，如果事件绑定时加了小括号，就代表自己要指定传参数，此时你传什么，参数就是什么
    2.1 如果加了小括号,但并没传实参，那么fn2里函数的参数的返回值是 undefined
        &lt;son @changeMsg="fn1()" /&gt;
        fn2 (e) {
           console.log(e)    // undefined
        }

    2.2 如果加了小括号,参数里传的是hello，那么fn3里函数的参数，就是一个 hello
        &lt;son @changeMsg="fn1(hello)" /&gt;
        fn3 (e) {
           console.log(e)    // hello
        }

    2.3 $event 代表 子组件传递过来的数据
        &lt;son @changeMsg="fn1($event)" /&gt;
        fn4 (e) {
           console.log(e)    // 子组件传递过来的数据
        }

        可以直接把子组件传递过来的数据进行赋值 
        &lt;son @getMsg="msg = $event"/&gt;</code></pre> 
<h4>（4）事件修饰符</h4> 
<p>在vue中很多事件对象的功能，可通过事件修饰符就能实现；</p> 
<p>写在事件类型后面即可，并且这些修饰符可以连在一起用，<strong>没有顺序之分</strong>；</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th style="text-align:center;">事件修饰符</th><th style="text-align:center;">作用</th></tr></thead><tbody><tr><th>.prevent</th><td> <p>阻止默认行为</p> </td></tr><tr><th>.stop</th><td> <p>阻止冒泡</p> </td></tr><tr><th>.once</th><td> <p>代表绑定的事件只触发一次</p> </td></tr><tr><th>.self</th><td> <p>代表事件只能由自身触发，不能由冒泡触发</p> <p>若加在父元素身上，其子元素的事件都会有.self效果</p> </td></tr></tbody></table> 
<pre><code class="language-html">例：&lt;button @click.stop="fn2"&gt;点我&lt;/button&gt;         写在事件类型后面
    &lt;button @click.stop.once="fn3"&gt;点我&lt;/button&gt;    链接写法，once代表这个事件绑定只绑定了一次，那么后面再点会连同stop的效果也会没了</code></pre> 
<h3>3、v-bind(动态绑定行内属性)</h3> 
<pre><code class="language-javascript">作用: 想让标签内哪个属性不写死，就可以用v-bind进行绑定
语法  &lt;标签 v-bind:属性名="vue里的数据"/&gt;
简写  &lt;标签 :属性名="vue里的数据"/&gt;   // 省略 v-bind

例：a标签中的href或img中的src 随数据中的 url/pic 改变而改变
    &lt;a v-bind:href="url" target="_blank"&gt;点我跳转&lt;/a&gt;  
    &lt;img v-bind:src="pic"&gt;</code></pre> 
<h3>4、v-model(双向绑定)</h3> 
<pre><code class="language-html">作用：v-model是用来获取/设置表单元素(input/select/textarea)的内容,除了获取也可以设置;
     (界面变了,数据会跟着变; 数据变了,界面也能跟着变)
语法：&lt;表单标签 v-model="vue里的数据"&gt;

例：&lt;input type="text" v-model="msg"&gt;  input里的内容修改时,数据中的msg也会改变;
                                       数据中的msg修改时,input里的内容也会改变</code></pre> 
<h4>（1）v-model的修饰符</h4> 
<pre><code>语法：&lt;表单标签 v-model.修饰符="vue里的数据"&gt;</code></pre> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th style="text-align:center;width:134px;"> v-model的修饰符</th><th style="text-align:center;width:365px;">作用</th></tr></thead><tbody><tr><th style="width:134px;">.number</th><td style="width:365px;"> <p>输入框默认输入的内容，拿到的都是字符串；</p> <p>用了.number 把输入的内容自动转成数字类型，如果不能转，输入的是什么就拿到什么；</p> </td></tr><tr><th style="width:134px;">.trim</th><td style="width:365px;"> <p>去除输入内容的两边空格</p> </td></tr><tr><th style="width:134px;">.lazy</th><td style="width:365px;"> <p>输入完成后，才会让数据改变</p> </td></tr><tr><th colspan="2" style="text-align:center;width:134px;">可以同时使用多个修饰符</th></tr></tbody></table> 
<h3>5、v-for(循环生成标签)</h3> 
<pre><code class="language-html">作用：循环/遍历(数组、对象)生成标签;
语法：
    &lt;标签 v-for="v in 数字"&gt;&lt;/标签&gt;
    &lt;标签 v-for="(元素,下标) in 数组"&gt;&lt;/标签&gt;      只取下标时,需要占位
    &lt;标签 v-for="(属性值,属性名) in 对象"&gt;&lt;/标签&gt;   只有1个值时不用加小括号
例：
    &lt;div v-for="v in 9"&gt;haha -- {<!-- -->{ v }}&lt;/div&gt;                
        会循环生成9个div, v就是从1到9的数字, 标签中的内容除了v 其它的都一样
    &lt;li v-for="(item, index) in list"&gt;{<!-- -->{ item }} -- {<!-- -->{ index }}&lt;/li&gt;   
        遍历list数组，这个数组有多少个元素就会产生多少个li；
        item:就是被遍历到的每个元素，index：就是被遍历到的下标（名字不一定要叫item和index）
    &lt;li v-for="(val,key) in obj"&gt; {<!-- -->{ val }} -- {<!-- -->{ key }}&lt;/li&gt;
        遍历obj这个对象，对象有多少个属性，就会生成多少个li；
        val就是每一个被遍历到的属性值，key就是每一个被遍历到的属性名
        （不一定要叫val和key，也可以叫别的名字，但是第一个一定是属性值，第二个一定是属性名）</code></pre> 
<h3>6、v-show与v-if</h3> 
<pre><code class="language-html">语法：
    &lt;标签 v-show="数据"&gt;&lt;/标签&gt;
    &lt;标签 v-if="数据"&gt;&lt;/标签&gt;
例：
    &lt;p v-show="isShow"&gt;我是v-show控制&lt;/p&gt;
    &lt;p v-if="isShow"&gt;我是v-if控制&lt;/p&gt;</code></pre> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:680px;"><thead><tr><th style="text-align:center;width:66px;"></th><th style="text-align:center;width:256px;">作用(相同点)</th><th style="text-align:center;width:334px;">不同点</th></tr></thead><tbody><tr><th style="width:66px;">v-show</th><td colspan="1" rowspan="2" style="width:256px;"> <p>都是用来控制一个元素是显示还是隐藏</p> </td><td style="width:334px;"> <p><strong>1.</strong> v-show 是通过控制css中的 display 属性来达到看的到或者看不到的效果，所以<strong>要频繁控制显示和隐藏，用 v-show</strong>；</p> <p><strong>2.</strong> v-show没有双分支或多分支；</p> </td></tr><tr><th style="width:66px;">v-if</th><td style="width:334px;"> <p><strong>1.</strong> v-if 是通过直接操作dom树的添加或移除来达到看到或者看不到的效果，所以如果<strong>要一次性决定有或者没有某个元素，就可以用 v-if；</strong>(如，VIP权力)</p> <p><strong>2.</strong> v-if有双分支和多分支<span style="color:#ff9900;"><strong>（v-if / v-else-if / v-else）</strong></span>；</p> </td></tr></tbody></table> 
<h4> v-if的双分支和多分支</h4> 
<pre><code class="language-html">举例：（根据输入的内容显示对应的div）
1. 双分支
    &lt;input type="text" placeholder="请输入年龄" v-model.number="age"&gt;  // 双向绑定
    &lt;div v-if="age &gt;= 18"&gt;去网吧偷耳机&lt;/div&gt;
    &lt;div v-else&gt;去公园捡垃圾&lt;/div&gt;
2. 多分支
    &lt;input type="text" placeholder="请输入班长有多少钱" v-model.number="money"&gt;
    &lt;div v-if="money &gt;= 3000"&gt;按背&lt;/div&gt;
    &lt;div v-else-if="money &gt;= 2000"&gt;洗脚&lt;/div&gt;
    &lt;div v-else-if="money &gt;= 1000"&gt;吃饭&lt;/div&gt;
    &lt;div v-else-if="money &gt;= 500"&gt;网吧&lt;/div&gt;
    &lt;div v-else&gt;扫地&lt;/div&gt;</code></pre> 
<h2>自定义指令</h2> 
<h3>1、全局自定义指令</h3> 
<pre><code class="language-javascript">写在 main.js 中，在 new Vue() 之前定义全局自定义指令
写法：Vue.directive('自定义指令名称', { 配置 })
例：
Vue.directive('color', {
  bind(el,binding) {                     // 只执行一次
        el.style.color = 'red'   或
        el.style.color = binding.value
  },
  update(el,binding) {                   // 当数据变化后，更新DOM，会调用update函数
        el.style.color = 'red'   或
        el.style.color = binding.value
  },
})

当bind和update里要执行的代码一模一样，可以简写
Vue.directive('color', (el, obj) =&gt; { el.style.color = obj.value; })</code></pre> 
<p><img alt="" height="460" src="https://images2.imgbox.com/87/7b/CKR1kme9_o.png" width="951"></p> 
<h3>2、 私有自定义指令</h3> 
<pre><code class="language-javascript">directives: {    // 用来声明自定义指令，与data同级
    指令名: {
        bind (el, obj) {    // 当绑定指令的dom渲染出来时就会立即执行的函数,就执行1次
            在函数内设置该指令的效果
            参数1：绑定指令的元素
            参数2：是一个对象，里面有指令的相关信息，其中这个对象的value属性可以拿到指令绑定的数据
        },
          
        update(el, obj) {    // 本指令绑定的数据发生改变就来调用，绑定的数据指的是&lt;h1 v-color="color"&gt;中国&lt;/h1&gt;中的变量color
            当绑定的数据发生变化后执行的代码
        },
    }
}

当bind和update里要执行的代码一模一样，可以简写
directives: { 
    指令名 (el, obj) {    // 就相当于不管是bind的时机还是update时机，都是调用此函数
        设置的指令效果的代码
    }
}</code></pre> 
<pre><code class="language-javascript">举例：自定义属性 v-color（作用：给标签更改颜色；
使用方法：就给某个标签加 v-color 即可使用这个指令）&lt;div v-color="msg"&gt;

directives: {
    color: {
        bind (el, obj) {
            console.log(el,obj)    // el为 &lt;h1 style="color: red;"&gt;中国&lt;/h1&gt;
                                   // obj为 {name: 'color', rawName: 'v-color', value: 'red', expression: 'color', modifiers: {…}, …}
            el.style.color = obj.value    // 把obj.value赋值给标签的样式,obj.value拿到的是msg的值
        },
        update(el, obj) {
            console.log(el, obj)
            el.style.color = obj.value;    // 把修改后的值重新赋值给标签的样式
        },
    }
}

因为bind和update里要执行的代码一模一样，所以可以简写
就相当于不管是bind的时机还是update时机，都是调用此函数
directives: {
    color (el, obj) {
      el.style.color = obj.value 
    }
}</code></pre> 
<h2>三、动态样式及类</h2> 
<h3>1、动态style</h3> 
<p>作用：让行内样式不写死，根据数据来得到最终效果；</p> 
<pre><code class="language-html">利用 v-bind 绑定 style 属性 
    &lt;标签 :style="{样式名1: 数据1,样式名2: 数据2}"&gt;&lt;/标签&gt;
    &lt;div :style="{backgroundColor: red, color}"&gt;我是div&lt;/div&gt;</code></pre> 
<p> <strong>注意：</strong></p> 
<ul><li>如果样式名带 <code>-</code>，那么去掉 <code>-</code>并把<code>-</code>后面的首字母大写；</li><li>如果要绑定多个样式，用逗号隔开；</li><li>若样式名和数据值一样时，根据es6简写，可以简写为样式名（color：color）</li></ul> 
<h3>2、动态class</h3> 
<p>作用：动态绑定类名(class)，让类名不写死，来实现样式的切换；</p> 
<pre><code class="language-html">&lt;标签 :class="{类名1：布尔值1,类名2：布尔值2}"&gt;&lt;/标签&gt;
&lt;div class="box" :class="{ red: isRed, op: true }"&gt;我是div&lt;/div&gt;
&lt;td :class="{red: item.price &gt;= 100}"&gt;{<!-- -->{ item.price }}&lt;/td&gt;

    1. 当布尔值为true就有这个类，为false就没有这个类;
    2. 布尔值写成比较表达式</code></pre> 
<p><strong>注意：</strong></p> 
<ul><li> 可以写死一些类，然后可以再动态绑定一些类，他们并不冲突,可以同时使用；</li><li>如果有多个动态类,那么逗号隔开；</li></ul> 
<h2>四、Vue过滤器和计算属性</h2> 
<p>过滤器(filters)、计算属性(computed)跟data、methods这些是平级的</p> 
<h3>（1）Vue过滤器</h3> 
<p>作用：对某个数据做处理，得到一个新的结果；</p> 
<pre><code class="language-javascript">1. 声明一个过滤器
    filters: { 
        过滤器名字 (参数) {        // 参数用来接收使用过滤器是的原数据
            代码对 参数(原数据) 进行处理
            return 新结果
        },
    }

2. 使用过滤器   含义：将原数据交给过滤器处理,会从左往右依次调用过滤器，但是最终显示的结果，一定是最后一个过滤器的结果
    &lt;标签&gt; {<!-- -->{ 原数据 | 过滤器名字1 | 过滤器名字2 }} &lt;/标签&gt;</code></pre> 
<pre><code class="language-html">例子：
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;!-- 把hobby先交给sing去处理得到一个结果,
            再把结果又交给jump去处理,得到最终结果,
            最终显示的结果一定是最后一个过滤器的结果 --&gt;
        &lt;p&gt;{<!-- -->{ hobby | sing | jump | rap }}&lt;/p&gt;   结果：我的兴趣是:唱,跳,rap
    &lt;/div&gt;

    &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        new Vue({
            el: '#app',
            data: {
                hobby: '我的兴趣是:'
            },
            // 写过滤器的地方
            filters: {
                sing (val) {
                    return val + '唱'    // 返回 原数据val和唱拼接成的字符串
                },
                jump (val) {
                    return val + ',跳'
                },
                rap (val) {
                    return val + ',rap'
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
<h3>（2）计算属性</h3> 
<p>作用：当某个数据是依赖别的数据计算得到的，就可以用计算属性；</p> 
<pre><code class="language-javascript">1. 声明一个计算属性
    computed: {      
        计算属性名 () {                // 函数的写法
            经过一系列计算，得到结果
            return 结果
        }
    }
2. 使用计算属性（和普通属性的使用方法一样）
    &lt;标签&gt;{<!-- -->{计算属性名}}&lt;/标签&gt;</code></pre> 
<pre><code class="language-javascript">例子：
// js中
computed: {
    total () {
        let sum = 0
        this.list.forEach(v =&gt; sum += v.price)
        return sum
    }
}
// html中
&lt;span&gt;{<!-- -->{ total }}&lt;/span&gt;</code></pre> 
<h4 id="83a48be1">计算属性有缓存</h4> 
<p>a）计算属性本质上是函数，但是它默认情况下<strong>只会调用一次</strong>，得到结果后把结果缓存起来了，后面读取计算属性，都是<strong>从缓存里取出来</strong>的；</p> 
<p>b）当计算属性里的<strong>依赖项</strong>（计算属性里用到的 别的属性）<strong>发生变化时</strong>，就<strong>会重新调用</strong>，得到一个新结果，再把新结果缓存起来；</p> 
<h3>（3）Vue过滤器和计算属性的区别</h3> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:680px;"><thead><tr><th style="text-align:center;width:160px;"></th><th style="text-align:center;width:412px;">应用场景</th><th style="text-align:center;width:107px;">是否有缓存</th></tr></thead><tbody><tr><th style="width:160px;">Vue过滤器 (filters)</th><td style="width:412px;"> <p>如果界面上展示的数据不是想要的效果，就可以用过滤器来处理，它一般用来处理时间等</p> </td><td style="text-align:center;width:107px;">没缓存</td></tr><tr><th style="width:160px;">计算属性 (computed)</th><td style="width:412px;"> <p>计算属性主要用在一些需要计算得到的数据（总价、平均价）</p> </td><td style="text-align:center;width:107px;">有缓存</td></tr></tbody></table> 
<h2>五、侦听器</h2> 
<p>作用：侦听某个数据的变化（如果数据变化了，就执行一些操作）；</p> 
<h3>1、普通侦听</h3> 
<pre><code class="language-javascript">语法：（可用来侦听data里的数据或某些数组变化）
    watch: {
        要监测的数据 (变化后的值，变化前的值) {
            监测的数据变换了，进行的操作
        }
    }
例：
    watch: {
        监测msg(msg是data里的数据)是否有变化，一旦有变化就调用这个函数
        msg (newVal, oldVal) {
            console.log('msg变化了', newVal, oldVal)  // 打印出 变化后的值 和 变化前的值
        }
    }

obj.name 对象的属性
要监测的数据是数据、对象（指向，地址不同）</code></pre> 
<h3>2、侦听对象</h3> 
<pre><code class="language-javascript">new Vue({
    el: '#app',
    data: {
        obj: {
            name: 'jack',
            age: 16
         }
    },
    watch: {
     1. 侦听对象本身时，是侦听不到他里面属性(obj.name)的变化（因为对象是复杂类型，指向的是地址）
        当对象的指向发生改变时，才会侦听到对象的变化
        obj (newVal, oldVal) {
            console.log('obj被改了', newVal, oldVal)
        },
     2. 直接写对象.属性名就能侦听这个对象的某个属性的变化
        这个是侦听的obj的name属性,不能侦听obj.age的变化
        'obj.name' (newVal, oldVal) {
            console.log('obj里的name变化了', newVal, oldVal)
        },
     3. 深度侦听，可以侦听对象(obj)里任何属性的变化
        obj: {
            deep: true,         // 开启深度侦听
            immediate: true,    // 是否页面一打开就立即调用一次handler(选写),不写默认为flase
            // 当侦听到obj里任何属性发生改变都会触发这个handler函数
            // newVal, oldVal得到的是obj的指向,返回的值是一样的
            handler (newVal, oldVal) {
            console.log('obj里有属性变化了', newVal, oldVal)
            }
         }
    }
})</code></pre> 
<h3>3、深度侦听</h3> 
<p>作用：深度侦听可以侦听对象(obj)里任何属性的变化；</p> 
<pre><code class="language-javascript">对象名: {
    deep: true,         // 开启深度侦听
    immediate: true,    // 是否页面一打开就立即调用一次handler(选写),不写默认为flase
    // 参数newVal, oldVal得到的是obj的指向,返回的值是一样的(都是修改后的指向),所以参数可以省略
    handler () {
        当侦听到obj里任何属性发生改变都会调用这个handler函数
    }
}</code></pre> 
<h3>4、侦听数组</h3> 
<p>如果调用的是以下方法(修改原数组的方法)，那么即是用一般侦听去侦听数组，那也能捕捉到变化（因为Vue对这些方法重新封装了），所以大部分情况下，对于数组而言，直接不用开启深度侦听也可侦听到。</p> 
<blockquote> 
 <p>push() / pop() / shift() / unshift() / splice() / sort() / sort() / reverse()</p> 
</blockquote> 
<pre><code class="language-javascript">// html
    &lt;div id="app"&gt;
        &lt;button @click="add"&gt;添加一个元素&lt;/button&gt;
        &lt;button @click="del"&gt;删除一个元素&lt;/button&gt;
        &lt;ul&gt;
            &lt;li v-for="item in list"&gt; {<!-- -->{ item }}&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
// JS
        new Vue({
            el: '#app',
            data: { list: [10, 20, 30] },
            methods: {
                add () {    // 添加一个随机数
                    this.list.push( Math.random() )
                },
                del () {    // 删除最后一个元素
                    this.list.pop()
                }
            },
            watch: {
                // 普通侦听数组list——因为数组的push、pop、unshift、shift、splice等方法都被Vue重新包装过,所以才能侦听到变化
                list () {
                    console.log('list有变化')
                }
            }
        })</code></pre> 
<h2>六、Vue文件(组件)</h2> 
<h3>1、概念</h3> 
<p>以 .vue结尾的文件，称之为vue文件，也叫组件；</p> 
<p>组成网页的一部分就叫组件，一个网页就是一个一个组件组成的；</p> 
<h3>2、vue文件包含的三大部分</h3> 
<p><strong>html、js、css</strong></p> 
<p>正是因为有这三大部分，所以才能代表界面中的一个小部分</p> 
<h3>3、将vue文件进行webpack打包</h3> 
<p>因为浏览器认识的是html文件，不认识vue文件，所以该用 webpack 进行打包，打包生成为html文件，而且 webpack 是一个模块化管理项目的工具，而组件可以理解为就是整个项目中的一个模块，所以更应该用 webpack 管理起来。</p> 
<h2>七、脚手架(vue-cli)</h2> 
<p>官网：4.40</p> 
<h3>1、安装脚手架</h3> 
<pre><code class="language-javascript">安装全局模块
    1. 安装命令
        npm i -g @vue/cli
    2. 检测是否安装成功（这是大写的V，如果出现版本号，就代表安装成功）
        vue -V
    3. 更新
        npm update -g @vue/cli</code></pre> 
<h3>2、创建新项目和运行项目</h3> 
<p><strong>a）</strong>找一个放自己项目的文件夹(文件夹中不能有vue.js文件)，打开小黑窗，执行创建项目的命令</p> 
<pre><code class="language-javascript">创建项目
vue create 项目名
    注意：项目名不能大写、不能有特殊符号、不能用关键字、不能叫vue</code></pre> 
<p><strong>b）</strong>选择版本配置</p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/cd/3d/KWfdqaom_o.png" width="500"></p> 
<p><strong>c）</strong>出现如下界面代表创建成功</p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/af/3f/nmENyM9l_o.png" width="573"></p> 
<p><strong>d）</strong>可执行最后两行命令开启开发服务器</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/b3/fe/53kfc4ye_o.png" width="511"></p> 
<p><strong>e）</strong>创建成功后，文件夹中会出现创建的项目文件夹</p> 
<h4>项目文件介绍</h4> 
<p><img alt="" height="713" src="https://images2.imgbox.com/cd/2c/312fhebI_o.png" width="805"></p> 
<p></p> 
<ul><li><code>App.vue</code>，称之为 <code>主组件</code>，因为项目运行后看到的效果，就是在这里写的</li><li><code>main.js</code>，称之为 <code>入口文件</code>，打包运行的第一个文件就是它</li><li>以后写代码，都是写在 <code>src</code> 里的</li></ul> 
<h3>3、脚手架Vue项目启动流程</h3> 
<p><img alt="" height="475" src="https://images2.imgbox.com/3b/17/6On6EBZD_o.png" width="944"></p> 
<p> <img alt="" height="465" src="https://images2.imgbox.com/6e/55/4c3cskKE_o.png" width="607"></p> 
<h3>4、组件开发的注意点</h3> 
<p>每个 <code>.vue文件</code>有三大部分：</p> 
<ul><li>template：写html结构的地方（必须有）；</li><li>script：写js代码的地方；</li><li>style：写样式的地方；</li></ul> 
<p>这三大部分可以用 <code>&lt;vue&gt;</code> 来快速生成</p> 
<h4>（1）每个组件的template里要有根标签</h4> 
<p>template里是放html结构的地方，但是<code>必须把所有写的结构</code> 包到一个<code>根标签</code>里；</p> 
<p>根标签一般都是div；</p> 
<h4>（2）组件化开发里，data必须是个函数，在return的对象中声明vue的数据</h4> 
<pre><code class="language-javascript">export default {    // 默认导出
    data () {       // 1.es6的简写形式
        return { 
            // 在此处声明vue的数据
            msg：'123',
        }
    },
    data: function () {       // 2.原生形式
        return {
            msg：'123',
        }
    }
};</code></pre> 
<h3>5、eslint (强制遵守规范)</h3> 
<p>eslint工具在创建项目时<strong>已经默认安装</strong>了，默认是开启的(代码不规范的话会报错)；</p> 
<p><strong>作用：</strong>让程序员写代码时能够<code>强制遵守规范</code>，如果代码不符合规范就直接报错，运行不了；</p> 
<h4>如何关闭ESLint (关的是项目的规范)？</h4> 
<p>来到 <code>vue.config.js</code> 这个配置文件，写如下命令</p> 
<pre><code class="language-javascript">lintOnSave: false</code></pre> 
<p><strong>注意：</strong>以后如果小黑窗里报错，但凡出现ESLint字样，代表代码不规范</p> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/f5/c4/qIyiF9I9_o.png" width="492"></p> 
<h3>6、v-for必须加key才符合VScode规范</h3> 
<p>:key只能给字符串或数值类型，所以建议：<strong><code>有id给id，没id给下标</code></strong></p> 
<pre><code class="language-html">&lt;li v-for="(item,index) in list" :key="index"&gt;{<!-- -->{ item }}&lt;/li&gt;      // item为字符串或数字
&lt;li v-for="(item,index) in list" :key="item.id"&gt;{<!-- -->{ item }}&lt;/li&gt;    // item为对象且有id属性时</code></pre> 
<p>注意：在VScode标准语法规范里，写 <code>v-for</code> 必须要加 <code>:key</code> 属性；如果不写，语法检查通不过会<code>标红报错（不是真正的报错）</code></p> 
<h2>八、组件</h2> 
<p>包含另外一个组件的叫<strong>父组件</strong>；被包含的组件叫<strong>子组件</strong>；</p> 
<p>Vue组件是对UI结构的封装，提高了复用性。</p> 
<h3>1、导入与注册组件</h3> 
<p><strong>（1）</strong>在文件夹components 中新建vue组件文件，相当于封装了一个组件；</p> 
<p><strong>（2）</strong>导入组件</p> 
<pre><code class="language-javascript">import 组件名 from '组件的路径'    // 写在父组件的&lt;script&gt;中，组件名可以和

例：
import mySon from './components/mySon.vue'
import mySon from './components/mySon'    可以省略后缀，意为先寻找这个的.js文件，在找.vue文件</code></pre> 
<p><strong>（3）</strong>注册组件</p> 
<pre><code class="language-javascript">components: {     写在与data平级的位置,注册的所有组件都写在这个components中
    组件名1,
    组件名2, ...
}
// 例
components: {
    mySon,       // 注册组件mySon，是 mySon: mySon 的简写
    xx:mySon,    // 注册组件mySon，并改名为xx,所以后面用要用 &lt;xx /&gt; 来使用
}</code></pre> 
<p><strong>（4）</strong>使用组件 (在想展示的位置，写一个这个组件的标签即可)</p> 
<pre><code class="language-html">&lt;组件名 /&gt;
例：
&lt;mySon /&gt;
&lt;my-son /&gt;    使用时支持把驼峰拆开
&lt;xx /&gt;        使用改名的组件</code></pre> 
<h3>2、组件的style的属性</h3> 
<h4>（1）scoped (样式只作用于当前文件)</h4> 
<p>默认情况下(没使用scoped时)，某个组件里写的样式，都是全局样式，别的组件也能匹配到此样式</p> 
<p><strong>（1.1）scoped使用方法</strong></p> 
<p>在 <code>style</code> 标签上加一个 <code>scoped</code>，就代表当前 <code>style</code> 里的样式，只生效于当前 <code>组件</code>，不会影响到别的组件；</p> 
<pre><code class="language-html">&lt;style scoped&gt;
    该vue文件的样式
&lt;/style&gt;</code></pre> 
<p><strong>建议：</strong>以后在组件里写样式时，记得要加 <code>scoped</code>，这样不会造成样式冲突；</p> 
<p><strong>（1.2）scoped原理</strong></p> 
<p><strong>（1.2.1）为什么默认情况下某个组件里的样式是全局样式？</strong></p> 
<p>因为在<code>app.vue</code>里导入某个组件，那就相当于把这个组件的内容全部放到<code>app.vue</code>里了，就相当于网页里整体内容都是在<code>app.vue</code>里的，所以某个组件的样式也是放到<code>app.vue</code>里了，那就相当于是全局样式了；</p> 
<p><strong>（1.2.2）为什么加<code>scoped</code>就能让它不是全局的样式了？</strong></p> 
<p>原理：用到了 <code>属性选择器</code></p> 
<p class="img-center"><img alt="" height="218" src="https://images2.imgbox.com/df/9b/XjYID0HK_o.png" width="1161"></p> 
<p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/0f/7d/cv3bO8xt_o.png" width="507"></p> 
<p>如果某个组件加了 <code>scoped</code>，它会把组件里所有的标签加上 <code>data-v-hash值</code>的自定义属性(图一)，并且把样式都变成<code>[data-v-hash]</code>的 <code>属性选择器</code> 的样式(图二)，既然是属性选择器，就代表一定要有这个属性，才能匹配到样式，没有这个属性就匹配不到，那么谁有这些属性呢？就只有加了 <code>scoped</code>的组件才有这个属性，所以通过这样的操作，保证了加了<code>scoped</code>的样式只给当前组件使用。</p> 
<p><strong>（1.2.3）如果另外一个<code>组件</code>也加了 <code>scoped</code>能用到这个组件里的样式吗？</strong></p> 
<p>不能，因为hash值不一样，这个hash值是根据组件名产生的（每一个都不一样），</p> 
<p>这样就保证了，谁加<code>scoped</code>，就只是给谁自己用，别人用不到。</p> 
<h4>（2）深度作用选择器（将样式穿透给子组件）</h4> 
<p><strong>使用情况：</strong>若一个组件加了 <code>scoped</code>，那么它的样式默认只能给自己用，无法给子组件用，如果希望某个样式能<code><strong>穿透给子组件</strong>用（即父组件的某个样式要做用于子组件）</code>，就用 <code>深度作用选择器</code></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th style="width:168px;"> <p id="1d7ca7e2" style="text-align:center;">深度作用选择器</p> </th><th style="text-align:center;width:331px;">注意</th></tr></thead><tbody><tr><th style="text-align:center;width:168px;">&gt;&gt;&gt;</th><td colspan="1" rowspan="2" style="width:331px;"> <pre>vscode不认识，会有波浪线（不是真的报错）</pre> </td></tr><tr><th style="text-align:center;width:168px;">/deep/</th></tr><tr><th style="text-align:center;width:168px;">::v-deep（推荐）</th><td style="width:331px;">不会有波浪线</td></tr></tbody></table> 
<pre><code class="language-css">语法：
::v-deep 选择器{ 这里的样式就能给子组件用了 }
&gt;&gt;&gt; 选择器{ 这里的样式就能给子组件用了 }
/deep/ 选择器{ 这里的样式就能给子组件用了 }</code></pre> 
<h4>（3）vue的style标签支持less语法</h4> 
<p><strong>步骤：</strong>（1）<span style="color:#404040;">安装 less：</span><span style="color:#c00000;">npm install less less-loader@7.3.0 -D</span></p> 
<p>           （2）在 &lt;styl<span style="color:#404040;">e&gt; 标签上添加 </span><span style="color:#c00000;">lang="less" </span><span style="color:#404040;">属性，即可使用 less 语法编写组件的样式</span></p> 
<pre><code class="language-html">例：
&lt;style lang='less'&gt;
h1{
  color: red;
  span{
    color: blue;
  }
}
&lt;/style&gt;</code></pre> 
<h3>3、prop</h3> 
<div> 
 <span style="color:#404040;">prop 是组件的</span> 
 <span style="color:#c00000;">自定义<strong>只读</strong>属性</span> 
 <span style="color:#404040;">。</span> 
</div> 
<div> 
 <span style="color:#404040;"><strong>作用：</strong>在</span> 
 封装通用组件的时候，合理地使用 prop 可以极大的提高组件的复用性。可以理解为 prop 是在使用组件 
 <span style="color:#404040;">的时候，</span> 
 <span style="color:#be191c;"><strong>从外面传递给组件的一个参数</strong></span> 
 <span style="color:#404040;">。</span> 
</div> 
<div> 
 <strong><span style="color:#404040;">使用举例：</span></strong> 
</div> 
<p><img alt="" height="490" src="https://images2.imgbox.com/db/06/kziwEyWR_o.png" width="1071"></p> 
<h4><span style="color:#404040;"><strong>prop 的配置选项</strong></span></h4> 
<p>3.30          配置时要用对象</p> 
<h4>（1）type—<span style="color:#404040;">给 prop 设置数据类型</span></h4> 
<h4>（2）default—<span style="color:#404040;"><strong>给 prop 设置默认值</strong></span></h4> 
<h4>（3）required—<span style="color:#404040;"><strong>给 prop 设置是否必填</strong></span></h4> 
<p> </p> 
<h3>4、组件通信</h3> 
<h4>（1）父传子</h4> 
<p>把父的数据传递给子组件</p> 
<p><img alt="" height="810" src="https://images2.imgbox.com/b5/bb/p5BGrGm7_o.png" width="1200"></p> 
<h4> 单向数据流</h4> 
<ul><li id="ue8f25cb3">父可以直接给子传递数据，并且传递时<code>父的数据变了，子的数据会跟着变</code></li><li id="uf326c08a">单向数据流只允许 <code>父数据改动能自动流入到子</code>，但是<code>子的数据不能流入到父</code></li><li id="ue96b9ef2">所以如果直接在 <code>子里</code>修改父传递来的数据，当修改的是 <code>栈</code><span style="color:#4d4d4d;"> 上的数据(即不能修改简单类型的数据，能修改复杂类型的数据</span><span style="color:#4d4d4d;">)</span><span style="color:#4d4d4d;">，会报错。所以如果传递的是对象，在子里改了对象的属性，那是不会报错的，也允许的；</span></li></ul> 
<p><img alt="" height="425" src="https://images2.imgbox.com/dc/b4/xQd4Jq6W_o.png" width="410"></p> 
<h4>（2）子传父</h4> 
<p> 子里的数据给父 或 父传给子的数据再给父</p> 
<p><strong> 使用步骤：</strong></p> 
<p><strong>a.</strong>在<code>子</code>需要改父数据的时候，使用 <code>$emit</code> 发送一条通知</p> 
<pre><code class="language-javascript">this.$emit('自定义的通知名', 数据)
例
this.$emit('changeMsg', '喵喵喵')</code></pre> 
<p><strong>b.</strong>父里监听这个通知</p> 
<pre><code class="language-javascript">&lt;子组件 @自定义的通知名="函数"/&gt;
例：
&lt;son @changeMsg='fn'/&gt;    // fn写在父组件中

fn (val) {    
  val就是子传递过来的数据，就可将val进行处理
}</code></pre> 
<p><img alt="" height="941" src="https://images2.imgbox.com/f0/18/RaP1pjSN_o.png" width="1200"></p> 
<h4>（3）兄弟(非父子关系)组件传值-eventBus</h4> 
<p>不一定是有一个共同的父组件的2个组件之间传值，可能是更复杂的关系。</p> 
<p><strong>原理：</strong>在vue中，实例化一个新的vue对象，把它作为bus，将bus作为转换平台，实现非父子关系的传值。</p> 
<p class="img-center"><img alt="" height="327" src="https://images2.imgbox.com/30/2a/eYPmPwEi_o.png" width="412"></p> 
<h4><strong>方法一：</strong>用了一个独立的<code>js</code>文件来准备 <code>bus</code>这个对象</h4> 
<p>准备文件的<strong>好处</strong>是：谁要用谁导入即可；  </p> 
<p><strong>缺点</strong>：得多准备这么个文件，然后要写导入导出的语法</p> 
<p><strong>步骤： </strong></p> 
<p><strong>a. </strong>来到 <code>src目录</code>，新建 <code>eventBus</code>的文件夹，里面放一个 <code>index.js</code></p> 
<pre><code class="language-javascript">此index.js文件中写：
    // 导入vue
    import Vue from "vue";
    // 实例化一个vue对象,并暴露出去（因为要通过它传值，所以别的组件要用）
    export default new Vue()</code></pre> 
<p><strong>b. </strong>发送、接收数据的组件都要导入index.js(bus文件)</p> 
<p><strong>c. </strong>使用 bus.$emit 发送数据；使用 bus.$on 接收数据；先点关注再传递数据，才能成功</p> 
<pre><code class="language-javascript">发送数据的组件：
    import bus from 'bus的路径'
    bus.$emit('自定义的事件名', 数据)    // 导入的对象不要加this，如果是访问data中的数据加this
例：
    bus.$emit('son1Send', "haha")
    bus.$emit('son1Send', this.list)
</code></pre> 
<pre><code class="language-javascript">接收数据的组件：
    import bus from 'bus路径'
    bus.$on('自定义事件', (data) =&gt; {
        // 当别的组件传过来值时会自动调用这个回调函数
        // 参数data就是传递过来的数据
    })</code></pre> 
<p><strong>例：</strong></p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/08/31/ItTdwRzE_o.png" width="979"></p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/27/16/X0vVwj4h_o.png" width="1200"></p> 
<h4>方法二：将eventBus挂载到原型对象上</h4> 
<p><strong>a. </strong>挂载Vue的原型对象一般是放在 <code>main.js</code></p> 
<p>因为 <code>main.js</code> 是入口文件，相当于项目一运行就执行的代码，所以如果写到这里面，就代表项目一打开，vue的原型里就有bus对象了</p> 
<pre><code class="language-javascript">Vue.prototype.$bus = new Vue()

注意：挂载到Vue原型上的属性，前面名字要加 $，方便区分是组件自己的数据还是原型上的数据
    this.emit    // 组件data里的变量
    this.$emit   // 原型上的$emit</code></pre> 
<p><strong>b. </strong>后面组件之间的传值，用...</p> 
<pre><code class="language-javascript">this.$bus.$on('自定义事件', (data) =&gt; { 参数data是传递过来的数据 }) // 订阅
this.$bus.$emit('自定义的事件名', 数据) // 发布</code></pre> 
<h4>补充：vue-cli脚手架里的路径说明</h4> 
<p><strong>（1）</strong>如果文件后缀是.js或者.vue，可以<strong>省略后缀</strong></p> 
<pre><code class="language-javascript">import bus from '../eventBus/index'</code></pre> 
<p><strong>（2）</strong>如果一个文件夹里的文件叫package.json、index.js 或 index.vue，<strong>文件名都可以省略</strong></p> 
<pre><code class="language-javascript">import bus from '../eventBus'</code></pre> 
<p><strong>（3）</strong>在脚手架中，用<strong>@代表src目录</strong></p> 
<pre><code class="language-javascript">import bus from '@/eventBus'</code></pre> 
<h3>5、ref与$refs（可非官方实现子传父）</h3> 
<p><strong>作用：</strong>ref配合$refs可以方便在vue中<strong>找到 <code>dom元素</code>以及 <code>组件对象</code></strong></p> 
<pre><code class="language-javascript">用法：
1. 对着标签添加 ref 属性，指定一个名字 
    &lt;标签 ref="名字" /&gt;
    &lt;组件 ref="名字" /&gt;
2. 在JS中，就可以通过 this.$refs.名字 就可以到这个标签对象

例：获取标签
        this.$refs.h1.style
    如果获取的是组件，那么拿到的是组件对象，相当于组件内部的this，所以可快速父传子
        this.$refs.son1                   // 找到son1组件对象
        this.$refs.son1.list.push(999)    // 给son1子组件里的数组list添加元素
        this.$refs.son1.sayHi()           // 调用子组件里的方法
</code></pre> 
<h2>九、插槽</h2> 
<h3>1、插槽分类</h3> 
<p><strong>作用：</strong>让封装的组件内某个区域不写死(放自己相放的内容)，增加组件的复用性。</p> 
<p><strong>使用步骤：</strong>在不想写死的地方写一个 <code>&lt;slot /&gt;</code>，就相当于在这个位置挖了个坑占了个位，外界使用组件时传递了什么。<code>slot</code>这个位置就显示什么</p> 
<p><strong>注意：</strong>给插槽传递内容时，规范是建议<strong>把所有内容包在 <code>template</code>标签里</strong>（方便具名插槽操作）</p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/1b/e2/1bhr1VKg_o.png" width="986"></p> 
<h4>（1）默认插槽</h4> 
<pre><code class="language-html">&lt;slot&gt;默认内容&lt;/slot&gt;

插槽的双标签内可写默认内容；
如果外界如果没传内容，那么就以默认内容来显示；
如果以后外界传了内容，那么就以传递的内容在slot里显示；</code></pre> 
<p><img alt="" height="530" src="https://images2.imgbox.com/02/5b/7NnYMz5j_o.png" width="990"></p> 
<h4>（2）具名插槽</h4> 
<p><strong>使用情况：</strong>当组件有多个地方不想写死是，所以就要准备多个具名插槽，使每处插入的内容不同。</p> 
<pre><code class="language-html">具名插槽语法：
    &lt;slot name="名字"&gt; 默认内容 &lt;/slot&gt;

传递给特定插槽的内容：
    &lt;template v-slot:插槽名字&gt;
    	要传递的内容
    &lt;/template&gt;</code></pre> 
<p><img alt="" height="698" src="https://images2.imgbox.com/e3/9f/RrVRxNk2_o.png" width="1200"></p> 
<h4>（3）作用域插槽</h4> 
<p><strong>使用情况：</strong>默认情况下，组件内部的数据是无法给外界使用的。作用域插槽可以把当前作用域里的数据暴露出去，给别的组件使用。</p> 
<pre><code class="language-html">语法：
1. 暴露(向外传递)数据
    &lt;slot name="插槽名字" :数据名1="数据1" :数据名2="数据2" /&gt;
2. 接收数据    若插槽无名字，则 v-slot="对象名"
    &lt;template v-slot:插槽名字="对象名"&gt;
        对象名表示的对象接收传递过来的所有数据
    &lt;/template&gt;</code></pre> 
<p><img alt="" height="537" src="https://images2.imgbox.com/9d/94/Evnwx6U3_o.png" width="1200"></p> 
<h3> 2、插槽简写</h3> 
<blockquote> 
 <p><strong>总结： </strong> <span style="color:#ff9900;"> v-slot：简写成 #</span></p> 
</blockquote> 
<h4>（1）默认插槽</h4> 
<pre><code class="language-html">&lt;template&gt;
    不写名字就是默认插槽
&lt;/template&gt;

&lt;template v-slot:default&gt;
    默认插槽的名字叫 default，简写 #default
&lt;/template&gt;

&lt;template v-slot="接收数据的对象名"&gt;
    如果要拿到作用域里的数据，这时候不建议写#，写#要写 #default="接收数据的对象名"
&lt;/template&gt;</code></pre> 
<h4>（2）具名插槽</h4> 
<pre><code class="language-html">1、具名插槽接收数据
    完整写法
    &lt;template v-slot:名字="obj"&gt;
    &lt;/template&gt;

    简写写法
    &lt;template #名字="obj"&gt;
    &lt;/template&gt;

2、不需要接收数据的具名插槽
    完整写法
    &lt;template v-slot:名字&gt;
    &lt;/template&gt;

    简写
    &lt;template #名字&gt;
    &lt;/template&gt;</code></pre> 
<h3>3、已废弃插槽的语法</h3> 
<p><a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95" rel="nofollow" title="已废弃的插槽语法 — Vue.js">已废弃的插槽语法 — Vue.js</a></p> 
<p>废弃语法是在vue2.6里开始废弃，vue2.6时还能用，在vue3以后彻底不能用；</p> 
<pre><code class="language-html">废弃语法有两个语法：
    1.用来指定给哪个插槽用
        slot="插槽名字"    等于    v-slot:"插槽名字"
    2.用来拿到插槽内部的数据，都放到obj里
        slot-scope="obj"  等于    v-slot="接收数据的对象名"

例：&lt;template #body="obj"&gt;
    废弃语法是  &lt;template slot="body" slot-scope="obj"&gt;</code></pre> 
<h2>十、Vue的生命周期</h2> 
<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" rel="nofollow" title="Vue生命周期图示 — Vue.js">Vue生命周期图示 — Vue.js</a></p> 
<p>Vue的生命周期指的是vue对象（组件）从创建到销毁的一系列阶段。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5b/81/Tfyx4ZbH_o.png" width="686"></p> 
<h3> 生命周期钩子总结</h3> 
<p>4个阶段8个钩子</p> 
<p>组件缓存会产生两个钩子（activated、deactivated），所以最终生命周期钩子共10个</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:680px;"><thead><tr><th style="text-align:center;width:79px;">阶段</th><th style="text-align:center;width:95px;">钩子</th><th style="text-align:center;width:226px;">特点</th><th style="text-align:center;width:269px;">使用场景</th></tr></thead><tbody><tr><th colspan="1" rowspan="2" style="width:79px;"> <p style="text-align:center;">创建阶段</p> <p style="text-align:center;"></p> </th><td style="width:95px;"> <p>beforeCreate</p> </td><td style="width:226px;"> <p>创建前，是最早的钩子，但是还无法访问data中的数据和methods的方法</p> </td><td style="width:269px;"> <p></p> </td></tr><tr><td style="width:95px;"> <p>created</p> <p>（常用）</p> </td><td style="width:226px;"> <p>创建后，是最早能访问到数据的钩子</p> </td><td style="width:269px;"> <p>场景1：开发中，要页面一打开就要发请求拿数据，所以越早越好，但是发请求拿到数据后，还要把数据保存到vue的变量里，所以写到 <code>created</code></p> <p></p> <p>场景2： eventBus要订阅兄弟组件传值</p> </td></tr><tr><th colspan="1" rowspan="2" style="width:79px;"> <p style="text-align:center;">渲染阶段</p> </th><td style="width:95px;"> <p>beforeMount</p> </td><td style="width:226px;"> <p>渲染前，还无法访问到真实DOM</p> </td><td style="width:269px;"></td></tr><tr><td style="width:95px;"> <p>mounted</p> <p>（常用）</p> </td><td style="width:226px;"> <p>渲染后，可以访问到真实dom，是最早能访问到真实dom的钩子</p> </td><td style="width:269px;"> <p>有些插件例如 <code>echarts</code>，希望页面一打开就有图表，那就意味着页面一打开就要创建<code>echarts对象</code>，但是创建 <code>echarts</code>对象时，需要传入一个dom元素作为图表的容器。所以用这个最早能访问到<code>dom</code>的钩子</p> </td></tr><tr><th colspan="1" rowspan="2" style="width:79px;"> <p style="text-align:center;">更新阶段</p> </th><td style="width:95px;"> <p>beforeUpdate</p> </td><td style="width:226px;"> <p>更新前，指数据发生改变立即调用的钩子，但是此时dom还没重新更新</p> </td><td style="width:269px;"></td></tr><tr><td style="width:95px;"> <p>updated</p> </td><td style="width:226px;"> <p>更新后，指数据发生改变并且dom已经更新调用的钩子</p> </td><td style="width:269px;"></td></tr><tr><th colspan="1" rowspan="2" style="width:79px;"> <p style="text-align:center;">销毁阶段</p> </th><td style="width:95px;"> <p>beforeDestroy</p> </td><td style="width:226px;"> <p>销毁前，还能访问到子组件</p> </td><td colspan="1" rowspan="2" style="width:269px;"> <p>两个钩子任选其一</p> <p></p> <p>可以做一些回收工作：</p> <p>1、停止定时器</p> <p>2、如果销毁了，应该把监听兄弟组件传值给关了(取关)</p> <p><code>this.$bus.$off("自定义的事件名")</code></p> </td></tr><tr><td style="width:95px;"> <p>destroyed</p> </td><td style="width:226px;"> <p>销毁后，访问不到子组件了</p> </td></tr></tbody></table> 
<p><strong>销毁钩子停止定时器</strong></p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="son2"&gt;
    &lt;h3&gt;我是son2.vue&lt;/h3&gt;
    &lt;button &gt;我要拿son1的数据 -- 相当于点了关注&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

  data() {
    return {
      timer: null,    // 声明变量，用于开启关闭定时器
    };
  },

  created() {
    // 当这个组件一诞生就自动订阅了组件传值（相当于关注了公众号）
    this.$bus.$on("son1Send", (data) =&gt; {
      console.log("son1给数据了，数据是：", data);
    });
    // 开启定时器
    this.timer = setInterval(() =&gt; {
      console.log('我是son2里开的定时器')
    }, 1000);
  },

  destroyed () {    或 beforeDestroy
    console.log('son2已销毁')
    // 移除定时器
    clearInterval(this.timer)
    // 在组件销毁时取关（避免内存泄露）
    this.$bus.$off("son1Send")
  }
};
&lt;/script&gt;</code></pre> 
<h3 id="1efc0d52">进阶面试题：当一个组件里也有子组件时，那么父组件和子组件穿插的的生命周期是怎样的？</h3> 
<p> 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子的beforeCreate-&gt;子的created-&gt;子beforeMount-&gt;子的mounted-&gt;父的mounted-&gt;谁数据改变就调用谁的beforeUpdate和updated -&gt; 如果此时销毁父组件，会调用父的 beforeDestroy -&gt; 子的beforeDestroy-&gt;子destroyed-&gt;父destroyed</p> 
<h2>十二、</h2> 
<h3>1、注册全局</h3> 
<p>全局组件、全局过滤器、全局指令都是<strong>在 main.js 里注册</strong>（写在new Vue上边）。</p> 
<h4 id="869b18c7">（1）全局组件</h4> 
<pre><code class="language-javascript">注册全局组件
    Vue.component('组件的注册名称', 导入的组件名称)

例：全局组件panel
    import panel from './components/panel'
    Vue.component('panel', panel)</code></pre> 
<h4>（2）全局过滤器</h4> 
<pre><code class="language-javascript">注册全局过滤器
    Vue.filter('过滤器名', (原数据) =&gt; {
        return 处理后的结果
    })

例：全局过滤器formatTime
    Vue.filter('formatTime', (val) =&gt; {
        return '2022-03-30'
    })</code></pre> 
<h4>（3）全局指令</h4> 
<pre><code class="language-javascript">注册全局指令
    Vue.directive('指令名', {
        bind (el, obj) { },
        update (el, obj) { }
    })

简写：写成函数的形式
    Vue.directive('指令名', (el, obj) =&gt; { })

例：全局指令v-color
// Vue.directive('color', {
//   bind (el, obj) {
//     el.style.color = obj.value 
//   },
//   update (el, obj) {
//     el.style.color = obj.value 
//   }
// })

全局指令v-color简写
Vue.directive('color', (el, obj) =&gt; {
  el.style.color = obj.value 
})</code></pre> 
<h3>2、动态组件</h3> 
<p><strong>作用：</strong>让某个区域里的组件可来回切换，你指定哪个组件，它就显示那个组件；</p> 
<p><strong>实现方法：</strong></p> 
<pre><code class="language-html">在需要切换组件的位置，写一个 component标签 ，数据变量等于哪个组件名，那么这个位置就会显示什么组件
    &lt;component :is="数据变量"/&gt;</code></pre> 
<h3>3、组件缓存</h3> 
<pre><code class="language-html">&lt;keep-alive&gt;
    // 被缓存的组件
&lt;/keep-alive&gt;</code></pre> 
<p>使用 v-if 隐藏组件时，会将组件销毁，因为v-if 是通过直接操作dom树的添加或移除来达到看到或者看不到的效果</p> 
<p><strong>组件缓存的作用：</strong><code>不想让组件销毁</code>，让其依然保留在内存中（即当组件被缓存时，它就<strong>不会被销毁</strong>）；</p> 
<p><strong>注意：</strong>如果组件被缓存起来了，它的 <code>销毁钩子</code>就不会被调用了，取而代之会多两个钩子，所以最终生命周期钩子10个</p> 
<ul><li>activated： 当组件显示时调用（激活时）</li><li>deactivated：当组件隐藏时调用</li></ul> 
<h4>登入切换案例—动态组件、组件缓存练习</h4> 
<p class="img-center"><img alt="" height="418" src="https://images2.imgbox.com/67/4c/QkBeVwU4_o.png" width="431"></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click="comName = 'qrcode'"&gt;二维码登入&lt;/button&gt;
    &lt;button @click="comName = 'sologinFomen'"&gt;表单登入&lt;/button&gt;
    &lt;!-- 动态切换方法1： --&gt;
    &lt;keep-alive&gt;
      &lt;component :is="comName" /&gt;
      &lt;!-- 当点击第一个按钮时,comName = 'qrcode',就显示qrcode组件;第二个按钮也是如此 --&gt;
    &lt;/keep-alive&gt;
    &lt;!-- &lt;keep-alive&gt; 组件缓存,当来回切换时,表单input的内容不会销毁 --&gt;

    &lt;!-- 动态切换方法2：v-if和v-else-if --&gt;
    &lt;!-- &lt;qrcode v-if="comName == 'qrcode'" /&gt;
    &lt;sologinFomen v-else-if="comName == 'sologinFomen'" /&gt; --&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 导入切换时显示不同的两个组件
import sologinFomen from "./components/loginFome.vue";
import qrcode from "./components/qrcode.vue";

export default {
  components: { sologinFomen, qrcode },
  data() {
    return { comName: qrcode }; // 设置comName的默认值
  },
};
&lt;/script&gt;</code></pre> 
<h3>4、单页面应用</h3> 
<p><strong>单页面应用(Single Page Application)：</strong>整个网站的项目其实只有一个页面（整个网站只有一个 <code>index.html</code>，用<strong>页面里内容的切换</strong> 实现 看起来的页面跳转效果，实际上页面并没有跳转，不会有刷新）</p> 
<p><strong>优点：</strong></p> 
<ul><li>切换页面时速度快</li><li id="uce70fbd3">可以减少服务器的请求</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>默认情况下，第一次加载会慢一点</li><li id="u97995d04">不利于SEO（搜索引擎优化）</li></ul> 
<div> 
 <strong>单页面应用实现原理—<span style="color:#404040;">Hash： </span></strong> 
</div> 
<ul><li><span style="color:#404040;"># 号后面的部分，专业术语为“Hash 地址” </span></li><li><span style="color:#404040;">Hash 地址发生变化，不会导致浏览器页面的刷新 </span></li><li><span style="color:#404040;">Hash 地址发生变化，会形成浏览器历史记录 </span></li><li><span style="color:#404040;">vue 就是基于 hash 的这些特性来做路由的跳转，实现页面的切换的</span></li></ul> 
<h2>十二、路由 (vue-router)</h2> 
<p><strong>官方文档地址</strong>（给vue2用的路由文档）：<a href="https://router.vuejs.org/zh/guide/" rel="nofollow" title="Vue Router-路由文档">Vue Router-路由文档</a></p> 
<p><strong>路由：</strong>可以实现用一个路径对应显示一个组件；路由(核心插件)是实现单页面应用的关键所在。</p> 
<h3>1、路由的基本使用步骤</h3> 
<h4>方法一：</h4> 
<p><strong>（1）</strong>下载路由插件</p> 
<blockquote> 
 <p>npm i vue-router@3.x        // 路由的3.x版本对应vue2，路由的4.x版本对应vue3</p> 
</blockquote> 
<p><strong>（2）</strong>在 main.js 中粘贴以下代码</p> 
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

// 1. 使用模块化机制编程时，导入Vue和VueRouter，要调用 Vue.use(VueRouter)
import VueRouter from 'vue-router'
// 给Vue安装路由（给vue对象提供路由支持）
Vue.use(VueRouter)

// 2. 导入路由要显示的组件    注意：以后路由对应的组件一般都是放到 `src/views`文件夹里
// import 组件对象 from '组件路径'
import discover from './views/discover'

// 3. 准备路由规则：设置什么路径对应什么组件
const routes = [
    // 路由重定向
    // { path: '/a路径', redirect: '/b路径'},

    // path这里就是路径;component这里就是对应的组件
    { path: '/a', component: discover },

    // 访问了一个没有设置过的路径，都会跳转到 404 页面(notFound组件)
    // { path: '*', component: notFound },
]

// 4. 创建 路由router 实例
const router = new VueRouter({
    routes, // (缩写) 相当于 routes: routes
    // mode: 'history'    // 将hash模式转换成history模式
})

// 5. 把路由对象挂载到vue的根实例
// 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载
new Vue({
    router,
    render:h=&gt;h(App)
}).$mount('#app')</code></pre> 
<p><strong>（3）</strong>在组件中放置一个<strong>路由出口</strong>        注：路由出口就是路由要显示到的位置</p> 
<blockquote> 
 <p>&lt;router-view /&gt;        // 用了路由，vue文件中就不必导入/注册组件了</p> 
</blockquote> 
<h4>方法二（规范）：</h4> 
<p><strong>（1）</strong>安装 <span style="color:#404040;">vue-router</span></p> 
<p><strong>（2）</strong>创建路由模块</p> 
<pre><code class="language-javascript">在 src 源代码目录下，新建 router/index.js 路由模块，并初始化如下的代码：

// 1.导入Vue及VueRouter
import Vue from "vue";
import VueRouter from "vue-router";

// 2.将VueRouter安装为Vue的插件,给vue对象提供路由支持
Vue.use(VueRouter)

// 3.创建路由的实例对象
const router = new VueRouter()

// 4.导出路由实例对象
export default router</code></pre> 
<p><strong>（3）</strong><span style="color:#404040;">将路由模块挂载到 vue 的根组件中</span></p> 
<p><span style="color:#404040;">在 src/</span><span style="color:#c00000;">main.js </span><span style="color:#404040;">入口文件中，导入并挂载路由模块</span></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/dd/a8/jEwiWuOe_o.png" width="387"> </p> 
<p><span style="color:#404040;"><strong>（4）</strong>配置路由规则</span></p> 
<pre><code class="language-javascript">在 src/router/index.js 路由模块中，在router的实例对象中通过 routes 数组声明路由的匹配规则

routes: [
    { path: 'hash地址', component:组件 }
    { path: '/home', component: home },
]</code></pre> 
<p> <img alt="" height="578" src="https://images2.imgbox.com/bb/51/ooRw7ZS7_o.png" width="510"></p> 
<p><span style="color:#404040;"><strong>（5）</strong>声明</span><span style="color:#c00000;">路由链接</span><span style="color:#404040;">和</span><span style="color:#c00000;">路由占位符</span></p> 
<pre><code class="language-html">在组件vue文件中使用
1.路由链接
    &lt;router-link to="路径"&gt;导航名&lt;/router-link&gt;
    &lt;router-link to="/about"&gt;关于&lt;/router-link&gt;
2.路由占位符，将组件渲染到这里
    &lt;router-view&gt;&lt;/router-view&gt;</code></pre> 
<h3>2、使用a标签做路由跳转</h3> 
<pre><code class="language-html">&lt;a href="#/a"&gt;组件discover&lt;/a&gt;    // 点击a标签显示地址对应的组件
    注意：使用路由后，默认的路径前面都有 # ，所以路径应该这样写： #/路径</code></pre> 
<h3>3、路由的模式</h3> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:600px;"><thead><tr><th style="text-align:center;width:98px;">路由的模式</th><th style="text-align:center;width:401px;">特点</th></tr></thead><tbody><tr><th style="width:98px;"> <p style="text-align:center;">hash模式</p> <p style="text-align:center;">（默认）</p> </th><td style="width:401px;"> <p>网址上的<strong>路径前面要包含 # </strong>，如 域名/#/my</p> </td></tr><tr><th style="width:98px;"> <p style="text-align:center;">history模式</p> </th><td style="width:401px;"> <p>像正常网址一样，<strong>没有 # 号</strong>，如 域名/my ；</p> <p></p> <p>如果项目正式上线，想用<code>history</code>模式还需要服务器做一些配置上的支持；</p> </td></tr></tbody></table> 
<h4>将hash模式转换成history模式</h4> 
<pre><code class="language-javascript">main.js文件中在实例化 router 对象时，加一个mode，写明模式名字 
    const router = new VueRouter({
        routes,
        mode: 'history'
    })</code></pre> 
<h3>4、router-link 路由链接，实现跳转（使用）</h3> 
<pre><code class="language-html">语法：
    &lt;router-link to="路径"&gt;文字&lt;/router-link&gt;
例：
    &lt;router-link to="/discover"&gt;发现音乐&lt;/router-link&gt;</code></pre> 
<p>router-link 的<strong>本质</strong>就是 a标签；</p> 
<p><strong>优点：</strong></p> 
<ul><li id="uc8b19f0c">既支持hash模式，也支持history模式；如果是hash模式，它最终会自动在路径前面加 #</li><li id="u2935380c">谁被点，谁会自动加两个类：router-link-exact-active 和 router-link-active，方便制作点谁谁高亮的效果（只要对 router-link-active 写一个高亮样式即可）；</li></ul> 
<h3>5、路由重定向</h3> 
<p><strong>路由重定向：</strong>访问a路径，自动帮你跳转到b路经；可用于自动跳转到默认主页面；</p> 
<pre><code class="language-javascript">语法：在 main.js的路由规则 里加如下一条
    { path: '/a路径', redirect: '/b路径'}    // 访问a路径，自动帮你跳转到b路经
    { path: '', redirect: '/b路径'}         // 空字符串就代表什么路径都没输入时，自动跳转到b路经
    { path: '/', redirect: '/b路径'}        // 空字符串和'/' 表示的含义一样,即访问域名自动跳转到默认的主页面
如：
    { path: '/d', redirect: '/discover'}    // 如果路径上输入的是 /d， 它会自动帮你跳转到 /discover</code></pre> 
<h3>6、路由404页面</h3> 
<p><strong>要实现的效果：</strong>访问了一个<code>没有设置过的路径</code>，都会跳转到 <code>404</code> 页面</p> 
<pre><code class="language-javascript">在 main.js的路由规则 的最后添加一条规则
    const routes = [
        .......
        .......
        { path: '*', component: notFound },
    ]

注意： 1. 一般情况下404页面都是放在最后；
      2. *代表除了上面以外的其他路径，就访问notFound组件(404页面)；
      3. 需要提前准备好 notFound组件并导入；</code></pre> 
<h3>7、动态路由</h3> 
<p><strong>作用、优点：</strong>提高路由规则的复用性。</p> 
<div> 
 <span style="color:#404040;"><strong>使用场景：</strong>一般都是在从列表页，跳转到详情页的时候，使用动态路由。</span> 
</div> 
<pre><code class="language-javascript">语法：
    { path: '/路径/:动态参数名', component: 组件对象 }
例：
    { path: '/movie/:id', component: movie },
    // 这里的:id就代表需要路径上在movie后面添加一个id参数；
    // 可以访问/movie/1，/movie/2，/movie/3，...
    // 访问这个路由时，必须携带id作为参数，不携带就访问不了；</code></pre> 
<h3>8、获取动态参数</h3> 
<p><strong>动态路由可以传参：</strong>访问一个路由的同时也把参数携带过去。</p> 
<h4>（1）$route.params.参数名</h4> 
<pre><code class="language-javascript">传递动态参数后，在这个组件内部拿到这个动态参数值    （$route记录了当前路由的信息）
    语法：$route.params.参数名    
    注意：如果这段代码不是写在html，而是写在 js，那记得前面要加 this

如：
    {<!-- -->{ $route.params.id }}    // 参数名如果叫id，那就是 .id</code></pre> 
<h4>（2）props: ['动态参数名']</h4> 
<p>使用 $route.params 获取动态参数比较麻烦，所以提供了通过 <code>props</code>来接收参数。</p> 
<pre><code class="language-javascript">步骤：
1. 在要访问的组件里，声明 props，动态参数名要跟规则里的动态参数名保持一致
    props: ['动态参数名']
2.  在main.js的路由规则里，开启props接收参数的功能
    { path: '/路径/:参数名', component: movie, props: true },</code></pre> 
<p><img alt="" height="906" src="https://images2.imgbox.com/20/65/Z3uH1ua0_o.png" width="1200"></p> 
<h3>9、路由嵌套</h3> 
<p><strong>路由嵌套：</strong>一个路由里又包含了另一个路由。</p> 
<ul><li id="ube5fea85">包含另外路由的叫父路由，被包含的叫子路由；</li><li id="u3a035c77">包含所有的路由叫一级路由；一级路由里的子路由叫二级路由；</li></ul> 
<p><strong>使用步骤：</strong></p> 
<p><strong>a. </strong>准备二级路由要对应的页面组件（也就是.vue文件）；</p> 
<p><strong>b. </strong>来到 main.js路由规则的地方，先做组件的导入；</p> 
<p><strong>c. </strong>将二级路由的规则写到父路由的 <code>children</code> 里</p> 
<pre><code class="language-javascript">const routes = [
  .....
  { 
    path: '/discover', 
    component: discover,                          // discover是一级路由的组件
    children: [
      { path: 'topList', component: topList },    // topList、songList是二级路由的组件
      { path: 'songList', component: songList },
    ]
  },
 ]
注意：1. 子路由的路径不加/
      2. 不加/就代表需要先拼接父路由的路径再加自己的路径
      3. 虽然加了/它还是二级路由，只不过地址上就不能拼接父路由路径了,不会访问到二级路由的组件</code></pre> 
<p><strong>d. </strong>在父路由对应的组件里，写路由链接和路由占位符</p> 
<pre><code class="language-html">1.路由链接    注：路径要从父组件开始
    &lt;router-link to="/about/tab1"&gt;tab1&lt;/router-link&gt;
2.路由占位符，二级导航要放在父组件哪里就写在哪里
    &lt;router-view&gt;&lt;/router-view&gt;</code></pre> 
<h3>10、<span style="color:#404040;"><strong>声明式导航 &amp; 编程式导航</strong></span></h3> 
<h4>（1）<span style="color:#404040;"><strong>声明式导</strong>航</span></h4> 
<div> 
 <span style="color:#404040;">在浏览器中，</span> 
 <span style="color:#c00000;">点击标签链接</span> 
 <span style="color:#404040;">实现路由跳转的方式，叫做</span> 
 <span style="color:#c00000;">声明式导航</span> 
 <span style="color:#404040;">。</span> 
</div> 
<div> 
 <span style="color:#404040;">例如： 普通网页中点击 </span> 
 <span style="color:#c00000;">&lt;a&gt; 链接</span> 
 <span style="color:#404040;">、vue 项目中点击 </span> 
 <span style="color:#c00000;">&lt;router-link&gt; </span> 
 <span style="color:#404040;">都属于声明式导航</span> 
</div> 
<h4><span style="color:#404040;">（2）编程式导航</span></h4> 
<div> 
 <span style="color:#404040;">在浏览器中，</span> 
 <span style="color:#c00000;">调用 JS API 方法</span> 
 <span style="color:#404040;">实现路由跳转的方式，叫做</span> 
 <span style="color:#c00000;">编程式导航</span> 
 <span style="color:#404040;">。</span> 
</div> 
<div> 
 <span style="color:#404040;">例如：普通网页中调用 </span> 
 <span style="color:#c00000;">location.href </span> 
 <span style="color:#404040;">跳转到新页面的方式、vue 项目中vue-router 提供的</span> 
 <span style="color:#be191c;">导航API</span> 
 都 
 <span style="color:#404040;">属于编程式导航</span> 
</div> 
<h4>（2.1）<span style="color:#404040;">this.$router.</span><span style="color:#c00000;">push</span><span style="color:#404040;">('hash地址')</span></h4> 
<p><strong>作用：</strong><span style="color:#404040;">跳转到指定 hash 地址，并</span><span style="color:#c00000;">增加</span><span style="color:#404040;">一条历史记录；</span><img alt="" height="400" src="https://images2.imgbox.com/28/1c/e9RRhkGR_o.png" width="552"></p> 
<h4><span style="color:#404040;">（2.2）this.$router.</span><span style="color:#c00000;">go</span><span style="color:#404040;">(数值n)</span></h4> 
<p><strong>作用：</strong>当数值为正、负数时，<span style="color:#404040;">实现导航历史前进、后退</span></p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/c3/5d/8cPCf2I2_o.png" width="459"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>Vue人力资源中台项目：<a href="https://gitee.com/vue-course-better/human-resources-project" rel="nofollow" title="vue全系列课程/人力资源项目">vue全系列课程/人力资源项目</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c5fc94d3ecce744af1aab0804da6bc43/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">$.ajax() 参数详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5d7f3eb39c8fcee1935d61be3edc154/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序——从零搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>