<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>输入输出大全（普通输入输出和快读快写）C/C&#43;&#43; - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="输入输出大全（普通输入输出和快读快写）C/C&#43;&#43;" />
<meta property="og:description" content="目录
前言
一、普通读写操作
1、cin
2、scanf
3、gets/getline
4、printf
二、快读快写
1、整形快读快写
2、浮点型的快读快写
3、字符串快读快写
三、O2优化
总结
前言 我最早接触的刷题平台是力扣，这导致我第一次在PTA平台上写题的时候在数据的输入和输出上感到非常折磨。这篇文章是我对各种输入输出的总结，准备开始刷题的同学看这篇文章能帮你节约不少的时间。
缓存区 ： 书上的定义是，缓冲区是一块物理内存中的存储区,当数据进行转移时用来临时存放数据。在这里的作用我就把他理解成，在输入和输出时数据时，这些数据都要在缓存区走一遍再去完成他们的功能。
一、普通读写操作 在不考虑读写运行速度的情况下，基本的读入函数就能完成我们所有的读入功能。下面主要介绍不同的读入函数，
1、cin 作为操作起来最方便的读入函数，cin不需要记住任何的多余符号，新手只要知道他在空格和换行符会自动停止读入就行，且不会清空缓存区，对刚刚刷题的小白非常的友好。但我个人是非常不建议用的，速度慢是其次，主要是他在读入一些比较特殊的词时会有些不方便（这个题目写多了肯定会遇到的），最基础的操作相比来说的话我更推荐scanf。
2、scanf 我是非常建议把scanf当成不需要考虑读入效率时的默认输入方式的。一般的scanf使用方法我就不多说了，这里介绍几种在刷题时曾经困扰过我的几种输入。
题目要求读入n个整形（n不确定），存放在arr数组里，输入时每个整形之间会以空格分开，具体样子如下。
当时我不了解scanf遇到空格会结束的特性，这个输入没有完成，其实这种类型的输入通过一句话就可以解决。
while(~scanf(&#34;%d&#34;,&amp;arr[i&#43;&#43;]));//i就是个从零开始的变量 这里用到了scanf的返回值特性，scanf其实是有返回值的（可能就我不知道吧），一次scanf读入几个字符他就会返回几，碰到空格或者TAB等会返回0，而碰到输入结束标志会返回EOF（即-1），所以这里用的是~符号，让-1的时候得到0退出while循环，就是要让他在检测接收到数据和空格时都继续接收下一个，而接收到输入结束标志时退出while即不继续输入。
大部分不确定输入个数的输入通过这个都能解决，但有一个例子不可以：要求将n（n不确定）个字符串放到二维数组arr里，具体如下。
我们先直接看解决代码
while(~scanf(&#34;%d&#34;,&amp;arr[i&#43;&#43;]) &amp;&amp; getchar() == &#39; &#39;);//i就是个从零开始的变量 这里我先解释上面的那一串字符为什么不能用之前的方法解决，在最开始我也不明白为什么这样的字符串输入进来会有问题，后面我看了录进去的值之后我发现其实不管是让我输入字符串还是让我输入整形，我的输入都是有问题的，只不过在字符串输入的时候更容易发现错误。对于第一个输入整形的题目我们写一下就会发现当我们运行完时，如果我们输入3个数，n的值会变成4而不是3，这是因为scanf在读入的时候在把空格，换行等读入到缓存区的时候会结束此次读入，但是这时候缓存区里的空格，换行等不会消失，这就导致我读完最后一个数时其实缓存区里还有\n而不是结束标志，这时候如果下一位是文章结束标志scanf会将\n转换成空格存到我的数组里，当然这时候n&#43;&#43;于是导致n比我们想要的值还多一。那为什么加了getchar就好了呢，这我们就要知道getchar的处理字符方式，当缓存区有字符时，getchar会从缓存区读取并清空一个字符，而这里就是用到了getchar的这个特性，不仅可以清空scanf之后缓存区残留的符号还能，让循环在正确的时候退出。
3、gets/getline 这两个分别是c/c&#43;&#43;的输入函数，这里要注意的是gets在c&#43;&#43;里是不能用的，在这里讲一下这两个函数和scanf有什么区别，前面我们已经说过了scanf遇到空格和回车会停止，但是这里的gets只有遇到回车才会停止，并且会自动把\n转化成\0(gets只会能把数据读到char*里)。还有一点与scanf不同的是scanf会把空格换行等留在缓存区里，只能通过getchar来清除，但gets不会在缓存区里留东西。getline就是c&#43;&#43;版的gets。那什么时候会用到这个呢？当我想输入一段字符串但字符串里面包含空格时，我就只能用gets去实现这个功能。
4、printf 所有的输出我都是建议printf的，虽然cout非常的方便，但是学会printf可以满足所有不需要效率时的输出操作。下面主要讲两个我之前不知道的操作。
固定小数位数的输出，这里举个例子1：比如我要输出一个小数后两位的浮点数。
double a =2.127; printf(&#34;%.2lf\n&#34;,a);//控制double类型到两位小数 这里有一点要注意，最后一位显示出来的小数是会自动四舍五入的。
例子2：在整形前面自动补0直到达到指定位数，多用于有补0格式要求的整形输出。
int i=2; printf(&#34;%02d&#34;,i);//不够两位在左边补零，补空格也行 二、快读快写 在有些题目里读写要求的数据量特别大时甚至会要求我们不能使用语言本身提供的函数，而是要求我们对一些不方便但是效率高的函数操作来达到输入输出的功能，这就是快读快写。
快读快写的本质就是用更快的读入函数去实现读写操作，读入操作时间 cin &gt; scanf &gt; getchar &gt; fread.这就衍生出了以下两种快读（getchar版本和fread版本）。以下按照整型的输入来解释。
inline int read1()//这里加inline是为了解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题 { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt;&#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 &#43; ch - &#39;0&#39;, ch = getchar(); return x * f; } 上面根据getchar读入字符的功能去实现读入一个整形，但是这样的函数没法像scanf一样放在while里读入，这就导致如果不告诉你数据个数你就没法很好的读入，于是改进后函数为下面这样，输入检测到\n会让while退出。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/2df88191cd1be1d0250522cde1ef085a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-27T16:01:23+08:00" />
<meta property="article:modified_time" content="2022-06-27T16:01:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">输入输出大全（普通输入输出和快读快写）C/C&#43;&#43;</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E6%99%AE%E9%80%9A%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%99%AE%E9%80%9A%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C" rel="nofollow">一、普通读写操作</a></p> 
<p id="1%E3%80%81cin-toc" style="margin-left:40px;"><a href="#1%E3%80%81cin" rel="nofollow">1、cin</a></p> 
<p id="2%E3%80%81scanf-toc" style="margin-left:40px;"><a href="#2%E3%80%81scanf" rel="nofollow">2、scanf</a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="3%E3%80%81gets%2Fgetline-toc" style="margin-left:40px;"><a href="#3%E3%80%81gets%2Fgetline" rel="nofollow">3、gets/getline</a></p> 
<p id="4%E3%80%81printf-toc" style="margin-left:40px;"><a href="#4%E3%80%81printf" rel="nofollow">4、printf</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99" rel="nofollow">二、快读快写</a></p> 
<p id="1%E3%80%81%E6%95%B4%E5%BD%A2%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%95%B4%E5%BD%A2%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99" rel="nofollow">1、整形快读快写</a></p> 
<p id="2%E3%80%81%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%9A%84%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%9A%84%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99" rel="nofollow">2、浮点型的快读快写</a></p> 
<p id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99" rel="nofollow">3、字符串快读快写</a></p> 
<p id="%E4%B8%89%E3%80%81O2%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81O2%E4%BC%98%E5%8C%96" rel="nofollow">三、O2优化</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p>我最早接触的刷题平台是力扣，这导致我第一次在PTA平台上写题的时候在数据的输入和输出上感到非常折磨。这篇文章是我对各种输入输出的总结，准备开始刷题的同学看这篇文章能帮你节约不少的时间。</p> 
<hr> 
<p>缓存区 ： 书上的定义是，<strong>缓冲区是一块物理内存中的存储区,当数据进行转移时用来临时存放数据</strong>。在这里的作用我就把他理解成，<strong>在输入和输出时数据时，这些数据都要在缓存区走一遍再去完成他们的功能</strong>。</p> 
<h2 id="%E4%B8%80%E3%80%81%E6%99%AE%E9%80%9A%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><a id="_19"></a>一、普通读写操作</h2> 
<p>在不考虑读写运行速度的情况下，基本的读入函数就能完成我们所有的读入功能。下面主要介绍不同的读入函数，</p> 
<h3 id="1%E3%80%81cin">1、cin</h3> 
<p>作为操作起来最方便的读入函数，cin不需要记住任何的多余符号，<strong>新手只要知道他在空格和换行符会自动停止读入就行，且不会清空缓存区</strong>，对刚刚刷题的小白非常的友好。但<strong>我个人是非常不建议用的</strong>，速度慢是其次，主要是他在读入一些比较特殊的词时会有些不方便（这个题目写多了肯定会遇到的），<strong>最基础的操作相比来说的话我更推荐scanf</strong>。</p> 
<h3 id="2%E3%80%81scanf">2、scanf</h3> 
<p>我是<strong>非常建议把scanf当成不需要考虑读入效率时的默认输入方式的</strong>。一般的scanf使用方法我就不多说了，这里介绍几种在刷题时曾经困扰过我的几种输入。</p> 
<p>题目要求读入n个整形（n不确定），存放在arr数组里，输入时每个整形之间会以空格分开，具体样子如下。</p> 
<p><img alt="" height="33" src="https://images2.imgbox.com/04/fc/Kw20nFO8_o.png" width="192"></p> 
<p> 当时我不了解scanf遇到空格会结束的特性，这个输入没有完成，其实这种类型的输入<strong>通过一句话就可以解决</strong>。</p> 
<pre><code>while(~scanf("%d",&amp;arr[i++]));//i就是个从零开始的变量</code></pre> 
<p> 这里用到了scanf的返回值特性，<strong>scanf其实是有返回值的</strong>（可能就我不知道吧），<strong>一次scanf读入几个字符他就会返回几，碰到空格或者TAB等会返回0，而碰到输入结束标志会返回EOF（即-1）</strong>，所以这里用的是~符号，<strong>让-1的时候得到0退出while循环，就是要让他在检测接收到数据和空格时都继续接收下一个，而接收到输入结束标志时退出while即不继续输入</strong>。</p> 
<p>大部分不确定输入个数的输入通过这个都能解决，但有一个例子不可以：要求将n（n不确定）个字符串放到二维数组arr里，具体如下。</p> 
<p><img alt="" height="38" src="https://images2.imgbox.com/44/ee/F8p99k1d_o.png" width="264"></p> 
<p> 我们先直接看解决代码</p> 
<pre><code>while(~scanf("%d",&amp;arr[i++]) &amp;&amp; getchar() == ' ');//i就是个从零开始的变量</code></pre> 
<h3><a id="1_20"></a></h3> 
<p>这里我先解释上面的那一串字符为什么不能用之前的方法解决，在最开始我也不明白为什么这样的字符串输入进来会有问题，后面我看了录进去的值之后我发现其实<strong>不管是让我输入字符串还是让我输入整形，我的输入都是有问题的，只不过在字符串输入的时候更容易发现错误</strong>。对于第一个输入整形的题目我们写一下就会发现当我们运行完时，如果我们输入3个数，n的值会变成4而不是3，<strong>这是因为scanf在读入的时候在把空格，换行等读入到缓存区的时候会结束此次读入，但是这时候缓存区里的空格，换行等不会消失，这就导致我读完最后一个数时其实缓存区里还有\n而不是结束标志，这时候如果下一位是文章结束标志scanf会将\n转换成空格存到我的数组里，当然这时候n++于是导致n比我们想要的值还多一</strong>。那为什么加了getchar就好了呢，这我们就要知道getchar的处理字符方式，<strong>当缓存区有字符时，getchar会从缓存区读取并清空一个字符，而这里就是用到了getchar的这个特性</strong>，不仅可以清空scanf之后缓存区残留的符号还能，让循环在正确的时候退出。</p> 
<h3 id="3%E3%80%81gets%2Fgetline">3、gets/getline</h3> 
<p>这两个分别是c/c++的输入函数，<strong>这里要注意的是gets在c++里是不能用的</strong>，在这里讲一下这两个函数和scanf有什么区别，前面我们已经说过了scanf遇到空格和回车会停止，但是这里的<strong>gets只有遇到回车才会停止，并且会自动把\n转化成\0(gets只会能把数据读到char*里)。还有一点与scanf不同的是scanf会把空格换行等留在缓存区里，只能通过getchar来清除，但gets不会在缓存区里留东西</strong>。<strong>getline就是c++版的gets</strong>。那什么时候会用到这个呢？<strong>当我想输入一段字符串但字符串里面包含空格时，我就只能用gets去实现这个功能</strong>。</p> 
<h3 id="4%E3%80%81printf">4、printf</h3> 
<p>所有的输出我都是建议printf的，虽然cout非常的方便，但是学会printf可以满足所有不需要效率时的输出操作。下面主要讲两个我之前不知道的操作。</p> 
<p>固定小数位数的输出，这里举个例子1：比如我要<strong>输出一个小数后两位的浮点数</strong>。</p> 
<pre><code class="language-cpp">double a =2.127;
printf("%.2lf\n",a);//控制double类型到两位小数</code></pre> 
<p><strong>这里有一点要注意，最后一位显示出来的小数是会自动四舍五入的</strong>。</p> 
<p>例子2：<strong>在整形前面自动补0直到达到指定位数，多用于有补0格式要求的整形输出</strong>。</p> 
<pre><code class="language-cpp">int i=2;
printf("%02d",i);//不够两位在左边补零，补空格也行</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99">二、快读快写</h2> 
<p>在有些题目里读写要求的数据量特别大时甚至会要求我们不能使用语言本身提供的函数，而是要求我们对一些不方便但是效率高的函数操作来达到输入输出的功能，这就是快读快写。</p> 
<p>快读快写的本质就是用更快的读入函数去实现读写操作，<strong>读入操作时间 cin &gt; scanf &gt; getchar &gt; fread.这就衍生出了以下两种快读（getchar版本和fread版本）</strong>。以下按照整型的输入来解释。</p> 
<pre><code class="language-cpp">inline int read1()//这里加inline是为了解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch &lt; '0' || ch &gt;'9')
    {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}</code></pre> 
<p><strong>上面根据getchar读入字符的功能去实现读入一个整形，但是这样的函数没法像scanf一样放在while里读入，这就导致如果不告诉你数据个数你就没法很好的读入</strong>，于是改进后函数为下面这样，输入检测到\n会让while退出。</p> 
<pre><code class="language-cpp">inline int read2(int* a,int i)//这里加inline是为了解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9')
    {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar();
    a[i] = x * f;
    if (ch == '\n') return 0;
    return 1;
}</code></pre> 
<p>从之前所说的我们知道还有一个比getchar更快的函数，<strong>接下来我们再用fread去实现getchar</strong>，实现一个更快的快读。</p> 
<pre><code class="language-cpp">char buf[100000], * p1 = buf, * p2 = buf;

inline char nc() {
    if(p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1, stdin);
    return *p1++;
}

inline int read3(int* a, int i) {
    int x = 0, f = 1;
    char ch = nc();
    while (ch &lt; '0' || ch &gt; '9')
    {
        if (ch == '-') f = -1;
        ch = nc();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = nc();
    a[i] = x * f;
    if (ch == '\n') return 0;
    return 1;
}</code></pre> 
<p><strong> fwrite<em>(buffer,size,count,fp)   </em> buf表示存放读入一个数据的地址指针；<em>size</em>表示读出的字节数；<em>count</em>表示读出数据项的个数；fp表示文件型指针。</strong></p> 
<p></p> 
<p>同样的我们这时候看快写运行时间 <strong>cout &gt; printf &gt; putchar</strong> ，下面就是<strong>用putchar来实现printf</strong>。</p> 
<pre><code class="language-cpp">void write(int x)
{
    if (x &lt; 0) putchar('-'), x = -x;
    if (x &gt; 9) write(x / 10);
    putchar(x % 10 + '0');
    return;
}</code></pre> 
<h3 id="1%E3%80%81%E6%95%B4%E5%BD%A2%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99">1、整形快读快写</h3> 
<pre><code class="language-cpp">char buf[100000], * p1 = buf, * p2 = buf;

inline char nc() {
    if(p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1, stdin);
    return *p1++;
}

inline int read3(int* a, int i) {
    int x = 0, f = 1;
    char ch = nc();
    while (ch &lt; '0' || ch &gt; '9')
    {
        if (ch == '-') f = -1;
        ch = nc();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = nc();
    a[i] = x * f;
    if (ch == '\n') return 0;
    return 1;
}

void write(int x)
{
    if (x &lt; 0)
        putchar('-'), x = -x;
    if (x &gt; 9)
        write(x / 10);
    putchar(x % 10 + '0');
    return;
}</code></pre> 
<h3 id="2%E3%80%81%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%9A%84%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99">2、浮点型的快读快写</h3> 
<p>这方面用到的雀食没见过，而且如果把浮点型写成快读快写也需要很多的函数，效果没那么明显，这里就不写了。</p> 
<h3 id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99">3、字符串快读快写</h3> 
<p>这里其实也起不到多大的优化效果，看个人意愿是否使用，这里就不用fread了。</p> 
<pre><code class="language-cpp">inline string readstr() {
	string s = "";
	char ch;
	while ((ch = getchar()) != '\n') s += ch;
	return s;
}

inline void writestr(string s) {
	for (int i = 0; i &lt; s.size(); i++) putchar(s[i]);
}
</code></pre> 
<h2 id="%E4%B8%89%E3%80%81O2%E4%BC%98%E5%8C%96">三、O2优化</h2> 
<p>读入数据量大的时候O2优化能减少很多运行时间，具体原理不需要了解，这里就直接放O2开关。</p> 
<p><strong>把下面这句话写到程序前面就好啦。</strong></p> 
<pre><code class="language-cpp">#pragma GCC optimize(2)</code></pre> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p>很多的题目都是可以不要快读快写的，很多时候怎么方便怎么来，但是这不意味这就不重要，快读快写在关键时刻说不定真的能救你一命呢。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f346a4237086e4fbdeb1bdf923b9b871/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务治理-Nacos</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38830fca328e3d030787043f8df3f9e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">聊聊java8中的@sun.misc.Contended与伪共享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>