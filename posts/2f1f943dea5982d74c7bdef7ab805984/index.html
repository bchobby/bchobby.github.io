<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言-排序 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言-排序" />
<meta property="og:description" content="十大排序算法 冒泡排序快速排序选择排序直接插入排序希尔排序归并排序堆排序计数排序基数排序桶排序 一、冒泡排序 原理：
两两比较相邻元素，如果顺序不对，则进行交换。达到使小数如气泡一样往上浮动（例如在数组中将元素左移），或者使大数如石头一样下沉（在数组中将元素右移）
步骤：
设待排序的n个元素存放在数组r[0…n-1] (注：此处数组下标从0开始)中，首先将第一个元素和第二个元素对比，如果(r[0] &gt; r[1])则交换两个元素顺序。接着比较第二个和第三个元素。依次类推，直至r[n-2]和第r[n-1]进行比较。这个过程就是第一趟起泡排序，结果是最大的元素被放在了r[n-1]的位置(即最后一个位置)进行第二趟起泡排序，对前n-1个元素进行同样的操作，使第二大的数放在了r[n-2]的位置重复上述步骤，第i趟是从r[0]到r[n-i-1] （注：这里i也是从0开始）依次比较两个元素，并在逆序(前一个元素比后一个元素大)时交换顺序，结果是n-i个元素中值最大的数被放到了r[n-i-1]的位置。直到在某一趟排序过程中没有进行交换操作，说明序列已经全是顺序排列(从左到右元素从小到大排列) 代码实现：
int oriData[8] = {49,38,65,97,76,13,27,49}; void bubbleSprt(int* data, int len) { int flag = 1;	//用于记录某本趟排序是否发生顺序交换 for(int i = 0; (i &lt; len) &amp;&amp; (flag == 1); i &lt; len) { flag = 0;	//flag置为0，如果本趟Paiute没有发生交换，则说明全部数据已经是顺序排列，不需要再比较 for(int j = 0; j &lt; len - i - 1; j&#43;&#43;) { if(data[j] &gt; data[j &#43; 1]) { int tmp = data[j &#43; 1]; data[j &#43; 1] = data[j]; data[j] = tmp;	//交换顺序 flag = 1;	//表明本趟排序发生了交换 } } } return; } 算法分析：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/2f1f943dea5982d74c7bdef7ab805984/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-25T20:52:02+08:00" />
<meta property="article:modified_time" content="2022-03-25T20:52:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言-排序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_2"></a>十大排序算法</h3> 
<ul><li>冒泡排序</li><li>快速排序</li><li>选择排序</li><li>直接插入排序</li><li>希尔排序</li><li>归并排序</li><li>堆排序</li><li>计数排序</li><li>基数排序</li><li>桶排序</li></ul> 
<h4><a id="_13"></a>一、冒泡排序</h4> 
<p><strong>原理</strong>：<br> 两两比较相邻元素，如果顺序不对，则进行交换。达到使小数如气泡一样往上浮动（例如在数组中将元素左移），或者使大数如石头一样下沉（在数组中将元素右移）<br> <strong>步骤</strong>：</p> 
<ol><li>设待排序的n个元素存放在数组r[0…n-1] (注：此处数组下标从0开始)中，首先将第一个元素和第二个元素对比，如果(r[0] &gt; r[1])则交换两个元素顺序。接着比较第二个和第三个元素。依次类推，直至r[n-2]和第r[n-1]进行比较。这个过程就是第一趟起泡排序，结果是最大的元素被放在了r[n-1]的位置(即最后一个位置)</li><li>进行第二趟起泡排序，对前n-1个元素进行同样的操作，使第二大的数放在了r[n-2]的位置</li><li>重复上述步骤，第i趟是从r[0]到r[n-i-1] （注：这里i也是从0开始）依次比较两个元素，并在逆序(前一个元素比后一个元素大)时交换顺序，结果是n-i个元素中值最大的数被放到了r[n-i-1]的位置。直到在某一趟排序过程中没有进行交换操作，说明序列已经全是顺序排列(从左到右元素从小到大排列)</li></ol> 
<p><strong>代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> oriData<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">bubbleSprt</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>						<span class="token comment">//用于记录某本趟排序是否发生顺序交换</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>						<span class="token comment">//flag置为0，如果本趟Paiute没有发生交换，则说明全部数据已经是顺序排列，不需要再比较</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">int</span> tmp <span class="token operator">=</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>			<span class="token comment">//交换顺序</span>
				flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>				<span class="token comment">//表明本趟排序发生了交换</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> 
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/00/2e/FdSDyWNV_o.png" alt="在这里插入图片描述"><br> <strong>算法分析：</strong></p> 
<ol><li> <p>时间复杂度<br> 最好情况（初始数据为顺序排列）：只需进行一趟排序，在排序过程中进行n-1次元素比较，且不存在交换<br> 最坏情况（初始数据为逆序排列）：需进行n-1趟排序，元素比较次数KCN和移动次数RMN(每次交换移动3次)<br> <img src="https://images2.imgbox.com/90/42/vnIMFRG5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d3/67/0YkonMZp_o.png" alt="在这里插入图片描述"><br> 平均情况下，冒泡排序比较次数和交换测试分别约为<img src="https://images2.imgbox.com/e7/85/Zk89bOvV_o.png" alt="在这里插入图片描述">和<img src="https://images2.imgbox.com/52/f2/O9lSnF8t_o.png" alt="在这里插入图片描述">，时间复杂度为O(n^2)</p> </li><li> <p>空间复杂度<br> 冒泡排序只有在交换顺序时用到一个辅助变量做暂存，所以空间复杂度为O(1)</p> </li></ol> 
<h4><a id="_57"></a>二、快速排序</h4> 
<p><strong>原理：</strong><br> 快速排序是对冒泡排序的的一种改进。在冒泡排序中，只对相邻的两个数进行比较，每次交换两个相邻数只能消除一个逆序。快速排序是任选一个数(比如数组中第一个数)作为基准数，将所有比其小的数放在它左边，所有比它大的数放在右边，这时，一趟快速排序将要排序的序列分割为两部分，然后再按此方法对两部分数据分别进行快速排序，整个过程递归进行，到每个子序列只有一个数时，排序完成，得到有序序列。<br> <strong>步骤：</strong></p> 
<ol><li>选择待排序序列的第一个数作为基准数，附设两个指针left和right.初始时分别指向数组的第一个数和最后一个数（第一趟：left = 0；right = n - 1）</li><li>从数组最右侧依次向左搜索，找到第一个比基准数小的数，将其移到data[left]处。具体操作为：当left&lt;right时，若data[right] &gt;= 基准数.则向左移动指针（high- -）;否则将data[high]和基准数交换。</li><li>然后再从数组最左侧位置，依次向右搜索，找到第一个比基准数大的数，将其移动到data[right]处，具体操作为：当left&lt; right时，若data[left]小于等于基准数，则向右移动指针（left++）;否则将data[left]和基准数交换</li><li>重复2和3的操作，直到left和right相等位置。此时left或right的位置即为基准数在祠堂排序中的最终位置，原序列被分为两个子序列。</li></ol> 
<p>在上述过程中，数据的交换都是与基准数之间发生，每次交换都要移动3次，排序过程中只移动要和基准数交换的数，也就是制作data[left]和data[right]的单向移动，知道一趟排序结束后再将基准数移到正确的位置上<br> <strong>代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> oriData<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> data<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>								<span class="token comment">//记录基准值</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;=</span> left<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>									<span class="token comment">//从表的两端交替地向中间扫描</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">)</span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
        data<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>						<span class="token comment">//将比基准值小的数移到左边</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">)</span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>										<span class="token comment">//将比基准值大的数移到右边</span>
        data<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    data<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>									<span class="token comment">//插入基准值</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//对左子表递归排序</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//对右子表递归排序</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">qucikSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">qSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>算法分析：</strong></p> 
<ol><li>时间复杂度<br> 快速排序的趟数取决于递归树的深度<br> 最好情况：每一趟排序后都能将序列均匀地分割成两个长度大致相等的子序列，类似折半查找。在n个数据的序列中，对基准值定位所需时间为O(n).如设T(n)是对n个数据进行排序所需的时间，而且每次对基准值正确定位后，正好把序列分为两个长度相等的子序列，那么总的排序时间为<br> <img src="https://images2.imgbox.com/92/a0/HRPArArt_o.png" alt=""><br> 最坏情况：在待排序序列已经排好序的情况下，其递归树成为单支数，每次划分只得到一个比上次少一个数的子序列。这样，必须经过 n-1 趟才能将所有数定位，而且第i趟需要经过n-1-i次比较。这样，总的关键字比较次数KCN为<br> <img src="https://images2.imgbox.com/a5/4a/nNOBYUdr_o.png" alt="在这里插入图片描述"><br> 这种情况下，快速排序已经退化到简单排序的水平。基准数的合理选择可以避免这种最坏情况的出现。<br> 理论证明，平均情况下，快速排序时间复杂度为<img src="https://images2.imgbox.com/fd/b5/jesEmLjk_o.png" alt="在这里插入图片描述"></li><li>空间复杂度<br> 快速排序是递归的，执行时需要一个栈来存放相应的数据。最大递归调用次数与递归树的深度一直。所以最好情况下的空间复杂度为<img src="https://images2.imgbox.com/c7/49/TcjoGTlf_o.png" alt="在这里插入图片描述">，最坏情况为O(n).</li></ol> 
<p><strong>算法特点：</strong></p> 
<ol><li>排序过程需要定位序列表的上界和下届，适用于顺序存储结构，很难适用于链式结构</li><li>当n比较大时，在平均情况下，快速排序时所有内部排序方法中速度最快的一种，所以其适合初始记录无序、n较大时的情况。</li></ol> 
<h4><a id="_113"></a>三、选择排序</h4> 
<p><strong>原理</strong>：和冒泡排序类似，只不过是每一趟从待排序的元素中选出最小(或最大)的元素，按顺序排在已经排序的序列最后，直到全部排完为止。可以看作是冒泡排序的优化。<br> <strong>步骤</strong>：</p> 
<ol><li>设待排序的n个元素存放在数组r[0…n-1] (注：此处数组下标从0开始)中，第一趟从r[0]开始，通过n-1次比较，从n个元素中找出最小的数，记为r[k],交换r[0]和r[k]。</li><li>第二趟从r[1]开始，通过n-2次比较，从n-1个元素中找出最小的数，记为r[k],交换r[1]和r[k]。</li><li>重复上述步骤，第i趟是从r[i]开始（注：这里i从0开始计），通过n-1-i次比较，从n-i个元素中找到最小的数，记为r[k],交换r[i]和r[k]</li><li>经过n-1趟，排序完成</li></ol> 
<p><strong>代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> oriData<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>			<span class="token comment">//从r[i, len-1]中找出最小值</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
				k <span class="token operator">=</span> j<span class="token punctuation">;</span>						<span class="token comment">//k记录最小值下标</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">!=</span> i<span class="token punctuation">)</span>							<span class="token comment">//交换r[i]和r[k]</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> tmp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
			data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/69/35/hLL8iH6i_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法分析：</strong></p> 
<ol><li>时间复杂度<br> 最好情况（初始序列为顺序）：不需要移动<br> 最坏情况（初始序列为逆序）：移动3(n-1)次<br> 任何情况查找最小值的比较次数相同，为：<br> <img src="https://images2.imgbox.com/f4/2c/7nw7i69S_o.png" alt="在这里插入图片描述"></li></ol> 
<p>所以，选择排序的时间复杂度也为O(n^2).<br> 2. 空间复杂度<br> 同冒泡排序一样，只有在交换顺序时需要一个辅助变量，所以空间复杂度也为O(1).</p> 
<h4><a id="_157"></a>四、直接插入排序</h4> 
<p><strong>原理</strong>：<br> 插入排序不是交换位置，而是通过比较，找到合适的位置插入。每次排序将一个待排数据按其大小插入到已经排序好的序列中，直到所有待排记录全部插入为止。<br> <strong>步骤：</strong></p> 
<ol><li>设待排序的n个元素存放在数组r[0…n-1] (注：此处数组下标从0开始)中，认为r[0]为一个有序序列</li><li>循环n-1次，每次是用顺序查找法，查找r[i] (i = 1,2,…,n-1)在已排好序的序列r[0…i-1]中的插入位置，然后将r[i]插入长度为 i 的有序序列r[0…i-1],直到将r[n-1]插入表长为n-1的有序序列r[1…n-2]中，最后得到一个表长为n的有序序列</li></ol> 
<p><strong>代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> oriData<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>			<span class="token comment">//第一个元素默认为已经排好序，所以从第二个元素开始</span>
	<span class="token punctuation">{<!-- --></span>
	    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>		<span class="token comment">//&lt;,将data[i]插入有序序列</span>
	    <span class="token punctuation">{<!-- --></span>
	        <span class="token keyword">int</span> tmp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//将待插入元素暂存</span>
	        data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//r[i -1]后移</span>
	        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//从后往前找插入位置</span>
	        <span class="token punctuation">{<!-- --></span>
	            data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//比待插入元素大的数逐个后移，直到找到合适位置</span>
	        <span class="token punctuation">}</span>
	        data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>			<span class="token comment">//将待插入元素插入到正确位置</span>
	    <span class="token punctuation">}</span>  
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/86/ef/KChJjb6i_o.png" alt="在这里插入图片描述"><br> <strong>算法分析：</strong></p> 
<ol><li> <p>时间复杂度<br> 中间某一趟的排序，内层for循环次数取决于待插入数据与前i个数据之间的关系。<br> 最好情况（初始序列为顺序），比较1次，不移动。<br> 最坏情况（初始序列为逆序），比较 i + 1 次（同前面 i 个数比较，另外和暂存数比较一次），移动 i + 2 次（前面 i 个数依次后移，另外开始将待插入数据移到临时变量中，最后从临时变量移到正确的插入位置中）</p> <p>所以整个排序过程需要执行 n-1 次<br> 最好情况下，总的比较次数达 n-1次，不移动<br> 最坏情况，总的比较次数KCN和移动次数RMN均达到最大值，分别为<br> <img src="https://images2.imgbox.com/79/9d/9Fg6cIxf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1a/cf/72Ac1tKi_o.png" alt="在这里插入图片描述"><br> 平均情况下，插入排序的比较次数和移动次数均为<img src="https://images2.imgbox.com/d0/36/WFUGHiHm_o.png" alt="在这里插入图片描述"><br> 因此，插入排序的时间复杂度为O(n^2)</p> </li><li> <p>空间复杂度<br> 只有在交换顺序时需要一个辅助变量，所以空间复杂度为O(1).</p> </li></ol> 
<p><strong>算法特点：</strong><br> 适用于初始序列基本有序(顺序)的情况，当初始序列无序，且n较大时，时间复杂度较高，不宜采用。</p> 
<h4><a id="_204"></a>五、希尔排序</h4> 
<p><strong>原理：</strong></p> 
<p>基于插入排序的快速排序算法。直接插入排序对于n比较大的无序序列效率很低，因为元素只能一点一点地从数组一端移到另一端。希尔排序时为了加快速度简单地改进了直接插入排序，也成为“缩小增量排序”。<br> 希尔排序实际是采用分组插入的方法。先将整个序列分割为几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。这样当经过几次分组排序后，整个序列的记录“基本有序”时，再对全部序列进行依次直接插入排序。</p> 
<p><strong>步骤：</strong></p> 
<ol><li>第一趟取增量d1(d1 &lt; n)把全部记录分成d1个组，所有间隔d1的数据分在同一组，在各个组中进行直接插入排序</li><li>第二趟取增量d2(d2 &lt; d1)，重复上述的分组和排序</li><li>依次类推，直到所取的增量<img src="https://images2.imgbox.com/da/7c/fE4mEfPI_o.png" alt="">,所有数据都在同一组中进行直接插入排序。</li><li></ol> 
<p>【补充】<br> 理论上，也就是说只要一个序列是递减的，并且最后一个值是1，都可作为增量序列使用。是否存在一个增量序列使得排序过程中所需的比较和移动次数较少，并且不管n有多大，算法的时间复杂度都能渐进最低，目前在数学上，没法证明某个增量序列是最好的。<br> 【常用增量序列】</p> 
<ul><li>希尔增量序列：{n/2, n/4, n/8,…, 1}</li><li>Hibbard序列：<img src="https://images2.imgbox.com/a7/51/5eXMJ8en_o.png" alt="在这里插入图片描述"></li><li>Sedgwick序列：{…, 109, 41, 19, 5,1},表达式为<img src="https://images2.imgbox.com/0f/d9/8iExiSHQ_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> oriData<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">49</span>，<span class="token number">55</span>，<span class="token number">04</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dtData<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//采用希尔增量序列，n = 10，增量序列为{5，2，1}</span>
<span class="token comment">//第一趟取增量d1=5,所有间隔为5的数据分在同一组，全部数据分为5组，在每个组分别进行直接插入排序</span>
<span class="token comment">//第二趟取增量d2=2,所有间隔为2的数据分在同一组，全部数据分为2组分别进行直接插入排序</span>
<span class="token comment">//第三趟取增量d3=1,对整个序列进行一趟直接插入排序，排序完成</span>
<span class="token keyword">void</span> <span class="token function">shellInsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> dt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dt<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>i<span class="token operator">-</span>dt<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> tmp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> dt<span class="token punctuation">;</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">-=</span>dt<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				data<span class="token punctuation">[</span>j <span class="token operator">+</span> dt<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//记录后移，直到找到插入的正确位置</span>
			<span class="token punctuation">}</span>
			data<span class="token punctuation">[</span>j<span class="token operator">+</span> dt<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>					<span class="token comment">//插入到正确的位置</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> dtData<span class="token punctuation">,</span> <span class="token keyword">int</span> dtLen<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token comment">//按照增量序列dt，对序列做dtLen趟希尔排序</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dtLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">shellInsertSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> len<span class="token punctuation">,</span> dtData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//一趟增量为dtData[i]的希尔插入排序</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/7c/6d/BpD7gmpX_o.png" alt="在这里插入图片描述"><br> <strong>算法分析：</strong></p> 
<ol><li>时间复杂度<br> 当增量大于1时，较小的数就不适合直接插入法那样一步一步地挪，而是跳跃式地挪，从而使得在进行最后一趟增量为1地插入排序中，序列基本有序，只要做少量的比较和移动即可完成排序，因此希尔排序的时间复杂度比直接插入排序低。但要具体进行分析，就是一个比较复杂的问题，因为希尔排序的时间复杂度是自己取的增量序列的函数。<br> 目前为止还没有人求得最好的增量序列，一些结论是，当增量序列为<img src="https://images2.imgbox.com/cc/b6/7XfjReWl_o.png" alt="在这里插入图片描述">时，希尔排序得时间复杂度为<img src="https://images2.imgbox.com/c0/f9/GX8eYxwh_o.png" alt="">，其中t为排序趟数，<img src="https://images2.imgbox.com/30/85/JRnYqJWC_o.png" alt="在这里插入图片描述">.还有实验结论为：当在某个特定范围内，希尔排序所需得比较和移动次数为n^1.3,当<img src="https://images2.imgbox.com/6a/1b/fZFDB5Lb_o.png" alt="在这里插入图片描述"></li><li>空间复杂度<br> 也只需要一个辅助空间，空间复杂度为O(1).</li></ol> 
<p><strong>算法特点：</strong></p> 
<ol><li>只能用于顺序存储结构，不能用于链式结构</li><li>元素总的比较和移动次数都比直接插入排序要少，n越大，效果越明显。所以适用于初始记录无序、n较大时的情况。</li></ol> 
<h4><a id="_266"></a>六、归并排序</h4> 
<p><strong>原理：</strong><br> 归并排序就是将两个或两个以上的<strong>有序表</strong>合成一个有序表的过程。将两个有序表合并成一个有序表的过程成为2-路归并，2-路归并最简单和常用，与之对对应的还有多路归并。<br> 归并排序算法的思想为：设初始序列含有n个数据，则可看成n个<strong>有序的子序列</strong>，每个子序列长度为1，然后两两归并，得到⌈n/2⌉个长度为2或为1的有序子序列；再两两归并,…如此重复，直到得到一个长度为n的有序序列为止。<br> <strong>步骤：</strong><br> 目的：将数组r[0,1,…,n-1]的记录归并排序后放入t[0,1,…,n-1]中,low = 0,high = n-1。当序列长度等于1时，递归结束，否则：</p> 
<ol><li>将当前序列一分为二，求出分裂点mid=⌊(low+high)/2⌋;</li><li>对子序列r[low,…,high]递归，进行归并排序，结果放入s[low…mid]中;</li><li>对子序列r[low+1,…,high]递归，进行归并排序，结果放入s[mid+1,…,high]中;</li><li>将有序的两个子序列s[low, …, mid]和s[mid+1, …, high]归并为一个有序序列r[low, …, high].</li></ol> 
<p><strong>代码实现：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> oriData<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">13</span>，<span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> low<span class="token punctuation">;</span>
	<span class="token keyword">int</span> tmp<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	
    <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> low<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> high<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>					<span class="token comment">//将子序列data[low, ..., mid]和data[mid+1,...,high]暂存到tmp[low, high]中</span>
    <span class="token punctuation">{<!-- --></span>
        tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    k <span class="token operator">=</span> low<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">)</span>				<span class="token comment">//将tmp中数据由小到大移动到data中</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>    data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//将剩余tmp[1, ...,mid]复制到data中</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//将剩余tmp[j, ...,high]复制到data中</span>
 <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>
     <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>					<span class="token comment">//将序列一分为二，求出分裂点mid</span>
       <span class="token function">mSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//对子序列data[low,...,mid]递归归并排序，结果放回data[slow,...,mid]</span>
       <span class="token function">mSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//对子序列data[mid+1,...,high]递归归并排序，结果放回data[mid+1,...,high]</span>
       <span class="token function">merge</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//将顺序子序列data[low, ..., mid]和将顺序子序列data[mid+1,...，high]归并到data[low, high]</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d7/44/npoOinob_o.png" alt="在这里插入图片描述"><br> <strong>算法分析：</strong></p> 
<ol><li> <p>时间复杂度<br> 当序列长度为n时，需进行<img src="https://images2.imgbox.com/22/2c/8ljalXOZ_o.png" alt="在这里插入图片描述">趟归并排序，每一趟归并，数据比较次数不超过n,数据移动次数都是n，因此归并排序的时间复杂度为<img src="https://images2.imgbox.com/78/14/WY21RNOb_o.png" alt="在这里插入图片描述"></p> </li><li> <p>空间复杂度<br> 用顺序表实现归并排序时，需要和待排序序列长度相等的辅助空间，所以空间复杂度为O(n).</p> </li></ol> 
<p><strong>算法特点：</strong><br> 可用于链式存储结构，且不用附加存储空间，但递归实现时仍需要开辟相应的递归工作栈。</p> 
<h4><a id="_328"></a>七、堆排序</h4> 
<p>篇幅较长，另作一篇，见<a href="https://blog.csdn.net/lmx11040101/article/details/122861555">C语言-堆排序</a></p> 
<h4><a id="_330"></a>八、计数排序</h4> 
<p>未完…<br> 【参考资料】<br> 《数据结构》C语言版|第2版</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/11fc1f33a08e3655275b53eb3d5e38ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面试考点：session和cookie</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e5f5ebfe6a3a2872ceaa9bc327f0c6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">less基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>