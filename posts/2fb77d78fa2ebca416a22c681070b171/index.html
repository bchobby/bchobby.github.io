<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis的集群模式：主从 &amp; 哨兵 &amp; 分片集群 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis的集群模式：主从 &amp; 哨兵 &amp; 分片集群" />
<meta property="og:description" content="基于Redis集群解决单机Redis存在的问题，在之前学Redis一直都是单节点部署 单机或单节点Redis存在的四大问题： 数据丢失问题：Redis是内存存储，服务重启可能会丢失数据 =&gt; 利用Redis数据持久化的功能将数据写入磁盘并发能力问题：单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景 =&gt; 搭建一主多从集群，实现读写分离单点故障 - 故障恢复问题：如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段 =&gt; 利用Redis哨兵，实现健康检测和自动故障恢复存储能力问题：Redis基于内存存储，单节点能存储的数据量难以满足海量数据要求 =&gt; 搭建分片集群，利用插槽机制实现动态扩容，从理论上来讲，它的存储能力是没有上限的 介绍一下Redis的集群模式？ Redis有三种主要的集群模式，用于在分布式环境中实现高可用性和数据复制，这些集群模式分别是：主从复制（Master-Slave Replication）、哨兵模式（Sentinel）和Redis Cluster模式。 1. Redis主从 搭建主从架构主从数据同步原理 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。
主从模式简介 主从复制是Redis最简单的集群模式，这个模式主要是为了解决单点故障的问题，所以将数据复制到多个副本中，这样即使有一台服务器出现故障，其它服务器依然可以继续提供服务。主从模式中，包括一个主节点（Master）和一个或多个从节点（Slave），主节点负责处理所有写操作和读操作，而从节点则复制主节点的数据，并且只能处理读操作，当主节点发送故障时，可以将一个从节点升级为主节点，实现故障转移（需要手动实现）。 1.1.主从集群结构 Redis的集群往往都是主从集群，它往往会有一个Master主节点，多个Slave / Replica从节点。 下图就是一个简单的Redis主从集群结构：
如图所示，集群中有一个Master主节点、两个Slave从节点（现在叫Replica） =&gt; 起码要包含三个节点，要有三个Redis实例，一主两从。
在Redis 5.0以前，从节点是叫Slave的，后来改名叫Replica =&gt; 都是代表从节点 当我们通过Redis的Java客户端访问主从集群时，应该做好路由：
如果是写操作，应该访问Master主节点，Master主节点会自动将数据同步给两个Slave从节点
如果是读操作，建议访问各个Slave从节点，从而分担并发压力
Master主节点可以执行set命令（写操作），Replica从节点只能执行get命令（读操作） 。
为什么Redis要做成这种主从的集群，而不是传统的负载均衡集群呢？ 这是因为Redis应用当中大多数都是读多写少的场景，也就是查询比较多，而增删改比较少，既然如此，我们更多要应对的是读的压力，那我做了主从以后，我们还可以去做读写分离， 也就是说，我在执行写操作时，我让它去访问Master主节点，但如果执行的是读操作，那我就把你的请求分发到各个Slave或Replica从节点，这样我们一主多从，多个从节点共同承担读的请求，我们的读并发能力就可以得到一个比较大的提升，所以这就是为什么要搭建主从集群的一个原因了。但是做主从集群，必须保证一点，就是客户端在读取的时候，不管访问到哪个Slave从节点，都必须要保证拿到相同的结果 =&gt; 如何保证？ 需要让Master主节点把它上面的数据同步给每一个Slave从节点，这就是Redis主从架构的一个基本模式了 1.2 搭建主从集群 1. 准备实例和配置 我们会在同一台虚拟机中开启3个Redis实例，模拟主从集群。 我们会在同一个虚拟机中利用3个Docker容器来搭建主从集群。
要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。
在同一个机器下还要修改每个实例的端口
2. 启动 &amp; 开启主从关系
分别启动多个Redis实例，虽然我们启动了3个Redis实例，但是它们并没有形成主从关系，我们需要通过命令来配置主从关系：
# Redis5.0以前 slaveof &lt;masterip&gt; &lt;masterport&gt; # Redis5.0以后 replicaof &lt;masterip&gt; &lt;masterport&gt; 有临时和永久两种模式： 永久生效：在redis." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/2fb77d78fa2ebca416a22c681070b171/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T23:53:00+08:00" />
<meta property="article:modified_time" content="2024-01-02T23:53:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis的集群模式：主从 &amp; 哨兵 &amp; 分片集群</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li><span style="color:#fe2c24;"><strong>基于Redis集群解决单机Redis存在的问题，在之前学Redis一直都是单节点部署</strong></span></li></ul> 
<h4>单机或单节点Redis存在的四大问题：</h4> 
<p><img alt="" height="891" src="https://images2.imgbox.com/33/99/SCl4ixu6_o.png" width="1200"></p> 
<ul><li><span style="color:#fe2c24;"><strong>数据丢失问题：</strong></span>Redis是内存存储，服务重启可能会丢失数据  =&gt;  <span style="color:#fe2c24;"><strong>利用Redis数据持久化的功能将数据写入磁盘</strong></span></li><li><span style="color:#fe2c24;"><strong>并发能力问题：</strong></span>单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景  =&gt;  <span style="color:#fe2c24;"><strong>搭建一主多从集群，实现读写分离</strong></span></li><li><span style="color:#fe2c24;"><strong>单点故障 - 故障恢复问题：</strong></span>如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段  =&gt;  <span style="color:#fe2c24;"><strong>利用Redis哨兵，实现健康检测和自动故障恢复</strong></span></li><li><span style="color:#fe2c24;"><strong>存储能力问题：</strong></span>Redis基于内存存储，单节点能存储的数据量难以满足海量数据要求  =&gt;  <span style="color:#fe2c24;"><strong>搭建分片集群，利用插槽机制实现动态扩容，从理论上来讲，它的存储能力是没有上限的</strong></span></li></ul> 
<h4><span style="color:#fe2c24;">介绍一下Redis的集群模式？</span></h4> 
<ul><li>Redis有三种主要的集群模式，用于在分布式环境中实现高可用性和数据复制，这些集群模式分别是：主从复制（Master-Slave Replication）、哨兵模式（Sentinel）和Redis Cluster模式。</li></ul> 
<h2>1. Redis主从</h2> 
<ul><li>搭建主从架构</li><li>主从数据同步原理</li></ul> 
<p><span style="color:#fe2c24;"><strong>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</strong></span></p> 
<h4><span style="color:#fe2c24;">主从模式简介</span></h4> 
<blockquote> 
 <ul><li>主从复制是Redis最简单的集群模式，这个模式主要是为了解决单点故障的问题，所以将数据复制到多个副本中，这样即使有一台服务器出现故障，其它服务器依然可以继续提供服务。</li><li>主从模式中，包括一个主节点（Master）和一个或多个从节点（Slave），主<span style="color:#fe2c24;"><strong>节点负责处理所有写操作和读操作，而从节点则复制主节点的数据，并且只能处理读操作</strong></span>，当主节点发送故障时，可以将一个从节点升级为主节点，实现故障转移（需要手动实现）。</li></ul> 
</blockquote> 
<p><img alt="" height="834" src="https://images2.imgbox.com/97/f4/nDkD6TFL_o.png" width="1200"></p> 
<h3>1.1.主从集群结构</h3> 
<ul><li><span style="color:#fe2c24;"><strong>Redis的集群往往都是主从集群，它往往会有一个Master主节点，多个Slave / Replica从节点。 </strong></span></li></ul> 
<p>下图就是一个简单的<span style="color:#fe2c24;"><strong>Redis主从集群结构：</strong></span></p> 
<p><img alt="" height="686" src="https://images2.imgbox.com/cf/ab/cZD2eQZ2_o.png" width="1200"></p> 
<p>如图所示，<span style="color:#fe2c24;"><strong>集群中有一个Master主节点、两个Slave从节点（现在叫Replica） =&gt;  起码要包含三个节点，要有三个Redis实例，一主两从</strong></span>。</p> 
<ul><li>在Redis 5.0以前，从节点是叫Slave的，后来改名叫Replica  =&gt;  都是代表从节点 </li></ul> 
<p>当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p> 
<ul><li> <p><span style="color:#fe2c24;"><strong>如果是写操作，应该访问Master主节点，Master主节点会自动将数据同步给两个Slave从节点</strong></span></p> </li><li> <p><span style="color:#fe2c24;"><strong>如果是读操作，建议访问各个Slave从节点，从而分担并发压力</strong></span></p> </li></ul> 
<p><span style="color:#fe2c24;"><strong>Master主节点可以执行set命令（写操作），Replica从节点只能执行get命令（读操作） 。</strong></span></p> 
<h4><span style="color:#fe2c24;">为什么Redis要做成这种主从的集群，而不是传统的负载均衡集群呢？</span></h4> 
<blockquote> 
 <ul><li>这是因为Redis应用当中大多数都是读多写少的场景，也就是查询比较多，而增删改比较少，既然如此，我们更多要应对的是读的压力，那我做了主从以后，我们还可以去做读写分离， 也就是说，我在执行写操作时，我让它去访问Master主节点，但如果执行的是读操作，那我就把你的请求分发到各个Slave或Replica从节点，这样我们一主多从，多个从节点共同承担读的请求，我们的读并发能力就可以得到一个比较大的提升，所以这就是为什么要搭建主从集群的一个原因了。</li><li>但是做主从集群，必须保证一点，就是客户端在读取的时候，不管访问到哪个Slave从节点，都必须要保证拿到相同的结果     =&gt;    如何保证？  需要让Master主节点把它上面的数据同步给每一个Slave从节点，这就是Redis主从架构的一个基本模式了</li></ul> 
</blockquote> 
<h3><span style="color:#fe2c24;">1.2 搭建主从集群 </span></h3> 
<h5><span style="color:#333333;">1. 准备实例和配置  </span></h5> 
<ul><li>我们会在同一台虚拟机中开启3个Redis实例，模拟主从集群。  </li><li> <p>我们会在同一个虚拟机中利用3个Docker容器来搭建主从集群。</p> </li><li> <p>要在同一台虚拟机开启3个实例，<span style="color:#fe2c24;"><strong>必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</strong></span></p> </li><li> <p><span style="color:#fe2c24;"><strong>在同一个机器下还要修改每个实例的端口</strong></span></p> </li></ul> 
<p><span style="color:#333333;"><strong>2. 启动 &amp; 开启主从关系</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>分别启动多个Redis实例</strong></span>，<span style="color:#fe2c24;"><strong>虽然我们启动了3个Redis实例，但是它们并没有形成主从关系，我们需要通过命令来配置主从关系：</strong></span></p> 
<pre><code class="language-bash"># Redis5.0以前
slaveof &lt;masterip&gt; &lt;masterport&gt;
# Redis5.0以后
replicaof &lt;masterip&gt; &lt;masterport&gt;</code></pre> 
<h5><span style="color:#fe2c24;">有临时和永久两种模式：</span></h5> 
<ul><li> <p><span style="color:#fe2c24;"><strong>永久生效：在redis.conf文件中利用slaveof命令指定Master主节点的IP和端口</strong></span></p> </li><li> <p><span style="color:#fe2c24;"><strong>临时生效：直接利用redis-cli控制台输入slaveof命令，并且指定Master主节点的IP和端口</strong></span></p> </li></ul> 
<p><span style="color:#fe2c24;"><strong>INFO replication：查看集群的状态信息</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>这样，就可以实现读写分离了，如果在Slave从节点上执行set写操作，会报错：</strong></span></p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/70/4b/r9LCsXbG_o.png" width="953"></p> 
<h4><span style="color:#fe2c24;">假设有A、B两个Redis实例，如何让B作为A的Slave从节点？</span></h4> 
<ul><li>在B节点执行命令：<span style="color:#fe2c24;"><strong>slaveof      A的IP     A的Port端口 </strong></span></li></ul> 
<h3><span style="color:#fe2c24;">1.3 数据同步原理 </span></h3> 
<ul><li>Redis主从同步的底层工作原理 </li></ul> 
<h4><span style="color:#fe2c24;">1. 全量同步</span></h4> 
<ul><li><span style="color:#fe2c24;"><strong>主从第一次建立连接时</strong></span>，会执行<span style="color:#fe2c24;"><strong>全量同步  =&gt;  主从第一次同步是全量同步，</strong></span>将Master主节点的所有数据都拷贝给Replica从节点，流程：</li></ul> 
<p><img alt="" height="962" src="https://images2.imgbox.com/5d/f0/G4BO0jI1_o.png" width="1200"></p> 
<ul><li>将来基于数据版本可以做一个控制</li></ul> 
<p>首先，从节点通过replicaof命令与主节点建立连接，请求数据同步，主节点会判断是否为第一次连接，如果是，则将完整数据发送给Slave从节点，Master主节点使用RDB持久化技术，将内存中的数据生成RDB文件，并在后台发送给Slave从节点，Slave清空本地数据，加载Master主节点的RDB，这样就能确保Slave节点与Master节点的数据基本一致了。 </p> 
<h5><span style="color:#fe2c24;">为什么是基本一致而不是完全一致呢？ </span></h5> 
<ul><li>bgsave是异步执行的，在执行的过程当中，Matser节点的主进程还会去处理用户的请求，也就是说会有新的数据写入，新写入的数据并没有发给Slave从节点，所以Master节点的主进程除了处理这些新的数据以外，它还会把这些新写入的数据命令记录到repl_baklog的这样一个缓冲区当中，它是一个内存的缓冲区，repl_backlog里面记录的就是RDB期间收到的一些新的命令，并持续将log中的命令发送给Slave，repl_baklog里面记录的所有命令 + RDB文件里面的数据合在一起就是我们Master节点上的完整数据了。 </li></ul> 
<p>.........Slave执行接收到的命令，保持与Master之间的同步，这样就能保证Slave节点与Master节点上面的数据完全一致了。 </p> 
<h5><span style="color:#fe2c24;">为什么叫全量同步呢？</span></h5> 
<ul><li>因为它有一个RDB的过程，它会把内存形成快照，整体发送给Slave，所以叫全量同步，全量同步是比较消耗性能的，因为生成RDB文件的速度比较慢，这种同步只有在第一次建立连接时才会去做。 </li></ul> 
<h5><span style="color:#fe2c24;">这里有一个问题，Master主节点如何得到Slave从节点是否是第一次来同步呢？Master如何判断Slave节点是不是第一次来做数据同步？ </span> </h5> 
<ul><li>这里会用到两个很重要的概念作为判断依据：</li></ul> 
<ol><li><strong><span style="color:#fe2c24;">Replication Id</span>：<span style="color:#fe2c24;"> 简称replid，是数据集的标记</span></strong>，replid一致则说明是同一数据集；每一个Master都有自己唯一的replid，Slave节点则会继承Master节点的replid。</li><li><span style="color:#fe2c24;"><strong>offset</strong>：<strong>偏移量，记录已同步的数据量</strong></span>，它会随着记录在repl_baklog中的数据增多而逐渐增大；Slave完成同步时也会记录当前同步的offset，Slave的offset一定是小于等于Master的offset，如果Slave的offset小于Matser的offset，则说明Slave数据落后于Master，需要更新。</li></ol> 
<p><span style="color:#333333;">因此，Slave做数据同步，必须向Master声明自己的</span><span style="color:#fe2c24;"><strong>replication id</strong></span><span style="color:#333333;">和</span><span style="color:#fe2c24;"><strong>offset</strong></span><span style="color:#333333;">，Master才可以判断到底需要同步哪些数据，基于offset去判断数据同步的进度。 </span></p> 
<p>由于我们在执行slaveof命令之前，所有Redis节点都是Master，即每个Slave在成为Slave之前，都有自己的replid和offset，当我们第一次执行slaveof命令，与Master建立主从关系时，发送的replid和offset是自己的，与Master肯定不一致，在数据同步请求时，<span style="color:#fe2c24;"><strong>Master判断Slave发送来的replid与自己的ID是否一致，如果发现不一致，则说明是第一次同步</strong></span>，说明这是一个全新的Slave，此时就知道要做全量同步了，主节点Master会将自己的replid和offset都发送给这个Slave，Slave保存这些信息到本地，并且Slave将Master的replid作为自己的ID，自此以后Slave的replid就与Matser一致了。</p> 
<p><span style="color:#fe2c24;"><strong>因此，Master判断一个节点是否是第一次同步的依据，就是看replid是否一致，流程如图：</strong></span></p> 
<p><img alt="" height="954" src="https://images2.imgbox.com/f2/6d/yL8vQsZ1_o.png" width="1200"></p> 
<p>全量同步的完整流程描述：</p> 
<ul><li>Slave从节点执行replicaof命令与Master主节点建立连接，并尝试请求增量同步</li><li>Master主节点判断replid，发现不一致，拒绝增量同步，开始进行<span style="color:#fe2c24;"><strong>全量同步 =&gt; Full resync</strong></span></li><li>Master将完整内存数据生成RDB，发送RDB文件到Slave</li><li>Slave清空本地数据（Flushing old data  =&gt;  清空本地旧数据），加载接收到的Master所发送的RDB文件</li><li>Master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给Slave</li><li>Slave执行接收到的命令，保持与Master之间的同步</li></ul> 
<h4><span style="color:#fe2c24;">2. 增量同步 </span></h4> 
<ul><li>主从第一次同步是<span style="color:#fe2c24;"><strong>全量同步</strong></span>，但如果Slave重启后同步（不管是因为故障重启还是自己重启），则执行<span style="color:#fe2c24;"><strong>增量同步</strong></span> </li><li>全量同步需要先做RDB，然后将RDB文件通过网络传输给Slave，成本太高了，因此除了第一次做全量同步，其它大多数时候Slave与Master都是做<span style="color:#fe2c24;"><strong>增量同步</strong></span>。</li></ul> 
<h5><span style="color:#fe2c24;">什么是增量同步？</span></h5> 
<ul><li>就是<span style="color:#fe2c24;"><strong>只更新Slave与Master存在差异的部分数据  =&gt;  差异的这一部分数据就是Slave在宕机期间错过的那些数据，增量同步是在主从服务器数据存在差异时进行的一种同步方式</strong></span>。 </li></ul> 
<p><span style="color:#fe2c24;"><strong>增量同步是在Slave从服务器或者Slave从节点已经进行过全量同步后，Master主节点和Slave从节点之间的数据存在差异时进行的同步操作。 </strong></span></p> 
<p><img alt="" height="729" src="https://images2.imgbox.com/0d/b0/3gGzBs0O_o.png" width="1200"></p> 
<ul><li><span style="color:#fe2c24;"><strong>Master主服务器从上次Slave同步的offset位置开始发送增量数据给Slave从服务器。 </strong></span></li></ul> 
<h5><span style="color:#fe2c24;">那么Master怎么知道Slave与自己的数据差异在哪里呢?  =&gt;  repl_baklog原理</span></h5> 
<ul><li>这就要说到全量同步时的repl-baklog文件了，这个文件的本质是一个固定大小的数组，只不过数组是环形，也就是说<span style="color:#fe2c24;"><strong>角标达到数组末尾后，会再次从0开始读写，这样数组头部的数据就会被覆盖。 </strong></span></li></ul> 
<p><span style="color:#fe2c24;"><strong>repl_baklog中记录的就是Master当前的offset和Slave已经拷贝到的offset：</strong></span></p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/c3/16/3i8DKaoF_o.png" width="206"></p> 
<p><span style="color:#fe2c24;"><strong>要增量同步拷贝的就是Slave的offset到Master最新的offset之间的这一部分数据</strong></span>，<span style="color:#fe2c24;"><strong>所以repl_baklog的本质就是Slave与Master它们数据差异的一个缓冲区</strong></span>，repl_baklog只要记录了Slave尚未同步的这部分数据就ok了， <span style="color:#fe2c24;"><strong>只要Slave与Master之间的数据差距别超过这个环的存储上限，那你永远能够从这个环里找到你所需要的数据，这样就永远能实现增量同步，但如果你Slave与Master之间的差距太多，已经超过了这个存储上限了，那么这个时候就没有办法做增量同步了。</strong></span></p> 
<p>也就是说，<span style="color:#fe2c24;"><strong>如果Slave出现网络阻塞</strong></span>，导致Master的offset远远超过了Slave的offset，如果Master持续写入新的数据，Master的offset就会覆盖repl_baklog中旧的数据，直到将Slave现在的offset也覆盖，此时如果Slave恢复，需要同步，却发现自己的offset都没有了，即Slave的offeset被覆盖，无法找到对应的offset，也就无法完成增量同步了，则此时只能做全量同步：</p> 
<figure class="image"> 
 <img alt="" height="227" src="https://images2.imgbox.com/3c/26/dWj4306a_o.png" width="203"> 
 <figcaption>
   、 
  <br> 棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。 
 </figcaption> 
</figure> 
<h5><span style="color:#fe2c24;">结论：</span></h5> 
<ul><li>repl_baklog大小有上限，写满后会覆盖最早的数据，如果Slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于repl_baklog做增量同步，只能再次全量同步   =&gt;  只能尽可能的避免。</li></ul> 
<h4><span style="color:#fe2c24;">3. 主从同步优化</span></h4> 
<ul><li><span style="color:#fe2c24;"><strong>主从同步可以保证主从数据的一致性，非常重要。 </strong></span></li></ul> 
<h5><span style="color:#fe2c24;">可以从以下几个方面来优化Redis主从集群：</span></h5> 
<p>一方面是尽可能的去减少全量同步，因为全量同步它的性能比较差，另一方面要去优化这个全量同步的性能 </p> 
<ul><li>在Master中配置repl-diskless-sync  yes启用无磁盘复制（就是当我去写RDB文件时，我不把它写到磁盘的IO流了，而是写到网络当中直接发给Slave，减少了一次磁盘读写，性能就提高了很多），避免全量同步时的磁盘IO    =&gt;   使用场景：你的磁盘比较慢，而网络却非常的快，<span style="color:#fe2c24;"><strong>如果你网络带宽不够，此时反而可能会导致网络阻塞</strong></span></li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO以及网络IO</li><li>适当提高repl_baklog的大小，发现Slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个Master上的Slave节点数量，如果实在是太多Slave，则可以<span style="color:#fe2c24;"><strong>采用主-从-从链式结构，减少Master压力  =&gt;  让两个Slave从节点也去 </strong></span></li></ul> 
<p><span style="color:#fe2c24;"><strong>主-从-从链式结构是一种用于减轻主节点同步压力的方法</strong></span>。在这种结构中，<span style="color:#fe2c24;"><strong>一个主节点为主，两个从节点为从，再由这两个从节点为主，各自再带领两个从节点，</strong></span>这样，主节点可以将同步任务交给这两个中间的从节点，从而减少自己的压力。</p> 
<figure class="image"> 
 <img alt="" height="607" src="https://images2.imgbox.com/78/e1/bX6chn8n_o.png" width="1200"> 
 <figcaption> 
  <strong>主-从-从架构图</strong> 
 </figcaption> 
</figure> 
<h4><span style="color:#fe2c24;">简述全量同步和增量同步的区别？</span></h4> 
<ul><li><span style="color:#fe2c24;"><strong>全量同步：</strong></span>Master将完整内存数据生成RDB，发送RDB到Slave，后续命令则记录在repl_baklog，逐个发送给Slave</li><li><span style="color:#fe2c24;"><strong>增量同步：</strong></span>Slave提交自己的offset到Master，Master获取repl_baklog中从offset之后的命令给Slave </li></ul> 
<h4><span style="color:#fe2c24;">什么时候执行全量同步？</span></h4> 
<ul><li>Slave节点第一次连接Master节点时</li><li>Slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul> 
<h4><span style="color:#fe2c24;">什么时候执行增量同步？</span></h4> 
<ul><li>Slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul> 
<h4><span style="color:#fe2c24;">主从复制的优缺点总结：</span></h4> 
<ul><li>主从复制的优势在于简单易于，适用于读多写少的场景，它提供了数据备份功能，并且有很好的扩展性，只要增加更多的从节点，就能让整个集群的读的能力不断提升。</li><li>但是<span style="color:#fe2c24;"><strong>主从模式最大的缺点，就是不具备故障自动转移的能力，没有办法做容错和恢复</strong></span>。</li><li><span style="color:#fe2c24;"><strong>主节点和从节点的宕机都会导致客户端部分读写请求失败</strong></span>，需要人工介入让节点恢复或者手动切换一台从节点服务器变成主节点服务器才可以，并且在主节点宕机时，如果数据没有及时复制到从节点，也会导致数据的不一致。 </li></ul> 
<p><img alt="" height="815" src="https://images2.imgbox.com/b5/32/RCaKmHie_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong>为了解决主从模式的无法自动容错及恢复的问题，Redis引入了一种哨兵模式的集群架构，从而来保证主从集群的高可用。</strong></span></p> 
<h2>2. Redis哨兵 </h2> 
<h4><span style="color:#fe2c24;">哨兵模式简介</span></h4> 
<ul><li>哨兵模式是在主从复制的基础上加入了哨兵节点，哨兵节点是一种特殊的Redis节点，用于监控主节点和从节点的状态，当主节点发生故障时，哨兵节点可以自动进行故障转移，选择一个合适的从节点升级为主节点，并通知其它的从节点和应用程序进行更新。</li></ul> 
<p><img alt="" height="1021" src="https://images2.imgbox.com/a0/7b/pCDoCuLP_o.png" width="1200">​​​​​​​在原来的架构中，引入哨兵节点，其作用是监控Redis主节点和从节点的状态，每个Redis实例都可以作为哨兵节点，通常需要部署多个哨兵节点（Sentinel也是需要集群部署），以确保故障转移的可靠性。  </p> 
<h4><span style="color:#fe2c24;">哨兵工作机制</span></h4> 
<ul><li>Redis提供了哨兵（Sentinel）机制来监控主从集群的健康状态，实现主从集群的自动故障恢复，确保集群的高可用性。</li></ul> 
<h4><span style="color:#fe2c24;">哨兵的作用：</span></h4> 
<figure class="image"> 
 <img alt="" height="910" src="https://images2.imgbox.com/58/87/fxXNL5H7_o.png" width="1157"> 
 <figcaption> 
  <strong>哨兵集群作用原理图</strong> 
 </figcaption> 
</figure> 
<h5><span style="color:#fe2c24;">Sentinel哨兵的作用如下：</span></h5> 
<ul><li><span style="color:#fe2c24;"><strong>集群状态监控：</strong></span>Sentinel会不断检查Master和Slave是否预期工作</li><li><span style="color:#fe2c24;"><strong>自动故障恢复或故障转移（failover - 故障转移或容错）</strong></span>：如果Master故障，Sentinel会将一个Slave提升为Master，当故障实例恢复后会成为Slave，会以新的Master为主</li><li><span style="color:#fe2c24;"><strong>状态通知：</strong></span><span style="color:#0d0016;">Sentinel哨兵节点充当Redis客户端的服务发现来源，哨兵节点通过发布订阅功能来通过客户端有关主节点状态变化的消息，当集群发送failover故障转移时，Sentinel会将最新集群消息推送给Redis的客户端，客户端收到消息后，会更新配置，将新的主节点信息应用于连接池，从而使客户端可以继续与新的主节点进行交互</span> </li></ul> 
<p>Sentinel怎么知道一个Redis节点是否宕机呢？ Sentinel如何判断一个redis实例是否健康？</p> 
<h4><span style="color:#fe2c24;">服务状态监控</span></h4> 
<p><span style="color:#fe2c24;"><strong>Sentinel哨兵节点基于心跳机制监测服务状态，哨兵节点每隔1秒向集群中的每个实例（所有主节点和从节点）发送ping命令，并通过实例的响应结果来做出判断：</strong></span></p> 
<ul><li><span style="color:#fe2c24;"><strong>主观下线（sdown）：</strong></span>如果某Sentinel哨兵节点发现某Redis实例未在规定时间内发送PONG响应，哨兵节点会将该节点标记未主观下线（我个人认为你下线了，但不一定真的下线了，因为是超时未响应，有可能是因为网络阻塞导致的响应超时）。</li><li><span style="color:#fe2c24;"><strong>客观下线（odown）：</strong></span><span style="color:#333333;">若超过指定数量（quorum）的Sentinel哨兵节点都认为该Redis节点或该实例主观下线，则该实例</span><span style="color:#fe2c24;"><strong>客观下线</strong></span><span style="color:#333333;">  /  如果一个Redis节点被多数哨兵节点都标记为主观下线，那么它将被标记为</span><span style="color:#fe2c24;"><strong>客观下线。quorum可以在redis.config配置文件里面配，quorum值最好超过Sentinel实例数量的一半，Sentinel节点数量至少3台（3 / 2 =&gt; 2）</strong></span></li></ul> 
<p><img alt="" height="727" src="https://images2.imgbox.com/7e/51/T5QoxYCM_o.png" width="1129"></p> 
<ul><li>当主节点被标记为客观下线时， 哨兵节点会触发故障转移过程，它会从所有健康的从节点中选举一个新的主节点，并将所有从节点切换到新的主节点，实现自动故障转移，同时，哨兵节点会更新所有客户端的配置，指向新的主节点。  </li></ul> 
<h4><span style="color:#fe2c24;">选举新的Master</span></h4> 
<p>一旦发现Master故障，Sentinel需要在Slave中选择一个作为新的Master，选择依据是这样的：</p> 
<ul><li>首先判断Slave节点与Master节点断开时间长短，如果断开时间超过(down -after-milliseconds * 10)则会排除该Slave节点，因为断开时间越长，丢失的数据肯定就越多，这样的节点会直接排除，它就不具备选举权</li><li>然后判断Slave节点的slave-priority值，默认值都为1，越小优先级越高，如果是0则永不参加选举  =&gt;  既然默认都是1，跳过  </li><li><span style="color:#fe2c24;"><strong>如果slave-priority一样，则判断Slave节点的offset值，offset代表当前Slave节点与Master节点之间数据同步的一个进度，值越大说明跟Master之间的数据越接近，越大说明数据越新，优先级越高</strong></span></li><li>最后是判断Slave节点的run_id  -  运行ID大小，越小优先级越高（通过info  server可以查看run_id）</li></ul> 
<h5><span style="color:#fe2c24;">问题来了，当选出一个新的master后，该如何实现身份切换呢？故障转移步骤有哪些？ </span></h5> 
<ul><li>首先要在多个Sentinel中选举一个leader  =&gt;  第一个确认Master客观下线的人会立刻发起投票，一定会成为leader</li><li>由leader执行failover故障转移</li><li>选定一个Slave作为新的Master，并且执行<span style="color:#fe2c24;"><strong>slaveof  no  one</strong></span>命令，让该节点成为Master</li><li>然后让所有其它Slave节点都执行   slaveof  新Master的IP  新Master的Port端口  命令，让这些Slave成为新Master的从节点，开始从新的Master上同步数据</li><li>最后，Sentinel修改故障节点的配置，将故障节点标记为Slave，当故障节点恢复后会自动成为新的Master的Slave节点</li></ul> 
<h4><span style="color:#fe2c24;">RedisTemplate的哨兵模式</span></h4> 
<ul><li><span style="color:#fe2c24;"><strong>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发送变化，Redis的客户端必须感知这种变化，及时更新连接信息。</strong></span></li><li>Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换（RedisTemplate底底层就用的lettuce）。 </li></ul> 
<p><span style="color:#fe2c24;"><strong>可以利用RedisTemplate连接哨兵集群：</strong></span></p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<h5><span style="color:#fe2c24;">总结：</span></h5> 
<ul><li>Redis哨兵这个集群模式的优点就是为整个集群系统提供了一种故障转移和恢复的能力。</li></ul> 
<h2>3. Redis分片集群</h2> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51cb60f605f4b51e7f3f1b2dc94cb993/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MINCO&#43;汽车</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e5d961a106ae2beb6f145ef9d7d56eb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【零基础入门TypeScript】类型和变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>