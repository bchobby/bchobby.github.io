<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>应用程序安装流程 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="应用程序安装流程" />
<meta property="og:description" content="https://maoao530.github.io/2017/01/18/package-install/
本文介绍APK的安装流程。
一、安装流程图 APK安装流程，总体可以下图流程，用ProcessOn画的，凑合看：
从上图我们可以看到apk安装到最后都会调用到这个flow：
PMS.scanPackageTracedLI =&gt; PMS.scanPackageLI =&gt; PMS.scanPackageDirtyLI
关于这个flow，之前的博客有详细介绍过，本文不再展开 : https://maoao530.github.io/2017/01/10/packagemanager/
后续的博文会根据这张图展开说明。
二、APK文件结构 APK(Android Package)，可以看做是一个zip压缩包，可以通过解压缩工具解开，其文件结构如下：
目录 or 文件描述assert存放的原生资源文件,通过AssetManager类访问libnative库文件META-INF存放签名信息，用来保证APK包的完整性和系统的安全。系统安装APK时，应用管理器会按照对应算法对包里文件做校验，如果校验结果与META-INF中内容不一致，则不会安装这个APK。res种资源文件系统会在R.java里面自动生成该资源文件的ID，所以访问这种资源文件比较简单，通过R.XXX.ID即可AndroidManifest.xml每个应用都必须定义和包含，描述应用的名字、版本权限、引用的库文件等信息。apk中的AndroidManifest.xml经过压缩，可以通过AXMLPrinter2工具解开。classes.dex是JAVA源码编译后生成的JAVA字节码文件。但Android使用的dalvik虚拟机与标准的JAVA虚拟机不兼容，dex文件与class文件相比，不论是文件结构还是opcode都不一样。resources.arsc编译后的二进制资源文件。 三、APK安装方法 APK有下面4种安装方法：
方法描述开机过程中安装开机时完成，没有安装界面，如系统应用、其它预置应用adb工具安装没有安装界面，adb install/push xxxx.apk第三方应用安装通过packageinstaller.apk进行安装，有安装界面，如打开文件管理器并点击sdk卡里APK文件网络下载应用安装通过google market应用完成，没有安装界面 简单说明下apk安装的基本过程：
拷贝目标apk到指定文件目录调用scanPackageLI为apk文件在系统中注册信息 四、应用程序安装过程 上述几种安装方法最终都通过PackageManagerService.scanPackageLI完成，总结起来大致有以下三种方式：
adb push：
PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件
frameworks\base\services\java\com\android\server\pm\PackageManagerService.java
adb install：
安装入口函数为Pm.runInstall
frameworks\base\cmds\pm\src\com\android\commands\pm\Pm.java
网络下载应用安装和第三方应用安装：
安装入口函数为ApplicationPackageManager.installPackage
frameworks\base\core\java\android\app\ApplicationPackageManager.java
接下来我们来分别详细说明这些安装流程：
五、adb push Android 4.4平台，PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件。
如果是添加事件，则调用scanPackageLI，并使用updatePermissionsLPw授权；如果是删除事件则调用removePackageLI移除该apk的相关信息。最后都要调用writeLPr重新保存相关信息到packages.xml。
关于AppDirObserver具体如何监听的，可以查看：AppDirObserver
不过我在android 7.0 sdk里面没有看到这个类，难道7.0把这个功能砍了？手头没有7.0平台，不好验证。
我猜测现在通过adb push apk到data/app或者system/app的apk，如果这个监听的功能砍了，那么应该是会通过reboot重启系统，走PMS.main流程，scanDir–&gt;scanPackageLI去安装apk。
以上待填坑。
六、adb install adb install 的安装方式，会调用system/core/adb/commandline.cpp中的adb_commandline函数：
1
2
3
4
5
adb_commandline
install_app_legacy or install_app" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/320d140e6c844e3697b7c5f42b659c2c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-30T15:43:23+08:00" />
<meta property="article:modified_time" content="2018-07-30T15:43:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">应用程序安装流程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://maoao530.github.io/2017/01/18/package-install/" rel="nofollow">https://maoao530.github.io/2017/01/18/package-install/</a></p> 
<p> </p> 
<p>本文介绍APK的安装流程。</p> 
<p><a id="more"></a></p> 
<h2 id="一、安装流程图">一、安装流程图</h2> 
<p>APK安装流程，总体可以下图流程，用ProcessOn画的，凑合看：</p> 
<p><a href="https://maoao530.github.io/img/archives/package-install.png" rel="nofollow"><img alt="package_install" class="has" src="https://images2.imgbox.com/f6/75/cRSzqxGJ_o.png"></a></p> 
<p>从上图我们可以看到apk安装到最后都会调用到这个flow：</p> 
<blockquote> 
 <p>PMS.scanPackageTracedLI =&gt; PMS.scanPackageLI =&gt; PMS.scanPackageDirtyLI</p> 
</blockquote> 
<p>关于这个flow，之前的博客有详细介绍过，本文不再展开 : <a href="https://maoao530.github.io/2017/01/10/packagemanager/" rel="nofollow">https://maoao530.github.io/2017/01/10/packagemanager/</a></p> 
<p>后续的博文会根据这张图展开说明。</p> 
<h2 id="二、APK文件结构">二、APK文件结构</h2> 
<p>APK(Android Package)，可以看做是一个zip压缩包，可以通过解压缩工具解开，其文件结构如下：</p> 
<table><thead><tr><th>目录 or 文件</th><th>描述</th></tr></thead><tbody><tr><td>assert</td><td>存放的原生资源文件,通过AssetManager类访问</td></tr><tr><td>lib</td><td>native库文件</td></tr><tr><td>META-INF</td><td>存放签名信息，用来保证APK包的完整性和系统的安全。系统安装APK时，应用管理器会按照对应算法对包里文件做校验，如果校验结果与META-INF中内容不一致，则不会安装这个APK。</td></tr><tr><td>res</td><td>种资源文件系统会在R.java里面自动生成该资源文件的ID，所以访问这种资源文件比较简单，通过R.XXX.ID即可</td></tr><tr><td>AndroidManifest.xml</td><td>每个应用都必须定义和包含，描述应用的名字、版本权限、引用的库文件等信息。apk中的AndroidManifest.xml经过压缩，可以通过AXMLPrinter2工具解开。</td></tr><tr><td>classes.dex</td><td>是JAVA源码编译后生成的JAVA字节码文件。但Android使用的dalvik虚拟机与标准的JAVA虚拟机不兼容，dex文件与class文件相比，不论是文件结构还是opcode都不一样。</td></tr><tr><td>resources.arsc</td><td>编译后的二进制资源文件。</td></tr></tbody></table> 
<h2 id="三、APK安装方法">三、APK安装方法</h2> 
<p>APK有下面4种安装方法：</p> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>开机过程中安装</td><td>开机时完成，没有安装界面，如系统应用、其它预置应用</td></tr><tr><td>adb工具安装</td><td>没有安装界面，adb install/push xxxx.apk</td></tr><tr><td>第三方应用安装</td><td>通过packageinstaller.apk进行安装，有安装界面，如打开文件管理器并点击sdk卡里APK文件</td></tr><tr><td>网络下载应用安装</td><td>通过google market应用完成，没有安装界面</td></tr></tbody></table> 
<p>简单说明下apk安装的基本过程：</p> 
<ul><li>拷贝目标apk到指定文件目录</li><li>调用scanPackageLI为apk文件在系统中注册信息</li></ul> 
<h2 id="四、应用程序安装过程">四、应用程序安装过程</h2> 
<p>上述几种安装方法最终都通过PackageManagerService.scanPackageLI完成，总结起来大致有以下三种方式：</p> 
<ul><li> <p><strong>adb push：</strong><br> PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件<br> frameworks\base\services\java\com\android\server\pm\PackageManagerService.java</p> </li><li> <p><strong>adb install：</strong><br> 安装入口函数为Pm.runInstall<br> frameworks\base\cmds\pm\src\com\android\commands\pm\Pm.java</p> </li><li> <p><strong>网络下载应用安装和第三方应用安装：</strong><br> 安装入口函数为ApplicationPackageManager.installPackage<br> frameworks\base\core\java\android\app\ApplicationPackageManager.java</p> </li></ul> 
<p>接下来我们来分别详细说明这些安装流程：</p> 
<h2 id="五、adb-push">五、adb push</h2> 
<p>Android 4.4平台，PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件。<br> 如果是添加事件，则调用scanPackageLI，并使用updatePermissionsLPw授权；如果是删除事件则调用removePackageLI移除该apk的相关信息。最后都要调用writeLPr重新保存相关信息到packages.xml。</p> 
<p>关于AppDirObserver具体如何监听的，可以查看：<a href="http://blog.csdn.net/new_abc/article/details/12949535">AppDirObserver</a></p> 
<p>不过我在android 7.0 sdk里面没有看到这个类，难道7.0把这个功能砍了？手头没有7.0平台，不好验证。</p> 
<p>我猜测现在通过adb push apk到data/app或者system/app的apk，如果这个监听的功能砍了，那么应该是会通过reboot重启系统，走PMS.main流程，scanDir–&gt;scanPackageLI去安装apk。</p> 
<p>以上待填坑。</p> 
<h2 id="六、adb-install">六、adb install</h2> 
<p>adb install 的安装方式，会调用system/core/adb/commandline.cpp中的adb_commandline函数：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td><td> <pre> </pre> <p>adb_commandline</p> <p>install_app_legacy or install_app</p> <p>pm_command</p> <p>send_shell_command</p> <p>Pm.runInstall()</p> </td></tr></tbody></table> 
<p> </p> 
<p>这个过程会把apk文件copy到data/local/tmp/目录下，然后向shell服务发送pm命令安装apk，最后调用<code>Pm.runInstall()</code>方法来安装apk。</p> 
<h3 id="6-1-pm-runInstall">6.1 pm.runInstall</h3> 
<p>frameworks\base\cmds\pm\src\com\android\commands\pm\Pm.java</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> </td><td> <pre> </pre> <p>private int runInstall() throws RemoteException {<!-- --></p> <p>final InstallParams params = makeInstallParams();</p> <p>// 1. 创建session</p> <p>final int sessionId = doCreateSession(params.sessionParams,</p> <p>params.installerPackageName, params.userId);</p> <p>try {<!-- --></p> <p>final String inPath = nextArg();</p> <p>if (inPath == null &amp;&amp; params.sessionParams.sizeBytes == 0) {<!-- --></p> <p>System.err.println("Error: must either specify a package size or an APK file");</p> <p>return 1;</p> <p>}</p> <p>// 2. 写session</p> <p>if (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, "base.apk",</p> <p>false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) {<!-- --></p> <p>return 1;</p> <p>}</p> <p>// 3. 提交Session</p> <p>if (doCommitSession(sessionId, false /*logSuccess*/)</p> <p>!= PackageInstaller.STATUS_SUCCESS) {<!-- --></p> <p>return 1;</p> <p>}</p> <p>System.out.println("Success");</p> <p>return 0;</p> <p>} finally {<!-- --></p> <p>try {<!-- --></p> <p>mInstaller.abandonSession(sessionId);</p> <p>} catch (Exception ignore) {<!-- --></p> <p>}</p> <p>}</p> <p>}</p> </td></tr></tbody></table> 
<p>从上面的代码来看，runInstall主要进行了三件事，即创建session、对session进行写操作，最后提交session。</p> 
<h4 id="6-1-1-doCreateSession">6.1.1 doCreateSession</h4> 
<p>实际调用的是PackageInstallerService的createSession，这个过程主要是为APK安装做好准备工作，例如权限检查、目的临时文件的创建等， 最终创建出PackageInstallerSession对象。PackageInstallerSession可以看做是”安装APK”这个请求的封装，其中包含了处理这个请求需要的一些信息。<br> 实际上PackageInstallerSession不仅是分装请求的对象，其自身还是个服务端。</p> 
<h4 id="6-1-2-doWriteSession">6.1.2 doWriteSession</h4> 
<p>通过PackageInstallerSession将/data/local/tmp的apk拷贝到终端目录内。</p> 
<h4 id="6-1-3-doCommitSession">6.1.3 doCommitSession</h4> 
<p>doWriteSession结束后，如果没有出现任何错误，那么APK源文件已经copy到目的地址了，doCommitSession最终会调用到PMS.installStage来安装apk，调用流程如下：</p> 
<p><code>PackageInstallerSession.commit ==&gt; commitLocked(); ==&gt; PMS.installStage()</code></p> 
<p>PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> </td><td> <pre> </pre> <p>void installStage(String packageName, File stagedDir, String stagedCid,</p> <p>IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams,</p> <p>String installerPackageName, int installerUid, UserHandle user,</p> <p>Certificate[][] certificates) {<!-- --></p> <p>if (DEBUG_EPHEMERAL) {<!-- --></p> <p>if ((sessionParams.installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0) {<!-- --></p> <p>Slog.d(TAG, "Ephemeral install of " + packageName);</p> <p>}</p> <p>}</p> <p>final VerificationInfo verificationInfo = new VerificationInfo(</p> <p>sessionParams.originatingUri, sessionParams.referrerUri,</p> <p>sessionParams.originatingUid, installerUid);</p> <p>final OriginInfo origin;</p> <p>if (stagedDir != null) {<!-- --></p> <p>origin = OriginInfo.fromStagedFile(stagedDir);</p> <p>} else {<!-- --></p> <p>origin = OriginInfo.fromStagedContainer(stagedCid);</p> <p>}</p> <p>final Message msg = mHandler.obtainMessage(INIT_COPY);</p> <p>final InstallParams params = new InstallParams(origin, null, observer,</p> <p>sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid,</p> <p>verificationInfo, user, sessionParams.abiOverride,</p> <p>sessionParams.grantedRuntimePermissions, certificates);</p> <p>params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));</p> <p>msg.obj = params;</p> <p>Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "installStage",</p> <p>System.identityHashCode(msg.obj));</p> <p>Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "queueInstall",</p> <p>System.identityHashCode(msg.obj));</p> <p>mHandler.sendMessage(msg);</p> <p>}</p> </td></tr></tbody></table> 
<p>PackageHandler用于处理apk的安装请求等消息，后面分析。</p> 
<h2 id="七、ApplicationPackageManager">七、ApplicationPackageManager</h2> 
<p>网络下载应用安装或者通过第三方应用安装，最终都会通过ApplicationPackageManager.installPackage来安装：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> </td><td> <pre> </pre> <p>public void installPackage(Uri packageURI, PackageInstallObserver observer,</p> <p>int flags, String installerPackageName) {<!-- --></p> <p>installCommon(packageURI, observer, flags, installerPackageName, mContext.getUserId());</p> <p>}</p> <p>private void installCommon(Uri packageURI,</p> <p>PackageInstallObserver observer, int flags, String installerPackageName,</p> <p>int userId) {<!-- --></p> <p>if (!"file".equals(packageURI.getScheme())) {<!-- --></p> <p>throw new UnsupportedOperationException("Only file:// URIs are supported");</p> <p>}</p> <p>final String originPath = packageURI.getPath();</p> <p>try {<!-- --></p> <p>// PMS.installPackageAsUser</p> <p>mPM.installPackageAsUser(originPath, observer.getBinder(), flags, installerPackageName,</p> <p>userId);</p> <p>} catch (RemoteException e) {<!-- --></p> <p>throw e.rethrowFromSystemServer();</p> <p>}</p> <p>}</p> </td></tr></tbody></table> 
<p>PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler:</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> </td><td> <pre> </pre> <p>@Override</p> <p>public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer,</p> <p>int installFlags, String installerPackageName, int userId) {<!-- --></p> <p>...</p> <p>final Message msg = mHandler.obtainMessage(INIT_COPY);</p> <p>final VerificationInfo verificationInfo = new VerificationInfo(</p> <p>null /*originatingUri*/, null /*referrer*/, -1 /*originatingUid*/, callingUid);</p> <p>final InstallParams params = new InstallParams(origin, null /*moveInfo*/, observer,</p> <p>installFlags, installerPackageName, null /*volumeUuid*/, verificationInfo, user,</p> <p>null /*packageAbiOverride*/, null /*grantedPermissions*/,</p> <p>null /*certificates*/);</p> <p>params.setTraceMethod("installAsUser").setTraceCookie(System.identityHashCode(params));</p> <p>msg.obj = params;</p> <p>mHandler.sendMessage(msg);</p> <p>....</p> <p>}</p> </td></tr></tbody></table> 
<p>PackageHandler用于处理apk的安装请求等消息，后面分析。</p> 
<h2 id="八、PackageHanlder">八、PackageHanlder</h2> 
<ul><li>PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler</li><li>PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler</li></ul> 
<h3 id="8-1-INIT-COPY">8.1 INIT_COPY</h3> 
<p>PackageHandler用于处理apk的安装请求等消息，在PMS构造函数中有初始化。实际处理消息的函数为doHandleMessage，我们来看看INIT_COPY的处理流程：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> </td><td> <pre> </pre> <p>class PackageHandler extends Handler {<!-- --></p> <p>...</p> <p>void doHandleMessage(Message msg) {<!-- --></p> <p>switch (msg.what) {<!-- --></p> <p>case INIT_COPY: {<!-- --></p> <p>//这里取出的其实就是InstallParams</p> <p>HandlerParams params = (HandlerParams) msg.obj;</p> <p>//idx为当前等待处理处理的安装请求的个数</p> <p>int idx = mPendingInstalls.size();</p> <p>............</p> <p>//初始时，mBound的值为false</p> <p>if (!mBound) {<!-- --></p> <p>............</p> <p>// If this is the only one pending we might</p> <p>// have to bind to the service again.</p> <p>//连接安装服务</p> <p>if (!connectToService()) {<!-- --></p> <p>..................</p> <p>} else {<!-- --></p> <p>// Once we bind to the service, the first</p> <p>// pending request will be processed.</p> <p>//绑定服务成功后，将新的请求加入到mPendingIntalls中，等待处理</p> <p>mPendingInstalls.add(idx, params);</p> <p>}</p> <p>} else {<!-- --></p> <p>//如果之前已经绑定过服务，同样将新的请求加入到mPendingIntalls中，等待处理</p> <p>mPendingInstalls.add(idx, params);</p> <p>// Already bound to the service. Just make</p> <p>// sure we trigger off processing the first request.</p> <p>if (idx == 0) {<!-- --></p> <p>//如果是第一个请求，则直接发送事件MCS_BOUND，触发处理流程</p> <p>mHandler.sendEmptyMessage(MCS_BOUND);</p> <p>}</p> <p>}</p> <p>break;</p> <p>}</p> <p>}</p> <p>}</p> <p>...</p> <p>}</p> </td></tr></tbody></table> 
<p>INIT_COPY主要是将新的请求加入到mPendingIntalls中，等待MCS_BOUND阶段处理。</p> 
<h3 id="8-2-MCS-BOUND">8.2 MCS_BOUND</h3> 
<p>INIT_COPY最后会发送MCS_BOUND消息触发接下来的流程，MCS_BOUND对应的处理流程同样定义于doHandleMessage中：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> </td><td> <pre> </pre> <p>void doHandleMessage(Message msg) {<!-- --></p> <p>.......</p> <p>case MCS_BOUND: {<!-- --></p> <p>........</p> <p>if (msg.obj != null) {<!-- --></p> <p>mContainerService = (IMediaContainerService) msg.obj;</p> <p>.......</p> <p>}</p> <p>if (mContainerService == null) {<!-- --></p> <p>if (!mBound) {<!-- --></p> <p>// Something seriously wrong since we are not bound and we are not</p> <p>// waiting for connection. Bail out.</p> <p>............</p> <p>} else {<!-- --></p> <p>Slog.w(TAG, "Waiting to connect to media container service");</p> <p>}</p> <p>// 请求队列mPendingInstalls不为空</p> <p>} else if (mPendingInstalls.size() &gt; 0) {<!-- --></p> <p>HandlerParams params = mPendingInstalls.get(0);</p> <p>if (params != null) {<!-- --></p> <p>........</p> <p>//调用参数的startCopy函数处理安装请求</p> <p>if (params.startCopy()) {<!-- --></p> <p>........</p> <p>// Delete pending install</p> <p>if (mPendingInstalls.size() &gt; 0) {<!-- --></p> <p>mPendingInstalls.remove(0);</p> <p>}</p> <p>if (mPendingInstalls.size() == 0) {<!-- --></p> <p>if (mBound) {<!-- --></p> <p>..........</p> <p>removeMessages(MCS_UNBIND);</p> <p>Message ubmsg = obtainMessage(MCS_UNBIND);</p> <p>// Unbind after a little delay, to avoid</p> <p>// continual thrashing.</p> <p>sendMessageDelayed(ubmsg, 10000);</p> <p>}</p> <p>} else {<!-- --></p> <p>// There are more pending requests in queue.</p> <p>// Just post MCS_BOUND message to trigger processing</p> <p>// of next pending install.</p> <p>......</p> <p>mHandler.sendEmptyMessage(MCS_BOUND);</p> <p>}</p> <p>}</p> <p>.........</p> <p>}</p> <p>} else {<!-- --></p> <p>// Should never happen ideally.</p> <p>Slog.w(TAG, "Empty queue");</p> <p>}</p> <p>break;</p> <p>}</p> <p>.......</p> <p>}</p> </td></tr></tbody></table> 
<p>这一段代码比较好理解:</p> 
<ul><li>如果mPendingInstalls不为空，调用<code>InstallParams.startCopy</code>函数处理安装请求。</li><li>接着如果mPendingInstalls不为空，发送MCS_BOUND继续处理下一个，直到队列为空。</li><li>如果队列为空，则等待一段时间后，发送MCS_UNBIND消息断开与安装服务的绑定。</li></ul> 
<h2 id="九、startCopy">九、startCopy</h2> 
<p>/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</p> 
<p>InstallParams继承HandlerParams，实际调用的是HandlerParams.startCopy:</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> </td><td> <pre> </pre> <p>final boolean startCopy() {<!-- --></p> <p>boolean res;</p> <p>try {<!-- --></p> <p>if (DEBUG_INSTALL) Slog.i(TAG, "startCopy " + mUser + ": " + this);</p> <p>if (++mRetries &gt; MAX_RETRIES) {<!-- --></p> <p>Slog.w(TAG, "Failed to invoke remote methods on default container service. Giving up");</p> <p>mHandler.sendEmptyMessage(MCS_GIVE_UP);</p> <p>handleServiceError();</p> <p>return false;</p> <p>} else {<!-- --></p> <p>// 调用handleStartCopy()处理</p> <p>handleStartCopy();</p> <p>Slog.i(TAG, "Apk copy done");</p> <p>res = true;</p> <p>}</p> <p>} catch (RemoteException e) {<!-- --></p> <p>if (DEBUG_INSTALL) Slog.i(TAG, "Posting install MCS_RECONNECT");</p> <p>mHandler.sendEmptyMessage(MCS_RECONNECT);</p> <p>res = false;</p> <p>}</p> <p>//</p> <p>handleReturnCode();</p> <p>return res;</p> <p>}</p> </td></tr></tbody></table> 
<p>PMS将先后调用handleStartCopy和handleReturnCode来完成主要的工作。</p> 
<h3 id="9-1-handleStartCopy">9.1 handleStartCopy</h3> 
<p>handleStartCopy函数在HandleParams抽象类定义，在其子类InstallParams来实现，我们看看与实际安装相关的handleStartCopy函数：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> </td><td> <pre> </pre> <p>public void handleStartCopy() throws RemoteException {<!-- --></p> <p>int ret = PackageManager.INSTALL_SUCCEEDED;</p> <p>// 决定是安装在手机内还是sdcard中，设置对应标志位</p> <p>if (origin.staged) {<!-- --></p> <p>if (origin.file != null) {<!-- --></p> <p>installFlags |= PackageManager.INSTALL_INTERNAL;</p> <p>installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL;</p> <p>} else if (origin.cid != null) {<!-- --></p> <p>installFlags |= PackageManager.INSTALL_EXTERNAL;</p> <p>installFlags &amp;= ~PackageManager.INSTALL_INTERNAL;</p> <p>} else {<!-- --></p> <p>throw new IllegalStateException("Invalid stage location");</p> <p>}</p> <p>}</p> <p>...</p> <p>// 检查APK的安装位置是否正确</p> <p>if (onInt &amp;&amp; onSd) {<!-- --></p> <p>// Check if both bits are set.</p> <p>Slog.w(TAG, "Conflicting flags specified for installing on both internal and external");</p> <p>ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p> <p>} else if (onSd &amp;&amp; ephemeral) {<!-- --></p> <p>Slog.w(TAG, "Conflicting flags specified for installing ephemeral on external");</p> <p>ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p> <p>} else {<!-- --></p> <p>...</p> <p>}</p> <p>...</p> <p>// createInstallArgs用于创建一个安装参数对象</p> <p>final InstallArgs args = createInstallArgs(this);</p> <p>if (ret == PackageManager.INSTALL_SUCCEEDED) {<!-- --></p> <p>...</p> <p>// 调用InstallArgs的copyApk函数</p> <p>ret = args.copyApk(mContainerService, true);</p> <p>}</p> <p>}</p> <p>mRet = ret;</p> <p>}</p> </td></tr></tbody></table> 
<p>InstallParams$handleStartCopy()主要功能是获取安装位置信息以及复制apk到指定位置。抽象类InstallArgs中的copyApk负责复制APK文件，具体实现在子类FileInstallArgs和SdInstallArgs里面。</p> 
<h3 id="9-2-handleReturnCode">9.2 handleReturnCode</h3> 
<p>InstallParams$handleReturnCode()中，调用processPendingInstall方法处理安装：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <pre> </pre> <p>void handleReturnCode() {<!-- --></p> <p>// If mArgs is null, then MCS couldn't be reached. When it</p> <p>// reconnects, it will try again to install. At that point, this</p> <p>// will succeed.</p> <p>if (mArgs != null) {<!-- --></p> <p>processPendingInstall(mArgs, mRet);</p> <p>}</p> <p>}</p> </td></tr></tbody></table> 
<h3 id="9-3-processPendingInstall">9.3 processPendingInstall</h3> 
<p>主要的安装流程都在这个方法里面: PMS.processPendingInstall</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> </td><td> <pre> </pre> <p>private void processPendingInstall(final InstallArgs args, final int currentStatus) {<!-- --></p> <p>mHandler.post(new Runnable() {<!-- --></p> <p>public void run() {<!-- --></p> <p>mHandler.removeCallbacks(this);</p> <p>// Result object to be returned</p> <p>PackageInstalledInfo res = new PackageInstalledInfo();</p> <p>res.setReturnCode(currentStatus);</p> <p>res.uid = -1;</p> <p>res.pkg = null;</p> <p>res.removedInfo = null;</p> <p>if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {<!-- --></p> <p>//1、预安装，检查包状态，确保环境ok，如果环境不ok，那么会清理拷贝的文件</p> <p>args.doPreInstall(res.returnCode);</p> <p>synchronized (mInstallLock) {<!-- --></p> <p>//2、安装，调用installPackageTracedLI进行安装</p> <p>installPackageTracedLI(args, res);</p> <p>}</p> <p>//3、安装收尾</p> <p>args.doPostInstall(res.returnCode, res.uid);</p> <p>}</p> <p>if (!doRestore) {<!-- --></p> <p>.......</p> <p>//4、生成一个POST_INSTALL消息给PackageHanlder</p> <p>Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</p> <p>mHandler.sendMessage(msg);</p> <p>}</p> <p>}</p> <p>});</p> <p>}</p> </td></tr></tbody></table> 
<p>安装过程放在一个线程里面，处理流程是预安装-安装-安装收尾-发送 POST_INSTALL消息：</p> 
<ul><li><strong>预安装</strong>：检查当前安装包的状态以及确保SDCARD的挂载，并返回状态信息。在安装前确保安装环境的可靠。</li><li><strong>安装</strong>：对mInstallLock加锁，表明同时只能有一个安装包进行安装；然后调用installPackageTracedLI完成具体安装操作。</li><li><strong>安装收尾</strong>： 检查状态，如果安装不成功，删除掉相关目录文件。</li><li><strong>发送POST_INSTALL消息</strong>：该消息由PackageHandler接收。POST_INSTALL的主要工作其实还是通过广播、回调接口通知系统中的其它组件，有新的Pacakge安装或发生了改变。</li></ul> 
<p>从上面我们可以知道，具体安装apk的函数是<code>PMS.installPackageTracedLI</code>。</p> 
<h2 id="十、installPackageTracedLI">十、installPackageTracedLI</h2> 
<p>PMS.installPackageTracedLI函数：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <pre> </pre> <p>private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) {<!-- --></p> <p>try {<!-- --></p> <p>Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "installPackage");</p> <p>installPackageLI(args, res);</p> <p>} finally {<!-- --></p> <p>Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</p> <p>}</p> <p>}</p> </td></tr></tbody></table> 
<h2 id="十一、installPackageLI">十一、installPackageLI</h2> 
<p>继续PMS.installPackageLI：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> <p>54</p> <p>55</p> <p>56</p> <p>57</p> <p>58</p> <p>59</p> <p>60</p> <p>61</p> <p>62</p> <p>63</p> <p>64</p> <p>65</p> <p>66</p> <p>67</p> <p>68</p> <p>69</p> <p>70</p> <p>71</p> <p>72</p> </td><td> <pre> </pre> <p>private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {<!-- --></p> <p>// PackageParser对象</p> <p>PackageParser pp = new PackageParser();</p> <p>pp.setSeparateProcesses(mSeparateProcesses);</p> <p>pp.setDisplayMetrics(mMetrics);</p> <p>Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");</p> <p>final PackageParser.Package pkg;</p> <p>try {<!-- --></p> <p>if (DEBUG_INSTALL) Slog.i(TAG, "Start parsing apk: " + installerPackageName);</p> <p>// 1.开始解析我们的package</p> <p>pkg = pp.parsePackage(tmpPackageFile, parseFlags);</p> <p>if (DEBUG_INSTALL) Slog.i(TAG, "Parsing done for apk: " + installerPackageName);</p> <p>} catch (PackageParserException e) {<!-- --></p> <p>res.setError("Failed parse during installPackageLI", e);</p> <p>return;</p> <p>} finally {<!-- --></p> <p>Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</p> <p>}</p> <p>...</p> <p>//2. 加载证书，获取签名信息</p> <p>try {<!-- --></p> <p>// either use what we've been given or parse directly from the APK</p> <p>if (args.certificates != null) {<!-- --></p> <p>try {<!-- --></p> <p>PackageParser.populateCertificates(pkg, args.certificates);</p> <p>} catch (PackageParserException e) {<!-- --></p> <p>PackageParser.collectCertificates(pkg, parseFlags);</p> <p>}</p> <p>} else {<!-- --></p> <p>PackageParser.collectCertificates(pkg, parseFlags);</p> <p>}</p> <p>} catch (PackageParserException e) {<!-- --></p> <p>res.setError("Failed collect during installPackageLI", e);</p> <p>return;</p> <p>}</p> <p>...</p> <p>synchronized (mPackages) {<!-- --></p> <p>// 3.检测packages是否存在</p> <p>if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) {<!-- --></p> <p>...</p> <p>replace = true;</p> <p>} else if (mPackages.containsKey(pkgName)) {<!-- --></p> <p>...</p> <p>replace = true;</p> <p>if (DEBUG_INSTALL) Slog.d(TAG, "Replace existing pacakge: " + pkgName);</p> <p>}</p> <p>...</p> <p>}</p> <p>}</p> <p>...</p> <p>try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags,</p> <p>"installPackageLI")) {<!-- --></p> <p>if (replace) {<!-- --></p> <p>// 4.更新已经存在的packages</p> <p>replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user,</p> <p>installerPackageName, res);</p> <p>} else {<!-- --></p> <p>// 5.安装新的packages</p> <p>installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES,</p> <p>args.user, installerPackageName, volumeUuid, res);</p> <p>}</p> <p>}</p> <p>...</p> <p>}</p> </td></tr></tbody></table> 
<p>这个函数过程比较长，主要做了几件事：</p> 
<ul><li>PackageParser$parsePackage，主要是解析APK的AndroidManifest.xml，将每个标签对应的信息添加到Package的相关列表中，如将下的信息添加到Package的activities列表等。</li><li>加载apk证书，获取签名信息</li><li>检查目前安装的APK是否在系统中已存在: 
  <ul><li>已存在，则调用<code>replacePackageLIF</code>进行替换安装。</li><li>不存在，否则调用<code>installNewPackageLIF</code>进行安装。</li></ul></li></ul> 
<h3 id="11-1-replacePackageLIF">11.1 replacePackageLIF</h3> 
<p>如果需要替换的是系统APP，则调用Settings$disableSystemPackageLPw来disable旧的APK；如果替换的是非系统APP，则调用deletePackageLI删除旧的APK。</p> 
<p>因为这个过程实在太差，没有必要贴出来一一分析，我来简化一下flow，有兴趣的读者可以深入跟进：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> </td><td> <pre> </pre> <p>replacePackageLIF</p> <p>replaceSystemPackageLIF // 系统 pkg</p> <p>removePackageLI</p> <p>disableSystemPackageLPw</p> <p>clearAppDataLIF</p> <p>scanPackageTracedLI //安装apk</p> <p>scanPackageLI</p> <p>scanPackageDirtyLI</p> <p>updateSettingsLI</p> <p>updatePermissionsLPw</p> <p>mSettings.writeLPr();</p> <p>replaceNonSystemPackageLIF // 非系统 pkg</p> <p>deletePackageLIF</p> <p>clearAppDataLIF</p> <p>clearAppProfilesLIF</p> <p>scanPackageTracedLI // 安装apk</p> <p>scanPackageLI</p> <p>scanPackageDirtyLI</p> <p>updateSettingsLI</p> <p>updatePermissionsLPw</p> <p>mSettings.writeLPr();</p> </td></tr></tbody></table> 
<p>不管是更新系统还是非系统apk，都会先清除之前的packages信息，然后通过scanPackageTracedLI去安装apk，安装完后更新permissions和setting，最后通过writeLPr更新packages.xml。</p> 
<p>关于scanPackageTracedLI和Settings.writeLPr();我有在上一篇blog讲过，可以回去看看。</p> 
<h3 id="11-2-installNewPackageLIF">11.2 installNewPackageLIF</h3> 
<p>PMS.installNewPackageLIF用于安装新的apk：</p> 
<table><tbody><tr><td> <pre> </pre> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> <p>30</p> <p>31</p> <p>32</p> <p>33</p> <p>34</p> <p>35</p> <p>36</p> <p>37</p> <p>38</p> <p>39</p> <p>40</p> <p>41</p> <p>42</p> <p>43</p> <p>44</p> <p>45</p> <p>46</p> <p>47</p> <p>48</p> <p>49</p> <p>50</p> <p>51</p> <p>52</p> <p>53</p> </td><td> <pre> </pre> <p>private void installNewPackageLIF(PackageParser.Package pkg, final int policyFlags,</p> <p>int scanFlags, UserHandle user, String installerPackageName, String volumeUuid,</p> <p>PackageInstalledInfo res) {<!-- --></p> <p>Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "installNewPackage");</p> <p>// Remember this for later, in case we need to rollback this install</p> <p>String pkgName = pkg.packageName;</p> <p>if (DEBUG_INSTALL) Slog.d(TAG, "installNewPackageLI: " + pkg);</p> <p>// package已经存在</p> <p>synchronized(mPackages) {<!-- --></p> <p>if (mSettings.mRenamedPackages.containsKey(pkgName)) {<!-- --></p> <p>// A package with the same name is already installed, though</p> <p>// it has been renamed to an older name. The package we</p> <p>// are trying to install should be installed as an update to</p> <p>// the existing one, but that has not been requested, so bail.</p> <p>res.setError(INSTALL_FAILED_ALREADY_EXISTS, "Attempt to re-install " + pkgName</p> <p>+ " without first uninstalling package running as "</p> <p>+ mSettings.mRenamedPackages.get(pkgName));</p> <p>return;</p> <p>}</p> <p>if (mPackages.containsKey(pkgName)) {<!-- --></p> <p>// Don't allow installation over an existing package with the same name.</p> <p>res.setError(INSTALL_FAILED_ALREADY_EXISTS, "Attempt to re-install " + pkgName</p> <p>+ " without first uninstalling.");</p> <p>return;</p> <p>}</p> <p>}</p> <p>try {<!-- --></p> <p>// 1. 安装apk</p> <p>PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags,</p> <p>System.currentTimeMillis(), user);</p> <p>// 2. 更新setting</p> <p>updateSettingsLI(newPackage, installerPackageName, null, res, user);</p> <p>if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {<!-- --></p> <p>prepareAppDataAfterInstallLIF(newPackage);</p> <p>} else {<!-- --></p> <p>// Remove package from internal structures, but keep around any</p> <p>// data that might have already existed</p> <p>deletePackageLIF(pkgName, UserHandle.ALL, false, null,</p> <p>PackageManager.DELETE_KEEP_DATA, res.removedInfo, true, null);</p> <p>}</p> <p>} catch (PackageManagerException e) {<!-- --></p> <p>res.setError("Package couldn't be installed in " + pkg.codePath, e);</p> <p>}</p> <p>Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</p> <p>}</p> </td></tr></tbody></table> 
<p>installNewPackageLIF会调用scanPackageTracedLI去安装apk，最终会调用scanPackageLI-&gt;scanPackageDirtyLI实际去安装apk。</p> 
<p>由于之前有描述过，便不再叙述</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05fd2d336a93cac35b4564f1f7c8e89f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:YES) 解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8294cdc799c15e622aeb8946cd9884e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">后台登录（实验吧）writeup</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>