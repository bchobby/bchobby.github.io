<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微信小程序-页面间如何进行传递数据(通信) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="微信小程序-页面间如何进行传递数据(通信)" />
<meta property="og:description" content="前言 在小程序中组件与组件之间的通信是通过在引用组件处,在自定义组件上添加自定义属性实现的,子组件内部通过properties进行接收
更多关于组件与组件之间的通信可参考小程序-实现自定义组件以及自定义组件间的通信这篇文章
那页面与页面之间又如何传递数据?
您将阅读完本文后,将收获到:
页面间跳转携带参数(通过url的方式)传递数据
如何返回上一级页面,并刷新页面呢
使用全局app页面定义的变量实现数据的传递
使用本地缓存数据
使用 eventChannel 向被打开页面传送数据(wx.navigateTo高级用法)
01 页面间通过 url 方式传递数据
在小程序中当中,在父页面,通过url方式传递参数到子页面,是一种比较常见的做法
如下示例所示:应用场景
点击列表页面,进入详情页
动态改变详情页面的navBar中的title
扫码即可体验
父页面实例代码 &lt;view&gt; &lt;view class=&#34;list-wrap&#34;&gt; &lt;block wx:for=&#34;{{listDatas}}&#34; wx:key=&#34;index&#34;&gt; &lt;view bindtap=&#34;onListTap&#34; data-list=&#34;{{item}}&#34;&gt; &lt;text&gt;{{ item.list_text}}&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; css代码
.list-wrap { display: flex; justify-content: space-between; flex-wrap: wrap; padding: 15px 15px; } .list-wrap view { width: 30%; height: 300rpx; border: 1px solid #ccc; margin-bottom: 15px; text-align: center; line-height: 300rpx; font-size: 28rpx; } js代码" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/33bb644feb95d461a75b35aaf0ee7719/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-11T08:11:39+08:00" />
<meta property="article:modified_time" content="2020-11-11T08:11:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微信小程序-页面间如何进行传递数据(通信)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p> </p> 
 <p> </p> 
 <h3>前言</h3> 
 <p>在小程序中组件与组件之间的通信是通过在引用组件处,在自定义组件上添加自定义属性实现的,子组件内部通过<code>properties</code>进行接收</p> 
 <p>更多关于组件与组件之间的通信可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b5d11db5cd4077ae65648cd6b828813db2886984899139509e9f9abb9533d3e62d725b2e0&amp;idx=1&amp;mid=2247487629&amp;scene=21&amp;sn=fed2e9873bd780bae94f2e2bc7b43e6e#wechat_redirect" rel="nofollow">小程序-实现自定义组件以及自定义组件间的通信</a>这篇文章</p> 
 <p>那页面与页面之间又如何传递数据?</p> 
 <p>您将阅读完本文后,将收获到:</p> 
 <ol><li> <p>页面间跳转携带参数(通过<code>url</code>的方式)传递数据</p> </li><li> <p>如何返回上一级页面,并刷新页面呢</p> </li><li> <p>使用全局<code>app</code>页面定义的变量实现数据的传递</p> </li><li> <p>使用本地缓存数据</p> </li><li> <p>使用 <code>eventChannel</code> 向被打开页面传送数据(<code>wx.navigateTo</code>高级用法)</p> </li></ol> 
 <h3> </h3> 
 <h3> </h3> 
 <h2>01</h2> 
 <p>页面间通过 <code>url</code> 方式传递数据</p> 
 <p>在小程序中当中,在父页面,通过<code>url</code>方式传递参数到子页面,是一种比较常见的做法</p> 
 <p>如下示例所示:应用场景</p> 
 <ol><li> <p>点击列表页面,进入详情页</p> </li><li> <p>动态改变详情页面的<code>navBar</code>中的<code>title</code></p> </li></ol> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d0/68/PkmulBQ0_o.png"></p> 
 <p>扫码即可体验</p> 
 <h4>父页面实例代码</h4> 
 <pre class="has"><code class="language-go">&lt;view&gt;
  &lt;view class="list-wrap"&gt;
    &lt;block wx:for="{<!-- -->{listDatas}}" wx:key="index"&gt;
      &lt;view bindtap="onListTap" data-list="{<!-- -->{item}}"&gt;
        &lt;text&gt;{<!-- -->{ item.list_text}}&lt;/text&gt;
      &lt;/view&gt;
    &lt;/block&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre> 
 <p>css代码</p> 
 <pre class="has"><code class="language-go">.list-wrap {
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
  padding: 15px 15px;
}

.list-wrap view {
  width: 30%;
  height: 300rpx;
  border: 1px solid #ccc;
  margin-bottom: 15px;
  text-align: center;
  line-height: 300rpx;
  font-size: 28rpx;
}
</code></pre> 
 <p>js代码</p> 
 <pre class="has"><code class="language-go">Page({
  /**
   * 页面的初始数据
   */
  data: {
    listDatas: [
      {
        listId: '1',
        list_text: '建钢构混泥房',
        link_phone: '137-0113-4148',
        linker: '王经理',
      },

      {
        listId: '2',
        list_text: '建办公楼房',
        link_phone: '137-0113-4148',
        linker: '陈经理',
      },

      {
        listId: '3',
        list_text: '建冰场钢结构',
        link_phone: '137-0113-4148',
        linker: '张经理',
      },
    ],
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {},

  onListTap(event) {
    const {
      listId,
      list_text,
      link_phone,
      linker,
    } = event.currentTarget.dataset.list;
    // 1. 传递参数-通过url的方式传递当前页面数据到子页面当中去,在子页面的onload的options中可以拿到
    wx.navigateTo({
      url: `/pages/listDetail/listDetail?id=${listId}&amp;navtitle=${list_text}&amp;phone=${link_phone}&amp;link=${linker}`,
    });
  },
});
</code></pre> 
 <p>切换<code>tab</code>选项就可以查看对应的代码,在上面示例中,从一个页面跳转到另一个页面是使用<code>wx.navigateTo()</code>这个方法,如果想要将该页面的数据传递到子页面中,可以通过<code>url</code>拼接参数的方式进行传递,多个参数之间使用<code>&amp;</code>符号相连</p> 
 <p>路径后可以带参数,参数与路径之间使用 <code>?</code> 分隔，参数键与参数值用 <code>=</code> 相连，不同参数用 <code>&amp;</code> 分隔；如<code>path?key=value&amp;key2=value2</code></p> 
 <p>上面示例代码中使用了<code>es6</code>的模板字符串,参数之间,也可以使用<code>+</code>拼接,个人觉得使用<code>+</code>真的很难受,不舒服,容易出错</p> 
 <p>如下是es6模板字符串方式拼接参数</p> 
 <pre class="has"><code class="language-go">wx.navigateTo({
  url: `/pages/listDetail/listDetail?id=${listId}&amp;navtitle=${list_text}&amp;phone=${link_phone}&amp;link=${linker}`,
});
</code></pre> 
 <p>如下是加号拼接方式</p> 
 <pre class="has"><code class="language-go"> wx.navigateTo({
      url: "/pages/listDetail/listDetail?id="+listId+"&amp;navtitle="+list_text+"&amp;phone="+link_phone+"&amp;link="+link_phone+"&amp;link="+linker,
    })
  }
</code></pre> 
 <p><strong>两者比较</strong></p> 
 <p>通过<code>es6</code>中的模板字符串,使用反引号,结合模板字符串<code>${变量}</code>的方式,要比使用<code>+</code>加号拼接参数要好理解得多</p> 
 <p>在单个参数情况下,或许使用模板字符串与加号没有影响,区别,但是当多个参数时,使用加号做拼接就会令人奔溃,很容易出错</p> 
 <p>甚至有可能在接收参数时,出现丢失的情况,这或许就是不小心使用加号前后空格或解析参数时,加号被转义导致的,很容易出现 <code>bug</code></p> 
 <h4>子页面实例代码</h4> 
 <pre class="has"><code class="language-go">&lt;view&gt;
  &lt;view class="container"&gt;
    &lt;view&gt;项目:&lt;text&gt;{<!-- -->{id}}-{<!-- -->{text}}&lt;/text&gt;&lt;/view&gt;
    &lt;view&gt;联系人: {<!-- -->{link}}&lt;/view&gt;
    &lt;view&gt;联系电话: {<!-- -->{phoneNumber}}&lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre> 
 <p>css代码</p> 
 <pre class="has"><code class="language-go">.container {
  padding: 20px 0 10px 30px;
}

.container view {
  line-height: 30px;
}
</code></pre> 
 <p>js逻辑代码</p> 
 <pre class="has"><code class="language-go">Page({
  /**
   * 页面的初始数据
   */
  data: {
    // 页面中要渲染的数据,数据初始化
    id: null,
    text: '',
    phoneNumber: '',
    linker: '',
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {
    console.log(options);
    const { id, navtitle, phone, link } = options;
    this._setNavTitle(navtitle);
    this._getList(id, navtitle, phone, link);
  },

  // 设置navTitle
  _setNavTitle(navtitle) {
    wx.setNavigationBarTitle({
      title: navtitle,
    });
  },

  _getList(id, navtitle, phone, link) {
    // 改变页面中的数据,setData
    this.setData({
      text: navtitle,
      id,
      phoneNumber: phone,
      link,
    });
  },
});
</code></pre> 
 <p>当父页面通过<code>url</code>的方式传递数据给子页面时,在子页面中的生命周期<code>onLoad</code>函数中的<code>options</code>中可以拿到 想要更改什么数据,直接重新<code>setData</code>就可以了的</p> 
 <p><strong>注意</strong></p> 
 <ol><li> <p><code>url</code>的方式适合页面间跳转携带参数,多个参数之间使用<code>&amp;</code>符号拼接</p> </li><li> <p>此方法有一定的局限性,不适宜传入复杂的数据,例如:数组,对象</p> </li><li> <p>适合参数比较少的情况</p> </li></ol> 
 <h4>url 中有多个参数时传递</h4> 
 <p>在小程序中,向跳转的目标<code>url</code>页面传递的参数有时候远不止一个,使用<code>wx.navigator</code>进行跳转,支持<code>/pages/xxx/xxx?param1=${param1}&amp;param2=${param2}&amp;param3=${param3}</code>的方式,并不支持类似<code>obj={key1:value1,key2: value2}</code>对象或者数组<code>list: [arr1, arr2, arr3 ..]</code></p> 
 <p><strong>若<code>url</code>参数是数组情况</strong></p> 
 <pre class="has"><code class="language-go">wx.navigateTo({
  url: `/pages/listDetail/listDetail?list=${[
    listId,
    list_text,
    link_phone,
    linker,
  ]}`,
});
</code></pre> 
 <p>子页面(跳转目标页)</p> 
 <pre class="has"><code class="language-go">onLoad: function (options) {
    console.log(options);
    const list = options.list.split(','); // 通过split分割成数组
    console.log(list);
  },
</code></pre> 
 <p><strong>分析</strong></p> 
 <p>当被跳转的 url 中的参数是数组时,那么在跳转的目标页面中的<code>onLoad</code>生命周期函数的<code>option</code>,将得到父页面中的字符串参数</p> 
 <p>通过<code>split</code>方法将字符串分割为数组,然后通过数组下标的方式拿到对应的参数</p> 
 <p>父页面中</p> 
 <pre class="has"><code class="language-go">const name = 'itclanCoder';
const sex = 'boy';
wx.navigateTo({
  url: `/pages/listDetail/listDetail?data=${[name, sex]}`,
});
</code></pre> 
 <p>子页面中</p> 
 <pre class="has"><code class="language-go">onLoad: function (options) {
    console.log(options);
    const data = options.data.split(','); // 通过split分割成数组
    console.log(data); // ["itclanCoder", "boy"]
  },
</code></pre> 
 <p><strong>若<code>url</code>参数是对象情况</strong></p> 
 <p>在<code>url</code>参数是对象时,并不会像数组一样,在目标页面中<code>onLoad</code>的<code>options</code>对象中是一个字符串,而却是一个对象</p> 
 <p>如下所示</p> 
 <pre class="has"><code class="language-go">{
  obj: [object, object];
}
</code></pre> 
 <p>我们需要借助<code>JSON.stringify()</code>对传入的参数对象进行序列化</p> 
 <p>父页面(对象参数序列化)</p> 
 <pre class="has"><code class="language-go">wx.navigateTo({
  url: `/pages/listDetail/listDetail?obj=${JSON.stringify({
    id: listId,
    text: list_text,
    phone: link_phone,
    link: linker,
  })}`,
});
</code></pre> 
 <p>通常,我们把参数对象,定义成一个对象的,简化我们的代码,用一个变量对象临时存储的</p> 
 <pre class="has"><code class="language-go">const params = {
  // 参数放到外面,让代码更加清晰,可读,可维护性更高
  id: listId,
  text: list_text,
  phone: link_phone,
  link: linker,
};
wx.navigateTo({
  url: `/pages/listDetail/listDetail?obj=${JSON.stringify(params)}`,
});
</code></pre> 
 <p>那么在子页面中,需要通过<code>JSON.parse()</code>对父页面中传递过来的参数进行反序列化,否则拿到的将是字符串对象,是无法通过对象.的方式访问属性</p> 
 <p>子页面(对象参数反序列化)</p> 
 <pre class="has"><code class="language-go">onLoad: function (options) {
    console.log(options);
    const obj = JSON.parse(options.obj); // 将字符串对象转化为真正的对象
    console.log(obj); // {id: "1", text: "建钢构混泥房", phone: "137-0113-4148", link: "王经理"}
  },

</code></pre> 
 <p><strong>分析</strong>在父页面中若跳转目标的 url 参数是对象的情况下,需要先将参数通过<code>JSON.stringify()</code>序列化才可以</p> 
 <pre class="has"><code class="language-go">const params = {
  // 参数放到外面,让代码更加清晰,可读,可维护性更高
  id: 22,
  name: '川川',
  sex: 'boy',
};
wx.navigateTo({
  url: `/pages/listDetail/listDetail?obj=${JSON.stringify(params)}`,
});
</code></pre> 
 <p>那么在子页面(目标页面中)的<code>onLoad</code>的<code>options</code>中</p> 
 <pre class="has"><code class="language-go">onLoad: function (options) {
    console.log(options);
    const obj = JSON.parse(options.obj); // 将字符串对象转化为真正的对象
    console.log(obj); // {id: 22, name: "川川",sex: "boy"}
},
</code></pre> 
 <h4>可能会遇到的问题</h4> 
 <p>当传递的对象数据中含有特殊字符串时，在下个页面使用<code>JSON.parse()</code>还原为对象时会报错 也就是当<code>url传参 参数值过长</code>,在子页面接收时,会出现问题,存在丢失情况</p> 
 <p>具体解决办法</p> 
 <p>在上个页面(被跳转页面)将对象转化为字符串后(<code>JSON.stringify()</code>),然后使用<code>encodeURIComponent</code>进行编码，然后在下个页面先用<code>decodeURIComponent</code>进行解码,最终在还原为对象</p> 
 <p>父(上个)页面编码</p> 
 <pre class="has"><code class="language-go">const params = {
  // 参数放到外面,让代码更加清晰,可读,可维护性更高
  id: 22,
  name: '川川',
  sex: 'boy',
};
const param = encodeURIComponent(JSON.stringify(params)); // 通过encodeURIComponent编码
wx.navigateTo({
  url: `/pages/listDetail/listDetail?obj=${param}`,
});
</code></pre> 
 <p>子页面解码</p> 
 <pre class="has"><code class="language-go">onLoad: function (options) {
    console.log(options);
    const tempObj = decodeURIComponent(options.obj)
    const obj = JSON.parse(tempObj); // 将字符串对象转化为真正的对象
    console.log(obj); // {id: 22, name: "川川",sex: "boy"}
},
</code></pre> 
 <p><strong>注意</strong></p> 
 <ol><li> <p>当父页面传递的<code>url</code>参数为对象时，在子页面是无法直接获取的，在父页面中,必须先使用<code>JSON.stringify()</code>转换为字符串 然后在下个页面使用<code>JSON.parse()</code>还原为对象,这样在子页面中便可以通过对象的方式拿到</p> </li><li> <p>当父页面传递的<code>url</code>对象数据中含有特殊字符串时，在子页面使用 <code>JSON.parse()</code>还原为对象时会报错。需要在上个(父)页面将对象转化为字符串后(<code>JSON.stringify()</code>),在使用 <code>encodeURIComponent</code> 进行编码，然后在下个(子)页面先用 <code>decodeURIComponent</code> 进行解码在还原(<code>JSON.parse()</code>)为对象。</p> </li></ol> 
 <h3> </h3> 
 <h2>02</h2> 
 <p>如何返回上一级页面-并刷新页面</p> 
 <p>在使用<code>wx.navigateTo()</code>API 进行跳转时,在子页面中可以通过<code>wx.navigateBack()</code>返回上一级页面的</p> 
 <p>这个场景在日常开发中,就有不少的</p> 
 <p>例如:写完微博,发完微博成功后,自动要返回到首页,申请退款时,跳转到申清退款页面等等的</p> 
 <pre class="has"><code class="language-go">const pages = getCurrentPages(); // 可以获取当前页面栈,上一个页面以及当前页面栈信息
console.log(pages); // 是一个数组，记录了上一个页面与当前页面信息
// 取到上一个页面
const prevPage = pages[pages.length - 2]; // 获取第0个页面,也就是上个页面
console.log(prevPage);
prevPage.onLoad(); // 可以调用上一页面的方法
prevPage.setData({
  name: 'itclanCoder',
});
</code></pre> 
 <p>这个方法非常厉害,而且很有用,当你通过<code>wx.navigateTo()</code>,一层一层跳转到子页面时,使用<code>getCurrentPages</code>方法就可以找到上级,上上级的页面栈信息</p> 
 <p>它是通过获取到其他页面的原型对象,然后通过小程序原型下的<code>setData</code>方法,对当前对象管理的数据<code>data</code>进行修改</p> 
 <p>这个方法<code>getCurrentPage</code>方法可以操作页面堆栈页面的数据和方法,可以做到对子(后一)页面对父(上一)页面的数据管理</p> 
 <p><strong>提示</strong></p> 
 <p><code>getCurrentPages()</code>用于获取当前页面栈,数组中第一个元素为首页，最后一个元素为当前页面</p> 
 <ol><li> <p>不要尝试修改页面栈，会导致路由以及页面状态错误(不要依赖这个方法)</p> </li><li> <p>不要在 <code>App.onLaunch</code> 的时候调用 <code>getCurrentPages()</code>，此时 <code>page</code> 还没有生成</p> </li></ol> 
 <h3> </h3> 
 <h2>03</h2> 
 <p>使用全局<code>app</code>页面定义的变量实现数据的传递</p> 
 <h3>在小程序当中,当有多个页面用到一些公共变量对象参数时,例如:小程序的<code>openId</code>,一些公用的状态,可以放到全局<code>app</code>中</h3> 
 <p>全局页面 app.js </p> 
 <pre class="has"><code class="language-go">//app.js
App({
  onLaunch: function() {
    // 定义的全局变量,如token,某些状态等,放在globalData下
    this.globalData = {
      token: 'token',
      url: 'http://coder.itclan.cn/',
      userInfo: 'itclanCoder',
    };
  },
});
</code></pre> 
 <p>使用页面</p> 
 <pre class="has"><code class="language-go">const app = getApp(); // 在另一页面想要使用全局变量处,调用getApp()
Page({
  // 页面初始化的数据
  data: {
    token: '',
    url: '',
    userInfo: '',
  },
  // 生命周期函数
  onLoad: function(options) {},

  onGetGlobal() {
    // 获取全局变量
    const { token, url, userInfo } = app.globalData;
    console.log(token, url, userInfo);
    this.setData({
      token,
      url,
      userInfo,
    });
  },
});
</code></pre> 
 <p>wxml</p> 
 <pre class="has"><code class="language-go">&lt;view&gt;
  &lt;view class="globalData"&gt;
    &lt;view class="getGloablBtn btn" bindtap="onGetGlobal"&gt;获取全局变量&lt;/view&gt;
    &lt;view class="changeGloablBtn btn" bindtap="onChangeGlobal"
      &gt;修改全局变量&lt;/view
    &gt;
  &lt;/view&gt;
  &lt;view&gt;{<!-- -->{token}}&lt;/view&gt;
  &lt;view&gt;{<!-- -->{url}}&lt;/view&gt;
  &lt;view&gt;{<!-- -->{userInfo}}&lt;/view&gt;
&lt;/view&gt;
</code></pre> 
 <p>wxss</p> 
 <pre class="has"><code class="language-go">.globalData {
  display: flex;
  justify-content: start;
  margin: 15px 0 0 0;
}

.getGloablBtn {
  background: rgb(89, 196, 119);
  margin-right: 15px;
}

.changeGloablBtn {
  background: rgb(160, 10, 7);
}

.btn {
  width: 120px;
  height: 30px;
  line-height: 30px;
  color: #fff;
  text-align: center;
}
</code></pre> 
 <p><strong>分析</strong></p> 
 <p>全局定义的变量,一些状态,可以挂载在全局页面 <code>app.js</code> 的<code>globalData</code>中,在使用全局变量页面处</p> 
 <ol><li> <p>需要调用<code>getApp()</code>函数</p> </li><li> <p>通过<code>getApp().globalData.a</code>可以拿到全局对象下定义的变量对象</p> </li><li> <p>若要修改全局变量对象直接赋值即可<code>getApp().globalData.a = "bb"</code>;</p> </li></ol> 
 <h4>全局定义变量注意事项</h4> 
 <ol><li> <p><code>App()</code>必须在<code>app.js</code>中注册,且不能注册多个</p> </li><li> <p>不要在定义<code>App()</code>内的函数调用<code>getApp()</code>,使用<code>this</code>就可以拿到<code>App</code>下的实例</p> </li><li> <p>不要在 <code>App.onLaunch</code> 的时候调用 <code>getCurrentPages()</code>，此时 <code>page</code> 还没有生成</p> </li><li> <p>通过<code>getApp()</code>获取到全局页面的实例后,就不要私自调用生命周期函数了的</p> </li></ol> 
 <h3> </h3> 
 <h2>04</h2> 
 <p>使用本地缓存</p> 
 <h3>在微信小程序都可以有自己的本地缓存</h3> 
 <ul><li> <p><code>wx.setStorageSync</code>:同步设置本地存储某个指定的<code>key</code>数据</p> </li><li> <p><code>wx.setStorage</code>: 异步设置本地所有存储某个<code>key</code>数据</p> </li><li> <p><code>wx.getStorage</code>: 异步获取本地所有存储数据</p> </li><li> <p><code>wx.getStorageSync</code>:同步获取本地存储某个指定<code>key</code>的数据</p> </li><li> <p><code>wx.clearStorage</code>:一次性清除所有本地存储(缓存)数据,不需要参数</p> </li><li> <p><code>wx.clearStorageSync</code>:一次性清除同步所有本地存储,不需要参数</p> </li><li> <p><code>wx.removeStorage</code>:从本地缓存中异步移除指定 <code>key</code>,需要指定某个<code>key</code></p> </li><li> <p><code>wx.removeStorageSync</code>:从本地存储中同步移除指定的<code>key</code>，需要指定某个<code>key</code></p> </li></ul> 
 <p>上面的方法可以对本地缓存进行读写和清理的操作,读与写都是一一对应的</p> 
 <p>使用本地缓存,可以作为页面间数据传递,但是仍然需要注意一些实用情况,如下所示</p> 
 <p><strong>隔离策略</strong></p> 
 <p>同一个微信用户，同一个小程序 <code>storage</code>上限为 <code>10MB</code>,一般可以作为缓存临时一些小的数据,比如用户登录信息之类的</p> 
 <p><code>storage</code> 以用户维度隔离，同一台设备上，A 用户无法读取到 B 用户的数据；不同小程序之间也无法互相读写数据</p> 
 <p><strong>存储大小限制</strong></p> 
 <p>除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 <code>key</code> 允许存储的最大数据长度为 1MB，所有数据存储上限为 <code>10MB</code></p> 
 <p><strong>插件隔离限制</strong></p> 
 <ol><li> <p>同一小程序使用不同插件：不同插件之间，插件与小程序之间 <code>storage</code> 不互通。</p> </li><li> <p>不同小程序使用同一插件：同一插件<code>storage</code>不互通</p> </li><li> <p><code>storage</code>只是针对当前用户,不同用户,使用不同的插件,他们之间<code>storage</code>是无法实现数据共用的 :::</p> </li></ol> 
 <p><strong>清理策略</strong></p> 
 <p>本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理</p> 
 <p><strong>注意事项</strong></p> 
 <p>将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容</p> 
 <p>也就是说,如果是相同的<code>key</code>，后面的会覆盖掉原来该 <code>key</code> 对应的内容</p> 
 <h4>设置/获取/删除存储</h4> 
 <p>使用的是<code>wx.setStorageSync()</code>,<code>wx.getStorageSync</code>方法</p> 
 <p><strong>如何设置本地存储数据</strong></p> 
 <pre class="has"><code class="language-go">wx.setStorage({
  key: 'key',
  data: 'value',
});
</code></pre> 
 <p>或如下简写方式</p> 
 <pre class="has"><code class="language-go">wx.setStorageSync('key', 'value');
</code></pre> 
 <p><strong>如何获取本地存储数据</strong></p> 
 <pre class="has"><code class="language-go">wx.getStorageSync({
  key: 'key',
  success(res) {
    console.log(res.data);
  },
});
</code></pre> 
 <p>或如下简写</p> 
 <pre class="has"><code class="language-go">var value = wx.getStorageSync('key');
</code></pre> 
 <p><strong>如何删除本地存储数据</strong></p> 
 <p>清除小程序当中的本地存储分为一次性全部删除所有存储,与删除存储中某指定的存储<code>key</code></p> 
 <pre class="has"><code class="language-go">wx.clearStorage(); // 一次性删除小程序中的所有存储数据
</code></pre> 
 <p>删除存储中某指定的存储<code>key</code>,一定要注意这两者的区别,有的小伙伴只知道<code>wx.clearStorage()</code></p> 
 <pre class="has"><code class="language-go">wx.removeStorageSync('key'); // 删除小程序中指定的key的存储
</code></pre> 
 <p>同样等价于</p> 
 <pre class="has"><code class="language-go">wx.removeStorageSync({
  key: 'key',
  success(res) {
    console.log(res);
  },
});
</code></pre> 
 <p><strong>注意</strong>:<code>wx.removeStorageSync</code>方法,不同于<code>wx.clearStorageSync()</code>方法,它同样也是删除小程序中所有同步存储的数据, 前者需要指定删除存储对应的<code>key</code>值,而后者不需要指定<code>key</code>,它是一次性删除所有同步存储的代码</p> 
 <pre class="has"><code class="language-go">wx.clearStorageSync(); // 一次性删除小程序中所有同步存储的数据
</code></pre> 
 <p>关于小程序中本地存储的方法确实容易让人晕,搞混淆,理解它们的区别,还是要在开发者工具中,自行调试,才知道每个方法之间区别差异的</p> 
 <p><strong>光看文字,不动手写代码测试,是无法理解他们之间的差异的,很容易搞混,在使用时容易乱套</strong></p> 
 <p><strong>提示</strong></p> 
 <p>凡是带<code>sync</code>结尾的都是同步的,而凡是带<code>clear</code>开头的都是一次性清除同步/异步的存储,而带·<code>remove</code>开头的都是需要指定删除某个存储的<code>key</code></p> 
 <h4>解决相同 key 覆盖问题</h4> 
 <p>在小程序中,当出现同名<code>key</code>,后者<code>key</code>覆盖前者是一个让人头疼的问题</p> 
 <p><strong>具体解决</strong></p> 
 <p>可以将需要存储数据存到一个数组当中,当需要使用时,取最后一个即可</p> 
 <p>至于若有增删操作,每次删除完某一数据后,重新在设置一次本地存储即可</p> 
 <pre class="has"><code class="language-go">let lists = wx.getStorageSync('lists'); // 先获取lists本地存储的数据
if (!lists) {
  // 第一次判断缓存中有没有lists数据
  lists = []; // 若没有,则存储设置一个空数组
}
lists.push(data); // 这里的data是要存储到本地中的数据
wx.setStorageSync('lists', lists); // 设置本地存储key:val
</code></pre> 
 <p>通过上面的操作,就解决了存储 key 值覆盖的问题,那么如何取最新的呢</p> 
 <pre class="has"><code class="language-go">const storageList = wx.getStorageSync('lists');
const listData = storageList[storageList.length - 1]; // 获取到最后一个
this.setData({
  // 重新setData数据即可
  lists: listData,
});
</code></pre> 
 <h4>是使用同步存储还是异步存储</h4> 
 <p>带有<code>Sync</code>,这个表示的<strong>同步</strong>的操作,与之相对的不带后缀就是<strong>异步</strong>”。</p> 
 <p>同步与异步是指的消息通讯机制。就是信息传来传去的时候是同步还异步。重点强调的是通讯这个动作。</p> 
 <p>很容易混淆,在计算机里,他们两是对立,相反的，同步代码是顺序执行,会形成阻塞,而异步代码不会阻塞,它是等待主线程执行完后,可以在回过头来执行</p> 
 <p>比如要请求用户信息的时候，需要从缓存中获取<code>username</code>这个变量，那只有先获取到这个变量才能进行下一步。那就应该使用同步,使用<code>wx.getStorageSync</code>。这样能确保一定能获取到这个变量,所有在第一次获取缓存中的数据时</p> 
 <p>我们往往先要判断一下缓存中是否有我们想要的那一数据的,否则若没有,在代码中使用了,就会报错</p> 
 <p>打电话就是一个同步的例子,必须先打完上一个,然后才能在打下一个,而发短信就是一个异步的例子,你可以跟 A 同学发,发完后不用等待,也可以更 B 同学发</p> 
 <p>在相同的时间内,使用同步只能干一件事情,必须得一件,一件的干完,而异步则在同一段时间内,可以同时干多件事情</p> 
 <p><code>JavaScript</code> 是单线程的,但是浏览器是多线程的.它的异步是借助事件实现的.具体可自行查看多线程与单线程相关知识的</p> 
 <h3> </h3> 
 <h2>05</h2> 
 <p>使用<code>eventChannel</code>向被打开页面传送数据(<code>wx.navigateTo</code>高级用法)</p> 
 <h3>对于页面与页面之间的数据通信,一种方式是,可以通过url携带参数的方式跳转到指定的页面,在跳转的指定页面中的onLoad生命周期函数中的options中可以拿到数据</h3> 
 <p>但是这种传递数据的方式是有限的,不适合数据多的情况下</p> 
 <p>另一种方式是可以传递数据没有限制,<code>wx.navigateTo</code>提供了一种更加高级的用法,通过<code>eventChannel</code>向被打开页面传送数据</p> 
 <h4>父(当前)页面向子(目标)页面传递数据</h4> 
 <p>被打开(上/父级)页面</p> 
 <pre class="has"><code class="language-go">Page({
  data: {
    parentPageData: {
      name: '川川',
      url: 'http://coder.itclan.cn',
      vx: 'itclanCoder',
    },
  },

  onEventChannel() {
    const parentPageData = this.data.parentPageData; // 当前页面的数据
    wx.navigateTo({
      url: `/pages/listDetail/listDetail`, // 打开的目标页面
      success: (res) =&gt; {
        // 通过eventChannel向被打开页面传送数据,目标页面是listDetail,这个data名字是你自己取的任意,在目标页面中有个参数接收就可以
        res.eventChannel.emit('parentPageEmit', { data: parentPageData });
      },
    });
  },
});
</code></pre> 
 <p>被打开(上/父级)页面的<code>wxml</code>,绑定事件</p> 
 <pre class="has"><code class="language-go">&lt;view bindtap="onEventChannel"&gt;打开跳转到目标页面&lt;/view&gt;
</code></pre> 
 <p>打开(目标)页面</p> 
 <p>在目标打开页面中通过<code>getOpenerEventChange</code>方法,用<code>on</code>进行监听被跳转页面的方法,就可以拿到被跳转页面中通过<code>emit</code>方法传递过来的数据,其中使用<code>on</code>监听的方法名与被跳转页面的名字保持一致就可以,这样实现了两个不同页面之间的数据通信传递</p> 
 <pre class="has"><code class="language-go">Page({
  data: {
    acceptParentData: {},
  },

  onLoad: function(options) {
    // 通过getOpenerEventChannel对象,对`parentPageEmit`进行监听
    const eventChannel = this.getOpenerEventChannel();
    eventChannel.on('parentPageEmit', (data) =&gt; {
      console.log(data);
      this.setData({
        acceptParentData: data,
      });
    });
  },
});
</code></pre> 
 <p><strong>说明 </strong></p> 
 <p>将某整个父页面的数据传递给跳转到的子页面,是一个比较常见的需求</p> 
 <p>比如在商品详情页面中,跳到到下单页面,需要将详情页面的一些数据</p> 
 <p>传递给跳转的子页面,那么这个时候,用<code>url</code>的方式传递数据就不时很合适,选用<code>eventChannel</code>的方式就比价适合</p> 
 <p>在<code>wx.navigateTo</code>的成功<code>success</code>回调中,通过<code>emit</code>进行触发,<code>emit</code>接收两个参数,第一个是监听事件的名称,第二个参数是需要向目标页面传递的数据</p> 
 <pre class="has"><code class="language-go">res.eventChannel.emit(`监听的事件名称parentPageEmit`, { data: '数据' });
</code></pre> 
 <p>在跳转的目标页面中,通过调用<code>getOpenerEventChannel</code>方法,然后进行<code>on</code>的绑定</p> 
 <pre class="has"><code class="language-go">const eventChannel = this.getOpenerEventChannel();
eventChannel.on('监听的事件名称parentPageEmit', (data) =&gt; {
  console.log(data);
  this.setData({
    acceptParentData: data,
  });
});
</code></pre> 
 <p>当前页面<code>--&gt;</code>目标页面是利用<code>wx.navigateTo</code> 中的 <code>success</code> 回调中使用 <code>emit</code> 触发,目标跳转页面用 <code>on</code> 监听</p> 
 <p>实现将当前页面的数据传递给目标页面中</p> 
 <p>那当前页面又如何获取目标页面的数据呢</p> 
 <h4>父(当前)页面如何获取跳转(子/目标)页面中的数据</h4> 
 <p>知道了当前页面向目标跳转页面传递数据,那么反过来,当前页面又如何接收跳转页面传递过来的数据?</p> 
 <p>当前页面</p> 
 <pre class="has"><code class="language-go">Page({
  data: {
    parentPageData: {
      name: '川川',
      url: 'http://coder.itclan.cn',
      vx: 'itclanCoder',
    },
    subdetailData: {},
  },

  onEventChannel() {
    const parentPageData = this.data.parentPageData; // 当前页面的数据
    wx.navigateTo({
      url: `/pages/listDetail/listDetail`, // 打开的目标页面
      events: {
        // 页面间通信接口，用于监听被打开页面发送到当前页面的数据
        // 取被打开页面传送到当前页面的数据
        subPageEmit: (data) =&gt; {
          console.log(data);
          this.setData({
            subdetailData: data,
          });
        },
      },
    });
  },
});
</code></pre> 
 <p>wxml</p> 
 <pre class="has"><code class="language-go">&lt;view class="subdetail-box"&gt;
  &lt;block wx:for="{<!-- -->{subdetailData}}" wx:key="index"&gt;
    &lt;view&gt;姓名:{<!-- -->{item.name}}&lt;/view&gt;
    &lt;view&gt;站点:{<!-- -->{item.url}}&lt;/view&gt;
    &lt;view&gt;微信:{<!-- -->{item.vx}}&lt;/view&gt;
  &lt;/block&gt;
&lt;/view&gt;
</code></pre> 
 <p>子页面目标页面</p> 
 <pre class="has"><code class="language-go">Page({
  data: {
    subdetailData: {
      name: '轻记账小程序-我是子页面传递过来的数据',
      url: 'http://itclan.cn/',
      vx: 'itclanCoder',
    },
  },

  onLoad: function(options) {
    this.returnSubPagePrev();
  },

  returnSubPagePrev() {
    const subdetailData = this.data.subdetailData;
    const eventChannel = this.getOpenerEventChannel();
    // 通过emit的方式进行触发,将子页面/目标页面中的数据传递给当前页面
    eventChannel.emit('subPageEmit', { data: subdetailData });
  },
});
</code></pre> 
 <p><strong>说明</strong></p> 
 <p>在当前页面中获取子页面的数据,是借助<code>wx.navigateTo</code>中提供的<code>event</code>这个参数接口,它可以用于监听被打开页面发送到当前页面的数据</p> 
 <p>换言之,也就是当前页面可以获取监听到子页面传递过来的数据,在子页面中通过<code>emit</code>的方式进行触发,同样,<code>emit</code>方法接收两个参数</p> 
 <p>第一个是监听的事件名称,第二个参数对象是具体要传递的数据</p> 
 <h3>结语</h3> 
 <p>本文主要介绍 4 种在小程序当中页面与页面之间的传递数据常见方法,其中如何返回上一级页面,这些都是实际开发中经常会遇到的问题</p> 
 <p>每一种方法都有与之对应的应用场景,<code>url</code> 方式比较适合跳转,携带少量的数据,当多个页面需要共享同一个数据对象时,可以使用全局<code>globalData</code>对象,也可以使用本地缓存数据</p> 
 <p>以及最后一种使用 <code>eventChannel</code> 向被打开页面传送数据(<code>wx.navigateTo</code>高级用法)</p> 
 <p>它适合一种传递复杂的数据.</p> 
 <p>关于页面之间数据传递就介绍这么多,如果您有问题,欢迎补充,给我留言,一起学习成长</p> 
 <h3>相关文档</h3> 
 <ul><li> <p>原文出处:微信小程序-页面与页面中间的数据通信  https://coder.itclan.cn/wechat/minprogram/page-between-transdata/</p> </li><li> <p>wx.navigateTo 跳转</p> </li><li> <p>https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html</p> </li><li> <p>小程序-页面路由</p> </li><li> <p>https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html</p> </li><li> <p>小程序-页面间通信</p> </li><li> <p>https://developers.weixin.qq.com/miniprogram/dev/api/route/EventChannel.html</p> </li><li> <p>小程序-本地存储</p> </li><li> <p>https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html</p> </li></ul> 
 <p> </p> 
 <p>戳原文，阅读体验会更好哦</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1c6404032aa65642fa5fd9aa57b93396/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springcloud项目改名</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/055db14c2f7c511a1cb4798a0ad589e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python剪刀石头布编程思路-python练习案例--剪刀石头布</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>