<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构基础 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构基础" />
<meta property="og:description" content="一、数据结构的有关概念
1．掌握数据结构的有关概念，理解逻辑结构与物理结构之间的关系。
1. 数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 2. 数据元素：数据的基本单位，一个数据元素可由若干数据项组成。 3. 数据项：数据的不可分割的最小单位。 4. 数据对象：性质相同的数据元素的集合，是数据的一个子集。 5. 数据结构：指互相之间存在着一种或多种特定关系的数据元素的集合，包括逻辑结构，存储结构和对数据的运算。（数据元素都不是孤立存在的）。 6. 抽象数据类型（ADT）：指一个数学模型以及定义在该模型上的一组操作，只取决于它的一组逻辑特性，用一个三元组表示（D, S, P）。 7. 数据类型：是程序设计语言中的一个概念，它是一个值的集合和操作的集合。 8. 逻辑结构：是指数据之间关系的描述，与数据的存储结构无关。分为线性结构和非线性结构，通常分为四类结构： 9. 存储结构：是指数据结构在计算机中的表示，又称为数据的物理结构。它包括数据元素的表示和关系的表示， 2．掌握数据结构的几种基本结构。
逻辑结构：是指数据之间关系的描述，与数据的存储结构无关。分为线性结构和非线性结构，通常分为四类结构：
1. 集合：结构中的数据元素除了同属于一种类型外，别无其它关系。 2. 线性结构：结构中的数据元素之间存在一对一的关系。 3. 树型结构：结构中的数据元素之间存在一对多的关系。 4. 图状结构（网状结构）：结构中的数据元素之间存在多对多的关系。 存储结构：是指数据结构在计算机中的表示，又称为数据的物理结构。它包括数据元素的表示和关系的表示，通常由四种基本的存储方法实现：
1. **顺序存储**方式。数据元素顺序存放，每个存储结点只含一个元素，存储位置反映数据元素间的逻辑关系，存储密度大。有些操作（如插入、删除）效率较差。 2. **链式存储**方式。每个存储结点除包含数据元素信息外还包含一组（至少一个）指针，指针反映数据元素间的逻辑关系。这种方式不要求存储空间连续，便于动态操作（如插入、删除等），但存储空间开销大（用于指针），且不能折半查找。 3. **索引存储**方式。除数据元素存储在一组地址连续的内存空间外，还需建立一个索引表，索引表中索引指示存储结点的存储位置（下标）或存储区间端点（下标）。 4. **散列存储**方式。通过散列函数和解决冲突的方法，将关键字散列在连续的有限的地址空间内，并将散列函数的值解释成关键字所在元素的存储地址。其特点是存取速度快，只能按关键字随机存取，不能顺序存取，也不能折半存取。 3．掌握抽象数据类型的表示与实现方法。
抽象数据类型（ADT）：指一个数学模型以及定义在该模型上的一组操作，只取决于它的一组逻辑特性，用一个三元组表示（D, S, P）。
4．熟悉算法分析的分析方法。
语句频度 T(n)，又被称为时间频度，指的是该语句重复执行的次数
详情
一
int i = 1; int k = 0; int n = 10; while(i &lt;= n-1){ k &#43;= 10 * i; /*计算该语句频度*/ i&#43;&#43;; } while 循环了多少次，就是该语句的频度 while 执行一次 i 自增 1 ，当 i&gt;n-1 时退出，就是当 i=n 时退出 while，i 一开始为 1，所以 while 总共循环了 n-1 次; 频度 ：n-1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/34f6387e6e41b7e3e7264e19067f5af1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-20T17:40:52+08:00" />
<meta property="article:modified_time" content="2022-10-20T17:40:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构基础</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一、数据结构的有关概念<br> 1．掌握数据结构的有关概念，理解逻辑结构与物理结构之间的关系。</p> 
<pre><code> 1. 数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。
    
2. 数据元素：数据的基本单位，一个数据元素可由若干数据项组成。
   
 3. 数据项：数据的不可分割的最小单位。
    
 4. 数据对象：性质相同的数据元素的集合，是数据的一个子集。
    
 5. 数据结构：指互相之间存在着一种或多种特定关系的数据元素的集合，包括逻辑结构，存储结构和对数据的运算。（数据元素都不是孤立存在的）。
    
 6. 抽象数据类型（ADT）：指一个数学模型以及定义在该模型上的一组操作，只取决于它的一组逻辑特性，用一个三元组表示（D, S, P）。
    
 7. 数据类型：是程序设计语言中的一个概念，它是一个值的集合和操作的集合。
    
 8. 逻辑结构：是指数据之间关系的描述，与数据的存储结构无关。分为线性结构和非线性结构，通常分为四类结构：

 9. 存储结构：是指数据结构在计算机中的表示，又称为数据的物理结构。它包括数据元素的表示和关系的表示，
</code></pre> 
<p>2．掌握数据结构的几种基本结构。<br> 逻辑结构：是指数据之间关系的描述，与数据的存储结构无关。分为线性结构和非线性结构，通常分为四类结构：</p> 
<pre><code> 1. 集合：结构中的数据元素除了同属于一种类型外，别无其它关系。
    
 2.  线性结构：结构中的数据元素之间存在一对一的关系。
    
 3. 树型结构：结构中的数据元素之间存在一对多的关系。
    
 4. 图状结构（网状结构）：结构中的数据元素之间存在多对多的关系。
</code></pre> 
<p>存储结构：是指数据结构在计算机中的表示，又称为数据的物理结构。它包括数据元素的表示和关系的表示，通常由四种基本的存储方法实现：</p> 
<pre><code> 1. **顺序存储**方式。数据元素顺序存放，每个存储结点只含一个元素，存储位置反映数据元素间的逻辑关系，存储密度大。有些操作（如插入、删除）效率较差。
    
  
 2. **链式存储**方式。每个存储结点除包含数据元素信息外还包含一组（至少一个）指针，指针反映数据元素间的逻辑关系。这种方式不要求存储空间连续，便于动态操作（如插入、删除等），但存储空间开销大（用于指针），且不能折半查找。

 3. **索引存储**方式。除数据元素存储在一组地址连续的内存空间外，还需建立一个索引表，索引表中索引指示存储结点的存储位置（下标）或存储区间端点（下标）。

    

 4. **散列存储**方式。通过散列函数和解决冲突的方法，将关键字散列在连续的有限的地址空间内，并将散列函数的值解释成关键字所在元素的存储地址。其特点是存取速度快，只能按关键字随机存取，不能顺序存取，也不能折半存取。
</code></pre> 
<p>3．掌握抽象数据类型的表示与实现方法。<br> 抽象数据类型（ADT）：指一个数学模型以及定义在该模型上的一组操作，只取决于它的一组逻辑特性，用一个三元组表示（D, S, P）。<br> 4．熟悉算法分析的分析方法。</p> 
<p>语句频度 T(n)，又被称为时间频度，指的是该语句重复执行的次数<br> <a href="https://blog.csdn.net/weixin_44589374/article/details/107851422">详情</a></p> 
<p>一</p> 
<pre><code>int i = 1;
int k = 0;
int n = 10;
while(i &lt;= n-1){
	k += 10 * i;  /*计算该语句频度*/
	i++;
}
</code></pre> 
<blockquote> 
 <p>while 循环了多少次，就是该语句的频度 while 执行一次 i 自增 1 ，当 i&gt;n-1 时退出，就是当 i=n 时退出 while，i 一开始为 1，所以 while 总共循环了 n-1 次; 频度 ：n-1</p> 
</blockquote> 
<p>二</p> 
<pre><code>int i = 1;
int k = 0;
int n = 10;
do{
	k += 10 * i;  /*计算该语句频度*/
	i++;
}while(i &lt;= n-1);
</code></pre> 
<blockquote> 
 <p>循环了多少次，就是该语句的频度 循环体执行一次 i 自增 1 ，当 i&gt;n-1 时退出，就是当 i=n 时退出循环体，i 一开始为 1<br> ，所以循环体总共循环了 n-1 次; 频度 ：n-1</p> 
</blockquote> 
<p>三</p> 
<pre><code>int i = 1;
int k = 0;
int n = 10;
while(i &lt;= n-1){
	i++;
	k += 10 * i;  /*计算该语句频度*/
}
</code></pre> 
<blockquote> 
 <p>循环了多少次，就是该语句的频度 循环体执行一次 i 自增 1 ，当 i&gt;n-1 时退出，就是当 i=n 时退出循环体，i 一开始为 1<br> ，所以循环体总共循环了 n-1 次; 频度 ：n-1</p> 
</blockquote> 
<p>四</p> 
<pre><code>int k = 0;
int n = 10;
for(int i = 1; i &lt;= n; i++){
	for(int j = i; j&lt;=n; j++){
		k++;    /*计算该语句频度*/
	}
}
</code></pre> 
<blockquote> 
 <p>第一层循环 n 次 第二层循环 n+(n-1)+(n-2)+…+2+1 = n(n+1)/2 ,所以 k++ 执行了 n(n+1)/2 次<br> 频度 ：n(n+1)/2</p> 
</blockquote> 
<p>五</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	i<span class="token operator">++</span><span class="token punctuation">;</span>    	<span class="token comment">/*计算该语句频度*/</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>循环体执行 floor(sqrt(n)) 次 频度: ⌊ n ⌋ \lfloor \sqrt{n}\rfloor⌊ n ​ ⌋</p> 
</blockquote> 
<p>六</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">/*计算该语句频度*/</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>第一层 n 第二层 1+2+3+4+…+n 第三层 1+(1+2)+(1+2+3)+(1+2+3+4)+…+(1+2+3+4+…+n) = n(n+1)(2n+3)/12 频度：n(n+1)(2n+3)/12</p> 
</blockquote> 
<p>七</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> j<span class="token punctuation">)</span><span class="token comment">/*计算该语句频度*/</span> j<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>注意：if 语句不管真假都会判断一次，所以循环了多少次就判断了多少次 if 语句 当 i+j=n+1 时退出循环 所以循环次数为<br> (n+1)-1 = n 所以频度为 n</p> 
</blockquote> 
<p>八</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">91</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>y <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">/*计算该判断语句频度*/</span>
		x <span class="token operator">-=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		y<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
		x<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>看 while 循环体中的 if 语句频度就看 while 循环次数 开始 x=91 ,循环了 10 次，每次都执行 else ，直到<br> x=101 当 x=101，循环了 1 次，if 条件成立，x 又变成了 91 ，而 y=99; while<br> 循环还没退出之前都是按照这规律循环，直到 y=0 退出 while ，一共重复了 100 遍上面的规律，每次 11 次循环，<br> 所以该语句频度为 100*11 = 1100</p> 
</blockquote> 
<p>注意</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//(1)</span>
	k<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">//(2)</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>(1)语句频度是n+1 i 变量在第一个 for 循环中，从取 i = 0 开始执行，直到i=n时为止，至此，i<br> 执行了n次。加上最后i=n+1跳出循环的判断，故，频度共n+1 次；</p> 
 <p>(2)语句频度是n 当 i = n+1时跳出循环，所以里面的循环体一共执行了 n 次0</p> 
</blockquote> 
<blockquote> 
 <p>时间复杂度 简单的说，就是保留语句频度的最高次幂，并且把系数去掉。 如T(n)=2n^2+n+1=O(n)</p> 
</blockquote> 
<h3><a id="_202"></a>二、线性表</h3> 
<p><strong>掌握线性表的顺序存储方法及链式存储方法。</strong><br> 线性表的基本概念</p> 
<ol><li>线性表：是具有相同数据类型的 n 个数据元素的有限序列。</li><li>特点：</li></ol> 
<ul><li> <p>存在惟一的第一个元素。</p> </li><li> <p>存在惟一的最后一个元素。</p> </li><li> <p>除第一个元素之外，每个元素均只有一个直接前驱。</p> </li><li> <p>除最后一个元素之外，每个元素均只有一个直接后继。</p> </li></ul> 
<ol start="3"><li>线性表的存储结构：</li></ol> 
<ul><li>顺序存储结构：顺序表</li><li>链式存储结构：链表</li></ul> 
<p><strong>熟悉线性表的建立、插入、删除、搜索与归并算法。</strong></p> 
<h4><a id="22__224"></a>2.2. 顺序表</h4> 
<h5><a id="_226"></a>顺序表的基本概念</h5> 
<ol><li> <p>顺序表：用顺序存储的方式实现线性表。顺序存储，将逻辑上相邻的元素存储在相邻的物理位置上。</p> </li><li> <p>特点：</p> </li></ol> 
<ul><li>随机访问，即可以在 O ( 1 ) O(1)O(1) 时间内找到第 i 个元素。</li><li>存储密度高，每个节点只存储数据元素。</li><li>拓展容量不方便（即使使用动态分配的方式实现，拓展长度的时间复杂度也比较高，因为需要把数据复制到新的区域）。</li><li>插入删除操作不方便，需移动大量元素：O ( n ) O(n)O(n)</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span> </span><span class="token comment">// 定义最大长度 </span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用静态的数组存放数据元素 </span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">// 顺序表的当前长度 </span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span>

<span class="token comment">// 初始化顺序表 </span>
<span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	L<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 顺序表初始长度为0 </span>
<span class="token punctuation">}</span>
<span class="token comment">// 在顺序表i位置插入e</span>
bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 判断i的范围是否有效 </span>
		<span class="token keyword">return</span> false<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> MaxSize<span class="token punctuation">)</span> <span class="token comment">// 判断存储空间是否已满 </span>
		<span class="token keyword">return</span> false<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">// 将第i个元素之后的元素后移 </span>
		L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 在位置i处放入e </span>
	L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 长度+1 </span>
	<span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token comment">// 删除顺序表i位置的数据并存入e</span>
bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 判断i的范围是否有效</span>
		<span class="token keyword">return</span> false<span class="token punctuation">;</span>
	e <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 将被删除的元素赋值给e </span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//将第i个位置后的元素前移 </span>
		L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> true<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 查找第一个元素值为e的元素，并返回其位序 </span>
<span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> e<span class="token punctuation">)</span>
			<span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 数组下标为i的元素值等于e，返回其位序i+1 </span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 没有查找到 </span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	SqList L<span class="token punctuation">;</span> <span class="token comment">// 声明一个顺序表 </span>
	<span class="token function">InitList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化顺序表 </span>
	<span class="token function">ListInsert</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="231__291"></a>2.3.1. 单链表的基本概念</h5> 
<ol><li>单链表：用链式存储实现了线性结构。一个结点存储一个数据元素，各结点间的前后关系用一个指针表示。</li><li>特点：</li></ol> 
<ul><li>优点：不要求大片连续空间，改变容量方便。</li><li>缺点：不可随机存取，要耗费一定空间存放指针。</li></ul> 
<ol start="3"><li>两种实现方式：</li></ol> 
<ul><li>带头结点，写代码更方便。头结点不存储数据，头结点指向的下一个结点才存放实际数据。</li><li>不带头结点，麻烦。对第一个数据结点与后续数据结点的处理需要用不同的代码逻辑，对空表和非空表的处理需要用不同的代码逻辑。</li></ul> 
<h5><a id="232__302"></a>2.3.2. 单链表的实现</h5> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{<!-- --></span>      
    ElemType data<span class="token punctuation">;</span>      
    <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span>

<span class="token comment">// 初始化一个单链表（带头结点）</span>
bool <span class="token function">InitList</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>      
    L <span class="token operator">=</span> <span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//分配一个头结点 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token comment">//内存不足，分配失败    </span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    
    L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token comment">//头结点之后暂时还没有结点   </span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//在第i个位置插入元素e</span>
bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>       
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>         
        <span class="token keyword">return</span> False<span class="token punctuation">;</span>   
    LNode <span class="token operator">*</span>p<span class="token punctuation">;</span>           <span class="token comment">//指针p指向当前扫描到的结点    </span>
    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">//当前p指向的是第几个结点   </span>
    p <span class="token operator">=</span> L<span class="token punctuation">;</span>              <span class="token comment">//循环找到第i-1个结点    </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>       <span class="token comment">//如果i&gt;lengh，p最后会等于NULL </span>
        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>              
        j<span class="token operator">++</span><span class="token punctuation">;</span>      
    <span class="token punctuation">}</span>       
    <span class="token comment">//p值为NULL说明i值不合法   </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>       
    <span class="token comment">//在第i-1个结点后插入新结点  </span>
    LNode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>LNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>     
    s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> 
    p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>       
    <span class="token comment">//将结点s连到p后      </span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除第i个结点并将其所保存的数据存入e</span>
bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>      
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>             
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>     
    LNode <span class="token operator">*</span>p<span class="token punctuation">;</span>       <span class="token comment">//指针p指向当前扫描到的结点     </span>
    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//当前p指向的是第几个结点    </span>
    p <span class="token operator">=</span> L<span class="token punctuation">;</span>         
    <span class="token comment">//循环找到第i-1个结点     </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   
        <span class="token comment">//如果i&gt;lengh，p和p的后继结点会等于NULL        </span>
        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            
        j<span class="token operator">++</span><span class="token punctuation">;</span>      
    <span class="token punctuation">}</span>       
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>       
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    	   
    <span class="token comment">//令q暂时保存被删除的结点   </span>
    LNode <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    
    e <span class="token operator">=</span> q<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>     
    p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>      
    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>     
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找数据域为e的结点指针，否则返回NULL</span>
LNode <span class="token operator">*</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>           
    LNode <span class="token operator">*</span>P <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>     
    <span class="token comment">// 从第一个结点开始查找数据域为e的结点  </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   
        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>     
    <span class="token punctuation">}</span>     
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3．了解一元多项式的表示方法及其应用。<br> 三、栈和队列<br> 1．掌握栈和队列的顺序存储方法及链式存储方法。</p> 
<h5><a id="31__383"></a>3.1. 栈</h5> 
<h6><a id="311__385"></a>3.1.1. 栈的基本概念</h6> 
<ol><li>栈是特殊的线性表：只允许在一端进行插入或删除操作，其逻辑结构与普通线性表相同。</li><li>栈顶：允许进行插入和删除的一端 （最上面的为栈顶元素）。</li><li>栈底：不允许进行插入和删除的一端 （最下面的为栈底元素）。</li><li>空栈：不含任何元素的空表。</li><li>特点：后进先出（后进栈的元素先出栈）、LIFO（Last In First Out）。</li><li>缺点：栈的大小不可变，解决方法：共享栈。</li></ol> 
<p>2．熟悉进栈、出栈、进队、出队的实现方法。</p> 
<h5><a id="313__395"></a>3.1.3. 栈的顺序存储实现</h5> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义栈中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>    
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//静态数组存放栈中元素    </span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                      <span class="token comment">//栈顶元素</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>

<span class="token comment">// 初始化栈</span>
<span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
    S<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token comment">//初始化栈顶指针</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新元素进栈</span>
bool <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    <span class="token comment">// 判断栈是否已满    </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> MaxSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    
    S<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token operator">++</span>S<span class="token punctuation">.</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 出栈</span>
bool <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    <span class="token comment">// 判断栈是否为空    </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    
    x <span class="token operator">=</span> S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>S<span class="token punctuation">.</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>共享栈（两个栈共享同一片空间）：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义栈中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>       
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//静态数组存放栈中元素  </span>
    <span class="token keyword">int</span> top0<span class="token punctuation">;</span>                     <span class="token comment">//0号栈栈顶指针  </span>
    <span class="token keyword">int</span> top1<span class="token punctuation">;</span>                     <span class="token comment">//1号栈栈顶指针</span>
<span class="token punctuation">}</span>ShStack<span class="token punctuation">;</span>

<span class="token comment">// 初始化栈</span>
<span class="token keyword">void</span> <span class="token function">InitSqStack</span><span class="token punctuation">(</span>ShStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    
    S<span class="token punctuation">.</span>top0 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      
    S<span class="token punctuation">.</span>top1 <span class="token operator">=</span> MaxSize<span class="token punctuation">;</span>   
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="314__448"></a>3.1.4. 栈的链式存储实现</h5> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Linknode</span><span class="token punctuation">{<!-- --></span>        
    ElemType data<span class="token punctuation">;</span>        <span class="token comment">//数据域    </span>
    Linknode <span class="token operator">*</span>next<span class="token punctuation">;</span>       <span class="token comment">//指针域</span>
<span class="token punctuation">}</span>Linknode<span class="token punctuation">,</span><span class="token operator">*</span>LiStack<span class="token punctuation">;</span>

<span class="token comment">// 初始化栈</span>
bool <span class="token function">InitStack</span><span class="token punctuation">(</span>LiStack <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    
    L <span class="token operator">=</span> <span class="token punctuation">(</span>Linknode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Linknode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">if</span><span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>             
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>   
    L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新元素入栈</span>
bool <span class="token function">pushStack</span><span class="token punctuation">(</span>LiStack <span class="token operator">&amp;</span>L<span class="token punctuation">,</span>ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    Linknode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>Linknode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Linknode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>         
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>   
    s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>     
    <span class="token comment">// 头插法      </span>
    s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  
    L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>     
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 出栈</span>
bool <span class="token function">popStack</span><span class="token punctuation">(</span>LiStack <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>     
    <span class="token comment">// 栈空不能出栈  </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>     
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    
    Linknode <span class="token operator">*</span>s <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  
    x <span class="token operator">=</span> s<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>       
    L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>       
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="32__491"></a>3.2. 队列</h3> 
<h4><a id="321__493"></a>3.2.1. 队列的基本概念</h4> 
<ol><li>队列是操作受限的线性表：只允许在一端进行插入 (入队)，另一端进行删除 (出队)。</li><li>队头：允许删除的一端。</li><li>队尾：允许插入的一端。</li><li>空队列：不含任何元素的空表。</li><li>特点：先进先出（先入队的元素先出队）、FIFO（First In First Out）。</li></ol> 
<h5><a id="323__500"></a>3.2.3. 队列的顺序存储实现</h5> 
<p>注意：</p> 
<ul><li> <p>循环队列不能使用Q.rear == Q.front作为判空的条件，因为当队列已满时也符合该条件，会与判空发生冲突！</p> </li><li> <p>解决方法一：牺牲一个单元来区分队空和队满，即将(Q.rear+1)%MaxSize == Q.front作为判断队列是否已满的条件。（主流方法）</p> </li><li> <p>解决方法二：设置 size 变量记录队列长度。</p> </li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span>     </span><span class="token comment">//定义队列中元素的最大个数</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>     
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//用静态数组存放队列元素     </span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>          <span class="token comment">//队头指针和队尾指针</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>
<span class="token comment">// 初始化队列</span>
<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    
    <span class="token comment">// 初始化时，队头、队尾指针指向0   </span>
    <span class="token comment">// 队尾指针指向的是即将插入数据的数组下标  </span>
    <span class="token comment">// 队头指针指向的是队头元素的数组下标</span>
    Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新元素入队</span>
bool <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>       
    <span class="token comment">// 如果队列已满直接返回</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> 	<span class="token comment">//牺牲一个单元区分队空和队满   </span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    
    Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>   
    Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token punctuation">;</span> 
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 出队</span>
bool <span class="token function">DeQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    
    <span class="token comment">// 如果队列为空直接返回    </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span>  
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>     
    x <span class="token operator">=</span> Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="324__546"></a>3.2.4. 队列的链式存储实现</h5> 
<pre><code class="prism language-c"><span class="token comment">// 链式队列结点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>  
    ElemType data<span class="token punctuation">;</span>    
    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 链式队列</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>       
    <span class="token comment">// 头指针和尾指针  </span>
    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>
<span class="token comment">// 初始化队列</span>
<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   
    <span class="token comment">// 初始化时，front、rear都指向头结点 </span>
    Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    Q<span class="token punctuation">.</span>front <span class="token operator">-&gt;</span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新元素入队</span>
<span class="token keyword">void</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
    LinkNode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>  
    s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> 
    Q<span class="token punctuation">.</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>  
    Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 队头元素出队</span>
bool <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span>         
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> 
    x <span class="token operator">=</span> p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>   
    Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> 
    <span class="token comment">// 如果p是最后一个结点，则将队头指针也指向NULL  </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span>          
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span>   
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>     
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3．栈和对列的简单应用。</p> 
<h5><a id="331__591"></a>3.3.1 栈在括号匹配中的应用</h5> 
<ol><li>栈在括号匹配中的应用 
  <ul><li>用栈实现括号匹配： 
    <ol><li>最后出现的左括号最先被匹配 （栈的特性——LIFO）。</li><li>遇到左括号就入栈。</li><li>遇到右括号，就“消耗”一个左括号（出栈）。</li></ol> </li><li>匹配失败情况： 
    <ol><li>扫描到右括号且栈空，则该右括号单身。</li><li>扫描完所有括号后，栈非空，则该左括号单身。</li><li>左右括号不匹配。</li></ol> </li></ul> </li><li>栈在表达式求值中的应用<br> 中序表达式转后序表达式的具体规则如下：</li></ol> 
<blockquote> 
 <ol><li>准备两个栈（java.util.Stack），栈number用来存储数据和后序表达式的结果，栈action用来存储op(+、-、<em>、/)。<br> 2. 数字直接压入number栈，如果action栈为空，则op(+、-、</em>、/)压栈，如果不为空，遵循 3 中的规则。<br> 3. 遇到op(+、-、*、/)时检查此操作符和栈顶操作符的优先级，如果优先级高于栈顶操作符，则此操作符压入action栈，否则将栈顶操作符弹出压入number栈(number栈存储结果)，此操作符压栈。<br> 4. 如果遇到“（”则直接压入action栈，如果 中检查优先级时栈顶的操作符为“（”则认为任何操作符的优先级高于“（”，直接将操作符压栈。<br> 5. 如果遇到“）”则action弹栈并压入number栈，直到遇到“（”。<br> 6. 中序表达式结束之后如果action栈不为空，则action弹栈并依次压入number栈。<br> 7.所有操作结束后number中存储的就是后序表达式的反序，将number栈中的元素顺序反过来就是后序表达式<br> 一</li></ol> 
</blockquote> 
<pre><code class="prism language-c"><span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">5</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>
</code></pre> 
<p>二</p> 
<pre><code class="prism language-c"><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span> <span class="token number">6</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span>
</code></pre> 
<p>三</p> 
<pre><code class="prism language-c"><span class="token punctuation">(</span><span class="token number">23</span><span class="token operator">+</span><span class="token number">34</span><span class="token operator">*</span><span class="token number">45</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">+</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>一<br> 2 5 1 - *<br> 二<br> 5 60 3 1 - * 6 4 - / 3 + +<br> 三<br> 23 34 45 * 5 6 + 7 + / +</p> 
</blockquote> 
<h5><a id="334__634"></a>3.3.4. 队列的应用</h5> 
<ol><li>树的层次遍历</li><li>图的广度优先遍历<br> 4．递归的实现。<br> 四、串<br> 1．掌握串的有关概念，了解顺序存储方法及链式存储方法。</li></ol> 
<h4><a id="41__641"></a>4.1. 串的基本概念</h4> 
<ol><li>串：即字符串（String）是由零个或多个字符组成的有限序列。</li><li>串的长度：中字符的个数 n，n = 0 n = 0n=0 时的串称为空串。</li><li>子串：串中任意个连续的字符组成的子序列。</li><li>主串：包含子串的串。</li><li>字符在主串中的位置：字符在串中的序号。</li><li>子串在主串中的位置：子串的第一个字符在主串中的位置 。</li></ol> 
<p>2．了解串的有关操作的实现方法。</p> 
<ul><li>StrAssign(&amp;T, chars)：赋值操作。把串 T 赋值为 chars。</li><li>StrCopy(&amp;T, S)：复制操作。由串 S 复制得到串 T。</li><li>StrEmpty(S)：判空操作。若 S 为空串，则返回 TRUE，否则返回 FALSE。</li><li>StrLength(S)：求串长。返回串 S 中元素的个数。</li><li>ClearString(&amp;S)：清空操作。将 S 清为空串。</li><li>DestroyString(&amp;S)：销毁串。将串 S 销毁（回收存储空间）。</li><li>Concat(&amp;T, S1, S2)：串联接。用 T 返回由 S1 和 S2 联接而成的新串 。</li><li>SubString(&amp;Sub, S, pos, len)：求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</li><li>Index(S, T)：定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为 0。</li><li>StrCompare(S, T)：比较操作。若 S&gt;T，则返回值&gt;0；若 S=T，则返回值=0；若 S&lt;T，则返回值&lt;0。</li></ul> 
<p>3．了解串的模式匹配算法。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">index_BF</span><span class="token punctuation">(</span>String S<span class="token punctuation">,</span>String A<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token operator">-&gt;</span>length<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>A<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c=%c\n"</span><span class="token punctuation">,</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>A<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>
			j<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			i<span class="token operator">=</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//计算出下一个比较开始下标 </span>
			j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>A<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> i<span class="token operator">-</span>A<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span>String S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> next<span class="token punctuation">[</span>S<span class="token operator">-&gt;</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//定义返回值变量</span>
	next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>S<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span>
			next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>4．串的简单应用。<br> 五、数组与广义表<br> 1． 掌握数组的顺序存储方法及矩阵的压缩存储方法。</p> 
<h3><a id="_706"></a>数据压缩</h3> 
<p><strong>三角矩阵：主对角线两边对称</strong><br> <img src="https://images2.imgbox.com/5c/39/1ibEU9wN_o.gif" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>压缩思想：使用线性结构存储主对角线下三角部分，或者上三角部分达到压缩的效果。<br> 元素存储线性结构位置：下三角或者上三角n-1项数列求和，再加上当前行。</p> 
</blockquote> 
<p>上三角公式：i行号，j列。<br> <img src="https://images2.imgbox.com/61/27/tn8Km5gY_o.gif" alt="在这里插入图片描述"></p> 
<p><strong>稀疏矩阵：只有少数的元素是非空的</strong></p> 
<p><img src="https://images2.imgbox.com/2d/a3/9xJjgbSq_o.gif" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>压缩是思想：使用数组或者链表去记录每个元素的（行、列、值）达到压缩效果。(是无法随机存取的)</p> 
</blockquote> 
<pre><code class="prism language-c">如：array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span>
    array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span>
	array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
</code></pre> 
<p>十字链表法：记录稀疏矩阵的行排序和列排序。<br> <img src="https://images2.imgbox.com/ff/2f/bAMLDiLS_o.gif" alt="在这里插入图片描述"><br> 压缩思想：记录行标和列表是数组达到压缩效果，但是有记录了行下一个元素位置和列下一个元素位置。<br> <img src="https://images2.imgbox.com/5b/e2/ICHQGV7G_o.gif" alt="在这里插入图片描述"><br> 可以通过行数组或者列数组，遍历行列数据。<br> <strong>对角矩阵:主对角线或者反对角线的两边空元素对称</strong><br> <img src="https://images2.imgbox.com/79/c5/yJmRiww9_o.jpg" alt="8*8的7对角矩阵"><br> <img src="https://images2.imgbox.com/29/bb/39m5NZPP_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>压缩思想：通过对角数，将8*8矩阵变成7*8矩阵 。</p> 
 <p>为了以后叙述方便，我们定义几个量：</p> 
 <p>diag：对角线条数</p> 
 <p>size：方阵高度</p> 
 <p>firstRowNum= ，第一行元素数（表达式易证）<br> 2． 掌握矩阵的转置算法和矩阵的相加算法的实现。<br> 3． 了解广义表在m元多项式中的简单应用。<br> 广义表<br> 广义表具有如下重要的特性：<br> （1）广义表中的数据元素有<strong>相对次序</strong>；<br> （2）广义表的<strong>长度</strong>定义为<strong>最外层包含元素个数</strong>；<br> （3）广义表的<strong>深度</strong>定义为<strong>所含括弧的重数</strong>。其中<strong>原子的深度为0</strong>，<strong>空表的深度为1</strong>；<br> （4）广义表可以<strong>共享</strong>；一个广义表可以为其他广义表共享；这种共享广义表称为<strong>再入表</strong>；<br> （5）广义表可以是一个<strong>递归的表</strong>。一个广义表可以是自已的子表。这种广义表称为递归表。递归表的<strong>深度是无穷值</strong>,长度是有限值；</p> 
</blockquote> 
<p>（6）任何一个<strong>非空广义表</strong>GL均可分解为<strong>表头</strong>head(GL) = a1和<strong>表尾</strong>tail(GL) = ( a2,…,an) 两部分。</p> 
<p>为了简单起见,下面讨论的广义表不包括前面定义的再入表和递归表，即只讨论一般的广义表。</p> 
<p>另外,我们规定用小写字母表示原子，用大写字母表示广义表的表名。例如：</p> 
<blockquote> 
 <pre><code>A=()
B=(e)
C=(a,(b,c,d))
D=(A,B,C)=((),(e),(a,(b,c,d)))
E=((a,(a,b),((a,b),c)))
</code></pre> 
</blockquote> 
<p>其中A是一个空表，其长度为0；</p> 
<p>B是只含有单个原子e的表，其长度为1；</p> 
<p>C有两个元素，一个是原子a，另一个是子表，其长度为2；</p> 
<p>D有三个元素，每个元素都是一个表，其长度为3；</p> 
<p>E中只含有一个元素，是一个表，它的长度为1；</p> 
<h4><a id="_777"></a>六、树和二叉树</h4> 
<p>1． 熟悉树和二叉树的有关定义，掌握二叉树的顺序存储结构和链式存储结构的实现方法。</p> 
<h5><a id="51__780"></a>5.1. 树的概念</h5> 
<p>5.1.1. 树的定义和基本术语</p> 
<ol><li>树是n（n≥0）个结点的有限集合，n = 0时，称为空树。</li><li>空树中应满足：<br> 1. 有且仅有一个特定的称为根的结点。<br> 2. 当n &gt; 1时，其余结点可分为m（m&gt;0）个互不相交的有限集合T1，T2，…，Tm，其中每个集合本 身 又是一棵树，并且称为根结点的子树。</li><li>度：树中一个结点的孩子个数称为该结点的度。所有结点的度的最大值是树的度。</li><li>度大于0的结点称为分支结点，度为0的结点称为叶子结点。</li><li>结点的层次（深度）：从上往下数。</li><li>结点的高度：从下往上数。</li><li>树的高度（深度）：树中结点的层数。</li><li>有序树：逻辑上看，树中结点的各子树从左至右是有次序的，不能互换。</li><li>若树中结点的各子树从左至右是有次序的，不能互换，则该树称为有序树，否则称为无序树。</li><li>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。</li><li>森林：森林是m（m≥0）棵互不相交的树的集合。</li></ol> 
<h5><a id="512__796"></a>5.1.2. 树的常考性质</h5> 
<ol><li>结点数 = 总度数 + 1</li><li>度为 m 的树、m 叉树的区别：</li></ol> 
<table><thead><tr><th>度为m的树</th><th>m叉树的区别</th></tr></thead><tbody><tr><td>任意结点的度≤m（最多m个孩子）</td><td>任意结点的度≤m（最多m个孩子）</td></tr><tr><td>至少有一个结点度=m（有m个孩子）</td><td>允许所有结点的度都＜m</td></tr><tr><td>一定是非空树，至少有m+1个结点</td><td>可以是空树</td></tr></tbody></table> 
<ol start="3"><li>度为 m 的树第 i 层至多有 m<sup>i-1</sup>个结点（i≥1）；m 叉树第 i 层至多有 m <sup>i-1</sup>个结点（i≥1）。<br> <img src="https://images2.imgbox.com/f4/33/KloyXeg3_o.png" alt="在这里插入图片描述"></li><li>高度为 h 的 m 叉树至多有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            ( 
           
           
           
             h 
            
           
             h 
            
           
          
            − 
           
          
            1 
           
          
            ) 
           
          
            ( 
           
          
            m 
           
          
            − 
           
          
            1 
           
          
            ) 
           
          
         
           6 
          
         
        
       
         \frac{(h^h -1)(m-1)}{6} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.4789em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.1339em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.485em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.927em;"><span class="" style="top: -2.931em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><br> 个结点。（等比数列求和）</li><li>高度为 h 的 m 叉树至少有 h 个结点；高度为 h、度为 m 的树至少有（h+m-1）个结点。</li><li>具有 n 个结点的 m 叉树的最小高度为[<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           m 
          
         
        
          ( 
         
        
          n 
         
        
          ( 
         
        
          m 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
       
         log_m(n(m-1)+1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>]<br> 5.2. 二叉树<br> 5.2.1. 二叉树的定义<br> 二叉树是 n（n≥0）个结点的有限集合：</li></ol> 
<p>或者为空二叉树，即 n = 0。<br> 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树又分别是一棵二叉树。<br> 二叉树的特点：</p> 
<p>每个结点至多只有两棵子树。<br> 左右子树不能颠倒（二叉树是有序树）。<br> 二叉树的五种状态：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
       
      
        \qquad\qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>空二叉树<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
       
      
        \qquad\qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>只有左子树<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
       
      
        \qquad\qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>只有右子树<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
       
      
        \qquad\qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>只有根节点<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
       
      
        \qquad\qquad 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mspace" style="margin-right: 2em;"></span></span></span></span></span>左右子树都有</p> 
<p>2．掌握二叉树的建立及二叉树的几种遍历算法，了解树和森林的遍历方法。<br> 3．了解最优线索二叉树、二叉树和哈夫曼树、b+树的应用。<br> 4．其他简单应用。<br> 七、图<br> 1． 熟悉图的有关定义，掌握图的数组存储结构和邻接表存储结构的实现方法。<br> 2．了解图的深度优先遍历算法和广度优先算法。<br> 3．了解最小生成树、拓扑排序、关键路径的有关算法。<br> 4．其他简单应用。<br> 八、查找<br> 1． 掌握静态查找表的几种查找方法。<br> 2．掌握哈希表的构造方法及其冲突处理方法。<br> 九、内部排序和外部排序<br> 1． 掌握内部排序和外部排序的概念。<br> 2． 熟悉插入排序、选择排序及常用的几种排序方法。能分析几种常用的排序算法的时间复杂度与空间复杂度。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab74f1834fe2f54c92df3d88f33a8b60/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hive的函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73493416c596705a8e376fd5f8c4b828/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">wrk压测工具使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>