<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot学习笔记 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot学习笔记" />
<meta property="og:description" content="文章目录 SpringBoot一、SpringBoot简介1.1 SpringBoot的概述 二、SpringBoot快速入门2.1 快速入门案例2.2 SpringBoot工程热部署2.3 使用idea快速创建SpringBoot项目 三、SpringBoot原理分析3.1 起步依赖原理分析3.2 自动配置原理解析3.2.1 原web.xml的中配置3.2.2 @SpringBootApplication注解3.2.3 举例自动配置 四、SpringBoot的配置文件4.1 SpringBoot配置文件类型4.2 application\*.yml配置文件4.3 配置文件与配置类的属性映射方式4.3.1 @ConfigurationProperties注解4.3.2 使用注解@Value映射 五、SpringBoot与整合其他技术5.1 SpringBoot整合Mybatis5.2 SpringBoot整合Junit5.3 SpringBoot整合Spring Data JPA5.3.1 Spring Data JPA 简介5.3.2 Spring Data JPA 的使用 5.4 SpringBoot整合Redis5.5 SpringBoot整合定时任务5.5.1 SpringBoot整合定时任务5.5.2 corn表达式 5.6 SpringBoot整合Thymeleaf SpringBoot 以前学习SpringBoot时所做的笔记，发在这里是为了方便自己翻阅，不喜勿喷。
一、SpringBoot简介 1.1 SpringBoot的概述 什么是Spring Boot
Spring Boot 是所有基于 Spring Framework 5.0 开发的项目。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序，并且尽可能减少你的配置文件。设计目的： 用来简化 Spring 应用的初始搭建以及开发过程。 从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目所使用，它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。spring boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，spring boot 整合了所有的框架，总结一下及几点： 为所有 Spring 开发提供一个更快更广泛的入门体验。零配置，无冗余代码生成和XML 强制配置，遵循“约定大于配置” 。集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。提供一系列大型项目常用的非功能性特征，如嵌入服务器等。 SpringBoot的特点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/361d202bf7d12fac50b366e3c9b07cd8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-03T00:42:50+08:00" />
<meta property="article:modified_time" content="2023-07-03T00:42:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#SpringBoot_1" rel="nofollow">SpringBoot</a></li><li><ul><li><a href="#SpringBoot_3" rel="nofollow">一、SpringBoot简介</a></li><li><ul><li><a href="#11_SpringBoot_5" rel="nofollow">1.1 SpringBoot的概述</a></li></ul> 
   </li><li><a href="#SpringBoot_34" rel="nofollow">二、SpringBoot快速入门</a></li><li><ul><li><a href="#21__36" rel="nofollow">2.1 快速入门案例</a></li><li><a href="#22_SpringBoot_139" rel="nofollow">2.2 SpringBoot工程热部署</a></li><li><a href="#23_ideaSpringBoot_187" rel="nofollow">2.3 使用idea快速创建SpringBoot项目</a></li></ul> 
   </li><li><a href="#SpringBoot_215" rel="nofollow">三、SpringBoot原理分析</a></li><li><ul><li><a href="#31__217" rel="nofollow">3.1 起步依赖原理分析</a></li><li><a href="#32__231" rel="nofollow">3.2 自动配置原理解析</a></li><li><ul><li><a href="#321_webxml_233" rel="nofollow">3.2.1 原web.xml的中配置</a></li><li><a href="#322_SpringBootApplication_285" rel="nofollow">3.2.2 @SpringBootApplication注解</a></li><li><a href="#323__437" rel="nofollow">3.2.3 举例自动配置</a></li></ul> 
   </li></ul> 
   </li><li><a href="#SpringBoot_465" rel="nofollow">四、SpringBoot的配置文件</a></li><li><ul><li><a href="#41_SpringBoot_467" rel="nofollow">4.1 SpringBoot配置文件类型</a></li><li><a href="#42_applicationyml_500" rel="nofollow">4.2 application\*.yml配置文件</a></li><li><a href="#43__599" rel="nofollow">4.3 配置文件与配置类的属性映射方式</a></li><li><ul><li><a href="#431_ConfigurationProperties_601" rel="nofollow">4.3.1 @ConfigurationProperties注解</a></li><li><a href="#432_Value_655" rel="nofollow">4.3.2 使用注解@Value映射</a></li></ul> 
   </li></ul> 
   </li><li><a href="#SpringBoot_706" rel="nofollow">五、SpringBoot与整合其他技术</a></li><li><ul><li><a href="#51_SpringBootMybatis_708" rel="nofollow">5.1 SpringBoot整合Mybatis</a></li><li><a href="#52_SpringBootJunit_758" rel="nofollow">5.2 SpringBoot整合Junit</a></li><li><a href="#53_SpringBootSpring_Data_JPA_796" rel="nofollow">5.3 SpringBoot整合Spring Data JPA</a></li><li><ul><li><a href="#531_Spring_Data_JPA__798" rel="nofollow">5.3.1 Spring Data JPA 简介</a></li><li><a href="#532_Spring_Data_JPA__823" rel="nofollow">5.3.2 Spring Data JPA 的使用</a></li></ul> 
    </li><li><a href="#54_SpringBootRedis_1033" rel="nofollow">5.4 SpringBoot整合Redis</a></li><li><a href="#55_SpringBoot_1109" rel="nofollow">5.5 SpringBoot整合定时任务</a></li><li><ul><li><a href="#551_SpringBoot_1111" rel="nofollow">5.5.1 SpringBoot整合定时任务</a></li><li><a href="#552_corn_1193" rel="nofollow">5.5.2 corn表达式</a></li></ul> 
    </li><li><a href="#56_SpringBootThymeleaf_1242" rel="nofollow">5.6 SpringBoot整合Thymeleaf</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="SpringBoot_1"></a>SpringBoot</h2> 
<blockquote> 
 <p>以前学习SpringBoot时所做的笔记，发在这里是为了方便自己翻阅，不喜勿喷。</p> 
</blockquote> 
<h3><a id="SpringBoot_3"></a>一、SpringBoot简介</h3> 
<h4><a id="11_SpringBoot_5"></a>1.1 SpringBoot的概述</h4> 
<ul><li> <p><strong>什么是Spring Boot</strong></p> 
  <ul><li>Spring Boot 是所有基于 Spring Framework 5.0 开发的项目。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序，并且尽可能减少你的配置文件。</li><li>设计目的： 
    <ul><li><strong>用来简化 Spring 应用的初始搭建以及开发过程。</strong></li></ul> </li><li>从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目所使用，它使用 “<strong>习惯优于配置</strong>” （项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。</li><li>spring boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，spring boot 整合了所有的框架，总结一下及几点： 
    <ul><li>为所有 Spring 开发提供一个更快更广泛的入门体验。</li><li>零配置，无冗余代码生成和XML 强制配置，遵循“约定大于配置” 。</li><li>集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。</li><li>提供一系列大型项目常用的非功能性特征，如<strong>嵌入服务器</strong>等。</li></ul> </li></ul> </li><li> <p>SpringBoot的特点</p> 
  <ul><li>为基于Spring的开发提供更快的入门体验</li><li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、外部配置等</li><li><strong>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</strong></li></ul> </li><li> <p><strong>SpringBoot的核心功能</strong></p> 
  <ul><li> <p><strong>起步依赖</strong></p> 
    <ul><li>起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</li><li>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</li></ul> </li><li> <p><strong>自动配置</strong></p> 
    <ul><li>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</li></ul> </li></ul> </li></ul> 
<h3><a id="SpringBoot_34"></a>二、SpringBoot快速入门</h3> 
<h4><a id="21__36"></a>2.1 快速入门案例</h4> 
<ol><li> <p><strong>创建Maven工程</strong></p> 
  <ul><li> <p>使用idea工具创建一个maven工程</p> <p><img src="https://images2.imgbox.com/cd/af/Qf5YwrSw_o.png" alt="在这里插入图片描述"></p> </li></ul> </li><li> <p>在该工程下的<code>pom.xml</code>文件中添加SpringBoot的起步依赖</p> <pre><code class="prism language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.ljf&lt;/groupId&gt;
    &lt;artifactId&gt;springboot_demo01&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;!-- SpringBoot父工程，里面有很多现成的依赖，所以不需要再自己添加这些依赖了 --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;!--web起步包，里面有很多
         	注意：虽然是web工程，但不需要打war包，直接打jar就行
        --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre> </li><li> <p><strong>编写SpringBoot引导类</strong></p> 
  <ul><li> <p>SpringBoot引导类需要在所有组件类的上一层。</p> </li><li> <p>SpringBoot引导类需要使用<code>@SpringBootApplication</code>进行声明</p> <pre><code class="prism language-JAVA">package com.ljf;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// 声明该类是一个SpringBoot引导类
@SpringBootApplication
public class Application {
    // main是java程序的入口
    public static void main(String[] args) {
        // run()方法表示运行SpringBoot的引导类,run参数就是SpringBoot引导类的字节码对象
        SpringApplication.run(Application.class, args);
    }
}
</code></pre> </li></ul> </li><li> <p><strong>编写Controller</strong></p> 
  <ul><li> <p>必须在引导类<code>Application</code>同级包或者子级包中创建Controller</p> <pre><code class="prism language-JAVA">package com.ljf.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/hello")
public class HelloController {
    @RequestMapping("/world")
    public String world(){
        return "springboot 访问成功!";
    }
}
</code></pre> </li></ul> </li><li> <p><strong>测试</strong></p> 
  <ul><li> <p>执行SpringBoot起步类<code>Application</code>的主方法，控制台打印日志如下：</p> <p><img src="https://images2.imgbox.com/4c/9f/KJ93UAAb_o.png" alt="在这里插入图片描述"></p> </li><li> <p>通过日志发现，Tomcat started on port(s): 8080 (http) with context path ’’</p> 
    <ul><li>tomcat已经起步，端口监听8080，web应用的虚拟工程名称为空（默认“/”）</li></ul> </li><li> <p>打开浏览器访问url地址为：http://localhost:8080/hello/world</p> <p><img src="https://images2.imgbox.com/f7/b1/O6lCeiDm_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ol> 
<h4><a id="22_SpringBoot_139"></a>2.2 SpringBoot工程热部署</h4> 
<ul><li> <p>我们在以往的开发中，每次修改类、页面等资源后，都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间。</p> </li><li> <p>在使用SpringBoot后，只需在pom.xml文件中添加一个插件就可以实现不重启服务就能生效的功能，对于这样的功能，我们称之为热部署。</p> 
  <ul><li> <p>热部署依赖</p> <pre><code class="prism language-XML">&lt;!-- 热部署依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> </li><li> <p>热部署插件</p> <pre><code class="prism language-XML">&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- 热部署插件 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre> </li></ul> </li><li> <p>开启 Intellij IEDA 自动编译，需要对IDEA进行自动编译的设置，如下：</p> <p><img src="https://images2.imgbox.com/f2/d0/GHK45P8m_o.png" alt="在这里插入图片描述"></p> 
  <ul><li> <p>正常情况下就可以进行热部署， 如果还是不行，在加入如下操作，如果已经可以热部署，就不需要看后面的操作</p> 
    <ul><li> <p>在Idea中， <code>Shift+Ctrl+Alt+/</code>， 选择<code>Registry</code></p> <p><img src="https://images2.imgbox.com/42/6e/62Hho0C8_o.png" alt="在这里插入图片描述"></p> </li><li> <p>找到以下选项，然后打勾：</p> <p><img src="https://images2.imgbox.com/59/46/nepI3PuL_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> </li></ul> 
<h4><a id="23_ideaSpringBoot_187"></a>2.3 使用idea快速创建SpringBoot项目</h4> 
<ul><li>可以在Idea中快速创建一个SpringBoot项目</li></ul> 
<ol><li> <p>在选择创建项目时，选择<code>Spring Initializr</code>工程：</p> <p><img src="https://images2.imgbox.com/9d/e8/EPV6SRt7_o.png" alt="在这里插入图片描述"></p> </li><li> <p>进行一些基础配置</p> <p><img src="https://images2.imgbox.com/ab/4d/Q2rvSy7v_o.png" alt="在这里插入图片描述"></p> </li><li> <p>选择<code>Spring Web</code></p> <p><img src="https://images2.imgbox.com/39/9d/B1bQjrf7_o.png" alt="在这里插入图片描述"></p> </li><li> <p>选择工程路径</p> <p><img src="https://images2.imgbox.com/b4/fd/cH1LCYLd_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<ul><li>使用这种方式创建出的工程会自动生成 <strong>SpringBoot启动类</strong> 和 配置<strong>pom.xml文件</strong>，虽然很方便，但是由于这样创建的工程会有很多我们不需要的东西，且需要在有网的时候才有用，所以<strong>一般我们不这样创建SpringBoot项目</strong>，了解即可。</li></ul> 
<h3><a id="SpringBoot_215"></a>三、SpringBoot原理分析</h3> 
<h4><a id="31__217"></a>3.1 起步依赖原理分析</h4> 
<ul><li> <p>通过查看父类<code>spring-boot-starter-parent</code>的<code>pom.xml</code>文件，可以发现其右继承了另一个父工程<code>spring-boot-starter-dependencies</code>，而查看这个工程的<code>pom.xml</code>文件，发现这里有很多依赖。</p> 
  <ul><li>总结： 
    <ul><li>从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好</li><li>所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了（不会出现版本冲突的问题）。</li><li>所以起步依赖的作用就是进行<strong>依赖的传递</strong>。</li></ul> </li></ul> </li><li> <p>通过查看web起步包<code>spring-boot-starter-web</code>工程的<code>pom.xml</code>文件：</p> 
  <ul><li>我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”</li><li>这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用</li><li>同时加载tomcat，只要启动main方法，就相当于起到tomcat进行开发</li><li>同时加载json，支持springmvc的数据请求和响应。</li></ul> </li></ul> 
<h4><a id="32__231"></a>3.2 自动配置原理解析</h4> 
<h5><a id="321_webxml_233"></a>3.2.1 原web.xml的中配置</h5> 
<ul><li> <p><strong>问题提出</strong>：</p> 
  <ul><li>在以往的web工程开发中，我们都需要配置一个<code>web.xml</code>文件，在其中配置过滤器、<code>dispatcherServlet</code>等。</li><li>但在SpringBoot中却不需要配置<code>web.xml</code>文件，那么<code>dispatcherServlet</code>等组件是如何配置的呢？</li></ul> </li><li> <p><strong>问题解析</strong>：</p> 
  <ul><li> <p>其实web.xml文件中的一些配置其实都已经被SpringBoot自动配置好了</p> </li><li> <p>可以在SpringBoot的启动类中，通过 <code>ApplicationContext.getBeanDefinitionNames()</code>方法查看web工程中所有的Bean对象</p> <pre><code class="prism language-JAVA">package com.ljf;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

// 声明该类是一个SpringBoot引导类
@SpringBootApplication
public class Application {
    // main是java程序的入口
    public static void main(String[] args) {
        // run()方法表示运行SpringBoot的引导类,run参数就是SpringBoot引导类的字节码对象，run()方法的返回值是一个ApplicationContext对象
        ApplicationContext act = SpringApplication.run(Application.class, args);
        // ApplicationContext.getBeanDefinitionNames()可以返回整个web工程的所有bean对象
        for (String name : act.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }
}
</code></pre> 
    <ul><li> <p>通过搜索其打印内容，可以发现里面有很多之前需要在web.xml中配置的bean对象：</p> 
      <ul><li> <p><strong>dispatcherServlet</strong>：</p> <p><img src="https://images2.imgbox.com/71/32/05ntTgKR_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>characterEncodingFilter</strong>：</p> <p><img src="https://images2.imgbox.com/8c/e8/fdWMVgmY_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>hiddenHttpMethodFilter</strong>：</p> <p><img src="https://images2.imgbox.com/7e/e7/j87KFQ6D_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> </li></ul> </li></ul> 
<h5><a id="322_SpringBootApplication_285"></a>3.2.2 @SpringBootApplication注解</h5> 
<ul><li> <p>SpringBoot的启动类需要使用<code>@SpringBootApplication</code>注解标识</p> </li><li> <p>通过查看<code>@SpringBootApplication</code>注解，我们可以发现这是一个复合注解：</p> <pre><code class="prism language-JAVA">package org.springframework.boot.autoconfigure;

// import...

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan( 
    excludeFilters = {
        @Filter(type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), 
        @Filter(type = FilterType.CUSTOM,classes = {AutoConfigurationExcludeFilter.class}) 
    }
)
public @interface SpringBootApplication {
    // ...
}
</code></pre> </li><li> <p>在<code>@SpringBootApplication</code>注解中，最重要的复合注解是后三个：</p> <pre><code class="prism language-JAVa">@SpringBootConfiguration	// 表示当前类具有配置类的作用，用于代替配置文件
@EnableAutoConfiguration	// 表示开启自动配置
@ComponentScan( 			// 表示自动扫描组件，等效于XML文件中的包扫描标签
    excludeFilters = {
        @Filter(type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), 
        @Filter(type = FilterType.CUSTOM,classes = {AutoConfigurationExcludeFilter.class}) 
    }
)
</code></pre> </li><li> <p><code>@ComponentScan</code>注解：</p> 
  <ul><li> <p>作用：</p> 
    <ul><li>表示自动扫描组件，等效于XML文件中的包扫描标签</li></ul> </li><li> <p>注意：</p> 
    <ul><li> <p>该注解是<strong>把当前启动类所在的包作为扫描包的起点</strong>，例如启动类所在的包在<code>com.ljf</code>中，则该注解等效于：</p> <pre><code class="prism language-XML">&lt;context:component-scan base-package="com.ljf"&gt;&lt;/context:component-scan&gt;
</code></pre> </li></ul> </li></ul> </li><li> <p><code>@SpringBootConfiguration</code>注解：</p> 
  <ul><li>作用： 
    <ul><li>表示当前类具有配置类的作用，用于代替配置文件</li></ul> </li></ul> </li><li> <p><code>@EnableAutoConfiguration</code>注解：</p> 
  <ul><li> <p>作用：</p> 
    <ul><li>表示开启自动配置</li></ul> </li><li> <p>点击查看<code>@EnableAutoConfiguration</code>注解：</p> <pre><code class="prism language-JAVA">package org.springframework.boot.autoconfigure;

// import...

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class&lt;?&gt;[] exclude() default {};

    String[] excludeName() default {};
}
</code></pre> </li><li> <p>发现<code>@EnableAutoConfiguration</code>注解引入了一个<code>AutoConfigurationImportSelector</code>类，再查看该类（主要看一下三个方法）：</p> <pre><code class="prism language-JAVA">// selectImports()方法：选择性引入
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    //...
    AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);
    //..
}

// getAutoConfigurationEntry()方法：获取自动配置项
protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {
    // ...
    List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
    // ...
}

// getCandidateConfigurations()方法：有条件的获取配置项
protected List&lt;String&gt; getCandidateConfigurations()方法：有条件的获取配置项(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    // 在META-INF/spring.factories中找不到自动配置类。需要看看文件是否正确
    Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
    return configurations;
}
</code></pre> 
    <ul><li>其中，<code>SpringFactoriesLoader.loadFactoryNames()</code> 方法的作用就是从<code>META-INF/spring.factories</code>文件中读取指定类对应的类名称列表。</li></ul> </li><li> <p>查看<code>spring-boot-autoconfigure-2.1.6.RELEASE.jar</code>包中的<code>META-INF/spring.factories</code>文件：</p> <p><img src="https://images2.imgbox.com/d4/cf/nm9rIYdn_o.png" alt="在这里插入图片描述"></p> 
    <ul><li> <p>可以在<code>Auto Configure</code>下面全是以下<code>Configure</code>类的全限定名</p> </li><li> <p>通过搜索发现，<code>META-INF/spring.factories</code>文件有标明<code>dispatcherServlet</code>的配置类<code>DispatcherServletAutoConfiguration</code>：</p> <pre><code>org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
</code></pre> </li><li> <p>查看<code>dispatcherServlet</code>的配置类<code>DispatcherServletAutoConfiguration</code>：</p> <pre><code class="prism language-JAVA">package org.springframework.boot.autoconfigure.web.servlet;

// import

@AutoConfigureOrder(-2147483648)
@Configuration
@ConditionalOnWebApplication(
    type = Type.SERVLET
)
@ConditionalOnClass({DispatcherServlet.class})
@AutoConfigureAfter({ServletWebServerFactoryAutoConfiguration.class})
public class DispatcherServletAutoConfiguration {
    // dispatcherServlet bean对象的默认名称
    public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = "dispatcherServlet";
    public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = "dispatcherServletRegistration";

    // ...
}
</code></pre> </li></ul> </li></ul> </li></ul> 
<h5><a id="323__437"></a>3.2.3 举例自动配置</h5> 
<ul><li> <p><strong>如何在SpringBoot中自动配置自己的类</strong>？</p> </li><li> <p>例：</p> 
  <ul><li> <p>新建包 <code>com.atguigu.pojo</code> , 创建类 <code>User</code></p> <pre><code class="prism language-JAVA">package com.ljf.pojo;

public class User {
}
</code></pre> </li><li> <p>在 <code>resources</code>文件夹下面 新建 <code>/META-INF/spring.factories</code> 文件</p> <pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ljf.pojo.User
</code></pre> </li><li> <p>重启项目，然后查看该项目打印的bean对象：</p> <p><img src="https://images2.imgbox.com/b3/6c/gNdO2chK_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<h3><a id="SpringBoot_465"></a>四、SpringBoot的配置文件</h3> 
<h4><a id="41_SpringBoot_467"></a>4.1 SpringBoot配置文件类型</h4> 
<ul><li> <p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用<strong>application*.properties</strong>或者**application*.yml（application*.yaml）**进行配置。</p> </li><li> <p>SpringBoot默认会从<strong>Resources</strong>目录下加载application*.properties或application*.yml（application*.yaml）文件</p> 
  <ul><li> <p>这些设置可以在<code>pom.xml</code>文件中的父工程<code>spring-boot-dependencies</code>中查看到：</p> <p><img src="https://images2.imgbox.com/ad/ff/cTkwHGu3_o.png" alt="在这里插入图片描述"></p> </li></ul> </li><li> <p><strong>properties</strong>配置文件：</p> 
  <ul><li> <p>properties文件是键值对类型的文件，键与值之间使用=号连接</p> </li><li> <p>例，在application.properties中对SpringBoot的tomcat的端口号进行修改：</p> <pre><code class="prism language-properties">server.port=80
</code></pre> </li></ul> </li><li> <p>具体可以修改SpringBoot的哪些配置文件，可以在 <strong>spring-boot-autoconfigure-2.1.6.RELEASE.jar</strong> 包中的 <strong>META-INF</strong> 目录下的 <code>spring-configuration-metadata.json</code> 文件中查找，</p> <p><img src="https://images2.imgbox.com/06/61/3e4PO3DM_o.png" alt="在这里插入图片描述"></p> 
  <ul><li> <p>以服务器端口号<strong>server.port</strong>为例：</p> <p><img src="https://images2.imgbox.com/6b/fd/tvplxE7W_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<h4><a id="42_applicationyml_500"></a>4.2 application*.yml配置文件</h4> 
<ul><li> <p>yml配置文件简介</p> 
  <ul><li> <p>YML文件格式是YAML（YAML Aint Markup Language）编写的文件格式</p> </li><li> <p>YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。</p> </li><li> <p>YML文件是以数据为核心的，比传统的xml方式更加简洁。</p> </li><li> <p>YML文件的扩展名可以使用.yml或者.yaml。</p> </li></ul> </li><li> <p>yml配置文件的<strong>语法</strong></p> 
  <ul><li> <p><strong>配置普通数据</strong></p> 
    <ul><li> <p>语法：</p> <pre><code class="prism language-yaml"><span class="token key atrule">key</span><span class="token punctuation">:</span> value
</code></pre> </li><li> <p>例：</p> <pre><code class="prism language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> jeff
</code></pre> </li><li> <p>注意：</p> 
      <ul><li>value之前有一个空格</li></ul> </li></ul> </li><li> <p><strong>配置对象数据</strong></p> 
    <ul><li> <p>语法：</p> <pre><code class="prism language-yaml"><span class="token key atrule">key</span><span class="token punctuation">:</span> 
     <span class="token key atrule">key1</span><span class="token punctuation">:</span> value1
     <span class="token key atrule">key2</span><span class="token punctuation">:</span> value2
<span class="token comment"># 或者：</span>
<span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token key atrule">key1</span><span class="token punctuation">:</span> value1<span class="token punctuation">,</span><span class="token key atrule">key2</span><span class="token punctuation">:</span> value2<span class="token punctuation">}</span>
</code></pre> </li><li> <p>例：</p> <pre><code class="prism language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">18082</span>
<span class="token key atrule">user</span><span class="token punctuation">:</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> jeff
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123</span>
</code></pre> </li><li> <p>注意：</p> 
      <ul><li>yaml文件是按照key前面的空格区分级别的，相同缩进代表同一个级别，一般按一下tab键。</li></ul> </li></ul> </li><li> <p><strong>配置Map数据</strong></p> 
    <ul><li> <p>语法：</p> <pre><code class="prism language-yaml"><span class="token key atrule">map</span><span class="token punctuation">:</span> 
    <span class="token key atrule">key</span><span class="token punctuation">:</span> value1
    <span class="token key atrule">key</span><span class="token punctuation">:</span> value2
</code></pre> </li></ul> </li><li> <p><strong>配置数组（List、Set）数据</strong></p> 
    <ul><li> <p>语法：</p> <pre><code class="prism language-yaml"><span class="token key atrule">key</span><span class="token punctuation">:</span> 
    <span class="token punctuation">-</span> value1
    <span class="token punctuation">-</span> value2
<span class="token comment"># 或者：</span>
<span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">]</span>
</code></pre> </li><li> <p>例：</p> <pre><code class="prism language-yaml"><span class="token comment"># 配置数据集合</span>
<span class="token key atrule">city</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> beijing
    <span class="token punctuation">-</span> tianjin
    <span class="token punctuation">-</span> shanghai
    <span class="token punctuation">-</span> chongqing
<span class="token comment"># 或者行内注入</span>
<span class="token key atrule">city</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>beijing<span class="token punctuation">,</span>tianjin<span class="token punctuation">,</span>shanghai<span class="token punctuation">,</span>chongqing<span class="token punctuation">]</span>
</code></pre> </li><li> <p>注意：</p> 
      <ul><li>-号与value之间存在一个空格</li></ul> </li></ul> </li></ul> </li></ul> 
<h4><a id="43__599"></a>4.3 配置文件与配置类的属性映射方式</h4> 
<h5><a id="431_ConfigurationProperties_601"></a>4.3.1 @ConfigurationProperties注解</h5> 
<ul><li> <p><code>@ConfigurationProperties</code>注解一般标注在组件类上，可以给组件属性赋值，所以其需要与<code>@Component</code>注解（或其衍生注解）使用。</p> </li><li> <p>例：</p> 
  <ul><li> <p>对于组件类User：</p> <pre><code class="prism language-JAVA">package com.ljf.pojo;

// import...

@Component
@ConfigurationProperties("user")
public class User {
    private String username;
    private String password;
    private List&lt;String&gt; nicknames;
    private List&lt;Mobile&gt; mobiles;
    
    // get、set、toString方法
}
</code></pre> 
    <ul><li>注意： 
      <ul><li><code>@ConfigurationProperties</code>注解需要传入yml配置文件中的key，这里是user</li></ul> </li></ul> </li><li> <p>在<strong>application.yml</strong>文件中加入以下配置：</p> <pre><code class="prism language-yaml"><span class="token key atrule">user</span><span class="token punctuation">:</span>
  <span class="token key atrule">username</span><span class="token punctuation">:</span> jeff
  <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123</span>
  <span class="token key atrule">nicknames</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> jj
    <span class="token punctuation">-</span> ff
  <span class="token key atrule">mobiles</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">num</span><span class="token punctuation">:</span> <span class="token number">100</span>
      <span class="token key atrule">brand</span><span class="token punctuation">:</span> 华为
    <span class="token punctuation">-</span> <span class="token key atrule">num</span><span class="token punctuation">:</span> <span class="token number">101</span>
      <span class="token key atrule">brand</span><span class="token punctuation">:</span> 小米
</code></pre> </li><li> <p>通过在SpringBoot的启动类中打印工程的所有bean对象：</p> <p><img src="https://images2.imgbox.com/0f/87/PBiXcQb3_o.png" alt="在这里插入图片描述"></p> </li><li> <p>再通过ApplicationContext的getBean()方法可以获取到user对象，发现属性的值与我们在配置文件中配置的值一样：</p> <p><img src="https://images2.imgbox.com/c9/7e/lUkh20L2_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<h5><a id="432_Value_655"></a>4.3.2 使用注解@Value映射</h5> 
<ul><li> <p>假如我们的组件类不需要使用一整个bean对象为其属性赋值，而只需要为其中的几个属性赋值，那么就可以通过<code>@Value</code>注解将配置文件中的值映射到一个Spring管理的Bean中的属性上</p> </li><li> <p>例如：</p> 
  <ul><li> <p><code>application.yml</code>配置如下：</p> <pre><code class="prism language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> jeff
  <span class="token key atrule">addr</span><span class="token punctuation">:</span> 南昌
</code></pre> </li><li> <p>组件类<code>HelloController</code>：</p> <pre><code class="prism language-JAVA">package com.ljf.controller;

// import...

@RestController
@RequestMapping("/hello")
public class HelloController {
    @Value("${person.name}")
    private String name;

    @Value("${person.addr}")
    private String addr;

    @RequestMapping("/quick")
    public String quick() {
        return "name:"+name+"，addr="+addr;
    }
}
</code></pre> </li><li> <p>访问http://localhost/hello/quick结果：</p> <p><img src="https://images2.imgbox.com/06/5d/3y2OzopY_o.png" alt="在这里插入图片描述"></p> </li></ul> </li><li> <p>@value注解语法：</p> <pre><code class="prism language-JAVA">@value("${key1.key2.....key3}")
// 成员属性
</code></pre> </li></ul> 
<h3><a id="SpringBoot_706"></a>五、SpringBoot与整合其他技术</h3> 
<h4><a id="51_SpringBootMybatis_708"></a>5.1 SpringBoot整合Mybatis</h4> 
<ul><li> <p><strong><code>pom.xml</code>中添加依赖</strong>（只需在原有的依赖上加入以下依赖即可）：</p> <pre><code class="prism language-XML">&lt;!--mybatis起步依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- MySQL连接驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> </li><li> <p><strong>application.yml</strong>配置文件：</p> <pre><code class="prism language-yml"><span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token comment"># 重新指定服务器端口号</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>

<span class="token key atrule">mybatis</span><span class="token punctuation">:</span>
  <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.ljf.pojo  <span class="token comment"># 指定mybatis别名包</span>
  <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>com/ljf/dao/<span class="token important">*.xml</span> <span class="token comment"># 指定xml映射文件路径</span>
  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>
    <span class="token key atrule">map-underscore-to-camel-case</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 配置下划线命名到驼峰命名的自动转换</span>

<span class="token key atrule">logging</span><span class="token punctuation">:</span>
  <span class="token key atrule">level</span><span class="token punctuation">:</span>
    <span class="token key atrule">com.ljf.dao</span><span class="token punctuation">:</span> debug <span class="token comment"># 配置日志为debug级</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span> <span class="token comment"># 配置数据库数据源</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> root
    <span class="token key atrule">password</span><span class="token punctuation">:</span> ljf123
    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//192.168.195.100<span class="token punctuation">:</span>3306/meinian
    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver
</code></pre> </li><li> <p>注意：</p> 
  <ul><li><strong>Bean类、Controller、Service、Dao.xml的写法与Spring的一致</strong></li><li><strong>只有 Dao 接口不同，需要在接口上加上 <code>@Mapper</code> 注解</strong>，标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文</li></ul> </li></ul> 
<h4><a id="52_SpringBootJunit_758"></a>5.2 SpringBoot整合Junit</h4> 
<ul><li> <p><strong><code>pom.xml</code>中添加依赖</strong>（只需在原有的依赖上加入以下依赖即可）：</p> <pre><code class="prism language-XML">&lt;!--SpingBoot集成junit测试的起步依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre> </li><li> <p>使用**@RunWit和@SpringBootTest注解**标识测试类就可以实现IOC自动注入：</p> <pre><code class="prism language-JAVA">package com.ljf.test;

// import...

@RunWith(SpringRunner.class)
@SpringBootTest
public class TestApplication {
    @Autowired
    private OrderService orderService;

    @Test
    public void testOrder() {
        List&lt;Order&gt; orders = orderService.findAll();
        for (Order order : orders) {
            System.out.println(order);
        }
    }
}
</code></pre> </li></ul> 
<h4><a id="53_SpringBootSpring_Data_JPA_796"></a>5.3 SpringBoot整合Spring Data JPA</h4> 
<h5><a id="531_Spring_Data_JPA__798"></a>5.3.1 Spring Data JPA 简介</h5> 
<ul><li>什么是 <strong>JPA</strong>？ 
  <ul><li><strong>JPA</strong> 英文名叫<code>Java Persistence API</code>，就是Java持久化API，是SUN公司推出的一套基于<code>ORM</code>的规范。</li><li>ORM：英文名为<code>Object-Relational Mapping</code>：对象关系映射 
    <ul><li>简单来说为了不用JDBC那一套原始方法来操作数据库，ORM框架横空出世（等等）。</li></ul> </li><li>主流的<strong>ORM</strong>框架（<strong>mybatis、hibernate</strong>等）都实现了 <strong>JPA</strong>规范。</li></ul> </li><li>**Spring Data JPA **： 
  <ul><li>是 <strong>Spring Data</strong> 家族的一部分，可以轻松实现基于JPA的存储库。</li><li>此模块处理对基于JPA的数据访问层的增强支持， 它使构建使用数据访问技术的Spring驱动应用程序变得更加容易。</li></ul> </li><li><strong>Hibernate</strong>： 
  <ul><li><strong>JPA</strong>默认使用<strong>hibernat</strong>作为<strong>ORM</strong>实现，所以，一般使用<strong>Spring Data JPA</strong>即会使用<strong>Hibernate</strong>。</li><li><strong>Hibernate</strong>是一个开放源代码的<strong>对象关系映射框架</strong>，它对JDBC进行了非常轻量级的对象封装</li><li>它将POJO与数据库表建立映射关系，是一个<strong>全自动的orm框架</strong></li><li>hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</li></ul> </li><li><strong>Mybatis</strong>： 
  <ul><li><strong>MyBatis</strong>是一款优秀的持久层框架，它<strong>支持定制化 SQL</strong>、存储过程以及高级映射</li></ul> </li><li><strong>Spring Data JPA</strong> 和 <strong>Mybatis</strong> 的区别： 
  <ul><li>由于 <strong>Spring Data JPA</strong> 默认使用 <strong>Hibernate</strong> ，所以Spring Data JPA与MyBatis对比，起始也就是Hibernate与MyBatis对比。</li><li>从SQL语句的角度看： 
    <ul><li><strong>hibernate</strong>是一个自动化更强、更高级的框架</li><li><strong>MyBatis</strong> 在Sql语句编写方面则更灵活自由。</li></ul> </li><li>从抽象层次去看： 
    <ul><li><strong>对于数据的操作，hibernate是面向对象的，而MyBatis是面向关系的</strong></li></ul> </li></ul> </li></ul> 
<h5><a id="532_Spring_Data_JPA__823"></a>5.3.2 Spring Data JPA 的使用</h5> 
<ul><li> <p>在pom.xml导入依赖：（在原有的基础上加上这两个即可）</p> <pre><code class="prism language-XML">&lt;!-- springBoot JPA的起步依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- MySQL连接驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> </li><li> <p>在<strong>application.yml</strong>中配置数据库和jpa的相关属性</p> <pre><code class="prism language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token comment"># 重新指定服务器端口号</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>

<span class="token key atrule">logging</span><span class="token punctuation">:</span>
  <span class="token key atrule">level</span><span class="token punctuation">:</span>
    <span class="token key atrule">com.ljf.dao</span><span class="token punctuation">:</span> debug <span class="token comment"># 配置日志为debug级</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span> <span class="token comment"># 配置数据库数据源</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> root
    <span class="token key atrule">password</span><span class="token punctuation">:</span> ljf123
    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//192.168.195.100<span class="token punctuation">:</span>3306/meinian
    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver
  <span class="token key atrule">jpa</span><span class="token punctuation">:</span> <span class="token comment"># 配置 Spring Data JPA</span>
    <span class="token key atrule">database</span><span class="token punctuation">:</span> mysql
    <span class="token key atrule">show-sql</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">generate-ddl</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">hibernate</span><span class="token punctuation">:</span>
      <span class="token key atrule">ddl-auto</span><span class="token punctuation">:</span> update
      <span class="token key atrule">naming</span><span class="token punctuation">:</span>
        <span class="token comment"># 表示使用 Hibernate 命名规则（即使用 @Table 和 @Column 注解定义的规则）</span>
        <span class="token key atrule">physical-strategy</span><span class="token punctuation">:</span> org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
</code></pre> </li><li> <p>实体类Order</p> 
  <ul><li> <p>注意这里与以往的实体类不一样</p> <pre><code class="prism language-JAVA">package com.ljf.pojo;

import javax.persistence.*;
import java.util.Date;

@Entity  // 表示这是一个实体类
@Table(name = "t_order")  // 为该实体类指定对应的数据库表的表名
public class Order {
    @Id  // 用于指定实体类的主键
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // 设置主键为自增长
    @Column(name = "id")  // 改属性对应数据库表中字段名
    private Integer id;
    @Column(name = "member_id")
    private Integer memberId;
    @Column(name = "orderDate")
    private Date orderDate;
    @Column(name = "orderType")
    private String orderType;
    @Column(name = "orderStatus")
    private String orderStatus;
    @Column(name = "setmeal_id")
    private Integer setmealId;

    // get、set、toString方法
}
</code></pre> </li></ul> </li><li> <p>Dao接口</p> 
  <ul><li> <p>注意：需要继承 <strong>JpaRepository&lt;T, TD&gt;</strong> 接口，其中：</p> 
    <ul><li>泛型T为对应<strong>实体类的类名</strong></li><li>泛型TD为该<strong>实体类主键的类型</strong></li></ul> <pre><code class="prism language-JAVA">package com.ljf.dao;

import com.ljf.pojo.Order;
import org.springframework.data.jpa.repository.JpaRepository;

// 需要继承 JpaRepository&lt;T, TD&gt; 接口，其中泛型T为对应实体类的类名，泛型TD为该实体类主键的类型
public interface OrderDao extends JpaRepository&lt;Order, Integer&gt; {

}
</code></pre> </li><li> <p>这个接口中虽然没有方法，但是其父类接口（以及祖父接口）中定义了很多<strong>基本的方法</strong></p> </li></ul> </li><li> <p>Service类：（与以往的没区别）</p> 
  <ul><li> <p><strong>OrderService</strong>接口：</p> <pre><code class="prism language-JAVA">package com.ljf.service;

import com.ljf.pojo.Order;

import java.util.List;

public interface OrderService {
    // 查询所有
    List&lt;Order&gt; findListOrder();
    // 根据id进行查询
    Order findOrderById(Integer id);
    // 保存Order
    void saveOrder(Order order);
    // 跟新
    void updateOrder(Order order);
    // 删除
    void deleteOrderById(Integer id);
}
</code></pre> </li><li> <p>OrderServiceImpl</p> <pre><code class="prism language-JAVA">package com.ljf.service.imp;

// import

@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    private OrderDao orderDao;

    @Override
    public List&lt;Order&gt; findListOrder() {
        return orderDao.findAll();
    }

    @Override
    public Order findOrderById(Integer id) {
        return orderDao.findById(id).get();
    }

    @Override
    public void saveOrder(Order order) {
        orderDao.save(order);
    }

    @Override
    public void updateOrder(Order order) {
        orderDao.save(order);
    }

    @Override
    public void deleteOrderById(Integer id) {
        orderDao.deleteById(id);
    }
}
</code></pre> </li></ul> </li><li> <p>SpringBoot启动类别忘了</p> </li><li> <p>测试类：</p> <pre><code class="prism language-JAVA">package com.ljf.test;

// import...

@RunWith(SpringRunner.class)
@SpringBootTest
public class TestService {
    @Autowired
    private OrderService orderService;

    @Test
    public void testFindListOrder() {
        List&lt;Order&gt; orders = orderService.findListOrder();
        for (Order order : orders) {
            System.out.println(order);
        }
    }
    // 其他方法略...
}
</code></pre> </li><li> <p>注意：</p> 
  <ul><li> <p>问题：</p> 
    <ul><li>当数据库表中的字段名不是按<strong>下划线</strong>格式命名时，会出无法找到字段的问题</li></ul> </li><li> <p>原因：</p> 
    <ul><li>原因是 <strong>SpringBoot Data JPA 默认会把所有的名称转为小写</strong>，而不是使用<strong>Hibernate</strong>的 <strong>@Table</strong> 和 <strong>@Column</strong> 注解定义的规则，并且在大写字母前加上横线，比如 IsActive 翻译成 is_active。</li></ul> </li><li> <p>解决：</p> 
    <ul><li> <p>我们应该使用 <strong>Hibernate</strong> 的命名规则，按照规则会使用 <strong>@Table</strong> 和 <strong>@Column</strong> 中的名字。</p> </li><li> <p>而使用 <strong>Hibernate</strong> 的命名规则需要在 springBoot 配置文件中加入如下规则：</p> <pre><code>spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
</code></pre> </li></ul> </li></ul> </li></ul> 
<h4><a id="54_SpringBootRedis_1033"></a>5.4 SpringBoot整合Redis</h4> 
<ul><li> <p>找到上面的 <code>springboot_mybatis</code> 项目，在<code>1pom.xml</code>文件中添加Redis起步依赖</p> <pre><code class="prism language-XML">&lt;!-- 配置使用redis启动器 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> </li><li> <p>在<code>application.yml</code>文件中添加 <code>redis</code> 的配置信息</p> <pre><code class="prism language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token comment"># 重新指定服务器端口号</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>

<span class="token key atrule">mybatis</span><span class="token punctuation">:</span>
  <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.ljf.pojo  <span class="token comment"># 指定mybatis别名包</span>
  <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>com/ljf/dao/<span class="token important">*.xml</span> <span class="token comment"># 指定xml映射文件路径</span>

<span class="token key atrule">logging</span><span class="token punctuation">:</span>
  <span class="token key atrule">level</span><span class="token punctuation">:</span>
    <span class="token key atrule">com.ljf.dao</span><span class="token punctuation">:</span> debug <span class="token comment"># 配置日志为debug级</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span> <span class="token comment"># 配置数据库数据源</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> root
    <span class="token key atrule">password</span><span class="token punctuation">:</span> ljf123
    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//192.168.195.100<span class="token punctuation">:</span>3306/meinian
    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>  <span class="token comment"># 配置Redis</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.195.100
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
</code></pre> </li><li> <p>注入<strong>RedisTemplate</strong>测试redis操作</p> <pre><code class="prism language-JAVA">package com.ljf.service.impl;

// import...

@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    private OrderDao orderDao;

    @Autowired
    private RedisTemplate redisTemplate;

    @Override
    public List&lt;Order&gt; findAll() {
        // redis的key
        String key = "alluser";
        // 先查询redis中是否有数据，如果有直接返回redis的数据
        List&lt;Order&gt; orders = (List&lt;Order&gt;) redisTemplate.boundValueOps(key).get();
        if (orders!=null) {
            return orders;
        }

        // 如果没有，查询数据库
        orders = orderDao.findAll();
        // 将数据库数据存入到redis中
        if (orders != null &amp;&amp; orders.size()&gt;0) {
            redisTemplate.boundValueOps(key).set(orders);
        }

        return orders;
    }
}
</code></pre> </li></ul> 
<h4><a id="55_SpringBoot_1109"></a>5.5 SpringBoot整合定时任务</h4> 
<h5><a id="551_SpringBoot_1111"></a>5.5.1 SpringBoot整合定时任务</h5> 
<ul><li> <p>创建工程 <code>springboot_task</code></p> </li><li> <p>在<code>pom.xml</code>文件中添加<strong>Scheduled</strong>依赖（基本SpringBoot依赖省略）</p> <pre><code class="prism language-XML">&lt;!-- 添加 Scheduled 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
    &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> </li><li> <p>创建SpringBoot启动类：</p> 
  <ul><li> <p>注意，使用定时任务需要使用 <strong>@EnableScheduling</strong> 注解标注启动类</p> <pre><code class="prism language-JAVA">package com.ljf;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling   // 定时任务需要加上这个注解
public class TaskApplication {
    public static void main(String[] args) {
        SpringApplication.run(TaskApplication.class, args);
    }
}
</code></pre> </li></ul> </li><li> <p>创建定时任务类：</p> 
  <ul><li> <p>任务类需要被Spring扫描到，所以需要使用<code>@Component</code>等注解标注。</p> </li><li> <p>定时任务方法需要使用<code>@Scheduled</code>注解标注，在该注解中设定定时规则，可选的规则有三个：</p> 
    <ol><li><strong>cron</strong>：cron表达式</li><li><strong>fixedDelay</strong>：在上一次定时任务执行完毕后N毫秒再次执行，</li><li><strong>fixedRate</strong>：执行周期，执行频率，定时任务执行开始，在过N毫秒后执行，例：<br> * 执行A任务花了2秒，比如参数是3000，A任务执行完成之后，在过1秒后执行，<br> * 执行A任务花了15秒，比如参数是3000，A任务执行完成之后，立即执行。</li></ol> <pre><code class="prism language-JAVA">package com.ljf.controller;

// import...

@Component
public class TaskController {
    /**
     *  @Scheduled注解: 设定定时规则，可选三种规则：
     *       1. cron：cron表达式
     *
     *       2. fixedDelay：距离上一次定时任务执行完毕后N毫秒在执行，
     *
     *       3. fixedRate：执行周期，执行频率，定时任务执行开始，在过N毫秒后执行，例：
     *          执行A任务花了2秒，比如参数是3000，A任务执行完成之后，在过1秒后执行，
     *          执行A任务花了15秒，比如参数是3000，A任务执行完成之后，立即执行。
     */
    @Scheduled(fixedDelay = 3000)
    public void myTask() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        System.out.println(simpleDateFormat.format(new Date()));
    }
}
</code></pre> 
    <ul><li> <p>结果：</p> <p><img src="https://images2.imgbox.com/7c/ef/7FJ6vUXj_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> </li></ul> 
<h5><a id="552_corn_1193"></a>5.5.2 corn表达式</h5> 
<ul><li> <p><strong>cron表达式</strong>：</p> 
  <ul><li>corn表达式分为七个域，依次分别是： 
    <ul><li><strong>秒 分 时 日 月 周 年</strong></li></ul> </li><li>每个域之间使用空格分隔</li><li>其中最后一个域（年）可以为空</li><li>每个域都有自己允许的值和一些特殊字符构成</li><li>使用这些特殊字符可以使我们定义的表达式更加灵活。</li></ul> </li><li> <p>下面是对这些特殊字符的介绍：</p> 
  <ul><li> <p>逗号（,）：指定一个值列表</p> 
    <ul><li>例如使用在月域上1,4,5,7表示1月、4月、5月和7月</li></ul> </li><li> <p>横杠（-）：指定一个范围</p> 
    <ul><li>例如在时域上3-6表示3点到6点（即3点、4点、5点、6点）</li></ul> </li><li> <p>星号（*）：表示这个域上包含所有合法的值</p> 
    <ul><li>例如，在月份域上使用星号意味着每个月都会触发</li></ul> </li><li> <p>斜线（/）：表示递增</p> 
    <ul><li>例如使用在秒域上0/15表示每15秒</li></ul> </li><li> <p>问号（?）：只能用在日和周域上，但是不能在这两个域上同时使用，表示不指定</p> 
    <ul><li>例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用 *，如果使用 * 表示不管星期几都会触发，实际上并不是这样。</li></ul> </li><li> <p>井号（#）：只能使用在周域上，用于指定月份中的第几周的哪一天</p> 
    <ul><li>例如6#3，意思是某月的第三个周五 (6=星期五，3意味着月份中的第三周)</li></ul> </li><li> <p>L：某域上允许的最后一个值，只能使用在日和周域上。</p> 
    <ul><li>当用在日域上，表示的是在月域上指定的月份的最后一天。</li><li>用于周域上时，表示周的最后一天，就是星期六</li></ul> </li><li> <p>W：W 字符代表着工作日 (星期一到星期五)，只能用在日域上，它用来指定离指定日的最近的一个工作日</p> <p><img src="https://images2.imgbox.com/86/c7/R8xIqvAZ_o.png" alt="在这里插入图片描述"></p> </li></ul> </li><li> <p><strong>cron表达式在线生成器</strong>：http://cron.qqe2.com/</p> </li></ul> 
<h4><a id="56_SpringBootThymeleaf_1242"></a>5.6 SpringBoot整合Thymeleaf</h4> 
<ul><li> <p>在<code>pom.xml</code>文件中加入<strong>thymeleaf</strong>起步依赖：</p> <pre><code class="prism language-XML">&lt;!-- thymeleaf 起步依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> </li><li> <p>在<code>application.yml</code>中设置 <code>thymeleaf</code> 的缓存设置，设置为false。</p> <pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">thymeleaf</span><span class="token punctuation">:</span>
    <span class="token key atrule">cache</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre> </li><li> <p>其他与以往发开一样，唯一需要注意的是：</p> 
  <ul><li>使用<strong>Ajax</strong>渲染页面时，<strong>Controller</strong>组件一般使用<code>@RestController</code></li><li>而使用<strong>Thymeleaf</strong>渲染页面时，<strong>Controller</strong>组件需要使用<code>Controller</code></li></ul> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d92972234b2e11a9fa153920cfbfebed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#异常总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba7e2692a16b163b2b206658c2eedb4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue路由配置公共布局layout</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>