<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【读书笔记】深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【读书笔记】深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制" />
<meta property="og:description" content="文章目录 文章说明第一部分 走近Java第1章 走进Java1.1 概述1.2 Java技术体系1.3 Java 发展史1.4 Java虚拟机发展史1.5 展望Java技术未来1.6 实战：自己编译JDK 第二部分 自动内存管理机制第2章 Java内存区域与内存溢出异常2.1 概述2.2 运行时数据区域2.3 HotSpot虚拟机对象探秘2.3.1 对象的创建（过程）2.3.2 对象的内存布局2.3.3 对象的访问定位 2.4 实战：OutOfMemoryError异常（OOM） 第3章 垃圾收集器与内存分配策略3.1 概述3.2 对象已死吗（如何判断对象可以被回收）3.2.1 引用计数法（不常用）3.2.2 可达性分析算法（常用）3.2.3 再谈引用（强/软/弱/虚引用、引用队列）3.2.4 生存还是死亡（finalize方法）3.2.5 回收方法区 3.3 垃圾收集算法3.3.1 标记-清理算法3.3.2 复制算法3.3.3 标记-整理算法3.3.4 分代收集算法 3.4 HotSpot的（收集）算法实现3.4.1 枚举根节点3.4.2 安全点（Safepoint） 3.5 （不同实现的）垃圾收集器3.5.1 Serial收集器（不常用）3.5.2 ParNew收集器（不常用）3.5.3 Parallel Scavenge收集器3.5.4 Serial Old收集器3.5.5 Parallel Old收集器3.5.6 CMS收集器（JDK1.8的收集器）3.5.7 GI 收集器3.5.8 理解GC日志3.5.9 垃圾收集器参数总结 3.6 内存分配与回收策略 第4章 虚拟机性能监控与故障处理工具4.1 概述4.2 JDK的命令行工具4.2.1 jps：虚拟机进程状况工具4.2.2 jstat：虚拟机统计信息监视工具4.2.3 jinfo：Java配置信息工具4.2.4 jmap：Java内存映像工具4.2.5 jhat：虚拟机堆转储快照分析工具4.2.6 jstack：Java堆栈跟踪工具4.2.7 HSDIS：JIT生成代码反汇编 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/38a4a2e911a6c805fd7946c88c44bae0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T09:15:13+08:00" />
<meta property="article:modified_time" content="2023-12-25T09:15:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【读书笔记】深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">文章说明</a></li><li><a href="#_Java_20" rel="nofollow">第一部分 走近Java</a></li><li><ul><li><a href="#1_Java_22" rel="nofollow">第1章 走进Java</a></li><li><ul><li><a href="#11__24" rel="nofollow">1.1 概述</a></li><li><a href="#12_Java_28" rel="nofollow">1.2 Java技术体系</a></li><li><a href="#13_Java__39" rel="nofollow">1.3 Java 发展史</a></li><li><a href="#14_Java_43" rel="nofollow">1.4 Java虚拟机发展史</a></li><li><a href="#15_Java_47" rel="nofollow">1.5 展望Java技术未来</a></li><li><a href="#16_JDK_51" rel="nofollow">1.6 实战：自己编译JDK</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__56" rel="nofollow">第二部分 自动内存管理机制</a></li><li><ul><li><a href="#2_Java_58" rel="nofollow">第2章 Java内存区域与内存溢出异常</a></li><li><ul><li><a href="#21__60" rel="nofollow">2.1 概述</a></li><li><a href="#22__64" rel="nofollow">2.2 运行时数据区域</a></li><li><a href="#23_HotSpot_84" rel="nofollow">2.3 HotSpot虚拟机对象探秘</a></li><li><ul><li><a href="#231__86" rel="nofollow">2.3.1 对象的创建（过程）</a></li><li><a href="#232__96" rel="nofollow">2.3.2 对象的内存布局</a></li><li><a href="#233__104" rel="nofollow">2.3.3 对象的访问定位</a></li></ul> 
    </li><li><a href="#24_OutOfMemoryErrorOOM_113" rel="nofollow">2.4 实战：OutOfMemoryError异常（OOM）</a></li></ul> 
   </li><li><a href="#3__130" rel="nofollow">第3章 垃圾收集器与内存分配策略</a></li><li><ul><li><a href="#31__132" rel="nofollow">3.1 概述</a></li><li><a href="#32__136" rel="nofollow">3.2 对象已死吗（如何判断对象可以被回收）</a></li><li><ul><li><a href="#321__138" rel="nofollow">3.2.1 引用计数法（不常用）</a></li><li><a href="#322__146" rel="nofollow">3.2.2 可达性分析算法（常用）</a></li><li><a href="#323__162" rel="nofollow">3.2.3 再谈引用（强/软/弱/虚引用、引用队列）</a></li><li><a href="#324_finalize_222" rel="nofollow">3.2.4 生存还是死亡（finalize方法）</a></li><li><a href="#325__241" rel="nofollow">3.2.5 回收方法区</a></li></ul> 
    </li><li><a href="#33__248" rel="nofollow">3.3 垃圾收集算法</a></li><li><ul><li><a href="#331__263" rel="nofollow">3.3.1 标记-清理算法</a></li><li><a href="#332__269" rel="nofollow">3.3.2 复制算法</a></li><li><a href="#333__278" rel="nofollow">3.3.3 标记-整理算法</a></li><li><a href="#334__285" rel="nofollow">3.3.4 分代收集算法</a></li></ul> 
    </li><li><a href="#34_HotSpot_293" rel="nofollow">3.4 HotSpot的（收集）算法实现</a></li><li><ul><li><a href="#341__295" rel="nofollow">3.4.1 枚举根节点</a></li><li><a href="#342_Safepoint_299" rel="nofollow">3.4.2 安全点（Safepoint）</a></li></ul> 
    </li><li><a href="#35__303" rel="nofollow">3.5 （不同实现的）垃圾收集器</a></li><li><ul><li><a href="#351_Serial_307" rel="nofollow">3.5.1 Serial收集器（不常用）</a></li><li><a href="#352_ParNew_315" rel="nofollow">3.5.2 ParNew收集器（不常用）</a></li><li><a href="#353_Parallel_Scavenge_321" rel="nofollow">3.5.3 Parallel Scavenge收集器</a></li><li><a href="#354_Serial_Old_330" rel="nofollow">3.5.4 Serial Old收集器</a></li><li><a href="#355_Parallel_Old_334" rel="nofollow">3.5.5 Parallel Old收集器</a></li><li><a href="#356_CMSJDK18_338" rel="nofollow">3.5.6 CMS收集器（JDK1.8的收集器）</a></li><li><a href="#357_GI__358" rel="nofollow">3.5.7 GI 收集器</a></li><li><a href="#358_GC_382" rel="nofollow">3.5.8 理解GC日志</a></li><li><a href="#359__400" rel="nofollow">3.5.9 垃圾收集器参数总结</a></li></ul> 
    </li><li><a href="#36__406" rel="nofollow">3.6 内存分配与回收策略</a></li></ul> 
   </li><li><a href="#4__425" rel="nofollow">第4章 虚拟机性能监控与故障处理工具</a></li><li><ul><li><a href="#41__427" rel="nofollow">4.1 概述</a></li><li><a href="#42_JDK_431" rel="nofollow">4.2 JDK的命令行工具</a></li><li><ul><li><a href="#421_jps_435" rel="nofollow">4.2.1 jps：虚拟机进程状况工具</a></li><li><a href="#422_jstat_455" rel="nofollow">4.2.2 jstat：虚拟机统计信息监视工具</a></li><li><a href="#423_jinfoJava_488" rel="nofollow">4.2.3 jinfo：Java配置信息工具</a></li><li><a href="#424_jmapJava_541" rel="nofollow">4.2.4 jmap：Java内存映像工具</a></li><li><a href="#425_jhat_562" rel="nofollow">4.2.5 jhat：虚拟机堆转储快照分析工具</a></li><li><a href="#426_jstackJava_569" rel="nofollow">4.2.6 jstack：Java堆栈跟踪工具</a></li><li><a href="#427_HSDISJIT_583" rel="nofollow">4.2.7 HSDIS：JIT生成代码反汇编</a></li></ul> 
    </li><li><a href="#43_JDK_588" rel="nofollow">4.3 JDK的可视化工具</a></li><li><ul><li><a href="#431_JConsoleJava_590" rel="nofollow">4.3.1 JConsole：Java监视与管理控制台</a></li><li><a href="#432_VisualVM_627" rel="nofollow">4.3.2 VisualVM：多合一故障处理工具</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5__658" rel="nofollow">第5章 调优案例分析与实战</a></li><li><ul><li><a href="#51__660" rel="nofollow">5.1 概述</a></li><li><a href="#52__664" rel="nofollow">5.2 案例分析</a></li><li><ul><li><a href="#521__666" rel="nofollow">5.2.1 高性能硬件上的程序部署策略</a></li><li><a href="#522__683" rel="nofollow">5.2.2 集群间同步导致的内存溢出</a></li><li><a href="#523__694" rel="nofollow">5.2.3 堆外内存导致的溢出错误</a></li><li><a href="#524__705" rel="nofollow">5.2.4 外部命令导致系统缓慢</a></li><li><a href="#525_JVM_723" rel="nofollow">5.2.5 服务器JVM进程崩溃</a></li><li><a href="#526__734" rel="nofollow">5.2.6 不恰当数据结构导致内存占用过大</a></li><li><a href="#527_Windows_742" rel="nofollow">5.2.7 由Windows虚拟内存导致的长时间停顿</a></li></ul> 
    </li><li><a href="#53_Eclipse_751" rel="nofollow">5.3 实战：Eclipse运行速度调优</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>文章说明</h2> 
<p>本文是《深入理解Java虚拟机（周志明）》这本书的重点摘要。</p> 
<p>本笔记仅作为复习，不过多的对内容进行讲解。</p> 
<p>本笔记按照书的目录进行，如遇到需要细看的，可以到书中找对应内容。</p> 
<p>本笔记并不是按照书中原话进行摘要，而是根据自己的理解使用大白话进行记录，同时进行了少部分扩展。如有错误欢迎指出。</p> 
<p>由于内容较多，一共分为三篇：</p> 
<table><thead><tr><th>篇幅</th><th>链接</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/134927759">深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/134927759</td></tr><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/135067398">深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/135067398</td></tr><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/135111650">深入理解Java虚拟机（周志明）（5）第五部分 高效并发</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/135111650</td></tr></tbody></table> 
<h2><a id="_Java_20"></a>第一部分 走近Java</h2> 
<h3><a id="1_Java_22"></a>第1章 走进Java</h3> 
<h4><a id="11__24"></a>1.1 概述</h4> 
<p>无重点</p> 
<h4><a id="12_Java_28"></a>1.2 Java技术体系</h4> 
<p><img src="https://images2.imgbox.com/1e/2e/och0yJkV_o.png" alt="在这里插入图片描述"></p> 
<p>Java按运行平台可分为四种：</p> 
<ul><li>Java Card：运行在小内存设备上的Java小程序（Applets），例如：智能卡</li><li>Java ME（Micro Edition）：移动中断，例如：手机、Pad。</li><li>Java SE（Standard Edition）：面向桌面应用程序</li><li>Java EE（Enterprise Edition）：面向企业应用</li></ul> 
<h4><a id="13_Java__39"></a>1.3 Java 发展史</h4> 
<p>无重点</p> 
<h4><a id="14_Java_43"></a>1.4 Java虚拟机发展史</h4> 
<p>无重点</p> 
<h4><a id="15_Java_47"></a>1.5 展望Java技术未来</h4> 
<p>无重点</p> 
<h4><a id="16_JDK_51"></a>1.6 实战：自己编译JDK</h4> 
<p>无重点</p> 
<h2><a id="__56"></a>第二部分 自动内存管理机制</h2> 
<h3><a id="2_Java_58"></a>第2章 Java内存区域与内存溢出异常</h3> 
<h4><a id="21__60"></a>2.1 概述</h4> 
<p>学习Java虚拟机的重要原因：当出现内存泄漏时，知道怎么排查。</p> 
<h4><a id="22__64"></a>2.2 运行时数据区域</h4> 
<p><img src="https://images2.imgbox.com/de/ff/arzJvCxu_o.png" alt="在这里插入图片描述"></p> 
<p>数据区有两种：</p> 
<ul><li><strong>由所有线程共享的数据区</strong>：字面意思，所有线程都使用同一个。</li><li><strong>线程隔离的数据区</strong>：每个线程有自己的，例如：每个线程都有自己的程序技术器</li></ul> 
<p>如上图，JVM内存被分为了如下区域：</p> 
<ul><li><strong>程序计数器</strong>：线程私有（即每个线程拥有自己的程序计数器），用于记录当前线程执行到哪一行了。</li><li><strong>虚拟机栈</strong>：线程私有，用于记录方法执行过程中的局部变量、方法出口等信息。每当进入一个方法，就会为该方法创建一个“栈帧”，该方法的局部变量都在这个栈帧中存储。（第8章详解）</li><li><strong>本地方法栈</strong>（Native Method Stack）：和虚拟机栈类似，不过是给Native方法用的。（Native方法就是那些在外部实现的方法，例如某些方法是用C++实现的）</li><li><strong>堆</strong>：线程共享（即整个虚拟机只有一块堆内存，所有线程都共用这一块），“几乎”所有的对象和数组都存在堆中。研究JVM重点就是研究堆内存。堆内存空间不足时会抛出<code>OutOfMeoryError</code>(OOM)。（第3章详解）</li><li><strong>方法区</strong>(Method Area)：线程共享，用来存类信息、常量、静态变量、动态编译的代码（在运行时编译的代码，而非一开始编译好的）。方法区也被称为<strong>永久代</strong>(Permanent Generation)。 
  <ul><li><strong>运行时常量池</strong>：方法区的一部分。用于存放常量（就是被final修饰的部分）。字符串也是放在常量池中的。</li></ul> </li><li><strong>直接内存</strong>(Direct Memory)：非虚拟机内存。直接操作本机的物理内存。例如：我写了一个Native方法调用了一个外部的C++程序，在这个C++程序中申请了10M内存，那这10M内存不会算在JVM中，而是直接和从本机物理内存申请的。</li></ul> 
<h4><a id="23_HotSpot_84"></a>2.3 HotSpot虚拟机对象探秘</h4> 
<h5><a id="231__86"></a>2.3.1 对象的创建（过程）</h5> 
<p>当JVM遇到一条<code>new</code>指令时，会进行如下过程：</p> 
<ol><li>去“方法区”中找是否加载了该类。若没有加载，则会执行“类加载”过程。（第7章详解）</li><li>为新对象分配内存（分多少在类加载后即可确定）。（不同JVM分配方式详见书籍）</li><li>为分配的内存区域全部赋值0。（这也是为什么类字段不给默认值时会默认初始化为0）</li><li>设置对象信息，存储在对象头（Object Header）中。包括：该对象是哪个类、HashCode值等。</li><li>最后执行构造方法初始化对象。</li></ol> 
<h5><a id="232__96"></a>2.3.2 对象的内存布局</h5> 
<p>一个对象在内存中有三块区域，分别是：</p> 
<ol><li><strong>对象头</strong>（Header）：存储对象的必要信息，包括：hashCode、GC分代年龄、锁状态标志、该对象是哪个类（用于找到对应类的信息）等</li><li><strong>实例数据</strong>（Instance Data）：存储对象字段数据（就是用户定义的各个变量）。</li><li><strong>对齐填充</strong>（Padding）：因为分配内存的时候最小单位是8字节，最后用不完的就填充一下。</li></ol> 
<h5><a id="233__104"></a>2.3.3 对象的访问定位</h5> 
<p>我们使用的对象变量仅存储该对象的引用（reference），因此在实际访问对象时需要根据reference去堆内存中查找。</p> 
<p>查找方式有两种（不同的JVM采用方式不同）：</p> 
<ol><li><strong>直接指针访问对象</strong>（常用）：reference记录的就是对象在堆内存的地址，可以用这个地址直接在虚拟机中找到对象数据。若要找该对象对应类的信息，那么根据对象头中的类信息地址去方法区找。<img src="https://images2.imgbox.com/13/30/DbPFJJLg_o.png" alt="在这里插入图片描述" width="500"></li><li><strong>通过句柄访问对象</strong>：reference指向的是句柄池，句柄池中记录了对象的地址。由于句柄是两次访问，因此缺点是速度较慢。优点是移动对象时（垃圾回收时会移动对象的位置）只需要更新句柄中的地址，比较方便。<img src="https://images2.imgbox.com/b2/0a/G2p6fVpD_o.png" alt="在这里插入图片描述" width="500"></li></ol> 
<h4><a id="24_OutOfMemoryErrorOOM_113"></a>2.4 实战：OutOfMemoryError异常（OOM）</h4> 
<p>除了程序计数器，其他区域都可能会出现OOM。</p> 
<p>以下是不同内存区域OOM的原因：</p> 
<ul><li><strong>Java堆溢出</strong>：当<strong>不断的new对象</strong>，但这些<strong>对象又释放不掉</strong>，最终导致堆内存不够用时，就会产生OOM。堆溢出分两种原因： 
  <ul><li><strong>内存泄露</strong>（Memory Leak）：本该释放掉的对象由于代码bug，导致还在被引用，因此没有被释放。<strong>解决方案</strong>：分析dump文件的GC Roots引用链。</li><li><strong>内存溢出</strong>（Memory Overflow）：不存在内存泄露，所有的对象都是程序必须的，就是<strong>单纯的堆内存不够用</strong>了。<strong>解决方案</strong>：调大堆内存（<code>-Xmx</code>与<code>-Xms</code>参数）</li></ul> </li><li><strong>虚拟机栈和本地方法栈溢出</strong>：栈溢出通常有两种情况： 
  <ul><li><strong>栈深度过大</strong>（常见）：抛出<code>StackOverflowError</code>异常。一般出现在“异常的递归”中，正常方法间调用的深度不至于溢出。</li><li><strong>栈内存不够</strong>（不常见）：可以调整<code>-Xss</code>参数增大栈内存容量。</li></ul> </li><li><strong>常量池溢出</strong>：由于字符串存在常量池中，如果程序中有大量被引用的字符串时，导致这些字符串不能被垃圾回收，最终就会出现常量池溢出。例如：你有个<code>List&lt;String&gt;</code>，然后你一直往里扔“不同的”String，就会出现常量池溢出。</li><li><strong>方法区溢出</strong>：方法区是存Class信息的，因此当运行时不断的动态加载类时（例如使用动态编译在运行时新增类），就会产生方法区溢出。</li><li><strong>本机直接内存溢出</strong>：当Native方法直接向本机申请内存，但内存又不够时，就会出现内存溢出。（实际上并没有真正执行申请动作，而是在检查本机内存是否够这个动作中抛出的异常，异常栈的最顶层一般为：<code>sun.misc.Unsafe.allocateMemory(Native Method)</code>）</li></ul> 
<h3><a id="3__130"></a>第3章 垃圾收集器与内存分配策略</h3> 
<h4><a id="31__132"></a>3.1 概述</h4> 
<p>学习垃圾收集（Garbage Collection, GC）的原因：可以帮助我们<strong>避免和解决OOM问题、由JVM引起的性能瓶颈等</strong></p> 
<h4><a id="32__136"></a>3.2 对象已死吗（如何判断对象可以被回收）</h4> 
<h5><a id="321__138"></a>3.2.1 引用计数法（不常用）</h5> 
<p>思路：记录每个对象当前被多少对象引用。若为0，说明没有被引用，就可以被回收了。</p> 
<p>优点：简单、高效</p> 
<p>缺点：<strong>无法解决循环引用问题</strong>。(例如：A、B两个垃圾互相引用，导致无法被回收)</p> 
<h5><a id="322__146"></a>3.2.2 可达性分析算法（常用）</h5> 
<p>思路：从“GC Roots”对象出发，若无法访问到某个对象，说明这个对象可以被回收了。</p> 
<p><img src="https://images2.imgbox.com/be/df/ZVmJDAF7_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>以下变量都会作为GC Roots：</p> 
<ol><li><strong>虚拟机栈中的变量</strong>：目前还没运行结束的方法中的变量。</li><li><strong>类的静态变量</strong></li><li>方法区中的常量：例如常量池中的String</li><li>本地方法栈中引用的对象</li><li>Java虚拟机的内部对象：例如：基本数据类型对应的Class对象等</li><li>被synchronized锁住的对象</li><li>…</li></ol> 
<h5><a id="323__162"></a>3.2.3 再谈引用（强/软/弱/虚引用、引用队列）</h5> 
<p>Java中的引用可以按强弱程度分为四种，JVM对不同程度的引用回收策略不同：</p> 
<p><strong>强引用</strong>（Strong Reference）：我们平时用的都是强引用。例如：<code>MyObject myObj = new MyObject();</code></p> 
<ul><li>回收：只要有引用，就不会被回收。</li></ul> 
<p><strong>软引用</strong>（Soft Reference）：使用<code>SoftReference</code>显式声明。</p> 
<ul><li>回收：当JVM内存不够时，会对软引用对象进行回收。</li><li>应用场景：做缓存。</li><li>使用样例：<pre><code class="prism language-java"> <span class="token class-name">MyObject</span> myObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token string">"Amy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从数据库中获取数据</span>
 <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyObject</span><span class="token punctuation">&gt;</span></span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 增添软引用</span>

 <span class="token comment">// do something ...</span>

 myObject <span class="token operator">=</span> reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 尝试获取myObject对象</span>

 <span class="token keyword">if</span> <span class="token punctuation">(</span>myObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// 没获取到，说明已经被JVM回收了</span>
     myObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token string">"Amy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 重新从数据库中获取数据</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// 没有被JVM回收</span>
 <span class="token punctuation">}</span>
</code></pre> </li></ul> 
<p><strong>弱引用</strong>（Weak Reference）：使用<code>WeakReference</code>显式声明。</p> 
<ul><li>回收：当JVM下次执行垃圾回收时，就会立刻回收。</li><li>应用场景：做缓存。</li><li>使用样例：和上面<code>SoftReference</code>一样，把<code>SoftReference</code>改成<code>WeakReference</code>即可。</li></ul> 
<p><strong>虚引用</strong>（Phantom Reference）：也称为“幽灵引用”、“幻影引用”等。</p> 
<ul><li>回收：当JVM执行垃圾回收时，就会立刻回收</li><li>应用场景：单纯的将其标记一下，配合引用队列（<code>ReferenceQueue</code>）进行回收前的一些操作</li><li>特殊点：虚引用的<code>reference.get()</code>方法一定会返回<code>null</code>（源码就是直接<code>return null</code>，这也是为什么叫虚引用的原因。</li><li>使用样例：建后续引用队列。</li></ul> 
<p>注：一个对象可以同时存在多种引用。例如：</p> 
<pre><code class="prism language-Java">MyObject myObject = new MyObject("Amy");  // 此时myObject存在强引用
SoftReference&lt;MyObject&gt; reference = new SoftReference&lt;&gt;(myObject);  // myObject同时存在强引用和软引用

myObject = null; // 去掉myObject的强引用，其只剩下软引用
</code></pre> 
<hr> 
<p><strong>引用队列</strong>：在定义软/弱/虚引用时，可以传个引用队列（虚引用必须传），这样对象在被回收之前会进入引用队列，可以显式的对其进行一些操作。（引用队列只能获取到“引用对象”即<code>XxxReference</code>，获取不到原对象，因为可能已经被JVM释放了）。</p> 
<p>对着四种引用更详细的讲解可参考：<a href="https://blog.csdn.net/zhaohongfei_358/article/details/134991715">Java中的强引用、软引用、弱引用、虚引用与引用队列 通俗举例实战详解</a></p> 
<h5><a id="324_finalize_222"></a>3.2.4 生存还是死亡（finalize方法）</h5> 
<p>对象被释放会经历两次标记：</p> 
<ol><li><strong>GC Roots不可达</strong>，第一次标记</li><li>没有重写<code>finalize</code>或JVM已经调用过<code>finalize</code>。注意：这里只是调用过，执行成没成功甚至是否执行完成都不管</li></ol> 
<p>当两次标记结束后，就会正式释放对象。</p> 
<p>若用户重写了finalize，则对象会在第一次标记后经历如下过程：</p> 
<ol><li>进入<code>F-Queue</code>队列</li><li>JVM使用<code>Finalizer</code>线程去调用<code>finalize</code>方法</li><li>之后不管<code>finalize</code>是否执行完，都释放对象。</li></ol> 
<blockquote> 
 <p>若用户在<code>finalize</code>方法中重新给对象增加了引用（不推荐这么做），那么这个对象就不会被释放了。</p> 
</blockquote> 
<p>由于JVM并不保证finalize是否执行完，因此不推荐使用<code>finalize</code>方法。如果要释放资源，try-with和虚引用都比<code>finalize</code>更好。</p> 
<h5><a id="325__241"></a>3.2.5 回收方法区</h5> 
<p>方法区通常有两种东西要回收：</p> 
<ol><li><strong>废弃常量</strong>：例如 各种字符串。</li><li><strong>无用的类</strong>：对于各种动态生成的类，若其对象和ClassLoader都被回收了，其就可能被回收。一般用到动态代理的框架中会有相关的卸载类机制来避免方法区OOM。</li></ol> 
<h4><a id="33__248"></a>3.3 垃圾收集算法</h4> 
<p>不同的虚拟机会采用不同的垃圾收集算法。也可能会同时使用不同的收集算法。</p> 
<p><img src="https://images2.imgbox.com/51/f5/u9Rzolhz_o.png" alt="在这里插入图片描述" width="600"><br> (图片来源：<a href="https://zhuanlan.zhihu.com/p/511132804" rel="nofollow">JVM 内存结构</a>)</p> 
<p>JVM根据对象的存活时长，将堆区域分为了<strong>新生代</strong>（Young）和<strong>老年代</strong>（Old Generation），而新生代又被分为了<strong>Eden</strong>区和<strong>两个Suvivor</strong>区：</p> 
<ul><li><strong>新生代</strong>：用于存放新生成的对象，内存小，清理快。新生代的GC称为<strong>Minor GC</strong>。新生代包含1一个Eden区和两个Survivor区 
  <ul><li><strong>Eden区</strong>：新生成的对象存在Eden区，当Eden区慢的时候会触发GC（也会定期清理）。其采用复制算法，将存活的对象复制到一个空的Survivor区域。</li><li><strong>Survivor区</strong>：两个Surviro区域，其中一个为空，另一个用于存放年龄大于1的对象。当发生Minor GC时，会将有对象的Survivor区域进行清理，并将存活对象全部挪到另一个Survivor去，然后清空当前Survivor取，并将所有对象年龄+1（表示这些对象又躲过了一次Minor GC，因此年龄又涨了一岁）。两个Suvivor区域就是这么交替清理。当对象存货超过15岁（参数可调），就会被移到老年代。</li></ul> </li><li><strong>老年代</strong>：用于存放长期存活的对象，内存大，因此清理速度慢。（若有一个大对象Eden区放不下，那么也会直接进入老年代）。</li></ul> 
<h5><a id="331__263"></a>3.3.1 标记-清理算法</h5> 
<p>思路：分两步：① 先对垃圾对象进行标记； ② 对标记的对象进行清理</p> 
<p>缺点：会产生大量<strong>内存碎片</strong></p> 
<h5><a id="332__269"></a>3.3.2 复制算法</h5> 
<p>思路：将内存分成两个区域。一次只使用一个区域，当该区域满时，直接将该区域存活的对象复制到另一个区域，然后使用另一个区域，因此这个区域就可以直接清空了。</p> 
<p>优点：没有内存碎片</p> 
<p>缺点：内存可用区域减少。</p> 
<h5><a id="333__278"></a>3.3.3 标记-整理算法</h5> 
<p>思路：与标记清除类似。分三步：① 标记；② 将存活对象往一端挪，避免内存碎片。③ 清理另一端内存。</p> 
<p>缺点：慢</p> 
<p>优点：无内存碎片</p> 
<h5><a id="334__285"></a>3.3.4 分代收集算法</h5> 
<p>思路：将内存分为新生代和老年代。</p> 
<ul><li>新生代：内存小，里面都是新对象，采用标记整理算法。</li><li>老年代：内存大，里面都是存货时间长的对象，采用复制算法。</li></ul> 
<h4><a id="34_HotSpot_293"></a>3.4 HotSpot的（收集）算法实现</h4> 
<h5><a id="341__295"></a>3.4.1 枚举根节点</h5> 
<p>为了保证GC过程中引用不能发生变化，因此在枚举根节点时，所有的Java线程都会暂停，称为<code>Stop The World</code>。</p> 
<h5><a id="342_Safepoint_299"></a>3.4.2 安全点（Safepoint）</h5> 
<p>在开始枚举根节点前，必须要保证所有的线程都处在一个安全点（safepoint）上，以便可以快速准确完成GC。若线程不在安全点上，那就需要等它执行到安全点。</p> 
<h4><a id="35__303"></a>3.5 （不同实现的）垃圾收集器</h4> 
<p>没有最好的垃圾收集器，只有最适合自己的。</p> 
<h5><a id="351_Serial_307"></a>3.5.1 Serial收集器（不常用）</h5> 
<p><img src="https://images2.imgbox.com/d2/fb/324F7Xv9_o.png" alt="在这里插入图片描述" width="700"></p> 
<p>古老的收集器，现在不用了。</p> 
<p>特点：单线程</p> 
<h5><a id="352_ParNew_315"></a>3.5.2 ParNew收集器（不常用）</h5> 
<p><img src="https://images2.imgbox.com/e4/14/5YGb03ux_o.png" alt="在这里插入图片描述" width="700"></p> 
<p>在Serial收集器的基础上增加了多线程。</p> 
<h5><a id="353_Parallel_Scavenge_321"></a>3.5.3 Parallel Scavenge收集器</h5> 
<p>在ParNew收集器的基础上，增加了对吞吐量的关注。即：一定时间内，让JVM更多的运行Java代码。</p> 
<p>主要方式就是：自适应条件新生代老年代内存大小、GC频次等。（也可以手动配）</p> 
<p>因此，Parallel Scavenge收集器适用于<strong>计算型任务</strong>。</p> 
<h5><a id="354_Serial_Old_330"></a>3.5.4 Serial Old收集器</h5> 
<p>无重点</p> 
<h5><a id="355_Parallel_Old_334"></a>3.5.5 Parallel Old收集器</h5> 
<p>无重点</p> 
<h5><a id="356_CMSJDK18_338"></a>3.5.6 CMS收集器（JDK1.8的收集器）</h5> 
<p>CMS（Concurrent Mark Sweep）目标：致力于<strong>回收停顿时间最短</strong>。常用于<strong>服务端</strong>，</p> 
<p>CMS采用“标记-清理”算法，共分为4步：</p> 
<ol><li>初始标记：Stop the World，仅标记直接和GC Roots关联的对象（即父节点是GC Roots的对象）</li><li>并发标记：与用户程序并发进行，沿着初始标记的节点标记下面的子节点。</li><li>重新标记：需要Stop the World。由于②过程是并发进行，部分节点引用会改变，因此需要再次扫描整个堆，修正改变引用的标记。时间较慢。</li><li>并发清除：与用户程序并发进行。清除无用的对象</li></ol> 
<p>CMS收集器的缺点：</p> 
<ol><li>由于是并发收集，<strong>占用CPU资源</strong>。</li><li><strong>预留内存，提前GC</strong>：由于清理过程是并发进行的，那么清理时就要给用户线程预留内存，避免用户线程申请的对象没地方放导致OOM。假设给用户预留8%内存，那么当老年代内存占比到92%时就会开始GC。</li><li><strong>并发收集失败</strong>（<strong>Concurrent Model Failure</strong>）问题：若GC过程中，预留内存不够用户线程用，就会导致Concurrent Model Failure。此时会停止并发收集，改用原始Full GC，即Stop the World，然后标记清理。（因此，需要根据业务情况调节预留内存大小）</li><li><strong>内存碎片</strong>：很明显，CMS会产生内存碎片。若导致用户线程大连续对象分不到内存，就会提前触发Full GC，并对内存碎片进行整理。</li></ol> 
<h5><a id="357_GI__358"></a>3.5.7 GI 收集器</h5> 
<p>GI收集器在CMS收集器的基础上进一步进化。</p> 
<p>GI收集器<strong>面向服务端应用</strong>。JDK1.9作为默认收集器。</p> 
<p>GI收集器在上述收集器的基础上，实现了“可指定最大停顿时间”。官方称为<strong>全能收集器</strong>。</p> 
<p>GI收集器基本思路：</p> 
<p><img src="https://images2.imgbox.com/72/9b/v8WUzxNL_o.png" alt="在这里插入图片描述"></p> 
<p>① GI将堆分为了许多同等大小的<strong>Region</strong>，每个小格子就是一个Region，每个Region取值范围为1~32MB。<br> ② 这样Eden区、Survivor区、Old区都是逻辑连续，实际物理不连续。<br> ③ 各个区的region数量不固定，运行过程中可以灵活调节。<br> ④ Humongous区用于存放大对象。若一个对象的大小超过了Region大小的50%，就认为是大对象。</p> 
<p>GI的三种垃圾回收模式：</p> 
<ul><li><strong>Young GC</strong>：当Eden区满时，可以很容易估算Eden区GC的耗时，若耗时太小，就会分几个Region给Eden区。</li><li><strong>Mixed GC</strong>：新生代+部分老年代（根据用户设置的“最大停顿时间”来决定回收哪些回收多少Old的Region区）+大对象区域</li><li><strong>Full GC</strong>：全堆扫描，对所有区域回收。</li></ul> 
<h5><a id="358_GC_382"></a>3.5.8 理解GC日志</h5> 
<p>GC日志样例：</p> 
<pre><code>33.125:[GC[DefNew: 3324K- ＞152K(3712K)，0.0025925 secs] 3324K- ＞ 152K（ 11904K）， 0. 0031680 secs] 
100.667:[Full GC[Tenured: 0 K- ＞ 210K（ 10240K）， 0. 0149142secs] 4603K- ＞ 210K（ 19456K），[Perm: 2999K-＞2999K（ 21248K）]， 0. 0150007 secs][Times: user= 0.01 sys= 0.00， real=0.02 secs]
</code></pre> 
<p>含义如下：</p> 
<ul><li><code>33.125</code> / <code>100.667</code>：GC发生的时间。该数字为JVM启动后经历的秒数。</li><li><code>[GC</code> / <code>[Full GC</code>：GC的类型。Full GC会Stop-The-World</li><li><code>[DefNew</code> / <code>Tenured</code> / <code>Perm</code> ：GC发生的区域（不同的虚拟机名字会有差异）</li><li><code>3324K-&gt;152K(3712K)</code>：<code>GC前该内存区域已使用容量</code> -&gt; <code>GC后该内存区域已使用容量</code> (<code>该内存区域总容量</code>)</li><li><code>0.0025925 secs</code>：GC所使用的时间</li><li><code>[Times: user=0.01 sys=0.00， real=0.02secs]</code>：user=用户态耗时、sys=内核态耗时、real总耗时（包括从准备开始GC到真正开始GC消耗的时间，这部分也会STW，见5.2.7节）。</li></ul> 
<h5><a id="359__400"></a>3.5.9 垃圾收集器参数总结</h5> 
<ul><li><code>SurvivorRatio</code>：调整Eden区和Survivor区的比值。默认为8:1:1。例如：我们经常要产生临时大对象时，可以将</li><li><code>PretenureSizeThreshold</code>：直接晋级到老年代对象的大小。</li><li><code>CMSInitiatingOccupancyFraction</code>：设置CMS收集器GC时给用户留多少%的空间</li></ul> 
<h4><a id="36__406"></a>3.6 内存分配与回收策略</h4> 
<p><strong>对象优先在Eden区分配</strong></p> 
<p>GC分两种：</p> 
<ul><li>新生代GC（Minor GC）：新生代的GC，新生代内存小，GC速度快。</li><li>老年代GC（Major GC/Full GC）：老年代的GC，老年代内存大，GC慢</li></ul> 
<p><strong>大对象“可能”会直接进入老年代</strong>，三种情况：</p> 
<ul><li>新生代内存不够放大对象</li><li>大对象连续空间，新生代没这么多连续空间</li><li>大对象大小超过了虚拟机的配置（虚拟机可以配当对象超过多大直接进入老年代），直接进入老年代</li></ul> 
<p><strong>长期存活的对象将进入老年代</strong>：对象每躲过一次Minor GC，年龄就会+1，当年龄到15岁时就会进入老年代。</p> 
<h3><a id="4__425"></a>第4章 虚拟机性能监控与故障处理工具</h3> 
<h4><a id="41__427"></a>4.1 概述</h4> 
<p>无重点</p> 
<h4><a id="42_JDK_431"></a>4.2 JDK的命令行工具</h4> 
<p>JDK在<code>bin</code>目录下提供了各种用于诊断程序的命令行工具：</p> 
<h5><a id="421_jps_435"></a>4.2.1 jps：虚拟机进程状况工具</h5> 
<p><code>jps</code>：查看当前机器都运行了哪些Java程序。</p> 
<p>样例：</p> 
<pre><code>&gt; jps

181584 Launcher
180296 KotlinCompileDaemon
182216 RemoteMavenServer
176556 MySpringBootApplication
185036 Jps
</code></pre> 
<p>前面的数字是该程序的<strong>虚拟机唯一ID（Local Virtual Machine Identifier, LVMID）</strong>，后面排查问题需要用到。</p> 
<p>后面的是Java程序的<code>main</code>方法类名。</p> 
<h5><a id="422_jstat_455"></a>4.2.2 jstat：虚拟机统计信息监视工具</h5> 
<p><code>jstat</code> 是一个监视各种状态的通用命令。</p> 
<p>使用方式为：<code>jstat -[工具] [vmid]</code></p> 
<blockquote> 
 <p>vmid就是上面提到的LVMID，使用jps命令查看。</p> 
</blockquote> 
<p>使用样例：</p> 
<p>监视GC情况：</p> 
<pre><code>&gt; jstat -gc 176556

 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
47616.0 42496.0  0.0   38949.0 968704.0 505022.9  165376.0   112599.7  92032.0 86841.6 11904.0 10893.4     15    0.255   3      0.185    0.440
</code></pre> 
<p>监视类“装/卸载”情况：</p> 
<pre><code>&gt; jstat -class 176556

Loaded  Bytes  Unloaded  Bytes     Time
 16799 31461.8        7     7.1      18.95
</code></pre> 
<p>jstat主要工具：</p> 
<p><img src="https://images2.imgbox.com/ca/e9/gSo0mI7v_o.png" alt="在这里插入图片描述" width="800"></p> 
<h5><a id="423_jinfoJava_488"></a>4.2.3 jinfo：Java配置信息工具</h5> 
<p><code>jinfo</code>：用于实时查看和调整虚拟机各项参数</p> 
<p>使用方式：</p> 
<ol><li>查看JVM配置信息： <code>jinfo [vmid]</code></li><li>增加JVM配置：<code>jinfo -flag +[配置项]</code></li><li>取消JVM配置：<code>jinfo -flag -[配置项]</code></li><li>修改JVM配置：<code>jinfo -flag [配置项]=[修改后配置]</code>。注意：大部分配置是不可以动态修改的。若不能（或者是拼写错误），都会报<code>flag 'XXX' cannot be changed</code> 错误。</li></ol> 
<p>使用样例：</p> 
<p>查看虚拟机各项参数：</p> 
<pre><code>&gt; jinfo 176556

Attaching to process ID 176556, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.281-b09
Java System Properties:

jboss.modules.system.pkgs = com.intellij.rt
.... # 这里省略若干参数

VM Flags:
Non-default VM flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote .... # 省略若干参数
</code></pre> 
<p>运行时增加打印GC详细信息：</p> 
<pre><code>&gt; jinfo -flag +PrintGCDetails 176556

# 执行完这条命令后，再观察程序，就会发现发生GC时就会在控制台打日志了
</code></pre> 
<p>运行时取消打印GC详细信息：</p> 
<pre><code>&gt; jinfo -flag -PrintGCDetails 176556

# 执行完后，发现程序又不打印日志了
</code></pre> 
<p>运行时修改Dump文件路径：</p> 
<pre><code>&gt; jinfo -flag HeapDumpPath=D:/ 176556
</code></pre> 
<h5><a id="424_jmapJava_541"></a>4.2.4 jmap：Java内存映像工具</h5> 
<p><code>jmap</code>：用于查看/导出Java内存使用情况</p> 
<p>使用方式：<code>jmap [option] &lt;vmid&gt;</code></p> 
<p>jmap工具的主要选项：</p> 
<p><img src="https://images2.imgbox.com/c1/da/i2mcq5GY_o.png" alt="在这里插入图片描述" width="800"></p> 
<p>使用样例：</p> 
<p>导出Dump文件到指定位置：</p> 
<pre><code>&gt; jmap -dump:file=D:\test.dump 176556

Dumping heap to D:\test.dump ...
Heap dump file created
</code></pre> 
<h5><a id="425_jhat_562"></a>4.2.5 jhat：虚拟机堆转储快照分析工具</h5> 
<p><code>jhat</code>（Java Heap Analysis Tool）：用于分析dump文件。</p> 
<blockquote> 
 <p>由于功能简陋，目前已经不怎么使用了。一般用VisualVM或其他更专业的工具</p> 
</blockquote> 
<h5><a id="426_jstackJava_569"></a>4.2.6 jstack：Java堆栈跟踪工具</h5> 
<p><code>jstack</code>：生成虚拟机当前时刻的线程快照。</p> 
<p>使用方式：<code>jstack &lt;vmid&gt;</code></p> 
<p>使用样例：</p> 
<pre><code>&gt; jstack 176556

# ... 生成了许多堆栈信息
</code></pre> 
<h5><a id="427_HSDISJIT_583"></a>4.2.7 HSDIS：JIT生成代码反汇编</h5> 
<p><code>XXX.class</code>字节码只是描述了程序在虚拟机中应该怎么执行，但使用不同的虚拟机运行过程还不太一样。如果我们想知道真正怎么执行，可以用JIT命令生成汇编文件，然后看虚拟机是怎么执行的。</p> 
<h4><a id="43_JDK_588"></a>4.3 JDK的可视化工具</h4> 
<h5><a id="431_JConsoleJava_590"></a>4.3.1 JConsole：Java监视与管理控制台</h5> 
<p>JConsole是将上述的各种命令行工具的结果可视化出来了。</p> 
<p><code>JConsole</code>使用方式：打开<code>bin</code>目录下的<code>JConsole.exe</code>，选择你要查看的程序即可。</p> 
<p>JConsole会展示如下内容：</p> 
<p>概述：</p> 
<p><img src="https://images2.imgbox.com/b4/b9/qiz74I3R_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>内存使用情况：</p> 
<p><img src="https://images2.imgbox.com/eb/92/sQ5Hndwz_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>线程使用情况：</p> 
<p><img src="https://images2.imgbox.com/7d/ef/NUL9Krx1_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>类加载情况：</p> 
<p><img src="https://images2.imgbox.com/88/dd/WxQvu7ll_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>虚拟机状况与参数：</p> 
<p><img src="https://images2.imgbox.com/29/e1/bKjr4Plf_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>MBean属性与执行MBean操作：</p> 
<p><img src="https://images2.imgbox.com/f3/5e/G3msXawp_o.png" alt="在这里插入图片描述" width="600"></p> 
<blockquote> 
 <p>MBean：Java中可以将对象注册成MBean，这样外部程序就可以通过JMX查看、修改该对象的属性，也可以执行该对象的方法。例如：上面图片中我们可以利用JConsole执行SpringApplication对象的shutdown方法</p> 
</blockquote> 
<h5><a id="432_VisualVM_627"></a>4.3.2 VisualVM：多合一故障处理工具</h5> 
<p>VisualVM是官方强大的运行监视和故障处理程序（上面能干的，它基本上都能干）。其支持插件，因此有无限可能。</p> 
<p>启动方式：执行jdk的<code>bin</code>目录下的<code>jvisualvm.exe</code>文件。进入后，再左侧选择你的Java程序。</p> 
<p>VisualVM的插件安装：选择<code>工具</code>-&gt;<code>插件</code>，然后在可用插件出选择要安装的插件即可。</p> 
<p><img src="https://images2.imgbox.com/cb/a4/HO9U65Jb_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>常用功能举例：</p> 
<p>Visual GC：查看GC情况，清晰的看到堆的每个区域的使用情况</p> 
<p><img src="https://images2.imgbox.com/4b/89/4P3WYWfh_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>监视：查看CPU、堆、类、线程的基本情况</p> 
<p><img src="https://images2.imgbox.com/ce/70/cveKavNY_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>线程：查看线程的运行情况</p> 
<p><img src="https://images2.imgbox.com/ab/62/zxVuieEf_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>其他常用：</p> 
<ul><li>Profiler：分析方法的CPU情况和内存情况</li><li>BTrace：动态增加调试代码。例如：生产报错，但是没加日志查不了。可以使用BTrace在不停程序的情况下，增加打印日志代码。</li></ul> 
<h3><a id="5__658"></a>第5章 调优案例分析与实战</h3> 
<h4><a id="51__660"></a>5.1 概述</h4> 
<p>无重点</p> 
<h4><a id="52__664"></a>5.2 案例分析</h4> 
<h5><a id="521__666"></a>5.2.1 高性能硬件上的程序部署策略</h5> 
<p>异常场景：网站15万PV/天 （PV=Page View，可以理解为请求量）。每隔十几分钟，网站就卡十几秒。</p> 
<p>机器情况：4个CPU，16GB内存，Java堆固定12GB</p> 
<p>经过排查后：</p> 
<ul><li>直接原因：① Full GC频繁，② 且Full GC消耗时间长（一次要十几秒）</li><li>根本原因：① 由于网站总是产生大对象，因为Eden区放不下，进而大对象直接进入老年代，导致老年代很快就满了，进而频繁引发Full GC。② 由于堆内存过大，因此一次Full GC消耗的时间较长。</li></ul> 
<p>解决方法：</p> 
<ul><li>Full GC频繁问题：优化代码，拆分大对象，或利用缓存等，避免大对象直接进入老年代。</li><li>Full GC时间长问题：采用逻辑集群。即 将程序部署多份，每份的堆内存都控制在一个较小的值（例如2G），避免一次Full GC时间过长。</li></ul> 
<h5><a id="522__683"></a>5.2.2 集群间同步导致的内存溢出</h5> 
<p>异常场景：程序是集群部署，隔一段时间就会内存溢出（OOM）。</p> 
<p>排查后发现：</p> 
<ul><li>原因：集群之间采用了JBossCache进行数据同步，而这个框架设计有缺陷，同步失败重试时会有大量对象驻留内存，最终导致内存不够用。</li></ul> 
<p>因此，我们在开发或排查问题时，也要考虑会不会存在大量对象释放不掉导致OOM的问题。</p> 
<h5><a id="523__694"></a>5.2.3 堆外内存导致的溢出错误</h5> 
<p>异常场景：系统经常产生OOM，但堆内存的各个区域都很稳定，并且有发现内存不足现象。</p> 
<p>排查后发现：</p> 
<ul><li>直接原因：是堆外内存不足导致的OOM，即Native方法产生的溢出（Native方法直接使用系统内存）。</li><li>根本原因：程序中用到了大量的NIO（NIO有大量的Native方法），该方法要不断的申请系统内存。而系统2G，给JVM分了1.6G，NIO只剩下0.4G可以用。而系统内存不够用时，JVM只能先抛出异常，然后再调用<code>System.gc()</code>，尝试让JVM去回收一下堆外内存。</li></ul> 
<p>解决方法：合理的调节JVM内存大小，给系统预留足够的内存。</p> 
<h5><a id="524__705"></a>5.2.4 外部命令导致系统缓慢</h5> 
<p>异常场景：系统CPU占用过高，但排查发现并不是Java程序占用高。</p> 
<p>排查后发现：</p> 
<ul><li>直接原因：占用CPU高的是<code>fork</code>系统调用。该调用是创建进程用的。</li><li>根本原因：代码中采用了<code>Runtime.getRuntime.exec()</code>方法执行shell脚本，且非常高频。因此导致高频的创建进程。</li></ul> 
<p>解决方案：降低这段代码频率，或采用其他的替代方案。总之，不要高频创建进程。</p> 
<p><code>Runtime.getRuntime.exec()</code>的执行逻辑：</p> 
<ol><li>首先克隆一个和当前虚拟机拥有一样环境变量的进程</li><li>使用该进程执行外部命令</li><li>最后退出这个进程</li></ol> 
<h5><a id="525_JVM_723"></a>5.2.5 服务器JVM进程崩溃</h5> 
<p>异常场景：Java程序总是异常崩溃（不是OOM，是直接崩掉了）</p> 
<p>排查后发现：</p> 
<ul><li>直接原因：程序不断创建线程，且线程一直处于等待状态，最终崩溃。</li><li>根本原因：远程调用响应过慢，导致线程等待，随着等待的线程越来越多，机器受不了了。</li></ul> 
<p>解决方案：远程调用增加超时时间，避免线程阻塞。或采用其他异步方案，例如MQ。</p> 
<h5><a id="526__734"></a>5.2.6 不恰当数据结构导致内存占用过大</h5> 
<p>异常场景：由于业务需要每10分钟加载一个80M的文件进行分析，导致分析期间Minor GC过于频繁，且时间较长。</p> 
<p>原因：分析文件期间，Eden区很快就被占满，但由于这些对象要用一段时间，导致还清理不掉，因此会出现频繁Minor GC。同时，分析文件时使用的是<code>HashMap&lt;Long, Long&gt;</code>，因为key, value都是Long，空间利用率过低（HashMap每个节点还有有其他数据去维护数据结构）。</p> 
<p>解决方案：① 调整JVM参数，让这些数据直接进入老年代（不推荐）。② 优化分析代码，使用空间利用率高的数据结构。</p> 
<h5><a id="527_Windows_742"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h5> 
<p>异常情况：一个简单的GUI程序，平时GC都很快，一最小化，GC就会耗时很久。</p> 
<p>根本原因：在windows程序被最小化时，该程序就改用虚拟内存了。</p> 
<p>解决方案：启动时增加<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>参数。</p> 
<h4><a id="53_Eclipse_751"></a>5.3 实战：Eclipse运行速度调优</h4> 
<p>无重点</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/09606fa654719111971b803e54f89b29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java AQS 核心数据结构-CLH 锁及优化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/628df68b16835d8bba56b216f519ad31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【读书笔记】深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>