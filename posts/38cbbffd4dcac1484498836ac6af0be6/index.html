<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于多反应堆的高并发服务器【C/C&#43;&#43;/Reactor】（上） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于多反应堆的高并发服务器【C/C&#43;&#43;/Reactor】（上）" />
<meta property="og:description" content="（一）初始化服务器端用于监听的套接字 Server.h #pragma once // 初始化监听的套接字 int initListenFd(unsigned short port); Server.c int initListenFd(unsigned short port) { // 1.创建监听的fd int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == -1) { perror(&#34;socket&#34;); return -1; } // 2.设置端口复用 int opt = 1; int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt)); if(ret == -1) { perror(&#34;setsockopt&#34;); return -1; } // 3.绑定 struct sockaddr_in addr; addr.sin_family=AF_INET; addr.sin_port=htons(port); addr.sin_addr.s_addr=INADDR_ANY; ret = bind(lfd,(struct sockaddr*)&amp;addr,sizeof(addr)); if(ret == -1) { perror(&#34;bind&#34;); return -1; } // 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/38cbbffd4dcac1484498836ac6af0be6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-21T23:35:41+08:00" />
<meta property="article:modified_time" content="2023-12-21T23:35:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于多反应堆的高并发服务器【C/C&#43;&#43;/Reactor】（上）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>（一）初始化服务器端用于监听的套接字</h4> 
<ul><li>Server.h</li></ul> 
<pre><code class="language-cpp">#pragma once 
// 初始化监听的套接字
int initListenFd(unsigned short port);</code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">int initListenFd(unsigned short port) {
    // 1.创建监听的fd
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1) {
        perror("socket");
        return -1;
    }
    // 2.设置端口复用
    int opt = 1;
    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));
    if(ret == -1) {
        perror("setsockopt");
        return -1;
    }
    // 3.绑定
    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_port=htons(port);
    addr.sin_addr.s_addr=INADDR_ANY;
    ret = bind(lfd,(struct sockaddr*)&amp;addr,sizeof(addr));
    if(ret == -1) {
        perror("bind");
        return -1;
    }
    // 4.设置监听
    ret = listen(lfd,128);
    if(ret == -1) {
        perror("listen");
        return -1;
    }
    // 返回fd
    return lfd;
}</code></pre> 
<p style="text-align:center;"><strong>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;知识回顾&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</strong></p> 
<p><strong>1. socket </strong></p> 
<pre><code class="language-cpp">// 套接字通信分两部分：
    - 服务器端：被动接受连接，一般不会主动发起连接
    - 客户端：主动向服务器发起连接</code></pre> 
<p><strong> 2.字节序转换函数</strong></p> 
<pre><code class="language-cpp">    当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。
    解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端
    知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定
    是否对接收到的数据进行转换（小端机转换，大端机不转换）。
    
    网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统
    等无关，从而 可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端
    排序方式。
    
    BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的
    转换函数： htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</code></pre> 
<ul><li><strong>h </strong>- <strong>host </strong>主机，主机字节序</li><li><strong>to </strong>- 转换成什么</li><li><strong>n </strong>- <strong>network </strong>网络字节序</li><li><strong>s</strong> - <strong>short</strong> <strong>unsigned short</strong></li><li><strong>l </strong>- <strong>long unsigned int</strong></li></ul> 
<pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;
// 转换端口
uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序
uint16_t ntohs(uint16_t netshort); // 网络字节序 - 主机字节序
// 转IP
uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序
uint32_t ntohl(uint32_t netlong); //  网络字节序 - 主机字节序</code></pre> 
<p><strong>3.socket 地址</strong></p> 
<pre><code class="language-cpp">socket 地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中
需要使用到这个socket地址。客户端 -&gt; 服务端（IP，Port）</code></pre> 
<pre><code class="language-cpp">#include &lt;netinet/in.h&gt;
struct sockaddr_in
{
    sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) */
    in_port_t sin_port; /* Port number. */
    struct in_addr sin_addr; /* Internet address. */
    /* Pad to size of `struct sockaddr'. */
    unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -
                sizeof (in_port_t) - sizeof (struct in_addr)];
};
struct in_addr
{
    in_addr_t s_addr;
};</code></pre> 
<p><strong>4. IP地址转换（字符串</strong><strong>ip-</strong><strong>整数 ，主机、网络 </strong><strong>字节序的转换）</strong></p> 
<p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用 十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字 符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p> 
<pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;
in_addr_t inet_addr(const char *cp);
int inet_aton(const char *cp, struct in_addr *inp);
char *inet_ntoa(struct in_addr in);</code></pre> 
<p>下面这对更新的函数也能完成前面 <strong>3 </strong>个函数同样的功能，并且它们同时适用 <strong>IPv4 </strong>地址和 <strong>IPv6 </strong>地址：</p> 
<pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;
// p:点分十进制的IP字符串，n:表示network，网络字节序的整数
int inet_pton(int af, const char *src, void *dst);
    af:地址族： AF_INET AF_INET6
    src:需要转换的点分十进制的IP字符串
    dst:转换后的结果保存在这个里面
 
// 将网络字节序的整数，转换成点分十进制的IP地址字符串
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
    af:地址族： AF_INET AF_INET6
    src: 要转换的ip的整数的地址
    dst: 转换成IP地址字符串保存的地方
    size：第三个参数的大小（数组的大小）
    返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</code></pre> 
<h4><strong>5. TCP</strong><strong>通信流程</strong></h4> 
<pre><code class="language-cpp">// TCP 和 UDP -&gt; 传输层的协议
UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠
TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输
 
 
                   UDP                                     TCP
是否创建连接       无连接                                  面向连接
是否可靠           不可靠                                   可靠的
连接的对象个数   一对一、一对多、多对一、多对多              支持一对一
传输的方式         面向数据报                              面向字节流
首部开销           8个字节                               最少20个字节
适用场景        实时应用（视频会议，直播）           可靠性高的应用（文件传输）</code></pre> 
<p class="img-center"><img alt="" height="715" src="https://images2.imgbox.com/6d/4f/x2DYXbgA_o.png" width="533"></p> 
<pre><code class="language-cpp">// TCP 通信的流程
// 服务器端 （被动接受连接的角色）
1. 创建一个用于监听的套接字
    - 监听：监听有客户端的连接
    - 套接字：这个套接字其实就是一个文件描述符
2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）
    - 客户端连接服务器的时候使用的就是这个IP和端口
3. 设置监听，监听的fd开始工作
4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字
（fd）
5. 通信
    - 接收数据
    - 发送数据
6. 通信结束，断开连接</code></pre> 
<pre><code class="language-cpp">// 客户端
1. 创建一个用于通信的套接字（fd）
2. 连接服务器，需要指定连接的服务器的 IP 和 端口
3. 连接成功了，客户端可以直接和服务器通信
    - 接收数据
    - 发送数据
4. 通信结束，断开连接</code></pre> 
<h4><strong>6. </strong><strong>套接字函数</strong></h4> 
<pre><code class="language-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略
int socket(int domain, int type, int protocol);
    - 功能：创建一个套接字
    - 参数：
        - domain: 协议族
            AF_INET : ipv4
            AF_INET6 : ipv6
            AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）
        - type: 通信过程中使用的协议类型
            SOCK_STREAM : 流式协议
            SOCK_DGRAM : 报式协议
    - protocol : 具体的一个协议。一般写0
            - SOCK_STREAM : 流式协议默认使用 TCP
            - SOCK_DGRAM : 报式协议默认使用 UDP
    - 返回值：
        - 成功：返回文件描述符，操作的就是内核缓冲区。
        - 失败：-1
 
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命
名
	- 功能：绑定，将fd 和本地的IP + 端口进行绑定
	- 参数：
		- sockfd : 通过socket函数得到的文件描述符
		- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息
		- addrlen : 第二个参数结构体占的内存大小
		
int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn
	- 功能：监听这个socket上的连接
	- 参数：
		- sockfd : 通过socket()函数得到的文件描述符
		- backlog : 未连接的和已经连接的和的最大值， 5
		
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
	- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接
	- 参数：
		- sockfd : 用于监听的文件描述符
		- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）
		- addrlen : 指定第二个参数的对应的内存大小
	- 返回值：
		- 成功 ：用于通信的文件描述符
		- 失败 ： -1
		
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	- 功能： 客户端连接服务器
	- 参数：
		- sockfd : 用于通信的文件描述符
		- addr : 客户端要连接的服务器的地址信息
		- addrlen : 第二个参数的内存大小
	- 返回值：成功 0， 失败 -1
 
//读写数据
ssize_t write(int fd, const void *buf, size_t count); // 写数据
ssize_t read(int fd, void *buf, size_t count); // 读数据</code></pre> 
<p><strong>7.SIGCHLD信号</strong></p> 
<p><strong>SIGCHLD</strong>的产生条件：</p> 
<ul><li>子进程终止</li><li>子进程接收到<strong>SIGSTOP</strong>信号停止时</li><li>子进程处于停止状态，接收到<strong>SIGCONT</strong>后唤醒</li></ul> 
<p>注意：通过<strong>signal(SIGCHLD, SIG_IGN)</strong>通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：<strong>signal(SIGCHLD,SIG_IGN);</strong>表示父进程忽略<strong>SIGCHLD</strong>信号，该信号是子进程退出的时候向父进程发送的。</p> 
<h4>（二）<strong>epoll </strong>工作模型的雏形</h4> 
<ul><li>Server.h</li></ul> 
<pre><code class="language-cpp">// 启动epoll
int epollRun(int lfd);</code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">int epollRun(int lfd) {
    // 1.创建epoll实例
    int epfd = epoll_create(1);
    if(epfd == -1) {
        perror("epoll_create");
        return -1;
    }
    // 2.添加监听fd lfd上树 对于监听的描述符来说只需要看一下有没有新的客户端连接
    struct epoll_event ev;
    ev.data.fd = lfd;
    ev.events = EPOLLIN;// 委托epoll(内核)帮我们检测lfd的读事件
    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);
    if(ret == -1) {
        perror("epoll_ctl");
        return -1;
    }
    // 3.检测
    struct epoll_event evs[1024];
    // int size = sizeof(evs)/sizeof(epoll_event);
    int size = sizeof(evs)/sizeof(evs[0]);
    while(1) {
        int num = epoll_wait(epfd,evs,size,-1);
        if(num == -1) {
            perror("epoll_wait");
            return -1;
        }
        for(int i=0;i&lt;num;++i) {
            int fd = evs[i].data.fd;
            if(fd == lfd) {
                // 建立新连接 accept
                acceptClient(lfd,epfd);
            }else{
                // 主要是接收对端的数据
                recvHttpRequest(fd,epfd);
            }

        }
    }
    return 0;
}</code></pre> 
<h4><strong>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;知识回顾&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</strong></h4> 
<p id="articleContentId"><strong>1.epoll() 多路复用 和 两种工作模式</strong></p> 
<p><strong>epoll</strong>是<strong>Linux内核</strong>中的一个<strong>事件驱动I/O机制</strong>，用于处理<strong>多个文件描述符</strong>上的事件。它是一个高效且强大的 <strong>I/O 多路复用工具</strong>，可以用于处理大量文件描述符的 <strong>I/O操作</strong>。<strong>epoll </strong>的主要优点是它只占用较少的资源，并且比传统的 <strong>select </strong>和 <strong>poll </strong>更易于使用。</p> 
<p><strong>epoll</strong>的工作原理是通过一个事件表来跟踪所有需要监控的文件描述符，当某个文件描述符上有事件发生时，<strong>epoll</strong>会通知程序去处理这些事件。这种方式可以确保程序在等待某个文件描述符上有事件发生时只占用较少的资源，而不是像<strong>select</strong>和<strong>poll</strong>那样整个程序</p> 
<p><strong>----来自CodeGeex</strong></p> 
<p><strong>2.epoll API介绍</strong></p> 
<pre><code class="language-cpp">typedef union epoll_data {
	void *ptr;
	int fd;
	uint32_t u32;
	uint64_t u64;
} epoll_data_t;
 
struct epoll_event {
	uint32_t events; /* Epoll events */
	epoll_data_t data; /* User data variable */
};
 
常见的Epoll检测事件：
	- EPOLLIN
	- EPOLLOUT
	- EPOLLERR
	
// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
	- 参数：
		- epfd : epoll实例对应的文件描述符
		- op : 要进行什么操作
				EPOLL_CTL_ADD: 添加
				EPOLL_CTL_MOD: 修改
				EPOLL_CTL_DEL: 删除
		- fd : 要检测的文件描述符
		- event : 检测文件描述符什么事情
 
// 检测函数----检测epoll树中是否有就绪的文件描述符
// 创建了epfd,设置好某个fd上需要检测事件并将该fd绑定到epfd上去后，就可以调用epoll_wait
// 检测事件了
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
	- 参数：
		- epfd : epoll实例对应的文件描述符
		- events : 传出参数，保存了发送了变化的文件描述符的信息
		- maxevents : 第二个参数结构体数组的大小
		- timeout : 阻塞时间
			- 0 : 不阻塞
			- -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞
			- &gt; 0 : 阻塞的时长（毫秒）
	- 返回值：
		- 成功，返回发送变化的文件描述符的个数 &gt; 0
		- 失败 -1
 
// 创建epoll实例，通过一棵红黑树管理待检测集合
// 参数 size 从 Linux 2.6.8 以后就不再使用，但是必须设置一个大于 0 的值。epoll_create 函数调用成功返回一个非负值的 epollfd，调用失败返回 -1。
int epoll_create(int size);</code></pre> 
<pre><code class="language-cpp">&gt;&gt;epoll_wait 缺点：
    ① epoll_wait 调用之后，需要将所有fd的event参数重新设置一遍，
      如果fd比较多的话，会比较消耗性能。----来自CodeGeeX
 
&gt;&gt;epoll_wait 优点：
    ① epoll_wait 调用之后，直接在event参数中拿到所有有事件就绪的fd,直接处理即可。
    ② 一般在fd数量比较多，但某段时间内，就绪事件fd数量较少的情况下，epoll_wait才会
    体现出它的优势，也就是说socket连接数量较大时而活跃连接较少时epoll模型更高效。</code></pre> 
<p><img alt="" height="733" src="https://images2.imgbox.com/03/97/LoiWoKiv_o.png" width="1200"></p> 
<pre><code class="language-cpp">// epoll 的使用
// 操作步骤
// 在服务器使用 epoll 进行 IO 多路转接的操作步骤如下:
    1.创建监听的套接字
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
 
    2.设置端口复用（可选）
    int opt = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
 
    3.使用本地的IP与端口和监听的套接字进行绑定
    int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr));
 
    4.给监听的套接字设置监听
    listen(lfd, 128);
 
    5.创建 epoll 实例
    int epfd = epoll_create(100);
 
    6.将用于监听的套接字添加到 epoll 实例中
    struct epoll_event ev;
    ev.events = EPOLLIN; //检测lfd读缓冲区是否有数据
    ev.data.fd = lfd;
    int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);
 
    接着创建一个数组，用于存储epoll_wait()返回的文件描述符
    struct epoll_event evs[1024];
 
    7.检测添加到epoll实例中的文件描述符是否已经就绪，并将这些已就绪的文件描述符进行处理
    int num = epoll_wait(epfd, evs, size, -1);
 
    ① 如果监听的是文件描述符，和新客户端建立连接，将得到的文件描述符添加到epoll实例中
    int cfd = accept(curfd,NULL,NULL);
    ev.events = EPOLLIN;
    ev.data.fd = cfd;
 
    新得到的文件描述符添加到epoll模型中，下一轮循环的时候就可以被检测了
    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);
 
    ② 如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从epoll实例中删除
    int len = recv(curfd,buf,sizeof(buf),0);
    if(len == 0) {
        // 将这个文件描述符从epoll实例中删除
        epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL);
        close(curfd);
    }else if(len &gt; 0) {
        send(curfd,buf,len,0);
    }
 
    8.重复第 7 步的操作</code></pre> 
<p><img alt="" height="872" src="https://images2.imgbox.com/14/96/GDZedyBv_o.png" width="1200"></p> 
<h5><strong>3.epoll 的两种工作模式 </strong></h5> 
<pre><code class="language-cpp">Epoll 的工作模式：
	LT 模式 （水平触发）
		假设委托内核检测读事件 -&gt; 检测fd的读缓冲区
			读缓冲区有数据 - &gt; epoll检测到了会给用户通知
				a.用户不读数据，数据一直在缓冲区，epoll 会一直通知
				b.用户只读了一部分数据，epoll会通知
				c.缓冲区的数据读完了，不通知
	
	LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这
	种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操
	作。如果你不作任何操作，内核还是会继续通知你的。
 
	ET 模式（边沿触发）
		假设委托内核检测读事件 -&gt; 检测fd的读缓冲区
			读缓冲区有数据 - &gt; epoll检测到了会给用户通知
				a.用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了
				b.用户只读了一部分数据，epoll不通知
				c.缓冲区的数据读完了，不通知
 
	ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述
	符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，
	并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述
	符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成
	未就绪），内核不会发送更多的通知（only once）。
	
	ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll
	工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写
	操作把处理多个文件描述符的任务饿死。
 
 
综上所述：epoll的边沿模式下 epoll_wait检测到文件描述符有新事件才会通知，
如果不是新的事情就不通知，通知的次数比水平模式少，效率比水平模式高。</code></pre> 
<p> <strong>【注意】 ET模式需要配合循环+非阻塞</strong></p> 
<pre><code class="language-cpp">&gt;&gt; epoll在边沿模式下非阻塞接收数据
    循环接收数据的处理方式：对于每次接收的buffer多小都不重要了，只不过我们需要多接收几次数据。
    效率相对来说低一些；如果说buffer稍微大一点，接收数据的次数就少一些，效率相对来说高一些；
    可以把recv写到一个while循环里，通过while循环，每次读取5个字节，直到把客户端发过来的数据全部都读到本地。
    【思考】这种方式的弊端在哪里？
    【思考】进行套接字通信时阻塞的还是非阻塞的？
 
    【回答】很显然默认情况下进行套接字通信，这个处理流程是阻塞的。如果是阻塞的，
    当这个服务器端循环接收客户端发过来的数据，假设客户端发来了100个字节的数据，
    在服务端接收了20次，就把客户端发过来的数据全部读到本地了，但是在做第21次读
    数据的时候，这个recv它还能读到数据吗？
    没有了，也就是说这个文件描述符对应的读缓冲区里边是空的。如果说这个文件描述符
    对应的读缓冲区里边是空的。这个recv再去接收数据的话，服务器端的线程或者服务器
    端的进程它就阻塞了。如果这个线程/进程阻塞了，就不能干别的事情了。如果说写的
    这个程序里边就是单线程或者单进程的程序，在这里阻塞了，就不能够去做其他的事情
    了，整个程序就停止在这里了。
 
    【问题】如何让while循环中的break起作用？
        修改文件描述符为非阻塞，而不是修改read/recv函数，因为这函数时基于文件描述符
        去进行数据的接收操作，所以说需要修改一下这个文件描述符的属性，把这个文件描述
        符的默认阻塞属性修改为非阻塞属性。再次调用recv/read函数的时候，它们也就不会阻塞了
 
    【思考】如何把这个文件描述符修改为非阻塞属性？
        解决阻塞问题，需要将套接字默认的阻塞行为修改为非阻塞，需要使用fcntl()函数进行处理
 
        // 设置完成之后，读写都变成了非阻塞模式
        int flag = fcntl(cfd,F_GETFL);
        flag |= O_NOBLOCK;
        fcntl(cfd,F_SETFL,flag);  </code></pre> 
<h4><strong>（三）</strong><strong>和客户端建立新连接</strong></h4> 
<ul><li>Server.h</li></ul> 
<pre><code class="language-cpp">// 和客户端建立连接
int acceptClient(int lfd,int epfd);</code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">// 接受新连接，把得到的新的文件描述符cfd也添加到epoll树上
int acceptClient(int lfd,int epfd) {
    // 1.创建一个套接字(建立连接)
    int cfd = accept(lfd,NULL,NULL);
    if(cfd == -1) {
        perror("accept");
        return -1;
    }
    // 2.添加到epoll中
    int flag = fcntl(cfd,F_GETFL);// 设置非阻塞
    flag |= O_NONBLOCK;
    fcntl(cfd,F_SETFL,flag);

    // 3.cfd 添加到epoll中
    struct epoll_event ev;
    ev.data.fd=cfd;
    ev.events=EPOLLIN | EPOLLET;
    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);
    if(ret == -1) {
        perror("epoll_ctl");
        return -1;
    }
    return 0;
}</code></pre> 
<h4>（四）接收客户端的http请求消息</h4> 
<p><a class="has-card" href="https://heheda.blog.csdn.net/article/details/132695415" rel="nofollow" title="WebServer 解析HTTP 请求报文-CSDN博客"><span class="link-card-box"><span class="link-title">WebServer 解析HTTP 请求报文-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/b5/00/FxHMfpul_o.png" alt="icon-default.png?t=N7T8">https://heheda.blog.csdn.net/article/details/132695415</span></span></a><a class="has-card" href="https://heheda.blog.csdn.net/article/details/132746046" rel="nofollow" title="WebServer 解析HTTP 响应报文-CSDN博客"><span class="link-card-box"><span class="link-title">WebServer 解析HTTP 响应报文-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/cc/63/S6hZu4DX_o.png" alt="icon-default.png?t=N7T8">https://heheda.blog.csdn.net/article/details/132746046</span></span></a></p> 
<ul><li>Server.h</li></ul> 
<pre><code class="language-cpp">// 主要是接收对端的数据
int recvHttpRequest(int cfd,int epfd);</code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">int recvHttpRequest(int cfd,int epfd) {
    // 有了存储数据的内存之后，接下来就是读数据
    // 注意：前面已经把用于通信的文件描述符的事件改成了边缘非阻塞
    // 如果是边缘模式epoll检测到文件描述符对应的读事件之后，只会给我们通知一次
    // 因此需要得到这个通知之后，
    printf("开始接收数据了...\n");
    int len = 0,total = 0;
    char buf[4096] = {0};
    char tmp[1024] = {0};
    while((len = recv(cfd,tmp,sizeof tmp,0))&gt;0) {
        if(total + len &lt; sizeof buf)
            memcpy(buf+total,tmp,len);
        total += len;
    }
    
    // 判断数据是否接收完毕
    if(len == -1 &amp;&amp; errno == EAGAIN) {
        // 说明服务器已经把客户端发过来的请求数据接收完毕了
        // 解析请求行
        char* pt = strstr(buf,"\r\n");
        int reqLen = pt - buf;
        buf[reqLen] = '\0';
        parseRequestLine(buf,cfd);
    }
    else if(len == 0) {
        // 说明客户端断开了连接
        int ret = epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);
        if(ret == -1) {
            perror("epoll_ctl");
            return -1;
        }
        close(cfd);
    }else{
        perror("recv");
    }
    return 0;
}</code></pre> 
<h4>（五）解析请求行</h4> 
<ul><li>Server.h </li></ul> 
<pre><code class="language-cpp">// 解析请求行
int parseRequestLine(const char* line,int cfd);</code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">int parseRequestLine(const char* line,int cfd){
    // 解析请求行 
    // 请求行格式：GET /index.html HTT   -------------------P/1.1
    // 解析出请求方法、请求路径、协议版本
    // 请求方法：GET
    // 请求路径：/index.html
    // 协议版本：HTTP/1.1
    // 请求方法GET、请求路径/index.html、协议版本HTTP/1.1
    // 请求行长度：GET /index.html HTTP/1.1
    // 请求行长度：29
    char method[12];
    char path[1024];
    sscanf(line,"%[^ ] %[^ ]",method,path);
    printf("method: %s,path: %s\n",method,path);
    if(strcasecmp(method,"get") != 0) {
        return -1;
    }
    decodeMsg(path,path);
    // 处理客户端请求的静态资源(目录或者文件)
    char* file = NULL; 
    if(strcmp(path,"/") == 0) {
        file = "./";
    }else {
        file = path+1;
    }
    // 获取文件属性
    struct stat st;
    int ret = stat(file,&amp;st);
    if(ret == -1) {
        // 文件不存在 -- 回复404
        sendHeadMsg(cfd,404,"Not Found",getFileType(".html"),-1);
        sendFile("404.html",cfd);
        return 0;
    }
    // 判断文件类型
    if(S_ISDIR(st.st_mode)) {
        // 把这个目录中的内容发送给客户端
        sendHeadMsg(cfd,200,"OK",getFileType(".html"),-1);
        sendDir(file,cfd);
    }
    else {
        // 把文件的内容发送给客户端
        sendHeadMsg(cfd,200,"OK",getFileType(file),st.st_size);
        sendFile(file,cfd);
    }
    return 0;
}</code></pre> 
<h4>（六）组织Http响应的数据块头</h4> 
<ul><li>Server.h  </li></ul> 
<pre><code class="language-cpp">// 发送响应头(状态行 + 响应头)
int sendHeadMsg(int cfd,int status,const char* descr,const char* type,int length);
const char* getFileType(const char* name);</code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">int sendHeadMsg(int cfd,int status,const char* descr,const char* type,int length) {
    // 状态行
    char buf[4096] = {0};
    sprintf(buf,"http/1.1 %d %s\r\n",status,descr);
    // 响应头
    sprintf(buf+strlen(buf),"content-type: %s\r\n",type);
    sprintf(buf+strlen(buf),"content-length: %d\r\n\r\n",length);
    send(cfd,buf,strlen(buf),0);
    return 0;
}

const char* getFileType(const char* name) {
    // a.jpg a.mp4 a.html
    // 自右向左查找 '.' 字符，如不存在返回NULL
    const char* dot = strrchr(name,'.');
    if(dot == NULL) 
        return "text/plain; charset=utf-8";//纯文本
    if(strcmp(dot,".html") == 0 || strcmp(dot,".htm") == 0) 
        return "text/html; charset=utf-8";
    if(strcmp(dot,".jpg")==0 || strcmp(dot,".jpeg")==0) 
        return "image/jpeg";
    if(strcmp(dot,".gif")==0)
        return "image/gif";
    if(strcmp(dot,".png")==0)
        return "image/png";
    if(strcmp(dot,".css")==0) 
        return "text/css";
    if(strcmp(dot,".au")==0)
        return "audio/basic";
    if(strcmp(dot,".wav")==0)
        return "audio/wav";
    if(strcmp(dot,".avi")==0)
        return "video/x-msvideo";
    if(strcmp(dot,".mov")==0 || strcmp(dot,".qt")==0)
        return "video/quicktime";
    if(strcmp(dot,".mpeg")==0 || strcmp(dot,".mpe")==0)
        return "video/mpeg";
    if(strcmp(dot,".vrml")==0 || strcmp(dot,".wrl")==0)
        return "model/vrml";
    if(strcmp(dot,".midi")==0 || strcmp(dot,".mid")==0)
        return "audio/midi";
    if(strcmp(dot,".mp3")==0)
        return "audio/mpeg";
    if(strcmp(dot,".ogg") == 0) 
        return "application/ogg";
    if(strcmp(dot,".pac") == 0)
        return "application/x-ns-proxy-autoconfig";
    return "text/plain; charset=utf-8";//纯文本
}</code></pre> 
<h4>（七）发送文件的两种方式</h4> 
<ul><li>Server.h  </li></ul> 
<pre><code class="language-cpp">// 发送文件
int sendFile(const char* fileName,int cfd);</code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">int sendFile(const char* fileName,int cfd) {
    // 打开文件
    int fd = open(fileName,O_RDONLY);
    // assert(fd &gt; 0);
    if(fd == -1){
        perror("open");
        return -1;
    }
#if 0
    while (1)
    {
        char buf[1024];
        int len = read(fd,buf,sizeof(buf));
        if(len &gt; 0) {
            send(cfd,buf,len,0);
            usleep(10); // 这非常重要
        }
        else if(len == 0) {
            break;
        }
        else{
            perror("read");
        }
    }
#else
    // 把文件内容发送给客户端
    // int size = lseek(fd,0,SEEK_END);// 文件指针移动到了尾部
    // lseek(fd,0,SEEK_SET);
    // int ret = sendfile(cfd,fd,NULL,size);
    // off_t offset = 0;
    // while (offset &lt; size){
    //     int ret = sendfile(cfd,fd,&amp;offset,size- offset);
    //     printf("ret value: %d\n",ret);
    //     if (ret == -1 &amp;&amp; errno == EAGAIN)
    //     {
    //         printf("没数据...\n");
    //     }
    // }
    struct stat st;
    fstat(fd,&amp;st);
    off_t offset = 0;
    while (offset &lt; st.st_size){
        int ret = sendfile(cfd,fd,&amp;offset,st.st_size- offset);
        printf("ret value: %d\n",ret);
        if (ret == -1 &amp;&amp; errno == EAGAIN)
        {
            printf("没数据...\n");
        }
    }
#endif
    close(fd);
    return 0;
}</code></pre> 
<h4>（八）发送目录</h4> 
<ul><li>Server.h</li></ul> 
<pre><code class="language-cpp">// 发送目录
int sendDir(const char* dirName,int cfd); </code></pre> 
<ul><li>Server.c</li></ul> 
<pre><code class="language-cpp">int sendDir(const char* dirName,int cfd) {
    char buf[4096] = {0};
    sprintf(buf,"&lt;html&gt;&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;",dirName);
    struct dirent** nameList;
    int num = scandir(dirName,&amp;nameList,NULL,alphasort);
    for(int i=0;i&lt;num;i++) {
        // 取出文件名 nameList 指向的是一个指针数组 struct dirent* tmp[]
        char* name = nameList[i]-&gt;d_name;
        struct stat st;
        char subPath[1024] = {0};
        sprintf(subPath,"%s/%s",dirName,name);
        stat(subPath,&amp;st);
        if(S_ISDIR(st.st_mode)) {
            // 从当前目录跳到子目录里边，/
            sprintf(buf+strlen(buf),
                "&lt;tr&gt;&lt;td&gt;&lt;a href=\"%s/\"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;",
                name,name,st.st_size);
        }else{
            sprintf(buf+strlen(buf),
                "&lt;tr&gt;&lt;td&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;",
                name,name,st.st_size);
        }
        send(cfd,buf,strlen(buf),0);
        memset(buf,0,sizeof(buf));
        free(nameList[i]); 
    }
    sprintf(buf,"&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;");
    send(cfd,buf,strlen(buf),0);
    free(nameList);
    return 0;
}
/*
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
*/</code></pre> 
<h4>（八）解决浏览器无法访问带特殊字符的文件得到问题</h4> 
<ul><li>Server.h</li></ul> 
<pre><code class="language-cpp">int hexToDec(char c);
void decodeMsg(char* to,char* from);</code></pre> 
<ul><li>Server.c </li></ul> 
<pre><code class="language-cpp">// 将字符转换为整型数
int hexToDec(char c){
    if (c &gt;= '0' &amp;&amp; c &lt;= '9')
        return c - '0';
    if (c &gt;= 'a' &amp;&amp; c &lt;= 'f')
        return c - 'a' + 10;
    if (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
        return c - 'A' + 10;
    return 0;
}

// 解码
// to 存储解码之后的数据, 传出参数, from被解码的数据, 传入参数
void decodeMsg(char* to,char* from) {
    for(;*from!='\0';++to,++from) {
        // isxdigit -&gt; 判断字符是不是16进制格式, 取值在 0-f
        // Linux%E5%86%85%E6%A0%B8.jpg
        if(*from == '%' &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])){
            // 将16进制的数 -&gt; 十进制 将这个数值赋值给了字符 int -&gt; char
            // B2 == 178
            // 将3个字符, 变成了一个字符, 这个字符就是原始数据
            // *to = (hexToDec(from[1]) * 16) + hexToDec(from[2]);
            *to = (hexToDec(from[1]) &lt;&lt; 4) + hexToDec(from[2]);

            // 跳过 from[1] 和 from[2] ，因此在当前循环中已经处理过了
            from += 2;
        }else{
            // 字符拷贝，赋值
            *to = *from;
        }
    }
    *to = '\0';
}</code></pre> 
<p>完整代码：</p> 
<p>main.c</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "Server.h"
#include "Server.c"
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc,char* argv[]) {
    if(argc &lt; 3) {
        printf("./a.out port path\n");
        return -1;
    }
    unsigned short port = atoi(argv[1]);
    // 切换服务器的工作路径
    chdir(argv[2]);
    // 初始化用于监听的套接字
    int lfd = initListenFd(port);
    // 启动服务器程序
    epollRun(lfd);
    return  0;
}</code></pre> 
<p>Server.c</p> 
<pre><code class="language-cpp">#include "Server.h"
#include &lt;arpa/inet.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;strings.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/sendfile.h&gt;
#include &lt;dirent.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
int initListenFd(unsigned short port) {
    // 1.创建监听的fd
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1) {
        perror("socket");
        return -1;
    }
    // 2.设置端口复用
    int opt = 1;
    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));
    if(ret == -1) {
        perror("setsockopt");
        return -1;
    }
    // 3.绑定
    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_port=htons(port);
    addr.sin_addr.s_addr=INADDR_ANY;
    ret = bind(lfd,(struct sockaddr*)&amp;addr,sizeof(addr));
    if(ret == -1) {
        perror("bind");
        return -1;
    }
    // 4.设置监听
    ret = listen(lfd,128);
    if(ret == -1) {
        perror("listen");
        return -1;
    }
    // 返回fd
    return lfd;
}

int epollRun(int lfd) {
    // 1.创建epoll实例
    int epfd = epoll_create(1);
    if(epfd == -1) {
        perror("epoll_create");
        return -1;
    }
    // 2.添加监听fd lfd上树 对于监听的描述符来说只需要看一下有没有新的客户端连接
    struct epoll_event ev;
    ev.data.fd = lfd;
    ev.events = EPOLLIN;// 委托epoll(内核)帮我们检测lfd的读事件
    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);
    if(ret == -1) {
        perror("epoll_ctl");
        return -1;
    }
    // 3.检测
    struct epoll_event evs[1024];
    // int size = sizeof(evs)/sizeof(epoll_event);
    int size = sizeof(evs)/sizeof(evs[0]);
    while(1) {
        int num = epoll_wait(epfd,evs,size,-1);
        if(num == -1) {
            perror("epoll_wait");
            return -1;
        }
        for(int i=0;i&lt;num;++i) {
            int fd = evs[i].data.fd;
            if(fd == lfd) {
                // 建立新连接 accept
                acceptClient(lfd,epfd);
            }else{
                // 主要是接收对端的数据
                recvHttpRequest(fd,epfd);
            }

        }
    }
    return 0;
}

// 接受新连接，把得到的新的文件描述符cfd也添加到epoll树上
int acceptClient(int lfd,int epfd) {
    // 1.创建一个套接字(建立连接)
    int cfd = accept(lfd,NULL,NULL);
    if(cfd == -1) {
        perror("accept");
        return -1;
    }
    // 2.添加到epoll中
    int flag = fcntl(cfd,F_GETFL);// 设置非阻塞
    flag |= O_NONBLOCK;
    fcntl(cfd,F_SETFL,flag);

    // 3.cfd 添加到epoll中
    struct epoll_event ev;
    ev.data.fd=cfd;
    ev.events=EPOLLIN | EPOLLET;
    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);
    if(ret == -1) {
        perror("epoll_ctl");
        return -1;
    }
    return 0;
}

int recvHttpRequest(int cfd,int epfd) {
    // 有了存储数据的内存之后，接下来就是读数据
    // 注意：前面已经把用于通信的文件描述符的事件改成了边缘非阻塞
    // 如果是边缘模式epoll检测到文件描述符对应的读事件之后，只会给我们通知一次
    // 因此需要得到这个通知之后，
    printf("开始接收数据了...\n");
    int len = 0,total = 0;
    char buf[4096] = {0};
    char tmp[1024] = {0};
    while((len = recv(cfd,tmp,sizeof tmp,0))&gt;0) {
        if(total + len &lt; sizeof buf)
            memcpy(buf+total,tmp,len);
        total += len;
    }
    
    // 判断数据是否接收完毕
    if(len == -1 &amp;&amp; errno == EAGAIN) {
        // 说明服务器已经把客户端发过来的请求数据接收完毕了
        // 解析请求行
        char* pt = strstr(buf,"\r\n");
        int reqLen = pt - buf;
        buf[reqLen] = '\0';
        parseRequestLine(buf,cfd);
    }
    else if(len == 0) {
        // 说明客户端断开了连接
        int ret = epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);
        if(ret == -1) {
            perror("epoll_ctl");
            return -1;
        }
        close(cfd);
    }else{
        perror("recv");
    }
    return 0;
}
int parseRequestLine(const char* line,int cfd){
    // 解析请求行 
    // 请求行格式：GET /index.html HTT   -------------------P/1.1
    // 解析出请求方法、请求路径、协议版本
    // 请求方法：GET
    // 请求路径：/index.html
    // 协议版本：HTTP/1.1
    // 请求方法GET、请求路径/index.html、协议版本HTTP/1.1
    // 请求行长度：GET /index.html HTTP/1.1
    // 请求行长度：29
    char method[12];
    char path[1024];
    sscanf(line,"%[^ ] %[^ ]",method,path);
    printf("method: %s,path: %s\n",method,path);
    if(strcasecmp(method,"get") != 0) {
        return -1;
    }
    decodeMsg(path,path);
    // 处理客户端请求的静态资源(目录或者文件)
    char* file = NULL; 
    if(strcmp(path,"/") == 0) {
        file = "./";
    }else {
        file = path+1;
    }
    // 获取文件属性
    struct stat st;
    int ret = stat(file,&amp;st);
    if(ret == -1) {
        // 文件不存在 -- 回复404
        sendHeadMsg(cfd,404,"Not Found",getFileType(".html"),-1);
        sendFile("404.html",cfd);
        return 0;
    }
    // 判断文件类型
    if(S_ISDIR(st.st_mode)) {
        // 把这个目录中的内容发送给客户端
        sendHeadMsg(cfd,200,"OK",getFileType(".html"),-1);
        sendDir(file,cfd);
    }
    else {
        // 把文件的内容发送给客户端
        sendHeadMsg(cfd,200,"OK",getFileType(file),st.st_size);
        sendFile(file,cfd);
    }
    return 0;
}

int sendFile(const char* fileName,int cfd) {
    // 打开文件
    int fd = open(fileName,O_RDONLY);
    // assert(fd &gt; 0);
    if(fd == -1){
        perror("open");
        return -1;
    }
#if 0
    while (1)
    {
        char buf[1024];
        int len = read(fd,buf,sizeof(buf));
        if(len &gt; 0) {
            send(cfd,buf,len,0);
            usleep(10); // 这非常重要
        }
        else if(len == 0) {
            break;
        }
        else{
            perror("read");
        }
    }
#else
    // 把文件内容发送给客户端
    // int size = lseek(fd,0,SEEK_END);// 文件指针移动到了尾部
    // lseek(fd,0,SEEK_SET);
    // int ret = sendfile(cfd,fd,NULL,size);
    // off_t offset = 0;
    // while (offset &lt; size){
    //     int ret = sendfile(cfd,fd,&amp;offset,size- offset);
    //     printf("ret value: %d\n",ret);
    //     if (ret == -1 &amp;&amp; errno == EAGAIN)
    //     {
    //         printf("没数据...\n");
    //     }
    // }
    struct stat st;
    fstat(fd,&amp;st);
    off_t offset = 0;
    while (offset &lt; st.st_size){
        int ret = sendfile(cfd,fd,&amp;offset,st.st_size- offset);
        printf("ret value: %d\n",ret);
        if (ret == -1 &amp;&amp; errno == EAGAIN)
        {
            printf("没数据...\n");
        }
    }
#endif
    close(fd);
    return 0;
}

int sendHeadMsg(int cfd,int status,const char* descr,const char* type,int length) {
    // 状态行
    char buf[4096] = {0};
    sprintf(buf,"http/1.1 %d %s\r\n",status,descr);
    // 响应头
    sprintf(buf+strlen(buf),"content-type: %s\r\n",type);
    sprintf(buf+strlen(buf),"content-length: %d\r\n\r\n",length);
    send(cfd,buf,strlen(buf),0);
    return 0;
}

const char* getFileType(const char* name) {
    // a.jpg a.mp4 a.html
    // 自右向左查找 '.' 字符，如不存在返回NULL
    const char* dot = strrchr(name,'.');
    if(dot == NULL) 
        return "text/plain; charset=utf-8";//纯文本
    if(strcmp(dot,".html") == 0 || strcmp(dot,".htm") == 0) 
        return "text/html; charset=utf-8";
    if(strcmp(dot,".jpg")==0 || strcmp(dot,".jpeg")==0) 
        return "image/jpeg";
    if(strcmp(dot,".gif")==0)
        return "image/gif";
    if(strcmp(dot,".png")==0)
        return "image/png";
    if(strcmp(dot,".css")==0) 
        return "text/css";
    if(strcmp(dot,".au")==0)
        return "audio/basic";
    if(strcmp(dot,".wav")==0)
        return "audio/wav";
    if(strcmp(dot,".avi")==0)
        return "video/x-msvideo";
    if(strcmp(dot,".mov")==0 || strcmp(dot,".qt")==0)
        return "video/quicktime";
    if(strcmp(dot,".mpeg")==0 || strcmp(dot,".mpe")==0)
        return "video/mpeg";
    if(strcmp(dot,".vrml")==0 || strcmp(dot,".wrl")==0)
        return "model/vrml";
    if(strcmp(dot,".midi")==0 || strcmp(dot,".mid")==0)
        return "audio/midi";
    if(strcmp(dot,".mp3")==0)
        return "audio/mpeg";
    if(strcmp(dot,".ogg") == 0) 
        return "application/ogg";
    if(strcmp(dot,".pac") == 0)
        return "application/x-ns-proxy-autoconfig";
    return "text/plain; charset=utf-8";//纯文本
}

/*
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
*/

int sendDir(const char* dirName,int cfd) {
    char buf[4096] = {0};
    sprintf(buf,"&lt;html&gt;&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;",dirName);
    struct dirent** nameList;
    int num = scandir(dirName,&amp;nameList,NULL,alphasort);
    for(int i=0;i&lt;num;i++) {
        // 取出文件名 nameList 指向的是一个指针数组 struct dirent* tmp[]
        char* name = nameList[i]-&gt;d_name;
        struct stat st;
        char subPath[1024] = {0};
        sprintf(subPath,"%s/%s",dirName,name);
        stat(subPath,&amp;st);
        if(S_ISDIR(st.st_mode)) {
            // 从当前目录跳到子目录里边，/
            sprintf(buf+strlen(buf),
                "&lt;tr&gt;&lt;td&gt;&lt;a href=\"%s/\"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;",
                name,name,st.st_size);
        }else{
            sprintf(buf+strlen(buf),
                "&lt;tr&gt;&lt;td&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;",
                name,name,st.st_size);
        }
        send(cfd,buf,strlen(buf),0);
        memset(buf,0,sizeof(buf));
        free(nameList[i]); 
    }
    sprintf(buf,"&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;");
    send(cfd,buf,strlen(buf),0);
    free(nameList);
    return 0;
}

// 将字符转换为整型数
int hexToDec(char c){
    if (c &gt;= '0' &amp;&amp; c &lt;= '9')
        return c - '0';
    if (c &gt;= 'a' &amp;&amp; c &lt;= 'f')
        return c - 'a' + 10;
    if (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
        return c - 'A' + 10;
    return 0;
}

// 解码
// to 存储解码之后的数据, 传出参数, from被解码的数据, 传入参数
void decodeMsg(char* to,char* from) {
    for(;*from!='\0';++to,++from) {
        // isxdigit -&gt; 判断字符是不是16进制格式, 取值在 0-f
        // Linux%E5%86%85%E6%A0%B8.jpg
        if(*from == '%' &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])){
            // 将16进制的数 -&gt; 十进制 将这个数值赋值给了字符 int -&gt; char
            // B2 == 178
            // 将3个字符, 变成了一个字符, 这个字符就是原始数据
            // *to = (hexToDec(from[1]) * 16) + hexToDec(from[2]);
            *to = (hexToDec(from[1]) &lt;&lt; 4) + hexToDec(from[2]);

            // 跳过 from[1] 和 from[2] ，因此在当前循环中已经处理过了
            from += 2;
        }else{
            // 字符拷贝，赋值
            *to = *from;
        }
    }
    *to = '\0';
}</code></pre> 
<p>Server.h</p> 
<pre><code class="language-cpp">#pragma once 
// 初始化监听的套接字
int initListenFd(unsigned short port);
// 启动epoll
int epollRun(int lfd);
// 和客户端建立连接
int acceptClient(int lfd,int epfd);
// 主要是接收对端的数据
int recvHttpRequest(int cfd,int epfd);
// 解析请求行
int parseRequestLine(const char* line,int cfd);
// 发送文件
int sendFile(const char* fileName,int cfd);
// 发送响应头(状态行 + 响应头)
int sendHeadMsg(int cfd,int status,const char* descr,const char* type,int length);
const char* getFileType(const char* name);

// 发送目录
int sendDir(const char* dirName,int cfd); 
int hexToDec(char c);
void decodeMsg(char* to,char* from);</code></pre> 
<p>演示效果：</p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/44/48/bIOPYSi5_o.png" width="373"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ea/19/dCVcA9a6_o.png" width="1070"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/94/ac/2oT1kD71_o.png" width="1200"></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/81/c6/aauTQbAR_o.png" width="1200"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/489e0cbb275e12124ce2b392ef3bac0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS7之我想上网</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a126a6c2d3cce7688e92eba15aaca14/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LVGL_V8.3入门六---手表表盘页面之间的切换(触摸切换、物理按键切换、组件切换)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>