<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql原理--Explain详解 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql原理--Explain详解" />
<meta property="og:description" content="1.概述
一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的 执行计划 ，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。设计 MySQL 的大叔贴心的为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划。
如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：EXPLAIN SELECT 1\G
输出的一大坨东西就是所谓的 执行计划 ，我的任务就是带领大家看懂这一大坨东西里边的每个列都是干啥用的，以及在这个 执行计划 的辅助下，我们应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 DELETE 、 INSERT 、 REPLACE 以及 UPDATE 语句前边都可以加上 EXPLAIN这个词儿，用来查看这些语句的执行计划，不过我们这里对 SELECT 语句更感兴趣，所以后边只会以 SELECT 语句为例来描述 EXPLAIN 语句的用法。为了让大家先有一个感性的认识，我们把 EXPLAIN 语句输出的各个列的作用先大致罗列一下：
列名描述id在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 idselect_typeSELECT 关键字对应的那个查询的类型table表名partitions匹配的分区信息type针对单表的访问方法possible_keys可能用到的索引key实际上使用的索引key_len实际使用到的索引长度ref当使用索引列等值查询时，与索引列进行等值匹配的对象信息rows预估的需要读取的记录条数filtered某个表经过搜索条件过滤后剩余记录条数的百分比Extra一些额外的信息 为了故事的顺利发展，我们还是要请出我们前边已经用了n遍的 single_table 表，为了防止大家忘了，再把它的结构描述一遍：
CREATE TABLE single_table ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3) ) Engine=InnoDB CHARSET=utf8; 我们仍然假设有两个和 single_table 表构造一模一样的 t1 、 t2 表，而且这两个表里边儿有10000条记录，除 id 列外其余的列都插入随机值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/397edfa033c74de3596a3b52ef3f7669/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T18:59:28+08:00" />
<meta property="article:modified_time" content="2024-01-01T18:59:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql原理--Explain详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.概述<br> 一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的 执行计划 ，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。设计 MySQL 的大叔贴心的为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划。</p> 
<p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：<code>EXPLAIN SELECT 1\G</code><br> <img src="https://images2.imgbox.com/c7/3d/rWkl2XRG_o.png" alt="在这里插入图片描述"><br> 输出的一大坨东西就是所谓的 执行计划 ，我的任务就是带领大家看懂这一大坨东西里边的每个列都是干啥用的，以及在这个 执行计划 的辅助下，我们应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 <code>DELETE 、 INSERT 、 REPLACE</code> 以及 <code>UPDATE</code> 语句前边都可以加上 <code>EXPLAIN</code>这个词儿，用来查看这些语句的执行计划，不过我们这里对 SELECT 语句更感兴趣，所以后边只会以 SELECT 语句为例来描述 EXPLAIN 语句的用法。为了让大家先有一个感性的认识，我们把 EXPLAIN 语句输出的各个列的作用先大致罗列一下：</p> 
<table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table> 
<p>为了故事的顺利发展，我们还是要请出我们前边已经用了n遍的 <code>single_table</code> 表，为了防止大家忘了，再把它的结构描述一遍：</p> 
<pre><code>CREATE TABLE single_table (
 id INT NOT NULL AUTO_INCREMENT,
 key1 VARCHAR(100),
 key2 INT,
 key3 VARCHAR(100),
 key_part1 VARCHAR(100),
 key_part2 VARCHAR(100),
 key_part3 VARCHAR(100),
 common_field VARCHAR(100),
 PRIMARY KEY (id),
 KEY idx_key1 (key1),
 UNIQUE KEY idx_key2 (key2),
 KEY idx_key3 (key3),
 KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
</code></pre> 
<p>我们仍然假设有两个和 <code>single_table</code> 表构造一模一样的 <code>t1 、 t2</code> 表，而且这两个表里边儿有<code>10000</code>条记录，除 <code>id</code> 列外其余的列都插入随机值。</p> 
<p>2.执行计划输出中各列详解<br> 2.1.table<br> 设计MySQL 的大叔规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。<br> 我们看一条比较简单的查询语句：<br> <img src="https://images2.imgbox.com/38/2b/MrY0eQyf_o.png" alt="在这里插入图片描述"><br> 这个查询语句只涉及对 t1 表的单表查询，所以 EXPLAIN 输出中只有一条记录，其中的 table 列的值是 t1 ，表明这条记录是用来说明对 t1 表的单表访问方法的。</p> 
<p>下边我们看一下一个连接查询的执行计划：<br> <img src="https://images2.imgbox.com/90/6b/U55srJJB_o.png" alt="在这里插入图片描述"><br> 可以看到这个连接查询的执行计划中有两条记录，这两条记录的 table 列分别是 t1 和 t2 ，这两条记录用来分别说明对 t1 表和 t2 表的访问方法是什么。</p> 
<p>2.2. id<br> 我们知道我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比如下边这个查询语句：<code>SELECT * FROM t1 WHERE key1 = 'a';</code>稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：<code>SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a';</code></p> 
<p>但是下边两种情况下在一条查询语句中会出现多个 SELECT 关键字：<br> (1). 查询中包含子查询的情况<br> 比如下边这个查询语句中就包含2个 SELECT 关键字： <code>SELECT * FROM s1 WHERE key1 IN (SELECT * FROM s2);</code><br> (2). 查询中包含 UNION 语句的情况<br> 比如下边这个查询语句中也包含2个 SELECT 关键字： <code>SELECT * FROM s1 UNION SELECT * FROM s2;</code></p> 
<p>查询语句中每出现一个 SELECT 关键字，设计 MySQL 的大叔就会为它分配一个唯一的 id 值。这个 id 值就是 EXPLAIN 语句的第一个列，比如下边这个查询中只有一个 SELECT 关键字，所以 EXPLAIN 的结果中也就只有一条 id 列为 1 的记录：<code>EXPLAIN SELECT * FROM t1 WHERE key1 = 'a';</code></p> 
<p>对于连接查询来说，一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如： <code>EXPLAIN SELECT * FROM t1 INNER JOIN t2;</code><br> <img src="https://images2.imgbox.com/bf/9e/soUULoqt_o.png" alt="在这里插入图片描述"><br> 可以看到，上述连接查询中参与连接的 t1 和 t2 表分别对应一条记录，但是这两条记录对应的 id 值都是 1 。这里需要大家记住的是，在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表。所以从上边的 EXPLAIN 输出中我们可以看出，查询优化器准备让 t1 表作为驱动表，让 t2 表作为被驱动表来执行查询。</p> 
<p>对于包含子查询的查询语句来说，就可能涉及多个 SELECT 关键字，所以在包含子查询的查询语句的执行计划中，每个 SELECT 关键字都会对应一个唯一的 id 值，比如这样： <code>EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2) OR key3 = 'a';</code><br> <img src="https://images2.imgbox.com/69/9d/WALvCrAJ_o.png" alt="在这里插入图片描述"><br> 从输出结果中我们可以看到， t1 表在外层查询中，外层查询有一个独立的 SELECT 关键字，所以第一条记录的 id 值就是 1 ， t2 表在子查询中，子查询有一个独立的 SELECT 关键字，所以第二条记录的 id 值就是 2 。</p> 
<p>但是这里大家需要特别注意，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说： <code>EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key3 FROM t2 WHERE common_field = 'a');</code><br> <img src="https://images2.imgbox.com/f8/15/sbghoy8P_o.png" alt="在这里插入图片描述"><br> 可以看到，虽然我们的查询语句是一个子查询，但是执行计划中 t1 和 t2 表对应的记录的 id 值全部是 1 ，这就表明了查询优化器将子查询转换为了连接查询。</p> 
<p>对于包含 UNION 子句的查询语句来说，每个 SELECT 关键字对应一个 id 值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询： <code>EXPLAIN SELECT * FROM t1 UNION SELECT * FROM t2;</code><br> <img src="https://images2.imgbox.com/03/88/AbFxg1QV_o.png" alt="在这里插入图片描述"><br> 这个语句的执行计划的第三条记录是个什么鬼？而且 table 列长的也怪怪的？大家别忘了 <code>UNION</code> 子句是干嘛用的，它会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？ MySQL 使用的是内部的临时表。正如上边的查询计划中所示， UNION 子句是为了把 id 为 1 的查询和 id 为 2 的查询的结果集合并起来并去重，所以在内部创建了一个名为 <code>&lt;union1, 2&gt;</code> 的临时表（就是执行计划第三条记录的 table 列的名称）。</p> 
<p>跟 UNION 对比起来， <code>UNION ALL</code> 就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含 <code>UNION ALL</code> 子句的查询的执行计划中，就没有那个 id 为 NULL 的记录，如下所示： <code>EXPLAIN SELECT * FROM t1 UNION ALL SELECT * FROM t2;</code><br> <img src="https://images2.imgbox.com/7f/f5/1ZJa2QIi_o.png" alt="在这里插入图片描述"></p> 
<p>2.3.select_type<br> 通过上边的内容我们知道，一条大的查询语句里边可以包含若干个 <code>SELECT</code> 关键字，每个 <code>SELECT</code> 关键字代表着一个小的查询语句，而每个 <code>SELECT</code> 关键字的 <code>FROM</code> 子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个 <code>SELECT</code> 关键字中的表来说，它们的 <code>id</code> 值是相同的。</p> 
<p>设计 MySQL 的大叔为每一个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，意思是我们只要知道了某个小查询的 select_type 属性，就知道了这个小查询在整个大查询中扮演了一个什么角色，口说无凭，我们还是先来见识见识这个 select_type 都能取哪些值（为了精确起见，我们直接使用文档中的英文做简要描述，随后会进行详细解释的）：</p> 
<table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>Simple SELECT (not using UNION or subqueries)</td></tr><tr><td>PRIMARY</td><td>Outermost SELECT</td></tr><tr><td>UNION</td><td>Second or later SELECT statement in a UNION</td></tr><tr><td>UNION RESULT</td><td>Result of a UNION</td></tr><tr><td>SUBQUERY</td><td>First SELECT in subquery</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>First SELECT in subquery, dependent on outer query</td></tr><tr><td>DEPENDENT UNION</td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td>DERIVED</td><td>Derived table</td></tr><tr><td>MATERIALIZED</td><td>Materialized subquery</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td>UNCACHEABLE UNION</td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table> 
<p>英文描述太简单，不知道说了啥？来详细瞅瞅里边儿的每个值都是干啥吃的：<br> (1). <code>SIMPLE</code><br> 查询语句中不包含 <code>UNION</code> 或者子查询的查询都算作是 <code>SIMPLE</code> 类型，比方说下边这个单表查询的 <code>select_type</code> 的值就是 <code>SIMPLE</code> ：<code>EXPLAIN SELECT * FROM t1;</code><br> <img src="https://images2.imgbox.com/8f/94/wIK8B8N2_o.png" alt="在这里插入图片描述"><br> 当然，连接查询也算是 SIMPLE 类型，比如： <code>EXPLAIN SELECT * FROM t1 INNER JOIN t2;</code><br> <img src="https://images2.imgbox.com/8a/86/McLmnsYl_o.png" alt="在这里插入图片描述"><br> (2). <code>PRIMARY</code><br> 对于包含 <code>UNION 、 UNION ALL</code> 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 <code>select_type</code> 值就是 <code>PRIMARY</code> ，比方说： <code>EXPLAIN SELECT * FROM t1 UNION SELECT * FROM t2;</code><br> <img src="https://images2.imgbox.com/41/5c/gEwGVsO3_o.png" alt="在这里插入图片描述"><br> 从结果中可以看到，最左边的小查询 <code>SELECT * FROM t1</code> 对应的是执行计划中的第一条记录，它的 <code>select type</code> 值就是 <code>PRIMARY</code> 。</p> 
<p>(3). <code>UNION</code><br> 对于包含 <code>UNION</code> 或者 <code>UNION ALL</code> 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 <code>select_type</code> 值就是 <code>UNION</code> ，可以对比上一个例子的效果，这就不多举例子了。</p> 
<p>(4). <code>UNION RESULT</code><br> <code>MySQL</code> 选择使用临时表来完成 <code>UNION</code> 查询的去重工作，针对该临时表的查询的 <code>select_type</code> 就是 <code>UNION RESULT</code> ，例子上边有，就不赘述了。</p> 
<p>(5). <code>SUBQUERY</code><br> 如果包含子查询的查询语句不能够转为对应的 <code>semi-join</code> 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个 <code>SELECT</code> 关键字代表的那个查询的 <code>select_type</code> 就是 <code>SUBQUERY</code> ，比如下边这个查询： <code>EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2) OR key3 = 'a';</code><br> <img src="https://images2.imgbox.com/c5/82/1vrfzNW3_o.png" alt="在这里插入图片描述"><br> 可以看到，外层查询的 <code>select_type</code> 就是 <code>PRIMARY</code> ，子查询的 <code>select_type</code> 就是 <code>SUBQUERY</code> 。需要大家注意的是，由于<code>select_type</code>为<code>SUBQUERY</code>的子查询由于会被物化，所以只需要执行一遍。</p> 
<p>注意：这里实际显示的是<code>DEPENDENT SUBQUERY</code></p> 
<p>(6). <code>DEPENDENT SUBQUERY</code><br> 如果包含子查询的查询语句不能够转为对应的 <code>semi-join</code> 的形式，并且该子查询是相关子查询，则该子查询的第一个 <code>SELECT</code> 关键字代表的那个查询的 <code>select_type</code> 就是 <code>DEPENDENT SUBQUERY</code> ，比如下边这个查询： <code>EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2 WHERE t1.key2 = t2.key2) OR key3 = 'a';</code><br> <img src="https://images2.imgbox.com/56/ac/ivpV4Ng1_o.png" alt="在这里插入图片描述"><br> 需要大家注意的是，<code>select_type</code>为<code>DEPENDENT SUBQUERY</code>的查询可能会被执行多次。</p> 
<p>(7). <code>DEPENDENT UNION</code><br> 在包含 <code>UNION</code> 或者 <code>UNION ALL</code> 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的 <code>select_type</code> 的值就是 <code>DEPENDENT UNION</code> 。说的有些绕哈，比方说下边这个查询：<code>EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2 WHERE key1 = 'a' UNION SELECT key1 FROM t1 WHERE key1 = 'b');</code><br> <img src="https://images2.imgbox.com/5c/ad/jVcIBsRb_o.png" alt="在这里插入图片描述"><br> 这个查询比较复杂啊，大查询里包含了一个子查询，子查询里又是由 <code>UNION</code> 连起来的两个小查询。从执行计划中可以看出来， <code>SELECT key1 FROM t2 WHERE key1 = 'a'</code> 这个小查询由于是子查询中第一个查询，所以它的 <code>select_type</code> 是 <code>DEPENDENT SUBQUERY</code> ，而 <code>SELECT key1 FROM t1 WHERE key1 = 'b'</code> 这个查询的 <code>select_type</code> 就是 <code>DEPENDENT UNION</code> 。</p> 
<p>(8). <code>DERIVED</code><br> 对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 <code>select_type</code> 就是 <code>DERIVED</code> ，比方说下边这个查询： <code>EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM t1 GROUP BY key1) AS derived_s1 where c &gt; 1;</code><br> <img src="https://images2.imgbox.com/09/a3/7w9kfbjT_o.png" alt="在这里插入图片描述"><br> 从执行计划中可以看出， id 为 2 的记录就代表子查询的执行方式，它的 <code>select_type</code> 是 <code>DERIVED</code> ，说明该子查询是以物化的方式执行的。 id 为 1 的记录代表外层查询，大家注意看它的 <code>table</code> 列显示的是 <code>&lt;derived2&gt;</code> ，表示该查询是针对将派生表物化之后的表进行查询的。</p> 
<p>如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象。</p> 
<p>(9). <code>MATERIALIZED</code><br> 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 <code>select_type</code> 属性就是 <code>MATERIALIZED</code> ，比如下边这个查询：<code>EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2);</code><br> <img src="https://images2.imgbox.com/9e/fe/ofK6TAJS_o.png" alt="在这里插入图片描述"><br> 执行计划的第三条记录的 id 值为 2 ，说明该条记录对应的是一个单表查询，从它的 select_type 值为 <code>MATERIALIZED</code> 可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的 id 值都为 1 ，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的 table 列的值是 <code>&lt;subquery2&gt;</code> ，说明该表其实就是 id 为 2 对应的子查询执行之后产生的物化表，然后将 <code>s1</code> 和该物化表进行连接查询。</p> 
<p>(10). <code>UNCACHEABLE SUBQUERY</code><br> 不常用，就不多唠叨了。</p> 
<p>(11). <code>UNCACHEABLE UNION</code><br> 不常用，就不多唠叨了。</p> 
<p>2.4.<code>partitions</code><br> 由于我们压根儿就没唠叨过分区是个啥，所以这个输出列我们也就不说了哈，一般情况下我们的查询语句的执行计划的 <code>partitions</code> 列的值都是 <code>NULL</code> 。</p> 
<p>2.5.<code>type</code><br> 我们前边说过执行计划的一条记录就代表着 MySQL 对某个表的执行查询时的访问方法，其中的 <code>type</code> 列就表明了这个访问方法是个啥，比方说下边这个查询： <code>EXPLAIN SELECT * FROM t1 WHERE key1 = 'a';</code><br> <img src="https://images2.imgbox.com/99/fe/qGRZ11YJ_o.png" alt="在这里插入图片描述"><br> 完整的访问方法如下： <code>system ， const ，eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ，range ， index ， ALL</code> 。当然我们还要详细唠叨一下哈：<br> (1). <code>system</code><br> 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如<code>MyISAM、Memory</code>，那么对该表的访问方法就是 system 。<br> (2). <code>const</code><br> 当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const 。<br> (3). <code>eq_ref</code><br> 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是 eq_ref 。<br> (4). <code>ref</code><br> 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref。<br> (5). <code>fulltext</code><br> 全文索引，我们没有细讲过，跳过～<br> (6). <code>ref_or_null</code><br> 当对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 <code>ref_or_null</code>。<br> (7). <code>index_merge</code><br> 一般情况下对于某个表的查询只能使用到一个索引，但我们唠叨单表访问方法时特意强调了在某些场景下可以使用 <code>Intersection 、 Union 、 Sort-Union</code> 这三种索引合并的方式来执行查询。<br> (8). <code>unique_subquery</code><br> 类似于两表连接中被驱动表的 <code>eq_ref</code> 访问方法， <code>unique_subquery</code> 是针对在一些包含 <code>IN</code> 子查询的查询语句中，如果查询优化器决定将 <code>IN</code>子查询转换为 <code>EXISTS</code> 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 <code>type</code> 列的值就是 <code>unique_subquery</code> ，比如下边的这个查询语句：<code>EXPLAIN SELECT * FROM t1 WHERE key2 IN (SELECT id FROM t2 where t1.key1 = t2.key1) OR key3 = 'a';</code><br> <img src="https://images2.imgbox.com/bb/a5/lSazrKeH_o.png" alt="在这里插入图片描述"><br> (9). <code>index_subquery</code><br> <code>index_subquery</code> 与 <code>unique_subquery</code> 类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：<code>EXPLAIN SELECT * FROM t1 WHERE common_field IN (SELECT key3 FROM t2 where t1. key1 = t2.key1) OR key3 = 'a';</code><br> (10). <code>range</code><br> 如果使用索引获取某些 范围区间 的记录，那么就可能使用到 <code>range</code> 访问方法。<br> (11). <code>index</code><br> 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index 。<br> (12). <code>ALL</code><br> 全表扫描</p> 
<p>一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了 <code>All</code> 这个访问方法外，其余的访问方法都能用到索引，除了 <code>index_merge</code> 访问方法外，其余的访问方法都最多只能用到一个索引。</p> 
<p>2.6.<code>possible_keys</code>和<code>key</code><br> 在 <code>EXPLAIN</code> 语句输出的执行计划中， <code>possible_keys</code> 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些， <code>key</code> 列表示实际用到的索引有哪些，比方说下边这个查询：<br> <img src="https://images2.imgbox.com/6b/23/b3u0wFu0_o.png" alt="在这里插入图片描述"><br> 2.7.<code>key_len</code><br> <code>key_len</code> 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：<br> (1). 对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 <code>VARCHAR(100)</code> ，使用的字符集是 <code>utf8</code> ，那么该列实际占用的最大存储空间就是 <code>100 × 3 = 300</code> 个字节。<br> (2). 如果该索引列可以存储 <code>NULL</code> 值，则 <code>key_len</code> 比不可以存储 <code>NULL</code> 值时多1个字节。<br> (3). 对于变长字段来说，都会有<code>2</code>个字节的空间来存储该变长列的实际长度。</p> 
<p>比如下边这个查询：<code>EXPLAIN SELECT * FROM t1 WHERE id = 1;</code>由于 id 列的类型是 <code>INT</code> ，并且不可以存储 <code>NULL</code> 值，所以在使用该列的索引时 <code>key_len</code> 大小就是 4 。当索引列可以存储 <code>NULL</code> 值时，比如： <code>EXPLAIN SELECT * FROM t1 WHERE key2 = 5;</code> <code>key_len</code> 列就变成了 5 ，比使用 <code>id</code> 列的索引时多了 <code>1</code> 。</p> 
<p>对于可变长度的索引列来说，比如下边这个查询：<code>EXPLAIN SELECT * FROM t1 WHERE key1 = 'a';</code>由于 <code>key1</code> 列的类型是 <code>VARCHAR(100)</code> ，所以该列实际最多占用的存储空间就是 <code>300</code> 字节，又因为该列允许存储 <code>NULL</code> 值，所以 <code>key_len</code> 需要加 <code>1</code> ，又因为该列是可变长度列，所以 <code>key_len</code> 需要加 <code>2</code> ，所以最后 <code>ken_len</code> 的值就是 <code>303</code> 。</p> 
<p>执行计划的生成是在 <code>MySQL server</code> 层中的功能，并不是针对具体某个存储引擎的功能，设计 <code>MySQL</code> 的大叔在执行计划中输出<code>key_len</code> 列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列，并不需要十分精确。</p> 
<p>2.8.<code>ref</code><br> 当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 <code>const 、 eq_ref 、 ref 、 ref_or_null 、unique_subquery 、 index_subquery</code> 其中之一时， <code>ref</code> 列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。大家看下边这个查询： <code>EXPLAIN SELECT * FROM t1 WHERE key1 = 'a';</code><br> <img src="https://images2.imgbox.com/89/e4/vehRsSuN_o.png" alt="在这里插入图片描述"><br> 当然有时候更复杂一点： <code>EXPLAIN SELECT * FROM t1 INNER JOIN t2 ON t1.id = t2.id;</code><br> <img src="https://images2.imgbox.com/6a/d6/VfGOekBd_o.png" alt="在这里插入图片描述"><br> 有的时候与索引列进行等值匹配的对象是一个函数，比方说下边这个查询：<code>EXPLAIN SELECT * FROM t1 INNER JOIN t2 ON t2.key1 = UPPER(t1.key1);</code><br> <img src="https://images2.imgbox.com/59/13/ui09XfMf_o.png" alt="在这里插入图片描述"><br> 2.9.<code>rows</code><br> 如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 <code>rows</code> 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 <code>rows</code> 列就代表预计扫描的索引记录行数。</p> 
<p>2.10.<code>filtered</code><br> 之前在分析连接查询的成本时提出过一个 <code>condition filtering</code> 的概念，就是 <code>MySQL</code> 在计算驱动表扇出时采用的一个策略：<br> (1). 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。<br> (2). 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p> 
<p>比方说下边这个查询： <code>EXPLAIN SELECT * FROM t1 WHERE key1 &gt; 'z' AND common_field = 'a';</code><br> <img src="https://images2.imgbox.com/ff/e5/EpzBPT5g_o.png" alt="在这里插入图片描述"><br> 从执行计划的 <code>key</code> 列中可以看出来，该查询使用 <code>idx_key1</code> 索引来执行查询，从 <code>rows</code> 列可以看出满足 <code>key1 &gt;'z'</code> 的记录有 1 条。执行计划的 <code>filtered</code> 列就代表查询优化器预测在这 1条记录中，有多少条记录满足其余的搜索条件，也就是 <code>common_field = 'a'</code> 这个条件的百分比。此处 <code>filtered</code> 列的值是 <code>33.33</code> ，说明查询优化器预测在 1条记录中有 <code>33.33%</code> 的记录满足 <code>common_field = 'a'</code> 这个条件。</p> 
<p>对于单表查询来说，这个 <code>filtered</code> 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 <code>filtered</code> 值，比方说下边这个查询：<code>EXPLAIN SELECT * FROM t1 INNER JOIN t2 ON t1.key1 = t2.key1 WHERE t1.common_field = 'a';</code><br> <img src="https://images2.imgbox.com/a5/f8/Zsl7DiHT_o.png" alt="在这里插入图片描述"><br> 从执行计划中可以看出来，查询优化器打算把 <code>t1</code> 当作驱动表， <code>t2</code> 当作被驱动表。我们可以看到驱动表 <code>t1</code> 表的执行计划的 <code>rows</code> 列为 <code>3</code>， <code>filtered</code> 列为 <code>33.33</code> ，这意味着驱动表 <code>t1</code> 的扇出值就是 <code>3× 33.33 % = 99.99%</code> ，这说明还要对被驱动表执行大约 <code>99.99%</code> 次查询。</p> 
<p>2.11.<code>Extra</code><br> 顾名思义， <code>Extra</code> 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解 MySQL 到底将如何执行给定的查询语句。 MySQL 提供的额外信息有好几十个，所以我们只挑一些平时常见的或者比较重要的额外信息介绍给大家哈。<br> (1). <code>No tables used</code><br> 当查询语句的没有 FROM 子句时将会提示该额外信息。<br> (2). <code>Impossible WHERE</code><br> 查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息。<br> (3). <code>No matching min/max row</code><br> 当查询列表处有 <code>MIN</code> 或者 <code>MAX</code> 聚集函数，但是并没有符合 <code>WHERE</code> 子句中的搜索条件的记录时，将会提示该额外信息，比方说：<code>EXPLAIN SELECT MIN(key1) FROM t1 WHERE key1 = 'abcdefg';</code><br> (4). <code>Using index</code><br> 当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在 <code>Extra</code> 列将会提示该额外信息。<br> (5). <code>Using index condition</code><br> 有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询： <code>SELECT * FROM t1 WHERE key1 &gt; 'z' AND key1 LIKE '%a';</code><br> 在以前版本的 MySQL 中，是按照下边步骤来执行这个查询的：<br> a. 先根据 <code>key1 &gt; 'z'</code> 这个条件，从二级索引 <code>idx_key1</code> 中获取到对应的二级索引记录。<br> b. 根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合 <code>key1 LIKE '%a'</code> 这个条件，将符合条件的记录加入到最后的结果集。</p> 
<p>但是虽然 <code>key1 LIKE '%a'</code> 不能组成范围区间参与 <code>range</code> 访问方法的执行，但这个条件毕竟只涉及到了 <code>key1</code> 列，所以设计 <code>MySQL</code> 的大叔把上边的步骤改进了一下：<br> a. 先根据 <code>key1 &gt; 'z'</code> 这个条件，定位到二级索引 <code>idx_key1</code> 中对应的二级索引记录。<br> b. 对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足 <code>key1 LIKE '%a'</code> 这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。<br> c. 对于满足 <code>key1 LIKE '%a'</code> 这个条件的二级索引记录执行回表操作。</p> 
<p>我们说回表操作其实是一个随机 IO ，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。设计 MySQL 的大叔们把他们的这个改进称之为 索引条件下推 （英文名： <code>Index Condition Pushdown</code> ）。如果在查询语句的执行过程中将要使用 索引条件下推 这个特性，在 Extra 列中将会显示 <code>Using index condition</code> 。</p> 
<p>(6). <code>Using where</code><br> 当我们使用全表扫描来执行对某个表的查询，并且该语句的 <code>WHERE</code> 子句中有针对该表的搜索条件时，在 <code>Extra</code> 列中会提示上述额外信息。比如下边这个查询： <code>EXPLAIN SELECT * FROM t1 WHERE common_field = 'a';</code></p> 
<p>当使用索引访问来执行对某个表的查询，并且该语句的 <code>WHERE</code> 子句中有除了该索引包含的列之外的其他搜索条件时，在 <code>Extra</code> 列中也会提示上述额外信息。比如下边这个查询虽然使用 <code>idx_key1</code> 索引执行查询，但是搜索条件中除了包含 <code>key1</code> 的搜索条件 <code>key1 = 'a'</code> ，还有包含 <code>common_field</code> 的搜索条件，所以 <code>Extra</code> 列会显示 <code>Using where</code> 的提示： <code>EXPLAIN SELECT * FROM t1 WHERE key1 = 'a' AND common_field = 'a';</code></p> 
<p>(7). <code>Using join buffer (Block Nested Loop)</code><br> 在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度， <code>MySQL</code> 一般会为其分配一块名叫 <code>join buffer</code> 的内存块来加快查询速度，也就是我们所讲的 基于块的嵌套循环算法 ，比如下边这个查询语句： <code>EXPLAIN SELECT * FROM t1 INNER JOIN t2 ON t1.common_field = t2.common_field;</code><br> <img src="https://images2.imgbox.com/70/2e/vBZsPfFH_o.png" alt="在这里插入图片描述"><br> 可以在对 t2 表的执行计划的 Extra 列显示了两个提示：<br> a. <code>Using join buffer (Block Nested Loop)</code> ：这是因为对表 <code>s2</code> 的访问不能有效利用索引，只好退而求其次，使用 <code>join buffer</code> 来减少对 <code>s2</code> 表的访问次数，从而提高性能。<br> b. <code>Using where</code> ：可以看到查询语句中有一个 <code>t1.common_field = t2.common_field</code> 条件，因为 <code>t1</code> 是驱动表， <code>t2</code> 是被驱动表，所以在访问 <code>t2</code> 表时， <code>t1.common_field</code> 的值已经确定下来了，所以实际上查询 <code>t2</code> 表的条件就是 <code>t2.common_field = 一个常数</code> ，所以提示了 <code>Using where</code> 额外信息。</p> 
<p>(8). <code>Not exists</code><br> 当我们使用左（外）连接时，如果 <code>WHERE</code> 子句中包含要求被驱动表的某个列等于 <code>NULL</code> 值的搜索条件，而且那个列又是不允许存储 <code>NULL</code> 值的，那么在该表的执行计划的 <code>Extra</code> 列就会提示 <code>Not exists</code> 额外信息，比如这样：<code>EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t1.key1 = t2.key1 WHERE t2.id IS NULL;</code></p> 
<p>上述实例中，只有驱动表中某条记录，在被驱动表里找不到符号<code>ON</code>条件的记录时，驱动表此记录才会加入到最终的结果集。</p> 
<p>(9). <code>Using intersect(...)</code> 、 <code>Using union(...)</code> 和 <code>Using sort_union(...)</code><br> 如果执行计划的 <code>Extra</code> 列出现了 <code>Using intersect(...)</code> 提示，说明准备使用 <code>Intersect</code> 索引合并的方式执行查询，括号中的 <code>...</code> 表示需要进行索引合并的索引名称；如果出现了 <code>Using union(...)</code> 提示，说明准备使用 <code>Union</code> 索引合并的方式执行查询；出现了 <code>Using sort_union(...)</code> 提示，说明准备使用 <code>Sort-Union</code> 索引合并的方式执行查询。</p> 
<p>(10). <code>Zero limit</code><br> 当我们的 LIMIT 子句的参数为 0 时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息，比如这样：<code>EXPLAIN SELECT * FROM t1 LIMIT 0;</code><br> <img src="https://images2.imgbox.com/ff/6a/XZUShldH_o.png" alt="在这里插入图片描述"><br> (11). <code>Using filesort</code><br> 有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询： <code>EXPLAIN SELECT * FROM t1 ORDER BY key1 LIMIT 10;</code><br> 这个查询语句可以利用 idx_key1 索引直接取出 key1 列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，设计 MySQL 的大叔把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：filesort ）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using<br> filesort 提示，比如这样： <code>EXPLAIN SELECT * FROM t1 ORDER BY common_field LIMIT 10;</code></p> 
<p>需要注意的是，如果查询中需要使用 <code>filesort</code> 的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用 文件排序 的执行方式改为使用索引进行排序。</p> 
<p>(12). <code>Using temporary</code><br> 在许多查询的执行过程中， <code>MySQL</code> 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 <code>DISTINCT 、 GROUP BY 、 UNION</code> 等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code> 很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的 <code>Extra</code> 列将会显示 <code>Using temporary</code> 提示，比方说这样： <code>EXPLAIN SELECT DISTINCT common_field FROM t1;</code></p> 
<p>执行计划中出现 <code>Using temporary</code> 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下边这个包含 <code>GROUP BY</code> 子句的查询就不需要使用临时表： <code>EXPLAIN SELECT key1, COUNT(*) AS amount FROM t1 GROUP BY key1;</code></p> 
<p>(13). <code>Start temporary, End temporary</code><br> 我们前边唠叨子查询的时候说过，查询优化器会优先尝试将 IN 子查询转换成 <code>semi-join</code> ，而 <code>semi-join</code> 又有好多种执行策略，当执行策略为 <code>DuplicateWeedout</code> 时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的 <code>Extra</code> 列将显示 <code>Start temporary</code> 提示，被驱动表查询执行计划的 <code>Extra</code> 列将显示 <code>End temporary</code> 提示，就是这样： <code>EXPLAIN SELECT * FROM t1 WHERE key1 IN (SELECT key3 FROM t2 WHERE common_field = 'a');</code></p> 
<p>(14). <code>LooseScan</code><br> 在将 <code>In</code> 子查询转为 <code>semi-join</code> 时，如果采用的是 <code>LooseScan</code> 执行策略，则在驱动表执行计划的 <code>Extra</code> 列就是显示 <code>LooseScan</code> 提示，比如这样： <code>EXPLAIN SELECT * FROM t1 WHERE key3 IN (SELECT key1 FROM t2 WHERE key1 &gt; 'z');</code></p> 
<p>(15). <code>FirstMatch(tbl_name)</code><br> 在将 <code>In</code> 子查询转为 <code>semi-join</code> 时，如果采用的是 <code>FirstMatch</code> 执行策略，则在被驱动表执行计划的 <code>Extra</code> 列就是显示 <code>FirstMatch(tbl_name)</code> 提示，比如这样：<code>EXPLAIN SELECT * FROM t1 WHERE common_field IN (SELECT key1 FROM t2 where t1.key3 = t2.key3);</code></p> 
<p>3.Json格式的执行计划<br> 我们上边介绍的 <code>EXPLAIN</code> 语句输出中缺少了一个衡量执行计划好坏的重要属性 —— 成本。不过设计 <code>MySQL</code> 的大叔贴心的为我们提供了一种查看某个执行计划花费的成本的方式：在 <code>EXPLAIN</code> 单词和真正的查询语句中间加上 <code>FORMAT=JSON</code> 。</p> 
<p>这样我们就可以得到一个 <code>json</code> 格式的执行计划，里边儿包含该计划花费的成本，比如这样： <code>EXPLAIN FORMAT=JSON SELECT * FROM t1 INNER JOIN t2 ON t1.key1 = t2.key2 WHERE t1.common_field = 'a'\G</code></p> 
<pre><code>mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G
*************************** 1. row ***************************
EXPLAIN: {
    "query_block": {
        "select_id": 1, # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1
        "cost_info": {
            "query_cost": "3197.16" # 整个查询的执行成本预计为3197.16
        },
        "nested_loop": [ # 几个表之间采用嵌套循环连接算法执行
            {
            "table": {
                    "table_name": "s1", # s1表是驱动表
                    "access_type": "ALL", # 访问方法为ALL，意味着使用全表扫描访问
                    "possible_keys": [ # 可能使用的索引
                        "idx_key1"
                    ],
                    "rows_examined_per_scan": 9688, # 查询一次s1表大致需要扫描9688条记录
                    "rows_produced_per_join": 968, # 驱动表s1的扇出是968
                    "filtered": "10.00", # condition filtering代表的百分比
                    "cost_info": {
                        "read_cost": "1840.84", # 稍后解释
                        "eval_cost": "193.76", # 稍后解释
                        "prefix_cost": "2034.60", # 单次查询s1表总共的成本
                        "data_read_per_join": "1M" # 读取的数据量
                    },
                    "used_columns": [ # 执行查询中涉及到的列
                        "id",
                        "key1",
                        "key2",
                        "key3",
                        "key_part1",
                        "key_part2",
                        "key_part3",
                        "common_field"
                    ],
                    # 对s1表访问时针对单表查询的条件
                    "attached_condition": "((`xiaohaizi`.`s1`.`common_field` = 'a') and (`xiaohaizi`.`s1`.`key1` is not null))"
                }
            },
            {
                "table": {
                    "table_name": "s2", # s2表是被驱动表
                    "access_type": "ref", # 访问方法为ref，意味着使用索引等值匹配的方式访问
                    "possible_keys": [ # 可能使用的索引
                        "idx_key2"
                    ],
                    key": "idx_key2", # 实际使用的索引
                    "used_key_parts": [ # 使用到的索引列
                        "key2"
                    ],
                    "key_length": "5", # key_len
                    "ref": [ # 与key2列进行等值匹配的对象
                        "xiaohaizi.s1.key1"
                    ],
                    "rows_examined_per_scan": 1, # 查询一次s2表大致需要扫描1条记录
                    "rows_produced_per_join": 968, # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）
                    "filtered": "100.00", # condition filtering代表的百分比
                    # s2表使用索引进行查询的搜索条件
                    "index_condition": "(`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key2`)",
                    "cost_info": {
                        "read_cost": "968.80", # 稍后解释
                        "eval_cost": "193.76", # 稍后解释
                        "prefix_cost": "3197.16", # 单次查询s1、多次查询s2表总共的成本
                        "data_read_per_join": "1M" # 读取的数据量
                    },
                    "used_columns": [ # 执行查询中涉及到的列
                        "id",
                        "key1",
                        "key2",
                        "key3",
                        "key_part1",
                        "key_part2",
                        "key_part3",
                        "common_field"
                    ]
                }
            }
        ]
    }
}
</code></pre> 
<p>大家可能有疑问 “cost_info” 里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的 “cost_info” 部分：</p> 
<pre><code class="prism language-cpp"><span class="token string">"cost_info"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
 <span class="token string">"read_cost"</span><span class="token operator">:</span> <span class="token string">"1840.84"</span><span class="token punctuation">,</span>
 <span class="token string">"eval_cost"</span><span class="token operator">:</span> <span class="token string">"193.76"</span><span class="token punctuation">,</span>
 <span class="token string">"prefix_cost"</span><span class="token operator">:</span> <span class="token string">"2034.60"</span><span class="token punctuation">,</span>
 <span class="token string">"data_read_per_join"</span><span class="token operator">:</span> <span class="token string">"1M"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>(1). read_cost 是由下边这两部分组成的：<br> a. IO 成本<br> b. 检测 rows × (1 - filter) 条记录的 CPU 成本<br> (2). eval_cost 是这样计算的：<br> 检测 rows × filter 条记录的成本。<br> (3). prefix_cost 就是单独查询 s1 表的成本，也就是：<br> read_cost + eval_cost<br> (4). data_read_per_join 表示在此次查询中需要读取的数据量，我们就不多唠叨这个了。</p> 
<p>对于 s2 表的 “cost_info” 部分是这样的：</p> 
<pre><code class="prism language-cpp"><span class="token string">"cost_info"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
 <span class="token string">"read_cost"</span><span class="token operator">:</span> <span class="token string">"968.80"</span><span class="token punctuation">,</span>
 <span class="token string">"eval_cost"</span><span class="token operator">:</span> <span class="token string">"193.76"</span><span class="token punctuation">,</span>
 <span class="token string">"prefix_cost"</span><span class="token operator">:</span> <span class="token string">"3197.16"</span><span class="token punctuation">,</span>
 <span class="token string">"data_read_per_join"</span><span class="token operator">:</span> <span class="token string">"1M"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和 eval_cost 是访问多次 s2 表后累加起来的值，大家主要关注里边儿的 prefix_cost 的值代表的是整个连接查询预计的成本，也就是单次查询 s1 表和多次查询 s2 表后的成本的和，也就是：<code>968.80 + 193.76 + 2034.60 = 3197.16</code></p> 
<p>4.Extented EXPLAIN<br> 在我们使用 EXPLAIN 语句查看了某个查询的执行计划后，紧接着还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：<code>EXPLAIN SELECT t1.key1, t2.key1 FROM t1 LEFT JOIN t2 ON t1.key1 = t2.key1 WHERE t2.common_field IS NOT NULL;</code>，再执行： <code>SHOW WARNINGS\G</code><br> <img src="https://images2.imgbox.com/8d/4c/KD3qia2j_o.png" alt="在这里插入图片描述"><br> 大家可以看到 <code>SHOW WARNINGS</code> 展示出来的信息有三个字段，分别是 <code>Level 、 Code 、 Message</code> 。我们最常见的就是 <code>Code</code> 为 <code>1003</code> 的信息，当 <code>Code</code> 值为 <code>1003</code> 时， <code>Message</code> 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左（外）连接查询，但是有一个 <code>t2.common_field IS NOT NULL</code>的条件，着就会导致查询优化器把左（外）连接查询优化为内连接查询，从 <code>SHOW WARNINGS</code> 的 <code>Message</code> 字段也可以看出来，原本的 <code>LEFT JOIN</code> 已经变成了 <code>JOIN</code> 。</p> 
<p>但是大家一定要注意，我们说 <code>Message</code> 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说 <code>Message</code> 字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解查 <code>MySQL</code> 将如何执行查询语句的一个参考依据而已。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9b96f9623553ac8f08a636243c23138e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">P1163 银行贷款</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7fd1bdd9735f5e43ea6e5d1e37a7a61d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024CleanMyMac X全新免费永久版下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>