<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一部很好的入门C＃入门教程 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一部很好的入门C＃入门教程" />
<meta property="og:description" content="java我了解的比较少，但是完全面向对象的技术，使得开发变得简便，这是毋庸置疑的。.net发展实现了这一点。最近做的东西，感觉还是用.net来开发界面比较方便，所以好好的把C＃的学习有深入看了看。当然，要使用.net，要使用Visual C＃，首先要学习C＃语言。感谢这部书，当初使我很快完成了C＋＋向C＃的过渡，希望大家共勉。另外一部是《C＃语言参考》，是手册，没有必要全看，主要是参考。最后多说两句，一、有人问我为什么不使用C&#43;&#43;.net这一既有C＋＋语法又有.net语法的语言，我说，那个东西是将C＋＋弄复杂来实现.net，而C＃是将C＋＋弄简单来实现.net，所以C&#43;&#43;.net比C＃难学两倍。二、我还是坚定的支持C＋＋和API，因为这仍然是最基本的。特别是C＋＋在一些算法技巧的实现上，我觉得有着非常大的特长。谢谢 前言
0.1 提要
欢迎阅读《展现 C#》(Presenting C#)。这本书是你提高企业编程语言的一条捷径。这种企业编程语言带有下一代编程语言服务运行时(NGWS Runtime)：C#(发音&#34;C sharp&#34;)。
NGWS Runtime 是一个不仅管理执行代码、同时也提供使编程更加容易的动态环境。编译器产生受管代码以指向这种受管理执行环境。你获得跨平台语言集成、跨平台语言异常处理、增强安全性、版本控制、安排支持和查错服务。
支持NGWS Runtime 的主要语言是C#。支持NGWS框架的很多程序是用C#写的，因此，在一些带有NGWS Runtime的编译器中，它的编译器可以被认为是非常经得起测试且是经过优化的。C#语言借鉴了C&#43;&#43;，但是具备现代化和新增的类型安全——使C#成为企业解决方案的首选语言。 0.2 谁应该读这本书
如果你对编程很陌生，这本书不适合你。这本书企图让程序员解脱并使用C#，基于他们已经拥有的知识。《展现 C#》的目标瞄准了已经具有如C/C&#43;&#43;、VB、Java或其它编程经验的程序员。
如果你具有C&#43;&#43;的背景，转向C#会很容易，但是，如果你精通于其它不同的语言，这本书也会耗掉你的一些日子。如果你有一点COM编程的知识，这本会更有趣，但会COM编程不再是必要的。 0.3 这本书如何组织
第一章 C#简介——这一章把你带到C#逛一回，同时回答了有关你应该考虑学习C#的问题。
第二章 NGWS Runtime 的技术基础——介绍NGWS Runtime为运行的C#代码所提供的低层架构。
第三章 第一个C#应用程序——创建真正第一个C#应用程序(否则它是什么呢?)，它就是一个&#34;Hello World&#34;应用程序。
第四章 C#类型——可以看到用在C#应用程序中的各种类型。探索值型和引用型的区别，还有如何加框和消框。
第五章 类——C#功能真正强大的标志，它是具有类的面向对象的编程。你会学到好多好多的东西，如构造函数、析构函数、方法、属性、索引和事件等。
第六章 控制语句——对应用程序实行流程控制。探索C#提供的各种选择和陈述语句。
第七章 异常处理——获得了编写实现异常处理的应用程序技巧，拥有这种技巧，在NGWS Runtime世界，你是一个好的公民
第八章 用C#写组件——用C#构建组件，因为支持NGWS Runtime，它可以被不同语言平台的客户使用。
第九章 配置和安排——学到如何用C#有条件地进行编译工作，和如何为你的C#源码自动地创建文档。另外，这一章将介绍到NGWS的版本技术问题。
第十章 用非受管代码交互操作——发现你如何使用C#内部的非受管代码，且非受管代码如何与你的C#组件一起交互操作。
第十一章 C#代码查错——获得使用SDK查错工具的技巧，可以在应用程序中准确地找到错误并修改它们。
第十二章 安全——探索NGWS Runtime的安全概念。学到代码访问安全性和基于角色的安全性。 0.4 使用这本书你需要什么?
从这本书的观点看，你所需要的就是下一代windows服务软件开发包(NGWS SDK)。尽管至少只要有NGWS Runtime 和C#编译器就可以，但当探索这些激动人心的新技术功能 时，在一台机器上装有说明文件档和所有的SDK工具(包括debugger)，将是一个极好的主意。
这本书不需要你装在机器上的Visual Studio 7的任何工具。我仅建议你要有一个优秀的支持行数的程序编辑器，用以编辑C#源文件。
……
(省略掉一些有关出版过程和表示感谢的段落) 0.5 关于作者" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/3e7017823f2bd4c44652ae63c306f59d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2007-12-06T10:11:00+08:00" />
<meta property="article:modified_time" content="2007-12-06T10:11:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一部很好的入门C＃入门教程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                      
 
<a name="#wbs-bookmark-top"></a> 
 
 
<a name="wbs-bookmark-item0"></a> java我了解的比较少，但是完全面向对象的技术，使得开发变得简便，这是毋庸置疑的。.net发展实现了这一点。最近做的东西，感觉还是用.net来开发界面比较方便，所以好好的把C＃的学习有深入看了看。当然，要使用.net，要使用Visual C＃，首先要学习C＃语言。感谢这部书，当初使我很快完成了C＋＋向C＃的过渡，希望大家共勉。另外一部是《C＃语言参考》，是手册，没有必要全看，主要是参考。最后多说两句，一、有人问我为什么不使用C++.net这一既有C＋＋语法又有.net语法的语言，我说，那个东西是将C＋＋弄复杂来实现.net，而C＃是将C＋＋弄简单来实现.net，所以C++.net比C＃难学两倍。二、我还是坚定的支持C＋＋和API，因为这仍然是最基本的。特别是C＋＋在一些算法技巧的实现上，我觉得有着非常大的特长。谢谢 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> <p><strong>前言</strong></p> <p><strong>0.1 提要</strong></p> <p>欢迎阅读《展现 <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>》(Presenting <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>)。这本书是你提高企业编程语言的一条捷径。这种企业编程语言带有下一代编程语言服务运行时(NGWS Runtime)：<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>(发音"C sharp")。</p> <p>NGWS Runtime 是一个不仅管理执行代码、同时也提供使编程更加容易的动态环境。编译器产生受管代码以指向这种受管理执行环境。你获得跨平台语言集成、跨平台语言异常处理、增强安全性、版本控制、安排支持和查错服务。</p> <p><font id="HHL_1178182776" style="BACKGROUND-COLOR: #ffff00">支持NGWS Runtime 的主要语言是<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>。</font>支持NGWS框架的很多程序是用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>写的，因此，在一些带有NGWS Runtime的编译器中，它的编译器可以被认为是非常经得起测试且是经过优化的。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>语言借鉴了<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>，但是具备现代化和新增的类型安全——<font id="HHL_1178182806" style="BACKGROUND-COLOR: #ffff00">使<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>成为企业解决方案的首选语言</font>。 </p> <p><strong>0.2 谁应该读这本书</strong></p> <p>如果你对编程很陌生，这本书不适合你。这本书企图让程序员解脱并使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>，基于他们已经拥有的知识。《展现 <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>》的目标瞄准了已经具有如C/<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>、<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>、<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/java/Index.html">Java</a>或其它编程经验的程序员。</p> <p>如果你具有<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的背景，转向<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>会很容易，但是，如果你精通于其它不同的语言，这本书也会耗掉你的一些日子。如果你有一点COM编程的知识，这本会更有趣，<font id="HHL_1178182848" style="BACKGROUND-COLOR: #ffff00">但会COM编程不再是必要的。 </font> </p><p><strong>0.3 这本书如何组织</strong></p> <p>第一章 <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>简介——这一章把你带到<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>逛一回，同时回答了有关你应该考虑学习<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的问题。<br>第二章 NGWS Runtime 的技术基础——介绍NGWS Runtime为运行的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>代码所提供的低层架构。<br>第三章 第一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>应用程序——创建真正第一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>应用程序(否则它是什么呢?)，它就是一个"Hello World"应用程序。<br>第四章 <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类型——可以看到用在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>应用程序中的各种类型。探索值型和引用型的区别，还有如何加框和消框。<br>第五章 类——<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>功能真正强大的标志，它是具有类的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>的编程。你会学到好多好多的东西，如构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>、析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>、方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>、索引和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>等。<br>第六章 控制语句——对应用程序实行流程控制。探索<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>提供的各种选择和陈述语句。<br>第七章 异常处理——获得了编写实现异常处理的应用程序技巧，拥有这种技巧，在NGWS Runtime世界，你是一个好的公民<br>第八章 用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>写组件——用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>构建组件，因为支持NGWS Runtime，它可以被不同语言平台的客户使用。<br>第九章 配置和安排——学到如何用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>有条件地进行编译工作，和如<font id="HHL_1178182913" style="BACKGROUND-COLOR: #ffff00">何为你的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>源码自动地创建文档</font>。另外，这一章将介绍到NGWS的版本技术问题。<br>第十章 用非受管代码交互操作——发现你如何使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>内部的非受管代码，且非受管代码如何与你的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>组件一起交互操作。<br>第十一章 <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>代码查错——获得使用SDK查错工具的技巧，可以在应用程序中准确地找到错误并修改它们。<br>第十二章 安全——探索NGWS Runtime的安全概念。学到代码访问安全性和基于角色的安全性。 </p> <p><strong>0.4 使用这本书你需要什么?</strong></p> <p>从这本书的观点看，你所需要的就是下一代windows服务软件开发包(NGWS SDK)。尽管至少只要有NGWS Runtime 和<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编译器就可以，但当探索这些激动人心的新技术功能 时，在一台机器上装有说明文件档和所有的SDK工具(包括debugger)，将是一个极好的主意。<br>这本书不需要你装在机器上的Visual Studio 7的任何工具。我仅建议你要有一个优秀的支持行数的程序编辑器，用以编辑<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>源文件。<br>……<br>(省略掉一些有关出版过程和表示感谢的段落) </p> <p><strong>0.5 关于作者</strong></p> <p>Christoph Wille，微软系统工程师(MCSE)、微软系统开发师(MCSD)、Netware网络管理员(CNA)和MCP-IT，作为一个网络咨询人员和程序员，特别精通Windows DNA。微软认为他是<a class="channel_keylink" href="http://www.bc-cn.net/Article/web/asp/Index.html">ASP</a>方面最有价值的人(MVP)，他是和微软在一起使用早期的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>版本的少数开发者之一。<br>Christoph 独自或参与了几本书的写作，包括Sams出版社的《自学ADO2.5 21天》、《自学<a class="channel_keylink" href="http://www.bc-cn.net/Article/web/asp/Index.html">ASP</a> 24小时》、《自学MCSE TCP/IP 14天》和《MCSE 训练指南：<a class="channel_keylink" href="http://www.bc-cn.net/Article/sjk/sqlserver/Index.html">SQL Server</a> 7管理》。<br></p> <p><strong>第一章 <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a> 简介</strong> 　</p> <p>欢迎您加入<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的世界！ 这一章将把您引进<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的天地，并回答一些相关的问题，如：您为什么要使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的主要有什么不同点，以及为什么<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>使开发更容易而且还使您感到很有趣。</p> <p>为什么是另外一种编程语言?<br>必须回答的一个问题：当您已经使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>或<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>从事企业开发时，为什么还要学习另一种语言? 市场式的回答就是："在企业计算领域，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>将会变成为用于编写"下一代窗口服务"(<font id="HHL_1178183001" style="BACKGROUND-COLOR: #ffff00">Next Generation Windows Services</font>,简写为NGWS )应用程序的主要语言。" 这一章将对用参数请求提供支持，并陈列了<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的一些功能。这一章会使您开胃的。</p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>语言自C/<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>演变而来。但是，它现代、简单、完全<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>和类型安全。如果您是C/<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员，学习曲线将会很平坦。许多<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>语句直接借用您所喜爱的语言，包括表达式和操作符。假如不仔细看，简直会把它当成<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>。</p> <p>关于<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>最重要的一点：它是现代的编程语言。它简化和现代化了<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>在类、名字空间、方法重载和异常处理等领域。屏弃了<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的复杂性，使它更易用、更少出错。</p> <p>对<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的易用有贡献的是减少了<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的一些特性，<font id="HHL_1178183034" style="BACKGROUND-COLOR: #ffff00">不再有宏、模板和多重继承</font>。特别对企业开发者来说，上述功能只会产生更多的麻烦而不是效益。使编程更方便的新功能是严格的<font id="HHL_1178183047" style="BACKGROUND-COLOR: #ffff00">类型安全、版本控制、垃圾收集</font>(garbage collect)等等。所有的这些功能的目标都是<font id="HHL_1178183053" style="BACKGROUND-COLOR: #ffff00">瞄准了开发面向组件的软件</font>。 </p> <p>在继续呈现出更多的功能之前，我想停下来并在下面说明<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>至关重要的各种要素。 </p> <p>简单<br>现代<br><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a><br>类型安全<br>版本控制<br>兼容<br>灵活 </p> <p><strong>简单</strong></p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>具有<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>所没有的一个优势就是学习简单。该语言首要的目标就是简单。很多功能(还不如说是缺少了<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的一些功能)有助于<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>全方位的简单。</p> <p>在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中，没有<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中流行的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>。默认地，您工作在受管理的代码中，在那里不允许如直接存取内存等不安全的操作。我想没有<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员可以声称，从没有使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>访问过不属于他们的内存。</p> <p>与<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>"戏剧性"密切相关的是"愚蠢的"操作。在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中，有::、.、和-&gt;操作符，它们用于名字空间、成员和引用。对于新手来说，操作符至今仍是学习的一道难关。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>弃用其它操作符，仅使用单个操作符 "."。现在一个程序员所需要理解的就是嵌套名字的注解了。</p> <p>您不必记住基于不同处理器架构的隐含的类型，甚至各种整型的变化范围。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>使用统一的类型系统，屏弃了<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>多变的类型系统。这种系统充许您把各种类型作为一个对象查看，它是一个原始类型还是一个full-blown 类。和其它编程语言相比，由于加框(boxing)和消框(unboxing)的机制，把简单类型当作对象处理并不能获得性能的改善。稍后将详细解释加框和消框，但基本上仅当需要时才使用对象访问简单类型这种技术。</p> <p>首先，老练的程序员可能不喜欢它，但是整型和布尔型如今终归是两种完全不同的数据类型。这就意味着原来if语句中错误的赋值现在会被编译出错，因为if语句只接受布尔类型的值。再也不会出现误用赋值符为比较符这样的错误！（首次学<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>，cnbruce就感受到了，“=”and “==”：）</p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>同时也解决了存在于<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中已经有些年头的多余东西(redundancies)。这种多余包括常数预定义，不同字符类型等。鉴于多余表单已经从该语言中消失，故一般在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中都可以使用表单了。 </p> <p></p></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item1"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> 
      <div> 
       <font id="zoomt" style="FONT-SIZE: 14px"> <p> </p> <p><strong>现代</strong></p> <p>您投入学习<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的努力是一笔大投资，因为<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>是为编写NGWS 应用程序的主要语言而设计。您将会发现很多自己用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>可以实现或者很费力实现的功能，在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中不过是一部分基本的功能而已。</p> <p>对于企业级的编程语言来说，新增的金融数据类型很受欢迎。您用到了一种新的十进制数据类型，它专用于金融计算方面。如果不喜欢这种现成简单的类型，根据您应用程序的特殊需求，可以很容易地创建出新的一种数据类型。</p> <p>我已经提到，<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>不再是您编程武器的一部分。不要太惊讶，全面的内存管理已经不是您的任务。运行时NGWS提供了一个垃圾收集器，负责<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序中的内存管理。因内存和应用程序都受到管理，所以很必要增强类型安全，以确保应用的稳定性。</p> <p>对于<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员，异常处理的切不是新的东西，但它是<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的主要功能。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的异常处理与<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的不同点在于它是交叉语言的(运行时的另一个功能)。在没有<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>之前，您必须处理怪异的HRESULTs，但现在由于使用了基于异常的健壮的出错处理， 这一切都 结束了</p> 
        <div> 
         <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
         <p>对于现代的应用程序，安全是首要的，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>也不会例外。它提供了<font id="HHL_1178183241" style="BACKGROUND-COLOR: #ffff00">元数据语法</font>，用于声明下述NGWS安全模式的能力和许可。元数据是NGWS运行时的一个关键的概念，下一章将涉及到它更深的含义。 </p> 
         <p><strong><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a></strong></p> 
         <p>您不会预料一种新语言不支持<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>的功能吧? <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>当然支持所有关键的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>的概念，如封装、继承和多态性。完整的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类模式构建在NGWS运行时的虚拟对象系统(<font id="HHL_1178183256" style="BACKGROUND-COLOR: #ffff00">VOS，Virtual Object System</font>)的上层，VOS将在下章描述。对象模式只是基础的一部分，不再是编程语言的一部分。</p> 
         <p>您一开始必须关注的事，就是不再有全局<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>、变量或者是常量。所有的东西都封装在类中，包括事例成员(通过类的事例--对象可以访问)或都静态成员(通过数据类型)。这些使<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>代码更加易读且有助于减少潜在的命名冲突。</p> 
         <p><font id="HHL_1178183286" style="BACKGROUND-COLOR: #ffff00">定义类中的方法默认是非虚拟的</font>(它们不能被派生类改写)。主要论点是，这样会消除由于偶尔改写方法而导致另外一些原码出错。要改写方法，必须具有显式的虚拟标志。 这种行为不但缩减速了虚拟<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>表，而且还确保正确版本的控制。</p> 
         <p>使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>编写类，您可以使用访问权限(access modifiers) 给类成员设置不同的访问等级。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>同样支持private、protected 和public 三种访问权限 ，而且<font id="HHL_1178183309" style="BACKGROUND-COLOR: #ffff00">还增加了第四种：internal</font>。有关访问权限 的详细情况将在第五章 "类" 中说明。</p> 
         <p>您曾经创建了多少个类是从多基类派生出来的(ATL 程序员，您的投票不计在内！) ? 大多数情况，仅需从一个类派生出。多基类惹出的麻烦通常比它们解决的问题还多。那就是为什么<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>仅允许一个基类。<font id="HHL_1178183339" style="BACKGROUND-COLOR: #ffff00">如果您觉得需要多重继承，可以运用<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。</font> </p> 
         <p>一个可能出现的问题：在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中不存在<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>，如何模仿它? 这个问题的答案很有代表性，它提供了对NGWS运行时<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>模式的支持。再次，我将把对它的全面解释放到第五章。 </p> 
         <p><strong>类型安全</strong></p> 
         <p>我再次选<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>作为一个例子。在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中拥有一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>，您能自由地把它强制转换成为任何类型，包括干出诸如把一个int*(整型<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>)强制转换成一个double *(双精度<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>)这样的傻事。只要内存支持这种操作，它就"干过"。这并不是您所想象的企业级编程语言的类型安全。</p> 
         <p>纲要性的问题，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>实施最严格的类型安全，以保护自己及垃圾收集器(garbage collector)。所以必须遵守<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中一些相关变量的规则：</p> 
         <p><font id="HHL_1178183392" style="BACKGROUND-COLOR: #ffff00">您不能使用没有初始化的变量</font>。<font id="HHL_1178183381" style="BACKGROUND-COLOR: #ffff00">对于对象的成员变量，编译器负责清零</font>。而局部变量，则由您负责清零。当您使用一个没有初始化的变量时，编译器会教您怎么做。优点是能够避免由于使用不经初始化的变量计算结果而导致的错误，而您还不知道这些奇怪的结果是如何产生的。</p> 
         <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>取消了不安全的类型转换。不能把一个整型强制转换成一个引用类型(如对象)，而当向下转换时，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>验证这种转换是正确的。(也就是说，派生类真的是从向下转换的那个类派生出来的。)</p> 
         <p><font id="HHL_1178183409" style="BACKGROUND-COLOR: #ffff00">边界检查是<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的一部分</font>。再也不会出现这种情况：当数组实际只定义了n-1个元素，却超额地使用了n个元素。</p> 
         <p>算术运算有可能溢出终值数据类型的范围。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>允许在语句级或应用程序级检测这些运算。在允许检测溢出的情况下，当溢出发生时将会抛出一个异常。</p> 
         <p>在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中，被传递的引用参数是类型安全的。 </p> 
         <p><strong>版本可控(Versionable)</strong></p> 
         <p>在过去的几年中，几乎所有的程序员都至少有一次不得不涉及到众所周知的"DLL地狱"。该问题起因于多个应用程序都安装了相同DLL名字的不同版本。有时，老版本的应用程序可以很好地和新版本的DLL一起工作，但是更多的时候它们会中断运行。现在的版本问题真是令人头痛。</p> 
         <p>就象您将在第八章"用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>写组件"所看到的，NGWS runtime 将对您所写的应用程序提供版本支持。<font id="HHL_1178183461" style="BACKGROUND-COLOR: #ffff00"><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a><font id="HHL_1178183452" style="BACKGROUND-COLOR: #ffff00">可</font>以最好地支持版本控制。</font>尽管<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>不能确保正确的版本控制，但是它可以为程序员保证版本控制成为可能。有这种支持，一个开发人员就可以确保当他的类库升级时，仍保留着对已存在的客户应用程序的二进制兼容。 </p> 
         <p><strong>兼容</strong></p> 
         <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>并没有存在于一个封闭的世界中。它允许使用最先进的NGWS的通用语言规定(Common Language Specification，简写为CLS)访问不同的API。CLS规定了一个标准，用于符合这种标准的语言的内部之间的操作。为了加强CLS的编译<font id="HHL_1178183486" style="BACKGROUND-COLOR: #ffff00">，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编译器检测所有的公共出口编译，并在通不过时列出错误</font>。<br></p> 
         <div> 
          <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
          <p>当然，您也想能够访问旧一点的COM对象。NGWS运行时提供对COM透明的访问。如何集成原来的代码将在第10章"非管理代码的内部操作"有介绍。</p> 
          <p>OLE 自动化是一种特殊的动物。任一个使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>创建OLE自动化项目的人已经喜欢上各种各样的自动化数据类型。有个好消息就是<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>支持它们，而没有烦锁的细节。</p> 
          <p>最后，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>允许您 用C 原型的API进持内部操作。可以从您的应用程序访问任何DLL中的入口点(有C的原型)。用于访问原始API的功能称作平台调用服务(<font id="HHL_1178183520" style="BACKGROUND-COLOR: #ffff00">Plaform Invocation Services ，缩写PInovke</font>)，第10章将展示使用C API进行内部操作的一些例子。 </p> 
          <p><strong>灵活</strong></p> 
          <p>上一部分的最后一段有可能提醒了程序员。您可能会问："难道就没有我要传递<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>的API吗?" 您是正确的。不是仅有少数的这种API，而是很多(有点保守的估计)。这种对原始WIN32代码的访问有时导致对非安全类指定<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>的使用(尽管它们中的一些由于受COM和PInvoke的支持可以解决)。</p> 
          <p>尽管<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>代码的缺省状态是类型安全的，但是您可以声明一些类或者仅声明类的的方法是非安全类型的。这样的声明<font id="HHL_1178183552" style="BACKGROUND-COLOR: #ffff00">允许您使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>、结构，静态地分配数组</font>。安全码和非安全码都运行在同一个管理空间，这样暗示着当从安全码调用非安全码时不会陷入列集(marshaling)。 </p> 
          <p><strong>小结</strong></p> 
          <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>语言从C和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>演变而来，它是给那些愿意牺牲<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>一点底层功能，以获得更方便和更产品化的企业开发人员而创造的。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>现代、简单、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>和类型安全。尽管它借鉴了C和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的许多东西，但是<font id="HHL_1178183574" style="BACKGROUND-COLOR: #ffff00">在一些诸如名字空间、类、方法和异常处理等特定领域，它们之间还存在着巨大的差异。</font> </p> 
          <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>为您提供了方便的功能，如垃圾收集、类型安全、版本控制，等等。仅有的"代价"就是，代码操作默认是类型安全的，不允许<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>。光是类型安全就可以搞定了。但是，如果您需要<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>，仍可以通过非安全码使用它们，而且当调用非安全码时，不能含有列集</p> 
          <p></p> 
         </div> 
         <p></p> 
        </div></font> 
      </div></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item2"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> <p><strong>第二章 理论基础－公用语言 运行环境</strong></p> <p>既然你已经具有了<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>全面的印象，我也想让你了解NGWS runtime的全貌。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>依靠由NGWS提供的运行时；因此，有必要知道运行时如何工作，以及它背后所蕴含的概念。<br>所以，这一章分为两部分——它们是所有的概念和使用的基础。两部分的内容虽然有些重叠，但它有助于加深理解正在学习的概念。</p> <p><strong>2.1 NGWS Runtime</strong></p> <p>NGWS和NGWS Runtime为你提供了一种运行时环境。该运行时管理执行代码，并提供了使编程更容易的服务。只要你的编译器支持这种运行时，你就会从这种受管理的执行环境中得益。</p> <p>你猜测<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编译器支持NGWS runtime很正确，但是不仅它支持NGWS runtime，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>也支持。这些为支持运行时所创建的代码称作"受管代码"(managed code)。以下是你的应用程序从NGWS runtime那里所得到的利益： </p> <p>交叉语言集成(通过通用语言规范)<br>自动内存管理(垃圾收集)<br>交叉语言异常处理(统一展开)<br>增强安全(包括类型安全)<br>版本支持("DLL地狱"终结者)<br>组件交互简化模式 </p> <p>因NGWS runtime 要提供了所有的这些好处，编译器必须把元文件和受管代码一起发出。元文件描述代码中的类型，它和你的代码存在一起(与PE类似---PE为可变位执行文件)</p> <p>正如你从很多种交叉语言功能所看到的，NGWS runtime主要是关于高度集成交叉多异编程语言(tight integration across multiple different programming languages)。这种支持可达到允许你从一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>对象派生出一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类的程度(我后面会给出要讨论的文章)。</p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序员将会喜欢的一个功能是，他们不必担心内存管理—也就是说不必担心臭名昭著的内存泄漏。NGWS runtime提供了内存管理，当对象和变量的生命期结束(不再被引用)时，垃圾收集器释放它们。我真的喜欢这个功能，因为在COM中的内存管理一直是我的一块心病。</p> <p>应该鼓励配置一个管理应用程序或者组件。因为管理应用程序含有元数据文件，NGWS runtime可以利用这些信息，以确保你的应用程序具有它所需的各种规定版本。所产生的明显效果为，由于你的代码没有相互之间的依赖，很少可能出现中断。</p> <p>这章余下来的将分为两部分，每一部分讨论NGWS runtime的各个方面，直到你的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>应用程序能执行为止。<br>1、中间语言(Intermediate Language，缩写IL)和元数据<br>2、即时编译器(just-in-time compliers,简称JITers) </p> <p>2.1.1 中间语言和元数据</p> <p>由<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编译器生成的受管代码并不是原始代码，但它是<font id="HHL_1178183729" style="BACKGROUND-COLOR: #ffff00">中间语言(IL)</font>代码。这种IL代码自身变成了NGWS runtime的受管执行进程的入口。IL代码明显的优势在于它是CPU无关的，这也意味着，你要用目标机器上的一个编译器才能把IL代码转换成原始代码。</p> <p>尽管IL代码由编译器产生，但它并不是编译器提供给运行时仅有的东西。编译器同样产生有关你代码的元数据，它告诉运行时有关你代码的更多的东西，例如各种类型的定义、各种类型成员的签名以及其它数据。基本上，元数据是类型库、注册表内容和其它用于COM的信息。尽管如此，元数据还是直接和执行代码合并在一起，并不处在隔离的位置。<br>IL和元数据存放于扩展了PE格式的文件中(PE格式用于.exe和.dll文件)。当这样的一个PE文件被装载时，运行时从文件中定位和分离出元数据和IL。</p> <p>在进一步说明之前，我想给你已有的IL指令的简短目录。尽管它不是一个完整的清单，也不需要你熟记和理解，但是它列出了你所必需的、<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序所基于的知识基础。 </p> <p>算术和逻辑操作符<br>控制流<br>直接内存访问<br>堆栈操作<br>参数和局部变量<br>堆栈分配<br>对象模式<br>实例类型值<br>临界区<br>数组<br>分型位置<br>即时编译器(JITters) </p></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item3"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <p> </p> 
     <p>2.1.2 即时编译器(JITters)</p> 
     <p>由<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>或其它能产生受管代码的编译器所生成的受管代码就是IL码。虽然IL代码被包装在一个有效的PE文件中，但是你还是不能执行它，除非它被转换成为受管原始代码。这就是NGWS runtime 即时编译器(也称作JITters)大显身手的时候。<br>为什么你会对即时编译代码感到厌繁， 为什么不把整个IL PE文件编译成原始代码? 答案是时间——需要把IL代码编译成CPU规格的代码的时间。这种编译将更加有效率，因为一些程序段从来就没有被执行过。例如，在我的字处理器中，邮件合并功能从来就没有被编译。<br></p> 
     <div> 
      <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
      <p>从技术上说，<font id="HHL_1178183822" style="BACKGROUND-COLOR: #ffff00">全部的处理过程</font>如下：当一个类型被装载时，装载器创建一个存根(stub)，并使它连接每一个类型的方法。当一个方法第一次被调用时，存根把控制交给JIT。JIT把IL编译为原始代码，且把存根<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>指向缓冲了的原始代码。接着的调用将执行原始码。在某些位置上(At some point)，所有的IL都被转换成为原始代码，而JITter处于空闲状态。</p> 
      <p>正如我在前面提到的，JIT编译器有很多，不止一个。在Windows平台上，NGWS runtime装有3个不同的JIT编译器。</p> 
      <p>JIT——这是NGWS runtime默认使用的JIT编译器。它是一个后台(back end)优化的编译器 ，在前台(up front)实行数据流分析，并创建了高度优化的受管原始代码做为输出结果。JIT可以使用不严格的IL指令集编码，但是所需资源将十分可观。主要的限制在于内存足迹(footprint)、结果工作集，以及实行优化所消耗的时间。</p> 
      <p>EconoJIT—— 和主JIT相比，EconJIT的目标是把IL高速地转换成受管原始代码。它允许缓冲所产生的原始代码，但是输出码并不象主JIT生成的代码那样优化(代码小)。当内存紧张时，快速代码生成方案的优势将荡然无存。通过永久地抛弃无用的已JIT过的代码，你可以把更大的IL程序装入代码缓冲区。因为JIT编译快，执行速度也仍然很快。</p> 
      <p>PreJIT—尽管它是基于主JIT的，但操作起来更象是一个传 统的编译器。你安装了NGWS组件，它才能运行，才可以把IL代码编译成受管原始代码。当然最终的结果为，更快的装载时间和更快的应用程序启动时间(不需要更多的JIT编译)。</p> 
      <p>在所列出的JITters中，有两个是运行时的JITters。可是你怎么决定要使用哪一个JIT，它如何使用内存? 有一个称做"JIT编译管理器"的小应用程序(jitman.exe)，它存放于NGWS SDK安装目录下的bin目录中。</p> 
      <p>尽管它是一个小小的对话框，可是你所选择的选项功能是相当强大的。每一个选项将在以下描述。</p> 
      <p>Use EconoJIT only 选项——当该复选框没有选上时，NGWS runtime使用默认的正常的JIT编译器。前面就曾经解释过两种JITter的区别。</p> 
      <p>Max Code Pitch Overhead(%)选项——该设置仅保留给EconoJIT。它控制了JIT编译时间和执行代码时间的百分比。如果超过了设定的域值，代码缓冲区得到扩充，以缩短JIT编译所消耗的时间。</p> 
      <p>Limit Size of Code Cache选项——该项默认为非选。没有选择该项意味着缓冲区将使用它所能得到的内存。如果你想限制缓冲区大小，复选该选项，这将允许你使用Max Size of Cache(bytes)选项。</p> 
      <p>Max Size of Cache(bytes)选项—控制容纳JIT代码的缓冲区的最大值。虽然你可以非常严格地限制这个值，但你还是应该小心，不能超过这个缓冲区所适合的最大值。否则该方法的JIT编译将会失败。</p> 
      <p>Optimize For Size选项——告诉JIT 编译器，优化的目的是为了使代码更小而不是能执行得更快。这个设置默认是关掉的。</p> 
      <p>Enable Concurrent GC[garbage collection]选 项——垃圾收集(GC)默认地运行在用户代码的线程中。意味GC发生时，可能会注意到回应有轻微的延迟。为防止出现该现象，打开当前GC。注意，当前GC比标准GC更慢，它仅在windows 2000上写时(the time of writing)有效。</p> 
      <p>当用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>创建项目时，你可能使用不同的设置试验过。当创建 UI-intensive应用程序时，你将会看到允许当前GC的最大差别。 </p> 
      <p><strong>2.2 虚拟对象系统(VOS)</strong></p> 
      <p>到目前为止，你仅看到了NGWS runtime如何工作，但是并不了解它工作的技术背景以及为什么它要这样工作。这节都是关于 NGWS 虚拟对象系统的(VOS)。</p> 
      <p>以下为在VOS中形成声明、使用和管理类型模型时，NGWS runtime的规则。在VOS背后的思想是建立一个框架，在执行代码时不能牺牲性能，允许交叉语言集成和类型安全。</p> 
      <p>我提到的框架是运行时架构的基础。为了帮助你更好地了解它，我将它勾出四个区域。当开发<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>应用程序和组件时，理解它们很重要。</p> 
      <p><font id="HHL_1178183989" style="BACKGROUND-COLOR: #ffff00"><font id="HHL_1178183991" style="BACKGROUND-COLOR: #ffff00">VOS类</font>型系统</font>——提供丰富的类型系统，它打算支持全面编程语言的完全实施。<br><font id="HHL_1178183992" style="BACKGROUND-COLOR: #ffff00">元数据</font>——描述和引用VOS类型系统所定义的类型。元数据的永久格式与编程语言无关，但是，元数据拿自己当作一种互换机制(nterchange mechanism)来使用，这种互换是在在工具和NGWS的虚拟执行系统之间。</p> 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item4"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p> </p> <p><font id="HHL_1178183994" style="BACKGROUND-COLOR: #ffff00">通用语言规范(CLS</font>)——CLS定义了VOS中类型的子集，也定义了常规的用法。如果一个类库遵守CLS的规则，它确保类库可以在其它所有能实现CLS的编程语言上使用。</p> <p><font id="HHL_1178184001" style="BACKGROUND-COLOR: #ffff00">虚拟执行系统(VES</font>)——这是VOS实时的实现。VES负责装入和执行为NGWS运得时编写的程序。</p> <p>这四个部分一起组成了NGWS runtime架构。每一部分在下面小节中描述。 </p> <p><strong>2.2.1 VOS类型系统</strong></p> <p>VOS类型系统提供丰富的类型系统，它打算支持多种编程语言的完全实施。所以，VOS必须都支持<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>的语言和过程编程语言。</p> <p>现在，存在着很多种近似但有点不兼容的类型。就拿整型当例子，在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>中，它是16位长，而在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中，它是32位。还有更多的例子，特别是用在日期和时间以及<a class="channel_keylink" href="http://www.bc-cn.net/Article/sjk/Index.html">数据库</a>方面的数据类型。这种不兼容使应用程序的创建和维护不必要地复杂化，尤其当程序使用了多种编程语言时。</p> <p>另一个问题是，因为编程语言之间存在着一些差别，你不能在一种语言中重用另一种语言创建的类型。(COM用二进制标准<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>部分地解决了这个问题)。 当今代码重用肯定是有限的。</p> <p>发布应用程序的最大障碍是各种编程语言的对象模型不统一。几乎每一方面都存在着差异：<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>、永久保存(persistence)等等。</p> <p>VOS这里将改变 这种现象 。VOS定义了描述值的类型，并规定了类型的所有值所必须支持的一条合约。由于前面提到的支持<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>和过程编程语言，就存在着两种值和对象。 </p> <p>对于值，类型存储于表述(representation)中，同样操作也在其中实行。对象更强大因为它显式地存于表述中。每一个对象都有一个区别于其它对象的识别号。支持不同的VOS类型在第四章 "<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类型"中提出。 </p> <p><strong>2.2.2元数据</strong></p> <p>尽管元数据用于描述和引用由VOS类型系统定义的类型，但它还不能锁定到这个单个目标。当你写一个程序时，通过利用类型声明，你所声明的类型(假定它们是数值类型或引用类型)被介绍给NGWS runtime类型系统。类型声明在存于PE可执行文件内部的元数据中得到描述。</p> <p>基本上，元数据用于各项任务：用于表示NGWS runtime用途的信息，如定位和装载类、 内存中这些类的事例、解决调用 、翻译IL为原始码、加强安全并设置运行时上下文边界。</p> <p>你不必关心元数据的生成。元数据是由<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的"代码转IL编译器"(code-to-IL compiler,不是JIT编译器)生成的。代码转IL编译器发送二进制元数据信息给PE文件，是以标准的方式发送的，不象<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>编译器那样，为出口<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>创建它们自己的修饰名字。</p> <p>你从元数据和可执行代码并存所获得的主要优势为，有关类型的信息同类型自身固定在一起，不会遍布很多地方。同样有助于解决存在于COM中的版本问题。进一步地，你可以在相同的上下文中使用不同的版本库，因为库不仅被注册表引用，也被包含在可执行代码中的元数据引用。 </p></td></tr></tbody></table> 
<p> </p> 
 
<a name="wbs-bookmark-item5"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p> </p> <p><strong>2.2.3通用语言规范</strong></p> <p>通用语言规范(CLS)并不是虚拟对象系统(VOS)真正的一部分，它是特殊的。CLS定义了VOS中的一个类型子集，也定义了必须符合CLS的常规用法。</p> <p>那么，对此有什么迷惑呢?如果一个类库遵守CLS规则，其它编程语言同样也遵守CLS规则，那么其它编程语言的客户也可以使用类库。CLS是关于语言的交互可操作性(interoperability)。因此，常规用法必须仅遵循外部可访问项目 (externally visible items)如方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>等等。</p> <p>我所描述的优点是你可以做以下工作。用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>写一个组件，在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>中派生它，因加在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>中的功能是如此之强大，在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中再次从<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>类派生它。只要所有的外部可访问项遵守CLS规则，这样是可行的。<br>我在这本书中出示的代码不关心CLS协定。但在构建你的类库时要注意到CLS协定。我提供了表2.1，用以给类型和外部可访问项定义协定规则。</p> <p>这个清单不完整。它仅包含一些很重要的项目。我不指出出现在本书中每一种类型的CLS协定，所以有个好主意：当你寻找CLS协定时，至少应该用浏览该表，以了解哪种功能有效。不要担心你不熟悉这章表中的每一个含义，在这本书中你会学到它们。 </p> <p>表2.1 <font id="HHL_1178184195" style="BACKGROUND-COLOR: #ffff00">通能语言规范中的类型和功能</font> </p> <p>bool<br>char<br>byte<br>short<br>int<br>long<br>float<br>double<br><font id="HHL_1178184199" style="BACKGROUND-COLOR: #ffff00">string<br></font>object(<font id="HHL_1178184201" style="BACKGROUND-COLOR: #ffff00">所有对象之母</font>)<br>Arrays(<font id="HHL_1178184203" style="BACKGROUND-COLOR: #ffff00">数组</font>)</p> <p><br>数组的维数必须是已知的(&gt;=1)，而且最小下标数必须为0。<br>要素类型必须是一个CLS类型。 </p> <p>类型(Types)</p> <p>可以被抽象或隐藏。<br>零或更多的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>可以被实现。不同的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>允许拥有具有相同名字和签名的方法。<br>一个类型可以准确地从一个类型派生。允许成员被覆盖和被隐藏。<br>可以有零或更多的成员，它们是字段(fields)、方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>或者类型。<br>类型可以拥有零或更多个构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。<br>一种类型的可访问性可以是公共的或者对NGWS组件来说是局部的；但是，仅公共成员可以认为是类型<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>的一部分。<br>所有的值型必须从系统值型继承。异常是一个枚举——它必须从系统枚举(System Enum)继承。</p> <p>类型成员</p> <p>类型成员允许隐藏或者覆盖另一种类型中的其它成员。<br>参数和返回值的类型都必须是 CLS 协定 类型。<br>构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>、方法和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>可以被重载。<br>一个类型可以有抽象成员，但仅当类型不被封装时。 </p> <p>方法</p> <p>一种方法可以是静态、虚拟或者实例。<br>虚拟和实例方法可以是抽象的，或者是一个实现。静态方法必须总拥有一个实现。<br>虚拟方法可能是最后的(或者不是)。 </p> <p>字段(Fields)</p> <p>可以是静态或者是非静态。<br>静态字段可以被描述或只初始化。 </p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a></p> <p>当获取和设置方法而不是使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>语法时，<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>可以公开。<br>获取的返回类型和设置方法的第一个参数必须是相同的CLS类型——<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>的类型。<br><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>名字必须不同，不同的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>类型用于区分是不充分的。<br>由于使用方法实现<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>访问，如果 PropertyName 是同一个类中定义的一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>，你不能实现命名为 get_PropertyName 和 set_PropertyName 的方法。<br><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>可以被索引。<br><font id="HHL_1178184259" style="BACKGROUND-COLOR: #ffff00"><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>访问必须遵循这种命名格</font>式：get_ProName，set_PropName。 </p> <p>枚举(Enumerations)</p> <p><font id="HHL_1178184294" style="BACKGROUND-COLOR: #ffff00">强调类型</font>必须是byte、short、int 或long。<br>每一个成员是一个枚举类型的静态描述字段。<br>一个枚举不能实现任何<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。<br>你允许给多字段设定相同的值。<br>一个枚举<font id="HHL_1178184301" style="BACKGROUND-COLOR: #ffff00">必须继承系统枚举(</font>隐含在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中) </p> <p>异常</p> <p>可以被引发和被捕获。<br>自定义异常<font id="HHL_1178184309" style="BACKGROUND-COLOR: #ffff00">必须继承系统异常</font>。 </p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a></p> <p>可需要实现其它<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。<br>一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>可以定义<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>和虚拟方法。实现取决于派生类。</p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a></p> <p>增加和取消方法必须是都提供或者都没有 ，每一种方法采用一个参数，它是一个从系统代表元(System Delegate)派生下来的类。 </p> <p>自定义<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a></p> <p>可以仅使用下更类型：Type(类型),char, char, bool, byte, short, int, long, float, double, enum (一种CLS 类型), and object. </p> <p>代表元(Delegates)</p> <p>可以被创建和被激活 </p> <p>标识符(Identifiers)</p> <p>一个标识符的第一个字母必须来自一限制集。<br>通过大小写在单一范围内，不可能唯一地区别两个或更多个标识符(大小写不敏感)。 </p></td></tr></tbody></table> 
<p> </p> 
 
<a name="wbs-bookmark-item6"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p> </p> <p><strong>2.2.4虚拟执行系统(VES)</strong></p> <p>虚拟执行系统实现了虚拟对象系统。通过实现一个负责NGWS runtime的执行引擎(execution engine，缩写EE)创建VES。这个执行引擎执行你用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编写和编译的应用程序。</p> <p>下列组件为VES的一部分。<br>1、中间语言(IL)——被设计为很容易受各种各样的编译器所兼容 。在该框架之外，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>、<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编译器都能够生成IL。<br>2、装入受管代码——这包括解决内存中的名字、 表层类(laying out classes )，并且创建JIT编译所必需的存根。通过执行经常性校验，包括加强一些访问规则，类装载器同样也增强了安全性。<br>3、用JIT转换IL成原始代码——IL代码并不是设计成为一种传统的解释字节代码或树型代码，IL转换是真正的编译。<br>4、装入元数据、校验类型安全和方法的完整性<br>5、垃圾收集(GC)和异常处理——两者都是基于堆栈格式的服务。受管代码允许你动态地跟踪堆栈。要动态地识别各个堆栈框架，JITter或其它编译器必须提供一个代码管理器。<br>6、描绘和查错服务——两者都取决于由源语言编译器所生成的信息。必须发出两个映射：一个映射从源语言结构发到指令流中的地址，一个映射从地址发到堆栈框架中的位置。当执行从IL到原始代码的转换时，这些映射被重新计算。<br>7、管理线程和上下文，还有远程管理——VES为受管代码提供这些服务。<br>虽然这个清单并不完整，但它足以让你理解运行时基于的由VES提供的低层架构。肯定将会有专门讨论运行时的书，而这本书将稍为深入地挖掘各种话题。</p> <p><br><strong>2.3 小结</strong></p> <p>这一章，我带你逛了一回运行时的世界。我描述了当创建、编译和配置<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序时它是如何工作的。你学会了中间语言(IL)，还有元数据是如何用于描述被编译为IL的类型。元数据和IL都用于JITter检测和执行你的代码。你甚至可以选择用哪一种JITter来执行应用程序。<br>在这一章的第二部分，涉及到了运行时为何按这种方式工作的理论。你学了虚拟对象系统(VOS)和组成它的那部分。对于类库设计者最为感兴趣的就是通用语言规范(CLS)，它为基于VOS的语言交互操作设定规则。最后，你看到了虚拟执行系统(VES)如何通过NGWS runtime实现VOS。</p></td></tr></tbody></table> 
<p> </p> 
 
<a name="wbs-bookmark-item7"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"><font id="zoomt" style="FONT-SIZE: 14px"> <p><strong>第三章 第一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>应用程序</strong><br> <br><strong>3.0 选择一个编辑器</strong></p> <p>尽管我是一个顽固的Notepad狂，但这次我不建议用它编辑源码。原因是你正在与真正的编程语言打交道，使用Notepad编辑源码编译时可能产生大量的错误信息行(<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员知道我在说什么。)</p> <p>你有几种选择。可以重新配置你信任的老式Visual <a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a> 6.0，使它能够和<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>源文件一起工作。第二种选择是使用新的Visual Studio 7。第三，你可以用任何第三方程序编辑器，最好要支持行数、色彩编码、工具集成和良好的搜索功能。CodeWright就是其中一个例子，CodeWright 是你可以用于创建<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>代码文件众多可能编辑器中的一个。 </p> <p>当然，在所提到的编辑器中，没有一个对创建<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序来说是必要的。用Notepad肯定可以编辑。但是，如果你考虑到要编写更大的项目，最好还是忍痛割爱吧。（<font id="HHL_1178184476" style="BACKGROUND-COLOR: #ffff00">cnbruce建议采用Visual Studio .Net</font>） </p> <p>3.1 "Hello World" 代码</p> <p>讨论编辑器有点离题 ，让我们把话题转回到一个非常出名的小应用程序。这个最短的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>版本应用程序见清单3.1。把它存起来，文件名为 helloworld.cs，以便使你能按照说明，完成诸如编译应用程序等其它余下来的步骤。 </p> <p>清单 3.1 最简单的 "Hello World "程序 （1，2，3，……7为行号，非程序：）</p> 
       <div class="quote">
         1: class HelloWorld 
        <br>2: { 
        <br>3: public static void Main() 
        <br>4: { 
        <br>5: System.Console.WriteLine("Hello World"); 
        <br>6: } 
        <br>7: } 
       </div> <p>在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中，代码块(语句组)由大括弧({和})所括住。所以，甚至你以前没有<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的经验，你也可以说出Main()方法就是HelloWorld 类语句的一部分，因为类被括在所定义的大括弧中。</p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html"><font id="HHL_1178184549" style="BACKGROUND-COLOR: #ffff00">C#</font>，它<font id="HHL_1178184551" style="BACKGROUND-COLOR: #ffff00">必须包含在一个类中</font>。<font id="HHL_1178184558" style="BACKGROUND-COLOR: #ffff00">仅有一个类能使用该标志定义</font>，除非你<font id="HHL_1178184569" style="BACKGROUND-COLOR: #ffff00">告诉编译器它应使用哪一个 Main 方法</font>(否侧，会产生一个编译错误)。</a>应用程序(可执行)的入口点就是 static Main 方法</p> <p>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>相比，<font id="HHL_1178184581" style="BACKGROUND-COLOR: #ffff00">Main的第一个字母是大写的M</font>，而不是你曾经使用过的小写字母。在这个方法中，你的程序开始并结束。方法中可以调用其它方法——如这个例子中，用于输出文本——或者创建对象并激活该方法。</p> <p>正如你所看到的，<font id="HHL_1178184589" style="BACKGROUND-COLOR: #ffff00">Main方法返回一个void类型</font>。<br>public static void Main()</p> <p>尽管看到这些语句时，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员肯定会觉得似曾相识，但是其他程序员并不如此。首先，public 的访问标志告诉我们这个方法可以被任何程序访问，这是它被调用的必要条件。其次，<font id="HHL_1178184611" style="BACKGROUND-COLOR: #ffff00">static 意味着没有先创建类的实例也可以调用方法——你所要做的就是用类名调用方法。<br></font>HelloWorld.Main();</p> <p>但是<font id="HHL_1178184628" style="BACKGROUND-COLOR: #ffff00">，我不赞成在Main方法中执行这行代码，递归会导致堆栈溢出</font>。</p> <p>另一重要的方面是返回类型。对于方法Main，可选择void (意味着根本就没有返回值)，或用int 为整型结果(应用程序返回的错误级别)。因此，两种可能的Main方法为：<br>public static void Main()<br>public static int Main() </p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员会同样知道后面我要提到的——可以传给应用程序的命令行参数数组。如：<br>public static void Main(string[] args) </p> <p>我现在并不想详细地说明如何访问参数，但我想事先给<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员一个警告：和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>相比，<font id="HHL_1178184658" style="BACKGROUND-COLOR: #ffff00">应用程序路径不是这个数组的一部分。仅仅那些参数包含在这个数组中。</font> </p><p>在对Main方法并不简短的介绍之后，让我们把注意力集中到唯一真正的代码行——这行代码在屏幕上显示"Hello Wold"。<br>System.Console.WriteLine("Hello World");</p> <p>假如不是由于有了System，大家会马上猜到WriteLine是Console 对象的一个静态方法。那么System代表什么呢? <font id="HHL_1178184687" style="BACKGROUND-COLOR: #ffff00">它是包含Console对象的名字空间(范围)，</font>实际上并不是每次都在Console对象前加上名字空间的前缀，你可以象清单3.2所示范的那样，在应用程序中引入名字空间。 <br></p> 
       <div> 
        <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
        <p>清单3.2 在应用程序中引入名字空间</p> 
        <div class="quote">
          1: using System; 
         <br>2: 
         <br>3: class HelloWorld 
         <br>4: { 
         <br>5: public static void Main() 
         <br>6: { 
         <br>7: Console.WriteLine("Hello World"); 
         <br>8: } 
         <br>9: } 
        </div> 
        <p>所有你要做的就是给System名字空间加一个using指令。在这之后，<font id="HHL_1178184703" style="BACKGROUND-COLOR: #ffff00">不再需要规定名字空间，</font>就可以使用它们的方法和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>了。NGWS 框架体系中有很多的名字空间，我只对巨大的名字空间池中的少数几个对象进行探讨。但在第八章 "用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>写组件"将介绍为你的对象创建自己的名字空间。 </p> 
       </div> <p></p></font></font> 
    </div></td></tr></tbody></table> 
<div></div> 
 
<a name="wbs-bookmark-item8"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <p> </p> 
     <p><strong>3.2 编译应用程序</strong></p> 
     <p>由于NGWS Runtime支持所有的编译器(<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>、<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>)，你不必买一个单独的开发工具用来把应用程序编译成IL(中间语言)。但是，如果你从没有用过命令行编译器编译过应用程序(仅懂得编译名，而没有熟记)， 它还是你的首要选择。<br>打开命令提示符并切换到存 helloworld.cs 的目录。敲入以下命令：</p> 
     <div class="quote">
       csc helloworld.cs 
     </div> 
     <p>helloworld.cs 被编译并链接成hellworld.exe。因为源码没有错误(那当然！)，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编译器没有出错提示，在整个编译过程没有丝毫停顿。</p> 
     <p>现在你已经准备好运行第一个真正用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编写的应用程序。简单地在命令行上敲入helloworld，输出结果为 "Hello World"。</p> 
     <p>在继续往下介绍之前， 我想稍为想象一下第一个应用程序和一个编译器开关的使用：<br>csc /out:hello.exe helloworld.cs</p> 
     <p><font id="HHL_1178184772" style="BACKGROUND-COLOR: #ffff00">这个开关告诉编译器输出文件命名为hello.exe</font>。虽然这不是什么绝招，但它是这本书中用到的未来编译器的基本功。</p> 
     <p><strong>3.3 输入和输出</strong></p> 
     <p>到目前为止，我仅仅演示了把简单的常量字符串输出到屏幕。尽管这本书只介绍了<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编程的概念而不介绍用户<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>编程，但我需要让你迅速学会简单的屏幕输入和输出方法——相应于C的scanf 和 printf，或者<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>的cin 和cout。我不能提供<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>相应的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>，因为屏幕访问不是该核心语言的一部分。<br>你只需要能够读用户的输入并提示一些信息给用户。清单3.3 说明如何读一个用户请求的名字输入，并显示一条已定制好的"Hello" 信息。 </p> 
     <p>Listing 3.3 <font id="HHL_1178184807" style="BACKGROUND-COLOR: #ffff00">从控制台读输入信息</font> </p> 
     <div class="quote">
       1: using System; 
      <br>2: 
      <br>3: class InputOutput 
      <br>4: { 
      <br>5: public static void Main() 
      <br>6: { 
      <br>7: Console.Write("Please enter your name: "); 
      <br>8: string strName = Console.ReadLine(); 
      <br>9: Console.WriteLine("Hello " + strName); 
      <br>10: } 
      <br>11: } 
     </div> 
     <p>第7行使用Console对象的一个新方法用于提示文本信息给用户，它就是Write方法。它与WriteLine不同的地方在于<font id="HHL_1178184843" style="BACKGROUND-COLOR: #ffff00">它输出时不换</font><font id="HHL_1178184846" style="BACKGROUND-COLOR: #ffff00">行</font>。我使用这种方法以便用户可以在信息提示的同一行输入名字。<br>在用户输入他的名字后(并按回车键)，ReadLine 方法读入了一个字符串变量。名字字符串连接到常量字符串"Hello"，并用我们早已熟悉的WriteLine方法显示出来</p> 
     <p>你几乎已学完了NGWS框架必要的输入和输出功能。但是，你还需要为用户显示多个值。为用户写一个格式串。清单3.4展示一个例子。 </p> 
     <p>清单 3.4 <font id="HHL_1178184865" style="BACKGROUND-COLOR: #ffff00">使用不同的输出方法</font></p> 
     <div class="quote">
       1: using System; 
      <br>2: 
      <br>3: class InputOutput 
      <br>4: { 
      <br>5: public static void Main() 
      <br>6: { 
      <br>7: Console.Write("Please enter your name: "); 
      <br>8: string strName = Console.ReadLine(); 
      <br>9: Console.WriteLine("Hello {0}",strName); 
      <br>10: } 
      <br>11: } 
     </div> 
     <p>第9行包含了使用格式串的Console.WriteLine语句。格式串例子如下：<br>"Hello {0}"<br><font id="HHL_1178184879" style="BACKGROUND-COLOR: #ffff00">{0}代替WriteLine方法的参数表中紧随格式串后的第一个变量</font>。你可以用该技术格式化超过三个变量。<br>Console.WriteLine("Hello {0} {1}, from {2}", <br>strFirstname, strLastname, strCity); <br></p> 
     <div> 
      <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
      <p>当然，并不仅限于只使用字符串变量。<font id="HHL_1178184888" style="BACKGROUND-COLOR: #ffff00">你可以使用任何类型</font>，这些类型在后面的第四章 "<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类型"中有讨论。 </p> 
      <p><strong>3.4 添加注释</strong></p> 
      <p>当写代码时，你应为代码写注释条文，解释实现的内容、变更史等。尽管你注释中提供的信息(如果有的话)是给你写的，但是你还是必须遵守写<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>注释的方法。清单3.5 显示采用的两种不同的方式。 </p> 
      <p>清单3.5 给你的代码添加注释 </p> 
      <div class="quote">
        1: using System; 
       <br>2: 
       <br>3: class HelloWorld 
       <br>4: { 
       <br>5: public static void Main() 
       <br>6: { 
       <br>7: // 这是单行注释 
       <br>8: /* 这种注释 
       <br>9: 跨越多行 */ 
       <br>10: Console.WriteLine(/*"Hello World"*/); 
       <br>11: } 
       <br>12: } 
      </div> 
      <p>"//" 符号用于单行注释。你可以用"//"注释当前所在行，或是跟在一个代码语句的后面：<br>int nMyVar = 10; // 胡说八道<br>所有在"//"后面的被认为是一条注释；所以，你可以同样用它们来注释一整行或一行源代码的部分。这种注释方式同<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中介绍的相似。</p> 
      <p>如果你的注释跨越多行，必须使用"/* */"的字符组合。这种方式在C中有效。除了单行注释外，这种方式在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中还同样有效。因C/<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>都使用这种多行注释方式，所以它们也使用相同的终结符。请看下列代码行：<br>/* Console.WriteLine("Hello World"); */ </p> 
      <p>我使用"/* */"简单地注释一整行。现在我假定这一行是很长代码的一部分，而且我决定要暂时禁用一个程序块：<br>/*<br>...<br>/* Console.WriteLine("Hello World"); */<br>...<br>*/ </p> 
      <p>这个结构所存在的问题为： "Hello World"那一行后面的"*/"终止了始于第一行的"/*"的注释，余下的代码对编译器有效，你将看到一些有趣的出错信息。至少 最后的"*/"被标志为归属错误。我只不过想提醒一下，让你了解这种错误。 </p> 
      <p><strong>3.5小结</strong></p> 
      <p>在这一章中，你创建、编译并执行了第一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>应用程序：著名的"Hello World"程序。我用这个短短的应用程序给你介绍有关Main方法，它是一个应用程序的入口点，也是出口点。这个方法可以没有返回值或返回一个整数错误级别。如果你的应用程序用参数调用，你可以(但不必要)读出并使用它们。</p> 
      <p>在编译和测试应用程序后，你学到了更多的由Console对象提供的有关输入和输出的方法。对于学习<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>而言，它们足以创建出有意义的控制台例子，但用户<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>的大部分将是WFC、WinForms或者<a class="channel_keylink" href="http://www.bc-cn.net/Article/web/asp/Index.html">ASP</a>+（<a class="channel_keylink" href="http://www.bc-cn.net/Article/web/asp/Index.html">ASP</a>.NET）。</p> 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item9"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> <p><strong>第四章 <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类型</strong> </p> <p>既然你知道了怎样创建一个简单的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序，我将会给你介绍<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的类型系统。在这一章中，你学到如何使用不同的值和引用类型，加框和消框机制能为你作些什么。尽管这一章的不侧重于例子，但你可以学到很多重要的信息，关于如何创建现成类型的程序。</p> <p><strong>4.1 值类型</strong> </p> <p>各种值类型总是含有相应该类型的一个值。<font id="HHL_1178185000" style="BACKGROUND-COLOR: #ffff00"><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>迫使你初始化变量才能使用它们进行计算</font>-变量没有初始化不会出问题，因为当你企图使用它们时，编译器会告诉你。 每当把一个值赋给一个值类型时，该值实际上被拷贝了。相比，对于引用类型，仅是引用被拷贝了，而实际的值仍然保留在相同的内存位置，但现在有两个对象指向了它（引用它）。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的值类型可以归类如下：<br>·简单类型（Simple types ）<br>·结构类型（struct types）<br>·枚举类型（Enumeration types）</p> <p>4.1.1 简单类型</p> <p>在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中出现的简单类型共享一些特性。第一，它们都是.NET系统类型的别名。第二，由简单类型组成的常量表达式仅在编译时而不是运行时受检测。最后，简单类型可以按字面被初始化。以下为<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>简单类型归类：<br>·整型<br>·布尔型<br>·字符型 (整型的一种特殊情况)<br>·浮点型<br>·小数型 </p> <p>4.1.1.1 整型<br><font id="HHL_1178185056" style="BACKGROUND-COLOR: #ffff00"><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中有9个整型</font>。 sbyte 、byte、 short、 ushort、 int、 uint、 long、 ulong 和 char（单独一节讨论）。它们具有以下特性： </p> <p>·sbyte型为有符号8位整数，取值范围在128~127之间。 <br>·bytet型为无符号16位整数，取值范围在0~255之间。<br>·short型为有符号16位整数，取值范围在-32,768~32,767之间。<br>·ushort型为无符号16位整数，取值范围在0~65,535之间。<br>·<font id="HHL_1178185084" style="BACKGROUND-COLOR: #ffff00">int型为有符号32位整数</font>，取值范围在-2,147,483,648~ 2,147,483,647之间。<br>·uint型为无符号32位整数，取值范围在 0 ~ 4,294,967,295之间。 <br>·<font id="HHL_1178185085" style="BACKGROUND-COLOR: #ffff00">long型为64位有符号整数</font>，取值范围在9,223,372,036,854,775,808~ 9,223,372,036,854,775,807之间。<br>·ulong型为64位无符号整数，取值范围在0 ~ 18,446,744,073,709,551,615之间。 </p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>和C程序员都可能会对int和long数据类型所代表的新范围感到惊讶。和其它的编程语言相比，在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中，int不再取决于一个机器的字（word)的大小，而long被设成64位。 </p> <p>4.1.1.2 布尔型</p> <p>布尔数据类型有true和false两个布尔值。可以赋于true或false值给一个布尔变量，或可以赋于一个表达式，其所求出的值等于两者之一：<br>bool bTest = (80 &gt; 90);<br>与C和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>相比，在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中，<font id="HHL_1178185098" style="BACKGROUND-COLOR: #ffff00">true值不再为任何非零值</font>。不要为了增加方便而把其它整型转换成布尔型。 </p> <p>4.1.1.3 字符型</p> <p>字符型为一个单Unicode 字符。一个Unicode字符16位长，它可以用来表示世界上多种语言。可以按以下方法给一个字符变量赋值：<br>char chSomeChar = 'A';<br>除此之外，可以通过十六进制转义符（前缀/x）或Unicode表示法给变量赋值（前缀/u）：<br>char chSomeChar = '/x0065';<br>char chSomeChar = '/u0065';<br><font id="HHL_1178185130" style="BACKGROUND-COLOR: #ffff00">不存在把char转换成其它数据类型的隐式转换</font>。这就意味着，在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中把一个字符变量当作另外的整数数据类型看待是行不通的——这是C程序员必须改变习惯的另一个方面。但是，可以运用显式转换：<br>char chSomeChar = (char)65;<br>int nSomeInt = (int)'A';<br>在C中仍然存在着转义符（字符含义）。要换换脑筋，请看表4.1。 </p> <p>Table 4.1 转义符（ Escape Sequences） </p> <p><font id="HHL_1178185154" style="BACKGROUND-COLOR: #ffff00">转义符 字符名<br></font>/' 单引号<br>/" 双引号<br>// 反斜杠<br>/0 空字符<br>/a 感叹号（Alert ）<br>/b 退格<br>/f 换页<br>/n 新行<br>/r 回车<br>/t 水平 tab<br>/v 垂直tab </p></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item10"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <p> </p> 
     <div> 
      <font id="zoomt" style="FONT-SIZE: 14px"> <p>4.1.1.4 浮点型</p> <p>两种数据类型被当作浮点型：float和double。它们的差别在于取值范围和精度：<br>float: 取值范围在 1.5x10^-45~ 3.4x10^38之间， <font id="HHL_1178185172" style="BACKGROUND-COLOR: #ffff00">精度为7位数</font>。 <br>double: 取值范围在 5.0x10^-324 ~ 1.7x10^308之间， <font id="HHL_1178185173" style="BACKGROUND-COLOR: #ffff00">精度为 15~16 位数。</font><br>当用两种浮点型执行运算时，可以产生以下的值：<br>正零和负零<br>正无穷和负无穷<br>非数字值（Not-a-Number，缩写NaN）<br>非零值的有限数集<br>另一个运算规则为，<font id="HHL_1178185190" style="BACKGROUND-COLOR: #ffff00">当表达式中的一个值是浮点型时，所有其它的类型都要被转换成浮点型才能执行运算</font>。 </p> <p>4.1.1.5 小数型（The decimal Type)</p> <p>小数型是一种高精度、128位数据类型，它打算<font id="HHL_1178185199" style="BACKGROUND-COLOR: #ffff00">用于金融和货币的计</font>算。它所表示的范围从大约1.0x10^-28 到 7.9x10^28，具有28至29位有效数字。要注意，精度是以位数 (digits)而不是以小数位（decimal places)表示。运算准确到28个小数位的最大值。</p> <p>正如你所看到的，它的取值范围比double的还窄，但它更精确。因此，没有decimal和double之间的隐式转换——往一个方向转换可能会溢出，往另外一个方向可能会丢失精度。你不得不运用显式转换。</p> <p>当定义一个变量并赋值给它时，<font id="HHL_1178185232" style="BACKGROUND-COLOR: #ffff00">使用 m 后缀以表明它是一个小数型</font>：<br>decimal decMyValue = 1.0m;<br>如果省略了m，在变量被赋值之前，它将被编译器认作double型。 </p> <p>4.1.2 结构类型</p> <p>一个结构类型可以声明构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>、常数、字段、方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>、索引、操作符和嵌套类型。尽管列出来的功能看起来象一个成熟的类，但在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中，<font id="HHL_1178185257" style="BACKGROUND-COLOR: #ffff00">结构和类的区别在于结构是一个值类型，而类是一个引用类型</font>。与<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>相比，这里可以用结构关键字定义一个类。</p> <p><font id="HHL_1178185266" style="BACKGROUND-COLOR: #ffff00">使用结构的主要思想是用于创建小型的对象</font>，如Point和FileInfo等等。你可以节省内存，因为没有如类对象所需的那样有额外的引用产生。例如，当声明含有成千上万个对象的数组时，这会引起极大的差异。</p> <p>清单4.1 包含一个命名为IP的简单结构，它表示一个使用byte类型的4个字段的IP地址。我不包括方法等，因为这些工作正如使用类一样，将在下一章有详细的描述。 </p> <p>清单4.1 定义一个简单的结构 </p> 
       <div class="quote">
         1: using System; 
        <br>2: 
        <br>3: struct IP 
        <br>4: { 
        <br>5: public byte b1,b2,b3,b4; 
        <br>6: } 
        <br>7: 
        <br>8: class Test 
        <br>9: { 
        <br>10: public static void Main() 
        <br>11: { 
        <br>12: IP myIP; 
        <br>13: myIP.b1 = 192; 
        <br>14: myIP.b2 = 168; 
        <br>15: myIP.b3 = 1; 
        <br>16: myIP.b4 = 101; 
        <br>17: Console.Write("{0}.{1}.",myIP.b1,myIP.b2); 
        <br>18: Console.Write("{0}.{1}",myIP.b3,myIP.b4); 
        <br>19: } 
        <br>20: } 
       </div> <p>4.1.3 枚举类型</p> <p>当你想声明一个由一指定常量集合组成的独特类型时，枚举类型正是你要寻觅的。最简单的形式，它看起来可能象这样：<br>enum MonthNames { January, February, March, April };</p> <p>因我惯用<font id="HHL_1178185315" style="BACKGROUND-COLOR: #ffff00">缺省设置，故枚举元素是int型，</font>且第一个元素为0值。每一个连续的元素按1递增。如果你想给第一个元素直接赋值，可以如下把它设成1：<br>enum MonthNames { January=1, February, March, April };</p> <p>如果你想赋任意值给每个元素——甚至相同的值——这也没有问题：<br>enum MonthNames { January=31, February=28, March=31, April=30 };</p> <p>最后的选择是不同于int的数据类型。可以在一条语句中按如此赋值：<br>enum MonthNames : byte { January=31, February=28, March=31, April=30 };<br>你可以使用的类型仅限于long、int、short和byte。 </p></font> 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item11"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> 
      <div> 
       <font id="zoomt" style="FONT-SIZE: 14px"> <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> <p><strong>4.2 引用类型</strong></p> <p>和值类型相比，引用类型不存储它们所代表的实际数据，但它们存储实际数据的引用。在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中提供以下引用类型给你使用：<br>·对象类型<br>·类类型<br>·<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a><br>·代表元<br>·字符串类型<br>·数组 </p> <p>4.2.1 对象类型</p> <p>对象类型是所有类型之母——它是其它类型最根本的基类。因为它是所有对象的基类，所以可把任何类型的值赋给它。例如，一个整型：<br>object theObj = 123;<br>给所有的<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员一个警告：<font id="HHL_1178185357" style="BACKGROUND-COLOR: #ffff00">object并不等价于你可能正在寻找的void*。</font>无论如何，忘掉<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>总是个好主意。<br>当一个值类型被加框（作为一个对象利用）时，对象类型就被使用了。这一章稍后会讨论到加框和消框 </p> <p>4.2.2 类类型</p> <p>一个类类型可以包含数据成员、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>成员和嵌套类型。数据成员是常量、字段和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>。<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>成员包括方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>、索引、操作符、构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>和析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。类和结构的功能是非常相似的，但正如前面所述，结构是值类型而类是引用类型。<br>和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>相比，仅允许单继承。（你不能拥有派生一个新对象的多重基类。） 但是，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中的一个类可以派生自多重<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>，该<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>在下一节将得到描述。第五章 “类”专门讨论使用类编程。这一节仅打算给出<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类在哪里适合类型图的一个全貌。 </p> <p>4.2.3 <a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a></p> <p><font id="HHL_1178185390" style="BACKGROUND-COLOR: #ffff00">一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>声明一个只有抽象成员的引用类型</font>。跟<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中相似的概念为：一个结构的成员，且方法等于0。如果你不知道那些概念的任何东西，这里就是在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>实际所做的。仅仅只存在着方法标志，但根本就没有执行代码。这就暗示了不能实例化一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>，只能实例化一个派生自该<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>的对象。</p> <p>可以在一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>中定义方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>和索引。所以，对比一个类，<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>有什么特殊性呢？<font id="HHL_1178185492" style="BACKGROUND-COLOR: #ffff00">当定义一个类时，可以派生自多重<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>，而你只能可以从仅有的一个类派生。</font> </p><p>你可能会问："OK，但我必须实现所有的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>成员，那么我能从这个途径得到什么呢?" 我想举一个来自.NET的例子：很多类实现了IDictionary <a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。你可以使用简单的类型转换访问<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>：<br>IDictionary myDict = (IDictionary)someobjectthatsupportsit;</p> <p>现在你的代码可以访问字典了。可等等，我说很多类可以实现这个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>——所以，你可以在多个地方重用代码来访问IDictionary <a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>！一旦学会，任何地方都可使用。</p> <p>当你决定在类设计中使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>时，学习更多关于<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>的设计是个好主意。这本书不能教你这些概念，但你可以学习如何创建<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。以下的代码段<font id="HHL_1178185549" style="BACKGROUND-COLOR: #ffff00">定义<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>IFace</font>，它只有一个方法：</p> 
        <div class="quote">
          interface IFace 
         <br>{ 
         <br>void ShowMyFace(); 
         <br>} 
        </div> <p>正如我所提到的，不能从这个定义实例化一个对象，但可以从它派生一个类。因此，该类必须实现ShowMyFace抽象方法：</p> 
        <div class="quote"> 
         <font id="HHL_1178185560" style="BACKGROUND-COLOR: #ffff00">class CFace:IFace</font> 
         <br>{ 
         <br>public void ShowMyFace() 
         <br>{ 
         <br>Console.WriteLine("implementation"); 
         <br>} 
         <br>} 
        </div> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>成员和类成员的区别在于，<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>成员不能被实现。因此，我不想在下一章中再次提到这一点。 </p> <p>4.2.4 代表元</p> <p><font id="HHL_1178185577" style="BACKGROUND-COLOR: #ffff00">一个代表元封装了具有一些标志的一个方法</font>。基本上，代表元是类型安全和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>的安全版本(回调功能)。可以同时在一个代表元实例中同时封装静态和实例方法。<br>尽管你可以用代表员当作具有方法，但它们的主要用途是拥有有一个类<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>。再次，我想把你引到下一章，那里会详细地讨论类。</p> <p>4.2.5 字符串类型</p> <p>C程序员可能会诧异，但当然，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>有一个用于操作字符串数据的基本字符串类型。字符串类直接派生自对象，且它是被密封的，这意味着再不能从它派生类。就象其它类型，<font id="HHL_1178185617" style="BACKGROUND-COLOR: #ffff00">字符串是预定义类System String的一个别名</font>。</p> <p>它的用法十分简单：<br>string myString = "some text";<br>合并字符串同样简单：<br>string myString = "some text" + " and a bit more";<br>而如果你想访问单个字符，所要做的就是访问下标：<br>char chFirst = myString[0];<br>当比较两个字符串是否相等时，简单地使用"=="比较操作符。<br>if (myString == yourString) ...<br></p> 
        <div> 
         <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
         <p>我只不过想提到，<font id="HHL_1178185640" style="BACKGROUND-COLOR: #ffff00">尽管字符串是一个引用类型，比较时是比较值，而不是比较引用(内存地址)。</font><br>字符串类型几乎用于这本书的每一个例子中，而且在这些例程中，我会介绍给你一些由字符串对象所显露的极其有趣的方法。</p> 
        </div> <p></p></font> 
      </div></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item12"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p>4.2.6 数组</p> <p>一个数组包含有通过计算下标访问的变量。所有包含于数组中且被当作元素的变量必须是同一类型。这种类型自然被称为"数组类型"。数组可以存储整数对象、字符串对象或者 你提出的任何对象。</p> <p><font id="HHL_1178185663" style="BACKGROUND-COLOR: #ffff00">数组的维数就是所谓的排(rank)，</font>它决定了相关数组元素的下标数。最常用的数组是一维数组(第一排)。一个多维数组具有的排数大于1 。每个维的下标始于0，终于维的长度减1 。</p> <p>应有足够的理论支持。让我们看一下用一个数组初始化器( array initializer)初始化的数组：<br>string[] arrLanguages = { "C", "<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>", "<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>" };<br>该简写效果等同以下：<br>arrLanguages[0]="C"; arrLanguages[1]="<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>"; arrLanguages[2]="<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>";<br>而编译器为你做了所有的工作。当然，它将同样为<font id="HHL_1178185703" style="BACKGROUND-COLOR: #ffff00">多维数组初</font>始化器工作：<br><font id="HHL_1178185702" style="BACKGROUND-COLOR: #ffff00">int[,] arr </font>= {<!-- -->{0,1}, {2,3}, {4,5}};<br>它是以下的简写：<br>arr[0,0] = 0; arr[0,1] = 1;<br>arr[1,0] = 2; arr[1,1] = 3;<br>arr[2,0] = 4; arr[2,1] = 5;<br><font id="HHL_1178185719" style="BACKGROUND-COLOR: #ffff00">如果你不想事先初始化一个数组，但知道了它的大小</font>，该声明就象这样：<br><font id="HHL_1178185721" style="BACKGROUND-COLOR: #ffff00">int[,] myArr = new int[5,3];</font><br>如果数组的大小<font id="HHL_1178185725" style="BACKGROUND-COLOR: #ffff00">必须动态地被计算</font>，用于数组创建的语句可以象这样写：<br>int nVar = 5;<br><font id="HHL_1178185727" style="BACKGROUND-COLOR: #ffff00">int[] arrToo = new int[nVar];</font><br>正如我在这一节开始所陈述的，<font id="HHL_1178185737" style="BACKGROUND-COLOR: #ffff00">你可以往数组里面塞任何东西</font>，只要所有的元素类型都相同。因此，如果你想把任何东西放进一个数组，就声明它的类型为对象： </p> <p><strong>4.3 加框和消框</strong></p> <p>这一章的课程中，我已经给出了各式各样的值类型和引用类型。由于速度的原因，你会使用值类型——它除了占据一定空间的内存块外，就没有什么了。但是，有时对象的方便性就象值类型一样好用。</p> <p>这就是加框和消框登上了舞台的地方，<font id="HHL_1178185761" style="BACKGROUND-COLOR: #ffff00">加框和消框是<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类型系统的核心概念</font>。通过允许一个值类型转换成类型对象或从类型对象转换成值类型，这种机制<font id="HHL_1178185772" style="BACKGROUND-COLOR: #ffff00">形成了值类型和引用类型之间的捆绑连接</font>。任何东西终究是一个对象——但是，仅当需要它们是对象时。</p> <p>4.3.1 加框转换</p> <p>给一个值加框指隐式地把任何值类型转换成类型对象。当一个值类型被加框时，一个对象实例就被分配，且值类型的值被拷贝给新的对象。<br>看以下例子：</p> 
    <div class="quote">
      int nFunny = 2000; 
     <br>object oFunny = nFunny; 
    </div> <p>第二行的赋值暗示调用一个加框操作。nFunny整型变量的值被拷贝给oFunny对象。现在<font id="HHL_1178185811" style="BACKGROUND-COLOR: #ffff00">整型变量和对象变量都同时存在于栈中，但对象的值居留在堆中。</font> </p><p>那么，它暗示着什么呢?它们的值互相独立——在它们之间没有连接。(oFunny没有引用nFunny的值。) 以下代码说明了结果：</p> 
    <div class="quote">
      int nFunny = 2000; 
     <br>object oFunny = nFunny; 
     <br>oFunny = 2001; 
     <br>Console.WriteLine("{0} {1}", nFunny, oFunny); 
    </div> <p>当代码改变oFunny的值时，nFunny的值并没有改变。只要你脑袋中有这个copy动作，就能够使用值类型的对象功能，发挥出你的巨大优势！</p> <p>4.3.2 消框转换</p> <p>和加框相比，<font id="HHL_1178185871" style="BACKGROUND-COLOR: #ffff00">消框是显式操作</font>——必须告诉编译器，你想从对象中抽取出哪一种值类型。当执行消框操作时，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>检测所请求的值类型实际上存储在对象实例中。经过成功的校验，该值被消框。 </p> <p>这就是消框如何执行：</p> 
    <div class="quote">
      int nFunny = 2000; 
     <br>object oFunny = nFunny; 
     <br> 
     <font id="HHL_1178185867" style="BACKGROUND-COLOR: #ffff00">int nNotSoFunny = (int)oFunny; </font> 
    </div> <p>如果错误地请求一个double值<br>double nNotSoFunny = (double)oFunny;<br>通用语言运行时(Common Language Runtime，简写CLR)将会<font id="HHL_1178185884" style="BACKGROUND-COLOR: #ffff00">引发一个InvalidCastException异常</font>。你可以在第7章 "异常处理" 中学到更多有关异常处理的知识。 <br></p> 
    <div> 
     <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
     <p><strong>4.4 小结</strong></p> 
     <p>在这一章中，你学到了<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中用到的各种类型。简单的值类型包括整型、布尔型、浮点型和小数型。你会非常经常地用到一些类型，进行数学和金融的计算，还有逻辑表达。</p> 
     <p>在介绍引用类型之前，我显示了一个看起来象类的结构类型。它几乎如一个类般地运作，但它只是一个值类型，这使它更加适合需要有大量的小对象的场合。</p> 
     <p>引用类型起始于所有对象之母的objedt本身。object是<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中所有对象的基类，且它同样用于值类型的加框和消框。除此之外，我还让你领略了代表元、字符串和数组。</p> 
     <p>令<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序员十分神气的类型就是类。它是<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>编程的心脏，下一章整章专门让你迅速理解这个激动人心且功能强大的类型。</p> 
    </div> 
    <div></div> <p></p></td></tr></tbody></table> 
 
<a name="wbs-bookmark-item13"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <p><font size="3"><strong>第五章 类</strong> </font></p> 
     <div> 
      <p>前一章讨论了数据类型和它们的用法。现在我们转移到<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中至关重要的结构——类。没有了类，就连简单的<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>程序都不能编译。这一章假定你知道了一个类的基本组成部分：方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>、构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>和析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>在其中增加了索引和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>。</p> 
      <p>在这一章中，你学到下列有关类的话题。<br>。使用构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>和析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a><br>。给类写方法<br>。给一个类增加<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>存取标志<br>。实现索引<br>。创建<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>并通过代表元为<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>关联客户<br>。应用类、成员和存取修饰符。 </p> 
      <p><strong>5.1 构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>和析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a></strong></p> 
      <p>在你可以访问一个类的方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>或任何其它东西之前， 第一条执行的语句是包含有相应类的构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。甚至你<font id="HHL_1178185929" style="BACKGROUND-COLOR: #ffff00">自己不写一个构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>，也会有一个缺省的构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>提供给你</font>。 </p> 
      <div class="quote">
        class TestClass 
       <br>{ 
       <br>public TestClass(): base() {} // 由编译器提供 
       <br>} 
      </div> 
      <p>一个构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>总是和它的类名相同，但是，它没有声明返回类型。总之，<font id="HHL_1178185939" style="BACKGROUND-COLOR: #ffff00">构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>总是public的</font>，你可以用它们来初始化变量。</p> 
      <div class="quote">
        public TestClass() 
       <br>{ 
       <br>// 在这给变量 
       <br>// 初始化代码等等。 
       <br>} 
      </div> 
      <p>如果类仅包含静态成员(能以类型调用，而不是以实例调用的成员)，你可以创建一个private的构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。</p> 
      <div class="quote">
        private TestClass() 
       <br>{ 
       <br>} 
      </div> 
      <p>尽管存取修饰符在这一章的后面将要大篇幅地讨论，<font id="HHL_1178185957" style="BACKGROUND-COLOR: #ffff00">但是private意味着从类的外面不可能访问该构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。所以，它不能被调用，且没有对象可以自该类定义被实例化。</font></p> 
      <p>并不仅限于无参数构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>——你可以传递初始参数来初始化成员。</p> 
      <div class="quote">
        public TestClass(string strName, int nAge) { ... } 
      </div> 
      <p>作为一个C/<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员，你可能习惯于给初始化写一个附加的方法，因为在构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>中没有返回值。当然，尽管在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中也没有返回值，<font id="HHL_1178185990" style="BACKGROUND-COLOR: #ffff00">但你可以引发一个自制的异常，以从构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>获得返回值。</font>更多有关异常处理的知识在第七章 "异常处理"中有讨论。但是，当你保留引用给宝贵的资源，应该想到写一个方法来解决：一个可以被显式地调用来释放这些资源。问题是当你可以在析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>(以类名的前面加"~"的方式命名)中做同样的事情时，为何还要写一个附加的方法.</p> 
      <div class="quote">
        public ~TestClass() 
       <br>{ 
       <br>// 清除 
       <br>} 
      </div> 
      <p>你应该写一个附加方法的原因是垃圾收集器，它在变量超出范围后并不会立即被调用，而仅当间歇期间或内存条件满足时才被触发。当你锁住资源的时间长于你所计划的时间时，它就会发生。 </p> 
      <p>因此，<font id="HHL_1178186030" style="BACKGROUND-COLOR: #ffff00">提供一个显式的释放方式是一个好主意，它同样能从析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>中调用</font>。 </p> 
      <div class="quote">
        public void Release() 
       <br>{ 
       <br>// 释放所有宝贵的资源 
       <br>} 
       <br> 
       <br>public ~TestClass() 
       <br>{ 
       <br> 
       <font id="HHL_1178186036" style="BACKGROUND-COLOR: #ffff00">Release();<br></font>} 
      </div> 
      <p>调用析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>中的释放方法并不是必要的——总之，垃圾收集会留意释放对象。但没有忘记清除是一种良好的习惯。 </p> 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item14"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div class="quote"> 
     <p><strong>5.2 方法</strong></p> 
     <p>既然对象能正确地初始化和结束，所剩下来的就是往类中增加功能。在大多数情况下，功能的主要部分在方法中能得到实现。你早已见过静态方法的使用，但是，这些是类型(类)的部分，不是实例(对象)。</p> 
     <p>为了让你迅速入门，我把这些方法的烦琐问题安排为三节：<br>。方法参数<br>。改写方法<br>。方法屏蔽</p> 
     <p>5.2.1 方法参数</p> 
     <p>因方法要处理更改数值，你多多少少要传递值给方法，并从方法获得返回值。以下三个部分涉及到由传递值和为调用者获取返回结果所引起的问题。 </p> 
     <p>。输入参数<br>。引用参数<br>。输出参数 </p> 
     <p>5.2.1.1 输入参数</p> 
     <p>你早已在例子中见过的一个参数就是输入参数。你用一个输入参数通过值传递一个变量给一个方法——方法的变量被调用者传递进来的值的一个拷贝初始化。清单5.1 示范输入参数的使用。 </p> 
     <p>清单 5.1 通过值传递参数 <br></p> 
     <div class="quote">
       1: using System; 
      <br>2: 
      <br>3: public class SquareSample 
      <br>4: { 
      <br>5: public int CalcSquare(int nSideLength) 
      <br>6: { 
      <br>7: return nSideLength*nSideLength; 
      <br>8: } 
      <br>9: } 
      <br>10: 
      <br>11: class SquareApp 
      <br>12: { 
      <br>13: public static void Main() 
      <br>14: { 
      <br>15: SquareSample sq = new SquareSample(); 
      <br>16: Console.WriteLine(sq.CalcSquare(25).ToString()); 
      <br>17: } 
      <br>18: } 
     </div> 
     <p>因为我传递值而不是引用给一个变量，所以当调用方法时(见第16行)，可以使用一个常量表达式(25)。整型结果被传回给调用者作为返回值，它没有存到中间变量就被立即显示到屏幕上 。</p> 
     <p>输入参数按C/<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员早已习惯的工作方式工作。如果你来自<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>，请注意没有能被编译器处理的隐式ByVal或ByRef——如果没有设定，参数总是用值传递。</p> 
     <p>这点似乎与我前面所陈述的有冲突：对于一些变量类型，用值传递实际上意味着用引用传递。 </p> 
     <p>迷惑吗? 一点背景知识也不需要：COM中的东西就是<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>，每一个类可以拥有一个或多个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。一个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>只不过是一组<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>，它不包含数据。重复该数组会浪费很多内存资源；所以，仅开始地址被拷贝给方法，它作为调用者，仍然指向<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>的相同<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+">指针</a>。那就是为什么对象用值传递一个引用。 </p> 
     <p>5.2.1.2 引用参数</p> 
     <p>尽管可以利用输入参数和返回值建立很多方法，但你一想到要传递值并原地修改它(也就是在相同的内存位置)，就没有那么好运了。这里用引用参数就很方便。</p> 
     <div class="quote">
       void myMethod( 
      <font id="HHL_1178186192" style="BACKGROUND-COLOR: #ffff00">ref int nInOut</font>) 
     </div> 
     <p>因为你传递了一个变量给该方法(不仅仅是它的值)，变量必须被初始化。否则，编译器会报警。 </p> 
     <p>清单 5.2 显示如何用一个引用参数建立一个方法。 </p> 
     <p>清单 5.2 通过引用传递参数 </p> 
     <div class="quote">
       1: // class SquareSample 
      <br>2: using System; 
      <br>3: 
      <br>4: public class SquareSample 
      <br>5: { 
      <br>6: public void CalcSquare( 
      <font id="HHL_1178186232" style="BACKGROUND-COLOR: #ffff00">ref int nOne4All</font>) 
      <br>7: { 
      <br>8: nOne4All *= nOne4All; 
      <br>9: } 
      <br>10: } 
      <br>11: 
      <br>12: class SquareApp 
      <br>13: { 
      <br>14: public static void Main() 
      <br>15: { 
      <br>16: SquareSample sq = new SquareSample(); 
      <br>17: 
      <br>18: int nSquaredRef = 20; // 
      <font id="HHL_1178186212" style="BACKGROUND-COLOR: #ffff00">一定要初始化</font> 
      <br>19: sq.CalcSquare( 
      <font id="HHL_1178186225" style="BACKGROUND-COLOR: #ffff00">ref nSquaredRef</font>); 
      <br>20: Console.WriteLine(nSquaredRef.ToString()); 
      <br>21: } 
      <br>22: } 
     </div> 
     <p>正如所看到的，所有你要做的就是给<font id="HHL_1178186238" style="BACKGROUND-COLOR: #ffff00">定义和调用都加上ref限定符</font>。因为变量通过引用传递，你可以用它来计算出结果并传回该结果。但是，在现实的应用程序中，<font id="HHL_1178186249" style="BACKGROUND-COLOR: #ffff00">我强烈建议要用两个变量，一个输入参数和一个引用参数</font>。 </p> 
     <p>5.2.1.3 输出参数</p> 
     <p>传递参数的第三种选择就是把它设作一个输出参数。正如该名字所暗示，一个输出参数仅用于从方法传递回一个结果。它和引用参数的另一个区别在于：<font id="HHL_1178186284" style="BACKGROUND-COLOR: #ffff00">调用者不必先初始化变量才调用方法。</font>这显示在清单5.3中。 </p> 
     <p>清单 5.3 定义一个输出参数 </p> 
     <div class="quote">
       1: using System; 
      <br>2: 
      <br>3: public class SquareSample 
      <br>4: { 
      <br>5: public void CalcSquare(int nSideLength, 
      <font id="HHL_1178186293" style="BACKGROUND-COLOR: #ffff00">out int nSquared</font>) 
      <br>6: { 
      <br>7: nSquared = nSideLength * nSideLength; 
      <br>8: } 
      <br>9: } 
      <br>10: 
      <br>11: class SquareApp 
      <br>12: { 
      <br>13: public static void Main() 
      <br>14: { 
      <br>15: SquareSample sq = new SquareSample(); 
      <br>16: 
      <br>17: int nSquared; // 不必初始化 
      <br>18: sq.CalcSquare(15, out nSquared); 
      <br>19: Console.WriteLine(nSquared.ToString()); 
      <br>20: } 
      <br>21: } 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
 
<a name="wbs-bookmark-item15"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p>5.2.2 改写方法</p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3">面向对象</a>设计的重要原则就是多态性。不要理会高深的理论，多态性意味着：<font id="HHL_1178186358" style="BACKGROUND-COLOR: #ffff00">当基类程序员已设计好用于改写的方法时，在派生类中，你就可以重定义(改写)基类的方法</font>。基类程序员可以用virtual 关键字设计方法：</p> 
    <div class="quote">
      virtual void CanBOverridden() 
     <br> 
    </div> <p><font id="HHL_1178186367" style="BACKGROUND-COLOR: #ffff00">当从基类派生时，所有你要做的就是在新方法中加入override关键字</font>：</p> 
    <div class="quote">
      override void CanBOverridden() 
    </div> <p>当改写一个基类的方法时，你必须明白，<font id="HHL_1178186377" style="BACKGROUND-COLOR: #ffff00">不能改变方法的访问<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>——在这章的后面，你会学到更多关于访问修饰符的知识。</font></p> <p>除了改写基类方法的事实外，还有另一个甚至更重要的改写特性。当把派生类强制转换成基类类型并接着调用虚拟方法时，<font id="HHL_1178186393" style="BACKGROUND-COLOR: #ffff00">被调用的是派生类的方法而不是基类的方法</font>。</p> 
    <div class="quote">
      ((BaseClass)DerivedClassInstance).CanBOverridden(); 
    </div> <p>为了演示虚拟方法的概念，清单 5.4 显示如何创建一个三角形基类，它拥有一个可以被改写的成员方法（ComputeArea）。 </p> <p>清单 5.4 改写一个基类的方法 </p> 
    <div class="quote">
      1: using System; 
     <br>2: 
     <br>3: class Triangle 
     <br>4: { 
     <br>5: public virtual double ComputeArea(int a, int b, int c) 
     <br>6: { 
     <br>7: // Heronian formula 
     <br>8: double s = (a + b + c) / 2.0; 
     <br>9: double dArea = Math.Sqrt(s*(s-a)*(s-b)*(s-c)); 
     <br>10: 
     <font id="HHL_1178186409" style="BACKGROUND-COLOR: #ffff00">return dArea</font>; 
     <br>11: } 
     <br>12: } 
     <br>13: 
     <br>14: class RightAngledTriangle:Triangle 
     <br>15: { 
     <br>16: public override double ComputeArea(int a, int b, int c) 
     <br>17: { 
     <br>18: double dArea = a*b/2.0; 
     <br>19: return dArea; 
     <br>20: } 
     <br>21: } 
     <br>22: 
     <br>23: class TriangleTestApp 
     <br>24: { 
     <br>25: public static void Main() 
     <br>26: { 
     <br>27: Triangle tri = new Triangle(); 
     <br>28: Console.WriteLine(tri.ComputeArea(2, 5, 6)); 
     <br>29: 
     <br>30: 
     <font id="HHL_1178186427" style="BACKGROUND-COLOR: #ffff00">R</font>ightAngledTriangle rat = new RightAngledTriangle(); 
     <br>31: Console.WriteLine(rat.ComputeArea(3, 4, 5)); 
     <br>32: } 
     <br>33: } 
    </div> <p>基类Triangle定义了方法ComputeArea。它采用三个参数，返回一个double结果，且具有公共访问性。从Triangle类派生出的是RightAngledTriangle，它改写了ComputeArea 方法，并实现了自己的面积计算公式。两个类都被实例化，且在命名为TriangleTestApp的应用类的Main() 方法中得到验证。</p> <p>我漏了解释第14行：<br>class RightAngledTriangle : Triangle<br>在类语句中冒号（：）表示RightAngledTriangle从类 Triangle派生。那就是你所必须要做的，以让<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>知道你想把 Triangle当作RightAngledTriangle的基类。当仔细观察直角三角形的ComputeArea方法时，你会发现第3个参数并没有用于计算。但是，利用该参数就可以验证是否是“直角”。如清单5.5所示。 </p> <p>清单 5.5 调用基类实现</p> 
    <div class="quote">
      1: class RightAngledTriangle:Triangle 
     <br>2: { 
     <br>3: public override double ComputeArea(int a, int b, int c) 
     <br>4: { 
     <br>5: const double dEpsilon = 0.0001; 
     <br>6: double dArea = 0; 
     <br>7: if ( 
     <font id="HHL_1178186507" style="BACKGROUND-COLOR: #ffff00">Math.Abs</font>((a*a + b*b - c*c)) &gt; dEpsilon) 
     <br>8: { 
     <br>9: 
     <font id="HHL_1178186489" style="BACKGROUND-COLOR: #ffff00">dArea = base.ComputeArea(a,b,c);<br></font>10: } 
     <br>11: else 
     <br>12: { 
     <br>13: dArea = a*b/2.0; 
     <br>14: } 
     <br>15: 
     <br>16: return dArea; 
     <br>17: } 
     <br>18: } 
    </div> <p>该检测简单地利用了毕达哥拉斯公式，对于直角三角形，检测结果必须为0。如果结果不为0，类就调用它基类的 ComputeArea来实现。<br><br></p> 
    <div> 
     <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
     <div class="quote">
       dArea = base.ComputeArea(a,b,c); 
     </div> 
     <p>例子的要点为：通过显式地利用基类的资格检查，你就能轻而易举地调用基类实现改写方法。当你需要实现其在基类中的功能，而不愿意在改写方法中重复它时，这就非常有帮助。 </p> 
    </div></td></tr></tbody></table> 
 
<a name="wbs-bookmark-item16"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div class="quote"> 
     <p>5.2.3 方法屏蔽</p> 
     <p>重定义方法的一个不同手段就是要屏蔽基类的方法。当从别人提供的类派生类时，这个功能特别有价值。看清单 5.6，假设BaseClass由其他人所写，而你从它派生出 DerivedClass 。 </p> 
     <p>清单 5.6 Derived Class 实现一个没有包含于 Base Class中的方法 </p> 
     <div class="quote">
       1: using System; 
      <br>2: 
      <br>3: class BaseClass 
      <br>4: { 
      <br>5: } 
      <br>6: 
      <br>7: class DerivedClass:BaseClass 
      <br>8: { 
      <br>9: public void TestMethod() 
      <br>10: { 
      <br>11: Console.WriteLine("DerivedClass::TestMethod"); 
      <br>12: } 
      <br>13: } 
      <br>14: 
      <br>15: class TestApp 
      <br>16: { 
      <br>17: public static void Main() 
      <br>18: { 
      <br>19: DerivedClass test = new DerivedClass(); 
      <br>20: test.TestMethod(); 
      <br>21: } 
      <br>22: } 
     </div> 
     <p>在这个例子中， DerivedClass 通过TestMethod()实现了一个额外的功能。但是，如果基类的开发者认为把TestMethod()放在基类中是个好主意，并使用相同的名字实现它时，会出现什么问题呢？（见清单5.7） </p> 
     <p>清单 5.7 Base Class 实现和 Derived Class相同的方法 </p> 
     <div class="quote">
       1: class BaseClass 
      <br>2: { 
      <br>3: public void TestMethod() 
      <br>4: { 
      <br>5: Console.WriteLine("BaseClass::TestMethod"); 
      <br>6: } 
      <br>7: } 
      <br>8: 
      <br>9: class DerivedClass:BaseClass 
      <br>10: { 
      <br>11: public void TestMethod() 
      <br>12: { 
      <br>13: Console.WriteLine("DerivedClass::TestMethod"); 
      <br>14: } 
      <br>15: } 
     </div> 
     <p>在优秀的编程语言中，你现在会遇到一个真正的大麻烦。但是，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>会给你提出警告：<br>hiding2.cs(13,14): warning CS0114: 'DerivedClass.TestMethod()' hides inherited member </p> 
     <p>'BaseClass.TestMethod()'. To make the current method override that implementation, add </p> 
     <p>the override keyword. Otherwise add the new keyword.<br>（hiding2.cs(13,14):警告 CS0114:'DerivedClass.TestMethod()' 屏蔽了所继承的成员 </p> 
     <p>'BaseClass.TestMethod()'。要想使当前方法改写原来的实现，加上 override关键字。否则加上新的关键字。具有了修饰符new，你就可以告诉编译器，不必重写派生类或改变使用到派生类的代码，你的方法就能屏蔽新加入的基类方法。清单5.8 显示如何在例子中运用new修饰符。 </p> 
     <p>清单 5.8 屏蔽基类方法 </p> 
     <div class="quote">
       1: class BaseClass 
      <br>2: { 
      <br>3: public void TestMethod() 
      <br>4: { 
      <br>5: Console.WriteLine("BaseClass::TestMethod"); 
      <br>6: } 
      <br>7: } 
      <br>8: 
      <br>9: class DerivedClass:BaseClass 
      <br>10: { 
      <br>11: 
      <font id="HHL_1178186614" style="BACKGROUND-COLOR: #ffff00">new</font> public void TestMethod() 
      <br>12: { 
      <br>13: Console.WriteLine("DerivedClass::TestMethod"); 
      <br>14: } 
      <br>15: } 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
 
<a name="wbs-bookmark-item17"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <p> </p> 
     <div> 
      <font id="zoomt" style="FONT-SIZE: 14px"> <p>该类仅有一个方法，它允许我们触发<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>。请注意，<font id="HHL_1178186636" style="BACKGROUND-COLOR: #ffff00">你必须进行<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>域成员不为null的检测</font>，因为可能会出现没有客户对<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>感兴趣这种情况。</p> <p>TestApp类包含了Main 方法，也包含了另外两个方法，它们都具备<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>所必需的信号。其中一个方法是静态的，而另一个是实例方法。</p> <p>EventSource 被实例化，而静态方法CatchEvent被预关联上了 TextOut<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>：<br>evsrc.TextOut += new EventHandler(CatchEvent);</p> <p>从现在起，当<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>被触发时，该方法被调用。如果你对<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>不再感兴趣，简单地取消关联：evsrc.TextOut -= new EventHandler(CatchEvent);</p> <p>注意，<font id="HHL_1178186665" style="BACKGROUND-COLOR: #ffff00">你不能随意取消关联的处理<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>——在类代码中仅创建了这些处理<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。为了证明<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>处理<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>也和实例方法一起工作，余下的代码建立了TestApp 的实例，并钩住<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>处理方法。<br><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>在哪方面对你特别有用？你将经常在<a class="channel_keylink" href="http://www.bc-cn.net/Article/web/asp/Index.html">ASP</a>+中或使用到<font id="HHL_1178186679" style="BACKGROUND-COLOR: #ffff00">WFC (Windows Foundation Classes</font>)时，涉及到<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>和代表元。 </font></p> <p><strong>5.5 应用修饰符</strong></p> <p>在这一章的学习过程中，你已经见过了象public、virtual等修饰符。欲以一种易于理解的方法概括它们，我把它们划分为三节： </p> <p>。类修饰符<br>。成员修饰符 <br>。存取修饰符 </p> <p>5.5.1 类修饰符</p> <p>到目前为止，我还没有涉及到类修饰符，而只涉及到了应用于类的存取修饰符。但是，有两个修饰符你可以用于类：</p> <p><font id="HHL_1178186703" style="BACKGROUND-COLOR: #ffff00">abstract——</font>关于抽象类的重要一点就是它不能被实例化。只有不是抽象的派生类才能被实例化。派生类必须实现抽象基类的所有抽象成员。你不能给抽象类使用sealed 修饰符。</p> <p><font id="HHL_1178186708" style="BACKGROUND-COLOR: #ffff00">sealed</font>——<font id="HHL_1178186711" style="BACKGROUND-COLOR: #ffff00">密封 类不能被继承。</font>使用该修饰符防止意外的继承，在.NET框架中的类用到这个修饰符。<br>要见到两个修饰符的运用，看看清单5.12 ，它创建了一个基于一个抽象类的密封类（肯定是一个十分极端的例子）。 </p> <p>清单 5.12 抽象类和密封类 </p> 
       <div class="quote">
         1: using System; 
        <br>2: 
        <br>3: abstract class AbstractClass 
        <br>4: { 
        <br>5: abstract public void MyMethod(); 
        <br>6: } 
        <br>7: 
        <br>8: sealed class DerivedClass:AbstractClass 
        <br>9: { 
        <br>10: public override void MyMethod() 
        <br>11: { 
        <br>12: Console.WriteLine("sealed class"); 
        <br>13: } 
        <br>14: } 
        <br>15: 
        <br>16: public class TestApp 
        <br>17: { 
        <br>18: public static void Main() 
        <br>19: { 
        <br>20: DerivedClass dc = new DerivedClass(); 
        <br>21: dc.MyMethod(); 
        <br>22: } 
        <br>23: } 
       </div> <p>5.5.2 成员修饰符</p> <p>与有用的成员修饰符的数量相比，类修饰符的数量很少。我已经提到了一些，这本书即将出现的例子描述了其它的成员修饰符。</p> <p>以下是有用的成员修饰符：</p> <p>abstract——说明一个方法或存取标志不能含有一个实现。它们都是隐式虚拟，且在继承类中，你必须提供 override关键字。<br>const——这个修饰符应用于域成员或局部变量。在编译时常量表达式被求值，所以，它不能包含变量的引用。<br><font id="HHL_1178186760" style="BACKGROUND-COLOR: #ffff00">event</font> ——定义一个域成员或<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>作为类型<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>。<font id="HHL_1178186762" style="BACKGROUND-COLOR: #ffff00">用于捆绑客户代码到类的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>。<br><font id="HHL_1178186768" style="BACKGROUND-COLOR: #ffff00">extern</font>——告诉编译器方法实际上由外部实现。第10章 “和非受管代码互相操作” 将全面地涉及到外部代码。<br><font id="HHL_1178186772" style="BACKGROUND-COLOR: #ffff00">override——</font>用于改写任何基类中被定义为virtual的方法和存取标志。要改写的名字和基类的方法必须一致。<br><font id="HHL_1178186774" style="BACKGROUND-COLOR: #ffff00">readonly——</font>一个使用 readonly修饰符的<font id="HHL_1178186787" style="BACKGROUND-COLOR: #ffff00">域成员只能在它的声明或者在包含它的类的构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>中被更改。</font> <br>static——被声明为static的成员属于类，而不属于类的实例。你可以用static 于域成员、方法、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>、操作符甚至构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。<br>virtual——说明方法或存取标志可以被继承类改写。 </font></p></font> 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item18"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <p> </p> 
     <p>5.5.3 存取修饰符</p> 
     <p>存取修饰符定义了某些代码对类成员（如方法和<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>）的存取等级。你必须给每个成员加上所希望的存取修饰符，否则，默认的存取类型是隐含的。</p> 
     <p>你可以应用4个 存取修饰符之一：<br>public——任何地方都可以访问该成员，这是具有最少限制的存取修饰符。<br>protected——在类及所有的<font id="HHL_1178186822" style="BACKGROUND-COLOR: #ffff00">派生类中可以访问该成员，不允许外部访问</font>。<br>private——仅仅在同一个类的内部才能访问该成员。甚至派生类都不能访问它。<br>internal——<font id="HHL_1178186807" style="BACKGROUND-COLOR: #ffff00">允</font><font id="HHL_1178186802" style="BACKGROUND-COLOR: #ffff00">许相同组件（应用程序或库）的所有代码访问</font>。<font id="HHL_1178186806" style="BACKGROUND-COLOR: #ffff00">在.NET组件级别，你可以把它视为public，而在外部则为private。</font> </p> 
     <p>为了演示存取修饰符的用法，我稍微修改了Triangle例子，使它包含了新增的域成员和一个新的派生类（见清单 5.13）。 </p> 
     <p>清单 5.13 在类中使用存取修饰符 </p> 
     <div class="quote">
       1: using System; 
      <br>2: 
      <br>3: 
      <font id="HHL_1178186828" style="BACKGROUND-COLOR: #ffff00">internal </font>class Triangle 
      <br>4: { 
      <br>5: 
      <font id="HHL_1178186826" style="BACKGROUND-COLOR: #ffff00">protected </font>int m_a, m_b, m_c; 
      <br>6: public Triangle(int a, int b, int c) 
      <br>7: { 
      <br>8: m_a = a; 
      <br>9: m_b = b; 
      <br>10: m_c = c; 
      <br>11: } 
      <br>12: 
      <br>13: public virtual double Area() 
      <br>14: { 
      <br>15: // Heronian formula 
      <br>16: double s = (m_a + m_b + m_c) / 2.0; 
      <br>17: double dArea = Math.Sqrt(s*(s-m_a)*(s-m_b)*(s-m_c)); 
      <br>18: return dArea; 
      <br>19: } 
      <br>20: } 
      <br>21: 
      <br>22: internal class Prism:Triangle 
      <br>23: { 
      <br>24: private int m_h; 
      <br>25: public Prism(int a, int b, int c, int h):base(a,b,c) 
      <br>26: { 
      <br>27: m_h = h; 
      <br>28: } 
      <br>29: 
      <br>30: public override double Area() 
      <br>31: { 
      <br>32: double dArea = base.Area() * 2.0; 
      <br>33: dArea += m_a*m_h + m_b*m_h + m_c*m_h; 
      <br>34: return dArea; 
      <br>35: } 
      <br>36: } 
      <br>37: 
      <br>38: class PrismApp 
      <br>39: { 
      <br>40: public static void Main() 
      <br>41: { 
      <br>42: Prism prism = new Prism(2,5,6,1); 
      <br>43: Console.WriteLine(prism.Area()); 
      <br>44: } 
      <br>45: } 
     </div> 
     <p>Triangle 类和 Prism 类现在被标为 internal。这意味着它们<font id="HHL_1178186892" style="BACKGROUND-COLOR: #ffff00">只能在当前组件中被访问。</font> </p> 
     <p>请记住“.NET组件”这个术语指的是包装（ packaging,），而不是你可能在COM+中用到的组件。 </p> 
     <p>Triangle 类有三个 protected成员，它们在构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>中被初始化，并用于面积计算的方法中。由于这些成员是protected 成员，所以我可以在派生类Prism中访问它们，在那里执行不同的面积计算。 </p> 
     <p>Prism自己新增了一个成员m_h，它是私有的——甚至派生类也不能访问它。<br>花些时间为每个类成员甚至每个类计划一种保护层次，通常是个好主意。当需要引入修改时，全面的计划最终会帮助你，因为没有程序员会愿意使用“没有文档”的类功能。</p> 
     <p><strong>5.6 小结</strong></p> 
     <p>这章显示了类的各种要素，它是运行实例（对象）的模板。在一个对象的生命期，首先被执行的代码是个构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>。构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>用来初始化变量，这些变量后来在方法中用于计算结果。</p> 
     <p>方法允许你传递值、引用给变量，或者只传送一个输出值。方法可以被改写以实现新的功能，或者你可以屏蔽基类成员，如果它实现了一个具有和派生类成员相同名字的方法。</p> 
     <p>命名<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>可以被当作域成员（成员变量）或<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>存取标志实现。后者是get和set存取标志，忽略一个或另外一个，你可以创建仅写或仅读<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>。存取标志非常适合于确认赋给<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>的值。<br></p> 
     <div> 
      <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
      <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>类的另外一个功能是索引，它使象数组语法一样访问类中值成为可能。还有，如果当类中的某些事情发生时，你想客户得到通知，要让它们与<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%C2%BC%FE">事件</a>关联。</p> 
      <p>当垃圾收集器调用析构<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>时，对象的生命就结束了。由于你不能准确地预测这种情况什么时候会发生，所以应该创建一个方法以释放这些宝贵的资源，当你停止使用它们时。</p> 
     </div> 
     <p></p> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item19"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"><font id="zoomt" style="FONT-SIZE: 14px"> <p><strong>第六章 控制语句</strong></p> <p>有一种语句，你在每种编程语言控制流程语句中都可以找到。在这一章中，我介绍了<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>的控制语句，它们分为两个主要部分：<br>。选择语句<br>。循环语句<br>如果你是C或<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员，很多信息会让你感到似曾相似；但是，你必须知道它们还存在着一些差别。</p> <p><strong>6.1 选择语句</strong></p> <p>当运用选择语句时，你定义了一个控制语句，它的值控制了哪个语句被执行。在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中用到两个选择语句：<br>。if 语句<br>。switch 语句 </p> <p>6.1.1 if 语句</p> <p>最先且最常用到的语句是 if 语句。内含语句是否被执行取决于布尔表达式：</p> <p>if (<font id="HHL_1178186977" style="BACKGROUND-COLOR: #ffff00">布尔表达式</font>) 内含语句 </p> <p>当然，也可以有else 分枝，当布尔表达式的值为假时，该分支就被执行：</p> <p>if (布尔表达式) 内含语句 else 内含语句 </p> <p>在执行某些语句之前就检查一个非零长字符串的例子： </p> 
       <div class="quote">
         if (0 != strTest.Length) 
        <br>{ 
        <br>} 
       </div> <p> 这是一个布尔表达式。（!=表示不等于。） 但是，如果你来自C或者<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>，可能会习惯于编写象这样的代码：</p> 
       <div class="quote">
         if (strTest.Length) 
        <br>{ 
        <br>} 
       </div> <p>这在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中不再工作，因为 if 语句仅允许布尔（ bool） 数据类型的结果，而字符串的Length<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>对象返回一个整形（integer）。编译器将出现以下错误信息：</p> <p><br>error CS0029: Cannot implicitly convert type 'int' to 'bool' （不能隐式地转换类型 'int' 为 'bool'。）  </p> <p>上边是你必须改变的习惯，而下边将不会再在 if 语句中出现赋值错误：</p> <p>if (nMyValue = 5) ... </p> <p>正确的代码应为 </p> <p>if (nMyValue == 5) ... </p> <p>因为相等比较由==实行，就象在C和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中一样。看以下有用的对比操作符（但并不是所有的数据类型都有效）：<br>== ——如果两个值相同，返回真。<br>!= ——如果两个值不同，返回假。<br>&lt;, &lt;=, &gt;, &gt;= —— 如果满足了关系（小于、小于或等于、大于、大于或等于），返回真。</p> <p>每个操作符是通过重载操作符被执行的，而且这种执行对数据类型有规定。如果你比较两个不同的类型，对于编译器，必须存在着一个隐式的转换，以便自动地创建必要的代码。但是，你可以执行一个显式的类型转换。</p> <p>清单 6.1 中的代码演示了 if 语句的一些不同的使用场合，同时也演示了如何使用字符串数据类型。这个程序的主要思想是，确定传递给应用程序的第一个参数是否以大写字母、小写字母或者数字开始。 </p> <p>清单 6.1 确定字符的形态 </p> 
       <div class="quote">
         1: using System; 
        <br>2: 
        <br>3: class NestedIfApp 
        <br>4: { 
        <br>5: public static int Main( 
        <font id="HHL_1178187037" style="BACKGROUND-COLOR: #ffff00">string[] args</font>) 
        <br>6: { 
        <br>7: if (args.Length != 1) 
        <br>8: { 
        <br>9: Console.WriteLine("Usage: one argument"); 
        <br>10: return 1; // error level 
        <br>11: } 
        <br>12: 
        <br>13: char chLetter = args[0][0]; 
        <br>14: 
        <br>15: if (chLetter &gt;= 'A') 
        <br>16: if (chLetter &lt;= 'Z') 
        <br>17: { 
        <br>18: Console.WriteLine("{0} is uppercase",chLetter); 
        <br>19: return 0; 
        <br>20: } 
        <br>21: 
        <br>22: chLetter = Char.FromString(args[0]); 
        <br>23: if (chLetter &gt;= 'a' &amp;&amp; chLetter &lt;= 'z') 
        <br>24: Console.WriteLine("{0} is lowercase",chLetter); 
        <br>25: 
        <br>26: if (Char.IsDigit((chLetter = args[0][0]))) 
        <br>27: Console.WriteLine("{0} is a digit",chLetter); 
        <br>28: 
        <br>29: return 0; 
        <br>30: } 
        <br>31: } 
       </div> <p>始于第7行的第一个 if 语段检测参数数组是否只有一个字符串。如果不满足条件，程序就在屏幕上显示用法信息，并终止运行。<br></p> 
       <div> 
        <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
        <p>可以采取多种方法从一个字符串中提取出单个字符——既可象第13行那样利用字符索引，也可以使用Char类的静态 FromString 方法，它返回字符串的第一个字符。</p> 
        <p>第16～20行的 if 语句块使用一个嵌套 的if 语句块检查大写字母。用逻辑“与”操作符（&amp;&amp;）可以胜任小写字母的检测，而最后通过使用Char类的静态<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>IsDigit，就可以完成对数字的检测。</p> 
        <p>除了“&amp;&amp;”操作符之外，还有另一个条件逻辑操作符，它就是代表“或”的<font id="HHL_1178187099" style="BACKGROUND-COLOR: #ffff00">“&amp;brvbar;&amp;brvbar</font>;”。两个逻辑操作符都 是“短路”式的。对于“&amp;&amp;”操作符，意味着如果条件“与”表达式的第一个结果返回一个假值，余下的条件“与”表达式就不会再被求值了。相对应，“&amp;brvbar;&amp;brvbar;”操作符当第一个真条件满足时，它就“短路”了。</p> 
        <p>我想让大家理解的是，要减少计算时间，你应该把最有可能使求值“短路”的表达式放在前面。同样你应该清楚，计算 if 语句中的某些值会存在着替在的危险。 </p> 
        <div class="quote">
          if (1 == 1 &amp;brvbar;&amp;brvbar; (5 == (strLength=str.Length))) 
         <br>{ 
         <br>Console.WriteLine(strLength); 
         <br>} 
        </div> 
        <p>当然，这是一个极其夸张的例子，但它说明了这样的观点：第一条语句求值为真，那么第二条语句就不会被执行，它使变量strLength维持原值。给大家一个忠告：决不要在具有条件逻辑操作符的 if 语句中赋值。 </p> 
       </div></font></font> 
    </div></td></tr></tbody></table> 
<div></div> 
 
<a name="wbs-bookmark-item20"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p> </p> <p>6.1.2 switch 语句</p> <p>和 if 语句相比，switch语句有一个控制表达式，而且内含语句按它们所关联的控制表达式的常量运行。 </p> <p>switch (控制表达式)<br>{<!-- --><br>case 常量表达式:<br>内含语句<br>default:<br>内含语句<br>} </p> <p>控制表达式所允许的数据类型为： sbyte, byte, short, ushort, uint, long, ulong, char, string, 或者枚举类型。只要使其它不同数据类型能隐式转换成上述的任何类型，用它作为控制表达式也很不错。</p> <p>switch 语句接以下顺序执行：<br>1、控制表达式求值<br>2、如果 case 标签后的常量表达式符合控制语句所求出的值，内含语句被执行。<br>3、如果没有常量表达式符合控制语句，在default 标签内的内含语句被执行。<br>4、<font id="HHL_1178187127" style="BACKGROUND-COLOR: #ffff00">如果没有一个符合case 标签，且没有default 标签，控制转向switch 语段的结束端</font>。</p> <p>在继续更详细地探讨switch语句之前，请看清单 6.2 ，它演示用 switch语句来显示一个月的天数（忽略跨年度）<br>清单 6.2 使用switch语句显示一个月的天数 </p> 
    <div class="quote">
      1: using System; 
     <br>2: 
     <br>3: class FallThrough 
     <br>4: { 
     <br>5: public static void Main(string[] args) 
     <br>6: { 
     <br>7: if (args.Length != 1) return; 
     <br>8: 
     <br>9: int nMonth = Int32.Parse(args[0]); 
     <br>10: if (nMonth &lt; 1 &amp;brvbar;&amp;brvbar; nMonth &gt; 12) return; 
     <br>11: int nDays = 0; 
     <br>12: 
     <br>13: switch (nMonth) 
     <br>14: { 
     <br>15: case 2: nDays = 28; 
     <font id="HHL_1178187162" style="BACKGROUND-COLOR: #ffff00"> break;</font> 
     <br>16: case 4: 
     <br>17: case 6: 
     <br>18: case 9: 
     <br>19: case 11: nDays = 30; 
     <font id="HHL_1178187163" style="BACKGROUND-COLOR: #ffff00"> break</font>; 
     <br>20: default: nDays = 31; 
     <br>21: } 
     <br>22: Console.WriteLine("{0} days in this month",nDays); 
     <br>23: } 
     <br>24: } 
    </div> <p>switch 语段包含于第13~21行。对于C程序员，这看起来非常相似，因为它不使用break语句。因此，存在着一个更具生命力的重要差别。<font id="HHL_1178187171" style="BACKGROUND-COLOR: #ffff00">你必须加上一个break语句（或一个不同的跳转语句），因为编译器会提醒，不允许直达下一部分。</font></p></td></tr></tbody></table> 
<p> </p> 
 
<a name="wbs-bookmark-item21"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> 
      <div class="quote"> 
       <font id="zoomt" style="FONT-SIZE: 14px"> <p>何谓直达？在C（和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>）中，忽略break并且按以下编写代码是完全合法的：</p> 
        <div class="quote">
          nVar = 1 
         <br>switch (nVar) 
         <br>{ 
         <br>case 1: 
         <br>DoSomething(); 
         <br>case 2: 
         <br>DoMore(); 
         <br>} 
        </div> <p>在这个例子中，在执行了第一个case语句的代码后，将直接执行到其它case标签的代码，直到一个break语句退出switch语段为止。尽管有时这是一个强大的功能，但它更经常地产生难于发现的缺陷。</p> <p>可如果你想执行其它case标签的代码，那怎么办？ 有一种办法，它显示于清单6.3中。 </p> <p>清单 6.3　在swtich语句中使用 goto 标签　和 goto default </p> 
        <div class="quote">
          1: using System; 
         <br>2: 
         <br>3: class SwitchApp 
         <br>4: { 
         <br>5: public static void Main() 
         <br>6: { 
         <br>7: Random objRandom = new Random(); 
         <br>8: double dRndNumber = objRandom.NextDouble(); 
         <br>9: int nRndNumber = (int)(dRndNumber * 10.0); 
         <br>10: 
         <br>11: switch (nRndNumber) 
         <br>12: { 
         <br>13: case 1: 
         <br>14: //什么也不做 
         <br>15: break; 
         <br>16: case 2: 
         <br>17: 
         <font id="HHL_1178187201" style="BACKGROUND-COLOR: #ffff00">goto case 3;<br></font>18: case 3: 
         <br>19: Console.WriteLine("Handler for 2 and 3"); 
         <br>20: break; 
         <br>21: case 4: 
         <br>22: 
         <font id="HHL_1178187211" style="BACKGROUND-COLOR: #ffff00">goto default;<br></font>23: // everything beyond a goto will be warned as 
         <br>24: // unreachable code 
         <br>25: default: 
         <br>26: Console.WriteLine("Random number {0}", nRndNumber); 
         <br>27: } 
         <br>28: } 
         <br>29: } 
        </div> <p>在这个例子中，通过Random类产生用于控制表达式的值（第７～９行）。switch语段包含两个对switch语句有效的跳转语句。</p> <p>goto case 　标签：跳转到所说明的标签</p> <p>goto default: 跳转到 default　标签</p> <p>有了这两个跳转语句，你可以创建同Ｃ一样的功能，但是，<font id="HHL_1178187226" style="BACKGROUND-COLOR: #ffff00">直达不再是自动的。你必须明确地请求它</font>。<br>不再使用直达功能的更深的含义为：你可任意排列标签，如把default标签放在其它所有标签的前面。为了说明它，我创建了一个例子，故意不结束循环： </p> 
        <div class="quote">
          switch (nSomething) 
         <br>{ 
         <br>default: 
         <br>case 5: 
         <br>goto default; 
         <br>} 
        </div> <p>我已经保留了其中一个swich 语句功能的讨论直至结束——<font id="HHL_1178187253" style="BACKGROUND-COLOR: #ffff00">事实上你可以使用字符串作为常量表达式</font>。这对于<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/vb/Index.html">VB</a>程序员，可能听起来不象是什么大的新闻，但来自Ｃ或Ｃ＋＋的程序员将会喜欢这个新功能。</p> <p>现在，一个 switch 语句可以如以下所示检查字符串常量了。 </p> 
        <div class="quote">
          string strTest = "Chris"; 
         <br>switch (strTest) 
         <br>{ 
         <br>case "Chris": 
         <br>Console.WriteLine("Hello Chris!"); 
         <br>break; 
         <br>} 
        </div></font> 
      </div></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<div></div> 
 
<a name="wbs-bookmark-item22"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p>6.2 循环语句</p> <p>当你想重复执行某些语句或语段时，依据当前不同的任务，Ｃ＃提供４个不同的循环语句选择给你使用：<br>。for 语句 <br>。foreach 语句 <br>。while 语句 <br>。do 语句 </p> <p>6.2.1 for 语句</p> <p>当你预先知道一个内含语句应要执行多少次时，for 语句特别有用。当条件为真时，常规语法允许重复地执行内含语句（和循环表达式）：</p> <p>for (初始化;条件;循环) 内含语句</p> <p>请注意，初始化、条件和循环都是可选的。如果忽略了条件，你就可以产生一个死循环，要用到跳转语句（break 或goto）才能退出。 <br></p> 
    <div> 
     <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
     <div class="quote">
       for (;;) 
      <br>{ 
      <br>break; // 由于某些原因 
      <br>} 
     </div> 
     <p>另外一个重点是，你可以同时加入多条由逗号隔开的语句到for循环的所有三个参数。例如，你可以初始化两个变量、拥有三个条件语句，并重复4个变量。<br>作为C或<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员，你必须了解仅有的一个变化：<font id="HHL_1178187299" style="BACKGROUND-COLOR: #ffff00">条件语句必须为布尔表达式</font>，就象 if 语句一样。</p> 
     <p>清单6.4 包含使用 for 语句的一个例子。它显示了如何计算一个阶乘，比使用递归<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>调用还要快。 </p> 
     <p>清单 6.4 在for 循环里计算一个阶乘</p> 
     <div class="quote">
       1: using System; 
      <br>2: 
      <br>3: class Factorial 
      <br>4: { 
      <br>5: public static void Main(string[] args) 
      <br>6: { 
      <br>7: long nFactorial = 1; 
      <br>8: long nComputeTo = Int64.Parse(args[0]); 
      <br>9: 
      <br>10: long nCurDig = 1; 
      <br>11: for (nCurDig=1;nCurDig &lt;= nComputeTo; nCurDig++) 
      <br>12: nFactorial *= nCurDig; 
      <br>13: 
      <br>14: Console.WriteLine("{0}! is {1}",nComputeTo, nFactorial); 
      <br>15: } 
      <br>16: } 
     </div> 
     <p>尽管该例子过于拖沓，但它作为如何使用for 语句的一个开端。<br>首先，我本应在初始化内部声明变量nCurDig：<br>for (long nCurDig=1;nCurDig &lt;= nComputeTo; nCurDig++) nFactorial *= nCurDig;</p> 
     <p>另一种忽略初始化的选择如下行，因为第10行在for 语句的外部初始化了变量。（记住<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>需要初始化变量）：<br>for (;nCurDig &lt;= nComputeTo; nCurDig++) nFactorial *= nCurDig;</p> 
     <p>另一种改变是把++操作符移到内含语句中：<br>for ( ;nCurDig &lt;= nComputeTo; ) nFactorial *= nCurDig++;</p> 
     <p>如果我也想摆脱条件语句，全部要做的是增加一条if 语句，用break 语句中止循环：</p> 
     <div class="quote">
       for (;;) 
      <br>{ 
      <br>if (nCurDig &gt; nComputeTo) break; 
      <br>nFactorial *= nCurDig++; 
      <br>} 
     </div> 
     <p>除了用于退出for语句的break语句外，你还可以用continue 跳过当前循环，并继续下一次循环。</p> 
     <div class="quote">
       for (;nCurDig &lt;= nComputeTo;) 
      <br>{ 
      <br>if (5 == nCurDig) continue; // 这行跳过了余下的代码 
      <br>nFactorial *= nCurDig++; 
      <br>} 
     </div> 
     <p>6.2.2 foreach 语句</p> 
     <p>已经在Visual Basic 语言中存在了很久的一个功能是，通过使用For Each 语句收集枚举。<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>通过foreach 语句，也有一个用来收集枚举的命令：</p> 
     <p>foreach(表达式中的类型标识符） 内含语句</p> 
     <p>循环变量由类型和标识符声明，且表达式与收集相对应。循环变量代表循环正在为之运行的收集元素。 </p> 
     <p>你应该知道不能赋一个新值给循环变量，也不能把它当作ref 或out 参数。这样引用在内含语句中被执行的代码。 </p> 
     <p>你如何说出某些类支持foreach 语句？ 简而言之，类必须支持具有 GetEnumerator()名字的方法，而且由其所返回的结构、类或者<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>必须具有public 方法MoveNext() 和public <a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>Current。如果你想知道更多，请阅读语言参考手册，它有很多关于这个话题的详细内容。 </p> 
     <p>对于清单 6.5 中的例子，我恰好偶然选了一个类，实现了所有这些需要。我用它来列举被定义过的所有的环境变量。 </p> 
     <p>清单 6.5 读所有的环境变量 </p> 
     <div class="quote">
       1: using System; 
      <br>2: using System.Collections; 
      <br>3: 
      <br>4: class EnvironmentDumpApp 
      <br>5: { 
      <br>6: public static void Main() 
      <br>7: { 
      <br>8: IDictionary envvars = Environment.GetEnvironmentVariables(); 
      <br>9: Console.WriteLine("There are {0} environment variables declared", envvars.Keys.Count); 
      <br>10: foreach ( 
      <font id="HHL_1178187457" style="BACKGROUND-COLOR: #ffff00">String strKey in envvars.Keys</font>) 
      <br>11: { 
      <br>12: Console.WriteLine("{0} = {1}",strKey, envvars[strKey].ToString()); 
      <br>13: } 
      <br>14: } 
      <br>15: } 
     </div> 
     <p>对GetEnvironmentVariables的调用返回一个IDictionary类型<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>，它是由.NET框架中的许多类实现了的字典<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。通过 IDictionary <a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>，可以访问两个收集：Keys 和 Values。在这个例子里，我在foreach语句中使用Keys，接着查找基于当前key值的值（第12行</p> 
    </div></td></tr></tbody></table> 
 
<a name="wbs-bookmark-item23"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> <p> </p> 
      <div> 
       <font id="zoomt" style="FONT-SIZE: 14px"> <p>当使用foreach时，只要注意一个问题：当确定循环变量的类型时，应该格外小心。选择错误的类型并没有受到编译器的检测，但它会在运行时受检测，且会引发一个异常。 </p> <p>6.2.3 while 语句</p> <p>当你想执行一个内含语句0次或更多次时，while语句正是你所盼望的：</p> <p>while (条件) 内含语句 </p> <p>条件语句——它也是一个布尔表达式 ——控制内含语句被执行的次数。你可以使用 break 和continue语句来控制while语句中的执行语句，它的运行方式同在for语句中的完全相同。</p> <p>为了举例while的用法，清单 6.6 说明如何使用一个 StreamReader类输出<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>源文件到屏幕。 </p> <p>清单 6.6 显示一个文件的内容 </p> 
        <div class="quote">
          1: using System; 
         <br>2: using System.IO; 
         <br>3: 
         <br>4: class WhileDemoApp 
         <br>5: { 
         <br>6: public static void Main() 
         <br>7: { 
         <br>8: StreamReader sr = File.OpenText ("whilesample.cs"); 
         <br>9: String strLine = null; 
         <br>10: 
         <br>11: while (null != (strLine = sr.ReadLine())) 
         <br>12: { 
         <br>13: Console.WriteLine(strLine); 
         <br>14: } 
         <br>15: 
         <br>16: sr.Close(); 
         <br>17: } 
         <br>18: } 
        </div> <p>代码打开文件 whilesample.cs, 接着当ReadLine 方法返回一个不等于null的值时，就在屏幕上显示所读取的值。注意，我在while条件语句中用到一个赋值。如果有更多的用&amp;&amp;和&amp;brvbar;&amp;brvbar;连接起来的条件语句，我不能保证它们是否会被执行，因为存在着“短路”的可能。 </p> <p>6.2.4 do 语句</p> <p><a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>最后可利用的循环语句是do语句。它与while语句十分相似，仅当经过最初的循环之后，条件才被验证。 </p> 
        <div class="quote">
          do 
         <br>{ 
         <br>内含语句 
         <br>} 
         <br>while (条件);  
        </div> <p>do语句保证内含语句至少被执行过一次，而且只要条件求值等于真，它们继续被执行。通过使用break语句，你可以迫使运行退出 do 语块。如果你想跳过这一次循环，使用continue语句。</p> <p>一个如何使用do语句的例子显示在清单 6.7中。它向用户请求一个或多个数字，并且当执行程序退出do循环后计算平均值。 </p> <p>清单 6.7 在do 循环中计算平均值</p> 
        <div class="quote">
          1: using System; 
         <br>2: 
         <br>3: class ComputeAverageApp 
         <br>4: { 
         <br>5: public static void Main() 
         <br>6: { 
         <br>7: ComputeAverageApp theApp = new ComputeAverageApp(); 
         <br>8: theApp.Run(); 
         <br>9: } 
         <br>10: 
         <br>11: public void Run() 
         <br>12: { 
         <br>13: double dValue = 0; 
         <br>14: double dSum = 0; 
         <br>15: int nNoOfValues = 0; 
         <br>16: char chContinue = 'y'; 
         <br>17: string strInput; 
         <br>18: 
         <br>19: do 
         <br>20: { 
         <br>21: Console.Write("Enter a value: "); 
         <br>22: strInput = Console.ReadLine(); 
         <br>23: dValue = Double.Parse(strInput); 
         <br>24: dSum += dValue; 
         <br>25: nNoOfValues++; 
         <br>26: Console.Write("Read another value?"); 
         <br>27: 
         <br>28: strInput = Console.ReadLine(); 
         <br>29: chContinue = Char.FromString(strInput); 
         <br>30: } 
         <br>31: while ('y' == chContinue); 
         <br>32: 
         <br>33: Console.WriteLine("The average is {0}",dSum / nNoOfValues); 
         <br>34: } 
         <br>35: } 
        </div> <p>在这个例子里，我在静态 Main<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>中实例化 ComputeAverageApp类型的一个对象。它同样接着调用实例的Run方法，该方法包含了计算平均值所有必要的功能。<br></p> <p>do 循环跨越第19~31行。条件是这样设定的：分别回答各个问题 “y”，以决定是否要增加另一个值。输入任何其它字符会引起程序退出 do语块，且平均值被计算。</p> <p>正如你可以从提到的例子看出，do语句和while语句差别不太大——仅有的差别就是条件在什么时候被求值。 </p> <p><strong>6.3 小结</strong></p> <p>这章解释了如何使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中用到的各种选择和循环语句。 if 语句在应用程序中可能是最为常用的语句。当在布尔表达式中使用计算时，编译器会为你留意。但是，你一定要确保条件语句的短路不会阻止必要代码的运行。<br>switch 语句——尽管同样与<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cyy/Index.html">C语言</a>的相应部分相似——但也被改善了。直达不再被支持，而且你可以使用字符串标签，对于C程序员，这是一种新的用法。</p> <p>在这一章的最后部分，我说明如何使用for、foreach、while和do语句。语句完成各种需要，包括执行固定次数的循环、列举收集元素和执行基于某些条件的任意次数的语句。</p></font> 
      </div></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item24"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p> </p> <p><strong><font color="#0000ff">第七章 异常处理<br><br></font>通用语言运行时（CLR）具有的一个很大的优势为，异常处理是跨语言被标准化的。一个在<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>中所引发的异常可以在Visual Basic客户中得到处理。<font id="HHL_1178187568" style="BACKGROUND-COLOR: #ffff00">不再有 HRESULTs 或者 ISupportErrorInfo <a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BD%D3%BF%DA">接口</a>。尽管跨语言异常处理的覆盖面很广，但这一章完全集中讨论<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>异常处理。你稍为改变编译器的溢出处理行为，接着有趣的事情就开始了：你处理了该异常。要增加更多的手段，随后引发你所创建的异常。<br><br>7.1 校验(checked)和非校验(unchecked)语句<br><br>当你执行运算时，有可能会发生计算结果超出<font id="HHL_1178187597" style="BACKGROUND-COLOR: #ffff00">结果变量数据类型的有效范围</font>。这种情况被称为溢出，依据不同的编程语言，你将被以某种方式通知——或者根本就没有被通知。（<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>程序员听起来熟悉吗？）<br><br>那么，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>如何处理溢出的呢？ 要找出其默认行为，请看我在这本书前面提到的阶乘的例子。（为了方便其见，前面的例子再次在清单 7.1 中给出）<br><br>清单 7.1 计算一个数的阶乘<br><br></font></strong></p> <p> </p> 
    <table cellspacing="1" width="100%" bgcolor="#cccccc" border="0"><tbody><tr><td bgcolor="#efefef"><br>1: using System;<br>2: <br>3: class Factorial<br>4: {<!-- --><br>5: public static void Main(string[] args)<br>6: {<!-- --><br>7: long nFactorial = 1;<br>8: long nComputeTo =<font id="HHL_1178187618" style="BACKGROUND-COLOR: #ffff00"> Int64</font>.Parse(args[0]);<br>9: <br>10: long nCurDig = 1;<br>11: for (nCurDig=1;nCurDig &lt;= nComputeTo; nCurDig++)<br>12: nFactorial *= nCurDig;<br>13: <br>14: Console.WriteLine("{0}! is {1}",nComputeTo, nFactorial);<br>15: }<br>16: }<br><br></td></tr></tbody></table><p></p> <p><br>当你象这样使用命令行执行程序时<br><br>factorial 2000<br><br>结果为0，什么也没有发生。因此，<font id="HHL_1178187655" style="BACKGROUND-COLOR: #ffff00">设想<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>默默地处理溢出情况而不明确地警告你是安全的。</font><br>通过给整个应用程序（经编译器开关）或于语句级允许溢出校验，你就可以改变这种行为。以下两节分别解决一种方案。<br><br><strong>7.1.1 给溢出校验设置编译器</strong><br><br>如果你想给整个应用程序控制溢出校验，<a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>编译器设置选择是正是你所要找的。<font id="HHL_1178187672" style="BACKGROUND-COLOR: #ffff00">默认地，<font id="HHL_1178187670" style="BACKGROUND-COLOR: #ffff00">溢</font>出校验是禁用的</font>。要明确地要求它，运行以下编译器命令：<br><br></p> <p> </p> 
    <table cellspacing="1" width="100%" bgcolor="#cccccc" border="0"><tbody><tr><td bgcolor="#efefef"><br>csc factorial.cs /checked+<br><br></td></tr></tbody></table><p></p> <p><br>现在当你用2000参数执行应用程序时，CLR通知你溢出异常。<br><br>按ＯＫ键离开对话框揭示了异常信息：<br><br></p> <p> </p> 
    <table cellspacing="1" width="100%" bgcolor="#cccccc" border="0"><tbody><tr><td bgcolor="#efefef"><br>Exception occurred: System.OverflowException<br>at Factorial.Main(System.String[])<br><br></td></tr></tbody></table><p></p> <p><br>现在你了解了溢出条件引发了一个 System.OverflowException异常。下一节，在我们完成语法校验之后，如何捕获并处理所出现的异常？<br><br><strong>7.1.2　语法溢出校验</strong><br><br>如果你不想给整个应用程序允许溢出校验，仅给某些代码段允许校验，你可能会很舒适。对于这种场合，你可能象清单7.2中显示的那样，使用校验语句。<br><br>清单 7.2　　阶乘计算中的溢出校验<br><br></p> <p> </p> 
    <table cellspacing="1" width="100%" bgcolor="#cccccc" border="0"><tbody><tr><td bgcolor="#efefef"><br>1: using System;<br>2: <br>3: class Factorial<br>4: {<!-- --><br>5: public static void Main(string[] args)<br>6: {<!-- --><br>7: long nFactorial = 1;<br>8: long nComputeTo = Int64.Parse(args[0]);<br>9: <br>10: long nCurDig = 1;<br>11: <br>12: for (nCurDig=1;nCurDig &lt;= nComputeTo; nCurDig++)<br>13:<font id="HHL_1178187712" style="BACKGROUND-COLOR: #ffff00"> checked </font>{ nFactorial *= nCurDig; }<br>14: <br>15: Console.WriteLine("{0}! is {1}",nComputeTo, nFactorial);<br>16: }<br>17: }<br><br></td></tr></tbody></table><p></p> <p><br>甚至就如你运用标志 checked-编译了该代码，在第13行中，溢出校验仍然会对乘法实现检查。错误信息保持一致。<br><br>显示相反行为的语句是非校验（unchecked ）。甚至如果允许了溢出校验（给编译器加上checked+标志），被unchecked 语句所括住的代码也将不会引发溢出异常：<br><br></p> <p> </p> 
    <table cellspacing="1" width="100%" bgcolor="#cccccc" border="0"><tbody><tr><td bgcolor="#efefef"><br><font id="HHL_1178187730" style="BACKGROUND-COLOR: #ffff00">unchecked<br></font>{<!-- --><br>nFactorial *= nCurDig;<br>}<br></td></tr></tbody></table><p></p></td></tr></tbody></table> 
<p> </p> 
 
<a name="wbs-bookmark-item25"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p> </p> <p><strong>7.2 　异常处理语句</strong></p> <p>既然你知道了如何产生一个异常（你会发现更多的方法，相信我），仍然存在如何处理它的问题。如果你是一个 <a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a> WIN32 程序员，肯定熟悉SEH（结构异常处理）。你将从中找到安慰，Ｃ＃中的命令几乎是相同的，而且它们也以相似的方式运作。</p> <p>The following three sections introduce <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a>'s exception-handling statements:</p> <p>以下三节介绍了Ｃ＃的异常处理语句：</p> <p>。用 try-catch 捕获异常<br>。用try-finally 清除异常<br>。用try-catch-finally 处理所有的异常</p> <p>7.2.1 使用 try 和 catch捕获异常</p> <p>你肯定会对一件事非常感兴趣——不要提示给用户那令人讨厌的异常消息，以便你的应用程序继续执行。要这样，你必须捕获（处理）该异常。<br>这样使用的语句是try 和 catch。try包含可能会产生异常的语句，而catch处理一个异常，如果有异常存在的话。清单7.3 用try 和 catch为OverflowException 实现异常处理。</p> <p>清单7.3 捕获由Factorial Calculation引发的OverflowException 异常</p> 
    <div class="quote">
      1: using System; 
     <br>2: 
     <br>3: class Factorial 
     <br>4: { 
     <br>5: public static void Main(string[] args) 
     <br>6: { 
     <br>7: long nFactorial = 1, nCurDig=1; 
     <br>8: long nComputeTo = Int64.Parse(args[0]); 
     <br>9: 
     <br>10: try 
     <br>11: { 
     <br>12: checked 
     <br>13: { 
     <br>14: for (;nCurDig &lt;= nComputeTo; nCurDig++) 
     <br>15: nFactorial *= nCurDig; 
     <br>16: } 
     <br>17: } 
     <br>18: catch ( 
     <font id="HHL_1178187794" style="BACKGROUND-COLOR: #ffff00">OverflowException oe</font>) 
     <br>19: { 
     <br>20: Console.WriteLine("Computing {0} caused an overflow exception", nComputeTo); 
     <br>21: return; 
     <br>22: } 
     <br>23: 
     <br>24: Console.WriteLine("{0}! is {1}",nComputeTo, nFactorial); 
     <br>25: } 
     <br>26: } 
    </div> <p>为了说明清楚，我扩展了某些代码段，而且我也保证异常是由checked 语句产生的，甚至当你忘记了编译器设置时。</p> <p>正如你所见，异常处理并不麻烦。你所有要做的是：在try语句中包含容易产生异常的代码，接着捕获异常，该异常在这个例子中是OverflowException类型。无论一个异常什么时候被引发，在catch段里的代码会注意进行适当的处理。</p> <p>如果你不事先知道哪一种异常会被预期，而仍然想处于安全状态，<font id="HHL_1178187829" style="BACKGROUND-COLOR: #ffff00">简单地忽略异常的类型</font>。</p> 
    <div class="quote">
      try 
     <br>{ 
     <br>... 
     <br>} 
     <br>catch 
     <br>{ 
     <br>... 
     <br>} 
    </div> <p>但是，通过这个途径，你不能获得对异常对象的访问，而该对象含有重要的出错信息。<font id="HHL_1178187841" style="BACKGROUND-COLOR: #ffff00">一般化异常处理代码象这</font>样：</p> 
    <div class="quote">
      try 
     <br>{ 
     <br>... 
     <br>} 
     <br>catch(System.Exception e) 
     <br>{ 
     <br>... 
     <br>} 
    </div> <p>注意，你不能用ref或out 修饰符传递 e 对象给一个方法，也不能赋给它一个不同的值。</p></td></tr></tbody></table> 
<p> </p> 
 
<a name="wbs-bookmark-item26"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div> 
     <font id="zoomt" style="FONT-SIZE: 14px"> <p> </p> <p>7.2.2 使用 try 和 finally 清除异常</p> <p>如果你更关心清除而不是错误处理， try 和 finally 会获得你的喜欢。它不仅抑制了出错消息，而且所有包含在 finally 块中的代码在异常被引发后仍然会被执行。尽管程序不正常终止，但你还可以为用户获取一条消息，如清单 7.4 所示。<br></p> 
      <div> 
       <p><font id="zoomt" style="FONT-SIZE: 14px"></font></p> 
       <p>清单 7.4 在finally 语句中处理异常</p> 
       <div class="quote">
         1: using System; 
        <br>2: 
        <br>3: class Factorial 
        <br>4: { 
        <br>5: public static void Main(string[] args) 
        <br>6: { 
        <br>7: 
        <font id="HHL_1178187869" style="BACKGROUND-COLOR: #ffff00">long nFactorial = 1, nCurDig=1;<br></font>8: long nComputeTo = 
        <font id="HHL_1178187875" style="BACKGROUND-COLOR: #ffff00">Int64.Parse(args[0]);<br></font>9: bool bAllFine = false; 
        <br>10: 
        <br>11: try 
        <br>12: { 
        <br>13: checked 
        <br>14: { 
        <br>15: for (;nCurDig &lt;= nComputeTo; nCurDig++) 
        <br>16: nFactorial *= nCurDig; 
        <br>17: } 
        <br>18: bAllFine = true; 
        <br>19: } 
        <br>20: finally 
        <br>21: { 
        <br>22: if (!bAllFine) 
        <br>23: Console.WriteLine("Computing {0} caused an overflow exception", nComputeTo); 
        <br>24: else 
        <br>25: Console.WriteLine("{0}! is {1}",nComputeTo, nFactorial); 
        <br>26: } 
        <br>27: } 
        <br>28: } 
       </div> 
       <p>通过检测该代码，你可能会猜到，<font id="HHL_1178187892" style="BACKGROUND-COLOR: #ffff00">即使没有引发异常处理，finally也会被执行</font>。这是真的——在finally中的代码总是会被执行的，不管是否具有异常条件。为了举例说明如何在两种情况下提供一些有意义的信息给用户， 我引进了新变量bAllFine。bAllFine告诉finally 语段，它是否是因为一个异常或者仅是因为计算的顺利完成而被调用。</p> 
       <p>作为一个习惯了SEH程序员，你可能会想，是否有一个与__leave 语句等价的语句，该语句在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中很管用。如果你还不了解，<font id="HHL_1178187920" style="BACKGROUND-COLOR: #ffff00">在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html">C++</a>中的__leave 语句是用来提前终止 try 语段中的执行代码，并立即跳转到finally 语段</font> 。坏消息， <a class="channel_keylink" href="http://www.bc-cn.net/Article/net/cs/Index.html">C#</a> 中没有__leave 语句。但是，在清单 7.5 中的代码演示了一个你可以实现的方案。</p> 
       <p>清单 7.5 从 try语句 跳转到finally 语句</p> 
       <div class="quote">
         1: using System; 
        <br>2: 
        <br>3: class JumpTest 
        <br>4: { 
        <br>5: public static void Main() 
        <br>6: { 
        <br>7: try 
        <br>8: { 
        <br>9: Console.WriteLine("try"); 
        <br>10: 
        <font id="HHL_1178187945" style="BACKGROUND-COLOR: #ffff00">goto __leave;</font> 
        <br>11: } 
        <br>12: finally 
        <br>13: { 
        <br>14: Console.WriteLine("finally"); 
        <br>15: } 
        <br>16: 
        <br>17: __leave: 
        <br>18: Console.WriteLine("__leave"); 
        <br>19: } 
        <br>20: } 
       </div> 
       <p>当这个应用程序运行时，输出结果为</p> 
       <p>try<br>finally<br>__leave</p> 
       <p><font id="HHL_1178187959" style="BACKGROUND-COLOR: #ffff00">一个 goto 语句不能退出 一个finally 语段</font>。甚至把 goto 语句放在 try 语句 段中，还是会立即返回控制到 finally 语段。因此，goto 只是离开了 try 语段并跳转到finally 语段。直到 finally 中的代码完成运行后，才能到达__leave 标签。按这种方式，你可以模仿在SEH中使用的的__leave 语句。</p> 
       <p>顺便地，你可能怀疑goto 语句被忽略了，因为它是try 语句中的最后一条语句，并且控制自动地转移到了 finally 。为了证明不是这样，试把goto 语句放到Console.WriteLine 方法调用之前。尽管由于不可到达代码你得到了编译器的警告，但是你将看到goto语句实际上被执行了，且没有为 try 字符串产生的输出。</p> 
       <div class="quote">
         1: using System; 
        <br>2: 
        <br>3: class CatchIT 
        <br>4: { 
        <br>5: public static void Main() 
        <br>6: { 
        <br>7: try 
        <br>8: { 
        <br>9: int nTheZero = 0; 
        <br>10: int nResult = 10 / nTheZero; 
        <br>11: } 
        <br>12: catch(DivideByZeroException divEx) 
        <br>13: { 
        <br>14: Console.WriteLine("divide by zero occurred!"); 
        <br>15: } 
        <br>16: catch(Exception Ex) 
        <br>17: { 
        <br>18: Console.WriteLine("some other exception"); 
        <br>19: } 
        <br>20: finally 
        <br>21: { 
        <br>22: } 
        <br>23: } 
        <br>24: } 
       </div> 
       <p>这个例子的技巧为，它包含了多个catch 语句。第一个捕获了更可能出现的DivideByZeroException异常，而第二个catch语句通过捕获普通异常处理了所有剩下来的异常。</p> 
       <p>你肯定总是首先捕获特定的异常，接着是普通的异常。如果你不按这个顺序捕获异常，会发生什么事呢？清单7.7中的代码有说明。</p> 
       <p>清单7.7 顺序不适当的 catch 语句</p> 
       <div class="quote">
         1: try 
        <br>2: { 
        <br>3: int nTheZero = 0; 
        <br>4: int nResult = 10 / nTheZero; 
        <br>5: } 
        <br>6: catch(Exception Ex) 
        <br>7: { 
        <br>8: Console.WriteLine("exception " + Ex.ToString()); 
        <br>9: } 
        <br>10: catch(DivideByZeroException divEx) 
        <br>11: { 
        <br>12: Console.WriteLine("never going to see that"); 
        <br>13: } 
       </div> 
       <p>编译器将捕获到一个小错误，并类似这样报告该错误：<br>wrongcatch.cs(10,9): error CS0160: A previous catch clause already <br>catches all exceptions of this or a super type ('System.Exception')</p> 
       <p>最后，我必须告发CLR异常与SEH相比时的一个缺点（或差别）：没有 EXCEPTION_CONTINUE_EXECUTION标识符的等价物，它在SEH异常过滤器中很有用。基本上，<font id="HHL_1178188059" style="BACKGROUND-COLOR: #ffff00">EXCEPTION_CONTINUE_EXECUTION 允许你重新执行负责异常的代码片段</font>。在重新执行之前，你有机会更改变量等。我个人特别喜欢的技术为，使用访问违例异常，按需要实施内存分配。</p> 
      </div></font> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item27"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> 
    <div class="quote"> 
     <p> </p> 
     <p><strong>7.3 引发异常</strong></p> 
     <p>当你必须捕获异常时，其他人首先必须首先能够引发异常。而且，不仅其他人能够引发，你也可以负责引发。其相当简单：</p> 
     <p><font id="HHL_1178188100" style="BACKGROUND-COLOR: #ffff00">throw new ArgumentException("Argument can't be 5");<br></font> </p> 
     <p>你所需要的是throw 语句和一个适当的异常类。我已经从表7.1提供的清单中选出一个异常给这个例子。</p> 
     <p>表 7.1 Runtime提供的标准异常</p> 
     <div class="quote"> 
      <p><font id="HHL_1178188106" style="BACKGROUND-COLOR: #ffff00">异常类型 描述</font> </p> 
      <p>Exception 所有异常对象的基类<br>SystemException 运行时产生的所有错误的基类<br>IndexOutOfRangeException 当一个数组的下标超出范围时运行时引发<br>NullReferenceException 当一个空对象被引用时运行时引发<br>InvalidOperationException 当对方法的调用对对象的当前状态无效时，由某些方法引发<br>ArgumentException 所有参数异常的基类<br>ArgumentNullException 在参数为空（不允许）的情况下，由方法引发<br>ArgumentOutOfRangeException 当参数不在一个给定范围之内时，由方法引发<br>InteropException 目标在或发生在CLR外面环境中的异常的基类<br>ComException 包含COM 类的HRESULT信息的异常<br>SEHException 封装win32 结构异常处理信息的异常<br></p> 
      <p>然而，在catch语句的内部，你已经有了随意处置的异常，就不必创建一个新异常。可能在表7.1 中的异常没有一个符合你特殊的要求——为什么不创建一个新的异常？在即将要学到小节中，都涉及到这两个话题。</p> 
      <p>7.3.1 重新引发异常</p> 
      <p>当处于一个catch 语句的内部时，你可能决定引发一个目前正在再度处理的异常，留下进一步的处理给一些外部的try-catch 语句。该方法的例子如 清单7.8所示。</p> 
      <p>清单 7.8 重新引发一个异常</p> 
      <div class="quote">
        1: try 
       <br>2: { 
       <br>3: checked 
       <br>4: { 
       <br>5: for (;nCurDig &lt;= nComputeTo; nCurDig++) 
       <br>6: nFactorial *= nCurDig; 
       <br>7: } 
       <br>8: } 
       <br>9: catch (OverflowException oe) 
       <br>10: { 
       <br>11: Console.WriteLine("Computing {0} caused an overflow exception", nComputeTo); 
       <br>12: 
       <font id="HHL_1178188143" style="BACKGROUND-COLOR: #ffff00"> throw;<br></font>13: } 
      </div> 
      <p>注意，<font id="HHL_1178188144" style="BACKGROUND-COLOR: #ffff00">我不必规定所声明的异常变量。</font>尽管它是可选的，但你也可以这样写：<br>throw oe;<br>现在有时还必须留意这个异常。</p> 
      <p></p> 
     </div> 
    </div></td></tr></tbody></table> 
<div></div> 
<p> </p> 
 
<a name="wbs-bookmark-item28"></a> 
<hr color="#ff0000" size="1"> 
 
<table class="center_tdbgall" style="WORD-BREAK: break-all" cellspacing="0" cellpadding="0" width="760" align="center" border="0"><tbody><tr><td class="main_tdbg_760" id="fontzoom" style="WORD-BREAK: break-all" colspan="2" height="300"> <p> </p> <p>7.3.2 创建自己的异常类</p> <p>尽管建议使用预定义的异常类，但对于实际场合，创建自己的异常类可能会方便。创建自己的异常类，允许你的异常类的使用者根据该异常类采取不同的手段。</p> <p>在清单 7.9 中出现的异常类 MyImportantException遵循两个规则：<font id="HHL_1178188163" style="BACKGROUND-COLOR: #ffff00">第一，它用Exception结束类名</font>。第<font id="HHL_1178188168" style="BACKGROUND-COLOR: #ffff00">二，它实现了所有三个被推荐的通用结构</font>。你也应该遵守这些规则。</p> <p>清单 7.9 实现自己的异常类 MyImportantException</p> 
    <div class="quote">
      1: using System; 
     <br>2: 
     <br>3: public class MyImportantException:Exception 
     <br>4: { 
     <br>5: public MyImportantException() 
     <br>6: :base() {} 
     <br>7: 
     <br>8: public MyImportantException(string message) 
     <br>9: :base(message) {} 
     <br>10: 
     <br>11: public MyImportantException(string message, Exception inner) 
     <br>12: :base(message,inner) {} 
     <br>13: } 
     <br>14: 
     <br>15: public class ExceptionTestApp 
     <br>16: { 
     <br>17: public static void TestThrow() 
     <br>18: { 
     <br>19: throw new MyImportantException("something bad has happened."); 
     <br>20: } 
     <br>21: 
     <br>22: public static void Main() 
     <br>23: { 
     <br>24: try 
     <br>25: { 
     <br>26: ExceptionTestApp.TestThrow(); 
     <br>27: } 
     <br>28: catch (Exception e) 
     <br>29: { 
     <br>30: Console.WriteLine(e); 
     <br>31: } 
     <br>32: } 
     <br>33: } 
    </div> <p>正如你所看到的，MyImportantException 异常类不能实现任何特殊的功能，但它完全基于System.Exception类。程序的剩余部分测试新的异常类，给System.Exception 类使用一个catch 语句。</p> <p>如果没有特殊的实现而只是给MyImportantException<font id="HHL_1178188220" style="BACKGROUND-COLOR: #ffff00">定义了三个构造<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD">函数</a>，创建它又有什么意义呢？它是一个重要的类型——你可以在catch语句中使用它，代替更为普通的异常类。可能引发你的新异常的客户代码可以按规定的catch代码发挥作用。</font></p> <p>当使用自己的名字空间编写一个类库时，也要把异常放到该名字空间。尽管它并没有出现在这个例子中，你还是应该使用适当的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>，为扩展了的错误信息扩充你的异常类。</p> <p><strong>7.4 异常处理的“要”和“不要<br></strong></p><strong> <p>作为最后的忠告之语，这里是对异常引发和处理所要做和不要做的清单：</p> <p><br>。当引发异常时，要提供有意义的文本。<br>。要引发异常仅当条件是真正异常；也就是当一个正常的返回值不满足时。<br>。<font id="HHL_1178188255" style="BACKGROUND-COLOR: #ffff00">如果你的方法或<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%CA%F4%D0%D4">属性</a>被传递一个坏参数，要引发一个ArgumentException异常</font>。<br>。当调用操作不适合对象的当前状态时，要引发一个 InvalidOperationException异常。<br>。要引发最适合的异常。<br>。要使用链接异常，它们允许你跟踪异常树。<br>。<font id="HHL_1178188271" style="BACKGROUND-COLOR: #ffff00">不要为正常或预期的错误使用异常。<br></font>。<font id="HHL_1178188274" style="BACKGROUND-COLOR: #ffff00">不要为流程的正常控制使用异常。<br></font>。不要在方法中引发 NullReferenceException或IndexOutOfRangeException异常。</p> <p><strong>7.5 小结</strong></p> <p>这一章由介绍溢出校验开始。你可以使用编译器开关（默认是关），使整个应用程序允许或禁止溢出校验。如果需要微调控制，你可以使用校验和非校验语句，它允许你使用或不使用溢出校验来执行一段代码，尽管没有给应用程序设置开关。</p> <p>当发生溢出时，一个异常就被引发了。如何处理异常取决于你。我提出了各种途径，包括你最有可能贯穿整个应用程序使用的：try、catch 和finally 语句。在伴随的多个例子中，你学到了它与WIN32结构异常处理（SEH）的差别。<br>异常处理是给类的用户； 然而，如果你负责创建新的类，就可以引发异常。有多种选择：引发早已捕获的异常，引发存在的框架异常，或者按规定的实际目标创建新的异常类。</p> <p>最后，你需要阅读引发和处理异常的各种“要”和“不要”。</p></strong></td></tr></tbody></table> 
<p> </p> 
 
<hr color="#ff0000" size="1">
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53c37acaf5c8ba36a94e107a027ac338/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电脑维修指导手册(联想)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ffc8b882946be62c4ebdd246a1783368/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MIT-BIH ECG 心电数据的下载和读取图解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>