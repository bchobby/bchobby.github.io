<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java并发编程 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java并发编程" />
<meta property="og:description" content="目录
一、基本概念
1、进程与线程
2、并发与并行
3、应用
二、Java 线程
1、线程创建与运行
方法一：继承Thread类
方法二：实现Runnale接口
方法三：实现Callable接口
2、线程运行原理
3、Thread 的常见方法
1）start()与run()
2）sleep()与yield()
3）join() 方法
4）interrupt() 方法
5）sleep，yiled，wait，join 对比
6)不推荐的方法
7）守护线程
4、线程状态
结论
三、共享模型之管程
1、线程共享带来的问题
2、synchronized 解决方案
1）解决手段
2）synchronized 语法
3）synchronized 加在方法上
3、变量的线程安全分析
1）成员变量和静态变量的线程安全分析
2）局部变量线程安全分析
3）线程安全的情况
4）线程不安全的情况
5）不安全原因分析
6）解决方法
7）思考 private 或 final的重要性
8）常见线程安全类
线程安全类方法的组合
不可变类的线程安全
示例分析-是否线程安全
4、Monitor 概念
1）Java 对象头
2）Monitor 原理
5、synchronized 原理进阶
1）synchronized 用于同步代码块与同步方法原理
2）轻量级锁
3）锁膨胀
4）自旋优化
5）偏向锁
撤销偏向
6）批量重偏向
7）批量撤销
6、Wait/Notify
1）原理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4032abc16e0e18443d2a73169451ef37/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-12T19:01:01+08:00" />
<meta property="article:modified_time" content="2023-08-12T19:01:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java并发编程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">一、基本概念</a></p> 
<p id="1%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B" rel="nofollow">1、进程与线程</a></p> 
<p id="2%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C" rel="nofollow">2、并发与并行</a></p> 
<p id="3%E3%80%81%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%BA%94%E7%94%A8" rel="nofollow">3、应用</a></p> 
<p id="%E4%BA%8C%E3%80%81Java%20%E7%BA%BF%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Java%20%E7%BA%BF%E7%A8%8B" rel="nofollow">二、Java 线程</a></p> 
<p id="1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C" rel="nofollow">1、线程创建与运行</a></p> 
<p id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB" rel="nofollow">方法一：继承Thread类</a></p> 
<p id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnale%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnale%E6%8E%A5%E5%8F%A3" rel="nofollow">方法二：实现Runnale接口</a></p> 
<p id="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3" rel="nofollow">方法三：实现Callable接口</a></p> 
<p id="2%E3%80%81%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86" rel="nofollow">2、线程运行原理</a></p> 
<p id="3%E3%80%81Thread%20%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3%E3%80%81Thread%20%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95" rel="nofollow">3、Thread 的常见方法</a></p> 
<p id="%C2%A01%EF%BC%89start()%E4%B8%8Erun()-toc" style="margin-left:80px;"><a href="#%C2%A01%EF%BC%89start%28%29%E4%B8%8Erun%28%29" rel="nofollow"> 1）start()与run()</a></p> 
<p id="2%EF%BC%89sleep()%E4%B8%8Eyield()-toc" style="margin-left:80px;"><a href="#2%EF%BC%89sleep%28%29%E4%B8%8Eyield%28%29" rel="nofollow">2）sleep()与yield()</a></p> 
<p id="3%EF%BC%89join()%20%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#3%EF%BC%89join%28%29%20%E6%96%B9%E6%B3%95" rel="nofollow">3）join() 方法</a></p> 
<p id="4%EF%BC%89interrupt()%20%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#4%EF%BC%89interrupt%28%29%20%E6%96%B9%E6%B3%95" rel="nofollow">4）interrupt() 方法</a></p> 
<p id="5%EF%BC%89sleep%EF%BC%8Cyiled%EF%BC%8Cwait%EF%BC%8Cjoin%20%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#5%EF%BC%89sleep%EF%BC%8Cyiled%EF%BC%8Cwait%EF%BC%8Cjoin%20%E5%AF%B9%E6%AF%94" rel="nofollow">5）sleep，yiled，wait，join 对比</a></p> 
<p id="6)%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#6%29%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">6)不推荐的方法</a></p> 
<p id="7%EF%BC%89%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B-toc" style="margin-left:80px;"><a href="#7%EF%BC%89%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B" rel="nofollow">7）守护线程</a></p> 
<p id="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81" rel="nofollow">4、线程状态</a></p> 
<p id="%E7%BB%93%E8%AE%BA-toc" style="margin-left:80px;"><a href="#%E7%BB%93%E8%AE%BA" rel="nofollow">结论</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B" rel="nofollow">三、共享模型之管程</a></p> 
<p id="1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">1、线程共享带来的问题</a></p> 
<p id="2%E3%80%81synchronized%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:40px;"><a href="#2%E3%80%81synchronized%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">2、synchronized 解决方案</a></p> 
<p id="1%EF%BC%89%E8%A7%A3%E5%86%B3%E6%89%8B%E6%AE%B5-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E8%A7%A3%E5%86%B3%E6%89%8B%E6%AE%B5" rel="nofollow">1）解决手段</a></p> 
<p id="2%EF%BC%89synchronized%20%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#2%EF%BC%89synchronized%20%E8%AF%AD%E6%B3%95" rel="nofollow">2）synchronized 语法</a></p> 
<p id="3%EF%BC%89synchronized%20%E5%8A%A0%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A-toc" style="margin-left:80px;"><a href="#3%EF%BC%89synchronized%20%E5%8A%A0%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A" rel="nofollow">3）synchronized 加在方法上</a></p> 
<p id="3%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90" rel="nofollow">3、变量的线程安全分析</a></p> 
<p id="1%EF%BC%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90" rel="nofollow">1）成员变量和静态变量的线程安全分析</a></p> 
<p id="2%EF%BC%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90" rel="nofollow">2）局部变量线程安全分析</a></p> 
<p id="3%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">3）线程安全的情况</a></p> 
<p id="4%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">4）线程不安全的情况</a></p> 
<p id="5%EF%BC%89%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#5%EF%BC%89%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90" rel="nofollow">5）不安全原因分析</a></p> 
<p id="6%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#6%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" rel="nofollow">6）解决方法</a></p> 
<p id="7%EF%BC%89%E6%80%9D%E8%80%83%20private%20%E6%88%96%20final%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7-toc" style="margin-left:80px;"><a href="#7%EF%BC%89%E6%80%9D%E8%80%83%20private%20%E6%88%96%20final%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7" rel="nofollow">7）思考 private 或 final的重要性</a></p> 
<p id="8%EF%BC%89%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#8%EF%BC%89%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB" rel="nofollow">8）常见线程安全类</a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%84%E5%90%88-toc" style="margin-left:120px;"><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%84%E5%90%88" rel="nofollow">线程安全类方法的组合</a></p> 
<p id="%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-toc" style="margin-left:120px;"><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" rel="nofollow">不可变类的线程安全</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90-%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90-%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" rel="nofollow">示例分析-是否线程安全</a></p> 
<p id="4%E3%80%81Monitor%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#4%E3%80%81Monitor%20%E6%A6%82%E5%BF%B5" rel="nofollow">4、Monitor 概念</a></p> 
<p id="1%EF%BC%89Java%20%E5%AF%B9%E8%B1%A1%E5%A4%B4-toc" style="margin-left:80px;"><a href="#1%EF%BC%89Java%20%E5%AF%B9%E8%B1%A1%E5%A4%B4" rel="nofollow">1）Java 对象头</a></p> 
<p id="%C2%A02%EF%BC%89Monitor%20%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%C2%A02%EF%BC%89Monitor%20%E5%8E%9F%E7%90%86" rel="nofollow"> 2）Monitor 原理</a></p> 
<p id="5%E3%80%81synchronized%20%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6-toc" style="margin-left:40px;"><a href="#5%E3%80%81synchronized%20%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6" rel="nofollow">5、synchronized 原理进阶</a></p> 
<p id="1%EF%BC%89synchronized%20%E7%94%A8%E4%BA%8E%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#1%EF%BC%89synchronized%20%E7%94%A8%E4%BA%8E%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86" rel="nofollow">1）synchronized 用于同步代码块与同步方法原理</a></p> 
<p id="2%EF%BC%89%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81" rel="nofollow">2）轻量级锁</a></p> 
<p id="3%EF%BC%89%E9%94%81%E8%86%A8%E8%83%80-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E9%94%81%E8%86%A8%E8%83%80" rel="nofollow">3）锁膨胀</a></p> 
<p id="4%EF%BC%89%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96" rel="nofollow">4）自旋优化</a></p> 
<p id="5%EF%BC%89%E5%81%8F%E5%90%91%E9%94%81-toc" style="margin-left:80px;"><a href="#5%EF%BC%89%E5%81%8F%E5%90%91%E9%94%81" rel="nofollow">5）偏向锁</a></p> 
<p id="%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91-toc" style="margin-left:120px;"><a href="#%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91" rel="nofollow">撤销偏向</a></p> 
<p id="6%EF%BC%89%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91-toc" style="margin-left:80px;"><a href="#6%EF%BC%89%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91" rel="nofollow">6）批量重偏向</a></p> 
<p id="7%EF%BC%89%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80-toc" style="margin-left:80px;"><a href="#7%EF%BC%89%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80" rel="nofollow">7）批量撤销</a></p> 
<p id="6%E3%80%81Wait%2FNotify-toc" style="margin-left:40px;"><a href="#6%E3%80%81Wait%2FNotify" rel="nofollow">6、Wait/Notify</a></p> 
<p id="1%EF%BC%89%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%8E%9F%E7%90%86" rel="nofollow">1）原理</a></p> 
<p id="2%EF%BC%89Wait%20%E4%B8%8E%20Sleep%20%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#2%EF%BC%89Wait%20%E4%B8%8E%20Sleep%20%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2）Wait 与 Sleep 的区别</a></p> 
<p id="3%EF%BC%89%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20wait%2Fnotify-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20wait%2Fnotify" rel="nofollow">3）优雅地使用 wait/notify</a></p> 
<p id="4%EF%BC%89%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C" rel="nofollow">4）同步模式之保护性暂停</a></p> 
<p id="%C2%A05%EF%BC%89%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%2F%E6%B6%88%E8%B4%B9%E8%80%85-toc" style="margin-left:80px;"><a href="#%C2%A05%EF%BC%89%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%2F%E6%B6%88%E8%B4%B9%E8%80%85" rel="nofollow"> 5）异步模式之生产者/消费者</a></p> 
<p id="7%E3%80%81park%20%26%20unpark-toc" style="margin-left:40px;"><a href="#7%E3%80%81park%20%26%20unpark" rel="nofollow">7、park &amp; unpark</a></p> 
<p id="1%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">1）基本使用</a></p> 
<p id="2%EF%BC%89park%20unpark%20%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#2%EF%BC%89park%20unpark%20%E5%8E%9F%E7%90%86" rel="nofollow">2）park unpark 原理</a></p> 
<p id="%C2%A08%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px;"><a href="#%C2%A08%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" rel="nofollow"> 8、线程状态转换</a></p> 
<p id="9%E3%80%81%E6%B4%BB%E8%B7%83%E6%80%A7-toc" style="margin-left:40px;"><a href="#9%E3%80%81%E6%B4%BB%E8%B7%83%E6%80%A7" rel="nofollow">9、活跃性</a></p> 
<p id="1%EF%BC%89%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%AE%9A%E4%B9%89" rel="nofollow">1）定义</a></p> 
<p id="2%EF%BC%89%E6%AD%BB%E9%94%81-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E6%AD%BB%E9%94%81" rel="nofollow">2）死锁</a></p> 
<p id="3%EF%BC%89%E6%B4%BB%E9%94%81-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E6%B4%BB%E9%94%81" rel="nofollow">3）活锁</a></p> 
<p id="4%EF%BC%89%E9%A5%A5%E9%A5%BF-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E9%A5%A5%E9%A5%BF" rel="nofollow">4）饥饿</a></p> 
<p id="10%E3%80%81ReentrantLock-toc" style="margin-left:40px;"><a href="#10%E3%80%81ReentrantLock" rel="nofollow">10、ReentrantLock</a></p> 
<p id="%C2%A01%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A01%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5" rel="nofollow"> 1）可重入</a></p> 
<p id="2%EF%BC%89%E5%8F%AF%E6%89%93%E6%96%AD-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%8F%AF%E6%89%93%E6%96%AD" rel="nofollow">2）可打断</a></p> 
<p id="3%EF%BC%89%E9%94%81%E8%B6%85%E6%97%B6-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E9%94%81%E8%B6%85%E6%97%B6" rel="nofollow">3）锁超时</a></p> 
<p id="4%EF%BC%89%E5%85%AC%E5%B9%B3%E9%94%81-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E5%85%AC%E5%B9%B3%E9%94%81" rel="nofollow">4）公平锁</a></p> 
<p id="5%EF%BC%89%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#5%EF%BC%89%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F" rel="nofollow">5）条件变量</a></p> 
<p id="11%E3%80%81%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6-toc" style="margin-left:40px;"><a href="#11%E3%80%81%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6" rel="nofollow">11、同步模式之顺序控制</a></p> 
<p id="1%EF%BC%89Wait%2FNotify%20%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#1%EF%BC%89Wait%2FNotify%20%E5%AE%9E%E7%8E%B0" rel="nofollow">1）Wait/Notify 实现</a></p> 
<p id="2%EF%BC%89park%2Funpark%C2%A0%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2%EF%BC%89park%2Funpark%C2%A0%E5%AE%9E%E7%8E%B0" rel="nofollow">2）park/unpark 实现</a></p> 
<p id="3%EF%BC%89await%2Fsignal%20%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#3%EF%BC%89await%2Fsignal%20%E5%AE%9E%E7%8E%B0" rel="nofollow">3）await/signal 实现</a></p> 
<p id="%E7%BB%93%E8%AE%BA-toc" style="margin-left:40px;"><a href="#%E7%BB%93%E8%AE%BA" rel="nofollow">结论</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98" rel="nofollow">四、共享模型之内存</a></p> 
<p id="1%E3%80%81Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89" rel="nofollow">1、Java 内存模型（JMM）</a></p> 
<p id="2%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7" rel="nofollow">2、可见性</a></p> 
<p id="1%EF%BC%89%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF" rel="nofollow">1）退不出的循环</a></p> 
<p id="2%EF%BC%89%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%80%A7-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%80%A7" rel="nofollow">2）可见性与原子性</a></p> 
<p id="3%EF%BC%89%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2" rel="nofollow">3）模式之两阶段终止</a></p> 
<p id="4%EF%BC%89%E6%A8%A1%E5%BC%8F%E4%B9%8B%20Balking-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E6%A8%A1%E5%BC%8F%E4%B9%8B%20Balking" rel="nofollow">4）模式之 Balking</a></p> 
<p id="3%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7" rel="nofollow">3、有序性</a></p> 
<p id="1%EF%BC%89%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92" rel="nofollow">1）指令重排</a></p> 
<p id="2%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E9%97%AE%E9%A2%98" rel="nofollow">2）多线程下指令重排问题</a></p> 
<p id="3%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" rel="nofollow">3）解决方法</a></p> 
<p id="4%E3%80%81volatile%20%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#4%E3%80%81volatile%20%E5%8E%9F%E7%90%86" rel="nofollow">4、volatile 原理</a></p> 
<p id="1%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7" rel="nofollow">1）如何保证可见性</a></p> 
<p id="2%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7" rel="nofollow">2）如何保证有序性</a></p> 
<p id="3%EF%BC%89double-checked%20locking%20%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#3%EF%BC%89double-checked%20locking%20%E9%97%AE%E9%A2%98" rel="nofollow">3）double-checked locking 问题</a></p> 
<p id="4%EF%BC%89double-checked%20locking%20%E8%A7%A3%E5%86%B3-toc" style="margin-left:80px;"><a href="#4%EF%BC%89double-checked%20locking%20%E8%A7%A3%E5%86%B3" rel="nofollow">4）double-checked locking 解决</a></p> 
<p id="5%E3%80%81happens-before-toc" style="margin-left:40px;"><a href="#5%E3%80%81happens-before" rel="nofollow">5、happens-before</a></p> 
<p id="6%E3%80%81%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E7%BB%83%E4%B9%A0" rel="nofollow">6、练习</a></p> 
<p id="%E7%BB%93%E8%AE%BA-toc" style="margin-left:40px;"><a href="#%E7%BB%93%E8%AE%BA" rel="nofollow">结论</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81" rel="nofollow">五、共享模型之无锁</a></p> 
<p id="1%E3%80%81%E6%97%A0%E9%94%81%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%97%A0%E9%94%81%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" rel="nofollow">1、无锁解决线程安全问题</a></p> 
<p id="2%E3%80%81CAS%20%E4%B8%8E%20volatile-toc" style="margin-left:40px;"><a href="#2%E3%80%81CAS%20%E4%B8%8E%20volatile" rel="nofollow">2、CAS 与 volatile</a></p> 
<p id="1%EF%BC%89cas-toc" style="margin-left:80px;"><a href="#1%EF%BC%89cas" rel="nofollow">1）cas</a></p> 
<p id="2%EF%BC%89volatile-toc" style="margin-left:80px;"><a href="#2%EF%BC%89volatile" rel="nofollow">2）volatile</a></p> 
<p id="3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98" rel="nofollow">3）为什么无锁效率高</a></p> 
<p id="4%EF%BC%89CAS%20%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#4%EF%BC%89CAS%20%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">4）CAS 的特点</a></p> 
<p id="3%E3%80%81%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0" rel="nofollow">3、原子整数</a></p> 
<p id="4%E3%80%81%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%C2%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%C2%A0" rel="nofollow">4、原子引用 </a></p> 
<p id="1%EF%BC%89AtomicReference-toc" style="margin-left:80px;"><a href="#1%EF%BC%89AtomicReference" rel="nofollow">1）AtomicReference</a></p> 
<p id="2%EF%BC%89ABA%20%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#2%EF%BC%89ABA%20%E9%97%AE%E9%A2%98" rel="nofollow">2）ABA 问题</a></p> 
<p id="3)AtomicStampedReference-toc" style="margin-left:80px;"><a href="#3%29AtomicStampedReference" rel="nofollow">3)AtomicStampedReference</a></p> 
<p id="4)AtomicMarkableReference-toc" style="margin-left:80px;"><a href="#4%29AtomicMarkableReference" rel="nofollow">4)AtomicMarkableReference</a></p> 
<p id="5%E3%80%81%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84" rel="nofollow">5、原子数组</a></p> 
<p id="6%E3%80%81%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8" rel="nofollow">6、字段更新器</a></p> 
<p id="7%E3%80%81%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8" rel="nofollow">7、原子累加器</a></p> 
<p id="1%EF%BC%89AtomicLong%20Vs%20LongAdder-toc" style="margin-left:80px;"><a href="#1%EF%BC%89AtomicLong%20Vs%20LongAdder" rel="nofollow">1）AtomicLong Vs LongAdder</a></p> 
<p id="8%E3%80%81LongAdder%20%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#8%E3%80%81LongAdder%20%E5%8E%9F%E7%90%86" rel="nofollow">8、LongAdder 原理</a></p> 
<p id="1%EF%BC%89%E4%BD%BF%E7%94%A8%20cas%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E4%BD%BF%E7%94%A8%20cas%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81" rel="nofollow">1）使用 cas 实现一个自旋锁</a></p> 
<p id="2%EF%BC%89%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BC%AA%E5%85%B1%E4%BA%AB-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BC%AA%E5%85%B1%E4%BA%AB" rel="nofollow">2）原理之伪共享</a></p> 
<p id="%C2%A03%EF%BC%89add%20%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%C2%A03%EF%BC%89add%20%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow"> 3）add 方法分析</a></p> 
<p id="4%EF%BC%89sum%20%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#4%EF%BC%89sum%20%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">4）sum 方法分析</a></p> 
<p id="5%E3%80%81Unsafe-toc" style="margin-left:40px;"><a href="#5%E3%80%81Unsafe" rel="nofollow">5、Unsafe</a></p> 
<p id="1%EF%BC%89Unsafe%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96-toc" style="margin-left:80px;"><a href="#1%EF%BC%89Unsafe%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96" rel="nofollow">1）Unsafe 对象的获取</a></p> 
<p id="2%EF%BC%89Unsafe%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%20cas%20%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#2%EF%BC%89Unsafe%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%20cas%20%E6%93%8D%E4%BD%9C" rel="nofollow">2）Unsafe 模拟实现 cas 操作</a></p> 
<p id="3%EF%BC%89Unsafe%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0-toc" style="margin-left:80px;"><a href="#3%EF%BC%89Unsafe%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0" rel="nofollow">3）Unsafe 模拟实现原子整数</a></p> 
<p id="%E7%BB%93%E8%AE%BA-toc" style="margin-left:40px;"><a href="#%E7%BB%93%E8%AE%BA" rel="nofollow">结论</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98" rel="nofollow">六、共享模型之不可变</a></p> 
<p id="1%E3%80%81%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">1、日期转换的问题</a></p> 
<p id="2%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1" rel="nofollow">2、不可变设计</a></p> 
<p id="1%EF%BC%89final%20%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#1%EF%BC%89final%20%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1）final 的使用</a></p> 
<p id="2%EF%BC%89%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D-toc" style="margin-left:40px;"><a href="#2%EF%BC%89%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D" rel="nofollow">2）保护性拷贝</a></p> 
<p id="3%E3%80%81%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83" rel="nofollow">3、模式之享元</a></p> 
<p id="1%EF%BC%89%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E7%AE%80%E4%BB%8B" rel="nofollow">1）简介</a></p> 
<p id="2%EF%BC%89%E4%BD%93%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E4%BD%93%E7%8E%B0" rel="nofollow">2）体现</a></p> 
<p id="3%EF%BC%89DIY%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-toc" style="margin-left:80px;"><a href="#3%EF%BC%89DIY%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0" rel="nofollow">3）DIY 实现简单的数据库连接池</a></p> 
<p id="4%E3%80%81final%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#4%E3%80%81final%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">4、final的原理</a></p> 
<p id="1%EF%BC%89%E8%AE%BE%E7%BD%AE%20final%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E8%AE%BE%E7%BD%AE%20final%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">1）设置 final 变量的原理</a></p> 
<p id="%E7%BB%93%E8%AE%BA-toc" style="margin-left:40px;"><a href="#%E7%BB%93%E8%AE%BA" rel="nofollow">结论</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7" rel="nofollow">七、共享模型之工具</a></p> 
<p id="1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">1、线程池</a></p> 
<p id="2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">2、自定义线程池</a></p> 
<p id="3%E3%80%81ThreadPoolExecutor-toc" style="margin-left:40px;"><a href="#3%E3%80%81ThreadPoolExecutor" rel="nofollow">3、ThreadPoolExecutor</a></p> 
<p id="1%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81" rel="nofollow">1）线程池状态</a></p> 
<p id="2%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">2）构造方法</a></p> 
<p id="3%EF%BC%89newFixedThreadPool-toc" style="margin-left:80px;"><a href="#3%EF%BC%89newFixedThreadPool" rel="nofollow">3）newFixedThreadPool</a></p> 
<p id="4%EF%BC%89newCachedThreadPool-toc" style="margin-left:80px;"><a href="#4%EF%BC%89newCachedThreadPool" rel="nofollow">4）newCachedThreadPool</a></p> 
<p id="5)newSingleThreadExecutor%C2%A0-toc" style="margin-left:80px;"><a href="#5%29newSingleThreadExecutor%C2%A0" rel="nofollow">5)newSingleThreadExecutor </a></p> 
<p id="%C2%A06%EF%BC%89%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A06%EF%BC%89%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%C2%A0" rel="nofollow"> 6）提交任务 </a></p> 
<p id="7%EF%BC%89%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:80px;"><a href="#7%EF%BC%89%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">7）关闭线程池</a></p> 
<p id="8%EF%BC%89%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:80px;"><a href="#8%EF%BC%89%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">8）任务调度线程池</a></p> 
<p id="9%EF%BC%89%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><a href="#9%EF%BC%89%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8" rel="nofollow">9）正确处理执行任务异常</a></p> 
<p id="10%EF%BC%89Tomcat%20%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:80px;"><a href="#10%EF%BC%89Tomcat%20%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">10）Tomcat 线程池</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%C2%A0" rel="nofollow">异步模式之工作线程 </a></p> 
<p id="%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" rel="nofollow">应用之定时任务</a></p> 
<p id="4%E3%80%81Fork%2FJoin-toc" style="margin-left:40px;"><a href="#4%E3%80%81Fork%2FJoin" rel="nofollow">4、Fork/Join</a></p> 
<p id="5%E3%80%81J.U.C-toc" style="margin-left:0px;"><a href="#5%E3%80%81J.U.C" rel="nofollow">5、J.U.C</a></p> 
<p id="AQS%20%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#AQS%20%E5%8E%9F%E7%90%86" rel="nofollow">AQS 原理</a></p> 
<p id="1%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:120px;"><a href="#1%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow">1、概述</a></p> 
<p id="2%E3%80%81%E7%89%B9%E7%82%B9-toc" style="margin-left:120px;"><a href="#2%E3%80%81%E7%89%B9%E7%82%B9" rel="nofollow">2、特点</a></p> 
<p id="%C2%A03%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8-toc" style="margin-left:120px;"><a href="#%C2%A03%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8" rel="nofollow"> 3、自定义同步器</a></p> 
<p id="ReentrantLock%20%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#ReentrantLock%20%E5%8E%9F%E7%90%86" rel="nofollow">ReentrantLock 原理</a></p> 
<p id="1%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">1、非公平锁实现原理</a></p> 
<p id="1%EF%BC%89%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B-toc" style="margin-left:120px;"><a href="#1%EF%BC%89%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B" rel="nofollow">1）加锁解锁流程</a></p> 
<p id="2%E3%80%81%E9%94%81%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E9%94%81%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86" rel="nofollow">2、锁重入原理</a></p> 
<p id="3%E3%80%81%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86" rel="nofollow">3、可打断原理</a></p> 
<p id="4%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E5%8E%9F%E7%90%86" rel="nofollow">4、公平锁原理</a></p> 
<p id="5%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">5、条件变量实现原理</a></p> 
<p id="%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86" rel="nofollow">读写锁原理</a></p> 
<p id="1%E3%80%81ReentrantReadWriteLock-toc" style="margin-left:80px;"><a href="#1%E3%80%81ReentrantReadWriteLock" rel="nofollow">1、ReentrantReadWriteLock</a></p> 
<p id="2%E3%80%81%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BC%93%E5%AD%98-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BC%93%E5%AD%98" rel="nofollow">2、应用之缓存</a></p> 
<p id="3%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86" rel="nofollow">3、读写锁原理</a></p> 
<p id="4%E3%80%81StampedLock-toc" style="margin-left:80px;"><a href="#4%E3%80%81StampedLock" rel="nofollow">4、StampedLock</a></p> 
<p id="Semaphore-toc" style="margin-left:40px;"><a href="#Semaphore" rel="nofollow">Semaphore</a></p> 
<p id="1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">1、基本使用</a></p> 
<p id="2%E3%80%81%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B" rel="nofollow">2、图解流程</a></p> 
<p id="3%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%C2%A0-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%C2%A0" rel="nofollow">3、源码分析 </a></p> 
<p id="CountdownLatch-toc" style="margin-left:40px;"><a href="#CountdownLatch" rel="nofollow">CountdownLatch</a></p> 
<p id="%C2%A0CyclicBarrier-toc" style="margin-left:40px;"><a href="#%C2%A0CyclicBarrier" rel="nofollow"> CyclicBarrier</a></p> 
<p id="LinkedBlockingQueue-toc" style="margin-left:40px;"><a href="#LinkedBlockingQueue" rel="nofollow">LinkedBlockingQueue</a></p> 
<p id="1%EF%BC%89%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C" rel="nofollow">1）入队操作</a></p> 
<p id="3%EF%BC%89%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90" rel="nofollow">3）加锁分析</a></p> 
<p id="4%EF%BC%89put%20%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#4%EF%BC%89put%20%E6%93%8D%E4%BD%9C" rel="nofollow">4）put 操作</a></p> 
<p id="5%EF%BC%89take%20%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#5%EF%BC%89take%20%E6%93%8D%E4%BD%9C" rel="nofollow">5）take 操作</a></p> 
<p id="6%EF%BC%89%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#6%EF%BC%89%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83" rel="nofollow">6）性能比较</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">一、基本概念</h2> 
<h3 id="1%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">1、进程与线程</h3> 
<p><strong>进程</strong></p> 
<ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程，也有的程序只能启动一个实例进程</li></ul> 
<p><strong>线程</strong></p> 
<ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul> 
<p><strong>两者对比</strong></p> 
<ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul> 
<h3 id="2%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C">2、并发与并行</h3> 
<p>并发是一个CPU在不同的时间去不同线程中执行指令。<br> 并行是多个CPU同时处理不同的线程。</p> 
<h3 id="3%E3%80%81%E5%BA%94%E7%94%A8">3、应用</h3> 
<p><strong>同步和异步</strong></p> 
<p>以调用方的角度讲，如果</p> 
<ul><li>需要等待结果返回才能继续运行的话就是<strong>同步</strong></li><li>不需要等待就是<strong>异步</strong></li></ul> 
<p>1）设计<br> 多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，那么 cpu 只能等 5 秒，啥都不能做。<br> 2) 结论<br> 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程<br> tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程<br> ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p> 
<p><strong>提高效率</strong></p> 
<div> 
 <span style="color:#333333;">充分利用多核</span> 
 <span style="color:#333333;"> cpu </span> 
 <span style="color:#333333;">的优势，提高运行效率。想象下面的场景，执行</span> 
 <span style="color:#333333;"> 3 </span> 
 <span style="color:#333333;">个计算，最后将计算结果汇总。 </span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#333333;">计算</span> 
   <span style="color:#333333;"> 1 </span> 
   <span style="color:#333333;">花费</span> 
   <span style="color:#333333;"> 10 ms </span> 
  </div> 
  <div> 
   <span style="color:#333333;">计算</span> 
   <span style="color:#333333;"> 2 </span> 
   <span style="color:#333333;">花费</span> 
   <span style="color:#333333;"> 11 ms </span> 
  </div> 
  <div> 
   <span style="color:#333333;">计算</span> 
   <span style="color:#333333;"> 3 </span> 
   <span style="color:#333333;">花费</span> 
   <span style="color:#333333;"> 9 ms </span> 
  </div> 
  <div> 
   <span style="color:#333333;">汇总需要</span> 
   <span style="color:#333333;"> 1 ms</span> 
  </div> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">如果是串行执行，那么总共花费的时间是 </span> 
 <span style="color:#333333;">10 + 11 + 9 + 1 = 31ms </span> 
</div> 
<div> 
 <span style="color:#333333;">但如果是四核</span> 
 <span style="color:#333333;"> cpu</span> 
 <span style="color:#333333;">，各个核心分别使用线程</span> 
 <span style="color:#333333;"> 1 </span> 
 <span style="color:#333333;">执行计算</span> 
 <span style="color:#333333;"> 1</span> 
 <span style="color:#333333;">，线程</span> 
 <span style="color:#333333;"> 2 </span> 
 <span style="color:#333333;">执行计算</span> 
 <span style="color:#333333;"> 2</span> 
 <span style="color:#333333;">，线程</span> 
 <span style="color:#333333;"> 3 </span> 
 <span style="color:#333333;">执行计算</span> 
 <span style="color:#333333;"> 3</span> 
 <span style="color:#333333;">，那么</span> 
 <span style="color:#333333;"> 3 </span> 
 <span style="color:#333333;">个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms</span> 
 <span style="color:#333333;">最后加上汇总时间只会花费 </span> 
 <span style="color:#333333;">12ms </span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#777777;"><strong>注意 </strong></span> 
  </div> 
  <div> 
   <span style="color:#777777;">需要在多核</span> 
   <span style="color:#777777;"> cpu </span> 
   <span style="color:#777777;">才能提高效率，单核仍然时是轮流执行</span> 
  </div> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;"><strong>结论 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;">单核</span> 
 <span style="color:#333333;"> cpu </span> 
 <span style="color:#333333;">下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用</span> 
 <span style="color:#333333;"> cpu</span> 
 <span style="color:#333333;">，别的线程没法干活 </span> 
</div> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;">多核</span> 
 <span style="color:#333333;"> cpu </span> 
 <span style="color:#333333;">可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 </span> 
</div> 
<div> 
 <span style="color:#333333;">有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】） </span> 
</div> 
<div> 
 <span style="color:#333333;">也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 </span> 
</div> 
<div> 
 <span style="color:#333333;">3. IO </span> 
 <span style="color:#333333;">操作不占用</span> 
 <span style="color:#333333;"> cpu</span> 
 <span style="color:#333333;">，只是我们一般拷贝文件使用的是【阻塞</span> 
 <span style="color:#333333;"> IO</span> 
 <span style="color:#333333;">】，这时相当于线程虽然不用</span> 
 <span style="color:#333333;"> cpu</span> 
 <span style="color:#333333;">，但需要一 直等待 IO </span> 
 <span style="color:#333333;">结束，没能充分利用线程。所以才有后面的【非阻塞</span> 
 <span style="color:#333333;"> IO</span> 
 <span style="color:#333333;">】和【异步</span> 
 <span style="color:#333333;"> IO</span> 
 <span style="color:#333333;">】优化</span> 
</div> 
<div></div> 
<h2 id="%E4%BA%8C%E3%80%81Java%20%E7%BA%BF%E7%A8%8B">二、Java 线程</h2> 
<h3 id="1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C">1、线程创建与运行</h3> 
<h4 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB">方法一：继承Thread类</h4> 
<pre><code class="language-java">public static void main(String[] args) {
        // 匿名内部类方式创建 Thread
        Thread t = new Thread("t1") {
            @Override
            public void run() {
                log.debug("running");
            }
        };
        t.start();
    }
</code></pre> 
<h4 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnale%E6%8E%A5%E5%8F%A3"><strong>方法二：实现Runnale接口</strong></h4> 
<pre><code class="language-java">public static void main(String[] args) {
        // 使用 lambda 表达式，因为 Runnable 接口 
        // 标注了 @FunctionalInterface 这个注解，表示是一个函数式接口，可以使用 lambda 表达式
        Thread t2=new Thread(()-&gt;{
           log.debug("running");
        },"t2");
        t2.start();
    }
</code></pre> 
<p><strong>比较方法一和方法二：</strong><br> 方法 1 是把线程和任务合并在了一起<br> 方法 2 是把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。<br> 通过查看源码可以发现，方法二其实还是通过使用 Thread 类中的 run 方法执行的！</p> 
<h4 id="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3">方法三：实现Callable接口</h4> 
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 1. 使用 FutureTask 传入 Callable 接口方式创建
        FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(() -&gt; {
            log.debug("running...");
            Thread.sleep(2000); // 休眠
            return 100;
        });
        // 2. 传入 future, 因为 FutureTask 这个类是实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 接口
        Thread t1 = new Thread(future, "t1");
        t1.start();
        // 3. 获取返回结果时
        // 当主线程获取 t1 线程的返回值时, 需要等 2 秒，此时主线程进入阻塞状态
        log.debug("{}",  future.get());
    }
</code></pre> 
<p>Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。</p> 
<pre><code class="language-java">public interface Future&lt;V&gt; {
	// 取消任务
	boolean cancel(boolean mayInterruptIfRunning);
	// 获取任务执行结果
	V get() throws InterruptedException, ExecutionException;
	// 获取任务执行结果，带有超时时间限制
	V get(long timeout, TimeUnit unit) throws InterruptedException,                             ExecutionException,  TimeoutException;
	// 判断任务是否已经取消
	boolean isCancelled();
	// 判断任务是否已经结束
	boolean isDone();
}
</code></pre> 
<p>FutureTask 类是 Future 接口和 Runable 接口的实现弥补 runnable 创建线程没有返回值的缺陷，<a href="https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag" rel="nofollow" title="点这里了解">点这里了解</a></p> 
<h3 id="2%E3%80%81%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">2、线程运行原理</h3> 
<p><strong>栈与栈帧</strong></p> 
<div> 
 <span style="color:#333333;">Java Virtual Machine Stacks </span> 
 <span style="color:#333333;">（</span> 
 <span style="color:#333333;">Java </span> 
 <span style="color:#333333;">虚拟机栈）</span> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">我们都知道</span> 
  <span style="color:#333333;"> JVM </span> 
  <span style="color:#333333;">中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。</span> 
 </div> 
 <div> 
  <ul><li><span style="color:#333333;">每个栈由多个栈帧（</span><span style="color:#333333;">Frame</span><span style="color:#333333;">）组成，对应着每次方法调用时所占用的内存 </span></li><li><span style="color:#333333;">每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 </span></li></ul> 
  <p><strong><span style="color:#333333;">线程上下文切换（</span><span style="color:#333333;">Thread Context Switch</span><span style="color:#333333;">） </span></strong></p> 
  <div> 
   <span style="color:#333333;">因为以下一些原因导致</span> 
   <span style="color:#333333;"> cpu </span> 
   <span style="color:#333333;">不再执行当前的线程，转而执行另一个线程的代码</span> 
  </div> 
  <div> 
   <ul><li><span style="color:#333333;">线程的</span><span style="color:#333333;"> cpu </span><span style="color:#333333;">时间片用完 </span></li><li><span style="color:#333333;">垃圾回收 </span></li><li><span style="color:#333333;">有更高优先级的线程需要运行 </span></li><li><span style="color:#333333;">线程自己调用了</span><span style="color:#333333;"> sleep</span><span style="color:#333333;">、</span><span style="color:#333333;">yield</span><span style="color:#333333;">、</span><span style="color:#333333;">wait</span><span style="color:#333333;">、</span><span style="color:#333333;">join</span><span style="color:#333333;">、</span><span style="color:#333333;">park</span><span style="color:#333333;">、</span><span style="color:#333333;">synchronized</span><span style="color:#333333;">、</span><span style="color:#333333;">lock </span><span style="color:#333333;">等方法</span></li></ul> 
   <div> 
    <span style="color:#333333;">当</span> 
    <span style="color:#333333;"> Context Switch </span> 
    <span style="color:#333333;">发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，</span> 
    <span style="color:#333333;">Java </span> 
    <span style="color:#333333;">中对应的概念就是程序计数器（Program Counter Register</span> 
    <span style="color:#333333;">），它的作用是记住下一条</span> 
    <span style="color:#333333;"> jvm </span> 
    <span style="color:#333333;">指令的执行地址，是线程私有的 </span> 
   </div> 
   <div> 
    <ul><li><span style="color:#333333;">状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 </span></li><li><span style="color:#333333;">Context Switch </span><span style="color:#333333;">频繁发生会影响性能 </span></li></ul> 
    <h3 id="3%E3%80%81Thread%20%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95">3、Thread 的常见方法</h3> 
    <p><img alt="" height="788" src="https://images2.imgbox.com/f6/09/EqsbFS0z_o.png" width="801"></p> 
    <h4 id="%C2%A01%EF%BC%89start()%E4%B8%8Erun()"><strong> 1）start()与run()</strong></h4> 
    <ul><li><span style="color:#333333;">直接调用</span><span style="color:#333333;"> run </span><span style="color:#333333;">是在主线程中执行了</span><span style="color:#333333;"> run</span><span style="color:#333333;">，没有启动新的线程 </span></li><li><span style="color:#333333;">使用</span><span style="color:#333333;"> start </span><span style="color:#333333;">是启动新的线程，通过新的线程间接执行</span><span style="color:#333333;"> run </span><span style="color:#333333;">中的代码 </span></li></ul> 
    <h4 id="2%EF%BC%89sleep()%E4%B8%8Eyield()">2）sleep()与yield()</h4> 
    <p><strong>sleep (使线程阻塞)</strong></p> 
    <ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞），可通过state()方法查看</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ol> 
    <p><strong>案例-防止CPU占用100%</strong></p> 
    <p>在没有利用CPU计算时，不要让while(true)空转浪费cpu这时可以使用sleep或yiled来让出cpu的使用权给其他线程</p> 
    <p><strong>yield （让出当前线程）</strong></p> 
    <ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态（仍然有可能被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol> 
    <p><strong>线程优先级</strong><br> 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p> 
    <h4 id="3%EF%BC%89join()%20%E6%96%B9%E6%B3%95">3）join() 方法</h4> 
    <p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。<br> 如在主线程中调用ti.join()，则是主线程等待t1线程结束，join 采用同步。</p> 
    <pre><code class="language-java">Thread t1 = new Thread();
//等待 t1 线程执行结束
t1.join();
// 最多等待 1000ms,如果 1000ms 内线程执行完毕，则会直接执行下面的语句，不会等够 1000ms
t1.join(1000);
</code></pre> 
    <h4 id="4%EF%BC%89interrupt()%20%E6%96%B9%E6%B3%95">4）interrupt() 方法</h4> 
    <p>interrupt 打断线程有两种情况，如下：</p> 
    <ul><li>如果一个线程在在运行中被打断，打断标记会被置为 true 。</li><li>如果是打断在sleep wait join 方法而被阻塞的线程，会将打断标记置为 false 。</li></ul> 
    <p><strong>isInterrupted() 与 interrupted() 比较，如下：</strong></p> 
    <p>首先，isInterrupted 是实例方法，interrupted 是静态方法，它们的用处都是查看当前打断的状态，但是 isInterrupted 方法查看线程的时候，不会将打断标记清空，也就是置为 false，interrupted 查看线程打断状态后，会将打断标志置为 false，也就是清空打断标记，简单来说，interrupt() 方法类似于 setter 设置中断值，isInterrupted() 类似于 getter 获取中断值，interrupted() 类似于 getter + setter 先获取中断值，然后清除标志。</p> 
    <pre><code class="language-java">/**
 * 测试 isInterrupted 与 interrupted
 */
@Slf4j(topic = "c.Code_14_Test")
public class Code_14_Test {

    public static void main(String[] args) throws InterruptedException {

        Thread t1 = new Thread(() -&gt; {
            log.info("park");
            LockSupport.park();
            log.info("unpark");
//            log.info("打断标记为:{}", Thread.currentThread().isInterrupted());
            log.info("打断标记为:{}", Thread.interrupted());

            // 使用 Thread.currentThread().isInterrupted() 查看打断标记为 true, LockSupport.park() 失效
            /**
             * 执行结果：
             * 11:54:17 [t1] c.Code_14_Test - park
             * 11:54:18 [t1] c.Code_14_Test - unpark
             * 11:54:18 [t1] c.Code_14_Test - 打断标记为:true
             * 11:54:18 [t1] c.Code_14_Test - unpark
             */
            // 使用 Thread.interrupted() 查看打断标记为 true, 然后清空打断标记为 false, LockSupport.park() 不失效
            /**
             * 执行结果：
             * 11:58:12 [t1] c.Code_14_Test - park
             * 11:58:13 [t1] c.Code_14_Test - unpark
             * 11:58:13 [t1] c.Code_14_Test - 打断标记为:true
             */
            LockSupport.park();
            log.info("unpark");

        }, "t1");

        t1.start();
        Thread.sleep(1000); // 主线程休眠 1 秒
        t1.interrupt();
    }

}
</code></pre> 
    <p><strong>终止模式之两阶段终止模式，如下：</strong></p> 
    <p>Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个料理后事的机会（如释放锁）。</p> 
    <p><img alt="" height="724" src="https://images2.imgbox.com/6d/44/Lm2hRz9J_o.png" width="966"></p> 
    <p> 代码实现如下：</p> 
    <pre><code class="language-java">/**
 * 使用 interrupt 进行两阶段终止模式
 */
@Slf4j(topic = "c.Code_13_Test")
public class Code_13_Test {

    public static void main(String[] args) throws InterruptedException {
        TwoParseTermination twoParseTermination = new TwoParseTermination();
        twoParseTermination.start();
        Thread.sleep(3500);
        twoParseTermination.stop();
    }

}

@Slf4j(topic = "c.TwoParseTermination")
class TwoParseTermination {

    private Thread monitor;

    // 启动线程
    public void start() {
        monitor = new Thread(() -&gt; {
            while (true) {
                Thread thread = Thread.currentThread();
                if(thread.isInterrupted()) { // 调用 isInterrupted 不会清除标记
                    log.info("料理后事 ...");
                    break;
                } else {
                    try {
                        Thread.sleep(1000);
                        log.info("执行监控的功能 ...");
                    } catch (InterruptedException e) {
                        log.info("设置打断标记 ...");
                        thread.interrupt();
                        e.printStackTrace();
                    }
                }
            }
        }, "monitor");
        monitor.start();
    }

    // 终止线程
    public void stop() {
        monitor.interrupt();
    }
}
</code></pre> 
    <h4 id="5%EF%BC%89sleep%EF%BC%8Cyiled%EF%BC%8Cwait%EF%BC%8Cjoin%20%E5%AF%B9%E6%AF%94">5）sleep，yiled，wait，join 对比</h4> 
    <p>参考文章：<a href="https://www.cnblogs.com/aspirant/p/8876670.html" rel="nofollow" title="点这里">点这里</a></p> 
    <h4 id="6)%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%B3%95"><strong>6)<span style="color:#333333;">不推荐的方法 </span></strong></h4> 
    <p><span style="color:#333333;">还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</span></p> 
    <p><img alt="" height="228" src="https://images2.imgbox.com/84/78/842ldJ4O_o.png" width="1019"></p> 
    <h4 id="7%EF%BC%89%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B">7）守护线程</h4> 
    <div> 
     <span style="color:#333333;">默认情况下，</span> 
     <span style="color:#333333;">Java </span> 
     <span style="color:#333333;">进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守 护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</span> 
    </div> 
    <div> 
     <ul><li><span style="color:#777777;">垃圾回收器线程就是一种守护线程 </span></li><li><span style="color:#777777;">Tomcat </span><span style="color:#777777;">中的</span><span style="color:#777777;"> Acceptor </span><span style="color:#777777;">和</span><span style="color:#777777;"> Poller </span><span style="color:#777777;">线程都是守护线程，所以</span><span style="color:#777777;"> Tomcat </span><span style="color:#777777;">接收到</span><span style="color:#777777;"> shutdown </span><span style="color:#777777;">命令后，不会等</span><span style="color:#777777;">待它们处理完当前请求</span></li></ul> 
     <h3 id="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81">4、线程状态</h3> 
     <p><strong>从操作系统层划分，线程有 5 种状态</strong></p> 
     <p><img alt="" height="606" src="https://images2.imgbox.com/89/45/FxZwRSP2_o.png" width="1049"></p> 
     <div> 
      <span style="color:#333333;">【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 </span> 
     </div> 
     <div> 
      <span style="color:#333333;">【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由</span> 
      <span style="color:#333333;"> CPU </span> 
      <span style="color:#333333;">调度执行 </span> 
     </div> 
     <div> 
      <span style="color:#333333;">【运行状态】指获取了</span> 
      <span style="color:#333333;"> CPU </span> 
      <span style="color:#333333;">时间片运行中的状态 </span> 
     </div> 
     <div> 
      <span style="color:#333333;">当</span> 
      <span style="color:#333333;"> CPU </span> 
      <span style="color:#333333;">时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </span> 
     </div> 
     <div> 
      <span style="color:#333333;">【阻塞状态】 </span> 
     </div> 
     <ul><li><span style="color:#333333;">如果调用了阻塞</span><span style="color:#333333;"> API</span><span style="color:#333333;">，如</span><span style="color:#333333;"> BIO </span><span style="color:#333333;">读写文件，这时该线程实际不会用到</span><span style="color:#333333;"> CPU</span><span style="color:#333333;">，会导致线程上下文切换，进入</span><span style="color:#333333;">【阻塞状态】 </span></li><li><span style="color:#333333;">等</span><span style="color:#333333;"> BIO </span><span style="color:#333333;">操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 </span></li><li><span style="color:#333333;">与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 </span><span style="color:#333333;">调度它们 </span></li></ul> 
     <div> 
      <span style="color:#333333;">【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</span> 
     </div> 
     <div></div> 
     <div> 
      <div> 
       <strong><span style="color:#333333;">这是从 </span><span style="color:#333333;">Java API </span><span style="color:#333333;">层面来描述的 </span></strong> 
      </div> 
      <div> 
       <strong><span style="color:#333333;">根据</span><span style="color:#333333;"> Thread.State </span><span style="color:#333333;">枚举，分为六种状态</span></strong> 
      </div> 
      <div>
        可以参考文章， 
       <a href="https://blog.csdn.net/pange1991/article/details/53860651" title="点这里">点这里</a> 
      </div> 
      <div></div> 
     </div> 
     <p> <img alt="" height="741" src="https://images2.imgbox.com/c4/82/dZU50oYe_o.png" width="1051"></p> 
     <ul><li><span style="color:#333333;">NEW</span> <span style="color:#333333;">线程刚被创建，但是还没有调用 </span><span style="color:#333333;">start() </span><span style="color:#333333;">方法 </span></li><li><span style="color:#333333;">RUNNABLE </span><span style="color:#333333;">当调用了 </span><span style="color:#333333;">start() </span><span style="color:#333333;">方法之后，注意，</span><span style="color:#333333;"><strong>Java API </strong></span><span style="color:#333333;">层面的 </span><span style="color:#333333;">RUNNABLE </span><span style="color:#333333;">状态涵盖了 </span><span style="color:#333333;"><strong>操作系统 </strong></span><span style="color:#333333;">层面的</span><span style="color:#333333;">【可运行状态】、【运行状态】和【阻塞状态】（由于</span><span style="color:#333333;"> BIO </span><span style="color:#333333;">导致的线程阻塞，在</span><span style="color:#333333;"> Java </span><span style="color:#333333;">里无法区分，仍然认为 </span><span style="color:#333333;">是可运行） </span></li><li><span style="color:#333333;">BLOCKED </span><span style="color:#333333;">， </span><span style="color:#333333;">WAITING </span><span style="color:#333333;">， </span><span style="color:#333333;">TIMED_WAITING </span><span style="color:#333333;">都是 </span><span style="color:#333333;"><strong>Java API </strong></span><span style="color:#333333;">层面对【阻塞状态】的细分，后面会在状态转换一节</span><span style="color:#333333;">详述 </span></li><li><span style="color:#333333;">TERMINATED </span><span style="color:#333333;">当线程代码运行结束</span></li></ul> 
     <h4 id="%E7%BB%93%E8%AE%BA">结论</h4> 
     <p> 本章的重点在于掌握<br> 1）线程的创建<br> 2）线程重要的 API，如 start、run、sleep、yield、join、interrupt 等<br> 3）线程的状态<br> 4）原理方面，线程的运行流程，栈、栈帧、上下文切换、程序计数器等知识。<br> 5）Thread 两种创建线程的源码<br> 6）使用 interrupt 来编写两阶段终止<br>  </p> 
     <h2 id="%E4%B8%89%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B">三、共享模型之管程</h2> 
     <h3 id="1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">1、线程共享带来的问题</h3> 
     <p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了。</p> 
     <pre><code class="language-java">	public static int count = 0;
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            for (int i = 1;i &lt; 5000; i++){
                count++;
            }
        });
        Thread t2 = new Thread(() -&gt; {
            for (int i = 1;i &lt; 5000; i++){
                count--;
            }
        });
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("count的值是{}",count);
    }
</code></pre> 
     <p>如上代码，当执行 count++ 或者 count-- 操作的时候，从字节码分析，实际上是 4 步操作。</p> 
     <pre><code class="language-TypeScript">count++; // 操作字节码如下：
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i

count--; // 操作字节码如下：
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
</code></pre> 
     <p>当 CPU 时间片分给 t1 线程时，t1 线程去读取变量值为 0 并且执行 ++ 的操作，如上在字节码自增操作中，当 t1 执行完自增，还没来得急将修改后的值存入静态变量时，假如线程的时间片用完了，并且 CPU 将时间片分配给 t2 线程，t2 线程拿到时间片执行自减操作，并且将修改后的值存入静态变量，此时 count 的值为 -1，但是当 CPU 将时间片分给经历了上下文切换的 t1 线程时，t1 将修改后的值存入静态变量，此时 counter 的值为 1，覆盖了 t2 线程执行的结果，出现了丢失更新，这就是多线对共享资源读取的问题。</p> 
     <p><br><strong>1）临界区 Critical Section</strong></p> 
     <ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源 
       <ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区<br> 例如，下面代码中的临界区</li></ul> 
     <pre><code class="language-java">static int counter = 0;
 
static void increment() 
// 临界区 
{   
    counter++; 
}
 
static void decrement() 
// 临界区 
{ 
    counter--; 
}
</code></pre> 
     <p><strong>2）竞态条件 Race Condition</strong></p> 
     <p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p> 
     <h3 id="2%E3%80%81synchronized%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">2、synchronized 解决方案</h3> 
     <h4 id="1%EF%BC%89%E8%A7%A3%E5%86%B3%E6%89%8B%E6%AE%B5">1）解决手段</h4> 
     <p>为了避免临界区中的竞态条件发生，由多种手段可以达到。</p> 
     <ul><li>阻塞式解决方案：synchronized ，Lock</li><li>非阻塞式解决方案：原子变量</li></ul> 
     <p>现在讨论使用 <strong>synchronized</strong> 来进行解决，即俗称的<strong>对象锁</strong>，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p> 
     <h4 id="2%EF%BC%89synchronized%20%E8%AF%AD%E6%B3%95">2）synchronized 语法</h4> 
     <pre><code class="language-java">synchronized(对象) {
	//临界区
}
</code></pre> 
     <h4 id="3%EF%BC%89synchronized%20%E5%8A%A0%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A">3）synchronized 加在方法上</h4> 
     <ul><li>加在成员方法上，锁住的是对象</li></ul> 
     <pre><code class="language-java">public class Test {
	// 在方法上加上synchronized关键字
	public synchronized void test() {
	
	}
	// 等价于
	public void test() {
		synchronized(this) { // 锁住的是对象
		
		}
	}
}
</code></pre> 
     <ul><li>加在静态方法上，锁住的是类</li></ul> 
     <pre><code class="language-java">public class Test {
	// 在静态方法上加上 synchronized 关键字
	public synchronized static void test() {
	
	}
	//等价于
	public void test() {
		synchronized(Test.class) { // 锁住的是类
		
		}
	}
}
</code></pre> 
     <h3 id="3%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90">3、变量的线程安全分析</h3> 
     <h4 id="1%EF%BC%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90">1）成员变量和静态变量的线程安全分析</h4> 
     <ul><li>如果变量没有在线程间共享，那么线程对该变量操作是安全的</li><li>如果变量在线程间共享 
       <ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码就是临界区，需要考虑线程安全问题</li></ul></li></ul> 
     <h4 id="2%EF%BC%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90">2）局部变量线程安全分析</h4> 
     <ul><li>局部变量【局部变量被初始化为基本数据类型】是安全的</li><li>局部变量是引用类型或者是对象引用则未必是安全的 
       <ul><li>如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的</li><li>如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全问题</li></ul></li></ul> 
     <h4 id="3%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5">3）线程安全的情况</h4> 
     <p>局部变量被初始化为基本数据类型是安全的，代码如下，因为每个线程都会有一份 test() 放在线程私有的栈中，多个线程就有多个，是不被多个线程共享的，所有就没有线程安全问题。</p> 
     <pre><code class="language-java">public static void test() {
     int i = 10;
     i++;
}
</code></pre> 
     <h4 id="4%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5">4）线程不安全的情况</h4> 
     <p>如果局部变量引用的对象逃离方法的范围，那么要考虑线程安全的，分析如下代码：</p> 
     <pre><code class="language-java">@Slf4j(topic = "c.Code_18_Test")
public class Code_18_Test {

    public static void main(String[] args) {
        UnsafeTest unsafeTest = new UnsafeTest();
        for(int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                unsafeTest.method1();
            }, "t" + i).start();
        }
    }

}

class UnsafeTest {

    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    public void method1() {
        for (int i = 0; i &lt; 200; i++) {
            method2();
            method3();
        }
    }

    public void method2() {
        list.add(1);
    }

    public void method3() {
        list.remove(0);
    }

}
</code></pre> 
     <h4 id="5%EF%BC%89%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90">5）不安全原因分析</h4> 
     <p><img alt="" height="652" src="https://images2.imgbox.com/f1/77/kTRJndXo_o.png" width="843"></p> 
     <p> 如图所示，因为 list 是实例变量，则多个线程都会使用到这个共享的实例变量，就会出现线程安全问题，为什么会有安全问题呢，首先要理解 list 添加元素的几步操作，第一步会获取添加元素的下标 index，第二步对指定的 index 位置添加元素，第三步将 index 往后移。<br> 当 t0 线程从 list 拿到 index = 0 后，t0 线程的时间片用完，出现上下文切换，t1 获取时间片开始执行，从 list 也拿到 index =0，然后将元素添加到 index 位置，然后将 index 值加 1，然后 t0 线程获取时间片，对 index = 0 位置添加元素，此时 index = 0 已经存在元素，就会出现报错。</p> 
     <h4 id="6%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">6）解决方法</h4> 
     <p>可以将 list 修改成局部变量，然后将 list 作为引用传入方法中，因为局部变量是每个线程私有的，不会出现共享问题，那么就不会有上述问题了。修改的代码如下：</p> 
     <pre><code class="language-java">
class SafeTest {

    public void method1() {
 
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 200; i++) {
            method2(list);
            method3(list);
        }
    }

    public void method2(List&lt;Integer&gt; list) {
        list.add(1);
    }

    public void method3(List&lt;Integer&gt; list) {
        list.remove(0);
    }

}
</code></pre> 
     <h4 id="7%EF%BC%89%E6%80%9D%E8%80%83%20private%20%E6%88%96%20final%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">7）思考 private 或 final的重要性</h4> 
     <p>在上诉代码中，其实存在线程安全的问题，因为 method2，method3 方法都是用 public 声明的，如果一个类继承 SafeTest 类，对 method2，method3 方法进行了重写，比如重写 method3 方法，代码如下：</p> 
     <pre><code class="language-java">class UnsafeSubTest extends UnsafeTest {

    @Override
    public void method3(List&lt;Integer&gt; list) {
        new Thread(() -&gt; {
            list.remove(0);
        }).start();
    }
}
</code></pre> 
     <p>可以看到重写的方法中又使用到了线程，当主线程和重写的 method3 方法的线程同时存在，此时 list 就是这两个线程的共享资源了，就会出现线程安全问题，我们可以用 private 访问修饰符解决此问题，代码实现如下：</p> 
     <pre><code class="language-java">class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList&lt;String&gt; list) {
        list.add("1");
    }
    private void method3(ArrayList&lt;String&gt; list) {
        list.remove(0);
    }
}
class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList&lt;String&gt; list) {
        new Thread(() -&gt; {
            list.remove(0);
        }).start();
    }
}
</code></pre> 
     <p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】。</p> 
     <h4 id="8%EF%BC%89%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB">8）常见线程安全类</h4> 
     <ul><li>String</li><li>Integer</li><li>StringBuﬀer</li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul> 
     <p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的。如：</p> 
     <pre><code class="language-java">Hashtable table = new Hashtable();
new Thread(()-&gt;{
 	table.put("key1", "value1");
}).start();
new Thread(()-&gt;{
 	table.put("key2", "value2");
}).start();
</code></pre> 
     <h5 id="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%84%E5%90%88">线程安全类方法的组合</h5> 
     <p>但注意它们多个方法的组合不是原子的，看如下代码</p> 
     <pre><code class="language-java">Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
 table.put("key", value);
}
</code></pre> 
     <p><img alt="" height="349" src="https://images2.imgbox.com/66/f8/kPrfbrbB_o.png" width="846"></p> 
     <p> 如上图所示，当使用方法组合时，出现了线程安全问题，当线程 1 执行完 get(“key”) ，这是一个原子操作没出问题，但是在 get(“key”) == null 比较时，如果线程的时间片用完了，线程 2 获取时间片执行了 get(“key”) == null 操作，然后进行 put(“key”, “v2”) 操作，结束后，线程 1 被分配 cpu 时间片继续执行，执行 put 操作就会出现线程安全问题。</p> 
     <h5 id="%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><strong>不可变类的线程安全</strong></h5> 
     <p>String和Integer类都是不可变的类，因为其类内部状态是不可改变的，因此它们的方法都是线程安全的，有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，其实调用这些方法返回的已经是一个新创建的对象了！</p> 
     <pre><code class="language-java">public String substring(int beginIndex, int endIndex) {
        if (beginIndex &lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        if (endIndex &gt; value.length) {
            throw new StringIndexOutOfBoundsException(endIndex);
        }
        int subLen = endIndex - beginIndex;
        if (subLen &lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this
                : new String(value, beginIndex, subLen); // 新建一个对象，然后返回，没有修改等操作，是线程安全的。
    }
</code></pre> 
     <h4 id="%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90-%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><strong>示例分析-是否线程安全</strong></h4> 
     <p><br> 示例一：<br> 分析线程是否安全，先对类的成员变量，类变量，局部变量进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的的。下面对实例一进行分析：<strong>此类不是线程安全</strong>的，MyAspect切面类只有一个实例，<strong>成员变量start 会被多个线程同时进行读写操作</strong></p> 
     <pre><code class="language-java">@Aspect
@Component
public class MyAspect {
        // 是否安全？
        private long start = 0L;

        @Before("execution(* *(..))")
        public void before() {
            start = System.nanoTime();
        }

        @After("execution(* *(..))")
        public void after() {
            long end = System.nanoTime();
            System.out.println("cost time:" + (end-start));
        }
    }
</code></pre> 
     <p><strong>示例二：</strong><br> 此例是典型的三层模型调用，MyServlet UserServiceImpl UserDaoImpl类都只有一个实例，UserDaoImpl类中没有成员变量，<strong>update方法里的变量引用的对象不是线程共享的</strong>，所以是<strong>线程安全</strong>的；<strong>UserServiceImpl类中只有一个线程安全的UserDaoImpl类的实例，那么UserServiceImpl类也是线程安全</strong>的，同理 MyServlet也是线程安全的</p> 
     <pre><code class="language-java">public class MyServlet extends HttpServlet {
 // 是否安全
 private UserService userService = new UserServiceImpl();

 public void doGet(HttpServletRequest request, HttpServletResponse response) {
 userService.update(...);
 }
}
public class UserServiceImpl implements UserService {
 // 是否安全
 private UserDao userDao = new UserDaoImpl();
 public void update() {
 userDao.update();
 }
}
public class UserDaoImpl implements UserDao {
 public void update() {
 String sql = "update user set password = ? where username = ?";
 // 是否安全
 try (Connection conn = DriverManager.getConnection("","","")){
 // ...
 } catch (Exception e) {
 // ...
 }
 }
}
</code></pre> 
     <p><br><strong>示例三：</strong><br> 跟示例二大体相似，UserDaoImpl类中有成员变量，那么多个线程可以对成员变量conn 同时进行操作，故<strong>是不安全的</strong></p> 
     <pre><code class="language-java">public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全
    private UserDao userDao = new UserDaoImpl();
    public void update() {
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全
    private Connection conn = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
</code></pre> 
     <p><br><strong>示例四：</strong><br> 跟示例三大体相似，UserServiceImpl类的update方法中 UserDao是作为局部变量存在的，所以每个线程访问的时候都会新建有一个UserDao对象，新建的对象是线程独有的，所以<strong>是线程安全的</strong></p> 
     <pre><code class="language-java">public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    public void update() {
        UserDao userDao = new UserDaoImpl();
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全
    private Connection = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
</code></pre> 
     <p><strong>示例五：</strong></p> 
     <pre><code class="language-java">public abstract class Test {
    public void bar() {
        // 是否安全
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        foo(sdf);
    }
    public abstract foo(SimpleDateFormat sdf);
    public static void main(String[] args) {
        new Test().bar();
    }
}
</code></pre> 
     <p>其中<strong> foo 的行为是不确定的，可能导致不安全的发</strong>生，被称之为外星方法，因为 foo 方<strong>法可以被重写，导致线程不安全</strong>。在 String 类中就考虑到了这一点，String 类是 final 关键字声明的，子类不能重写它的方法。</p> 
     <h3 id="4%E3%80%81Monitor%20%E6%A6%82%E5%BF%B5">4、Monitor 概念</h3> 
     <h4 id="1%EF%BC%89Java%20%E5%AF%B9%E8%B1%A1%E5%A4%B4">1）Java 对象头</h4> 
     <p>以 32 位虚拟机为例,普通对象的对象头结构如下，其中的 Klass Word 为指针，指向对应的 Class 对象；<br> 普通对象</p> 
     <p><img alt="" height="124" src="https://images2.imgbox.com/8a/b9/WzH38WL6_o.png" width="764"></p> 
     <p>数组对象</p> 
     <p><img alt="" height="130" src="https://images2.imgbox.com/49/8d/JeQRKvnH_o.png" width="808"></p> 
     <p> <span style="color:#333333;">其中</span><span style="color:#333333;"> Mark Word </span><span style="color:#333333;">结构为</span></p> 
     <p><img alt="" height="311" src="https://images2.imgbox.com/64/68/UZBwtoGf_o.png" width="810"></p> 
     <p> 所以一个对象的结构如下：</p> 
     <p><img alt="" height="410" src="https://images2.imgbox.com/58/63/I2H1gq1n_o.png" width="583"></p> 
     <h4 id="%C2%A02%EF%BC%89Monitor%20%E5%8E%9F%E7%90%86"> 2）Monitor 原理</h4> 
     <p>Monitor 被翻译为监视器或者说管程<br> 每个 java 对象都可以关联一个 Monitor ，如果使用 synchronized 给对象上锁（重量级），该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</p> 
     <p><img alt="" height="468" src="https://images2.imgbox.com/cb/79/Toay479A_o.png" width="1200"></p> 
     <ul><li>刚开始时 Monitor 中的 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj){} 代码时就会将 Monitor 的所有者Owner 设置为 Thread-2，上锁成功，Monitor 中同一时刻只能有一个 Owner</li><li>当 Thread-2 占据锁时，如果线程 Thread-3 ，Thread-4 也来执行synchronized(obj){} 代码，就会进入 EntryList（阻塞队列） 中变成BLOCKED（阻塞） 状态</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</li></ul> 
     <p>注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则</p> 
     <h3 id="5%E3%80%81synchronized%20%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6">5、synchronized 原理进阶</h3> 
     <h4 id="1%EF%BC%89synchronized%20%E7%94%A8%E4%BA%8E%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86">1）synchronized 用于同步代码块与同步方法原理</h4> 
     <p><a href="https://www.cnblogs.com/aspirant/p/11470858.html" rel="nofollow" title="参考这篇文章">参考这篇文章</a></p> 
     <h4 id="2%EF%BC%89%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">2）轻量级锁</h4> 
     <p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是 synchronized ，假设有两个方法同步块，利用同一个对象加锁</p> 
     <pre><code class="language-java">static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
</code></pre> 
     <p>每次指向到 synchronized 代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的 Mark Word 和对象引用 reference</p> 
     <p><img alt="" height="418" src="https://images2.imgbox.com/fc/39/Njo9PUsr_o.png" width="744"></p> 
     <p>让锁记录中的 Object reference 指向对象，并且尝试用 cas(compare and sweep) 替换 Object 对象的 Mark Word ，将 Mark Word 的值存入锁记录中。</p> 
     <p><img alt="" height="477" src="https://images2.imgbox.com/1a/5c/2UCdnVdf_o.png" width="815"></p> 
     <p>如果 cas 替换成功，那么对象的对象头储存的就是锁记录的地址和状态 00 表示轻量级锁，如下所示</p> 
     <p><img alt="" height="456" src="https://images2.imgbox.com/1c/94/DTsre9oi_o.png" width="803"></p> 
     <p>如果cas失败，有两种情况</p> 
     <ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，那么表示有竞争，首先会进行自旋锁，自旋一定次数后，如果还是失败就进入锁膨胀阶段。</li><li>如果是自己的线程已经执行了 synchronized 进行加锁，那么再添加一条 Lock Record 作为重入的计数。<br>  </li></ul> 
     <p><img alt="" height="556" src="https://images2.imgbox.com/86/28/WnX5flXv_o.png" width="870"></p> 
     <p> 当线程退出 synchronized 代码块的时候，如果获取的是取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p> 
     <p><img alt="" height="472" src="https://images2.imgbox.com/a7/16/cXy2XGDH_o.png" width="799"></p> 
     <p>当线程退出 synchronized 代码块的时候，如果获取的锁记录取值不为 null，那么使用 cas 将 Mark Word 的值恢复给对象</p> 
     <ol><li>成功则解锁成功</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ol> 
     <h4 id="3%EF%BC%89%E9%94%81%E8%86%A8%E8%83%80">3）锁膨胀</h4> 
     <p>如果在尝试加轻量级锁的过程中，cas 操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p> 
     <p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p> 
     <p><img alt="" height="414" src="https://images2.imgbox.com/5d/2f/Q8p69MuI_o.png" width="1191"></p> 
     <p></p> 
     <p> 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程，</p> 
     <ul><li>即为对象申请Monitor锁，让Object指向重量级锁地址</li><li>然后自己进入Monitor 的EntryList 变成BLOCKED状态</li></ul> 
     <p><img alt="" height="419" src="https://images2.imgbox.com/8c/30/4dWNb05x_o.png" width="1179"></p> 
     <p> 当 Thread-0 退出 synchronized 同步块时，使用 cas 将 Mark Word 的值恢复给对象头，对象的对象头指向 Monitor，那么会进入重量级锁的解锁过程，即按照 Monitor 的地址找到 Monitor 对象，将 Owner 设置为 null ，唤醒 EntryList 中的 Thread-1 线程</p> 
     <h4 id="4%EF%BC%89%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><br> 4）自旋优化</h4> 
     <p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁</p> 
     <p>自旋重试成功的情况</p> 
     <p><img alt="" height="625" src="https://images2.imgbox.com/3f/ca/jGFiOzGg_o.png" width="1169"></p> 
     <p> 自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁</p> 
     <p><img alt="" height="562" src="https://images2.imgbox.com/93/32/2gfo0OYG_o.png" width="1182"></p> 
     <p> 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</p> 
     <h4 id="5%EF%BC%89%E5%81%8F%E5%90%91%E9%94%81"><br> 5）偏向锁</h4> 
     <p>在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行 CAS 操作，这是有点耗时滴，那么 java6 开始引入了偏向锁的东东，只有第一次使用 CAS 时将对象的 Mark Word 头设置为偏向线程 ID，之后这个入锁线程再进行重入锁时，发现线程 ID 是自己的，那么就不用再进行CAS了。</p> 
     <p><strong>分析代码，比较轻量级锁与偏向锁</strong></p> 
     <pre><code class="language-java">static final Object obj = new Object();
public static void m1() {
	synchronized(obj) {
		// 同步块 A
		m2();
	}
}
public static void m2() {
	synchronized(obj) {
		// 同步块 B
		m3();
	}
}
public static void m3() {
	synchronized(obj) {
		// 同步块 C
	}
}
</code></pre> 
     <p>分析如图：</p> 
     <p><img alt="" height="773" src="https://images2.imgbox.com/57/b4/K4oqPhnM_o.png" width="788"></p> 
     <p><strong>偏向状态</strong></p> 
     <p>对象头格式如下： </p> 
     <p><img alt="" height="459" src="https://images2.imgbox.com/4b/19/bigEUISs_o.png" width="1186"></p> 
     <p>一个对象的创建过程</p> 
     <ul><li>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的 Thread，epoch，age 都是 0 ，在加锁的时候进行设置这些的值.</li><li>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-XX:BiasedLockingStartupDelay=0 来禁用延迟</li><li>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</li></ul> 
     <p></p> 
     <h5 id="%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91">撤销偏向</h5> 
     <p>以下几种情况会使对象的偏向锁失效</p> 
     <ul><li>调用对象的 hashCode 方法</li><li>多个线程使用该对象</li><li>调用了 wait/notify 方法（调用wait方法会导致锁膨胀而使用重量级锁）</li></ul> 
     <h4 id="6%EF%BC%89%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91">6）批量重偏向</h4> 
     <ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向 t1 的对象仍有机会重新偏向 t2 
       <ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过<span style="color:#fe2c24;">20</span>次后（超过阈值），JVM 会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul> 
     <h4 id="7%EF%BC%89%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80">7）批量撤销</h4> 
     <p>当撤销偏向锁的阈值超过<span style="color:#fe2c24;"> 40</span> 以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p> 
     <h3 id="6%E3%80%81Wait%2FNotify">6、Wait/Notify</h3> 
     <h4 id="1%EF%BC%89%E5%8E%9F%E7%90%86">1）原理</h4> 
     <p><img alt="" height="474" src="https://images2.imgbox.com/7f/8c/15XoI7sG_o.png" width="1200"></p> 
     <ul><li> 锁对象调用wait方法（obj.wait），就会使当前线程进入 WaitSet 中，变为 WAITING 状态。</li><li>处于BLOCKED和 WAITING 状态的线程都为阻塞状态，CPU 都不会分给他们时间片。但是有所区别：</li></ul> 
     <ol><li>BLOCKED 状态的线程是在竞争对象时，发现 Monitor 的 Owner 已经是别的线程了，此时就会进入 EntryList 中，并处于 BLOCKED 状态</li><li>WAITING 状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了 wait 方法而进入了 WaitSet 中，处于 WAITING 状态</li></ol> 
     <ul><li>BLOCKED 状态的线程会在锁被释放的时候被唤醒，但是处于 WAITING 状态的线程只有被锁对象调用了 notify 方法(obj.notify/obj.notifyAll)，才会被唤醒。</li></ul> 
     <p>注：只有当对象加锁以后，才能调用 wait 和 notify 方法</p> 
     <h4 id="2%EF%BC%89Wait%20%E4%B8%8E%20Sleep%20%E7%9A%84%E5%8C%BA%E5%88%AB">2）Wait 与 Sleep 的区别</h4> 
     <ul><li>Sleep 是 Thread 类的静态方法，Wait 是 Object 的方法，Object 又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep 在阻塞的时候不会释放锁，而 Wait 在阻塞的时候会释放锁，它们都会释放 CPU 资源。</li><li>Sleep 不需要与 synchronized 一起使用，而 Wait 需要与 synchronized 一起使用（对象被锁以后才能使用）</li><li>使用 wait 一般需要搭配 notify 或者 notifyAll 来使用，不然会让线程一直等待。<br>  </li></ul> 
     <h4 id="3%EF%BC%89%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20wait%2Fnotify">3）优雅地使用 wait/notify</h4> 
     <p><strong>什么时候适合使用wait</strong></p> 
     <ul><li>当线程不满足某些条件，需要暂停运行时，可以使用 wait 。这样会将对象的锁释放，让其他线程能够继续运行。如果此时使用 sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程 sleep 结束后，运行完毕，才能得到执行。</li></ul> 
     <p><strong>使用wait/notify需要注意什么</strong></p> 
     <ul><li>当有多个线程在运行时，对象调用了 wait 方法，此时这些线程都会进入 WaitSet 中等待。如果这时使用了 notify 方法，可能会造成虚假唤醒（唤醒的不是满足条件的等待线程），这时就需要使用 notifyAll 方法</li></ul> 
     <pre><code class="language-java">synchronized (lock) {
	while(//不满足条件，一直等待，避免虚假唤醒) {
		lock.wait();
	}
	//满足条件后再运行
}

synchronized (lock) {
	//唤醒所有等待线程
	lock.notifyAll();
}
</code></pre> 
     <h4 id="4%EF%BC%89%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C">4）同步模式之保护性暂停</h4> 
     <p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果，要点：</p> 
     <ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul> 
     <p>多任务版 GuardedObject 图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。和生产者消费者模式的区别就是：这个生产者和消费者之间是一一对应的关系，但是生产者消费者模式并不是。rpc 框架的调用中就使用到了这种模式。<br><img alt="" height="483" src="https://images2.imgbox.com/49/74/3YHc1U0H_o.png" width="1200"></p> 
     <p>代码如下：</p> 
     <pre><code class="language-java">/**
 * 同步模式-保护性暂停 (Guarded-Suspension-pattern)
 */
@Slf4j(topic = "c.Code_23_Test")
public class Code_23_Test {

    public static void main(String[] args) {

        for (int i = 0; i &lt; 3; i++) {
            new People().start();
        }

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for(Integer id : Mailboxes.getIds()) {
            new Postman(id, "内容 " + id).start();
        }
    }

}

@Slf4j(topic = "c.People")
class People extends Thread {

    @Override
    public void run() {
        GuardedObject guardedObject = Mailboxes.createGuardedObject();
        log.info("收信的为 id: {}", guardedObject.getId());
        Object o = guardedObject.get(5000);
        log.info("收到信的 id: {}, 内容: {}", guardedObject.getId(), o);
    }
}

@Slf4j(topic = "c.Postman")
class Postman extends Thread {

    private int id;
    private String mail;

    public Postman(int id, String mail) {
        this.id = id;
        this.mail = mail;
    }

    @Override
    public void run() {
        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
        log.info("送信的 id: {}, 内容: {}", id, mail);
        guardedObject.complete(mail);
    }
}

class Mailboxes {

    private static int id = 1;
    private static Map&lt;Integer, GuardedObject&gt; boxes = new Hashtable&lt;&gt;();

    public static synchronized int generateId() {
        return id++;
    }

    // 用户会进行投信
    public static GuardedObject createGuardedObject() {
        GuardedObject guardedObject = new GuardedObject(generateId());
        boxes.put(guardedObject.getId(), guardedObject);
        return guardedObject;
    }

    // 派件员会派发信
    public static GuardedObject getGuardedObject(int id) {
        return boxes.remove(id);
    }

    public static Set&lt;Integer&gt; getIds() {
        return boxes.keySet();
    }
}

class GuardedObject {

    private int id;

    public GuardedObject(int id) {
        this.id = id;
    }

    public int getId() {
        return this.id;
    }

    private Object response;

    // 优化等待时间
    public Object get(long timeout) {
        synchronized (this) {
            long begin = System.currentTimeMillis();
            long passTime = 0;
            while (response == null) {
                long waitTime = timeout - passTime; // 剩余等待时间
                if(waitTime &lt;= 0) {
                    break;
                }
                try {
                    this.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                passTime = System.currentTimeMillis() - begin;
            }
            return response;
        }
    }

    public void complete(Object response) {
        synchronized (this) {
            this.response = response;
            this.notify();
        }
    }

}

</code></pre> 
     <h4 id="%C2%A05%EF%BC%89%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%2F%E6%B6%88%E8%B4%B9%E8%80%85"> 5）异步模式之生产者/消费者</h4> 
     <p>要点</p> 
     <ul><li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul> 
     <p>“异步”的意思就是生产者产生消息之后消息没有被立刻消费，而“同步模式”中，消息在产生之后被立刻消费了。</p> 
     <p><img alt="" height="265" src="https://images2.imgbox.com/3a/1d/KU5wzhOk_o.png" width="1200"></p> 
     <p></p> 
     <ol><li>当调用 wait 时，首先需要确保调用了 wait 方法的线程已经持有了对象的锁(调用 wait 方法的代码片段需要放在 sychronized 块或者时 sychronized 方法中，这样才可以确保线程在调用wait方法前已经获取到了对象的锁)</li><li>当调用 wait 时，该线程就会释放掉这个对象的锁，然后进入等待状态 (wait set)</li><li>当线程调用了 wait 后进入到等待状态时，它就可以等待其他线程调用相同对象的 notify 或者 notifyAll 方法使得自己被唤醒</li><li>一旦这个线程被其它线程唤醒之后，该线程就会与其它线程以同开始竞争这个对象的锁(公平竞争)；只有当该线程获取到对象的锁后，线程才会继续往下执行</li><li>当调用对象的 notify 方法时，他会随机唤醒对象等待集合 (wait set) 中的任意一个线程，当某个线程被唤醒后，它就会与其它线程一同竞争对象的锁</li><li>当调用对象的 notifyAll 方法时，它会唤醒该对象等待集合 (wait set) 中的所有线程，这些线程被唤醒后，又会开始竞争对象的锁</li><li>在某一时刻，只有唯一的一个线程能拥有对象的锁</li></ol> 
     <h3 id="7%E3%80%81park%20%26%20unpark">7、park &amp; unpark</h3> 
     <h4 id="1%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">1）基本使用</h4> 
     <p>park &amp; unpark 是 LockSupport 线程通信工具类的静态方法。</p> 
     <pre><code class="language-java">// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark;
</code></pre> 
     <h4 id="2%EF%BC%89park%20unpark%20%E5%8E%9F%E7%90%86">2）park unpark 原理</h4> 
     <p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter， _cond 和 _mutex</p> 
     <p>2）park unpark 原理<br> 每个线程都有自己的一个 Parker 对象，由三部分组成 _counter， _cond 和 _mutex</p> 
     <p><strong>先调用park再调用upark的过程</strong></p> 
     <p>先调用 park</p> 
     <ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁(mutex对象有个等待队列 _cond)</li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter = 0</li></ol> 
     <p><img alt="" height="619" src="https://images2.imgbox.com/63/d3/vH8G3YPY_o.png" width="1122"></p> 
     <p> 调用 upark</p> 
     <ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ol> 
     <p><img alt="" height="622" src="https://images2.imgbox.com/77/90/3OyJhxeq_o.png" width="1118"></p> 
     <p><strong>先调用upark再调用park的过程</strong></p> 
     <ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol> 
     <p><img alt="" height="611" src="https://images2.imgbox.com/6b/6b/GBOoTGdB_o.png" width="1141"></p> 
     <h3 id="%C2%A08%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"> 8、线程状态转换</h3> 
     <p><img alt="" height="602" src="https://images2.imgbox.com/97/91/gLDAwGka_o.png" width="842"></p> 
     <p>情况一：NEW –&gt; RUNNABLE</p> 
     <ul><li>当调用了 t.start() 方法时，由 NEW –&gt; RUNNABLE</li></ul> 
     <p>情况二： RUNNABLE &lt;–&gt; WAITING</p> 
     <ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后，调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时，会在 WaitSet 等待队列中出现锁竞争，非公平竞争</li></ul> 
     <ol><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li></ol> 
     <p>情况三：RUNNABLE &lt;–&gt; WAITING</p> 
     <ul><li>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</li><li>注意是当前线程在 t 线程对象的监视器上等待</li><li>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li></ul> 
     <p>情况四： RUNNABLE &lt;–&gt; WAITING</p> 
     <ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul> 
     <p>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</p> 
     <ul><li>t 线程用 synchronized(obj) 获取了对象锁后</li><li>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</li></ul> 
     <ol><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li></ol> 
     <p>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</p> 
     <ul><li>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING,注意是当前线程在 t 线程对象的监视器上等待</li><li>当前线程等待时间超过了 n 毫秒，或 t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul> 
     <p>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</p> 
     <ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul> 
     <p>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</p> 
     <ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul> 
     <p>情况九：RUNNABLE &lt;–&gt; BLOCKED</p> 
     <ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul> 
     <p>情况十： RUNNABLE &lt;–&gt; TERMINATED</p> 
     <ul><li>当前线程所有代码运行完毕，进入 TERMINATED</li></ul> 
     <h3 id="9%E3%80%81%E6%B4%BB%E8%B7%83%E6%80%A7">9、活跃性</h3> 
     <h4 id="1%EF%BC%89%E5%AE%9A%E4%B9%89">1）定义</h4> 
     <p>线程因为某些原因，导致代码一直无法执行完毕，这种的现象叫做活跃性。</p> 
     <h4 id="2%EF%BC%89%E6%AD%BB%E9%94%81">2）死锁</h4> 
     <p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br> 如：t1 线程获得 A 对象锁，接下来想获取 B 对象的锁 t2 线程获得 B 对象锁，接下来想获取 A 对象的锁。</p> 
     <pre><code class="language-java">public static void main(String[] args) {
		final Object A = new Object();
		final Object B = new Object();
		new Thread(()-&gt;{
			synchronized (A) {
				try {
					Thread.sleep(2000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				synchronized (B) {

				}
			}
		}).start();

		new Thread(()-&gt;{
			synchronized (B) {
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				synchronized (A) {

				}
			}
		}).start();
	}
</code></pre> 
     <p><strong>发生死锁的必要条件</strong></p> 
     <p>互斥条件</p> 
     <ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul> 
     <p>请求和保持条件</p> 
     <ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul> 
     <p>不可抢占条件</p> 
     <ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul> 
     <p>循环等待条件</p> 
     <ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul> 
     <p><strong>定位死锁的方法</strong><br> 检测死锁可以使用 jconsole工具；或者使用 jps 定位进程 id，再用 jstack 根据进程 id 定位死锁。<br><strong>哲学家就餐问题</strong><br> 有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 。<br> 当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况。<br><strong>避免死锁的方法</strong><br> 在线程使用锁对象时，顺序加锁即可避免死锁</p> 
     <p><img alt="" height="459" src="https://images2.imgbox.com/ea/90/Zbk7JaO7_o.png" width="872"></p> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<h4 id="3%EF%BC%89%E6%B4%BB%E9%94%81">3）活锁</h4> 
<p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，谁也无法结束。</p> 
<p><strong>避免活锁的方法</strong><br> 在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p> 
<p><strong>死锁与活锁的区别</strong></p> 
<ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞，停止运行的现</strong>象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行，却一直运行不完</strong>的现象。</li></ul> 
<h4 id="4%EF%BC%89%E9%A5%A5%E9%A5%BF">4）饥饿</h4> 
<p>某些线程因为优先级太低，导致一直无法获得资源的现象。<br> 在使用顺序加锁时，可能会出现饥饿现象</p> 
<h3 id="10%E3%80%81ReentrantLock">10、ReentrantLock</h3> 
<p>和 synchronized 相比具有的的特点</p> 
<ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有多个 WaitSet)</li></ul> 
<pre><code class="language-java">// 获取ReentrantLock对象
private ReentrantLock lock = new ReentrantLock();
// 加锁
lock.lock();
try {
	// 需要执行的代码
}finally {
	// 释放锁
	lock.unlock();
}
</code></pre> 
<h4 id="%C2%A01%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5"><strong> 1）可重入</strong></h4> 
<ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul> 
<h4 id="2%EF%BC%89%E5%8F%AF%E6%89%93%E6%96%AD">2）可打断</h4> 
<p>如果某个线程处于阻塞状态，可以调用其 interrupt 方法让其停止阻塞，获得锁失败<br> 简而言之就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p> 
<pre><code class="language-java">public static void main(String[] args) {
		ReentrantLock lock = new ReentrantLock();
		Thread t1 = new Thread(() -&gt; {
			try {
				// 加锁，可打断锁
				lock.lockInterruptibly();
			} catch (InterruptedException e) {
				e.printStackTrace();
                // 被打断，返回，不再向下执行
				return;
			}finally {
				// 释放锁
				lock.unlock();
			}

		});

		lock.lock();
		try {
			t1.start();
			Thread.sleep(1000);
			// 打断
			t1.interrupt();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
</code></pre> 
<h4 id="3%EF%BC%89%E9%94%81%E8%B6%85%E6%97%B6">3）锁超时</h4> 
<p>使用 lock.tryLock 方法会返回获取锁是否成功。如果成功则返回 true ，反之则返回 false 。<br> 并且 tryLock 方法可以指定等待时间，参数为：tryLock(long timeout, TimeUnit unit), 其中 timeout 为最长等待时间，TimeUnit 为时间单位<br> 简而言之就是：获取锁失败了、获取超时了或者被打断了，不再阻塞，直接停止运行。<br><strong>不设置等待时间</strong></p> 
<pre><code class="language-java">public static void main(String[] args) {
		ReentrantLock lock = new ReentrantLock();
		Thread t1 = new Thread(() -&gt; {
            // 未设置等待时间，一旦获取失败，直接返回false
			if(!lock.tryLock()) {
				System.out.println("获取失败");
                // 获取失败，不再向下执行，返回
				return;
			}
			System.out.println("得到了锁");
			lock.unlock();
		});


		lock.lock();
		try{
			t1.start();
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
</code></pre> 
<p><strong>设置等待时间</strong></p> 
<pre><code class="language-java">public static void main(String[] args) {
		ReentrantLock lock = new ReentrantLock();
		Thread t1 = new Thread(() -&gt; {
			try {
				// 判断获取锁是否成功，最多等待1秒
				if(!lock.tryLock(1, TimeUnit.SECONDS)) {
					System.out.println("获取失败");
					// 获取失败，不再向下执行，直接返回
					return;
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
				// 被打断，不再向下执行，直接返回
				return;
			}
			System.out.println("得到了锁");
			// 释放锁
			lock.unlock();
		});


		lock.lock();
		try{
			t1.start();
			// 打断等待
			t1.interrupt();
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
</code></pre> 
<h4 id="4%EF%BC%89%E5%85%AC%E5%B9%B3%E9%94%81">4）公平锁</h4> 
<p>在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。</p> 
<pre><code class="language-java">// 默认是不公平锁，需要在创建时指定为公平锁
ReentrantLock lock = new ReentrantLock(true);
</code></pre> 
<h4 id="5%EF%BC%89%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F">5）条件变量</h4> 
<p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待。ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p> 
<ul><li>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待。</li><li>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</li></ul> 
<p>使用要点：</p> 
<ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul> 
<h3 id="11%E3%80%81%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6">11、同步模式之顺序控制</h3> 
<p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现。</p> 
<h4 id="1%EF%BC%89Wait%2FNotify%20%E5%AE%9E%E7%8E%B0">1）Wait/Notify 实现</h4> 
<pre><code class="language-java">public class Code_32_Test {

    public static void main(String[] args) {
        WaitAndNotify waitAndNotify = new WaitAndNotify(1, 5);

        new Thread(()-&gt;{
            waitAndNotify.run("a", 1, 2);
        }).start();
        new Thread(()-&gt;{
            waitAndNotify.run("b", 2, 3);
        }).start();
        new Thread(()-&gt;{
            waitAndNotify.run("c", 3, 1);
        }).start();
    }
}

class WaitAndNotify {
    public void run(String str, int flag, int nextFlag) {
        for(int i = 0; i &lt; loopNumber; i++) {
            synchronized(this) {
                while (flag != this.flag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                // 设置下一个运行的线程标记
                this.flag = nextFlag;
                // 唤醒所有线程
                this.notifyAll();
            }
        }
    }

    private int flag;
    private int loopNumber;

    public WaitAndNotify(int flag, int loopNumber) {
        this.flag = flag;
        this.loopNumber = loopNumber;
    }
}
</code></pre> 
<h4 id="2%EF%BC%89park%2Funpark%C2%A0%E5%AE%9E%E7%8E%B0">2）park/unpark 实现</h4> 
<pre><code class="language-java">public class Code_33_Test {

    public static Thread t1, t2, t3;
    public static void main(String[] args) {
        ParkAndUnPark obj = new ParkAndUnPark(5);
        t1 = new Thread(() -&gt; {
            obj.run("a", t2);
        });

        t2 = new Thread(() -&gt; {
            obj.run("b", t3);
        });

        t3 = new Thread(() -&gt; {
            obj.run("c", t1);
        });
        t1.start();
        t2.start();
        t3.start();

        LockSupport.unpark(t1);
    }
}

class ParkAndUnPark {
    public void run(String str, Thread nextThread) {
        for(int i = 0; i &lt; loopNumber; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(nextThread);
        }
    }

    private int loopNumber;

    public ParkAndUnPark(int loopNumber) {
        this.loopNumber = loopNumber;
    }
}
</code></pre> 
<h4 id="3%EF%BC%89await%2Fsignal%20%E5%AE%9E%E7%8E%B0">3）await/signal 实现</h4> 
<pre><code class="language-java">public class Code_34_Test {

    public static void main(String[] args) {
        AwaitAndSignal lock = new AwaitAndSignal(5);
        Condition a = lock.newCondition();
        Condition b = lock.newCondition();
        Condition c = lock.newCondition();
        new Thread(() -&gt; {
            lock.run("a", a, b);
        }).start();

        new Thread(() -&gt; {
            lock.run("b", b, c);
        }).start();

        new Thread(() -&gt; {
            lock.run("c", c, a);
        }).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        lock.lock();
        try {
            a.signal();
        }finally {
            lock.unlock();
        }
    }
}

class AwaitAndSignal extends ReentrantLock {
    public void run(String str, Condition current, Condition nextCondition) {
        for(int i = 0; i &lt; loopNumber; i++) {
            lock();
            try {
                current.await();
                System.out.print(str);
                nextCondition.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                unlock();
            }
        }
    }

    private int loopNumber;

    public AwaitAndSignal(int loopNumber) {
        this.loopNumber = loopNumber;
    }
}
</code></pre> 
<h3>结论</h3> 
<p>本章我们需要重点掌握的是</p> 
<ul><li>分析多线程访问共享资源时，哪些代码片段属于临界区</li><li>使用 synchronized 互斥解决临界区的线程安全问题</li></ul> 
<ol><li>掌握 synchronized 锁对象语法</li><li>掌握 synchronzied 加载成员方法和静态方法语法</li><li>掌握 wait/notify 同步方法</li></ol> 
<ul><li>使用 lock 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li><li>学会分析变量的线程安全性、掌握常见线程安全类的使用</li><li>了解线程活跃性问题：死锁、活锁、饥饿</li><li>应用方面</li></ul> 
<ol><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果，实现原子性效果，保证线程安全。</li><li>同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果。</li></ol> 
<ul><li>原理方面</li></ul> 
<ol><li>monitor、synchronized 、wait/notify 原理</li><li>synchronized 进阶原理</li><li>park &amp; unpark 原理</li></ol> 
<ul><li>模式方面</li></ul> 
<ol><li>同步模式之保护性暂停</li><li>异步模式之生产者消费者</li><li>同步模式之顺序控制</li></ol> 
<h2 id="%E5%9B%9B%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98">四、共享模型之内存</h2> 
<h3 id="1%E3%80%81Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89">1、Java 内存模型（JMM）</h3> 
<p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。<br> JMM 体现在以下几个方面</p> 
<ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul> 
<h3 id="2%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7">2、可见性</h3> 
<h4 id="1%EF%BC%89%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF">1）退不出的循环</h4> 
<p>首先看一段代码：</p> 
<pre><code class="language-java">public static boolean run = true;

    public static void main(String[] args) {

        Thread t1 = new Thread(() -&gt; {
            while(run) {

            }
        }, "t1");

        t1.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info("t1 Stop");
        run = false;
    }
</code></pre> 
<p></p> 
<p>首先 t1 线程运行，然后过一秒，主线程设置 run 的值为 false，想让 t1 线程停止下来，但是 t1 线程并没有停，分析如下图：</p> 
<p><img alt="" height="631" src="https://images2.imgbox.com/3a/9a/VrY5xfpL_o.png" width="591"></p> 
<p> <strong>解决方法</strong></p> 
<ul><li>使用 volatile （易变关键字）</li><li>它可以用来修饰成员变量和静态成员变量（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</li></ul> 
<pre><code class="language-java"> public static volatile boolean run = true; // 保证内存的可见性</code></pre> 
<h4 id="2%EF%BC%89%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%80%A7">2）可见性与原子性</h4> 
<p>上面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对<a href="https://so.csdn.net/so/search?q=volatile&amp;spm=1001.2101.3001.7020" title="volatile">volatile</a> 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况。</p> 
<ul><li>注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低。</li><li>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</li><li>因为 printIn() 方法使用了 synchronized 同步代码块，可以保证原子性与可见性，它是 PrintStream 类的方法。</li></ul> 
<h4 id="3%EF%BC%89%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2">3）模式之两阶段终止</h4> 
<p>使用 volatile 关键字来实现两阶段终止模式。</p> 
<pre><code class="language-java">public class Code_02_Test {
	public static void main(String[] args) throws InterruptedException {
		Monitor monitor = new Monitor();
		monitor.start();
		Thread.sleep(3500);
		monitor.stop();
	}
}

class Monitor {

	Thread monitor;
	// 设置标记，用于判断是否被终止了
	private volatile boolean stop = false;
	/**
	 * 启动监控器线程
	 */
	public void start() {
		// 设置线控器线程，用于监控线程状态
		monitor = new Thread() {
			@Override
			public void run() {
				// 开始不停的监控
				while (true) {
					if(stop) {
						System.out.println("处理后续任务");
						break;
					}
					System.out.println("监控器运行中...");
					try {
						// 线程休眠
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						System.out.println("被打断了");
					}
				}
			}
		};
		monitor.start();
	}

	/**
	 * 	用于停止监控器线程
	 */
	public void stop() {
		// 修改标记
		stop = true;
		// 打断线程
		monitor.interrupt();        
	}
}
</code></pre> 
<h4 id="4%EF%BC%89%E6%A8%A1%E5%BC%8F%E4%B9%8B%20Balking">4）模式之 Balking</h4> 
<p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回，有点类似单例。</p> 
<ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题</li><li>加锁的代码块要尽量的小，以保证性能</li></ul> 
<pre><code class="language-java">public class Code_03_Test {
	public static void main(String[] args) throws InterruptedException {
		Monitor monitor = new Monitor();
		monitor.start();
		monitor.start();
		Thread.sleep(3500);
		monitor.stop();
	}
}

class Monitor {

	Thread monitor;
	// 设置标记，用于判断是否被终止了
	private volatile boolean stop = false;
	// 设置标记，用于判断是否已经启动过了
	private boolean starting = false;
	/**
	 * 启动监控器线程
	 */
	public void start() {
		// 上锁，避免多线程运行时出现线程安全问题
		synchronized (this) {
			if (starting) {
				// 已被启动，直接返回
				return;
			}
			// 启动监视器，改变标记
			starting = true;
		}
		// 设置线控器线程，用于监控线程状态
		monitor = new Thread() {
			@Override
			public void run() {
				// 开始不停的监控
				while (true) {
					if(stop) {
						System.out.println("处理后续任务");
						break;
					}
					System.out.println("监控器运行中...");
					try {
						// 线程休眠
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						System.out.println("被打断了");
					}
				}
			}
		};
		monitor.start();
	}

	/**
	 * 	用于停止监控器线程
	 */
	public void stop() {
		// 打断线程
		monitor.interrupt();
		stop = true;
	}
}
</code></pre> 
<h3 id="3%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7">3、有序性</h3> 
<h4 id="1%EF%BC%89%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92">1）指令重排</h4> 
<p>首先看一个例子：</p> 
<pre><code class="language-java">// 可以重排的例子 
int a = 10; 
int b = 20; 
System.out.println( a + b );

// 不能重排的例子 
int a = 10;
int b = a - 5;
</code></pre> 
<p>指令重排简单来说可以，在程序结果不受影响的前提下，可以调整指令语句执行顺序。多线程下指令重排会影响正确性。</p> 
<h4 id="2%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E9%97%AE%E9%A2%98">2）多线程下指令重排问题</h4> 
<p>首先看一段代码：</p> 
<pre><code class="language-java">int num = 0;

// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序
boolean ready = false; 
// 线程1 执行此方法
public void actor1(I_Result r) {
 if(ready) {
 	r.r1 = num + num;
 } 
 else {
 	r.r1 = 1;
 }
}
// 线程2 执行此方法
public void actor2(I_Result r) {
 num = 2;
 ready = true;
}
</code></pre> 
<p>在多线程环境下，以上的代码 r1 的值有三种情况：<br> 第一种：线程 2 先执行，然后线程 1 后执行，r1 的结果为 4<br> 第二种：线程 1 先执行，然后线程 2 后执行，r1 的结果为 1<br> 第三种：线程 2 先执行，但是发送了指令重排，num = 2 与 ready = true 这两行代码语序发生装换，<br>  </p> 
<pre><code class="language-java">ready = true; // 前
num = 2; // 后
</code></pre> 
<p>然后执行 ready = true 后，线程 1 运行了，那么 r1 的结果是为 0。</p> 
<h4 id="3%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">3）解决方法</h4> 
<p>volatile 修饰的变量，可以禁用指令重排，禁止的是加 volatile 关键字变量<strong>之前的代码</strong>重排序</p> 
<h3 id="4%E3%80%81volatile%20%E5%8E%9F%E7%90%86">4、volatile 原理</h3> 
<p>volatile 的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）<br> 对 volatile 变量的写指令<strong>后会加入写屏障</strong><br> 对 volatile 变量的读指令<strong>前会加入读屏障</strong></p> 
<h4 id="1%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7">1）如何保证可见性</h4> 
<ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li></ul> 
<pre><code class="language-java">public void actor2(I_Result r) {
     num = 2;
     ready = true; // ready 是被 volatile 修饰的，赋值带写屏障
     // 写屏障
}

</code></pre> 
<ul><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul> 
<pre><code class="language-java">public void actor1(I_Result r) {
 // 读屏障
 // ready是被 volatile 修饰的，读取值带读屏障
 if(ready) {
 	r.r1 = num + num;
 } else {
 	r.r1 = 1;
 }
}
</code></pre> 
<p><img alt="" height="650" src="https://images2.imgbox.com/dd/15/s5xRM1LS_o.png" width="1200"></p> 
<h4 id="2%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7">2）如何保证有序性</h4> 
<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li></ul> 
<pre><code class="language-java">public void actor2(I_Result r) {
 num = 2;
 ready = true; // ready 是被 volatile 修饰的，赋值带写屏障
 // 写屏障
}
</code></pre> 
<ul><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul> 
<pre><code class="language-java">public void actor1(I_Result r) {
 // 读屏障
 // ready 是被 volatile 修饰的，读取值带读屏障
 if(ready) {
 	r.r1 = num + num;
 } else {
 	r.r1 = 1;
 }
}
</code></pre> 
<p>注意：volatile 不能解决指令交错<br> 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读跑到它前面去。<br> 而有序性的保证也只是保证了本线程内相关代码不被重排序</p> 
<h4 id="3%EF%BC%89double-checked%20locking%20%E9%97%AE%E9%A2%98">3）double-checked locking 问题</h4> 
<p>看如下代码：</p> 
<pre><code class="language-java">	// 最开始的单例模式是这样的
    public final class Singleton {
        private Singleton() { }
        private static Singleton INSTANCE = null;
        public static Singleton getInstance() {
        // 首次访问会同步，而之后的使用不用进入synchronized
        synchronized(Singleton.class) {
        	if (INSTANCE == null) { // t1
        		INSTANCE = new Singleton();
            }
        }
            return INSTANCE;
        }
    }
// 但是上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响性能！因此就有了模式如下double-checked lockin：
    public final class Singleton {
        private Singleton() { }
        private static Singleton INSTANCE = null;
        public static Singleton getInstance() {
            if(INSTANCE == null) { // t2
                // 首次访问会同步，而之后的使用没有 synchronized
                synchronized(Singleton.class) {
                    if (INSTANCE == null) { // t1
                        INSTANCE = new Singleton();
                    }
                }
            }
            return INSTANCE;
        }
    }
//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性，可见性。所以
</code></pre> 
<p>以上的实现特点是：</p> 
<ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外<br> 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</li></ul> 
<pre><code class="language-TypeScript">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull 37
// ldc是获得类对象
6: ldc #3 // class cn/itcast/n5/Singleton
// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份
8: dup
// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中
// 将类对象的引用地址存储了一份，是为了将来解锁用
9: astore_0
10: monitorenter
11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull 27
// 新建一个实例
17: new #3 // class cn/itcast/n5/Singleton
// 复制了一个实例的引用
20: dup
// 通过这个复制的引用调用它的构造方法
21: invokespecial #4 // Method "&lt;init&gt;":()V
// 最开始的这个引用用来进行赋值操作
24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn
</code></pre> 
<p>其中</p> 
<ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 复制了引用地址</li><li>21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul> 
<p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/44/26/7PPHGe0k_o.png" width="816"></p> 
<p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例 对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效。</p> 
<h4 id="4%EF%BC%89double-checked%20locking%20%E8%A7%A3%E5%86%B3">4）double-checked locking 解决</h4> 
<p>加volatile就行了。</p> 
<pre><code class="language-java">public final class Singleton {
        private Singleton() { }
        private static volatile Singleton INSTANCE = null;
        public static Singleton getInstance() {
            // 实例没创建，才会进入内部的 synchronized代码块
            if (INSTANCE == null) {
                synchronized (Singleton.class) { // t2
                    // 也许有其它线程已经创建实例，所以再判断一次
                    if (INSTANCE == null) { // t1
                        INSTANCE = new Singleton();
                    }
                }
            }
            return INSTANCE;
        }
    }
</code></pre> 
<p>如上面的注释内容所示，读写 volatile 变量操作（即 getstatic 操作和 putstatic 操作）时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p> 
<ul><li>可见性</li></ul> 
<ol><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ol> 
<ul><li>有序性</li></ul> 
<ol><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li></ol> 
<h3 id="5%E3%80%81happens-before">5、happens-before</h3> 
<div> 
 <span style="color:#333333;">happens-before </span> 
 <span style="color:#333333;">规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛 开以下 happens-before </span> 
 <span style="color:#333333;">规则，</span> 
 <span style="color:#333333;">JMM </span> 
 <span style="color:#333333;">并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 </span> 
</div> 
<div></div> 
<div>
  下面说的变量都是指成员变量或静态成员变量 
</div> 
<div>
  1）线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见 
</div> 
<div> 
 <pre><code class="language-java">	 static int x;
	 static Object m = new Object();
	 new Thread(()-&gt;{
	     synchronized(m) {
	         x = 10;
	     }
	 },"t1").start();
	 new Thread(()-&gt;{
	     synchronized(m) {
	         System.out.println(x);
	     }
	 },"t2").start();
         
</code></pre> 
 <p>2）线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p> 
 <pre><code class="language-java">volatile static int x;
new Thread(()-&gt;{
 x = 10;
},"t1").start();
new Thread(()-&gt;{
 System.out.println(x);
},"t2").start();
</code></pre> 
 <p>3）线程 start 前对变量的写，对该线程开始后对该变量的读可见</p> 
 <pre><code class="language-java">static int x;
x = 10;
new Thread(()-&gt;{
 System.out.println(x);
},"t2").start();
</code></pre> 
 <p>4）线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p> 
 <pre><code class="language-java">static int x;
Thread t1 = new Thread(()-&gt;{
 x = 10;
},"t1");
t1.start();
t1.join();
System.out.println(x);
</code></pre> 
 <p>5）线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</p> 
 <pre><code class="language-java">	static int x;
    public static void main(String[] args) {
        Thread t2 = new Thread(()-&gt;{
            while(true) {
                if(Thread.currentThread().isInterrupted()) {
                    System.out.println(x);
                    break;
                }
            }
        },"t2");
        t2.start();
        new Thread(()-&gt;{
            sleep(1);
            x = 10;
            t2.interrupt();
        },"t1").start();
        while(!t2.isInterrupted()) {
            Thread.yield();
        }
        System.out.println(x);
    }
</code></pre> 
 <p>6）对变量默认值（0，false，null）的写，对其它线程对该变量的读可见<br> 7）具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p> 
 <pre><code class="language-java">	volatile static int x; ​ 
	static int y; ​ 
	new Thread(() -&gt; { ​ 
		y = 10; ​ 
		x = 20; ​ 
	},"t1").start(); ​ 
		new Thread(() -&gt; { ​ 
		// x=20 对 t2 可见, 同时 y=10 也对 t2 可见 ​ 
		System.out.println(x); ​ 
	},"t2").start(); ​
</code></pre> 
 <h3 id="6%E3%80%81%E7%BB%83%E4%B9%A0">6、练习</h3> 
 <p><strong>1）balking 模式习题</strong><br> 希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p> 
 <pre><code class="language-java">public class TestVolatile {
    volatile boolean initialized = false;
    void init() {
        if (initialized) {
            return;
        }
        doInit();
        initialized = true;
    }
    private void doInit() {
    }
} 
</code></pre> 
 <p>volatile 可以保存线程的可见性，有序性，但是不能保证原子性，doInit 方法没加锁，可能会被调用多次。</p> 
 <p>2）线程安全单例习题<br> 单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试着分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p> 
 <ul><li>饿汉式：类加载就会导致该单实例对象被创建</li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li></ul> 
 <p><strong>实现1： 饿汉式</strong></p> 
 <pre><code class="language-java">// 问题1：为什么加 final，防止子类继承后更改
// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示
public final class Singleton implements Serializable {
    // 问题3：为什么设置为私有? 放弃其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。
    private Singleton() {}
    // 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性
    private static final Singleton INSTANCE = new Singleton();
    // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。
    //1.提供更好的封装性；2.提供范型的支持
    public static Singleton getInstance() {
        return INSTANCE;
    }
    public Object readResolve() {
        return INSTANCE;
    }
}
</code></pre> 
 <p><strong>实现2： 饿汉式</strong></p> 
 <pre><code class="language-java">// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量
// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量
// 问题3：枚举单例能否被反射破坏单例：不能
// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了
enum Singleton {
 INSTANCE;
}
</code></pre> 
 <p><strong>实现3：懒汉式</strong></p> 
 <pre><code class="language-java">public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    // 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次访问都会加锁，性能比较低。
    public static synchronized Singleton getInstance() {
        if( INSTANCE != null ){
            return INSTANCE;
        }
        INSTANCE = new Singleton();
        return INSTANCE;
    }
}
</code></pre> 
 <p><strong>实现4：DCL 懒汉式</strong></p> 
 <pre><code class="language-java">public final class Singleton {
    private Singleton() { }
    // 问题1：解释为什么要加 volatile ?为了防止重排序问题
    private static volatile Singleton INSTANCE = null;

    // 问题2：对比实现3, 说出这样做的意义：提高了效率
    public static Singleton getInstance() {
        if (INSTANCE != null) {
            return INSTANCE;
        }
        synchronized (Singleton.class) {
            // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。
            if (INSTANCE != null) { // t2
                return INSTANCE;
            }
            INSTANCE = new Singleton();
            return INSTANCE;
        }
    }
}
</code></pre> 
 <p><strong>实现5：静态内部类懒汉式</strong></p> 
 <pre><code class="language-java">public final class Singleton {
    private Singleton() { }
    // 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。
    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }
    // 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全
    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
</code></pre> 
 <h3>结论</h3> 
 <p>本章重点讲解了 JMM 中的</p> 
 <ol><li>可见性 - 由 JVM 缓存优化引起</li><li>有序性 - 由 JVM 指令重排序优化引起</li><li>happens-before 规则</li><li>原理方面 
   <ol><li>volatile</li></ol></li><li>模式方面 
   <ol><li>两阶段终止模式的 volatile 改进</li><li>同步模式之 balking</li></ol></li></ol> 
 <h2 id="%E4%BA%94%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81">五、共享模型之无锁</h2> 
 <p>管程即 monitor 是阻塞式的悲观锁实现并发控制，这章我们将通过非阻塞式的乐观锁的来实现并发控制</p> 
 <h3 id="1%E3%80%81%E6%97%A0%E9%94%81%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">1、无锁解决线程安全问题</h3> 
 <p>如下代码，通过 synchronized 解决线程安全问题。</p> 
 <pre><code class="language-java">public class Code_04_UnsafeTest {

    public static void main(String[] args) {
        Account acount = new AccountUnsafe(10000);
        Account.demo(acount);
    }

}
class AccountUnsafe implements Account {

    private Integer balance;

    public AccountUnsafe(Integer balance) {
        this.balance = balance;
    }

    @Override
    public Integer getBalance() {
        return this.balance;
    }

    @Override
    public void withdraw(Integer amount) {
        synchronized (this) { // 加锁。
            this.balance -= amount;
        }
    }
}

interface Account {

    // 获取金额的方法
    Integer getBalance();
    // 取款的方法
    void withdraw(Integer amount);

    static void demo(Account account) {
        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();
        long start = System.nanoTime();
        for(int i = 0; i &lt; 1000; i++) {
            list.add(new Thread(() -&gt; {
                account.withdraw(10);
            }));
        }
        list.forEach(Thread::start);
        list.forEach(t -&gt; {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.nanoTime();
        System.out.println(account.getBalance()
                + " cost: " + (end-start)/1000_000 + " ms");
    }
}

</code></pre> 
 <p>如上代码加锁会造成线程堵塞，堵塞的时间取决于临界区代码执行的时间，这使用加锁的性能不高，我们可以使用无锁来解决此问题。</p> 
 <pre><code class="language-java">class AccountSafe implements Account{

    AtomicInteger atomicInteger ;
    
    public AccountSafe(Integer balance){
        this.atomicInteger =  new AtomicInteger(balance);
    }
    
    @Override
    public Integer getBalance() {
        return atomicInteger.get();
    }

    @Override
    public void withdraw(Integer amount) {
        // 核心代码
        while (true){
            int pre = getBalance();
            int next = pre - amount;
            if (atomicInteger.compareAndSet(pre,next)){
                break;
            }
        }
    }
}
</code></pre> 
 <h3 id="2%E3%80%81CAS%20%E4%B8%8E%20volatile">2、CAS 与 volatile</h3> 
 <h4 id="1%EF%BC%89cas">1）cas</h4> 
 <p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？<br> 其中的关键是 compareAndSwap（比较并设置值），它的简称<strong>就是 CAS</strong> （也有 Compare And Swap 的说法），它必须<strong>是原子操作</strong>。</p> 
 <p><img alt="" height="626" src="https://images2.imgbox.com/f5/a5/f8VmpdPS_o.png" width="596"></p> 
 <p> 如图所示，它的工作流程如下：<br> 当一个线程要去修改 Account 对象中的值时，先获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用 cas 方法）。在调用 cas 方法时，会将 pre 与 Account 中的余额进行比较。</p> 
 <ul><li>如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果两者不相等，就不设置值，重新获取值 preVal（调用get方法），然后再将其设置为新的值 nextVal（调用cas方法），直到修改成功为止。</li></ul> 
 <p>注意：</p> 
 <ul><li>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的 。</li></ul> 
 <h4 id="2%EF%BC%89volatile">2）volatile</h4> 
 <p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。<br> 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。<br> 注意<br> volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）<br> CAS 是原子性操作借助 volatile 读取到共享变量的新值来实现【比较并交换】的效果</p> 
 <h4 id="3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98">3）为什么无锁效率高</h4> 
 <p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大<br> 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p> 
 <h4 id="4%EF%BC%89CAS%20%E7%9A%84%E7%89%B9%E7%82%B9">4）CAS 的特点</h4> 
 <p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p> 
 <ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</li></ul> 
 <p>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一<br> 但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响</p> 
 <h3 id="3%E3%80%81%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0">3、原子整数</h3> 
 <p>java.util.concurrent.atomic并发包提供了一些并发工具类，这里把它分成五类：</p> 
 <p>原子整数<br> 原子引用<br> 原子数组<br> 字段更新器<br> 原子累加器</p> 
 <p><br> 使用原子的方式更新基本类型</p> 
 <ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul> 
 <p>上面三个类提供的方法几乎相同，所以我们将以 AtomicInteger 为例子来介绍。</p> 
 <p>下面先讨论原子整数类，以 AtomicInteger 为例讨论它的api接口：通过观察源码可以发现，AtomicInteger 内部都是通过cas的原理来实现的。</p> 
 <pre><code class="language-java">    public static void main(String[] args) {
        AtomicInteger i = new AtomicInteger(0);
        // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
        System.out.println(i.getAndIncrement());
        // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
        System.out.println(i.incrementAndGet());
        // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
        System.out.println(i.decrementAndGet());
        // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
        System.out.println(i.getAndDecrement());
        // 获取并加值（i = 0, 结果 i = 5, 返回 0）
        System.out.println(i.getAndAdd(5));
        // 加值并获取（i = 5, 结果 i = 0, 返回 0）
        System.out.println(i.addAndGet(-5));
        // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
        // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
        System.out.println(i.getAndUpdate(p -&gt; p - 2));
        // 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
        // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
        System.out.println(i.updateAndGet(p -&gt; p + 2));
        // 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
        // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
        // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
        // getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
        System.out.println(i.getAndAccumulate(10, (p, x) -&gt; p + x));
        // 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）
        // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
        System.out.println(i.accumulateAndGet(-10, (p, x) -&gt; p + x));
    }
</code></pre> 
 <p></p> 
</div> 
<h3 id="4%E3%80%81%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%C2%A0">4、原子引用 </h3> 
<p>为什么需要原子引用类型？保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。<br> 基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p> 
<ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起。</li></ul> 
<h4 id="1%EF%BC%89AtomicReference">1）AtomicReference</h4> 
<p>先看如下代码的问题：</p> 
<pre><code class="language-java">class DecimalAccountUnsafe implements DecimalAccount {
    BigDecimal balance;
    public DecimalAccountUnsafe(BigDecimal balance) {
        this.balance = balance;
    }
    @Override
    public BigDecimal getBalance() {
        return balance;
    }
    // 取款任务
    @Override
    public void withdraw(BigDecimal amount) {
        BigDecimal balance = this.getBalance();
        this.balance = balance.subtract(amount);
    }
}
</code></pre> 
<p>当执行 withdraw 方法时，可能会有线程安全，我们可以加锁解决或者是使用无锁的方式 CAS 来解决，解决方式是用 AtomicReference 原子引用解决。<br> 代码如下：</p> 
<pre><code class="language-java">
class DecimalAccountCas implements DecimalAccount {

    private AtomicReference&lt;BigDecimal&gt; balance;

    public DecimalAccountCas(BigDecimal balance) {
        this.balance = new AtomicReference&lt;&gt;(balance);
    }

    @Override
    public BigDecimal getBalance() {
        return balance.get();
    }

    @Override
    public void withdraw(BigDecimal amount) {
        while (true) {
            BigDecimal preVal = balance.get();
            BigDecimal nextVal = preVal.subtract(amount);
            if(balance.compareAndSet(preVal, nextVal)) {
                break;
            }
        }
    }
}
</code></pre> 
<h4 id="2%EF%BC%89ABA%20%E9%97%AE%E9%A2%98">2）ABA 问题</h4> 
<p>看如下代码：</p> 
<pre><code class="language-java">	public static AtomicReference&lt;String&gt; ref = new AtomicReference&lt;&gt;("A");

    public static void main(String[] args) throws InterruptedException {
        log.debug("main start...");
        String preVal = ref.get();
        other();
        TimeUnit.SECONDS.sleep(1);
        log.debug("change A-&gt;C {}", ref.compareAndSet(preVal, "C"));
    }

    private static void other() throws InterruptedException {
        new Thread(() -&gt; {
            log.debug("change A-&gt;B {}", ref.compareAndSet(ref.get(), "B"));
        }, "t1").start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; {
            log.debug("change B-&gt;A {}", ref.compareAndSet(ref.get(), "A"));
        }, "t2").start();
    }
</code></pre> 
<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号。使用AtomicStampedReference来解决。</p> 
<h4 id="3)AtomicStampedReference">3)AtomicStampedReference</h4> 
<p>使用 AtomicStampedReference 加 stamp （版本号或者时间戳）的方式解决 ABA 问题。代码如下：</p> 
<pre><code class="language-java">// 两个参数，第一个：变量的值 第二个：版本号初始值
    public static AtomicStampedReference&lt;String&gt; ref = new AtomicStampedReference&lt;&gt;("A", 0);

    public static void main(String[] args) throws InterruptedException {
        log.debug("main start...");
        String preVal = ref.getReference();
        int stamp = ref.getStamp();
        log.info("main 拿到的版本号 {}",stamp);
        other();
        TimeUnit.SECONDS.sleep(1);
        log.info("修改后的版本号 {}",ref.getStamp());
        log.info("change A-&gt;C:{}", ref.compareAndSet(preVal, "C", stamp, stamp + 1));
    }

    private static void other() throws InterruptedException {
        new Thread(() -&gt; {
            int stamp = ref.getStamp();
            log.info("{}",stamp);
            log.info("change A-&gt;B:{}", ref.compareAndSet(ref.getReference(), "B", stamp, stamp + 1));
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; {
            int stamp = ref.getStamp();
            log.info("{}",stamp);
            log.debug("change B-&gt;A:{}", ref.compareAndSet(ref.getReference(), "A",stamp,stamp + 1));
        }).start();
    }
</code></pre> 
<h4 id="4)AtomicMarkableReference">4)AtomicMarkableReference</h4> 
<p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference 。</p> 
<h3 id="5%E3%80%81%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><br> 5、原子数组</h3> 
<p>使用原子的方式更新数组里的某个元素</p> 
<ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul> 
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍，代码如下：<br>  </p> 
<pre><code class="language-java">public class Code_10_AtomicArrayTest {

    public static void main(String[] args) throws InterruptedException {
        /**
         * 结果如下：
         * [9934, 9938, 9940, 9931, 9935, 9933, 9944, 9942, 9939, 9940]
         * [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]
         */
        demo(
                () -&gt; new int[10],
                (array) -&gt; array.length,
                (array, index) -&gt; array[index]++,
                (array) -&gt; System.out.println(Arrays.toString(array))
        );
        TimeUnit.SECONDS.sleep(1);
        demo(
                () -&gt; new AtomicIntegerArray(10),
                (array) -&gt; array.length(),
                (array, index) -&gt; array.getAndIncrement(index),
                (array) -&gt; System.out.println(array)
        );
    }

    private static &lt;T&gt; void demo(
            Supplier&lt;T&gt; arraySupplier,
            Function&lt;T, Integer&gt; lengthFun,
            BiConsumer&lt;T, Integer&gt; putConsumer,
            Consumer&lt;T&gt; printConsumer) {
        ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); // 创建集合
        T array = arraySupplier.get(); // 获取数组
        int length = lengthFun.apply(array); // 获取数组的长度
        for(int i = 0; i &lt; length; i++) {
            ts.add(new Thread(() -&gt; {
                for (int j = 0; j &lt; 10000; j++) {
                    putConsumer.accept(array, j % length);
                }
            }));
        }
        ts.forEach(Thread::start);
        ts.forEach((thread) -&gt; {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        printConsumer.accept(array);
    }

}
</code></pre> 
<p>使用原子数组可以保证元素的线程安全。</p> 
<h3 id="6%E3%80%81%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8">6、字段更新器</h3> 
<ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul> 
<p>注意：利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p> 
<pre><code class="language-java">Exception in thread "main" java.lang.IllegalArgumentException: Must be volatile type
</code></pre> 
<p>代码如下：</p> 
<pre><code class="language-java">public class Code_11_AtomicReferenceFieldUpdaterTest {

    public static AtomicReferenceFieldUpdater ref =
            AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");

    public static void main(String[] args) throws InterruptedException {
        Student student = new Student();

        new Thread(() -&gt; {
            System.out.println(ref.compareAndSet(student, null, "list"));
        }).start();
        System.out.println(ref.compareAndSet(student, null, "张三"));
        System.out.println(student);
    }

}

class Student {

    public volatile String name;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
</code></pre> 
<p>字段更新器就是为了保证类中某个属性线程安全问题。</p> 
<h3 id="7%E3%80%81%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8">7、原子累加器</h3> 
<h4 id="1%EF%BC%89AtomicLong%20Vs%20LongAdder"><a name="t35"></a><a id="1AtomicLong_Vs_LongAdder_1001"></a>1）AtomicLong Vs LongAdder</h4> 
<pre><code class="language-java">	public static void main(String[] args) {
        for(int i = 0; i &lt; 5; i++) {
            demo(() -&gt; new AtomicLong(0), (ref) -&gt; ref.getAndIncrement());
        }
        for(int i = 0; i &lt; 5; i++) {
            demo(() -&gt; new LongAdder(), (ref) -&gt; ref.increment());
        }
    }

    private static &lt;T&gt; void demo(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer) {
        ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();

        T adder = supplier.get();
        // 4 个线程，每人累加 50 万
        for (int i = 0; i &lt; 4; i++) {
            list.add(new Thread(() -&gt; {
                for (int j = 0; j &lt; 500000; j++) {
                    consumer.accept(adder);
                }
            }));
        }
        long start = System.nanoTime();
        list.forEach(t -&gt; t.start());
        list.forEach(t -&gt; {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.nanoTime();
        System.out.println(adder + " cost:" + (end - start)/1000_000);
    }

</code></pre> 
<p>执行代码后，发现使用 LongAdder 比 AtomicLong 快2，3倍，使用 LongAdder 性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p> 
<h3 id="8%E3%80%81LongAdder%20%E5%8E%9F%E7%90%86">8、LongAdder 原理</h3> 
<p>LongAdder 类有几个关键域<br> public class LongAdder extends Striped64 implements Serializable {}<br> 下面的变量属于 Striped64 被 LongAdder 继承。</p> 
<pre><code class="language-java">// 累加单元数组, 懒惰初始化
transient volatile Cell[] cells;
// 基础值, 如果没有竞争, 则用 cas 累加这个域
transient volatile long base;
// 在 cells 创建或扩容时, 置为 1, 表示加锁
transient volatile int cellsBusy; 
</code></pre> 
<h4 id="1%EF%BC%89%E4%BD%BF%E7%94%A8%20cas%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81">1）使用 cas 实现一个自旋锁</h4> 
<pre><code class="language-java">public class Code_13_LockCas {

    public AtomicInteger state = new AtomicInteger(0); // 如果 state 值为 0 表示没上锁, 1 表示上锁

    public void lock() {
        while (true) {
            if(state.compareAndSet(0, 1)) {
                break;
            }
        }
    }

    public void unlock() {
        log.debug("unlock...");
        state.set(0);
    }

    public static void main(String[] args) {
        Code_13_LockCas lock = new Code_13_LockCas();
        new Thread(() -&gt; {
            log.info("begin...");
            lock.lock();
            try {
                log.info("上锁成功");
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "t1").start();
        new Thread(() -&gt; {
            log.info("begin...");
            lock.lock();
            try {
                log.info("上锁成功");
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "t2").start();
    }

}

</code></pre> 
<h4 id="2%EF%BC%89%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BC%AA%E5%85%B1%E4%BA%AB">2）原理之伪共享</h4> 
<p>其中 Cell 即为累加单元</p> 
<pre><code class="language-java">// 防止缓存行伪共享
@sun.misc.Contended
static final class Cell {
    volatile long value;
    Cell(long x) { value = x; }
    // 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值
    final boolean cas(long prev, long next) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next);
    }
    // 省略不重要代码
}
</code></pre> 
<p>下面讨论 @sun.misc.Contended 注解的重要意义<br> 得从缓存说起，缓存与内存的速度比较</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/c5/e2/9SpwWKLx_o.png" width="821"></p> 
<p> 因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。缓存离 cpu 越近速度越快。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效。<br><img alt="" height="337" src="https://images2.imgbox.com/f1/2f/LrDjrdO1_o.png" width="815"></p> 
<p></p> 
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了： Core-0 要修改 Cell[0]，Core-1 要修改 Cell[1]</p> 
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效，@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效<br><img alt="" height="338" src="https://images2.imgbox.com/25/a9/ZGbs4uQt_o.png" width="817"></p> 
<h4 id="%C2%A03%EF%BC%89add%20%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"> 3）add 方法分析</h4> 
<p>LongAdder 进行累加操作是调用 increment 方法，它又调用 add 方法。</p> 
<pre><code class="language-java">public void increment() {
        add(1L);
    }
</code></pre> 
<p><strong>第一步：add 方法分析，流程图如下</strong></p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/bc/9d/ka8KhyOx_o.png" width="769"></p> 
<p>源码如下：</p> 
<pre><code class="language-java">public void add(long x) {
        // as 为累加单元数组, b 为基础值, x 为累加值
        Cell[] as; long b, v; int m; Cell a;
        // 进入 if 的两个条件
        // 1. as 有值, 表示已经发生过竞争, 进入 if
        // 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if
        // 3. 如果 as 没有创建, 然后 cas 累加成功就返回，累加到 base 中 不存在线程竞争的时候用到。
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            // uncontended 表示 cell 是否有竞争，这里赋值为 true 表示有竞争
            boolean uncontended = true;
            if (
                // as 还没有创建
                    as == null || (m = as.length - 1) &lt; 0 ||
                            // 当前线程对应的 cell 还没有被创建，a为当线程的cell
                            (a = as[getProbe() &amp; m]) == null ||
       // 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )
                            !(uncontended = a.cas(v = a.value, v + x))
            ) {
                // 当 cells 为空时，累加操作失败会调用方法，
                // 当 cells 不为空，当前线程的 cell 创建了但是累加失败了会调用方法，
                // 当 cells 不为空，当前线程 cell 没创建会调用这个方法
                // 进入 cell 数组创建、cell 创建的流程
                longAccumulate(x, null, uncontended);
            }
        }
    }
</code></pre> 
<p> <strong>第二步：longAccumulate 方法分析，流程图如下：</strong></p> 
<p><img alt="" height="682" src="https://images2.imgbox.com/31/5b/QMhEbePE_o.png" width="1149"></p> 
<p> 源码如下：</p> 
<pre><code class="language-java">final void longAccumulate(long x, LongBinaryOperator fn,
                              boolean wasUncontended) {
        int h;
        // 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell
        if ((h = getProbe()) == 0) {
            // 初始化 probe
            ThreadLocalRandom.current();
            // h 对应新的 probe 值, 用来对应 cell
            h = getProbe();
            wasUncontended = true;
        }
        // collide 为 true 表示需要扩容
        boolean collide = false;
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            // 已经有了 cells
            if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) {
                // 但是还没有当前线程对应的 cell
                if ((a = as[(n - 1) &amp; h]) == null) {
                    // 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x
                    // 成功则 break, 否则继续 continue 循环
                    if (cellsBusy == 0) {       // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &amp;&amp;
                                    (m = rs.length) &gt; 0 &amp;&amp;
                                    // 判断槽位确实是空的
                                    rs[j = (m - 1) &amp; h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                }
                // 有竞争, 改变线程对应的 cell 来重试 cas
                else if (!wasUncontended)
                    wasUncontended = true;
                    // cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null
                else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
                    break;
                    // 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas
                else if (n &gt;= NCPU || cells != as)
                    collide = false;
                    // 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了
                else if (!collide)
                    collide = true;
                    // 加锁
                else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                    // 加锁成功, 扩容
                    continue;
                }
                // 改变线程对应的 cell
                h = advanceProbe(h);
            }
            // 还没有 cells, cells==as是指没有其它线程修改cells，as和cells引用相同的对象，使用casCellsBusy()尝试给 cellsBusy 加锁
            else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
                // 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell
                // 成功则 break;
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h &amp; 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            // 上两种情况失败, 尝试给 base 使用casBase累加
            else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
                break;
        }
    }
</code></pre> 
<h4 id="4%EF%BC%89sum%20%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">4）sum 方法分析</h4> 
<p>获取最终结果通过 sum 方法，将各个累加单元的值加起来就得到了总的结果。</p> 
<pre><code class="language-java">public long sum() {
        Cell[] as = cells; Cell a;
        long sum = base;
        if (as != null) {
            for (int i = 0; i &lt; as.length; ++i) {
                if ((a = as[i]) != null)
                    sum += a.value;
            }
        }
        return sum;
    }
</code></pre> 
<h3 id="5%E3%80%81Unsafe">5、Unsafe</h3> 
<h4 id="1%EF%BC%89Unsafe%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96"><a name="t42"></a><a id="1Unsafe__1276"></a>1）Unsafe 对象的获取</h4> 
<p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。LockSupport 的 park 方法，cas 相关的方法底层都是通过Unsafe类来实现的。</p> 
<pre><code class="language-java">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
		// Unsafe 使用了单例模式，unsafe 对象是类中的一个私有的变量 
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        Unsafe unsafe = (Unsafe)theUnsafe.get(null);
        
    }
</code></pre> 
<h4 id="2%EF%BC%89Unsafe%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%20cas%20%E6%93%8D%E4%BD%9C">2）Unsafe 模拟实现 cas 操作</h4> 
<pre><code class="language-java">public class Code_14_UnsafeTest {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {

        // 创建 unsafe 对象
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        Unsafe unsafe = (Unsafe)theUnsafe.get(null);

        // 拿到偏移量
        long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("id"));
        long nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("name"));

        // 进行 cas 操作
        Teacher teacher = new Teacher();
        unsafe.compareAndSwapLong(teacher, idOffset, 0, 100);
        unsafe.compareAndSwapObject(teacher, nameOffset, null, "lisi");

        System.out.println(teacher);
    }

}

@Data
class Teacher {

    private volatile int id;
    private volatile String name;

}

</code></pre> 
<h4 id="3%EF%BC%89Unsafe%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0">3）Unsafe 模拟实现原子整数</h4> 
<pre><code class="language-java">public class Code_15_UnsafeAccessor {

    public static void main(String[] args) {
        Account.demo(new MyAtomicInteger(10000));
    }
}

class MyAtomicInteger implements Account {

    private volatile Integer value;
    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = UNSAFE.objectFieldOffset
                    (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    public MyAtomicInteger(Integer value) {
        this.value = value;
    }

    public Integer get() {
        return value;
    }

    public void decrement(Integer amount) {
        while (true) {
            Integer preVal = this.value;
            Integer nextVal = preVal - amount;
            if(UNSAFE.compareAndSwapObject(this, valueOffset, preVal, nextVal)) {
                break;
            }
        }
    }

    @Override
    public Integer getBalance() {
        return get();
    }

    @Override
    public void withdraw(Integer amount) {
        decrement(amount);
    }
}
</code></pre> 
<h3>结论</h3> 
<p>本章重点讲解</p> 
<ol><li>CAS 与 volatile</li><li>juc 包下 API 
  <ol><li>原子整数</li><li>原子引用</li><li>原子数组</li><li>字段更新器</li><li>原子累加器</li></ol></li><li>Unsafe</li><li>原理方面 
  <ol><li>LongAdder 源码</li><li>伪共享</li></ol></li></ol> 
<h2 id="%E5%85%AD%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98">六、共享模型之不可变</h2> 
<h3 id="1%E3%80%81%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98"><a name="t47"></a><a id="1_1389"></a>1、日期转换的问题</h3> 
<p>问题提出，下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果。</p> 
<pre><code class="language-java">  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        for (int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                try {
                    log.debug("{}", sdf.parse("1951-04-21"));
                } catch (Exception e) {
                    log.error("{}", e);
                }
            }).start();
        }
</code></pre> 
<p>思路 - 不可变对象<br> 如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter</p> 
<pre><code class="language-java">    DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        for (int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                LocalDate date = dtf.parse("2018-10-01", LocalDate::from);
                log.debug("{}", date);
            }).start();
        }
</code></pre> 
<h3 id="2%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1">2、不可变设计</h3> 
<p>String类中不可变的体现</p> 
<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    /** Cache the hash code for the string */
    private int hash; // Default to 0
    // ...
}
</code></pre> 
<h3 id="1%EF%BC%89final%20%E7%9A%84%E4%BD%BF%E7%94%A8">1）final 的使用</h3> 
<p>发现该类、类中所有属性都是 ﬁnal 的</p> 
<ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改</li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li></ul> 
<h3 id="2%EF%BC%89%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D">2）保护性拷贝</h3> 
<p><br> 但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p> 
<pre><code class="language-java">public String substring(int beginIndex, int endIndex) {
        if (beginIndex &lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        if (endIndex &gt; value.length) {
            throw new StringIndexOutOfBoundsException(endIndex);
        }
        int subLen = endIndex - beginIndex;
        if (subLen &lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        // 上面是一些校验，下面才是真正的创建新的String对象
        return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this
                : new String(value, beginIndex, subLen);
    }
</code></pre> 
<p>发现其内部是调用 String 的构造方法创建了一个新字符串</p> 
<pre><code class="language-java"> public String(char value[], int offset, int count) {
        if (offset &lt; 0) {
            throw new StringIndexOutOfBoundsException(offset);
        }
        if (count &lt;= 0) {
            if (count &lt; 0) {
                throw new StringIndexOutOfBoundsException(count);
            }
            if (offset &lt;= value.length) {
                this.value = "".value;
                return;
            }
        }
        // Note: offset or count might be near -1&gt;&gt;&gt;1.
        if (offset &gt; value.length - count) {
            throw new StringIndexOutOfBoundsException(offset + count);
        }
        // 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值
        this.value = Arrays.copyOfRange(value, offset, offset+count);
    }
</code></pre> 
<p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p> 
<h3 id="3%E3%80%81%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83">3、模式之享元</h3> 
<h4 id="1%EF%BC%89%E7%AE%80%E4%BB%8B"><br> 1）简介</h4> 
<p><br> 简介定义英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时，归类为：Structual patterns</p> 
<h4 id="2%EF%BC%89%E4%BD%93%E7%8E%B0">2）体现</h4> 
<p><br> 包装类<br> 在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法。<br> 例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</p> 
<pre><code class="language-java">public static Long valueOf(long l) {
 final int offset = 128;
 if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache
 return LongCache.cache[(int)l + offset];
 }
 return new Long(l);
}
</code></pre> 
<p>Byte, Short, Long 缓存的范围都是 -128~127<br> Character 缓存的范围是 0~127<br> Integer 的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 "-Djava.lang.Integer.IntegerCache.high "来改变<br> Boolean 缓存了 TRUE 和 FALSE<br><strong>String 池</strong><br><strong>BigDecimal、BigInteger</strong></p> 
<h4 id="3%EF%BC%89DIY%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><strong>3）DIY 实现简单的数据库连接池</strong></h4> 
<p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。<br> 代码实现如下：</p> 
<pre><code class="language-java">public class Code_17_DatabaseConnectionPoolTest {

    public static void main(String[] args) {
        Pool pool = new Pool(2);
        for(int i = 0; i &lt; 5; i++) {
            new Thread(() -&gt; {
                Connection connection = pool.borrow();
                try {
                    Thread.sleep(new Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                pool.free(connection);
            }).start();
        }
    }

}

@Slf4j(topic = "c.Pool")
class Pool {

    // 连接池的大小, 因为没有实现连接池大小的扩容, 用 final 表示池的大小是一个固定值。
    private final int poolSize;
    // 连接池
    private Connection[] connections;
    // 表示连接状态, 如果是 0 表示没连接, 1 表示有连接
    private AtomicIntegerArray status;
    // 初始化连接池
    public Pool(int poolSize) {
        this.poolSize = poolSize;
        status = new AtomicIntegerArray(new int[poolSize]);
        connections = new Connection[poolSize];
        for(int i = 0; i &lt; poolSize; i++) {
            connections[i] = new MockConnection("连接" + (i + 1));
        }
    }

    // 从连接池中获取连接
    public Connection borrow() {
        while (true) {
            for(int i = 0; i &lt; poolSize; i++) {
                if(0 == status.get(i)) {
                    if(status.compareAndSet(i,0, 1)) {
                        log.info("获取连接:{}", connections[i]);
                        return connections[i];
                    }
                }
            }
            synchronized (this) {
                try {
                    log.info("wait ...");
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // 从连接池中释放指定的连接
    public void free(Connection connection) {
        for (int i = 0; i &lt; poolSize; i++) {
            if(connections[i] == connection) {
                status.set(i, 0);
                log.info("释放连接:{}", connections[i]);
                synchronized (this) {
                    notifyAll();
                }
            }
        }
    }

}

class MockConnection implements Connection {

    private String name;

    public MockConnection(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "MockConnection{" +
                "name='" + name + '\'' +
                '}';
    }
}
</code></pre> 
<p>以上实现没有考虑：</p> 
<ul><li>连接的动态增长与收缩</li><li>连接保活（可用性检测）</li><li>等待超时处理</li><li>分布式 hash</li></ul> 
<p>对于关系型数据库，有比较成熟的连接池的实现，例如 c3p0、druid 等<br> 对于更通用的对象池，可以考虑用 apache commons pool，例如 redis 连接池可以参考 jedis 中关于连接池的实现。</p> 
<h3 id="4%E3%80%81final%E7%9A%84%E5%8E%9F%E7%90%86">4、final的原理</h3> 
<h4 id="1%EF%BC%89%E8%AE%BE%E7%BD%AE%20final%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86"><a name="t56"></a><a id="1_final__1606"></a>1）设置 final 变量的原理</h4> 
<p>理解了 volatile 原理，再对比 final 的实现就比较简单了</p> 
<pre><code class="language-java">public class TestFinal {
	final int a = 20;
}
</code></pre> 
<p>字节码</p> 
<pre><code class="language-java">0: aload_0
1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V
4: aload_0
5: bipush 20
7: putfield #2 // Field a:I
 &lt;-- 写屏障
10: return
</code></pre> 
<p>final 变量的赋值操作都必须在定义时或者构造器中进行初始化赋值，并发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。</p> 
<h3>结论</h3> 
<ul><li>不可变类使用</li><li>不可变类设计</li><li>原理方面：final</li><li>模式方面 
  <ul><li>享元模式-&gt; 设置线程池</li></ul></li></ul> 
<h2 id="%E4%B8%83%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7">七、共享模型之工具</h2> 
<h3 id="1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><a name="t1"></a><a id="1_6"></a>1、线程池</h3> 
<p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。<br> 线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。<br> 这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p> 
<ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul> 
<h3 id="2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0">2、自定义线程池</h3> 
<p><img alt="" height="459" src="https://images2.imgbox.com/e5/c9/Y0x8fVR3_o.png" width="1108"></p> 
<p> 上图就是一个线程池的实现，先初始化线程池、阻塞队列大小，然后开几个线程通过线程池对象调用方法执行任务，线程池中的线程会执行任务，如果任务过多，会添加到阻塞队列中，执行完任务再从阻塞队列中取值继续执行。当执行的线程数大于线程池和阻塞队列的大小，我们可以定义拒绝策略，类似 jdk 线程池那样。代码实现如下：<br>  </p> 
<pre><code class="language-java">@Slf4j(topic = "c.Demo7")
public class Demo7 {
    public static void main(String[] args) {
        ThreadPool threadPool=new ThreadPool(1, 1000, TimeUnit.NANOSECONDS, 2,
                ((queue, task) -&gt; {
                    //等待
                   // queue.put(task);
                    queue.put(task, 1500, TimeUnit.MILLISECONDS);
                }));
        for (int i = 0; i &lt; 4; i++) {
            int j=i;
            threadPool.execute(()-&gt;{
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("{}",j);
            });
        }
    }
}

@FunctionalInterface
interface RejectPolicy&lt;T&gt;{
    void reject(BockingQueue&lt;T&gt; queue,T task);
}

@Slf4j(topic = "c.ThreadPool")
class ThreadPool{
    //任务队列
BockingQueue&lt;Runnable&gt; taskQueue;
    //线程集合
HashSet&lt;Worker&gt; workers=new HashSet&lt;&gt;();
    //核心线程数
private int coreSize;
    //超时时间
private long timeout;
    private  TimeUnit timeUnit;

    RejectPolicy&lt;Runnable&gt; rejectPolicy;

    public void  execute(Runnable task){
        synchronized (workers) {
            if (workers.size() &lt; coreSize) {
                Worker worker = new Worker(task);
                log.debug("新增 worker{}, {}", worker, task);
                workers.add(worker);
                worker.start();
            } else {
                taskQueue.tryPut(rejectPolicy,task);
            }
        }
    }


   class Worker extends Thread {
       private Runnable task;

       public Worker(Runnable task) {
           this.task = task;
       }

       @Override
       public void run() {
            // 执行任务
           // 1) 当 task 不为空，执行任务
           // 2) 当 task 执行完毕，再接着从任务队列获取任务并执行
           //while (task!=null || (task=taskQueue.take())!=null){
           while (task!=null || (task=taskQueue.take(timeout,timeUnit))!=null){
               try {
                   log.debug("正在执行:{}",task);
                   task.run();
               }catch (Exception e){
                   e.printStackTrace();
               }finally {
                 task=null;
               }
           }
           synchronized (workers){
               log.debug("worker被移除:{}",this);
               workers.remove(this);
           }
       }
   }



    public ThreadPool( int coreSize, long timeout, TimeUnit timeUnit,int queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue=new BockingQueue&lt;&gt;(queueCapacity);
        this.rejectPolicy=rejectPolicy;
    }
}

@Slf4j(topic = "c.BockingQueue")
class BockingQueue&lt;T&gt;{
    //1.任务队列
    private Deque&lt;T&gt; deque=new ArrayDeque&lt;&gt;();
    //2.锁
    private  ReentrantLock lock=new ReentrantLock();
    //3.生产者条件变量
    private Condition fullWaitSet=lock.newCondition();
    //4.消费者条件变量
   private  Condition emptyWaitSet= lock.newCondition();
    //5.容量
    private int capacity;



    public BockingQueue(int capacity) {
        this.capacity = capacity;
    }

    //从队列中取任务,限时等待
    public T take(long timeout, TimeUnit unit){
        lock.lock();
        try{
            long nanos = unit.toNanos(timeout);
            while (deque.isEmpty()){
                try {
                    if(nanos&lt;=0){
                        return null;
                    }
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = deque.removeFirst();
            fullWaitSet.signal();
            return t;
        }finally {
            lock.unlock();
        }
    }
    //从队列中取任务
    public T take(){
        lock.lock();
        try{
           while (deque.isEmpty()){
               try {
                   emptyWaitSet.await();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
            T t = deque.removeFirst();
           fullWaitSet.signal();
           return t;
        }finally {
            lock.unlock();
        }
    }
    //把任务放入队列，带超时
    public boolean put(T task,long timeout,TimeUnit unit) {
        lock.lock();
        try {
            long nanos = unit.toNanos(timeout);

            while (deque.size() == capacity) {
                log.debug("尝试加入队列:{}", task);
                try { if(nanos&lt;=0){
                    return false;
                }
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("加入队列成功:{}",task);
            deque.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    //把任务放入队列
    public void put(T task){
        lock.lock();
        try{
            while (deque.size()==capacity){
                try {
                    log.debug("尝试加入队列:{}",task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("加入队列成功:{}",task);
            deque.addLast(task);
            emptyWaitSet.signal();
        }finally {
            lock.unlock();
        }
    }

    public int size(){
        lock.lock();
        try{
            return deque.size();
        }finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) {
        lock.lock();
        try {
            if(deque.size()==capacity){
               rejectPolicy.reject(this, task);
            }else {
                log.debug("加入队列成功:{}",task);
                deque.addLast(task);
                emptyWaitSet.signal();
            }
        }finally {
            lock.unlock();
        }
    }
}</code></pre> 
<h3 id="3%E3%80%81ThreadPoolExecutor">3、ThreadPoolExecutor</h3> 
<h4 id="1%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81">1）线程池状态</h4> 
<p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量，ThreadPoolExecutor 类中的线程状态变量如下：</p> 
<pre><code class="language-java">	// Integer.SIZE 值为 32 
  	private static final int COUNT_BITS = Integer.SIZE - 3;
    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;
</code></pre> 
<p><img alt="" height="293" src="https://images2.imgbox.com/06/21/Wsh8tkBz_o.png" width="1200"></p> 
<p></p> 
<p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p> 
<ul><li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul> 
<pre><code class="language-java">// 原子整数，前 3 位保存了线程池的状态，剩余位保存的是线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 并不是所有平台的 int 都是 32 位。
// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量
// 高3位为0，剩余位数全为1
private static final int COUNT_BITS = Integer.SIZE - 3;

// 2^COUNT_BITS次方，表示可以保存的最大线程数
// CAPACITY 的高3位为 0
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;
</code></pre> 
<p>获取线程池状态、线程数量以及合并两个值的操作</p> 
<pre><code class="language-java">// Packing and unpacking ctl
// 获取运行状态
// 该操作会让除高3位以外的数全部变为0
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }

// 获取运行线程数
// 该操作会让高3位为0
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }

// 计算ctl新值
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre> 
<p>获取线程池状态、线程数量以及合并两个值的操作</p> 
<pre><code class="language-java">// Packing and unpacking ctl
// 获取运行状态
// 该操作会让除高3位以外的数全部变为0
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }

// 获取运行线程数
// 该操作会让高3位为0
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }

// 计算ctl新值
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre> 
<p><strong>线程池的属性：</strong></p> 
<pre><code class="language-java">// 工作线程，内部封装了Thread
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable {
    ...
}

// 阻塞队列，用于存放来不及被核心线程执行的任务
private final BlockingQueue&lt;Runnable&gt; workQueue;

// 锁
private final ReentrantLock mainLock = new ReentrantLock();

//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();
</code></pre> 
<p><strong>线程池的属性：</strong></p> 
<pre><code class="language-java">// 工作线程，内部封装了Thread
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable {
    ...
}

// 阻塞队列，用于存放来不及被核心线程执行的任务
private final BlockingQueue&lt;Runnable&gt; workQueue;

// 锁
private final ReentrantLock mainLock = new ReentrantLock();

//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();
</code></pre> 
<h4 id="2%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">2）构造方法</h4> 
<p>首先我们看一下 ThreadPoolExecutor 类参数最多、最全的有参构造方法。</p> 
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre> 
<p>构造参数解释：</p> 
<ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数</li></ul> 
<ol><li>maximumPoolSize - corePoolSize = 救急线程数</li></ol> 
<ul><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）</li></ul> 
<ol><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的队列 SynchronousQueue</li></ol> 
<ul><li>优先队列 PriorityBlockingQueue</li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul> 
<p>工作方式：</p> 
<ul><li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li><li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入 workQueue 队列排 队，直到有空闲的线程。</li><li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急。</li><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 下面的前 4 种实现，其它著名框架也提供了实现</li></ul> 
<ol><li>ThreadPoolExecutor.AbortPolicy 让调用者抛出RejectedExecutionException 异常，这是默认策略</li><li>ThreadPoolExecutor.CallerRunsPolicy 让调用者运行任务</li><li>ThreadPoolExecutor.DiscardPolicy 放弃本次任务</li><li>ThreadPoolExecutor.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ol> 
<ul><li>当高峰过去后，超过 corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。</li></ul> 
<p>jdk 线程池的拒绝策略结构图如下：<br><img alt="" height="142" src="https://images2.imgbox.com/21/5d/9QI1gOsa_o.png" width="918"></p> 
<p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池</p> 
<h4 id="3%EF%BC%89newFixedThreadPool">3）newFixedThreadPool</h4> 
<p>这个是 Executors 类提供的静态的工厂方法来创建线程池！Executors 是 Executor 框架的工具类，newFixedThreadPool 创建的是固定大小的线程池。实现代码如下：</p> 
<pre><code class="language-java">		// 创建大小为 2 的固定线程池, 自定义线程名称
        ExecutorService executorService = Executors.newFixedThreadPool(2, new ThreadFactory() {
            private AtomicInteger atomicInteger = new AtomicInteger(1);
            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "my_thread_" + atomicInteger.getAndIncrement());
            }
        });
        // 开 3 个线程, 线程池大小为 2 , 第三个线程执行时, 如果前两个线程任务没执行完, 会加入任务队列.
        executorService.execute(() -&gt; {
            log.info("1");
        });
        executorService.execute(() -&gt; {
            log.info("2");
        });
        executorService.execute(() -&gt; {
            log.info("3");
        });
</code></pre> 
<p> 然后我再看看 Executors 类 使用 newFixedThreadPool 如何创建线程的，源码如下：</p> 
<pre><code class="language-java">    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
</code></pre> 
<p></p> 
<p>通过源码可以看到 new ThreadPoolExecutor(xxx) 方法其实是是调用了之前说的完整参数的构造方法，创建的是固定的线程数，使用了默认的线程工厂和拒绝策略。<br> 特点：</p> 
<ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的（LinkedBlockingQueue），可以放任意数量的任务</li><li>适用于任务量已知，相对耗时的任务</li></ul> 
<h4 id="4%EF%BC%89newCachedThreadPool">4）newCachedThreadPool</h4> 
<pre><code class="language-java">    ExecutorService executorService = Executors.newCachedThreadPool();
	public static ExecutorService newCachedThreadPool() {
	 return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
	 60L, TimeUnit.SECONDS,
	 new SynchronousQueue&lt;Runnable&gt;());
	}
</code></pre> 
<p>特点</p> 
<ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着</li></ul> 
<ol><li>全部都是救急线程（60s 后没有任务就回收）</li><li>救急线程可以无限创建</li></ol> 
<ul><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货）SynchronousQueue</li><li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。</li><li>适合任务数比较密集，但每个任务执行时间较短的情况<br>  </li></ul> 
<h4 id="5)newSingleThreadExecutor%C2%A0">5)newSingleThreadExecutor </h4> 
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
 return new FinalizableDelegatedExecutorService
 (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre> 
<p>使用场景：</p> 
<ul><li>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</li><li>newSingleThreadExecutor 和 newFixedThreadPool 区别：</li></ul> 
<ol><li>和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li><li>Executors.newSingleThreadExecutor() 线程个数始终为 1 ，不能修改FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法</li><li>和Executors.newFixedThreadPool(1) 初始时为1时的区别：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改<br>  </li></ol> 
<p>注意，Executors 返回线程池对象的弊端如下：</p> 
<ul><li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。<br>  </li></ul> 
<p> 说白了就是：使用有界队列，控制线程创建数量。<br> 除了避免 OOM 的原因之外，不推荐使用 Executors提供的两种快捷的线程池的原因还有： </p> 
<ol><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ol> 
<h4 id="%C2%A06%EF%BC%89%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%C2%A0"> 6）提交任务 </h4> 
<pre><code class="language-java">// 执行任务
void execute(Runnable command);
// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
// 提交 tasks 中所有任务
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
 throws InterruptedException;
// 提交 tasks 中所有任务，带超时时间
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException;
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
 throws InterruptedException, ExecutionException;
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException, ExecutionException, TimeoutException;
</code></pre> 
<h4 id="7%EF%BC%89%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0">7）关闭线程池</h4> 
<p><strong>shutdown</strong></p> 
<pre><code class="language-java">	/*
	  线程池状态变为 SHUTDOWN
	- 不会接收新任务
	- 但已提交任务会执行完，包括等待队列里面的
	- 此方法不会阻塞调用线程的执行
	*/
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            // 修改线程池状态
            advanceRunState(SHUTDOWN);
            // 仅会打断空闲线程
            interruptIdleWorkers();
            onShutdown(); // 扩展点 ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        // 尝试终结(没有运行的线程可以立刻终结)
        tryTerminate();
    }
</code></pre> 
<p><strong>shutdownNow</strong></p> 
<pre><code class="language-java">    /*
	线程池状态变为 STOP
	- 不会接收新任务
	- 会将队列中的任务返回
	- 并用 interrupt 的方式中断正在执行的任务
	*/
    public List&lt;Runnable&gt; shutdownNow() {

        List&lt;Runnable&gt; tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            // 修改线程池状态
            advanceRunState(STOP);
            // 打断所有线程
            interruptWorkers();
            // 获取队列中剩余任务
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        // 尝试终结
        tryTerminate();
        return tasks;
    }
</code></pre> 
<p><strong>其它方法</strong></p> 
<pre><code class="language-java">// 不在 RUNNING 状态的线程池，此方法就返回 true
boolean isShutdown();
// 线程池状态是否是 TERMINATED
boolean isTerminated();
// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
</code></pre> 
<h4 id="8%EF%BC%89%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0">8）任务调度线程池</h4> 
<p><br> 在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。<br> 使用 ScheduledExecutorService 改写：</p> 
<p>整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务。</p> 
<ul><li>ScheduledExecutorService 中 scheduleAtFixedRate 方法的使用，是 一段时间 的 期间。</li><li>ScheduledExecutorService 中 scheduleWithFixedDelay 方法的使用，是 一段时间 的 间隔。<br>  </li></ul> 
<h4 id="9%EF%BC%89%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8">9）正确处理执行任务异常</h4> 
<p>可以发现，如果线程池中的线程执行任务时，如果任务抛出了异常，默认是中断执行该任务而不是抛出异常或者打印异常信息。<br> 方法1：主动捉异常</p> 
<pre><code class="language-java">	ExecutorService pool = Executors.newFixedThreadPool(1);
	pool.submit(() -&gt; {
		 try {
			 log.debug("task1");
			 int i = 1 / 0;
		 } catch (Exception e) {
		 	log.error("error:", e);
		 }
	});
</code></pre> 
<p>方法2：使用 Future，错误信息都被封装进submit方法的返回方法中</p> 
<pre><code class="language-java">	ExecutorService pool = Executors.newFixedThreadPool(1);
	Future&lt;Boolean&gt; f = pool.submit(() -&gt; {
		 log.debug("task1");
		 int i = 1 / 0;
		 return true;
	});
	log.debug("result:{}", f.get());
</code></pre> 
<h4 id="10%EF%BC%89Tomcat%20%E7%BA%BF%E7%A8%8B%E6%B1%A0">10）Tomcat 线程池</h4> 
<p><img alt="" height="272" src="https://images2.imgbox.com/39/9b/upVwgXfi_o.png" width="1181"></p> 
<ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】<br>  </li></ul> 
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同，如果总线程数达到 maximumPoolSize，这时不会立刻抛 RejectedExecutionException 异常，而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常。<br> 源码 tomcat-7.0.42<br>  </p> 
<pre><code class="language-java">  public void execute(Runnable command, long timeout, TimeUnit unit) {
        submittedCount.incrementAndGet();
        try {
            super.execute(command);
        } catch (RejectedExecutionException rx) {
            if (super.getQueue() instanceof TaskQueue) {
                final TaskQueue queue = (TaskQueue)super.getQueue();
                try {
                    // 使任务从新进入阻塞队列
                    if (!queue.force(command, timeout, unit)) {
                        submittedCount.decrementAndGet();
                        throw new RejectedExecutionException("Queue capacity is full.");
                    }
                } catch (InterruptedException x) {
                    submittedCount.decrementAndGet();
                    Thread.interrupted();
                    throw new RejectedExecutionException(x);
                }
            } else {
                submittedCount.decrementAndGet();
                throw rx;
            }
        }
    }

    public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException {
        if ( parent.isShutdown() )
            throw new RejectedExecutionException(
                    "Executor not running, can't force a command into the queue"
            );
        return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task
        is rejected
    }
</code></pre> 
<p><strong>Connector 配置如下：</strong></p> 
<p><img alt="" height="273" src="https://images2.imgbox.com/07/9a/d9P2IwgX_o.png" width="835"></p> 
<p><strong>Executor 线程池配置如下：</strong></p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/68/1c/flFubtfQ_o.png" width="819"></p> 
<p>可以看到该线程池实现的是一个无界的队列，所以说是不是执行任务的线程数大于了核心线程数，都会添加到阻塞队列中，那么救急线程是不是就不会用到呢，其实不是，分析如下图：</p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/9d/23/tSe8VsC3_o.png" width="785"></p> 
<p>如图所示，当添加新的任务时，如果提交的任务大于核心线程数小于最大线程数就创建救急线程，否则就加入任务队列中。</p> 
<h4 id="%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%C2%A0">异步模式之工作线程 </h4> 
<p>定义：<br> 让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。<br> 例如：<br> 海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message） 注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率 例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工。</p> 
<p>饥饿：<br> 固定大小线程池会有饥饿现象</p> 
<ul><li>两个工人是同一个线程池中的两个线程</li><li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作</li></ul> 
<ol><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li><li>后厨做菜：没啥说的，做就是了</li></ol> 
<ul><li>比如工人 A 处理了点餐任务，接下来它要等着 工人 B 把菜做好，然后上菜，他俩也配合的蛮好 但现在同时来了两个客人，这个时候工人 A 和工人 B 都去处理点餐了，这时没人做饭了，这就是饥饿。<br>  </li></ul> 
<p>解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池。实现代码如下：</p> 
<pre><code class="language-java">/**
 * 异步模式之工作线程
 */
@Slf4j(topic = "c.Code_07_StarvationTest")
public class Code_07_StarvationTest {

    public static List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("宫保鸡丁", "青椒肉丝", "千张肉丝"));
    public static Random random = new Random();
    public static String cooking() {
        return list.get(random.nextInt(list.size()));
    }

    public static void main(String[] args) {
        // 演示饥饿现象
//        ExecutorService executorService = Executors.newFixedThreadPool(2);
//        test1(executorService);

        // 解决
        ExecutorService cookPool = Executors.newFixedThreadPool(1);
        ExecutorService waiterPool = Executors.newFixedThreadPool(1);

        waiterPool.execute(() -&gt; {
            log.info("处理点餐");
            Future&lt;String&gt; f = cookPool.submit(() -&gt; {
                log.info("做菜");

                return cooking();
            });
            try {
                log.info("上菜 {} ", f.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        });

        waiterPool.execute(() -&gt; {
            log.info("处理点餐");
            Future&lt;String&gt; f2 = cookPool.submit(() -&gt; {
                log.info("做菜");
                return cooking();
            });
            try {
                log.info("上菜 {} ", f2.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        });
    }

    public static void test1( ExecutorService executorService) {
        executorService.execute(() -&gt; {
            log.info("处理点餐");
            Future&lt;String&gt; f = executorService.submit(() -&gt; {
                log.info("做菜");
                return cooking();
            });
            try {
                log.info("上菜 {} ", f.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        });
        executorService.execute(() -&gt; {
            log.info("处理点餐");
            Future&lt;String&gt; f2 = executorService.submit(() -&gt; {
                log.info("做菜");
                return cooking();
            });
            try {
                log.info("上菜 {} ", f2.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        });
    }

}


</code></pre> 
<p><strong>创建多大的线程池合适?</strong><br> 过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存，</p> 
<ol><li>CPU 密集型运算 通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</li><li>I/O 密集型运算 CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</li></ol> 
<p>经验公式如下：<br> 线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间<br> 例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 50% = 8<br> 例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 10% = 40<br>  </p> 
<h4 id="%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">应用之定时任务</h4> 
<p>使用 newScheduledThreadPool 中的 scheduleAtFixedRate 这个方法可以执行定时任务。代码如下：</p> 
<pre><code class="language-java"> public static void main(String[] args) {
        // 获取当前时间
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        // 获取每周四晚时间
        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);
        if(now.compareTo(time) &gt; 0) {
            time = time.plusWeeks(1);
        }

        long initalDelay = Duration.between(now, time).toMillis();
        // 一周的时间
        long period = 1000 * 60 * 60 * 24 * 7;
        // initalDelay 表示当前时间与周四的时间差, period 一周的间隔时间。
        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
        // 创建一个定时任务, 每周四 18:00:00 执行。
        executorService.scheduleAtFixedRate(() -&gt; {
            System.out.println("running");
        }, initalDelay, period, TimeUnit.MILLISECONDS);
    }
</code></pre> 
<h3 id="4%E3%80%81Fork%2FJoin">4、Fork/Join</h3> 
<p>参考如下文章：<br><a href="https://blog.csdn.net/tyrroo/article/details/81483608" title="Fork/Join框架原理解析">Fork/Join框架原理解析</a><br><a href="https://www.jianshu.com/p/42e9cd16f705" rel="nofollow" title="Fork/Join框架学习">Fork/Join框架学习</a></p> 
<h2 id="5%E3%80%81J.U.C">5、J.U.C</h2> 
<h4 id="AQS%20%E5%8E%9F%E7%90%86"><a id="AQS__6"></a>AQS 原理</h4> 
<h5 id="1%E3%80%81%E6%A6%82%E8%BF%B0">1、概述</h5> 
<p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p> 
<h5 id="2%E3%80%81%E7%89%B9%E7%82%B9"><a name="t3"></a><a id="2_9"></a>2、特点</h5> 
<ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</li></ul> 
<ol><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ol> 
<ul><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet<br>  </li></ul> 
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p> 
<ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul> 
<pre><code class="language-java">// 获取锁的姿势
// 如果获取锁失败
if (!tryAcquire(arg)) {
 // 入队, 可以选择阻塞当前线程 park unpark
}

// 释放锁的姿势
// 如果释放锁成功
if (tryRelease(arg)) {
 // 让阻塞线程恢复运行
}
</code></pre> 
<h5 id="%C2%A03%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8"> 3、自定义同步器</h5> 
<p>下面实现一个不可重入的阻塞式锁：使用 AbstractQueuedSynchronizer 自定义一个同步器来实现自定义锁，代码如下：</p> 
<pre><code class="language-java">@Slf4j(topic = "c.Code_11_UnRepeatLockTest")
public class Code_11_UnRepeatLockTest {

    public static void main(String[] args) {

        MyLock myLock = new MyLock();
        new Thread(() -&gt; {
            myLock.lock();
            log.info("lock ... ");
            // 测试是否不可重入
            myLock.lock();
            try {
                log.info("starting ... ");
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log.info("unlock ... ");
                myLock.unlock();
            }
        }, "t1").start();

    }

}

// 自定义锁（不可重入锁）
class MyLock implements Lock {

    class MySync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if(compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            if (compareAndSetState(1, 0)) {
                setExclusiveOwnerThread(null);
                setState(0);
                return true;
            }
            return false;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
    }

    private MySync mySync = new MySync();

    // 加锁
    @Override
    public void lock() {
        mySync.acquire(1);
    }

    // 可中断的锁
    @Override
    public void lockInterruptibly() throws InterruptedException {
        mySync.acquireInterruptibly(1);
    }

    // 只会尝试一次加锁
    @Override
    public boolean tryLock() {
        return mySync.tryAcquire(1);
    }

    // 带超时时间的
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return mySync.tryAcquireNanos(1, unit.toNanos(time));
    }

    // 解锁
    @Override
    public void unlock() {
        mySync.release(1);
    }

    // 创建条件变量
    @Override
    public Condition newCondition() {
        return mySync.newCondition();
    }
}
</code></pre> 
<h3 id="ReentrantLock%20%E5%8E%9F%E7%90%86">ReentrantLock 原理</h3> 
<p>可以看到 ReentrantLock 提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁！</p> 
<p> <img alt="" height="430" src="https://images2.imgbox.com/35/7f/kaLV36Xb_o.png" width="938"></p> 
<p></p> 
<h4 id="1%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1、非公平锁实现原理</h4> 
<h5 id="1%EF%BC%89%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><a id="1_144"></a>1）加锁解锁流程</h5> 
<p>先从构造器开始看，默认为非公平锁实现</p> 
<pre><code class="language-java">	public ReentrantLock() {
        sync = new NonfairSync();
    }
</code></pre> 
<p>NonfairSync 继承自 AQS<br> 没有竞争时</p> 
<pre><code class="language-java">		final void lock() {
		 	// 没有竞争时, 直接加锁
            if (compareAndSetState(0, 1))
            	// 设置持有锁的线程
                setExclusiveOwnerThread(Thread.currentThread());
            else
            	// 有竞争, 会调用这个方法
                acquire(1);
        }
</code></pre> 
<p><img alt="" height="389" src="https://images2.imgbox.com/98/75/RvVnLTW1_o.png" width="957"></p> 
<p> 第一个竞争出现时</p> 
<pre><code class="language-java">	public final void acquire(int arg) {
		// 再次尝试加锁, 然后为 true 就不走下面逻辑，为 false，则创建一个 Node 节点对象加入到等待队列中去
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre> 
<p><img alt="" height="389" src="https://images2.imgbox.com/07/f1/e4fcFLV6_o.png" width="1100"></p> 
<p>Thread-1 执行了</p> 
<ul><li>ock方法中CAS 尝试将 state 由 0 改为 1，结果失败</li><li>lock方法中进一步调用acquire方法，进入 tryAcquire 逻辑，这里我们认为这时 state 已经是1，结果仍然失败</li><li>接下来进入 acquire方法的addWaiter 逻辑，构造 Node 队列</li></ul> 
<ol><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ol> 
<p> <img alt="" height="348" src="https://images2.imgbox.com/1d/52/J4df7fe5_o.png" width="1056"></p> 
<p>当前线程进入 acquire方法的 acquireQueued 逻辑</p> 
<ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，我们这里设置这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li></ol> 
<p><img alt="" height="354" src="https://images2.imgbox.com/05/45/uZdyXCn9_o.png" width="1043"></p> 
<ol><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示已经阻塞）<br>  </li></ol> 
<p><img alt="" height="358" src="https://images2.imgbox.com/c2/57/s94GZEna_o.png" width="1075"></p> 
<p> 再从次有多个线程经历上述过程竞争失败，变成这个样子</p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/36/35/oVXhShlE_o.png" width="1153"></p> 
<p></p> 
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p> 
<ul><li>设置 exclusiveOwnerThread 为 null</li><li>state = 0</li></ul> 
<p><img alt="" height="271" src="https://images2.imgbox.com/46/dd/XNM5gPNO_o.png" width="1190"></p> 
<p>如果当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程：</p> 
<p>unparkSuccessor 中会找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p> 
<p>回到 Thread-1 的 acquireQueued 流程</p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/cc/86/q7IjFmFV_o.png" width="1158"></p> 
<p>如果加锁成功（没有竞争），会设置 （acquireQueued 方法中）</p> 
<ol><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ol> 
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/d6/eb/sE8JeNAM_o.png" width="1146"></p> 
<p>如果不巧又被 Thread-4 占了先</p> 
<ol><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ol> 
<p><strong>加锁源码：</strong></p> 
<pre><code class="language-java">// Sync 继承自 AQS
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

     // 加锁实现
    final void lock() {
        // 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            // 如果尝试失败，进入 ㈠
            acquire(1);
    }

    // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处
    public final void acquire(int arg) {
        // ㈡ tryAcquire
        if (
                !tryAcquire(arg) &amp;&amp;
            	// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤
                 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            selfInterrupt();
        }
    }

    // ㈡ 进入 ㈢
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }

    // ㈢ Sync 继承过来的方法, 方便阅读, 放在此处
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        // 如果还没有获得锁
        if (c == 0) {
            // 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入
        else if (current == getExclusiveOwnerThread()) {
            // state++
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        // 获取失败, 回到调用处
        return false;
    }

    // ㈣ AQS 继承过来的方法, 方便阅读, 放在此处
    private Node addWaiter(Node mode) {
// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0
        Node node = new Node(Thread.currentThread(), mode);
        // 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                // 双向链表
                pred.next = node;
                return node;
            }
        }
        //如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥
        enq(node);
        return node;
    }

    // ㈥ AQS 继承过来的方法, 方便阅读, 放在此处
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) {
                // 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）
                if (compareAndSetHead(new Node())) {
                    tail = head;
                }
            } else {
                // cas 尝试将 Node 对象加入 AQS 队列尾部
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

    // ㈤ AQS 继承过来的方法, 方便阅读, 放在此处
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                // 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    // 获取成功, 设置自己（当前线程对应的 node）为 head
                    setHead(node);
                    // 上一个节点 help GC
                    p.next = null;
                    failed = false;
                    // 返回中断标记 false
                    return interrupted;
                }
                if (
                    // 判断是否应当 park, 进入 ㈦
                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    // park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧
                    parkAndCheckInterrupt()
                ) {
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // ㈦ AQS 继承过来的方法, 方便阅读, 放在此处
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 获取上一个节点的状态
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL) {
            // 上一个节点都在阻塞, 那么自己也阻塞好了
            return true;
        }
        // &gt; 0 表示取消状态
        if (ws &gt; 0) {
            // 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            // 这次还没有阻塞
            // 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

    // ㈧ 阻塞当前线程
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
}
</code></pre> 
<p> <strong>解锁源码：</strong></p> 
<pre><code class="language-java">// Sync 继承自 AQS
static final class NonfairSync extends Sync {
    // 解锁实现
    public void unlock() {
        sync.release(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final boolean release(int arg) {
        // 尝试释放锁, 进入 ㈠
        if (tryRelease(arg)) {
            // 队列头节点 unpark
            Node h = head;
            if (
                // 队列不为 null
                h != null &amp;&amp;
                // waitStatus == Node.SIGNAL 才需要 unpark
                h.waitStatus != 0
            ) {
                // unpark AQS 中等待的线程, 进入 ㈡
                unparkSuccessor(h);
            }
            return true;
        }
        return false;
    }

    // ㈠ Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryRelease(int releases) {
        // state--
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // 支持锁重入, 只有 state 减为 0, 才释放成功
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处
    private void unparkSuccessor(Node node) {
        // 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉
        // 不成功也可以
        int ws = node.waitStatus;
        if (ws &lt; 0) {
            compareAndSetWaitStatus(node, ws, 0);
        }
        // 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的
        Node s = node.next;
        // 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
}
</code></pre> 
<h4 id="2%E3%80%81%E9%94%81%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86">2、锁重入原理</h4> 
<pre><code class="language-java">static final class NonfairSync extends Sync {
    // ...

    // Sync 继承过来的方法, 方便阅读, 放在此处
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入
        else if (current == getExclusiveOwnerThread()) {
            // state++
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryRelease(int releases) {
        // state--
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // 支持锁重入, 只有 state 减为 0, 才释放成功
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
}
</code></pre> 
<h4 id="3%E3%80%81%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86">3、可打断原理</h4> 
<p><strong>不可打断模式：</strong><br> 在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了。</p> 
<pre><code class="language-java">// Sync 继承自 AQS
static final class NonfairSync extends Sync {
    // ...

    private final boolean parkAndCheckInterrupt() {
        // 如果打断标记已经是 true, 则 park 会失效
        LockSupport.park(this);
        // interrupted 会清除打断标记
        return Thread.interrupted();
    }

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null;
                    failed = false;
                    // 还是需要获得锁后, 才能返回打断状态
                    return interrupted;
                }
                if (
                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                                parkAndCheckInterrupt()
                ) {
                    // 如果是因为 interrupt 被唤醒, 返回打断状态为 true
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    public final void acquire(int arg) {
        if (
                !tryAcquire(arg) &amp;&amp;
                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            // 如果打断状态为 true
            selfInterrupt();
        }
    }

    static void selfInterrupt() {
        // 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错
        Thread.currentThread().interrupt();
    }
}
}
</code></pre> 
<p><strong>可打断模式：</strong></p> 
<pre><code class="language-java">static final class NonfairSync extends Sync {
    public final void acquireInterruptibly(int arg) throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        // 如果没有获得到锁, 进入 ㈠
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }

    // ㈠ 可打断的获取锁流程
    private void doAcquireInterruptibly(int arg) throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                        parkAndCheckInterrupt()) {
                    // 在 park 过程中如果被 interrupt 会进入此
                    // 这时候抛出异常, 而不会再次进入 for (;;)
                    throw new InterruptedException();
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
}
</code></pre> 
<h4 id="4%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E5%8E%9F%E7%90%86">4、公平锁原理</h4> 
<pre><code class="language-java">static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;
    final void lock() {
        acquire(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final void acquire(int arg) {
        if (
                !tryAcquire(arg) &amp;&amp;
                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            selfInterrupt();
        }
    }
    // 与非公平锁主要区别在于 tryAcquire 方法的实现
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // 先检查 AQS 队列中是否有前驱节点, 没有才去竞争
            if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }

    // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处
    public final boolean hasQueuedPredecessors() {
        Node t = tail;
        Node h = head;
        Node s;
        // h != t 时表示队列中有 Node
        return h != t &amp;&amp;
                (
                        // (s = h.next) == null 表示队列中还有没有老二
                        (s = h.next) == null || // 或者队列中老二线程不是此线程
                                s.thread != Thread.currentThread()
                );
    }
}
</code></pre> 
<p></p> 
<h4 id="5%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5、条件变量实现原理</h4> 
<p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject<br><strong>await 流程</strong></p> 
<p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部<br><img alt="" height="409" src="https://images2.imgbox.com/95/f8/VvEJTmgF_o.png" width="1153"></p> 
<p> 接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁 </p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/3a/0c/N5Yr1is9_o.png" width="1155"></p> 
<p> unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p> 
<p> <img alt="" height="420" src="https://images2.imgbox.com/92/d2/pMMS06YH_o.png" width="1159"></p> 
<p> park 阻塞 Thread-0</p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/68/62/yBK9OTPG_o.png" width="1178"></p> 
<p> <strong>signal 流程</strong><br> 假设 Thread-1 要来唤醒 Thread-0</p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/60/c3/fNkeUe4Q_o.png" width="1144"></p> 
<p> 进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/45/99/73p78F8k_o.png" width="1147"></p> 
<p> 执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/91/cd/8Da3m5ah_o.png" width="1156"></p> 
<p> Thread-1 释放锁，进入 unlock 流程。<br> 源码分析：</p> 
<pre><code class="language-java">public class ConditionObject implements Condition, java.io.Serializable {
    private static final long serialVersionUID = 1173984872572414699L;

    // 第一个等待节点
    private transient Node firstWaiter;

    // 最后一个等待节点
    private transient Node lastWaiter;
    public ConditionObject() { }
    // ㈠ 添加一个 Node 至等待队列
    private Node addConditionWaiter() {
        Node t = lastWaiter;
        // 所有已取消的 Node 从队列链表删除, 见 ㈡
        if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
            unlinkCancelledWaiters();
            t = lastWaiter;
        }
        // 创建一个关联当前线程的新 Node, 添加至队列尾部
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        if (t == null)
            firstWaiter = node;
        else
            t.nextWaiter = node;
        lastWaiter = node;
        return node;
    }
    // 唤醒 - 将没取消的第一个节点转移至 AQS 队列
    private void doSignal(Node first) {
        do {
            // 已经是尾节点了
            if ( (firstWaiter = first.nextWaiter) == null) {
                lastWaiter = null;
            }
            first.nextWaiter = null;
        } while (
            // 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢
                !transferForSignal(first) &amp;&amp;
                        // 队列还有节点
                        (first = firstWaiter) != null
        );
    }

    // 外部类方法, 方便阅读, 放在此处
    // ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功
    final boolean transferForSignal(Node node) {
        // 设置当前node状态为0（因为处在队列末尾），如果状态已经不是 Node.CONDITION, 说明被取消了
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;
        // 加入 AQS 队列尾部
        Node p = enq(node);
        int ws = p.waitStatus;
        if (
            // 插入节点的上一个节点被取消
                ws &gt; 0 ||
                        // 插入节点的上一个节点不能设置状态为 Node.SIGNAL
                        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)
        ) {
            // unpark 取消阻塞, 让线程重新同步状态
            LockSupport.unpark(node.thread);
        }
        return true;
    }
// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列
private void doSignalAll(Node first) {
    lastWaiter = firstWaiter = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);
        first = next;
    } while (first != null);
}

    // ㈡
    private void unlinkCancelledWaiters() {
        // ...
    }
    // 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁
    public final void signal() {
        // 如果没有持有锁，会抛出异常
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }
    // 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁
    public final void signalAll() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignalAll(first);
    }
    // 不可打断等待 - 直到被唤醒
    public final void awaitUninterruptibly() {
        // 添加一个 Node 至等待队列, 见 ㈠
        Node node = addConditionWaiter();
        // 释放节点持有的锁, 见 ㈣
        int savedState = fullyRelease(node);
        boolean interrupted = false;
        // 如果该节点还没有转移至 AQS 队列, 阻塞
        while (!isOnSyncQueue(node)) {
            // park 阻塞
            LockSupport.park(this);
            // 如果被打断, 仅设置打断状态
            if (Thread.interrupted())
                interrupted = true;
        }
        // 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列
        if (acquireQueued(node, savedState) || interrupted)
            selfInterrupt();
    }
    // 外部类方法, 方便阅读, 放在此处
    // ㈣ 因为某线程可能重入，需要将 state 全部释放，获取state，然后把它全部减掉，以全部释放
    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            int savedState = getState();
            // 唤醒等待队列队列中的下一个节点
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }
    // 打断模式 - 在退出等待时重新设置打断状态
    private static final int REINTERRUPT = 1;
    // 打断模式 - 在退出等待时抛出异常
    private static final int THROW_IE = -1;
    // 判断打断模式
    private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
                0;
    }
    // ㈤ 应用打断模式
    private void reportInterruptAfterWait(int interruptMode)
            throws InterruptedException {
        if (interruptMode == THROW_IE)
            throw new InterruptedException();
        else if (interruptMode == REINTERRUPT)
            selfInterrupt();
    }
    // 等待 - 直到被唤醒或打断
    public final void await() throws InterruptedException {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        // 添加一个 Node 至等待队列, 见 ㈠
        Node node = addConditionWaiter();
        // 释放节点持有的锁
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        // 如果该节点还没有转移至 AQS 队列, 阻塞
        while (!isOnSyncQueue(node)) {
            // park 阻塞              
            LockSupport.park(this);
            // 如果被打断, 退出等待队列
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        // 退出等待队列后, 还需要获得 AQS 队列的锁
        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        // 所有已取消的 Node 从队列链表删除, 见 ㈡
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        // 应用打断模式, 见 ㈤
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
    // 等待 - 直到被唤醒或打断或超时
    public final long awaitNanos(long nanosTimeout) throws InterruptedException {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        // 添加一个 Node 至等待队列, 见 ㈠
        Node node = addConditionWaiter();
        // 释放节点持有的锁
        int savedState = fullyRelease(node);
        // 获得最后期限
        final long deadline = System.nanoTime() + nanosTimeout;
        int interruptMode = 0;
        // 如果该节点还没有转移至 AQS 队列, 阻塞
        while (!isOnSyncQueue(node)) {
            // 已超时, 退出等待队列
            if (nanosTimeout &lt;= 0L) {
                transferAfterCancelledWait(node);
                break;
            }
            // park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns
            if (nanosTimeout &gt;= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            // 如果被打断, 退出等待队列
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        // 退出等待队列后, 还需要获得 AQS 队列的锁
        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        // 所有已取消的 Node 从队列链表删除, 见 ㈡
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        // 应用打断模式, 见 ㈤
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return deadline - System.nanoTime();
    }
    // 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos
    public final boolean awaitUntil(Date deadline) throws InterruptedException {
        // ...
    }
    // 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos
    public final boolean await(long time, TimeUnit unit) throws InterruptedException {
        // ...
    }
    // 工具方法 省略 ...
}
</code></pre> 
<h3 id="%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86"><a href="https://so.csdn.net/so/search?q=%E8%AF%BB%E5%86%99%E9%94%81&amp;spm=1001.2101.3001.7020" title="读写锁">读写锁</a>原理</h3> 
<h4 id="1%E3%80%81ReentrantReadWriteLock"><a name="t12"></a><a id="1ReentrantReadWriteLock_898"></a>1、ReentrantReadWriteLock</h4> 
<p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的！</p> 
<p>提供一个数据容器类内部分别使用读锁保护数据的read()方法，写锁保护数据的write()方法 。</p> 
<p> 实现代码如下：</p> 
<pre><code class="language-java">public class Code_12_ReadWriteLockTest {

    public static void main(String[] args) throws InterruptedException {

        DataContainer dataContainer = new DataContainer();

        Thread t1 = new Thread(() -&gt; {
            dataContainer.read();
//            dataContainer.write();
        }, "t1");

//        Thread.sleep(100);

        Thread t2 = new Thread(() -&gt; {
//            dataContainer.read();
            dataContainer.write();
        }, "t2");

        t1.start();
        t2.start();

    }

}

@Slf4j(topic = "c.DataContainer")
class DataContainer {

    private Object object = new Object();
    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
    private ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();

    public Object read() {
        readLock.lock();
        log.info("拿到读锁！");
        try {
            log.info("读取操作 ...");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }finally {
            readLock.unlock();
            log.info("释放读锁！");
        }
        return object;
    }

    public void write() {
        writeLock.lock();
        log.info("拿到写锁！");
        try {
            log.info("写操作 ... ");
        }finally {
            writeLock.unlock();
            log.info("释放写锁！");
        }
    }

}
</code></pre> 
<p>注意事项</p> 
<ol><li>读锁不支持条件变量</li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li></ol> 
<pre><code class="language-java">	 r.lock();
	 try {
	     // ...
	     w.lock();
	     try {
	         // ...
	     } finally{
	         w.unlock();
	     }
	 } finally{
	     r.unlock();
	 }
</code></pre> 
<ol><li>重入时降级支持：即持有写锁的情况下去获取读锁</li></ol> 
<pre><code class="language-java">class CachedData {
    Object data;
    // 是否有效，如果失效，需要重新计算 data
    volatile boolean cacheValid;
    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    void processCachedData() {
        rwl.readLock().lock();
        if (!cacheValid) {
            // 获取写锁前必须释放读锁
            rwl.readLock().unlock();
            rwl.writeLock().lock();
            try {
                // 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新
                if (!cacheValid) {
                    data = ...
                    cacheValid = true;
                }
                // 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存
                rwl.readLock().lock();
            } finally {

                rwl.writeLock().unlock();
            }
        }
        // 自己用完数据, 释放读锁
        try {
            use(data);
        } finally {
            rwl.readLock().unlock();
        }
    }
}
</code></pre> 
<h4 id="2%E3%80%81%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BC%93%E5%AD%98">2、应用之缓存</h4> 
<p><strong>缓存更新策略：</strong><br> 更新时，是先清缓存还是先更新数据库？<br> 先清除缓存操作如下：</p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/fe/d2/rOUPbjbi_o.png" width="1185"></p> 
<p> 先更新数据库操作如下：</p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/9b/f3/mH00VbV1_o.png" width="1200"></p> 
<p> 补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询：这种情况的出现几率非常小：</p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/a7/08/L7RXpvfl_o.png" width="1179"></p> 
<p> 实现代码如下：</p> 
<pre><code class="language-java">/**
 * ReentrantReadWriteLock 读写锁解决 缓存与数据库一致性问题
 */
public class Code_13_ReadWriteCacheTest {
    public static void main(String[] args) {

        GeneriCacheDao&lt;Object&gt; generiCacheDao = new GeneriCacheDao&lt;&gt;();

        Object[] objects = new Object[2];
        generiCacheDao.queryOne(Object.class,"Test",objects);
        generiCacheDao.queryOne(Object.class,"Test",objects);
        generiCacheDao.queryOne(Object.class,"Test",objects);
        generiCacheDao.queryOne(Object.class,"Test",objects);
        System.out.println(generiCacheDao.map);
        generiCacheDao.update("Test",objects);
        System.out.println(generiCacheDao.map);
    }

}

class GeneriCacheDao&lt;T&gt;  extends GenericDao {

    HashMap&lt;SqlPair, T&gt; map = new HashMap&lt;&gt;();
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    GenericDao genericDao = new GenericDao();

    @Override
    public int update(String sql, Object... params){
        lock.writeLock().lock();
        SqlPair sqlPair = new SqlPair(sql, params);
        try {
            // 先查询数据库再更新缓存,但是这里加了锁，谁先谁后都没关系
            int update = genericDao.update(sql, params);
            map.clear();
            return update;
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public T queryOne(Class beanClass, String sql, Object... params){
        SqlPair key = new SqlPair(sql, params);
        // 加读锁, 防止其它线程对缓存更改
        lock.readLock().lock();

        try {
            T t = map.get(key);
            if (t != null){
                return t;
            }
        } finally {
            lock.readLock().unlock();
        }

        // 加写锁, 防止其它线程对缓存读取和更改
        lock.writeLock().lock();
        // get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据
        // 为防止重复查询数据库, 再次验证
        try {
            T value = map.get(key);
            if (value == null){
                value = (T) genericDao.queryOne(beanClass, sql, params);
                map.put(key, value);
            }
            return value;
        } finally {
            lock.writeLock().unlock();
        }
    }


    class SqlPair{
        private String sql;

        private Object[] params;

        public SqlPair(String sql, Object[] params) {
            this.sql = sql;
            this.params = params;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            SqlPair sqlMap = (SqlPair) o;
            return Objects.equals(sql, sqlMap.sql) &amp;&amp;
                    Arrays.equals(params, sqlMap.params);
        }

        @Override
        public int hashCode() {
            int result = Objects.hash(sql);
            result = 31 * result + Arrays.hashCode(params);
            return result;
        }
    }
}

class GenericDao&lt;T&gt;{
    public int update(String sql, Object... params){
        return 1;
    }

    public T queryOne(Class&lt;T&gt; beanClass, String sql, Object... params){
        System.out.println("查询数据库中");
        return (T) new Object();
    }
}
</code></pre> 
<h4 id="3%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86">3、读写锁原理</h4> 
<p><strong>图解流程</strong></p> 
<p>读写锁用的是同一个 Sync 同步器，因此等待队列、state 等也是同一个<br><strong>下面执行：t1 w.lock，t2 r.lock 情况</strong></p> 
<p>1）t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/52/e8/GYybSAB3_o.png" width="785"></p> 
<p> 2）t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败。<br> tryAcquireShared 返回值表示</p> 
<ul><li>-1 表示失败</li><li>0 表示成功，但后继节点不会继续唤醒</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，我们这里的读写锁返回 1</li></ul> 
<p><img alt="" height="552" src="https://images2.imgbox.com/3f/03/pIsr1zGl_o.png" width="1200"></p> 
<p>3）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/26/13/kkz10Eky_o.png" width="1160"></p> 
<p> 4）t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁<br> 5）如果没有成功，在 doAcquireShared 内 for (;😉 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;😉 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park。</p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/a5/c3/QRA4MHOp_o.png" width="1176"></p> 
<p><strong>又继续执行</strong>：t3 r.lock，t4 w.lock<br> 这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/6d/a3/MrWP8Br3_o.png" width="1144"></p> 
<p> <strong>继续执行 t1 w.unlock</strong><br> 这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/3c/52/dBmCdGiH_o.png" width="1135"></p> 
<p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，图中的t2从黑色变成了蓝色（注意这里只是恢复运行而已，并没有获取到锁！） 这回再来一次 for (;; ) 执行 tryAcquireShared 成功则让读锁计数加一</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/78/52/rYQqFzXN_o.png" width="1155"></p> 
<p> 这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/8e/b3/Swa7Oya9_o.png" width="1164"></p> 
<p> 事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行.</p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/f7/37/82BzFPus_o.png" width="1149"></p> 
<p>这回再来一次 for (;; ) 执行 tryAcquireShared 成功则让读锁计数加一</p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/b4/15/lNfFeqzd_o.png" width="1128"> 这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/82/1a/0jgEE9DB_o.png" width="1112"></p> 
<p> 再继续执行t2 r.unlock，t3 r.unlock t2<br> 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/25/87/2Nd7oQ4r_o.png" width="1109"></p> 
<p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即 </p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/b4/f1/53LFcpUz_o.png" width="1148"></p> 
<p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;; ) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束</p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/0a/82/ci7Fuidf_o.png" width="872"></p> 
<p>源码分析：<br> 写锁上锁流程</p> 
<pre><code class="language-java">static final class NonfairSync extends Sync {
    // ... 省略无关代码

    // 外部类 WriteLock 方法, 方便阅读, 放在此处
    public void lock() {
        sync.acquire(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final void acquire(int arg) {
        if (
            // 尝试获得写锁失败
                !tryAcquire(arg) &amp;&amp;
                        // 将当前线程关联到一个 Node 对象上, 模式为独占模式
                        // 进入 AQS 队列阻塞
                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            selfInterrupt();
        }
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryAcquire(int acquires) {
        // 获得低 16 位, 代表写锁的 state 计数
        Thread current = Thread.currentThread();
        int c = getState();
        int w = exclusiveCount(c);

        if (c != 0) {
            if (
                // c != 0 and w == 0 表示有读锁返回错误，读锁不支持锁升级, 或者
                    w == 0 ||
                            // c != 0 and w == 0 表示有写，如果 exclusiveOwnerThread 不是自己
                            current != getExclusiveOwnerThread()
            ) {
                // 获得锁失败
                return false;
            }
            // 写锁计数超过低 16 位, 报异常
            if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
                throw new Error("Maximum lock count exceeded");
            // 写锁重入, 获得锁成功
            setState(c + acquires);
            return true;
        }
        if (
            // 判断写锁是否该阻塞这里返回false, 或者
                writerShouldBlock() ||
                        // 尝试更改计数失败
                        !compareAndSetState(c, c + acquires)
        ) {
            // 获得锁失败
            return false;
        }
        // 获得锁成功
        setExclusiveOwnerThread(current);
        return true;
    }

    // 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞
    final boolean writerShouldBlock() {
        return false;
    }
}
</code></pre> 
<p> 写锁释放流程：</p> 
<pre><code class="language-java">static final class NonfairSync extends Sync {
    // ... 省略无关代码

    // WriteLock 方法, 方便阅读, 放在此处
    public void unlock() {
        sync.release(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final boolean release(int arg) {
        // 尝试释放写锁成功
        if (tryRelease(arg)) {
            // unpark AQS 中等待的线程
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryRelease(int releases) {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        int nextc = getState() - releases;
        // 因为可重入的原因, 写锁计数为 0, 才算释放成功
        boolean free = exclusiveCount(nextc) == 0;
        if (free) {
            setExclusiveOwnerThread(null);
        }
        setState(nextc);
        return free;
    }
}
</code></pre> 
<p>读锁上锁流程</p> 
<pre><code class="language-java">static final class NonfairSync extends Sync {

    // ReadLock 方法, 方便阅读, 放在此处
    public void lock() {
        sync.acquireShared(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final void acquireShared(int arg) {
        // tryAcquireShared 返回负数, 表示获取读锁失败
        if (tryAcquireShared(arg) &lt; 0) {
            doAcquireShared(arg);
        }
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final int tryAcquireShared(int unused) {
        Thread current = Thread.currentThread();
        int c = getState();
        // 如果是其它线程持有写锁, 获取读锁失败
        if (
                exclusiveCount(c) != 0 &amp;&amp;
                        getExclusiveOwnerThread() != current
        ) {
            return -1;
        }
        int r = sharedCount(c);
        if (
            // 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且
                !readerShouldBlock() &amp;&amp;
                        // 小于读锁计数, 并且
                        r &lt; MAX_COUNT &amp;&amp;
                        // 尝试增加计数成功
                        compareAndSetState(c, c + SHARED_UNIT)
        ) {
            // ... 省略不重要的代码
            return 1;
        }
        return fullTryAcquireShared(current);
    }

    // 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁
    // true 则该阻塞, false 则不阻塞
    final boolean readerShouldBlock() {
        return apparentlyFirstQueuedIsExclusive();
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    // 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞
    final int fullTryAcquireShared(Thread current) {
        HoldCounter rh = null;
        for (;;) {
            int c = getState();
            if (exclusiveCount(c) != 0) {
                if (getExclusiveOwnerThread() != current)
                    return -1;
            } else if (readerShouldBlock()) {
                // ... 省略不重要的代码
            }
            if (sharedCount(c) == MAX_COUNT)
                throw new Error("Maximum lock count exceeded");
            if (compareAndSetState(c, c + SHARED_UNIT)) {
                // ... 省略不重要的代码
                return 1;
            }
        }
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    private void doAcquireShared(int arg) {
        // 将当前线程关联到一个 Node 对象上, 模式为共享模式
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    // 再一次尝试获取读锁
                    int r = tryAcquireShared(arg);
                    // 成功
                    if (r &gt;= 0) {
                        // ㈠
						// r 表示可用资源数, 在这里总是 1 允许传播
                        //（唤醒 AQS 中下一个 Share 节点）
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (
                    // 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）
                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                                // park 当前线程
                                parkAndCheckInterrupt()
                ) {
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处
    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        // 设置自己为 head
        setHead(node);

        // propagate 表示有共享资源（例如共享读锁或信号量）
        // 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE
        // 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE
        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
                (h = head) == null || h.waitStatus &lt; 0) {
            Node s = node.next;
            // 如果是最后一个节点或者是等待共享读锁的节点
            if (s == null || s.isShared()) {
                // 进入 ㈡
                doReleaseShared();
            }
        }
    }

    // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处
    private void doReleaseShared() {
        // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark
        // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析，参考这里：http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#5propagate-%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89
        for (;;) {
            Node h = head;
            // 队列还有节点
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue; // loop to recheck cases
                    // 下一个节点 unpark 如果成功获取读锁
                    // 并且下下个节点还是 shared, 继续 doReleaseShared
                    unparkSuccessor(h);
                }
                else if (ws == 0 &amp;&amp;
                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue; // loop on failed CAS
            }
            if (h == head) // loop if head changed
                break;
        }
    }
}
</code></pre> 
<p>读锁释放流程</p> 
<pre><code class="language-java">static final class NonfairSync extends Sync {

    // ReadLock 方法, 方便阅读, 放在此处
    public void unlock() {
        sync.releaseShared(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryReleaseShared(int unused) {
        // ... 省略不重要的代码
        for (;;) {
            int c = getState();
            int nextc = c - SHARED_UNIT;
            if (compareAndSetState(c, nextc)) {
                // 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程
                // 计数为 0 才是真正释放
                return nextc == 0;
            }
        }
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    private void doReleaseShared() {
        // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark
        // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE
        for (;;) {
            Node h = head;
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                // 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0
                // 防止 unparkSuccessor 被多次执行
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue; // loop to recheck cases
                    unparkSuccessor(h);
                }
                // 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析
                else if (ws == 0 &amp;&amp;
                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue; // loop on failed CAS
            }
            if (h == head) // loop if head changed
                break;
        }
    }
}
</code></pre> 
<h4 id="4%E3%80%81StampedLock">4、StampedLock</h4> 
<p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p> 
<p>加解读锁</p> 
<pre><code class="language-java">long stamp = lock.readLock();
lock.unlockRead(stamp);
</code></pre> 
<p> 加解写锁</p> 
<pre><code class="language-java">long stamp = lock.writeLock();
lock.unlockWrite(stamp);
</code></pre> 
<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p> 
<pre><code class="language-java">long stamp = lock.tryOptimisticRead();
// 验戳
if(!lock.validate(stamp)){
 // 锁升级
}
</code></pre> 
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法。<br> 代码实现：</p> 
<pre><code class="language-java">public class Code_14_StampedLockTest {

    public static void main(String[] args) throws InterruptedException {
        StampedLockDataContainer dataContainer = new StampedLockDataContainer(1);

        Thread t1 = new Thread(() -&gt; {
            try {
                System.out.println(dataContainer.read(1));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1");

        t1.start();

        TimeUnit.MILLISECONDS.sleep(500);

        Thread t2 = new Thread(() -&gt; {
//            try {
//                dataContainer.read(0);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
            dataContainer.write(10);
        }, "t2");

        t2.start();
    }

}

@Slf4j(topic = "c.StampedLockDataContainer")
class StampedLockDataContainer {

    private int data;
    private StampedLock stampedLock = new StampedLock();

    public StampedLockDataContainer(int data) {
        this.data = data;
    }

    public int read(int readTime) throws InterruptedException {
        long stamp = stampedLock.tryOptimisticRead();
        log.info("optimistic read locking ...{}", stamp);
        Thread.sleep(readTime * 1000);
        if(stampedLock.validate(stamp)) {
            log.info("read finish... {}", stamp);
            return data;
        }
        // 锁升级 - 读锁
        log.info("update to read lock ...");
        try {
            stamp = stampedLock.readLock();
            log.info("read lock {}", stamp);
            Thread.sleep(readTime * 1000);
            log.info("read finish ... {}", stamp);
            return data;
        } finally {
            stampedLock.unlockRead(stamp);
        }
    }

    public void write(int newData) {
        long stamp = stampedLock.writeLock();
        try {
            log.info("write lock {}", stamp);
            this.data = newData;
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("write finish ... {}", stamp);
            log.info("write newData ... {}", this.data);
        } finally {
            stampedLock.unlockWrite(stamp);
        }
    }

}
</code></pre> 
<p>注意：<br> StampedLock 不支持条件变量<br> StampedLock 不支持可重入</p> 
<h3 id="Semaphore"><strong>Semaphore</strong></h3> 
<h4 id="1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><a name="t17"></a><a id="1_1629"></a>1、基本使用</h4> 
<p>信号量，用来限制能同时访问共享资源的线程上限。</p> 
<pre><code class="language-java">public static void main(String[] args) {
        // 1. 创建一个对象
        Semaphore semaphore = new Semaphore(3);

        // 2. 开 10 个线程
        for(int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                // 获取一个许可
                try {
                    semaphore.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    log.info("start ...");
                    Thread.sleep(1000);
                    log.info("end ....");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            }, "t" + (i + 1)).start();;
        }

    }
</code></pre> 
<p></p> 
<h4 id="2%E3%80%81%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B">2、图解流程</h4> 
<p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一刚开始，permits（state）为 3，这时 5 个线程来获取资源。</p> 
<p><img alt="" height="563" src="https://images2.imgbox.com/83/fd/6a1rJ9O8_o.png" width="1046"></p> 
<p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p> 
<p><img alt="" height="310" src="https://images2.imgbox.com/43/4d/iEGnUVI5_o.png" width="1161"></p> 
<p> 这时 Thread-4 释放了 permits，状态如下</p> 
<p><img alt="" height="298" src="https://images2.imgbox.com/ab/73/ei1VSnYV_o.png" width="1124"></p> 
<p> 接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/d8/4b/2Wo8PIB7_o.png" width="1163"></p> 
<h4 id="3%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%C2%A0">3、源码分析 </h4> 
<pre><code class="language-java">static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -2694183684443567898L;
    NonfairSync(int permits) {
        // permits 即 state
        super(permits);
    }

    // Semaphore 方法, 方便阅读, 放在此处
    public void acquire() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) &lt; 0)
            doAcquireSharedInterruptibly(arg);
    }

    // 尝试获得共享锁
    protected int tryAcquireShared(int acquires) {
        return nonfairTryAcquireShared(acquires);
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    final int nonfairTryAcquireShared(int acquires) {
        for (;;) {
            int available = getState();
            int remaining = available - acquires;
            if (
                // 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly
                    remaining &lt; 0 ||
                            // 如果 cas 重试成功, 返回正数, 表示获取成功
                            compareAndSetState(available, remaining)
            ) {
                return remaining;
            }
        }
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    // 再次尝试获取许可
                    int r = tryAcquireShared(arg);
                    if (r &gt;= 0) {
                        // 成功后本线程出队（AQS）, 所在 Node设置为 head
                        // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark
                        // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE
					  // r 表示可用资源数, 为 0 则不会继续传播
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                // 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                        parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // Semaphore 方法, 方便阅读, 放在此处
    public void release() {
        sync.releaseShared(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryReleaseShared(int releases) {
        for (;;) {
            int current = getState();
            int next = current + releases;
            if (next &lt; current) // overflow
                throw new Error("Maximum permit count exceeded");
            if (compareAndSetState(current, next))
                return true;
        }
    }
}
</code></pre> 
<p></p> 
<h3 id="CountdownLatch">CountdownLatch</h3> 
<p>CountDownLatch 允许多线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p> 
<p>CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用 countDown方法时,其实使用了 tryReleaseShared 方法以CAS 的操作来减少 state ,直至 state 为 0 就代表所有的线程都调用了countDown方法。当调用 await 方法的时候，如果 state 不为0，就代表仍然有线程没有调用 countDown 方法，那么就把已经调用过 countDown 的线程都放入阻塞队列 Park ,并自旋 CAS 判断 state == 0，直至最后一个线程调用了 countDown ，使得 state == 0，于是阻塞的线程便判断成功，全部往下执行。</p> 
<p>用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一。<br>  </p> 
<pre><code class="language-java">@Slf4j(topic = "c.CountDownLatch")
public class Code_16_CountDownLatchTest {

    public static void main(String[] args) throws InterruptedException {
        method3();
    }

    public static void method1() throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(3);

        new Thread(() -&gt; {
            log.info("t1 start ...");

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("t1 end ...");
            countDownLatch.countDown();
        }, "t1").start();


        new Thread(() -&gt; {
            log.info("t2 start ...");

            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("t2 end ...");
            countDownLatch.countDown();
        }, "t2").start();

        new Thread(() -&gt; {
            log.info("t3 start ...");

            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("t3 end ...");
            countDownLatch.countDown();
        }, "t3").start();


        log.info("main wait ...");
        countDownLatch.await();
        log.info("main wait end ...");
    }

    public static void method2() throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(3);

        ExecutorService executorService = Executors.newFixedThreadPool(4);
        executorService.submit(() -&gt; {
            log.info("t1 start ...");

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            countDownLatch.countDown();
            log.info("t1 end ...{}", countDownLatch.getCount());
        });

        executorService.submit(() -&gt; {
            log.info("t2 start ...");

            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("t2 end ...{}", countDownLatch.getCount());
            countDownLatch.countDown();
        });

        executorService.submit(() -&gt; {
            log.info("t3 start ...");

            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("t3 end ...{}", countDownLatch.getCount());
            countDownLatch.countDown();
        });

        executorService.submit(() -&gt; {
            log.info("main wait ...");
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("main wait end ...");
            executorService.shutdown();
        });
    }

    public static void method3() throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(10);
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        String[] all = new String[10];
        Random random = new Random();
        for(int i = 0; i &lt; 10; i++) {
            int id = i;
            executorService.submit(() -&gt; {
                for (int j = 0; j &lt;= 100; j++) {
                    try {
                        Thread.sleep(random.nextInt(100));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    all[id] = j + "%";
                    System.out.print("\r" + Arrays.toString(all));
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println();
        System.out.println("游戏开始");
        executorService.shutdown();
    }

}

</code></pre> 
<h3 id="%C2%A0CyclicBarrier"> CyclicBarrier</h3> 
<p><br> CyclicBarri[ˈsaɪklɪk ˈbæriɚ]<br> 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。跟 CountdownLatch 一样，但这个可以重用。<br>  </p> 
<pre><code class="language-java">public static void main(String[] args) {

        ExecutorService executorService = Executors.newFixedThreadPool(2);
        CyclicBarrier cyclicBarrier = new CyclicBarrier(2, () -&gt; {
            log.info("task2 finish ...");
        });

        for(int i = 0; i &lt; 3; i++) {
            executorService.submit(() -&gt; {
                log.info("task1 begin ...");
                try {
                    Thread.sleep(1000);
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
            executorService.submit(() -&gt; {
                log.info("task2 begin ...");
                try {
                    Thread.sleep(2000);
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }

        executorService.shutdown();
    }
</code></pre> 
<p></p> 
<h3 id="LinkedBlockingQueue">LinkedBlockingQueue</h3> 
<h4 id="1%EF%BC%89%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"><a name="t23"></a><a id="1_1951"></a>1）入队操作</h4> 
<pre><code class="language-java">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
        implements BlockingQueue&lt;E&gt;, java.io.Serializable {
    static class Node&lt;E&gt; {
        E item;

        /**
         * One of:
         * - the real successor Node(真正的后继节点)
         * - this Node, meaning the successor is head.next(自己, 发生在出队的时候)
         * - null, meaning there is no successor (this is the last node)(null, 表示没有后继节点, 是最后了)
         */
        Node&lt;E&gt; next;

        Node(E x) { item = x; }
    }
</code></pre> 
<p>初始化链表 last = head = new Node(null); Dummy 节点用来占位，item 为 null。</p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/af/ec/Jw3IhkCe_o.png" width="1170"></p> 
<p>当一个节点入队 last = last.next = node; </p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/d3/94/NWDaQQU7_o.png" width="1182"></p> 
<p>再来一个节点入队 last = last.next = node; </p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/a7/4c/h4kXZgi7_o.png" width="749"></p> 
<p>2）出队操作</p> 
<pre><code class="language-java">	 private E dequeue() {
	       // assert takeLock.isHeldByCurrentThread();
	       // assert head.item == null;
	       Node&lt;E&gt; h = head;
	       Node&lt;E&gt; first = h.next;
	       h.next = h; // help GC
	       head = first;
	       E x = first.item;
	       first.item = null;
	       return x;
	   }
</code></pre> 
<p> h = head;</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/22/84/rYR8HyGB_o.png" width="755"></p> 
<p> first = h.next;</p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/66/5a/f33BffMR_o.png" width="750"></p> 
<p> h.next = h;</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/b0/6d/zpP6Uf6R_o.png" width="758"></p> 
<p> head = first;</p> 
<p><img alt="" height="291" src="https://images2.imgbox.com/b3/9c/RsjNTNAt_o.png" width="712"></p> 
<h4 id="3%EF%BC%89%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90">3）加锁分析</h4> 
<p>高明之处在于用了两把锁和 dummy 节点</p> 
<ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行 
  <ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul> 
<p>线程安全分析</p> 
<ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul> 
<pre><code class="language-java">// 用于 put(阻塞) offer(非阻塞)
private final ReentrantLock putLock = new ReentrantLock();
// 用户 take(阻塞) poll(非阻塞)
private final ReentrantLock takeLock = new ReentrantLock();
</code></pre> 
<h4 id="4%EF%BC%89put%20%E6%93%8D%E4%BD%9C">4）put 操作</h4> 
<pre><code class="language-java">public void put(E e) throws InterruptedException {
	if (e == null) throw new NullPointerException();
	int c = -1;
	Node&lt;E&gt; node = new Node&lt;E&gt;(e);
	final ReentrantLock putLock = this.putLock;
	// count 用来维护元素计数
	final AtomicInteger count = this.count;
	putLock.lockInterruptibly();
	try {
		// 满了等待
		while (count.get() == capacity) {
		// 倒过来读就好: 等待 notFull
		notFull.await();
	}
	// 有空位, 入队且计数加一
	enqueue(node);
	c = count.getAndIncrement(); 
	// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程
	if (c + 1 &lt; capacity)
		notFull.signal();
	} finally {
		putLock.unlock();
	}
	// 如果队列中有一个元素, 叫醒 take 线程
	if (c == 0)
	// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争
	signalNotEmpty();
}
</code></pre> 
<h4 id="5%EF%BC%89take%20%E6%93%8D%E4%BD%9C">5）take 操作</h4> 
<pre><code class="language-java">public E take() throws InterruptedException {
	E x;
	int c = -1;
	final AtomicInteger count = this.count;
	final ReentrantLock takeLock = this.takeLock;
	takeLock.lockInterruptibly();
	try {
		while (count.get() == 0) {
		notEmpty.await();
	}
	x = dequeue();
	c = count.getAndDecrement();
	if (c &gt; 1)
		notEmpty.signal();
	} finally {
		takeLock.unlock();
	}
	// 如果队列中只有一个空位时, 叫醒 put 线程
	// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity
	if (c == capacity)
	// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争
	signalNotFull()
	return x; 
 }
</code></pre> 
<p>注意：由 put 唤醒 put 是为了避免信号不足</p> 
<h4 id="6%EF%BC%89%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83">6）性能比较</h4> 
<p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p> 
<ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁<br>  </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd313c03b79af107c0b95fb5c2d76aa7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter 中，ListView 中需要放置 ListView 需要怎么处理才高效？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2584b339a549fd08e8c8eb04d737846/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Kafka】1.Kafka简介及安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>