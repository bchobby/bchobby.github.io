<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM成神之路-Java垃圾回收 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM成神之路-Java垃圾回收" />
<meta property="og:description" content="Java垃圾回收机制 为什么要进行垃圾回收？ 随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多，如果不及时进行垃圾回收，必然会带来程序性能的下降，甚至会因为可用内存不足造成一些不必要的系统异常。
哪些“垃圾”需要回收？ 如果某个对象已经不存在任何引用，那么它可以被回收。
什么时候进行垃圾回收？ 引用计数算法 每个对象添加一个引用计数器，每被引用一次，计数器加1，失去引用，计数器减1，当计数器在一段时间内保持为0时，该对象就认为是可以被回收得了。（在JDK1.2之前，使用的是该算法）
缺点：当两个对象A、B相互引用的时候，当其他所有的引用都消失之后，A和B还有一个相互引用，此时计数器各为1，而实际上这两个对象都已经没有额外的引用了，已经是垃圾了。但是却不会被回收
可达性分析算法 该算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点
目前java 中可作为GC Root 的对象有：
虚拟机栈中引用的对象（本地变量表）方法区中静态属性引用的对象方法区中常量引用的对象本地方法栈中引用的对象（Native Object） 引用的分类 JDK 1.2之后，对引用进行了扩充，引入了强、软、若、虚四种引用，被标记为这四种引用的对象，在GC时分别有不同的意义：
强引用(Strong Reference) 就是为刚被new出来的对象所加的引用，它的特点就是，永远不会被GC，除非显示的设置null，才会GC。代码如下：
Object ojb = new Object();
软引用(Soft Reference) 非必须引用，内存溢出之前进行回收。如果JVM内存并不紧张，这类对象可以不被回收，如果内存紧张，则会被回收。此处有一个问题，既然被引用为软引用的对象可以回收，为什么不去回收呢？其实我们知道，Java中是存在缓存机制的，就拿字面量缓存来说，有些时候，缓存的对象就是当前可有可无的，只是留在内存中如果还有需要，则不需要重新分配内存即可使用，因此，这些对象即可被引用为软引用，方便使用，提高程序性能。代码如下：
Object obj = new Object();
SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj =null;
sf.get();//有时候会返回null
这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
弱引用(Weak Reference) 第二次垃圾回收时回收。代码如下：
Object obj = new Object();
WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);
obj =null;
wf.get();//有时候会返回null
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器
虚引用(Phantom Reference) 垃圾回收时回收，无法通过引用取到对象值。代码如下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/41eb6cd7fbc377d3bb2a8d8f9daac3c8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-02T15:37:53+08:00" />
<meta property="article:modified_time" content="2018-08-02T15:37:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM成神之路-Java垃圾回收</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;"><strong>Java垃圾回收机制</strong></h2> 
<h3 style="margin-left:0cm;"><strong>为什么要进行垃圾回收？</strong></h3> 
<p style="margin-left:0cm;">随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多，如果不及时进行垃圾回收，必然会带来程序性能的下降，甚至会因为可用内存不足造成一些不必要的系统异常。</p> 
<h3 style="margin-left:0cm;"><strong>哪些“垃圾”需要回收？</strong></h3> 
<p style="margin-left:0cm;">如果某个对象已经不存在任何引用，那么它可以被回收。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="463" src="https://images2.imgbox.com/44/15/ToOX8WIn_o.png" width="554"></p> 
<h3 style="margin-left:0cm;"><strong>什么时候进行垃圾回收？</strong></h3> 
<ul><li>引用计数算法</li></ul> 
<p style="margin-left:0cm;">每个对象添加一个引用计数器，每被引用一次，计数器加1，失去引用，计数器减1，当计数器在一段时间内保持为0时，该对象就认为是可以被回收得了。（在JDK1.2之前，使用的是该算法）</p> 
<p style="margin-left:0cm;">缺点：当两个对象A、B相互引用的时候，当其他所有的引用都消失之后，A和B还有一个相互引用，此时计数器各为1，而实际上这两个对象都已经没有额外的引用了，已经是垃圾了。但是却不会被回收</p> 
<ul><li>可达性分析算法</li></ul> 
<p style="margin-left:0cm;">该算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点<br><img alt="" class="has" height="325" src="https://images2.imgbox.com/7d/f4/xwxUP8GQ_o.png" width="637"><br> 目前java 中可作为GC Root 的对象有：</p> 
<ol><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native Object）</li></ol> 
<h3 style="margin-left:0cm;"><strong>引用的分类</strong></h3> 
<p style="margin-left:0cm;">JDK 1.2之后，对引用进行了扩充，引入了强、软、若、虚四种引用，被标记为这四种引用的对象，在GC时分别有不同的意义：</p> 
<ul><li>强引用(Strong Reference)</li></ul> 
<p style="margin-left:0cm;">就是为刚被new出来的对象所加的引用，它的特点就是，永远不会被GC，除非显示的设置null，才会GC。代码如下：</p> 
<p style="margin-left:0cm;">Object ojb = new Object();</p> 
<ul><li>软引用(Soft Reference)</li></ul> 
<p style="margin-left:0cm;">非必须引用，内存溢出之前进行回收。如果JVM内存并不紧张，这类对象可以不被回收，如果内存紧张，则会被回收。此处有一个问题，既然被引用为软引用的对象可以回收，为什么不去回收呢？其实我们知道，Java中是存在缓存机制的，就拿字面量缓存来说，有些时候，缓存的对象就是当前可有可无的，只是留在内存中如果还有需要，则不需要重新分配内存即可使用，因此，这些对象即可被引用为软引用，方便使用，提高程序性能。代码如下：</p> 
<p style="margin-left:0cm;">Object obj = new Object();</p> 
<p style="margin-left:0cm;">SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);</p> 
<p style="margin-left:0cm;">obj =null;</p> 
<p style="margin-left:0cm;">sf.get();//有时候会返回null</p> 
<p style="margin-left:0cm;">这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；</p> 
<ul><li>弱引用(Weak Reference)</li></ul> 
<p style="margin-left:0cm;">第二次垃圾回收时回收。代码如下：</p> 
<p style="margin-left:0cm;">Object obj = new Object();</p> 
<p style="margin-left:0cm;">WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);</p> 
<p style="margin-left:0cm;">obj =null;</p> 
<p style="margin-left:0cm;">wf.get();//有时候会返回null</p> 
<p style="margin-left:0cm;">wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾</p> 
<p style="margin-left:0cm;">弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。<br> 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器</p> 
<ul><li>虚引用(Phantom Reference)</li></ul> 
<p style="margin-left:0cm;">垃圾回收时回收，无法通过引用取到对象值。代码如下</p> 
<p style="margin-left:0cm;">Object obj = new Object();</p> 
<p style="margin-left:0cm;">PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);</p> 
<p style="margin-left:0cm;">obj=null;</p> 
<p style="margin-left:0cm;">pf.get();//永远返回null</p> 
<p style="margin-left:0cm;">pf.isEnQueued();//返回从内存中已经删除</p> 
<p style="margin-left:0cm;">虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。</p> 
<p style="margin-left:0cm;">扩展：如果一个对象的引用有多个，怎么通过可达性确定回收周期呢？两个原则：</p> 
<ul><li>单条引用链上，由最弱的一个引用类型决定</li><li>多条引用链上，由最强的一个引用类型决定<br> 这个想想其实还是很好理解的。</li></ul> 
<h3 style="margin-left:0cm;"><strong>如何垃圾回收</strong></h3> 
<p style="margin-left:0cm;">内存主要被分为三块，新生代、旧生代、持久代。三代的特点不同，造就了他们所用的GC算法不同，新生代适合那些生命周期较短，频繁创建及销毁的对象，旧生代适合生命周期相对较长的对象，持久代在Sun HotSpot中就是指方法区（有些JVM中根本就没有持久代这中说法）。首先介绍下新生代、旧生代、持久代的概念及特点：</p> 
<p style="margin-left:0cm;"><img alt="https://img-my.csdn.net/uploads/201211/24/1353728416_1655.jpg" class="has" height="283" src="https://images2.imgbox.com/9d/a0/CMCTXDP4_o.jpg" width="515"></p> 
<p style="margin-left:0cm;">新生代：New Generation或者Young Generation。上面大致分为Eden区和Survivor区，Survivor区又分为大小相同的两部分：FromSpace 和ToSpace。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代的大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例.<br> 旧生代：Old Generation。用于存放新生代中经过多次垃圾回收仍然存活的对象，例如缓存对象。旧生代占用大小为-Xmx值减去-Xmn对应的值。</p> 
<p style="margin-left:0cm;">持久代：Permanent Generation。在Sun的JVM中就是方法区的意思，尽管有些JVM大多没有这一代。主要存放常量及类的一些信息默认最小值为16MB，最大值为64MB，可通过-XX:PermSize及-XX:MaxPermSize来设置最小值和最大值。</p> 
<h4 style="margin-left:0cm;"><strong><strong><span style="color:#000000;">常见的</span></strong><strong><span style="color:#000000;">GC</span></strong><strong><span style="color:#000000;">算法：</span></strong></strong></h4> 
<h2 style="margin-left:0cm;"><strong>标记-清除算法（Mark-Sweep）</strong></h2> 
<p style="margin-left:0cm;">就是分为标记和清除两个阶段进行处理内存中的对象</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="297" src="https://images2.imgbox.com/08/6e/1DzzCVe1_o.png" width="437"></p> 
<p style="margin-left:0cm;">缺点：</p> 
<ol><li>效率问题，标记和清除两个过程的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol> 
<h2 id="复制算法（Copying）" style="margin-left:0cm;"><strong>复制算法（Copying）</strong></h2> 
<ol><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</li><li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。反复去交换两个内存的角色，完成垃圾收集</li></ol> 
<p style="margin-left:0cm;">java中新生代的from和to空间就是使用这个算法</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="306" src="https://images2.imgbox.com/f2/f5/u0MXr6p1_o.png" width="430"></p> 
<p style="margin-left:0cm;">优点：这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等。复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。<br> 缺点：复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低（所以eden区没有采用这个算法）</p> 
<h2 id="标记-整理算法（标记-压缩法）（Mark-Compact）" style="margin-left:0cm;"><strong>标记-整理算法（标记-压缩法）（Mark-Compact）</strong></h2> 
<p style="margin-left:0cm;">是在标记清除法基础上做了优化，把存活的对象压缩到内存一端，然后直接清理掉端边界以外的内存（老年代使用的就是标记压缩法）</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="296" src="https://images2.imgbox.com/16/cb/YyTAiFew_o.png" width="414"></p> 
<h2 style="margin-left:0cm;"><strong>分代收集算法（Generational Collection）</strong></h2> 
<p style="margin-left:0cm;">1、根据对象存活周期的不同将内存划分为几块。<br> 2、一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br> 3、在新生代中，每次垃圾收集时都发现有大批对象死去（回收频率很高），只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p> 
<p style="margin-left:0cm;">其中，新生代又细分为三个区：Eden,From Survivor,ToSurviver,比例是8：1：1</p> 
<p style="margin-left:0cm;">4、老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p> 
<h2 id="分区算法" style="margin-left:0cm;"><strong>分区算法</strong></h2> 
<p style="margin-left:0cm;">其主要就是将整个内存分为N个多小的独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收都少个小空间和那些个小空间，而不是对整个空间进行GC，从而提升性能，并减少GC的停顿时间。</p> 
<h2 style="margin-left:0cm;"><strong>GC算法优劣标准</strong></h2> 
<p style="margin-left:0cm;">评价一个垃圾收集GC算法的两个标准</p> 
<ol><li>吞吐量（throughput）越高算法越好</li><li>暂停时间（pause times）越短算法越好</li></ol> 
<h3 id="吞吐量" style="margin-left:0cm;"><strong>吞吐量</strong></h3> 
<p style="margin-left:0cm;">JVM在专门的线程[GC Threads]中执行GC 只要GC线程是活动的 就会和应用程序线程[Application Threads]争用当前可用CPU的时钟周期而吞吐量就是指应用程序线程占程序总用时的比例</p> 
<h3 id="停顿" style="margin-left:0cm;"><strong>停顿</strong></h3> 
<p style="margin-left:0cm;">一个时间段内应用程序线程让GC线程执行而完全暂停。</p> 
<p style="margin-left:0cm;">垃圾回收器的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以高效的执行，大部分情况下，会要求系统进入一个停顿的状态。停顿的目的是终止所有应用线程，只有这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一个瞬间的一致性，也有益于更好地标记垃圾对象，因此垃圾回收时，都会产生应用程序的停顿</p> 
<h3 style="margin-left:0cm;"><strong>垃圾收集器</strong></h3> 
<h4 style="margin-left:0cm;"><strong>前言</strong></h4> 
<p style="margin-left:0cm;">HotSpot JVM收集器<br><img alt="" class="has" height="370" src="https://images2.imgbox.com/43/7e/TPBMFA89_o.png" width="545"><br> 上面有7中收集器，分为两块，上面为新生代收集器，下面是老年代收集器。如果两个收集器之间存在连线，就说明它们可以搭配使用。</p> 
<h2 id="串行收集器" style="margin-left:0cm;"><strong>串行收集器</strong></h2> 
<h3 id="概念" style="margin-left:0cm;"><strong>概念</strong></h3> 
<p style="margin-left:0cm;">使用单线程进行垃圾回收的收集器，每次回收时，串行收集器只有一个工作线程，对于并行能力较弱的计算机来说，串行收集器的专注性和独占性往往有更好的性能表现。串行收集器可以在新生代和老年代中使用，根据作用于不同的堆空间，分为新生代串行收集器和老年代收集器。</p> 
<p style="margin-left:0cm;"><code>-XX:+UseSerialGC</code> :年轻串行（Serial），老年串行（Serial Old）</p> 
<h3 id="Serial收集器：" style="margin-left:0cm;"><strong>Serial收集器：</strong></h3> 
<p style="margin-left:0cm;">Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。<br><img alt="" class="has" height="184" src="https://images2.imgbox.com/81/8a/6XlgV671_o.png" width="595"></p> 
<h3 style="margin-left:0cm;"><strong>Serial Old收集器</strong></h3> 
<p style="margin-left:0cm;">1、Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。<br> 2、主要意义也是在于给Client模式下的虚拟机使用。<br> 3、如果在Server模式下，那么它主要还有两大用途：<br> 一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，<br> 另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。<br><img alt="" class="has" height="187" src="https://images2.imgbox.com/03/d9/SqsyvHv2_o.png" width="656"></p> 
<h2 id="并行收集器" style="margin-left:0cm;"><strong>并行收集器</strong></h2> 
<h3 style="margin-left:0cm;"><strong>概念</strong></h3> 
<h3 id="ParNew收集器" style="margin-left:0cm;"><strong>ParNew收集器</strong></h3> 
<p style="margin-left:0cm;">1、Serial收集器的多线程版本<br> 2、单CPU不如Serial，因为存在线程交互的开销</p> 
<p style="margin-left:0cm;"><code>-XX:+UseParNewGC</code> 新生代并行（ParNew），老年代串行（Serial Old）</p> 
<p style="margin-left:0cm;"><code>-XX:ParallelGCThreads=n</code> 设置并行收集器收集时使用的CPU数。并行收集线程数。一般最好和计算机的CPU相当</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="167" src="https://images2.imgbox.com/9a/31/WWu8Sy9t_o.png" width="562"></p> 
<h3 style="margin-left:0cm;"><strong>Parallel Scavenge收集器</strong></h3> 
<p style="margin-left:0cm;"><code>-XX:+UseParallelGC</code> 新生代使用并行回收收集器，老年代使用串行收集器</p> 
<p style="margin-left:0cm;">1、吞吐量优先”收集器<br> 2、新生代收集器，复制算法，并行的多线程收集器<br> 3、目标是达到一个可控制的吞吐量（Throughput）。<br> 4、吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。<br> 5、两个参数用于精确控制吞吐量:<br><code>-XX</code><code>：MaxGCPauseMillis</code> 是控制最大垃圾收集停顿时间</p> 
<p style="margin-left:0cm;"><code>-XX</code><code>：GCTimeRatio</code> 直接设置吞吐量大小</p> 
<p style="margin-left:0cm;"><code>-XX</code><code>：+UseAdaptiveSizePolicy</code> 动态设置新生代大小、Eden与Survivor区的比例、晋升老年代对象年龄</p> 
<p style="margin-left:0cm;">6、并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br> 7、并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p> 
<h3 style="margin-left:0cm;"><strong>Parallel Old收集器</strong></h3> 
<p style="margin-left:0cm;"><code>-XX:+UseParallelOldGC</code> 新生代和老年代都使用并行回收收集器</p> 
<p style="margin-left:0cm;">1、Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。<br> 2、在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。<br><img alt="" class="has" height="169" src="https://images2.imgbox.com/01/8d/Imi2o4XP_o.png" width="578"></p> 
<h2 id="CMS收集器" style="margin-left:0cm;"><strong>CMS收集器</strong></h2> 
<p style="margin-left:0cm;">1、以获取最短回收停顿时间为目标的收集器。<br> 2、非常符合互联网站或者B/S系统的服务端上，重视服务的响应速度，希望系统停顿时间最短的应用<br> 3、基于“标记—清除”算法实现的<br> 4、CMS收集器的内存回收过程是与用户线程一起并发执行的<br> 5、它的运作过程分为4个步骤，包括：</p> 
<ol><li>初始标记，“Stop The World”，只是标记一下GC Roots能直接关联到的对象，速度很快</li><li>并发标记，并发标记阶段就是进行GC RootsTracing的过程</li><li>重新标记，Stop The World”，是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，但远比并发标记的时间短</li><li>并发清除（CMS concurrent sweep）</li></ol> 
<p style="margin-left:0cm;">6、优点：并发收集、低停顿<br> 7、缺点：</p> 
<ol><li>对CPU资源非常敏感。</li><li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</li><li>一款基于“标记—清除”算法实现的收集器</li></ol> 
<p style="margin-left:0cm;"><code>-XX:+UseConcMarkSweepGC</code> 应用CMS收集器</p> 
<p style="margin-left:0cm;"><code>-XX:ConcGCThreads</code> 设置并发线程数量</p> 
<p style="margin-left:0cm;"><code>-XX:CMSInitiatingOccupancyFraction</code> 设置当老年代空间实用率达到百分比值时进行一次cms回收,默认为68，当老年代的空间使用率达到68%的时候，会执行CMS回收</p> 
<p style="margin-left:0cm;">如果内存使用率增长的很快，在CMS执行的过程中，已经出现了内存不足的情况，此时CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这回导致应用程序中断，直到垃圾回收完成后才会正常工作，这个过程GC的停顿时间可能较长，所以该值需要根据实际情况设置。</p> 
<p style="margin-left:0cm;"><code>-XX:+UseCMSCompactAtFullCollection</code> 设置cms在垃圾收集完成后进行一次内存碎片整理</p> 
<p style="margin-left:0cm;"><code>-XX:CMSFullGCsBeforeCompaction</code> 设定进行多少次cms回收后，进行一次内存压缩。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="168" src="https://images2.imgbox.com/a7/61/62n5RFj8_o.png" width="582"></p> 
<h2 id="G1（Garbage-First）收集器" style="margin-left:0cm;"><strong>G1（Garbage-First）收集器</strong></h2> 
<p style="margin-left:0cm;">1、当今收集器技术发展的最前沿成果之一<br> 2、G1是一款面向服务端应用的垃圾收集器。<br> 3、优点：</p> 
<ol><li>并行与并发：充分利用多CPU、多核环境下的硬件优势</li><li>分代收集：不需要其他收集器配合就能独立管理整个GC堆</li><li>空间整合：“标记—整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片</li><li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li></ol> 
<p style="margin-left:0cm;">4、G1收集器的运作大致可划分为以下几个步骤：</p> 
<ol><li>初始标记：标记一下GC Roots能直接关联到的对象，需要停顿线程，但耗时很短</li><li>并发标记：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行</li><li>最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</li><li>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划</li></ol> 
<p style="margin-left:0cm;"><code>-XX:+UserG1Gc</code> 应用G1收集器</p> 
<p style="margin-left:0cm;"><code>-XX:MaxGCPauseMillis</code> 指定最大停顿时间</p> 
<p style="margin-left:0cm;"><code>-XX:ParallelGCThreads</code> 设置并行回收的线程数量</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="152" src="https://images2.imgbox.com/a6/15/s8HGueOn_o.png" width="542"></p> 
<h2 id="总结" style="margin-left:0cm;"><strong>总结</strong></h2> 
<p style="margin-left:0cm;">在众多的垃圾回收器中，没有最好的，只有最适合应用的回收器，根据应用软件的特性以及硬件平台的特点，选择不同的垃圾回收器，才能有效的提高系统性能。</p> 
<h3 style="margin-left:0cm;"><strong>Minor GC 和 Full GC 有什么区别？</strong></h3> 
<p style="margin-left:0cm;">新生代 GC （Minor GC） ：发生在新生代的垃圾收集动作。Minor GC 非常频繁，回收速度比较快。</p> 
<p style="margin-left:0cm;">老年代 GC （Major GC/Full GC）：发生在老年代的 GC， Major GC 一般比 Minor GC 慢 10 倍以上。</p> 
<h4 style="margin-left:0cm;"><strong>内存分配规则</strong></h4> 
<p style="margin-left:0cm;"><strong>对象优先在 Eden 分配</strong></p> 
<p style="margin-left:0cm;">大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起 Minor GC。</p> 
<p style="margin-left:0cm;"><strong>大对象直接进入老年代</strong></p> 
<p style="margin-left:0cm;"><strong>长期存活的对象将进入老年代</strong></p> 
<p style="margin-left:0cm;">虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生在 Survivor 区中每熬过一次 Minor GC，年龄加 1 岁，当年龄到一定程度（默认15岁），就会晋升到老年代中。</p> 
<p style="margin-left:0cm;"><strong>动态对象年龄判定</strong></p> 
<p style="margin-left:0cm;">在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p> 
<p style="margin-left:0cm;"><strong>空间分配担保</strong></p> 
<p style="margin-left:0cm;">在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的<strong>连续空间</strong>是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可能连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这个 Minor GC 是有风险的；如果小于，或 HandlePromotionFailure 设置不允许冒险，那这次也要改为进行一次 Full GC。</p> 
<p style="margin-left:0cm;"><strong><span style="color:#000099;">优秀的编程习惯</span></strong></p> 
<p style="margin-left:0cm;">（1）避免在循环体中创建对象，即使该对象占用内存空间不大。<br> （2）尽量及时使对象符合垃圾回收标准。<br> （3）不要采用过深的继承层次。<br> （4）访问本地变量优于访问类中的变量。</p> 
<h2 style="margin-left:0cm;"><strong>XX参数语法</strong></h2> 
<p style="margin-left:0cm;">所有的XX参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型。</p> 
<p style="margin-left:0cm;">对于布尔类型的参数，我们有”+”或”-“，然后才设置JVM选项的实际名称。例如，<code>-XX:+&lt;name&gt;</code>用于激活<code>&lt;name&gt;</code>选项，而<code>-XX:-&lt;name&gt;</code>用于注销选项。</p> 
<p style="margin-left:0cm;">对于需要非布尔值的参数，如string或者integer，我们先写参数的名称，后面加上”=”，最后赋值。例如， <code>-XX:&lt;name&gt;=&lt;value&gt;</code>给<code>&lt;name&gt;</code>赋值<code>&lt;value&gt;</code>。</p> 
<h2 id="垃圾回收统计信息" style="margin-left:0cm;"><strong>垃圾回收统计信息</strong></h2> 
<p style="margin-left:0cm;"><code>-XX:+PrintGC</code>虚拟机启动后，只要遇到GC就会打印日志</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintGCDetails</code> 查看详细信息，包括各个区的情况</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintGCTimeStamps</code> 可以将时间和日期也加到GC日志中。表示自JVM启动至今的时间戳</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintGCApplicationStoppedTime</code> 打印垃圾回收期间程序暂停的时间.可与上面混合使用</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintGCDateStamps</code> 每一行就添加上了绝对的日期和时间。（以日期的形式，如 2013-05-04T21:53:59.234+0800）</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</p> 
<p style="margin-left:0cm;"><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintTLAB</code> 查看TLAB空间的使用情况</p> 
<h2 id="JVM参数" style="margin-left:0cm;"><strong>JVM参数</strong></h2> 
<h3 id="堆参数" style="margin-left:0cm;"><strong>堆参数</strong></h3> 
<p style="margin-left:0cm;"><code>-Xms20M</code>，-XX:InitialHeapSize简写 表示设置堆容量的最小值为20M，必须以M为单位</p> 
<p style="margin-left:0cm;"><code>-Xmx20M</code> -XX:MaxHeapSize简写，表示设置堆容量的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免堆自动扩展，减少程序运行时的垃圾回收次数，从而提供性能。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高</p> 
<p style="margin-left:0cm;">所有JVM关于初始\最大堆内存大小的输出都是使用它们的完整名称：“InitialHeapSize”和“InitialHeapSize”。所以当你查询一个正在运行的JVM的堆内存大小时，如使用-XX:+PrintCommandLineFlags参数或者通过JMX查询，应该寻找“InitialHeapSize”和“InitialHeapSize”标志而不是“Xms”和“Xmx”</p> 
<p style="margin-left:0cm;">稳定的堆大小能减少gc次数，但是每次gc时间增加<br> 震荡的堆大小能增加gc次数，但是每次gc时间减少<br><code>-XX:MinHeapFreeRatio</code> 最小空闲比例，当堆空间空闲内存小于这个比例，则扩展<br><code>-XX:ManHeapFreeRatio</code> 最大空闲比例，当堆空间空闲内存大于这个比例，则压缩<br> -Xms和-Xmx相等时，上面的参数失效</p> 
<p style="margin-left:0cm;"><code>-XX:+HeapDumpOnOutOfMemoryError</code> 使得JVM在产生内存溢出时自动生成堆内存快照</p> 
<p style="margin-left:0cm;"><code>-XX:HeapDumpPath=&lt;path&gt;</code> 改变默认的堆内存快照生成路径，可以是相对或者绝对路径</p> 
<p style="margin-left:0cm;"><code>-XX:OnOutOfMemoryError</code> 当内存发生溢出时 执行一串指令-XX:OnOutOfMemoryError ="sh ~/cleanup.sh"</p> 
<p style="margin-left:0cm;"><code>-XX:PermSize</code> 设置永久代的初始大小</p> 
<p style="margin-left:0cm;"><code>-XX:MaxPermSize</code> 设置永久代的最大大小</p> 
<p style="margin-left:0cm;"><code>-Xmn</code> 或 <code>-XX:NewSize</code> 设置新生代的初始大小</p> 
<p style="margin-left:0cm;">新生代只是堆的一部分 新生代越大老年代越小，一般不允许新生代比老生代还大。考虑到GC最坏的情况 新生代全部复制到老生代会产生OOM错误，这个参数对系统性能以及GC行为有很大影响，新生代大小一般会设置整个堆空间的1/3到1/4左右</p> 
<p style="margin-left:0cm;"><code>-XX:NewRatio</code> 设置新生代和老生代的相对大小。优点是新生代大小会随着整个堆大小动态扩展</p> 
<p style="margin-left:0cm;">不同的堆分布情况对系统执行都会产生不一样的影响，实际配置的基本策略就是尽可能将对象预留在新生代，减少老年代的GC次数。</p> 
<p style="margin-left:0cm;"><code>-XX:SurvivorRatio</code> 设置新生代中eden空间和from/to空间的比例，eden/to=eden/from</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintTenuringDistribution</code> 指定JVM在每次新生代GC时 输出Survivor中对象的年龄分布</p> 
<p style="margin-left:0cm;"><code>-XX:InitialTenuringThreshold</code> 设置老年代阈值的初始值</p> 
<p style="margin-left:0cm;"><code>-XX:MaxTenuringThreshold</code> 设置新生代阈值的最大值（垃圾最大年龄），默认为15。如果设置为0的话，则新生代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则新生代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在新生代即被回收的概念。<br> 另外，大对象（新生代eden区无法装入时，也会直接进入老年代）。</p> 
<p style="margin-left:0cm;"><code>-XX:PretenureSizeThreshold</code> 设置对象的大小超过指定的大小后，直接进入老年代，但是要注意TLAB区域优先分配空间的原则</p> 
<p style="margin-left:0cm;">TLAB 全称Thread Local Allocation Buffer，即线程本地分配缓存，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的。每一个线程都会产生一个TLAB，该线程独享的工作区域，java虚拟机使用这种TLAB区来避免多线程冲突问题，提高了对象分配的效率。TLAB空间一般不会太大，当大对象无法在TLAB分配时，则会直接分配到堆上。</p> 
<p style="margin-left:0cm;"><code>-XX:+NeverTenure</code> 对象永远不会晋升到老年代（当不需要老生代的时候可以这样设置）</p> 
<p style="margin-left:0cm;"><code>-XX:+AlwaysTenure</code> 表示没有Survivor区 对象会直接被移动到老年代中</p> 
<h4 id="TLAB" style="margin-left:0cm;"><strong>TLAB</strong></h4> 
<p style="margin-left:0cm;"><code>-XX:+UserTLAB</code> 使用TLAB</p> 
<p style="margin-left:0cm;"><code>-XX:+TLABSize</code> 设置TLAB大小</p> 
<p style="margin-left:0cm;"><code>-XX:+TLABRefllWasteFraction</code> 设置维护进入TLAB空间的单个对象大小，他是一个比例值，默认为64，即如果对象大于整个空间的1/64，则在堆中创建对象。</p> 
<p style="margin-left:0cm;"><code>-XX:+PrintTLAB</code> 查看TLAB信息</p> 
<p style="margin-left:0cm;"><code>-XX:+ResizeTLAB</code> 自调整TLABRefllWasteFraction阀值</p> 
<p style="margin-left:0cm;"><code>-XX:TLABWasteTargetPercent</code> TLAB占eden区的百分比</p> 
<h3 id="栈参数" style="margin-left:0cm;"><strong>栈参数</strong></h3> 
<p style="margin-left:0cm;"><code>-Xss5m</code> 指定线程的最大栈空间，整个参数也直接决定了函数可调用的最大深度</p> 
<h3 id="方法区参数" style="margin-left:0cm;"><strong>方法区参数</strong></h3> 
<p style="margin-left:0cm;"><code>-XX:PermSize=10M</code> 表示JVM初始分配的永久代的容量，必须以M为单位</p> 
<p style="margin-left:0cm;"><code>-XX:MaxPermSize=10M</code> 表示JVM允许分配的永久代的最大容量，必须以M为单位，大部分情况下这个参数默认为64M</p> 
<p style="margin-left:0cm;">方法区，又称永久区，默认情况下-XX:PermSize=64M，如果系统运行时生产大量的类，就需要设置一个相对合适的方法区，以免出现永久区内存溢出的问题</p> 
<h3 id="直接内存参数" style="margin-left:0cm;"><strong>直接内存参数</strong></h3> 
<p style="margin-left:0cm;"><code>-XX:MaxDirectMemorySize=128m</code> 直接内存最大容量，M单位，默认为64M</p> 
<p style="margin-left:0cm;">如果不设置默认值为最大堆空间，即-Xmx。直接内存使用达到上限时，就会触发垃圾回收，如果不能有效的释放空间，也会引起系统的OOM</p> 
<h3 id="其他" style="margin-left:0cm;"><strong>其他</strong></h3> 
<p style="margin-left:0cm;"><code>-XX:+UseFastAccessorMethods</code> 原始类型的快速优化</p> 
<p style="margin-left:0cm;"><code>-XX:+DisableExplicitGC</code> 关闭System.gc()</p> 
<p style="margin-left:0cm;"><code>-XX:+AggressiveOpts</code> 加快编译</p> 
<p style="margin-left:0cm;"><code>-XX:+UseBiasedLocking</code> 锁机制的性能改善</p> 
<p style="margin-left:0cm;"><code>-Xnoclassgc</code> 禁用垃圾回收</p> 
<h3 id="Client和Server虚拟工作模式" style="margin-left:0cm;"><strong>Client和Server虚拟工作模式</strong></h3> 
<p style="margin-left:0cm;">目前Java虚拟机支持Client和Server两种运行模式，使用参数-client可以指定使用Client模式，使用-server即使用Server模式，可以直接在命令行查看当前计算机系统自动选择的运行模式。java -version<br> 二者区别：Client模式相对Server启动较快，如果不追究系统的长时间使用性能仅仅是测试，可以使用Client模式，而Server模式则启动较慢，原因是会对其进行复杂的系统性能信息收集和使用更复杂的算法对程序进行优化，一般我们的生产环境都会使用Server模式，长期运行其性能要远远快于Client模式<br> Server：默认为堆提供了一个更大的空间和并行的垃圾收集器 并且在运行时可以更大程度的优化代码<br> Client：客户端虚拟机有较小的默认堆内存 可以缩短JVM启动的时间和占用更少的内存 客户端的JVM只有在32位操作系统中才有<br> JDK1.7之后就不区分了，全部按Server模式工作</p> 
<h2 id="收集器设置" style="margin-left:0cm;"><strong>收集器设置</strong></h2> 
<p style="margin-left:0cm;">收集器设置：<br><code>-XX:+UseSerialGC</code> 新生代串行（Serial），老年代串行（Serial Old）</p> 
<p style="margin-left:0cm;"><code>-XX:+UseParNewGC</code> 新生代并行（ParNew），老年代串行（Serial Old）</p> 
<p style="margin-left:0cm;"><code>-XX:+UseConcMarkSweepGC</code> 新生代并行（ParNew），老年代串行（CMS），备份（Serial Old）</p> 
<p style="margin-left:0cm;"><code>-XX:+UseParallelGC</code> 新生代并行吞吐（Parallel Scavenge），老年代串行（Serial Old）</p> 
<p style="margin-left:0cm;"><code>-XX:+UseParalledlOldGC</code> 新生代并行吞吐（Parallel Scavenge），老年代并行吞吐（Parallel Old）</p> 
<p style="margin-left:0cm;">并行收集器设置<br><code>-XX:ParallelGCThreads=n</code> 设置并行收集器收集时使用的CPU数。并行收集线程数。一般最好和计算机的CPU相当</p> 
<p style="margin-left:0cm;"><code>-XX:MaxGCPauseMillis=n</code> 设置并行收集最大暂停时间</p> 
<p style="margin-left:0cm;"><code>-XX:GCTimeRatio=n</code> 设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p> 
<p style="margin-left:0cm;"><code>-XX:+CMSIncrementalMode</code> 设置为增量模式。适用于单CPU情况。</p> 
<p style="margin-left:0cm;"><code>-XX:ParallelGCThreads=n</code> 设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p> 
<p style="margin-left:0cm;">工具：JDK自带的jvisualvm.exe、jconsole.exe</p> 
<p style="margin-left:0cm;">参考：</p> 
<p>《深入理解Java虚拟机》《Hotspot实战》</p> 
<p><a href="https://blog.csdn.net/zhangerqing/article/details/8214365">链接：</a><a href="https://blog.csdn.net/zhangerqing/article/details/8214365">Java之美[从菜鸟到高手演变]之JVM内存管理及垃圾回收 - CSDN博客</a></p> 
<p><a href="http://www.jikexueyuan.com/course/2098.html" rel="nofollow">链接：</a><a href="http://www.jikexueyuan.com/course/2098.html" rel="nofollow">JVM 自动内存管理：对象判定和回收算法-极客学院</a></p> 
<p><a href="https://www.ibm.com/developerworks/cn/java/j-ibmjava2/" rel="nofollow">链接：</a><a href="https://www.ibm.com/developerworks/cn/java/j-ibmjava2/" rel="nofollow">Java 技术，IBM 风格: 垃圾收集策略，第 1 部分</a> </p> 
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/" rel="nofollow">链接：</a><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/" rel="nofollow">JVM 垃圾回收器工作原理及使用实例介绍</a></p> 
<p>球友分享</p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ef67ba89d85a62806bc3186a2fcd9bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用xshell6连接Linux服务器失败的原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fce23fd62adea5ccab78e8f6aedce0c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">flask-admin modelView 如何在create和edit显示不同表单提交</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>