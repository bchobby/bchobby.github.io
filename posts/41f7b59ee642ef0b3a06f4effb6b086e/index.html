<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件工程期末复习习题 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件工程期末复习习题" />
<meta property="og:description" content="知识点总结 第一章：软件工程概述 1、软件的定义：在运行中能提供所希望的功能与性能的程序&#43;使程序能够正确运行的数据及其结构&#43;描述软件研制过程和方法所用的文档。
2、软件危机：软件开发的生产率远远不能满足客观需要。开发的软件产品往往不能满足用户的实际需要。软件产品的质量低下且可维护性差。很难估计软件开发的进度计划与成本。
3、软件工程是将系统化的、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件。
4、软件工程三个要素：方法、工具、过程
5、瀑布模型：软件需求的认识是明确的
6、演化模型：适用于对软件需求缺乏准确认识的情况。软件需求的认识是模糊的、不确定的
7、增量模型特别适用于：需求经常变化的软件开发；市场急需而开发人员和资金不能在设定的市场期限之前实现一个完善的产品的软件开发
8、原型是预期系统的一个可执行版本，它反映了系统性质的一个选定的子集。
9、螺旋模型：是瀑布模型和演化模型的结合，并增加了风险分析
10、喷泉模型：喷泉模型是一种支持面向对象开发的模型，体现迭代和无间隙特征。
第二章：系统策划 1、可行性研究的任务：技术可行性 、经济可行性和社会因素的考虑。
2、两种成本估算方法：代码行法(LOC)——每行代码的平均成本乘以程序的行数；功能点法(FP)——采用软件所提供的功能来测量的
第三章 需求分析 1、需求分析的重要性：需求分析是发现、求精、建模、规格说明和复审的过程；需求分析是系统设计的基础，关系到程的成败和软件产品的质量。
2、需求获取困难原因有三：一是用户需求的动态性(不稳定性)；二是需求的模糊性(不准确性)；三是需求必须得到用户的确认，否则毫无意义 。
3、需求分析任务：
确定对系统的综合要求：系统界面要求、系统功能要求、系统性能要求、完全性可靠性保密性要求、系统运行要求、异常处理要求、将来可能提出的要求、分析系统的数据要求；分析系统的数据要求；画出系统的逻辑模型；修正项目开发划。
4、评审、验证的四个方面：一致性、完整性、现实性和有效性。
5、结构化分析方法：面向数据的方法，以数据流为中心 。其核心概念包括：数据流、数据存储、外部实体、数据组和数据元素。基本思想：自顶向下和逐层分解。
6、面向对象的分析方法 ：面向对象分析以对象及其服务作为建模标准，比较自然，对象也具有相对的稳定性。
7、数据流图(DFD)是一种图形化技术，它描绘信息和数据从输入到输出的过程中所经受的变换。
8、数据字典任务：对于数据流图中出现的所以被命名的图形元素在数据字典中作为一个词条加以定义，使得每一个图形元素的名字都有一个确切的解释。
9、数据元素：数据的最小单位
10、面向对象＝对象＋类＋继承＋通信
11、对象是现实世界中个体或事物的抽象表示，它封装了特殊的属性(数据)和行为方法(操作)。
12、类是具有相同属性和操作的一组相似对象的抽象
13、实例：是由某个特定的类所描述的一个具体的对象
14、属性：是类或对象中所定义的数据，它是描述客观世界实体静态特征的数据项。
15、方法是对象所能执行的操作，也就是类中所定义的服务。方法描述了对象执行操作的算法，响应消息的方法
16、一个消息由以下三部分组成：
•接收消息的对象；
•消息选择符即消息名；
•零个或多个变元。
17、封装就是把某个事物包起来，使外界不知道该事物的具体内容。在面向对象的程序中，把数据和实现操作的代码集中起来放在对象内部。
18、继承：类之间的继承关系是现实世界中遗传关系的直接模拟，它表示类之间的内在联系以及对属性和操作的共享，即子类可沿用父类(被继承)的某些特征。当然也可以具有自己独有的属性和操作。
19、多态是指在父类中定义的属性或服务被子类继承后，可以具有不同的数据类型或表现出不同的行为
20、向对象方法
Booch方法 ：提出面象对象的软件工程的概念
OMT方法 ：提出面象对象的建模技术方法
OOSE方法 ：用例贯穿于软件整个开发过程
21、UML（重点放到下边来总结）
第四章 软件设计 1、软件设计是一个把需求转换为某种软件表达方式的过程。基本目标是用比较抽象概括的方式确定目标系统如何完成预定的任务。
2、概要设计：将软件需求转化为软件体系结构，确定系统级接口、全局数据结构或数据库模式。
3、详细设计：确立每个模块的实现算法、局部数据结构，用适当方法表示算法和数据结构的细节。
4、所谓模块，是指具有相对独立性的，由数据说明、执行语句等程序对象构成的集合。模块具体表现为函数、子程序、过程等。一个模块具有输入/输出(接口)、功能、内部数据和程序代码四个特征。
5、模块化是指将整个程序划分为若干个模块，每个模块用于实现一个特定的功能。
6、体系结构设计的主要任务
软件体系结构设计（功能性）：设计软件的体系结构需要在对需求分析阶段生成的数据流图进一步分析和精化的基础上，首先将系统按照功能划分为模块，接着需要确定模块之间的调用关系及其接口，最后还应该对划分的结果进行优化和调整。良好的软件结构设计对详细设计及编码阶段的工作都是至关重要的。
数据结构和数据库设计：体系结构设计中应对需求分析阶段所生成的数据字典加以细化，从计算机技术实现的角度出发，确定软件涉及的文件系统及各种数据的结构。
系统可靠性、安全性设计（非功能性）：可靠性设计也称为质量设计，目的是为了保证程序及其文档具有较高的正确性和容错性，并对可能出现的错误易于修改和维护。安全性设计的主要目的是为了增强系统的自我防护能力和运行的稳定性，防止系统遭受到有意或无意地入侵和破坏，保证系统在安全的环境下正常地工作。
7、体系结构设计的原则
(1)降低模块的耦合性，提高模块的内聚性。 为了提高软件中各个模块的独立性，提高程序的可读性、可测试性和可维护性。
(2)保持适中的模块规模。对于模块的适当规模并没有严格的规定，但普遍的观点是模块中的语句数最好保持在10～100之间。
(3)模块应具有高扇入和适当的扇出。模块的扇入越大，则说明共享该模块的上级模块数越多，或者说该模块在程序中的重用性越高，这正是程序设计所追求的目标之一。模块的扇出若过大，如在一个模块中要调用八个下级模块，则会使该模块的调用控制过于复杂。最常见的解决办法是通过在此模块和下级模块间增加一个中间层来控制模块分解的速度。根据实践经验，设计良好的典型系统中，模块的平均扇出通常为3或4。
(4)软件结构中的深度和宽度不宜过大。所谓深度，是指软件体系结构中控制的层数，它能够粗略地反映出软件系统的规模和复杂程度；所谓宽度，是指软件体系结构内同一层次上模块个数的最大值，通常宽度越大的系统越复杂。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/41f7b59ee642ef0b3a06f4effb6b086e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-30T21:56:45+08:00" />
<meta property="article:modified_time" content="2023-12-30T21:56:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件工程期末复习习题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>知识点总结</h2> 
<h3><a id="_1"></a>第一章：软件工程概述</h3> 
<p>1、软件的定义：在运行中能提供所希望的功能与性能的程序+使程序能够正确运行的数据及其结构+描述软件研制过程和方法所用的文档。<br> 2、<strong>软件危机</strong>：软件开发的生产率远远不能满足客观需要。开发的软件产品往往不能满足用户的实际需要。软件产品的质量低下且可维护性差。很难估计软件开发的进度计划与成本。<br> 3、软件工程是将<strong>系统化的、严格约束的、可量化</strong>的方法应用于软件的开发、运行和维护，即将工程化应用于软件。<br> 4、<strong>软件工程三个要素：方法、工具、过程</strong><br> 5、瀑布模型：软件需求的认识是<strong>明确的</strong><br> 6、演化模型：适用于对软件需求<strong>缺乏准确认识</strong>的情况。软件需求的认识是模糊的、不确定的<br> 7、增量模型特别适用于：<strong>需求经常变化</strong>的软件开发；市场急需而开发人员和资金不能在设定的市场期限之前实现一个完善的产品的软件开发<br> 8、<strong>原型</strong>是<strong>预期系统</strong>的一个<strong>可执行版本</strong>，它反映了系统性质的一个选定的子集。<br> 9、螺旋模型：是瀑布模型和演化模型的结合，并增加了<strong>风险分析</strong><br> 10、喷泉模型：喷泉模型是一种支持<strong>面向对象开发</strong>的模型，体现迭代和无间隙特征。</p> 
<h3><a id="_13"></a>第二章：系统策划</h3> 
<p>1、可行性研究的任务：技术可行性 、经济可行性和社会因素的考虑。<br> 2、两种成本估算方法：代码行法(LOC)——每行代码的平均成本乘以程序的行数；功能点法(FP)——采用软件所提供的功能来测量的</p> 
<h3><a id="__16"></a>第三章 需求分析</h3> 
<p>1、需求分析的重要性：需求分析是发现、求精、建模、规格说明和复审的过程；需求分析是系统设计的基础，关系到程的成败和软件产品的质量。<br> 2、需求获取困难原因有三：一是用户<strong>需求的动态性</strong>(不稳定性)；二是需求的<strong>模糊性</strong>(不准确性)；三是需求<strong>必须得到用户的确认</strong>，否则毫无意义 。<br> 3、需求分析任务：<br> 确定对系统的综合要求：系统界面要求、系统功能要求、系统性能要求、完全性可靠性保密性要求、系统运行要求、异常处理要求、将来可能提出的要求、分析系统的数据要求；分析系统的数据要求；画出系统的逻辑模型；修正项目开发划。<br> 4、评审、验证的四个方面：一致性、完整性、现实性和有效性。<br> 5、<strong>结构化分析方法</strong>：面向<strong>数据</strong>的方法，以<strong>数据流</strong>为中心 。其核心概念包括：数据流、数据存储、外部实体、数据组和数据元素。基本思想：<strong>自顶向下和逐层分解</strong>。<br> 6、<strong>面向对象的分析方法</strong> ：面向对象分析以对象及其服务作为建模标准，比较自然，对象也具有相对的稳定性。<br> 7、<strong>数据流图(DFD)<strong>是一种</strong>图形化</strong>技术，它描绘信息和数据从输入到输出的过程中<strong>所经受的变换</strong>。<br> 8、数据字典任务：对于数据流图中出现的所以被命名的图形元素在数据字典中作为一个词条加以定义，使得每一个图形元素的名字都有一个确切的解释。<br> 9、数据元素：数据的最小单位<br> 10、<strong>面向对象＝对象＋类＋继承＋通信</strong><br> 11、对象是现实世界中个体或事物的抽象表示，它封装了特殊的属性(数据)和行为方法(操作)。<br> 12、类是具有相同属性和操作的一组相似对象的抽象<br> 13、实例：是由某个特定的类所描述的一个具体的对象<br> 14、属性：是类或对象中所定义的数据，它是描述客观世界实体静态特征的数据项。<br> 15、方法是对象所能执行的操作，也就是类中所定义的服务。方法描述了对象执行操作的算法，响应消息的方法<br> 16、一个消息由以下三部分组成：<br> •接收消息的对象；<br> •消息选择符即消息名；<br> •零个或多个变元。<br> 17、封装就是把某个事物包起来，使外界不知道该事物的具体内容。在面向对象的程序中，把数据和实现操作的代码集中起来放在对象内部。<br> 18、继承：类之间的继承关系是现实世界中遗传关系的直接模拟，它表示类之间的内在联系以及对属性和操作的共享，即子类可沿用父类(被继承)的某些特征。当然也可以具有自己独有的属性和操作。<br> 19、多态是指在父类中定义的属性或服务被子类继承后，可以具有不同的数据类型或表现出不同的行为<br> 20、向对象方法<br> Booch方法 ：提出面象对象的软件工程的概念<br> OMT方法 ：提出面象对象的建模技术方法<br> OOSE方法 ：用例贯穿于软件整个开发过程<br> 21、UML（重点放到下边来总结）</p> 
<h3><a id="__45"></a>第四章 软件设计</h3> 
<p>1、软件设计是一个把需求转换为某种软件表达方式的过程。基本目标是用比较抽象概括的方式确定目标系统如何完成预定的任务。<br> 2、概要设计：将<strong>软件需求</strong>转化为<strong>软件体系结构</strong>，确定系统级接口、全局数据结构或数据库模式。<br> 3、详细设计：确立每个模块的实现算法、局部数据结构，用适当方法表示算法和数据结构的细节。<br> 4、所谓模块，是指具有相对<strong>独立性</strong>的，由数据说明、执行语句等程序对象构成的集合。模块具体表现为函数、子程序、过程等。一个模块具有输入/输出(接口)、功能、内部数据和程序代码四个特征。<br> 5、模块化是指将整个程序划分为若干个模块，每个模块用于实现一个特定的功能。<br> 6、<strong>体系结构设计</strong>的主要任务<br> <strong>软件体系结构设计（功能性）</strong>：设计软件的体系结构需要在对需求分析阶段生成的<strong>数据流图</strong>进一步分析和精化的基础上，首先将系统按照功能划分为<strong>模块</strong>，接着需要确定模块之间的<strong>调用关系及其接口</strong>，最后还应该对划分的结果进行<strong>优化和调整</strong>。良好的软件结构设计对详细设计及编码阶段的工作都是至关重要的。<br> <strong>数据结构和数据库设计</strong>：体系结构设计中应对需求分析阶段所生成的数据字典加以<strong>细化</strong>，从计算机技术实现的角度出发，确定软件涉及的文件系统及各种数据的结构。<br> <strong>系统可靠性、安全性设计（非功能性）</strong>：可靠性设计也称为<strong>质量设计</strong>，目的是为了保证程序及其文档具有较高的<strong>正确性和容错性</strong>，并对可能出现的错误易于修改和维护。<strong>安全性设计</strong>的主要目的是为了增强系统的自我防护能力和运行的稳定性，防止系统遭受到有意或无意地入侵和破坏，保证系统在安全的环境下正常地工作。<br> 7、体系结构设计的原则<br> (1)降低模块的耦合性，提高模块的内聚性。 为了提高软件中各个模块的独立性，提高程序的可读性、可测试性和可维护性。<br> (2)保持适中的模块规模。对于模块的适当规模并没有严格的规定，但普遍的观点是模块中的语句数最好保持在10～100之间。<br> (3)模块应具有高扇入和适当的扇出。模块的扇入越大，则说明共享该模块的上级模块数越多，或者说该模块在程序中的重用性越高，这正是程序设计所追求的目标之一。模块的扇出若过大，如在一个模块中要调用八个下级模块，则会使该模块的调用控制过于复杂。最常见的解决办法是通过在此模块和下级模块间增加一个中间层来控制模块分解的速度。根据实践经验，设计良好的典型系统中，模块的平均扇出通常为3或4。<br> (4)软件结构中的深度和宽度不宜过大。所谓深度，是指软件体系结构中控制的层数，它能够粗略地反映出软件系统的规模和复杂程度；所谓宽度，是指软件体系结构内同一层次上模块个数的最大值，通常宽度越大的系统越复杂。<br> (5) 模块的作用域应处于其控制域范围之内。模块的作用域是指受该模块内一个判定条件影响的所有模块范围。模块的控制域是指该模块本身以及所有该模块的下属模块(包括该模块可以直接调用的下级模块和可以间接调用的更下层的模块)。因此，软件设计时应使各个模块的作用域处于其控制域范围之内。若发现不符合此设计原则的模块，可通过下面的方法进行改进：<br> a、 将判定位置上移。<br> b、 将超出作用域的模块下移。<br> (6) 尽量降低模块的接口复杂度。<br> 8、划分模块的重要目标是提高模块的独立性。度量模块独立性的两个准则是模块间的内聚性和耦合性。好的软件结构应该具有高内聚、低耦合的模块化结构。<br> 内聚性是一个模块内部各个元素彼此结合的紧密程度的度量。<br> 耦合性是模块间互相连接的紧密程度的度量。它取决于各个模块之间接口的复杂度、调用方式以及哪些信息通过接口。<br> 9、模块内聚按照模块独立性由高到低的顺序：<br> 功能内聚：这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。<br> 逻辑内聚：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能。<br> 时间内聚：把需要同时执行的动作组合在一起形成的模块为时间内聚模块。<br> 过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。<br> 通信内聚：指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。<br> 顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。<br> 偶然内聚：模块中的代码无法定义其不同功能的调用。但它使该模块能执行不同的功能，这种模块称为巧合强度模块。<br> 10、耦合度由低到高：<br> 非直接耦合：两模块间没有直接关系，之间的联系完全是通过主模块的控制和调用来实现的。<br> 数据耦合：一个模块访问另一模块，彼此间通过简单数据参数来交换输入、输出信息。这里的简单数据参数不同于控制参数、公共数据结构或外部变量。<br> 标记耦合：指两个模块之间传递的是数据结构,如高级语言的数组名,记录名,文件名等这些名字即为标记,其实传递的是这个数据结构的地址。<br> 控制耦合：一个模块通过传递开关、标志、名字等控制信息，明显的控制选择另一模块的功能 。<br> 外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数传递该全局变量的信息。<br> 公共耦合：一组模块都访问同一个公共数据环境。该公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。<br> 内容耦合：一个模块直接修改另一个模块的数据，或直接转入另一个模块 。<br> 11、<strong>概要设计的主要目标是把需求转换为软件的体系结构。</strong><br> 12、图形设计表示法<br> 流程图、盒图（N-S图）、PAD图（问题分析图）、PDL (Process Design Language)语言即过程设计语言，是一种用于描述程序算法和定义数据结构的伪代码。<br> 13、类图通常表示为长方形，长方形又分三个部分，分别用来表示类的名字、属性和操作。常用的可见性有公用、私有、受保护 3 种， 分别用“+”、 “－”、 “＃”来表示<br> 14、包(package)是一种组合机制，把许多类集合成一个更高层次的单位，形成一个高内聚、低耦合的类的集合。包图是一个很有用的工具，特别是对于改进系统的结构非常有帮助。<br> 15、状态图：所有对象都具有状态，状态是对象执行了一系列活动的结果。当某个事件发生后，对象的状态将发生变化。状态图中定义的状态有：初态、终态、中间状态、复合状态。其中，初态是状态图的起始点，而终态则是状态图的终点。一个状态图只能有一个初态，而终态则可以有多个。状态图描述跨越多个用例的单个对象的行为<br> 16、顺序图用来描述对象之间动态的交互关系，着重体现对象间消息传递的时间顺序。<br> 17、协作图用于描述相互合作的对象间的交互关系和链接关系。<br> 18、顺序图和协作图适合描述单个用例中几个对象的行为。</p> 
<h3><a id="_92"></a>第五章：编程</h3> 
<p>1、计算机语言分类<br> 面向机器的语言：汇编语言<br> 面向过程的语言：FORTRAN、COBOL、 PASCAL 、C<br> 面向对象的语言：C++、C#、Java、 Perl 、python、Delphi、Visual Basic、PowerBuilder<br> <strong>面向服务的语言：XML、.NET(C#)、J2EE(Java)</strong><br> <strong>Web编程语言：HTML语言</strong>、ASP 、JSP、PHP、.Net<br> 2、源程序的文档化包括标识符的选择与命名、注释的安排、程序代码的视觉组织等 。<br> 3、注释是程序员和程序读者通信的重要手段，正确的注释非常有助于对程序的理解。<br> 4、结构化程序设计的原则<br> 程序三种基本流程结构：顺序结构、选择结构和循环结构。<br> 基本原则：自顶向下,逐步求精,单入口单出口。在分析一个问题的编程思路时，先将该问题分成若干个大的步骤，然后对每一步骤再进行细化分成若干个小的步骤，这样逐级细分，直到最后能将每一个步骤直接翻译成为相应的计算机语言的指令。<br> 5、面向对象程序设计风格：提高可复用性、提高可扩充性和提高健壮性</p> 
<h3><a id="__105"></a>第七章 软件实施与维护</h3> 
<p>1、软件文档分类：<strong>开发文档、管理文档和用户文档</strong><br> 2、软件维护概念：是指在软件的运行/维护阶段由软件厂商向客户所提供的服务工作 。<br> 3、软件维护分四类<br> （1）<strong>纠错性维护</strong> 占 17%～20% ：改正在特定的使用条件下软件中暴露出来的错误与缺陷，这些错误或缺陷在测试时并未被发现。<br> （2）<strong>适应性维护</strong>占18%～25%：使软件产品能够适应变化了的运行环境，如操作系统版本的升级、机器配置的变化、软件使用对象的变化等。<br> （3）<strong>完善性维护</strong>，占50%～60%：为适应用户对软件功能、性能或接口方面提出的新要求以使产品更加完善与合理而进行的修改<br> （4）<strong>预防性维护</strong>占4%左右：提高产品的可靠性和可维护性，减少今后维护的工作量，有利于系统和进一步改造或升级换代而进行的维护<br> 4、UML将软件生存周期定义为4个主要阶段：初始、细化、构造、移交。</p> 
<h3><a id="_115"></a>第八章软件项目管理</h3> 
<p>1、软件项目管理的主要任务：为了使软件项目能够按照预定的成本、进度、质量顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。<br> 2、软件项目组织结构类型<br> 工作队式的项目组织：适用于大型项目，工期要求紧，要求多工种、多部门密切配合的项目。<br> 部门控制式组织：适用于小型的，专业性较强，不需涉及众多部门的项目。<br> 项目型组织：能迅速有效地对项目目标和客户的需要做出反应。<br> 矩阵型组织：能够充分利用人力和物力资源，适用于同时承担多个项目的企业。<br> 直线职能型组织：缺点是项目时间长，各部门协调困难。<br> 3、成本估算需要考虑的因素<br> （1）项目所包括的工作<br> （2）资源需求<br> （3）资源单价<br> （4）项目完成所需要的时间<br> （5）已完成项目的历史资料<br> （6）会计科目表<br> 4、成本估算的方法<br> （1）通过度量软件代码行数进行估算：是度量软件规模的直观指标，对软件成本估算起一定的作用。<br> （2）通过软件功能点进行估算<br> （3）使用类比估计法<br> （4）使用累加估计法<br> 5、进度控制就是比较项目执行的实际状态和项目计划之间的差异，并做出必要的调整使项目向有利的方向发展。<br> 6、进度控制的四个步骤：计划、执行、检查、行动。<br> 7、软件质量保证是为了保证软件产品和服务能够充分满足客户所要求的质量而进行的有计划、有组织的活动 。<br> 8、软件质量因素<br> (1)正确性(2)健壮性(3)效率(4)完整性(安全性)(5)可用性(6)易用性(7)风险<br> (8)可理解性(9)可维护性(10)灵活性(适应性)(11)可测试性(12)可移植性<br> (13)可再用性(14)互运行性（兼容性）<br> 9、使用合理的质量评价指标体系：(1)功能性指标(2)可靠性指标(3)易用性指标(4)效率特征指标<br> 10、软件配置管理任务：配置标识；建立系统受控配置库；版本管理；变更控制；配置审核<br> 配置状态报告；发布管理</p> 
<h3><a id="_145"></a>第九章软件过程</h3> 
<p>1、CMM内容简介<br> (1)软件过程：人们用于<strong>开发和维护</strong>软件及其相关过程的一系列活动，包括<strong>软件工程活动和软件管理活动</strong>。<br> (2)软件过程能力：描述(开发组织或项目组)遵循其软件过程<strong>能够实现预期结果的程度</strong>，它既可对整个软件开发组织而言，也可对一个软件项目而言。<br> (3)软件过程性能：表示(开发组织或项目组)遵循其软件过程所得到的实际结果，软件过程性能描述的是已得到的实际结果，而软件过程能力则描述的是最可能的预期结果，它既可对整个软件开发组织而言，也可对一个特定项目而言。<br> (4)软件过程成熟：一个特定软件过程被明确和有效地定义，管理测量和控制的程度。<br> (5)软件能力成熟度等级：软件开发组织在走向成熟的途中几个具有明确定义的表示软件过程能力成熟度的平台。<br> (6)关键实践：对关键过程域的实践起关键作用的方针、规程、措施、活动以及相关基础设施的建立。关键实践一般只描述“做什么”而不强制规定“如何做”。<br> (7)软件能力成熟度模型：随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力也伴随着这些阶段逐步前进，完成对软件组织进化阶段的描述模型。<br> 2、软件过程评估目的是确定一个组织的当前软件过程的状态，找出组织所面临的急需解决的与软件过程有关问题，进而有步骤地实施软件过程改进，使组织的软件过程能力不断提高。<br> 3、软件能力评价目的是识别合格的能完成软件工程项目的承制方，或者监控承制方现有软件工作中软件过程的状态，进而提出承制方应改进之处。<br> 4、PSP简介：个体软件过程(PSP：Personal Software Process)能够指导软件工程师如何保证自己的工作质量，估计和规划自身的工作，度量和追踪个人的表现，管理自身的软件过程和产品质量。<br> 5、RUP（Rational Unified Process，统一（软件开发）过程)是一个面向对象且基于网络的程序开发方法论。<br> 6、RUP最重要的它有三大特点：<br> 1）软件开发是一个迭代过程，<br> 2）软件开发是由Use Case驱动的，<br> 3）软件开发是以架构设计（Architectural Design）为中心的<br> 7、软件生命周期中的各个阶段：<br> 初始阶段、细化阶段、构造阶段和交付阶</p> 
<p>第二部分</p> 
<h3><a id="_168"></a>开发模式与平台</h3> 
<p>1、客户/服务器（Client/Server)模式<br> 特点：系统使用了客户和服务器双方智能、资源和计算能力来执行一个特定的任务。提出服务请求的一方称为“客户机”，而提供服务的一方则称为“服务器”。<br> 应用软件安装在：前端（即客户部分）/后端（服务器部分）<br> 2、浏览器/服务器（ Browser/Server)模式<br> 特点： B/S结构的客户端采用了人们普遍使用的浏览器，它是一个简单的、低廉的、以Web技术为基础的“瘦”C/S系统。<br> 应用软件安装在：后端（服务器部分）<br> 3、对等（Peer to Peer，P2P）模式<br> 特点：用户和资源处于对等状态，分布式计算。<br> P2P网络是一个应用层网络，一般由网络边缘节点构成，充分利用资源；网络的扩展性好；<br> 资源分布在各个节点中，而不是集中在一个服务器上进行管理，不存在单点瓶颈问题；节点之间可直接建立连接，交互共享资源。<br> 需要解决的问题：动态性、安全性、可管理性…<br> 4、c/s与b/s比较<br> B/S模式以<strong>Web服务器</strong>为系统的中心，客户机端通过其浏览器向Web服务器提出查询请求（HTTP协议方式），Web服务器根据需要向<strong>数据库服务器</strong>发出数据请求。数据库则根据查询或查询的条件返回相应的数据结果给Web服务器，最后Web服务器再将结果翻译成为HTML或各类脚本语言的格式，并传送给客户机上的浏览器，用户通过浏览器即可浏览自己所需的结果。<br> 使用B/S结构的<strong>浏览器访问数据库的三层方式</strong>，与C/S结构的二层结构相比，具有成本低，易于更新和改动，用户可以自行安装浏览器软件，并使用通用的浏览器进行访问，与网络平台完全无关，客户端软件廉价，安全保密控制灵活等显著的优点。<br> 5、MVC好处是它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。<br> 6、MVC的工作原理：<br> ①当用户在浏览器中点击一个链接或者提交一个表单时，那么就会产生一个请求（request）。当请求离开浏览器时，它会携带用户请求的信息。<br> ②请求的第一站到达的是Spring的DispatcherServlet，它是一个前端控制器，工作是将用户的请求委托给其他的组件（这里是交给Spring MVC的控制器）去处理。<br> ③当选择了一个合适的控制器后，DispatcherServlet就会将请求交给这个控制器去处理。在这个控制器上，用户的请求将会将用户提交的一些信息交由控制器处理并等待。<br> ④当控制器对用户请求所携带的信息进行处理（或交给模型层处理）后，经常会产生一些其他的需要返回给浏览器进行显示的数据。<br> ⑤DispatcherServlet会向一个视图解析器（ViewResolver）进行请求，视图解析器可以将逻辑视图名称映射到一个特定的视图显示文件上面。<br> ⑥现在DispatcherServlet知道哪一个视图文件可以显示结果了。该视图将会利用模板数据产生输出，这些输出通过response对象返回给客户端进行显示。<br> 7、MVC基本概念：<strong>模型-视图-控制器</strong><br> MVC（Model-View-Controller）将一个<strong>交互式应用程序</strong>分成3个组件<br> 模型：包含核心功能和数据 （核心业务逻辑）<br> 视图：向用户显示信息<br> 控制器：处理用户输入 <br> <strong>变更-传播机制</strong>保证了模型和用户界面之间的<strong>一致性</strong><br> 变更-传播机制工作原理：<br> 模型维护了一个表；所有视图还有一些控制器在这个表中登记了对变更通知的需求；模型状态的改变将触发变更-传播机制，每个在表中登记的视图和控制器都会收到变更通知。<br> 目的：<br> <strong>将人机交互从核心功能中分离出来(M)<br> 模型对用户来说是透明的，用户只需要观察视图(V)<br> 用户与模型的交互通过控制器提供的安全方法来实现©</strong><br> 7、SSH (Struts + Spring + Hibernate)<br> Hibernate是一个开放源代码的ORM（Object/Relational Mapping，对象关系映射 ）框架，是一种数据持久化的实现技术。它对JDBC进行了轻量级的对象封装，使得Java程序员可以随心所欲地使用面向对象编程思维来操作数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP（Container Managed Persistence ），完成数据持久化的重任。<br> 8、MVC架构的开发模式（特点）<br> 优点：<br> 开发流程更为明确：区别开显示端和商业逻辑端，美工设计人员和程序员能够专注于本身的工作，有利于大型系统的开发。<br> 核心的程序管控 ：由Controller控制整个流程，可以减少JSP需要撰写许多条件判断逻辑及流程管控等等的程序代码。<br> 维护容易：不论是后端商业逻辑对象或间断的网页呈现，都通过控制中心来掌控，如果有商业逻辑的变更，可以轻易的修改Model段的程序，而不用去修改相关的JSP文件。<br> 缺点：<br> 学习时间较长：各家公司都有自己MVC架构，花更多的时 间去熟悉了解他们的流程与概念。<br> 发时间较长：因为需要设计MVC个对象比吃的数据交换与方法，会需要更多的时间在系统设计之上。</p> 
<h3><a id="J2EENET_215"></a><strong>J2EE和.NET</strong></h3> 
<p>总体上来说，J2EE和.NET是两种不同的企业级应用开发平台，它们在技术概念、语言选择、跨平台性、开发环境、架构模型、企业级标准、开源性等方面存在一些差异。以下是对比的主要分点总结：</p> 
<ol><li> <p>技术概览：</p> 
  <ul><li><strong>J2EE：</strong> 规范集合，注重跨平台性，使用Java语言。</li><li><strong>.NET：</strong> 一组产品，包括多种语言，注重一站式软件，使用C#等语言。</li></ul> </li><li> <p>技术比较：</p> </li></ol> 
<ul><li><strong>开发语言：</strong> 
  <ul><li>J2EE使用Java，.NET使用C#等多种语言。</li></ul> </li><li><strong>跨平台性：</strong> 
  <ul><li>J2EE强调跨平台性，可以在不同平台上运行。</li><li>.NET通过.NET Core实现跨平台性，但以Web services解决异种平台间通信问题。</li></ul> </li><li><strong>开发环境：</strong> 
  <ul><li>J2EE使用Eclipse、NetBeans等，.NET使用Visual Studio。</li></ul> </li><li><strong>架构模型：</strong> 
  <ul><li>J2EE使用JavaBeans、EJB等，.NET使用.NET组件、ASP.NET等。</li></ul> </li><li><strong>企业级标准：</strong> 
  <ul><li>J2EE遵循Java EE规范，.NET遵循微软标准，包括ASP.NET、WCF等。</li></ul> </li><li><strong>开源性：</strong> 
  <ul><li>J2EE完全开源，.NET部分开源（.NET Core）。</li></ul> </li></ul> 
<ol start="3"><li> <p>技术细节比较：</p> 
  <ul><li><strong>开发语言相似性：</strong> 
    <ul><li>C#在结构上与Java相似，但C#引入了一些新概念。</li></ul> </li><li><strong>中间层：</strong> 
    <ul><li>J2EE使用JavaBean和EJB，.NET使用.NET组件和COM+。</li></ul> </li><li><strong>表示层：</strong> 
    <ul><li>J2EE使用Servlet、JSP、HTML等，.NET使用Windows Forms和ASP.NET。</li></ul> </li><li><strong>数据访问：</strong> 
    <ul><li>J2EE使用JDBC和实体EJB，.NET使用ADO.NET和DataSet。</li></ul> </li></ul> </li><li> <p>整体评价：</p> 
  <ul><li><strong>J2EE优势：</strong> 
    <ul><li>跨平台性强，开源，丰富的开发者社区。</li><li>高度规范化，适用于复杂的企业级应用。</li></ul> </li><li><strong>.NET优势：</strong> 
    <ul><li>统一平台，一站式软件，强调简单、快捷、高效。</li><li>提供全方位的产品，从桌面到后台。</li></ul> </li></ul> </li><li> <p>发展趋势：</p> </li></ol> 
<ul><li><strong>J2EE：</strong> 
  <ul><li>跨平台性和开源性使其在多种场景下具有优势。</li><li>发展方向可能受J2EE规范的进一步完善和开源生态系统的支持。</li></ul> </li><li><strong>.NET：</strong> 
  <ul><li>微软持续改进.NET Core，提升跨平台性。</li><li>强调Web services，与云计算和微服务架构的发展趋势相符。</li></ul> </li></ul> 
<p>综合考虑企业需求、技术栈、开发团队技能等因素，选择合适的平台是关键。</p> 
<p>9、J2EE 与 .NET 比较<br> （1）技术概观 ：<strong>在表现形式上，J2EE是一组规范，而.NET更象是一组产品。<strong>但它们的目的都是为了企业应用提供</strong>分布式的，高可靠性</strong>的解决方案.<br> （2）技术比较：</p> 
<p>一 vs 多 ：<br> 两种平台主流的开发语言Java和C#在架构上有着惊人的相似：虚拟机技术，基于沙箱的安全模型，分层的命名空间，垃圾回收等。所以从第一眼看上去，C#简直就是Java的克隆。一方面，C#的大多数关键字来源于C++，使它在书写上有别于Java。但另一方面，C#的严格的类型转换等概念却明显来自于Java(当然，它的原始类型的定义更严格，并且据微软声称没有影响到效率.)，使其在内涵上有克隆之嫌.但即是Java，其有些特性也和Smalltalk颇有渊源.所以评价一种开发语言的优劣不仅是看其外在的表现形式，更重要的是其实实在在的功效.作为一种新语言，C#加入了基于XML的标记，可以被编译器用来直接生成文档，C#的另一个特点:一站式软件(one-stop-shopping software)强调了自解释( self-describing) 的编码方式，即头文件，IDL(Interface Definition Language)，GUID和其他复杂的接口无需再被引用.也即是C#，VB.NET等代码片断可以任意的被加入到其他语言中.这无疑在多种语言混合编程的模式中是一次飞跃，但是，其难维护性也是不言而喻的。<br> 微软的.NET的平台提供了象C#，VB.NET，COBOL等多种开发语言，C#是新的，而其他的每一种语言都是在原有的基础上改造而来.这是微软煞费苦心并且也是不得以的要为习惯于这些语言的程序员铺一条便捷之路.但是，这些语言的改造与其说是整容到不如说是一次开膛破肚的大手术.<br> 跨平台是J2EE的最大卖点，也是至今为止还绊住微软的栅栏.当开发商完成了符合J2EE规范的软件时，其客户可以依据其喜好和实力来选择不同应用服务器.从基于open source的免费软件到高端满足B2B需求的商业套件来搭建自己的平台.但是由于J2EE的规范还不完善，各个J2EE服务器的提供商为了使其提供其各自理解的完整的功能，不得不添加一些额外的特性.这就使得使用了这些特别功能的应用软件，绑定到了特定的应用服务器上.随着J2EE规范的发展，这种差别会逐渐减小.<br> 微软的跨平台解决方案是Web services，它解决的是异种平台上不同应用之间的连通性问题.从技术角度讲，它除了以XML为介质之外没有什么新意.但它的重要意义在于:它是微软这样一个重量级选手所推出的，前景不容小视.构造和使用 Web services 的过程较为简单</p> 
<p>中间层：<br> 基于组件的软件开发技术可以在较高的级别上实现软件复用，加快企业软件开发的进程.在J2EE构架中， JavaBean和EJB(Enterprise JavaBeans) 被用来完成事物逻辑.其中EJB和 JavaBean 有着类似的模型，但它被用来创建分布式的企业应用.<br> 在微软的.NET平台中，旧的COM 和 COM+的组件模型被新的组件模型所代替。增加了象基于沙箱的安全模型和垃圾回收等功能.并且实现了多重接口继承，扩展的元数据和新的代理模型等.旧有的COM和COM+组件也可被映射到新的运行环境中。<br> 表示层：<br> 两种架构都同时支持胖客户端和瘦客户端.即C/S模式和B/S模式.对于C/S模式，J2EE提供了替代Java AWT的Java Swing，同时作为可视化组件的JavaBean也可用来构造系统。对于B/S结构的表示层，J2EE使用 servlet ，JSP(Java Server Page) ，HMTL，WML，XML等工具来实现。<br> 微软的胖客户端技术则由 Windows Forms代替了MFC.它们起的作用相同，在结构上 Windows Forms 被插入到.NET的运行时框架(runtime framework)和组件模型 (component model)中.在瘦客户模型中， ASP.NET代替了旧有的ASP和 HMTL， WML ，XML作为表示层。在 ASP.NET 中，C#，VB.NET等语言的代码片断可被自由引用.ASP.NET 页面被首先转换成中介语言( Intermediary Language)，然后再被 中介语言及时编译器(just-in-time IL compiler)编译，最后运行于公共语言运行环境中，并且 ASP.NET 提供了页面的缓冲，所以，其运行速度要远远快于ASP。<br> 数据访问 ：<br> J2EE 和 .NET 已不同的形式支持数据的访问。JDBC和ADO一样和所连接的数据库无关，并且通过连接，命令语句和结果集来对数据进行操作.所以属于中间层次的 API.更高一级的数据封装和数据管理是通过实体EJB (entity EJB)来完成的.基于容器管理的实体EJB使开发更快捷，管理更方便.事实上，由于实体EJB的load()和store()方法的同步机制，将大大缓解因并发而使数据库产生的瓶颈.也可以采用不属于J2EE规范的第三方数据访问工具，象WebGain的 TopLink。<br> 而微软的.NET的数据访问工具则由基于XML的ADO.NET代替了基于COM组件的ADO.任何以XML为输出的数据源都可以作为 ADO.NET 的数据源.相应的结果集升级为数据集 (DataSets)，命令语句则升级为数据集命令(DataSetCommands).从形式来看，微软的ADO.NET更新潮和时髦一些，基于XML的特性使其可以处理极其丰富的数据源，并且，因其构架在HTTP协议之上，易于穿透防火墙，使沟通更为便利.但由于XML本身的基于标记的特性，很明显限制了在有超大数据量和有网络瓶颈的应用中的使用.而J2EE的数据访问规则则显得略有单薄，但同时却更简单，更有效.并且通过对应用程序有效的层次的设计，对于数据库和基于XML的数据源的访问，也是可以无缝的整合的。<br> （3）整体评价<br> 就企业而言，内部众多系统的整合、系统的延展性、安全性是更需要注意的议题，而这些都是J2EE的优势，也是微软的不足处。 在效率方面，J2EE阵营主张通过硬件的效能增加来弥补软件的不足.开放标准，功能强大，易于移植这些都是J2EE的卖点。但让人奇怪的是IBM的WebSphere和BEA的WebLogic在J2EE市场占了大半壁江山，而作为规则制定者的SUN却在做壁上观。<br> 微软确实提供了从桌面的办公软件，开发工具，到后台服务器数据库的全方位的产品。 但统一平台的使用者可能要牺牲跨平台的好处，并也有可能由此就被无穷无尽的锁定在微软的许可证的汪洋中.更简单，更快捷，更高效是微软的目标，随着时代的发展，我们也许会看到更完美的技术解决方案。</p> 
<h3><a id="_291"></a>云计算</h3> 
<p>1、什么是云计算<br> 云计算（cloud computing）是<strong>分布式计算技术</strong>的一种，其最基本的概念是透过<strong>网络</strong>将庞大的<strong>计算处理程序</strong>自动分拆成无数个较小的<strong>子程序</strong>，再交由多部服务器所组成的庞大系统经搜寻、计算分析之后将处理结果<strong>回传给用户</strong>。<br> 狭义云计算是指IT基础设施的交付和使用模式，指通过网络<strong>以按需、易扩展的方式获得所需的资源</strong>。<br> 广义云计算是指服<strong>务的交付和使用模式</strong>，指通过网络以按需、易扩展的方式获得所需的服务。这种服务可以是IT和软件、互联网相关的，也可以是任意其他的服务，它具有超大规模、虚拟化、可靠安全等独特功效。<br> 2、云计算的<strong>主要服务模式</strong> ——IaaS、PaaS、SaaS、DaaS<br> <strong>IaaS(Infrastructure-as-a-Service)</strong>：<strong>基础设施即服务</strong>。消费者通过Internet可以从完善的计算机基础设施（包括网络、服务器和存储等）获得服务。世纪互联集团旗下的云快线公司号称要开拓新的IT基础设施业务，但究其本质，它只能实现主机托管业务的延伸，很难与亚马逊等企业相媲美。<br> <strong>PaaS(Platform-as-a-Service)：平台即服务</strong>。PaaS实际上是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。国内的八百客拥有PaaS平台技术。<br> **SaaS(Software-as-a-Service)：软件即服务。**它是一种通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动。相对于传统的软件，SaaS解决方案有明显的优势，包括较低的前期成本，便于维护，快速展开使用等。比如红麦软件的舆情监测系统。<br> <strong>DaaS(Data-as-a-Service)：数据即服务</strong>。数据做为一种服务是通过传递有用的信息以帮助他人的活动来实现的。如有关汽车的组成及损坏情况的数据帮助维修师傅维修。我们经常上网查询资料，这些资料中的有用信息给我们的活动产生影响也是一种服务。大数据时代的到来促进了DaaS的出现。<br> 3、云计算的特点<br> <strong>云计算的特点：超大规模、虚拟化、高可靠性、通用性 、高可扩展性 、按需服务 、廉价性、潜在的危险性</strong><br> 超大规模：具有相当的规模，Google云计算已经拥有100多万台服务器， Amazon、IBM、微软、Yahoo等的“云”均拥有几十万台服务器。企业私有云一般拥有数百上千台服务器。“云”能赋予用户前所未有的计算能力。<br> 虚拟化：云计算支持用户在任意位置、使用各种终端获取应用服务。所请求的资源来自“云”，而不是固定的有形的实体。应用在“云”中某处运行，但实际上用户无需了解、也不用担心应用运行的具体位置。只需要一台笔记本或者一个手机，就可以通过网络服务来实现我们需要的一切，甚至包括超级计算这样的任务。<br> 高可靠性：<br> “云”使用了数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性，使用云计算比使用本地计算机可靠。<br> 通用性：<br> 云计算不针对特定的应用，在“云”的支撑下可以构造出千变万化的应用，同一个“云”可以同时支撑不同的应用运行。<br> 高可扩展性：<br> “云”的规模可以动态伸缩，满足应用和用户规模增长的需要。<br> 按需服务：<br> “云”是一个庞大的资源池，你按需购买；云可以象自来水、电、煤气那样计费。 <br> 廉价性：<br> 由于“云”的特殊容错措施可以采用极其廉价的节点来构成云，“云”的自动化集中式管理使大量企业无需负担日益高昂的数据中心管理成本，“云”的通用性使资源的利用率较之传统系统大幅提升，因此用户可以充分享受“云”的低成本优势，经常只要花费几百美元、几天时间就能完成以前需要数万美元、数月时间才能完成的任务。<br> 云计算可以彻底改变人们未来的生活，但同时也要重视环境问题，这样才能真正为人类进步做贡献,而不是简单的技术提升。<br> 潜在的危险性：<br> 云计算服务除了提供计算服务外，还必然提供了存储服务。但是云计算服务当前垄断在私人机构（企业）手中，而他们仅仅能够提供商业信用。<br> 4、常用的主机虚拟化软件<br> Citrix XenServer<br> 微软 Windows Server 2008 Hyper-V<br> VMware ESX Server<br> RedHat KVM<br> 开源的OpenStack<br> 方物vServer<br> 华为Galax<br> 5、云计算的好处<br> <strong>数据安全可靠、客户端设备需求低、轻松共享数据、使网络无所不能</strong><br> 数据安全可靠：云计算提供了最可靠、最安全的数据存储中心，用户不用再担心数据丢失、病毒入侵等麻烦。<br> 客户端需求低：云计算对用户端的设备要求最低，使用起来也最方便。<br> 轻松共享数据：云计算可以轻松实现不同设备间的数据与应用共享。<br> 使网络无所不能：云计算为我们使用网络提供了几乎无限多的可能</p> 
<h3><a id="CMMI_334"></a>CMMI</h3> 
<p><strong>Capability Maturity Model Integration</strong><br> 1、CMMI给企业带来的好处<br> 第一、能保证软件开发的质量与进度，能对“杂乱无章、无序管理”的项目<strong>开发过程进行规范</strong>。<br> 第二、有利于<strong>成本控制</strong>。因为质量有所保证，浪费在修改、解决客户的抱怨方面的成本会降低很多。绝大多数情况是缺少规范制度，只是求快。项目完成后，要花很多时间修修补补，费用很容易失控。<br> 第三、有助于<strong>提高软件开发者的职业素养</strong>。每一个具体参与其中的员工，无论是项目经理，还是工程师，甚至一些高层管理人的做事方法逐渐变得标准化、规范化。<br> 第四、能够<strong>解决人员流动所带来的问题</strong>。公司通过过程改进，建立了财富库以共享经验， 而不是单纯依靠某些人员。<br> 第五、有利于<strong>提升公司和员工绩效管理水平</strong>，以持续改进效益。通过度量和分析开发过程和产品，建立公司的效率指标。</p> 
<p>2、什么是CMMI<br> CMMI全称是Capability Maturity Model Integration, 即软件能力成熟度模型集成，是由美国国防部与卡内基-梅隆大学和美国国防工业协会共同开发和研制的，其目的是<strong>帮助软件企业对软件工程过程进行管理和改进，增强开发与改进能力，从而能按时地、不超预算地开发出高质量的软件</strong>。<br> <strong>软件工程三个要素：方法、工具、过程</strong><br> 3、什么是过程<br> 为实现预定目的而执行的一组实践（活动）；过程包含<strong>工具，方法，材料及人员。</strong><br> 了解过程：<br> 规定了实现预定目的或成果所要完成的一系列活动/任务 - 要做什么；<br> 执行活动相关的角色和职责 – 谁来做；<br> 完成活动所要采用的技术、方法和步骤 – 如何去做<br> 4、CMMI 模型<br> CMMI有两种表示方法，一种是<strong>阶段式表现方法</strong>，另一种是<strong>连续式</strong>的表现方法。<br> 这两种表现方法的区别是：<br> 阶段式表现方法仍然把CMMI中的若干个过程域分成了<strong>5 个成熟度级别</strong>，帮助实施CMMI的组织建议一条比较容易实现的过程改进发展道路。<br> 连续式表现方法则通过将CMMI中过程域分为<strong>四大类</strong>：过程管理、项目管理、工程以及支持。对于每个大类中的过程域，又进一步分为基本的和高级的。这样，在按照连续式表示方法实施CMMI的时候，一个组织可以把项目管理或者其他某类的实践一直做到最好，而其他方面的过程域可以完全不必考虑。<br> 5、CMMI的<strong>五级标准</strong><br> CMMI分为五个等级，<strong>二十二个过程域（PA）。</strong><br> <strong>初始级</strong>:软件过程是<strong>无序的</strong>，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是<strong>反应式</strong>的。<br> <strong>已管理</strong>级:建立了<strong>基本的</strong>项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。<br> <strong>已定义级</strong>:已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。<br> <strong>量化管理级</strong>:分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。<br> <strong>优化管理级</strong>:过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。<br> 6、五个公共属性<br> 目标 ：<br> 每一个KPA都确定了一组目标，若这组目标在每一个项目都能实现，则 说明企业满足了该KPA的要求。若满足了一个级别的所有KPA要求，则表明达到了这个级别所要求的能力。<br> 实施能力：<br> 实施能力一般包括资源保证、人员培训等内容。它是企业实施KPA的前提条件。企业必须采取措施，在满足了这些条件后，才有可能执行KPA的活动。<br> 执行活动：<br> 　 执行过程描述了执行KPA所需求的必要角色和步骤，一般包括计划、执行的任务、任务执行的跟踪等。在五个公共属性中，执行活动是唯一与项目执行相关的属性，其余四个属性则涉及企业CMM能力基础设施的建立。<br> 度量分析：<br> 　 描述了过程的度量和度量分析要求。典型的度量和度量分析的要求是确定执行活动的状态和执行活动的有效性。<br> 实施验证：　<br> 验证执行活动是否与建立的过程一致。实施验证涉及到管理的评审和审计以及质量保证活动。<br> 7、<strong>CMMI评估</strong>，也有人称是CMMI认证，“认证”是国内的叫法习惯。要获得正宗的CMMI证书，是要经过主任评估师对企业的软件项目评估通过后才会颁发证书，这里要强调的是，发证书是以主任评估师的<strong>个人名义</strong>签发的，并不是由认证机构发的。<br> 8、CMMI过程改进实施方案<br> 需求管理、品质管理、项目管理</p> 
<h3><a id="SOAWeb_382"></a><strong>SOA与Web服务</strong></h3> 
<p>1、SOA与Web服务的区别<br> （1）<strong>Web服务是技术规范，而SOA是设计原则。</strong><br> （2）从本质上来说，SOA是一种<strong>架构模式</strong>，而Web服务是<strong>利用一组标准实现的服务</strong>。<strong>Web服务是实现SOA的方式之一</strong>。用Web服务来实现SOA的好处是你可以实现一个<strong>中立平台，来获得服务</strong>，而且随着越来越多的软件商支持越来越多的Web服务规范，你会取得更好的通用性。<br> 2、<strong>面向服务的体系结构（SOA），是一个组件模型</strong>，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。</p> 
<p>3、服务是整个SOA实现的核心。SOA的基本元素是服务，SOA 指定一组实体(服务提供者、服务消费者、服务注册表、服务条款、服务代理和服务契约)，这些实体详细说明了如何提供和消费服务。这些服务是可互操作的、独立的、模块化的、位置明确的、松耦合的并且可以通过网络查找其地址。</p> 
<p>4、为什么选择SOA?<br> （1）不同种类的操作系统，应用软件，系统软件和应用基础结构（application infrastructure）相互交织，这便是IT企业的现状。一些现存的应用程序被用来处理当前的业务流程（business processes），因此从头建立一个新的基础环境是不可能的。<br> （2）企业应该能对业务的变化做出快速的反应，利用对现有的应用程序和应用基础结构（application infrastructure）的投资来解决新的业务需求，为客户，商业伙伴以及供应商提供新的互动渠道，并呈现一个可以支持有机业务（organic business）的构架。<br> （3）SOA凭借其松耦合的特性，使得企业可以按照模块化的方式来添加新服务或更新现有服务，以解决新的业务需要，提供选择从而可以通过不同的渠道提供服务，并可以把企业现有的或已有的应用作为服务， 从而保护了现有的IT基础建设投资。</p> 
<p>5、简单对象访问协议（SOAP）<br> SOAP= HTTP+RPC+ XML<br> 即: SOAP以HTTP作为底层通讯协议<br> 以RPC作为一致性的调用途径<br> 以XML作为数据传送的格式</p> 
<p>6、SOAP概述<br> 许多程序通过使用远程过程调用（RPC）在诸如 DCOM（分布式组件对象模型 ） 与 CORBA（Common Object Request Broker Architecture,公共对象请求代理体系结构 ） 等对象之间进行通信。但RPC 会产生兼容性以及安全问题；防火墙和代理服务器通常会阻止此类流量。通过 HTTP 在应用程序间通信是更好的方法，因为 HTTP得到了所有的因特网浏览器及服务器的支持，SOAP 就是被创造出来完成这个任务的。</p> 
<h3><a id="_405"></a>面向对象软件建模技术（重点）</h3> 
<p>1、UML: Unified Modeling Language 统一建模语言<br> 作为建模语言,UML由以下几部分构成:<br> ●基本语言组成 语言的构成成分,包括:要素，关系，图<br> ●语义规则: 语言的语法和语义规则<br> ●公共机制: 规范说明,语言扩展等<br> 关系: UML定义的模型元素之间的关系,包括四种:<br> 关联：本指事物之间存在的固有的牵连关系，在UML中，是对具有共同结构特征、关系和语义的对象或实例之间的链接描述。表示：一条实线<br> 泛化：在UML中，描述事物之间的一般和特殊关系。特殊事物具有并继承一般事物的特性。<br> 表示：一条带空心三角形箭头的实箭线<br> 依赖：两个要素之间的因果关系，其中一个要素（独立要素）发生变化会影响另外一个要素（依赖要素）的语义。表示：一条虚箭线<br> 实现：描述类元之间的语义关系，表示说明和实现间的关系。一种是接口与实现它的类和构件；另一种是用例和实现它们的协作。表示：一条带空心三角形箭头的虚箭线。<br> 2、UML中的图<br> UML共定义了9种图:用例图、状态图、类图、活动图、对象图、构件图、 顺序图 、部署图和协作图。<br> 用例图：<br> 用例:是外部可见的一个系统功能单元。<br> 作用:描述一组用例,参与者及其它们之间的关系，是外部用户所能观察到的系统功能的模型图。用于需求建模。<br> 用例用椭圆表示<br> 参与者（actor）是外部需要与系统交互的事物。也被称为活动者。<br> 参与者的三种类型<br> ①. 人：客户，读者，库管员<br> ②. 设备：计算机，磁盘，读卡机等<br> ③. 外部系统：上层系统等<br> 用例之间可以具有以下几种关系：<br> ①. 关联关系：参与者与用例之间是关联关系，表示参与者与用例之间具有使用，交互信息的关联。<br> ②. 泛化关系：参与者与参与者之间，用例与用例之间存在一般与特殊的关系。<br> ③. 包含关系 ：两个用例之间，一个用例(基本用例)的行为包含了另外一个用例(包含用例)的行为。 包含关系用依赖关系的&lt;&gt;构造型来表示，箭头指向被包含的用例。<br> ④. 扩展关系：扩展关系表示基本用例在扩展点要增加新的行为或功能，以扩展到新用例。 扩展关系用依赖关系的&lt;&gt;构造型来表示，箭头指向被扩展的用例。<br> 用例的描述：自然语言；内容：用例的目标用例是怎么启动的、参与者和用例之间的消息是如何传送的、用例中除了主路径外，其它路径是什么、用例结束后的系统状态、其它需要描述的内容<br> 案例：<br> 某学校网上选课系统的用例分析<br> 管理员通过系统管理界面进入系统，建立本学期要开设的各种课程，将课程信息保存到系统中，并可以对课程进行改动和删除。学生通过客户机浏览器进入系统，选择课程：可以查询课程，选择课程，支付课程费用。<br> ① 找出系统外部参与者，确定系统边界和范围。</p> 
<p>② 确定各参与者所期望的系统行为。<br> 管理员： 增加课程、修改课程、删除课程<br> 学生： 查询课程、选择课程、网上付费<br> ③ 把这些系统行为命名为用例。</p> 
<p>④ 确定各用例之间的关系(泛化，包含，扩展)。</p> 
<p>⑤ 绘制用例图。</p> 
<p>⑥ 编制用例说明。<br> ● 用例：增加课程<br> ●参与者：管理员<br> ●操作流：<br> ① 管理员选择进入管理界面，用例开始。<br> ② 系统提示输入管理员密码。<br> ③ 管理员输入密码。<br> ④ 系统检验密码。<br> A1：密码出错。<br> ⑤ 进入管理界面，系统显示当前所建立的全部课程信息。<br> ⑥ 管理员选择增加课程，管理员输入新课程信息。<br> ⑦系统验证是否与已有课程冲突。<br> 　　Ａ２：有冲突。<br> 　 ⑧系统添加新课程，并提示添加成功。<br> 　 ⑨系统回到管理主界面，显示所有课程，用例结束。<br> ⑦ 对异常流程确定单独用例。<br> ⑧ 优化用例图，解决用例之间的冲突和重复。</p> 
<p>类图及对象图：<br> 类(class): 具有相似结构、行为和关系的一组对象。<br> 类的表示：</p> 
<p>类的其他几种表示形式：<br> 简化表示：</p> 
<p>缩略表示：</p> 
<p>实体类对应着现实中的客观实物，用来保存信息，一般对应着数据表、文件等。实体类可以从现实中存在的客观事物，以及需要持久存放的信息两方面来发现。</p> 
<p>边界类位于系统与外界的交界处,承担系统与外界的信息功能.边界类处在用例图中,参与者与用例的关联处,可以根据用例图发现边界类。<br> 控制类承担着事务处理，控制调控的控制作用。一个用例中最少会有一个控制类，用来控制用例中的事件顺序，也可以在多个用例之间协调用例之间的联系。</p> 
<p>类名：名词或名词短语(动词或动词短语表示控制类)；尽可能用明确、简短，业务领域中事物的名称,避免使用抽象、无意义的名词；用英文，第1个字母大写；可分为简单类名，带路径类名。<br> 属性(attribute): 描述类所表示事物的静态性质。<br> 操作(operation): 描述类所表示事物的动态性质。<br> 关联的定义：表示事物之间的一种牵连式的固有联系。关联一定指的是类中对象与类中的对象之间的连接对应关系。<br> 聚集(aggregation): 表示类之间一种松散的整体与部分的组成关系，是一种特殊的关联。<br> 组合(composition): 表示类之间一种紧密的整体与部分的组成关系，也是一种特殊的关联。<br> 泛化(generalization): 表示事物之间的一般与特殊的关系。也可以称为继承关系。<br> 依赖(dependency): 表示两个元素X、Y，如果X的变化必然导致Y的变化，则称Y依赖X。<br> 建立类图的一般步骤：<br> ① 研究分析问题领域，确定系统需求；<br> ② 确定类，明确类的含义和职责，确定类的属性和操作；<br> ③ 确定类之间的关系。关联，泛化，聚集，组合，依赖；<br> ④ 调整和细化类及其关系，解决重复和冲突；<br> ⑤ 绘制类图，并增加相应说明。<br> 对象图的概念：对象图表示一组对象及其它们之间的联系。<br> 对象类： 可以实例化为对象的类。我们前面所提的例子都属于对象类。<br> 抽象类：不能直接产生实例的类。抽象类的类名一般被写成为斜体。</p> 
<p>顺序图(sequence diagram): 用来描述为了完成确定事务，对象之间按照时间消息交互的顺序关系。<br> 建立顺序图 ：<br> ① 从用例中识别交互过程;<br> ② 识别参与交互过程的对象;<br> ③ 为每一个对象设置生命线,并确定对象的存在期限;<br> ④ 从引发交互的初始消息开始,在对象生命线上依次画出交互的消息;<br> ⑤如果需要,可以给消息增加时间约束,以及前置条件和后置条件。<br> 实例：图书馆借书处理的顺序图</p> 
<p>● 用例：借书<br> ●参与者：管理员,借阅者<br> ●操作流：<br> ① 管理员进入图书借阅界面，用例开始。<br> ② 系统要求输入借阅者的借书证编码。<br> ③系统检验借书证编码,如果正确,则显示借阅者的信息。<br> A1：借书证编码有错。<br> A2: 如果该借阅者所借图书已经超期,则提示,本次拒借.<br> ④ 系统要求输入所借图书的条码。<br> ⑤ 系统显示所借图书的信息。<br> ⑥ 确认借书。<br> ⑦系统回到上一界面，等待处理下一借书。<br> ① 识别交互过程。<br> 读者在借书时，先由管理员把借书证上的读者编号扫描给系统，系统检查这个读者的借书证合法信息,如果不合法,则系统给出提示,如果正确系统返回读者的身份信息，以及读者的借阅信息。<br> 如果读者借书数量没有超过借书的上限，则把要借书的图书编号输入系统，系统登记借书信息，并返回借书成功信息，借书过程完成。<br> ② 识别参与交互过程的对象；</p> 
<p>绘制借书处理类图</p> 
<p>③ 为每一个对象设置生命线,并确定对象的存在期限；</p> 
<p>④ 从引发交互的初始消息开始,在对象生命线上依次画出交互的消息</p> 
<p>⑤ 绘制顺序图</p> 
<p>活动图<br> 活动图(activity diagram)是UML的动态视图之一，用来描述事物或对象的活动变化流程。<br> 活动图的要素：<br> 活动(Action): 是活动图主要结点,用两边为弧的条形框表示,中间填活动名 。<br> 活动流(ActionFlow): 描述活动之间的有向关系，反映一个活动向另外一个活动之间的转移。用带箭头的实线表示。<br> 分支: 表示活动流的分叉和合并。表示从一个活动按照某种条件转移到几个不同的活动。<br> 分劈和汇合: 表示并发的同步行为，用同步杆表示。<br> 泳道(swimlane): 是活动图中的区域划分，每一个泳道代表一个责任区域。一个泳道中包括一组相关活动。<br> 对象流: 反映活动与对象之间的依赖关系，表示对象对活动的作用或活动对对象的影响，用依赖关系表示。</p> 
<p>状态图(statechart diagram): 用来描述一个特定的对象所有可能的状态,以及由于各种事件的发生而引起的状态之间的转移和变化。</p> 
<p>协作图(collaboration diagram): 用来描述为了完成确定事务，各对象之间消息联系的结构关系。</p> 
<p>部署图(deployment diagram): 用来描述系统中计算结点的拓扑结构和通信路径与结点上运行的软件构件等。</p> 
<p>构件图(component diagram): 描述构件及其相互关系的图。构件之间是依赖关系。</p> 
<p>包图由包和包之间的联系构成，包图中的图形元素是包，包之间用依赖关系或泛化关系连接。包图是对系统结构建模的重要工具。</p> 
<h3><a id="_585"></a>软件测试（重点）</h3> 
<p>1、测试目标：测试是一个为了发现错误而执行程序的过程；好的测试用例能够发现至今尚未发现的错误；一个成功的测试是发现了至今尚未发现的错误。<br> 2、测试用例是为某个测试目标而编制的一组测试输入、执行条件以及预期结果的方案，以便测试某个程序路径或核实是否满足某个特定需求。<br> 3、测试技术：黑盒测试和白盒测试<br> 4、测试环境：静态分析和动态测试<br> 5、测试的功能：配置测试、兼容性测试、压力测试、语言测试、文档测试和特殊测试。<br> 6、测试步骤与策略<br> 单元测试、集成测试、确认测试、系统测试、α测试、β测试</p> 
<p>7、测试用例的好处：<br> （1）测试用例反映了用户的需求。<br> （2）对测试过程可以进行有效的监督，可以准确、有效的评估测试的工作量。<br> （3）可以对测试结果进行评估，并且对测试是否完成产生一个量化的结果。<br> （4）可以在回归测试的过程中准确、快速的进行正确的回归。<br> （5）测试用例的使用令软件测试的实施重点突出、目的明确。<br> （6）在开始实施测试之前设计好测试用例，可以避免盲目测试并提高测试效率。<br> 8、测试用例的格式：<br> 编号：唯一编号<br> 前置条件：说明测试路径<br> 输入：输入的条件<br> 期望输出：期望输出的结果<br> 实际输出：实际输出的结果<br> 是否正确：是/否<br> 执行人：测试用例执行人标志<br> 执行时间：测试用例执行的时间<br> 9、测试用例的设计：<br> 测试用例应基于用户需求、测试用例应考虑使用对象、测试用例设计应由粗到细、所有的用例都必须经过评审。<br> 10、黑盒测试<br> 黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。<br> 等价分类法基本思想：<br> 将所有可能的输入数据划分成若干个等价类；有效等价类(合理等价类)和无效等价类(不合理等价类)<br> 案例：<br> 例:某报表处理系统要求用户输入处理报表的日期，日期限制在2001年1月至2005年12月，即系统只能对该段期间内的报表进行处理，如日期不在此范围内，则显示输入错误信息。<br> 系统日期规定由年、月的6位数字字符组成，前四位代表年，后两位代表月。<br> 如何用等价类划分法设计测试用例,<br> 来测试程序的日期检查功能？<br> 第一步：等价类划分</p> 
<p>第二步：设计有效类的测试用例<br> 对表中编号为1,2,3的3个有效等价类用一个测试用例覆盖</p> 
<p>第三步：设计无效类的测试用例<br> 不能出现相同的测试用例</p> 
<p>边界值分析法基本思想：<br> 边界值分析法是使用一些输入/输出值正好等于、小于或大于边界值的测试用例对程序进行测试。边界值分析法作为一种测试技术，通常作为等价分类法的补充。<br> 因果图：<br> 因果图是设计测试用例的一种工具，它主要检查各种输入条件的组合。等价类划分、边界值分析的测试用例设计方法还不能考虑到组合输入条件可能引起软件错误，而因果图法则弥补了这个不足之处。<br> 错误推测法基本思想：<br> 列举出程序可能有的错误和容易发生错误的特殊情况，并据此设计测试用例。<br> 11、白盒测试<br> 白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。<br> 测试方法：<br> 逻辑覆盖法</p> 
<p>案例：源程序<br> void DoWork(int x,int y,int z)<br> {<!-- --><br> int k=0,j=0;<br> if ((x&gt;3)&amp;&amp;(z&lt;10))<br> {<!-- --><br> k=x<em>y-1; //语句块1<br> j=sqrt(k);<br> }<br> if ((x= =4)||(y&gt;5))<br> {<!-- --><br> j=x</em>y+10; //语句块2<br> }<br> j=j%3; //语句块3<br> }</p> 
<p>语句覆盖测试用例可设计为：<br> { x=4、y=5、z=5}<br> 判断覆盖测试用例可设计为：<br> { x=4、y=5、z=5}，通过的路径为abd；<br> { x=2、y=5、z=5}，通过的路径为ace。<br> 条件覆盖<br> 对于第一个判断：<br> 条件x&gt;3 取真值为T1，取假值为-T1<br> 条件z&lt;10 取真值为T2，取假值为-T2<br> 对于第二个判断：<br> 条件x=4 取真值为T3，取假值为-T3<br> 条件y&gt;5 取真值为T4，取假值为-T4<br> 测试用例 通过路径 条件取值 覆盖分支<br> x=4,y=6,z=5 abd T1,T2,T3,T4 bd<br> x=2,y=5,z=5 ace -T1,T2,-T3,-T4 ce<br> x=4,y=5,z=15 acd T1,-T2,T3,-T4 cd<br> 判断/条件覆盖</p> 
<p>条件组合覆盖</p> 
<p>基本路径测试<br> 基本思想：在程序控制流图的基础上，通过分析控制构造的环复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每一个可执行语句至少执行一次。<br> 基本步骤：绘制程序的控制流图G ；计算程序环复杂度V(G)；根据V(G)导出测试用例；设计测试用例。<br> 案例：源程序<br> void Sort(int iRecordNum,int iType)<br> 1 {<!-- --><br> 2 int x=0;<br> 3 int y=0;<br> 4 while (iRecordNum &gt; 0)<br> 5 {<!-- --><br> 6 if(0==iType)<br> 7 x=y+2;<br> 8 else<br> 9 if(1= =iType)<br> 10 x=y+10;<br> 11 else<br> 12 x=y+20;<br> 13 }<br> 14 }</p> 
<p>给定流图G的环复杂度－V(G) 有两种计算方法：<br> V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量<br> E=10，N=8，V(G)=10-8+2=4<br> V(G)=P+1，P是流图G中判定结点的数量<br> 流图中有三个判定结点4、6、8，所以V(G)=3+1=4</p> 
<p>12、单元测试：<br> 主要内容：模块接口、边界测试、重要执行路径、局部数据结构、错误处理、边界测试。<br> 驱动模块(driver)相当于所测模块的主程序。它接收测试数据，把这些数据传送给所测模块，最后再输出实际测试结果。<br> 桩模块(stub)用于代替所测模块调用的子模块。桩模块可以做少量的数据操作<br> 13、集成测试<br> 集成测试的目的：集成一般不可能一次成功，集成中总存在这样那样的错误 ；当将多个模块通过接口相连集成在一起时，数据可能在接口中产生错误甚至丢失；集成后一个模块可能对另一个模块产生副作用，全局的数据结构也有可能出现问题<br> 集成策略：非增量式集成，即按照系统结构图一次性地将所有模块全部组装起来，然后进行测试，也就是所谓的“一步到位” –注定要失败<br> 增量集成，即按照系统结构图采用自顶而下或自底向上的方式一步一步地构造测试，逐步组装直到系统完成。<br> 集成的方式：<br> 自顶而下集成：首先集成主控模块(主程序)，然后按照系统结构图的层次结构逐步向下集成。<br> 自底向上集成是从系统结构的最底层的模块开始来构造系统的，逐步安装，逐步测试。<br> 自底向上集成的特点：不再需要桩模块，但它需要驱动模块；设计测试用例比较容易；只有将最后一个模块组装完成后，系统才能作为一个整体存在。<br> 14、确认测试<br> 确认测试又称有效性测试、合格测试或验收测试。<br> 确认测试主要由使用用户参加测试，检验软件规格说明的技术标准的符合程度，是保证软件质量的最后关键环节。<br> 确认测试内容或步骤主要包括<br> 有效性测试：要求在模拟环境下通过一系列黑盒测试以验证所测软件功能与用户的需求是否一致 。<br> 配置复审：可执行程序、源程序、配置脚本、测试程序或脚本；主要的开发类文档；主要的管理类文档。<br> α测试：指软件开发公司组织内部人员模拟各类用户或由某些用户在开发场所对即将面市的软件产品（称为α版本）进行测试，试图发现错误并修正。在开发机构的监督下，由个别用户在确认测试阶段后期对软件进行测试，目的是评价软件的FLURPS（功能、局域化、可使用性、可靠性、性能和支持），注重界面和特色。<br> β测试：软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，并要求用户报告异常情况、提出批评意见。然后软件开发公司再对β版本进行改错和完善 。由软件的多个用户对FLURPS进行测试，主要目的是测试系统的可支持性。<br> 15、系统测试<br> 系统测试是将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行(使用)环境下，对计算机系统进行一系列的组装测试和确认测试。<br> 系统测试分为功能性测试和非功能性测试：<br> 功能性测试分为正常功能测试和健壮性测试：<br> 健壮性测试主要检查系统的容错能力，也叫容错性测试、恢复测试。当系统出错时，能否在指定的时间间隔内修正错误并重新启动系统。<br> 非功能性测试包括安全性测试、强度（压力）测试、性能测试等：<br> （1）系统的安全性测试是要检验在系统中已存在的保密性、完整性、可用性、不可否认性、可控性等措施是否发挥作用，有无漏洞。<br> （2） 强度（压力）测试是要检查在系统运行环境不正常到发生故障的时间内，系统可以运行到何种程度的测试。强度测试是在要求一个非正常数量、频率或容量资源方式下运行一个系统。<br> （3）性能测试就是测试软件在被组装进系统的环境下运行时的性能。性能测试应覆盖测试过程的每一步。即使在单元层，单个模块的性能也可以通过白盒测试来评价，而不是等到所有系统元素全组装以后，再确认系统的真正性能。性能测试有时是与强度测试联系在一起的，常常需要硬件和软件的测试设备。主要测试有关功能操作的响应时间。<br> 16、测试层次<br> 17、自动化测试（automated test）是相对手工测试（manual test）而存在的一个概念，由手工逐个地运行测试用例的操作过程被测试工具自动执行的过程所代替。<br> 18、自动化测试焦点集中在测试执行，主要是由测试工具自动地完成测试。<br> 19、测试自动化指“一切可以由计算机系统自动完成的测试任务都已经由计算机系统或软件工具、程序来承担并自动执行”<br> 20、自动化测试的特点<br> 自动运行的速度快、测试结果准确、高复用性、永不疲劳、可靠、独特的能力<br> 21、自动化测试带来的好处<br> 测试周期缩短；更高质量的产品；软件过程更规范；高昂的团队士气；节省人力资源，降低企业成本；充分利用硬件资源，降低企业成本。<br> 11、回归测试<br> 回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p> 
<h2><a id="_746"></a>选择题</h2> 
<p>具有风险分析的软件生命周期模型是（  C   ）。<br> A.瀑布模型      B.喷泉模型  C.螺旋模型        D.增量模型</p> 
<p>在结构化分析方法中，（ C ）表达系统内部数据运动的图形化技术。<br> A. 数据字典         B. 实体关系图   C. 数据流图         D. 状态转换图</p> 
<p>为了提高模块的独立性，模块内部最好是（  C  ）。//外部耦合，功能内聚<br> A．逻辑内聚       B．时间内聚     C．功能内聚       D．通信内聚</p> 
<p>模块的内聚性最高的是（  D  ）。<br> A．逻辑内聚       B．时间内聚  C． 偶然内聚       D．功能内聚</p> 
<p>在白盒测试技术测试用例的设计中，（  B  ）是最强的覆盖标准。<br> A．语句覆盖       B．路径覆盖  C． 条件组合覆盖      D．判定覆盖</p> 
<h2><a id="_761"></a>判断题</h2> 
<blockquote> 
 <p>敏捷开发提倡一个迭代 80%以上的时间都在编程,几乎没有设计阶段。敏捷方法可以说是一种无计划性和纪律性的方法。（ ）</p> 
</blockquote> 
<p>这表述并<strong>不准确</strong>。敏捷开发并不是无计划性和纪律性的方法，而是强调<strong>灵活性、快速响应变化</strong>的一种方法。敏捷方法确实强调在软件开发过程<strong>中尽早、尽快地交付</strong>可工作的软件，并在实际使用中获取反馈。然而，这并不意味着没有计划和纪律。</p> 
<p>敏捷开发包含一系列的实践和原则，其中之一是“个体和交互高于流程和工具”，强调了个体之间的沟通和协作。另一个原则是“响应变化高于遵循计划”，强调了对需求和优先级的灵活性。</p> 
<p>至于设计阶段，敏捷开发并不是完全没有设计，而是强调<strong>轻量级的设计</strong>、<strong>简单性和代码的可维护性</strong>。在敏捷中，设计是一个<strong>持续</strong>的过程，而不是一个单一的阶段。敏捷开发团队通常会在<strong>迭代</strong>中进行设计工作，以满足当前需求，并随着时间的推移进行适应性设计。</p> 
<p>总体而言，敏捷开发是一种注<strong>重灵活性和快速交付</strong>的方法，但它并不意味着没有计划和纪律，而是强调<strong>在变化环境中</strong>的<strong>灵活响应和持续改进。</strong></p> 
<p>12、敏捷开发模型：它以用户的需求进化为核心，采用<strong>迭代、循序渐进</strong>的方法进行软件开发。</p> 
<blockquote> 
 <p>CMMMI 的“已定义级”的主要内容包括:建立了基本的项目管理过程来跟踪<br> 费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得 的成功经验。（ ）<br> <img src="https://images2.imgbox.com/a9/40/3MPllgqD_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="_780"></a>简答题</h2> 
<blockquote> 
 <p>1、说明单元测试和集成测试的在测试内容和测试方法上的区别。</p> 
</blockquote> 
<blockquote> 
 <p>2、为什么说 CMMI 不是一套可以直接拿来用的过程?</p> 
</blockquote> 
<p>定义：CMMI 是Capability maturity model integration,软件能力成熟度模型集成<br> 目的：对软件工程<strong>过程</strong>进行管理和改进，增强开发和改进能力，从而按时，不超预算的开发出高质量软件<br> 软件工程三要素：工具、方法、过程<br> 过程的定义：为实现预定目标，而执行的一组实践活动，包含工具、方法、材料、人员<br> 为什么不可以直接用：CMMI 提供的是一个标准化的东西，而每个企业，每个软件开发和维护有着不同的特点，要根据不同的软件做出不同的响应。<br> CMMI模型分为阶段性的表示方法和连续性的表示方法<br> 阶段式表现方法仍然把CMMI中的若干个过程域分成了5 个成熟度级别，帮助实施CMMI的组织建议一条比较容易实现的过程改进发展道路。<br> 连续式表现方法则通过将CMMI中过程域分为四大类：过程管理、项目管理、工程以及支持。<br> CMMI 五个标准：初始级、已管理、已定义、量化管理、优化管理<br> CMMI 五个公共属性：目标、实施能力、执行活动、度量分析、实施验证<br> CMMI评估：主任评估师对软件项目进行评估后，以个人名义颁发证书<br> <img src="https://images2.imgbox.com/25/2d/WGhtJMSv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3、简述 SOAP 的作用。说明为什么该协议可以穿透防火墙?</p> 
</blockquote> 
<p>SOAP是simple object access protocol简单对象访问协议<br> SOAP=HTTP（底层通信协议）+RPC（调用途径）+XML（消息传递的格式）<br> SOAP是一个框架模式，以Web服务为核心，</p> 
<p>简单对象访问协议（Simple Object Access Protocol，SOAP）是一种用于在<strong>网络上交换结构化信息的协议</strong>。它是<strong>一种基于 XML（可扩展标记语言）的通信协议</strong>，用于在<strong>分布式系统中的应用程序</strong>之间进行信息传递。以下是 SOAP 的一些关键特点和组成部分：</p> 
<ol><li> <p><strong>XML格式：</strong> SOAP 使用 XML 格式来定义消息的结构和内容。XML是一种通用的标记语言，具有可读性和可扩展性，因此非常适合用于描述结构化数据。</p> </li><li> <p><strong>协议独立性：</strong> SOAP 不依赖于任何特定的底层协议，可以在多种传输协议上运行，包括HTTP、SMTP、FTP等。然而，最常见的是在HTTP上使用SOAP。</p> </li><li> <p><strong>消息模型：</strong> SOAP 的通信是基于消息的，每个消息包含一个由 XML 构成的数据块。消息可以包括请求、响应以及其他与应用程序相关的信息。</p> </li><li> <p><strong>标准化：</strong> SOAP 是由国际组织制定的标准，因此具有跨平台、跨语言的特性。这使得不同语言和平台上的应用程序能够相互通信。</p> </li><li> <p><strong>Web服务：</strong> SOAP 常常与 Web 服务（Web Services）相关联。Web服务是一种通过网络进行通信的软件系统，它们使用 SOAP 作为消息协议，通过HTTP进行通信。</p> </li></ol> 
<p>SOAP 的使用使得在异构系统之间进行通信变得更加容易，它被广泛应用于Web服务和其他分布式系统中。</p> 
<p>关于为什么 SOAP 可以穿透防火墙，有以下一些因素：</p> 
<ol><li> <p><strong>使用 HTTP 作为传输协议：</strong> 大多数防火墙允许 HTTP 流量通过，因为 HTTP 是Web浏览器和服务器之间标准的通信协议。由于 SOAP 常常使用 HTTP 作为传输协议，因此可以更容易穿透防火墙。</p> </li><li> <p><strong>利用已开放的端口：</strong> SOAP 使用标准的端口（如80端口）进行通信，这通常是防火墙默认开放的端口，使得 SOAP 可以通过防火墙进行通信。</p> </li><li> <p><strong>HTTP代理：</strong> SOAP 可以通过支持 HTTP 代理的方式进行通信。防火墙内部的 HTTP 代理可以代理 SOAP 请求和响应，使得跨越防火墙的通信成为可能。</p> </li></ol> 
<p>需要注意的是，虽然 SOAP 在设计上具有穿透防火墙的特性，但具体是否能够成功穿透防火墙还取决于防火墙的配置和策略。</p> 
<blockquote> 
 <p>4、简述应用软件安全的重要性。说明如何应用信息安全等级来保护应用软件的安全性?<br> 5、简述软件架构对软件开发的作用。说明目前主流的软件架构的技术特点。</p> 
</blockquote> 
<blockquote> 
 <p>6、传统的结构化方法与面向对象方法在……的需求和设计建模上有所使用的工具有何不同？</p> 
</blockquote> 
<p>结构化分析方法：面向数据的方法，以数据流为中心 。其核心概念包括：数据流、数据存储、外部实体、数据组和数据元素。基本思想：自顶向下和逐层分解。<br> 面向对象的分析方法 ：面向对象分析以对象及其服务作为建模标准，比较自然，对象也具有相对的稳定性。</p> 
<p>传统的结构化方法和面向对象方法在需求和设计建模上使用的工具有所不同。以下是两者之间主要区别的一些关键方面：</p> 
<ol><li><strong>结构化方法（例如，结构化分析与设计）：</strong></li></ol> 
<ul><li> <p><strong>数据流图（DFD）：</strong> 结构化方法常使用数据流图来描述系统中的数据流、处理和数据存储之间的关系。DFD用于可视化系统的功能和流程。</p> </li><li> <p><strong>数据字典：</strong> 用于定义系统中使用的数据元素及其属性，以及数据流、数据存储和处理过程的详细信息。</p> </li><li> <p><strong>结构化语言（如COBOL，FORTRAN）：</strong> 结构化方法通常使用传统的结构化编程语言，这些语言以过程为中心，关注数据和控制流。</p> </li></ul> 
<ol start="2"><li><strong>面向对象方法（例如，UML - 统一建模语言）：</strong></li></ol> 
<ul><li> <p><strong>类图：</strong> 面向对象方法使用类图来表示系统中的类、对象及它们之间的关系。类图显示了系统中的静态结构。</p> </li><li> <p><strong>用例图：</strong> 描述系统的用例（用户场景），以及用户与系统之间的交互。用例图有助于识别系统的功能需求。</p> </li><li> <p><strong>时序图和协作图：</strong> 用于可视化对象之间的时序和协作关系，强调对象在系统中的交互。</p> </li><li> <p><strong>行为图（状态图，活动图）：</strong> 用于表示系统中对象的行为和状态变化。</p> </li><li> <p><strong>面向对象编程语言（如Java，C++）：</strong> 面向对象方法使用编程语言，这些语言支持面向对象的概念，例如封装、继承和多态。</p> </li></ul> 
<p>总体来说，两者在需求和设计建模上的不同点主要在于：</p> 
<ul><li>结构化方法更注重<strong>过程和数据流</strong>的控制，使用<strong>数据流图</strong>等来描述系统的功能。</li><li>面向对象方法更注重<strong>对象和类</strong>的抽象，使用<strong>类图、用例图</strong>等来描述系统的结构和行为。</li></ul> 
<p>随着软件工程的发展，面向对象方法逐渐取代了传统的结构化方法，因为它更符合现代软件开发中的复杂性和可维护性的需求。UML作为面向对象方法的标准建模语言，在需求和设计建模上得到了广泛的应用。</p> 
<blockquote> 
 <p>7、CMMI 是什么？简述其对软件项目管理的重要作用。</p> 
</blockquote> 
<p>CMMI是capability maturity model integration 软件能力成熟度集成，<br> 目的：对软件工程过程进行管理和改进，增强开发和改进能力，从而按时，不超预算的设计出高质量软件<br> 软件工程三要素包括工具、方法、过程。过程是为实现预定目标，而执行的一系列实践活动，包含工具、方法、材料、人员<br> CMMI 包含了五个标准：初始化、已管理、已定义、量化管理、优化管理<br> <img src="https://images2.imgbox.com/17/34/2FRhIIbR_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>8、简述 WEB 服务的定义与特点，并说明 SOA 和 REST 架构的异同之处。</p> 
</blockquote> 
<p>SOA（Service-Oriented Architecture），Web服务和RESTful是三种与服务和系统集成相关的架构和设计理念。</p> 
<p>SOA（Service-Oriented Architecture）:</p> 
<ul><li> <p><strong>定义：</strong> SOA是一种<strong>面向服务</strong>的架构风格，它通过将应用程序的不同功能拆分为<strong>可独立部署和使用的服务</strong>，实现了<strong>松散耦合</strong>的<strong>分布式系统。</strong></p> </li><li> <p><strong>特点：</strong> SOA强调服务的<strong>可重用性、互操作性和松散耦合</strong>。服务是一种<strong>可通过网络进行访问的、独立的</strong>功能单元。</p> </li></ul> 
<p>Web服务：</p> 
<ul><li> <p><strong>定义：</strong> Web服务是一种实现SOA的<strong>技术实现</strong>，它使用**开放标准协议（如SOAP）和通信协议（如HTTP）**来实现不同系统之间的通信。</p> </li><li> <p><strong>特点：</strong> Web服务提供了一种通过网络进行<strong>跨平台和跨语言通信</strong>的方式。它使用标准的HTTP协议，因此可以<strong>很容易地穿透防火墙</strong>。</p> </li></ul> 
<p>RESTful：</p> 
<ul><li> <p><strong>定义：</strong> REST（Representational State Transfer）是一种<strong>架构风格</strong>，它强调使用<strong>标准的HTTP协议</strong>进行通信，<strong>而不依赖其他中间件</strong>。</p> </li><li> <p><strong>特点：</strong> RESTful架构<strong>使用资源的状态</strong>来进行通信，每个资源通过唯一的URI标识，并使用标准的<strong>HTTP方法</strong>（GET、POST、PUT、DELETE）进行操作。RESTful服务通常<strong>返回轻量级的数据格式</strong>，如<strong>JSON或XML</strong>。</p> </li></ul> 
<p>区别和联系：</p> 
<ul><li> <p><strong>协议：</strong> Web服务通常使用SOAP协议，而RESTful服务使用HTTP协议。</p> </li><li> <p><strong>风格：</strong> SOA是一种架构风格，而Web服务和RESTful是实现SOA的技术手段。</p> </li><li> <p><strong>状态：</strong> RESTful强调资源的状态，而Web服务通常使用基于操作的状态。</p> </li><li> <p><strong>数据格式：</strong> RESTful通常使用轻量级的数据格式，如JSON，而Web服务通常使用XML。</p> </li><li> <p><strong>使用场景：</strong> RESTful适用于轻量级、无状态的场景，而Web服务适用于需要复杂消息传递和事务支持的场景。</p> </li></ul> 
<p>总的来说，SOA是一种架构风格，而Web服务和RESTful是在实现SOA时所选择的具体技术和协议。RESTful是一种更轻量级和灵活的服务设计风格，相比之下，Web服务更加重量级。选择其中一种取决于具体的需求和系统特点。</p> 
<blockquote> 
 <p>简述软件漏洞和软件后门的区别，并说明他们各自的防范措施。</p> 
</blockquote> 
<p><strong>软件漏洞（Software Vulnerability）：</strong></p> 
<p>软件漏洞指的是在软件中存在的程序设计或实现上的错误，这些错误可能导致软件在运行时产生不安全的行为。漏洞可能是由于程序员的错误、设计缺陷或者未经充分测试而导致的。攻击者可以利用这些漏洞来执行恶意操作，例如越权访问、拒绝服务攻击、远程执行代码等。</p> 
<p><strong>防范措施：</strong></p> 
<ol><li> <p><strong>代码审查：</strong> 定期对软件代码进行审查，发现和修复潜在的漏洞。</p> </li><li> <p><strong>静态分析工具：</strong> 使用静态分析工具来检测代码中的潜在漏洞，这些工具可以自动分析代码并发现一些常见的安全问题。</p> </li><li> <p><strong>动态测试：</strong> 运行时进行漏洞扫描和测试，模拟攻击者的行为，检测系统在运行时的弱点。</p> </li><li> <p><strong>安全开发培训：</strong> 为开发人员提供安全开发的培训，使其具备发现和修复漏洞的能力。</p> </li><li> <p><strong>及时更新和修复：</strong> 及时应用软件厂商发布的安全更新和修复补丁，以防止已知漏洞被利用。</p> </li></ol> 
<p><strong>软件后门（Software Backdoor）：</strong></p> 
<p>软件后门是一种被故意插入到软件中的功能或代码，允许未经授权的用户在系统中执行非法操作。与漏洞不同，后门通常是有意设置的，可能是由软件开发者或者其他恶意方插入的。后门的目的可能是为了绕过安全控制、实现远程访问、收集敏感信息等。</p> 
<p><strong>防范措施：</strong></p> 
<ol><li> <p><strong>严格的访问控制：</strong> 实施最小权限原则，确保只有授权用户能够访问敏感部分的代码和数据。</p> </li><li> <p><strong>审查第三方代码：</strong> 在使用第三方软件或库时，审查其源代码以确保不存在潜在的后门。</p> </li><li> <p><strong>加密和数字签名：</strong> 使用加密和数字签名技术来确保软件的完整性，防止未经授权的修改。</p> </li><li> <p><strong>持续监控：</strong> 在运行时监控软件的行为，检测是否有异常的操作和未经授权的访问。</p> </li><li> <p><strong>定期审计：</strong> 对软件进行定期的安全审计，以发现潜在的后门或不正常的行为。</p> </li></ol> 
<p>总的来说，漏洞和后门都是安全领域需要关注的问题，防范措施需要综合考虑代码质量、开发过程、权限管理、监控等多个方面。</p> 
<blockquote> 
 <p>比较 LAMP 和 J2EE 框架（平台）的组成与优缺点。</p> 
</blockquote> 
<p><strong>LAMP 框架：</strong></p> 
<p>LAMP是一个<strong>开源的Web应用程序开发平台</strong>，由Linux操作系统、Apache HTTP服务器、MySQL数据库系统和PHP编程语言组成。</p> 
<p><strong>组成：</strong></p> 
<ol><li> <p><strong>Linux（操作系统）：</strong> 作为服务器端的操作系统，提供稳定性、安全性和性能。</p> </li><li> <p><strong>Apache（Web服务器）：</strong> 作为Web服务器，处理HTTP请求并向客户端提供网页。</p> </li><li> <p><strong>MySQL（数据库系统）：</strong> 提供数据存储和管理，支持关系型数据库。</p> </li><li> <p><strong>PHP（编程语言）：</strong> 用于服务器端的脚本编程，生成动态Web页面。</p> </li></ol> 
<p><strong>优缺点：</strong></p> 
<ul><li> <p><strong>优点：</strong></p> 
  <ol><li><strong>开源和免费：</strong> 所有组件都是开源的，没有额外的软件成本。</li><li><strong>易学易用：</strong> PHP语言易学易用，适合快速开发。</li><li><strong>灵活性：</strong> 可以选择不同的数据库（不仅限于MySQL），并可以使用其他编程语言替代PHP。</li></ol> </li><li> <p><strong>缺点：</strong></p> 
  <ol><li><strong>性能：</strong> 相对于J2EE，性能可能较低，特别是在大型和复杂的应用中。</li><li><strong>可伸缩性：</strong> 在处理大量并发请求时，可伸缩性可能受到限制。</li><li><strong>不适合大型企业应用：</strong> 对于大型企业级应用，可能不如J2EE适用。</li></ol> </li></ul> 
<hr> 
<p><strong>J2EE 框架（Java 2 Platform, Enterprise Edition）：</strong></p> 
<p>J2EE是一套用于开发企业级应用的Java平台，提供了一系列的规范和API，使得开发者可以构建大规模、可伸缩、分布式的应用。</p> 
<p><strong>组成：</strong></p> 
<ol><li> <p><strong>Java（编程语言）：</strong> 作为主要的开发语言，具有跨平台的特性。</p> </li><li> <p><strong>Enterprise JavaBeans（EJB）：</strong> 用于构建分布式组件的服务器端组件模型。</p> </li><li> <p><strong>JavaServer Faces（JSF）：</strong> 用于构建用户界面的Java Web应用程序的Web框架。</p> </li><li> <p><strong>Java Persistence API（JPA）：</strong> 用于持久性（数据库访问）的Java API。</p> </li><li> <p><strong>Java Message Service（JMS）：</strong> 用于在分布式系统中发送消息的API。</p> </li></ol> 
<p><strong>优缺点：</strong></p> 
<ul><li> <p><strong>优点：</strong></p> 
  <ol><li><strong>强大的企业级功能：</strong> J2EE提供了丰富的企业级功能，适用于大型和复杂的应用。</li><li><strong>可伸缩性：</strong> 具备良好的可伸缩性和性能，适用于处理大量并发请求。</li><li><strong>广泛的工具和框架支持：</strong> 有丰富的工具和框架支持，例如Spring、Hibernate等。</li></ol> </li><li> <p><strong>缺点：</strong></p> 
  <ol><li><strong>学习曲线：</strong> 相对于LAMP，J2EE有更高的学习曲线，需要更多的时间和经验。</li><li><strong>部署复杂性：</strong> 部署和配置J2EE应用程序可能相对较复杂。</li><li><strong>资源消耗：</strong> 一些J2EE应用可能对系统资源消耗较大。</li></ol> </li></ul> 
<hr> 
<p><strong>总结：</strong></p> 
<ul><li> <p><strong>LAMP适用于：</strong> 小型到中型规模的Web应用，对成本敏感，追求快速开发和简单性。</p> </li><li> <p><strong>J2EE适用于：</strong> 大型企业级应用，对可伸缩性和性能要求较高，有足够的开发资源和时间来投入学习和开发。</p> </li></ul> 
<blockquote> 
 <p>软件工程化思想的核心是什么？</p> 
</blockquote> 
<p>软件工程化思想的核心是通过系统性、规范化、可重复的方法来进行软件开发，以提高软件开发的质量、效率和可维护性。以下是软件工程化思想的核心要点：</p> 
<ol><li> <p><strong>系统性（Systematic）：</strong> 软件工程强调系统性的方法，即将软件开发过程划分为多个阶段，并在每个阶段采用明确的步骤和规范。这确保了开发过程的有序性和可控性。</p> </li><li> <p><strong>规范化（Standardization）：</strong> 引入标准和规范，确保在软件开发的不同阶段和不同项目中都能够遵循相似的流程和标准。标准化有助于提高软件的质量，减少错误和缺陷。</p> </li><li> <p><strong>可重复性（Repeatability）：</strong> 通过建立可重复的开发流程，使得相同的方法和过程可以在不同项目中被重复使用。这有助于提高开发效率，减少不必要的工作。</p> </li><li> <p><strong>工程化思想（Engineering Approach）：</strong> 将软件开发看作一项工程活动，采用类似于其他工程领域的方法来进行规划、设计、实施和测试。这包括项目管理、配置管理、需求分析等方面的工程化方法。</p> </li><li> <p><strong>质量控制（Quality Control）：</strong> 强调对软件质量的管理和控制，包括在开发过程中的各个阶段进行质量检查，以确保交付的软件符合预期的质量标准。</p> </li><li> <p><strong>迭代和增量开发（Iterative and Incremental Development）：</strong> 采用迭代和增量的开发方式，将开发过程分为多个小步骤，并在每一步中逐渐完善和改进软件。这有助于更灵活地应对需求变化和逐步构建复杂系统。</p> </li><li> <p><strong>团队协作（Team Collaboration）：</strong> 强调团队协作和沟通，将软件开发视为一个团队努力的结果。合理的团队结构和有效的沟通有助于提高开发效率和软件质量。</p> </li></ol> 
<p>软件工程化思想的目标是通过引入科学化和系统化的方法，使得软件开发更加可控、可预测，从而提高软件的质量、可维护性和客户满意度。</p> 
<blockquote> 
 <p>软件设计过程包括的主要内容是什么？</p> 
</blockquote> 
<p>软件设计是软件工程中的一个关键阶段，它涉及到定义软件系统的结构和组织方式，以满足系统需求。软件设计的主要内容包括以下几个方面：</p> 
<ol><li> <p><strong>需求分析和规格说明：</strong> 在软件设计的初期，需要仔细审查并理解系统的需求，包括功能需求、性能需求、安全需求等。这通常是基于需求分析和规格说明文档进行的。</p> </li><li> <p><strong>体系结构设计：</strong> 在体系结构设计阶段，确定系统的整体结构和组织方式。这包括划分系统为模块、定义模块之间的关系，以及确定数据流、控制流等。</p> </li><li> <p><strong>详细设计：</strong> 在详细设计阶段，对系统的每个模块进行详细设计，包括数据结构、算法、接口等。这一阶段通常涉及到设计文档的编写，以便开发人员能够按照设计文档进行编码。</p> </li><li> <p><strong>数据库设计：</strong> 对于涉及数据库的系统，需要进行数据库设计。这包括确定数据库表的结构、关系、索引等，以满足系统对数据的存储和检索需求。</p> </li><li> <p><strong>界面设计：</strong> 界面设计关注用户与系统之间的交互。这包括设计用户界面的外观、布局、交互方式等，以提供用户友好的体验。</p> </li><li> <p><strong>算法设计：</strong> 针对需要解决的问题，设计和选择合适的算法。算法设计涉及到优化、复杂度分析等方面，以确保系统在性能和效率上达到预期水平。</p> </li><li> <p><strong>安全性设计：</strong> 在设计阶段考虑系统的安全性，包括身份验证、授权、数据加密等。确保系统对潜在的安全威胁有有效的防护措施。</p> </li><li> <p><strong>性能设计：</strong> 考虑系统的性能需求，包括响应时间、吞吐量等。优化系统的设计以满足性能目标。</p> </li><li> <p><strong>测试策略设计：</strong> 在设计阶段制定测试策略，明确测试的范围、方法、工具等，以确保在开发完成后能够进行全面的测试。</p> </li></ol> 
<p>软件设计是一个迭代的过程，可能需要多次调整和修改。设计阶段的质量和准确性对于整个软件开发过程的成功至关重要。</p> 
<blockquote> 
 <p>13、风险分析三项活动包括的主要内容是什么？</p> 
</blockquote> 
<blockquote> 
 <p>14、简述面向对象的设计过程。</p> 
</blockquote> 
<p>面向对象的设计过程是软件工程中将系统需求转化为面向对象的软件设计的过程。这个过程通常包括以下几个主要步骤：</p> 
<ol><li> <p><strong>分析需求：</strong> 在设计开始之前，需要对系统的需求进行深入的分析。这包括与客户和利益相关者的沟通，收集和理解系统的功能需求和非功能需求。</p> </li><li> <p><strong>定义问题域：</strong> 将问题域划分为相关的概念和实体，识别系统中的类、对象、属性和关系。这是建立系统模型的起点。</p> </li><li> <p><strong>创建用例图：</strong> 使用用例图来描述系统的功能需求和各个参与者之间的关系。用例图有助于识别系统的用例（功能点）和参与者（系统和外部实体）。</p> </li><li> <p><strong>创建类图：</strong> 基于问题域的定义，创建类图来表示系统中的类、对象及它们之间的关系。这一步骤将问题域的概念映射到类和对象的设计中。</p> </li><li> <p><strong>定义类的行为：</strong> 对每个类定义其行为，即类的方法。这有助于明确每个类如何响应系统的各种操作和事件。</p> </li><li> <p><strong>创建序列图和协作图：</strong> 使用序列图和协作图来描述系统中的交互过程。这有助于表示系统中的消息传递和对象之间的协作。</p> </li><li> <p><strong>设计系统的状态：</strong> 对于需要处理状态变化的对象，设计相应的状态图。状态图描述了对象在不同状态下的行为和转换。</p> </li><li> <p><strong>验证设计：</strong> 对设计进行验证，确保它符合系统需求并且能够满足预期的功能和性能。可以通过模拟、原型制作、代码审查等方式进行验证。</p> </li><li> <p><strong>实施设计：</strong> 将设计转化为实际的代码。在这个阶段，使用选定的编程语言和开发工具来实现定义的类和对象。</p> </li><li> <p><strong>测试和调试：</strong> 对实现的系统进行测试，包括单元测试、集成测试和系统测试。通过测试和调试确保系统达到预期的质量标准。</p> </li><li> <p><strong>维护和更新：</strong> 随着系统的使用，可能会出现需求变更或者发现一些缺陷。在这个阶段进行维护和更新，确保系统能够适应变化并持续提供价值。</p> </li></ol> 
<p>整个过程是迭代的，设计和实现的阶段可能会交替进行，通过不断的反馈和调整来逐步完善系统。这种面向对象的设计过程强调模块化、可维护性和可扩展性，有助于创建灵活、可靠且易于理解的软件系统。</p> 
<blockquote> 
 <p>3、什么是软件工程过程？</p> 
</blockquote> 
<h2><a id="UML_1086"></a>UML</h2> 
<p>、一台饮料自动售货机能提供六种不同的饮料，售货机上有六个按钮，分别对应于这六种饮料，顾客可以通过按钮来选择所要的饮料，每个按钮旁边有一个指示灯，用来表明该售货机中是否还有这种饮料可售。售货机有一个硬币槽和找零槽，用来收钱和找零。<br> （1）请给出上述描述的用例图。<br> （2）请画出一个顾客买某种饮料需要退钱时的时序图。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e0a3d8390af8330606cb5868304b70a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么保你平安</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c905f901d713c3ba5b8be8293fbd8a6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">react基础学习 附加todo实现代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>