<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[SpringBoot]Spring Security框架 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[SpringBoot]Spring Security框架" />
<meta property="og:description" content="目录
关于Spring Security框架
Spring Security框架的依赖项
Spring Security框架的典型特征
关于Spring Security的配置
关于默认的登录页
关于请求的授权访问（访问控制）
使用自定义的账号登录
使用数据库中的账号登录
关于密码编码器
使用BCrypt算法
关于伪造的跨域攻击
使用前后端分离的登录
关于认证的标准
未通过认证时拒绝访问
识别当事人（Principal）
实现根据权限限制访问
补充解释（关于使用resultMap标签）：
基于方法的权限检查
添加Token 首先添加Token-JWT的依赖项：
生成JWT：
解析JWT
补充：
在项目中使用JWT识别用户的身份
核心流程
验证登录成功时响应JWT
解析客户端携带的JWT
我们这次选择去继承Spring系列框架提供的OncePerRequestFilter这个类。
关于认证信息中的当事人
处理解析JWT时的异常
处理复杂请求的跨域问题
单点登录
关于Spring Security框架 Spring Security框架主要解决了认证与授权相关的问题。 认证信息（Authentication）：表示用户的身份信息
认证（Authenticate）：识别用户的身份信息的行为，例如：登录
授权（Authorize）：授予用户权限，使之可以进行某些访问，反之，如果用户没有得到必要的授权，将无法进行访问
Spring Security框架的依赖项 在Spring Boot中使用Spring Security时需要添加spring-boot-starter-security依赖。 Spring Security框架的典型特征 当添加了spring-boot-starter-security依赖后，在启动项目时执行一些自动配置，具体表现有：
所有请求（包括根本不存在的）都是必须要登录才允许访问的，如果未登录，会自动跳转到框架自带的登录页面（1.项目重启之后需要重新登录，2.原来想去的页面会要求登录，登录完成之后回到原来的位置）
当尝试登录时，如果在打开登录页面后重启过服务器端，则第1次的输入是无效的 默认的用户名是user，密码是在启动项目是控制台提示的一段UUID值，每次启动项目时都不同(同一时空的唯一性，即同一时间同一空间的值都不同)
UUID是通过128位算法（运算结果是128个bit）运算得到的，是一个随机数，在同一时空是唯一的，通常使用32个十六进制数来表示，每种平台生成UUID的API和表现可能不同，UUID值的种类有2的128次方个，即：3.4028237e&#43;38，也就是340282366920938463463374607431768211456
当登录成功后，会自动跳转到此前尝试访问的URL
当登录成功后，可以通过 /logout 退出登录
默认不接受普通POST请求，如果提交POST请求，将响应403（Forbidden）
关于Spring Security的配置 在项目的根包下创建config.SecurityConfiguration类，作为Spring Security的配置类，此类需要继承自WebSecurityConfigurerAdapter，并重写void configure(HttpSecurity http)方法，例如：
@Slf4j @Configuration public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { // super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/420e0897549dc6aa7ef846b32a97c4ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T20:55:31+08:00" />
<meta property="article:modified_time" content="2023-06-11T20:55:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[SpringBoot]Spring Security框架</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%85%B3%E4%BA%8ESpring%20Security%E6%A1%86%E6%9E%B6-toc" style="margin-left:0px;"><a href="#%E5%85%B3%E4%BA%8ESpring%20Security%E6%A1%86%E6%9E%B6" rel="nofollow">关于Spring Security框架</a></p> 
<p id="Spring%20Security%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9-toc" style="margin-left:40px;"><a href="#Spring%20Security%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9" rel="nofollow">Spring Security框架的依赖项</a></p> 
<p id="Spring%20Security%E6%A1%86%E6%9E%B6%E7%9A%84%E5%85%B8%E5%9E%8B%E7%89%B9%E5%BE%81-toc" style="margin-left:40px;"><a href="#Spring%20Security%E6%A1%86%E6%9E%B6%E7%9A%84%E5%85%B8%E5%9E%8B%E7%89%B9%E5%BE%81" rel="nofollow">Spring Security框架的典型特征</a></p> 
<p id="%C2%A0%E5%85%B3%E4%BA%8ESpring%20Security%E7%9A%84%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%85%B3%E4%BA%8ESpring%20Security%E7%9A%84%E9%85%8D%E7%BD%AE" rel="nofollow"> 关于Spring Security的配置</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E9%BB%98%E8%AE%A4%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5-toc" style="margin-left:0px;"><a href="#%E5%85%B3%E4%BA%8E%E9%BB%98%E8%AE%A4%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5" rel="nofollow">关于默认的登录页</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%EF%BC%88%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%85%B3%E4%BA%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%EF%BC%88%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%89" rel="nofollow">关于请求的授权访问（访问控制）</a></p> 
<p id="%C2%A0%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95" rel="nofollow"> 使用自定义的账号登录</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95" rel="nofollow">使用数据库中的账号登录</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%99%A8" rel="nofollow">关于密码编码器</a></p> 
<p id="%E4%BD%BF%E7%94%A8BCrypt%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8BCrypt%E7%AE%97%E6%B3%95" rel="nofollow">使用BCrypt算法</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E4%BC%AA%E9%80%A0%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB-toc" style="margin-left:0px;"><a href="#%E5%85%B3%E4%BA%8E%E4%BC%AA%E9%80%A0%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB" rel="nofollow">关于伪造的跨域攻击</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E7%99%BB%E5%BD%95-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E7%99%BB%E5%BD%95" rel="nofollow">使用前后端分离的登录</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E8%AE%A4%E8%AF%81%E7%9A%84%E6%A0%87%E5%87%86-toc" style="margin-left:0px;"><a href="#%E5%85%B3%E4%BA%8E%E8%AE%A4%E8%AF%81%E7%9A%84%E6%A0%87%E5%87%86" rel="nofollow">关于认证的标准</a></p> 
<p id="%E6%9C%AA%E9%80%9A%E8%BF%87%E8%AE%A4%E8%AF%81%E6%97%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE-toc" style="margin-left:0px;"><a href="#%E6%9C%AA%E9%80%9A%E8%BF%87%E8%AE%A4%E8%AF%81%E6%97%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE" rel="nofollow">未通过认证时拒绝访问</a></p> 
<p id="%E8%AF%86%E5%88%AB%E5%BD%93%E4%BA%8B%E4%BA%BA%EF%BC%88Principal%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E8%AF%86%E5%88%AB%E5%BD%93%E4%BA%8B%E4%BA%BA%EF%BC%88Principal%EF%BC%89" rel="nofollow">识别当事人（Principal）</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE" rel="nofollow">实现根据权限限制访问</a></p> 
<p id="%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A%EF%BC%88%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8resultMap%E6%A0%87%E7%AD%BE%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A%EF%BC%88%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8resultMap%E6%A0%87%E7%AD%BE%EF%BC%89%EF%BC%9A" rel="nofollow">补充解释（关于使用resultMap标签）：</a></p> 
<p id="%E5%9F%BA%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5" rel="nofollow">基于方法的权限检查</a></p> 
<p id="%E6%B7%BB%E5%8A%A0Token%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%B7%BB%E5%8A%A0Token%C2%A0" rel="nofollow">添加Token </a></p> 
<p id="%E9%A6%96%E5%85%88%E6%B7%BB%E5%8A%A0Token-JWT%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%A6%96%E5%85%88%E6%B7%BB%E5%8A%A0Token-JWT%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9%EF%BC%9A" rel="nofollow">首先添加Token-JWT的依赖项：</a></p> 
<p id="%E7%94%9F%E6%88%90JWT%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%94%9F%E6%88%90JWT%EF%BC%9A" rel="nofollow">生成JWT：</a></p> 
<p id="%C2%A0%E8%A7%A3%E6%9E%90JWT-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%A7%A3%E6%9E%90JWT" rel="nofollow"> 解析JWT</a></p> 
<p id="%E8%A1%A5%E5%85%85%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%A1%A5%E5%85%85%EF%BC%9A" rel="nofollow">补充：</a></p> 
<p id="%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8JWT%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E7%9A%84%E8%BA%AB%E4%BB%BD-toc" style="margin-left:0px;"><a href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8JWT%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E7%9A%84%E8%BA%AB%E4%BB%BD" rel="nofollow">在项目中使用JWT识别用户的身份</a></p> 
<p id="%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B" rel="nofollow">核心流程</a></p> 
<p id="%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E6%97%B6%E5%93%8D%E5%BA%94JWT-toc" style="margin-left:80px;"><a href="#%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E6%97%B6%E5%93%8D%E5%BA%94JWT" rel="nofollow">验证登录成功时响应JWT</a></p> 
<p id="%E8%A7%A3%E6%9E%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%90%BA%E5%B8%A6%E7%9A%84JWT-toc" style="margin-left:0px;"><a href="#%E8%A7%A3%E6%9E%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%90%BA%E5%B8%A6%E7%9A%84JWT" rel="nofollow">解析客户端携带的JWT</a></p> 
<p id="%C2%A0%E6%88%91%E4%BB%AC%E8%BF%99%E6%AC%A1%E9%80%89%E6%8B%A9%E5%8E%BB%E7%BB%A7%E6%89%BFSpring%E7%B3%BB%E5%88%97%E6%A1%86%E6%9E%B6%E6%8F%90%E4%BE%9B%E7%9A%84OncePerRequestFilter%E8%BF%99%E4%B8%AA%E7%B1%BB%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%88%91%E4%BB%AC%E8%BF%99%E6%AC%A1%E9%80%89%E6%8B%A9%E5%8E%BB%E7%BB%A7%E6%89%BFSpring%E7%B3%BB%E5%88%97%E6%A1%86%E6%9E%B6%E6%8F%90%E4%BE%9B%E7%9A%84OncePerRequestFilter%E8%BF%99%E4%B8%AA%E7%B1%BB%E3%80%82" rel="nofollow"> 我们这次选择去继承Spring系列框架提供的OncePerRequestFilter这个类。</a></p> 
<p id="%E5%85%B3%E4%BA%8E%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84%E5%BD%93%E4%BA%8B%E4%BA%BA-toc" style="margin-left:0px;"><a href="#%E5%85%B3%E4%BA%8E%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84%E5%BD%93%E4%BA%8B%E4%BA%BA" rel="nofollow">关于认证信息中的当事人</a></p> 
<p id="%E5%A4%84%E7%90%86%E8%A7%A3%E6%9E%90JWT%E6%97%B6%E7%9A%84%E5%BC%82%E5%B8%B8-toc" style="margin-left:0px;"><a href="#%E5%A4%84%E7%90%86%E8%A7%A3%E6%9E%90JWT%E6%97%B6%E7%9A%84%E5%BC%82%E5%B8%B8" rel="nofollow">处理解析JWT时的异常</a></p> 
<p id="%E5%A4%84%E7%90%86%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E5%A4%84%E7%90%86%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98" rel="nofollow">处理复杂请求的跨域问题</a></p> 
<p id="%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-toc" style="margin-left:0px;"><a href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95" rel="nofollow">单点登录</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="%E5%85%B3%E4%BA%8ESpring%20Security%E6%A1%86%E6%9E%B6">关于Spring Security框架</h2> 
<p>Spring Security框架主要解决了认证与授权相关的问题。  </p> 
<p>认证信息（Authentication）：表示用户的身份信息</p> 
<p>认证（Authenticate）：识别用户的身份信息的行为，例如：登录</p> 
<p>授权（Authorize）：授予用户权限，使之可以进行某些访问，反之，如果用户没有得到必要的授权，将无法进行访问</p> 
<p></p> 
<h3 id="Spring%20Security%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9">Spring Security框架的依赖项</h3> 
<p>在Spring Boot中使用Spring Security时需要添加<code>spring-boot-starter-security</code>依赖。  </p> 
<p></p> 
<h3 id="Spring%20Security%E6%A1%86%E6%9E%B6%E7%9A%84%E5%85%B8%E5%9E%8B%E7%89%B9%E5%BE%81">Spring Security框架的典型特征</h3> 
<p> 当添加了<code>spring-boot-starter-security</code>依赖后，在启动项目时执行一些自动配置，具体表现有：</p> 
<p></p> 
<ul><li> <p>所有请求（包括根本不存在的）都是必须要登录才允许访问的，如果未登录，会自动跳转到框架自带的登录页面（1.项目重启之后需要重新登录，2.原来想去的页面会要求登录，登录完成之后回到原来的位置）</p> </li></ul> 
<p class="img-center"><img alt="" height="206" src="https://images2.imgbox.com/df/aa/wQvIIb6S_o.png" width="319"></p> 
<p></p> 
<ul><li>当尝试登录时，如果在打开登录页面后重启过服务器端，则第1次的输入是无效的  </li><li> <p>默认的用户名是<code>user</code>，密码是在启动项目是控制台提示的一段UUID值，每次启动项目时都不同(同一时空的唯一性，即同一时间同一空间的值都不同)</p> 
  <ul><li> <p>UUID是通过<strong>128位算法</strong>（运算结果是128个bit）运算得到的，是一个随机数，在同一时空是唯一的，通常使用32个十六进制数来表示，每种平台生成UUID的API和表现可能不同，UUID值的种类有2的128次方个，即：3.4028237e+38，也就是340282366920938463463374607431768211456</p> </li></ul></li></ul> 
<p class="img-center"><img alt="" height="201" src="https://images2.imgbox.com/10/f4/I6T3jC8w_o.png" width="949"></p> 
<p></p> 
<ul><li> <p>当登录成功后，会自动跳转到此前尝试访问的URL</p> </li><li> <p>当登录成功后，可以通过 <code>/logout</code> 退出登录</p> </li></ul> 
<ul><li> <p>默认不接受普通<code>POST</code>请求，如果提交<code>POST</code>请求，将响应<strong><code>403（Forbidden）</code></strong></p> </li></ul> 
<h3 id="%C2%A0%E5%85%B3%E4%BA%8ESpring%20Security%E7%9A%84%E9%85%8D%E7%BD%AE"> 关于Spring Security的配置</h3> 
<p> 在项目的根包下创建<code>config.SecurityConfiguration</code>类，作为Spring Security的配置类，此类需要继承自<code>WebSecurityConfigurerAdapter</code>，并重写<code>void configure(HttpSecurity http)</code>方法，例如：</p> 
<pre><code class="language-java">@Slf4j
@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // super.configure(http); // 不要保留调用父级同名方法的代码，不要保留！不要保留！不要保留！
    }

}</code></pre> 
<p>做了配置后，此时重启工程就不需要登陆了，就算访问登录页面也没有。</p> 
<p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/7a/dd/VhzeMtyL_o.png" width="460"></p> 
<p> </p> 
<p> </p> 
<blockquote> 
 <p> 写此配置是为了调整Spring Security框架的特征的所有表现由自己来设置。</p> 
</blockquote> 
<h2 id="%E5%85%B3%E4%BA%8E%E9%BB%98%E8%AE%A4%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5">关于默认的登录页</h2> 
<p>在自定义的配置类中的<code>void configure(HttpSecurity http)</code>方法中，调用参数对象的<code>formLogin()</code>方法即可开启默认的登录表单，如果没有调用此方法，则不会应用默认的登录表单，例如：</p> 
<pre><code class="language-java">@Slf4j
@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // super.configure(http); // 不要保留调用父级同名方法的代码，不要保留！不要保留！不要保留！

        // 如果调用以下方法，当Security认为需要通过认证，但实际未通过认证时，就会跳转到登录页面
        // 如果未调用以下方法，将会响应403错误
        http.formLogin();
    }

}</code></pre> 
<p></p> 
<h2 id="%E5%85%B3%E4%BA%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%EF%BC%88%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%89">关于请求的授权访问（访问控制）</h2> 
<p>在刚刚添加<code>spring-boot-starter-security</code>时，所有请求都是<strong>需要</strong>登录后才允许访问的，当添加了自定义的配置类且没有调用父级同名方法后，所有请求都是<strong>不需要</strong>登录就可以访问的！</p> 
<p>为了实现一部分需要登录，一部分不需要登录就需要做配置类，不然如果是自己做了一个登录页面，访问登录页面还需要登录就不合适。 </p> 
<p>在配置类中的<code>void configure(HttpSecurity http)</code>方法中，调用参数对象的<code>authorizeRequests()</code>方法开始配置授权访问：</p> 
<pre><code class="language-java">@Override
protected void configure(HttpSecurity http) throws Exception {
    // 白名单
    // 使用1个星号，可以通配此层级的任何资源，例如：/admin/*，可以匹配：/admin/add-new、/admin/list，但不可以匹配：/admin/password/change
    // 使用2个连续的星可以，可以通配若干层级的资源，例如：/admin/**，可以匹配：/admin/add-new、/admin/password/change
    String[] urls = {
            "/doc.html",
            "/**/*.css",
            "/**/*.js",
            "/swagger-resources",
            "/v2/api-docs",
    };

    // 配置授权访问
    // 注意：以下授权访问的配置，是遵循“第一匹配原则”的，即“以最先匹配到的规则为准”
    // 例如：anyRequest()是匹配任何请求，通常，应该配置在最后，表示“除了以上配置过的以外的所有请求”
    // 所以，在开发实践中，应该将更具体的请求配置在靠前的位置，将更笼统的请求配置在靠后的位置
    http.authorizeRequests() // 开始对请求进行授权
            .mvcMatchers(urls) // 匹配某些请求
            .permitAll() // 许可，即不需要通过认证就可以访问
            .anyRequest() // 任何请求
            .authenticated() // 要求已经完成认证的
    ;
}</code></pre> 
<p> http.authorizeRequests() // 开始对请求进行授权 </p> 
<p>表示开始对请求进行授权 。</p> 
<p>  .anyRequest() // 任何请求<br>   .authenticated() // 要求已经完成认证的</p> 
<p>上面两句需要连起来理解，表示任何请求都要求是已经完成认证的。加上这两句就回到了最开始的样子，所有的请求都需要登录才能访问，不登录访问不了。</p> 
<p> .mvcMatchers(urls) // 匹配某些请求<br>  .permitAll() // 许可，即不需要通过认证就可以访问 </p> 
<p>这两句话也是连起来理解的， 理解同上面一样，上面是任何请求，这里是匹配某些请求，上面的行为是所有都要求认证，这里的行为是许可访问，不需要通过认证。（因为遵循“第一匹配原则”的，即“以最先匹配到的规则为准”，所有这两行代码要放在最上面才有效）</p> 
<p></p> 
<p>这里的urls是怎么来的：<br> 首先为了方便页面正确显示，勾上禁用缓存。   </p> 
<p class="img-center"><img alt="" height="549" src="https://images2.imgbox.com/62/44/Z66MgsAZ_o.png" width="1200"></p> 
<p></p> 
<p>看下面错误提示，看到有一堆的200都是login的，为了更好的看到提示信息，把http.formLogin（）关掉。</p> 
<p class="img-center"><img alt="" height="545" src="https://images2.imgbox.com/5c/65/08QEZovY_o.png" width="1054"></p> 
<p></p> 
<p class="img-center"><img alt="" height="148" src="https://images2.imgbox.com/7f/cb/rfeWokjT_o.png" width="383"></p> 
<p>   可以看到大量的403</p> 
<p class="img-center"><img alt="" height="220" src="https://images2.imgbox.com/ec/47/y6zdMSXl_o.png" width="690"></p> 
<p> 从中我们对这些403进行许可(案例访问的API文档，给文档需要的资源进行许可，就可以顺利访问API文档了），urls就是这么来的。</p> 
<p class="img-center"><img alt="" height="294" src="https://images2.imgbox.com/19/e2/M2rrXYKa_o.png" width="577"></p> 
<p>注意：有的比如表面是说的api-docs这样一个名字，实际在配白名单的时候，看它的url是在一个v2的文件夹里面，配置为 "/v2/api-docs"。</p> 
<p class="img-center"><img alt="" height="159" src="https://images2.imgbox.com/71/6a/0Go85Vr5_o.png" width="413"></p> 
<p></p> 
<p> <img alt="" height="96" src="https://images2.imgbox.com/2c/7f/hFEXmkR4_o.png" width="873"></p> 
<p></p> 
<h2 id="%C2%A0%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95"> 使用自定义的账号登录</h2> 
<p>在使用Spring Security框架时，可以自定义组件类，实现<code>UserDetailsService</code>接口，则Spring Security就会基于此类的对象来处理认证！</p> 
<p>则在项目的根包下创建<code>security.UserDetailsServiceImpl</code>，在类上添加<code>@Service</code>注解使其成为组件类，实现<code>UserDetailsService</code>接口：</p> 
<pre><code class="language-java">@Slf4j
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        return null;
    }
}</code></pre> 
<p>（通过loadUserByUsername(String s)这个方法的名字可以理解为通过用户名加载用户，参数s就是username用户名，返回UserDetails用户详情）</p> 
<p>在项目中存在<code>UserDetailsService</code>接口类型的组件对象时，尝试登录时，Spring Security就会自动使用登录表单中输入的用户名来调用以上方法， 把输入的用户名作为一个参数， 并得到方法返回的<code>UserDetails</code>类型的结果， 此结果中应该包含用户的相关信息，例如密码、账号状态、权限等等，接下来，Spring Security框架会自动判断账号的状态（例如是否启用或禁用）、验证密码（在<code>UserDetails</code>中的密码与登录表单中的密码是否匹配）等，从而决定此次是否登录成功！</p> 
<p></p> 
<p>所以，对于开发者而言，在以上方法中只需要完成“根据用户名返回匹配的用户详情”即可！例如： </p> 
<pre><code class="language-java">@Slf4j
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        log.debug("用户名：{}", s);
        // 假设正确的用户名是root，匹配的密码是1234
        if (!"root".equals(s)) {
            log.debug("此用户名没有匹配的用户数据，将返回null");
            return null;
        }

        log.debug("用户名匹配成功！准备返回此用户名匹配的UserDetails类型的对象");
        UserDetails userDetails = User.builder()
                .username(s)
                .password("1234")
                .disabled(false) // 账号状态是否禁用
                .accountLocked(false) // 账号状态是否锁定
                .accountExpired(false) // 账号状态是否过期
                .credentialsExpired(false) // 账号的凭证是否过期
                .authorities("这是一个临时使用的山寨的权限！！！") // 权限
                .build();
        log.debug("即将向Spring Security返回UserDetails类型的对象：{}", userDetails);
        return userDetails;
    }

}</code></pre> 
<p> 以上代码中，用User.builder()开启它的构建者模式， .build()表示构建完了。这是一个链式写法，先有个builder()在执行 .build()就可以创建这个对象。创建的过程中就传入例如密码、账号状态、权限等相关信息。</p> 
<p>当项目中存在<code>UserDetailsService</code>类型的对象后，启动项目时，控制台不会再提示临时使用的UUID密码！并且，<code>user</code>账号也不可用！ 用的就是自己配的  .username(s)  .password("1234")这个。</p> 
<p></p> 
<p>另外，Spring Security框架认为所有的密码都是必须显式的经过某种算法处理过的，如果使用的密码是明文（原始密码例如1234这种），也必须明确的指出！例如，使用没加密的原始密码在Security的配置类中添加配置<code>NoOpPasswordEncoder</code>这种密码编码器告诉Security是没有加密的，不然会报错：  </p> 
<pre><code class="language-java">@Bean
public PasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}</code></pre> 
<p><strong> 此时尝试登录</strong>，输入用户名root，密码1234，登录成功，输入错误的用户名提示以下为null，这是因为这个null是在用户名不对的时候我们给它的。</p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/08/db/UIDDw1oU_o.png" width="325"></p> 
<p class="img-center"><img alt="" height="158" src="https://images2.imgbox.com/14/28/bFOp2Vg5_o.png" width="555"></p> 
<p> 如果用户名是输入的root，密码故意输出会提示：</p> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/32/16/S4MF7LZ5_o.png" width="357"></p> 
<p> 如果把禁用打开，输入正确的用户名密码也会显示用户已失效：</p> 
<p class="img-center"><img alt="" height="115" src="https://images2.imgbox.com/84/0b/kA257iAR_o.png" width="582"></p> 
<p></p> 
<p class="img-center"><img alt="" height="243" src="https://images2.imgbox.com/20/d4/55m3HjGm_o.png" width="419"></p> 
<p></p> 
<h2 id="%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95">使用数据库中的账号登录</h2> 
<p>需要将<code>UserDetailsServiceImpl</code>中的实现改为“根据用户名查询数据库中的用户信息”！需要执行的SQL语句大致是：</p> 
<pre><code class="language-sql">select username, password, enable from ams_admin where username=?</code></pre> 
<p> 在<code>pojo.vo.AdminLoginInfoVO</code>类：</p> 
<pre><code class="language-java">@Data
@Accessors(chain = true)
public class AdminLoginInfoVO implements Serializable {
    private String username;
    private String password;
    private Integer enable;
}</code></pre> 
<p> 在<code>AdminMapper</code>接口中添加抽象方法：</p> 
<pre><code class="language-java">AdminLoginInfoVO getLoginInfoByUsername(String username);</code></pre> 
<p> 在<code>AdminMapper.xml</code>中配置SQL：</p> 
<pre><code class="language-XML">&lt;!-- AdminLoginInfoVO getLoginInfoByUsername(String username); --&gt;
&lt;select id="getLoginInfoByUsername" resultType="cn.tedu.csmall.passport.pojo.vo.AdminLoginInfoVO"&gt;
    SELECT 
        username, password, enable 
    FROM 
         ams_admin 
    WHERE 
        username=#{username}
&lt;/select&gt;</code></pre> 
<p> 在<code>AdminMapperTests</code>中编写并执行测试：</p> 
<pre><code class="language-java">@Test
void getStandardById() {
    String username = "root";
    Object queryResult = mapper.getLoginInfoByUsername(username);
    System.out.println("根据【username=" + username + "】查询数据完成，结果：" + queryResult);
}</code></pre> 
<p> 然后，在<code>UserDetailsServiceImpl</code>中调整原来的实现，改成：</p> 
<p></p> 
<pre><code class="language-java">@Override
public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
    log.debug("Spring Security框架自动调用了UserDetailsServiceImpl.loadUserByUsername()方法，用户名：{}", s);
    // 根据用户名从数据库中查询匹配的用户信息
    AdminLoginInfoVO loginInfo = adminMapper.getLoginInfoByUsername(s);
    if (loginInfo == null) {
        log.debug("此用户名没有匹配的用户数据，将返回null");
        return null;
    }

    log.debug("用户名匹配成功！准备返回此用户名匹配的UserDetails类型的对象");
    UserDetails userDetails = User.builder()
            .username(loginInfo.getUsername())
            .password(loginInfo.getPassword())
            .disabled(loginInfo.getEnable() == 0) // 账号状态是否禁用
            .accountLocked(false) // 账号状态是否锁定
            .accountExpired(false) // 账号状态是否过期
            .credentialsExpired(false) // 账号的凭证是否过期
            .authorities("这是一个临时使用的山寨的权限！！！") // 权限
            .build();
    log.debug("即将向Spring Security返回UserDetails类型的对象：{}", userDetails);
    return userDetails;
}</code></pre> 
<p>为了得到较好的运行效果，应该在数据表中插入一些新的测试数据，例如：</p> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/b2/29/jJuPNa5K_o.png" width="837"></p> 
<p>因为目前配置的密码编码器是<code>NoOpPasswordEncoder</code>，所以，本次测试运行时，使用的账号在数据库的密码应该是明文密码！</p> 
<h3 id="%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%99%A8">关于密码编码器</h3> 
<p> Spring Security定义了<code>PasswordEncoder</code>接口，可以有多种不同的实现，此接口中的抽象方法主要有：</p> 
<pre><code class="language-java">// 对原密码进行编码，返回编码后的结果（密文）
String encode(String rawPassword);

// 验证密码原文（第1个参数）和密文（第2个参数）是否匹配
boolean matches(String rawPassword, String encodedPassword);</code></pre> 
<p>常见的对密码进行编码，实现“加密”效果所使用的算法主要有：</p> 
<ul><li> <p>MD（Message Digest）系列：MD2 / MD4 / MD5</p> </li><li> <p>SHA（Secure Hash Algorithm）系列：SHA-1 / SHA-256 / SHA-384 / SHA-512</p> </li><li> <p>BCrypt</p> </li><li> <p>SCrypt</p> </li></ul> 
<p>目前，推荐使用的算法是<code>BCrypt</code>算法！在Spring Security框架中，也提供了<code>BCryptPasswordEncoder</code>类，其基本使用：  </p> 
<pre><code class="language-java">public class BCryptTests {

    PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Test
    void encode() {
        String rawPassword = "123456";
        System.out.println("原文：" + rawPassword);

        for (int i = 0; i &lt; 5; i++) {
            String encodedPassword = passwordEncoder.encode(rawPassword);
            System.out.println("密文：" + encodedPassword);
        }
    }

    // 原文：123456
    // 密文：$2a$10$YOW67gn1jGQsNd1lWFOktuxGEK3Ai4obSCo6m0o0zP3YA4iTm0QoS
    // 密文：$2a$10$AoGlKthb1ZKzTAng5ssX6OUwN8.tC9junqbYhtF0POkr.XdFuoEWy
    // 密文：$2a$10$wgBhSmnoFQ.LdvFCLd8lyOSsHuGVIpVYKW8.bW4yt2kBMYqG1G.5u
    // 密文：$2a$10$OIiWGSjFH02Vr9khLEQnG.s2rGowkotMV14TThAgJK8KQm.WQq6pm
    // 密文：$2a$10$DluGioTO7Zcc0hmwDz8Ld.4Uyp2hIIZ/PcGhFCVd1P3FuSukqJN36
    
    @Test
    void matches() {
        String rawPassword = "123456";
        System.out.println("原文：" + rawPassword);

        String encodedPassword = "$2a$10$wgBhSmnoFQ.LdvFCLd8lyOSsHuGVIpVYKW8.bW4yt2kBMYqG1G.5u";
        System.out.println("密文：" + encodedPassword);

        boolean result = passwordEncoder.matches(rawPassword, encodedPassword);
        System.out.println("匹配结果：" + result);
    }

}</code></pre> 
<p>关于BCrypt算法，其典型特征有：</p> 
<ul><li> <p>使用同样的原文，每次得到的密文都不相同</p> 
  <ul><li> <p>BCrypt算法在编码过程中，使用了随机的“盐”（salt）值，所以，每次编码结果都不同</p> </li><li> <p>编码结果中保存了这个随机的盐值，所以，并不影响验证是否匹配</p> </li></ul></li><li> <p>运算效率极为低下，可以非常有效的避免暴力破解</p> 
  <ul><li> <p>可以通过构造方法传入<code>strength</code>值，增加强度（默认为<code>10</code>），表示运算过程中执行2的多少次方的哈希运算</p> <p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/92/92/eUV0tcKR_o.png" width="833"></p> </li><li> <p>此特征是MD系列和SHA家庭的算法所不具备的特征</p> </li></ul></li></ul> 
<p>另外，SCrypt算法的安全性比BCrypt还要高，但是，执行效率比BCrypt更低，通常，由于BCrypt算法已经能够提供足够的安全强度，所以，目前，使用BCrypt是常见的选择。</p> 
<p></p> 
<h3 id="%E4%BD%BF%E7%94%A8BCrypt%E7%AE%97%E6%B3%95">使用BCrypt算法</h3> 
<p>只需要在Security配置类中将密码编码器换成<code>BCryptPasswordEncoder</code>即可：  </p> 
<p class="img-center"><img alt="" height="479" src="https://images2.imgbox.com/79/83/dVFwrZv8_o.png" width="1200"></p> 
<p> 接下来，便可以使用数据库中那些密码是密文的账号测试登录：</p> 
<p class="img-center"><img alt="" height="645" src="https://images2.imgbox.com/29/03/WJhUUpFk_o.png" width="1200"></p> 
<p>(注意:专业名词上BCrypt算法以及上文提到的MD等都不是加密算法，加密算法是能加密还能解密的，而这些算法都是单向加密不可逆和还原的。登录的时候只能用数据库的密文和传递进来的密文做匹配，是不能验证原密码的。)</p> 
<p></p> 
<p>在以上案例中还<strong>不能使用post请求</strong>，需要以下：<br> Spring Security框架设计了“防止伪造的跨域攻击”的防御机制，所以，默认情况下，自定义的POST请求是不可用的，简单的解决方案就是在Spring Security的配置类中禁用这个防御机制即可，例如：</p> 
<p class="img-center"><img alt="" height="130" src="https://images2.imgbox.com/3c/ec/fIHt5NU4_o.png" width="673"></p> 
<p> </p> 
<p> </p> 
<h2 id="%E5%85%B3%E4%BA%8E%E4%BC%AA%E9%80%A0%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB">关于伪造的跨域攻击</h2> 
<p> <strong>伪造的跨域攻击：</strong>此类攻击原理是利用服务器端对客户端浏览器的“信任”来实现的！目前，主流的浏览器都是<strong>多选项卡</strong>模式的，假设在第1个选项卡中登录了某个网站，在第2个选项卡也打开这个网站的页面，就会被当作是已经登录的状态！基于这种特征，假设在第1个选项卡中登录了某个网上银行，在第2个选项卡中打开了某个坏人的网站（不是网上银行的网站），但是，在这个坏人的网站的页面中隐藏了一个使用网上银行进行转账的请求，这个请求在坏人的网站的页面刚刚打开时就自动发送出去了（自动发送：方法很多，例如将URL设置为某个不显示的<code>&lt;img&gt;</code>标签的<code>src</code>值），由于在第1个选项卡中已经登录了网上银行，从第2个选项卡中发出的请求也会被视为已经登录网上银行的状态，这就实现了一种攻击行为！当然，以上只是举例，真正的银行转账不会这么简单，例如还需要输入密码、手机验证码等等，但是，这种模式的攻击行为是确实存在的，由于使用另一个网站（坏人的网站）偷偷的实现的攻击，所以，称之为“伪造的跨域攻击”！</p> 
<p> </p> 
<p><strong>典型的防御手段：</strong>在Spring Security框架中，默认就开启了对于“伪造跨域攻击”的防御机制，其做法是在所有POST表单中隐藏一个具有“唯一性”的“随机值”，例如UUID值，当客户端提交请求时，必须提交这个UUID值，如果未提交，则服务器端将其直接视为攻击行为，将拒绝处理此请求！以Spring Security默认的登录表单为例：</p> 
<p class="img-center"><img alt="" height="509" src="https://images2.imgbox.com/48/af/kKTM4jty_o.png" width="991"></p> 
<p> </p> 
<p>当把防御机制禁用后，这个数值也就没有了。</p> 
<p> 提示：此前“如果在打开登录页面后重启过服务器端，则第1次的输入是无效的”，也是因为这种防御机制，当打开登录页，服务器端生成了此次使用的UUID，但重启服务器后，服务器不再识别此前生成的UUID，所以，第1次的输入是无效的！</p> 
<p> </p> 
<blockquote> 
 <p>目前以上已经实现Spring Security框架它默认带来的效果，解决了认证和授权的问题，最主要的用它来处理登录。但目前还不够，还需要实现前后端分离的登录。</p> 
</blockquote> 
<h2 id="%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E7%99%BB%E5%BD%95">使用前后端分离的登录</h2> 
<p> Spring Security框架自带了登录页面和退出登录页面，不是前后端分离的，则不可以与自行开发的前端项目中的登录页面进行交互，如果要改为前后端分离的模式，需要：</p> 
<p> </p> 
<ul><li> <p>不再启用服务器端Spring Security框架自带的登录页面和退出登录页面</p> 
  <ul><li> <p>在配置类中不再调用<code>http.formLogin()</code>即可</p> </li></ul></li></ul> 
<p class="img-center"><img alt="" height="76" src="https://images2.imgbox.com/a1/28/Ylr71bgp_o.png" width="350"></p> 
<p> </p> 
<ul><li> <p>使用控制器接收客户端的登录请求</p> 
  <ul><li> <p>自定义Param类，封装客户端将提交的用户名和密码，在控制器类中添加接收登录请求的方法</p> </li></ul></li></ul> 
<p class="img-center"><img alt="" height="416" src="https://images2.imgbox.com/35/04/N7ZMBN9d_o.png" width="739"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="243" src="https://images2.imgbox.com/a7/52/RS2CJrb2_o.png" width="740"></p> 
<p> </p> 
<p> </p> 
<ul><li> <p>注意：需要将此请求配置在“白名单”中（不能登录之后在登录）</p> </li></ul> 
<p class="img-center"><img alt="" height="203" src="https://images2.imgbox.com/be/ca/AgJciU26_o.png" width="361"></p> 
<p> </p> 
<p>使用Service处理登录的业务</p> 
<ul><li> <p>在接口中声明抽象方法，并在实现类中重写此方法</p> </li></ul> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/8e/42/uzV0lWP1_o.png" width="757"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="126" src="https://images2.imgbox.com/44/98/OhH0gKs7_o.png" width="794"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="256" src="https://images2.imgbox.com/6d/d5/jVIBmv89_o.png" width="800"></p> 
<p> </p> 
<p> </p> 
<ul><li> <p>具体的验证登录，仍可以由Spring Security框架来完成，<strong>调用<code>AuthenticationManager</code>（认证管理器）对象的<code>authenticate()</code>方法即可</strong>，则Spring Security框架会自动基于调用方法时传入的用户名来调用<code>UserDetailsService</code>接口对象的<code>loadUserByUsername()</code>方法，并得到返回的<code>UserDetails</code>对象，然后，自动判断账号状态、对比密码等等</p> 
  <ul><li> <p>可以在Spring Security的配置类中重写<code>authenticationManagerBean()</code>方法，并在此方法上添加<code>@Bean</code>注解，则可以在任何所需要的位置自动装配<code>AuthenticationManager</code>类型的数据，注意：不要使用<code>authenticationManager()</code>方法，此方法在某些场景（例如某些测试等）中可能导致死循环，最终内存溢出</p> </li></ul></li></ul> 
<p> </p> 
<p class="img-center"><img alt="" height="227" src="https://images2.imgbox.com/08/e6/MV7WNnIA_o.png" width="822"></p> 
<p> <img alt="" height="212" src="https://images2.imgbox.com/cf/48/alBO2azw_o.png" width="904"></p> 
<p class="img-center"><img alt="" height="398" src="https://images2.imgbox.com/d9/ed/41kzQQ91_o.png" width="947"></p> 
<p class="img-center"><img alt="" height="303" src="https://images2.imgbox.com/5d/3b/ACSKuN1n_o.png" width="881"></p> 
<p> 调用<code>AuthenticationManager</code>（认证管理器）对象的<code>authenticate()</code>方法，传入authentication这个参数。</p> 
<p> <img alt="" height="231" src="https://images2.imgbox.com/46/1f/BLhEGrIK_o.png" width="654"></p> 
<p>点开Authentication 发现，也是一个接口</p> 
<p> </p> 
<p class="img-center"><img alt="" height="138" src="https://images2.imgbox.com/0c/6c/9Xb7ULO9_o.png" width="402"></p> 
<p> 而Authentication实现类是</p> 
<p class="img-center"><img alt="" height="205" src="https://images2.imgbox.com/b4/e2/DGO2GHkS_o.png" width="850"></p> 
<p>它需要传入参数  ， 有两套构造方法，第一套第一个参数是用户名，第二个是密码。通过传入的参数取出用户名和密码。</p> 
<p class="img-center"><img alt="" height="237" src="https://images2.imgbox.com/9c/57/3xGtuoJ0_o.png" width="1006"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="201" src="https://images2.imgbox.com/8c/fe/oGE902Ly_o.png" width="841"></p> 
<p> 以上：根据取出的用户名和密码创建了用户认证对象authentication ，用于去调用认证管理器<strong><code>AuthenticationManager的认证方法authenticate()。</code></strong><code>最后验证登录成功。</code></p> 
<p> </p> 
<p>完成后，重启项目，可以通过API文档的调试功能来测试登录，如果使用无法登录的账号信息，会在服务器端的控制台看到对应的异常：  </p> 
<ul><li> <p>用户名不存在</p> </li></ul> 
<pre><code class="hljs">org.springframework.security.authentication.InternalAuthenticationServiceException: UserDetailsService returned null, which is an interface contract violation</code></pre> 
<ul><li> <p>密码错误</p> </li></ul> 
<pre><code class="hljs">org.springframework.security.authentication.BadCredentialsException: 用户名或密码错误</code></pre> 
<ul><li> <p>账号被禁用</p> </li></ul> 
<pre><code class="hljs">org.springframework.security.authentication.DisabledException: 用户已失效</code></pre> 
<p>可以在全局异常处理器中添加处理以上异常的方法，通常，在处理时，不会严格区分“用户名不存在”和“密码错误”这2种错误，也就是说，无论是这2种错误中的哪一种，一般提示“用户名或密码错误”即可，以进一步保障账号安全！</p> 
<p></p> 
<p>关于以上用户名不存在、密码错误时对应的异常，其继承结构是：</p> 
<pre><code class="hljs">AuthenticationException
-- BadCredentialsException // 密码错误
-- AuthenticationServiceException
-- -- InternalAuthenticationServiceException // 用户名不存在</code></pre> 
<p>则可以在处理异常的方法上，在<code>@ExceptionHandler</code>注解中指定需要处理的2种异常，并且，使用这2种异常公共的父类作为方法的参数，（如果光使用父类作为参数，父类下的其他异常也会被处理，所以要指定要处理的两种异常）例如：</p> 
<pre><code class="language-java">// 如果@ExceptionHandler没有配置参数，则以方法参数的异常为准，来处理异常
// 如果@ExceptionHandler配置了参数，则只处理此处配置的异常
@ExceptionHandler({
        InternalAuthenticationServiceException.class,
        BadCredentialsException.class
})
public JsonResult handleAuthenticationException(AuthenticationException e) {
    // 暂不关心方法内部的代码
}</code></pre> 
<p>在实际处理时，需要先在<code>ServiceCode</code>中添加新的枚举值，以表示以上错误的状态码：</p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/7d/5c/AzV74ORJ_o.png" width="559"></p> 
<p style="text-align:center;"> </p> 
<p>然后，在全局异常处理器中添加处理异常的方法：  </p> 
<pre><code class="language-java">// 如果@ExceptionHandler没有配置参数，则以方法参数的异常为准，来处理异常
// 如果@ExceptionHandler配置了参数，则只处理此处配置的异常
@ExceptionHandler({
        InternalAuthenticationServiceException.class,
        BadCredentialsException.class
})
public JsonResult handleAuthenticationException(AuthenticationException e) {
    log.warn("程序运行过程中出现了AuthenticationException，将统一处理！");
    log.warn("异常：", e);
    String message = "登录失败，用户名或密码错误！";
    return JsonResult.fail(ServiceCode.ERR_UNAUTHORIZED, message);
}

@ExceptionHandler
public JsonResult handleDisabledException(DisabledException e) {
    log.warn("程序运行过程中出现了DisabledException，将统一处理！");
    log.warn("异常：", e);
    String message = "登录失败，账号已经被禁用！";
    return JsonResult.fail(ServiceCode.ERR_UNAUTHORIZED_DISABLE, message);
}</code></pre> 
<p> </p> 
<blockquote> 
 <p>以上只能算验证已经完成了，还不能算登录已经成功，因为在判断用户名和密码对了以后，还需要把相关的信息比如用户，把它放进例如session里面去，回头判断有没有登录的标准，就是看session有没有这个信息，有就是登录了，没有就是没登录。所以登录不是判断用户名密码就结束，还需要把信息留下来，下次在来访问的时候才知道你是谁。不仅仅是验证的过程。</p> 
</blockquote> 
<h2 id="%E5%85%B3%E4%BA%8E%E8%AE%A4%E8%AF%81%E7%9A%84%E6%A0%87%E5%87%86">关于认证的标准</h2> 
<p>Spring Security为每个客户端分配了一个<code>SecurityContext</code>（可称之为“Security上下文”），并且，会根据在<code>SecurityContext</code>中<strong>是否存在认证信息</strong>来判断当前请求是否已经通过认证！即：</p> 
<ul><li> <p>如果在<code>SecurityContext</code>中<strong>存在</strong>有效的认证信息，则视为“<strong>已通过</strong>认证”</p> </li><li> <p>如果在<code>SecurityContext</code>中<strong>没有</strong>有效的认证信息，则视为“<strong>未通过</strong>认证”</p> </li></ul> 
<p>所以，在验证登录成功后，需要将认证信息存入到<code>SecurityContext</code>中，否则，所开发的登录功能是没有意义的！<br><br><strong>其实调用<code>AuthenticationManager</code>（认证管理器）对象的<code>authenticate()</code>方法</strong>时是可以接收到一个返回值的，可以获取到认证结果。</p> 
<p>使用<code>SecurityContextHolder</code>的<code>getContext()</code>静态方法可以获取当前客户端对应的<code>SecurityContext</code>对象！</p> 
<p class="img-center"><img alt="" height="425" src="https://images2.imgbox.com/50/f0/iVbiQLbC_o.png" width="705"></p> 
<p> </p> 
<p> 打印认证方法返回的结果</p> 
<p class="img-center"><img alt="" height="153" src="https://images2.imgbox.com/92/54/57Lm9h9q_o.png" width="711"></p> 
<p> </p> 
<p> 以上认证方法返回的结果例如：</p> 
<pre><code class="language-java">UsernamePasswordAuthenticationToken [
	Principal=org.springframework.security.core.userdetails.User [
		Username=root, 
		Password=[PROTECTED], 
		Enabled=true, 
		AccountNonExpired=true, 
		credentialsNonExpired=true, 
		AccountNonLocked=true, 
		Granted Authorities=[这是一个临时使用的山寨的权限！！！]
	], 
	Credentials=[PROTECTED], 
	Authenticated=true, 
	Details=null, 
	Granted Authorities=[这是一个临时使用的山寨的权限！！！]
]</code></pre> 
<p>其实，以上数据是基于<code>UserDetailsSerivce</code>实现类中<code>loadUserByUsername()</code>返回的<code>UserDetails</code>对象来创建的！</p> 
<p>后续整个Spring Security在登录之后每次发请求的时候就可以重SecurityContext的到这个数据，从而识别你的身份。</p> 
<p></p> 
<blockquote> 
 <p>以上算是实现了一个登录的完整功能，但是还有一个小的问题，比如在登录了的时候，服务端重启了，此时登录的信息就没了，此时在没有登录信息的时候去访问那些必须要登录的请求。会得到一个403错误。所以以下：</p> 
</blockquote> 
<h2 id="%E6%9C%AA%E9%80%9A%E8%BF%87%E8%AE%A4%E8%AF%81%E6%97%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE">未通过认证时拒绝访问</h2> 
<p>当未通过认证（Spring Security从<code>SecurityContext</code>中未找到认证信息）时，尝试访问那些需要授权的资源（不在白名单中的，需要先登录才可以访问的资源），在没有启用<code>http.formLogin()</code>时，默认将响应<code>403</code>错误！</p> 
<p>需要在Spring Security的配置类中进行处理：  </p> 
<p>首先用http去这个方法</p> 
<p class="img-center"><img alt="" height="174" src="https://images2.imgbox.com/6b/34/gpJybNji_o.png" width="803"></p> 
<p> 这个方法需要传进去的参数的类型是AuthenticationEntryPoint，点开后发现也是一个接口。</p> 
<p class="img-center"><img alt="" height="91" src="https://images2.imgbox.com/35/c2/ItihkhO3_o.png" width="767"></p> 
<p class="img-center"><img alt="" height="155" src="https://images2.imgbox.com/e0/c7/gkbhwKOk_o.png" width="963"></p> 
<p> 有两种方式，可以自己写个类去实现，但这个本身是一次性的使用，因为这个类只用在配置里，而配置本身是一次性的代码，所以可以用匿名内部类来写。</p> 
<p class="img-center"><img alt="" height="279" src="https://images2.imgbox.com/8c/e6/KBtM7X7u_o.png" width="1004"></p> 
<p> 这里我们需要向客户端去响应一个错误说你还没有登录，那么可以直接用response去响应，比如通过一个输出流-写出文本-关流响应一个简单内容：</p> 
<p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/12/c7/Uzuoh00k_o.png" width="826"></p> 
<p class="img-center"><img alt="" height="151" src="https://images2.imgbox.com/fa/18/khzdeiek_o.png" width="347"></p> 
<p> 但是现在响应的内容太过简单，可以响应一个message内容进去。</p> 
<p class="img-center"><img alt="" height="291" src="https://images2.imgbox.com/b9/0e/iEbCV1uO_o.png" width="651"></p> 
<p> 此时响应出现显示为一堆问号，这是因为java原始的服务器端的问题，默认使用的是ISO-8859-1这个编码格式，这种格式是不支持中文的。</p> 
<p class="img-center"><img alt="" height="153" src="https://images2.imgbox.com/09/38/ejyCoWe5_o.png" width="350"></p> 
<p> 要在文档响应之前，设置编码格式，例如：</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/b8/37/ISKE1oZ2_o.png" width="817"></p> 
<p>此时显示就没有问题了： </p> 
<p> <img alt="" height="224" src="https://images2.imgbox.com/78/50/5hqb1EMQ_o.png" width="652"></p> 
<p> 但此时任然不符合我们的设计需求。我们因该响应给客户端的是一个json结果，而不是一个字符串而已，需要更改文档类型前半截：</p> 
<p class="img-center"><img alt="" height="147" src="https://images2.imgbox.com/ea/d4/pBNzaUDa_o.png" width="777"></p> 
<p> 在写入一个json格式的字符串（格式可以复制，手敲累容易出错）：<br><img alt="" height="280" src="https://images2.imgbox.com/64/9e/UXCHVDCr_o.png" width="787"></p> 
<p> 得到显示json的结果：</p> 
<p class="img-center"><img alt="" height="126" src="https://images2.imgbox.com/0a/ff/ntOVDOdx_o.png" width="386"></p> 
<p> 现在代码恶心在需要自己去拼json这个结果，最终我们要响应的还是和之前成功处理请求和处理异常时得到是一样的结果，它依然是一个json格式的数据，只不过我们之前处理请求，处理异常返回JsonResult就可以，为什么返回JsonResult的对象最终响应是一个json的数据是因为springMVC框架帮我们做了数据格式的转换，转换成json格式的字符串。但现在不能转，它不在springMVC的范围之内。</p> 
<p class="img-center"><img alt="" height="70" src="https://images2.imgbox.com/91/62/QaG8m565_o.png" width="599"></p> 
<p> 则需要人为创建JSON格式的结果！可以借助<code>fastjson</code>工具进行处理，这是一款可以实现对象与JSON格式字符串相互转换的工具！需要添加依赖：</p> 
<pre><code class="language-XML">&lt;fastjson.version&gt;1.2.75&lt;/fastjson.version&gt;</code></pre> 
<pre><code class="language-XML">&lt;!-- fastjson：实现对象与JSON的相互转换 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;${fastjson.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p> 便可以用这个工具做以下调整：</p> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/88/2c/O5FgrEKz_o.png" width="805"></p> 
<p> 最终：</p> 
<p class="img-center"><img alt="" height="524" src="https://images2.imgbox.com/c6/cc/k8X1fA1Y_o.png" width="995"></p> 
<p> </p> 
<p>目前，登录算做好了，对Security使用难得部分已经过去了，下面是一些往后推进会设计的问题：</p> 
<h2 id="%E8%AF%86%E5%88%AB%E5%BD%93%E4%BA%8B%E4%BA%BA%EF%BC%88Principal%EF%BC%89">识别当事人（Principal）</h2> 
<p>当事人：当前提交请求的客户端的身份数据  。</p> 
<p>当事人是一种身份数据，作用是，比如你登录一款软件，这个软件得知道你是谁，不然就无法做相关的操作，例如登录之后你要修改自己的密码，首先它得知道你是谁，然后再去改你的密码。这份表示你到底是谁的这个数据其核心，我们就把它叫做当事人。</p> 
<p>当通过登录的验证后，<code>AuthenticationManager</code>的<code>authenticate()</code>方法返回的<code>Authentication</code>对象中，就包含了当事人信息！例如：  </p> 
<pre><code class="language-XML">UsernamePasswordAuthenticationToken [
	Principal=org.springframework.security.core.userdetails.User [
		Username=root, 
		Password=[PROTECTED], 
		Enabled=true, 
		AccountNonExpired=true, 
		credentialsNonExpired=true, 
		AccountNonLocked=true, 
		Granted Authorities=[这是一个临时使用的山寨的权限！！！]
	], 
	Credentials=[PROTECTED], 
	Authenticated=true, 
	Details=null, 
	Granted Authorities=[这是一个临时使用的山寨的权限！！！]
]</code></pre> 
<p> 数据里面的Principal这些数据就是当事人。</p> 
<p>由于已经将以上认证结果存入到<code>SecurityContext</code>中，则可以在后续任何需要识别当事人的场景中，获取当事人信息！  </p> 
<p>Spring Security提供了非常便利的获取当事人的做法，在控制器类中的处理请求的方法的参数列表中，可以声明当事人类型的参数（这里的user就是当时返回的userDetails，即可以说它是userDetails类型也可以说是User类型）：</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/ef/20/Pdjw4PwJ_o.png" width="771"></p> 
<p></p> 
<p>并在参数上添加<code>@AuthenticationPrincipal</code>注解即可，例如找到管理员的controller：  </p> 
<p> </p> 
<p class="img-center"><img alt="" height="279" src="https://images2.imgbox.com/1d/0f/PCyES8uw_o.png" width="961"></p> 
<p>上面添加@ApiIgnore是因为 写user有一个问题是API文档会以为你这个是请求参数，会在API文档中看到很多参数，调试里面也会有很多输入框，需要加上这个注解来忽略。</p> 
<p> <img alt="" height="478" src="https://images2.imgbox.com/1b/9f/A055LyYL_o.png" width="1055"></p> 
<p> 此时这个user是有值的</p> 
<p class="img-center"><img alt="" height="279" src="https://images2.imgbox.com/c3/a3/3TJ8AES8_o.png" width="961"></p> 
<p> 它的值就是在登录成功后返回的当事人数据： </p> 
<p class="img-center"><img alt="" height="254" src="https://images2.imgbox.com/54/22/5ywznR7z_o.png" width="932"></p> 
<p> 也就是这一截：</p> 
<pre><code class="language-XML">Principal=org.springframework.security.core.userdetails.User [
		Username=root, 
		Password=[PROTECTED], 
		Enabled=true, 
		AccountNonExpired=true, 
		credentialsNonExpired=true, 
		AccountNonLocked=true, 
		Granted Authorities=[这是一个临时使用的山寨的权限！！！]
	]</code></pre> 
<p>就可以通过get拿到当时人的信息： </p> 
<p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/3b/c9/C4zEW6zX_o.png" width="912"></p> 
<p> 完成以上代码后，重启项目，可以在API文档中使用各个账号尝试登录并访问以上“查询管理员列表”，可以看到日志中输出了当次登录的账号的用户名，例如：</p> 
<p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/a9/a7/OOuVhvxo_o.png" width="1200"></p> 
<p> </p> 
<blockquote> 
 <p>通过以上做法，虽然可以获取当事人信息，但是，无论是<code>UserDetails</code>还是<code>User</code>类型，可以获取的数据信息较少，且不包含当前登录的用户的ID，通常并不满足开发需求！  </p> 
</blockquote> 
<p> 需要记住：当前在控制器类中处理请求的方法中注入的当事人数据，就是<code>UserDetailsService</code>接口的实现类中返回的数据！</p> 
<p class="img-center"><img alt="" height="808" src="https://images2.imgbox.com/64/c3/lhPiwcCq_o.png" width="1200"></p> 
<p> 而里面的数据来自于loginInfo</p> 
<p class="img-center"><img alt="" height="102" src="https://images2.imgbox.com/cb/99/iJK2uBaj_o.png" width="544"></p> 
<p> loginInfo是从数据库查出来的</p> 
<p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/8b/b4/ydQwKom1_o.png" width="742"></p> 
<p> 所以如果需要获取当事人的ID，需要：</p> 
<p> 在<code>AdminLoginInfoVO</code>中添加ID属性</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/b5/4d/2VYL2trD_o.png" width="694"></p> 
<p> 修改Mapper层的<code>getLoginInfoByUsername()</code>，需要查询管理员ID</p> 
<p class="img-center"><img alt="" height="413" src="https://images2.imgbox.com/e3/43/iVldEzTy_o.png" width="914"></p> 
<p> 现有的<code>UserDetails</code>的实现类<code>User</code>并不支持ID属性，需要自定义类实现<code>UserDetails</code>接口，或者，自定义类继承自<code>User</code>类，在自定义类中扩展出所需的各种属性，例如ID</p> 
<p>因为它本身给了我们user类</p> 
<p class="img-center"><img alt="" height="155" src="https://images2.imgbox.com/82/27/o7b1vLRq_o.png" width="598"></p> 
<p> </p> 
<p> 点开后发现user实现了UserDetails类</p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/a5/0e/GbSYssAn_o.png" width="662"></p> 
<p> </p> 
<p> 所以我们自定义继承user相对于也实现了UserDetails，最终也可以作为这个方法的返回值。</p> 
<p class="img-center"><img alt="" height="159" src="https://images2.imgbox.com/1d/73/xrCJVl4L_o.png" width="770"></p> 
<p> </p> 
<p>在项目的根包下创建<code>security.AdminDetails</code>类，继承自<code>User</code>类，添加基于父类的构造方法，并扩展出ID属性：</p> 
<p class="img-center"><img alt="" height="239" src="https://images2.imgbox.com/2f/83/Zhziatps_o.png" width="884"></p> 
<p> 然后只用第二个多的构造方法，第一个可以去掉，第二个包含了第一个所有的参数，还有账户启动状态等必要的信息。</p> 
<p class="img-center"><img alt="" height="196" src="https://images2.imgbox.com/a0/65/mYp2p3f1_o.png" width="882"></p> 
<p>但同时也用不完第二个构造方法里面的所有参数，我们需要把自己的构造方法中不用的参数去掉，同时，在调用父类的构造方法的时候需要这个参数，我们在给个固定的值传过去就好了。</p> 
<p class="img-center"><img alt="" height="223" src="https://images2.imgbox.com/43/d8/OhYpHMms_o.png" width="909"></p> 
<p> 扩展出id属性，并给构造参数加上id传进来给值。回头还需要被这个值取出来，但是不能用@Data，因为Lombok需要在父类也就是user类有一个默认的无参构造方法，但是user没有。所以添加@Getter注解。</p> 
<p class="img-center"><img alt="" height="416" src="https://images2.imgbox.com/1f/18/6mHUueUn_o.png" width="972"></p> 
<p> 在<code>UserDetailsService</code>中返回数据时，改为返回自定义类的对象，其中将包含ID等属性值</p> 
<p class="img-center"><img alt="" height="357" src="https://images2.imgbox.com/ea/68/3IuLWqWK_o.png" width="864"></p> 
<p> 里面的自定义的传参会略有不用，之前判断账号是否禁用的==0，因为当时方法叫做disabled禁用，而自己的属性的启用，就用==1判断。</p> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/b7/f3/9vWWQIdM_o.png" width="615"></p> 
<p> 添加权限用集合，以下：</p> 
<p class="img-center"><img alt="" height="320" src="https://images2.imgbox.com/f2/09/tE5rou68_o.png" width="964"></p> 
<p> 最终代码如下：</p> 
<p class="img-center"><img alt="" height="443" src="https://images2.imgbox.com/d8/7e/I72k5r7g_o.png" width="844"></p> 
<p> 在控制器类中处理请求的方法中，注入的当事人类型改为自定义类型</p> 
<p class="img-center"><img alt="" height="195" src="https://images2.imgbox.com/1e/f0/CcMa54nL_o.png" width="738"></p> 
<p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/ca/fe/5iYef3H4_o.png" width="977"></p> 
<p> </p> 
<blockquote> 
 <p>以上实现了可以登录登录后也知道你是谁的功能，登录的效果就差不多了，而Spring Security还有一个重要的功能就是权限，我们可以区分不同的账户它有什么操作权限，使得某些用户可以做特定的事情。如果要去判端当前这个人有没有权限去做这个事情，第一件事是把现在给的山寨权限换成数据库里的真实权限。</p> 
</blockquote> 
<h2 id="%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE">实现根据权限限制访问</h2> 
<p> 首先，需要在管理员登录时，明确此管理员的权限，则需要在Mapper层实现“<strong>根据用户名查询管理员的登录信息，且需要包含此管理员对应的各权限</strong>”，需要执行的SQL语句大致是：</p> 
<pre><code class="language-sql">select
    ams_admin.id,
    ams_admin.username,
    ams_admin.password,
    ams_admin.enable,
    ams_permission.value
from ams_admin
left join ams_admin_role on ams_admin.id=ams_admin_role.admin_id
left join ams_role_permission on ams_admin_role.role_id=ams_role_permission.role_id
left join ams_permission on ams_role_permission.permission_id=ams_permission.id
where username='root';</code></pre> 
<p>然后，修改现有的查询功能，需要先在<code>AdminLoginInfoVO</code>类中添加新的属性，用于存放“权限列表”：</p> 
<p class="img-center"><img alt="" height="528" src="https://images2.imgbox.com/b7/b4/QdKLGVpR_o.png" width="534"></p> 
<p> </p> 
<p> </p> 
<p> 然后，调整<code>AdminMapper.xml</code>中的配置：</p> 
<pre><code class="language-XML">&lt;!-- AdminLoginInfoVO getLoginInfoByUsername(String username); --&gt;
&lt;select id="getLoginInfoByUsername" resultMap="LoginInfoResultMap"&gt;
    SELECT
        ams_admin.id,
        ams_admin.username,
        ams_admin.password,
        ams_admin.enable,
        ams_permission.value
    FROM ams_admin
        LEFT JOIN ams_admin_role ON ams_admin.id=ams_admin_role.admin_id
        LEFT JOIN ams_role_permission ON ams_admin_role.role_id=ams_role_permission.role_id
        LEFT JOIN ams_permission ON ams_role_permission.permission_id=ams_permission.id
    WHERE
        username=#{username}
&lt;/select&gt;

&lt;!-- resultMap标签：指导MyBatis封装查询结果 --&gt;
&lt;!-- resultMap标签的id属性：自定义名称，也是select标签上使用resultMap属性的值 --&gt;
&lt;!-- resultMap标签的type属性：封装查询结果的类型的全限定名 --&gt;
&lt;resultMap id="LoginInfoResultMap"
           type="cn.tedu.csmall.passport.pojo.vo.AdminLoginInfoVO"&gt;
    &lt;!-- id标签：配置主键的列与属性的对应关系 --&gt;
    &lt;!-- result标签：配置普通的列与属性的对应关系 --&gt;
    &lt;!-- collection标签：配置List集合类型的属性与查询结果中的数据的对应关系 --&gt;
    &lt;!-- collection标签的ofType属性：集合中的元素类型，取值为类型的全限定名 --&gt;
    &lt;id column="id" property="id"/&gt;
    &lt;result column="username" property="username"/&gt;
    &lt;result column="password" property="password"/&gt;
    &lt;result column="enable" property="enable"/&gt;
    &lt;collection property="permissions" ofType="String"&gt;
        &lt;!-- constructor标签：通过构造方法来创建对象 --&gt;
        &lt;constructor&gt;
            &lt;!-- arg标签：配置构造方法的参数，如果构造方法有多个参数，依次使用多个此标签 --&gt;
            &lt;arg column="value"&gt;&lt;/arg&gt;
        &lt;/constructor&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre> 
<h4 id="%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A%EF%BC%88%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8resultMap%E6%A0%87%E7%AD%BE%EF%BC%89%EF%BC%9A">补充解释（关于使用resultMap标签）：</h4> 
<p><a href="https://blog.csdn.net/YJH000_/article/details/131139081?spm=1001.2014.3001.5502" title="[SpringBoot]xml文件里写SQL用resultMap标签_万物更新_的博客-CSDN博客">[SpringBoot]xml文件里写SQL用resultMap标签_万物更新_的博客-CSDN博客</a></p> 
<p> 配置完成后，可以通过测试进行检验，查询结果例如：</p> 
<pre><code class="language-XML">根据【username=super_admin】查询数据完成，结果：

AdminLoginInfoVO(
	id=2, 
	username=super_admin, 
	password=$2a$10$N.ZOn9G6/YLFixAOPMg/h.z7pCu6v2XyFDtC4q.jeeGm/TEZyj15C, 
	enable=1, 
	permissions=[/pms/product/read, /pms/product/add-new, /pms/product/delete, /pms/product/update, /pms/brand/read, /pms/brand/add-new, /pms/brand/delete, /pms/brand/update, /pms/category/read, /pms/category/add-new, /pms/category/delete, /pms/category/update, /pms/picture/read, /pms/picture/add-new, /pms/picture/delete, /pms/picture/update, /pms/album/read, /pms/album/add-new, /pms/album/delete, /pms/album/update]
)</code></pre> 
<p> </p> 
<p> </p> 
<h2 id="%E5%9F%BA%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5">基于方法的权限检查</h2> 
<p>以上loginInfo已经有真实的权限信息，从中get出真实权限，遍历加到权限集合里面去，加进去后，返回的userDetails就有真正的权限信息了。</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/1f/4e/HbAOx1FT_o.png" width="782"></p> 
<blockquote> 
 <p>当有了真实的权限以后，接下来就可以对所有的访问加上权限的限制，就是某些人可以干什么，某些人不可以干什么。要实现这样的效果需要做两件事情。</p> 
</blockquote> 
<p>第一件事情，找到配置类， 开启权限的检查机制</p> 
<p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/2b/67/cUuSku1t_o.png" width="1200"></p> 
<p> 接下来就可以做访问什么需要什么权限，例如必须具有管理员权限的值的人，才可以查看权限列表。</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/b1/10/GFdBXIIS_o.png" width="1200"> </p> 
<p>加上下面这个注解后就表示你不光要登录，你的认证信息的权限列表里面必须要包含hasAuthority里面的这个值，才能够做这次的访问，如果不包含这个权限，就访问不了。</p> 
<p class="img-center"><img alt="" height="559" src="https://images2.imgbox.com/db/9c/PPXq7ia6_o.png" width="1200"></p> 
<p>提示：以上使用<code>@PreAuthorize</code>注解检查权限时，此注解可以添加在任何方法上！例如Controller中的方法，或Service中的方法等等，由于当前项目中，客户端的请求第一时间都是交给了Controller，所以，更适合在Controller方法上检查权限！</p> 
<p> </p> 
<p>当访问不包含所需的权限时， Spring Security给了我们以下这个异常：</p> 
<p class="img-center"><img alt="" height="237" src="https://images2.imgbox.com/51/73/teUSJjRe_o.png" width="935"></p> 
<p> 有异常在全局异常处理器里面处理异常：<img alt="" height="172" src="https://images2.imgbox.com/a7/ba/W26tdcvx_o.png" width="906"></p> 
<p> </p> 
<p>在<code>ServiceCode</code>中添加新的业务状态码表示“无此权限”：</p> 
<p><a href="https://blog.csdn.net/YJH000_/article/details/131142250" title="[异常]401和403的区分_万物更新_的博客-CSDN博客">[异常]401和403的区分_万物更新_的博客-CSDN博客</a></p> 
<p class="img-center"><img alt="" height="377" src="https://images2.imgbox.com/c3/ce/pXiHKHP6_o.png" width="700"></p> 
<p> </p> 
<p>然后，在全局异常处理器中添加处理以上异常的方法：  </p> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/4b/ac/ywtdQwh6_o.png" width="1178"></p> 
<p> </p> 
<p></p> 
<blockquote> 
 <p>以上权限做好以后，还需要给它添加Token功能，这样每次客服端在访问过一次之后，都不用在继续登陆。</p> 
</blockquote> 
<p><a href="https://blog.csdn.net/YJH000_/article/details/131142645?spm=1001.2014.3001.5502" title="[java]关于Session&amp;关于Token&amp;关于JWT_万物更新_的博客-CSDN博客">[java]关于Session&amp;关于Token&amp;关于JWT_万物更新_的博客-CSDN博客</a> </p> 
<h2 id="%E6%B7%BB%E5%8A%A0Token%C2%A0">添加Token </h2> 
<h4 id="%E9%A6%96%E5%85%88%E6%B7%BB%E5%8A%A0Token-JWT%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9%EF%BC%9A">首先添加Token-JWT的依赖项：</h4> 
<p>父项目添加版本管理：</p> 
<p class="img-center"><img alt="" height="127" src="https://images2.imgbox.com/2d/1b/DWpEMyCe_o.png" width="445"></p> 
<p> 父项目添加依赖：</p> 
<p class="img-center"><img alt="" height="205" src="https://images2.imgbox.com/89/a7/SlOM1VBl_o.png" width="489"></p> 
<p> 子项目添加依赖：</p> 
<p class="img-center"><img alt="" height="210" src="https://images2.imgbox.com/dc/d0/q5stfYG1_o.png" width="557"></p> 
<p> 添加好依赖以后做两个<strong>测试</strong>，一个生成JWT的测试，一个解析JWT 的测试：</p> 
<h4 id="%E7%94%9F%E6%88%90JWT%EF%BC%9A">生成JWT：</h4> 
<pre><code class="language-java">
    // 不太简单的、难以预测的字符串
    String secretKey = "jhdSfkkjKJ3831HdsDkdfSA9jklJD749Fhsa34fdsKf08dfjFhkdfs";

    @Test
    void generate() {
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put("id", 9527);
        claims.put("name", "张三");

        String jwt = Jwts.builder()
                // Header
                .setHeaderParam("alg", "HS256")
                .setHeaderParam("typ", "JWT")
                // Payload
                .setClaims(claims)
                .setExpiration(new Date(System.currentTimeMillis() + 3 * 60 * 1000))//设置有效期,防止一直用.
                // Verify Signature
                .signWith(SignatureAlgorithm.HS256, secretKey)
                // 生成
                .compact();
        System.out.println(jwt);
    }
</code></pre> 
<p>备注：</p> 
<p class="img-center"><img alt="" height="137" src="https://images2.imgbox.com/6b/9f/qVMR6910_o.png" width="471"></p> 
<p class="img-center"><img alt="" height="352" src="https://images2.imgbox.com/9e/d9/KYV6QkyK_o.png" width="826"></p> 
<p> 基于它的做法，我们可以自己传进去一个值：</p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/48/84/dGOf2xSf_o.png" width="798"></p> 
<p style="text-align:center;"> </p> 
<h4 id="%C2%A0%E8%A7%A3%E6%9E%90JWT"> 解析JWT</h4> 
<pre><code class="language-java">    // 不太简单的、难以预测的字符串
    String secretKey = "jhdSfkkjKJ3831HdsDkdfSA9jklJD749Fhsa34fdsKf08dfjFhkdfs";  

   @Test
    void parse() {
        String jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoi5byg5LiJIiwiaWQiOjk1MjcsImV4cCI6MTY4NDkwODUwMn0.tBo7YKRqQv6TG2cf5jeu7nNjUim5X8H6pKLF1LrYuKI";
        Claims claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
        Long id = claims.get("id", Long.class);
        String name = claims.get("name", String.class);
        System.out.println("id = " + id);
        System.out.println("name = " + name);
    }</code></pre> 
<p>备注： </p> 
<p>点进Claims可以看到本质是一个map</p> 
<p class="img-center"><img alt="" height="179" src="https://images2.imgbox.com/ac/29/TAVTjE17_o.png" width="731"></p> 
<p> 获取往里面放的值，直接给的是object，因为map的value被定义死了是object，取出也是object</p> 
<p class="img-center"><img alt="" height="167" src="https://images2.imgbox.com/bf/9a/IYQCptHq_o.png" width="938"></p> 
<p> 但在这里Claims在原有的map之上，get方法是有扩展的，传入的第二个参数就是你的目标类型是什么，这样传进去是什么类型得到的就是什么类型。</p> 
<p class="img-center"><img alt="" height="72" src="https://images2.imgbox.com/9e/bd/XEldh1Yk_o.png" width="590"></p> 
<p> </p> 
<p>以下是会这块会出现的异常，列举出来，回头需要全局处理。</p> 
<p>如果尝试解析的JWT已经过期，会出现异常：</p> 
<pre><code class="language-java">io.jsonwebtoken.ExpiredJwtException: JWT expired at 2023-05-24T12:02:38Z. Current time: 2023-05-24T14:04:35Z, a difference of 7317175 milliseconds.  Allowed clock skew: 0 milliseconds.</code></pre> 
<p> 如果解析JWT时使用的secretKey有误，会出现异常：</p> 
<pre><code class="language-java">io.jsonwebtoken.SignatureException: JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.</code></pre> 
<p>如果解析JWT的数据格式错误，会出现异常：</p> 
<pre><code class="language-java">io.jsonwebtoken.MalformedJwtException: JWT strings must contain exactly 2 period characters. Found: 1</code></pre> 
<h4 id="%E8%A1%A5%E5%85%85%EF%BC%9A">补充：</h4> 
<p class="img-center"><img alt="" height="115" src="https://images2.imgbox.com/37/98/fIHDifzb_o.png" width="797"></p> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/02/04/C4kSHGph_o.png" width="826"></p> 
<p><strong>注意：在不知晓secretKey的情况下，也可以解析出JWT中的数据（例如将JWT数据粘贴到官网），只不过验证签名是失败的，所以，不要在JWT中存放敏感信息（比如密码，手机号码，身份证号码等）！</strong><strong> </strong><img alt="" height="372" src="https://images2.imgbox.com/3c/59/vb0INbTS_o.png" width="985"></p> 
<p> </p> 
<p> <strong>验证签名是失败的</strong>就是说就算你知道里面的数据，但是我会告诉你不可信，比如id是9527但是也不要相信id就是9527，因为它很有可能是一个伪造的JWT，因为验证签名失败了。所以JWT的secretKey的价值是防止被伪造，而不是防止被解析出来，它不能做到这一点。<img alt="" height="279" src="https://images2.imgbox.com/1c/58/vlR5YmxN_o.png" width="759"></p> 
<p> </p> 
<blockquote> 
 <p>经过上面的测试，接下来就要在项目中使用JWT识别用户的身份了</p> 
</blockquote> 
<h2 id="%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8JWT%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E7%9A%84%E8%BA%AB%E4%BB%BD">在项目中使用JWT识别用户的身份</h2> 
<h3 id="%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B">核心流程</h3> 
<p> 在项目中使用JWT识别用户的身份，至少需要：</p> 
<ul><li> <p>当验证登录成功时，生成JWT数据，并响应到客户端去，是“卖票”的过程</p> 
  <ul><li> <p>当验证登录成功后，<strong>不再需要</strong>（没有必要）</p> </li><li> <p>当验证登录成功时，生成JWT数据，并响应到客户端去，是“卖票”的过程</p> 
    <ul><li> <p>当验证登录成功后，不再需要（没有必要）将认证结果存入到<code>SecurityContext</code>中 ，之前是这样的：</p> </li></ul></li></ul></li></ul> 
<p class="img-center"><img alt="" height="277" src="https://images2.imgbox.com/95/dd/QzXhtMin_o.png" width="770"></p> 
<p> </p> 
<ul><li> <p>当客户端提交请求时，需要获取客户端携带的JWT数据，并尝试解析，解析成功后，再将相关信息存入到<code>SecurityContext</code>中去，（因为之前我们说<code>Security去检验这个账号或者说这次客户端的访问到底是不是一个已认证的状态，就只是去看SecurityContext里面有没有东西，所以一旦解析成功之后，还是要把相关信息往SecurityContext里面放，然后就没了，后续说他有没有登录啊，有没有权限啊不是这里管的事，是Security去做后续的处理</code>）是“检票”的过程</p> 
  <ul><li> <p>可以调整Spring Security使用Session的策略，改为不使用Session，则不会将<code>SecurityContext</code>存入到Session中（不存在Session里面的好处是它就只作用在这一次请求中，这次请求结束了<code>SecurityContext就没了，当下次在过来的时候就又有了，结束了又没了。。。所以SecurityContext里面的认证信息只作用于当次那一次而已，在没有调整之前是基于session的，意味着如果session的有效期是15分钟，那你把认证信息存上下文里面，那这个上下文的有效时间就是15分钟，15分钟之内一直存在这个数据了，如果有效期是30分钟，那就会存在30分钟，在这个30分钟里面肯定是会有浪费的时间的，内存里面存这个信息就会浪费了，并且在你重新来访之后时间又会重新调整为30分钟，所以会有很长时间的浪费</code></p> </li></ul></li></ul> 
<p> </p> 
<p></p> 
<h4 id="%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E6%97%B6%E5%93%8D%E5%BA%94JWT">验证登录成功时响应JWT</h4> 
<p>需要调整的代码大致包括：</p> 
<ul><li> <p>在<code>IAdminService</code>中，将<code>login()</code>方法的返回值类型改为<code>String</code>类型，重写的方法作同样的修改</p> </li></ul> 
<p class="img-center"><img alt="" height="194" src="https://images2.imgbox.com/de/e7/tgOi9iNM_o.png" width="411"></p> 
<p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/c1/0c/OTAp4KIA_o.png" width="540"></p> 
<p> </p> 
<ul><li> <p>在<code>AdminServiceImpl</code>中，验证登录成功后，生成此管理员的信息对应的JWT（把上文测试里面生成JWT的代码拿过来做修改），并返回</p> </li></ul> 
<p><img alt="" height="408" src="https://images2.imgbox.com/a8/64/A9r7hG7p_o.png" width="752"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="249" src="https://images2.imgbox.com/d3/53/oaF7fOJy_o.png" width="826"></p> 
<p> </p> 
<ul><li> <p>在<code>AdminController</code>中，处理登录时，调用Service方法时获取返回的JWT，并响应到客户端去</p> </li></ul> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/fd/a9/cUmMnm35_o.png" width="848"></p> 
<p> </p> 
<p></p> 
<h2 id="%E8%A7%A3%E6%9E%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%90%BA%E5%B8%A6%E7%9A%84JWT">解析客户端携带的JWT</h2> 
<p>客户端提交若干种不同的请求时，可能都会携带JWT，对应的，在服务器，处理若干种不同的请求时，也都需要尝试接收并解析JWT，则应该使用<strong>过滤器（Filter）</strong>组件进行处理！</p> 
<p><a href="https://blog.csdn.net/YJH000_/article/details/130972154?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168646924116782425154703%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=168646924116782425154703&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-130972154-null-null.268%5Ev1%5Ekoosearch&amp;utm_term=fiter&amp;spm=1018.2226.3001.4450" title="[web]关于过滤器Filter_万物更新_的博客-CSDN博客">[web]关于过滤器Filter_万物更新_的博客-CSDN博客</a></p> 
<p>其实，Spring Security框架也使用了许多不同的过滤器来解决各种问题，为了保证解析JWT是有效的，解析JWT的代码<strong>必须运行在Spring Security的某些过滤器之前</strong>，则接收、解析JWT的代码也<strong>必须</strong>定义在过滤器中！</p> 
<blockquote> 
 <p>提示：过滤器（Filter）是Java服务器端应用程序的核心组件之一，它是最早接收到请求的组件！过滤器可以对请求选择“阻止”或“放行”！同一个项目中，允许存在若干个过滤器，形成“过滤器链（Filter Chain）”，任何请求必须被所有过滤器都“放行”，才会被控制器或其它组件所处理！</p> 
</blockquote> 
<p> 按照之前的方法，实现javax.servlet的过滤器接口，让后重写doFilter方法。</p> 
<p class="img-center"><img alt="" height="424" src="https://images2.imgbox.com/8a/bc/m5JLLRU7_o.png" width="964"></p> 
<p class="img-center"><img alt="" height="206" src="https://images2.imgbox.com/1d/b1/1jPT5P8J_o.png" width="629"></p> 
<p> 但是重写方法需要对类型进行强转，比较麻烦，不太好用。 </p> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/a6/7a/hEtY7mki_o.png" width="774"></p> 
<p> </p> 
<h4 id="%C2%A0%E6%88%91%E4%BB%AC%E8%BF%99%E6%AC%A1%E9%80%89%E6%8B%A9%E5%8E%BB%E7%BB%A7%E6%89%BFSpring%E7%B3%BB%E5%88%97%E6%A1%86%E6%9E%B6%E6%8F%90%E4%BE%9B%E7%9A%84OncePerRequestFilter%E8%BF%99%E4%B8%AA%E7%B1%BB%E3%80%82"> 我们这次选择去继承Spring系列框架提供的OncePerRequestFilter这个类。</h4> 
<p><img alt="" height="238" src="https://images2.imgbox.com/03/a1/fhzoaCR0_o.png" width="795"> </p> 
<p> 这个类是一个抽象类，这个类继承自GenericFilterBean这个类。<img alt="" height="149" src="https://images2.imgbox.com/e7/05/d1dg0wVU_o.png" width="752"></p> 
<p>而GenericFilterBean这个类实现了Filter这个接口， 所以继承OncePerRequestFilter这个类也算是实现了过滤器接口的。</p> 
<p class="img-center"><img alt="" height="187" src="https://images2.imgbox.com/b9/c1/uCXTiQ1f_o.png" width="774"></p> 
<p>继承spring这个框架提供的OncePerRequestFilter这个类已经帮我们做了强转了，就不用我们自己强转了。</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/e1/90/kMMlyPg1_o.png" width="975"> </p> 
<p> 所以在项目的根包下创建<code>filter.JwtAuthorizationFilter</code>类，继承自<code>OncePerRequestFilter</code>类，并添加<code>@Component</code>注解：</p> 
<pre><code class="language-java">@Slf4j
@Component
public class JwtAuthorizationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        log.debug("JwtAuthorizationFilter开始执行……");

        // 放行
        filterChain.doFilter(request, response);
    }

}</code></pre> 
<p>添加<code>@Component</code>注解把它标记成组件是因为通过注入，把解析JWT的代码<strong>必须运行在Spring Security的某些过滤器之前。</strong></p> 
<p class="img-center"><img alt="" height="490" src="https://images2.imgbox.com/6b/f5/mz2ZqjFM_o.png" width="1200"></p> 
<p> 到此可以测试通过API登录请求常看第一步过滤器有没有生效：</p> 
<p class="img-center"><img alt="" height="118" src="https://images2.imgbox.com/fa/c0/kw46npko_o.png" width="628"></p> 
<p>关于携带JWT，根据业内惯用的做法，客户端会将JWT放在请求头（Request Header）中的Authorization属性中，在Knife4j的API文档中，可以：</p> 
<p class="img-center"><img alt="" height="663" src="https://images2.imgbox.com/d2/c8/ZErb3diI_o.png" width="1156"></p> 
<p class="img-center"><img alt="" height="684" src="https://images2.imgbox.com/2a/24/bvpHITfR_o.png" width="1200"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/03/82/rvAwjzX4_o.png" width="627"></p> 
<p> </p> 
<p>关于过滤器的初步实现：</p> 
<pre><code class="language-java">/**
 * JWT过滤器，解决的问题：接收JWT，解析JWT，将解析得到的数据创建为认证信息并存入到SecurityContext
 */
@Slf4j
@Component
public class JwtAuthorizationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        log.debug("JwtAuthorizationFilter开始执行……");
        // 根据业内惯用的做法，客户端会将JWT放在请求头（Request Header）中的Authorization属性中
        String jwt = request.getHeader("Authorization");
        log.debug("客户端携带的JWT：{}", jwt);

        // 判断客户端是否携带了有效的JWT
        if (!StringUtils.hasText(jwt)) {
            // 如果JWT无效，则放行，并reture
            filterChain.doFilter(request, response);
            return;
        }

        // TODO 当前类和AdminServiceImpl中都声明了同样的secretKey变量，是不合理的
        // TODO 解析JWT过程中可能出现异常，需要处理
        // 尝试解析JWT
        String secretKey = "jhdSfkkjKJ3831HdsDkdfSA9jklJD749Fhsa34fdsKf08dfjFhkdfs";
        Claims claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
        Long id = claims.get("id", Long.class);
        String username = claims.get("username", String.class);
        System.out.println("id = " + id);
        System.out.println("username = " + username);

        // TODO 需要考虑使用什么数据作为当事人
        // TODO 需要使用真实的权限
        // 创建认证信息
        Object principal = username; //当事人 可以是任何类型，暂时使用用户名
        Object credentials = null; //凭证 本次不需要
        Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();//权限
        authorities.add(new SimpleGrantedAuthority("山寨权限"));
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                principal, credentials, authorities);

        // 将认证信息存入到SecurityContext中
        SecurityContext securityContext = SecurityContextHolder.getContext();
        securityContext.setAuthentication(authentication);

        // 放行
        filterChain.doFilter(request, response);
    }

}</code></pre> 
<p>因为上面代码中当事人是username，此时参数再用AdminDetails 声明是不对的，此处暂时去掉。</p> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/22/0d/WD7n2pNR_o.png" width="790"></p> 
<p> </p> 
<p>需要注意：由于Spring Security的<code>SecurityContext</code>默认是基于Session的，所以，当携带JWT成功登录访问过后，在<code>SecurityContext</code>中就已经有了认证信息，并且，在Session的有效期内，即使后续不携带JWT，Spring Security也能基于Session找到<code>SecurityContext</code>并读取到认证信息，并不在需要登录就能访问的，这可能与设计初衷并不相符！</p> 
<p></p> 
<p>可以将Spring Security使用（创建）Session的策略改为“完全不使用Session”，需要在Spring Security的配置类中添加配置：</p> 
<p class="img-center"><img alt="" height="304" src="https://images2.imgbox.com/30/c0/jAsTFdsB_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<p>备注：<br> 1.用StringUtils.hasText的方法</p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/9a/54/3aG1vqNn_o.png" width="949"></p> 
<p> 用StringUtils.hasText的方法可以同时判断，不能为空，不能为null，和包含文本。</p> 
<p class="img-center"><img alt="" height="160" src="https://images2.imgbox.com/8d/86/XMFv6v3c_o.png" width="599"></p> 
<p class="img-center"><img alt="" height="125" src="https://images2.imgbox.com/5c/99/nQAK5OuJ_o.png" width="699"></p> 
<p> 包含文本即不是空白就是包含文本：</p> 
<p class="img-center"><img alt="" height="185" src="https://images2.imgbox.com/9d/35/aNaqicb3_o.png" width="612"></p> 
<p> 2.关于 Object credentials = null本此不需要凭证，因为之前凭证的表现是密码，而放在上下文里的认证信息作用是回头框架来识别出你是谁，有什么权限，这个过程是不需要使用密码的。</p> 
<p> </p> 
<h2 id="%E5%85%B3%E4%BA%8E%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84%E5%BD%93%E4%BA%8B%E4%BA%BA">关于认证信息中的当事人</h2> 
<p>pring Security框架并不介意你使用什么类型作为认证信息（<code>Authentication</code>）中的当事人（<code>principal</code>）！</p> 
<p>在项目中，到底使用什么类型作为当事人，可以自行考虑，主要考虑的因素就是：当你需要注入当事人数据的时候，你希望能够得到哪些数据！</p> 
<p>在项目的根包下创建<code>security.LoginPrincipal</code>作为自定义的当事人类型：</p> 
<p class="img-center"><img alt="" height="638" src="https://images2.imgbox.com/1d/7c/xzTNbazv_o.png" width="1200"></p> 
<p> </p> 
<p>并且，在解析JWT成功后，在过滤去使用此类型作为当事人来创建认证信息：</p> 
<p class="img-center"><img alt="" height="477" src="https://images2.imgbox.com/63/a7/i95OLQZQ_o.png" width="1200"></p> 
<p> 后续，在Controller中，就可以通过<code>@AuthenticationPrincipal</code>来注入自定义的当事人数据，例如：</p> 
<p class="img-center"><img alt="" height="398" src="https://images2.imgbox.com/8e/ce/ivB9mRHl_o.png" width="1200"></p> 
<p> </p> 
<blockquote> 
 <p>接着处理一个小问题，因为在生成和解析JWT的时候对需要用到secretKey这个值，并且这个值相同，如果不相同就会签名失败，所以一个完全相同的代码写两遍是不合理的，有两种解决方案，第一种是专门写一个类去调取，第二个是写在application.yml文件里面，它们的区别是在application.yml里面需要读取在应用，有一个读取的过程，在类里面是直接应用的，从执行效率来说肯定是在类里面更快一些，但由于这个值需要甲方来定（为了防止伪造相关问题），所以必须写在application.yml里面。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="258" src="https://images2.imgbox.com/56/a6/Zuvnd8iE_o.png" width="834"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="445" src="https://images2.imgbox.com/99/f9/2eHVqswq_o.png" width="858"></p> 
<p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/35/26/f7zhWszg_o.png" width="814"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="367" src="https://images2.imgbox.com/1c/00/8s0Zky4G_o.png" width="479"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="135" src="https://images2.imgbox.com/50/69/k5e17IgM_o.png" width="735"></p> 
<p class="img-center"><img alt="" height="186" src="https://images2.imgbox.com/12/1f/Jvv313Y0_o.png" width="818"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/c5/7a/2vhTuNY7_o.png" width="874"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="185" src="https://images2.imgbox.com/bc/36/CiL3LyUX_o.png" width="768"></p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/3b/f8/z8wS7jpT_o.png" width="399"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="203" src="https://images2.imgbox.com/9a/a7/J57QRySj_o.png" width="852"></p> 
<p> </p> 
<blockquote> 
 <p> 关于secretKey必须有4位以上，否则都会被视为空值报错</p> 
</blockquote> 
<p class="img-center"><img alt="" height="89" src="https://images2.imgbox.com/77/dc/mJcRMu5f_o.png" width="433"></p> 
<p> </p> 
<blockquote> 
 <p>以上权限还是一个假的权限，需要换成真的权限，目前我们就用把权限放在JWT中，然后再从JWT中取出权限的方式。（以替换在数据库里查的方式，因为从数据库里查数据是一个效率低下的方式，其一需要连接，传递SQL，然后准备，准备好了编译执行，执行好了在给个结果一个过程。其二，数据库里面的数据存在硬盘里面，硬盘是一个存储效率非常低效的硬件。同时这段代码只要有客户端来访就会执行这段代码，发生的非常高频率，所以不能选择连接数据库这么低效的做法） </p> 
</blockquote> 
<p> 把集合放进JWT里面。</p> 
<p class="img-center"><img alt="" height="422" src="https://images2.imgbox.com/ea/a3/fUnHhh4O_o.png" width="867"></p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/36/50/A1yijxbl_o.png" width="747"> </p> 
<p> 从JWT取出权限列表<img alt="" height="344" src="https://images2.imgbox.com/38/b8/zBmhQgLy_o.png" width="860"></p> 
<p> 这样的取出方式看似语法没有问题，但会出现类型转换错误。</p> 
<p class="img-center"><img alt="" height="468" src="https://images2.imgbox.com/95/de/XUC9k9zL_o.png" width="1200"></p> 
<p> 因为在这一步，它获取出来的是LinkedHashMap，但是LinkedHashMap不能强制转其他类型，为什么获取的是LinkedHashMap类型呢，因为API不知道你要获取什么类型，给你处理为了LinkedHashMap。因为是集合加泛型也没有办法向获取id一样在后面第二个参数加上Long.class来指定返回的类型。</p> 
<p class="img-center"><img alt="" height="223" src="https://images2.imgbox.com/4d/a7/BumdhYaq_o.png" width="1010"></p> 
<p> </p> 
<p> 所以这里需要换一个做法，在生成JWT的时候不往里面放集合里，改为放Json，</p> 
<p class="img-center"><img alt="" height="488" src="https://images2.imgbox.com/05/9b/NYyNY8T9_o.png" width="1200"></p> 
<p> 可以放Json是因为我们有添加fastjson的依赖，实现对象和Json相互转换的依赖。</p> 
<p class="img-center"><img alt="" height="499" src="https://images2.imgbox.com/6f/35/2G8A6ljv_o.png" width="1200"></p> 
<p> 在从JWT 取出权限的时候也取出Json字符串，然后用fastjson转成集合</p> 
<p class="img-center"><img alt="" height="718" src="https://images2.imgbox.com/40/62/MKkU2Cqw_o.png" width="1200"></p> 
<p> </p> 
<p class="img-center"><img alt="" height="726" src="https://images2.imgbox.com/d4/24/f5Ua01Hy_o.png" width="1200"></p> 
<p>以上就实现真实权限的功能了。</p> 
<p> 注意：此方式也不是最优解决方案。</p> 
<p> </p> 
<blockquote> 
 <p>接下来处理解析JWT时可能出现的异常，往常我们是在全局异常处理器处理的，但是在这里不行，因为解析JWT是在过滤器里面做的，全局异常处理器只能处理controller抛出的异常。</p> 
</blockquote> 
<h2 id="%E5%A4%84%E7%90%86%E8%A7%A3%E6%9E%90JWT%E6%97%B6%E7%9A%84%E5%BC%82%E5%B8%B8">处理解析JWT时的异常</h2> 
<p>由于解析JWT是在过滤器组件中执行的，而过滤器是最早处理请求的组件，此时，控制器（Controller）还没有开始处理这次的请求，则全局异常处理器也无法处理解析JWT时出现的异常（全局异常处理器只能处理控制器抛出的异常）！这里使用最原始的try...catch处理</p> 
<p>首先，在<code>ServiceCode</code>中补充新的状态码：</p> 
<pre><code class="language-java">ERR_JWT_EXPIRED(60000),
ERR_JWT_MALFORMED(60100),
ERR_JWT_SIGNATURE(60200),</code></pre> 
<p>然后，在<code>JwtAuthorizationFilter</code>中，使用<code>try...catch</code>包裹尝试解析JWT的代码：</p> 
<pre><code class="language-java">// 尝试解析JWT
response.setContentType("application/json; charset=utf-8");
Claims claims = null;
try {
    claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
} catch (MalformedJwtException e) {
    String message = "非法访问！";
    log.warn("程序运行过程中出现了MalformedJwtException，将向客户端响应错误信息！");
    log.warn("错误信息：{}", message);
    JsonResult jsonResult = JsonResult.fail(ServiceCode.ERR_JWT_MALFORMED, message);
    String jsonString = JSON.toJSONString(jsonResult);
    PrintWriter printWriter = response.getWriter();
    printWriter.println(jsonString);
    printWriter.close();
    return;
} catch (SignatureException e) {
    String message = "非法访问！";
    log.warn("程序运行过程中出现了SignatureException，将向客户端响应错误信息！");
    log.warn("错误信息：{}", message);
    JsonResult jsonResult = JsonResult.fail(ServiceCode.ERR_JWT_SIGNATURE, message);
    String jsonString = JSON.toJSONString(jsonResult);
    PrintWriter printWriter = response.getWriter();
    printWriter.println(jsonString);
    printWriter.close();
    return;
} catch (ExpiredJwtException e) {
    String message = "您的登录信息已经过期，请重新登录！";
    log.warn("程序运行过程中出现了ExpiredJwtException，将向客户端响应错误信息！");
    log.warn("错误信息：{}", message);
    JsonResult jsonResult = JsonResult.fail(ServiceCode.ERR_JWT_EXPIRED, message);
    String jsonString = JSON.toJSONString(jsonResult);
    PrintWriter printWriter = response.getWriter();
    printWriter.println(jsonString);
    printWriter.close();
    return;
} catch (Throwable e) {
    String message = "服务器忙，请稍后再试！【在开发过程中，如果看到此提示，应该检查服务器端的控制台，分析异常，并在解析JWT的过滤器中补充处理对应异常的代码块】";
    log.warn("程序运行过程中出现了Throwable，将向客户端响应错误信息！");
    log.warn("异常：", e);
    JsonResult jsonResult = JsonResult.fail(ServiceCode.ERR_UNKNOWN, message);
    String jsonString = JSON.toJSONString(jsonResult);
    PrintWriter printWriter = response.getWriter();
    printWriter.println(jsonString);
    printWriter.close();
    return;
}</code></pre> 
<p>注意：</p> 
<p>以上代码中只有response.setContentType("application/json; charset=utf-8");这串代码可以提到最上面给每一个catch复用。 PrintWriter printWriter = response.getWriter();<strong>是不可以的</strong>：</p> 
<p class="img-center"><img alt="" height="192" src="https://images2.imgbox.com/31/a2/EFpmNJL7_o.png" width="803"></p> 
<p>把printWriter 放在上面会导致本该在正常成功访问的时候会报状态异常错误，说getWriter在本次调用中已经被占用了。原因是我们服务端向客户端响应就是用printWriter 来响应的，然后你在上图中拿到了getWriter输出流，控制器那边就拿不到响应成功的输出流了，以至于控制器没有办法去响应。<img alt="" height="91" src="https://images2.imgbox.com/b2/2a/oyeaDwq6_o.png" width="893"></p> 
<p> </p> 
<p> </p> 
<blockquote> 
 <p> 以上JWT就差不多了，以下在和前端结合的时候还需要实现的一些功能。</p> 
</blockquote> 
<h2 id="%E5%A4%84%E7%90%86%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">处理复杂请求的跨域问题</h2> 
<p>当客户端提交请求时，在请求头中配置了特定的属性（例如<code>Authorization，带了JWT的时候</code>），则这个请求会被视为“复杂请求”：</p> 
<p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/11/11/1U0Egmy2_o.png" width="752"></p> 
<p>对于复杂请求，浏览器会先对服务器端发送<code>OPTIONS</code>类型的请求（也是和get，post一样的请求方式，<code>OPTIONS请求的目的是试一下服务器是不是好的，是不是可以接受</code>），以执行预检（PreFlight），如果预检通过，才会执行本应该发送的请求。</p> 
<p>然后会看到它的请求就需要给它配置白名单已通过。</p> 
<p class="img-center"><img alt="" height="456" src="https://images2.imgbox.com/94/31/ukM31rFr_o.png" width="787"></p> 
<p> 在Spring Security的配置类中，可以在配置对请求授权时，将所有<code>OPTIONS</code>类型的请求全部直接许可，例如：</p> 
<p class="img-center"><img alt="" height="566" src="https://images2.imgbox.com/b7/95/rgHPwawe_o.png" width="1200"></p> 
<p> 或者，调用参数对象的<code>cors()</code>方法也可以，例如：</p> 
<p class="img-center"><img alt="" height="197" src="https://images2.imgbox.com/01/a6/ZvIf2NTB_o.png" width="1090"></p> 
<p>提示：对于复杂请求的预检，是浏览器的行为，并且，当某个请求通过预检后，浏览器会缓存此结果，后续再次发出此请求时，不会再次执行预检。</p> 
<p></p> 
<p></p> 
<blockquote> 
 <p>实现单点登录，以下</p> 
</blockquote> 
<p> </p> 
<h2 id="%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95">单点登录</h2> 
<p><strong>SSO</strong>（<strong>S</strong>ingle <strong>S</strong>ign <strong>O</strong>n）：单点登录，表示在集群或分布式系统中，客户端只需要在某1个服务器上完成登录的验证，后续，无论访问哪个服务器，都不需要再次重新登录！常见的实现手段主要有：共享Session，使用Token。  </p> 
<p> 目前，如果希望客户端在<code>csmall-passport</code>中登录后，在<code>csmall-product</code>中也能够被识别身份、权限，需要：</p> 
<ul><li> <p>复制依赖项：<code>spring-boot-starter-security</code>、<code>jjwt</code>、<code>fastjson</code></p> </li></ul> 
<p class="img-center"><img alt="" height="279" src="https://images2.imgbox.com/e3/05/uUNM1npN_o.png" width="987"></p> 
<ul><li> <p>复制<code>LoginPrincipal</code></p> </li></ul> 
<p class="img-center"><img alt="" height="228" src="https://images2.imgbox.com/5e/68/NoR4wSAP_o.png" width="752"></p> 
<p> </p> 
<ul><li> <p>复制<code>ServiceCode</code>，覆盖此前的文件</p> </li></ul> 
<p class="img-center"><img alt="" height="405" src="https://images2.imgbox.com/c9/fa/3oOlt3no_o.png" width="697"></p> 
<ul><li> <p>复制<code>application-dev.yml</code>中的自定义的配置</p> </li></ul> 
<p class="img-center"><img alt="" height="305" src="https://images2.imgbox.com/c9/cc/ezvZCYAV_o.png" width="957"></p> 
<ul><li> <p>复制<code>JwtAuthorizationFilter</code></p> </li></ul> 
<p class="img-center"><img alt="" height="403" src="https://images2.imgbox.com/53/8f/rIoiHBAK_o.png" width="852"></p> 
<p> </p> 
<ul><li> <p>复制<code>SecurityConfiguration，并更改导包</code></p> 
  <ul><li> <p>删除<code>PasswordEncoder</code>的<code>@Bean</code>方法</p> </li><li> <p>删除<code>AuthenticationManager</code>的<code>@Bean</code>方法</p> </li><li> <p>删除“白名单”中管理员登录的URL地址</p> </li></ul></li></ul> 
<p>完成后，在<code>csmall-product</code>项目中，也可以通过<code>@AuthenticationPrincipal</code>来注入当事人数据，也可以使用<code>@PreAuthorize</code>来配置访问权限，这些都是通的。</p> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/b8/4d/DH4750Wr_o.png" width="983"></p> 
<p class="img-center"><img alt="" height="160" src="https://images2.imgbox.com/3a/4a/aXv7hhhF_o.png" width="651"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72a9043a03b2b9063e437623e460b5ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">更新 deployment 解决 field is immutable 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76b4503bd8e1e5712d883e38d118b9a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">理解和创建Windows和Linux下的动态和静态库区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>