<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【leetcode】优先队列题目集合 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【leetcode】优先队列题目集合" />
<meta property="og:description" content="一、在N个元素中选出前M个元素（N远大于M时） 在1,000,000个元素中选出前100名。
思路一：对N的元素进行排序，然后选出前M个元素，时间复杂度为O(NlogN)（采用快排或归并排序等高级排序算法）
思路二：使用优先队列，可以将时间复杂度降低为O(NlogM)。具体实现：使用优先队列维护M个元素，即每次向优先队列中加入一个元素时，需要将当前队列中的最小元素替换出去，保证队列中的M个元素是当前遍历过的元素中的最大的前M个。
使用最小堆
347 前k个高频元素
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:
输入: nums = [1], k = 1
输出: [1]
import heapq from collections import Counter class Solution: def topKFrequent(self, nums, k): res = [] dic = Counter(nums) max_heap = [(-val, key) for key, val in dic.items()] heapq.heapify(max_heap) for i in range(k): # 把Heap里面出现最大的几个数pop出来就好，记得这里需要pop出来的是key, 不是val res.append(heapq.heappop(max_heap)[1]) return res # 利用Counter &#43; PriorityQueue来做 # python skill class Solution(object): def topKFrequent(self, nums, k): return [item[0] for item in collections." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/425d23c3b39af22abbd4ae65c5da5697/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-18T18:52:45+08:00" />
<meta property="article:modified_time" content="2019-08-18T18:52:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【leetcode】优先队列题目集合</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、在N个元素中选出前M个元素（N远大于M时）</h2> 
<p>在1,000,000个元素中选出前100名。</p> 
<p>思路一：对N的元素进行排序，然后选出前M个元素，时间复杂度为O(NlogN)（采用快排或归并排序等高级排序算法）<br> 思路二：使用优先队列，可以将时间复杂度降低为O(NlogM)。<span style="color:#f33b45;"><strong>具体实现：使用优先队列维护M个元素，即每次向优先队列中加入一个元素时，需要将当前队列中的最小元素替换出去，保证队列中的M个元素是当前遍历过的元素中的最大的前M个。</strong></span><br> 使用最小堆</p> 
<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" rel="nofollow">347 前k个高频元素</a></p> 
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p> 
<p>示例 1:</p> 
<p>输入: nums = [1,1,1,2,2,3], k = 2<br> 输出: [1,2]<br> 示例 2:</p> 
<p>输入: nums = [1], k = 1<br> 输出: [1]</p> 
<pre class="has"><code class="language-python">import heapq
from collections import Counter
class Solution:
    def topKFrequent(self, nums, k):
        res = []
        dic = Counter(nums)
        max_heap = [(-val, key) for key, val in dic.items()]
        heapq.heapify(max_heap)
        for i in range(k):
            # 把Heap里面出现最大的几个数pop出来就好，记得这里需要pop出来的是key, 不是val
            res.append(heapq.heappop(max_heap)[1])
        return res   
# 利用Counter + PriorityQueue来做

# python skill
class Solution(object):
    def topKFrequent(self, nums, k):
        return [item[0] for item in collections.Counter(nums).most_common(k)]</code></pre> 
<pre class="has"><code class="language-java">class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
              
        //将数组放入一个记录频次的Map中
        TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();
        for(int num : nums){
            if(map.containsKey(num)){
                map.put(num, map.get(num)+1);
            }else{
                map.put(num, 1);
            }
        }
        
        
        //通过一个最多可容纳K个元素的优先队列来选出出现频率前k高的k个元素
        //优先队列在构造时，通过传入的外部比较器Comparator 可以定义优先队列里元素类型的比较方法
        //这里，优先队列里存放Integer, 传入的外部比较器重新定义了比较两个整型类型的方法，即比较它们出现的频次
        //Java内置优先队列的底层是最小堆，所以出队的是根据比较器定义的最小元素
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;(){
            @Override
            public int compare(Integer a, Integer b){  //使用匿名内部类实现Comparator接口，重新定义了比较两个整型类型的方法，即比较它们出现的频次
                return map.get(a)-map.get(b);
            }
        });
        
        for(int num : map.keySet()){  
            if(pq.size()&lt;k){
                pq.add(num);
            }else{
                if(map.get(num)&gt;map.get(pq.peek())){  //优先队列内只保持k个元素，入队时需要和优先级最高的元素（（频次）最小的元素）作比较
                    pq.remove();
                    pq.add(num);
                }
            }
        }
        
        //根据要求，返回一个List
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        while(!pq.isEmpty()){
            list.add(pq.remove());
        }
        
        return list;                                                  
    }
}</code></pre> 
<h2>二、POJ2431</h2> 
<p>用优先队列模拟贪心</p> 
<p>题意：</p> 
<p>驾驶卡车行驶L单位距离，卡车初始P单位汽油，行驶1单位距离消耗1单位汽油。图中有一些加油站，可以在加油站中给汽车加油，知道加油站离终点的距离也知道每个加油站最多给汽车加多少油，现在要求最少停车几次，能够使得汽车到达终点。若不能到达，输出-1。</p> 
<p>思路：</p> 
<p>题目中加油站数量N非常大，所以不能暴力。然后可以这样想，路过加油站的时候，先不加油，但是你没油的时候你要知道你之前是可以加油的。也就是到达加油站的时候，就获得了加油的权利。这样，当汽车没油的时候，认为在之前加过油就行了。<br> 那么为了使得加油次数最少，每次没油的时候就选取经过的加油站中能够加油最多的一个加油站加油即可。那么就用到了优先队列，大根堆。路过时push()，加油时pop()。</p> 
<p>解题思路：反正就是一个个站点遍历下去，如果够不到下一个站点，那说明前面需要加油。就把优先队列中加油最大的那个提出来。每扫过一个站点，把它可加的油放入优先队列中维护。</p> 
<pre class="has"><code class="language-cpp">    #include&lt;iostream&gt;
    #include&lt;cstdio&gt;
    #include&lt;queue&gt;
    #include&lt;algorithm&gt;
    using namespace std; 
    const int maxn = 10010; 
    struct Node{
        int x;
        int y;
    }stop[maxn];
    bool cmp (Node a, Node b)           //按照距离从大到小排序 
    {
        return a.x &gt; b.x;   
    }
    int main()
    {
        int n, l, p, cnt = 0;;
        scanf("%d",&amp;n);
        priority_queue&lt;int &gt; q;
        for(int i = 0; i &lt; n ;i ++){
            scanf("%d%d", &amp;stop[i].x, &amp;stop[i].y);
        }
        scanf("%d%d", &amp;l, &amp;p);
        sort(stop, stop + n, cmp);
        int i = 0;
        p ++;               //防止初始位置就有加油站 
        l ++;
        while(p != 0 &amp;&amp; l != 0){
            p --;
            l --;
            //cout&lt;&lt;"p="&lt;&lt;p&lt;&lt;" l="&lt;&lt;l&lt;&lt;endl;
            if(l == 0)      //到达终点 
                break;

            if(i &lt; n &amp;&amp; stop[i].x == l){    //路过加油站 
                q.push(stop[i++].y);
            }
            if(p == 0 &amp;&amp; q.size() != 0){    //没油了 并且还可以加油 
                p += q.top();
                q.pop();
                cnt ++;                     //停车次数加1 
            }
        }
        if(l == 0){
            printf("%d\n",cnt);
        } else {
            printf("-1\n");
        }
        return 0;   
    } </code></pre> 
<p>参考：</p> 
<p><a href="https://blog.csdn.net/WaveBridge/article/details/79079643">优先队列简单介绍+例题POJ2431</a></p> 
<h2>三、小红薯笔试</h2> 
<p><img alt="" class="has" height="584" src="https://images2.imgbox.com/28/5a/Vg0on3em_o.png" width="457"></p> 
<p><img alt="" class="has" height="400" src="https://images2.imgbox.com/fa/e8/0jkSO0vX_o.png" width="454"></p> 
<p>血量降序排序：2~max，选择一个最合适的值（因为如果大的都不行，那么比这个“大”的小的元素就都不行，根本不用考虑。）</p> 
<p>选出这个最合适的值a，分别对每个元素攻击Xi（相减），Xi-a后的值也放入优先队列里，每次都从优先队列里找到最大的元素。</p> 
<pre class="has"><code class="language-python">def list2gen(a):
    for n in a:
        yield n
 
def ismatch(X):
    # 在达到目标时输出X
    fali_need = 0
    for Hi in list2gen(H):
        fali_need += Hi // X
#        fali_need = sum([Hi // X for Hi in H])
    # 法力不够，用物理攻击弥补
    if fali_need &gt;= M:
        wuli_need = X * (fali_need - M)
        for Hi in list2gen(H):
            wuli_need += Hi % X
#            wuli_need += sum([Hi % X for Hi in H])
        if M + fali_need &lt;= T:
            return True
        else:
            return False
    # 法力超出，多出来的这样用
    # X=3，Hi=2,这样使用一次
    else:
        yushu = sorted([Hi % X for Hi in H])
        wuli_need = sum(sorted(yushu)[::-1][M - fali_need :])
        if M + wuli_need &lt;= T:
            return True
        else:
            return False
 
def solution(N, T, M, H):
    H = sorted(H)[::-1]     
    # 特殊情况
    if M + sum(H[M:]) &gt; T:
        return -1         
    l = (sum(H) - (T - M)) // M
    r = H[0]
#    print(l, r)
    while l &lt; r:
        mid = l + ((r - l) &gt;&gt; 1)
#        print(f'mid: {mid}')
        if ismatch(mid):
            r = mid
        else:
            l = mid + 1
    return l
 
import sys
line = sys.stdin.readline().strip()
N, T, M = list(map(int, line.split()))
line = sys.stdin.readline().strip()
H = list(map(int, line.split()))
print(solution(N, T, M, H))
</code></pre> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
using namespace std;

int main()
{
    int n, t, m;
    cin&gt;&gt;n&gt;&gt;t&gt;&gt;m;
    int h[100010];
    for (int i = 1; i &lt;= n; ++i)
    	cin&gt;&gt;h[i];
    sort(h + 1, h + n + 1);
    int l = 0, r = h[n], ans;
    int x = 0x3ffffff;
    while(l &lt;= r)
    {
    	int mid = (l + r) / 2;
    	priority_queue&lt;int&gt; que;
    	ans = 0;
    	int cnt = m;

    	for (int i = 1; i &lt;= n; ++i)
    	{
    		int tmp = (h[i] / mid &lt; cnt) ? (h[i] / mid) : cnt;	
    		ans += tmp;
    		cnt -= tmp;
    		que.push(h[i] - tmp * mid);

    	}
    	while(!que.empty())
    	{
    		ans += (cnt &gt; 0) ? 1 : que.top();
    		que.pop();
    		cnt--;
    	}
    	if (ans &lt;= t)
    	{
    		x = (mid &lt; x) ? mid : x;
    		r = mid - 1;
    	}
    	else
    	{
    		l = mid + 1;
    	}
    }
    if (x &lt;= 0x3ffffff)
    {
    	cout&lt;&lt;x&lt;&lt;endl;
    }
    else
    {
    	cout&lt;&lt;(-1)&lt;&lt;endl;
    }
}</code></pre> 
<p><a href="https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/" rel="nofollow">871. 最低加油次数</a></p> 
<p><a href="https://blog.csdn.net/qq_28120673/article/details/81076179">Expedition (POJ2431)运用优先级队列解题</a></p> 
<p>有个优先队列题目汇总的<a href="https://www.cnblogs.com/xenny/p/9379659.html" rel="nofollow">https://www.cnblogs.com/xenny/p/9379659.html</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d59bdce328db47c5eb6bf0c09ee9049/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用maven，在一个项目中调用另一个项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/adc6d969aad4f37b93c424a28e01f39a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Petalinux系列-Petalinux2019.1安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>