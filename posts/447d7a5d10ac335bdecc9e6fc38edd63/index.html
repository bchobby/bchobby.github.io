<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA8 十大新特性详解 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA8 十大新特性详解" />
<meta property="og:description" content="一、接口的默认方法 在接口中新增了default方法和static方法，这两种方法可以有方法体 1、static方法 示例代码：
public interface DefalutTest { static int a =5; default void defaultMethod(){ System.out.println(&#34;DefalutTest defalut 方法&#34;); } int sub(int a,int b); static void staticMethod() { System.out.println(&#34;DefalutTest static 方法&#34;); } } 接口里的静态方法，即static修饰的有方法体的方法不会被继承或者实现，但是静态变量会被继承 例如：我们添加一个接口DefalutTest的实现类DefaultTestImpl
public class DefaultTestImpl implements DefalutTest{ @Override public int sub(int a, int b) { // TODO Auto-generated method stub return a-b; } } 如下图所示是这个实现类中所有可调用的方法： 在这些方法里面我们无法找到staticMethod方法，则说明接口中的static方法不能被它的实现类直接使用。但是我们看到了defaultMethod，说明实现类可以直接调用接口中的default方法； 那么如何使用接口中的static方法呢？？？ 接口.static方法调用，如：DefalutTest.staticMethod();
public static void main(String[] args) { DefaultTestImpl dtl = new DefaultTestImpl(); DefalutTest." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/447d7a5d10ac335bdecc9e6fc38edd63/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-30T22:14:17+08:00" />
<meta property="article:modified_time" content="2017-03-30T22:14:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA8 十大新特性详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="一接口的默认方法">一、接口的默认方法</h3> 
<p>在接口中新增了<strong>default</strong>方法和<strong>static</strong>方法，这两种方法可以有方法体 <br> <strong>1、static方法</strong> <br> 示例代码：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> DefalutTest {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a =<span class="hljs-number">5</span>;
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> defaultMethod(){
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"DefalutTest defalut 方法"</span>);
    }

    <span class="hljs-keyword">int</span> sub(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b);

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> staticMethod() {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"DefalutTest static 方法"</span>);
    }
}</code></pre> 
<p>接口里的静态方法，即static修饰的有方法体的方法不会被继承或者实现，但是静态变量会被继承 <br> 例如：我们添加一个接口DefalutTest的实现类DefaultTestImpl</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultTestImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DefalutTest</span>{<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        <span class="hljs-keyword">return</span> a-b;
    }

}</code></pre> 
<p>如下图所示是这个实现类中所有可调用的方法： <br> <img src="https://images2.imgbox.com/76/3c/z0LNEN6M_o.png" alt="这里写图片描述" title=""> <br> 在这些方法里面我们无法找到staticMethod方法，则说明接口中的static方法不能被它的实现类直接使用。但是我们看到了defaultMethod，说明实现类可以直接调用接口中的default方法； <br> 那么如何使用接口中的static方法呢？？？ <br> 接口.static方法调用，如：DefalutTest.staticMethod();</p> 
<pre class="prettyprint"><code class=" hljs cs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        DefaultTestImpl dtl = <span class="hljs-keyword">new</span> DefaultTestImpl();
        DefalutTest.staticMethod();
    }</code></pre> 
<p>当我们试图使用接口的子接口去调用父接口的static方法是，我们发现，无法调用，找不到方法： <br> <img src="https://images2.imgbox.com/8e/65/kAIPRfHC_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>结论：接口中的static方法不能被继承，也不能被实现类调用，只能被自身调用</strong></p> 
<p><strong>2、default方法</strong> <br> 准备一个子接口继承DefalutTest接口</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SubTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefalutTest</span>{<!-- --></span>

}</code></pre> 
<p>准备一个子接口的实现类</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTestImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SubTest</span>{<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        <span class="hljs-keyword">return</span> a-b;
    }

}
</code></pre> 
<p>现在我们创建一个子接口实现类对象，并调用对象中的default方法：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        SubTestImp stl = <span class="hljs-keyword">new</span> SubTestImp();
        stl.defaultMethod();

    }
}</code></pre> 
<p>执行结果： <br> DefalutTest defalut 方法</p> 
<p><strong>结论1：default方法可以被子接口继承亦可被其实现类所调用</strong></p> 
<p>现在我们在子接口中重写default方法，在进行调用：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SubTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefalutTest</span>{<!-- --></span>

    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> defaultMethod(){
        System.out.println(<span class="hljs-string">"SubTest defalut 方法"</span>);
    }
}</code></pre> 
<p>执行结果：SubTest defalut 方法</p> 
<p><strong>结论2：default方法被继承时，可以被子接口覆写</strong></p> 
<p>现在，我们去除接口间的继承关系，并使得SubTestImp同时实现父接口和子接口，我们知道此时父接口和子接口中存在同名同参数的default方法，这会怎么样？ <br> 如下图所示，实现类报错，实现类要求必须指定他要实现那个接口中的default方法 <br> <img src="https://images2.imgbox.com/cd/ea/By85zVfp_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>结论3：如果一个类实现了多个接口，且这些接口中无继承关系，这些接口中若有相同的（同名，同参数）的default方法，则接口实现类会报错，接口实现类必须通过特殊语法指定该实现类要实现那个接口的default方法</strong> <br> 特殊语法：<code>&lt;接口&gt;.super.&lt;方法名&gt;([参数])</code> <br> 示例代码：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTestImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SubTest</span>,<span class="hljs-title">DefalutTest</span>{<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        <span class="hljs-keyword">return</span> a-b;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span>() {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        DefalutTest.<span class="hljs-keyword">super</span>.defaultMethod();
    }

}</code></pre> 
<p>使用示例：</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//接口代码</span>
interface Formula {
    <span class="hljs-keyword">double</span> calculate(<span class="hljs-keyword">int</span> a);
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">double</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">sqrt</span>(a);
    }
}
<span class="hljs-comment">//实现</span>
Formula formula = <span class="hljs-keyword">new</span> Formula() {
    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> calculate(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(a * <span class="hljs-number">100</span>);
    }
};
formula.calculate(<span class="hljs-number">100</span>);     <span class="hljs-comment">// 100.0</span>
formula.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">16</span>);           <span class="hljs-comment">// 4.0</span></code></pre> 
<h3 id="二lambda-表达式">二、Lambda 表达式 </h3> 
<p>Lambda表达式可以看成是匿名内部类，使用Lambda表达式时，接口必须是<strong>函数式接口</strong></p> 
<p><strong>基本语法：</strong></p> 
<pre class="prettyprint"><code class=" hljs coffeescript">            &lt;函数式接口&gt;  &lt;变量名&gt; = <span class="hljs-function"><span class="hljs-params">(参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2.</span>..)</span> -&gt;</span> {
                    <span class="hljs-regexp">//</span>方法体
        }</code></pre> 
<p><strong>说明：</strong> <br> (参数1，参数2…)表示参数列表；-&gt;表示连接符；{}内部是方法体 <br> 1、=右边的类型会根据左边的函数式接口类型自动推断； <br> 2、如果形参列表为空，只需保留()； <br> 3、如果形参只有1个，()可以省略，只需要参数的名称即可； <br> 4、如果执行语句只有1句，且无返回值，{}可以省略，若有返回值，则若想省去{}，则必须同时省略return，且执行语句也保证只有1句； <br> 5、形参列表的数据类型会自动推断； <br> 6、lambda不会生成一个单独的内部类文件； <br> 7、lambda表达式若访问了局部变量，则局部变量必须是final的，若是局部变量没有加final关键字，系统会自动添加，此后在修改该局部变量，会报错；</p> 
<p><strong>示例代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> LambdaTest {

    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> print();
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> LambdaTest2 {

    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> print(String a);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> DefalutTest {

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a =<span class="hljs-number">5</span>;
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> defaultMethod(){
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"DefalutTest defalut 方法"</span>);
    }

    <span class="hljs-keyword">int</span> sub(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b);

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> staticMethod() {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"DefalutTest static 方法"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        <span class="hljs-comment">//匿名内部类--java8之前的实现方式</span>
        DefalutTest dt = <span class="hljs-keyword">new</span> DefalutTest(){
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
                <span class="hljs-comment">// TODO Auto-generated method stub</span>
                <span class="hljs-keyword">return</span> a-b;
            }
        };

        <span class="hljs-comment">//lambda表达式--实现方式1</span>
        DefalutTest dt2 =(a,b)-&gt;{
            <span class="hljs-keyword">return</span> a-b;
        };
        System.<span class="hljs-keyword">out</span>.println(dt2.sub(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));

        <span class="hljs-comment">//lambda表达式--实现方式2，省略花括号</span>
        DefalutTest dt3 =(a,b)-&gt;a-b;
        System.<span class="hljs-keyword">out</span>.println(dt3.sub(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>));

        <span class="hljs-comment">//测试final</span>
        <span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span>;
        DefalutTest dt4 =(a,b)-&gt;a-c;
        System.<span class="hljs-keyword">out</span>.println(dt4.sub(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>));

        <span class="hljs-comment">//无参方法，并且执行语句只有1条</span>
        LambdaTest lt = ()-&gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"测试无参"</span>);
        lt.print();
        <span class="hljs-comment">//只有一个参数方法</span>
        LambdaTest2 lt1 = s-&gt; System.<span class="hljs-keyword">out</span>.println(s);
        lt1.print(<span class="hljs-string">"有一个参数"</span>);
    }
}</code></pre> 
<p>局部变量修改报错如图： <br> <img src="https://images2.imgbox.com/3f/9f/N1BUsD9S_o.png" alt="这里写图片描述" title=""> <br> 若是强行修改也无法编译通过</p> 
<p><strong><em>Lambda表达式其他特性：</em></strong></p> 
<p><strong>1、引用实例方法：</strong> <br> <strong>语法：</strong></p> 
<pre class="prettyprint"><code class=" hljs r">    &lt;函数式接口&gt;  &lt;变量名&gt; = &lt;实例&gt;::&lt;实例方法名&gt;
    //调用
    &lt;变量名&gt;.接口方法([实际参数<span class="hljs-keyword">...</span>])</code></pre> 
<p>将调用方法时的传递的实际参数，全部传递给引用的方法，执行引用的方法； <br> <strong>示例代码：</strong> <br> 如我们引用PrintStream类中的println方法。我们知道System类中有一个PrintStream的实例为out，引用该实例方法：System.out::println：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        LambdaTest2 lt1 = s-&gt; System.<span class="hljs-keyword">out</span>.println(s);
        lt1.print(<span class="hljs-string">"有一个参数"</span>);

        <span class="hljs-comment">//改写为：</span>
        LambdaTest2 lt2 = System.<span class="hljs-keyword">out</span>::println;
        lt2.print(<span class="hljs-string">"实例引用方式调用"</span>);
    }
}</code></pre> 
<p>将lt2调用时的实际参数传递给了PrintStream类中的println方法，并调用该方法</p> 
<p><strong>2、引用类方法：</strong> <br> <strong>语法：</strong></p> 
<pre class="prettyprint"><code class=" hljs r">    &lt;函数式接口&gt;  &lt;变量名&gt; = &lt;类&gt;::&lt;类方法名称&gt;
    //调用
    &lt;变量名&gt;.接口方法([实际参数<span class="hljs-keyword">...</span>])</code></pre> 
<p>将调用方法时的传递的实际参数，全部传递给引用的方法，执行引用的方法； <br> <strong>示例代码：</strong> <br> 我们可以以数组排序方式为例</p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LambdaTest3</span> {<!-- --></span>

     <span class="hljs-keyword">abstract</span> void sort(<span class="hljs-keyword">List</span>&lt;Integer&gt; <span class="hljs-keyword">list</span>,Comparator&lt;Integer&gt; c);
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {<!-- --></span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) {
        <span class="hljs-keyword">List</span>&lt;Integer&gt;  <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
        <span class="hljs-keyword">list</span>.add(<span class="hljs-number">50</span>);
        <span class="hljs-keyword">list</span>.add(<span class="hljs-number">18</span>);
        <span class="hljs-keyword">list</span>.add(<span class="hljs-number">6</span>);
        <span class="hljs-keyword">list</span>.add(<span class="hljs-number">99</span>);
        <span class="hljs-keyword">list</span>.add(<span class="hljs-number">32</span>);
        System.out.println(<span class="hljs-keyword">list</span>.toString()+<span class="hljs-string">"排序之前"</span>);
        LambdaTest3 lt3 = Collections::sort;
        lt3.sort(<span class="hljs-keyword">list</span>, (a,b) -&gt; {
            <span class="hljs-keyword">return</span> a-b;
        });
        System.out.println(<span class="hljs-keyword">list</span>.toString()+<span class="hljs-string">"排序之后"</span>);
    }
}
</code></pre> 
<p>执行结果： <br> [50, 18, 6, 99, 32]排序之前 <br> [6, 18, 32, 50, 99]排序之后</p> 
<p>再来看Comparator接口，它属于函数式接口，所以我们在Comparator入参时，也采取了lambda表达式写法。</p> 
<pre class="prettyprint"><code class=" hljs r">@FunctionalInterface
public interface Comparator&lt;<span class="hljs-literal">T</span>&gt; {
<span class="hljs-keyword">...</span>
<span class="hljs-keyword">...</span>
<span class="hljs-keyword">...</span>
}</code></pre> 
<p><strong>3、引用类的实例方法：</strong> <br> 定义、调用接口时，需要多传递一个参数，并且参数的类型与引用实例的类型一致 <br> <strong>语法：</strong></p> 
<pre class="prettyprint"><code class=" hljs r">    //定义接口
    interface &lt;函数式接口&gt;{
        &lt;返回值&gt; &lt;方法名&gt;(&lt;类&gt;&lt;类名称&gt;,[其他参数<span class="hljs-keyword">...</span>]); 
    }
    &lt;函数式接口&gt;  &lt;变量名&gt; = &lt;类&gt;::&lt;类实例方法名&gt;
    //调用
    &lt;变量名&gt;.接口方法(类的实例,[实际参数<span class="hljs-keyword">...</span>])</code></pre> 
<p>将调用方法时的传递的实际参数，从第二个参数开始（第一个参数指定的类的实例），全部传递给引用的方法，执行引用的方法； <br> <strong>示例代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> LambdaClassTest {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b){
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"LambdaClassTest类的add方法"</span>);
        <span class="hljs-keyword">return</span> a+b;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> LambdaTest4 {

    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> add(LambdaClassTest lt,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        LambdaTest4 lt4 = LambdaClassTest::add;
        LambdaClassTest lct = <span class="hljs-keyword">new</span> LambdaClassTest();
        System.<span class="hljs-keyword">out</span>.println(lt4.add(lct, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>));
    }
}</code></pre> 
<p><strong>4、引用构造器方法：</strong> <br> <strong>语法：</strong></p> 
<pre class="prettyprint"><code class=" hljs r">    &lt;函数式接口&gt;  &lt;变量名&gt; = &lt;类&gt;::&lt;new&gt;
    //调用
    &lt;变量名&gt;.接口方法([实际参数<span class="hljs-keyword">...</span>])</code></pre> 
<p>把方法的所有参数全部传递给引用的构造器，根据参数类型自动推断调用的构造器方法； <br> <strong>示例代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> LambdaTest5 {

    <span class="hljs-keyword">abstract</span> String creatString(<span class="hljs-keyword">char</span>[] c);
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        LambdaTest5 lt5 = String::<span class="hljs-keyword">new</span>;
        System.<span class="hljs-keyword">out</span>.println(lt5.creatString(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]{<!-- --><span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'a'</span>}));
    }
}</code></pre> 
<p>根据传入的参数类型，自动匹配构造函数</p> 
<h3 id="三函数式接口">三、函数式接口</h3> 
<p>如果一个接口只有一个抽象方法，则该接口称之为函数式接口，因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 <br> 函数式接口可以使用Lambda表达式，lambda表达式会被匹配到这个抽象方法上 <br> 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的</p> 
<p><strong>示例代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs cs">@FunctionalInterface
<span class="hljs-keyword">interface</span> Converter&lt;F, T&gt; {
    T convert(F <span class="hljs-keyword">from</span>);
}
Converter&lt;String, Integer&gt; converter = (<span class="hljs-keyword">from</span>) -&gt; Integer.valueOf(<span class="hljs-keyword">from</span>);
Integer converted = converter.convert(<span class="hljs-string">"123"</span>);
System.<span class="hljs-keyword">out</span>.println(converted);    <span class="hljs-comment">// 123</span></code></pre> 
<h3 id="五lambda-作用域">五、Lambda 作用域</h3> 
<p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p> 
<h3 id="六访问局部变量">六、访问局部变量</h3> 
<p>我们可以直接在lambda表达式中访问外层的局部变量，但是该局部变量必须是final的，即使没有加final关键字，之后我们无论在哪（lambda表达式内部或外部）修改该变量，均报错。</p> 
<h3 id="七访问对象字段与静态变量">七、访问对象字段与静态变量</h3> 
<p>lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的；</p> 
<p><strong>示例代码：</strong></p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda4</span> {<!-- --></span>
    static int outerStaticNum;
    int outerNum;
    <span class="hljs-reserved">void</span> testScopes() {
        Converter&lt;Integer, String&gt; <span class="hljs-function"><span class="hljs-title">stringConverter1</span> = <span class="hljs-params">(from)</span> -&gt;</span> {
            outerNum = <span class="hljs-number">23</span>;
            <span class="hljs-keyword">return</span> String.valueOf(from);
        };
        Converter&lt;Integer, String&gt; <span class="hljs-function"><span class="hljs-title">stringConverter2</span> = <span class="hljs-params">(from)</span> -&gt;</span> {
            outerStaticNum = <span class="hljs-number">72</span>;
            <span class="hljs-keyword">return</span> String.valueOf(from);
        };
    }
}</code></pre> 
<h3 id="八访问接口的默认方法">八、访问接口的默认方法</h3> 
<p><strong>Predicate接口</strong> <br> Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">    public static void main(String[] args) {
        Predicate&lt;String&gt; predicate = (s) -&gt; s<span class="hljs-preprocessor">.length</span>() &gt; <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(predicate<span class="hljs-preprocessor">.test</span>(<span class="hljs-string">"foo"</span>))<span class="hljs-comment">;              // true</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(predicate<span class="hljs-preprocessor">.negate</span>()<span class="hljs-preprocessor">.test</span>(<span class="hljs-string">"foo"</span>))<span class="hljs-comment">;     // false</span>
        Predicate&lt;Boolean&gt; nonNull = Objects::nonNull<span class="hljs-comment">;</span>
        Predicate&lt;Boolean&gt; isNull = Objects::isNull<span class="hljs-comment">;</span>
        Predicate&lt;String&gt; isEmpty = String::isEmpty<span class="hljs-comment">;</span>
        Predicate&lt;String&gt; isNotEmpty = isEmpty<span class="hljs-preprocessor">.negate</span>()<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(nonNull<span class="hljs-preprocessor">.test</span>(null))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(isNull<span class="hljs-preprocessor">.test</span>(null))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(isEmpty<span class="hljs-preprocessor">.test</span>(<span class="hljs-string">"sss"</span>))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(isNotEmpty<span class="hljs-preprocessor">.test</span>(<span class="hljs-string">""</span>))<span class="hljs-comment">;</span>
    }</code></pre> 
<p><strong>运行结果：</strong> <br> true <br> false <br> false <br> true <br> false <br> false</p> 
<p><strong>Function 接口</strong> <br> Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">        Function&lt;String, Integer&gt; toInteger = Integer::valueOf<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(toInteger<span class="hljs-preprocessor">.apply</span>(<span class="hljs-string">"123"</span>)<span class="hljs-preprocessor">.getClass</span>())<span class="hljs-comment">;</span>
        Function&lt;String, Object&gt; toInteger2 = toInteger<span class="hljs-preprocessor">.andThen</span>(String::valueOf)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(toInteger2<span class="hljs-preprocessor">.apply</span>(<span class="hljs-string">"123"</span>)<span class="hljs-preprocessor">.getClass</span>())<span class="hljs-comment">;</span></code></pre> 
<p>输出： <br> class java.lang.Integer <br> class java.lang.String</p> 
<p><strong>Supplier 接口</strong> <br> Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p> 
<pre class="prettyprint"><code class=" hljs cs">Supplier&lt;Person&gt; personSupplier = Person::<span class="hljs-keyword">new</span>;
personSupplier.<span class="hljs-keyword">get</span>();   <span class="hljs-comment">// new Person</span></code></pre> 
<p><strong>Consumer 接口</strong></p> 
<p>Consumer 接口表示执行在单个参数上的操作。接口只有一个参数，且无返回值</p> 
<pre class="prettyprint"><code class=" hljs avrasm">        Supplier&lt;LambdaClassTest&gt; personSupplier = LambdaClassTest::new<span class="hljs-comment">;</span>
        Consumer&lt;LambdaClassTest&gt; greeter = (lt) -&gt; System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"Hello, "</span> + lt<span class="hljs-preprocessor">.getTest</span>())<span class="hljs-comment">;</span>
        greeter<span class="hljs-preprocessor">.accept</span>(personSupplier<span class="hljs-preprocessor">.get</span>())<span class="hljs-comment">;</span></code></pre> 
<p><strong>Comparator 接口</strong></p> 
<p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1<span class="hljs-preprocessor">.firstName</span><span class="hljs-preprocessor">.compareTo</span>(p2<span class="hljs-preprocessor">.firstName</span>)<span class="hljs-comment">;</span>
Person p1 = new Person(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)<span class="hljs-comment">;</span>
Person p2 = new Person(<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Wonderland"</span>)<span class="hljs-comment">;</span>
comparator<span class="hljs-preprocessor">.compare</span>(p1, p2)<span class="hljs-comment">;             // &gt; 0</span>
comparator<span class="hljs-preprocessor">.reversed</span>()<span class="hljs-preprocessor">.compare</span>(p1, p2)<span class="hljs-comment">;  // &lt; 0</span></code></pre> 
<p><strong>Optional 接口</strong></p> 
<p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么： <br> Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p> 
<pre class="prettyprint"><code class=" hljs coffeescript">Optional&lt;String&gt; optional = Optional.<span class="hljs-keyword">of</span>(<span class="hljs-string">"bam"</span>);
optional.isPresent();           <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span>
optional.get();                 <span class="hljs-regexp">//</span> <span class="hljs-string">"bam"</span>
optional.orElse(<span class="hljs-string">"fallback"</span>);    <span class="hljs-regexp">//</span> <span class="hljs-string">"bam"</span>
optional.ifPresent<span class="hljs-function"><span class="hljs-params">((s) -&gt; System.out.println(s.charAt(<span class="hljs-number">0</span>)))</span>;     // "<span class="hljs-title">b</span>"</span></code></pre> 
<p><strong>Stream 接口 重要！！！</strong></p> 
<p><strong>创建stream–通过of方法</strong></p> 
<pre class="prettyprint"><code class=" hljs vbnet">Stream&lt;<span class="hljs-built_in">Integer</span>&gt; integerStream = Stream.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
Stream&lt;<span class="hljs-built_in">String</span>&gt; stringStream = Stream.<span class="hljs-keyword">of</span>(<span class="hljs-string">"taobao"</span>);</code></pre> 
<p><strong>创建stream–通过generator方法</strong> <br> 生成一个无限长度的Stream，其元素的生成是通过给定的Supplier（这个接口可以看成一个对象的工厂，每次调用返回一个给定类型的对象）</p> 
<pre class="prettyprint"><code class=" hljs coffeescript">Stream.generate(<span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() {

    <span class="hljs-property">@Override</span>

    public Double get() {

        <span class="hljs-keyword">return</span> Math.random();

    }

});

Stream.generate<span class="hljs-function"><span class="hljs-params">(() -&gt; Math.random())</span>;

<span class="hljs-title">Stream</span>.<span class="hljs-title">generate</span><span class="hljs-params">(Math::random)</span>;</span></code></pre> 
<p>三条语句的作用都是一样的，只是使用了lambda表达式和方法引用的语法来简化代码。每条语句其实都是生成一个无限长度的Stream，其中值是随机的。这个无限长度Stream是懒加载，一般这种无限长度的Stream都会配合Stream的limit()方法来用。</p> 
<p><strong>创建stream–通过iterate方法</strong> <br> 也是生成无限长度的Stream，和generator不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环 <br> Stream.iterate(1, item -&gt; item + 1).limit(10).forEach(System.out::println); <br> 这段代码就是先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。千万记住使用limit方法，不然会无限打印下去。</p> 
<p><strong>通过Collection子类获取Stream</strong></p> 
<pre class="prettyprint"><code class=" hljs php">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; {<!-- --></span>

    <span class="hljs-comment">//其他方法省略</span>

    <span class="hljs-keyword">default</span> Stream&lt;E&gt; stream() {

        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">false</span>);

    }

}</code></pre> 
<p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p> 
<p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。 <br> Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p> 
<p>下面的例子展示了是如何通过并行Stream来提升性能： <br> 首先我们创建一个没有重复元素的大表：</p> 
<pre class="prettyprint"><code class=" hljs glsl"><span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">1000000</span>;
List&lt;String&gt; values = new ArrayList&lt;&gt;(<span class="hljs-built_in">max</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">max</span>; i++) {
    UUID uuid = UUID.randomUUID();
    values.add(uuid.toString());
}</code></pre> 
<p>然后我们计算一下排序这个Stream要耗时多久， <br> <strong>串行排序：</strong></p> 
<pre class="prettyprint"><code class=" hljs avrasm">long t0 = System<span class="hljs-preprocessor">.nanoTime</span>()<span class="hljs-comment">;</span>
long count = values<span class="hljs-preprocessor">.stream</span>()<span class="hljs-preprocessor">.sorted</span>()<span class="hljs-preprocessor">.count</span>()<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(count)<span class="hljs-comment">;</span>
long t1 = System<span class="hljs-preprocessor">.nanoTime</span>()<span class="hljs-comment">;</span>
long millis = TimeUnit<span class="hljs-preprocessor">.NANOSECONDS</span><span class="hljs-preprocessor">.toMillis</span>(t1 - t0)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(String<span class="hljs-preprocessor">.format</span>(<span class="hljs-string">"sequential sort took: %d ms"</span>, millis))<span class="hljs-comment">;</span></code></pre> 
<p>// 串行耗时: 899 ms <br> <strong>并行排序：</strong></p> 
<pre class="prettyprint"><code class=" hljs avrasm">long t0 = System<span class="hljs-preprocessor">.nanoTime</span>()<span class="hljs-comment">;</span>
long count = values<span class="hljs-preprocessor">.parallelStream</span>()<span class="hljs-preprocessor">.sorted</span>()<span class="hljs-preprocessor">.count</span>()<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(count)<span class="hljs-comment">;</span>
long t1 = System<span class="hljs-preprocessor">.nanoTime</span>()<span class="hljs-comment">;</span>
long millis = TimeUnit<span class="hljs-preprocessor">.NANOSECONDS</span><span class="hljs-preprocessor">.toMillis</span>(t1 - t0)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(String<span class="hljs-preprocessor">.format</span>(<span class="hljs-string">"parallel sort took: %d ms"</span>, millis))<span class="hljs-comment">;</span></code></pre> 
<p>// 并行排序耗时: 472 ms <br> 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是<strong>将stream()改为parallelStream()</strong>；</p> 
<p><strong>stream的其他应用：</strong> <br> <strong>1、count()、max()、min()</strong>方法</p> 
<pre class="prettyprint"><code class=" hljs avrasm">import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.ArrayList</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.List</span><span class="hljs-comment">;</span>

public class Main {

    public static void main(String[] args) {
        List&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;()<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">14</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">5</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">43</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">89</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">64</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">112</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">55</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">55</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">58</span>)<span class="hljs-comment">;</span>
        //list长度
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(collection<span class="hljs-preprocessor">.parallelStream</span>()<span class="hljs-preprocessor">.count</span>())<span class="hljs-comment">;</span>

        //求最大值,返回Option,通过Option<span class="hljs-preprocessor">.get</span>()获取值
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(collection<span class="hljs-preprocessor">.parallelStream</span>()<span class="hljs-preprocessor">.max</span>((a,b)-&gt;{return a-b<span class="hljs-comment">;}).get());</span>

        //求最小值,返回Option,通过Option<span class="hljs-preprocessor">.get</span>()获取值
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(collection<span class="hljs-preprocessor">.parallelStream</span>()<span class="hljs-preprocessor">.min</span>((a,b)-&gt;{return a-b<span class="hljs-comment">;}).get());</span>

    }
}</code></pre> 
<p><strong>2、Filter 过滤方法</strong> <br> 过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.ArrayList</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.List</span><span class="hljs-comment">;</span>

public class Main {

    public static void main(String[] args) {
        List&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;()<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">14</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">5</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">43</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">89</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">64</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">112</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">55</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">55</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">58</span>)<span class="hljs-comment">;</span>
        Long count =collection<span class="hljs-preprocessor">.stream</span>()<span class="hljs-preprocessor">.filter</span>(num -&gt; num!=null).
                filter(num -&gt; num<span class="hljs-preprocessor">.intValue</span>()&gt;<span class="hljs-number">50</span>)<span class="hljs-preprocessor">.count</span>()<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(count)<span class="hljs-comment">;</span>
    }
}</code></pre> 
<p><strong>3、distinct方法</strong> <br> 去除重复</p> 
<pre class="prettyprint"><code class=" hljs avrasm">import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.ArrayList</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.List</span><span class="hljs-comment">;</span>

public class Main {

    public static void main(String[] args) {
        List&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;()<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">14</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">5</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">43</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">89</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">64</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">112</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">55</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">55</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">58</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.stream</span>()<span class="hljs-preprocessor">.distinct</span>()<span class="hljs-preprocessor">.forEach</span>(System<span class="hljs-preprocessor">.out</span>::println)<span class="hljs-comment">;;</span>
    }
}</code></pre> 
<p><strong>4、Sort 排序</strong> <br> 排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">stringCollection
    <span class="hljs-preprocessor">.stream</span>()
    <span class="hljs-preprocessor">.sorted</span>()
    <span class="hljs-preprocessor">.filter</span>((s) -&gt; s<span class="hljs-preprocessor">.startsWith</span>(<span class="hljs-string">"a"</span>))
    <span class="hljs-preprocessor">.forEach</span>(System<span class="hljs-preprocessor">.out</span>::println)<span class="hljs-comment">;</span>
// <span class="hljs-string">"aaa1"</span>, <span class="hljs-string">"aaa2"</span></code></pre> 
<p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p> 
<pre class="prettyprint"><code class=" hljs cs">System.<span class="hljs-keyword">out</span>.println(stringCollection);
<span class="hljs-comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></code></pre> 
<p><strong>5、Map 映射</strong></p> 
<p>对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和mapToDouble。这三个方法也比较好理解，比如mapToInt就是把原始Stream转换成一个新的Stream，这个新生成的Stream中的元素都是int类型。之所以会有这样三个变种方法，可以免除自动装箱/拆箱的额外消耗；</p> 
<pre class="prettyprint"><code class=" hljs avrasm">import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.ArrayList</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.List</span><span class="hljs-comment">;</span>

public class Main {

    public static void main(String[] args) {
        List&lt;String&gt; collection = new ArrayList&lt;String&gt;()<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"14"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"5"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"43"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"89"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"64"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"112"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"55"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"55"</span>)<span class="hljs-comment">;</span>
        collection<span class="hljs-preprocessor">.add</span>(<span class="hljs-string">"58"</span>)<span class="hljs-comment">;</span>
        //将String转化为Integer类型
        collection<span class="hljs-preprocessor">.stream</span>()<span class="hljs-preprocessor">.mapToInt</span>(Integer::valueOf)<span class="hljs-preprocessor">.forEach</span>(System<span class="hljs-preprocessor">.out</span>::println)<span class="hljs-comment">;</span>
        //或
        collection<span class="hljs-preprocessor">.stream</span>()<span class="hljs-preprocessor">.mapToInt</span>(a-&gt;Integer<span class="hljs-preprocessor">.parseInt</span>(a))<span class="hljs-preprocessor">.forEach</span>(System<span class="hljs-preprocessor">.out</span>::println)<span class="hljs-comment">;</span>
    }
}

也可以这样用：
List&lt;Integer&gt; nums = Lists<span class="hljs-preprocessor">.newArrayList</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,null,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,null,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(“sum is:”+nums<span class="hljs-preprocessor">.stream</span>()<span class="hljs-preprocessor">.filter</span>(num -&gt; num != null)<span class="hljs-preprocessor">.distinct</span>()<span class="hljs-preprocessor">.mapToInt</span>(num -&gt; num * <span class="hljs-number">2</span>).
            peek(System<span class="hljs-preprocessor">.out</span>::println)<span class="hljs-preprocessor">.skip</span>(<span class="hljs-number">2</span>)<span class="hljs-preprocessor">.limit</span>(<span class="hljs-number">4</span>)<span class="hljs-preprocessor">.sum</span>())<span class="hljs-comment">;</span></code></pre> 
<p><strong>7、limit：</strong> <br> 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素；</p> 
<p><strong>8、skip：</strong> <br> 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream；</p> 
<p><strong>9、Match 匹配</strong> <br> Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p> 
<pre class="prettyprint"><code class=" hljs coffeescript">boolean anyStartsWithA = 
    stringCollection
        .stream()
        .anyMatch<span class="hljs-function"><span class="hljs-params">((s) -&gt; s.startsWith(<span class="hljs-string">"a"</span>))</span>;
<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(anyStartsWithA)</span>;      // <span class="hljs-title">true</span>
<span class="hljs-title">boolean</span> <span class="hljs-title">allStartsWithA</span> = 
    <span class="hljs-title">stringCollection</span>
        .<span class="hljs-title">stream</span><span class="hljs-params">()</span>
        .<span class="hljs-title">allMatch</span><span class="hljs-params">((s) -&gt; s.startsWith(<span class="hljs-string">"a"</span>))</span>;
<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(allStartsWithA)</span>;      // <span class="hljs-title">false</span>
<span class="hljs-title">boolean</span> <span class="hljs-title">noneStartsWithZ</span> = 
    <span class="hljs-title">stringCollection</span>
        .<span class="hljs-title">stream</span><span class="hljs-params">()</span>
        .<span class="hljs-title">noneMatch</span><span class="hljs-params">((s) -&gt; s.startsWith(<span class="hljs-string">"z"</span>))</span>;
<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(noneStartsWithZ)</span>;      // <span class="hljs-title">true</span></span></code></pre> 
<p><strong>10、Count 计数</strong></p> 
<p>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p> 
<pre class="prettyprint"><code class=" hljs coffeescript">long startsWithB = 
    stringCollection
        .stream()
        .filter<span class="hljs-function"><span class="hljs-params">((s) -&gt; s.startsWith(<span class="hljs-string">"b"</span>))</span>
        .<span class="hljs-title">count</span><span class="hljs-params">()</span>;
<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(startsWithB)</span>;    // 3</span></code></pre> 
<p><strong>11、Reduce 规约</strong> <br> 这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">Optional&lt;String&gt; reduced =
    stringCollection
        <span class="hljs-preprocessor">.stream</span>()
        <span class="hljs-preprocessor">.sorted</span>()
        <span class="hljs-preprocessor">.reduce</span>((s1, s2) -&gt; s1 + <span class="hljs-string">"#"</span> + s2)<span class="hljs-comment">;</span>
reduced<span class="hljs-preprocessor">.ifPresent</span>(System<span class="hljs-preprocessor">.out</span>::println)<span class="hljs-comment">;</span>
// <span class="hljs-string">"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></code></pre> 
<p><strong>Map</strong> <br> 前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-built_in">Map</span><span class="hljs-subst">&lt;</span><span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">String</span><span class="hljs-subst">&gt;</span> <span class="hljs-built_in">map</span> <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> HashMap<span class="hljs-subst">&lt;&gt;</span>();
for (int i <span class="hljs-subst">=</span> <span class="hljs-number">0</span>; i <span class="hljs-subst">&lt;</span> <span class="hljs-number">10</span>; i<span class="hljs-subst">++</span>) {
    <span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>putIfAbsent(i, <span class="hljs-string">"val"</span> <span class="hljs-subst">+</span> i);
}
<span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>forEach((id, val) <span class="hljs-subst">-&gt; </span>System<span class="hljs-built_in">.</span>out<span class="hljs-built_in">.</span>println(val));</code></pre> 
<p>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。 <br> 下面的例子展示了map上的其他有用的函数：</p> 
<pre class="prettyprint"><code class=" hljs coffeescript">map.computeIfPresent<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>, (num, val) -&gt; val + num)</span>;
<span class="hljs-title">map</span>.<span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;             // <span class="hljs-title">val33</span>
<span class="hljs-title">map</span>.<span class="hljs-title">computeIfPresent</span><span class="hljs-params">(<span class="hljs-number">9</span>, (num, val) -&gt; <span class="hljs-literal">null</span>)</span>;
<span class="hljs-title">map</span>.<span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span>;     // <span class="hljs-title">false</span>
<span class="hljs-title">map</span>.<span class="hljs-title">computeIfAbsent</span><span class="hljs-params">(<span class="hljs-number">23</span>, num -&gt; <span class="hljs-string">"val"</span> + num)</span>;
<span class="hljs-title">map</span>.<span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-number">23</span>)</span>;    // <span class="hljs-title">true</span>
<span class="hljs-title">map</span>.<span class="hljs-title">computeIfAbsent</span><span class="hljs-params">(<span class="hljs-number">3</span>, num -&gt; <span class="hljs-string">"bam"</span>)</span>;
<span class="hljs-title">map</span>.<span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;             // <span class="hljs-title">val33</span></span></code></pre> 
<p>接下来展示如何在Map里删除一个键值全都匹配的项：</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>remove(<span class="hljs-number">3</span>, <span class="hljs-string">"val3"</span>);
<span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>get(<span class="hljs-number">3</span>);             <span class="hljs-comment">// val33</span>
<span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>remove(<span class="hljs-number">3</span>, <span class="hljs-string">"val33"</span>);
<span class="hljs-built_in">map</span><span class="hljs-built_in">.</span>get(<span class="hljs-number">3</span>);             <span class="hljs-comment">// null</span></code></pre> 
<p>另外一个有用的方法：</p> 
<pre class="prettyprint"><code class=" hljs ruby">map.getOrDefault(<span class="hljs-number">42</span>, <span class="hljs-string">"not found"</span>);  <span class="hljs-regexp">//</span> <span class="hljs-keyword">not</span> found</code></pre> 
<p>对Map的元素做合并也变得很容易了：</p> 
<pre class="prettyprint"><code class=" hljs coffeescript">map.merge<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">9</span>, <span class="hljs-string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue))</span>;
<span class="hljs-title">map</span>.<span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span>;             // <span class="hljs-title">val9</span>
<span class="hljs-title">map</span>.<span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-number">9</span>, <span class="hljs-string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue))</span>;
<span class="hljs-title">map</span>.<span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span>;             // <span class="hljs-title">val9concat</span></span></code></pre> 
<p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p> 
<p><strong>steam在实际项目中使用的代码片段：</strong></p> 
<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、有list集合生成以productId为key值得map集合
Map&lt;String, List&lt;CartManager&gt;&gt; cartManagerGroup =
        carts.stream().collect(
                Collectors.groupingBy(<span class="hljs-attribute">CartManager</span>::getProductId)
        );
<span class="hljs-regexp">//</span><span class="hljs-number">2</span>、取得购物车中数量之和
IntStream  <span class="hljs-keyword">is</span> = list.stream<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">mapToInt</span><span class="hljs-params">((CartManager c)-&gt;c.getQuantity())</span>; 
<span class="hljs-title">is</span>.<span class="hljs-title">sum</span><span class="hljs-params">()</span>;//数量之和

//3、所有订单中商品数量*订单金额求和
<span class="hljs-title">orderDetailsNew</span>.<span class="hljs-title">parallelStream</span><span class="hljs-params">()</span>
                            .<span class="hljs-title">mapToDouble</span><span class="hljs-params">(orderDetailMid -&gt; orderDetailMid.getQuantity()*orderDetailMid.getFinalPrice())</span>.<span class="hljs-title">sum</span><span class="hljs-params">()</span>

//4、过滤出指定类型的订单，并生成新的集合
<span class="hljs-title">orderDetails</span>.<span class="hljs-title">stream</span><span class="hljs-params">()</span>.
    <span class="hljs-title">filter</span><span class="hljs-params">(orderDetail -&gt;    StringUtil.isEmpty(orderDetail.getPromotionsType())|| !orderDetail.getPromotionsType().equals(PromotionTypeEnum.ORDERGIFTPROMOTION.getType()))</span>.<span class="hljs-title">collect</span><span class="hljs-params">(Collectors.toList())</span>;

//5、过滤购物车未被选中商品并生成新的<span class="hljs-title">list</span>
<span class="hljs-title">carts</span>.<span class="hljs-title">stream</span><span class="hljs-params">()</span>.<span class="hljs-title">filter</span><span class="hljs-params">(cart -&gt; cart.getSelectFlag()==<span class="hljs-number">1</span>)</span>.<span class="hljs-title">collect</span><span class="hljs-params">(Collectors.toList())</span>;

//6、将<span class="hljs-title">list</span>以商品促销委<span class="hljs-title">key</span>转化为<span class="hljs-title">map</span>
<span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>,<span class="hljs-title">List</span>&lt;<span class="hljs-title">PromotionsGiftProduct</span>&gt;&gt; <span class="hljs-title">map</span> = 
                <span class="hljs-title">promotionsGiftProducts</span>.<span class="hljs-title">stream</span><span class="hljs-params">()</span>.<span class="hljs-title">collect</span><span class="hljs-params">(                    Collectors.groupingBy(PromotionsGiftProduct::getPromotionId))</span>;

//7、从<span class="hljs-title">list</span>&lt;<span class="hljs-title">Cart</span>&gt;中分离出只存储<span class="hljs-title">productId</span>的列表<span class="hljs-title">list</span>&lt;<span class="hljs-title">String</span>&gt;
<span class="hljs-title">List</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">productIds</span> = <span class="hljs-title">needUpdate</span>.<span class="hljs-title">parallelStream</span><span class="hljs-params">()</span>
                        .<span class="hljs-title">map</span><span class="hljs-params">(CartManager::getProductId)</span>
                        .<span class="hljs-title">collect</span><span class="hljs-params">(Collectors.toList())</span>;</span></code></pre> 
<h3 id="九date-api">九、Date API</h3> 
<p>Java 8 在包java.time下包含了一组全新的时间日期API。 <br> <strong>Clock 时钟</strong> <br> Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p> 
<pre class="prettyprint"><code class=" hljs mathematica"><span class="hljs-keyword">Clock</span> clock = <span class="hljs-keyword">Clock</span>.systemDefaultZone();
long millis = clock.millis();
Instant instant = clock.instant();
<span class="hljs-keyword">Date</span> legacyDate = <span class="hljs-keyword">Date</span>.from(instant);   // legacy java.util.<span class="hljs-keyword">Date</span></code></pre> 
<p><strong>Timezones 时区</strong></p> 
<pre class="prettyprint"><code class=" hljs avrasm">System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ZoneId<span class="hljs-preprocessor">.getAvailableZoneIds</span>())<span class="hljs-comment">;</span>
// prints all available timezone ids
ZoneId zone1 = ZoneId<span class="hljs-preprocessor">.of</span>(<span class="hljs-string">"Europe/Berlin"</span>)<span class="hljs-comment">;</span>
ZoneId zone2 = ZoneId<span class="hljs-preprocessor">.of</span>(<span class="hljs-string">"Brazil/East"</span>)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(zone1<span class="hljs-preprocessor">.getRules</span>())<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(zone2<span class="hljs-preprocessor">.getRules</span>())<span class="hljs-comment">;</span>
// ZoneRules[currentStandardOffset=+<span class="hljs-number">01</span>:<span class="hljs-number">00</span>]
// ZoneRules[currentStandardOffset=-<span class="hljs-number">03</span>:<span class="hljs-number">00</span>]</code></pre> 
<p><strong>LocalTime 本地时间</strong> <br> LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">LocalTime now1 = LocalTime<span class="hljs-preprocessor">.now</span>(zone1)<span class="hljs-comment">;</span>
LocalTime now2 = LocalTime<span class="hljs-preprocessor">.now</span>(zone2)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(now1<span class="hljs-preprocessor">.isBefore</span>(now2))<span class="hljs-comment">;  // false</span>
long hoursBetween = ChronoUnit<span class="hljs-preprocessor">.HOURS</span><span class="hljs-preprocessor">.between</span>(now1, now2)<span class="hljs-comment">;</span>
long minutesBetween = ChronoUnit<span class="hljs-preprocessor">.MINUTES</span><span class="hljs-preprocessor">.between</span>(now1, now2)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(hoursBetween)<span class="hljs-comment">;       // -3</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(minutesBetween)<span class="hljs-comment">;     // -239</span></code></pre> 
<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">LocalTime late = LocalTime<span class="hljs-preprocessor">.of</span>(<span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(late)<span class="hljs-comment">;       // 23:59:59</span>
DateTimeFormatter germanFormatter =
    DateTimeFormatter
        <span class="hljs-preprocessor">.ofLocalizedTime</span>(FormatStyle<span class="hljs-preprocessor">.SHORT</span>)
        <span class="hljs-preprocessor">.withLocale</span>(Locale<span class="hljs-preprocessor">.GERMAN</span>)<span class="hljs-comment">;</span>
LocalTime leetTime = LocalTime<span class="hljs-preprocessor">.parse</span>(<span class="hljs-string">"13:37"</span>, germanFormatter)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(leetTime)<span class="hljs-comment">;   // 13:37</span></code></pre> 
<p><strong>LocalDate 本地日期</strong> <br> LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">LocalDate today = LocalDate<span class="hljs-preprocessor">.now</span>()<span class="hljs-comment">;</span>
LocalDate tomorrow = today<span class="hljs-preprocessor">.plus</span>(<span class="hljs-number">1</span>, ChronoUnit<span class="hljs-preprocessor">.DAYS</span>)<span class="hljs-comment">;</span>
LocalDate yesterday = tomorrow<span class="hljs-preprocessor">.minusDays</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
LocalDate independenceDay = LocalDate<span class="hljs-preprocessor">.of</span>(<span class="hljs-number">2014</span>, Month<span class="hljs-preprocessor">.JULY</span>, <span class="hljs-number">4</span>)<span class="hljs-comment">;</span>
DayOfWeek dayOfWeek = independenceDay<span class="hljs-preprocessor">.getDayOfWeek</span>()<span class="hljs-comment">;</span>

System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(dayOfWeek)<span class="hljs-comment">;    // FRIDAY</span></code></pre> 
<p>从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">DateTimeFormatter germanFormatter =
    DateTimeFormatter
        <span class="hljs-preprocessor">.ofLocalizedDate</span>(FormatStyle<span class="hljs-preprocessor">.MEDIUM</span>)
        <span class="hljs-preprocessor">.withLocale</span>(Locale<span class="hljs-preprocessor">.GERMAN</span>)<span class="hljs-comment">;</span>
LocalDate xmas = LocalDate<span class="hljs-preprocessor">.parse</span>(<span class="hljs-string">"24.12.2014"</span>, germanFormatter)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(xmas)<span class="hljs-comment">;   // 2014-12-24</span></code></pre> 
<p>LocalDateTime 本地日期时间 <br> LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">LocalDateTime sylvester = LocalDateTime<span class="hljs-preprocessor">.of</span>(<span class="hljs-number">2014</span>, Month<span class="hljs-preprocessor">.DECEMBER</span>, <span class="hljs-number">31</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>)<span class="hljs-comment">;</span>
DayOfWeek dayOfWeek = sylvester<span class="hljs-preprocessor">.getDayOfWeek</span>()<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(dayOfWeek)<span class="hljs-comment">;      // WEDNESDAY</span>
Month month = sylvester<span class="hljs-preprocessor">.getMonth</span>()<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(month)<span class="hljs-comment">;          // DECEMBER</span>
long minuteOfDay = sylvester<span class="hljs-preprocessor">.getLong</span>(ChronoField<span class="hljs-preprocessor">.MINUTE</span>_OF_DAY)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(minuteOfDay)<span class="hljs-comment">;    // 1439</span></code></pre> 
<p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">Instant instant = sylvester
        <span class="hljs-preprocessor">.atZone</span>(ZoneId<span class="hljs-preprocessor">.systemDefault</span>())
        <span class="hljs-preprocessor">.toInstant</span>()<span class="hljs-comment">;</span>
Date legacyDate = Date<span class="hljs-preprocessor">.from</span>(instant)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(legacyDate)<span class="hljs-comment">;     // Wed Dec 31 23:59:59 CET 2014</span></code></pre> 
<p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">DateTimeFormatter formatter =
    DateTimeFormatter
        <span class="hljs-preprocessor">.ofPattern</span>(<span class="hljs-string">"MMM dd, yyyy - HH:mm"</span>)<span class="hljs-comment">;</span>
LocalDateTime parsed = LocalDateTime<span class="hljs-preprocessor">.parse</span>(<span class="hljs-string">"Nov 03, 2014 - 07:13"</span>, formatter)<span class="hljs-comment">;</span>
String string = formatter<span class="hljs-preprocessor">.format</span>(parsed)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(string)<span class="hljs-comment">;     // Nov 03, 2014 - 07:13</span></code></pre> 
<p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 <br> 关于时间日期格式的详细信息： <br> <a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" rel="nofollow">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a></p> 
<h3 id="十annotation-注解">十、Annotation 注解</h3> 
<p>在Java 8中支持多重注解了</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8003b6d19019df72263097f3ff31c32c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">StrictMode.setThreadPolicy  StrictMode.setVmPolicy</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f8609c00a6da05d1b3886af91353ae1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GitHub Gist 指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>