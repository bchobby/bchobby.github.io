<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shell脚本基础之详解脚本数据的输入与输出 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shell脚本基础之详解脚本数据的输入与输出" />
<meta property="og:description" content="数据的展示 理解输入与输出标准文件描述符STDIN（标准输入）STDOUT（标准输出）STDERR（标准错误） 重定向错误只重定向错误重定向错误和数据 在shell脚本中重定向输出临时重定向永久重定向 在shell脚本中重定向输入创建自己的重定向创建输出文件描述符重定向文件描述符创建输入文件描述符创建读写文件描述符关闭文件描述符 列出打开的文件描述符阻止命令输出创建临时文件创建本地临时文件在/tmp 目录创建临时文件创建临时目录 记录消息 截至到现在，我们所写的shell脚本都是通过将数据打印在屏幕上或将数据重定向到文件中来显示信息的，下面我们会学习如何将脚本的输出重定向到Linux系统的其它位置，并深入了解重定向 理解输入与输出 目前我们已经学习到两种显示脚本输出的方法： 在显示器屏幕上显示输出将输出重定向到文件，查看文件 上述两种方法，要么是将数据全部显示到屏幕上，要么是什么都不显示。如果可以将一部分数据展示到显示器上，一部分保存到文件中，这个方法看起来是个更优解，对此我们需要了解Linux如何处理输入输出，才能够帮助我们将脚本输出放到正确位置 标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符（0、1、2），如下表： 文件描述符英文缩写描述0STDIN标准输入1STDOUT标准输出2STDERR标准错误 这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置，如下介绍： STDIN（标准输入） STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符，它会读取文件并提取数据，就好像是从键盘上键入的许多bash命令能接受STDIN的输入，尤其是没有在命令行上指定文件的话。如下是使用cat命令处理STDIN输入的数据的例子：
当在命令行上只输入cat命令时，它会从STDIN接受输入（键盘）。键盘输入一行，cat命令就会显示出一行，但我们也可以通过STDIN重定向符号强制cat命令接受来自另一个STDIN文件的输入，如下：
如上cat命令会用cat_txt文件中的行作为输入。我们还可以使用这种技术将数据输入到任何能从STDIN接受数据的shell命令中 STDOUT（标准输出） STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器
默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，如下，我们可以用输出重定向来改变标准输出：
通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。我们也可以将数据追加到某个文件。这可以用&gt;&gt;符号来完成，如下：
who命令生成的输出会被追加到ls_txt文件中已有数据的后面，但是如果你对脚本使用了标准输出重定向，你还可能遇到一个特殊的问题，如下：
当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示new_ls文件的内容时并没有任何错误。new_ls文件创建成功了，只是没有内容而已
shell对于错误消息的处理是跟普通输出分开的。如果我们创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些错误信息也是不会出现在日志文件中的，需要换种方法来处理
STDERR（标准错误） shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中但是从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，我们常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候，如下介绍 重定向错误 我们已经学习了如何用重定向符号来重定向STDOUT数据。重定向STDERR数据也没太大差别，只要在使用重定向符号时定义STDERR文件描述符即可。有如下几种办法实现 只重定向错误 STDERR文件描述符被设成2。选择只重定向错误消息时，只需要将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作，如下： ls -l badTXT 2&gt; err.txt 如上，错误消息不会出现在屏幕上了。只需要注意：文件描述符值紧贴在重定向符号前，二者之间没有空白符，该命令生成的任何错误消息都会保存在输出文件中。用这种方法，shell会只重定向错误消息，而非普通数据。这里是另一个将STDOUT和STDERR消息混杂在同一输出中的例子，如下：
ls命令的正常STDOUT输出仍然会发送到默认的STDOUT文件描述符，也就是显示器。由于该命令将文件描述符2的输出（STDERR）重定向到了一个输出文件，shell会将生成的所有错误消息直接发送到指定的重定向文件中 重定向错误和数据 如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件，如下： ls -l err.txt new_ls badTXT 2&gt; err01.txt 1&gt; succ01.txt shell利用1&gt;符号将ls命令的正常输出重定向到了succ01.txt文件，而这些输出本该是进入STDOUT的。所有本该输出到STDERR的错误消息通过2&gt;符号被重定向到了err01.txt文件使用这种方法可以将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松方便地查看错误信息也可以将STDERR和STDOUT的输出重定向到同一个输出文件。为此bash shell提供了特殊的重定向符号&amp;&gt;，如下： ls -l err.txt new_ls badTXT &amp;&gt; normal.txt 当使用&amp;&gt;符时，命令生成的所有输出都会发送到同一文件，包括数据输出和错误。我们注意到其中错误消息出现的位置和预想中的不一样。badTXT文件（列出的最后一个文件）的这条错误消息出现在输出文件中的第一行。这是为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级。这样就可以集中查看错误信息 在shell脚本中重定向输出 可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出： 临时重定向行输出永久重定向脚本中的所有命令 临时重定向 如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加&amp;，如下： echo &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4694db939a374f6e2d47ecbcff8ace01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-17T16:02:05+08:00" />
<meta property="article:modified_time" content="2023-04-17T16:02:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shell脚本基础之详解脚本数据的输入与输出</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>数据的展示</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">理解输入与输出</a></li><li><ul><li><a href="#_7" rel="nofollow">标准文件描述符</a></li><li><ul><li><a href="#STDIN_16" rel="nofollow">STDIN（标准输入）</a></li><li><a href="#STDOUT_24" rel="nofollow">STDOUT（标准输出）</a></li><li><a href="#STDERR_36" rel="nofollow">STDERR（标准错误）</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_40" rel="nofollow">重定向错误</a></li><li><ul><li><a href="#_42" rel="nofollow">只重定向错误</a></li><li><a href="#_52" rel="nofollow">重定向错误和数据</a></li></ul> 
   </li><li><a href="#shell_70" rel="nofollow">在shell脚本中重定向输出</a></li><li><ul><li><a href="#_74" rel="nofollow">临时重定向</a></li><li><a href="#_95" rel="nofollow">永久重定向</a></li></ul> 
   </li><li><a href="#shell_129" rel="nofollow">在shell脚本中重定向输入</a></li><li><a href="#_155" rel="nofollow">创建自己的重定向</a></li><li><ul><li><a href="#_157" rel="nofollow">创建输出文件描述符</a></li><li><a href="#_181" rel="nofollow">重定向文件描述符</a></li><li><a href="#_199" rel="nofollow">创建输入文件描述符</a></li><li><a href="#_226" rel="nofollow">创建读写文件描述符</a></li><li><a href="#_243" rel="nofollow">关闭文件描述符</a></li></ul> 
   </li><li><a href="#_277" rel="nofollow">列出打开的文件描述符</a></li><li><a href="#_320" rel="nofollow">阻止命令输出</a></li><li><a href="#_336" rel="nofollow">创建临时文件</a></li><li><ul><li><a href="#_339" rel="nofollow">创建本地临时文件</a></li><li><a href="#tmp__372" rel="nofollow">在/tmp 目录创建临时文件</a></li><li><a href="#_402" rel="nofollow">创建临时目录</a></li></ul> 
   </li><li><a href="#_424" rel="nofollow">记录消息</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<ul><li>截至到现在，我们所写的shell脚本都是通过将数据打印在屏幕上或将数据重定向到文件中来显示信息的，下面我们会学习如何将脚本的输出重定向到Linux系统的其它位置，并深入了解重定向</li></ul> 
<h3><a id="_2"></a>理解输入与输出</h3> 
<ul><li>目前我们已经学习到两种显示脚本输出的方法： 
  <ul><li><strong>在显示器屏幕上显示输出</strong></li><li><strong>将输出重定向到文件，查看文件</strong></li></ul> </li><li>上述两种方法，要么是将数据全部显示到屏幕上，要么是什么都不显示。如果可以将一部分数据展示到显示器上，一部分保存到文件中，这个方法看起来是个更优解，对此我们需要了解Linux如何处理输入输出，才能够帮助我们将脚本输出放到正确位置</li></ul> 
<h4><a id="_7"></a>标准文件描述符</h4> 
<ul><li>Linux系统将每个对象当作文件处理。这包括<strong>输入和输出进程</strong>。Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符（0、1、2），如下表：</li></ul> 
<table><thead><tr><th>文件描述符</th><th>英文缩写</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>STDIN</td><td>标准输入</td></tr><tr><td>1</td><td>STDOUT</td><td>标准输出</td></tr><tr><td>2</td><td>STDERR</td><td>标准错误</td></tr></tbody></table> 
<ul><li>这三个特殊文件描述符会处理<strong>脚本的输入和输出</strong>。shell用它们将shell默认的输入和输出导向到相应的位置，如下介绍：</li></ul> 
<h5><a id="STDIN_16"></a>STDIN（标准输入）</h5> 
<ul><li><strong>STDIN文件描述符代表shell的标准输入</strong>。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符</li><li>在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符，它会读取文件并提取数据，就好像是从键盘上键入的</li><li>许多bash命令能接受STDIN的输入，尤其是没有在命令行上指定文件的话。如下是使用cat命令处理STDIN输入的数据的例子：<br> <img src="https://images2.imgbox.com/ac/f2/rhxcLSC2_o.png" alt="在这里插入图片描述"></li><li>当在命令行上只输入cat命令时，它会从STDIN接受输入（键盘）。键盘输入一行，cat命令就会显示出一行，但我们也可以通过<strong>STDIN重定向符号强制cat命令接受来自另一个STDIN文件的输入</strong>，如下：<br> <img src="https://images2.imgbox.com/74/5a/eojegZia_o.png" alt="在这里插入图片描述"></li><li>如上cat命令会用cat_txt文件中的行作为输入。我们还可以使用这种技术<strong>将数据输入到任何能从STDIN接受数据的shell命令中</strong></li></ul> 
<h5><a id="STDOUT_24"></a>STDOUT（标准输出）</h5> 
<ul><li> <p>STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器</p> </li><li> <p>默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，如下，我们可以用输出重定向来改变标准输出：<br> <img src="https://images2.imgbox.com/96/07/7LFFOChO_o.png" alt="在这里插入图片描述"></p> </li><li> <p>通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。我们也可以将数据追加到某个文件。这可以<strong>用&gt;&gt;符号</strong>来完成，如下：<br> <img src="https://images2.imgbox.com/aa/99/BcpmoOw2_o.png" alt="在这里插入图片描述"></p> </li><li> <p>who命令生成的输出会被追加到ls_txt文件中已有数据的后面，但是如果你对脚本使用了标准输出重定向，你还可能遇到一个特殊的问题，如下：<br> <img src="https://images2.imgbox.com/56/41/3eidqJpg_o.png" alt="在这里插入图片描述"></p> </li><li> <p>当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示new_ls文件的内容时并没有任何错误。new_ls文件创建成功了，只是没有内容而已</p> </li><li> <p>shell对于<strong>错误消息的处理是跟普通输出分开的</strong>。如果我们创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些错误信息也是不会出现在日志文件中的，需要换种方法来处理</p> </li></ul> 
<h5><a id="STDERR_36"></a>STDERR（标准错误）</h5> 
<ul><li>shell通过特殊的STDERR文件描述符来处理错误消息。<strong>STDERR文件描述符代表shell的标准错误输出</strong>。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置</li><li>默认情况下，<strong>STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同</strong>）。也就是说，默认情况下，错误消息也会输出到显示器输出中</li><li>但是从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，我们常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候，如下介绍</li></ul> 
<h3><a id="_40"></a>重定向错误</h3> 
<ul><li>我们已经学习了如何用重定向符号来重定向STDOUT数据。重定向STDERR数据也没太大差别，只要在<strong>使用重定向符号时定义STDERR文件描述符</strong>即可。有如下几种办法实现</li></ul> 
<h4><a id="_42"></a>只重定向错误</h4> 
<ul><li>STDERR文件描述符被设成2。<strong>选择只重定向错误消息时，只需要将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作</strong>，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token function">ls</span> <span class="token operator">-</span>l badTXT 2&gt; err<span class="token punctuation">.</span>txt
</code></pre> 
<p><img src="https://images2.imgbox.com/d5/c5/iYAehX9i_o.png" alt="在这里插入图片描述"></p> 
<ul><li>如上，错误消息不会出现在屏幕上了。只需要注意：<strong>文件描述符值紧贴在重定向符号前，二者之间没有空白符</strong>，该命令生成的任何错误消息都会保存在输出文件中。用这种方法，shell会只重定向错误消息，而非普通数据。这里是另一个将STDOUT和STDERR消息混杂在同一输出中的例子，如下：<br> <img src="https://images2.imgbox.com/9f/2f/OPNvjXyf_o.png" alt="在这里插入图片描述"></li><li>ls命令的正常STDOUT输出仍然会发送到默认的STDOUT文件描述符，也就是显示器。由于该命令将<strong>文件描述符2的输出（STDERR）重定向到了一个输出文件</strong>，shell会将生成的所有错误消息直接发送到指定的重定向文件中</li></ul> 
<h4><a id="_52"></a>重定向错误和数据</h4> 
<ul><li>如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token function">ls</span> <span class="token operator">-</span>l err<span class="token punctuation">.</span>txt new_ls badTXT 2&gt; err01<span class="token punctuation">.</span>txt 1&gt; succ01<span class="token punctuation">.</span>txt
</code></pre> 
<p><img src="https://images2.imgbox.com/6f/cb/JqMF6NcL_o.png" alt="在这里插入图片描述"></p> 
<ul><li>shell利用<strong>1&gt;符号</strong>将ls命令的正常输出重定向到了succ01.txt文件，而这些输出本该是进入STDOUT的。所有本该输出到STDERR的错误消息通过<strong>2&gt;符号</strong>被重定向到了err01.txt文件</li><li>使用这种方法可以将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松方便地查看错误信息</li><li>也可以<strong>将STDERR和STDOUT的输出重定向到同一个输出文件</strong>。为此bash shell提供了特殊的<strong>重定向符号&amp;&gt;</strong>，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token function">ls</span> <span class="token operator">-</span>l err<span class="token punctuation">.</span>txt new_ls badTXT &amp;&gt; normal<span class="token punctuation">.</span>txt
</code></pre> 
<p><img src="https://images2.imgbox.com/04/41/sWBrhBKS_o.png" alt="在这里插入图片描述"></p> 
<ul><li>当<strong>使用&amp;&gt;符时</strong>，命令生成的所有输出都会发送到同一文件，包括数据输出和错误。我们注意到其中错误消息出现的位置和预想中的不一样。badTXT文件（列出的最后一个文件）的这条错误消息出现在输出文件中的第一行。这是<strong>为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级</strong>。这样就可以集中查看错误信息</li></ul> 
<h3><a id="shell_70"></a>在shell脚本中重定向输出</h3> 
<ul><li>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出： 
  <ul><li><strong>临时重定向行输出</strong></li><li><strong>永久重定向脚本中的所有命令</strong></li></ul> </li></ul> 
<h4><a id="_74"></a>临时重定向</h4> 
<ul><li>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是<strong>使用输出重定向符来将输出信息重定向到STDERR文件描述符</strong>。在重定向到文件描述符时，必须在文件描述符数字之前<strong>加&amp;</strong>，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token function">echo</span> <span class="token string">"数据错误！！"</span> &gt;&amp;2
</code></pre> 
<ul><li>这行代码的输出会在脚本的STDERR文件描述符所指向的位置显示文本，而不是通常的STDOUT，如下：</li></ul> 
<pre><code class="prism language-powershell">
<span class="token comment">#!/bin/bash</span>

<span class="token function">echo</span> <span class="token string">"错误输出！！"</span> &gt;&amp;2
<span class="token function">echo</span> <span class="token string">"正常输出！！"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/1b/ko58fN5Q_o.png" alt="在这里插入图片描述"></p> 
<ul><li>如果像平常一样运行这个脚本，是看不出有什么区别的，默认情况下，Linux会<strong>将STDERR导向STDOUT</strong>。但是，如果在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向，如下：<br> <img src="https://images2.imgbox.com/cb/02/5qQeu1w9_o.png" alt="在这里插入图片描述"></li><li>通过STDOUT显示的文本显示在了屏幕上，而发送给STDERR的echo语句的文本则被<br> 重定向到了输出文件</li></ul> 
<h4><a id="_95"></a>永久重定向</h4> 
<ul><li>当脚本中有大量数据需要重定向，重定向每个echo语句就会很烦琐。我们可以使用<strong>exec命令</strong>告诉shell在脚本执行期间重定向某个特定文件描述符，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 1&gt;succ02<span class="token punctuation">.</span>txt

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span>
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/79/83/lWcE5anb_o.png" alt="在这里插入图片描述"></p> 
<ul><li>exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件，可以在脚本执行过程中重定向STDOUT，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 2&gt;err03<span class="token punctuation">.</span>txt

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span>
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span>

exec 1&gt;succ03<span class="token punctuation">.</span>txt

<span class="token function">echo</span> <span class="token string">"正确输出&gt;succ03.txt"</span>
<span class="token function">echo</span> <span class="token string">"错误输出&gt;err03.txt"</span> &gt;&amp;2
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/02/dGHcHqcv_o.png" alt="在这里插入图片描述"></p> 
<ul><li>上述脚本用exec命令来将发给STDERR的输出重定向到文件err03.txt。然后脚本用echo语句向STDOUT显示了几行文本。随后使用exec命令来将STDOUT重定向到succ03.txt文件</li><li>注意，<strong>尽管STDOUT被重定向了，但仍然可以将echo语句的输出发给STDERR</strong></li><li>当我们只想将脚本的部分输出重定向到其他位置时（如错误日志），这个特性用起来非常方便。不过这样做的话，会碰到一个问题一旦重定向了STDOUT或STDERR，就很难再将它们重定向回原来的位置，如果需要在重定向中来回切换的话，下面会介绍一种方法</li></ul> 
<h3><a id="shell_129"></a>在shell脚本中重定向输入</h3> 
<ul><li>我们可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许<strong>将STDIN重定向到Linux系统上的文件中</strong>，如下格式：</li></ul> 
<pre><code class="prism language-powershell">exec 0&lt; inputfile
</code></pre> 
<ul><li>这个命令会告诉<strong>shell它应该从文件testfile中获得输入</strong>，而不是STDIN。这个重定向只要在脚本需要输入时就会作用。如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 0&lt;name<span class="token punctuation">.</span>txt

count=1

<span class="token keyword">while</span> read line
<span class="token keyword">do</span>
        <span class="token function">echo</span> <span class="token string">"Name #<span class="token variable">$count</span>：<span class="token variable">$line</span>"</span>
        count=$<span class="token punctuation">[</span> <span class="token variable">$count</span> <span class="token operator">+</span> 1 <span class="token punctuation">]</span>
done
</code></pre> 
<p><img src="https://images2.imgbox.com/cc/30/qfEBmop6_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在之前我们学习了如何使用read命令读取用户在键盘上输入的数据。将STDIN重定向到文件后，当read命令试图从STDIN读入数据时，它会到文件去取数据，而不是键盘，这是在脚本中从待处理的文件中读取数据的较好办法</li></ul> 
<h3><a id="_155"></a>创建自己的重定向</h3> 
<ul><li>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符，在之前提到过，<strong>在shell中最多可以有9个打开的文件描述符</strong>。其他6个从3~8的文件描述符均可用作输入或输出重定向。你可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们</li></ul> 
<h4><a id="_157"></a>创建输出文件描述符</h4> 
<ul><li>可以<strong>用exec命令来给输出分配文件描述符</strong>。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配，如下：</li></ul> 
<pre><code class="prism language-powershell">
<span class="token comment">#!/bin/bash</span>

exec 3&gt;test05out

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span>
<span class="token function">echo</span> <span class="token string">"输出&gt;test05out"</span> &gt;&amp;3
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/48/CBY0Nl2H_o.png" alt="在这里插入图片描述"></p> 
<ul><li>脚本用exec命令将<strong>文件描述符3重定向到另一个文件</strong>。当脚本执行echo语句时，输出内<br> 容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入了另一个文件。这样就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如日志文件）</li><li>也可以不用创建新文件，而是使用exec命令来将输出追加到现有文件中:</li></ul> 
<pre><code class="prism language-powershell">exec 3&gt;&gt;test05out
</code></pre> 
<ul><li>现在输出会被追加到test05out文件，而不是创建一个新文件</li></ul> 
<h4><a id="_181"></a>重定向文件描述符</h4> 
<ul><li>那么我们该怎么恢复已重定向的文件描述符呢？解决方法：<strong>可以分配另外一个文件描符给标准文件描述符，反之亦然</strong>。这意味着可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 3&gt;&amp;1
exec 1&gt;test06out

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span>

exec 1&gt;&amp;3
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7a/1a/PubRPHSZ_o.png" alt="在这里插入图片描述"></p> 
<ul><li>上述代码：首先，脚本将<strong>文件描述符3重定向到文件描述符1的当前位置，也就是STDOUT</strong>。这意味着任何发送给文件描述符3的输出都将出现在显示器上，第二个exec命令将<strong>STDOUT重定向到文件</strong>，shell现在会将发送给STDOUT的输出直接重定向到输出文件中</li><li>但是，<strong>文件描述符3仍然指向STDOUT原来的位置，也就是显示器</strong>。如果此时将输出数据发送给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了。在向STDOUT（现在指向一个文件）发送一些输出之后，脚本将STDOUT重定向到文件描述符3的当前位置（现在仍然是显示器）。这意味着现在STDOUT又指向了它原来的位置（显示器）。这个方法可能有点令人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置的常用方法</li></ul> 
<h4><a id="_199"></a>创建输入文件描述符</h4> 
<ul><li>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 6&lt;&amp;0
exec 0&lt;name<span class="token punctuation">.</span>txt

count=1

<span class="token keyword">while</span> read line
<span class="token keyword">do</span>
        <span class="token function">echo</span> <span class="token string">"Name #<span class="token variable">$count</span>：<span class="token variable">$line</span>"</span>
        count=$<span class="token punctuation">[</span> <span class="token variable">$count</span> <span class="token operator">+</span> 1 <span class="token punctuation">]</span>
done

exec 0&lt;&amp;6
read <span class="token operator">-</span>p <span class="token string">"是否结束？[y|n]"</span> answer
case <span class="token variable">$answer</span> in
        Y<span class="token punctuation">|</span>y<span class="token punctuation">)</span> <span class="token function">echo</span> <span class="token string">"已完成，再见！！"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
        N<span class="token punctuation">|</span>n<span class="token punctuation">)</span> <span class="token function">echo</span> <span class="token string">"已经结束！！"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
esac
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/a1/DDSbcbtS_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在上述例子中，<strong>文件描述符6用来保存STDIN的位置。然后脚本将STDIN重定向到一个文件</strong>。read命令的所有输入都来自重定向后的STDIN（也就是输入文件）。在读取了所有行之后，脚本会将STDIN重定向到文件描述符6，从而将STDIN恢复到原先的位置。然后使用了read命令来测试STDIN是否恢复正常了。这次它会等待键盘的输入</li></ul> 
<h4><a id="_226"></a>创建读写文件描述符</h4> 
<ul><li>我们还可以打开<strong>单个文件描述符来作为输入和输出</strong>。可以用同一个文件描述符对同一个文件进行读写。不过用这种方法时，需要特别注意。由于是对<strong>同一个文件进行数据读写shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始</strong>。如果不够小心，它会产生一些奇奇怪怪的结果，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 3&lt;&gt;test08txt

read line &lt;&amp;3
<span class="token function">echo</span> <span class="token string">"输入：<span class="token variable">$line</span>"</span>
<span class="token function">echo</span> <span class="token string">"输出：我劝天公重抖擞，不拘一格降人才"</span> &gt;&amp;3
</code></pre> 
<p><img src="https://images2.imgbox.com/39/8d/WC4mvHOp_o.png" alt="在这里插入图片描述"></p> 
<ul><li>上述例子用了<strong>exec命令将文件描述符3分配给文件test08txt以进行文件读写</strong>。接下来，它通过分配好的文件描述符，使用read命令读取文件中的第一行，然后将这一行显示在STDOUT上，然后，用echo语句将一行数据写入由同一个文件描述符打开的文件中</li><li>在运行脚本时，一开始还算正常。输出内容表明脚本读取了testfile文件中的第一行。但如果在脚本运行完毕后，查看test08txt文件内容，会发现写入文件中的数据覆盖了已有的数据</li><li>当脚本向文件中写入数据时，它会从文件指针所处的位置开始。read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符。在echo语句将数据输出到文件时，它会将数据放在文件指针的当前位置，覆盖了当前文件指针位置的已有数据</li></ul> 
<h4><a id="_243"></a>关闭文件描述符</h4> 
<ul><li>如果我们创建了新的输入或输出文件描述符，<strong>shell会在脚本退出时自动关闭它们</strong>。然而在有些情况下，需要在脚本结束前手动关闭文件描述符。要关闭文件描述符，将它重定向到<strong>特殊符号&amp;-</strong>。格式如下：</li></ul> 
<pre><code class="prism language-powershell">exec 3&gt;&amp;<span class="token operator">-</span>
</code></pre> 
<ul><li>此语句会关闭文件描述符3，不再在脚本中使用它，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 3&gt;test09out
<span class="token function">echo</span> <span class="token string">"输出：但行好事莫问前程"</span> &gt;&amp;3
exec 3&gt;&amp;<span class="token operator">-</span>
<span class="token function">echo</span> <span class="token string">"错误输出：钝鸟先飞大器晚成"</span> &gt;&amp;3
</code></pre> 
<p><img src="https://images2.imgbox.com/8e/a1/iiO4PqLk_o.png" alt="在这里插入图片描述"></p> 
<ul><li>一旦关闭了文件描述符，就不能在脚本中向它写入任何数据，否则shell会生成错误消息。在关闭文件描述符时还要注意另一件事。<strong>如果随后在脚本中打开了同一个输出文件，shell会用一个新文件来替换已有文件。这意味着如果你输出数据，它就会覆盖已有文件</strong>，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>


exec 3&gt;test10out
<span class="token function">echo</span> <span class="token string">"输出01：但行好事莫问前程"</span> &gt;&amp;3
exec 3&gt;&amp;<span class="token operator">-</span>
<span class="token function">cat</span> test10out

exec 3&gt;test10out
<span class="token function">echo</span> <span class="token string">"输出02：钝鸟先飞大器晚成"</span> &gt;&amp;3
</code></pre> 
<p><img src="https://images2.imgbox.com/fe/59/6dYuAzlw_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在向test10out文件发送一个数据字符串并关闭该文件描述符之后，使用用了cat命令来查看文件的内容。到目前为止，一切都还好。下一步，脚本重新打开了该输出文件并向它发送了另一个数据字符串。当显示该输出文件的内容时，所能看到的只有第二个数据字符串。shell覆盖了原来的输出文件</li></ul> 
<h3><a id="_277"></a>列出打开的文件描述符</h3> 
<ul><li>我们所用的文件描述符只有9个，可能会觉得这没什么复杂的。但有时要记住哪个文件描述符被重定向到了哪里很难。为了帮助你理清条理，bash shell提供了lsof命令</li><li>lsof命令会列出整个Linux系统打开的所有文件描述符。这是个有争议的功能，因为<strong>它会向非系统管理员用户提供Linux系统的信息</strong>。鉴于此原因，许多Linux系统隐藏了该命令，这样普通用户就不会一不小心就发现了。在很多Linux系统中（如Fedora），lsof命令位于/usr/sbin目录。要想以普通用户账户来运行它，必须通过全路径名来引用：</li></ul> 
<pre><code class="prism language-powershell"><span class="token operator">/</span>usr/sbin/lsof 
</code></pre> 
<ul><li>此命令会产生大量的输出。它会显示当前Linux系统上打开的每个文件的有关信息。这包括<strong>后台运行的所有进程以及登录到系统的任何用户</strong>，有大量的命令行选项和参数可以用来帮助过滤lsof的输出。最常用的<strong>有-p和-d</strong>，前者允许<strong>指定进程ID（PID），后者允许指定要显示的文件描述符编号</strong>，要想知道进程的当前PID，可以用<strong>特殊环境变量$$（shell会将它设为当前PID）</strong>。-a选项用来对其他两个选项的结果执行布尔AND运算，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token operator">/</span>usr/bin/lsof <span class="token operator">-</span>a <span class="token operator">-</span>p $$ <span class="token operator">-</span>d 0<span class="token punctuation">,</span>1<span class="token punctuation">,</span>2
</code></pre> 
<p><img src="https://images2.imgbox.com/17/b6/45PLKGk3_o.png" alt="在这里插入图片描述"></p> 
<ul><li>上图显示了当前进程（bash shell）的默认文件描述符（0、1和2）。lsof的默认输出中有7列信息，如下表：</li></ul> 
<table><thead><tr><th>列 名</th><th>描 述</th></tr></thead><tbody><tr><td>COMMAND</td><td>正在运行的命令名的前9个字符</td></tr><tr><td>PID</td><td>进程的PID</td></tr><tr><td>USER</td><td>进程属主的登录名</td></tr><tr><td>FD</td><td>文件描述符号以及访问类型（r代表读，w代表写，u代表读写）</td></tr><tr><td>TYPE</td><td>文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）</td></tr><tr><td>DEVICE</td><td>设备的设备号（主设备号和从设备号）</td></tr><tr><td>SIZE</td><td>如果有的话，表示文件的大小</td></tr><tr><td>NODE</td><td>本地文件的节点号</td></tr><tr><td>NAME</td><td>文件名</td></tr></tbody></table> 
<ul><li>与STDIN、STDOUT和STDERR关联的文件类型是字符型。因为STDIN、STDOUT和STDERR文件描述符都指向终端，所以输出文件的名称就是终端的设备名。所有3种标准文件都支持读和写（尽管向STDIN写数据以及从STDOUT读数据看起来有点奇怪）</li><li>现在看一下在打开了多个替代性文件描述符的脚本中使用lsof命令的结果，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

exec 3&gt;test11out01
exec 6&gt;test11out02
exec 7&lt;name<span class="token punctuation">.</span>txt

<span class="token operator">/</span>usr/bin/lsof <span class="token operator">-</span>a <span class="token operator">-</span>p $$ <span class="token operator">-</span>d 0<span class="token punctuation">,</span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>3<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7
</code></pre> 
<p><img src="https://images2.imgbox.com/76/91/c0QuPrW2_o.png" alt="在这里插入图片描述"></p> 
<ul><li>上述脚本创建了3个替代性文件描述符，两个作为输出（3和6），一个作为输入（7）。在脚本运行lsof命令时，可以在输出中看到新的文件描述符。去掉了输出中的第一部分，这样就能看到文件名的结果了。文件名显示了文件描述符所使用的文件的完整路径名。它将每个文件都显示成REG类型的，这说明它们是文件系统中的常规文件</li></ul> 
<h3><a id="_320"></a>阻止命令输出</h3> 
<ul><li>有时候，我们可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。如果在运行在后台的脚本出现错误消息，shell会通过其它方式将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时</li><li>要解决这个问题，可以将<strong>STDERR重定向到一个叫作null文件的特殊文件</strong>。null文件跟它的名字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了</li><li>在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token function">ls</span> <span class="token operator">-</span>al &gt; <span class="token operator">/</span>dev/null
</code></pre> 
<p><img src="https://images2.imgbox.com/b2/cc/4vkQIZ5c_o.png" alt="在这里插入图片描述"></p> 
<ul><li>这是避免出现错误消息，也无需保存它们的一个常用方法：<br> <img src="https://images2.imgbox.com/12/6b/UPYhoP6l_o.png" alt="在这里插入图片描述"></li><li>也可以在输入重定向中将/dev/null作为输入文件。由于/dev/null文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建，如下：<br> <img src="https://images2.imgbox.com/9c/13/TogvQUoi_o.png" alt="在这里插入图片描述"><br> -文件name.txt仍然存在系统上，但现在它是空文件。这是清除日志文件的一个常用方法，因为日志文件必须时刻准备等待应用程序操作</li></ul> 
<h3><a id="_336"></a>创建临时文件</h3> 
<ul><li>Linux系统有特殊的目录，专供临时文件使用。Linux<strong>使用/tmp目录来存放不需要永久保留的文件</strong>。大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件，系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为你提供了一种创建临时文件的简单方法，而且还不用担心清理文件工作</li><li>有个特殊命令可以用来创建临时文件。<strong>mktemp命令可以在/tmp目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的umask值。它会将文件的读和写权限分配给文件的属主</strong>，并将你设成文件的属主。一旦创建了文件，我们就在脚本中有了完整的读写权限，但其他人没法访问它（当然，root用户除外）</li></ul> 
<h4><a id="_339"></a>创建本地临时文件</h4> 
<ul><li>默认情况下，mktemp会在本地目录中创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，只要指定一个文件名模板就行了。模板可以包含任意文本文件名，在文件名末尾<strong>加上6个X</strong>即可，如下：</li></ul> 
<pre><code class="prism language-powershell">mktemp testing<span class="token punctuation">.</span>XXXXXX
</code></pre> 
<p><img src="https://images2.imgbox.com/f9/12/RsDtrL0P_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>mktemp命令会用6个字符码替换这6个X，从而保证文件名在目录中是唯一的。你可以创建多个临时文件，它可以保证每个文件都是唯一的，如下：<br> <img src="https://images2.imgbox.com/fe/9a/gvzRHefX_o.png" alt="在这里插入图片描述"></p> </li><li> <p>如上图，mktemp命令的输出正是它所创建的文件的名字。<strong>在脚本中使用mktemp命令时，可能要将文件名保存到变量中</strong>，这样就能在后面的脚本中引用，如下：</p> </li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

tempfile=$<span class="token punctuation">(</span>mktemp test12<span class="token punctuation">.</span>XXXXXX<span class="token punctuation">)</span>

exec 3&gt;<span class="token variable">$tempfile</span>

<span class="token function">echo</span> <span class="token string">"临时文件为：<span class="token variable">$tempfile</span>"</span>

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span> &gt;&amp;3
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span> &gt;&amp;3

exec 3&gt;&amp;<span class="token operator">-</span>
<span class="token function">echo</span> <span class="token string">"临时文件的值为："</span>
<span class="token function">cat</span> <span class="token variable">$tempfile</span>
<span class="token function">rm</span> <span class="token operator">-</span>f <span class="token variable">$tempfile</span> 2&gt; <span class="token operator">/</span>dev/null
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/a9/Jd36nVOB_o.png" alt="在这里插入图片描述"></p> 
<ul><li>上述脚本用mktemp命令来创建临时文件并将文件名赋给$tempfile变量。接着将这个临时文件作为文件描述符3的输出重定向文件。在将临时文件名显示在STDOUT之后，向临时文件中写入了几行文本，然后关闭了文件描述符。最后，显示出临时文件的内容，并用rm命令将其删除</li></ul> 
<h4><a id="tmp__372"></a>在/tmp 目录创建临时文件</h4> 
<ul><li><strong>-t选项会强制mktemp命令来在系统的临时目录来创建该文件</strong>。在用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是只有文件名，如下：</li></ul> 
<pre><code class="prism language-powershell"> mktemp <span class="token operator">-</span>t test<span class="token punctuation">.</span>XXXXXX
</code></pre> 
<p><img src="https://images2.imgbox.com/fe/90/JhM9LmgV_o.png" alt="在这里插入图片描述"></p> 
<ul><li>由于<strong>mktemp -t命令</strong>返回了全路径名，可以在Linux系统上的任何目录下引用该临时文件，不管临时目录在哪里，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

tempfile=$<span class="token punctuation">(</span>mktemp <span class="token operator">-</span>t test<span class="token punctuation">.</span>XXXXXX<span class="token punctuation">)</span>

exec 3&gt;<span class="token variable">$tempfile</span>

<span class="token function">echo</span> <span class="token string">"临时文件全路径为：<span class="token variable">$tempfile</span>"</span>

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span> &gt;&amp;3
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span> &gt;&amp;3

exec 3&gt;&amp;<span class="token operator">-</span>
<span class="token function">echo</span> <span class="token string">"临时文件的值为："</span>
<span class="token function">cat</span> <span class="token variable">$tempfile</span>
<span class="token function">rm</span> <span class="token operator">-</span>f <span class="token variable">$tempfile</span> 2&gt; <span class="token operator">/</span>dev/null
</code></pre> 
<p><img src="https://images2.imgbox.com/7c/b3/aAq41F1r_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在mktemp创建临时文件时，它会将全路径名返回给变量。这样就能在任何命令中使用该值来引用临时文件</li></ul> 
<h4><a id="_402"></a>创建临时目录</h4> 
<ul><li><strong>-d选项</strong>告诉mktemp命令来创建一个临时目录而不是临时文件。这样就能用该目录进行任何需要的操作了，比如创建其他的临时文件，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

tempdir=$<span class="token punctuation">(</span>mktemp <span class="token operator">-</span>d <span class="token function">dir</span><span class="token punctuation">.</span>XXXXXX<span class="token punctuation">)</span>
cd <span class="token variable">$tempdir</span>
tempfile1=$<span class="token punctuation">(</span>mktemp test<span class="token punctuation">.</span>XXXXXX<span class="token punctuation">)</span>
tempfile2=$<span class="token punctuation">(</span>mktemp test<span class="token punctuation">.</span>XXXXXX<span class="token punctuation">)</span>

exec 3&gt;<span class="token variable">$tempfile1</span>
exec 4&gt;<span class="token variable">$tempfile2</span>

<span class="token function">echo</span> <span class="token string">"临时文件目录为：<span class="token variable">$tempdir</span>"</span>

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span> &gt;&amp;3
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span> &gt;&amp;4
</code></pre> 
<p><img src="https://images2.imgbox.com/de/30/OSJjoFbY_o.png" alt="在这里插入图片描述"></p> 
<ul><li>上述脚本在当前目录创建了一个目录，然后它用cd命令进入该目录，并创建了两个临时文件。之后这两个临时文件被分配给文件描述符，用来存储脚本的输出</li></ul> 
<h3><a id="_424"></a>记录消息</h3> 
<ul><li>将输出同时发送到显示器和日志文件，这种做法有时候能够派上用场。不用将输出重定向两次，只要用特殊的tee命令就行，<strong>tee命令相当于管道的一个T型接头。它将从STDIN过来的数据同时发往两处。一处是STDOUT，另一处是tee命令行所指定的文件名</strong>，格式如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token function">tee</span> testfile
</code></pre> 
<ul><li>由于tee会重定向来自STDIN的数据，可以用它配合管道命令来重定向命令输出，如下：</li></ul> 
<pre><code class="prism language-powershell">date <span class="token punctuation">|</span> <span class="token function">tee</span> testfile
</code></pre> 
<p><img src="https://images2.imgbox.com/cf/13/iCwKY8TM_o.png" alt="在这里插入图片描述"></p> 
<ul><li>输出出现在了STDOUT中，同时也写入了指定的文件中。注意，默认情况下，<strong>tee命令会在每次使用时覆盖输出文件内容</strong>，如下：<br> <img src="https://images2.imgbox.com/80/40/LbFoSz3A_o.png" alt="在这里插入图片描述"></li><li>如果想将数据追加到文件中，必须用-a选项，如下：<br> <img src="https://images2.imgbox.com/e8/3f/ZLN1Sfad_o.png" alt="在这里插入图片描述"></li><li>利用上述的方法，既能将数据保存在文件中，也能将数据显示在屏幕上，如下：</li></ul> 
<pre><code class="prism language-powershell"><span class="token comment">#!/bin/bash</span>

tempfile=test15out

<span class="token function">echo</span> <span class="token string">"但行好事莫问前程"</span> <span class="token punctuation">|</span> <span class="token function">tee</span> <span class="token variable">$tempfile</span>
<span class="token function">echo</span> <span class="token string">"钝鸟先飞大器晚成"</span> <span class="token punctuation">|</span> <span class="token function">tee</span> <span class="token operator">-</span>a <span class="token variable">$tempfile</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/49/11/jYKm40XO_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf2c4d9673c380da0e719bba8db7ccad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">国内超算中心官网</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc91130b66415001d994f9b0c772d341/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac系统下使用clion调试redis源码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>