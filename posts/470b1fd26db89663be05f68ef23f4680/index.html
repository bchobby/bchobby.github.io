<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud Alibaba实战第三课 Gateway、Sentinel实战 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud Alibaba实战第三课 Gateway、Sentinel实战" />
<meta property="og:description" content="09 服务门户：Spring Cloud Gateway 如何把好微服务的大门 上一讲我们学习了 Dubbo 是如何与 Nacos 协同作业。通过对比 RESTful 与 RPC，我们介绍了两种通信方式的区别，再通过实例讲解如何将 Dubbo 与 Nacos 进行整合。但你是否发现无论是基于 OpenFeign 的 RESTful 通信，还是基于 Dubbo 的 RPC 通信，它们都在强调的是微服务间的信息传递，属于微服务架构内部的事情。而对于用户端从外侧访问微服务如何有效管理，微服务又是如何将接口暴露给用户呢？这就需要通过 API 网关实现需求了，本讲咱们就针对 API 网关学习三方面知识：
介绍 API 网关的用途与产品；
讲解 Spring Cloud Gateway 的配置技巧；
讲解 Gateway执行原理与自定义过滤器（Filter）。
API 网关的作用 如下图所示，对于整个微服务来说如果将每一个微服务的接口直接暴露给用户是错误的做法，这里主要体现出三个问题：
服务将所有 API 接口对外直接暴露给用户端，这本身就是不安全和不可控的，用户可能越权访问不属于它的功能，例如普通的用户去访问管理员的高级功能。
后台服务可能采用不同的通信方式，如服务 A 采用 RESTful 通信，服务 B 采用 RPC 通信，不同的接入方式让用户端接入困难。尤其是 App 端接入 RPC 过程更为复杂。
在服务访问前很难做到统一的前置处理，如服务访问前需要对用户进行鉴权，这就必须将鉴权代码分散到每个服务模块中，随着服务数量增加代码将难以维护。
用户端直接访问微服务
为了解决以上问题，API 网关应运而生，加入网关后应用架构变为下图所示。
引入 API 网关后的微服务架构
当引入 API 网关后，在用户端与微服务之间建立了一道屏障，通过 API 网关为微服务访问提供了统一的访问入口，所有用户端的请求被 API 网关拦截并在此基础上可以实现额外功能，例如：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/470b1fd26db89663be05f68ef23f4680/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-08T09:07:04+08:00" />
<meta property="article:modified_time" content="2022-05-08T09:07:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud Alibaba实战第三课 Gateway、Sentinel实战</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="09__Spring_Cloud_Gateway__0"></a>09 服务门户：Spring Cloud Gateway 如何把好微服务的大门</h4> 
<p class="">上一讲我们学习了 Dubbo 是如何与 Nacos 协同作业。通过对比 RESTful 与 RPC，我们介绍了两种通信方式的区别，再通过实例讲解如何将 Dubbo 与 Nacos 进行整合。但你是否发现无论是基于 OpenFeign 的 RESTful 通信，还是基于 Dubbo 的 RPC 通信，它们都在强调的是微服务间的信息传递，属于微服务架构内部的事情。而对于用户端从外侧访问微服务如何有效管理，微服务又是如何将接口暴露给用户呢？这就需要通过 API 网关实现需求了，本讲咱们就针对 API 网关学习三方面知识：</p> 
<ol><li> <p>介绍 API 网关的用途与产品；</p> </li><li> <p>讲解 Spring Cloud Gateway 的配置技巧；</p> </li><li> <p>讲解 Gateway执行原理与自定义过滤器（Filter）。</p> </li></ol> 
<h4>API 网关的作用</h4> 
<p>如下图所示，对于整个微服务来说如果将每一个微服务的接口直接暴露给用户是错误的做法，这里主要体现出三个问题：</p> 
<ul><li> <p>服务将所有 API 接口对外直接暴露给用户端，这本身就是不安全和不可控的，用户可能越权访问不属于它的功能，例如普通的用户去访问管理员的高级功能。</p> </li><li> <p>后台服务可能采用不同的通信方式，如服务 A 采用 RESTful 通信，服务 B 采用 RPC 通信，不同的接入方式让用户端接入困难。尤其是 App 端接入 RPC 过程更为复杂。</p> </li><li> <p>在服务访问前很难做到统一的前置处理，如服务访问前需要对用户进行鉴权，这就必须将鉴权代码分散到每个服务模块中，随着服务数量增加代码将难以维护。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/7d/cd/KBnKMCig_o.png" alt="图片1.png"></p> 
<div> 
 <p>用户端直接访问微服务</p> 
</div> 
<p>为了解决以上问题，API 网关应运而生，加入网关后应用架构变为下图所示。</p> 
<p class="te-preview-highlight"><img src="https://images2.imgbox.com/4e/d0/OOSyurDl_o.png" alt="微信图片_20210322095840.png"></p> 
<div> 
 <p>引入 API 网关后的微服务架构</p> 
</div> 
<p>当引入 API 网关后，在用户端与微服务之间建立了一道屏障，通过 API 网关为微服务访问提供了统一的访问入口，所有用户端的请求被 API 网关拦截并在此基础上可以实现额外功能，例如：</p> 
<ul><li> <p>针对所有请求进行统一鉴权、熔断、限流、日志等前置处理，让微服务专注自己的业务。</p> </li><li> <p>统一调用风格，通常 API 网关对外提供 RESTful 风格 URL 接口。用户传入请求后，由 API 网关负责转换为后端服务需要的 RESTful、RPC、WebService 等方式，这样便大幅度简化用户的接入难度。</p> </li><li> <p>更好的安全性，在通过 API 网关鉴权后，可以控制不同角色用户访问后端服务的权利，实现了服务更细粒度的权限控制。</p> </li><li> <p>API 网关是用户端访问 API 的唯一入口，从用户的角度来说只需关注 API 网关暴露哪些接口，至于后端服务的处理细节，用户是不需要知道的。从这方面讲，微服务架构通过引入 API 网关，将用户端与微服务的具体实现进行了解耦。</p> </li></ul> 
<p>以上便是 API 网关的作用，那 API 网关有哪些产品呢？</p> 
<h5>API 网关主流产品</h5> 
<p>API 网关是微服务架构中必要的组件，具体的实现产品在软件市场上层出不穷，下面我列举三款在国内外主流的开源产品。</p> 
<h5>OpenResty</h5> 
<p>OpenResty 是一个强大的 Web 应用服务器，Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块,更主要的是在性能方面，OpenResty可以快速构造出足以胜任 10K 以上并发连接响应的超高性能 Web 应用系统。360、UPYUN、阿里云、新浪、腾讯网、去哪儿网、酷狗音乐等都是 OpenResty 的深度用户。</p> 
<p>OpenResty 因为性能强大在微服务架构早期深得架构师的喜爱。但 OpenResty 是一款独立的产品，与主流的注册中心存在一定兼容问题，需要架构师独立实现其服务注册、发现的功能。后来 Spring Cloud 官方极力推崇自家封装的 Zuul 或者 Spring Cloud Gateway，渐渐 OpenResty 便淡出了我们的视野。但不能否认，OpenResty 仍是一款优秀的 API 网关产品。</p> 
<h5>Spring Cloud Zuul</h5> 
<p>Zuul 是 Netflix 开源的微服务网关，它的主要职责是对用户请求进行路由转发与过滤。早期Spring Cloud 与 Netfilx 合作，使用 Zuul 作为微服务架构的首选网关产品。Zuul 是基于 J2EE Servlet 实现路由转发，网络通信采用同步方式，使用简单部署方便。经过 Spring Cloud 对 Zuul 的封装，Spring Cloud Zuul 应运而生。Spring Cloud Zuul 在原有 Zuul 的基础上，增加对注册中心的支持，同时在基于 Spring Boot Starter 机制基础上，可以在极短的时间内完成 API 网关的开发部署任务。</p> 
<p><img src="https://images2.imgbox.com/23/68/8hFzW8PU_o.png" alt="图片3.png"></p> 
<div> 
 <p>Zuul 基于 Servlet 的请求响应处理过程</p> 
</div> 
<p>但好景不长，后来 Netflix 内部产生分歧，Netflix 官方宣布 Zuul 停止维护，这让 Spring 机构也必须转型。于是 Spring Cloud 团队决定开发自己的第二代 API 网关产品：Spring Cloud Gateway。</p> 
<h5>Spring Cloud Gateway</h5> 
<p>与 Zuul 是“别人家的孩子”不同，Spring Cloud Gateway 是 Spring 自己开发的新一代 API 网关产品。它基于 NIO 异步处理，摒弃了 Zuul 基于 Servlet 同步通信的设计，因此拥有更好的性能。同时，Spring Cloud Gateway 对配置进行了进一步精简，比 Zuul 更加简单实用。</p> 
<p>以下是 Spring Cloud Gateway 的关键特征：</p> 
<ul><li> <p>基于 JDK 8+ 开发；</p> </li><li> <p>基于 Spring Framework 5 + Project Reactor + Spring Boot 2.0 构建；</p> </li><li> <p>支持动态路由，能够匹配任何请求属性上的路由；</p> </li><li> <p>支持基于 HTTP 请求的路由匹配（Path、Method、Header、Host 等）；</p> </li><li> <p>过滤器可以修改 HTTP 请求和 HTTP 响应（增加/修改 Header、增加/修改请求参数、改写请求 Path 等等）；</p> </li><li> <p>...</p> </li></ul> 
<p>当下 Spring Cloud Gateway 已然是 Spring Cloud 体系上API 网关标准组件。Spring Cloud Gateway 十分优秀，Spring Cloud Alibaba 也默认选用该组件作为网关产品，下面我们就通过实例讲解 Spring Cloud Gateway 的使用办法。</p> 
<h4>Spring Cloud Gateway的配置技巧</h4> 
<h5>Spring Cloud Gateway使用入门</h5> 
<p>示例说明：</p> 
<p>假设“service-a”微服务提供了三个 RESTful 接口。</p> 
<p><img src="https://images2.imgbox.com/26/37/cka1hTAO_o.png" alt="图片4.png"></p> 
<p>假设 “service-b” 微服务提供了三个 RESTful 接口。</p> 
<p><img src="https://images2.imgbox.com/86/fd/oo3ej6Ym_o.png" alt="图片5.png"></p> 
<p>如何通过部署 Spring Cloud Gateway 实现 API 路由功能来屏蔽后端细节呢？</p> 
<p>第一步，利用 Spring Initializr 向导创建 Gateway 工程，确保 pom.xml 引入以下依赖：</p> 
<pre class="lang-xml"><code><span class="hljs-comment">&lt;!-- Nacos客户端 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- Spring Cloud Gateway Starter --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 对外提供Gateway应用监控指标 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre> 
<p>第二步，在 application.yml 增加如下配置。</p> 
<pre class="lang-yaml"><code><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment">#配置微服务id</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#nacos通信地址</span>
        <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span>
        <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span>
    <span class="hljs-attr">gateway:</span> <span class="hljs-comment">#让gateway通过nacos实现自动路由转发</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">locator:</span>
          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#locator.enabled是自动根据URL规则实现路由转发</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#服务端口号</span>
<span class="hljs-attr">management:</span> 
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">'*'</span> <span class="hljs-comment">#对外暴露actuator所有监控指标，便于监控系统收集跟踪</span>
</code></pre> 
<p>在上面的配置中最重要的一句是：</p> 
<pre><code class="language-java"><code>spring.cloud.gateway.discovery.locator.enabled=<span class="hljs-keyword">true</span>
</code></code></pre> 
<p>这是一个自动项，允许 Gateway 自动实现后端微服务路由转发， Gateway 工程启动后，在浏览器地址栏按下面格式访问后端服务。</p> 
<pre><code class="language-java"><code>http:<span class="hljs-comment">//网关IP:端口/微服务id/URI</span>
</code></code></pre> 
<p>例如，网关 IP 为：192.168.31.103，我们需要通过网关执行 service-a 的 list 方法，具体写法为：</p> 
<pre><code class="language-java"><code>http:<span class="hljs-comment">//192.168.31.103:80/service-a/list</span>
</code></code></pre> 
<p>访问后 Gateway 按下图流程进行请求路由转发。</p> 
<p><img src="https://images2.imgbox.com/c8/17/8RlSlYBA_o.png" alt="图片6.png"></p> 
<div> 
 <p>基于网关自动路由处理流程</p> 
</div> 
<p>咱们来梳理下路由转发流程：</p> 
<ol><li> <p>Gateway、service-a 这些都是微服务实例，在启动时向 Nacos 注册登记；</p> </li><li> <p>用户端向 Gateway 发起请求，请求地址<a href="http://192.168.31.103:80/service-a/list" rel="nofollow">http://192.168.31.103:80/service-a/list</a>；</p> </li><li> <p>Gateway 网关实例收到请求，解析其中第二部分 service-a，即微服务 Id，第三部分 URI 为“/list”。之后向 Nacos 查询 service-a 可用实例列表；</p> </li><li> <p>Nacos 返回 120 与 121 两个可用微服务实例信息；</p> </li><li> <p>Spring Cloud Gateway 内置 Ribbon，根据默认轮询策略将请求转发至 120 实例，转发的完整 URL 将附加用户的 URI，即<a href="http://192.168.31.120:80/list" rel="nofollow">http://192.168.31.120:80/list</a>；</p> </li><li> <p>120 实例处理后返回 JSON 响应数据给 Gateway；</p> </li><li> <p>Gateway 返回给用户端，完成一次完整的请求路由转发过程。</p> </li></ol> 
<p>讲到这，我们已理解了 Spring Cloud Gateway 的执行过程。但是真实项目中，存在着各种特殊的路由转发规则，而非自动路由能简单解决的，在 Spring Cloud Gateway 项目中内置了强大的“谓词”系统，可以满足企业应用中的各种转发规则要求，下一小节咱们就来介绍常见的谓词用法。</p> 
<h5>谓词（Predicate）与过滤器（Filter）</h5> 
<p>在讲解前需要引入 Gateway 网关三个关键名词：路由（Route）、谓词（Predicate）、过滤器（Filter）。</p> 
<p>路由（Route）是指一个完整的网关地址映射与处理过程。一个完整的路由包含两部分配置：谓词（Predicate）与过滤器（Filter）。前端应用发来的请求要被转发到哪个微服务上，是由谓词决定的；而转发过程中请求、响应数据被网关如何加工处理是由过滤器决定的。说起来有些晦涩，我们通过实例进行讲解就容易理解了。</p> 
<p><strong>谓词（Predicate）</strong></p> 
<p>这里我们给出一个实例，将原有 Gateway 工程的 application.yml 文件修改为下面的设置：</p> 
<pre class="lang-yaml"><code><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span>
        <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span>
        <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span>
    <span class="hljs-string">gateway:</span> 
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">locator:</span>
          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#不再需要Gateway路由转发</span>
      <span class="hljs-string">routes:</span>  <span class="hljs-comment">#路由规则配置</span>
        <span class="hljs-comment">#第一个路由配置，service-a路由规则</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">service_a_route</span> <span class="hljs-comment">#路由唯一标识</span>
          <span class="hljs-comment">#lb开头代表基于gateway的负载均衡策略选择实例</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-a</span> 
          <span class="hljs-comment">#谓词配置</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-comment">#Path路径谓词，代表用户端URI如果以/a开头便会转发到service-a实例</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/a/**</span> 
            <span class="hljs-comment">#After生效时间谓词，2020年10月15日后该路由才能在网关对外暴露</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">After=2020-10-05T00:00:00.000+08:00[Asia/Shanghai]</span>
          <span class="hljs-comment">#谓词配置</span>
          <span class="hljs-attr">filters:</span>
            <span class="hljs-comment">#忽略掉第一层前缀进行转发</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span> 
            <span class="hljs-comment">#为响应头附加X-Response=Blue</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=X-Response,Blue</span> 
        <span class="hljs-comment">#第二个路由配置，service-b路由规则</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">service_b_route</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-b</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/b/**</span>
          <span class="hljs-attr">filters:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">'*'</span>
</code></pre> 
<p>我来翻译下上面的配置：<br> 在 2020 年 10 月 15 日后，当用户端发来/a/...开头的请求时，Spring Cloud Gateway 会自动获取 service-a 可用实例，默认采用轮询方式将URI附加至实例地址后，形成新地址，service-a处理后 Gateway 网关自动在响应头附加 X-Response=Blue。至于第二个 service_b_route，比较简单，只说明当用户访问/b开头 URL 时，转发到 service-b 可用实例。</p> 
<p>完整的路由配置格式固定如下：</p> 
<pre class="lang-yaml"><code><span class="hljs-attr">spring:</span>
    <span class="hljs-string">gateway:</span> 
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">locator:</span>
          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#不再需要Gateway路由转发</span>
      <span class="hljs-string">routes:</span> 
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">xxx</span> <span class="hljs-comment">#路由规则id</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://微服务id</span>  <span class="hljs-comment">#路由转发至哪个微服务</span>
          <span class="hljs-string">predicates:</span> 
         <span class="hljs-string">//具体的谓词</span>
         <span class="hljs-attr">filters:</span>
         <span class="hljs-string">//具体的过滤器</span>
</code></pre> 
<p>其中 predicates 是重点，说明路由生效条件，在这里我将常见的谓词使用形式列出来。</p> 
<ul><li> <p>After 代表在指定时点后路由规则生效。</p> </li></ul> 
<pre><code class="language-java"><code>predicates:
    - After=<span class="hljs-number">2020</span>-<span class="hljs-number">10</span>-<span class="hljs-number">04</span>T00:<span class="hljs-number">00</span>:<span class="hljs-number">00.000</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>
</code></code></pre> 
<ul><li> <p>Before 代表在指定时点前路由规则生效。</p> </li></ul> 
<pre><code class="language-java"><code>predicates:
    - Before=<span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">20</span>T17:<span class="hljs-number">42</span>:<span class="hljs-number">47.789</span>-<span class="hljs-number">07</span>:<span class="hljs-number">00</span>[America/Denver]
</code></code></pre> 
<ul><li> <p>Path 代表 URI 符合映射规则时生效。</p> </li></ul> 
<pre><code class="language-java"><code>predicates:
    - Path=/b<span class="hljs-comment">/**
</span></code></code></pre> 
<ul><li> <p>Header 代表包含指定请求头时生效。</p> </li></ul> 
<pre><code class="language-java"><code>predicates:
    - Header=X-Request-Id, \d+
</code></code></pre> 
<p>这里额外解释下，如果请求具有名为 X-Request-Id 的 Header，其值与\d+正则表达式匹配（具有一个或多个数字的值），则该路由匹配。</p> 
<ul><li> <p>Method 代表要求 HTTP 方法符合规定时生效。</p> </li></ul> 
<pre><code class="language-java"><code>predicates:
    - Method=GET
</code></code></pre> 
<p>谓词是 Gateway 网关中最灵活的部分，刚才列举的是最常用的谓词，还有很多谓词是在文中没有提到，如果你对这部分感兴趣可以翻阅<a href="https://spring.io/projects/spring-cloud-gateway%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0" rel="nofollow">https://spring.io/projects/spring-cloud-gateway</a>进行学习。</p> 
<p><strong>过滤器（Filter）</strong></p> 
<p>过滤器（Filter）可以对请求或响应的数据进行额外处理，这里我们列出三个最常用的内置过滤器进行说明。</p> 
<ul><li> <p>AddRequestParameter 是对所有匹配的请求添加一个查询参数。</p> </li></ul> 
<pre><code class="language-java"><code>filters:
- AddRequestParameter=foo,bar #在请求参数中追加foo=bar
</code></code></pre> 
<ul><li> <p>AddResponseHeader 会对所有匹配的请求，在返回结果给客户端之前，在 Header 中添加响应的数据。</p> </li></ul> 
<pre><code class="language-java"><code>#在Response中添加Header头，key=X-Response-Foo，Value=Bar。
filters:
- AddResponseHeader=X-Response,Blue
</code></code></pre> 
<ul><li> <p>Retry 为重试过滤器，当后端服务不可用时，网关会根据配置参数来发起重试请求。</p> </li></ul> 
<pre><code class="language-java"><code>filters:
#涉及过滤器参数时，采用name-args的完整写法
- name: Retry #name是内置的过滤器名
  args: #参数部分使用args说明
    retries: 3
    status: 503
</code></code></pre> 
<p>以上片段含义为，当后端服务返回 503 状态码的响应后，Retry 过滤器会重新发起请求，最多重试 3 次。</p> 
<p>以上是三种最常用的内置过滤器的使用案例，因为 Spring Cloud 内置过滤器将近 30 个，这里咱们就不一一列举，有兴趣的同学可以查询官方资料。</p> 
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.6.RELEASE/reference/html/#gatewayfilter-factories" rel="nofollow">https://docs.spring.io/spring-cloud-gateway/docs/2.2.6.RELEASE/reference/html/#gatewayfilter-factories</a></p> 
<h4>Gateway 的执行原理与自定义过滤器</h4> 
<h5>Spring Cloud Gateway 的执行原理</h5> 
<p>在初步掌握 Spring Cloud Gateway 的配置技巧与谓词用法后，我们来关注 Gateway 底层的实现细节。</p> 
<p>下图是 Spring Cloud Gateway 的执行流程。</p> 
<p><img src="https://images2.imgbox.com/d5/17/eudjeG6U_o.png" alt="图片7.png"></p> 
<p>按执行顺序可以拆解以下几步：</p> 
<ol><li> <p>Spring Cloud Gateway 启动时基于 Netty Server 监听指定的端口（该端口可以通过 server.port 属性自定义）。当前端应用发送一个请求到网关时，进入 Gateway Handler Mapping 处理过程，网关会根据当前 Gateway 所配置的谓词（Predicate）来决定是由哪个微服务进行处理。</p> </li><li> <p>确定微服务后，请求向后进入 Gateway Web Handler 处理过程，该过程中 Gateway 根据过滤器（Filters）配置，将请求按前后顺序依次交给 Filter 过滤链进行前置（Pre）处理，前置处理通常是对请求进行前置检查，例如：判断是否包含某个指定请求头、检查请求的 IP 来源是否合法、请求包含的参数是否正确等。</p> </li><li> <p>当过滤链前置（Pre）处理完毕后，请求会被 Gateway 转发到真正的微服务实例进行处理，微服务处理后会返回响应数据，这些响应数据会按原路径返回被 Gateway 配置的过滤链进行后置处理（Post），后置处理通常是对响应进行额外处理，例如：将处理过程写入日志、为响应附加额外的响应头或者流量监控等。</p> </li></ol> 
<p>可以看到，在整个处理过程中谓词（Predicate）与过滤器（Filter）起到了重要作用，谓词决定了路径的匹配规则，让 Gateway 确定应用哪个微服务，而 Filter 则是对请求或响应作出实质的前置、后置处理。</p> 
<p>在项目中功能场景多种多样，像日常的用户身份鉴权、日志记录、黑白名单、反爬虫等基础功能都可以通过自定义 Filter 为 Gateway 进行功能扩展，下面我们通过“计时过滤器”为例，讲解如何为 Gateway 绑定自定义全局过滤器。</p> 
<h5>自定义全局过滤器</h5> 
<p>在 Spring Cloud Gateway 中，自定义过滤器分为两种，全局过滤器与局部过滤器。两者唯一的区别是：全局过滤器默认应用在所有路由（Route）上，而局部过滤器可以为指定的路由绑定。下面咱们通过“计时过滤器”这个案例讲解全局过滤器的配置。所谓计时过滤器是指任何从网关访问的请求，都要在日志中记录下从请求进入到响应退出的执行时间，通过这个时间运维人员便可以收集并分析哪些功能进行了慢处理，以此为依据进行进一步优化。下面是计时过滤器的代码，重要的部分我通过注释进行了说明。</p> 
<pre><code class="language-java"><code><span class="hljs-keyword">package</span> com.lagou.gateway.filter;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;
<span class="hljs-keyword">import</span> org.springframework.core.Ordered;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;
<span class="hljs-keyword">import</span> reactor.core.publisher.Mono;
<span class="hljs-meta">@Component</span> <span class="hljs-comment">//自动实例化并被Spring IOC容器管理</span>
<span class="hljs-comment">//全局过滤器必须实现两个接口：GlobalFilter、Ordered</span>
<span class="hljs-comment">//GlobalFilter是全局过滤器接口，实现类要实现filter()方法进行功能扩展</span>
<span class="hljs-comment">//Ordered接口用于排序，通过实现getOrder()方法返回整数代表执行当前过滤器的前后顺序</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElapsedFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>{
    <span class="hljs-comment">//基于slf4j.Logger实现日志输出</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ElapsedFilter.class);
    //起始时间属性名
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ELAPSED_TIME_BEGIN = "elapsedTimeBegin";
    /**
     * 实现filter()方法记录处理时间
     * <span class="hljs-meta">@param</span> exchange 用于获取与当前请求、响应相关的数据，以及设置过滤器间传递的上下文数据
     * <span class="hljs-meta">@param</span> chain Gateway过滤器链对象
     * <span class="hljs-meta">@return</span> Mono对应一个异步任务，因为Gateway是基于Netty Server异步处理的,Mono对就代表异步处理完毕的情况。
     */
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>{
        <span class="hljs-comment">//Pre前置处理部分</span>
        <span class="hljs-comment">//在请求到达时，往ServerWebExchange上下文环境中放入了一个属性elapsedTimeBegin，保存请求执行前的时间戳</span>
        exchange.getAttributes().put(ELAPSED_TIME_BEGIN, System.currentTimeMillis());
</code></code></pre> 
<p>        <span class="hljs-comment">//chain.filter(exchange).then()对应Post后置处理部分</span><br>         <span class="hljs-comment">//当响应产生后，记录结束与elapsedTimeBegin起始时间比对，获取RESTful API的实际执行时间</span><br>         <span class="hljs-keyword">return</span> chain.filter(exchange).then(<br>                 Mono.fromRunnable(() -&gt; { <span class="hljs-comment">//当前过滤器得到响应时，计算并打印时间</span><br>                     Long startTime = exchange.getAttribute(ELAPSED_TIME_BEGIN);<br>                     <span class="hljs-keyword">if</span> (startTime != <span class="hljs-keyword">null</span>) {<!-- --><br>                         logger.info(exchange.getRequest().getRemoteAddress() <span class="hljs-comment">//远程访问的用户地址</span><br>                                 + <span class="hljs-string">" | “</span> +  exchange.getRequest().getPath()  <span class="hljs-comment">//Gateway URI</span><br>                                 + <span class="hljs-string">” | cost "</span> + (System.currentTimeMillis() - startTime) + <span class="hljs-string">“ms”</span>); <span class="hljs-comment">//处理时间</span><br>                     }<br>                 })<br>         );<br>     }<br>     <span class="hljs-comment">//设置为最高优先级，最先执行ElapsedFilter过滤器</span><br>     <span class="hljs-comment">//return Ordered.LOWEST_PRECEDENCE; 代表设置为最低优先级</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>{<!-- --><br>         <span class="hljs-keyword">return</span> Ordered.HIGHEST_PRECEDENCE;<br>     }<br> }<br> </p> 
<p>运行后通过 Gateway 访问任意微服务便会输出日志：</p> 
<pre><code class="language-java"><code><span class="hljs-number">2021</span>-<span class="hljs-number">01</span>-<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">36</span>:<span class="hljs-number">01.765</span>  INFO <span class="hljs-number">14052</span> --- [ctor-http-nio-<span class="hljs-number">4</span>] com.lagou.gateway.filter.ElapsedFilter   : /<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">57873</span> | /test-service/test | cost <span class="hljs-number">821</span>ms
</code></code></pre> 
<p>日志包含四部分：</p> 
<ul><li> <p>日志的基础信息包括时间、日志级别、线程、产生的类与方法等。</p> </li><li> <p>/0:0:0:0:0:0:0:1:57873 代表访问者的远程 IP 端口等信息。</p> </li><li> <p>/test-service/test 是通过 Gateway 访问的完整 URI，第一部分是服务名，第二部分是 RESTful 接口。</p> </li><li> <p>cost 821ms 是具体的执行时间。</p> </li></ul> 
<p>以上就是全局过滤器的开发方法，至于局部过滤器的配置方法与全局过滤器极为相似，有兴趣的同学通过下面的官方文档了解更详细的内容。</p> 
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.BUILD-SNAPSHOT/reference/html/%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82" rel="nofollow">https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.BUILD-SNAPSHOT/reference/html/</a></p> 
<h4>小结与预告</h4> 
<p>这一讲咱们学了三方面内容，首先讲解了什么是 API 网关，API 网关是负责微服务请求统一路由转发的组件，用户端所有的请求都要经过 API 网关路由、加工、过滤后送达给后端微服务。其次，讲解了 Spring Cloud Gateway 网关的部署方式，了解到谓词（Predicate）与过滤器（Filter）的作用。最后，咱们通过实例介绍了 Spring Cloud Gateway 的执行原理并实现了计时功能的全局过滤器。</p> 
<p>这里给你出一道思考题：结合你当前的项目思考下，API 网关除了路由还能额外实现哪些功能呢？</p> 
<p class="">下一讲我们将开始一个新篇章，介绍在微服务环境下如何通过服务降级、熔断等机制保护我们的微服务架构，避免雪崩效应的产生。</p> 
<hr> 
<h4><a id="10___409"></a>10 系统保护：微服务架构雪崩效应与服务限流</h4> 
<p class="">前面我们介绍了 OpenFeign 微服务间通信与 Spring Cloud Gateway 网关通信，这些是日常业务中的正常处理情况，但是在微服务环境下受制于网络、机器性能、算法、程序各方面影响，运行异常的情况也在显著提升，如果不做好异常保护，微服务架构就像空中楼阁一样随时可能会崩溃，从本节我们开始一个新话题：<strong>微服务的系统保护</strong>。通过这个话题，我们就可以了解在 Spring Cloud Alibaba 生态下解决雪崩等一系列危机整体架构安全的方法。</p> 
<p>这一讲我们先来对 Alibaba Sentinel 做入门讲解，涉及三方面内容：</p> 
<ul><li> <p>通过真实的生产案例讲解微服务的雪崩效应；</p> </li><li> <p>Alibaba Sentinel 的部署与配置；</p> </li><li> <p>配置的接口限流规则。</p> </li></ul> 
<h4>微服务的雪崩效应</h4> 
<h5>一次线上的服务雪崩事故</h5> 
<p>“雪崩”一词指的是山地积雪由于底部溶解等原因造成的突然大块塌落的现象，具有很强的破坏力。在微服务项目中指由于突发流量导致某个服务不可用，从而导致上游服务不可用，并产生级联效应，最终导致整个系统不可用，使用雪崩这个词来形容这一现象最合适不过。</p> 
<p>之前我在国内一家著名的金融服务机构负责架构设计与维护，经历过不止一次服务雪崩，这也给我造成了一些心理阴影。在日后的架构设计中，我总是情不自禁地从最坏的情况考虑，尽我所能规避最差的情况发生。</p> 
<p>下面我跟大家分享一次险些给公司带来重大损失的雪崩事故，希望各位能引以为戒。</p> 
<p>在 2015 年 “618” 前几天，当时我负责公司普惠金融业务线架构。</p> 
<p class=""><img src="https://images2.imgbox.com/6d/f7/E3igznlA_o.png" alt="图片1.png"></p> 
<div> 
 <p>普惠金融业务流程</p> 
</div> 
<p>平时从借款人门户的订单接口的访问峰值约为 100 TPS，因为并发压力不大，我对系统性能与可用性考虑不足，为节约成本也只为每一个子系统部署了单台高性能服务器。没想到在 6 月 16 日上午 10 点 30 分，技术部接到紧急通知，除催收系统外，各节点服务全线崩溃。崩溃前借款人门户订单接口 TPS 峰值高达 2000，出现大量请求积压，之后运维迅速重启服务，但没过5分钟，系统再次崩溃。技术部大佬和架构师们都发觉情况不妙，迅速启用 Nginx 限流，设置最多放行 200 TPS，多余请求直接拒绝，并且总部电话远程调度各区域客户经理分时间段录入借款数据，这才度过了本次难关。</p> 
<p>事后，架构组对本次问题进行复盘，发现 2015 年 618 是某东大促，客户购物热情激增，此时公司为配合 618 大促，推出了优惠力度最大的借款活动，这导致在这几天的业务量是平时的几十倍。而分散在全国的 20000 多名客户经理的工作习惯是在上午十点多集中录入昨日客户借款单据，如此庞大的短时并发让“贷后系统”不堪重负，出现长时未响应。同时上游的“借款人门户”与“信审风控”也处于阻塞等待的状态。而在客户经理这边看到表单提交无响应，便会 F5 刷新页面重发请求，这无疑又为“贷后系统”雪上加霜，之后便是贷后系统崩溃、信审系统崩溃、借款人门户网站崩溃这一连锁反应。</p> 
<p>发现了问题根源，解决也就简单了，经过多方权衡在以下几方面作出应对：</p> 
<ul><li> <p>提高可用性，将单台设备转为多台负载均衡集群。</p> </li><li> <p>提高性能，检查慢 SQL、优化算法、引入缓存来缩短单笔业务的处理时间。</p> </li><li> <p>预防瞬时 TPS 激增，将系统限流作为常态加入系统架构。</p> </li><li> <p>完善事后处理，遇到长响应，一旦超过规定窗口时间，服务立即返回异常，中断当前处理。</p> </li><li> <p>加强预警与监控，引入 ELK，进行流量实时监控与风险评估，及时发现系统风险。</p> </li><li> <p>完善制度，要求客户单据当日录入系统。</p> </li></ul> 
<p>刚才所描述的是一次典型的雪崩效应，下面我们来梳理下分布式架构为什么会产生雪崩？</p> 
<h5>为什么微服务会产生雪崩效应</h5> 
<p>如下图所示，假如我们开发了一套分布式应用系统，前端应用分别向 A/H/I/P 四个服务发起调用请求：</p> 
<p><img src="https://images2.imgbox.com/bd/28/QJuNZQie_o.png" alt="Drawing 1.png"></p> 
<div> 
 <p>前端应用需要四个服务</p> 
</div> 
<p>但随着时间推移，假如服务 I 因为优化问题，导致需要 20 秒才能返回响应，这就必然会导致 20 秒内该请求线程会一直处于阻塞状态。</p> 
<p><img src="https://images2.imgbox.com/a1/38/Hsg8gq2x_o.png" alt="Drawing 2.png"></p> 
<div> 
 <p>其中一个出现长延时，会导致前端应用线程阻塞</p> 
</div> 
<p>但是，如果这种状况放在高并发场景下，就绝对不允许出现，假如在 20 秒内有 10 万个请求通过应用访问到后端微服务。容器会因为大量请求阻塞积压导致连接池爆满，而这种情况后果极其严重！轻则“服务无响应”，重则前端应用直接崩溃。</p> 
<p>以上这种因为某一个节点长时间处理导致应用请求积压崩溃的现象被称为微服务的“雪崩效应”。</p> 
<p><img src="https://images2.imgbox.com/26/b9/9zH8H4Vr_o.png" alt="Drawing 3.png"></p> 
<div> 
 <p>当大量线程积压后，前端应用崩溃，雪崩效应产生</p> 
</div> 
<h5>如何有效避免雪崩效应？</h5> 
<p>刚才我们分析了雪崩效应是因为<strong>出现瞬间大流量+微服务响应慢</strong>造成的。针对这两点在架构设计时要采用不同方案。</p> 
<ul><li> <p><strong>采用限流方式进行预防</strong>：可以采用限流方案，控制请求的流入，让流量有序的进入应用，保证流量在一个可控的范围内。</p> </li><li> <p><strong>采用服务降级与熔断进行补救</strong>：针对响应慢问题，可以采用服务降级与熔断进行补救。服务降级是指当应用处理时间超过规定上限后，无论服务是否处理完成，便立即触发服务降级，响应返回预先设置的异常信息。</p> </li></ul> 
<p>这么说有些晦涩，以下图为例。在用户支付完成后，通过消息通知服务向用户邮箱发送“订单已确认”的邮件。假设消息通知服务出现异常，需要 10 秒钟才能完成发送请求， 这是不能接受的。为了预防雪崩，我们可以在微服务体系中增加服务降级的功能，预设 2 秒钟有效期，如遇延迟便最多允许 2 秒，2 秒内服务未处理完成则直接降级并返回响应，此时支付服务会收到“邮件发送超时”的错误信息。这也就意味着消息通知服务最多只有两秒钟的处理时间。处理结果，要么发送成功，要么超时降级。 因此阻塞时间缩短，产生雪崩的概率会大大降低。</p> 
<p class="te-preview-highlight"><img src="https://images2.imgbox.com/81/c4/pH0408Xi_o.png" alt="图片2.png"></p> 
<div> 
 <p>通过服务降级减少阻塞时间</p> 
</div> 
<h5>Alibaba Sentinel</h5> 
<p>有了解决问题的方案，下面咱们就可以聊聊落地实现的事情。在 Spring Cloud Alibaba 生态中有一个重要的流控组件 Sentinel。Sentinel 以流量为切入点，从<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统负载保护</strong>等多个维度保护服务的稳定性。</p> 
<p><img src="https://images2.imgbox.com/15/6d/7qaFlJee_o.png" alt="Drawing 6.png"></p> 
<div> 
 <p>Alibaba Sentinel</p> 
</div> 
<p>Sentinel 具有以下特征。</p> 
<ul><li> <p><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p> </li><li> <p><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p> </li><li> <p><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其他开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 整合只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p> </li><li> <p><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/80/dd/KQXTRYeG_o.png" alt="Drawing 8.png"></p> 
<div> 
 <p>Alibaba Sentinel特性图</p> 
</div> 
<h4>Sentinel 配置入门</h4> 
<p>Sentinel 分为两个部分：<strong>Sentinel Dashboard</strong>和<strong>Sentinel 客户端</strong>。</p> 
<ul><li> <p><strong>Sentinel Dashboard</strong>：Sentinel Dashboard 是 Sentinel 配套的可视化控制台与监控仪表盘套件，它支持节点发现，以及健康情况管理、监控（单机和集群）、规则管理和推送的功能。Sentinel Dashboard 是基于 Spring Boot 开发的 WEB 应用，打包后可以直接运行，目前最新版本为 1.8.0。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/9e/10/shpWw1BO_o.png" alt="Drawing 9.png"></p> 
<div> 
 <p>Sentinel Dashboard</p> 
</div> 
<ul><li> <p><strong>Sentinel 客户端</strong>：Sentinel 客户端需要集成在 Spring Boot 微服务应用中，用于接收来自 Dashboard 配置的各种规则，并通过 Spring MVC Interceptor 拦截器技术实现应用限流、熔断保护。</p> </li></ul> 
<h5>部署 Sentinel Dashboard（仪表盘）</h5> 
<p><strong>1</strong>. 访问：<a href="https://github.com/alibaba/Sentinel/releases?fileGuid=xxQTRXtVcqtHK6j8">https://github.com/alibaba/Sentinel/releases</a>，下载最新版 Sentinel Dashboard。</p> 
<p><img src="https://images2.imgbox.com/2c/e1/uRaODfS7_o.png" alt="Drawing 10.png"></p> 
<div> 
 <p>Sentinel Dashboard GitHub 下载页</p> 
</div> 
<p><strong>2</strong>. 利用下面的命令启动 Dashboard。</p> 
<pre><code class="language-java"><code>java -jar -Dserver.port=<span class="hljs-number">9100</span> sentinel-dashboard-<span class="hljs-number">1.8</span><span class="hljs-number">.0</span>.jar
</code></code></pre> 
<p>这个命令的含义是启动 Sentinel Dashboard 应用，Sentinel Dashboard 会监听9100端口实现与微服务的通信。同时我们可以访问下面的网址查看 Sentinel Dashboard 的UI界面。<br> <a href="http://192.168.31.10:9100?fileGuid=xxQTRXtVcqtHK6j8" rel="nofollow">http://192.168.31.10:9100</a></p> 
<p>在用户名、密码处输入 sentinel/sentinel，便可进入 Dashboard。</p> 
<p><img src="https://images2.imgbox.com/ac/13/ONn55IjZ_o.png" alt="Drawing 11.png"></p> 
<div> 
 <p>Sentinel Dashboard 登录页</p> 
</div> 
<p><img src="https://images2.imgbox.com/de/b3/ZHhY2Y1D_o.png" alt="Drawing 12.png"></p>![在这里插入图片描述](https://img-blog.csdnimg.cn/2f04129258a5466faf3e32b2aea13051.png#pic_center) 
<div> 
 <p>Sentinel Dashboard 首页</p> 
</div> 
<h5>微服务内置 Sentinel 客户端</h5> 
<p>第一步，利用 Spring Initializr 向导创建 sentinel-sample 工程，pom.xml 增加以下三项依赖。</p> 
<pre class="lang-xml"><code><span class="hljs-comment">&lt;!-- Nacos客户端Starter--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- Sentinel客户端Starter--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 对外暴露Spring Boot监控指标--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre> 
<p>第二步，配置 Nacos 与 Sentinel 客户端。</p> 
<pre class="lang-yaml"><code><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">sentinel-sample</span> <span class="hljs-comment">#应用名&amp;微服务id</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">sentinel:</span> <span class="hljs-comment">#Sentinel Dashboard通信地址</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.10</span><span class="hljs-string">:9100</span>
      <span class="hljs-attr">eager:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#取消控制台懒加载</span>
    <span class="hljs-attr">nacos:</span> <span class="hljs-comment">#Nacos通信地址</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span>
      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span>
      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span> <span class="hljs-comment">#将所有可用的监控指标项对外暴露</span>
      <span class="hljs-attr">exposure:</span> <span class="hljs-comment">#可以访问 /actuator/sentinel进行查看Sentinel监控项</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">'*'</span>
</code></pre> 
<p>第三步，验证配置。</p> 
<p>访问下面网址，在 Sentinel Dashboard 左侧看到 sentinel-sample 服务出现，则代表 Sentinel 客户端与 Dashboard 已经完成通信。</p> 
<pre><code class="language-java"><code>http:<span class="hljs-comment">//192.168.31.10:9100/</span>
</code></code></pre> 
<p><img src="https://images2.imgbox.com/60/cd/9ZtvVhLF_o.png" alt="Drawing 13.png"></p> 
<div> 
 <p>确认 sentinel-sampl e与 Dashboard 通信成功</p> 
</div> 
<p>下面咱们通过 Dashboard 配置应用的限流规则，来体验下 Sentinel 的用法。</p> 
<h4>配置限流规则</h4> 
<p>第一步，在 sentinel-sample 服务中，增加 SentinelSampleController 类，用于演示 Sentinel 限流规则。</p> 
<pre><code class="language-java"><code><span class="hljs-keyword">package</span> com.lagou.sentinelsample.controller;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentinelSampleController</span> </span>{
    <span class="hljs-meta">@GetMapping("/test_flow_rule")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testFlowRule</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"SUCCESS"</span>;
    }
}
</code></code></pre> 
<p>启动 sentinel-sample，访问<a href="http://localhost/test_flow_rule?fileGuid=xxQTRXtVcqtHK6j8" rel="nofollow">http://localhost/test_flow_rule</a>，无论刷新多少次，都会看到“SUCCESS”。</p> 
<p><img src="https://images2.imgbox.com/2f/a8/N2T4toqo_o.png" alt="Drawing 14.png"></p> 
<div> 
 <p>正常访问结果</p> 
</div> 
<p>第二步，访问 Sentinel Dashboard 配置限流规则。</p> 
<p>在左侧找到簇点链路，右侧定位到 /test_flow_rule，点击后面的“流控”按钮。</p> 
<p><img src="https://images2.imgbox.com/3f/a2/O6cZacyf_o.png" alt="Drawing 15.png"></p> 
<div> 
 <p>设置接口流控规则</p> 
</div> 
<p>在弹出界面，按下图配置，其含义为 /test_flow_rule 接口每秒钟只允许 1QPS 访问，超出的请求直接服务降级返回异常。最后点击“新增”完成规则设置。</p> 
<p><img src="https://images2.imgbox.com/a4/90/NJM6rn2U_o.png" alt="Drawing 16.png"></p> 
<div> 
 <p>设置流控规则</p> 
</div> 
<p>此时针对 /test_flow_rule 接口的流控规则已生效，可以在“流控规则”面板看到。</p> 
<p><img src="https://images2.imgbox.com/74/1e/8XNSAj34_o.png" alt="Drawing 17.png"></p> 
<div> 
 <p>现有流控规则列表</p> 
</div> 
<p>第三步，验证流控效果。</p> 
<p>重新访问<a href="http://localhost/test_flow_rule?fileGuid=xxQTRXtVcqtHK6j8" rel="nofollow">http://localhost/test_flow_rule</a>，浏览器反复刷新。</p> 
<p>第一次刷新时会出现“SUCCESS”文本代表处理成功。</p> 
<p><img src="https://images2.imgbox.com/e9/54/y3Tb8gDC_o.png" alt="Drawing 18.png"></p>![在这里插入图片描述](https://img-blog.csdnimg.cn/fea3626db92c4e3fb5436da96475a9f7.png#pic_center) 
<div> 
 <p>第一次执行成功</p> 
</div> 
<p>同一秒内再次刷新便会出现 “Blocked by Sentinel (flow limiting)”，代表服务已被限流降级。</p> 
<p><img src="https://images2.imgbox.com/2b/28/q9sRI2eD_o.png" alt="Drawing 20.png"></p> 
<div> 
 <p>第二次限流降级</p> 
</div> 
<p>到这里，我们已经利用 Sentinel 对微服务接口实施了初步的限流降级控制，Sentinel 还有很多高级的用法，我们在后面继续深入讲解。</p> 
<h4>小结与预告</h4> 
<p>这一讲我们主要对 Sentinel 进行入门学习，让你有个感性认识。本节讲解三方面内容，首先通过在工作中真实的案例分析了雪崩效应的产生与预防办法，其次介绍 Alibaba Sentinel Dashboard 与客户端的配置过程，最后演示了如何对微服务接口进行限流降级。</p> 
<p>这里我预留一道讨论题：在架构设计时，你是如何预估某个接口线上运行时的 QPS 范围呢？你可以把自己的经验写在评论中，我们一起探讨。</p> 
<p class="">下一讲，我们继续深入 Sentinel，了解 Sentinel 的高级特性与执行原理。</p> 
<hr> 
<h4><a id="11__Sentinel__623"></a>11 限流与熔断：Sentinel 在项目中的最佳实践</h4> 
<p class="">上一讲我们讲解了微服务的雪崩效应与如何基于 Sentinel 实现初步微服务限流，掌握了部署 Sentinel Dashboard与配置 Sentinel Core 客户端的技巧。本讲咱们继续 Sentinel 这个话题，将更有针对性的讲解 Sentinel 底层的细节与限流、熔断的各种配置方式。</p> 
<p>本讲咱们主要学习三方面内容：</p> 
<ul><li> <p>Sentinel 通信与降级背后的技术原理；</p> </li><li> <p>Sentinel 限流降级的规则配置；</p> </li><li> <p>Sentinel 熔断降级的规则配置。</p> </li></ul> 
<p>下面咱们先开始第一部分。</p> 
<h4>Sentinel Dashboard通信与降级原理</h4> 
<p>Sentinel Dashboard 是Sentinel的控制端，是新的限流与熔断规则的创建者。当内置在微服务内的 Sentinel Core（客户端）接收到新的限流、熔断规则后，微服务便会自动启用的相应的保护措施。</p> 
<p>按执行流程，Sentinel 的执行流程分为三个阶段：</p> 
<ol><li> <p>Sentinel Core 与 Sentinel Dashboard 建立连接；</p> </li><li> <p>Sentinel Dashboard 向 Sentinel Core 下发新的保护规则；</p> </li><li> <p>Sentinel Core 应用新的保护规则，实施限流、熔断等动作。</p> </li></ol> 
<p><strong>第一步，建立连接。</strong></p> 
<p>Sentine Core 在初始化的时候，通过 application.yml 参数中指定的 Dashboard 的 IP地址，会主动向 dashboard 发起连接的请求。</p> 
<pre class="lang-yaml"><code><span class="hljs-comment">#Sentinel Dashboard通信地址</span>
<span class="hljs-attr">spring:</span> 
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">sentinel:</span> 
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.10</span><span class="hljs-string">:9100</span>
</code></pre> 
<p>该请求是以心跳包的方式定时向 Dashboard 发送，包含 Sentinel Core 的 AppName、IP、端口信息。这里有个重要细节：Sentinel Core为了能够持续接收到来自 Dashboard的数据，会在微服务实例设备上监听 8719 端口，在心跳包上报时也是上报这个 8719 端口，而非微服务本身的 80 端口。</p> 
<p class=""><img src="https://images2.imgbox.com/62/26/LSD4BgPO_o.png" alt="图片1.png"></p> 
<div> 
 <p>Sentinel Core 向 Dashboard 建立连接</p> 
</div> 
<p class="">在 Sentinel Dashboard 接收到心跳包后，来自 Sentinel Core的AppName、IP、端口信息会被封装为 MachineInfo 对象放入 ConcurrentHashMap 保存在 JVM的内存中，以备后续使用。</p> 
<p><strong>第二步，推送新规则。</strong></p> 
<p>如果在 Dashboard 页面中设置了新的保护规则，会先从当前的 MachineInfo 中提取符合要求的微服务实例信息，之后通过 Dashboard内置的 transport 模块将新规则打包推送到微服务实例的 Sentinel Core，Sentinel Core收 到新规则在微服务应用中对本地规则进行更新，这些新规则会保存在微服务实例的 JVM 内存中。</p> 
<p class=""><img src="https://images2.imgbox.com/a3/16/2BYN4dkR_o.png" alt="图片22.png"></p> 
<div> 
 <p>Sentinel Dashboard 向Sentinel Core推送新规则</p> 
</div> 
<p><strong>第三步，处理请求。</strong></p> 
<p>Sentinel Core 为服务限流、熔断提供了核心拦截器 SentinelWebInterceptor，这个拦截器默认对所有请求 /** 进行拦截，然后开始请求的链式处理流程，在对于每一个处理请求的节点被称为 Slot（槽），通过多个槽的连接形成处理链，在请求的流转过程中，如果有任何一个 Slot 验证未通过，都会产生 BlockException，请求处理链便会中断，并返回“Blocked by sentinel" 异常信息。</p> 
<p class=""><img src="https://images2.imgbox.com/c6/08/qpQjrGta_o.png" alt="图片2.png"></p> 
<div> 
 <p>SentinelWebInterceptor 实施请求拦截与保护</p> 
</div> 
<p>那这些 Slot 都有什么作用呢？我们需要了解一下，默认 Slot 有7 个，前 3 个 Slot为前置处理，用于收集、统计、分析必要的数据；后 4 个为规则校验 Slot，从Dashboard 推送的新规则保存在“规则池”中，然后对应 Slot 进行读取并校验当前请求是否允许放行，允许放行则送入下一个 Slot 直到最终被 RestController 进行业务处理，不允许放行则直接抛出 BlockException 返回响应。</p> 
<p>以下是每一个 Slot 的具体职责：</p> 
<ul><li> <p>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</p> </li><li> <p>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT（运行时间）, QPS, thread count（线程总数）等，这些信息将用作为多维度限流，降级的依据；</p> </li><li> <p>StatistcSlot 则用于记录，统计不同维度的runtime 信息；</p> </li><li> <p>SystemSlot 则通过系统的状态，例如CPU、内存的情况，来控制总的入口流量；</p> </li><li> <p>AuthoritySlot 则根据黑白名单，来做黑白名单控制；</p> </li><li> <p>FlowSlot 则用于根据预设的限流规则，以及前面 slot 统计的状态，来进行限流；</p> </li><li> <p>DegradeSlot 则通过统计信息，以及预设的规则，来做熔断降级。</p> </li></ul> 
<p>到这里我们理解了 Sentinel 通信与降级背后的执行过程，下面咱们学习如何有效配置 Sentinel 的限流策略。</p> 
<h4>Sentinel 限流降级的规则配置</h4> 
<h5>滑动窗口算法</h5> 
<p>实现限流降级的核心是如何统计单位时间某个接口的访问量，常见的算法有计数器算法、令牌桶算法、漏桶算法、滑动窗口算法。Sentinel 采用滑动窗口算法来统计访问量。</p> 
<p>滑动窗口算法并不复杂，咱们举例说明：某应用限流控制 1 分钟最多允许 600 次访问。采用滑动窗口算法是将每 1 分钟拆分为 6（变量）个等份时间段，每个时间段为 10 秒，6 个时间段为 1 组在下图用红色边框区域标出，而这个红色边框区域就是滑动窗口。当每产生 1 个访问在对应时间段的计数器自增加 1，当滑动窗口内所有时间段的计数器总和超过 600，后面新的访问将被限流直接拒绝。同时每过 10 秒，滑动窗口向右移动，前面的过期时间段计数器将被作废。</p> 
<p>总结下，滑动窗口算法的理念是将整段时间均分后独立计数再汇总统计，滑动窗口算法被广泛应用在各种流控场景中，请你理解它的实现过程。</p> 
<p class=""><img src="https://images2.imgbox.com/c4/f1/yAsNhkRl_o.png" alt="图片4.png"></p> 
<div> 
 <p>滑动窗口算法</p> 
</div> 
<h5>基于 Sentinel Dashboard 的限流设置</h5> 
<p>在 Sentinel Dashboard 中“簇点链路”,找到需要限流的 URI，点击“+流控”进入流控设置。小提示，sentinel-dashboard 基于懒加载模式，如果在簇点链路没有找到对应的 URI，需要先访问下这个功能的功能后对应的 URI 便会出现。</p> 
<p class=""><img src="https://images2.imgbox.com/40/9a/rtOXOfsz_o.png" alt="图片5.png"></p> 
<div> 
 <p>流控设置界面</p> 
</div> 
<p>流控规则项目说明主要有以下几点。</p> 
<ul><li> <p>资源名：要流控的 URI，在 Sentinel 中 URI 被称为“资源”；</p> </li><li> <p>针对来源：默认 default 代表所有来源，可以针对某个微服务或者调用者单独设置；</p> </li><li> <p>阈值类型：是按每秒访问数量（QPS）还是并发数（线程数）进行流控；</p> </li><li> <p>单机阈值：具体限流的数值是多少。</p> </li></ul> 
<p class=""><img src="https://images2.imgbox.com/9b/14/EweMXAAz_o.png" alt="图片6.png"></p> 
<div> 
 <p>默认流控规则</p> 
</div> 
<p>点击对话框中的“高级选项”，就会出现更为详细的设置项。</p> 
<p>其中流控模式是指采用什么方式进行流量控制。Sentinel支持三种模式：直接、关联、链路，下面咱们分别讲解这三种模式。</p> 
<ul><li> <p><strong>直接模式：</strong></p> </li></ul> 
<p>以下图为例，当 List 接口 QPS 超过 1个时限流，浏览器会出现“Blocked by Sentinel”。</p> 
<p class=""><img src="https://images2.imgbox.com/45/ab/f1hoETx2_o.png" alt="图片7.png"></p> 
<div> 
 <p>流控模式-直接</p> 
</div> 
<ul><li> <p><strong>关联模式：</strong></p> </li></ul> 
<p>如下图所示，当同 List 接口关联的update 接口 QPS 超过 1 时，再次访问List 接口便会响应“Blocked by Sentinel”。</p> 
<p class=""><img src="https://images2.imgbox.com/4e/ee/RR29oZp2_o.png" alt="图片8.png"></p> 
<div> 
 <p>流控模式-关联</p> 
</div> 
<ul><li> <p><strong>链路模式：</strong></p> </li></ul> 
<p>链路模式相对复杂，我们举例说明，现在某公司开发了一个单机的电商系统，为了满足完成“下订单”的业务，程序代码会依次执行<strong>订单创建方法-&gt;减少库存方法-&gt;微信支付方法-&gt;短信发送</strong>方法。方法像链条一样从前向后依次执行，这种执行的链条被称为调用链路，而链路模式限流就是为此而生。</p> 
<p>以下图为例，在某个微服务中 List 接口，会被 Check 接口调用。在另一个业务，List 接口也会被 Scan 接口调用。</p> 
<p class=""><img src="https://images2.imgbox.com/5c/0a/Qwrmjvkn_o.png" alt="图片99.png"></p> 
<div> 
 <p>调用链路</p> 
</div> 
<p>但如果按下图配置，将入口资源设为“/check”，则只会针对 check 接口的调用链路生效。当访问 check 接口的QPS 超过 1 时，List 接口就会被限流。而另一条链路从 scan 接口到List 接口的链路则不会受到任何影响。链路模式与关联模式最大的区别是 check 接口与 List 接口必须是在同一个调用链路中才会限流，而关联模式是任意两个资源只要设置关联就可以进行限流。</p> 
<p class=""><img src="https://images2.imgbox.com/05/6e/aMo2XflJ_o.png" alt="图片9.png"></p> 
<div> 
 <p>流控模式-链路</p> 
</div> 
<p>讲完了直接、关联、链路三种流控模式，下面咱们聊一聊高级选项中的“流控效果”。</p> 
<p>流控效果是指在达到流控条件后，对当前请求如何进行处理。流控效果有三种：<strong>快速失败</strong>、<strong>Warm UP（预热）</strong>、<strong>排队等待</strong>。</p> 
<ul><li> <p><strong>快速失败：</strong></p> </li></ul> 
<p>快速失败是指流浪当过限流阈值后，直接返回响应并抛出 BlockException，快速失败是最常用的处理形式。如下图所示，当 List 接口每秒 QPS 超过 1 时，可以直接抛出“Blocked By Sentinel”异常。</p> 
<p class=""><img src="https://images2.imgbox.com/e4/f0/Fqs3bE5E_o.png" alt="图片11.png"></p> 
<div> 
 <p>流控效果-快速失败</p> 
</div> 
<ul><li> <p><strong>Warm Up（预热）：</strong></p> </li></ul> 
<p>Warm Up 用于应对瞬时大并发流量冲击。当遇到突发大流量 Warm Up 会缓慢拉升阈值限制，预防系统瞬时崩溃，这期间超出阈值的访问处于队列等待状态，并不会立即抛出 BlockException。</p> 
<p>如下图所示，List 接口平时单机阈值 QPS 处于低水位：默认为 1000/3 (冷加载因子)≈333，当瞬时大流量进来，10 秒钟内将 QPS 阈值逐渐拉升至 1000，为系统留出缓冲时间，预防突发性系统崩溃。</p> 
<p class=""><img src="https://images2.imgbox.com/ce/a4/adutChRf_o.png" alt="图片12.png"></p> 
<div> 
 <p>流控效果-Warm Up</p> 
</div> 
<ul><li> <p><strong>排队等待：</strong></p> </li></ul> 
<p>排队等待是采用匀速放行的方式对请求进行处理。如下所示，假设现在有100个请求瞬间进入，那么会出现以下几种情况：</p> 
<ol><li> <p>单机 QPS 阈值=1，代表每 1 秒只能放行 1 个请求，其他请求队列等待，共需 100 秒处理完毕；</p> </li><li> <p>单机 QPS 阈值=4，代表 250 毫秒匀速放行 1 个请求，其他请求队列等待，共需 25 秒处理完毕；</p> </li><li> <p>单机 QPS 阈值=200，代表 5 毫秒匀速放行一个请求，其他请求队列等待，共需 0.5 秒处理完毕；</p> </li><li> <p>如果某一个请求在队列中处于等待状态超过 2000 毫秒，则直接抛出 BlockException。</p> </li></ol> 
<p>注意，匀速队列只支持 QPS 模式，且单机阈值不得大于 1000。</p> 
<p class=""><img src="https://images2.imgbox.com/43/46/NlpZcY7q_o.png" alt="图片13.png"></p> 
<div> 
 <p>流控效果-排队等待</p> 
</div> 
<p>讲到这，我为你讲解了从滑动窗口统计流量到 Sentinel Dashboard 如何进行流控配置。下面咱们再来讲解 Sentinel的熔断降级策略。</p> 
<h4>Sentinel 熔断降级的规则配置</h4> 
<h5>什么是熔断？</h5> 
<p>先说现实中的股市熔断机制。2016 年 1 月 4 日，A 股遇到史上首次熔断，沪指开盘后跌幅超过 5%，直接引发熔断。三家股市交易所暂停交易15分钟，但恢复交易之后股市继续下跌，三大股市交易所暂停交易至闭市。通过现象可以看<strong>出熔断是一种保护机制</strong>，当事物的状态达到某种“不可接受”的情况时，便会触发“熔断”。在股市中，熔断条件就是大盘跌幅超过 5%，而熔断的措施便是强制停止交易 15 分钟，之后尝试恢复交易，如仍出现继续下跌，便会再次触发熔断直接闭市。但假设 15分钟后，大盘出现回涨，便认为事故解除继续正常交易。这是现实生活中的熔断，如果放在软件中也是一样的。</p> 
<p>微服务的熔断是指在某个服务接口在执行过程中频繁出现故障的情况，我们便认为这种状态是“不可接受”的，立即对当前接口实施熔断。在规定的时间内，所有送达该接口的请求都将直接抛出 BlockException，在熔断期过后新的请求进入看接口是否恢复正常，恢复正常则继续运行，仍出现故障则再次熔断一段时间，以此往复直到服务接口恢复。</p> 
<p>下图清晰的说明了 Sentinel的熔断过程：</p> 
<ol><li> <p>设置熔断的触发条件，当某接口超过20%的请求访问出现故障，便启动熔断；</p> </li><li> <p>在熔断状态下，若干秒内所有该接口的请求访问都会直接抛出BlockException拒绝访问。</p> </li><li> <p>熔断器过后，下一次请求重新访问接口，当前接口为“半开状态”，后续处理以下分两种情况。</p> </li></ol> 
<ul><li> <p>当前请求被有效处理，接口恢复到正常状态。</p> </li><li> <p>当前请求访问出现故障，接口继续熔断。</p> </li></ul> 
<p class=""><img src="https://images2.imgbox.com/6d/4f/Or3EkmmY_o.png" alt="图片14.png"></p> 
<div> 
 <p>Sentinel 熔断机制</p> 
</div> 
<h5><strong>基于SentinelDashboard的熔断设置</strong></h5> 
<p>Sentinel Dashboard可以设置三种不同的熔断模式：慢调用比例、异常比例、异常数，下面我们分别讲解：</p> 
<ul><li> <p>慢调用比例是指当接口在1秒内“慢处理”数量超过一定比例，则触发熔断。</p> </li></ul> 
<p class=""><img src="https://images2.imgbox.com/b8/25/yk1GbWGZ_o.png" alt="图片15.png"></p> 
<div> 
 <p>熔断模式-慢调用比例</p> 
</div> 
<p>结合上图的设置，介绍下“慢调用比例”熔断规则。</p> 
<p class=""><img src="https://images2.imgbox.com/ef/21/tLpoJCMW_o.png" alt="图片18.png"></p> 
<ul><li> <p>异常比例是指 1 秒内按接口调用产生异常的比例（异常调用数/总数量）触发熔断。</p> </li></ul> 
<p class=""><img src="https://images2.imgbox.com/63/63/kn1mXajC_o.png" alt="图片16.png"></p> 
<div> 
 <p>熔断模式-异常比例</p> 
</div> 
<p>结合上图的设置，介绍下“异常比例”熔断规则。</p> 
<p class=""><img src="https://images2.imgbox.com/a7/08/t4x59CWZ_o.png" alt="图片19.png"></p> 
<ul><li> <p>异常数是指在 1 分钟内异常的数量超过阈值则触发熔断。</p> </li></ul> 
<p class=""><img src="https://images2.imgbox.com/6a/4d/dXGCdKNC_o.png" alt="图片17.png"></p> 
<div> 
 <p>熔断模式-异常数</p> 
</div> 
<p>结合上图的设置，介绍下“异常数”熔断规则。</p> 
<p class="te-preview-highlight"><img src="https://images2.imgbox.com/2c/31/JmjDe314_o.png" alt="图片20.png"></p> 
<p>以上就是三种熔断模式的介绍，熔断相对流控配置比较简单，只需要设置熔断检查开启条件与触发熔断条件即可。讲到这关于限流与熔断的配置暂时告一段落，下面对本讲内容进行下总结。</p> 
<h4>小结与预告</h4> 
<p>本讲咱们介绍了三部分内容，第一部分讲解了 Sentinel Dashboard 与 Sentinel Core的通信机制与执行原理，了解 Sentinel Core 是通过拦截器实现了限流与熔断；第二部分讲解了滑动窗口算法与 Dashboard 流控配置的每一种情况；第三部分讲解了熔断机制与 Dashboard 的熔断配置。</p> 
<p>这里留一个讨论话题：假如你遇到像春运 12306 热门车次购票这种高并发场景，为了保证应用的稳定和用户的体验，我们要采取哪些措施呢？可以把你的经验写在评论中，咱们一起探讨。</p> 
<p class="">下一讲，将进入生产集群保护这个话题，看 Sentinel 是如何对整个服务集群实施保护的。</p> 
<hr>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/14cc7f222ed489df2f7f8134d9b2f0d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu 20.04下配置 HAL 汇编开发环境教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ccd3d633cc6e872d7aa0684f15e2e939/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL入门之第八讲——UPDATE更新语句</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>