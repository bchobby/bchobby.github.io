<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【RabbitMQ】RabbitMQ 消息的可靠性 —— 生产者和消费者消息的确认，消息的持久化以及消费失败的重试机制 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【RabbitMQ】RabbitMQ 消息的可靠性 —— 生产者和消费者消息的确认，消息的持久化以及消费失败的重试机制" />
<meta property="og:description" content="文章目录 前言：消息的可靠性问题一、生产者消息的确认1.1 生产者确认机制1.2 实现生产者消息的确认1.3 验证生产者消息的确认 二、消息的持久化2.1 演示消息的丢失2.2 声明持久化的交换机和队列2.3 发送持久化的消息 三、消费者消息的确认3.1 配置消费者消息确认3.2 演示 none 模式3.3 演示 auto 模式 四、消息消费失败的重试机制4.1 本地重试机制4.2 失败消息的处理策略 前言：消息的可靠性问题 在现代分布式应用程序中，消息队列扮演了至关重要的角色，允许系统中的各个组件之间进行异步通信。这种通信模式提供了高度的灵活性和可伸缩性，但也引入了一系列的挑战，其中最重要的之一是消息的可靠性。
首先让我们来了解一下，在消息队列中，消息从生产者发送到交换机，再到队列，最后到消费者，有哪些情况会导致消息的丢失？
发送时丢失：
生产者发送的消息未送达交换机；消息到达交换机后未到达队列； MQ 宕机，队列中的消息会丢失；
消费者接收到消息后未消费就宕机了。
确保消息队列的可靠性是分布式系统中不可或缺的一部分，因此我们需要采取措施来应对这些挑战。为了解决上述消息可靠性问题，RabbitMQ提供了一系列的机制和最佳实践，以确保消息在整个传递过程中得到妥善处理和保护。
本文将深入探讨如何应对这些挑战，介绍消息队列中的关键概念，并详细讨论 RabbitMQ 提供的解决方案，包括生产者消息的确认、消息的持久化、消费者消息的确认以及消息消费失败的重试机制。这些措施将有助于确保消息队列在应用程序中的可靠性和稳定性。
一、生产者消息的确认 1.1 生产者确认机制 RabbitMQ 提供了 publisher confirm 机制，这是一种用于解决消息发送过程中可能出现的丢失问题的机制。当消息发送到 RabbitMQ 后，系统会返回一个结果给消息的发送者，以指示消息的处理状态。这个结果有两种可能的值：
publisher-confirm，发送者确认：
消息成功投递到交换机，系统返回 ack（确认）。消息未能成功投递到交换机，系统返回 nack（未确认）。 publisher-return，发送者回执：
消息成功投递到交换机，但是没有成功路由到队列，系统返回 ACK，同时提供路由失败的原因。 这个确认机制的目的是确保消息在发送到消息队列后，发送者能够获得有关消息处理状态的明确反馈，从而可以采取适当的措施，例如重发消息或记录失败信息。
需要注意的是，为了实现这一机制，需要为每条消息设置一个全局唯一的标识符，以便区分不同的消息，避免在确认过程中出现冲突。
例如下图所示：
确保消息生产者能够获得有关消息状态的反馈是确保消息可靠性的关键一步，因为它有助于解决消息可能在发送期间丢失的问题。这是构建可靠的消息队列系统中的重要组成部分。
1.2 实现生产者消息的确认 下面将通过一个 Java 的 Spring Boot 项目来演示如何实现生产者消息的确认。这个项目的结构如下：
这个项目有两个模块，其中 consumer 负责对消息的消费，而 publisher 负责发送消息。下面是在 publisher 模块中实现消息确认的具体步骤：
在 publisher 服务中的 application." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4a89c8a0225febebb018429a9624cc66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-04T12:41:52+08:00" />
<meta property="article:modified_time" content="2023-11-04T12:41:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【RabbitMQ】RabbitMQ 消息的可靠性 —— 生产者和消费者消息的确认，消息的持久化以及消费失败的重试机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">前言：消息的可靠性问题</a></li><li><a href="#_24" rel="nofollow">一、生产者消息的确认</a></li><li><ul><li><a href="#11__26" rel="nofollow">1.1 生产者确认机制</a></li><li><a href="#12__46" rel="nofollow">1.2 实现生产者消息的确认</a></li><li><a href="#13__154" rel="nofollow">1.3 验证生产者消息的确认</a></li></ul> 
  </li><li><a href="#_182" rel="nofollow">二、消息的持久化</a></li><li><ul><li><a href="#21__185" rel="nofollow">2.1 演示消息的丢失</a></li><li><a href="#22__205" rel="nofollow">2.2 声明持久化的交换机和队列</a></li><li><a href="#23__251" rel="nofollow">2.3 发送持久化的消息</a></li></ul> 
  </li><li><a href="#_276" rel="nofollow">三、消费者消息的确认</a></li><li><ul><li><a href="#31__277" rel="nofollow">3.1 配置消费者消息确认</a></li><li><a href="#32__none__296" rel="nofollow">3.2 演示 none 模式</a></li><li><a href="#33__auto__327" rel="nofollow">3.3 演示 auto 模式</a></li></ul> 
  </li><li><a href="#_346" rel="nofollow">四、消息消费失败的重试机制</a></li><li><ul><li><a href="#41__348" rel="nofollow">4.1 本地重试机制</a></li><li><a href="#42__376" rel="nofollow">4.2 失败消息的处理策略</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>前言：消息的可靠性问题</h2> 
<p>在现代分布式应用程序中，消息队列扮演了至关重要的角色，允许系统中的各个组件之间进行异步通信。这种通信模式提供了高度的灵活性和可伸缩性，但也引入了一系列的挑战，其中最重要的之一是消息的可靠性。</p> 
<p>首先让我们来了解一下，在消息队列中，消息从生产者发送到交换机，再到队列，最后到消费者，有哪些情况会导致消息的丢失？</p> 
<ul><li> <p>发送时丢失：</p> 
  <ul><li>生产者发送的消息未送达交换机；</li><li>消息到达交换机后未到达队列；</li></ul> </li><li> <p>MQ 宕机，队列中的消息会丢失；</p> </li><li> <p>消费者接收到消息后未消费就宕机了。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/39/02/tjJXduG3_o.png" alt="">确保消息队列的可靠性是分布式系统中不可或缺的一部分，因此我们需要采取措施来应对这些挑战。为了解决上述消息可靠性问题，RabbitMQ提供了一系列的机制和最佳实践，以确保消息在整个传递过程中得到妥善处理和保护。</p> 
<p>本文将深入探讨如何应对这些挑战，介绍消息队列中的关键概念，并详细讨论 RabbitMQ 提供的解决方案，包括生产者消息的确认、消息的持久化、消费者消息的确认以及消息消费失败的重试机制。这些措施将有助于确保消息队列在应用程序中的可靠性和稳定性。</p> 
<h2><a id="_24"></a>一、生产者消息的确认</h2> 
<h3><a id="11__26"></a>1.1 生产者确认机制</h3> 
<p>RabbitMQ 提供了 <code>publisher confirm</code> 机制，这是一种用于解决消息发送过程中可能出现的丢失问题的机制。当消息发送到 RabbitMQ 后，系统会返回一个结果给消息的发送者，以指示消息的处理状态。这个结果有两种可能的值：</p> 
<ul><li> <p><strong>publisher-confirm，发送者确认：</strong></p> 
  <ul><li>消息成功投递到交换机，系统返回 <code>ack</code>（确认）。</li><li>消息未能成功投递到交换机，系统返回 <code>nack</code>（未确认）。</li></ul> </li><li> <p><strong>publisher-return，发送者回执：</strong></p> 
  <ul><li>消息成功投递到交换机，但是没有成功路由到队列，系统返回 <code>ACK</code>，同时提供路由失败的原因。</li></ul> </li></ul> 
<p>这个确认机制的目的是确保消息在发送到消息队列后，发送者能够获得有关消息处理状态的明确反馈，从而可以采取适当的措施，例如重发消息或记录失败信息。</p> 
<p><code>需要注意的是，为了实现这一机制，需要为每条消息设置一个全局唯一的标识符，以便区分不同的消息，避免在确认过程中出现冲突。</code></p> 
<p><strong>例如下图所示：</strong><br> <img src="https://images2.imgbox.com/a6/70/8KjasBGU_o.png" alt="示例图"></p> 
<p>确保消息生产者能够获得有关消息状态的反馈是确保消息可靠性的关键一步，因为它有助于解决消息可能在发送期间丢失的问题。这是构建可靠的消息队列系统中的重要组成部分。</p> 
<h3><a id="12__46"></a>1.2 实现生产者消息的确认</h3> 
<p>下面将通过一个 Java 的 Spring Boot 项目来演示如何实现生产者消息的确认。这个项目的结构如下：</p> 
<p><img src="https://images2.imgbox.com/58/f4/vFy8Lez0_o.png" alt=""><br> 这个项目有两个模块，其中 <code>consumer</code> 负责对消息的消费，而 <code>publisher</code> 负责发送消息。下面是在 <code>publisher</code> 模块中实现消息确认的具体步骤：</p> 
<ol><li>在 <code>publisher</code> 服务中的 <code>application.yml</code> 文件中添加如下配置：</li></ol> 
<pre><code class="prism language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> correlated
    <span class="token key atrule">publisher-returns</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">template</span><span class="token punctuation">:</span>
      <span class="token key atrule">mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre> 
<p>对这个配置的详细说明：</p> 
<ul><li><code>publish-confirm-type</code>：开启 <code>publisher-confirm</code> 功能，这里支持两种类型： 
  <ul><li><code>simple</code>：同步等待 <code>confirm</code> 结果，直到超时；</li><li><code>correlated</code>：异步回调，定义<code>ConfirmCallback</code>，MQ返回结果时会回调这个 <code>ConfirmCallback</code>。</li></ul> </li><li><code>publish-returns</code>：开启 <code>publish-return</code> 功能，同样是基于 <code>callback</code> 机制，不过是定义 <code>ReturnCallback</code>；</li><li><code>template.mandatory</code>：定义消息路由失败时的策略。<code>true</code>，则调用 <code>ReturnCallback</code>；<code>false</code>，则直接丢弃消息。</li></ul> 
<ol start="2"><li>给 <code>RabbitTemplate</code> 配置 <code>ReturnCallback</code>：</li></ol> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取 RabbitTemplate 对象</span>
        <span class="token class-name">RabbitTemplate</span> rabbitTemplate <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 配置 ReturnCallBack</span>
        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> replyCode<span class="token punctuation">,</span> replyText<span class="token punctuation">,</span> exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 记录日志</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息发送到队列失败，响应码：{}，失败原因：{}，交换机：{}，路由 Key：{}，消息：{}"</span><span class="token punctuation">,</span>
                    replyCode<span class="token punctuation">,</span> replyText<span class="token punctuation">,</span> exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果有需要，接下来可以重发消息，或者执行其他通知逻辑</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于每个 <code>RabbitTemplate</code> 只能配置一个 <code>ReturnCallback</code>，并且 <code>RabbitTemplate </code> 在Spring 中是一个全局对象，因此需要在项目启动过程中配置。</p> 
<p>上述代码就是一个 Spring Boot 的配置类，通常用于在项目启动时配置一些全局的设置。在这个配置类中，实现了 <code>ApplicationContextAware</code> 接口，用于获取 Spring 应用上下文（<code>ApplicationContext</code>）对象。主要作用是配置 RabbitMQ 的 <code>ReturnCallback</code>，以处理消息发送到队列失败的情况。</p> 
<ol start="3"><li>发送消息，指定消息的 ID以及消息的 <code>ConfirmCallback</code></li></ol> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage2SimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">String</span> routingKey <span class="token operator">=</span> <span class="token string">"simple.test"</span><span class="token punctuation">;</span>
    <span class="token comment">// 1. 准备消息</span>
    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 准备 CorrelationDate</span>
    <span class="token comment">// 2.1.消息ID</span>
    <span class="token class-name">CorrelationData</span> correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.2.准备 ConfirmCallback</span>
    correlationData<span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>confirm <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 消息发送成功</span>
        <span class="token comment">// 判断结果</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>confirm <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> confirm<span class="token punctuation">.</span><span class="token function">isAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// ACK</span>
            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"消息投递到交换机成功！消息 ID: {}"</span><span class="token punctuation">,</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// NACK</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息投递到交换机失败！消息 ID: {}"</span><span class="token punctuation">,</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> throwable <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 发送失败</span>
        <span class="token comment">// 记录日志</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息发送失败！"</span><span class="token punctuation">,</span> throwable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 重发消息...</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3. 发送消息</span>
    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"amq.topic"</span><span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> message<span class="token punctuation">,</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这是一个 Java 测试方法，用于发送消息到 RabbitMQ 队列，并指定消息的 ID 以及 <code>ConfirmCallback</code>（确认回调）。以下是对这段代码的详细解释：</p> 
<ol><li> <p><code>testSendMessage2SimpleQueue</code>: 这是一个测试方法，用于演示如何发送消息到名为 “simple.test” 的 RabbitMQ 队列。</p> </li><li> <p><code>String routingKey = "simple.test";</code>: 定义了消息的路由键，这是用于将消息路由到特定队列的关键。</p> </li><li> <p>准备消息：将要发送的消息内容存储在 <code>message</code> 变量中。</p> </li><li> <p>准备 <code>CorrelationData</code>：</p> 
  <ul><li><code>CorrelationData</code> 用于关联消息的 ID。</li><li>使用 <code>UUID.randomUUID().toString()</code> 生成一个全局唯一的消息 ID。</li></ul> </li><li> <p>准备 <code>ConfirmCallback</code>：</p> 
  <ul><li><code>CorrelationData.getFuture().addCallback(confirm -&gt; { ... }, throwable -&gt; { ... })</code> 定义了 <code>ConfirmCallback</code>，该回调会在消息的发送状态发生变化时触发。</li><li>在 <code>ConfirmCallback</code> 中，判断了消息是否成功投递到交换机： 
    <ul><li>如果 <code>confirm</code> 不为 null 且 <code>confirm.isAck()</code> 为 <code>true</code>，则表示消息成功到达交换机，记录一条成功的日志。</li><li>否则，如果消息未成功到达交换机，则记录一条失败的日志。</li></ul> </li><li>在 <code>throwable</code> 回调中，处理了发送失败的情况，记录了失败的日志，可以在这里添加重发消息或其他失败处理逻辑。</li></ul> </li><li> <p>发送消息：</p> 
  <ul><li>使用 <code>rabbitTemplate.convertAndSend("amq.topic", routingKey, message, correlationData);</code> 发送消息到 RabbitMQ。</li><li>参数包括交换机名称、路由键、消息内容和关联的 <code>CorrelationData</code>。</li></ul> </li></ol> 
<p>这段代码演示了如何发送消息并在消息状态变化时使用 <code>ConfirmCallback</code> 处理消息的确认情况。通过关联消息 ID 和 <code>ConfirmCallback</code>，可以确保消息的可靠性，根据确认情况采取适当的措施。</p> 
<h3><a id="13__154"></a>1.3 验证生产者消息的确认</h3> 
<p><strong>下面通过可以运行上述测试代码来查看生产者的消息确认情况：</strong></p> 
<ol><li>正常发送消息</li></ol> 
<p>直接执行测试方法，可以发现消息成功投递到交换机：<br> <img src="https://images2.imgbox.com/5d/e3/CHR2kalI_o.png" alt=""></p> 
<ol start="2"><li>发送消息失败</li></ol> 
<p>此时，将交换机的名称改成一个错误不存在的：<br> <img src="https://images2.imgbox.com/1f/55/KQehyBLP_o.png" alt="">然后再次执行测试方法：<br> <img src="https://images2.imgbox.com/40/fe/F7O1w21T_o.png" alt=""><br> 发现此时消息投递到交换机失败，说明此时返回的是 <code>NACK</code>，并且提示了错误的原因是找不到名为 <code>aamq.topic</code>的交换机。</p> 
<ol start="3"><li>成功发送消息，但是路由失败</li></ol> 
<p>此时将交换机的名称修改回来，但是将路由 Key 修改成错误的：</p> 
<p><img src="https://images2.imgbox.com/cd/a2/ugxGLsxi_o.png" alt=""><br> 然后执行测试方法：</p> 
<p><img src="https://images2.imgbox.com/34/a6/USu8PxAc_o.png" alt="">通过输出的日志可以发现，消息成功投递到了交换机，但是由于路由 Key 不正确，导致路由不到 <code>simple,queue</code>，从而触发调用了上文配置的<code>ReturnCallback</code>。</p> 
<h2><a id="_182"></a>二、消息的持久化</h2> 
<p>在通过上文的生产者消息确认机制之后，确保了消息能够正确的发送到队列中，但是这并不意味着消息就安全了。因为 RabbitMQ 默认是内存储存的，如果出现了 RabbitMQ 宕机的情况，那么此时队列中的消息还是会丢失。要确保消息能够真正的安全，我们还需要实现消息的持久化。</p> 
<h3><a id="21__185"></a>2.1 演示消息的丢失</h3> 
<p>例如，现在 <code>simple.queue</code> 中存在 3 条消息：<br> <img src="https://images2.imgbox.com/d4/3d/LFdgOuHf_o.png" alt=""><br> 这些消息是通过 RabbitMQ 自带的交换机 <code>amp.topic</code> 进行转发的：<br> <img src="https://images2.imgbox.com/9b/54/uDIwjZne_o.png" alt=""></p> 
<p>然后我们重启一下 RabbitMQ 服务，看一看队列中的消息是否还存在：</p> 
<p><img src="https://images2.imgbox.com/5a/b8/ppMO9hxp_o.png" alt=""><br> 此时我们重新服务 RabbitMQ 的控制台，发现连 <code>simple.queue</code> 都消失了：<br> <img src="https://images2.imgbox.com/f0/b9/ITBz7Gyn_o.png" alt=""><br> 但是RabbitMQ自带的 <code>amp.topic</code> 交换机还存在：</p> 
<p><img src="https://images2.imgbox.com/9c/81/ijUs1TOC_o.png" alt=""> 说明，这个交换机是持久化储存的，如果仔细观察可以发现，这些所有的交换机的 <code>Features</code> 都带有一个 <code>D</code> ，即持久化 Durable。</p> 
<p>因此要让我们自己创建的队列或者交换机也能持久存在，就可以否选上 Durable 这个选项：</p> 
<p><img src="https://images2.imgbox.com/70/b7/Xoc861Z6_o.png" alt=""></p> 
<h3><a id="22__205"></a>2.2 声明持久化的交换机和队列</h3> 
<p>通过上文我们知道了可以在 RabbitMQ 的控制台创建交换机和队列的时候可以勾选 Durable 来达到持久化的目的，但是如果使用代码来创建持久化的交换机和队列呢？下面我将使用 Java 代码来演示这个过程：</p> 
<p>由于消费者<code>comsumer</code>在启动的时候可以帮我们创建交换机和队列，因此将交换机和队列的声明交给 <code>consumer</code> 来完成。</p> 
<ol><li>声明持久化的交换机</li></ol> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonConfig</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">simpleDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// DirectExchange的构造方法有三个参数：交换机名称、是否持久化、当没有 queue 与其绑定时是否自动删除</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"simple.direct"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>声明持久化的队列持久化</li></ol> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonConfig</span> <span class="token punctuation">{<!-- --></span>

		<span class="token comment">// ...</span>
		
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">simpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用QueueBuilder构建队列，其中使用 durable 方法就是持久化的</span>
        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当完成了上面两步之后，我们可以启动 <code>consumer</code> 服务：</p> 
<p><img src="https://images2.imgbox.com/93/ff/NZRs8oMS_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/fc/27/AzFs0rjJ_o.png" alt=""><br> 此时，我们发现成功创建了<code>simple.direct</code>交换机和 <code>simple.queue</code> 队列，并且它们都是持久的。然后停止<code>consumer</code> 服务，在 RabbitMQ 的控制台中向 <code>simple.queue</code> 添加一条消息：</p> 
<p><img src="https://images2.imgbox.com/09/13/CYh6WavO_o.png" alt=""><br> 然后再次重启 RabbitMQ 服务，发现刚才创建的交换机和队列都还在，但是消息却没有了：<br> <img src="https://images2.imgbox.com/df/36/EVC2aTsJ_o.png" alt="">因为我刚才添加的是非持久化的消息：<br> <img src="https://images2.imgbox.com/ee/36/u25vSZCQ_o.png" alt=""></p> 
<h3><a id="23__251"></a>2.3 发送持久化的消息</h3> 
<p>同样，在控制台添加消息的时候可以设置消息的持久化和非持久化，下面让我来演示然后在使用 Java 代码发送持久化的消息：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDurableMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1. 准备消息</span>
    <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">"hello, simple.queue"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 发送消息</span>
    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在发送持久化的消息需要使用<code>MessageBuilder</code>来构建消息，其中<code>withBody</code>用于指定消息体；<code>setDeliveryMode</code>用来设置消息的发送类型，可以是持久化的，也可以是非持久化的；<code>build</code> 与构建消息。</p> 
<p>完成上述代码之后，我们可以执行这个测试方法：</p> 
<p>查看 RabbitMQ 的控制台，发现成功发送了消息，并且其中的 <code>delivery_mode</code> 为 2，代表的就是持久化：<br> <img src="https://images2.imgbox.com/0c/c5/D6Ztr7WP_o.png" alt=""></p> 
<p>再次重启 RabbitMQ 服务：<br> <img src="https://images2.imgbox.com/f0/65/qEaOUn3h_o.png" alt=""></p> 
<p>此时发现刚才的消息并没有丢失，至此我们就完成了持久化消息的发送，进一步确保了消息的可靠性。<code>另外，其实在使用 Spring AMQP 创建的交换机，队列和发送的消息都是持久化的。</code></p> 
<h2><a id="_276"></a>三、消费者消息的确认</h2> 
<h3><a id="31__277"></a>3.1 配置消费者消息确认</h3> 
<p>RabbitMQ 同样也支持消费者确认机制，即当消费者处理消息后可以向 MQ 发送 ack 回执，当 MQ 收到 ack 回执后才会删除该消息。而Spring AMQP 则允许配置三种确认模式：</p> 
<ul><li><code>manual</code>：在代码中手动 ack，需要在业务代码结束后，调用Spring AMQP 提供的 API 发送 ack，但是这种情况存在代码侵入的问题。</li><li><code>auto</code>：基于 AOP 自动发送 ack，由 Spring 监测 <code>listener</code> 代码是否出现异常，没有异常则返回 ack；抛出异常则返回 nack；</li><li><code>none</code>：关闭 ack，MQ 假定消费者获取消息后会成功处理，因此消息投递后立即被删除。</li></ul> 
<p>实现消费者的确认机制的方式就是是修改<code>application.yml</code>文件，添加下面配置：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">listener</span><span class="token punctuation">:</span>
      <span class="token key atrule">simple</span><span class="token punctuation">:</span>
        <span class="token key atrule">prefetch</span><span class="token punctuation">:</span> <span class="token number">1</span>
        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> auto <span class="token comment"># none，关闭ack；manual，手动ack；auto：自动 ack</span>
</code></pre> 
<h3><a id="32__none__296"></a>3.2 演示 none 模式</h3> 
<p>此时，我们将消费者的确认模式改为 <code>none</code>：</p> 
<p><img src="https://images2.imgbox.com/07/0d/jDpjypSz_o.png" alt=""><br> 消息处理逻辑：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到simple.queue的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 模拟异常</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消费者处理消息成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这里，使用 <code>System.out.println(1/0)</code>来模拟异常的产生。</p> 
<p>此时，在 <code>simple.queue</code> 中存在一条消息：</p> 
<p><img src="https://images2.imgbox.com/45/fe/5xqbGanf_o.png" alt=""></p> 
<p>然后，我们将断点设置到如下位置：<br> <img src="https://images2.imgbox.com/b8/dd/QWImLb0C_o.png" alt="">调试运行，可以发现，在 <code>none</code> 模式下，只有消费者接收到了消息，RabbitMQ 就会立即删除队列中的消息。<br> <img src="https://images2.imgbox.com/d6/f4/FXW7EQV4_o.png" alt=""><br> 在这种<code>none</code>模式下，队列中的消息并不可靠，当消费者消费消息失败的时候不应该理解删除，而是应该重新发送或者采取其他措施来保证消息的可靠性。</p> 
<h3><a id="33__auto__327"></a>3.3 演示 auto 模式</h3> 
<p>接下来让我们演示一下 <code>auto</code> 模式：<br> <img src="https://images2.imgbox.com/94/47/iCO6QIQZ_o.png" alt=""><br> 同样在<code>simple.queue</code>中准备一条消息：</p> 
<p><img src="https://images2.imgbox.com/83/d3/4SkefcVg_o.png" alt="">然后调试运行刚才的代码：</p> 
<p>此时发现<code>consumer</code>成功接收到了消息：<br> <img src="https://images2.imgbox.com/a2/0c/YLe7EFjU_o.png" alt="">并且，此时 <code>simple.queue</code> 中消息的状态变成了 <code>Unacked</code>：<br> <img src="https://images2.imgbox.com/a2/13/ej55lrLk_o.png" alt=""><br> 如果，此时放行代码，发现消费者还是会继续接收到这条消息：</p> 
<p><img src="https://images2.imgbox.com/0f/ab/d1LeXQ8E_o.png" alt=""><br> 此时，如果取消断点，并放开代码，会发现此时的消费者就会一直死循环的接收到这条消息。</p> 
<p>通过上面的演示可以发现，尽管在 <code>auto</code> 模式下保证了消息的不丢失，但是此时如果消费者出现了异常，就会死循环的接收并尝试处理同一条消息。面对这个问题，还需要采取其他措施来进行处理，例如下文消费者消费失败的重试机制。</p> 
<h2><a id="_346"></a>四、消息消费失败的重试机制</h2> 
<h3><a id="41__348"></a>4.1 本地重试机制</h3> 
<p>当消费者出现异常后，消息会不断 <code>requeue</code>（重新入队）到队列，再重新发送给消费者，然后再次异常，再次 <code>requeue</code>，无限循环，导致 MQ的消息处理的压力大大提高，给 MQ 服务器带来不必要的压力：</p> 
<p><img src="https://images2.imgbox.com/ea/79/AtSSb2h3_o.png" alt=""></p> 
<p>我们可以利用 Spring 的 <code>retry</code> 机制，在消费者出现异常时利用本地重试，而不是无限制的 <code>requeue</code> 到 MQ 队列，使用这个重试机制需要在 <code>application.yml</code> 添加如下配置：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">listener</span><span class="token punctuation">:</span>
      <span class="token key atrule">simple</span><span class="token punctuation">:</span>
        <span class="token key atrule">retry</span><span class="token punctuation">:</span>
          <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启消费者失败重试</span>
          <span class="token key atrule">initial-interval</span><span class="token punctuation">:</span> <span class="token number">1000</span> <span class="token comment"># 初识的失败等待时长为1秒</span>
          <span class="token key atrule">multiplier</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span>
          <span class="token key atrule">max-attempts</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 最大重试次数</span>
          <span class="token key atrule">stateless</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># true无状态；false 有状态。如果业务中包含事务，这里改为 false</span>
</code></pre> 
<p>完成了上面的配置之后，再次重启 <code>consumer</code> ：<br> <img src="https://images2.imgbox.com/5e/06/hizBiDZH_o.png" alt=""><br> <img src="https://images2.imgbox.com/5e/23/XnWiNLmC_o.png" alt=""></p> 
<p>发现，消费者在本地重试了三次，最终还是失败，然后就放弃重试，并且<code>simple.queue</code> 中的消息也删除了。</p> 
<h3><a id="42__376"></a>4.2 失败消息的处理策略</h3> 
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有 MessageRecoverer 接口来处理，它包含三种不同的实现：</p> 
<ul><li><code>RejectAndDontRequeueRecoverer</code>：重试次数耗尽后，直接 <code>reject</code>，丢弃消息，这是默认采取的方式；</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试次数耗尽后，返回 nack，消息重新入队；</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机。</li></ul> 
<p>下面演示一下 <code>RepublishMessageRecoverer</code> 处理模式：</p> 
<ol><li>首先，定义接收失败消息的交换机、队列及其绑定关系：</li></ol> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">errorMessageExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"error.direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">errorQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"error.queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">errorBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">errorQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">errorMessageExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<ol start="2"><li>然后，定义<code>RepublishMessageRecoverer</code>：</li></ol> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">MessageRecoverer</span> <span class="token function">republishMessageRecoverer</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RepublishMessageRecoverer</span><span class="token punctuation">(</span>rabbitTemplate<span class="token punctuation">,</span> <span class="token string">"error.direct"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当我们注册了 <code>RepublishMessageRecoverer</code> Bean 对象之后，就会自动覆盖 Spring 提供的默认的 <code>RejectAndDontRequeueRecoverer</code> 的 Bean 对象。</p> 
<p>当完成了上述的所有配置之后，首先在 <code>simple.queue</code> 中准备一条消息，然后再启动 <code>consumer</code>：<br> <img src="https://images2.imgbox.com/f8/41/QaCF5CqA_o.png" alt=""><br> 最终发现，处理失败的消息最终转发到了 <code>error.queue</code> 队列了。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da2a32edddf51965b735606b84cd9b04/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件学报排版样例2021版</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bed151df49812a2a038825c6a3155f62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用MATLAB创建栅格地图(代码可复制)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>