<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据清洗概念，方法及流程等等要点初探 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据清洗概念，方法及流程等等要点初探" />
<meta property="og:description" content="数据清洗(Data Cleaning)是把数据记录中的错误数据辨认识别出来，然后将其去除，是对数据重新进行检查和校验的过程。数据清洗的目标是去除重复记录，消除异常数据，修正错误数据，确保数据一致性，并提高数据质量。数据仓库是关于特定主题的数据集合，数据来自不同类型的业务系统，并包含历史性数据，这样，在数据仓库中就会出现错误数据或者冲突数据的情况，将这类数据称为“脏数据”。根据确切的清洗规则和算法“洗掉”“脏数据”，这就是数据清洗。 近年来，数据库钻研团队对数据清洗非常关注，并且常常将数据清洗与数据仓库、数据挖掘以及数据关联关系联系在一起。钻研团队整合视图的研究目标是调和概念层面的差异，对整合框架、调解制度、原则冲突等综合性学习进行研究。对于数据清洗过程的下一步，分层和数据差异的例子几乎没有被注意。研究数据清洗和视图集成工作相辅相成，并实现了全局性的调和架构。但是，实例级别的数据调整面临着挑战，当需要将来自多个数据源的数据进行整合时，比如，在网络信息系统或数据仓库中，数据清洗的意义变得尤为重要，因为不同类型的数据源通常以不同的形式出现。剖析“脏数据”出现的原因以及其存在的形式就是数据清洗的原理，使用相关的清洗软件或工具清洗数据，把“脏数据”变为“干净数据”，提高数据质量。从“脏数据”产生的源头对数据进行剖析，对数据集进行全盘考察，进而提取数据清洗规则，最终，利用所提取的清洗规则发现数据集中的“脏数据”，然后对该类数据进行清洗。 数据清洗方式主要分为手动清洗，全机清洗，人机同步清洗和人机异步清洗四种类型。 (1)手动清洗：对较大的数据集来说，因为人工的限制，对数据清洗的准确性和速率会有所下降，所以，在公司业务体系中较小的数据集上通常会使用这种清洗方式。优点是准确率相对较高，缺点是执行速度较慢。 (2)全机清洗：依据具体清洗方案，编写清洗程序，自动清洗数据。优点是清洗自动化，把人解脱出来，缺点是实现过程复杂，后期维护困难。 (3)人机同步清洗：对于某些特殊的清洗，只能通过数据清洗程序才能实现，设计人机交互的界面，采取人工和机器辅助的方式，当清洗程序无法处理数据时，将通过人工干预等方式进行处理。优点是降低编写程序复杂度，减少大量人工操作，缺点是需人工实时参与。 (4)人机异步清洗：在对数据进行清洗的过程中，当遇到程序不能处理的问题时，不需人工直接参与，只需将异常情况记录下来生成相应的报告，然后继续进行清洗工作，人工则只需按照报告在后期进行相应的处理便可。优点是节约人力，提高清洗效果，是一种可行的清洗方式。 一般情况下，需要进行清洗的数据包括下列几种数据类型。 (1)缺损数据 缺损数据是指数据的一些信息缺失损坏，比如，业务体系中的主表与明细表不匹配、分公司的名称信息缺失损坏等，这些数据将从数据集中过滤出来，按照缺失内容的差异性将其分别写到不同类型的文档中，而后提交给客户，要求其在指定的时间内，根据所提出来的数据清洗框架、清洗规则和清洗算法进行补全，然后将其写入数据仓库。 缺 失 数 据 清 洗 ( missing values imputation) 。完善缺失数据是数据清洗领域面临的另一个重要问题。如图 2 所示，在现实世界中，由于手动输入的失误操作、部分信息需要保密或者数据来源不可靠等各种各样的原因，使得数据集中的内容残缺不完整。比如某条记录的属性值被标记为 NULL \、空缺或“未知”等。一旦不完整、不准确的数据用于挖掘，则会影响抽取模式的正确性和导出规则的准确性。当错误的数据挖掘模型应用于前端的决策系统时，就会导致分析结果和执行决策出现严重偏差。
当前有很多方法用于缺失值清洗，可以分为两类:
( a) 忽略不完整数据。直接通过删除属性或实例，忽略不完整的数据。在数据集规模不大、不完整数据较少的情况下，常常利用该方法来实现数据清洗。
该方法因为执行效率高，因此经常作为缺省方法，但缺点也相当明显。如果不完整数据集较大，一旦删除了若干记录之后，因为剩余的数据集规模较小，使得模型的构建不具备普适性和代表性，无法让人信赖，可靠度大大降低。另外，因为删除不完整数据带来的数据集偏差也使得数据挖掘的分类、聚类模型产生严重倾斜，进而影响最终的挖掘结果，产生重大决策性误导。
( b) 基于填充技术的缺失值插补算法。上一种忽略法很有可能将潜在的有价值信息也一并删除。因此更多的时候选择填充不完整的数据。为了填充缺失值，用最接近缺失值的值来替代它，保证可挖掘数据的数量和质量。填充方法保留了潜在的有用数据，和删除属性或记录相比，保留了更多数据样本，不易于产生数据分析偏差，由此构建的模型更可靠，更有说服力。目前常用的缺失值填充算法大体分为两大类，一类是统计学方法，另一类是分类、聚类方法。
采用统计学方法填充缺失值。分析数据集，获取数据集的统计信息，利用数值信息填充缺失值。其中最简单的方法是平均值填充方法。它把所有完整数据的算术平均值作为缺失数据的值。这种方法的弊端在于有可能会影响缺失数据与其他数据之间原本的相关性。如果规模较大的数据集的缺失值全部采用平均值填充法进行填充，因为过多的中值存在，更多的尖峰态频率分布有可能会误导挖掘结果。
采用分类、聚类方法填充缺失值。分类是在已有类标号的基础上，通过输入训练样本数据集，构造出分类器( 如分类函数或者分类模型) 。常用的数据分类技术包括决策树、神经网络、贝叶斯网络、粗糙集理论、最临近分类法等。利用完整记录与缺失记录之间的记录相似度，通过最大相似度的计算，结合机器学习的相关技术，建立最大可能的完整的数据模型。聚类是在不考虑类标号的前提下，寻求类间的相似性，目的也是在海量的数据聚集的基础上，构建较小的代表性的数据集，并基于该集合进一步分析和研究。常见的缺失值填充算法包括 EM 最大期望值算法( expectation－maximization algorithm ) 、MI 算 法 ( multiple imputation) 和 KNNI 算法( k－nearest neighbor imputation) 等。其中最大期望算法通过创建概率模型，寻找参数最大似然估计值或者最大后验估计值，概率模型的成功与否依赖于无法观测的隐藏变量( latent variable)。
(2)错误数据 错误数据出现的原因主要是不够完善的业务体系，没有判别所接收到的输入数据是否与业务准则相符，直接将其写入到后台数据库中。先对错误数据进行分类，而后经过 SQL 语句寻找出来，根据客户请求在业务体系中修改，最终再对其进行抽取。数据类型不一致或日期格式不正确等问题同样会导致数据清洗失败，对于此类型的错误问题，需要在业务系统的数据库中通过 SQL 语句将其找出，交给业务部门进行修改，然后再对其进行抽取。 噪声数据处理( noise treatment) 。数据挖掘前，往往假设数据集不存在任何数据干扰。然而，实际应用中却因为各种原因，在数据收集、整理的过程中，产生大量的噪声数据，即“离群点”。因为噪声数据不在合理的数据域内，所以分析、挖掘过程中输入和输出数据的质量难以保证，容易造成后续的挖掘结果不准确、不可靠，如图 3 所示。常用的消除噪声数据的方法分为两种。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4b3e4b75b392000cf0e79653589c7962/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-26T08:06:46+08:00" />
<meta property="article:modified_time" content="2023-12-26T08:06:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据清洗概念，方法及流程等等要点初探</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/33/ac/lJuJjQ7S_o.png" alt="3b63d5c66c8684dfa37aa798fb0a28f9.png"></p> 
 <p>数据清洗(Data Cleaning)是把数据记录中的错误数据辨认识别出来，然后将其去除，是对数据重新进行检查和校验的过程。数据清洗的目标是去除重复记录，消除异常数据，修正错误数据，确保数据一致性，并提高数据质量。数据仓库是关于特定主题的数据集合，数据来自不同类型的业务系统，并包含历史性数据，这样，在数据仓库中就会出现错误数据或者冲突数据的情况，将这类数据称为“脏数据”。根据确切的清洗规则和算法“洗掉”“脏数据”，这就是数据清洗。 </p> 
 <p>近年来，数据库钻研团队对数据清洗非常关注，并且常常将数据清洗与数据仓库、数据挖掘以及数据关联关系联系在一起。钻研团队整合视图的研究目标是调和概念层面的差异，对整合框架、调解制度、原则冲突等综合性学习进行研究。对于数据清洗过程的下一步，分层和数据差异的例子几乎没有被注意。研究数据清洗和视图集成工作相辅相成，并实现了全局性的调和架构。但是，实例级别的数据调整面临着挑战，当需要将来自多个数据源的数据进行整合时，比如，在网络信息系统或数据仓库中，数据清洗的意义变得尤为重要，因为不同类型的数据源通常以不同的形式出现。剖析“脏数据”出现的原因以及其存在的形式就是数据清洗的原理，使用相关的清洗软件或工具清洗数据，把“脏数据”变为“干净数据”，提高数据质量。从“脏数据”产生的源头对数据进行剖析，对数据集进行全盘考察，进而提取数据清洗规则，最终，利用所提取的清洗规则发现数据集中的“脏数据”，然后对该类数据进行清洗。 </p> 
 <p><img src="https://images2.imgbox.com/ff/23/cpsRp7MB_o.jpg" alt="8f8f025ce81e25738ed32fe7b936acd9.jpeg"></p> 
 <p>数据清洗方式主要分为手动清洗，全机清洗，人机同步清洗和人机异步清洗四种类型。 </p> 
 <p>(1)手动清洗：对较大的数据集来说，因为人工的限制，对数据清洗的准确性和速率会有所下降，所以，在公司业务体系中较小的数据集上通常会使用这种清洗方式。优点是准确率相对较高，缺点是执行速度较慢。 </p> 
 <p>(2)全机清洗：依据具体清洗方案，编写清洗程序，自动清洗数据。优点是清洗自动化，把人解脱出来，缺点是实现过程复杂，后期维护困难。 </p> 
 <p>(3)人机同步清洗：对于某些特殊的清洗，只能通过数据清洗程序才能实现，设计人机交互的界面，采取人工和机器辅助的方式，当清洗程序无法处理数据时，将通过人工干预等方式进行处理。优点是降低编写程序复杂度，减少大量人工操作，缺点是需人工实时参与。 </p> 
 <p>(4)人机异步清洗：在对数据进行清洗的过程中，当遇到程序不能处理的问题时，不需人工直接参与，只需将异常情况记录下来生成相应的报告，然后继续进行清洗工作，人工则只需按照报告在后期进行相应的处理便可。优点是节约人力，提高清洗效果，是一种可行的清洗方式。 </p> 
 <p><img src="https://images2.imgbox.com/b2/74/4raFTP9o_o.jpg" alt="c9d34116552b4fb80a16b2bbfc98ab16.jpeg"></p> 
 <p>一般情况下，需要进行清洗的数据包括下列几种数据类型。 </p> 
 <p><strong>(1)缺损数据 </strong></p> 
 <p>缺损数据是指数据的一些信息缺失损坏，比如，业务体系中的主表与明细表不匹配、分公司的名称信息缺失损坏等，这些数据将从数据集中过滤出来，按照缺失内容的差异性将其分别写到不同类型的文档中，而后提交给客户，要求其在指定的时间内，根据所提出来的数据清洗框架、清洗规则和清洗算法进行补全，然后将其写入数据仓库。 </p> 
 <p>缺 失 数 据 清 洗 ( missing values imputation) 。完善缺失数据是数据清洗领域面临的另一个重要问题。如图 2 所示，在现实世界中，由于手动输入的失误操作、部分信息需要保密或者数据来源不可靠等各种各样的原因，使得数据集中的内容残缺不完整。比如某条记录的属性值被标记为 NULL \、空缺或“未知”等。一旦不完整、不准确的数据用于挖掘，则会影响抽取模式的正确性和导出规则的准确性。当错误的数据挖掘模型应用于前端的决策系统时，就会导致分析结果和执行决策出现严重偏差。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/a6/f8/nVJuv2a2_o.png" alt="094df02a6cfb2bb0609c46cc74241ecd.png"></p> 
 <p>当前有很多方法用于缺失值清洗，可以分为两类:</p> 
 <p>( a) 忽略不完整数据。直接通过删除属性或实例，忽略不完整的数据。在数据集规模不大、不完整数据较少的情况下，常常利用该方法来实现数据清洗。</p> 
 <p>该方法因为执行效率高，因此经常作为缺省方法，但缺点也相当明显。如果不完整数据集较大，一旦删除了若干记录之后，因为剩余的数据集规模较小，使得模型的构建不具备普适性和代表性，无法让人信赖，可靠度大大降低。另外，因为删除不完整数据带来的数据集偏差也使得数据挖掘的分类、聚类模型产生严重倾斜，进而影响最终的挖掘结果，产生重大决策性误导。</p> 
 <p>( b) 基于填充技术的缺失值插补算法。上一种忽略法很有可能将潜在的有价值信息也一并删除。因此更多的时候选择填充不完整的数据。为了填充缺失值，用最接近缺失值的值来替代它，保证可挖掘数据的数量和质量。填充方法保留了潜在的有用数据，和删除属性或记录相比，保留了更多数据样本，不易于产生数据分析偏差，由此构建的模型更可靠，更有说服力。目前常用的缺失值填充算法大体分为两大类，一类是统计学方法，另一类是分类、聚类方法。</p> 
 <p>采用统计学方法填充缺失值。分析数据集，获取数据集的统计信息，利用数值信息填充缺失值。其中最简单的方法是平均值填充方法。它把所有完整数据的算术平均值作为缺失数据的值。这种方法的弊端在于有可能会影响缺失数据与其他数据之间原本的相关性。如果规模较大的数据集的缺失值全部采用平均值填充法进行填充，因为过多的中值存在，更多的尖峰态频率分布有可能会误导挖掘结果。</p> 
 <p>采用分类、聚类方法填充缺失值。分类是在已有类标号的基础上，通过输入训练样本数据集，构造出分类器( 如分类函数或者分类模型) 。常用的数据分类技术包括决策树、神经网络、贝叶斯网络、粗糙集理论、最临近分类法等。利用完整记录与缺失记录之间的记录相似度，通过最大相似度的计算，结合机器学习的相关技术，建立最大可能的完整的数据模型。聚类是在不考虑类标号的前提下，寻求类间的相似性，目的也是在海量的数据聚集的基础上，构建较小的代表性的数据集，并基于该集合进一步分析和研究。常见的缺失值填充算法包括 EM 最大期望值算法( expectation－maximization algorithm ) 、MI 算 法 ( multiple imputation) 和 KNNI 算法( k－nearest neighbor imputation) 等。其中最大期望算法通过创建概率模型，寻找参数最大似然估计值或者最大后验估计值，概率模型的成功与否依赖于无法观测的隐藏变量( latent variable)。</p> 
 <p><strong>(2)错误数据 <br></strong></p> 
 <p>错误数据出现的原因主要是不够完善的业务体系，没有判别所接收到的输入数据是否与业务准则相符，直接将其写入到后台数据库中。先对错误数据进行分类，而后经过 SQL 语句寻找出来，根据客户请求在业务体系中修改，最终再对其进行抽取。数据类型不一致或日期格式不正确等问题同样会导致数据清洗失败，对于此类型的错误问题，需要在业务系统的数据库中通过 SQL 语句将其找出，交给业务部门进行修改，然后再对其进行抽取。 </p> 
 <p>噪声数据处理( noise treatment) 。数据挖掘前，往往假设数据集不存在任何数据干扰。然而，实际应用中却因为各种原因，在数据收集、整理的过程中，产生大量的噪声数据，即“离群点”。因为噪声数据不在合理的数据域内，所以分析、挖掘过程中输入和输出数据的质量难以保证，容易造成后续的挖掘结果不准确、不可靠，如图 3 所示。常用的消除噪声数据的方法分为两种。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/a9/c2/cgyqT2Qi_o.png" alt="9d70e404a8e641cd900375c12e687560.png"></p> 
 <p>一种叫噪声平滑方法( data polishing ) ，常用的方法是分箱法。将预处理数据分布到不同的箱中，通过参考周围实例平滑噪声数据，包括等宽分箱和等深分箱两大类。具体的分箱技术包括: 按箱平均值平滑，即求取箱中的所有值的平均值，然后使用均值替代箱中所有数据; 按中位数平滑，和上一种方法类似，采用中位数进行平滑; 按设定的箱边界平滑，定义箱边界是箱中的最大和最小值。用最近的箱边界值替换每一个值。另一种是噪声过滤( data filters) ，利用聚类方法对离群点进行分析、过滤。在训练集中明确并去除噪声实例。噪声过滤的常用算法包括 IPF 算法( iterative partitioning filter) 、EF 算法( ensemble filter)。</p> 
 <p><strong>(3)重复数据 </strong></p> 
 <p>将重复数据定义为除去 ID 和时间因子，其它字段的数据均相同的数据记录。在维表中经常会呈现这类数据，需要将重复的数据信息导出并记录在报告中，用户需要根据报告进行确认和整理。 </p> 
 <p>数据清洗不会在短期内实现，需要不断地重复进行，在这个过程当中，只有发现问题并不断地解决问题，才可以确保数据清洗的顺利进行。是否应该对数据进行过滤或修改，一般要求客户对其进行确认，然后依据客户的要求对数据进行清洗操作。值得一提的是，需要反复验证每个过滤规则，以防止过滤掉有用的数据。 </p> 
 <p>为了提高数据挖掘的速度和精度，有必要去除数据集合中的重复记录。如果有两个及以上的实例表示的是同一实体，那么即为重复记录。为了发现重复实例，通常的做法是将每一个实例都与其他实例进行对比，找出与之相同的实例。对于实例中的数值型属性，可以采用统计学的方法来检测，根据不同的数值型属性的均值和标准方差值，设置不同属性的置信区间来识别异常属性对应的记录，识别出数据集合中的重复记录，并加以消除。相似度计算是重复数据清洗过程中的常用方法，通过计算记录的各属性的相似度，再考虑每个属性的不同权重值，加权平均后得到记录的相似度。如果两条记录相似度超过了某一阈值，则认为两条记录是匹配的，否则，认为这两条记录指向不同实体。</p> 
 <p>另一种相似度计算算法基于基本近邻排序算法。核心思想是为了减少记录的比较次数，在按关键字排序后的数据集上移动一个大小固定的窗口，通过检测窗口内的记录来判定它们是否相似，从而确定重复记录。</p> 
 <p><img src="https://images2.imgbox.com/eb/0e/gigyDSkQ_o.jpg" alt="5934f87791caa905323ed7587bfcff1e.jpeg"></p> 
 <p>通常情况下，数据清洗的流程包括下列五个步骤。 <br></p> 
 <p>(1)数据分析：数据分析是数据清洗的条件和基础。经过分析，可以检测到数据集中的错误或不一致。除手动对数据分析，也可利用程序算法获得数据属性元数据，目的是发现数据集中的数据质量问题。 </p> 
 <p>(2)定义数据清洗转换规则：依据所分析的数据结果，定义数据清洗转换规则。根据数据源的数量和数据源中“脏数据”的数量，执行大量的数据清洗和转换操作。 </p> 
 <p>(3)验证：验证数据清洗转换规则的正确性，并对其效率进行评估。从数据源中提取数据样本，在所提取的数据样本中执行数据清洗转换规则，目的是对其进行验证。当情况不符合清洗的要求时，要改进清洗转换规则或调整系统参数。在清洗数据的过程当中，往往要重复迭代分析和验证数据的质量，直到获得相对理想的数据清洗转换规则和工作流，并且其质量对数据清洗的效率和质量起决定作用。 </p> 
 <p>(4)清洗数据的错误：在数据源上执行经由验证的清洗转换规则和工作流。假如直接在数据源上清洗数据，则必须备份数据源中的数据，以防止清洗数据的过程当中出现错误，从而将清洗操作进行撤销。 </p> 
 <p>(5)干净数据回流：数据清洗结束后，用干净的数据替换原始数据中的“脏数据”，以提高数据源的数据质量，避免再次清洗时进行重复的工作任务。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/69/0f/u2Vx9YhN_o.png" alt="e0b6d7d9dad66c9c9ce80ca38bcb830d.png"></p> 
 <p>数据源：数据源是所有系统数据的根源，也是数据仓库数据的主要来源。一般情况下，包含企业的内部信息和外部信息，内部信息是指关系数据库管理系统(RDBMS)的文档信息和事务处理信息；外部信息是指市场信息、法律法规以及竞争对手的信息等。 </p> 
 <p>数据存储与管理：数据仓库的中心焦点就是数据存储与管理，与其它传统数据库的差别在于组织管理方式，也决定了数据仓库的表现形式，将各业务系统的数据进行抽取、清洗、集成，依照主题进行组织构造。按照数据的覆盖范围，可以将数据仓库分为企业级数据仓库以及部门级数据仓库。 </p> 
 <p>OLAP 服务器：在线联机分析处理(OLAP)是一种可帮助分析师迅速交互地察看数据各个方面的软件技术，从而能更加深切地理解数据。依据多维模型，必要剖析的数据能够获得相应地整合以及组织，从而达到多角度、多层次趋势的分析和挖掘。 </p> 
 <p>前端工具：各类数据分析工具，数据挖掘工具，报表工具和查询工具都属于前端工具范畴。在数据仓库中利用数据挖掘工具，在 OLAP 服务器与报表工具中使用数据分析工具。 </p> 
 <p>当从多个数据源对数据进行提取的时候，由于数据源表结构布局设计的不同，从多个数据源中将数据迁移到数据仓库的过程当中，就会出现一些冗余数据或错误信息。假如不及时清洗这些数据，所生成的“脏数据”就会扭曲已经获得的数据信息，进而对已有的数据仓库系统造成恶劣的影响，所以，为了使数据仓库系统能够正常运行，数据仓库中的数据更准确，必须消除冗余数据错误信息。</p> 
 <p><img src="https://images2.imgbox.com/22/7b/t2CsLCKF_o.jpg" alt="18bc0ce08d42df2b25c7eeea34a50f86.jpeg"></p> 
 <p>通常情况下，数据清洗就是简化数据库的过程，消除数据库中重复的数据。</p> 
 <p>记录，并将其余部分转换成标准的能够接受的格式。标准模型是把待清洗的数据输入到处理器，经由一系列数据清洗相干环节清洗数据，最后，输出研究人员要求的预期格式数据。数据清洗是从数据的准确性、完整性、一致性以及时效性等方面对缺损数据、异常数据、不一致数据和冗余数据等存在数据质量问题的数据进行处理。一般情况下，数据清洗应用于特定的应用程序，所以，很难概括出统一的方法，但对不同类型的数据来讲，能够为其给出相关的数据清洗方式。数据清洗的结果是相应地处理各种类型的“脏数据”，从而获得标准和高效的数据，并提供用于数据统计和数据挖掘。 </p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/6b/0c/eWDhELfZ_o.jpg" alt="3f1661fb4039de4d5b46908e6309fc4e.jpeg"></p> 
 <p>数据清洗算法一般包括下列内容。 </p> 
 <p><strong>(1)空值的清洗 </strong></p> 
 <p>对于空值的清洗，当数据量较小的时候，可以采用人工填写空值的方法；</p> 
 <p>假如数据量较大，使用全局变量或利用属性的平均值、中间值、最大值、最小值或更为繁杂的统计函数值来填充空值，从而达到空值的清洗。 </p> 
 <p><strong>(2)噪声数据的清洗 </strong></p> 
 <p>分箱(Binning)技术是用于清除噪声数据，该属性的值是通过观察属性值的相关值来平滑属性值。如果将属性值分散为等宽或等距的“箱”，则可以使用属性值的中间值或平均值；利用计算机和人为处理相结合的方法对有嫌疑数据进行检测，继而再对这些有嫌疑的数据进行人工判别；利用不同属性的约束、简略的规则或者外部数据源的错误检测与校正，从而实现对噪声数据的清洗。 </p> 
 <p><strong>(3)不一致数据的清洗</strong></p> 
 <p>某些交易记录的数据可能存在不一致，可以使用其他工具手动更正，也可以利用知识工具对违反约束的数据进行检测。另外，数据集成可能会产生不一致的数据，应针对具体问题进行具体分析，以实现对不一致数据的清洗。 </p> 
 <p><strong>(4)重复数据的清洗 </strong></p> 
 <p>现有的重复记录删除的基本思想是“排序后合并”。数据库中的数据记录最初按照提取的关键字排序数据记录，经过与相邻记录进行比较来检查是否有重复记录存在。通常用于删除重复记录的算法：优先队列算法，基本近邻排序算法和多趟近邻排序算法。 </p> 
 <p><img src="https://images2.imgbox.com/18/0a/L838Ek3v_o.jpg" alt="c27efa3e042f22971423ec2ce81e08c6.jpeg"></p> 
 <p>随着信息化的不断深入，企业几乎每天都会产生大批量的数据，累积的数据必定会对企业的发展产生巨大的影响。为了促使庞大的数据集可以更好地发挥作用，就必须对数据质量进行提高，研究行之有效的数据清洗策略。 </p> 
 <p>大数据分析不能唯结果论，避免因唯结果论而产生的问题， 数据清洗应有相应的方法论调整。首先要树立以人为本的价值理念。对企业来说， 在维护人的权利与维护企业利润方面，应首先维护人的权利。企业利用大数据，对数据进行清洗，当然是为了利润， 但利润的获取应建立在人对技术的利用基础上，换句话说，大数据利用的根本目的，不只是为了企业获取利润， 还在于提高社会效益。只有建立在人通过技术利用提高舒适感和建立在整个社会中的位置上， 大数据技术才是有意义的。</p> 
 <p>可以说， 企业行为时时刻刻面临着维护人的权利与追求企业利润之间的选择。对于维护人的权利，往往是隐性和长远的；而维护利润，则是显性和即时的。数据清洗以人为本，考验企业发展战略及方法选择。</p> 
 <p>一是数据分析时加进更多的相关因素。数据清洗建立在数据分析基础上，如何进行清洗，不同的目标考虑，清洗的方法和结果都不一样。</p> 
 <p>如果只是单一因素考虑， 容易将数据清洗导向单一结果， 往往这种结果经不起更多 因素加进来一起考虑， 也经不起长远考虑。数据清洗时，分析更多的相关因素，有利于数据利用的综合结果， 特别是将数据利用与人的权利保护相结合时更是如此。</p> 
 <p>单一因素考虑进行数据清洗，有利于节省成本， 提高数据利用效率。这是单一目标导向的结果。然而这种效率提高是不长远、不稳定的，随着技术发展越来越趋向满足人的需求，保障人的利益，数据清洗会变得越来越没有效率。</p> 
 <p>二是结果的社会效应分析。数据清洗如果只针对结果， 则是有利于结果的数据清洗都是必要的。而往往这种结果只是公 司的短期需要，或者公司特定的需要。从整个社会来看，这种结果是不适宜的，或者有违社会公共价值， 或者不利于社会长远发展。显然，只针对这种结果的数据清洗会带来诸多问题。要避免问题的产生， 对数据利用结果的社会效应分析必不可少。数据利用结果是数据利用的结束， 但却是社会效应的开始， 越是详尽的数据利用结果社会效应分析， 越有利于数据利用效率， 越有利于维护社会在数据利用过程中的公平正义。</p> 
 <p><img src="https://images2.imgbox.com/b3/4f/9yMUboHW_o.jpg" alt="4b4210b6ced88b864dea518f20b04d05.jpeg"></p> 
 <p style="text-align:left;"><strong><strong>来源：经聚汇</strong></strong></p> 
 <p style="text-align:left;"><strong><strong>版权声明：本号内容部分来自互联网，转载请注明原文链接和作者，如有侵权或出处有误请和我们联系。</strong></strong><br></p> 
 <hr> 
 <p style="text-align:center;"><strong>合作请加QQ：365242293  </strong><br></p> 
 <p style="text-align:left;"><strong>数据分析</strong>（ID : ecshujufenxi ）互联网科技与数据圈自己的微信，也是WeMedia自媒体联盟成员之一，WeMedia联盟覆盖5000万人群。</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/cc/a6/bk8H1FY4_o.jpg" alt="53151ae2633587daa86285128d4ccad4.jpeg"></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62a259532642d4a239b5142a4c103449/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">交换机端口镜像技术原理与配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cb34e790ab37a6c140fe53a6d4c8839/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">神经网络介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>