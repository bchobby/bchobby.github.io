<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Elasticsearch 简介 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Elasticsearch 简介" />
<meta property="og:description" content="Elasticsearch 是一个非常强大的搜索引擎。它目前被广泛地使用于各个 IT 公司。Elasticsearch 是由 Elastic 公司创建。它的代码位于 GitHub - elastic/elasticsearch: Free and Open, Distributed, RESTful Search Engine。Elasticsearch 是一个分布式、免费和开放的搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。 Elasticsearch 基于 Apache Lucene 构建，并于 2010 年由 Elasticsearch N.V. 首次发布（现在称为 Elastic）。Elasticsearch 以其简单的 REST API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件，Elastic Stack 是一组用于数据摄取、丰富、存储、分析和可视化的免费开放工具。 通常被称为 ELK Stack。Elastic 公司也同时拥有 Logstash 及 Kibana 开源项目。这个三个项目组合在一起，就形成了 ELK 软件栈。他们三个共同形成了一个强大的生态圈。简单地说，Logstash 负责数据的采集，处理（丰富数据，数据转换等），Kibana 负责数据展示，分析，管理，监督，警报及方案。Elasticsearch 处于最核心的位置，它可以帮我们对数据进行存储，并快速地搜索及分析数据。随着后来的 Beats 加入，ELK 软件栈，也被称为 ELKB。
事实上 Elasticsearch 的完整栈有如下的几个：
BeatsElasticsearchKibanaLogstash Beats 是一些轻量级可以允许在客户端服务器中的代理。它并不需要部署到我们的 Elastic 云中。它可以帮我们收集所有需要的事件。如果把 Beats 也纳入到我的架构中，那么 Elastic 的栈可以表述为：
在上面是一个典型的运用 Elastic Stack 的架构。我们通常不会在客户端直接调用 Elasticsearch 的 REST 接口。取而代之的是，我们使用一个 Search Service 作为中间接口。Search Service 再向 Elasticsearch 发送请求。我们可以通过 Beats 来采集 service 的日志及指标信息，我们甚至可以使用 Elastic Stack 所提供的 APM （应用性能监控）来监控应用及服务的性能并调优。Beats 所收集的信息，我们可以直接发送至 Elasticsearch，也可以发送至 Logstash 对数据做更进一步的加工（丰富，转换，删除，结构化等）再发送至 Elasticsearch。我们可以通过 Kibana 对数据进行可视化，分析，管理，对服务进行监控等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4c3593729e4375e5231ad856f0dc36ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-03T10:13:36+08:00" />
<meta property="article:modified_time" content="2023-09-03T10:13:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Elasticsearch 简介</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p id="main-toc"><a href="https://www.elastic.co/elasticsearch/" rel="nofollow" title="Elasticsearch">Elasticsearch</a> 是一个非常强大的搜索引擎。它目前被广泛地使用于各个 IT 公司。Elasticsearch 是由 <a href="http://elastic.co/" rel="nofollow" title="Elastic">Elastic</a> 公司创建。它的代码位于 <a href="https://github.com/elastic/elasticsearch" title="GitHub - elastic/elasticsearch: Free and Open, Distributed, RESTful Search Engine">GitHub - elastic/elasticsearch: Free and Open, Distributed, RESTful Search Engine</a>。Elasticsearch 是一个分布式、免费和开放的搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。 Elasticsearch 基于 Apache Lucene 构建，并于 2010 年由 Elasticsearch N.V. 首次发布（现在称为 Elastic）。Elasticsearch 以其简单的 REST API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件，Elastic Stack 是一组用于数据摄取、丰富、存储、分析和可视化的免费开放工具。 通常被称为 ELK Stack。Elastic 公司也同时拥有 <a href="https://github.com/elastic/logstash" title="Logstash">Logstash</a> 及 <a href="https://github.com/elastic/kibana" title="Kibana">Kibana</a> 开源项目。这个三个项目组合在一起，就形成了 <strong>ELK </strong>软件栈。他们三个共同形成了一个强大的生态圈。简单地说，<strong>L</strong>ogstash 负责数据的采集，处理（丰富数据，数据转换等），<strong>Ki</strong>bana 负责数据展示，分析，管理，监督，警报及方案。Elasticsearch 处于最核心的位置，它可以帮我们对数据进行存储，并快速地搜索及分析数据。随着后来的 <a class="link-info" href="https://www.elastic.co/beats/" rel="nofollow" title="Beats">Beats</a> 加入，ELK 软件栈，也被称为 <strong>ELKB</strong>。</p> 
<p class="img-center"><img alt="" class="has" height="422" src="https://images2.imgbox.com/9b/4c/Ax35zlXy_o.png" width="404"></p> 
<p><img alt="" height="953" src="https://images2.imgbox.com/c3/23/bNWATPPS_o.png" width="1200"></p> 
<p>事实上 Elasticsearch 的完整栈有如下的几个：</p> 
<ul><li><a href="https://www.elastic.co/beats/" rel="nofollow" title="Beats">Beats</a></li><li><a href="https://www.elastic.co/elasticsearch/" rel="nofollow" title="Elasticsearch">Elasticsearch</a></li><li><a href="https://www.elastic.co/kibana/" rel="nofollow" title="Kibana">Kibana</a></li><li><a href="https://www.elastic.co/logstash/" rel="nofollow" title="Logstash">Logstash</a></li></ul> 
<p>Beats 是一些轻量级可以允许在客户端服务器中的代理。它并不需要部署到我们的 Elastic 云中。它可以帮我们收集所有需要的事件。如果把 Beats 也纳入到我的架构中，那么 Elastic 的栈可以表述为：</p> 
<p style="text-align:center;"><img alt="" height="611" src="https://images2.imgbox.com/93/5a/3gV7h6M7_o.png" width="1000"></p> 
<p><img alt="" height="772" src="https://images2.imgbox.com/0f/4d/xKI3Kc9R_o.png" width="1200"></p> 
<p>在上面是一个典型的运用 Elastic Stack 的架构。我们通常不会在客户端直接调用 Elasticsearch 的 REST 接口。取而代之的是，我们使用一个 Search Service 作为中间接口。Search Service 再向 Elasticsearch 发送请求。我们可以通过 Beats 来采集 service 的日志及指标信息，我们甚至可以使用 Elastic Stack 所提供的 APM （应用性能监控）来监控应用及服务的性能并调优。Beats 所收集的信息，我们可以直接发送至 Elasticsearch，也可以发送至 Logstash 对数据做更进一步的加工（丰富，转换，删除，结构化等）再发送至 Elasticsearch。我们可以通过 Kibana 对数据进行可视化，分析，管理，对服务进行监控等。</p> 
<p>在 Elastic 公司，我们称上面的技术栈为 <a href="https://www.elastic.co/elastic-stack" rel="nofollow" title="Elastic Stack">Elastic Stack</a>。</p> 
<p>在最新的 Elastic Stack 架构中，取而代之的是，integration 是被推荐的采集数据的方法。采用 integration 可以使得我们能对采集端进行集中监控。</p> 
<p>随着 Elastic Stack 的发展，在最新的发布中，Elastic 引入 <a class="link-info" href="https://www.elastic.co/integrations/" rel="nofollow" title="integrations">integrations</a> 来采集数据。<a class="link-info" href="https://www.elastic.co/elastic-agent" rel="nofollow" title="Elastic Agent">Elastic Agent</a> 可以被安装于采集端采集数据，并可以在 Kibana 中对采集端进行集中管理：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/15/b8/bOB1DW4Z_o.png"></p> 
<p></p> 
<div class="csdn-video-box"> 
 <iframe id="3mYnt2tB-1646692778541" frameborder="0" src="https://player.bilibili.com/player.html?aid=668647846" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>Elastic Stack 简介及 7.x 安装</p> 
</div> 
<p></p> 
<div class="csdn-video-box"> 
 <iframe id="QouzDUKE-1692403623783" frameborder="0" src="https://player.bilibili.com/player.html?aid=594268360" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>Elastic Stack 8.0 安装介绍</p> 
</div> 
<p></p> 
<p>在全世界范围内有非常多的公司在使用 Elastic Stack。它们分布在不同的领域：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7a/70/Xf3yf8NP_o.png"></p> 
<p>你可以在 Elastic 的官方地址找到更多的关于<a href="https://www.elastic.co/customers/" rel="nofollow" title="客户">客户</a>的信息。 </p> 
<p>在今天的这篇文章中，我来简单地介绍一下什么是 <strong>Elasticsearch</strong>。</p> 
<div class="csdn-video-box"> 
 <iframe id="YaRchYV2-1617757533333" frameborder="0" src="https://player.youku.com/embed/XNTEzNDAyNTg1Mg==" allowfullscreen="true" data-mediaembed="youku"></iframe> 
 <p>Elastic is a Search Company</p> 
</div> 
<p></p> 
<h2><strong>Elasticsearch 能做什么？</strong></h2> 
<p>Elasticsearch 的速度和可扩展性及其为多种类型的内容编制索引的能力意味着它可用于多种用例：</p> 
<ul><li>应用搜索，比如我们常见的 github，linkedin，滴滴，美团，抖音，点评，音乐，视频，银行，证券，保险，电信 app 里的搜索</li><li>网站搜索</li><li>企业搜索</li><li>日志记录和日志分析</li><li>基础设施指标和容器监控</li><li>应用性能监控</li><li>地理空间数据分析和可视化</li><li>安全分析</li><li>商业分析</li></ul> 
<p></p> 
<h2 id="Elastic%E4%BA%A7%E5%93%81%E7%94%9F%E6%80%81">Elastic 产品生态</h2> 
<p style="text-align:center;"><img alt="" height="647" src="https://images2.imgbox.com/7d/0e/nQO99xes_o.png" width="907"></p> 
<p>Elastic 围绕 Elasticsearch 已经建立了许多成熟的方案。更多详情请参阅我们的官方网站 <a href="https://www.elastic.co/" rel="nofollow" title="Free and Open Search: The Creators of Elasticsearch, ELK &amp; Kibana | Elastic">Free and Open Search: The Creators of Elasticsearch, ELK &amp; Kibana | Elastic</a>。</p> 
<div class="csdn-video-box"> 
 <iframe id="8OlqWh38-1639104758857" frameborder="0" src="https://player.bilibili.com/player.html?aid=209638829" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>Power of Search - 60 sec</p> 
</div> 
<p><a href="https://www.bilibili.com/video/BV1Lh411x7sv/" rel="nofollow" title="Power of Search - 60 sec_哔哩哔哩_bilibili">Power of Search - 60 sec_哔哩哔哩_bilibili</a></p> 
<p></p> 
<h2 id="Elasticsearch">Elasticsearch</h2> 
<p>简单地说， Elasticsearch 是一个分布式的使用 REST 接口的搜索引擎。它的产品可以在<a href="https://www.elastic.co/products/elasticsearch" rel="nofollow" title="Elasticsearch: The Official Distributed Search &amp; Analytics Engine | Elastic">Elasticsearch: The Official Distributed Search &amp; Analytics Engine | Elastic</a> 进行下载。Elasticsearch 是一个分布式的基于 <a href="https://www.jianshu.com/p/ee92c9accedd" rel="nofollow" title="REST">REST</a> 接口的为云而设计的搜索引擎，它的功能包括：</p> 
<p>Elasticsearch是一个基于 <a href="http://lucene.apache.org/" rel="nofollow" title="Apache Lucene">Apache Lucene</a> （TM）的开源搜索引擎。无论在开源还是专有领域，Lucene 可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。在 1999 年，Doug Cutting 创建了一个叫做 Lucene 的开源项目：</p> 
<ul><li>一个完全用 Java 编写的搜索引擎库</li><li>截止 2005 年，是一个顶级的 Apache 开源项目</li><li>提供强大的全文搜索功能</li></ul> 
<p>但是，Lucene 只是一个库。Lucene 本身并不提供高可用性及分布式部署。想要发挥其强大的作用，你需使用 Java 并要将其集成到你的应用中。Lucene 非常复杂，你需要深入的了解检索相关知识来理解它是如何工作的。 </p> 
<p>Elasticsearch 始于一个食谱应用。早在 2000 年，在伦敦的一间公寓里，谢伊·班农 (Shay Banon，也就是 Elastic 现在的 CTO) 正在找工作，而他的妻子则在蓝带国际学院 (Le Cordon Bleu) 上烹饪学校。 在业余时间，他开始为他不断增加的食谱列表构建一个搜索引擎。在 2004年，他的第一个迭代称为 <a class="link-info" href="https://github.com/Compass/compass" title="Compass">Compass</a>。反映令人印象深刻。 用户自然而轻松地接受了它。 使用它的人员飙升，一个社区开始形成。</p> 
<p>Compass 是这样的一个项目：</p> 
<ul><li>构建于 Lucence 之上</li><li>目的是使得 Lucene 搜索更容易集成到 Java 应用中去</li><li>可扩展性变得尤为重要</li></ul> 
<p>在 2010 年，Shay 完全重新编写了 Compass 以实现如下的两个目的：</p> 
<ul><li>从一开始设计之初，分布式部署贯穿整个设计</li><li>可方便地使用其它的语言进行对接使用</li></ul> 
<p style="text-align:center;"><img alt="" height="479" src="https://images2.imgbox.com/9a/c6/wdlf5OJ8_o.png" width="800"></p> 
<p>Shay 最终把这个项目称之为 Elasticsearch，并于当年10月发布与 github 上。如果你对 Elasticsearch 的历史更感兴趣的话，请阅读另外一篇我同事写的文章 “<a href="https://elasticstack.blog.csdn.net/article/details/113754619" rel="nofollow" title="Elasticsearch 的前世今生">Elasticsearch 的前世今生</a>”。</p> 
<p>人们注意到了 Elasticsearch —— 特别是  Steven Schuurman、Uri Boness 及 Simon Willnauer。 他们和 Shay 一起创立了一家搜索公司 Elastic。现在很多开发者人都知道 <strong>ES</strong> 及 <strong>ELK</strong>，但是很多人很少知道 Elastic 是这个软件栈后面的商业公司。</p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" height="666" src="https://images2.imgbox.com/d5/c2/qKMQoqXQ_o.jpg" width="1000"> 
  <figcaption>
    图片来自  
   <a href="https://www.elastic.co/about/history-of-elasticsearch" rel="nofollow" title="Our Story | Elastic">Our Story | Elastic</a> 
  </figcaption> 
 </figure> 
</div> 
<p>Elasticsearch 也是使用 Java 编写并使用 Lucene 来建立索引并实现搜索功能，但是它的目的是通过简单连贯的 RESTful API 让全文搜索变得简单并隐藏 Lucene 的复杂性。 </p> 
<p>不过，Elasticsearch 不仅仅是 Lucene 和全文搜索引擎，它还提供：</p> 
<ul><li>分布式的实时文件存储，每个字段都被索引并可被搜索</li><li>实时分析的分布式搜索引擎</li><li>可以扩展到上百台服务器，处理 PB 级结构化或非结构化数据</li></ul> 
<p>而且，所有的这些功能被集成到一台服务器，你的应用可以通过简单的 RESTful API、各种语言的客户端甚至命令行与之交互。上手 Elasticsearch 非常简单，它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。Elasticsearch 在 <a href="https://elasticstack.blog.csdn.net/article/details/114818352" rel="nofollow" title="Elastic V2 及 SSPL">Elastic V2 及 SSPL</a> 下许可使用，可以免费下载、使用和修改。 随着知识的积累，你可以根据不同的问题领域定制 Elasticsearch 的高级特性，这一切都是可配置的，并且配置非常灵活。</p> 
<p>Elasticsearch 的特点是它提供了一个极速的搜索体验。这源于它的高速（<strong>speed</strong>）。相比较其它的一些大数据引擎，Elasticsearch 可以实现秒级的搜索，但是对于它们来说，可能需要数小时或更长才能完成。Elasticsearch 的 cluster 是一种分布式的部署，极易扩展（<strong>scale</strong>)。这样很容易使它处理 petabytes 的数据库容量。最重要的是 Elasticsearch 是它搜索的结果可以按照分数进行排序，它能提供我们最相关的搜索结果（<strong>relevance</strong>)。我们可以依据自己的业务场景有正对性地进行<a href="https://elasticstack.blog.csdn.net/article/details/114278163" rel="nofollow" title=" relevance 定制"> relevance 定制</a>。</p> 
<p style="text-align:center;"><img alt="" class="has" height="362" src="https://images2.imgbox.com/aa/07/F0ZWzoqZ_o.png" width="820"></p> 
<p></p> 
<h3 id="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E6%90%9C%E7%B4%A0%E5%BC%95%E6%93%8E">分布式及高可用性的搜素引擎</h3> 
<ol><li>每个索引（index）都使用可配置数量的分片进行完全分片</li><li>每个分片都可以有一个或多个副本</li><li>在任何副本分片上可执行读取/搜索操作</li></ol> 
<h3 id="%E5%A4%9A%E7%A7%9F%E6%88%B7">多租户</h3> 
<ol><li>支持多个索引</li><li>索引级别配置（分片数，索引存储，......）</li></ol> 
<h3 id="%E5%90%84%E7%A7%8DAPI">各种API</h3> 
<ol><li>HTTP RESTful API</li><li>Native Java API</li><li>所有 API 都执行自动节点操作重新路由</li></ol> 
<p style="text-align:center;"><img alt="" class="has" height="285" src="https://images2.imgbox.com/b8/67/YzB6pT7P_o.png" width="800"></p> 
<h3 id="%E9%9D%A2%E5%90%91%E6%96%87%E6%A1%A3">面向文档</h3> 
<ol><li>无需前期定义 schema （文档结构）</li><li>可以定义 schema 以定制索引过程</li></ol> 
<h3 id="%E5%8F%AF%E9%9D%A0%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%86%99%E5%85%A5%EF%BC%8C%E5%8F%AF%E5%AE%9E%E7%8E%B0%E9%95%BF%E6%9C%9F%E6%8C%81%E7%BB%AD%E6%80%A7">可靠，异步写入，可实现长期持续性</h3> 
<h3 id="(%E8%BF%91)%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2">(近)实时搜索</h3> 
<h3 id="%E5%BB%BA%E5%9C%A8Lucene%E4%B9%8B%E4%B8%8A">建在 Lucene 之上</h3> 
<ol><li>每个分片都是一个功能齐全的 Lucene 索引</li><li>Lucene 的所有功能都可以通过简单的配置/插件轻松暴露出来</li></ol> 
<h3 id="%E6%AF%8F%E6%AC%A1%E6%93%8D%E4%BD%9C%E4%B8%80%E8%87%B4%E6%80%A7">每次操作一致性</h3> 
<ol><li>单文档级操作具有原子性，一致性，隔离性和持久性。</li></ol> 
<p></p> 
<h2 id="%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97">入门指南</h2> 
<p>首先，不要恐慌。 获得 Elasticsearch 的全部内容需要 5 分钟。</p> 
<h3 id="%E5%89%8D%E6%8F%90%E8%A6%81%E6%B1%82">前提要求</h3> 
<p>你需要在你的电脑上安装最新的 Java（在最新的版本中，Java 可以不用安装，因为在安装包中已经含有 Java 的安装包）。你可查看 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup.html#jvm-version" rel="nofollow" title="setup">setup</a> 链接得到更多的信息。</p> 
<h3 id="%E5%AE%89%E8%A3%85">安装</h3> 
<ol><li>你可以到链接 <a href="https://www.elastic.co/downloads/elasticsearch" rel="nofollow" title="Download">Download</a> 里去下载 Elasticsearch 最新的发布版。可以参考文档  “<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/102728604" rel="nofollow" title="Elastic：开发者上手指南">Elastic：开发者上手指南</a>” 来安装 Elasticsearch</li><li>在 Unix/Linux上运行 bin/elasticsearch，或在 Windows 上运行 bin\elasticsearch.bat</li><li>运行 curl -X GET http://localhost:9200。你在 Windows 上可以安装 <a href="https://www.cygwin.com/" rel="nofollow" title="cygwin">cygwin</a> 来运行 curl 指令</li><li>运行更多的服务器...</li></ol> 
<p style="text-align:center;"><img alt="" height="413" src="https://images2.imgbox.com/32/f8/iet0P9N9_o.png" width="615"></p> 
<h3 id="%E4%BD%BF%E7%94%A8%20cURL%E5%91%BD%E4%BB%A4%E5%92%8C%20Elasticsearch%20%E5%AF%B9%E8%AF%9D">使用 cURL 命令和 Elasticsearch 对话</h3> 
<p>我们可以使用 <a class="link-info" href="https://baike.baidu.com/item/curl/10098606?fr=aladdin" rel="nofollow" title="cURL">cURL</a> 将请求从命令行提交到本地 Elasticsearch 实例。对 Elasticsearch 的请求包含与任何 HTTP 请求相同的部分：</p> 
<pre><code>curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</code></pre> 
<p>本示例使用以下变量：</p> 
<ul><li>&lt;VERB&gt; ：适当的 HTTP 方法或动词。 例如，GET，POST，PUT，HEAD 或 DELETE</li><li>&lt;PROTOCOL&gt;：http 或 https。 如果你在 Elasticsearch 前面有一个 HTTPS 代理，或者你使用 Elasticsearch 安全功能来加密 HTTP 通信，请使用后者</li><li>&lt;HOST&gt;：Elasticsearch 集群中任何节点的主机名。 或者，将 localhost 用于本地计算机上的节点</li><li>&lt;PORT&gt;：运行 Elasticsearch HTTP 服务的端口，默认为 9200</li><li>&lt;PATH&gt;：API 端点，可以包含多个组件，例如 _cluster/stats 或 _nodes/stats/jvm</li><li>&lt;QUERY_STRING&gt;：任何可选的查询字符串参数。 例如，?pretty 将漂亮地打印 JSON 响应以使其更易于阅读</li><li>&lt;BODY&gt;：JSON 编码的请求正文（如有必要）</li></ul> 
<p>如果启用了 Elasticsearch 安全功能，则还必须提供有权运行 API 的有效用户名（和密码）。 例如，使用 -u 或 --u cURL 命令参数。比如：</p> 
<pre><code>curl -u elastic:password -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</code></pre> 
<p>这里的 elastic 及 password 代表用超级用户名 elastic 及其密码。</p> 
<p></p> 
<h3 id="%E6%A3%80%E6%9F%A5Elastic%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E5%A5%BD">检查 Elasticsearch 是否正确安装好</h3> 
<p>如果你对 Postman 比较熟悉，请参阅我的文章 “<a href="https://elasticstack.blog.csdn.net/article/details/104982536" rel="nofollow" title="Elastic：使用 Postman 来访问 Elastic Stack">Elastic：使用 Postman 来访问 Elastic Stack</a>” 来做如下的练习。</p> 
<p>在我们的 terminal上我们可以打人如下的命令：</p> 
<pre class="has"><code>$ curl -XGET 'http://localhost:9200/' -H 'Content-Type: application/json'</code></pre> 
<p>如果你看到如下的内容，表面我们的 Elasticsearch 已经安装正确：</p> 
<p><img alt="" class="has" height="496" src="https://images2.imgbox.com/6b/1d/X40HHhUf_o.png" width="997"></p> 
<p>如果你在 Elasticsearch 中启动了最基本的安全，那么我们可以通过如下的命令来做这个：</p> 
<pre class="has"><code>$ curl -XGET -u "elastic:changeme" 'http://localhost:9200/' -H 'Content-Type: application/json'</code></pre> 
<p>这里 -u 选项可以帮我们设置用户名及密码来访问 Elasticsearch。</p> 
<h3 id="%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%88Index%EF%BC%89"><br> 建立索引（Index）</h3> 
<p>对于经常看 Elastic 英文官方文档的开发者来说，我们经常会看到 index 这个词。在英文中，它即可以做<strong>动词</strong>，表示建立索引的意思，但同时它也用作<strong>名词</strong>，称作索引。很多刚开始学习 Elasticsearch 的开发者有时有点弄不明白。</p> 
<p style="text-align:center;"><img alt="" height="484" src="https://images2.imgbox.com/c7/af/XsVlCOvi_o.png" width="800"></p> 
<p> 让我们尝试索引一些类似于 Twitter 的信息。 首先，让我们索引一些推文（将自动创建 twitter 索引）：</p> 
<p style="text-align:center;"><img alt="" height="415" src="https://images2.imgbox.com/da/95/BYRU7O5f_o.png" width="963"></p> 
<pre class="has"><code>curl -XPUT 'http://localhost:9200/twitter/_doc/1?pretty' -H 'Content-Type: application/json' -d '
{
    "user": "kimchy",
    "post_date": "2009-11-15T13:12:00",
    "message": "Trying out Elasticsearch, so far so good?"
}'

curl -XPUT 'http://localhost:9200/twitter/_doc/2?pretty' -H 'Content-Type: application/json' -d '
{
    "user": "kimchy",
    "post_date": "2009-11-15T14:12:12",
    "message": "Another tweet, will it be indexed?"
}'

curl -XPUT 'http://localhost:9200/twitter/_doc/3?pretty' -H 'Content-Type: application/json' -d '
{
    "user": "elastic",
    "post_date": "2010-01-15T01:46:38",
    "message": "Building the site, should be kewl"
}'</code></pre> 
<p>现在，让我们检查一下上面的信息是否已经通过我上面的操作加入到索引里。我们可以通过 GET 来查询：</p> 
<pre class="has"><code>curl -XGET 'http://localhost:9200/twitter/_doc/1?pretty=true'
curl -XGET 'http://localhost:9200/twitter/_doc/2?pretty=true'
curl -XGET 'http://localhost:9200/twitter/_doc/3?pretty=true'</code></pre> 
<h3 id="%E6%90%9C%E7%B4%A2">搜索</h3> 
<p>让我们找到 kimchy 发布的所有推文：</p> 
<pre class="has"><code>curl -XGET 'http://localhost:9200/twitter/_search?q=user:kimchy&amp;pretty=true'</code></pre> 
<p>我们还可以使用 Elasticsearch 提供的 JSON 查询语言而不是查询字符串：</p> 
<pre class="has"><code>curl -XGET 'http://localhost:9200/twitter/_search?pretty=true' -H 'Content-Type: application/json' -d '
{
    "query" : {
        "match" : { "user": "kimchy" }
    }
}'</code></pre> 
<p>上面的查询将会显示所有的由 kimchy 发布的所有 tweet。为了好玩，让我们来得到所有的存储的文档（document） （我们可以看到由用户 elastic 发布的所有的 tweet）.</p> 
<pre class="has"><code>curl -XGET 'http://localhost:9200/twitter/_search?pretty=true' -H 'Content-Type: application/json' -d '
{
    "query" : {
        "match_all" : {}
    }
}'</code></pre> 
<p>我们也可以做一个范围里的搜索（刚才上面的那个 post_date 在建立索引的时候已经自动被识别为 date 类型）</p> 
<pre class="has"><code>curl -XGET 'http://localhost:9200/twitter/_search?pretty=true' -H 'Content-Type: application/json' -d '
{
    "query" : {
        "range" : {
            "post_date" : { "from" : "2009-11-15T13:00:00", "to" : "2009-11-15T14:00:00" }
        }
    }
}'</code></pre> 
<p>还有更多的选项可以执行搜索，毕竟，这是一个搜索产品吗？ 所有熟悉的 Lucene 查询都可以通过 JSON 查询语言或查询解析器获得。</p> 
<p></p> 
<h3 id="%E5%A4%9A%E7%A7%9F%E6%88%B7%20-%20%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B1%BB%E5%9E%8B">多租户 - 索引和类型</h3> 
<p>伙计，那个 twitter 索引可能会变大（在这种情况下，索引大小 == 估值）。 让我们看看我们是否可以稍微改变我们的 tweet 系统，以支持如此大量的数据。</p> 
<p>Elasticsearch 支持多个索引。 在前面的示例中，我们使用了一个名为 twitter 的索引，该索引为每个用户存储了推文。</p> 
<p>定义我们简单的推特系统的另一种方法是为每个用户提供不同的索引（注意，尽管每个索引都有开销）。 这是这种情况下的索引 curl：</p> 
<pre class="has"><code>curl -XPUT 'http://localhost:9200/kimchy/_doc/1?pretty' -H 'Content-Type: application/json' -d '
{
    "user": "kimchy",
    "post_date": "2009-11-15T13:12:00",
    "message": "Trying out Elasticsearch, so far so good?"
}'

curl -XPUT 'http://localhost:9200/kimchy/_doc/2?pretty' -H 'Content-Type: application/json' -d '
{
    "user": "kimchy",
    "post_date": "2009-11-15T14:12:12",
    "message": "Another tweet, will it be indexed?"
}'</code></pre> 
<p>以上将索引信息到 kimchy 索引中。 每个用户都将获得自己的特殊索引。</p> 
<p>允许完全控制索引级别。 例如，在上面的情况中，我们可能希望从每个索引1个副本的默认1分片更改为每个索引1个副本的2个分片（因为此用户推文很多）。 以下是如何做到这一点（配置也可以是在 yaml 文件里配置）：</p> 
<pre class="has"><code>curl -XPUT http://localhost:9200/another_user?pretty -H 'Content-Type: application/json' -d '
{
    "settings" : {
        "index.number_of_shards" : 2,
        "index.number_of_replicas" : 1
    }
}'</code></pre> 
<p>搜索（和类似操作）具有多索引感知功能。 这意味着我们可以轻松搜索多个 index（twitter 用户），例如：</p> 
<pre class="has"><code>curl -XGET 'http://localhost:9200/kimchy,another_user/_search?pretty=true' -H 'Content-Type: application/json' -d '
{
    "query" : {
        "match_all" : {}
    }
}'</code></pre> 
<p>或者在所有的索引（index）里进行搜索：</p> 
<pre class="has"><code>curl -XGET 'http://localhost:9200/_search?pretty=true' -H 'Content-Type: application/json' -d '
{
    "query" : {
        "match_all" : {}
    }
}'</code></pre> 
<p>{One liner teaser}：关于那个很酷的部分？ 你可以轻松搜索多个 Twitter 用户（索引），每个用户具有不同的提升级别（索引），使社交搜索变得更加简单（我朋友的结果排名高于我朋友的朋友的结果）。</p> 
<p></p> 
<h3 id="%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%8C%E9%AB%98%E5%BA%A6%E5%8F%AF%E7%94%A8">分布式，高度可用</h3> 
<p>Elasticsearch 是一个高度可用的分布式搜索引擎。每个索引都分解为分片（shard），每个分片可以有一个或多个副本。默认情况下，创建一个索引，每个分片有1个分片和1个副本（1/1）。可以使用许多拓扑，包括1/10（提高搜索性能，多个副本可以帮我们提高搜索的速度）或20/1（提高索引性能，多个主分片可以帮我们提高导入数据的速度）。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fc/49/XWe1X8yV_o.png"></p> 
<p>为了使用 Elasticsearch 的分布式特性，只需启动更多节点并关闭节点。系统将继续为索引的最新数据提供请求（确保使用正确的 HTTP 端口）。</p> 
<p></p> 
<h2>在哪些时候 Elasticsearch 可能不是正确的工具？</h2> 
<p>了解 Elasticsearch 的局限性也很重要。本节介绍在某些情况下，单独使用 Elasticsearch 可能不是完成这项工作的最佳工具。</p> 
<h3><br> 处理关系数据集</h3> 
<p>与 MySQL 等数据库不同，Elasticsearch 并非旨在处理关系数据。 Elasticsearch 允许你在数据中建立简单的关系，例如父子关系和嵌套关系，但会降低性能（分别在搜索时间和索引时间）。必须对 Elasticsearch 上的数据进行<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/114523140" rel="nofollow" title="非规范化">非规范化</a>（在文档中复制或添加冗余字段，以避免必须加入数据）以改进搜索和<br> 索引/更新性能。</p> 
<p>如果你需要让数据库管理关系并在不同类型的链接数据之间强制执行一致性规则，以及维护规范化的数据记录，那么 Elasticsearch 可能不是适合这项工作的工具。</p> 
<h3><br> 执行 ACID 事务</h3> 
<p>Elasticsearch 中的单个请求支持 ACID 属性。 但是 Elasticsearch 没有事务的概念，所以不提供 ACID 事务。</p> 
<p>在单个请求级别，ACID 属性可以实现如下：</p> 
<ul><li><strong><span style="color:#fe2c24;">A</span>tomictiy</strong> 是通过发送写入请求来实现的，该请求将在所有活动分片上成功或失败。请求无法部分成功。</li><li>通过写入主分片来实现 <strong><span style="color:#fe2c24;">C</span>onsistency</strong>。数据复制在返回成功响应之前同步发生。这意味着在写入请求之后所有分片上的所有读取请求都将看到相同的响应。</li><li>提供 <strong><span style="color:#fe2c24;">I</span>solation</strong>，因为可以成功处理并发写入或更新（即删除和写入）而不受任何干扰。</li><li>实现了 <strong><span style="color:#fe2c24;">D</span>urability</strong>，因为一旦将文档写入 Elasticsearch，它就会持续存在，即使在系统发生故障的情况下也是如此。 Elasticsearch 上的写入不会立即持久化到磁盘上的 Lucene 段，因为 Lucene 提交是相对昂贵的操作。相反，文档被写入事务日志（称为 translog）并定期刷新到磁盘中。如果一个节点在数据刷新之前崩溃了，translog 中的操作将在启动时恢复到 Lucene 索引中。</li></ul> 
<p>如果 ACID 事务对你的用例很重要，那么 Elasticsearch 可能不适合你。有关 Elasticsearch 和其他传统数据库的比较，请参阅文章 “<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/132645542" rel="nofollow" title="Elasticsearch 对比传统数据库：深入挖掘 Elasticsearch 的优势">Elasticsearch 对比传统数据库：深入挖掘 Elasticsearch 的优势</a>”。</p> 
<blockquote> 
 <p><strong>重要提示</strong>：在关系数据或 ACID 事务需求的情况下，Elasticsearch 通常与传统的 RDBMS 解决方案（如 MySQL）一起使用。 在这样的架构中，RDBMS 将充当事实来源并处理来自应用程序的写入/更新。 然后可以使用 Logstash 等工具将这些更新复制到 Elasticsearch，以进行快速/相关搜索和可视化/分析用例。关于这个用例，你可以阅读文章 “<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/103874185" rel="nofollow" title="Logstash：如何使用 Logstash 和 JDBC 确保 Elasticsearch 与关系型数据库保持同步">Logstash：如何使用 Logstash 和 JDBC 确保 Elasticsearch 与关系型数据库保持同步</a>”。</p> 
</blockquote> 
<p></p> 
<h3 id="%E6%88%91%E4%BB%AC%E5%B0%86%E4%BB%8E%E5%93%AA%E9%87%8C%E5%BC%80%E5%A7%8B%E5%91%A2%EF%BC%9F">我们将从哪里开始呢？</h3> 
<p><br> 我们刚刚介绍了 Elasticsearch 的一小部分内容。有关更多信息，请参阅 <a href="https://www.elastic.co/" rel="nofollow" title="elastic.co">elastic.co</a> 网站。一般问题可以在 <a href="https://discuss.elastic.co/" rel="nofollow" title="elastic论坛">elastic论坛</a> 上或在<a href="https://webchat.freenode.net/#elasticsearch" rel="nofollow" title="#elasticsearch">#elasticsearch</a> 的 Freenode 上的 IRC 上询问。 <a href="https://github.com/elastic" title="Elasticsearch GitHub">Elasticsearch GitHub</a> 存储库仅用于错误报告和功能请求。</p> 
<p></p> 
<h3 id="%E4%BB%8ESource%E6%9E%84%E5%BB%BA">从 Source 构建</h3> 
<p>Elasticsearch 使用 Gradle 作为其构建系统。</p> 
<p>要创建分发，只需在克隆目录中运行 ./gradlew 汇编命令。</p> 
<p>将在该项目的 build/distributions 目录下创建每个项目的分发。</p> 
<p>有关运行 Elasticsearch 测试套件的更多信息，请参阅 TESTING 文件。</p> 
<p></p> 
<h3 id="%E4%BB%8E%E6%97%A7%E7%9A%84Elasticsearch%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7">从旧的 Elasticsearch 版本升级</h3> 
<p>为了确保从早期版本的 Elasticsearch 顺利升级过程，请参阅我们的升级文档以获取有关升级过程的更多详细信息。<br>  </p> 
<h2 id="%E4%B8%8B%E4%B8%80%E6%AD%A5">下一步</h2> 
<p>如果你很想使用 Elastic 的 Kibana 来进行进行索引的操作，请参阅我的文章：</p> 
<ul><li> <p><a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/102728604" rel="nofollow" title="Elastic：开发者上手指南">Elastic：开发者上手指南</a></p> </li><li><a href="https://elasticstack.blog.csdn.net/article/details/99413578" rel="nofollow" title="如何在 Linux，MacOS 及 Windows 上进行安装 Elasticsearch">如何在 Linux，MacOS 及 Windows 上进行安装 Elasticsearch</a></li><li> <p><a href="https://blog.csdn.net/UbuntuTouch/article/details/99481016" title="开始使用 Elasticsearch （1）">开始使用 Elasticsearch （1）</a></p> </li><li> <p><a href="https://elasticstack.blog.csdn.net/" rel="nofollow" title="Elastic_Elastic 中国社区官方博客_CSDN博客-Elastic,Elasticsearch,Kibana领域博主">Elastic_Elastic 中国社区官方博客_CSDN博客-Elastic,Elasticsearch,Kibana领域博主</a></p> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4127fd555a75b35a5a2208ea1e20a727/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows命令行初步：更改配色、提示符以及编码方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/600648bcd273830fbff7b6e41ead5df8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RocketMQ的NameServer</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>