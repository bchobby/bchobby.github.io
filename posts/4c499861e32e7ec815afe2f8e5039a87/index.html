<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2.算法-贪心算法，分配问题（leetcode455发饼干，135发糖果），区间问题（435无重叠区间），练习（605种花，452射气球，122 买卖股票） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2.算法-贪心算法，分配问题（leetcode455发饼干，135发糖果），区间问题（435无重叠区间），练习（605种花，452射气球，122 买卖股票）" />
<meta property="og:description" content="一 算法解释 保证每次操作都是局部最优，局部结果互不相干，全局结果是局部结果的简单求和，从而使最后得到的结果是全局最优的。
二 分配问题 例1：leetcode题455，分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
1.题目分析：
从胃口小（数组g中最小的）的开始分配，在饼干里找能满足其胃口的且最小的（即数组中大于g【i】且最小的）分给他，然后再考虑剩下的。
贪心策略：每次给剩余孩子里胃口最小的分配能满足胃口的最小饼干
2.优化：
由于两个数组都需找出最小的，且需获得大小关系，如果直接循环遍历两次，容易一开始取到胃口最大的小孩，所以应在开始判定之前，将两个数组都由小到大排序。这样 就可以从头开始分别遍历。
然后这里如果用双层for 的话，情况会很复杂，首先两个数组谁长谁短，每个循环何时结束？都不好判断，而且可能会重复遍历。
所以这个题目用while(numchild&lt;g.size() &amp;&amp; numcookie&lt;s.size() )，一旦有一个遍历结束就结束，即要么孩子先没了，要么第一个孩子胃口大于最大的饼干，后面的孩子就都吃不了。
然后符合情况的numchild&#43;&#43;，否则就一直numcookie&#43;&#43;
3.sort（）排序函数：
sort(first_pointer,first_pointer&#43;n,cmp) 3.2 功能：该函数可以给数组，或者链表list、向量排序。
3.3 实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。
3.4参数：
此函数有3个参数：
参数1：第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。
参数2：第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。
参数3：默认可以不填，如果不填sort会默认按数组升序排序。也就是1,2,3,4排序。也可以自定义一个排序函数，改排序方式为降序什么的，也就是4,3,2,1这样。
3.5使用
使用此函数需先包含：
#include &lt;algorithm&gt; 并且导出命名空间：
using namespace std; 简单例子：对数组A的0~n-1元素进行升序排序，只要写sort(A,A&#43;n)即可；对于向量V也一样，sort(v.begin(),v.end())即可。题目中给的是两个向量gs，所以我们使用向量排序。
4.代码
class Solution { public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(),g.end());//排序 sort(s.begin(),s.end()); int numchild=0; int numcookie=0; while(numchild&lt;g." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4c499861e32e7ec815afe2f8e5039a87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-28T14:57:13+08:00" />
<meta property="article:modified_time" content="2021-01-28T14:57:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2.算法-贪心算法，分配问题（leetcode455发饼干，135发糖果），区间问题（435无重叠区间），练习（605种花，452射气球，122 买卖股票）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="__0"></a>一 算法解释</h3> 
<p>保证每次操作都是局部最优，局部结果互不相干，全局结果是局部结果的简单求和，从而使最后得到的结果是全局最优的。</p> 
<h3><a id="__3"></a>二 分配问题</h3> 
<h3><a id="1leetcode455_5"></a>例1：leetcode<strong>题455，分发饼干</strong></h3> 
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。<br> <img src="https://images2.imgbox.com/f8/db/zMxbGdMZ_o.png" alt="在这里插入图片描述"></p> 
<p>1.题目分析：<br> 从胃口小（数组g中最小的）的开始分配，在饼干里找能满足其胃口的且最小的（即数组中大于g【i】且最小的）分给他，然后再考虑剩下的。<br> 贪心策略：每次给剩余孩子里胃口最小的分配能满足胃口的最小饼干</p> 
<p>2.优化：<br> 由于两个数组都需找出最小的，且需获得大小关系，如果直接循环遍历两次，容易一开始取到胃口最大的小孩，所以应<strong>在开始判定之前，将两个数组都由小到大排序</strong>。这样 就可以从头开始分别遍历。<br> 然后这里如果用双层for 的话，情况会很复杂，首先两个数组谁长谁短，每个循环何时结束？都不好判断，而且可能会重复遍历。<br> 所以这个题目用while(numchild&lt;g.size() &amp;&amp; numcookie&lt;s.size() )，<strong>一旦有一个遍历结束就结束</strong>，即要么孩子先没了，要么第一个孩子胃口大于最大的饼干，后面的孩子就都吃不了。<br> 然后符合情况的numchild++，否则就一直numcookie++</p> 
<p><strong>3.sort（）排序函数</strong>：</p> 
<pre><code class="prism language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>first_pointer<span class="token punctuation">,</span>first_pointer<span class="token operator">+</span>n<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span>
</code></pre> 
<p>3.2 功能：该函数可以给数组，或者链表list、向量排序。</p> 
<p>3.3 实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。</p> 
<p>3.4参数：<br> 此函数有3个参数：<br> 参数1：第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。</p> 
<p>参数2：第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。</p> 
<p>参数3：默认可以不填，如果不填sort会默认按数组升序排序。也就是1,2,3,4排序。也可以自定义一个排序函数，改排序方式为降序什么的，也就是4,3,2,1这样。</p> 
<p>3.5使用<br> 使用此函数需先包含：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
</code></pre> 
<p>并且导出命名空间：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
</code></pre> 
<p>简单例子：对数组A的0~n-1元素进行升序排序，只要写<code>sort(A,A+n)</code>即可；对于向量V也一样，<code>sort(v.begin(),v.end())</code>即可。题目中给的是两个向量gs，所以我们使用向量排序。<br> <img src="https://images2.imgbox.com/15/4f/Io3ujr9k_o.png" alt="在这里插入图片描述"><br> 4.代码</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> g<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>g<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排序</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">int</span> numchild<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token keyword">int</span> numcookie<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token keyword">while</span><span class="token punctuation">(</span>numchild<span class="token operator">&lt;</span>g<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> numcookie<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">//一旦有一个结束就结束</span>
       <span class="token punctuation">{<!-- --></span>
           <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>numchild<span class="token punctuation">]</span><span class="token operator">&lt;=</span>s<span class="token punctuation">[</span>numcookie<span class="token punctuation">]</span><span class="token punctuation">)</span> numchild<span class="token operator">++</span><span class="token punctuation">;</span>
           numcookie<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//不管孩子吃没吃，饼干始终只能用一次，因为吃的了的话饼干没了得到下一块饼干，吃不了的话上一个胃口小的孩子吃不了下一个胃口大的孩子更吃不了。</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> numchild<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>5.总结：<br> 1.在开始判定之前，先对数组和字符串进行排序是常见操作，方便之后大小比较。<br> 2.若对连续空间变量进行操作，不区分数组和字符串，因为其本质上都是在连续空间上的有序变量集合。字符传“zfc”可以被看成数组【‘z’,‘f’,‘c’】</p> 
<h3><a id="2135_80"></a>例2：135.分发糖果</h3> 
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p> 
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p> 
<ul><li>每个孩子至少分配到 1 个糖果。</li><li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul> 
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p> 
<p><img src="https://images2.imgbox.com/60/67/C9RY79LA_o.png" alt="在这里插入图片描述"><br> 1.题目分析<br> 1.1<br> 每个孩子至少分配到1个糖果，所以n个孩子至少一开始数目就是n。<br> 1.2<br> 首先明确这个问题没有办法先排序，因为学生的站位会影响到糖果数目。接下来是两侧的问题，我们可以考虑把两侧分开来考虑：<br> 第一次for，从头开始，如果右大于左，则右加一<br> 第二次for，从尾开始，如果左大于右，则左加一<br> （那么这样说的话如果只有一个人，或者没有人，不需要遍历，直接返回.size()即可）</p> 
<p>2.优化<br> 一开始我的思路，<strong>在加一方面草率了</strong>，不能单独设置一个num一直加，应该给每个小孩都设置一个属性值，一开始都设置为1，第一次从左往右的时候，<strong>如果右大于左，右应该等于左+1</strong>，意思就是第一次从左往右应该变成一个越阶的升序12312或者112312这种。<br> 但是从右往左的时候，这个num的数值不能简单的自加（可能出现有个值被多加一），要考虑他是不是已经比两边的大了，应该在<br> <strong>他本身 和 他右边值+1 里面取max</strong>。<br> 3.代码</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> num<span class="token operator">=</span>ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token function">f</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> num<span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>ratings<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            f<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sum<span class="token operator">=</span><span class="token function">accumulate</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>f<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="__133"></a>三 区间问题</h3> 
<h3><a id="435_135"></a>例：435无重叠区间</h3> 
<p>435.给定一个区间的集合，找到需要<strong>移除区间的最小数量</strong>，使剩余区间<strong>互不重叠</strong>。</p> 
<p>注意:<br> 可以认为区间的终点总是大于它的起点。<br> 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br> <img src="https://images2.imgbox.com/39/8d/C4Iw1npB_o.png" alt="在这里插入图片描述"><br> 分析：<br> 首先，对于每个区间来说，我们先考虑它的结尾，如果第一个区间的结尾尽可能的小，那么我们留给后面区间的空间就大，也就是说需要移除的区间应该最小。因此，我们有限考虑保留结尾小，且不相交的区间。</p> 
<p>优化：<br> 可以先对每个区间进行按结尾升序排序（如果区间结尾相同那就把区间开头小的放前面），这个跟我们第一个发饼干的思路一样。这样第一个就是结尾最小的，之后我们每次选择结尾最小的和前一个被选择的比较以下有没有重叠，如果有，就移除的num++，如果没有就继续。</p> 
<p>验证一下示例：<br> 示例1： [ [1,2], [2,3], [3,4], [1,3] ]<br> 1.先排序，应该得到这样的二维数组 [ [1,2], [1,3] [2,3], [3,4] ]<br> 2.看第二个【1，3】和第一个【1，2】有没有交集，后一个数组的1比前一个数组的2小，所以有交集，【1，3】要去掉。<br> 3.【2，3】，【3，4】均无交集。</p> 
<p>示例2： [ [1,2], [1,2], [1,2] ]<br> 1.先排序 [ [1,2], [1,2], [1,2] ]<br> 2.第二个1小于第一个2，有交集，同理，去掉后两个</p> 
<p>示例3： [ [1,2], [2,3] ]<br> 1.先排序 [ [1,2], [2,3] ]<br> 2.均无交集。</p> 
<p>注意：<br> 1.sort()函数，默认的是对二维数组按照第一列的大小对每行的数组进行排序。如何进行排序，这里有一篇写的非常清楚的文章。<a href="https://lishizheng.blog.csdn.net/article/details/112250038" rel="nofollow">sort排序</a></p> 
<pre><code class="prism language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>b<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样我们就可以是实现按每个区间的结尾升序排列。</p> 
<p>代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> s<span class="token operator">=</span>intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>b<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> q2<span class="token operator">=</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//第一行第二个</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>q2<span class="token punctuation">)</span>
            <span class="token operator">++</span>num<span class="token punctuation">;</span>
            <span class="token keyword">else</span> 
            q2<span class="token operator">=</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> num<span class="token punctuation">;</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="__202"></a>四 练习</h3> 
<h3><a id="605_204"></a>题一：605.种花问题</h3> 
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，<strong>花不能种植在相邻</strong>的地块上，它们会争夺水源，两者都会死去。<br> 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。<br> 另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。<br> <img src="https://images2.imgbox.com/7a/5b/WKQWMOcU_o.png" alt="在这里插入图片描述"><br> 分析：<br> n如果=0，一定能种下。<br> 首先明确花坛里能种n朵花是一个偶然情况，不能种这么多花才是一般情况，所以只需要考虑如何能种下n朵花，其他情况均为false即可。</p> 
<p>我们从头开始遍历flowerbed数组，判别每个flowerbed【i】分两种情况：<br> 1.如果是1，表明此处有一朵花，i向右移动2(i+2)<br> 2.else如果是0，判别flowerbed【i-1】和flowerbed【i+1】是不是也是0：<br> 2.1如果都是0，那么此处可以种花，n–，i+2；<br> 2.2else，此处种不了花，i++；<br> 最后，看f是不是&gt;=n即可；</p> 
<p>优化：<br> <strong>怎么处理边界问题：<br> 在第一个元素前面和最后一个元素后面，都插入一个0，这样每次判定都可以判定连续三个数是不是0即可，不需要分头尾的情况。</strong></p> 
<p>代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">canPlaceFlowers</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> flowerbed<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    flowerbed<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>flowerbed<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左右各加个盆，避免边界情况</span>
    flowerbed<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>flowerbed<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> s<span class="token operator">=</span>flowerbed<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//n如果=0，一定能种下。</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//如果此处已经有花，直接右移2</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>flowerbed<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> flowerbed<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                n<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//种一朵</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//右移2</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//else右移1</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="42__256"></a>题二:42 射气球问题</h3> 
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p> 
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。<br> <img src="https://images2.imgbox.com/b6/8f/tlKGH2EY_o.png" alt="在这里插入图片描述"><br> <strong>注意：两个边界挨着的，可以同时引爆</strong><br> 示例分析：<br> 示例1：points = [[10,16],[2,8],[1,6],[7,12]]<br> 1.对其进行按结尾升序排列newpoints = [[1,6],[2,8],[7,12]，[10,16]]<br> 2.从【1，6】开始，num=1，pre=6；<br> 【2，8】和前有重叠，2&lt;=6,num不变，设置【2，6】为雷区，i++<br> 那么第三个区间有以下可能性：<br> 区间3的第一个数如果也&lt;=6,num不变，i++<br> 区间3的第一个数如果&gt;6,num++,i++,pre=…<br> 所以【7，12】中，7&gt;6，num++，i++，pre=12；<br> 【10，16】和前有重叠，num不变，结束</p> 
<p>示例2：points = [[1,2],[3,4],[5,6],[7,8]]<br> 1.升序排列newpoints = [[1,2],[3,4],[5,6],[7,8]]<br> 2.从【1，2】开始判断，num=1，pre=2；<br> 【3，4】无重叠，num++，i++；pre=4；<br> 【5，6】无重叠，num++，i++，pre=6；<br> 【7，8】无重叠，num++，i++；结束num=4；</p> 
<p>示例3：points = [[1,2],[2,3],[3,4],[4,5]]<br> 1.升序排列newpoints = [[1,2],[2,3],[3,4],[4,5]]<br> 2.从【1，2】开始，num=1，pre=2；<br> 【2，3】2&lt;=2,有重叠，num不变，设置【2，2】为雷区，i++<br> 【3，4】3&gt;2，无重叠，num++,i++,pre=4;<br> 【4，5】4&lt;=4,有重叠，num不变，结束。</p> 
<p>示例4：points = [[1,2]]<br> points.size()&lt;2, return points.size();</p> 
<p>示例5：points = [[2,3],[2,3]]<br> 1升序排列不变<br> 2.从【2，3】开始，num=1,pre=3；<br> 【2，3】有重叠，2&lt;=3,num不变，结束；</p> 
<p>总结就是<br> 先升序排列，预参数设置好。然后开始for循环。如果有重叠，则不操作，无重叠则 num++，pre更新；<br> 代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> points<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> s<span class="token operator">=</span>points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>
            points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>points<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>a<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>b<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> pre<span class="token operator">=</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>pre<span class="token punctuation">)</span><span class="token comment">//无重叠</span>
            <span class="token punctuation">{<!-- --></span>
                num<span class="token operator">++</span><span class="token punctuation">;</span>
                pre<span class="token operator">=</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> num<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="122__328"></a>题三：122 买卖股票</h3> 
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br> 设计一个算法来计算你所能获取的<strong>最大利润</strong>。你可以尽可能地完成<strong>更多的交易</strong>（多次买卖一支股票）<br> 注意：你不能同时参与多笔交易（你<strong>必须在再次购买前出售掉之前的股票</strong>）。<br> <img src="https://images2.imgbox.com/e8/ea/H7D7NQDS_o.png" alt="在这里插入图片描述"><br> 分析：<br> 股票无非就涨和跌两种情况，现在我们属于一种先知的情况：<br> 最开始，买不买股票，取决于第二天是涨还是跌。如果第二天涨，那我们第一天买，如果第二天跌，则不买。<br> 需要明确，如果他第三天连涨，我们没有必要每天都买卖，直接持有到他下跌为止。</p> 
<p>示例分析：<br> 示例1：[7,1,5,3,6,4]<br> 7&gt;1,第一天不买,i++（因为第二天跌了）<br> 1&lt;5，第二天买，num=-1（因为三天涨了，且手里没有买入的）<br> 5&lt;3,第三天卖出，num=5-1=4（因为第四天跌了）<br> 3&lt;6，第四天买入，num=4-3=1（因为第五天涨了）<br> 6&lt;4，第五天卖出，num=6+1=7（因为第六天跌了）<br> 第六天是最后一天，手上没有股票，结束；</p> 
<p>优化：<br> 这个循环不需要从第一天跑到最后一天，由于我们是先知，我们从第一天跑到倒数第二天即可。<br> 每一天预知第二天上涨的话，利润就加上差额。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> s<span class="token operator">=</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//明天上涨，今天就提前有利润</span>
            <span class="token punctuation">{<!-- --></span>
                num<span class="token operator">+</span><span class="token operator">=</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
              
        <span class="token keyword">return</span> num<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>



</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/269d24934ea25beb410c7fb65f5c40cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库命令速记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a90563133a91ebce14ae0521eb417176/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">idea 安装插件后 启动报错 无法进入主界面  org.picocontainer.PicoRegistrationException</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>