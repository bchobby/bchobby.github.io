<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>http协议学习系列 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="http协议学习系列" />
<meta property="og:description" content="1. 基础概念篇 1.1 介绍 HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。
HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。
HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。
1.2 在TCP/IP协议栈中的位置 HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：
默认HTTP的端口号为80，HTTPS的端口号为443。
1.3 HTTP的请求响应模型 HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：
这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。
HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。
1.4 工作流程 一次HTTP操作称为一个事务，其工作过程可分为四步：
1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。
2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。
3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。
如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。
1.5 使用Wireshark抓TCP、http包 打开Wireshark，选择工具栏上的“Capture”-&gt;“Options”，界面选择如图1所示：
图1 设置Capture选项
一般读者只需要选择最上边的下拉框，选择合适的Device，而后点击“Capture Filter”，此处选择的是“HTTP TCP port（80）”，选择后点击上图的“Start”开始抓包。
图2 选择Capture Filter
例如在浏览器中打开http://image.baidu.com/，抓包如图3所示：
http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-3.jpg
图3 抓包
在上图中，可清晰的看到客户端浏览器（ip为192.168.2.33）与服务器的交互过程：
1）No1：浏览器（192.168.2.33）向服务器（220.181.50.118）发出连接请求。此为TCP三次握手第一步，此时从图中可以看出，为SYN，seq:X （x=0）
2）No2：服务器（220.181.50.118）回应了浏览器（192.168.2.33）的请求，并要求确认，此时为：SYN，ACK，此时seq：y（y为0），ACK：x&#43;1（为1）。此为三次握手的第二步；
3）No3：浏览器（192.168.2.33）回应了服务器（220.181.50.118）的确认，连接成功。为：ACK，此时seq：x&#43;1（为1），ACK：y&#43;1（为1）。此为三次握手的第三步；
4）No4：浏览器（192.168.2.33）发出一个页面HTTP请求；
5）No5：服务器（220.181.50.118）确认；
6）No6：服务器（220.181.50.118）发送数据；
7）No7：客户端浏览器（192.168.2.33）确认；
8）No14：客户端（192.168.2.33）发出一个图片HTTP请求；
9）No15：服务器（220.181.50.118）发送状态响应码200 OK
……
1.6 头域 每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4d73bd76e4a0f49d159be5b471574913/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-07-21T14:29:18+08:00" />
<meta property="article:modified_time" content="2014-07-21T14:29:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">http协议学习系列</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <strong></strong> 
<h2>1. 基础概念篇</h2> 
<h3>1.1 介绍</h3> 
<p>  HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p> 
<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p> 
<p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p> 
<h3>1.2 在TCP/IP协议栈中的位置</h3> 
<p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：<br>     <img border="0" alt="" src="https://images2.imgbox.com/0c/c9/JILWp2tn_o.jpg" width="396" height="300"><br> </p> 
<p>默认HTTP的端口号为80，HTTPS的端口号为443。</p> 
<h3>1.3 HTTP的请求响应模型</h3> 
<p>HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：<br>    <img border="0" alt="" src="https://images2.imgbox.com/38/b4/rokGZLjQ_o.jpg" width="551" height="181"><br> </p> 
<p>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p> 
<p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。<br> </p> 
<h3>1.4 工作流程</h3> 
<p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p> 
<p>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</p> 
<p>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p> 
<p>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p> 
<p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p> 
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p> 
<h3>1.5 使用Wireshark抓TCP、http包</h3> 
<p>打开Wireshark，选择工具栏上的“Capture”-&gt;“Options”，界面选择如图1所示：<br>                             <img border="0" alt="" src="https://images2.imgbox.com/05/c4/rYqMbYSg_o.jpg" width="459" height="399"><br> </p> 
<p align="center">图1 设置Capture选项</p> 
<p>一般读者只需要选择最上边的下拉框，选择合适的Device，而后点击“Capture Filter”，此处选择的是“HTTP TCP port（80）”，选择后点击上图的“Start”开始抓包。<br>                                   <img border="0" alt="" src="https://images2.imgbox.com/f3/6f/o40fpDrP_o.jpg" width="388" height="361"><br> </p> 
<p align="center">图2 选择Capture Filter</p> 
<p>例如在浏览器中打开<a target="_blank" href="http://image.baidu.com/" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://image.baidu.com/</a>，抓包如图3所示：<br>     http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-3.jpg<br> <img border="0" alt="" src="https://images2.imgbox.com/aa/14/w1iIxKZF_o.jpg" width="614" height="142"><br> </p> 
<p align="center">图3   抓包</p> 
<p>在上图中，可清晰的看到客户端浏览器（ip为192.168.2.33）与服务器的交互过程：</p> 
<p>1）No1：浏览器（192.168.2.33）向服务器（220.181.50.118）发出连接请求。此为TCP三次握手第一步，此时从图中可以看出，为SYN，seq:X （x=0）</p> 
<p>2）No2：服务器（220.181.50.118）回应了浏览器（192.168.2.33）的请求，并要求确认，此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）。此为三次握手的第二步；</p> 
<p>3）No3：浏览器（192.168.2.33）回应了服务器（220.181.50.118）的确认，连接成功。为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。此为三次握手的第三步；</p> 
<p>4）No4：浏览器（192.168.2.33）发出一个页面HTTP请求；</p> 
<p>5）No5：服务器（220.181.50.118）确认；</p> 
<p>6）No6：服务器（220.181.50.118）发送数据；</p> 
<p>7）No7：客户端浏览器（192.168.2.33）确认；</p> 
<p>8）No14：客户端（192.168.2.33）发出一个图片HTTP请求；</p> 
<p>9）No15：服务器（220.181.50.118）发送状态响应码200 OK</p> 
<p>……</p> 
<h3>1.6 头域</h3> 
<p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p> 
<p>在抓包的图中，No14点开可看到如图4所示：<br>   <a target="_blank" href="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-4.jpg" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-4.jpg</a><br> <img border="0" alt="" src="https://images2.imgbox.com/2a/87/tnQdYttk_o.jpg" width="703" height="175"><br> </p> 
<p align="center">图4 http请求消息</p> 
<p>       回应的消息如图5所示：<br>                <img border="0" alt="" src="https://images2.imgbox.com/d2/cd/UhnnpJ9l_o.jpg" width="478" height="250"><br> </p> 
<p align="center">图5 http状态响应信息</p> 
<h4>1.6.1 host头域</h4> 
<p>Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。</p> 
<p>图5中host那行为：<br>    <img border="0" alt="" src="https://images2.imgbox.com/ec/8d/DzKnFyL1_o.jpg" width="210" height="20"><br> </p> 
<h4>1.6.2 Referer头域</h4> 
<p>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。</p> 
<p>在图4中，Referer行的内容为：<br>    <img border="0" alt="" src="https://images2.imgbox.com/75/64/IsV62JXJ_o.jpg" width="301" height="23"><br> </p> 
<h4>1.6.3 User-Agent头域</h4> 
<p>User-Agent头域的内容包含发出请求的用户信息。</p> 
<p>在图4中，User-Agent行的内容为：<br>   <a target="_blank" href="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-8.jpg" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-%e6%a6%82%e5%bf%b5-8.jpg</a><br> <br> </p> 
<h4>1.6.4 Cache-Control头域</h4> 
<p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。</p> 
<p>在图5中的该头域为：<br>    <img border="0" alt="" src="https://images2.imgbox.com/16/71/wkld923k_o.jpg" width="244" height="21"><br> <br> </p> 
<h4>1.6.5 Date头域</h4> 
<p>Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p> 
<p>图5中，该头域如下图所示：<br>    <img border="0" alt="" src="https://images2.imgbox.com/b4/e1/BI166DYr_o.jpg" width="318" height="20"><br>  </p> 
<h3>1.7 HTTP的几个重要概念</h3> 
<h4>1.7.1连接：Connection</h4> 
<p>一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。</p> 
<p>在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。</p> 
<p>在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</p> 
<h4>1.7.2消息：Message</h4> 
<p>HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。</p> 
<h4>1.7.3请求：Request</h4> 
<p>一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号。</p> 
<h4>1.7.4响应：Response</h4> 
<p>一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。</p> 
<h4>1.7.5资源：Resource</h4> 
<p>由URI标识的网络数据对象或服务。</p> 
<h4>1.7.6实体：Entity</h4> 
<p>数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</p> 
<h4>1.7.7客户机：Client</h4> 
<p>一个为发送请求目的而建立连接的应用程序。</p> 
<h4>1.7.8用户代理：UserAgent</h4> 
<p>初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。</p> 
<h4>1.7.9服务器：Server</h4> 
<p>一个接受连接并对请求返回信息的应用程序。</p> 
<h4>1.7.10源服务器：Originserver</h4> 
<p>是一个给定资源可以在其上驻留或被创建的服务器。</p> 
<h4>1.7.11代理：Proxy</h4> 
<p>一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。</p> 
<p>代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p> 
<h4>1.7.12网关：Gateway</h4> 
<p>一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。</p> 
<p>网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p> 
<h4>1.7.13通道：Tunnel</h4> 
<p>是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p> 
<h4>1.7.14缓存：Cache</h4> 
<p>反应信息的局域存储。<br> </p> 
<h2><span style="font-family:Trebuchet MS">    附录：</span>参考资料</h2> 
<p>《http_百度百科》：<a target="_blank" href="http://baike.baidu.com/view/9472.htm" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://baike.baidu.com/view/9472.htm</a></p> 
<p>《结果编码和http状态响应码》：<a target="_blank" href="http://blog.tieniu1980.cn/archives/377" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://blog.tieniu1980.cn/archives/377</a></p> 
<p>《分析TCP的三次握手》：</p> 
<p><a target="_blank" href="http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763104c8c711923d030678197027fa3c215cc7905141130a8e5747e0d548d98297a5ae91e03f7f63772315477e3cacdd94cdbbdc42225d82c36734f844315c419d891007a9f34d507a9f916a2e1b065d2f48193864353bb15543897f1fb4d711edd1b86033093b1e94e022e67adec40728e2e605f983431c5508fe4&amp;p=c6769a46c5820efd08e2973b42&amp;user=baidu" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763104c8c711923d030678197027fa3c215cc7905141130a8e5747e0d548d98297a5ae91e03f7f63772315477e3cacdd94cdbbdc42225d82c36734f844315c419d891007a9f34d507a9f916a2e1b065d2f48193864353bb15543897f1fb4d711edd1b86033093b1e94e022e67adec40728e2e605f983431c5508fe4&amp;p=c6769a46c5820efd08e2973b42&amp;user=baidu</a></p> 
<p>《使用Wireshark来检测一次HTTP连接过程》：</p> 
<p>http://blog.163.com/wangbo_tester/blog/static/12806792120098174162288/</p> 
<p>《http协议的几个重要概念》：<a target="_blank" href="http://nc.mofcom.gov.cn/news/10819972.html" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://nc.mofcom.gov.cn/news/10819972.html</a></p> 
<p>《http协议中connection头的作用》：</p>         
<a target="_blank" href="http://blog.csdn.net/barfoo/archive/2008/06/05/2514667.aspx" style="color:rgb(0,153,51)" rel="noopener noreferrer">http://blog.csdn.net/barfoo/archive/2008/06/05/2514667.aspx</a>  
<br> 
<h2>2. 协议详解篇</h2> 
<h3>2.1 HTTP/1.0和HTTP/1.1的比较</h3> 
<p>RFC 1945定义了HTTP/1.0版本，RFC 2616定义了HTTP/1.1版本。</p> 
<p>笔者在blog上提供了这两个RFC中文版的下载地址。</p> 
<p>RFC1945下载地址：</p> 
<p>http://www.blogjava.net/Files/amigoxie/RFC1945（HTTP）中文版.rar</p> 
<p>RFC2616下载地址：</p> 
<p>http://www.blogjava.net/Files/amigoxie/RFC2616（HTTP）中文版.rar</p> 
<h4>2.1.1建立连接方面</h4> 
<p>HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。</p> 
<p>注意：在同一个TCP连接中，新的请求需要等上次请求收到响应后，才能发送。</p> 
<h4>2.1.2 Host域</h4> 
<p>HTTP1.1在Request消息头里头多了一个Host域, HTTP1.0则没有这个域。</p> 
<p>Eg：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/3e/3c/zmGG6anm_o.gif">    GET /pub/WWW/TheProject.html HTTP/1.1 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/8d/91/HBa35hCh_o.gif">    Host: www.w3.org 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/8e/94/KRuEt4Ss_o.gif"> 
</div> 
<p>    可能HTTP1.0的时候认为，建立TCP连接的时候已经指定了IP地址，这个IP地址上只有一个host。</p> 
<h4>2.1.3日期时间戳</h4> 
<p>(接收方向)</p> 
<p>无论是HTTP1.0还是HTTP1.1，都要能解析下面三种date/time stamp：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/ee/38/se9HY0zI_o.gif">Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/93/8a/XetwTsgY_o.gif">Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/62/0a/YMPp4B9G_o.gif">Sun Nov 6 08:49:37 1994       ; ANSI C's asctime() format 
</div> 
<p>       (发送方向)</p> 
<p>HTTP1.0要求不能生成第三种asctime格式的date/time stamp；</p> 
<p>HTTP1.1则要求只生成RFC 1123(第一种)格式的date/time stamp。</p> 
<h4>2.1.4状态响应码</h4> 
<p>状态响应码100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p> 
<p>客户端在Request头部中包含</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/7b/fa/EWj00zYC_o.gif">Expect: 100-continue 
</div> 
<p>       Server看到之后呢如果回100 (Continue) 这个状态代码，客户端就继续发request body。这个是HTTP1.1才有的。</p> 
<p>另外在HTTP/1.1中还增加了101、203、205等等性状态响应码</p> 
<h4>2.1.5请求方式</h4> 
<p>HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT这些Request方法.</p> 
<p>       Method         = "<strong>OPTIONS</strong>"                ; Section 9.2</p> 
<p>                      | "GET"                    ; Section 9.3</p> 
<p>                      | "HEAD"                   ; Section 9.4</p> 
<p>                      | "POST"                   ; Section 9.5</p> 
<p>                      | "<strong>PUT</strong>"                    ; Section 9.6</p> 
<p>                      | "<strong>DELETE</strong>"                 ; Section 9.7</p> 
<p>                      | "<strong>TRACE</strong>"                  ; Section 9.8</p> 
<p>                      | "<strong>CONNECT</strong>"                ; Section 9.9</p> 
<p>                      | extension-method</p> 
<p>       extension-method = token</p> 
<h3>2.2 HTTP请求消息</h3> 
<h4>2.2.1请求消息格式</h4> 
<p>请求消息格式如下所示：</p> 
<p>请求行</p> 
<p>通用信息头|请求头|实体头</p> 
<p>CRLF(回车换行)</p> 
<p>实体内容</p> 
<p>其中“请求行”为：请求行 = 方法 [空格] 请求URI [空格] 版本号 [回车换行]</p> 
<p>请求行实例：</p> 
<p>Eg1：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/ca/f5/TKtaFqXh_o.gif">GET /index.html HTTP/1.1 
</div> 
<p>       Eg2：</p> 
<p>POST <a target="_parent" href="http://192.168.2.217:8080/index.jsp%20HTTP/1.1" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)"><span style="color:windowtext">http://192.168.2.217:8080/index.jsp HTTP/1.1</span></a></p> 
<p>HTTP请求消息实例：<br> </p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/c5/f5/sPNi2CHx_o.gif">GET /hello.htm HTTP/1.1 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/25/f0/pIgvNX3n_o.gif">Accept: */* 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/10/20/jiFtlMOk_o.gif">Accept-Language: zh-cn 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/36/27/tWuBhSL0_o.gif">Accept-Encoding: gzip, deflate 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/d9/c8/gnwX6tGd_o.gif">If-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/5c/9d/rdegZpBY_o.gif">If-None-Match: W/"158-1192587355000" 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/aa/a4/efgWtxTj_o.gif">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/4f/ab/TPuT12LL_o.gif">Host: 192.168.2.162:8080 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/ea/5d/n1eeNsxd_o.gif">Connection: Keep-Alive 
</div> 
<p><br> </p> 
<h4>2.2.2请求方法</h4> 
<p>       HTTP的请求方法包括如下几种：</p> 
<p>q      GET</p> 
<p>q      POST</p> 
<p>q      HEAD</p> 
<p>q      PUT</p> 
<p>q      DELETE</p> 
<p>q      OPTIONS</p> 
<p>q      TRACE</p> 
<p>q      CONNECT</p> 
<h3>2.3 HTTP响应消息</h3> 
<h4>2.3.1响应消息格式</h4> 
<p>HTTP响应消息的格式如下所示：</p> 
<p>状态行</p> 
<p>通用信息头|响应头|实体头</p> 
<p>CRLF</p> 
<p>实体内容</p> 
<p>其中：状态行 = 版本号 [空格] 状态码 [空格] 原因 [回车换行]</p> 
<p>状态行举例：</p> 
<p>Eg1：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/c3/e8/L23AGaqa_o.gif">HTTP/1.0 200 OK  
</div> 
<p>      Eg2：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/1c/ba/cvRUZ2Qz_o.gif">HTTP/1.1 400 Bad Request 
</div> 
<p>     HTTP响应消息实例如下所示：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/46/5b/1bUKC0bd_o.gif">HTTP/1.1 200 OK 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/f0/a8/oHDAl4hI_o.gif">ETag: W/"158-1192590101000" 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/f9/6b/Ngeh3DQb_o.gif">Last-Modified: Wed, 17 Oct 2007 03:01:41 GMT 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/9f/0c/ibXo4XTs_o.gif">Content-Type: text/html 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/2f/25/ktS9LowI_o.gif">Content-Length: 158 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/5e/af/LtqtoWkx_o.gif">Date: Wed, 17 Oct 2007 03:01:59 GMT 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/34/03/wclIiWpf_o.gif">Server: Apache-Coyote/1.1 
</div> 
<p>2.3.2 http的状态响应码</p> 
<h5>2.3.2.1  1**：请求收到，继续处理</h5> 
<p align="left">100——客户必须继续发出请求</p> 
<p align="left">101——客户要求服务器根据请求转换HTTP协议版本</p> 
<h5>2.3.2.2  2**：操作成功收到，分析、接受</h5> 
<p align="left">200——交易成功<br> 201——提示知道新文件的URL</p> 
<p align="left">202——接受和处理、但处理未完成</p> 
<p align="left">203——返回信息不确定或不完整</p> 
<p align="left">204——请求收到，但返回信息为空</p> 
<p align="left">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p> 
<p align="left">206——服务器已经完成了部分用户的GET请求</p> 
<h5>2.3.2.3  3**：完成此请求必须进一步处理</h5> 
<p align="left">300——请求的资源可在多处得到</p> 
<p align="left">301——删除请求数据</p> 
<p align="left">302——在其他地址发现了请求数据</p> 
<p align="left">303——建议客户访问其他URL或访问方式</p> 
<p align="left">304——客户端已经执行了GET，但文件未变化</p> 
<p align="left">305——请求的资源必须从服务器指定的地址得到</p> 
<p align="left">306——前一版本HTTP中使用的代码，现行版本中不再使用</p> 
<p align="left">307——申明请求的资源临时性删除</p> 
<h5>2.3.2.4  4**：请求包含一个错误语法或不能完成</h5> 
<p align="left">400——错误请求，如语法错误</p> 
<p align="left">401——未授权</p> 
<p align="left">HTTP 401.1 - 未授权：登录失败</p> 
<p align="left">　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败</p> 
<p align="left">　　HTTP 401.3 - ACL 禁止访问资源</p> 
<p align="left">　　HTTP 401.4 - 未授权：授权被筛选器拒绝</p> 
<p align="left">HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</p> 
<p align="left">402——保留有效ChargeTo头响应</p> 
<p align="left">403——禁止访问</p> 
<p align="left">HTTP 403.1 禁止访问：禁止可执行访问</p> 
<p align="left">　　HTTP 403.2 - 禁止访问：禁止读访问</p> 
<p align="left">　　HTTP 403.3 - 禁止访问：禁止写访问</p> 
<p align="left">　　HTTP 403.4 - 禁止访问：要求 SSL</p> 
<p align="left">　　HTTP 403.5 - 禁止访问：要求 SSL 128</p> 
<p align="left">　　HTTP 403.6 - 禁止访问：IP 地址被拒绝</p> 
<p align="left">　　HTTP 403.7 - 禁止访问：要求客户证书</p> 
<p align="left">　　HTTP 403.8 - 禁止访问：禁止站点访问</p> 
<p align="left">　　HTTP 403.9 - 禁止访问：连接的用户过多</p> 
<p align="left">　　HTTP 403.10 - 禁止访问：配置无效</p> 
<p align="left">　　HTTP 403.11 - 禁止访问：密码更改</p> 
<p align="left">　　HTTP 403.12 - 禁止访问：映射器拒绝访问</p> 
<p align="left">　　HTTP 403.13 - 禁止访问：客户证书已被吊销</p> 
<p align="left">　　HTTP 403.15 - 禁止访问：客户访问许可过多</p> 
<p align="left">　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效</p> 
<p align="left">HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</p> 
<p align="left">404——没有发现文件、查询或URl</p> 
<p align="left">405——用户在Request-Line字段定义的方法不允许</p> 
<p align="left">406——根据用户发送的Accept拖，请求资源不可访问</p> 
<p align="left">407——类似401，用户必须首先在代理服务器上得到授权</p> 
<p align="left">408——客户端没有在用户指定的饿时间内完成请求</p> 
<p align="left">409——对当前资源状态，请求不能完成</p> 
<p align="left">410——服务器上不再有此资源且无进一步的参考地址</p> 
<p align="left">411——服务器拒绝用户定义的Content-Length属性请求</p> 
<p align="left">412——一个或多个请求头字段在当前请求中错误</p> 
<p align="left">413——请求的资源大于服务器允许的大小</p> 
<p align="left">414——请求的资源URL长于服务器允许的长度</p> 
<p align="left">415——请求资源不支持请求项目格式</p> 
<p align="left">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</p> 
<p align="left">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p> 
<h5>2.3.2.5  5**：服务器执行一个完全有效请求失败</h5> 
<p align="left">　　HTTP 500 - 内部服务器错误</p> 
<p align="left">　　HTTP 500.100 - 内部服务器错误 - ASP 错误</p> 
<p align="left">　　HTTP 500-11 服务器关闭</p> 
<p align="left">　　HTTP 500-12 应用程序重新启动</p> 
<p align="left">　　HTTP 500-13 - 服务器太忙</p> 
<p align="left">　　HTTP 500-14 - 应用程序无效</p> 
<p align="left">　　HTTP 500-15 - 不允许请求 global.asa</p> 
<p align="left">　　Error 501 - 未实现</p> 
<p>HTTP 502 - 网关错误</p> 
<h3>2.4 使用telnet进行http测试</h3> 
<p>       在Windows下，可使用命令窗口进行http简单测试。</p> 
<p>       输入cmd进入命令窗口，在命令行键入如下命令后按回车：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/37/5a/cJRuxnD7_o.gif">telnet www.baidu.com 80 
</div> 
<p>       而后在窗口中按下“Ctrl+]”后按回车可让返回结果回显。</p> 
<p>接着开始发请求消息，例如发送如下请求消息请求baidu的首页消息，使用的HTTP协议为HTTP/1.1：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/1a/b5/WrtWOwBg_o.gif">GET /index.html HTTP/1.1 
</div> 
<p>   注意：copy如上的消息到命令窗口后需要按两个回车换行才能得到响应的消息，第一个回车换行是在命令后键入回车换行，是HTTP协议要求的。第二个是确认输入，发送请求。</p> 
<p>可看到返回了200 OK的消息，如下图所示：<br> <img border="0" alt="" src="https://images2.imgbox.com/1e/55/E6RNnKdD_o.jpg" width="664" height="443"><br> </p> 
<p>       可看到，当采用HTTP/1.1时，连接不是在请求结束后就断开的。若采用HTTP1.0，在命令窗口键入：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/e7/65/3DOY0STp_o.gif">GET /index.html HTTP/1.0 
</div> 
<p>      此时可以看到请求结束之后马上断开。</p> 
<p>       读者还可以尝试在使用GET或POST等时，带上头域信息，例如键入如下信息：</p> 
<div> 
 <img alt="" align="top" src="https://images2.imgbox.com/a2/62/aFuHazxJ_o.gif">GET /index.html HTTP/1.1 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/bb/07/cWuPlacj_o.gif">connection: close 
 <br> 
 <img alt="" align="top" src="https://images2.imgbox.com/eb/a7/2NyBcNFQ_o.gif">Host: www.baidu.com 
</div> 
<p>2.5 常用的请求方式</p> 
<p>       常用的请求方式是GET和POST.</p> 
<p>l         <strong>GET方式</strong>：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。</p> 
<p>l         <strong>POST方式</strong>：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：</p> 
<p>1：对现有资源的解释；</p> 
<p>2：向电子公告栏、新闻组、邮件列表或类似讨论组发信息；</p> 
<p>3：提交数据块；</p> 
<p>4：通过附加操作来扩展数据库 。</p> 
<p>从上面描述可以看出，Get是向服务器发索取数据的一种请求；而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</p> 
<p>GET与POST方法有以下区别：</p> 
<p>（1）   在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。</p> 
<p>（2）   GET方式提交的数据最多只能有1024字节，而POST则没有此限制。</p> 
<p>（3）   安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用post为好。</p> 
<p>（4）   安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。<br>  </p> 
<h3>2.6 请求头</h3> 
<p>HTTP最常见的请求头如下：</p> 
<p>l         <strong>Accept</strong>：浏览器可接受的MIME类型；</p> 
<p>l         <strong>Accept-Charset</strong>：浏览器可接受的字符集；</p> 
<p>l         <strong>Accept-Encoding</strong>：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；</p> 
<p>l         <strong>Accept-Language</strong>：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；</p> 
<p>l         <strong>Authorization</strong>：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</p> 
<p>l         <strong>Connection</strong>：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</p> 
<p>l         <strong>Content-Length</strong>：表示请求消息正文的长度；</p> 
<p>l         <strong>Cookie</strong>：这是最重要的请求头信息之一；</p> 
<p>l         <strong>From</strong>：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；</p> 
<p>l         <strong>Host</strong>：初始URL中的主机和端口；</p> 
<p>l         <strong>If-Modified-Since</strong>：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；</p> 
<p>l         <strong>Pragma</strong>：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；</p> 
<p>l         <strong>Referer</strong>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p> 
<p>l         <strong>User-Agent</strong>：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；</p> 
<p>l         <strong>UA-Pixels，UA-Color，UA-OS，UA-CPU</strong>：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p> 
<h3>2.7 响应头</h3> 
<p>HTTP最常见的响应头如下所示：</p> 
<p>l         <strong>Allow</strong>：服务器支持哪些请求方法（如GET、POST等）；</p> 
<p>l         <strong>Content-Encoding</strong>：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept-Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</p> 
<p>l         <strong>Content-Length</strong>：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容；</p> 
<p>l         <strong>Content-Type</strong>： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</p> 
<p>l         <strong>Date</strong>：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</p> 
<p>l         <strong>Expires</strong>：指明应该在什么时候认为文档已经过期，从而不再缓存它。</p> 
<p>l         <strong>Last-Modified</strong>：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</p> 
<p>l         <strong>Location</strong>：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</p> 
<p>l         <strong>Refresh</strong>：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=<a target="_blank" href="http://host/path" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)"><span style="color:windowtext">http://host/path</span></a>")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的&lt;META HTTP-EQUIV="Refresh" CONTENT="5;URL=<a target="_blank" href="http://host/path" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)"><span style="color:windowtext">http://host/path</span></a>"&gt;实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV="Refresh" ...&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p> 
<h3>2.8实体头</h3> 
<p>实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p> 
<p>l         <strong>Allow</strong>：GET,POST</p> 
<p>l         <strong>Content-Encoding</strong>：文档的编码（Encode）方法，例如：gzip，见“2.5 响应头”；</p> 
<p>l         <strong>Content-Language</strong>：内容的语言类型，例如：zh-cn；</p> 
<p>l         <strong>Content-Length</strong>：表示内容长度，eg：80，可参考“2.5响应头”；</p> 
<p>l         <strong>Content-Location</strong>：表示客户应当到哪里去提取文档，例如：<a target="_blank" href="http://www.dfdf.org/dfdf.html" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://www.dfdf.org/dfdf.html</a>，可参考“2.5响应头”；</p> 
<p>l         <strong>Content-MD5</strong>：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5: &lt;base64 of 128 MD5 digest&gt;。Eg2：dfdfdfdfdfdfdff==；</p> 
<p>l         <strong>Content-Range</strong>：随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</p> 
<p>l         <strong>Content-Type</strong>：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312       主类型/子类型；</p> 
<p>l         <strong>Expires</strong>：为0证明不缓存；</p> 
<p>l         <strong>Last-Modified：</strong>WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT<strong>.</strong></p> 
<h3>2.8扩展头</h3> 
<p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。</p> 
<p>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p> 
<p>l         <strong>Refresh</strong>：1;url=http://www.dfdf.org  //过1秒跳转到指定位置；</p> 
<p>l         <strong>Content-Disposition</strong>：头字段,可参考“2.5响应头”；</p> 
<p>l         <strong>Content-Type</strong>：WEB 服务器告诉浏览器自己响应的对象的类型。</p> 
<p>eg1：Content-Type：application/xml ；</p> 
<p>eg2：applicaiton/octet-stream；</p> 
<p><strong>Content-Disposition</strong>：attachment; filename=aaa.zip。<br>   附录：参考资料</p> 
<p>《HTTP1.1和HTTP1.0的区别》：</p> 
<p><a target="_blank" href="http://blog.csdn.net/yanghehong/archive/2009/05/28/4222594.aspx" style="color:rgb(0,153,51)" rel="noopener noreferrer">http://blog.csdn.net/yanghehong/archive/2009/05/28/4222594.aspx</a></p> 
<p>《HTTP请求（GET和POST区别）和响应》：</p> 
<p><a target="_blank" href="http://www.blogjava.net/honeybee/articles/164008.html" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://www.blogjava.net/honeybee/articles/164008.html</a><br>  </p> 
<p>《HTTP请求头概述_百度知道》：</p> 
<p><a target="_blank" href="http://zhidao.baidu.com/question/32517427.html" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://zhidao.baidu.com/question/32517427.html</a></p> 
<p>《实体头和扩展头》：</p> 
<p><a target="_blank" href="http://www.cnblogs.com/tongzhiyong/archive/2008/03/16/1108776.html" rel="nofollow noopener noreferrer" style="color:rgb(0,153,51)">http://www.cnblogs.com/tongzhiyong/archive/2008/03/16/1108776.html</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fed235339ff0f53b42f89d9fe8d23ffa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS获取地址栏参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5731896c9e0e8841d084b141a4ec728/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">libudev使用说明书</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>