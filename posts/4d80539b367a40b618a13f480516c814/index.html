<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>上海华为OD--JAVA面试总结 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="上海华为OD--JAVA面试总结" />
<meta property="og:description" content="我是2021年6月21日收到华为OD的机试邀请，华为OD机试第一次做很难，我在2019年的时候第一次接触这个机试，三道题一题不会，要想通过，前期不去LeetCode上刷题那是不可能的，好在这次面试有个华为的人事全程对接，可能是od那边真的很缺人，他们急迫想招人进去，然后给了一份常考机试题的答案给我了，一百多道，我大概花了5天时间，全部敲了一遍，机考链接给下来，有7天有效期，如果准备准备不充分的千万不要尝试去做，没过有6个月的封禁期，实在是得不偿失。想去OD的同学下面这个链接的机试题务必请务必掌握都是高频考题：
华为OD机试高频考题
下面重点讲一下本次7轮面试的面试题以及注意点：
第一轮 机试 2021年6月27日 说明机试第一和第二题一般对应LeetCode上的中等题，第三题为困难模式，总分400分，通过180分，也即是2道中等题搞出来基本就过了
第一题：
查找众数及中位数 1.众数是指一组数据中出现次数量多的那个数，众数可以是多个 2.中位数是指把一组数据从小到大排列，最中间的那个数，如果这组数据的个数是奇数，那最中间那个就是中位数，如果这组数据的个数为偶数，那就把中间的两个数之和除以2，所得的结果就是中位数 3.查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数 输入描述: 输入一个一维整型数组，数组大小取值范围 0&lt;N&lt;1000，数组中每个元素取值范围 0&lt;E&lt;1000 输出描述: 输出众数组成的新数组的中位数 示例1： 输入 10 11 21 19 21 17 21 16 21 18 15 输出 21 示例2： 输入 2 1 5 4 3 3 9 2 7 4 6 2 15 4 2 4 输出 3 示例3： 输入 5 1 5 3 5 2 5 5 7 6 7 3 7 11 7 55 7 9 98 9 17 9 15 9 9 1 39 输出 7 答案(测试用例通过100%)，【注：最终得分=用例通过率*本题总分数】" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4d80539b367a40b618a13f480516c814/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-28T13:28:46+08:00" />
<meta property="article:modified_time" content="2021-07-28T13:28:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">上海华为OD--JAVA面试总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我是2021年6月21日收到华为OD的机试邀请，华为OD机试第一次做很难，我在2019年的时候第一次接触这个机试，三道题一题不会，要想通过，前期不去LeetCode上刷题那是不可能的，好在这次面试有个华为的人事全程对接，可能是od那边真的很缺人，他们急迫想招人进去，然后给了一份常考机试题的答案给我了，一百多道，我大概花了5天时间，全部敲了一遍，机考链接给下来，有7天有效期，如果准备准备不充分的千万不要尝试去做，没过有6个月的封禁期，实在是得不偿失。想去OD的同学下面这个链接的机试题务必请务必掌握都是高频考题：</p> 
<p><a href="https://gitee.com/xwl123456_admin_admin/gulimall/blob/master/HUAWEI-ComputerTest/src/com/xuwenfei/huawei/%E7%AD%94%E6%A1%88.txt" rel="nofollow">华为OD机试高频考题</a></p> 
<p>下面重点讲一下本次7轮面试的面试题以及注意点：</p> 
<h2>第一轮 机试  2021年6月27日</h2> 
<p>说明机试第一和第二题一般对应LeetCode上的中等题，第三题为困难模式，总分400分，通过180分，也即是2道中等题搞出来基本就过了</p> 
<p>第一题：</p> 
<pre><code class="language-bash">查找众数及中位数
1.众数是指一组数据中出现次数量多的那个数，众数可以是多个
2.中位数是指把一组数据从小到大排列，最中间的那个数，如果这组数据的个数是奇数，那最中间那个就是中位数，如果这组数据的个数为偶数，那就把中间的两个数之和除以2，所得的结果就是中位数
3.查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数

输入描述:
输入一个一维整型数组，数组大小取值范围 0&lt;N&lt;1000，数组中每个元素取值范围 0&lt;E&lt;1000
输出描述:
输出众数组成的新数组的中位数

示例1：
输入
10 11 21 19 21 17 21 16 21 18 15
输出
21
示例2：
输入
2 1 5 4 3 3 9 2 7 4 6 2 15 4 2 4
输出
3
示例3：
输入
5 1 5 3 5 2 5 5 7 6 7 3 7 11 7 55 7 9 98 9 17 9 15 9 9 1 39
输出
7
</code></pre> 
<p>答案(测试用例通过100%)，【注：最终得分=用例通过率*本题总分数】</p> 
<pre><code class="language-java">import java.util.*;
public class Main {
    public static void main(String[] args) {
        // 输入
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        String[] s = input.split(" ");
        int[] nums = new int[s.length];
        for (int i = 0; i &lt; nums.length; i++) {
            nums[i] = Integer.parseInt(s[i]);
        }
        scanner.close();
        // 获取众数数组和中位数
        Integer[] manyNums = getManyArr(nums);
        int medium = 0;
        int len = manyNums.length;
        if (len % 2 == 0) {
            medium = (manyNums[len / 2 - 1] + manyNums[len / 2]) / 2;
        } else {
            medium = manyNums[len / 2];
        }
        System.out.println(medium);
    }

    private static Integer[] getManyArr(int[] arr) {
        if (arr == null) {
            return new Integer[0];
        }
        // 将数组元素和出现的次数转换为key-value
        Map&lt;Integer, Integer&gt; countMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; arr.length; i++) {
            int current = arr[i];
            if (countMap.containsKey(current)) {
                Integer count = countMap.get(current);
                countMap.put(current, ++count);
            } else {
                countMap.put(current, 1);
            }
        }
        // 获取出现最多的次数
        int countMax = 0;
        for (int value : countMap.values()) {
            if (value &gt; countMax) {
                countMax = value;
            }
        }
        // 获取众数，并排序
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int key : countMap.keySet()) {
            if (countMap.get(key) == countMax) {
                list.add(key);
            }
        }
        list.sort(new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1 - o2;
            }
        });
        Integer[] newArr = new Integer[list.size()];
        return list.toArray(newArr);
    }
}
</code></pre> 
<p> 第二题：LeetCode第152题</p> 
<pre><code>152. 乘积最大子数组
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

 

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

</code></pre> 
<p>用例通过100%答案：</p> 
<pre><code class="language-java">public class Solution {
    public int maxProduct(int[] nums) {
        int length = nums.length;
        int[] maxF = new int[length];
        int[] minF = new int[length];
        System.arraycopy(nums, 0, maxF, 0, length);
        System.arraycopy(nums, 0, minF, 0, length);
        for (int i = 1; i &lt; length; ++i) {
            maxF[i] = Math.max(maxF[i - 1] * nums[i], Math.max(nums[i], minF[i - 1] * nums[i]));
            minF[i] = Math.min(minF[i - 1] * nums[i], Math.min(nums[i], maxF[i - 1] * nums[i]));
        }
        int ans = maxF[0];
        for (int i = 1; i &lt; length; ++i) {
            ans = Math.max(ans, maxF[i]);
        }
        return ans;
    }
}
</code></pre> 
<p>第三题LeetCode第65题：</p> 
<pre><code class="language-bash">有效数字（按顺序）可以分成以下几个部分：

一个 小数 或者 整数
（可选）一个 'e' 或 'E' ，后面跟着一个 整数
小数（按顺序）可以分成以下几个部分：

（可选）一个符号字符（'+' 或 '-'）
下述格式之一：
至少一位数字，后面跟着一个点 '.'
至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
一个点 '.' ，后面跟着至少一位数字
整数（按顺序）可以分成以下几个部分：

（可选）一个符号字符（'+' 或 '-'）
至少一位数字
部分有效数字列举如下：

["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]
部分无效数字列举如下：

["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]
给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。

 

示例 1：

输入：s = "0"
输出：true
示例 2：

输入：s = "e"
输出：false
示例 3：

输入：s = "."
输出：false
示例 4：

输入：s = ".1"
输出：true
</code></pre> 
<p>答案(这道题参考标准答案太难了)：</p> 
<pre><code class="language-java">public class Solution {
    public boolean isNumber(String s) {
        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = new HashMap&lt;State, Map&lt;CharType, State&gt;&gt;();
        Map&lt;CharType, State&gt; initialMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);
            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);
            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);
        }};
        transfer.put(State.STATE_INITIAL, initialMap);
        Map&lt;CharType, State&gt; intSignMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);
            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);
        }};
        transfer.put(State.STATE_INT_SIGN, intSignMap);
        Map&lt;CharType, State&gt; integerMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);
            put(CharType.CHAR_EXP, State.STATE_EXP);
            put(CharType.CHAR_POINT, State.STATE_POINT);
        }};
        transfer.put(State.STATE_INTEGER, integerMap);
        Map&lt;CharType, State&gt; pointMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);
            put(CharType.CHAR_EXP, State.STATE_EXP);
        }};
        transfer.put(State.STATE_POINT, pointMap);
        Map&lt;CharType, State&gt; pointWithoutIntMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);
        }};
        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);
        Map&lt;CharType, State&gt; fractionMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);
            put(CharType.CHAR_EXP, State.STATE_EXP);
        }};
        transfer.put(State.STATE_FRACTION, fractionMap);
        Map&lt;CharType, State&gt; expMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);
        }};
        transfer.put(State.STATE_EXP, expMap);
        Map&lt;CharType, State&gt; expSignMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
        }};
        transfer.put(State.STATE_EXP_SIGN, expSignMap);
        Map&lt;CharType, State&gt; expNumberMap = new HashMap&lt;CharType, State&gt;() {<!-- -->{
            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
        }};
        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);

        int length = s.length();
        State state = State.STATE_INITIAL;

        for (int i = 0; i &lt; length; i++) {
            CharType type = toCharType(s.charAt(i));
            if (!transfer.get(state).containsKey(type)) {
                return false;
            } else {
                state = transfer.get(state).get(type);
            }
        }
        return state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;
    }

    public CharType toCharType(char ch) {
        if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
            return CharType.CHAR_NUMBER;
        } else if (ch == 'e' || ch == 'E') {
            return CharType.CHAR_EXP;
        } else if (ch == '.') {
            return CharType.CHAR_POINT;
        } else if (ch == '+' || ch == '-') {
            return CharType.CHAR_SIGN;
        } else {
            return CharType.CHAR_ILLEGAL;
        }
    }

    enum State {
        STATE_INITIAL,
        STATE_INT_SIGN,
        STATE_INTEGER,
        STATE_POINT,
        STATE_POINT_WITHOUT_INT,
        STATE_FRACTION,
        STATE_EXP,
        STATE_EXP_SIGN,
        STATE_EXP_NUMBER,
        STATE_END
    }

    enum CharType {
        CHAR_NUMBER,
        CHAR_EXP,
        CHAR_POINT,
        CHAR_SIGN,
        CHAR_ILLEGAL
    }
}
</code></pre> 
<p>第一轮三道机试，我最终应该拿到280，测试的时候 第一道100%通过，第二道测试100%通过，第三道40%，那么总分就是280分，这样机试第一轮就过了。</p> 
<h2>第二轮 性格测试 时间2021年7月2日</h2> 
<p>性格测试也是机试，可不要小看性格测试，我有个同事机试过了挂在性格测试上面，为什么这么说呢，性格测试，是在测试你是否和华为的价值观相符，测试之前请好好了解一下华为的企业价值观，无非就是华为是数字型企业，你将从事数字化工作，华为奉承奋斗者文化、狼性文化、奉献文化，你将吃苦耐劳，能在重压之下成长，明确自己在公司的定位，做技术就专心做技术，不要朝三暮四的，等等吧，一共102道选择题，每组2道，一共51组，每组选出一个最符合你的描述，选出一个最不符合你的描述，时间是30分钟内做完，非常难选，你稍微选错了，就无缘了，反正你选的是要尽量要仔细，把自己的价值观往华为公司的价值观上靠拢，这样被淘汰。我选完手心冒汗，因为太难做出选择，不过最后还是通过的。</p> 
<h2>第三轮 技术面试第一轮 时间2021年7月7日</h2> 
<p>性格测试通过以后才是真正的技术面试了，面试事宜视频面试举行的，面试时候保持环境安静，不要太吵了，影响面试体感，穿着上正式一点，上身穿件带领的寸衫吧，面试前提前15分钟进入房间测试语音和摄像头，电脑视频面试的，所以保证你的电脑是带摄像头的，因为面试官要共享你的电脑屏幕，让你手撕一道算法题，我第一轮那个面试官人很话不多，上来就是，你先写一道算法题吧。题目如下：</p> 
<pre><code>注：此题是LeetCode第三题
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度
 * 输入: s = "abcabcbb"
 * 输出: 3
 * 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
 * 输入: s = "bbbbb"
 * 输出: 1
 * 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
 * 输入: s = "pwwkew"
 * 输出: 3
 * 解释: 因为无重复字符的最长子串是"wke"，所以其长度为 3。
 * 请注意，你的答案必须是 子串 的长度，"pwke"是一个子序列，不是子串。
 * 输入: s = ""
 * 输出: 0</code></pre> 
<p>我当时的答案：</p> 
<pre><code class="language-java">package leetcode;

/**
 * @author:
 * @description 无重复字符的最长子串
 * @create 2021-07-07 13:56
 * @Copyright (C), 2006-2021, 
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Set;

/**
 * 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度
 * 输入: s = "abcabcbb"
 * 输出: 3
 * 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
 * 输入: s = "bbbbb"
 * 输出: 1
 * 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
 * 输入: s = "pwwkew"
 * 输出: 3
 * 解释: 因为无重复字符的最长子串是"wke"，所以其长度为 3。
 * 请注意，你的答案必须是 子串 的长度，"pwke"是一个子序列，不是子串。
 * 输入: s = ""
 * 输出: 0
 */
public class Test_3 {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String str = bufferedReader.readLine();
        System.out.println(solve(str));
        //System.out.println(solve(new Scanner(System.in).nextLine()));
    }

    static int solve(String str) {
        int ans = 0, n = str.length(), rk = -1;
        Set&lt;Character&gt; occ = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            if (i != 0) {
                occ.remove(str.charAt(i - 1));
            }
            while (rk + 1 &lt; n &amp;&amp; !occ.contains(str.charAt(rk + 1))) {
                occ.add(str.charAt(rk + 1));
                ++rk;
            }
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}</code></pre> 
<p>手撕算法有时间限制的，一般在15分钟就要写完，超时直接挂</p> 
<p>写完以后，就开始正式进入提问环节了，首先进行自我介绍</p> 
<p>自我介绍无非自己受教育经历、工作经历，其中你说的时候要注意你的项目描述，一般建议这样描述，项目背景是什么、项目主要解决了什么问题、项目的主要介绍架构、项目前、后端、运维分布使用了什么技术栈、项目的人员规模、你在项目里担任的角色(一般就说核心开发人员，核心二字请务必加上)、最后描述下你在项目里遇到重难点技术问题你是怎么解决的，我一般会说前后端跨域怎么解决的、分布式系统全局session怎么解决的、第三方登录、单点登录、分布式事务怎么控制的、事务一致性怎么保证的、缓存穿透、击穿、雪崩分别怎样保证的、mysql的分库分表怎样设计的等等，最好有这块的经验，不然很难，推荐去尚硅谷和黑马找对应的视频看看。</p> 
<p>我介绍完大概10分钟吧，你说完，请补充一句，我的个人学习和工作情况就是这样的，请问您还有什么需要了解的吗？这样就平滑过渡到面试官的发文环节了</p> 
<p>第一轮技术问题如下：</p> 
<p>1.说下java集合，以及他们之间的区别(很多，详细说)</p> 
<p>2.说下get和post的请求之间的区别</p> 
<p>3.熟下MVC模式设计原则和好处</p> 
<p>4.说下servlet是不是线程安全的</p> 
<p>5.说下SpringMVC的主要组件以及请求流程(6个组件，11个流程，务必牢记)</p> 
<p>6.讲一下mysql的优化原则，已经索引失效的场景，以及为什么会失效</p> 
<p>7.讲一下spirng 的IOC和AOP的原理</p> 
<p>8.讲一下redis的数据结构，以及你在项目中的使用场景有哪些</p> 
<p>9.讲一下Sringboot自动注解的原理，已经他的启动原理</p> 
<p>10.讲下数据库的隔离级别，脏库、幻读、不可重复读，分别是什么概念</p> 
<p>11.讲下hashMap和hashTable的底层实现以及底层的扩容机制</p> 
<p>12.讲下你项目中遇到的困难，以及你怎样解决的</p> 
<p>然后面试官向你发问，你有什么问题想问他，精心准备几个吧</p> 
<p>你可准备的问题如下：</p> 
<pre><code>1.如果顺利入职，公司这边对我的安排是怎样的？
2.公司这边做的项目主要是什么，技术栈是什么？
3.公司这边有没有一些知识分享的平台？
4.面的好就问，你觉得我在这次面试中表现的怎么样，我们还有机会再见吗？
</code></pre> 
<p>第一轮面试持续时间70分钟</p> 
<h2>第四轮  技术面试第二轮 时间 2021年7月12日</h2> 
<p>本轮技术面试是一位中年面试官，很严肃，这一轮不是先手撕代码，还是先自我介绍，说辞如上，这里不再赘述。直接到发问环节</p> 
<p>1.说下双亲委派原则以及类加载机制，双亲委派有何好处</p> 
<p>2.你说你做过架构设计，那你的输入是什么，输出是什么，UML设计原则讲一下(卧槽，这种题我哪儿会，我都听蒙了，输入输出，UML，完全没搞过呀，不知道就说自己不知道，输入就说需求文档，输出就说prd文档，UML设计干脆说自己没搞过，就说自己架构图是简单的png图片)</p> 
<p>3.讲一下你项目怎样进行单元测试的，输入输出又是什么？(这边我又听蒙了，可能这就是小厂和大厂的区别吧，规范都没有，我傻乎乎的说，我们用postman进行整个模块测试，单元测试很少，业务场景用不上)</p> 
<p>4.说下hashMap的底层实现，以及扩容机制</p> 
<p>5.你们项目里怎样对代码进行质量把控，又是输入输出，我说我们用sonar代码检测质量工具进行分析的，然后针对需要的优化的代码会尽心提示，然后他又问，你这个检测工具界面是什么样的，你看什么指标，我的天，追到这里就看你有无实际的项目经验，然后他又说你这里的异常代码，有哪些，你项目中的异常都有哪些，说5个，并说出出现场景、我说了5个 数组越界异常、空指针异常、算术异常、类转换异常、类找不到异常等等</p> 
<p>6.你刚才说sonar检测代码，那为什么在编辑CICD的时候不单独拉取一个流水线进行检测呢，我的理由就是一条jenkinsfile文件集成多个步骤，主要为了节省共工作量，然后后面，他针对我的K8S集群和CICD流水线部署做了一些建议，你虚心接收就行了</p> 
<p>7.好了，咱们来写一道算法题，题目如下，15分钟内完成</p> 
<pre><code class="language-bash"> * * 示例 1:
 * * 输入: "(()"
 * * 输出: 2
 * * 解释: 最长有效括号子串为 "()"
 * * 示例 2:
 * * 输入: ")()())"
 * * 输出: 4
 * * 解释: 最长有效括号子串为 "()()"
 * * 示例 3:
 * * 输入: "(())(()"
 * * 输出: 6
 * * 解释: 最长有效括号子串为 "(())()"</code></pre> 
<p>标准答案：</p> 
<pre><code class="language-java">package test;

/**
 * @author:
 * @description
 * @create 2021-07-12 20:01
 * @Copyright (C), 2006-2021, 
 */

import java.util.Scanner;
import java.util.Stack;

/**
 * * 示例 1:
 * * 输入: "(()"
 * * 输出: 2
 * * 解释: 最长有效括号子串为 "()"
 * * 示例 2:
 * * 输入: ")()())"
 * * 输出: 4
 * * 解释: 最长有效括号子串为 "()()"
 * * 示例 3:
 * * 输入: "(())(()"
 * * 输出: 6
 * * 解释: 最长有效括号子串为 "(())()"
 * *
 * * class Solution {
 * *     public int longestValidParentheses(String s) {
 * *     }
 * * }
 */
public class OdTest_02 {
    public static void main(String[] args) {
        System.out.println(solve(new Scanner(System.in).nextLine()));
    }

    static int solve(String str) {
        int max = 0;
        if (str == null) {
            return 0;
        }
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i &lt; str.length(); i++) {
            if (str.charAt(i) == '(') {
                stack.push('(');
                continue;
            } else {
                if (stack.isEmpty()) {
                    continue;
                } else {
                    stack.pop();
                    max += 2;
                }
            }
        }
        return max;
    }
}</code></pre> 
<p>写完后，让我问他几个问题，我还是问了技术一轮面试问的问题</p> 
<p>总结，这一轮面试明显吃力很多，面试时间持续60分钟，这一轮面试侧重点在于对你简历上的项目进行深度发掘，深追你项目问题，算法题，我自己写的时候测试用例三，不满足，面试官提示了很多，最后才写出上面的答案，主要是自己算法太菜了，也太难了，不过后来他还是当面说，这一轮放你过，此时我终于松了一口气。</p> 
<h2>第五轮 华为HRBP 人力资源官面试 时间2021年7月13日</h2> 
<p>经历技术一轮和二轮面试 也是华为那边的对接人事为了缓解氛围，来一轮HR面试，面试形式也就是视频面试，这一轮面试，首先是自我介绍，因为人事面试，所以呢，会重点关心你为什么离职的原因，就照实说吧，第一次因为疫情公司倒闭，第二次因为想去华为公司，无奈学历不够，经验来凑，只能社招进华为OD，然后就疯狂舔华为公司，想过，你懂得，就说他是技术创新高低，中国高科技公司的一面旗帜，从新闻得知华为公司多牛逼，以一个公司的力量对抗超级大国美国的制裁，依然业绩坚挺，等等反正就是往好的方向说，我说完，面试官心里乐滋滋的，然后说我这种人特别适合来华为OD干，最后呢他简单聊了一下OD和自营的区别，整体上无非就是，自营有股票，OD没有股票，工牌和华为一样，在一起办公，技术氛围好，成长快，压力大，工资不低，然后就问我期望多少薪资了，整体而言，整个过程都在一种轻松的环境里度过的，面试持续时间30分钟</p> 
<h2>第六轮  部门技术主管面试  时间2021年7月14日</h2> 
<p>这一轮面试时间很仓促，因为要协调面试官的面试时间，形式也是视频面试，这一轮部门主管面试，延续技术二轮面试一样，氛围紧张，上来也是手撕一道算法题，LeetCode第64题，如下，</p> 
<pre><code class="language-java">package leetcode;

/**
 * @author:
 * @description 动态规划-最小路径之和
 * @create 2021-07-14 10:09
 * @Copyright (C), 2006-2021, 
 */

/**
 * 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
 * 说明：每次只能向下或者向右移动一步。
 */
public class Test_64 {
    public static void main(String[] args) {
        int[][] arr = new int[][]{
                {1, 0, 0, 0},
                {1, 2, 2, 0},
                {1, 3, 7, 0},
                {0, 3, 0, 0}
        };
        System.out.println(solve(arr));
    }

    static int solve(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) {
            return 0;
        }
        int rows = arr.length, columns = arr[0].length;
        int[][] dp = new int[rows][columns];
        dp[0][0] = arr[0][0];
        for (int i = 1; i &lt; rows; i++) {
            dp[i][0] = dp[i - 1][0] + arr[i][0];
        }
        for (int j = 1; j &lt; columns; j++) {
            dp[0][j] = dp[0][j - 1] + arr[0][j];
        }
        for (int i = 1; i &lt; rows; i++) {
            for (int j = 1; j &lt; columns; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + arr[i][j];
            }
        }
        return dp[rows - 1][columns - 1];
    }
}</code></pre> 
<p>做完后面展开发问：</p> 
<p>1.介绍项目，不再赘述</p> 
<p>2.讲一下常用的springcloud组件</p> 
<p>3.讲一下，soringboot的自动配置原理</p> 
<p>4.Mybaties的一二级缓存有什么区别、原理、怎么开启，画一下你项目里的mybaties的一二级原理图</p> 
<p>5.JVM内存模型说下，分别存放什么</p> 
<p>6.GC的整个流程讲一下</p> 
<p>7.monitor gc 、Major GC 、Full GC的区别，以及常用参数</p> 
<p>8.Spring Bean 的生命周期</p> 
<p>9.HashMap 和 hashTable 区别？</p> 
<p>10.线上服务 CPU 很高该怎么做？有哪些措施可以找到问题</p> 
<p>11.JDK 中有哪几个线程池？顺带把线程池讲了个遍</p> 
<p>12.线程池的异步编排使用场景，以及线程池的参数</p> 
<p>13.Concurrenthashmap 是怎么做到线程安全的？</p> 
<p>总结：部门主管面试持续时间75分钟，重点也是聊了项目，至于后续的常见问题和二轮面试并无区别</p> 
<h2>第七轮 综合面试 时间2021年7月24日</h2> 
<p>这一轮面试持续时间大约为35分钟，一共提问了8个问题</p> 
<p>1.项目架构设计你的输入输出是什么，UML设计原则是什么？</p> 
<p>2.技术选型你是怎么考虑的，有哪些因素，我的回答，技术成本、技术开源社区活跃度，讲一下这些场景你的实际应用</p> 
<p>3.你认为你最大的优势是什么</p> 
<p>4.你对华为公司有哪些了解</p> 
<p>5.你未来的工作方向</p> 
<p>6.你在杭州为什么选择来上海</p> 
<p>7.你认为你自己有没有被不公平对待过，说一下你的真实想法</p> 
<p>8.你有家人或者朋友在华为上班吗？</p> 
<h2>总结</h2> 
<p>        整个面试走完大概花了5周时间，昨天通知我提交审核材料，如果审核通过，offer就会下来，如果offer能下来，我在补充od的福利待遇吧。</p> 
<p>        面试是综合性的，面试官问你的问题，没有标准答案，面试的过程看中的是你的表述能力以及是否自信，总体上有个积极乐观、开放自信、衣冠得体、基础扎实、心态健康的人能容易面试成功，自信非常重要，我在面试第一轮的时候，让我手撕代码，我差点放弃，有时候面试坚持住了，可能就成功，总之，IT行业不是养老行业，技术迭代太快，唯一能顺应时代发展的唯有努力学习，不断提升。最后说下,简单聊下工作岗位的问题，现在的趋势是，在工作岗位整体不变的情况下，每年仍有1000多万应届毕业生加入进来，争抢好的工作岗位，如果自身学历、专业并不占优的情况下，请看清形式，深度了解自己在这个竞争潮流中的所处的地位，如果你没有合适的大厂offer，华为OD是你比较好的选择之一，工作无非就是为了挣钱养家，所以有时候别放不开你的面子，能挣钱的工作就是好工作，先让自己活下来，再去讨论自己要过得更好的话题，好了，我的面试经验就写到这里吧。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80a66178fdfb51e28f8a61b99d6ffbe0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">历年计算机使用人数变化,历年高考人数和录取率统计-数据可视化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e71ad81d4b895aba39a83a8e36d8aa60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【FDCAN】STM32G0B1&#43;FDCAN&#43;HAL库调试记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>