<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python模块：Scipy.optimize.minimize规划问题求解 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python模块：Scipy.optimize.minimize规划问题求解" />
<meta property="og:description" content="目录
一、模块介绍
二、模块源分析与参数解释
三、实例求解
四、参考
一、模块介绍 1.1模块功能 Scipy.optimize是Scipy中一个用于解决数学模型中优化类模型的子包，该子包中又包含了多个子功能模块见下表，不同方法不同条件求解最优化模型。本节介绍minimize对一般规划问题的模型建立与求解。
问题类型模块多元标量函数的有/无约束最小化minimize最小二乘法最小化least_squares单变量函数最小化器minimize_scalar线性规划linprog 1.2模型介绍 多元标量函数的最小化，是数学规划模型中更为一般的模型，该模块包括有限制性约束和无限制性约束的最小化，而对于限制性约束又分为线性约束和非线性约束。这种更为一般的模型需要针对具体的问题假设选择特定的方法进行求解。
在数学规划模型中，minimize提供的方法能够解决无/有（线性、非线性）约束的多个决策变量目标函数的最优化问题，但是由于该模块是依据函数导数与梯度进行求解，不能够求解整数规划、01规划等问题。
二、模块源分析与参数解释 2.1模块整体介绍 对于整个多元标量的最小化问题，主要的api为optimize包下的minimize函数。该minimize函数的完整参数详情如下。同时，对于不同的method方法，函数的参数也会有相应的限制，这在具体的方法介绍中具体介绍。
minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None) 该函数主要参数意义解释：
fun待求解的目标函数x0初始猜测的数组args目标函数带参数时需要指定method选择的方法jacjacobian矩阵或梯度函数（梯度求解的方法需要传入）hesshessian矩阵hessp黑塞向量积bounds寻优范围constraints限制约束tol浮动，可以理解为单次寻找的步长上限，越小精度越高callback回调函数options选项字典，不同方法有不同选项 完整的方法options可通过optimize的show_options方法访问
from scipy.optimize import show_options print(show_options(method=&#39;minimize&#39;)
该模块提供求解方法字典如下, 通过optimize包导入minimize后，对minimize传入method参数指定方法。而对于不同方法的选用,便有不同的求解策略。我们选择部分主要方法介绍。
MINIMIZE_METHODS = [&#39;nelder-mead&#39;, &#39;powell&#39;, &#39;cg&#39;, &#39;bfgs&#39;, &#39;newton-cg&#39;, &#39;l-bfgs-b&#39;, &#39;tnc&#39;, &#39;cobyla&#39;, &#39;slsqp&#39;, &#39;trust-constr&#39;, &#39;dogleg&#39;, &#39;trust-ncg&#39;, &#39;trust-exact&#39;, &#39;trust-krylov&#39;] 无约束多元标量最小化选择以下4个方法：
nelder-mead powellbfgsnewton-cg 有约束多元标量最小化选择方法：
trust-constr 对于更多的方法可以访问该文档查询：完整方法文档
2.2 各方法详细介绍 2.2.1 nelder-mead 方法完名称为Nelder-Mead Simplex algorithm Nelder-Mead单纯形法，该方法通过对可行域顶点不断迭代选出最优解。由于是迭代寻优策略，可以指定寻优范围。
该方法对应参数：
scipy.optimize.minimize(fun, x0, args=(), method=&#39;Nelder-Mead&#39;, bounds=None, tol=None, callback=None, options={&#39;func&#39;: None, &#39;maxiter&#39;: None, &#39;maxfev&#39;: None, &#39;disp&#39;: False, &#39;return_all&#39;: False, &#39;initial_simplex&#39;: None, &#39;xatol&#39;: 1e-5, &#39;fatol&#39;: 1e-5, &#39;adaptive&#39;: False})" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4e330595cc1e84033d8035a392dbe49b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-19T13:53:50+08:00" />
<meta property="article:modified_time" content="2022-08-19T13:53:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python模块：Scipy.optimize.minimize规划问题求解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D" rel="nofollow">一、模块介绍</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A" rel="nofollow">二、模块源分析与参数解释</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AE%9E%E4%BE%8B%E6%B1%82%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%9E%E4%BE%8B%E6%B1%82%E8%A7%A3" rel="nofollow">三、实例求解</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%8F%82%E8%80%83-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%8F%82%E8%80%83" rel="nofollow">四、参考</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><strong>一、模块介绍</strong></h3> 
<h4><strong>1.1模块功能</strong></h4> 
<p>        Scipy.optimize是Scipy中一个用于解决数学模型中优化类模型的子包，该子包中又包含了多个子功能模块见下表，不同方法不同条件求解最优化模型。本节介绍<strong>minimize</strong>对一般规划问题的模型建立与求解。</p> 
<table border="1" cellpadding="1" cellspacing="1"><caption></caption><tbody><tr><td>问题类型</td><td>模块</td></tr><tr><td>多元标量函数的有/无约束最小化</td><td>minimize</td></tr><tr><td>最小二乘法最小化</td><td>least_squares</td></tr><tr><td>单变量函数最小化器</td><td>minimize_scalar</td></tr><tr><td>线性规划</td><td>linprog</td></tr></tbody></table> 
<h4><strong>1.2模型介绍</strong>       </h4> 
<p style="margin-left:0;">        多元标量函数的最小化，是数学规划模型中更为一般的模型，该模块包括有限制性约束和无限制性约束的最小化，而对于限制性约束又分为线性约束和非线性约束。这种更为一般的模型需要针对具体的问题假设选择特定的方法进行求解。</p> 
<p>        在数学规划模型中，<strong>minimize</strong>提供的方法能够解决无/有（线性、非线性）约束的多个决策变量目标函数的最优化问题，但是由于该模块是依据函数导数与梯度进行求解，不能够求解整数规划、01规划等问题。</p> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A">二、模块源分析与参数解释</h3> 
<h4><strong>2.1模块整体介绍</strong></h4> 
<p>        对于整个多元标量的最小化问题，主要的api为optimize包下的minimize函数。该minimize函数的完整参数详情如下。同时，对于不同的method方法，函数的参数也会有相应的限制，这在具体的方法介绍中具体介绍。</p> 
<blockquote> 
 <pre>minimize(fun, x0, args=(), method=None, jac=None, hess=None,
             hessp=None, bounds=None, constraints=(), tol=None,
             callback=None, options=None)</pre> 
</blockquote> 
<p>       该函数主要参数意义解释：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>fun</td><td>待求解的目标函数</td></tr><tr><td>x0</td><td>初始猜测的数组</td></tr><tr><td>args</td><td>目标函数带参数时需要指定</td></tr><tr><td>method</td><td>选择的方法</td></tr><tr><td>jac</td><td>jacobian矩阵或梯度函数（梯度求解的方法需要传入）</td></tr><tr><td>hess</td><td>hessian矩阵</td></tr><tr><td>hessp</td><td>黑塞向量积</td></tr><tr><td>bounds</td><td>寻优范围</td></tr><tr><td>constraints</td><td>限制约束</td></tr><tr><td>tol</td><td>浮动，可以理解为单次寻找的步长上限，越小精度越高</td></tr><tr><td>callback</td><td>回调函数</td></tr><tr><td>options</td><td>选项字典，不同方法有不同选项</td></tr></tbody></table> 
<p>        完整的方法options可通过optimize的show_options方法访问</p> 
<blockquote> 
 <p>from scipy.optimize import show_options </p> 
 <p>print(show_options(method='minimize')</p> 
</blockquote> 
<p>        该模块提供求解方法字典如下,  通过optimize包导入minimize后，对minimize传入method参数指定方法。而对于不同方法的选用,便有不同的求解策略。我们选择部分主要方法介绍。</p> 
<blockquote> 
 <pre>MINIMIZE_METHODS = ['nelder-mead', 'powell', 'cg', 'bfgs', 'newton-cg',
                    'l-bfgs-b', 'tnc', 'cobyla', 'slsqp', 'trust-constr',
                    'dogleg', 'trust-ncg', 'trust-exact', 'trust-krylov']
</pre> 
</blockquote> 
<p>        无约束多元标量最小化选择以下4个方法：</p> 
<ul><li>nelder-mead </li><li>powell</li><li>bfgs</li><li>newton-cg</li></ul> 
<p>        有约束多元标量最小化选择方法：</p> 
<ul><li>trust-constr</li></ul> 
<p>        对于更多的方法可以访问该文档查询：<a class="link-info" href="https://osgeo.cn/scipy/reference/optimize.html" rel="nofollow" title="完整方法文档">完整方法文档</a></p> 
<h4><strong>2.2 各方法详细介绍</strong></h4> 
<p><strong>2.2.1 nelder-mead </strong></p> 
<p style="margin-left:0;">        方法完名称为Nelder-Mead Simplex algorithm Nelder-Mead单纯形法，该方法通过对可行域顶点不断迭代选出最优解。由于是迭代寻优策略，可以指定寻优范围。</p> 
<blockquote> 
 <p style="margin-left:0;">该方法对应参数：</p> 
 <p style="margin-left:0;">scipy.optimize.minimize(fun, x0, args=(), method='Nelder-Mead', bounds=None, tol=None, callback=None, options={'func': None, 'maxiter': None, 'maxfev': None, 'disp': False, 'return_all': False, 'initial_simplex': None, 'xatol': 1e-5, 'fatol': 1e-5, 'adaptive': False})</p> 
</blockquote> 
<blockquote> 
 <p style="margin-left:0;">特殊参数：</p> 
 <p style="margin-left:0;">         bounds        该方法不要求函数连续，可指定寻优范围</p> 
 <p style="margin-left:0;">特殊选项：</p> 
 <p style="margin-left:0;">        xatol/fatol        解与函数值迭代之间绝对误差上限值，值越小求解越慢，精度越高</p> 
</blockquote> 
<p><strong>2.2.2 powell</strong></p> 
<p style="margin-left:0;">        方法名称为鲍威尔算法，该方法通过共轭方向加速收敛，其它与单纯形法类似。</p> 
<blockquote> 
 <p style="margin-left:0;">该方法对应参数：</p> 
 <p style="margin-left:0;">scipy.optimize.minimize(fun, x0, args=(), method='Powell', bounds=None, tol=None, callback=None, options={'func': None, 'xtol': 0.0001, 'ftol': 0.0001, 'maxiter': None, 'maxfev': None, 'disp': False, 'direc': None, 'return_all': False})</p> 
</blockquote> 
<blockquote> 
 <p style="margin-left:0;">特殊参数：</p> 
 <p style="margin-left:0;">         bounds        该方法不要求函数连续，可指定寻优范围</p> 
 <p style="margin-left:0;">特殊选项：</p> 
 <p style="margin-left:0;">        xatol/fatol        解与函数值迭代之间绝对误差上限值，值越小求解越慢，精度越高</p> 
</blockquote> 
<p><strong>2.2.3 bfgs</strong></p> 
<p style="margin-left:0;">        方法名称为 BFGS（Broyden-Fletcher-Goldfarb-Shanno algorithm）拟牛顿法。算法利用梯度下降进行收敛，因此不可指定范围。该方法未传入梯度函数时通过第一次的差值估计。</p> 
<blockquote> 
 <p style="margin-left:0;">该方法对应参数：</p> 
 <p style="margin-left:0;">scipy.optimize.minimize(fun, x0, args=(), method='BFGS', jac=None, tol=None, callback=None, options={'gtol': 1e-05, 'norm': inf, 'eps': 1.4901161193847656e-08, 'maxiter': None, 'disp': False, 'return_all': False, 'finite_diff_rel_step': None})</p> 
</blockquote> 
<blockquote> 
 <p style="margin-left:0;">特殊参数：</p> 
 <p style="margin-left:0;">         jac        梯度函数</p> 
 <p style="margin-left:0;">特殊选项：</p> 
 <p style="margin-left:0;">         gtol       梯度范数上限</p> 
 <p style="margin-left:0;">        norm      范数浮动上限</p> 
 <p style="margin-left:0;">        eps        求解浮动上限</p> 
</blockquote> 
<p><strong>2.2.4 newton-cg</strong></p> 
<p style="margin-left:0;">        方法名称为NCG （Newton-Conjugate-Gradient algorithm）牛顿共轭梯度算法，该方法通过梯度函数，二阶导数的hessian矩阵形式将目标函数拟合为二次函数形式，通过该二次式梯度下降求解。</p> 
<blockquote> 
 <p style="margin-left:0;">该方法对应参数：</p> 
 <p style="margin-left:0;">scipy.optimize.minimize(fun, x0, args=(), method='Newton-CG', jac=None, hess=None, hessp=None, tol=None, callback=None, options={'xtol': 1e-05, 'eps': 1. e-08, 'maxiter': None, 'disp': False, 'return_all': False})</p> 
</blockquote> 
<blockquote> 
 <p style="margin-left:0;">特殊参数：</p> 
 <p style="margin-left:0;">         jac        梯度函数</p> 
 <p style="margin-left:0;">         hess         hessian矩阵</p> 
 <p style="margin-left:0;">         hessp        hessian向量积（与hess只需要定义一个）</p> 
 <p style="margin-left:0;">特殊选项：</p> 
 <p style="margin-left:0;">         xtol        解的平均相对误差上限</p> 
 <p style="margin-left:0;">        eps        求解浮动上限</p> 
</blockquote> 
<p><strong>2.2.5 trust-constr</strong></p> 
<p style="margin-left:0;">        方法名称为Trust-Region Constrained Algorithm信赖域约束算法， 该方法需要用用约束模块定义线性和非线性约束。线性约束与linprog中约束定义类似，而非线性约束需要定义jacobian矩阵和hessian矩阵。</p> 
<blockquote> 
 <p style="margin-left:0;">该方法对应参数：</p> 
 <p style="margin-left:0;">scipy.optimize.minimize(fun, x0, args=(), method='trust-constr', hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options={'grad': None, 'xtol': 1e-08, 'gtol': 1e-08, 'barrier_tol': 1e-08, 'sparse_jacobian': None, 'maxiter': 1000, 'verbose': 0, 'finite_diff_rel_step': None, 'initial_constr_penalty': 1.0, 'initial_tr_radius': 1.0, 'initial_barrier_parameter': 0.1, 'initial_barrier_tolerance': 0.1, 'factorization_method': None, 'disp': False})</p> 
</blockquote> 
<blockquote> 
 <p style="margin-left:0;">特殊参数：</p> 
 <p style="margin-left:0;">        bounds  变量定义域</p> 
 <p style="margin-left:0;">         jac        梯度函数</p> 
 <p style="margin-left:0;">         hess         hessian矩阵</p> 
 <p style="margin-left:0;">         hessp        hessian向量积（与hess只需要定义一个）</p> 
 <p style="margin-left:0;">        constraints        线性约束和非线性约束组成的约束列表</p> 
 <p style="margin-left:0;">特殊选项：</p> 
 <p style="margin-left:0;">        xatol/fatol   解与函数值迭代之间绝对误差上限值，值越小求解越慢，精度越高</p> 
</blockquote> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%AE%9E%E4%BE%8B%E6%B1%82%E8%A7%A3">三、实例求解</h3> 
<h4><strong>3.1 实例模型与知识补充</strong></h4> 
<p><strong>3.1.1Rosenbrock函数</strong></p> 
<p>        rosenbrock是一个常用于检测优化算法效果的函数<a href="https://baike.baidu.com/item/Rosenbrock%E5%87%BD%E6%95%B0/22781931#:~:text=%E5%9C%A8%E6%95%B0%E5%AD%A6%20%E6%9C%80%E4%BC%98%E5%8C%96%20%E4%B8%AD%EF%BC%8C%20Rosenbrock%E5%87%BD%E6%95%B0%20%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BC%98%E5%8C%96%20%E7%AE%97%E6%B3%95%20%E6%80%A7%E8%83%BD%E7%9A%84%E9%9D%9E%E5%87%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%B1Howard%20Harry,%28x%2Cy%29%3D%20%281%2C1%29%E7%82%B9%EF%BC%8C%E6%95%B0%E5%80%BC%E4%B8%BAf%20%28x%2Cy%29%3D0%E3%80%82%20%E6%9C%89%E6%97%B6%E7%AC%AC%E4%BA%8C%E9%A1%B9%E7%9A%84%E7%B3%BB%E6%95%B0%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%85%A8%E5%9F%9F%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%82%20%E5%A4%9A%E5%8F%98%E9%87%8F%E4%B8%8B%E7%9A%84%E6%89%A9%E5%B1%95%20%E7%BC%96%E8%BE%91%20%E6%92%AD%E6%8A%A5%20%E5%A4%9A%E5%8F%98%E9%87%8F%E7%9A%84Rosenbrock%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BA%8C%E7%A7%8D%E5%BD%A2%E5%BC%8F%E3%80%82" rel="nofollow" title="Rosenbrock函数_百度百科 (baidu.com)">Rosenbrock函数_百度百科 (baidu.com)</a>。</p> 
<p>该函数可以用以形式表示：</p> 
<p>                                ​​​​​​​        <img alt="f(X)=\sum_{i=1}^{N-1}100(x_{i+1}-x_{i}^{2} )^{2}+(1-x_{i})^{2}" class="mathcode" src="https://images2.imgbox.com/a2/6d/zx8LU0CX_o.png"></p> 
<p>        其中，X为N为向量表示多元标量</p> 
<p>        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        <img alt="X=(x_{1},...,x_{N})" class="mathcode" src="https://images2.imgbox.com/2a/89/VqrXy2OP_o.png"></p> 
<p>        该函数的全局最优解为：<img alt="X_{g}=(1,1,...,1)" class="mathcode" src="https://images2.imgbox.com/7e/a9/txECVgHS_o.png"></p> 
<p><strong>3.1.2 jacobian矩阵和hessian矩阵</strong></p> 
<p>        这两个矩阵是用于梯度求解方法，jacobian矩阵是函数一阶偏导形成的一个向量。hessian矩阵是二阶偏导后得到的一个N阶方阵，当指定X=X0时，在该点的hessian矩阵可表示为：</p> 
<p class="img-center"><img alt="" height="226" src="https://images2.imgbox.com/46/78/0NNf3sPW_o.png" width="428"></p> 
<p>         通过这两个矩阵可以将目标函数通过二次函数形式拟合。</p> 
<p>对于数学部分了解以上部分即可，具体的数学解释可以参考：<a href="https://baike.baidu.com/item/%E9%BB%91%E5%A1%9E%E7%9F%A9%E9%98%B5/2248782" rel="nofollow" title="黑塞矩阵_百度百科 (baidu.com)">黑塞矩阵_百度百科 (baidu.com)</a></p> 
<h4><strong>3.2 实例求解</strong></h4> 
<p><strong>3.2.1无约束多元标量最小化</strong></p> 
<p>        根据上面的介绍，我们以rosenbrock函数作为实例演示（下称rosen函数）。</p> 
<p>        先定义rosen的目标函数，梯度函数和hessian矩阵以及一些假设变量如假定范围为bounds。设定x1，x2两组初始假设值用于比较初始值对求解的影响。</p> 
<pre><code class="language-python">from scipy.optimize import minimize
import numpy as np

# 两组初始迭代值
x1=np.array([1,1.2,0.9,1.3,0.5])
x2=np.array([1,1.2,0.9,1.3,0.3])
# 以rosenbrock函数来评价优化方法
def rosen(x):
    return sum(100*(x[1:]-x[:-1]**2.0)**2+(1-x[:-1])**2.0)
# 带参的rosen函数
def rosen_(x,a,b):
    return sum(a*(x[1:]-x[:-1]**2.0)**2+(1-x[:-1])**2.0)+b
# rosen函数的梯度
def rosen_der(x):
    xm = x[1:-1]
    xm_m1 = x[:-2]
    xm_p1 = x[2:]
    der = np.zeros_like(x)
    der[1:-1] = 200*(xm-xm_m1**2) - 400*(xm_p1 - xm**2)*xm - 2*(1-xm)
    der[0] = -400*x[0]*(x[1]-x[0]**2) - 2*(1-x[0])
    der[-1] = 200*(x[-1]-x[-2]**2)
    return der
# rosen函数的hessian矩阵
def rosen_hess(x):
    x = np.asarray(x)
    H = np.diag(-400*x[:-1],1) - np.diag(400*x[:-1],-1)
    diagonal = np.zeros_like(x)
    diagonal[0] = 1200*x[0]**2-400*x[1]+2
    diagonal[-1] = 200
    diagonal[1:-1] = 202 + 1200*x[1:-1]**2 - 400*x[2:]
    H = H + np.diag(diagonal)
    return H
# 限定寻优范围
bounds=np.array([[0,2],[0,2],[0,2],[0,2],[None,None]])

</code></pre> 
<p>        各个方法的实现如下：</p> 
<pre><code class="language-python"># nelder-mead单纯形方法 初始值依赖
res11=minimize(rosen_,x1,args=(100,1),method='nelder-mead',options={'xatol': 1e-8, 'disp':True})
res12=minimize(rosen_,x1,args=(100,1),method='nelder-mead',options={'xatol': 1e-8, 'disp':True})
print('========================')
print(res11)
print('========================')
print(res12)


# powell方法
res21=minimize(rosen_,x1,args=(100,1),method='powell',tol=1e-5,bounds=bounds,options={'disp':True})
res22=minimize(rosen_,x2,args=(100,1),method='powell',bounds=bounds,options={'disp':True})
# ftol和xtol分别为函数值与x解的相对误差上限
res21_=minimize(rosen_,x1,args=(100,1),method='powell',options={'ftol':1e-8,'xtol':1e-8,'disp':True})
print('初始迭代值会对算法的收敛速度和精度产生影响========================')
print(res21.x)
print(res22.x)
print('对于精度过低，可以指定浮动上限值，通过增加代数提高算法精度========================')
print(res21_.x)


# bfgs拟牛顿方法  由于拟牛顿法采用梯度计算，不能够指定变量的寻优范围 gtol为梯度范数上限
res31=minimize(rosen,x1,method='bfgs',options={'gtol':1e-8,'disp':True})
res32=minimize(rosen,x1,method='bfgs',jac=rosen_der,options={'gtol':1e-8,'disp':True})
print('jac参数为函数梯度参数，若不指定，则通过差值估计,两者效果相差不大============')
print(res31)
print(res32)

# ncg 牛顿共轭梯度方法，先求解hessian矩阵得到二次函数拟合目标函数，再通过梯度下降求解最优
res41=minimize(rosen,x1,method='Newton-cg',jac=rosen_der,hess=rosen_hess,options={'xtol':1e-8,'disp':True})
print(res41)</code></pre> 
<p><strong>3.2.2 有约束的多元标量最小化</strong></p> 
<p>        我们选择二元标量的rosen函数，并添加约束，得到一个优化模型：</p> 
<p>         ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        <img alt="min 100(x_{1}-x_{0}^{2})^{2}+(1-x_{0})^{2}" class="mathcode" src="https://images2.imgbox.com/ab/de/TAZroSAM_o.png"></p> 
<p>                                                s.t.</p> 
<p>        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​        ​​​​​​​                <img alt="\begin{cases} &amp; \text{ } x_0+2x_1\leq 1 \\ &amp; \text{ } x_0^2+x_1\leq 1 \\ &amp; \text{ } x_0^2-x_1\leq 1 \\ &amp; \text{ } 2x_0+x_1 = 1 \\ &amp; \text{ } 0 \leq x_0 \leq 1 \\ &amp; \text{ } -0.5 \leq x_1 \leq 2 \end{cases}" class="mathcode" src="https://images2.imgbox.com/5b/dc/85xHI6SG_o.png"></p> 
<p>        按照下步骤建立模型并求解，其中线性约束部分与linprog模块类似，通过矩阵表示多个线性约束条件。而非线性约束需要定义对应的约束求解函数cons_f，jacobian矩阵函数和hessian矩阵的线性组合函数cons_J/cons_H.如下所示。两个约束需要通过LinearConstraint和NonlinearConstraint封装为对应的结构，并组合成列表形式作为constraints的参数。</p> 
<pre><code class="language-python"># 有限制的最优化
# Trust-Region Constrained Algorithm信赖域约束算法
# 定义一个带有线性和非线性约束的优化函数
from scipy.optimize import Bounds,LinearConstraint,NonlinearConstraint
# bounds为定义域，参数分别为变量的下限和上限向量表示形式
bounds_t=Bounds([0, -0.5], [1.0, 2.0])
# 与linprog中定义线性约束相同，通过矩阵和向量表示参数
linear_constraint=LinearConstraint([[1,2],[2,1]],[-np.inf,1],[1,1])
# 非线性约束需要jacobian矩阵和hessian矩阵辅助定义
# 返回非线性约束原函数
def cons_f(x):
    return [x[0]**2 + x[1], x[0]**2 - x[1]]
# 对应返回jacboian矩阵
def cons_J(x):
    return [[2*x[0], 1], [2*x[0], -1]]
# 返回hessian矩阵的线性组合形式
def cons_H(x,v):
    return v[0]*np.array([[2, 0], [0, 0]]) + v[1]*np.array([[2, 0], [0, 0]])
from scipy.optimize import NonlinearConstraint
nonlinear_constraint = NonlinearConstraint(cons_f, -np.inf, 1, jac=cons_J, hess=cons_H)
# 约束条件
x3=np.array([0.5,0])
res5=minimize(rosen, x3, method='trust-constr', jac=rosen_der,constraints=[linear_constraint, nonlinear_constraint],hess=rosen_hess,options={'verbose': 1}, bounds=bounds_t)
print(res5)</code></pre> 
<h3 id="%E5%9B%9B%E3%80%81%E5%8F%82%E8%80%83">四、参考</h3> 
<p>[1] Scipy v1.9.0版用户指南 <a href="https://docs.scipy.org/doc/scipy-1.9.0/tutorial/optimize.html#" rel="nofollow" title="Optimization (scipy.optimize) — SciPy v1.9.0 Manual">Optimization (scipy.optimize) — SciPy v1.9.0 Manual</a></p> 
<p>[2] osego 指南 <a href="https://osgeo.cn/scipy/reference/optimize.html" rel="nofollow" title="优化与寻根 (scipy.optimize ) — SciPy v1.8.0.dev0+1869.838cfbe Manual (osgeo.cn)">优化与寻根 (scipy.optimize ) — SciPy v1.8.0.dev0+1869.838cfbe Manual (osgeo.cn)</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4af749e8e3ccff1d7a95ee5b5ecd50e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多线程之callable详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7485074eaaa239af3f56f7a8850824ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu更换国内源（apt更换源）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>