<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Cloud之Eureka客户端健康检测(五) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Cloud之Eureka客户端健康检测(五)" />
<meta property="og:description" content="在前面的博客中，我们知道一个最简单的Eureka微服务架构，也要由3个项目组成，当项目增多的时候，Eureka是怎么维护服务的呢？如何确保其中一个服务实例不能使用了，将它排除出去呢？
由于整个演示过程还是Eureka的内容，我们首先从Spring Cloud服务管理框架Eureka简单示例(三)文章底部的源码链接拿到我们的示例代码。
客户端心跳推送与检测 Eureka分为服务器端和客户端，客户端每隔一段时间就会向服务器端发送一次讯息，向服务器说明自己还正常，让服务器端继续维护自己的服务，不要从服务列表里面把自己给剔除了。同时，设置一个让服务器端等待自己的时间，当自己的服务实例没有继续为服务器端发送心跳后，也就是从最后一次发送心跳开始计时，等待一段时间，依然没有收到讯息，服务器端就会把这个服务实例从服务列表里面移除，不再让流量涌入这个服务实例。
eureka.instance.lease-renewal-interval-in-seconds
表明客户端需要将心跳发送到服务器端，以表明它还活着。如果心跳停止的时间超过了服务器设置的等待时间，那么服务器端将会从它的服务列表中删除该实例，从而将流量排除在该实例之外。默认30s
eureka.instance.lease-expiration-duration-in-seconds
服务器端等待的时间，因为它收到了最后的心跳，然后才可以从它的视图中删除这个实例，并且不允许流量进入这个实例。将这个值设置得太长可能意味着，即使实例不存在，流量也可以被路由到实例。将这个值设置得太小可能意味着，由于临时网络故障，该实例可能会被排除在流量之外。这个值的设置至少要高于leaseRenewalIntervalInSeconds中指定的值。默认90s
我们通过修改这些配置，查看运行结果，去直观地理解这些配置。首先运行euraka-server项目com.init.springCloud包下面的ServerApp类main()方法，启动Eureka服务器端。然后，修改eureka-provider项目application.yml文件，把leaseRenewalIntervalInSeconds的时间改成5s，为了能够看到项目发送的心跳讯息，我们把Eureka的log日志打开，在控制台看输出结果。application.yml配置如下：
spring: application: name: eureka-provider eureka: instance: leaseRenewalIntervalInSeconds: 5 client: serviceUrl: defaultZone: http://localhost:8761/eureka/ logging: level: com.netflix: DEBUG 然后运行eureka-provider项目ProviderApp类的main()方法，项目启动成功之后，我们就能够在控制台看到打印出来的日志信息。我这里截取一段5s内的日志，为了方便观察，去掉了最前面的时间：
[{}-&gt;http://localhost:8761] total kept alive: 1, total issued: 0, total allocated: 1 out of 200 Getting free connection [{}-&gt;http://localhost:8761][null] Released connection is reusable. Releasing connection [{}-&gt;http://localhost:8761][null] Pooling connection [{}-&gt;http://localhost:8761][null]; keep alive indefinitely Notifying no-one, there are no waiting threads Jersey HTTP PUT http://localhost:8761/eureka//apps/EUREKA-PROVIDER/DESKTOP-E3UNJK3:eureka-provider; statusCode=200 DiscoveryClient_EUREKA-PROVIDER/DESKTOP-E3UNJK3:eureka-provider - Heartbeat status: 200 浏览器访问http://localhost:8761，在Eureka的控制台也能够看见注册到服务器端的项目。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/4f960907e56e0327eb3e31e3024a7da8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-03T16:15:16+08:00" />
<meta property="article:modified_time" content="2018-05-03T16:15:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Cloud之Eureka客户端健康检测(五)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在前面的博客中，我们知道一个最简单的Eureka微服务架构，也要由3个项目组成，当项目增多的时候，Eureka是怎么维护服务的呢？如何确保其中一个服务实例不能使用了，将它排除出去呢？</p> 
<p>由于整个演示过程还是Eureka的内容，我们首先从<a href="https://blog.csdn.net/mrspirit/article/details/80004458">Spring Cloud服务管理框架Eureka简单示例(三)</a>文章底部的源码链接拿到我们的示例代码。</p> 
<h2>客户端心跳推送与检测</h2> 
<p>Eureka分为服务器端和客户端，客户端每隔一段时间就会向服务器端发送一次讯息，向服务器说明自己还正常，让服务器端继续维护自己的服务，不要从服务列表里面把自己给剔除了。同时，设置一个让服务器端等待自己的时间，当自己的服务实例没有继续为服务器端发送心跳后，也就是从最后一次发送心跳开始计时，等待一段时间，依然没有收到讯息，服务器端就会把这个服务实例从服务列表里面移除，不再让流量涌入这个服务实例。</p> 
<p><span style="color:#333333;"><strong>eureka.instance.lease-renewal-interval-in-seconds</strong></span></p> 
<p><span style="color:#333333;">表明客户端需要将心跳发送到服务器端，以表明它还活着。如果心跳停止的时间超过了服务器设置的等待时间，那么服务器端将会从它的服务列表中删除该实例，从而将流量排除在该实例之外。默认30s</span></p> 
<p><span style="color:#333333;"><strong>eureka.instance.lease-expiration-duration-in-seconds</strong></span></p> 
<p><span style="color:#333333;">服务器端等待的时间，因为它收到了最后的心跳，然后才可以从它的视图中删除这个实例，并且不允许流量进入这个实例。将这个值设置得太长可能意味着，即使实例不存在，流量也可以被路由到实例。将这个值设置得太小可能意味着，由于临时网络故障，该实例可能会被排除在流量之外。这个值的设置至少要高于leaseRenewalIntervalInSeconds中指定的值。默认90s</span></p> 
<p>我们通过修改这些配置，查看运行结果，去直观地理解这些配置。首先运行euraka-server项目com.init.springCloud包下面的ServerApp类main()方法，启动Eureka服务器端。然后，修改eureka-provider项目application.yml文件，把leaseRenewalIntervalInSeconds的时间改成5s，为了能够看到项目发送的心跳讯息，我们把Eureka的log日志打开，在控制台看输出结果。application.yml配置如下：</p> 
<pre class="has"><code class="language-html">spring:
  application:
    name: eureka-provider

eureka:
  instance:
    leaseRenewalIntervalInSeconds: 5
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

logging:
  level:
    com.netflix: DEBUG</code></pre> 
<p>然后运行eureka-provider项目ProviderApp类的main()方法，项目启动成功之后，我们就能够在控制台看到打印出来的日志信息。我这里截取一段5s内的日志，为了方便观察，去掉了最前面的时间：</p> 
<pre class="has"><code class="language-html">[{}-&gt;http://localhost:8761] total kept alive: 1, total issued: 0, total allocated: 1 out of 200
Getting free connection [{}-&gt;http://localhost:8761][null]
Released connection is reusable.
Releasing connection [{}-&gt;http://localhost:8761][null]
Pooling connection [{}-&gt;http://localhost:8761][null]; keep alive indefinitely
Notifying no-one, there are no waiting threads
Jersey HTTP PUT http://localhost:8761/eureka//apps/EUREKA-PROVIDER/DESKTOP-E3UNJK3:eureka-provider; statusCode=200
DiscoveryClient_EUREKA-PROVIDER/DESKTOP-E3UNJK3:eureka-provider - Heartbeat status: 200</code></pre> 
<p>浏览器访问http://localhost:8761，在Eureka的控制台也能够看见注册到服务器端的项目。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/20/1d/XMPNcFIe_o.png"></p> 
<p>继续在eureka-provider项目的application.yml文件中添加<span style="color:#333333;">leaseExpirationDurationInSeconds，跟leaseRenewalIntervalInSeconds并排，时间设置为10s，前面的介绍中说明了这个时间是要比<span style="color:#333333;">leaseRenewalIntervalInSeconds大的。修改后的</span></span>application.yml<span style="color:#333333;"><span style="color:#333333;">文件为：</span></span></p> 
<pre class="has"><code class="language-html">spring:
  application:
    name: eureka-provider

eureka:
  instance:
    leaseRenewalIntervalInSeconds: 5
    leaseExpirationDurationInSeconds: 10
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

logging:
  level:
    com.netflix: DEBUG</code></pre> 
<p>由于服务器端会运行一个保护机制，虽然我们在客户端设置了10s之后就清除自己的实例，但是服务器端默认会在60s之后才去清理服务列表，并移除已经失效的服务实例。我们可以在eureka-server项目的application.yml新增配置，将服务器的自我保护机制关闭，并把自动清理的时间设置短一些。</p> 
<p>enable-self-preservation 自我保护机制，默认开启</p> 
<p>eviction-interval-timer-in-ms 服务器清理服务列表的定时器，默认60s，注意时间是毫秒</p> 
<pre class="has"><code class="language-html">server:
  port: 8761
  
eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 10000</code></pre> 
<p>然后重新启动eureka-provider和eureka-server项目，访问http://localhost:8761，确定eureka-provider项目已经注册到eureka-server上面，之后，停止eureka-provider项目，等待大概10s以后，重新访问http://localhost:8761，就会看到eureka-server已经不再维护eureka-provider的服务了。</p> 
<h2>客户端服务抓取间隔</h2> 
<p>服务器端在更新了服务列表之后，客户端为了获得最新的服务列表，需要从服务器端主动抓取服务列表。</p> 
<p><span style="color:#333333;"><strong>eureka.client.registry-fetch-interval-seconds </strong></span></p> 
<p><span style="color:#333333;">表示从“发现”服务器获取注册表信息的频率（以秒为单位）。</span></p> 
<p><span style="color:#333333;">在eureka-consumer项目的ConsumerController类里添加一个方法，用于展示当前自己已经缓存的服务列表的信息，同时，为了展示<span style="color:#333333;">eureka-consumer抓取服务的过程，我们同样在<span style="color:#333333;">eureka-consumer的</span></span></span>application.yml<span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;">中开启日志，在控制台查看输出信息(为了方便查看，可以先把eureka-provider项目</span></span></span>application.yml<span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;">文件中的日志注释掉)。<span style="color:#333333;">eureka-consumer的</span></span></span></span>application.yml<span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;">配置如下：</span></span></span></p> 
<pre class="has"><code class="language-html">server:
  port: 8081

spring:
  application:
    name: eureka-consumer

eureka:
  client:
    registry-fetch-interval-seconds: 5
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
      
logging:
  level:
    com.netflix: DEBUG</code></pre> 
<p>ConsumerController类新加方法countService()，完整代码如下：</p> 
<pre class="has"><code class="language-java">package com.init.springCloud;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.client.RestTemplate;

@Controller
@Configuration
public class ConsumerController {
	
	@Bean
	@LoadBalanced
	public RestTemplate getRestTemplate(){
		return new RestTemplate();
	}
	
	@GetMapping(value = "/router")
	@ResponseBody
	public String router(){
		RestTemplate temp = getRestTemplate();
		return temp.getForObject("http://eureka-provider/search/1", String.class);
	}
	
	@Autowired
	private DiscoveryClient  discoveryClient;
	
	@GetMapping(value = "/count")
	@ResponseBody
	public String countService(){
		List&lt;String&gt; services = discoveryClient.getServices();
		for (String string : services) {
			List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(string);
			System.out.println("服务名称："+string+",服务数量："+instances.size());
		}
		return "success";
	}
	
}</code></pre> 
<p>之后，我们把三个项目都启动，在<span style="color:#333333;">eureka-consumer的控制台下，可以看到服务抓取日志，这里同样去掉时间等其他信息：</span></p> 
<pre class="has"><code class="language-html">Get connection: {}-&gt;http://localhost:8761, timeout = 5000
[{}-&gt;http://localhost:8761] total kept alive: 1, total issued: 0, total allocated: 1 out of 200
Getting free connection [{}-&gt;http://localhost:8761][null]
Released connection is reusable.
Releasing connection [{}-&gt;http://localhost:8761][null]
Pooling connection [{}-&gt;http://localhost:8761][null]; keep alive indefinitely
Notifying no-one, there are no waiting threads
Jersey HTTP GET http://localhost:8761/eureka//apps/delta?; statusCode=200
Got delta update with apps hashcode UP_2_
Added instance DESKTOP-E3UNJK3:eureka-provider to the existing apps in region null
Added instance DESKTOP-E3UNJK3:eureka-consumer:8081 to the existing apps in region null
The total number of instances fetched by the delta processor : 2
The total number of all instances in the client now is 2
Completed cache refresh task for discovery. All Apps hash code is Local region apps hashcode: UP_2_, is fetching remote regions? false </code></pre> 
<p>访问http://localhost:8081/count，控制台也输出了我们统计的服务信息：</p> 
<pre class="has"><code class="language-html">服务名称：eureka-consumer,服务数量：1
服务名称：eureka-provider,服务数量：1</code></pre> 
<h2>使用Actuator健康端点检测客户端状态</h2> 
<p>默认情况下，Eureka使用客户端心跳来决定一个服务是否是处于“UP”状态的，只要客户端注册服务成功以后，Eureka服务器端就宣布这个服务是“UP”的，所以，如果是服务整个宕掉了，还好说，Eureka服务器能够知道这个服务挂掉了，但是倘若一个服务提供者不能进行数据库连接了，这个服务实例就是不可用的，但我们的服务器可不这么认为，因为他也无从知晓这个服务是有问题的。所以，我们这里引入Actuator，并使用它的\Health端点做健康检测。</p> 
<p>在我们示例里面，eureka-provider是作为一个服务提供者，这里将它作为测试服务，引入Actuator的包，在eureka-provider的pom.xml中添加如下依赖：</p> 
<pre class="has"><code class="language-html">	    &lt;dependency&gt;
	        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
	        &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;
	    &lt;/dependency&gt;</code></pre> 
<p>我们在程序内部模仿数据库连接，并在控制器提供一个方法，用于修改数据库连接是否发生了故障，之后通知health端点，修改当前服务的状态。在ProviderController类添加下面的方法：</p> 
<pre class="has"><code class="language-java">	public static Boolean isCanLinkDb = true;
	
	@RequestMapping(value = "/linkDb/{can}", method = RequestMethod.GET)
	public void LinkDb(@PathVariable Boolean can){
		isCanLinkDb = can;
	}</code></pre> 
<p>之后新建一个MyHealthIndicator类，实现HealthIndicator接口，重写Health方法，把数据库是否能连接这个状态传入，最后更改当前服务的健康状态：</p> 
<pre class="has"><code class="language-java">package com.init.springCloud;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.boot.actuate.health.Status;
import org.springframework.stereotype.Component;
/**
 * 自定义健康指示器(Spring Boot的内容)
 * @author spirit   
 * @date 2018年5月3日 下午2:19:58 
 * @email spirit612@sina.cn
 */
@Component
public class MyHealthIndicator implements HealthIndicator {

	@Override
	public Health health() {
		if(ProviderController.isCanLinkDb){
			return new Health.Builder(Status.UP).build();
		}else{
			return new Health.Builder(Status.DOWN).build();
		}
	}

}</code></pre> 
<p>这里修改了服务的状态，也是针对于eureka-provider自身来说的，我们能够通过health端点知道服务是否是正常的，那怎么能把health端点返回的服务状态告诉eureka-server呢？也就是跟Eureka服务器说明，我这个服务的数据库不能连接了，服务暂时不可以使用了，你在服务列表里面把我这个服务的状态更改到“DOWN”状态，不要继续让请求涌入我这个服务。这里我们使用Netflix里面提供的HealthCheckHandler接口来做，新建一个MyHealthCheckHandler类，实现HealthCheckHandler接口，重写getStatus()方法：</p> 
<pre class="has"><code class="language-java">package com.init.springCloud;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.health.Status;
import org.springframework.stereotype.Component;

import com.netflix.appinfo.HealthCheckHandler;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;

/**
 * 健康检查处理器
 * @author spirit   
 * @date 2018年5月3日 下午2:39:45 
 * @email spirit612@sina.cn
 */
@Component
public class MyHealthCheckHandler implements HealthCheckHandler {

	@Autowired
	private MyHealthIndicator myHealthIndicator;
	
	@Override
	public InstanceStatus getStatus(InstanceStatus instanceStatus) {
		Status status = myHealthIndicator.health().getStatus();
		if(status.equals(Status.UP)){
			return InstanceStatus.UP;
		}else{
			return InstanceStatus.DOWN;
		}
	}

}</code></pre> 
<p>其实，到这里，已经完成了所有的测试代码。但是，为了能让eureka-server接受到服务变更信息后，更快速地把服务列表的信息进行更改同步(多台发现服务的服务器之间会复制服务列表，进行更新)，我们缩短一下更新的时间。</p> 
<p><span style="color:#333333;">eureka.client.instance-info-replication-interval-seconds 表示复制实例更改的频率（以秒为单位），以复制到发现服务的服务器。默认30s。</span></p> 
<p><span style="color:#333333;">在eureka-server的</span>application.yml<span style="color:#333333;">文件中添加上面的配置，把时间更改到10s：</span></p> 
<pre class="has"><code class="language-html">server:
  port: 8761
  
eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    instanceInfoReplicationIntervalSeconds: 10
    defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
#  server:
#    enable-self-preservation: false
#    eviction-interval-timer-in-ms: 10000</code></pre> 
<p>为了方便测试，不影响观察，把上面两个项目中之前所做的各种配置全部注释掉，然后把三个项目全部启动。</p> 
<p>访问：http://localhost:8080/health，能看到eureka-provider项目当前的状态是“UP”</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/da/e1/TUcb5h2R_o.png"></p> 
<p>访问：http://localhost:8761，能看到eureka-provider项目的状态是“UP”：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d0/e1/gwRzWytg_o.png"></p> 
<p>再访问：http://localhost:8081/router，通过eureka-consumer项目去调用eureka-provider的方法(不清楚过程的，可以查看之前的博客内容，也可在文章末尾下载源代码)，也是能够正常返回结果：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/70/a8/swnyDkUA_o.png"></p> 
<p>之后访问：http://localhost:8080/linkDb/false，设置eureka-provider项目的服务不可用，更改状态为“DOWN”。再次访问eureka-provider的健康端点：http://localhost:8080/health，可以看到服务状态已经更改了：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/8e/bc/fVEDc19Q_o.png"></p> 
<p>接着再次访问：http://localhost:8761，查看服务器维护的服务信息，eureka-provider的状态也被更改到“DOWN”这个不可用状态了：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ae/1c/LNwXz4AJ_o.png"></p> 
<p><span style="color:#333333;">此时，eureka-consumer也是没办法再调用eureka-provider提供的服务了：</span></p> 
<p><span style="color:#333333;"><img alt="" class="has" src="https://images2.imgbox.com/91/5b/gY8kCAqp_o.png"></span></p> 
<p><a href="https://download.csdn.net/download/mrspirit/10389664">源码点击这里</a></p> 
<p>最后，大家有什么不懂的或者其他需要交流的内容，也可以进入我的QQ讨论群一起讨论：654331206</p> 
<p>Spring Cloud系列：</p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/79970306">Spring Cloud介绍与环境搭建(一)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/79975963">Spring Boot的简单使用(二)</a></p> 
<p><a href="https://blog.csdn.net/MrSpirit/article/details/80004458">Spring Cloud服务管理框架Eureka简单示例(三)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80019617">Spring Cloud服务管理框架Eureka项目集群(四)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80164315">Spring Cloud之Eureka客户端健康检测(五)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80182508">Netflix之第一个Ribbon程序(六)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80203414">Ribbon负载均衡器详细介绍(七)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80215604">Spring Cloud中使用Ribbon(八)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80309104">具有负载均衡功能的RestTemplate底层原理(九)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80325580">OpenFeign之第一个Feign程序(十)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80347876">OpenFeign之feign使用简介(十一)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80388108">Spring Cloud中使用Feign(十二)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80391635">Netflix之第一个Hystrix程序(十三)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80401588">Netflix之Hystrix详细分析(十四)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80434058">Spring Cloud中使用Hystrix(十五)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80453562">Netflix之第一个Zuul程序(十六)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80483667">Spring Cloud集群中使用Zuul(十七)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80533995">Netflix之Zuul的进阶应用(十八)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80564456">消息驱动之背景概述(十九)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80569738">消息中间件之RabbitMQ入门讲解(二十)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80572082">消息中间件之Kafka入门讲解(二十一)</a></p> 
<p><a href="https://blog.csdn.net/mrspirit/article/details/80574164">Spring Cloud整合RabbitMQ或Kafka消息驱动(二十二)</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/755af54daa819c401a1a78d6184ea635/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开关电源：选择隔离电源还是非隔离电源（转）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27c170ca4c2b3b70bf14f84f19289d05/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是xserver和xclient</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>