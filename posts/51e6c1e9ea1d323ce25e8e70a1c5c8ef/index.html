<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 腾讯 Matrix 原理分析（一）：Matrix 概览 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 腾讯 Matrix 原理分析（一）：Matrix 概览" />
<meta property="og:description" content="写在前面 近期开始 Android Framework 层的学习，然而较为庞大的 Framework 让人感觉无从下手。碰巧看到一篇文章说到腾讯的 性能监控框架 Matrix 用到了大量 Framework 相关的知识，所以试着分析下该框架的源码实现。
在学习大佬们代码的同时主要关注该框架用到了哪些、是怎么使用的 Framework 的内容。
文章目录 写在前面一、Matrix 简介官方说明Matrix for Android 二、使用 Matrix三、Matrix 结构初始化插件 PluginMatrix 构造器AppActiveMatrixDelegateController Issue总结 一、Matrix 简介 官方说明 Matrix 是一款微信研发并日常使用的应用性能接入框架，支持iOS, macOS和Android。 Matrix 通过接入各种性能监控方案，对性能监控项的异常数据进行采集和分析，输出相应的问题分析、定位与优化建议，从而帮助开发者开发出更高质量的应用。
大公司就是大气，直接双端都给你整一套。
Matrix 地址
Matrix for Android Matrix-android 当前监控范围包括：应用安装包大小，帧率变化，启动耗时，卡顿，慢方法，SQLite 操作优化，文件读写，内存泄漏等等。
APK Checker: 针对 APK 安装包的分析检测工具，根据一系列设定好的规则，检测 APK 是否存在特定的问题，并输出较为详细的检测结果报告，用于分析排查问题以及版本追踪Resource Canary: 基于 WeakReference 的特性和 Square Haha 库开发的 Activity 泄漏和 Bitmap 重复创建检测工具Trace Canary: 监控界面流畅性、启动耗时、页面切换耗时、慢函数及卡顿等问题SQLite Lint: 按官方最佳实践自动化检测 SQLite 语句的使用质量IO Canary: 检测文件 IO 问题，包括：文件 IO 监控和 Closeable Leak 监控 好家伙，功能还真不少。看样子是个大工程，排个计划吧：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/51e6c1e9ea1d323ce25e8e70a1c5c8ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-10T14:50:54+08:00" />
<meta property="article:modified_time" content="2020-12-10T14:50:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 腾讯 Matrix 原理分析（一）：Matrix 概览</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>写在前面</h2> 
<p>近期开始 Android Framework 层的学习，然而较为庞大的 Framework 让人感觉无从下手。碰巧看到一篇文章说到腾讯的 <strong>性能监控框架 Matrix</strong> 用到了大量 Framework 相关的知识，所以试着分析下该框架的源码实现。</p> 
<p>在学习大佬们代码的同时主要关注该框架用到了哪些、是怎么使用的 Framework 的内容。</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_0" rel="nofollow">写在前面</a></li><li><a href="#Matrix__7" rel="nofollow">一、Matrix 简介</a></li><li><ul><li><a href="#_8" rel="nofollow">官方说明</a></li><li><a href="#Matrix_for_Android_17" rel="nofollow">Matrix for Android</a></li></ul> 
  </li><li><a href="#_Matrix_32" rel="nofollow">二、使用 Matrix</a></li><li><a href="#Matrix__41" rel="nofollow">三、Matrix 结构</a></li><li><ul><li><a href="#_43" rel="nofollow">初始化</a></li><li><a href="#_Plugin_120" rel="nofollow">插件 Plugin</a></li><li><a href="#Matrix__142" rel="nofollow">Matrix 构造器</a></li><li><ul><li><a href="#AppActiveMatrixDelegate_162" rel="nofollow">AppActiveMatrixDelegate</a></li><li><ul><li><a href="#Controller_205" rel="nofollow">Controller</a></li></ul> 
   </li></ul> 
   </li><li><a href="#Issue_306" rel="nofollow">Issue</a></li><li><a href="#_409" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Matrix__7"></a>一、Matrix 简介</h2> 
<h3><a id="_8"></a>官方说明</h3> 
<blockquote> 
 <p>Matrix 是一款微信研发并日常使用的应用性能接入框架，支持iOS, macOS和Android。 Matrix 通过接入各种性能监控方案，对性能监控项的异常数据进行采集和分析，输出相应的问题分析、定位与优化建议，从而帮助开发者开发出更高质量的应用。</p> 
</blockquote> 
<p>大公司就是大气，直接双端都给你整一套。</p> 
<blockquote> 
 <p><a href="https://github.com/Tencent/matrix">Matrix 地址</a></p> 
</blockquote> 
<h3><a id="Matrix_for_Android_17"></a>Matrix for Android</h3> 
<p>Matrix-android 当前监控范围包括：应用安装包大小，帧率变化，启动耗时，卡顿，慢方法，SQLite 操作优化，文件读写，内存泄漏等等。</p> 
<ul><li>APK Checker: 针对 APK 安装包的分析检测工具，根据一系列设定好的规则，检测 APK 是否存在特定的问题，并输出较为详细的检测结果报告，用于分析排查问题以及版本追踪</li><li>Resource Canary: 基于 WeakReference 的特性和 Square Haha 库开发的 Activity 泄漏和 Bitmap 重复创建检测工具</li><li>Trace Canary: 监控界面流畅性、启动耗时、页面切换耗时、慢函数及卡顿等问题</li><li>SQLite Lint: 按官方最佳实践自动化检测 SQLite 语句的使用质量</li><li>IO Canary: 检测文件 IO 问题，包括：文件 IO 监控和 Closeable Leak 监控</li></ul> 
<p>好家伙，功能还真不少。看样子是个大工程，排个计划吧：</p> 
<ol><li>首先是对框架的大致了解，对框架中用到的需要用到的类、函数进行预习；</li><li>从某一模块入手，分析功能实现的同时注重 Framework 的内容；</li><li>最后进行总结，思考为什么这样做，有没有更好的做法。</li></ol> 
<p>那么本文先大概了解一下框架，遇到 Framework 中的知识进行简单的了解和预习。</p> 
<h2><a id="_Matrix_32"></a>二、使用 Matrix</h2> 
<p>有关 Matrix 的接入和使用官方文档已经写得很清楚了，本文简单总结下：</p> 
<ol><li>引入 Matrix 库，添加相关依赖；</li><li>创建插件监听，可以接收到插件的启动和工作通知。<br> Matrix 的功能基本都是由这些 <strong>插件 Plugin</strong> 实现的，这样做的好处一方面是解耦，另一方面是用户可以根据需要选择使用的功能。</li><li>在 Application 中初始化 Matrix，添加插件并开启插件功能。</li></ol> 
<h2><a id="Matrix__41"></a>三、Matrix 结构</h2> 
<p>接下来根据 Matrix 的创建和使用来确定它的结构。</p> 
<h3><a id="_43"></a>初始化</h3> 
<p>Matrix 需要在 Applicaton 中初始化，对象的构建方式是熟悉的建造者模式：</p> 
<pre><code>public class MatrixApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
		// 创建 Matrix，传入 application
		Matrix.Builder builder = new Matrix.Builder(this);
		// 设置插件监听
		builder.patchListener(new TestPluginListener(this));
		// 创建插件
		TracePlugin tracePlugin = new TracePlugin(new TraceConfig.Builder()
		        .build());
		// 添加插件
		builder.plugin(tracePlugin);
		// 初始化
		Matrix.init(builder.build());
		// 插件开始工作
		tracePlugin.start();
    }
}
</code></pre> 
<p>维护的变量也比较简单：</p> 
<pre><code>public static class Builder {
	// 持有 Application 
    private final Application application;
    // 插件工作回调
    private PluginListener pluginListener;
	// 维护插件列表
    private HashSet&lt;Plugin&gt; plugins = new HashSet&lt;&gt;();

    public Builder(Application app) {
        if (app == null) {
            throw new RuntimeException("matrix init, application is null");
        }
        this.application = app;
    }
}
</code></pre> 
<ul><li><strong>PluginListener</strong>：是一个接口，定义了插件的生命周期。官方提供了默认实现 DefaultPluginListener，我们只需要继承该类并设置给 Matrix 就可以接收到插件的生命周期。</li></ul> 
<pre><code>public interface PluginListener {
    void onInit(Plugin plugin);// 初始化

    void onStart(Plugin plugin);// 开始

    void onStop(Plugin plugin);// 结束

    void onDestroy(Plugin plugin);// 销毁

    void onReportIssue(Issue issue);// 提交报告
}
</code></pre> 
<pre><code>public class TestPluginListener extends DefaultPluginListener {
    public static final String TAG = "Matrix.TestPluginListener";

    public TestPluginListener(Context context) {
        super(context);
    }

    @Override
    public void onReportIssue(Issue issue) {
        super.onReportIssue(issue);
        MatrixLog.e(TAG, issue.toString());
        //add your code to process data
    }
}
</code></pre> 
<ul><li><strong>plugins</strong>：插件列表，使用 HashSet 维护，保证插件不会重复添加。</li></ul> 
<h3><a id="_Plugin_120"></a>插件 Plugin</h3> 
<p>插件是 Matrix 的重要组成结构，通过继承抽象类 Plugin 来创建一个插件，Plugin 是接口 IPlugin 的实现。IPlugin 接口定义了插件所实现的主要功能：</p> 
<pre><code>public interface IPlugin {

    Application getApplication();

    void init(Application application, PluginListener pluginListener);

    void start();

    void stop();

    void destroy();

    String getTag();

    void onForeground(boolean isForeground);
}
</code></pre> 
<p>比如分析卡顿的 TracePlugin，它就是一个继承了 Plugin 的插件实现，在工作的过程中也会调用这些方法。</p> 
<h3><a id="Matrix__142"></a>Matrix 构造器</h3> 
<pre><code>Matrix.Builder builder = new Matrix.Builder(this);
Matrix.init(builder.build());
</code></pre> 
<p>调用 <code>builder.build()</code> 之后会创建一个 Matrix 对象，然后创建一个用于监听 App 生命周期的 AppActiveMatrixDelegate。之后遍历所有的插件列表，并调用它们的 <code>init()</code> 方法初始化插件。</p> 
<pre><code>private Matrix(Application app, PluginListener listener, HashSet&lt;Plugin&gt; plugins) {
    this.application = app;
    this.pluginListener = listener;
    this.plugins = plugins;
    // 初始化
    AppActiveMatrixDelegate.INSTANCE.init(application);
    for (Plugin plugin : plugins) {
        plugin.init(application, pluginListener);
        pluginListener.onInit(plugin);
    }
}
</code></pre> 
<h4><a id="AppActiveMatrixDelegate_162"></a>AppActiveMatrixDelegate</h4> 
<p>这个类是个枚举单例，并且监听应用 Activity 生命周期以及内存状态。</p> 
<pre><code>public enum AppActiveMatrixDelegate {
	// 1. 利用枚举创建单例
    INSTANCE;

    private static final String TAG = "Matrix.AppActiveDelegate";
    private final Set&lt;IAppForeground&gt; listeners = new HashSet();
    private boolean isAppForeground = false;
    private String visibleScene = "default";
    private Controller controller = new Controller();
    private boolean isInit = false;
    private String currentFragmentName;
    private Handler handler;

    public void init(Application application) {
        if (isInit) {
            MatrixLog.e(TAG, "has inited!");
            return;
        }
        this.isInit = true;
        // 2. HandlerTherad：一个封装了 Handler 的线程
        if (null != MatrixHandlerThread.getDefaultHandlerThread()) {
            this.handler = new Handler(MatrixHandlerThread.getDefaultHandlerThread().getLooper());
        }
        // 3. 注册应用内存状态回调
        application.registerComponentCallbacks(controller);
        // 4. 注册监听 Activity 生命周期
        application.registerActivityLifecycleCallbacks(controller);
    }
}
</code></pre> 
<ol><li>枚举实现单例的原理是利用枚举的特点来实现的：枚举类型是线程安全的，并且只会装载一次。</li><li>HandlerTherad 继承了 Thread，可以看作是一个线程。而其内部维护了一个 Handler，在调用 start() 方法后初始化 Looper，可以很方便地执行异步任务。其它类可以通过 <code>getThreadHandler</code> 方法获取 HandlerTherad 的 Handler，然后 post 任务由 HandlerTherad 内部的 Looper 取出并执行。</li><li>registerComponentCallbacks：Application 的方法，作用是监听应用的内存状态。<br> 在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用 onLowMemory。<br> OnTrimMemory 是 Android 4.0 之后提供的 API。比起 onLowMemory，这个回调新增返回了一个 int 值表示当前内存状态，开发者可以根据返回的状态来适当回收资源避免 app 被杀死的风险。<br> <strong>想要监听内存状态回调需要实现 ComponentCallbacks2 接口，该接口是 ComponentCallbacks 的升级版。</strong></li></ol> 
<blockquote> 
 <p><a href="https://www.cnblogs.com/xiajf/p/3993599.html" rel="nofollow">应用内存优化之OnLowMemory&amp;OnTrimMemory</a></p> 
</blockquote> 
<ol start="4"><li>registerActivityLifecycleCallbacks：注册监听 Activity 状态回调，<strong>实现 Application.ActivityLifecycleCallbacks 接口以监听 Activity 生命周期回调。</strong></li></ol> 
<h5><a id="Controller_205"></a>Controller</h5> 
<p><strong>Controller 实现 ComponentCallbacks2 监听内存状态、ActivityLifecycleCallbacks 监听 Activity 生命周期。</strong></p> 
<pre><code>private final class Controller implements Application.ActivityLifecycleCallbacks, ComponentCallbacks2 {

    @Override
    public void onActivityStarted(Activity activity) {
    	// 1. 记录启动的 Activity
        updateScene(activity);
        // 1.1 告知 listeners Activity 在前台了
        onDispatchForeground(getVisibleScene());
    }


    @Override
    public void onActivityStopped(Activity activity) {
    	// 1.2 获取栈顶活动的 Activity
        if (getTopActivityName() == null) {
        	// 1.3 告知 listeners Activity 在后台了
            onDispatchBackground(getVisibleScene());
        }
    }
    ...

    @Override
    public void onTrimMemory(int level) {
        MatrixLog.i(TAG, "[onTrimMemory] level:%s", level);
        // 2. TRIM_MEMORY_UI_HIDDEN 表示当前 app UI 不再可见
        if (level == TRIM_MEMORY_UI_HIDDEN &amp;&amp; isAppForeground) { // fallback
            onDispatchBackground(visibleScene);
        }
    }
}
</code></pre> 
<p>Controller 的逻辑主要为了区分 App 进入前台或后台。怎么区分呢？</p> 
<ul><li>有 Activity 回调了 onStart，说明 App 进入了前台，记录并返回给监听就行；</li><li>有 Activity 回调了 onStop，且栈顶没有 Resume 状态的 Activity，说明 App 进入了后台；<br> 用户点击了 Home 或者 Back 键，系统会通过 onTrimMemory 回调一个 TRIM_MEMORY_UI_HIDDEN 状态，告知这是 App 进入后台，是回收资源的大好时机。</li></ul> 
<blockquote> 
 <p>回调 onStart 之后用一个字符串记录当前 Activity</p> 
</blockquote> 
<pre><code>private void updateScene(Activity activity) {
    visibleScene = activity.getClass().getName();
}

public String getVisibleScene() {
    return visibleScene;
}
</code></pre> 
<p>我们主要关注 <code>onActivityStopped()</code> 回调中的 <code>getTopActivityName()</code> 方法，该方法用于获取栈顶活动状态的 Activity。</p> 
<blockquote> 
 <p>getTopActivityName()</p> 
</blockquote> 
<pre><code>public static String getTopActivityName() {
    long start = System.currentTimeMillis();
    try {
    	// 获取 ActivityThread Class 对象
        Class activityThreadClass = Class.forName("android.app.ActivityThread");
        // 调用这个类的 currentActivityThread 方法，返回一个静态的 ActivityThread 实例 sCurrentActivityThread
        // 这个静态实例是在 main 函数中赋值的
        Object activityThread = activityThreadClass.getMethod("currentActivityThread").invoke(null);
        // 获取 ActivityThread 的 mActivities 列表
        // 在 Activity onCreate 之后，往列表添加 Activity 记录
        Field activitiesField = activityThreadClass.getDeclaredField("mActivities");
        activitiesField.setAccessible(true);

        Map&lt;Object, Object&gt; activities; // 获取 activityThread 类的 mActivities 对象
        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) {
            activities = (HashMap&lt;Object, Object&gt;) activitiesField.get(activityThread);
        } else {
            activities = (ArrayMap&lt;Object, Object&gt;) activitiesField.get(activityThread);
        }
        if (activities.size() &lt; 1) {
            return null;
        }
        for (Object activityRecord : activities.values()) {
            Class activityRecordClass = activityRecord.getClass();
            Field pausedField = activityRecordClass.getDeclaredField("paused");
            pausedField.setAccessible(true);
            if (!pausedField.getBoolean(activityRecord)) {// onResume 的 Activity paused 为 false
                Field activityField = activityRecordClass.getDeclaredField("activity");
                activityField.setAccessible(true);
                Activity activity = (Activity) activityField.get(activityRecord);
                return activity.getClass().getName();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        long cost = System.currentTimeMillis() - start;
        MatrixLog.d(TAG, "[getTopActivityName] Cost:%s", cost);
    }
    return null;
}
</code></pre> 
<p>整个过程就是利用反射操作 Framework ActivityThread 的参数和函数，获取栈顶的非 paused 状态的 Activity。这段代码需要看着 ActivityThread 类慢慢消化，在你的 IDE 查看或者<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/ActivityThread.java" rel="nofollow">在线查看</a>。</p> 
<p>综上，AppActiveMatrixDelegate 是利用内部的 Controller 监听 App 发来的信号，用来确定应用程序的前后台状态。</p> 
<p>外部可以设置监听，等应用程序前后台转换的时候再遍历监听者回调告知。</p> 
<h3><a id="Issue_306"></a>Issue</h3> 
<p>当插件监控到 App 运行出现问题时，会把问题信息封装为一个 Issue 类进行报告。</p> 
<pre><code>public class Issue {
    private int        type;
    private String     tag;
    private String     key;
    private JSONObject content;
    private Plugin     plugin;

    public static final String ISSUE_REPORT_TYPE    = "type";
    public static final String ISSUE_REPORT_TAG     = "tag";
    public static final String ISSUE_REPORT_PROCESS = "process";
    public static final String ISSUE_REPORT_TIME = "time";
}
</code></pre> 
<p>可以看到该类详细记录了问题的类型、信息、插件信息等，发现问题是怎么报告呢？我们拿性能监控插件 TracePlugin 中的 FrameTracer 举例：</p> 
<blockquote> 
 <p>FrameTracer</p> 
</blockquote> 
<pre><code>void report() {
    float fps = Math.min(60.f, 1000.f * sumFrame / sumFrameCost);
    MatrixLog.i(TAG, "[report] FPS:%s %s", fps, toString());

    try {
    	// 根据插件名称遍历查找
        TracePlugin plugin = Matrix.with().getPluginByClass(TracePlugin.class);
        if (null == plugin) {
            return;
        }
		// ... 省略部分代码
		
        JSONObject resultObject = new JSONObject();
        resultObject = DeviceUtil.getDeviceInfo(resultObject, plugin.getApplication());
		// 组装内容
        resultObject.put(SharePluginInfo.ISSUE_SCENE, visibleScene);
        resultObject.put(SharePluginInfo.ISSUE_DROP_LEVEL, dropLevelObject);
        resultObject.put(SharePluginInfo.ISSUE_DROP_SUM, dropSumObject);
        resultObject.put(SharePluginInfo.ISSUE_FPS, fps);

        Issue issue = new Issue();
        issue.setTag(SharePluginInfo.TAG_PLUGIN_FPS);
        issue.setContent(resultObject);
        // 调用插件方法
        plugin.onDetectIssue(issue);

    } catch (JSONException e) {
        MatrixLog.e(TAG, "json error", e);
    } finally {
        sumFrame = 0;
        sumDroppedFrames = 0;
        sumFrameCost = 0;
    }
}
</code></pre> 
<p>最后会调用 Plugin 的 onDetectIssue （Detect：发现、侦查出）方法传递 Issue 信息。</p> 
<blockquote> 
 <p>Plugin # onDetectIssue</p> 
</blockquote> 
<pre><code>@Override
public void onDetectIssue(Issue issue) {
    if (issue.getTag() == null) {
        // 设置默认 tag
        issue.setTag(getTag());
    }
    issue.setPlugin(this);
    JSONObject content = issue.getContent();
    // add tag and type for default
    try {
        if (issue.getTag() != null) {
            content.put(Issue.ISSUE_REPORT_TAG, issue.getTag());
        }
        if (issue.getType() != 0) {
            content.put(Issue.ISSUE_REPORT_TYPE, issue.getType());
        }
        content.put(Issue.ISSUE_REPORT_PROCESS, MatrixUtil.getProcessName(application));
        content.put(Issue.ISSUE_REPORT_TIME, System.currentTimeMillis());

    } catch (JSONException e) {
        MatrixLog.e(TAG, "json error", e);
    }

    // 报告 Issue
    pluginListener.onReportIssue(issue);
}
</code></pre> 
<p>这个 pluginListener 对象其实就是在 <strong>初始化</strong> 的时候创建并设置的 TestPluginListener，现在发现问题了就通过这个 Listener 报告问题。</p> 
<pre><code>public class TestPluginListener extends DefaultPluginListener {
    public static final String TAG = "Matrix.TestPluginListener";

    public TestPluginListener(Context context) {
        super(context);
    }

    @Override
    public void onReportIssue(Issue issue) {
        super.onReportIssue(issue);
        MatrixLog.e(TAG, issue.toString());
        // 收到 Issue，做后续工作
    }
}
</code></pre> 
<h3><a id="_409"></a>总结</h3> 
<p>画个简单的流程图：<br> <img src="https://images2.imgbox.com/10/05/jQH3C1UF_o.png" alt="在这里插入图片描述"></p> 
<p>到这里，Matrix 大致的工作流程已经搞清楚了。但是到现在基本没有接触核心功能，Matrix 是怎么分析卡顿的？怎么分析 ANR 的？… 后面会发文继续分析，敬请期待。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/784ecafdef50b72642aa5ac40c1b3d85/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一道单调栈的题目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e1c31a0bfbb895daf82025b1ab07859/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python怎么建立矩阵的方法_如何创建一个3x3矩阵并填充它</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>