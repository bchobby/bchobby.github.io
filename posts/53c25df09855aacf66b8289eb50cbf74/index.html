<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉搜索树：红黑树的原理和实现 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉搜索树：红黑树的原理和实现" />
<meta property="og:description" content="目录 前言1. 红黑树的概念2. 红黑树的性质3. 红黑树的定义4. 红黑树的插入操作5. 红黑树的验证6. 红黑树和AVL树的比较7. 红黑树的应用 前言 💭上文我们在遇到问题：二叉搜索树退化到单支导致效率和性能降低时，利用了AVL树解决。但是由于AVL树是一棵绝对平衡的树，每次修改树结构都要保证左右子树高度差的绝对值不超过1，这可能会引发多次旋转。因此，若我们要设计出一棵结构动态变化的二叉搜索树，利用AVL树的效率并不高。基于这个原因，红黑树诞生了。
1. 红黑树的概念 🔴⚫
红黑树（RBTree）是一种二叉搜索树，在每个节点设置一个存储域用于指明该节点的颜色 （Red或Black），进而，通过限制任一条从根到叶子节点的路径上的各个节点的着色方式，使得任一条路径的长度都不超过另一条路径，最终达到接近平衡的树结构。
📃红黑树结构示意图：
其中，NIL为空节点
2. 红黑树的性质 每一棵红黑树，都满足以下五条性质：
每个节点不是黑色就是红色根节点为黑对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点不允许有相邻的两个红色节点每个叶节点都为黑（此处的叶节点指NIL节点） 💡这五条性质，保证了红黑树最长路径长度不超过最短路径长度的二倍。
为何要引进 NIL 节点？ 保证任意节点都有两个分叉，这样才能使得红黑树接近平衡。不这样做的话，若直接以平时的叶子节点作叶节点，极端情况下，下面这棵树同样满足红黑树的性质，但是其已经退化成链表了，查找效率为O(N)。
如何保证最长路径长度不超过最短路径的二倍? 如图所示，我们以8为根节点的红黑树为例（只关注左右两条路径，假设左路径是最短路径，右路径是最长路径，图中三角形是一些能保证整棵树为红黑树的不同情况的子树）
由性质3可得，最短路径中的黑节点必须与最长路径中的黑节点数量相同，又由性质4，最终可得最短路径节点全为黑，且与最长路径中黑节点数量相同。而最长路径中，在与最短路径拥有相同数量黑节点的前提下，穿插了红色节点，使之长度最长的方法是每个黑节点都带一个红节点。这样一来，最长路径的长度就是最短路径的二倍，此时最长路径最后一个节点为红，插入红色节点违反性质4，插入黑色节点违反性质3，因此最长路径长度不超过最短路径长度的二倍。如图中，左边路径长度为3（最短），右边路径长度为6（最长）。
3. 红黑树的定义 // 枚举：红和黑 enum COLOR { RED, BLACK, }; // RBTree的节点 template &lt;class V&gt; struct RBTreeNode { typedef RBTreeNode&lt;V&gt; Self; V _v; // 数据域 Self* _left; Self* _right; Self* _parent; COLOR _col; // 颜色域 RBTreeNode(const V&amp; v) :_v(v) , _left(nullptr) , _right(nullptr) , _parent(nullptr) , _col(RED) {} }; // RBTree的大致结构 template &lt;class V&gt; class RBTree { typedef RBTreeNode&lt;V&gt; node; public: RBTree() :_root(nullptr) {} private: node* _root; }; 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/53c25df09855aacf66b8289eb50cbf74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-30T21:06:18+08:00" />
<meta property="article:modified_time" content="2023-03-30T21:06:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉搜索树：红黑树的原理和实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#1__10" rel="nofollow">1. 红黑树的概念</a></li><li><a href="#2__23" rel="nofollow">2. 红黑树的性质</a></li><li><a href="#3__56" rel="nofollow">3. 红黑树的定义</a></li><li><a href="#4__106" rel="nofollow">4. 红黑树的插入操作</a></li><li><a href="#5__436" rel="nofollow">5. 红黑树的验证</a></li><li><a href="#6_AVL_564" rel="nofollow">6. 红黑树和AVL树的比较</a></li><li><a href="#7__612" rel="nofollow">7. 红黑树的应用</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<blockquote> 
 <p>💭上文我们在遇到问题：二叉搜索树退化到单支导致效率和性能降低时，利用了AVL树解决。但是由于AVL树是一棵绝对平衡的树，每次修改树结构都要保证左右子树高度差的绝对值不超过1，这可能会引发多次旋转。因此，若我们要设计出一棵结构动态变化的二叉搜索树，利用AVL树的效率并不高。基于这个原因，红黑树诞生了。</p> 
</blockquote> 
<h2><a id="1__10"></a>1. 红黑树的概念</h2> 
<blockquote> 
 <p>🔴⚫<br> <em>红黑树（RBTree）是一种二叉搜索树，在每个节点设置一个存储域用于指明该节点的颜色 <code>（Red或Black）</code>，进而，通过限制任一条从根到叶子节点的路径上的各个节点的着色方式，使得任一条路径的长度都不超过另一条路径，最终达到接近平衡的树结构。</em></p> 
</blockquote> 
<p>📃红黑树结构示意图：</p> 
<p><img src="https://images2.imgbox.com/54/3f/jkMCaQUA_o.png" alt="在这里插入图片描述"><br> <code>其中，NIL为空节点</code></p> 
<hr> 
<h2><a id="2__23"></a>2. 红黑树的性质</h2> 
<p><mark>每一棵红黑树，都满足以下五条性质：</mark></p> 
<blockquote> 
 <ol><li>每个节点不是黑色就是红色</li><li>根节点为黑</li><li><strong>对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</strong></li><li><strong>不允许有相邻的两个红色节点</strong></li><li>每个叶节点都为黑（此处的叶节点指<code>NIL</code>节点）</li></ol> 
</blockquote> 
<p>💡这五条性质，保证了红黑树最长路径长度不超过最短路径长度的二倍。</p> 
<ul><li><font color="#003399"><em>为何要引进 <strong>NIL</strong> 节点？</em></font></li></ul> 
<blockquote> 
 <p><strong>保证任意节点都有两个分叉，这样才能使得红黑树接近平衡</strong>。不这样做的话，若直接以平时的叶子节点作叶节点，极端情况下，下面这棵树同样满足红黑树的性质，但是其已经退化成链表了，查找效率为O(N)。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/81/7e/1Idd3eFA_o.png" alt="在这里插入图片描述"></p> 
<ul><li><font color="#003399"><em>如何保证最长路径长度不超过最短路径的二倍?</em></font></li></ul> 
<p><img src="https://images2.imgbox.com/c8/e3/xjEP7UJ3_o.png" alt="在这里插入图片描述"></p> 
<p>如图所示，我们以<code>8</code>为根节点的红黑树为例（只关注左右两条路径，假设左路径是最短路径，右路径是最长路径，图中三角形是一些能保证整棵树为红黑树的不同情况的子树）</p> 
<blockquote> 
 <p>由性质3可得，最短路径中的黑节点必须与最长路径中的黑节点数量相同，又由性质4，最终可得<strong>最短路径节点全为黑，且与最长路径中黑节点数量相同</strong>。而最长路径中，在与最短路径拥有相同数量黑节点的前提下，穿插了红色节点，使之长度最长的方法是每个黑节点都带一个红节点。这样一来，最长路径的长度就是最短路径的二倍，此时最长路径最后一个节点为红，插入红色节点违反性质4，插入黑色节点违反性质3，因此最长路径长度不超过最短路径长度的二倍。如图中，左边路径长度为3（最短），右边路径长度为6（最长）。</p> 
</blockquote> 
<hr> 
<h2><a id="3__56"></a>3. 红黑树的定义</h2> 
<pre><code class="prism language-cpp"><span class="token comment">// 枚举：红和黑</span>
<span class="token keyword">enum</span> <span class="token class-name">COLOR</span> 
<span class="token punctuation">{<!-- --></span>
	RED<span class="token punctuation">,</span>
	BLACK<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// RBTree的节点</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">RBTreeNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> RBTreeNode<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> Self<span class="token punctuation">;</span>

	V _v<span class="token punctuation">;</span> <span class="token comment">// 数据域</span>
	Self<span class="token operator">*</span> _left<span class="token punctuation">;</span>
	Self<span class="token operator">*</span> _right<span class="token punctuation">;</span>
	Self<span class="token operator">*</span> _parent<span class="token punctuation">;</span>
	COLOR _col<span class="token punctuation">;</span> <span class="token comment">// 颜色域</span>

	<span class="token function">RBTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_parent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_col</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// RBTree的大致结构</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">RBTree</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> RBTreeNode<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> node<span class="token punctuation">;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	node<span class="token operator">*</span> _root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="4__106"></a>4. 红黑树的插入操作</h2> 
<blockquote> 
 <p>💭红黑树的插入，是其区别于AVL树的最大亮点，红黑树的插入减少了一些旋转，使用<code>变色+旋转</code>的调整方式，提高了插入效率。</p> 
</blockquote> 
<p>💨<em>红黑树的插入操作可分为两步</em> ：</p> 
<ol><li><em><strong>按照二叉搜索树的规则，插入新节点</strong></em></li></ol> 
<blockquote> 
 <p>⭕ <em><strong>插入新节点默认为红</strong></em>。如果默认为黑，则必定违反性质3，需要做的调整更多。而默认为红，有可能会违反性质4，需要做出调整，也可能不违反任何性质，无需调整。因而选择第二种方案，减少插入时的调整次数，提高效率。</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">RBTree</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> RBTreeNode<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...</span>
	<span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//插入</span>
		node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> cur<span class="token operator">-&gt;</span>_v<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&gt;</span> cur<span class="token operator">-&gt;</span>_v<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_v <span class="token operator">&lt;</span> parent<span class="token operator">-&gt;</span>_v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>

		<span class="token comment">// ...</span>
	<span class="token punctuation">}</span>
	
<span class="token keyword">private</span>
	node<span class="token operator">*</span> _root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="2"><li><em><strong>检查插入后是否破坏了红黑树结构，若是则需进行调整</strong></em></li></ol> 
<p>💭因为新节点的默认颜色是红色，所以：</p> 
<ol><li>如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；</li><li>如果新插入节点的双亲节点颜色为红色时，就违反了性质3<code>不允许有相邻的两个红色节点</code>，此时需要对红黑树分情况来讨论，不同情况有不同调整方法：</li></ol> 
<p>约定:<img src="https://images2.imgbox.com/a5/e6/XCHOXIET_o.png" alt="在这里插入图片描述"></p> 
<p><em>需要调整时，<strong>cur为红，p为红，g为黑</strong>（否则调整前p、g就已经破坏了红黑树的规则）。因此我们重点看uncle节点的情况，uncle节点的存在与否、着色状态决定了该如何调整。</em></p> 
<br> 
<br> 
<p><font size="3">1️⃣<strong>情况1：<code>uncle</code>节点存在且为红</strong></font></p> 
<p>⭕<em>注意，此时看到的树可能是某棵子树，也有可能是整棵树。</em><br> <img src="https://images2.imgbox.com/2e/48/4Rz9r2i3_o.png" alt="在这里插入图片描述"></p> 
<ul><li>📝调整方法：<strong>p，u变黑，g变红</strong>。这样做不仅解决了相邻两个红节点的问题，还使得以g为根到任意叶子节点的每条路径的黑节点数量不变。但是要注意g还需继续向上调整。</li></ul> 
<br> 
<blockquote> 
 <p><strong>为什么g还需要向上继续调整？</strong></p> 
 <ul><li>当这棵树是某棵子树时，g一定还有双亲节点，若g的双亲节点为红色，则需要继续向上调整。</li><li>当这棵树是整颗树时，g是根节点，则需要修改g的颜色为黑，否则会破坏性质2（根节点为黑）。</li></ul> 
</blockquote> 
<ul><li>🔎综上所述，<strong>cur可以是新插入节点，也可以是由a、b子树插入节点调整（情况1）后变成红色。</strong> 若cur为新插入的节点，易得a、b为空树。此时c、d、e皆为空树，否则插入前的树并不是红黑树。若cur是调整后得来的红节点，则各个子树又有不同情况。总而言之，<strong>插入新节点前该树必须满足红黑树的性质。</strong></li></ul> 
<p><img src="https://images2.imgbox.com/0c/42/wmAzHBB7_o.png" alt="在这里插入图片描述"></p> 
<ul><li><em>因为情况1并不涉及旋转，不会调整树的物理结构，所以调整方法与cur的插入位置无关，只要满足条件即可。下面四种情况均属于情况1的调整。</em></li></ul> 
<p><img src="https://images2.imgbox.com/29/a0/1mHH0b2K_o.png" alt="在这里插入图片描述"><br> <br><br> <br><br> <font size="3">2️⃣<strong>情况2：<code>uncle</code>节点不存在/存在且为黑</strong></font></p> 
<ol><li> <p><code>uncle</code>不存在。<strong>cur</strong>只能是新插入节点的情况（不能是由子树调整而来变红）。abcde子树均不存在，否则插入之前不满足红黑树的性质。<br> <img src="https://images2.imgbox.com/53/af/DoWtEz5i_o.png" alt="在这里插入图片描述"></p> </li><li> <p><code>uncle</code>存在且为黑。<strong>cur</strong>只能是由子树调整而来变红 <mark>（即情况1变化而来）</mark> 的情况（不能是新插入节点），否则调整前不满足红黑树的性质。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/81/b0/XbeI8GZA_o.png" alt="在这里插入图片描述"></p> 
<p>⭕<em>假设cur为新插入节点，则插入前树结构如图所示（暂且不考虑NIL节点），违反性质3。</em><br> <img src="https://images2.imgbox.com/e7/e8/7nY045nm_o.png" alt="在这里插入图片描述"></p> 
<p>(1)(2)的调整方法都是一样的。不同于情况1，情况二无法单凭节点的变色完成调整，而是要借助<code>旋转＋变色</code>。旋转方式与AVL树的旋转大同小异。</p> 
<ol><li> <p><strong>左左——右单旋</strong><br> <img src="https://images2.imgbox.com/ec/ff/rFR5fAHG_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>右右——左单旋</strong><br> <img src="https://images2.imgbox.com/60/c2/McI2oSuG_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>左右——左右双旋</strong><img src="https://images2.imgbox.com/ba/4b/w5DCm2Rr_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>右左——右左双旋</strong><br> <img src="https://images2.imgbox.com/38/7f/p9lRTB3r_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<p><strong>💬代码实现</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">RBTree</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> RBTreeNode<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> node<span class="token punctuation">;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...</span>
	<span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//插入</span>
		node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> cur<span class="token operator">-&gt;</span>_v<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&gt;</span> cur<span class="token operator">-&gt;</span>_v<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_v <span class="token operator">&lt;</span> parent<span class="token operator">-&gt;</span>_v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>

		<span class="token comment">// 调整</span>
		
		node<span class="token operator">*</span> grandfather <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">*</span>uncle <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> parent<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token comment">// parent存在且为红色时需继续向上调整</span>
		<span class="token punctuation">{<!-- --></span>
			grandfather <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">//情况1：u存在且为红</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
				grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>

				<span class="token comment">// 继续向上更新</span>
				cur <span class="token operator">=</span> grandfather<span class="token punctuation">;</span>
				parent <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">//情况2：u不存在/u存在且为黑</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">&amp;&amp;</span> parent <span class="token operator">==</span> grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 左左——右单旋</span>
					<span class="token function">RotateR</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>
					parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
					grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">&amp;&amp;</span> parent <span class="token operator">==</span> grandfather<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 右右——左单旋</span>
					<span class="token function">RotateL</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>
					parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
					grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> parent<span class="token operator">-&gt;</span>_right <span class="token operator">&amp;&amp;</span> parent <span class="token operator">==</span> grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 左右——左右双旋</span>
					<span class="token function">RotateL</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token function">RotateR</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>
					cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
					grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> parent<span class="token operator">-&gt;</span>_left <span class="token operator">&amp;&amp;</span> parent <span class="token operator">==</span> grandfather<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 右左——右左双旋</span>
					<span class="token function">RotateR</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token function">RotateL</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>
					cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
					grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// 经过情况2调整后，子树根节点必为黑，因此直接结束更新</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 最后写定根节点为黑色</span>
		_root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>

		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">// 右单旋</span>
	<span class="token keyword">void</span> <span class="token function">RotateR</span><span class="token punctuation">(</span>node<span class="token operator">*</span> pParent<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		node<span class="token operator">*</span> subL <span class="token operator">=</span> pParent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
		node<span class="token operator">*</span> subLR <span class="token operator">=</span> subL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
		node<span class="token operator">*</span> ppParent <span class="token operator">=</span> pParent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>

		<span class="token comment">//1.pParent(父)和subLR(子)</span>
		pParent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subLR<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>subLR<span class="token punctuation">)</span>
			subLR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> pParent<span class="token punctuation">;</span>

		<span class="token comment">//2.subL(父)和pParent(子)</span>
		subL<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> pParent<span class="token punctuation">;</span>
		pParent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subL<span class="token punctuation">;</span>

		<span class="token comment">//3.ppParent(父)和subL(子)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pParent <span class="token operator">==</span> _root<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_root <span class="token operator">=</span> subL<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>ppParent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> pParent<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				ppParent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subL<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				ppParent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subL<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		subL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> ppParent<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 左单旋</span>
	<span class="token keyword">void</span> <span class="token function">RotateL</span><span class="token punctuation">(</span>node<span class="token operator">*</span> pParent<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		node<span class="token operator">*</span> subR <span class="token operator">=</span> pParent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>
		node<span class="token operator">*</span> subRL <span class="token operator">=</span> subR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
		node<span class="token operator">*</span> ppParent <span class="token operator">=</span> pParent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>

		pParent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subRL<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>subRL<span class="token punctuation">)</span>
			subRL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> pParent<span class="token punctuation">;</span>

		subR<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> pParent<span class="token punctuation">;</span>
		pParent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subR<span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>pParent <span class="token operator">==</span> _root<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_root <span class="token operator">=</span> subR<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>ppParent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> pParent<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				ppParent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subR<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				ppParent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subR<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		subR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> ppParent<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	node<span class="token operator">*</span> _root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="5__436"></a>5. 红黑树的验证</h2> 
<p>💭<em>验证一棵树是否为红黑树，不能像AVL树一样简单粗暴地判断左右子树高度差的绝对值是否小于1，因为红黑树只是接近平衡。<strong>红黑树的验证需要验证其五条性质是否都成立</strong>。</em></p> 
<p>⭕红黑树的性质</p> 
<blockquote> 
 <ol><li>每个节点不是黑色就是红色</li><li>根节点为黑</li><li><strong>对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</strong></li><li><strong>不允许有相邻的两个红色节点</strong></li><li>每个叶节点都为黑（此处的叶节点指<code>NIL</code>节点）</li></ol> 
</blockquote> 
<p>性质1和性质5无需验证，通过代码就已经保证了。我们需要验证性质2、3、4。</p> 
<blockquote> 
 <p>💡思路：</p> 
 <ul><li>验证性质2：直接判断即可</li><li>验证性质3：先选取任一路径（一般旋转最左或最右路径），计算其黑节点数量，作为参考值，然后再用每一条路径的黑节点数量与参考值比较，只要有一条路径上的黑节点数量与参考值不相等，则不满足红黑树旋转3。</li><li>验证性质4：判断当前节点与其parent节点是否同时为红即可。（parent节点必存在，孩子节点不一定存在且情况多，所以选取parent与当前节点比较）。</li></ul> 
</blockquote> 
<p><strong>💬代码实现</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">RBTree</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> RBTreeNode<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...</span>
	<span class="token keyword">bool</span> <span class="token function">IsRBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">// 判断性质2</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"违反性质2：根节点为黑"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 求任意一条路径上的黑色节点数量，让其他路径上的与之对比</span>
		<span class="token comment">// 选取最左路径</span>
		node<span class="token operator">*</span> left <span class="token operator">=</span> _root<span class="token punctuation">;</span>
		<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				ref<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			left <span class="token operator">=</span> left<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// NIL节点也是黑色</span>
		ref<span class="token operator">++</span><span class="token punctuation">;</span>

		<span class="token comment">// 检查左右子树，需要传入路径到达当前节点的黑节点的数量</span>
		<span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_left<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ref<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_right<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>

	<span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span>node<span class="token operator">*</span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> prevBlackCount<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> refBlackCount<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 当前路径到达终点</span>
			<span class="token comment">// 黑色节点个数与参照值比较</span>

			<span class="token comment">// 加上NIL节点</span>
			prevBlackCount<span class="token operator">++</span><span class="token punctuation">;</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>prevBlackCount <span class="token operator">!=</span> refBlackCount<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"违反性质3：每条路径的黑节点数量应相同"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 判断性质4</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>_parent<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"违反性质4：不允许有相邻的两个红节点"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">// 计算路径到达当前节点的黑节点的数量</span>
		<span class="token keyword">int</span> curBlackCount <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> BLACK <span class="token operator">?</span> prevBlackCount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> prevBlackCount<span class="token punctuation">;</span>

		<span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">,</span> curBlackCount<span class="token punctuation">,</span> refBlackCount<span class="token punctuation">)</span>
			<span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">,</span> curBlackCount<span class="token punctuation">,</span> refBlackCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	node<span class="token operator">*</span> _root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>💬 测试函数</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">testRBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	RBTree<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> rbt<span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">14</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		rbt<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>rbt<span class="token punctuation">.</span><span class="token function">IsRBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The tree is a RBTree!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>📃 简易的递归图</strong><br> <img src="https://images2.imgbox.com/b6/fc/ktMdeN2b_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/92/82/CtdYtDim_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="6_AVL_564"></a>6. 红黑树和AVL树的比较</h2> 
<blockquote> 
 <p>💭红黑树和AVL树都是常见的自平衡二叉搜索树，它们都能够保证树的高度不会过高，从而保证了树的查询、插入和删除操作的时间复杂度都是O(logN)。但是它们之间有一些不同点。</p> 
</blockquote> 
<p>上面提到，红黑树是近似平衡，而AVL树是绝对平衡，因此，红黑树的查找效率低于AVL树。那么这对使用红黑树的影响大吗？那么需要探讨一下近似平衡的概念。</p> 
<ul><li><strong>近似平衡</strong><br> 红黑树通过对从根到叶子节点的任一条路径上各个节点的着色方式的限制，以达到近似平衡的效果，即最长路径长度不超过最短路径的二倍。近似平衡，通俗理解，在效率方面，越接近平衡越优，越不平衡越差，若要得到其查找的时间复杂度，就要分近似平衡的最优情况和最差情况讨论。</li></ul> 
<ol><li> <p><strong>最优情况</strong>：每条路径都是全黑，或者每条路径都是一红一黑相间。此时的红黑树是满二叉树，即最平衡的情况，查找的时间复杂度为<code>O(logN)</code><br> <img src="https://images2.imgbox.com/ef/69/XXoe5EfI_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>最差情况</strong>：每个节点的往左右的两条路径，一条全黑，一条一红一黑相间，此时左右两条路径有一条是另一条的两倍，这种情况下为最差情况。抽象示意图如下：</p> </li></ol> 
<p><img src="https://images2.imgbox.com/6c/60/d5kY1XNe_o.png" alt="在这里插入图片描述"></p> 
<p><strong>⭕分析：</strong></p> 
<p><em>设全黑路径长度（即最短路径长度）：h</em></p> 
<ul><li> <p>极端情况下，当N黑很大时，N红相对于N黑很小，可忽略不计</p> <p><code>N = N黑 + N红</code></p> <p>故 <code>N = N黑</code></p> </li><li> <p>此时只考虑黑色节点，可以想象成将红色节点都往最底部挪，那么上层是一个由黑色节点组成的满二叉树</p> <p>故：<code>N黑 = N = 2^h-1</code></p> <p><code>h = logN</code></p> </li></ul> 
<p>因为：<code>全黑路径长度 = 最短路径长度 = h</code><br> 所以：<code>最长路径长度 = 2×最短路径长度 = 2h = 2logN</code></p> 
<blockquote> 
 <p>🔎红黑树最差情况的查找，就是去找最长路径的最后一个节点，综上推论，大概要找<code>2logN</code>次。而在AVL树中，由于绝对平衡的结构，查找一个节点只需找<code>logN次</code>。</p> 
</blockquote> 
<ul><li> <p>给一个很大的数，比方说10亿。那么，在一棵10亿节点的AVL树中，查找的最坏情况是找30次（log10亿）。而在一棵10亿节点的红黑树中，查找的最坏情况是找60次（2*log10亿）。可见，<strong>红黑树的查找效率略低于AVL树</strong>，但是二者是同一个量级的，对于计算机来说，这点差别不算什么。所以这点效率区别对红黑树的使用影响并不大。</p> </li><li> <p>对于树的插入和删除。AVL树在插入或删除节点时，可能会需要更多地通过旋转操作来保持树的平衡，而旋转操作可能会导致更多的旋转，从而导致插入和删除操作的时间复杂度可能会比红黑树更高。而红黑树通过着色和旋转操作来保持平衡，旋转次数比AVL树少。因此<strong>红黑树插入和删除操作的效率可能会更高。</strong></p> </li></ul> 
<blockquote> 
 <p>💡得出结论：如果需要频繁进行插入和删除操作，且对查询效率要求不是特别高，可以选择红黑树；如果对查询效率有比较高的要求，且能够容忍插入和删除操作的效率稍低，可以选择AVL树。实际应用中，红黑树用的更多。</p> 
</blockquote> 
<hr> 
<h2><a id="7__612"></a>7. 红黑树的应用</h2> 
<blockquote> 
 <ol><li>C++ STL库 – <strong>map/set</strong>、mutil_map/mutil_set</li><li>Java 库</li><li>linux内核</li><li>其他一些库</li></ol> 
</blockquote> 
<p>💭<em>下一篇文章将带你了解map和set，并分析如何用红黑树实现它们。</em></p> 
<hr> 
<p><font size="4"><em>完。</em></font></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b6bf34835e80fe1762cd10b823c5565b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Vue学习笔记】路由详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a830de0f53387a30e4f2ede02042a717/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Google Earth导入经纬高（txt文件）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>