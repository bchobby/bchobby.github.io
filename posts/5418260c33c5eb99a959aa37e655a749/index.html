<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法--python学习笔记四(听了左神的课，自己整理的，左神还是强啊) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法--python学习笔记四(听了左神的课，自己整理的，左神还是强啊)" />
<meta property="og:description" content="class AbstractBinarySearchTree(object): def __init__(self, pHead): self.root = pHead self.size = 0 def createNode(self, value, parent, left, right): self.newNode = withParentNode(value) self.newNode.parent = parent self.newNode.left = left self.newNode.right = right return self.newNode def search(self, element): node = self.root while node is not None and node.value is not None and node.value != element: if element &lt; node.value: node = node.left else: node = node.right return node def insert(self, element): if self.root is None: self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/5418260c33c5eb99a959aa37e655a749/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-25T19:13:31+08:00" />
<meta property="article:modified_time" content="2019-03-25T19:13:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法--python学习笔记四(听了左神的课，自己整理的，左神还是强啊)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre>class AbstractBinarySearchTree(object):

    def __init__(self, pHead):
        self.root = pHead
        self.size = 0

    def createNode(self, value, parent, left, right):
        self.newNode = withParentNode(value)
        self.newNode.parent = parent
        self.newNode.left = left
        self.newNode.right = right
        return self.newNode

    def search(self, element):
        node = self.root
        while node is not None and node.value is not None and node.value != element:
            if element &lt; node.value:
                node = node.left
            else:
                node = node.right
        return node

    def insert(self, element):
        if self.root is None:
            self.root = self.createNode(element, None, None, None)
            self.size += 1
            return self.root
        insertParentNode = None
        searchTempNode = self.root
        while searchTempNode is not None and searchTempNode.value is not None:
            insertParentNode = searchTempNode
            if element &lt; searchTempNode.value:
                searchTempNode = searchTempNode.left
            else:
                searchTempNode = searchTempNode.right
        newNode = self.createNode(element, insertParentNode, None, None)
        if insertParentNode.value &gt; newNode.value:
            insertParentNode.left = newNode
        else:
            insertParentNode.right = newNode
        self.size += 1
        return newNode

    def delete(self, element):
        # 如果该节点既有左子树，又有右子树，则找到该节点右子树的最左节点，来代替它的位置。如果最左节点有右子树，则挂在该节点原来的位置
        deleteNode = self.search(element)
        if deleteNode is not None:
            return self.deleteNode(deleteNode)
        else:
            return None

    def deleteNode(self, delNode):
        if delNode is not None:
            nodeToReturn = None
            if delNode is not None:
                if delNode.left is None:
                    nodeToReturn = self.transplant(delNode, delNode.right)
                elif delNode.right is None:
                    nodeToReturn = self.transplant(delNode, delNode.left)
                else:
                    successorNode = self.getMinimum(delNode.right)
                    if successorNode.parent != delNode:
                        self.transplant(successorNode, successorNode.right)
                        successorNode.right = delNode.right
                        successorNode.right.parent = successorNode
                    self.transplant(delNode, successorNode)
                    successorNode.left = delNode.left
                    successorNode.left.parent = successorNode
                    nodeToReturn = successorNode
                self.size -= 1
            return nodeToReturn

    def transplant(self, nodeToReplace, newNode):
        if nodeToReplace.parent is None:
            self.root = newNode
        elif nodeToReplace == nodeToReplace.parent.left:
            nodeToReplace.parent.left = newNode
        else:
            nodeToReplace.parent.right = newNode
        if newNode is not None:
            newNode.parent = nodeToReplace.parent
        return newNode

    def getMinimum(self, node):
        while node.left is not None:
            node = node.left
        return node


class AVLNode(object):
    def __init__(self, value, parent, left, right, height):
        self.value = value
        self.parent = parent
        self.left = left
        self.right = right
        self.height = height


class AVLTree(AbstractBinarySearchTree):

    def insert(self, element):
        newNode = self.insert(element)
        return newNode

    def rebalance(self, pHead):
        while pHead is not None:
            parentNode = pHead.parent
            leftHeight = -1 if pHead.left is None else pHead.left.height
            rightHeight = -1 if pHead.right is None else pHead.right.height
            nodeBalance = rightHeight - leftHeight
            if nodeBalance == 2:
                if pHead.right.right is not None:
                    pHead = self.avlRotateLeft(pHead)
                    break
                else:
                    pHead = self.doubleRotateRightLeft(pHead)
                    break
            elif nodeBalance == -2:
                if pHead.left.left is not None:
                    pHead = self.avlRotateRight(pHead)
                    break
                else:
                    pHead = self.doubleRotateLeftRight(pHead)
                    break
            else:
                self.updateHeight(pHead)
            pHead = parentNode

    def updateHeight(self, pHead):
        leftHeight = -1 if pHead.left is None else pHead.left.height
        rightHeight = -1 if pHead.right is None else pHead.right.height
        pHead.height = 1 + max(leftHeight, rightHeight)

    def avlRotateLeft(self, pHead):
        temp = self.rotateLeft(pHead)
        self.updateHeight(temp.left)
        self.updateHeight(temp)
        return temp

    def avlRotateRight(self, pHead):
        temp = self.rotateRight(pHead)
        self.updateHeight(temp.right)
        self.updateHeight(temp)
        return temp

    def doubleRotateRightLeft(self, pHead):
        pHead.right = self.avlRotateRight(pHead.right)
        return self.avlRotateLeft(pHead)

    def doubleRotateLeftRight(self, pHead):
        pHead.left = self.avlRotateLeft(pHead.left)
        return self.avlRotateRight(pHead)

    def rotateLeft(self, pHead):
        temp = pHead.right
        temp.parent = pHead.parent
        pHead.right = temp.left
        if pHead.right is not None:
            pHead.right.parent = pHead
        temp.left = pHead
        pHead.parent = temp

    # temp took over node's place so now its parent should point to temp
        if temp.parent is not None:
            if pHead == temp.parent.left:
                temp.parent.left = temp
            else:
                temp.parent.right = temp
        else:
            self.root = temp
        return temp

    def rotateRight(self, pHead):
        temp = pHead.left
        temp.parent = pHead.parent
        pHead.left = temp.right
        if pHead.left is not None:
            pHead.left.parent = pHead
        temp.right = pHead
        pHead.parent = temp
        # temp took over node's place so now its parent should point to temp
        if temp.parent is not None:
            if pHead == temp.parent.left:
                temp.parent.left = temp
            else:
                temp.parent.right = temp
        else:
            self.root = temp
        return temp


def maxLength(alist, aim):
    """给定数组，返回满足累加和为aim的子数组的最大长度"""
    if alist == [] or len(alist) == 0:
        return 0
    mapDict = {}
    mapDict.update({0: -1})
    maxLen, sumNum = 0, 0
    for i in range(len(alist)):
        sumNum += alist[i]
        if (sumNum - aim) in mapDict.keys():
            maxLen = max(i - mapDict.get(sumNum - aim), maxLen)
        if sumNum not in mapDict.keys():
            mapDict.update({sumNum: i})
    return maxLen


def mostEOR(alist):
    """将给定数组进行分组，保证每组的异或和为0，返回最多的子数组数"""
    ans, xor = 0, 0
    dp = [0] * len(alist)
    mapDict = {}
    mapDict.update({0: -1})
    for i in range(len(alist)):
        xor ^= alist[i]
        if xor in mapDict.keys():
            pre = mapDict.get(xor)
            dp[i] = 1 if pre == -1 else dp[pre] + 1
        if i &gt; 0:
            dp[i] = max(dp[i - 1], dp[i])
        mapDict.update({xor: i})
        ans = max(ans, dp[i])
    return ans


def biggestSubNSTInTree(pHead):
    record = [] * 3  # 0 -&gt; size  1 -&gt; min  2 -&gt; max
    return posOrder(pHead, record)


def posOrder(pHead, record):
    if pHead is None:
        record[0] = 0
        record[1] = 0
        record[2] = 0
        return None
    value = pHead.value
    leftNode = pHead.left
    rightNode = pHead.right
    lBST = posOrder(leftNode, record)
    lSize = record[0]
    lMin = record[1]
    lMax = record[2]
    rBST = posOrder(rightNode, record)
    rSize = record[0]
    rMin = record[1]
    rMax = record[2]
    record[1] = min(rMin, lMin, value)  #  lmin, value, rmin -&gt; min
    record[2] = max(lMax, rMax, value)  #  lmax, value, rmax -&gt; max
    if leftNode == lBST and rightNode == rBST and lMax &lt; value &lt; rMin:
        record[0] = lSize + rSize + 1
        return pHead
    record[0] = max(lSize, rSize)
    return lBST if lSize &gt; rSize else rBST


def biggestSubNSTInTreeProcess(pHead):
    if pHead is None:
        return 0, None, 0, 0
    leftTree = pHead.left
    leftSubTressInfo = biggestSubNSTInTreeProcess(leftTree)
    rightTree = pHead.right
    rightSubTressInfo = biggestSubNSTInTreeProcess(rightTree)

    includeItSelf = 0
    if leftSubTressInfo[1] == leftTree and rightSubTressInfo[1] == rightTree and \
            rightSubTressInfo[2] &gt; pHead.value &gt; leftSubTressInfo[2]:
        includeItSelf = leftSubTressInfo[0] + 1 + rightSubTressInfo[0]
    p1, p2 = leftSubTressInfo[0], rightSubTressInfo[0]
    maxSize = max(p1, p2, includeItSelf)
    maxpHead = leftSubTressInfo[1] if p1 &gt; p2 else rightSubTressInfo[1]
    if maxSize == includeItSelf:
        maxpHead = pHead
    return maxSize, maxpHead


# 节点A走到节点B的距离为：A走到B最短路径上的节点个数。求一颗二叉树上的最远距离
def MaxDistanceInTree(pHead):
    """节点A走到节点B的距离为：A走到B最短路径上的节点个数。求一颗二叉树上的最远距离"""
    return MaxDistanceInTreeProcess(pHead)[0]


def MaxDistanceInTreeProcess(pHead):
    if pHead is None:
        return 0, 0
    leftReturnType = MaxDistanceInTreeProcess(pHead.left)
    rightReturnType = MaxDistanceInTreeProcess(pHead.right)
    includeHeadDistance = leftReturnType[1] + 1 + rightReturnType[1]
    p1, p2 = leftReturnType[0], rightReturnType[0]
    resultDistance = max(p1, p2, includeHeadDistance)
    hitself = max(leftReturnType[1], rightReturnType[1]) + 1
    return resultDistance, hitself


class maxHappyNode(object):
    def __init__(self, huo):
        self.huo = huo
        self.nexts = []


def getMaxHuo(pHead):
    """活跃度的计算"""
    return max(getMaxHuoProcess(pHead)[0], getMaxHuoProcess(pHead)[1])


def getMaxHuoProcess(pHead):
    lai_huo, bu_lai_huo = pHead.huo, 0
    if pHead.nexts == []:
        return pHead.huo, 0
    for i in range(len(pHead.nexts)):
        nextNode = pHead.nexts[i]
        nextNodeReturn = getMaxHuoProcess(nextNode)
        lai_huo += nextNodeReturn[1]
        bu_lai_huo = max(nextNodeReturn[0], nextNodeReturn[1])
    return lai_huo, bu_lai_huo


class LRUNode(object):
    def __init__(self, value):
        self.value = value
        self.last = None
        self.next = None


class NodeDoubleLinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None

    def addNode(self, newNode):
        if newNode is None:
            return None
        if self.head is None:
            self.head = newNode
            self.tail = newNode
        else:
            self.tail.next = newNode
            newNode.last = self.tail
            self.tail = newNode

    def moveNodeToTail(self, pHead):
        if self.tail == pHead:
            return
        if self.head == pHead:
            self.head = pHead.next
            self.head.last = None
        else:
            pHead.last.next = pHead.next
            pHead.next.last = pHead.last
        pHead.last = self.tail
        pHead.next = None
        self.tail.next = pHead
        self.tail = pHead

    def removeHead(self):
        if self.head is None:
            return None
        res = self.head
        if self.head == self.tail:
            self.head = None
            self.tail = None
        else:
            self.head = res.next
            res.next = None
            self.head.last = None
        return res


# 自定义一种缓存结构(LRU)，假设大小为K，能实现两个功能set()和get()
#   set和get方法的时间复杂度为O(1)
#   某个key的set或get操作一旦发生，则认为这个key的记录成了最经常使用的
#   当缓存的大小超过K时，移除最不经常使用的记录
class MyCache(object):

    def __init__(self, capacity):
        if capacity &lt; 1:  # capacity指限定的内存大小
            raise RuntimeError("should be more than 0.")
        self.keyNodeMap = {}
        self.nodeKeyMap = {}
        self.nodeList = NodeDoubleLinkedList()
        self.capacity = capacity

    def get(self, K):
        if K in self.keyNodeMap.keys():
            res = self.keyNodeMap[K]
            self.nodeList.moveNodeToTail(res)
            return res.value
        return None

    def set(self, K, V):
        if K in self.keyNodeMap.keys():
            node = self.keyNodeMap[K]
            node.value = V
            self.nodeList.moveNodeToTail(node)
        else:
            newNode = LRUNode(V)
            self.keyNodeMap.update({K: newNode})
            self.nodeKeyMap.update({newNode: K})
            self.nodeList.addNode(newNode)
            if len(self.keyNodeMap) == self.capacity + 1:
                self.removeMostUnusedCache()

    def removeMostUnusedCache(self):
        removeNode = self.nodeList.removeHead()
        K = self.nodeKeyMap[removeNode]
        del self.nodeKeyMap[removeNode]
        del self.keyNodeMap[K]


class LFUNode(object):
    def __init__(self, key, value, times):
        self.key = key
        self.value = value
        self.times = times
        self.up = None
        self.down = None


class NodeList(object):
    def __init__(self, pHead):
        self.next = None
        self.last = None
        self.head = pHead
        self.tail = pHead

    def addNodeFromHead(self, newHead):
        newHead.down = self.head
        self.head = newHead

    def isEmpty(self):
        return self.head is None

    def deleteNode(self, pHead):
        """删除任意节点pHead"""
        if self.head == self.tail:
            self.head = None
            self.tail = None
        elif pHead == self.head:
            self.head = pHead.down
            self.head.up = None
        elif pHead == self.tail:
            self.tail = pHead.up
            self.tail.down = None
        else:
            pHead.up.down = pHead.down
            pHead.down.up = pHead.up
        pHead.up = None
        pHead.down = None


class LFUCache(object):
    def __init__(self, capacity):
        self.capacity = capacity  # 容量
        self.size = 0  # 实际存储的个数
        self.records = {}  # key(Integer): node
        self.heads = {}  # node: NodeList
        self.headlist = NodeList(None)

    def set(self, key, value):
        if key in self.records.keys():
            pHead = self.records[key]
            pHead.value = value
            pHead.times += 1
            curNodeList = self.heads[pHead]
            self.move(pHead, curNodeList)
        else:
            if self.size == self.capacity:
                pHead = self.headlist.tail
                self.headlist.deleteNode(pHead)
                self.modifyHeadList(self.headlist)
                del self.records[pHead.key]
                del self.heads[pHead]
                self.size -= 1
            pHead = LFUNode(key, value, 1)
            if self.headlist is None:
                self.headlist = NodeList(pHead)
            elif self.headlist.head.times == pHead.times:
                self.headlist.addNodeFromHead(pHead)
            else:
                newList = NodeList(pHead)
                newList.next = self.headlist
                self.headlist.last = newList
                self.headlist = newList
        self.records.update({key: pHead})
        self.heads.update({pHead: self.headlist})
        self.size += 1

    def get(self, key):
        if key not in self.records.keys():
            return -1
        pHead = self.records[key]
        pHead.times += 1
        curNodeList = self.heads[pHead]
        self.move(pHead, curNodeList)
        return pHead.value

    # return whether delete this head
    def modifyHeadList(self, nodeList):
        if nodeList.isEmpty():
            if self.headlist == nodeList:
                self.headlist = nodeList.next
                if self.headlist is not None:
                    self.headlist.last = None
            else:
                nodeList.last.next = nodeList.next
                if nodeList.next is not None:
                    nodeList.next.last = nodeList.last
            return True
        return False

    # 将一个节点从老链表拿出，送到新链表中，需要考虑：
    #       老链表在删除之后，是否还有存在必要(老链表中只有一个节点)
    #       老链表是否是头链表
    #       新链表是否存在(老链表是否是尾链表)
    #       新链表是否与老链表在次数是相连的(比如老链表中的times均是4，而与之相连的链表的times为6，此时需要新建一个times为5的链表)
    def move(self, node, oldNodeList):
        oldNodeList.deleteNode(node)
        preList = oldNodeList.last if self.modifyHeadList(oldNodeList) else oldNodeList
        nextList = oldNodeList.next
        if nextList is None:
            newList = NodeList(node)
            if preList is not None:
                preList.next = newList
            newList.last = preList
            if self.headlist is None:
                self.headlist = newList
            self.heads.update({node, newList})
        else:
            if nextList.head.times == node.times:
                nextList.addNodeFromHead(node)
                self.heads.update({node, nextList})
            else:
                newList = NodeList(node)
                if preList is not None:
                    preList.next = newList
                newList.last = preList
                newList.next = nextList
                nextList.last = newList
                if self.headlist == nextList:
                    self.headlist = newList
                self.heads.update({node, newList})</pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81a36c04aec57cdd01cd2b1a36d5ac06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构与算法--python学习笔记三(听了左神的课，自己整理的，左神还是强啊)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c0daa32ef1f5983841bd01fa8a5366b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构与算法--python学习笔记五(听了左神的课，自己整理的，左神还是强啊)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>