<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP/UDP协议 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP/UDP协议" />
<meta property="og:description" content="1. 请解释TCP和UDP的主要区别。 TCP和UDP都是位于传输层的协议，具有不同的特点和应用场景。以下是它们的主要区别：
连接方式：TCP是面向连接的协议，这意味着在数据传输之前需要先建立连接。这通常通过三次握手来建立连接，以确保通信双方都已准备好。而UDP是无连接的，即在发送数据之前不需要建立连接。
可靠性：TCP提供了可靠的数据传输服务。它通过使用确认、重传和流量控制等机制来确保数据的完整性和正确性。与此相反，UDP是不可靠的，它不保证数据的完整性或正确性。
传输速度：由于TCP需要进行各种检查和确认，其传输速度可能相对较慢。而UDP由于没有这些额外的机制，因此在传输速度上通常更快。
应用场景：TCP通常用于需要高可靠性的应用，如Web服务器、电子邮件和文件传输等。而UDP则常用于对实时性要求较高的应用，如视频流、在线游戏和VoIP通话等。
数据流量控制：TCP有流量控制机制，可以避免数据传输过快导致的问题。而UDP没有流量控制功能，因此可能会导致数据丢失或网络拥塞。
数据包顺序：TCP保证数据包的顺序，即数据包会按照发送的顺序到达接收端。而UDP则不保证数据包的顺序，数据包可能会乱序到达接收端。
头部开销：TCP的头部开销较大，因为它需要携带更多的信息来保证可靠性。而UDP的头部开销较小，这使得其在传输小数据包时更为高效。
2. TCP协议是如何保证数据的可靠性的？ TCP协议保证数据传输可靠性的方式主要有以下几种：
校验和：TCP在数据传输过程中，将每个发送的数据包进行校验和计算，并将结果添加到数据包头部。接收方在接收到数据包后，会对数据包进行校验和的验证，如果发现校验和不匹配，就会向发送方发送错误报告。
序列号确认应答：TCP为每个字节分配一个序列号，接收方会对序列号进行检查并确认应答，以此来确保数据的完整性和正确性。
超时重传：如果发送方在规定时间内没有收到接收方的确认应答，就会认为该数据包已丢失或损坏，进而进行超时重传。
连接管理：TCP通过三次握手来建立连接，并采用四次挥手来终止连接，这种方式可以确保连接的可靠性。
流量控制和拥塞控制：TCP通过流量控制机制来避免数据传输过快导致的问题，同时，通过拥塞控制机制来避免网络拥塞，这两者都有助于保障数据的可靠传输。
3. TCP协议是如何实现流量控制的？ TCP协议实现流量控制的主要机制是滑动窗口。在TCP的数据传输过程中，发送方会持续地维护一个叫做“窗口”的数据结构，而接收方也会维护一个类似的数据结构。这两个“窗口”分别代表了发送方和接收方可以接收或发送的数据量。
当发送方需要向接收方发送数据时，它会先查看自己的窗口。如果窗口允许，那么它就会将一部分数据发出去。一旦这些数据被发送出去，窗口就会相应地缩小。
同时，接收方会根据自己的处理能力来动态调整其窗口的大小。如果接收方发现自己处理不过来了，那么它就会通过TCP协议告诉发送方，让自己的窗口变小一些。
此外，网络中的拥塞状况也会影响到发送方一次可以向接收方发送的TCP报文段的大小和数量。具体来说，无论处于流量控制还是拥塞控制的目的，发送方的发送速率总是受到两者中较小一者的限制。
总的来说，TCP协议通过这种动态调整窗口大小的方式，实现了对数据传输速度和流量的有效控制，从而避免了因网络拥塞而导致的数据包丢失和网络堵塞的现象。
4. TCP协议是如何实现拥塞控制的？ TCP协议实现拥塞控制的主要方法是通过&#34;拥塞窗口&#34;变量来动态调整发送速率。在TCP的发送端，所有未收到确认的数据段必须落在这个窗口内。当网络出现拥塞时，TCP程序会减小拥塞窗口的大小，从而降低数据的发送速率；反之，当网络状况好转时，TCP程序会增大拥塞窗口的大小，提高数据的发送速率。
此外，TCP协议还设计了四种拥塞控制算法：慢开始、拥塞避免、快重传和快恢复。这些算法结合使用，可以有效地防止过多的数据注入到网络中，避免出现网络负载过大的情况。
慢开始：发送方在开始发送数据时，会先探测一下网络的状况，如果网络状况良好，则逐渐增大拥塞窗口的大小；否则，会按照一定的规则逐渐增大拥塞窗口的大小。拥塞避免：当拥塞窗口的大小达到一个阈值时，就会进入拥塞避免阶段。在这个阶段，拥塞窗口的大小会按照线性增长的规则逐渐增大。快重传：当发送方连续收到三个重复的确认报文时，就会直接重传数据包，而不用等待超时重传定时器的时间到了再重传。快恢复：当发送方连续收到三个重复的确认报文时，它会把慢开始门限设置为当前拥塞窗口大小的一半，然后把拥塞窗口的大小设定为慢开始门限加上3个报文段的大小。 5. 请解释TCP三次握手和四次挥手的过程。 TCP三次握手和四次挥手是TCP协议中建立连接和断开连接的两个重要过程。
三次握手：
第一次握手：客户端向服务器发送一个SYN（同步）报文，表示请求建立连接。第二次握手：服务器接收到SYN报文后，会发送一个SYN&#43;ACK（同步确认）报文给客户端，表示同意建立连接。第三次握手：客户端接收到SYN&#43;ACK报文后，会发送一个ACK（确认）报文给服务器，表示已经准备好建立连接了。
通过三次握手，客户端和服务器之间建立了可靠的连接，并确定了双方的序列号。 四次挥手：
第一次挥手：客户端发送一个FIN（结束）报文给服务器，表示即将关闭连接。第二次挥手：服务器接收到FIN报文后，会发送一个ACK（确认）报文给客户端，表示已经收到了客户端的结束信号。第三次挥手：客户端接收到ACK报文后，会发送一个FIN（结束）报文给服务器，表示已经关闭了连接。第四次挥手：服务器接收到FIN报文后，会发送一个ACK（确认）报文给客户端，表示已经收到了客户端的结束信号，并且也准备关闭连接了。
通过四次挥手，客户端和服务器之间的连接被彻底关闭。 总之，TCP三次握手和四次挥手的过程确保了数据传输的可靠性和安全性，避免了网络中的资源浪费和数据丢失。
6. 请解释TCP的慢启动、拥塞避免、快速重传和快速恢复算法。 TCP的慢启动、拥塞避免、快速重传和快速恢复算法是TCP协议中用于控制数据传输速率和处理网络拥塞的重要机制。
慢启动（Slow Start）：在TCP连接建立后，发送方的初始窗口大小为1个MSS（最大段大小）。当接收方确认一个数据段时，发送方会将窗口大小翻倍。但是，如果在一定时间内没有收到任何确认信息，发送方会将窗口大小减半，并等待一段时间后再尝试翻倍。这个过程被称为“慢启动”。
拥塞避免（Congestion Avoidance）：当网络出现拥塞时，TCP协议会通过降低发送速率来减少拥塞的程度。发送方会逐渐减小其发送速率，直到网络状况得到改善。这个过程被称为“拥塞避免”。
快速重传（Fast Retransmit）：当发送方在规定的时间内未收到接收方的确认信息时，它会认为数据包丢失或出错，并要求重新发送该数据包。这个过程被称为“快速重传”。
快速恢复（Fast Recovery）：当接收方检测到网络状况已得到改善时，它会通知发送方可以恢复其发送速率。发送方会逐渐增加其发送速率，直到达到原来的值。这个过程被称为“快速恢复”。
这些算法共同作用，确保了TCP协议在面对网络拥塞时能够有效地调整数据传输速率，从而保证了数据传输的可靠性和效率。
7. UDP协议的特点是什么？为什么它比TCP更快？ UDP协议的特点包括以下几个方面：
无连接：UDP协议不需要建立连接，也不需要维护连接状态。数据报文直接发送到目标地址，不会等待确认应答。
不可靠：UDP协议没有提供可靠性保证，数据报文在传输过程中可能会出现丢失、重复或乱序的情况。
无流量控制：UDP协议没有内置的流量控制机制，发送方可以以任意速率发送数据，接收方无法控制数据的接收速度。
无拥塞控制：UDP协议没有内置的拥塞控制机制，网络拥塞时无法进行自适应调整。
面向数据报文：UDP协议采用面向数据报文的方式传输数据，每个数据报文都是独立的，包含完整的信息。
相比于TCP协议，UDP协议更快的原因主要有以下几点：
无需建立连接和维持连接状态：TCP协议需要进行三次握手来建立连接，而UDP协议可以直接发送数据报文，省去了连接建立和断开的时间开销。
无需等待确认应答：TCP协议在发送数据后需要等待接收方的确认应答，而UDP协议不需要等待确认应答，可以连续发送多个数据报文。
无流量控制和拥塞控制：TCP协议通过滑动窗口机制进行流量控制和拥塞控制，而UDP协议没有这些机制，可以更快速地传输数据。
需要注意的是，由于UDP协议的不可靠性，它适用于对实时性要求较高但允许一定数据丢失的场景，如音视频传输、网络游戏等。而对于对数据传输可靠性要求较高的场景，如文件传输、电子邮件等，通常使用TCP协议。
8. 请解释UDP如何实现数据包的顺序传输。 UDP协议本身并不保证数据包的顺序传输。因为UDP是无连接的，每个数据包都是独立发送的，并且没有序列号和确认机制来保证数据包的顺序。因此，如果多个数据包在网络上同时传输，到达接收端的顺序可能与发送端的顺序不同。
然而，在应用层，可以通过一些手段来实现UDP数据包的顺序传输。以下是几种常见的方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/551e18b101fe5afcbe182f8d67bdab72/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T15:44:52+08:00" />
<meta property="article:modified_time" content="2023-12-29T15:44:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP/UDP协议</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_TCPUDP_0"></a>1. 请解释TCP和UDP的主要区别。</h3> 
<p>TCP和UDP都是位于传输层的协议，具有不同的特点和应用场景。以下是它们的主要区别：</p> 
<ol><li> <p><strong>连接方式</strong>：TCP是面向连接的协议，这意味着在数据传输之前需要先建立连接。这通常通过三次握手来建立连接，以确保通信双方都已准备好。而UDP是无连接的，即在发送数据之前不需要建立连接。</p> </li><li> <p><strong>可靠性</strong>：TCP提供了可靠的数据传输服务。它通过使用确认、重传和流量控制等机制来确保数据的完整性和正确性。与此相反，UDP是不可靠的，它不保证数据的完整性或正确性。</p> </li><li> <p><strong>传输速度</strong>：由于TCP需要进行各种检查和确认，其传输速度可能相对较慢。而UDP由于没有这些额外的机制，因此在传输速度上通常更快。</p> </li><li> <p><strong>应用场景</strong>：TCP通常用于需要高可靠性的应用，如Web服务器、电子邮件和文件传输等。而UDP则常用于对实时性要求较高的应用，如视频流、在线游戏和VoIP通话等。</p> </li><li> <p><strong>数据流量控制</strong>：TCP有流量控制机制，可以避免数据传输过快导致的问题。而UDP没有流量控制功能，因此可能会导致数据丢失或网络拥塞。</p> </li><li> <p><strong>数据包顺序</strong>：TCP保证数据包的顺序，即数据包会按照发送的顺序到达接收端。而UDP则不保证数据包的顺序，数据包可能会乱序到达接收端。</p> </li><li> <p><strong>头部开销</strong>：TCP的头部开销较大，因为它需要携带更多的信息来保证可靠性。而UDP的头部开销较小，这使得其在传输小数据包时更为高效。</p> </li></ol> 
<h3><a id="2_TCP_17"></a>2. TCP协议是如何保证数据的可靠性的？</h3> 
<p>TCP协议保证数据传输可靠性的方式主要有以下几种：</p> 
<ol><li> <p><strong>校验和</strong>：TCP在数据传输过程中，将每个发送的数据包进行校验和计算，并将结果添加到数据包头部。接收方在接收到数据包后，会对数据包进行校验和的验证，如果发现校验和不匹配，就会向发送方发送错误报告。</p> </li><li> <p><strong>序列号确认应答</strong>：TCP为每个字节分配一个序列号，接收方会对序列号进行检查并确认应答，以此来确保数据的完整性和正确性。</p> </li><li> <p><strong>超时重传</strong>：如果发送方在规定时间内没有收到接收方的确认应答，就会认为该数据包已丢失或损坏，进而进行超时重传。</p> </li><li> <p><strong>连接管理</strong>：TCP通过三次握手来建立连接，并采用四次挥手来终止连接，这种方式可以确保连接的可靠性。</p> </li><li> <p><strong>流量控制和拥塞控制</strong>：TCP通过流量控制机制来避免数据传输过快导致的问题，同时，通过拥塞控制机制来避免网络拥塞，这两者都有助于保障数据的可靠传输。</p> </li></ol> 
<h3><a id="3_TCP_30"></a>3. TCP协议是如何实现流量控制的？</h3> 
<p>TCP协议实现流量控制的主要机制是滑动窗口。在TCP的数据传输过程中，发送方会持续地维护一个叫做“窗口”的数据结构，而接收方也会维护一个类似的数据结构。这两个“窗口”分别代表了发送方和接收方可以接收或发送的数据量。</p> 
<p>当发送方需要向接收方发送数据时，它会先查看自己的窗口。如果窗口允许，那么它就会将一部分数据发出去。一旦这些数据被发送出去，窗口就会相应地缩小。</p> 
<p>同时，接收方会根据自己的处理能力来动态调整其窗口的大小。如果接收方发现自己处理不过来了，那么它就会通过TCP协议告诉发送方，让自己的窗口变小一些。</p> 
<p>此外，网络中的拥塞状况也会影响到发送方一次可以向接收方发送的TCP报文段的大小和数量。具体来说，无论处于流量控制还是拥塞控制的目的，发送方的发送速率总是受到两者中较小一者的限制。</p> 
<p>总的来说，TCP协议通过这种动态调整窗口大小的方式，实现了对数据传输速度和流量的有效控制，从而避免了因网络拥塞而导致的数据包丢失和网络堵塞的现象。</p> 
<h3><a id="4_TCP_41"></a>4. TCP协议是如何实现拥塞控制的？</h3> 
<p>TCP协议实现拥塞控制的主要方法是通过"拥塞窗口"变量来动态调整发送速率。在TCP的发送端，所有未收到确认的数据段必须落在这个窗口内。当网络出现拥塞时，TCP程序会减小拥塞窗口的大小，从而降低数据的发送速率；反之，当网络状况好转时，TCP程序会增大拥塞窗口的大小，提高数据的发送速率。</p> 
<p>此外，TCP协议还设计了四种拥塞控制算法：慢开始、拥塞避免、快重传和快恢复。这些算法结合使用，可以有效地防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p> 
<ul><li><strong>慢开始</strong>：发送方在开始发送数据时，会先探测一下网络的状况，如果网络状况良好，则逐渐增大拥塞窗口的大小；否则，会按照一定的规则逐渐增大拥塞窗口的大小。</li><li><strong>拥塞避免</strong>：当拥塞窗口的大小达到一个阈值时，就会进入拥塞避免阶段。在这个阶段，拥塞窗口的大小会按照线性增长的规则逐渐增大。</li><li><strong>快重传</strong>：当发送方连续收到三个重复的确认报文时，就会直接重传数据包，而不用等待超时重传定时器的时间到了再重传。</li><li><strong>快恢复</strong>：当发送方连续收到三个重复的确认报文时，它会把慢开始门限设置为当前拥塞窗口大小的一半，然后把拥塞窗口的大小设定为慢开始门限加上3个报文段的大小。</li></ul> 
<h3><a id="5_TCP_51"></a>5. 请解释TCP三次握手和四次挥手的过程。</h3> 
<p>TCP三次握手和四次挥手是TCP协议中建立连接和断开连接的两个重要过程。</p> 
<ol><li> <p>三次握手：</p> 
  <ul><li>第一次握手：客户端向服务器发送一个SYN（同步）报文，表示请求建立连接。</li><li>第二次握手：服务器接收到SYN报文后，会发送一个SYN+ACK（同步确认）报文给客户端，表示同意建立连接。</li><li>第三次握手：客户端接收到SYN+ACK报文后，会发送一个ACK（确认）报文给服务器，表示已经准备好建立连接了。<br> 通过三次握手，客户端和服务器之间建立了可靠的连接，并确定了双方的序列号。</li></ul> </li><li> <p>四次挥手：</p> 
  <ul><li>第一次挥手：客户端发送一个FIN（结束）报文给服务器，表示即将关闭连接。</li><li>第二次挥手：服务器接收到FIN报文后，会发送一个ACK（确认）报文给客户端，表示已经收到了客户端的结束信号。</li><li>第三次挥手：客户端接收到ACK报文后，会发送一个FIN（结束）报文给服务器，表示已经关闭了连接。</li><li>第四次挥手：服务器接收到FIN报文后，会发送一个ACK（确认）报文给客户端，表示已经收到了客户端的结束信号，并且也准备关闭连接了。<br> 通过四次挥手，客户端和服务器之间的连接被彻底关闭。</li></ul> </li></ol> 
<p>总之，TCP三次握手和四次挥手的过程确保了数据传输的可靠性和安全性，避免了网络中的资源浪费和数据丢失。</p> 
<h3><a id="6_TCP_69"></a>6. 请解释TCP的慢启动、拥塞避免、快速重传和快速恢复算法。</h3> 
<p>TCP的慢启动、拥塞避免、快速重传和快速恢复算法是TCP协议中用于控制数据传输速率和处理网络拥塞的重要机制。</p> 
<ol><li> <p>慢启动（Slow Start）：在TCP连接建立后，发送方的初始窗口大小为1个MSS（最大段大小）。当接收方确认一个数据段时，发送方会将窗口大小翻倍。但是，如果在一定时间内没有收到任何确认信息，发送方会将窗口大小减半，并等待一段时间后再尝试翻倍。这个过程被称为“慢启动”。</p> </li><li> <p>拥塞避免（Congestion Avoidance）：当网络出现拥塞时，TCP协议会通过降低发送速率来减少拥塞的程度。发送方会逐渐减小其发送速率，直到网络状况得到改善。这个过程被称为“拥塞避免”。</p> </li><li> <p>快速重传（Fast Retransmit）：当发送方在规定的时间内未收到接收方的确认信息时，它会认为数据包丢失或出错，并要求重新发送该数据包。这个过程被称为“快速重传”。</p> </li><li> <p>快速恢复（Fast Recovery）：当接收方检测到网络状况已得到改善时，它会通知发送方可以恢复其发送速率。发送方会逐渐增加其发送速率，直到达到原来的值。这个过程被称为“快速恢复”。</p> </li></ol> 
<p>这些算法共同作用，确保了TCP协议在面对网络拥塞时能够有效地调整数据传输速率，从而保证了数据传输的可靠性和效率。</p> 
<h3><a id="7_UDPTCP_82"></a>7. UDP协议的特点是什么？为什么它比TCP更快？</h3> 
<p>UDP协议的特点包括以下几个方面：</p> 
<ol><li> <p>无连接：UDP协议不需要建立连接，也不需要维护连接状态。数据报文直接发送到目标地址，不会等待确认应答。</p> </li><li> <p>不可靠：UDP协议没有提供可靠性保证，数据报文在传输过程中可能会出现丢失、重复或乱序的情况。</p> </li><li> <p>无流量控制：UDP协议没有内置的流量控制机制，发送方可以以任意速率发送数据，接收方无法控制数据的接收速度。</p> </li><li> <p>无拥塞控制：UDP协议没有内置的拥塞控制机制，网络拥塞时无法进行自适应调整。</p> </li><li> <p>面向数据报文：UDP协议采用面向数据报文的方式传输数据，每个数据报文都是独立的，包含完整的信息。</p> </li></ol> 
<p>相比于TCP协议，UDP协议更快的原因主要有以下几点：</p> 
<ol><li> <p>无需建立连接和维持连接状态：TCP协议需要进行三次握手来建立连接，而UDP协议可以直接发送数据报文，省去了连接建立和断开的时间开销。</p> </li><li> <p>无需等待确认应答：TCP协议在发送数据后需要等待接收方的确认应答，而UDP协议不需要等待确认应答，可以连续发送多个数据报文。</p> </li><li> <p>无流量控制和拥塞控制：TCP协议通过滑动窗口机制进行流量控制和拥塞控制，而UDP协议没有这些机制，可以更快速地传输数据。</p> </li></ol> 
<p>需要注意的是，由于UDP协议的不可靠性，它适用于对实时性要求较高但允许一定数据丢失的场景，如音视频传输、网络游戏等。而对于对数据传输可靠性要求较高的场景，如文件传输、电子邮件等，通常使用TCP协议。</p> 
<h3><a id="8_UDP_105"></a>8. 请解释UDP如何实现数据包的顺序传输。</h3> 
<p>UDP协议本身并不保证数据包的顺序传输。因为UDP是无连接的，每个数据包都是独立发送的，并且没有序列号和确认机制来保证数据包的顺序。因此，如果多个数据包在网络上同时传输，到达接收端的顺序可能与发送端的顺序不同。</p> 
<p>然而，在应用层，可以通过一些手段来实现UDP数据包的顺序传输。以下是几种常见的方法：</p> 
<ol><li> <p>序列号：在应用层为每个数据包分配一个唯一的序列号，接收端按照序列号的顺序对接收到的数据包进行排序。这种方法需要确保序列号不会重复且能够处理乱序、丢失等问题。</p> </li><li> <p>时间戳：在应用层为每个数据包添加一个时间戳，接收端根据时间戳对数据包进行排序。这种方法不需要额外的序列号空间，但可能会受到网络延迟的影响。</p> </li><li> <p>累积确认：接收端可以向发送端发送累积确认（ACK），表示已经成功接收到之前的所有数据包。发送端可以根据累积确认来判断哪些数据包已经到达接收端，从而调整发送速率或者重传丢失的数据包。</p> </li><li> <p>可靠传输协议：在某些应用场景下，可以使用可靠的传输协议（如TCP）替代UDP来实现顺序传输。虽然这会增加一定的开销，但可以确保数据的可靠性和顺序性。</p> </li></ol> 
<p>总之，UDP协议本身无法保证数据包的顺序传输，但在应用层可以通过一些手段来实现这一目标。具体选择哪种方法取决于应用的需求和场景。</p> 
<h3><a id="9_UDP_120"></a>9. 请解释UDP如何实现多播和广播。</h3> 
<p>UDP协议支持多播和广播。</p> 
<ol><li> <p>多播：在UDP中，多播是指将数据包发送给多个接收者。实现多播的方法是使用特殊的IP地址（D类地址）作为目的地址。当一个主机向一个D类地址发送数据包时，路由器会将该数据包复制并转发给所有加入该多播组的主机。这样，一个数据包就可以被多个接收者同时接收，而不需要为每个接收者单独发送一个数据包。</p> </li><li> <p>广播：在UDP中，广播是指将数据包发送给网络中的所有主机。实现广播的方法是将数据包的目的地址设置为特殊的IP地址（B类地址）。当一个主机向一个B类地址发送数据包时，路由器会将该数据包复制并转发给网络中的所有主机。这样，一个数据包就可以被整个网络上的所有主机接收。</p> </li></ol> 
<p>需要注意的是，多播和广播都是通过路由器来实现的。当主机发送多播或广播数据包时，它只需要知道目标组的IP地址，而不需要知道具体的接收者列表。路由器会根据IP地址将数据包转发给正确的接收者。</p> 
<h3><a id="10_TCPUDP_129"></a>10. 在什么情况下，你会选择使用TCP而不是UDP？反之呢？</h3> 
<p>选择使用TCP而不是UDP的情况：</p> 
<ol><li>需要可靠的数据传输：TCP提供了可靠的数据传输机制，包括数据包的确认、重传和排序等功能，可以保证数据的完整性和顺序性。适用于对数据可靠性要求较高的场景，如文件传输、电子邮件等。</li><li>需要流量控制和拥塞控制：TCP通过滑动窗口机制进行流量控制和拥塞控制，可以避免网络拥塞和数据丢失。适用于网络状况不稳定或带宽有限的场景。</li><li>需要双向通信：TCP是面向连接的协议，建立连接后可以进行双向通信。适用于需要实时交互的应用，如聊天室、在线游戏等。</li></ol> 
<p>选择使用UDP而不是TCP的情况：</p> 
<ol><li>实时性要求较高：UDP传输速度较快，没有建立连接和断开连接的开销，适用于对实时性要求较高的应用，如音视频传输、实时游戏等。</li><li>对数据可靠性要求较低：UDP不提供可靠性保证，数据包可能会丢失或乱序，适用于对数据可靠性要求不高的场景，如实时监控、传感器数据采集等。</li><li>网络资源受限：UDP协议较简单，占用较少的网络资源，适用于网络带宽有限或资源受限的环境。</li></ol> 
<h3><a id="11_TCPIP_140"></a>11. 请解释TCP/IP模型的四个层次。</h3> 
<p>TCP/IP模型采用了四层结构，分别是链路层、网络层、传输层和应用层。</p> 
<ul><li> <p>链路层：也被称为数据链路层或网络接口层，主要负责处理与物理网络接口相关的细节，如设备驱动程序和网络接口卡等。</p> </li><li> <p>网络层：负责数据的路由和转发，包括IP协议和ICMP协议等。IP协议是用于为计算机网络中的设备分配地址，而ICMP协议则是用于发送错误报告和操作信息的。</p> </li><li> <p>传输层：负责提供端到端的数据传输服务，例如TCP协议和UDP协议等。TCP协议是一种面向连接的、可靠的数据传输协议，而UDP协议则是一种无连接的、不可靠的数据传输协议。</p> </li><li> <p>应用层：负责处理特定的应用程序细节，包括简单电子邮件传输(SMTP)、文件传输协议(FTP)、以及HTTP等。</p> </li></ul> 
<h3><a id="12_IP_151"></a>12. 请解释IP地址的作用以及分类。</h3> 
<p>IP地址，也被称为网络身份证，是用于标识和区别网络中设备的一组数字编码系统。它的主要作用包括区分数以亿计的主机而分配的专门地址，从而可以区分不同的主机。此外，它还具有定位的功能，可以根据IP地址查询来确定设备的位置。</p> 
<p>根据其功能和用途，IP地址被分为A、B、C、D和E五类。这些类别反映了网络的大小以及数据包是单播还是组播的。具体来说：</p> 
<ul><li>A类地址（1.0.0.0-126.255.255.255）用于最大型的网络，该网络的节点数可达16,777,216个。</li><li>B类地址（128.0.0.0-191.255.255.255）用于中型网络，节点数可达65,536个。</li><li>C类地址（192.0.0.0-223.255.255.255）用于256个节点以下的小型网络的单点网络通信。</li><li>D类地址并不反映网络的大小，只是用于组播，用来指定所分配的接收组播的节点组，这个节点组由组播订阅成员组成。D类地址的范围为224.0.0.0-239.255.255.255。</li><li>E类地址（240.0.0.0-255.255.255.254）用于试验。</li></ul> 
<h3><a id="13__162"></a>13. 请解释子网掩码的作用。</h3> 
<p>子网掩码的主要作用是将IP地址划分成网络地址和主机地址两部分，以区别网络标识和主机标识。换句话说，它是用来确定IP地址中哪一部分是网络号，哪一部分是机器号。</p> 
<p>以下是子网掩码的几个关键功能：</p> 
<ol><li>划分网络位和主机位：子网掩码可以帮助我们区分IP地址中的网络部分和主机部分。</li><li>划分子网：通过使用子网掩码，可以将一个大的IP网络划分为多个小的子网。</li><li>通信管理：划分子网后，同一子网内的设备可以直接通信，而不同子网的设备需要通过路由器进行通信。</li><li>节省IP地址：通过合理划分子网，我们可以更有效地使用有限的IP地址。</li><li>易于管理：子网掩码可以简化网络的管理，例如分配和跟踪网络资源。</li></ol> 
<p>总的来说，子网掩码是一个非常重要的工具，它有助于我们理解和操作复杂的网络环境。</p> 
<h3><a id="14_DNS_174"></a>14. 请解释DNS解析的过程。</h3> 
<p>DNS解析是将域名转换为对应的IP地址的过程。在域名解析过程中，首先由DNS client的主机调用解析器（Resolver），向DNS server发出请求，DNS server会尝试完成域名解析。</p> 
<p>如果解析器无法直接完成域名解析，那么会按照以下步骤进行：</p> 
<ol><li>搜索浏览器的DNS缓存，缓存中维护了一张域名与IP地址的对应表。如果在缓存中找到了对应的IP地址，则直接返回；</li><li>如果浏览器的DNS缓存没有命中，那么操作系统的DNS缓存会被搜索。如果操作系统的DNS缓存中有对应的IP地址，则直接返回；</li><li>如果操作系统的DNS缓存也没有命中，那么操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的DNS缓存，查找成功则返回结果；</li><li>如果本地域名服务器的DNS缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询。首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器；然后本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址；最后本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的IP地址。得到IP地址后，本地域名服务器将IP地址返回给操作系统，同时自己也将IP地址缓存起来。</li></ol> 
<p>这个过程涉及到两个重要的查询方式：迭代查询和递归查询。迭代查询是指，发出DNS请求后，对方如果不知道这个域名的IP地址，会告诉我有可能知道这件事的机器的IP，我自己再去问有可能知道的机器，不断重复直到问到结果。而递归查询是指，发出DNS请求后，要求对方查好后直接给出最终结果。<br> （DNS解析是将一个域名转换成与之对应的IP地址的过程。当用户在浏览器中输入一个网址时，浏览器首先会向本地的DNS服务器发送一个请求，查询该域名所对应的IP地址。如果本地DNS服务器没有该域名对应的IP地址，则会向根DNS服务器发送一个请求，依次向上查找直到找到相应的IP地址。</p> 
<p>具体来说，DNS解析的过程如下：</p> 
<ol><li> <p>浏览器向本地DNS服务器发送一个请求，查询该域名所对应的IP地址。</p> </li><li> <p>如果本地DNS服务器无法解析该域名，则会向根DNS服务器发送一个请求。</p> </li><li> <p>根DNS服务器返回顶级域（如.com、.org等）所在的权威DNS服务器的地址。</p> </li><li> <p>本地DNS服务器向权威DNS服务器发送请求。</p> </li><li> <p>权威DNS服务器返回该域名所对应的IP地址。</p> </li><li> <p>本地DNS服务器将IP地址返回给浏览器。</p> </li><li> <p>浏览器通过该IP地址与目标服务器建立连接。）</p> </li></ol> 
<h3><a id="15_ARP_202"></a>15. 请解释ARP协议的作用。</h3> 
<p>ARP协议，全称地址解析协议，是一个在局域网中根据IP地址获取物理MAC地址的重要协议。它工作在网络层与数据链路层之间，起着承上启下的桥梁作用。</p> 
<p>其主要功能如下：</p> 
<ol><li>地址转换：ARP协议可以将网络层的IP地址转换为物理层的MAC地址，使得信息能够正确地找到目标设备。</li><li>缓存更新：为了提高查询效率，主机通常会将得到的IP和MAC的映射关系保存在内存中，这个映射关系表就叫做ARP缓存表。每当有新的IP和MAC映射关系时，主机就会更新这个ARP缓存表。</li><li>动态维护：ARP缓存是动态的，即当ARP缓存中的某个条目超过一段时间未被使用时，该条目会被自动删除，以便于新的条目加入。</li></ol> 
<h3><a id="16_ICMP_210"></a>16. 请解释ICMP协议的作用。</h3> 
<p>ICMP协议，全称为互联网控制报文协议，是TCP/IP协议簇中的一个重要子协议，主要用于在主机和路由器之间传递控制消息。这些控制消息主要涉及网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p> 
<p>ICMP协议的主要功能如下：</p> 
<ol><li>检查网络通不通：我们常使用的用于检查网络连通性的Ping命令（包括Linux和Windows系统中的Ping命令），其工作原理就是基于ICMP协议。当Ping一个网址时，系统会构造一个ICMP Echo Request数据包发送给目的地并报告是否收到所希望的ICMP echo（ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。</li><li>实现链路追踪：另一个常见的应用是Traceroute命令，它也是基于ICMP协议的，可以用来确定到达目标主机所经过的路由。</li><li>错误报告：当数据包无法访问目标地址时，会自动发送一个ICMP报错消息给源头，比如常说的"Destination Unreachable"（目的不可达）和"Time Exceeded"（超时）等错误信息，告诉发送方出现了何种问题。</li><li>探测网络最大传输单元（MTU）：通过发送不同大小的数据包并观察回应，可以间接探测出网络的最大传输单元（MTU），有助于提高网络传输效率。</li></ol> 
<h3><a id="17_NAT_219"></a>17. 请解释NAT（网络地址转换）的作用及其工作原理。</h3> 
<p>NAT（Network Address Translation），网络地址转换，是一种在本地网络中使用私有地址，而在NAT（Network Address Translation），网络地址转换，是一种在本地网络中使用私有地址，而在连接互联网时转而使用全局 IP 地址的技术。它是为解决IPv4地址短缺的问题而开发的。</p> 
<p>NAT的工作原理是：在局域网中组织会为内部主机分配私有地址，当这些内部主机需要发送数据包到外部网络时，私有地址就会自动转换为公有 IP 地址；相应地，返回的流量的目的地址也会从公有 IP 地址自动转换为内部私有地址。此外，NAT还具有“地址复用”功能，即允许多个内网IP同时映射到一个外网IP上面，因此也被称为“多对一地址转换”技术。</p> 
<p>具体来说，进行NAT转换时，内部本地地址将会转换为内部全局地址，外部全局地址会成为目的地址。例如，以 10.0.0.10 的主机与 163.221.120.9 的主机进行通信为例，NAT可以将内部的私有IP地址转换为全局IP地址，同时也可以反向操作，将来自外部网络的全球IP地址转换为内部私有IP地址。</p> 
<h3><a id="18_DHCP_226"></a>18. 请解释DHCP（动态主机配置协议）的作用及其工作原理。</h3> 
<p>DHCP（动态主机配置协议）是一种基于Client/Server模式的网络管理协议，主要用于在网络中自动管理和配置IP地址。这种协议在大型的局域网络环境中得到了广泛的应用，它能够动态地给局域网内的主机分配IP地址、子网掩码、默认网关地址以及域名服务器（DNS）地址等网络配置信息。</p> 
<p>DHCP的工作原理如下：当DHCP客户端启动时，它会向网络发送一个DHCP DISCOVER数据包，该数据包包含了客户端的MAC地址和所需的IP地址信息。接着，DHCP服务器会接收到这个数据包，然后从它的地址池中为该设备提供一个可用的IP地址，同时还会提供其他的网络配置参数，如子网掩码、默认网关和DNS服务器的地址等。这些信息会被包含在DHCP OFFER数据包中返回给客户端。当客户端接收到DHCP OFFER后，会向DHCP服务器发送一个DHCP REQUEST数据包，确认接受所分配的IP地址和其他网络配置信息。最后，DHCP服务器会向客户端发送一个DHCP ACK数据包，将租约（即分配给客户端的IP地址和其他网络配置信息的有效期）正式确认下来。</p> 
<h3><a id="19_HTTPHTTPS_231"></a>19. 请解释HTTP和HTTPS的区别。</h3> 
<p>HTTP和HTTPS是两种网络传输协议，其中，HTTP是一种基于TCP/IP通信协议来传递数据的协议，主要用于发布和接收HTML页面，而HTTPS则是一种在HTTP基础上加入了SSL/TLS加密处理的协议，主要用于发布和接收数据和文件。</p> 
<p>在网络模型中，HTTP工作于应用层，使用80端口，而HTTPS工作在传输层，使用443端口。这意味着，HTTPS与HTTP使用的是完全不同的连接方式。</p> 
<p>从安全性的角度来看，HTTPS由于采用了SSL/TLS加密技术，所以可以提供对网站服务器的身份认证和数据保护，从而大大增加了数据传输的安全性。而HTTP协议由于没有采用任何加密措施，因此在数据传输过程中存在安全风险。</p> 
<p>总的来说，两者的主要区别在于安全性、连接方式以及使用的端口号。其中，HTTPS由于提供了加密保护和身份认证，所以在安全性方面具有明显优势；而在速度和资源消耗方面，由于HTTPS需要进行加密解密操作，可能会比HTTP稍微慢一些。</p> 
<h3><a id="20_TLSSSL_240"></a>20. 请解释TLS/SSL协议的作用及其工作原理。</h3> 
<p>TLS/SSL是一种密码通信框架，被广泛应用于保护网络通信的安全。这种协议综合运用了对称密码、消息认证码、公钥密码、数字签名以及伪随机数生成器等密码学元素，堪称密码学的大成者。</p> 
<p>在具体的工作原理上，为了确保网络通信的安全性，需要对网络上传递的数据进行加密处理。目前主流的加密方法就是使用安全套接层（SSL）和传输层安全（TLS）协议。更具体地说，这个过程主要包括三个步骤：握手协议，密钥交换和数据传输。</p> 
<p>首先，客户端向服务器发送一个连接请求，然后服务器回应一个确认信息。这就是握手协议的过程，同时它也完成了身份认证和密钥协商的工作。</p> 
<p>接着，客户端和服务器通过非对称加密算法来生成共享密钥，然后利用这个共享密钥进行数据加密和解密。这个阶段的主要任务就是保证信息传输的机密性。</p> 
<p>最后，客户端和服务器利用已协商好的密钥对数据进行加密并传输，接收方接收到数据后用同样的密钥进行解密，以此来实现数据的保密传输。</p> 
<p>另外值得一提的是，TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。例如，TLS在SSL v3.0的基础上提供了更安全的MAC算法，更严密的警报机制，以及对“灰色区域”规范的更明确的定义。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cbe8a4ca92692fed5563c0e0aa18803b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二、C#基础语法（ 异常处理）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7aa72503f0091c66f7fe4674d107de8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">移动端手签-图片base64旋转功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>