<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>H.265/HEVC编码结构 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="H.265/HEVC编码结构" />
<meta property="og:description" content="H.265/HEVC编码结构 为了增强各种应用下操作的灵活性以及数据损失的鲁棒性，H.265/HEVC在编解码的设计上添加了多种新的语法结构。相较于以往的视频编码标准（如H.264/AVC），这种新的语法架构使得H.265/HEVC在压缩效率和网络适应性两个方面都有显著提升。此外，根据不同业务需求、终端运算能力等，H.265/HEVC还相应地规定出不同的档次、层、级，以适应各种应用场景。本章首先对H.265/HEVC的编码架构和其所涉及的相关语法参数集进行详细介绍，然后给出档次、层、级的基本概念以及在H.265/HEVC中对它们的具体规范 [1] 。
3.1　编码结构概述
关于编码结构，可以从编码时的分层处理架构和编码完后码流的语法架构两方面进行描述。视频序列由若干时间连续的图像构成，在对其进行压缩时，先将该视频序列分割为若干个小的图像组（Group Of Pictures，GOP）。在视频编码中，存在两种GOP类型：封闭式GOP（Closed GOP）和开放式GOP（Open GOP），如图3.1所示。在封闭式GOP类型中，每一个GOP以IDR（Instantaneous Decoding Refresh）图像开始，各个GOP之间独立编解码。在开放式GOP类型中，第一个GOP中的第一个帧内编码图像为IDR图像，后续GOP中的第一个帧内编码图像为non-IDR图像，也就是说，后面GOP中的帧间编码图像可以越过non-IDR图像，使用前一个GOP中的已编码图像做参考图像。每个GOP又被划分为多个片（Slice），片与片之间进行独立编解码。其主要目的之一是在数据丢失情况下进行重新同步。每个片由一个或多个片段（Slice Segment，SS）组成。此外，为了更灵活、更有效地表示视频内容，H.265/HEVC还引入了树形结构单元（Coding Tree Unit，CTU）这一概念，其类似于传统的宏块。每个CTU包括一个亮度树形编码块（Coding Tree Block，CTB）和两个色差树形编码块。一个SS在编码时，先被分割为相同大小的CTU，每一个CTU按照四叉树分割方式被划分为不同类型的编码单元（Coding Unit，CU）。Slice到CU的之间的编码结构如图3.2所示。以上即为编码时的分层处理架构。一般来说，为了支持视频编码标准的通用性，ITU—T和ISO/IEC只规定码流的语法元素，以保证编码器的设计更为灵活。因此本章重点介绍H.265/HEVC编码后码流的语法架构。
图3.1　两种不同的GOP类型
图3.2　Slice到CU之间的编码架构
在码流结构方面，H.265/HEVC压缩数据采用了类似于H.264/AVC的分层结构，将属于GOP层、Slice层中共用的大部分语法元素游离出来，组成序列参数集（Sequence Parameter Set，SPS）和图像参数集（Picture Parameter Set，PPS）。SPS包含了一个CVS（Coded Video Sequence）中所有图像共用的信息。其中CVS被定义为一个GOP编码后所生成的压缩数据。SPS的内容大致包括解码相关信息，如档次级别、分辨率、某档次中编码工具开关标识和涉及的参数、时域可分级信息等。PPS包含一幅图像所用的公共参数，即一幅图像中所有SS引用同一个PPS。其大致内容包括初始图像控制信息，如初始量化参数（Quantization Parameter，QP）、分块信息等。此外，为了兼容标准在其他应用上的扩展，例如可分级视频编码器、多视点视频编码器，H.265/HEVC的语法架构中增加了视频参数集（Video Parameter Set，VPS）。其内容大致包括多个子层共享的语法元素，其他不属于SPS的特定信息等。对于一个SS，通过引用它所使用的PPS，该PPS又引用其对应的SPS，该SPS又引用它对应的VPS，最终得到SS的公用信息。H.265/HEVC压缩码流的结构如图3.3所示。
图3.3　H.265/HEVC压缩码流结构
参数集是一个独立的数据单位，它包含视频的不同层级编码单元的共享信息，只有当参数集直接或间接被SS引用时才有效。一个参数集并不对应某个特定的图像或CVS，同一个VPS或SPS可以被多个CVS引用，同一个PPS可以被多个图像引用。在H.265/HEVC中，NAL单元根据是否装载视频编码数据被分为VCLU（Video Coding Layer NAL Unit）和non-VCLU。非编码数据的参数集作为non-VCLU进行传输，这为传递关键数据提供了高鲁棒机制。参数集的独立使得其可以提前发送，也可以在需要增加新参数集的时候再发送，可以被多次重发或者采用特殊技术加以保护，甚至采用带外（Out-of-band）发送的方式。片段SS是视频编码数据的基本单位，一个SS的压缩数据生成一个VCLU进行传输。最终，一个视频序列的编码码流由一系列SS所生成的多个VCLU单元和夹杂其间的一些分割标示数据和参数集数据组成。分割标示数据用于区分一个SS属于哪幅图像、哪个CVS。
3.2　视频参数集
3.2.1　视频层描述
在H.264/AVC的码流结构中，没有类似VPS这样的参数集去描述时域各层之间的依赖关系。它的扩展部分可伸缩视频编码中，SEI信息提供了相关各层信息，以用于不同业务和不同终端的访问。但在一些应用场景，例如广播和多播，由于SEI中的部分信息会重复出现在SPS中，这样造成参数重传而引起延迟等问题。因此在H.265/HEVC中引入VPS，以克服H.264/AVC中存在的不足，同时为设计简洁，可扩展多层视频编码提供方便。VPS主要用于传输视频分级信息，有利于兼容标准在可分级视频编码或多视点视频编码的扩展。
一个给定的视频序列，无论它每一层的SPS是否相同，都参考相同的VPS。VPS包含的信息有：
① 多个子层和操作点共享的语法元素；
② 会话所需的有关操作点的关键信息，如档次、级别；
③ 其他不属于SPS的操作点特性信息，例如与多层或子层相关的虚拟参考解码器（Hypothetical Reference Decoder，HRD）参数。对每个操作点的关键信息的编码，不要求可变长编码，这样有利于减轻大多数网络组成单元的负担。H.265/HEVC的扩展版本将会在当前VPS中添加更多的语法元素，以使会话更加灵活高效并使编码码率具有更高的自适应性。
3.2.2　视频层参数集
表3.1给出了VPS中包含的各个语法元素以及它们的描述子。描述子即语法元素的熵解码算法，描述子符号表示如下。
ae（v）：基于上下文自适应的二元算术编码。
b（8）：读进连续的8 bit。
f（n）：读进连续的n bit。
se（v）：有符号指数Golomb熵编码。
u（n）：读进连续的n bit，且它们解码后的值为无符号整数。
ue（n）：无符号指数Golomb熵编码。
上面描述子中括号内的参数为n时，表明该语法元素是定长编码；参数为v时表示语法元素采用变长编码。
表3.1　VPS内的语法元素" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/563670b8117b4baaa6f469597e3c431f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-27T18:01:24+08:00" />
<meta property="article:modified_time" content="2023-02-27T18:01:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">H.265/HEVC编码结构</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a href="https://www.cnblogs.com/sddai/p/14366110.html" rel="nofollow" id="cb_post_title_url" title="H.265/HEVC编码结构">H.265/HEVC编码结构</a></h2> 
<p>为了增强各种应用下操作的灵活性以及数据损失的鲁棒性，H.265/HEVC在编解码的设计上添加了多种新的语法结构。相较于以往的视频编码标准（如H.264/AVC），这种新的语法架构使得H.265/HEVC在压缩效率和网络适应性两个方面都有显著提升。此外，根据不同业务需求、终端运算能力等，H.265/HEVC还相应地规定出不同的档次、层、级，以适应各种应用场景。本章首先对H.265/HEVC的编码架构和其所涉及的相关语法参数集进行详细介绍，然后给出档次、层、级的基本概念以及在H.265/HEVC中对它们的具体规范 <a href="http://reader.epubee.com/books/mobile/90/9046b984943e32a544cd1d11b1244ba4/text00007.html" rel="nofollow" title="[1]">[1]</a> 。</p> 
<p><strong>3.1　编码结构概述</strong></p> 
<p>关于编码结构，可以从编码时的分层处理架构和编码完后码流的语法架构两方面进行描述。视频序列由若干时间连续的图像构成，在对其进行压缩时，先将该视频序列分割为若干个小的图像组（Group Of Pictures，GOP）。在视频编码中，存在两种GOP类型：封闭式GOP（Closed GOP）和开放式GOP（Open GOP），如图3.1所示。在封闭式GOP类型中，每一个GOP以IDR（Instantaneous Decoding Refresh）图像开始，各个GOP之间独立编解码。在开放式GOP类型中，第一个GOP中的第一个帧内编码图像为IDR图像，后续GOP中的第一个帧内编码图像为non-IDR图像，也就是说，后面GOP中的帧间编码图像可以越过non-IDR图像，使用前一个GOP中的已编码图像做参考图像。每个GOP又被划分为多个片（Slice），片与片之间进行独立编解码。其主要目的之一是在数据丢失情况下进行重新同步。每个片由一个或多个片段（Slice Segment，SS）组成。此外，为了更灵活、更有效地表示视频内容，H.265/HEVC还引入了树形结构单元（Coding Tree Unit，CTU）这一概念，其类似于传统的宏块。每个CTU包括一个亮度树形编码块（Coding Tree Block，CTB）和两个色差树形编码块。一个SS在编码时，先被分割为相同大小的CTU，每一个CTU按照四叉树分割方式被划分为不同类型的编码单元（Coding Unit，CU）。Slice到CU的之间的编码结构如图3.2所示。以上即为编码时的分层处理架构。一般来说，为了支持视频编码标准的通用性，ITU—T和ISO/IEC只规定码流的语法元素，以保证编码器的设计更为灵活。因此本章重点介绍H.265/HEVC编码后码流的语法架构。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5c/af/tUNVJ7k5_o.jpg"></p> 
<p>图3.1　两种不同的GOP类型</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7c/ec/yw8tubxW_o.jpg"></p> 
<p>图3.2　Slice到CU之间的编码架构</p> 
<p>在码流结构方面，H.265/HEVC压缩数据采用了类似于H.264/AVC的分层结构，将属于GOP层、Slice层中共用的大部分语法元素游离出来，组成序列参数集（Sequence Parameter Set，SPS）和图像参数集（Picture Parameter Set，PPS）。SPS包含了一个CVS（Coded Video Sequence）中所有图像共用的信息。其中CVS被定义为一个GOP编码后所生成的压缩数据。SPS的内容大致包括解码相关信息，如档次级别、分辨率、某档次中编码工具开关标识和涉及的参数、时域可分级信息等。PPS包含一幅图像所用的公共参数，即一幅图像中所有SS引用同一个PPS。其大致内容包括初始图像控制信息，如初始量化参数（Quantization Parameter，QP）、分块信息等。此外，为了兼容标准在其他应用上的扩展，例如可分级视频编码器、多视点视频编码器，H.265/HEVC的语法架构中增加了视频参数集（Video Parameter Set，VPS）。其内容大致包括多个子层共享的语法元素，其他不属于SPS的特定信息等。对于一个SS，通过引用它所使用的PPS，该PPS又引用其对应的SPS，该SPS又引用它对应的VPS，最终得到SS的公用信息。H.265/HEVC压缩码流的结构如图3.3所示。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3b/86/wHNR1Mbl_o.jpg"></p> 
<p>图3.3　H.265/HEVC压缩码流结构</p> 
<p>参数集是一个独立的数据单位，它包含视频的不同层级编码单元的共享信息，只有当参数集直接或间接被SS引用时才有效。一个参数集并不对应某个特定的图像或CVS，同一个VPS或SPS可以被多个CVS引用，同一个PPS可以被多个图像引用。在H.265/HEVC中，NAL单元根据是否装载视频编码数据被分为VCLU（Video Coding Layer NAL Unit）和non-VCLU。非编码数据的参数集作为non-VCLU进行传输，这为传递关键数据提供了高鲁棒机制。参数集的独立使得其可以提前发送，也可以在需要增加新参数集的时候再发送，可以被多次重发或者采用特殊技术加以保护，甚至采用带外（Out-of-band）发送的方式。片段SS是视频编码数据的基本单位，一个SS的压缩数据生成一个VCLU进行传输。最终，一个视频序列的编码码流由一系列SS所生成的多个VCLU单元和夹杂其间的一些分割标示数据和参数集数据组成。分割标示数据用于区分一个SS属于哪幅图像、哪个CVS。</p> 
<p><strong>3.2　视频参数集</strong></p> 
<p><strong>3.2.1　视频层描述</strong></p> 
<p>在H.264/AVC的码流结构中，没有类似VPS这样的参数集去描述时域各层之间的依赖关系。它的扩展部分可伸缩视频编码中，SEI信息提供了相关各层信息，以用于不同业务和不同终端的访问。但在一些应用场景，例如广播和多播，由于SEI中的部分信息会重复出现在SPS中，这样造成参数重传而引起延迟等问题。因此在H.265/HEVC中引入VPS，以克服H.264/AVC中存在的不足，同时为设计简洁，可扩展多层视频编码提供方便。VPS主要用于传输视频分级信息，有利于兼容标准在可分级视频编码或多视点视频编码的扩展。</p> 
<p>一个给定的视频序列，无论它每一层的SPS是否相同，都参考相同的VPS。VPS包含的信息有：</p> 
<p>① 多个子层和操作点共享的语法元素；</p> 
<p>② 会话所需的有关操作点的关键信息，如档次、级别；</p> 
<p>③ 其他不属于SPS的操作点特性信息，例如与多层或子层相关的虚拟参考解码器（Hypothetical Reference Decoder，HRD）参数。对每个操作点的关键信息的编码，不要求可变长编码，这样有利于减轻大多数网络组成单元的负担。H.265/HEVC的扩展版本将会在当前VPS中添加更多的语法元素，以使会话更加灵活高效并使编码码率具有更高的自适应性。</p> 
<p><strong>3.2.2　视频层参数集</strong></p> 
<p>表3.1给出了VPS中包含的各个语法元素以及它们的描述子。描述子即语法元素的熵解码算法，描述子符号表示如下。</p> 
<p>ae（v）：基于上下文自适应的二元算术编码。</p> 
<p>b（8）：读进连续的8 bit。</p> 
<p>f（n）：读进连续的n bit。</p> 
<p>se（v）：有符号指数Golomb熵编码。</p> 
<p>u（n）：读进连续的n bit，且它们解码后的值为无符号整数。</p> 
<p>ue（n）：无符号指数Golomb熵编码。</p> 
<p>上面描述子中括号内的参数为n时，表明该语法元素是定长编码；参数为v时表示语法元素采用变长编码。</p> 
<p>表3.1　VPS内的语法元素</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fb/cd/Efqu2Afw_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/78/22/hV8U74u9_o.jpg"></p> 
<p>vps_video_parameter_set_id： 当前VPS的标识号，以供其他句法元素引用。</p> 
<p>vps_reserved_three_2bits： 保留位，其值为3。</p> 
<p>vps_max_layers_minus1： 当前保留，其值为0，用于以后的3D视频编码或可分级视频编码的使用。</p> 
<p>vps_max_sub_layers_minus1： 表示比特流中可支持时域子层的最大数目减1，取值0~6，即最大可支持7个子层。</p> 
<p>vps_temporal_id_nesting_flag： 当vps_max_sub_layers_minus1为0时，这个参数值为1；当vps_max_sub_layers_minus1大于0时，这个参数指定是否对帧间预测进行额外限定。该参数用于指示时域子层升档，即从低子层切入高子层。</p> 
<p>vps_reserved_0xffff_16bits： 两字节的保留位，其值等于0xFFFF。</p> 
<p>vps_sub_layer_ordering_info_present_flag： 其值为1时表示vps_max_dec_pic_buffering_minus1[i]、vps_max_num_reorder_pics[i]、vps_max_latency_increase_plus1[i]存在并用于第vps_max_sub_layers_minus1 + 1子层；其值为0时表示这三个语法元素可以用于所有子层。</p> 
<p>vps_max_dec_pic_buffering_minus1 [i]：规定了HighestTid等于i时，CVS的图像存储单元中解码图像所需要的最大缓存。</p> 
<p>vps_max_num_reorder_pics [i]：规定了HighestTid等于i时，在CVS中解码顺序在某一幅图像之后，而显示顺序在该幅图像之前的图像的最大数量。</p> 
<p>vps_max_latency_increase_plus1 [i]：当HighestTid等于i时，该语法元素用于计算VpsMaxLatencyPictures[i]的值。</p> 
<p>vps_max_layer_id： 指定CVS中所有的NAL单元的nuh_layer_id的最大值。</p> 
<p>vps_num_layer_sets_minus1： 指定VPS中图层集的数量。在该版本中，该语法元素值被要求等于0。但解码器应该允许其可取0~1023之间的其他值。</p> 
<p>layer_id_included_flag [i][j]：该语法元素取值为1时，表示图层标识列表layerSetLayerIdList[i]中包含nuh_layer_id等于j的情况；其值为0时，则表示图层标识列表layerSetLayerIdList[i]中不包含nuh_layer_id等于j的情况。</p> 
<p>vps_timing_info_present_flag： 该语法元素取值为1时，表示在VPS中语法元素vps_num_units_in_tick、vps_time_scale、vps_poc_proportional_to_timing_flag、vps_num_hrd_parameters存在；其值为0时则表示在VPS中不存在这四个语法元素。</p> 
<p>vps_num_units_in_tick： 该语法元素规定当时钟频率为vps_time_scale Hz时，所花的时间单位的个数。以秒为单位时，一个时钟周期等于vps_num_units_in_tick除以vps_time_scale。例如，当一个视频的帧率为25Hz时，vps_time_scale等于27 000 000Hz，vps_num_units_in_tick就等于1 080 000，因此一个时钟周期就是0.04s。</p> 
<p>vps_time_scale： 一秒内时间单位的个数。</p> 
<p>vps_poc_proportional_to_timing_flag： 该语法元素值为1，表示CVS中的每一幅图像（不包括第一幅图像）的POC与它的显示时间和第一幅图像的显示时间的比值成正比；否则，不成比例。</p> 
<p>vps_num_ticks_poc_diff_one_minus1： 表示POC之间差值为1时，时钟周期的数目。</p> 
<p>vps_num_hrd_parameters： 指定VPS RBSP中语法结构体hrd_parameters()的数目。</p> 
<p>hrd_layer_set_idx [i]：规定第i个语法结构体hrd_parameters()使用的图层集的索引。</p> 
<p>cprms_present_flag [i]：表示第i个hrd_parameters()中是否存在所有子层公用的HRD参数。</p> 
<p>vps_extension_flag： 该语法元素取值为0，表示在VPS PBSP中没有语法元素vps_extension_data_flag。在该版本中，vps_extension_flag取值等于0；其值等于1用于保留为将来使用。</p> 
<p>vps_extension_data_flag： 可以是任意值。在该版本中，其取值不影响解码器，解码器可以忽略该语法元素。</p> 
<p><strong>3.3　序列参数集</strong></p> 
<p>在H.265/HEVC中，一个CVS由一个随机接入点开始，第一幅图像可以是IDR图像，也可以是non-IDR图像。non-IDR图像可以是BLA（Broken Link Access）图像或CRA（Clean Random Access）图像。对于一段视频码流，其可能包含一个或者多个编码视频序列CVS。序列参数集SPS的内容就是包含一个CVS中所有编码图像的共享编码参数，SPS通过被PPS引用而作用于编码图像，一个CVS中所有被使用的PPS必须引用同一个SPS。实际上，SPS为所有的SS提供了公共参数，如图像的格式、档次、级等。当一个SPS被引用时，该SPS处于激活状态，直到整个CVS结束。</p> 
<p>表3.2给出了SPS中所含的语法元素，其内容大致分为以下几个部分。</p> 
<p>① 图像格式的信息。包括采样格式、图像分辨率、量化深度、解码图像是否需要裁剪输出以及相关的裁剪参数。</p> 
<p>② 编码参数信息。包括编码块、变换块的最小尺寸和最大尺寸，帧内、帧间预测编码时变换块的最大划分深度，对4：4：4采样格式的三个通道分量是否单独编码，是否需要帧内强滤波，帧间预测过程中的某些限制条件[如非对称模式（AMP）的使用、时域MV预测的使用]是否使用量化矩阵，是否需要样点自适应补偿（SAO），是否采用PCM模式及在该模式下的相关编码参数。</p> 
<p>③ 与参考图像相关的信息。包括短期参考图像的设置，长期参考图像的使用和数目，长期参考图像的POC和其能否作为当前图像的参考图像。</p> 
<p>④ 档次、层和级相关参数。具体内容见3.8节。</p> 
<p>⑤ 时域分级信息。包括时域子层的最大数目，控制传输POC进位的参数，时域子层顺序标识开关，与子层相关的参数（如解码图像缓冲区的最大需求）。</p> 
<p>⑥ 可视化可用性信息（Video Usability Information，VUI），用于表征视频格式等额外信息。</p> 
<p>⑦ 其他信息。包括当前SPS引用的VPS编号、SPS标识号和SPS扩展信息。</p> 
<p>表3.2　序列参数集SPS</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8b/be/YoE7oEky_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/87/23/KFjLctRl_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/94/cf/1bmAiXmc_o.jpg"></p> 
<p>sps_video_parameter_set_id： 指定当前激活的VPS的ID号。</p> 
<p>sps_max_sub_layers_minus1： 用于指定时域子层的最大数目。</p> 
<p>sps_temporal_id_nesting_flag： 当sps_max_sub_layers_minus1大于0时，其规定了是否额外地限制CVS的帧间预测，当vps_temporal_id_nesting_flag取值为1时，该语法元素取值为1。当sps_max_sub_layers_minus1为0时，该语法元素取值为1。</p> 
<p>sps_seq_parameter_set_id： 表示SPS的标识号，取值范围为[0，15]。</p> 
<p>chroma_format_idc： 表示色度采样格式，取值范围为[0，3]。例如取值为1时，表示采用4：2：0格式。</p> 
<p>separate_colour_plane_flag： 该语法元素取值为1，则表示对4：4：4格式的三种通道分量采用单独编码；该语法元素取值为0则表示彩色分量不进行独立编码。当该语法元素没有给出时，可推测出其值为0。</p> 
<p>pic_width_in_luma_samples： 表明解码图像中亮度样点的宽度。</p> 
<p>pic_height_in_luma_samples： 表明解码图像中亮度样点的高度。</p> 
<p>conformance_window_flag： 表示解码器是否要对解码后的图像裁剪输出。</p> 
<p>conf_win_left_offset、conf_win_right_offset、conf_win_top_offset和conf_win_bottom_offset： 当conformance_window_flag值为1时，解码图片需要裁减输出，这四个参数用于指定左、右、上、下的裁剪宽度。</p> 
<p>bit_depth_luma_minus8： 表示亮度像素的比特深度。</p> 
<p>bit_depth_chroma_minus8： 表示色度像素的比特深度。</p> 
<p>log2_max_pic_order_cnt_lsb_minus4： 该语法元素的取值范围为[0，12]，其用于计算变量MaxPicOrderCntLsb的值。MaxPicOrderCntLsb用于控制进位，比特流中只传一个低位的POC，不用传高位POC。利用前参考图像的高、低位POC和MaxPicOrderCntLsb得到当前图像的高位POC，再结合当前图像的低位POC，可以得到当前图像实际的POC。</p> 
<p>sps_sub_layer_ordering_info_present_flag： 时域子层顺序标识开关。该值等于1，表示sps_max_dec_pic_buffering_minus1[i]、sps_max_num_reorder_pics[i]、sps_max_latency_increase_plus1[i]适用于sps_max_sub_layers_minus1 + 1子层；该值等于0，则表示这些参数适用于所有子层。</p> 
<p>sps_max_dec_pic_buffering_minus1 [i]：当HighestTid取值为i时，该语法元素规定了解码图像缓冲区的最大需求。</p> 
<p>sps_max_num_reorder_pics [i]：当HighestTid取值为i时，表示解码顺序在某一图像之后，而显示顺序在该图像之前的图像的最大数量。其取值范围为[0，sps_max_dec_pic_buffering_minus1[i]]。</p> 
<p>sps_max_latency_increase_plus1 [i]：该值不为0时，其用于计算SpsMaxLatencyPictures[i]的值。</p> 
<p>log2_min_luma_coding_block_size_minus3： 指定亮度编码块的最小尺寸。</p> 
<p>log2_diff_max_min_luma_coding_block_size： 指定亮度编码块最大尺寸和最小尺寸的差值。</p> 
<p>log2_min_transform_block_size_minus2： 指定亮度变换块的最小尺寸。</p> 
<p>log2_diff_max_min_transform_block_size： 指定亮度变换块最大尺寸和最小尺寸的差值。</p> 
<p>max_transform_hierarchy_depth_inter： 表示帧间预测时变换块的最大划分深度。取值范围为[0，CtbLog2SizeY − Log2MinTrafoSize] 。</p> 
<p>max_transform_hierarchy_depth_intra： 表示帧内预测时变换块的最大划分深度。取值范围为[0，CtbLog2SizeY − Log2MinTrafoSize] 。</p> 
<p>scaling_list_enabled_flag： 表示对变换系数在量化过程中是否使用量化矩阵。</p> 
<p>sps_scaling_list_data_present_flag： 表示是否存在量化矩阵数据。</p> 
<p>amp_enabled_flag： 表示是否使用非对称划分模式，非对称模式即PartMode等于PART_2NxnU，PART_2NxnD，PART_nLx2N或PART_nRx2N。</p> 
<p>sample_adaptive_offset_enabled_flag： 表示去方块滤波过程后重构图像是否使用样点自适应补偿（SAO）。</p> 
<p>pcm_enabled_flag： 表示是否使用PCM模式。</p> 
<p>pcm_sample_bit_depth_luma_minus1： 表示亮度分量中PCM样点的比特深度。</p> 
<p>pcm_sample_bit_depth_chroma_minus1： 表示色度分量中PCM样点的比特深度。</p> 
<p>log2_min_pcm_luma_coding_block_size_minus3： 表示在PCM模式下，编码块的最小尺寸。</p> 
<p>log2_diff_max_min_pcm_luma_coding_block_size： 表示在PCM模式下，编码块尺寸最大值和最小值的差值。</p> 
<p>pcm_loop_filter_disabled_flag： 表示在PCM模式下，编码单元的重建像素是否使用环路滤波。</p> 
<p>num_short_term_ref_pic_set： 指明在SPS中short_term _ref_pic_set()的数目。其取值范围为[0，64] 。</p> 
<p>long_term_ref_pics_present_flag： 表示帧间预测时是否使用长期参考图像。</p> 
<p>num_long_term_ref_pics_sps： 指定SPS中长期参考图像的数目，其取值范围是[0，32]。</p> 
<p>lt_ref_pic_poc_lsb_sps [i]：表示POC与SPS中第i个长期参考图像的MaxPicOrderCntLsb取模之后的值。</p> 
<p>used_by_curr_pic_lt_sps_flag [i]：表示第i个长期参考图像能否作为当前图像的参考图像。</p> 
<p>sps_temporal_mvp_enabled_flag： 指定非IDR图像的片头中是否存在句法元素slice_temporal_mvp_enabled_flag（表示帧间预测过程中能否使用时域MV预测）。</p> 
<p>strong_intra_smoothing_enabled_flag： 表示滤波过程是否使用双向线性插值。</p> 
<p>vui_parameters_present_flag： 表示是否含有语法结构体vui_parameters()。</p> 
<p>sps_extension_flag： 其值为0，则表示语法元素sps_extension_data_flag不存在；其值为1，则语法元素sps_extension_data_flag被保留以供将来使用。</p> 
<p>sps_extension_data_flag： 可以为任意值，在现有版本中解码器忽略该语法元素。</p> 
<p><strong>3.4　图像参数集</strong></p> 
<p>在编码视频流中，一个CVS包含多幅图像，每幅图像可能包括一个或多个SS，每个SS头提供了其所引用的PPS标识号，以此得到相应PPS中的公用信息。对于同一幅图像，其内所有的SS都用同一个PPS。需要注意的是，PPS中存在一些与SPS中相同的参数，PPS中的这些参数值将会覆盖SPS中它们的取值，也就是说，SS使用PPS中的这些参数进行解码。在解码开始时，所有的PPS全部是非活动状态，而且在解码的任意时刻最多只能有一个PPS处于激活状态。当某一幅图像在其解码过程中引用了某个PPS时，这个PPS便处于激活状态，直到该图像解码结束。</p> 
<p>表3.3给出了PPS中所涉及的具体的语法元素，图像参数集的内容大致分为以下几个部分。</p> 
<p>① 编码工具的可用性标志。指明片头中一些工具是否可用。这些编码工具主要包括符号位隐藏、帧内预测受限、去方块滤波、P/B图像的加权预测、环路滤波跨越片边界或者Tile边界、Transform skip模式和Transquant bypass模式。</p> 
<p>② 量化过程相关句法元素。包括每个Slice中QP初始值的设定以及计算每个CU的QP时所需的参数。此外，还有亮度量化参数的偏移量和由它导出的色度量化参数的偏移量等。有关量化过程中QP的具体计算及相关参数详见6.2节。</p> 
<p>③ Tile相关句法元素。包括Tile划分模式的可用性标志，以及在使用Tile划分模式时的一些参数，例如Tile的划分形式，总行数、总列数及第几行、第几列的标识等。</p> 
<p>④ 去方块滤波相关句法元素。包括去方块滤波的可用性标志以及使用去方块滤波时的一些控制信息和参数，如去方块滤波的默认补偿值β和tC。</p> 
<p>⑤ 片头中的控制信息。包括当前片是否为依赖片、片头中是否有额外的Slice头比特、图像解码顺序与输出顺序的先后关系以及CABAC中确定上下文变量初始化表格时使用的方法等。</p> 
<p>⑥ 其他编码一幅图像时可以共用的信息。包括ID标识符、参考图像的数目和并行产生merge候选列表的能力等。其中ID标识符用于标识当前活动的参数集，主要是当前活动的PPS的自身ID和其引用的SPS的ID。此外，PPS中还包括变换矩阵信息是否存在的标志位，这一变换矩阵信息若存在，便会对SPS中的该信息进行覆盖。</p> 
<p>表3.3　图像参数集PPS</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5c/4d/VNN9CL5y_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0f/f3/UvWEptN3_o.jpg"></p> 
<p>pps_pic_parameter_set_id： 表示当前激活的PPS的ID号，取值范围为[0，63]。</p> 
<p>pps_seq_parameter_set_id： 表示当前激活的SPS的ID号，取值范围为[0，15]。</p> 
<p>dependent_slice_segments_enabled_flag： 表示Slice头中是否存在句法元素dependent_slice_segment_flag，用于判断当前片段是否含有依赖片。</p> 
<p>output_flag_present_flag： 表示Slice头中是否存在句法元素pic_output_flag，pic_output_flag影响解码图像的输出和移除过程。</p> 
<p>num_extra_slice_header_bits： 其值为0，表示Slice头RBSP中没有额外Slice头比特。其他值保留供ITU-T及ISO/IEC将来使用。</p> 
<p>sign_data_hiding_enabled_flag： 表示是否不允许使用符号位隐藏技术。</p> 
<p>cabac_init_present_flag： 表示片头中是否存在句法元素cabac_init_flag，cabac_init_flag用于判断在CABAC中使用何种方法来确定上下文变量的初始值。</p> 
<p>num_ref_idx_l0_default_active_minus1： 该语法元素取值范围为[0，14]，表示在num_ref_idx_active_override_flag等于0时，P Slice和B Slice中num_ref_idx_l0_active_minus1的默认值，即引用的list0中参考图像数目的最大默认值。</p> 
<p>num_ref_idx_l1_default_active_minus1： 该语法元素取值范围为[0，14]，表示在num_ref_idx_active_override_flag为0时，num_ref_idx_l1_active_minus1的默认值，即引用list1中参考图像数目的最大默认值。</p> 
<p>init_qp_minus26： 规定了每个Slice中亮度分量的量化参数初始值。</p> 
<p>constrained_intra_pred_flag： 表示帧内预测是否受限，即是否允许使用采用帧间预测模式的邻近块信息进行帧内预测。</p> 
<p>transform_skip_enabled_flag： 指定在残差编码句法中是否存在transform_skip_flag，transform_skip_flag用于表示残差编码是否为tansform skip模式。</p> 
<p>cu_qp_delta_enabled_flag： 其值取1，表明当前PPS中存在diff_cu_qp_delta_depth，并且在变换单元句法中可能存在cu_qp_delta_abs；其值等于0，则表示两个句法元素都不存在。</p> 
<p>diff_cu_qp_delta_depth： 表示在传送cu_qp_delta_abs和cu_qp_delta_sign_flag的编码单元中，亮度CTB尺寸与最小亮度CB尺寸的差值，用于每个CU中QP值的计算。其详细计算过程见6.2节。该语法元素取值范围为[0，log2_diff_max_min_luma_coding_block_size]。</p> 
<p>pps_cb_qp_offset和pps_cr_qp_offset： 表示色度分量Cb和Cr分别采用的量化参数（Qp′Cb 和Qp′Cr ）相对于亮度分量的量化参数（Qp′Y ）的偏移量，其取值范围都是[-12，+12]。</p> 
<p>pps_slice_chroma_qp_offsets_present_flag： 指明Slice头中是否存在slice_cb_qp_offset和slice_cr_qp_offset，这两个值用来计算量化参数Qp′Cb 和Qp′Cr 。</p> 
<p>weighted_pred_flag： 表示P Slice是否使用加权预测。</p> 
<p>weighted_bipred_flag： 表示B Slice是否使用双向加权预测。</p> 
<p>transquant_bypass_enabled_flag： 表示是否存在cu_transquant_bypass_flag。cu_transquant_bypass_flag用于判断是否为transquant_bypass模式，即是否跳过伸缩变换和环路滤波过程。</p> 
<p>tiles_enabled_flag： 表示是否使用Tile模式。</p> 
<p>entropy_coding_sync_enabled_flag： 表示是否使用熵编码同步机制。</p> 
<p>num_tile_columns_minus1： 表示划分该图像的Tile的总列数。</p> 
<p>num_tile_rows_minus1： 表示划分该图像的Tile的总行数。</p> 
<p>uniform_spacing_flag： 表示图像中Tile的列边界和行边界的分布是否一致。</p> 
<p>column_width_minus1 [i]：表示纵向第i个Tile的宽度。</p> 
<p>row_height_minus1 [i]：表示横向第i个Tile的高度。</p> 
<p>loop_filter_across_tiles_enabled_flag： 表示是否允许环路滤波跨越Tile边界。</p> 
<p>pps_loop_filter_across_slices_enabled_flag： 表示是否允许环路滤波跨越Slice的左边界和上边界。</p> 
<p>deblocking_filter_control_present_flag： 表示PPS中是否存在去方块滤波的控制信息。</p> 
<p>deblocking_filter_override_enabled_flag： 表示Slice头中是否存在语法元素deblocking_filter_override_flag。</p> 
<p>pps_deblocking_filter_disabled_flag： 表示Slice中是否使用去方块滤波器。</p> 
<p>pps_beta_offset_div2和pps_tc_offset_div2： 其用于给出Slice所使用的默认的去方块滤波参数补偿值β和tC。该两个语法元素的取值范围都是[−6，6]。</p> 
<p>pps_scaling_list_data_present_flag： 表示当前PPS中是否存在变换矩阵的信息，若存在，这一信息会对SPS中的该信息进行覆盖。</p> 
<p>lists_modification_present_flag： 表示Slice头中是否存在句法结构ref_pic_lists_modification()。</p> 
<p>log2_parallel_merge_level_minus2： 用于给出变量Log2ParMrgLevel的值。变量Log2ParMrgLevel被用在merge模式下亮度分量MV的产生过程中，表示并行产生merge候选列表的能力。</p> 
<p>slice_segment_header_extension_present_flag： 表示SS头扩展句法元素是否存在。在该版本中，规定其取值为0。其取值为1，用做保留，供ITU-T及ISO/IEC将来使用。</p> 
<p>pps_extension_flag： 表示是否存在语法元素pps_extension_data_flag。在该版本中，规定其取值为0。其取值为1，用做保留，供ITU-T及ISO/IEC将来使用。</p> 
<p>pps_extension_data_flag： 可以是任意值。该语法元素的取值不影响解码器。解码过程忽略该语法元素。</p> 
<p><strong>3.5　片段层</strong></p> 
<p><strong>3.5.1　片与片段</strong></p> 
<p>一幅图像可以被分割为一个或多个片（Slice），每个片的压缩数据都是独立的，Slice头信息无法通过前一个Slice的头信息推断得到。这就要求Slice不能跨过它的边界来进行帧内或帧间预测，且在进行熵编码前需要进行初始化。但在进行环路滤波时，允许滤波器跨越Slice的边界进行滤波。除了Slice的边界可能受环路滤波影响外，Slice的解码过程可以不使用任何来自其他Slice的影响，且有利于实现并行运算。使用Slice的主要目的是当数据丢失后能再次保证解码同步。</p> 
<p>根据编码类型不同，Slice可分为以下几部分。</p> 
<p>① I Slice：该Slice中所有CU的编码过程都使用帧内预测。</p> 
<p>② P Slice：在I Slice的基础上，该Slice中的CU还可以使用帧间预测，每个预测块（PB）使用至多一个运动补偿预测信息。P Slice只使用图像参考列表list 0。</p> 
<p>③ B Slice：在P Slice的基础上，B Slice中的CU也可以使用帧间预测，但是每个PB可以使用至多两个运动补偿预测信息。B Slice可以使用图像参考列表list 0和list 1。</p> 
<p>一个独立的Slice可以被进一步划分为若干SS，包括一个独立SS和若干个依赖SS，并且以独立SS作为该Slice的开始。一个SS包含整数个CTU（至少一个），并且这些CTU分布在同一个NAL单元中。SS可以作为一个分组来传送视频编码数据。其中，独立SS是指它所涉及的句法元素可以由自身确定，依赖SS是指它所涉及的某些句法元素由已解码的独立SS推导得到。依赖SS可以共享独立SS携带的一些信息，例如RPS信息、SAO的可用性和加权预测的可用性等。预测过程不能跨越独立Slice的边界，但是可以跨越依赖SS的边界，一个Slice内的SS之间可以相互参考。下面的例子将分别对同一幅图像中的Slice及其所包含的SS做详细说明。</p> 
<p>例：如图3.4所示，一幅图像划分为两个Slice。第一个Slice由一个包含4个CTU的独立Slice segment、一个包含32个CTU的依赖SS和另外一个包含24个CTU的依赖SS组成；而第二个Slice由唯一一个包含39个CTU的独立SS组成。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/72/c6/W5QEMM2j_o.jpg"></p> 
<p>图3.4　Slice、独立SS、依赖SS 3者之间关系示意图</p> 
<p>H.265/HEVC编码的最高层为SS层，SS层所需要的图像层信息可以通过引用相应的PPS来获得。SS头包含其引用的PPS的标识号，同一幅图像中的所有SS引用同一个PPS。此外，SS头中会存在一些与PPS中相同的参数，SS头中的这些参数值会对PPS中的该参数值进行覆盖。以下部分对H.265/HEVC中SS相关语法语义做详细介绍。</p> 
<p><strong>3.5.2　片头语法语义</strong></p> 
<p>表3.4和表3.5分别给出了SS及SS头的相关句法元素。</p> 
<p>表3.4　SS的句法元素</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1b/45/rstn5TCW_o.jpg"></p> 
<p>表3.5　SS头的句法元素</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f2/41/Q8ar0mOz_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/c3/fvxpDsgU_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b9/cc/tGg8aej7_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/06/8f/ca4xJxrN_o.jpg"></p> 
<p>end_of_slice_segment_flag： 用于判断当前SS是否结束。</p> 
<p>end_of_sub_stream_one_bit： 取值应该为1。</p> 
<p>first_slice_segment_in_pic_flag： 表示按照解码顺序，当前SS是否为第一个SS。</p> 
<p>no_output_of_prior_pics_flag： 在IDR和BLA图像解码之后该语法元素会影响解码图像缓冲器中已解码图像的输出。</p> 
<p>slice_pic_parameter_set_id： 表示当前Slice所引用的PPS的ID号。</p> 
<p>dependent_slice_segment_flag： 表示当前SS是否依赖SS。</p> 
<p>slice_segment_address： 对一幅图像的CTU进行光栅扫描后，当前SS中第一个CTU的地址。</p> 
<p>slice_reserved_flag [i]：其值和语义保留，供ITU-T及ISO/IEC将来使用。解码器应该忽略该句法元素的值。</p> 
<p>slice_type： 指明Slice的编码类型。其值为0，表示该Slice是B Slice；其值为1，表示该Slice是P Slice；其值为2，表示该Slice是I Slice。</p> 
<p>pic_output_flag： 该句法元素影响解码图像的输出和移除过程。</p> 
<p>colour_plane_id： 当separate_colour_plane_flag为1时，该语法元素规定了彩色平面。其值为0，1，2时，分别对应着Y，Cb，Cr。</p> 
<p>slice_pic_order_cnt_lsb： 规定了当前图像的POC与MaxPicOrderCntLsb取模后的值，用于计算当前图像的POC值。</p> 
<p>short_term_ref_pic_set_sps_flag： 其值为1，表示当前图像的短期参考图像集可以通过SPS中的句法结构st_ref_pic_set()得出；其值为0，则表示当前图像的短期参考图像集可通过Slice头中的句法结构st_ref_pic_set()得出。当num_short_term_ref_pic_sets取值为0时，short_term_ref_pic_set_sps_flag应该等于0。</p> 
<p>short_term_ref_pic_set_idx： 表示当前图像使用哪一个短期参考图像集（由当前激活的SPS中指定）。</p> 
<p>num_long_term_sps： 表示当前图像的长期参考图像（在当前激活的SPS中指定）的数目。</p> 
<p>num_long_term_pics： 表示当前图像的长期参考图像（在Slice头中指定）的数目。</p> 
<p>lt_idx_sps [i]：表示当前图像的第i个长期参考图像在候选长期参考图像列表中的索引号。</p> 
<p>poc_lsb_lt [i]：表示当前图像的第i个长期参考图像的POC值与MaxPicOrderCntLsb取模之后的值。</p> 
<p>used_by_curr_pic_lt_flag [i]：表示当前图像长期参考图像集中第i个参考图像是否可以用做当前图像的参考。</p> 
<p>delta_poc_msb_present_flag [i]：表示delta_poc_msb_cycle_lt[i]是否存在。</p> 
<p>delta_poc_msb_cycle_lt [i]：用于计算当前图像的第i个长期参考图像的POC值（长期参考图像包括两部分——SPS和Slice头中分别指定的长期参考图像，该句法元素中的delta表示任一部分中相邻两个长期参考图像的poc_msb_cycle_lt的差值）。</p> 
<p>slice_temporal_mvp_enabled_flag： 表示帧间预测是否使用时域MV预测。</p> 
<p>slice_sao_luma_flag： 表示当前Slice的亮度分量是否使用SAO。</p> 
<p>slice_sao_chroma_flag： 表示当前Slice的色度分量是否使用SAO。</p> 
<p>num_ref_idx_active_override_flag： 表示当前Slice中语法元素的num_ref_idx_l0_active_minus1和num_ref_idx_l1_active_minus1是否存在。</p> 
<p>num_ref_idx_l0_active_minus1： 表示可能用于解码当前Slice的参考图像list0中的最大参考索引值，其取值范围为[0，14]。</p> 
<p>num_ref_idx_l1_active_minus1： 表示可能用于解码当前Slice的参考图像list1中的最大参考索引值，其取值范围为[0，14]。</p> 
<p>mvd_l1_zero_flag： 其值为1表示mvd_coding（x0，y0，1）未被解析，且对于compIdx = 0..1，MvdL1[x0][y0][compIdx]被设为0；其值为0表示mvd_coding（x0，y0，1）已被解析。</p> 
<p>cabac_init_flag： 规定在上下文变量的初始化过程中，是否使用初始化表。</p> 
<p>collocated_from_l0_flag： 规定用于时域MV预测的collocated图像来自参考图像列表list0还是list1。</p> 
<p>collocated_ref_idx： 规定用于时域MV预测的collocated图像的参考索引号。</p> 
<p>five_minus_max_num_merge_cand： 指定MVP候选点可合并的最大数目。</p> 
<p>slice_qp_delta： 规定当前Slice中CB可使用的的量化参数QpY 。</p> 
<p>slice_cb_qp_offset： 该语法元素值加上变量pps_cb_qp_offset的值即为量化参数变量Qp′Cb 的值。</p> 
<p>slice_cr_qp_offset： 该语法元素值加上变量pps_cr_qp_offset的值即为量化参数Qp′Cr 的值。</p> 
<p>deblocking_filter_override_flag： 表示Slice头是否存在去方块滤波参数。</p> 
<p>slice_deblocking_filter_disabled_flag： 表示当前Slice是否使用去方块滤波。该语法元素不存在时，可推测出其值等于pps_deblocking_filter_disabled_flag。</p> 
<p>slice_beta_offset_div2和slice_tc_offset_div2： 用于获取当前Slice的去方块滤波补偿参数β和tC。该两个语法元素不存在时，可推测出其值分别等于pps_beta_offset_div2和pps_tc_offset_div2。</p> 
<p>slice_loop_filter_across_slices_enabled_flag： 表示环路滤波是否可以跨越当前Slice的上边界和左边界。该语法元素不存在时，可推测出其值等于pps_loop_filter_across_slices_enabled_flag。</p> 
<p>num_entry_point_offsets： 表示Slice头中句法元素entry_point_offset _minus1[i]的数目。</p> 
<p>offset_len_minus1： 表示句法元素entry_point_offset_minus1[i]的比特长度。</p> 
<p>entry_point_offset_minus1 [i]：规定第i个entry point的以字节为单位的偏移量。</p> 
<p>slice_segment_header_extension_length： 表示SS头扩充数据的长度。</p> 
<p>slice_segment_header_extension_data_byte： 可以是任意值，解码器忽略该语法元素。在该版本中，其值不影响解码。</p> 
<p><strong>3.6　Tile单元</strong></p> 
<p><strong>3.6.1　Tile单元描述</strong></p> 
<p>H.265/HEVC对H.264/AVC的改进之处还在于Tile概念的提出。一幅图像不仅可以划分为若干个Slice，也可以划分为若干个Tile。即从水平和垂直方向将一幅图像分割为若干个矩形区域，一个矩形区域就是一个Tile。每个Tile包含整数个CTU，其可以独立解码。划分Tile的主要目的是在增强并行处理能力的同时又不引入新的错误扩散。Tile提供比CTB更大程度的并行（在图像或者子图像的层面上），在使用时无须进行复杂的线程同步。</p> 
<p>Tile的划分并不要求水平和垂直边界均匀分布，可根据并行计算和差错控制的要求灵活掌握。通常情况下，每一个Tile中包含的CTU数据是近似相等的。在编码时，图像中的所有Tile按照扫描顺序进行处理，每个Tile中的CTU也按照扫描顺序进行编码。一个Tile包含的CTU个数和Slice中的CTU个数互不影响，图3.5中给出了Tile的一种划分方式。这是3×3的划分，整幅图像被划分为9个Tile，每个Tile都为矩形。在同一幅图像中，可以同时存在某些Slice中包含多个Tile和某些Tile中包含多个Slice的情况。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/41/03/k1L4xv5L_o.jpg"></p> 
<p>图3.5　Tile划分示意图</p> 
<p><strong>3.6.2　Slice与Tile</strong></p> 
<p>在H.265/HEVC中，Slice和Tile划分的目的都是为了进行独立解码，但是二者的划分方式又有所不同。Tile形状基本上为矩形，Slice的形状则为条带状。Slice由一系列的SS组成，一个SS由一系列的CTU组成。Tile则直接由一系列的CTU组成。Slice/SS和Tile之间必须遵守一些基本原则，每个Slice/SS和Tile至少要满足以下两个条件之一。</p> 
<p>① 一个Slice/SS中的所有CTU属于同一个Tile。</p> 
<p>② 一个Tile中的所有CTU属于同一个Slice/SS。</p> 
<p>下面的例子将分别对同一幅图像中的Slice和Tile划分做详细说明。</p> 
<p>例：图3.6中一幅图像在垂直方向上被分割为三个Tile。图3.6（a）中这三个Tile中各自的所有CTU都属于同一个Slice，图3.6（b）中一个Slice中的所有CTU都属于同一个Tile。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3b/50/ScJP7ykK_o.jpg"></p> 
<p>图3.6　Tile和Slice之间的关系</p> 
<p><strong>3.7　树形编码块</strong></p> 
<p>传统的视频编码都是基于宏块实现的，对于4：2：0采样格式的视频，一个宏块包含一个16×16大小的亮度块和两个8×8大小的色度块。考虑到高清视频/超高清视频的自身特性，H.265/HEVC标准中引入了树形编码单元CTU，其尺寸由编码器指定，且可大于宏块尺寸。同一位置处的一个亮度CTB和两个色度CTB，再加上相应的语法元素形成一个CTU。对于一个大小为L×L的亮度CTB，L的取值可以是16、32或64。在高分辨率视频的编码中，使用较大的CTB可以获得更好的压缩性能。</p> 
<p>为了灵活、高效地表示视频场景中的不同纹理细节、运动变化的视频内容或者视频对象，H.265/HEVC为图像划分定义了一套全新的语法单元，包括编码单元CU、预测单元（Prediction Unit，PU）和变换单元（Transform Unit，TU）。其中编码单元是进行预测、变换、量化和熵编码等处理的基本单元，预测单元是进行帧内/帧间预测的基本单元，变换单元是进行变换和量化的基本单元。这三个单元的分离，不仅使得变换、预测和编码各个处理环节更加灵活，也使得各环节的划分更加符合视频图像的纹理特征，保证编码性能的最优化。</p> 
<p><strong>3.7.1　编码单元</strong></p> 
<p>近年来标清和高清视频产业得到了蓬勃发展。大尺寸图像的一个特点是平缓区域的面积更大，用较大的块进行编码能够极大地提升编码效率。在H.264/AVC中，编码块（Coding Block，CB）的大小是固定的。而在H.265/HEVC中，一个CTB可以直接作为一个CB，也可以进一步以四叉树的形式划分为多个小的CB。所以H.265/HEVC中CB的大小是可变的，亮度CB最大为64×64，最小为8×8。一方面大的CB可以使得平缓区域的编码效率大大提高，另一方面小的CB能很好地处理图像局部的细节，从而可以使复杂图像的预测更加准确。一个亮度CB和相应的色度CB及它们相关的句法元素共同组成一个编码单元（CU）。在H.265/HEVC中，一幅图像可以被划分为若干个互不重叠的CTU，在CTU内部，采用基于四叉树的循环分层结构。同一层次上的编码单元具有相同的分割深度。一个CTU可能只包含一个CU（没有进行划分），也可能被划分为多个CU。图3.7是一幅图像划分为CTU以及一个CTU划分为CU的示意图。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6b/b4/Zu8v0hvp_o.jpg"></p> 
<p>图3.7　图像划分结构示意图</p> 
<p>编码单元是否继续被划分取决于分割标志位Split flag。对于编码单元CUd ，假设它的大小为2N×2N，深度为d。如果它对应的Split flag值为0，则CUd 不再进行四叉树划分；反之，CUd 将会被划分为4个独立的编码单元CUd+1 。编码单元CUd+1 的深度和大小分别变为d+1和N×N。图3.8给出了CUd ，d和Split flag三者之间的划分关系。这种灵活的单元表示方法与H.264/AVC中的宏块划分方法相比有以下优点。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d5/5f/Qh6Y1yaB_o.jpg"></p> 
<p>图3.8　编码单元的循环四叉树分层结构</p> 
<p>① 编码单元的大小可以大于传统的宏块大小（16×16）。对于平坦区域，用一个较大的编码单元编码可以减少所用的比特数，提高编码效率。这一点在高清视频应用领域体现得尤为明显。</p> 
<p>② 通过合理地选择CTU大小和最大层次深度，编码器的编码结构可以根据不同的图片内容、图片大小以及应用需求获得较大程度的优化。</p> 
<p>③ 所有的单元类型都统称为编码单元，消除了宏块与亚宏块之分，并且编码单元的结构可以根据CTU大小、最大编码深度以及一系列划分标志Split flag简单地表示出来。</p> 
<p>此外，表3.6给出了CU所涉及的相关语法元素。</p> 
<p>表3.6　编码单元语法语义</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d0/57/nw65yhI5_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/97/d6/lcBYVH3b_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f4/cd/egiWxSWK_o.jpg"></p> 
<p>cu_transquant_bypass_flag： 表示对CU是否进行伸缩、变换和环路滤波过程。</p> 
<p>cu_skip_flag [x0][y0]：表示是否跳过当前CU。</p> 
<p>pred_mode_flag： 其值为0，表示当前CU的预测模式为MODE_INTER；其值为1，表示当前CU的预测模式为MODE_INTRA。</p> 
<p>part_mode： 规定当前CU的分割模式，其值取决于CU的预测模式（CuPredMode[x0][y0]）。表3.7给出了该语法元素对应的具体的分割模式。</p> 
<p>表3.7　part_mode语义</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/68/f2/lyVfk9DC_o.jpg"></p> 
<p>pcm_flag [x0][y0]：该值等于1，表示CU（亮度CB位于（x0，y0））中存在语法结构体pcm_sample()，不存在语法结构体transform_tree()；其值等于0，则表示不存在语法结构体pcm_sample()。</p> 
<p>pcm_alignment_zero_bit： 表示一个等于0的比特。</p> 
<p>prev_intra_luma_pred_flag [x0 + i][y0 + j]、mpm_idx [x0 + i][y0 + j]和rem_intra_luma_pred_mode [x0 + i][y0 + j]：规定亮度分量的帧内预测模式。当prev_intra_luma_pred_flag[x0 + i][y0 + j]等于1时，帧内预测模式可以从其相邻预测单元的帧内预测模式推测得到。</p> 
<p>intra_chroma_pred_mode [x0][y0]：规定色度分量的帧内预测模式。</p> 
<p>rqt_root_cbf： 表示当前CU是否存在transform_tree()语法结构体。</p> 
<p><strong>3.7.2　预测单元</strong></p> 
<p>预测单元PU规定了编码单元的所有预测模式，一切与预测有关的信息都定义在预测单元部分。比如，帧内预测的方向、帧间预测的分割方式、运动矢量预测，以及帧间预测参考图像索引号都属于预测单元的范畴。一个2N×2N的编码单元所包含的预测单元划分模式如图3.9所示。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/24/21/LBSowBHT_o.jpg"></p> 
<p>图3.9　H.265/HEVC预测单元的划分模式</p> 
<p>对于一个2N×2N的CU模式，帧内预测单元PU的可选模式有两种：2N×2N和N×N；帧间预测单元PU的可选模式有8种：4种对称模式（2N×2N、2N×N、N×2N、N×N）和4种非对称模式（2N×nU、2N×nD、nL×2N、nR×2N）。其中2N×nU和2N×nD分别以上下1：3、3：1的比率划分，nL×2N和nR×2N分别以左右1：3、3：1的比率划分。skip模式是帧间预测的一种，当需要编码的运动信息只有运动参数集索引（采用运动合并技术），编码残差信息不需要编码时，为2N×2N skip模式。此外，表3.8还给出了PU相关的语法元素。</p> 
<p>表3.8　预测单元语法语义</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2e/69/JBa7HkSj_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6a/6d/6EgKITEM_o.jpg"></p> 
<p>mvp_l0_flag [x0][y0]：表示MVP在list0中的索引。该语法元素不存在时，可以推测出其值等于0。</p> 
<p>mvp_l1_flag [x0][y0]：表示MVP在list1中的索引。该语法元素不存在时，可以推测出其值等于0。</p> 
<p>merge_flag [x0][y0]：表示当前PU的帧间预测参数是否由相邻帧间预测块推测得到。当该语法元素不存在时，若CuPredMode[x0][y0]等于MODE_SKIP，则该语法元素值等于1；否则等于0。</p> 
<p>merge_idx [x0][y0]：表示在融合（merge）候选列表中的候选索引。该语法元素值不存在时，可推测出其值等于0。</p> 
<p>inter_pred_idc [x0][y0]：规定当前PU使用list0、list1，还是双向预测，见表3.9。该语法元素值不存在时，可推测出其值为PRED_L0。</p> 
<p>表3.9　inter_pred_idc的语义</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d3/03/jE1AKqUE_o.jpg"></p> 
<p>ref_idx_l0 [x0][y0]：表示当前PU的list0的参考图像索引。该语法元素值不存在时，默认为0。</p> 
<p>ref_idx_l1 [x0][y0]：表示当前PU的list1的参考图像索引。该语法元素值不存在时，默认为0。</p> 
<p><strong>3.7.3　变换单元</strong></p> 
<p>变换单元是独立完成变换和量化的基本单元，其尺寸也是灵活变化的。H.265/HEVC突破了原有的变换尺寸限制，可支持大小为4×4~32×32的编码变换，以变换单元（TU）为基本单元进行变换和量化。它的大小依赖于CU模式，在一个CU内，允许TU跨越多个PU，以四叉树的形式递归划分。图3.10给出了CTU为64×64时各个CU中TU的分割结构。对于一个2N×2N的CU，有一个标志位决定其是否划分为4个N×N的TU，是否可以进一步划分由SPS中的TU的最大划分深度决定。根据预测残差的局部变化特性，TU可以自适应地选择最优的模式。大块的TU模式能够将能量更好地集中，小块的TU模式能够保存更多的图像细节。这种灵活的分割结构，可以使变换后的残差能量得到充分压缩，以进一步提高编码增益。同时，表3.10给出了TU相关的语法元素。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4f/08/pxRPTW3l_o.jpg"></p> 
<p>图3.10　CU中TU四叉树划分示意图</p> 
<p>表3.10　变换单元语法元素</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/14/23/1G2GwsjF_o.jpg"></p> 
<p>cu_qp_delta_abs： 表示当前编码单元的亮度量化参数和它的预测值的差值CuQpDeltaVal的绝对值。</p> 
<p>cu_qp_delta_sign_flag： 表示CuQpDeltaVal的符号。</p> 
<p><strong>3.8　档次、层和级别</strong></p> 
<p>在H.264中就有对档次（Profile）和级别（Level）的划分，它们规定了比特流必须要遵守的一些限制要求。而H.265/HEVC在此基础上又定义了一个新的概念：层（Tier）。档次、层和级别为多种不同应用提供了兼容性。档次主要规定编码器可采用哪些编码工具或算法。级别则是指根据解码端的负载和存储空间情况对关键参数加以限制[如最大采样频率、最大图像尺寸、分辨率、最小压缩率，最大比特率和CPB（解码缓冲区）大小等]。考虑到应用可以依据最大的码率和CPB大小来区分，因此有些Level定义了两个Tier：主层（Main Tier）和高层（High Tier），主层用于大多数应用，高层用于那些最苛刻的应用。满足某一Level或Tier的解码器应当可以解码当前Level和Tier，以及比当前Level和Tier更低的Level和Tier的所有码流，满足某一Profile的解码器必须支持该Profile中的所有特性。编码器不必实现Profile中的所有特性，但生成的码流必须遵守标准规定。</p> 
<p><strong>3.8.1　档次</strong></p> 
<p>在H.265/HEVC标准中提出了三种档次，分别是Main，Main 10和Main Still Picture。这三个档次的限制条件如下：</p> 
<p>① 只支持4：2：0色度采样信号；</p> 
<p>② 使用了Tiles便不能使用WPP，每一个Tile的亮度分辨率至少要为256×64；</p> 
<p>③ Main和Main Still Picture档次支持8位像素深度，Main 10档次则支持10位像素深度，Main Still Picture档次不支持帧间预测。</p> 
<p>1. Main</p> 
<p>支持每像素8比特的位深、4：2：0的采样格式，是最常见的档次。</p> 
<p>2. Main 10</p> 
<p>2012年10月的会议上，提案JCTVC-K0109提出了10比特位深的档次，其指出10比特位深的图像有助于提高视频质量。该提案获得通过，这一技术主要应用于消费电子领域。Main 10档次支持每像素8比特或者10比特的位深、4：2：0的采样格式。由于采用更多的比特来描述像素值，Main 10可以大幅度提高重构视频的质量。支持Main 10档次的解码器必须同时可以解码Main和Main 10档次的码流。</p> 
<p>3. Main Still Picture</p> 
<p>Main Still Picture档次支持单个静止图像，其按照Main档次的规定进行编码。为了测试Main Still Picture档次下静态图像的压缩性能，将H.265/HEVC HM 8.0rc2，JPEG 2000 kakadu v6.0和JPEG IJG v6b进行实验对比。视频质量评价标准采用基于PSNR的客观评价和基于平均意见得分（MOS）的主观评价。对于4：2：0色度采样信号，相比于JPEG 2000和JPEG，在相同重构视频质量下（PSNR度量），H.265/HEVC编码下得到的码率分别下降了20.26%和61.63%；在相同重构视频质量下（MOS度量），H.265/HEVC编码下得到的码率分别下降了30.96%和43.10%。</p> 
<p>下面主要给出Main和Main 10这两个档次各自可采用的编码工具，见表3.11。关于Main Still Picture档次，可按照Main档次中提供的编码工具进行编码。</p> 
<p>表3.11　Main和Main 10所采用的编码工具</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f6/cb/Q8HdJB5A_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/64/18/9kYngz1j_o.jpg"></p> 
<p><strong>3.8.2　层和级别</strong></p> 
<p>H.265/HEVC标准中定义了两个层和13个级，见表3.12。两个层分别是Main Tier和High Tier。4和4以上的8个Level支持High Tier。Tier按其最高比特率来处理应用问题，Main Tier可适用于大多数应用，High Tier用于高需求应用。符合某一Tier/Level的解码器能够解码当前以及比当前Tier/Level低的所有码流。</p> 
<p>表3.12　Level和Tier</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6d/c6/UllIfz4a_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1c/60/9YOgtSed_o.jpg"></p> 
<p>同一个Level实际上就是一套对编码比特流的一系列编码参数的限制。H.265/HEVC的13个级支持从QCIF到8k多种分辨率的图像。图像宽高受到该级别定义参数MaxLumaPS的限制——图像的宽和高均须小于等于8倍的MaxLumaPS再开方。此外，Level还约束了每幅图像中垂直和水平方向Tile的最大数量，以及每秒最大的Tile数量。此外，表3.13还给出了它们相关的语法元素。</p> 
<p>表3.13　档次、层和级的语法语义</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/60/GYlS3RqC_o.jpg"></p> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/81/cf/gkc6zYeO_o.jpg"></p> 
<p>general_profile_space： 在该版本中，其值取0。该语法元素的其他值保留将来使用。它规定了一个档次空间，包含所有档次的ID号和对应的内容。</p> 
<p>general_tier_flag： 规定了当前档次中使用的层的内容。</p> 
<p>general_profile_idc： 其值取0时，表示当前CVS编码过程使用的档次的ID号。其他值保留供ITU-T及ISO/IEC将来使用。</p> 
<p>general_profile_compatibility_flag [j]：当general_profile_space值等于0时，该语法元素取值为1，表示当前CVS编码过程使用的档次的ID号为j。</p> 
<p>general_progressive_source_flag 和general_interlaced_source_flag： 用于指定CVS中图像的扫描方式，即逐行扫描、隔行扫描或未指明扫描方式等。</p> 
<p>general_non_packed_constraint_flag： 指明CVS中是否存在frame packing arrangement SEI messages。</p> 
<p>general_frame_only_constraint_flag： 指定field_seq_flag的值是否为0。</p> 
<p>general_reserved_zero_44bits： 其值为0，解码器应忽略该值。</p> 
<p>general_level_idc： 指明CVS中使用的level的ID号。</p> 
<p>sub_layer_profile_present_flag [i]：表示在TemporalId等于i的子层中，其profile_tier_level()语法结构体中是否存在档次的信息。</p> 
<p>sub_layer_level_present_flag [i]：表示在TemporalId等于i的子层中，其profile_tier_level()语法结构体中是否存在级的信息。</p> 
<p>reserved_zero_2bits [i]：其值为0。解码器应忽略该值。以下是跟子层有关的语法元素，它们适用于TemporalId等于i的子层，其语法语义和前面的general部分相同。</p> 
<p>sub_layer_profile_space [i]</p> 
<p>sub_layer_tier_flag [i]</p> 
<p>sub_layer_profile_idc [i]</p> 
<p>sub_layer_profile_compatibility_flag [i][j]</p> 
<p>sub_layer_progressive_source_flag [i]</p> 
<p>sub_layer_interlaced_source_flag [i]</p> 
<p>sub_layer_non_packed_constraint_flag [i]</p> 
<p>sub_layer_frame_only_constraint_flag [i]</p> 
<p>sub_layer_reserved_zero_44bits [i]</p> 
<p>sub_layer_level_idc [i]</p> 
<p><strong>参考文献</strong></p> 
<p><a href="http://reader.epubee.com/books/mobile/90/9046b984943e32a544cd1d11b1244ba4/text00007.html" rel="nofollow" title="[1]">[1]</a> High efficiency video coding, ITU-T Recommendation H.265 and ISO/IEC 23008-2 （HEVC）, ITU-T and ISO/IEC JTC 1, Apr. 2013.</p> 
<p>   </p> 
<p>出自：《新一代高效视频编码H.265/HEVC：原理、标准与实现》</p> 
<p>万帅 &amp; 杨付正</p> 
<p>   </p> 
<p>   </p> 
<p><em>来自 &lt;<a href="http://reader.epubee.com/books/mobile/90/9046b984943e32a544cd1d11b1244ba4/text00007.html" rel="nofollow" title="http://reader.epubee.com/books/mobile/90/9046b984943e32a544cd1d11b1244ba4/text00007.html">http://reader.epubee.com/books/mobile/90/9046b984943e32a544cd1d11b1244ba4/text00007.html</a>&gt;</em></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/374794c7916aaa554164bb5e6aca4294/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker容器开启IPv6</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2cfa2940f6ab7def0dcbb54a1dfe51fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML快速生成代码的语法，简单快速上手。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>