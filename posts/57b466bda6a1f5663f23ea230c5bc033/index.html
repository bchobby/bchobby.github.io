<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式--今天就学这么多 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式--今天就学这么多" />
<meta property="og:description" content="设计模式 设计模式，其实就是一种写代码时的设计思想。
分类：
创建型
单例模式
原型模式
构造器模式
工厂模式
抽象工厂模式
结构型
桥接模式
外观模式
组合模式
装饰器模式
适配器模式
代理模式
享元模式
行为型
迭代器模式
解释器模式
观察者模式
中介者模式
访问者模式
状态模式
策略模式
命令模式
模板模式
为什么要学习理解设计模式
我们在写代码，写页面时，为了可维护、可迭代、可读性、低耦合性等等，有时需要考虑 逻辑代码该怎么封装，组件该怎么封装，设计模式 就是 前人从以往的经验中总结出来的一些 书写代码的思想（或者说套路），帮助我们更快的做决定、做判断，为了更好的应对我们的场景，我们眼下这块代码该怎么写。
设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结（来自百度百科）
注意：
我们实现某块功能，某个组件时，可以结合多个设计模式
外观模式（Facade） 概念：
为子系统中的 一组接口 提供一个一致的界面，外观模式定义了 一个高层接口
这个 接口 使得这一子系统更加容易使用。
引入外观角色之后，用户只需要直接与外观角色交互
用户与子系统之间的复杂关系由外观角色内部来处理，从而降低了系统的耦合度
应用示例：
普通登录、邮箱登录、手机登录，三个表单，那么我们就要判断该显示那个表单
先经过一层简单封装，变为：
逻辑处理还是留在了使用层
所以，使用 外观模式：
将逻辑判断和处理留在封装组件的内部，组件变得可读，可随意抽离
单例模式 概念：
保证一个类只有一个实例（提供一个访问它的全局访问点，无论”创建“多少次，都只返回第一次所创建的那个唯一的实例）
单例模式是创建型设计模式的一种。针对全局仅需一个实例的场景
实现需求：
具备判断自己是否已经创建过该实例的的能力
理解与应用
jquery 我们全局需要几个，只需要一个，所以这就是符合单例模式的
逻辑代码层面：
静态方法实现：
&lt;span style=&#34;background-color:#f8f8f8&#34;&gt; &lt;span style=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/57b466bda6a1f5663f23ea230c5bc033/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-26T18:16:20+08:00" />
<meta property="article:modified_time" content="2022-03-26T18:16:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式--今天就学这么多</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong><span style="color:#333333;">设计模式</span></strong></h3> 
<p style="margin-left:.8em;"><span style="color:#333333;">设计模式，其实就是一种写代码时的设计思想。</span></p> 
<p><strong><span style="color:#333333;">分类：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>创建型</p> 
  <ul style="margin-left:0;"><li> <p>单例模式</p> </li><li> <p>原型模式</p> </li><li> <p>构造器模式</p> </li><li> <p>工厂模式</p> </li><li> <p>抽象工厂模式</p> </li></ul></li><li> <p>结构型</p> 
  <ul style="margin-left:0;"><li> <p>桥接模式</p> </li><li> <p>外观模式</p> </li><li> <p>组合模式</p> </li><li> <p>装饰器模式</p> </li><li> <p>适配器模式</p> </li><li> <p>代理模式</p> </li><li> <p>享元模式</p> </li></ul></li><li> <p>行为型</p> 
  <ul style="margin-left:0;"><li> <p>迭代器模式</p> </li><li> <p>解释器模式</p> </li><li> <p>观察者模式</p> </li><li> <p>中介者模式</p> </li><li> <p>访问者模式</p> </li><li> <p>状态模式</p> </li><li> <p>策略模式</p> </li><li> <p>命令模式</p> </li><li> <p>模板模式</p> </li></ul></li></ul> 
<p><strong><span style="color:#333333;">为什么要学习理解设计模式</span></strong></p> 
<p style="margin-left:.8em;"><span style="color:#333333;">我们在写代码，写页面时，为了可维护、可迭代、可读性、低耦合性等等，有时需要考虑 <span style="color:#ea0000;"><strong>逻辑代码该怎么封装，组件该怎么封装</strong></span>，设计模式 就是 前人从以往的经验中总结出来的一些 <strong>书写代码的思想</strong>（或者说套路），帮助我们更快的<strong>做决定、做判断</strong>，为了<strong>更好的应对</strong>我们的场景，我们眼下这块代码该怎么写。</span></p> 
<p style="margin-left:.8em;"><span style="color:#333333;"><strong>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结</strong>（来自百度百科）</span></p> 
<p><strong><span style="color:#333333;">注意：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>我们实现某块功能，某个组件时，可以结合多个设计模式</p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">外观模式（Facade）</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>为子系统中的 <strong>一组接口 </strong>提供一个一致的界面，外观模式定义了 <strong>一个高层接口</strong></p> <p>这个 <strong>接口</strong> 使得这一子系统更加容易使用。</p> <p>引入外观角色之后，用户<span style="color:#ea7500;">只需要直接与外观角色交互</span></p> <p>用户与子系统之间的复杂关系由外观角色内部来处理，从而<span style="color:#8600ff;">降低了系统的耦合度</span></p> </li></ul> 
<p><strong><span style="color:#333333;">应用示例：</span></strong></p> 
<p style="margin-left:.8em;"><span style="color:#333333;">普通登录、邮箱登录、手机登录，三个表单，那么我们就要判断该显示那个表单</span></p> 
<p style="margin-left:.8em;"><img alt="" height="526" src="https://images2.imgbox.com/26/10/ZKTXuWQC_o.png" width="541"></p> 
<p></p> 
<p style="margin-left:.8em;"><span style="color:#333333;">先经过一层简单封装，变为：</span></p> 
<p style="margin-left:.8em;"><img alt="" height="116" src="https://images2.imgbox.com/c1/e5/Gwtpt45V_o.png" width="487"></p> 
<p></p> 
<p style="margin-left:.8em;"><span style="color:#333333;">逻辑处理还是留在了使用层</span></p> 
<p style="margin-left:.8em;"><span style="color:#333333;">所以，使用 外观模式：</span></p> 
<p style="margin-left:.8em;"><img alt="" height="115" src="https://images2.imgbox.com/7b/b2/TlP5JkSr_o.png" width="490"></p> 
<p></p> 
<p style="margin-left:.8em;"><span style="color:#333333;">将逻辑判断和处理留在封装组件的内部，组件变得可读，可随意抽离</span></p> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">单例模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>保证一个类<span style="color:#ea0000;">只有一个实例</span>（<span style="color:#8600ff;">提供一个访问它的全局访问点</span>，无论”创建“多少次，都只返回第一次所创建的那个唯一的实例）</p> </li><li> <p>单例模式是创建型设计模式的一种。<strong>针对全局仅需一个实例</strong>的场景</p> </li></ul> 
<p><strong><span style="color:#333333;">实现需求：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p><strong>具备判断自己是否已经创建过该实例的的能力</strong></p> </li></ul> 
<p><strong><span style="color:#333333;">理解与应用</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>jquery 我们全局需要几个，只需要一个，所以这就是符合单例模式的</p> </li><li> <p>逻辑代码层面：</p> 
  <ul style="margin-left:0;"><li> <p>静态方法实现：</p> <pre class="has" style="text-align:left;"><code class="language-md-end-block">&lt;span style="background-color:#f8f8f8"&gt; &lt;span style="color:#aa5500"&gt;// 静态方法的实现&lt;/span&gt;
 &lt;span style="color:#770088"&gt;class&lt;/span&gt; &lt;span style="color:#0000ff"&gt;SingleLoading&lt;/span&gt; {
   &lt;span style="color:#000000"&gt;show&lt;/span&gt; () {
     &lt;span style="color:#000000"&gt;console&lt;/span&gt;.&lt;span style="color:#000000"&gt;log&lt;/span&gt;(&lt;span style="color:#aa1111"&gt;'这是一个单例Loading'&lt;/span&gt;)
   }
   &lt;span style="color:#770088"&gt;static&lt;/span&gt; &lt;span style="color:#000000"&gt;getInstance&lt;/span&gt;(){
     &lt;span style="color:#aa5500"&gt;// 判断是否已经创建过实例&lt;/span&gt;
     &lt;span style="color:#770088"&gt;if&lt;/span&gt; (&lt;span style="color:#981a1a"&gt;!&lt;/span&gt;&lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;.&lt;span style="color:#000000"&gt;instance&lt;/span&gt;) {
       &lt;span style="color:#aa5500"&gt;// 将创建的实例对象保持下来&lt;/span&gt;
       &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;.&lt;span style="color:#000000"&gt;instance&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;()
     }
     &lt;span style="color:#770088"&gt;return&lt;/span&gt; &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;.&lt;span style="color:#000000"&gt;instance&lt;/span&gt;
   }
 }
 &lt;span style="color:#770088"&gt;const&lt;/span&gt; &lt;span style="color:#0000ff"&gt;loading1&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;.&lt;span style="color:#000000"&gt;getInstance&lt;/span&gt;()
 &lt;span style="color:#770088"&gt;const&lt;/span&gt; &lt;span style="color:#0000ff"&gt;loading2&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;.&lt;span style="color:#000000"&gt;getInstance&lt;/span&gt;()
 &lt;span style="color:#000000"&gt;console&lt;/span&gt;.&lt;span style="color:#000000"&gt;log&lt;/span&gt;(&lt;span style="color:#000000"&gt;loading1&lt;/span&gt; &lt;span style="color:#981a1a"&gt;===&lt;/span&gt; &lt;span style="color:#000000"&gt;loading2&lt;/span&gt;) &lt;span style="color:#aa5500"&gt;// true&lt;/span&gt;&lt;/span&gt;</code></pre> </li><li> <p>闭包实现</p> <pre class="has" style="text-align:left;"><code class="language-md-end-block">&lt;span style="background-color:#f8f8f8"&gt; &lt;span style="color:#770088"&gt;class&lt;/span&gt; &lt;span style="color:#0000ff"&gt;SingleLoading&lt;/span&gt; {
   &lt;span style="color:#000000"&gt;show&lt;/span&gt; () {
     &lt;span style="color:#000000"&gt;console&lt;/span&gt;.&lt;span style="color:#000000"&gt;log&lt;/span&gt;(&lt;span style="color:#aa1111"&gt;'这是一个单例Loading'&lt;/span&gt;)
   }
 }
 &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;.&lt;span style="color:#000000"&gt;getInstance&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; (&lt;span style="color:#770088"&gt;function&lt;/span&gt;(){
   &lt;span style="color:#aa5500"&gt;// 定义自由变量instance，模拟私有变量&lt;/span&gt;
   &lt;span style="color:#770088"&gt;let&lt;/span&gt; &lt;span style="color:#0000ff"&gt;instance&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#221199"&gt;null&lt;/span&gt;
 ​
   &lt;span style="color:#770088"&gt;return&lt;/span&gt; &lt;span style="color:#770088"&gt;function&lt;/span&gt;(){
     &lt;span style="color:#770088"&gt;if&lt;/span&gt;(&lt;span style="color:#981a1a"&gt;!&lt;/span&gt;&lt;span style="color:#0055aa"&gt;instance&lt;/span&gt;) {
        &lt;span style="color:#aa5500"&gt;// 如果为null则new出唯一实例&lt;/span&gt;
       &lt;span style="color:#0055aa"&gt;instance&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;()
     }
     &lt;span style="color:#770088"&gt;return&lt;/span&gt; &lt;span style="color:#0055aa"&gt;instance&lt;/span&gt;
   }
 })();
 &lt;span style="color:#770088"&gt;const&lt;/span&gt; &lt;span style="color:#0000ff"&gt;loading3&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;().&lt;span style="color:#000000"&gt;getInstance&lt;/span&gt;()
 &lt;span style="color:#770088"&gt;const&lt;/span&gt; &lt;span style="color:#0000ff"&gt;loading4&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;SingleLoading&lt;/span&gt;().&lt;span style="color:#000000"&gt;getInstance&lt;/span&gt;()
 &lt;span style="color:#000000"&gt;console&lt;/span&gt;.&lt;span style="color:#000000"&gt;log&lt;/span&gt;(&lt;span style="color:#000000"&gt;loading3&lt;/span&gt; &lt;span style="color:#981a1a"&gt;===&lt;/span&gt; &lt;span style="color:#000000"&gt;loading4&lt;/span&gt;)&lt;/span&gt;</code></pre> </li></ul></li><li> <p>封装组件层面：</p> <p>我们页面中有时需要显示弹框，而且同时只能显示一个（也就是说只需要一个），那么就可以用<span style="color:#ea7500;">单例模式的思想</span>来封装一个 <strong>弹框组件</strong></p> <p>实现的<strong>核心思想</strong>：是否已创建弹框，没有则创建，有则直接使用</p> <p>这样做的好处：<span style="color:#8600ff;">避免了频繁创建和销毁实例，减少内存消耗</span></p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">工厂模式</span></strong></h4> 
<p><strong><span style="color:#333333;">分类：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p><code>简单工厂模式</code>、<code>工厂方法模式</code>、<code>抽象工厂模式</code></p> </li></ul> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p><code>简单工厂模式</code>又叫<code>静态工厂模式</code>，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。（白话：只要我能做，要什么样的，做什么样的）</p> </li></ul> 
<p><strong><span style="color:#333333;">理解与应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>工厂生产零件，我们<span style="color:#8600ff;">常用的（需要重复用）的</span>细小零件都可以采用工厂模式来生产，工厂会<span style="color:#8600ff;">根据我们的要求</span>来生产零件。</p> </li><li> <p>在<strong>组件封装</strong>层面：例如一些按钮，输入框，我们在很多地方要使用，但是每次使用这些小零件的时候，可能存在<span style="color:#ea0000;">细微的差别</span>，那么，我们就要将我们的建造的那个<strong>工厂</strong>，尽可能打造成一个<span style="color:#ea7500;">尽可能灵活的工厂</span>，让其可以做<span style="color:#8600ff;">各种型号的螺丝</span></p> <p>展示一个很好的 输入框的工厂组件 案例</p> <p><img alt="" height="626" src="https://images2.imgbox.com/34/c8/zVTw906S_o.png" width="652"></p> <p></p> <p></p> </li><li> <p>在<strong>逻辑代码封装</strong>层面：例如 不同的管理人员，有不同的权限，也可以用简单工厂模式来整理</p> <pre class="has" style="text-align:left;"><code class="language-md-end-block">&lt;span style="background-color:#f8f8f8"&gt; &lt;span style="color:#aa5500"&gt;//User类&lt;/span&gt;
 &lt;span style="color:#770088"&gt;class&lt;/span&gt; &lt;span style="color:#0000ff"&gt;User&lt;/span&gt; {
   &lt;span style="color:#aa5500"&gt;//构造器&lt;/span&gt;
   &lt;span style="color:#000000"&gt;constructor&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;opt&lt;/span&gt;) {
     &lt;span style="color:#770088"&gt;this&lt;/span&gt;.&lt;span style="color:#000000"&gt;name&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#0055aa"&gt;opt&lt;/span&gt;.&lt;span style="color:#000000"&gt;name&lt;/span&gt;;
     &lt;span style="color:#770088"&gt;this&lt;/span&gt;.&lt;span style="color:#000000"&gt;viewPage&lt;/span&gt; &lt;span style="color:#981a1a"&gt;=&lt;/span&gt; &lt;span style="color:#0055aa"&gt;opt&lt;/span&gt;.&lt;span style="color:#000000"&gt;viewPage&lt;/span&gt;;
   }
 ​
   &lt;span style="color:#aa5500"&gt;//静态方法&lt;/span&gt;
   &lt;span style="color:#770088"&gt;static&lt;/span&gt; &lt;span style="color:#000000"&gt;getInstance&lt;/span&gt;(&lt;span style="color:#0000ff"&gt;role&lt;/span&gt;) {
     &lt;span style="color:#770088"&gt;switch&lt;/span&gt; (&lt;span style="color:#0055aa"&gt;role&lt;/span&gt;) {
       &lt;span style="color:#770088"&gt;case&lt;/span&gt; &lt;span style="color:#aa1111"&gt;'superAdmin'&lt;/span&gt;:
         &lt;span style="color:#770088"&gt;return&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;User&lt;/span&gt;({ &lt;span style="color:#000000"&gt;name&lt;/span&gt;: &lt;span style="color:#aa1111"&gt;'超级管理员'&lt;/span&gt;, &lt;span style="color:#000000"&gt;viewPage&lt;/span&gt;: [&lt;span style="color:#aa1111"&gt;'首页'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'通讯录'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'发现页'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'应用数据'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'权限管理'&lt;/span&gt;] });
         &lt;span style="color:#770088"&gt;break&lt;/span&gt;;
       &lt;span style="color:#770088"&gt;case&lt;/span&gt; &lt;span style="color:#aa1111"&gt;'admin'&lt;/span&gt;:
         &lt;span style="color:#770088"&gt;return&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;User&lt;/span&gt;({ &lt;span style="color:#000000"&gt;name&lt;/span&gt;: &lt;span style="color:#aa1111"&gt;'管理员'&lt;/span&gt;, &lt;span style="color:#000000"&gt;viewPage&lt;/span&gt;: [&lt;span style="color:#aa1111"&gt;'首页'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'通讯录'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'发现页'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'应用数据'&lt;/span&gt;] });
         &lt;span style="color:#770088"&gt;break&lt;/span&gt;;
       &lt;span style="color:#770088"&gt;case&lt;/span&gt; &lt;span style="color:#aa1111"&gt;'user'&lt;/span&gt;:
         &lt;span style="color:#770088"&gt;return&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;User&lt;/span&gt;({ &lt;span style="color:#000000"&gt;name&lt;/span&gt;: &lt;span style="color:#aa1111"&gt;'普通用户'&lt;/span&gt;, &lt;span style="color:#000000"&gt;viewPage&lt;/span&gt;: [&lt;span style="color:#aa1111"&gt;'首页'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'通讯录'&lt;/span&gt;, &lt;span style="color:#aa1111"&gt;'发现页'&lt;/span&gt;] });
         &lt;span style="color:#770088"&gt;break&lt;/span&gt;;
       &lt;span style="color:#770088"&gt;default&lt;/span&gt;:
         &lt;span style="color:#770088"&gt;throw&lt;/span&gt; &lt;span style="color:#770088"&gt;new&lt;/span&gt; &lt;span style="color:#000000"&gt;Error&lt;/span&gt;(&lt;span style="color:#aa1111"&gt;'参数错误, 可选参数:superAdmin、admin、user'&lt;/span&gt;)
     }
   }
 }&lt;/span&gt;</code></pre> <p></p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">状态模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>行为基于它的状态改变而改变。属于行为型模式</p> </li><li> <p>在状态模式中，我们创建表示<span style="color:#8600ff;">各种状态</span>的对象和一个<span style="color:#8600ff;">行为随着状态改变</span>而<span style="color:#8600ff;">改变的context对象</span></p> </li><li> <p>每个阶段的状态都是固定好的</p> </li></ul> 
<p><strong><span style="color:#333333;">理解与应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>实现<span style="color:#8600ff;">tab切换</span>时，我们用 <code>curActive</code> 来标识当前状态，封装好的组件就是一个“context”，这就是一种状态模式的应用</p> </li><li> <p>实现<span style="color:#8600ff;">状态进度条</span>时，也是状态模式的一种应用</p> </li></ul> 
<p><strong><span style="color:#333333;">完善的状态模式</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>真正完善的状态模式，还需要提供<span style="color:#ea7500;">状态随意切换的功能</span>，提供各种<span style="color:#ea7500;">切换状态方式</span>（好比浏览器的前进后退）。</p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">策略模式</span></strong></h4> 
<p style="margin-left:.8em;"><span style="color:#333333;">扩展性极强</span></p> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>一个类的行为或其算法，可以在运行时更改。属于行为型模式</p> </li><li> <p>在策略模式中，我们创建<span style="color:#8600ff;"><strong>表示各种策略的对象</strong></span>和一个<span style="color:#8600ff;"><strong>行为随着策略对象改变而改变的 context 对象</strong></span>。策略对象改变 context 对象的执行算法</p> </li></ul> 
<p><strong><span style="color:#333333;">理解与应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>状态模式和策略模式很相似，但是策略模式的内部处理可以是外部使用时再决定如何处理，状态模式都是已经准备好的。</p> 
  <ul style="margin-left:0;"><li> <p>状态模式：程序运行过程中不同状态之间可以随意转换</p> </li><li> <p>策略模式：选择一种策略执行一次</p> </li></ul></li><li> <p>策略模式说简单一点，就是要对一些事情做处理，但是 <span style="color:#8600ff;"><strong>处理方式</strong></span> &lt;--- 由使用策略时<span style="color:#8600ff;">选择的策略</span>决定。也就是，实现不同东西，使用不同策略</p> </li><li> <p>在组件封装层面：</p> <p>封装全局提示框时：</p> <p>可以先封装3种效果及功能的"策略"，然后给外界提供一个 "context"组件，context负责组织和<strong>按需调用</strong>我们的策略代码。</p> <p>也就是，我们的提示框内容，以及提示框按钮的功能都要封装成：<span style="color:#ea0000;">使用时</span>传递这些<strong>内容和功能</strong></p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">模板模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>定义一个操作中的算法的<strong><span style="color:#8600ff;">骨架</span></strong>，但是将一些步骤<span style="color:#ea7500;">延迟</span>到子类中，模板方法使得子类可以不改变一个算法的结构即可<strong><span style="color:#8600ff;">重定义该算法的某些特定步骤</span></strong>。</p> </li></ul> 
<p><strong><span style="color:#333333;">理解与应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p><span style="color:#ea0000;"><strong>封装不变的部分，扩展可变的部分</strong></span></p> </li><li> <p>例如我们渲染列表时，都要经过获取数据、显示正在加载、获取到数据后就渲染列表、是否没有更多数据的状态，这些固定的部分就可以封装成一个骨架，我们每次渲染列表时，都用这个骨架，及不必每次都声明一个 <code>data、loading、noMore</code>等等变量来每次实现一遍这种固定套路。</p> </li><li> <p>其实 <code>vue</code>、<code>react</code> 宏观上就是模板模式，各种响应式，各种依赖，简化我们从Model层到View层要做的很多事情</p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">享元模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>主要用于减少创建对象的数量，以<span style="color:#8600ff;">减少内存占用</span>和<span style="color:#8600ff;">提高性能</span>。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p> </li><li> <p>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p> </li></ul> 
<p><strong><span style="color:#333333;">理解应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p> </li><li> <p>数据库的数据池。</p> </li><li> <p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">观察者模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p> </li><li> <p>一个对象<span style="color:#8600ff;">状态改变</span>给其他对象<span style="color:#8600ff;">通知</span>的问题，而且要考虑到<span style="color:#8600ff;">易用和低耦合</span>，保证<span style="color:#8600ff;">高度的协作</span>。</p> </li></ul> 
<p><strong><span style="color:#333333;">理解应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p><code>redux</code> 其实就是一种观察者模式，有发布、订阅等等</p> </li><li> <p><code>vue2</code> 的源码中其实就应用了观察者模式，收集依赖，同时在这些依赖的角度，就是在订阅这个数据，当数据变化时，观察者 触发视图更新。</p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">适配器模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它<strong><span style="color:#ea0000;">结合了两个独立接口的功能</span></strong>。</p> </li></ul> 
<p><strong><span style="color:#333333;">理解应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>将一个已有的类的接口，转化成客户希望的另外一个接口（方法或属性），让原本由于接口不兼容而不能一起工作的那些类可以正常协作，简单理解就是为了兼容而生的“转换器”</p> </li><li> <p>逻辑代码封装层面：</p> <p>当我们为我们的项目封装 请求接口 <code>request[type](url, data, config)</code> 方法时，其实就可以应用适配器模式</p> <p>因为在使用 get 请求时，我们要传的是 params</p> <p>而在使用 post 请求时，我们要传的是 data</p> <p>但是我们为了使用时方便简洁，我们在封装时，request 的<span style="color:#8600ff;">第二个参数 <code>data</code></span> 就要采用适配器思想，不管是要传 <strong><code>params</code></strong> 还是 <strong><code>data</code></strong> 都 从第二个参数传对象即可。</p> <p>之后，原本是一个get请求格式，一个post请求格式，就很好的<strong><span style="color:#ea0000;">兼容</span></strong>为一个 request 请求格式</p> </li><li> <p>提高了我们封装出的功能的<strong><span style="color:#8600ff;">灵活性</span></strong></p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">装饰者模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>装饰模式指的是在不必改变原类文件和使用继承的情况下，<span style="color:#ea0000;">动态地扩展一个对象的功能</span>。它是通过创建一个包装对象，也就是装饰，来包裹真实的对象</p> </li><li> <p>装饰类和被装饰类可以<span style="color:#ea0000;">独立发展</span>，<span style="color:#ea0000;">不会相互耦合</span>，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能</p> </li><li> <p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p> </li></ul> 
<p><strong><span style="color:#333333;">理解与应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>TS下就有装饰器</p> </li><li> <p>在Java中，可以用来降低子类的膨胀</p> </li><li> <p>封装组件层面：</p> <p>我们在使用某些组件时，当前这个组件的功能不能满足我们的需求，例如 input，我们很多input都需要带有校验功能</p> <p>这时，我们就可以封装一个装饰器思想的组件，这个组件给传入的Input提供校验功能，antDesign、elementUI等 校验表单就提供了类似的<strong><span style="color:#8600ff;">包裹性组件</span></strong></p> <pre class="has" style="text-align:left;"><code class="language-md-end-block">&lt;span style="background-color:#f8f8f8"&gt; &lt;span style="color:#117700"&gt;&lt;&lt;/span&gt;&lt;span style="color:#117700"&gt;valid-input&lt;/span&gt; &lt;span style="color:#0000cc"&gt;field&lt;/span&gt;=&lt;span style="color:#aa1111"&gt;"username"&lt;/span&gt; &lt;span style="color:#0000cc"&gt;options&lt;/span&gt;=&lt;span style="color:#aa1111"&gt;"[{ rule: required, message: '用户名必须' }]"&lt;/span&gt;&lt;span style="color:#117700"&gt;&gt;&lt;/span&gt;
   &lt;span style="color:#117700"&gt;&lt;&lt;/span&gt;&lt;span style="color:#117700"&gt;input&lt;/span&gt; &lt;span style="color:#0000cc"&gt;v-model&lt;/span&gt;=&lt;span style="color:#aa1111"&gt;"username"&lt;/span&gt; &lt;span style="color:#0000cc"&gt;type&lt;/span&gt;=&lt;span style="color:#aa1111"&gt;"text"&lt;/span&gt; &lt;span style="color:#117700"&gt;/&gt;&lt;/span&gt;
 &lt;span style="color:#117700"&gt;&lt;/&lt;/span&gt;&lt;span style="color:#117700"&gt;valid-input&lt;/span&gt;&lt;span style="color:#117700"&gt;&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> <p>还有，我有次在封装一个弹窗框时，其实也涉及这个思想，就是<strong>弹窗的性质</strong>就像一种装饰器，我们想弹窗显示某个组件，就使用这个弹窗组件<span style="color:#8600ff;"><strong>包裹装饰</strong></span>（再结合上<strong>外观模式</strong>，我们把弹窗相关的功能都封装到这个组件中，易于使用）</p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<p style="margin-left:.8em;"></p> 
<h4><strong><span style="color:#333333;">代理模式</span></strong></h4> 
<p><strong><span style="color:#333333;">概念：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p> </li><li> <p>为其他对象提供一种代理以控制对这个对象的访问</p> </li><li> <p>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</p> </li><li> <p>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p> </li></ul> 
<p><strong><span style="color:#333333;">理解与应用：</span></strong></p> 
<ul style="margin-left:.8em;"><li> <p><code>Vue3</code> 用到的 <code>proxy</code></p> </li><li> <p>想在访问一些内容时做一些控制，就考虑用代理模式</p> </li><li> <p>可以用来避免已有代码的过度封装，保证代码职责清晰</p> </li></ul> 
<p style="margin-left:.8em;"></p> 
<h3><strong><span style="color:#333333;">参考文档：</span></strong></h3> 
<p style="margin-left:.8em;"><span style="color:#333333;"><a href="https://www.runoob.com/design-pattern/state-pattern.html" rel="nofollow" title="菜鸟-各种模式的介绍都有">菜鸟-各种模式的介绍都有</a></span></p> 
<p style="margin-left:.8em;"><span style="color:#333333;"><a href="https://juejin.cn/post/6844903768333500429" rel="nofollow" title="掘金文章">掘金文章</a></span></p> 
<p style="margin-left:.8em;"><span style="color:#333333;"><a href="https://juejin.cn/post/6844903789019807757" rel="nofollow" title="掘金文章">掘金文章</a></span></p> 
<h4></h4>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96baebefcb4b2d89eeadb4c0bf5c1f13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决：java -version,java,javac不是内部或外部命令，也不是可运行的程序 或批处理文件。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9d9b2c3a50f5133ffc1457d105f752a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flutter简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>