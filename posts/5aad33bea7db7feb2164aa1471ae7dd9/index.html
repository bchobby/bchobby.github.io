<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于神经网络的意图识别 - 基础版 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于神经网络的意图识别 - 基础版" />
<meta property="og:description" content="Github: https://github.com/yjfiejd/Text_Classification_NN/blob/master/text_classification_6.28.py # -*- coding:utf8 -*- # @TIME : 2018/6/28 下午10:34 # @Author : Allen # @File : text_classification_6.28.py import nltk from nltk.stem.lancaster import LancasterStemmer import os import json import datetime stemmer = LancasterStemmer() #3种意图 training_data = [] training_data.append({&#34;class&#34;:&#34;greeting&#34;, &#34;sentence&#34;:&#34;how are you?&#34;}) training_data.append({&#34;class&#34;:&#34;greeting&#34;, &#34;sentence&#34;:&#34;how is your day&#34;}) training_data.append({&#34;class&#34;:&#34;greeting&#34;, &#34;sentence&#34;:&#34;good day&#34;}) training_data.append({&#34;class&#34;:&#34;greeting&#34;, &#34;sentence&#34;:&#34;how is it going today?&#34;}) training_data.append({&#34;class&#34;:&#34;goodbye&#34;, &#34;sentence&#34;:&#34;have a nice day&#34;}) training_data.append({&#34;class&#34;:&#34;goodbye&#34;, &#34;sentence&#34;:&#34;see you later&#34;}) training_data.append({&#34;class&#34;:&#34;goodbye&#34;, &#34;sentence&#34;:&#34;have a nice day&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/5aad33bea7db7feb2164aa1471ae7dd9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-29T08:51:21+08:00" />
<meta property="article:modified_time" content="2018-06-29T08:51:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于神经网络的意图识别 - 基础版</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre style="background-color:rgb(255,255,255);font-family:Menlo;font-size:9pt;">Github: <a href="https://github.com/yjfiejd/Text_Classification_NN/blob/master/text_classification_6.28.py">https://github.com/yjfiejd/Text_Classification_NN/blob/master/text_classification_6.28.py</a>
</pre> 
<pre style="background-color:rgb(255,255,255);font-family:Menlo;font-size:9pt;"><span style="color:rgb(128,128,128);"><em># -*- coding:utf8 -*-
</em></span><span style="color:rgb(128,128,128);"><em># @TIME : 2018/6/28 下午10:34
</em></span><span style="color:rgb(128,128,128);"><em># @Author : Allen
</em></span><span style="color:rgb(128,128,128);"><em># @File : text_classification_6.28.py
</em></span><span style="color:rgb(128,128,128);"><em>
</em></span><span style="color:rgb(0,0,128);"><strong>import </strong></span>nltk
<span style="color:rgb(0,0,128);"><strong>from </strong></span>nltk.stem.lancaster <span style="color:rgb(0,0,128);"><strong>import </strong></span>LancasterStemmer
<span style="color:rgb(0,0,128);"><strong>import </strong></span>os
<span style="color:rgb(0,0,128);"><strong>import </strong></span>json
<span style="color:rgb(0,0,128);"><strong>import </strong></span>datetime
stemmer = LancasterStemmer()

<span style="color:rgb(128,128,128);"><em>#3种意图
</em></span>training_data = []
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"greeting"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"how are you?"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"greeting"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"how is your day"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"greeting"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"good day"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"greeting"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"how is it going today?"</strong></span>})

training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"goodbye"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"have a nice day"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"goodbye"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"see you later"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"goodbye"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"have a nice day"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"goodbye"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"talk to you soon"</strong></span>})

training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"sandwich"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"make me a sandwich"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"sandwich"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"can you make a sandwich"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"sandwich"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"having a sandwich today"</strong></span>})
training_data.append({<!-- --><span style="color:rgb(0,128,128);"><strong>"class"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"sandwich"</strong></span>, <span style="color:rgb(0,128,128);"><strong>"sentence"</strong></span>:<span style="color:rgb(0,128,128);"><strong>"what's for lunch?"</strong></span>})

<span style="color:rgb(128,128,128);"><em>#预处理
</em></span>words = []
classes = []
documents = []
ignore_words = [<span style="color:rgb(0,128,128);"><strong>'?'</strong></span>]

<span style="color:rgb(0,0,128);"><strong>for </strong></span>pattern <span style="color:rgb(0,0,128);"><strong>in </strong></span>training_data:
    w = nltk.word_tokenize(pattern[<span style="color:rgb(0,128,128);"><strong>'sentence'</strong></span>])
    words.extend(w)
    documents.append((w, pattern[<span style="color:rgb(0,128,128);"><strong>'class'</strong></span>]))
    <span style="color:rgb(0,0,128);"><strong>if </strong></span>pattern[<span style="color:rgb(0,128,128);"><strong>'class'</strong></span>] <span style="color:rgb(0,0,128);"><strong>not in </strong></span>classes:
        classes.append(pattern[<span style="color:rgb(0,128,128);"><strong>'class'</strong></span>])

words = [stemmer.stem(w.lower()) <span style="color:rgb(0,0,128);"><strong>for </strong></span>w <span style="color:rgb(0,0,128);"><strong>in </strong></span>words <span style="color:rgb(0,0,128);"><strong>if </strong></span>w <span style="color:rgb(0,0,128);"><strong>not in </strong></span>ignore_words]
words = <span style="color:rgb(0,0,128);">list</span>(<span style="color:rgb(0,0,128);">set</span>(words))
classes = <span style="color:rgb(0,0,128);">list</span>(<span style="color:rgb(0,0,128);">set</span>(classes))

<span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,0,128);">len</span>(documents), <span style="color:rgb(0,128,128);"><strong>"documents"</strong></span>)
<span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,0,128);">len</span>(classes), <span style="color:rgb(0,128,128);"><strong>"classes"</strong></span>, classes)
<span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,0,128);">len</span>(words), <span style="color:rgb(0,128,128);"><strong>"unique stemmed words"</strong></span>, words)
<span style="color:rgb(0,0,128);">print</span>(<span style="color:rgb(0,128,128);"><strong>"************"</strong></span>)
<span style="color:rgb(0,0,128);">print</span>(documents)
<span style="color:rgb(0,0,128);">print</span>(classes)
<span style="color:rgb(0,0,128);">print</span>(words)
<span style="color:rgb(0,0,128);">print</span>(<span style="color:rgb(0,128,128);"><strong>"************"</strong></span>)

<span style="color:rgb(128,128,128);"><em>#bag of word
</em></span>training = []
output = []
output_empty = [<span style="color:rgb(0,0,255);">0</span>] * <span style="color:rgb(0,0,128);">len</span>(classes)

<span style="color:rgb(0,0,128);"><strong>for </strong></span>doc <span style="color:rgb(0,0,128);"><strong>in </strong></span>documents:
    bag = []
    pattern_words = doc[<span style="color:rgb(0,0,255);">0</span>]
    pattern_words = [stemmer.stem(word.lower()) <span style="color:rgb(0,0,128);"><strong>for </strong></span>word <span style="color:rgb(0,0,128);"><strong>in </strong></span>pattern_words]
    <span style="color:rgb(0,0,128);"><strong>for </strong></span>w <span style="color:rgb(0,0,128);"><strong>in </strong></span>words:
        bag.append(<span style="color:rgb(0,0,255);">1</span>) <span style="color:rgb(0,0,128);"><strong>if </strong></span>w <span style="color:rgb(0,0,128);"><strong>in </strong></span>pattern_words <span style="color:rgb(0,0,128);"><strong>else </strong></span>bag.append(<span style="color:rgb(0,0,255);">0</span>)

    training.append(bag)
    output_row = <span style="color:rgb(0,0,128);">list</span>(output_empty)
    output_row[classes.index(doc[<span style="color:rgb(0,0,255);">1</span>])] = <span style="color:rgb(0,0,255);">1
</span><span style="color:rgb(0,0,255);">    </span>output.append(output_row)

i = <span style="color:rgb(0,0,255);">0
</span>w = documents[i][<span style="color:rgb(0,0,255);">0</span>]
<span style="color:rgb(0,0,128);">print</span>(w)
<span style="color:rgb(0,0,128);">print</span>([stemmer.stem(word.lower()) <span style="color:rgb(0,0,128);"><strong>for </strong></span>word <span style="color:rgb(0,0,128);"><strong>in </strong></span>w])
<span style="color:rgb(0,0,128);">print</span>(training[i])
<span style="color:rgb(0,0,128);">print</span>(output[i])
<span style="color:rgb(0,0,128);">print</span>(<span style="color:rgb(0,128,128);"><strong>"******下面的代码，实现了词袋处理并将输入句子转换为0、1数组******"</strong></span>)

<span style="color:rgb(128,128,128);"><em>#使用sigmiod作为激活函数, 不断的调整参数，直到错误率降低到可以接受
</em></span><span style="color:rgb(0,0,128);"><strong>import </strong></span>numpy <span style="color:rgb(0,0,128);"><strong>as </strong></span>np
<span style="color:rgb(0,0,128);"><strong>import </strong></span>time

<span style="color:rgb(0,0,128);"><strong>def </strong></span>sigmoid(x):
    output = <span style="color:rgb(0,0,255);">1</span>/(<span style="color:rgb(0,0,255);">1 </span>+ np.exp(-x))
    <span style="color:rgb(0,0,128);"><strong>return </strong></span>output

<span style="color:rgb(0,0,128);"><strong>def </strong></span>sigmoid_output_to_derivative(output):
    <span style="color:rgb(0,0,128);"><strong>return </strong></span>output*(<span style="color:rgb(0,0,255);">1</span>-output)

<span style="color:rgb(0,0,128);"><strong>def </strong></span>clean_up_sentence(sentence):
    sentence_words = nltk.word_tokenize(sentence)
    sentence_words = [stemmer.stem(word.lower()) <span style="color:rgb(0,0,128);"><strong>for </strong></span>word <span style="color:rgb(0,0,128);"><strong>in </strong></span>sentence_words]
    <span style="color:rgb(0,0,128);"><strong>return </strong></span>sentence_words

<span style="color:rgb(0,0,128);"><strong>def </strong></span>bow(sentence, words, show_details=<span style="color:rgb(0,0,128);"><strong>False</strong></span>):
    sentence_words = clean_up_sentence(sentence)
    bag = [<span style="color:rgb(0,0,255);">0</span>] * <span style="color:rgb(0,0,128);">len</span>(words)
    <span style="color:rgb(0,0,128);"><strong>for </strong></span>s <span style="color:rgb(0,0,128);"><strong>in </strong></span>sentence_words:
        <span style="color:rgb(0,0,128);"><strong>for </strong></span>i,w <span style="color:rgb(0,0,128);"><strong>in </strong></span><span style="color:rgb(0,0,128);">enumerate</span>(words):
            <span style="color:rgb(0,0,128);"><strong>if </strong></span>w == s:
                bag[i] = <span style="color:rgb(0,0,255);">1
</span><span style="color:rgb(0,0,255);">                </span><span style="color:rgb(0,0,128);"><strong>if </strong></span>show_details:
                    <span style="color:rgb(0,0,128);">print</span>(<span style="color:rgb(0,128,128);"><strong>"found in bag: %s" </strong></span>% w)
    <span style="color:rgb(0,0,128);"><strong>return </strong></span>(np.array(bag))

<span style="color:rgb(0,0,128);"><strong>def </strong></span>think(sentence, show_details=<span style="color:rgb(0,0,128);"><strong>False</strong></span>):
    x = bow(sentence.lower(), words, show_details)
    <span style="color:rgb(0,0,128);"><strong>if </strong></span>show_details:
        <span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,128,128);"><strong>"sentence:"</strong></span>, sentence, <span style="color:rgb(0,128,128);"><strong>"</strong></span><span style="color:rgb(0,0,128);"><strong>\n</strong></span><span style="color:rgb(0,128,128);"><strong> bow:"</strong></span>, x)
    <span style="color:rgb(128,128,128);"><em># input layer is our bag of words
</em></span><span style="color:rgb(128,128,128);"><em>    </em></span>l0 = x
    <span style="color:rgb(128,128,128);"><em># matrix multiplication of input and hidden layer
</em></span><span style="color:rgb(128,128,128);"><em>    </em></span>l1 = sigmoid(np.dot(l0, synapse_0))
    <span style="color:rgb(128,128,128);"><em># output layer
</em></span><span style="color:rgb(128,128,128);"><em>    </em></span>l2 = sigmoid(np.dot(l1, synapse_1))
    <span style="color:rgb(0,0,128);"><strong>return </strong></span>l2

<span style="color:rgb(0,0,128);">print</span>(<span style="color:rgb(0,128,128);"><strong>"******实现神经网络的训练函数来调整突触的权重******"</strong></span>)

<span style="color:rgb(0,0,128);"><strong>def </strong></span>train(X, y, hidden_neurons=<span style="color:rgb(0,0,255);">10</span>, alpha=<span style="color:rgb(0,0,255);">1</span>, epochs=<span style="color:rgb(0,0,255);">50000</span>, dropout=<span style="color:rgb(0,0,128);"><strong>False</strong></span>, dropout_percent=<span style="color:rgb(0,0,255);">0.5</span>):

    <span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,128,128);"><strong>"Training with %s neurons, alpha:%s, dropout:%s %s" </strong></span>% (hidden_neurons, <span style="color:rgb(0,0,128);">str</span>(alpha), dropout, dropout_percent <span style="color:rgb(0,0,128);"><strong>if </strong></span>dropout <span style="color:rgb(0,0,128);"><strong>else </strong></span><span style="color:rgb(0,128,128);"><strong>''</strong></span>) )
    <span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,128,128);"><strong>"Input matrix: %sx%s    Output matrix: %sx%s" </strong></span>% (<span style="color:rgb(0,0,128);">len</span>(X),<span style="color:rgb(0,0,128);">len</span>(X[<span style="color:rgb(0,0,255);">0</span>]),<span style="color:rgb(0,0,255);">1</span>, <span style="color:rgb(0,0,128);">len</span>(classes)) )
    np.random.seed(<span style="color:rgb(0,0,255);">1</span>)

    last_mean_error = <span style="color:rgb(0,0,255);">1
</span><span style="color:rgb(0,0,255);">    </span><span style="color:rgb(128,128,128);"><em># randomly initialize our weights with mean 0
</em></span><span style="color:rgb(128,128,128);"><em>    </em></span>synapse_0 = <span style="color:rgb(0,0,255);">2</span>*np.random.random((<span style="color:rgb(0,0,128);">len</span>(X[<span style="color:rgb(0,0,255);">0</span>]), hidden_neurons)) - <span style="color:rgb(0,0,255);">1
</span><span style="color:rgb(0,0,255);">    </span>synapse_1 = <span style="color:rgb(0,0,255);">2</span>*np.random.random((hidden_neurons, <span style="color:rgb(0,0,128);">len</span>(classes))) - <span style="color:rgb(0,0,255);">1
</span><span style="color:rgb(0,0,255);">
</span><span style="color:rgb(0,0,255);">    </span>prev_synapse_0_weight_update = np.zeros_like(synapse_0)
    prev_synapse_1_weight_update = np.zeros_like(synapse_1)

    synapse_0_direction_count = np.zeros_like(synapse_0)
    synapse_1_direction_count = np.zeros_like(synapse_1)

    <span style="color:rgb(0,0,128);"><strong>for </strong></span>j <span style="color:rgb(0,0,128);"><strong>in </strong></span><span style="color:rgb(0,0,128);">iter</span>(<span style="color:rgb(0,0,128);">range</span>(epochs+<span style="color:rgb(0,0,255);">1</span>)):

        <span style="color:rgb(128,128,128);"><em># Feed forward through layers 0, 1, and 2
</em></span><span style="color:rgb(128,128,128);"><em>        </em></span>layer_0 = X
        layer_1 = sigmoid(np.dot(layer_0, synapse_0))

        <span style="color:rgb(0,0,128);"><strong>if</strong></span>(dropout):
            layer_1 *= np.random.binomial([np.ones((<span style="color:rgb(0,0,128);">len</span>(X),hidden_neurons))],<span style="color:rgb(0,0,255);">1</span>-dropout_percent)[<span style="color:rgb(0,0,255);">0</span>] * (<span style="color:rgb(0,0,255);">1.0</span>/(<span style="color:rgb(0,0,255);">1</span>-dropout_percent))

        layer_2 = sigmoid(np.dot(layer_1, synapse_1))

        <span style="color:rgb(128,128,128);"><em># how much did we miss the target value?
</em></span><span style="color:rgb(128,128,128);"><em>        </em></span>layer_2_error = y - layer_2

        <span style="color:rgb(0,0,128);"><strong>if </strong></span>(j% <span style="color:rgb(0,0,255);">10000</span>) == <span style="color:rgb(0,0,255);">0 </span><span style="color:rgb(0,0,128);"><strong>and </strong></span>j &gt; <span style="color:rgb(0,0,255);">5000</span>:
            <span style="color:rgb(128,128,128);"><em># if this 10k iteration's error is greater than the last iteration, break out
</em></span><span style="color:rgb(128,128,128);"><em>            </em></span><span style="color:rgb(0,0,128);"><strong>if </strong></span>np.mean(np.abs(layer_2_error)) &lt; last_mean_error:
                <span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,128,128);"><strong>"delta after "</strong></span>+<span style="color:rgb(0,0,128);">str</span>(j)+<span style="color:rgb(0,128,128);"><strong>" iterations:" </strong></span>+ <span style="color:rgb(0,0,128);">str</span>(np.mean(np.abs(layer_2_error))) )
                last_mean_error = np.mean(np.abs(layer_2_error))
            <span style="color:rgb(0,0,128);"><strong>else</strong></span>:
                <span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,128,128);"><strong>"break:"</strong></span>, np.mean(np.abs(layer_2_error)), <span style="color:rgb(0,128,128);"><strong>"&gt;"</strong></span>, last_mean_error )
                <span style="color:rgb(0,0,128);"><strong>break
</strong></span><span style="color:rgb(0,0,128);"><strong>
</strong></span><span style="color:rgb(0,0,128);"><strong>        </strong></span><span style="color:rgb(128,128,128);"><em># in what direction is the target value?
</em></span><span style="color:rgb(128,128,128);"><em>        # were we really sure? if so, don't change too much.
</em></span><span style="color:rgb(128,128,128);"><em>        </em></span>layer_2_delta = layer_2_error * sigmoid_output_to_derivative(layer_2)

        <span style="color:rgb(128,128,128);"><em># how much did each l1 value contribute to the l2 error (according to the weights)?
</em></span><span style="color:rgb(128,128,128);"><em>        </em></span>layer_1_error = layer_2_delta.dot(synapse_1.T)

        <span style="color:rgb(128,128,128);"><em># in what direction is the target l1?
</em></span><span style="color:rgb(128,128,128);"><em>        # were we really sure? if so, don't change too much.
</em></span><span style="color:rgb(128,128,128);"><em>        </em></span>layer_1_delta = layer_1_error * sigmoid_output_to_derivative(layer_1)

        synapse_1_weight_update = (layer_1.T.dot(layer_2_delta))
        synapse_0_weight_update = (layer_0.T.dot(layer_1_delta))

        <span style="color:rgb(0,0,128);"><strong>if</strong></span>(j &gt; <span style="color:rgb(0,0,255);">0</span>):
            synapse_0_direction_count += np.abs(((synapse_0_weight_update &gt; <span style="color:rgb(0,0,255);">0</span>)+<span style="color:rgb(0,0,255);">0</span>) - ((prev_synapse_0_weight_update &gt; <span style="color:rgb(0,0,255);">0</span>) + <span style="color:rgb(0,0,255);">0</span>))
            synapse_1_direction_count += np.abs(((synapse_1_weight_update &gt; <span style="color:rgb(0,0,255);">0</span>)+<span style="color:rgb(0,0,255);">0</span>) - ((prev_synapse_1_weight_update &gt; <span style="color:rgb(0,0,255);">0</span>) + <span style="color:rgb(0,0,255);">0</span>))

        synapse_1 += alpha * synapse_1_weight_update
        synapse_0 += alpha * synapse_0_weight_update

        prev_synapse_0_weight_update = synapse_0_weight_update
        prev_synapse_1_weight_update = synapse_1_weight_update

    now = datetime.datetime.now()

    <span style="color:rgb(128,128,128);"><em># persist synapses
</em></span><span style="color:rgb(128,128,128);"><em>    </em></span>synapse = {<!-- --><span style="color:rgb(0,128,128);"><strong>'synapse0'</strong></span>: synapse_0.tolist(), <span style="color:rgb(0,128,128);"><strong>'synapse1'</strong></span>: synapse_1.tolist(),
               <span style="color:rgb(0,128,128);"><strong>'datetime'</strong></span>: now.strftime(<span style="color:rgb(0,128,128);"><strong>"%Y-%m-%d %H:%M"</strong></span>),
               <span style="color:rgb(0,128,128);"><strong>'words'</strong></span>: words,
               <span style="color:rgb(0,128,128);"><strong>'classes'</strong></span>: classes
              }
    synapse_file = <span style="color:rgb(0,128,128);"><strong>"synapses.json"
</strong></span><span style="color:rgb(0,128,128);"><strong>
</strong></span><span style="color:rgb(0,128,128);"><strong>    </strong></span><span style="color:rgb(0,0,128);"><strong>with </strong></span><span style="color:rgb(0,0,128);">open</span>(synapse_file, <span style="color:rgb(0,128,128);"><strong>'w'</strong></span>) <span style="color:rgb(0,0,128);"><strong>as </strong></span>outfile:
        json.dump(synapse, outfile, <span style="color:rgb(102,0,153);">indent</span>=<span style="color:rgb(0,0,255);">4</span>, <span style="color:rgb(102,0,153);">sort_keys</span>=<span style="color:rgb(0,0,128);"><strong>True</strong></span>)
<span style="color:rgb(128,128,128);"><em># print ("saved synapses to:", synapse_file)
</em></span><span style="color:rgb(128,128,128);"><em>
</em></span><span style="color:rgb(0,0,128);">print</span>(<span style="color:rgb(0,128,128);"><strong>"******隐层中只使用了20个神经元，因此比较容易进行调节******"</strong></span>)

X = np.array(training)
y = np.array(output)

start_time = time.time()

train(X, y, <span style="color:rgb(102,0,153);">hidden_neurons</span>=<span style="color:rgb(0,0,255);">20</span>, <span style="color:rgb(102,0,153);">alpha</span>=<span style="color:rgb(0,0,255);">0.1</span>, <span style="color:rgb(102,0,153);">epochs</span>=<span style="color:rgb(0,0,255);">100000</span>, <span style="color:rgb(102,0,153);">dropout</span>=<span style="color:rgb(0,0,128);"><strong>False</strong></span>, <span style="color:rgb(102,0,153);">dropout_percent</span>=<span style="color:rgb(0,0,255);">0.2</span>)

elapsed_time = time.time() - start_time
<span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,128,128);"><strong>"processing time:"</strong></span>, elapsed_time, <span style="color:rgb(0,128,128);"><strong>"seconds"</strong></span>)

<span style="color:rgb(0,0,128);">print</span>(<span style="color:rgb(0,128,128);"><strong>"******预测一个句子属于某个分类的概率******"</strong></span>)
<span style="color:rgb(128,128,128);"><em># probability threshold
</em></span>ERROR_THRESHOLD = <span style="color:rgb(0,0,255);">0.2
</span><span style="color:rgb(128,128,128);"><em># load our calculated synapse values
</em></span>synapse_file = <span style="color:rgb(0,128,128);"><strong>'synapses.json'
</strong></span><span style="color:rgb(0,0,128);"><strong>with </strong></span><span style="color:rgb(0,0,128);">open</span>(synapse_file) <span style="color:rgb(0,0,128);"><strong>as </strong></span>data_file:
    synapse = json.load(data_file)
    synapse_0 = np.asarray(synapse[<span style="color:rgb(0,128,128);"><strong>'synapse0'</strong></span>])
    synapse_1 = np.asarray(synapse[<span style="color:rgb(0,128,128);"><strong>'synapse1'</strong></span>])

<span style="color:rgb(0,0,128);"><strong>def </strong></span>classify(sentence, show_details=<span style="color:rgb(0,0,128);"><strong>False</strong></span>):
    results = think(sentence, show_details)

    results = [[i,r] <span style="color:rgb(0,0,128);"><strong>for </strong></span>i,r <span style="color:rgb(0,0,128);"><strong>in </strong></span><span style="color:rgb(0,0,128);">enumerate</span>(results) <span style="color:rgb(0,0,128);"><strong>if </strong></span>r&gt;ERROR_THRESHOLD ]
    results.sort(<span style="color:rgb(102,0,153);">key</span>=<span style="color:rgb(0,0,128);"><strong>lambda </strong></span>x: x[<span style="color:rgb(0,0,255);">1</span>], <span style="color:rgb(102,0,153);">reverse</span>=<span style="color:rgb(0,0,128);"><strong>True</strong></span>)
    return_results =[[classes[r[<span style="color:rgb(0,0,255);">0</span>]],r[<span style="color:rgb(0,0,255);">1</span>]] <span style="color:rgb(0,0,128);"><strong>for </strong></span>r <span style="color:rgb(0,0,128);"><strong>in </strong></span>results]
    <span style="color:rgb(0,0,128);">print </span>(<span style="color:rgb(0,128,128);"><strong>"%s </strong></span><span style="color:rgb(0,0,128);"><strong>\n</strong></span><span style="color:rgb(0,128,128);"><strong> classification: %s" </strong></span>% (sentence, return_results))
    <span style="color:rgb(0,0,128);"><strong>return </strong></span>return_results

classify(<span style="color:rgb(0,128,128);"><strong>"sudo make me a sandwich"</strong></span>)
classify(<span style="color:rgb(0,128,128);"><strong>"how are you today?"</strong></span>)
classify(<span style="color:rgb(0,128,128);"><strong>"talk to you tomorrow"</strong></span>)
classify(<span style="color:rgb(0,128,128);"><strong>"who are you?"</strong></span>)
classify(<span style="color:rgb(0,128,128);"><strong>"make me some lunch"</strong></span>)
classify(<span style="color:rgb(0,128,128);"><strong>"how was your lunch today?"</strong></span>)
<span style="color:rgb(0,0,128);">print</span>()
classify(<span style="color:rgb(0,128,128);"><strong>"good day"</strong></span>, <span style="color:rgb(102,0,153);">show_details</span>=<span style="color:rgb(0,0,128);"><strong>True</strong></span>)


<span style="color:rgb(128,128,128);"><em>#运行的结果
</em></span><span style="color:rgb(128,128,128);"><em># 12 documents
</em></span><span style="color:rgb(128,128,128);"><em># 3 classes ['greeting', 'sandwich', 'goodbye']
</em></span><span style="color:rgb(128,128,128);"><em># 26 unique stemmed words ['me', 'can', 'lunch', 'soon', 'good', 'to', 'for', 'see', 'a', 'is', 'what', 'day', "'s", 'going', 'ar', 'lat', 'today', 'it', 'hav', 'you', 'talk', 'yo', 'nic', 'sandwich', 'mak', 'how']
</em></span><span style="color:rgb(128,128,128);"><em># ************
</em></span><span style="color:rgb(128,128,128);"><em># [(['how', 'are', 'you', '?'], 'greeting'), (['how', 'is', 'your', 'day'], 'greeting'), (['good', 'day'], 'greeting'), (['how', 'is', 'it', 'going', 'today', '?'], 'greeting'), (['have', 'a', 'nice', 'day'], 'goodbye'), (['see', 'you', 'later'], 'goodbye'), (['have', 'a', 'nice', 'day'], 'goodbye'), (['talk', 'to', 'you', 'soon'], 'goodbye'), (['make', 'me', 'a', 'sandwich'], 'sandwich'), (['can', 'you', 'make', 'a', 'sandwich'], 'sandwich'), (['having', 'a', 'sandwich', 'today'], 'sandwich'), (['what', "'s", 'for', 'lunch', '?'], 'sandwich')]
</em></span><span style="color:rgb(128,128,128);"><em># ['greeting', 'sandwich', 'goodbye']
</em></span><span style="color:rgb(128,128,128);"><em># ['me', 'can', 'lunch', 'soon', 'good', 'to', 'for', 'see', 'a', 'is', 'what', 'day', "'s", 'going', 'ar', 'lat', 'today', 'it', 'hav', 'you', 'talk', 'yo', 'nic', 'sandwich', 'mak', 'how']
</em></span><span style="color:rgb(128,128,128);"><em># ************
</em></span><span style="color:rgb(128,128,128);"><em># ['how', 'are', 'you', '?']
</em></span><span style="color:rgb(128,128,128);"><em># ['how', 'ar', 'you', '?']
</em></span><span style="color:rgb(128,128,128);"><em># [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]
</em></span><span style="color:rgb(128,128,128);"><em># [1, 0, 0]
</em></span><span style="color:rgb(128,128,128);"><em># ******下面的代码，实现了词袋处理并将输入句子转换为0、1数组******
</em></span><span style="color:rgb(128,128,128);"><em># ******实现神经网络的训练函数来调整突触的权重******
</em></span><span style="color:rgb(128,128,128);"><em># ******隐层中只使用了20个神经元，因此比较容易进行调节******
</em></span><span style="color:rgb(128,128,128);"><em># Training with 20 neurons, alpha:0.1, dropout:False
</em></span><span style="color:rgb(128,128,128);"><em># Input matrix: 12x26    Output matrix: 1x3
</em></span><span style="color:rgb(128,128,128);"><em># delta after 10000 iterations:0.006316297034425907
</em></span><span style="color:rgb(128,128,128);"><em># delta after 20000 iterations:0.0043193475426743615
</em></span><span style="color:rgb(128,128,128);"><em># delta after 30000 iterations:0.003467478418933735
</em></span><span style="color:rgb(128,128,128);"><em># delta after 40000 iterations:0.0029698374148845906
</em></span><span style="color:rgb(128,128,128);"><em># delta after 50000 iterations:0.0026348137914361477
</em></span><span style="color:rgb(128,128,128);"><em># delta after 60000 iterations:0.0023899968815955614
</em></span><span style="color:rgb(128,128,128);"><em># delta after 70000 iterations:0.0022012384383537555
</em></span><span style="color:rgb(128,128,128);"><em># delta after 80000 iterations:0.0020500796559913266
</em></span><span style="color:rgb(128,128,128);"><em># delta after 90000 iterations:0.0019255650109882149
</em></span><span style="color:rgb(128,128,128);"><em># delta after 100000 iterations:0.00182073232414893
</em></span><span style="color:rgb(128,128,128);"><em># processing time: 8.264868974685669 seconds
</em></span><span style="color:rgb(128,128,128);"><em># ******预测一个句子属于某个分类的概率******
</em></span><span style="color:rgb(128,128,128);"><em># sudo make me a sandwich
</em></span><span style="color:rgb(128,128,128);"><em>#  classification: [['sandwich', 0.998725720350513]]
</em></span><span style="color:rgb(128,128,128);"><em># how are you today?
</em></span><span style="color:rgb(128,128,128);"><em>#  classification: [['greeting', 0.9991704815542843]]
</em></span><span style="color:rgb(128,128,128);"><em># talk to you tomorrow
</em></span><span style="color:rgb(128,128,128);"><em>#  classification: [['goodbye', 0.9916537770480427]]
</em></span><span style="color:rgb(128,128,128);"><em># who are you?
</em></span><span style="color:rgb(128,128,128);"><em>#  classification: [['greeting', 0.852891610128995]]
</em></span><span style="color:rgb(128,128,128);"><em># make me some lunch
</em></span><span style="color:rgb(128,128,128);"><em>#  classification: [['sandwich', 0.9756042223385346]]
</em></span><span style="color:rgb(128,128,128);"><em># how was your lunch today?
</em></span><span style="color:rgb(128,128,128);"><em>#  classification: [['greeting', 0.9854377884742492]]
</em></span><span style="color:rgb(128,128,128);"><em>#
</em></span><span style="color:rgb(128,128,128);"><em># found in bag: good
</em></span><span style="color:rgb(128,128,128);"><em># found in bag: day
</em></span><span style="color:rgb(128,128,128);"><em># sentence: good day
</em></span><span style="color:rgb(128,128,128);"><em>#  bow: [0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
</em></span><span style="color:rgb(128,128,128);"><em># good day
</em></span><span style="color:rgb(128,128,128);"><em>#  classification: [['greeting', 0.9966108820436639]]
</em></span><span style="color:rgb(128,128,128);"><em>#
</em></span><span style="color:rgb(128,128,128);"><em># Process finished with exit code 0</em></span></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/439f7b093b6a778a35984d60f188d255/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Matlab] Simulink 串口接收详解1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0440eee645ba93404188a576f7720512/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Error: No PostCSS Config found in... 报错 解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>