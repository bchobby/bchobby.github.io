<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Shader的基础知识 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Shader的基础知识" />
<meta property="og:description" content="管线渲染
定义：图形数据在GPU上经过运算处理，最后输出到屏幕的过程
1. 顶点处理： 接收模型顶点数据、坐标系装换
2. 图元装配： 组装面、连接相邻的顶点，绘制为三角面
3. 光栅化 ：计算三角面上的像素，并为后面着色阶段提供合理的插值参数（以及深度值）
4. 像素处理： 对每个像素区域进行着色、写入到缓存
5. 缓存：一个存储像素数据的内存块，最重要的缓存是帧缓存与深度缓存
帧缓存：存储每个像素的色彩（缓冲）
深度缓存Z-buffer：前后排序（深度信息，物体到摄像机的距离）
6. Draw Call 绘制调用：每帧调用显卡渲染物体的次数
什么是缓冲？
一个像素有如下缓冲
颜色缓冲Color buffer/prixel buffer: 储存该点即将显示的颜色，RGBA值
深度缓存 depth buffer/Z buffer: 储存该点的深度Z
模板缓存stencil buffer ： 通常作用限制渲染区域。更高级用法需结合深度缓存，例如某像素的模板缓冲值会随着其是否通过深度缓冲测试而改变
什么是图元装配（Primitive Assembly）
经过变换的顶点 被装配成几何（三角形等）图集
什么是光栅化(栅格化)（Rasterization）
栅格化这个术语：可以用于任何将矢量图形转化成栅格图像的过程
在3D渲染中主要是指，三角形等图元（矢量）转化成像素碎片的过程。或者说决定哪些像素几何图元覆盖的过程。栅格化的结果是像素位置的集合和片段的集合
什么是光栅操作（Raster Operation）
指在碎片fragment处理后，在更新帧缓存前最后执行的一系列操作。通过包括裁剪，深度测试，alpha测试，alpha混合等。
Shader常见术语
Alpha 透明的（黑透白不透、灰色半透半不透）
Bump凹凸 （法线贴图）
Specular (高光)
Shader主要看Game视窗
Shader显示名称与Shader名不冲突
什么是GPU?
GPU：Graphic Processing Unit,中文翻译为“图形处理器”。显卡包括（GPU,显存，显卡BLOS，显卡PCB板）
什么是Shader?
Shader程序：GPU执行的，针对3D对象进行操作的程序
Shader编程有那几种？
CG：与DirectX 9.0 以上以及OpenGL 完全兼容。运行时或事先编译成GPU汇编代码
HLSL: 主要用于Direct3D。平台：Windows" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/5ab147a05e25d3fd2602618808b6114b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-26T11:21:45+08:00" />
<meta property="article:modified_time" content="2021-01-26T11:21:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shader的基础知识</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>管线渲染</strong></p> 
<p>定义：图形数据在GPU上经过运算处理，最后输出到屏幕的过程</p> 
<p>1. 顶点处理： 接收模型顶点数据、坐标系装换</p> 
<p>2. 图元装配： 组装面、连接相邻的顶点，绘制为三角面</p> 
<p>3. 光栅化 ：计算三角面上的像素，并为后面着色阶段提供合理的插值参数（以及深度值）</p> 
<p>4. 像素处理： 对每个像素区域进行着色、写入到缓存</p> 
<p>5.  缓存：一个存储像素数据的内存块，最重要的缓存是帧缓存与深度缓存</p> 
<p> 帧缓存：存储每个像素的色彩（缓冲）</p> 
<p> 深度缓存Z-buffer：前后排序（深度信息，物体到摄像机的距离）</p> 
<p>6. Draw Call  绘制调用：每帧调用显卡渲染物体的次数</p> 
<p><strong>什么是缓冲？</strong></p> 
<p>一个像素有如下缓冲</p> 
<p>颜色缓冲Color buffer/prixel buffer: 储存该点即将显示的颜色，RGBA值</p> 
<p>深度缓存 depth buffer/Z buffer: 储存该点的深度Z</p> 
<p>模板缓存stencil buffer  ： 通常作用限制渲染区域。更高级用法需结合深度缓存，例如某像素的模板缓冲值会随着其是否通过深度缓冲测试而改变</p> 
<p><strong>什么是图元装配（Primitive Assembly）</strong></p> 
<p>经过变换的顶点 被装配成几何（三角形等）图集</p> 
<p><strong>什么是光栅化(栅格化)（Rasterization）</strong></p> 
<p>栅格化这个术语：可以用于任何将矢量图形转化成栅格图像的过程</p> 
<p>在3D渲染中主要是指，三角形等图元（矢量）转化成像素碎片的过程。或者说决定哪些像素几何图元覆盖的过程。栅格化的结果是像素位置的集合和片段的集合</p> 
<p><strong>什么是光栅操作（Raster Operation）</strong></p> 
<p>指在碎片fragment处理后，在更新帧缓存前最后执行的一系列操作。通过包括裁剪，深度测试，alpha测试，alpha混合等。</p> 
<p><strong>Shader常见术语</strong></p> 
<p>Alpha 透明的（黑透白不透、灰色半透半不透）</p> 
<p>Bump凹凸 （法线贴图）</p> 
<p>Specular (高光)</p> 
<p>Shader主要看Game视窗</p> 
<p>Shader显示名称与Shader名不冲突</p> 
<p><strong>什么是GPU?</strong></p> 
<p>GPU：Graphic Processing Unit,中文翻译为“图形处理器”。显卡包括（GPU,显存，显卡BLOS，显卡PCB板）</p> 
<p><strong>什么是Shader?</strong></p> 
<p>Shader程序：GPU执行的，针对3D对象进行操作的程序</p> 
<p>Shader编程有那几种？</p> 
<p>CG：与DirectX 9.0 以上以及OpenGL 完全兼容。运行时或事先编译成GPU汇编代码</p> 
<p>HLSL: 主要用于Direct3D。平台：Windows</p> 
<p>GLSL: 主要用于OPenGL。 平台：移动平台（IOS,Android）,Mac(only use when you target Mac OS X or OpenGL ES 2.0)</p> 
<p><strong>为什么Shader中选择CG?</strong></p> 
<p>因为CG/HLSL 比GLSL支持更多的平台。</p> 
<p><strong>Unity3d 里CG输出什么？</strong></p> 
<p>Windows平台：Direct3D,GPU汇编代码</p> 
<p>Mac: OpenGL GPU汇编代码</p> 
<p>Flash: Flash GPU 汇编代码</p> 
<p>IOS/Android : unity 会将CG转换成GLSL代码。</p> 
<p>总结：也就是除了移动平台会把CG转换成GLSL代码，其余平台都是转化成汇编代码。</p> 
<p> </p> 
<p><strong>Unity 中的三种自定义Shade:</strong></p> 
<p>1.surface shaders, 表面着色器（最常用，比固定功能管线高级）（之前默认创建的shader类型）它是 Vertex and fragment shaders 的包装，让我们可以不用关心这些顶点和片段程序的细节，可以直接得到我们想要的着色器。</p> 
<p>2.Vertex and fragment shaders 顶点和片元着色器（细节处理，偏底层）</p> 
<p>3.fixed function shaders.  固定功能管线着色器（更简单），在可编程渲染管线硬件出现之前，很多光照都会放在硬件级处理（可以理解为对固定管线硬件的操作），一般放在项目前绝大多数硬件都可支持，应用就可以使用，比如光照、纹理采样</p> 
<p>//Shader中没有注明是前两种shader,即为第三种shader</p> 
<p>先从ShaderLab基本语法开始入手，再去阅读surface shader,或者vertex and fragment shaders</p> 
<p><strong>ShaderLab 基本结构</strong></p> 
<p>Unity中的Shader 都是要通过ShaderLab的基本语法进行编写，unity就是想通过Shaderlab的方案进行Shader的编写。将三种定义的Shader通过同一种格式进行编写，避免不同Shader使用不同的方法。</p> 
<p> </p> 
<pre><code>Shader "name"
{
    //[Properties] 属性 查看ShaderLab：Properties 
    //作用:在可视化面板提供美工可使用的属性
	Properties  
	{
		
	}
    //[Subshader] 算法用于执行给定的数据
	SubShader
	{
		
	}
    //[FallBack] 后退 一般会填写所有硬件都支持的渲染方式
    FallBack "Diffuse"
}</code></pre> 
<p>关于SubShaders (处理ShaderLab中的语言片段) 在ShaderLab中至少有一个SubShader，当然也可多个。但是，显卡每次渲染处理的时候只能选择一个SubShaders执行。那多个SubShader的作用是为了不同的硬件的渲染支持，为了Shader能在比较老的图形显卡中也能支持。一般比较往下的Subshader要简化，运算指令要简单。</p> 
<p> </p> 
<p>Fixed function shader固定功能管线</p> 
<p>所有硬件平台都可支持，针对硬件能够执行的基本命令的Shader,当然有，但是，速度最快</p> 
<p>Properties 属性</p> 
<p>Material 材质</p> 
<p>Lighting 光照</p> 
<p>Settexture  设置纹理</p> 
<p>Pass通道（存储图像的色彩RGB）(只有Surface 可以不写)</p> 
<p>Surface shaders</p> 
<p>surfaceOutPut输出</p> 
<p>Input 输入</p> 
<p>Lighting 光照</p> 
<p>常用公式</p> 
<p>环境反射</p> 
<p>Ambient= Ka*globalAmbient;</p> 
<p>Ka是材质的环境反射系数</p> 
<p>globalAmbient是入射环境光的颜色</p> 
<p> </p> 
<p>漫反射</p> 
<p>Diffuse=Kd*lightColor*max(N*L,0);</p> 
<p>Kd 是材质的漫反射颜色</p> 
<p>lightColor是入射漫反射光的颜色</p> 
<p>N 是规范化的表面法向量</p> 
<p>L 是规范化的纸箱光源对的向量；</p> 
<p>镜面反射</p> 
<p>Specular=Ks * lightColor *facing*max((N*H),0) shininess</p> 
<p>Ks 是材质的镜面反射颜色；</p> 
<p>lightColor是入射镜面反射光的颜色</p> 
<p>N是规范化的表面法向量</p> 
<p>V是指向视点的规范化的向量</p> 
<p>L是指向光源的规范化的向量</p> 
<p>H是V和L的中间向量的规范化向量</p> 
<p>P是要被着色的点</p> 
<p>Faceing是1如果N*L是大于0的，否者为0</p> 
<p>写Shader不区分大小写</p> 
<p>和灯光有呼应的  ------ 漫反射  高光   背光    阴影   环境光</p> 
<p><strong>固定着色器格式</strong></p> 
<pre><code>hader "Unlit/Test2"//不区分大小写
{
    //声明属性
	Properties
	{
        //默认颜色颜色
        //变量名    在监视面板显示的名称    类型=值
		_Color("MyColor",Color)=(1,0,0,1)
        //环境光
        _Ambient("Ambient",Color)=(1,0,0,1)
        //高光
        _Specular("Specular",Color)=(1,0,0,1)
        _Shininess("Shininess",Range(0,1))=0.5 //range 0-8的值
        //自发光
        _Emission("Emission",Color)=(1,0,0,1)
        //
        _MainTexture("Main Texture",2D)="white"{}
        //默认颜色

	}
	SubShader
	{

    pass
    {

		Color[_Color]   //使用默认颜色进行颜色的写入
      
        Material{
            //漫反射
            Diffuse[_Color]
            //环境光
            Ambient[_Ambient]
            //亮度
            Shininess[_Shininess]
            //高光反射系数
            Specular[_Specular]
            //自发光
            Emission[_Emission]
        }
        //启动光照
        Lighting On 
        //启动高光反射
        SeparateSpecular On
        SetTexture[_MainTexture]
        {
          Combine Texture*primary double
        }
	}
    }
    FallBack "Diffuse"
}
</code></pre> 
<p><br><strong>表面着色器格式</strong></p> 
<pre><code>Shader "Custom/Test1" {
    //属性 
    //属性变量
	Properties {
         //变量名  面板中的名字  类型
		_Color ("Color", Color) = (1,1,1,1)
		_MainTex ("Albedo (RGB)", 2D) = "white" {}
		_Glossiness ("Smoothness", Range(0,1)) = 0.5
		_Metallic ("Metallic", Range(0,1)) = 0.0
	}
    //算法
	SubShader {
		Tags { "RenderType"="Opaque" } //描述渲染类型，当前是不透明的物体
        //Tags{"RenderType"="Opaque" "queue"="transparent"}//透明的物体
		LOD 200  //层级细节
		
		CGPROGRAM  //CG代码块 CG开始
		// Physically based Standard lighting model, and enable shadows on all light types
        //如果是Standard fullforwardshadows光照模型，则对应用SurfaceOutputStandard，
        //如果是Lambert光照模型（其他版本Unity默认的光照模型），则对应SurfaceOutput。
        //对应的SurfaceOutputStandard/SurfaceOutput结构体不用写出来
        #pragma surface surf Standard fullforwardshadows//编译指令
        //surface表面着色器 surf调用的方法 Standard基于物理的光照模型（原来是漫反射 Lambert）
        //fullforwardshadows 阴影表现（平行光、点光、聚光都是有阴影的）
        // Use shader model 3.0 target, to get nicer looking lighting
		#pragma target 3.0  //GPU硬件支持3.0 （不写默认是2.0）

		sampler2D _MainTex; //CG中图片的类型

		struct Input {
			float2 uv_MainTex; //记录uv纹理坐标
		};

		half _Glossiness; //CG中的浮点型
		half _Metallic;   
		fixed4 _Color;    //CG中的四阶向量（0，0，0，0）rgb

		// Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.
		// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.
		// #pragma instancing_options assumeuniformscaling
		UNITY_INSTANCING_CBUFFER_START(Props)
			// put more per-instance properties here
		UNITY_INSTANCING_CBUFFER_END
        //Input 传入值    inout 传出值(基于物理的要加Standard)
		void surf (Input IN, inout SurfaceOutputStandard o) {
			// Albedo comes from a texture tinted by color
			fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
			o.Albedo = c.rgb;
			// Metallic and smoothness come from slider variables
			o.Metallic = _Metallic;  //金属光泽表现
			o.Smoothness = _Glossiness; //高光光泽度
			o.Alpha = c.a;
		}
		ENDCG //CG结束
	}
	FallBack "Diffuse"
}
</code></pre> 
<p><strong>表面着色器示例练习</strong></p> 
<pre><code>Shader "Custom/Test5" {
	Properties {
        //2D ---图片    white----默认格式  “”内也可以不写
        //大括号也可以不写（大括号内可以给值）
		_MainTex("Texture",2D)="white"{}
        _BumpMap("Bumpmap",2D)="bump"{}
        //cube 立方体贴图
        _Cube("Cubemap",CUBE)=""{}
	}
	SubShader {
        //不透明
		Tags { "RenderType"="Opaque" }
		LOD 200
		
		CGPROGRAM
		// Physically based Standard lighting model, and enable shadows on all light types
        //如果是Standard fullforwardshadows光照模型，则对应用SurfaceOutputStandard，
        //如果是Lambert光照模型（其他版本Unity默认的光照模型），则对应SurfaceOutput。
        //对应的SurfaceOutputStandard/SurfaceOutput结构体不用写出来
        #pragma surface surf Lambert

		// Use shader model 3.0 target, to get nicer looking lighting
		#pragma target 3.0

		struct Input {
            //只要是纹理相关都需要UV
			float2 uv_MainTex;
            float2 uv_BumpMap;
            float3 worldRef1;
            INTERNAL_DATA  //反射与法线效果配合
		};

        //再次声明变量
        sampler2D _MainTex;
        sampler2D _BumpMap;
        samplerCUBE _Cube;


		// Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.
		// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.
		// #pragma instancing_options assumeuniformscaling
		UNITY_INSTANCING_CBUFFER_START(Props)
			// put more per-instance properties here
		UNITY_INSTANCING_CBUFFER_END

		void surf (Input IN, inout SurfaceOutput o) {
			o.Albedo=tex2D(_MainTex,IN.uv_MainTex).rgb;
            //不需要法线的反射效果
            //o.Emission=texCUBE(_Cube,IN.worldRefl).rgb;
            //法线与反射效果配合
            //需要将INTERNAL_DATA添加到Input结构中
            o.Normal=UnpackNormal(tex2D(_BumpMap,IN.uv_BumpMap));
            //反射
            o.Emission=texCUBE(_Cube,WorldReflectionVector(IN,o.Normal)).rgb;
		}
		ENDCG
	}
	FallBack "Diffuse"
}
</code></pre> 
<p><a href="https://www.cnblogs.com/jietian331/p/5549889.html" rel="nofollow">CG之基本光照模型计算公式 </a></p> 
<p>在一个基本模型里，一个物体表面的颜色是由放射(emissive)、环境反射(ambient)、漫反射(diffuse)和镜面反射(specular)等光照作用的总和。每种光照作用取决于表面材质的性质（如亮度和材质颜色）和光源的性质（如光的颜色和位置）的共同作用。</p> 
<p>从数学上描述基本模型的高级公式如下所示：</p> 
<p>surfaceColor = emissive +ambient + diffuse + specular</p> 
<p>一、放射项</p> 
<p>emissive = Ke</p> 
<p>其中：</p> 
<p>Ke代表材质的放射光颜色。</p> 
<p>二、环境反射项</p> 
<p>ambient = Ka * globalAmbient</p> 
<p>其中：</p> 
<p>Ka是材质的环境反射系数。</p> 
<p>globalAmbient是入射环境光的颜色。</p> 
<p>三、漫反射项</p> 
<p>diffuse = Kd * lightColor * max(dot(N, L), 0)</p> 
<p>其中：</p> 
<p>Kd是材质的漫反射颜色。</p> 
<p>lightColor是入射漫反射光的颜色。</p> 
<p>N是规范化的表面法向量。</p> 
<p>L是规范化的从顶点到光源的向量。</p> 
<p>四、镜面反射项</p> 
<p>specular = Ks * lightColor * facing * pow(max(dot(N, H), 0), shininess)</p> 
<p>其中：</p> 
<p>Ks 是材质的镜面反射颜色。</p> 
<p>lightColor是入射镜面反射光的颜色。</p> 
<p>N是规范化的表面法向量。</p> 
<p>H是规范化的，顶点到光源的向量与顶点到眼睛的向量的中间向量。</p> 
<p>facing是，如果dot(N,L)大于0则为1，否则为0。其中L是顶点到光源位置的向量。</p> 
<p>shinniess是表面光泽度。</p> 
<p>1 Shader "Custom/Test"<br>  2 {<!-- --><br>  3     Properties<br>  4     {<!-- --><br>  5         _Ke("Ke", Color) = (1,1,1,1)<br>  6         _Ka("Ka", Color) = (1,1,1,1)<br>  7         _GlobalAmbient("Global ambient", Color) = (1,1,1,1)<br>  8         _Kd("Kd", Color) = (1,1,1,1)<br>  9         _Ks("Ks", Color) = (1,1,1,1)<br> 10         _Shininess("", float) = 1<br> 11     }<br> 12<br> 13     SubShader<br> 14     {<!-- --><br> 15         Pass<br> 16         {<!-- --><br> 17             Tags<br> 18             {<!-- --><br> 19                 "RenderType" = "Opaque"<br> 20             }<br> 21<br> 22             CGPROGRAM<br> 23             #pragma vertex Vert<br> 24             #pragma fragment Frag<br> 25<br> 26             #include "UnityCG.cginc"<br> 27             #include "Lighting.cginc"<br> 28<br> 29             uniform float4 _Ke;<br> 30             uniform float4 _Ka;<br> 31             uniform float4 _GlobalAmbient;<br> 32             uniform float4 _Kd;<br> 33             uniform float4 _Ks;<br> 34             uniform float _Shininess;<br> 35             <br> 36             struct VertexInput<br> 37             {<!-- --><br> 38                 float4 pos : POSITION;<br> 39                 float2 uv : TEXCOORD0;<br> 40                 float3 nor : NORMAL;<br> 41                 float4 col : COLOR;<br> 42             };<br> 43<br> 44             struct FragmentInput<br> 45             {<!-- --><br> 46                 float4 pos : SV_POSITION;<br> 47                 float2 uv : TEXCOORD0;<br> 48                 float4 col : COLOR;<br> 49             };<br> 50<br> 51             FragmentInput Vert(VertexInput vi)<br> 52             {<!-- --><br> 53                 FragmentInput fi;<br> 54                 fi.pos = mul(UNITY_MATRIX_MVP, vi.pos);<br> 55                 fi.uv = vi.uv;<br> 56<br> 57                 // compute emissive<br> 58                 float3 emissiveC = _Ke.rgb;<br> 59<br> 60                 // compute ambient<br> 61                 float3 ambientC = _Ka.rgb * _GlobalAmbient.rgb;<br> 62<br> 63                 // compute diffuse<br> 64                 float3 nor = mul(vi.nor, (float3x3)_World2Object);<br> 65                 float3 dir2Light = normalize(WorldSpaceLightDir(vi.pos));<br> 66                 float nl = max(0, dot(nor, dir2Light));<br> 67                 float3 diffuseC = _Kd.rgb * _LightColor0.rgb * nl;<br> 68<br> 69                 // compute specular<br> 70                 float3 dir2Cam = normalize(WorldSpaceViewDir(vi.pos));<br> 71                 float nh = max(0, dot(nor, dir2Cam + dir2Light));<br> 72                 float specLight = nl &gt; 0 ? pow(nh, _Shininess) : 0;<br> 73                 float3 specC = _Ks * _LightColor0.rgb * specLight;<br> 74<br> 75                 fi.col.rgb = emissiveC + ambientC + diffuseC + specC;<br> 76                 fi.col.a = 1;<br> 77<br> 78                 return fi;<br> 79             }<br> 80<br> 81             float4 Frag(FragmentInput fi) : Color<br> 82             {<!-- --><br> 83                 return fi.col;<br> 84             }<br> 85<br> 86             ENDCG<br> 87         }<br> 88     }<br> 89 }<br><img alt="" height="490" src="https://images2.imgbox.com/c6/fe/foCUvbMI_o.png" width="749"></p> 
<p> </p> 
<h2 id="articleContentId">【Unity5.x Shaders】最基本的Surface Shader-Diffuse shader以及Surface中的三种输出结构</h2> 
<p>某些物体可能具有均匀的颜色和光滑的表面，但光滑程度不足以照射反射光。<br> 这些哑光材料最好用Diffuse Shader。 在现实世界中，不存在纯diffuse materials<br><strong>Diffuse shader</strong>经常出现在游戏中，下面就是一个简单的Diffuse shader代码</p> 
<pre><code>Shader "Custom/DiffuseShader" {
    Properties {
        _Color ("Color", Color) = (1,1,1,1)                     
    }
    SubShader {
        Tags { "RenderType"="Opaque" }
        LOD 200

        CGPROGRAM
        // Physically based Standard lighting model, and enable shadows on all light types
        #pragma surface surf Standard fullforwardshadows

        // Use shader model 3.0 target, to get nicer looking lighting
        #pragma target 3.0

        struct Input {
            float2 uv_MainTex;
        };

        fixed4 _Color;

        void surf (Input IN, inout SurfaceOutputStandard o)
        {           
            o.Albedo = _Color.rgb;          
        }
        ENDCG
    }
    FallBack "Diffuse"
}</code></pre> 
<p>这是一个从Standard Shader改装的的Shader，它将使用基于物理的渲染去模仿灯光在模型上的行为。<br> 如果你想实现一个非真实感（non-photorealistic）的外观，可以改变第一个预处理指令使用<strong>Lambert</strong>光照模型。<br><code>#pragma surface surf Lambert</code><br> 如果使用了这个模型，<strong>surf</strong>函数中的输出结构<strong>SurfaceOutputStandard</strong>需要改成<strong>SurfaceOutput</strong>。</p> 
<h3 id="surface输出结构"><strong>Surface输出结构</strong></h3> 
<p>Shader允许你通过Surface的输出结构将材质的渲染属性传递给光照模型。<br> 不同的Surface光照模型需要不同的Surface输出结构</p> 
<p>在Unity5中，有<strong>三种</strong>主要的输出结构：</p> 
<h4 id="surfaceoutput"><a name="t1"></a><strong>SurfaceOutput</strong></h4> 
<p>一般的光照模型例如Lambert光照模型</p> 
<pre><code>struct SurfaceOutput {  
    fixed3 Albedo;   //对光源的反射率
    fixed3 Normal;   //对应切线空间法线方向
    fixed3 Emission; //自发光
    half Specular;   //高光反射中的指数部分的系数。
    fixed Gloss;     //高光反射中的强度系数
    half Alpha;      //透明通道</code></pre> 
<h4 id="surfaceoutputstandard"><strong>SurfaceOutputStandard</strong></h4> 
<p><strong>标准光照模型</strong> 使用此结构输出</p> 
<pre><code>struct SurfaceOutputStandard {  
    fixed3 Albedo;  //材质的基础颜色（无论是漫反射还是高光）
    fixed3 Normal;   
    half3 Emission; //类型被声明为half3，注意在SurfaceOutput中被定义为fixed3
    half Alpha;      
    half Occlusion; //遮挡(默认为1)  
    half Smoothness;//光滑程度（0=粗糙, 1=光滑）
    half Metallic;  //0=非金属, 1=金属</code></pre> 
<ul><li> </li></ul> 
<h4 id="surfaceoutputstandardspecular"><a name="t3"></a><strong>SurfaceOutputStandardSpecular</strong></h4> 
<p><strong>标准镜面光照模型</strong> 使用此结构输出</p> 
<pre><code>struct SurfaceOutputStandardSpecular
{
    fixed3 Albedo;      
    fixed3 Specular;    // 镜面反射颜色
    fixed3 Normal;     
    half3 Emission;
    half Smoothness;    
    half Occlusion;     
    fixed Alpha;      
};</code></pre> 
<p><strong>注意</strong>：这里的Specular完全不同于SurfaceOutput中的Specular<br> 它允许指定一个颜色而不是一个单值。</p> 
<p>正确使用Surface Shader，是使Surface输出结构输出正确的值</p> 
<p><a href="https://blog.csdn.net/leonardo_davinci/article/details/78869587">参考资料 https://blog.csdn.net/leonardo_davinci/article/details/78869587</a> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9629a63e66905c4828ff2c4f46bcdbc4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[git]mac的github头像突然显示不出来，解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58d8cf1718941ec0948d25381b1e7fe8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">系统学习 Zabbix 系统监控（二）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>