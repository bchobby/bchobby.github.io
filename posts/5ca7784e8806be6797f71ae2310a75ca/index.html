<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python(三)基于flask返回json数据接口：flask-sqlalchemy详细介绍 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python(三)基于flask返回json数据接口：flask-sqlalchemy详细介绍" />
<meta property="og:description" content="因为不关心前台页面的开发，前台工程师给我提供了一份json样式。让我实现，然后给出了筛选条件。还是接着上篇文章，将ORM这块仔细写写。这篇文章也将关于flask-sqlalchemy的总结，我会把用户遇到的格式问题都总结在这里面。我写博客的原则，用过什么写什么，没涉及的也不瞎写了。
首先看前台工程师给我提供的json返回格式样例。大概就是以song为对象的list，里面有嵌着多对多关系的歌手和一对多的版权
{ &#34;Songs&#34;: [ { &#34;ID&#34;: 28, &#34;artist&#34;: [ &#34;吴克群&#34; ], &#34;lyric&#34;: &#34;&#34;, &#34;title&#34;: &#34;大舌头&#34; &#34;copyrights&#34;: { &#34;lyric&#34;: [ { &#34;OP&#34;: &#34;成果音乐版权有限公司&#34;, &#34;SP&#34;: &#34;&#34;, &#34;disctrict&#34;: &#34;&#34;, &#34;endDate&#34;: &#34;永久&#34;, &#34;lyricists&#34;: &#34;吴克群&#34;, &#34;share&#34;: &#34;50.0%&#34;, &#34;startDate&#34;: &#34;&#34; } ] } } ], &#34;paging&#34;: { &#34;page-index&#34;: 1, &#34;page-size&#34;: 20, &#34;total&#34;: 25 } } 上篇文章的时候我已经将model层的代码粘了出来，这里再粘贴一次
from mock import db artist_songs = db.Table(&#39;artist_songs&#39;, db.Column(&#39;song_id&#39;, db.Integer, db.ForeignKey(&#39;songs.id&#39;)), db.Column(&#39;artist_id&#39;, db.Integer, db.ForeignKey(&#39;artists.id&#39;)) ) class songs(db.Model): __tablename__ = &#39;songs&#39; id = db." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/5ca7784e8806be6797f71ae2310a75ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-23T01:21:30+08:00" />
<meta property="article:modified_time" content="2018-11-23T01:21:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python(三)基于flask返回json数据接口：flask-sqlalchemy详细介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p> </p> 
<p>因为不关心前台页面的开发，前台工程师给我提供了一份json样式。让我实现，然后给出了筛选条件。还是接着上篇文章，将ORM这块仔细写写。这篇文章也将关于flask-sqlalchemy的总结，我会把用户遇到的格式问题都总结在这里面。我写博客的原则，用过什么写什么，没涉及的也不瞎写了。</p> 
<p>首先看前台工程师给我提供的json返回格式样例。大概就是以song为对象的list，里面有嵌着多对多关系的歌手和一对多的版权</p> 
<pre class="has"><code>{
  "Songs": [
    {
      "ID": 28,
      "artist": [
        "吴克群"
      ], 
      "lyric": "", 
      "title": "大舌头"
      "copyrights": {
        "lyric": [
          {
            "OP": "成果音乐版权有限公司", 
            "SP": "", 
            "disctrict": "", 
            "endDate": "永久", 
            "lyricists": "吴克群", 
            "share": "50.0%", 
            "startDate": ""
          }
        ]
      }
    }
   ], 
  "paging": {
    "page-index": 1, 
    "page-size": 20, 
    "total": 25
  }
}
</code></pre> 
<p>上篇文章的时候我已经将model层的代码粘了出来，这里再粘贴一次</p> 
<pre class="has"><code class="language-python">from mock import db

artist_songs = db.Table('artist_songs',
    db.Column('song_id', db.Integer, db.ForeignKey('songs.id')),
    db.Column('artist_id', db.Integer, db.ForeignKey('artists.id'))
    )  

class songs(db.Model):
    __tablename__ = 'songs'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(255), nullable=True)
    lyrics = db.Column(db.Text(), nullable=True)
    created_at = db.Column(db.DateTime, nullable=False)
    artists=db.relationship('artists', secondary=artist_songs,backref = db.backref('artists'),lazy="select")
    lyric_copies=db.relationship('lyric_copies',backref='songs',lazy='select')
  
     def jsonstr(self):
        artist=[]
        if self.artists is not None and len(self.artists)!=0:
            for art in self.artists:
                artist.append(art.name)
        
        lyricarr=[]
        if self.lyric_copies is not None and len(self.lyric_copies)!=0:
            for lyr in self.lyric_copies:
                lyricarr.append(lyr.jsonstr())
                
        jsondata = { 
            'ID': self.id, 
            'title': self.title,
            'artist': artist,
            'lyric':self.lyrics,
            'copyrights':{
                'lyric':lyricarr
            }
        }
        return jsondata

class artists(db.Model):
    __tablename__ = 'artists'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(255), nullable=True)
    gender = db.Column(db.Integer, nullable=True)
    location = db.Column(db.String(255), nullable=True)
    created_at = db.Column(db.DateTime, nullable=False)
    updated_at = db.Column(db.DateTime, nullable=False)

class lyric_copies(db.Model):
    __tablename__ = 'lyric_copies'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(255), nullable=True)
    end_date=db.Column(db.DateTime, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False)
    updated_at = db.Column(db.DateTime, nullable=False)
    song_id = db.Column(db.Integer, db.ForeignKey('songs.id'),nullable=False)

    def jsonstr(self):
        enddatestr=''
        if self.end_date is not None and self.end_date!='':
            enddatestr=self.end_date.strftime('%Y-%m-%d')
        else:
            enddatestr='永久'
  
        jsonstr={
            "lyricists": self.name,      
            "endDate": enddatestr
        }
        return jsonstr</code></pre> 
<p>这里有几个知识点：flask-sqlalchemy的文档不是很好，所有的注释都在源代码里，可以连接过去看看源代码。</p> 
<p>1)引入在初始化时生成db对象</p> 
<p>2)所有model类要继承db.Model 类</p> 
<p>3）__tablename__表示对应的表名</p> 
<p>4）db.Column（列类型、[Constraint|ForeignKey|ColumnDefault|Sequence|autoincrement|server_default|default])等等。</p> 
<p>      主键：primary_key=True，如果是联合主键在多个列标注上</p> 
<p>      自增长：autoincrement=True，只有主键是Integer时才行，只能有一列</p> 
<p>      外键：db.ForeignKey('songs.id')，songs表示songs类，songs.id表示songs表的id列</p> 
<p>      索引：index=True，说明该列建了索引</p> 
<p>      不能为空：nullable=True时，表示该列不能为空，如果nullable=False，表示default=NULL</p> 
<p>      默认值：server_default，eg：Column('y', DateTime, server_default=text('NOW()'))</p> 
<p>      唯一值：unique=True时，表示该列数值独一无二。此时该列默认index=True</p> 
<p>      系统列：system=True，表示该列是python程序自己列，并不会跟数据库关联</p> 
<p>5）类每个属性对应数据库表中每列的名称</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><th>数据库类型</th><th>Sqlalchemy类型</th><th>Python类型</th><th>说明</th></tr><tr><td>INT</td><td>Integer</td><td>int</td><td>普通整数,一般是32位</td></tr><tr><td>SMALLINT</td><td>SmallInteger</td><td>int</td><td>取值范围小的整数,一般是16位</td></tr><tr><td>BIGINT</td><td>BigInteger</td><td>int或long</td><td>不限制精度的整数</td></tr><tr><td>FLOAT、REAL</td><td>Float</td><td>float</td><td>浮点数</td></tr><tr><td>VARCHAR</td><td>String</td><td> string</td><td> </td></tr><tr><td>TEXT</td><td>Text</td><td>string</td><td> </td></tr><tr><td>NUMERIC、DECIMAL</td><td>Numeric</td><td>decimal.Decimal</td><td>定点数</td></tr><tr><td>NVARCHAR、unicode</td><td>Unicode</td><td>unicode</td><td> </td></tr><tr><td>Date</td><td>Date</td><td>datetime.date</td><td>日期</td></tr><tr><td>Time</td><td>Time</td><td>datetime.time</td><td>时间</td></tr><tr><td>DateTime</td><td>DateTime</td><td>datetime.datetime</td><td>日期和时间</td></tr></tbody></table> 
<p>以上是基本列的声明。其实用到也就那么几个，相信数据库端设计也不会太超出常规。</p> 
<p> </p> 
<p>下面着重对flask-sqlalchemy的一对多和多对多的声明进行讲解：</p> 
<p>一）1：N关系</p> 
<p>      一首歌有多个版权商，每个版权对应某首歌，所以在版权表里有song_id表示的是songs表的id，这里作为外键。在表述列的时候要如此描述：</p> 
<p>song_id = db.Column(db.Integer, db.ForeignKey('songs.id'),nullable=False)</p> 
<p>那么对于songs来说，它就有多个lyric_copies.</p> 
<p>将lyric_copies看作songs的一个对象来看，描述的方法如下：</p> 
<p>lyric_copies=db.relationship('lyric_copies',backref='songs',lazy='select')<br> 'lyric_copies'表示lyric_copies类、backref表示反向对应的类，lazy可以理解lyric_copies的加载时机，后面详见，默认是select</p> 
<p> </p> 
<p>二）N:N关系</p> 
<p>多对多的关系一般都会有个中间表用来保存彼此关系。在本例中歌手与歌曲的关系，被保存在artist_songs表中。</p> 
<p>表也很简单声明相对应列对应哪些表的外键。因为要在songs里面引用artist_songs对象，所以声明放在songs类之前。</p> 
<p> artists=db.relationship('artists', secondary=artist_songs,backref = db.backref('artists'),lazy="select")</p> 
<p>第一个参数'artists',表示对应的那个类</p> 
<p>secondary表示中间表是哪个，等于artist_songs对象</p> 
<p>backref = db.backref('artists')表示反向查找，说实话没弄明白</p> 
<p>lazy同上表示该对象的加载时机。</p> 
<p> </p> 
<h3>怎么通过Flask-sqlalchemy构造SQL语言</h3> 
<p>说完了关于数据库到对象的映射描述以后，我们接下来介绍一下一对一，一对多的增删改查操作。在谈具体细节之前，想说一下我对ORM框架的理解，因为之前一直在拼装SQL或将业务逻辑在存储过程里面完成。对ORM将结果映射在对象的做法无法理解。在学习sqlalchemry以后觉得，到底在用ORM还是SQL这个问题上，增删改和简单查询用ORM比较好、方便快捷。但是复杂的报表开发，用ORM那就是自掘坟墓了。所以看情况使用，当然作为ORM的初学者，一点微薄个人见解。</p> 
<p>我将所有ORM编写都放在了BSL层里，先从最关键的查询写起。</p> 
<p>在aritistbsl.py里面，先引用相关类型，db为上一文中，初始化生成对象</p> 
<pre class="has"><code>from mock import db
from mock.model.mockmodel import songs,artists,lyric_copies
from sqlalchemy.sql.expression import or_, and_</code></pre> 
<p>查询所有歌手</p> 
<pre class="has"><code class="language-python">class ArtistBSL   
    def QueryArtist(self):
        return db.session.query(Artist)</code></pre> 
<p>这样返回的就是查询Artist表的sql语句，类型是Basequery，只有当Basequery后面跟上.all(),.first(),.count(),paginate(int,int,bool)以后才真正转换为相应对象。</p> 
<p>.all()返回所有结果list</p> 
<p>.first()返回第一个对象</p> 
<p>.count()返回int型数据，行数</p> 
<p>.pageinate()返回list对象，结果集分页(pageindex,pagesize,false) 表示（第几页，每页行数，遇到error是否raise）</p> 
<p>构造SQL语句</p> 
<pre class="has"><code class="language-python">#查询歌手
db.session.query(Artists)
#查询name为吴克群的歌手
db.session.query(Artists).filter(Artists.name=='吴克群')
#查询姓吴的歌手
db.session.query(Artists).filter(Artists.name.like('吴%'))
#查询姓吴歌手并且是男性
db.session.query(Artists).filter(and_(Artists.name.like('吴%'),Artists.gender=='1'))
#查询姓吴或姓周的歌手
db.session.query(Artists).filter(or_(Artists.name.like('吴%'),Artists.name.like('周%')))


#songs关联歌手表查询
db.session.query(songs).join(songs.artists).filter(songs.title=='大舌头',artists.name=='吴克群')
#查询songs关联artists，输出歌手姓名和歌曲
db.session.query(songs.title,artists.name).join(songs.artists).filter(songs.title=='大舌头',artists.name=='吴克群')
#查询songs关联artists，输出歌手姓名和歌曲,并重命名列名
db.session.query(songs.title.label('songname'),artists.name.label('artistname')).join(songs.artists).filter(songs.title=='大舌头',artists.name=='吴克群')
#查询songs并左关联版权
db.session.query(songs).outjoin(songs.lyrice_copies)

#所有歌名并且去重
db.session.query(songs.name).distinct()
</code></pre> 
<h3>动态增加筛选条件</h3> 
<p> |id    |title         |<br>  | 1    |song1     |<br>  | 2    |               |<br>  | 3    |NULL      |<br>  ------------------<br> 当前台传来的参数title为''时，我们想查询到所有的结果<br> ORM:<br>     db.session.query(songs).filter(songs.title.like('%'+parm+'%'))<br>     相当于SQL:<br>     select * from songs where songs.title.like '%%'</p> 
<p>可是这样我们会把id=3为空的筛除掉。这时候就需要动态创建查询SQL，条件中就不增加where语句。<br> python应该为</p> 
<p>    condition=set()<br>     if parm !='':<br>         condition.add(songs.title.like('%'+parm+'%'))<br>     db.session.query(songs).filter(*condition)</p> 
<p>当parm为''时，SQL相当于<br>     select * from songs </p> 
<p>复合条件嵌套查询<br>     db.session.query(songs).filter(and_(*condition1,or_(*condition2)))<br> 常见条件运算符号</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>SQL</strong></td><td><strong>PYTHON</strong></td><td><strong>备注用法</strong></td></tr><tr><td>AND</td><td>and_</td><td>and_(条件1，条件2）</td></tr><tr><td>OR</td><td>or_</td><td>or_(条件1，条件2）</td></tr><tr><td>IN</td><td>in_</td><td>songs.title.in_(条件1，条件2）或者in_(list&lt;&gt;)</td></tr><tr><td>not IN</td><td>notin_</td><td>同上</td></tr><tr><td>Between</td><td>between</td><td>lyricescopies.share.between(0,100)包括边界值</td></tr><tr><td>LIKE</td><td>like</td><td>songs.title.like('%'+条件1+‘%’)</td></tr><tr><td>NOT LIKE</td><td>notlike</td><td>同上</td></tr></tbody></table> 
<p> </p> 
<p> </p> 
<p> </p> 
<h3>查询结果怎么用？返回JSON！JSON怎么构造？</h3> 
<p>       现在大部分系统已经做到前后台分离，中间靠JSON来传递。而我们查到的结果又需要一些特殊处理，比如当我们查到授权结束时间为空时，需要将输出字段显示为“永久”，或者输出键为“lyricists”对应对象name，那么这种情况都需要自己构造返回JSON格式，python里面最符合JSON的就是dict类型。在songs类里面添加jsonstr方法。类似下面情况，可以把一对多和多对多对象当list来处理。</p> 
<pre class="has"><code class="language-python">class songs(db.Model):
    __tablename__ = 'songs'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(255), nullable=True)
    lyrics = db.Column(db.Text(), nullable=True)
    created_at = db.Column(db.DateTime, nullable=False)
    artists=db.relationship('artists', secondary=artist_songs,backref = db.backref('artists'),lazy="select")
    lyric_copies=db.relationship('lyric_copies',backref='songs',lazy='select')
  
     def jsonstr(self):
        artist=[]
        if self.artists is not None and len(self.artists)!=0:
            for art in self.artists:
                artist.append(art.name)
        
        lyricarr=[]
        if self.lyric_copies is not None and len(self.lyric_copies)!=0:
            for lyr in self.lyric_copies:
                lyricarr.append(lyr.jsonstr())
                
        jsondata = { 
            'ID': self.id, 
            'title': self.title,
            'artist': artist,
            'lyric':self.lyrics,
            'copyrights':{
                'lyric':lyricarr
            }
        }
        return jsondata

class lyric_copies(db.Model):
    __tablename__ = 'lyric_copies'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(255), nullable=True)
    end_date=db.Column(db.DateTime, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False)
    updated_at = db.Column(db.DateTime, nullable=False)
    song_id = db.Column(db.Integer, db.ForeignKey('songs.id'),nullable=False)

    def jsonstr(self):
        enddatestr=''
        if self.end_date is not None and self.end_date!='':
            enddatestr=self.end_date.strftime('%Y-%m-%d')
        else:
            enddatestr='永久'
  
        jsonstr={
            "lyricists": self.name,      
            "endDate": enddatestr
        }
        return jsonstr</code></pre> 
<h3>根据结果集自动生成JSON</h3> 
<p>那么我们的结果可能千奇百怪，有些时候我们需要根据结果的列名自动生成JSON。比如我们要获取songs的id、title，比如：</p> 
<p>[</p> 
<p>{"Label":"世界末日","Value":1},</p> 
<p>{"Label":"稻香","Value":2},</p> 
<p>{"Label":"大舌头","Value":3}</p> 
<p>]</p> 
<p>ORM语句我们会这样写：</p> 
<pre class="has"><code>datalist=db.session.query(songs.title.label('label'),songs.id.label('Value')).all()</code></pre> 
<p>这时候datalist就是一个&lt;class 'sqlalchemy.util._collections.result'&gt;的list集合</p> 
<p>sqlalchemy.util._collections.result对象保存列值也包括列名</p> 
<p>写了一个静态方法，将list集合转为JSON数组。</p> 
<pre class="has"><code class="language-python">class JSONHelper():
    @staticmethod
    def jsonBQlist(bqlist):
        result=[]
        for item in bqlist:
            jsondata={}
            for i in range(item.__len__()):
                tdic={item._fields[i]:item[i]}
                jsondata.update(tdic)  
            result.append(jsondata)
        return result</code></pre> 
<p>在flask的app下使用办法。 </p> 
<pre class="has"><code>@app.route('/querytags', methods=['GET', 'POST'])
def querytags():
    tagslist=TagsBSL().QueryTags()
    return jsonify(JSONHelper.jsonBQlist(tagslist))</code></pre> 
<h3>一对多、多对多关系复杂关系的声明和查询</h3> 
<p>接下来的问题困扰了很长时间，也查了很多代码。就是一对多和多对多关系声明的时候，可能需要联合条件才能行。怎么处理？比如如图所示： </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dde538f09111d1900fc0fbd21cdb50c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">00004__VSCode__配置注释和自动提示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2755711dc11e3b458a7aa45c094ede87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">dubbo管理工具dubbo-admin安装使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>