<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Es6中的模块化Module,导入(import)导出(export) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Es6中的模块化Module,导入(import)导出(export)" />
<meta property="og:description" content="虽互不曾谋面,但希望能和你成为笔尖下的朋友
以读书,技术,生活为主,偶尔撒点鸡汤
不作,不敷衍,意在真诚吐露,用心分享
点击左上方,可关注本刊
前言 在Es6之前,javascript没有模块系统,它无法将一个大程序拆分成若干个互相依赖的小文件,然后在用简单的方法拼装起来.为了做到模块化,在Es6之前,引入了AMD(Asynchronous module definition)与CMD(common module definition)
前者典型代表是requireJS(外国人搞出来的),后者是seajs(国内) 共同点:都是对模块定义的不同规范,都是异步加载模块,并且解决文件之间的依赖重命名冲突等问题。 不同点:模块定义的方式和模块加载机制是不同的,前者AMD(requirejs)是将所有文件同时加载,一次性引入,推崇依赖前置,也就是在定义模块时要先声明其依赖的模块,加载完模块后会立马执行该模块(运行时加载)
而CMD(seajs)强调的是一个文件一个模块,可按需引入,推崇依赖就近,加载完某个模块后不会立即执行,而是等遇到了require语句的时候在执行 .
两者的使用加载机制不同,也就导致了AMD(requirejs)模块会提前执行,用户体验好,而CMD(seajs)性能好,因为只有在需要时候才执行,在服务器端,nodejs使用的就是cmd规范,也就是需要什么包,就引入什么包,按需加入(编译时加载)
而在Es6的语言规格中引入了模块化功能,也就很好的取代了之前的commonjs和AMD规范了,成为了浏览器和服务器的通用的模块解决方案,在现今(vuejs,ReactJS)等框架大行其道中,都引入了Es6中的模块化(Module)机制,一些自动化打包工具webpack或者微信小游戏中也同样如此
您将在本文中学习到什么是模块,以及模块的导入导出,理解了这个,在一些基于脚手架搭建的项目里或者自动化构建工具中,就不觉得写法怪怪和迷路了的
正文从这里开始~
什么是模块？ 在Es6中引入let,const定义变量是解决访问变量的全局作用域问题,从而引入块级作用域,解决命名冲突,同名全局污染,安全等问题
模块可以理解为函数代码块的功能,是封装对象的属性和方法的javascript代码,它可以是某单个文件,变量或者函数,
在Es6模块中,无论有没有加&#34;use strict&#34;,都会自动采用严格模式,而且在模块顶部创建的变量不会自动被添加全局作用域中,这个变量仅在模块的顶级作用域中存在,而且模块必须导出一些外部代码可以访问的元素,如变量或者函数,模块也可以从其他模块导入绑定
在模块与模块之间的特性与作用域关系不大(例如微信小程序或者小游戏中的各个文件就是不同的模块,在该文件定义的变量或者函数只在该文件内作用),但也很重要,在模块的顶部,this的值是undefined,另外,模块不支持HTML风格的代码注释
模块实质上是对业务逻辑分离实现低耦合高内聚,也便于代码管理而不是所有功能代码堆叠在一起,模块真正的魔力所在是仅导出和导入你需要的绑定,而不是将所有的东西都放到一个文件
引入模块与引入脚本是有区别的,前者更多是按需引入加载,后者而是无论有没有用,全部一次性引入和加载,类似于通过script标签引入jQuery等库都是一次性载入
Node中模块的导出与导入 在Node模块中,采用的是commonjs规范,也就是使用require方式引入模块,而使用module.exports导出接口,在node中,例如如下代码example.js,当然你也是可以把属性值定义到外面去的,把下面这段代码存储脚本为example
/*
* 通过module.exports将数据进行对外暴露
*/
module.exports = {
name:&#34;随笔川迹&#34;,
funA:function(){
return `我是${this.name}`
}
}
// 或者把变量函数值定义在外面，例如,与上面等价，以下是常见写法
var name = &#34;随笔川迹&#34;;
var funA = function(){
return `我是${name}`
}
module.exports = {
name:name, // 至于前面的变量名可以任意,但是在另外一模块中引入时要与该变量名保持一致,否则就会报错，也可以只写一个name
funA:funA // 也可以只写一个funA
} 而在另外一文件命名requireExample.js中使用require方式引入
/*
*
* 通过require()的方式将外部模块引入" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/60379e4f2238b1b276ed531948848c4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-09T07:00:00+08:00" />
<meta property="article:modified_time" content="2018-07-09T07:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Es6中的模块化Module,导入(import)导出(export)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: center">虽互不曾谋面,但希望能和你成为笔尖下的朋友</p> 
 <p style="text-align: center">以读书,技术,生活为主,偶尔撒点鸡汤</p> 
 <p style="text-align: center">不作,不敷衍,意在真诚吐露,用心分享</p> 
 <p style="text-align: center">点击<strong>左</strong><strong>上方</strong>,可关注本刊</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/51/60/nFX5TQH9_o.jpg" width="900"></p> 
 <h4>前言</h4> 
 <p>在Es6之前,javascript没有模块系统,它无法将一个大程序拆分成若干个互相依赖的小文件,然后在用简单的方法拼装起来.为了做到模块化,在Es6之前,引入了AMD(Asynchronous module definition)与CMD(common module definition)</p> 
 <p>前者典型代表是requireJS(外国人搞出来的),后者是seajs(国内) </p> 
 <p><strong>共同点:</strong>都是对模块定义的不同规范,都是异步加载模块,并且解决文件之间的依赖重命名冲突等问题。 </p> 
 <p><strong>不同点:</strong>模块定义的方式和模块加载机制是不同的,<strong>前者AMD(requirejs)是将所有文件同时加载,一次性引入,推崇依赖前置,也就是在定义模块时要先声明其依赖的模块,加载完模块后会立马执行该模块(运行时加载)</strong></p> 
 <p>而<strong>CMD(seajs)</strong><strong>强调的是一个文件一个模块,可按需引入,推崇依赖就近,加载完某个模块后不会立即执行,而是等遇到了require语句的时候在执行</strong> .</p> 
 <p><strong>两者的使用加载机制不同,也就导致了AMD(requirejs)模块会提前执行</strong>,<strong>用户体验好</strong>,<strong>而CMD(seajs)性能好,因为只有在需要时候才执行</strong>,<strong>在服务器端,nodejs使用的就是cmd规范,也就是需要什么包,就引入什么包,按需加入(编译时加载)</strong></p> 
 <p>而在Es6的语言规格中引入了模块化功能,也就很好的取代了之前的commonjs和AMD规范了,成为了浏览器和服务器的通用的模块解决方案,在现今(vuejs,ReactJS)等框架大行其道中,都引入了Es6中的模块化(Module)机制,一些自动化打包工具webpack或者微信小游戏中也同样如此</p> 
 <p>您将在本文中学习到什么是模块,以及模块的导入导出,理解了这个,在一些基于脚手架搭建的项目里或者自动化构建工具中,就不觉得写法怪怪和迷路了的</p> 
 <p>正文从这里开始~</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/4a/63/ne3dytLY_o.png" width="640"></p> 
 <blockquote> 
  <h4>什么是模块？</h4> 
 </blockquote> 
 <p>在Es6中引入let,const定义变量是解决访问变量的全局作用域问题,从而引入块级作用域,解决命名冲突,同名全局污染,安全等问题</p> 
 <p><strong>模块</strong>可以<strong>理解为函数代码块的功能,是封装对象的属性和方法的javascript代码,它可以是某单个文件,变量或者函数</strong>,</p> 
 <p>在Es6模块中,无论有没有加"use strict",都会自动采用严格模式,而且在模块顶部创建的变量不会自动被添加全局作用域中,这个变量仅在模块的顶级作用域中存在,而且模块必须导出一些外部代码可以访问的元素,如变量或者函数,模块也可以从其他模块导入绑定</p> 
 <p>在模块与模块之间的特性与作用域关系不大(例如微信小程序或者小游戏中的各个文件就是不同的模块,在该文件定义的变量或者函数只在该文件内作用),但也很重要,在模块的顶部,this的值是undefined,另外,模块不支持HTML风格的代码注释</p> 
 <p><strong>模块</strong><strong>实质上是对业务逻辑分离实现低耦合高内聚,也便于代码管理而不是所有功能代码堆叠在一起,模块真正的魔力所在是仅导出和导入你需要的绑定,而不是将所有的东西都放到一个文件</strong></p> 
 <p><strong>引入模块与引入脚本是有区别的</strong>,前者更多是按需引入加载,后者而是无论有没有用,全部一次性引入和加载,类似于通过script标签引入jQuery等库都是一次性载入</p> 
 <blockquote> 
  <h4>Node中模块的导出与导入</h4> 
 </blockquote> 
 <p>在Node模块中,采用的是commonjs规范,也就是使用require方式引入模块,而使用module.exports导出接口,在node中,例如如下代码example.js,当然你也是可以把属性值定义到外面去的,把下面这段代码存储脚本为example</p> 
 <pre class="has"><code class="language-go"><code>/*<br>*  通过module.exports将数据进行对外暴露<br>*/<br>module.exports = {<!-- --><br>       name:"随笔川迹",<br>       funA:function(){<!-- --><br>          return `我是${<!-- -->this.name}`<br>       }<br> }<br>// 或者把变量函数值定义在外面，例如,与上面等价，以下是常见写法<br>var name = "随笔川迹";<br>var funA = function(){<!-- --><br>    return `我是${name}`<br>}<br>module.exports = {<!-- --><br>   name:name,  // 至于前面的变量名可以任意,但是在另外一模块中引入时要与该变量名保持一致,否则就会报错，也可以只写一个name<br>   funA:funA  // 也可以只写一个funA<br>}</code></code></pre> 
 <p>而在另外一文件命名requireExample.js中使用<strong>require</strong>方式引入</p> 
 <pre class="has"><code class="language-go"><code>/*<br>*<br>*  通过require()的方式将外部模块引入<br>* <br><br> */<br> var  m =  require("./requireExample.js");<br> console.log(m.name);  // 随笔川迹 <br> console.log(m.funA()); // 我是随笔川迹</code></code></pre> 
 <p>执行结果如下图所示</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/22/a0/yvykzeje_o.png" width="1288"></p> 
 <p>以上代码是在node中,<strong>通过module.exports对外暴露变量对象,函数等常见方式,而通过require()的方式引入本地模块或者导入包</strong></p> 
 <p>这个<strong>module.exports是node提供的一个私有全局变量属性,而require也是node提供的一个私有全局方法</strong>,那么在Es6模块中并没有采用node中require导入模块的方式</p> 
 <p>在微信小程序中,暂不支持Es6中的export和import模块导出与导入的语法,它依然采用的是类似node中对外暴露数据用module.exports方式,而引入数据则用require的方式</p> 
 <p>注意:小程序中用import方式引入外部wxss是可以的,但在微信小游戏中却已经支持来Es6中的export与import模块语法</p> 
 <p>如下为小游戏测试:Es6中export与import的使用,但遗憾的是在小程序暂且还不支持Es6中模块的写法,对外暴露数据仍然采用module.export 的方式而引入模块采用require的方式,与在node中使用相似</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/14/5a/OWvDsqa5_o.png" width="1362"></p> 
 <p style="text-align: center">(微信小游戏是支持Es中的模块的)</p> 
 <blockquote> 
  <h4>如何检测node.js对Es6的支持情况</h4> 
 </blockquote> 
 <p>命令行终端下全局安装 <code>es-checker</code></p> 
 <pre class="has"><code class="language-go"><code>npm install -g es-checker</code></code></pre> 
 <p>安装后,在命令行中执行 <code>es-checker</code>命令</p> 
 <pre class="has"><code class="language-go"><code>es-checker</code></code></pre> 
 <p>在命令行终端就会有一个Es6在该node版本中支持结果:如下图所示,红色的表示是暂不支持的</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/54/cd/1FBONf3K_o.png" width="669"></p> 
 <p>另外一种检测Es6的方法是:在node的repl环境中测试,如果不支持就会报错,运行正常就说明支持Es6写法</p> 
 <p>还有一种检测方法就是:参考官方文档Es6对Node或者浏览器的支持情况具体可Ecmascript6 compatibility Table(https://kangax.github.io/compat-table/es6/),微信不支持访问外链,直接将地止复制到浏览器访问即可</p> 
 <blockquote> 
  <h4>Es6中模块导出的基本语法</h4> 
 </blockquote> 
 <p><strong>模块的导出,export关键字用于暴露数据</strong>,<strong>暴露给其他模块</strong></p> 
 <p><strong>使用方式</strong><strong>是</strong>,可以<strong>将export放在任何变量,函数或类声明的前面</strong>,从而将他们从模块导出,而<strong>import用于引入数据,</strong>例如如下所示</p> 
 <p>将下面这些js存储到exportExample.js中,分别导出的是数据,函数,类</p> 
 <pre class="has"><code class="language-go"><code>/*<br>* <br>* @authors 随笔川迹 (itclanCode@163.com) <br>* @date    2018-07-07 18:01:23<br>* @desc:导出数据<br>* */<br><br><br>// 导出数据<br> export var  name = "随笔川迹"; // 导出暴露name变量<br> export let  weChatPublic = "itclanCoder"; // 暴露weChatPublic<br> export const time = 2018; // 暴露time<br><br><br>// 导出函数<br> export function sum(num1,num2){<!-- --><br>      return num1+num2;<br> }<br>/*<br>*<br>* 以上等价于<br>* function sum(num1,num2){<!-- --><br>*    return num1+num2;<br>* }<br>* export sum;<br>* <br> */<br><br> // 导出类<br>export class People{<!-- --><br>      constructor(name,age){<!-- --><br>         this.name = name;<br>         this.age = age;<br>      }<br>      info(){<!-- --><br>         return `${<!-- -->this.name}${<!-- -->this.age}岁了`;<br>      }<br> }</code></code></pre> 
 <p>若将上面代码进行拆分</p> 
 <p><strong>1. 导出数据</strong>,变量前面加上export关键字</p> 
 <pre class="has"><code class="language-go"><code>export var  name = "随笔川迹";<br> export let  weChatPublic = "itclanCoder";<br> export const time = 2018;<br>// 上面的等价于下面的写法,以下这种是常见写法<br><br>var name = "随笔川迹";<br>let weChatPublic = "itclanCoder";<br>const time = 2018;<br><br>export {name,weChatPublic,time}</code></code></pre> 
 <p><strong>2. </strong><strong>导出函数</strong>,函数前面加上export关键字<br></p> 
 <pre class="has"><code class="language-go"><code>export function sum(num1,num2){<!-- --><br>      return num1+num2;<br>}</code></code></pre> 
 <p>也可以这样:在定义它时没有马上导出它,由于不必总是导出声明,可以导出引用,因此下面这段代码也是可以运行的</p> 
 <pre class="has"><code class="language-go"><code>function sum(num1,num2){<!-- --><br>       return num1+num2;<br>}<br>// 之后将其导出<br>export sum;</code></code></pre> 
 <p>注意:一个模块就是一个独立的文件,该文件内部的所有变量,外部无法获取,同样,任何未显示导出的变量,函数或类都是模块私有的,若没有用export对外暴露,是无法从模块外部访问的 例如:</p> 
 <pre class="has"><code class="language-go"><code>function countResult(num1,num2){<!-- --><br>       return num1-num2;<br> }<br>// 没有通过export关键字导出,在外部是无法访问该模块的变量或者函数的</code></code></pre> 
 <p><strong>3.</strong> <strong>导出类</strong>,类前面加上export关键字</p> 
 <pre class="has"><code class="language-go"><code>export class People{<!-- --><br>      constructor(name,age){<!-- --><br>         this.name = name;<br>         this.age = age;<br>      }<br>      info(){<!-- --><br>         return `${<!-- -->this.name}${<!-- -->this.age}`<br>      }<br>}</code></code></pre> 
 <p>对应在另一个模块中通过import导入如下所示,模块命名为importExample.js</p> 
 <pre class="has"><code class="language-go"><code>/*<br>*<br>* @desc:从exportExample模块中导入数据,通过import的方式<br>* @说明:由于我在node环境中测试,因为node暂且不支持Es6中的module语法,所以得先把es6代码通过babel转化成Es5代码,方可在node环境中执行该脚本，from后面具体路径引入的应该是通过Es6转化为Es5的代码<br>* <br><br> */<br><br>import { name, weChatPublic,time,sum,People} from "../modelTest1/exportExampleEs5.js"<br><br>var people = new People("小美",18); // 实例化perople对象<br>console.log(name);<br>console.log(weChatPublic);<br>console.log(time);<br>console.log(sum(1,2));<br>console.log(people.info());</code></code></pre> 
 <p><strong>注意1</strong>:在上面的示例中,除了export关键字外,每一个声明与脚本中的一模一样,因为导出的函数和类声明需要有一个名称,所以代码中的每一个函数或类也确实有这个名称,除非用default关键字,否则不能用这个语法导出匿名函数或类</p> 
 <p><strong>注意2</strong>:因为在现今node版本环境中,目前还不直接支持export和import语法,也就是说在node环境中,直接写Es6的模块代码,用node执行js脚本,会抛出错误,所以得先把Es6转换成Es5版本的代码,然后在node环境下运行该脚本才不会报错,这种转换方式可以通过babel进行转化</p> 
 <p>安装babel如下所示:<strong>命令行终端下通过npm全局安装babel-cli</strong></p> 
 <pre class="has"><code class="language-go"><code>npm install --global babel-cli<br>npm install --save babel-preset-es2015</code></code></pre> 
 <p>然后在当前目录下新建配置文件.babelrc,注意存储的位置不要带有中文路径,否则使用babel命令时会抛出错误<br></p> 
 <pre class="has"><code class="language-go"><code>{<!-- --><br>  "presets":["es2015"]<br>}</code></code></pre> 
 <p>在编写好es6代码后通过 <code>babel Es6源脚本 -o Es5脚本</code> 这里的-o或--out-file指的从Es6标准格式转化生成的输出Es5文件<br></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/1d/fd/6VgIggZK_o.png" width="1289"></p> 
 <p style="text-align: center">（在node环境中babel进行转化为Es5代码执行）</p> 
 <p>让我们对比看一下,其实在node中Es6中的export通过babel编译后Es5中代码是以exports方式进行导出的,而Es6中的import导入模块通过babel编译后是通过转变为require的方式引入的：<br></p> 
 <p>如下对比所示:Es6中export导出模块代码</p> 
 <pre class="has"><code class="language-go"><code>/*<br>* <br>* @authors 随笔川迹 (itclanCode@163.com) <br>* @date    2018-07-07 18:01:23<br>* @desc:导出数据<br>* */<br><br><br>// 导出数据<br> export var  name = "随笔川迹"; // 导出暴露name变量<br> export let  weChatPublic = "itclanCoder"; // 暴露weChatPublic<br> export const time = 2018; // 暴露time<br><br><br>// 导出函数<br> export function sum(num1,num2){<!-- --><br>      return num1+num2;<br> }<br>/*<br>*<br>* 以上等价于<br>* function sum(num1,num2){<!-- --><br>*    return num1+num2;<br>* }<br>* export sum;<br>* <br> */<br>function multiply(num1,num2){<!-- --><br>   return num1+num2;<br>}<br>export multiply;<br> // 导出类<br>export class People{<!-- --><br>      constructor(name,age){<!-- --><br>         this.name = name;<br>         this.age = age;<br>      }<br>      info(){<!-- --><br>         return `${<!-- -->this.name}${<!-- -->this.age}岁了`;<br>      }<br> }</code></code></pre> 
 <p>通过babel编译转变为Es5代码:</p> 
 <pre class="has"><code class="language-go"><code>"use strict";<br><br>Object.defineProperty(exports, "__esModule", {<!-- --><br>    value: true<br>});<br><br>var _createClass = function() {<!-- --><br>    function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i];<br>            descriptor.enumerable = descriptor.enumerable || false;<br>            descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;<br>            Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();<br><br>exports.sum = sum;<br><br>function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }<br><br>/*<br> * <br> * @authors 随笔川迹 (itclanCode@163.com) <br> * @date    2018-07-07 18:01:23<br> * @desc:导出数据<br> * */<br><br>// 导出数据<br>var name = exports.name = "随笔川迹"; // 导出暴露name变量<br>var weChatPublic = exports.weChatPublic = "itclanCoder"; // 暴露weChatPublic<br>var time = exports.time = 2018; // 暴露time<br>var flag = true;<br><br><br><br>// 导出函数<br>function sum(num1, num2) {<!-- --><br>    return num1 + num2;<br>}<br>/*<br> *<br> * 以上等价于<br> * function sum(num1,num2){<!-- --><br> *    return num1+num2;<br> * }<br> * export sum;<br> * <br> */<br><br>// 导出类<br><br>var People = exports.People = function() {<!-- --><br>    function People(name, age) {<!-- --><br>        _classCallCheck(this, People);<br><br>        this.name = name;<br>        this.age = age;<br>    }<br><br>    _createClass(People, [{<!-- --><br>        key: "info",<br>        value: function info() {<!-- --><br>            return "" + this.name + this.age + "\u5C81\u4E86";<br>        }<br>    }]);<br><br>    return People;<br>}();</code></code></pre> 
 <p>而在另一个模块中importExample.js中,这里是Es6中import导入模块的代码</p> 
 <pre class="has"><code class="language-go"><code>/*<br>*<br>* @desc:从exportExample模块中导入数据,通过import的方式<br>* <br><br> */<br><br>import { name, weChatPublic,time,sum,People} from "../modelTest1/exportExampleEs5.js"<br><br>var people = new People("小美",18); // 实例化perople对象<br>console.log(name);<br>console.log(weChatPublic);<br>console.log(time);<br>console.log(sum(1,2));<br>console.log(people.info());</code></code></pre> 
 <p>在node中通过babel编译转化为Es5代码后,import相当于require的作用,但是他们两者是不同的,前者是按需引入,而后者是一次性全部引入</p> 
 <pre class="has"><code class="language-go"><code>"use strict";<br><br>var _exportExampleEs = require("../modelTest1/exportExampleEs5.js");<br><br>var people = new _exportExampleEs.People("小美", 18); // 实例化perople对象<br>/*<br>*<br>* @desc:从exportExample模块中导入数据,通过import的方式<br>* <br><br> */<br><br>console.log(_exportExampleEs.name);<br>console.log(_exportExampleEs.weChatPublic);<br>console.log(_exportExampleEs.time);<br>console.log((0, _exportExampleEs.sum)(1, 2));<br>console.log(people.info());</code></code></pre> 
 <blockquote> 
  <h4>Es6中模块导入的基本语法·</h4> 
 </blockquote> 
 <p>如果想从一个文件(模块)访问另一个文件(模块)的功能,则需要通过import关键字在另一个模块中引入数据,<strong>import语句的两个部分组成分别是</strong>:<strong>要导入的标识符</strong>和<strong>标识符应当从那个模块导入</strong>,<strong>另外,导入的标识符的顺序可以是任意位置,但是导入的标识符(也就是大括号里面的变量)与export暴露出的变量名应该是一致的</strong> 具体的写法如下:</p> 
 <pre class="has"><code class="language-go"><code>import {identifer1,indentifer2}  from "./example.js"  // import {标识符1，标识符2} from "本地模块路径"</code></code></pre> 
 <p><strong>import后面的双大括号表示从后面给定的模块导入的绑定</strong>,<strong>关键字from表示从哪个模块导入给定的绑定,</strong><strong>该模块由表示模块路径的字符串指定</strong>(被称为模块说明符),如果在浏览器中,使用路径格式与&lt;script&gt;元素的相同,也就是说,必须把文件拓展名也加上</p> 
 <p><strong>注意</strong>:<strong>在nodejs中,区分加前缀和不加前缀,不加路径前缀的表示的是包,而加入路径前缀的表示本地文件</strong>,例如:require("http")引入的是一个包;而require("./http.js")引入的是一个本地文件<br></p> 
 <p><strong>注意</strong>:导入绑定的列表看起来与解构对象很相似,但两者不是一样的</p> 
 <p>当从模块中导入一个绑定时,它就好像使用了const定义的一样<strong>,也就是自动默认使用严格模式,你无法定义另一个同名变量(包括导入另一个同名绑定),也无法在import语句前使用标识符或改变绑定的值</strong></p> 
 <h4><strong>1. 导入单个绑定</strong></h4> 
 <p>假设前面的实例在一个名为ExportExample.js的模块当中,我们可以导入并以多种方式使用这个模块中的绑定,可以只导入一个标识符:例如:</p> 
 <pre class="has"><code class="language-go"><code>// 只导入一个<br>  import {sum} from "./example.js"<br><br>  console.log(sum(1,2));  // 3<br>  sum = 1; // 抛出一个错误,是不能对导入的绑定变量对象进行改写操作的</code></code></pre> 
 <p>尽管ExportExample.js导出的函数不止一个,但这个示例导入的却只有sum()函数,如果尝试给sum赋新值,那么就会抛出一个错误,因为<strong>不能给导入的绑定重新赋值</strong> <strong>为了兼容多个浏览器和Nodejs坏境,一定要在字符串之前包含/,./或../来表示要导入的文件</strong></p> 
 <p><strong>2. 导入多个绑定</strong></p> 
 <p>如果想从示例模块中导入多个绑定,与单个绑定相似,多个绑定值之间用逗号隔开即可</p> 
 <pre class="has"><code class="language-go"><code>// 导入多个<br>import {sum,multiply,time} from "./exportExample.js"<br>console.log(sum(1,2)); // 3<br>console.log(multiply(1,2)); // 3<br>console.log(time);  // 2018</code></code></pre> 
 <p>在这段代码中,从exportExample.js模块导入3个绑定,sum,multiply和time之后使用它们,就像使用本地定义的一样 等价于下面这个: <strong>不管在import语句中把一个模块写了多少次,该模块将只执行一次,导入模块的代码执行后,实例化过的模块被保存在内存中,</strong>只要另一个import语句使用它就可以重复使用它</p> 
 <pre class="has"><code class="language-go"><code>import {sum} from "./exportExample.js"<br>import {multiply} from "./exportExample.js"<br>import {time} from "./exportExample.js</code></code></pre> 
 <p><strong>3. Es6中导入整个模块</strong></p> 
 <p>特殊情况下,可以导入整个模块作为一个单一的对象,然后所有的导出都可以作为对象的属性使用,例如:</p> 
 <pre class="has"><code class="language-go"><code>// 导入一整个模块<br>import * as example from "./exportExample.js"<br>console.log(example.sum(1,example.time));<br>consoole.log(example.multiply(1,2));// multiply与sum函数功能一样</code></code></pre> 
 <p>在上面这段代码中,从本地模块的exportExample.js中导出的所有绑定被加载到一个被称作为example的对象中,指定的导出sum()函数,multiply()函数和time之后作为example的属性被访问,这种导入格式被称为<strong>命名空间导入</strong>,因为exportExample.js文件中不存在example对象,所以它被作为exportExample.js中所有导出成员的命名空间对象而被创建</p> 
 <blockquote> 
  <h4>Es6中模块语法的限制</h4> 
 </blockquote> 
 <p>export和import的一个重要的限制是,他们必须在其他语句和函数之外使用,例如,下面的代码会给出一个语法错误</p> 
 <pre class="has"><code class="language-go"><code>if(flag){<!-- --><br>      export flag; // 语法错误<br> }</code></code></pre> 
 <p>下面以在微信小游戏中测试为证</p> 
 <p><img src="https://images2.imgbox.com/61/27/8k5N6dQ9_o.png" width="1347"></p> 
 <p style="text-align: center">(export必须在函数其他语句之外使用否则会报错)</p> 
 <p>export和import的一个重要的限制是,他们必须在其他语句和函数之外使用,例如,下面的代码会给出一个语法错误</p> 
 <p>export语句不允许出现在if语句中,不能有条件导出或以任何方式动态导出,也就是说export命令规定的是对外的接口,必须与模块内部的变量建立一一对应的关系,不能这样写: <code>export 5;</code>或者 <code>var num = 5; export num;</code>必须得加上大括号 <code>{变量名}</code>去暴露它 模块语法存在的一个原因是要让javascipt引擎静态的确定哪些可以导出,因此,只能在模块顶部使用export</p> 
 <p>同样,不能在一条语句中使用import,只能在顶部使用它(这也是为什么很多框架在业务逻辑代码之前,需要什么插件,都得提前引入),如下代码所示,import语句也不能放在一条语句当中</p> 
 <pre class="has"><code class="language-go"><code>function testImport(){<!-- --><br>      import flag  from "./ExportExample.js"   // 语法错误<br>  }</code></code></pre> 
 <p>下面时在微信小游戏中测试可证</p> 
 <p><img src="https://images2.imgbox.com/68/a7/ofAleRb1_o.png" width="1360"></p> 
 <p style="text-align: center">（import也不能在其他语句或者函数内使用,否则会报错）</p> 
 <p style="text-align: left">由于同样的原因,<strong>不能动态的导入或导出绑定,export和import关键字被设计成静态的</strong> 以上这种<strong>通过import导入模块与require的写法的具体区别是</strong>:</p> 
 <p style="text-align: left"><strong>import 导入的方式更加灵活随意一些,要想用哪个变量,函数,模块就导入哪一个,按需加载</strong>,现在想想在使用框架当中,使用某个UI库里面的某单个组件,使用import导入单个组件而非全部一次性引入的原因了.</p> 
 <p style="text-align: left"><strong>而使用require是全部都引入了的</strong>，<strong>若想要更加效率的话,那么推崇import导入的方式</strong> </p> 
 <p style="text-align: left">例1:全局完整引入,没有大括号,从element-ui库中引入Element,当然在vue中,还得Vue.use(插件名)全局注册一下</p> 
 <pre class="has"><code class="language-go"><code>import Element from 'element-ui';<br>Vue.use(Element);</code></code></pre> 
 <p style="text-align: left">例2:从element-ui库中导入两个Button,Select组件<br></p> 
 <pre class="has"><code class="language-go"><code>import { Button, Select } from 'element-ui<br>Vue.use(Button);<br>Vue.use(Select);</code></code></pre> 
 <blockquote> 
  <h4>Es6中如何给导入导出时标识符重命名</h4> 
 </blockquote> 
 <p>从一个模块导入变量,函数或者类时,我们可能不希望使用他们的原始名称,<strong>就是导入导出时模块内的标识符(变量名,函数,或者类)可以不用一一对应,保持一致</strong>,<strong>可以在导出和导入过程中改变导出变量对象的名称</strong></p> 
 <p><strong>使用方式</strong>: <strong>使用</strong><strong>as</strong><strong>关键字来指定变量,函数,或者类在模块外应该被称为什么名称</strong> 例如如下一函数</p> 
 <pre class="has"><code class="language-go"><code>function sum(num1,num2){<!-- --><br>     return num1+num2;<br>}<br><br>export {sum as add} // as后面是重新指定的函数名</code></code></pre> 
 <p>如上代码,函数sum是本地名称,add是导出时使用的名称,换句话说,<strong>当另一个模块要导入这个函数时,必须使用add这个名称</strong><br></p> 
 <p>若在importExample.js一模块中,则导入的变量对象应是add而不是sum，是由它导出时变量对象决定的</p> 
 <pre class="has"><code class="language-go"><code>import  {add} from "./exportExample.js"</code></code></pre> 
 <p>如果模块想使用不同的名称来导入函数,也可以使用as关键字</p> 
 <pre class="has"><code class="language-go"><code>import {add as sum} from "./exportExample.js"<br> console.log(sum(1,2)); // 3<br> console.log(typeof add); // undefined</code></code></pre> 
 <p style="text-align: left">如上代码导入add函数时使用了一个导入名称来重命名sum函数,注意这种写法与前面导出export时的区别,使用import方式时,重新命名的标识符在前面,as后面是本地名称,但是这种方式,即使导入时改变函数的本地名称,即使模块导入了add函数,在当前模块中也没有add()标识符,如上对add的类型检测就是很好的验证</p> 
 <blockquote> 
  <h4>Es6中导入绑定时的一个注意点,导入定义时的变量无法更改</h4> 
 </blockquote> 
 <p><strong>在Es6中的import语句为变量,函数,类创建的目的是只读绑定所要导入的对象,并不是像正常变量一样简单的引用原始绑定</strong>,<strong>标识符只有在被导出的模块中可以修改（也就是只能在export模块中修改）,当导入绑定的模块后,它是无法更改绑定的值的(在import中无法对已导入绑定的变量作修改)</strong>,from前面的就是绑定的变量对象,例如:如下代码所示</p> 
 <pre class="has"><code class="language-go"><code>import {name,setName}  from "./exportExample.js"  // from前面双大括号中的变量对象是不可以被修改的,想尝试修改就会报错<br><br>console.log(name);  // 随笔川迹,此时访问name是全局变量<br>setName("好好先生");<br>console.log(name);  // 好好先生，函数内的同名变量会覆盖全局变量<br>name = "itclanCoder"  // 抛出错误,此处的name并非导入时name</code></code></pre> 
 <p><img src="https://images2.imgbox.com/d2/3c/LOSjUWid_o.png" width="1360"></p> 
 <p style="text-align: left">当想尝试更改导入时变量对象的名称时,就会抛出错误</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/e5/85/wNizdI4f_o.png" width="1354"></p> 
 <p style="text-align: center">（在导入模块中,修改导入变量对象是会抛出错误的，不允许被修改,想修改,应当滚回导出模块中修改变量对象的值）</p> 
 <p style="text-align: left">如上代码:当调用setName("好好先生")时会回到导出setName()的模块中去执行,并将name设置为好好先生,通过import导入的name标识符是export导出时的name标识符本地名称</p> 
 <p style="text-align: left">总结</p> 
 <p>本文主要从什么是模块,Node中模块的导出与导入,如何检测node.js对Es6的支持情况 ,以及在Node中通过babel将es6代码转化为Es5代码在Node中执行,模块的导出(导出数据,函数和类)模块的导入(单个导入,多个导入,导入整个)</p> 
 <p>模块中<strong>在用export关键字导出所要暴露的对象和用import关键字导入暴露的对象中</strong>,<strong>导入的变量对象需要和导出的保持一致,当然也可以通过as关键字进行重命名,并且模块导入的变量对象无法被改写,如果要改写,那么需要到export所暴露对象的模块中进行改写</strong></p> 
 <p> 在模块化项目里,从模块中导出导入是如今非常常见的做法,<strong>如果在不给导出的标识符(变量,函数,类)呢,那么可以通过导出default关键字指定单个变量,函数或者类,预知后文详情,可持续关注了</strong></p> 
 <p>关于模块化处理在未来的标准中非常重要,为<strong>什么初次看到那些脚手架生成的代码,文件导出导入,有些摸不透的,不知所云的</strong>,<strong>就是因为加入了Es6中的模块化知识</strong>,与AMD比较也好,还是CMD也罢,是有些区别的,本人初学者笔记学习心得,如果文章中有误导的地方,欢迎路过的老师多提意见和指正</p> 
 <hr> 
 <p><strong>推荐阅读</strong></p> 
 <ul><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b48fedb5cc1e894f011d5807c71f9fb3d506e66c826230da4b025e37d4b7c5bd0aa2b79e0&amp;idx=1&amp;mid=2247484770&amp;scene=21&amp;sn=8804475883148c1f28a8122fd7361e7c#wechat_redirect" rel="nofollow">链接关系,相互陪伴,见证成长</a><br></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b48d2db5cc1c44ae2aca00b994fb12ce2ea3de7689a1ef7320006f9ef1ffbb0b1b502f288&amp;idx=1&amp;mid=2247484750&amp;scene=21&amp;sn=f1bdefcede366f6893f471a8e352c52e#wechat_redirect" rel="nofollow">电脑本地,WiFi都能连上,但就是上不去网</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b48afdb5cc1b91792d8cb278d833aa1f1b9de9f91c57814809833a546b56ad03c924cc78c&amp;idx=1&amp;mid=2247484723&amp;scene=21&amp;sn=7a4b0af4a5ddb93b5427e41d94f73bb7#wechat_redirect" rel="nofollow">如何序列化Js中的并发操作:回调,承诺和异步等待</a><strong><br></strong></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b49eedb5cc0f8f8714c95e42db4f9c1c15e21daec57b1e398f7bcef58a4cd42fd87eb5eb5&amp;idx=1&amp;mid=2247484530&amp;scene=21&amp;sn=b8414ed51a609f8d54c70fd80480a71b#wechat_redirect" rel="nofollow">关于社交圈子的一点思考</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b490edb5cc0189f2c1a641316fba5e29f1442903ee49f5d77ce9b25ab1908ffcb0845de39&amp;idx=1&amp;mid=2247484562&amp;scene=21&amp;sn=050ecb8390e38915dc896e4797cce84a#wechat_redirect" rel="nofollow">js中的正则表达式(2)</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b490edb5cc018d92ea09c1e0125b95926c87880c49313df41dae8c1661112119c5760a25c&amp;idx=2&amp;mid=2247484562&amp;scene=21&amp;sn=bf6f9feee60fe665443218c632e48b19#wechat_redirect" rel="nofollow">js中的正则表达式(1)</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b4913db5cc0050af85d2a0f0cdd61ada166d8e36c3a26c1c4ca8a9700614b28a5d11ded56&amp;idx=1&amp;mid=2247484559&amp;scene=21&amp;sn=6fd2cb2116780fb7a4212d7f052d8902#wechat_redirect" rel="nofollow">手势魅力-设置一个触摸菜单</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b4913db5cc0050af85d2a0f0cdd61ada166d8e36c3a26c1c4ca8a9700614b28a5d11ded56&amp;idx=1&amp;mid=2247484559&amp;scene=21&amp;sn=6fd2cb2116780fb7a4212d7f052d8902#wechat_redirect" rel="nofollow"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b49fcdb5cc0eaf97a081e1c0e6b487091529aaf171fde03938a34431da19e3d12af05b5ad&amp;idx=1&amp;mid=2247484512&amp;scene=21&amp;sn=c4d53e9d42a637e51b9e6050710c999c#wechat_redirect" rel="nofollow">js之工厂构造函数模式</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ%3D%3D&amp;chksm=ec2b49ccdb5cc0dada860e87750679662ad084a5b1a93dd1a43c205da8545d0ebe4a4bd07b2d&amp;idx=1&amp;mid=2247484496&amp;scene=21&amp;sn=a6acb3dd15d370427351fe8abdeb0a81#wechat_redirect" rel="nofollow">现代web开发方法</a></p></li></ul> 
 <p><strong><strong>作者</strong>：</strong>川川,一个靠前排的90后帅小伙,具有情怀的代码男,路上正追逐斜杠青年的践行者,愿做你耳朵旁边的枕男,眼睛笔尖下的窗户</p> 
 <hr> 
 <p style="text-align: center">随手点赞</p> 
 <p style="text-align: center">手留余香</p> 
 <hr> 
 <p style="text-align: center"><strong>(个人微信:suibichuanji) </strong></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/2d/11/CniZR7S8_o.png" width="364"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/67/18/sd7kt9SN_o.png" width="640"></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be8b17cc9a9538b7d4dc1509834c9a4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Pyinstaller打包多个.py文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba6055491e81e1b473523eb02173e885/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebGL学习笔记（3）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>