<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Scala基础教程--19--Actor - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Scala基础教程--19--Actor" />
<meta property="og:description" content="Scala基础教程–19–Actor 章节目标 了解Actor的相关概述掌握Actor发送和接收消息掌握WordCount案例 1. Actor介绍 Scala中的Actor并发编程模型可以用来开发比Java线程效率更高的并发程序。我们学习Scala Actor的目的主要是为后续学习Akka做准备。
1.1 Java并发编程的问题 在Java并发编程中，每个对象都有一个逻辑监视器（monitor），可以用来控制对象的多线程访问。我们添加sychronized关键字来标记，需要进行同步加锁访问。这样，通过加锁的机制来确保同一时间只有一个线程访问共享数据。但这种方式存在资源争夺、以及死锁问题，程序越大问题越麻烦。
线程死锁
1.2 Actor并发编程模型 Actor并发编程模型，是Scala提供给程序员的一种与Java并发编程完全不一样的并发编程模型，是一种基于事件模型的并发机制。Actor并发编程模型是一种不共享数据，依赖消息传递的一种并发编程模式，有效避免资源争夺、死锁等情况。
1.3 Java并发编程对比Actor并发编程 Java内置线程模型Scala Actor模型&#34;共享数据-锁&#34;模型 (share data and lock)share nothing每个object有一个monitor，监视线程对共享数据的访问不共享数据，Actor之间通过Message通讯加锁代码使用synchronized标识死锁问题每个线程内部是顺序执行的每个Actor内部是顺序执行的 注意:
scala在2.11.x版本中加入了Akka并发编程框架，老版本已经废弃。
Actor的编程模型和Akka很像，我们这里学习Actor的目的是为学习Akka做准备。
2. 创建Actor 我们可以通过类(class)或者单例对象(object), 继承Actor特质的方式, 来创建Actor对象.
2.1 步骤 定义class或object继承Actor特质重写act方法调用Actor的start方法执行Actor 注意: 每个Actor是并行执行的, 互不干扰.
2.2 案例一: 通过class实现 需求
创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20使用class继承Actor实现.（如果需要在程序中创建多个相同的Actor） 参考代码
import scala.actors.Actor //案例:Actor并发编程入门, 通过class创建Actor object ClassDemo01 { //需求: 创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20 //1. 创建Actor1, 用来打印1~10的数字. class Actor1 extends Actor { override def act(): Unit = for (i &lt;- 1 to 10) println(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/6156a37624808aff89af748d5be77f70/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-30T14:15:45+08:00" />
<meta property="article:modified_time" content="2022-06-30T14:15:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Scala基础教程--19--Actor</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Scala19Actor_0"></a>Scala基础教程–19–Actor</h2> 
<h4><a id="_2"></a>章节目标</h4> 
<ol><li>了解Actor的相关概述</li><li>掌握Actor发送和接收消息</li><li>掌握WordCount案例</li></ol> 
<hr> 
<h4><a id="1_Actor_10"></a>1. Actor介绍</h4> 
<p>Scala中的Actor并发编程模型可以用来开发比Java线程效率更高的并发程序。我们学习Scala Actor的目的主要是为后续学习Akka做准备。</p> 
<h5><a id="11_Java_14"></a>1.1 Java并发编程的问题</h5> 
<p>在Java并发编程中，每个对象都有一个逻辑监视器（monitor），可以用来控制对象的多线程访问。我们添加sychronized关键字来标记，需要进行同步加锁访问。这样，通过加锁的机制来确保同一时间只有一个线程访问共享数据。但这种方式存在资源争夺、以及死锁问题，程序越大问题越麻烦。<br> <img src="https://images2.imgbox.com/9c/be/FLxFcLt8_o.png" alt="在这里插入图片描述"></p> 
<p><strong>线程死锁</strong><br> <img src="https://images2.imgbox.com/0e/52/2TRldro1_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="12_Actor_24"></a>1.2 Actor并发编程模型</h5> 
<p>Actor并发编程模型，是Scala提供给程序员的一种与Java并发编程完全不一样的并发编程模型，是一种基于事件模型的并发机制。Actor并发编程模型是一种不共享数据，依赖消息传递的一种并发编程模式，有效避免资源争夺、死锁等情况。</p> 
<p><img src="https://images2.imgbox.com/c4/c4/YXkNLYPz_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="13_JavaActor_31"></a>1.3 Java并发编程对比Actor并发编程</h5> 
<table><thead><tr><th>Java内置线程模型</th><th>Scala Actor模型</th></tr></thead><tbody><tr><td>"共享数据-锁"模型 (share data and lock)</td><td>share nothing</td></tr><tr><td>每个object有一个monitor，监视线程对共享数据的访问</td><td>不共享数据，Actor之间通过Message通讯</td></tr><tr><td>加锁代码使用synchronized标识</td><td></td></tr><tr><td>死锁问题</td><td></td></tr><tr><td>每个线程内部是顺序执行的</td><td>每个Actor内部是顺序执行的</td></tr></tbody></table> 
<blockquote> 
 <p>注意:</p> 
 <ol><li> <p>scala在2.11.x版本中加入了Akka并发编程框架，老版本已经废弃。</p> </li><li> <p>Actor的编程模型和Akka很像，我们这里学习Actor的目的是为学习Akka做准备。</p> </li></ol> 
</blockquote> 
<h4><a id="2_Actor_49"></a>2. 创建Actor</h4> 
<p>我们可以通过类(class)或者单例对象(object), 继承Actor特质的方式, 来创建Actor对象.</p> 
<h5><a id="21__53"></a>2.1 步骤</h5> 
<ol><li>定义class或object继承Actor特质</li><li>重写act方法</li><li>调用Actor的start方法执行Actor</li></ol> 
<blockquote> 
 <p>注意: 每个Actor是并行执行的, 互不干扰.</p> 
</blockquote> 
<h5><a id="22__class_61"></a>2.2 案例一: 通过class实现</h5> 
<p><strong>需求</strong></p> 
<ol><li>创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20</li><li>使用class继承Actor实现.（如果需要在程序中创建多个相同的Actor）</li></ol> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token keyword">import</span> <span class="token namespace">scala<span class="token punctuation">.</span>actors<span class="token punctuation">.</span></span>Actor

<span class="token comment">//案例:Actor并发编程入门, 通过class创建Actor</span>
<span class="token keyword">object</span> ClassDemo01 <span class="token punctuation">{<!-- --></span>

  <span class="token comment">//需求: 创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20</span>
  <span class="token comment">//1. 创建Actor1, 用来打印1~10的数字.</span>
  <span class="token keyword">class</span> Actor1 <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span> println<span class="token punctuation">(</span><span class="token string">"actor1: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//2. 创建Actor2, 用来打印11~20的数字.</span>
  <span class="token keyword">class</span> Actor2 <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">11</span> to <span class="token number">20</span><span class="token punctuation">)</span> println<span class="token punctuation">(</span><span class="token string">"actor2: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 启动两个Actor.</span>
    <span class="token keyword">new</span> Actor1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">new</span> Actor2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="23__object_97"></a>2.3 案例二: 通过object实现</h5> 
<p><strong>需求</strong></p> 
<ol><li>创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20</li><li>使用object继承Actor实现.（如果在程序中只创建一个Actor）</li></ol> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token keyword">import</span> <span class="token namespace">scala<span class="token punctuation">.</span>actors<span class="token punctuation">.</span></span>Actor

<span class="token comment">//案例:Actor并发编程入门, 通过object创建Actor</span>
<span class="token keyword">object</span> ClassDemo02 <span class="token punctuation">{<!-- --></span>
  <span class="token comment">//需求: 创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20</span>

  <span class="token comment">//1. 创建Actor1, 用来打印1~10的数字.</span>
  <span class="token keyword">object</span> Actor1 <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span> println<span class="token punctuation">(</span><span class="token string">"actor1: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//2. 创建Actor2, 用来打印11~20的数字.</span>
  <span class="token keyword">object</span> Actor2 <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">11</span> to <span class="token number">20</span><span class="token punctuation">)</span> println<span class="token punctuation">(</span><span class="token string">"actor2: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 启动两个Actor.</span>
   Actor1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
   Actor2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="24_Actor_131"></a>2.4 Actor程序运行流程</h5> 
<ol><li>调用start()方法启动Actor</li><li>自动执行<strong>act</strong>()方法</li><li>向Actor发送消息</li><li>act方法执行完成后，程序会调用**exit()**方法结束程序执行.</li></ol> 
<h4><a id="3__140"></a>3. 发送消息/接收消息</h4> 
<p>我们之前介绍Actor的时候，说过Actor是基于事件（消息）的并发编程模型，那么Actor是如何发送消息和接收消息的呢？</p> 
<h5><a id="31__144"></a>3.1 使用方式</h5> 
<h6><a id="311__146"></a>3.1.1 发送消息</h6> 
<p>我们可以使用三种方式来发送消息：</p> 
<table><thead><tr><th><strong>！</strong></th><th><strong>发送异步消息，没有返回值</strong></th></tr></thead><tbody><tr><td><strong>!?</strong></td><td><strong>发送同步消息，等待返回值</strong></td></tr><tr><td><strong>!!</strong></td><td><strong>发送异步消息，返回值是Future[Any]</strong></td></tr></tbody></table> 
<p>例如：要给actor1发送一个异步字符串消息，使用以下代码：</p> 
<pre><code class="prism language-scala">actor1 <span class="token operator">!</span> <span class="token string">"你好!"</span>
</code></pre> 
<h6><a id="312__163"></a>3.1.2 接收消息</h6> 
<p>Actor中使用<code>receive方法</code>来接收消息，需要给receive方法传入一个偏函数</p> 
<pre><code class="prism language-scala"><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> 变量名<span class="token number">1</span><span class="token operator">:</span>消息类型<span class="token number">1</span> <span class="token keyword">=&gt;</span> 业务处理<span class="token number">1</span>
    <span class="token keyword">case</span> 变量名<span class="token number">2</span><span class="token operator">:</span>消息类型<span class="token number">2</span> <span class="token keyword">=&gt;</span> 业务处理<span class="token number">2</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>注意: receive方法只接收一次消息，接收完后继续执行act方法</p> 
</blockquote> 
<h5><a id="32___179"></a>3.2 案例一: 发送及接收一句话</h5> 
<p><strong>需求</strong></p> 
<ol><li>创建两个Actor（ActorSender、ActorReceiver）</li><li>ActorSender发送一个异步字符串消息给ActorReceiver</li><li>ActorReceiver接收到该消息后，打印出来</li></ol> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wLuMBeNp-1656569569791)(D:/%E6%95%99%E6%A1%88/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E5%8C%97%E4%BA%AC31~40%E6%9C%9F/%E5%8C%97%E4%BA%AC34%E6%9C%9F/Day03_Scala%E7%AC%AC%E4%B8%89%E5%A4%A9/%E8%AE%B2%E4%B9%89/%E5%90%88%E5%B9%B6%E7%89%88/assets/1552791021244.png)]</p> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token comment">//案例: 采用 异步无返回的形式, 发送消息.</span>
<span class="token keyword">object</span> ClassDemo03 <span class="token punctuation">{<!-- --></span>
  <span class="token comment">//1. 创建发送消息的Actor, ActorSender, 发送一句话给ActorReceiver</span>
  <span class="token keyword">object</span> ActorSender <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//发送一句话给ActorReceiver</span>
      ActorReceiver <span class="token operator">!</span> <span class="token string">"你好啊, 我是ActorSender!"</span>

      <span class="token comment">//发送第二句话</span>
      ActorReceiver <span class="token operator">!</span> <span class="token string">"你叫什么名字呀? "</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//2. 创建接收消息的Actor, ActorReceiver</span>
  <span class="token keyword">object</span> ActorReceiver <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//接收发送过来的消息.</span>
      receive <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> x<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 启动两个Actor</span>
    ActorSender<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ActorReceiver<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="33___225"></a>3.3 案例二: 持续发送和接收消息</h5> 
<p>如果我们想实现<code>ActorSender一直发送消息, ActorReceiver能够一直接收消息</code>，该怎么实现呢？</p> 
<p>答: 我们只需要使用一个while(true)循环，不停地调用receive来接收消息就可以啦。</p> 
<p><strong>需求</strong></p> 
<ol><li>创建两个Actor（ActorSender、ActorReceiver）</li><li>ActorSender持续发送一个异步字符串消息给ActorReceiver</li><li>ActorReceiver持续接收消息，并打印出来</li></ol> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token comment">//案例:Actor 持续发送和接收消息.</span>
<span class="token keyword">object</span> ClassDemo04 <span class="token punctuation">{<!-- --></span>
  <span class="token comment">//1. 创建发送消息的Actor, ActorSender, 发送一句话给ActorReceiver</span>
  <span class="token keyword">object</span> ActorSender <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">//发送一句话给ActorReceiver</span>
          ActorReceiver <span class="token operator">!</span> <span class="token string">"你好啊, 我是ActorSender!"</span>
          <span class="token comment">//休眠3秒.</span>
          TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>       <span class="token comment">//单位是: 秒</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//2. 创建接收消息的Actor, ActorReceiver</span>
  <span class="token keyword">object</span> ActorReceiver <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//接收发送过来的消息,  持续接收.</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        receive <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">case</span> x<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 启动两个Actor</span>
    ActorSender<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ActorReceiver<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="34___276"></a>3.4 案例三: 优化持续接收消息</h5> 
<p>上述代码，是用while循环来不断接收消息的, 这样做可能会遇到如下问题:</p> 
<ul><li>如果当前Actor没有接收到消息，线程就会处于阻塞状态</li><li>如果有很多的Actor，就有可能会导致很多线程都是处于阻塞状态</li><li>每次有新的消息来时，重新创建线程来处理</li><li>频繁的线程创建、销毁和切换，会影响运行效率</li></ul> 
<p>针对上述情况, 我们可以使用<code>loop(), 结合react()</code>来复用线程, 这种方式比<code>while循环 + receive()</code>更高效.</p> 
<p><strong>需求</strong></p> 
<ol><li>创建两个Actor（ActorSender、ActorReceiver）</li><li>ActorSender持续发送一个异步字符串消息给ActorReceiver</li><li>ActorReceiver持续接收消息，并打印出来</li></ol> 
<blockquote> 
 <p>注意: 使用loop + react重写上述案例.</p> 
</blockquote> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token comment">//案例: 使用loop + react循环接收消息.</span>
<span class="token keyword">object</span> ClassDemo05 <span class="token punctuation">{<!-- --></span>

  <span class="token comment">//1. 创建发送消息的Actor, ActorSender, 发送一句话给ActorReceiver</span>
  <span class="token keyword">object</span> ActorSender <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送一句话给ActorReceiver</span>
        ActorReceiver <span class="token operator">!</span> <span class="token string">"你好啊, 我是ActorSender!"</span>
        <span class="token comment">//休眠3秒.</span>
        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>       <span class="token comment">//单位是: 秒</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//2. 创建接收消息的Actor, ActorReceiver</span>
  <span class="token keyword">object</span> ActorReceiver <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//接收发送过来的消息,  持续接收.</span>
      loop<span class="token punctuation">{<!-- --></span>
        react <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">case</span> x<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 启动两个Actor</span>
    ActorSender<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ActorReceiver<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="35___335"></a>3.5 案例四: 发送和接收自定义消息</h5> 
<p>我们前面发送的消息都是字符串类型，Actor中也支持发送自定义消息，例如：使用样例类封装消息，然后进行发送处理。</p> 
<h6><a id="351___339"></a>3.5.1 示例一: 发送同步有返回消息</h6> 
<p><strong>需求</strong></p> 
<ol><li>创建一个MsgActor，并向它发送一个同步消息，该消息包含两个字段（id、message）</li><li>MsgActor回复一个消息，该消息包含两个字段（message、name）</li><li>打印回复消息</li></ol> 
<blockquote> 
 <p>注意:</p> 
 <ul><li>使用<code>!?</code>来发送同步消息</li><li>在Actor的act方法中，可以使用sender获取发送者的Actor引用</li></ul> 
</blockquote> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token comment">//案例: Actor发送和接收自定义消息, 采用 同步有返回的形式</span>
<span class="token keyword">object</span> ClassDemo06 <span class="token punctuation">{<!-- --></span>

  <span class="token comment">//1. 定义两个样例类Message(表示发送数据),   ReplyMessage(表示返回数据.)</span>
  <span class="token keyword">case</span> <span class="token keyword">class</span> Message<span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> message<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token comment">//自定义的发送消息 样例类</span>
  <span class="token keyword">case</span> <span class="token keyword">class</span> ReplyMessage<span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token comment">//自定义的接收消息 样例类</span>


  <span class="token comment">//2. 创建一个MsgActor，用来接收MainActor发送过来的消息, 并向它回复一条消息.</span>
  <span class="token keyword">object</span> MsgActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//2.1 接收 主Actor(MainActor) 发送过来的消息.</span>
      loop <span class="token punctuation">{<!-- --></span>
        react <span class="token punctuation">{<!-- --></span>
          <span class="token comment">//结合偏函数使用</span>
          <span class="token keyword">case</span> Message<span class="token punctuation">(</span>id<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"我是MsgActor, 我收到的消息是: </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">id</span><span class="token punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">message</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

          <span class="token comment">//2.2 给MainActor回复一条消息.</span>
          <span class="token comment">//sender: 获取消息发送方的Actor对象</span>
          sender <span class="token operator">!</span> ReplyMessage<span class="token punctuation">(</span><span class="token string">"我很不好, 熏死了!..."</span><span class="token punctuation">,</span> <span class="token string">"车磊"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 开启MsgActor</span>
    MsgActor<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">//4. 通过MainActor, 给MsgActor发送一个 Message对象.</span>
    <span class="token comment">//采用 !?  同步有返回.</span>
    <span class="token keyword">val</span> reply<span class="token operator">:</span><span class="token builtin">Any</span> <span class="token operator">=</span> MsgActor <span class="token operator">!</span><span class="token operator">?</span> Message<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"你好啊, 我是MainActor, 我在给你发消息!"</span><span class="token punctuation">)</span>
    <span class="token comment">//resutl表示最终接收到的 返回消息.</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> reply<span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span>ReplyMessage<span class="token punctuation">]</span>
    <span class="token comment">//5. 输出结果.</span>
    println<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="352___397"></a>3.5.2 示例二: 发送异步无返回消息</h6> 
<p><strong>需求</strong></p> 
<p>创建一个MsgActor，并向它发送一个异步无返回消息，该消息包含两个字段（id, message）</p> 
<blockquote> 
 <p>注意: 使用<code>!</code>发送异步无返回消息</p> 
</blockquote> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token comment">//案例: Actor发送和接收自定义消息, 采用 异步 无返回的形式</span>
<span class="token keyword">object</span> ClassDemo07 <span class="token punctuation">{<!-- --></span>

  <span class="token comment">//1. 定义一个样例类Message(表示发送数据)</span>
  <span class="token keyword">case</span> <span class="token keyword">class</span> Message<span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> message<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token comment">//自定义的发送消息 样例类</span>

  <span class="token comment">//2. 创建一个MsgActor，用来接收MainActor发送过来的消息, 并打印.</span>
  <span class="token keyword">object</span> MsgActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//2.1 接收 主Actor(MainActor) 发送过来的消息.</span>
      loop <span class="token punctuation">{<!-- --></span>
        react <span class="token punctuation">{<!-- --></span>
          <span class="token comment">//结合偏函数使用</span>
          <span class="token keyword">case</span> Message<span class="token punctuation">(</span>id<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"我是MsgActor, 我收到的消息是: </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">id</span><span class="token punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">message</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 开启MsgActor</span>
    MsgActor<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">//4. 通过MainActor, 给MsgActor发送一个 Message对象.</span>
    <span class="token comment">//采用 !  异步无返回</span>
   MsgActor <span class="token operator">!</span> Message<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"我是采用 异步无返回 的形式发送消息!"</span><span class="token punctuation">)</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="353___442"></a>3.5.3 示例三: 发送异步有返回消息</h6> 
<p><strong>需求</strong></p> 
<ol><li>创建一个MsgActor，并向它发送一个异步有返回消息，该消息包含两个字段（id、message）</li><li>MsgActor回复一个消息，该消息包含两个字段（message、name）</li><li>打印回复消息</li></ol> 
<blockquote> 
 <p>注意:</p> 
 <ul><li>使用<code>!!</code>发送异步有返回消息</li><li>发送后，返回类型为Future[Any]的对象</li><li>Future表示异步返回数据的封装，虽获取到Future的返回值，但不一定有值，可能在将来某一时刻才会返回消息</li><li>Future的isSet()可检查是否已经收到返回消息，apply()方法可获取返回数据</li></ul> 
</blockquote> 
<p><strong>图解</strong></p> 
<p><img src="https://images2.imgbox.com/83/13/Q8jEr7K8_o.png" alt="在这里插入图片描述"></p> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token comment">//案例: Actor发送和接收自定义消息, 采用 异步有返回的形式</span>
<span class="token keyword">object</span> ClassDemo08 <span class="token punctuation">{<!-- --></span>

  <span class="token comment">//1. 定义两个样例类Message(表示发送数据),   ReplyMessage(表示返回数据.)</span>
  <span class="token keyword">case</span> <span class="token keyword">class</span> Message<span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> message<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token comment">//自定义的发送消息 样例类</span>
  <span class="token keyword">case</span> <span class="token keyword">class</span> ReplyMessage<span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token comment">//自定义的接收消息 样例类</span>


  <span class="token comment">//2. 创建一个MsgActor，用来接收MainActor发送过来的消息, 并向它回复一条消息.</span>
  <span class="token keyword">object</span> MsgActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//2.1 接收 主Actor(MainActor) 发送过来的消息.</span>
      loop <span class="token punctuation">{<!-- --></span>
        react <span class="token punctuation">{<!-- --></span>
          <span class="token comment">//结合偏函数使用</span>
          <span class="token keyword">case</span> Message<span class="token punctuation">(</span>id<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"我是MsgActor, 我收到的消息是: </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">id</span><span class="token punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">message</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

            <span class="token comment">//2.2 给MainActor回复一条消息.</span>
            <span class="token comment">//sender: 获取消息发送方的Actor对象</span>
            sender <span class="token operator">!</span> ReplyMessage<span class="token punctuation">(</span><span class="token string">"我很不好, 熏死了!..."</span><span class="token punctuation">,</span> <span class="token string">"糖糖"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3. 开启MsgActor</span>
    MsgActor<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">//4. 通过MainActor, 给MsgActor发送一个 Message对象.</span>
    <span class="token comment">//采用 !!  异步有返回.</span>
    <span class="token keyword">val</span> future<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> MsgActor <span class="token operator">!</span><span class="token operator">!</span> Message<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"你好啊, 我是MainActor, 我在给你发消息!"</span><span class="token punctuation">)</span>

    <span class="token comment">//5. 因为future中不一定会立马有数据, 所以我们要校验.</span>
    <span class="token comment">//Future的isSet()可检查是否已经收到返回消息，apply()方法可获取返回数据</span>
    <span class="token comment">//!future.isSet表示: 没有接收到具体的返回消息, 就一直死循环.</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>future<span class="token punctuation">.</span>isSet<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token comment">//通过Future的apply()方法来获取返回的数据.</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span>ReplyMessage<span class="token punctuation">]</span>
    <span class="token comment">//5. 输出结果.</span>
    println<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="4__WordCount_513"></a>4. 案例: WordCount</h4> 
<h5><a id="41__515"></a>4.1 需求</h5> 
<p>接下来，我们要使用Actor并发编程模型实现<code>多文件的单词统计</code>。</p> 
<p><strong>案例介绍</strong></p> 
<p>给定几个文本文件（文本文件都是以空格分隔的），使用Actor并发编程来统计单词的数量.</p> 
<p><strong>思路分析</strong></p> 
<p><img src="https://images2.imgbox.com/02/16/UHVUHFo0_o.png" alt="在这里插入图片描述"></p> 
<p><strong>实现思路</strong></p> 
<ol><li>MainActor获取要进行单词统计的文件</li><li>根据文件数量创建对应的WordCountActor</li><li>将文件名封装为消息发送给WordCountActor</li><li>WordCountActor接收消息，并统计单个文件的单词计数</li><li>将单词计数结果发送给MainActor</li><li>MainActor等待所有的WordCountActor都已经成功返回消息，然后进行结果合并</li></ol> 
<h5><a id="42___539"></a>4.2 步骤一: 获取文件列表</h5> 
<p><strong>实现思路</strong></p> 
<ol><li> <p>在当前项目下的data文件夹下有: 1.txt, 2.txt两个文本文件, 具体存储内容如下:</p> 
  <blockquote> 
   <p>1.txt文本文件存储内容如下:</p> 
   <pre><code class="prism language-scala">hadoop sqoop hadoop
hadoop hadoop flume
hadoop hadoop hadoop
spark
</code></pre> 
   <p>2.txt文本文件存储内容如下:</p> 
   <pre><code class="prism language-scala">flink hadoop hive
hadoop sqoop hadoop
hadoop hadoop hadoop
spark
</code></pre> 
  </blockquote> </li><li> <p>获取上述两个文本文件的路径, 并将结果打印到控制台上.</p> </li></ol> 
<p><strong>参考代码</strong></p> 
<pre><code class="prism language-scala"><span class="token keyword">object</span> MainActor <span class="token punctuation">{<!-- --></span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//1. 获取所有要统计的文件的路径.</span>
    <span class="token comment">//1.1 定义变量dir, 记录保存所有文件的: 文件夹路径.  ./data/</span>
    <span class="token keyword">var</span> dir <span class="token operator">=</span> <span class="token string">"./data/"</span>
    <span class="token comment">//1.2 获取该文件夹下, 所有的文件名.</span>
    <span class="token keyword">var</span> fileNameList <span class="token operator">=</span> <span class="token keyword">new</span> File<span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toList <span class="token comment">//List("1.txt", "2.txt")</span>
    <span class="token comment">//1.3 对获取到的文件名进行封装, 获取其全路径.     ./data/1.txt      ./data/2.txt</span>
    <span class="token keyword">var</span> fileDirList <span class="token operator">=</span> fileNameList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>dir <span class="token operator">+</span> _<span class="token punctuation">)</span>
    <span class="token comment">//println(fileDirList)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="43__WordCountActor_585"></a>4.3 步骤二: 创建WordCountActor</h5> 
<p><strong>实现思路</strong></p> 
<ol><li>根据文件数量创建对应个数的WordCountActor对象.</li><li>为了方便后续发送消息给Actor，将每个Actor与文件名关联在一起</li></ol> 
<p><strong>实现步骤</strong></p> 
<ol><li>创建WordCountActor</li><li>将文件列表转换为WordCountActor</li><li>为了后续方便发送消息给Actor，将Actor列表和文件列表拉链到一起</li><li>打印测试</li></ol> 
<p><strong>参考代码</strong></p> 
<ul><li> <p>WordCountActor.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token comment">//2.1 先创建WordCountActor类, 用来获取WordCountActor对象.</span>
<span class="token comment">//创建WordCountActor类, 每一个WordCountActor对象, 统计一个文件.</span>
<span class="token keyword">class</span> WordCountActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> </li><li> <p>MainActor.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token keyword">object</span> MainActor <span class="token punctuation">{<!-- --></span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//1. 获取所有要统计的文件的路径.</span>
    <span class="token comment">//1.1 定义变量dir, 记录保存所有文件的: 文件夹路径.  ./data/</span>
    <span class="token keyword">var</span> dir <span class="token operator">=</span> <span class="token string">"./data/"</span>
    <span class="token comment">//1.2 获取该文件夹下, 所有的文件名.</span>
    <span class="token keyword">var</span> fileNameList <span class="token operator">=</span> <span class="token keyword">new</span> File<span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toList <span class="token comment">//List("1.txt", "2.txt")</span>
    <span class="token comment">//1.3 对获取到的文件名进行封装, 获取其全路径.     ./data/1.txt      ./data/2.txt</span>
    <span class="token keyword">var</span> fileDirList <span class="token operator">=</span> fileNameList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>dir <span class="token operator">+</span> _<span class="token punctuation">)</span>
    <span class="token comment">//println(fileDirList)</span>

    <span class="token comment">//2. 根据文件数量, 创建对应的WordCountActor对象.</span>
    <span class="token comment">//2.1 先创建WordCountActor类, 用来获取WordCountActor对象.</span>
    <span class="token comment">//2.2 根据文件数量, 创建对应的WordCountActor对象.</span>
    <span class="token keyword">val</span> wordCountList <span class="token operator">=</span> fileNameList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token keyword">=&gt;</span> <span class="token keyword">new</span> WordCountActor<span class="token punctuation">)</span> <span class="token comment">//根据两个txt文件, 创建了两个wordCount对象.</span>
    <span class="token comment">//println(wordCountList)</span>
    <span class="token comment">//2.3 将WordCountActor和文件全路径关联起来</span>
    <span class="token keyword">val</span> actorWithFile <span class="token operator">=</span> wordCountList<span class="token punctuation">.</span>zip<span class="token punctuation">(</span>fileDirList<span class="token punctuation">)</span> <span class="token comment">//WordCountActor -&gt; ./data/1.txt ,  WordCountActor -&gt; ./data/2.txt</span>
    println<span class="token punctuation">(</span>actorWithFile<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="44__Actor_641"></a>4.4 步骤三: 启动Actor/发送/接收任务消息</h5> 
<p><strong>实现思路</strong></p> 
<p>启动所有WordCountActor对象，并发送单词统计任务消息给每个WordCountActor对象.</p> 
<blockquote> 
 <p>注意: 此处应<code>发送异步有返回消息</code></p> 
</blockquote> 
<p><strong>实现步骤</strong></p> 
<ol><li>创建一个WordCountTask样例类消息，封装要进行单词计数的文件名</li><li>启动所有WordCountActor，并发送异步有返回消息</li><li>获取到所有的WordCountActor中返回的消息（封装到一个Future列表中）</li><li>在WordCountActor中接收并打印消息</li></ol> 
<p><strong>参考代码</strong></p> 
<ul><li> <p>MessagePackage.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token comment">/**
  * 表示: MainActor 给每一个WordCountActor发送任务的 格式.
  * @param fileName 具体的要统计的 文件路径.
  */</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> WordCountTask<span class="token punctuation">(</span>fileName<span class="token operator">:</span><span class="token builtin">String</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p>MainActor.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token keyword">object</span> MainActor <span class="token punctuation">{<!-- --></span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//1. 获取所有要统计的文件的路径.</span>
    <span class="token comment">//1.1 定义变量dir, 记录保存所有文件的: 文件夹路径.  ./data/</span>
    <span class="token keyword">var</span> dir <span class="token operator">=</span> <span class="token string">"./data/"</span>
    <span class="token comment">//1.2 获取该文件夹下, 所有的文件名.</span>
    <span class="token keyword">var</span> fileNameList <span class="token operator">=</span> <span class="token keyword">new</span> File<span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toList <span class="token comment">//List("1.txt", "2.txt")</span>
    <span class="token comment">//1.3 对获取到的文件名进行封装, 获取其全路径.     ./data/1.txt      ./data/2.txt</span>
    <span class="token keyword">var</span> fileDirList <span class="token operator">=</span> fileNameList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>dir <span class="token operator">+</span> _<span class="token punctuation">)</span>
    <span class="token comment">//println(fileDirList)</span>

    <span class="token comment">//2. 根据文件数量, 创建对应的WordCountActor对象.</span>
    <span class="token comment">//2.1 先创建WordCountActor类, 用来获取WordCountActor对象.</span>
    <span class="token comment">//2.2 根据文件数量, 创建对应的WordCountActor对象.</span>
    <span class="token keyword">val</span> wordCountList <span class="token operator">=</span> fileNameList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token keyword">=&gt;</span> <span class="token keyword">new</span> WordCountActor<span class="token punctuation">)</span> <span class="token comment">//根据两个txt文件, 创建了两个wordCount对象.</span>
    <span class="token comment">//println(wordCountList)</span>
    <span class="token comment">//2.3 将WordCountActor和文件全路径关联起来</span>
    <span class="token keyword">val</span> actorWithFile <span class="token operator">=</span> wordCountList<span class="token punctuation">.</span>zip<span class="token punctuation">(</span>fileDirList<span class="token punctuation">)</span> <span class="token comment">//WordCountActor -&gt; ./data/1.txt ,  WordCountActor -&gt; ./data/2.txt</span>
    println<span class="token punctuation">(</span>actorWithFile<span class="token punctuation">)</span>

    <span class="token comment">//3. 启动WordCountActor, 并给每一个WordCountActor发送任务.</span>
    <span class="token comment">/*
      Map(spark -&gt; 1, hadoop -&gt; 7, sqoop -&gt; 1, flume -&gt; 1)
      Map(sqoop -&gt; 1, flink -&gt; 1, hadoop -&gt; 6, spark -&gt; 1, hive -&gt; 1)
     */</span>
    <span class="token keyword">val</span> futureList<span class="token operator">:</span> List<span class="token punctuation">[</span>Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> actorWithFile<span class="token punctuation">.</span>map <span class="token punctuation">{<!-- --></span>       <span class="token comment">//futureList: 记录的是所有WordCountActor统计的结果.</span>
      keyVal <span class="token keyword">=&gt;</span> <span class="token comment">//keyVal的格式: WordCountActor -&gt; ./data/1.txt</span>
        <span class="token comment">//3.1 获取具体的要启动的WordCountActor对象.</span>
        <span class="token keyword">val</span> actor <span class="token operator">=</span> keyVal<span class="token punctuation">.</span>_1 <span class="token comment">//actor: WordCountActor</span>
        <span class="token comment">//3.2 启动具体的WordCountActor.</span>
        actor<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token comment">//3.3 给每个WordCountActor发送具体的任务(文件路径)  异步有返回.</span>
        <span class="token keyword">val</span> future<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">!</span><span class="token operator">!</span> WordCountTask<span class="token punctuation">(</span>keyVal<span class="token punctuation">.</span>_2<span class="token punctuation">)</span>
        future      <span class="token comment">//记录的是某一个WordCountActor返回的统计结果.</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>WordCountActor.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token comment">//2.1 先创建WordCountActor类, 用来获取WordCountActor对象.</span>
<span class="token comment">//创建WordCountActor类, 每一个WordCountActor对象, 统计一个文件.</span>
<span class="token keyword">class</span> WordCountActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> 
      loop <span class="token punctuation">{<!-- --></span>
          react <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//3.4 接收具体的任务</span>
            <span class="token keyword">case</span> WordCountTask<span class="token punctuation">(</span>fileName<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
              <span class="token comment">//3.5 打印具体的任务</span>
              println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"接收到的具体任务是: </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">fileName</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="45___733"></a>4.5 步骤四: 统计文件单词计数</h5> 
<p><strong>实现思路</strong></p> 
<p>读取文件文本，并统计出来单词的数量。例如：</p> 
<pre><code class="prism language-html">(hadoop, 3), (spark, 1)...
</code></pre> 
<p><strong>实现步骤</strong></p> 
<ol><li>读取文件内容，并转换为列表</li><li>按照空格切割文本，并转换为一个一个的单词</li><li>为了方便进行计数，将单词转换为元组</li><li>按照单词进行分组，然后再进行聚合统计</li><li>打印聚合统计结果</li></ol> 
<p><strong>参考代码</strong></p> 
<ul><li> <p>WordCountActor.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token keyword">class</span> WordCountActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//采用loop + react 方式接收数据.</span>
    loop <span class="token punctuation">{<!-- --></span>
      react <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//3.4 接收具体的任务</span>
        <span class="token keyword">case</span> WordCountTask<span class="token punctuation">(</span>fileName<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
          <span class="token comment">//3.5 打印具体的任务</span>
          println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"接收到的具体任务是: </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">fileName</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

        <span class="token comment">//4. 统计接收到的文件中的每个单词的数量.</span>
        <span class="token comment">//4.1 获取指定文件中的所有的文件. List("hadoop sqoop hadoop","hadoop hadoop flume")</span>
        <span class="token keyword">val</span> lineList <span class="token operator">=</span> Source<span class="token punctuation">.</span>fromFile<span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">.</span>getLines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toList
        <span class="token comment">//4.2 将上述获取到的数据, 转换成一个一个的字符串.  </span>
        <span class="token comment">//List("hadoop", "sqoop", "hadoop","hadoop", "hadoop", "flume")</span>
        <span class="token keyword">val</span> strList <span class="token operator">=</span> lineList<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>_<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">//4.3 给每一个字符串后边都加上次数, 默认为1.             </span>
        <span class="token comment">//List("hadoop"-&gt;1, "sqoop"-&gt;1, "hadoop"-&gt;1, "hadoop"-&gt;1, "flume"-&gt;1)</span>
        <span class="token keyword">val</span> wordAndCount <span class="token operator">=</span> strList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token operator">-&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment">//4.4 按照 字符串内容分组.                              </span>
        <span class="token comment">//"hadoop" -&gt; List("hadoop"-&gt;1, "hadoop"-&gt;1),   "sqoop" -&gt; List("sqoop"-&gt;1)</span>
        <span class="token keyword">val</span> groupMap <span class="token operator">=</span> wordAndCount<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span>
        <span class="token comment">//4.5 对分组后的内容进行统计, 统计每个单词的总次数.    "hadoop" -&gt; 2,   "sqoop" -&gt; 1</span>
        <span class="token keyword">val</span> wordCountMap <span class="token operator">=</span> groupMap<span class="token punctuation">.</span>map<span class="token punctuation">(</span>keyVal <span class="token keyword">=&gt;</span> keyVal<span class="token punctuation">.</span>_1 <span class="token operator">-&gt;</span> keyVal<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">)</span>
        <span class="token comment">//4.6 打印统计后的结果. </span>
        println<span class="token punctuation">(</span>wordCountMap<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="46__MainActor_789"></a>4.6 步骤五: 返回结果给MainActor</h5> 
<p><strong>实现思路</strong></p> 
<ul><li>将单词计数的结果封装为一个样例类消息，并发送给MainActor</li><li>MainActor等待所有WordCountActor均已返回后,获取到每个WordCountActor单词计算后的结果</li></ul> 
<p><strong>实现步骤</strong></p> 
<ol><li>定义一个样例类封装单词计数结果</li><li>将单词计数结果发送给MainActor</li><li>MainActor中检测所有WordCountActor是否均已返回，如果均已返回，则获取并转换结果</li><li>打印结果</li></ol> 
<p><strong>参考代码</strong></p> 
<ul><li> <p>MessagePackage.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token comment">/**
  * 表示: MainActor 给每一个WordCountActor发送任务的 格式.
  * @param fileName 具体的要统计的 文件路径.
  */</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> WordCountTask<span class="token punctuation">(</span>fileName<span class="token operator">:</span><span class="token builtin">String</span><span class="token punctuation">)</span>


<span class="token comment">/**
  * 每个WordCountActor统计完的返回结果的: 格式
  * @param wordCountMap  具体的返回结果, 例如:  Map("hadoop"-&gt;6, "sqoop"-&gt;1)
  */</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> WordCountResult<span class="token punctuation">(</span>wordCountMap<span class="token operator">:</span>Map<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p>WordCountActor.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token keyword">class</span> WordCountActor <span class="token keyword">extends</span> Actor <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">override</span> <span class="token keyword">def</span> act<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//采用loop + react 方式接收数据.</span>
    loop <span class="token punctuation">{<!-- --></span>
      react <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//3.4 接收具体的任务</span>
        <span class="token keyword">case</span> WordCountTask<span class="token punctuation">(</span>fileName<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
          <span class="token comment">//3.5 打印具体的任务</span>
          println<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"接收到的具体任务是: </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">fileName</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

        <span class="token comment">//4. 统计接收到的文件中的每个单词的数量.</span>
        <span class="token comment">//4.1 获取指定文件中的所有的文件.                       List("hadoop sqoop hadoop","hadoop hadoop flume")</span>
        <span class="token keyword">val</span> lineList <span class="token operator">=</span> Source<span class="token punctuation">.</span>fromFile<span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">.</span>getLines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toList
        <span class="token comment">//4.2 将上述获取到的数据, 转换成一个一个的字符串.        List("hadoop", "sqoop", "hadoop","hadoop", "hadoop", "flume")</span>
        <span class="token keyword">val</span> strList <span class="token operator">=</span> lineList<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>_<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">//4.3 给每一个字符串后边都加上次数, 默认为1.             List("hadoop"-&gt;1, "sqoop"-&gt;1, "hadoop"-&gt;1,"hadoop"-&gt;1, "hadoop"-&gt;1, "flume"-&gt;1)</span>
        <span class="token keyword">val</span> wordAndCount <span class="token operator">=</span> strList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token operator">-&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment">//4.4 按照 字符串内容分组.                              "hadoop" -&gt; List("hadoop"-&gt;1, "hadoop"-&gt;1),   "sqoop" -&gt; List("sqoop"-&gt;1)</span>
        <span class="token keyword">val</span> groupMap <span class="token operator">=</span> wordAndCount<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span>
        <span class="token comment">//4.5 对分组后的内容进行统计, 统计每个单词的总次数.      "hadoop" -&gt; 2,   "sqoop" -&gt; 1</span>
        <span class="token keyword">val</span> wordCountMap <span class="token operator">=</span> groupMap<span class="token punctuation">.</span>map<span class="token punctuation">(</span>keyVal <span class="token keyword">=&gt;</span> keyVal<span class="token punctuation">.</span>_1 <span class="token operator">-&gt;</span> keyVal<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">)</span>
        <span class="token comment">//4.6 把统计后的结果返回给: MainActor.</span>
        sender <span class="token operator">!</span> WordCountResult<span class="token punctuation">(</span>wordCountMap<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h5><a id="47___856"></a>4.7 步骤六: 结果合并</h5> 
<p><strong>实现思路</strong></p> 
<p>对接收到的所有单词计数进行合并。</p> 
<p><strong>参考代码</strong></p> 
<ul><li> <p>MainActor.scala文件中的代码</p> <pre><code class="prism language-scala"><span class="token keyword">object</span> MainActor <span class="token punctuation">{<!-- --></span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//1. 获取所有要统计的文件的路径.</span>
    <span class="token comment">//1.1 定义变量dir, 记录保存所有文件的: 文件夹路径.  ./data/</span>
    <span class="token keyword">var</span> dir <span class="token operator">=</span> <span class="token string">"./data/"</span>
    <span class="token comment">//1.2 获取该文件夹下, 所有的文件名.</span>
    <span class="token keyword">var</span> fileNameList <span class="token operator">=</span> <span class="token keyword">new</span> File<span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toList <span class="token comment">//List("1.txt", "2.txt")</span>
    <span class="token comment">//1.3 对获取到的文件名进行封装, 获取其全路径.     ./data/1.txt      ./data/2.txt</span>
    <span class="token keyword">var</span> fileDirList <span class="token operator">=</span> fileNameList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>dir <span class="token operator">+</span> _<span class="token punctuation">)</span>
    <span class="token comment">//println(fileDirList)</span>

    <span class="token comment">//2. 根据文件数量, 创建对应的WordCountActor对象.</span>
    <span class="token comment">//2.1 先创建WordCountActor类, 用来获取WordCountActor对象.</span>
    <span class="token comment">//2.2 根据文件数量, 创建对应的WordCountActor对象.</span>
    <span class="token keyword">val</span> wordCountList <span class="token operator">=</span> fileNameList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token keyword">=&gt;</span> <span class="token keyword">new</span> WordCountActor<span class="token punctuation">)</span> <span class="token comment">//根据两个txt文件, 创建了两个wordCount对象.</span>
    <span class="token comment">//println(wordCountList)</span>
    <span class="token comment">//2.3 将WordCountActor和文件全路径关联起来</span>
    <span class="token keyword">val</span> actorWithFile <span class="token operator">=</span> wordCountList<span class="token punctuation">.</span>zip<span class="token punctuation">(</span>fileDirList<span class="token punctuation">)</span> <span class="token comment">//WordCountActor -&gt; ./data/1.txt ,  WordCountActor -&gt; ./data/2.txt</span>
    println<span class="token punctuation">(</span>actorWithFile<span class="token punctuation">)</span>

    <span class="token comment">//3. 启动WordCountActor, 并给每一个WordCountActor发送任务.</span>
    <span class="token comment">/*
      Map(spark -&gt; 1, hadoop -&gt; 7, sqoop -&gt; 1, flume -&gt; 1)
      Map(sqoop -&gt; 1, flink -&gt; 1, hadoop -&gt; 6, spark -&gt; 1, hive -&gt; 1)
     */</span>
    <span class="token keyword">val</span> futureList<span class="token operator">:</span> List<span class="token punctuation">[</span>Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> actorWithFile<span class="token punctuation">.</span>map <span class="token punctuation">{<!-- --></span>       <span class="token comment">//futureList: 记录的是所有WordCountActor统计的结果.</span>
      keyVal <span class="token keyword">=&gt;</span> <span class="token comment">//keyVal的格式: WordCountActor -&gt; ./data/1.txt</span>
        <span class="token comment">//3.1 获取具体的要启动的WordCountActor对象.</span>
        <span class="token keyword">val</span> actor <span class="token operator">=</span> keyVal<span class="token punctuation">.</span>_1 <span class="token comment">//actor: WordCountActor</span>
        <span class="token comment">//3.2 启动具体的WordCountActor.</span>
        actor<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">//3.3 给每个WordCountActor发送具体的任务(文件路径)  异步有返回.</span>
        <span class="token keyword">val</span> future<span class="token operator">:</span> Future<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> actor <span class="token operator">!</span><span class="token operator">!</span> WordCountTask<span class="token punctuation">(</span>keyVal<span class="token punctuation">.</span>_2<span class="token punctuation">)</span>
        future      <span class="token comment">//记录的是某一个WordCountActor返回的统计结果.</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//5. MainActor对接收到的数据进行合并.</span>
    <span class="token comment">//5.1 判断所有的future都有返回值后, 再往下执行.</span>
    <span class="token comment">//       过滤没有返回值的future         不为0说明还有future没有收到值</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>futureList<span class="token punctuation">.</span>filter<span class="token punctuation">(</span><span class="token operator">!</span>_<span class="token punctuation">.</span>isSet<span class="token punctuation">)</span><span class="token punctuation">.</span>size <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">//futureList:  future1, future2</span>
    <span class="token comment">//5.2 从每一个future中获取数据.</span>
    <span class="token comment">//wordCountMap:  List(Map(spark -&gt; 1, hadoop -&gt; 7, sqoop -&gt; 1, flume -&gt; 1), Map(sqoop -&gt; 1, flink -&gt; 1, hadoop -&gt; 6, spark -&gt; 1, hive -&gt; 1))</span>
    <span class="token keyword">val</span> wordCountMap <span class="token operator">=</span> futureList<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span>WordCountResult<span class="token punctuation">]</span><span class="token punctuation">.</span>wordCountMap<span class="token punctuation">)</span>
    <span class="token comment">//5.3 对获取的数据进行flatten, groupBy, map, 然后统计.</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> wordCountMap<span class="token punctuation">.</span>flatten<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>keyVal <span class="token keyword">=&gt;</span> keyVal<span class="token punctuation">.</span>_1 <span class="token operator">-&gt;</span> keyVal<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">)</span>
    <span class="token comment">//5.4 打印结果</span>
    println<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<p>start()</p> 
<pre><code>      //3.3 给每个WordCountActor发送具体的任务(文件路径)  异步有返回.
      val future: Future[Any] = actor !! WordCountTask(keyVal._2)
      future      //记录的是某一个WordCountActor返回的统计结果.
  }

  //5. MainActor对接收到的数据进行合并.
  //5.1 判断所有的future都有返回值后, 再往下执行.
  //       过滤没有返回值的future         不为0说明还有future没有收到值
  while(futureList.filter(!_.isSet).size != 0) {} //futureList:  future1, future2
  //5.2 从每一个future中获取数据.
  //wordCountMap:  List(Map(spark -&gt; 1, hadoop -&gt; 7, sqoop -&gt; 1, flume -&gt; 1), Map(sqoop -&gt; 1, flink -&gt; 1, hadoop -&gt; 6, spark -&gt; 1, hive -&gt; 1))
  val wordCountMap = futureList.map(_.apply().asInstanceOf[WordCountResult].wordCountMap)
  //5.3 对获取的数据进行flatten, groupBy, map, 然后统计.
  val result = wordCountMap.flatten.groupBy(_._1).map(keyVal =&gt; keyVal._1 -&gt; keyVal._2.map(_._2).sum)
  //5.4 打印结果
  println(result)
}
</code></pre> 
<p>}</p> 
<pre><code>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c019fba59a8a6ea07dea3ad0b32a458a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">centos6 yum源失效解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/782255d5c0773ba2dd50aa682c1bab47/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Scala基础教程--20--Akka</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>