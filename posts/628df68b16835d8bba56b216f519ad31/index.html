<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【读书笔记】深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【读书笔记】深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化" />
<meta property="og:description" content="文章目录 文章说明第三部分 虚拟机执行子系统第6章 类文件结构6.1 概述6.2 无关性的基石6.3 Class类文件的结构 第7章 虚拟机类加载机制7.1 概述7.2 类加载的时机7.3 类加载过程7.4 类加载器7.4.1 类与类加载器7.4.2 双亲委派模型7.4.3 破坏双亲委派模型 第8章 虚拟机字节码执行引擎8.1 概述8.2 运行时栈帧结构8.3 方法调用8.3.1 解析8.3.2 分派8.3.3 动态类型语言支持8.4 基于栈的字节码解释执行引擎 第9章 类加载及执行子系统的案例与实战9.1 概述9.2 案例分析9.2.1 Tomcat：正统的类加载器结构9.2.2 OSGi：灵活的类加载器结构9.2.3 字节码生成技术与动态代理的实现9.2.4 Retrotranslator：跨越JDK版本 9.3 实战：自己动手实现远程执行功能 第四部分 程序编译与代码优化第10章 早期（编译期）优化10.1 概述10.2 Javac编译器10.3 Java语法糖的味道10.3.1 泛型与类型擦除10.3.2 自动装箱、拆箱与遍历循环10.3.3 条件编译 10.4 实战：插入式注解处理器 第11章 晚期（运行期）优化11.1 概述11.2 HotSpot虚拟机内的即时编译器11.3 编译优化技术11.3.1 优化技术概览11.3.2 公共子表达式消除11.3.3 数组边界检查消除11.3.4 方法内联11.3.5 逃逸分析 11.4 Java与C/C&#43;&#43;的编译器对比 文章说明 本文是《深入理解Java虚拟机（周志明）》这本书的重点摘要。
本笔记仅作为复习，不过多的对内容进行讲解。
本笔记按照书的目录进行，如遇到需要细看的，可以到书中找对应内容。
本笔记并不是按照书中原话进行摘要，而是根据自己的理解使用大白话进行记录，同时进行了少部分扩展。如有错误欢迎指出。
由于内容较多，一共分为三篇：
篇幅链接深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制https://blog.csdn.net/zhaohongfei_358/article/details/134927759深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化https://blog.csdn.net/zhaohongfei_358/article/details/135067398深入理解Java虚拟机（周志明）（5）第五部分 高效并发https://blog." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/628df68b16835d8bba56b216f519ad31/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T09:15:31+08:00" />
<meta property="article:modified_time" content="2023-12-25T09:15:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【读书笔记】深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">文章说明</a></li><li><a href="#__19" rel="nofollow">第三部分 虚拟机执行子系统</a></li><li><ul><li><a href="#6__21" rel="nofollow">第6章 类文件结构</a></li><li><ul><li><a href="#61__23" rel="nofollow">6.1 概述</a></li><li><a href="#62__27" rel="nofollow">6.2 无关性的基石</a></li><li><a href="#63_Class_40" rel="nofollow">6.3 Class类文件的结构</a></li></ul> 
   </li><li><a href="#7__46" rel="nofollow">第7章 虚拟机类加载机制</a></li><li><ul><li><a href="#71__48" rel="nofollow">7.1 概述</a></li><li><a href="#72__54" rel="nofollow">7.2 类加载的时机</a></li><li><a href="#73__70" rel="nofollow">7.3 类加载过程</a></li><li><a href="#74__84" rel="nofollow">7.4 类加载器</a></li><li><ul><li><a href="#741__88" rel="nofollow">7.4.1 类与类加载器</a></li><li><a href="#742__93" rel="nofollow">7.4.2 双亲委派模型</a></li><li><a href="#743__105" rel="nofollow">7.4.3 破坏双亲委派模型</a></li></ul> 
   </li></ul> 
   </li><li><a href="#8__114" rel="nofollow">第8章 虚拟机字节码执行引擎</a></li><li><ul><li><a href="#81__116" rel="nofollow">8.1 概述</a></li><li><a href="#82__120" rel="nofollow">8.2 运行时栈帧结构</a></li><li><a href="#83__133" rel="nofollow">8.3 方法调用</a></li><li><ul><li><a href="#831__138" rel="nofollow">8.3.1 解析</a></li><li><a href="#832__146" rel="nofollow">8.3.2 分派</a></li><li><a href="#833__247" rel="nofollow">8.3.3 动态类型语言支持</a></li><li><a href="#84__256" rel="nofollow">8.4 基于栈的字节码解释执行引擎</a></li></ul> 
   </li></ul> 
   </li><li><a href="#9__260" rel="nofollow">第9章 类加载及执行子系统的案例与实战</a></li><li><ul><li><a href="#91__262" rel="nofollow">9.1 概述</a></li><li><a href="#92__266" rel="nofollow">9.2 案例分析</a></li><li><ul><li><a href="#921_Tomcat_267" rel="nofollow">9.2.1 Tomcat：正统的类加载器结构</a></li><li><a href="#922_OSGi_282" rel="nofollow">9.2.2 OSGi：灵活的类加载器结构</a></li><li><a href="#923__294" rel="nofollow">9.2.3 字节码生成技术与动态代理的实现</a></li><li><a href="#924_RetrotranslatorJDK_354" rel="nofollow">9.2.4 Retrotranslator：跨越JDK版本</a></li></ul> 
    </li><li><a href="#93__360" rel="nofollow">9.3 实战：自己动手实现远程执行功能</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__365" rel="nofollow">第四部分 程序编译与代码优化</a></li><li><ul><li><a href="#10__367" rel="nofollow">第10章 早期（编译期）优化</a></li><li><ul><li><a href="#101__369" rel="nofollow">10.1 概述</a></li><li><a href="#102_Javac_373" rel="nofollow">10.2 Javac编译器</a></li><li><a href="#103_Java_379" rel="nofollow">10.3 Java语法糖的味道</a></li><li><ul><li><a href="#1031__381" rel="nofollow">10.3.1 泛型与类型擦除</a></li><li><a href="#1032__419" rel="nofollow">10.3.2 自动装箱、拆箱与遍历循环</a></li><li><a href="#1033__448" rel="nofollow">10.3.3 条件编译</a></li></ul> 
    </li><li><a href="#104__472" rel="nofollow">10.4 实战：插入式注解处理器</a></li></ul> 
   </li><li><a href="#11__478" rel="nofollow">第11章 晚期（运行期）优化</a></li><li><ul><li><a href="#111__480" rel="nofollow">11.1 概述</a></li><li><a href="#112_HotSpot_490" rel="nofollow">11.2 HotSpot虚拟机内的即时编译器</a></li><li><a href="#113__494" rel="nofollow">11.3 编译优化技术</a></li><li><ul><li><a href="#1131__496" rel="nofollow">11.3.1 优化技术概览</a></li><li><a href="#1132__560" rel="nofollow">11.3.2 公共子表达式消除</a></li><li><a href="#1133__580" rel="nofollow">11.3.3 数组边界检查消除</a></li><li><a href="#1134__585" rel="nofollow">11.3.4 方法内联</a></li><li><a href="#1135__621" rel="nofollow">11.3.5 逃逸分析</a></li></ul> 
    </li><li><a href="#114_JavaCC_645" rel="nofollow">11.4 Java与C/C++的编译器对比</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>文章说明</h2> 
<p>本文是《深入理解Java虚拟机（周志明）》这本书的重点摘要。</p> 
<p>本笔记仅作为复习，不过多的对内容进行讲解。</p> 
<p>本笔记按照书的目录进行，如遇到需要细看的，可以到书中找对应内容。</p> 
<p>本笔记并不是按照书中原话进行摘要，而是根据自己的理解使用大白话进行记录，同时进行了少部分扩展。如有错误欢迎指出。</p> 
<p>由于内容较多，一共分为三篇：</p> 
<table><thead><tr><th>篇幅</th><th>链接</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/134927759">深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/134927759</td></tr><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/135067398">深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/135067398</td></tr><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/135111650">深入理解Java虚拟机（周志明）（5）第五部分 高效并发</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/135111650</td></tr></tbody></table> 
<h2><a id="__19"></a>第三部分 虚拟机执行子系统</h2> 
<h3><a id="6__21"></a>第6章 类文件结构</h3> 
<h4><a id="61__23"></a>6.1 概述</h4> 
<p>无重点</p> 
<h4><a id="62__27"></a>6.2 无关性的基石</h4> 
<p>Java虚拟机只和字节码（也就是<code>class</code>文件）打交道。因此，JVM可以运行其他语言，例如：Groovy、Jython、Scala、Kotlin等。</p> 
<p>它们都是先将各自的代码编译成class文件，然后交给JVM运行即可。</p> 
<p><img src="https://images2.imgbox.com/b0/6f/PSgXBjz5_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>这也是JVM的<strong>语言无关性</strong>。</p> 
<p>而字节码可以拿到任何平台运行，例如Windows、Mac、Linux等，只要该平台有JVM即可。这是Java语言的<strong>平台无关性</strong>，即“一次编译，处处运行”。</p> 
<h4><a id="63_Class_40"></a>6.3 Class类文件的结构</h4> 
<p>无重点</p> 
<blockquote> 
 <p>第6章后续讲解了如何看懂字节码，这部分比较高级，且大多数人用不到，感兴趣可以自行阅读。</p> 
</blockquote> 
<h3><a id="7__46"></a>第7章 虚拟机类加载机制</h3> 
<h4><a id="71__48"></a>7.1 概述</h4> 
<p>虚拟机把class文件记载到内存，并进行校验、解析、初始化等，最终形成可以被虚拟机直接使用的java类，这就是虚拟机的类加载机制。</p> 
<p>class文件不一定非要是文件，从网络或其他地方加载的二进制流也可以。</p> 
<h4><a id="72__54"></a>7.2 类加载的时机</h4> 
<p>类的生命周期：</p> 
<p><img src="https://images2.imgbox.com/72/14/cR5cJc6p_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>加载、连接的发生时机：各JVM实现自行决定</p> 
<p>初始化的发生时机：当需要用到该类时（包括访问其属性和方法），主要场景：</p> 
<ol><li>首次<code>new</code>对象时</li><li>调用静态属性或方法时</li><li>对类进行反射时</li><li>该类作为main入口</li></ol> 
<h4><a id="73__70"></a>7.3 类加载过程</h4> 
<p>类加载包括如下动作：</p> 
<ul><li><strong>加载</strong>：执行过程：① 读取类的二进制字节流；② 将静态存储结构（类的方法等）存到方法区；③ 生成该类对应的<code>java.lang.Class</code>对象。（注意：加载过程和后面的验证、准备等动作是交叉进行的，并不是整个做完加载才进行后续验证）</li><li><strong>验证</strong>：验证字节码是否符合JVM规范。包括： 
  <ul><li>① 文件格式验证；</li><li>② 元数据验证：是否符合Java规范，例如：是否继承了final类，继承接口的类是否还有未实现的方法等）；</li><li>③ 字节码验证：验证语义的是否合法、是否符合逻辑。例如：类型转换是否有效、是否有危害虚拟机安全的事件等。</li><li>④ 符合引用验证：验证符号引用的正确性。例如：是否访问了一个其他类的private方法。</li></ul> </li><li><strong>准备</strong>：为类的静态变量分配内存（存在方法区），并附上“0”的初始值。（真正的默认值赋值是在初始化阶段做的）。</li><li><strong>解析</strong>：将符号引用转为直接引用</li><li><strong>初始化</strong>：从上到下执行给static字段赋值和执行static静态代码块。</li></ul> 
<h4><a id="74__84"></a>7.4 类加载器</h4> 
<p>类加载可以允许用户在运行时加载类。用户可以实现自己的类加载器。</p> 
<h5><a id="741__88"></a>7.4.1 类与类加载器</h5> 
<p>一个类可以被多个类加载器加载，每个类加载器有自己的独立的类名称空间。这也意味着两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。</p> 
<h5><a id="742__93"></a>7.4.2 双亲委派模型</h5> 
<p>Java提供了三种类加载器：</p> 
<ul><li>启动类加载器（Bootstrap ClassLoader）：虚拟机用的，用于加载<code>&lt;JAVA_HOME&gt;/lib</code>下的类，用户无法直接使用。</li><li>扩展类加载器（Extension ClassLoader）：用户可以使用，用来加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>中的类。</li><li>应用程序类加载器（Application ClassLoader）：用户可以使用，用来加载用户自己编写的类。</li></ul> 
<p>类加载器的双亲委派模型：下游的类加载应该将类加载动作尽可能的委派给父类，如果父类不能加载（搜索范围内找不到该类），那么子类再做加载工作。（这里上下游并不是继承关系，而是组合关系）。这么做的目的是：一个类尽可能被一个类加载器加载，否则就会出现上面提到的“同一个class文件存在两个不相等的类”的问题。</p> 
<p><img src="https://images2.imgbox.com/e1/03/cMVlDzIH_o.png" alt="在这里插入图片描述" width="300"></p> 
<h5><a id="743__105"></a>7.4.3 破坏双亲委派模型</h5> 
<p>双亲委派模型只是一个建议，并不强制。</p> 
<p>有些情况确实无法遵守双亲委派模型。例如：</p> 
<ul><li><strong>基础类需要调用外部类</strong>：例如JDBC等。通常基础类（jre中的类）是由BootstrapClassLoader加载的，然而，对于JDBC这个基础类，它需要调用JDBC实现类，而实现类又是由ApplicationClassLoader加载的。因此为了让JDBC基础类可以调用实现类，就不得不让JDBC基础类使用ApplicationClassLoader来加载。这就违反了上面说的双亲委派模型。</li><li><strong>热部署</strong>：例如OSGi实现的热部署中，就没有按照双亲委派模型做。（具体细节请参考原文）</li></ul> 
<h3><a id="8__114"></a>第8章 虚拟机字节码执行引擎</h3> 
<h4><a id="81__116"></a>8.1 概述</h4> 
<p>无重点</p> 
<h4><a id="82__120"></a>8.2 运行时栈帧结构</h4> 
<p>程序运行时，每当进入一个新方法，就会在“栈”中创建一个“栈帧（Stack Frame）”，并放置在栈的最顶层。也就说，栈中最顶层的栈帧存储就是当前运行的方法的数据。</p> 
<p><img src="https://images2.imgbox.com/78/f2/eQIh7u7E_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>一个栈帧存储了如下数据：</p> 
<ul><li><strong>局部变量表</strong>(Local Variable Table)：用于存放方法参数和方法内部定义的局部变量。注意：每个方法需要使用多大的局部变量表在编译时就会确定下来。</li><li><strong>操作数栈</strong>(Operand Stack)：当方法内部进行<code>+-x÷</code>时，用于存放操作数的。例如：执行<code>1+2</code>的步骤就是，先1,2,3分别入栈，执行+操作，从栈顶取出1,2进行相加操作。（感兴趣可以百度“计算器栈实现”）</li><li><strong>动态连接</strong>(Dynamic Linking)：将方法中的符号引用转为直接引用。即记录了该方法中调用的其他方法的实际地址。例如：当前的A方法中调用了B方法和C方法，那么A方法的动态链接就会存储B方法和C方法所在的实际地址是多少。</li><li><strong>返回地址</strong>(Return Address)：存放了“当方法退出后，下一条指令的执行地址”。① 若方法正常return的退出，则执行下一条指令。② 若方法抛出异常的退出，则由异常表决定下一条指令执行什么。</li></ul> 
<h4><a id="83__133"></a>8.3 方法调用</h4> 
<p>在Java中，由于部分方法（重写或重载的方法）具体调用哪个方法是在运行时决定的。因此，方法调用是指：确定应该调用哪个方法。</p> 
<h5><a id="831__138"></a>8.3.1 解析</h5> 
<p>部分方法调用在编译期就可以唯一确定，这类方法的调用称为解析（Resolution）。</p> 
<p>符合“编译期可知，运行期不变”要求的方法，主要包括<strong>静态方法</strong>和<strong>私有方法</strong>两大类。</p> 
<h5><a id="832__146"></a>8.3.2 分派</h5> 
<p>对于多态方法（重载和重写），虚拟机确定其调用有两种方式：<strong>静态分派</strong>和<strong>动态分派</strong>。</p> 
<hr> 
<p>静态分派：对于静态方法的重载多态，会在编译期给调用的参数确定一个静态类型，以确定一个确定的方法。</p> 
<p>样例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Human</span> human<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, human"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Man</span> man<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, man"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Woman</span> woman<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, woman"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sayHello</span><span class="token punctuation">(</span>man<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：</p> 
<pre><code>Hello, human
Hello, human
</code></pre> 
<p>上述代码中的<code>Human</code>称为<strong>静态类型(Static Type)</strong>（也称为外观类型(Apparent Type)），<code>Man</code>则称为<strong>实际类型(Actual Type)</strong>。</p> 
<p>在编译期，静态类型已经可以确定，因此代码编译时该方法的调用也选择<code>sayHello(Human human)</code>进行调用，而不理会它的实际类型。</p> 
<p>也就是说，对于静态分派，要调用哪个方法在编译期就已经确定下来了。</p> 
<hr> 
<p>动态分派：如果是非静态方法的重写，那就需要在运行期动态确定应该调用哪个方法。</p> 
<p>样例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, human"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{<!-- --></span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, man"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{<!-- --></span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, woman"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：</p> 
<pre><code>Hello, man
Hello, woman
</code></pre> 
<p>由于调用的是非静态方法，因此会在运行期来确定这两个对象实际是什么类型，然后调用其对应的方法。</p> 
<h5><a id="833__247"></a>8.3.3 动态类型语言支持</h5> 
<p><strong>动态语言</strong>：在运行期对类型进行检查，例如：Javascript，python等。例如，js一个变量可以是任何类型 <code>var a = new Object(); a=3;</code>，但Java就不行。优点：动态语言灵活性高，开发效率高；缺点：错误不容易在编译期发现，导致代码稳定性差，扩展性也差。</p> 
<p><strong>静态语言</strong>：在编译期对类型进行检查，例如：Java，C++等。例如：java中<code>Object a = new Object(); a=3</code> 就是非法的。优点：代码稳定性好，很多错误在编译期就可以被发现。缺点：代码不够灵活和简洁。</p> 
<p>Java1.7之后，在虚拟机层面对动态语言类型进行了支持，可以使用<code>java.lang.invoke</code>包来实现。</p> 
<h5><a id="84__256"></a>8.4 基于栈的字节码解释执行引擎</h5> 
<p>无重点（较高级）。</p> 
<h3><a id="9__260"></a>第9章 类加载及执行子系统的案例与实战</h3> 
<h4><a id="91__262"></a>9.1 概述</h4> 
<p>虽然类加载大部分过程用户无法通过Java控制（都是由JVM自行完成的），但<strong>字节码生成</strong>和<strong>类加载器</strong>用户可以操作，利用这两点就可以玩出很多花样。</p> 
<h4><a id="92__266"></a>9.2 案例分析</h4> 
<h5><a id="921_Tomcat_267"></a>9.2.1 Tomcat：正统的类加载器结构</h5> 
<p>多个应用程序会部署在一个Tomcat的服务器上（不过现在都用Springboot了，都是一个程序一个tomcat）。</p> 
<p>如果Tomcat只使用一个类加载器可能会引发：两个程序相同路径且相同名称类只加载了一份，但两个类代码又不一样出现问题。</p> 
<p>如果Tomcat为每一个应用程序使用完全独立的类加载又会引发：两个程序都使用了Spring3.0，如果将Spring的类加载两份，又太浪费内存资源。</p> 
<p>因此，Tomcat采用的方案如下（非常符合上面提到的“双亲委派模型”）：</p> 
<p><img src="https://images2.imgbox.com/9a/d9/DCrnuvq1_o.png" alt="在这里插入图片描述" width="400"></p> 
<blockquote> 
 <p>灰色部分为Java提供的类加载器，白色部分为Tomcat自己实现的类加载器。</p> 
</blockquote> 
<p>即：对于公共类（例如：Spring等框架的类），都使用公共的<code>CommonClassLoader</code>。而对应用程序自己的类，都使用各自独立的<code>WebAppClassLoader</code>，这样就完美解决了上面两个问题。</p> 
<h5><a id="922_OSGi_282"></a>9.2.2 OSGi：灵活的类加载器结构</h5> 
<p>OSGi中，没有使用双亲委派模型的“树状结构”，而是采用了更复杂的“网状结构”。</p> 
<p>其将代码分成了各个模块（Bundle），每个Bundle有自己的类加载器，Bundle之间会互相依赖。</p> 
<p>例如：</p> 
<p><img src="https://images2.imgbox.com/e5/48/cyXb8yJf_o.png" alt="在这里插入图片描述" width="400"></p> 
<p>例如，该例子中，BundleB模块就依赖BundleA和BundleC中的代码。</p> 
<h5><a id="923__294"></a>9.2.3 字节码生成技术与动态代理的实现</h5> 
<p>在Spring中有大量的代理类，其可以在原类发放的执行前后增加一些逻辑。</p> 
<p>使用Java生成代理类的简单样例：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationHandler</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Proxy</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxyTest</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">interface</span> <span class="token class-name">IHello</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">implements</span> <span class="token class-name">IHello</span> <span class="token punctuation">{<!-- --></span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 定义动态代理类</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">Object</span> originalObj<span class="token punctuation">;</span> <span class="token comment">// 原对象</span>

        <span class="token class-name">Object</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">Object</span> originalObj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>originalObj <span class="token operator">=</span> originalObj<span class="token punctuation">;</span>
            <span class="token comment">// 返回代理类</span>
            <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    originalObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>

        <span class="token comment">// 使用代理类时，执行的其实是这个方法</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"welcome! "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在原来的方法前面增加逻辑</span>
            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行原始方法</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">IHello</span> hello <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IHello</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 给Hello绑定代理类</span>
        hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>输出：</p> 
<pre><code>welcome! hello world
</code></pre> 
<h5><a id="924_RetrotranslatorJDK_354"></a>9.2.4 Retrotranslator：跨越JDK版本</h5> 
<p>Java逆向移植（Java Backporting Tools）：将高版本JDK编写的代码放到低版本的JDK环境下部署。</p> 
<p>Retrotranslator技术就是Java逆向移植工具中较为出色的一个。</p> 
<h4><a id="93__360"></a>9.3 实战：自己动手实现远程执行功能</h4> 
<p>无重点，感兴趣可以自己看原文。</p> 
<h2><a id="__365"></a>第四部分 程序编译与代码优化</h2> 
<h3><a id="10__367"></a>第10章 早期（编译期）优化</h3> 
<h4><a id="101__369"></a>10.1 概述</h4> 
<p>编译期优化就是在编译期做的优化操作，例如很多Java新特性都是靠编译期优化实现的，其底层的JVM并没有做任何改变。</p> 
<h4><a id="102_Javac_373"></a>10.2 Javac编译器</h4> 
<p>Javac编译器是用Java实现的。</p> 
<blockquote> 
 <p>原文讲解了调试方法和编译过程。</p> 
</blockquote> 
<h4><a id="103_Java_379"></a>10.3 Java语法糖的味道</h4> 
<h5><a id="1031__381"></a>10.3.1 泛型与类型擦除</h5> 
<p>Java中的<strong>泛型只存在编译前</strong>，用于<strong>对类型进行约束（同时也方便了程序员，不用老是强制类型转换了），使代码更加安全，避免运行时产生类型转换错误</strong>。</p> 
<p>但是，在<strong>编译后泛型会被擦除</strong>。</p> 
<p>例如：</p> 
<p>编译前代码：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>编译后代码：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>编译后泛型被擦除了。</p> 
<p>因此，下面这段代码是无法编译：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypesTest</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// 编译报错，报存在相同的方法</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1032__419"></a>10.3.2 自动装箱、拆箱与遍历循环</h5> 
<p>Java的每一个基本数据类型对应了一个包装类，例如：<code>int</code>对应<code>Integer</code>。</p> 
<p>当给包装类进行赋值时可以使用基本类型，即编译器会自动将基本数据类型转为包装类，称为“自动装箱”。例如：<code>Integer a = 1;</code></p> 
<p>包装类对象可以像基本数据类型那样使用，例如四则运算。此时会自动将包装类型转为基本数据类型，称为“自动拆箱”。</p> 
<p>包装类比较时，遵循如下规则：① <code>包装类==包装类</code>，引用比较。② <code>包装类==基本数据类型</code>，值比较。</p> 
<p>例如：</p> 
<pre><code class="prism language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> e <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> f <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>
<span class="token class-name">Long</span> g <span class="token operator">=</span> <span class="token number">3L</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true 值比较</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true 引用比较（但由于小于255，因此都是一个引用）</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e <span class="token operator">==</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false 引用比较。不是同一对象</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true 值比价，因为a+b后被自动拆箱成了int</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true 值比较。</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g <span class="token operator">==</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true  值比较。(a+b)隐含个一个自动转long</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Long不能和int比较，因此为false</span>
</code></pre> 
<h5><a id="1033__448"></a>10.3.3 条件编译</h5> 
<p>编译器对<code>if</code>和循环做了优化。</p> 
<p>例如：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p>编译后：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>在例如：</p> 
<pre><code class="prism language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// 编译报错，报“语句不可达”。</span>
</code></pre> 
<h4><a id="104__472"></a>10.4 实战：插入式注解处理器</h4> 
<p>无重点</p> 
<blockquote> 
 <p>该节实战内容：对Javac进行改造，增加了一个对驼峰式命名的校验，若不符合，则编译失败。</p> 
</blockquote> 
<h3><a id="11__478"></a>第11章 晚期（运行期）优化</h3> 
<h4><a id="111__480"></a>11.1 概述</h4> 
<p>JVM运行代码通常都是依赖解释器。</p> 
<p>但，JVM中还有一个<strong>即时编译器</strong>（Just In Time Compiler，JIT），简称为JIT编译器。</p> 
<p>它的作用是：将“热点代码”（也就是运行频繁的代码）编译成本地机器码，并进行进一步优化。</p> 
<p>本章就是讲这个的。</p> 
<h4><a id="112_HotSpot_490"></a>11.2 HotSpot虚拟机内的即时编译器</h4> 
<p>无重点</p> 
<h4><a id="113__494"></a>11.3 编译优化技术</h4> 
<h5><a id="1131__496"></a>11.3.1 优化技术概览</h5> 
<p>优化可能会对你的并发结果产生影响，因此了解怎么优化的还是有必要的。</p> 
<p>对于下面这段代码的最后四行，会进行四步优化</p> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> sum<span class="token punctuation">;</span>
    <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... do something...</span>
    z <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>方法内联</strong>优化，优化后：</p> 
<pre><code class="prism language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>  <span class="token comment">// 这里被优化了</span>
<span class="token comment">// ... do something...</span>
z <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>  <span class="token comment">// 这里被优化了</span>
sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p><strong>公共子表达式消除(Common Subexpression Elimination)</strong> 优化：</p> 
<pre><code class="prism language-java">y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token comment">// ... do something...  // 假设这里没有对b.value进行修改</span>
z <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// 这里被优化了</span>
sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
</code></pre> 
<p><strong>复写传播(Copy Propagation)</strong> 优化：</p> 
<pre><code class="prism language-java">y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token comment">// ... do something... </span>
y <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// 这里被优化了，消除了z</span>
sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token comment">// 这里被优化了</span>
</code></pre> 
<p><strong>无用代码消除(Dead Code Elimination)</strong> 优化：</p> 
<pre><code>y = b.value;
// ... do something... 
// y = y;  // 这行被删除了
sum = y + y;
</code></pre> 
<h5><a id="1132__560"></a>11.3.2 公共子表达式消除</h5> 
<p>公共子表达式消除：若一个计算表达式中出现了公共的表达式，则不会重复计算。</p> 
<p>例如：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token operator">*</span>c<span class="token punctuation">)</span>
</code></pre> 
<p>会被优化成：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> <span class="token class-name">E</span> <span class="token operator">=</span> b<span class="token operator">*</span>c <span class="token punctuation">;</span> <span class="token comment">// 这里只是这样写便于理解，但实际并不会真的声明E</span>
<span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token class-name">E</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token class-name">E</span><span class="token punctuation">)</span>； <span class="token comment">// 即 对于公共表达式“b*c”不会被重复计算两次</span>

<span class="token comment">// 甚至部分JVM还会进一步优化成：</span>
<span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token class-name">E</span> <span class="token operator">*</span> <span class="token number">13</span> <span class="token operator">+</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="1133__580"></a>11.3.3 数组边界检查消除</h5> 
<p>Java在使用数据取值时，JVM会判断数组是否越界，若越界则报错。但如果每次都检查，那么性能就难免受影响。因此，如果编译时能够确定下来这段不会越界，那么就会不进行越界检查。</p> 
<h5><a id="1134__585"></a>11.3.4 方法内联</h5> 
<p>方法内联：如果编译期可以根据上下文确定调用的方法，JVM有可能会直接把该方法的内容内联到调用的地方，即不真正的调用方法。</p> 
<p>例如：</p> 
<p>优化前：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"张三"</span><span class="token punctuation">;</span>
	<span class="token function">sayHello</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>优化后：</p> 
<pre><code class="prism language-java">```java
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"张三"</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里被优化了</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1135__621"></a>11.3.5 逃逸分析</h5> 
<p>逃逸分析：一种分析手段，为其他优化提供依据。主要就是用来分析<strong>一个变量或对象是不是只在某个作用域下有效</strong>，这样就可以逃脱掉一些处理，进而优化速度或内存。</p> 
<p>主要场景：</p> 
<ul><li><strong>栈上分配</strong>(Stack Allocation)：正常来说，对象是在堆上分配的。但如果逃逸分析发现某个对象一定只是在该方法内使用，不会被其他方法访问，那么这个对象就可以在栈上分配，减缓GC压力。</li><li><strong>同步消除</strong>(Synchronization Elimination)：如果逃逸分析发现某个变量一定是在线程内使用，即不会带来并发问题，那么对该变量的同步锁等措施就可以消除掉。</li><li><strong>标量替换</strong>(Scalar Replacement)：如果逃逸分析发现一个对象不会外部访问，并且对象可以拆分成若干个变量，那么可能就不会创建该对象，而是直接创建成员变量。标量替换的主要用途就是上面的“栈上分配”。例如：<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Amy"</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 此时，根据标量替换，就会被优化成：<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"Amy"</span><span class="token punctuation">;</span> <span class="token comment">// 并没有创建Person对象</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h4><a id="114_JavaCC_645"></a>11.4 Java与C/C++的编译器对比</h4> 
<p>JVM的即时编译器和C/C++的静态编译器相比，有如下劣势：</p> 
<ul><li>即时编译器由于是在运行时编译，因此会占用用户程序的运行时间。</li><li>Java是动态的类型安全语言。jvm需要不断的进行空指针、数组是否越界、类型转换是否安全等的检查。</li><li>由于多态特性，具体调用哪个方法很多都是运行时决定的。这加大了编译器优化时结合上下文的难度。</li><li>Java中只有局部变量才是在栈上分，而对象都是在堆上分。而C++则可以自由选择，因此在垃圾收集效率上，C++有明显优势。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38a4a2e911a6c805fd7946c88c44bae0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【读书笔记】深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f84943962dbb4cb40d046ef854d6802b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【读书笔记】深入理解Java虚拟机（周志明）（5）第五部分 高效并发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>