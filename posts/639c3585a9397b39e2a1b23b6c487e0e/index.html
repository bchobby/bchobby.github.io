<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32F103系列芯片的地址映射和寄存器映射原理，以及GPIO端口的初始化设置 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32F103系列芯片的地址映射和寄存器映射原理，以及GPIO端口的初始化设置" />
<meta property="og:description" content="文章目录 一、STM32F103系列芯片的地址映射和寄存器映射原理1、什么是寄存器（1）基本概念（2）举例说明（3）地址映射 2、地址映射和寄存器映射原理（1）存储器映射（2）寄存器映射 二、GPIO初始化设置步骤（时钟配置、输入输出模式设置、最大速率设置）（1）基本介绍（2）工作模式（3）初始化1. 首先配置时钟使能2. 配置为通用输出3. 设置输出值 三、解决两个问题四、解释嵌入式中常见的register和volatile 关键字1、register关键字（1）介绍（2）应用（3）示例代码 2、volatile关键字（1）介绍（2）应用（3）示例代码 总结参考文献 一、STM32F103系列芯片的地址映射和寄存器映射原理 1、什么是寄存器 （1）基本概念 现代的计算机主要包括三级存储，寄存器、内存储器和外存储器，存储数据的速率也依次递减。
寄存器是中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。
存放数据的寄存器：如果你需要读取一个数据，直接到这个寄存器所在的地方来问问他，数据是多少就行了。问寄存器这个动作，叫做访问寄存器。不同的数据会存放在不同的寄存器，例如：引脚PA2与PB8的高低电平数据（1或0）肯定放在不同的寄存器里，那么怎么区分不同的寄存器呢？通过地址，不同的寄存器有不同的地址，就像老张行李寄存处在101号店铺，老王行李寄存处在258号店铺。
指令、地址寄存器与数据寄存器类似，里边存放的都是0和1，只是特别的规定下，数据寄存器里面存放的0和1表示数据，指令寄存器里存放的表示指令。
（2）举例说明 比如，我们找到 GPIOB 端口的输出数据寄存器 ODR 的地址是 0x4001 0C0C（至于这个地址如何找到可以先跳过，后面我们会有详细的讲解），ODR 寄存器是 32bit，低 16bit有效，对应着 16 个外部 IO，写 0/1 对应的的 IO 则输出低/高电平。现在我们通过 C 语言指
针的操作方式，让 GPIOB 的 16 个 IO 都输出高电平，具体见代码
通过绝对地址访问内存单元
// GPIOB 端口全部输出 高电平 *(unsigned int*)(0x4001 0C0C) = 0xFFFF; 0x4001 0C0C在我们看来是 GPIOB端口 ODR的地址，但是在编译器看来，这只是一个普通的变量，是一个立即数，要想让编译器也认为是指针，我们得进行强制类型转换，把它转换成指针，即(unsigned int *)0x4001 0C0C，然后再对这个指针进行 * 操作。刚刚我们说了，通过绝对地址访问内存单元不好记忆且容易出错，我们可以通过寄存器的方式来操作，具体见代码
通过寄存器别名方式访问内存单元
// GPIOB 端口全部输出 高电平 #define GPIOB_ODR (unsigned int*)(GPIOB_BASE&#43;0x0C) * GPIOB_ODR = 0xFF; 为了方便操作，我们干脆把指针操作“*”也定义到寄存器别名里面，具体见代码" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/639c3585a9397b39e2a1b23b6c487e0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-31T21:41:10+08:00" />
<meta property="article:modified_time" content="2023-10-31T21:41:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32F103系列芯片的地址映射和寄存器映射原理，以及GPIO端口的初始化设置</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#STM32F103_6" rel="nofollow">一、STM32F103系列芯片的地址映射和寄存器映射原理</a></li><li><ul><li><a href="#1_7" rel="nofollow">1、什么是寄存器</a></li><li><ul><li><a href="#1_8" rel="nofollow">（1）基本概念</a></li><li><a href="#2_18" rel="nofollow">（2）举例说明</a></li><li><a href="#3_45" rel="nofollow">（3）地址映射</a></li></ul> 
   </li><li><a href="#2_50" rel="nofollow">2、地址映射和寄存器映射原理</a></li><li><ul><li><a href="#1_52" rel="nofollow">（1）存储器映射</a></li><li><a href="#2_65" rel="nofollow">（2）寄存器映射</a></li></ul> 
  </li></ul> 
  </li><li><a href="#GPIO_101" rel="nofollow">二、GPIO初始化设置步骤（时钟配置、输入输出模式设置、最大速率设置）</a></li><li><ul><li><a href="#1_103" rel="nofollow">（1）基本介绍</a></li><li><a href="#2_113" rel="nofollow">（2）工作模式</a></li><li><a href="#3_154" rel="nofollow">（3）初始化</a></li><li><ul><li><a href="#1__157" rel="nofollow">1. 首先配置时钟使能</a></li><li><a href="#2__170" rel="nofollow">2. 配置为通用输出</a></li><li><a href="#3__199" rel="nofollow">3. 设置输出值</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_210" rel="nofollow">三、解决两个问题</a></li><li><a href="#registervolatile__260" rel="nofollow">四、解释嵌入式中常见的register和volatile 关键字</a></li><li><ul><li><a href="#1register_264" rel="nofollow">1、register关键字</a></li><li><ul><li><a href="#1_265" rel="nofollow">（1）介绍</a></li><li><a href="#2_270" rel="nofollow">（2）应用</a></li><li><a href="#3_277" rel="nofollow">（3）示例代码</a></li></ul> 
   </li><li><a href="#2volatile_295" rel="nofollow">2、volatile关键字</a></li><li><ul><li><a href="#1_297" rel="nofollow">（1）介绍</a></li><li><a href="#2_304" rel="nofollow">（2）应用</a></li><li><a href="#3_314" rel="nofollow">（3）示例代码</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_352" rel="nofollow">总结</a></li><li><a href="#_362" rel="nofollow">参考文献</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="STM32F103_6"></a>一、STM32F103系列芯片的地址映射和寄存器映射原理</h2> 
<h3><a id="1_7"></a>1、什么是寄存器</h3> 
<h4><a id="1_8"></a>（1）基本概念</h4> 
<p>现代的计算机主要包括三级存储，寄存器、内存储器和外存储器，存储数据的速率也依次递减。</p> 
<p>寄存器是中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存<strong>指令</strong>、<strong>数据</strong>和<strong>地址</strong>。</p> 
<p>存放<strong>数据</strong>的寄存器：如果你需要读取一个数据，直接到这个寄存器所在的地方来问问他，数据是多少就行了。问寄存器这个动作，叫做访问寄存器。不同的数据会存放在不同的寄存器，例如：引脚PA2与PB8的高低电平数据（1或0）肯定放在不同的寄存器里，那么怎么区分不同的寄存器呢？通过地址，不同的寄存器有不同的地址，就像老张行李寄存处在101号店铺，老王行李寄存处在258号店铺。</p> 
<p><strong>指令</strong>、<strong>地址</strong>寄存器与数据寄存器类似，里边存放的都是0和1，只是特别的规定下，数据寄存器里面存放的0和1表示数据，指令寄存器里存放的表示指令。</p> 
<h4><a id="2_18"></a>（2）举例说明</h4> 
<p>比如，我们找到 GPIOB 端口的输出数据寄存器 ODR 的地址是 0x4001 0C0C（至于这个地址如何找到可以先跳过，后面我们会有详细的讲解），ODR 寄存器是 32bit，低 16bit有效，对应着 16 个外部 IO，写 0/1 对应的的 IO 则输出低/高电平。现在我们通过 C 语言指<br> 针的操作方式，让 GPIOB 的 16 个 IO 都输出高电平，具体见代码</p> 
<p>通过绝对地址访问内存单元</p> 
<pre><code class="prism language-c"> <span class="token comment">// GPIOB 端口全部输出 高电平</span>
 <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x4001</span> <span class="token number">0</span>C0C<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>
</code></pre> 
<p>0x4001 0C0C在我们看来是 GPIOB端口 ODR的地址，但是在编译器看来，这只是一个普通的变量，是一个立即数，要想让编译器也认为是指针，我们得进行强制类型转换，把它转换成指针，即(unsigned int *)0x4001 0C0C，然后再对这个指针进行 * 操作。刚刚我们说了，通过绝对地址访问内存单元不好记忆且容易出错，我们可以通过寄存器的方式来操作，具体见代码</p> 
<p>通过寄存器别名方式访问内存单元</p> 
<pre><code class="prism language-c"> <span class="token comment">// GPIOB 端口全部输出 高电平</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIOB_ODR</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x0C</span><span class="token punctuation">)</span></span></span>
 <span class="token operator">*</span> GPIOB_ODR <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>
</code></pre> 
<p>为了方便操作，我们干脆把指针操作“*”也定义到寄存器别名里面，具体见代码</p> 
<p>通过寄存器别名访问内存单元</p> 
<pre><code class="prism language-c"> <span class="token comment">// GPIOB 端口全部输出 高电平</span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIOB_ODR</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x0C</span><span class="token punctuation">)</span></span></span>
 GPIOB_ODR <span class="token operator">=</span> <span class="token number">0xFF</span>
</code></pre> 
<h4><a id="3_45"></a>（3）地址映射</h4> 
<p>为了保证CPU执行指令时可正确访问存储单元，需将用户程序中的逻辑地址转换为运行时由机器直接寻址的物理地址，这一过程称为<strong>地址映射</strong></p> 
<h3><a id="2_50"></a>2、地址映射和寄存器映射原理</h3> 
<h4><a id="1_52"></a>（1）存储器映射</h4> 
<p>存储器本身没有地址，给存储器分配地址的过程叫存储器映射，我们知道地址是连续的如果我们需要给存储器分配地址，可以将地址分为多组，将每一组地址映射给对应的存储器，这就是<strong>存储器映射</strong>，具体见下图。<br> <img src="https://images2.imgbox.com/e6/d3/gR37jEGX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>存储器区域功能划分</strong><br> 在这 4GB 的地址空间中，ARM 已经粗线条的平均分成了 8 个块，每块 512MB，每个块也都规定了用途，具体分类见表格 6-1。每个块的大小都有 512MB，显然这是非常大的，芯片厂商在每个块的范围内设计各具特色的外设时并不一定都用得完，都是只用了其中的一部分而已。</p> 
<p>存储器功能分类表<br> <img src="https://images2.imgbox.com/db/42/FlXg8poO_o.png" alt="在这里插入图片描述"></p> 
<p>在这 8个 Block里面，有 3个块非常重要，也是我们最关心的三个块。Block0用来设计成内部 FLASH，Block1 用来设计成内部 RAM，Block2 用来设计成片上的外设。</p> 
<h4><a id="2_65"></a>（2）寄存器映射</h4> 
<p>以STM32为例，操作硬件本质上就是操作寄存器。在存储器片上外设区域，四字节为一个单元，每个单元对应不同的功能。当我们控制这些单元时就可以驱动外设工作，我们可以找到每个单元的起始地址，然后通过C 语言指针的操作方式来访问这些单元。但若每次都是通过这种方式访问地址，不好记忆且易出错。这时我们可以根据每个单元功能的不同，以功能为名给这个内存单元取一个别名，这个别名实质上就是寄存器名字。<strong>给已分配好地址(通过存储器映射实现)的有特定功能的内存单元取别名的过程就叫寄存器映射。</strong></p> 
<blockquote> 
 <p>GPIOA下的某个寄存器,挂载在GPIOA下,地址为GPIOA基地址+偏移量；<br> GPIOA挂载在APB2总线,地址为APB2总线基地址+GPIOA偏移量；<br> ABP2挂载加外设基地址,地址为外设基地址+ABP2偏移量</p> 
</blockquote> 
<p>下面通过查找GPIOB端口相关寄存器进行举例：</p> 
<p><strong>第一步，找到GPIOB的基地址</strong><br> 也就是找到GPIOB的小区。结论是，所有GPIOB相关的寄存器，都住在0x4001 0C00到0x4001 0FFF范围内。<br> <img src="https://images2.imgbox.com/cb/81/RsY54IBq_o.png" alt="在这里插入图片描述"></p> 
<p><strong>第二步，找到端口输入寄存器的地址偏移</strong><br> 找到存储数据的地址，结论是0x4001 0C00+0x08 = 0x4001 0C08<br> <img src="https://images2.imgbox.com/f8/c9/JX0DL5Db_o.png" alt="在这里插入图片描述"></p> 
<p><strong>第三步，找到存储数据的最终位置</strong><br> PB3的数据位于从右往左数第4个。<br> <img src="https://images2.imgbox.com/63/74/1gcpo8sX_o.png" alt="在这里插入图片描述"></p> 
<p>我们可以简单地直接访问这个地址：</p> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>GPIOB_IDR<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x40010C08</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> PB3 <span class="token operator">=</span> <span class="token operator">*</span>GPIOB_IDR <span class="token operator">&amp;</span> <span class="token number">0x8</span><span class="token punctuation">;</span><span class="token comment">//取出从右往左数的第4位</span>
</code></pre> 
<p><code>提示：这里可以添加本文要记录的大概内容：</code></p> 
<p>例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。</p> 
<hr> 
<p><code>提示：以下是本篇文章正文内容，下面案例可供参考</code></p> 
<h2><a id="GPIO_101"></a>二、GPIO初始化设置步骤（时钟配置、输入输出模式设置、最大速率设置）</h2> 
<h3><a id="1_103"></a>（1）基本介绍</h3> 
<p><strong>GPIO</strong> 是通用<strong>输入输出端口</strong>的简称，简单来说就是 STM32 可控制的引脚，STM32 芯片的 GPIO 引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。STM32 芯片的 GPIO 被分成很多组，每组有 16 个引脚，如型号为 STM32F103VET6 型号的芯片有 GPIOA、GPIOB、GPIOC至 GPIOE共 5组 GPIO，芯片一共 100个引脚，其中 GPIO就占了一大部分，所有的 GPIO 引脚都有基本的输入输出功能。</p> 
<p><strong>最基本的输出功能</strong><br> 是由 STM32 控制引脚输出高、低电平，实现开关控制，如把 GPIO引脚接入到 LED灯，那就可以控制 LED灯的亮灭，引脚接入到继电器或三极管，那就可以通过继电器或三极管控制外部大功率电路的通断。</p> 
<p><strong>最基本的输入功能</strong><br> 检测外部输入电平，如把 GPIO 引脚连接到按键，通过电平高低区分按键是否被按下。</p> 
<h3><a id="2_113"></a>（2）工作模式</h3> 
<p><strong>GPIO框架图</strong><br> <img src="https://images2.imgbox.com/8b/1a/JgMDEwR3_o.png" alt="在这里插入图片描述"><br> 由 GPIO 的结构决定了 GPIO 可以配置成以下模式：</p> 
<pre><code class="prism language-c">由 GPIO 的结构决定了 GPIO 可以配置成以下模式：
GPIO <span class="token number">8</span> 种工作模式<span class="token operator">:</span>
<span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">{<!-- --></span>
	GPIO_Mode_AIN <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token comment">// 模拟输入</span>
 	GPIO_Mode_IN_FLOATING <span class="token operator">=</span> <span class="token number">0x04</span><span class="token punctuation">,</span> <span class="token comment">// 浮空输入</span>
 	GPIO_Mode_IPD <span class="token operator">=</span> <span class="token number">0x28</span><span class="token punctuation">,</span> <span class="token comment">// 下拉输入</span>
	GPIO_Mode_IPU <span class="token operator">=</span> <span class="token number">0x48</span><span class="token punctuation">,</span> <span class="token comment">// 上拉输入</span>
	GPIO_Mode_Out_OD <span class="token operator">=</span> <span class="token number">0x14</span><span class="token punctuation">,</span> <span class="token comment">// 开漏输出</span>
	GPIO_Mode_Out_PP <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">,</span> <span class="token comment">// 推挽输出</span>
	GPIO_Mode_AF_OD <span class="token operator">=</span> <span class="token number">0x1C</span><span class="token punctuation">,</span> <span class="token comment">// 复用开漏输出</span>
	GPIO_Mode_AF_PP <span class="token operator">=</span> <span class="token number">0x18</span> <span class="token comment">// 复用推挽输出</span>
<span class="token punctuation">}</span> GPIOMode_TypeDef<span class="token punctuation">;</span>
</code></pre> 
<p>在固件库中，GPIO 总共有 8 种细分的工作模式，稍加整理可以大致归类为以下三类：</p> 
<p><strong>输入模式(模拟/浮空/上拉/下拉)</strong><br> 在输入模式时，施密特触发器打开，输出被禁止，可通过输入数据寄存器 GPIOx_IDR<br> 读取 I/O 状态。其中输入模式，可设置为上拉、下拉、浮空和模拟输入四种。上拉和下拉<br> 输入很好理解，默认的电平由上拉或者下拉决定。浮空输入的电平是不确定的，完全由外<br> 部的输入决定，一般接按键的时候用的是这个模式。模拟输入则用于 ADC 采集。</p> 
<p><strong>输出模式(推挽/开漏)</strong><br> 在输出模式中，推挽模式时双 MOS 管以轮流方式工作，输出数据寄存器 GPIOx_ODR<br> 可控制 I/O 输出高低电平。开漏模式时，只有 N-MOS 管工作，输出数据寄存器可控制 I/O<br> 输出高阻态或低电平。输出速度可配置，有 2MHz\10MHz\50MHz的选项。此处的输出速度<br> 即 I/O 支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求不<br> 严格，把速度设置成最大即可。</p> 
<p>在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器 GPIOx_IDR<br> 可读取 I/O 的实际状态。</p> 
<p><strong>复用功能(推挽/开漏)</strong><br> 复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器 GPIOx_ODR 无效；输入可用，通过输入数据寄存器可获取 I/O 实际状态，但一般直接用外设的寄存器来获取该数据信号。</p> 
<h3><a id="3_154"></a>（3）初始化</h3> 
<p>下面以操作寄存器来点亮LED了解GPIO初始化步骤</p> 
<h4><a id="1__157"></a>1. 首先配置时钟使能</h4> 
<p>时钟控制名字叫做RCC，属于AHB总线。GPIOB属于APB2<br> <img src="https://images2.imgbox.com/69/16/NyYUJW1U_o.png" alt="在这里插入图片描述"><br> 由下图可知AHB总线包含RCC时钟控制，GPIO是属于APB2<br> <img src="https://images2.imgbox.com/9d/40/yuiUWi9j_o.png" alt="在这里插入图片描述"><br> 　<strong>我们已经知道，GPIO端口B的地址从0x4001 0C00开始。接下来只寻找时钟使能寄存器的地址：<br> 　复位和时钟控制RCC的地址从0x4002 1000开始</strong><br> 　<br> APB2外设时钟使能寄存器（RCC_APB2ENR），偏移地址是0x18,所以APB2的地址就是0x4002 1018。<br> RCC_APB2ENR，位3是IOPBEN，名字是IO端口B时钟使能，就是我们想要的。把RCC_APB2ENR的位3赋值为1，就是开启GPIOB时钟。</p> 
<p><img src="https://images2.imgbox.com/45/29/yXdCNoiX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__170"></a>2. 配置为通用输出</h4> 
<p>由于STM32的每个IO都需要4个位来配置，所以一个32位的寄存器最大只能配置8个IO，由于STM32的每个IO都需要4个位来配置，所以一个32位的寄存器最大只能配置8个IO</p> 
<p>查看原理图可以看到点亮红色灯为PB5<br> <img src="https://images2.imgbox.com/22/13/ViGPe3js_o.png" alt="在这里插入图片描述"></p> 
<p>配置引脚PB5，使用的寄存器是GPIOB_CRL。下面我们来寻找这个寄存器的地址。<br> <img src="https://images2.imgbox.com/ce/bb/2c6n1aEC_o.png" alt="在这里插入图片描述"></p> 
<p>那么需要的寄存器是低位的寄存器GPIOB_CRL，它的地址是0x4001 0c00，端口号为5<br> 找到需要操作的寄存器后，把它配置为通用输出。　我们需要的是输出高低电平，所以要设置为输出。输出模式又有好几种输出：</p> 
<p>00：通用推挽输出模式<br> 01：通用开漏输出模式<br> 10：复用功能推挽输出模式<br> 11：复用功能开漏输出模式</p> 
<p>由此可得：</p> 
<pre><code class="prism language-c"><span class="token comment">// 开启GPIOB 端口时钟</span>
	RCC_APB2ENR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//清空控制PB5的端口位</span>
	GPIOB_CRL <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span> <span class="token number">0x0F</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token comment">// 配置PB5为通用推挽输出，速度为10M</span>
	GPIOB_CRL <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样就把对应的IO口输入输出模式调好了</p> 
<h4><a id="3__199"></a>3. 设置输出值</h4> 
<p>查看GPIO输出文档（GPIOx_ODR）<br> <img src="https://images2.imgbox.com/2d/52/Sj5uapZS_o.png" alt="在这里插入图片描述"></p> 
<p>地址偏移量0x0c，由于低电平有效所以需要将第5位设置成0，其它端口设置成1，可以实现LED的点亮</p> 
<pre><code class="prism language-c"><span class="token comment">// PB5 输出 低电平</span>
	GPIOB_ODR <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_210"></a>三、解决两个问题</h2> 
<p><strong>1.嵌入式C程序代码对内存(RAM)中的各变量的修改操作，与对外部设备（寄存器—&gt;对应相关管脚）的操作有哪些相同与差别？</strong></p> 
<p>嵌入式C程序代码对内存(RAM)中的变量和对外设(寄存器)的操作,主要差别如下:</p> 
<p><strong>相同点:</strong></p> 
<p>都可以通过赋值操作来修改值,如int a=10; write_reg(REG, 20);</p> 
<p>都可以通过指针来访问,如*ptr = 30;</p> 
<p><strong>差异点:</strong></p> 
<p>存储位置不同,变量在RAM中,外设寄存器在外设芯片内部。</p> 
<p>访问方法不同,变量直接操作,外设需要通过读写函数接口。</p> 
<p>访问速度,RAM访问速度快,外设寄存器通过总线需要更长时间。</p> 
<p>访问范围,变量任意读写,外设寄存器只能访问已开放的范围。</p> 
<p>初始化需求,变量可以不初始化直接使用,外设需要在使用前初始化外设和寄存器。</p> 
<p>错误处理,变量错误难定位,外设可以通过状态位判断错误类型。</p> 
<p>访问权限,变量在程序内任意访问,外设需要按手册了解每个寄存器的读写属性。</p> 
<p>所以总体来说,变量访问更简单直接,外设寄存器访问需要考虑外设接口规范和性能限制。这给嵌入式程序设计带来一定的难度。</p> 
<p><strong>2、为什么51单片机的LED点灯编程要比STM32的简单？</strong><br> 51单片机LED点灯编程比STM32简单主要有以下几点原因:</p> 
<p>51单片机IO口直接连接LED,只需设置IO口为输出模式并输出高电平即可点亮LED。STM32需要通过外设驱动LED,增加了一层外设驱动的复杂度。</p> 
<p>51单片机IO口操作直接使用单指令SETB/CLR即可,STM32需要配置GPIO外设寄存器,增加了配置步骤。</p> 
<p>51单片机没有时钟和电源管理模块,LED点亮不需要配置这些外设。STM32需要配置时钟树、电源管理等外设。</p> 
<p>51单片机没有内存保护,直接使用数据区域内存操作IO口。STM32需要考虑内存映射区和外设寄存器访问权限。</p> 
<p>51单片机开发环境相对简单,如KEIL只需添加几行代码即可。STM32需要使用更复杂的开发环境如MDK/IAR/SW4STM32。</p> 
<p>51单片机指令集简单,不需要学习复杂的ARM指令。STM32需要学习ARM指令集知识。</p> 
<p>51单片机例程少,例如LED点亮只需几行代码。STM32例程复杂度较高,需要了解更多外设知识。</p> 
<p>所以总体来说,51单片机的硬件结构和软件开发环境都较为简单,对初学者LED点亮编程难度小,上手更快。STM32由于外设驱动的增加,开发难度相对更高。</p> 
<h2><a id="registervolatile__260"></a>四、解释嵌入式中常见的register和volatile 关键字</h2> 
<p>与PC平台上的一般程序不同，嵌入式C程序经常会看见 register和volatile 关键字，下面我们将解释这两个变量修饰符的作用，并用C代码示例进行说明。</p> 
<h3><a id="1register_264"></a>1、register关键字</h3> 
<h4><a id="1_265"></a>（1）介绍</h4> 
<p>在嵌入式系统中，寄存器是位于CPU内部的高速存储器，用于存储临时数据和执行指令。使用寄存器变量可以提高程序的执行速度和效率，因为寄存器的访问速度比内存快得多。</p> 
<p>当使用register关键字声明变量时，编译器会尽可能地将该变量存储在寄存器中，以便快速访问。然而，嵌入式系统的编译器可能会忽略register关键字，因为寄存器的数量有限，编译器需要根据需要进行优化和分配寄存器。</p> 
<h4><a id="2_270"></a>（2）应用</h4> 
<p>关键性能代码：对于一些关键性能代码，例如内部循环或频繁执行的代码段，可以使用register关键字声明相关的变量。这样可以减少对内存的访问延迟，从而提高代码的执行速度。</p> 
<p>中断处理程序：在嵌入式系统中，中断处理程序的执行时间通常要求非常短。通过使用register关键字声明一些关键变量，可以减少对内存的访问，提高中断处理程序的响应速度。</p> 
<p>硬件接口：与外部硬件设备进行通信时，通常需要频繁读写寄存器。通过使用register关键字声明与硬件接口相关的变量，可以加快对寄存器的访问速度，提高数据传输的效率。</p> 
<h4><a id="3_277"></a>（3）示例代码</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">register</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//使用register关键字声明变量count</span>
	
	<span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The value of count is: %d\n"</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span> 
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的示例中，我们使用 “register” 关键字声明了一个整数变量 “count”。这将提示编译器将该变量存储在寄存器中，以提高访问速度。然而，实际上，编译器可能会忽略 “register” 关键字，并根据优化策略自动决定变量的存储位置。</p> 
<h3><a id="2volatile_295"></a>2、volatile关键字</h3> 
<h4><a id="1_297"></a>（1）介绍</h4> 
<p>在嵌入式系统中，volatile关键字用于告诉编译器变量的值可能会在意料之外的时间被修改，因此编译器不应该对该变量进行优化。</p> 
<p>嵌入式系统中，有些变量的值可能会被硬件或者其他任务异步地修改，而编译器通常会对变量进行优化，例如将变量的值缓存在寄存器中，以提高访问速度。然而，这种优化可能会导致程序出现错误，因为编译器不知道变量的值可能会在意料之外的时间被修改。</p> 
<p>使用volatile关键字可以告诉编译器不要对变量进行优化，每次访问变量时都从内存中读取或写入变量的值。这样可以确保程序始终使用最新的变量值，而不是使用缓存的值。</p> 
<h4><a id="2_304"></a>（2）应用</h4> 
<p>外设寄存器：嵌入式系统通常需要与外部设备进行通信，例如控制器、传感器等。这些设备通常通过特定的寄存器与嵌入式系统进行交互。使用volatile关键字可以确保每次访问寄存器时都是从内存中读取或写入最新的值。</p> 
<p>中断处理程序：嵌入式系统经常会使用中断来处理外部事件，例如定时器溢出、外部输入等。中断处理程序通常需要访问和更新共享的状态变量。使用volatile关键字可以确保中断处理程序对这些变量的访问是原子的，并且不会被编译器优化。</p> 
<p>多任务间通信：在多任务系统中，任务之间需要进行通信和共享数据。使用volatile关键字可以确保任务在读取和修改共享数据时，始终使用最新的值，避免数据不一致性的问题。</p> 
<p>嵌入式系统的状态变量：嵌入式系统通常会有一些状态变量，用于表示系统的状态或者标志位。这些变量可能会被不同的任务或者中断处理程序修改。使用volatile关键字可以确保对这些状态变量的读取和修改是可见的，并且不会被编译器优化。</p> 
<h4><a id="3_314"></a>（3）示例代码</h4> 
<p><strong>示例代码1：</strong><br> 在程序中对GPIO相关寄存器的定义</p> 
<pre><code class="prism language-c"><span class="token number">1.</span> #define <span class="token function">PINSEL0</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0xE002C000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2.</span> #define <span class="token function">PINSEL1</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0xE002C004</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">3.</span> #define <span class="token function">PINSEL2</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0xE002C008</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">4.</span> #define <span class="token function">PINSEL3</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0xE002C00C</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>寄存器的定义应该用volatile修饰，避免其在编译过程中被编译器优化，产生意想不到的后果。</p> 
<p><strong>示例代码2：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	
	<span class="token keyword">volatile</span> <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">//使用volatile关键字声明变量x</span>
	
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//循环等待，编译器不会优化对x的读取 </span>
		
	<span class="token punctuation">}</span> 
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
	
 <span class="token punctuation">}</span> 
</code></pre> 
<p>在上面的代码中，使用volatile关键字声明了变量x。循环会持续等待，因为编译器会将对变量x的读取保留在循环中，以便在变量发生改变时立即响应。</p> 
<hr> 
<h2><a id="_352"></a>总结</h2> 
<p><strong>1）嵌入式C程序代码对内存(RAM)中的各变量的修改操作，与对外部设备（寄存器—&gt;对应相关管脚）的操作有哪些相同与差别？</strong></p> 
<p>在嵌入式C程序中，对内存中的变量进行修改操作和对外部设备的操作有相同和差异之处。相同之处是，无论是修改内存中的变量还是对外部设备进行操作，都需要通过特定的指令或函数来进行读写操作。此外，无论是修改内存中的变量还是对外部设备进行操作，都需要使用特定的地址或寄存器来定位变量或设备，并且通过读取或写入相应的值来改变状态或数据。</p> 
<p><strong>2）为什么51单片机的LED点灯编程要比STM32的简单？</strong></p> 
<p>LED点灯编程在51单片机上相对简单的原因主要有以下几点：首先，51单片机的引脚功能相对简单，通常只需要将引脚设置为输出模式并给相应的引脚赋值即可实现LED的点亮和熄灭。其次，51单片机的开发环境和编程工具相对成熟，有很多成熟的开发板和开发套件可供选择，开发者可以直接使用这些工具进行开发，减少了开发的复杂性。此外，51单片机的指令集相对简单，编程接口也相对统一，具有一定的易用性和可读性。</p> 
<h2><a id="_362"></a>参考文献</h2> 
<p><a href="https://blog.csdn.net/qq_46470208/article/details/120846673?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-120846673.142%5Ev94%5Einsert_down28v1&amp;spm=1018.2226.3001.4187">STM32F103系列芯片的地址和寄存器映射原理、LED轮流闪烁实现</a></p> 
<p><a href="https://blog.csdn.net/qq_45917157/article/details/120855266?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169556069416800197079638%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169556069416800197079638&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-120855266-null-null.142%5Ev94%5Einsert_down28v1&amp;utm_term=%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86&amp;spm=1018.2226.3001.4187">STM32F103系列芯片的地址映射和寄存器映射原理&amp;&amp;GPIO端口的初始化设置</a></p> 
<p><a href="https://blog.csdn.net/qq_46470208/article/details/120846673?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-120846673.142%5Ev94%5Einsert_down28v1&amp;spm=1018.2226.3001.4187">STM32F103系列芯片的地址和寄存器映射原理、LED轮流闪烁实现</a></p> 
<p><a href="https://blog.51cto.com/u_16003019/7584043#:~:text=%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E7%9A%84%20register%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%BC%95%E8%A8%80%EF%BC%9A%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8Cregister%E5%92%8Cvolatile%E6%98%AF%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E5%A4%84%E7%90%86%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%82,register%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E4%BA%8E%E6%8C%87%E7%A4%BA%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%86%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%EF%BC%8C%E4%BB%A5%E6%8F%90%E9%AB%98%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E5%92%8C%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E3%80%82%20%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%EF%BC%8C%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%B8%8E%E7%A1%AC%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E3%80%82" rel="nofollow">嵌入式中的 register和volatile关键字</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/404594697d719c74e99004d79df14d1b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">博客搬家,搬到博客园</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f72e18b0d945a6495f235ce819cb1385/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kmeans</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>