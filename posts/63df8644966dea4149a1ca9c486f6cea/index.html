<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM详解 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM详解" />
<meta property="og:description" content="目录
一、前言
1.什么是JVM?
2.学习路线
二、内存结构
1.程序计数器
2.虚拟机栈
3.本地方法栈
4.堆
5.方法区
6.直接内存
三、垃圾回收
1.如果判断对象可以回收
2.垃圾回收算法
3.垃圾回收器
CMS收集器
G1（Garbage First）收集器：区域化分代式
4.垃圾回收调优
四、类加载与字节码技术
1.类文件结构
2.字节码指令
图解方法执行流程
通过字节码指令分析问题
构造方法
方法调用
多态原理
异常处理
Synchronized
3.编译期处理
默认构造器
自动拆装箱
泛型集合取值
可变参数
foreach 循环
switch 字符串
switch 枚举
枚举类
try-with-resources
方法重写时的桥接方法
匿名内部类
4.类加载阶段
加载
连接
初始化
典型应用 - 完成懒惰初始化单例模式
5.类加载器
双亲委派模式
自定义类加载器
线程上下文类加载器（破坏双亲委派模式）
6.运行期优化
即时编译
方法内联
反射优化
一、前言 1.什么是JVM? 定义： Java Virtual Machine - java 程序的运行环境（ java 二进制字节码的运行环境） 好处： 一次编写，到处运行 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/63df8644966dea4149a1ca9c486f6cea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-04T12:46:45+08:00" />
<meta property="article:modified_time" content="2023-08-04T12:46:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">一、前言</a></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AFJVM%3F-toc" style="margin-left:40px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AFJVM%3F" rel="nofollow">1.什么是JVM?</a></p> 
<p id="2.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-toc" style="margin-left:40px;"><a href="#2.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF" rel="nofollow">2.学习路线</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84" rel="nofollow"> 二、内存结构</a></p> 
<p id="1.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-toc" style="margin-left:40px;"><a href="#1.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8" rel="nofollow">1.程序计数器</a></p> 
<p id="2.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-toc" style="margin-left:40px;"><a href="#2.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88" rel="nofollow">2.虚拟机栈</a></p> 
<p id="3.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-toc" style="margin-left:40px;"><a href="#3.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88" rel="nofollow">3.本地方法栈</a></p> 
<p id="4.%E5%A0%86-toc" style="margin-left:40px;"><a href="#4.%E5%A0%86" rel="nofollow">4.堆</a></p> 
<p id="5.%E6%96%B9%E6%B3%95%E5%8C%BA-toc" style="margin-left:40px;"><a href="#5.%E6%96%B9%E6%B3%95%E5%8C%BA" rel="nofollow">5.方法区</a></p> 
<p id="6.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-toc" style="margin-left:40px;"><a href="#6.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98" rel="nofollow">6.直接内存</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" rel="nofollow">三、垃圾回收</a></p> 
<p id="1.%E5%A6%82%E6%9E%9C%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6-toc" style="margin-left:40px;"><a href="#1.%E5%A6%82%E6%9E%9C%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6" rel="nofollow">1.如果判断对象可以回收</a></p> 
<p id="2.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95" rel="nofollow">2.垃圾回收算法</a></p> 
<p id="3.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-toc" style="margin-left:40px;"><a href="#3.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" rel="nofollow">3.垃圾回收器</a></p> 
<p id="CMS%E6%94%B6%E9%9B%86%E5%99%A8-toc" style="margin-left:120px;"><a href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8" rel="nofollow">CMS收集器</a></p> 
<p id="G1%EF%BC%88Garbage%20First%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F-toc" style="margin-left:120px;"><a href="#G1%EF%BC%88Garbage%20First%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F" rel="nofollow">G1（Garbage First）收集器：区域化分代式</a></p> 
<p id="4.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98-toc" style="margin-left:40px;"><a href="#4.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98" rel="nofollow">4.垃圾回收调优</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF" rel="nofollow">四、类加载与字节码技术</a></p> 
<p id="%C2%A01.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%C2%A01.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" rel="nofollow"> 1.类文件结构</a></p> 
<p id="2.%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#2.%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4" rel="nofollow">2.字节码指令</a></p> 
<p id="%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-toc" style="margin-left:120px;"><a href="#%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B" rel="nofollow">图解方法执行流程</a></p> 
<p id="%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98" rel="nofollow">通过字节码指令分析问题</a></p> 
<p id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">构造方法</a></p> 
<p id="%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" rel="nofollow">方法调用</a></p> 
<p id="%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86" rel="nofollow">多态原理</a></p> 
<p id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow">异常处理</a></p> 
<p id="Synchronized-toc" style="margin-left:80px;"><a href="#Synchronized" rel="nofollow">Synchronized</a></p> 
<p id="3.%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#3.%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86" rel="nofollow">3.编译期处理</a></p> 
<p id="%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8" rel="nofollow">默认构造器</a></p> 
<p id="%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1" rel="nofollow">自动拆装箱</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC" rel="nofollow">泛型集合取值</a></p> 
<p id="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0" rel="nofollow">可变参数</a></p> 
<p id="foreach%20%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#foreach%20%E5%BE%AA%E7%8E%AF" rel="nofollow">foreach 循环</a></p> 
<p id="switch%20%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:80px;"><a href="#switch%20%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">switch 字符串</a></p> 
<p id="switch%20%E6%9E%9A%E4%B8%BE-toc" style="margin-left:80px;"><a href="#switch%20%E6%9E%9A%E4%B8%BE" rel="nofollow">switch 枚举</a></p> 
<p id="%E6%9E%9A%E4%B8%BE%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB" rel="nofollow">枚举类</a></p> 
<p id="try-with-resources-toc" style="margin-left:80px;"><a href="#try-with-resources" rel="nofollow">try-with-resources</a></p> 
<p id="%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95" rel="nofollow">方法重写时的桥接方法</a></p> 
<p id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">匿名内部类</a></p> 
<p id="4.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5-toc" style="margin-left:40px;"><a href="#4.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5" rel="nofollow">4.类加载阶段</a></p> 
<p id="%E5%8A%A0%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E5%8A%A0%E8%BD%BD" rel="nofollow">加载</a></p> 
<p id="%E8%BF%9E%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%E8%BF%9E%E6%8E%A5" rel="nofollow">连接</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">初始化</a></p> 
<p id="%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%20-%20%E5%AE%8C%E6%88%90%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%20-%20%E5%AE%8C%E6%88%90%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" rel="nofollow">典型应用 - 完成懒惰初始化单例模式</a></p> 
<p id="5.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-toc" style="margin-left:40px;"><a href="#5.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" rel="nofollow">5.类加载器</a></p> 
<p id="%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F" rel="nofollow">双亲委派模式</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" rel="nofollow">自定义类加载器</a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%EF%BC%89" rel="nofollow">线程上下文类加载器（破坏双亲委派模式）</a></p> 
<p id="%C2%A06.%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#%C2%A06.%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96" rel="nofollow"> 6.运行期优化</a></p> 
<p id="%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91-toc" style="margin-left:80px;"><a href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91" rel="nofollow">即时编译</a></p> 
<p id="%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94" rel="nofollow">方法内联</a></p> 
<p id="%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96" rel="nofollow">反射优化</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">一、前言</h2> 
<h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AFJVM%3F">1.什么是JVM?</h3> 
<div> 
 <span style="color:#333333;">定义： Java Virtual Machine - java 程序的运行环境（</span> 
 <span style="color:#333333;">java </span> 
 <span style="color:#333333;">二进制字节码的运行环境）</span> 
</div> 
<div></div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;">好处： </span> 
 </div> 
 <ul><li><span style="color:#333333;">一次编写，到处运行 </span></li></ul> 
 <p>1.我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件</p> 
 <p>2.Java虚拟机JVM就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p> 
 <p>注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的,不同平台下需要安装不同版本的JVM</p> 
 <p>所以对成千上万的java开发者和java程序来讲,java是跨平台的</p> 
 <ul><li><span style="color:#333333;">自动内存管理，垃圾回收功能 </span></li><li><span style="color:#333333;">数组下标越界检查 </span></li><li><span style="color:#333333;">多态 </span></li></ul> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">比较： jvm jre jdk</span> 
 </div> 
 <div> 
  <img alt="" height="672" src="https://images2.imgbox.com/57/2f/pGlrEArH_o.png" width="1102"> 
 </div> 
 <p></p> 
 <h3 id="2.%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF">2.学习路线</h3> 
 <p><img alt="" height="703" src="https://images2.imgbox.com/f7/50/0fD63yok_o.png" width="1200"></p> 
 <h2 id="%C2%A0%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"> 二、内存结构</h2> 
 <h3 id="1.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span style="color:#38d8f0;">1.程序计数器</span></h3> 
 <p><strong>定义:</strong></p> 
 <p>   <span style="color:#333333;">Program Counter Register 程序计数器（寄存器）</span></p> 
 <p><span style="color:#333333;">  作用:  是记住下一条jvm</span><span style="color:#333333;">指令的执行地址 </span></p> 
 <p><span style="color:#333333;">  特点 </span></p> 
 <ul><li><span style="color:#333333;">是线程私有的 </span></li><li><span style="color:#333333;">不会存在内存溢出</span></li></ul> 
 <pre><code class="language-java">0: getstatic #20 // PrintStream out = System.out;
3: astore_1 // --
4: aload_1 // out.println(1);
5: iconst_1 // --
6: invokevirtual #26 // --
9: aload_1 // out.println(2);
10: iconst_2 // --
11: invokevirtual #26 // --
14: aload_1 // out.println(3);
15: iconst_3 // --
16: invokevirtual #26 // --
19: aload_1 // out.println(4);
20: iconst_4 // --
21: invokevirtual #26 // --
24: aload_1 // out.println(5);
25: iconst_5 // --
26: invokevirtual #26 // --
29: return</code></pre> 
 <p>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</p> 
 <p>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</p> 
 <h3 id="2.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span style="color:#38d8f0;">2.虚拟机栈</span></h3> 
 <p><strong>定义:</strong></p> 
 <p><span style="color:#333333;"> Java Virtual Machine Stacks （</span><span style="color:#333333;">Java </span><span style="color:#333333;">虚拟机栈） </span></p> 
 <ul><li>每个线程运行需要的内存空间，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法   </li></ul> 
 <p><strong>问题辨析：</strong></p> 
 <p>1.垃圾回收是否涉及栈内存？</p> 
 <p>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p> 
 <p><br> 2.栈内存分配越大越好吗？</p> 
 <p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p> 
 <p><br> 3.方法呢的局部变量是否线程安全</p> 
 <ul><li>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的</li><li>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</li></ul> 
 <p></p> 
 <p><strong>栈内存溢出</strong></p> 
 <p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError，使用 -Xss256k 指定栈内存大小！</p> 
 <p><strong>线程运行诊断</strong></p> 
 <p>案例1：cpu 占用过多（ps:死循环）<br> 解决方法：Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p> 
 <ul><li>top 命令，查看是哪个进程占用 CPU 过高</li><li>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高</li><li>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</li></ul> 
 <p><span style="color:#333333;">案例2</span><span style="color:#333333;">：程序运行很长时间没有结果(ps:死锁)</span></p> 
 <h3 id="3.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span style="color:#38d8f0;">3.本地方法栈</span></h3> 
 <p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p> 
 <h3 id="4.%E5%A0%86"><span style="color:#38d8f0;">4.堆</span></h3> 
 <p><strong>定义：</strong></p> 
 <p>Heap 堆</p> 
 <ul><li>通过new关键字创建的对象都会被放在堆内存</li></ul> 
 <p>特点</p> 
 <ul><li>它是线程共享，堆内存中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul> 
 <p><strong>堆内存溢出</strong></p> 
 <p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出<br> 可以使用 -Xmx8m 来指定堆内存大小。</p> 
 <p><strong>堆内存诊断</strong></p> 
 <ol><li>jps 工具<br> 查看当前系统中有哪些 java 进程</li><li>jmap 工具<br> 查看堆内存占用情况 jmap - heap 进程id</li><li>jconsole 工具<br> 图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 工具</li></ol> 
 <h3 id="5.%E6%96%B9%E6%B3%95%E5%8C%BA"><span style="color:#38d8f0;">5.方法区</span></h3> 
 <p><strong>定义:</strong></p> 
 <p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p> 
 <p>说到方法区的实现，对于JDK8之前的版本，我们都把他称为永久代，或者将两者混为一谈，其实两者并不是一个概念，使用永久代来实现方法区，可以像java堆一样去管理方法区的内存，而它会更容易导致内存溢出的问题（永久代有上限，参数：-XX：MaxPermSize，即使不设置也会有默认大小），JDK7将字符串常量池移到堆中，到了JDK8，就完全舍弃了永久代，改用元空间来实现。</p> 
 <p></p> 
 <p><strong>组成</strong></p> 
 <p>Hotspot 虚拟机 jdk1.6 1.8 内存结构图</p> 
 <p><img alt="" height="656" src="https://images2.imgbox.com/bc/3e/o8JVkZAN_o.png" width="726"></p> 
 <p><strong> 方法区内存溢出</strong></p> 
 <ul><li>1.8 之前会导致永久代内存溢出 
   <ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出 
   <ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul> 
 <p><strong>常量池</strong></p> 
 <blockquote> 
  <p>常量池,也叫 Class 常量池(常量池==Class常量池)。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区 各种字面量 (Literal)和 符号引用 。</p> 
 </blockquote> 
 <p>在Class文件结构中，最头的4个字节用于 存储魔数 (Magic Number)，用于确定一个文件是否能被JVM接受，再接着4个字节用于 存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念。如下</p> 
 <p><img alt="" height="605" src="https://images2.imgbox.com/0a/c5/67THBmMi_o.png" width="1176"><br><br>  </p> 
 <p></p> 
 <p><strong>运行时常量池</strong></p> 
 <p>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p> 
 <p></p> 
 <blockquote> 
  <p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</p> 
 </blockquote> 
 <div></div> 
 <div> 
  <p><strong>方法区的Class文件信息，Class常量池和运行时常量池的三者关系</strong></p> 
  <p><img alt="" height="342" src="https://images2.imgbox.com/94/4b/ti5iEMCE_o.png" width="538"></p> 
  <p></p> 
  <p><strong> 字符串常量池（StringTable）</strong></p> 
  <blockquote> 
   <p>字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool。 在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p> 
  </blockquote> 
 </div> 
 <p>常量池和字符串常量池的版本变化：</p> 
 <ul><li>在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</li><li>在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说 字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</li><li>在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</li></ul> 
 <p><span style="color:#fe2c24;"><strong>String.intern在JDK6和JDK7之后的区别(重点）</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>JDK6和JDK7中该方法的功能是大都一致，不同的是常量池位置的改变（JDK7将常量池放在了堆空间中），下面会具体说明。intern的方法返回字符串对象的规范表示形式。其中它做的事情是：首先去判断该字符串是否在常量池中存在，如果存在返回常量池中的字符串，如果在字符串常量池中不存在，先在字符串常量池中添加该字符串（jdk6）或引用（jdk7），然后返回引用地址</strong></span><br>  </p> 
 <pre><code class="language-java">String s1 = new String("1") + new String("1");
s1.intern();
String s2 = "11";
System.out.println(s1 == s2);

运行结果：
JDK6运行结果：false
JDK7运行结果：true
</code></pre> 
 <p></p> 
</div> 
<p>JDK6中，s1.intern()运行时，首先去常量池查找，发现没有该常量，则在常量池中开辟空间存储"11"，返回常量池中的值（注意这里也没有使用该返回值），第三行中，s2直接指向常量池里边的字符串，所以s1和s2不相等。有可能会有小伙伴问为啥s1.intern()发现没有该常量呢，那是因为：</p> 
<blockquote> 
 <p><br> String s1 = new String(“1”) + new String(“1”);这行代码实际操作是，创建了一个StringBuilder对象，然后一路append，最后toString，而toString其实是又重新new了一个String对象，然后把对象给s1，此时并没有在字符串常量池中添加常量<br>  </p> 
</blockquote> 
<p>JDK7中，由于字符串常量池在堆空间中，所以在s1.intern()运行时，发现字符串 常量池没有常量，则添加堆中“11”对象的引用到字符串常量池，这个引用返回堆空间“11”地址（注意这里也没有使用该返回值），这时s2通过查找字符串常量池中的常量，查到的是s1.intern()存在字符串常量池里的“11”对象的引用，既然都是指向堆上的“11”对象，所以s1和s2相等。</p> 
<p><strong>StringTable 性能调优</strong></p> 
<ul><li>因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</li></ul> 
<blockquote> 
 <p>-XX:StringTableSize=桶个数（最少设置为 1009 以上）</p> 
</blockquote> 
<ul><li>考虑是否需要将字符串对象入池<br> 可以通过 intern 方法减少重复入池</li></ul> 
<h3 id="6.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">6.直接内存</h3> 
<p><strong>定义:</strong></p> 
<p>Direct Memory</p> 
<ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul> 
<div> 
 <span style="color:#333333;"><strong>分配和回收原理 </strong></span> 
</div> 
<div> 
 <ul><li><span style="color:#333333;">使用了</span><span style="color:#333333;"> Unsafe </span><span style="color:#333333;">对象完成直接内存的分配回收，并且回收需要主动调用</span><span style="color:#333333;"> freeMemory </span><span style="color:#333333;">方法 </span></li><li><span style="color:#333333;">ByteBuffer </span><span style="color:#333333;">的实现类内部，使用了</span><span style="color:#333333;"> Cleaner </span><span style="color:#333333;">（虚引用）来监测</span><span style="color:#333333;"> ByteBuffer </span><span style="color:#333333;">对象，一旦</span><span style="color:#333333;">ByteBuffer </span><span style="color:#333333;">对象被垃圾回收，那么就会由</span><span style="color:#333333;"> ReferenceHandler </span><span style="color:#333333;">线程通过</span><span style="color:#333333;"> Cleaner </span><span style="color:#333333;">的</span><span style="color:#333333;"> clean </span><span style="color:#333333;">方法调 </span><span style="color:#333333;">用</span><span style="color:#333333;"> freeMemory </span><span style="color:#333333;">来释放直接内存</span></li></ul> 
 <h2 id="%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">三、垃圾回收</h2> 
 <h3 id="1.%E5%A6%82%E6%9E%9C%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6">1.如果判断对象可以回收</h3> 
 <p><strong>引用计数法</strong></p> 
 <p>当一个对象被引用时，就当引用对象的值加一，当值为 0 时，就表示该对象不被引用，可以被垃圾收集器回收。这个引用计数法听起来不错，但是有一个弊端，如下图所示，循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。</p> 
 <p><img alt="" height="335" src="https://images2.imgbox.com/b1/fc/npppM6aD_o.png" width="952"></p> 
 <p><strong> </strong></p> 
 <p><strong>可达性分析算法</strong></p> 
 <p>JVM 中的垃圾回收器通过可达性分析来探索所有存活的对象<br> 扫描堆中的对象，看能否沿着 GC Root 对象为起点的引用链找到该对象，如果找不到，则表示可以回收<br> 可以作为 GC Root 的对象</p> 
 <ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的Native方法）引用的对象</li></ul> 
 <p><strong>四种引用</strong></p> 
 <p>ps：众所周知四种引用里面有五种引用</p> 
 <p><strong>⑴强引用（StrongReference）</strong><br> 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  ps：强引用其实也就是我们平时A a = new A()这个意思</p> 
 <p><strong>⑵软引用（SoftReference）</strong><br> 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。<br> 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p> 
 <p><strong>⑶弱引用（WeakReference）</strong><br> 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br> 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p> 
 <p></p> 
 <p><strong>⑷虚引用（PhantomReference）</strong></p> 
 <p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br> 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p> 
 <p>ReferenceQueue queue = <strong>new</strong> ReferenceQueue ();</p> 
 <p>PhantomReference pr = <strong>new</strong> PhantomReference (object, queue); <br> 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p> 
 <p><strong>（5）终结器引用（FinalReference）</strong><br> 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</p> 
 <p><strong>使用软引用构建敏感数据的缓存</strong></p> 
 <p>1 为什么需要使用软引用<br>       首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。<br><br> 2 如果使用软引用<br>       SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。<br> 看下面代码:</p> 
 <p>MyObject aRef = <strong>new </strong>MyObject();</p> 
 <p>SoftReference aSoftRef = <strong>new</strong> SoftReference(aRef); </p> 
 <p><br> 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。<br> 随即，我们可以结束aReference对这个MyObject实例的强引用:</p> 
 <p>aRef = <strong>null</strong>;</p> 
 <p><br> 此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:<br> MyObject anotherRef=(MyObject)aSoftRef.get(); <br><br> 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。<br><br> 3 使用ReferenceQueue清除失去了软引用对象的SoftReference<br>        作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:</p> 
 <p>ReferenceQueue queue = <strong>new </strong>ReferenceQueue();</p> SoftReference ref =  
 <strong>new</strong> 
 <br> SoftReference(aMyObject, queue);  
 <br> 
 <br> 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。 
 <br> 在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为: 
 <p>SoftReference ref = <strong>null</strong>;</p> 
 <p><strong>while</strong> ((ref = (EmployeeRef) q.poll()) != <strong>null</strong>) {<!-- --></p> 
 <p>// 清除ref</p> 
 <p>}</p> 
 <h3 id="2.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">2.垃圾回收算法</h3> 
 <p><strong>标记清除算法</strong></p> 
 <ul><li>速度较快</li><li>会产生内存碎片</li></ul> 
 <p><img alt="" height="461" src="https://images2.imgbox.com/2f/c2/ChYAacfg_o.png" width="688"></p> 
 <p><strong>标记整理算法</strong></p> 
 <ul><li>速度慢</li><li>没有内存碎片</li></ul> 
 <p><img alt="" height="368" src="https://images2.imgbox.com/53/1d/voLbnRcf_o.png" width="680"></p> 
 <p><strong> 复制算法</strong></p> 
 <ul><li>不会有内存碎片</li><li>需要占用两倍内存空间</li></ul> 
 <p><img alt="" height="296" src="https://images2.imgbox.com/80/0f/y6JDOJVp_o.png" width="711"></p> 
 <p><span style="color:#333333;"><strong>分代垃圾回收</strong></span></p> 
 <p>根据内存对象的存活周期不同，将内存划分成几块，java虚拟机中一般将内存划分成新生代和老年代，当新建对象时一般在新生代中分配内存，在<span style="color:#fe2c24;">新生代垃圾收集器回收几次后仍然存活的对象</span>，将被移动到老年代，或者<span style="color:#fe2c24;">当大的对象在新生代中无法分配到足够连续的内存空间</span>时也会直接分配到老年代。 </p> 
 <p>jvm垃圾收集器的内存结构</p> 
 <p><img alt="" height="699" src="https://images2.imgbox.com/83/e0/8T04hRBO_o.png" width="805"></p> 
 <p>由图可知堆内存被分为新生代和老年代，整个堆内存采用分代垃圾回收算法。 </p> 
 <p>1.新生代</p> 
 <p>采用复制算法收集垃圾，在新生代中存在大量短生命周期的对象，所以不需要讲新生代容量等量化分，而是将新生代划分为Eden、survivor from、survivor to 三部分，其中新生代内存容量的默认比例如上图所示是8:1：1。survivor from和survivor to区域中总有一个是空白的，只有Eden和其中一个survior也就是总容量的90%会被用来为新对象分配内存。这样内存浪费就少了。当新生代的内存空间分配不足时，仍然存活的对象会被分配到空白的survior内存区域中。Eden和非空白的survivor会被标记回收，两个survivor交换使用。</p> 
 <p>jvm对新生代的垃圾回收称为Minor GC，次数频繁，每次回收时间也短。</p> 
 <p>-Xmn 设置新生代内存大小。</p> 
 <p>2.老年代</p> 
 <p>老年代存活率一般比较高，所以采用标记-整理算法进行垃圾收集效率会比较高。</p> 
 <p>jvm对老年代垃圾回收称为MajorGC/Full GC,次数相对比较少，每次回收的时间也比较长。</p> 
 <p>当新生代中无足够空间为对象分配内存，老年代内存也无法回收到足够的空间时，堆会产生OOM异常。<br>  </p> 
 <p><strong>相关 <a href="https://so.csdn.net/so/search?q=JVM&amp;spm=1001.2101.3001.7020" title="JVM">JVM</a> 参数</strong></p> 
 <table align="center" border="1" cellpadding="1" cellspacing="1"><thead><tr><th style="width:263px;">含义</th><th style="width:585px;">参数</th></tr></thead><tbody><tr><td style="width:263px;">堆初始大小</td><td style="width:585px;">-Xms</td></tr><tr><td style="width:263px;">堆最大大小</td><td style="width:585px;">-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td style="width:263px;">新生代大小</td><td style="width:585px;">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td style="width:263px;">幸存区比例（动态）</td><td style="width:585px;">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td style="width:263px;">幸存区比例</td><td style="width:585px;">-XX:SurvivorRatio=ratio</td></tr><tr><td style="width:263px;">晋升阈值</td><td style="width:585px;">-XX:MaxTenuringThreshold=threshold</td></tr><tr><td style="width:263px;">晋升详情</td><td style="width:585px;">-XX:MaxTenuringThreshold=threshold</td></tr><tr><td style="width:263px;">GC详情</td><td style="width:585px;">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td style="width:263px;">FullGC 前 MinorGC</td><td style="width:585px;">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table> 
 <h3 id="3.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">3.垃圾回收器</h3> 
 <p><img alt="" height="328" src="https://images2.imgbox.com/7d/35/y5nW3VAY_o.png" width="1200"></p> 
 <p></p> 
 <p>相关概念：</p> 
 <ul><li>并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li><li>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上</li><li>吞吐量：即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</li></ul> 
 <p>垃圾回收（GC）线程与应用线程保持相对独立，当系统需要执行垃圾回收任务时，先停止工作线程，然后命令 GC 线程工作。以串行模式工作的收集器，称为Serial Collector，即串行收集器；与之相对的是以并行模式工作的收集器，称为Paraller Collector，即并行收集器。<br>  </p> 
 <p><span style="color:#fe2c24;"><strong>串行</strong></span></p> 
 <ul><li>单线程</li><li>堆内存较少，适合个人电脑</li></ul> 
 <p><img alt="" height="332" src="https://images2.imgbox.com/50/1f/Jwlnqt6D_o.png" width="937"></p> 
 <p> <strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象，因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态。</p> 
 <p><strong>Serial 收集器</strong><br> 串行收集器采用单线程方式进行收集，且在 GC 线程工作时，系统不允许应用线程打扰。此时，应用程序进入暂停状态，即 Stop-the-world。Stop-the-world 暂停时间的长短，是衡量一款收集器性能高低的重要指标。Serial 是针对新生代的垃圾回收器，采用“复制”算法。</p> 
 <p><strong>Serial Old 收集器</strong></p> 
 <p>Serial Old 是 Serial 收集器的老年代版本，单线程收集器，采用“标记-整理”算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。</p> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>吞吐量优先</strong></span></p> 
 <ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>让单位时间内，STW 的时间最短</li></ul> 
 <p><img alt="" height="534" src="https://images2.imgbox.com/25/50/q5e1idlM_o.png" width="921"></p> 
 <p><strong>Parallel Scavenge 收集器</strong><br> Parallel Scavenge 是针对新生代的垃圾回收器，采用“复制”算法，和 ParNew 类似，但更注重吞吐率。在 ParNew 的基础上演化而来的 Parallel Scanvenge 收集器被誉为“吞吐量优先”收集器。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。如虚拟机总运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。</p> 
 <p>Parallel Scanvenge 收集器在 ParNew 的基础上提供了一组参数，用于配置期望的收集时间或吞吐量，然后以此为目标进行收集。通过 VM 选项可以控制吞吐量的大致范围：</p> 
 <p>-XX：MaxGCPauseMills：期望收集时间上限，用来控制收集对应用程序停顿的影响。<br> -XX：GCTimeRatio：期望的 GC 时间占总时间的比例，用来控制吞吐量。<br> -XX：UseAdaptiveSizePolicy：自动分代大小调节策略。<br> 但要注意停顿时间与吞吐量这两个目标是相悖的，降低停顿时间的同时也会引起吞吐的降低。因此需要将目标控制在一个合理的范围中。</p> 
 <p><strong>Parallel Old 收集器</strong></p> 
 <p>Parallel Old 是 Parallel Scanvenge 收集器的老年代版本，多线程收集器，采用“标记-整理”算法。</p> 
 <p><span style="color:#fe2c24;"><strong>响应时间优先</strong></span></p> 
 <ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>尽可能让 STW 的单次时间最短</li></ul> 
 <p><img alt="" height="427" src="https://images2.imgbox.com/c3/31/4dl6Bfal_o.png" width="920"></p> 
 <p></p> 
 <p><strong>ParNew 收集器</strong><br> 并行收集器充分利用了多处理器的优势，采用多个 GC 线程并行收集。可想而知，多条 GC 线程执行显然比只使用一条 GC 线程执行的效率更高。一般来说，与串行收集器相比，在多处理器环境下工作的并行收集器能够极大地缩短 Stop-the-world 时间。ParNew 是针对新生代的垃圾回收器，采用“复制”算法，可以看成是 Serial 的多线程版本<br>  </p> 
 <h5 id="CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span style="color:#fe2c24;"><strong>CMS收集器</strong></span></h5> 
 <p>在JDK 1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器:CMS (Concurrent-Mark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p> 
 <p>        CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p> 
 <p>        CMS的垃圾收集算法采用标记-清除算法，并且也会"Stop-the-world" <br>  </p> 
 <p>CMS工作流程 ：</p> 
 <p>CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发<br> 标记阶段、重新标记阶段和并发清除阶段。</p> 
 <ul><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li>并发标记(Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li>重新标记（Remark)阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>并发清除(Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul> 
 <p>尽管CNS收集器采用的是并发回收（非独占式)，但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-world”，只是尽可能地缩短暂停时间。</p> 
 <p>        因为最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p> 
 <p>        CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p> 
 <p>        既然Mark Sweep会造成内存碎片,那么为什么不把算法换成Mark Compact呢？答案其实很简答，因为当并发清除的时候，用compact整理内存的话，原来的用户线程使用的内存还怎么用呢?要保证用户线程能继续执行，前提的它运行的资源不受影响。Mark Compact更适合“stop the world”这种场景下使用。</p> 
 <p>CMS的优缺点 <br>  优点 </p> 
 <ul><li>并发收集</li><li>低延迟 </li></ul> 
 <p>弊端 <br> 1）会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</p> 
 <p>2）CMS收集器对CPU资源非常敏感。在开发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p> 
 <p>3)   CMS收集器无法处理浮动垃圾。可能出现 “Concurrent Mode Failure” 失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS经无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。 </p> 
 <h5 id="G1%EF%BC%88Garbage%20First%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span style="color:#fe2c24;">G1（Garbage First）收集器：区域化分代式</span></h5> 
 <p><span style="color:#fe2c24;">ps：同时注重响应时间和吞吐量</span></p> 
 <p>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First (G1)GC？原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间(pause time)，同时兼顾良好的吞吐量。</p> 
 <p>        G1(Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。它在JDK1.7版本正式被启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel old组合。被oracle官方称为“全功能的垃圾收集器”。与此同时，CMS已经在JDK 9中被标记为废弃(deprecated)。在jdk8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。</p> 
 <p>        G1 (Garbage-First）垃圾回收器是当今收集器技术发展的最前沿成果之一。官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。<br>  </p> 
 <p><strong> G1的工作原理</strong></p> 
 <p>G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region)（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。他跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p> 
 <p>        由于这种方式的侧重点在于回收垃圾最大量的区间（Region)，所以我们给他起一个名字：垃圾优先（Garbage First) 。</p> 
 <p>        G1中提供了三种垃圾回收模式: YoungGC、Mixed GC和Full GC，在不同的条件下被触发。<br>  </p> 
 <p>主要环节 ：<br> G1 GC的垃圾回收过程主要包括如下三个环节:</p> 
 <p>年轻代GC (Young GC)<br> 老年代并发标记过程(Concurrent Marking)<br> 混合回收(Mixed GC)<br> (如果需要，单线程、独占式、高强度的Full Gc还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</p> 
 <p><img alt="" height="487" src="https://images2.imgbox.com/d6/0c/YPbmdrgR_o.png" width="1200"></p> 
 <p></p> 
 <p><strong>Young GC</strong><br>         应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到survivor区间或者老年区间，也有可能是两个区间都会涉及。</p> 
 <p><strong> 老年代并发标记</strong><br>         当堆内存使用达到-XX:InitiatingHeapOccupancyPercent（默认45%）时，开始老年代并发标记过程。</p> 
 <p><strong>混合回收</strong><br>         标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了（在规定时间内挑选价值高的回收）。同时，这个老年代Region是和年轻代一起被回收的。</p> 
 <h3 id="4.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98">4.垃圾回收调优</h3> 
 <p>查看虚拟机参数命令</p> 
 <p>-XX:+PrintFlagsFinal -version | findstr "GC"</p> 
 <p>可以根据参数去查询具体的信息</p> 
 <p><strong>调优领域</strong></p> 
 <ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li><li>gc</li></ul> 
 <p><strong>确定目标</strong></p> 
 <p>低延迟/高吞吐量？ 选择合适的GC</p> 
 <ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul> 
 <p><strong>最快的 GC，就是没有GC</strong><br> 首先排除减少因为自身编写的代码而引发的内存问题</p> 
 <p>查看 Full GC 前后的内存占用，考虑以下几个问题<br> 数据是不是太多？</p> 
 <ul><li>resultSet = statement.executeQuery(“select * from 大表 limit n”)</li></ul> 
 <p>数据表示是否太臃肿</p> 
 <ul><li>对象图</li><li>对象大小 16 Integer 24 int 4</li></ul> 
 <p>是否存在内存泄漏</p> 
 <ul><li>static Map map …</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul> 
 <p><strong>新生代调优</strong><br> 新生代的特点</p> 
 <ul><li>所有的 new 操作分配内存都是非常廉价的  TLAB thread-lcoal allocation buffer</li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>Minor GC 所用时间远小于 Full GC</li></ul> 
 <p>新生代内存越大越好么？</p> 
 <p>不是<br> 新生代内存太小：频繁触发 Minor GC ，会 STW ，会使得吞吐量下降<br> 新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full GC。而且触发 Minor GC 时，清理新生代所花费的时间会更长<br> 新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜<br> 幸存区需要能够保存 当前活跃对象+需要晋升的对象</p> 
 <p>晋升阈值配置得当，让长时间存活的对象尽快晋升</p> 
 <p><strong>老年代调优</strong></p> 
 <p>以 CMS 为例：</p> 
 <ul><li>CMS 的老年代内存越大越好</li><li>先尝试不做调优，如果没有 Full GC 那么已经，否者先尝试调优新生代。</li><li>观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</li></ul> 
 <p><strong>案例</strong></p> 
 <p>案例1：Full GC 和 Minor GC 频繁<br> 案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）<br> 案例3：老年代充裕情况下，发生 Full GC（jdk1.7）</p> 
 <h2 id="%E5%9B%9B%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF" style="background-color:transparent;">四、类加载与字节码技术</h2> 
 <p><img alt="" height="615" src="https://images2.imgbox.com/96/af/CrALhjXl_o.png" width="1200"></p> 
 <h3 id="%C2%A01.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><strong> 1.类文件结构</strong></h3> 
 <p>根据 JVM 规范，类文件结构如下：</p> 
 <pre><code>u4 			   magic
u2             minor_version;    
u2             major_version;    
u2             constant_pool_count;    
cp_info        constant_pool[constant_pool_count-1];    
u2             access_flags;    
u2             this_class;    
u2             super_class;   
u2             interfaces_count;    
u2             interfaces[interfaces_count];   
u2             fields_count;    
field_info     fields[fields_count];   
u2             methods_count;    
method_info    methods[methods_count];    
u2             attributes_count;    
attribute_info attributes[attributes_count];
</code></pre> 
 <h3 id="2.%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span style="color:#333333;">2.</span><span style="color:#333333;">字节码指令 </span></h3> 
 <h5 id="%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">图解方法执行流程</h5> 
 <p>代码：</p> 
 <pre><code class="language-java">package cn.itcast.jvm.t3.bytecode;
/**
* 演示 字节码指令 和 操作数栈、常量池的关系
*/
public class Demo3_1 {
public static void main(String[] args) {
int a = 10;
int b = Short.MAX_VALUE + 1;
int c = a + b;
System.out.println(c);
}
}</code></pre> 
 <p><strong>常量池载入运行时常量池</strong><br> 常量池也属于方法区，只不过这里单独提出来了</p> 
 <p><img alt="" height="526" src="https://images2.imgbox.com/fd/49/7dESXlFw_o.png" width="1200"></p> 
 <p><strong>方法字节码载入方法</strong></p> 
 <p><img alt="" height="524" src="https://images2.imgbox.com/61/b6/rs8lGrOx_o.png" width="1200"></p> 
 <div> 
  <span style="color:#333333;"><strong>main </strong></span> 
  <span style="color:#333333;"><strong>线程开始运行，分配栈帧内存 </strong></span> 
 </div> 
 <div>
   （stack=2，locals=4） 对应操作数栈有 2 个空间（每个空间 4 个字节），局部变量表中有4个槽位。   
 </div> 
 <div> 
  <img alt="" height="528" src="https://images2.imgbox.com/24/4f/8G4mbG7D_o.png" width="1200"> 
 </div> 
 <p></p> 
 <p>执行引擎开始执行字节码<br> bipush 10</p> 
 <p>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有</p> 
 <ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li></ul> 
 <p><img alt="" height="532" src="https://images2.imgbox.com/83/8f/Y3ioG8lZ_o.png" width="1200"></p> 
 <p><strong>istore 1</strong><br> 将操作数栈栈顶元素弹出，放入局部变量表的 slot 1 中<br> 对应代码中的 a = 10 </p> 
 <p><img alt="" height="534" src="https://images2.imgbox.com/ad/5e/ZwpYF5Kx_o.png" width="1200"></p> 
 <p>ldc #3<br> 读取运行时常量池中 #3 ，即 32768 (超过 short 最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的。</p> 
 <p><img alt="" height="533" src="https://images2.imgbox.com/d9/eb/bupi9AVd_o.png" width="1200"></p> 
 <p><strong>istore 2</strong><br> 将操作数栈中的元素弹出，放到局部变量表的 2 号位置 </p> 
 <p><img alt="" height="532" src="https://images2.imgbox.com/1b/fe/6ltMOKgZ_o.png" width="1200"></p> 
 <p> <strong>iload1 iload2</strong><br> 将局部变量表中 1 号位置和 2 号位置的元素放入操作数栈中。因为只能在操作数栈中执行运算操作</p> 
 <p><img alt="" height="545" src="https://images2.imgbox.com/0b/b8/MiaDhJKS_o.png" width="1200"></p> 
 <p></p> 
 <p> <strong>iadd</strong><br> 将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中。</p> 
 <p><img alt="" height="526" src="https://images2.imgbox.com/c1/40/Ogqjwq4M_o.png" width="1200"></p> 
 <p> <strong>istore 3</strong><br> 将操作数栈中的元素弹出，放入局部变量表的3号位置。</p> 
 <p><img alt="" height="543" src="https://images2.imgbox.com/6f/4d/mnEj0caw_o.png" width="1200"></p> 
 <p><strong>getstatic #4</strong><br> 在运行时常量池中找到 #4 ，发现是一个对象，在堆内存中找到该对象，并将其引用放入操作数栈中</p> 
 <p><img alt="" height="546" src="https://images2.imgbox.com/f6/55/cE3TXXUa_o.png" width="1200"></p> 
 <p><strong>iload 3</strong><br> 将局部变量表中 3 号位置的元素压入操作数栈中。</p> 
 <p><img alt="" height="530" src="https://images2.imgbox.com/d8/fa/Uf3EKbLG_o.png" width="1200"></p> 
 <div> 
  <span style="color:#333333;"><strong>invokevirtual #5 </strong></span> 
 </div> 
 <ul><li><span style="color:#333333;">找到常量池</span><span style="color:#333333;"> #5 </span><span style="color:#333333;">项 </span></li><li><span style="color:#333333;">定位到方法区 </span><span style="color:#333333;">java/io/PrintStream.println:(I)V </span><span style="color:#333333;">方法 </span></li><li><span style="color:#333333;">生成新的栈帧（分配</span><span style="color:#333333;"> locals</span><span style="color:#333333;">、</span><span style="color:#333333;">stack</span><span style="color:#333333;">等） </span></li><li><span style="color:#333333;">传递参数，执行新栈帧中的字节码</span></li></ul> 
 <p> <img alt="" height="618" src="https://images2.imgbox.com/55/24/4c4FLyDr_o.png" width="1200"></p> 
 <p>执行完毕，弹出栈帧<br> 清除 main 操作数栈内容</p> 
 <p><img alt="" height="534" src="https://images2.imgbox.com/25/4c/Q7vQUjMG_o.png" width="1200"></p> 
 <p> <strong>return</strong><br> 完成 main 方法调用，弹出 main 栈帧，程序结束</p> 
 <h4 id="%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98">通过字节码指令分析问题</h4> 
 <p>代码：</p> 
 <pre><code class="language-java">public class Code_11_ByteCodeTest {
    public static void main(String[] args) {

        int i = 0;
        int x = 0;
        while (i &lt; 10) {
            x = x++;
            i++;
        }
        System.out.println(x); // 0
    }
}

</code></pre> 
 <p>为什么最终的 x 结果为 0 呢？ 通过分析字节码指令即可知晓</p> 
 <pre><code class="language-TypeScript">Code:
     stack=2, locals=3, args_size=1	// 操作数栈分配2个空间，局部变量表分配 3 个空间
        0: iconst_0	// 准备一个常数 0
        1: istore_1	// 将常数 0 放入局部变量表的 1 号槽位 i = 0
        2: iconst_0	// 准备一个常数 0
        3: istore_2	// 将常数 0 放入局部变量的 2 号槽位 x = 0	
        4: iload_1		// 将局部变量表 1 号槽位的数放入操作数栈中
        5: bipush        10	// 将数字 10 放入操作数栈中，此时操作数栈中有 2 个数
        7: if_icmpge     21	// 比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到 21 。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空
       10: iload_2		// 将局部变量 2 号槽位的数放入操作数栈中，放入的值是 0 
       11: iinc          2, 1	// 将局部变量 2 号槽位的数加 1 ，自增后，槽位中的值为 1 
       14: istore_2	//将操作数栈中的数放入到局部变量表的 2 号槽位，2 号槽位的值又变为了0
       15: iinc          1, 1 // 1 号槽位的值自增 1 
       18: goto          4 // 跳转到第4条指令
       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       24: iload_2
       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
       28: return
</code></pre> 
 <h4 id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</h4> 
 <p><strong>cinit()V</strong></p> 
 <pre><code class="language-java">public class Code_12_CinitTest {
	static int i = 10;

	static {
		i = 20;
	}

	static {
		i = 30;
	}

	public static void main(String[] args) {
		System.out.println(i); // 30
	}
}
</code></pre> 
 <div> 
  <span style="color:#333333;">编译器会按从上至下的顺序，收集所有</span> 
  <span style="color:#333333;"> static </span> 
  <span style="color:#333333;">静态代码块和静态成员赋值的代码，合并为一个特殊的方 法 &lt;cinit&gt;()V </span> 
  <span style="color:#333333;">： </span> 
 </div> 
 <div> 
  <pre><code class="language-TypeScript">0: bipush 10
2: putstatic #2 // Field i:I
5: bipush 20
7: putstatic #2 // Field i:I
10: bipush 30
12: putstatic #2 // Field i:I
15: return</code></pre> 
  <div> 
   <span style="color:#333333;">&lt;cinit&gt;()V</span> 
   <span style="color:#333333;">方法会在类加载的初始化阶段被调用 </span> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#333333;">&lt;init&gt;()V </span></strong> 
  </div> 
  <div> 
   <pre><code class="language-java">public class Code_13_InitTest {
    private String a = "s1";
    {
        b = 20;
    }
    private int b = 10;
    {
        a = "s2";
    }
    public Code_13_InitTest(String a, int b) {
        this.a = a;
        this.b = b;
    }
    public static void main(String[] args) {
        Code_13_InitTest d = new Code_13_InitTest("s3", 30);
        System.out.println(d.a);
        System.out.println(d.b);
    }
}

</code></pre> 
   <div> 
    <span style="color:#333333;">编译器会按从上至下的顺序，收集所有</span> 
    <span style="color:#333333;"> {} </span> 
    <span style="color:#333333;">代码块和成员变量赋值的代码，形成新的构造方法，但原始构 造方法内的代码总是在最后 </span> 
   </div> 
   <div> 
    <pre><code class="language-TypeScript">Code:
     stack=2, locals=3, args_size=3
        0: aload_0
        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
        4: aload_0
        5: ldc           #2                  // String s1
        7: putfield      #3                  // Field a:Ljava/lang/String;
       10: aload_0
       11: bipush        20
       13: putfield      #4                  // Field b:I
       16: aload_0
       17: bipush        10
       19: putfield      #4                  // Field b:I
       22: aload_0
       23: ldc           #5                  // String s2
       25: putfield      #3                  // Field a:Ljava/lang/String;
       // 原始构造方法在最后执行
       28: aload_0
       29: aload_1
       30: putfield      #3                  // Field a:Ljava/lang/String;
       33: aload_0
       34: iload_2
       35: putfield      #4                  // Field b:I
       38: return
</code></pre> 
    <h4 id="%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</h4> 
    <div> 
     <span style="color:#333333;">看一下几种不同的方法调用对应的字节码指令</span> 
    </div> 
    <div> 
     <pre><code class="language-java">public class Code_14_MethodTest {
    public Code_14_MethodTest() {

    }
    private void test1() {

    }
    private final void test2() {

    }
    public void test3() {

    }
    public static void test4() {

    }
    public static void main(String[] args) {
        Code_14_MethodTest obj = new Code_14_MethodTest();
        obj.test1();
        obj.test2();
        obj.test3();
        Code_14_MethodTest.test4();
    }
}

</code></pre> 
     <p>不同方法在调用时，对应的虚拟机指令有所区别</p> 
     <ul><li>私有、构造、被 final 修饰的方法，在调用时都使用 invokespecial 指令</li><li>普通成员方法在调用时，使用 invokevirtual 指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用 invokestatic 指令 </li></ul> 
     <pre><code class="language-TypeScript">Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  //
         3: dup // 复制一份对象地址压入操作数栈中
         4: invokespecial #3                  // Method "&lt;init&gt;":()V
         7: astore_1
         8: aload_1
         9: invokespecial #4                  // Method test1:()V
        12: aload_1
        13: invokespecial #5                  // Method test2:()V
        16: aload_1
        17: invokevirtual #6                  // Method test3:()V
        20: invokestatic  #7                  // Method test4:()V
        23: return
</code></pre> 
     <ul><li><span style="color:#333333;">new </span><span style="color:#333333;">是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈 </span></li><li><span style="color:#333333;">dup </span><span style="color:#333333;">是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配</span><span style="color:#333333;">合</span><span style="color:#333333;"> invokespecial </span><span style="color:#333333;">调用该对象的构造方法 </span><span style="color:#333333;">"&lt;init&gt;":()V </span><span style="color:#333333;">（会消耗掉栈顶一个引用），另一个要 </span><span style="color:#333333;">配合</span><span style="color:#333333;"> astore_1 </span><span style="color:#333333;">赋值给局部变量 </span></li><li><span style="color:#333333;">最终方法（</span><span style="color:#333333;">final</span><span style="color:#333333;">），私有方法（</span><span style="color:#333333;">private</span><span style="color:#333333;">），构造方法都是由</span><span style="color:#333333;"> invokespecial </span><span style="color:#333333;">指令来调用，属于静</span><span style="color:#333333;">态绑定 </span></li><li><span style="color:#333333;">普通成员方法是由</span><span style="color:#333333;"> invokevirtual </span><span style="color:#333333;">调用，属于动态绑定，即支持多态 </span></li><li><span style="color:#333333;">成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 </span></li><li><span style="color:#333333;">比较有意思的是 </span><span style="color:#333333;">d.test4()</span><span style="color:#333333;">; </span><span style="color:#333333;">是通过【对象引用】调用一个静态方法，可以看到在调用 </span></li><li><span style="color:#333333;">invokestatic </span><span style="color:#333333;">之前执行了</span><span style="color:#333333;"> pop </span><span style="color:#333333;">指令，把【对象引用】从操作数栈弹掉了</span><span style="color:#333333;">😂 </span></li><li><span style="color:#333333;">还有一个执行</span><span style="color:#333333;"> invokespecial </span><span style="color:#333333;">的情况是通过</span><span style="color:#333333;"> super </span><span style="color:#333333;">调用父类方法 </span></li></ul> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h4 id="%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86">多态原理</h4> 
   <p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用 invokevirtual 指令<br> 在执行 invokevirtual 指令时，经历了以下几个步骤</p> 
   <ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的 Class</li><li>Class 结构中有 vtable</li><li>查询 vtable 找到方法的具体地址</li><li>执行方法的字节码</li></ul> 
   <h4 id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</h4> 
   <p><strong>try-catch-finally</strong></p> 
   <pre><code class="language-java">public class Code_17_FinallyTest {
    
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (Exception e) {
            i = 20;
        } finally {
            i = 30;
        }
    }
}

</code></pre> 
   <pre><code class="language-TypeScript">Code:
     stack=1, locals=4, args_size=1
        0: iconst_0
        1: istore_1
        // try块
        2: bipush        10
        4: istore_1
        // try块执行完后，会执行finally    
        5: bipush        30
        7: istore_1
        8: goto          27
       // catch块     
       11: astore_2 // 异常信息放入局部变量表的2号槽位
       12: bipush        20
       14: istore_1
       // catch块执行完后，会执行finally        
       15: bipush        30
       17: istore_1
       18: goto          27
       // 出现异常，但未被 Exception 捕获，会抛出其他异常，这时也需要执行 finally 块中的代码   
       21: astore_3
       22: bipush        30
       24: istore_1
       25: aload_3
       26: athrow  // 抛出异常
       27: return
     Exception table:
        from    to  target type
            2     5    11   Class java/lang/Exception
            2     5    21   any
           11    15    21   any
</code></pre> 
   <ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>可以看到 ﬁnally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程<br> 注意：虽然从字节码指令看来，每个块中都有 finally 块，但是 finally 块中的代码只会被执行一次</li></ul> 
   <p><strong>finally 中的 return</strong></p> 
   <pre><code class="language-java">public class Code_17_FinallyTest {
    
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (Exception e) {
            i = 20;
        } finally {
            i = 30;
        }
    }
}

</code></pre> 
   <p>对应的字节码</p> 
   <pre><code class="language-TypeScript">Code:
     stack=1, locals=3, args_size=0
        0: bipush        10
        2: istore_0
        3: iload_0
        4: istore_1  // 暂存返回值
        5: bipush        20
        7: istore_0
        8: iload_0
        9: ireturn	// ireturn 会返回操作数栈顶的整型值 20
       // 如果出现异常，还是会执行finally 块中的内容，没有抛出异常
       10: astore_2
       11: bipush        20
       13: istore_0
       14: iload_0
       15: ireturn	// 这里没有 athrow 了，也就是如果在 finally 块中如果有返回操作的话，且 try 块中出现异常，会吞掉异常！
     Exception table:
        from    to  target type
            0     5    10   any
</code></pre> 
   <ul><li>由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现没有 athrow 了，这告诉我们：如果在 ﬁnally 中出现了 return，会吞掉异常</li><li>所以不要在finally中进行返回操作</li></ul> 
   <p><strong>finally 不带 return</strong></p> 
   <pre><code class="language-java">public static int test() {
		int i = 10;
		try {
			return i;
		} finally {
			i = 20;
		}
	}
</code></pre> 
   <pre><code class="language-TypeScript">Code:
     stack=1, locals=3, args_size=0
        0: bipush        10
        2: istore_0 // 赋值给i 10
        3: iload_0	// 加载到操作数栈顶
        4: istore_1 // 加载到局部变量表的1号位置
        5: bipush        20
        7: istore_0 // 赋值给i 20
        8: iload_1 // 加载局部变量表1号位置的数10到操作数栈
        9: ireturn // 返回操作数栈顶元素 10
       10: astore_2
       11: bipush        20
       13: istore_0
       14: aload_2 // 加载异常
       15: athrow // 抛出异常
     Exception table:
        from    to  target type
            3     5    10   any
</code></pre> 
   <h4 id="Synchronized">Synchronized</h4> 
   <pre><code class="language-java">public class Code_19_SyncTest {

    public static void main(String[] args) {
        Object lock = new Object();
        synchronized (lock) {
            System.out.println("ok");
        }
    }

}

</code></pre> 
   <pre><code class="language-TypeScript">Code:
      stack=2, locals=4, args_size=1
         0: new           #2                  // class java/lang/Object
         3: dup // 复制一份栈顶，然后压入栈中。用于函数消耗
         4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
         7: astore_1 // 将栈顶的对象地址方法 局部变量表中 1 中
         8: aload_1 // 加载到操作数栈
         9: dup // 复制一份，放到操作数栈，用于加锁时消耗
        10: astore_2 // 将操作数栈顶元素弹出，暂存到局部变量表的 2 号槽位。这时操作数栈中有一份对象的引用
        11: monitorenter // 加锁
        12: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        15: ldc           #4                  // String ok
        17: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        20: aload_2 // 加载对象到栈顶
        21: monitorexit // 释放锁
        22: goto          30
        // 异常情况的解决方案 释放锁！
        25: astore_3
        26: aload_2
        27: monitorexit
        28: aload_3
        29: athrow
        30: return
        // 异常表！
      Exception table:
         from    to  target type
            12    22    25   any
            25    28    25   any

</code></pre> 
   <h3 id="3.%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86">3.编译期处理</h3> 
   <p>所谓的 语法糖 ，其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利<br> 注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p> 
   <h4 id="%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><strong>默认构造器</strong></h4> 
   <pre><code class="language-java">public class Candy1 {

}
</code></pre> 
   <p>经过编译期优化后</p> 
   <pre><code class="language-java">public class Candy1 {
   // 这个无参构造器是java编译器帮我们加上的
   public Candy1() {
      // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init&gt;":()V
      super();
   }
}
</code></pre> 
   <h4 id="%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1">自动拆装箱</h4> 
   <p>基本类型和其包装类型的相互转换过程，称为拆装箱<br> 在 JDK 5 以后，它们的转换可以在编译期自动完成</p> 
   <pre><code class="language-java">public class Candy2 {
   public static void main(String[] args) {
      Integer x = 1;
      int y = x;
   }
}
</code></pre> 
   <p>转换过程如下</p> 
   <pre><code class="language-java">public class Candy2 {
   public static void main(String[] args) {
      // 基本类型赋值给包装类型，称为装箱
      Integer x = Integer.valueOf(1);
      // 包装类型赋值给基本类型，称谓拆箱
      int y = x.intValue();
   }
}
</code></pre> 
   <h4 id="%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC">泛型集合取值</h4> 
   <p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：</p> 
   <pre><code class="language-java">public class Candy3 {
   public static void main(String[] args) {
      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
      list.add(10);
      Integer x = list.get(0);
   }
}
</code></pre> 
   <p>对应字节码</p> 
   <pre><code class="language-TypeScript">Code:
    stack=2, locals=3, args_size=1
       0: new           #2                  // class java/util/ArrayList
       3: dup
       4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V
       7: astore_1
       8: aload_1
       9: bipush        10
      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      // 这里进行了泛型擦除，实际调用的是add(Objcet o)
      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z

      19: pop
      20: aload_1
      21: iconst_0
      // 这里也进行了泛型擦除，实际调用的是get(Object o)   
      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
// 这里进行了类型转换，将 Object 转换成了 Integer
      27: checkcast     #7                  // class java/lang/Integer
      30: astore_2
      31: return
</code></pre> 
   <p>所以调用 get 函数取值时，有一个类型转换的操作。</p> 
   <pre><code class="language-java">Integer x = (Integer) list.get(0);
</code></pre> 
   <p>如果要将返回结果赋值给一个 int 类型的变量，则还有自动拆箱的操作</p> 
   <pre><code class="language-java">int x = (Integer) list.get(0).intValue();
</code></pre> 
   <p>使用反射可以得到，参数的类型以及泛型类型。泛型反射代码如下：</p> 
   <pre><code class="language-java">
    public static void main(String[] args) throws NoSuchMethodException {
        // 1. 拿到方法
        Method method = Code_20_ReflectTest.class.getMethod("test", List.class, Map.class);
        // 2. 得到泛型参数的类型信息
        Type[] types = method.getGenericParameterTypes();
        for(Type type : types) {
            // 3. 判断参数类型是否，带泛型的类型。
            if(type instanceof ParameterizedType) {
                ParameterizedType parameterizedType = (ParameterizedType) type;

                // 4. 得到原始类型
                System.out.println("原始类型 - " + parameterizedType.getRawType());
                // 5. 拿到泛型类型
                Type[] arguments = parameterizedType.getActualTypeArguments();
                for(int i = 0; i &lt; arguments.length; i++) {
                    System.out.printf("泛型参数[%d] - %s\n", i, arguments[i]);
                }
            }
        }
    }

    public Set&lt;Integer&gt; test(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map) {
        return null;
    }
</code></pre> 
   <p>输出：</p> 
   <pre><code class="language-TypeScript">原始类型 - interface java.util.List
泛型参数[0] - class java.lang.String
原始类型 - interface java.util.Map
泛型参数[0] - class java.lang.Integer
泛型参数[1] - class java.lang.Object
</code></pre> 
   <h4 id="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</h4> 
   <p>可变参数也是 JDK 5 开始加入的新特性： 例如：</p> 
   <pre><code class="language-java">public class Candy4 {
   public static void foo(String... args) {
      // 将 args 赋值给 arr ，可以看出 String... 实际就是 String[]  
      String[] arr = args;
      System.out.println(arr.length);
   }

   public static void main(String[] args) {
      foo("hello", "world");
   }
}
</code></pre> 
   <p>可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p> 
   <pre><code class="language-java">public class Candy4 {
public static void foo(String[] args) {
String[] array = args; // 直接赋值
System.out.println(array);
}
public static void main(String[] args) {
foo(new String[]{"hello", "world"});
}
}</code></pre> 
   <p>注意，如果调用的是 foo() ，即未传递参数时，等价代码为 foo(new String[]{}) ，创建了一个空数组，而不是直接传递的 null </p> 
   <h4 id="foreach%20%E5%BE%AA%E7%8E%AF">foreach 循环</h4> 
   <p>仍是 JDK 5 开始引入的语法糖，数组的循环：</p> 
   <pre><code class="language-java">public class Candy5 {
	public static void main(String[] args) {
        // 数组赋初值的简化写法也是一种语法糖。
		int[] arr = {1, 2, 3, 4, 5};
		for(int x : arr) {
			System.out.println(x);
		}
	}
}
</code></pre> 
   <p>编译器会帮我们转换为</p> 
   <pre><code class="language-java">public class Candy5 {
    public Candy5() {}

	public static void main(String[] args) {
		int[] arr = new int[]{1, 2, 3, 4, 5};
		for(int i = 0; i &lt; arr.length; ++i) {
			int x = arr[i];
			System.out.println(x);
		}
	}
}
</code></pre> 
   <p>如果是集合使用 foreach</p> 
   <pre><code class="language-java">public class Candy5 {
   public static void main(String[] args) {
      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
      for (Integer x : list) {
         System.out.println(x);
      }
   }

</code></pre> 
   <p>集合要使用 foreach ，需要该集合类实现了 Iterable 接口，因为集合的遍历需要用到迭代器 Iterator.</p> 
   <pre><code class="language-java">public class Candy5 {
    public Candy5(){}
    
   public static void main(String[] args) {
      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
      // 获得该集合的迭代器
      Iterator&lt;Integer&gt; iterator = list.iterator();
      while(iterator.hasNext()) {
         Integer x = iterator.next();
         System.out.println(x);
      }
   }
}
</code></pre> 
   <h4 id="switch%20%E5%AD%97%E7%AC%A6%E4%B8%B2">switch 字符串</h4> 
   <p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p> 
   <pre><code class="language-java">public class Cnady6 {
   public static void main(String[] args) {
      String str = "hello";
      switch (str) {
         case "hello" :
            System.out.println("h");
            break;
         case "world" :
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
</code></pre> 
   <p>在编译器中执行的操作</p> 
   <pre><code class="language-java">public class Candy6 {
   public Candy6() {
      
   }
   public static void main(String[] args) {
      String str = "hello";
      int x = -1;
      // 通过字符串的 hashCode + value 来判断是否匹配
      switch (str.hashCode()) {
         // hello 的 hashCode
         case 99162322 :
            // 再次比较，因为字符串的 hashCode 有可能相等
            if(str.equals("hello")) {
               x = 0;
            }
            break;
         // world 的 hashCode
         case 11331880 :
            if(str.equals("world")) {
               x = 1;
            }
            break;
         default:
            break;
      }

      // 用第二个 switch 在进行输出判断
      switch (x) {
         case 0:
            System.out.println("h");
            break;
         case 1:
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
</code></pre> 
   <p>过程说明：</p> 
   <p>在编译期间，单个的 switch 被分为了两个<br>   第一个用来匹配字符串，并给 x 赋值</p> 
   <ul><li>字符串的匹配用到了字符串的 hashCode ，还用到了 equals 方法</li><li>使用 hashCode 是为了提高比较效率，使用 equals 是防止有 hashCode 冲突（如 BM 和 C .）</li></ul> 
   <p>第二个用来根据x的值来决定输出语句</p> 
   <h4 id="switch%20%E6%9E%9A%E4%B8%BE">switch 枚举</h4> 
   <pre><code class="language-java">enum SEX {
   MALE, FEMALE;
}
public class Candy7 {
   public static void main(String[] args) {
      SEX sex = SEX.MALE;
      switch (sex) {
         case MALE:
            System.out.println("man");
            break;
         case FEMALE:
            System.out.println("woman");
            break;
         default:
            break;
      }
   }
}
</code></pre> 
   <p>编译器中执行的代码如下</p> 
   <pre><code class="language-java">enum SEX {
   MALE, FEMALE;
}

public class Candy7 {
   /**     
    * 定义一个合成类（仅 jvm 使用，对我们不可见）     
    * 用来映射枚举的 ordinal 与数组元素的关系     
    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     
    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     
    */ 
   static class $MAP {
      // 数组大小即为枚举元素个数，里面存放了 case 用于比较的数字
      static int[] map = new int[2];
      static {
         // ordinal 即枚举元素对应所在的位置，MALE 为 0 ，FEMALE 为 1
         map[SEX.MALE.ordinal()] = 1;
         map[SEX.FEMALE.ordinal()] = 2;
      }
   }

   public static void main(String[] args) {
      SEX sex = SEX.MALE;
      // 将对应位置枚举元素的值赋给 x ，用于 case 操作
      int x = $MAP.map[sex.ordinal()];
      switch (x) {
         case 1:
            System.out.println("man");
            break;
         case 2:
            System.out.println("woman");
            break;
         default:
            break;
      }
   }
}
</code></pre> 
   <h4 id="%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举类</h4> 
   <p>JDK 7 新增了枚举类，以前面的性别枚举为例：</p> 
   <pre><code class="language-java">enum SEX {
   MALE, FEMALE;
}
</code></pre> 
   <p>转换后的代码</p> 
   <pre><code class="language-java">public final class Sex extends Enum&lt;Sex&gt; {   
   // 对应枚举类中的元素
   public static final Sex MALE;    
   public static final Sex FEMALE;    
   private static final Sex[] $VALUES;
   
    static {       
    	// 调用构造函数，传入枚举元素的值及 ordinal
    	MALE = new Sex("MALE", 0);    
        FEMALE = new Sex("FEMALE", 1);   
        $VALUES = new Sex[]{MALE, FEMALE}; 
   }
 	
   // 调用父类中的方法
    private Sex(String name, int ordinal) {     
        super(name, ordinal);    
    }
   
    public static Sex[] values() {  
        return $VALUES.clone();  
    }
    public static Sex valueOf(String name) { 
        return Enum.valueOf(Sex.class, name);  
    } 
   
}
</code></pre> 
   <h4 id="try-with-resources">try-with-resources</h4> 
   <p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法，‘try-with-resources’</p> 
   <pre><code class="language-java">try(资源变量 = 创建资源对象) {
	
} catch() {

}
</code></pre> 
   <p>其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-with- resources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：<br>  </p> 
   <pre><code class="language-java">public class Candy9 { 
	public static void main(String[] args) {
		try(InputStream is = new FileInputStream("d:\\1.txt")){	
			System.out.println(is); 
		} catch (IOException e) { 
			e.printStackTrace(); 
		} 
	} 
}
</code></pre> 
   <p>会被转换为：</p> 
   <pre><code class="language-java">public class Candy9 { 
    
    public Candy9() { }
   
    public static void main(String[] args) { 
        try {
            InputStream is = new FileInputStream("d:\\1.txt");
            Throwable t = null; 
            try {
                System.out.println(is); 
            } catch (Throwable e1) { 
                // t 是我们代码出现的异常 
                t = e1; 
                throw e1; 
            } finally {
                // 判断了资源不为空 
                if (is != null) { 
                    // 如果我们代码有异常
                    if (t != null) { 
                        try {
                            is.close(); 
                        } catch (Throwable e2) { 
                            // 如果 close 出现异常，作为被压制异常添加
                            t.addSuppressed(e2); 
                        } 
                    } else { 
                        // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e 
                        is.close(); 
                    } 
                } 
            } 
        } catch (IOException e) {
            e.printStackTrace(); 
        } 
    }
}
</code></pre> 
   <p>为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）</p> 
   <h4 id="%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95">方法重写时的桥接方法</h4> 
   <p>我们都知道，方法重写时对返回值分两种情况：<br> - 父子类的返回值完全一致<br> - 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）</p> 
   <pre><code class="language-java">class A { 
	public Number m() { 
		return 1; 
	} 
}
class B extends A { 
	@Override 
	// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 	
	public Integer m() { 
		return 2; 
	} 
}
</code></pre> 
   <p>对于子类，java 编译器会做如下处理：</p> 
   <pre><code class="language-java">class B extends A { 
	public Integer m() { 
		return 2; 
	}
	// 此方法才是真正重写了父类 public Number m() 方法 
	public synthetic bridge Number m() { 
		// 调用 public Integer m() 
		return m(); 
	} 
}
</code></pre> 
   <p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证：</p> 
   <pre><code class="language-java">public static void main(String[] args) {
        for(Method m : B.class.getDeclaredMethods()) {
            System.out.println(m);
        }
    }
</code></pre> 
   <p>结果：</p> 
   <pre><code class="language-java">public java.lang.Integer cn.ali.jvm.test.B.m()
public java.lang.Number cn.ali.jvm.test.B.m()
</code></pre> 
   <h4 id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</h4> 
   <pre><code class="language-java">public class Candy10 {
   public static void main(String[] args) {
      Runnable runnable = new Runnable() {
         @Override
         public void run() {
            System.out.println("running...");
         }
      };
   }
}

</code></pre> 
   <p>转换后的代码</p> 
   <pre><code class="language-java">public class Candy10 {
   public static void main(String[] args) {
      // 用额外创建的类来创建匿名内部类对象
      Runnable runnable = new Candy10$1();
   }
}

// 创建了一个额外的类，实现了 Runnable 接口
final class Candy10$1 implements Runnable {
   public Demo8$1() {}

   @Override
   public void run() {
      System.out.println("running...");
   }
}
</code></pre> 
   <p>引用局部变量的匿名内部类，源代码：</p> 
   <pre><code class="language-java">public class Candy11 { 
	public static void test(final int x) { 
		Runnable runnable = new Runnable() { 
			@Override 
			public void run() { 	
				System.out.println("ok:" + x); 
			} 
		}; 
	} 
}
</code></pre> 
   <p>转换后代码：</p> 
   <pre><code class="language-java">// 额外生成的类 
final class Candy11$1 implements Runnable { 
	int val$x; 
	Candy11$1(int x) { 
		this.val$x = x; 
	}
	public void run() { 
		System.out.println("ok:" + this.val$x); 
	} 
}

public class Candy11 { 
	public static void test(final int x) { 
		Runnable runnable = new Candy11$1(x); 
	} 
}
</code></pre> 
   <p>注意：这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的 x 值发生了改变，匿名内部类则值不一致。</p> 
   <h3 id="4.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5">4.类加载阶段</h3> 
   <h4 id="%E5%8A%A0%E8%BD%BD">加载</h4> 
   <p><span style="color:#fe2c24;">将类的字节码载入方法区</span>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p> 
   <ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul> 
   <p>如果这个类还有父类没有加载，先加载父类<br><span style="color:#fe2c24;">加载和链接可能是交替运行的</span><br><img alt="" height="685" src="https://images2.imgbox.com/51/9c/rlnoAhC8_o.png" width="1200"></p> 
   <ul><li> instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在堆内存中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息<br>  </li></ul> 
   <h4 id="%E8%BF%9E%E6%8E%A5">连接</h4> 
   <p><strong>验证</strong><br> 验证类是否符合 JVM规范，安全性检查</p> 
   <div> 
    <span style="color:#333333;"><strong>准备 </strong></span> 
   </div> 
   <p><span style="color:#333333;">为</span><span style="color:#333333;"> static </span><span style="color:#333333;">变量分配空间，设置默认值 </span></p> 
   <ul><li><span style="color:#333333;">static </span><span style="color:#333333;">变量在</span><span style="color:#333333;"> JDK 7 </span><span style="color:#333333;">之前存储于</span><span style="color:#333333;"> instanceKlass </span><span style="color:#333333;">末尾，从</span><span style="color:#333333;"> JDK 7 </span><span style="color:#333333;">开始，存储于</span><span style="color:#333333;"> _java_mirror </span><span style="color:#333333;">末尾 </span></li><li><span style="color:#333333;">static </span><span style="color:#333333;">变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成 </span></li><li><span style="color:#333333;">如果</span><span style="color:#333333;"> static </span><span style="color:#333333;">变量是</span><span style="color:#333333;"> final </span><span style="color:#333333;">的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶</span><span style="color:#333333;">段完成 </span></li><li><span style="color:#333333;">如果</span><span style="color:#333333;"> static </span><span style="color:#333333;">变量是</span><span style="color:#333333;"> final </span><span style="color:#333333;">的，但属于引用类型，那么赋值也会在初始化阶段完成 </span></li></ul> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#333333;"><strong>解析 </strong></span> 
    </div> 
    <div> 
     <span style="color:#333333;">将常量池中的符号引用解析为直接引用</span> 
    </div> 
    <div></div> 
    <h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</h4> 
    <p><strong>&lt;cinit&gt;()v 方法</strong></p> 
    <p>初始化即调用 &lt;cinit&gt;()V ，虚拟机会保证这个类的『构造方法』的线程安全</p> 
    <p>发生的时机<br> 概括得说，类初始化是【懒惰的】</p> 
    <ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul> 
    <p>不会导致类初始化的情况</p> 
    <ul><li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class 不会触发初始化</li><li>创建该类的数组不会触发初始化<br>  </li></ul> 
    <pre><code class="language-java">public class Load1 {
    static {
        System.out.println("main init");
    }
    public static void main(String[] args) throws ClassNotFoundException {
        // 1. 静态常量（基本类型和字符串）不会触发初始化
//         System.out.println(B.b);
        // 2. 类对象.class 不会触发初始化
//         System.out.println(B.class);
        // 3. 创建该类的数组不会触发初始化
//         System.out.println(new B[0]);
        // 4. 不会初始化类 B，但会加载 B、A
//         ClassLoader cl = Thread.currentThread().getContextClassLoader();
//         cl.loadClass("cn.ali.jvm.test.classload.B");
        // 5. 不会初始化类 B，但会加载 B、A
//         ClassLoader c2 = Thread.currentThread().getContextClassLoader();
//         Class.forName("cn.ali.jvm.test.classload.B", false, c2);


        // 1. 首次访问这个类的静态变量或静态方法时
//         System.out.println(A.a);
        // 2. 子类初始化，如果父类还没初始化，会引发
//         System.out.println(B.c);
        // 3. 子类访问父类静态变量，只触发父类初始化
//         System.out.println(B.a);
        // 4. 会初始化类 B，并先初始化类 A
//         Class.forName("cn.ali.jvm.test.classload.B");
    }

}


class A {
    static int a = 0;
    static {
        System.out.println("a init");
    }
}
class B extends A {
    final static double b = 5.0;
    static boolean c = false;
    static {
        System.out.println("b init");
    }
}
</code></pre> 
    <h4 id="%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%20-%20%E5%AE%8C%E6%88%90%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">典型应用 - 完成懒惰初始化单例模式</h4> 
    <pre><code class="language-java">public class Singleton {

    private Singleton() { } 
    // 内部类中保存单例
    private static class LazyHolder { 
        static final Singleton INSTANCE = new Singleton(); 
    }
    // 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 
    public static Singleton getInstance() { 
        return LazyHolder.INSTANCE; 
    }
}

</code></pre> 
    <p>以上的实现特点是：</p> 
    <ul><li>懒惰实例化</li><li>初始化时的线程安全是有保障的</li></ul> 
    <h3 id="5.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">5.类加载器</h3> 
    <p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段<br> 对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等！<br><img alt="" height="249" src="https://images2.imgbox.com/53/c4/xnvbgBUI_o.png" width="1200"></p> 
    <p><strong> 启动类的加载器</strong></p> 
    <p>可通过在控制台输入指令，使得类被启动类加器加载</p> 
    <p><strong>扩展类的加载器</strong></p> 
    <p>如果 classpath 和 JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p> 
    <h4 id="%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F">双亲委派模式</h4> 
    <p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则。<br> loadClass源码</p> 
    <pre><code class="language-java">protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // 首先查找该类是否已经被该类加载器加载过了
        Class&lt;?&gt; c = findLoadedClass(name);
        // 如果没有被加载过
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // 看是否被它的上级加载器加载过了 Extension 的上级是Bootstarp，但它显示为null
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 看是否被启动类加载器加载过
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
                //捕获异常，但不做任何处理
            }

            if (c == null) {
                // 如果还是没有找到，先让拓展类加载器调用 findClass 方法去找到该类，如果还是没找到，就抛出异常
                // 然后让应用类加载器去找 classpath 下找该类
                long t1 = System.nanoTime();
                c = findClass(name);

                // 记录时间
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
</code></pre> 
    <h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">自定义类加载器</h4> 
    <p><strong>使用场景</strong></p> 
    <p></p> 
    <ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul> 
    <p><strong>步骤</strong></p> 
    <ul><li>继承 ClassLoader 父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<br> 不是重写 loadClass 方法，否则不会走双亲委派机制</li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul> 
    <h4 id="%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%EF%BC%89"><strong>线程上下文类加载器（破坏双亲委派模式）</strong></h4> 
    <blockquote> 
     <p>ava 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。</p> 
     <p>这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由**启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)**来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。</p> 
     <p>而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。</p> 
    </blockquote> 
   </div> 
  </div> 
 </div> 
</div> 
<h3 id="%C2%A06.%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"> 6.运行期优化</h3> 
<h4 id="%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91">即时编译</h4> 
<p><strong>分层编译</strong></p> 
<p>JVM 将执行状态分成了 5 个层次：</p> 
<ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 即时编译器编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul> 
<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p> 
<p>即时编译器（JIT）与解释器的区别</p> 
<ul><li>解释器 
  <ul><li>将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器 
  <ul><li>将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul> 
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码。</p> 
<p><strong>逃逸分析</strong></p> 
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p> 
<p>使用逃逸分析，编译器可以对代码做如下优化：</p> 
<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p> 
<p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p> 
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p> 
<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p> 
<p>-XX:+DoEscapeAnalysis ： 表示开启逃逸分析</p> 
<p>-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p> 
<p><br><strong>同步省略</strong></p> 
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p> 
<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。<br>  </p> 
<p id="标量替换"><strong>标量替换</strong></p> 
<p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p> 
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p> 
<p>标量替换为栈上分配提供了很好的基础。</p> 
<p id="栈上分配"><strong>栈上分配</strong></p> 
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p> 
<p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在对象和数组并不是都在堆上分配内存的。中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。<br>  </p> 
<h4 id="%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94" style="background-color:transparent;"><strong>方法内联</strong></h4> 
<pre><code class="language-java">private static int square(final int i) {
return i * i;
}

System.out.println(square(9));</code></pre> 
<div> 
 <span style="color:#333333;">如果发现</span> 
 <span style="color:#333333;"> square </span> 
 <span style="color:#333333;">是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置： </span> 
</div> 
<div> 
 <pre><code class="language-java">System.out.println(9 * 9);</code></pre> 
 <p><span style="color:#333333;">还能够进行常量折叠（constant folding</span><span style="color:#333333;">）的优化 </span></p> 
 <pre><code class="language-java">System.out.println(81);</code></pre> 
 <p><strong>字段优化</strong></p> 
 <pre><code class="language-java">public void test1() {
for (int i = 0; i &lt; elements.length; i++) {
doSum(elements[i]);
}
}

static void doSum(int x) {
sum += x;
}</code></pre> 
 <div></div> 
 <div> 
  <span style="color:#333333;">如果</span> 
  <span style="color:#333333;"> doSum </span> 
  <span style="color:#333333;">方法内联了，刚才的</span> 
  <span style="color:#333333;"> test1 </span> 
  <span style="color:#333333;">方法会被优化成下面的样子（伪代码）：</span> 
 </div> 
 <div> 
  <pre><code class="language-java">public void test1() {
// elements.length 首次读取会缓存起来 -&gt; int[] local
for (int i = 0; i &lt; elements.length; i++) { // 后续 999 次 求长度 &lt;- local
sum += elements[i]; // 1000 次取下标 i 的元素 &lt;- local
}
}</code></pre> 
  <h4 id="%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96">反射优化</h4> 
  <pre><code class="language-java">public class Reflect1 {
   public static void foo() {
      System.out.println("foo...");
   }

   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
      Method foo = Demo3.class.getMethod("foo");
      for(int i = 0; i&lt;=16; i++) {
         foo.invoke(null);
      }
   }
}
</code></pre> 
  <p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现<br> invoke 方法源码</p> 
  <pre><code class="language-java">@CallerSensitive
public Object invoke(Object obj, Object... args)
    throws IllegalAccessException, IllegalArgumentException,
       InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class&lt;?&gt; caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, obj, modifiers);
        }
    }
    //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类
    MethodAccessor ma = methodAccessor;             // read volatile
    if (ma == null) {
        ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
}
</code></pre> 
  <div> 
   <span style="color:#333333;">当调用到第</span> 
   <span style="color:#333333;"> 16 </span> 
   <span style="color:#333333;">次（从</span> 
   <span style="color:#333333;">0</span> 
   <span style="color:#333333;">开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过</span> 
   <span style="color:#333333;"> debug </span> 
   <span style="color:#333333;">得到 类名为 sun.reflect.GeneratedMethodAccessor1</span> 
  </div> 
  <div> 
   <img alt="" height="118" src="https://images2.imgbox.com/7d/dd/bTqG6JCa_o.png" width="638"> 
  </div> 
  <p>会由 DelegatingMehodAccessorImpl 去调用 NativeMethodAccessorImpl<br> NativeMethodAccessorImpl 源码</p> 
  <pre><code class="language-java">class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private final Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;

    NativeMethodAccessorImpl(Method var1) {
        this.method = var1;
    }
	
	//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一
	//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法
    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {
        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {
            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());
            this.parent.setDelegate(var3);
        }

        return invoke0(this.method, var1, var2);
    }

    void setParent(DelegatingMethodAccessorImpl var1) {
        this.parent = var1;
    }

    private static native Object invoke0(Method var0, Object var1, Object[] var2);
}
</code></pre> 
  <pre><code class="language-java">//ReflectionFactory.inflationThreshold()方法的返回值
private static int inflationThreshold = 15;</code></pre> 
  <ul><li>一开始if条件不满足，就会调用本地方法 invoke0</li><li>随着 numInvocation 的增大，当它大于 ReflectionFactory.inflationThreshold 的值 16 时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率，这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()</li></ul> 
  <p><img alt="" height="634" src="https://images2.imgbox.com/1b/4d/VZ7WayZK_o.png" width="1054"></p> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9069dc5ad6d18ebef663ca745ceeb535/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hbase shell实验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47b171d4c28bf70d86b722a3a6617cae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JS 获取URL 某个参数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>