<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>bond接口参数配置 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="bond接口参数配置" />
<meta property="og:description" content="Bond接口最简化的创建命令如下，任何参数都使用默认：
ip link add bond1 type bond 或者： ip link add type bond 由内核决定接口名称，格式为：bond%d。 以上命令，创建的bond1设备，默认参数可使用如下命令查看。
$ ip -d link show dev bond1 5: bond1: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 8e:cf:e6:a3:de:82 brd ff:ff:ff:ff:ff:ff promiscuity 0 bond mode balance-rr miimon 0 updelay 0 downdelay 0 use_carrier 1 arp_interval 0 arp_validate none arp_all_targets any primary_reselect always fail_over_mac none xmit_hash_policy layer2 resend_igmp 1 num_grat_arp 1 all_slaves_active 0 min_links 0 lp_interval 1 packets_per_slave 1 lacp_rate slow ad_select stable tlb_dynamic_lb 1 addrgenmode eui64 numtxqueues 16 numrxqueues 16 gso_max_size 65536 gso_max_segs 65535 参数mode 由内核中函数bond_check_params可知，如果不指定模式mode参数，默认情况下为BOND_MODE_ROUNDROBIN，即以上显示的balance-rr。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/669f4c7ef94424f016b4988665db3368/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-26T09:20:57+08:00" />
<meta property="article:modified_time" content="2020-02-26T09:20:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">bond接口参数配置</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Bond接口最简化的创建命令如下，任何参数都使用默认：</p> 
<pre><code>ip link add bond1 type bond 或者：
ip link add type bond  由内核决定接口名称，格式为：bond%d。
</code></pre> 
<p>以上命令，创建的bond1设备，默认参数可使用如下命令查看。</p> 
<pre><code>$ ip -d link show dev bond1
5: bond1: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 8e:cf:e6:a3:de:82 brd ff:ff:ff:ff:ff:ff promiscuity 0 
    bond mode balance-rr miimon 0 updelay 0 downdelay 0 use_carrier 1 arp_interval 0 arp_validate none arp_all_targets any primary_reselect always fail_over_mac none xmit_hash_policy layer2 resend_igmp 1 num_grat_arp 1 all_slaves_active 0 min_links 0 lp_interval 1 packets_per_slave 1 lacp_rate slow ad_select stable tlb_dynamic_lb 1 addrgenmode eui64 numtxqueues 16 numrxqueues 16 gso_max_size 65536 gso_max_segs 65535 
</code></pre> 
<h4><a id="mode_25"></a>参数mode</h4> 
<p>由内核中函数bond_check_params可知，如果不指定模式mode参数，默认情况下为BOND_MODE_ROUNDROBIN，即以上显示的balance-rr。</p> 
<pre><code>static int bond_check_params(struct bond_params *params)
{
    int bond_mode   = BOND_MODE_ROUNDROBIN;
</code></pre> 
<p>目前bond支持的模式如下：</p> 
<table><thead><tr><th>值</th><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>balance-rr</td><td>在可用的从设备之间按顺序轮询</td></tr><tr><td>1</td><td>active-backup</td><td>固定某一个从设备，不可用时选择另一从设备</td></tr><tr><td>2</td><td>balance-xor</td><td>依据对报文信息的hash（xor）结果选择发送使用的从设备</td></tr><tr><td>3</td><td>broadcast</td><td>每个报文都在所有的从设备上执行发送</td></tr><tr><td>4</td><td>802.3ad</td><td>802.3ad标准</td></tr><tr><td>5</td><td>balance-tlb</td><td>可调整的发送负载均衡，根据从设备的负载选择使用从设备</td></tr><tr><td>6</td><td>balance-alb</td><td>可调整的负载均衡，包含发送tlb和接收rlb</td></tr></tbody></table> 
<h4><a id="MII_52"></a>MII相关选项</h4> 
<p>选项miimon指定通过MII检查链路状态的间隔时长，单位是毫秒。默认情况下miimon值为零，对于802.3ad、tlb和alb三种不使用以下介绍的arp链路检测方式的bond模式，内核要求启用miimon检查方式，默认检测时长为BOND_DEFAULT_MIIMON（100ms），否则，bond系统将不能检测链路的状况，如下bond_check_params函数中代码所示。</p> 
<pre><code>static int bond_check_params(struct bond_params *params)
{ 
    if (miimon &lt; 0) {
        pr_warn("Warning: miimon module parameter (%d), not in range 0-%d, so it was reset to 0\n", miimon, INT_MAX);
        miimon = 0;
    }
    /* reset values for 802.3ad/TLB/ALB */
    if (!bond_mode_uses_arp(bond_mode)) {
        if (!miimon) {
            pr_warn("Warning: miimon must be specified, otherwise bonding will not detect link failure, speed and duplex which are essential for 802.3ad operation\n");
            pr_warn("Forcing miimon to 100msec\n");
            miimon = BOND_DEFAULT_MIIMON;
        }
    }
</code></pre> 
<p>对于选项updelay和downdelay，前者表示延迟多长时间系统认为链路为UP状态；或者表示延迟多久认为链路DOWN，单位都是毫秒。如下所示，如果miimon选项未开启，updelay和downdelay选项将不起作用。</p> 
<p>如果开启miimon选项，将关闭arp_interval选项（稍后介绍），updelay和downdelay的值应为miimon值的整数倍，系统会强制这一点，最终，updelay和downdelay中保存的为miimon的倍数，而不是最初的毫秒值。</p> 
<pre><code>    if (!miimon) {
        if (updelay || downdelay) {
            /* just warn the user the up/down delay will have no effect since miimon is zero...
             */
            pr_warn("Warning: miimon module parameter not set and updelay (%d) or downdelay (%d) module parameter is set; updelay and downdelay have no effect unless miimon is set\n", updelay, downdelay);
        }
    } else {
        if (arp_interval) {  /* don't allow arp monitoring */
            pr_warn("Warning: miimon (%d) and arp_interval (%d) can't be used simultaneously, disabling ARP monitoring\n", miimon, arp_interval);
            arp_interval = 0;
        }

        if ((updelay % miimon) != 0) {
            pr_warn("Warning: updelay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n", updelay, miimon, (updelay / miimon) * miimon);
        }
        updelay /= miimon;

        if ((downdelay % miimon) != 0) {
            pr_warn("Warning: downdelay (%d) is not a multiple of miimon (%d), downdelay rounded to %d ms\n", downdelay, miimon, (downdelay / miimon) * miimon);
        }
        downdelay /= miimon;
    }
</code></pre> 
<p>bond系统为每个实例启动一个delayed work调用函数bond_mii_monitor执行MII检查，要求网卡支持ethtool的get_link调用，或者MII的ioctl接口，参见函数bond_check_dev_link。</p> 
<pre><code>static int bond_check_dev_link(struct bonding *bond, struct net_device *slave_dev, int reporting)
{
    const struct net_device_ops *slave_ops = slave_dev-&gt;netdev_ops;

    if (!reporting &amp;&amp; !netif_running(slave_dev))
        return 0;
    if (bond-&gt;params.use_carrier)
        return netif_carrier_ok(slave_dev) ? BMSR_LSTATUS : 0;

    if (slave_dev-&gt;ethtool_ops-&gt;get_link)   /* Try to get link status using Ethtool first. */
        return slave_dev-&gt;ethtool_ops-&gt;get_link(slave_dev) ? BMSR_LSTATUS : 0;

    ioctl = slave_ops-&gt;ndo_do_ioctl; /* Ethtool can't be used, fallback to MII ioctls. */
    if (ioctl) {
        strncpy(ifr.ifr_name, slave_dev-&gt;name, IFNAMSIZ);
        mii = if_mii(&amp;ifr);
        if (ioctl(slave_dev, &amp;ifr, SIOCGMIIPHY) == 0) {
            mii-&gt;reg_num = MII_BMSR;
            if (ioctl(slave_dev, &amp;ifr, SIOCGMIIREG) == 0)
                return mii-&gt;val_out &amp; BMSR_LSTATUS;
        } 
</code></pre> 
<p>选项use_carrier定义了在MII进行链路检测时，所使用的方式。值为0表示使用以上介绍的ethtool或者MII ioctl方式；值为1表示使用驱动程序提供的netif_carrier_ok函数，如以上的bond_check_dev_link函数所示。默认情况下，user_carrier选项为1。</p> 
<pre><code>static int use_carrier  = 1;

static int bond_check_params(struct bond_params *params)
{ 
    if ((use_carrier != 0) &amp;&amp; (use_carrier != 1)) {
        pr_warn("Warning: use_carrier module parameter (%d), not of valid value (0/1), so it was set to 1\n", use_carrier);
        use_carrier = 1;
    }
</code></pre> 
<h4><a id="ARP_153"></a>ARP相关选项</h4> 
<p>arp_interval选项指定bond系统进行ARP链路检测的间隔时长，也就是bond_arp_monitor函数对应的delayed work执行的间隔（对于activebackup模式会略有出入）。在函数bond_arp_monitor中，检查从设备接收或者发送流量的最近时间，来决定其up或者down的状态。ARP流量在bond_arp_monitor函数中使用诸如（bond_arp_send_all函数）发送，其目的地址为选项arp_ip_target中所指定地址，最多可指定16（BOND_MAX_ARP_TARGETS）个目标地址。arp链路检测功能不能和miimon功能同时使用。</p> 
<p>如下函数bond_check_params中的初始化代码，如果arp_ip_target选项中未指定地址，禁用arp_interval，默认情况下arp_interval为0。</p> 
<pre><code>    for (arp_ip_count = 0, i = 0; (arp_ip_count &lt; BOND_MAX_ARP_TARGETS) &amp;&amp; arp_ip_target[i]; i++) {

        /* not a complete check, but good enough to catch mistakes */
        if (!in4_pton(arp_ip_target[i], -1, (u8 *)&amp;ip, -1, NULL) || !bond_is_ip_target_ok(ip)) {
            pr_warn("Warning: bad arp_ip_target module parameter (%s), ARP monitoring will not be performed\n", arp_ip_target[i]);
            arp_interval = 0;
        } else {
            if (bond_get_targets_ip(arp_target, ip) == -1)
                arp_target[arp_ip_count++] = ip;
            else
                pr_warn("Warning: duplicate address %pI4 in arp_ip_target, skipping\n", &amp;ip);
        }
    }
    if (arp_interval &amp;&amp; !arp_ip_count) {
        /* don't allow arping if no arp_ip_target given... */
        pr_warn("Warning: arp_interval module parameter (%d) specified without providing an arp_ip_target parameter, arp_inter     val was reset to 0\n",
            arp_interval);
        arp_interval = 0;
    }
</code></pre> 
<p>选项arp_validate决定是否对ARP流量（请求和应答）进行验证，以及是否过滤非ARP流量，其取值如下：</p> 
<table><thead><tr><th>数值</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>none</td><td>No validation or filtering</td></tr><tr><td>1</td><td>active</td><td>Validation is performed only for the active slave.</td></tr><tr><td>2</td><td>backup</td><td>Validation is performed only for backup slaves.</td></tr><tr><td>3</td><td>all</td><td>Validation is performed for all slaves.</td></tr><tr><td>4</td><td>filter</td><td>Filtering is applied to all slaves. <br> No validation is performed.</td></tr><tr><td>5</td><td>filter_active</td><td>Filtering is applied to all slaves,<br> validation is performed only for the active slave.</td></tr><tr><td>6</td><td>filter_backup</td><td>Filtering is applied to all slaves,<br> validation is performed only for backup slaves.</td></tr></tbody></table> 
<p>对于活动的从设备，开启arp_validate之后，将检查arp响应报文是否由arp_ip_target中的地址所产生。对于非活动从设备，其可能由对端交换机接收到活动设备发送的广播ARP请求，从而执行arp_validate操作，如果由于对端交换机的行为，接收不到ARP报文，需要禁止对非活动从设备的验证。对于非活动从设备接收到ARP请求的情况，应判断报文的源IP为bond接口的IP地址，而目的IP为arp_ip_target中的地址。对于接收到ARP请求，判断情况相反。</p> 
<p>对于多个bond实例连接在同一个交换机的情况，其中某个bond实例可接收到其它实例发送的ARP报文，将引起链路状态判断的错误，arp_validate正是解决此问题。filter过滤功能仅依据接收的ARP报文进行链路状态判断，忽略非ARP报文，这对于网络拓扑中存在大量其它的广播报文的情况，可屏蔽这里报文对链路状态判断的影响。</p> 
<p>如果为指定arp_interval，不应开启arp_validate功能，默认情况下arp_validate为0。</p> 
<pre><code>    if (arp_validate) {
        if (!arp_interval) {
            pr_err("arp_validate requires arp_interval\n");
            return -EINVAL;
        }
        bond_opt_initstr(&amp;newval, arp_validate);
        valptr = bond_opt_parse(bond_opt_get(BOND_OPT_ARP_VALIDATE), &amp;newval);
        if (!valptr) {
            pr_err("Error: invalid arp_validate \"%s\"\n", arp_validate);
            return -EINVAL;
        }
        arp_validate_value = valptr-&gt;value;
    } else {
        arp_validate_value = 0;
    }
</code></pre> 
<p>选项arp_all_targets仅对activeback模式的bond实例，在开启arp_validation的情况下有作用，其取值为0（any）或1(all)。为0时，如果arp_ip_targets中的某一个目标地址不可达时，就认为从设备部可用；如果取值为1，仅当arp_ip_targets中指定的所有目标地址全部可达时，才判断从设备为up状态。默认情况下arp_all_targets选项为0。</p> 
<pre><code>    if (arp_all_targets) {
        bond_opt_initstr(&amp;newval, arp_all_targets);
        valptr = bond_opt_parse(bond_opt_get(BOND_OPT_ARP_ALL_TARGETS), &amp;newval);
        if (!valptr) {
            pr_err("Error: invalid arp_all_targets_value \"%s\"\n", arp_all_targets);
            arp_all_targets_value = 0;
        } else {
            arp_all_targets_value = valptr-&gt;value;
</code></pre> 
<h4><a id="primaryprimary_reselect_243"></a>primary和primary_reselect</h4> 
<p>这两个选项仅在模式为active-backup(1), balance-tlb (5) 和 balance-alb (6)时有效，<strong>primary</strong>选项指定首选从设备，只要其可用，总是活动的从设备。只有当指定的首选从设备离线时，才选择其它从设备为活动设备。应用于某一从设备在带宽等方面优于其它从设备的情况下。</p> 
<p><strong>primary_reselect</strong>选项规定在当前活动设备失效或者首选设备恢复时，首选设备是否转变为活动设备的策略，其可选值如下：</p> 
<table><thead><tr><th>数值</th><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>always</td><td>默认值，首选设备总是转变为活动设备</td></tr><tr><td>1</td><td>better</td><td>首选设备的速率和双工参数要由于当前的活动设备</td></tr><tr><td>2</td><td>failure</td><td>仅在当前活动设备失效时，首选设备转变为活动设备</td></tr></tbody></table> 
<p>但是，当所有从设备都为失效状态时，第一个恢复的从设备转变为活动设备。另外，当首选设备首次添加到bond中时，其总是活动设备。重选策略可通过修改sysfs文件实现（/sys/devices/virtual/net/bond1/bonding/primary_reselect），此文件的修改将触发一次活动设备的选择操作。</p> 
<pre><code>$ cat /sys/devices/virtual/net/bond1/bonding/primary_reselect 
always 0
</code></pre> 
<p>如下函数bond_check_params中的代码，函数bond_mode_uses_primary判断模式是否为ACTIVEBACKUP/TLB/ALB，如果不成立，将primary设置为空。primary_reselect选项的值默认设置为宏BOND_PRI_RESELECT_ALWAYS（0）。</p> 
<pre><code>    if (primary &amp;&amp; !bond_mode_uses_primary(bond_mode)) {
        /* currently, using a primary only makes sense in active backup, TLB or ALB modes
         */
        pr_warn("Warning: %s primary device specified but has no effect in %s mode\n", primary, bond_mode_name(bond_mode));
        primary = NULL;
    }
    if (primary &amp;&amp; primary_reselect) {
        bond_opt_initstr(&amp;newval, primary_reselect);
        valptr = bond_opt_parse(bond_opt_get(BOND_OPT_PRIMARY_RESELECT), &amp;newval);
        if (!valptr) {
            pr_err("Error: Invalid primary_reselect \"%s\"\n", primary_reselect);
            return -EINVAL;
        }
        primary_reselect_value = valptr-&gt;value;
    } else {
        primary_reselect_value = BOND_PRI_RESELECT_ALWAYS;
    }
</code></pre> 
<h4><a id="fail_over_mac_293"></a>fail_over_mac</h4> 
<p>选项fail_over_mac仅对active-backup模式有效，其取值如下：</p> 
<table><thead><tr><th>数组</th><th>表示</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>none</td><td>默认值，将bond内所有从设备MAC地址设为同一地址</td></tr><tr><td>1</td><td>active</td><td>从设备MAC地址不改变，bond的MAC地址等于活动从设备的MAC</td></tr><tr><td>2</td><td>follow</td><td>bond的MAC地址等于第一个加入的从设备的MAC地址，<br> 当其它从设备变为活动设备时，将活动设备MAC修改为bond的MAC地址；<br> 而上一个活动设备的MAC地址修改为当前活动设备的MAC地址。</td></tr></tbody></table> 
<p>如下函数bond_check_params所示，默认情况下fail_over_mac取值为BOND_FOM_NONE（0）。</p> 
<pre><code>    if (fail_over_mac) {
        bond_opt_initstr(&amp;newval, fail_over_mac);
        valptr = bond_opt_parse(bond_opt_get(BOND_OPT_FAIL_OVER_MAC), &amp;newval);
        if (!valptr) {
            pr_err("Error: invalid fail_over_mac \"%s\"\n", fail_over_mac);
            return -EINVAL;
        }
        fail_over_mac_value = valptr-&gt;value;
        if (bond_mode != BOND_MODE_ACTIVEBACKUP)
            pr_warn("Warning: fail_over_mac only affects active-backup mode\n");
    } else {
        fail_over_mac_value = BOND_FOM_NONE;
    }
</code></pre> 
<p>可通过以下sysfs文件修改fail_over_mac的值，但是此操作要求在bond没有任何从设备的请求下进行。</p> 
<pre><code>$ cat /sys/devices/virtual/net/bond1/bonding/fail_over_mac 
none 0
</code></pre> 
<h4><a id="xmit_hash_policy_338"></a>xmit_hash_policy</h4> 
<p>用于在balance-xor, 802.3ad, 和 tlb模式下，选择发送使用的hash算法，可选值如下：</p> 
<table><thead><tr><th>数值</th><th>策略</th><th>算法</th></tr></thead><tbody><tr><td>0</td><td>layer 2</td><td>默认值， hash = source MAC XOR destination MAC XOR packet type ID <br> hash mod slave count</td></tr><tr><td>1</td><td>layer 3+4</td><td>hash = source MAC XOR destination MAC XOR packet type ID <br> hash = hash XOR source IP XOR destination IP <br> hash = hash XOR (hash RSHIFT 16) <br> hash = hash XOR (hash RSHIFT 8) <br> hash mod slave count</td></tr><tr><td>2</td><td>layer 2+3</td><td>hash = source port, destination port (as in the header) <br> hash = hash XOR source IP XOR destination IP <br> hash = hash XOR (hash RSHIFT 16) <br> hash = hash XOR (hash RSHIFT 8) <br> hash modulo slave count.</td></tr><tr><td>3</td><td>encap layer 2+3</td><td>算法与layer 2+3相同，但是对于隧道封装报文，使用内部报文头部数据做计算</td></tr><tr><td>4</td><td>encap layer 3+4</td><td>算法与layer 3+4相同，但是对于隧道封装报文，使用内部报文头部数据做计算</td></tr></tbody></table> 
<p>内核中默认的值为BOND_XMIT_POLICY_LAYER2（0），对于ROUNDROBIN / ACTIVEBACKUP / BROADCAST三种模式，此选项没有效果。</p> 
<pre><code>    int xmit_hashtype = BOND_XMIT_POLICY_LAYER2;
    
    if (xmit_hash_policy) {
        if (bond_mode == BOND_MODE_ROUNDROBIN || bond_mode == BOND_MODE_ACTIVEBACKUP || bond_mode == BOND_MODE_BROADCAST) {
            pr_info("xmit_hash_policy param is irrelevant in mode %s\n", bond_mode_name(bond_mode));
        } else {
            bond_opt_initstr(&amp;newval, xmit_hash_policy);
            valptr = bond_opt_parse(bond_opt_get(BOND_OPT_XMIT_HASH), &amp;newval);
            if (!valptr) {
                pr_err("Error: Invalid xmit_hash_policy \"%s\"\n", xmit_hash_policy);
                return -EINVAL;
            }
            xmit_hashtype = valptr-&gt;value;
        } 
    }
</code></pre> 
<h4><a id="resend_igmp_378"></a>resend_igmp</h4> 
<p>选项resend_igmp指定在发生故障切换时，发送IGMP membership报告的数量，取值范围[0, 255]，默认值为BOND_DEFAULT_RESEND_IGMP（1）。在发送failover时，如果resend_igmp不为零，立即发送IGMP报告，如果resend_igmp大于1，后续的报文间隔200ms发送。</p> 
<pre><code>static int resend_igmp = BOND_DEFAULT_RESEND_IGMP;

static int bond_check_params(struct bond_params *params)
{ 
    if (resend_igmp &lt; 0 || resend_igmp &gt; 255) {
        pr_warn("Warning: resend_igmp (%d) should be between 0 and 255, resetting to %d\n", resend_igmp, BOND_DEFAULT_RESEND_IGMP);
        resend_igmp = BOND_DEFAULT_RESEND_IGMP;
    }
</code></pre> 
<p>如下的delayed work执行函数bond_resend_igmp_join_requests_delayed，每个HZ/5(200ms)执行一次。</p> 
<pre><code>static void bond_resend_igmp_join_requests_delayed(struct work_struct *work)
{
    struct bonding *bond = container_of(work, struct bonding, mcast_work.work);

    if (!rtnl_trylock()) {
        queue_delayed_work(bond-&gt;wq, &amp;bond-&gt;mcast_work, 1);
        return;
    }
    call_netdevice_notifiers(NETDEV_RESEND_IGMP, bond-&gt;dev);

    if (bond-&gt;igmp_retrans &gt; 1) {
        bond-&gt;igmp_retrans--;
        queue_delayed_work(bond-&gt;wq, &amp;bond-&gt;mcast_work, HZ/5);
    }
</code></pre> 
<h4><a id="num_grat_arp_418"></a>num_grat_arp</h4> 
<p>选项num_grat_arp与IPv6的选项num_unsol_na意义相同，指定在故障转移时，发送免费ARP和unsolicited IPv6 NA邻居通告的数量，取值范围：[0, 255]，默认值为1。此选项仅对active-backup模式有效。</p> 
<pre><code>static int num_peer_notif = 1;
  
static int bond_check_params(struct bond_params *params)
{ 
    if (num_peer_notif &lt; 0 || num_peer_notif &gt; 255) {
        pr_warn("Warning: num_grat_arp/num_unsol_na (%d) not in range 0-255 so it was reset to 1\n", num_peer_notif);
        num_peer_notif = 1;
    }
</code></pre> 
<p>首先在failover处理函数bond_change_active_slave中，如果num_grat_arp启用，发送NETDEV_NOTIFY_PEERS通知。</p> 
<pre><code>void bond_change_active_slave(struct bonding *bond, struct slave *new_active)
{
    if (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP) {
            if (should_notify_peers)
                call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, bond-&gt;dev);
</code></pre> 
<p>其次，在bond系统的两个delayed work处理MII和ARP链路检测中，如果满足发送条件，其中包括num_grat_arp指定次数未达到，继续发送NETDEV_NOTIFY_PEERS通知。</p> 
<pre><code>static void bond_mii_monitor(struct work_struct *work)
{
    if (should_notify_peers) {
        call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, bond-&gt;dev);

static void bond_activebackup_arp_mon(struct bonding *bond)
{
    if (should_notify_peers || should_notify_rtnl) {
        if (should_notify_peers)
            call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, bond-&gt;dev);
</code></pre> 
<p>在bond函数注册的netdevice通知链处理函数bond_master_netdev_event中，每接收到一次NETDEV_NOTIFY_PEERS通知，将发送次数递减一。</p> 
<pre><code>static int bond_master_netdev_event(unsigned long event, struct net_device *bond_dev)
{
    struct bonding *event_bond = netdev_priv(bond_dev);

    switch (event) {
    case NETDEV_NOTIFY_PEERS:
        if (event_bond-&gt;send_peer_notif)
            event_bond-&gt;send_peer_notif--;
</code></pre> 
<p>最后，对于IPv4协议，在函数inetdev_event中，接收到NETDEV_NOTIFY_PEERS事件，发送免费ARP。</p> 
<pre><code>static int inetdev_event(struct notifier_block *this, unsigned long event, void *ptr)
{
    struct net_device *dev = netdev_notifier_info_to_dev(ptr);
    struct in_device *in_dev = __in_dev_get_rtnl(dev);

    switch (event) {
    case NETDEV_NOTIFY_PEERS:
        /* Send gratuitous ARP to notify of link change */
        inetdev_send_gratuitous_arp(dev, in_dev);
</code></pre> 
<p>对于IPv6协议，在函数ndisc_netdev_event中处理NETDEV_NOTIFY_PEERS通知事件，发送unsolicited邻居通告。</p> 
<pre><code>static int ndisc_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)
{
    struct net_device *dev = netdev_notifier_info_to_dev(ptr);

    switch (event) {
    case NETDEV_NOTIFY_PEERS:
        ndisc_send_unsol_na(dev);
        break;
</code></pre> 
<p>另外，对于bond接口上创建的VLAN子接口，在VLAN子系统处理函数vlan_device_event中，将变量所有的VLAN子接口，发送NETDEV_NOTIFY_PEERS事件，每个VLAN子设备的处理函数也是上面介绍的inetdev_event和ndisc_netdev_event函数。</p> 
<pre><code>static int vlan_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
{
    struct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);
    struct net_device *dev = netdev_notifier_info_to_dev(ptr);

    switch (event) {
    case NETDEV_NOTIFY_PEERS:
    case NETDEV_BONDING_FAILOVER:
    case NETDEV_RESEND_IGMP:
        /* Propagate to vlan devices */
        vlan_group_for_each_dev(grp, i, vlandev)
            call_netdevice_notifiers(event, vlandev);
        break;
</code></pre> 
<h4><a id="all_slaves_active_528"></a>all_slaves_active</h4> 
<p>选项all_slaves_active决定是否为每个从设备设定active标志，开启之后，所有从设备都可正常转发报文，这将都是重复报文的处理。默认情况下all_slaves_active值为0（dropped），非活动的从设备将丢弃重复报文；可能在某些情况下all_slaves_active需要设置为1（delivered）。</p> 
<p>如下bond_set_slave_inactive_flags函数，如果all_salves_active为1，将不会为从设备设置inactive标志。</p> 
<pre><code>static inline void bond_set_slave_inactive_flags(struct slave *slave, bool notify)
{
    if (!bond_is_lb(slave-&gt;bond))
        bond_set_slave_state(slave, BOND_STATE_BACKUP, notify);
    if (!slave-&gt;bond-&gt;params.all_slaves_active)
        slave-&gt;inactive = 1;
}
</code></pre> 
<p>在bond系统处理函数bond_handle_frame中，将调用如下函数bond_should_deliver_exact_match判断是否要跳过报文处理，如果所有的从设备都没有设置inactive，返回false，正常处理接收的报文。</p> 
<pre><code>static bool bond_should_deliver_exact_match(struct sk_buff *skb, struct slave *slave, struct bonding *bond)
{
    if (bond_is_slave_inactive(slave)) {
        if (BOND_MODE(bond) == BOND_MODE_ALB &amp;&amp;
            skb-&gt;pkt_type != PACKET_BROADCAST &amp;&amp;
            skb-&gt;pkt_type != PACKET_MULTICAST)
            return false;
        return true;
    }
    return false;
</code></pre> 
<h4><a id="min_links_565"></a>min_links</h4> 
<p>选项min_lins规定了bond接口转变为carrier on前至少要有的可用链路数量，此选项仅在802.3ad模式下生效，默认值为0，即只要有可用的链路，bond接口就设置为carrier on。如下函数bond_3ad_set_carrier所示，如果active的端口数量小于设定值min_links，将bond设备设置为carrier off。</p> 
<pre><code>int bond_3ad_set_carrier(struct bonding *bond)
{
    active = __get_active_agg(&amp;(SLAVE_AD_INFO(first_slave)-&gt;aggregator));
    if (active) {
        /* are enough slaves available to consider link up? */
        if (__agg_active_ports(active) &lt; bond-&gt;params.min_links) {
            if (netif_carrier_ok(bond-&gt;dev)) {
                netif_carrier_off(bond-&gt;dev);
                goto out;
            }
        } else if (!netif_carrier_ok(bond-&gt;dev)) {
            netif_carrier_on(bond-&gt;dev);
            goto out;
        }
</code></pre> 
<h4><a id="lp_interval_589"></a>lp_interval</h4> 
<p>选项lp_interval定义了bond实例向对端交换机发送Learning Packets报文的时间间隔，此选项仅在balance-tlb 和 balance-alb模式下生效，取值范围：[1, 0x7fffffff]，单位为秒，默认值为BOND_ALB_DEFAULT_LP_INTERVAL（1秒）。</p> 
<pre><code>static int lp_interval = BOND_ALB_DEFAULT_LP_INTERVAL;

static int bond_check_params(struct bond_params *params)
{
    if (lp_interval == 0) {
        pr_warn("Warning: ip_interval must be between 1 and %d, so it was reset to %d\n", INT_MAX, BOND_ALB_DEFAULT_LP_INTERVAL);
        lp_interval = BOND_ALB_DEFAULT_LP_INTERVAL;
    }
</code></pre> 
<p>内核中处理函数bond_alb_monitor的运行时间间隔是alb_delta_in_ticks,即1/10秒，每次运行，将lp计数lp_counter自加一，选项lp_interval换算为次数的话，值为BOND_ALB_LP_TICKS，当lp_counter大于等于BOND_ALB_LP_TICKS时，发送Learning报文。</p> 
<pre><code>#define ALB_TIMER_TICKS_PER_SEC     10  /* should be a divisor of HZ */
#define BOND_ALB_LP_INTERVAL(bond) (bond-&gt;params.lp_interval)
#define BOND_ALB_LP_TICKS(bond) (BOND_ALB_LP_INTERVAL(bond) * ALB_TIMER_TICKS_PER_SEC)

static const int alb_delta_in_ticks = HZ / ALB_TIMER_TICKS_PER_SEC;

void bond_alb_monitor(struct work_struct *work)
{
    struct bonding *bond = container_of(work, struct bonding, alb_work.work);
    struct alb_bond_info *bond_info = &amp;(BOND_ALB_INFO(bond));

    bond_info-&gt;lp_counter++;

    if (bond_info-&gt;lp_counter &gt;= BOND_ALB_LP_TICKS(bond)) {/* send learning packets */

        bond_for_each_slave_rcu(bond, slave, iter) {
            /* If updating current_active, use all currently user mac addreses (!strict_match).  Otherwise, only
             * use mac of the slave device. In RLB mode, we always use strict matches.
             */
            strict_match = (slave != rcu_access_pointer(bond-&gt;curr_active_slave) || bond_info-&gt;rlb_enabled);
            alb_send_learning_packets(slave, slave-&gt;dev-&gt;dev_addr, strict_match);
        }
        bond_info-&gt;lp_counter = 0;
    }
</code></pre> 
<p>以上函数bond_alb_monitor仅在ALB模式或者TLB模式下并且打开tlb_dynamic_lb选项的情况下调用。</p> 
<pre><code>static int bond_open(struct net_device *bond_dev)
{
    struct bonding *bond = netdev_priv(bond_dev);

    if (bond_is_lb(bond)) {
        /* bond_alb_initialize must be called before the timer is started.
         */
        if (bond_alb_initialize(bond, (BOND_MODE(bond) == BOND_MODE_ALB)))
            return -ENOMEM;
        if (bond-&gt;params.tlb_dynamic_lb || BOND_MODE(bond) == BOND_MODE_ALB)
            queue_delayed_work(bond-&gt;wq, &amp;bond-&gt;alb_work, 0);
    }
</code></pre> 
<h4><a id="packets_per_slave_657"></a>packets_per_slave</h4> 
<p>选项packets_per_slave指定在转换到下一个从设备之前，当前从设备发送的报文数量，仅在balance-rr模式下生效。取值范围：[0 - 65535]，值为0时，随机选择下一个从设备；默认值为1，每个从设备发送一个报文。</p> 
<p>在初始化函数bond_check_params中，如果选项packets_per_slave大于零，这里先计算出其倒数值（reciprocal_value）。</p> 
<pre><code>static int packets_per_slave = 1;

static int bond_check_params(struct bond_params *params)
{
    if (packets_per_slave &gt; 0) {
        params-&gt;reciprocal_packets_per_slave = reciprocal_value(packets_per_slave);
    }
</code></pre> 
<p>如下函数bond_rr_gen_slave_id用于选择balance-rr模式下的下一个发送从设备ID。当选项packets_per_slave为0时，使用随机函数prandom_u32进行选择。当为1时，slave_id等于rr_tx_counter的值，后者在每发送一个报文后递增一。其它情况下，使用统计出来的发送报文数量rr_tx_counter除以选项中定义的报文数量packets_per_slave的结果作为从设备ID，即每个设备发送packets_per_slave数量的报文。</p> 
<pre><code>static u32 bond_rr_gen_slave_id(struct bonding *bond)
{
    int packets_per_slave = bond-&gt;params.packets_per_slave;

    switch (packets_per_slave) {
    case 0:
        slave_id = prandom_u32();
        break;
    case 1:
        slave_id = bond-&gt;rr_tx_counter;
        break;
    default:
        reciprocal_packets_per_slave = bond-&gt;params.reciprocal_packets_per_slave;
        slave_id = reciprocal_divide(bond-&gt;rr_tx_counter, reciprocal_packets_per_slave);
        break;
    }
    bond-&gt;rr_tx_counter++;
    return slave_id;
</code></pre> 
<h4><a id="lacp_rate_703"></a>lacp_rate</h4> 
<p>选项lacp_rate指定请求对端执行的LACPDU报文的发送速率，此选项仅在802.3ad模式下生效。默认值为0（slow），其它有效值为1（fast）。如下函数ad_initialize_port，如果lacp_fast为真，将设置Actor状态的AD_STATE_LACP_TIMEOUT比特位，根据802.3ad协议，此位位于LACPDU报文结构的Actor_State中的第二位（bit 1），表示长短两种超时时间，说明此LACPDU报文中的信息的有效时长。</p> 
<pre><code>void bond_3ad_bind_slave(struct slave *slave)
{
    if (SLAVE_AD_INFO(slave)-&gt;port.slave != slave) {
        port = &amp;(SLAVE_AD_INFO(slave)-&gt;port);
        ad_initialize_port(port, bond-&gt;params.lacp_fast);

static void ad_initialize_port(struct port *port, int lacp_fast)
{
    if (port) {
        if (lacp_fast)
            port-&gt;actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;
</code></pre> 
<p>802.3ad定义的两者超时时长，如下宏定义AD_FAST_PERIODIC_TIME和AD_SLOW_PERIODIC_TIME，单位为秒。如下函数__update_lacpdu_from_port，根据端口port的actor_oper_port_state值，更新LACPDU报文中的actor_state字段。</p> 
<pre><code>#define AD_FAST_PERIODIC_TIME      1
#define AD_SLOW_PERIODIC_TIME      30

static inline void __update_lacpdu_from_port(struct port *port)
{
    struct lacpdu *lacpdu = &amp;port-&gt;lacpdu;

    lacpdu-&gt;actor_state = port-&gt;actor_oper_port_state;
</code></pre> 
<p>以下为802.3ad的Periodic Transmission machine实现函数ad_periodic_machine，在sm_periodic_timer_counter时间超时之后，将根据AD_STATE_LACP_TIMEOUT标志，设置此状态机的状态为AD_SLOW_PERIODIC或者AD_FAST_PERIODIC，前者意味着下一次超时时长将设置为AD_SLOW_PERIODIC_TIME；而后者意味值超时时长设置为AD_FAST_PERIODIC_TIME。</p> 
<pre><code>static void ad_periodic_machine(struct port *port)
{
    if...
    else if (port-&gt;sm_periodic_timer_counter) {/* check if state machine should change state */
    } else {
        switch (port-&gt;sm_periodic_state) {
        case AD_NO_PERIODIC:
            port-&gt;sm_periodic_state = AD_FAST_PERIODIC;
            break;
        case AD_PERIODIC_TX:
            if (!(port-&gt;partner_oper.port_state &amp; AD_STATE_LACP_TIMEOUT))
                port-&gt;sm_periodic_state = AD_SLOW_PERIODIC;
            else
                port-&gt;sm_periodic_state = AD_FAST_PERIODIC;
            break;

    if (port-&gt;sm_periodic_state != last_state) {
        switch (port-&gt;sm_periodic_state) {
        case AD_FAST_PERIODIC:
            port-&gt;sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_FAST_PERIODIC_TIME))-1;
            break;
        case AD_SLOW_PERIODIC:
            port-&gt;sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_SLOW_PERIODIC_TIME))-1;
            break;
        case AD_PERIODIC_TX:
            port-&gt;ntt = true;
</code></pre> 
<p>LACPDU报文的发送时通过设置ntt（Need To Transmit）标志实现。具体发送在TX状态机函数ad_tx_machine中。</p> 
<pre><code>static void ad_tx_machine(struct port *port)
{
    /* check if tx timer expired, to verify that we do not send more than 3 packets per second
     */
    if (port-&gt;sm_tx_timer_counter &amp;&amp; !(--port-&gt;sm_tx_timer_counter)) {
        if (port-&gt;ntt &amp;&amp; (port-&gt;sm_vars &amp; AD_PORT_LACP_ENABLED)) {
            __update_lacpdu_from_port(port);

            if (ad_lacpdu_send(port) &gt;= 0) {
</code></pre> 
<h4><a id="ad_select_788"></a>ad_select</h4> 
<p>选项ad_select定义802.3ad模式的聚合选择逻辑，取值如下：</p> 
<table><thead><tr><th>数值</th><th>字符串</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>stable</td><td>默认值，活动aggregator依据最大带宽选择，当所有从设备down时，进行重新选择</td></tr><tr><td>1</td><td>bandwidth</td><td>同上，按照最大带宽选择。重选择时机如下：<br>从设备添加/移除<br>任一从设备链路变化<br>任一从设备的802.3ad关联状态变化<br>bond的管理状态变为UP</td></tr><tr><td>2</td><td>count</td><td>活动aggregator依据最大port（从设备）数量选择，重选择机制如同以上的bandwidth</td></tr></tbody></table> 
<p>如下函数ad_agg_selection_test所示，子函数__agg_active_ports用于在BOND_AD_COUNT选择模式时，获取aggregator的活动port数量。子函数__get_agg_bandwidth用户子其它两个选择模式时，获取带宽值。</p> 
<pre><code>static struct aggregator *ad_agg_selection_test(struct aggregator *best, struct aggregator *curr)
{
    switch (__get_agg_selection_mode(curr-&gt;lag_ports)) {
    case BOND_AD_COUNT:
        if (__agg_active_ports(curr) &gt; __agg_active_ports(best))
            return curr;
        if (__agg_active_ports(curr) &lt; __agg_active_ports(best))
            return best;

        /*FALLTHROUGH*/
    case BOND_AD_STABLE:
    case BOND_AD_BANDWIDTH:
        if (__get_agg_bandwidth(curr) &gt; __get_agg_bandwidth(best))
            return curr;
</code></pre> 
<p>如下函数ad_agg_selection_logic，对于BOND_AD_STABLE选择模式，如果当前活动的aggregator还有活动的port及应答的partner，或者当前活动的aggregator和刚刚选择的aggregator都没有应答的partner时，仍然使用当前的活动aggregator。</p> 
<pre><code>static void ad_agg_selection_logic(struct aggregator *agg, bool *update_slave_arr)
{
    struct aggregator *best, *active, *origin;

    bond_for_each_slave_rcu(bond, slave, iter) {
        agg = &amp;(SLAVE_AD_INFO(slave)-&gt;aggregator);
        agg-&gt;is_active = 0;
        if (__agg_active_ports(agg) &amp;&amp; agg_device_up(agg))
            best = ad_agg_selection_test(best, agg);
    }
    if (best &amp;&amp; __get_agg_selection_mode(best-&gt;lag_ports) == BOND_AD_STABLE) {

        if (active &amp;&amp; active-&gt;lag_ports &amp;&amp; __agg_active_ports(active) &amp;&amp; (__agg_has_partner(active) ||
             (!__agg_has_partner(active) &amp;&amp; !__agg_has_partner(best)))) {
            if (!(!active-&gt;actor_oper_aggregator_key &amp;&amp; best-&gt;actor_oper_aggregator_key)) {
                best = NULL;
                active-&gt;is_active = 1;
</code></pre> 
<h4><a id="tlb_dynamic_lb_845"></a>tlb_dynamic_lb</h4> 
<p>选项tlb_dynamic_lb决定是否开启动态负载均衡，此选项仅使用在TLB模式。默认值为1，意味着根据负荷情况在从设备之间动态分配流量；如果设置为0，表示根据对报文部分字段的HASH结果选择从设备，参见选项xmit_hash_policy。前者，根据负荷进行的负载均衡，副作用是会引起报文乱序。</p> 
<p>参见以下TLB模式发送函数bond_tlb_xmit，选项tlb_dynamic_lb没有开启时，根据hash值选择发送使用的从设备。相反，使用函数tlb_choose_channel进行选择。</p> 
<pre><code>netdev_tx_t bond_tlb_xmit(struct sk_buff *skb, struct net_device *bond_dev)
{
    struct bonding *bond = netdev_priv(bond_dev);

    if (!is_multicast_ether_addr(eth_data-&gt;h_dest)) {
        switch (skb-&gt;protocol) {
        case htons(ETH_P_IP):
        case htons(ETH_P_IPX):
        case htons(ETH_P_IPV6):
            hash_index = bond_xmit_hash(bond, skb);
            if (bond-&gt;params.tlb_dynamic_lb) {
                tx_slave = tlb_choose_channel(bond, hash_index &amp; 0xFF, skb-&gt;len);
            } else {
                slaves = rcu_dereference(bond-&gt;slave_arr);
                count = slaves ? READ_ONCE(slaves-&gt;count) : 0;
                if (likely(count))
                    tx_slave = slaves-&gt;arr[hash_index % count];
</code></pre> 
<p>如下__tlb_choose_channel函数，如果报文对应的hash值已经有对应的处理设备，使用此设备，否则选取负荷最轻从设备。此函数还负责更新每个hash值所对应的发送报文数量。</p> 
<pre><code>static struct slave *__tlb_choose_channel(struct bonding *bond, u32 hash_index, u32 skb_len)
{  
    struct alb_bond_info *bond_info = &amp;(BOND_ALB_INFO(bond));
    struct tlb_client_info *hash_table;

    hash_table = bond_info-&gt;tx_hashtbl;
    assigned_slave = hash_table[hash_index].tx_slave;
    if (!assigned_slave) { 
        assigned_slave = tlb_get_least_loaded_slave(bond);
        if (assigned_slave) {
            struct tlb_slave_info *slave_info = &amp;(SLAVE_TLB_INFO(assigned_slave));
            u32 next_index = slave_info-&gt;head;

            hash_table[hash_index].tx_slave = assigned_slave;
            hash_table[hash_index].next = next_index;
            hash_table[hash_index].prev = TLB_NULL_INDEX;

            if (next_index != TLB_NULL_INDEX) hash_table[next_index].prev = hash_index;
            slave_info-&gt;head = hash_index;
            slave_info-&gt;load += hash_table[hash_index].load_history;
        }      
    }
    if (assigned_slave)  hash_table[hash_index].tx_bytes += skb_len;
</code></pre> 
<h4><a id="numtxqueuesnumrxqueues_907"></a>numtxqueues和numrxqueues</h4> 
<p>函数bond_get_num_tx_queues获取bond系统默认的发送队列数值，为BOND_DEFAULT_TX_QUEUES（16），并且接收队列的数值与发送相同，也是16，由以上的两个选项（numtxqueues/numrxqueues）可见。</p> 
<pre><code>struct net_device *rtnl_create_link(struct net *net, const char *ifname, unsigned char name_assign_type,
                    const struct rtnl_link_ops *ops, struct nlattr *tb[], struct netlink_ext_ack *extack)
{
    if (tb[IFLA_NUM_TX_QUEUES])
        num_tx_queues = nla_get_u32(tb[IFLA_NUM_TX_QUEUES]);
    else if (ops-&gt;get_num_tx_queues)
        num_tx_queues = ops-&gt;get_num_tx_queues();

    if (tb[IFLA_NUM_RX_QUEUES])
        num_rx_queues = nla_get_u32(tb[IFLA_NUM_RX_QUEUES]);
    else if (ops-&gt;get_num_rx_queues)
        num_rx_queues = ops-&gt;get_num_rx_queues();
</code></pre> 
<h4><a id="gso_max_sizegso_max_segs_932"></a>gso_max_size和gso_max_segs选项</h4> 
<p>选项gso_max_size和gso_max_segs定义了对于bond接口GSO最大的长度和数量，选项gso_max_size默认值为GSO_MAX_SIZE（65536）；选项gso_max_segs的默认值为GSO_MAX_SEGS（65535）。如下函数bond_compute_features所示，其在从设备加入和删除时调用，计算bond接口的GSO相关数值，取所有从设备中最小的值。</p> 
<pre><code>static void bond_compute_features(struct bonding *bond)
{
    struct net_device *bond_dev = bond-&gt;dev;
    unsigned int gso_max_size = GSO_MAX_SIZE;
    u16 gso_max_segs = GSO_MAX_SEGS;

    bond_for_each_slave(bond, slave, iter) {
        ...
        gso_max_size = min(gso_max_size, slave-&gt;dev-&gt;gso_max_size);
        gso_max_segs = min(gso_max_segs, slave-&gt;dev-&gt;gso_max_segs);
    }
    bond_dev-&gt;hard_header_len = max_hard_header_len;
done:
    bond_dev-&gt;gso_max_segs = gso_max_segs;
    netif_set_gso_max_size(bond_dev, gso_max_size);
</code></pre> 
<h4><a id="ad_user_port_key_958"></a>选项ad_user_port_key</h4> 
<p>此选项仅用于802.3ad模式，定义端口key值的高10位，即[6, 15]，默认情况下为0。</p> 
<pre><code>   --------------------------------------------------------------
   | User key (10 bits)           | Speed (5 bits)      | Duplex|
   --------------------------------------------------------------
   |15                           6|5                   1|0
</code></pre> 
<p>在如下函数bond_3ad_bind_slave中，端口初始化时，先行将端口key值的[6,15]位赋为选项ad_user_port_key的值，之后在添加接口速率和双工值。</p> 
<pre><code>void bond_3ad_bind_slave(struct slave *slave)
{
    struct bonding *bond = bond_get_bond_by_slave(slave);
    struct port *port;

    if (SLAVE_AD_INFO(slave)-&gt;port.slave != slave) {
        port = &amp;(SLAVE_AD_INFO(slave)-&gt;port);
        ...
        /* key is determined according to the link speed, duplex and
         * user key
         */
        port-&gt;actor_admin_port_key = bond-&gt;params.ad_user_port_key &lt;&lt; 6;
</code></pre> 
<p>内核版本 5.0</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a9cea79735772652089e298008eefe9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【VScode】C语言环境配置填坑 | 报错：no iconv implementation | unrecognized command line option “-std=c&#43;&#43;11</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3eef327428dd8eb0a935cc0d8c826d26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">淘宝双11大数据分析（Hive 分析篇-上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>