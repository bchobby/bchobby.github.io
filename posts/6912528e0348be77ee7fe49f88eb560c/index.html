<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】树 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】树" />
<meta property="og:description" content="一.二叉树的基本概念和性质： 1.二叉树的递归定义： 二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成
2.二叉树的特点： （1）每个结点最多只有两棵子树，即不存在结点度大于2的结点
（2）子树有左右之分，不能颠倒。
3.满二叉树： 深度为k，且有个结点的二叉树。
（1）每一层上结点数都达到最大。
（2）度为1的结点数
4.完全二叉树： 深度为k，结点数为n的二叉树，当且仅当每个结点的编号都与相同深度的满二叉树中从1到n的结点一一对应时，称为完全二叉树。
（1）完全二叉树的任意结点，左子树的高度-右子树的高度=0或1
5.二叉树的性质： 1）在二叉树的第i层，至多有个结点。
2）深度为k的二叉树上至多含有个结点。
3) 证明如下：
二叉树中全部结点数
除根结点外，每个结点必有一个直接前驱，即一个分支
（1度结点必有1个直接后继，2度结点必有2个直接后继）
即：
叶子数=2度结点数&#43;1
4）具有n个结点的完全二叉树的深度为
5)
对有n个结点的完全二叉树的结点按层序编号，则对于任一结点i，有：
如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是i/2如果2i&gt;n，则结点i无左孩子；如果，则其左孩子是2i如果2i&#43;1&gt;n，则结点i无右孩子；如果，则其右孩子是2i&#43;1 例题：
设一棵完全二叉树具有1000个结点，则它有489个叶子结点，有488个度为2的结点，有1个结点只有非空左子树，有0个结点只有非空右子树。
二.二叉树、树以及森林的存储结构 1.二叉树的顺序存储结构 用一组地址连续的存储单元，以层序顺序存放二叉树的数据元素，结点的相对位置蕴含着结点之间的关系。
问：顺序存储后能否复原成唯一对应的二叉树形状？
若是完全二叉树则可以完全复原，下标值为i的双亲，左孩子为2i，右孩子为2i&#43;1。
而对于一般的二叉树的存储，将其先补成完全二叉树，然后按照完全二叉树的顺序存储方式进行存储，而新补上的结点只占位置，不存放数据元素。
对于一般二叉树的顺序存储，如果是斜树，则会浪费很多的存储空间，而且插入删除不便。
2.二叉树的链式存储结构 有一个指向根的指针root
二叉链表：2个链分别存放左孩子和右孩子。
三叉链表：2个链分别存放左孩子和右孩子另外一个指向双亲。
线索链表：用空链域存放前驱或后继。
2.1 二叉链表： 结点结构：
lchilddatarchild typedef struct BiTreeNode{ DataType data; struct BiTreeNode *lchild,*rchild; }BiTreeNode,*BiTree; 2.2 三叉链表： 结点结构：
parentlchilddatarchild typedef struct BiTreeNode{ DataType data; struct BiTreeNode *lchild,*rchild,*parent; }BiTreeNode,*BiTree; 3.树和森林的存储结构 3.1 树的双亲表示法 对于一个结点来说，双亲是一定的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/6912528e0348be77ee7fe49f88eb560c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T18:40:15+08:00" />
<meta property="article:modified_time" content="2023-12-27T18:40:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.二叉树的基本概念和性质：</h2> 
<h3>1.二叉树的递归定义：</h3> 
<p>二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成</p> 
<h3>2.二叉树的特点：</h3> 
<p>（1）每个结点最多只有两棵子树，即不存在结点度大于2的结点</p> 
<p>（2）子树有左右之分，不能颠倒。</p> 
<h3>3.满二叉树：</h3> 
<p>深度为k，且有<img alt="2^k-1" class="mathcode" src="https://images2.imgbox.com/f3/91/2AiqQoaK_o.png">个结点的二叉树。</p> 
<p>（1）每一层上结点数都达到最大。</p> 
<p>（2）度为1的结点数<img alt="n_1=0" class="mathcode" src="https://images2.imgbox.com/f7/55/qaXZFjhW_o.png"></p> 
<h3>4.完全二叉树：</h3> 
<p>深度为k，结点数为n的二叉树，当且仅当每个结点的编号都与相同深度的满二叉树中从1到n的结点一一对应时，称为完全二叉树。</p> 
<p>（1）完全二叉树的任意结点，左子树的高度-右子树的高度=0或1</p> 
<h3>5.二叉树的性质：</h3> 
<p>1）在二叉树的第i层，至多有<img alt="2^{i-1}" class="mathcode" src="https://images2.imgbox.com/3d/29/C50lz0H4_o.png">个结点。</p> 
<p>2）深度为k的二叉树上至多含有<img alt="2^k-1" class="mathcode" src="https://images2.imgbox.com/bf/63/e9K9D4Hc_o.png">个结点。</p> 
<p>3)  <img alt="n_0=n_2+1" class="mathcode" src="https://images2.imgbox.com/18/55/PAtO96uy_o.png"></p> 
<blockquote> 
 <p>证明如下：</p> 
 <p>二叉树中全部结点数<img alt="n=n_0+n_1+n_2" class="mathcode" src="https://images2.imgbox.com/1e/d0/QCtQ5VPW_o.png"></p> 
 <p>除根结点外，每个结点必有一个直接前驱，即一个分支</p> 
 <p><img alt="n=B+1" class="mathcode" src="https://images2.imgbox.com/49/b2/3EgxM1fD_o.png"></p> 
 <p><img alt="B=n_1+2n_2" class="mathcode" src="https://images2.imgbox.com/20/cd/NlODDIwO_o.png">（1度结点必有1个直接后继，2度结点必有2个直接后继）</p> 
 <p><img alt="n_0+n_1+n_2=n_1+2n_2+1" class="mathcode" src="https://images2.imgbox.com/22/f9/MdufMaz0_o.png"></p> 
 <p>即：</p> 
 <p><img alt="n_0=n_2+1" class="mathcode" src="https://images2.imgbox.com/ee/93/nG7m91dE_o.png"></p> 
 <p>叶子数=2度结点数+1</p> 
</blockquote> 
<p>4）具有n个结点的完全二叉树的深度为<img alt="\lfloor log_2n\rfloor +1" class="mathcode" src="https://images2.imgbox.com/fd/8e/725LHOvr_o.png"></p> 
<p></p> 
<p>5)</p> 
<p>对有n个结点的完全二叉树的结点按层序编号，则对于任一结点i，有：</p> 
<blockquote> 
 <ul><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是i/2</li><li>如果2i&gt;n，则结点i无左孩子；如果<img alt="2i\leq n" class="mathcode" src="https://images2.imgbox.com/ae/ed/aoeL2F49_o.png">，则其左孩子是2i</li><li>如果2i+1&gt;n，则结点i无右孩子；如果<img alt="2i+1\leq n" class="mathcode" src="https://images2.imgbox.com/dd/60/8fpaInkm_o.png">，则其右孩子是2i+1</li></ul> 
</blockquote> 
<p>例题：</p> 
<p>设一棵完全二叉树具有1000个结点，则它有489个叶子结点，有488个度为2的结点，有1个结点只有非空左子树，有0个结点只有非空右子树。</p> 
<p></p> 
<h2>二.二叉树、树以及森林的存储结构</h2> 
<h3>1.二叉树的顺序存储结构</h3> 
<p>        用一组地址连续的存储单元，以<strong>层序顺序</strong>存放二叉树的数据元素，结点的<strong>相对位置</strong>蕴含着结点之间的关系。</p> 
<p></p> 
<p>问：顺序存储后能否复原成唯一对应的二叉树形状？</p> 
<p>若是<strong>完全二叉树则可以完全复原</strong>，下标值为i的双亲，左孩子为2i，右孩子为2i+1。</p> 
<p></p> 
<p>        而对于一般的二叉树的存储，将其先<strong>补成完全二叉树</strong>，然后按照完全二叉树的顺序存储方式进行存储，而新补上的结点只占位置，不存放数据元素。</p> 
<p></p> 
<p>对于一般二叉树的顺序存储，如果是斜树，则会浪费很多的存储空间，而且插入删除不便。</p> 
<p></p> 
<h3>2.二叉树的链式存储结构</h3> 
<p>有一个指向根的指针root</p> 
<blockquote> 
 <p><strong>二叉链表</strong>：2个链分别存放左孩子和右孩子。</p> 
 <p><strong>三叉链表</strong>：2个链分别存放左孩子和右孩子另外一个指向双亲。</p> 
 <p><strong>线索链表</strong>：用空链域存放前驱或后继。</p> 
</blockquote> 
<h4>2.1 二叉链表：</h4> 
<p>结点结构：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>lchild</td><td>data</td><td>rchild</td></tr></tbody></table> 
<pre><code class="language-cpp">typedef struct BiTreeNode{
    DataType data;
    struct BiTreeNode *lchild,*rchild;
}BiTreeNode,*BiTree;</code></pre> 
<h4> 2.2 三叉链表：</h4> 
<p>结点结构：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>parent</td><td>lchild</td><td>data</td><td>rchild</td></tr></tbody></table> 
<pre><code class="language-cpp">typedef struct BiTreeNode{
    DataType data;
    struct BiTreeNode *lchild,*rchild,*parent;
}BiTreeNode,*BiTree;</code></pre> 
<h3> 3.树和森林的存储结构</h3> 
<h4>3.1 树的双亲表示法</h4> 
<p>对于一个结点来说，双亲是一定的。</p> 
<pre><code class="language-cpp">typedef struct PTNode{
    DataType data;
    int parent;
}PTNode;
typedef struct PTree{
    PTNode nodes[MAX_SIZE];
    int r,n;
}PTree;</code></pre> 
<h4>3.2 树的孩子表示法</h4> 
<p>对于一个结点来说，孩子的数量是不一定的，为了整体元素结构的一致性，采用存储地址的方法。</p> 
<pre><code class="language-cpp">typedef struct CTNode{
    int child;
    struct CTNode *next;
}CTNode;

typedef struct CTBox{
    DataType data;
    CTNode *firstchild;
}CTBox;
typedef struct CTree{
    CTBox nodes[MAX_SIZE];
    int n,r;
}CTree;</code></pre> 
<h4>3.3 树的双亲孩子表示法</h4> 
<p>结点结构变为</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>data</td><td>parent（下标）</td><td>指向第一个孩子的指针</td></tr></tbody></table> 
<h4>3.4 树的孩子兄弟表示法</h4> 
<pre><code class="language-cpp">typedef struct CSNode{
    datatype data;
    struct CSNode *firstchild,*rightsib;
}CSNode;</code></pre> 
<p></p> 
<h2>三.二叉树、树及森林的基本操作</h2> 
<h3>1.二叉树的遍历</h3> 
<p>顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，且仅被访问一次。</p> 
<h4>1.1 先序遍历：</h4> 
<p>根、左、右。</p> 
<blockquote> 
 <p>若二叉树非空，则：</p> 
 <p>1）访问根结点</p> 
 <p>2）先序遍历左子树</p> 
 <p>3）先序遍历右子树</p> 
</blockquote> 
<pre><code class="language-cpp">typedef struct BiNode{
    int data;
    struct BiNode *rchild,*lchild;
}BiNode;
void preOrder(BiNode *root){
    if(root){
        cout&lt;&lt;root-&gt;data;
        preOrder(root-&gt;lchild);
        preOrder(root-&gt;rchild);
    }
}</code></pre> 
<p></p> 
<h4>1.2 中序遍历：</h4> 
<p>左、根、右。</p> 
<blockquote> 
 <p>若二叉树非空，则：</p> 
 <p>1）中序遍历左子树</p> 
 <p>2）访问根结点</p> 
 <p>3）中序遍历右子树</p> 
</blockquote> 
<pre><code class="language-cpp">void inOrder(BiNode *root){
    if(root){
        inOrder(root-&gt;lchild);
        cout&lt;&lt;root-&gt;data;
        inOrder(root-&gt;rchild);
    }
}</code></pre> 
<p> <strong>中序遍历的非递归算法：</strong></p> 
<blockquote> 
 <p>1.初始化栈，将根结点入栈。</p> 
 <p>2.如果栈空则结束（空树或所有结点处理完毕），否则进入下一步。</p> 
 <p>3.p指向栈顶元素，如果p不空，则左孩子入栈，直到左孩子为空。</p> 
 <p>4.如果栈不空，则出栈，输出该结点，再将其右孩子入栈。以该结点为本子树的根，转步骤2继续。</p> 
</blockquote> 
<pre><code class="language-cpp">void InOrder(BiNode *root){
    stack &lt;BiNode*&gt; s;
    BiNode* p=root;
    s.push(p);
    while(!s.empty()){
        while(p-&gt;lchild){//走到最左边
            p=p-&gt;lchild;
            s.push(p);
        }
        p=s.top();//弹栈
        s.pop();
        cout&lt;&lt;p-&gt;data;
        if(p-&gt;rchild){
            s.push(p-&gt;rchild);
        }
    }
}</code></pre> 
<p></p> 
<h4>1.3 后序遍历：</h4> 
<p>左、右、根。</p> 
<blockquote> 
 <p>若二叉树非空，则：</p> 
 <p>1）后序遍历左子树</p> 
 <p>2）后序遍历右子树</p> 
 <p>3）访问根结点</p> 
</blockquote> 
<pre><code class="language-cpp">void postOrder(BiNode *root){
    if(root){
        postOrder(root-&gt;lchild);
        postOrder(root-&gt;rchild);
        cout&lt;&lt;root-&gt;data;
    }
}</code></pre> 
<p></p> 
<h4>1.4 层次遍历：</h4> 
<p>从上到下、从左到右。</p> 
<p>初始化队列，根结点入队列。</p> 
<p>如果队列不空，则出队列并访问该结点；该结点左孩子入队，右孩子入队；如果队列为空，则层次遍历结束。</p> 
<pre><code class="language-cpp">void levelOrder(BiNode *root){
    queue &lt;BiNode*&gt; s;
    BiNode* p=root;
    s.push(p);
    while(!s.empty()){
        p=s.front();
        s.pop();
        cout&lt;&lt;p-&gt;data;
        if(p-&gt;lchild){
            s.push(p-&gt;lchild);
        }
        if(p-&gt;rchild){
            s.push(p-&gt;rchild);
        }
    }
}</code></pre> 
<p></p> 
<h4>1.5 对遍历的分析：</h4> 
<p>从前面的三种遍历算法可以知道，如果将输出语句抹掉，从递归的角度看，这三种算法是完全相同的，或者说这三种遍历算法的<strong>访问路径是相同</strong>的，只是<strong>访问结点的时机不同</strong>。</p> 
<p>从虚线的出发点到终点的路径上，每个结点经过三次。</p> 
<blockquote> 
 <ul><li>第一次经过时访问=先序遍历</li><li>第二次经过时访问=中序遍历</li><li>第三次经过时访问=后序遍历</li></ul> 
</blockquote> 
<h4>1.6 二叉树遍历算法的应用举例：</h4> 
<h5>1.6.1 表达式树：</h5> 
<p>算数表达式可以表示为一棵二叉树 中缀表达——对树进行中序遍历即可得到表达式。</p> 
<blockquote> 
 <ul><li>前缀表达式：不含括号的算数表达式，将运算符写在前面，操作数写在后面。</li><li>中缀表达式：操作符以中缀形式处于操作数中间。</li><li>后缀表达式：不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格的从左到右进行（不再考虑运算符的优先次序）</li></ul> 
</blockquote> 
<p><strong>表达式树的构建</strong>：（即：给出一个中序序列，构建出这棵树）</p> 
<p>顺序扫描中缀表达式 明确：左子树的优先级高</p> 
<ul><li>当扫描到的是运算数：先检查当前的表达式树是否存在。如果不存在，则表示扫描到的是第一个运算数，将它作为树根。如果树存在，则将此运算数作为前一运算符的右孩子。</li><li>如果扫描到的是+或-：将它作为根结点，原来的树作为它的左子树。</li><li>如果扫描到的是*或/：<strong>则与根结点进行比较</strong>。如果根节点也是*或/，则根结点应该先执行，于是，将当前的运算符作为根结点，原来的树作为左子树。如果根结点是+或-，则当前运算符应该先运算，于是将它作为右子树的根，原来的右子树作为它的左子树。</li></ul> 
<p>在遇到运算数时，如何知道它前面的运算符是谁？这只需要判别根结点有没有右孩子。如果没有右孩子，则运算数是根节点的右运算数，否则就是根结点右孩子的右运算数。</p> 
<p></p> 
<h5>1.6.2 由先序和中序遍历序列建立二叉树：</h5> 
<p>可以唯一的确定一棵二叉树。</p> 
<pre><code class="language-cpp">void PreInorder(char preorder[],char inorder[],int first1,int end1,int first2,int end2,BiNode *t){
    //先序序列从first1到end1，中序序列从first2到end2，建立一棵二叉树放在t中
    int m;
    t=new BiNode;
    t-&gt;data=preorder[first1];//二叉树的根
    m=first2;
    while(inorder[m]!=preorder[first1]){//在中序序列中定位根结点的位置
        ++m;
    }
    //建立左子树
    if(m==first2){//左子树为空
        t-&gt;lchild=NULL;
    }
    else{
        PreInorder(preorder, inorder, first1+1, first1+m-first2, first2, m-1, t-&gt;lchild);
    }
    //建立右子树
    if(m==end2){//右子树为空
        t-&gt;lchild=NULL;
    }
    else{
        PreInorder(preorder, inorder, first1+m+1-first2, end1, m+1, end2, t-&gt;rchild);
    }
}
void CreateBiTree(char preorder[],char inorder[],int n,BiNode *root){
    if(n&lt;=0){
        root=NULL;
    }
    else{
        PreInorder(preorder, inorder, 0, n-1, 0, n-1, root);
    }
}</code></pre> 
<h5>1.6.3 二叉树中叶子结点的统计：</h5> 
<p>先序（中序或后序）遍历二叉树，在遍历过程中查找叶子节点，将算法中“访问结点”的操作改为：判定是否为叶子结点。</p> 
<p>叶子结点：左右孩子均为空。</p> 
<h5>1.6.4 二叉树的深度：</h5> 
<p>空树：深度=0；</p> 
<p>左右子树为空：深度=1；</p> 
<p>其他：深度等于1+max（左子树深度，右子树深度）</p> 
<pre><code class="language-cpp">int get_depth(BiNode *t){
    if(t==NULL){
        return 0;
    }
    else if(t-&gt;lchild==NULL&amp;&amp;t-&gt;rchild==NULL){
        return 1;
    }
    else{
        int depth;
        int depth1=get_depth(t-&gt;lchild);
        int depth2=get_depth(t-&gt;rchild);
        depth=max(depth1,depth2);
        return depth;
    }
}</code></pre> 
<h3> 2.树和森林的基本操作</h3> 
<h4>2.1 树以及森林和二叉树的相互转换</h4> 
<p><strong>1）树-&gt;二叉树</strong></p> 
<blockquote> 
 <p>兄弟加线，每一个结点只保留与第一个孩子的连线，再进行旋转。</p> 
 <p>树转换成的二叉树，其根结点的右子树一定为空。</p> 
 <p>想要有右子树，就必须要有兄弟。将兄弟作为右子树。</p> 
</blockquote> 
<p><strong>2）二叉树-&gt;树</strong></p> 
<blockquote> 
 <p>结点与其右子树、右子树的右子树加线，去掉结点与右子树的连线，再进行旋转。</p> 
</blockquote> 
<p><strong>3）森林-&gt;二叉树</strong></p> 
<blockquote> 
 <p>将森林中的每一棵树都先转化为二叉树，再令第i棵树作为第i-1棵树的右子树。 </p> 
</blockquote> 
<p><strong>4）二叉树-&gt;森林</strong></p> 
<blockquote> 
 <p>断开根结点与右子树的关系，再将右子树作为新树，依次断开根结点与右子树的关系，直至右子树为空，得到了多棵二叉树。</p> 
 <p>再将这些二叉树转化为树。</p> 
</blockquote> 
<h4>2.2 树的遍历</h4> 
<ul><li>先序遍历</li><li>后序遍历</li><li>层次遍历 </li></ul> 
<p>没有中序遍历是因为树不分左右子树</p> 
<h4>2.3 森林的遍历</h4> 
<ul><li>先序遍历：先序遍历每一棵树</li><li>中序遍历：后序遍历每一棵树</li></ul> 
<p></p> 
<h2>四.二叉树的变形</h2> 
<h3>1.二叉排序树（BST）</h3> 
<p><span style="color:#fe2c24;"><strong>对于二叉排序树的插入和删除操作：我们需要改变指针指向的地址，而在函数中传递指针，只能够改变指针指向的内容，所以要传递指针的引用。</strong></span></p> 
<h4>1.1 定义（具有递归性质）：</h4> 
<p>二叉排序树或是一颗空树，或是一棵具有以下性质的树</p> 
<p>（1）若它的左子树不空，则它左子树上所有结点的值均小于根结点的值。</p> 
<p>（2）若它的右子树不空，则它右子树上所有结点的值均大于根结点的值。</p> 
<p>（3）它的左右子树都是二叉排序树</p> 
<h4>1.2 二叉排序树的查找：</h4> 
<p>在二叉排序树中查找给定k值的过程是：</p> 
<blockquote> 
 <p>1）若root是空树，则查找失败</p> 
 <p>2）若k=root-&gt;data,则查找成功，否则</p> 
 <p>3）若k&lt;root-&gt;data，则在root的左子树上查找；否则</p> 
 <p>4）在root的右子树上查找。</p> 
</blockquote> 
<p>上述过程一直持续到k被找到或者待查找的子树为空。如果待查找的子树为空，则查找失败。</p> 
<p>只需要查找两个子树之一。</p> 
<pre><code class="language-cpp">BiNode* search(BiNode *root,int key){
    if(root==NULL){
        return NULL;
    }
    else{
        while(key!=root-&gt;data){
            if(key&gt;root-&gt;data){
                root=root-&gt;rchild;
            }
            else if(key&lt;root-&gt;data){
                root=root-&gt;lchild;
            }
            else{
                break;
            }
        }
               return root;
    }
}</code></pre> 
<h4>1.3 二叉排序树的插入：</h4> 
<p>若二叉排序树为空树，则新插入的结点为新的根结点；否则新插入的结点必为一个新的<a href="https://so.csdn.net/so/search?q=%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9&amp;spm=1001.2101.3001.7020" title="叶子结点">叶子结点</a>，其插入位置由查找过程得到。</p> 
<pre><code class="language-cpp">void insert(BiNode *&amp;root,int key){
    BiNode *p;
    if(root==NULL){
        p=new BiNode;
        p-&gt;data=key;
        p-&gt;lchild=NULL;
        p-&gt;rchild=NULL;
    }
    else{
        if(key&lt;root-&gt;data){
            insert(root-&gt;lchild, key);
        }
        else{
            insert(root-&gt;rchild,key);
        }
    }
}</code></pre> 
<p>二叉排序树的构造：</p> 
<pre><code class="language-cpp">BiSortTree::BiSortTree(int array[],int n){
    root=NULL;
    for(int i=0;i&lt;n;i++){
        insertBST(root, array[i]);
    }
}</code></pre> 
<blockquote> 
 <p></p> 
 <p>二叉排序树构造算法总结：<br> 1）一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列</p> 
 <p>2）每次插入的新结点都是二叉排序树上新的叶子结点</p> 
 <p>3）找到插入位置后，不必移动其它结点，仅需修改某个结点的指针</p> 
 <p>4）在左子树/右子树的查找过程与在整棵树上查找过程相同</p> 
 <p>5）新插入的结点没有破坏原有结点之间的关系<br>  </p> 
</blockquote> 
<blockquote> 
 <p>注：</p> 
 <p>此处函数参数为指针的引用类型</p> 
 <p>1）只传指针的话，只能改变指针最初的指向的内容，而不能够改变指针所指向的地址。</p> 
 <p>2）而采用指针的引用，实际上改变指针，就改变了指针指向的地址。</p> 
 <p>3）这样做，还能够直接链接起根结点和孩子之间的指针关系。（bt-&gt;lchild/rchild 就被赋值为下一级函数所开辟出空间的地址） </p> 
</blockquote> 
<h4>1.4 二叉排序树的删除：</h4> 
<p>在二叉排序树上删除某个结点之后，仍然保持二叉排序树的特性。</p> 
<blockquote> 
 <p>1）被删除的结点是叶子</p> 
 <p>删除该结点，并将该结点的双亲的孩子指针域赋值为空</p> 
 <p>2）被删除的结点只有左子树或只有右子树</p> 
 <p>将双亲结点相应的指针域的值指向被删除结点的左/右孩子</p> 
 <p>3）被删除的结点既有左子树，又有右子树</p> 
 <p>以其左子树的最大值或右子树的最小值来代替该结点</p> 
 <p>以其前驱替代，然后再删除前驱结点</p> 
</blockquote> 
<pre><code class="language-cpp">void deleteNode(BiNode *&amp;bt){
    BiNode *p=bt;
    if(bt-&gt;lchild==NULL&amp;&amp;bt-&gt;rchild==NULL){//叶子结点
        bt=NULL;//该结点的双亲结点的相应孩子指针被赋值为空
        delete p;//返回时，其双亲的左右孩子指针均被赋值为NULL
    }
    if(bt-&gt;lchild==NULL){//该结点的左孩子为空，只有右子树
        bt=bt-&gt;rchild;
        delete p;
    }
    if(bt-&gt;rchild==NULL){//该结点的右孩子为空，只有左子树
        bt=bt-&gt;lchild;
        delete p;
    }
    else{//左右子树均存在，选取其前驱作为新的根结点
        BiNode *parent=bt,*pre=bt-&gt;lchild;
        while(pre-&gt;rchild){//找到左子树值最大的结点，parent保存这个结点的双亲结点
            parent=pre;
            pre=pre-&gt;rchild;
        }
        bt-&gt;data=pre-&gt;data;//用该结点的直接前驱替代该结点，并删除该结点的直接前驱
        if(parent==bt){
            parent-&gt;lchild=pre-&gt;lchild;
        }
        else{
            parent-&gt;rchild=NULL;
        }
        delete pre;
    }
}</code></pre> 
<p>二叉排序树的性能取决于<strong>二叉树的形状 </strong></p> 
<h3>2.平衡二叉树 </h3> 
<h4>2.1 定义：</h4> 
<p>平衡二叉树或者是一颗空树，或者是具有下列性质的二叉树：</p> 
<blockquote> 
 <ul><li>是一棵二叉排序树</li><li>并且任何结点的<strong>左右子树的深度之差不超过1</strong></li></ul> 
</blockquote> 
<h4>2.2 构造平衡二叉树：</h4> 
<p></p> 
<p>在插入过程中，采用<strong>平衡旋转技术</strong>。</p> 
<h5>1）平衡因子BF（Balance Factor）：</h5> 
<p>左子树高度 - 右子树高度的值</p> 
<p>平衡因子的绝对值大于1，就需要进行调整。</p> 
<h5>2）最小不平衡子树：</h5> 
<p>距离插入结点最近的，且BF的绝对值大于1的结点。</p> 
<p>旋转只需要纠正最小不平衡子树即可。</p> 
<h5>3）右旋：</h5> 
<blockquote> 
 <ul><li>旧根结点为新根结点的右子树</li><li>新根结点的右子树（如果存在）为旧根结点的左子树</li></ul> 
</blockquote> 
<h5>4）左旋：</h5> 
<blockquote> 
 <ul><li>旧根结点为新根结点的左子树</li><li>新根结点的左子树（如果存在）为旧根结点的右子树</li></ul> 
</blockquote> 
<p></p> 
<h4>2.3 四种类型的旋转</h4> 
<blockquote> 
 <p>1）LL型</p> 
 <p>2）RR型</p> 
 <p>3）LR型</p> 
 <p><strong><span style="color:#fe2c24;">最小不平衡子树根结点左子树先左旋，最小不平衡子树再右旋</span></strong></p> 
 <p>4）RL型</p> 
 <p><strong><span style="color:#fe2c24;">最小不平衡子树根结点右子树先右旋，最小不平衡子树再左旋</span></strong></p> 
</blockquote> 
<h3> 3.最优树——哈夫曼树</h3> 
<h4>3.1哈夫曼编码</h4> 
<p>1）前缀码：</p> 
<p>对每一个字符规定一个0，1串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀。</p> 
<p>2）前缀码的平均码长：</p> 
<p>每个字符频率乘以该字符编码的bit数之和。</p> 
<p>3）最优前缀码：</p> 
<p>寻找最小的前缀码的平均码长。</p> 
<p>4）最优树：</p> 
<p>称树的带权路径长度最短的一类树为“最优树”。</p> 
<h4>3.2 哈夫曼树的构造</h4> 
<blockquote> 
 <p>（1）初始化：<br> 由给定的 n个权值构造n棵只有一个根结点的二叉树，从而得到一个二叉树集合。</p> 
 <p>（2）选取与合并：<br> 在二叉树集合中选取根结点的权值最小的两颗二叉树分别作为左、右子树构造一颗新的二叉树，这颗新的二叉树的根结点的权值为其左、右子树根结点的权值之和。</p> 
 <p>（3）删除与加入<br> 在二叉树集合中删去作为左、右子树的二叉树，并将新建立的二叉树加入到二叉树结合中。</p> 
 <p>（4）重复<br> 重复（2）（3）两步，直到二叉树集合中只剩下一颗二叉树。</p> 
</blockquote> 
<p></p> 
<p>哈夫曼树的左右子树可以进行交换。</p> 
<p>有n个叶子结点的哈夫曼树有2n-1个结点。<br>  </p> 
<h4>3.3 哈夫曼算法的实现：</h4> 
<p><strong>1）存储结构：</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>weight</td><td>lchild</td><td>rchild</td><td>parent</td></tr></tbody></table> 
<p> 由于有n个叶子结点的哈夫曼树有2n-1个结点，设置数组长度为2n-1。</p> 
<p><strong>2）伪代码：</strong></p> 
<blockquote> 
 <p><strong>1.数组huffTree初始化：</strong></p> 
 <p>所有元素结点的双亲、左右孩子都置为-1.</p> 
 <p><strong>2.权值给定：</strong></p> 
 <p>数组huffTree的前n个元素的权值给定</p> 
 <p><strong>3.进行n-1次合并：</strong></p> 
 <p>3.1 在二叉树集合中选取两个权值最小的根结点，其下标为i1，i2</p> 
 <p>3.2 将二叉树i1，i2合并为一棵新的二叉树</p> 
</blockquote> 
<pre><code class="language-cpp">struct element{
    int weight;
    int lchild,rchild,parent;
};
void select(struct element huffTree[],int k,int &amp;i1,int &amp;i2){
    for(int i=0;i&lt;k;i++){//初始化i1，i2
        if(huffTree[i].parent==-1){
            i1=i2=i;
            break;
        }
    }
    for(int i=0;i&lt;k;i++){
        if(huffTree[i].parent==-1&amp;&amp;huffTree[i].weight&lt;huffTree[i1].weight){
            i1=i;
        }
    }
    for(int i=0;i&lt;k;i++){
        if(huffTree[i].parent==-1&amp;&amp;i!=i1&amp;&amp;huffTree[i].weight&lt;huffTree[i2].weight){
            i2=i;
        }
    }
}
void huffmanTree(struct element huffTree[],int w[],int n){
    int i1,i2,i;
    for(i=0;i&lt;2*n-1;i++){
        huffTree[i].parent=huffTree[i].lchild=huffTree[i].rchild=-1;
    }
    for(i=0;i&lt;n;i++){
        huffTree[i].weight=w[i];
    }
    for(i=n;i&lt;2*n-1;i++){
        select(huffTree, i, i1, i2);
        huffTree[i].weight=huffTree[i1].weight+huffTree[i2].weight;
        huffTree[i1].parent=i;
        huffTree[i2].parent=i;
        huffTree[i].lchild=i1;
        huffTree[i].rchild=i2;
    }
}</code></pre> 
<h3>4.堆排序</h3> 
<h4 style="background-color:transparent;"> 4.1 堆的定义：</h4> 
<p>堆通常是<strong><span style="color:#fe2c24;">一个可以被看作一棵<a href="https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&amp;spm=1001.2101.3001.7020" title="完全二叉树">完全二叉树</a>的数组对象</span></strong>。</p> 
<p>每个结点的值都小于或等于其左右孩子结点的值（称为<a href="https://so.csdn.net/so/search?q=%E5%B0%8F%E6%A0%B9%E5%A0%86&amp;spm=1001.2101.3001.7020" title="小根堆">小根堆</a>）</p> 
<p>或每个结点的值都大于或等于其左右孩子结点的值（称为大根堆）</p> 
<p>特点：</p> 
<p>1.大根堆的根结点是所有结点中值最大的结点。</p> 
<p>2.较大结点靠近根节点，但不绝对。</p> 
<p>3.每次创建一个堆，都使数据基本有序。</p> 
<p></p> 
<h4>4.2 堆排序的思想：</h4> 
<p>首先，将待排序的记录序列构造成一个堆（大根堆），此时，选出了堆中所有记录的最大者，然后将它从堆中移走，并将剩余的记录再调整成堆，这样，又找出了次大的记录，以此类推，直到堆中只有一个记录。</p> 
<p></p> 
<h4>4.3 堆的存储：</h4> 
<p>将堆用顺序结构存储，则堆就对应了一组序列。</p> 
<p>根据完全二叉树的性质：</p> 
<p>结点i的双亲结点编号为i/2，左孩子为2i，右孩子为2i+1</p> 
<p></p> 
<h4 style="background-color:transparent;">4.4 堆调整：</h4> 
<p>在一棵完全二叉树中，根结点的左右子树均是堆，<strong><span style="color:#fe2c24;">如何调整根结点</span></strong>，使整个完全二叉树成为一个堆？</p> 
<p>建立堆，从下向上调整；调整堆时，从上向下处理。</p> 
<p>首先，根和他两个孩子中较大的那个比较，如果根比较大，不做处理；如果根比较小，则交换，交换后，再去看交换的结果是否影响下面的堆。</p> 
<p></p> 
<h4>4.5 如何处理堆顶元素？</h4> 
<p>堆顶就是r[1]。</p> 
<p>第k次处理堆顶，就是将堆顶记录r[1]与r[n-k+1]交换。</p> 
<p></p> 
<h4 style="background-color:transparent;">4.6 代码：</h4> 
<pre><code class="language-cpp">void sift(int r[],int k,int end){
    //当前处理的根结点的编号为k，堆中最后一个结点的编号为k
    int i=k;
    int j=2*i;
    int temp;
    while(j&lt;=end){
        if(j&lt;end&amp;&amp;r[j]&lt;r[j+1]){//找到左右孩子中较大的那个
            j++;
        }
        if(r[i]&lt;r[j]){
            temp=r[i];
            r[i]=r[j];
            r[j]=temp;
        }
        i=j;
        j=2*i;
    }
}
void heapsort(int r[],int n){
    //初始化，得到一个初始堆
    for(int k=n/2;k&gt;=1;k--){
        sift(r,k,n);
    }
    for(int k=1;k&lt;n;k++){//最大的元素往后挪，堆逐渐缩小
        r[0]=r[1];
        r[1]=r[n-k+1];
        r[n-k+1]=r[0];
        sift(r,1,n-k);
    }
}</code></pre> 
<p>时间复杂度：</p> 
<p><img alt="O(nlog_2n)" class="mathcode" src="https://images2.imgbox.com/38/cc/8jm0vXuN_o.png"></p> 
<p>不稳定排序</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/730592cd1978da53548ad014454ab97d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第六章 Linux 磁盘管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a146c3aaf5e3f515f791ea522f97eb7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">产品经理学习-策略产品指标</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>