<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>开始使用 Elasticsearch （1） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="开始使用 Elasticsearch （1）" />
<meta property="og:description" content="在今天的这篇文章中，我们来主要介绍一下如何使用 REST 接口来对 Elasticsearch 进行操作。为了完成这项工作，我们必须完成如下的步骤：
安装 Elasticsearch。请参阅文章 “如何在 Linux，MacOS 及 Windows 上进行安装 Elasticsearch”。把 Elasticsearch 运行起来。安装 Kibana。请参阅文章 “如何在 Linux，MacOS 及 Windows 上安装 Elastic 栈中的 Kibana”。把 Kibana 运行起来。熟悉有关于 Elastic 栈的一些最基本的概念。请参阅文章 “Elasticsarch 中的一些重要概念: cluster, node, shards 及 replica”。这些概念对我们如下的练习有非常多的帮助。 有了上面最基本的一些安装及概念，我们就很容进行下面的讲解了。在如下所展示的所有的 scripts 可在地址 https://github.com/liu-xiao-guo/es-scripts-7.3 找到。
搜索引擎执行以下两个主要操作：
索引（indexing）：此操作用于接收文档，对其进行处理，并将其存储在一个索引中。搜索（searching）：此操作用于根据查询从索引中检索数据。 除了上述的两个操作，作为数据库，通常它还有另外的两个操作：
更改（updating）删除（deleting） 有关这两个操作的详述，请参阅我的另外一篇文章 “Elasticsearch：彻底理解 Elasticsearch 数据操作”。
本教程基于上面的两个操作来完成。这个教程是一个3篇文章的教程，它涵盖了最基本的 Elasticsearch 的一些最基本的点：
开始使用 Elasticsearch （1）: 了解如何创建索引，添加，删除，更新文档开始使用 Elasticsearch （2）：了解如何进行搜索开始使用 Elasticsearch （3）：了解如何进行分析数据: analyze 及 aggregate 数据 开始使用Elasticsearch （1)
开始使用Elasticsearch （1)_哔哩哔哩_bilibili
什么是 JSON？ JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。在 Elasticsearch 中，所以的数据都是以 JSON 的格式来进行表述的。这个和其它的有些数据库，比如 Solr，它支持更多格式的数据，比如 xml, csv 等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/6fbf16d9df0e3309de11f3cd0c0c07b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-09T11:08:10+08:00" />
<meta property="article:modified_time" content="2023-07-09T11:08:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">开始使用 Elasticsearch （1）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在今天的这篇文章中，我们来主要介绍一下如何使用 REST 接口来对 Elasticsearch 进行操作。为了完成这项工作，我们必须完成如下的步骤：</p> 
<ol><li>安装 Elasticsearch。请参阅文章 “<a href="https://blog.csdn.net/UbuntuTouch/article/details/99413578" title="如何在 Linux，MacOS 及 Windows 上进行安装 Elasticsearch">如何在 Linux，MacOS 及 Windows 上进行安装 Elasticsearch</a>”。把 Elasticsearch 运行起来。</li><li>安装 Kibana。请参阅文章 “<a href="https://elasticstack.blog.csdn.net/article/details/99433732" rel="nofollow" title="如何在 Linux，MacOS 及 Windows 上安装 Elastic 栈中的 Kibana">如何在 Linux，MacOS 及 Windows 上安装 Elastic 栈中的 Kibana</a>”。把 Kibana 运行起来。</li><li>熟悉有关于 Elastic 栈的一些最基本的概念。请参阅文章 “<a href="https://blog.csdn.net/UbuntuTouch/article/details/99443042" title="Elasticsarch 中的一些重要概念: cluster, node, shards 及 replica">Elasticsarch 中的一些重要概念: cluster, node, shards 及 replica</a>”。这些概念对我们如下的练习有非常多的帮助。</li></ol> 
<p>有了上面最基本的一些安装及概念，我们就很容进行下面的讲解了。在如下所展示的所有的 scripts 可在地址 <a href="https://github.com/liu-xiao-guo/es-scripts-7.3" title="https://github.com/liu-xiao-guo/es-scripts-7.3">https://github.com/liu-xiao-guo/es-scripts-7.3</a> 找到。</p> 
<p>搜索引擎执行以下两个主要操作：</p> 
<ul><li>索引（indexing）：此操作用于接收文档，对其进行处理，并将其存储在一个索引中。</li><li>搜索（searching）：此操作用于根据查询从索引中检索数据。</li></ul> 
<p>除了上述的两个操作，作为数据库，通常它还有另外的两个操作：</p> 
<ul><li>更改（updating）</li><li>删除（deleting）</li></ul> 
<p>有关这两个操作的详述，请参阅我的另外一篇文章 “<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/128835177" rel="nofollow" title="Elasticsearch：彻底理解 Elasticsearch 数据操作">Elasticsearch：彻底理解 Elasticsearch 数据操作</a>”。</p> 
<p>本教程基于上面的两个操作来完成。这个教程是一个3篇文章的教程，它涵盖了最基本的 Elasticsearch 的一些最基本的点：</p> 
<ul><li><a href="https://blog.csdn.net/UbuntuTouch/article/details/99481016" title="开始使用 Elasticsearch （1）">开始使用 Elasticsearch （1）</a>:   了解如何创建索引，添加，删除，更新文档</li><li><a href="https://blog.csdn.net/UbuntuTouch/article/details/99546568" title="开始使用 Elasticsearch （2">开始使用 Elasticsearch （2</a>）：了解如何进行搜索</li><li><a href="https://blog.csdn.net/UbuntuTouch/article/details/99621105" title="开始使用 Elasticsearch （3">开始使用 Elasticsearch （3</a>）：了解如何进行分析数据: analyze 及 aggregate 数据</li></ul> 
<div class="csdn-video-box"> 
 <iframe id="9uJ6MUVa-1646692900692" frameborder="0" src="https://player.bilibili.com/player.html?aid=796143530" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>开始使用Elasticsearch （1)</p> 
</div> 
<p><a href="https://www.bilibili.com/video/BV1vC4y187tA" rel="nofollow" title="开始使用Elasticsearch （1)_哔哩哔哩_bilibili">开始使用Elasticsearch （1)_哔哩哔哩_bilibili</a></p> 
<p></p> 
<h2>什么是 JSON？</h2> 
<p><a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin" rel="nofollow" title="JSON">JSON</a> (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。在 Elasticsearch 中，所以的数据都是以 JSON 的格式来进行表述的。这个和其它的有些数据库，比如 <a href="https://baike.baidu.com/item/Solr/4101582?fr=aladdin" rel="nofollow" title="Solr">Solr</a>，它支持更多格式的数据，比如 xml, csv 等。</p> 
<p>我们来看一下一个简单的 JSON 格式的数据表达：</p> 
<pre class="has"><code>{
  "name" : "Elastic",
  "location" : {
    "state" : "CA",
    "zipcode" : 94123
  }
}</code></pre> 
<p>这个看起来非常简单直接。如果大家熟悉 Javascript 的话，你会发现它和 Javascript 里的 Object 非常地相似。</p> 
<p></p> 
<h2>什么是 REST 接口？</h2> 
<p>相信很多做过微服务架构的开发者来说，你们可能对 REST 接口再熟悉不过了。<a href="https://baike.baidu.com/item/RESTful/4406165?fr=aladdin" rel="nofollow" title="REST">REST</a> 即表述性状态传递（英文：Representational State Transfer，简称 REST）是 Roy Fielding 博士在2000年他的博士论文中提出来的一种<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" rel="nofollow" title="软件架构">软件架构</a>风格。REST 是一种规范。即参数通过封装后进行传递，响应也是返回的一个封装对象。一个 REST 的接口就像如下的接口：</p> 
<p><a href="http://example.com/customers/1234" rel="nofollow" title="http://example.com/customers/1234">http://example.com/customers/1234</a></p> 
<p>我们可以通过：</p> 
<pre class="has"><code class="language-html">HTTP GET
HTTP POST
HTTP PUT
HTTP DELETE
HTTP PATCH
</code></pre> 
<p>来对数据进行增加（<strong>C</strong>reate），查询（<strong>R</strong>ead)，更新（<strong>U</strong>pdate）及删除（<strong>D</strong>elete）。也就是我们通常说是的 CRUD。</p> 
<table border="1" cellpadding="1" cellspacing="1"><caption>
   HTTP 方法及其用法 
 </caption><thead><tr><th style="width:342px;">方法</th><th style="width:456px;">用法</th></tr></thead><tbody><tr><td style="width:342px;">GET</td><td style="width:456px;">读取数据</td></tr><tr><td style="width:342px;">POST</td><td style="width:456px;">插入数据</td></tr><tr><td style="width:342px;">PUT 或 PATCH</td><td style="width:456px;">更新数据，或如果是一个新的 id，则插入数据</td></tr><tr><td style="width:342px;">DELETE</td><td style="width:456px;">删除数据</td></tr></tbody></table> 
<p>Elasticsearch 里的接口都是通过 REST 接口来实现的。我们在一下的章节里来重点介绍一下是如果使用 REST 接口来实现对数据的操作及查询的。</p> 
<p></p> 
<h2>检查 Elasticsearch 及 Kibana 是否运行正常</h2> 
<p>我们首先在我们的浏览器中输入如下地址：<a href="http://localhost:9200" rel="nofollow" title="http://elasticsearch_endpoint:9200">http://elasticsearch_endpoint:9200</a>。查看一下我们的输出：</p> 
<p style="text-align:center;"><img alt="" class="has" height="583" src="https://images2.imgbox.com/db/1d/y4fQksrf_o.png" width="1000"></p> 
<p></p> 
<p>如果你能看到如上的信息输出，表明我们的 Elasticsearch 是处于一个正常运行的状态。</p> 
<p>同时，我们在浏览器中输入地址：<a href="http://localhost:5601/" rel="nofollow" title="http://kibana_endpoint:5601">http://kibana_endpoint:5601</a>。在浏览器中，我们查看输出的信息：</p> 
<p><img alt="" class="has" height="551" src="https://images2.imgbox.com/37/0d/HYqMtqGv_o.png" width="1000"></p> 
<p>上面显示了 Kibana 的界面。由于 Kibana 的功能有很多。我们在今天的培训中就不一一介绍了。我们着重使用在上面显示的 “Dev Tools” 菜单里的功能。当我们点击它的时候，我们可以看到如下的界面。</p> 
<p><img alt="" class="has" height="502" src="https://images2.imgbox.com/09/c7/nYExFTMR_o.png" width="1000"></p> 
<p>当我们执行命令时，我们必须点击左边窗口里的那个绿色的播放按钮。命令所执行显示的结果将在右边展示。在接下的所有练习中，我们都将使用这样的操作来进行。</p> 
<p>在使用 Kibana 之前，最后先熟悉一下一些快捷键的使用，你可以点击 help 链接得到更多的帮助：</p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/94/d1/ibSf5KAa_o.png" width="958"></p> 
<h3></h3> 
<h2>查看 Elasticsearch 信息</h2> 
<p>就像我们之前在浏览器其中打入地址 <a href="http://localhost:9200" rel="nofollow" title="http://localhost:9200">http://localhost:9200</a> 看到的效果一样，我们直接打入</p> 
<pre class="has"><code>GET /</code></pre> 
<p>我们就可以看到如下的信息：</p> 
<p style="text-align:center;"><img alt="" class="has" height="439" src="https://images2.imgbox.com/d8/c2/k0prHkU5_o.png" width="1000"></p> 
<p>在这里我们可以看到 Elasticsearch 的版本信息及我们正在使用的 Elasticsearch 的 Cluster 名称等信息。</p> 
<p>在很多时候，我们也可以直接在 terminal 中打入相应的指令来达到同样的效果，不过在 Kibana 中更加直接：</p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/b7/9f/GmLZSxDO_o.png" width="958"></p> 
<p>我们把上面的命令拷贝为 cURL，然后再粘贴到 terminal 中，你就会看到：</p> 
<p><img alt="" height="431" src="https://images2.imgbox.com/c5/f2/mPuoX62d_o.png" width="970"></p> 
<p>同样地，我们也可以直接把如下的 terminal 命令：</p> 
<pre><code>curl -XGET "http://localhost:9200/"</code></pre> 
<p>直接拷贝并粘贴到 Dev Tools 的 Console 里去，你会发现，它变成为：</p> 
<pre><code>GET /</code></pre> 
<p><img alt="" height="467" src="https://images2.imgbox.com/ba/f6/QPaw0gjx_o.png" width="958"></p> 
<p>我们可以使用 <a href="https://baike.baidu.com/item/curl/10098606?fr=aladdin" rel="nofollow" title="cURL">cURL</a> 将请求从命令行提交到本地 Elasticsearch 实例。对 Elasticsearch 的请求包含与任何 HTTP 请求相同的部分：</p> 
<pre><code>curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</code></pre> 
<p>本示例使用以下变量：</p> 
<ul><li>&lt;VERB&gt; ：适当的 HTTP 方法或动词。 例如，GET，POST，PUT，HEAD 或 DELETE</li><li>&lt;PROTOCOL&gt;：http 或 https。 如果你在 Elasticsearch 前面有一个 HTTPS 代理，或者你使用 Elasticsearch 安全功能来加密 HTTP 通信，请使用后者</li><li>&lt;HOST&gt;：Elasticsearch 集群中任何节点的主机名。 或者，将 localhost 用于本地计算机上的节点</li><li>&lt;PORT&gt;：运行 Elasticsearch HTTP 服务的端口，默认为9200</li><li>&lt;PATH&gt;：API 端点，可以包含多个组件，例如 _cluster/stats 或 _nodes/stats/jvm</li><li>&lt;QUERY_STRING&gt;：任何可选的查询字符串参数。 例如，?pretty 将漂亮地打印 JSON 响应以使其更易于阅读</li><li>&lt;BODY&gt;：JSON 编码的请求正文（如有必要）</li></ul> 
<p>如果启用了 Elasticsearch 安全功能，则还必须提供有权运行 API 的有效用户名（和密码）。 例如，使用 -u 或 --u cURL 命令参数。比如：</p> 
<pre><code>curl -u elastic:password -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</code></pre> 
<p>这里的 elastic 及 password 代表用超级用户名 elastic 及其密码。你也可以可以使用其它用户账号，如果你的安装是带有安全的。比如一个写入文档到 Elasticsearch 的 curl 命令如下：</p> 
<pre><code>curl -XPUT "https://10.211.55.2:9200/twitter/_doc/1" -H "Content-Type: application/json" -d'
{
  "content": "This is Xiaoguo from Elastic"
}'</code></pre> 
<p class="img-center"><img alt="" height="424" src="https://images2.imgbox.com/a0/84/a9Kx4ZQm_o.png" width="800"></p> 
<p></p> 
<p class="img-center"><img alt="" height="443" src="https://images2.imgbox.com/00/81/tt3bpcFx_o.png" width="1200"></p> 
<p> 我们发现当我们打入一个命令时，Kibana 会帮我们自动地显示可以输入的选择项，它具有 autocomplete 的功能。这个对我们打入我们所需要的命令非常有用。我们有时候不需要记那么多。</p> 
<p style="text-align:center;"><img alt="" class="has" height="305" src="https://images2.imgbox.com/ec/c9/EfzDMHQ2_o.png" width="1000"></p> 
<h3></h3> 
<h2>创建一个索引及文档</h2> 
<p>我们接下来创建一个叫做 <strong>twitter </strong>的索引（index），并插入一个文档（document)。我们知道在 RDMS 中，我们通常需要有专用的语句来生产相应的数据库，表格，让后才可以让我们输入相应的记录，但是针对 Elasticsearch 来说，这个是不必须的。我们在左边的窗口中输入：</p> 
<pre class="has"><code>PUT twitter/_doc/1
{
  "user": "GB",
  "uid": 1,
  "city": "Beijing",
  "province": "Beijing",
  "country": "China"
}</code></pre> 
<p>我们可以看到在 Kibana 右边的窗口中有下面的输出：</p> 
<p><img alt="" class="has" height="455" src="https://images2.imgbox.com/a0/5f/jzGOguJw_o.png" width="1000"></p> 
<p>一旦一个文档被写入，它经历如下的一个过程：</p> 
<p class="img-center"><img alt="" height="660" src="https://images2.imgbox.com/a6/bf/QCRIOdGo_o.png" width="1190"></p> 
<p>在通常的情况下，新写入的文档并不能马上被用于搜索。新增的索引必须写入到 Segment 后才能被搜索到。需要等到 refresh 操作才可以。在默认的情况下每隔一秒的时间 refresh 一次。这就是我们通常所说的近实时。详细阅读请参阅文章 “<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/103641544" rel="nofollow" title="Elasticsearch：Elasticsearch 中的 refresh 和 flush 操作指南">Elasticsearch：Elasticsearch 中的 refresh 和 flush 操作指南</a>”。在编程的时候，我们尤为需要注意这一点。比如我们通过 REST API 时写进一个文档，在写入的时候没有强制 refresh 操作，而是立即进行搜索。我们可能搜索不到刚写入的文档。</p> 
<p><strong>请注意：</strong>在上面创建文档的过程中，我们并没有像其他 RDMS 系统一样，在输入文档之前需要定义各个字段的类型及长度等。为了提高入门时的易用性，Elasticsearch 可以自动动态地为你创建索 mapping。当我们建立一个索引的<span style="color:#fe2c24;"><strong>第一个文档</strong></span>时，如果你没有创建它的  schema，那么 Elasticsearch 会根据所输入字段的数据进行<strong>猜测</strong>它的数据类型，比如上面的 user 被被认为是 text 类型，而 uid 将被猜测为整数类型。这种方式我们称之为 schema on write，也即当我们写入第一个文档时，Elasticsearch 会自动帮我们创建相应的 schema。在 Elasticsearch 的术语中，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html" rel="nofollow" title="mapping">mapping</a> 被称作为 Elasticsearch 的数据 schema。文档中的所有字段都需要映射到 Elasticsearch 中的数据类型。 mapping 指定每个字段的数据类型，并确定应如何索引和分析字段以进行搜索。 在 SQL 数据库中定义表时，mapping 类似于 schema。 mapping 可以显式声明或动态生成。一旦一个索引的某个字段的类型被确定下来之后，那么后续导入的文档的这个字段的类型必须是和之前的是一致，否则写入将导致错误。schema on write 可能在某些时候不是我们想要的，那么在这种情况下，我们可以事先创建一个索引的 schema。你将在文章的下面部分中看到如何创建这个 schema。在最新的 Elasticsearch 设计中，也出现了一种叫做 schema on read 的设计。如果你对这个感兴趣的话，请参阅我的另外一篇文章 “<a href="https://elasticstack.blog.csdn.net/article/details/113813915" rel="nofollow" title="Elasticsearch：Runtime fields 入门， Elastic 的 schema on read 实现 - 7.11 发布">Elasticsearch：Runtime fields 入门， Elastic 的 schema on read 实现 - 7.11 发布</a>”。</p> 
<p>在写入文档时，如果该文档的 ID 已经存在，那么就更新现有的文档；如果该文档从来没有存在过，那么就创建新的文档。如果更新时该文档有新的字段并且这个字段在现有的 mapping 中没有出现，那么 Elasticsearch 会根据 schem on write 的策略来推测该字段的类型，并更新当前的 mapping 到最新的状态。</p> 
<p>动态 mapping 还可能导致某些字段未映射到你的预期，从而导致索引请求失败。显式 mapping 允许更好地控制索引中的字段和数据类型。 一旦知道索引 schema，明确定义索引映射是一个好主意。我们在运行完上面的命令后，可以通过如下的命令来查看当前索引的 mapping：</p> 
<pre><code>GET twitter/_mapping</code></pre> 
<pre><code>{
  "twitter" : {
    "mappings" : {
      "properties" : {
        "city" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "country" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "province" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "uid" : {
          "type" : "long"
        },
        "user" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }
      }
    }
  }
}</code></pre> 
<p>如果我仅想得到某一个字段的类型，我们可以使用如的命令：</p> 
<pre><code class="hljs">GET twitter/_mapping/field/city</code></pre> 
<p>上面的名仅返回 city 这个字段的属性：</p> 
<pre><code class="hljs">{
  "twitter": {
    "mappings": {
      "city": {
        "full_name": "city",
        "mapping": {
          "city": {
            "type": "text",
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          }
        }
      }
    }
  }
}</code></pre> 
<p>针对一些刚接触 Elasticsearch 的开发者来说，上面的这个类型的字段：</p> 
<pre><code>        "city" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }</code></pre> 
<p>它可能难以让人理解。究其实上面的这个字段是一个 <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-fields.html" rel="nofollow" title="mulit-field">mulit-field</a> 字段。为不同目的以不同方式索引同一字段通常很有用。比如在上面，我们定义字段 city 为 <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/text.html" rel="nofollow" title="text">text</a> 类型。text 类型的数据在摄入的时候会分词，这样它可以实现搜索的功能。同时，这个字段也被定义为 <a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html" rel="nofollow" title="keyword">keyword</a> 类型的数据。这个类型的数据可以让我们针对它进行精确匹配（比如区分大小写，空格等符号），聚合和排序。我刚开始学习的时候，上面的两个 keyword 有时让人费解。其实，上面的第一个 keyword 可以是你定义的任何词，而第二个 keyword 才是它的类型定义。比如，我们可以这样来定义这个字段：</p> 
<pre><code>        "city" : {
          "type" : "text",
          "fields" : {
            "raw" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }</code></pre> 
<p>这在早期的 Elasticsearch 发行版中比较常见，一般定义它为 raw。在现在的版本中，在默认的情况下，Elasticsearch 会自动选用 keyword 作为它的名称。在我们访问这个 multi-field 字段时，我们需要以这样的形式来进行访问：city.text 及 city.raw。在实际的使用中，我们有时可能对一个字段需要同时进行搜索和聚合，我们可以这样定义它为 multi-field，但是如果我们仅对搜索或者聚合感兴趣，我们只需要定义其中的一种类型。这样做的好处是，它可以提高数据摄入的速度，因为不必为两个类型进行索引，同时它也可以减少磁盘的使用。</p> 
<p>Elasticsearch 的数据类型：</p> 
<ul><li><strong>text</strong>：全文搜索字符串</li><li><strong>keyword</strong>：用于精确字符串匹配和聚合</li><li><strong>date</strong> 及 <strong>date_nanos</strong>：格式化为日期或数字日期的字符串</li><li><strong>byte</strong>, <strong>short</strong>, <strong>integer</strong>, <strong>long</strong>：整数类型</li><li><strong>boolean</strong>：布尔类型</li><li><strong>float</strong>，<strong>double</strong>，<strong>half_float</strong>：浮点数类型</li><li> <p>分级的类型：<strong>object</strong> 及 <strong>nested</strong>。你可以参考文章 “<a href="https://elasticstack.blog.csdn.net/article/details/100068659" rel="nofollow" title="Elasticsearch: nested 对象">Elasticsearch: nested 对象</a>”</p> </li></ul> 
<p class="img-center"><img alt="" height="438" src="https://images2.imgbox.com/7e/67/v24ocXD9_o.png" width="800"></p> 
<p>有关 Elasticsearch 的数据类型，可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html#_core_datatypes" rel="nofollow" title="链接">链接</a>。</p> 
<p>在默认的情况下，Elasticsearch 可以理解你正在索引的文档的结构并自动创建映射（mapping）定义。 这称为显式映射（Explicit mapping）创建。在绝大多数的情况下，它工作的非常好。使用显式映射可以开始使用无模式（schemaless）方法快速摄取数据，而无需担心字段类型。 因此，为了在索引中获得更好的结果和性能，我们有时需要需要手动定义映射。 微调映射带来了一些优势，例如：</p> 
<ul><li>减少磁盘上的索引大小（禁用自定义字段的功能）</li><li>仅索引感兴趣的字段（一般加速）</li><li>用于快速搜索或实时分析（例如聚合）</li><li>正确定义字段是否必须分词为多个 token 或单个 token</li><li>定义映射类型，例如地理点、suggester、向量等</li></ul> 
<p>假如，我们想创建一个索引 test，并且含有 id 及 message 字段。id 字段为 keyword 类型，而 message 字段为 text 类型，那么我们可以使用如下的方法来创建：</p> 
<pre><code>PUT test
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "message": {
        "type": "text"
      }
    }
  }
}</code></pre> 
<p>我们甚至可以使用如下的 API 来追加一个新的字段 age，并且它的类型为 long 类型：</p> 
<pre><code>PUT test/_mapping
{
  "properties": {
    "age": {
      "type": "long"
    }
  }
}</code></pre> 
<p>我们可以使用如下的命令来查看索引 test 的最终 mapping：</p> 
<pre><code>GET test/_mapping</code></pre> 
<p>上面的命令显示的结果为：</p> 
<pre><code>{
  "test" : {
    "mappings" : {
      "properties" : {
        "age" : {
          "type" : "long"
        },
        "id" : {
          "type" : "keyword"
        },
        "message" : {
          "type" : "text"
        }
      }
    }
  }
}</code></pre> 
<p>在上面，我们可以看出来我们已经成功地创建了一个叫做 twitter 的 index。通过这样的方法，我们可以自动创建一个 index。如果大家不喜欢自动创建一个 index，我们可以修改如下的一个设置：</p> 
<pre class="has"><code>PUT _cluster/settings
{
    "persistent": {
        "action.auto_create_index": "false" 
    }
}</code></pre> 
<p><strong>请注意</strong>：在绝大多数情况下，我们并不需要这么做，除非你知道你要做什么。详细设置请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html" rel="nofollow" title="链接">链接</a>。如果你想禁止自动创建索引，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/targz.html#targz-enable-indices" rel="nofollow" title="你必须配置 action.auto_create_index 以允许这些创建以下索引的组件">你必须配置 action.auto_create_index 以允许这些创建以下索引的组件</a>：</p> 
<pre><code>PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index": ".monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*"
  }
}</code></pre> 
<p>如果使用 Logstash 或 Beats，则应在上面的列表中添加其他索引名称。我们也可以在 elasticsearch.yml 里进行配置。</p> 
<p>通常对一个通过上面方法写入到 Elasticsearch 的文档，在默认的情况下并不马上可以进行搜索。这是因为在 Elasticsearch 的设计中，有一个叫做 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/docs-refresh.html" rel="nofollow" title="refresh">refresh</a> 的操作。它可以使更改可见以进行搜索的操作。通常会有一个 refresh timer 来定时完成这个操作。这个周期为1秒。这也是我们通常所说的 Elasticsearch 可以实现秒级的搜索。当然这个 timer 的周期也可以在索引的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-update-settings.html" rel="nofollow" title="设置">设置</a>中进行配置。如果我们想让我们的结果马上可以对搜索可见，我们可以用如下的方法：</p> 
<pre class="has"><code>PUT twitter/_doc/1?refresh=true
{
  "user": "GB",
  "uid": 1,
  "city": "Beijing",
  "province": "Beijing",
  "country": "China"
}</code></pre> 
<p>上面的方式可以强制使 Elasticsearch 进行 refresh 的操作，当然这个是有代价的。频繁的进行这种操作，可以使我们的 Elasticsearch 变得非常慢。另外一种方式是通过设置 refresh=wait_for。这样相当于一个同步的操作，它等待下一个 refresh 周期发生完后，才返回。这样可以确保我们在调用上面的接口后，马上可以搜索到我们刚才录入的文档：</p> 
<pre class="has"><code>PUT twitter/_doc/1?refresh=wait_for
{
  "user": "GB",
  "uid": 1,
  "city": "Beijing",
  "province": "Beijing",
  "country": "China"
}</code></pre> 
<p>如果你想对 refresh 有更多的了解，请参阅我的文章 “<a href="https://elasticstack.blog.csdn.net/article/details/103641544" rel="nofollow" title="Elasticsearch 中的 refresh 和 flush 操作指南">Elasticsearch 中的 refresh 和 flush 操作指南</a>”。</p> 
<p>它也创建了一个被叫做 _doc 的 type。自从 Elasticsearch 6.0 以后，一个 index 只能有一个 type。如果我们创建另外一个 type 的话，系统会告诉我们是错误的。这里我们也会发现有一个版本（_version）信息，它显示的是4。如果这个 _id 为 1 的 document 之前没有被创建过的话，它会显示为 1。之后如果我们更改这个 document，它的版本会每次自动增加1。比如，我们输入：</p> 
<pre class="has"><code>POST twitter/_doc/1
{
  "user": "GB",
  "uid": 1,
  "city": "Shenzhen",
  "province": "Guangdong",
  "country": "China"
}</code></pre> 
<p><img alt="" class="has" height="475" src="https://images2.imgbox.com/9c/23/hUKb4IfU_o.png" width="1000"></p> 
<p>我们在左边修改了我们的数据，在右边，我们可以看到版本信息增加到6。这是因为我们把左边的命令执行了两次。同时，我们也可以看出来，我们也把左边的数据进行了修改，我们也看到了成功被修改的返回信息。在上面我们可以看出来，我们每次执行那个 POST 或者 PUT 接口时，如果文档已经存在，那么相应的版本（_version）就会自动加1，之前的版本抛弃。如果这个不是我们想要的，那么我们可以使 _create  端点接口来实现：</p> 
<pre class="has"><code>PUT twitter/_create/1
{
  "user": "GB",
  "uid": 1,
  "city": "Shenzhen",
  "province": "Guangdong",
  "country": "China"
}</code></pre> 
<p>如果文档已经存在的话，我们会收到一个错误的信息：</p> 
<p style="text-align:center;"><img alt="" class="has" height="472" src="https://images2.imgbox.com/23/e5/qoUpFKxY_o.png" width="1000"></p> 
<p>上面的命令和如下的命令也是一样的效果：</p> 
<pre><code>PUT twitter/_doc/1?op_type=create
{
  "user": "双榆树-张三",
  "message": "今儿天气不错啊，出去转转去",
  "uid": 2,
  "age": 20,
  "city": "北京",
  "province": "北京",
  "country": "中国",
  "address": "中国北京市海淀区",
  "location": {
    "lat": "39.970718",
    "lon": "116.325747"
  }
}</code></pre> 
<p>在上面，我们在请求时带上 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#docs-index-api-query-params" rel="nofollow" title="op_type">op_type</a>。它可以有两种值：index 及 create。</p> 
<p>我们必须指出的是，如果你是在 Linux 或 MacOS 机器上，我们也可以使用如下的命令行指令来达到同样的效果：</p> 
<pre class="has"><code>curl -XPUT 'http://localhost:9200/twitter/_doc/1?pretty' -H 'Content-Type: application/json' -d '
{
  "user": "GB",
  "uid": 1,
  "city": "Shenzhen",
  "province": "Guangdong",
  "country": "China"
}'</code></pre> 
<p><img alt="" class="has" height="580" src="https://images2.imgbox.com/79/23/mmYLkB86_o.png" width="970"></p> 
<p>本方法适用于一下所有的命令，如法炮制！</p> 
<p>我们可以通过如下的命令来查看被修改的文档：</p> 
<pre class="has"><code>GET twitter/_doc/1</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="493" src="https://images2.imgbox.com/f8/0f/k7skh1Jh_o.png" width="1000"></p> 
<p>我们可以看到在右边显示了我们被修改的文档的结果。</p> 
<p>如果我们只想得到这个文档的 _source 部分，我们可以使用如下的命令格式：</p> 
<pre><code>GET twitter/_doc/1/_source</code></pre> 
<p>在 Elasticsearch 7.0 之后，在 type 最终要被废除的情况下，我们建立使用如下的方法来获得 _source:</p> 
<pre><code>GET twitter/_source/1</code></pre> 
<p></p> 
<h3>自动 ID 生成</h3> 
<p>在上面，我特意为我们的文档分配了一个 ID。其实在实际的应用中，这个并不必要。相反，当我们分配一个 ID 时，在数据导入的时候会检查这个 ID 的文档是否存在，如果是已经存在，那么就更新到版本。如果不存在，就创建一个新的文档。如果我们不指定文档的 ID，转而让 Elasticsearch 自动帮我们生成一个 ID，这样的速度更快。在这种情况下，我们必须使用 POST，而不是 PUT，比如：</p> 
<pre><code>POST my_index/_doc
{
  "content": "this is really cool"
}</code></pre> 
<p>返回的结果：</p> 
<pre><code>{
  "_index" : "my_index",
  "_type" : "_doc",
  "_id" : "egiY4nEBQTokU_uEEGZz",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}</code></pre> 
<p>从上面我们可以看出来，系统会为我们自动分配一个 ID 啊。</p> 
<p>在正常的情况下，当当前复制组的所有分片都执行了索引操作时，Elasticsearch 从索引操作返回。</p> 
<p class="img-center"><img alt="" height="533" src="https://images2.imgbox.com/3e/d1/XUNm9ZaN_o.png" width="800"></p> 
<p></p> 
<p> 设置异步复制允许我们在主分片上同步执行索引操作，在副本分片上异步执行。这样，API 调用会更快地返回响应操作。我们可以这样来进行调用：</p> 
<pre><code>POST my_index/_doc?replication=async
{
  "content": "this is really cool"
}</code></pre> 
<blockquote> 
 <p>注意：上面的 replication=async 在新版本中已经弃用，并不再支持。</p> 
</blockquote> 
<p>如果我们只对 source 的内容感兴趣的话，我们可以使用：</p> 
<pre class="has"><code>GET twitter/_doc/1/_source</code></pre> 
<p>这样我们可以直接得到 source 的信息：</p> 
<pre class="has"><code>{
  "user" : "双榆树-张三",
  "message" : "今儿天气不错啊，出去转转去",
  "uid" : 2,
  "age" : 20,
  "city" : "北京",
  "province" : "北京",
  "country" : "中国",
  "address" : "中国北京市海淀区",
  "location" : {
    "lat" : "39.970718",
    "lon" : "116.325747"
  }
}
</code></pre> 
<p>我们也可以只获取 source 的部分字段：</p> 
<pre class="has"><code>GET twitter/_doc/1?_source=city,age,province</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="509" src="https://images2.imgbox.com/9a/a3/ZuU6wf7n_o.png" width="1000"></p> 
<p>如果你想一次请求查找多个文档，我们可以使用 _mget 接口：</p> 
<pre class="has"><code>GET _mget
{
  "docs": [
    {
      "_index": "twitter",
      "_id": 1
    },
    {
      "_index": "twitter",
      "_id": 2
    }
  ]
}</code></pre> 
<p>我们也可以只获得部分字段：</p> 
<pre class="has"><code>GET _mget
{
  "docs": [
    {
      "_index": "twitter",
      "_id": 1,
      "_source":["age", "city"]
    },
    {
      "_index": "twitter",
      "_id": 2,
      "_source":["province", "address"]
    }
  ]
}</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="455" src="https://images2.imgbox.com/a4/5f/3lOgjOah_o.png" width="1000"></p> 
<p>在这里，我们同时请求 id 为 1 和 2 的两个文档。</p> 
<p style="text-align:center;"><img alt="" class="has" height="583" src="https://images2.imgbox.com/59/a1/DcYf17Wx_o.png" width="1000"></p> 
<p>我们也可以简单地写为：</p> 
<pre class="has"><code>GET twitter/_doc/_mget
{
  "ids": ["1", "2"]
}</code></pre> 
<p>它和上面的做一个是一样的。使用一个命令同时获取 id 为 1 及 2 的文档。</p> 
<p>在上面当我们写入数据时，我们有意识地把文档的 <strong>id </strong>在命令中写了出来。如果我们不写这个 id 的话，ES 会帮我们自动生产一个 id:</p> 
<pre class="has"><code>POST twitter/_doc/</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="509" src="https://images2.imgbox.com/56/56/K4IEzWWu_o.png" width="1000"></p> 
<p>我可以看到右边的一个 id 像是一个随机的数值，同时我们可以看到它的一个版本信息为1。在实际的需要有大量导入数据的情况下，我们建议让系统自动帮我们生成一个 id，这样可以提高导入的速度。假如我们指定一个 id，通常 ES 会先查询这个 id 是否存在，然后在觉得是更新之前的文档还是创建一个新的文档。这里是分两步走。显然它比直接创建一个文档要慢！</p> 
<p>我们也可以看出来系统所给出来的字段都是以下划线的形式给出来的，比如：_id, _shards, _index, _typed 等</p> 
<h3></h3> 
<h2>修改一个文档</h2> 
<p>我们接下来看一下如何修改一个文档。在上面我们看到了可以使用 POST 的命令来修改改一个文档。通常我们使用 POST 来创建一个新的文档。在使用 POST 的时候，我们甚至不用去指定特定的 id，系统会帮我们自动生成。但是我们修改一个文档时，我们通常会使用 PUT 来进行操作，并且，我们需要指定一个特定的 id 来进行修改：</p> 
<pre class="has"><code>PUT twitter/_doc/1
{
   "user": "GB",
   "uid": 1,
   "city": "北京",
   "province": "北京",
   "country": "中国",
   "location":{
     "lat":"29.084661",
     "lon":"111.335210"
   }
}</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="517" src="https://images2.imgbox.com/83/18/y36z4r36_o.png" width="1000"></p> 
<p>如上面所示，我们使用 PUT 命令来对我们的 id 为1的文档进行修改。我们也可以使用我们上面学过的 GET 来进行查询：</p> 
<pre class="has"><code>GET twitter/_doc/1</code></pre> 
<pre class="has"><code>{
  "_index" : "twitter",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 8,
  "_seq_no" : 13,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "user" : "GB",
    "uid" : 1,
    "city" : "北京",
    "province" : "北京",
    "country" : "中国",
    "location" : {
      "lat" : "29.084661",
      "lon" : "111.335210"
    }
  }
}</code></pre> 
<p>显然，我们的这个文档已经被成功修改了。</p> 
<p>我们使用 PUT 的这个方法，每次修改一个文档时，我们需要把文档的每一项都要写出来。这对于有些情况来说，并不方便，我们可以使用如下的方法来进行修改：</p> 
<pre class="has"><code>POST twitter/_update/1
{
  "doc": {
    "city": "成都",
    "province": "四川"
  }
}</code></pre> 
<p>我们可以使用如上的命令来修改我们的部分数据。同样我们可以使用 GET 来查询我们的修改是否成功：</p> 
<p style="text-align:center;"><img alt="" class="has" height="527" src="https://images2.imgbox.com/56/cd/cc9cixSC_o.png" width="1000"></p> 
<p>从上面的显示中，我们可以看出来，我们的修改是成功的，虽然在我们修改时，我们只提供了部分的数据。</p> 
<p>在关系数据库中，我们通常是对数据库进行搜索，让后才进行修改。在这种情况下，我们事先通常并不知道文档的 id。我们需要通过查询的方式来进行查询，让后进行修改。ES 也提供了相应的 REST 接口。</p> 
<pre class="has"><code>POST twitter/_update_by_query
{
  "query": {
    "match": {
      "user": "GB"
    }
  },
  "script": {
    "source": "ctx._source.city = params.city;ctx._source.province = params.province;ctx._source.country = params.country",
    "lang": "painless",
    "params": {
      "city": "上海",
      "province": "上海",
      "country": "中国"
    }
  }
}</code></pre> 
<p>对于那些名字是中文字段的文档来说，在 painless 语言中，直接打入中文字段名字，并不能被认可。我们可以使用如下的方式来操作：</p> 
<pre class="has"><code>POST edd/_update_by_query
{
  "query": {
    "match": {
      "姓名": "张彬"
    }
  },
  "script": {
    "source": "ctx._source[\"签到状态\"] = params[\"签到状态\"]",
    "lang": "painless",
    "params" : {
      "签到状态":"已签到"
    }
  }
}</code></pre> 
<p>在上面我们使用一个中括号并 escape 引号的方式来操作。有关 Painless 的编程，你可以参阅文章 “<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/100576555" rel="nofollow" title="Elasticsearch: Painless script 编程">Elasticsearch: Painless script 编程</a>”。</p> 
<p>我们可以通过上面的方法搜寻 user 为 GB 的用户，并且把它的数据项修改为：</p> 
<pre class="has"><code>        "city" : "上海",
        "province": "上海",
        "country": "中国"</code></pre> 
<p>我们也可以通过 update 接口，使用 script 的方法来进行修改。这个方法也是需要知道文档的 id:</p> 
<pre class="has"><code>POST twitter/_update/1
{
  "script" : {
      "source": "ctx._source.city=params.city",
      "lang": "painless",
      "params": {
        "city": "长沙"
      }
  }
}</code></pre> 
<p>在我们使用上面的方法更新文档时，如果当前的文档 id 不存在，那么我们甚至可以使用 <strong>upsert</strong> 属性来创建一个文档：</p> 
<pre><code>POST twitter/_update/1
{
  "script" : {
      "source": "ctx._source.city=params.city",
      "lang": "painless",
      "params": {
        "city": "长沙"
      }
  },
  "upsert": {
    "city": "长沙"
  }
}</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="542" src="https://images2.imgbox.com/43/18/5o1FHMoh_o.png" width="1000"></p> 
<p>和前面的方法一下，我们可以使用 GET 来查询，我们的结果是否已经改变：</p> 
<pre class="has"><code>{
  "_index" : "twitter",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 18,
  "_seq_no" : 39,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "uid" : 1,
    "country" : "中国",
    "province" : "上海",
    "city" : "长沙",
    "location" : {
      "lon" : "111.335210",
      "lat" : "29.084661"
    },
    "user" : "GB"
  }
}
</code></pre> 
<p>如果你涉及到多个客户端同时更新一个索引的情况，你需要阅读文章 “<a href="https://elasticstack.blog.csdn.net/article/details/108810469" rel="nofollow" title="深刻理解文档中的 verision 及 乐观并发控制">深刻理解文档中的 verision 及 乐观并发控制</a>”。</p> 
<p>我们甚至可以使用 _update 接口使用 ctx['_op'] 来达到删除一个文档的目的，比如：</p> 
<pre><code>POST twitter/_update/1
{
  "script": {
    "source": """
    if(ctx._source.uid == 1) {
      ctx.op = 'delete'
    } else {
      ctx.op = "none"
    }
    """
  }
}</code></pre> 
<p>当检测文档的 uid 是否为 1，如果为 1 的话，那么该文档将被删除，否则将不做任何事情。</p> 
<p>我还可以充分使用 script 的一些高级操作，比如我们可以通过如下的方法来添加一个崭新的字段：</p> 
<pre><code>POST twitter/_update/1
{
  "script" : {
      "source": "ctx._source.newfield=4",
      "lang": "painless"
  }
}</code></pre> 
<p>通过上面的操作，我们可以发现，我们新增加了一个叫做 newfield 的字段。当然我们也可以使用如下的方法来删除一个字段：</p> 
<pre><code>POST twitter/_update/1
{
  "script" : {
      "source": "ctx._source.remove(\"newfield\")",
      "lang": "painless"
  }
}</code></pre> 
<p>在上面的命令中，我们通过 remove 删除了刚才被创建的 newfiled 字段。我们可以通过如下的命令来进行查看：</p> 
<pre><code>GET twitter/_doc/1</code></pre> 
<p>在这里请注意的是：一旦一个字段被创建，那么它就会存在于更新的 mapping 中。即便针对 id 为 1 的文档删除了 newfield，但是 newfield 还将继续存在于 twitter 的 mapping 中。我们可以使用如下的命令来查看 twitter 的 mapping：</p> 
<pre><code>GET twitter/_mapping</code></pre> 
<p>这里值得注意是：对于多用户，我们可以从各个客户端同时更新，这里可能会造成更新数据的一致性问题。为了避免这种现象的出现，请阅读我的另外一篇文章 “<a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/108810469" rel="nofollow" title="Elasticsearch：深刻理解文档中的 verision 及乐观并发控制">Elasticsearch：深刻理解文档中的 verision 及乐观并发控制</a>”。</p> 
<p></p> 
<h2>UPSERT 一个文档</h2> 
<p>仅在文档事先存在的情况下，我们在前面的代码中看到的部分更新才有效。 如果具有给定 id 的文档不存在，Elasticsearch 将返回一个错误，指出该文档丢失。 让我们了解如何使用更新 API 进行 upsert 操作。 术语 “upsert” 宽松地表示更新或插入，即更新文档（如果存在），否则，插入新文档。</p> 
<p>doc_as_upsert 参数检查具有给定ID的文档是否已经存在，并将提供的 doc 与现有文档合并。 如果不存在具有给定 id 的文档，则会插入具有给定文档内容的新文档。<br>   <br> 下面的示例使用 doc_as_upsert 合并到 id 为 3 的文档中，或者如果不存在则插入一个新文档：</p> 
<pre class="has"><code>POST /catalog/_update/3
{
  "doc": {
    "author": "Albert Paro",
    "title": "Elasticsearch 5.0 Cookbook",
    "description": "Elasticsearch 5.0 Cookbook Third Edition",
    "price": "54.99"
  },
  "doc_as_upsert": true
}</code></pre> 
<p></p> 
<h2>检查一个文档是否存在</h2> 
<p>有时候我们想知道一个文档是否存在，我们可以使用如下的方法：</p> 
<pre class="has"><code>HEAD twitter/_doc/1</code></pre> 
<p>这个 HEAD 接口可以很方便地告诉我们在 twitter 的索引里是否有一 id 为1的文档：</p> 
<p style="text-align:center;"><img alt="" class="has" height="361" src="https://images2.imgbox.com/9f/e6/EZCA2rFH_o.png" width="1000"></p> 
<p>上面的返回值表面 id 为1的文档时存在的。</p> 
<p></p> 
<h2>删除一个文档</h2> 
<p>如果我们想删除一个文档的话，我们可以使用如下的命令：</p> 
<pre class="has"><code>DELETE twitter/_doc/1</code></pre> 
<p> 在上面的命令中，我们删除了 id 为 1 的文档。</p> 
<p style="text-align:center;"><img alt="" class="has" height="459" src="https://images2.imgbox.com/05/86/OHJfVY5x_o.png" width="1000"></p> 
<p>在关系数据库中，我们通常是对数据库进行搜索，让后才进行删除。在这种情况下，我们事先通常并不知道文档的 id。我们需要通过查询的方式来进行查询，让后进行删除。ES 也提供了相应的 REST 接口。</p> 
<pre class="has"><code>POST twitter/_delete_by_query
{
  "query": {
    "match": {
      "city": "上海"
    }
  }
}</code></pre> 
<p>这样我们就把所有的 city 是上海的文档都删除了。</p> 
<p></p> 
<h2>检查一个索引是否存在</h2> 
<p>我们可以使用如下的命令来检查一个索引是否存在：</p> 
<pre><code>HEAD twitter</code></pre> 
<p>如果 twitter 索引存在，那么上面的命令会返回：</p> 
<pre><code>200 - OK</code></pre> 
<p>否则就会返回：</p> 
<pre><code>{"statusCode":404,"error":"Not Found","message":"404 - Not Found"}</code></pre> 
<p></p> 
<h2>删除一个索引</h2> 
<p>删除一个索引 是非常直接的。我们可以直接使用如下的命令来进行删除：</p> 
<pre class="has"><code>DELETE twitter</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="423" src="https://images2.imgbox.com/98/77/TiMPvHvI_o.png" width="1000"></p> 
<p>当我们执行完这一条语句后，所有的在 twitter 中的所有的文档都将被删除。</p> 
<h3></h3> 
<h2>批处理命令</h2> 
<p>上面我们已经了解了如何使用 REST 接口来创建一个 index，并为之创建（Create），读取（Read），修改（Update），删除文档（Delete）（CRUD）。因为每一次操作都是一个 REST 请求，对于大量的数据进行操作的话，这个显得比较慢。ES 创建一个批量处理的命令给我们使用。这样我们在一次的 REST 请求中，我们就可以完成很多的操作。这无疑是一个非常大的好处。下面，我们来介绍一下这个 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" rel="nofollow" title="_bulk">_bulk</a> 命令。</p> 
<p>我们使用如下的命令来进行 bulk 操作：</p> 
<pre class="has"><code>POST _bulk
{ "index" : { "_index" : "twitter", "_id": 1} }
{"user":"双榆树-张三","message":"今儿天气不错啊，出去转转去","uid":2,"age":20,"city":"北京","province":"北京","country":"中国","address":"中国北京市海淀区","location":{"lat":"39.970718","lon":"116.325747"}}
{ "index" : { "_index" : "twitter", "_id": 2 }}
{"user":"东城区-老刘","message":"出发，下一站云南！","uid":3,"age":30,"city":"北京","province":"北京","country":"中国","address":"中国北京市东城区台基厂三条3号","location":{"lat":"39.904313","lon":"116.412754"}}
{ "index" : { "_index" : "twitter", "_id": 3} }
{"user":"东城区-李四","message":"happy birthday!","uid":4,"age":30,"city":"北京","province":"北京","country":"中国","address":"中国北京市东城区","location":{"lat":"39.893801","lon":"116.408986"}}
{ "index" : { "_index" : "twitter", "_id": 4} }
{"user":"朝阳区-老贾","message":"123,gogogo","uid":5,"age":35,"city":"北京","province":"北京","country":"中国","address":"中国北京市朝阳区建国门","location":{"lat":"39.718256","lon":"116.367910"}}
{ "index" : { "_index" : "twitter", "_id": 5} }
{"user":"朝阳区-老王","message":"Happy BirthDay My Friend!","uid":6,"age":50,"city":"北京","province":"北京","country":"中国","address":"中国北京市朝阳区国贸","location":{"lat":"39.918256","lon":"116.467910"}}
{ "index" : { "_index" : "twitter", "_id": 6} }
{"user":"虹桥-老吴","message":"好友来了都今天我生日，好友来了,什么 birthday happy 就成!","uid":7,"age":90,"city":"上海","province":"上海","country":"中国","address":"中国上海市闵行区","location":{"lat":"31.175927","lon":"121.383328"}}</code></pre> 
<p>在上面的命令中，我们使用了 bulk 指令来完成我们的操作。在输入命令时，我们需要特别的注意：千<strong>万不要添加除了换行以外的空格，否则会导致错误</strong>。在上面我们使用的 index 用来创建一个文档。为了说明问题的方便，我们在每一个文档里，特别指定了每个文档的 id。当执行完我们的批处理 bulk 命令后，我们可以看到：</p> 
<p style="text-align:center;"><img alt="" class="has" height="453" src="https://images2.imgbox.com/31/a4/Atl7WGeA_o.png" width="1000"></p> 
<p>显然，我们的创建时成功的。因为我运行了两遍的原因，所以你看到的是 version 为 2 的返回结果。bulk 指令是高效的，因为一个请求就可以处理很多个操作。在实际的使用中，我们必须注意的是：一个好的起点是批量处理 1,000 到 5,000 个文档，总有效负载在 5MB 到 15MB 之间。如果我们的 payload 过大，那么可能会造成请求的失败。如果你想更进一步探讨的话，你可以使用文件 <a href="https://raw.githubusercontent.com/elastic/elasticsearch/master/docs/src/test/resources/accounts.json" rel="nofollow" title="accounts.json">accounts.json</a> 来做实验。更多是有数据可以在地址 <a href="https://www.elastic.co/guide/cn/kibana/current/tutorial-load-dataset.html" rel="nofollow" title="加载示例数据 | Kibana 用户手册 | Elastic">加载示例数据 | Kibana 用户手册 | Elastic</a> 进行下载。</p> 
<p>如果你想查询到所有的输入的文档，我们可以使用如下的命令来进行查询：</p> 
<pre class="has"><code>POST twitter/_search</code></pre> 
<p>这是一个查询的命令，在以后的章节中，我们将再详细介绍。通过上面的指令，我们可以看到所有的已经输入的文档。</p> 
<p style="text-align:center;"><img alt="" class="has" height="453" src="https://images2.imgbox.com/f0/3f/HscJP4QE_o.png" width="1000"></p> 
<p>上面的结果显示，我们已经有6条生产的文档记录已经生产了。</p> 
<p>我们可以通过使用 _count 命令来查询有多少条数据：</p> 
<pre class="has"><code>GET twitter/_count</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="444" src="https://images2.imgbox.com/f4/1e/OqOJS7Zl_o.png" width="1000"></p> 
<p></p> 
<p>上面我们已经使用了 index 来创建6条文档记录。我也可以尝试其它的命令，比如 create:</p> 
<pre class="has"><code>POST _bulk
{ "create" : { "_index" : "twitter", "_id": 1} }
{"user":"双榆树-张三","message":"今儿天气不错啊，出去转转去","uid":2,"age":20,"city":"北京","province":"北京","country":"中国","address":"中国北京市海淀区","location":{"lat":"39.970718","lon":"116.325747"}}
{ "index" : { "_index" : "twitter", "_id": 2 }}
{"user":"东城区-老刘","message":"出发，下一站云南！","uid":3,"age":30,"city":"北京","province":"北京","country":"中国","address":"中国北京市东城区台基厂三条3号","location":{"lat":"39.904313","lon":"116.412754"}}
{ "index" : { "_index" : "twitter", "_id": 3} }
{"user":"东城区-李四","message":"happy birthday!","uid":4,"age":30,"city":"北京","province":"北京","country":"中国","address":"中国北京市东城区","location":{"lat":"39.893801","lon":"116.408986"}}
{ "index" : { "_index" : "twitter", "_id": 4} }
{"user":"朝阳区-老贾","message":"123,gogogo","uid":5,"age":35,"city":"北京","province":"北京","country":"中国","address":"中国北京市朝阳区建国门","location":{"lat":"39.718256","lon":"116.367910"}}
{ "index" : { "_index" : "twitter", "_id": 5} }
{"user":"朝阳区-老王","message":"Happy BirthDay My Friend!","uid":6,"age":50,"city":"北京","province":"北京","country":"中国","address":"中国北京市朝阳区国贸","location":{"lat":"39.918256","lon":"116.467910"}}
{ "index" : { "_index" : "twitter", "_id": 6} }
{"user":"虹桥-老吴","message":"好友来了都今天我生日，好友来了,什么 birthday happy 就成!","uid":7,"age":90,"city":"上海","province":"上海","country":"中国","address":"中国上海市闵行区","location":{"lat":"31.175927","lon":"121.383328"}}</code></pre> 
<p>在上面，我们的第一个记录里，我们使用了 create 来创建第一个 id 为1的记录。因为之前，我们已经创建过了，所以我们可以看到如下的信息：</p> 
<p style="text-align:center;"><img alt="" class="has" height="447" src="https://images2.imgbox.com/93/be/KD38Z9rY_o.png" width="1000"></p> 
<p>从上面的信息，我们可以看出来 index 和 create 的区别。index 总是可以成功，它可以覆盖之前的已经创建的文档，但是 create 则不行，如果已经有以那个 id 为名义的文档，就不会成功。</p> 
<p>我们可以使用 delete 来删除一个已经创建好的文档：</p> 
<pre class="has"><code>POST _bulk
{ "delete" : { "_index" : "twitter", "_id": 1 }}</code></pre> 
<p style="text-align:center;"><img alt="" class="has" height="416" src="https://images2.imgbox.com/1a/50/UmfSanMF_o.png" width="1000"></p> 
<p></p> 
<p>我们可以看到 id 为1的文档已经被删除了。我可以通过如下的命令来查看一下：</p> 
<p style="text-align:center;"><img alt="" class="has" height="436" src="https://images2.imgbox.com/ac/b7/xjgwG48K_o.png" width="1000"></p> 
<p>显然，我们已经把 id 为1的文档已经成功删除了。</p> 
<p>我们也可以是使用 update 来进行更新一个文档。</p> 
<pre class="has"><code>POST _bulk
{ "update" : { "_index" : "twitter", "_id": 2 }}
{"doc": { "city": "长沙"}}</code></pre> 
<p>运行的结果如下：</p> 
<p style="text-align:center;"><img alt="" class="has" height="471" src="https://images2.imgbox.com/a4/c1/WDv0hME6_o.png" width="1000"></p> 
<p></p> 
<p>同样，我们可以使用如下的方法来查看我们修改的结果：</p> 
<p style="text-align:center;"><img alt="" class="has" height="448" src="https://images2.imgbox.com/29/c9/3uXpVuVB_o.png" width="1000"></p> 
<p>我们可以清楚地看到我们已经成功地把城市 city 修改为 “长沙”。</p> 
<p><strong>注意</strong>：通过 bulk API 为数据编制索引时，你不应在集群上进行任何查询/搜索。 这样做可能会导致严重的性能问题。</p> 
<p>如果你对脚本编程比较熟悉的话，你可能更希望通过脚本的方法来把大量的数据通过脚本的方式来导入：</p> 
<pre class="has"><code>$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary @request_example.json</code></pre> 
<p>这里的 request_example.json 就是我们的 JSON 数据文件。我们可以做如下的实验：</p> 
<p>下载测试数据：</p> 
<pre class="has"><code>wget https://github.com/liu-xiao-guo/elasticsearch-bulk-api-data/blob/master/es.json</code></pre> 
<p>然后在命令行中打入如下的命令:</p> 
<pre class="has"><code>curl -u elastic:123456 -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary @es.json</code></pre> 
<p>这里的 “elastic:123456” 是我们的 Elasticsearch 的用户名及密码，如果我们没有为我们的 Elasticsearch 设置安全，那么可以把 “-u elastic:123456” 整个去掉。正对配置有 https 的 Elasticsearch 服务器，我们可以使用如下格式的命令来进行操作：</p> 
<pre><code>curl --cacert /home/elastic/ca.crt -u elastic:123456 -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary @es.json</code></pre> 
<p>在上面， 我们使用 --cacert /home/elastic/ca.crt 来定义证书的地址。</p> 
<p>等我们运行完上面的指令后，我们可以在 Kibana 中查看到我们的叫做 “bank_account” 的索引。</p> 
<p style="text-align:center;"><img alt="" class="has" height="355" src="https://images2.imgbox.com/af/ba/B9ZKL6eT_o.png" width="955"></p> 
<p></p> 
<h2>索引统计</h2> 
<p>Elasticsearch 提供有关进入索引的数据以及提取的数据的详细统计信息。 它提供 API 来生成报告，例如索引包含的文档数、已删除的文档、合并和刷新统计信息等。每个索引都会生成统计信息，例如它拥有的文档总数、已删除文档的计数、分片的内存、获取和搜索请求数据等。_stats API 帮助我们检索索引的统计信息，包括主分片和副本分片。</p> 
<pre><code>GET twitter/_stats</code></pre> 
<p class="img-center"><img alt="" height="427" src="https://images2.imgbox.com/f5/23/tgmt6zm3_o.png" width="800"></p> 
<p>响应指示 total 属性，它是与该索引关联的总分片（包括主分片和副本分片）的数量。 由于我们只有一个主分片，所以 successful 属性指向这个分片号。</p> 
<p>我们甚至可以同时获得多个索引的统计数据：</p> 
<pre><code>GET twitter1,twitter2,twitter3/_stats</code></pre> 
<p>我们也可以使用通配符来匹配多个索引：</p> 
<pre><code>GET twitter*/_stats</code></pre> 
<p></p> 
<h2>Open/close Index</h2> 
<p>Elasticsearch 支持索引的在线/离线模式。 使用脱机模式时，在群集上几乎没有任何开销地维护数据。 关闭索引后，将阻止读/写操作。 当你希望索引重新联机时，只需打开它即可。 但是，关闭索引会占用大量磁盘空间。 你可以通过将 cluster.indices.close.enable 的默认值从 true 更改为 false 来禁用关闭索引功能，以避免发生意外。</p> 
<p style="text-align:center;"><img alt="" class="has" height="473" src="https://images2.imgbox.com/2c/a8/QCw0R5Fd_o.png" width="1000"></p> 
<p>一旦 twitter 索引被关闭了，那么我们再访问时会出现如下的错误：</p> 
<p style="text-align:center;"><img alt="" class="has" height="473" src="https://images2.imgbox.com/db/72/EQudc0xc_o.png" width="1000"></p> 
<p>我们可以通过 _open 接口来重新打开这个 index:</p> 
<p style="text-align:center;"><img alt="" class="has" height="473" src="https://images2.imgbox.com/a0/ee/d21D0NGa_o.png" width="1000"></p> 
<p>关于关闭索引有很多用例：</p> 
<ul><li>它可以禁用基于日期的索引（按日期存储其记录的索引）— 例如，当你将索引保留一周、一个月或一天，并且你希望保留固定数量的旧索引（即 2 个月 旧）在线和一些离线（即从 2 个月到 6 个月）。</li><li>当你搜索集群的所有 active 索引并且不想搜索某些索引时（在这种情况下，使用 <a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/100246175" rel="nofollow" title="alias">alias</a> 是最好的解决方案，但你可以使用具有关闭索引的 <a class="link-info" href="https://elasticstack.blog.csdn.net/article/details/100246175" rel="nofollow" title="alias">alias</a> 来实现相同的效果）。</li></ul> 
<p></p> 
<h2>Freeze/unfreeze index</h2> 
<p>冻结索引（freeze index）在群集上几乎没有开销（除了将其元数据保留在内存中），并且是只读的。 只读索引被阻止进行写操作，例如 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/search-suggesters.html#indexing" rel="nofollow" title="docs-index">docs-index</a> 或 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/indices-forcemerge.html" rel="nofollow" title="force merge">force merge</a>。 请参<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/frozen-indices.html" rel="nofollow" title="阅冻结索引">阅冻结索引</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/freeze-index-api.html" rel="nofollow" title="取消冻结索引">取消冻结索引</a>。</p> 
<p>冻结索引受到限制，以限制每个节点的内存消耗。 每个节点的并发加载的冻结索引数受 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-threadpool.html#search-throttled" rel="nofollow" title="search_throttled">search_throttled</a> 线程池中的线程数限制，默认情况下为1。 默认情况下，即使已明确命名冻结索引，也不会针对冻结索引执行搜索请求。 这是为了防止由于误将冻结的索引作为目标而导致的意外减速。 如果要包含冻结索引做搜索，必须使用查询参数 ignore_throttled = false 来执行搜索请求。</p> 
<p>我们可以使用如下的命令来对 twitter 索引来冻结：</p> 
<pre class="has"><code>POST twitter/_freeze</code></pre> 
<p>在执行上面的命令后，我们再对 twitter 进行搜索：</p> 
<p><img alt="" class="has" height="509" src="https://images2.imgbox.com/ab/3f/nW0uhFXS_o.png" width="1008"></p> 
<p>我们搜索不到任何的结果。按照我们上面所说的，我们必须加上 ignore_throttled=false 参数来进行搜索：</p> 
<p><img alt="" class="has" height="509" src="https://images2.imgbox.com/64/28/nM12kllb_o.png" width="1008"></p> 
<p>显然对于一个 frozen 的索引来说，我们是可以对它进行搜索的。我们可以通过如下的命令来对这个已经冻结的索引来进行解冻：</p> 
<pre class="has"><code>POST twitter/_unfreeze</code></pre> 
<p>一旦我们的索引被成功解冻，那么它就可以像我们正常的索引来进行操作了，而不用添加参数 ignore_throttled=false 来进行访问。</p> 
<p></p> 
<h2>总结</h2> 
<p></p> 
<p>在这篇文章中，我们详细地介绍了如果在 Elasticserch 中创建我们的索引，文档，并对他们进行更改，删除，查询的操作。希望对大家有所帮助。在接下来的文章里，我们将重点介绍如何对 Elasticsearch 里的 index 进行搜索和分析。</p> 
<p>如果你想了解更多关于 Elastic Stack 相关的知识，请参阅我们的官方网站：<a href="https://www.elastic.co/guide/index.html" rel="nofollow" title="Elastic Stack and Product Documentation | Elastic">Elastic Stack and Product Documentation | Elastic</a></p> 
<h3></h3> 
<h2>下一步</h2> 
<p>接下来，我们可以学习教程：</p> 
<ul><li> <p><a href="https://blog.csdn.net/UbuntuTouch/article/details/99546568" title="开始使用Elasticsearch （2）">开始使用Elasticsearch （2）</a></p> </li><li> <p><a href="https://blog.csdn.net/UbuntuTouch/article/details/99621105" title="开始使用Elasticsearch （3）">开始使用Elasticsearch （3）</a></p> </li></ul> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32ef8739a714f30969786b6dacffdf8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python的一些小练习（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5afb6eff61ec46580cd424c194385886/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【漏洞复现】nginxWebUI 存在前台远程命令执行漏洞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>