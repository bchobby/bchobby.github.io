<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>R语言 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="R语言" />
<meta property="og:description" content="R的源起
R是S语言的一种实现。S语言是由 AT&amp;T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业 软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman 和 Ross Ihaka 及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。
R is free
R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。
R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言：可操纵数据的输入和输入，可实现分支、循环，用户可自定义功能。
R是一个免费的自由软件，它有UNIX、LINUX、MacOS和WINDOWS版本，都是可以免费下载和使用的,在那儿可以下载到R的安装程序、各种外挂程序和文档。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。
R的特点
(1) 有效的数据处理和保存机制。
(2) 拥有一整套数组和矩阵的操作运算符。
(3) 一系列连贯而又完整的数据分析中间工具。
(4) 图形统计可以对数据直接进行分析和显示，可用于多种图形设备。
(5) 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数以及输入输出接口。
(6) R语言是彻底面向对象的统计编程语言。
(7) R语言和其它编程语言、数据库之间有很好的接口。
(8) R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。
(9) R语言具有丰富的网上资源
一 入门训练
1. 获取帮助
&gt; help.start() 开启帮助文档
&gt;help(solve) 显示某命令的帮助信息，或者
&gt;?solve
对于由特殊字符指定的功能，这些参数必须用单引号或双引号括起来，使之成为一个“字符串”,如
&gt; help(&#34;[[&#34;)
与某个主题相关的例子通常可以用下面的命令得到
&gt; example(topic)
2. 命令简介
R对大小写是敏感的；名称不能以数字开始；
基本的命令由表达式或者赋值语句组成。如果一个表达式被作为一条命令给出，它将被求值、打印而表达式的值并不被保存。一个赋值语句同样对表达式求值之后把表达式的值传给一个变量，不过并不会自动的被打印出来；
命令由分号(;)来分隔，或者另起新行；
基本命令可以由花括号(f和g)合并为一组复合表达式；
注释几乎可以被放在任何地方，只要是以井号( # )开始，到行末结束；
如果一个命令在行莫仍没有结束，R将会给出一个不同的提示符，默认的是‘&#43;’。
3. 命令文件的执行和输出转向到文件
如果命令存储于一个外部文件中，比如工作目录work中的commands.R，他们可以随时在R的任务中被执行
&gt; source(&#34;commands.R&#34;)在Windows中Source也可以由File菜单执行。
函数sink，
&gt; sink(&#34;record.lis&#34;)
将把所有后续的输出由终端转向一个外部文件，record.lis。命令" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/7163a446e36c311a471845fc7f182b7a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-06-23T21:21:00+08:00" />
<meta property="article:modified_time" content="2016-06-23T21:21:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">R语言</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="content" id="articleContent"> 
 <p><strong><span style="font-size:14px;">R的源起</span></strong></p> 
 <p>R是S语言的一种实现。S语言是由 AT&amp;T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业 软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman 和 Ross Ihaka 及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。</p> 
 <p><strong><span style="font-size:14px;">R is free</span></strong></p> 
 <p>R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。<br> R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言：可操纵数据的输入和输入，可实现分支、循环，用户可自定义功能。<br> R是一个免费的自由软件，它有UNIX、LINUX、MacOS和WINDOWS版本，都是可以免费下载和使用的,在那儿可以下载到R的安装程序、各种外挂程序和文档。在R的安装程序中只包含了<strong>8个基础模块</strong>，其他外在模块可以通过<strong>CRAN获得</strong>。<br><strong><span style="font-size:14px;">R的特点</span></strong></p> 
 <p>(1) 有效的数据处理和保存机制。<br> (2) 拥有一整套数组和矩阵的操作运算符。<br> (3) 一系列连贯而又完整的数据分析中间工具。<br> (4) 图形统计可以对数据直接进行分析和显示，可用于多种图形设备。<br> (5) 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数以及输入输出接口。<br> (6) R语言是彻底面向对象的统计编程语言。<br> (7) R语言和其它编程语言、数据库之间有很好的接口。<br> (8) R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。<br> (9) R语言具有丰富的网上资源</p> 
 <p><strong><span style="font-size:18px;">一   入门训练</span></strong></p> 
 <p><strong><span style="font-size:14px;">1. 获取帮助</span></strong><br>     &gt; help.start() 开启帮助文档<br>     &gt;help(solve) 显示某命令的帮助信息，或者<br>     &gt;?solve<br>     对于由特殊字符指定的功能，这些参数必须用单引号或双引号括起来，使之成为一个“字符串”,如<br>     &gt; help("[[")<br>     与某个主题相关的例子通常可以用下面的命令得到<br>     &gt; <strong>example</strong>(topic)</p> 
 <p><strong><span style="font-size:14px;">2. 命令简介</span></strong><br>     R对大小写是敏感的；名称不能以数字开始；<br>     基本的命令由表达式或者赋值语句组成。如果一个表达式被作为一条命令给出，它将被求值、打印而表达式的值并不被保存。一个赋值语句同样对表达式求值之后把表达式的值传给一个变量，不过并不会自动的被打印出来；<br>     命令由分号(;)来分隔，或者另起新行；<br>     基本命令可以由花括号(f和g)合并为一组复合表达式；<br>     注释几乎可以被放在任何地方，只要是以井号( # )开始，到行末结束；<br>     如果一个命令在行莫仍没有结束，R将会给出一个不同的提示符，默认的是‘+’。</p> 
 <p> </p> 
 <p><strong><span style="font-size:14px;">3. 命令文件的执行和输出转向到文件</span></strong></p> 
 <p>如果命令存储于一个外部文件中，比如工作目录work中的commands.R，他们可以随时在R的任务中被执行<br> &gt; <strong>source</strong>("commands.R")在Windows中Source也可以由File菜单执行。<br> 函数sink，<br> &gt; <strong>sink</strong>("record.lis")<br> 将把所有后续的输出由终端转向一个外部文件，record.lis。命令<br> &gt; sink()   将把信息重新恢复到终端上。</p> 
 <p><strong><span style="font-size:14px;">4. 数据的保持与对象的清除</span></strong></p> 
 <p>R所创建、操作的实体是对象。对象可以是变量、数组、字符串、函数以及由这些元素组成的其它结构；<br> &gt; <strong>objects</strong>()     用来显示目前存储在R中的对象的名字。而当前存储的所有对象的组合被称为workspace；<br> 清除对象可以使用rm命令：<br> &gt; <strong>rm</strong>(x, y, z, ink, junk, temp, foo, bar)<br> 所有在一个R任务中被创建的对象都可以在文件中被永久保存，并在其它的R任务中被使用。在每个R任务结束时用户都有机会保存当前有效的所有对象。如果用户这样做的话，对象将被写入当前目录一个名为<strong>.RData</strong>。当R被再次启动时R会从这个文件中再载入workspace。同时相关的命令记录也被载入。<br> 所以，推荐大家在用R进行不同的分析时分别使用不同的工作目录。</p> 
 <p><strong><span style="font-size:14px;">5. 基本数据结构</span></strong></p> 
 <p> </p> 
 <table border="1" cellpadding="2" cellspacing="0"><tbody><tr><td> <p>数值型(numeric）</p> </td><td> <p>1,1.2,3.1415926</p> </td></tr><tr><td> <p>复数型(complex)</p> </td><td> <p>1+2i</p> </td></tr><tr><td> <p>字符型(character)</p> </td><td> <p>‘A’/ “hello world!”</p> </td></tr><tr><td> <p>逻辑型(logical)</p> </td><td> <p>TRUE / FALSE</p> </td></tr></tbody></table> 
 <p><strong><span style="font-size:14px;">6. 基本数据对象</span></strong></p> 
 <p> </p> 
 <p><strong>向量(vector)</strong>, 见下节<br><strong>矩阵(matrix)</strong>： <br> 更一般的说数组是向量在多维情况下的一般形式。事实上它们是可以被两个或更多的指标索引的向量，并且以特定的方式被打印出来。<br><strong>因子(factors) </strong>提供了一种处理分类数据的更简介的方式。<br><strong>列表(list)</strong>：  <br> 是向量的一种一般形式，并不需要保证其中的元素都是相同的类型，而且其中的元素经常是向量和列表本身。<br><strong>数据框(data frame)</strong>：<br> 是一种与矩阵相似的结构，其中的列可以是不同的数据类型。可以把数据框看作一种数据"矩阵"，它的每行是一个观测单位，而且(可能)同时包含数值型和分类的变量。<br><strong>函数( function)</strong>：<br> 能够在R的workspace中存储的对象。我们可以通过函数来扩展R的功能。</p> 
 <p><strong><span style="font-size:18px;">二   简单操作，数值与向量</span></strong></p> 
 <p><strong><span style="font-size:14px;">2.1 向量与赋值</span></strong></p> 
 <p>R对命名了的数据结构进行操作。最简单的数据结构是数字向量；如，<br> &gt; x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7)    c()是创建函数，赋值运算符是'&lt;-'，与函数assign()等价<br> &gt; <strong>assign</strong>("x", c(10.4, 5.6, 3.1, 6.4, 21.7))  也可以写成：<br> &gt; <strong>c</strong>(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; x<br> 如果一个表达式被当作一个完整的命令，它的值将被打印到终端但不被储存。<br> 单独输入x则会将值打印出来。也可以打印倒数：<br> &gt; 1/x<br> &gt; y &lt;- c(x, 0, x)   也可以将向量作为元素。</p> 
 <p><strong><span style="font-size:14px;">2.2 向量运算</span></strong></p> 
 <p>    操作是按照向量中的元素一个一个进行的。同一个表达式中的向量并不需要具有相同的长度。如果它们的长度不同,表达式的结果是一个与表达式中最长向量有相同 长度的向量。表达式中较短的向量会根据它的长度被重复使用若干次(不一定是整数次)，直到与长度最长的向量相匹配。而常数很明显的将被不断重复。如，<br> &gt; v &lt;- 2*x + y + 1<br><strong>常用运算</strong>有：<br> +，-，*，/，<strong>^</strong>（次方）；<br><strong>log, exp, sin, cos, tan,sqrt</strong>等；<br><strong>max和min</strong>的作用是选出所给向量中最大的或最小的元素；<br><strong>range</strong>函数的值是一个长度为2的向量，即c(min(x),max(x))<br><strong>length(x)</strong>返回了向量x中元素的个数，也就是x的长度。<br><strong>sum(x)</strong>给出了x中所有元素的总和；<br><strong>prod(x)</strong>给出x中所有元素的乘积；<br><strong>mean(x)和var(x)</strong>，分别计算样本均值和样本方差，这两个函数分别相当于sum(x)/length(x)，sum((x-mean(x)) \^2)/(length(x) -1)。如果var()的参数是一个n*p的矩阵，那么函数的值是一个p*p的样本<strong>协方差矩阵</strong>，认为每行是一个p变量的样本向量。<br><strong>sort(x)</strong>返回一个与x具有相同长度的向量，其中的元素按招升序排列。还有其他更灵活的排序功能(参见<strong>order()</strong>和<strong>sort.list()</strong>)。<br><strong>pmax</strong>和<strong>pmin</strong>将返回一个与最长的向量长度相等的向量，向量中的元素由参数中所有向量在相应位置的最大值(最小值)组成；<br> 如果要使用<strong>复数</strong>，需要直接给出一个复数部分。因此sqrt(-17)将会返回NaN(无效数值)和一个警告，而sqrt(-17+0i)将按照复数进行运算。</p> 
 <p><strong><span style="font-size:14px;">2.3 生成序列</span></strong></p> 
 <p>最简单的方法是用<strong>冒号</strong>‘：’，冒号具有最高运算优先级。例如1:30就是向量c(1,2,. . .,29,30)。30:1构造一个递减序列。<br> 利用<strong>seq()</strong>函数构造序列：有五个参数，from, to, by, length, along<br>                                        from, to可以不写参数名，seq(2,10)就相当于2:10。<br>                                        by指定步长，默认为1，如seq(-5, 5, by=.2)即为c(-5.0, -4.8, -4.6, ..., 4.6, 4.8, 5.0)<br>                                        length指定序列长度，如seq(length=51, from=-5, by=.2)，等同于seq(-5, 5, by=.2)<br>                                        along=vector只能单独使用，产生一个“1:length(vector)”序列。类似的函数是<strong>rep()</strong>,这个函数可以用多种复杂的方法来                          <br>                                            复制一个对象。最简单的形式是&gt; s5 &lt;- rep(x, times=5)</p> 
 <p><strong><span style="font-size:14px;">2.4 逻辑向量</span></strong></p> 
 <p> </p> 
 <p><strong>TRUE</strong>, <strong>FALSE</strong>, 和<strong>NA</strong>(not available), 前两个可以简写为T和F，但T/F并不是系统保留字，可以被用户覆盖，所以最好还是不要简写。<br><strong>逻辑向量</strong>是由条件给出的，如下列语句令temp成为一个与x长度相同，相应位置根据是否与条件相符而由TRUE或FALSE组成的向量：<br> &gt; temp &lt;- x &gt; 13<br><strong>逻辑操作符</strong>包括&lt;, &lt;=, &gt;, &gt;=,完全相等==和不等于!=，与或非分别为&amp;, |, !。<br> 在普通运算中，FALSE当做0而TRUE当做1。</p> 
 <p><strong><span style="font-size:14px;">2.5 缺失值</span></strong></p> 
 <p><strong>NA</strong>(not available): 一般来讲一个NA的任何操作都将返回NA。<br>      <strong>is.na(x)</strong>返回一个与x等长的逻辑向量，并且由相应位置的元素是否是NA来决定这个逻辑向量相应位置的元素是TRUE还是FALSE。<br>      x==NA是一个与x具有相同长度而其所有元素都是NA的向量。<br><strong>NaN</strong>(Not a Number): 由数值运算产生，如0/0, Inf-Inf.<br>      is.na(x)对于NA和NaN值都返回TRUE，<br>      <strong>is.nan(x)</strong>只对NaN值返回TRUE。</p> 
 <p><strong><span style="font-size:14px;">2.6 字符向量</span></strong></p> 
 <p> </p> 
 <p>字符串在<strong>输入</strong>时可以使用单引号(')或双以号(");  在<strong>打印</strong>时用双引号(有时不用引号)。<br> R使用与C语言风格基本相同的<strong>转义符</strong>, 所以输入\\打印的也是\\, 输入\" 打印引号",  \n: 换行, \t: tab, \b: 回格。<br> 字符向量可以通过函数<strong>c()连接</strong>；<br><strong>paste()</strong>可以接受任意个参数，并从它们中逐个取出字符并连成字符串，形成的字符串的个数与参数中最长字符串的长 度相同。如果参数中包含数字的话，数字将被强制转化为字符串。在默认情况下，参数中的各字符串是被一个空格分隔的，不过通过参数sep=string 用户可以把它更改为其他字符串，包括空字符串。例如：<br> &gt; labs &lt;- paste(c("X","Y"), 1:10, sep="")  使变量labs成为字符变量c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")</p> 
 <p><strong><span style="font-size:14px;">2.7 index vector</span>---数据集子集的选择与修改</strong></p> 
 <p> </p> 
 <p>任何结果为一个向量的表达式都可以通过追加<strong>索引向量(index vector)</strong>来选择其中的子集。<br><strong>1 逻辑的向量</strong>。<br> &gt; y &lt;- x[!is.na(x)]    表示将向量x中的非NA元素赋给y；<br> &gt; (x+1)[(!is.na(x)) &amp; x&gt;0] -&gt; z     表示创建一个对象z，其中的元素由向量x+1中与x中的非缺失值和正数对应的向量组成。<br><strong>2. 正整数的向量</strong><br> &gt; x[6]    是x的第六个元素<br> &gt; x[1:10]       选取了x的前10个元素(假设x的长度不小于10)。<br> &gt; c("x","y")[rep(c(1,2,2,1), times=4)]     产生了一个字符向量，长度为16，由"x", "y", "y", "x"重复4次而组成。<br><strong>3. 负整数的向量</strong><br> &gt; y &lt;- x[-(1:5)]       表示向量y取向量x前5个元素以外的元素。<br><strong>4. 字符串的向量</strong><br> 只存在于拥有names属性并由它来区分向量中元素的向量。这种情况下一个由名称组成的子向量起到了和正整数的索引向量相同的效果。<br> &gt; fruit &lt;- c(5, 10, 1, 20)<br> &gt; names(fruit) &lt;- c("orange", "banana", "apple", "peach")<br> &gt; lunch &lt;- fruit[c("apple","orange")]<br><strong>子集的修改</strong><br> &gt; x[is.na(x)] &lt;- 0    表示将向量x中所以NA元素用0来代替<br> &gt; y[y &lt; 0] &lt;- -y[y &lt; 0]      表示将向量(-y)中 与向量y的负元素对应位置的元素 赋值给 向量y中 与向量y负元素对应的元素。作用相当于：<br> &gt; y &lt;- abs(y)</p> 
 <p><strong><span style="font-size:18px;">三  对象，模式和属性</span></strong></p> 
 <p><strong><span style="font-size:14px;">3.1 固有属性：模式和长度</span></strong></p> 
 <p><strong>对象</strong>是R所进行操作的实体，对象可以是向量、列表等，详见1.6.<br><strong>对象的模式</strong>包括numeri，ccomplex，character，logical，list，function，expression等。可以用<strong>mode(object)</strong>查看。<br><strong>对象的长度</strong>是对象的另一固有属性。可以用length(object)查看。<br><strong>attribute(object)</strong>可以查看更深入的属性。</p> 
 <p><strong>模式的转换</strong><br> 在允许的情况下(大多数情况都是允许的)，R可以完成各种模式的转换。例如：d&lt;-<strong>as.character(z)</strong>，将数值向量z&lt;-(0:9)转化为字符向量c("0", "1", "2", ..., "9")。as.integer(d)将d转化为数值向量。<br> R中很多形式为<strong>as.something()</strong>的函数，可以完成从一个模式向另一个模式的转化，或者是令对象取得它当前模式不具有的某些属性。</p> 
 <p><strong><span style="font-size:14px;">3.2 改变对象的长度</span></strong></p> 
 <p>&gt; e &lt;- <strong>numeric()</strong>    产生一个numeric型的<strong>空向量</strong>e。<strong>character()</strong>等类似。此时长度为对象0。<br> 此时新添加一个元素会使e的<strong>长度自动调整</strong>。<br> &gt; e[3] &lt;- 17    令e为一个长度为3的向量（此时，该向量的前两个元素都是NA）<br><strong>缩短</strong>（截断）一个对象的长度，只需要一个赋值命令。因此，若alpha是一个长度为10的对象，下面的命令<br> &gt; alpha &lt;- alpha[2 * 1:5]</p> 
 <p><strong><span style="font-size:14px;">3.3 属性的获取和设置</span></strong></p> 
 <p> </p> 
 <p>函数<strong>attributes(object)</strong>将给出当前对象所具有的所有非基本属性（长度和模式属于基本属性）的一个列表。<br> 函数<strong>attr(object,name)</strong>可以被用来选取一个指定的属性。除了为某些特殊的目的创建新属性这样特殊的环境下，这些函数很少被用到。<br> 当函数attr()用在赋值语句左侧时，既可以是将对象与一种新的属性关联，也可以是对原有<strong>属性的更改</strong>。例如<br> &gt; attr(z,"dim") &lt;- c(10,10)         另R将z作为一个10X10的矩阵看待。</p> 
 <p><strong><span style="font-size:14px;">3.4 对象的类别</span></strong></p> 
 <p>对象的一个特别属性，类别，被用来指定对象在R编程中的风格。比如：如果对象类别"<strong>data.frame</strong>"则会以特定方式处理。<br><strong>unclass()</strong>可以去除对象的类别。<br><strong>summary()</strong>可以查看对象的基本信息（min, max, mean, etc.）</p> 
 <p><strong><span style="font-size:18px;">四  有序因子和无序因子</span></strong></p> 
 <p> </p> 
 <p><strong>因子</strong>是一种向量对象，它给自己的组件指定了一个离散的分类（分组），它的组件由其他等长的向量组成。R提供了有序因子和无序因子。<br> 通俗点说，因子就是将对象的值<strong>分成不同的组</strong>（<strong>levels</strong>）。<br> 用函数<strong>factor()创建</strong>一个因子，levels按序排列(字母序或数值序)。</p> 
 <p>例如province&lt;-c("四川","湖南","江苏","四川","四川","四川","湖南","江苏","湖南","江苏")，为province创建因子：<br> &gt; pf&lt;-factor(province)   创建province的因子pf<br> &gt; pf     打印出来<br>  [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏<br> Levels: 湖南 江苏 四川<br><strong>函数levels()</strong>可以用来观察因子中有多少不同的levels。</p> 
 <p>假如我们拥有这些省份考生的分数：<br> &gt; score&lt;-c(95,86,84,92,84,79,86,99,85,90)<br><strong>函数tappley()</strong>可以用来计算各省的平均分数，函数tapply()的作用是对它第一个参数的组件中所包含的每个组应用一个参数三指定的函数。<br> &gt; smeans&lt;-tapply(score,pf,mean)<br> &gt; smeans<br>     湖南     江苏     四川 <br> 85.66667 91.00000 87.50000 <br> 再例如，下面命令会给出各组的length<br> &gt; tapply(score,pf,length)<br> 湖南 江苏 四川 <br>    3    3    4 </p> 
 <p> </p> 
 <p><strong>函数ordered()</strong>可以创建有序因子<br> &gt; ordered(province)<br>  [1] 四川 湖南 江苏 四川 四川 四川 湖南 江苏 湖南 江苏<br> Levels: 湖南 &lt; 江苏 &lt; 四川</p> 
 <p> </p> 
 <p><strong><span style="font-size:18px;">五 数组和矩阵</span></strong></p> 
 <p><strong><span style="font-size:14px;">5.1 数组</span></strong></p> 
 <p><strong>数组</strong>可以看成一个由递增下标表示的数据项的集合，例如数值。<br><strong>数组的生成</strong><br> 如果一个向量需要在R中以数组的方式被处理，则必须含有一个<strong>维数向量</strong>作为它的dim属性。<br> 维度向量由<strong>dim()</strong>指定，例如，z是一个由1500个元素组成的向量。下面的赋值语句<br> &gt; dim(z) &lt;- c(3,5,100)        使它具有dim属性，并且将被当作一个3X5X100的数组进行处理。 c(3,5,100) 就是他的维度向量。<br> 还可以用到像<strong>matrix()</strong>和<strong>array()</strong>这样的函数来赋值。比如<br> &gt; array(1:20, dim=c(4,5))<br> &gt; matrix(1:24, 3,4)<br> 数据向量中的值被赋给数组中的值时，将遵循与FORTRAN相同的原则<strong>"主列顺序"</strong>，即第一个下标变化的最快，最后的下标变化最慢。<br><strong>数组的运算</strong><br> 数组可以在算数表达式中使用，结果也是一个数组，这个数组由数据向量逐个元素的运算后组成，通常参与运算的对象应当具有相同的dim属性。</p> 
 <p><strong><span style="font-size:14px;">5.2 数组的索引和数组的子块</span></strong></p> 
 <p> </p> 
 <p>数组中的<strong>单个元素</strong>可以通过下标来指定，<strong>下标由逗号分隔</strong>，写在<strong>括号</strong>内。<br> 我们可以通过在下标的位置给出一个<strong>索引向量</strong>来指定一个数组的<strong>子块</strong>，不过如果在任何一个索引位置上给出空的索引向量，则相当于选取了这个下标的全部范围。<br> 如a[2,,]，a[,3,]等</p> 
 <p><strong><span style="font-size:14px;">5.3 索引数组</span></strong></p> 
 <p>除了索引向量，还可以使用<strong>索引数组</strong>来指定数组的某些元素。<br> 例如：有4X5的数组a，若要得到a中的a[1,3], a[2,2] 和a[3,1]这三个元素，可以生成索引向量i，然后用a[i]得到它们。<br> &gt; a &lt;- array(1:20,dim=c(4,5)) # Generate a 4 by 5 array.<br> &gt; i &lt;- array(c(1:3,3:1),dim=c(3,2))<br> &gt; i<br> [,1] [,2]<br> [1,] 1 3<br> [2,] 2 2<br> [3,] 3 1<br> &gt; a[i]<br> [1] 9 6 3<br> &gt; a[i] &lt;- 0   # 将这三个元素用0替换。</p> 
 <p><strong><span style="font-size:14px;">5.4 向量，数组的混合运算</span></strong></p> 
 <p>表达式从左到右被扫描；<br> 参与运算的任意对象如果大小不足，都将被重复使用直到与其他参与运算的对象等长；<br> 当较短的向量和数组在运算中相遇时，所有的数组必须具有相同的dim属性，否则返回一个错误；<br> 如果有任意参与运算的向量比参与运算的矩阵或数组长，将会产生错误；<br> 如果数组结构正常声称，并且没有错误或者强制转换被应用于向量上，那么得到的结果与参与运算的数组具有相同的dim属性。</p> 
 <p><strong><span style="font-size:14px;">5.5 矩阵的运算</span></strong></p> 
 <p><strong>构建分区矩阵：cbind()和rbind()</strong>，cbind()按照水平方向，或者说按列的方式将矩阵连接到一起。rbind()按照垂直的方向，或者说按行的方式将矩阵连接到一起。</p> 
 <p> </p> 
 <p><strong>外积：</strong>操作符是<strong>%o%</strong>:<br> &gt; ab &lt;- a %o% b   或者<br> &gt; ab &lt;- <strong>outer(a, b, "*")</strong><br> 其中的乘法操作可以由任意一个双变量的函数替代。</p> 
 <p><strong>广义转置：</strong>函数<strong>t(A)</strong>，或<strong>aperm</strong>(A, c(2,1))；</p> 
 <p><strong>获取行数/列数</strong>：<strong>nrow</strong>(A)和<strong>ncol</strong>(A)分别返回矩阵A的行数和列数。</p> 
 <p><strong>矩阵乘法：</strong>操作符为<strong>%*%；</strong></p> 
 <p><strong>交叉乘积</strong>（cross product）：<strong>crossprod</strong>(X，Y)等同于t(X) %*% y，crossprod(X)等价于crossprod(X, X)；</p> 
 <p><strong>diag(v)</strong>：如果v是向量，diag(v)返回一个由v的元素为对角元素的对角矩阵。<br>                如果v为矩阵，diag(v)返回一个由v主对角元素组成的向量。<br>                如果v只是一个数值，那么diag(v)是一个vXv的单位矩阵。</p> 
 <p> </p> 
 <p><strong>特征值和特征向量</strong>：<strong>eigen</strong>(Sm)。这个函数的结果是由名为values和vectors的两部分组成的列表。如果只是需要特征值：eigen(Sm)$values</p> 
 <p><strong>最小二乘拟合即QR分解</strong>：lsfit(), qr()。</p> 
 <p><strong>强制转换</strong>为向量：as.vector()，或者直接c().</p> 
 <p>解<strong>线性方程</strong>和求矩阵的<strong>逆，奇异值分解</strong>与<strong>行列式</strong>见&lt;R语言笔记&gt;；</p> 
 <p><strong><span style="font-size:18px;">六  列表和数据帧</span></strong></p> 
 <p><strong><span style="font-size:14px;">6.1 列表</span></strong></p> 
 <p>列表是由称作组件的有序对象集合构成的对象。组件的模式或类型不一定相同。<br> 形如Lst &lt;- <strong>list(name_1=object_1, . . ., name_m=object_m)</strong>的赋值将创建一个包含m个组件的列表，并根据参数中指定的名称为其命名。（其名称可以自由选取）。如果它们的名称被省略，组件将只是被编号。例如：<br> &gt; Lst &lt;- <strong>list</strong>(name="Fred", wife="Mary", no.children=3,child.ages=c(4,7,9))</p> 
 <p>所使用的组件是被<strong>复制</strong>到新的列表中的，对原始对象没有影响。<br> 组件总是被<strong>编号</strong>的，并且可以通过编号指定。<br><strong>Lst[[1]]</strong> 即为"Fred"，也可以用<strong> Lst$name</strong>，<strong>Lst[["name"]]</strong>指定。如果Lst[[4]]是一个有下标的数组，<strong>Lst[[4]][1]</strong>就是它的第一项。<br><strong>区分Lst[[1]]和Lst[1]</strong>，'[[...]]'是选择单个元素时使用的操作符，而'[...]'是一个一般的下标操作符。因此，前者代表列表Lst中的第一个对象；后者是列表Lst的子列表，仅包含列表的第一项。<br> 组件的名称可以<strong>缩写</strong>，可缩写的程度是只要能令组件被唯一的识别就可以了。如：Lst$na等价于Lst$name， Lst$w等价于Lst$wife。</p> 
 <p><strong>扩展列表</strong><br> 可以通过指定额外组件的方式<strong>。</strong>例如<br> &gt; Lst[5] &lt;- list(matrix=Mat)</p> 
 <p><strong>连接列表</strong><br> 当连接函数c()的参数为列表时，其结果也是一个模式为列表的对象。由参数中的列表作为组件依次连接而成。<br> &gt; list.ABC &lt;- c(list.A, list.B, list.C)</p> 
 <p><strong><span style="font-size:14px;">6.2 数据帧</span></strong></p> 
 <p> </p> 
 <p>数据帧是类别为"data.frame"的列表；<br> 数据帧会被当作各列具有不同模式和属性的矩阵。<br> 数据帧按照矩阵的方式显示，选取的行或列也按照矩阵的方式来索引。</p> 
 <p><strong>创建数据帧</strong></p> 
 <p><strong>直接创建</strong>：那些满足对数据帧的列（组件）限制的对象可以通过函数<strong>data.frame</strong>来构建成为一个数据帧<br> &gt; t &lt;- data.frame(home=statef, loot=income, shot=incomef)<br><strong>强制转换</strong>：如果一个列表的组件与数据帧的限制一致，这个列表就可以通过函数<strong>as.data.frame()</strong>强制转化为一个数据帧。<br><strong>外部文件</strong>：创建数据帧最简单的方法应当是使用read.table()函数从外部文件中读取整个数据帧。</p> 
 <p><strong>数据帧和列表的限制</strong></p> 
 <p>1 组件必须是向量（数值型，字符形，逻辑型），因子，数值矩阵，列表，或其他数据帧；<br> 2 矩阵，列表，数据帧向新数据帧提供的变量数分别等于它们的列数，元素数和变量数；<br> 3 数值向量，逻辑值和因子在数据帧中保持不变，字符向量将被强制转化为因子，其水平是字符向量中所出现的值；<br> 4 数据帧中作为变量的向量结构必须具有相同的长度，而矩阵结构应当具有相同的行大小。</p> 
 <p> </p> 
 <p><strong>挂接和卸载数据帧</strong></p> 
 <p>当觉得使用'$'引用数据帧元素(如't$home')麻烦时，可以进行数据帧挂接<br> &gt; <strong>attach(t)</strong>      这样可以直接引用数据帧内的元素，而无需'$'，前提是数据帧外没有同名的变量(如name)。<br> 挂接后若要对数据帧元素进行赋值操作，仍需用'$'，否则视为赋值给数据帧外的元素。<br> 赋值后必须要先卸载(detach)再重新挂接后，新值才可见。<br> &gt; <strong>detach(t)</strong></p> 
 <p> </p> 
 <p><strong>attach()</strong>是具有一般性的函数，即它不仅能够将目录和数据帧挂接在<strong>搜索路径</strong>上，还能挂接其他类别的对象。特别是模式为"list"的对象可以通过相同的方式挂接：<br> &gt; attach(any.old.list)     <br> 任何被挂接的对象都可以用<strong>detach</strong>来卸载，通过指定位置编号或者指定名称这样的方式.</p> 
 <p><strong>搜索路径</strong><br> 函数search()将显示目前的搜索路径，可以用来查看数据帧/列表的挂接状态。<br><strong>ls()</strong>（或objects()）命令可以用来检查搜索路径任意位置上的内容。如：ls(), ls(2), ls(t)<br> R可以在搜索路径中包含至多20个项目,列表和数据帧只能在位置2或更靠后的位置上挂接。</p> 
 <p> </p> 
 <p><strong>数据帧使用惯例</strong></p> 
 <p> </p> 
 <p>1 将每个独立的，适当定义的问题所包含的所有变量收入同一个数据帧中，并赋予合适的、易理解、易辨识的名称；<br> 2 处理问题时，当相应的数据帧挂接于位置2，同时在第1层工作目录下存放操作的数值和临时变量；<br> 3 在结束一次工作之前，将你认为对将来有参考价值的变量通过$标记的形式添加到数据帧里面，然后detach()；<br> 4 最后，将工作目录下所有不需要的变量剔除，并且尽量将剩下多余的临时变量都清除干净。<br> 这样我们可以很简单的在同一个目录下处理多个问题，而且对每个问题都可以使用x,y,z这样的变量名。</p> 
 <p><strong><span style="font-size:18px;">七  从文件中读取数据</span></strong></p> 
 <p><strong><span style="font-size:14px;">7.1 函数read.table()</span></strong></p> 
 <p>该函数可以直接将文件中完整的数据帧读入。此时文件要符合<strong>特定的格式</strong>：<br> 1 第一行应当提供数据帧中每个变量的名称；<br> 2 每一行(除变量名称行)应包含一个行标号和各变量的值。<br> 3 若没有表头(变量名称行)，也没有行标号，只有变量值，则默认变量名称为"v1","v2"...<br> 4 若有表头，但没有行标号，则可以指定参数header=TRUE.</p> 
 <p><strong><span style="font-size:14px;">7.2 函数scan()</span></strong></p> 
 <p>该函数从键盘或文件中读取数据，并存入向量或列表中。<br> &gt; inp &lt;- <strong>scan(file, what)</strong><br> 第一个参数是文件名,如“test.txt”，若为“”或空，则从键盘读入数据；<br> 第二个参数用于确定读入数据的模式。  如：list("",0,0) 指定读入到列表中，列表有三项，且列表第一项是字符型，第二三项是数值型。若为0，则指定读入到一个数值向量中，若为“”则指定读入到字符向量中。</p> 
 <p><strong><span style="font-size:14px;">7.3 内置数据集的读取</span></strong></p> 
 <p> </p> 
 <p><strong>R本身提供超过50个数据集</strong>，同时在功能包（包括标准功能包）中附带更多的数据集。与S-Plus不同，这些数据即必须通过<strong>data函数载入</strong>。<br> &gt; data()   #获得基本系统提供的数据集列表，然后通过形如<br> &gt; data(infert)    #来载入名为infert的数据集</p> 
 <p><strong>从其他package中载入数据集</strong><br> data(package="nls")      #查看nls中数据集<br> data(Puromycin, package="nls")     #读取nls中Puromycin数据集。<br> 用library()挂接package后，它的数据集也自动包含到搜索路径中了。<br> library(nls)    #载入package nls<br> data()      #查看数据集<br> date(Puromycin)    #载入Puromycin数据集</p> 
 <p> </p> 
 <p><strong><span style="font-size:14px;">7.4  编辑数据</span></strong></p> 
 <p>在使用一个数据帧或矩阵时，<strong>edit</strong>提供一个独立的工作表式编辑环境。<br> &gt; xnew &lt;- edit(xold)       #对数据集xold进行编辑。并在完成时将改动后的对象赋值给xnew<br> &gt; xnew &lt;- edit(data.frame())        #可以通过工作表界面录入新数据。</p> 
 <p><strong>fix()</strong>函数用于直接修改已有的对象，等价于  x&lt;-edit(x).</p> 
 <p><strong><span style="font-size:18px;">八 概率分布</span></strong></p> 
 <p><strong><span style="font-size:14px;">8.1 R是一个统计表集合</span></strong>(略读)</p> 
 <p> </p> 
 <p>R提供了一套完整的统计表集合。函数可以对累积分布函数P(X&lt;=x)，概率密度函数，分位函数（对给定的q，求满足P(X&lt;=x) &gt; q的最小x）求值，并根据分布进行模拟。<br><img alt="" src="https://images2.imgbox.com/62/56/zjjnGahi_o.png"><br> 对于所给的名称，加前缀'd'代表密度(density)，'p'代表CDF，'q'代表分位函数，'r'代表模拟（随即散布）。这几类函数的第一个参数 是有规律的，形为dxxx的函数为x，pxxx的函数为q，qxxx的函数为p，rxxx的函数为n（rhyper和rwilcox是特例，他们的第一个 参数为nn）。目前为止，非中心参数(non-centrality parameter)仅对CDF和少数几个其他函数有效，细节请参考在线帮助。<br> 所有pxxx和qxxx的函数都具有逻辑参数lower.tail和log.p，而所有的dxxx函数都有参数log，这个是我们可以直接通过<br> - pxxx(t, ..., lower.tail = FALSE, log.p = TRUE)<br> 获取，比如说，累积失效函数（cumulative/integrated hazard function），H(t) =-log(1-F(t))，以及更精确的对数似然（通过dxxx(..., log = TRUE)）。<br> 此外，对于来自正态分布，具有学生化样本区间的分布还有ptukey和qtukey这样的函数。下面是一些例子<br> &gt; ## 2-tailed p-value for t distribution<br> &gt; 2*pt(-2.43, df = 13)<br> &gt; ## upper 1% point for an F(2, 7) distribution<br> &gt; qf(0.99, 2, 7)</p> 
 <p><strong><span style="font-size:14px;">8.2 检测数据集的分布</span></strong></p> 
 <p> </p> 
 <p>函数<strong>summary</strong>和<strong>fivenum</strong>这两个函数可以给出摘要，后者只给出数值；<br> 函数<strong>stem</strong>可以将数值统计结果以类似直方图的方式显示出来；<br> 函数<strong>hist</strong>()可以绘制直方图；<br> 函数density和line可以获得更漂亮的密度图；<br> 功能包<strong>fun</strong>中的<strong>ecdf</strong>函数能绘制经验累积分布函数；<br> 还可以进行拟合正态分布，覆盖拟合<strong>CDF</strong>；<br> 还可以绘制Quantile-quantile <strong>(Q-Q)图</strong>有助于我们更细致的检测其分布形态；</p> 
 <p><strong>8.3 单样本和两样本检验</strong>（略读）</p> 
 <p><strong><span style="font-size:18px;">九  语句组、循环和条件操作</span></strong></p> 
 <p> </p> 
 <p>R是一种表达式语言，也就是说其命令类型只有函数或表达式，并由它们返回一个结果。<br> 语句组由花括号‘<strong>{ }</strong>’确定，此时结果是该组中最后一个能返回值的语句的结果。</p> 
 <p><strong><span style="font-size:14px;">条件语句</span></strong></p> 
 <p>&gt;<strong> if (expr_1) expr_2 else expr_3 </strong><br> 其中条件表达式expr1必须返回一个逻辑值，操作符&amp;&amp;和||经常被用于条件部分。<br><strong>&amp;和|与&amp;&amp;</strong>，||的区别在于，&amp;和|按照逐个元素的方式进行计算，&amp;&amp;和||对向量的第一个元素进行运算，只有在必需的时候才对第二个参数求值。<br> if/else结构的<strong>向量版本</strong>是函数ifelse，其形式为<strong>ifelse (condition,a,b)</strong>，产生函数结果的规则是：如果condition[i]为真，对应a[i]元素；反之对应的是b[i]元素。根据这个原则函数返回一个由a,b中相应元素组成的向量，向量长度与其最长的参数等长。</p> 
 <p><strong><span style="font-size:14px;">循环语句</span></strong></p> 
 <p>&gt; <strong>for (name in expr_1) expr_2</strong><br> 其中name是循环变量，expr1是一个向量表达式（通常是1:20这样的序列），而expr2经常是一个表达式语句组，expr2随着name依次取expr1结果向量的值而被多次重复运行。</p> 
 <p>&gt; <strong>repeat</strong>(expr)</p> 
 <p>&gt; <strong>while</strong>(condition) expr</p> 
 <p> </p> 
 <p><strong>break</strong>语句可以用来中断任何循环，可能是非正常的中断。而且这是中止repeat循环的唯一方式。</p> 
 <p><strong>next</strong>语句可以中止一个特定的循环，跳至下一个.</p> 
 <p><strong><span style="font-size:18px;">十 编写自己的函数</span></strong></p> 
 <p><strong>10.1 函数的定义</strong></p> 
 <p>&gt; name &lt;- function(arg_1, arg_2, ...) expression <br> expression是一个R表达式（通常是表达式语句组），并使用参数arg_i来计算出一个数值，表达式的值就是函数的返回值。<br><strong>函数调用</strong>的形式通常都是name(expr1,expr2,...)</p> 
 <p><strong>10.2 定义新的二元操作符</strong></p> 
 <p>可以将函数定义为新的二元操作符：<br> &gt; <strong>"%!%" &lt;- function(X, y) { ... }</strong><br> 正如矩阵乘法运算符，%*%，和矩阵外积运算符%o%</p> 
 <p><strong>10.3 指定参数和默认值</strong></p> 
 <p> </p> 
 <p>如果被调用函数的参数按照"name = obj"的形式给出，那么参数的次序可以是任意的。<br> 而且，参数序列可以在开始依次序给出，而将指定名称的参数置于后面。<br> 因此，如果由一个函数fun1被定义为<br> &gt; fun1 &lt;- function(data, data.frame, graph, limit) {<!-- --><br> [function body omitted]<br> }<br> 那么函数可以有多种等价的使用方法，例如<br> &gt; ans &lt;- fun1(d, df, TRUE, 20)<br> &gt; ans &lt;- fun1(d, df, graph=TRUE, limit=20)<br> &gt; ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df)<br><strong>默认值 ：</strong>在很多情况下，参数都会被赋予一个普遍适用的默认值。<br> &gt; fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { ... }<br> 则函数可以这样被调用<br> &gt; ans &lt;- fun1(d, df)<br> 此时与上面三种情况等价，也可以这样调用<br> &gt; ans &lt;- fun1(d, df, limit=10)<br> 此时改变了一个默认值。<br> NOTE：<strong>参数可以是任意表达式</strong>，甚至可以是包含其他参数的表达式；</p> 
 <p><strong>10.4 额外参数“...”</strong></p> 
 <p> </p> 
 <p>当需要将一个函数的参数传递给另一个函数时，可以通过包含一个额外的参数"..."实现。<br> fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, ...) {<!-- --><br> [omitted statements]<br> if (graph)<br> par(pch="*", ...)<br> [more omissions]<br> }</p> 
 <p><strong>10.5 全局变量和局部变量</strong></p> 
 <p>函数内的赋值都是局部变量，退出函数就丢失了。<br> 如果要在函数内进行永久赋值（定义全局变量），需要用到“超赋值”操作符, &lt;&lt;-或者函数assign()。</p> 
 <p><strong>10.6 一些高级示例</strong></p> 
 <p>区组设计的效率因子 (E±ciency factors)<br> 删除打印数组中的所有名称<br> 递归的数值积分</p> 
 <p><strong>10.7 范畴（Scope）</strong></p> 
 <p> </p> 
 <p>函数主体内出现的标识(symbol)可以被分为3类；正式参数、局部变量和自由变量。<br><strong>正式参数</strong>就是出现在函数参数列表中的参数，他们的值由实际的函数参数与正式参数的绑定（binding）过程决定。<br><strong>局部变量</strong>是在参数主体中，由表达式求值过程决定的变量。<br><strong>自由变量</strong>为既不是正式参数又不是局部变量的变量。赋值之后自由变量成为局部变量。</p> 
 <p> </p> 
 <p>在R中，自由变量的值由函数被创建的环境中与其同名的第一个变量值决定（我理解为最近的同名变量），这种方式被称为<strong>词汇式范畴(lexical scope)。</strong><br> 而在S中，该值由同名的全局变量决定。<br> 例如下面的函数cube，在R中cube（2）=8，在S中报错为sq()找不到n。<br> cube &lt;- function(n) {<!-- --><br> sq &lt;- function() n*n<br> n*sq()<br> }</p> 
 <p>一个银行账户的例子，详见《R语言笔记》。</p> 
 <p><strong>10.8 定制环境</strong></p> 
 <p>详见《R语言笔记》。</p> 
 <p><strong>10.9 类别，通用函数和对象定位</strong></p> 
 <p> </p> 
 <p>一个对象的类别(class)决定了他会如何被通用函数(generic function)处理。<br> 如果参数本身没有任何类别属性，或者其类别在特定问题中并不满足通用函数的要求，通常会有一个默认的动作被执行。<br> 类别机制使用户可以为特定的目的设计和编写通用函数。<br> 使用&gt; methods(class="data.frame")可以查看数据帧的通用函数。<br> 使用&gt; methods(plot)可以查看plot函数能处理的类别。</p> 
 <p><span style="font-size:18px;"><strong>十一   R的统计模型</strong></span></p> 
 <p>待阅。<br><br><img alt="" src="https://images2.imgbox.com/e5/bb/om6Wzz3B_o.png"></p> 
 <p><strong><span style="font-size:18px;">十二 图形过程</span></strong></p> 
 <p>在Windows下用window()命令可以打开图形窗口。</p> 
 <p><strong><span style="font-size:14px;">12.1 高级绘图命令</span></strong></p> 
 <p> </p> 
 <p>    高级绘图函数，由函数参数提供数据生成一幅完整的图形。其中适当的坐标轴，标签和标题都自动生成了（除非你另外指定了）。高级绘图命令每次都生成一幅新的图形，清除当前的图形（如果需要的话）。</p> 
 <p><strong>1  plot()函数</strong></p> 
 <p> </p> 
 <p>这是一个通用函数：生成图形的类型取决于第一个参数的类型或类别(class)。<br> plot(x,y)  plot(xy)：<br> 如果x，y是向量，plot(x,y)生成一幅y对x的散点图。用包含两个元素x，y的一个列表或一个两列的矩阵作为一个参数（第二种形式那样的）也能达成相同的效果。<br> plot(x)：<br> 如果x是一个时间序列，这个命令生成一个时间序列图，如果x是一个数值型向量，则生成一个向量值对它们向量索引的土，而如果x是一个复向量，则生成一个向量中元素的虚部对实部的图。<br> plot(f)   plot(f,y)：<br> f是一个因子对象，y是一个数值型向量。第一种形式生成一个f的条形图；第二种形式生成y对应于f各个水平的箱线图。<br> plot(df)   plot( expr)    plot(y expr)：<br> df是一个数据帧，y是任意对象，expr是由对象名称组成的列表，分隔符'+'(例如，a + b + c)。前两种形式生成分布式的图形，第一种是数据帧中的变量，第二种是一系列被命名的对象。第三种形式生成y对expr中每个对象的图。</p> 
 <p><strong>2 显示多元数据</strong></p> 
 <p> </p> 
 <p>如果X是一个数值矩阵或数据帧，下面的命令<br> &gt; <strong>pairs</strong>(X) <br> 生成一个配对的散点图矩阵，矩阵由X中的每列的列变量对其他各列列变量的散点图组成，得到的矩阵中每个散点图行、列长度都是固定的。</p> 
 <p> </p> 
 <p>当问题涉及到三、四个变量时，使用coplot更好些。如果a和b是数值向量，c是数值向量或因子对象（全都是相同长度的），下面的命令<br> &gt; <strong>coplot</strong>(a ~ b | c)<br> 对应c的某些给定值生成数个a对b的散点图。当c是一个因子时，这个命令也就是对c的每个水平生成a对b的散点图。当c是数值向量的时候，这个数值向量被 分为一系列的条件区间（conditioning intervals），对应c的每个区间生成一个a对b的散点图。区间的数量和位置可以通过coplot()的参数<strong>given.values</strong>来控制，函数<strong>co.intervals()</strong>也可以用来选择区间。我们也可以使用两个给定变量通过命令<br> &gt;coplot(a ~ b | c+d)<br> 对c和d的每个联合条件区间生成a对b的散点图。</p> 
 <p> </p> 
 <p>函数coplot()和pairs()都可以使用参数<strong>panel</strong>=，这个参数可以用来定制我们得到的图形类型。默认的是points()函数，生成一个散点图，不过通过在参数panel=中提供某些其它的低级图形函数，我们可以生成需要的各种图形。一个很有用的函数例子是<strong>panel.smooth()</strong>。</p> 
 <p><strong>3 显示图形</strong></p> 
 <p> </p> 
 <p><strong>qqnorm</strong>(x)   <strong>qqline</strong>(x)    <strong>qqplot</strong>(x,y)<br><strong>分布比较图</strong>。第一种形式生成向量x对期望正态分数（一个正态记分图），第二个在上面的图上添加一条穿过分布分位点和数据分位点的直线。第三个命令生成x的分位点对y分位点图，用于分别比较它们的分布。</p> 
 <p><strong>hist</strong>(x)     hist(x,nclass=n)       hist(x,breaks=b, . . . )<br> 生成数值变量x的<strong>直方图</strong>。通常会自动选定一个合理的类别数，不过可以通过nclass=参数来指定一个推荐值。或者通过参数breaks=来指定分界点。如果给定了probability=TRUE参数，那么条形图代表相对频数而不是累计数。</p> 
 <p><strong>dotchart</strong>(x, . . . )<br> 创建一个x中数据的<strong>点图</strong>(dotchart)。点图中y轴给出x中数据的标签，x轴给出它们的值。它允许对落入某一特定区间的所有数据项方便的进行可视化选择。</p> 
 <p><strong>image</strong>(x,y,z, . . . )     <strong>contour</strong>(x,y,z, . . . )    <strong>persp</strong>(x,y,z, . . . )<br> 生成三个变量的图。函数image是用不同的颜色绘制一些矩形方格来展示z的值，函数contour通过绘制等高线来展示z的值，函数persp绘制一个3D面。</p> 
 <p><strong>4 参数配置</strong></p> 
 <p> </p> 
 <p><strong>add</strong>=TRUE      强制函数按照低级图形函数的方式操作，将图形置于当前图形上（仅对某些函数有效）。<br><strong>axes</strong>=FALSE       暂时禁止坐标轴的生成|以便使用axis()函数添加你自己定制的坐标轴。默认情况是axes=TRUE，即包含坐标轴。<br><strong>log</strong>="x"   log="y"   log="xy"      令x,y或者两者全都对数化。这个参数对许多函数都有效，不过不是全部。<br><strong>type</strong>=          参数type=控制所生成图形的类型：<br>         type="p" 绘制单独的点（默认值）<br>         type="l" 绘制线<br>         type="b" 绘制由线连接的点（both）<br>         type="o" 将点绘在线上<br>         type="h" 绘制从点到零轴的垂线（high-density）<br>         type="s" 阶梯式图。第一种形式中，点由垂线的顶部定义；第二种形式里用底部定义。<br>         type="n" 不绘制。不过坐标轴是绘出的（默认情况）而且要根据数据绘出坐标系统。用来给后续的低级图形函数创建图形作基础。<br><strong>xlab</strong>=string    <strong>ylab</strong>=string          x轴或y轴的标签。使用这些参数来改变默认的标签，通常的默认值是调用高级绘图函数时所使用对象的名称。<br><strong>main</strong>=string          图表标题，位于图形的顶部，大字体显示。 <br><strong>sub</strong>=string         子标题，位于x轴下面，用较小的字体显示。</p> 
 <p><strong><span style="font-size:14px;">12.2   低级绘图命令</span></strong></p> 
 <p> </p> 
 <p>有些时候高级绘图函数并不能很精确的生成我们想要的图形。这种情况下，我们可以通过低级绘图命令在当前图形上添加信息（例如，点、线或文本）。</p> 
 <p><strong>points</strong>(x,y)    <strong>lines</strong>(x,y)<br> 在当前图形上<strong>添加点或线</strong>。函数plot()的参数type=也可以用于这些函数（默认的是"p"代表points()和"l"代表lines()）。</p> 
 <p><strong>text</strong>(x,y,labels, . . . )<br> 给定点坐标x,y，在该点<strong>添加文本</strong>。通常labels是一个整数或字符向量，其中labels[i]出现在点(x[i],y[i])。默认值是1:length(x)。<br> Note： 这个函数通常用于这样的序列中<br>  &gt; plot(x, y, type="n"); text(x, y, names)<br> 图形参数type="n"阻止了点的生成，但是建立了坐标轴，由函数text()提供字符向量names所指定的特定字符。</p> 
 <p> </p> 
 <p><strong>abline</strong>(a, b)   abline(h=y)   abline(v=x)    abline(lm.obj)<br> 在当前图上<strong>添加</strong>一条斜率为b，截距为a的<strong>直线</strong>。h=y在图形指定的高度上绘制一条贯穿图形的<strong>水平线</strong>，同样的，v=x在x轴的指定位置绘制一条贯穿的<strong>垂线</strong>。而lm.obj是一个包含coefficients组件的列表，该组件的长度为2，分别当作截距和斜率。</p> 
 <p><strong>polygon</strong>(x, y, . . . )<br> 绘制一个<strong>多边形</strong>，其顶点由(x,y)指定。同时还（可选的）可以加上阴影线，如果图形设备允许的话还可以将多边形填充。</p> 
 <p><strong>legend</strong>(x, y, legend, . . . )<br> 这当前图形的指定位置<strong>添加图例</strong>。绘制的字符，线条类型，颜色等等由字符向量legend指定。除此之外至少还要给出一个参数v，与绘图单元的相应值，分别有：<br> legend( , fill=v)填充方框的颜色<br> legend( , col=v)绘制点线的颜色<br> legend( , lty=v)线条类型<br> legend( , lwd=v)线条宽度<br> legend( , pch=v)绘制字符(字符向量)</p> 
 <p> </p> 
 <p><strong>title</strong>(main,sub)<br> 在当前图形的顶部用大字题添加一个标题main，在底部用较小的字体添加子标题sub。</p> 
 <p><strong>axis</strong>(side, . . . )<br> 在当前图形的指定边上<strong>添加坐标</strong>，在哪个边上由第一个参数指定（1到4，从底部按照顺时针顺序）。其他参数控制坐标的位置|在图形内或图形外，以及标记的位置和标签。适合在调用参数为axes=FALSE的函数plot()后添加定制的坐标轴。</p> 
 <p>低级绘图函数通常都需要一些位置信息（例如，x,y坐标）来决定在哪里添加新的元素。坐标以<strong>用户坐标</strong>(user coordinates)的形式给出，这个坐标系是根据所提供的数据由之前的高级绘图语句定义的。需要x,y参数的地方还可以选用一个单独的参数，即一个由名为x,y的元素组成的列表。相似的，一个两列的矩阵也可以。像<strong>locator</strong>()（后面会提到）这样的函数也可以按照这种方式交互的指定图形中的位置。</p> 
 <p><strong>添加数学注释</strong><br> 某些情况下需要在图形中加入数学符号或公式。在R中可以通过在text, mtext,axis或title中指定一个表达式来实现。例如，下面的代码绘制了二项概率函数的公式：<br> &gt; text(x, y, expression(paste(bgroup("(", atop(n, x), ")"),p^x, q^{n-x})))<br> 更多的信息，包括其特性的一个完整列表可以在R中通过下面的命令得到：<br> &gt; help(<strong>plotmath</strong>)<br> &gt; example(plotmath)</p> 
 <p><strong>添加Hershey矢量字体</strong><br> &gt; help(<strong>Hershey</strong>)<br> &gt; example(Hershey)</p> 
 <p><strong><span style="font-size:14px;">12.3 图形的交互</span></strong></p> 
 <p>R提供了函数，使用户可以通过鼠标从图形中释放信息或添加信息。</p> 
 <p> </p> 
 <p><strong>locator</strong>(n,type)<br> 等待用户使用鼠标左键在当前图形上选择位置。直到n(默认是512)个点都选完或者点击了鼠标另一个键（Unix,Windows)，在Mac下用鼠标点 击图形窗口外的部分也可以结束。参数type的效果和在高级绘图函数中使用时是一样的，即在选择的点绘制指定的图形。默认情况是不绘制图形。函数 locator()将所选点的坐标返回到一个列表中，列表包含x,y两个组件。<br> 通常locator()在调用的时候并不带参数。这个功能在为图例或标签这样的图形元素选择位置时比较有用，尤其是这些位置不好通过计算得到的时候。举个例子，如果要在一个野点附近添加一些信息，可以使用下面的命令<br> &gt; text(locator(1), "Outlier", adj=0)</p> 
 <p> </p> 
 <p><strong>identify</strong>(x, y, labels)<br> 允许用户在x,y（使用鼠标左键）定义的点附近绘制相应的labels的组件（如果没有给出labels就给出该点的序号），突显该点。当鼠标的另一个键被点击时（Unix,Windows）返回被选点的序号，在Mac下通过点击图形窗口外来实现这个效果。<br> 有时我们更想确定图形中的点，而非它们的位置。例如，我们可能希望从图示中选出某些感兴趣的观测点，然后进行某些操作。通过两个数值向量x,y给定一系列坐标(x; y)，我们可以使用identify()函数：<br> &gt; plot(x,y) &gt; identify(x,y)<br> 函数identify()本身不绘图，但是允许用户移动鼠标，在某点附近点击左键。离鼠标指针最近的点将被突显，并标出其序号（也就是它在向量x/y中的 位置）。或者使用identify()的labels参数，把某些信息（例如案例名称）作为突显的标志；或者通过plot=FALSE参数取消所有突显标 志。当选点的过程结束后，identify()返回所选点的序号；用户可以使用这些序号从x和y中释放所选的点。</p> 
 <p><strong><span style="font-size:14px;">12.4 使用图形参数</span></strong></p> 
 <p> </p> 
 <p>通过图形参数可以定制图形显示的几乎所有方面。R包含大量的图形参数，可以控制的包括线条类型，颜色，图标排列，文本对齐等等。</p> 
 <p><strong>1 持续性变更 (Permanent changes): par()函数</strong></p> 
 <p> </p> 
 <p>通过par()函数设定图形参数的值会持续性的更改参数的值，也就是说这之后（在当前设备上）所有对图形函数的调用都受到新值的影响。<br> 函数par()用于存取和修改当前图形设备的图形参数列表。<br><strong>par()</strong>不带任何参数，返回当前设备所有图形参数和它们的值的列表。<br><strong>par(c("col","lty"))</strong><br> 参数为一个字符向量，仅返回参数中指定的图形参数（也是作为一个列表）。<br><strong>par(col=4, lty=2)</strong><br> 带指定参数（或一个列表型参数），设定指定图形参数的值，并将参数的原始值作为一个列表返回。<br> 所以如果想设定参数绘制一些图形后再恢复成原来的设定，可以这么做：<br> &gt; oldpar &lt;- par(col=4, lty=2) <br> . . . plotting commands . . . <br> &gt; par(oldpar)</p> 
 <p><strong>2 临时性变更：图形函数的参数</strong></p> 
 <p> </p> 
 <p>图形参数也可以作为（几乎）所有图形函数的命名参数。这种方式的效果和用于par()函数的效果是一样的，只不过这种改变只在函数调用的区间内有效。比如：<br> &gt;<strong> plot(x, y, pch="+")</strong><br> 生成一个以加号作为绘图符号的散点图，而不改变后续图形的默认的绘图符号。</p> 
 <p><strong>3 图形参数列表</strong></p> 
 <p><strong>A  图形元素</strong><br> R图表由点、线、文本和多边形（填充区）组成。下面的图形参数控制了图形元素的绘制：<br><strong>pch</strong>="+" 用来绘点的字符。这个默认值随不同的图形驱动是不同的，不过通常都是'±'。除非使用"."作为绘图字符，否则绘制的点都会比适当的位置高一点或者低一点，而不是恰好在指定位置。<br> pch=4当给定一个0到18的整数时，会生成一个特殊的绘图符号。通过下面的命令可以看这些符号都有什么。<br> &gt; legend(locator(1), as.character(0:18), pch=0:18)<br><strong>lty</strong>=2 线条类型。并不是所有图形设备都支持多种线条类型（在那些支持的设<br> 备上也不全一样），不过线条类型1始终是实线，2及以上的是点、划线或者它们的组合。<br><strong>lwd</strong>=2 线条宽度。所需的线条宽度，是"标准"线条宽度的倍数。对line()等函数绘制的线条和坐标轴都有效果。<br><strong>col</strong>=2 点、线、文本、填充区和图像使用的颜色。每种图形元素都有其可用的颜色列表，这个参数的值就是颜色在列表中的序号。显然，这个参数值对有限的一类设备有效。<br><strong>font</strong>=2 指定文本所使用字体的一个整数。如果可能的话，设备驱动会把1对应普通文本，2对应粗体，3对应斜体，4对应粗斜体。<br> font.axis   font.lab    font.main   font.sub 这几个参数分别指定坐标轴注释，x,y轴的标签，主、副标题所用的字体。<br><strong>adj</strong>=-0.1 文本对齐和绘图位置有关。0代表左对齐，1代表右对齐，0.5代表水平的中间位置。当前的值使会图位置到左端距离的比例，所以-0.1在文本和绘图位置之间留10%的空白。<br><strong>cex</strong>=1.5 字符缩放。这个值是所需文本字符（包括绘图字符）的大小，与默认文本大小相关。</p> 
 <p><strong>B  坐标轴和标记</strong><br> 很多R的高级图形都有坐标轴，你可以使用低级图形函数axis()自己创建坐标轴。坐标轴包含三个主要组件：轴线axis line（线条类型由参数lty控制），标记tick mark（沿着轴线划分单元），标号tick label（用来标出这些单元）。这些组件可以用下面这些参数定制。<br><strong>lab</strong>=c(5,7,12)前两个数字分别是x和y轴上所要划分的区间数。第三个数字是坐标轴标签的长度，用字符数来衡量（包括小数点）。参数的值如果选得太小可能导致所有标号都聚在一起。<br><strong>las</strong>=1 坐标轴标签的方向。0代表总是和坐标轴平行，1代表总是水平的，2代表总是垂直于坐标轴。<br><strong>mgp</strong>=c(3,1,0)坐标轴组件的位置。第一个组件是坐标轴标签到坐标轴的距离，单位是文本行(text lines)。第二个组件是到标号的距离，最后一个是轴的巍直到轴线的距离（一般都是0）。正数代表绘图区域外，负数代表区域内。<br><strong>tck</strong>=0.01 标号的长度，绘图区域大小的一个分数作单位。当tck比较小时（小于0.5），就强制x和y轴上的标记为相同大小。tck=1就是生成网格线。取负值时标记画向绘图区域外。内部标记可以使用tck=0.01和mgp=c(1,-1.5,0)。<br><strong>xaxs</strong>="s"   <strong>yaxs</strong>="d" 分别是x、y轴的类型。如果是s(standard)或e(extended)类型，那最大和最小的标记都始终在数据区域之外。如果有某个点离边界非常 近，那么扩展型(extended)的轴会稍稍扩展一下。这种类型的轴有时会在边界附近留出大片空白。而i(internal)或r(默认值)类型的轴， 标记始终在数据区域内，不过r类型会在边界留出少量空白。<br> 如果这个参数设为d，就锁定当前轴，对之后绘制的所有图形都用这个轴（直到参数被重新设定为其他的那几个值）。这个参数适用于生成一系列固定尺度的图。</p> 
 <p><strong>C  图边缘（Figure margins）</strong><br> 在R中一个单独图形，图（figure），包含一个绘图区(plot region)，以及环绕着这个区域的边缘（其中可能含有坐标轴标签、标题等等），（通常）这两部分以轴为边界。<br> 一个典型的图是<br><img alt="" src="https://images2.imgbox.com/e4/c0/PQ1LrRTC_o.png"><br> 控制图的样式的图形参数包括：<br><strong>mai</strong>=c(1,0.5,0.5,0)分别是底部，左侧，顶部，右侧的宽度，单位是英寸。<br><strong>mar</strong>=c(4,2,2,1)与mai相似，只是单位是文本行(text lines)。<br> 由于更改一个就会改变另一个的值，所以在这个意义上，mai和mar是等价的。这个参数的默认值通常都太大了；右侧边缘很少用到，如果没标题，顶部边缘也 不需要，左侧和底部的边缘应当足够大，以容纳坐标轴和标号。此外，默认值并没有考虑到设备表面的大小：比如，使用postscript()驱 动，height=4参数时，除非用mar，mai另外设定，否则图的边缘就要占上大约50%。使用多图环境时（后面会提到）。边缘会减少一半，不过这在 多图共用一页的时候可能还不够。</p> 
 <p><strong>D 多图环境</strong><br> R允许在一页上创建一个n£m的图的阵列。每个图由自己的边缘，图的阵列还有一个可选的外部边缘，如下图所示。<br><img alt="" src="https://images2.imgbox.com/ff/d6/t70RtB1n_o.png"><br> 与多图环境相关的图形参数有：<br><strong>mfcol</strong>=c(3, 2)    <strong>mfrow</strong>=c(2, 4)<br>    设定多图阵列的大小。第一个值是行数，第二个值是列数。这两个参数唯一的区别是mfcol把图按列排入，mfrow把图按行排入。上图所示的版式可用mfrow=c(3,2)创建；上图显示的是绘制四幅图后的情况。<br><strong>mfg</strong>=c(2, 2, 3, 2)<br>     当前图在多图环境下的位置。前两个数字是当前图的行、列数；后两个是其在多图阵列中的行列数。这个参数用来在多图阵列中跳转。你甚至可以在后两个数中使用和真值(true value)不同的值，在同一页上得到大小不同的图。<br><strong>fig</strong>=c(4, 9, 1, 4)/10<br>     当前图在页面的位置，取值分别是左下角到左边界，右边界，下、上边界的距离与对应边的百分比数。给出的例子是一个页面右下角的图。这个参数可以设定图在页面的绝对位置。<br><strong>oma</strong>=c(2, 0, 3, 0)   <strong>omi</strong>=(0, 0, 0.8, 0)  <br>        外部边缘的大小。与mar和mai相似，第一个用文本行作单位，第二个以英寸作单位，从下方开始按照顺时针顺序指定。<br> 外部边缘对页标题这类东西很有用。文本可以通过带<strong>outer</strong>=TRUE参数的<strong>mtext</strong>()函数加入外部边缘。默认情况下是没有外部边缘的因此必须通过oma或omi指定。<br> 函数<strong>split.screen()</strong>和<strong>layout()</strong>可以对多个图形作更复杂的排列。</p> 
 <p><strong><span style="font-size:14px;">12.6 设备驱动</span></strong></p> 
 <p> </p> 
 <p>R几乎可以在任何一种类型的显示器和打印设备上生成（不同质量的）图形。不过，在这之前，需要告诉R要处理的是哪一种设备。这通过启动一个设备驱动来完成。<br> 设备驱动通过调用<strong>设备驱动函数</strong>来启动。<br> 某些常用的设备驱动有：<br><strong>X11</strong>()[Unix] 使用X11视窗系统<br><strong>windows</strong>()[Windows]   使用 Windows 视窗系统 <br><strong>postscript</strong>()在PostScript打印机上打印或者创建PostScript图形文件<br><strong>pictex</strong>()生成一个LATEX文件<br> 当一个设备使用完之后，可以通过下面的命令终止设备驱动<br> &gt; <strong>dev.off</strong>()<br> 这个命令可以确保设备已经结束；例如，在某些硬拷贝的设备中，这个命令可以保证每页都已经完成，并且都被传送到打印机了。</p> 
 <p><strong>PostScript文档</strong><br> 通过给postscript()函数带上file参数，我们可以把图形以PostScript格式存储到文件中。如果没有给出horizontal=FALSE参数，图形是横向的，你可以通过width和height参数控制图形的大小（图形会自动适应）。例如，命令<br> &gt; postscript("file.ps", horizontal=FALSE, height=5, pointsize=10)<br> 为一个五英寸的图生成一个包含PostScript代码的文件，可以放在文当中。如果命令中的指定的文件名已经存在，将会被覆盖。</p> 
 <p>多重图形设备<br> 每个对设备驱动的新调用都会打开一个新的图形设备，在设备列表中加入新的一项。这个设备就成为当前设备，图形输出就传送到这个设备。<br><strong>dev.list</strong>()      返回所有活动中设备的序号和名称。在列表位置1的设备始终是空设备(null device)，这个设备不接收任何图形命令。<br><strong>dev.next</strong>()    <strong>dev.prev</strong>()     分别返回当前设备的后一个和前一个设备的序号和名称。<br><strong>dev.set</strong>(which=k)     用来把当前设备更改为设备列表中位置k的那个。返回设备的序号和标签。<br><strong>dev.off</strong>(k)    终止图形列表位置k的那个图形设备。对于某些设备，比如postscript，这个命令会立刻打印文件或者正常结束文件，具体怎样处理取决于设备是怎样初始化的。<br><strong>dev.copy</strong>(device,. . . ,which=k)      dev.print(device,. . . ,which=k)<br> 建立一个设备k的拷贝。其中device是一个设备函数，例如postscript，如果需要的话可以在'. . . '中指定其它的参数，dev.print效果相似，不过复制的设备会立刻关闭，所以打印硬拷贝这样的终止操作也会被立即执行。<br><strong>graphics.off</strong>()      终止列表中的所有图形设备，空设备除外</p> 
</div> 
<p>转载于:https://my.oschina.net/u/2552979/blog/700151</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96434ba4e42488dab1f3c677832a5c0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MyBatis 参数允许为空的异常解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c9f66e1ec2201b5c0d67a015d43e40c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用JAVA语言操作Hbase  JAVA整合Hbase</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>