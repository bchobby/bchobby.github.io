<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>通过深度学习从胸部X射线检测肺炎 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="通过深度学习从胸部X射线检测肺炎" />
<meta property="og:description" content="Note from Towards Data Science’s editors: While we allow independent authors to publish articles in accordance with our rules and guidelines, we do not endorse each author’s contribution. You should not rely on an author’s works without seeking professional advice. See our Reader Terms for details.
Towards Data Science编辑的注意事项： 尽管我们允许独立作者按照我们的 规则和指南 发表文章 ，但我们不认可每位作者的贡献。 您不应在未征求专业意见的情况下依赖作者的作品。 有关 详细信息， 请参见我们的 阅读器条款 。 In 2017, 2.56 million people died from pneumonia. About a third of those people were children less than 5 years old." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/7174db64e074208b0cfb053dfab3e46f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-29T00:26:03+08:00" />
<meta property="article:modified_time" content="2020-09-29T00:26:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">通过深度学习从胸部X射线检测肺炎</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <article style="font-size: 16px;"> 
 <div> 
  <section> 
   <div> 
    <div> 
     <p><strong>Note from Towards Data Science’s editors:</strong><em> While we allow independent authors to publish articles in accordance with our </em><a target="_blank" rel="nofollow noopener noreferrer" href="https://towardsdatascience.com/questions-96667b06af5"><em>rules and guidelines</em></a><em>, we do not endorse each author’s contribution. You should not rely on an author’s works without seeking professional advice. See our </em><a target="_blank" rel="nofollow noopener noreferrer" href="https://towardsdatascience.com/readers-terms-b5d780a700a4"><em>Reader Terms</em></a><em> for details.</em></p> 
     <p> <strong>Towards Data Science编辑的注意事项：</strong> <em>尽管我们允许独立作者按照我们的</em> <a target="_blank" rel="nofollow noopener noreferrer" href="https://towardsdatascience.com/questions-96667b06af5"><em>规则和指南</em></a> <em>发表文章</em> <em>，但我们不认可每位作者的贡献。</em> <em>您不应在未征求专业意见的情况下依赖作者的作品。</em> <em>有关</em> <em>详细信息，</em> <em>请参见我们的</em> <a target="_blank" rel="nofollow noopener noreferrer" href="https://towardsdatascience.com/readers-terms-b5d780a700a4"><em>阅读器条款</em></a> <em>。</em> </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <p>In 2017, 2.56 million people died from pneumonia. About a third of those people were children less than 5 years old. The WHO estimated that 45,000 of these premature deaths were due to household air pollution. With more efficiency in the diagnostics, many of these deaths can be reduced.The goal of this project is to create various machine learning and deep learning models so that when optimized, can assist radiologists in detecting Pneumonia from Chest X-Rays.</p> 
     <p> 2017年，有256万人死于肺炎。 这些人中约有三分之一是5岁以下的儿童。 世界卫生组织估计，这些过早死亡中有45,000是由于家庭空气污染所致。 通过提高诊断效率，可以减少许多此类死亡。该项目的目标是创建各种机器学习和深度学习模型，以便在进行优化时可以帮助放射科医生从胸部X射线检测肺炎。 </p> 
     <h2> 环境与工具 <span style="font-weight: bold;">(</span>Environment and Tools<span style="font-weight: bold;">)</span></h2> 
     <p>Throughout this project, we will be using python, so it is recommended that you have editors such as Google Colaboratory that is compatible with it but also allows the use of certain python packages.</p> 
     <p> 在整个项目中，我们将使用python，因此建议您使用兼容的编辑器，例如Google Colaboratory，但也允许使用某些python软件包。 </p> 
     <p>We will be using python packages:</p> 
     <p> 我们将使用python软件包： </p> 
     <ul><li>Numpy<p class="nodelete"></p> 脾气暴躁的 </li><li>Pandas<p class="nodelete"></p> 大熊猫 </li><li>Tensorflow (Version 1.x)<p class="nodelete"></p> Tensorflow(版本1.x) </li><li>Sci-Kit Learn and Keras<p class="nodelete"></p> Sci-Kit学习和Keras </li><li>Seaborn and Matplotlib<p class="nodelete"></p> Seaborn和Matplotlib </li></ul> 
     <p>We will be using other packages to download files and helper functions that do not have to do with building the models. For a full list, check the code attached below.</p> 
     <p> 我们将使用其他软件包来下载与构建模型无关的文件和帮助程序功能。 有关完整列表，请检查下面随附的代码。 </p> 
     <h2> 项目和代码 <span style="font-weight: bold;">(</span>Project and Code<span style="font-weight: bold;">)</span></h2> 
     <p>Now that we got all the introduction out of the way, let’s get started.</p> 
     <p> 现在我们已经完成了所有介绍，让我们开始吧。 </p> 
     <p>We will begin by importing some key packages which we will be using throughout the project. We will also be downloading the data (in this case, images of Chest X-rays) for the project.</p> 
     <p> 我们将从导入一些关键软件包开始，这些软件包将在整个项目中使用。 我们还将下载该项目的数据(在本例中为胸部X射线的图像)。 </p> 
     <p>You can find the full code on Github <a href="https://github.com/shayaf84/Detecting-Pneumonia-" target="_blank" rel="noopener nofollow noopener noreferrer">here</a>.</p> 
     <p> 您可以在Github上找到完整的代码<a href="https://github.com/shayaf84/Detecting-Pneumonia-" target="_blank" rel="noopener nofollow noopener noreferrer">在这里</a> 。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>We have to analyze and become familiar with our data before we start building various models. Let’s download a file called “metadata” which gives us key information about our data. After that, we will create a data frame (essentially a table) using the pandas library, which will give info about the first five images in our dataset.</p> 
     <p> 在开始构建各种模型之前，我们必须分析并熟悉我们的数据。 让我们下载一个名为“元数据”的文件，该文件为我们提供了有关数据的关键信息。 之后，我们将使用pandas库创建一个数据框(本质上是一个表)，该库将提供有关数据集中前五个图像的信息。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/5b/c5/DaY5zbaz_o.png" width="212" height="204" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption>
        Image by Author 
      </figcaption> 
      <figcaption>
        图片作者 
      </figcaption> 
     </figure> 
     <p>Each row in the table represents one image of a chest x-ray. You can see three columns: class, split, and index. Class is either 0 or a 1, 0 meaning that the lung is healthy, and 1 meaning that the lung has pneumonia. The index is a label for the image that tells us which image in the dataset we are looking at.</p> 
     <p> 表格中的每一行代表一张胸部X射线图像。 您可以看到三列：类，拆分和索引。 Class为0或1，0表示肺部健康，而1表示肺部患有肺炎。 索引是图像的标签，它告诉我们正在查看的数据集中的图像。 </p> 
     <p>In regards to split, when we are teaching the computer how to do something (in this case diagnose pneumonia), we have to train it, by giving the image with a label. However, we also have to test the computer by giving different images that the computer has not seen before, and letting the computer decide whether or not the lung has pneumonia. So, the split column describes whether the image is used to train the computer or test it. Below is a chart I made to help distinguish between the two.</p> 
     <p> 关于分割，当我们教计算机如何做某事(在这种情况下，诊断为肺炎)时，我们必须通过给图像加上标签来对其进行训练。 但是，我们还必须通过提供计算机以前未见过的不同图像来测试计算机，然后让计算机确定肺部是否患有肺炎。 因此，拆分列描述了该图像是用于训练计算机还是对其进行测试。 下面是我制作的用于帮助区分两者的图表。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/ac/bf/amlfPRsu_o.png" width="710" height="246" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption>
        Image by author 
      </figcaption> 
      <figcaption>
        图片作者 
      </figcaption> 
     </figure> 
     <p>Now, make a graph and table of the info given to further classify how many images are in each class, and split. We will be using the pandas method “count” to display the table, and we will be using the seaborn “count plot” to display a graph that classifies the data.</p> 
     <p> 现在，为给出的信息制作图表，以进一步分类每个类别中的图像数量并进行拆分。 我们将使用pandas方法“计数”来显示表格，并且将使用原始的“计数图”来显示对数据进行分类的图形。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
    </div> 
   </div> 
   <div> 
    <div> 
     <div> 
      <figure style="display:block;text-align:center;"> 
       <div> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/ff/d6/gbr4GYJY_o.png" width="171" height="110" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </div> 
       <figcaption>
         Image by author 
       </figcaption> 
       <figcaption>
         图片作者 
       </figcaption> 
      </figure> 
      <figure style="display:block;text-align:center;"> 
       <div> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/b3/b3/Igod8CZg_o.png" width="393" height="261" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </div> 
       <figcaption>
         Image by author 
       </figcaption> 
       <figcaption>
         图片作者 
       </figcaption> 
      </figure> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div> 
     <p>As the charts show, 1200 lungs are healthy, and 1200 lungs have pneumonia. Within those 1200, a thousand will be used to train the model, and the other thousand will be used to test the model.</p> 
     <p> 如图所示，有1200肺健康，而1200肺有肺炎。 在这1200个中，有1000个将用于训练模型，而其他1000个将用于测试模型。 </p> 
     <p>Now that we fully understand which category our data is in, we can go ahead and plot some images, to view what the chest x-rays will look like.</p> 
     <p> 既然我们完全了解了数据所在的类别，我们就可以继续绘制一些图像，以查看胸部X射线的外观。 </p> 
     <p>Run this function, which allows you to plot images:</p> 
     <p> 运行此功能，可以绘制图像： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>From here you can call the function by running the code below. It downloads the training and testing data (from the functions we defined earlier) and will plot an image depending on an index (the number associated with the image. Notice the 1 on line 4). The “data” is the image while the “labels” section is the number 0 or 1 to say whether the patient has pneumonia or not.</p> 
     <p> 在这里，您可以通过运行以下代码来调用该函数。 它下载训练和测试数据(从我们之前定义的功能中下载)，并将根据索引(与图像关联的数字。请注意第4行的1)绘制图像。 “数据”是图像，而“标签”部分是数字0或1，表示患者是否患有肺炎。 </p> 
     <p>I specifically chose one healthy image, and one with a lung that has pneumonia. Feel free to play around with the index to see other images.</p> 
     <p> 我专门选择了一个健康的图像，一个肺部有肺炎的图像。 随意操作索引以查看其他图像。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
    </div> 
   </div> 
   <div> 
    <div> 
     <div> 
      <div> 
       <figure style="display:block;text-align:center;"> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/66/fd/Uuos8vxy_o.png" width="265" height="273" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </figure> 
       <figure style="display:block;text-align:center;"> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/1a/ea/KucXQMws_o.png" width="265" height="276" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
        <figcaption>
          The image on the left is a healthy lung, and the one on the right has pneumonia. Images by author 
        </figcaption> 
        <figcaption>
          左图是健康的肺，右图是肺炎。 图片作者 
        </figcaption> 
       </figure> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div> 
     <h2> 简单的机器学习模型 <span style="font-weight: bold;">(</span>Simple Machine Learning Models<span style="font-weight: bold;">)</span></h2> 
     <p>Now that we finished examining and analyzing our data, we can go ahead and build some machine learning models. We will begin simple, using the K-nearest neighbours, and logistic regression classifiers.</p> 
     <p> 现在我们完成了对数据的检查和分析，我们可以继续构建一些机器学习模型。 我们将使用K最近邻和逻辑回归分类器开始简单的工作。 </p> 
     <h3> K最近邻居 <span style="font-weight: bold;">(</span>K-Nearest Neighbours<span style="font-weight: bold;">)</span></h3> 
     <p>The key concept of K-nearest neighbours is that, when we see an unknown example, we will look at what the unknown is closest too, and predict that it is the same thing.</p> 
     <p> K近邻的关键概念是，当我们看到一个未知的示例时，我们还将查看未知的最接近的事物，并预测它是同一回事。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/2d/75/ULNeATq1_o.png" width="489" height="451" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption>
        Image by author 
      </figcaption> 
      <figcaption>
        图片作者 
      </figcaption> 
     </figure> 
     <p>This diagram above shows the K-Nearest Neighbours Classifier. For example, if k=1, the (single) closest shape to the one in question is a circle. Thus, if k=1, the shape is a circle. However, if k=3, the 3 closest shapes to the one in question are 2 rectangles and 1 circle. So, if k=3, the shape is a rectangle.</p> 
     <p> 上图显示了K最近邻分类器。 例如，如果k = 1，则最接近所讨论形状的(单个)形状是圆形。 因此，如果k ＝ 1，则形状是圆形。 但是，如果k = 3，则最接近所讨论形状的3个形状是2个矩形和1个圆形。 因此，如果k = 3，则形状为矩形。 </p> 
     <h3> 逻辑回归 <span style="font-weight: bold;">(</span>Logistic Regression<span style="font-weight: bold;">)</span></h3> 
     <p>Logistic Regression is used to predict probabilities that will later be turned into a category (0–1). In linear regression, the predicted y-value can exceed the 0–1 range (with the continuous straight line). However, in logistic regression, the predicted y-values can not exceed the 0–1 range because it is in the shape of an “s”. As an example, look at the diagram below.</p> 
     <p> Logistic回归用于预测概率，以后将其转换为类别(0-1)。 在线性回归中，预测的y值可以超过0–1范围(使用连续直线)。 但是，在逻辑回归中，预测的y值不能超过0–1范围，因为它的形状为“ s”。 例如，请看下面的图。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/e1/96/SybDYUgq_o.png" width="563" height="408" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption> 
       <a href="https://en.wikipedia.org/wiki/Logistic_regression#/media/File:Exam_pass_logistic_curve.jpeg" rel="noopener nofollow noopener noreferrer" target="_blank">Public Domain</a> 
       <a href="https://en.wikipedia.org/wiki/Logistic_regression#/media/File:Exam_pass_logistic_curve.jpeg" rel="noopener nofollow noopener noreferrer" target="_blank">公共领域的</a>图片 
      </figcaption> 
     </figure> 
     <p>It shows on the x-axis, the number of hours students were studying, and the y-axis shows whether or not they passed the exam (0 or 1). However, the logistic curve’s y-axis shows the probability of whether or not they passed the exam. As you can see, the curve predicts that people who study less will fail, rather than pass, and vice versa.</p> 
     <p> 它在x轴上显示学生的学习时间，在y轴上显示他们是否通过了考试(0或1)。 但是，逻辑曲线的y轴显示它们是否通过考试的概率。 如您所见，曲线预测学习较少的人会失败而不是通过，反之亦然。 </p> 
     <h2> 建立机器学习模型 <span style="font-weight: bold;">(</span>Building the Machine Learning Models<span style="font-weight: bold;">)</span></h2> 
     <p>We will be using the sci-kit learn library to build these models, specifically the KNeighborsClassifier and LogisticRegression methods.</p> 
     <p> 我们将使用sci-kit学习库来构建这些模型，特别是KNeighborsClassifier和LogisticRegression方法。 </p> 
     <p>The steps to build a machine learning model is to load the model, fit (or train) the model, use the model to predict whether a patient has pneumonia or not, and finally evaluate the model.</p> 
     <p> 建立机器学习模型的步骤是加载模型，拟合(或训练)模型，使用模型预测患者是否患有肺炎，最后评估模型。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>As you can see, in lines 6 and 7, we loaded or initiated the models. Then, on lines 10, and 11, we trained the models using the train data. For predictions, the models predicted what the test_labels were based on the test_data. This is why, to check the accuracy score, we were checking to see how our predictions were, based on the test_data.</p> 
     <p> 如您所见，在第6和7行中，我们加载或启动了模型。 然后，在第10和11行，我们使用训练数据训练了模型。 为了进行预测，模型基于test_data预测了test_labels是什么。 这就是为什么要检查准确性分数，我们根据test_data检查我们的预测结果如何。 </p> 
     <p>So, now we can run the model and check the accuracy scores. Note that you can improve the performance of the KNN classifier by just changing the number of neighbours.</p> 
     <p> 因此，现在我们可以运行模型并检查准确性得分。 请注意，您只需更改邻居数即可提高KNN分类器的性能。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/9b/20/gkiQnl0U_o.png" width="322" height="38" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption>
        Accuracy Scores 
      </figcaption> 
      <figcaption>
        准确性分数 
      </figcaption> 
     </figure> 
     <p>It is obvious that the accuracy scores for these models were low. Thus, these are not the best models to use for this problem. So, we have to take a different approach to it.</p> 
     <p> 显然，这些模型的准确性得分很低。 因此，这些不是解决此问题的最佳模型。 因此，我们必须采取不同的方法。 </p> 
     <h2> 卷积神经网络 <span style="font-weight: bold;">(</span>Convolutional Neural Networks<span style="font-weight: bold;">)</span></h2> 
     <p>Convolutional Neural Networks are a specific type of neural networks, used to find patterns between images. I will briefly describe 3 key parts:</p> 
     <p> 卷积神经网络是神经网络的一种特殊类型，用于查找图像之间的模式。 我将简要描述3个关键部分： </p> 
     <ol><li>Convolution<p class="nodelete"></p> 卷积 </li><li>Pooling<p class="nodelete"></p> 汇集 </li><li>Fully-Connected Layers<p class="nodelete"></p> 全连接层 </li></ol> 
     <h3> 卷积 <span style="font-weight: bold;">(</span>Convolution<span style="font-weight: bold;">)</span></h3> 
     <p>A convolutional kernel is a matrix of weights, similar to the ones of a fully-connected layer. A convolutional kernel is applied to inputs by multiplying the weights elementwise with the corresponding pixel values in the image input. This will help sharpen the image.</p> 
     <p> 卷积核是权重矩阵，类似于完全连接层的权重矩阵。 通过将权重逐元素乘以图像输入中的相应像素值，将卷积核应用于输入。 这将有助于锐化图像。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/c9/c4/CLYGd6hS_o.gif" width="390" height="345" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption> 
       <a href="https://commons.wikimedia.org/wiki/File:2D_Convolution_Animation.gif" rel="noopener nofollow noopener noreferrer" target="_blank">Public Domain</a> 
       <a href="https://commons.wikimedia.org/wiki/File:2D_Convolution_Animation.gif" rel="noopener nofollow noopener noreferrer" target="_blank">公共领域的图片</a> 
      </figcaption> 
     </figure> 
     <h3> 汇集 <span style="font-weight: bold;">(</span>Pooling<span style="font-weight: bold;">)</span></h3> 
     <p>The convolution layer output is still too big for the neural network to make any predictions. We can reduce its size by pooling. It combines certain pixels from the convolution layer and combines them into a single one. Max pooling is one of the most common examples of pooling, where it divides the output into tiles, and takes the maximum of each.</p> 
     <p> 卷积层输出对于神经网络来说仍然太大，无法做出任何预测。 我们可以通过合并来减小它的大小。 它合并了卷积层中的某些像素，并将它们合并为一个像素。 最大池化是最常见的池化示例之一，它将输出分成多个磁贴，并取每个磁贴的最大值。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/73/9f/UOmhhEzq_o.png" width="599" height="287" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption> 
       <a href="http://en.wikipedia.org/wiki/Convolutional_neural_network#/media/File:Max_pooling.png" rel="noopener nofollow noopener noreferrer" target="_blank">Public Domain</a> 
       <a href="http://en.wikipedia.org/wiki/Convolutional_neural_network#/media/File:Max_pooling.png" rel="noopener nofollow noopener noreferrer" target="_blank">公共领域</a> 
      </figcaption> 
     </figure> 
     <h3> 完全连接的层 <span style="font-weight: bold;">(</span>Fully Connected Layers<span style="font-weight: bold;">)</span></h3> 
     <p>Fully connected layers connect each neuron in a single to every other neuron in the next layer. The last layer uses an activation function that outputs probabilities, such as softmax or sigmoid, which the computer will use to classify images.</p> 
     <p> 完全连接的层将单个神经元连接到下一层中的每个其他神经元。 最后一层使用激活函数来输出概率，例如softmax或Sigmoid，计算机将使用这些概率对图像进行分类。 </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/e5/e0/cqgpyfdA_o.png" width="500" height="309" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption> 
       <a href="https://texample.net/tikz/examples/neural-network/" rel="noopener nofollow noopener noreferrer" target="_blank">Public Domain</a> 
       <a href="https://texample.net/tikz/examples/neural-network/" rel="noopener nofollow noopener noreferrer" target="_blank">公共领域</a> 
      </figcaption> 
     </figure> 
     <h2> 建立我们的卷积神经网络 <span style="font-weight: bold;">(</span>Building our Convolutional Neural Network<span style="font-weight: bold;">)</span></h2> 
     <p>We will be using the Keras library to build our model. Before you build your model, run these two functions, that will allow you to plot accuracy and loss.</p> 
     <p> 我们将使用Keras库构建模型。 在构建模型之前，请运行以下两个函数，这些函数将允许您绘制准确性和损失。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>So, now that we ran those functions, let’s build the model. There are key components that you must know, which are:</p> 
     <p> 因此，既然我们已经运行了这些功能，我们就来构建模型。 您必须知道一些关键组件，它们是： </p> 
     <ul><li><p><strong>add(Conv2D())</strong>: The layer that performs convolution. It takes 3 arguments. The first is the number of times it performs the convolution, second is the dimensions of the convolution, and the third is the activation function. For the first layer, make sure to specify the input shape as well.</p><p> <strong>add(Conv2D())</strong> ：执行卷积的图层。 它需要3个参数。 第一个是执行卷积的次数，第二个是卷积的维数，第三个是激活函数。 对于第一层，请确保也指定输入形状。 </p></li><li><p><strong>add(MaxPooling2D()): </strong>The layer that performs the max-pooling. It takes in 1 argument, which is the dimensions of the pixels that are combined.</p><p> <strong>add(MaxPooling2D())：</strong>执行最大池化的层。 它接受1个参数，这是组合像素的尺寸。 </p></li><li><p><strong>add(Flatten()): </strong>Flattens the images into a one dimensional array.</p><p> <strong>add(Flatten())：</strong>将图像展平为一维数组。 </p></li><li><p><strong>add(Dense()): </strong>Adds a fully-connected layer. It takes in two arguments, the number of neurons in the layer, and the activation function of that layer.</p><p> <strong>add(Dense())：</strong>添加一个完全连接的层。 它接受两个参数，即该层中神经元的数量以及该层的激活功能。 </p></li><li><p><strong>add(Dropout(): </strong>Shuts off a certain amount of neurons, to reduce overfitting. Takes in one argument, usually a number between 0 and 1, which when converted to percents, is the percents of neurons from the previous layers that will be shut off.</p><p> <strong>add(Dropout()：</strong>关闭一定数量的神经元，以减少过度拟合。采用一个参数，通常为0到1之间的数字，当转换为百分比时，它是将关闭的上一层神经元的百分比。关。 </p></li><li><p>Our activation function for every layer (except the output layer) will be <strong>ReLU</strong>. For our output layer, the activation function will be <strong>sigmoid </strong>which outputs probabilities of whether our patient has pneumonia or not.</p><p> 我们对每层(输出层除外)的激活函数将是<strong>ReLU</strong> 。 对于我们的输出层，激活函数将为<strong>S型</strong> ，输出患者是否患有肺炎的概率。 </p></li><li><p>Our loss will be <strong>binary_crossentropy</strong>, and we will use the optimizer, <strong>RMSprop</strong>, customized to a learning rate of 1e-4 and a decay of 1e-6.</p><p> 我们的损失将是<strong>binary_crossentropy</strong> ，我们将使用针对学习速率为1e-4且衰减为1e-6定制的优化器<strong>RMSprop</strong> 。 </p></li></ul> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>Great! Now that we built our model, let’s run it to see how well it did.</p> 
     <p> 大！ 现在我们已经建立了模型，让我们运行它来看看它做得如何。 </p> 
    </div> 
   </div> 
   <div> 
    <div> 
     <div> 
      <div> 
       <figure style="display:block;text-align:center;"> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/aa/ab/oN4dAsCt_o.png" width="482" height="307" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </figure> 
       <figure style="display:block;text-align:center;"> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/8b/10/E1cPVkd8_o.png" width="446" height="305" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
        <figcaption>
          Images by author 
        </figcaption> 
        <figcaption>
          图片作者 
        </figcaption> 
       </figure> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div> 
     <p>You can see from the plots above, that our model did fairly well. However, it did not perform well enough for it to be used in a clinical setting. You can from here continue tinkering with the model to increase accuracy and decrease the loss. However, make sure to avoid overfitting (when the computer memorizes the training data, so it performs poorly on the testing data.</p> 
     <p> 您可以从上面的图中看出，我们的模型做得很好。 但是，它不能很好地用于临床环境。 您可以从此处继续修改模型，以提高准确性并减少损失。 但是，请确保避免过度拟合(当计算机存储训练数据时，它在测试数据上的表现会很差。 </p> 
     <h2> 如何阅读图表 <span style="font-weight: bold;">(</span>How to read the graph<span style="font-weight: bold;">)</span></h2> 
     <p>The x-axis shows the number of epochs. Whenever there are decimals on the x-axis, you can ignore it, because only full epochs are allowed (whole numbers). On the y-axis, you have the value you are measuring. It could be loss, accuracy, etc. The yellow line represents the training data, while the blue line represents the validation data. The green line represents the best epoch for that metric.</p> 
     <p> x轴显示历元数。 每当x轴上有小数位时，您都可以忽略它，因为只允许完整的纪元(整数)。 在y轴上，您具有要测量的值。 可能是损失，准确性等。黄线表示训练数据，而蓝线表示验证数据。 绿线代表该指标的最佳时期。 </p> 
     <h2> <strong>转移学习</strong> <span style="font-weight: bold;">(</span><strong>Transfer Learning</strong><span style="font-weight: bold;">)</span></h2> 
     <p>For our transfer learning, we will be using VGG16. VGG16 is an “expert” model used during the “ImageNet” Classification Problem. In ImageNet, contestants were challenged to build models that can distinguish between 14 million image categories, where there were more than 20,000 categories available.</p> 
     <p> 对于我们的迁移学习，我们将使用VGG16。 VGG16是在“ ImageNet”分类问题期间使用的“专家”模型。 在ImageNet中，参赛者面临的挑战是建立可区分1400万个图像类别的模型，其中有20,000多个类别可用。 </p> 
     <p>VGG16 was allowed to study those 14 million images 74 times. It then was able to guess an image to the real label better than a human can.</p> 
     <p> VGG16被允许研究那1400万张图像74次。 然后，它能够比人类更好地猜测出具有真实标签的图像。 </p> 
     <p>We are going to take VGG16 and let it train on our x-rays. Hopefully, their experience in the ImageNet Problem will assist in distinguishing pneumonia from our x-rays.</p> 
     <p> 我们将采用VGG16，并对其进行X射线训练。 希望他们在ImageNet问题中的经验将有助于从我们的X射线中区分出肺炎。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>The first line will download, VGG16’s Convolution algorithms. Then we will have to declare it as trainable, making sure we can train every layer, by utilizing a “for” loop. After that, we have to add and customize fully connected layers, as VGG16 contains fixed convolution layers.</p> 
     <p> 第一行将下载VGG16的卷积算法。 然后，我们必须将其声明为可训练的，以确保我们可以利用“ for”循环来训练每个图层。 之后，我们必须添加和自定义完全连接的层，因为VGG16包含固定的卷积层。 </p> 
     <p>Now, run it and let’s see how it performed!</p> 
     <p> 现在，运行它，让我们看看它的性能！ </p> 
    </div> 
   </div> 
   <div> 
    <div> 
     <div> 
      <div> 
       <figure style="display:block;text-align:center;"> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/fe/9a/n9MCTbw6_o.png" width="477" height="305" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </figure> 
       <figure style="display:block;text-align:center;"> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/fb/a6/TNnwUNMw_o.png" width="464" height="310" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </figure> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div> 
     <p>As you can see, the performance of our model, with VGG16 significantly increased. You can also see that the model began to overfit after 1–2 epochs. This is because VGG16 is pre-trained, so that makes it more efficient and accurate, but at the same time, it can overfit easier.</p> 
     <p> 如您所见，带有VGG16的模型的性能大大提高。 您还可以看到模型在1-2个时期后开始过拟合。 这是因为VGG16是经过预训练的，因此使其更有效，更准确，但是同时，过拟合也更容易。 </p> 
     <h2> <strong>结论</strong> <span style="font-weight: bold;">(</span><strong>Conclusion</strong><span style="font-weight: bold;">)</span></h2> 
     <p>We started this project by analyzing the data we learned and learning how many images have pneumonia or are healthy. We also split the dataset into training data and testing data. Afterwards, we constructed simple machine learning models, that were able to make informed decisions based on the training that we applied to it. Finally, we built Convolutional Neural Networks to improve the accuracy and efficiency of the model. Afterwards, we used a pre-trained model as our transfer learning to further optimize our model. Now, I leave it to you. How can you continue to improve the model, so that it will be able to be used in medical practices? Maybe you can even run it on some field data and apply data augmentation.</p> 
     <p> 我们通过分析我们获得的数据并了解有多少图像患有肺炎或健康来开始这个项目。 我们还将数据集分为训练数据和测试数据。 之后，我们构建了简单的机器学习模型，该模型能够根据我们所接受的训练做出明智的决策。 最后，我们构建了卷积神经网络以提高模型的准确性和效率。 之后，我们使用预先训练的模型作为转移学习，以进一步优化模型。 现在，我留给你。 您如何继续改进该模型，以便可以在医疗实践中使用它？ 也许您甚至可以在某些现场数据上运行它并应用数据扩充。 </p> 
     <h2></h2> 
     <p>[1] Anon, <a href="https://inspiritaischolars.teachable.com/courses/1040297/lectures/21877191" rel="noopener nofollow noopener noreferrer" target="_blank">Classification</a> (n.d.), Teachable</p> 
     <p> [1]匿名， <a href="https://inspiritaischolars.teachable.com/courses/1040297/lectures/21877191" rel="noopener nofollow noopener noreferrer" target="_blank">分类</a> (nd)，可教 </p> 
     <p>[2] Anon, <a href="https://www.who.int/news-room/fact-sheets/detail/pneumonia" rel="noopener nofollow noopener noreferrer" target="_blank">Pneumonia</a> (2019), World Health Organization</p> 
     <p> [2] Anon， <a href="https://www.who.int/news-room/fact-sheets/detail/pneumonia" rel="noopener nofollow noopener noreferrer" target="_blank">肺炎</a> (2019年)，世界卫生组织 </p> 
     <p>[2] B. Dadonaite, and M. Roser, <a href="https://ourworldindata.org/pneumonia#citation" rel="noopener nofollow noopener noreferrer" target="_blank">Pneumonia</a> (2019), Our World in Data</p> 
     <p> [2] B. Dadonaite和M. Roser，《 <a href="https://ourworldindata.org/pneumonia#citation" rel="noopener nofollow noopener noreferrer" target="_blank">肺炎》</a> (2019年)，《我们的数据世界》 </p> 
     <p>[3] C. Archie, <a target="_blank" rel="nofollow noopener noreferrer" href="https://towardsdatascience.com/chest-x-rays-pneumonia-detection-using-convolutional-neural-network-63d6ec2d1dee">Chest X-rays Pneumonia Detection using Convolutional Neural Network</a> (2020), Medium.com</p> 
     <p> [3] C. Archie， <a target="_blank" rel="nofollow noopener noreferrer" href="https://towardsdatascience.com/chest-x-rays-pneumonia-detection-using-convolutional-neural-network-63d6ec2d1dee">使用卷积神经网络进行的胸部X射线肺炎检测</a> (2020年)，Medium.com </p> 
     <p>[4] R. Prabhu,<a href="https://medium.com/@RaghavPrabhu/understanding-of-convolutional-neural-network-cnn-deep-learning-99760835f148" rel="noopener noopener noreferrer" target="_blank"> Understanding of Convolutional Neural Network (CNN) — Deep Learning</a> (2018), Medium.com</p> 
     <p> [4] R. Prabhu，《 <a href="https://medium.com/@RaghavPrabhu/understanding-of-convolutional-neural-network-cnn-deep-learning-99760835f148" rel="noopener noopener noreferrer" target="_blank">对卷积神经网络的理解-深度学习》</a> (2018年)，Medium.com </p> 
     <p>Credit to Inspirit AI for teaching me about all the technical details and providing the dataset.</p> 
     <p> 感谢Inspirit AI教给我有关所有技术细节并提供数据集的信息。 </p> 
    </div> 
   </div> 
  </section> 
 </div> 
 <blockquote> 
  <p>翻译自: <a href="https://towardsdatascience.com/detecting-pneumonia-from-chest-x-rays-with-deep-learning-6b83b4a77ee8" rel="nofollow">https://towardsdatascience.com/detecting-pneumonia-from-chest-x-rays-with-deep-learning-6b83b4a77ee8</a></p> 
 </blockquote> 
</article>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81c5dbdf26f475b9d5fe18b7301df64b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自变量向量的函数的泰勒公式_向量自变量的线性函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/249eaf6b805f84de39af92de58d0c71a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">云讯健身管理系统-12--SSO单点登录、阿里云短信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>