<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;初阶】九、STL容器中的string类（上） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;初阶】九、STL容器中的string类（上）" />
<meta property="og:description" content="=========================================================================
相关代码gitee自取：
C语言学习日记: 加油努力 (gitee.com)
=========================================================================
接上期：
【C&#43;&#43;初阶】八、初识模板（泛型编程、函数模板、类模板）-CSDN博客
=========================================================================
目录 一 . STL简介
什么是STL
STL的版本
HP 原始版本：
P.J. 版本：
RW 版本：
SGI 版本：
STL的六大组件
图示：
二 . string类
C语言中的字符串
C&#43;&#43;标准库中的string类
string类（了解）
总结：
string类的常用接口说明（重点）
string类对象的常见构造函数：
图示 -- 第1个构造函数：
图示 -- 第2、3个构造函数：
图示 -- 第4、5个构造函数：
图示 -- 第6、7个构造函数：
补充 -- operator= ：（赋值“=”运算符重载函数）
string类对象的容量操作：
使用注意事项：
string类对象的访问即遍历操作：
operator[] ：（下标运算符&#34;[ ]&#34;重载函数）
begin &#43; end ：（通过迭代器进行遍历）
rbegin &#43; rend ：（通过迭代器进行反向遍历）
范围for循环 -- 完成字符串遍历：
本篇博客相关代码：
Test.cpp文件 -- C&#43;&#43;文件：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/7291b582a17d83f48c7992426c89519e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T21:19:42+08:00" />
<meta property="article:modified_time" content="2023-12-25T21:19:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;初阶】九、STL容器中的string类（上）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><strong>=========================================================================</strong></p> 
<p style="text-align:center;"><strong><span style="color:#fe2c24;">相关代码gitee自取</span>：</strong></p> 
<p style="text-align:center;"><strong><a href="https://gitee.com/ding-peihua/c-language-learning-diary" rel="nofollow" title="C语言学习日记: 加油努力 (gitee.com)">C语言学习日记: 加油努力 (gitee.com)</a></strong></p> 
<p style="text-align:center;"><strong> =========================================================================</strong></p> 
<p style="text-align:center;"><strong><span style="color:#fe2c24;">接上期</span>：</strong></p> 
<p style="text-align:center;"><a href="https://dph-and-wsj.blog.csdn.net/article/details/134895933?spm=1001.2014.3001.5502" rel="nofollow" title="【C++初阶】八、初识模板（泛型编程、函数模板、类模板）-CSDN博客"><strong>【C++初阶】八、初识模板（泛型编程、函数模板、类模板）-CSDN博客</strong></a></p> 
<p style="text-align:center;"><strong> =========================================================================</strong></p> 
<p style="text-align:center;"><strong>                     </strong></p> 
<h2 id="%E7%9B%AE%E5%BD%95" style="text-align:center;"><strong><span style="background-color:#f9eda6;">目录</span></strong></h2> 
<blockquote> 
 <p id="%E4%B8%80%20.%20STL%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><strong><a href="#%E4%B8%80%20.%20STL%E7%AE%80%E4%BB%8B" rel="nofollow">一 . STL简介</a></strong></p> 
 <p id="%E4%BB%80%E4%B9%88%E6%98%AFSTL-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFSTL" rel="nofollow">什么是STL</a></p> 
 <p id="STL%E7%9A%84%E7%89%88%E6%9C%AC-toc" style="margin-left:40px;"><a href="#STL%E7%9A%84%E7%89%88%E6%9C%AC" rel="nofollow">STL的版本</a></p> 
 <p id="HP%20%E5%8E%9F%E5%A7%8B%E7%89%88%E6%9C%AC%EF%BC%9A-toc" style="margin-left:120px;"><a href="#HP%20%E5%8E%9F%E5%A7%8B%E7%89%88%E6%9C%AC%EF%BC%9A" rel="nofollow">HP 原始版本：</a></p> 
 <p id="P.J.%20%E7%89%88%E6%9C%AC%EF%BC%9A-toc" style="margin-left:120px;"><a href="#P.J.%20%E7%89%88%E6%9C%AC%EF%BC%9A" rel="nofollow">P.J. 版本：</a></p> 
 <p id="RW%20%E7%89%88%E6%9C%AC%EF%BC%9A-toc" style="margin-left:120px;"><a href="#RW%20%E7%89%88%E6%9C%AC%EF%BC%9A" rel="nofollow">RW 版本：</a></p> 
 <p id="SGI%20%E7%89%88%E6%9C%AC%EF%BC%9A-toc" style="margin-left:120px;"><a href="#SGI%20%E7%89%88%E6%9C%AC%EF%BC%9A" rel="nofollow">SGI 版本：</a></p> 
 <p id="STL%E7%9A%84%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#STL%E7%9A%84%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6" rel="nofollow">STL的六大组件</a></p> 
 <p id="%E5%9B%BE%E7%A4%BA%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%9B%BE%E7%A4%BA%EF%BC%9A" rel="nofollow">图示：</a></p> 
 <hr> 
 <p id="%E4%BA%8C%20.%20string%E7%B1%BB-toc" style="margin-left:0px;"><strong><a href="#%E4%BA%8C%20.%20string%E7%B1%BB" rel="nofollow">二 . string类</a></strong></p> 
 <p id="C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">C语言中的字符串</a></p> 
 <p id="C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB-toc" style="margin-left:40px;"><a href="#C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB" rel="nofollow">C++标准库中的string类</a></p> 
 <p id="string%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#string%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">string类（了解）</a></p> 
 <p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">总结：</a></p> 
 <p id="string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:80px;"><a href="#string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">string类的常用接口说明（重点）</a></p> 
 <p id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:120px;"><a href="#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">string类对象的常见构造函数：</a></p> 
 <p id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC1%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC1%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">图示 -- 第1个构造函数：</a></p> 
 <p id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC2%E3%80%813%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC2%E3%80%813%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">图示 -- 第2、3个构造函数：</a></p> 
 <p id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC4%E3%80%815%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC4%E3%80%815%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">图示 -- 第4、5个构造函数：</a></p> 
 <p id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC6%E3%80%817%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC6%E3%80%817%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">图示 -- 第6、7个构造函数：</a></p> 
 <p id="%E8%A1%A5%E5%85%85%20--%20operator%3D%20%EF%BC%9A%EF%BC%88%E8%B5%8B%E5%80%BC%E2%80%9C%3D%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:160px;"><a href="#%E8%A1%A5%E5%85%85%20--%20operator%3D%20%EF%BC%9A%EF%BC%88%E8%B5%8B%E5%80%BC%E2%80%9C%3D%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">补充 -- operator= ：（赋值“=”运算符重载函数）</a></p> 
 <p id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:120px;"><a href="#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">string类对象的容量操作：</a></p> 
 <p id="%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A" rel="nofollow">使用注意事项：</a></p> 
 <p id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8D%B3%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:120px;"><a href="#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8D%B3%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">string类对象的访问即遍历操作：</a></p> 
 <p id="operator%5B%5D%20%EF%BC%9A%EF%BC%88%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6%22%5B%20%5D%22%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:160px;"><a href="#operator%5B%5D%20%EF%BC%9A%EF%BC%88%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6%22%5B%20%5D%22%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">operator[] ：（下标运算符"[ ]"重载函数）</a></p> 
 <p id="begin%20%2B%20end%20%EF%BC%9A%EF%BC%88%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%EF%BC%89-toc" style="margin-left:160px;"><a href="#begin%20%2B%20end%20%EF%BC%9A%EF%BC%88%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%EF%BC%89" rel="nofollow">begin + end ：（通过迭代器进行遍历）</a></p> 
 <p id="rbegin%20%2B%20rend%20%EF%BC%9A%EF%BC%88%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86%EF%BC%89-toc" style="margin-left:160px;"><a href="#rbegin%20%2B%20rend%20%EF%BC%9A%EF%BC%88%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86%EF%BC%89" rel="nofollow">rbegin + rend ：（通过迭代器进行反向遍历）</a></p> 
 <p id="%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF%20--%C2%A0%20%E5%AE%8C%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF%20--%C2%A0%20%E5%AE%8C%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">范围for循环 --  完成字符串遍历：</a></p> 
 <hr> 
 <p id="%E6%9C%AC%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><strong><a href="#%E6%9C%AC%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">本篇博客相关代码：</a></strong></p> 
 <p id="Test.cpp%E6%96%87%E4%BB%B6%20--%20C%2B%2B%E6%96%87%E4%BB%B6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#Test.cpp%E6%96%87%E4%BB%B6%20--%20C%2B%2B%E6%96%87%E4%BB%B6%EF%BC%9A" rel="nofollow">Test.cpp文件 -- C++文件：</a></p> 
</blockquote> 
<p style="text-align:center;"><strong>         </strong></p> 
<p style="text-align:center;"><strong>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</strong></p> 
<p style="text-align:center;"><strong>             </strong></p> 
<h2 id="%E4%B8%80%20.%20STL%E7%AE%80%E4%BB%8B" style="text-align:center;"><strong><span style="background-color:#f9eda6;">一 . STL简介</span></strong></h2> 
<blockquote> 
 <h3 id="%E4%BB%80%E4%B9%88%E6%98%AFSTL" style="text-align:center;"><span style="background-color:#d4e9d5;">什么是STL</span></h3> 
 <p style="text-align:center;">                    </p> 
 <p style="text-align:center;"><strong><span style="color:#1a439c;">STL</span>（<span style="color:#1a439c;">standard template libaray</span> -- <span style="color:#1a439c;">标准模板库</span>）：</strong></p> 
 <p style="text-align:center;"><strong><span style="color:#be191c;">是</span><span style="color:#1c7331;"> C++标准库</span><span style="color:#be191c;"> 的</span><span style="color:#1c7331;">重要组成部分</span>，<span style="color:#be191c;">不仅是一个</span><span style="color:#1c7331;">可复用的组件库</span>，<br><span style="color:#be191c;">而且是一个</span><span style="color:#1c7331;">包罗数据结构和算法</span><span style="color:#be191c;">的</span><span style="color:#1c7331;">软件框架</span></strong></p> 
 <p style="text-align:center;"><strong>                     </strong></p> 
 <p style="text-align:center;"><strong>                     </strong></p> 
 <hr> 
 <p style="text-align:center;"><strong>                    </strong></p> 
 <h3 id="STL%E7%9A%84%E7%89%88%E6%9C%AC" style="text-align:center;"><strong><span style="background-color:#d4e9d5;">STL的版本</span></strong></h3> 
 <p style="text-align:center;">                   </p> 
 <h5 id="HP%20%E5%8E%9F%E5%A7%8B%E7%89%88%E6%9C%AC%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">HP 原始版本：</span></strong></h5> 
 <p style="text-align:center;"><strong><span style="color:#1c7331;">Alexander Stepanov</span>、<span style="color:#1c7331;">Meng Lee </span><span style="color:#be191c;">在惠普实验室完成的</span><span style="color:#1c7331;">原始版本</span>，<br><span style="color:#be191c;">本着</span><span style="color:#1a439c;">开源精神</span>，<span style="color:#be191c;">他们声明允许任何人</span><span style="color:#1c7331;">任意运用</span>、<span style="color:#1c7331;">拷贝</span>、<span style="color:#1c7331;">修改</span>、<span style="color:#1c7331;">传播</span>、<span style="color:#1c7331;">商业使用</span><span style="color:#be191c;">这些代码</span><br><span style="color:#be191c;">无需付费</span>，<span style="color:#be191c;">唯一的条件就是也需要像原始版本一样</span><span style="color:#1c7331;">做开源使用</span>。<br><span style="color:#956fe7;">HP版本</span><span style="color:#be191c;">的STL</span><span style="color:#1a439c;"> </span>-- <span style="color:#1a439c;">所有STL实现版本的始祖</span></strong></p> 
 <p style="text-align:center;">                          </p> 
 <p style="text-align:center;">                          <br> ---------------------------------------------------------------------------------------------</p> 
 <p style="text-align:center;">                       </p> 
 <h5 id="P.J.%20%E7%89%88%E6%9C%AC%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">P.J. 版本：</span></strong></h5> 
 <p style="text-align:center;"><strong><span style="color:#be191c;">由</span></strong><strong><span style="color:#be191c;"> </span><span style="color:#1c7331;">P. J. Plauger</span><span style="color:#be191c;"> 开发</span>，<span style="color:#be191c;">继承自</span><span style="color:#956fe7;">HP版本</span>，<br><span style="color:#be191c;">被</span><span style="color:#1a439c;"> Windows Visual C++</span>（<span style="color:#1a439c;">VS系列</span>）<span style="color:#be191c;">采用</span>，<span style="color:#be191c;">不能公开或修改</span>。<br><span style="color:#be191c;">缺陷</span>：<span style="color:#1c7331;">可读性</span><span style="color:#be191c;">比较</span><span style="color:#1c7331;">低</span>，<span style="color:#1c7331;">符号命名</span><span style="color:#be191c;">比较</span><span style="color:#1c7331;">怪异</span></strong></p> 
 <p style="text-align:center;">                          </p> 
 <p style="text-align:center;">                          <br> ---------------------------------------------------------------------------------------------</p> 
 <p style="text-align:center;">                       </p> 
 <h5 id="RW%20%E7%89%88%E6%9C%AC%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">RW 版本：</span></strong></h5> 
 <p style="text-align:center;"><strong><span style="color:#be191c;">由 </span><span style="color:#1c7331;">Rouge Wage公司</span><span style="color:#be191c;"> 开发</span>，<span style="color:#be191c;">继承自</span><span style="color:#956fe7;">HP版本</span>，<span style="color:#be191c;">被 </span><span style="color:#1a439c;">C++ Builder</span><span style="color:#be191c;"> 采用</span>，<br><span style="color:#be191c;">不能公开或修改</span>，<span style="color:#1c7331;">可读性一般</span></strong></p> 
 <p style="text-align:center;">                          </p> 
 <p style="text-align:center;">                          <br> ---------------------------------------------------------------------------------------------</p> 
 <p style="text-align:center;">                       </p> 
 <h5 id="SGI%20%E7%89%88%E6%9C%AC%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">SGI 版本：</span></strong></h5> 
 <p style="text-align:center;"><strong><span style="color:#be191c;">由</span><span style="color:#1c7331;"> Silicon Graphics Computer Systems</span>，<span style="color:#1c7331;">inc公司</span><span style="color:#be191c;">开发</span>，<span style="color:#be191c;">继承自</span><span style="color:#956fe7;">HP版本</span>。<br><span style="color:#be191c;">被 </span><span style="color:#1a439c;">GCC</span>（<span style="color:#1a439c;">Linux</span>）<span style="color:#be191c;">采用</span>，<span style="color:#1c7331;">可移植性好</span>，<span style="color:#1c7331;">可公开</span>、<span style="color:#1c7331;">可修改甚至贩卖</span>，<br><span style="color:#be191c;">从</span><span style="color:#1c7331;">命名风格</span><span style="color:#be191c;">和</span><span style="color:#1c7331;">编程风格</span><span style="color:#be191c;">上看</span>，<span style="color:#1c7331;">阅读性</span><span style="color:#be191c;">非常</span><span style="color:#1c7331;">高</span></strong></p> 
 <p style="text-align:center;"><strong>                     </strong></p> 
 <p style="text-align:center;"><strong>                     </strong></p> 
 <hr> 
 <p style="text-align:center;"><strong>                    </strong></p> 
 <h3 id="STL%E7%9A%84%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6" style="text-align:center;"><strong><span style="background-color:#d4e9d5;">STL的六大组件</span></strong></h3> 
 <p style="text-align:center;">              </p> 
 <ul><li style="text-align:center;"><strong><span style="color:#956fe7;">STL的六大组件</span><span style="color:#be191c;">分别为</span>：<br><span style="color:#1a439c;">仿函数</span> 、<span style="color:#1a439c;">算法</span> 、<span style="color:#1a439c;">迭代器</span> 、<span style="color:#1a439c;">空间配置器</span> 、<span style="color:#1a439c;">容器</span> 、<span style="color:#1a439c;">配接器</span></strong></li></ul> 
 <h5 id="%E5%9B%BE%E7%A4%BA%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">图示：</span></strong></h5> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/2d/cb/QRRpnHpe_o.png" width="1200"></p> 
 <p style="text-align:center;">                   </p> 
 <ul><li style="text-align:center;"><strong><span style="color:#be191c;">其中</span><span style="color:#1a439c;">空间配置器</span><span style="color:#be191c;">也叫</span><span style="color:#1c7331;">内存池</span>，<span style="color:#1a439c;">容器</span><span style="color:#be191c;">可以简单理解成</span><span style="color:#1c7331;">数据结构</span>，<span style="color:#1a439c;">配接器</span><span style="color:#be191c;">也可叫</span><span style="color:#1c7331;">适配器</span>，<br><span style="color:#1a439c;">容器</span>（<span style="color:#1c7331;">数据结构</span>）<span style="color:#be191c;">存储数据需要大量的空间</span>，<br><span style="color:#be191c;">如果频繁向</span><span style="color:#1c7331;">堆</span><span style="color:#be191c;">申请大量的内存空间</span>，<span style="color:#be191c;">效率会有点低</span>，<br><span style="color:#be191c;">所以</span><span style="color:#1a439c;">STL</span><span style="color:#be191c;">中有了</span><span style="color:#1a439c;">空间配置器</span>（<span style="color:#1c7331;">内存池</span>），<span style="color:#be191c;">专门给</span><span style="color:#1a439c;">容器</span>（<span style="color:#1c7331;">数据结构</span>）<span style="color:#be191c;">提供内存空间</span>，<br><span style="color:#be191c;">内存空间的</span><span style="color:#1c7331;">初始化工作</span><span style="color:#be191c;">则交给</span><span style="color:#1a439c;">定位new</span><span style="color:#be191c;">完成</span></strong></li></ul> 
</blockquote> 
<p style="text-align:center;"><strong>         </strong></p> 
<p style="text-align:center;"><strong>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</strong></p> 
<p style="text-align:center;"><strong>             </strong></p> 
<h2 id="%E4%BA%8C%20.%20string%E7%B1%BB" style="background-color:transparent;text-align:center;"><strong><span style="background-color:#f9eda6;">二 . string类</span></strong></h2> 
<blockquote> 
 <h3 id="C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2" style="text-align:center;"><strong><span style="background-color:#d4e9d5;">C语言中的字符串</span></strong></h3> 
 <p style="text-align:center;">           </p> 
 <p style="text-align:center;"><strong><span style="color:#1a439c;">C语言</span><span style="color:#be191c;">中</span>，<span style="color:#1c7331;">字符串</span><span style="color:#be191c;">是以</span> ‘<span style="color:#1c7331;">\0</span>’ <span style="color:#1c7331;">结尾</span><span style="color:#be191c;">的一些</span><span style="color:#1c7331;">字符的集合</span>，<span style="color:#be191c;">为了</span><span style="color:#1c7331;">操作方便</span>，<br><span style="color:#1a439c;">C语言标准库</span><span style="color:#be191c;">中提供了一些</span><span style="color:#1c7331;">str系列</span><span style="color:#be191c;">的</span><span style="color:#1c7331;">库函数</span>，<span style="color:#be191c;">但是</span><span style="color:#1c7331;">这些库函数</span><span style="color:#be191c;">与</span><span style="color:#1c7331;">字符串</span><span style="color:#be191c;">是</span><span style="color:#1c7331;">分离开</span><span style="color:#be191c;">的</span>，<br><span style="color:#be191c;">不太符合</span><span style="color:#1c7331;">OOP</span>(<span style="color:#1c7331;">面向对象程序设计</span>)<span style="color:#be191c;">的思想</span>，<span style="color:#be191c;">而且</span><span style="color:#1c7331;">底层空间</span><span style="color:#be191c;">需要用户</span><span style="color:#1c7331;">自己管理</span>，<br><span style="color:#be191c;">稍不留神可能还会</span><span style="color:#1c7331;">越界访问</span></strong></p> 
 <p style="text-align:center;"><strong>                     </strong></p> 
 <p style="text-align:center;"><strong>                     </strong></p> 
 <hr> 
 <p style="text-align:center;"><strong>                    </strong></p> 
 <h3 id="C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB" style="text-align:center;"><span style="background-color:#d4e9d5;">C++标准库中的string类</span></h3> 
 <p style="text-align:center;">             </p> 
 <h4 id="string%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" style="text-align:center;"><strong><span style="background-color:#c7e6ea;">string类（了解）</span></strong></h4> 
 <p style="text-align:center;">                </p> 
 <ul><li style="text-align:center;"><strong><span style="color:#1a439c;">string类</span><span style="color:#be191c;">严格来说</span><span style="color:#1c7331;">不是STL容器</span>，<span style="color:#be191c;">但从</span><span style="color:#1c7331;">归类</span><span style="color:#be191c;">的角度来说</span>，<br><span style="color:#be191c;">其实可以把</span><span style="color:#1c7331;">字符串</span><span style="color:#be191c;">看成是</span><span style="color:#1c7331;">数据结构中的串</span>，<span style="color:#be191c;">一个</span><span style="color:#1a439c;">专门管理字符的串</span>。<br><span style="color:#be191c;">因为</span><span style="color:#1a439c;">string</span><span style="color:#1c7331;">产生</span><span style="color:#be191c;">得比</span><span style="color:#1a439c;">STL</span><span style="color:#1c7331;">早</span>，<span style="color:#be191c;">所以在</span><span style="color:#1c7331;">C++文档</span><span style="color:#be191c;">中被</span><span style="color:#1c7331;">纳入到了</span><span style="color:#1a439c;">标准库</span><span style="color:#1c7331;">中</span>，<span style="color:#be191c;">而不是</span><span style="color:#1a439c;">STL</span><span style="color:#be191c;">中</span></strong><br>                     </li><li style="text-align:center;"><strong><span style="color:#1a439c;">string字符串</span><span style="color:#be191c;">是表示</span><span style="color:#1c7331;">字符序列的类</span>，<span style="color:#be191c;">虽然我们</span><span style="color:#1c7331;">通常叫做string类</span>，<br><span style="color:#be191c;">但string其实是一个</span><span style="color:#1a439c;">模板类</span><span style="color:#be191c;">的一个</span><span style="color:#1c7331;">实例</span><br>                    </strong></li><li style="text-align:center;"><strong><span style="color:#1c7331;">标准的字符串类</span><span style="color:#be191c;">提供了对</span><span style="color:#1c7331;">此类对象的支持</span>，<span style="color:#be191c;">其</span><span style="color:#1a439c;">接口</span><span style="color:#be191c;">类似于</span><span style="color:#1a439c;">标准字符容器的接口</span>，<br><span style="color:#be191c;">但添加了专门用于操作</span><span style="color:#1c7331;">单字节字符字符串</span><span style="color:#be191c;">的设计特性</span><br>                   </strong></li><li style="text-align:center;"><strong><span style="color:#1a439c;">string类</span><span style="color:#be191c;">使用</span><span style="color:#1c7331;">char</span><span style="color:#be191c;">作为其</span><span style="color:#1c7331;">字符类型</span>，<span style="color:#be191c;">使用它的</span><span style="color:#1c7331;">默认char_traits</span><span style="color:#be191c;">和</span><span style="color:#1c7331;">分配器类型</span><br> （关于<span style="color:#be191c;">模板的更多学习</span>，可参阅：<a class="link-info" href="https://cplusplus.com/reference/string/string/?kw=string" rel="nofollow" title="C++ string类模板">C++ string类模板</a>）<br>             </strong></li><li style="text-align:center;"><strong><span style="color:#1a439c;">string类</span><span style="color:#be191c;">是</span><span style="color:#1a439c;">basic_string模板类</span><span style="color:#be191c;">的一个</span><span style="color:#1c7331;">示例</span>，<span style="color:#be191c;">它使用</span><span style="color:#1c7331;">char</span><span style="color:#be191c;">来</span><span style="color:#1c7331;">实例化</span><span style="color:#1a439c;">basic_string模板类</span>,<br><span style="color:#be191c;">并用 </span><span style="color:#1c7331;">char_traits </span><span style="color:#be191c;">和 </span><span style="color:#1c7331;">allocator </span><span style="color:#be191c;">作为 </span><span style="color:#1a439c;">basic_string</span><span style="color:#be191c;"> 的</span><span style="color:#1a439c;">默认参数</span><br> （关于<span style="color:#be191c;">模板的更多学习</span>，可参阅：<strong><a class="link-info" href="https://cplusplus.com/reference/string/string/?kw=string" rel="nofollow" title="C++ string类模板">C++ string类模板</a></strong>）<br>              </strong></li><li style="text-align:center;"><strong><span style="color:#956fe7;">注意</span>：<br><span style="color:#1a439c;">string类</span><span style="color:#1c7331;">独立于</span><span style="color:#be191c;">所使用的</span><span style="color:#1c7331;">编码</span><span style="color:#be191c;">来</span><span style="color:#1c7331;">处理字节</span>，<br><span style="color:#be191c;">如果用来处理</span><span style="color:#1c7331;">多字节</span><span style="color:#be191c;">或</span><span style="color:#1c7331;">变长字符</span>（<span style="color:#be191c;">如</span><span style="color:#1c7331;">UTF-8</span>）<span style="color:#be191c;">的</span><span style="color:#1c7331;">序列</span>，<br><span style="color:#1a439c;">string类</span><span style="color:#be191c;">的</span><span style="color:#1a439c;">所有成员</span>（<span style="color:#be191c;">如</span><span style="color:#1c7331;">长度</span><span style="color:#be191c;">或</span><span style="color:#1c7331;">大小</span>）<span style="color:#be191c;">以及它的</span><span style="color:#1a439c;">迭代器</span>，<br><span style="color:#be191c;">将仍然</span><span style="color:#1a439c;">按照字节</span><span style="color:#be191c;">而</span><span style="color:#1c7331;">不是实际编码的字符</span><span style="color:#be191c;">来操作</span><br>               </strong></li></ul> 
 <h5 id="%E6%80%BB%E7%BB%93%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">总结：</span></strong></h5> 
 <ul><li style="text-align:center;"><strong><span style="color:#1a439c;">string</span><span style="color:#be191c;">是表示</span><span style="color:#1c7331;">字符串的字符串类</span><br>           </strong></li><li style="text-align:center;"><strong><span style="color:#1c7331;">该类的接口</span><span style="color:#be191c;">和</span><span style="color:#1c7331;">常规容器的接口</span><span style="color:#be191c;">基本相同</span>，<span style="color:#be191c;">再添加了一些用来</span><span style="color:#1c7331;">操作</span><span style="color:#1a439c;">string</span><span style="color:#1c7331;">的常规操作</span><br>              </strong></li><li style="text-align:center;"><strong><span style="color:#1a439c;">string类</span><span style="color:#be191c;">在</span><span style="color:#1c7331;">底层</span><span style="color:#be191c;">实际是 </span><span style="color:#1a439c;">basic_string模板类</span><span style="color:#be191c;"> 的</span><span style="color:#1c7331;">别名</span>（<span style="color:#1c7331;">引用</span>），<br><span style="color:#be191c;">使用了</span><span style="color:#956fe7;"> typedef </span><span style="color:#1a439c;">basic_string</span><span style="color:#956fe7;">&lt;char, char_traits, allocator&gt; </span><span style="color:#1a439c;">string</span><span style="color:#956fe7;">;</span><span style="color:#be191c;"> 重命名为了</span><span style="color:#1a439c;">string</span><br>                  </strong></li><li style="text-align:center;"><strong><span style="color:#be191c;">不能操作</span><span style="color:#1c7331;">多字节</span><span style="color:#be191c;">或者</span><span style="color:#1c7331;">变长字符</span><span style="color:#be191c;">的</span><span style="color:#1c7331;">序列</span><br>               </strong></li><li style="text-align:center;"><strong><span style="color:#be191c;">在使用</span><span style="color:#1a439c;">string类</span><span style="color:#be191c;">时</span>，<span style="color:#be191c;">必须</span><span style="color:#1c7331;">包含</span><span style="color:#be191c;"> </span><span style="color:#956fe7;">#include&lt;string&gt;头文件</span><span style="color:#be191c;"> 以及 </span><span style="color:#956fe7;">using namespace std;</span><br> (也可以<span style="color:#be191c;">不用完全展开</span>，<span style="color:#be191c;">展开string对应的那部分</span>即可)<br>                      </strong></li></ul> 
 <p style="text-align:center;"><strong>                          <br> ---------------------------------------------------------------------------------------------</strong></p> 
 <p style="text-align:center;">                     </p> 
 <h4 id="string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" style="text-align:center;"><strong><span style="background-color:#c7e6ea;">string类的常用接口说明（重点）</span></strong></h4> 
 <p style="text-align:center;">              </p> 
 <h5 id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">string类对象的常见构造函数：</span></strong></h5> 
 <table align="center" border="2" cellpadding="1" cellspacing="1" style="width:650px;"><thead><tr><th style="text-align:center;"><strong>（<a class="link-info" href="https://cplusplus.com/reference/string/string/string/" rel="nofollow" title="constructor">constructor</a>）构造函数名称</strong></th><th style="text-align:center;"><strong>对应功能说明</strong></th></tr></thead><tbody><tr><td style="text-align:center;"><span style="color:#1a439c;">string</span>();        <strong>（重点）</strong></td><td style="text-align:center;">创建一个字符串对象，<br> 但<span style="color:#be191c;">没有使用字符串初始化</span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;">string </span>(const char* <span style="color:#be191c;">s</span>);        <strong>（重点）</strong></td><td style="text-align:center;">创建一个字符串对象，<br> 并<span style="color:#be191c;">使用常量字符串初始化</span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;">string </span>(const string&amp; <span style="color:#be191c;">str</span>);        <strong>（重点）</strong></td><td style="text-align:center;">创建一个字符串对象，<br> 并<span style="color:#be191c;">使用另一个字符串对象<br> 进行初始化</span></td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;">string </span>(const string&amp; <span style="color:#be191c;">str</span>, size_t <span style="color:#be191c;">pos</span>, size_t <span style="color:#be191c;">len </span>= <span style="color:#1c7331;">npos</span>);</td><td style="text-align:center;"><span style="color:#be191c;">拷贝<strong><u>str</u></strong>字符串中<u><strong>pos</strong></u>下标<br> 开始的<u><strong>len</strong></u>个字符</span>，<br> 拷贝给创建的字符串对象</td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;">string </span>(const char* <span style="color:#be191c;">s</span>, size_t <span style="color:#be191c;">n</span>);</td><td style="text-align:center;"><span style="color:#be191c;">拷贝一个<u><strong>常量字符串</strong></u>的<br><u><strong>n</strong></u>个长度的字符</span>，<br> 拷贝给创建的字符串对象</td></tr><tr><td style="text-align:center;"><span style="color:#1a439c;">string </span>(size_t <span style="color:#be191c;">n</span>, char <span style="color:#be191c;">c</span>);</td><td style="text-align:center;"><span style="color:#be191c;">填充<u><strong>n</strong></u>个<u><strong>c</strong></u>字符</span>到<br> 创建的字符串对象中</td></tr><tr><td style="text-align:center;">template &lt;class InputIterator&gt; <span style="color:#1a439c;">string </span>(InputIterator first, InputIterator last);</td><td style="text-align:center;">涉及<span style="color:#be191c;">迭代器</span>，<br> 不懂，以后再说</td></tr></tbody></table> 
 <h6 id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC1%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">图示 -- 第1个构造函数：</span></strong></h6> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/b6/53/X0VDCzKc_o.png" width="1200"></p> 
 <h6 id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC2%E3%80%813%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">图示 -- 第2、3个构造函数：</span></strong></h6> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/98/f2/GA08fFFR_o.png" width="1200"></p> 
 <h6 id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC4%E3%80%815%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">图示 -- 第4、5个构造函数：</span></strong></h6> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/6d/78/bgKVr6eh_o.png" width="1200"></p> 
 <h6 id="%E5%9B%BE%E7%A4%BA%20--%20%E7%AC%AC6%E3%80%817%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">图示 -- 第6、7个构造函数：</span></strong></h6> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/12/9d/BLEtFIYb_o.png" width="1200"></p> 
 <h6 id="%E8%A1%A5%E5%85%85%20--%20operator%3D%20%EF%BC%9A%EF%BC%88%E8%B5%8B%E5%80%BC%E2%80%9C%3D%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%89" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">补充 -- operator= ：</span><br><span style="background-color:#fbd4d0;">（赋值“=”运算符重载函数）</span></strong></h6> 
 <ul><li style="text-align:center;"><strong><span style="color:#1c7331;">string类对象</span><span style="color:#be191c;">还可以通过</span><span style="color:#1a439c;">赋值</span>“<span style="color:#1a439c;">=</span>”<span style="color:#1a439c;">运算符重载函数</span>（<span style="color:#1a439c;">operator=</span>）<span style="color:#be191c;">实现</span><span style="color:#1c7331;">初始化</span><br>                    </strong></li><li style="text-align:center;"><strong><span style="color:#1a439c;">operator= </span><span style="color:#be191c;">有</span><span style="color:#1c7331;">三种实现</span>：<br><span style="color:#be191c;">第1种</span>： <span style="color:#956fe7;">string&amp; operator=</span> (<span style="color:#956fe7;">const string&amp; str</span>);  --  <span style="color:#1c7331;">string字符串类对象</span><span style="color:#be191c;">赋值</span><br><span style="color:#be191c;">第2种</span>： <span style="color:#956fe7;">string&amp; operator=</span> (<span style="color:#956fe7;">const char* s</span>);  -- <span style="color:#1c7331;"> 直接写出字符串</span><span style="color:#be191c;">进行赋值</span><br><span style="color:#be191c;">第3种</span>： <span style="color:#956fe7;">string&amp; operator=</span> (<span style="color:#956fe7;">char c</span>);  --  <span style="color:#1c7331;">单个字符</span><span style="color:#be191c;">进行赋值</span></strong></li></ul> 
 <p style="text-align:center;"><span style="color:#956fe7;"><strong>对应图示</strong></span><strong>：</strong></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/c3/5c/pvQw0q9S_o.png" width="1200"></p> 
 <p style="text-align:center;">                          </p> 
 <p style="text-align:center;">                          <br> ---------------------------------------------------------------------------------------------</p> 
 <p style="text-align:center;">                       </p> 
 <h5 id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">string类对象的容量操作：</span></strong></h5> 
 <table align="center" border="2" cellpadding="1" cellspacing="1" style="width:650px;"><thead><tr><th style="text-align:center;">函数名称</th><th style="text-align:center;">功能说明</th></tr></thead><tbody><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/rend/" rel="nofollow" title="size">size</a>        <strong>（重点）</strong></td><td style="text-align:center;">返回字符串<span style="color:#be191c;">有效字符大小</span>（<span style="color:#be191c;">长度</span>）</td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/length/" rel="nofollow" title="length">length</a></td><td style="text-align:center;">返回字符串<span style="color:#be191c;">有效字符长度</span></td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/capacity/" rel="nofollow" title="capacity">capacity</a></td><td style="text-align:center;"><span style="color:#be191c;">实际能够存储</span>的<span style="color:#be191c;">有效字符个数</span></td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/empty/" rel="nofollow" title="empty">empty</a>       <strong>（重点）</strong></td><td style="text-align:center;">检测字符串<span style="color:#be191c;">是否为空串</span>，<span style="color:#be191c;">是</span>返回<span style="color:#be191c;">true</span>，<span style="color:#be191c;">否</span>则返回<span style="color:#be191c;">false</span></td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/clear/" rel="nofollow" title="clear">clear</a>       <strong>（重点）</strong></td><td style="text-align:center;"><span style="color:#be191c;">清空字符串有效字符</span></td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/reserve/" rel="nofollow" title="reserve">reserve</a>      <strong> （重点）</strong></td><td style="text-align:center;">为字符串<span style="color:#be191c;">预留空间</span>，可以进行<span style="color:#be191c;">扩容操作</span><br> （只影响<span style="color:#be191c;">容量</span>，不会影响数据）</td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/resize/" rel="nofollow" title="resize">resize</a>       <strong>（重点）</strong></td><td style="text-align:center;">将<span style="color:#be191c;">有效字符的个数分割成n个</span>，<span style="color:#be191c;">多出的空间</span>可用<span style="color:#be191c;">字符c填充</span><br> （即影响<span style="color:#be191c;">容量</span>，也影响<span style="color:#be191c;">数据</span>）</td></tr></tbody></table> 
 <h6 id="%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">使用注意事项：</span></strong></h6> 
 <ul><li style="text-align:center;"><strong><span style="color:#1a439c;">size()</span> <span style="color:#be191c;">与</span><span style="color:#1a439c;"> length()</span><span style="color:#be191c;"> 方法</span><span style="color:#1c7331;">底层实现原理</span><span style="color:#be191c;">完全相同</span>，<br><span style="color:#1c7331;">引入</span><span style="color:#1a439c;"> size() </span><span style="color:#1c7331;">的原因</span><span style="color:#be191c;">是为了</span><span style="color:#1c7331;">与其它容器的接口</span><span style="color:#be191c;">保持一致</span>，<br><span style="color:#be191c;">一般情况下基本都是用</span><span style="color:#1a439c;"> size()</span><br><span style="color:#956fe7;">对应图示</span>：</strong> <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/c3/c7/HlfGinJS_o.png" width="1200"></p> <strong>               </strong></li><li style="text-align:center;"><strong><span style="color:#1a439c;">clear() </span><span style="color:#be191c;">方法只是将</span><span style="color:#1c7331;">string字符串</span><span style="color:#be191c;">中的</span><span style="color:#1c7331;">有效字符清空</span>，<br><span style="color:#1c7331;">不改变底层空间大小</span><br>                </strong></li><li style="text-align:center;"><strong><span style="color:#1a439c;">resize</span>(<span style="color:#1a439c;">size_t n</span>) <span style="color:#be191c;">与 </span><span style="color:#1a439c;">resize</span>(<span style="color:#1a439c;">size_t n</span>, <span style="color:#1a439c;">char c</span>) <span style="color:#be191c;">都是将</span><span style="color:#1c7331;">字符串中有效字符个数改变到</span><span style="color:#1a439c;">n</span><span style="color:#1c7331;">个</span>，<br><span style="color:#be191c;">不同的是当</span><span style="color:#1c7331;">字符个数增多时</span>：<br><span style="color:#1a439c;">resize</span>(<span style="color:#1a439c;">size_t n</span>) <span style="color:#be191c;">用</span><span style="color:#1c7331;">0</span><span style="color:#be191c;">来填充多出的元素空间</span>，<br><span style="color:#1a439c;">resize</span>(<span style="color:#1a439c;">size_t n</span>, <span style="color:#1a439c;">char c</span>) <span style="color:#be191c;">用</span><span style="color:#1c7331;">字符c</span><span style="color:#be191c;">来填充多出的元素空间</span>。<br><span style="color:#956fe7;">注意：</span><br><span style="color:#1a439c;">resize</span><span style="color:#be191c;">在</span><span style="color:#1c7331;">改变元素个数</span><span style="color:#be191c;">时</span>，<span style="color:#be191c;">如果是</span><span style="color:#1c7331;">将元素个数增多</span>，<span style="color:#be191c;">可能会</span><span style="color:#1c7331;">改变底层容量的大小</span>，<br><span style="color:#be191c;">如果是</span><span style="color:#1c7331;">将元素个数减少</span>，<span style="color:#1c7331;">底层空间总大小不变</span></strong></li></ul> 
 <p style="text-align:center;"><span style="color:#956fe7;"><strong>图示 --  resize ：</strong></span></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/07/87/Ft0evWeC_o.png" width="1200"></p> 
 <p style="text-align:center;">                  </p> 
 <ul><li style="text-align:center;"><strong><span style="color:#1a439c;"> reserve</span>(<span style="color:#1a439c;">size_t res_arg=0</span>) ：<br><span style="color:#be191c;">为string</span><span style="color:#1c7331;">预留空间</span>，<span style="color:#1c7331;">不改变有效元素个数</span>，<br><span style="color:#be191c;">当</span><span style="color:#1a439c;">reserve</span><span style="color:#be191c;">的</span><span style="color:#1a439c;">参数</span><span style="color:#1c7331;">小于string的底层空间总大小</span><span style="color:#be191c;">时</span>，<span style="color:#1a439c;">reserve</span><span style="color:#1c7331;">不会改变容量大小</span></strong></li></ul> 
 <p style="text-align:center;"><span style="color:#956fe7;"><strong>图示 --  reserve ：</strong></span></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/7a/ee/z9WrtIHK_o.png" width="1200"></p> 
 <p style="text-align:center;">                     </p> 
 <p style="text-align:center;"><span style="color:#956fe7;"><strong>图示 --  reserve增容 ：</strong></span></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/f5/31/VaN7l4Z6_o.png" width="1200"></p> 
 <p style="text-align:center;">                          </p> 
 <p style="text-align:center;">                          <br> ---------------------------------------------------------------------------------------------</p> 
 <p style="text-align:center;">                       </p> 
 <h5 id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8D%B3%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#dad5e9;">string类对象的访问即遍历操作：</span></strong></h5> 
 <table align="center" border="2" cellpadding="1" cellspacing="1" style="width:650px;"><thead><tr><th style="text-align:center;">函数名称</th><th style="text-align:center;">功能说明</th></tr></thead><tbody><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/operator%5B%5D/" rel="nofollow" title="operator[]">operator[]</a>        <strong>（重点）</strong></td><td style="text-align:center;"><span style="color:#be191c;">返回pos下标位置</span>的<span style="color:#be191c;">字符</span>，<span style="color:#be191c;">const string类对象</span>也有<span style="color:#be191c;">对应const调用</span></td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/begin/" rel="nofollow" title="begin">begin</a> + <a class="link-info" href="https://cplusplus.com/reference/string/string/end/" rel="nofollow" title="end">end</a></td><td style="text-align:center;"><span style="color:#1a439c;">begin</span>：<span style="color:#be191c;">获取第一个字符</span>的<span style="color:#be191c;">迭代器</span><br><span style="color:#1a439c;">end</span>：<span style="color:#be191c;">获取最后一个字符下一个位置</span>的<span style="color:#be191c;">迭代器</span></td></tr><tr><td style="text-align:center;"><a class="link-info" href="https://cplusplus.com/reference/string/string/rbegin/" rel="nofollow" title="rbegin">rbegin</a> + <a class="link-info" href="https://cplusplus.com/reference/string/string/rend/" rel="nofollow" title="rend">rend</a></td><td style="text-align:center;"><span style="color:#1a439c;">being</span> + <span style="color:#1a439c;">end </span>是<span style="color:#be191c;">正向迭代器</span>（<span style="color:#be191c;">正向</span>遍历），分为<span style="color:#be191c;">const</span>和<span style="color:#be191c;">非const</span>版本，<br><span style="color:#1a439c;">rbegin </span>+ <span style="color:#1a439c;">rend </span>是<span style="color:#be191c;">反向迭代器</span>（<span style="color:#be191c;">反向</span>遍历），也分为<span style="color:#be191c;">const</span>和<span style="color:#be191c;">非const</span>版本</td></tr><tr><td style="text-align:center;">范围for循环</td><td style="text-align:center;"><span style="color:#be191c;">C++11</span>支持<span style="color:#be191c;">更简洁</span>的<span style="color:#be191c;">范围for循环</span>的新遍历方式</td></tr></tbody></table> 
 <h6 id="operator%5B%5D%20%EF%BC%9A%EF%BC%88%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6%22%5B%20%5D%22%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%89" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">operator[] ：</span><br><span style="background-color:#fbd4d0;">（下标运算符"[ ]"重载函数）</span></strong></h6> 
 <ul><li style="text-align:center;"><strong><span style="color:#1c7331;">string类</span><span style="color:#be191c;">的</span> "<span style="color:#1a439c;">operator[]</span>" <span style="color:#be191c;">有</span><span style="color:#1c7331;">两个实现</span>：<br><span style="color:#be191c;">第1种</span>： <span style="color:#956fe7;">char&amp; operator[]</span> (<span style="color:#956fe7;">size_t pos</span>);<br><span style="color:#be191c;">第2种</span>： <span style="color:#956fe7;">const char&amp; operator[] </span>(<span style="color:#956fe7;">size_t pos</span>) <span style="color:#956fe7;">const</span>;<br>                </strong></li><li style="text-align:center;"><strong><span style="color:#1c7331;">string类</span><span style="color:#be191c;">实现了</span> "<span style="color:#1a439c;">operator[]</span>" <span style="color:#be191c;">后</span>，<br><span style="color:#1c7331;">string类对象</span><span style="color:#be191c;">就可以像数组</span><span style="color:#1c7331;">通过下标</span><span style="color:#be191c;">一样</span><span style="color:#1c7331;">访问字符串中的字符</span><span style="color:#be191c;">了</span></strong></li></ul> 
 <p style="text-align:center;"><span style="color:#956fe7;"><strong>图示 --  第1种实现</strong></span><strong>：</strong></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/f3/e0/IRNUblyU_o.png" width="1200"></p> 
 <h6 id="begin%20%2B%20end%20%EF%BC%9A%EF%BC%88%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%EF%BC%89" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">begin + end ：</span><br><span style="background-color:#fbd4d0;">（通过迭代器进行遍历）</span></strong></h6> 
 <ul><li style="text-align:center;"><strong><span style="color:#1a439c;">迭代器iterator</span><span style="color:#be191c;">定义在</span><span style="color:#1c7331;">类域</span><span style="color:#be191c;">中</span>，<span style="color:#be191c;">但它不</span><span style="color:#1c7331;">是内部类</span>，<span style="color:#be191c;">是一个</span><span style="color:#1c7331;">类型</span>，<br><span style="color:#be191c;">现在刚接触迭代器的情况下</span>，<span style="color:#be191c;">可以认为</span><span style="color:#1c7331;">迭代器的用法</span><span style="color:#be191c;">和</span><span style="color:#1c7331;">指针类似</span><br>                          </strong></li><li style="text-align:center;"><strong><span style="color:#1a439c;">迭代器</span><span style="color:#be191c;">的</span><span style="color:#1a439c;"> begin() </span><span style="color:#be191c;">和</span><span style="color:#1a439c;"> end() </span><span style="color:#be191c;">方法</span>，<span style="color:#be191c;">形成的</span><span style="color:#1c7331;">区间</span><span style="color:#be191c;">是</span>“<span style="color:#1c7331;">左闭右开</span>”<span style="color:#be191c;">的</span>，<br><span style="color:#be191c;">对于</span><span style="color:#1c7331;">string类对象</span>，<span style="color:#1a439c;">begin() </span><span style="color:#be191c;">可以理解成</span><span style="color:#1c7331;">指向字符串首字符</span><span style="color:#be191c;">的</span><span style="color:#1c7331;">指针</span>，<br><span style="color:#1a439c;">end() </span><span style="color:#be191c;">可以理解成</span><span style="color:#1c7331;">指向最后一个有效字符的下一位字符</span><span style="color:#be191c;">的</span><span style="color:#1c7331;">指针</span></strong></li></ul> 
 <p style="text-align:center;"><strong><span style="color:#956fe7;">图示 --  使用迭代器遍历字符串</span>：</strong></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/3d/ff/i2CyayYM_o.png" width="1200"></p> 
 <p style="text-align:center;">                  </p> 
 <p style="text-align:center;"><strong><span style="color:#956fe7;">图示 --  迭代器实现operator[]的第2种实现</span>：</strong></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/59/3c/K41JnS0V_o.png" width="1200"></p> 
 <h6 id="rbegin%20%2B%20rend%20%EF%BC%9A%EF%BC%88%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86%EF%BC%89" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">rbegin + rend ：</span><br><span style="background-color:#fbd4d0;">（通过迭代器进行反向遍历）</span></strong></h6> 
 <ul><li style="text-align:center;"><strong><span style="color:#be191c;">和 </span><span style="color:#1a439c;">begin+end</span><span style="color:#be191c;"> 类似</span>，<span style="color:#be191c;">只不过 </span><span style="color:#1a439c;">rbegin+rend</span><span style="color:#be191c;"> 是</span><span style="color:#1c7331;">反向遍历</span><br>                          </strong></li><li style="text-align:center;"><span style="color:#1a439c;"><strong>begin+end</strong></span><span style="color:#be191c;"><strong> 和 </strong></span><span style="color:#1a439c;"><strong>rbegin+rend </strong></span><span style="color:#be191c;"><strong>各自都有</strong></span><span style="color:#1c7331;"><strong>两种实现</strong></span><strong>：</strong><br><span style="color:#1c7331;"><strong>非const版本</strong></span><span style="color:#be191c;"><strong> 和</strong></span><span style="color:#1c7331;"><strong> const版本</strong></span></li></ul> 
 <p style="text-align:center;"><strong><span style="color:#956fe7;">图示 --  使用迭代器反向遍历字符串</span>：</strong></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/a9/6c/kN7UkxDu_o.png" width="1200"></p> 
 <h6 id="%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF%20--%C2%A0%20%E5%AE%8C%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#fbd4d0;">范围for循环 --  完成字符串遍历：</span></strong></h6> 
 <ul><li style="text-align:center;"><strong><span style="color:#1a439c;">范围for循环</span><span style="color:#1c7331;">底层</span><span style="color:#be191c;">是通过</span><span style="color:#1c7331;">迭代器</span><span style="color:#be191c;">实现的</span>，<br><span style="color:#be191c;">是</span><span style="color:#1c7331;">C++11</span><span style="color:#be191c;">支持的</span><span style="color:#1c7331;">更简洁的范围for循环</span><span style="color:#be191c;">的</span><span style="color:#1c7331;">新遍历方式</span></strong></li></ul> 
 <p style="text-align:center;"><strong><span style="color:#956fe7;">对应图示</span>：</strong></p> 
 <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/44/2d/0rOZKST5_o.png" width="1200"></p> 
</blockquote> 
<p style="text-align:center;"><strong>         </strong></p> 
<p style="text-align:center;"><strong>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</strong></p> 
<p style="text-align:center;"><strong>             </strong></p> 
<h2 id="%E6%9C%AC%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#f9eda6;">本篇博客相关代码：</span></strong></h2> 
<blockquote> 
 <h3 id="Test.cpp%E6%96%87%E4%BB%B6%20--%20C%2B%2B%E6%96%87%E4%BB%B6%EF%BC%9A" style="text-align:center;"><strong><span style="background-color:#d4e9d5;">Test.cpp文件 -- C++文件：</span></strong></h3> 
 <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

//包含IO流头文件：
#include&lt;iostream&gt;
//完全展开std命名空间：
using namespace std;

//包含string类头文件：
#include&lt;string&gt;

#include&lt;vector&gt;
#include&lt;list&gt;

//template&lt;class T&gt;
//T* func(int n)
//{
//	return new T[n];
//}
//
主函数：
//int main()
//{
//	func&lt;double&gt; (10);
//	
//	return 0;
//}



string类的默认成员函数：
主函数：
//int main()
//{
//	//string：
//	/*
//	* string是一个类模板，
//	* typedef basic_string&lt;char&gt; string;
//	* 原名是叫 basic_string&lt;char&gt; 的类模板，
//	* 被typedef重命名为string
//	*/
//
//	//string类的默认成员函数 -- 构造函数：
//	//string类中有7种构造函数：
//	/*
//	*（最常用）1：无参的string -- string(); 
//	*（最常用）2：string (const char* s);
//	* 3：string (const string&amp; str);
//	* 4：string (const string&amp; str, size_t pos, size_t len = npos);
//	* 5：string (const char* s, size_t n);
//	* 6：string (size_t n, char c);
//	* 7：template &lt;class InputIterator&gt; string (InputIterator first, InputIterator last);
//	*/
//
//	//（最常用）1：无参的string -- string(); 
//	string s1;
//
//
//	//（最常用）2：string (const char* s);
//	string s2("hello world");
//	/*
//	* s：接收一个字符串
//	* 创建一个字符串类，
//	* 并使用C语言的常量字符串的地址进行初始化，
//	* s2就存储着这段常量字符串
//	*/
//
//
//	//赋值“=”，调用拷贝构造初始化：
//	string s3 = s2;
//	/*
//	* 该写法相当于4中的：string s3(s2);
//	*/
//	
//
//	//3：string (const string&amp; str);
//	string s4(s3);
//	/*
//	* str：接收string字符串类对象
//	* 拷贝str字符串对象，
//	* 该写法相当于3中的：string s4 = s3;
//	* 这种方法也是调用拷贝构造函数进行初始化的
//	*/
//
//	/*
//	* 因为string类重载了 流插入/流提取：
//	*	operator &lt;&lt; / operator &gt;&gt;
//	* 所以是可以直接使用 输出流/输入流 的
//	*/
//	cout &lt;&lt; "构造函数1：" &lt;&lt; s1 &lt;&lt; endl;
//	cout &lt;&lt; "构造函数2：" &lt;&lt; s2 &lt;&lt; endl;
//	cout &lt;&lt; "赋值“=”：" &lt;&lt; s3 &lt;&lt; endl;
//	cout &lt;&lt; "构造函数3：" &lt;&lt; s4 &lt;&lt; endl;
//
//
//	//4：string (const string&amp; str, size_t pos, size_t len = npos);
//	/*
//	* str：接收string字符串类对象
//	* pos：下标
//	* len：长度
//	* npos：一个整型静态const无符号的变量，值为-1，
//	*		因为无符号，-1会是整型的最大值，
//	*		所以如果不对len初始化的话，len的缺省值就是很大的值，
//	*		所以会拷贝很长的字符串，即拷贝pos后的所有字符了
//	*		（len不给默认拷贝str中pos下标后的所有字符）
//	* 
//	* 这个string类函数的功能是拷贝字符串str的一部分，
//	* 从pos下标开始，拷贝len长度的字符串
//	*/
//	string s5(s2, 1, 5);
//	/*
//	* 从s2字符串的第1个字符开始，
//	* （s2：“hello world”）
//	* 往后拷贝5个字符长度的字符串，
//	* 拷贝结果存放在字符串s5中。
//	* （s5：“ello ”）
//	* 注：空格也算一个字符；
//	*     len如果超过str的长度，则str结尾为止
//	*/
//	cout &lt;&lt; "构造函数4：" &lt;&lt; s5 &lt;&lt; endl;
//	
//
//	//5：string (const char* s, size_t n);
//	/*
//	* s：字符串指针
//	* n：在s字符串中拷贝字符长度
//	*/
//	string s6("hello world", 5);
//	/*
//	* 拷贝“hello world”中的前5个字符，
//	* 拷贝到s6中初始化s6
//	*/
//	cout &lt;&lt; "构造函数5：" &lt;&lt; s6 &lt;&lt; endl;
//
//
//	//6：string (size_t n, char c);
//	/*
//	* n：填充的字符个数
//	* c：要填充的字符
//	* 使用n个c字符来填充字符串字符串
//	*/
//	string s7(10, 'x');
//	/*
//	* 使用10个‘x’来填充s7
//	*/
//	cout &lt;&lt; "构造函数6：" &lt;&lt; s7 &lt;&lt; endl;
//
//
//	//7：template &lt;class InputIterator&gt; string (InputIterator first, InputIterator last);
//	/*
//	* 这个string类构造函数因为涉及迭代器的内容，
//	* 所以等了解了迭代器再来了解该类构造函数
//	*/
//
//
//
//
//
//	//string类的默认成员函数 -- 析构函数：
//	/*
//	* string类的析构函数：
//	* string字符串类为了支持扩容，
//	* 其字符数组是动态开辟的，
//	* 动态开辟的空间使用后要进行释放，
//	* 其释放工作就是由析构函数负责的，
//	* 而析构函数一般是自动调用的
//	*/
//	
//
//	//string类的默认成员函数 -- 赋值“=”运算符重载函数：
//	//string::operator= （string类赋值“=”运算符重载函数）
//	/*
//	* 第1种： string&amp; operator= (const string&amp; str);
//	* 第2种： string&amp; operator= (const char* s);
//	* 第3种： string&amp; operator= (char c);
//	* 
//	* 第1种是支持string字符串类对象进行赋值；
//	* 第2种是支持字符串（直接写出字符串）进行赋值；
//	* 第3种是支持单个字符进行赋值
//	*/
//	//string类第1种赋值方法：
//	s1 = s2; //string字符串类对象进行赋值
//	cout &lt;&lt; "赋值=运算符重载函数1：" &lt;&lt; s1 &lt;&lt; endl;
//
//	//string类第2种赋值方法：
//	s1 = "world"; //字符串（直接写出字符串）进行赋值
//	cout &lt;&lt; "赋值=运算符重载函数2：" &lt;&lt; s1 &lt;&lt; endl;
//
//	//string类第3种赋值方法：
//	s1 = 'x'; //单个字符进行赋值
//	cout &lt;&lt; "赋值=运算符重载函数3：" &lt;&lt; s1 &lt;&lt; endl;
//	
//	
//	return 0;
//}


namespace ggdpz
//防止和std中的string命名冲突：
{
	//string类（自己的）：
	class string
	{
	private: //私有成员变量：

		char* _str; //字符数组（字符串）指针
		size_t _size; //字符数组大小（长度）
		size_t _capacity; //字符数组容量

		/*
		* 可以简单想象string类的私有成员变量
		* 就是这几个
		*/
	};
}


//string类的遍历和访问：
int main()
{
	string s1("hello world");
	/*
	* string本质是个字符数组，
	* 只不过通过类封装在一起，
	* 如果想要遍历string字符串的话有两种方法：
	* 
	* 遍历的第1种方法：下标 + []
	* 我们访问数组的时候会使用到方括号“[]”，
	* string的底层是数组实现的，所以会对“[]”进行重载，
	* 即operator[]，使用string类的operator[]后，
	* 就可以像访问数组一样访问字符串（字符数组）了
	*/

	//string类的成员函数 -- 下标“[]”运算符重载函数：
	//string::operator[]
	/*
	* 第1种： char&amp; operator[] (size_t pos);
	* 第2种： const char&amp; operator[] (size_t pos) const;
	* 
	* pos：访问string字符串对象pos下标的
	* char&amp;：访问pos下标字符后返回该字符的引用（“别名”），
	*		 如果是普通对象则可以修改该字符
	* 
	* 第2种是第1种的重载版本
	*/

	//要获取string类对象的长度有两种方法：
	//第一种方法：size()
	cout &lt;&lt; s1.size() &lt;&lt; endl; 
	//第二种方法：length()
	cout &lt;&lt; s1.length() &lt;&lt; endl; 
	/*
	* size() 和 length() 都是返回字符串对象s1的长度，
	* 至于同个功能取两个名字，是因为历史发展的关系，
	* 对于字符串，长度其实使用length()会更合理，
	* 但由于string产生得比STL早，STL出来前string只有length()，
	* 当STL出来后，对像set(树)这种数据结构length(长度)就不太合适了，
	* STL设置接口的时候又需要一定的统一性，length又不能统一使用，
	* 所以又设置了size(大小)，所以string类中又有了size(),
	* 之后计算string类时使用size()即可，按照STL的标准来
	* 
	* size() 和 length() 计算string类时不会计算"\0"
	*/
	
	//第一种遍历方法：使用for循环遍历字符串：
	for (size_t i = 0; i &lt; s1.size(); i++)
		//s1.size() 就可以返回string类对象s1的长度
	{
		/*
		* 第1种： char&amp; operator[] (size_t pos);
		*/
		//遍历打印string类对象s1的字符：
		cout &lt;&lt; s1[i] &lt;&lt; " ";
		//cout &lt;&lt; s1.operator[](i) &lt;&lt; " "; //等于上面的代码
		/*
		* 这里遍历string类时使用了下标运算符"[]"，
		* 让string类可以像遍历数组一样被遍历，
		* 实际string字符串类对象s1调用了下标“[]”运算符重载函数，
		* s1[i] 即 s1.operator[](i)
		*/
	}
	cout &lt;&lt; endl; //换行


	/*
	* 使用下标符[]可以读数据，
	* 还可以用它来写数据，跟数组类似，
	* 因为operator[]调用后返回的是char&amp;，
	* 是一个引用，所以字符串使用[]可以直接写（修改）数据
	*/
	s1[0] = 'x';
	cout &lt;&lt; s1 &lt;&lt; endl;


	//逆置string字符串：
	int begin = 0; //字符串左边界（下标）
	int end = s1.size() - 1; //字符串右边界（下标）
	/*
	* 右边界即字符串最后一个字符下标，
	* 使用size()获得字符串长度，
	* 字符串长度 - 1，即最后一个字符下标
	*/

	while (begin &lt; end) 
		/*
		* begin &lt; end，
		* 说明字符串中还有字符能够逆置
		*/
	{
		//1、通过创建临时变量实现两值交换：
		/*
		* //创建临时变量存储左边界：
		* char tmp = s1[begin];
		*
		* //将右边界字符赋给左边界字符：
		* s1[begin] = s1[end];
		*
		* //将左边界字符赋给右边界字符：
		* s1[end] = tmp;
		*/

		//2、通过C++自带的swap交换函数实现两值交换：
		swap(s1[begin], s1[end]);
		/*
		* C++自带交换函数swap，
		* 因为C++中有了函数模板，
		* 所以不用考虑实际类型的问题，
		* 从而实现了通用的swap交换函数，
		* 使用swap函数需要包含&lt;utility&gt;头文件，
		* 但是这里该头文件间接包含了，
		* 所以不用再显式写出来
		*/

		//进行迭代：
		++begin; //调整左边界
		--end; //调整右边界
	}

	cout &lt;&lt; s1 &lt;&lt; endl;



	//第二种遍历方法：使用迭代器iterator遍历字符串：
	string::iterator it = s1.begin();
	/*
	* iterator定义在类域中，但它不是内部类，是一个类型，
	* 现在还不熟悉迭代器，它的用法类似指针，
	* 但迭代器不一定是指针
	* 
	* it可以理解成指向字符串（字符数组）首字符的指针，
	* begin() 和 end() 迭代器区间是“左闭右开”的，
	* begin()可以理解成指向字符串首字符的指针，
	* end()可以理解成指向最后一个有效字符的下一位字符（'/0'）的指针，
	*/
	while (it != s1.end())
	{
		*it += 1; //通过迭代器也可以写（修改）数据
		/*
		* it一开始指向字符串首字符，
		* *it解引用指针后就可以修改该位置的字符了，
		*/
		cout &lt;&lt; *it &lt;&lt; " "; //打印当前it指针的字符
		++it; //调整it指针位置

		/*
		* it实际可能是指针，也可能不是指针，
		* 可以发现iterator迭代器实际运作方式，
		* 就像是用指针的方式进行字符串遍历访问和修改
		*/

		/*
		* 下标运算符[]，只能底层有一定连续的情况下使用，
		* 所以不是所有容器都能够支持。
		* 真正访问容器最方便主流的就是迭代器
		* （链式结构、树形、哈希结构 只能使用迭代器）
		* 
		* 而且各类容器调用迭代器的方式都是相同，
		* 会调用一个容器的迭代器，
		* 其它容器的迭代器也就会使用了
		*/
	}

	cout &lt;&lt; endl;


	//对于字符串的逆置，在C++算法中也有，
	//直接调用即可：
	reverse(s1.begin(), s1.end());
	/*
	* 该算法名叫reverse，
	* 使用时传 开始 和 结束 的位置即可,
	* 无论什么容器，只要传迭代器区间给reverse，
	* 就可以实现逆置
	* 
	* 所以迭代器还可以配合算法使用（nb）
	* C++算法也是泛型编程，
	* 不是针对某个容器的迭代器实现的，
	* 函数模板，针对各个容器的迭代器实现
	*/
	cout &lt;&lt; s1 &lt;&lt; endl;

	return 0;
}


//迭代器：
int main()
{
	//vector类：
	vector&lt;int&gt; v;

	//尾插入数据：
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);

	//vector可以使用类遍历，
	//也可以使用迭代器遍历：
	vector&lt;int&gt;::iterator vit = v.begin();
	/*
	* begin() 会获取第一个位置的迭代器（左闭）,
	* 迭代器的区间都是左闭右开的,
	* end() 会获取最后一个数据的下一个位置（右开）
	*/

	while (vit != v.end())
		//begin() 还未到 end() ：
	{
		//解引用vit获取当前位置数据：
		cout &lt;&lt; *vit &lt;&lt; " ";
		++vit; //调整指针
	}

	cout &lt;&lt; endl; //换行
	
	//reverse 也可以实现vector的逆置：
	reverse(v.begin(), v.end());



	//list类：
	list&lt;double&gt; lt;

	//尾插入数据：
	lt.push_back(1.1);
	lt.push_back(2.1);
	lt.push_back(3.1);
	lt.push_back(4.1);

	//使用迭代器遍历list：
	list&lt;double&gt;::iterator lit = lt.begin();

	while (lit != lt.end())
		//begin() 还未到 end() ：
	{
		//解引用vit获取当前位置数据：
		cout &lt;&lt; *lit &lt;&lt; " ";
		++lit; //调整指针
	}

	cout &lt;&lt; endl; //换行

	//reverse 也可以实现list的逆置：
	reverse(lt.begin(), lt.end());

	return 0;
}



int main()
{
	/*
	* 第2种： const char&amp; operator[] (size_t pos) const;
	* 这个重载构造函数的隐藏this指针是用const修饰的，
	* 该函数主要是为了解决参数匹配的问题
	*/
	string s1{ "hello world" }; //非const对象
	const string s2{ "hello world" }; //const对象
	s1[0] = 'x'; //非const对象s1调用"[]"
	s2[1] = 'x'; //const对象s2调用"[]"
	/*
	* 非const对象s1调用的"[]"运算符重载函数：
	* 第1种： char&amp; operator[] (size_t pos);
	* 
	* const对象s2调用的"[]"运算符重载函数：
	* 第2种： const char&amp; operator[] (size_t pos) const;
	* (const：只读，不能修改)
	* 
	* s1也可以调用“第2种”，非const调用const，
	* “可读可写” 变成 “只读”，访问权限缩小是允许的，
	* 虽然都可以调用“第2种”，但是“第2种”的返回值是const char&amp;，
	* 非const对象调用后返回“只读”的引用（别名）就不合适，
	* 所以还需要实现“第1种” 
	*/

	/*
	* 对于const的string对象s2，因为“只读”，
	* 所以不能像s1非const对象那样使用迭代器：
	*/
	//string::iterator it = s2.begin(); //编译错误

	//应该是const_iterator（“只读”）而不是iterator（“可读可写”）：
	string::const_iterator it = s2.begin();
	while (it != s2.end())
	{
		//*it += 1; //const对象数据无法被修改
		cout &lt;&lt; *it &lt;&lt; " ";
		++it; //迭代器it本身是可以修改的
	}
	cout &lt;&lt; endl;
	/*
	* string类的迭代器中的 begin / end，
	* 其实现时也有两个版本：
	* 第1种：iterator begin();
	* 第2种：const_iterator begin() const;
	* 
	* 其中“第2种”const版本中，
	* 它是名字为：const_iterator，
	* 而不是在iterator前直接加const修饰，
	* 
	* 
	* 
	* const_iterator it 和 const iterator it：
	* 
	* const_iterator it 本质是修饰迭代器指向的数据，
	* 即 *it 不能被修改
	* 
	* const iterator it 修饰的是迭代器本身，
	* 迭代器本身不能被修改，即 it 不能被修改，
	* 要进行遍历的话，得调整it（it++），
	* 所以不能直接在iterator前加const进行修饰
	*/



	//容器都能支持范围for循环：
	for (auto e : s1)
		//依次取容器对象s1放入e中进行循环遍历：
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;


	return 0;
}



一般在传参才会用到const对象：
(让对象在函数中使用时不会被改变)
//void func(const string&amp; s)
//{
//	//第二种：const对象版本：
//	string::const_reverse_iterator it = s.rbegin();
//	//这里反向迭代器的const版本的类型很长，所以可以用auto进行省略：
//	auto it = s.rbegin();
//	
//	//进行反向遍历：
//	while (it != s.rend())
//	{
//		//"只读"
//		//*it1 = 'x'; //报错，无法‘写’
//
//		//打印当前字符串s1中it指针指向的字符：
//		cout &lt;&lt; *it &lt;&lt; " ";
//		//调整it指针：
//		++it;
//	}
//	cout &lt;&lt; endl; //换行
//}
//
//
//int main()
//{
//	//string类对象：
//	string s1("hello world");
//	/*
//	* string类对象的三种遍历方式：
//	* 1、下标 + [] ：只适用于底层连续的容器
//	* 2、迭代器 ：yyds，能配合算法使用
//	* 3、范围for ：看似好用，实际是依靠迭代器实现的
//	*/
//
//	/*
//	* string的反向迭代器：std::string::rbegin
//	* 
//	* 第一种：reverse_iterator rbegin();
//	* 第二种：const_reverse_iterator rbegin() const;
//	* (rend 和 rbegin 类似)
//	* 
//	* 对于没有下标的情况，如链表，如果要进行倒着遍历，
//	* 就可以使用其反向迭代器，掌握了迭代器，
//	* 就掌握了所有容器的遍历、访问、修改
//	*/
//	  
//	//第一种：非const版本：
//	string::reverse_iterator it1 = s1.rbegin();
//	//进行反向遍历：
//	while (it1 != s1.rend())
//	{
//		//"可读可写"
//		//*it1 = 'x'; //‘写’
//		
//		//打印当前字符串s1中it指针指向的字符：
//		cout &lt;&lt; *it1 &lt;&lt; " ";
//		//调整it指针：
//		++it1;
//	}
//	cout &lt;&lt; endl; //换行
//
//	/*
//	* 打印："d l r o w  o l l e h"，
//	* 即实现了s1："h e l l o  w o r l d"的反向遍历
//	*/
//
//
//	//第二种：const对象版本：
//	func(s1);
//	/*
//	* func函数接收const对象，
//	* s1不是const对象，传过去后权限缩小，
//	* “可读可写” 变成 “只读”
//	*/
//
//	return 0;
//}



//int main()
//{
//	//std::string::max_size
//	//（返回字符串可以达到的最大长度）
//
//	//无参字符串对象：
//	string s1;
//
//	//有参字符串对象：
//	string s2("hello world");
//
//	cout &lt;&lt; s1.max_size() &lt;&lt; endl;
//	cout &lt;&lt; s2.max_size() &lt;&lt; endl;
//	/*
//	* 无论是s1的无参，还是s2的有参，
//	* 打印两者的“max_size()”时，
//	* (32位系统)都是“214783647”(2^31)，
//	* 即整型最大值的一半,
//	* 也就是说此时这两个字符串能达到的最大长度为2^31,
//	* 这是在VS2022上，不同编译器可能不同，
//	* 不同系统也不同（x64/x86），
//	* 实际也不一定就开了2^31个字符的空间
//	*/
//
//
//
//	//std::string::reserve
//	/*
//	* （为字符串预留空间，可以进行扩容操作）
//	* 注意和revserve进行区分，
//	* reserve：保留
//	* reverse：反转、逆置
//	*/
//	s1.reserve(s1.max_size());
//	//保留max_size个空间
//
//	//std::string::capacity
//	//（实际能够存储的有效字符个数）
//	cout &lt;&lt; s1.capacity() &lt;&lt; endl; //“15”
//	cout &lt;&lt; s2.capacity() &lt;&lt; endl; //“15”
//	/*
//	* string s1;
//	* string s2("hello world");
//	*
//	* s1 和 s2 的capacity打印时都是“15”，
//	* 即实际可存储的有效字符个数为15，
//	* 但实际是有16个空间的，有一个空间给了"\0"，
//	* "\0"不算有效字符，而是标识字符，
//	* 所以capacity打印时为“15”
//	*/
//
//
//
//	//std::string::resize
//	//（将有效字符的个数分割成n个，多出的空间用字符c填充）
//	/*
//	* reserve：只影响容量，不会影响数据；
//	* resize：即影响容量，也影响数据
//	* 
//	* resize有两种实现：
//	* 1、void resize(size_t n);
//	* 2、void resize(size_t n, char c);
//	* 
//	* resize的使用分三种情况：
//	*/
//
//	string s1("hello world");
//	//起始字符串大小（长度）-- 11
//	cout &lt;&lt; s1.size() &lt;&lt; endl;
//	//起始容量 -- 15
//	cout &lt;&lt; s1.capacity() &lt;&lt; endl; 
//
//	//第一种情况：resize分割数 &gt; capacity
//	//	（即影响容量，又影响数据）
//	//size为11，capacity为15，分割数为100：
//	s1.resize(100); 
//	
//	//分割后字符串大小 -- 100
//	cout &lt;&lt; s1.size() &lt;&lt; endl; 
//	//分割后容量 -- 111
//	cout &lt;&lt; s1.capacity() &lt;&lt; endl; 
//	/*
//	* 当 resize分割数 &gt; capacity 时，
//	* 分割后capacity容量会增容到至少比分割数大，
//	*（这里 capacity--15 就变成至少比 分割数--100 大的111）
//	* 
//	* 而字符串数据 size 从15变成了100，
//	* 那其余“85”的数据是什么数据呢？
//	* 
//	* 这里的resize是第一种实现：void resize(size_t n);
//	* 使用resize这种实现，且 resize分割数 &gt; capacity 时，
//	* 多出的数据就会用 空字符(初识字符)--'/0' 插入，
//	* 这里的'/0'就不是标识字符了，而是有效字符了，
//	* '/0'是哪种字符，取决于'/0'是否在size范围中，
//	* 这里增容后，size从15扩大到100并用'/0'插入充当多余数据，
//	* 此时“数据'/0'”就不是结束符而是有效数据了
//	* 
//	* 如果是第二种实现：void resize(size_t n, char c);
//	* 相同情况下，多出的数据就会用传过来的 字符c 插入
//	* 
//	* resize分割数 &gt; capacity ---- “扩容 + 尾插”
//	*/
//
//
//	string s2("hello world");
//	//起始字符串大小（长度）-- 11
//	cout &lt;&lt; s2.size() &lt;&lt; endl;
//	//起始容量 -- 15
//	cout &lt;&lt; s2.capacity() &lt;&lt; endl;
//
//	//第二种情况：size &lt; n &lt; capacity
//	//（只会改变字符串大小size）
//	//size为11，capacity为15，分割数n为12：
//	s2.resize(12);
//
//	//分割后字符串大小 -- 12
//	cout &lt;&lt; s2.size() &lt;&lt; endl;
//	//分割后容量 -- 15
//	cout &lt;&lt; s2.capacity() &lt;&lt; endl;
//	/*
//	* 在VS中，reserve不会缩容，resize也不会缩容，
//	* 所以容量还是15，不会改变，
//	* 字符串数据size还是和第一种情况类似，
//	* size &lt; 分割数n，数据size就增加到b，
//	* 并用'/0'或'字符c'插入充当多余数据，
//	*（插入的数据取决于resize是哪种实现）
//	* 
//	*（g++ 和 VS 的resize在这种情况下是一样的）
//	* size &lt; n &lt; capacity ---- “尾插（容量足够）”
//	*/
//
//
//	string s3("hello world");
//	//起始字符串大小（长度）-- 11
//	cout &lt;&lt; s3.size() &lt;&lt; endl;
//	//起始容量 -- 15
//	cout &lt;&lt; s3.capacity() &lt;&lt; endl;
//
//	//第三种情况：分割数n &lt; size
//	//（只会改变字符串大小size）
//	//size为11，capacity为15，分割数n为5：
//	s3.resize(5);
//
//	//分割后字符串大小 -- 5
//	cout &lt;&lt; s3.size() &lt;&lt; endl;
//	//分割后容量 -- 15
//	cout &lt;&lt; s3.capacity() &lt;&lt; endl;
//	/*
//	* 和第二种情况一样，
//	* 因为capacity容量足够，
//	* 所以不会改变空间大小，
//	* 只对数据进行分割
//	*（g++中和VS也是一样的）
//	* 
//	* 分割数n &lt; size ---- “删除数据，保留分割数n个”
//	*/
//
//	/*
//	* 总结：
//	* resize一定会对数据大小size进行操作，
//	* 对容量capacity可能会进行增容操作
//	*（g++ 和 VS 两个主流平台中）
//	* 在第一种情况中可以 增加数据，
//	* 在第三种情况中可以 删除数据
//	* 所以resize的作用就是：
//	* 1、插入数据（如果空间不够还会扩容）
//	* 2、删除数据
//	* 更多场景下是用于开空间并初始化
//	*/
//}

//int main()
//{
//	//reserve 和 capacity 的使用：
//
//	//无参字符串对象：
//	string s1;
//	//有参字符串对象：
//	string s2("hello world");
//
//	//使用reserve进行空间预留：
//	s1.reserve(500);
//	/*
//	* 如果我们知道大概需要多少空间，
//	* 则可以使用reserve提前开好空间，
//	* 不需要进行后面的扩容操作，
//	* 打印结果："15、511"
//	* 容量直接一次性扩容到足够存储500个有效字符
//	* （实际512个空间）
//	*/
//
//	//通过capacity检车string的扩容机制：
//	size_t old = s1.capacity(); //s1此时容量
//	cout &lt;&lt; old &lt;&lt; endl; 
//
//	for (size_t i = 0; i &lt; 100; i++)
//	{
//		//循环依次，尾插一个字符：
//		s1.push_back('x');
//
//		if (old != s1.capacity())
//			/*
//			* 如果 old 和当前容量不同，
//			* 说明old容量被扩容了
//			*/
//		{
//			//打印扩容后容量：
//			cout &lt;&lt; s1.capacity() &lt;&lt; endl;
//			//更新old容量：
//			old = s1.capacity();
//		}
//	}
//	/*
//	* 如果没有使用reserve进行空间预留，则会进行扩容操作：
//	* 
//	* 打印结果：“15、31、47、70、105”
//	* 容量从15变成31在变成47……
//	* 从整体来说，是按当前容量的1.5倍进行扩容
//	* 
//	* 不同编译器容量和扩容操作不同：
//	* VS -- "15、31、47、70、105" -- 1.5倍扩容
//	* gcc -- "0、1、2、4、8、16……" -- 2倍扩容
//	*/
//
//	/*
//	* reserve在VS上只会增容；
//	* 
//	* 在g++上除了增容，还可以缩容，
//	* 但缩容不会影响数据，只会影响空间，
//	* 即最多缩容到现存数据大小的空间
//	*（缩容不会删除数据，最小缩到size）
//	*/
//}


int main()
{
	
	return 0;
}</code></pre> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d38b3db8f9b7fd63839d516a2865c1e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023-12-22 回溯算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/311b00fdec9a1f828bb1e51039acaac3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">软件测试面试八股文——基础篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>