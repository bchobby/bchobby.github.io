<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第六章 Linux 磁盘管理 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第六章 Linux 磁盘管理" />
<meta property="og:description" content="第六章 Linux 磁盘管理 1、磁盘分区、格式化、文件系统、文件系统类型、挂载、挂载点 的概念1）对该磁盘进行分区（分割）2）对某个分区进行格式化3）挂载4）一块硬盘需要经过哪些步骤才可以被我们 Linux 操作系统用来实际的存取数据呢？ 2、查看文件系统使用情况（比如容量空间的使用情况）4、列出所有可用块设备的信息（即列出系统上所有存储5、磁盘分区1）通过 MSDOS (MBR) 分区表 方式分区2）GPT 分区表（GUID partition table） 方式分区3）partprobe [-s]4）parted 命令 6、格式化（写入文件系统）1）Linux 下常见的文件系统类型：2）格式化操作3）查看文件系统信息 7、挂载/卸载文件系统1）使用 mount 进行手动挂载 1、磁盘分区、格式化、文件系统、文件系统类型、挂载、挂载点 的概念 如果我们想在系统中增加一块硬盘用于数据存取，那么大概需要以下步骤：
1）对该磁盘进行分区（分割） 目的，一是为了分割硬盘空间方便管理，更重要的是让各个分区都基本独立开来，这样如果某个区发生问题，至少不会直接影响到其他分区。
举例：如果把一块磁盘比喻成一大块地，那么对磁盘进行分区就相当于是把地按照需要划分成几块地或者几个区域。划分出来的某块地或者某个区域我们一般称作“某个分区”
2）对某个分区进行格式化 各种操作系统都必须按照一定的方式来管理数据，对分区进行格式化的目的是为了在分区里写入文件系统，这样才能被操作系统使用。
举例：我们把向磁盘里存数据比喻成现实生活中向“银行保管箱”里存物贵重品
地刚刚你已经分好了，可是这个地你能直接用来存物品吗？当然不行，你得在分好的某块地上建好大厦以及在大厦里构建保管柜，这样才能够用于存储物品。
■ 磁盘分区也是同样的道理，要想能够被操作系统用于实际的存储数据，还得在磁盘分区里写入文件系统，也就是所谓的“格式化”，即操作系统需要按照特定的规划去建设开发这个分区，开发好后才能被操作系统用作数据存储。
■ 问一下：向分区写入文件系统，这个文件系统本身会占用磁盘空间吗？
■ 在地上建设大厦和构建保管柜，建设大厦时肯定可以有不同的结构供选择吧？保管柜也有不同的品牌供选择吧？同样的，文件系统也有不同的类型供选择，比如我们 windows 下常见的 NTFS、FAT32 等，它们就是传说中的文件系统类型，而 Linux 下常见的文件系统类型有 EXT*（比如 EXT4）、xfs 等等，具体我们后面讲。
■ 一个分区被格式化（写入文件系统，不管是什么类型的文件系统）后，我们就可以称作它是一个“文件系统”
3）挂载 这个就是把某个文件系统用管子接到某个目录上，对应的目录就称作挂载点，参考第一回！
4）一块硬盘需要经过哪些步骤才可以被我们 Linux 操作系统用来实际的存取数据呢？ 分区（分割） -&gt; 对（某个）分区进行格式化（写入文件系统） -&gt; 挂载
所以比较讲究的说法是：我们称呼一个可被挂载的数据为一个文件系统，而不是叫一个分区
请问：第一步 分区（分割） 是必须的吗？一整块磁盘可不可以不进行分区就直接格式化，然后挂载使用
2、查看文件系统使用情况（比如容量空间的使用情况） df [-ihT] [FILE...] 注： FILE 可以直接指定文件系统（路径），则会打印出该文件系统的磁盘空间使用情况； FILE 也可以指定为非文件系统文件的路径则会输出该文件相关的文件系统的磁盘空间使用情况； 选项： -i：以 inode 数量显示 -h：以较易阅读的单位来显示容量 -T：显示出分区的文件系统格式名称 3、查看目录所占容量（包括其后代文件所占） du [-ahcs] FILE." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/730592cd1978da53548ad014454ab97d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T18:37:24+08:00" />
<meta property="article:modified_time" content="2023-12-27T18:37:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第六章 Linux 磁盘管理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>第六章 Linux 磁盘管理</h4> 
 <ul><li><a href="#1__2" rel="nofollow">1、磁盘分区、格式化、文件系统、文件系统类型、挂载、挂载点 的概念</a></li><li><ul><li><a href="#1_4" rel="nofollow">1）对该磁盘进行分区（分割）</a></li><li><a href="#2_8" rel="nofollow">2）对某个分区进行格式化</a></li><li><a href="#3_18" rel="nofollow">3）挂载</a></li><li><a href="#4_Linux__20" rel="nofollow">4）一块硬盘需要经过哪些步骤才可以被我们 Linux 操作系统用来实际的存取数据呢？</a></li></ul> 
  </li><li><a href="#2_25" rel="nofollow">2、查看文件系统使用情况（比如容量空间的使用情况）</a></li><li><a href="#4_54" rel="nofollow">4、列出所有可用块设备的信息（即列出系统上所有存储</a></li><li><a href="#5_81" rel="nofollow">5、磁盘分区</a></li><li><ul><li><a href="#1_MSDOS_MBR___85" rel="nofollow">1）通过 MSDOS (MBR) 分区表 方式分区</a></li><li><a href="#2GPT_GUID_partition_table__117" rel="nofollow">2）GPT 分区表（GUID partition table） 方式分区</a></li><li><a href="#3partprobe_s_123" rel="nofollow">3）partprobe [-s]</a></li><li><a href="#4parted__127" rel="nofollow">4）parted 命令</a></li></ul> 
  </li><li><a href="#6_140" rel="nofollow">6、格式化（写入文件系统）</a></li><li><ul><li><a href="#1Linux__141" rel="nofollow">1）Linux 下常见的文件系统类型：</a></li><li><a href="#2_158" rel="nofollow">2）格式化操作</a></li><li><a href="#3_168" rel="nofollow">3）查看文件系统信息</a></li></ul> 
  </li><li><a href="#7_205" rel="nofollow">7、挂载/卸载文件系统</a></li><li><ul><li><a href="#1_mount__206" rel="nofollow">1）使用 mount 进行手动挂载</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__2"></a>1、磁盘分区、格式化、文件系统、文件系统类型、挂载、挂载点 的概念</h2> 
<p>如果我们想在系统中增加一块硬盘用于数据存取，那么大概需要以下步骤：</p> 
<h3><a id="1_4"></a>1）对该磁盘进行分区（分割）</h3> 
<p>目的，一是为了分割硬盘空间方便管理，更重要的是让各个分区都基本独立开来，这样如果某个区发生问题，至少不会直接影响到其他分区。</p> 
<p>举例：如果把一块磁盘比喻成一大块地，那么对磁盘进行分区就相当于是把地按照需要划分成几块地或者几个区域。划分出来的某块地或者某个区域我们一般称作“某个分区”</p> 
<h3><a id="2_8"></a>2）对某个分区进行格式化</h3> 
<p>各种操作系统都必须按照一定的方式来管理数据，对分区进行格式化的目的是为了在分区里写入文件系统，这样才能被操作系统使用。</p> 
<p>举例：我们把向磁盘里存数据比喻成现实生活中向“银行保管箱”里存物贵重品<br> <img src="https://images2.imgbox.com/0f/63/3fbge2bV_o.png" alt="在这里插入图片描述"><br> 地刚刚你已经分好了，可是这个地你能直接用来存物品吗？当然不行，你得在分好的某块地上建好大厦以及在大厦里构建保管柜，这样才能够用于存储物品。<br> ■ 磁盘分区也是同样的道理，要想能够被操作系统用于实际的存储数据，还得在磁盘分区里写入文件系统，也就是所谓的“格式化”，即操作系统需要按照特定的规划去建设开发这个分区，开发好后才能被操作系统用作数据存储。<br> ■ 问一下：向分区写入文件系统，这个文件系统本身会占用磁盘空间吗？<br> ■ 在地上建设大厦和构建保管柜，建设大厦时肯定可以有不同的结构供选择吧？保管柜也有不同的品牌供选择吧？同样的，文件系统也有不同的类型供选择，比如我们 windows 下常见的 NTFS、FAT32 等，它们就是传说中的文件系统类型，而 Linux 下常见的文件系统类型有 EXT*（比如 EXT4）、xfs 等等，具体我们后面讲。<br> ■ 一个分区被格式化（写入文件系统，不管是什么类型的文件系统）后，我们就可以称作它是一个“文件系统”</p> 
<h3><a id="3_18"></a>3）挂载</h3> 
<p>这个就是把某个文件系统用管子接到某个目录上，对应的目录就称作挂载点，参考第一回！</p> 
<h3><a id="4_Linux__20"></a>4）一块硬盘需要经过哪些步骤才可以被我们 Linux 操作系统用来实际的存取数据呢？</h3> 
<p>分区（分割） -&gt; 对（某个）分区进行格式化（写入文件系统） -&gt; 挂载</p> 
<p>所以比较讲究的说法是：我们称呼一个可被挂载的数据为一个文件系统，而不是叫一个分区<br> 请问：第一步 分区（分割） 是必须的吗？一整块磁盘可不可以不进行分区就直接格式化，然后挂载使用</p> 
<h2><a id="2_25"></a>2、查看文件系统使用情况（比如容量空间的使用情况）</h2> 
<pre><code class="prism language-xml">df [-ihT] [FILE...]
</code></pre> 
<pre><code class="prism language-xml">注：
FILE 可以直接指定文件系统（路径），则会打印出该文件系统的磁盘空间使用情况；
FILE 也可以指定为非文件系统文件的路径则会输出该文件相关的文件系统的磁盘空间使用情况；
</code></pre> 
<pre><code class="prism language-xml">选项：
-i：以 inode 数量显示
-h：以较易阅读的单位来显示容量
-T：显示出分区的文件系统格式名称
3、查看目录所占容量（包括其后代文件所占）
du [-ahcs] FILE... 选项：
-h：以较易阅读的单位来显示容量（常用）
-s：只列出总量（常用）
-a：将文件的容量也显示出来，而不是仅仅列
-c：最后列出总量
</code></pre> 
<pre><code class="prism language-xml">常用形式：du -sh FILE...
</code></pre> 
<h2><a id="4_54"></a>4、列出所有可用块设备的信息（即列出系统上所有存储</h2> 
<pre><code class="prism language-xml">lsblk [-dfp] [device]
</code></pre> 
<p>注：可以看成是 list block device 的缩写，这个命令很重要可以看到系统上块设备的各种情况比如容量这些都是可以查看的！</p> 
<pre><code class="prism language-xml">选项：
-d：仅列出磁盘，而不列出其分区信息
-f：显示文件系统信息，比如类型以及 UUID 等；UUID 是通用唯一识别码，Linux 会将系统内所有的装置都给予一个独一无二的识别码
-p：列出完整路径！而不是仅列出名字
</code></pre> 
<p>PS：一般我们是直接敲 lsblk 来查看</p> 
<pre><code class="prism language-xml">■ 存储设备名称规范：
■ 物理磁盘：/dev/sd[a-z]，比如/dev/sda、/dev/sdb 等等
■ 该磁盘的分区：
/dev/sd[a-z]数字，比如/dev/sda1：表示是/dev/sda 这个磁盘的某个分区，其中数字 1 是分区号。
■ 云服务上磁盘可能为：/dev/vd[a-z]
■ 该磁盘的分区：同理...
■ 所以查看存储设备也可以通过类似这种方法：
ls -l /dev/[sv]d
</code></pre> 
<h2><a id="5_81"></a>5、磁盘分区</h2> 
<blockquote> 
 <p>分区的两种方式： MSDOS (MBR) 分区表方式分区、GPT 分区表（GUID partition table） 方式分区，他们各自有什么特点呢？</p> 
</blockquote> 
<h3><a id="1_MSDOS_MBR___85"></a>1）通过 MSDOS (MBR) 分区表 方式分区</h3> 
<p>①特点：<br> ■ 主分区+扩展分区 最多 4 个<br> ■ 扩展分区最多只有一个<br> ■ 可以在扩展分区下 划分出多个逻辑分区<br> ■ 不能直接支持 2T 以上磁盘</p> 
<p>②有人可能有疑问为什么分区还分什么主分区、扩展分区、逻辑分区这些名词呢？<br> 其实归根到底是因为 MSDOS (MBR) 分区表的分区方式技术上最多只能有四个分区，4 个分区实在是很容易就不够用，怎么办呢？于是牛人就想办法把一个分区作为扩展分区（扩展分区本身不能直接用的），可以在扩展分区的基础上划分出很多个逻辑分区就可以使用了，这样主分区+多个逻辑分区就可以打破只能有 4 个分区的限制。那逻辑分区与主分区在数据存储上是没有区别的，只是名分不同，至于其具体的硬件层面的技术实现细节就不是我<br> 们应该考虑的问题了！</p> 
<p>③fdisk [-l] [设备名称]<br> ■ 选项：<br> -l：输出后面接的设备所有的分区内容。<br> 若后不接具体设备则把能列出来的都列出来</p> 
<p>④fdisk 后面如果不加-l 选项，而是接磁盘的名称 则可以对该磁盘进行分区</p> 
<pre><code class="prism language-xml">■ 举例：
fdisk /dev/sdb
根据提示输入 m 可获取帮助：

常用的交互命令：
p：打印出当前磁盘的分区信息
n：新建一个新的分区
w：保存
q：退出
d：删除一个分区
注：这个命令是一个非常容易操作的命令，因为每一步都有提示！
</code></pre> 
<h3><a id="2GPT_GUID_partition_table__117"></a>2）GPT 分区表（GUID partition table） 方式分区</h3> 
<p>通过这个分区表方式来分区就强大了，分区数量没有 4 个限制了，所以就没有什么主分区、扩展分区、逻辑分区这些概念了都是分区没有名分的不同了；也没有 2T 容量的限制！所以比上面 MBR 分区表方式的分区更强大更先进。</p> 
<p>警告：其实目前的 fdisk 命令已经开始支持 GPT 分区表方式分区进行分区，不过目前是在实验阶段，不建议生产环境使用。</p> 
<p>所以我们最好使用专门的用于 GPT 分区表方式分区的命令：gdisk，这个命令使用上和 fdisk 类似</p> 
<h3><a id="3partprobe_s_123"></a>3）partprobe [-s]</h3> 
<p>partprobe 更新 Linux 核心的分区表信息，如果分完区结果看不到分区设备信息（虚拟机这边不用），就手动更新下，当然重启系统也可以<br> 选项：<br> -s：显示摘要和分区</p> 
<h3><a id="4parted__127"></a>4）parted 命令</h3> 
<p>parted 支持 MSDOS (MBR) 分区表方式分区 以及 GPT 分区表（GUID partition table） 方式分区进行分区，不过我们上面介绍了 fdisk 与 gdisk 用户体验更好，所以更推 荐你使用 fdisk 或 gdisk 进行分区！parted 命令你如果有兴趣自行查询使用。<br> ■ 查询帮助<br> ①直接敲 parted 进入交互模式（输入之后会等待你输入交互命令）<br> <img src="https://images2.imgbox.com/ce/5c/39pOOsSO_o.png" alt="在这里插入图片描述"></p> 
<p>②输入 help 命令查看这边支持的交互命令<br> <img src="https://images2.imgbox.com/e4/55/R8IGH2Yt_o.png" alt="在这里插入图片描述"></p> 
<p>提示：<br> ■ 这边的交互命令也可以通过 tab 进行自动补全，甚至你不敲 help 直接敲两次 tab 试试！<br> ■ 当然直接通过 man parted 的方式也可以查询 parted 的帮助信息</p> 
<h2><a id="6_140"></a>6、格式化（写入文件系统）</h2> 
<h3><a id="1Linux__141"></a>1）Linux 下常见的文件系统类型：</h3> 
<p>■ ext4<br> 第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是 Linux 系统下的日志文件系统，是 ext3 文件系统的后继版本。<br> ■ 什么叫日志文件系统？<br> 日志文件系统（英语：Journaling file system）是一种文件系统在发生变化时，先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统的文件系统。 在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。<br> ■ 注意：这个日志不是用来修复数据损坏的而是修复文件系统的，你可以理解为他主要修复这种情况：当把物品存入保管箱时，由于突发状况使得银行没有把这个保管箱登记标记为已使用，这时就产生了不一致性（比如实际已使用的保管箱数量与登记系统里记录的不一样）！至于说数据本身的丢失，就不是这个能够恢复的了！<br> ■ xfs<br> xfs，一种高性能的日志文件系统，也是 CentOS7 上默认的文件系统类型（CentOS6 上默认是 ext4）。<br> ■ 比较<br> <img src="https://images2.imgbox.com/fb/d7/956fS9Ej_o.png" alt="在这里插入图片描述"><br> ■ 当然文件系统类型有很多，可以通过以下命令查看当前操作系统支持那些文件系统类型：</p> 
<pre><code class="prism language-xml">ls -l /lib/modules/$(uname -r)/kernel/fs
</code></pre> 
<p>我们知道 ext4 和 xfs 即可</p> 
<h3><a id="2_158"></a>2）格式化操作</h3> 
<p>■ mkfs.xfs [-L] 设备<br> 选项：<br> -L：指定文件系统的 Label name，最长可以有 12<br> 其他参数等以后遇到特殊的格式化需求再 man 查询吧!<br> ■ mkfs.ext4 [-L] 设备<br> ■ mkfs [-t 文件系统类型] 设备<br> 这是个综合命令，当我们使用 mkfs -t xfs 时，它内部就会去执行 mkfs.xfs<br> 选型：<br> -t： 可接系统支持的文件系统类型，例如常见文件系统类型：xfs、ext4 等</p> 
<h3><a id="3_168"></a>3）查看文件系统信息</h3> 
<p>■ dumpe2fs [-h] 文件系统设备路径<br> 显示 ext2/ext3/ext4 类型的文件系统信息<br> 选项：<br> -h：只显示 superblock 信息，superblock 里记载了该文件系统的整体信息比如 inode、date block 的总量、剩余量、以及每个 inode 或 date block<br> 的大小、等属性。<br> ■ xfs_info 文件系统设备路径<br> 显示 xfs 类型的文件系统信息<br> ■ blkid 查看文件系统 UUID 等信息<br> ■ 以列表的形式输出文件系统的设备名路径、文件系统类型、lable、挂载点、UUID 信息<br> <img src="https://images2.imgbox.com/6f/3f/jo0HkB3b_o.png" alt="在这里插入图片描述"></p> 
<p>■ 查看文件系统的 UUID</p> 
<pre><code class="prism language-xml">blkid 文件系统路径
blkid 可列出各个文件系统的 UUID 、文件系统类型 等参数
blkid -s UUID [文件系统设备路径]
如果不指定文件系统路径，则显示所有文件系统的 UUID
</code></pre> 
<p>■ 查看文件系统 LABEL：blkid -s LABEL [文件系统设备路径]<br> 如果不指定文件系统路径，则显示所有文件系统的 LABEL<br> ■ 修改文件系统的 LABEL 即卷名称类似于我们 windows 下盘的名字比如 C、D、E 的意思（如果格式化的时候没有设置可以通过这个方法来设置或修改）<br> ■ ext 类的文件系统，修改某个文件系统的卷标 LABEL 可以使用 e2label 或 tune2fs</p> 
<pre><code class="prism language-xml"> e2label 设备路径 [新 LABEL]
 tune2fs –L 新 LABEL 文件系统设备路径
</code></pre> 
<p>■ xfs 类的文件系统，修改 LABLE 请使用 xfs_admin</p> 
<pre><code class="prism language-xml">xfs_admin -L 新 LABEL
</code></pre> 
<h2><a id="7_205"></a>7、挂载/卸载文件系统</h2> 
<h3><a id="1_mount__206"></a>1）使用 mount 进行手动挂载</h3> 
<p>■ mount [-t 文件系统类型] 文件系统路径 挂载点<br> 选项：<br> -t ：来指定欲挂载的文件系统类型（一般不用加、因为系统会自动分析文件系统类型的）<br> 其他一些选项我们待会再讲</p> 
<p>注：强烈不推荐使用文件系统名称（路径）的方式来挂载，因为不可靠（万一哪天硬盘插入服务器接口的顺序改变了那么名称就变了）！<br> ■ mount [-t 文件系统类型] UUID=‘’ 挂载点<br> 通过文件系统名字挂载并不可靠，所以最好使用文件系统的 UUID 号来挂载！<br> ■ mount [-t 文件系统类型] LABEL=‘’ 挂载点<br> 也可以通过 文件系统的 LABEL 名来挂载<br> ■ mount -o 后面接挂载时设定的参数</p> 
<p>未完待续</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40aa210fdc6752568d91cc935856f476/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">普中STM32-PZ6806L开发板(使用过程中的问题收集)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6912528e0348be77ee7fe49f88eb560c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>