<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一.c#基础 [Unity_Learn_RPG_1] - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一.c#基础 [Unity_Learn_RPG_1]" />
<meta property="og:description" content="一.C#、unity C# 基础 1.面向对象 1).面向过程和面向对象 a.面向过程 就是把一个需求/问题，分成一步步的逻辑，很像数学里的解答。
关心的是解决问题的步骤。
b.面向对象 把需求分为一个个对象。
关心的是对象在做什么。以及对象之间的交互。
2).类和对象 a.先有类还是现有对象 设计角度：现有对象，再有类。根据需求，我们从中分析，提取出一有相同行为的&#34;类”。
编码角度：肯定是先有类了，不然new 什么呢？
b.类与类 类是抽象的。是抽象的&#34;类别&#34;。类与类行为不同。
什么是行为？我的理解其实就是代码，如果一个类的代码改变了，那么它的逻辑也改变，逻辑改变体现在对象的实际执行上，也就是对象的行为也会因为逻辑的改变而改变。
那么不同类的代码肯定是不一样的，所以行为也不一样。
c.对象与对象 对象和对象数据不同。
不同类的对象就不说了。同类型的对象呢？
d.区分是对象不同还是类不同 比如人这个类。
游戏的捏脸功能就是如此，修改一些不同的属性数据即可。比如有的人腿长，有的人腿短，只是数据不同。
但是如果需求要人能飞，能射出蛛丝，“一般&#34;来说我们就得新建一个类了。给它加上 飞行/喷射蛛丝 的行为。
所以，对象和对象的不同，只是数据上，比如腿的长短。而类就得是 行为/功能 上的不同。
类与类行为不同；对象与对象数据不同。 2.主要思想 分而治之
将一个大的需求分解为许多类，每个类处理一个独立的模块。
拆分好处：独立模块便于分工，每个模块便于复用，可扩展性强。
封装变化
变化的地方独立封装，避免影响其他模块。
高内聚
类中各个方法都在完成一项任务(单一职责的类)。
复杂的实现封装在内部，对外提供简单的调用。
低耦合
类与类的关联性依赖度要低(每个类独立)。
让一个模块的改变，尽少影响其他模块。
1).分而治之和封装变化 分而治之其实就是模块化。
封装变化：
比如我们可以攻击，但是攻击可以分为用手，用武器，等。那么我们就应该用一个专门的武器类来封装这些。
难点在于，什么时候该用类来封装。老师的说法是，变化。
就比如攻击，当攻击方式多样化的时候，就应该封装了。
2).高内聚和低耦合 也很简单。老师也列了一个例子。
[例如：硬件高度集成化，又要可插拔]
最高的内聚莫过于类中仅包含1个方法，将会导致高内聚高耦合。
最低的耦合莫过于类中包含所有方法，将会导致低耦合低内聚。
高内聚高耦合
说的是，如果类都是最简单的一个方法那种，是高内聚了，但是实现一个功能，往往不可能这么简单，那么就得调用多个类，导致高耦合。
低耦合低内聚
极端的一个类囊括所有功能。低耦合的确，但是各种功能都在一个类，导致了低内聚。
2.继承 复习一些基础知识
1).栈和堆 深入理解堆栈、堆在内存中的实现
什么是堆？什么是栈？他们之间有什么区别和联系？
推荐看这篇知乎回答。
管理方式：栈由编译器自动管理，无需人为控制。而堆释放工作由程序员控制，容易产生内存泄漏（memory leak）。
空间大小：在32位系统下，堆内存可以达到4G的空间（虚拟内存的大小，有面试官问过），从这个角度来看堆内存大小可以很大。但对于栈来说，一般都是有一定的空间大小的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/73e3f50ce5bc022302123ab2d2403eaa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-17T22:12:00+08:00" />
<meta property="article:modified_time" content="2022-05-17T22:12:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一.c#基础 [Unity_Learn_RPG_1]</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Cunity_C__0"></a>一.C#、unity C# 基础</h2> 
<h3><a id="1_1"></a>1.面向对象</h3> 
<p><img src="https://images2.imgbox.com/99/7a/cajmcJ3u_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_4"></a>1).面向过程和面向对象</h4> 
<h5><a id="a_5"></a>a.面向过程</h5> 
<p>就是把一个需求/问题，分成一步步的逻辑，很像数学里的解答。<br> 关心的是解决问题的步骤。</p> 
<h5><a id="b_8"></a>b.面向对象</h5> 
<p>把需求分为一个个对象。<br> 关心的是对象在做什么。以及对象之间的交互。</p> 
<h4><a id="2_12"></a>2).类和对象</h4> 
<h5><a id="a_13"></a>a.先有类还是现有对象</h5> 
<p>设计角度：现有对象，再有类。根据需求，我们从中分析，提取出一有相同行为的"类”。<br> 编码角度：肯定是先有类了，不然new 什么呢？</p> 
<h5><a id="b_17"></a>b.类与类</h5> 
<p>类是抽象的。是抽象的"类别"。类与类行为不同。</p> 
<p>什么是行为？我的理解其实就是代码，如果一个类的代码改变了，那么它的逻辑也改变，逻辑改变体现在对象的实际执行上，也就是对象的行为也会因为逻辑的改变而改变。</p> 
<p>那么不同类的代码肯定是不一样的，所以行为也不一样。</p> 
<h5><a id="c_24"></a>c.对象与对象</h5> 
<p>对象和对象数据不同。<br> 不同类的对象就不说了。同类型的对象呢？</p> 
<h5><a id="d_28"></a>d.区分是对象不同还是类不同</h5> 
<p>比如人这个类。</p> 
<p>游戏的捏脸功能就是如此，修改一些不同的属性数据即可。比如有的人腿长，有的人腿短，只是数据不同。</p> 
<p>但是如果需求要人能飞，能射出蛛丝，“一般"来说我们就得新建一个类了。给它加上 飞行/喷射蛛丝 的行为。</p> 
<p>所以，对象和对象的不同，只是数据上，比如腿的长短。而类就得是 行为/功能 上的不同。</p> 
<ul><li>类与类行为不同；</li><li>对象与对象数据不同。</li></ul> 
<h4><a id="2_40"></a>2.主要思想</h4> 
<ol><li> <p>分而治之<br> 将一个大的需求分解为许多类，每个类处理一个独立的模块。<br> 拆分好处：独立模块便于分工，每个模块便于复用，可扩展性强。</p> </li><li> <p>封装变化<br> 变化的地方独立封装，避免影响其他模块。</p> </li><li> <p>高内聚<br> 类中各个方法都在完成一项任务(单一职责的类)。<br> 复杂的实现封装在内部，对外提供简单的调用。</p> </li><li> <p>低耦合<br> 类与类的关联性依赖度要低(每个类独立)。<br> 让一个模块的改变，尽少影响其他模块。</p> </li></ol> 
<h5><a id="1_56"></a>1).分而治之和封装变化</h5> 
<p>分而治之其实就是模块化。</p> 
<p>封装变化：<br> 比如我们可以攻击，但是攻击可以分为用手，用武器，等。那么我们就应该用一个专门的武器类来封装这些。</p> 
<p>难点在于，什么时候该用类来封装。老师的说法是，变化。<br> 就比如攻击，当攻击方式多样化的时候，就应该封装了。</p> 
<h5><a id="2_65"></a>2).高内聚和低耦合</h5> 
<p>也很简单。老师也列了一个例子。</p> 
<p><em>[例如：硬件高度集成化，又要可插拔]<br> 最高的内聚莫过于类中仅包含1个方法，将会导致高内聚高耦合。<br> 最低的耦合莫过于类中包含所有方法，将会导致低耦合低内聚。</em></p> 
<ol><li> <p>高内聚高耦合<br> 说的是，如果类都是最简单的一个方法那种，是高内聚了，但是实现一个功能，往往不可能这么简单，那么就得调用多个类，导致高耦合。</p> </li><li> <p>低耦合低内聚<br> 极端的一个类囊括所有功能。低耦合的确，但是各种功能都在一个类，导致了低内聚。</p> </li></ol> 
<h3><a id="2_78"></a>2.继承</h3> 
<p>复习一些基础知识</p> 
<h4><a id="1_80"></a>1).栈和堆</h4> 
<p><a href="https://www.cnblogs.com/tianzhiliang/archive/2010/09/19/1830763.html" rel="nofollow">深入理解堆栈、堆在内存中的实现</a></p> 
<p><a href="https://www.zhihu.com/question/19729973" rel="nofollow">什么是堆？什么是栈？他们之间有什么区别和联系？</a></p> 
<p>推荐看这篇知乎回答。</p> 
<p><img src="https://images2.imgbox.com/5a/d2/ZPZSoejL_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p>管理方式：栈由编译器自动管理，无需人为控制。而堆释放工作由程序员控制，容易产生内存泄漏（memory leak）。</p> </li><li> <p>空间大小：在32位系统下，堆内存可以达到4G的空间（虚拟内存的大小，有面试官问过），从这个角度来看堆内存大小可以很大。但对于栈来说，一般都是有一定的空间大小的。</p> </li><li> <p>碎片问题：堆频繁new/delete会造成内存空间的不连续，造成大量的碎片，使程序效率降低（如何解决？如内存池、伙伴系统等）。对栈来说不会存在这个问题，因为栈是先进后出，不可能有一个内存块从栈中间弹出。在该块弹出之前，在它上面的（后进的栈内容）已经被弹出。</p> </li><li> <p>生长方向：堆生长（扩展）方向是向上的，也就是向着内存地址增加的方向；栈生长（扩展）方向是向下的，是向着内存地址减小的方向增长， 可以看第一张图。</p> </li><li> <p>分配方式：堆都是动态分配的，没有静态分配的堆。而栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，如局部变量分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。</p> </li><li> <p>效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持（有专门的寄存器存放栈的地址，压栈出栈都有专门的机器指令执行），这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的（可以了解侯捷老师的内存管理的视频，关于malloc/realloc/free函数等）。例如分配一块内存，堆会按照一定的算法，在堆内存中搜索可用的足够大小的空间，如果没有（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。总之，堆的效率比栈要低得多。</p> </li></ol> 
<p>以上来自链接的文章中</p> 
<h4><a id="2_104"></a>2).实际编写</h4> 
<p><img src="https://images2.imgbox.com/33/ad/f2rOVWPr_o.png" alt="在这里插入图片描述"></p> 
<p>这是老师列出来的图。左侧是栈，右侧是堆。</p> 
<ul><li>方法是每个对象共享的，不存储在堆里。New只是在堆里申请空间，存储属性之类的数据成员。<br> 所以说，对象和对象不同是数据不同。</li></ul> 
<h3><a id="3_112"></a>3.抽象类</h3> 
<ul><li>开闭原则：对扩展开发，对修改关闭</li><li>依赖倒置：依赖父级，不要依赖子级。父级的作用在隔离子级，隔离子级的变化。</li></ul> 
<h4><a id="1_116"></a>1).语法</h4> 
<ul><li>abstract</li><li>可以有方法和属性</li><li>不能创建对象（因为是抽象概念，抽象概念怎么会有实体呢？）</li></ul> 
<h4><a id="2_121"></a>2).语义</h4> 
<p>只表示做什么，有什么数据，不做具体处理。</p> 
<h4><a id="3_124"></a>3).适用性</h4> 
<ul><li>不了解具体代码的实现</li><li>不希望创建实体类</li></ul> 
<h4><a id="4_128"></a>4).抽象类的方法</h4> 
<ul><li>类中只声明方法，不实现</li><li>描述做什么，不描述怎么做；</li><li>子类必须实现；</li><li>子类重写必须使用override。</li></ul> 
<h4><a id="5virutal_134"></a>5).virutal</h4> 
<ul><li>子类选择实现</li><li>本类可以写逻辑代码</li></ul> 
<h3><a id="4_138"></a>4.类的关系</h3> 
<p><img src="https://images2.imgbox.com/23/70/DxwWde9k_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b4/0c/X7UjpW0X_o.png" alt="在这里插入图片描述"><br> 两张图，一个需求变化。</p> 
<p>原来是每个员工都需要计算薪资，所以基类是Employee。</p> 
<p>后来有需求，可以改变一个员工的职位。</p> 
<p>所以，Employee单独作为“员工”独立出来，而每个职位“Programer”，“Tester”，作为员工的职位，继承于基类Job。</p> 
<ul><li><strong>找到变化点</strong></li></ul> 
<h4><a id="1_151"></a>1.类的四大关系</h4> 
<ul><li> <p><strong>泛化</strong>：<br> 子类与父类的关系，概念的复用，耦合度最高。因为父类以上，只要改变，子类也全会变。<br> B类泛化A类，意味B类是A类的一种；<br> 做法：B类继承A类</p> </li><li> <p><strong>实现</strong>：<br> 抽象行为的具体实现，两者体现功能的关系，变化只影响行为；<br> A类实现B类，意味A类必须具体实现B类中所有抽象成员。<br> 做法：实现抽象类、接口中的抽象成员。</p> </li><li> <p><strong>关联(聚合/组合)</strong>：<br> 部分与整体的关系，功能的复用，变化影响一个类；<br> A与B关联，意味着B是A的一部分；<br> 做法：在A类中包含B类型成员。</p> </li><li> <p><strong>依赖</strong>：<br> 合作关系，一种相对松散的协作，变化影响一个方法；<br> A类依赖B类，意味A类的某些功能靠B类实现；<br> 做法：<strong>B类型作为A类中方法的参数，并不是A的成员。</strong></p> </li></ul> 
<p>如何判断两种类的耦合度，从上到下依次减少</p> 
<ul><li>继承：整个之后的家族都会增加（属性+方法）；</li><li>聚合：同上，但是只是家族里增加了一个属性；</li><li>依赖：只是一个方法中用到；</li></ul> 
<h4><a id="2_177"></a>2.总结：设计的八大原则（其四）</h4> 
<ul><li> <p><strong>开闭原则（目标、总的指导思想）</strong><br> Open Closed Principle<br> 对扩展开放，对修改关闭。<br> 增加新功能，不改变原有代码。</p> </li><li> <p><strong>类的单一职责（一个类的定义）</strong><br> Single Responsibility Principle<br> 一个类有且只有一个改变它的原因。<br> 适用于基础类，不适用基于基础类构建复杂的聚合类。</p> </li><li> <p><strong>依赖倒置（依赖抽象）</strong><br> Dependency Inversion Principle<br> 客户端代码(调用的类)尽量依赖(使用)抽象的组件。<br> <strong>抽象的是稳定的。实现是多变的。</strong><br> 比如出行，出现是抽象的，但是实际上可以开车，走路等等</p> </li><li> <p><strong>组合复用原则（复用的最佳实践）</strong><br> Composite Reuse Principle<br> <strong>如果仅仅为了代码复用优先选择组合复用，而非继承复用。</strong><br> 组合的<strong>耦合性</strong>相对继承低。耦合低了，自然以后修改，增加也更容易了。</p> </li><li> <p><strong>里氏替换（继承后的重写，指导继承的设计）</strong><br> Liskov Substitution Principle<br> <strong>父类出现的地方可以被子类替换，在替换后依然保持原功能。</strong><br> 子类要拥有父类的所有功能。<br> 子类在重写父类方法时，尽量选择扩展重写，防止改变了功能。</p> <pre><code>  // 调用 base.xxx 就是所谓的 “拓展“重写
  // 尽量，不是一定
  public void xxx(){
  	base.xxx();
  	....
  }
</code></pre> </li><li> <p><strong>接口隔离（功能拆分）</strong><br> Interface Segregation Principle<br> <strong>尽量定义小而精的接口interface，少定义大而全的接口。本质与单一职责相同。</strong><br> 小接口之间功能隔离，实现类需要多个功能时可以选择多实现.或接口之间做继承。<br> <img src="https://images2.imgbox.com/2a/71/lBNO3qX7_o.png" alt="在这里插入图片描述"><br> 例子：IPointerClickHandler</p> </li><li> <p>IPointerClickHandler UI点击的调用。</p> </li><li> <p>IPointerUpHandler UI点击抬起时的调用。</p> </li><li> <p>IPointerDownHandler UI点击按下时的调用。</p> </li></ul> 
<p>那为什么不用一个 IPointerHandler 来处理三个呢？就是这个原则了，尽量小而精，而非大而全。</p> 
<ul><li> <p><strong>面向接口编程而非面向实现（切换、并行开发）</strong><br> <strong>客户端通过一系列抽象操作实例，而无需关注具体类型。</strong><br> 便于灵活切换一系列功能。<br> 实现软件的并行开发。<br> <img src="https://images2.imgbox.com/9d/09/3wOp0Pbq_o.png" alt="在这里插入图片描述"><br> 排序的例子。</p> </li><li> <p><strong>迪米特法则（类与类交互的原则）</strong><br> Law of Demeter<br> 不要和陌生人说话。<br> <strong>类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。</strong> 因为这样可能降低耦合度。</p> </li></ul> 
<h3><a id="5_236"></a>5.多态</h3> 
<h4><a id="_237"></a>定义</h4> 
<ul><li>父类同一种动作或者行为(父类型的引用调用同一方法)，在不同的子类上有不同的实现。</li><li>继承将相关概念的共性进行抽象，并提供了一种复用的方式；</li><li>多态在共性的基础上，体现类型及行为的个性化，即一个行为有多个不同的实现。</li></ul> 
<h4><a id="_242"></a>实现手段</h4> 
<ol><li>虚方法： 父类型的引用 指向 子类的对象，调用虚方法，执行子类中的重写方法。</li><li>抽象方法：抽象类的引用 指向 实现类的对象，调用抽象方法，执行实现类中重写方法。</li><li>接口：接口的引用 指向 实现类的对象，调用接口方法，执行实现类中实现方法。</li></ol> 
<h4><a id="1_247"></a>1).方法重写</h4> 
<p>语法：在子类中使用<strong>override</strong>关键字修饰的方法。<br> 作用：父类的方法在子类中不适用（虚方法），或父类没有实现(抽象方法)。子类重写可以满足对该方法的不同需求。方法重写时必须在方法前加override关键字。</p> 
<h5><a id="a_251"></a>a.三种方法可以重写：</h5> 
<ul><li>abstract <strong>方法在子类必须重写，除非子类也是抽象类。</strong></li><li>virtual 方法在子类可以重写，父类方法的做法与子类不同。</li><li>override <strong>方法，已经重写过的方法，在子类还可以继续重写，除非被标识为sealed。（多重继承)</strong></li></ul> 
<h5><a id="b_256"></a>b.重写原理</h5> 
<ol><li>子类在方法表中修改对应的地址；</li><li>修改父级方法表地址。</li></ol> 
<p>不管通过父类还是子类型的引用，调用方法时，都执行对象真实类型中定义的方法。</p> 
<h5><a id="chttpsimgblogcsdnimgcnede4798d983d4203a1e0f31caef57859pngxossprocessimagewatermarktype_d3F5LXplbmhlaQshadow_50text_Q1NETiBAY3l4MTE0NAsize_20color_FFFFFFt_70g_sex_16_261"></a>c.重写原理看图理解<img src="https://images2.imgbox.com/e2/6f/Bld4M9E2_o.png" alt="在这里插入图片描述"></h5> 
<p>如图。每个类，在内存的堆中，都有一个方法表。</p> 
<ul><li> <p>重写的原理就是，实际运行时，把子级的方法表中的方法地址，覆盖掉父级方法地址，然后实际父类引用调用父类方法时，就会是子类的方法了。</p> </li><li> <p>因为这种覆盖是随着程序进行而会更改的，比如调用A子类，A子类先覆盖，然后调用。然后到B子类，就变成B子类覆盖，然后调用。</p> </li></ul> 
<p>这种，在运行时修改的，也叫动态绑定。</p> 
<h5><a id="d_270"></a>d.对于继承逻辑的一些问题</h5> 
<h6><a id="_271"></a>重写方法的时候是否要调用父的逻辑？</h6> 
<p>我一直以来认为，既然继承了父类，那么我也有相同的方法，并且此方法应该包含父类的逻辑，这才算继承把？</p> 
<p>目前老师的回答是。需要的时候就调用，不需要的时候就不调用。</p> 
<h6><a id="_276"></a>如果是多重继承，但是我只需要上层的某个父类的逻辑，那我该如何调用？</h6> 
<p>比如，我只想调用某个父类的父类的相同方法，这应该如何调用？</p> 
<h5><a id="f_279"></a>f.重写</h5> 
<pre><code>//  (virtual/absctrac -&gt; override)
// 重写。只是为了父类引用可以调用到子类的方法。

// 是否使用父类方法的逻辑，得用 
base.xxxx();
</code></pre> 
<h4><a id="2_286"></a>2).方法隐藏</h4> 
<p><img src="https://images2.imgbox.com/27/bf/9BM1oHBK_o.png" alt="在这里插入图片描述"></p> 
<p>定义：在子类中使用new关键字修饰的与父类同签名的方法。<br> 作用：父类的方法在子类中不适用，且通过子类型引用调用时，隐藏掉父类继承的旧方法，好像该方法不存在。</p> 
<h5><a id="_292"></a>隐藏原理</h5> 
<p><img src="https://images2.imgbox.com/d3/a3/CIQd4lTC_o.png" alt="在这里插入图片描述"></p> 
<p>子类在自己的方法表中<strong>增加一个新地址。</strong></p> 
<ul><li>通过子类引用调用时使用新纪录（自己的），执行子类中新方法；</li><li>父类引用调用时使用旧纪录，执行父类中方法。</li></ul> 
<p>比如</p> 
<pre><code>C { call(); }
A extend C{ call(); }
B extend C{ 
	virtual call(); 
}

toCall(C temp){
	temp.call();
}

toCall(B) --&gt; 用的是B类的Call，而不是C类的Call
toCall(A)  --&gt; 在toCall里，用的不是A类的call，而是C类的Call

想要使用A类的Call，要改成
toCall(C temp){
	(temp as A).call();
}
</code></pre> 
<p>所以说，如果是方法隐藏，那么“引用类型”是什么，那就只会调引用类型的方法，不会因为传入的是子类，就调用子类的方法。</p> 
<h5><a id="_321"></a>虚方法</h5> 
<p>定义：用vritual关键修饰的已实现方法。<br> 作用：可以在子类中重写的方法。</p> 
<h4><a id="_325"></a>动态绑定(晚期绑定)与静态绑定(早期绑定)</h4> 
<ul><li> <p>绑定：类型与关联的方法的调用关系，通俗讲就是一个类型能够调用哪些方法。（内存中有张表）</p> </li><li> <p><strong>静态绑定</strong>：是指调用关系是在运行之前确定的，即编译期间。</p> </li><li> <p><strong>动态绑定</strong>：是指调用关系是在运行期间确定的。</p> </li></ul> 
<p>动态绑定因为在运行期确定，占用运行时间，但是更灵活。</p> 
<ul><li><strong>方法重写是动态绑定。每次调用的时候，子类要改父类的地址。因为不确定是哪个子类，的在运行的时候才能确定。</strong></li><li><strong>方法隐藏是静态绑定。调用时，不改父类的地址，所以是明确的一对一关系，直接编译期间确定就行。</strong></li></ul> 
<h4><a id="_336"></a>最后</h4> 
<p>优先选择方法覆盖，因为是静态绑定，速度更快。</p> 
<h3><a id="6_339"></a>6.接口</h3> 
<h4><a id="1_340"></a>1).定义</h4> 
<ul><li> <p>接口定义一组对外的行为规范，要求它的实现类必须遵循。</p> </li><li> <p>接口只关注行为，不关注数据，且不关注行为的实现，实现由实现类完成。</p> </li><li> <p>接口自身表达“能够做”,不表达“如何做”。</p> </li><li> <p>接口是一组行为的抽象，它的方法没有方法体，也就是自己不写方法的逻辑。</p> <pre><code>//一组：接口中可以包含多个方法；
//对外：接口成员是要求子类实现，自己不要用。
//行为：接口中只能包含方法成员（属性、方法）
//规范：要求子类必须自行实现
</code></pre> </li></ul> 
<h4><a id="2_351"></a>2).抽象类与接口的选择策略</h4> 
<ul><li> <p>抽象类与子类之间关系：is a [是一种]。内部的属性等，子类都可以直接用。</p> </li><li> <p>接口与实现类之间关系：can do [能够做(功能)]。内部的东西不可以直接用，必须再次实现。</p> </li><li> <p>接口与接口之间可继承，且可以多继承。</p> </li><li> <p>类与类是单继承，类与接口是多实现，接口与接口是多继承。</p> </li></ul> 
<p>父类，只能有一个。而接口，可以很多个。<br> 当都可以用时，优先选择接口。</p> 
<h4><a id="3_361"></a>3).作用</h4> 
<ul><li> <p>规范不同类型的行为，达到了不同类型在行为上是一致的。<br> <strong>比如，伤害。</strong><br> 玩家和敌人，肯定都能受到伤害，那么它们可以继承同个父类。<br> 但是如果，树木，房子等也可以受到伤害，那就不能用同个父类了。</p> </li><li> <p>扩展一个已有类的行为。<br> 或者在设计的后期，一个类以及设计并且实现完毕，这时候需要增加一个功能，一般也会用接口。</p> </li></ul> 
<h4><a id="4_370"></a>4).语法</h4> 
<ul><li>使用interface关键定义。<strong>接口名建议用”I”开头，其后单词首字母大写。</strong></li><li>接口中不能包含<strong>字段</strong>，可以包含：<strong>方法，属性，索引器，事件。</strong></li><li>接口中的成员一定是<strong>public abstract</strong>的，但是不能写。</li><li>接口中的所有成员不能有实现，全部默认抽象的。</li><li>实现类实现接口用“：”与继承相同。</li><li>实现类实现可以实现多个接口，且每个接口中所有的成员必须都实现。</li><li><strong>接口中的成员在实现类中以public的方式实现（除显式实现）。</strong></li><li>接口的引用可以指向实现类的对象。</li><li>接口内的所有属性，方法等，它的访问级别跟 interface 是一致的<br> public interface IXXX 那就都是public的<br> internal interface IXXX 那就都是internal的<br> <img src="https://images2.imgbox.com/8c/a2/NDkxtGRw_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="5_384"></a>5).接口的显式实现</h4> 
<h5><a id="a_385"></a>a.作用：</h5> 
<ol><li>解决多接口实现时的二义性</li><li>解决接口中的成员对实现类不适用的问题</li></ol> 
<p>比如两个接口，都有同一个名称的方法。这时候如何实现，如何调用呢？</p> 
<h5><a id="b_390"></a>b.做法：</h5> 
<p><img src="https://images2.imgbox.com/6b/49/lLeT84Ko_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在实现的成员前加接口名，并且不能加任何访问修饰符，默认为private</li><li>显式实现成员只能通过接口类型的引用调用。<br> Void InterFace1.Fun()<br> { }</li></ul> 
<h5><a id="c_397"></a>c.使用场景</h5> 
<ol><li>两个接口同个方法名，这时候用，这两个方法都会变成私有。只有父类引用才能调用的到（父类肯定不是私有啊）；</li><li>这个方法，对于我这个类，并不需要实现且暴露给外部。也是变成了私有，外部调不到。</li></ol> 
<h4><a id="6Framework_401"></a>6).Framework常用接口</h4> 
<ul><li> <p>IComparable 可比较，使类型支持比大小的功能<br> <img src="https://images2.imgbox.com/7c/04/laBb1jeZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/72/b0/D5YwAn7D_o.png" alt="在这里插入图片描述"><br> 如图，使用Array.Sort 进行排序时，Grenade需要实现 IComparable 接口的 CompareTo 方法才可以，不然会报错。也就是说，Array的排序功能，是通过 IComparable 接口，这个功能实现的。</p> </li><li> <p>IComparer 比较器，提供比较的方法，常用于排序比较</p> </li><li> <p>IEnumerable 可枚举，使类型支持简单迭代(foreach)</p> </li><li> <p>IEnumerator 枚举器,支持MoveNext ,自己可以控制迭代的节奏</p> </li></ul> 
<h5><a id="a_IComparer_IComparable_411"></a>a.何时使用 IComparer，何时使用 IComparable</h5> 
<ul><li> <p><strong>IComparable</strong></p> <pre><code>  Array.Sort(array)
</code></pre> <p>IComparable 的逻辑，是Sort里直接调用传入的类的CompareTo，写在类里。所以，如果这个类大部分都用这种方法排序，那么就使用 IComparable。</p> </li><li> <p><strong>IComparer</strong></p> <pre><code>  Array.Sort(array, new XXXComparer);
</code></pre> <p>IComparer 是需要在使用Sort时，new一个传入的，所以一般不会写在array代表的类里，它更灵活，有点像策略模式。但这样就说明它这个类的排序方式多变。</p> </li></ul> 
<p>综上，这两个其实可以结合使用。常用的放类里，不常用/特殊的 放外面。</p> 
<h5><a id="bC_427"></a>b.C#表达抽象的语义，有以下三种方法。</h5> 
<ul><li>抽象类：一个概念的抽象（普通成员，抽象成员)<br> 这就不多说了，已经可以作为一种“类”来表达了。</li><li>接口：一组行为的抽象（多种抽象成员）<br> 一组行为，比如接口里的多个函数方法。接口常用于不能当作类，但是又具有部分共同功能的抽象。</li><li>委托：一类行为的抽象（同一种类多个方法）<br> 委托，其实也就是函数回调。函数能又多少抽象逻辑呢？所以说是一类行为，可以传多个模板类（也不可能无限传模板类参数吧）。</li></ul> 
<p>由上往下，耦合度越低，抽象程度越低，功能也越简单。</p> 
<h3><a id="7_437"></a>7.协程</h3> 
<h4><a id="1_438"></a>1.)迭代器</h4> 
<pre><code>foreach(var item in hand) {

}

//foreach 的原理，就是如下的代码
// 1.获取迭代器
IEnumerator iter = hand.GetEnumerator();
// 2.移动到下一个元素
while(iter.MoveNext() ) {
    // 3.获取元素
    Console.WriteLine(iter.Current);
}
</code></pre> 
<p>如上，foreach的原理如此。</p> 
<pre><code>public class Hand :IEnumerable{
    public IThrowable[] AllObject { get; set; }

    public IEnumerator GetEnumerator() {
        return new HandEnumerator() {
            Target = AllObject
        };
    }

    public void Thorwing(IThrowable temp) {
        temp.Fly();
    }
}

// Hand的迭代器
public class HandEnumerator : IEnumerator {
    public IThrowable[] Target { get; set; }
    private int index = -1;

    // 获取当前数据
    public object Current{
        get {
            return Target[index];
        }
    }

    public bool MoveNext() {
        index++;
        return index &lt; Target.Length;
    }

    public void Reset() {
        throw new NotImplementedException();
    }
}
</code></pre> 
<p>实现方式，就是类继承，IEnumerable，代表此类有这个功能。<br> 子类实现一个迭代器类，继承 IEnumerator ，代表它是一个迭代器类，并且从父类传入需要迭代的“队列”，由此实现的接口代码才是实际的逻辑。父类也只是返回一个自己的迭代器类。</p> 
<h4><a id="2___493"></a>2).迭代器 -&gt; 协程</h4> 
<p>我们重新实现一下 GetEnumerator 的逻辑</p> 
<pre><code>public class Hand :IEnumerable{
    /*
     * 传统代码
    public IEnumerator GetEnumerator() {
        return new HandEnumerator() {
            Target = AllObject
        };
    }
    */

    public IEnumerator GetEnumerator() {
        /*
            将 yield 以前的代码，分配到 MoveNext 方法中
            将 return 后的数据，分配到 Current 中
         */
        for(int i = 0; i &lt; AllObject.Length; i++) {
            yield return AllObject[i];// 返回数据， 退出方法
        }
    }
    
}
</code></pre> 
<p>还是看之前，迭代器的实现，这里改成用 yield。</p> 
<pre><code>//foreach 的原理，就是如下的代码
// 1.获取迭代器
IEnumerator iter = hand.GetEnumerator();
// 2.移动到下一个元素
while(iter.MoveNext() ) {
    // 3.获取元素
    Console.WriteLine(iter.Current);
}
</code></pre> 
<p>我们看实际foreach的逻辑代码，不同点在这段代码</p> 
<pre><code>IEnumerator iter = hand.GetEnumerator();
</code></pre> 
<p>它并不会实际执行，而是在</p> 
<pre><code>while(iter.MoveNext() )
</code></pre> 
<p>中才会跳到</p> 
<pre><code>    for(int i = 0; i &lt; AllObject.Length; i++) {
        yield return AllObject[i];// 返回数据， 退出方法
    }
</code></pre> 
<p>里，做第一次循环执行。</p> 
<p>所以说:</p> 
<pre><code>   public IEnumerator GetEnumerator() {
       /*
           将 yield 前的代码，分配到 MoveNext 方法中
           将 return 后的数据，分配到 Current 中
        */
       for(int i = 0; i &lt; AllObject.Length; i++) {
           yield return AllObject[i];// 返回数据， 退出方法
       }
   }
</code></pre> 
<h4><a id="3Unity_Coroutine_557"></a>3).Unity 协同程序(Coroutine)</h4> 
<h5><a id="a_558"></a>a.定义</h5> 
<p>具有多个返回点（yield），可以在特定时机分部执行的函数。</p> 
<h5><a id="b_561"></a>b.原理</h5> 
<pre><code>   private IEnumerator iter;
   private void OnGUI() {
       if(GUILayout.Button("启动")) {
           iter = Fun1();
       }

       if(GUILayout.Button("执行一次")) {
           iter.MoveNext();
       }

       if(GUILayout.Button("携程")) {
           //StartCoroutine(iter);
           //每帧调用一次 MoveNext 方法

           //相当于
           StartCoroutine( Fun1() );
       }
   }

   private IEnumerator Fun1() {
       for(int i = 0;i &lt; 5;i++) {
           print(i + "--" + Time.frameCount);
           //yield return null;
           yield return new WaitForSeconds(1);
       }
   }
}
</code></pre> 
<p>先附上所有代码</p> 
<h6><a id="_592"></a>携程本质上是执行迭代器</h6> 
<pre><code>   private IEnumerator Fun1() {
       for(int i = 0;i &lt; 5;i++) {
           print(i + "--" + Time.frameCount);
           //yield return null;
           yield return new WaitForSeconds(1);
       }
   }
</code></pre> 
<p>可以看到，fun1返回的是 IEnumerator 对象，也就是迭代器对象</p> 
<pre><code>StartCoroutine( Fun1() );
</code></pre> 
<p>同时，用迭代器的模板也是可以执行的</p> 
<pre><code>if(GUILayout.Button("启动")) {
    iter = Fun1();
}

if(GUILayout.Button("执行一次")) {
    iter.MoveNext();
}
</code></pre> 
<p>唯一的不同在于， StartCoroutine 不需要我们手动点击按钮执行MoveNext()，而是由C#自动控制的。</p> 
<h6><a id="_617"></a>控制携程迭代的间隔</h6> 
<pre><code>   private IEnumerator Fun1() {
       for(int i = 0;i &lt; 5;i++) {
           print(i + "--" + Time.frameCount);
           yield return null;
       }
   }
</code></pre> 
<p>携程默认是每个渲染帧（Time.frameCount）调用一次<br> <img src="https://images2.imgbox.com/0d/98/URbYMiCs_o.png" alt="在这里插入图片描述"></p> 
<pre><code>   private IEnumerator Fun1() {
       for(int i = 0;i &lt; 5;i++) {
           print(i + "--" + Time.frameCount);
           //yield return null;
           yield return new WaitForSeconds(1);
       }
   }
</code></pre> 
<p>在 return 后增加一个 new WaitForSeconds(1); 那么，每次的间隔都会变成 1s，如图。<br> <img src="https://images2.imgbox.com/df/46/FA1Fd0QP_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_638"></a>总结</h6> 
<ul><li><strong>GameObject</strong>的某个脚本有协程，如果脚本enbaled了，那么协程仍会进行</li><li><strong>GameObject</strong>的某个脚本有协程，如果<strong>GameObject</strong>enbaled了，那么协程会直接停止</li></ul> 
<p>Unity每帧处理<strong>GameObject</strong>中的协同程序（不是Component的协程），直到函数执行完毕。</p> 
<p><strong>流程</strong></p> 
<ul><li>当一个协程函数启动时，本质创建迭代器对象；</li><li>调用MoveNext方法，执行到 yield 暂时退出；</li><li>待满足条件后再次调用MoveNext方法，执行后续代码，直至遇到下一个yield为止。</li></ul> 
<p>如此循环至整个函数结束。</p> 
<h5><a id="c_651"></a>c.语法</h5> 
<p>通过MonoBehaviour中的StartCoroutine启动，StopCoroutine停止。<br> 协程函数返回值类型为IEnumerator，方法体中通过yield关键字定义返回点，通过return xx对象定义继续执行的条件。<br> 可以被yield return 的对象：</p> 
<ol><li>null 或者 数字 —&gt; 等待一个渲染帧</li><li>new WaitForSeconds(1) --&gt; 等待指定时间</li><li>new WaitForSecondsRealtime(1) --&gt; 等待指定时间(不受时间缩放影响)</li><li>new WaitForFixedUpdate() --&gt; 等待一个物理帧</li><li>new WaitForEndOfFrame() --&gt; 等待一帧结束</li><li>new WaitWhile( 委托 ) —&gt; (下回分解……)</li><li>Coroutine --&gt; 在另一个协程函数执行完毕后再执行。</li><li>WWW --&gt;</li></ol> 
<h5><a id="d_664"></a>d.作用</h5> 
<p>1.延时调用。<br> 2.分解操作。</p> 
<h5><a id="e1_668"></a>e.[例1]颜色变化</h5> 
<pre><code>  // 透明度变化
   public float fadeSpeed;
   public IEnumerator FadeOutTest() {
       Color currentColor;
       do {
           currentColor = mt.color;
           currentColor.a -= fadeSpeed * Time.deltaTime;
           mt.color = currentColor;
           yield return null;
       } while(currentColor.a &gt; 0);

       currentColor.a = 0;
       mt.color = currentColor;
   }
  // 颜色变化
   public Color EndColor;
   public AnimationCurve curve;
   public IEnumerator FadeOut() {
       Color oriColor = mt.color;
       
       //for(float x = 0; x &lt;= 1; x += Time.deltaTime) {
       
       // 2s，变慢
       for(float x = 0; x &lt;= 1; x += Time.deltaTime/2) {
               mt.color = Color.Lerp(oriColor, EndColor, curve.Evaluate(x) );
           yield return null;
       }

   }

   // 动画曲线：提供数值可视化的操作面板
   // Color.Lerp 将数值的变化，变为颜色的变化
</code></pre> 
<p>代码就不说了</p> 
<ul><li> <p><strong>AnimationCurve</strong><br> 动画曲线：提供数值可视化的操作面板。</p> <p>上面的颜色变化中，x的最大值是1，也就是1s，那么要如何延长时间呢？如下代码：</p> <pre><code>     //for(float x = 0; x &lt;= 1; x += Time.deltaTime) {
     
     // 2s，变慢
     for(float x = 0; x &lt;= 1; x += Time.deltaTime/2) {
</code></pre> </li><li> <p><strong>Color.Lerp</strong><br> Color.Lerp 将数值的变化，变为颜色的变化<br> <a href="https://www.cnblogs.com/unity3ds/p/5737152.html" rel="nofollow">nity3D中的线性插值Lerp()函数解析</a></p> </li></ul> 
<h5><a id="f3_717"></a>f[例3]复杂协程的执行顺序</h5> 
<pre><code>    //a1 b1 d1 f1 ...(2s)... c106 e106
    private Coroutine coroutine;
    private void Start() {
        print("a: " + Time.frameCount);
        coroutine = StartCoroutine( Fun1() ); 
        print("d: " + Time.frameCount);
        StartCoroutine(Fun2());
        print("f:" + Time.frameCount);
    }

    private IEnumerator Fun1() {
        print("b:" + Time.frameCount);
        yield return new WaitForSeconds(2);
        print("c:" + Time.frameCount);
        
    }

    // 这里return ciroutine 是指等待 coroutine 指向的那个协程一次运行结束（下个yield之前/协程运行完）
    private IEnumerator Fun2() {
        yield return coroutine;
        print("e:" + Time.frameCount);
    } 
</code></pre> 
<p>这里的顺序是 a1 b1 d1 f1 …(2s)… c106 e106</p> 
<p>a1，这里的1代表是哪一帧，所以可以得出结论，<strong>在yield之前的操作是不会放到下一帧的。</strong></p> 
<h5><a id="g2_745"></a>g.[例2]寻路</h5> 
<pre><code>public Transform[] wayPoints;
private float moveSpeed;

public IEnumerator PathFinding() {
    for(int i = 0; i &lt; wayPoints.Length; i++) {
        //移动到目标点
        yield return StartCoroutine( MoveToTarget(wayPoints[i].position) );
    }
}

private IEnumerator MoveToTarget(Vector3 position) {
    transform.LookAt(position);
    while(Vector3.Distance(transform.position, position) &gt; 0.1f) {
        transform.position = Vector3.MoveTowards(transform.position, position, moveSpeed * Time.deltaTime);
        yield return new WaitForFixedUpdate();
    }
}


private void OnGUI() {
    if(GUILayout.Button("Go")) {
        StartCoroutine( PathFinding() );
    }
}
</code></pre> 
<p>主要是讲解分解操作，利用了协程</p> 
<pre><code>yield return new xxxcoroutine;
</code></pre> 
<p>等待xxx协程执行完毕再继续，的特性。来分解寻路到每个点的步骤。</p> 
<h3><a id="8_777"></a>8.抽象工厂</h3> 
<h6><a id="_778"></a>可访问性不一致</h6> 
<p>属性有public，private，protected等访问权限关键字。类也有</p> 
<ul><li>属性默认是private</li><li>而类，枚举、接口等默认是internal</li></ul> 
<h4><a id="_784"></a>如何设计</h4> 
<p>老师的说法是。这种设计模式，难度有些高，要在项目初期，由经验丰富的程序员来设计比较好。</p> 
<p>因为这种模式的拓展并不是很好。</p> 
<h3><a id="9_789"></a>9.反射</h3> 
<p>基本用在框架级的代码</p> 
<h4><a id="1_791"></a>1).基础定义</h4> 
<h5><a id="a_792"></a>a.定义</h5> 
<p>动态获取类型信息,动态创建对象,动态访问成员的过程。</p> 
<h5><a id="b_794"></a>b.作用</h5> 
<p>在编译时无法了解类型，在运行时获取类型信息，创建对象，访问成员。</p> 
<h5><a id="c_796"></a>c.流程</h5> 
<ol><li>得到数据类型</li><li>动态创建对象</li><li>查看类型信息（了解本身信息,成员信息）</li></ol> 
<p>具体实现流程，请看 4.</p> 
<h4><a id="2_803"></a>2).常用类</h4> 
<h5><a id="aType_804"></a>a.取得数据类型Type</h5> 
<h6><a id="_805"></a>方式：</h6> 
<ol><li><strong>Type.GetType(“类型全名”)</strong>：适合于类型的名称已知。</li><li><strong>obj.GetType()</strong>：适合于类型名未知， 类型未知，存在已有对象。</li><li><strong>typeof(类型)</strong>：适合于已知类型。</li><li><strong>Assembly.Load(“XXX”).GetType(“名字”)</strong>：适合于类型在另一个程序集中。 <strong>Untiy中目前基本不使用。</strong></li></ol> 
<h5><a id="bTypeGet_Is_811"></a>b.Type类常用Get系列方法 Is系列属性。</h5> 
<ol><li>MethodInfo(方法) <br> 重要方法: Invoke</li><li>PropertyInfo(属性)<br> 重要方法：SetValue GetValue</li><li>FieldInfo(字段)<br> 重要方法：SetValue GetValue</li><li>ConstructInfo(构造方法)<br> 重要方法：Invoke</li></ol> 
<h4><a id="3_821"></a>3).动态创建对象</h4> 
<pre><code> Activator.CreateInstance(string 程序集名称,string 类型全名)
 Activator.CreateInstance(Type type);
 
Assembly assembly = Assembly.Load(程序集);
assembly.CreateInstance(Type);

//找到有参构造方法，动态调用构造方法
type.GetConstructor(typeof(string)).Invoke() 
</code></pre> 
<h4><a id="4_831"></a>4).反射的具体行为</h4> 
<pre><code> // 编译时
 User user1 = new User();
 user1.ID = 1001;
 user1.LoginID = "zs";
 user1.Print();

 // 动态 ---&gt; 运行时

 // 获取 Type
 // -- 根据字符串获取类型
 Type type = Type.GetType("Day5.User");//命名空间.类名
 // 目的：这样我们完全可以把 需要使用的类，放在表里，让使用的人来选择
 //Type type = Type.GetType( Console.ReadLine() );

 // -- 根据对象获取类型
 //Type type = user1.GetType();

 // -- 根据数据类型
 // Type type = typeof(User);

 // 创建对象
 object instance = Activator.CreateInstance(type);

 // 访问成员
 PropertyInfo IDProperty = type.GetProperty("ID");

 // 当你确定使用的这系列类，一定由这个 属性 的 类型 时
 IDProperty.SetValue(instance, 1001);
 // 当你不确定使用的这系列类，的某个 属性 的 类型 时
 object idValue = Convert.ChangeType("1001", IDProperty.PropertyType);
 IDProperty.SetValue(instance, idValue);

 PropertyInfo LoginIDProperty = type.GetProperty("LoginID");
 LoginIDProperty.SetValue(instance, "zs");

 // 获取方法
 MethodInfo printMethod = type.GetMethod("Print");
 // 调用方法
 printMethod.Invoke(instance, null);
</code></pre> 
<p>这里上面的 User 代码，和 下面的一长串代码，最后得到的是一样的 User。<br> 不同的是，上面的User是写代码的时候，就会知道的类型，而下面的 “反射” 写法，则是运行时才会知道具体是什么类。</p> 
<h5><a id="a_875"></a>a.按需使用类</h5> 
<pre><code> // -- 根据字符串获取类型
 Type type = Type.GetType("Day5.User");//命名空间.类名
 // 目的：这样我们完全可以把 需要使用的类，放在表里，让使用的人来选择
 //Type type = Type.GetType( Console.ReadLine() );
</code></pre> 
<p>把上面和下面代码对比一下，就知道它的用法了。</p> 
<p>比如，游戏中的buff。这时候，可以在表里填写这一类型的类名和参数，这样就可以灵活变化和测试，到底应该使用那些buff。</p> 
<h5><a id="b_885"></a>b.反射如何使用函数（方法）</h5> 
<pre><code>	 // 获取方法
	 MethodInfo printMethod = type.GetMethod("Print");
	 // 调用方法。null代表无参数。object[] 是参数按要求
	 printMethod.Invoke(instance, null);
</code></pre> 
<h5><a id="c_891"></a>c.灵活使用类的属性类型</h5> 
<pre><code> // 访问成员
 PropertyInfo IDProperty = type.GetProperty("ID");

 // 当你确定使用的这系列类，一定由这个 属性 的 类型 时
 IDProperty.SetValue(instance, 1001);
 // 当你不确定使用的这系列类，的某个 属性 的 类型 时
 object idValue = Convert.ChangeType("1001", IDProperty.PropertyType);
 IDProperty.SetValue(instance, idValue);
</code></pre> 
<p>我们可以不知道属性的类型，如何做请看代码。</p> 
<p>这里有个，不灵活的地方，就是属性名称。我们可以不知道属性的类型，但是名称是一定要知道的。</p> 
<h4><a id="5Json_905"></a>5).[例子]Json转换器</h4> 
<pre><code> public static string Object2Json(object obj) {
     // 获取所有属性（名称/值）
     // 根据规则拼接字符串
     // 提示：在MSDN中 搜索 "StringBuilder"类

     Type type = obj.GetType();
     PropertyInfo[] allProperty = type.GetProperties();
     StringBuilder builder = new StringBuilder();

     builder.Append("{");
     foreach(var item in allProperty) {
         builder.AppendFormat("\"{0}\":\"{1}\",", item.Name, item.GetValue(obj) );
     }
     builder.Remove(builder.Length - 1, 1);
     builder.Append("}");

     return builder.ToString();
 }


 public static T Json2Object&lt;T&gt;(string json) where T:new(){
     // 创建对象
     // 字符串解析（提取 属性名、名称值）
     // 根据属性名 设置属性
     // 提示：在 MSDN 中搜索"String"类

     //Type type = typeof(T);
     //object instance = Activator.CreateInstance(type);

     T instance = new T();
     Type type = instance.GetType();

     json = json.Replace("\"", "").Replace("{", "").Replace("}", "");
     //json.Replace("\"", string.Empty);
     string[] keyValue = json.Split(':','c');
     for(int i = 0;i &lt; keyValue.Length - 1; i++) {
         PropertyInfo property = type.GetProperty(keyValue[i]);
         property.SetValue(instance, Convert.ChangeType(keyValue[i + 1], property.PropertyType) );
     }

     return instance;
 }
</code></pre> 
<p>反射目前都是通过 <strong>类型</strong> 去找属性的，而不是通过 <strong>对象</strong>。</p> 
<h5><a id="aObject2Json_950"></a>a.Object2Json</h5> 
<pre><code>   builder.Append("{");
    foreach(var item in allProperty) {
        builder.AppendFormat("\"{0}\":\"{1}\",", item.Name, item.GetValue(obj) );
    }
    builder.Remove(builder.Length - 1, 1);
    builder.Append("}");
</code></pre> 
<p>主要就是这段。没啥好说的。</p> 
<h6><a id="Q_960"></a>Q:如果是属性是某个类，该如何呢？</h6> 
<h6><a id="A%09Object2Json_json_string__961"></a>A:自己的想法是，把那个属性也传入 Object2Json()，插入返回的 json string 即可。</h6> 
<h5><a id="bJson2Object_963"></a>b.Json2Object</h5> 
<p>主要看这里</p> 
<pre><code>   // 使用 replace 把所有 “ {  } 都替换为 空字符串。
   // 可以得到 只剩 “key:value,key:value,key:value” 这样的字符串
   json = json.Replace("\"", "").Replace("{", "").Replace("}", "");
   //json.Replace("\"", string.Empty);
   // 按 ：和 ，把 key 和 value 都单独出来，农场队列。
   // 可以得到 。{key，value，key，value, ...} 这样的队列
   string[] keyValue = json.Split(':','c');
</code></pre> 
<h4><a id="68_974"></a>6).反射与抽象工厂(8.中的例子)的互动</h4> 
<pre><code> public static DaoFactory Instance {
     //如果增加新的存储方式，违反开闭原则
     //选择子类
     get {
         if(GameMain.Type == "Client") {
             return new ClientDaoFactory();
         } else {
             return new ServerDaoFactory();
         }

         //
         if(null == instance) {
             // 动态（利用字符串）创建对象
             // 定义规则：GameMain.Type + Factory
             Type type = Type.GetType(GameMain.Type + "Factory");
             //return Activator.CreateInstance(type) as DaoFactory; 
             instance = Activator.CreateInstance(type) as DaoFactory;
         }

         // www.......com/user/login? loginID&amp;zs

         // UserHandle

         return instance;
     }
 }
</code></pre> 
<p>这里用反射，重写了之前的抽象工厂方法。</p> 
<p>老师的意思是说，这里在开发中，属于并行开发，我们不知道其他程序会写出哪些工厂，所以用反射来灵活的配置。</p> 
<p>因为反射很耗时间，所以还用了单例的方法，并且列出了规则。</p> 
<h4><a id="7_1008"></a>7).总结</h4> 
<ul><li>反射的动态，就是用字符串（老师的说法）</li><li>无法确定用什么类，无法在代码中 new 出来的，就用发射</li></ul> 
<h3><a id="10_1012"></a>10.角色控制</h3> 
<h4><a id="1_1013"></a>1).需求分析</h4> 
<h5><a id="a_1014"></a>a.需求分析</h5> 
<p><img src="https://images2.imgbox.com/31/27/Xx4Cl7eF_o.png" alt="在这里插入图片描述"></p> 
<ol><li>首先分析需求，老师已经帮我们分析好了。如图。</li><li>1-4个红点即是我们要制作的类。</li></ol> 
<h5><a id="b_1019"></a>b.代码模板修改以及增加</h5> 
<p>如图，在编辑器的如图路径下，保存着Unity所有的模板。<br> <img src="https://images2.imgbox.com/fe/22/xQosWb9O_o.png" alt="在这里插入图片描述"><br> 这里的文件名称什么意思呢？</p> 
<p><em>81-C# Script-NewBehaviourScripts.cs</em></p> 
<ul><li><strong>81</strong> 这个数字，应该指的是排序/分类。</li><li><strong>c# Scrip</strong> 指的是我们在Unity右键后，显示的创建选项名称</li><li><strong>NewBehaviourScripts</strong> 指的是新建出来的东西默认名称。</li></ul> 
<p>如下图。</p> 
<p><img src="https://images2.imgbox.com/23/f3/4cLwhJM8_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3a/38/SxhDhRrU_o.png" alt="在这里插入图片描述"><br> 比如我们常用到的mono模板，可以看到和编辑器里看到的是不一样的。#SCRIPTNAME#是我们的类名称，要等创建的时候才会赋值过去。</p> 
<h4><a id="2_1037"></a>2).制作</h4> 
<h3><a id="11Unity_1038"></a>11.Unity的单例模板类</h3> 
<pre><code>public class MonoSingleton&lt;T&gt; : MonoBehaviour where T:MonoSingleton&lt;T&gt;{
       // T 表示子类类型
       private static T instance;
       public static T Instance {
           get {
               if(instance == null) {
                   instance = FindObjectOfType&lt;T&gt;();
                   if(instance == null) {
                       //创建脚本对象
                       instance = new GameObject("Singleton of " + typeof(T)).AddComponent&lt;T&gt;();
                   } else {
                       instance.init();
                   }
               }
               return instance;
           }
       }

       protected void Awake() {
           if(instance == null) {
               instance = this as T;
               init();
           }
       }

       public void init() {

       }

       /*
        * 备注：
        * 1.适用性：场景中存在唯一的对象，即可让该对象继承当前类
        * 2.如何适用：
        *  -- 继承时必须传递子类类型
        *  -- 在任意脚本生命周期中，通过子类类型访问Instance属性
        */
</code></pre> 
<p>老师给了一个，Unity的单例基类，继承于它的，都可以使用单例模式。</p> 
<p>一般我是把单例在开始的场景中直接挂上，然后dontdestory，就可以一直存在了。老师这种，如果没有挂上，则会动态在场景中创建对象。</p> 
<h4><a id="a_1080"></a>a.泛型类</h4> 
<pre><code>public class MonoSingleton&lt; T &gt;
</code></pre> 
<p>这里的T和函数里的T都表示一个未知类，可以让传入，让整个系列的类，使用自己传入的类型来生成属性，以及使用。</p> 
<h4><a id="b_1085"></a>b.约束</h4> 
<pre><code>public class MonoSingleton&lt;T&gt; : MonoBehaviour where T:MonoSingleton&lt;T&gt;
</code></pre> 
<p>where 后面就代表约束，具体语法我也不是很清楚，看msdn去。</p> 
<pre><code>where T:MonoSingleton&lt;T&gt;
</code></pre> 
<p>这段表示的是，T是继承于MonoSingleton</p> 
<p><strong>约束告知编译器类型参数必须具备的功能。 在没有任何约束的情况下，类型参数可以是任何类型。</strong></p> 
<h4><a id="cUnity_1096"></a>c.Unity中单例的获取</h4> 
<pre><code>   public static T Instance {
       get {
           if(instance == null) {
               instance = FindObjectOfType&lt;T&gt;();
               if(instance == null) {
                   //创建脚本对象
                   instance = new GameObject("Singleton of " + typeof(T)).AddComponent&lt;T&gt;();
               } else {
                   instance.init();
               }
           }
           return instance;
       }
   }
</code></pre> 
<p>首先，肯定是判重拉，如果没有instance，得先在世界中查找</p> 
<pre><code>FindObjectOfType&lt;T&gt;();
</code></pre> 
<p>如果还是没找到，那我们就要创建 UnityObject 然后 AddComponent&lt; T &gt;</p> 
<pre><code>   //创建脚本对象
   instance = new GameObject("Singleton of " + typeof(T)).AddComponent&lt;T&gt;();
</code></pre> 
<h4><a id="dAwakeInit_1121"></a>d.不用Awake，改用Init</h4> 
<pre><code> protected void Awake() {
     if(instance == null) {
         instance = this as T;
         init();
     }
 }

 public void init() {

 }
</code></pre> 
<p>这是老师的做法：</p> 
<p>一般来说，只要生成一个 component 后，一定会执行 awake。而我们为保证在没有第一次调用 Instance 而走到Awake，就在 Awake 里也加了预防代码。</p> 
<p>一般都用 Awake做初始化，现在改用了 Init 来做初始化。并且使用 protected 来限制它的访问级别。</p> 
<p>其实暂时还不太理解init的这种写法，等以后实际使用时再慢慢消化吧。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5e79db9d80905878af98f00edb31bc12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【1&#43;X】正交实验法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/287871ea41a054661e504f9778bd73e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于Element Plus图标组件局部引用问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>