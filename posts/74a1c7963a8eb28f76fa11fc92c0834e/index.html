<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WebServer 解析HTTP 响应报文 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WebServer 解析HTTP 响应报文" />
<meta property="og:description" content="一、基础API部分，介绍stat、mmap、iovec、writev、va_list 1.1 stat​ 作用：获取文件信息
#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; // 获取文件属性，存储在statbuf中 int stat(const char *pathname, struct stat *statbuf); struct stat { mode_t st_mode; /* 文件类型和权限 */ off_t st_size; /* 文件大小，字节数 */ }; 返回值：成功返回0，失败返回-1；参数：文件路径（名），struct stat 类型的结构体 struct stat 结构体详解：
struct stat { dev_t st_dev; /* ID of device containing file */文件使用的设备号 ino_t st_ino; /* inode number */ 索引节点号 mode_t st_mode; /* protection */ 文件对应的模式，文件，目录等 nlink_t st_nlink; /* number of hard links */ 文件的硬连接数 uid_t st_uid; /* user ID of owner */ 所有者用户识别号 gid_t st_gid; /* group ID of owner */ 组识别号 dev_t st_rdev; /* device ID (if special file) */ 设备文件的设备号 off_t st_size; /* total size, in bytes */ 以字节为单位的文件容量 blksize_t st_blksize; /* blocksize for file system I/O */ 包含该文件的磁盘块的大小 blkcnt_t st_blocks; /* number of 512B blocks allocated */ 该文件所占的磁盘块 time_t st_atime; /* time of last access */ 最后一次访问该文件的时间 time_t st_mtime; /* time of last modification */ /最后一次修改该文件的时间 time_t st_ctime; /* time of last status change */ 最后一次改变该文件状态的时间 }; stat结构体中的st_mode 则定义了下列数种情况：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/74a1c7963a8eb28f76fa11fc92c0834e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-09T15:20:00+08:00" />
<meta property="article:modified_time" content="2023-09-09T15:20:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WebServer 解析HTTP 响应报文</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、基础API部分，介绍stat、mmap、iovec、writev、va_list</h4> 
<p><strong>1.1 stat​ </strong></p> 
<p><strong>作用</strong>：获取文件信息</p> 
<pre><code class="language-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

// 获取文件属性，存储在statbuf中
int stat(const char *pathname, struct stat *statbuf);

struct stat {
    mode_t  st_mode;         /* 文件类型和权限 */
    off_t   st_size;         /* 文件大小，字节数 */  
};</code></pre> 
<ul><li>返回值：成功返回0，失败返回-1；</li><li>参数：文件路径（名），<a href="https://so.csdn.net/so/search?q=struct&amp;spm=1001.2101.3001.7020" title="struct">struct</a> stat 类型的结构体 </li></ul> 
<p><strong>struct stat 结构体详解：</strong></p> 
<pre><code class="language-cpp">struct stat
{
    dev_t     st_dev;     /* ID of device containing file */文件使用的设备号
    ino_t     st_ino;     /* inode number */    索引节点号 
    mode_t    st_mode;    /* protection */  文件对应的模式，文件，目录等
    nlink_t   st_nlink;   /* number of hard links */    文件的硬连接数  
    uid_t     st_uid;     /* user ID of owner */    所有者用户识别号
    gid_t     st_gid;     /* group ID of owner */   组识别号  
    dev_t     st_rdev;    /* device ID (if special file) */ 设备文件的设备号
    off_t     st_size;    /* total size, in bytes */ 以字节为单位的文件容量   
    blksize_t st_blksize; /* blocksize for file system I/O */ 包含该文件的磁盘块的大小   
    blkcnt_t  st_blocks;  /* number of 512B blocks allocated */ 该文件所占的磁盘块  
    time_t    st_atime;   /* time of last access */ 最后一次访问该文件的时间   
    time_t    st_mtime;   /* time of last modification */ /最后一次修改该文件的时间   
    time_t    st_ctime;   /* time of last status change */ 最后一次改变该文件状态的时间   
};</code></pre> 
<p><strong>stat结构体中的st_mode 则定义了下列数种情况：</strong></p> 
<pre><code class="language-cpp">    S_IFMT   0170000    文件类型的位遮罩
    S_IFSOCK 0140000    套接字
    S_IFLNK 0120000     符号连接
    S_IFREG 0100000     一般文件
    S_IFBLK 0060000     区块装置
    S_IFDIR 0040000     目录
    S_IFCHR 0020000     字符装置
    S_IFIFO 0010000     先进先出
​
    S_ISUID 04000     文件的(set user-id on execution)位
    S_ISGID 02000     文件的(set group-id on execution)位
    S_ISVTX 01000     文件的sticky位
​
    S_IRUSR(S_IREAD) 00400     文件所有者具可读取权限
    S_IWUSR(S_IWRITE)00200     文件所有者具可写入权限
    S_IXUSR(S_IEXEC) 00100     文件所有者具可执行权限
​
    S_IRGRP 00040             用户组具可读取权限
    S_IWGRP 00020             用户组具可写入权限
    S_IXGRP 00010             用户组具可执行权限
​
    S_IROTH 00004             其他用户具可读取权限
    S_IWOTH 00002             其他用户具可写入权限
    S_IXOTH 00001             其他用户具可执行权限
​
    上述的文件类型在POSIX中定义了检查这些类型的宏定义：
    S_ISLNK (st_mode)    判断是否为符号连接
    S_ISREG (st_mode)    是否为一般文件
    S_ISDIR (st_mode)    是否为目录
    S_ISCHR (st_mode)    是否为字符装置文件
    S_ISBLK (s3e)        是否为先进先出
    S_ISSOCK (st_mode)   是否为socket
    若一目录具有sticky位(S_ISVTX)，则表示在此目录下的文件只能被该文件所有者、此目录所有者或root来删除或改名，在linux中，最典型的就是这个/tmp目录啦。
​</code></pre> 
<h4>1.2 mmap</h4> 
<p>用于将一个文件或其他对象映射到内存，提高文件的访问速度</p> 
<pre><code class="language-cpp">void* mmap(void* start,size_t length,int port,int flags,int fd,off_t offset);
int munmap(void* start,size_t length);</code></pre> 
<ul><li>start : 映射区的开始地址，设置为0时表示由系统决定映射区的起始地址</li><li>length : 映射区的长度</li><li>prot : 期望的内存保护标志，不能与文件的打开模式冲突 
  <ul><li><strong><span style="background-color:#f9eda6;">PROT_READ</span></strong> 表示页内容可以读取</li></ul></li><li>flags : 指定映射对象的类型，映射选项和映射页是否可以共享 
  <ul><li><strong><span style="background-color:#ffd7b9;">MAP_PRIVATE</span></strong> 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</li></ul></li><li>fd : 有效的文件描述符，一般是由open()函数返回</li><li>off_toffset : 被映射对象内容的起点</li></ul> 
<p><strong>我的往期文章：  </strong></p> 
<p><a class="has-card" href="https://heheda.blog.csdn.net/article/details/132119077" rel="nofollow" title='了解Linux 的 mmap --- 笔记_呵呵哒(￣▽￣)"的博客-CSDN博客'><span class="link-card-box"><span class="link-title">了解Linux 的 mmap --- 笔记_呵呵哒(￣▽￣)"的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/7c/09/HJv15zs6_o.png" alt="icon-default.png?t=N7T8">https://heheda.blog.csdn.net/article/details/132119077</span></span></a></p> 
<h4>1.3 iovec</h4> 
<p>定义了一个向量元素，一般把这个结构用作一个多元素的数组</p> 
<pre><code class="language-cpp">struct iovec {
    void    *iov_base;    /* starting address of buffer */
    size_t  iov_len;      /* size of buffer */
};</code></pre> 
<ul><li><strong><span style="background-color:#d7d8d9;">iov_base </span></strong>指向数据的地址</li><li><strong><span style="background-color:#d7d8d9;">iov_len </span></strong>表示数据的长度</li><li><strong><span style="background-color:#d7d8d9;">iovec</span></strong>是一个结构体，里面有两个元素，指针成员<strong><span style="background-color:#d7d8d9;">iov_base</span></strong>指向一个缓冲区，这个缓冲区是存放的是<strong><span style="background-color:#d7d8d9;">writev</span></strong>将要发送的数据</li><li>成员<strong><span style="background-color:#d7d8d9;">iov_len</span></strong>表示实际写入的长度</li></ul> 
<h4>1.4 writev</h4> 
<p><strong><span style="background-color:#fefcd8;">writev函数</span></strong>用于在<strong>一次函数调用中<span style="color:#ff9900;">写多个非连续缓冲区</span></strong>，有时也将这该函数称为<span style="color:#fe2c24;"><strong>聚集写</strong></span></p> 
<pre><code class="language-cpp">#include &lt;sys/uio.h&gt;
ssize_t writev(int filedes,const struct iovec* iov,int iovcnt);</code></pre> 
<ul><li><strong><span style="background-color:#d7d8d9;">filedes </span></strong>表示文件描述符</li><li><strong><span style="background-color:#d7d8d9;">iov </span></strong>为前述io向量机制结构体 <strong><span style="background-color:#d7d8d9;">iovec</span></strong></li><li><strong><span style="background-color:#d7d8d9;">iovcnt </span></strong>为结构体的个数</li></ul> 
<p><strong><span style="background-color:#fefcd8;"> 若成功则返回已写的字节数，若出错则返回 -1</span></strong></p> 
<ul><li><strong><span style="background-color:#d7d8d9;">writev </span></strong>以顺序<strong><span style="background-color:#fefcd8;"> iov[0],iov[1] 至 iov[iovcnt - 1] </span></strong>从缓冲区中聚集输出数据</li><li><strong><span style="background-color:#d7d8d9;">writev </span></strong>返回输出的字节总数。通常，它应等于所有缓冲区长度之和</li></ul> 
<p>特别注意：循环调用<strong><span style="background-color:#d7d8d9;">writev</span></strong>时，需要重新处理<strong><span style="background-color:#d7d8d9;">iovec</span></strong>中的指针和长度，该函数不会对这两个成员做任何处理</p> 
<p><strong><span style="background-color:#fefcd8;">writev()函数</span></strong>是<strong>Linux系统</strong>中的一个<span style="color:#fe2c24;"><strong>系统调用</strong></span>，其作用是将<span style="color:#1c7331;"><strong><span style="background-color:#eaf4fc;">多个缓冲区的数据一起写入到文件描述符中（各个缓冲区的数据可以是不连续的）</span></strong></span>。</p> 
<h4>1.5 va_list</h4> 
<ul><li><strong>va_list 是C语言中用于解决变参问题的一组宏，它定义于标准库 stdarg.h 中</strong></li><li><strong>通过命令 $man va_arg 也可以从手册中查询到 va_list 的用法</strong></li></ul> 
<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

void va_start(va_list ap, last);
type va_arg(va_list ap, type);
void va_end(va_list ap);
void va_copy(va_list dest, va_list src);
</code></pre> 
<p><img alt="" height="221" src="https://images2.imgbox.com/bf/47/OjX6f7iV_o.png" width="918"></p> 
<p><strong>对可变参数列表的处理过程：</strong></p> 
<ul><li>用 <span style="color:#956fe7;"><strong>va_list </strong></span>定义一个可变参数列表</li><li>用 <span style="color:#956fe7;"><strong>va_start </strong></span>获取函数可变参数列表</li><li>用 <span style="color:#956fe7;"><strong>va_arg </strong></span>循环处理可变参数列表中的各个可变参数</li><li>用 <span style="color:#956fe7;"><strong>va_end </strong></span>结束对可变参数列表的处理 </li></ul> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

static void show_numbers(int num,...) {
    va_list va;
    /* 初始化va,让va指向num后面的参数*/
    va_start(va,num);
    while (num--) {
        /* 通过while循环依次获取遍历后面的参数 */
        printf("%d\n",va_arg(va,int));
    }
    va_end(va);
}

int main(void) {
    show_numbers(3,110,111,112);
    return 0;
}</code></pre> 
<pre><code class="language-cpp">heheda@heheda:~/Linux/webserver$ gcc va_list.cpp
heheda@heheda:~/Linux/webserver$ ./a.out
110
111
112</code></pre> 
<h6>1.5.1 va_start</h6> 
<pre><code class="language-cpp">void va_start(va_list ap, last_arg);</code></pre> 
<ul><li><strong>ap</strong>: 这是一个 <strong><span style="background-color:#fefcd8;">va_list</span></strong><span style="background-color:#fefcd8;"> </span>类型的对象，它用来存储通过 <strong><span style="background-color:#fefcd8;">va_arg</span></strong><span style="background-color:#fefcd8;"> </span>获取额外参数时所必需的信息</li><li>这个函数的作用是初始化 <code>ap</code> 变量，它与 <strong><span style="background-color:#fefcd8;">va_arg</span></strong><span style="background-color:#fefcd8;"> </span>和 <strong><span style="background-color:#fefcd8;">va_end</span></strong><span style="background-color:#fefcd8;"> </span>函数一起使用</li><li><strong><span style="background-color:#fefcd8;">last_arg</span></strong><span style="background-color:#fefcd8;"> </span>是最后一个传递给函数的已知的固定参数，<strong>即省略号之前的参数</strong></li></ul> 
<pre><code class="language-cpp">#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt; 

// 采用可变参数，第一个参数用于标识参数数量
int sum(int num_args,...) {
    int val = 0;
    va_list ap;
    int i;

    va_start(ap,num_args);
    for(i=0;i&lt;num_args;i++) {
        val += va_arg(ap,int);
    }
    va_end(ap);
    return val;
}

void test1() {
    printf("10、20 和 30 的和 = %d\n",  sum(3, 10, 20, 30) );
    printf("4、20、25 和 30 的和 = %d\n",  sum(4, 4, 20, 25, 30) );
}

int main() {
    test1();
    return 0;
}</code></pre> 
<pre><code class="language-cpp">heheda@heheda:~/Linux/webserver$ gcc va_list.cpp
heheda@heheda:~/Linux/webserver$ ./a.out
10、20 和 30 的和 = 60
4、20、25 和 30 的和 = 79</code></pre> 
<h6>1.5.2 vsnprintf</h6> 
<p><strong>作用：使用<span style="color:#1c7331;"><code><span style="background-color:#fefcd8;">vsnprintf()</span></code></span>用于<span style="color:#fe2c24;">向一个</span><span style="color:#1c7331;">字符串缓冲区</span><span style="color:#fe2c24;">打印格式化字符串</span>，且可以限定打印的格式化字符串的最大长度</strong></p> 
<pre><code class="language-cpp">#include &lt;stdarg.h&gt;
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
    - 功能：将可变参数格式化输出到一个字符数组
    - 参数：
        - str：把生成的格式化的字符串存放在这里
        - size：str可接受的最大字符数
        - format：指定输出格式的字符串，它决定了你需要提供的可变参数的类型、个数和顺序
        - ap：va_list变量
    - 返回值：
        - 成功：返回最终生成字符串的长度
        - 失败：返回负值</code></pre> 
<ul><li>第一个参数：目标缓冲区（字符数组）</li><li>第二个参数，限定最多打印到缓冲区的字符数量为<code>n-1</code>个（留位置给<code>\0</code>）</li><li>第三个参数，打印的格式（如<code>%d:%s</code>）</li><li>第四个参数，可变参数arg，需要用<code>va_start</code>初始化</li></ul> 
<h6> 1.5.3 fprintf</h6> 
<pre><code class="language-cpp">int fprintf(FILE *stream, const char *format, ...);
</code></pre> 
<pre><code class="language-cpp">#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;cerrno&gt;
#include &lt;ctime&gt;

#define DEBUG 0
#define NOTICE 1
#define WARNING 2
#define FATAL 3

const char* log_level[] = {"DEBUG","NOTICE","WARNING","FATAL"};

// 采用可变参数列表
void logging(int level,const char* format,...) {
    assert(level &gt;= DEBUG &amp;&amp; level &lt;= FATAL);
    char* name = getenv("USER"); // 获取环境变量中的用户（执行命令的用户）
    char logInfo[1024];
    // 获取可变参数列表
    va_list ap;// ap -&gt; char*
    va_start(ap,format);
    vsnprintf(logInfo,sizeof(logInfo),format,ap);
    va_end(ap);// ap = NULL;

    // 根据日志等级选择打印到 stderr/stdout
    FILE *out = (level == FATAL) ? stderr:stdout;
    // 格式化打印到文件中
    fprintf(out, "%s | %u | %s | %s\n", \
        log_level[level], \
        (unsigned int)time(nullptr),\
        name == nullptr ? "unknow":name,\
        logInfo);
}

int main() {
    logging(DEBUG, "socket create success: %d", 114514);
    logging(FATAL, "socket:%s:%d", strerror(errno), 11234);
    return 0;
}</code></pre> 
<pre><code class="language-cpp">heheda@heheda:~/Linux/webserver$ g++ 利用可变参数实现log类.cpp
heheda@heheda:~/Linux/webserver$ ./a.out
DEBUG | 1694175430 | heheda | socket create success: 114514
FATAL | 1694175430 | heheda | socket:Success:11234</code></pre> 
<h4>二、 HTTP请求和响应步骤</h4> 
<h5><img alt="" height="1200" src="https://images2.imgbox.com/cd/04/WHoCsNMY_o.png" width="1200"></h5> 
<h5>2.1 HTTP 响应报文格式</h5> 
<p><img alt="" height="630" src="https://images2.imgbox.com/9b/40/Cmg01YXQ_o.png" width="1200"></p> 
<pre><code class="language-cpp">响应行\r\n
响应头\r\n
空行\r\n
响应体\r\n

提示: 每项信息之间都要有一个\r\n进行分割
</code></pre> 
<h5>2.2 流程图</h5> 
<p>浏览器端发出<span style="color:#1c7331;"><strong>HTTP</strong></span>请求报文，服务器端接收该报文并调用<strong> <span style="color:#1c7331;">process_read</span></strong><span style="color:#1c7331;"> </span>对其进行解析，根据解析结果 <span style="color:#1c7331;"><strong>HTTP_CODE</strong></span>,进入相应的逻辑和模块</p> 
<ul><li>服务器子线程完成报文的解析与响应；</li><li>主线程监测读写事件，调用<span style="color:#1c7331;"><strong> read_once</strong></span> 和 <span style="color:#1c7331;"><strong>http_conn::write </strong></span>完成数据的读取与发送</li></ul> 
<p><img alt="" height="677" src="https://images2.imgbox.com/57/c0/Q5NAEEc7_o.png" width="1200"></p> 
<h5>2.3 HTTP_CODE 含义 </h5> 
<h5><img alt="" height="518" src="https://images2.imgbox.com/2a/84/oj0XS1J6_o.png" width="908"> 2.4 do_request</h5> 
<p><strong><span style="background-color:#fefcd8;">do_request </span></strong>函数的返回值是对请求的文件分析后的结果，一部分是语法错误导致的 <strong>BAD_REQUEST</strong>，一部分是 <strong><span style="background-color:#fff5e6;">do_request </span></strong>的返回结果<strong>（NO_RESOURCE、FORBIDDEN_REQUEST、FILE_REQUEST）</strong></p> 
<p><strong><span style="background-color:#fefcd8;">do_request 函数:</span></strong></p> 
<ul><li>将网络将网站根目录 和 <strong><span style="background-color:#d7d8d9;">url </span></strong>文件拼接</li><li>接着通过 <strong><span style="background-color:#d7d8d9;">stat </span></strong>判断该文件属性</li><li>为了提高访问速度，可通过<strong><span style="background-color:#d7d8d9;">mmap</span></strong>进行映射，将普通文件映射到内存逻辑地址</li></ul> 
<pre><code class="language-cpp">// 网站的根目录
const char* doc_root = "/home/nowcoder/webserver/resources";

// 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，
// 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其
// 映射到内存地址m_file_address处，并告诉调用者获取文件成功
http_conn::HTTP_CODE http_conn::do_request()
{
    // "/home/nowcoder/webserver/resources"
	// 将初始化的m_real_file赋值为网站根目录
    strcpy( m_real_file, doc_root );
    int len = strlen( doc_root );
	
	
    strncpy( m_real_file + len, m_url, FILENAME_LEN - len - 1 );
    
	// 获取m_real_file文件的相关的状态信息，-1失败，0成功
	// 通过stat获取请求资源文件信息，成功则将信息更新到m_file_stat结构体
	// 失败返回NO_RESOURCE状态，表示资源不存在
    if ( stat( m_real_file, &amp;m_file_stat ) &lt; 0 ) {
        return NO_RESOURCE;
    }

    // 判断文件的权限，是否可读，不可读则返回FORBINDDEN_REQUEST状态
    if ( ! ( m_file_stat.st_mode &amp; S_IROTH ) ) {
        return FORBIDDEN_REQUEST;
    }

    // 判断文件类型，如果是目录，则返回BAD_REQUEST，表示请求报文有误
    if ( S_ISDIR( m_file_stat.st_mode ) ) {
        return BAD_REQUEST;
    }

    // 以只读方式获取文件描述符，通过mmap将该文件映射到内存中
    int fd = open( m_real_file, O_RDONLY );
    // 创建内存映射
	// 通过mmap将该文件映射到内存中
    m_file_address = ( char* )mmap( 0, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0 );
    
	// 避免文件描述符的浪费和占用
	close( fd );
	
	// 表示请求文件存在，且可以访问
    return FILE_REQUEST;
}</code></pre> 
<p><strong>unmap 取消映射 </strong></p> 
<pre><code class="language-cpp">// 对内存映射区执行munmap操作
void http_conn::unmap() {
    if( m_file_address )
    {
        munmap( m_file_address, m_file_stat.st_size );
        m_file_address = 0;
    }
}</code></pre> 
<h5> 2.5 process_write</h5> 
<p>根据 <strong><span style="background-color:#d7d8d9;">do_request </span></strong>的返回状态，服务器子线程调用 <strong><span style="background-color:#d7d8d9;">process_write </span></strong>向 <strong><span style="background-color:#d7d8d9;">m_write_buf </span></strong>中写入响应报文</p> 
<ul><li><strong><span style="background-color:#fff5e6;">add_status_line</span></strong>函数，添加状态行:<strong><span style="background-color:#fefcd8;"> http/1.1 状态码 状态消息</span></strong></li><li><strong><span style="background-color:#fff5e6;">add_headers</span></strong>函数添加消息报头，内部调用<strong><span style="background-color:#fff5e6;">add_content_length </span></strong>和 <strong><span style="background-color:#fff5e6;">add_linger</span></strong>函数 
  <ul><li><strong><span style="background-color:#d4e9d5;">content-length</span> 记录<span style="color:#1c7331;">响应报文长度</span></strong>，用于浏览器端判断服务器是否发送完的数据</li><li><strong><span style="background-color:#d4e9d5;">connection </span>记录<span style="color:#1c7331;">连接状态</span></strong>，用于告诉浏览器端保持长连接</li></ul></li><li><strong><span style="background-color:#fff5e6;">add_blank_line</span></strong>添加空行</li></ul> 
<p><span style="color:#1a439c;"><strong><span style="background-color:#edf6e8;">add_status_line、add_headers、add_content_length、add_linger、add_blank_line</span></strong></span><strong>这5个函数</strong>，<span style="background-color:#fefcd8;">均是</span><strong><span style="background-color:#fefcd8;">内部调用</span></strong><span style="background-color:#fefcd8;"> </span><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">add_response</span></strong><span style="background-color:#fefcd8;"> </span></span><strong><span style="background-color:#fefcd8;">函数</span><span style="color:#1c7331;"><span style="background-color:#fefcd8;">更新</span></span></strong><span style="background-color:#fefcd8;"> </span><strong><span style="color:#fe2c24;"><span style="background-color:#fefcd8;">m_write_idx </span></span><span style="background-color:#fefcd8;">指针</span></strong><span style="background-color:#fefcd8;">和</span><strong><span style="background-color:#fefcd8;">缓冲区</span></strong><span style="background-color:#fefcd8;"> </span><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">m_write_buf </span></strong></span><span style="background-color:#fefcd8;">中的内容</span></p> 
<h6>2.5.1 add_response</h6> 
<pre><code class="language-cpp">// 往写缓冲中写入待发送的数据
bool http_conn::add_response( const char* format, ... ) {
	// 如果写入内容超出m_write_buf大小则报错
    if( m_write_idx &gt;= WRITE_BUFFER_SIZE ) {
        return false;
    }
	
	// 定义可变参数列表
    va_list arg_list;
	
	// 将变量arg_list初始化为传入参数
    va_start( arg_list, format );
	
	// 将数据format从可变参数列表写入缓冲区写，返回写入数据的长度
    int len = vsnprintf( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - 1 - m_write_idx, format, arg_list );
    
	// 如果写入的数据长度超过缓冲区剩余空间，则报错
	if( len &gt;= ( WRITE_BUFFER_SIZE - 1 - m_write_idx ) ) {
		va_end( arg_list );
        return false;
    }
	
	// 更新m_write_idx位置
    m_write_idx += len;
	
	// 清空可变参列表
    va_end( arg_list );
	
    return true;
}</code></pre> 
<h6>2.5.2 add_status_line</h6> 
<pre><code class="language-cpp">// 添加状态行
bool http_conn::add_status_line( int status, const char* title ) {
    return add_response( "%s %d %s\r\n", "HTTP/1.1", status, title );
}</code></pre> 
<h6>2.5.3 add_headers</h6> 
<pre><code class="language-cpp">// 添加消息报头，具体的添加文本长度
bool http_conn::add_headers(int content_len) {
    add_content_length(content_len);
    add_content_type();
    add_linger();
    add_blank_line();
}</code></pre> 
<h6>2.5.3 add_headers</h6> 
<pre><code class="language-cpp">// 添加消息报头，具体的添加文本长度
bool http_conn::add_headers(int content_len) {
    add_content_length(content_len);
    add_content_type();
    add_linger();
    add_blank_line();
}</code></pre> 
<h6>2.5.4 add_content_length</h6> 
<pre><code class="language-cpp">// 添加Content-Length，表示响应报文的长度
bool http_conn::add_content_length(int content_len) {
    return add_response( "Content-Length: %d\r\n", content_len );
}</code></pre> 
<h6>2.5.5 add_linger</h6> 
<pre><code class="language-cpp">// 添加连接状态，通知浏览器端是保持连接还是关闭
bool http_conn::add_linger()
{
    return add_response( "Connection: %s\r\n", ( m_linger == true ) ? "keep-alive" : "close" );
}</code></pre> 
<h6>2.5.6 add_blank_line</h6> 
<pre><code class="language-cpp">// 添加空行
bool http_conn::add_blank_line()
{
    return add_response( "%s", "\r\n" );
}</code></pre> 
<h6>2.5.7 add_content</h6> 
<pre><code class="language-cpp">// 添加文本content
bool http_conn::add_content( const char* content )
{
    return add_response( "%s", content );
}</code></pre> 
<h6>2.5.8 add_content_type</h6> 
<pre><code class="language-cpp">// 添加文本类型，这里是html
bool http_conn::add_content_type() {
    return add_response("Content-Type:%s\r\n", "text/html");
}</code></pre> 
<p><strong><span style="background-color:#fefcd8;">响应报文分为两种</span></strong></p> 
<ul><li><strong>①</strong> 一种是<span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">请求文件的存在</span></strong></span>，通过<strong><code><span style="background-color:#d7d8d9;">io</span></code></strong>向量机制<strong><code><span style="background-color:#d7d8d9;">iovec</span></code></strong>，声明两个<strong><code><span style="background-color:#d7d8d9;">iovec</span></code></strong> 
  <ul><li>第一个指向<strong><code><span style="background-color:#d7d8d9;">m_write_buf（包含响应首行和响应头部）</span></code></strong></li><li>第二个指向<strong><code><span style="background-color:#d7d8d9;">mmap</span></code></strong>的地址<strong><code><span style="background-color:#d7d8d9;">m_file_address</span></code></strong>；（响应体）</li></ul></li><li><strong>② </strong>一种是<span style="color:#1c7331;"><strong><span style="background-color:#e7fafa;">请求出错</span></strong></span>，这时候只申请一个<strong><code><span style="background-color:#d7d8d9;">iovec</span></code></strong>，指向<strong><code><span style="background-color:#d7d8d9;">m_write_buf（包含响应首行、响应头部、响应体）</span></code></strong></li></ul> 
<p><strong>&gt;&gt;process_write : 根据服务器处理HTTP请求的结果，决定返回给客户端的内容</strong></p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/0a/28/Od8EYWNP_o.png" width="1200"></p> 
<pre><code class="language-cpp">// 定义HTTP响应的一些状态信息
const char* ok_200_title = "OK";
const char* error_400_title = "Bad Request";
const char* error_400_form = "Your request has bad syntax or is inherently impossible to satisfy.\n";
const char* error_403_title = "Forbidden";
const char* error_403_form = "You do not have permission to get file from this server.\n";
const char* error_404_title = "Not Found";
const char* error_404_form = "The requested file was not found on this server.\n";
const char* error_500_title = "Internal Error";
const char* error_500_form = "There was an unusual problem serving the requested file.\n";

// 根据服务器处理HTTP请求的结果，决定返回给客户端的内容
bool http_conn::process_write(HTTP_CODE ret) {
    switch (ret)
    {
		// 内部错误，500
        case INTERNAL_ERROR:
			// 状态行
            add_status_line( 500, error_500_title );
			// 消息头
            add_headers( strlen( error_500_form ) );
            if ( ! add_content( error_500_form ) ) {
                return false;
            }
            break;
		
		// 报文语法有误，400
        case BAD_REQUEST:
            add_status_line( 400, error_400_title );
            add_headers( strlen( error_400_form ) );
            if ( ! add_content( error_400_form ) ) {
                return false;
            }
            break;
		
		// 请求资源不存在，404
        case NO_RESOURCE:
            add_status_line( 404, error_404_title );
            add_headers( strlen( error_404_form ) );
            if ( ! add_content( error_404_form ) ) {
                return false;
            }
            break;
		
		// 资源没有访问权限，403
        case FORBIDDEN_REQUEST:
            add_status_line( 403, error_403_title );
            add_headers(strlen( error_403_form));
            if ( ! add_content( error_403_form ) ) {
                return false;
            }
            break;
			
		// 请求资源可以正常访问，200
        case FILE_REQUEST:
            add_status_line(200, ok_200_title );
			// 如果请求的资源存在
			if(m_file_stat.st_size !=0 ) {
				add_headers(m_file_stat.st_size);
				// 第一个iovec指针指向响应报文缓冲区，长度指向m_write_idx
				m_iv[ 0 ].iov_base = m_write_buf;
				m_iv[ 0 ].iov_len = m_write_idx;
				
				// 第二个iovec指针指向mmap返回的文件指针，长度指向文件大小
				m_iv[ 1 ].iov_base = m_file_address;
				m_iv[ 1 ].iov_len = m_file_stat.st_size;
				m_iv_count = 2;
				
				// 发送的全部数据为响应报文头部信息和文件大小
				bytes_to_send = m_write_idx + m_file_stat.st_size;
				return true;
			} 
			else {
				// 如果请求的资源大小为0，则返回空白html文件
				const char* ok_string = "&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;";
				add_headers(strlen(ok_string));
				if(!add_content(ok_string)) 
					return false;
			}
            
        default:
            return false;
    }
	// 除FILE_REQUEST状态之外，其余状态只申请一个iovec，指向响应报文缓冲区
    m_iv[ 0 ].iov_base = m_write_buf;
    m_iv[ 0 ].iov_len = m_write_idx;
    m_iv_count = 1;
    bytes_to_send = m_write_idx;
    return true;
}</code></pre> 
<p><img alt="" height="429" src="https://images2.imgbox.com/0d/69/p3swvaJC_o.png" width="797"><br><img alt="" height="415" src="https://images2.imgbox.com/0f/dd/8po2ck6U_o.png" width="707"></p> 
<h5>2.6 write 写事件</h5> 
<p>该函数实现了分散写的功能，也就是把要发送的数据分为多个部分进行传输</p> 
<p>① 首先，在函数开始时，会判断是否存在字节需要发送，如果没有，则结束此次响应</p> 
<p>② 通过writev()函数进行分散写操作，将 m_iv 数组中保存的多个缓冲区的数据写入到套接字中。</p> 
<p>temp : 表示本次写入的字节数量</p> 
<ul><li>bytes_have_send : 记录已经发送的字节数  </li><li>bytes_to_send : 表示剩余需要发送的字节数</li></ul> 
<pre><code class="language-cpp">// 写HTTP响应
// 写事件是指服务器向客户端“写”数据，也就是服务器向客户端发送数据（即HTTP响应报文）
bool http_conn::write()
{
    int temp = 0;
    
	// 若要发送的数据长度为0
	// 表示响应报文为空，一般不会出现这种情况
    if ( bytes_to_send == 0 ) {
        // 将要发送的字节为0，这一次响应结束。
        modfd( m_epollfd, m_sockfd, EPOLLIN ); 
		// 重新初始化HTTP对象
        init();
        return true;
    }

    while(1) {
        // 分散写
		// 将响应报文的状态行、消息头、空行和响应正文发送给浏览器端
        temp = writev(m_sockfd, m_iv, m_iv_count);
		
        if ( temp &lt;= -1 ) {
			// 判断缓冲区是满了
            // 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，
            // 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性
            if( errno == EAGAIN ) {
				// 重新注册写事件
                modfd( m_epollfd, m_sockfd, EPOLLOUT );
                return true;
            }
			// 如果发送失败，但不是缓冲区问题，取消映射
            unmap();
            return false;
        }

        bytes_have_send += temp;// 已发送的字节数
		
		// 更新已发送字节数
        bytes_to_send -= temp;// 剩余需要发送的字节数
		
		// 第一个iovec头部信息的数据已发送完，发送第二个iovec数据
        if (bytes_have_send &gt;= m_iv[0].iov_len) {
			// 不再继续发送头部信息
            m_iv[0].iov_len = 0;
            m_iv[1].iov_base = m_file_address + (bytes_have_send - m_write_idx);
            m_iv[1].iov_len = bytes_to_send;
        }
		// 继续发送第一个iovec头部信息的数据
        else
        {
            m_iv[0].iov_base = m_write_buf + bytes_have_send;
            m_iv[0].iov_len = m_iv[0].iov_len - temp;
        }

		// 判断条件，数据已全部发送完
        if (bytes_to_send &lt;= 0)
        {
            // 取消映射
            unmap();
			
			// 在epoll树上重置EPOLLONESHOT事件
            modfd(m_epollfd, m_sockfd, EPOLLIN);

			// 浏览器的请求为长连接
            if (m_linger)
            {
				// 重新初始化HTTP对象
                init();
                return true;
            }
            else
            {
                return false;
            }
        }

    }
}</code></pre> 
<h5>2.7 总结：生成响应报文的具体流程（<a href="https://blog.csdn.net/qq_53157334/article/details/127586141" title="来自这篇文章">来自这篇文章</a>）</h5> 
<ol><li>进行请求报文的时候，进行URL分析。使用一个文件或其他对象映射到内存，不能映射则报错！</li><li>根据状态码，若为错误状态码，则提取对应的报错介绍和报错信息，作为响应头和响应正文；若为正确的状态码，则提取成功信息作为响应头，提取的内存映射作为响应正文。根据当前的响应头和响应正文的情况，对写缓冲区进行相应的写入（状态行、响应头）</li><li>将写事件写入<a href="https://so.csdn.net/so/search?q=epoll&amp;spm=1001.2101.3001.7020" title="epoll">epoll</a>事件表，之后主线程会自动将写缓冲区中的前半部分报文和响应正文通过分散写传回给客户端</li></ol> 
<h5>2.8 演示效果：</h5> 
<p><img alt="" height="1004" src="https://images2.imgbox.com/e9/b7/p7mzWFon_o.png" width="1181"></p> 
<pre><code class="language-cpp">heheda@heheda:~/Linux/heheda_test/webserver$ g++ main.cpp -pthread
heheda@heheda:~/Linux/heheda_test/webserver$ ./a.out 
按照如下格式运行：a.out port_number
heheda@heheda:~/Linux/heheda_test/webserver$ ./a.out 9999
create the 0th thread
create the 1th thread
create the 2th thread
create the 3th thread
create the 4th thread
create the 5th thread
create the 6th thread
create the 7th thread
heheda read
读取到了数据:GET /index.html HTTP/1.1
Host: 192.168.90.131:9999
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6


got 1 http line : GET /index.html HTTP/1.1
got 1 http line : Host: 192.168.90.131:9999
got 1 http line : Connection: keep-alive
got 1 http line : Upgrade-Insecure-Requests: 1
oop!unknow header Upgrade-Insecure-Requests: 1
got 1 http line : User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
oop!unknow header User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
got 1 http line : Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
oop!unknow header Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
got 1 http line : Accept-Encoding: gzip, deflate
oop!unknow header Accept-Encoding: gzip, deflate
got 1 http line : Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
oop!unknow header Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
got 1 http line : 
write....
heheda read
读取到了数据:GET /images/image1.jpg HTTP/1.1
Host: 192.168.90.131:9999
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://192.168.90.131:9999/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6


got 1 http line : GET /images/image1.jpg HTTP/1.1
got 1 http line : Host: 192.168.90.131:9999
got 1 http line : Connection: keep-alive
got 1 http line : User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
oop!unknow header User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
got 1 http line : Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
oop!unknow header Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
got 1 http line : Referer: http://192.168.90.131:9999/index.html
oop!unknow header Referer: http://192.168.90.131:9999/index.html
got 1 http line : Accept-Encoding: gzip, deflate
oop!unknow header Accept-Encoding: gzip, deflate
got 1 http line : Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
oop!unknow header Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
got 1 http line : 
write....
heheda read
读取到了数据:GET /favicon.ico HTTP/1.1
Host: 192.168.90.131:9999
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://192.168.90.131:9999/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6


got 1 http line : GET /favicon.ico HTTP/1.1
got 1 http line : Host: 192.168.90.131:9999
got 1 http line : Connection: keep-alive
got 1 http line : User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
oop!unknow header User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69
got 1 http line : Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
oop!unknow header Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
got 1 http line : Referer: http://192.168.90.131:9999/index.html
oop!unknow header Referer: http://192.168.90.131:9999/index.html
got 1 http line : Accept-Encoding: gzip, deflate
oop!unknow header Accept-Encoding: gzip, deflate
got 1 http line : Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
oop!unknow header Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
got 1 http line : 
write....
</code></pre> 
<p><strong>推荐和参考文章：</strong></p> 
<p><a href="https://zhuanlan.zhihu.com/p/533284035?utm_id=0" rel="nofollow" title="超详细的HTTP协议请求报文、响应报文教程！ - 知乎 (zhihu.com)">超详细的HTTP协议请求报文、响应报文教程！ - 知乎 (zhihu.com)</a></p> 
<p><a href="https://blog.csdn.net/Boss_peng/article/details/125576937" title="“Web 服务器” 笔记04 ------ 生成、写HTTP响应_http响应报文为啥用writev_CV发烧友的博客-CSDN博客">“Web 服务器” 笔记04 ------ 生成、写HTTP响应_http响应报文为啥用writev_CV发烧友的博客-CSDN博客</a></p> 
<p><a href="https://www.cnblogs.com/BlueBlueSea/p/14999635.html" rel="nofollow" title="writev函数 - lypbendlf - 博客园 (cnblogs.com)">writev函数 - lypbendlf - 博客园 (cnblogs.com)</a></p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&amp;mid=2649274278&amp;idx=8&amp;sn=a6b011ad877d865608dcec7130df0c2f&amp;chksm=83ffbefeb48837e838ec4e001e5ad05dd1930d821ad4114c10d4b59bfabb166bc25b0db1f71b&amp;scene=178&amp;cur_album_id=1339230165934882817#rd" rel="nofollow" title="最新版Web服务器项目详解 - 06 http连接处理（下） (qq.com)">最新版Web服务器项目详解 - 06 http连接处理（下） (qq.com)</a></p> 
<p><a href="https://blog.csdn.net/qq_53157334/article/details/127586141" title="【webserver】 第8节 响应报文的生成_webserver中http处理类中写缓冲区大小小于读缓冲区_几日行云的博客-CSDN博客">【webserver】 第8节 响应报文的生成_webserver中http处理类中写缓冲区大小小于读缓冲区_几日行云的博客-CSDN博客</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/09accec319a25ab5e9486ca75907be7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">矩阵的求导运算</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54d36ecfd63cae58dee27ac72dee144a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">php将数组中的最后一个元素放到第一个</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>