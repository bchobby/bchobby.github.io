<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker Daemon启动 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker Daemon启动" />
<meta property="og:description" content="Docker Daemon启动
Docker Daemon 是Docker架构中运行在后台的守护进程，可分为Docker Server、Engine和Job三部分。
Docker Daemon 是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行，运行过程的几种可能：向Docker Registry获取镜像，通过graphdriver执行容器镜像的本地化操作，通过networkdriver执行容器网络环境的配置，通过execdriver执行容器内部运行的执行工作等。
Docker Daemon架构示意图：
Docker Daemon启动流程图
通过流程图可以看出，有关DockerDaemon的所有工作都在mainDaemon()方法中实现。
mainDaemon()方法:
功能：1)创建Docker运行环境；2)服务于Docker Client，接受并处理请求。
细节：
1) daemon的配置初始化；(在init()函数中实现，即mainDaemon()运行前就执行)
var ( daemonCfg = &amp;daemon.Config{} ) funcinit() { daemonCfg.InstallFlags() } 首先，声明一个为daemon包中Config类型的变量，名为daemonCfg。而Config对象，定义了Docker Daemon所需的配置信息。在Docker Daemon在启动时，daemonCfg变量被传递至Docker Daemon并被使用。
Config对象的定义如下：
typeConfig struct { Pidfile string //Docker Daemon所属进程的PID文件 Root string //Docker运行时所使用的root路径 AutoRestart bool //已被启用，转而支持docker run时的重启 Dns []string //Docker使用的DNS Server地址 DnsSearch []string //Docker使用的指定的DNS查找域名 Mirrors []string //指定的优先Docker Registry镜像 EnableIptables bool //启用Docker的iptables功能 EnableIpForward bool //启用net.ipv4.ip_forward功能 EnableIpMasq bool //启用IP伪装技术 DefaultIp net." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/752fa25f3058eaa7eed1ba7c9614ea18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-04-14T21:30:49+08:00" />
<meta property="article:modified_time" content="2015-04-14T21:30:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker Daemon启动</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="artical-content-bak main-content editor-side-new" style="font-size: 16px;"> 
 <div class="con editor-preview-side" id="result"> 
  <p>Docker Daemon启动</p> 
  <p>Docker Daemon 是Docker架构中运行在后台的守护进程，可分为Docker Server、Engine和Job三部分。</p> 
  <p>Docker Daemon 是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行，运行过程的几种可能：向Docker Registry获取镜像，通过graphdriver执行容器镜像的本地化操作，通过networkdriver执行容器网络环境的配置，通过execdriver执行容器内部运行的执行工作等。</p> 
  <p>Docker Daemon架构示意图：</p> 
  <p> <a href="https://s3.51cto.com/wyfs02/M02/6B/6F/wKiom1UtFbbALM7fAAByRFTq0b0217.jpg" rel="nofollow noopener noreferrer" target="_blank"></a></p> 
  <div style="text-align: center;"> 
   <a href="https://s3.51cto.com/wyfs02/M02/6B/6F/wKiom1UtFbbALM7fAAByRFTq0b0217.jpg" rel="nofollow noopener noreferrer" target="_blank"><img src="https://images2.imgbox.com/5b/7e/dsEma6J5_o.png" title="Docker Daemon架构示意图_编辑.jpg" alt="wKiom1UtFbbALM7fAAByRFTq0b0217.jpg" style="outline: none;"></a> 
  </div> 
  <p></p> 
  <p>Docker Daemon启动流程图</p> 
  <p><a href="https://s3.51cto.com/wyfs02/M02/6B/6A/wKioL1UtFqywqP4oAAD47oZOX20648.jpg" rel="nofollow noopener noreferrer" target="_blank"></a></p> 
  <div style="text-align: center;"> 
   <a href="https://s3.51cto.com/wyfs02/M02/6B/6A/wKioL1UtFqywqP4oAAD47oZOX20648.jpg" rel="nofollow noopener noreferrer" target="_blank"><img src="https://images2.imgbox.com/86/6d/hs8Ni4Us_o.png" title="Docker Daemon启动流程图_编辑.jpg" alt="wKioL1UtFqywqP4oAAD47oZOX20648.jpg" style="outline: none;"></a> 
  </div>  
  <p></p> 
  <p>通过流程图可以看出，有关DockerDaemon的所有工作都在mainDaemon()方法中实现。</p> 
  <p>mainDaemon()方法:</p> 
  <p>功能：1)创建Docker运行环境；2)服务于Docker Client，接受并处理请求。</p> 
  <p>细节：</p> 
  <p>1)  daemon的配置初始化；(在init()函数中实现，即mainDaemon()运行前就执行)</p> 
  <pre><code class="has">var (
daemonCfg = &amp;daemon.Config{}
)
funcinit() {
daemonCfg.InstallFlags()
}</code></pre> 
  <p>首先，声明一个为daemon包中Config类型的变量，名为daemonCfg。而Config对象，定义了Docker Daemon所需的配置信息。在Docker Daemon在启动时，daemonCfg变量被传递至Docker Daemon并被使用。</p> 
  <p>Config对象的定义如下：</p> 
  <pre><code class="has">typeConfig struct {
Pidfile                  string   //Docker Daemon所属进程的PID文件
Root                   string   //Docker运行时所使用的root路径
AutoRestart             bool    //已被启用，转而支持docker run时的重启
Dns                  []string  //Docker使用的DNS Server地址
DnsSearch              []string  //Docker使用的指定的DNS查找域名
Mirrors                 []string  //指定的优先Docker Registry镜像
EnableIptables           bool    //启用Docker的iptables功能
EnableIpForward         bool   //启用net.ipv4.ip_forward功能
EnableIpMasq            bool      //启用IP伪装技术
DefaultIp                net.IP     //绑定容器端口时使用的默认IP
BridgeIface              string      //添加容器网络至已有的网桥
BridgeIP                 string     //创建网桥的IP地址
FixedCIDR               string     //指定IP的IPv4子网，必须被网桥子网包含
InterContainerCommunication   bool //是否允许相同host上容器间的通信
GraphDriver             string      //Docker运行时使用的特定存储驱动
GraphOptions            []string   //可设置的存储驱动选项
ExecDriver               string    // Docker运行时使用的特定exec驱动
Mtu                    int      //设置容器网络的MTU
DisableNetwork          bool     //有定义，之后未初始化
EnableSelinuxSupport      bool    //启用SELinux功能的支持
Context                 map[string][]string   //有定义，之后未初始化
}</code></pre> 
  <p>init()函数实现了daemonCfg变量中各属性的赋值，具体的实现为：daemonCfg.InstallFlags()：</p> 
  <pre><code class="has">func(config *Config) InstallFlags() {
flag.StringVar(&amp;config.Pidfile,[]string{"p", "-pidfile"}, "/var/run/docker.pid",
 "Path to use for daemon PID file")
flag.StringVar(&amp;config.Root,[]string{"g", "-graph"}, "/var/lib/docker",
"Pathto use as the root of the Docker runtime")
……
opts.IPVar(&amp;config.DefaultIp,[]string{"#ip", "-ip"}, "0.0.0.0", "DefaultIP address to
use whenbinding container ports")
opts.ListVar(&amp;config.GraphOptions,[]string{"-storage-opt"}, "Set storage driver options")
……
}</code></pre> 
  <p>在InstallFlags()函数的实现过程中，主要是定义某种类型的flag参数，并将该参数的值绑定在config变量的指定属性上。</p> 
  <p>2)  命令行flag参数检查；</p> 
  <p>当docker命令经过flag参数解析之后，判断剩余的参数是否为0。若为0，则说明Docker Daemon的启动命令无误，正常运行；若不为0，则说明在启动DockerDaemon的时候，传入了多余的参数，此时会输出错误提示，并退出运行程序。具体代码如下：</p> 
  <pre><code class="has">ifflag.NArg() != 0 {
flag.Usage()
return
}</code></pre> 
  <p>3)  创建engine对象；</p> 
  <p>mainDaemon()运行过程中，flag参数检查完毕之后，随即创建engine对象，代码如下：</p> 
  <p>eng :=engine.New()</p> 
  <p>Engine是Docker架构中的运行引擎，同时也是Docker运行的核心模块。Engine扮演着Docker container存储仓库的角色，并且通过job的形式来管理这些容器。</p> 
  <p>在<a href="https://github.com/docker/docker/blob/v1.2.0/engine/engine.go#L47" target="_blank" rel="noopener noreferrer">./docker/engine/engine.go</a>中,Engine结构体的定义如下：</p> 
  <pre><code class="has">type Enginestruct {
handlers  map[string]Handler
catchall  Handler
hack      Hack // data for temporary hackery (see hack.go)
id        string
Stdout    io.Writer
Stderr    io.Writer
Stdin     io.Reader
Logging   bool
tasks     sync.WaitGroup
l         sync.RWMutex // lock for shutdown
shutdown  bool
onShutdown []func() // shutdown handlers
}</code></pre> 
  <p>之后，进入New()函数的实现中：</p> 
  <pre><code class="has">func New()*Engine {
//创建Engine结构体实例eng
eng := &amp;Engine{
        handlers: make(map[string]Handler),
        id:      utils.RandomString(),
        Stdout:  os.Stdout,
        Stderr:  os.Stderr,
        Stdin:   os.Stdin,
        Logging: true,
}
//向eng对象注册名为commands的Handler
eng.Register("commands", func(job*Job) Status {
        for _, name := range eng.commands() {
               job.Printf("%s\n",name)
        }
        return StatusOK
})
// Copy existing global handlers将已定义的变量globalHandlers中的所有的Handler，都
//复制到eng对象的handlers属性中
for k, v := range globalHandlers {
        eng.handlers[k] = v
}
return eng
}</code></pre> 
  <p>New()函数最终返回一个Engine对象。在代码实现部分，第一个工作即为创建一个Engine结构体实例eng；第二个工作是向eng对象注册名为commands的Handler，其中Handler为临时定义的函数func(job *Job) Status{ } , 该函数的作用是通过job来打印所有已经注册完毕的command名称，最终返回状态StatusOK；第三个工作是：将已定义的变量globalHandlers中的所有的Handler，都复制到eng对象的handlers属性中。最后成功返回eng对象。</p> 
  <p>4)  设置engine的信号捕获及处理方法；</p> 
  <p>执行后续代码：</p> 
  <p>signal.Trap(eng.Shutdown)</p> 
  <p>该部分代码的作用是：在Docker Daemon的运行中，设置Trap特定信号的处理方法，特定信号有SIGINT，SIGTERM以及SIGQUIT；当程序捕获到SIGINT或者SIGTERM信号时，执行相应的善后操作，最后保证Docker Daemon程序退出。</p> 
  <p>Trap()函数的代码如下：</p> 
  <pre><code class="has">funcTrap(cleanup func()) {
       c:= make(chan os.Signal, 1)
       signals:= []os.Signal{os.Interrupt, syscall.SIGTERM}
       ifos.Getenv("DEBUG") == "" {
               signals= append(signals, syscall.SIGQUIT)
       }
       gosignal.Notify(c,signals...)
       gofunc() {
               interruptCount:= uint32(0)
               forsig := range c {
                      gofunc(sig os.Signal) {
                             log.Printf("Received signal '%v', starting shutdown ofdocker...\n", sig)
                             switch sig {
                             case os.Interrupt, syscall.SIGTERM:
                                    // If the user really wants to interrupt,let him do so.
                                    if atomic.LoadUint32(&amp;interruptCount)&lt; 3 {
                                           atomic.AddUint32(&amp;interruptCount, 1)
                                           // Initiate the cleanup only once
                                           if atomic.LoadUint32(&amp;interruptCount)== 1 {
                                                  // Call cleanup handler
                                                  cleanup()
                                                  os.Exit(0)
                                           } else {
                                                  return
                                           }
                                    } else {
                                           log.Printf("Force shutdown ofdocker, interrupting cleanup\n")
                                    }
                             case syscall.SIGQUIT:
                             }
                             os.Exit(128 + int(sig.(syscall.Signal)))
                      }(sig)
               }
       }()
}</code></pre> 
  <p>实现流程分为4个步骤：</p> 
  <p>1)创建并设置一个channel，用于发送信号通知；</p> 
  <p>2)定义signals数组变量，初始值为os.SIGINT, os.SIGTERM;若环境变量DEBUG为空的话，则添加os.SIGQUIT至signals数组；</p> 
  <p>3)通过gosignal.Notify(c, signals...)中Notify函数来实现将接收到的signal信号传递给c。需要注意的是只有signals中被罗列出的信号才会被传递给c，其余信号会被直接忽略；</p> 
  <p>4)创建一个goroutine来处理具体的signal信号，当信号类型为os.Interrupt或者syscall.SIGTERM时，执行传入Trap函数的具体执行方法，形参为cleanup(),实参为eng.Shutdown。</p> 
  <p>Shutdown()函数的工作是为Docker Daemon的关闭做一些善后工作。</p> 
  <p>善后工作如下：</p> 
  <p>1)Docker Daemon不再接收任何新的Job；</p> 
  <p>2)Docker Daemon等待所有存活的Job执行完毕；</p> 
  <p>3)Docker Daemon调用所有shutdown的处理方法；</p> 
  <p>4)当所有的handler执行完毕，或者15秒之后，Shutdown()函数返回。</p> 
  <p>5)  加载builtins;</p> 
  <p>为eng设置完Trap特定信号的处理方法之后，Docker Daemon实现了builtins的加载。代码实现如下：</p> 
  <pre><code class="has">if err :=builtins.Register(eng); err != nil {
log.Fatal(err)
}</code></pre> 
  <p>加载builtins的主要工作是为：为engine注册多个Handler，以便后续在执行相应任务时，运行指定的Handler。这些Handler包括：网络初始化、web API服务、事件查询、版本查看、Docker Registry验证与搜索。代码实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/builtins/builtins.go#L16" target="_blank" rel="noopener noreferrer">./docker/builtins/builtins.go</a>,如下：</p> 
  <pre><code class="has">funcRegister(eng *engine.Engine) error {
if err := daemon(eng); err != nil {
        return err
}
if err := remote(eng); err != nil {
        return err
}
if err := events.New().Install(eng); err != nil{
        return err
}
if err := eng.Register("version",dockerVersion); err != nil {
        return err
}
return registry.NewService().Install(eng)
}</code></pre> 
  <p>以上代码实现主要有5个部分：daemon(eng)、remote(eng)、events.New().Install(eng)、eng.Register(“version”,dockerVersion)以及registry.NewService().Install(eng)。</p> 
  <p>daemon(eng)：注册初始化网络驱动的Handler</p> 
  <p>remote(eng)：注册API服务的Handler</p> 
  <p>events.New().Install(eng)：注册events事件的Handler</p> 
  <p>eng.Register(“version”,dockerVersion)：注册版本的Handler</p> 
  <p>registry.NewService().Install(eng)：注册registry的Handler</p> 
  <p>6)  使用goroutine加载daemon对象并运行；</p> 
  <p>执行完builtins的加载，回到mainDaemon()的执行，通过一个goroutine来加载daemon对象并开始运行。这一环节的执行，主要包含三个步骤：</p> 
  <p>1)通过init函数中初始化的daemonCfg与eng对象来创建一个daemon对象d；</p> 
  <p>2)通过daemon对象的Install函数，向eng对象中注册众多的Handler；</p> 
  <p>3)在Docker Daemon启动完毕之后，运行名为”acceptconnections”的job，主要工作为向init守护进程发送”READY=1”信号，以便开始正常接受请求。</p> 
  <p>代码实现如下：</p> 
  <pre><code class="has">go func() {
d, err := daemon.MainDaemon(daemonCfg, eng)
if err != nil {
        log.Fatal(err)
}
if err := d.Install(eng); err != nil {
        log.Fatal(err)
}
if err :=eng.Job("acceptconnections").Run(); err != nil {
        log.Fatal(err)
}
}()</code></pre> 
  <p>三个步骤详解：</p> 
  <p>1)创建daemon对象：daemon.MainDaemon(daemonCfg, eng)是创建daemon对象d的核心部分。主要作用为初始化Docker Daemon的基本环境，如处理config参数，验证系统支持度，配置Docker工作目录，设置与加载多种driver，创建graph环境等，验证DNS配置等。</p> 
  <p>2)通过daemon对象为engine注册Handler:</p> 
  <p>创建完daemon对象，goroutine执行d.Install(eng)，具体实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/daemon.go#L100" target="_blank" rel="noopener noreferrer">./docker/daemon/daemon.go</a>:</p> 
  <pre><code class="has">func (daemon*Daemon) Install(eng *engine.Engine) error {
for name, method := rangemap[string]engine.Handler{
        "attach":            daemon.ContainerAttach,
        ……
        "p_w_picpath_delete":      daemon.ImageDelete,
} {
        if err := eng.Register(name, method);err != nil {
               return err
        }
}
if err := daemon.Repositories().Install(eng);err != nil {
        return err
}
eng.Hack_SetGlobalVar("httpapi.daemon",daemon)
return nil
}</code></pre> 
  <p>以上代码的实现分为三部分：</p> 
  <ul type="disc" class="list-paddingleft-2"><li><p>向eng对象中注册众多的Handler对象；</p></li><li><p>daemon.Repositories().Install(eng)实现了向eng对象注册多个与p_w_picpath相关的Handler，Install的实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/graph/service.go#L12" target="_blank" rel="noopener noreferrer">./docker/graph/service.go</a>；</p></li><li><p>eng.Hack_SetGlobalVar("httpapi.daemon", daemon)实现向eng对象中map类型的hack对象中添加一条记录，key为”httpapi.daemon”，value为daemon。</p></li></ul> 
  <p>3)运行acceptconnection的job:</p> 
  <p>在goroutine内部最后运行名为”acceptconnections”的job，主要作用是通知init守护进程，Docker Daemon可以开始接受请求了。</p> 
  <p>7)  打印Docker版本信息及驱动信息；</p> 
  <p>回到mainDaemon()的运行流程中，在goroutine的执行之时，mainDaemon()函数内部其它代码也会并发执行。</p> 
  <p>显示docker的版本信息，以及ExecDriver和GraphDriver这两个驱动的具体信息，代码如下：</p> 
  <pre><code class="has">logrus.WithFields(logrus.Fields{
               "version":     dockerversion.VERSION,
               "commit":      dockerversion.GITCOMMIT,
               "execdriver":  d.ExecutionDriver().Name(),
               "graphdriver":d.GraphDriver().String(),
        }).Info("Docker daemon")</code></pre> 
  <p>8)  Job之“serveapi”的创建与运行。</p> 
  <p>打印部分Docker具体信息之后，DockerDaemon立即创建并运行名为”serveapi”的job，主要作用为让Docker Daemon提供API访问服务。实现代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/docker/daemon.go#L66" target="_blank" rel="noopener noreferrer">./docker/docker/daemon.go</a>:</p> 
  <pre><code class="has">job :=eng.Job("serveapi", flHosts...)
job.SetenvBool("Logging",true)
job.SetenvBool("EnableCors",*flEnableCors)
job.Setenv("Version",dockerversion.VERSION)
job.Setenv("SocketGroup",*flSocketGroup)
 
job.SetenvBool("Tls",*flTls)
job.SetenvBool("TlsVerify",*flTlsVerify)
job.Setenv("TlsCa",*flCa)
job.Setenv("TlsCert",*flCert)
job.Setenv("TlsKey",*flKey)
job.SetenvBool("BufferRequests",true)
if err :=job.Run(); err != nil {
log.Fatal(err)
}</code></pre> 
  <p>实现过程中，首先创建一个名为”serveapi”的job，并将flHosts的值赋给job.Args。flHost的作用主要是为Docker Daemon提供使用的协议与监听的地址。随后，Docker Daemon为该job设置了众多的环境变量，如安全传输层协议的环境变量等。最后通过job.Run()运行该serveapi的job。</p> 
  <p>至此，可以认为DockerDaemon已经完成了serveapi这个job的初始化工作。一旦acceptconnections这个job运行完毕，则会通知init进程Docker Daemon启动完毕，可以开始提供API服务。本文从源码的角度简单分析了Docker Daemon的启动，着重分析了mainDaemon()的实现。</p> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c55e75cd653d83200201bb9951ce122c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">09-SQLite之join</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da7345a561390ddf5c5d43c568313fe5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS 7打开NTF文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>