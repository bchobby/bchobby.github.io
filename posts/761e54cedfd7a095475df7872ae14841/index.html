<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>prometheus 配置文件详解 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="prometheus 配置文件详解" />
<meta property="og:description" content="目录 prometheus 配置文件详解 简介配置文件 原始配置文件内容global字段alerting 字段 alert_relabel_configsalertmanagersrule_files 规则分组rule_groupalerting rules定义Recording rules使用模板规则检查scrape_configs字段 job_namehonor_labelsschemeparams抓取认证类basic_authbearer_tokentls_configproxy_url服务发现类static_configs数据过滤类target配置示例sample_limit远程读写 remote_readremote_write参考文档 prometheus 配置文件详解 简介 Prometheus配置方式有两种：
命令行，用来配置不可变命令参数，主要是Prometheus运行参数，比如数据存储位置配置文件，用来配置Prometheus应用参数，比如数据采集，报警对接 不重启进程配置生效方式有两种:
对进程发送信号SIGHUPHTTP POST请求，需要开启–web.enable-lifecycle选项curl -X POST http://192.168.66.112:9091/-/reload 配置文件格式是yaml格式,.yml或者.yaml 都是 yaml格式的文件， yaml格式的好处: 和json交互比较容易 python/go/java/php 有yaml格式库，方便语言之间解析,并且这种格式存储的信息量很大
配置文件 配置文件使用yml格式，配置文件中一级配置项如下，说明参考#备注内容
＃全局配置 (如果有内部单独设定，会覆盖这个参数) global: ＃告警插件定义。这里会设定alertmanager这个报警插件。 alerting: ＃告警规则。 按照设定参数进行扫描加载，用于自定义报警规则，其报警媒介和route路由由alertmanager插件实现。 rule_files: ＃采集配置。配置数据源，包含分组job_name以及具体target。又分为静态配置和服务发现 scrape_configs: ＃用于远程存储写配置 remote_write: ＃用于远程读配置 remote_read: 配置文件中通用字段值格式 : 布尔类型值为true和false : 协议方式包含http和https
原始配置文件内容 # my global config global: scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/761e54cedfd7a095475df7872ae14841/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-16T14:06:00+08:00" />
<meta property="article:modified_time" content="2022-11-16T14:06:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">prometheus 配置文件详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown" style="font-size: 16px;"> 
 <div class="toc"> 
  <div class="toc-container-header">
    目录 
  </div> 
  <ul><li><a href="#prometheus-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3" rel="noopener">prometheus 配置文件详解</a> 
    <ul><li><a href="#%E7%AE%80%E4%BB%8B" rel="noopener">简介</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="noopener">配置文件</a> 
      <ul><li><a href="#%E5%8E%9F%E5%A7%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9" rel="noopener">原始配置文件内容</a></li><li><a href="#global%E5%AD%97%E6%AE%B5" rel="noopener">global字段</a></li><li><a href="#alerting-%E5%AD%97%E6%AE%B5" rel="noopener">alerting 字段</a> 
        <ul><li><a href="#alert_relabel_configs" rel="noopener">alert_relabel_configs</a></li><li><a href="#alertmanagers" rel="noopener">alertmanagers</a></li></ul></li><li><a href="#rule_files" rel="noopener">rule_files</a> 
        <ul><li><a href="#%E8%A7%84%E5%88%99%E5%88%86%E7%BB%84rule_group" rel="noopener">规则分组rule_group</a></li><li><a href="#alerting-rules" rel="noopener">alerting rules</a></li><li><a href="#%E5%AE%9A%E4%B9%89recording-rules" rel="noopener">定义Recording rules</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF" rel="noopener">使用模板</a></li><li><a href="#%E8%A7%84%E5%88%99%E6%A3%80%E6%9F%A5" rel="noopener">规则检查</a></li></ul></li><li><a href="#scrape_configs%E5%AD%97%E6%AE%B5" rel="noopener">scrape_configs字段</a> 
        <ul><li><a href="#job_name" rel="noopener">job_name</a></li><li><a href="#honor_labels" rel="noopener">honor_labels</a></li><li><a href="#scheme" rel="noopener">scheme</a></li><li><a href="#params" rel="noopener">params</a></li><li><a href="#%E6%8A%93%E5%8F%96%E8%AE%A4%E8%AF%81%E7%B1%BB" rel="noopener">抓取认证类</a></li><li><a href="#basic_auth" rel="noopener">basic_auth</a></li><li><a href="#bearer_token" rel="noopener">bearer_token</a></li><li><a href="#tls_config" rel="noopener">tls_config</a></li><li><a href="#proxy_url" rel="noopener">proxy_url</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%B1%BB" rel="noopener">服务发现类</a></li><li><a href="#static_configs" rel="noopener">static_configs</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E7%B1%BB" rel="noopener">数据过滤类</a></li><li><a href="#target%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B" rel="noopener">target配置示例</a></li><li><a href="#sample_limit" rel="noopener">sample_limit</a></li></ul></li><li><a href="#%E8%BF%9C%E7%A8%8B%E8%AF%BB%E5%86%99" rel="noopener">远程读写</a> 
        <ul><li><a href="#remote_read" rel="noopener">remote_read</a></li><li><a href="#remote_write" rel="noopener">remote_write</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3" rel="noopener">参考文档</a></li></ul></li></ul> 
 </div> 
 <h3 id="prometheus-配置文件详解">prometheus 配置文件详解</h3> 
 <h4 id="简介">简介</h4> 
 <p>Prometheus配置方式有两种：</p> 
 <ul><li>命令行，用来配置不可变命令参数，主要是Prometheus运行参数，比如数据存储位置</li><li>配置文件，用来配置Prometheus应用参数，比如数据采集，报警对接</li></ul> 
 <p>不重启进程配置生效方式有两种:</p> 
 <ul><li>对进程发送信号SIGHUP</li><li>HTTP POST请求，需要开启–web.enable-lifecycle选项curl -X POST <a href="http://192.168.66.112:9091/-/reload" rel="noopener noopener noreferrer" target="_blank">http://192.168.66.112:9091/-/reload</a></li></ul> 
 <p>配置文件格式是yaml格式,.yml或者.yaml 都是 yaml格式的文件， yaml格式的好处: 和json交互比较容易 python/go/java/php 有yaml格式库，方便语言之间解析,并且这种格式存储的信息量很大</p> 
 <h4 id="配置文件">配置文件</h4> 
 <p>配置文件使用yml格式，配置文件中一级配置项如下，说明参考#备注内容</p> 
 <pre class="has"><code>＃全局配置 (如果有内部单独设定，会覆盖这个参数)
global:

＃告警插件定义。这里会设定alertmanager这个报警插件。
alerting:

＃告警规则。 按照设定参数进行扫描加载，用于自定义报警规则，其报警媒介和route路由由alertmanager插件实现。
rule_files:

＃采集配置。配置数据源，包含分组job_name以及具体target。又分为静态配置和服务发现
scrape_configs:

＃用于远程存储写配置
remote_write:

＃用于远程读配置
remote_read:</code></pre> 
 <p>配置文件中通用字段值格式 : 布尔类型值为true和false : 协议方式包含http和https</p> 
 <h5 id="原始配置文件内容">原始配置文件内容</h5> 
 <pre class="has"><code># my global config
global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).
 
# Alertmanager configuration
alerting:
  alertmanagers:
  - static_configs:
    - targets:
      # - alertmanager:9093
 
# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"
 
# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=` to any timeseries scraped from this config.
  - job_name: 'prometheus'
 
    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.
 
    static_configs:
    - targets: ['localhost:9090']</code></pre> 
 <h5 id="global字段">global字段</h5> 
 <pre class="has"><code>//scrape_interval
//全局默认的数据拉取间隔
[ scrape_interval: &lt;duration&gt; | default = 1m ]

//scrape_timeout
//全局默认的单次数据拉取超时，当报context deadline exceeded错误时需要在特定的job下配置该字段。
[ scrape_timeout: &lt;duration&gt; | default = 10s ]

//evaluation_interval
//全局默认的规则(主要是报警规则)拉取间隔
[ evaluation_interval: &lt;duration&gt; | default = 1m ]

//external_labels
//该服务端在与其他系统对接所携带的标签
[ &lt;labelname&gt;: &lt;labelvalue&gt; ... ]</code></pre> 
 <h5 id="alerting-字段">alerting 字段</h5> 
 <p>该字段配置与Alertmanager进行对接的配置 样例：</p> 
 <pre class="has"><code>alerting:
  alert_relabel_configs: # 动态修改 alert 属性的规则配置。
    - source_labels: [dc] 
      regex: (.+)\d+
      target_label: dc1
  alertmanagers:
    - static_configs:
        - targets: ['127.0.0.1:9093'] # 单实例配置
        #- targets: ['172.31.10.167:19093','172.31.10.167:29093','172.31.10.167:39093'] # 集群配置
    - job_name: 'Alertmanager'
    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.
    - static_configs:
      - targets: ['localhost:19093']</code></pre> 
 <p>上面的配置中的 alert_relabel_configs是指警报重新标记在发送到Alertmanager之前应用于警报。 它具有与目标重新标记相同的配置格式和操作，外部标签标记后应用警报重新标记，主要是针对集群配置。</p> 
 <p>这个设置的用途是确保具有不同外部label的HA对Prometheus服务端发送相同的警报信息。</p> 
 <p>Alertmanager 可以通过 static_configs 参数静态配置，也可以使用其中一种支持的服务发现机制动态发现，我们上面的配置是静态的单实例。</p> 
 <p>此外，relabel_configs 允许从发现的实体中选择 Alertmanager，并对使用的API路径提供高级修改，该路径通过 <strong>alerts_path</strong> 标签公开。</p> 
 <p>完成以上配置后，重启Prometheus服务，用以加载生效，也可以使用热加载功能，使其配置生效。然后通过浏览器，访问 <a href="http://192.168.1.220:19090/alerts" rel="noopener noopener noreferrer" target="_blank">http://192.168.1.220:19090/alerts</a> 就可以看 inactive pending firing 三个状态，没有警报信息是因为我们还没有配置警报规则 rules。</p> 
 <p>这里定义和prometheus集成的alertmanager插件，用于监控报警。后续会单独进行alertmanger插件的配置、配置说明、报警媒介以及route路由规则记录。</p> 
 <h6 id="alert_relabel_configs">alert_relabel_configs</h6> 
 <p>此项配置和scrape_configs字段中relabel_configs配置一样，用于对需要报警的数据进行过滤后发向Alertmanager</p> 
 <p>说明 relabel-configs的配置允许你选择你想抓取的目标和这些目标的标签是什么。所以说如果你想要抓取这种类型的服务器而不是那种，可以使用relabel_configs</p> 
 <p>相比之下，metric_relabel_configs是发生在抓取之后，但在数据被插入存储系统之前使用。因此如果有些你想过滤的指标，或者来自抓取本身的指标(比如来自/metrics页面)你就可以使用metric_relabel_configs来处理。</p> 
 <h6 id="alertmanagers">alertmanagers</h6> 
 <p>该项目主要用来配置不同的alertmanagers服务，以及Prometheus服务和他们的链接参数。alertmanagers服务可以静态配置也可以使用服务发现配置。Prometheus以pushing 的方式向alertmanager传递数据。</p> 
 <p>alertmanager 服务配置和target配置一样，可用字段如下</p> 
 <pre class="has"><code>[ timeout: &lt;duration&gt; | default = 10s ]
[ path_prefix: &lt;path&gt; | default = / ]
[ scheme: &lt;scheme&gt; | default = http ]
basic_auth:
  [ username: &lt;string&gt; ]
  [ password: &lt;string&gt; ]
  [ password_file: &lt;string&gt; ]
[ bearer_token: &lt;string&gt; ]
[ bearer_token_file: /path/to/bearer/token/file ]
tls_config:
  [ &lt;tls_config&gt; ]
[ proxy_url: &lt;string&gt; ]
azure_sd_configs:
  [ - &lt;azure_sd_config&gt; ... ]
consul_sd_configs:
  [ - &lt;consul_sd_config&gt; ... ]
dns_sd_configs:
  [ - &lt;dns_sd_config&gt; ... ]
ec2_sd_configs:
  [ - &lt;ec2_sd_config&gt; ... ]
file_sd_configs:
  [ - &lt;file_sd_config&gt; ... ]
gce_sd_configs:
  [ - &lt;gce_sd_config&gt; ... ]
kubernetes_sd_configs:
  [ - &lt;kubernetes_sd_config&gt; ... ]
marathon_sd_configs:
  [ - &lt;marathon_sd_config&gt; ... ]
nerve_sd_configs:
  [ - &lt;nerve_sd_config&gt; ... ]
serverset_sd_configs:
  [ - &lt;serverset_sd_config&gt; ... ]
triton_sd_configs:
  [ - &lt;triton_sd_config&gt; ... ]
static_configs:
  [ - &lt;static_config&gt; ... ]
relabel_configs:
  [ - &lt;relabel_config&gt; ... ]</code></pre> 
 <h5 id="rule_files">rule_files</h5> 
 <p>这个主要是用来设置告警规则，基于设定什么指标进行报警(类似触发器trigger)。这里设定好规则以后，prometheus会根据全局global设定的evaluation_interval参数进行扫描加载，规则改动后会自动加载。其报警媒介和route路由由alertmanager插件实现。 样例：</p> 
 <pre class="has"><code># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"</code></pre> 
 <p>first_rules.yml"样例：</p> 
 <pre class="has"><code>groups:
 - name: test-rules
   rules:
   - alert: InstanceDown # 告警名称
     expr: up == 0 # 告警的判定条件，参考Prometheus高级查询来设定
     for: 10s # 满足告警条件持续时间多久后，才会发送告警
     labels: #标签项
      severity: error
     annotations: # 解析项，详细解释告警信息
      summary: "{<!-- -->{$labels.instance}}: has been down"
      description: "{<!-- -->{$labels.instance}}: job {<!-- -->{$labels.job}} has been down "</code></pre> 
 <p>Prometheus 支持两种类型的 Rules ，可以对其进行配置，然后定期进行运算：recording rules 记录规则 与 alerting rules 警报规则，规则文件的计算频率与警报规则计算频率一致，都是通过全局配置中的 evaluation_interval 定义</p> 
 <h6 id="规则分组rule_group">规则分组rule_group</h6> 
 <p>不论是recording rules还是alerting rules都要在组里面。</p> 
 <pre class="has"><code>groups:
  
  - name: example
    #该组下的规则
    rules:
      [ - &lt;rule&gt; ... ]</code></pre> 
 <h6 id="alerting-rules">alerting rules</h6> 
 <p>要在Prometheus中使用Rules规则，就必须创建一个包含必要规则语句的文件，并让Prometheus通过Prometheus配置中的rule_files字段加载该文件，前面我们已经讲过了。 其实语法都一样，除了 recording rules 中的收集的指标名称 record: 字段配置方式略有不同，其他都是一样的。</p> 
 <p>配置范例：</p> 
 <pre class="has"><code>- alert: ServiceDown
  expr: avg_over_time(up[5m]) * 100 &lt; 50
  annotations:
      description: The service {<!-- -->{ $labels.job }} instance {<!-- -->{ $labels.instance }} is
        not responding for more than 50% of the time for 5 minutes.
      summary: The service {<!-- -->{ $labels.job }} is not responding
- alert: RedisDown
  expr: avg_over_time(redis_up[5m]) * 100 &lt; 50
  annotations:
      description: The Redis service {<!-- -->{ $labels.job }} instance {<!-- -->{ $labels.instance
        }} is not responding for more than 50% of the time for 5 minutes.
      summary: The Redis service {<!-- -->{ $labels.job }} is not responding
- alert: PostgresDown
  expr: avg_over_time(pg_up[5m]) * 100 &lt; 50
  annotations:
      description: The Postgres service {<!-- -->{ $labels.job }} instance {<!-- -->{ $labels.instance
        }} is not responding for more than 50% of the time for 5 minutes.
      summary: The Postgres service {<!-- -->{ $labels.job }} is not responding</code></pre> 
 <h6 id="定义recording-rules">定义Recording rules</h6> 
 <p>recording rules 是提前设置好一个比较花费大量时间运算或经常运算的表达式，其结果保存成一组新的时间序列数据。当需要查询的时候直接会返回已经计算好的结果，这样会比直接查询快，同时也减轻了PromQl的计算压力，同时对可视化查询的时候也很有用，可视化展示每次只需要刷新重复查询相同的表达式即可。</p> 
 <p>在配置的时候，除却 record: 需要注意，其他的基本上是一样的，一个 groups 下可以包含多条规则 rules ，Recording 和 Rules 保存在 group 内，Group 中的规则以规则的配置时间间隔顺序运算，也就是全局中的 evaluation_interval 设置。</p> 
 <p>配置范例：</p> 
 <pre class="has"><code>groups:
- name: http_requests_total
  rules:
  - record: job:http_requests_total:rate10m
    expr: sum by (job)(rate(http_requests_total[10m]))
    lables:
      team: operations
  - record: job:http_requests_total:rate30m
    expr: sum by (job)(rate(http_requests_total[30m]))
    lables:
      team: operations</code></pre> 
 <p>上面的规则其实就是根据 record 规则中的定义，Prometheus 会在后台完成 expr 中定义的 PromQL 表达式周期性运算，以 job 为维度使用 sum 聚合运算符 计算 函数rate 对http_requests_total 指标区间 10m 内的增长率，并且将计算结果保存到新的时间序列 job:http_requests_total:rate10m 中， 同时还可以通过 labels 为样本数据添加额外的自定义标签，但是要注意的是这个 lables 一定存在当前表达式 Metrics 中。</p> 
 <h6 id="使用模板">使用模板</h6> 
 <p>模板是在警报中使用时间序列标签和值展示的一种方法，可以用于警报规则中的注释(annotation)与标签(lable)。模板其实使用的go语言的标准模板语法，并公开一些包含时间序列标签和值的变量。这样查询的时候，更具有可读性，也可以执行其他PromQL查询 来向警报添加额外内容，ALertmanager Web UI中会根据标签值显示器警报信息。</p> 
 <p>{<!-- -->{ $lable.}} 可以获取当前警报实例中的指定标签值</p> 
 <p>{<!-- -->{ $value }} 变量可以获取当前PromQL表达式的计算样本值。</p> 
 <pre class="has"><code>groups:
- name: operations
  rules:
# monitor node memory usage
  - alert: node-memory-usage
    expr: (1 - (node_memory_MemAvailable_bytes{env="operations",job!='atlassian'} / (node_memory_MemTotal_bytes{env="operations"})))* 100 &gt; 90
    for: 1m
    labels:
      status: Warning
      team: operations
    annotations:
      description: "Environment: {<!-- -->{ $labels.env }} Instance: {<!-- -->{ $labels.instance }} memory usage above {<!-- -->{ $value }} ! ! !"
      summary:  "node os memory usage status"</code></pre> 
 <p>调整好rules以后，我们可以使用 curl -XPOST <a href="http://localhost:9090/-/reload" rel="noopener noopener noreferrer" target="_blank">http://localhost:9090/-/reload</a> 或者 对Prometheus服务重启，让警报规则生效。</p> 
 <p>这个时候，我们可以把阈值调整为 50 来进行故障模拟操作，这时在去访问UI的时候，当持续1分钟满足警报条件，实际警报状态已转换为 Firing，可以在 Annotations中看到模板信息 summary 与 description 已经成功显示</p> 
 <h6 id="规则检查">规则检查</h6> 
 <pre class="has"><code>#打镜像后使用
FROM golang:1.10

RUN GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go get -u github.com/prometheus/prometheus/cmd/promtool

FROM alpine:latest  

COPY --from=0 /go/bin/promtool /bin
ENTRYPOINT ["/bin/promtool"]  

# 编译
docker build -t promtool:0.1 .
#使用
docker run --rm -v /root/test/prom:/opt promtool:0.1 check rules /opt/rule.yml
#返回
Checking /opt/rule.yml
  SUCCESS: 1 rules found</code></pre> 
 <h5 id="scrape_configs字段">scrape_configs字段</h5> 
 <p>拉取数据配置，在配置字段内可以配置拉取数据的对象(Targets)，job以及实例</p> 
 <h6 id="job_name">job_name</h6> 
 <p>定义job名称，是一个拉取单元。每个job_name都会自动引入默认配置如</p> 
 <ul><li>scrape_interval 依赖全局配置</li><li>scrape_timeout 依赖全局配置</li><li>metrics_path 默认为’/metrics’</li><li>scheme 默认为’http’<br> 这些也可以在单独的job中自定义</li></ul> 
 <pre class="has"><code>[ scrape_interval: &lt;duration&gt; | default = &lt;global_config.scrape_interval&gt; ]
[ scrape_timeout: &lt;duration&gt; | default = &lt;global_config.scrape_timeout&gt; ]
[ metrics_path: &lt;path&gt; | default = /metrics ]</code></pre> 
 <h6 id="honor_labels">honor_labels</h6> 
 <p>服务端拉取过来的数据也会存在标签，配置文件中也会有标签，这样就可能发生冲突。</p> 
 <p>true就是以抓取数据中的标签为准 false就会重新命名抓取数据中的标签为“exported”形式，然后添加配置文件中的标签</p> 
 <pre class="has"><code>[ honor_labels: &lt;boolean&gt; | default = false ]</code></pre> 
 <h6 id="scheme">scheme</h6> 
 <p>切换抓取数据所用的协议</p> 
 <pre class="has"><code>[ scheme: &lt;scheme&gt; | default = http ]</code></pre> 
 <h6 id="params">params</h6> 
 <p>定义可选的url参数</p> 
 <pre class="has"><code>[ &lt;string&gt;: [&lt;string&gt;, ...] ]</code></pre> 
 <h6 id="抓取认证类">抓取认证类</h6> 
 <p>每次抓取数据请求的认证信息</p> 
 <h6 id="basic_auth">basic_auth</h6> 
 <p>password和password_file互斥只可以选择其一</p> 
 <pre class="has"><code>basic_auth:
  [ username: &lt;string&gt; ]
  [ password: &lt;secret&gt; ]
  [ password_file: &lt;string&gt; ]</code></pre> 
 <h6 id="bearer_token">bearer_token</h6> 
 <p>bearer_token和bearer_token_file互斥只可以选择其一</p> 
 <pre class="has"><code>[ bearer_token: &lt;secret&gt; ]
[ bearer_token_file: /path/to/bearer/token/file ]</code></pre> 
 <h6 id="tls_config">tls_config</h6> 
 <p>抓取ssl请求时证书配置</p> 
 <pre class="has"><code>tls_config:
  [ ca_file: &lt;filename&gt; ]
  [ cert_file: &lt;filename&gt; ]
  [ key_file: &lt;filename&gt; ]
  [ server_name: &lt;string&gt; ]
  #禁用证书验证
  [ insecure_skip_verify: &lt;boolean&gt; ]</code></pre> 
 <h6 id="proxy_url">proxy_url</h6> 
 <p>通过代理去主取数据</p> 
 <pre class="has"><code>[ proxy_url: &lt;string&gt; ]</code></pre> 
 <h6 id="服务发现类">服务发现类</h6> 
 <p>Prometheus支持多种服务发现工具，详细配置这里不再展开</p> 
 <pre class="has"><code>#sd就是service discovery的缩写
azure_sd_configs: 
consul_sd_configs:
dns_sd_configs:
ec2_sd_configs:
openstack_sd_configs:
file_sd_configs:
gce_sd_configs:
kubernetes_sd_configs:
marathon_sd_configs:
nerve_sd_configs:
serverset_sd_configs:
triton_sd_configs:</code></pre> 
 <p>更多参考官网：<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" rel="noopener noopener noreferrer" target="_blank">https://prometheus.io/docs/prometheus/latest/configuration/configuration/</a></p> 
 <h6 id="static_configs">static_configs</h6> 
 <p>服务发现来获取抓取目标为动态配置，这个配置项目为静态配置，静态配置为典型的targets配置，在改配置字段可以直接添加标签</p> 
 <pre class="has"><code>- targets:
    [ - '&lt;host&gt;' ]
  labels:
    [ &lt;labelname&gt;: &lt;labelvalue&gt; ... ]</code></pre> 
 <p>采集器所采集的数据都会带有label，当使用服务发现时，比如consul所携带的label如下:</p> 
 <pre class="has"><code>__meta_consul_address: consul地址
__meta_consul_dc: consul中服务所在的数据中心
__meta_consul_metadata_: 服务的metadata
__meta_consul_node: 服务所在consul节点的信息
__meta_consul_service_address: 服务访问地址
__meta_consul_service_id: 服务ID
__meta_consul_service_port: 服务端口
__meta_consul_service: 服务名称
__meta_consul_tags: 服务包含的标签信息</code></pre> 
 <p>这些lable是数据筛选与聚合计算的基础。</p> 
 <h6 id="数据过滤类">数据过滤类</h6> 
 <p>抓取数据很繁杂，尤其是通过服务发现添加的target。所以过滤就显得尤为重要，我们知道抓取数据就是抓取target的一些列metrics，Prometheus过滤是通过对标签操作操现的，在字段relabel_configs和metric_relabel_configs里面配置，两者的配置都需要relabel_config字段。该字段需要配置项如下</p> 
 <pre class="has"><code>[ source_labels: '[' &lt;labelname&gt; [, ...] ']' ]

[ separator: &lt;string&gt; | default = ; ]

[ target_label: &lt;labelname&gt; ]

[ regex: &lt;regex&gt; | default = (.*) ]

[ modulus: &lt;uint64&gt; ]

[ replacement: &lt;string&gt; | default = $1 ]

#action除了默认动作还有keep、drop、hashmod、labelmap、labeldrop、labelkeep
[ action: &lt;relabel_action&gt; | default = replace ]</code></pre> 
 <h6 id="target配置示例">target配置示例</h6> 
 <pre class="has"><code>relabel_configs:
  - source_labels: [job]
    regex:         (.*)some-[regex]
    action:        drop
  - source_labels: [__address__]
    modulus:       8
    target_label:  __tmp_hash
    action:        hashmod</code></pre> 
 <p>target中metric示例</p> 
 <pre class="has"><code>- job_name: cadvisor
  ...
  metric_relabel_configs:
  - source_labels: [id]
    regex: '/system.slice/var-lib-docker-containers.*-shm.mount'
    action: drop
  - source_labels: [container_label_JenkinsId]
    regex: '.+'
    action: drop</code></pre> 
 <p>使用示例 由以上可知当使用服务发现consul会带入标签__meta_consul_dc，现在为了表示方便需要将该标签变为dc<br> 需要做如下配置，这里面action使用的replacement</p> 
 <pre class="has"><code>scrape_configs:
  - job_name: consul_sd
    relabel_configs:
    - source_labels:  ["__meta_consul_dc"]
      regex: "(.*)"
      replacement: $1
      action: replace
      target_label: "dc"

#或者
- source_labels:  ["__meta_consul_dc"]
  target_label: "dc"</code></pre> 
 <p>过滤采集target</p> 
 <pre class="has"><code>relabel_configs:
- source_labels: ["__meta_consul_tags"]
  regex: ".*,development,.*"
  action: keep</code></pre> 
 <h6 id="sample_limit">sample_limit</h6> 
 <p>为了防止Prometheus服务过载，使用该字段限制经过relabel之后的数据采集数量，超过该数字拉取的数据就会被忽略</p> 
 <pre class="has"><code>[ sample_limit: &lt;int&gt; | default = 0 ]</code></pre> 
 <h5 id="远程读写">远程读写</h5> 
 <p>Prometheus可以进行远程读/写数据。字段remote_read和remote_write</p> 
 <h6 id="remote_read">remote_read</h6> 
 <pre class="has"><code>#远程读取的url
url: &lt;string&gt;

#通过标签来过滤读取的数据
required_matchers:
  [ &lt;labelname&gt;: &lt;labelvalue&gt; ... ]

[ remote_timeout: &lt;duration&gt; | default = 1m ]

#当远端不是存储的时候激活该项
[ read_recent: &lt;boolean&gt; | default = false ]

basic_auth:
  [ username: &lt;string&gt; ]
  [ password: &lt;string&gt; ]
  [ password_file: &lt;string&gt; ]
[ bearer_token: &lt;string&gt; ]
[ bearer_token_file: /path/to/bearer/token/file ]
tls_config:
  [ &lt;tls_config&gt; ]
[ proxy_url: &lt;string&gt; ]</code></pre> 
 <h6 id="remote_write">remote_write</h6> 
 <pre class="has"><code>url: &lt;string&gt;

[ remote_timeout: &lt;duration&gt; | default = 30s ]

#写入数据时候进行标签过滤
write_relabel_configs:
  [ - &lt;relabel_config&gt; ... ]

basic_auth:
  [ username: &lt;string&gt; ]
  [ password: &lt;string&gt; ]
  [ password_file: &lt;string&gt; ]

[ bearer_token: &lt;string&gt; ]

[ bearer_token_file: /path/to/bearer/token/file ]

tls_config:
  [ &lt;tls_config&gt; ]

[ proxy_url: &lt;string&gt; ]

#远端写细粒度配置，这里暂时仅仅列出官方注释
queue_config:
  # Number of samples to buffer per shard before we start dropping them.
  [ capacity: &lt;int&gt; | default = 10000 ]
  # Maximum number of shards, i.e. amount of concurrency.
  [ max_shards: &lt;int&gt; | default = 1000 ]
  # Maximum number of samples per send.
  [ max_samples_per_send: &lt;int&gt; | default = 100]
  # Maximum time a sample will wait in buffer.
  [ batch_send_deadline: &lt;duration&gt; | default = 5s ]
  # Maximum number of times to retry a batch on recoverable errors.
  [ max_retries: &lt;int&gt; | default = 3 ]
  # Initial retry delay. Gets doubled for every retry.
  [ min_backoff: &lt;duration&gt; | default = 30ms ]
  # Maximum retry delay.
  [ max_backoff: &lt;duration&gt; | default = 100ms ]</code></pre> 
 <h4 id="参考文档">参考文档</h4> 
 <p><a href="https://blog.csdn.net/k_young1997/article/details/126369983" target="_blank" rel="noopener noopener noreferrer">Prometheus 配置详解</a></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/323f19349a3bbb3df25d7a873bbf901f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vscode配置prettier格式化工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d24c0067c94b1d84eb618b5c3239688a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql 查看锁表信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>