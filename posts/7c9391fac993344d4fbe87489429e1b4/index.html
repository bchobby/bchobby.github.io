<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32中文手册解读（1） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32中文手册解读（1）" />
<meta property="og:description" content="STM32中文手册的阅读 初学stm32，读手册是十分重要的。由于买了野火的开发板，最近也在学习，所以记录下学习的内容。
关于寄存器的描述：
首先对于STM32芯片基础知识的了解
STM32 芯片是已经封装好的成品，主要由内核和片上外设组成。若与电脑类比，内核与外设就如同电脑上的 CPU 与主板、内存、显卡、硬盘的关系。
STM32F103 采用的是 Cortex-M3 内核，内核即 CPU，由 ARM 公司设计。ARM 公司并不生产芯片，而是出售其芯片技术授权。芯片生产厂商(SOC)如 ST、TI、Freescale，负责在内核之外设计部件并生产整个芯片，这些内核之外的部件被称为核外外设或片上外设。如 GPIO、USART（串口）、I2C、SPI 等都叫做片上外设。
芯片（这里指内核，或者叫 CPU）和外设之间通过各种总线连接，其中驱动单元有 4个，被动单元也有 4 个，为了方便理解，我们都可以把驱动单元理解成是CPU 部分，被动单元都理解成外设。
1. ICode 总线
ICode 中的 I 表示 Instruction，即指令。我们写好的程序编译之后都是一条条指令，存放在 FLASH 中，内核要读取这些指令来执行程序就必须通过 ICode 总线，它几乎每时每刻都需要被使用，它是专门用来取指的。
2. 驱动单元
DCode 总线
DCode 中的 D 表示 Data，即数据，那说明这条总线是用来取数的。我们在写程序的时候，数据有常量和变量两种，常量就是固定不变的，用 C 语言中的 const 关键字修饰，是放到内部的 FLASH 当中的，变量是可变的，不管是全局变量还是局部变量都放在内部的SRAM。因为数据可以被 Dcode 总线和 DMA 总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。
系统总线
系统总线主要是访问外设的寄存器，我们通常说的寄存器编程，即读写寄存器都是通过这根系统总线来完成的。
DMA 总线
DMA 总线也主要是用来传输数据，这个数据可以是在某个外设的数据寄存器，可以在SRAM，可以在内部的 FLASH。因为数据可以被 Dcode 总线和 DMA 总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。
3. 被动单元" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/7c9391fac993344d4fbe87489429e1b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-08T15:35:53+08:00" />
<meta property="article:modified_time" content="2023-04-08T15:35:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32中文手册解读（1）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="STM32_0"></a><strong>STM32中文手册的阅读</strong></h3> 
<p>初学stm32，读手册是十分重要的。由于买了野火的开发板，最近也在学习，所以记录下学习的内容。<br> <strong>关于寄存器的描述：</strong><br> 首先对于<strong>STM32芯片基础知识</strong>的了解<br> STM32 芯片是已经封装好的成品，主要由内核和片上外设组成。若与电脑类比，内核与外设就如同电脑上的 CPU 与主板、内存、显卡、硬盘的关系。<br> STM32F103 采用的是 Cortex-M3 内核，内核即 CPU，由 ARM 公司设计。ARM 公司并不生产芯片，而是出售其芯片技术授权。芯片生产厂商(SOC)如 ST、TI、Freescale，负责在内核之外设计部件并生产整个芯片，这些内核之外的部件被称为核外外设或片上外设。如 GPIO、USART（串口）、I2C、SPI 等都叫做片上外设。<br> 芯片（这里指内核，或者叫 CPU）和外设之间通过各种总线连接，其中驱动单元有 4个，被动单元也有 4 个，为了方便理解，我们都可以把驱动单元理解成是CPU 部分，被动单元都理解成外设。</p> 
<p><strong>1. ICode 总线</strong><br> ICode 中的 I 表示 Instruction，即指令。我们写好的程序编译之后都是一条条指令，存放在 FLASH 中，内核要读取这些指令来执行程序就必须通过 ICode 总线，它几乎每时每刻都需要被使用，它是专门用来取指的。</p> 
<p><strong>2. 驱动单元<br> DCode 总线</strong><br> DCode 中的 D 表示 Data，即数据，那说明这条总线是用来取数的。我们在写程序的时候，数据有常量和变量两种，常量就是固定不变的，用 C 语言中的 const 关键字修饰，是放到内部的 FLASH 当中的，变量是可变的，不管是全局变量还是局部变量都放在内部的SRAM。因为数据可以被 Dcode 总线和 DMA 总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。</p> 
<p><strong>系统总线</strong><br> 系统总线主要是访问外设的寄存器，我们通常说的寄存器编程，即读写寄存器都是通过这根系统总线来完成的。</p> 
<p><strong>DMA 总线</strong><br> DMA 总线也主要是用来传输数据，这个数据可以是在某个外设的数据寄存器，可以在SRAM，可以在内部的 FLASH。因为数据可以被 Dcode 总线和 DMA 总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。</p> 
<p><strong>3. 被动单元<br> 内部的闪存存储器</strong><br> 内部的闪存存储器即 FLASH，我们编写好的程序就放在这个地方。内核通过 ICode 总线来取里面的指令。<br> <strong>内部的 SRAM</strong><br> 内部的 SRAM，即我们通常说的 RAM，程序的变量，堆栈等的开销都是基于内部的SRAM。内核通过 DCode 总线来访问它。<br> <strong>FSMC</strong><br> FSMC 的英文全称是 Flexible static memory controller，叫灵活的静态的存储器控制器，是STM32F10xx 中一个很有特色的外设，通过 FSMC，我们可以扩展内存，如外部的SRAM，NANDFLASH NORFLASH。但有一点我们要注意的是，FSMC 只能扩展静态的内存，即名称里面的 S：static，不能是动态的内存，比如 SDRAM 就不能扩展。<br> <strong>AHB 到 APB 的桥</strong><br> 从 AHB 总线延伸出来的两条 APB2 和 APB1 总线，上面挂载着 STM32 各种各样的特色外设。我们经常说的 GPIO、串口、I2C、SPI 这些外设就挂载在这两条总线上，这个是我们学习 STM32 的重点，就是要学会编程这些外设去驱动外部的各种设备。</p> 
<p><strong>存储器映射</strong><br> 被控单元的 FLASH，RAM，FSMC 和 AHB 到 APB 的桥（即片上外设），这些功能部件共同排列在一个 4GB 的地址空间内。我们在编程的时候，可以通过他们的地址找到他们，然后来操作他们（通过 C 语言对它们进行数据的读和写）。<br> 存储器本身不具有地址信息，它的地址是由芯片厂商或用户分配，给存储器分配地址的过程就称为存储器映射。如果给存储器再分配一个地址就叫存储器重映射。</p> 
<p><strong>存储器功能分类</strong><br> 序号 用途 地址范围<br> Block 0 Code 0x0000 0000 ~ 0x1FFF FFFF(512MB)<br> Block 1 SRAM 0x2000 0000 ~ 0x3FFF FFFF(512MB)<br> Block 2 片上外设 0x4000 0000 ~ 0x5FFF FFFF(512MB)<br> Block 3 FSMC 的 bank1 ~ bank2 0x6000 0000 ~ 0x7FFF FFFF(512MB)<br> Block 4 FSMC 的 bank3 ~ bank4 0x8000 0000 ~ 0x9FFF FFFF(512MB)<br> Block 5 FSMC 寄存器 0xA000 0000 ~ 0xCFFF FFFF(512MB)<br> Block 6 没有使用 0xD000 0000 ~ 0xDFFF FFFF(512MB)<br> Block 7 Cortex-M3 内部外设 0xE000 0000 ~ 0xFFFF FFFF(512MB)</p> 
<p>在这 8 个 Block 里面，有 3 个块非常重要，也是我们最关心的三个块。Block0 用来设计成内部FLASH，Block1 用来设计成内部 RAM，Block2 用来设计成片上的外设，下面我们简单的介绍下这三个 Block 里面的具体区域的功能划分。</p> 
<p><strong>存储器 Block0 内部区域功能划分</strong><br> Block0 主要用于设计片内的 FLASH，我们使用的 STM32F103ZET6（霸道）和STM32F103VET6（指南者）的 FLASH 都是 512KB，属于大容量。要在芯片内部集成更大的 FLASH 或者 SRAM 都意味着芯片成本的增加，往往片内集成的 FLASH 都不会太大，ST 能在追求性价比的同时做到 512KB，实乃良心之举。<br> Block 内部区域的功能划分具体见表格 6-2<br> 存储器 Block0 内部区域功能划分<br> 块 用途说明 地址范围<br> 预留 0x1FFE C008 ~ 0x1FFF FFFF<br> 选项字节： 用 于 配 置 读 写 保 护 、 0x1FFF F800 - 0x1FFF F80F<br> BOR 级别、软件/硬件看门狗以及器<br> 件处于待机或停止模式下的复位。当<br> 芯片不小心被锁住之后，我们可以从<br> RAM 里面启动来修改这部分相应的寄<br> 存器位。<br> Block0 系统存储器：里面存的是 ST 出厂时 0x1FFF F000- 0x1FFF F7FF<br> 烧 写 好 的 isp 自 举 程 序 （ 即<br> Bootloader），用户无法改动。串口<br> 下载的时候需要用到这部分程序。<br> 预留 0x0808 0000 ~ 0x1FFF EFFF<br> FLASH：我们的程序就放在这里。 0x0800 0000 ~ 0x0807 FFFF (512KB)<br> 预留 0x0008 0000 ~ 0x07FF FFFF<br> 取决于 BOOT 引脚，为 FLASH、系 0x0000 0000 ~ 0x0007 FFFF<br> 统存储器、SRAM 的别名。</p> 
<p><strong>储存器 Block1 内部区域功能划分</strong><br> Block1 用 于 设 计 片 内 的 SRAM 。 我 们 使 用 的 STM32F103ZET6 （ 霸 道 ） 和<br> STM32F103VET6（指南者）的 SRAM 都是 64KB，Block 内部区域的功能划分具体见表格<br> 6-3。<br> 块 用途说明 地址范围<br> Block1 预留 0x2001 0000 ~ 0x3FFF FFFF<br> SRAM 64KB 0x2000 0000 ~0x2000 FFFF</p> 
<p><strong>储存器 Block2 内部区域功能划分</strong><br> Block2 用于设计片内的外设，根据外设的总线速度不同，Block 被分成了 APB 和 AHB<br> 两部分，其中 APB 又被分为 APB1 和 APB2，具体见表格 6-4。<br> 表格 6-4 存储器 Block2 内部区域功能划分<br> 块 用途说明 地址范围<br> APB1 总线外设 0x4000 0000 ~ 0x4000 77FF<br> Block2 APB2 总线外设 0x4001 0000 ~ 0x4001 3FFF<br> AHB 总线外设 0x4001 8000 ~ 0x5003 FFFF</p> 
<p><strong>寄存器映射</strong><br> 我们知道，存储器本身没有地址，给存储器分配地址的过程叫存储器映射，那什么叫<br> 寄存器映射？寄存器到底是什么？<br> 在存储器 Block2 这块区域，设计的是片上外设，它们以四个字节为一个单元，共<br> 32bit，每一个单元对应不同的功能，当我们控制这些单元时就可以驱动外设工作。我们可<br> 以找到每个单元的起始地址，然后通过 C 语言指针的操作方式来访问这些单元，如果每次<br> 都是通过这种地址的方式来访问，不仅不好记忆还容易出错，这时我们可以根据每个单元<br> 功能的不同，以功能为名给这个内存单元取一个别名，这个别名就是我们经常说的寄存器，<br> 这个给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射。</p> 
<p><strong>代码 6-1 通过绝对地址访问内存单元</strong><br> 1 // GPIOB 端口全部输出 高电平<br> 2 <em>(unsigned int</em>)(0x4001 0C0C) = 0xFFFF;</p> 
<p>0x4001 0C0C 在我们看来是 GPIOB 端口 ODR 的地址，但是在编译器看来，这只是一<br> 个普通的变量，是一个立即数，要想让编译器也认为是指针，我们得进行强制类型转换，<br> 把它转换成指针，即(unsigned int *)0x4001 0C0C，然后再对这个指针进行 * 操作。</p> 
<p>刚刚我们说了，通过绝对地址访问内存单元不好记忆且容易出错，我们可以通过寄存<br> 器的方式来操作。<br> <strong>代码 6-2 通过寄存器别名访问内存单元</strong><br> 1 // GPIOB 端口全部输出 高电平<br> 2 #define GPIOB_ODR <em>(unsigned int</em>)(GPIOB_BASE+0x0C)<br> 3 GPIOB_ODR = 0xFF;</p> 
<p><strong>STM32 的外设地址映射</strong><br> 片上外设区分为三条总线，根据外设速度的不同，不同总线挂载着不同的外设，APB1<br> 挂载低速外设，APB2 和 AHB 挂载高速外设。相应总线的最低地址我们称为该总线的基地<br> 址，总线基地址也是挂载在该总线上的首个外设的地址。其中 APB1 总线的地址最低，片<br> 上外设从这里开始，也叫外设基地址。</p> 
<p><strong>总线基地址</strong><br> 总线名称 总线基地址 相对外设基地址的偏移<br> APB1 0x4000 0000 0x0<br> APB2 0x4001 0000 0x0001 0000<br> AHB 0x4001 8000 0x0001 8000<br> “相对外设基地址偏移”即该总线地址与“片上外设”基地址 0x4000 0000的差值。</p> 
<p><strong>外设基地址</strong><br> 总线上挂载着各种外设，这些外设也有自己的地址范围，特定外设的首个地址称为<br> “XX 外设基地址”，也叫 XX 外设的边界地址。具体有关 STM32F10xx 外设的边界地址<br> 请参考《STM32F10xx 参考手册》的 2.3 小节的存储器映射的表 1：STM32F10xx 寄存器边<br> 界地址。<br> 这里面我们以 GPIO 这个外设来讲解外设的基地址，GPIO 属于高速的外设 ，挂载到<br> APB2 总线上，具体见表格 6-6。<br> 表格 6-6 外设 GPIO 基地址<br> 外设名称 外设基地址 相对 APB2 总线的地址偏移<br> GPIOA 0x4001 0800 0x0000 0800<br> GPIOB 0x4001 0C00 0x0000 0C00<br> GPIOC 0x4001 1000 0x0000 1000<br> GPIOD 0x4001 1400 0x0000 1400<br> GPIOE 0x4001 1800 0x0000 1800<br> GPIOF 0x4001 1C00 0x0000 1C00<br> GPIOG 0x4001 2000 0x0000 2000</p> 
<p><strong>外设寄存器</strong><br> 在 XX 外设的地址范围内，分布着的就是该外设的寄存器。以 GPIO 外设为例，GPIO<br> 是<strong>通用输入输出端口</strong>的简称，简单来说就是 STM32 可控制的引脚，基本功能是控制引脚输<br> 出高电平或者低电平。最简单的应用就是把 GPIO 的引脚连接到 LED 灯的阴极，LED 灯的<br> 阳极接电源，然后通过 STM32 控制该引脚的电平，从而实现控制 LED 灯的亮灭。<br> GPIO 有很多个寄存器，每一个都有特定的功能。每个寄存器为 32bit，占四个字节，<br> 在该外设的基地址上按照顺序排列，寄存器的位置都以相对该外设基地址的偏移地址来描述。<br> 表格 6-7 GPIOB 端口的 寄存器地址列表<br> 寄存器名称 寄存器地址 相对 GPIOB 基址的偏移<br> GPIOB_CRL 0x4001 0C00 0x00<br> GPIOB_CRH 0x4001 0C04 0x04<br> GPIOB_IDR 0x4001 0C08 0x08<br> GPIOB_ODR 0x4001 0C0C 0x0C<br> GPIOH_BSRR 0x4001 0C10 0x10<br> GPIOH_BRR 0x4001 0C14 0x14<br> GPIOH_LCKR 0x4001 0C18 0x18</p> 
<p><strong>①名称</strong><br> 寄存器说明中首先列出了该寄存器中的名称，“(GPIOx_BSRR)(x=A…E)”这段的意<br> 思是该寄存器名为“GPIOx_BSRR”其中的“x”可以为 A-E，也就是说这个寄存器说明适<br> 用于 GPIOA、GPIOB 至 GPIOE，这些 GPIO 端口都有这样的一个寄存器。<br> <strong>②偏移地址</strong><br> 偏移地址是指本寄存器相对于这个外设的基地址的偏移。本寄存器的偏移地址是 0x18，<br> 从参考手册中我们可以查到 GPIOA 外设的基地址为 0x4001 0800 ，我们就可以算出<br> GPIOA 的这个 GPIOA_BSRR 寄存器的地址为：0x4001 0800+0x18 ；同理，由于 GPIOB 的<br> 外设基地址为 0x4001 0C00，可算出 GPIOB_BSRR 寄存器的地址为：0x4001 0C00+0x18 。<br> 其他 GPIO 端口以此类推即可。<br> <strong>③寄存器位表</strong><br> 紧接着的是本寄存器的位表，表中列出它的 0-31 位的名称及权限。表上方的数字为位<br> 编号，中间为位名称，最下方为读写权限，其中 w 表示只写，r 表示只读，rw 表示可读写。<br> 本寄存器中的位权限都是 w，所以只能写，如果读本寄存器，是无法保证读取到它真正内<br> 容的。而有的寄存器位只读，一般是用于表示 STM32 外设的某种工作状态的，由 STM32<br> 硬件自动更改，程序通过读取那些寄存器位来判断外设的工作状态。<br> <strong>④位功能说明</strong><br> 位功能是寄存器说明中最重要的部分，它详细介绍了寄存器每一个位的功能。例如本<br> 寄存器中有两种寄存器位，分别为 BRy 及 BSy，其中的 y 数值可以是 0-15，这里的 0-15<br> 表示端口的引脚号，如 BR0、BS0 用于控制 GPIOx 的第 0 个引脚，若 x 表示 GPIOA，那就<br> 是控制 GPIOA 的第 0 引脚，而 BR1、BS1 就是控制 GPIOA 第 1 个引脚。<br> 其中 BRy 引脚的说明是“0：不会对相应的 ODRx 位执行任何操作；1：对相应 ODRx<br> 位进行复位”。这里的“复位”是将该位设置为 0 的意思，而“置位”表示将该位设置为<br> 1；说明中的 ODRx 是另一个寄存器的寄存器位，我们只需要知道 ODRx 位为 1 的时候，<br> 对应的引脚 x 输出高电平，为 0 的时候对应的引脚输出低电平即可(感兴趣的读者可以查询<br> 该寄存器 GPIOx_ODR 的说明了解)。所以，如果对 BR0 写入“1”的话，那么 GPIOx 的第<br> 0 个引脚就会输出“低电平”，但是对 BR0 写入“0”的话，却不会影响 ODR0 位，所以引<br> 脚电平不会改变。要想该引脚输出“高电平”，就需要对“BS0”位写入“1”，寄存器位<br> BSy 与 BRy 是相反的操作。</p> 
<p><em><strong>重点部分</strong></em><br> <strong>封装总线和外设基地址</strong><br> 在编程上为了方便理解和记忆，我们把总线基地址和外设基地址都以相应的宏定义起<br> 来，总线或者外设都以他们的名字作为宏名，具体见代码</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">/* 外设基地址 */</span>
<span class="token number">2</span> #define <span class="token function">PERIPH_BASE</span>                               <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">0x40000000</span><span class="token punctuation">)</span>
<span class="token number">3</span> 
<span class="token number">4</span> <span class="token comment">/* 总线基地址 */</span>
<span class="token number">5</span> #define APB1PERIPH_BASE                            PERIPH_BASE
<span class="token number">6</span> #define <span class="token function">APB2PERIPH_BASE</span>                            <span class="token punctuation">(</span>PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x00010000</span><span class="token punctuation">)</span>
<span class="token number">7</span> #define <span class="token function">AHBPERIPH_BASE</span>                             <span class="token punctuation">(</span>PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x00020000</span><span class="token punctuation">)</span>
<span class="token number">8</span> 
<span class="token number">9</span> 
<span class="token number">10</span> <span class="token comment">/* GPIO 外设基地址 */</span>
<span class="token number">11</span> #define <span class="token function">GPIOA_BASE</span>                                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x0800</span><span class="token punctuation">)</span>
<span class="token number">12</span> #define <span class="token function">GPIOB_BASE</span>                                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x0C00</span><span class="token punctuation">)</span>
<span class="token number">13</span> #define <span class="token function">GPIOC_BASE</span>                                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1000</span><span class="token punctuation">)</span>
<span class="token number">14</span> #define <span class="token function">GPIOD_BASE</span>                                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1400</span><span class="token punctuation">)</span>
<span class="token number">15</span> #define <span class="token function">GPIOE_BASE</span>                                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1800</span><span class="token punctuation">)</span>
<span class="token number">16</span> #define <span class="token function">GPIOF_BASE</span>                                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1C00</span><span class="token punctuation">)</span>
<span class="token number">17</span> #define <span class="token function">GPIOG_BASE</span>                                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x2000</span><span class="token punctuation">)</span>
<span class="token number">18</span> 
<span class="token number">19</span> 
<span class="token number">20</span> <span class="token comment">/* 寄存器基地址，以 GPIOB 为例 */</span>
<span class="token number">21</span> #define <span class="token function">GPIOB_CRL</span>                                 <span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x00</span><span class="token punctuation">)</span>
<span class="token number">22</span> #define <span class="token function">GPIOB_CRH</span>                                 <span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x04</span><span class="token punctuation">)</span>
<span class="token number">23</span> #define <span class="token function">GPIOB_IDR</span>                                 <span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x08</span><span class="token punctuation">)</span>
<span class="token number">24</span> #define <span class="token function">GPIOB_ODR</span>                                 <span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x0C</span><span class="token punctuation">)</span>
<span class="token number">25</span> #define <span class="token function">GPIOB_BSRR</span>                                <span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x10</span><span class="token punctuation">)</span>
<span class="token number">26</span> #define <span class="token function">GPIOB_BRR</span>                                 <span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x14</span><span class="token punctuation">)</span>
<span class="token number">27</span> #define <span class="token function">GPIOB_LCKR</span>                                <span class="token punctuation">(</span>GPIOB_BASE<span class="token operator">+</span><span class="token number">0x18</span><span class="token punctuation">)</span>
</code></pre> 
<p>首先定义了 “片上外设”基地址 PERIPH_BASE，接着在 PERIPH_BASE 上<br> 加入各个总线的地址偏移，得到 APB1、APB2 总线的地址 APB1PERIPH_BASE、<br> APB2PERIPH_BASE，在其之上加入外设地址的偏移，得到 GPIOA-G 的外设地址，最后在<br> 外设地址上加入各寄存器的地址偏移，得到特定寄存器的地址。一旦有了具体地址，就可<br> 以用指针读写。使用指针控制 BSRR 寄存器。</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">/* 控制 GPIOB 引脚 0 输出低电平(BSRR 寄存器的 BR0 置 1) */</span>
<span class="token number">2</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>GPIOB_BSRR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0x01</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">3</span> 
<span class="token number">4</span> <span class="token comment">/* 控制 GPIOB 引脚 0 输出高电平(BSRR 寄存器的 BS0 置 1) */</span>
<span class="token number">5</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>GPIOB_BSRR <span class="token operator">=</span> <span class="token number">0x01</span><span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">6</span> 
<span class="token number">7</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
<span class="token number">8</span> <span class="token comment">/* 读取 GPIOB 端口所有引脚的电平(读 IDR 寄存器) */</span>
<span class="token number">9</span> temp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>GPIOB_IDR<span class="token punctuation">;</span>
</code></pre> 
<p>该代码使用 (unsigned int <em>) 把 GPIOB_BSRR 宏的数值强制转换成了地址，然后再用<br> “</em>”号做取指针操作，对该地址的赋值，从而实现了写寄存器的功能。同样，读寄存器也<br> 是用取指针操作，把寄存器中的数据取到变量里，从而获取 STM32 外设的状态。</p> 
<p><strong>封装寄存器列表</strong><br> 用上面的方法去定义地址，还是稍显繁琐，例如 GPIOA-GPIOE 都各有一组功能相同<br> 的寄存器，如 GPIOA_ODR/GPIOB_ODR/GPIOC_ODR 等等，它们只是地址不一样，但却<br> 要为每个寄存器都定义它的地址。为了更方便地访问寄存器，我们引入 C 语言中的结构体<br> 语法对寄存器进行封装，具体代码如下</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">uint32_t</span><span class="token punctuation">;</span> <span class="token comment">/*无符号 32 位变量*/</span>
<span class="token number">2</span> <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token class-name">uint16_t</span><span class="token punctuation">;</span> <span class="token comment">/*无符号 16 位变量*/</span>
<span class="token number">3</span> 
<span class="token number">4</span> <span class="token comment">/* GPIO 寄存器列表 */</span>
<span class="token number">5</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">6</span> <span class="token class-name">uint32_t</span> CRL<span class="token punctuation">;</span>                <span class="token comment">/*GPIO 端口配置低寄存器 地址偏移: 0x00 */</span>
<span class="token number">7</span> <span class="token class-name">uint32_t</span> CRH<span class="token punctuation">;</span>                <span class="token comment">/*GPIO 端口配置高寄存器 地址偏移: 0x04 */</span>
<span class="token number">8</span> <span class="token class-name">uint32_t</span> IDR<span class="token punctuation">;</span>                <span class="token comment">/*GPIO 数据输入寄存器 地址偏移: 0x08 */</span>
<span class="token number">9</span> <span class="token class-name">uint32_t</span> ODR<span class="token punctuation">;</span>                <span class="token comment">/*GPIO 数据输出寄存器 地址偏移: 0x0C */</span>
<span class="token number">10</span> <span class="token class-name">uint32_t</span> BSRR<span class="token punctuation">;</span>              <span class="token comment">/*GPIO 位设置/清除寄存器 地址偏移: 0x10 */</span>
<span class="token number">11</span> <span class="token class-name">uint32_t</span> BRR<span class="token punctuation">;</span>               <span class="token comment">/*GPIO 端口位清除寄存器 地址偏移: 0x14 */</span>
<span class="token number">12</span> <span class="token class-name">uint16_t</span> LCKR<span class="token punctuation">;</span>              <span class="token comment">/*GPIO 端口配置锁定寄存器 地址偏移: 0x18 */</span>
<span class="token punctuation">}</span> GPIO_TypeDef<span class="token punctuation">;</span>
</code></pre> 
<p>这段代码用 typedef 关键字声明了名为 GPIO_TypeDef 的结构体类型，结构体内有 7 个<br> 成员变量，变量名正好对应寄存器的名字。<br> C 语言的语法规定，结构体内变量的存储空间<br> 是连续的，其中 32 位的变量占用 4 个字节，16 位的变量占用 2 个字节。<br> 也就是说，我们定义的这个 GPIO_TypeDef ，假如这个结构体的首地址为 0x4001<br> 0C00（这也是第一个成员变量 CRL 的地址）， 那么结构体中第二个成员变量 CRH 的地址<br> 即为 0x4001 0C00 +0x04 ，加上的这个 0x04 ，正是代表 CRL 所占用的 4 个字节地址的偏<br> 移量，其它成员变量相对于结构体首地址的偏移，在上述代码右侧注释已给。<br> 这样的地址偏移与 STM32 GPIO 外设定义的寄存器地址偏移一一对应，只要给结构体<br> 设置好首地址，就能把结构体内成员的地址确定下来，然后就能以结构体的形式访问寄存<br> 器。</p> 
<p><strong>通过结构体指针访问寄存器</strong></p> 
<pre><code class="prism language-c"><span class="token number">1</span> GPIO_TypeDef <span class="token operator">*</span> GPIOx<span class="token punctuation">;</span> <span class="token comment">//定义一个 GPIO_TypeDef 型结构体指针 GPIOx</span>
<span class="token number">2</span> GPIOx <span class="token operator">=</span> GPIOB_BASE<span class="token punctuation">;</span> <span class="token comment">//把指针地址设置为宏 GPIOH_BASE 地址</span>
<span class="token number">3</span> GPIOx<span class="token operator">-&gt;</span>IDR <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span> 
<span class="token number">4</span> GPIOx<span class="token operator">-&gt;</span>ODR <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span> 
<span class="token number">5</span> 
<span class="token number">6</span> 
<span class="token number">7</span> <span class="token class-name">uint32_t</span> temp<span class="token punctuation">;</span>
<span class="token number">8</span> temp <span class="token operator">=</span> GPIOx<span class="token operator">-&gt;</span>IDR<span class="token punctuation">;</span> <span class="token comment">//读取 GPIOB_IDR 寄存器的值到变量 temp 中</span>
</code></pre> 
<p>这段代码先用 GPIO_TypeDef 类型定义一个结构体指针 GPIOx，并让指针指向地址<br> GPIOB_BASE(0x4001 0C00)，使用地址确定下来，然后根据 C 语言访问结构体的语法，用<br> GPIOx-&gt;ODR 及 GPIOx-&gt;IDR 等方式读写寄存器。</p> 
<p>最后，我们更进一步，直接使用宏定义好 GPIO_TypeDef 类型的指针，而且指针指向<br> 各个 GPIO 端口的首地址，使用时我们直接用该宏访问寄存器即可<br> <strong>定义好 GPIO 端口首地址址针</strong></p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">/*使用 GPIO_TypeDef 把地址强制转换成指针*/</span>
<span class="token number">2</span> #define <span class="token function">GPIOA</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOA_BASE<span class="token punctuation">)</span>
<span class="token number">3</span> #define <span class="token function">GPIOB</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOB_BASE<span class="token punctuation">)</span>
<span class="token number">4</span> #define <span class="token function">GPIOC</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOC_BASE<span class="token punctuation">)</span>
<span class="token number">5</span> #define <span class="token function">GPIOD</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOD_BASE<span class="token punctuation">)</span>
<span class="token number">6</span> #define <span class="token function">GPIOE</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOE_BASE<span class="token punctuation">)</span>
<span class="token number">7</span> #define <span class="token function">GPIOF</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOF_BASE<span class="token punctuation">)</span>
<span class="token number">8</span> #define <span class="token function">GPIOG</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOG_BASE<span class="token punctuation">)</span>
<span class="token number">9</span> #define <span class="token function">GPIOH</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOH_BASE<span class="token punctuation">)</span>
<span class="token number">10</span> 
<span class="token number">11</span> 
<span class="token number">12</span> 
<span class="token number">13</span> <span class="token comment">/*使用定义好的宏直接访问*/</span>
<span class="token number">14</span> <span class="token comment">/*访问 GPIOB 端口的寄存器*/</span>
<span class="token number">15</span> GPIOB<span class="token operator">-&gt;</span>BSRR <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span> <span class="token comment">//通过指针访问并修改 GPIOB_BSRR 寄存器</span>
<span class="token number">16</span> GPIOB<span class="token operator">-&gt;</span>CRL <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span> <span class="token comment">//修改 GPIOB_CRL 寄存器</span>
<span class="token number">17</span> GPIOB<span class="token operator">-&gt;</span>ODR <span class="token operator">=</span><span class="token number">0xFFFF</span><span class="token punctuation">;</span> <span class="token comment">//修改 GPIOB_ODR 寄存器</span>
<span class="token number">18</span> 
<span class="token number">19</span> <span class="token class-name">uint32_t</span> temp<span class="token punctuation">;</span>
<span class="token number">20</span> temp <span class="token operator">=</span> GPIOB<span class="token operator">-&gt;</span>IDR<span class="token punctuation">;</span> <span class="token comment">//读取 GPIOB_IDR 寄存器的值到变量 temp 中</span>
<span class="token number">21</span> 
<span class="token number">22</span> <span class="token comment">/*访问 GPIOA 端口的寄存器*/</span>
<span class="token number">23</span> GPIOA<span class="token operator">-&gt;</span>BSRR <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>  <span class="token comment">//通过指针访问并修改GPIOA_BSRR寄存器</span>
<span class="token number">24</span> GPIOA<span class="token operator">-&gt;</span>CRL <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>   <span class="token comment">//修改GPIOA_CRL寄存器</span>
<span class="token number">25</span> GPIOA<span class="token operator">-&gt;</span>ODR <span class="token operator">=</span><span class="token number">0xFFFF</span><span class="token punctuation">;</span>    <span class="token comment">//修改GPIOA_odr寄存器</span>
<span class="token number">26</span> 
<span class="token number">27</span> <span class="token class-name">uint32_t</span> temp<span class="token punctuation">;</span>
<span class="token number">28</span> temp <span class="token operator">=</span> GPIOA<span class="token operator">-&gt;</span>IDR<span class="token punctuation">;</span> <span class="token comment">//读取 GPIOA_IDR 寄存器的值到变量 temp 中</span>
</code></pre> 
<p><strong>修改寄存器的位操作方法</strong><br> 使用 C 语言对寄存器赋值时，我们常常要求只修改该寄存器的某几位的值，且其它的<br> 寄存器位不变，这个时候我们就需要用到 C 语言的位操作方法了。<br> <strong>1. 把变量的某位清零</strong><br> 此处我们以变量 a 代表寄存器，并假设寄存器中本来已有数值，此时我们需要把变量<br> a 的某一位清零，且其它位不变，方法见代码清单 6-1。<br> 代码清单 6-1 对某位清零</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">//定义一个变量 a = 1001 1111 b (二进制数)</span>
<span class="token number">2</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">0x9f</span><span class="token punctuation">;</span>
<span class="token number">3</span> 
<span class="token number">4</span> <span class="token comment">//对 bit2 清零</span>
<span class="token number">5</span> 
<span class="token number">6</span> a <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">7</span> 
<span class="token number">8</span> <span class="token comment">//括号中的 1 左移两位，(1&lt;&lt;2)得二进制数：0000 0100 b</span>
<span class="token number">9</span> <span class="token comment">//按位取反，~(1&lt;&lt;2)得 1111 1011 b</span>
<span class="token number">10</span> <span class="token comment">//假如 a 中原来的值为二进制数： a = 1001 1111 b</span>
<span class="token number">11</span> <span class="token comment">//所得的数与 a 作”位与&amp;”运算，a = (1001 1111 b)&amp;(1111 1011 b),</span>
<span class="token number">12</span> <span class="token comment">//经过运算后，a 的值 a=1001 1011 b</span>
<span class="token number">13</span> <span class="token comment">// a 的 bit2 位被被零，而其它位不变。</span>
</code></pre> 
<p><strong>把变量的某几个连续位清零</strong><br> 由于寄存器中有时会有连续几个寄存器位用于控制某个功能，现假设我们需要把寄存<br> 器的某几个连续位清零，且其它位不变，方法见代码清单 6-2。<br> 代码清单 6-2 对某几个连续位清零</p> 
<pre><code class="prism language-c"><span class="token number">1</span> 
<span class="token number">2</span> <span class="token comment">//若把 a 中的二进制位分成 2 个一组</span>
<span class="token number">3</span> <span class="token comment">//即 bit0、bit1 为第 0 组，bit2、bit3 为第 1 组，</span>
<span class="token number">4</span> <span class="token comment">// bit4、bit5 为第 2 组，bit6、bit7 为第 3 组</span>
<span class="token number">5</span> <span class="token comment">//要对第 1 组的 bit2、bit3 清零</span>
<span class="token number">6</span> 
<span class="token number">7</span> a <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">8</span> 
<span class="token number">9</span> <span class="token comment">//括号中的 3 左移两位，(3&lt;&lt;2*1)得二进制数：0000 1100 b</span>
<span class="token number">10</span> <span class="token comment">//按位取反，~(3&lt;&lt;2*1)得 1111 0011 b</span>
<span class="token number">11</span> <span class="token comment">//假如 a 中原来的值为二进制数： a = 1001 1111 b</span>
<span class="token number">12</span> <span class="token comment">//所得的数与 a 作”位与&amp;”运算，a = (1001 1111 b)&amp;(1111 0011 b),</span>
<span class="token number">13</span> <span class="token comment">//经过运算后，a 的值 a=1001 0011 b</span>
<span class="token number">14</span> <span class="token comment">// a 的第 1 组的 bit2、bit3 被清零，而其它位不变。</span>
<span class="token number">15</span> 
<span class="token number">16</span> <span class="token comment">//上述(~(3&lt;&lt;2*1))中的(1)即为组编号;如清零第 3 组 bit6、bit7 此处应为 3</span>
<span class="token number">17</span> <span class="token comment">//括号中的(2)为每组的位数，每组有 2 个二进制位;若分成 4 个一组，此处即为 4</span>
<span class="token number">18</span> <span class="token comment">//括号中的(3)是组内所有位都为 1 时的值;若分成 4 个一组，此处即为二进制数“1111 b”</span>
<span class="token number">19</span> 
<span class="token number">20</span> <span class="token comment">//例如对第 2 组 bit4、bit5 清零</span>
<span class="token number">21</span> a <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>对变量的某几位进行赋值。</strong><br> 寄存器位经过上面的清零操作后，接下来就可以方便地对某几位写入所需要的数值了，<br> 且其它位不变，方法见代码清单 6-3，这时候写入的数值一般就是需要设置寄存器的位参<br> 数。<br> 代码清单 6-3 对某几位进行赋值</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">//a = 1000 0011 b</span>
<span class="token number">2</span> <span class="token comment">//此时对清零后的第 2 组 bit4、bit5 设置成二进制数“01 b ”</span>
<span class="token number">3</span> 
<span class="token number">4</span> a <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token comment">//a = 1001 0011 b，成功设置了第 2 组的值，其它组不变</span>
</code></pre> 
<p><strong>对变量的某位取反</strong><br> 某些情况下，我们需要对寄存器的某个位进行取反操作，即 1 变 0 ，0 变 1，这可以直<br> 接用如下操作，其它位不变，见代码清单 6-4。<br> 代码清单 6-4 对某位进行取反操作</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">//a = 1001 0011 b</span>
<span class="token number">2</span> <span class="token comment">//把 bit6 取反，其它位不变</span>
<span class="token number">3</span> 
<span class="token number">4</span> a <span class="token operator">^=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span> <span class="token comment">//a = 1101 0011 b</span>
</code></pre> 
<p><strong>关于GPIO寄存器:</strong><br> 端口配置低寄存器(GPIOx_CRL) (x=A…E)<br> 偏移地址：0x00<br> 复位值：0x4444 4444<br> 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16<br> CNF7[1:0] MODE7[1:0] CNF6[1:0] MODE6[1:0] CNF5[1:0] MODE5[1:0] CNF4[1:0] MODE4[1:0]<br> rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw<br> 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br> CNF3[1:0] MODE3[1:0] CNF2[1:0] MODE2[1:0] CNF1[1:0] MODE1[1:0] CNF0[1:0] MODE0[1:0]<br> rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw</p> 
<p>位31:30 CNFy[1:0]：端口x配置位(y = 0…7) (Port x configuration bits)<br> 27:26 软件通过这些位配置相应的I/O端口，请参考表17端口位配置表。<br> 23:22 在输入模式(MODE[1:0]=00)：<br> 19:18 00：模拟输入模式<br> 15:14 01：浮空输入模式(复位后的状态) 11:10 10：上拉/下拉输入模式 7:6<br> 11：保留 3:2<br> 在输出模式(MODE[1:0]&gt;00)：<br> 00：通用推挽输出模式<br> 01：通用开漏输出模式<br> 10：复用功能推挽输出模式<br> 11：复用功能开漏输出模式</p> 
<p>位29:28 MODEy[1:0]：端口x的模式位(y = 0…7) (Port x mode bits)<br> 25:24 软件通过这些位配置相应的I/O端口，请参考表17端口位配置表。<br> 21:20 00：输入模式(复位后的状态)<br> 17:16 01：输出模式，最大速度10MHz<br> 13:12 10：输出模式，最大速度2MHz<br> 9:8, 5:4 11：输出模式，最大速度50MHz 1:0</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e2cc0b9be7139e7a9bb460a9c91ef02f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux配置NTP时间同步</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07abbb7ff7232efacd06404e52d03244/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">七种方法实现异步编程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>