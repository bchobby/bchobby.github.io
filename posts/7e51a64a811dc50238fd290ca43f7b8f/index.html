<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flink基础：实时处理管道与ETL - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flink基础：实时处理管道与ETL" />
<meta property="og:description" content="​
往期推荐：
Flink基础：入门介绍
Flink基础：DataStream API
Flink深入浅出：资源管理
Flink深入浅出：部署模式
Flink深入浅出：内存模型
Flink深入浅出：JDBC Source从理论到实战
Flink深入浅出：Sql Gateway源码分析
Flink深入浅出：JDBC Connector源码分析
Flink的经典使用场景是ETL，即Extract抽取、Transform转换、Load加载，可以从一个或多个数据源读取数据，经过处理转换后，存储到另一个地方，本篇将会介绍如何使用DataStream API来实现这种应用。注意Flink Table和SQL api 会很适合来做ETL，但是不妨碍从底层的DataStream API来了解其中的细节。
1 无状态的转换 无状态即不需要在操作中维护某个中间状态，典型的例子如map和flatmap。
map() 下面是一个转换操作的例子，需要根据输入数据创建一个出租车起始位置和目标位置的对象。首先定义出租车的位置对象：
public static class EnrichedRide extends TaxiRide { public int startCell; public int endCell; public EnrichedRide() {} public EnrichedRide(TaxiRide ride) { this.rideId = ride.rideId; this.isStart = ride.isStart; ... this.startCell = GeoUtils.mapToGridCell(ride.startLon, ride.startLat); this.endCell = GeoUtils.mapToGridCell(ride.endLon, ride.endLat); } public String toString() { return super.toString() &#43; &#34;,&#34; &#43; Integer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/7e51a64a811dc50238fd290ca43f7b8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-11T21:23:00+08:00" />
<meta property="article:modified_time" content="2020-11-11T21:23:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flink基础：实时处理管道与ETL</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body" style="font-size: 16px;"> 
 <p>​</p> 
 <div style="text-align: center;"> 
  <img src="https://images2.imgbox.com/f6/3c/m3XTh4oT_o.png" style="outline: none;"> 
 </div> 
 <p>往期推荐：</p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247485026&amp;idx=1&amp;sn=6a20ba0ca67cc0a820961c6bc8cd04bc&amp;chksm=fbc0ab24ccb722326873e7432736116f44b948e35f5712a38c85225aa56ffc29c88c4d299b83&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink基础：入门介绍</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247485037&amp;idx=1&amp;sn=96cf9ea57cef091021874badf28a9f76&amp;chksm=fbc0ab2bccb7223d09e5ed2559dabca228834f1fff3bc950c7cbd9b25da1923d0ebc33f53639&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink基础：DataStream API</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247484996&amp;idx=1&amp;sn=b26737e32d07a9a7bf00cf739b15e1c6&amp;chksm=fbc0ab02ccb722143a789e6a79c6ba5f331bab0042ea64ff75cc6a02381b618bf876b41d56f8&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink深入浅出：资源管理</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247484987&amp;idx=1&amp;sn=cc08ab620f15d510a7c3c0700651e013&amp;chksm=fbc0ab7dccb7226b8aa0d8b31f62cd4847a70beb43f67c7982d14b005b9873972027ab68178f&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink深入浅出：部署模式</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247484974&amp;idx=1&amp;sn=f02489295de20d1398b38f2ee0e939ab&amp;chksm=fbc0ab68ccb7227e243ab7db77bde55bec5c9ba5ef0a7940eb5a14000c150c3723aab30f4c5a&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink深入浅出：内存模型</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247484547&amp;idx=1&amp;sn=eaab22866f7e0fa492f79349f38604e6&amp;chksm=fbc0a9c5ccb720d3c7b18de81c88f6175cb1f83286b82b253e73268a2eeb4b2a3cd5e73ab748&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink深入浅出：JDBC Source从理论到实战</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247484529&amp;idx=1&amp;sn=2dbdb75daad3f248ededd88449d77f02&amp;chksm=fbc0a937ccb72021a5f06a70609b9d87f043c8fd33f423a0079885da3acf7cecd14d49f2dff4&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink深入浅出：Sql Gateway源码分析</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzU1NjY0NTQxNw==&amp;mid=2247484513&amp;idx=1&amp;sn=0402cb44d2ad55cde6b3990010e3b59d&amp;chksm=fbc0a927ccb72031d94d26fe7d43fb66be7e2059fab599b35055e8d257cd21feecbc0a15b476&amp;scene=21#wechat_redirect" rel="nofollow noopener noreferrer" target="_blank">Flink深入浅出：JDBC Connector源码分析</a></p> 
 <p>Flink的经典使用场景是ETL，即Extract抽取、Transform转换、Load加载，可以从一个或多个数据源读取数据，经过处理转换后，存储到另一个地方，本篇将会介绍如何使用DataStream API来实现这种应用。注意Flink Table和SQL <br>api 会很适合来做ETL，但是不妨碍从底层的DataStream API来了解其中的细节。</p> 
 <h2>1 无状态的转换</h2> 
 <p>无状态即不需要在操作中维护某个中间状态，典型的例子如map和flatmap。</p> 
 <h5>map()</h5> 
 <p>下面是一个转换操作的例子，需要根据输入数据创建一个出租车起始位置和目标位置的对象。首先定义出租车的位置对象：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">public static class EnrichedRide extends TaxiRide {
    public int startCell;
    public int endCell;

    public EnrichedRide() {}

    public EnrichedRide(TaxiRide ride) {
        this.rideId = ride.rideId;
        this.isStart = ride.isStart;
        ...
        this.startCell = GeoUtils.mapToGridCell(ride.startLon, ride.startLat);
        this.endCell = GeoUtils.mapToGridCell(ride.endLon, ride.endLat);
    }

    public String toString() {
        return super.toString() + "," +
            Integer.toString(this.startCell) + "," +
            Integer.toString(this.endCell);
    }
}</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <p>使用的时候可以注册一个MapFunction，该函数接收TaxiRide对象，输出EnrichRide对象。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">public static class Enrichment implements MapFunction&lt;TaxiRide, EnrichedRide&gt; {
    @Override
    public EnrichedRide map(TaxiRide taxiRide) throws Exception {
        return new EnrichedRide(taxiRide);
    }
}</code>
</pre> 
 </div> 
 <p>使用时只需要创建map对象即可：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">DataStream&lt;TaxiRide&gt; rides = env.addSource(new TaxiRideSource(...));

DataStream&lt;EnrichedRide&gt; enrichedNYCRides = rides
    .filter(new RideCleansingSolution.NYCFilter())
    .map(new Enrichment());

enrichedNYCRides.print();</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <h5>flatmap()</h5> 
 <p>MapFunction适合一对一的转换，对于输入流的每个元素都有一个元素输出。如果需要一对多的场景，可以使用flatmap：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">DataStream&lt;TaxiRide&gt; rides = env.addSource(new TaxiRideSource(...));

DataStream&lt;EnrichedRide&gt; enrichedNYCRides = rides
    .flatMap(new NYCEnrichment());

enrichedNYCRides.print();</code>
</pre> 
 </div> 
 <p>FlatMapFunction的定义：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">public static class NYCEnrichment implements FlatMapFunction&lt;TaxiRide, EnrichedRide&gt; {
    @Override
    public void flatMap(TaxiRide taxiRide, Collector&lt;EnrichedRide&gt; out) throws Exception {
        FilterFunction&lt;TaxiRide&gt; valid = new RideCleansing.NYCFilter();
        if (valid.filter(taxiRide)) {
            out.collect(new EnrichedRide(taxiRide));
        }
    }
}</code>
</pre> 
 </div> 
 <p>通过collector，可以在flatmap中任意添加零个或多个元素。</p> 
 <h2>2 Keyed Streams</h2> 
 <h5>keyBy()</h5> 
 <p>有时需要对数据流按照某个字段进行分组，每个事件会根据该字段相同的值汇总到一起。比如，希望查找相同出发位置的路线。如果在SQL中可能会使用GROUP BY startCell，在Flink中可以直接使用keyBy函数：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">rides
    .flatMap(new NYCEnrichment())
    .keyBy(value -&gt; value.startCell)</code>
</pre> 
 </div> 
 <p>keyBy会引起重分区而导致网络数据shuffle，通常这种代价都很昂贵，因为每次shuffle时需要进行数据的序列化和反序列化，既浪费CPU资源，又占用网络带宽。</p> 
 <p></p> 
 <div style="text-align: center;"> 
  <img src="https://images2.imgbox.com/61/ff/JtOzg4JW_o.png" style="outline: none;"> 
 </div> 
 <p>通过对startCell进行分组，这种方式的分组可能会由于编译器而丢失字段的类型信息，因此Flink也支持把字段包装成Tuple，基于元素位置进行分组。当然也支持使用KeySelector函数，自定义分组规则。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">rides
    .flatMap(new NYCEnrichment())
    .keyBy(
        new KeySelector&lt;EnrichedRide, int&gt;() {

            @Override
            public int getKey(EnrichedRide enrichedRide) throws Exception {
                return enrichedRide.startCell;
            }
        })</code>
</pre> 
 </div> 
 <p>可以直接使用lambda表达式：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">rides
    .flatMap(new NYCEnrichment())
    .keyBy(enrichedRide -&gt; enrichedRide.startCell)</code>
</pre> 
 </div> 
 <h5>key可以自定义计算规则</h5> 
 <p>keyselector不限制从必须从事件中抽取key，也可以自定义任何计算key的方法。但需要保证输出的key是一致的，并且实现了对应的hashCode和equals方法。生成key的规则一定要稳定，因为生成key可能在应用运行的任何时间，因此一定要保证key生成规则的持续稳定。</p> 
 <p>key可以通过某个字段选择：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">keyBy(enrichedRide -&gt; enrichedRide.startCell)</code>
</pre> 
 </div> 
 <p>也可以直接替换成某个方法：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">keyBy(ride -&gt; GeoUtils.mapToGridCell(ride.startLon, ride.startLat))</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <h5>Keyed Stream的聚合</h5> 
 <p>下面的例子中，创建了一个包含startCell和花费时间的二元组：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import org.joda.time.Interval;

DataStream&lt;Tuple2&lt;Integer, Minutes&gt;&gt; minutesByStartCell = enrichedNYCRides
    .flatMap(new FlatMapFunction&lt;EnrichedRide, Tuple2&lt;Integer, Minutes&gt;&gt;() {

        @Override
        public void flatMap(EnrichedRide ride,
                            Collector&lt;Tuple2&lt;Integer, Minutes&gt;&gt; out) throws Exception {
            if (!ride.isStart) {
                Interval rideInterval = new Interval(ride.startTime, ride.endTime);
                Minutes duration = rideInterval.toDuration().toStandardMinutes();
                out.collect(new Tuple2&lt;&gt;(ride.startCell, duration));
            }
        }
    });</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <p>现在需要输出每个起始位置最长距离的路线，有很多种方式可以实现。以上面的数据为例，可以通过startcell进行聚合，然后选择时间最大的元素输出：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">minutesByStartCell
  .keyBy(value -&gt; value.f0) // .keyBy(value -&gt; value.startCell)
  .maxBy(1) // duration
  .print();</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <p>可以得到输出结果：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">4&gt; (64549,5M)
4&gt; (46298,18M)
1&gt; (51549,14M)
1&gt; (53043,13M)
1&gt; (56031,22M)
1&gt; (50797,6M)
...
1&gt; (50797,8M)
...
1&gt; (50797,11M)
...
1&gt; (50797,12M)</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <h5>状态</h5> 
 <p>上面是一个有状态的例子，Flink需要记录每个key的最大值。无论何时在应用中涉及到状态，都需要考虑这个状态有多大。如果key的空间是无限大的，那么flink可能需要维护大量的状态信息。当使用流时，一定要对无限窗口的聚合十分敏感，因为它是对整个流进行操作，很有可能因为维护的状态信息不断膨胀，而导致内存溢出。在上面使用的maxBy就是经典的的聚合操作，也可以使用更通用的reduce来自定义聚合方法。</p> 
 <h2>3 有状态的操作</h2> 
 <p>Flink针对状态的管理有很多易用的特性，比如：</p> 
 <ul><li>支持本地保存：基于进程内存来保存状态</li></ul> 
 <ul><li class="_mce_tagged_br">状态的持久化：定期保存到检查点，保证容错</li></ul> 
 <ul><li class="_mce_tagged_br">垂直扩展：Flink状态可以把状态保存到RocksDB中，也支持扩展到本地磁盘</li></ul> 
 <ul><li class="_mce_tagged_br">水平扩展：状态支持在集群中扩缩容，通过调整并行度，自动拆分状态</li></ul> 
 <ul><li class="_mce_tagged_br">可查询：Flink的状态可以在外部直接查询</li></ul> 
 <h5>Rich函数</h5> 
 <p>Flink有几种函数接口，包括FilterFunction, MapFunction，FlatMapFunction等。对于每个接口，Flink都提供了对应的Rich方法。比如RichFlatMapFunction，提供了额外的一些方法：</p> 
 <ul><li>open(Configuration c) 在初始化的时候调用一次，用于加载静态数据，开启外部服务的连接等</li></ul> 
 <ul><li class="_mce_tagged_br">close() 流关闭时调用</li></ul> 
 <ul><li class="_mce_tagged_br">getRuntimeContext() 提供进入全局状态的方法，需要了解如何创建和查询状态</li></ul> 
 <h5>使用Keyed State的例子</h5> 
 <p>下面是一个针对事件的key进行去重的例子：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">private static class Event {
    public final String key;
    public final long timestamp;
    ...
}

public static void main(String[] args) throws Exception {
    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

    env.addSource(new EventSource())
        .keyBy(e -&gt; e.key)
        .flatMap(new Deduplicator())
        .print();

    env.execute();
}</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <p>为了实现这个功能，deduplicator需要记住一些信息，对于每个key，都需要记录是否已经存在。Flink支持几种不同类型的状态，最简单的一种是valueState。对于每个key，flink都为它保存一个对象，在上面的例子中对象是Boolean。Deduplicator有两个方法：open()和flatMap()。open方法通过descriptor为状态起了一个标识名称，并声明类型为Boolean。</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">public static class Deduplicator extends RichFlatMapFunction&lt;Event, Event&gt; {
    ValueState&lt;Boolean&gt; keyHasBeenSeen;

    @Override
    public void open(Configuration conf) {
        ValueStateDescriptor&lt;Boolean&gt; desc = new ValueStateDescriptor&lt;&gt;("keyHasBeenSeen", Types.BOOLEAN);
        keyHasBeenSeen = getRuntimeContext().getState(desc);
    }

    @Override
    public void flatMap(Event event, Collector&lt;Event&gt; out) throws Exception {
        if (keyHasBeenSeen.value() == null) {
            out.collect(event);
            keyHasBeenSeen.update(true);
        }
    }
}</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <p>flatMap中调用state.value()获取状态。flink在上下文中为每个key保存了一个状态值，只有当值为null时，说明这个key之前没有出现过，然后将其更新为true。当flink调用open时，状态是空的。但是当调用flatMap时，key可以通过context进行访问。当在集群模式中运行时，会有很多个Deduplicator实例，每个负责维护一部分key的事件。因此，当使用单个事件的valuestate时，要理解它背后其实不是一个值，而是每个key都对应一个状态值，并且分布式的存储在集群中的各个节点进程上。</p> 
 <h5>清除状态</h5> 
 <p>有时候key的空间可能是无限制的，flink会为每个key存储一个boolean对象。如果key的数量是有限的还好，但是应用往往是持续不间断的运行，那么key可能会无限增长，因此需要清理不再使用的key。可以通过<code>state.clear()</code>进行清理。比如针对某个key按照某一时间频率进行清理，在processFunction中可以了解到如何在事件驱动的应用中执行定时器操作。也可以在状态描述符中为状态设置TTL生存时间，这样状态可以自动进行清理。</p> 
 <h5>非keyed状态</h5> 
 <p>状态也支持在非key类型的上下文中使用，这种叫做操作符状态，operator state。典型的场景是Flink读取Kafka时记录的offset信息。</p> 
 <h2>4 连接流</h2> 
 <p>大部分场景中Flink都是接收一个数据流输出一个数据流，类似管道式的处理数据：</p> 
 <p></p> 
 <div style="text-align: center;"> 
  <img src="https://images2.imgbox.com/45/b9/jep5Kql1_o.png" style="outline: none;"> 
 </div> 
 <p>也有的场景需要动态的修改函数中的信息，比如阈值、规则或者其他的参数，这种设计叫做connected streams，流会拥有两个输入，类似：</p> 
 <p></p> 
 <div style="text-align: center;"> 
  <img src="https://images2.imgbox.com/07/7d/m0f4Mnqh_o.png" style="outline: none;"> 
 </div> 
 <p>在下面的例子中，通过控制流用来指定必须过滤的单词：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">public static void main(String[] args) throws Exception {
    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

    DataStream&lt;String&gt; control = env.fromElements("DROP", "IGNORE").keyBy(x -&gt; x);
    DataStream&lt;String&gt; streamOfWords = env.fromElements("Apache", "DROP", "Flink", "IGNORE").keyBy(x -&gt; x);

    control
        .connect(datastreamOfWords)
        .flatMap(new ControlFunction())
        .print();

    env.execute();
}</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <p>两个流可以通过key的方式连接，keyby用来分组数据，这样保证相同类型的数据可以进入到相同的实例中。上面的例子两个流都是字符串，</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has">public static class ControlFunction extends RichCoFlatMapFunction&lt;String, String, String&gt; {
    private ValueState&lt;Boolean&gt; blocked;

    @Override
    public void open(Configuration config) {
        blocked = getRuntimeContext().getState(new ValueStateDescriptor&lt;&gt;("blocked", Boolean.class));
    }

    @Override
    public void flatMap1(String control_value, Collector&lt;String&gt; out) throws Exception {
        blocked.update(Boolean.TRUE);
    }

    @Override
    public void flatMap2(String data_value, Collector&lt;String&gt; out) throws Exception {
        if (blocked.value() == null) {
            out.collect(data_value);
        }
    }
}</code>
</pre> 
 </div> 
 <pre class="has"><code></code></pre> 
 <p>blocked用于记录key的控制逻辑，key的state会在两个流间共享。flatMap1和flatMap2会被两个流调用，分别用来更新和获取状态，从而实现通过一个流控制另一个流的目的。</p> 
 <p>总结：本片从状态上讲述了有状态的操作和无状态的操作，还介绍了状态的使用以及连接流的适用场景。后面会介绍DataStream的操作和状态的管理。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c9a4eb28d61c0060eb03f164cc948b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TypeError: __init__() got an unexpected keyword argument ‘ragged‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f98c9639ea4736d95fb8969d3d2a80d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java反射之Method的invoke方法实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>