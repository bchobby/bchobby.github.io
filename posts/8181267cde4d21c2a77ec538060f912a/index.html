<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IP/TCP/UDP报文解析（2）TCP报文 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IP/TCP/UDP报文解析（2）TCP报文" />
<meta property="og:description" content="目录 前言正文TCP报文格式TCP建立连接过程TCP数据传输过程TCP断开连接时的挥手过程TCP/UDP校验和的计算与数据校验伪首部格式计算校验和验证校验和 完整代码 总结 前言 本文中涉及很多的位运算，如果对位运算不太了解的请看这篇博文《Java中的位运算》。
正文 TCP报文格式 源端口： 占16位 在第1、2字节（下标0、1）中，标识信源机1发送该信息时所分配的端口2。目的端口：占16位 在第3、4字节（下标2、3）中，标识最终收信端主机用来处理该信息时分配的端口。序列码：占32位 在第5、6、7、8字节（下标4、5、6、7）中，标识数据报序列。确认码：占32位 在第9、10、11、12字节（下标8、9、10、11）中，标识确认数据序列。首部长：占4位 在第13字节前4位（下标12）中。标识TCP数据报的首部长度，单位是4字节，所以最大取值为15*4=60字节。第13字节后4位与第14字节的前2位组成6位全为0的预留位，暂无定义标志位：占6位 在第14字节后6位（下标13）中。标识该数据报的行为。其值依次为： URG(urgent) :紧急标志 当URG =1时，表明紧急字段有效，告诉系统此报文中有紧急数据，应尽快传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针字段配合使用。ACK(acknowledge)：授权标志 可以理解为对端对上一次请求验证通过，可以继续后续行为。所以仅当ACK = 1时确认号字段才有效，TCP规定，连接建立后所有传送的报文段都必须把ACK置1。PSH(push)：推标志 当两端进行交互式的通信时，有时某一端进程希望在键入一个命令后立即就能收到对端的响应。在这种情况下，TCP就可以将PSH位置为1使用推送操作，对端收到数据报后直接进行处理，不会被加入等待队列。RST(reset)：复位标志 当复位标志生效时，表明连接中出现严重错误，必须释放连接，然后再重新建立运输连接。SYN(synchronous)：同步标志 该标志位只在建立连接前两次握手请求中生效。当该值为1时表示该报文是一个请求连接的报文或授权连接的报文。FIN（fin）:结束标志 该标志只在断开TCP连接时生效。该值为1时标识某一端发出了断开连接的请求。 窗口大小：占16位 在第15、16字节（下标14、15）中。窗口大小的作用是数据接收方通告数据发送方自己单次能处理的数据大小，数据发送方根据这个值来确定自己单次发送数据的量，避免发送方因发送数据过快，接收方由于某些原因数据处理较慢，从而造成的丢包重发性能消耗。因其是16位，所以最大取值为65535字节。具体解释请参见《TCP报头里的那个窗口大小到底是指什么》，在此对该博主表以诚挚感谢！校验和：占16位 在第17、18字节（下标16、17）中。用于校验整个报文的准确性，包括首部和数据部分。紧急指针：占16位 在第19、20字节（下标18、19）中。紧急指针仅在紧急标志生效时才有意义，它指出本报文段中的紧急数据结束序号。该报文段的起始序号到这个序号就是该报文段中需要紧急处理的数据。该序号&#43;1就是普通数据序号。即使窗口为0时也可发送紧急数据。选项和填充：可变长度。作用是在报头中添加特殊选项。当没有选项和填充时报头长度是20字节。一般这里会填入一个最大报文段长度MSS，MSS指每一个TCP报文段中的数据字段的最大长度。数据：可变长度。上层协议（一般指HTTP/HTTPs）封装后的报文数据。 TCP建立连接过程 TCP建立连接时会经历3次授权确认的过程，具体如下：
客户端随机生成一个数据初始序列号（seq）填入序列码字节中,作为数据存储的起始序号和该次数据段的存储起始位置。将SYN标志位置为1，发送连接申请给服务器端。服务器端收到连接申请后，随机生成一个验证码填入序列码字节中，作为客户端收到授权信息时的确认码。将客户端发来的数据序列码&#43;1后填入确认序列码字节中，作为对客户端的连接申请的确认和该次数据段的存储起始位置，将ACK和SYN位都置为1，发送连接确认给客户端。客户端收到连接确认后，将服务器返回的确认序列码&#43;1填入序列码字节中，作为该段的数据起始位置。将服务器返回的序列码&#43;1后填入确认序列码字节中，作为客户端对服务器授权的确认，将ACK位置为1，发送成功连接的信息给服务器。到此两端就可以有序的收发数据了。 发送接收标志位序列码确认码clientserviceSYN = 1x–serviceclientSYN = 1 ACK = 1yx &#43;1 = x1clientserviceACK = 1–y &#43; 1 = y1 其中x为客户端报文段的起始序号 随机生成，y为服务端报文段的起始序号 随机生成。序号取值范围0-65535。为什么需要随机生成起始序号呢？是因为如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。
TCP数据传输过程 TCP建立连接后传输数据过程如下
成功连接后的第1个报文段，客户端将数据初始序号&#43;3填入序列码字节，作为该段报文的存储位置。将初始序号&#43;2填入确认码字节，作为对之前数据段中数据的确认，将PSH和ACK标志位置为1，发送一个推消息告诉服务器自己已经准备就绪，可以开始发送数据了。服务端收到客户端准备就绪的报文后，将收到报文中的序列码&#43;1填入数据序列号中，作为该段报文的起始序号。将这个起始序号&#43;发送数据的长度填入序列码字节中，作为该段报文的结束序号。将ACK标志位置为1，发送数据给客户端。客户端收到数据后，将数据报文中的确认序号&#43;1填入序列码字节，作为客户端报文段的存储位置和数据起始位置。将数据报文中的序列码填入确认序列字节，作为对所有该次数据报文的确认，将ACK标志位置为1，发送给服务器。 重复以上步骤直到数据传递结束，某一段发起断开连接的请求。
发送接收标志位序列码确认码clientservicePSH = 1 ACK = 1x&#43;3 = x3x&#43;3 = x3serviceclientACK = 1x3 &#43; 1 = x4x4 &#43; data length = x5clientserviceACK = 1x5&#43;1 = x6x5serviceclientACK = 1x6&#43;1 = x7x7&#43; data length = x8––––––––––clientserviceACK = 1xn&#43;1xnserviceserviceACK = 1xn&#43;2xn&#43;1 其中x为客户端随机的数据初始序号（x&#43;3是因为前面3个序号依次进行了 SYN-SENT(同步已发送)状态、服务器ESTABLISHED(已建立连接)状态，客户端ESTABLISHED(已建立连接)状态。为什么&#43;3后没有&#43;1是因为该报文段只是起到一个通知作用，没有进入到数据序列中）." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/8181267cde4d21c2a77ec538060f912a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-18T13:35:35+08:00" />
<meta property="article:modified_time" content="2021-10-18T13:35:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IP/TCP/UDP报文解析（2）TCP报文</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_4" rel="nofollow">正文</a></li><li><ul><li><a href="#TCP_5" rel="nofollow">TCP报文格式</a></li><li><a href="#TCP_28" rel="nofollow">TCP建立连接过程</a></li><li><a href="#TCP_42" rel="nofollow">TCP数据传输过程</a></li><li><a href="#TCP_64" rel="nofollow">TCP断开连接时的挥手过程</a></li><li><a href="#TCPUDP_72" rel="nofollow">TCP/UDP校验和的计算与数据校验</a></li><li><ul><li><a href="#_74" rel="nofollow">伪首部格式</a></li><li><a href="#_84" rel="nofollow">计算校验和</a></li><li><a href="#_97" rel="nofollow">验证校验和</a></li></ul> 
    </li><li><a href="#_101" rel="nofollow">完整代码</a></li></ul> 
   </li><li><a href="#_353" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>前言</h3> 
<p>本文中涉及很多的位运算，如果对位运算不太了解的请看这篇博文<a href="https://blog.csdn.net/qq_36999880/article/details/87642345">《Java中的位运算》</a>。</p> 
<h3><a id="_4"></a>正文</h3> 
<h4><a id="TCP_5"></a>TCP报文格式</h4> 
<p><img src="https://images2.imgbox.com/6d/ea/hkCmVXgY_o.png" alt="TCP报文格式"></p> 
<ul><li>源端口： 占16位 在第1、2字节（下标0、1）中，标识信源机<sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1">1</a></sup>发送该信息时所分配的端口<sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2">2</a></sup>。</li><li>目的端口：占16位 在第3、4字节（下标2、3）中，标识最终收信端主机用来处理该信息时分配的端口。</li><li>序列码：占32位 在第5、6、7、8字节（下标4、5、6、7）中，标识数据报序列。</li><li>确认码：占32位 在第9、10、11、12字节（下标8、9、10、11）中，标识确认数据序列。</li><li>首部长：占4位 在第13字节前4位（下标12）中。标识TCP数据报的首部长度，单位是4字节，所以最大取值为15*4=60字节。<mark>第13字节后4位与第14字节的前2位组成6位全为0的预留位，暂无定义</mark></li><li>标志位：占6位 在第14字节后6位（下标13）中。标识该数据报的行为。其值依次为：</li></ul> 
<ol><li>URG(urgent) :紧急标志 当URG =1时，表明紧急字段有效，告诉系统此报文中有紧急数据，应尽快传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针字段配合使用。</li><li>ACK(acknowledge)：授权标志 可以理解为对端对上一次请求验证通过，可以继续后续行为。所以仅当ACK = 1时确认号字段才有效，TCP规定，连接建立后所有传送的报文段都必须把ACK置1。</li><li>PSH(push)：推标志 当两端进行交互式的通信时，有时某一端进程希望在键入一个命令后立即就能收到对端的响应。在这种情况下，TCP就可以将PSH位置为1使用推送操作，对端收到数据报后直接进行处理，不会被加入等待队列。</li><li>RST(reset)：复位标志 当复位标志生效时，表明连接中出现严重错误，必须释放连接，然后再重新建立运输连接。</li><li>SYN(synchronous)：同步标志 该标志位只在建立连接前两次握手请求中生效。当该值为1时表示该报文是一个请求连接的报文或授权连接的报文。</li><li>FIN（fin）:结束标志 该标志只在断开TCP连接时生效。该值为1时标识某一端发出了断开连接的请求。</li></ol> 
<ul><li>窗口大小：占16位 在第15、16字节（下标14、15）中。窗口大小的作用是数据接收方通告数据发送方自己单次能处理的数据大小，数据发送方根据这个值来确定自己单次发送数据的量，避免发送方因发送数据过快，接收方由于某些原因数据处理较慢，从而造成的丢包重发性能消耗。因其是16位，所以最大取值为65535字节。具体解释请参见<a href="https://blog.csdn.net/lee576/article/details/1957003">《TCP报头里的那个窗口大小到底是指什么》</a>，在此对该博主表以诚挚感谢！</li><li>校验和：占16位 在第17、18字节（下标16、17）中。用于校验整个报文的准确性，包括首部和数据部分。</li><li>紧急指针：占16位 在第19、20字节（下标18、19）中。紧急指针仅在紧急标志生效时才有意义，它指出本报文段中的紧急数据结束序号。该报文段的起始序号到这个序号就是该报文段中需要紧急处理的数据。该序号+1就是普通数据序号。即使窗口为0时也可发送紧急数据。</li><li>选项和填充：可变长度。作用是在报头中添加特殊选项。当没有选项和填充时报头长度是20字节。一般这里会填入一个最大报文段长度MSS，MSS指每一个TCP报文段中的数据字段的最大长度。</li><li>数据：可变长度。上层协议（一般指HTTP/HTTPs）封装后的报文数据。</li></ul> 
<h4><a id="TCP_28"></a>TCP建立连接过程</h4> 
<p>TCP建立连接时会经历3次授权确认的过程，具体如下：</p> 
<ol><li>客户端随机生成一个数据初始序列号（seq）填入序列码字节中,作为数据存储的起始序号和该次数据段的存储起始位置。将SYN标志位置为1，发送连接申请给服务器端。</li><li>服务器端收到连接申请后，随机生成一个验证码填入序列码字节中，作为客户端收到授权信息时的确认码。将客户端发来的数据序列码+1后填入确认序列码字节中，作为对客户端的连接申请的确认和该次数据段的存储起始位置，将ACK和SYN位都置为1，发送连接确认给客户端。</li><li>客户端收到连接确认后，将服务器返回的确认序列码+1填入序列码字节中，作为该段的数据起始位置。将服务器返回的序列码+1后填入确认序列码字节中，作为客户端对服务器授权的确认，将ACK位置为1，发送成功连接的信息给服务器。到此两端就可以有序的收发数据了。</li></ol> 
<table><thead><tr><th>发送</th><th>接收</th><th>标志位</th><th>序列码</th><th>确认码</th></tr></thead><tbody><tr><td>client</td><td>service</td><td>SYN = 1</td><td>x</td><td>–</td></tr><tr><td>service</td><td>client</td><td>SYN = 1 ACK = 1</td><td>y</td><td>x +1 = x1</td></tr><tr><td>client</td><td>service</td><td>ACK = 1</td><td>–</td><td>y + 1 = y1</td></tr></tbody></table> 
<blockquote> 
 <p>其中x为客户端报文段的起始序号 随机生成，y为服务端报文段的起始序号 随机生成。序号取值范围0-65535。为什么需要随机生成起始序号呢？是因为如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。</p> 
</blockquote> 
<h4><a id="TCP_42"></a>TCP数据传输过程</h4> 
<p>TCP建立连接后传输数据过程如下</p> 
<ol><li>成功连接后的第1个报文段，客户端将数据初始序号+3填入序列码字节，作为该段报文的存储位置。将初始序号+2填入确认码字节，作为对之前数据段中数据的确认，将PSH和ACK标志位置为1，发送一个推消息告诉服务器自己已经准备就绪，可以开始发送数据了。</li><li>服务端收到客户端准备就绪的报文后，将收到报文中的序列码+1填入数据序列号中，作为该段报文的起始序号。将这个起始序号+发送数据的长度填入序列码字节中，作为该段报文的结束序号。将ACK标志位置为1，发送数据给客户端。</li><li>客户端收到数据后，将数据报文中的确认序号+1填入序列码字节，作为客户端报文段的存储位置和数据起始位置。将数据报文中的序列码填入确认序列字节，作为对所有该次数据报文的确认，将ACK标志位置为1，发送给服务器。</li></ol> 
<p>重复以上步骤直到数据传递结束，某一段发起断开连接的请求。</p> 
<table><thead><tr><th>发送</th><th>接收</th><th>标志位</th><th>序列码</th><th>确认码</th></tr></thead><tbody><tr><td>client</td><td>service</td><td>PSH = 1 ACK = 1</td><td>x+3 = x3</td><td>x+3 = x3</td></tr><tr><td>service</td><td>client</td><td>ACK = 1</td><td>x3 + 1 = x4</td><td>x4 + data length = x5</td></tr><tr><td>client</td><td>service</td><td>ACK = 1</td><td>x5+1 = x6</td><td>x5</td></tr><tr><td>service</td><td>client</td><td>ACK = 1</td><td>x6+1 = x7</td><td>x7+ data length = x8</td></tr><tr><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>client</td><td>service</td><td>ACK = 1</td><td>xn+1</td><td>xn</td></tr><tr><td>service</td><td>service</td><td>ACK = 1</td><td>xn+2</td><td>xn+1</td></tr></tbody></table> 
<blockquote> 
 <p>其中x为客户端随机的数据初始序号（x+3是因为前面3个序号依次进行了 SYN-SENT(同步已发送)状态、服务器ESTABLISHED(已建立连接)状态，客户端ESTABLISHED(已建立连接)状态。为什么+3后没有+1是因为该报文段只是起到一个通知作用，没有进入到数据序列中）.</p> 
</blockquote> 
<h4><a id="TCP_64"></a>TCP断开连接时的挥手过程</h4> 
<p>TCP断开连接时会经历4次申请确认过程，具体如下：</p> 
<ol><li>当某一端（暂且认为是客户端）需要关闭当前TCP连接时，首先将当前收到的数据段中的确认号+1<br> 后填入数据序列字节，将当前收到的序列号+1后填入确认号字节，将ACK、FIN标志位置为1，发送断连请求。</li><li>当对端（暂且认为是服务端）收到断连请求后，将但当前收到序列号+1填入确认号字节，将确认号+1填入数据序列字节，将ACK位置为1，发送确认回信。表示服务器端收到了客户端的断连请求，此时服务器可能任有数据需要发送，不会立即发送自己断连的请求，所以当客户端收到回信时进入等待服务器断连信息的状态。</li><li>当服务器将数据全部发送完成后，将当前确认号+1填入序列字节，将当前序列号+1填入确认序列字节，将ACK、FIN标志置为1，发送服务器断连请求。</li><li>当客户端收到服务器的断连请求后，将当前序列号+1填入确认序列字节，将确认序列+1填入序列字节，将ACK置为1，发送断连确认回信。为了避免网络数据延时返回造成后续使用该端口的连接数据混乱，所以客户端发送回信后不会立即关闭，会进入两个网络延时的等待时间，确保该次连接在网络中不会有延时数据。服务器端收到确认回信后立即关闭连接。</li></ol> 
<h4><a id="TCPUDP_72"></a>TCP/UDP校验和的计算与数据校验</h4> 
<h5><a id="_74"></a>伪首部格式</h5> 
<p>TCP与UDP计算校验和时都需要添加一个12字节的伪首部，其格式为：</p> 
<p><img src="https://images2.imgbox.com/df/53/Vfca97Sb_o.png" alt="TCP/UDP伪首部格式"></p> 
<ul><li>源地址：占32位 在伪首部第1、2、3、4字节（下标0、1、2、3）中，标示数据始发地IP地址</li><li>目的地址：占32位 在伪首部第5、6、7、8字节（下标4、5、6、7）中，标识数据目的地IP地址</li><li>填充对齐位：占8位 在伪首部第9字节（下标8）中，用于伪首部的数据对齐填充，默认全以0填充。</li><li>协议号：占8位 在伪首部第10字节（下标9）中，用于标识该数据采用哪种协议解析</li><li>TCP/UDP数据长度：占16位 在位首部第11、12字节（下标10、11）中，用于标识该报文段中TCP/UDP除报头以外的数据长度。注意是该报文段，不是整个协议报文数据长度。</li></ul> 
<h5><a id="_84"></a>计算校验和</h5> 
<p>TCP/UDP校验和计算的步骤如下：</p> 
<ol><li>将报文段中的校验和位置为0</li><li>将包括伪首部、TCP/DUP报头长度、数据长度中的所有数据字节看成16位一组的数。如果三者字节总长度为奇数字节，还需要在末尾填补一个字节的0.</li><li>将分组后的所有数进行相加求和。</li><li>最后的和肯定会大于16位，所以还需要将这个和的进位反复折叠求和，知道其16位之上没有进位。</li><li>将得到的结果取反得到最终的校验和。</li></ol> 
<p>具体实现代请看文末的完整代码。</p> 
<h5><a id="_97"></a>验证校验和</h5> 
<p>TCP/UDP的数据校验与校验和计算大体一样，只是在数据校验时无需将校验和位置为0，最终得到的结果取反后取16位的值(~sum) &amp; 16)， 如果该值为零 则校验通过 如果不为零 则校验失败 (( ~sum ) &amp; 16 == 0 ? true : false)</p> 
<blockquote> 
 <p>TCP为了实现可靠传输，校验和是不可缺少的，校验不通过会要求服务端数据重传。UDP校验和则可以省略。</p> 
</blockquote> 
<h4><a id="_101"></a>完整代码</h4> 
<pre><code>public class TCPPacket extends Packet{
    private static final String TAG = TCPPacket.class.getSimpleName();

    static final int LOCAL_PORT_BIT = 0;
    static final int REMOTE_PORT_BIT = 2;
    static final int SEQUENCE_BIT = 4;
    static final int ACKNOWLEDGEMENT_SEQUENCE_BIT = 8;
    static final int HEADER_LENGTH_BIT = 12;
    static final int TAG_BIT = 13;
    static final int WINDOWS_SIZE_BIT = 14;
    static final int CHECK_SUM_BIT = 16;
    static final int URG_BIT = 18;

    private byte[] pseudoHeader;

    public TCPPacket(byte[] bytes , int... parameters){
        super(bytes,parameters);
    }

    /**
     * 获取源端口
     * 源端口
     * 在TCP数据报中第0、1字节 占2字节 共16位
     * @return
     */
    public int getLocalPort(){
       return byteToInt(bytes[LOCAL_PORT_BIT + offset],bytes[LOCAL_PORT_BIT + offset + 1]);
    }


    /**
     * 获取目的端口
     * 目的端口
     * 在TCP数据报中第2、3字节 占2字节 共16位
     * @return
     */
    public int getRemotePort(){
        return byteToInt(bytes[REMOTE_PORT_BIT + offset],bytes[REMOTE_PORT_BIT + offset + 1]);
    }

    /**
     * 获取序列码
     *
     *  序列码
     *      在TCP数据报中第4、5、6、7字节 占4字节 共32位
     *      由初始请求方随机生成，用来标识数据起始位置的编码。
     *      TCP将应用层发来的数据对每一字节顺序编号
     *      TCP首部中的序列号是指在本段报文段所携带数据的第一个字节编号
     *      应答方收到请求后值+1后 作为确认序列码返回给请求方标识该请求被成功送达
     *      序列码和标志位配合使用,以实现不同的状态逻辑
     */
    public int getSequence(){
        return  byteToInt(bytes[SEQUENCE_BIT + offset],bytes[SEQUENCE_BIT + offset + 1],bytes[SEQUENCE_BIT + offset + 2],bytes[SEQUENCE_BIT + offset + 3]);
    }

    public void setSequence(int seq){
        for(int i = 0;i &lt; 4;i ++){
            bytes[SEQUENCE_BIT + offset + i] = (byte) (seq &gt;&gt; ((3 - i) * 8));
        }
    }

    /**
     * 获取确认码
     *
     *  确认序列码
     *      在TCP数据报中第8、9、10、11字节 占4字节 共32位
     *      如果是请求方 则确认码就是序列码
     *      如果是应答方 则确认码是收到的确认码+1
     * @return
     */
    public int getAcknowledgementSequence(){
        return byteToInt(bytes[ACKNOWLEDGEMENT_SEQUENCE_BIT + offset],bytes[ACKNOWLEDGEMENT_SEQUENCE_BIT + offset + 1]
                ,bytes[ACKNOWLEDGEMENT_SEQUENCE_BIT + offset + 2],bytes[ACKNOWLEDGEMENT_SEQUENCE_BIT + offset + 3]);
    }

    public void setAcknowledgementSequence(int ack){
        for(int i = 0;i &lt; 4;i ++){
            bytes[ACKNOWLEDGEMENT_SEQUENCE_BIT + offset + i] = (byte) (ack &gt;&gt; ((3 - i) * 8));
        }
    }

    /**
     * 获取首部长
     * 头部长
     *      在TCP数据报中第12字节前4位 占1/2字节 共4位 单位 4 byte
     *      TCP默认报头长20字节
     * @return
     */
    public int getHeaderLength(){
        return ((bytes[HEADER_LENGTH_BIT + offset] &amp; 0xFF) &gt;&gt; 4 ) * 4;
    }



    /**
     * 获取标志位
     *
     * 标志位
     *      在TCP数据报中第13字节后6位 占2/3字节 共6位
     *      从第13字节第3位起 左至右依次表示为 URG(urgent) ACK(acknowledge) PSH（push） RST(reset) SYN(synchronous) FIN(fin)
     *      URG 紧急标志 说明这个报文中包含需紧急处理的数据 该位值为 1 时紧急指针生效 指向需紧急处理的数据
     *      ACK 确认标志 说明发送的请求被送达并返回响应
     *      PSH 推标志   该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理Telnet或r login等交互模式的连接时，该标志总是置位的。
     *      RST 复位标志 要求复位相应的TCP连接
     *      SYN 同步标志 该标志位只在3次握手建立TCP连接时有效 提示TCP连接的服务端检查序列编号
     *      FIN 结束标志 该标志位只在4次挥手断开连接时有效
     */
    public int getTag(){
        return bytes[TAG_BIT + offset] &amp; 0x2F;
    }

    public boolean isURG(){
        return (getTag() &gt;&gt; 5) == 1;
    }

    public boolean isACK(){
        return ((getTag() &gt;&gt; 4) &amp; 1) == 1;
    }

    public boolean isPSH(){
        return ((getTag() &gt;&gt; 3) &amp; 1) == 1;
    }

    public boolean isRST(){
        return ((getTag() &gt;&gt; 2) &amp; 1) == 1;
    }

    public boolean isSYN(){
        return ((getTag() &gt;&gt; 1) &amp; 1) == 1;
    }

    public boolean isFIN(){
        return (getTag() &amp; 1) == 1;
    }

    /**
     * 获取窗口大小
     * 窗口大小
     *      在TCP数据报中第14、15字节 占2字节 共16位
     *      用来表示想收到的每个TCP数据段的大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供
     *      窗口大小最大为65535字节
     * @return
     */
    public int getWindowsSize(){
       return byteToInt(bytes[WINDOWS_SIZE_BIT + offset],bytes[WINDOWS_SIZE_BIT + offset + 1]);
    }

    /**
     * 获取紧急指针
     * 紧急指针
     *      在TCP数据报中第18、19字节 占2字节 共16位
     *      用于标识数据报中需紧急处理的数据位置
     * @return
     */
    public int getUrg(){
        return byteToInt(bytes[URG_BIT + offset],bytes[URG_BIT + offset + 1]);
    }


    /**
     * 获取校验和
     * 校验和
     *      在TCP数据报中第16、17字节 占2字节 共16位
     *      用于对TCP数据的校验  由发送端对数据报中所有数据计算得出
     * @return
     */
    public int getCheckSum(){
        return byteToInt(bytes[CHECK_SUM_BIT + offset],bytes[CHECK_SUM_BIT + offset + 1]);
    }

    /**
     * 检查校验和
     * @return
     */
    public boolean checkSum(){
        return  (~getSum() &amp; 0xFFFF) == 0;
    }

    // 获取和
    private int getSum(){
        int sum = 0;

        if(pseudoHeader != null){
            for(int i = 0;i &lt; pseudoHeader.length; i += 2){
                sum += byteToInt(pseudoHeader[i],pseudoHeader[i + 1]);
            }
        }

        for(int i = offset;i &lt; validLength;i += 2){
            sum += byteToInt(bytes[i],bytes[i + 1]);
        }

        if((validLength - offset) % 2 &gt; 0){
            sum += (bytes[validLength - 1] &amp; 0xFF) &lt;&lt; 8;
        }

        while ((sum &gt;&gt; 16) &gt; 0){
            sum = (sum  &gt;&gt; 16) + (sum &amp; 0xFFFF);
        }

        return sum;
    }

    // 初始化伪首部  在数据校验 与 计算校验和之前必须进行初始化
    public void initPseudoHeader(int localIP,int remoteIP,int length){
        pseudoHeader = new byte[12];

        for(int i = 0;i &lt; 4;i ++){
            pseudoHeader[i] = (byte) (localIP &gt;&gt; ((3 - i) * 8));
            pseudoHeader[i + 4] = (byte) (remoteIP &gt;&gt; ((3 - i) * 8));
        }

        pseudoHeader[8] =  0 ;
        pseudoHeader[9] =  6 ;
        pseudoHeader[10] = (byte) (length &gt;&gt; 8);
        pseudoHeader[11] = (byte) length;
    }

    public void refreshCheckSum(){
        bytes[CHECK_SUM_BIT + offset] = 0;
        bytes[CHECK_SUM_BIT + offset + 1] = 0;
        int m = ~getSum();
        bytes[CHECK_SUM_BIT + offset] = (byte) (m &gt;&gt; 8);
        bytes[CHECK_SUM_BIT + offset + 1] = (byte)m;
    }


    /**
     * 设置本地锻端口
     * @return
     */
    public void setLocalPort(int port){
        bytes[LOCAL_PORT_BIT + offset] = (byte) (port &gt;&gt; 8);
        bytes[LOCAL_PORT_BIT + offset + 1] = (byte) port;
    }

    /**
     * 设置远程端口
     * @param port
     */
    public void setRemotePort(int port){
        bytes[REMOTE_PORT_BIT + offset] = (byte) (port &gt;&gt; 8);
        bytes[REMOTE_PORT_BIT + offset + 1] = (byte) port;
    }

}
</code></pre> 
<blockquote> 
 <p>注释很简洁，不过配合上面几部分的内容，应该能看懂是什么意思。关于代码中Packet类的代码在<a href="https://blog.csdn.net/qq_36999880/article/details/87812058">《IP/TCP/UDP报文解析（1）IP报文》</a>中有完整代码。</p> 
</blockquote> 
<h3><a id="_353"></a>总结</h3> 
<p>到此TCP的报文格式、连接过程、数据传递过程、断开连接过程、报文的校验、校验和的计算我知道的知识点都在这里了，希望你能有所收获。</p> 
<hr class="footnotes-sep"> 
<section class="footnotes"> 
 <ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>信息始发地主机 <a href="#fnref1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn2" class="footnote-item"><p>两个主机建立信息交互时随机分配的未被占用的标识符，用来在本地保存一些信息 如：发出信息的应用或接收后交给那个应用处理，这样当消息送达或是收到回信时，才能知道应该交给那个应用来处理。因为TCP报文中端口位用16位保存，所以端口的取值范围是0 - 65535 <a href="#fnref2" rel="nofollow" class="footnote-backref">↩︎</a></p> </li></ol> 
</section>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ecfcbb1660187d1f3bb231481c7f8c2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Edge 浏览器的收藏夹文档位置——最新版windows10和edge</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9aaa9c629cce7d438b290282c1b7cc6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IP/TCP/UDP报文解析（1）IP报文</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>