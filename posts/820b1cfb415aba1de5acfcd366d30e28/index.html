<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构汇总（竞赛&#43;笔试）（有待补全） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构汇总（竞赛&#43;笔试）（有待补全）" />
<meta property="og:description" content="1.链表 1.1 单链表
(1) 笔试写法
struct Node { int val; Node *next; Node(int _val) : val(_val), next(NULL){} } *head; // p 后插入新节点 void insert(Node *p , int x) { Node *q = new Node(x); q-&gt;next = p-&gt;next; p-&gt;next = q; } // 删除节点p -&gt; next void remove(Node *p) { auto q = p-&gt;next; p-&gt;next = q-&gt;next; delete(q); } //查找x节点 Node *find(int x) { for(auto p = head ; p !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/820b1cfb415aba1de5acfcd366d30e28/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-14T12:03:05+08:00" />
<meta property="article:modified_time" content="2023-09-14T12:03:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构汇总（竞赛&#43;笔试）（有待补全）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.链表</h3> 
<hr> 
<p>1.1 单链表<br> (1) 笔试写法<br>  </p> 
<pre><code class="language-cpp">struct Node
{
    int val;
    Node *next;
    Node(int _val) : val(_val), next(NULL){}
} *head;

// p 后插入新节点
void insert(Node *p , int x)
{
    Node *q = new Node(x);
    q-&gt;next = p-&gt;next;
    p-&gt;next = q;
}

// 删除节点p -&gt; next
void remove(Node *p)
{
    auto q = p-&gt;next;
    p-&gt;next = q-&gt;next;
    delete(q);
}

//查找x节点
Node *find(int x)
{
    for(auto p = head ; p != NULL ; p = p-&gt;next)
    {
        if(p-&gt;val == x) return p;
    }
    return NULL;
}

//修改
void modify(int x , int y)
{
    Node *p = find(x);
    if(p) p-&gt;val = y;
}</code></pre> 
<p>(2)机试写法(链式前向星)<br>  </p> 
<pre><code class="language-cpp">// head 表示头结点的下标
// e[i] 表示节点i的值
// ne[i] 表示节点i的next指针是多少
// idx 存储当前已经用到了哪个点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 将x插到头结点
void add_to_head(int x)
{
    e[idx] = x, ne[idx] = head, head = idx ++ ;
}

// 将x插到下标是k的点后面
void add(int k, int x)
{
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;
}

// 将下标是k的点后面的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}</code></pre> 
<p>1.2 双链表</p> 
<p>1.3 循环链表</p> 
<p>1.4 十字链表</p> 
<h3><br> 栈与队列</h3> 
<hr> 
<h3>树</h3> 
<hr> 
<p>3.3平衡树<br> (1) Splay</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;
const int N = 500010 , INF = 1e9;

int n , m;
struct Node
{
    int s[2] , p , v; // 左右子树下标、父节点下标、值
    int rev , same;   // 翻转和改变值的懒标记
    int size , sum , ms , ls , rs; // 子树大小、子树和、最大子段和、最大前缀和、最大后缀和
    
    void init(int _v , int _p)          
    {
        s[0] = s[1] = 0 , p = _p , v = _v;      // 0表示空
        rev = same = 0;
        size = 1 , sum = ms = v;
        ls = rs = max(0 , v);
    }
}tr[N];

int root , nodes[N] , idx;   // 根、下标分配站(因为数量很大，所以要循环利用删掉的点的下标)、分配站的idx
int w[N];                   // 存值的地方

void pushup(int x)
{
    auto &amp;u = tr[x] , &amp;l = tr[u.s[0]] , r = tr[u.s[1]];
    u.size = l.size + r.size + 1;
    u.sum = l.sum + r.sum + u.v;
    u.ls = max(l.ls , l.sum + u.v + r.ls);     // 最大前缀和是 左子树最大前缀和 和 左子树全部加上该节点加上右子树最大前缀和 的最大值
    u.rs = max(r.rs , r.sum + u.v + l.rs);     // 同理
    u.ms = max(max(l.ms , r.ms) , l.rs + u.v + r.ls );  
    // 最大子段和是 左子树的最大子段和 和 右子树的最大子段和 和 左子树最大后缀和加上该节点加上右子树的最大前缀和(因为子段和得连续) 中的最大值
}

void pushdown(int x)
{
    auto &amp;u = tr[x] , &amp;l = tr[u.s[0]] , &amp;r = tr[u.s[1]];
    if(u.same)
    {
        u.same = u.rev = 0; // 懒标记消除
        if (u.s[0]) l.same = 1, l.v = u.v, l.sum = l.v * l.size;        // 懒标记下传
        if (u.s[1]) r.same = 1, r.v = u.v, r.sum = r.v * r.size;
        if (u.v &gt; 0)
        {
            if (u.s[0]) l.ms = l.ls = l.rs = l.sum;
            if (u.s[1]) r.ms = r.ls = r.rs = r.sum;
        }
        else
        {
            if (u.s[0]) l.ms = l.v, l.ls = l.rs = 0;
            if (u.s[1]) r.ms = r.v, r.ls = r.rs = 0;
        }
    }
    else if(u.rev) // else 的原因是如果same了就没有必要旋转了，因为旋不旋转都一样
    {
        u.rev = 0, l.rev ^= 1, r.rev ^= 1;                   // 懒标记下传
        swap(l.ls, l.rs), swap(r.ls, r.rs);
        swap(l.s[0], l.s[1]), swap(r.s[0], r.s[1]);
    }
}

void rotate(int x)                      // 左旋右旋合并函数
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int x, int k)                // splay 操作 将x转到k的右子树上
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}


int get_k(int k)                            // 找到第k排名的下标
{
    int u = root;
    while (u)
    {
        pushdown(u);
        if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
}

int build(int l, int r, int p)      // 建树
{
    int mid = l + r &gt;&gt; 1;
    int u = nodes[idx -- ];
    tr[u].init(w[mid], p);
    if (l &lt; mid) tr[u].s[0] = build(l, mid - 1, u);
    if (mid &lt; r) tr[u].s[1] = build(mid + 1, r, u);
    pushup(u);
    return u;
}

void del(int u)                             // 递归删树
{
    if(tr[u].s[0]) del(tr[u].s[0]);         
    if(tr[u].s[1]) del(tr[u].s[1]);
    nodes[ ++ idx] = u;                     // 空间回收利用
}

int main()
{
    for(int i = 1 ; i &lt; N ; i ++) nodes[++ idx] = i;    // 给分配站一些初始空间
    scanf("%d%d", &amp;n, &amp;m);
    tr[0].ms = w[0] = w[n + 1] = -INF; // 空和哨兵(为了方便删除结点)
    for(int i = 1 ; i &lt;= n ; i ++) scanf("%d", &amp;w[i]);
    root = build(0 , n + 1 , 0);                        // 别忘了建树时把哨兵带上
    
    char op[20]; // 读指令
    while (m -- )
    {
        scanf("%s", op);
        if(!strcmp(op , "INSERT"))
        {
            int posi , tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            for(int i = 0 ; i &lt; tot ; i ++) scanf("%d", &amp;w[i]);
            int l = get_k(posi + 1) , r = get_k(posi + 2); // +1 是因为有哨兵 , +2 是因为要插到两个之间
            splay(l , 0) , splay(r , l); // 现将l转到0的右子树,再将r转到l的右子树,这样r的左子树就是在l到r之间了
            int u = build(0 , tot - 1 , r);
            tr[r].s[0] = u;                 //插入到r的左子树
            pushup(r) , pushup(l);          // 因为r是l的子树,所以先pushup(r),再pushup(l)
        }
        else if(!strcmp(op , "DELETE"))
        {
            int posi , tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            int l = get_k(posi) , r = get_k(posi + tot + 1) ; // 左边的向左一个,右边的向右一个,这样r的左子树就是这段序列了
            splay(l , 0) , splay(r,  l);
            del(tr[r].s[0]);            // 删除子树
            tr[r].s[0] = 0;             // 指向空
            pushup(r) , pushup(l);
        }
        else if(!strcmp(op , "MAKE-SAME"))
        {
            int posi , tot , c;
            scanf("%d%d%d", &amp;posi, &amp;tot ,&amp;c);
            int l = get_k(posi) , r = get_k(posi + tot + 1);
            splay(l , 0) , splay(r , l);
            auto &amp;son = tr[tr[r].s[0]];
            son.same = 1 , son.v = c , son.sum = c * son.size;
            if(c &gt; 0) son.ms = son.ls = son.rs = son.sum;
            else son.ms = c , son.ls = son.rs = 0;
            pushup(r) , pushup(l);
        }
        else if (!strcmp(op, "REVERSE"))
        {
            int posi, tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            int l = get_k(posi) , r = get_k(posi + tot + 1);
            splay(l , 0) , splay(r , l);
            auto &amp;son = tr[tr[r].s[0]];
            son.rev ^= 1;
            swap(son.ls , son.rs);          // 旋转之后最大前缀和和最大后缀和对调
            swap(son.s[0] , son.s[1]);       // 左右子树对调
            pushup(r) , pushup(l);
        }
        else if (!strcmp(op, "GET-SUM"))
        {
            int posi, tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            printf("%d\n", tr[tr[r].s[0]].sum);
        }
        else printf("%d\n", tr[root].ms);
    }
    
    return 0;
    
}</code></pre> 
<p><br> (2) FHQ</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 500010, INF = 1e9;


int n, m;
struct FHQ
{
    int l, r;            // 左右子树下标
    int size;            // 子树大小
    int val, key;        // 结点值和维护堆性质的k
    int sum, ls, rs, ms; // 子树总和、最大前缀和、最大后缀和、最大子段和
    int same, rev;       // 懒标记

    void init(int _v) // 初始化函数
    {
        l = r = 0;
        size = 1;
        sum = val = ms = _v;
        key = rand();
        ls = rs = max(_v, 0);
        same = rev = 0;
    }
} tr[N];

int root, nodes[N], idx; // 根、下标分配站(因为数量很大，所以要循环利用删掉的点的下标)、分配站的idx
int w[N];                // 存值的地方

int addNode(int x) // 增加节点
{
    int id = nodes[idx--]; // 发配节点下标
    tr[id].init(x);
    return id;
}

void reverse(int p) // rev处理函数
{
    if (!p) // 如果是哨兵就跳过
        return;
    tr[p].rev ^= 1;           // 标记下传
    swap(tr[p].ls, tr[p].rs); // 旋转之后最大前缀和和最大后缀和对调
    swap(tr[p].l, tr[p].r);   // 左右子树对调
}

void cover(int p, int c) // same处理函数
{
    if (!p) // 如果是哨兵就跳过
        return;
    tr[p].same = 1;                            // 标记下传
    tr[p].val = c, tr[p].sum = c * tr[p].size; // 修改结点信息
    if (c &gt;= 0)
        tr[p].ms = tr[p].ls = tr[p].rs = tr[p].sum;
    else
        tr[p].ms = c, tr[p].ls = tr[p].rs = 0;
}

void pushdown(int p)
{
    if (!p) // 如果是哨兵就跳过
        return;
    if (tr[p].same) // 如果有same标记
    {
        cover(tr[p].l, tr[p].val);
        cover(tr[p].r, tr[p].val);
        tr[p].same = 0; // 去除标记
    }
    if (tr[p].rev) // 如果有rev标记
    {
        if (tr[p].l)
            reverse(tr[p].l);
        if (tr[p].r)
            reverse(tr[p].r);
        tr[p].rev = 0; // 去除标记
    }
}

void pushup(int p)
{
    tr[p].sum = tr[p].val + tr[tr[p].l].sum + tr[tr[p].r].sum;
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + 1;
    tr[p].ls = max(tr[tr[p].l].ls, tr[tr[p].l].sum + tr[p].val + tr[tr[p].r].ls);                     // 最大前缀和是 左子树最大前缀和 和 左子树全部加上该节点加上右子树最大前缀和 的最大值
    tr[p].rs = max(tr[tr[p].r].rs, tr[tr[p].r].sum + tr[p].val + tr[tr[p].l].rs);                     // 同理
    tr[p].ms = max(tr[tr[p].l].rs + tr[p].val + tr[tr[p].r].ls, max(tr[tr[p].l].ms, tr[tr[p].r].ms)); // 最大子段和是 左子树的最大子段和 和 右子树的最大子段和 和 左子树最大后缀和加上该节点加上右子树的最大前缀和(因为子段和得连续) 中的最大值
}

// FHQ基本操作,合并x,y子树,其中x子树的值&lt;=y子树的值
int merge(int x, int y)
{
    if (!x || !y)
        return x + y;          // x = 0答案是y,y = 0答案是x,也就是如果有一个子树为空则返回另一个子树
    if (tr[x].key &gt; tr[y].key) // x在堆中是在y的上方,而值小于y,故在y的左上方
    {
        pushdown(x);                 // 合并谁的子树就pushdown谁
        tr[x].r = merge(tr[x].r, y); // 让x的右子树和y合并
        pushup(x);
        return x;
    }
    else // x在y的左下方
    {
        pushdown(y);
        tr[y].l = merge(x, tr[y].l); // x和y的左子树合并
        // 不能写成merge(tr[y].l,x) 必须满足x &lt; y
        pushup(y);
        return y;
    }
}

// FHQ基本操作,按size分裂,找到第k个
// 将p子树以按k拆成x和y子树,其中x的大小&lt;=k,y的大小大于k
void split(int p, int k, int &amp;x, int &amp;y)
{
    if (!p)
    {
        x = y = 0;
        return;
    }
    pushdown(p);               // 分裂前要pushdown标记
    if (k &lt;= tr[tr[p].l].size) // 这里和以前不一样,因为本题是按照排名分裂,所以不比较val的大小,而是看左子树的大小来决定分裂哪棵
    {
        y = p;
        split(tr[p].l, k, x, tr[y].l);
        pushup(y);
    }
    else
    {
        x = p;
        split(tr[p].r, k - tr[tr[p].l].size - 1, tr[x].r, y);
        pushup(x);
    }
}

void del(int p)
{
    nodes[++idx] = p; // 空间回收利用
    if (tr[p].l)
        del(tr[p].l);
    if (tr[p].r)
        del(tr[p].r);
}

int build(int l, int r) // 建树
{
    if (l &gt; r)
        return 0;
    if (l == r)
        return addNode(w[l]);
    int mid = (l + r) &gt;&gt; 1, p = addNode(w[mid]);
    tr[p].l = build(l, mid - 1);
    tr[p].r = build(mid + 1, r);
    pushup(p);
    return p;
}

int main()
{
    tr[0].ms = tr[0].val = w[0] = w[n + 1] = -INF; // 空和哨兵(为了方便删除结点)
    int X, Y, Z;                                   // 建三个空树,方便后序split和merge
    scanf("%d%d", &amp;n, &amp;m);
    for (int i = 1; i &lt; N; i++)
        nodes[++idx] = i;
    for (int i = 1; i &lt;= n; i++)
        scanf("%d", &amp;w[i]);
    root = build(1, n);

    char op[20];
    while (m--)
    {
        scanf("%s", op);
        if (!strcmp(op, "INSERT"))
        {
            int posi, tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            split(root, posi, X, Y);
            for (int i = 1; i &lt;= tot; i++)
                scanf("%d", &amp;w[i]);
            root = merge(X, merge(build(1, tot), Y));
        }
        else if (!strcmp(op, "DELETE"))
        {
            int posi, tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            split(root, posi - 1, X, Y);
            split(Y, tot, Y, Z);
            del(Y);
            root = merge(X, Z);
        }
        else if (!strcmp(op, "MAKE-SAME"))
        {
            int posi, tot, c;
            scanf("%d%d%d", &amp;posi, &amp;tot, &amp;c);
            split(root, posi - 1, X, Y);
            split(Y, tot, Y, Z);
            cover(Y, c);
            root = merge(X, merge(Y, Z));
        }
        else if (!strcmp(op, "REVERSE"))
        {
            int posi, tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            split(root, posi - 1, X, Y);
            split(Y, tot, Y, Z);
            reverse(Y);
            root = merge(X, merge(Y, Z));
        }
        else if (!strcmp(op, "GET-SUM"))
        {
            int posi, tot;
            scanf("%d%d", &amp;posi, &amp;tot);
            split(root, posi - 1, X, Y);
            split(Y, tot, Y, Z);
            printf("%d\n", tr[Y].sum);
            root = merge(X, merge(Y, Z));
        }
        else
            printf("%d\n", tr[root].ms);
    }
    return 0;
}</code></pre> 
<p><br> (3) Treap(下标写法)</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010 , INF = 1e8;

int n;

struct Node
{
    int l , r; //表示左右子树的下标
    int key , val; //表示键值和维护大根堆性质的随机数
    int cnt , size; // 该key的个数和该节点及其子树包含的数字总个数
}tr[N];

int root , idx;

void pushup(int p) //更新节点的size
{
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

int get_node(int key) //创造新的节点
{
    tr[++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void zig(int &amp;p) //右旋拎左右挂左
{
    int q = tr[p].l;
    tr[p].l = tr[q].r , tr[q].r = p , p = q;
    pushup(tr[p].r) , pushup(p);
}

void zag(int &amp;p)//左旋拎右左挂右
{
    int q = tr[p].r;
    tr[p].r = tr[q].l , tr[q].l = p , p = q;
    pushup(tr[p].l) , pushup(p);
}

void build() //初始化
{
    get_node(-INF) , get_node(INF); // 哨兵
    root = 1 , tr[root].r = 2;
    pushup(root);

    if(tr[root].val &lt; tr[tr[root].r].val) zag(root);
}

void insert(int &amp;p , int key)
{
    if(!p) p = get_node(key);
    else if(tr[p].key == key) tr[p].cnt ++;
    else if(tr[p].key &gt; key)
    {
        insert(tr[p].l , key);
        if(tr[tr[p].l].val &gt; tr[p].val) zig(p);
    }
    else 
    {
        insert(tr[p].r , key);  
        if(tr[tr[p].r].val &gt; tr[p].val ) zag(p);
    }
    pushup(p);//别忘了插入之后一定要更新该节点的信息
}

void _delete(int &amp;p , int key)
{
    if(!p) return ;
    if(tr[p].key == key) //找到这个数了
    {
        if(tr[p].cnt &gt; 1) tr[p].cnt --;
        else if( tr[p].l || tr[p].r ) //至少存在一个子树
        {
            if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val) //右子树不存在或都存在但是左子树是大根,最终结果都是要右旋
            {
                zig(p);
                _delete(tr[p].r , key); //注意右旋之后要删除的点就是之前点的右儿子
            }
            else
            {
                zag(p);
                _delete(tr[p].l , key);
            }
        }
        else p = 0; //叶子节点,直接删除
    }
    else if (tr[p].key &gt; key) _delete(tr[p].l , key);
    else _delete(tr[p].r , key);

    pushup(p);  //别忘了删除之后一定要更新该节点的信息
}

int get_rank_by_key(int p, int key) // 通过数字找排名
{
    if(!p) return 0;
    if(tr[p].key == key) return tr[tr[p].l].size + 1; 
    if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l , key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r , key);
}

int get_key_by_rank(int p , int rank) // 通过排名找数字
{
    if(!p) return INF;
    if(tr[tr[p].l].size &gt;= rank) return get_key_by_rank(tr[p].l , rank);
    if(tr[tr[p].l].size + tr[p].cnt &gt;= rank) return tr[p].key;
    return get_key_by_rank(tr[p].r , rank - tr[p].cnt - tr[tr[p].l].size);
}

int get_prev(int p , int key) //找前驱(小于key的最大数)
{
    if(!p) return -INF;
    if(tr[p].key &gt;= key) return get_prev(tr[p].l , key);
    return max(tr[p].key , get_prev(tr[p].r , key));
}

int get_next(int p , int key) //找后继(大于key的最小数)
{
    if(!p) return INF;
    if(tr[p].key &lt;= key) return get_next(tr[p].r , key);
    return min(tr[p].key , get_next(tr[p].l , key));
}

int main()
{
    build(); //初始化

    scanf("%d", &amp;n);
    while (n -- )
    {
        int opt , x;
        scanf("%d%d", &amp;opt, &amp;x);
        if(opt == 1) insert(root , x);
        else if(opt == 2) _delete(root , x);
        else if(opt == 3) printf("%d\n" , get_rank_by_key(root , x) - 1); //减1是因为有哨兵(-INF)
        else if(opt == 4) printf("%d\n" , get_key_by_rank(root , x + 1)); //加1也是因为有哨兵(-INF)
        else if(opt == 5) printf("%d\n" , get_prev(root , x));
        else printf("%d\n" , get_next(root , x));
    }

    return 0;
}</code></pre> 
<p><br> (4)Treap(指针写法)</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Node
{
    int key;
    int priority;
    Node *left;
    Node *right;
    Node(int k, int p) : key(k), priority(p), left(nullptr), right(nullptr) {}
};
Node *rightRotate(Node *t)
{
    Node *s = t-&gt;left;
    t-&gt;left = s-&gt;right;
    s-&gt;right = t;
    return s;
}
Node *leftRotate(Node *t)
{
    Node *s = t-&gt;right;
    t-&gt;right = s-&gt;left;
    s-&gt;left = t;
    return s;
}
Node *insert(Node *t, int key, int priority)
{
    if (t == nullptr)
    {
        return new Node(key, priority);
    }
    if (key == t-&gt;key)
    {
        return t;
    }
    if (key &lt; t-&gt;key)
    {
        t-&gt;left = insert(t-&gt;left, key, priority);
        if (t-&gt;priority &lt; t-&gt;left-&gt;priority)
        {
            t = rightRotate(t);
        }
    }
    else
    {
        t-&gt;right = insert(t-&gt;right, key, priority);
        if (t-&gt;priority &lt; t-&gt;right-&gt;priority)
        {
            t = leftRotate(t);
        }
    }
    return t;
}
Node *find(Node *t, int key)
{
    if (t == nullptr)
    {
        return nullptr;
    }
    if (key == t-&gt;key)
    {
        return t;
    }
    if (key &lt; t-&gt;key)
    {
        return find(t-&gt;left, key);
    }
    else
    {
        return find(t-&gt;right, key);
    }
}
Node *_delete(Node *t, int key);
Node *deleteNode(Node *t, int key)
{
    if (t == nullptr)
    {
        return nullptr;
    }
    if (key &lt; t-&gt;key)
    {
        t-&gt;left = deleteNode(t-&gt;left, key);
    }
    else if (key &gt; t-&gt;key)
    {
        t-&gt;right = deleteNode(t-&gt;right, key);
    }
    else
    {
        return _delete(t, key);
    }
    return t;
}
Node *_delete(Node *t, int key)
{
    if (t-&gt;left == nullptr &amp;&amp; t-&gt;right == nullptr)
    {
        return nullptr;
    }
    else if (t-&gt;left == nullptr)
    {
        t = leftRotate(t);
    }
    else if (t-&gt;right == nullptr)
    {
        t = rightRotate(t);
    }
    else
    {
        if (t-&gt;left-&gt;priority &gt; t-&gt;right-&gt;priority)
        {
            t = rightRotate(t);
        }
        else
        {
            t = leftRotate(t);
        }
    }
    return deleteNode(t, key);
}

void inorder(Node *t, vector&lt;int&gt; &amp;v)
{
    if (t == nullptr)
    {
        return;
    }
    inorder(t-&gt;left, v);
    v.push_back(t-&gt;key);
    inorder(t-&gt;right, v);
}
void preorder(Node *t, vector&lt;int&gt; &amp;v)
{
    if (t == nullptr)
    {
        return;
    }
    v.push_back(t-&gt;key);
    preorder(t-&gt;left, v);
    preorder(t-&gt;right, v);
}
int main()
{
    int m;
    cin &gt;&gt; m;
    Node *root = nullptr;
    while (m--)
    {
        string cmd;
        cin &gt;&gt; cmd;
        if (cmd == "insert")
        {
            int key, priority;
            cin &gt;&gt; key &gt;&gt; priority;
            root = insert(root, key, priority);
        }
        else if (cmd == "find")
        {
            int key;
            cin &gt;&gt; key;
            if (find(root, key) != nullptr)
            {
                cout &lt;&lt; "yes" &lt;&lt; endl;
            }
            else
            {
                cout &lt;&lt; "no" &lt;&lt; endl;
            }
        }
        else if (cmd == "delete")
        {
            int key;
            cin &gt;&gt; key;
            root = deleteNode(root, key);
        }
        else
        {
            vector&lt;int&gt; res;
            inorder(root, res);
            for (auto t : res)
                cout &lt;&lt; t &lt;&lt; ' ';
            cout &lt;&lt; '\n';
            res.clear();
            preorder(root, res);
            for (auto t : res)
                cout &lt;&lt; t &lt;&lt; ' ';
            cout &lt;&lt; '\n';
        }
    }
    //system("pause");
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f97ccc43d782d033741f855f68970940/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ADS1256&#43;STM32程序详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44db80e1a9fe8b2ba471336528a083bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">E2E 端到端保护</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>