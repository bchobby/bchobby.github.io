<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nginx负载均衡核心模块(upstream和proxy模块)及常用参数介绍 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="nginx负载均衡核心模块(upstream和proxy模块)及常用参数介绍" />
<meta property="og:description" content="前言 环境：centos nginx 1.18.0
以下所说的反向代理服务器和负载均衡服务器其实是一个意思，因为nginx做反向代理的时候本质上做到了负载均衡的效果。
upstream模块 nginx的负载均衡功能依赖于http_upstream_module模块，所支持的代理方式包括proxy_pass、fastcgi_pass、memcached_pass等。
http_upstream_module模块允许nginx定义一组或多组节点服务器组，使用时可以通过proxy_pass代理方式把网站请求发送到事先定义好的对应upstream组名上，具体的写法为：proxy_pass http://www.server_pools，其中www.server_pools就是一个upstream节点服务器组名。
upstream模块语法：
upstream 组名{ server IP:port 参1,参2，....; server IP:port 参1,参2，....; } 说明：upstream模块放在http里面，语法结构中upstream是关键字，接着定义一个组名，server也是关键字，后面是IP或者域名，再是参数。
upstream范例如下：
upstream www.server_pools{	#www.server_pools是集群组名 server 10.0.0.1:80 weight=15;	#可以写IP或域名，指定端口，如果不指定端口就认80端口 server 10.0.0.2:80 weight=15;	#weight表示权重，后面会讲 } upstream www.server_pools{	#www.server_pools是集群组名 server www.fujiseiko.com:80;	#域名，DNS或负载均衡服务器必须做解析 server 10.0.0.2:80 backup;	#backup表示备用服务器,除非其它都挂了，否则不会请求不会到这台服务器 server 10.0.0.3:80 max_fails=3,fail_timeout=15s;	#表示在15秒内尝试重连3次，3次都失败就认为服务器不可用，请求就不会转发到这台服务器 } 下面讲一下server标签的一些常用参数：
weight	表示权重，其书写规则为weight=1，默认就等于1，权重数值越大表示接受的请求比例就越大； max_fails 表示nginx在fail_timeout 参数设置的持续时间内尝试连接后端主机失败次数，则认为服务器在fail_timeout参数设置的持续时间内不可用 。其书写规则为max_fails=2；默认max_fails=1，零值将禁用对尝试的记帐。认为失败的尝试由 proxy_next_upstream， fastcgi_next_upstream， uwsgi_next_upstream， scgi_next_upstream， memcached_next_upstream和 grpc_next_upstream 指令定义。 fail_timeout	表示在指定次数的不成功尝试与服务器通信的时间范围内，应考虑服务器不可用，其书写规则为fail_timeout=15s，默认该参数为fail_timeout=10s； down	表示将服务器标记为永久不可用； backup	表示当前服务器节点是备用机，只有在其他的服务器都宕机以后，请求才会被转发到这个备用服务器上； upstream模块的调度算法 我们知道，定义一个upstream模块的时候，定义了很多server主机，那么LB服务器是如何决定将请求调度给哪一个后端主机的呢？这就涉及到调度算法的问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/83322897530e71799f839d8a48b4fae2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-24T17:25:31+08:00" />
<meta property="article:modified_time" content="2022-10-24T17:25:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">nginx负载均衡核心模块(upstream和proxy模块)及常用参数介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>环境：<code>centos nginx 1.18.0</code><br> 以下所说的反向代理服务器和负载均衡服务器其实是一个意思，因为<code>nginx</code>做反向代理的时候本质上做到了负载均衡的效果。</p> 
<h3><a id="upstream_4"></a>upstream模块</h3> 
<p><code>nginx</code>的负载均衡功能依赖于<code>http_upstream_module</code>模块，所支持的代理方式包括<code>proxy_pass、fastcgi_pass、memcached_pass</code>等。<br> <code>http_upstream_module</code>模块允许<code>nginx</code>定义一组或多组节点服务器组，使用时可以通过<code>proxy_pass</code>代理方式把网站请求发送到事先定义好的对应<code>upstream</code>组名上，具体的写法为：<code>proxy_pass http://www.server_pools</code>，其中<code>www.server_pools</code>就是一个<code>upstream</code>节点服务器组名。</p> 
<p>upstream模块语法：</p> 
<pre><code class="prism language-bash">upstream 组名<span class="token punctuation">{<!-- --></span>
	server IP:port 参1,参2，<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">;</span>
	server IP:port 参1,参2，<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>说明：<code>upstream</code>模块放在<code>http</code>里面，语法结构中<code>upstream</code>是关键字，接着定义一个组名，<code>server</code>也是关键字，后面是IP或者域名，再是参数。</p> 
<p>upstream范例如下：</p> 
<pre><code class="prism language-bash">upstream www.server_pools<span class="token punctuation">{<!-- --></span>				<span class="token comment">#www.server_pools是集群组名</span>
	server <span class="token number">10.0</span>.0.1:80  <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">;</span>		<span class="token comment">#可以写IP或域名，指定端口，如果不指定端口就认80端口</span>
	server <span class="token number">10.0</span>.0.2:80  <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">;</span>		<span class="token comment">#weight表示权重，后面会讲</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-bash">upstream www.server_pools<span class="token punctuation">{<!-- --></span>				<span class="token comment">#www.server_pools是集群组名</span>
	server www.fujiseiko.com:80<span class="token punctuation">;</span>		<span class="token comment">#域名，DNS或负载均衡服务器必须做解析</span>
	server <span class="token number">10.0</span>.0.2:80   backup<span class="token punctuation">;</span>		<span class="token comment">#backup表示备用服务器,除非其它都挂了，否则不会请求不会到这台服务器</span>
	server <span class="token number">10.0</span>.0.3:80 <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">3</span>,fail_timeout<span class="token operator">=</span>15s<span class="token punctuation">;</span>	<span class="token comment">#表示在15秒内尝试重连3次，3次都失败就认为服务器不可用，请求就不会转发到这台服务器</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面讲一下server标签的一些常用参数：</p> 
<pre><code class="prism language-bash">weight		表示权重，其书写规则为weight<span class="token operator">=</span><span class="token number">1</span>，默认就等于1，权重数值越大表示接受的请求比例就越大；
max_fails 	表示nginx在fail_timeout 参数设置的持续时间内尝试连接后端主机失败次数，则认为服务器在fail_timeout参数设置的持续时间内不可用 。其书写规则为max_fails<span class="token operator">=</span><span class="token number">2</span>；默认max_fails<span class="token operator">=</span><span class="token number">1</span>，零值将禁用对尝试的记帐。认为失败的尝试由 proxy_next_upstream， fastcgi_next_upstream， uwsgi_next_upstream， scgi_next_upstream， memcached_next_upstream和 grpc_next_upstream 指令定义。
fail_timeout	表示在指定次数的不成功尝试与服务器通信的时间范围内，应考虑服务器不可用，其书写规则为fail_timeout<span class="token operator">=</span>15s，默认该参数为fail_timeout<span class="token operator">=</span>10s；
down		表示将服务器标记为永久不可用；
backup		表示当前服务器节点是备用机，只有在其他的服务器都宕机以后，请求才会被转发到这个备用服务器上；
</code></pre> 
<h3><a id="upstream_42"></a>upstream模块的调度算法</h3> 
<p>我们知道，定义一个upstream模块的时候，定义了很多server主机，那么LB服务器是如何决定将请求调度给哪一个后端主机的呢？这就涉及到调度算法的问题。<br> 调度算法可以分为静态调度算法和动态调度算法，所谓静态调度算法就是指负载均衡服务器根据自身设定的规则进行分配，不需要考虑后端节点服务的情况，如rr、wrr、ip_hash等调度算法，而动态调度就是指根据后端节点服务器的当前状态来决定是否分发请求，如least_conn、fair等调度算法。<br> 下面介绍一下常用的调度算法：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>、rr轮询（Round Robin，默认调度算法，静态调度算法）
	每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除；
<span class="token number">2</span>、wrr轮询（weight Round Robin，权重轮询，静态调度算法）
	在轮询算法的基础上加上权重weight，权重轮询和访问成正比，权重值越大，转发的请求也就越多；
<span class="token number">3</span>、ip_hash（静态调度算法<span class="token punctuation">)</span>
	每个请求按访问的IP的hash结果分配，当新的请求到达时，先将其客户端IP通过哈希算法希出一个值，在随后请求中客户端ip的哈希值只要相同，就会被分值至同一台服务器，该调度算法可以解决网页session共享问题，但有时会导致请求分配不均和无法保证相对的负载均衡；
	注意：当调度算法是ip_hash 时，后端服务器中负载均衡调度中的状态不能有weight和backup，即使有也不会生效。
<span class="token number">4</span>、fair（动态调度算法）
	按照后端服务器节点的响应时间来智能分配请求，响应时间短的优先分配，这中调度算法是更加智能的算法，这种算法可以依据页面大小和加载时间长短智能的进行负载均衡，nginx本身不支持fair，需要下载nginx的upstream_fair模块；
<span class="token number">5</span>、least_conn（动态调度算法）
	根据后端节点的连接数来决定分配情况，哪个后端节点连接数少就连接哪个；
<span class="token number">6</span>、url_hash
	与ip_hash调度算法类似，但url_hash是按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，这当后端服务器是缓存服务器时效果更显著；
</code></pre> 
<h3><a id="upstream_63"></a>upstream模块指定调度算法</h3> 
<p>直接在大括号内指定调度算法即可：</p> 
<pre><code class="prism language-bash">upstream 组名<span class="token punctuation">{<!-- --></span>
	ip_hash<span class="token punctuation">;</span>					<span class="token comment">#指定调度算法，不指定的话默认rr轮询</span>
	server IP:port <span class="token punctuation">;</span>
	server IP:port <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="http_proxy_module_73"></a>http_proxy_module模块介绍</h3> 
<p>http_proxy_module模块可以将请求转发到另一台服务器，在实际的反向代理工作中，会通过location功能匹配指定的URL，然后把接收到的符合匹配的URL的请求通过proxy_pass指令抛给定义好的upstream服务器组池，下面是proxy_pass指令的一些使用案例；</p> 
<pre><code class="prism language-bash"> <span class="token number">1</span>、将匹配URL为ngme的请求抛给http://127.0.0.1/remote/
	 location /name/<span class="token punctuation">{<!-- --></span>
	 proxy_pass http://127.0.0.1/remote/<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token number">2</span>、将匹配URL为some/path的请求抛给http://127.0.0.1/
	 location /some/path/<span class="token punctuation">{<!-- --></span>
	 proxy_pass http://127.0.0.1/<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token number">3</span>、将匹配URL为name的请求应用指定的rewrite规则，然后抛给http://127.0.0.1/
	 location /some/path/<span class="token punctuation">{<!-- --></span>
	 	rewrite /name/<span class="token punctuation">(</span><span class="token punctuation">[</span>^/ <span class="token punctuation">]</span>+ <span class="token punctuation">)</span> /user?name<span class="token operator">=</span><span class="token variable">$1</span> <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
	 proxy_pass http://127.0.0.1/<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>nginx功能的代理功能是是通过http proxy模块来实现的。默认在安装Nginx是已经安装了http proxy模块，可以直接使用，http proxy模块参数如下：</p> 
<pre><code class="prism language-bash">proxy_set_header
设置http请求header项传给后端服务节点，例如：可实现让代理后端的服务节点获取访问客户端用户的真实IP地址，以及让后端服务器得知访问的哪一个server虚拟主机

client_body_buffer_size
用于指定客户端请求主体缓冲区大小，此处如果了解前面的http请求包的原理就好理解了

proxy_connect_timeout
表示反向代理与后端节点服务器连接的超时时间，即发起握手等候相应超时时间

proxy_send_timeout
表示代理后端服务器的数据回传时间，即在规定时间之内后端服务器必须传完所有的数据，否则Nginx将断开这个连接

proxy_read_timeout
设置Nginx从代理的 后端服务器获取信息的时间，表示连接建立成功后，Nginx等待后端服务器的相应时间，其实是Nginx已经进入后端的排队之中等候处理的时间

proxy_buffer_size
设置缓存区大小，默认该缓存区等于指令proxy_buffer设置的大小

proxy_buffer
设置缓存区的数量和大小，Nginx从代理的后端服务器获取的响应信息，会放置到缓存区

proxy_busy_buffer_size
用于设置系统很忙是可以使用的proxy_buffer大小，官方推荐大小为proxy_buffers*2

proxy_temp_file_write_size
指定proxy缓冲临时文件的大小
</code></pre> 
<p>这里重点将一下proxy_set_header这个参数，为什么呢？因为这个参数功能很强大，我们先来假设后端节点有这样两台服务器web01，web02，<br> web01的主配置文件nginx.conf是带有两个或多个虚拟主机的，即这样写的：</p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> nginx.conf
user  nginx<span class="token punctuation">;</span>
worker_processes  <span class="token number">1</span><span class="token punctuation">;</span>
events <span class="token punctuation">{<!-- --></span>
    worker_connections  <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
http <span class="token punctuation">{<!-- --></span>
    include       mime.types<span class="token punctuation">;</span>
    default_type  application/octet-stream<span class="token punctuation">;</span>
    sendfile        on<span class="token punctuation">;</span>
    keepalive_timeout  <span class="token number">65</span><span class="token punctuation">;</span>
   	server <span class="token punctuation">{<!-- --></span>
        listen       <span class="token number">80</span><span class="token punctuation">;</span>
        server_name  bbs.cnblogs.com<span class="token punctuation">;</span>					<span class="token comment">#第1个虚拟主机bbs.cnblogs.com</span>
        location / <span class="token punctuation">{<!-- --></span>
            root   html/cnblogs<span class="token punctuation">;</span>
            index  index.html index.htm<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
     server <span class="token punctuation">{<!-- --></span>
        listen       <span class="token number">80</span><span class="token punctuation">;</span>
        server_name  www.fujiseiko.com<span class="token punctuation">;</span>					<span class="token comment">#第2个虚拟主机www.fujiseiko.com</span>
        location / <span class="token punctuation">{<!-- --></span>
            root   html/fujiseiko<span class="token punctuation">;</span>
            index  index.html index.htm<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>web02的主配置文件nginx.conf也是类似这些写，再在各自的index文件里写点内容；</p> 
<p>接下来开始配置LB负载均衡服务器（即nginx反向代理服务器），LB的nginx.conf配置如下：</p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> nginx.conf
user  nginx<span class="token punctuation">;</span>
worker_processes  <span class="token number">1</span><span class="token punctuation">;</span>
events <span class="token punctuation">{<!-- --></span>
    worker_connections  <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
http <span class="token punctuation">{<!-- --></span>
    include       mime.types<span class="token punctuation">;</span>
    default_type  application/octet-stream<span class="token punctuation">;</span>
    sendfile        on<span class="token punctuation">;</span>
    keepalive_timeout  <span class="token number">65</span><span class="token punctuation">;</span>
    upstream server_pools<span class="token punctuation">{<!-- --></span>								<span class="token comment">#定义upstream 服务器池</span>
		server <span class="token number">192.168</span>.1.120:80 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>				<span class="token comment">#这是web01	</span>
		server <span class="token number">192.168</span>.1.121:80 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>				<span class="token comment">#这是web02	</span>
	<span class="token punctuation">}</span>
    server <span class="token punctuation">{<!-- --></span>
        listen       <span class="token number">80</span><span class="token punctuation">;</span>
        server_name  www.fujiseiko.com<span class="token punctuation">;</span>					<span class="token comment">#虚拟主机www.fujiseiko.com</span>
        location / <span class="token punctuation">{<!-- --></span>
           proxy_pass http://server_pools<span class="token punctuation">;</span>				<span class="token comment">#这里只写了一句proxy_pass</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>以上，配置完域名解析等工作，启动nginx没有问题的话，客户开始访问<code>http://www.fujiseiko.com</code>，得到了结果，但是这个结果是虚拟主机<code>bbs.cnblogs.com</code>的网页，看出问题了吗？我明明是想要访问<code>www.fujiseiko.com</code>网站的呀，按理来说负载均衡服务器应该请求到后端服务器nginx里配置的<code>www.fujiseiko.com</code>虚拟主机的呀，为什么现在出现的网站却是<code>bbs.cnblogs.com</code>的网页呢？</p> 
<p>问题就在于是：客户访问<code>http://www.fujiseiko.com</code>网站时确实是带了<code>www.fujiseiko.com</code>主机头请求的负载均衡代理服务器，但是反向代理服务器在请求节点池中的服务器时，默认并没有在请求头中告诉后端节点服务器要找你的哪一台虚拟主机，所以后端节点服务器在发现并没有主机头信息的时候就默认把第一台虚拟主机发给了反向代理服务器，反向代理服务器就把信息返回给了前端页面。</p> 
<p>如何解决呢？解决办法就是，当反向代理服务器向节点服务器发起请求的时候，携带主机头信息，非常明确的告知后端节点服务器要访问的是你的哪一台虚拟主机，配置非常简单，如下：</p> 
<pre><code class="prism language-bash">location / <span class="token punctuation">{<!-- --></span>
           proxy_pass http://server_pools<span class="token punctuation">;</span>
           proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>		<span class="token comment">#就是添加这一句，让反向代理服务器携带主机头信息明确访问的是节点服务器的哪一个虚拟主机</span>
           
        <span class="token punctuation">}</span>
</code></pre> 
<p>我们再来看一个问题，当Windows访问反向代理服务器时，节点服务器web01的日志信息会是什么样子的，答案是web01服务器记录的IP是反向代理服务器的IP，并没有记录真实的客户端IP，如何解决呢？加参数<code>proxy_set_header X-real-ip $remote_addr</code> 或<code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for</code>，如下，在反向代理服务器的nginx.conf配置文件添加参数：</p> 
<pre><code class="prism language-bash"> location / <span class="token punctuation">{<!-- --></span>
           proxy_pass http://server_pools<span class="token punctuation">;</span>
           proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>		
           proxy_set_header  X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>	<span class="token comment">#用于传递真实客户端的IP地址</span>
           <span class="token comment">#proxy_set_header X-real-ip $remote_addr;						#也可以加这个，两者能传递真实客户端的IP地址</span>
           <span class="token punctuation">}</span>
</code></pre> 
<p>这样反向代理服务器在向后端节点服务器发起请求的主机头信息中就带有客户端的IP的字段信息了，但是这样还不够，后端节点服务器还需要设置日志格式添加<code>$http_x_forwarded_for</code>，下面以web01节点的日志格式为例：</p> 
<pre><code class="prism language-bash">log_format  main  <span class="token string">'$remote_addr - $remote_user [$time_local] "$request" '</span>
                      <span class="token string">'$status $body_bytes_sent "$http_referer" '</span>
                      <span class="token string">'"$http_user_agent" "$http_x_forwarded_for"'</span><span class="token punctuation">;</span>
</code></pre> 
<p>就是这个<code>$http_x_forwarded_for</code>，设置完成后就会显示真实客户端Windows的IP地址，当然 <code>$remote_addr</code> 值还是反向代理服务器的IP，不需要可以删除这个<code>$remote_addr</code>变量。</p> 
<h3><a id="_215"></a>总结</h3> 
<p>直接看配置吧</p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> nginx.conf
user  nginx<span class="token punctuation">;</span>
worker_processes  <span class="token number">1</span><span class="token punctuation">;</span>
events <span class="token punctuation">{<!-- --></span>
    worker_connections  <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
http <span class="token punctuation">{<!-- --></span>
    include       mime.types<span class="token punctuation">;</span>
    default_type  application/octet-stream<span class="token punctuation">;</span>
    sendfile        on<span class="token punctuation">;</span>
    keepalive_timeout  <span class="token number">65</span><span class="token punctuation">;</span>
    upstream server_pools<span class="token punctuation">{<!-- --></span>								<span class="token comment">#定义upstream 服务器池</span>
    	wrr<span class="token punctuation">;</span>											<span class="token comment">#定义调度策略wrr为按权重轮询，不写材料默认rr轮询</span>
		server <span class="token number">192.168</span>.1.120:80 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>				<span class="token comment">#这是web01	</span>
		server <span class="token number">192.168</span>.1.121:80 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>				<span class="token comment">#这是web02	</span>
	<span class="token punctuation">}</span>
    server <span class="token punctuation">{<!-- --></span>
        listen       <span class="token number">80</span><span class="token punctuation">;</span>
        server_name  www.fujiseiko.com<span class="token punctuation">;</span>					<span class="token comment">#虚拟主机www.fujiseiko.com</span>
        location / <span class="token punctuation">{<!-- --></span>
           proxy_pass http://server_pools<span class="token punctuation">;</span>				<span class="token comment">#这三个参数下面讲</span>
           proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>	
           proxy_set_header X-Forwarded-For <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

proxy_pass http://server_pools<span class="token punctuation">;</span>					<span class="token comment">#请求转发到upstream定义的server_pools中去</span>
proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>						<span class="token comment">#反向代理服务器请求节点服务器时，在http请求头中加入host字段信息，用以指定访问的是节点服务器的哪一个虚拟主机，当节点服务器存在多个虚拟主机时，该参数非常重要；</span>
proxy_set_header X-Forwarded-For <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>		<span class="token comment">#反向代理服务器请求节点服务器时，在http请求头中加入X-Forwarded-For字段信息,这样后端节点服务器的日志就能正常记录得客户端的ip地址信息了，而不是记录代理服务器的ip,这需要在节点服务器的日志添加$http_x_forwarded_for，为了简单化主配置文件，可以使用include proxy.conf的方式把配置参数添加进来。</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/168c739713d0b45cf79a18a09a14d9ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">强化学习自然策略梯度Natural Policy Gradient推导</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1582b8c29bff176caf3fb4be0df21e5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MCU不用定时器实现非阻塞延时</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>