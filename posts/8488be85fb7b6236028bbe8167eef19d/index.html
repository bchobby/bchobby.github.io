<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SVA断言 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SVA断言" />
<meta property="og:description" content="目录 Assertion介绍什么是assertion？断言覆盖率断言语言的发展与进步类型划分立即断言并行断言并行断言的执行阶段assertion，property，sequencesequences sequence定义基本操作符号and操作符号intersect操作符号or操作符号first_match操作符号throughout操作符号within操作符号if操作符号检测序列的终点局部变量调用方法访问采样方法系统函数和方法 Property使用介绍时钟声明绑定expect语句 Assertion介绍 什么是assertion？ 用来与设计功能和时序做比较的属性描述。断言可以用来完成：
1、检查设计的内容；
2、提高设计的可视度和调试能力；
3、检查设计特性在验证中是否被覆盖。可读性好，因此也可用来服务于设计文档。用来检查算法模型的断言在形式验证中可以穷尽计算，找出可能的违例。可以自由地打开或关闭。一小部分子集甚至可以用来综合或移植到emulation中，用来完成跨平台的移植。 断言覆盖率 仿真工具可以报告断言覆盖率，指示哪些断言没有被触发；帮助检查是否验证计划捕捉到了所有需要的覆盖率；断言覆盖率和功能覆盖率可以共同量化验证进度。 断言语言的发展与进步 Verilog不支持断言，因此需要写过程语句来坐替代；SVA是由一些支持断言的语言进化而来，作为SV相对独立的语言分支。 类型划分 立即断言（immediate assertion）：非时序的；执行时如同过程语句；可以在initial/always过程块或task/function中使用。并行断言（concurrent assertion）：时序性的；关键词property用于区分立即断言和并行断言；并行是因为它们与设计模块一同并行执行。 立即断言 [name:] assert (expression) [pass_statement] [else fail_statement]
time t; always @(posedge clk) if(staet == REQ) assert (req1 || req2) else begin t = $time; #5 $error(&#34;assert failed at time %0t&#34;, t); end //如果状态为REQ，但req1或req2均不为1时，断言将失败 立即断言可以结合$fatal/$error/$warning/$info给出不同严重级别的消息提示。
always @(state) assert (state == $onehot) else $fatal; 并行断言 base_rule1: assert property (cont_prop(rst,in1,in2)) pass_stat else fail_stat;
property req_grant_prop @(posedge clk) req ##2 gnt ##1 !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/8488be85fb7b6236028bbe8167eef19d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-25T21:49:07+08:00" />
<meta property="article:modified_time" content="2022-08-25T21:49:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SVA断言</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#Assertion_6" rel="nofollow">Assertion介绍</a></li><li><ul><li><a href="#assertion_7" rel="nofollow">什么是assertion？</a></li><li><a href="#_18" rel="nofollow">断言覆盖率</a></li><li><a href="#_22" rel="nofollow">断言语言的发展与进步</a></li><li><a href="#_25" rel="nofollow">类型划分</a></li><li><a href="#_28" rel="nofollow">立即断言</a></li><li><a href="#_46" rel="nofollow">并行断言</a></li><li><a href="#_58" rel="nofollow">并行断言的执行阶段</a></li><li><a href="#assertionpropertysequence_65" rel="nofollow">assertion，property，sequence</a></li><li><a href="#sequences_94" rel="nofollow">sequences</a></li></ul> 
  </li><li><a href="#sequence_126" rel="nofollow">sequence定义</a></li><li><ul><li><a href="#_127" rel="nofollow">基本操作符号</a></li><li><a href="#and_135" rel="nofollow">and操作符号</a></li><li><a href="#intersect_147" rel="nofollow">intersect操作符号</a></li><li><a href="#or_150" rel="nofollow">or操作符号</a></li><li><a href="#first_match_160" rel="nofollow">first_match操作符号</a></li><li><a href="#throughout_170" rel="nofollow">throughout操作符号</a></li><li><a href="#within_183" rel="nofollow">within操作符号</a></li><li><a href="#if_191" rel="nofollow">if操作符号</a></li><li><a href="#_215" rel="nofollow">检测序列的终点</a></li><li><a href="#_240" rel="nofollow">局部变量</a></li><li><a href="#_265" rel="nofollow">调用方法</a></li><li><a href="#_275" rel="nofollow">访问采样方法</a></li><li><a href="#_321" rel="nofollow">系统函数和方法</a></li></ul> 
  </li><li><a href="#Property_354" rel="nofollow">Property使用</a></li><li><ul><li><a href="#_355" rel="nofollow">介绍</a></li><li><a href="#_400" rel="nofollow">时钟声明</a></li><li><a href="#_456" rel="nofollow">绑定</a></li><li><a href="#expect_471" rel="nofollow">expect语句</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="Assertion_6"></a>Assertion介绍</h2> 
<h3><a id="assertion_7"></a>什么是assertion？</h3> 
<ul><li>用来<strong>与设计功能和时序做比较的属性描述</strong>。</li><li>断言可以用来完成：<br> 1、<strong>检查设计的内容</strong>；<br> 2、<strong>提高设计的可视度和调试能力</strong>；<br> 3、<strong>检查设计特性在验证中是否被覆盖</strong>。</li><li>可读性好，因此也可用来服务于设计文档。</li><li>用来检查算法模型的断言在形式验证中可以穷尽计算，找出可能的违例。</li><li>可以<strong>自由地打开或关闭</strong>。</li><li>一小部分子集甚至可以用来综合或移植到emulation中，用来完成跨平台的移植。</li></ul> 
<h3><a id="_18"></a>断言覆盖率</h3> 
<ul><li>仿真工具可以报告断言覆盖率，指示哪些断言没有被触发；</li><li>帮助检查是否验证计划捕捉到了所有需要的覆盖率；</li><li>断言覆盖率和功能覆盖率可以共同量化验证进度。</li></ul> 
<h3><a id="_22"></a>断言语言的发展与进步</h3> 
<ul><li>Verilog不支持断言，因此需要写过程语句来坐替代；</li><li>SVA是由一些支持断言的语言进化而来，作为SV相对独立的语言分支。</li></ul> 
<h3><a id="_25"></a>类型划分</h3> 
<ul><li><strong>立即断言</strong>（immediate assertion）：<strong>非时序</strong>的；执行时如同过程语句；可以在<strong>initial/always</strong>过程块或<strong>task/function</strong>中使用。</li><li><strong>并行断言</strong>（concurrent assertion）：<strong>时序性</strong>的；关键词<strong>property</strong>用于区分立即断言和并行断言；并行是因为它们<strong>与设计模块一同并行执行</strong>。</li></ul> 
<h3><a id="_28"></a>立即断言</h3> 
<p><code>[name:] assert (expression) [pass_statement] [else fail_statement]</code></p> 
<pre><code class="prism language-c">time t<span class="token punctuation">;</span>
always @<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>staet <span class="token operator">==</span> REQ<span class="token punctuation">)</span>
		<span class="token function">assert</span> <span class="token punctuation">(</span>req1 <span class="token operator">||</span> req2<span class="token punctuation">)</span>
	<span class="token keyword">else</span> begin
		t <span class="token operator">=</span> $time<span class="token punctuation">;</span>
		#<span class="token number">5</span> $<span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"assert failed at time %0t"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	end
<span class="token comment">//如果状态为REQ，但req1或req2均不为1时，断言将失败</span>
</code></pre> 
<p>立即断言可以结合<code>$fatal/$error/$warning/$info</code>给出不同严重级别的消息提示。</p> 
<pre><code class="prism language-c">always @<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
	<span class="token function">assert</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> $onehot<span class="token punctuation">)</span> <span class="token keyword">else</span> $fatal<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_46"></a>并行断言</h3> 
<p><code>base_rule1: assert property (cont_prop(rst,in1,in2)) pass_stat else fail_stat;</code></p> 
<pre><code class="prism language-c">property req_grant_prop
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> req ##<span class="token number">2</span> gnt ##<span class="token number">1</span> <span class="token operator">!</span>req ## <span class="token operator">!</span>gnt<span class="token punctuation">;</span>
endproperty
assert property req_grant_prop <span class="token keyword">else</span> $<span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Req-Gnt Protocol violoation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Request-Grant协议描述：request拉高，两个周期后grant拉高</span>
<span class="token comment">//一个周期后request拉低，一个周期后grant拉低</span>
</code></pre> 
<p>并行断言只会在<strong>时钟边沿</strong>激活，<strong>变量的值是采样到的值</strong>。<br> <img src="https://images2.imgbox.com/cd/5d/isNpHi0k_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_58"></a>并行断言的执行阶段</h3> 
<p>并行断言的执行：</p> 
<ul><li>在preponed阶段采样稳定的变量值；</li><li>在obeserve阶段执行并行断言；</li><li>在reactive区域执行pass/fail语句。<br> 通过这种方式可以保证并行断言执行会采样稳定的设计信号变量。<br> <img src="https://images2.imgbox.com/28/48/5reFh2KI_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="assertionpropertysequence_65"></a>assertion，property，sequence</h3> 
<ul><li>assertion可以直接包含一个property；</li><li>assertion也可以清晰地独立声明property；</li><li>在property内部可以有条件地关闭。</li></ul> 
<pre><code class="prism language-c">assert <span class="token function">property</span><span class="token punctuation">(</span>@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>
	disable <span class="token function">iff</span> <span class="token punctuation">(</span><span class="token operator">!</span>rset<span class="token punctuation">)</span>
	a <span class="token operator">|=</span><span class="token operator">&gt;</span> b ##<span class="token number">1</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
assert <span class="token function">property</span><span class="token punctuation">(</span>my_prop<span class="token punctuation">)</span><span class="token punctuation">;</span>
property my_prop<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>
		disable <span class="token function">iff</span><span class="token punctuation">(</span><span class="token operator">!</span>reset<span class="token punctuation">)</span>
		a <span class="token operator">|=</span><span class="token operator">&gt;</span> b ##<span class="token number">1</span> c<span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li>property块可直接包含sequence；</li><li>复杂的property也可以独立声明多个sequence。</li></ul> 
<pre><code class="prism language-c">sequence s1<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> a ##<span class="token number">1</span> b ##<span class="token number">1</span> c<span class="token punctuation">;</span>
endsequence
sequence s2<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> a ##<span class="token number">1</span> c<span class="token punctuation">;</span>
endsequence
property p1<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> disable <span class="token function">iff</span> <span class="token punctuation">(</span><span class="token operator">!</span>reset<span class="token punctuation">)</span>
	s1 <span class="token operator">|=</span><span class="token operator">&gt;</span> s2<span class="token punctuation">;</span>
endproperty
</code></pre> 
<h3><a id="sequences_94"></a>sequences</h3> 
<ul><li>sequence用来表示在<strong>一个或多个时钟周期内的时序描述</strong>；</li><li>是property的<strong>基本构建模块</strong>，并经过组合来描述复杂的功能属性。</li></ul> 
<p>sequence用来提供下列的场景描述：</p> 
<ul><li>第一个时钟周期，第一个表达式成立；</li><li>接下来在若干时钟周期后，第二个表达式也成立；</li><li>以此类推，在接下来若干时钟周期，后续的表达式也成立。</li></ul> 
<p>sequence可以在<strong>module、interface、program、clocking块和package</strong>中声明。</p> 
<ul><li>sequence可以提供形式参数，提高复用性：</li></ul> 
<pre><code class="prism language-c">sequence <span class="token function">s20_1</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>en<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">!</span>frame <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>data<span class="token operator">==</span>data_bus<span class="token punctuation">)</span><span class="token punctuation">)</span> ##<span class="token number">1</span> <span class="token punctuation">(</span>c_be<span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> en<span class="token punctuation">)</span><span class="token punctuation">;</span>
endsequence
</code></pre> 
<ul><li>蕴含(implication)操作符用来表示如果property中<strong>左边的先行算子(antecedent)成立</strong>，那么property右边的<strong>后续算子(consequent)才会被计算</strong>。</li><li>如果<strong>先行算子不成功，那么整个属性就默认地被认为成功</strong>，即“<strong>空成功</strong>”(vacuous success).</li><li>蕴含结构<strong>只能用在属性定义中</strong>，不能在序列中使用。</li></ul> 
<p><strong>交叠蕴含(|-&gt;)</strong>:</p> 
<ul><li>如果条件<strong>满足</strong>，则<strong>评估其后续算子序列</strong>；</li><li>如果条件<strong>不满足</strong>，则表现为<strong>空成功</strong>，不执行后续算子。<br> <img src="https://images2.imgbox.com/9a/ea/TFNs8LaO_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>非交叠蕴含(|=&gt;)</strong>：</p> 
<ul><li>如果条件满足，则在<strong>下一个周期</strong>评估其后续算子序列；</li><li>如果条件不满足，则表现为空成功，不执行后续算子。<br> <img src="https://images2.imgbox.com/be/e5/P7BVe2tl_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="sequence_126"></a>sequence定义</h2> 
<h3><a id="_127"></a>基本操作符号</h3> 
<ul><li><code>##</code>表示<strong>周期延迟</strong>符号，如##n表示在n个时钟周期后，<strong>##0表示在当前周期</strong>，即交叠周期。</li><li><code>##[min:max]</code>表示在一个范围内的时钟周期延迟。min和max必须是<strong>非负数</strong>，序列会在从min到max时间窗口中最早的时间来匹配。</li><li><code>$</code>用来表示<strong>无穷大的周期（在仿真结束前）</strong>，但一般不建议这么做，这会增大仿真评估序列的负担。</li><li>事件可以通过<code>[*n]</code>操作符来表示<strong>重复</strong>，n须为<strong>非负数且不能为$</strong>；类似的，也可使用<code>[*m:n]</code>表示一定范围内的重复事件。</li><li><code>[=m]</code>用来表示一个事件的连续性，需要重复发生m次，但并<strong>不需要在连续周期内发生</strong>。类似的，也可使用<code>[=m:n]</code>表示从最小m到最大n的重复发生的<strong>非连续周期次数</strong>。</li><li><code>a[*0]</code>用来表示<strong>没有在任何正数时钟周期内有效</strong>。<br> <img src="https://images2.imgbox.com/d1/52/ODPkCtV3_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="and_135"></a>and操作符号</h3> 
<ul><li>and用来表示<strong>两个序列需要保持匹配</strong>；</li><li>用法：<code>SEQ1 and SEQ2</code></li></ul> 
<p>下列情形将满足此操作符：</p> 
<ul><li>在从同一个起始点开始后，seq1和seq2均满足；</li><li>满足的时刻发生在两个序列都满足的周期，即稍晚序列的满足时刻；</li><li>两个序列的<strong>满足时间可以不同</strong>。<br> <img src="https://images2.imgbox.com/3f/74/cUBUH4vZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/53/ed/FTtTgV1w_o.png" alt="在这里插入图片描述"></li><li>如果操作符<strong>两边的序列都是用来衡量采样信号</strong>而非事件时序，那么要求在相同周期内，and左右两边的序列都应该满足条件。<br> <img src="https://images2.imgbox.com/31/0a/LtB3HZzG_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="intersect_147"></a>intersect操作符号</h3> 
<ul><li>与and类似，但需要两边的序列时序<strong>在同一时钟周期内匹配</strong>。<br> <img src="https://images2.imgbox.com/b5/86/L17LAT2z_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="or_150"></a>or操作符号</h3> 
<ul><li>表示两个序列至少需要有一个满足；</li><li>用法：<code>SEQ1 or SEQ2</code></li></ul> 
<p>下列情形将满足此操作符：</p> 
<ul><li>seq1和seq2都从同一个时刻被触发；</li><li>最终满足seq1或seq2；</li><li>每个序列的<strong>结束时间可以不同</strong>，结束时间<strong>以序列满足的最后一个序列时间为准</strong>。<br> <img src="https://images2.imgbox.com/e4/bc/4iyAXeEP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a0/22/Betv1oYD_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="first_match_160"></a>first_match操作符号</h3> 
<ul><li>用来从多次满足的序列中<strong>选择第一次满足时刻</strong>，从而放弃其他满足的时刻。</li></ul> 
<pre><code class="prism language-c">sequence checkBusIdle<span class="token punctuation">;</span>
	<span class="token punctuation">(</span>##<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">:</span>$<span class="token punctuation">]</span> <span class="token punctuation">(</span>frame <span class="token operator">&amp;&amp;</span> irdy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
endsequence
property first_match_idle
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> <span class="token function">first_match</span><span class="token punctuation">(</span>checkBusIdle<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-&gt;</span> <span class="token punctuation">(</span>state<span class="token operator">==</span>busidle<span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<h3><a id="throughout_170"></a>throughout操作符号</h3> 
<ul><li>用来检查一个信号或一个表达式在<strong>贯穿(throughout)一个序列时是否满足要求</strong>。</li><li>用法：<strong>Sig1/Exp1 throughout Seq</strong></li><li>例如，在burst模式信号拉低以后的两个周期时，irdy/trdy也应该在连续七个周期内保持为低，同时burst模式信号也应该在这连续周期内保持为低。</li></ul> 
<pre><code class="prism language-c">sequence burst_rule1<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>
		$<span class="token function">fell</span><span class="token punctuation">(</span>burst_mode<span class="token punctuation">)</span> ##<span class="token number">0</span>
		<span class="token punctuation">(</span><span class="token operator">!</span>burst_mode<span class="token punctuation">)</span> <span class="token function">throughout</span> <span class="token punctuation">(</span>##<span class="token number">2</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>trdy<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>irdy<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
endsequence
</code></pre> 
<p><img src="https://images2.imgbox.com/39/b5/FhhEfP3B_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ad/47/wF0BsdBM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="within_183"></a>within操作符号</h3> 
<ul><li>用来检查<strong>一个序列与另一个序列在部分周期长度上的重叠</strong>；</li><li>用法：<code>SEQ1 within SEQ2</code></li><li>例如，trdy需要在irday下拉的1个周期后保持7个周期为低，同时irday也将保持8个周期为低，以下序列会在第11个时钟周期满足：</li></ul> 
<pre><code class="prism language-c"><span class="token operator">!</span>trdy<span class="token punctuation">[</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token function">within</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>$fell irdy<span class="token punctuation">)</span> ##<span class="token number">1</span> <span class="token operator">!</span>irdy<span class="token punctuation">[</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/81/dwknhil5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="if_191"></a>if操作符号</h3> 
<ul><li>可以在sequence中使用<code>if...else</code></li><li>例如，当master_req为高时，下个周期req1或req2应该为高；如果req1为高，则下个周期ack1为高；如果req2为高，则下个周期ack2为高：</li></ul> 
<pre><code class="prism language-c">property master_child_reqs<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> master_req ##<span class="token number">1</span> <span class="token punctuation">(</span>req1 <span class="token operator">||</span> req2<span class="token punctuation">)</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>req1<span class="token punctuation">)</span>
		<span class="token punctuation">(</span>##<span class="token number">1</span> ack1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token punctuation">(</span>##<span class="token number">1</span> ack2<span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li>在cache访问时，如果有cache lookup满足，那么状态机的状态应该为READ_CACHE，否则应该为REQ_OUT：</li></ul> 
<pre><code class="prism language-c">property cache_hit_check
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> <span class="token punctuation">(</span>state<span class="token operator">==</span>CACHE_LOOKUP<span class="token punctuation">)</span> ##<span class="token number">1</span> <span class="token punctuation">(</span>CHit<span class="token operator">||</span>CMiss<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-&gt;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>CHit<span class="token punctuation">)</span>
		##<span class="token number">1</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> CACHE_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		##<span class="token number">1</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> REQ_OUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
assert <span class="token function">property</span><span class="token punctuation">(</span>cache_hit_check<span class="token punctuation">)</span> <span class="token keyword">else</span> $error<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_215"></a>检测序列的终点</h3> 
<ul><li>用法：<code>SEQ.ended</code></li><li><strong>在某一时刻，序列如果及时抵达终点</strong>，那么条件满足。</li><li>例如，在inst为高的下个周期，序列e1应该结束或已经结束：</li></ul> 
<pre><code class="prism language-c">sequence e1<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge sysclk<span class="token punctuation">)</span> $<span class="token function">rose</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> ##<span class="token number">1</span> proc1 ##<span class="token number">1</span> proc2<span class="token punctuation">;</span>
endsequence
sequence rule<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge sysclk<span class="token punctuation">)</span> $reset ##<span class="token number">1</span> inst ##<span class="token number">1</span> e1<span class="token punctuation">.</span>ended ##<span class="token number">1</span> branch_back<span class="token punctuation">;</span>
endsequence
</code></pre> 
<ul><li>在c拉起的下个周期，a拉低b拉高的序列也应该结束。</li></ul> 
<pre><code class="prism language-c">sequence <span class="token function">aRbseq</span> <span class="token punctuation">(</span>aFell<span class="token punctuation">,</span>bRose<span class="token punctuation">)</span><span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> $<span class="token function">fell</span><span class="token punctuation">(</span>aFell<span class="token punctuation">)</span> ##<span class="token number">1</span> $<span class="token function">rose</span><span class="token punctuation">(</span>bRose<span class="token punctuation">)</span><span class="token punctuation">;</span>
endsequence
property endCycle<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> $<span class="token function">rose</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">|=</span><span class="token operator">&gt;</span> <span class="token function">aRbseq</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span>ended<span class="token punctuation">;</span>
endproperty
<span class="token comment">//等价于</span>
$<span class="token function">rose</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>$<span class="token function">fell</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">|=</span><span class="token operator">&gt;</span>$<span class="token function">rose</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/d1/5wTijzsc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_240"></a>局部变量</h3> 
<ul><li>可以在<strong>sequence或property</strong>中使用；</li><li>这些变量会伴随着sequence、property<strong>动态创建</strong>；</li><li>每个sequence实例都会有其自己的变量拷贝。</li></ul> 
<p>例如，在rdDone拉高后，读出的cache_rd_data会在2个周期后，在其基础上加1，并作reg_wr_data写入。</p> 
<pre><code class="prism language-c">sequence rd_cache_done<span class="token punctuation">;</span>
	##<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">]</span> rdDone<span class="token punctuation">;</span>
endsequence
sequence check_reg_wr_data<span class="token punctuation">;</span>
	<span class="token keyword">int</span> local_data<span class="token punctuation">;</span>
	<span class="token punctuation">(</span>rd_cache_done<span class="token punctuation">,</span>local_data<span class="token operator">=</span>cache_rd_data<span class="token punctuation">)</span> ##<span class="token number">2</span> <span class="token punctuation">(</span>reg_wr_data<span class="token operator">==</span><span class="token punctuation">(</span>local_data<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
endsequence
</code></pre> 
<p>例如：如果read拉高，伴随着readId，则下一次read必须在这一次read对应的readAck返回之后才可以发起。<br> 需要先记录上一次read的readId，继而在接下来的周期，检查没有相同readId的read发起，直到对应readId的上一次read的readAck拉起，并且readAckId与之相同。</p> 
<pre><code class="prism language-c">property checkReadIdAck<span class="token punctuation">;</span>
	<span class="token keyword">int</span> loc_id<span class="token punctuation">;</span>
	<span class="token punctuation">(</span>$<span class="token function">rose</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span><span class="token punctuation">,</span>loc_id<span class="token operator">=</span>readId<span class="token punctuation">)</span> <span class="token operator">|=</span><span class="token operator">&gt;</span>
	<span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">(</span>$<span class="token function">rose</span><span class="token punctuation">(</span>read<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>readId<span class="token operator">==</span>loc_id<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token operator">*</span><span class="token number">1</span><span class="token operator">:</span>$<span class="token punctuation">]</span><span class="token punctuation">)</span> ##<span class="token number">0</span> <span class="token comment">//##0相当于&amp;&amp;</span>
	<span class="token punctuation">(</span>$<span class="token function">rose</span><span class="token punctuation">(</span>readAck<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>readAckId<span class="token operator">==</span>loc_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<h3><a id="_265"></a>调用方法</h3> 
<ul><li>在序列匹配时，可以调用task、void function和系统函数；</li><li>例如，可以在s1序列末尾，分别打印出e和f变量被采样时的数值。</li></ul> 
<pre><code class="prism language-c">sequence s1<span class="token punctuation">;</span>
	logic v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
	<span class="token punctuation">(</span>a<span class="token punctuation">,</span> v<span class="token operator">=</span>e<span class="token punctuation">)</span> ##<span class="token number">1</span>
	<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token operator">-&gt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token operator">=</span>f<span class="token punctuation">,</span>$<span class="token function">display</span><span class="token punctuation">(</span><span class="token string">"b after a with v = %h, w = %h\n"</span><span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
endsequence
</code></pre> 
<h3><a id="_275"></a>访问采样方法</h3> 
<p>一些系统函数可以用来访问指定类型的变量采样：</p> 
<ul><li>用来访问<strong>当前周期采样值</strong>；</li><li>用来访问<strong>上一个采样周期值</strong>；</li><li>用来检测<strong>采样变量的变化</strong>。</li></ul> 
<p><code>$rose(expression[, clocking_event])</code>和<code>$fell(expression)[, clocking_event])</code>用来表示<strong>与上一个采样周期相比，变量最低位是否跳变为1或0，满足条件返回1</strong>，否则返回0。<br> <code>clocking_event</code>在sequence中不需要单独提供，因为sequence中一般会指定采样时钟。<br> 例如，在req拉起的2个周期以后，ack也应该拉高：<br> <img src="https://images2.imgbox.com/8b/c3/djQsIxmb_o.png" alt="在这里插入图片描述"><br> 例如，在write_en拉低好（表征发起写访问），write_data的数据内容不应该为X：<br> <img src="https://images2.imgbox.com/b3/ea/Ikycfmha_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>$stable(expression[, clocking_event])</code>，用来表示在连续两个采样周期内，表达式的值保持不变，如果满足返回1，否则返回0。</li><li>例如，在rd_en为高时，寄存器的值应该保持不变。</li></ul> 
<pre><code class="prism language-c">property reg_rd_data_stable<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> rd_en <span class="token operator">|</span><span class="token operator">-&gt;</span> $<span class="token function">stable</span><span class="token punctuation">(</span>reg_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li><code>$pase(expr[, num_cycles][, gating_expr][, clocking_event])</code>用来访问在过去若干采样周期前的数值。</li><li>默认请客下，<code>num_cycles=1</code>，即采样1个周期前的数值。</li><li>例如，在ack拉高时的前两个周期，req信号应该为高：</li></ul> 
<pre><code class="prism language-c">property ReqCauseAck<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> $<span class="token function">rose</span><span class="token punctuation">(</span>ack<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-&gt;</span> $<span class="token function">past</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li>例如，如果当前状态是CACHE_READ，那么上一个状态不应该是CACHE_MISS（如果cache丢失，那么无法从中读取数据）：</li></ul> 
<pre><code class="prism language-c">property cache_read_chk<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> <span class="token punctuation">(</span>state<span class="token operator">==</span>CACHE_READ<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-&gt;</span> <span class="token punctuation">(</span>$<span class="token function">past</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">!=</span> CACHE_MISS<span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li><code>$rose/$fell/$stable</code>也可以在<strong>过程块语句和连续赋值中</strong>使用。</li></ul> 
<pre><code class="prism language-c">always @<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>
	TestDone <span class="token operator">&lt;=</span> stimulus_over <span class="token operator">&amp;</span> $<span class="token function">rose</span><span class="token punctuation">(</span>unit_done<span class="token punctuation">)</span><span class="token punctuation">;</span>
always @<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span>$<span class="token function">stable</span><span class="token punctuation">(</span>my_sig<span class="token punctuation">)</span><span class="token punctuation">)</span> begin
		$<span class="token function">display</span><span class="token punctuation">(</span>$time<span class="token punctuation">,</span> <span class="token string">"my_sig is stable from previous clk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	end
end
assign intr_cleared <span class="token operator">=</span> $<span class="token function">fell</span><span class="token punctuation">(</span>intr<span class="token punctuation">,</span> @<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span><span class="token punctuation">;</span>
assign intr_set <span class="token operator">=</span> $<span class="token function">rose</span><span class="token punctuation">(</span>intr<span class="token punctuation">,</span> @<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_321"></a>系统函数和方法</h3> 
<ul><li>类似于访问采样的方法，还可以使用其他一些系统函数和方法，在sequence/property/assertion中使用：</li><li><code>$countbits(expression, control_bit)</code>用来<strong>计算expression中匹配control_bit数值的位数</strong>。</li><li><code>$onehot(expression)</code>与<code>$countbits(expression, '1)</code>一致，即计算expression中<strong>为1的位数</strong>。</li><li><code>$isunknown(expression)</code>与<code>$countbits(expression, '1)==1</code>一致，即检查expression中<strong>是否有且只有1位为1</strong>。</li><li><code>$countones(expression)</code>与<code>$countbits(expression, 'x, 'z)!=0</code>一致，即检查expression中<strong>是否有x或z</strong>。</li><li>这些系统函数也可以用在一般的过程语句块和赋值语句中。</li><li>在assertion或property中，可以通过<code>disable iff</code>来给assertion做局部的条件控制。</li><li>全局控制方面，也可通过系统函数对property模块或实例做出控制：</li><li><code>$asserton</code>，默认控制，用来<strong>打开</strong>所有的assertion；</li><li><code>$assertoff</code>，<strong>暂时停止</strong>assertion运行；</li><li><code>$assertkill</code>，<strong>终止</strong>所有执行的assertion。</li></ul> 
<pre><code class="prism language-c">$<span class="token function">assertoff</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> <span class="token punctuation">[</span>list of module<span class="token punctuation">,</span> instance or assertion_identifier<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
$<span class="token function">assertkill</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> <span class="token punctuation">[</span>list of module<span class="token punctuation">,</span> instance or assertion_identifier<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
$<span class="token function">asserton</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> <span class="token punctuation">[</span>list of module<span class="token punctuation">,</span> instance or assertion_identifier<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><code>level=0</code>，表示当前模块或层次下的<strong>所有</strong>assertion；</li><li><code>level=n</code>，表示当前模块或层次下<strong>n层范围中</strong>的assertion；</li><li><code>assertion_identifier</code>表示<strong>property的名字或assertion的label</strong>。</li></ul> 
<p>例如，在reset阶段停止所有的assertion，并在其复位之后，使能所有的assertion：</p> 
<pre><code class="prism language-c">module <span class="token function">assert_control</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	initial begin<span class="token operator">:</span> disable_assert_during_reset
		@<span class="token punctuation">(</span>negedge top_tb<span class="token punctuation">.</span>reset_n<span class="token punctuation">)</span> <span class="token comment">//active low reset</span>
			$<span class="token function">display</span><span class="token punctuation">(</span><span class="token string">"Disabling assertion during reset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			$<span class="token function">assertoff</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> top_tb<span class="token punctuation">.</span>cpu_inst1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		@<span class="token punctuation">(</span>posedge top_tb<span class="token punctuation">.</span>reset_n<span class="token punctuation">)</span>
			$<span class="token function">display</span><span class="token punctuation">(</span><span class="token string">"enabling assertions after reset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			$<span class="token function">assertion</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> top_tb<span class="token punctuation">.</span>cpu_inst1<span class="token punctuation">)</span><span class="token punctuation">;</span>
endmodule
</code></pre> 
<h2><a id="Property_354"></a>Property使用</h2> 
<h3><a id="_355"></a>介绍</h3> 
<ul><li>结合sequence对时序和逻辑的描述，property可用来<strong>描述设计的确切行为</strong>。</li></ul> 
<p>property可以在验证中用来做assumption、checker或coverage：</p> 
<ul><li>当使用<code>assert</code>关键词时，可以用作<code>checker</code>来检查<strong>设计是否遵循property的描述</strong>；</li><li>当使用<code>assume</code>关键词时，可以作为<strong>环境的假设条件</strong>，对于仿真环境和形式验证均起到<strong>对激励进行假设</strong>的作用；</li><li>当使用<code>cover</code>关键词时，可以<strong>将property是否真正通过作为断言覆盖率</strong>来衡量。</li></ul> 
<p>property可以在<code>module、interface、clocking块或package中</code>声明；也可以同sequence一样具备形式参数：<code>sequence、negation、disjunction、conjunction、if...else、implication、instantiation</code>。</p> 
<ul><li><code>sequence</code>类型的property，只有当出现<strong>满足</strong>该sequence条件时，property才可以通过。</li><li><code>negation</code>类型，即<code>not_property_expr</code>。如果property_expr<strong>不满足</strong>，那么negation类型的property可以通过。</li></ul> 
<pre><code class="prism language-c">property rule2<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>clkev<span class="token punctuation">)</span> disable <span class="token function">iff</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> a <span class="token operator">|</span><span class="token operator">-&gt;</span> <span class="token function">not</span><span class="token punctuation">(</span>b ##<span class="token number">1</span> c ##<span class="token number">1</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li><code>disjunction(OR)</code>用法即<code>property_expr1 or property_expr2</code>，当<strong>至少一个</strong>property_expr满足时，property即通过。</li></ul> 
<pre><code class="prism language-c">property rule3<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> a<span class="token punctuation">[</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>##<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span> <span class="token function">or</span> <span class="token punctuation">(</span>d <span class="token operator">|=</span><span class="token operator">&gt;</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li><code>conjunction(AND)</code>，用法<code>property_expr1 and property_expr2</code>，当两个property_expr均满足时，property通过。</li></ul> 
<pre><code class="prism language-c">property rule3<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> a<span class="token punctuation">[</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>##<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span> <span class="token function">and</span> <span class="token punctuation">(</span>d <span class="token operator">|=</span><span class="token operator">&gt;</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
endproperty
</code></pre> 
<ul><li><code>if(expression) property_expr1 else property_expr2</code></li><li>implication蕴含，同sequence中用法一致，<code>sequence_expr {|-&gt;, |=&gt;} property_expr</code></li><li>instantiation用法即<strong>一个命名后的property可以在另外一个property_expr中所使用</strong>。</li></ul> 
<pre><code class="prism language-c">property <span class="token function">rule6</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	##<span class="token number">1</span> x <span class="token operator">|</span><span class="token operator">-&gt;</span> y<span class="token punctuation">;</span>
endproperty
property rule5a<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>
	a ##<span class="token number">1</span> <span class="token punctuation">(</span>b <span class="token operator">||</span> c<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token operator">-&gt;</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">-&gt;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
			<span class="token function">rule6</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> e<span class="token punctuation">)</span>
		<span class="token keyword">else</span> <span class="token comment">// c</span>
			f<span class="token punctuation">;</span>
endproperty
</code></pre> 
<h3><a id="_400"></a>时钟声明</h3> 
<ul><li>一般对于sequence或property，默认情况下在使用同一个时钟对数据做采样，但不排除<strong>多个时钟的采样情况</strong>。</li></ul> 
<pre><code class="prism language-c">@<span class="token punctuation">(</span>posedge clk0<span class="token punctuation">)</span> sig0 ##<span class="token number">1</span> @<span class="token punctuation">(</span>posedge clk1<span class="token punctuation">)</span> sig1 <span class="token comment">// ##1的时钟对应的clk0</span>
</code></pre> 
<ul><li>如果一个sequence或property需要声明多个时钟用来数据采样，可以使用<code>##1</code>结合第二个时钟沿采样，表示<strong>与第一个时钟（clk0）沿紧密相连的下个时钟（clk1）沿</strong>。</li><li><code>sequence</code><strong>操作符号</strong>如and、or、intersect等<strong>无法被使用在多时钟sequence</strong>。</li><li>以下的多时钟sequence声明均是<strong>非法的</strong>：</li></ul> 
<pre><code class="prism language-c">@<span class="token punctuation">(</span>posedge clk1<span class="token punctuation">)</span> s1 ##<span class="token number">0</span> @<span class="token punctuation">(</span>posedge clk2<span class="token punctuation">)</span> s2
@<span class="token punctuation">(</span>posedge clk1<span class="token punctuation">)</span> s1 ##<span class="token number">2</span> @<span class="token punctuation">(</span>posedge clk2<span class="token punctuation">)</span> s2
@<span class="token punctuation">(</span>posedge clk1<span class="token punctuation">)</span> s1 intersect @<span class="token punctuation">(</span>posedge clk2<span class="token punctuation">)</span> s2
</code></pre> 
<ul><li><code>property</code>中的<code>and、or、not</code>则<strong>可以用在多时钟的property声明中</strong>，因为它们代表<strong>逻辑运算</strong>，并<strong>不参与sequence之间的时序关系</strong>。</li><li>正常不会有这样的复杂场景，一般有多时钟的情况是写task（相当于checker）来解决。</li><li>如果clk0上升沿a为高，且下个clk1和clk2的上升沿，b和c分别为高时，该property成立。<br> <img src="https://images2.imgbox.com/16/4c/YSMogg2b_o.png" alt="在这里插入图片描述"></li><li>可以在<code>sequence</code>中<strong>独立指定时钟</strong>：<img src="https://images2.imgbox.com/a8/05/BJPNIIcI_o.png" alt="在这里插入图片描述"></li></ul> 
<pre><code class="prism language-c">sequence s2<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> a ##<span class="token number">2</span> b<span class="token punctuation">;</span>
endsequence
property p2<span class="token punctuation">;</span>
	not s2<span class="token punctuation">;</span>
endproperty
assert <span class="token function">property</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>可以在<code>property</code>中<strong>独立指定时钟</strong>：</li></ul> 
<pre><code class="prism language-c">property p3<span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> a ##<span class="token number">2</span> b<span class="token punctuation">;</span>
endproperty
assert <span class="token function">property</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>在<strong>过程块</strong>中，可以继承过程块的时钟：<br> <code>always @(posedge clk) assert property (not (a ##2 b));</code></li><li>在<strong>时钟块</strong>中，也可以继承时钟块的时钟：</li></ul> 
<pre><code class="prism language-c">clocking master_clk @<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	property p3<span class="token punctuation">;</span>
		<span class="token function">not</span> <span class="token punctuation">(</span>a ##<span class="token number">2</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	endproperty
endclocking
assert <span class="token function">property</span> <span class="token punctuation">(</span>master_clk<span class="token punctuation">.</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>由此，断言的时钟由以下条件的<strong>优先级</strong>逐级判定：</p> 
<ul><li>显式声明断言时钟；</li><li>继承断言所嵌入环境的时钟；</li><li>继承默认的时钟。</li></ul> 
<p>对于<strong>并行断言</strong>，其<strong>必须具备时钟</strong>，即满足上述时钟条件之一。<br> 对于<strong>多时钟</strong>的断言，<strong>必须显式声明时钟</strong>，无法继承或使用默认时钟；也<strong>无法嵌套入时钟块</strong>，同样也<strong>无法嵌套入由时钟驱动的过程块语句</strong>：</p> 
<pre><code class="prism language-c">always @<span class="token punctuation">(</span>clk<span class="token punctuation">)</span> assert <span class="token function">property</span> <span class="token punctuation">(</span>mult_clock_prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// illegal</span>
initial @<span class="token punctuation">(</span>clk<span class="token punctuation">)</span> assert <span class="token function">property</span> <span class="token punctuation">(</span>mult_clock_prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// illegal</span>
</code></pre> 
<h3><a id="_456"></a>绑定</h3> 
<ul><li>断言既可以嵌入到设计中，也可以在设计外部定义。</li><li>嵌入到设计中，可能存在<strong>无法综合</strong>的问题，需同时考虑添加定向编译；在设计外部定义则不用担心综合问题。</li><li>bind方法可以满足在设计外部定义断言，将其绑定到设计内部或接口上面：<code>bind design_block_or_instance_name block_with_assertions</code></li><li>bind可以将包含断言的模块与设计模块或实例进行绑定，既可以满足<strong>对设计内部信号的可视性</strong>，又能够满足<strong>断言模块的独立性</strong>。</li><li>使用绑定的优势：<strong>无需修改原有设计代码，也无需添加监测信号</strong>，就可以实现断言的添加。</li></ul> 
<pre><code class="prism language-c">interface <span class="token function">range</span> <span class="token punctuation">(</span>input clk<span class="token punctuation">,</span> enable<span class="token punctuation">,</span> input <span class="token keyword">int</span> minval<span class="token punctuation">,</span> expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	property crange_en<span class="token punctuation">;</span>
		@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> enable <span class="token operator">|</span><span class="token operator">-&gt;</span> <span class="token punctuation">(</span>minval <span class="token operator">&lt;=</span> expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	endproperty
	range_chk<span class="token operator">:</span> assert <span class="token function">property</span> <span class="token punctuation">(</span>crange_en<span class="token punctuation">)</span><span class="token punctuation">;</span>
endinterface
bind cr_unit range <span class="token function">r1</span><span class="token punctuation">(</span>c_clk<span class="token punctuation">,</span> c_en<span class="token punctuation">,</span> v_low<span class="token punctuation">,</span> <span class="token punctuation">(</span>in1<span class="token operator">&amp;&amp;</span>in2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="expect_471"></a>expect语句</h3> 
<ul><li>前面assert、assume和cover都是非阻塞的，而expect是<strong>阻塞的</strong>property使用方式；其语法与assert一致，不过它会<strong>等property执行通过，才会执行后续的语句</strong>。</li><li>即可以使用wait语句的地方，就可以使用expect语句：<code>expect_property_statement ::= expect(property_spec) action block</code></li><li>当期望一些特定时序的时候，作为<strong>阻塞条件</strong>，可以使用expect来嵌入到过程语句块中：</li></ul> 
<pre><code class="prism language-c">initial begin
	#<span class="token number">200</span>ms<span class="token punctuation">;</span>
	<span class="token function">expect</span><span class="token punctuation">(</span>@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> a ##<span class="token number">1</span> b ##<span class="token number">1</span> c<span class="token punctuation">)</span> <span class="token keyword">else</span> $<span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"expect failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ABC<span class="token operator">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
end
</code></pre> 
<ul><li>同assert语句的调用方式类似，它也可以使用在function和task中，同时也可以引用静态变量或动态变量：</li></ul> 
<pre><code class="prism language-c">integer data<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
task automatic <span class="token function">wait_for</span><span class="token punctuation">(</span>integer value<span class="token punctuation">,</span> output bit success<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">expect</span> <span class="token punctuation">(</span>@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span> ##<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">]</span> data <span class="token operator">==</span> value<span class="token punctuation">)</span> success <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> success <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
endtask
initial begin
	bit ok<span class="token punctuation">;</span>
	<span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
end
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70dd62b40b1b1b10501e585bc7de4b77/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mac Couldn‘t load OpenSSL lib解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e11d4062c902c6d8623b0a0b4d90e3e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">爬虫系列：某家小区房产信息及POI数据获取</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>