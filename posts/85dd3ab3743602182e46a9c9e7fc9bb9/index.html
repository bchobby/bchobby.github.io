<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端js八股文大全 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端js八股文大全" />
<meta property="og:description" content="一、js的数据类型 值类型(基本类型)：数字(Number)、字符串（String）、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol,大数值类型(BigInt)
引用数据类型：对象(Object)、数组(Array)、函数(Function)、日期(Date)。
注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值(标识符)。
二、什么是函数 JS函数的概念
函数就是把特定功能的代码抽取出来，使之成为程序中的一个独立实体。
函数的作用 正如函数的概念, 我们可以根据需要, 将特定的功能用函数来包裹(封装)
使用函数的好处 1, 函数可以在同一个程序或其他程序中多次重复使用（通过函数名调用）
2, 使程序变得更简短而清晰 ， 提高可读性
3, 有利于程序维护
三、本地对象、内置对象和宿主对象 1.内置对象 js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、&gt;RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、&gt;SyntaxError和TypeError。
其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。
2.宿主对象 宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器
提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的
宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，
增加开发难度。浏览器对象有很多，如Window和Document等等。
3.自定义对象 顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充
四、数组(Array) 1.基本方法 push() 从后面添加元素，返回值为添加完后的数组的长度 pop() 从后面删除元素，只能是一个，返回值是删除的元素 shift() 从前面删除元素，只能删除一个 返回值是删除的元素 unshift() 从前面添加元素, 返回值是添加完后的数组的长度 splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素 concat() 连接两个数组 返回值为连接后的新数组 sort() 将数组进行排序,默认根据ASCII码比较,返回值是排好的数组 reverse() 将数组反转,返回值是反转后的数组 slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组 indexOf() 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1 Array.isArray() 检测是否是一个数组 join() 默认是以 &#34;,&#34; 隔开,返回的是字符串 2.高阶函数(1) forEach(callback) 遍历数组,无return 即使有return，也不会返回任何值，并且会影响原来的数组 map(callback) 映射数组(遍历数组),有return 返回一个新数组 。 注意:forEach()和map()的区别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/85dd3ab3743602182e46a9c9e7fc9bb9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-10T21:00:02+08:00" />
<meta property="article:modified_time" content="2023-10-10T21:00:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端js八股文大全</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="js_0"></a>一、js的数据类型</h2> 
<p>值类型(基本类型)：数字(Number)、字符串（String）、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol,大数值类型(BigInt)</p> 
<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)、日期(Date)。</p> 
<p>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值(标识符)。</p> 
<h2><a id="_8"></a>二、什么是函数</h2> 
<p>JS函数的概念</p> 
<blockquote> 
 <p>函数就是把特定功能的代码抽取出来，使之成为程序中的一个独立实体。</p> 
</blockquote> 
<ol start="2"><li>函数的作用</li></ol> 
<blockquote> 
 <p>正如函数的概念, 我们可以根据需要, 将特定的功能用函数来包裹(封装)</p> 
</blockquote> 
<ol start="3"><li>使用函数的好处</li></ol> 
<blockquote> 
 <p>1, 函数可以在同一个程序或其他程序中多次重复使用（通过函数名调用）<br> 2, 使程序变得更简短而清晰 ， 提高可读性<br> 3, 有利于程序维护</p> 
</blockquote> 
<h2><a id="_24"></a>三、本地对象、内置对象和宿主对象</h2> 
<h5><a id="1_26"></a>1.内置对象</h5> 
<blockquote> 
 <p>js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、&gt;RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、&gt;SyntaxError和TypeError。</p> 
</blockquote> 
<p>其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。</p> 
<h5><a id="2_32"></a>2.宿主对象</h5> 
<blockquote> 
 <p>宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器<br> 提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的<br> 宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，<br> 增加开发难度。浏览器对象有很多，如Window和Document等等。</p> 
</blockquote> 
<h5><a id="3_39"></a>3.自定义对象</h5> 
<blockquote> 
 <p>顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充</p> 
</blockquote> 
<h2><a id="Array_43"></a>四、数组(Array)</h2> 
<h5><a id="1_45"></a>1.基本方法</h5> 
<pre><code class="prism language-JavaScript">push() 从后面添加元素，返回值为添加完后的数组的长度
pop() 从后面删除元素，只能是一个，返回值是删除的元素
shift() 从前面删除元素，只能删除一个 返回值是删除的元素
unshift() 从前面添加元素, 返回值是添加完后的数组的长度
splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素
concat() 连接两个数组 返回值为连接后的新数组
sort() 将数组进行排序,默认根据ASCII码比较,返回值是排好的数组
reverse() 将数组反转,返回值是反转后的数组
slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组
indexOf() 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1
Array.isArray() 检测是否是一个数组
join()  默认是以 "," 隔开,返回的是字符串
</code></pre> 
<h5><a id="21_62"></a>2.高阶函数(1)</h5> 
<pre><code class="prism language-html">forEach(callback) 遍历数组,无return  即使有return，也不会返回任何值，并且会影响原来的数组
map(callback) 映射数组(遍历数组),有return 返回一个新数组 。
</code></pre> 
<p>注意:<code>forEach()和map()的区别</code></p> 
<blockquote> 
 <ol><li>arr.forEach()是和for循环一样，是代替for。arr.map()是修改数组其中的数据，并返回新的数据。</li><li>arr.forEach() 没有return arr.map() 有return</li></ol> 
</blockquote> 
<h5><a id="32_74"></a>3.高阶函数(2)</h5> 
<pre><code class="prism language-JavaScript">filter(callback) 过滤数组，返回一个满足要求的数组 
every(callback) 依据判断条件，数组的元素是否全满足，若满足则返回ture
some() 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture
reduce(callback, initialValue) 迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值
</code></pre> 
<p>lastIndexOf() 和arr.indexOf()的功能一样，不同的是从后往前查找<br> Array.from() 将伪数组变成数组，就是只要有length的就可以转成数组。 —es6<br> Array.of() 将一组值转换成数组，类似于声明数组 —es6<br> find(callback) 找到第一个符合条件的数组成员<br> findIndex(callback) 找到第一个符合条件的数组成员的索引值<br> fill(target, start, end) 使用给定的值，填充一个数组<br> includes() 判断数中是否包含给定的值<br> keys() 遍历数组的键名<br> values() 遍历数组键值<br> entries() 遍历数组的键名和键值</p> 
<h2><a id="String_95"></a>五、字符串(String)</h2> 
<h5><a id="_97"></a>字符串的恒定性</h5> 
<p>字符串的方法修改字符,不会改变原来的字符串,叫做恒定性</p> 
<h5><a id="_101"></a>字符串的方法</h5> 
<pre><code class="prism language-JavaScript">charAt(): 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。
charCodeAt(): 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。
indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置
toLowerCase()把字符串转为小写，返回新的字符串。
toUpperCase(): 把字符串转为大写，返回新的字符串。
lastIndexOf(): 返回某个指定的子字符串在字符串中最后出现的位置。
slice(): 返回字符串中提取的子字符串。 
substring(): 提取字符串中介于两个指定下标之间的字符。	
split(): 把字符串分割成字符串数组。
substr(): 返回从指定下标开始指定长度的的子字符串
replace(): 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。
match(): 返回所有查找的关键字内容的数组。
concat(): 合并

支持正则的四个方法:
	search()
	match()
	split()
	replace()
</code></pre> 
<h2><a id="_125"></a>六、浏览器渲染页面的原理及流程</h2> 
<p>浏览器将域名通过网络通信从服务器拿到html文件后，如何渲染页面呢？</p> 
<blockquote> 
 <p>1.根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。+<br> 2.构建渲染树（Render Tree）。<br> 3.页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是回流</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8f/b9/zITU1Brv_o.png" alt=""></p> 
<h2><a id="repaintreflow_135"></a>七、重绘和回流（repaint&amp;reflow)</h2> 
<p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为<strong>回流</strong>。</p> 
<pre><code class="prism language-JavaScript">1、页面首次渲染
2、浏览器窗口大小发生改变
3、元素尺寸或位置发生改变
4、元素内容变化（文字数量或图片大小改变而引起的计算值宽度和高度改变）
5、元素字体大小变化
6、添加或者删除可见的DOM元素
7、激活CSS伪类（例如：:hover）6
8、查询某些属性或调用某些方法
9、offsetWidth,width,clientWidth,scrollTop/scrollHeight的计算,会使浏览器将渐进回流队列Flush,立即执行回流。
</code></pre> 
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为<strong>重绘</strong>。</p> 
<p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p> 
<h2><a id="_155"></a>八、如何避免重绘和回流？</h2> 
<p><strong>css：</strong></p> 
<pre><code class="prism language-JavaScript">1.避免使用table布局，可能很小的一个小改动会造成整个table的重新布局
2.尽可能在DOM树的最末端改变class。
3.避免设置多层内联样式。
4.将动画效果应用到position属性为absolute或fixed的元素上。
5.动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame
6.避免使用CSS表达式（例如：calc()）
7.使用transform替代top
8.使用visibility替换display: none，因为前者只会引起重绘，后者会引发回流（改变了布局）
将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点
</code></pre> 
<p><strong>js：</strong></p> 
<pre><code class="prism language-JavaScript">1.避免频繁操作样式，最好一次性重写style属性,cssText，或者将样式列表定义为class并一次性更改class属性。
2.避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
3.也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
4.避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
5.对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。
</code></pre> 
<h2><a id="Closure_181"></a>九、什么是闭包(Closure)</h2> 
<p>闭包是这样一种机制:</p> 
<p>**函数嵌套函数,内部函数可以引用外部函数的参数和变量,参数和变量不会被垃圾回收机制所收回. **</p> 
<p>闭包的好处：</p> 
<blockquote> 
 <ol><li>可以让一个变量长期驻扎在内存当中不被释放,在IE6、7、8下会存在内存溢出</li><li>避免全局变量的污染, 和全局变量不同, 闭包中的变量无法被外部使用</li></ol> 
</blockquote> 
<p><strong>闭包的用途</strong></p> 
<p>1.实现缓存</p> 
<p>2.存储值与避免变量全局污染</p> 
<p>3.函数的柯里化</p> 
<p>4.节流和防抖</p> 
<p><strong>使用闭包的注意点</strong></p> 
<blockquote> 
 <p>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。<br> （2）闭包会在父函数外部，改变父函数内部变量的值。</p> 
</blockquote> 
<h2><a id="GC_209"></a>十、垃圾回收机制(GC)</h2> 
<p>​ JS引擎会在一定的时间间隔来自动对内存进行回收(把内存释放)</p> 
<p>JS垃圾回收机制有两种: 1, 标记清除, 2, 引用计数</p> 
<p>​ 1, <strong>标记清除</strong>: js会对变量做一个标记Yes or No的标签以供js引擎来处理, 当变量在某个环境下被使用则标记为yes, 当超出该环境(可以理解为超出作用域)则标记为no, js引擎会在一定时间间隔来进行扫描, 会对所有no标签的变量进行释放(将该变量所占的内存释放掉)</p> 
<p>​ 2, <strong>引用计数</strong>: 对于js中引用类型的变量, 采用引用计数的内存回收机制, 当一个引用类型的变量赋值给另一个变量时, 引用计数会+1, 而当其中有一个变量不再等于值时, 引用计数会-1, 如果引用计数为0, 则js引擎会将其释放掉</p> 
<h2><a id="callback_219"></a>十一、什么是回调函数(callback)</h2> 
<p>回调函数也是一种高阶函数,把一个函数当做另外一个函数的参数,在另外一个函数内部被执行和传递参数</p> 
<p>好处:</p> 
<blockquote> 
 <p>1.解决异步<br> 2.对函数进行功能扩展</p> 
</blockquote> 
<p>缺点:</p> 
<blockquote> 
 <p>1.容易造成回调地狱,回调地狱不方便维护与理解,<br> 2.解决方案使用 promise + async + await</p> 
</blockquote> 
<h2><a id="ajax_233"></a>十二、什么是ajax</h2> 
<p>AJAX (阿贾克斯 Asynchronous Javascript And Xml ) 异步JavaScript和XML，是指一种创建交互式网页应用的网页开发技术, 可以<strong>访问服务器数据的局部刷新的技术</strong></p> 
<p>核心对象: <strong>XMLHttpRequest</strong></p> 
<p>ajax的异步如何获取到数据?</p> 
<blockquote> 
 <p>使用<code>onreadystatechange</code>事件(事件队列event loop的宏任务),并结合<code>callback</code>回调函数获取数据</p> 
</blockquote> 
<p><code>ajax的同步,发送请求时会占据 (thread main)主线程,造成阻塞,不推荐使用</code></p> 
<h2><a id="getpost_245"></a>十三、get请求与post请求的区别?</h2> 
<blockquote> 
 <p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br> GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br> GET请求只能进行url编码，而POST支持多种编码(文字,图片,电影…)方式。<br> GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br> GET请求在URL中传送的参数是有长度限制的，而POST没有。get做查询post做提交</p> 
 <p>对参数的数据类型，</p> 
 <p>GET只接受ASCII字符，而POST没有限制。<br> GET比POST更不安全，因为GET的参数直接暴露在URL上，所以不能用来传递敏感信息。<br> GET参数通过URL传递，POST放在Request body中。<br> GET产生的URL地址可以被Bookmark，而POST不可以。</p> 
 <h6><a id="GETPOST_260"></a>GET请求的速度是POST请求速度的两倍</h6> 
</blockquote> 
<p><strong>注意:GET产生一个TCP数据包；POST产生两个TCP数据包。Firefox就只发送一次</strong></p> 
<p>get适合做查询post适合做提交</p> 
<p>get只接受ASCII字符，而POST没有限制</p> 
<p>get请求比post请求快,post比get请求相对安全</p> 
<p>post传输的数据量大,可以传输视频音频等</p> 
<h2><a id="HTTP_274"></a>十四、HTTP协议</h2> 
<h5><a id="1http_276"></a>1.什么是http协议</h5> 
<pre><code>超文本传输协议Hyper Text Transfer Protocol
它是基于TCP协议的应用层传输协议，
简单来说就是客户端和服务端进行数据传输的一种规则
</code></pre> 
<h5><a id="2http__284"></a>2.http 协议一共有五大特点：</h5> 
<p>HTTP 是一个属于应用层的面向对象的协议有五大特点</p> 
<p>1.<strong>支持客户/服务器模式</strong>。<br> 2.<strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种 方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br> 3.<strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由<strong>Content-Type</strong>（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。<br> 4.<strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即<strong>断开式连接</strong>。采用这种方式可以节省传输时间。<br> 5.<strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于<strong>事务处理没有记忆能力</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p> 
<h5><a id="3request_294"></a>3.请求报文(request)</h5> 
<pre><code class="prism language-js"><span class="token number">1.</span>请求行    <span class="token punctuation">[</span>请求方式  url地址  <span class="token function">协议</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">/</span><span class="token number">1.1</span><span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token punctuation">]</span>
<span class="token number">2.</span>请求头    <span class="token punctuation">[</span>content<span class="token operator">-</span>type<span class="token punctuation">,</span>cookie<span class="token punctuation">]</span>
<span class="token number">3.</span>请求体    <span class="token punctuation">[</span>数据<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/82/a2/WnhRqQMM_o.jpg" alt="请求报文格式"></p> 
<p><img src="https://images2.imgbox.com/2d/07/GLjYffXu_o.png" alt="请求报文"></p> 
<h5><a id="4_response_309"></a>4.响应报文 (response)</h5> 
<pre><code class="prism language-JavaScript">1.状态行  [协议, 状态码,短语]
2.响应头  [content-Type,...Referer:防盗链]
3.响应体  [数据]
</code></pre> 
<p><img src="https://images2.imgbox.com/a4/a6/Lx8hfTp1_o.jpg" alt="响应报文"></p> 
<p><img src="https://images2.imgbox.com/ee/2a/3GHNgfra_o.png" alt="响应报文"></p> 
<h2><a id="Promise_321"></a>十五、Promise</h2> 
<p>回调函数是用来解决异步或对函数进行功能扩展,如果滥用回调函数的嵌套,就会形成<strong>回调地狱</strong><br> <strong>回调地狱</strong>,不方便维护与代码的理解,就可以采用Promise.(不仅能解决回调地狱还能做并发)<br> <strong>promsie是一个类,需要被实例化,微任务</strong></p> 
<pre><code>promsie 有三种状态
1.pending 等待 默认是 等待
2.fulfilled 完成
3.rejected  拒绝
它们顺序是不可以逆的
</code></pre> 
<h5><a id="promsie_335"></a>promsie的原型方法</h5> 
<p>then() 里面有2个函数,第1个函数取resolve的结果,第2个参数取reject的结果<br> catch() 捕获 reject的结果<br> finally() 只要执行resolve或reject后,都会执行finally</p> 
<h5><a id="promise_341"></a>promise的静态方法</h5> 
<p>Promise.all() ,all方法里需要填入一个数组,数组里必须都是支持promise的方法,迸发执行</p> 
<p>Promise.race(),race方法里需要填入一个数组,谁先完成,就只取谁的结果</p> 
<p>Promise.resolve() 只执成功,并返回一个新的promise对象</p> 
<p>Promise.reject() 只执失败,并返回一个新的promise对象</p> 
<h5><a id="ES7_async_await_351"></a>ES7 async await</h5> 
<p>await关键字后面必须接promise对象,有await关键字的地方,必须是一个async 异步函数</p> 
<p>它能解决,<strong>把异步像同步一样的被调用</strong></p> 
<h2><a id="_357"></a>十六、同源策略</h2> 
<p>同源策略是一种浏览器的安全机制,</p> 
<p>如果出现 <strong>协议,域名,端口</strong>,三者不统一,就会产生跨域</p> 
<pre><code class="prism language-javascript"><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com
<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com   <span class="token comment">//协议不同,跨域</span>

<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com
<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mail<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com    二级域名
<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>aaa<span class="token punctuation">.</span>bbb<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com 三级域名    域名不同<span class="token punctuation">,</span>跨域

<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">8080</span>
<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">5500</span>  端口不一致<span class="token punctuation">,</span>跨域
</code></pre> 
<h6><a id="cors_375"></a>怎么解决跨域(cors)?</h6> 
<p>目前常见的方案</p> 
<ol><li> <p>在后端的<strong>响应头</strong>加上一句 <code>Access-Control-Allow-Origin:*</code>,这里的*表示所有请求,都可以访问该服务</p> </li><li> <p>采用非官方的跨域方案 ,JSONP, 它算不上真正ajax请求,它只能算get请求,因为它是利用了带<code>src</code>属性的</p> <p><code>script</code>,不受限制的访问外部资源,再又结合<code>callback</code>回调函数获取数据.</p> <p>还要和后端配合使用</p> </li><li> <p>前端使用webpack模块中的server proxy ,实现服务器端代理,来解决跨域</p> </li></ol> 
<h2><a id="xss_389"></a>十七、什么是xss攻击?</h2> 
<p>**跨站脚本攻击。**XSS的重点不在于跨站点，而在于脚本的执行</p> 
<p>恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的</p> 
<p><strong>如何防范？</strong></p> 
<ol><li>后端需要对提交的数据进行过滤(</li></ol> 
<h2><a id="JSONJSONP__404"></a>十八、JSON和JSONP的区别 ?</h2> 
<pre><code>json  是一种轻量级的数据结构,能跨平台进行网络传输,能做配置文件.
jsonp 是一种非官方的跨域解决方案,它是利用script的src,不受限制的访问外部资源,并结合callback拿到数据
它并不是真正的ajax,它是一个get请求,更加适合做查询.
xml   可扩展性标记语言,是一种重量级的数据格式,也能跨平台进行网络传输和配置文件.
</code></pre> 
<h2><a id="oop_413"></a>十九、什么是oop(面向对象)</h2> 
<pre><code>oop是一种编程思想,又叫做面向对象编程(ooa面向对象分析,ood面向对象设计)
它有三大特性
封装 将相同的属性和方法提取成一个类
继承 子类拥有父类的属性和方法
多态  
     重写 子类重写父类的属性和方法
     重载 在同一个类中,同名不同参数 js没有重载
补充: css3大特性
    层叠性,继承性,优先级(特殊性)
</code></pre> 
<h2><a id="_427"></a>二十、继承</h2> 
<pre><code>1. 对象冒充继承  使用 bind,call,apply 解决构造函数属性的继承
		缺点:不能继承原型上的属性和方法
2. 原型链继承   
		缺点:不能让构造函数的属性,初始化
3. 组合继承 (对象冒充+原型继承)
	    缺点:原型中会有多余的属性,并且是undefined
4. ES6的class和extends继承
5. 寄生组合继承  Object.create(base.prototype);
</code></pre> 
<h2><a id="_440"></a>二十一、递归</h2> 
<h5><a id="1_442"></a>1.什么是递归?</h5> 
<pre><code>函数自己调用自己,要有零界点(结束条件)
</code></pre> 
<h5><a id="2_448"></a>2.递归能做什么?</h5> 
<pre><code>循环的能做的事,递归都能实现
</code></pre> 
<h5><a id="3_454"></a>3.递归的使用场景</h5> 
<pre><code>1. 快速排序使用递归
2. nodejs磁盘文件的遍历,使用递归
3. 管理系统的权限菜单栏(n级菜单栏)
4. 对象的深拷贝
</code></pre> 
<h2><a id="throttledebounce_463"></a>二十二、节流(throttle)与防抖(debounce)</h2> 
<h5><a id="_465"></a><strong>防抖</strong>：<strong>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</strong></h5> 
<blockquote> 
 <p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</p> 
</blockquote> 
<pre><code class="prism language-javascript">     <span class="token comment">// 1、防抖功能函数，接受传参</span>
    <span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay<span class="token operator">==</span><span class="token number">600</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 2、创建一个标记用来存放定时器的返回值</span>
      <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 3、每次当用户点击/输入的时候，把前一个定时器清除</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4、然后创建一个新的 setTimeout，</span>
        <span class="token comment">// 这样就能保证点击按钮后的 interval 间隔内</span>
        <span class="token comment">// 如果用户还点击了的话，就不会执行 fn 函数</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_489"></a><strong>节流</strong>：<strong>指定时间间隔内只会执行一次任务。</strong></h5> 
<blockquote> 
 <p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay<span class="token operator">=</span><span class="token number">600</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 1、通过闭包保存一个标记</span>
      <span class="token keyword">let</span> canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 2、在函数开头判断标志是否为 true，不为 true 则中断函数</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>canRun<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 3、将 canRun 设置为 false，防止执行之前再被执行</span>
        canRun <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 4、定时器</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 5、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span>
          canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>节流和防抖的共同点,都是减少执行频率.</p> 
<p>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，</p> 
<p>而函数防抖只是在最后一次事件后才触发一次函数</p> 
<h2><a id="_deferasync_520"></a>二十三 、defer和async的区别</h2> 
<pre><code class="prism language-JavaScript"> &lt;script src="./async1.js" async defer&gt;&lt;/script&gt;
</code></pre> 
<ul><li> <p>defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。</p> </li><li> <p>async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关</p> </li></ul> 
<h2><a id="_532"></a>二十四、前端性能优化</h2> 
<ol><li> <p><strong>减少 HTTP 请求数量</strong></p> 
  <ul><li>基本原理：在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（<a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/" rel="nofollow">不同浏览器允许并发数</a>），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。 
    <ol><li><strong>CSS Sprites：国内俗称 CSS 精灵</strong>，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数，节省命名词汇量（由命名多张图片文件变成一张，哈哈哈）。</li><li><strong>合并 CSS 和 JS 文件</strong>：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。</li><li><strong>采用 lazyLoad：俗称懒加载</strong>，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。</li></ol> </li></ul> </li><li> <p><strong>控制资源文件加载优先级</strong></p> 
  <ul><li>基本原理：说到这里就需要知道浏览器加载 HTML 内容的原理，浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。 
    <ol><li>遵循原则：主要文件放在 head 内部，次要文件放在 body 底部。一般情况下都是 CSS 在头部，JS 在底部。</li></ol> </li></ul> </li><li> <p><strong>利用浏览器缓存</strong></p> 
  <ul><li>基本原理：浏览器缓存分强缓存和协商缓存，他们是将网络资源存储在本地，等待下次请求该资源时，如果命中就不需要到服务器重新请求该资源，直接在本地读取该资源。 
    <ol><li>强缓存：在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header。</li><li>协商缓存：通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 分别管理。</li></ol> </li></ul> </li><li> <p><strong>使用 CDN</strong></p> 
  <ul><li>基本原理：CDN的全称是Content Delivery Network，即<a href="http://zsvalue.com/201405/foundation-of-cdn-%E3%80%8Acdn%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E3%80%8Bnote/" rel="nofollow">内容分发网络</a>。</li></ul> </li><li> <p><strong>减少重排（Reflow）</strong></p> 
  <ul><li>基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。 
    <ol><li>减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。</li></ol> </li></ul> </li><li> <p><strong>减少 DOM 操作</strong></p> <pre><code class="prism language-JavaScript">使用createDocumentFragment
</code></pre> </li><li> <p><strong>图标使用 IconFont 替换</strong></p> </li></ol> 
<p>https://www.jianshu.com/p/d9c20eafa67e 网页性能优化</p> 
<p>https://segmentfault.com/a/1190000017329980 你真的了解回流和重绘吗</p> 
<h2><a id="__575"></a>二十五 、值类型和引用类型的区别</h2> 
<p>【值类型】</p> 
<blockquote> 
 <p>1.占用空间固定，保存在栈中，在当前环境执行结束时销毁<br> 2.保存和赋值是值的本身<br> 3.可以使用typeof检测数据类型<br> 4.基本类型数据是值类型</p> 
</blockquote> 
<p>【引用类型】</p> 
<blockquote> 
 <p>1.占用空间不固定，保存在堆中，只有在引用的它的变量不在时，会被垃圾回收机制回收。 (引用变量存储在栈中的是指向堆中的数组或者对象的地址 )<br> 2.保存与复制的是指向对象的一个指针<br> 3.使用instanceof检测数据类型<br> 4.使用new()方法构造出的对象是引用型</p> 
</blockquote> 
<h2><a id="_cookie_591"></a>二十六 、什么是cookie?</h2> 
<p>基于http协议的一种本地’存储’技术 (它就相当于钱包)</p> 
<pre><code class="prism language-javascript">document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">"username=qingmu; expires=有效时间 GMT; path=/"</span><span class="token punctuation">;</span>domain<span class="token operator">=</span><span class="token punctuation">;</span>secure<span class="token punctuation">;</span>
</code></pre> 
<p>它的特点:</p> 
<blockquote> 
 <p>1.基于http协议,解决无状态问题</p> 
 <p>2.它会随着请求携带到服务器<br> 3.只能存储’字符串’ 4k左右大小<br> 4.能跨域(设置domain),默认不可以<br> 5.容易被伪造,不安全,会造成 xss攻击 (站点伪造)</p> 
</blockquote> 
<p>它的使用场景:</p> 
<blockquote> 
 <p>1.免登录 2.购物车<br> 3.简单的存储,非敏感数据</p> 
</blockquote> 
<p>http协议</p> 
<p>常见于 浏览器与服务器的通信,它是属于 应用层 (应用程序)</p> 
<p>http 默认的端口 80</p> 
<p>http协议的特点<br> 短连接(断开式) 浏览器向服务器发送请求,服务器接受,并响应<br> 无状态 不知道是谁访问了服务器,</p> 
<blockquote> 
 <ol><li>(cookie+session)</li><li>token 凭证</li></ol> 
</blockquote> 
<h2><a id="cookie_sessionStoragelocalStorage_628"></a>二十七、cookie 、sessionStorage与localStorage的区别</h2> 
<table><thead><tr><th>特性</th><th></th><th>sessionStorage</th><th>localStorage</th></tr></thead><tbody><tr><td>数据的生命期</td><td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td><td>除非被清除，否则永久保存</td></tr><tr><td>存放数据大小</td><td>4K左右</td><td>一般为5MB</td><td>一般为5MB</td></tr><tr><td>与服务器端通信</td><td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td><td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td></tr><tr><td>易用性</td><td>需要程序员自己封装，源生的Cookie接口不友好</td><td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td><td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td></tr></tbody></table> 
<p>WebStorage(<strong>sessionStorage与localStorage</strong>)提供了一些方法，数据操作比cookie方便；</p> 
<blockquote> 
 <p>1).setItem (key, value) —— 保存数据，以键值对的方式储存信息。<br> 2).getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。<br> 3).removeItem (key) —— 删除单个数据，根据键值移除对应的信息。<br> 4).clear () —— 删除所有的数据<br> 5).key (index) —— 获取某个索引的key</p> 
</blockquote> 
<h6><a id="cookielocalstoragesessionStorage_645"></a>cookie、localstorage和sessionStorage三者都是临时存储客户端会话信息或数据的方法，下面就简单介绍一下三者的区别：</h6> 
<p>一、存储的时间有效期不同<br> 1、cookie的有效期是可以设置的，默认的情况下是关闭浏览器后失效</p> 
<p>2、sessionStorage的有效期是仅保持在当前页面，关闭当前会话页或者浏览器后就会失效</p> 
<p>3、localStorage的有效期是在不进行手动删除的情况下是一直有效的</p> 
<p>二、存储的大小不同<br> 1、cookie的存储是4kb左右，存储量较小，一般页面最多存储20条左右信息</p> 
<p>2、localStorage和sessionStorage的存储容量是5Mb(官方介绍，可能和浏览器有部分差异性)</p> 
<p>三、与服务端的通信<br> 1、cookie会参与到与服务端的通信中，一般会携带在http请求的头部中，例如一些关键密匙验证等。</p> 
<p>2、localStorage和sessionStorage是单纯的前端存储，不参与与服务端的通信</p> 
<h2><a id="forin__forof_666"></a>二十八、for…in 和 for…of的区别?</h2> 
<blockquote> 
 <p>推荐在循环对象属性的时候, 使用for…in.<br> ​在遍历数组的时候的时候使用for…of。<br> ​for…in循环出的是key，for…of循环出的是value<br> ​注意，for…of是ES6新引入的特性。修复了ES5引入的for…in的不足<br> ​for…of不能循环普通的对象，需要通过和Object.keys()搭配使用<br> ​for…of更加强大, 能遍历Array, Map, Set, String,<br> TypedArray，arguments, 而for in 不能遍历map</p> 
</blockquote> 
<h2><a id="new_676"></a>二十九、new操作符做了什么?</h2> 
<pre><code class="prism language-javascript">        <span class="token keyword">function</span> <span class="token function">Perosn</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 1.在构造函数内部创建一个空对象</span>
            <span class="token comment">// var obj = new Object();</span>
            <span class="token comment">//2. obj.__proto__= Perosn.prototype;</span>
            <span class="token comment">//3.1 Perosn.bind(obj) this指向obj</span>
            <span class="token comment">//3.2 让空对象拥有 属性和方法 (让this有属性和方法)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">//属性</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>   <span class="token comment">//属性</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">run</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span><span class="token comment">//方法</span>
            <span class="token comment">//4.  return this; 是隐式 (看不见的,默认)</span>
            <span class="token comment">// return this;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Perosn</span><span class="token punctuation">(</span><span class="token string">"旺旺"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>1.在构造函数内部(隐式)创建一个空对象<br> 2.空对象的指针( __ proto __ )指向构造函数的原型(prototype)<br> 3.构造函数的this指向空对象、给空对象添加(自定义的)属性和方法<br> 5.隐式的返回 return this<br> <strong>所以new 能改变构造函数内部的this指向,函数内部的this默认是window</strong></p> 
</blockquote> 
<h2><a id="__702"></a>三十 、什么是面向对象?</h2> 
<p>面向对象是<strong>利用对象进行编程</strong>的一种思想. 面向对象又被成为 <strong>OOP</strong> (Object Oriented Programming面向对象编程)</p> 
<h6><a id="1_706"></a>1).为什么要使用面向对象编程?</h6> 
<p>这种编程方式,更加贴近现实;</p> 
<h6><a id="2_710"></a>2).哪些语言是面向对象?</h6> 
<p>java,c#, c++ , js … 面向对象编程,是主流;</p> 
<h6><a id="3_714"></a>3).面向对象的特点有哪些?</h6> 
<pre><code>1)封装
   把相同的属性和方法 提取成为一个类
   类是抽象的,类是模板
2)继承
   子类拥有父类的属性和方法  (偷懒神器)
3)多态
   1).重写 (override)  (基于继承)
        子类重写父类的属性和方法
   2).重载 (overload)
     同一个类中,同名不同参数 (在同一个类中,函数名称相同,参数的个数和类型不相同)
     注意: js没有重载
</code></pre> 
<h6><a id="4css_730"></a>4).css也有三大特性?</h6> 
<pre><code>1).继承性
2).层叠性
3).优先级
c/s   client  -- server  客户端--服务器    功能强大,不方便维护 (需安装)
b/s   browser -- server  浏览器--服务器    主流  跨域平台,方便 (无须安装)
</code></pre> 
<h6><a id="5_738"></a>5).什么是面向过程?与面向对象有什么区别?</h6> 
<h6><a id="_740"></a>面向过程:</h6> 
<blockquote> 
 <p>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，<br> 使用的时候一个一个依次调用就可以了。</p> 
</blockquote> 
<h6><a id="_745"></a>面向对象:</h6> 
<blockquote> 
 <p>是把构成问题的事务分解成各个对象，每个对象都有自己独立的属性和行为,<br> 对象可以将整个问题事务进行分工, 不同的对象做不同的事情,<br> 这种面向对象的编程思想由于更加贴近实际生活, 所以被计算机语言广泛应用。</p> 
</blockquote> 
<h6><a id="js2_751"></a>js有2种编程模式</h6> 
<p>1.面对过程<br> 2.面向对象</p> 
<h2><a id="_756"></a>三十一、类和对象的关系</h2> 
<p><strong>类是对象的抽象，而对象是类的具体实例</strong>。</p> 
<p>类是抽象的，不占用内存，而对象是具体的，占用存储空间。</p> 
<p>类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p> 
<p>类与对象的关系就如模具和铸件的关系</p> 
<p>类的实例化结果就是对象，而对一类对象的抽象就是类，</p> 
<p><strong>类描述了一组有相同属性和相同方法的对象</strong></p> 
<p>​</p> 
<h2><a id="_772"></a>三十二、原型</h2> 
<h6><a id="1_774"></a>1.什么是原型?</h6> 
<blockquote> 
 <p>原型, 英文名prototype是函数中一个自带的属性,用来添加公共属性的方法,我们创建的每个函数都有一个<br> prototype(原型)属性,这个属性是一个对象.<br> ~</p> 
</blockquote> 
<h6><a id="2_780"></a>2.原型的作用?</h6> 
<blockquote> 
 <p>原型的作用是: 可以让同一个构造函数创建的所有对象共享属性和方法. 也就是说, 你可以不在<br> 构造函数中定义对象的属性和方法,<br> 而是可以直接将这些信息添加到原型对象中。</p> 
</blockquote> 
<h6><a id="3_786"></a>3.原型的好处?</h6> 
<p>优点:<br> 1, 实例对象都有自己的独有属性<br> 2, 同时共享了原型中的方法,最大限度的节省了内存<br> 3, 支持向构造函数传递参数 (初始值)</p> 
<h6><a id="4_793"></a>4.什么是原型链?</h6> 
<p>当访问一个实列对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找的过程就会形成一个链式结构，我们-称为原型链<br> <img src="https://images2.imgbox.com/33/49/LFImfRdf_o.png" alt=""></p> 
<h2><a id="__798"></a>三十三 、进程与线程的区别?</h2> 
<ol><li> <p>线程是<strong>程序执行的最小单位</strong>，而进程是操作<strong>系统分配资源的最小单位</strong>；</p> </li><li> <p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</p> </li><li> <p>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信</p> </li></ol> 
<p>号等)，某进程内的线程在其他进程不可见；</p> 
<ol start="4"><li>调度和切换：线程上下文切换比进程上下文切换要快得多</li></ol> 
<h2><a id="_AMDCMDCommonJsES6_812"></a>三十四 、AMD、CMD、CommonJs、ES6的对比</h2> 
<p>CommonJS规范是诞生比较早的,适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快.</p> 
<h5><a id="CommonJS_816"></a>CommonJS的特点:</h5> 
<ul><li> <p>1.所有代码都运行在模块作用域，不会污染全局作用域。</p> </li><li> <p>2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</p> </li><li> <p>3模块加载的顺序，按照其在代码中出现的顺序。</p> <p>AMD的特点<br> AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行,<strong>依赖前置</strong> ,代表作有 require.js库</p> </li></ul> 
<pre><code class="prism language-js"><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'clock'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">clock</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  clock<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="CMD_833"></a>CMD的特点</h5> 
<p>CMD (Common Module Definition), 是seajs推出的规范，CMD则是依赖就近，用的时候再require, <strong>就近依赖</strong> 代代表有SeaJS 库</p> 
<pre><code class="prism language-JavaScript">define(function(require, exports, module) {
   var clock = require('clock');
   clock.start();
});
</code></pre> 
<table><thead><tr><th>方案</th><th>优势</th><th>劣势</th><th>特点</th></tr></thead><tbody><tr><td>AMD</td><td>速度快</td><td>会浪费资源</td><td>预先加载所有的依赖，直到使用的时候才执行</td></tr><tr><td>CMD</td><td>只有真正需要才加载依赖</td><td>性能较差</td><td>直到使用的时候才定义依赖</td></tr></tbody></table> 
<p>能够提出CMD和AMD互相补充是一个很赞的想法。现在，它们除了希望放在浏览器作为loader也能够放在服务端，提供加载功能。在我看来，AMD擅长在浏览器端、CMD擅长在服务器端。这是因为浏览器加载一个功能不像服务器那么快，有大量的网络消耗。所以一个异步loader是更接地气的。</p> 
<p>后期使用webpack之后 AMD和CMD 没有啥意义.加上ES6也出了自己的模块化机制</p> 
<h5><a id="ES6_855"></a>ES6的模块化</h5> 
<pre><code class="prism language-JavaScript">import config from './config' //导入
export default function () { //导出
  console.log('fff')
}
</code></pre> 
<p>注意:</p> 
<p>script标签中写js代码，或者使用src引入js文件时，默认不能使用module形式，即不能使用import导入文件，</p> 
<p>但是我们可以再script标签上加上type=module属性来改变方式</p> 
<h2><a id="__870"></a>三十五 、比较运算符的规则</h2> 
<ul><li>数字和数字比较,直接比较大小</li><li>数字和字符串比较,字符串转换为数字后再比较</li><li>字符串和字符串比较,进行字符的ASCII码值比较</li></ul> 
<h2><a id="this_878"></a>this的理解</h2> 
<ul><li> <p>单独使用 this，它指向全局(Global)window对象。</p> </li><li> <p>在对象方法中， this 指向调用它所在方法的对象。</p> </li><li> <p>函数使用中，this 指向函数的所属者。</p> </li><li> <p>严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined。</p> </li><li> <p>绑定事件this 指向了接收事件的 HTML 元素。</p> </li><li> <p>apply 和 call 允许切换函数执行的上下文环境（context），即 this 绑定的对象，可以将 this 引用到任何对象。</p> </li><li> <p><a href="https://so.csdn.net/so/search?q=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">箭头函数</a>中this，沿作用域链向外找，直到有this定义（不受内部定时器影响）</p> </li></ul> 
<h2><a id="_892"></a>堆和栈的区别</h2> 
<h2><a id="getpost_896"></a>get和post的区别</h2> 
<h2><a id="_898"></a>什么是箭头函数</h2> 
<ul><li>没有this,this指向上下文对象</li><li>不能被实例化</li><li>没有构造器</li><li>如果函数体中只有一句代码 且省略了{} 且你需要返回值 那么必须省略return关键词,如果返回的是对象要用括号括起来2</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d41f098b099726d3340e1351858c1c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">No matching distribution found for numpy 安装numpy报错怎么办，看这里</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/089f96bc0e40aaf58888ade75d411216/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uni-app 经验分享，从入门到离职（实战篇）——模拟从后台获取图片路径数据后授权相册以及保存图片到本地（手机相册）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>