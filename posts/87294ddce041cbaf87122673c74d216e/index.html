<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java8 Stream收集器collect操作 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java8 Stream收集器collect操作" />
<meta property="og:description" content="收集器， 一种通用的、 从流生成复杂值的结构。 只要将它传给 collect 方法， 所有的流就都可以使用它了。
收集器可以做很多事情，例如：计数、分组、归并、求和等。
收集器汇总 序号方法含义1Collectors.averageingInt
Collectors.averagingLong
Collectors.averagingDouble平均值2Collectors.collectingAndThen统计并转换3Collectors.counting计数4Collectors.groupingBy分组5Collectors.mapping替换6Collectors.maxBy
Collectors.minBy最大值、最小值7Collectors.partitioningBy按Boolean分组8Collectors.reducing归并9Collectors.summarizingInt
Collectors.summarizingLong
Collectors.summarizingDouble获得统计结果对象10Collectors.summingInt
Collectors.summingLong
Collectors.summingDouble求和11Collectors.toList将流转换成list12Collectors.toSet将流转换成set13Collectors.toCollection将流转换成Collection14Collectors.toMap
Collectors.toConcurrentMap将流转换成map Collectors.averagingInt、Collectors.averagingLong、Collectors.averagingDouble：
统计Stream&lt;T&gt;流中， (根据)每个元素T得到的类型为int/long/double的数值的平均值。
/** * 统计Stream&lt;T&gt;流中, (根据)每个元素T得到的类型为int/long/double的数值的平均值。 * * 注:统计结果为Double。 * * 注:Stream的collect方法，签名为: * &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector) * * 注:Collectors的caveragingLong方法，签名为: * Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper) * * 注:Collectors的caveragingLong方法，签名为: * Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper) * * 注:Collectors的caveragingLong方法，签名为: * Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/87294ddce041cbaf87122673c74d216e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-29T13:56:55+08:00" />
<meta property="article:modified_time" content="2023-06-29T13:56:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java8 Stream收集器collect操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>收集器</strong>， <span style="color:#be191c;"><span style="background-color:#fefcd8;">一种通用的、 从流生成复杂值的结构。 只要将它传给 collect 方法， 所有的流就都可以使用它了。</span></span><br> 收集器可以做很多事情，例如：计数、分组、归并、求和等。</p> 
<hr> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:629px;"><caption>
   收集器汇总 
 </caption><thead><tr><th style="background-color:#ffff99;text-align:center;vertical-align:middle;width:54px;">序号</th><th style="background-color:#ffff99;text-align:center;vertical-align:middle;width:335px;">方法</th><th style="background-color:#ffff99;text-align:center;vertical-align:middle;width:235px;">含义</th></tr></thead><tbody><tr><td style="text-align:center;vertical-align:middle;width:54px;">1</td><td style="width:335px;">Collectors.averageingInt<br> Collectors.averagingLong<br> Collectors.averagingDouble</td><td style="text-align:center;vertical-align:middle;width:235px;">平均值</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">2</td><td style="width:335px;">Collectors.collectingAndThen</td><td style="text-align:center;vertical-align:middle;width:235px;">统计并转换</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">3</td><td style="width:335px;">Collectors.counting</td><td style="text-align:center;vertical-align:middle;width:235px;">计数</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">4</td><td style="width:335px;">Collectors.groupingBy</td><td style="text-align:center;vertical-align:middle;width:235px;">分组</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">5</td><td style="width:335px;">Collectors.mapping</td><td style="text-align:center;vertical-align:middle;width:235px;">替换</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">6</td><td style="width:335px;">Collectors.maxBy<br> Collectors.minBy</td><td style="text-align:center;vertical-align:middle;width:235px;">最大值、最小值</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">7</td><td style="width:335px;">Collectors.partitioningBy</td><td style="text-align:center;vertical-align:middle;width:235px;">按Boolean分组</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">8</td><td style="width:335px;">Collectors.reducing</td><td style="text-align:center;vertical-align:middle;width:235px;">归并</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">9</td><td style="width:335px;">Collectors.summarizingInt<br> Collectors.summarizingLong<br> Collectors.summarizingDouble</td><td style="text-align:center;vertical-align:middle;width:235px;">获得统计结果对象</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">10</td><td style="width:335px;">Collectors.summingInt<br> Collectors.summingLong<br> Collectors.summingDouble</td><td style="text-align:center;vertical-align:middle;width:235px;">求和</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">11</td><td style="width:335px;">Collectors.toList</td><td style="text-align:center;vertical-align:middle;width:235px;">将流转换成list</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">12</td><td style="width:335px;">Collectors.toSet</td><td style="text-align:center;vertical-align:middle;width:235px;">将流转换成set</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">13</td><td style="width:335px;">Collectors.toCollection</td><td style="text-align:center;vertical-align:middle;width:235px;">将流转换成Collection</td></tr><tr><td style="text-align:center;vertical-align:middle;width:54px;">14</td><td style="width:335px;">Collectors.toMap<br> Collectors.toConcurrentMap</td><td style="text-align:center;vertical-align:middle;width:235px;">将流转换成map</td></tr></tbody></table> 
<hr> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.averagingInt、Collectors.averagingLong、Collectors.averagingDouble：</span></strong></span></p> 
<p>统计Stream&lt;T&gt;流中， (根据)每个元素T得到的类型为int/long/double的数值的平均值。</p> 
<pre><code class="language-java">/**
     * 统计Stream&lt;T&gt;流中, (根据)每个元素T得到的类型为int/long/double的数值的平均值。
     *
     * 注:统计结果为Double。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的caveragingLong方法，签名为:
     *       Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)
     *
     * 注:Collectors的caveragingLong方法，签名为:
     *       Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)
     *
     * 注:Collectors的caveragingLong方法，签名为:
     *       Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)
     *
     * 注:当前stream元素类型为T。
     *
     * 注:由于计算机二进制存数的问题，返回的double值可能存在误差。
     *
     * 建议:尽量少用此方法，如果非要用的话，建议用在那些对精度要求不高的场景下，且对结果进行舍入。
     */
    @Test
    public void test27_0() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三").age(18).workStartTimestamp(1L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(24).workStartTimestamp(2L).faceScore(89.2D).build(),
                Staff.builder().name("王五").age(45).workStartTimestamp(3L).faceScore(68.6D).build()
        );

        // Collectors.averagingInt进行统计
        Double averageOne = tmpList.parallelStream().collect(
                // -&gt; 根据Int值统计出平均值Double的统计器
                Collectors.averagingInt(
                        x -&gt; x == null ? 0 : x.getAge()
                )

        );
        // 输出: 29.0
        System.out.println(averageOne);

        // Collectors.averagingLong进行统计
        Double averageTwo = tmpList.parallelStream().collect(
                // -&gt; 根据Long值统计出平均值Double的统计器
                Collectors.averagingLong(
                        x -&gt; x == null ? 0L : x.getWorkStartTimestamp()
                )
        );
        // 输出: 2.0
        System.out.println(averageTwo);

        // Collectors.averagingDouble进行统计
        Double averageThree = tmpList.parallelStream().collect(
                // -&gt; 根据Double值统计出平均值Double的统计器
                Collectors.averagingDouble(
                        x -&gt; x == null ? 0D : x.getFaceScore()
                )
        );
        // 输出: 85.90000000000002
        // 注:由于计算机二进制存数的问题，返回的double值可能存在误差, 如:这里理
        //    论上应返回85.9, 但是实际上返回的是85.90000000000002
        System.out.println(averageThree);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.collectingAndThen：</span></strong></span></p> 
<p>先按照Collectors对Stream&lt;T&gt;流中的元素进行统计(得到R), 再利用Function&lt;R,RR&gt;得到并返回RR。</p> 
<pre><code class="language-java">/**
     * 先按照Collectors对Stream&lt;T&gt;流中的元素进行统计(得到R), 再利用Function&lt;R,RR&gt;得到并返回RR。
     * 即:对流的元素先Collector&lt;T,A,R&gt; downstream,再对得到的结果进行Function&lt;R,RR&gt; finisher，最后返回RR。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的collectingAndThen方法，签名为:
     *       Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt; downstream,
     *                                           Function&lt;R,RR&gt; finisher)
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_1() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三").age(18).workStartTimestamp(1L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(25).workStartTimestamp(2L).faceScore(89.2D).build(),
                Staff.builder().name("王五").age(40).workStartTimestamp(3L).faceScore(68.7D).build()
        );

        // 为便于理解，这里 先编写一个Function&lt;R,RR&gt; finisher
        Function&lt;Set&lt;Staff&gt;, Integer&gt; function = Set::size;

        // 先Collector&lt;T,A,R&gt; downstream,再Function&lt;R,RR&gt; finisher，最后返回RR。
        Integer size = tmpList.parallelStream().collect(
                Collectors.collectingAndThen(
                        Collectors.toSet(),
                        function
                )
        );
        // 输出: 3
        System.out.println(size);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.counting：</span></strong></span></p> 
<p>对stream中的元素进行计数。</p> 
<pre><code class="language-java">/**
     * 对stream中的元素进行计数。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的counting方法，签名为:
     *       Collector&lt;T, ?, Long&gt; counting()
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_2() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三").age(18).workStartTimestamp(1L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(25).workStartTimestamp(2L).faceScore(89.2D).build(),
                Staff.builder().name("王五").age(40).workStartTimestamp(3L).faceScore(68.7D).build()
        );
        @SuppressWarnings("all")
        // 对stream中的元素进行计数。 等价于Stream的count()方法。
        Long count = tmpList.parallelStream().collect(
                Collectors.counting()
        );
        // 输出: 3
        System.out.println(count);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.groupingBy：</span></strong></span></p> 
<p>对stream中的元素进行分组。</p> 
<p><strong>用法一</strong>： 先通过classifier，计算每个元素对应的key，然后再通过Collectors的groupingBy方法，按key值分组，得到并返回Map&lt;K, List&lt;T&gt;&gt;。</p> 
<pre><code class="language-java">/**
     * 对stream中的元素进行分组:
     *     先通过classifier，计算每个元素对应的key,然后再通过Collectors的
     *     groupingBy方法，按key值分组，得到并返回Map&lt;K, List&lt;T&gt;&gt;
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的重载groupingBy方法，(本次示例的方法的)签名为:
     *       Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)
     *    追注:此方法内部调用的实际是groupingBy(classifier, HashMap::new, toList())方法
     *
     * 注:此方法返回的Map实现是非线程安全的，如果需要返回线程安全的Map实现，可使用(使用方式几乎一致):
     *         Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T&gt;&gt;&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier)
     *
     * 注: 不论是串行stream，还是并行parallelStream，对于groupingBy(或groupingByConcurrent)本身来说，是线程安全的。
     *
     * 注:当前stream类型为T。
     *
     *
     */
    @Test
    public void test27_3() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三1").age(18).build(),
                Staff.builder().name("张三2").age(15).build(),
                Staff.builder().name("李四1").age(25).build(),
                Staff.builder().name("李四2").age(23).build(),
                Staff.builder().name("王五1").age(55).build(),
                Staff.builder().name("王五2").age(40).build()
        );

        // 为便于理解，这里 先编写一个Function&lt;? super T, ? extends K&gt; classifier
        // 这个classifier的作用是: 根据元素T，返回其对应的K, 然后Collectors.groupingBy会根据K，
        // 将stream中的元素按键值对分组为Map&lt;K, List&lt;T&gt;
        Function&lt;Staff, String&gt; function = x -&gt; x.getName() == null ? "" : x.getName().substring(0, 1);

        // 使用Collectors.groupingBy，按照(通过Function得到的)key进行分组，得到并返回Map&lt;K, List&lt;T&gt;&gt;
        Map&lt;String, List&lt;Staff&gt;&gt; resultMap = tmpList.parallelStream().collect(
                Collectors.groupingBy(function)
        );

        // 输出(为方便观察，本人简单整理了一下输出结果):
        // {
        //   张=[
        //       Staff(name=张三1, age=18, staffNo=null, faceScore=null, workStartTimestamp=null),
        //       Staff(name=张三2, age=15, staffNo=null, faceScore=null, workStartTimestamp=null)
        //      ],
        //
        //   王=[
        //       Staff(name=王五1, age=55, staffNo=null, faceScore=null, workStartTimestamp=null),
        //       Staff(name=王五2, age=40, staffNo=null, faceScore=null, workStartTimestamp=null)
        //      ],
        //
        //   李=[
        //       Staff(name=李四1, age=25, staffNo=null, faceScore=null, workStartTimestamp=null),
        //       Staff(name=李四2, age=23, staffNo=null, faceScore=null, workStartTimestamp=null)
        //      ]
        // }
        System.out.println(resultMap);
    }</code></pre> 
<p><strong>用法二</strong>： 先通过classifier，计算每个元素对应的key，然后根据key进行分组，然后对每组的元素T进行downstream统计，得到每组的结果D， 最终返回Map&lt;K, D&gt;。</p> 
<p>即：先通过classifier得到Map&lt;K, List&lt;T&gt;&gt;，再通过对每个List&lt;T&gt;进行downstream统计，最终得到Map&lt;K, D&gt;。</p> 
<pre><code class="language-java">/**
     * 对stream中的元素进行分组:
     *     先通过classifier，计算每个元素对应的key,然后根据key进行分组，然后对每组的
     *     元素T进行downstream统计，得到每组的结果D， 最终返回Map&lt;K, D&gt;。
     *     即:先通过classifier得到Map&lt;K, List&lt;T&gt;&gt;，再通过
     *        对每个List&lt;T&gt;进行downstream统计，最终得到Map&lt;K, D&gt;。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的重载groupingBy方法，(本次示例的方法的)签名为:
     *       Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,
     *                                             Collector&lt;? super T, A, D&gt; downstream)
     *    追注:此方法内部调用的实际是groupingBy(classifier, HashMap::new, downstream)方法
     *
     * 注:此方法返回的Map实现是非线程安全的，如果需要返回线程安全的Map实现，可使用(使用方式几乎一致):
     *         Collector&lt;T, ?, ConcurrentMap&lt;K, D&gt;&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,
     *                                                                   Collector&lt;? super T, A, D&gt; downstream)
     *
     * 注: 不论是串行stream，还是并行parallelStream，对于groupingBy(或groupingByConcurrent)本身来说，是线程安全的。
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_4() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三1").age(18).build(),
                Staff.builder().name("张三2").age(15).build(),
                Staff.builder().name("张三3").age(11).build(),
                Staff.builder().name("李四1").age(25).build(),
                Staff.builder().name("李四2").age(23).build(),
                Staff.builder().name("王五1").age(55).build(),
                Staff.builder().name("王五2").age(40).build()
        );

        // 为便于理解，这里 先编写一个Function&lt;? super T, ? extends K&gt; classifier
        Function&lt;Staff, String&gt; function = x -&gt; x.getName() == null ? "" : x.getName().substring(0, 1);

        // 使用Collectors.groupingBy，按照(通过Function得到的)key进行分组并对各组元素进行统计，得到并返回Map&lt;K, D&gt;
        Map&lt;String, Long&gt; resultMap = tmpList.parallelStream().collect(
                Collectors.groupingBy(function, Collectors.counting())
        );

        // 输出: {张=3, 王=2, 李=2}
        System.out.println(resultMap);
    }</code></pre> 
<p><strong>用法三</strong>： 先通过classifier，计算每个元素对应的key，然后根据key进行分组，然后对每组的元素T进行downstream统计，得到每组的结果D。最终返回Map&lt;K, D&gt;。Map&lt;K, D&gt;即对应Supplier&lt;M&gt; mapFactory中的M，换句话说，返回的Map容器由mapFactory进行提供。</p> 
<p>即：先通过classifier得到Map&lt;K, List&lt;T&gt;&gt;，再通过对每个List&lt;T&gt;进行downstream统计，并将K和D放入由mapFactory提供的M中(即:mapFactory提供的Map中)，并进行返回。</p> 
<pre><code class="language-java">/**
     * 对stream中的元素进行分组:
     *     先通过classifier，计算每个元素对应的key,然后根据key进行分组，然后对每组的
     *     元素T进行downstream统计，得到每组的结果D。最终返回Map&lt;K, D&gt;。Map&lt;K, D&gt;
     *     即对应Supplier&lt;M&gt; mapFactory中的M，换句话说:返回的Map容器由mapFactory进行提供。
     *     即:先通过classifier得到Map&lt;K, List&lt;T&gt;&gt;，再通过
     *        对每个List&lt;T&gt;进行downstream统计，并将K和D放入由mapFactory提供
     *        的M中(即:mapFactory提供的Map中)，并进行返回。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的重载groupingBy方法，(本次示例的方法的)签名为:
     *       Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,
     *                                     Supplier&lt;M&gt; mapFactory,
     *                                     Collector&lt;? super T, A, D&gt; downstream)
     * 注:此方法返回的Map实现是非线程安全的，如果需要返回线程安全的Map实现，可使用(使用方式几乎一致):
     *         Collector&lt;T, ?, M&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,
     *                                                 Supplier&lt;M&gt; mapFactory,
     *                                                 Collector&lt;? super T, A, D&gt; downstream)
     *
     * 注: 不论是串行stream，还是并行parallelStream，对于groupingBy(或groupingByConcurrent)本身来说，是线程安全的。
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_5() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三1").age(18).build(),
                Staff.builder().name("张三2").age(15).build(),
                Staff.builder().name("张三3").age(11).build(),
                Staff.builder().name("李四1").age(25).build(),
                Staff.builder().name("李四2").age(23).build(),
                Staff.builder().name("王五1").age(55).build(),
                Staff.builder().name("王五2").age(40).build()
        );

        // 为便于理解，这里 先编写一个Function&lt;? super T, ? extends K&gt; classifier
        Function&lt;Staff, String&gt; function = x -&gt; x.getName() == null ? "" : x.getName().substring(0, 1);


        //  Supplier&lt;M&gt; mapFactory
        Supplier&lt;TreeMap&lt;String, Long&gt;&gt; mapFactory = TreeMap::new;

        // 使用Collectors.groupingBy，按照(通过Function得到的)key进行分组并对各组元素进行统计，得到并返回Map&lt;K, D&gt;
        Map&lt;String, Long&gt; resultMap = tmpList.parallelStream().collect(
                Collectors.groupingBy(function, mapFactory, Collectors.counting())
        );

        // 输出: {张=3, 王=2, 李=2}
        System.out.println(resultMap);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.joining：</span></strong></span></p> 
<p>字符串拼接。</p> 
<p><strong>用法一</strong>：对Stream&lt;String&gt;中的元素直接进行拼接。</p> 
<pre><code class="language-java">/**
     * 对Stream&lt;String&gt;中的元素直接进行拼接。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的joining方法，签名为:
     *         Collector&lt;CharSequence, ?, String&gt; joining()
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_6() {
        // 数据准备
        List&lt;String&gt; tmpList = Lists.newArrayList("A","B","C","D","E");

        String resultStr = tmpList.parallelStream().collect(
                Collectors.joining()
        );

        // 输出: ABCDE
        System.out.println(resultStr);
    }</code></pre> 
<p><strong>用法二</strong>：对Stream&lt;String&gt;中的元素以delimiter为分隔符进行拼接。</p> 
<pre><code class="language-java">/**
     * 对Stream&lt;String&gt;中的元素以delimiter为分隔符进行拼接。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的joining方法，签名为:
     *         Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_7() {
        // 数据准备
        List&lt;String&gt; tmpList = Lists.newArrayList("A","B","C","D","E");

        String resultStr = tmpList.parallelStream().collect(
                Collectors.joining("-")
        );

        // 输出: A-B-C-D-E
        System.out.println(resultStr);
    }</code></pre> 
<p><strong>用法三</strong>：以delimiter为分隔符，以prefix为前缀，以suffix为后缀，对Stream&lt;String&gt;中的元素进行拼接。</p> 
<pre><code class="language-java">/**
     * 以delimiter为分隔符，以prefix为前缀，以suffix为后缀，对Stream&lt;String&gt;中的元素进行拼接。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的joining方法，签名为:
     *         Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,
     *                                                    CharSequence prefix,
     *                                                    CharSequence suffix)
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_8() {
        // 数据准备
        List&lt;String&gt; tmpList = Lists.newArrayList("A","B","C","D","E");

        String resultStr = tmpList.parallelStream().collect(
                Collectors.joining("-", "[", "]")
        );

        // 输出: [A-B-C-D-E]
        System.out.println(resultStr);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.mapping：</span></strong></span></p> 
<p>先以mapper将Stream&lt;T&gt;转换为Stream&lt;U&gt;，再用downstream对Stream&lt;U&gt;进行统计。</p> 
<p>提示：collect(mapping())能做的事，.map().collect()都能做；我们一般都使用.map().collect()，而不使用collect(mapping())。</p> 
<pre><code class="language-java">/**
     * 先以mapper将Stream&lt;T&gt;转换为Stream&lt;U&gt;，再用downstream对Stream&lt;U&gt;进行统计。
     *
     * 提示:collect(mapping())能做的事，.map().collect()都能做；我们一般都
     *     使用.map().collect()，而不使用collect(mapping())。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的mapping方法，签名为:
     *         Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper,
     *                                    Collector&lt;? super U, A, R&gt; downstream)
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_9() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三").age(18).workStartTimestamp(1L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(25).workStartTimestamp(2L).faceScore(89.2D).build(),
                Staff.builder().name("王五").age(40).workStartTimestamp(3L).faceScore(68.7D).build()
        );

        // 为便于理解，这里 先编写一个Function&lt;? super T, ? extends U&gt; mapper
        Function&lt;Staff, String&gt; function = Staff::getName;
        @SuppressWarnings("all")
        String resultStr = tmpList.parallelStream().collect(
                Collectors.mapping(
                        function,
                        Collectors.joining("&amp;")
                )
        );
        // 输出: 张三&amp;李四&amp;王五
        System.out.println(resultStr);

        /// 以.map().collect()的方式来实现的话，是这样的:
        String resultStr2 =  tmpList.parallelStream().map(Staff::getName).collect(Collectors.joining("&amp;"));
        // 输出: 张三&amp;李四&amp;王五
        System.out.println(resultStr2);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.maxBy、Collectors.minBy：</span></strong></span></p> 
<p>根据比较器，筛选出Stream&lt;T&gt;中最大、最小的元素。</p> 
<pre><code class="language-java">/**
     * 根据比较器，筛选出Stream&lt;T&gt;中最大、最小的元素。
     *
     * 注:推荐使用.max()、.min()的方式，而非.collect(Collectors.maxBy())、.collect(Collectors.minBy())
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的maxBy方法，签名为:
     *         Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator)
     *
     * 注:Collectors的maxBy方法，签名为:
     *         Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator)
     *
     * 注:当前stream类型为T。
     */
    @Test
    @SuppressWarnings("all")
    public void test27_10() {
        // 数据准备
        List&lt;Integer&gt; tmpList = Lists.newArrayList(3, 5, 1, 7, 9);

        // 比较器准备
        Comparator&lt;Integer&gt; comparator = Comparator.comparingInt(x -&gt; x);

        // -&gt; 最大值
        // 等价于: tmpList.parallelStream().max(comparator)
        Optional&lt;Integer&gt; maxResult = tmpList.parallelStream().collect(
                Collectors.maxBy(comparator)
        );
        // 输出: 9
        maxResult.ifPresent(System.out::println);

        // -&gt; 最小值
        // 等价于: tmpList.parallelStream().min(comparator)
        Optional&lt;Integer&gt; minResult = tmpList.parallelStream().collect(
                Collectors.minBy(comparator)
        );
        // 输出: 1
        minResult.ifPresent(System.out::println);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.partitioningBy：</span></strong></span></p> 
<p>(按key为true或false进行)分组。</p> 
<p><strong>用法一</strong>： 将Stream中的元素，分为两组: predicate通过的分到key为true的组，否者分到key为false的组,最后得到并返回Map&lt;Boolean, List&lt;T&gt;&gt;&gt;。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;中的元素，分为两组: predicate通过的分到key为true的组，否者分到key为false的组,
     * 最后得到并返回Map&lt;Boolean, List&lt;T&gt;&gt;&gt;。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的partitioningBy方法，签名为:
     *         Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)
     *    追注:此方法与groupingBy方法类似，也是分组。不过此方法是根据predicate将元素分为key为tru/false两组;
     *        而groupingBy是根据Function&lt;? super T, ? extends K&gt; classifier来进行的分组。
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_11() {
        // 数据准备
        List&lt;Integer&gt; tmpList = Lists.newArrayList(3, 5, 1, 7, 9);

        // 准备一个比较器
        Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; 6;

        // -&gt; 最大值
        Map&lt;Boolean, List&lt;Integer&gt;&gt; resultMap = tmpList.parallelStream().collect(
                Collectors.partitioningBy(predicate)
        );
        // 输出: {false=[3, 5, 1], true=[7, 9]}
        System.out.println(resultMap);
    }</code></pre> 
<p><strong>用法二</strong>： 将Stream&lt;T&gt;中的元素，分为两组: predicate通过的分到key为true的组，否者分到key为false的组，然后通过downstream再对每组进行统计(得到统计结果D)，最后得到并返回Map&lt;Boolean, D&gt;。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;中的元素，分为两组: predicate通过的分到key为true的组，否者分到key为false的组,
     * 然后通过downstream再对每组进行统计(得到统计结果D)，最后得到并返回Map&lt;Boolean, D&gt;。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的partitioningBy方法，签名为:
     *         Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate,
     *                                                         Collector&lt;? super T, A, D&gt; downstream)
     *    追注:此方法与groupingBy方法类似,类比着进行理解即可。
     *
     * 注:当前stream类型为T。
     */
    @Test
    public void test27_12() {
        // 数据准备
        List&lt;Integer&gt; tmpList = Lists.newArrayList(3, 5, 1, 7, 9);

        // 准备一个比较器
        Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; 6;

        // -&gt; 最大值
        Map&lt;Boolean, Long&gt; resultMap = tmpList.parallelStream().collect(
                Collectors.partitioningBy(
                        predicate,
                        Collectors.counting()
                )
        );
        // 输出: {false=3, true=2}
        System.out.println(resultMap);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.reducing：</span></strong></span></p> 
<p>对Stream中的元素进行归并。</p> 
<p>提示： 串行流下的reduce与并行流下的reduce可能结果不一样，如果不太熟悉的话，建议使用stream的reduce()，而不使用.stream().collect(Collectors.reducing())。</p> 
<pre><code class="language-java">/**
     * 对Stream&lt;T&gt;中的元素进行归并。
     * 提示:串行流下的reduce与并行流下的reduce可能结果不一样，如果不太熟悉的话，建议
     *      使用stream的reduce()，而不使用.stream().collect(Collectors.reducing())。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的reducing方法，签名为:
     *        Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)
     *
     * 注:当前stream类型为T。
     *
     * 声明:在stream的collect()方法内部进行reduce的，总共有下述三种方法
     *      Collector&lt;T,?,Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)
     *      Collector&lt;T,?,T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)
     *      Collector&lt;T,?,U&gt; reducing(U identity, Function&lt;? super T,? extends U&gt; mapper, BinaryOperator&lt;U&gt; op),
     *      此这里只示例第一种。
     */
    @Test
    public void test27_13() {
        // 数据准备
        List&lt;Integer&gt; tmpList = Lists.newArrayList(3, 5, 1, 7, 9);

        BinaryOperator&lt;Integer&gt; binaryOperator = Integer::sum;
        // -&gt; 进行归并
        @SuppressWarnings("all")
        Optional&lt;Integer&gt; result = tmpList.stream().collect(
                Collectors.reducing(binaryOperator)
        );
        // 输出: 25
        result.ifPresent(System.out::println);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.summarizingInt、Collectors.summarizingLong、Collectors.summarizingDouble：</span></strong></span></p> 
<p>对Stream&lt;T&gt;中的元素T“对应”的int/long/double值进行统计，并获得一个统计对象；通过此对象可以获得具体的统计信息(如：最大值、最小值、平均值、总和、数量)。</p> 
<pre><code class="language-java">/**
     * 对Stream&lt;T&gt;中的元素T“对应”的int/long/double值进行统计，并获得一个统计对象；
     * 通过此对象可以获得具体的统计信息(如:最大值、最小值、平均值、总和、数量)。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的summarizingInt方法，签名为:
     *        Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper)
     *
     * 注:Collectors的summarizingLong方法，签名为:
     *        Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper)
     *
     * 注:Collectors的summarizingDouble方法，签名为:
     *        Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper)
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    public void test27_14() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );

        /// -&gt; summarizingInt示例
        // 编写mapper，使用此mapper,能根据Stream&lt;T&gt;中的元素T，获取到对应的int值
        ToIntFunction&lt;Staff&gt; intMapper = Staff::getAge;
        // 采集数据，获得统计信息 对象
        IntSummaryStatistics intResult = tmpList.parallelStream().collect(
                Collectors.summarizingInt(intMapper)
        );
        // 输出: IntSummaryStatistics{count=3, sum=87, min=18, average=29.000000, max=45}
        System.out.println(intResult);

        /// -&gt; summarizingLong示例
        // 编写mapper，使用此mapper,能根据Stream&lt;T&gt;中的元素T，获取到对应的int值
        ToLongFunction&lt;Staff&gt; longMapper = Staff::getWorkStartTimestamp;
        // 采集数据，获得统计信息 对象
        LongSummaryStatistics longResult = tmpList.parallelStream().collect(
                Collectors.summarizingLong(longMapper)
        );
        // 输出: LongSummaryStatistics{count=3, sum=1368, min=123, average=456.000000, max=789}
        System.out.println(longResult);

        /// -&gt; summarizingDouble示例
        // 编写mapper，使用此mapper,能根据Stream&lt;T&gt;中的元素T，获取到对应的double值
        ToDoubleFunction&lt;Staff&gt; doubleMapper = Staff::getFaceScore;
        // 采集数据，获得统计信息 对象
        DoubleSummaryStatistics doubleResult = tmpList.parallelStream().collect(
                Collectors.summarizingDouble(doubleMapper)
        );
        // 输出: DoubleSummaryStatistics{count=3, sum=199.800000, min=33.300000, average=66.600000, max=99.900000}
        System.out.println(doubleResult);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.summingInt、Collectors.summingLong、Collectors.summingDouble：</span></strong></span></p> 
<p>求和。</p> 
<p>提示：建议使用.mapToInt().sum()，而不使用.collect(Collectors.summingInt())；建议使用.mapToLong().sum()，而不使用.collect(Collectors.summingLong())；建议使用.mapToDouble().sum()，而不使用.collect(Collectors.summingDouble())。</p> 
<pre><code class="language-java">/**
     * 对Stream&lt;T&gt;中的元素T“对应”的int/long/double值进行求和。
     *
     * 建议使用.mapToInt().sum()，而不使用.collect(Collectors.summingInt())
     * 建议使用.mapToLong().sum()，而不使用.collect(Collectors.summingLong())
     * 建议使用.mapToDouble().sum()，而不使用.collect(Collectors.summingDouble())
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的summarizingInt方法，签名为:
     *        Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)
     *
     * 注:Collectors的summarizingLong方法，签名为:
     *        Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper)
     *
     * 注:Collectors的summarizingDouble方法，签名为:
     *        Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper)
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    @SuppressWarnings("all")
    public void test27_15() {
        // 数据准备
        List&lt;Staff&gt; tmpList = Lists.newArrayList(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );

        /// -&gt; summingInt示例
        // 编写mapper，使用此mapper,能根据Stream&lt;T&gt;中的元素T，获取到对应的int值
        ToIntFunction&lt;Staff&gt; intMapper = Staff::getAge;
        // Integer求和
        Integer intResult = tmpList.parallelStream().collect(
                Collectors.summingInt(intMapper)
        );
        // 输出: 87
        System.out.println(intResult);

        /// -&gt; summingLong示例
        // 编写mapper，使用此mapper,能根据Stream&lt;T&gt;中的元素T，获取到对应的int值
        ToLongFunction&lt;Staff&gt; longMapper = Staff::getWorkStartTimestamp;
        // Long求和
        Long longResult = tmpList.parallelStream().collect(
                Collectors.summingLong(longMapper)
        );
        // 输出: 1368
        System.out.println(longResult);

        /// -&gt; summingDouble示例
        // 编写mapper，使用此mapper,能根据Stream&lt;T&gt;中的元素T，获取到对应的double值
        ToDoubleFunction&lt;Staff&gt; doubleMapper = Staff::getFaceScore;
        //  Double求和
        Double doubleResult = tmpList.parallelStream().collect(
                Collectors.summingDouble(doubleMapper)
        );
        // 输出: 199.8
        System.out.println(doubleResult);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.toList：</span></strong></span></p> 
<p>将Stream&lt;T&gt;转换为一个集合List&lt;T&gt;。</p> 
<p>提示：实际上转换成的是ArrayList&lt;T&gt;。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;转换为一个集合List&lt;T&gt;。
     * 注:实际上转换成的是ArrayList&lt;T&gt;
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的toList方法，签名为:
     *        Collector&lt;T, ?, List&lt;T&gt;&gt; toList()
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    public void test27_16() {
        // 数据准备
        Stream&lt;Staff&gt; s = Stream.of(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );
        // 将String&lt;T&gt;转换为集合List&lt;T&gt;
        List&lt;Staff&gt; list = s.parallel().collect(
                Collectors.toList()
        );
        // 输出(为方便观察，本人简单整理了一下输出结果):
        // [
        //  Staff(name=张三, age=18, staffNo=null, faceScore=99.9, workStartTimestamp=123),
        //  Staff(name=李四, age=45, staffNo=null, faceScore=66.6, workStartTimestamp=456),
        //  Staff(name=王五, age=24, staffNo=null, faceScore=33.3, workStartTimestamp=789)
        // ]
        System.out.println(list);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.toSet：</span></strong></span></p> 
<p>将Stream&lt;T&gt;转换为一个集合Set&lt;T&gt;。</p> 
<p>提示：实际上转换成的是HashSet&lt;T&gt;。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;转换为一个集合Set&lt;T&gt;。
     * 注:实际上转换成的是HashSet&lt;T&gt;。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的toSet方法，签名为:
     *        Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    public void test27_17() {
        // 数据准备
        Stream&lt;Staff&gt; s = Stream.of(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );
        // 将String&lt;T&gt;转换为集合List&lt;T&gt;
        Set&lt;Staff&gt; set = s.parallel().collect(
                Collectors.toSet()
        );
        // 输出(为方便观察，本人简单整理了一下输出结果):
        // [
        //  Staff(name=张三, age=18, staffNo=null, faceScore=99.9, workStartTimestamp=123),
        //  Staff(name=李四, age=45, staffNo=null, faceScore=66.6, workStartTimestamp=456),
        //  Staff(name=王五, age=24, staffNo=null, faceScore=33.3, workStartTimestamp=789)
        // ]
        System.out.println(set);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.toCollection：</span></strong></span></p> 
<p>将Stream转换为一个(自定义类型的)集合。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;转换为一个(自定义类型的)集合。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的toCollection方法，签名为:
     *        Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    public void test27_18() {
        // 数据准备
        Stream&lt;Staff&gt; s = Stream.of(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );

        // 先实现Supplier&lt;C&gt;, Supplier&lt;C&gt;会提供一种集合容器。
        Supplier&lt;LinkedList&lt;Staff&gt;&gt; collectionFactory = LinkedList::new;

        // 将String&lt;T&gt;转换为集合LinkedList&lt;T&gt;
        LinkedList&lt;Staff&gt; linkedList = s.parallel().collect(
                Collectors.toCollection(collectionFactory)
        );
        // 输出(为方便观察，本人简单整理了一下输出结果):
        // [
        //  Staff(name=张三, age=18, staffNo=null, faceScore=99.9, workStartTimestamp=123),
        //  Staff(name=李四, age=45, staffNo=null, faceScore=66.6, workStartTimestamp=456),
        //  Staff(name=王五, age=24, staffNo=null, faceScore=33.3, workStartTimestamp=789)
        // ]
        System.out.println(linkedList);
    }</code></pre> 
<p><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;">Collectors.toMap、Collectors.toConcurrentMap：</span></strong></span></p> 
<p>将流转换为Map(或ConcurrentMap)。</p> 
<p>特别注意：筛选出来后(，调用Map#merge方法之前，需保证)value值不能为null，否者会报NPE。可详见源码java.util.Map(或其对应子类)的merge方法。</p> 
<p><strong>用法一</strong>： 将Stream&lt;T&gt;转换为一个Map， 在转换时若发现重复的key，那么会抛出异常。</p> 
<p>提示：这里示例的是toMap方法(转换为线程非安全的Map),对应的(转换为线程 安全的ConcurrentMap的)toConcurrentMap方法用法几乎是一样的。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;转换为一个Map, 在转换时若发现重复的key,那么会抛出异常。
     *
     * 提示:这里示例的是toMap方法(转换为线程非安全的Map),对应的(转换为线程
     *      安全的ConcurrentMap的)toConcurrentMap方法用法几乎是一样的。
     *
     * 特别注意:筛选出来后(，调用Map#merge方法之前，需保证)value值不能为null,否者会报NPE。可详见源码java.util.Map(或其对应子类)的merge方法。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的toMap方法，签名为:
     *        Collector&lt;T,?,Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper)
     *        追注:此方式的toMap,要求key不能有重复的，否者会出错
     *            java.lang.IllegalStateException: java.lang.IllegalStateException: Duplicate key...
     *        追注:此方法内部调用的其实是:toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
     *
     * 注:Collectors的toConcurrentMap方法，签名为:
     *        Collector&lt;T,?,ConcurrentMap&lt;K,U&gt;&gt; toConcurrentMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper)
     *        追注:用法与本示例几乎一样，不过toConcurrentMap是线程安全的。
     *        追注:此方式的toMap,要求key不能有重复的，否者会出错
     *            java.lang.IllegalStateException: java.lang.IllegalStateException: Duplicate key...
     *        追注:此方法内部调用的其实是:toConcurrentMap(keyMapper, valueMapper, throwingMerger(), ConcurrentHashMap::new)
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    public void test27_19() {
        // 数据准备
        Stream&lt;Staff&gt; s = Stream.of(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );

        // 编写一个keyMapper，用于 根据元素T获取对应的key
        Function&lt;Staff, String&gt; keyMapper = Staff::getName;

        // 编写一个valueMapper，用于 根据元素T获取对应的value
        Function&lt;Staff, Integer&gt; valueMapper = Staff::getAge;

        // 将Stream&lt;T&gt;转换为Map
        Map&lt;String, Integer&gt; resultMap = s.collect(
                Collectors.toMap(keyMapper, valueMapper)
        );

        // 输出: {李四=45, 张三=18, 王五=24}
        System.out.println(resultMap);
    }</code></pre> 
<p><strong>用法二</strong>： 将Stream&lt;T&gt;转换为一个Map，在转换时若发现重复的key，那么会根据mergeFunction来决定该key的value是多少。</p> 
<p>提示：这里示例的是toMap方法(转换为线程非安全的Map),对应的(转换为线程安全的ConcurrentMap的)toConcurrentMap方法用法几乎是一样的。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;转换为一个Map, 在转换时若发现重复的key,那么会根据mergeFunction来决定该key的value是多少。
     *
     * 提示:这里示例的是toMap方法(转换为线程非安全的Map),对应的(转换为线程
     *      安全的ConcurrentMap的)toConcurrentMap方法用法几乎是一样的。
     *
     * 特别注意:筛选出来后(，调用Map#merge方法之前，需保证)value值不能为null,否者会报NPE。可详见源码java.util.Map(或其对应子类)的merge方法。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的toMap方法，签名为:
     *        Collector&lt;T,?,Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)
     *        追注:此方法内部调用的其实是:toMap(keyMapper, valueMapper, mergeFunction, HashMap::new)
     *
     * 注:Collectors的toConcurrentMap方法，签名为:
     *        Collector&lt;T,?,ConcurrentMap&lt;K,U&gt;&gt; toConcurrentMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)
     *        追注:用法与本示例几乎一样，不过toConcurrentMap是线程安全的。
     *        追注:此方法内部调用的其实是:toConcurrentMap(keyMapper, valueMapper, mergeFunction, ConcurrentHashMap::new)
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    public void test27_20() {
        // 数据准备
        Stream&lt;Staff&gt; s = Stream.of(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("张三").age(100).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );

        // 编写一个keyMapper，用于 根据元素T获取对应的key
        Function&lt;Staff, String&gt; keyMapper = Staff::getName;

        // 编写一个valueMapper，用于 根据元素T获取对应的value
        Function&lt;Staff, Staff&gt; valueMapper = Function.identity();

        // 编写一个mergeFunction，用于 处理 key冲突时的逻辑
        BinaryOperator&lt;Staff&gt; mergeFunction = (Staff preStaff, Staff nextValue) -&gt; {
            // 输出: oldStaff的name是[张三]， age是[18]
            System.err.println("preStaff的name是[" + preStaff.getName() + "]， age是[" + preStaff.getAge() + "]");
            // 输出: oldStaff的name是[张三]， age是[100]
            System.err.println("nextValue的name是[" + nextValue.getName() + "]， age是[" + nextValue.getAge() + "]");
            return nextValue;
        };

        // 将Stream&lt;T&gt;转换为Map
        Map&lt;String, Staff&gt; resultMap = s.collect(
                Collectors.toMap(keyMapper, valueMapper, mergeFunction)
        );

        // 输出(为方便观察，本人简单整理了一下输出结果):
        // {
        //  李四=Staff(name=李四, age=45, staffNo=null, faceScore=66.6, workStartTimestamp=456),
        //  张三=Staff(name=张三, age=100, staffNo=null, faceScore=99.9, workStartTimestamp=123),
        //  王五=Staff(name=王五, age=24, staffNo=null, faceScore=33.3, workStartTimestamp=789)
        // }
        System.out.println(resultMap);
    }</code></pre> 
<p><strong>用法三</strong>： 将Stream&lt;T&gt;转换为一个(由mapSupplier定义提供的)Map，在转换时若发现重复的key，那么会根据mergeFunction来决定该key的value是多少。</p> 
<p>提示：这里示例的是toMap方法(转换为线程非安全的Map),对应的(转换为线程安全的ConcurrentMap的)toConcurrentMap方法用法几乎是一样的。</p> 
<pre><code class="language-java">/**
     * 将Stream&lt;T&gt;转换为一个(由mapSupplier定义提供的)Map, 在转换时若发现重复的key,
     * 那么会根据mergeFunction来决定该key的value是多少。
     *
     * 提示:这里示例的是toMap方法(转换为线程非安全的Map),对应的(转换为线程
     *      安全的ConcurrentMap的)toConcurrentMap方法用法几乎是一样的。
     *
     * 特别注意:筛选出来后(，调用Map#merge方法之前，需保证)value值不能为null,否者会报NPE。可详见源码java.util.Map(或其对应子类)的merge方法。
     *
     * 注:Stream的collect方法，签名为:
     *       &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
     *
     * 注:Collectors的toMap方法，签名为:
     *        Collector&lt;T,?,M&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier)
     *
     * 注:Collectors的toConcurrentMap方法，签名为:
     *        Collector&lt;T,?,M&gt; toConcurrentMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier)
     *        追注:用法与本示例几乎一样，不过toConcurrentMap是线程安全的。
     *
     * 注:当前stream类型为T。
     *
     */
    @Test
    public void test27_21() {
        // 数据准备
        Stream&lt;Staff&gt; s = Stream.of(
                Staff.builder().name("张三").age(18).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("张三").age(100).workStartTimestamp(123L).faceScore(99.9D).build(),
                Staff.builder().name("李四").age(45).workStartTimestamp(456L).faceScore(66.6D).build(),
                Staff.builder().name("王五").age(24).workStartTimestamp(789L).faceScore(33.3D).build()
        );

        // 编写一个keyMapper，用于 根据元素T获取对应的key
        Function&lt;Staff, String&gt; keyMapper = Staff::getName;

        // 编写一个valueMapper，用于 根据元素T获取对应的value
        Function&lt;Staff, Integer&gt; valueMapper = Staff::getAge;

        // 编写一个mergeFunction，用于 处理 key冲突时的逻辑
        BinaryOperator&lt;Integer&gt; mergeFunction = (Integer preValue, Integer nextValue) -&gt; {
            // 输出: preValue是: 18
            System.err.println("preValue是: " + preValue);
            // 输出: nextValue是: 100
            System.err.println("nextValue是: " + nextValue);
            return nextValue;
        };

        // Map容器提供者。 .collect(Collectors.toMap())返回的Map, 由此mapSupplier进行提供。
        Supplier&lt;LinkedHashMap&lt;String, Integer&gt;&gt; mapSupplier = LinkedHashMap::new;

        // 将Stream&lt;T&gt;转换为Map
        LinkedHashMap&lt;String, Integer&gt; resultMap = s.collect(
                Collectors.toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)
        );

        // 输出: {张三=100, 李四=45, 王五=24}
        System.out.println(resultMap);
    }</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/daead548dec2079992c4be557139bdd0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue3&#43;TS封装全局按钮防抖函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a3edf3bc95e195a37348bb3800f2dcc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pip常用命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>