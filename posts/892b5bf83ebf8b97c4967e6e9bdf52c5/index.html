<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——查找的基本概念 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——查找的基本概念" />
<meta property="og:description" content="——本节内容为Bilibili王道考研《数据结构》P68~71视频内容笔记。
目录
一、基本概念
1.查找
2.查找表（查找结构）
3.关键字
4.静态查找表
5.动态查找表
6.查找长度
7.平均查找长度ASL
8.查找算法的效率评价
二、顺序查找
1.顺序查找
2.顺序查找的实现
3.图示
4.补充解释
5.有序表的顺序查找
6.被查概率不相等的情况
三、折半查找
1.折半查找
2.思想
3.算法
4.例子
5.查找效率分析
四、分块查找
1.分块查找
2.查找步骤
3.折半查找索引表
4.查找效率分析
一、基本概念 1.查找 在数据集合中寻找满足某种条件的数据元素的过程称为查找。
2.查找表（查找结构） 用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。
3.关键字 数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。
4.静态查找表 只进行查找符合条件的数据元素的操作，无需动态地修改查找表的查找表称为静态查找表。
5.动态查找表 需要动态地插入或删除的查找表称为动态查找表。
6.查找长度 在查找运算中，需要对比关键字的次数称为查找长度。
7.平均查找长度ASL 所有查找过程中进行关键字的比较次数的平均值，其数学定义为
式中，n是查找表的长度即元素个数；Pi是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即Pi=1/n；Ci是查找到第i个数据元素所需要进行的比较次数即查找第i个元素的查找长度。
ASL的数量级反映了查找算法时间复杂度。
8.查找算法的效率评价 （1）平均查找长度ASL；
（2）通常考虑查找成功、查找失败两种情况下的ASL。
二、顺序查找 1.顺序查找 即从头到尾依次查找，不论怎么优化，其时间复杂度都为O(n)。
2.顺序查找的实现 typedef struct {	//查找表的数据结构 int* elem;	//元素存储空间基址，建表时按实际长度分配，0号单元留空 int TableLen;	//表的长度 }SSTable; int Search_Seq(SSTable ST, int key) { ST." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/892b5bf83ebf8b97c4967e6e9bdf52c5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-29T19:07:37+08:00" />
<meta property="article:modified_time" content="2022-12-29T19:07:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——查找的基本概念</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>——本节内容为Bilibili王道考研《数据结构》P68~71视频内容笔记。</strong></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">一、基本概念</a></p> 
<p id="1.%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#1.%E6%9F%A5%E6%89%BE" rel="nofollow">1.查找</a></p> 
<p id="2.%E6%9F%A5%E6%89%BE%E8%A1%A8%EF%BC%88%E6%9F%A5%E6%89%BE%E7%BB%93%E6%9E%84%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.%E6%9F%A5%E6%89%BE%E8%A1%A8%EF%BC%88%E6%9F%A5%E6%89%BE%E7%BB%93%E6%9E%84%EF%BC%89" rel="nofollow">2.查找表（查找结构）</a></p> 
<p id="3.%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#3.%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">3.关键字</a></p> 
<p id="4.%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#4.%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8" rel="nofollow">4.静态查找表</a></p> 
<p id="5.%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#5.%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8" rel="nofollow">5.动态查找表</a></p> 
<p id="6.%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6-toc" style="margin-left:80px;"><a href="#6.%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6" rel="nofollow">6.查找长度</a></p> 
<p id="7.%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6ASL-toc" style="margin-left:80px;"><a href="#7.%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6ASL" rel="nofollow">7.平均查找长度ASL</a></p> 
<p id="8.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%E8%AF%84%E4%BB%B7-toc" style="margin-left:80px;"><a href="#8.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%E8%AF%84%E4%BB%B7" rel="nofollow">8.查找算法的效率评价</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE" rel="nofollow">二、顺序查找</a></p> 
<p id="1.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#1.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE" rel="nofollow">1.顺序查找</a></p> 
<p id="2.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.顺序查找的实现</a></p> 
<p id="3.%E5%9B%BE%E7%A4%BA-toc" style="margin-left:80px;"><a href="#3.%E5%9B%BE%E7%A4%BA" rel="nofollow">3.图示</a></p> 
<p id="%C2%A04.%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A-toc" style="margin-left:80px;"><a href="#%C2%A04.%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A" rel="nofollow"> 4.补充解释</a></p> 
<p id="5.%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#5.%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE" rel="nofollow">5.有序表的顺序查找</a></p> 
<p id="6.%E8%A2%AB%E6%9F%A5%E6%A6%82%E7%8E%87%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:80px;"><a href="#6.%E8%A2%AB%E6%9F%A5%E6%A6%82%E7%8E%87%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">6.被查概率不相等的情况</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE" rel="nofollow">三、折半查找</a></p> 
<p id="1.%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#1.%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE" rel="nofollow">1.折半查找</a></p> 
<p id="2.%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.%E6%80%9D%E6%83%B3" rel="nofollow">2.思想</a></p> 
<p id="3.%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#3.%E7%AE%97%E6%B3%95" rel="nofollow">3.算法</a></p> 
<p id="4.%E4%BE%8B%E5%AD%90-toc" style="margin-left:80px;"><a href="#4.%E4%BE%8B%E5%AD%90" rel="nofollow">4.例子</a></p> 
<p id="%C2%A05.%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%C2%A05.%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90" rel="nofollow"> 5.查找效率分析</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%9B%9B%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE" rel="nofollow">四、分块查找</a></p> 
<p id="%C2%A01.%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#%C2%A01.%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE" rel="nofollow"> 1.分块查找</a></p> 
<p id="%C2%A02.%E6%9F%A5%E6%89%BE%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#%C2%A02.%E6%9F%A5%E6%89%BE%E6%AD%A5%E9%AA%A4" rel="nofollow"> 2.查找步骤</a></p> 
<p id="3.%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%B4%A2%E5%BC%95%E8%A1%A8-toc" style="margin-left:80px;"><a href="#3.%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%B4%A2%E5%BC%95%E8%A1%A8" rel="nofollow">3.折半查找索引表</a></p> 
<p id="4.%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#4.%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90" rel="nofollow">4.查找效率分析</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">一、基本概念</h2> 
<h4 id="1.%E6%9F%A5%E6%89%BE">1.查找</h4> 
<p>        在数据集合中寻找满足某种条件的数据元素的过程称为查找。</p> 
<h4 id="2.%E6%9F%A5%E6%89%BE%E8%A1%A8%EF%BC%88%E6%9F%A5%E6%89%BE%E7%BB%93%E6%9E%84%EF%BC%89">2.查找表（查找结构）</h4> 
<p>        用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。</p> 
<h4 id="3.%E5%85%B3%E9%94%AE%E5%AD%97">3.关键字</h4> 
<p>        数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p> 
<h4 id="4.%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8">4.静态查找表</h4> 
<p>        只进行查找符合条件的数据元素的操作，无需动态地修改查找表的查找表称为静态查找表。</p> 
<h4 id="5.%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8">5.动态查找表</h4> 
<p>        需要动态地插入或删除的查找表称为动态查找表。</p> 
<h4 id="6.%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6">6.查找长度</h4> 
<p>        在查找运算中，需要对比关键字的次数称为查找长度。</p> 
<h4 id="7.%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6ASL">7.平均查找长度ASL</h4> 
<p>        所有查找过程中进行关键字的比较次数的平均值，其数学定义为</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="ASL=\sum_{i=1}^{n}P_{i}C_{i}" class="mathcode" src="https://images2.imgbox.com/c6/af/Uytgzuo0_o.png"></p> 
</blockquote> 
<p>        式中，n是查找表的长度即元素个数；Pi是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即Pi=1/n；Ci是查找到第i个数据元素所需要进行的比较次数即查找第i个元素的查找长度。</p> 
<p>       <strong>ASL的数量级反映了查找算法时间复杂度。</strong></p> 
<h4 id="8.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%E8%AF%84%E4%BB%B7">8.查找算法的效率评价</h4> 
<p>（1）平均查找长度ASL；</p> 
<p>（2）通常考虑查找成功、查找失败两种情况下的ASL。</p> 
<hr> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">二、顺序查找</h2> 
<h4 id="1.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">1.顺序查找</h4> 
<p>        <strong>即从头到尾依次查找，不论怎么优化，其时间复杂度都为O(n)。</strong></p> 
<h4 id="2.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0">2.顺序查找的实现</h4> 
<pre><code class="language-cpp">typedef struct {					//查找表的数据结构
	int* elem;						//元素存储空间基址，建表时按实际长度分配，0号单元留空
	int TableLen;					//表的长度
}SSTable;

int Search_Seq(SSTable ST, int key) {
	ST.elem[0] = key;				//“哨兵”，将关键字key放入0号位置
	int i = ST.TableLen;
	for (int i = ST.TableLen; ST.elem[i] != key; --i);	//从后往前找
	return i;						//若表中不存在关键字为key的元素，将查找到i为0时退出for循环
}
</code></pre> 
<h4 id="3.%E5%9B%BE%E7%A4%BA">3.图示</h4> 
<p><img alt="" height="676" src="https://images2.imgbox.com/65/10/WnnYzhCn_o.png" width="1200"></p> 
<h4 id="%C2%A04.%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A"> 4.补充解释</h4> 
<p>（1）上述算法中，将ST.elem[0]称为哨兵，引入它的目的是使得Search_Seq内的循环<strong>不必判断数组是否会越界</strong>；</p> 
<p>（2）当每个元素的查找概率相等为1/n时，有：</p> 
<blockquote> 
 <p style="text-align:center;">成功情况下：<img alt="ASL=\sum_{i=1}^{n}P_{i}(n-i+1)" class="mathcode" src="https://images2.imgbox.com/9a/cd/vVwcrMh6_o.png"></p> 
 <p style="text-align:center;">失败情况下：<img alt="ASL=n+1" class="mathcode" src="https://images2.imgbox.com/53/62/UJZ2N0wu_o.png"></p> 
</blockquote> 
<h4 id="5.%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">5.有序表的顺序查找</h4> 
<p>（1）引出：如果在查找之前就已经知道关键字是有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。</p> 
<p>（2）可以用如图所示的判定树来描述有序线性表的查找过程，树中的圆形结点表示有序线性表中存在的元素，树中的矩形结点称为失败结点（若有n个结点，则相应地有n+1个查找失败节点）。</p> 
<p><img alt="" height="791" src="https://images2.imgbox.com/d8/d9/a0nq19q4_o.png" width="1200"></p> 
<p>（3）<strong>一个成功结点的查找长度=自身所在层数；</strong></p> 
<p><strong>一个失败结点的查找长度=其父结点所在层数；</strong></p> 
<p>默认情况下，各种失败情况或成功情况都等概率发生。</p> 
<h4 id="6.%E8%A2%AB%E6%9F%A5%E6%A6%82%E7%8E%87%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E6%83%85%E5%86%B5">6.被查概率不相等的情况</h4> 
<p>        将被查概率大的放在靠前的位置（仅可降低查找成功的查找长度，对于查找失败来讲毫无优化），如下图：</p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/5f/b5/VpPQwqRa_o.png" width="1200"> </p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE">三、折半查找</h2> 
<h4 id="1.%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE">1.折半查找</h4> 
<p>        折半查找又称二分查找，它仅适用于有序的顺序表。</p> 
<h4 id="2.%E6%80%9D%E6%83%B3">2.思想</h4> 
<p>         首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排序时，若给定值key大于中间元素，则所查找的元素只可能在后半部分）。然后再缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</p> 
<h4 id="3.%E7%AE%97%E6%B3%95">3.算法</h4> 
<p>升序顺序表的折半查找：</p> 
<pre><code class="language-cpp">typedef struct {					//查找表的数据结构
	int* elem;						//元素存储空间基址，建表时按实际长度分配，0号单元留空
	int TableLen;					//表的长度
}SSTable;

int Binary_Search(SSTable L, int key) {			//升序顺序表折半查找
	int low = 0, high = L.TableLen - 1, mid;
	while (low &lt;= high)
	{
		mid = (low + high) / 2;					//取中间位置
		if (L.elem[mid] == key)
			return mid;							//查找成功则返回所在位置
		else if (L.elem[mid] &gt; key)
			high = mid - 1;						//从前半部分继续查找
		else
			low = mid + 1;						//从后半部分继续查找
	}
	return -1;									//查找失败，返回-1
}
</code></pre> 
<h4 id="4.%E4%BE%8B%E5%AD%90">4.例子</h4> 
<p>（1）查找成功</p> 
<p><img alt="" height="809" src="https://images2.imgbox.com/88/24/vVwwdbgf_o.png" width="652"></p> 
<p> （2）查找失败</p> 
<p><img alt="" height="620" src="https://images2.imgbox.com/74/21/UBcusdyq_o.png" width="656"></p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/b1/a5/NSNGM8HR_o.png" width="666"> </p> 
<h4 id="%C2%A05.%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"> 5.查找效率分析</h4> 
<p>（1）通过折半查找判定树来分析查找效率：</p> 
<p><img alt="" height="745" src="https://images2.imgbox.com/0a/77/BUm6fKB3_o.png" width="1200"></p> 
<p> （2）折半查找判定树的构造</p> 
<p>        ①如果当前low和high之间有奇数个元素，则mid分隔后左右两部分元素个数相等；</p> 
<p>        ②如果当前low和high之间有偶数个元素，则mid分隔后左半部分比右半部分少一个元素；</p> 
<p>        ③得出结论：<span style="color:#fe2c24;"><strong>在折半查找判定树的构造中，若<img alt="mid=\left \lfloor (low+high)/2 \right \rfloor" class="mathcode" src="https://images2.imgbox.com/5d/61/XeI9iHVD_o.png">，则对于任何一个结点，必有：右子树结点数-左子树结点数=0或1；</strong></span></p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/bf/4b/vPgAnCAU_o.png" width="1200"></p> 
<p>         ④<strong>折半查找判定树一定是一个平衡二叉树，任何一个树的左右子树的深度之差都不会超过1；因此元素个数为n时树高<img alt="h=\left \lceil log_{2}(n+1) \right \rceil" class="mathcode" src="https://images2.imgbox.com/1b/2d/OlVkJ7Br_o.png">；</strong></p> 
<p>        ⑤<strong>判定树结点关键字：左&lt;中&lt;右，满足二叉排序树的定义；失败结点：n+1个（等于成功结点的空链域数量）</strong></p> 
<p>（3）<strong>树高<img alt="h=\left \lceil log_{2}(n+1) \right \rceil" class="mathcode" src="https://images2.imgbox.com/de/27/1tIGlwJV_o.png">，所以查找成功ASL&lt;=h，查找失败ASL&lt;=h，所以折半查找的时间复杂度=<img alt="O(log_{2}n)" class="mathcode" src="https://images2.imgbox.com/86/ba/Q4rv7die_o.png">。</strong></p> 
<hr> 
<h2></h2> 
<h2 id="%E5%9B%9B%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE">四、分块查找</h2> 
<h4 id="%C2%A01.%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"> 1.分块查找</h4> 
<p>        分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。对于整个顺序表来说，<span style="color:#fe2c24;"><strong>块内无序，块间有序</strong></span>；而对于索引表来说，其中保存每个分块的最大关键字和分块的存储区间，如下图所示：</p> 
<pre><code class="language-cpp">typedef struct {          //索引表
	int maxValue;
	int low, high;
}Index;

int List[100];            //顺序表存储实际元素</code></pre> 
<p><img alt="" height="652" src="https://images2.imgbox.com/5e/45/RbF5OixI_o.png" width="1200"></p> 
<h4 id="%C2%A02.%E6%9F%A5%E6%89%BE%E6%AD%A5%E9%AA%A4"> 2.查找步骤</h4> 
<p>（1）在索引表中确定待查记录所在的块，<strong>可以顺序查找或折半查找索引表</strong>；</p> 
<p>（2）在块内顺序查找。</p> 
<h4 id="3.%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%B4%A2%E5%BC%95%E8%A1%A8">3.折半查找索引表</h4> 
<p>（1）由于索引表是有序的，所以可以对索引表进行折半查找；</p> 
<p>（2）若索引表中不包含目标关键字，则<span style="color:#fe2c24;"><strong>折半查找索引表最终停在low&gt;high，并且此时我们要在low所指的分块中进一步查找。</strong></span></p> 
<p><img alt="" height="611" src="https://images2.imgbox.com/86/e0/8E4y6C9s_o.png" width="1200"></p> 
<p> <span style="color:#fe2c24;"><strong>（3）关于为什么在low中进一步查找：</strong></span></p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/2e/23/nl7A8vtN_o.png" width="1180"></p> 
<p> （4）若在折半查找索引表时，low&gt;high时low超出了索引表的范围，此时直接查找失败，因为low&gt;high时我们要在low所指的分块中进一步查找，但low指空了。</p> 
<h4 id="4.%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90">4.查找效率分析</h4> 
<p><img alt="" height="797" src="https://images2.imgbox.com/63/0f/Ps4qiioH_o.png" width="1200"></p> 
<p> </p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f3e562278b985b9b1c1a6bdac4aa3d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Dnscat2实现DNS隐蔽隧道反弹Shell</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/79eb93e18b0e614f660a27c5779c990f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">POI通过模板导出excel（包含表头合并处理）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>