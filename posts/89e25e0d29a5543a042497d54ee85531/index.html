<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>io,nio,aio总结 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="io,nio,aio总结" />
<meta property="og:description" content="I/O简介 I/O（Input/Outpu） 即输入／输出 。
我们先从计算机结构的角度来解读一下 I/O。
根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。
输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。
输入设备向计算机输入数据，输出设备接收计算机输出的数据。
从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。
我们再先从应用程序的角度来解读一下 I/O。
根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。
像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。
并且，用户空间的程序不能直接访问内核空间。
当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。
因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间
我们在平常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。
从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。
当应用程序发起 I/O 调用后，会经历两个步骤：
内核等待 I/O 设备准备好数据内核将数据从内核空间拷贝到用户空间。 同步/异步，阻塞/非阻塞 同步和异步关注的是消息通信机制.
同步是指: 发送方发出数据后, 等待接收方发回响应后才发下一个数据包的通讯方式. 就是在发出一个调用时, 在没有得到结果之前, 该调用就不返回, 但是一旦调用返回, 就得到返回值了. 也就是由&#34;调用者&#34;主动等待这个&#34;调用&#34;的结果.
异步是指: 发送方发出数据后, 不等待接收方发回响应, 接着发送下个数据包的通讯方式." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/89e25e0d29a5543a042497d54ee85531/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-16T17:18:18+08:00" />
<meta property="article:modified_time" content="2022-08-16T17:18:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">io,nio,aio总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="IO_0"></a>I/O简介</h2> 
<p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p> 
<p><strong>我们先从计算机结构的角度来解读一下 I/O。</strong></p> 
<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p> 
<p><img src="https://images2.imgbox.com/2c/4e/KdD6hMxl_o.jpg" alt="img"></p> 
<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p> 
<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p> 
<p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p> 
<p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p> 
<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p> 
<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p> 
<p>并且，用户空间的程序不能直接访问内核空间。</p> 
<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p> 
<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p> 
<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p> 
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p> 
<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p> 
<ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol> 
<h3><a id="_37"></a>同步/异步，阻塞/非阻塞</h3> 
<p><strong>同步和异步关注的是消息通信机制.</strong></p> 
<p><strong>同步是指</strong>: 发送方发出数据后, 等待接收方发回响应后才发下一个数据包的通讯方式. 就是在发出一个调用时, 在没有得到结果之前, 该调用就不返回, 但是一旦调用返回, 就得到返回值了. 也就是由"调用者"主动等待这个"调用"的结果.</p> 
<p><strong>异步是指</strong>: 发送方发出数据后, 不等待接收方发回响应, 接着发送下个数据包的通讯方式. 当一个异步过程调用发出后, 调用者不会立刻得到结果. 而是在调用发出后, "被调用者"通过状态、通知来通知调用者, 或通过回调函数处理这个调用.</p> 
<p><strong>阻塞和非阻塞属于进程API执行动作的方式, 关注的是程序在等待调用结果时的状态.</strong></p> 
<p><strong>阻塞是指</strong>: 调用结果返回之前, 当前线程会被挂起. 函数只有在得到结果之后才会返回, 线程需要等待结果.</p> 
<p><strong>非阻塞是指</strong>: 与阻塞的概念相对应, 指在不能立刻得到结果之前, 该函数不会阻塞当前线程, 而会立刻返回. 线程不需要等待结果.</p> 
<h3><a id="_IO__54"></a>常见的 IO 模型</h3> 
<p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p> 
<p>这也是我们经常提到的 5 种 IO 模型。</p> 
<h2><a id="javabionioaio_62"></a>java中的bio，nio,aio的简介</h2> 
<h3><a id="BIO_Blocking_IO_64"></a>BIO (Blocking I/O)</h3> 
<p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p> 
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p> 
<p><img src="https://images2.imgbox.com/c3/3c/JwwpCjFU_o.png" alt="在这里插入图片描述"></p> 
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p> 
<p><strong>BIO的优点：</strong></p> 
<p>程序简单，在阻塞等待数据期间，用户线程挂起。用户线程基本不会占用 CPU 资源。</p> 
<p><strong>BIO的缺点：</strong></p> 
<p>一般情况下，会为每个连接配套一条独立的线程，或者说一条线程维护一个连接成功的IO流的读写。在并发量小的情况下，这个没有什么问题。但是，当在高并发的场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上，BIO模型在高并发场景下是不可用的。</p> 
<h3><a id="NIO_NonblockingNew_IO_83"></a>NIO (Non-blocking/New I/O)</h3> 
<p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。流行基于Java NIO通信框架有Mina、Netty、Grizzly等</p> 
<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p> 
<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p> 
<p><img src="https://images2.imgbox.com/47/1c/cG68zzTg_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xRbNEDoX-1660641084527)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61%7Etplv-k3u1fbpfcp-watermark.image)]"></p> 
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p> 
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p> 
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p> 
<p><strong>NIO的优点</strong>：每次发起的 IO 系统调用，在内核的等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p> 
<p><strong>NIO的缺点</strong>：需要不断的重复发起IO系统调用，这种不断的轮询，将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低。</p> 
<p>总之，NIO模型在高并发场景下，也是不可用的。一般 Web 服务器不使用这种 IO 模型。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。java的实际开发中，也不会涉及这种IO模型。</p> 
<p>再次说明，Java NIO（New IO） 不是IO模型中的NIO模型，而是另外的一种模型，叫做IO多路复用模型（ IO multiplexing ）。</p> 
<p><strong>I/O 多路复用模型</strong></p> 
<p><img src="https://images2.imgbox.com/36/98/8vTxrymu_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-euHQtmKi-1660641084528)(https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ff862764024c3b8567367df11df6ab%7Etplv-k3u1fbpfcp-watermark.image)]"></p> 
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p> 
<blockquote> 
 <p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p> 
 <ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul> 
</blockquote> 
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p> 
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p> 
<p><img src="https://images2.imgbox.com/97/b8/OXYt1dR8_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yIrVsKl7-1660641084528)(https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144%7Etplv-k3u1fbpfcp-watermark.image)]"></p> 
<p>多路复用IO的特点：</p> 
<p>IO多路复用模型，建立在操作系统kernel内核能够提供的多路分离系统调用select/epoll基础之上的。多路复用IO需要用到两个系统调用（system call）， 一个select/epoll查询调用，一个是IO的读取调用。</p> 
<p>和NIO模型相似，多路复用IO需要轮询。负责select/epoll查询调用的线程，需要不断的进行select/epoll轮询，查找出可以进行IO操作的连接。</p> 
<p>另外，多路复用IO模型与前面的NIO模型，是有关系的。对于每一个可以查询的socket，一般都设置成为non-blocking模型。只是这一点，对于用户程序是透明的（不感知）。</p> 
<p><strong>多路复用IO的优点：</strong></p> 
<p>用select/epoll的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I/O多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。</p> 
<p>Java的NIO（new IO）技术，使用的就是IO多路复用模型。在linux系统上，使用的是epoll系统调用。</p> 
<p><strong>多路复用IO的缺点：</strong></p> 
<p>本质上，select/epoll系统调用，属于同步IO，也是阻塞IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。</p> 
<h3><a id="AIO_Asynchronous_IO_147"></a>AIO (Asynchronous I/O)</h3> 
<p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p> 
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p> 
<p><img src="https://images2.imgbox.com/17/11/h74e0KQu_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FnQGakEj-1660641084528)(https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7%7Etplv-k3u1fbpfcp-watermark.image)]"></p> 
<p><strong>异步IO模型的特点</strong>：</p> 
<p>在内核kernel的等待数据和复制数据的两个阶段，用户线程都不是block(阻塞)的。用户线程需要接受kernel的IO操作完成的事件，或者说注册IO操作完成的回调函数，到操作系统的内核。所以说，异步IO有的时候，也叫做信号驱动 IO 。</p> 
<p><strong>异步IO模型缺点</strong>：</p> 
<p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p> 
<p>目前来说， Windows 系统下通过 IOCP 实现了真正的异步 I/O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p> 
<p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在 Linux 下，实现高并发网络编程时都是以 IO 复用模型模式为主</p> 
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p> 
<h3><a id="Java__BIONIOAIO_170"></a>Java 中的 BIO、NIO、AIO对比。</h3> 
<p><img src="https://images2.imgbox.com/5b/d5/84rHIUF2_o.png" alt="img"></p> 
<h2><a id="selectpollepoll__176"></a>select,poll,epoll 对比</h2> 
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p> 
<h3><a id="select_180"></a>select</h3> 
<pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
int select(int maxfd_add_1, fd_set *readset, fd_set *write_set, fd_set * exceptset, 
            const struct timeval *timeout);
struct timeval{
    long tv_sec;
    long tv_usec;
};
/*设置fd_set，下面的四个函数都是宏，不能取地址*/
//清空
void FD_ZERO(fd_set *fdset);
//设置一个位
void FD_SET(int fd, fd_set *fdset);
//清除一个位
void FD_CLR(int fd, fd_set *fdset);
/*检查某个位是否被设置,可用于函数返回时判断那个文件描述符就绪*/
int FD_ISSET(int fd,fd_set *fdset);
</code></pre> 
<p><code>maxfd_add_1</code>后面三个集中设置了的文件描述符的最大值+1，因为这个值表示的是个数。这个参数存在的意义就是内核在每次唤醒的时候需要遍历的文件描述符个数，因而不用全部遍历所有1024个文件描述符的状态</p> 
<p>存在这个参数的原因纯粹是为了效率。因为<code>fd_set</code>的最大值典型的是1024.为了避免所有的都被检查，因此使用这个。</p> 
<p>最大值为宏<code>FD_SETSIZE</code></p> 
<p><code>readset</code>、<code>write_set</code>、<code>exceptset</code>这三个<code>fd_set</code>类型是一个位图。返回的时候，如果对应的位被设置，那么表示文件描述符就绪，因此需要用户再次手动遍历依次。</p> 
<p><strong>select的缺点：</strong><br> <strong>select支持的文件描述符数量太小了，默认是1024</strong></p> 
<p><strong>每次调用select都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p> 
<p><strong>每次调用select都需要在内核遍历传递进来的所有fd，查看有没有就绪的fd，这个开销在fd很多时也很大，效率随FD数目增加而线性下降</strong></p> 
<h3><a id="poll_217"></a>poll</h3> 
<pre><code>#include &lt;poll.h&gt;
int poll(struct pollfd *fdarray, unsigned long n, int timeout);
//成功个数，错误-1,超时0

struct pollfd{
  int fd;
  short events;
  short revents;
};
</code></pre> 
<ul><li><code>fdarray</code>是一个<code>pollfd</code>类型的数组（首指针），<code>n</code>表示这个数组的个数。</li><li><code>pollfd</code>的<code>events</code>成员是要测试的条件，而<code>revents</code>是内核要填充的，表示文件描述符当前的读写状态。</li></ul> 
<p>poll方法不再使用位图的方式传入文件描述符符，而是采用一个结构体的方式，因而在遍历每个文件描述符的poll方法的时候，就从结构体的数组中依次遍历，因此突破了select文件描述符的限制。</p> 
<p><strong>poll的缺点：</strong><br> <strong>每次调用select都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p> 
<p><strong>每次调用select都需要在内核遍历传递进来的所有fd，查看有没有就绪的fd，这个开销在fd很多时也很大，效率随FD数目增加而线性下降</strong></p> 
<h3><a id="epoll_243"></a><strong>epoll</strong></h3> 
<h4><a id="_245"></a>源码</h4> 
<pre><code>include &lt;sys/epoll.h&gt;
// 创建 epollfd 的函数
int epoll_create(int size);
int epoll_create1(int flags);
// 对要监听的文件描述符的的增加修改删除
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// 开始阻塞
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, 
    int timeout);
int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, 
    int timeout, const sigset_t *sigmask);
// epoll_wait 返回的时候，events表示发生的、
//时间 data则表示与文件描述符相关的信息，可以指向一个结构体，
//也可以是直接的文件描述符
typedef union epoll_data {
    void *ptr; // 常用这个
    int fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;
struct epoll_event
{
 //感兴趣的事件如EPOLLIN，EPOLLOUT，EPOLLPRI等
    uint32_t events;  
 //一般使用data的fd成员表示感兴趣的socket
    epoll_data_t data;
};
</code></pre> 
<p>epoll_ctl() 这个函数是修改<code>epoll</code>关注描述符的。</p> 
<ol><li><code>epfd</code>是<code>epoll_create</code>创建的文件描述符</li><li><code>op</code>表示要修改的方式： 
  <ol><li><code>POLL_CTL_ADD</code>：添加</li><li><code>EPOLL_CTL_MOD</code>：修改</li><li><code>EPOLL_CTL_DEL</code>：删除</li></ol> </li><li><code>fd</code>参数是要修改关注的文件描述符</li><li><code>event</code>则是要关注的事件了。</li></ol> 
<p>epoll_wait() 就是开始阻塞的函数了。</p> 
<ol><li> <p><code>events</code>是已经分配好的<code>epoll_event</code>结构体。这个是一个空的，内核负责帮我们填充.events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存</p> </li><li> <p><code>maxevents</code>是传入要填充的数组的大小。</p> </li></ol> 
<h4><a id="_295"></a>为什么高效</h4> 
<ol><li>每次调用不需要传入所有的文件描述符</li></ol> 
<p>select/poll每次调用都要传递所要监控的所有fd给select/poll系统调用（这意味着每次调用都要将fd列表从用户态拷贝到内核态，当fd数目很多时，这会造成低效）。而每次调用epoll_wait时（作用相当于调用select/poll），不需要再传递fd列表给内核，因为已经在epoll_ctl中将需要监控的fd告诉了内核（epoll_ctl不需要每次都拷贝所有的fd，只需要进行增量式操作）。所以，在调用epoll_create之后，内核已经在内核态开始准备数据结构存放要监控的fd了。每次epoll_ctl只是对这个数据结构进行简单的维护。</p> 
<ol start="2"><li> <p>每次epoll_wait()被唤醒，不需要去遍历所有文件描述符</p> </li><li> <p>epoll没有文件描述符数量上的限制。</p> </li></ol> 
<h4><a id="epollLTET_305"></a>epoll两种工作方式LT和ET</h4> 
<p>水平触发（LT）是epoll**缺省的工作方式，**支持阻塞和非阻塞文件描述符。当数据可读写的时候就唤醒<code>epoll_wait</code>，如果不对这个文件描述符作任何操作，内核还是会继续通知，所以，这种模式编程出错误可能性要小一点。传统的select/poll都使用这种模型。</p> 
<p>边缘触发（ET）是<strong>高速工作方式</strong>,只支持非阻塞模式。当一个新的事件到来时，ET模式下当然可以从<code>epoll_wait</code>调用中获取到这个事件，可是如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字中没有新的事件再次到来时，在ET模式下是无法再次从<code>epoll_wait</code>调用中获取这个事件的。</p> 
<p>LT模式下开发基于<code>epoll</code>的应用要简单些，不太容易出错。而在ET模式下事件发生时，如果没有彻底地将缓冲区数据处理完，则会导致缓冲区中的用户请求得不到响应。</p> 
<h4><a id="epollselectpoll_313"></a><strong>epoll的跟select和poll对比的优点：</strong></h4> 
<p><strong>支持一个进程打开大数目的socket描述符。它所支持的FD上限是最大可以打开文件的数目，这个数字一般远远于2048，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</strong></p> 
<p><strong>select和poll每次调用都需要把所有要监听的fd重新拷贝到内核空间；epoll只在调用epoll_ctl时拷贝一次要监听的fd，调用epoll_wait时不需要每次把所有要监听的fd重复拷贝到内核空间。</strong></p> 
<p><strong>IO效率不随FD数目增加而线性下降。传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，任一时间只有部分的socket是”活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行操作。这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用callback函数，其他idle状态socket则不会。</strong></p> 
<h3><a id="selectpollepoll_321"></a>select,poll,epoll区别</h3> 
<p><img src="https://images2.imgbox.com/b3/37/3UVhRgCr_o.png" alt="请添加图片描述"></p> 
<h2><a id="_326"></a>零拷贝</h2> 
<h3><a id="_328"></a>零拷贝基本概念：</h3> 
<pre><code>零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，进而减少上下文切换以及CPU的拷贝时间。它是一种IO操作优化技术。
</code></pre> 
<h3><a id="nioepoll_334"></a>nio中epoll零拷贝原理解析：</h3> 
<p><img src="https://images2.imgbox.com/15/44/2XzYwXsx_o.png" alt="请添加图片描述"></p> 
<p>mmap 通过内存映射，将文件映射到 内核缓冲区，同时，<strong>用户空间可以共享内核空间的数据</strong>。这样，在进行网络传输时，就可以减少内核空间到用户控件的拷贝次数。</p> 
<h3><a id="_341"></a>零拷贝代码演示：</h3> 
<pre><code> /**
     * 零拷贝代码演示
     */
    private static void zeroCopyDemo() throws IOException {
        // 构建零拷贝的输入输出
        FileChannel inChannel = FileChannel.open(Paths.get("C:\\Users\\yojofly\\Desktop\\sps-plugins\\learn\\test.csv"), StandardOpenOption.READ);
        FileChannel outChannel = FileChannel.open(Paths.get("C:\\Users\\yojofly\\Desktop\\sps-plugins\\learn\\test_cp.csv"),StandardOpenOption.READ,StandardOpenOption.CREATE,StandardOpenOption.WRITE);
        // 缓冲区初始化，可对比为文件Io读取时候的   new byte[1024]
        MappedByteBuffer inMapperBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());
        MappedByteBuffer outMapperBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());
        // 获取输入文件的字节长度limit
        byte[] bytes = new byte[inMapperBuffer.limit()];
        // 文件读入缓存中
        inMapperBuffer.get(bytes);
        // 从缓存中取出文件内容写入到新的文件
        outMapperBuffer.put(bytes);
        inChannel.close();
        outChannel.close();
    }
</code></pre> 
<h2><a id="niochannelbufferselector_365"></a>nio中channel,buffer,selector</h2> 
<h3><a id="Channel_367"></a>Channel</h3> 
<p>Channel是数据传输的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel。<br> 常见的Channel有：</p> 
<p>FileChannel 文件传输<br> DatagramChannel（通常用于UDP）<br> SocketChannel（通常用于TCP）<br> ServerSocketChannel（通常用于TCP）</p> 
<h3><a id="Buffer_377"></a>Buffer</h3> 
<p>内存缓存区，用于暂存从Channel中读取的数据、以及即将写入Channel中的数据。</p> 
<h4><a id="Buffer_381"></a>常见的实现类Buffer：</h4> 
<p>ByteBuffer 字节</p> 
<p>MappedByteBuffer<br> DirectByteBuffer<br> HeapByteBuffer<br> ShortBuffer<br> IntBuffer<br> LongBuffer<br> FloatBuffer<br> DoubleBuffer<br> CharBuffer<br> 从名字上可以看出，这些Buffer支持的是不同数据类型的缓冲区，如short、int等。</p> 
<h4><a id="_396"></a>常用方法：</h4> 
<p><strong>put</strong>： 写入数据</p> 
<p><strong>get</strong>：读取数据</p> 
<p><strong>flip</strong>：将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值</p> 
<p><strong>clear</strong>：方法，position将被设回0，limit被设置成 capacity的值</p> 
<p><strong>compact</strong>：方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面</p> 
<p><strong>mark</strong> ：添加标记<br> <strong>reset</strong>：恢复到标记位置</p> 
<p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。</p> 
<h4><a id="_413"></a>内部结构</h4> 
<pre><code>ByteBuffer的内部结构类似于一个数组，主要有3个重要属性：

capacity：代表buffer的容量。
position：一个读写指针，可以理解为读写到buffer中的哪个下标。
limit：读写限制，position不能超过limit。
</code></pre> 
<p>当我们新建一个buffer时，它的内部结构如下：</p> 
<p><img src="https://images2.imgbox.com/45/1d/mw4P5gHj_o.png" alt="在这里插入图片描述"></p> 
<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态：</p> 
<p><img src="https://images2.imgbox.com/bc/7c/UVPDNc2u_o.png" alt="在这里插入图片描述"></p> 
<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制：</p> 
<p><img src="https://images2.imgbox.com/fa/5a/8nHbsKdV_o.png" alt="在这里插入图片描述"></p> 
<p>读取 4 个字节后，状态变成：</p> 
<p><img src="https://images2.imgbox.com/88/44/XjbfEXdt_o.png" alt="在这里插入图片描述"></p> 
<p>clear 动作发生后，状态变成：</p> 
<p><img src="https://images2.imgbox.com/60/2b/HH7Og6o5_o.png" alt="在这里插入图片描述"></p> 
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p> 
<p><img src="https://images2.imgbox.com/29/f6/kuYZXPun_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Selector_447"></a>Selector</h3> 
<p>在NIO出现之前，在开发服务器端程序时，会采用一种叫做“多线程版设计”的思路，即服务器端每当需要和一个新的客户端进行通信时，就会开启一个新的Socket连接（通过Socket就能读写数据了），并启动一个新的线程来为这个Socket服务（执行读写操作等）。</p> 
<p>这种思路的弊端在于，如果客户端太多的话，那么服务器端就需要开启许多线程才能进行服务，这会带来以下问题：</p> 
<p>内存占用高。<br> 线程上下文切换成本高。<br> 只适合连接数少的场景。<br> 注意：线程并不是越多越好，因为CPU能并行处理的线程是有限的，一旦线程数量超出CPU能并行处理的数量，多出来的线程就需要等待CPU，而这就会导致线程上下文切换，从而带来额外开销</p> 
<h4><a id="SelectionKey_458"></a>SelectionKey的四个常量</h4> 
<ol><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ol> 
<p>分别表示监听四种不同类型的事件：</p> 
<ul><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ul> 
<h4><a id="selector_472"></a>selector常用方法：</h4> 
<p><strong>open</strong>: 创建一个selector连接</p> 
<p><strong>select()</strong>：阻塞到至少有一个通道在你注册的事件上就绪了。</p> 
<p><strong>select(long timeout)</strong>：select()一样，除了最长会阻塞timeout毫秒(参数)。</p> 
<p><strong>selectNow()</strong>：不会阻塞，不管什么通道就绪都立刻返回（此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零）。</p> 
<p><strong>selectedKeys()</strong>：返回所有selector里注册的SelectionKey</p> 
<h4><a id="Nio_486"></a>代码示例：模拟Nio中网络中的客户端和服务端通信</h4> 
<p>SelectorClientDemo.java</p> 
<pre><code>package com.yojofly.server.learn.nio.selector;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class SelectorClientDemo {
    static Selector selector;

    public static void main(String[] args) throws IOException {
        selector = Selector.open();
        SocketChannel socketChannel = SocketChannel.open();
        // 设置为非阻塞io
        socketChannel.configureBlocking(false);
        socketChannel.connect(new InetSocketAddress("localhost",8000));
        socketChannel.register(selector, SelectionKey.OP_CONNECT);
        while (true){
            selector.select(); //阻塞
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()){
                SelectionKey selectionKey = iterator.next();
                iterator.remove();
                if (selectionKey.isConnectable()){ // 连接事件
                    // 处理连接事件
                    handleConnect(selectionKey);
                }else if (selectionKey.isReadable()){ // 读事件
                    // 处理读事件
                    handleRead(selectionKey);
                }
            }
        }
    }

    private static void handleConnect(SelectionKey selectionKey) throws IOException{
        SocketChannel socketChannel  = (SocketChannel) selectionKey.channel();
        // 连接中断
        if (socketChannel.isConnectionPending()){
            socketChannel.finishConnect();
        }
        // 设置io非阻塞状态
        socketChannel.configureBlocking(false);
        socketChannel.write(ByteBuffer.wrap("hello server,i am nio client with accept".getBytes()));
        socketChannel.register(selector,SelectionKey.OP_READ);
    }

    private static void handleRead(SelectionKey selectionKey) throws IOException{
        SocketChannel socketChannel  = (SocketChannel) selectionKey.channel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        socketChannel.read(byteBuffer);
        System.out.println("client receive Msg:" +new String(byteBuffer.array()));
    }
}

</code></pre> 
<p>SelectorServerDemo.java</p> 
<pre><code>package com.yojofly.server.learn.nio.selector;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class SelectorServerDemo {
    static Selector selector;

    public static void main(String[] args) throws IOException {
        selector = Selector.open();
        ServerSocketChannel socketChannel = ServerSocketChannel.open();
        // 设置为非阻塞io
        socketChannel.configureBlocking(false);
        socketChannel.socket().bind(new InetSocketAddress(8000));
        socketChannel.register(selector, SelectionKey.OP_ACCEPT);
        while (true){
            selector.select(); //阻塞
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()){
                SelectionKey selectionKey = iterator.next();
                iterator.remove();
                if (selectionKey.isAcceptable()){ // 连接事件
                    // 处理连接事件
                    handleConnect(selectionKey);
                }else if (selectionKey.isReadable()){ // 读事件
                    // 处理读事件
                    handleRead(selectionKey);
                }
            }
        }
    }

    private static void handleConnect(SelectionKey selectionKey) throws IOException{
        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();
        SocketChannel socketChannel = serverSocketChannel.accept();
        socketChannel.configureBlocking(false);
        socketChannel.write(ByteBuffer.wrap("hello client,i am nio server with connect".getBytes()));
        socketChannel.register(selector,SelectionKey.OP_READ);
    }

    private static void handleRead(SelectionKey selectionKey) throws IOException{
        SocketChannel socketChannel  = (SocketChannel) selectionKey.channel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        socketChannel.read(byteBuffer);
        System.out.println("server receive Msg:" +new String(byteBuffer.array()));
    }
}

</code></pre> 
<h2><a id="_617"></a>文章参考：</h2> 
<p>同步异步，阻塞非阻塞<br> https://blog.csdn.net/qq_39515350/article/details/120854214<br> io多路复用中详解：<br> https://blog.csdn.net/adminpd/article/details/124553590<br> io基础知识原理分析：<br> https://www.cnblogs.com/crazymakercircle/p/10225159.html<br> select,poll.epoll对比<br> https://blog.csdn.net/xx_yTm/article/details/54801977<br> select,poll,epoll源码分析<br> http://t.zoukankan.com/perfy576-p-8554734.html<br> nio中channel,buffer,selector的作用：<br> https://blog.csdn.net/lucas161543228/article/details/125172566</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d826e9ca73820dc6a82503be1b6c125a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker轻量级可视化工具Portainer汉化教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30a5144d4cde7b52602dc553dfee5fa9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端解决百度地图地址逆解析（BMap.Geocoder()）异步问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>