<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>两篇2023 ICLR多模态论文分享(模态互补性对多模态鲁棒性影响 与 对多模表示学习有效的单模学习) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="两篇2023 ICLR多模态论文分享(模态互补性对多模态鲁棒性影响 与 对多模表示学习有效的单模学习)" />
<meta property="og:description" content="Modality Complementariness Towards Understanding Multi modal Robustness 本文讨论了模态互补性在多模态鲁棒性中的重要性，并基于信息论提出了一种数据集层面量化度量，用于量化不同模态之间有多少互补信息，以及这些信息对预测标签有多大贡献。该指标基于互信息神经估计器（MINE）来计算。提出了一个两阶段pipeline，分成数据生成阶段和度量计算阶段。在数据生成阶段，作者生成具有受控模态互补性的数据集。在度量计算阶段，作者使用生成的数据集计算度量并分析结果。，并通过实验验证了其有效性。此外，本文还讨论了各种相关主题，如变压器、对抗性示例和深度学习模型。
这篇论文的主要贡献是提供了一个统一且可操作的方法来评估和优化多模态学习系统，以及提出了一些有趣且具有启发性的发现，例如：不同任务下最佳模态组合可能不同；单一模态可能包含足够或过剩信息；增加噪声或缺失值可以提高某些情况下的互补性等。本文还为量化多模态和缺失模态或噪声模态的贝叶斯错误率之间的差异提供了理论保证。
这篇论文的局限性或未来方向有：
这篇论文的理论分析框架只适用于多模态分类任务，对于其他类型的多模态任务，如生成、检索、对话等，还需要进一步扩展和验证。
这篇论文的指标计算依赖于互信息神经估计器（MINE），而MINE本身可能存在一些问题，如估计偏差、不稳定性、超参数敏感性等，这些问题可能影响到指标的准确性和可靠性。
这篇论文的实验设置较为简单，只考虑了两种模态（视觉和语言）以及两种噪声类型（高斯噪声和缺失值），对于更复杂和更真实的多模态场景，还需要进行更多的探索和分析。
互信息神经估计器（MINE）是一种基于神经网络的方法，用于估计高维连续随机变量之间的互信息。互信息是衡量两个随机变量之间相关性的一个指标，它等于两个随机变量的联合分布与边缘分布之间的KL散度1。MINE利用了一个重要的定理，即最大化一个函数关于联合分布和边缘分布的期望差等价于最大化该函数与互信息之间的下界23。因此，MINE可以通过梯度下降来训练一个神经网络，使其输出接近互信息的下界，并且具有线性可扩展性、灵活性和强一致性。
MINE的优势有：
它可以有效地估计高维连续随机变量之间的互信息，而不需要对分布做任何假设或近似。
它可以通过梯度下降来训练一个神经网络，使其输出接近互信息的下界，而不需要计算复杂的积分或优化问题。
它具有线性可扩展性、灵活性和强一致性，即它可以处理任意维度和样本大小的数据，并且在样本趋于无穷时，它的估计值会收敛到真实值。
MINE的缺点有：
它依赖于一个超参数，即神经网络的结构和激活函数，这些选择可能影响到估计值的准确性和稳定性。
它可能存在一些估计偏差，即它的估计值可能低于或高于真实值，这取决于神经网络的初始化和训练过程。
它可能受到样本相关性、噪声、离群点等因素的干扰，导致估计值不准确或不可靠。
有很多方法可以估计互信息，其中一些常见的有：
直接方法：这种方法通过呈现来自p(S)的刺激，并从重复呈现相同刺激来估计hΔ(R|S)，从而估计hΔ®和hΔ(R|S)。由于估计p(R|S)所需的数据量通常很大，因此大多数研究者采用一些技术来给I(S;R)设置上下界。
基于k最近邻的方法：这种方法通过利用k最近邻距离来估计熵和互信息，不需要对数据进行分箱或假设分布的形式。它具有非参数性、鲁棒性和一致性，但也存在一些缺点，如高维空间中距离度量的困难、超参数k的选择和样本相关性的影响。
基于几何k最近邻的方法：这种方法是基于k最近邻的方法的改进，它通过在流形上定义距离度量来克服高维空间中欧氏距离失效的问题。它利用了流形学习中的局部线性嵌入（LLE）算法，将数据映射到一个低维空间，然后在该空间中使用k最近邻算法来估计互信息。、
论文的3.1节主要讲了多模态互补性度量（Modality Complementarity Metric），这是一个用来评估多模态数据中不同模态之间信息互补程度的指标。该指标基于信息熵（Entropy）和互信息（Mutual Information）的概念，可以反映出多模态数据中每个模态对整体信息的贡献和冗余。该指标可以用来预测多模态模型在不同场景下的鲁棒性，例如缺失某个模态、某个模态受到噪声或对抗攻击等
论文的3.2节主要讲了多模态互补性度量的理论分析（Theoretical Analysis of Modality Complementarity Metric），这是一个用来证明该指标与多模态鲁棒性之间关系的数学推导。该分析基于贝叶斯风险（Bayesian Risk）和最小化期望损失（Minimizing Expected Loss）的原则，给出了在不同场景下，多模态互补性度量与多模态模型性能之间的上下界。该分析表明，当某个模态缺失或受到噪声或对抗攻击时，多模态互补性度量越高，多模态模型的性能下降越小。
这篇论文的3.3节主要讨论了如何在真实世界的多模态数据集上计算模态互补性度量，并展示了不同数据集的模态互补性和多模态鲁棒性之间的关系。
论文中的图2显示了在不同设置下，模态互补性和多模态鲁棒性之间的关系。模态互补性是一种度量每种模态对其他模态增加多少信息的指标。多模态鲁棒性是指一个模型在某些模态缺失或受损时能够表现良好的能力。
图2的作用是说明论文的主要思想：模态互补性影响多模态鲁棒性。互补性越高，模型对缺失或噪声模态越敏感。互补性越低，模型对这种情况越鲁棒 。
I(X; Y, Z)表示X和(Y, Z)之间的互信息，即X减少了对(Y, Z)的不确定性的程度。它等于(Y, Z)的熵减去给定X时(Y, Z)的熵。
I(Z; Y, X) 表示 Z 和 (Y, X) 之间的模态互补性，即 Z 在 (Y, X) 缺失或受损时能够减少对 (Y, X) 的不确定性的程度。它等于 (Y, X) 的熵减去给定 Z 时 (Y, X) 的熵。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/8cc496de3b36d12d5c64faa791321c4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T17:52:31+08:00" />
<meta property="article:modified_time" content="2023-03-29T17:52:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">两篇2023 ICLR多模态论文分享(模态互补性对多模态鲁棒性影响 与 对多模表示学习有效的单模学习)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Modality_Complementariness_Towards_Understanding_Multi_modal_Robustness_0"></a>Modality Complementariness Towards Understanding Multi modal Robustness</h2> 
<p>本文讨论了模态互补性在多模态鲁棒性中的重要性，并基于信息论提出了一种数据集层面量化度量，用于量化不同模态之间有多少互补信息，以及这些信息对预测标签有多大贡献。该指标基于互信息神经估计器（MINE）来计算。提出了一个两阶段pipeline，分成数据生成阶段和度量计算阶段。在数据生成阶段，作者生成具有受控模态互补性的数据集。在度量计算阶段，作者使用生成的数据集计算度量并分析结果。，并通过实验验证了其有效性。此外，本文还讨论了各种相关主题，如变压器、对抗性示例和深度学习模型。<br> 这篇论文的主要贡献是提供了一个统一且可操作的方法来评估和优化多模态学习系统，以及提出了一些有趣且具有启发性的发现，例如：不同任务下最佳模态组合可能不同；单一模态可能包含足够或过剩信息；增加噪声或缺失值可以提高某些情况下的互补性等。<strong>本文还为量化多模态和缺失模态或噪声模态的贝叶斯错误率之间的差异提供了理论保证。</strong></p> 
<p>这篇论文的局限性或未来方向有：<br> 这篇论文的理论分析框架只适用于多模态分类任务，对于其他类型的多模态任务，如生成、检索、对话等，还需要进一步扩展和验证。<br> 这篇论文的指标计算依赖于互信息神经估计器（MINE），而MINE本身可能存在一些问题，如估计偏差、不稳定性、超参数敏感性等，这些问题可能影响到指标的准确性和可靠性。<br> 这篇论文的实验设置较为简单，只考虑了两种模态（视觉和语言）以及两种噪声类型（高斯噪声和缺失值），对于更复杂和更真实的多模态场景，还需要进行更多的探索和分析。<br> 互信息神经估计器（MINE）是一种基于神经网络的方法，用于估计高维连续随机变量之间的互信息。互信息是衡量两个随机变量之间相关性的一个指标，它等于两个随机变量的联合分布与边缘分布之间的KL散度1。MINE利用了一个重要的定理，即最大化一个函数关于联合分布和边缘分布的期望差等价于最大化该函数与互信息之间的下界23。因此，MINE可以通过梯度下降来训练一个神经网络，使其输出接近互信息的下界，并且具有线性可扩展性、灵活性和强一致性。<br> MINE的优势有：</p> 
<p>它可以有效地估计高维连续随机变量之间的互信息，而不需要对分布做任何假设或近似。<br> 它可以通过梯度下降来训练一个神经网络，使其输出接近互信息的下界，而不需要计算复杂的积分或优化问题。<br> 它具有线性可扩展性、灵活性和强一致性，即它可以处理任意维度和样本大小的数据，并且在样本趋于无穷时，它的估计值会收敛到真实值。<br> MINE的缺点有：</p> 
<p>它依赖于一个超参数，即神经网络的结构和激活函数，这些选择可能影响到估计值的准确性和稳定性。<br> 它可能存在一些估计偏差，即它的估计值可能低于或高于真实值，这取决于神经网络的初始化和训练过程。<br> 它可能受到样本相关性、噪声、离群点等因素的干扰，导致估计值不准确或不可靠。<br> 有很多方法可以估计互信息，其中一些常见的有：</p> 
<p>直接方法：这种方法通过呈现来自p(S)的刺激，并从重复呈现相同刺激来估计hΔ(R|S)，从而估计hΔ®和hΔ(R|S)。由于估计p(R|S)所需的数据量通常很大，因此大多数研究者采用一些技术来给I(S;R)设置上下界。<br> 基于k最近邻的方法：这种方法通过利用k最近邻距离来估计熵和互信息，不需要对数据进行分箱或假设分布的形式。它具有非参数性、鲁棒性和一致性，但也存在一些缺点，如高维空间中距离度量的困难、超参数k的选择和样本相关性的影响。<br> 基于几何k最近邻的方法：这种方法是基于k最近邻的方法的改进，它通过在流形上定义距离度量来克服高维空间中欧氏距离失效的问题。它利用了流形学习中的局部线性嵌入（LLE）算法，将数据映射到一个低维空间，然后在该空间中使用k最近邻算法来估计互信息。、</p> 
<p>论文的3.1节主要讲了多模态互补性度量（Modality Complementarity Metric），这是一个用来评估多模态数据中不同模态之间信息互补程度的指标。该指标基于信息熵（Entropy）和互信息（Mutual Information）的概念，可以反映出多模态数据中每个模态对整体信息的贡献和冗余。该指标可以用来预测多模态模型在不同场景下的鲁棒性，例如缺失某个模态、某个模态受到噪声或对抗攻击等<br> 论文的3.2节主要讲了多模态互补性度量的理论分析（Theoretical Analysis of Modality Complementarity Metric），这是一个用来证明该指标与多模态鲁棒性之间关系的数学推导。该分析基于贝叶斯风险（Bayesian Risk）和最小化期望损失（Minimizing Expected Loss）的原则，给出了在不同场景下，多模态互补性度量与多模态模型性能之间的上下界。该分析表明，当某个模态缺失或受到噪声或对抗攻击时，多模态互补性度量越高，多模态模型的性能下降越小。<br> 这篇论文的3.3节主要讨论了如何在真实世界的多模态数据集上计算模态互补性度量，并展示了不同数据集的模态互补性和多模态鲁棒性之间的关系。</p> 
<p>论文中的图2显示了在不同设置下，模态互补性和多模态鲁棒性之间的关系。模态互补性是一种度量每种模态对其他模态增加多少信息的指标。多模态鲁棒性是指一个模型在某些模态缺失或受损时能够表现良好的能力。<br> <img src="https://images2.imgbox.com/dd/5e/4QBE7kmZ_o.png" alt="在这里插入图片描述"></p> 
<p>图2的作用是说明论文的主要思想：模态互补性影响多模态鲁棒性。互补性越高，模型对缺失或噪声模态越敏感。互补性越低，模型对这种情况越鲁棒 。<br> I(X; Y, Z)表示X和(Y, Z)之间的互信息，即X减少了对(Y, Z)的不确定性的程度。它等于(Y, Z)的熵减去给定X时(Y, Z)的熵。<br> I(Z; Y, X) 表示 Z 和 (Y, X) 之间的模态互补性，即 Z 在 (Y, X) 缺失或受损时能够减少对 (Y, X) 的不确定性的程度。它等于 (Y, X) 的熵减去给定 Z 时 (Y, X) 的熵。<br> I(X; Y, Z) 表示给定 (Y, Z) 时 X 的多模态鲁棒性，即 X 在 (Y, Z) 存在且可靠时能够减少对 (Y, Z) 的不确定性的程度。它等于 (Y, Z) 的熵减去给定 X 时 (Y, Z) 的熵。</p> 
<p>4.2节主要讲了一种用于计算模态互补性度量的实用流程。该流程包括三个步骤：1) 使用互信息神经估计器 (MINE) (Belghazi et al., 2018) 来估计不同模态之间的互信息；2) 使用条件熵神经估计器 (CENE) 来估计给定一个或多个模态时，另一个模态的条件熵；3) 使用公式 (4) 来计算模态互补性度量。该流程可以处理任意数量和类型的模态，并且可以在真实世界的多模态数据集上运行。<br> <img src="https://images2.imgbox.com/04/b8/ZnINwdBq_o.png" alt="在这里插入图片描述"></p> 
<p>公式 (4) 定义了模态互补性度量 (MCM) 作为不同模态之间的互信息和条件熵的函数。MCM 可以看作是一个模态在其他模态缺失或受损时能够提供的有用信息的比例。MCM 的值越高，表示一个模态对其他模态的补充程度越高，也就意味着多模态模型在面对缺失或噪声干扰时更容易受到影响。<br> 这种方法的目的是为了定量地评估多模态数据集中不同模态之间的互补性，从而揭示互补性对多模态模型鲁棒性的影响。作者认为，现有的多模态学习理论和实践中忽略了这一重要因素，导致了一些矛盾的结论。因此，他们提出了一个基于信息论的分析框架和一个基于神经网络估计器的计算流程，来探索互补性在不同任务和数据集上的变化，并与多模态模型在缺失、噪声和对抗攻击等情况下的表现进行比较。</p> 
<h2><a id="On_Uni_modal_Feature_Learning_in_Multi_modal_Learning_66"></a>On Uni modal Feature Learning in Multi modal Learning</h2> 
<p>多模态数据的特征抽象为1)单模态特征(可以从单模态训练中学习)和2)配对特征(只能从跨模态交互中学习)。多模态联合训练有望在保证单模态特征学习的基础上受益于跨模态交互。然而，目前的后期融合训练方法仍然存在对每个模态上的单模态特征学习不足的问题，并且证明了这一现象确实损害了模型的泛化能力。针对一个多模态任务，根据单模态和成对特征的分布，从单模态集成(UME)和提出的单模态教师(UMT)中选择有针对性的后期融合学习方法。我们证明，在一个简单的指导策略下，我们可以在多模态数据集上获得与其他复杂的后期融合或中间融合方法<br> 单模态先验有意义的多模态任务。理想情况下，我们希望多模态联合训练能够在保证学习足够多的单模态特征的基础上，通过跨模态交互来学习成对特征。<br> <img src="https://images2.imgbox.com/ba/82/taZFrcs5_o.png" alt="在这里插入图片描述"></p> 
<p>虽然多模态联合训练为跨模态交互提供了学习配对特征的机会，但该模型容易饱和并忽略了难以学习但对泛化很重要的单模态特征<br> 然而，最近的后期融合方法仍然存在学习每个模态的单模态表示不足的问题。我们将这种现象称为模态懒惰，并在图1中加以说明。我们从理论上描述了模态懒惰，并证明它确实损害了模型的泛化能力，特别是当单模态特征在给定任务中占主导地位时。<br> 我们关注单模态特征的学习，根据单模态特征和配对特征的分布，从Uni-ModalEnsemble (UME)和提出的uni-modal Teacher (UMT)中选择有针对性的后期融合训练方法。如果单模态特征和成对特征都是必要的，则UMT是有效的，它可以帮助多模态模型通过单模态蒸馏更好地学习单模态特征;如果两种模态都具有较强的单模态特征，且成对特征不够重要，则采用UME，它结合了单模态模型的预测，完全避免了对单模态特征的学习不足。我们还提供了一个经验技巧来决定使用哪一个。<br> 联合训练优缺点：一方面，联合训练导致单模态特征学习不足(Modality lazy)。另一方面，它允许模态之间的交互，以学习单模态特征以外的表示，即成对特征。基于此，我们提供了多模态后期融合学习的指导。最后，我们对情态懒惰进行了理论分析，并对我们的解决方案进行了论证。<br> 视觉问答(VQA) (Agrawal等人，2018)是一个反例。具体来说，相同的图像与不同的文本问题可能有完全不同的标签，使得检查其单模态准确性毫无意义。<br> <img src="https://images2.imgbox.com/67/8f/Et1G04pJ_o.png" alt="在这里插入图片描述"></p> 
<p>对单模态模型的预测结果进行平均，预训练的单模态编码器上训练一个多模态线性分类器，其中模态可以通过线性层相互作用，朴素融合，没有使用精心设计的技巧 跨模态交互作用。</p> 
<p>对于一个多模态任务，如果单模态特征和配对特征都是必要的，那么Uni-ModalTeacher (UMT)是有效的;如果两种模态都具有强烈的单模态特征，同时成对特征不重要，简单地结合单模态模型的预测就可以很好地实现，这种方法被称为单模态集成(UME)。<br> <img src="https://images2.imgbox.com/62/3a/ypNarQeR_o.png" alt="在这里插入图片描述"></p> 
<p>φ′miis是对单模态数据进行监督预训练的编码器。φmi是一个没有预训练的随机初始编码器。Lmulti是多模态预测和标签之间的损失。Ldistill是单模态蒸馏损失。<br> 单模态蒸馏发生在融合前，late-fusion<br> 从单模态模型中提取知识可以帮助多模态模型更好地学习单模态特征，这发生在特征级。UMT的框架如图1和图4所示。请注意，对于特定的模态，我们在单模态模型和多模态模型中使用相同的backbone。<br> 如果两种模式都有强烈的单模态特征，联合训练弊大于利。结合单模态模型的预测，避免了单模态特征的学习不足。首先，我们可以独立地训练单模态模型。然后，我们可以通过加权单模态模型的预测给出最终输出。简单的集成方法被称为单模态集成(UME)。我们证明了UME可以在某些多模态数据集上表现出具有竞争力的性能。<br> 决定使用哪种方法的经验Trick。我们可以在单模态预训练编码器上训练一个多模态线性分类器，并将其与单模态模型的平均预测进行比较。如果分类器的性能更好，则意味着我们可以从该任务中的跨模态交互中受益，我们可以选择UMT，在保证改善单模态特征学习的同时，保留跨模态交互;反之，简单的跨模态交互弊大于利，因为每个模态都有很强的单模态特征，我们可以选择UME，它完全避免了模态懒惰。<br> 证明：从特征学习角度证明模态惰性确实对多模态的泛化性有害<br> 多模态联合训练可以比单模态训练学习更多的特征，但所学习的特征不一定有用，甚至会损害模型的泛化。定理3.4指出，在单模态集成中，与单模态训练相比，训练过程学习到的单模态特征更少，这损害了模型的泛化。这种现象被称为模态懒惰<br> <img src="https://images2.imgbox.com/88/a9/obotK6kn_o.png" alt="在这里插入图片描述"></p> 
<p>UMT，Bm1特征学自模态xm1，在多模态训练方法中，假设训练程序在模态x m1中学习了km1的单模态特征，在模态x m2中学习了km2的单模态特征，并学习了kpa的配对特征<br> 考虑一个新的测试点，然后对于每个 δ &gt; 0，如果以下不等式成立：<br> 其中 ∆(δ) = p 8(kpa + bm1 − km1 + bm2 − km2) log(1/δ)，则概率 至少为 1 − δ，单模态集成优于多模态训练方法概率测试点<br> 数量懒惰表示在简单的多模态训练中学习到的特征数量少于单模态训练。<br> 单模态懒惰表明，由于数量懒惰，多模态训练的编码器比单模态训练的编码器性能差，这符合第3.1节的实验结果。<br> 性能懒惰比较了多模态联合训练方法和单模态集合的性能，表明当单模态特征占主导地位时，结合单模态的预测更有效。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8969622b8e9cf83da3adbc4942ebe40/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">platform架构完成，在应用层通过ioctl控制LED灯流水，当按键KEY1按下让风扇转动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ea656f71b43f47e207d35f47650a737/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot集成Mybatis-Plus最新代码自动生成器v3.5.1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>