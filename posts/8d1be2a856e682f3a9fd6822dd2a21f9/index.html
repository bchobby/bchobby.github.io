<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java数据类型相关 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java数据类型相关" />
<meta property="og:description" content="数据类型 Java有哪些数据类型 定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类 型，在内存中分配了不同大小的内存空间。
分类：
基本数据类型
数值型 整数类型(byte,short,int,long)
浮点类型(float,double)
字符型(char)布尔型(boolean) 引用数据类型
类(class)接口(interface)数组([]) Java基本数据类型图
Java中各种数据默认值 Byte,short,int,long默认是都是0
Boolean默认值是false
Char类型的默认值是’’
Float与double类型的默认是0.0
对象类型的默认值是null
超过 long 整型的数据应该如何表示？ 基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。
在 Java 中，64 位 long 整型是最大的整数类型。
long l = Long.MAX_VALUE; System.out.println(l &#43; 1); // -9223372036854775808 System.out.println(l &#43; 1 == Long.MIN_VALUE); // true BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。
相对于常规整数类型的运算来说， BigInteger 运算的效率会相对较低。
String 属于基础的数据类型吗？ String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，除了基本类型(primitive type)和枚举类型(enumeration type)，剩下的都是引用类型(reference type)。
用最有效率的方法计算 2 乘以 8 2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次 方）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/8d1be2a856e682f3a9fd6822dd2a21f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-14T21:08:53+08:00" />
<meta property="article:modified_time" content="2023-12-14T21:08:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java数据类型相关</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>数据类型</h3> 
<h4>Java有哪些数据类型</h4> 
<p>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类 型，在内存中分配了不同大小的内存空间。</p> 
<p>分类：</p> 
<p><strong>基本数据类型</strong></p> 
<ul><li>数值型</li></ul> 
<p>        整数类型(byte,short,int,long)</p> 
<p>        浮点类型(float,double)</p> 
<ul><li>字符型(char)</li><li>布尔型(boolean)</li></ul> 
<p><strong>引用数据类型</strong></p> 
<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul> 
<p>Java基本数据类型图</p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/95/b6/ZAto7ep0_o.png" width="1173"></p> 
<h4>Java中各种数据默认值</h4> 
<p>Byte,short,int,long默认是都是0</p> 
<p>Boolean默认值是false</p> 
<p>Char类型的默认值是’’</p> 
<p>Float与double类型的默认是0.0</p> 
<p>对象类型的默认值是null</p> 
<h4>超过 long 整型的数据应该如何表示？</h4> 
<p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p> 
<p>在 Java 中，64 位 long 整型是最大的整数类型。</p> 
<pre><code class="language-java">long l = Long.MAX_VALUE;

System.out.println(l + 1); // -9223372036854775808

System.out.println(l + 1 == Long.MIN_VALUE); // true</code></pre> 
<p>BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</p> 
<p>相对于常规整数类型的运算来说， BigInteger 运算的效率会相对较低。</p> 
<h4>String 属于基础的数据类型吗？</h4> 
<p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，除了基本类型(primitive type)和枚举类型(enumeration type)，剩下的都是引用类型(reference type)。</p> 
<h4>用最有效率的方法计算 2 乘以 8</h4> 
<p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次 方）。</p> 
<h4>Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少</h4> 
<p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍 五入的原理是在参数上加0.5 然后进行下取整。</p> 
<h4>float f=3.4;是否正确</h4> 
<p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转 换float f =(float)3.4; 或者写成 float f =3.4F;。</p> 
<h4>short s1 = 1; s1 = s1 + 1;有错吗?</h4> 
<p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p> 
<h4>3*0.1 == 0.3返回值是什么</h4> 
<p>false,因为有些浮点数不能完全精确的表示出来.</p> 
<h4>为什么浮点数运算的时候会有精度丢失的风险？</h4> 
<p>浮点数运算精度丢失代码演示：</p> 
<pre><code class="language-java">float a = 2.0f - 1.9f;

float b = 1.8f - 1.7f;

System.out.println(a);// 0.100000024

System.out.println(b);// 0.099999905

System.out.println(a == b);// false</code></pre> 
<p><strong>为什么会出现这个问题呢？</strong></p> 
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p> 
<p>就比如说⼗进制下的 0.2 就没办法精确转换成⼆进制小数：</p> 
<pre><code class="language-java">// 0.2 转换为⼆进制数的过程为，不断乘以 2，直到不存在小数为止，

// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。

0.2 * 2 = 0.4 -&gt; 0

0.4 * 2 = 0.8 -&gt; 0

0.8 * 2 = 1.6 -&gt; 1

0.6 * 2 = 1.2 -&gt; 1

0.2 * 2 = 0.4 -&gt; 0（发⽣循环）

...</code></pre> 
<h4>那针对浮点型数据运算出现的误差的问题，你怎么解决？</h4> 
<p>BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p> 
<pre><code class="language-java">BigDecimal a = new BigDecimal("1.0");

BigDecimal b = new BigDecimal("0.9");

BigDecimal c = new BigDecimal("0.8");

BigDecimal x = a.subtract(b);

BigDecimal y = b.subtract(c);

System.out.println(x); /* 0.1 /

System.out.println(y); / 0.1 /

System.out.println(Objects.equals(x, y)); / true */</code></pre> 
<h3>类型转换</h3> 
<h4>自动装箱与拆箱</h4> 
<p>装箱：将基本类型用它们对应的引用类型包装起来；</p> 
<p>拆箱：将包装类型转换为基本数据类型；</p> 
<p>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p> 
<p>Integer i = new Integer(10);</p> 
<p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p> 
<p>Integer i = 10;</p> 
<p>注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p> 
<pre><code class="language-java">private static long sum() {

 // 应该使用 long 而不是 Long

 Long sum = 0L;

 for (long i = 0; i

   sum += i;

 return sum;

}</code></pre> 
<h4><strong>八种基本数据类型的大小，以及他们的包装类</strong></h4> 
<p><img alt="" height="367" src="https://images2.imgbox.com/d9/62/A1TKBkUB_o.png" width="690"></p> 
<h4 style="background-color:transparent;">基本类型和包装类型的区别？</h4> 
<p>成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null 。</p> 
<p>包装类型可用于泛型，而基本类型不可以。</p> 
<p>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p> 
<p>相对于对象类型， 基本数据类型占用的空间非常小。</p> 
<p>为什么说是几乎所有对象实例呢？ 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，从而避免堆上分配内存</p> 
<p>注意 ： 基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的成员变量如果没有被static 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p> 
<p>class BasicTypeVar{<!-- --></p> 
<p> private int x;</p> 
<p>}</p> 
<h4>包装类型的缓存机制了解么？</h4> 
<p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p> 
<p>Byte , Short , Integer , Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， Character 创建了数值在 [0,127] 范围的缓存数据， Boolean 直接返回 True or False 。</p> 
<p><strong>Integer 缓存源码：</strong></p> 
<pre><code class="language-java">public static Integer valueOf(int i) {

 if (i &gt;= IntegerCache.low &amp;&amp; i

   return IntegerCache.cache[i + (-IntegerCache.low)];

 return new Integer(i);

}

private static class IntegerCache {

 static final int low = -128;

 static final int high;

 static {

 // high value may be configured by property

 int h = 127;

}

}</code></pre> 
<p><strong>Character 缓存源码:</strong></p> 
<pre><code class="language-java">public static Character valueOf(char c) {

 if (c

 return CharacterCache.cache[(int)c];

}

 return new Character(c);

}

private static class CharacterCache {

 private CharacterCache(){}

 static final Character cache[] = new Character[127 + 1];

 static {

 for (int i = 0; i &lt; cache.length; i++)

   cache[i] = new Character((char)i);

}

}</code></pre> 
<p><strong>Boolean 缓存源码：</strong></p> 
<pre><code class="language-java">public static Boolean valueOf(boolean b) {

 return (b ? TRUE : FALSE);

}</code></pre> 
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p> 
<p>两种浮点数类型的包装类 Float , Double 并没有实现缓存机制。</p> 
<pre><code class="language-java">Integer i1 = 33;

Integer i2 = 33;

System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;

Float i22 = 333f;

System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;

Double i4 = 1.2;

System.out.println(i3 == i4);// 输出 false</code></pre> 
<p><strong>下面我们来看一下问题。下面的代码的输出结果是 true 还是 false 呢？</strong></p> 
<pre><code class="language-java">Integer i1 = 40;

Integer i2 = new Integer(40);

System.out.println(i1==i2);</code></pre> 
<p>Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此， i1 直接使用的是缓存中的对象。而 Integer i2 = new Integer(40) 会直接创建新的对象。</p> 
<p>因此，答案是 false 。你答对了吗？</p> 
<p>记住：所有整型包装类对象之间值的⽐较，全部使用 equals 方法比较。</p> 
<h4 style="background-color:transparent;">什么是隐式转换，什么是显式转换</h4> 
<p>显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。</p> 
<h4>Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型</h4> 
<p>Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据；</p> 
<p>Char类型可以隐式转成int,double类型，但是不能隐式转换成string；</p> 
<p>如果char类型转成byte，short类型的时候，需要强转。</p> 
<h4>int 和 Integer 有什么区别</h4> 
<p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p> 
<p>Java 为每个原始类型提供了包装类型：</p> 
<p>原始类型: boolean，char，byte，short，int，long，float，double</p> 
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p> 
<h4>Integer a= 127 与 Integer b = 127相等吗</h4> 
<p>对于对象引用类型：==比较的是对象的内存地址。</p> 
<p>对于基本数据类型：==比较的是值。如果整型字面量的值在-128到127之间，那么自动装箱时不会new 新的Integer 对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</p> 
<pre><code class="language-java">public static void main(String[] args) {
　　Integer a = new Integer(3);
　　Integer b = 3; // 将3自动装箱成Integer类型
　　int c = 3;
　　System.out.println(a == b); // false 两个引用没有引用同一对象
　　System.out.println(a == c); // true a自动拆箱成int类型再和c比较
System.out.println(b == c); // true

 Integer a1 = 128;
 Integer b1 = 128;
 System.out.println(a1 == b1); // false

 Integer a2 = 127;
 Integer b2 = 127;
 System.out.println(a2 == b2); // true
 }</code></pre> 
<h4>以下代码输出什么</h4> 
<pre><code class="language-java">public class Main {
public static void main(String[] args) {
Double i1 = 100.0;
Double i2 = 100.0;
Double i3 = 200.0;
Double i4 = 200.0;
System.out.println(i1==i2);
System.out.println(i3==i4);
}
}</code></pre> 
<p>运行结果：</p> 
<p>false</p> 
<p>false</p> 
<p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee30a8d3b2872feee129a4d42844c3d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">联合查询为什么小表要放在前面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2f4c1ae9e2a95d610c68e3f95eb2ed4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面向对象基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>