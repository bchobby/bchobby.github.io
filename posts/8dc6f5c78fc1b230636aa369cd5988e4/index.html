<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python cli_使用Python创建您的第一个CLI应用程序Click - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python cli_使用Python创建您的第一个CLI应用程序Click" />
<meta property="og:description" content="python cli
Life at the terminal is sweet. It’s fast powering up tasks, makes multitasking feel remarkably easy and allows you to keep resources that would otherwise be used by a fancy, but unnecessary, GUI.
码头的生活很甜蜜。 它可以快速启动任务，使多任务处理变得异常简单，并允许您保留原本可以由花哨的但不必要的GUI使用的资源。 Think about having to load up a graphical interface Version Control tool every time you want to track a change in your file — it’s scary how time-wasting that is. That’s our need for command-line interfaces on applications." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/8dc6f5c78fc1b230636aa369cd5988e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-14T17:34:58+08:00" />
<meta property="article:modified_time" content="2020-09-14T17:34:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python cli_使用Python创建您的第一个CLI应用程序Click</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <article style="font-size: 16px;"> 
 <p>python cli</p> 
 <div> 
  <section> 
   <div> 
    <div> 
     <p>Life at the terminal is sweet. It’s fast powering up tasks, makes multitasking feel remarkably easy and allows you to keep resources that would otherwise be used by a fancy, but unnecessary, GUI.</p> 
     <p> 码头的生活很甜蜜。 它可以快速启动任务，使多任务处理变得异常简单，并允许您保留原本可以由花哨的但不必要的GUI使用的资源。 </p> 
     <p>Think about having to load up a graphical interface Version Control tool every time you want to track a change in your file — it’s scary how time-wasting that is. That’s our need for command-line interfaces on applications. When you get the itch to create a CLI for an application for the use of you or your team, you scratch it, of course, by building one!</p> 
     <p> 考虑一下每次您要跟踪文件中的更改时都必须加载图形界面版本控制工具-这太浪费时间了，这太可怕了。 这就是我们对应用程序上的命令行界面的需求。 当您想为应用程序创建CLI以便您或您的团队使用时，您当然会通过构建一个来开始使用它！ </p> 
     <p>In this article, well explore <a href="https://pypi.org/project/click/" rel="noopener nofollow noopener noreferrer" target="_blank">Python Click</a> for creating command-line interfaces. We’ll familiarize ourselves with Click’s most useful features and see them at play. To do so, we have to get our hands dirty by creating a media file convertor CLI application — a little dirt never hurt!</p> 
     <p> 在本文中，您将深入探索<a href="https://pypi.org/project/click/" rel="noopener nofollow noopener noreferrer" target="_blank">Python Click</a>来创建命令行界面。 我们将使自己熟悉Click的最有用的功能，并在使用中看到它们。 为此，我们必须通过创建媒体文件转换器CLI应用程序来弄脏我们的手，一点脏物永远不会伤害您！ </p> 
     <p>If you would like to jump right into the complete project first, the code is <a href="https://github.com/hogum/audioConvertor" target="_blank" rel="noopener nofollow noopener noreferrer">here.</a></p> 
     <p> 如果您想先直接进入整个项目，请参见<a href="https://github.com/hogum/audioConvertor" target="_blank" rel="noopener nofollow noopener noreferrer">此处</a>的代码<a href="https://github.com/hogum/audioConvertor" target="_blank" rel="noopener nofollow noopener noreferrer">。</a> </p> 
     <p>In the first part of our Python click tutorial, we cover a general but pretty cool Command Line Interface features undirectly related to click. If you’re about to create your first CLI app, you’ll find this bit useful. But for a direct dive, go straight to the section <a target="_blank" rel="nofollow noopener noreferrer" href="https://medium.com/p/6947d5319ef7"><strong>Bringing Click into the Picture</strong></a>.</p> 
     <p> 在我们的Python Click教程的第一部分中，我们介绍了与Click无关的常规但非常酷的Command Line Interface功能。 如果您要创建第一个CLI应用程序，那么您会发现这很有用。 但是，如果要直接潜水，请直接转到“ <a target="_blank" rel="nofollow noopener noreferrer" href="https://medium.com/p/6947d5319ef7"><strong>将图片插入图片”部分</strong></a> 。 </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> 那么，为什么要使用命令行库？ <span style="font-weight: bold;">(</span>So, Why a Command-Line Library?<span style="font-weight: bold;">)</span></h2> 
     <p>Click is a Python library. It’s possible to create your own CLI from scratch. Take a look at this prompt:</p> 
     <p> Click是一个Python库。 可以从头开始创建自己的CLI。 请看以下提示： </p> 
     <pre><code class="has">$ &gt;&gt;&gt; Make the world go round?<br>       A little [default]<br>       Yes<br>       No</code></pre> 
     <p>It’s a simple prompt that asks the user to select from three available choices. We can simply have this with the command below:</p> 
     <p> 这是一个简单的提示，要求用户从三个可用选项中进行选择。 我们可以使用以下命令简单地做到这一点： </p> 
     <pre><code class="has">user_choice = input('Make the world go round?\n' +<br>      'A little [default]\n' + 'Yes\n' + 'No\n')</code></pre> 
     <p>Just like that, we can interact with the user at the command line. We’re taking a leap of faith and hoping that the user gives us a response from the available choices — which may not happen. This takes us to the issue of parsing user inputs.</p> 
     <p> 这样，我们可以在命令行与用户进行交互。 我们的信念飞跃，希望用户能从可用的选择中给我们答复-可能不会发生。 这将我们带到了解析用户输入的问题。 </p> 
     <p>We have to be ready for the user who replies<em> </em>“spin it” or something fancier like “I’m not sure”.</p> 
     <p> 我们必须为回复的用户做好准备 <em> </em> “旋转”或像“我不确定”这样的幻想者。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>By looping with that condition, we restrict our user to giving us one of the three options. That should do it.</p> 
     <p> 通过循环这种条件，我们限制了用户为我们提供三个选项之一。 那应该做。 </p> 
     <p>But…remember we wanted “A little”<em> </em>to be our default option if the user doesn’t specify anything. We tweak our code a bit to accommodate this. We should end up with something along these lines:</p> 
     <p> 但是…记住我们想要“一点” <em> </em> 如果用户未指定任何内容，则为默认选项。 我们对代码进行了一些调整以适应这一点。 我们应该遵循以下原则： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>It might lessen the excitement, noticing how much patience it takes to parse a single user input. Most of the effort has gone into handling side cases of users who don’t like to follow instructions.</p> 
     <p> 注意到分析单个用户输入需要花费多少耐心，这可能会减少兴奋感。 大多数工作已用于处理不喜欢遵循说明的用户的附带情况。 </p> 
     <p>It would also be better if the app could specify the error in their input, rather than just repeat the same line — another consideration.</p> 
     <p> 如果应用程序可以在输入中指定错误，而不是仅重复同一行，则更好。 </p> 
     <p>It’s possible to do this for a complete CLI app — parse each prompt, have descriptive error messages, give the user frequent feedback (we hate guessing — remember the last time you used <a href="https://en.wikipedia.org/wiki/Dd_%28Unix%29" rel="noopener nofollow noopener noreferrer" target="_blank"><strong>dd</strong></a>). Importantly, we should be asked if we’re sure when we’re about to do something that seems silly.</p> 
     <p> 可以针对完整的CLI应用程序执行此操作-解析每个提示，获取描述性错误消息，为用户提供频繁的反馈(我们讨厌猜测-记住上次使用<a href="https://en.wikipedia.org/wiki/Dd_%28Unix%29" rel="noopener nofollow noopener noreferrer" target="_blank"><strong>dd的</strong></a>时间)。 重要的是，应该问我们是否确定何时要做一些看起来很愚蠢的事情。 </p> 
     <p>We’re getting our hands dirty. We should be focusing on feature delivery. Command-line libraries are here to take away this pain so we can focus on the cool part. Remember, dirt doesn’t hurt — as long as it’s just a little dirt!</p> 
     <p> 我们正在弄脏我们的手。 我们应该专注于功能交付。 命令行库可以减轻这种痛苦，因此我们可以集中精力处理很酷的部分。 记住，污垢不会伤害-只要是一点污垢即可！ </p> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div> 
          <div style="text-align: center;"> 
           <img alt="Image for post" src="https://images2.imgbox.com/12/e6/wkJRrGDn_o.png" width="5352" height="3823" style="outline: none;"> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption>
        Photo by 
       <a href="https://unsplash.com/@zacharykadolph?utm_source=medium&amp;utm_medium=referral" rel="noopener nofollow noopener noreferrer" target="_blank">Zach Kadolph</a> on 
       <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener nofollow noopener noreferrer" target="_blank">Unsplash</a> 
      </figcaption> 
      <figcaption> 
       <a href="https://unsplash.com/@zacharykadolph?utm_source=medium&amp;utm_medium=referral" rel="noopener nofollow noopener noreferrer" target="_blank">Zach Kadolph</a>在 
       <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener nofollow noopener noreferrer" target="_blank">Unsplash</a>上 
       <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener nofollow noopener noreferrer" target="_blank">拍摄的</a>照片 
      </figcaption> 
     </figure> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> 跳入参数向量(Argv) <span style="font-weight: bold;">(</span>Jumping Into Argument Vectors (Argv)<span style="font-weight: bold;">)</span></h2> 
     <p>In the example spinning the world, we used <code>input </code>to interact with the user<em>.</em> However, it would make more sense to allow the user to supply their input directly when launching the application.</p> 
     <p> 在旋转世界的示例中，我们使用<code>input</code>与用户进行交互<em>。</em> 但是，在启动应用程序时允许用户直接提供他们的输入会更有意义。 </p> 
     <p>To run what we currently have, we would use:</p> 
     <p> 要运行当前拥有的内容，我们将使用： </p> 
     <pre><code class="has">&gt;&gt;&gt; python spin_world_v2.pyMake the world go round?<br> A little [default]<br> Yes<br> No: #    <em>User gives input</em></code></pre> 
     <p>The user has to wait for the app to run to give their desired input. What we think would be a well-behaved script is:</p> 
     <p> 用户必须等待应用运行以提供所需的输入。 我们认为，行为良好的脚本是： </p> 
     <pre><code class="has">&gt;&gt;&gt; python spin_world_v2.py 'a little'#<em> Then the world spins. Of course, a little</em></code></pre> 
     <p>That way, we won’t have to wait for an input prompt to ask the user if they want the world to spin. We use <code>argv </code>to do this. Shall we tweak our first script a little more?</p> 
     <p> 这样，我们将不必等待输入提示来询问用户是否希望世界旋转。 我们使用<code>argv</code>来做到这一点。 我们可以再稍微调整一下第一个脚本吗？ </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>Running the script produces the following results:</p> 
     <p> 运行脚本将产生以下结果： </p> 
     <pre><code class="has"><strong>Option 1 - Known argument</strong><br>&gt;&gt;&gt; python spin_world_v2.py 'a little'<br>    <br># <em>Output</em>    [spin_world_v3.py 'a little'] # <em>Our argv list</em>    Spinning this thing a little<strong>Option 2 - Unknown argument</strong><br>&gt;&gt;&gt; python spin_world_v2.py 'some more'# <em>Output</em>    [spin_world_v3.py 'a little'] # <em>Our argv list<br>    <br>    </em>Use with: a little yes, or no. Cool?</code></pre> 
     <p>We’ve created a command-line script. All command-line apps use the argv concept when requiring the user to supply an argument while starting the application. Now, it will be sure to click when we have a look at the same concept, but using click library.</p> 
     <p> 我们已经创建了一个命令行脚本。 当要求用户在启动应用程序时提供参数时，所有命令行应用程序都使用argv概念。 现在，当我们查看相同的概念但使用单击库时，将确保单击。 </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> <strong>界面选项</strong> <span style="font-weight: bold;">(</span><strong>Interface Options</strong><span style="font-weight: bold;">)</span></h2> 
     <p>We use the shell <code><em>ls</em></code> all the time<em>. </em>We can learn some tips about interfaces by having a look at it.</p> 
     <p> 我们一直在使用shell <code><em>ls</em></code> <em>。</em> 我们可以通过学习一些有关接口的技巧。 </p> 
     <p>Running <code><em>ls</em></code><em> </em>in a terminal window:</p> 
     <p> 运行<code><em>ls</em></code> <em> </em> 在终端窗口中： </p> 
     <pre><code class="has">ls</code></pre> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/9d/ec/klTAX9E8_o.png" width="337" height="149" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption> 
       <em>Source</em><em>来源</em> 
       <em>]</em> 
       <em>]</em> 
      </figcaption> 
     </figure> 
     <p>It’s a simple tool. We can use it without calling an argument and be happy.</p> 
     <p> 这是一个简单的工具。 我们可以使用它而无需调用参数并感到高兴。 </p> 
     <p>But would the use of an argument make us happier? Let’s see.</p> 
     <p> 但是使用论点会使我们更快乐吗？ 让我们来看看。 </p> 
     <pre><code class="has"> ls -l</code></pre> 
     <figure style="display:block;text-align:center;"> 
      <div> 
       <div> 
        <div> 
         <div style="text-align: center;"> 
          <img alt="Image for post" src="https://images2.imgbox.com/db/81/y7InUtBQ_o.png" width="641" height="237" style="outline: none;"> 
         </div> 
        </div> 
       </div> 
      </div> 
      <figcaption> 
       <a href="https://www.tecmint.com/" rel="noopener nofollow noopener noreferrer" target="_blank">Source</a>] 
       <a href="https://www.tecmint.com/" rel="noopener nofollow noopener noreferrer" target="_blank">来源</a> ] 
      </figcaption> 
     </figure> 
     <p>Here, we made the tool a little noisy by requesting details. It throws at us the file permissions, the owner, the group, size, time, and name. It worked! In this case, <code>-l</code> is an option. Let’s see docs on its use:</p> 
     <p> 在这里，我们通过询问详细信息使该工具有点嘈杂。 它向我们抛出文件许可权，所有者，组，大小，时间和名称。 有效！ 在这种情况下， <code>-l</code>是一个选项。 让我们看看它的用法文档： </p> 
     <pre><code class="has">&gt;&gt;&gt; ls --help<br>Usage: ls [OPTION]... [FILE]...# <em>Run this to see the complete [OPTIONS] list</em></code></pre> 
     <p>We see <code>ls</code><em> </em>takes only two arguments — the option, and an optional path. We can vary the taste of information we get on our files and sub-directories by playing around with the listed options.</p> 
     <p> 我们看到<code>ls</code> <em> </em> 仅接受两个参数-选项和可选路径。 我们可以通过使用列出的选项来改变在文件和子目录中获得的信息的口味。 </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> 接口命令 <span style="font-weight: bold;">(</span>Interface Commands<span style="font-weight: bold;">)</span></h2> 
     <p><code>ls</code><em> </em>has options. However, we <em>can</em> say it has no commands. The use of commands is to group related options of a CLI.</p> 
     <p> <code>ls</code> <em> </em> 有选择。 但是， <em>可以</em>说它没有命令。 命令的使用是对CLI的相关选项进行分组。 </p> 
     <pre><code class="has">tool command --option</code></pre> 
     <p>We can have hundreds of options in hundreds of commands. Why not place everything in a single list of options? That’s like filling your house with traps so trap admirers can come and visit you! Maintenance of your application will be difficult and users will find it hard to work with more complex features.</p> 
     <p> 我们可以在数百个命令中包含数百个选项。 为什么不将所有内容都放在一个选项列表中？ 这就像用陷阱塞满你的房子，使陷阱崇拜者可以来拜访您！ 应用程序的维护将很困难，并且用户会发现很难使用更复杂的功能。 </p> 
     <p>Let’s go back to our world spinning example and see something cool about commands.</p> 
     <p> 让我们回到旋转世界的示例，看看有关命令的一些很棒的东西。 </p> 
     <p>The spinning of the world is in our control. Perhaps we can specify <em>when the </em>spinning occurs? Our script could have an interface command that allows us to set the time the spinning should take place.</p> 
     <p> 世界的旋转在我们的掌控之中。 也许我们可以指定<em>何时进行</em>旋转？ 我们的脚本可以具有一个接口命令，该命令允许我们设置旋转发生的时间。 </p> 
     <pre><code class="has">python spin_world_v3.py time 0900 1700</code></pre> 
     <p>Here, we set the time interval for which we want the world to spin. From 9 am (0900 hrs) because that’s when we take breakfast, to 5 pm (1700hrs) when we should be leaving work. Since these are working hours, we might want the world to spin faster than usual during this period.</p> 
     <p> 在这里，我们设置希望世界旋转的时间间隔。 从早上9点(0900小时)开始，因为那是我们早餐的时间，到下午5点(1700小时)，我们应该离开工作。 由于这些都是工作时间，因此我们可能希望在此期间世界旋转得比平常更快。 </p> 
     <p>So we give our application a <em>spin</em> command where we can specify the spinning speed.</p> 
     <p> 因此，我们为应用程序提供了一个<em>旋转</em>命令，可以在其中指定旋转速度。 </p> 
     <pre><code class="has">python spin_world_v3.py time 0900 1700 --speed 1500m/h</code></pre> 
     <p>This has given us a simple understanding of the CLI commands concept.</p> 
     <p> 这使我们对CLI命令概念有了简单的了解。 </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> 点击进入图片 <span style="font-weight: bold;">(</span>Bringing Click into the Picture<span style="font-weight: bold;">)</span></h2> 
     <p>We’ve looked at how command-line tools work and the basics of creating a command-line interface.</p> 
     <p> 我们已经研究了命令行工具的工作方式以及创建命令行界面的基础。 </p> 
     <p>Now, let’s create our media-convertor-CLI app. Our application should allow us to convert a media file to a format of our choice. We often use video to audio-conversion tools— it will be exciting to have one that we can tweak ourselves.</p> 
     <p> 现在，让我们创建我们的媒体转换器CLI应用。 我们的应用程序应允许我们将媒体文件转换为我们选择的格式。 我们经常使用视频到音频转换工具-拥有一个我们可以自己调整的工具将非常令人兴奋。 </p> 
     <h3> <strong>应用设置</strong> <span style="font-weight: bold;">(</span><strong>App setup</strong><span style="font-weight: bold;">)</span></h3> 
     <p>Our directory structure will look like this:</p> 
     <p> 我们的目录结构如下所示： </p> 
     <pre><code class="has">| audioConvertor  |-convertor<br>    |- __init__.py<br>    |- utils<br>      |- __init__.py<strong>    |- cli.py</strong>|- tests<br>    |- __init__.py- setup.py</code></pre> 
     <p>We create the interface of our app in the file <code>cli.py</code>.</p> 
     <p> 我们在文件<code>cli.py</code>创建应用程序的界面。 </p> 
     <h3> <strong>添加使用选项</strong> <span style="font-weight: bold;">(</span><strong>Adding usage options</strong><span style="font-weight: bold;">)</span></h3> 
     <p>To convert a file, we need to know its location. So we need to allow the user to tell our application where to get this file. We start building our app by creating a simple script that does that.</p> 
     <p> 要转换文件，我们需要知道其位置。 因此，我们需要允许用户告诉我们的应用程序在何处获取此文件。 我们通过创建一个简单的脚本来开始构建我们的应用程序。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>We give our users an option <code>--input_directory</code> to specify which file to convert<em>. </em>We can run the script as follows:</p> 
     <p> 我们为用户提供<code>--input_directory</code>选项，以指定要转换的文件<em>。</em> 我们可以如下运行脚本： </p> 
     <pre><code class="has">$ python cli.py --input_directory Videos/musicVideo.mp4# <em>Output</em><br>Videos/musicVideo.mp4</code></pre> 
     <p>Our script echoes back the file the user has specified. It works!</p> 
     <p> 我们的脚本回显用户指定的文件。 有用！ </p> 
     <p>How will our users know how to interact with the app? A short help<em> </em>menu works a charm. With<em> </em>Click<em>, </em>we get this easy and for free. Let’s check it out by running:</p> 
     <p> 我们的用户将如何知道如何与该应用进行交互？ 短暂的帮助 <em> </em> 菜单很有魅力。 用 <em> </em> 点击<em>，</em>我们可以轻松，免费地进行此操作。 让我们通过运行检查一下： </p> 
     <pre><code class="has">$ python cli.py --help# <em>Output</em>Usage: cli.py [OPTIONS]audioConvertor is a command-line tool that helps convert video files to audio file formats.example: python cli.py -i input/file/path -o output/pathOptions:<br>  -i, --input_directory TEXT  Location of the media file to be converted<br>  --help                      Show this message and exit.</code></pre> 
     <p>Note the convenience<em>. </em><code>-i </code>is also interchangeable with <code>--input_directory</code><em>. </em>The help example says an output path is necessary too.</p> 
     <p> 注意方便<em>。</em> <code>-i</code>也可以与<code>--input_directory</code>互换<em>。</em> 帮助示例说输出路径也是必需的。 </p> 
     <pre><code class="has">example: python cli.py -i input/file/path -o output/path</code></pre> 
     <p>We can get it working this way by adding the following lines to our script:</p> 
     <p> 我们可以通过在脚本中添加以下几行来使其工作： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>The added lines are marked <code>++</code>. Adding an option is as easy as calling <code>@click.option </code>and passing our string to the decorated function. Remember to pass your options to <code>main</code> in order of creation.</p> 
     <p> 添加的行标记为<code>++</code> 。 添加选项就像调用<code>@click.option</code>并将我们的字符串传递给装饰函数一样容易。 请记住按创建顺序将选项传递给<code>main</code> 。 </p> 
     <h3> <strong>解析用户选项</strong> <span style="font-weight: bold;">(</span><strong>Parsing user options</strong><span style="font-weight: bold;">)</span></h3> 
     <p>It would be good manners to confirm the existence of a file before we attempt to convert it. We can do so like this:</p> 
     <p> 在尝试转换文件之前，最好先确认文件的存在。 我们可以这样做： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>The script should now terminate if a user provides a non-existent media file. But with Click, parsing and validation are handled for us. The snippet of code below serves the same purpose as what we’ve just done above:</p> 
     <p> 现在，如果用户提供的媒体文件不存在，该脚本应终止。 但是使用Click可以为我们处理解析和验证。 以下代码段的目的与上面所做的目的相同： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>The magic happens at line six. By supplying the <code>type</code><em> </em>parameter to Click’s options command, we can tell Click to ensure the user gives as <code>--input_directory</code><em> </em>as a path, and that it exists.</p> 
     <p> 魔术发生在第六行。 通过提供<code>type</code> <em> </em> Click选项的参数，我们可以告诉Click确保用户输入为<code>--input_directory</code> <em> </em> 作为一条路径，并且它存在。 </p> 
     <p>Click gives us <a href="https://click.palletsprojects.com/en/7.x/options/" rel="noopener nofollow noopener noreferrer" target="_blank">plenty of arguments</a> to use in an option. We get to see more of them in play as we progress.</p> 
     <p> 单击为我们提供了在选项中使用的<a href="https://click.palletsprojects.com/en/7.x/options/" rel="noopener nofollow noopener noreferrer" target="_blank">大量参数</a> 。 随着我们的进步，我们可以看到更多的游戏。 </p> 
     <h3> <strong>添加命令</strong> <span style="font-weight: bold;">(</span><strong>Adding commands</strong><span style="font-weight: bold;">)</span></h3> 
     <p>Using commands will allow us to isolate different features of our application for the convenience of users. It also makes it easier to add new options. For example, we have two options — it would make sense to nest them in a command that describes what they do.</p> 
     <p> 使用命令将使我们能够隔离应用程序的不同功能，以方便用户使用。 它还使添加新选项更加容易。 例如，我们有两个选项-将它们嵌套在描述它们功能的命令中是有意义的。 </p> 
     <pre><code class="has">python cli.py convert -i input/file/path -o output/path</code></pre> 
     <p>We want to bundle our options in a <code>convert</code> command, so our app can be used as shown. What’s something else we would want our app to do besides converting? If we could play our converted songs, that would be nice. So, if we use it as shown below, something should pop out of our speakers:</p> 
     <p> 我们希望将选项捆绑在<code>convert</code>命令中，因此可以如图所示使用我们的应用程序。 除了转换外，我们还希望我们的应用程序还要做什么？ 如果我们可以播放转换后的歌曲，那就太好了。 因此，如果我们按如下所示使用它，则扬声器中应该弹出一些声音： </p> 
     <pre><code class="has">python cli.py play --playlist path/to/audio</code></pre> 
     <p>We know how we want our app to work. Let’s get to it.</p> 
     <p> 我们知道我们希望我们的应用程序如何工作。 让我们开始吧。 </p> 
     <h3> <strong>分组命令</strong> <span style="font-weight: bold;">(</span><strong>Grouping the commands</strong><span style="font-weight: bold;">)</span></h3> 
     <p>The first thing we do is add the commands <code>play</code> and <code>convert</code> to our app.</p> 
     <p> 我们要做的第一件事是添加命令<code>play</code>并将其<code>convert</code>为我们的应用程序。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>Let’s go through this script.</p> 
     <p> 让我们来看一下这个脚本。 </p> 
     <p>We have three functions: — <code>main</code>, <code>load_files</code>, and <code>load_audio</code>. The function <code>main</code><em> </em>is helping us group our two commands with Click by decorating it with <code>@click.group</code><em>. </em>This is our first step.</p> 
     <p> 我们有三个功能： - <code>main</code> ， <code>load_files</code>和<code>load_audio</code> 。 功能<code>main</code> <em> </em> 通过用<code>@click.group</code>装饰它来帮助我们将两个命令与Click <code>@click.group</code> <em>。</em> 这是我们的第一步。 </p> 
     <p>After that, notice how easy it is to add a command — we call <code>@main.command </code>then specify the options we think will make us happy.</p> 
     <p> 之后，请注意添加命令有多容易-我们调用<code>@main.command</code>然后指定我们认为会让我们满意的选项。 </p> 
     <p>There’s this line hovering around:</p> 
     <p> 这条线徘徊： </p> 
     <pre><code class="has">@click.pass_context</code></pre> 
     <p>Whenever we want to use an argument specified in command but in a different function, we pass its context. This is done by storing it in the click <em>context object</em> dictionary. See what we do in line 21:</p> 
     <p> 每当我们要使用命令中指定的参数但在其他函数中使用时，我们都会传递其上下文。 这是通过将其存储在单击<em>上下文对象</em>字典中来完成的。 看看我们在第21行中所做的事情： </p> 
     <pre><code class="has">ctx.obj[‘VERBOSE’] = verbose</code></pre> 
     <p>This allows us to access the value of <code>VERBOSE</code> in any other function with a click decorator by passing in <code>ctx</code><em>. </em>(Remember to call main with the <code>obj</code> argument as in line 52). For example:</p> 
     <p> 这使我们可以通过传入<code>ctx</code>来通过单击装饰器访问任何其他函数中的<code>VERBOSE</code>值<em>。</em> (请记住，如第52行所示，使用<code>obj</code>参数调用main)。 例如： </p> 
     <pre><code class="has">def load_files(ctx, input_directory, output):<br>    """<br>        :   Convert video file input to audio.<br>    """<br>    if ctx.obj.get('VERBOSE'):<br>        # <em>shout a lot</em><br>    else:<br>       #  <em>convert quietly</em></code></pre> 
     <p>We introduced some new arguments to our command <em>options</em> too. Here’s what they help us achieve:</p> 
     <p> 我们还在命令<em>选项中</em>引入了一些新参数。 以下是他们帮助我们实现的目标： </p> 
     <ul><li><p><code>required</code>: mandatory input.</p><p> <code>required</code> ：必填项。 </p></li><li><p><code>multiple</code>: allow users to add many parameters e.g convert -<em>i</em> video_1 -<em>i </em>video_2.</p><p> <code>multiple</code> ：允许用户添加许多参数，例如convert- <em>i</em> video_1- <em>i</em> video_2。 </p></li><li><p><code>nargs</code><em>: </em>almost same a<em>s multiple e.g </em>convert -<em>i</em> video_1 video_2 video_3</p><p> <code>nargs</code> <em>：</em>几乎相同的<em>s倍数，例如，</em>转换<em>-i</em> video_1 video_2 video_3 </p></li></ul> 
     <p>In our case, <code>nargs</code> would help us specify multiple input files.</p> 
     <p> 就我们而言， <code>nargs</code>将帮助我们指定多个输入文件。 </p> 
     <ul><li><p><code>is_flag</code>: A boolean option that doesn’t need a parameter`.</p><p> <code>is_flag</code> ：不需要参数的布尔选项。 </p></li></ul> 
     <h3> <strong>转换-选项</strong> <span style="font-weight: bold;">(</span><strong>Convert — option</strong><span style="font-weight: bold;">)</span></h3> 
     <p>Let’s list out all our decorators for function <code>(<em>load_files</em>)</code> running the convert command.</p> 
     <p> 让我们列出所有用于运行convert命令的函数<code>( <em>load_files</em> )</code>装饰器。 </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>That’s a list of options for one command on our CLI. Now let’s dive into processing the parameters received from the user. For easier maintenance, we will isolate all our processing functionality to a new file, in a class called <code>Convertor</code>.</p> 
     <p> 这是CLI上一个命令的选项列表。 现在，让我们深入研究处理从用户那里收到的参数。 为了简化维护，我们将所有处理功能隔离到一个名为<code>Convertor</code>的类中的新文件中。 </p> 
     <pre><code class="has">| audioConvertor|-convertor<br>    |- __init__.py<br>    |- utils<br>      |- __init__.py<strong>   </strong> |- cli.py<strong>    |- formats.py</strong>|- tests<br>    |- __init__.py- setup.py</code></pre> 
     <p>Since our focus is on the CLI, we won’t dwell on the <code>Convertor</code><strong> </strong>class. But I made an effort to <a href="https://github.com/mugoh/audioConvertor/blob/a4afedd128e36c5761963fa30ebf0aeac9e151c0/convertor/formats.py#L14" target="_blank" rel="noopener nofollow noopener noreferrer">document it</a> quite nicely, so don’t worry about it.</p> 
     <p> 由于我们专注于CLI，因此我们将不再关注<code>Convertor</code> <strong> </strong> 类。 但是我尽力将<a href="https://github.com/mugoh/audioConvertor/blob/a4afedd128e36c5761963fa30ebf0aeac9e151c0/convertor/formats.py#L14" target="_blank" rel="noopener nofollow noopener noreferrer">其</a>很好地<a href="https://github.com/mugoh/audioConvertor/blob/a4afedd128e36c5761963fa30ebf0aeac9e151c0/convertor/formats.py#L14" target="_blank" rel="noopener nofollow noopener noreferrer">记录下来</a> ，所以不用担心。 </p> 
     <p>Let’s add these lines to the top of our <code>cli.py</code>:</p> 
     <p> 让我们将这些行添加到<code>cli.py</code>的顶部： </p> 
     <pre><code class="has">import click<br>from formats import Convertor # +convertor_instance = Convertor() # +</code></pre> 
     <figure style="display:block;text-align:center;"> 
      <figcaption>
        processing user input 
      </figcaption> 
      <figcaption>
        处理用户输入 
      </figcaption> 
     </figure> 
     <p>Let’s toy around a bit on our interface with the above options:</p> 
     <p> 让我们在上面的选项中玩一些玩具： </p> 
     <pre><code class="has">$ python3 convertor/cli.py convert -i /root/Videos/# <em>Output</em><br>/root/Videos/ is a directory. --recursive Needed for a directory</code></pre> 
     <p>Let’s point our app to a file and attempt to convert it again:</p> 
     <p> 让我们将应用程序指向一个文件，然后尝试再次将其转换： </p> 
     <pre><code class="has">python3 convertor/cli.py convert -i Videos/snoring_noises.avi<em></em>Input specified as file name.<br>.<br>Conversion Complete<br>saved: snoring_noises.mp3</code></pre> 
     <p>The app should prompt us to install <code><a href="https://pypi.org/project/ffmpeg-python/" rel="noopener nofollow noopener noreferrer" target="_blank">ffmpeg</a></code><em>, </em>which is the media convertor library we shall use. This is getting exciting!</p> 
     <p> 该应用程序应提示我们安装<code><a href="https://pypi.org/project/ffmpeg-python/" rel="noopener nofollow noopener noreferrer" target="_blank">ffmpeg</a></code> <em>，</em>这是我们将使用的媒体转换器库。 这真令人兴奋！ </p> 
     <p>Next, let’s allow the user to convert multiple video files at once by running:</p> 
     <p> 接下来，让用户通过运行一次转换多个视频文件： </p> 
     <pre><code class="has">python3 convertor/cli.py convert -i /root/Videos/* -o /root/converted_music</code></pre> 
     <p>This command should convert for us all video files in the Videos folder to audio and save the output to the directory <code>converted_music</code>. Adding the following code to the <code>load_files</code> function should do it:</p> 
     <p> 此命令应为我们将“视频”文件夹中的所有视频文件转换为音频，并将输出保存到目录<code>converted_music</code> 。 将以下代码添加到<code>load_files</code>函数即可： </p> 
     <figure style="display:block;text-align:center;"> 
      <figcaption>
        ++ in the `load_files` function 
      </figcaption> 
      <figcaption>
        `load_files`函数中的++ 
      </figcaption> 
     </figure> 
     <h3> <strong>播放—选项</strong> <span style="font-weight: bold;">(</span><strong>Play — option</strong><span style="font-weight: bold;">)</span></h3> 
     <p>The play command decorates the<em> </em><code>load_audio</code> function:</p> 
     <p> 播放命令装饰 <em> </em> <code>load_audio</code>函数： </p> 
     <figure style="display:block;text-align:center;"></figure> 
     <p>The app should now allow us to load a playlist of our choice.</p> 
     <p> 该应用程序现在应允许我们加载我们选择的播放列表。 </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> <strong>链接命令</strong> <span style="font-weight: bold;">(</span><strong>Chaining Commands</strong><span style="font-weight: bold;">)</span></h2> 
     <p>Whenever we want to convert a file then play its audio, our CLI application restricts us from running the <em>convert</em> and <em>play</em> command individually. That’s good enough, but wouldn’t it be better if we could use the interface as follows?</p> 
     <p> 每当我们要转换文件然后播放其音频时，我们的CLI应用程序都会限制我们分别运行<em>convert</em> and <em>play</em>命令。 那已经足够好了，但是如果我们可以按如下方式使用接口，那会更好吗？ </p> 
     <pre><code class="has">python convertor/cli.py <strong>convert</strong> -<em>i</em> my_video_file.mp4 <strong>play</strong></code></pre> 
     <p>To use more than one command at a go, we pass the <code>chain</code> argument to our multi-command:</p> 
     <p> 要一次使用多个命令，我们将<code>chain</code>参数传递给我们的多命令： </p> 
     <pre><code class="has"><a href="http://twitter.com/click" rel="noopener nofollow noopener noreferrer" target="_blank">@click</a>.group(invoke_without_command=True, chain=True)</code></pre> 
     <p>That’s just the first step. We are invoking <code>convert</code><em> </em>first. When we run <code>play</code><em> </em>later, the location of our converted file shall need to be known. For every successful conversion, our interface should know the path of the saved file(s).</p> 
     <p> 那只是第一步。 我们正在调用<code>convert</code> <em> </em> 第一。 当我们运行<code>play</code> <em> </em> 以后，我们转换后的文件的位置必须是已知的。 对于每次成功的转换，我们的界面都应知道已保存文件的路径。 </p> 
     <pre><code class="has">ctx.obj[‘PLAYLIST’] = convertor_instance.get_file_save_path()</code></pre> 
     <p>We add the <code>PLAYLIST</code> key as a context accessible to all our sub-commands. <code>get_file_save_path </code>is the function that does this. The above line shall be added in two places in the <code>load_files </code>function:</p> 
     <p> 我们将<code>PLAYLIST</code>键添加为所有子命令均可访问的上下文。 <code>get_file_save_path</code>是执行此操作的函数。 上一行应在<code>load_files</code>函数的两个位置添加： </p> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> 其他注意事项 <span style="font-weight: bold;">(</span>Some Additional Considerations<span style="font-weight: bold;">)</span></h2> 
     <h3> 单个和多个文件转换 <span style="font-weight: bold;">(</span>Individual and multiple file conversion<span style="font-weight: bold;">)</span></h3> 
     <p>To differentiate between the single and multiple file inputs, one tweak would be allowing the user to set a recursive option. The <code>recursive </code>flag, during processing, will let us know if we are to convert a single or more than one file.</p> 
     <p> 为了区分单个文件输入和多个文件输入，一项调整将允许用户设置一个递归选项。 在处理过程中， <code>recursive</code>标志将让我们知道我们是否要转换单个或多个文件。 </p> 
     <p>Additionally, to check if the input is a directory, we recurse through all its children and find any valid file matching a video format.</p> 
     <p> 另外，要检查输入是否为目录，我们遍历其所有子级，然后找到与视频格式匹配的任何有效文件。 </p> 
     <pre><code class="has">if os.path.isfile(input_directory) and not recursive:<br>    # <em>convert single file</em>else:<em>    </em># <em>convert multiple files</em></code></pre> 
     <p>That solves it for us. We can even match input files recursively using the wild-card, <code>*</code>:</p> 
     <p> 那为我们解决了。 我们甚至可以使用通配符<code>*</code>递归匹配输入文件： </p> 
     <pre><code class="has">python convertor/cli.py <strong>convert</strong> -<em>i</em> Videos/snoring*.mp4 <strong>play</strong></code></pre> 
     <h3> 可选参数 <span style="font-weight: bold;">(</span>Optional arguments<span style="font-weight: bold;">)</span></h3> 
     <p>If we attempted to run the above command, we might get an output such as this:</p> 
     <p> 如果尝试运行上述命令，则可能会得到如下输出： </p> 
     <pre><code class="has">python convertor/cli.py <strong>convert</strong> -<em>i</em> Videos/snoring*.mp4 <strong>play</strong>Usage: cli.py play [OPTIONS]<br>Try "cli.py play --help" for help.Error: Missing option "--playlist" / "-p".</code></pre> 
     <p>It means <code>playlist </code>is a required argument. To make it optional, required set to <code>False </code>as follows:</p> 
     <p> 这意味着<code>playlist</code>是必填参数。 要使其可选，必须将其设置为<code>False</code> ，如下所示： </p> 
     <pre><code class="has"><a href="http://twitter.com/click" rel="noopener nofollow noopener noreferrer" target="_blank">@click</a>.option('--playlist', '-p', required=<strong>False</strong>, type=click.Path(exists=True),<br>              help="Folder containing audio files to be played")</code></pre> 
    </div> 
   </div> 
  </section> 
  <section> 
   <div> 
    <div> 
     <h2> <strong>结论</strong> <span style="font-weight: bold;">(</span><strong>Conclusion</strong><span style="font-weight: bold;">)</span></h2> 
     <p>That’s it, folks.</p> 
     <p> 就是这样，伙计们。 </p> 
     <p>We’re now familiar with command-line interfaces and have learned how to interface an application to the terminal, using Click<em>. </em>I hope this Python Click tutorial has helped you gain something exciting and useful. Remember you can have a tour of the complete project on its <a href="https://github.com/hogum/audioConvertor" target="_blank" rel="noopener nofollow noopener noreferrer">GitHub repo</a>.</p> 
     <p> 现在，我们已经熟悉命令行界面，并且学习了如何使用Click将应用程序连接到终端<em>。</em> 希望本Python Click教程能帮助您获得激动人心且有用的东西。 记住，您可以在其<a href="https://github.com/hogum/audioConvertor" target="_blank" rel="noopener nofollow noopener noreferrer">GitHub repo</a>上浏览整个项目。 </p> 
     <p>You are awesome. Make your next CLI better.</p> 
     <p> 你真棒。 使您的下一个CLI更好。 </p> 
    </div> 
   </div> 
  </section> 
 </div> 
 <blockquote> 
  <p>翻译自: <a href="https://medium.com/better-programming/python-click-building-your-first-command-line-interface-application-6947d5319ef7" rel="nofollow">https://medium.com/better-programming/python-click-building-your-first-command-line-interface-application-6947d5319ef7</a></p> 
 </blockquote> 
 <p>python cli</p> 
</article>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ad105f57100384018d62f491660a864/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">传统PHP项目迁移到k8s上</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e278618407cb01e1758b1e3b49e5ced/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开源视频处理工具Shotcut的用法： 剪切、合并、增加背景音乐、添加字幕、 插入视频、图片转视频并加背景音乐、制作电子相册</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>