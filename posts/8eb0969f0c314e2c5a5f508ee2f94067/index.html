<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Crypto API - 9.1 编程接口-块密码算法定义 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Crypto API - 9.1 编程接口-块密码算法定义" />
<meta property="og:description" content="编程接口-块密码算法定义 这些数据结构定义了模块化加密算法实现，通过 crypto_register_alg（） 和 crypto_unregister_alg（） 进行管理。
struct cipher_alg single-block symmetric ciphers definition（单块对称密码定义） 定义：
struct cipher_alg { unsigned int cia_min_keysize; unsigned int cia_max_keysize; int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen); void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src); void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src); }; 成员
cia_min_keysize
变换所支持的最小密钥长度。这是此变换算法支持的最小密钥长度。此值必须设置为预定义值之一，因为它不是特定于硬件的。此字段的可能取值可以通过 git grep &#34;_MIN_KEY_SIZE&#34; include/crypto/ 找到。 cia_max_keysize
变换所支持的最大密钥长度。这是此变换算法支持的最大密钥长度。此值必须设置为预定义值之一，因为它不是特定于硬件的。此字段的可能取值可以通过 git grep &#34;_MAX_KEY_SIZE&#34; include/crypto/ 找到。 cia_setkey
为变换设置密钥。此函数用于将提供的密钥编程到硬件中，或将密钥存储在变换上下文中以供稍后编程。请注意，此函数确实会修改变换上下文。在变换对象存在期间，可以多次调用此函数，因此必须确保密钥已正确地重新编程到硬件中。此函数还负责检查密钥长度的有效性。 cia_encrypt" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/8eb0969f0c314e2c5a5f508ee2f94067/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T22:28:59+08:00" />
<meta property="article:modified_time" content="2023-12-28T22:28:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Crypto API - 9.1 编程接口-块密码算法定义</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>编程接口-块密码算法定义</h2> 
<p>这些数据结构定义了模块化加密算法实现，通过 crypto_register_alg（） 和 crypto_unregister_alg（） 进行管理。</p> 
<pre><code>struct cipher_alg
single-block symmetric ciphers definition（单块对称密码定义）
</code></pre> 
<p><strong>定义：</strong></p> 
<pre><code>struct cipher_alg {
    unsigned int cia_min_keysize;
    unsigned int cia_max_keysize;
    int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen);
    void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
    void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
};
</code></pre> 
<p><strong>成员</strong></p> 
<p>cia_min_keysize</p> 
<pre><code>变换所支持的最小密钥长度。这是此变换算法支持的最小密钥长度。此值必须设置为预定义值之一，因为它不是特定于硬件的。此字段的可能取值可以通过 git grep "_MIN_KEY_SIZE" include/crypto/ 找到。
</code></pre> 
<p>cia_max_keysize</p> 
<pre><code>变换所支持的最大密钥长度。这是此变换算法支持的最大密钥长度。此值必须设置为预定义值之一，因为它不是特定于硬件的。此字段的可能取值可以通过 git grep "_MAX_KEY_SIZE" include/crypto/ 找到。
</code></pre> 
<p>cia_setkey</p> 
<pre><code>为变换设置密钥。此函数用于将提供的密钥编程到硬件中，或将密钥存储在变换上下文中以供稍后编程。请注意，此函数确实会修改变换上下文。在变换对象存在期间，可以多次调用此函数，因此必须确保密钥已正确地重新编程到硬件中。此函数还负责检查密钥长度的有效性。
</code></pre> 
<p>cia_encrypt</p> 
<pre><code>对单个块进行加密。此函数用于加密一个大小必须为cra_blocksize的数据块。它始终对整个cra_blocksize进行操作，不可能加密一个更小尺寸的块。因此，提供的缓冲区的大小也必须至少为cra_blocksize。输入和输出缓冲区始终对齐到cra_alignmask。如果由crypto API的用户提供的输入或输出缓冲区之一不对齐到cra_alignmask，crypto API将重新对齐缓冲区。重新对齐意味着将分配一个新的缓冲区，数据将被复制到新的缓冲区中，然后在新的缓冲区上进行处理，然后将数据复制回原始缓冲区，最后释放新的缓冲区。如果在cra_init调用中实施了软件回退(fallback)，当算法不支持所有密钥长度时，此函数可能需要使用回退。如果密钥存储在变换上下文中，此函数可能需要将密钥重新编程到硬件中。此函数不应修改变换上下文，因为可能会并行调用相同的变换对象。
</code></pre> 
<p>cia_decrypt</p> 
<pre><code>解密单个块。这与cia_encrypt相反，条件完全相同。
</code></pre> 
<h2><a id="_40"></a>描述</h2> 
<p>所有字段都是强制性的，必须填写。</p> 
<pre><code>struct compress_alg
    compression/decompression algorithm（压缩/解压缩算法）
</code></pre> 
<p><strong>定义</strong></p> 
<pre><code>struct compress_alg {
    int (*coa_compress)(struct crypto_tfm *tfm, const u8 *src, unsigned int slen, u8 *dst, unsigned int *dlen);
    int (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src, unsigned int slen, u8 *dst, unsigned int *dlen);
};
</code></pre> 
<p><strong>成员</strong></p> 
<p>coa_compress</p> 
<pre><code>压缩指定长度的缓冲区，将生成的数据存储在指定的缓冲区中。数据的长度以 dlen 返回。
</code></pre> 
<p>coa_decompress</p> 
<pre><code>解压缩源缓冲区，将未压缩的数据存储在指定的缓冲区中。数据的长度以 dlen 返回。
</code></pre> 
<h2><a id="_64"></a>描述</h2> 
<p>所有字段都是强制性的</p> 
<pre><code>struct crypto_alg
    definition of a cryptograpic cipher algorithm（加密密码算法的定义）
</code></pre> 
<p><strong>定义：</strong></p> 
<pre><code>struct crypto_alg {
    struct list_head cra_list;
    struct list_head cra_users;
    u32 cra_flags;
    unsigned int cra_blocksize;
    unsigned int cra_ctxsize;
    unsigned int cra_alignmask;
    int cra_priority;
    refcount_t cra_refcnt;
    char cra_name[CRYPTO_MAX_ALG_NAME];
    char cra_driver_name[CRYPTO_MAX_ALG_NAME];
    const struct crypto_type *cra_type;
    union {
        struct cipher_alg cipher;
        struct compress_alg compress;
    } cra_u;
    int (*cra_init)(struct crypto_tfm *tfm);
    void (*cra_exit)(struct crypto_tfm *tfm);
    void (*cra_destroy)(struct crypto_alg *alg);
    struct module *cra_module;
};
</code></pre> 
<p><strong>成员</strong></p> 
<p>cra_list</p> 
<pre><code>内部使用
</code></pre> 
<p>ra_users<br> 内部使用</p> 
<p>cra_flags</p> 
<pre><code>描述此变换的标志。请参见include/linux/crypto.h CRYPTO_ALG_*标志，用于精细调整变换算法的描述。
</code></pre> 
<p>cra_blocksize</p> 
<pre><code>此变换的最小块大小。以字节为单位表示该算法可以转换的最小单位的大小。用户必须遵守此值。在HASH变换的情况下，可以传递比cra_blocksize更小的块到加密API进行变换，而在其他任何变换类型的情况下，任何尝试转换小于cra_blocksize的块都将返回错误。
</code></pre> 
<p>cra_ctxsize</p> 
<pre><code>转换的操作上下文的大小。此值通知内核加密 API 需要为转换上下文分配的内存大小。
</code></pre> 
<p>cra_alignmask</p> 
<pre><code>对于 cipher、skcipher、lskcipher 和 aead 算法，这比算法实现对输入和输出缓冲区所需的对齐方式（以字节为单位）少 1。当使用未与此对齐方式对齐的缓冲区调用加密 API 时，加密 API 会自动利用适当对齐的临时缓冲区来符合算法的需求。（对于散点列表（scatterlists），仅当算法使用 skcipher_walk 帮助程序函数时才会发生这种情况。这种错位处理会带来性能损失，因此算法最好不要设置非零对齐掩码。此外，加密 API 用户可能希望分配与所用算法的对齐掩码对齐的缓冲区，以避免 API 必须重新对齐它们。注意：哈希算法不支持对齐掩码，并且它们始终为 0。
</code></pre> 
<p>cra_priority</p> 
<pre><code>此转换实现的优先级。如果 Crypto API 可以使用具有相同cra_name的多个转换，内核将使用具有最高cra_priority的转换。
</code></pre> 
<p>cra_refcnt<br> 内部使用</p> 
<p>cra_name<br> 变换算法的通用名称（可由多个实现使用）。这是变换本身的名称。内核在查找特定变换的提供者时使用此字段。</p> 
<p>cra_driver_name<br> 变换提供者的唯一名称。这是变换提供者的名称。它可以是任意值，但通常情况下，它包含芯片或提供者的名称以及变换算法的名称。</p> 
<p>cra_type<br> 加密转换的类型。这是指向struct crypto_type的指针，该指针实现了所有转换类型通用的回调函数。有多种选项，例如crypto_skcipher_type，crypto_ahash_type，crypto_rng_type。这个字段可能为空。在这种情况下，没有通用的回调函数。这是密码、压缩、散列等算法的情况。</p> 
<p>cra_u<br> 实现变换的回调函数。这是多个结构的联合体。根据上述 cra_type 和 cra_flags 选择的变换类型，必须填充相关的结构体回调函数。这个字段可能为空。这是散列算法的情况。</p> 
<p>cra_u.cipher<br> 联合体成员，包含单块对称密码定义。请参阅 struct cipher_alg。</p> 
<p>cra_u.compress<br> 包含（解）压缩算法的联合成员。请参阅 struct compress_alg。</p> 
<p>cra_init<br> 初始化加密变换对象。此函数用于初始化加密变换对象。该函数在实例化时仅被调用一次，在分配变换上下文之后立即调用。如果加密硬件具有一些需要软件处理的特殊要求，此函数应检查变换的精确要求，并采取任何软件回退措施。</p> 
<p>cra_exit<br> 取消初始化加密变换对象。这是 cra_init 的对应函数，用于移除 cra_init 中设置的各种更改。</p> 
<p>cra_destroy<br> 内部使用。</p> 
<p>cra_module<br> 此转换实现的所有者。设置为 THIS_MODULE。</p> 
<h2><a id="_157"></a>描述</h2> 
<p>struct crypto_alg 描述了一个通用的 Crypto API 算法，对于所有的变换都是通用的。在此未记录的任何变量都不应该被密码实现使用，因为它们是 Crypto API 内部使用的。</p> 
<h2><a id="_API_160"></a>对称密钥密码 API</h2> 
<p>对称密钥密码 API 用于 CRYPTO_ALG_TYPE_SKCIPHER 类型的密码（在 /proc/crypto 中被列为 “skcipher” 类型）。</p> 
<p>异步密码操作意味着密码请求的函数调用会立即返回，而不等待操作完成。该密码请求会作为一个独立的内核线程进行调度，通过进程调度程序在不同的 CPU 上进行负载平衡。为了让内核加密 API 能够通知调用者密码请求的完成，调用者必须提供一个回调函数。当请求完成时，该函数会使用密码句柄进行调用。</p> 
<p>为了支持异步操作，除了仅仅提供密码句柄，还必须向内核加密 API 提供其他的信息。这些额外的信息通过填充 skcipher_request 数据结构来提供。</p> 
<p>对于对称密钥密码 API，状态是通过 tfm 密码句柄来维护的。一个 tfm 可以在多个调用和并行操作中使用。对于异步块密码调用，除了用于密码请求的 IV 之外，还可以将供调用者使用的上下文数据引用到请求数据结构中。对于加密驱动程序实施者来说，维护这种状态信息是很重要的，因为当在加密操作完成时调用回调函数时，如果它并行调用了多个操作，那么回调函数可能需要一些关于刚刚完成的操作的信息。这种状态信息由内核加密 API 未使用。</p> 
<p>struct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name, u32 type, u32 mask)</p> 
<p>allocate symmetric key cipher handle</p> 
<pre><code>Parameters

const char *alg_name
    is the cra_name / name or cra_driver_name / driver name of the skcipher cipher

u32 type
    specifies the type of the cipher

u32 mask
    specifies the mask for the cipher

Description

    Allocate a cipher handle for an skcipher. The returned struct crypto_skcipher is the cipher handle that is required for any subsequent API invocation for that skcipher.

Return

    allocated cipher handle in case of success; IS_ERR() is true in case
    of an error, PTR_ERR() returns the error code.
</code></pre> 
<p>void crypto_free_skcipher(struct crypto_skcipher *tfm)</p> 
<p>zeroize and free cipher handle</p> 
<pre><code>Parameters

struct crypto_skcipher *tfm
    cipher handle to be freed

Description

    If tfm is a NULL or error pointer, this function does nothing.
</code></pre> 
<p>int crypto_has_skcipher(const char *alg_name, u32 type, u32 mask)</p> 
<p>Search for the availability of an skcipher.</p> 
<pre><code>Parameters

const char *alg_name
    is the cra_name / name or cra_driver_name / driver name of the skcipher

u32 type
    specifies the type of the skcipher

u32 mask
    specifies the mask for the skcipher

Return

    true when the skcipher is known to the kernel crypto API; false otherwise
</code></pre> 
<p>unsigned int crypto_skcipher_ivsize(struct crypto_skcipher *tfm)<br> obtain IV size</p> 
<pre><code>Parameters

struct crypto_skcipher *tfm
    cipher handle

Description

    The size of the IV for the skcipher referenced by the cipher handle is returned. This IV size may be zero if the cipher does not need an IV.

Return

    IV size in bytes
</code></pre> 
<p>unsigned int crypto_skcipher_blocksize(struct crypto_skcipher *tfm)<br> obtain block size of cipher</p> 
<pre><code>Parameters

struct crypto_skcipher *tfm
    cipher handle

Description

    The block size for the skcipher referenced with the cipher handle is returned. The caller may use that information to allocate appropriate memory for the data returned by the encryption or decryption operation

Return

    block size of cipher            
</code></pre> 
<p>int crypto_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key, unsigned int keylen)<br> set key for cipher</p> 
<pre><code>Parameters

struct crypto_skcipher *tfm
    cipher handle

const u8 *key
    buffer holding the key

unsigned int keylen
    length of the key in bytes

Description

    The caller provided key is set for the skcipher referenced by the cipher handle.

Note, the key length determines the cipher type. Many block ciphers implement different cipher modes depending on the key size, such as AES-128 vs AES-192 vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128 is performed.

Return

    0 if the setting of the key was successful; &lt; 0 if an error occurred
</code></pre> 
<p>struct crypto_skcipher *crypto_skcipher_reqtfm(struct skcipher_request *req)<br> obtain cipher handle from request</p> 
<pre><code>Parameters

struct skcipher_request *req
    skcipher_request out of which the cipher handle is to be obtained

Description

    Return the crypto_skcipher handle when furnishing an skcipher_request data structure.

Return

    crypto_skcipher handle
</code></pre> 
<p>int crypto_skcipher_encrypt(struct skcipher_request *req)<br> encrypt plaintext</p> 
<pre><code>Parameters

struct skcipher_request *req
    reference to the skcipher_request handle that holds all information needed to perform the cipher operation

Description

    Encrypt plaintext data using the skcipher_request handle. That data structure and how it is filled with data is discussed with the skcipher_request_* functions.

Return

    0 if the cipher operation was successful; &lt; 0 if an error occurred
</code></pre> 
<p>int crypto_skcipher_decrypt(struct skcipher_request *req)<br> decrypt ciphertext</p> 
<pre><code>Parameters

struct skcipher_request *req
    reference to the skcipher_request handle that holds all information needed to perform the cipher operation

Description

    Decrypt ciphertext data using the skcipher_request handle. That data structure and how it is filled with data is discussed with the skcipher_request_* functions.

Return

0 if the cipher operation was successful; &lt; 0 if an error occurred
</code></pre> 
<h2><a id="_330"></a>对称密钥密码请求句柄</h2> 
<p>skcipher_request数据结构包含指向对称密钥密码操作所需数据的所有指针。这包括密码句柄（可由多个skcipher_request实例使用）、指向明文和密文的指针、异步回调函数等。它充当 skcipher_request_* API 调用的句柄，其方式类似于 crypto_skcipher_* API 调用的 skcipher 句柄。</p> 
<p>unsigned int crypto_skcipher_reqsize(struct crypto_skcipher *tfm)</p> 
<p>obtain size of the request data structure</p> 
<pre><code>Parameters

struct crypto_skcipher *tfm
    cipher handle

Return
    number of bytes
</code></pre> 
<p>void skcipher_request_set_tfm(struct skcipher_request *req, struct crypto_skcipher *tfm)</p> 
<p>update cipher handle reference in request</p> 
<pre><code>Parameters

struct skcipher_request *req
    request handle to be modified

struct crypto_skcipher *tfm
    cipher handle that shall be added to the request handle

Description
    Allow the caller to replace the existing skcipher handle in the request data structure with a different one.
</code></pre> 
<p>struct skcipher_request *skcipher_request_alloc(struct crypto_skcipher *tfm, gfp_t gfp)</p> 
<p>allocate request data structure</p> 
<pre><code>Parameters

struct crypto_skcipher *tfm
    cipher handle to be registered with the request

gfp_t gfp
    memory allocation flag that is handed to kmalloc by the API call.

Description
    Allocate the request data structure that must be used with the skcipher encrypt and decrypt API calls. During the allocation, the provided skcipher handle is registered in the request data structure.

Return
    allocated request handle in case of success, or NULL if out of memory
</code></pre> 
<p>void skcipher_request_free(struct skcipher_request *req)</p> 
<p>zeroize and free request data structure</p> 
<pre><code>Parameters

struct skcipher_request *req
    request data structure cipher handle to be freed
</code></pre> 
<p>void skcipher_request_set_callback(struct skcipher_request *req, u32 flags, crypto_completion_t compl, void *data)</p> 
<p>set asynchronous callback function</p> 
<pre><code>Parameters

struct skcipher_request *req
    request handle

u32 flags
    specify zero or an ORing of the flags CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and increase the wait queue beyond the initial maximum size; CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep

crypto_completion_t compl
    callback function pointer to be registered with the request handle

void *data
    The data pointer refers to memory that is not used by the kernel crypto API, but provided to the callback function for it to use. Here, the caller can provide a reference to memory the callback function can operate on. As the callback function is invoked asynchronously to the related functionality, it may need to access data structures of the related functionality which can be referenced using this pointer. The callback function can access the memory via the "data" field in the crypto_async_request data structure provided to the callback function.

Description

This function allows setting the callback function that is triggered once the cipher operation completes.

The callback function is registered with the skcipher_request handle and must comply with the following template:
    void callback_function(struct crypto_async_request *req, int error)
</code></pre> 
<p>void skcipher_request_set_crypt(struct skcipher_request *req, struct scatterlist *src, struct scatterlist *dst, unsigned int cryptlen, void *iv)</p> 
<p>set data buffers</p> 
<pre><code>Parameters

struct skcipher_request *req
    request handle

struct scatterlist *src
    source scatter / gather list

struct scatterlist *dst
    destination scatter / gather list

unsigned int cryptlen
    number of bytes to process from src

void *iv
    IV for the cipher operation which must comply with the IV size defined by crypto_skcipher_ivsize

Description
    This function allows setting of the source data and destination data scatter / gather lists.
    For encryption, the source is treated as the plaintext and the destination is the ciphertext. For a decryption operation, the use is reversed - the source is the ciphertext and the destination is the plaintext.
</code></pre> 
<h2><a id="_API_438"></a>单块密码 API</h2> 
<p>单块密码 API 用于处理类型为 CRYPTO_ALG_TYPE_CIPHER（在 /proc/crypto 中列为 “cipher” 类型）的密码算法。</p> 
<p>通过使用单块密码 API 调用，可以实现基本密码原语的操作。这些密码原语不包括任何块链操作，包括 IV 处理。</p> 
<p>这个单块密码 API 的目的是为了支持模板或其他仅需要逐个块执行密码操作的概念的实现。模板会以块为单位调用底层密码原语，并处理这些密码操作的输入或输出数据之一。</p> 
<p>struct crypto_cipher *crypto_alloc_cipher(const char *alg_name, u32 type, u32 mask)</p> 
<p>allocate single block cipher handle</p> 
<pre><code>Parameters

const char *alg_name
    is the cra_name / name or cra_driver_name / driver name of the single block cipher

u32 type
    specifies the type of the cipher

u32 mask
    specifies the mask for the cipher

Description
    Allocate a cipher handle for a single block cipher. The returned struct crypto_cipher is the cipher handle that is required for any subsequent API invocation for that single block cipher.

Return
    allocated cipher handle in case of success; IS_ERR() is true in case
of an error, PTR_ERR() returns the error code.
</code></pre> 
<p>void crypto_free_cipher(struct crypto_cipher *tfm)</p> 
<p>zeroize and free the single block cipher handle</p> 
<pre><code>Parameters

struct crypto_cipher *tfm
    cipher handle to be freed
</code></pre> 
<p>int crypto_has_cipher(const char *alg_name, u32 type, u32 mask)</p> 
<p>Search for the availability of a single block cipher</p> 
<pre><code>Parameters

const char *alg_name
    is the cra_name / name or cra_driver_name / driver name of the single block cipher

u32 type
    specifies the type of the cipher

u32 mask
    specifies the mask for the cipher

Return
    true when the single block cipher is known to the kernel crypto API;
false otherwise
</code></pre> 
<p>unsigned int crypto_cipher_blocksize(struct crypto_cipher *tfm)</p> 
<p>obtain block size for cipher</p> 
<pre><code>Parameters

struct crypto_cipher *tfm
    cipher handle

Description
    The block size for the single block cipher referenced with the cipher handle tfm is returned. The caller may use that information to allocate appropriate memory for the data returned by the encryption or decryption operation

Return
    block size of cipher
</code></pre> 
<p>int crypto_cipher_setkey(struct crypto_cipher *tfm, const u8 *key, unsigned int keylen)<br> set key for cipher</p> 
<pre><code>Parameters

struct crypto_cipher *tfm
    cipher handle

const u8 *key
    buffer holding the key

unsigned int keylen
    length of the key in bytes

Description
    The caller provided key is set for the single block cipher referenced by the cipher handle.

Note, the key length determines the cipher type. Many block ciphers implement different cipher modes depending on the key size, such as AES-128 vs AES-192 vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128 is performed.

Return
    0 if the setting of the key was successful; &lt; 0 if an error occurred
</code></pre> 
<p>void crypto_cipher_encrypt_one(struct crypto_cipher *tfm, u8 *dst, const u8 *src)</p> 
<p>encrypt one block of plaintext</p> 
<pre><code>Parameters

struct crypto_cipher *tfm
    cipher handle

u8 *dst
    points to the buffer that will be filled with the ciphertext

const u8 *src
    buffer holding the plaintext to be encrypted

Description
    Invoke the encryption operation of one block. The caller must ensure that the plaintext and ciphertext buffers are at least one block in size.
</code></pre> 
<p>void crypto_cipher_decrypt_one(struct crypto_cipher *tfm, u8 *dst, const u8 *src)</p> 
<p>decrypt one block of ciphertext</p> 
<pre><code>Parameters

struct crypto_cipher *tfm
    cipher handle

u8 *dst
    points to the buffer that will be filled with the plaintext

const u8 *src
    buffer holding the ciphertext to be decrypted

Description
    Invoke the decryption operation of one block. The caller must ensure that the plaintext and ciphertext buffers are at least one block in size.
</code></pre> 
<br> ref: https://www.kernel.org/doc/html/latest/crypto/api-skcipher.html
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f4f2dc80944bd67f6a309b6fd3cad89b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Stable diffusion inpaiting】训练自己数据集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3179ab5d9260fe43c2294c6dc27d8ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【头歌实训】kafka-入门篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>