<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UVM自学笔记：项目之四（重难点）——具有AHB二级流水特性的高适用性driver的编写（考虑到hready为低情况） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UVM自学笔记：项目之四（重难点）——具有AHB二级流水特性的高适用性driver的编写（考虑到hready为低情况）" />
<meta property="og:description" content="目录
1. driver写功能编写，为了验证driver的功能我们同时需要完善sequence、sequence_item、env、testcase以及模拟DUT行为的Slave_module
1.1 interface的编写：
1.2 driver写功能编写：
1.2.1 初始main_phase代码：
1.2.2 满足AHB二级流水要求的main_phase代码：
1.2.3. do_drive任务代码：
1.2.4.send_addr_control()/send_wdata()/judge_trans_finished()任务代码
1.2.5.对照波形进行判断
1.3. 模拟slave行为具有发送hready信号功能的module的代码
1.4. seq_item的编写，代码如下：
1.5. seq的编写，代码如下：
1.6. 在testcase中启动seq，给seq配置控制参数具体值
1.7. 在tb_top中将tb与slave_module连接起来，并且产生时钟和复位信号
1.8. 写makefile跑仿真验证写信号时序正确性
1.8.1我们打开VCS看看波形
2.完善driver的读写功能时序
2.1driver的代码部分：
2.1.1 driver中的main_phase阶段代码如下：
2.1.2 get_sim_trans的任务如下，也可以将该task写成方法
2.1.3 do_drive任务代码如下：
2.1.4 do_drive中的send_addr_control任务代码：
2.1.5 do_drive中的send_wdata任务代码：
2.1.6 do_drive中的judge_trans_finished任务代码：
2.2 接下来我们完善模拟DUT行为的Slave的module的编写
2.2.1 Slave中产生hready信号：
2.2.2 Slave中判断一笔trans是否完成：
2.2.3 Slave接受总线上的数据：
​
2.2.4 Slave发送一笔读数据： 2.2.5 其他组件配置：
3. 用makefile编译，VCS仿真查看结果：
1. driver写功能编写，为了验证driver的功能我们同时需要完善sequence、sequence_item、env、testcase以及模拟DUT行为的Slave_module 1.1 interface的编写： interface如下，在driver，monitor和slave_module的clocking_block中声明好各自信号的方向。 1.2 driver写功能编写： 1.2.1 初始main_phase代码： Driver 通过79行代码get到seq传来的req，随后执行do_drive函数将该笔trans传递到总线上，然后调用82行代码完成与seq的握手，之后通过83行代码，来到下一个时钟上升沿，这样做会有以下几个缺点：
（1）首先，#10ns是一个hard code，一旦我们更改了时钟频率，就要到driver中重新修改该值，非常不便利。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/95be6b023a2f068aff67afbbd67b0379/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-09T12:16:16+08:00" />
<meta property="article:modified_time" content="2021-09-09T12:16:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UVM自学笔记：项目之四（重难点）——具有AHB二级流水特性的高适用性driver的编写（考虑到hready为低情况）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20driver%E5%86%99%E5%8A%9F%E8%83%BD%E7%BC%96%E5%86%99%EF%BC%8C%E4%B8%BA%E4%BA%86%E9%AA%8C%E8%AF%81driver%E7%9A%84%E5%8A%9F%E8%83%BD%E6%88%91%E4%BB%AC%E5%90%8C%E6%97%B6%E9%9C%80%E8%A6%81%E5%AE%8C%E5%96%84sequence%E3%80%81sequence_item%E3%80%81env%E3%80%81testcase%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9FDUT%E8%A1%8C%E4%B8%BA%E7%9A%84Slave_module-toc" style="margin-left:0px;"><a href="#1.%20driver%E5%86%99%E5%8A%9F%E8%83%BD%E7%BC%96%E5%86%99%EF%BC%8C%E4%B8%BA%E4%BA%86%E9%AA%8C%E8%AF%81driver%E7%9A%84%E5%8A%9F%E8%83%BD%E6%88%91%E4%BB%AC%E5%90%8C%E6%97%B6%E9%9C%80%E8%A6%81%E5%AE%8C%E5%96%84sequence%E3%80%81sequence_item%E3%80%81env%E3%80%81testcase%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9FDUT%E8%A1%8C%E4%B8%BA%E7%9A%84Slave_module" rel="nofollow">1. driver写功能编写，为了验证driver的功能我们同时需要完善sequence、sequence_item、env、testcase以及模拟DUT行为的Slave_module</a></p> 
<p id="1.1%20interface%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.1%20interface%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%9A" rel="nofollow">1.1 interface的编写：</a></p> 
<p id="1.2%20driver%E5%86%99%E5%8A%9F%E8%83%BD%E7%BC%96%E5%86%99%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.2%20driver%E5%86%99%E5%8A%9F%E8%83%BD%E7%BC%96%E5%86%99%EF%BC%9A" rel="nofollow">1.2 driver写功能编写：</a></p> 
<p id="1.2.1%20%E5%88%9D%E5%A7%8Bmain_phase%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.2.1%20%E5%88%9D%E5%A7%8Bmain_phase%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">1.2.1 初始main_phase代码：</a></p> 
<p id="1.2.2%20%E6%BB%A1%E8%B6%B3AHB%E4%BA%8C%E7%BA%A7%E6%B5%81%E6%B0%B4%E8%A6%81%E6%B1%82%E7%9A%84main_phase%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.2.2%20%E6%BB%A1%E8%B6%B3AHB%E4%BA%8C%E7%BA%A7%E6%B5%81%E6%B0%B4%E8%A6%81%E6%B1%82%E7%9A%84main_phase%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">1.2.2 满足AHB二级流水要求的main_phase代码：</a></p> 
<p id="1.2.3.%20do_drive%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.2.3.%20do_drive%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">1.2.3. do_drive任务代码：</a></p> 
<p id="1.2.4.send_addr_control()%2Fsend_wdata()%2Fjudge_trans_finished()%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#1.2.4.send_addr_control%28%29%2Fsend_wdata%28%29%2Fjudge_trans_finished%28%29%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81" rel="nofollow">1.2.4.send_addr_control()/send_wdata()/judge_trans_finished()任务代码</a></p> 
<p id="1.2.5.%E5%AF%B9%E7%85%A7%E6%B3%A2%E5%BD%A2%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD-toc" style="margin-left:80px;"><a href="#1.2.5.%E5%AF%B9%E7%85%A7%E6%B3%A2%E5%BD%A2%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD" rel="nofollow">1.2.5.对照波形进行判断</a></p> 
<p id="1.3.%20%E6%A8%A1%E6%8B%9Fslave%E8%A1%8C%E4%B8%BA%E5%85%B7%E6%9C%89%E5%8F%91%E9%80%81hready%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD%E7%9A%84module%E7%9A%84%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#1.3.%20%E6%A8%A1%E6%8B%9Fslave%E8%A1%8C%E4%B8%BA%E5%85%B7%E6%9C%89%E5%8F%91%E9%80%81hready%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD%E7%9A%84module%E7%9A%84%E4%BB%A3%E7%A0%81" rel="nofollow">1.3. 模拟slave行为具有发送hready信号功能的module的代码</a></p> 
<p id="1.4.%20seq_item%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.4.%20seq_item%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">1.4. seq_item的编写，代码如下：</a></p> 
<p id="1.5.%20seq%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.5.%20seq%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">1.5. seq的编写，代码如下：</a></p> 
<p id="1.6.%20%E5%9C%A8testcase%E4%B8%AD%E5%90%AF%E5%8A%A8seq%EF%BC%8C%E7%BB%99seq%E9%85%8D%E7%BD%AE%E6%8E%A7%E5%88%B6%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E5%80%BC-toc" style="margin-left:40px;"><a href="#1.6.%20%E5%9C%A8testcase%E4%B8%AD%E5%90%AF%E5%8A%A8seq%EF%BC%8C%E7%BB%99seq%E9%85%8D%E7%BD%AE%E6%8E%A7%E5%88%B6%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E5%80%BC" rel="nofollow">1.6. 在testcase中启动seq，给seq配置控制参数具体值</a></p> 
<p id="1.7.%20%E5%9C%A8tb_top%E4%B8%AD%E5%B0%86tb%E4%B8%8Eslave_module%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BA%A7%E7%94%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#1.7.%20%E5%9C%A8tb_top%E4%B8%AD%E5%B0%86tb%E4%B8%8Eslave_module%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BA%A7%E7%94%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7" rel="nofollow">1.7. 在tb_top中将tb与slave_module连接起来，并且产生时钟和复位信号</a></p> 
<p id="1.8.%20%E5%86%99makefile%E8%B7%91%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%E5%86%99%E4%BF%A1%E5%8F%B7%E6%97%B6%E5%BA%8F%E6%AD%A3%E7%A1%AE%E6%80%A7-toc" style="margin-left:40px;"><a href="#1.8.%20%E5%86%99makefile%E8%B7%91%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%E5%86%99%E4%BF%A1%E5%8F%B7%E6%97%B6%E5%BA%8F%E6%AD%A3%E7%A1%AE%E6%80%A7" rel="nofollow">1.8. 写makefile跑仿真验证写信号时序正确性</a></p> 
<p id="1.8.1%E6%88%91%E4%BB%AC%E6%89%93%E5%BC%80VCS%E7%9C%8B%E7%9C%8B%E6%B3%A2%E5%BD%A2-toc" style="margin-left:80px;"><a href="#1.8.1%E6%88%91%E4%BB%AC%E6%89%93%E5%BC%80VCS%E7%9C%8B%E7%9C%8B%E6%B3%A2%E5%BD%A2" rel="nofollow">1.8.1我们打开VCS看看波形</a></p> 
<p id="2.%E5%AE%8C%E5%96%84driver%E7%9A%84%E8%AF%BB%E5%86%99%E5%8A%9F%E8%83%BD%E6%97%B6%E5%BA%8F-toc" style="margin-left:0px;"><a href="#2.%E5%AE%8C%E5%96%84driver%E7%9A%84%E8%AF%BB%E5%86%99%E5%8A%9F%E8%83%BD%E6%97%B6%E5%BA%8F" rel="nofollow">2.完善driver的读写功能时序</a></p> 
<p id="2.1driver%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.1driver%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%EF%BC%9A" rel="nofollow">2.1driver的代码部分：</a></p> 
<p id="2.1.1%20driver%E4%B8%AD%E7%9A%84main_phase%E9%98%B6%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.1.1%20driver%E4%B8%AD%E7%9A%84main_phase%E9%98%B6%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">2.1.1 driver中的main_phase阶段代码如下：</a></p> 
<p id="%C2%A02.1.2%20get_sim_trans%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%B8%8B%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%86%E8%AF%A5task%E5%86%99%E6%88%90%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A02.1.2%20get_sim_trans%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%B8%8B%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%86%E8%AF%A5task%E5%86%99%E6%88%90%E6%96%B9%E6%B3%95" rel="nofollow"> 2.1.2 get_sim_trans的任务如下，也可以将该task写成方法</a></p> 
<p id="%C2%A02.1.3%20do_drive%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A02.1.3%20do_drive%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow"> 2.1.3 do_drive任务代码如下：</a></p> 
<p id="%C2%A02.1.4%20do_drive%E4%B8%AD%E7%9A%84send_addr_control%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A02.1.4%20do_drive%E4%B8%AD%E7%9A%84send_addr_control%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow"> 2.1.4 do_drive中的send_addr_control任务代码：</a></p> 
<p id="%C2%A02.1.5%20do_drive%E4%B8%AD%E7%9A%84send_wdata%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A02.1.5%20do_drive%E4%B8%AD%E7%9A%84send_wdata%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow"> 2.1.5 do_drive中的send_wdata任务代码：</a></p> 
<p id="%C2%A02.1.6%20do_drive%E4%B8%AD%E7%9A%84judge_trans_finished%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A02.1.6%20do_drive%E4%B8%AD%E7%9A%84judge_trans_finished%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow"> 2.1.6 do_drive中的judge_trans_finished任务代码：</a></p> 
<p id="2.2%C2%A0%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%AE%8C%E5%96%84%E6%A8%A1%E6%8B%9FDUT%E8%A1%8C%E4%B8%BA%E7%9A%84Slave%E7%9A%84module%E7%9A%84%E7%BC%96%E5%86%99-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%AE%8C%E5%96%84%E6%A8%A1%E6%8B%9FDUT%E8%A1%8C%E4%B8%BA%E7%9A%84Slave%E7%9A%84module%E7%9A%84%E7%BC%96%E5%86%99" rel="nofollow">2.2 接下来我们完善模拟DUT行为的Slave的module的编写</a></p> 
<p id="2.2.1%20Slave%E4%B8%AD%E4%BA%A7%E7%94%9Fhready%E4%BF%A1%E5%8F%B7%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.2.1%20Slave%E4%B8%AD%E4%BA%A7%E7%94%9Fhready%E4%BF%A1%E5%8F%B7%EF%BC%9A" rel="nofollow">2.2.1 Slave中产生hready信号：</a></p> 
<p id="2.2.2%20Slave%E4%B8%AD%E5%88%A4%E6%96%AD%E4%B8%80%E7%AC%94trans%E6%98%AF%E5%90%A6%E5%AE%8C%E6%88%90%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.2.2%20Slave%E4%B8%AD%E5%88%A4%E6%96%AD%E4%B8%80%E7%AC%94trans%E6%98%AF%E5%90%A6%E5%AE%8C%E6%88%90%EF%BC%9A" rel="nofollow">2.2.2 Slave中判断一笔trans是否完成：</a></p> 
<p id="%C2%A02.2.3%20Slave%E6%8E%A5%E5%8F%97%E6%80%BB%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A02.2.3%20Slave%E6%8E%A5%E5%8F%97%E6%80%BB%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A" rel="nofollow"> 2.2.3 Slave接受总线上的数据：</a></p> 
<p id="%E2%80%8B-toc" style="margin-left:80px;"><a href="#%E2%80%8B" rel="nofollow">​</a></p> 
<p id="%C2%A02.2.4%20Slave%E5%8F%91%E9%80%81%E4%B8%80%E7%AC%94%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A02.2.4%20Slave%E5%8F%91%E9%80%81%E4%B8%80%E7%AC%94%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%9A%C2%A0" rel="nofollow"> 2.2.4 Slave发送一笔读数据： </a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%C2%A02.2.5%20%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%E9%85%8D%E7%BD%AE%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A02.2.5%20%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%E9%85%8D%E7%BD%AE%EF%BC%9A" rel="nofollow"> 2.2.5 其他组件配置：</a></p> 
<p id="3.%C2%A0%E7%94%A8makefile%E7%BC%96%E8%AF%91%EF%BC%8CVCS%E4%BB%BF%E7%9C%9F%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C%EF%BC%9A-toc" style="margin-left:0px;"><a href="#3.%C2%A0%E7%94%A8makefile%E7%BC%96%E8%AF%91%EF%BC%8CVCS%E4%BB%BF%E7%9C%9F%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C%EF%BC%9A" rel="nofollow">3. 用makefile编译，VCS仿真查看结果：</a></p> 
<hr id="hr-toc"> 
<h2 id="1.%20driver%E5%86%99%E5%8A%9F%E8%83%BD%E7%BC%96%E5%86%99%EF%BC%8C%E4%B8%BA%E4%BA%86%E9%AA%8C%E8%AF%81driver%E7%9A%84%E5%8A%9F%E8%83%BD%E6%88%91%E4%BB%AC%E5%90%8C%E6%97%B6%E9%9C%80%E8%A6%81%E5%AE%8C%E5%96%84sequence%E3%80%81sequence_item%E3%80%81env%E3%80%81testcase%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9FDUT%E8%A1%8C%E4%B8%BA%E7%9A%84Slave_module" style="margin-left:0px;text-align:justify;"><span style="color:#000000;"><strong>1. driver</strong><strong>写功能编写，为了验证driver的功能我们同时需要完善</strong><strong>sequence</strong><strong>、</strong><strong>sequence_item</strong><strong>、</strong><strong>env</strong><strong>、</strong><strong>testcase</strong><strong>以及模拟</strong><strong>DUT</strong><strong>行为的</strong><strong>Slave_module</strong></span></h2> 
<h3 id="1.1%20interface%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%9A" style="margin-left:0px;text-align:justify;"><span style="color:#000000;"><strong>1.1 interface</strong><strong>的编写</strong>：</span></h3> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">interface如下，在driver，monitor和slave_module的clocking_block中声明好各自信号的方向。</span> <img alt="" src="https://images2.imgbox.com/20/af/oVQ2WY2b_o.png"></p> 
<p></p> 
<h3 id="1.2%20driver%E5%86%99%E5%8A%9F%E8%83%BD%E7%BC%96%E5%86%99%EF%BC%9A"><span style="color:#000000;"><strong>1.2 driver写功能编写</strong>：</span></h3> 
<h4 id="1.2.1%20%E5%88%9D%E5%A7%8Bmain_phase%E4%BB%A3%E7%A0%81%EF%BC%9A" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.2.1 初始main_phase代码：</span></strong></h4> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/9b/9f/tnbEckjS_o.jpg"></span></p> 
<p> <span style="color:#000000;">Driver 通过79行代码get到seq传来的req，随后执行do_drive函数将该笔trans传递到总线上，然后调用82行代码完成与seq的握手，之后通过83行代码，来到下一个时钟上升沿，<span style="background-color:#ffff00;">这样做会有以下几个缺点</span>：</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（1）首先，#10ns是一个hard code，一旦我们更改了时钟频率，就要到driver中重新修改该值，非常不便利。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（2）其次，seq中每产生一笔数据就会通过79行的握手被driver给get到，然后执行push到总线上的操作。但是ahb是二级流水，产生的req内既有地址和控制信号，又有数据信号，数据信号总是滞后于地址信号一个时钟周期被发送到总线上，直接将所有信号push到总线上显然是不满足二级流水的时序要求，并且当hready为低时可能会丢掉hready为低时候的信号。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（3）最后，假设我们将产生10笔trans，当执行其中一笔trans时，此时hready为低，do_drive函数不能将当前的trans push到总线上，随后调用82行的代码，让seq产生下一笔trans，那么就会丢掉hready为低时候的trans，并且让总的trans数目不满足10笔。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="background-color:#ffff00;">解决问题的方法如下</span>：</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（1）问题一：我们将#10ns修改为@vif.drvCLK</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（1）问题二：我们应该设法在driver中加入队列，队列里面按照顺序存放着由seq产生的每一笔trans，然后driver从该队列中按照先入先出的顺序取出数据，并将数据发送到总线上，这样既能保证二级流水，又不会丢失每一笔trans。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（2）问题三：我们让driver从seqr中get到trans的操作与driver将该笔数据按照时序发送到总线上的操作分开。<span style="background-color:#ffd900;">在main_phase中开启两个并发线程，其中一个线程负责不断地通过seq与drv的握手从seq中获取trans并放入drv的队列中等待处理，而另一个线程负责将drv队列中的trans转换成pin级的信号按照AHB二级流水的时序要求发送到总线上。</span></span></p> 
<h4 id="1.2.2%20%E6%BB%A1%E8%B6%B3AHB%E4%BA%8C%E7%BA%A7%E6%B5%81%E6%B0%B4%E8%A6%81%E6%B1%82%E7%9A%84main_phase%E4%BB%A3%E7%A0%81%EF%BC%9A" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.2.2 满足AHB二级流水要求的main_phase代码：</span></strong></h4> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/18/c9/8bjXb0dQ_o.jpg"></p> 
<p> <span style="color:#000000;">（1）首先，我们在main_phase中启动了两个forever的并发线程，<span style="background-color:#ffd900;">其中一个负责通过95行方法:get_sim_trans，从seq中get到其产生的数据。并且将该数据放入到队列中等待处理。</span>队列包含存放地址的队列sim_addr_q[$]，以及存放控制信号或者写数据信号的其他队列。我们通过第92行的判断条件，保证了当队列中的待处理trans数目少于2个时候，就让seq产生数据，否则就无需让seq产生数据，这样可以避免在hready为低的时候，队列中未处理的数据数目越来越多，而占用大量内存空间。又可以保证在所有trans结束之前，sim_addr_q中都有至少一笔trans交给drive的do_drive函数去处理而不会出现丢数据或者数据断层的情况。</span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p><span style="color:#000000;">（2）其次，<span style="background-color:#ffd900;">我们通过第二个线程第105行的任务do_drive，将trans中的每一笔信号按照时序要求发送到总线上</span>。</span></p> 
<h4 id="1.2.3.%20do_drive%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A" style="margin-left:0px;text-align:justify;"><span style="color:#000000;"><strong>1.2.3. do_drive任务代码：</strong></span></h4> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">首先我们来对照ahb的时序波形：</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/b9/d6/kfv395tb_o.jpg"></span></p> 
<p> <span style="color:#000000;">我们需要将该波形抽象成具体的代码，为了满足二级流水特性，地址和控制信号的相位总是提前于数据相位，并且driver需要知道什么时候可以发送下一笔trans。为了简化设计，我们先只考虑写数据的情况，代码如下：</span></p> 
<p style="text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/7c/67/JxOaJlFv_o.jpg"></span></p> 
<p><span style="background-color:#ffd900;"> </span><span style="color:#000000;"><span style="background-color:#ffd900;">采用三个并发线程：其中send_addr_control()负责发送地址和控制信号，send_wdata()负责发送写数据信号，而judge_trans_finished()负责判断当前的trans是否有完成</span>。需要进行如下控制：</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">1）其中数据相位总是滞后于地址相位，所以我在send_addr_control中增加一个信号，当该线程执行完毕后，把信号拉高，而send_wdata则等待该信号为高时才执行，而拉高的信号只有到下个时钟上升沿才会被感知到，因此完成了时序上的数据相位滞后于地址相位一个时钟周期，在send_wdata执行完以后，再将该信号拉低。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">2）三个线程的执行顺序通过握手信号实现。让judge_ready线程最先执行，然后让send_wdata()线程执行，最后让send_addr_control执行</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">3）这样写还有一个优点：就是三个线程前可以通过#延时来控制具体每个信号前的延时时间。</span></p> 
<h4 id="1.2.4.send_addr_control()%2Fsend_wdata()%2Fjudge_trans_finished()%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81" style="margin-left:0px;text-align:justify;"><span style="color:#000000;"><strong>1.2.4.send_addr_control()/send_wdata()/judge_trans_finished()任务代码</strong></span></h4> 
<p style="text-align:justify;"><strong><span style="color:#000000;">1.地址和控制信号的发送任务：send_addr_control</span></strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/ed/c2/xcksRP70_o.jpg"></span></p> 
<p><span style="color:#000000;">这里我们采用了一个队列addr_q用于存放从sim_addr_q中get到的地址信号，并且让该队列中<span style="background-color:#ffd900;">最大只能有两笔未完成的trans</span>，当判断完成一笔trans时，则将该trans从addr_q中pop出来，对于地址信号，只要addr_q队列中未完成的信号少于两个，我们就可以一直发送信号到总线上，否则不能发送新trans而应该对未完成的旧trans再发送一次。<span style="background-color:#ffd900;">当发送完地址信号后，将haddr_send_ready信号拉高，这样数据信号才被授权发送。</span></span></p> 
<p style="text-align:justify;"><strong><span style="color:#000000;">2.写数据信号的发送任务：send_wdata()</span></strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/13/d7/z7mG0H4n_o.jpg"></p> 
<p><span style="color:#000000;">得到了addr发送完毕的授权：haddr_send_ready&gt;0以后，我们将数据信号从sim_wdata_q队列中get到，然后push到总线上，并push进入wdata_q队列中。该队列仅允许有一笔未完成的trans，当该trans完成时，则将该trans从wdata_q中pop出来，当该trans未完成时，我们应该将未完成的trans继续push到总线上。完成一笔读数据信号发送后，将haddr_send_ready拉低。</span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">3.判断一笔trans是否完成的任务（只考虑写操作）：judge_trans_finished()</span></strong></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/ff/b2/6IebTO1g_o.jpg"></span></p> 
<p> <span style="color:#000000;">该任务负责判断总线上该时钟沿是否有一笔trans完成，当hready为高且wdata_q中有一笔写数据时表示有一笔trans将会在这个时钟沿完成，将完成的trans从对应的队列中pop出去。</span></p> 
<h4 id="1.2.5.%E5%AF%B9%E7%85%A7%E6%B3%A2%E5%BD%A2%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.2.5.对照波形进行判断</span></strong></h4> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/7e/5d/SUCOBDHz_o.jpg"></span></p> 
<p> 1.<span style="color:#000000;">在t0时刻，judge线程判断没有trans完成，执行发送旧trans操作（x）；data_send线程判断不发数据，执行发送旧trans操作（x）；addr_send线程判断发数据A到总线上，并将数据push进入addr_q中，将addr_send_ready信号拉高；</span></p> 
<p style="text-align:justify;"><span style="color:#000000;">2.在t1时刻，judge线程判断没有trans完成，执行空操作；data_send线程判断addr_send_ready信号为高，并且addr_q中没有待完成的trans，执行发送A写数据，并将addr_send_ready拉低，将Apush进入wdata_q中；addr_send线程执行发送B地址数据，将addr_send_ready拉高，addr_q中有两个trans：A和B；</span></p> 
<p style="text-align:justify;"><span style="color:#000000;">3.在t2时刻，judge线程判断有trans完成，执行将addr_q和wdata_q的第一笔trans:A pop出来，完成该trans；datas_send线程判断执行，发送数据B；addr_send线程执行发动数据C</span></p> 
<p style="text-align:justify;"><span style="color:#000000;">4.在t3时刻，judge线程发现hready为低，执行发送旧数据操作（C）；data_send线程发现wdata_q中有一笔未完成的wdata信号，执行发送旧数据操作（B）；addr_send线程发现addr_q中有2笔未完成的trans，执行空操作；</span></p> 
<p style="text-align:justify;"><span style="color:#000000;">5.在t4时刻，judge线程判断有trans完成，完成该trans（B）；data_send线程判断可以发数据，发送数据C；addr_send线程判断sim_addr_q为空，不执行空操作；</span></p> 
<p style="text-align:justify;"><span style="color:#000000;">6.在t5时刻，judge线程判断有trans完成，完成该trans(C)；由于addr_send_ready为低，data_send线程判断不能发数据；并且addr_send线程不发送地址。</span></p> 
<p></p> 
<h3 id="1.3.%20%E6%A8%A1%E6%8B%9Fslave%E8%A1%8C%E4%B8%BA%E5%85%B7%E6%9C%89%E5%8F%91%E9%80%81hready%E4%BF%A1%E5%8F%B7%E5%8A%9F%E8%83%BD%E7%9A%84module%E7%9A%84%E4%BB%A3%E7%A0%81" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.3. 模拟slave行为具有发送hready信号功能的module的代码</span></strong></h3> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">当driver中有关写功能都验证完毕后，我们试着写一个slave的module，能够模拟slave产生hready_resp信号，并以此来验证driver写的是否有问题。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">Module的代码如下：</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" height="345" src="https://images2.imgbox.com/08/19/mUhL6Ht7_o.jpg" width="632"></span></p> 
<p></p> 
<p></p> 
<h3 id="1.4.%20seq_item%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.4. seq_item的编写，代码如下：</span></strong></h3> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0px;text-align:center;"> <img alt="" src="https://images2.imgbox.com/8b/cc/2KKgx3Qq_o.jpg"></p> 
<p> <span style="color:#000000;">在seq_item中，我们将各个信号包在其中，并且产生一个<span style="background-color:#ffd900;">静态变量count</span>，在new函数中，每新产生一笔trans，count的值就会加1，<span style="background-color:#ffd900;">用来对每一笔trans打印一个trans_id标签</span>，之后我们让每个信号类型是rand型的，利用contraint函数为其随机化设置范围，我们在<span style="background-color:#ffd900;">检验driver功能的时候，让地址信号为trans_id*10，写数据信号为trans_id*100</span>。之后我们利用automatic_field给每个信号开启copy clone print等功能。</span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="1.5.%20seq%E7%9A%84%E7%BC%96%E5%86%99%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.5. seq的编写，代码如下：</span></strong></h3> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/c9/7f/pxSU68DE_o.jpg"></span></p> 
<p> <span style="color:#000000;">在body函数中采用手动的方式启动这个seq，<span style="background-color:#ffd900;">通过start_item和finish_item实现与driver的握手</span>。并且在两者之间对seq_item进行randomize。<span style="background-color:#ffd900;">Seq中有一个信号trans_num，是用来控制一共产生多少笔trans的，在tb中通过config db机制配置给seqr，在seq中通过config机制和m_sequencer句柄get到该控制参数</span>。</span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="1.6.%20%E5%9C%A8testcase%E4%B8%AD%E5%90%AF%E5%8A%A8seq%EF%BC%8C%E7%BB%99seq%E9%85%8D%E7%BD%AE%E6%8E%A7%E5%88%B6%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E5%80%BC" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.6. 在testcase中启动seq，给seq配置控制参数具体值</span></strong></h3> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/2f/eb/p9wugQuM_o.jpg"></span></p> 
<p> <span style="color:#000000;">在main_phase阶段通过start函数在固定seqr上启动该seq，注意raise_objection和drop_objection</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">#1000ns是为了让最后的几笔trans能够完成。</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/a5/0d/7qo1w265_o.jpg"></span></p> 
<p> <span style="color:#000000;">给<span style="background-color:#ffd900;">seq配置trans_num的值为30，共产生30笔trans</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="1.7.%20%E5%9C%A8tb_top%E4%B8%AD%E5%B0%86tb%E4%B8%8Eslave_module%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BA%A7%E7%94%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.7. 在tb_top中将tb与slave_module连接起来，并且产生时钟和复位信号</span></strong></h3> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/86/fa/4AKPuaHk_o.jpg"></span></p> 
<p></p> 
<h3 id="1.8.%20%E5%86%99makefile%E8%B7%91%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%E5%86%99%E4%BF%A1%E5%8F%B7%E6%97%B6%E5%BA%8F%E6%AD%A3%E7%A1%AE%E6%80%A7" style="margin-left:0px;text-align:justify;"><strong><span style="color:#000000;">1.8. 写makefile跑仿真验证写信号时序正确性</span></strong></h3> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">Makefile如下，我们跑几个不同的seed</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/f9/47/TeiyIw07_o.jpg"></span></p> 
<p> <span style="color:#000000;">成功跑通了30笔trans：</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/79/00/VngkFwjx_o.jpg"></p> 
<p> <span style="color:#000000;">打印的log文件如下：</span><img alt="" src="https://images2.imgbox.com/fe/27/PYzGDzsX_o.jpg"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e5/0c/Gt2l6iQO_o.jpg"></p> 
<p></p> 
<h4 id="1.8.1%E6%88%91%E4%BB%AC%E6%89%93%E5%BC%80VCS%E7%9C%8B%E7%9C%8B%E6%B3%A2%E5%BD%A2"><strong><span style="color:#000000;">1.8.1我们打开VCS看看波形</span></strong></h4> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/ac/d2/wSE9zsqw_o.jpg"></span></p> 
<p> <span style="color:#000000;">一共30笔trans，trans完成的时间和log文件完全对应的上</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">我们将seed换成2，trans数目换成50再试试看：</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/a1/af/QQAL1NyC_o.jpg"></span></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/85/78/jOu41XSQ_o.jpg"></p> 
<p> <span style="color:#000000;">结果一目了然，完全符合预期。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="background-color:#ffd900;">至此，我们完成了driver的写操作的时序设计。接下来，我们将完善driver的读操作的设计</span>。</span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h2 id="2.%E5%AE%8C%E5%96%84driver%E7%9A%84%E8%AF%BB%E5%86%99%E5%8A%9F%E8%83%BD%E6%97%B6%E5%BA%8F" style="margin-left:0px;text-align:justify;"><span style="color:#000000;"><strong>2.完善driver的读写功能时序</strong></span></h2> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">这部分我们重点把<span style="background-color:#ffd900;">driver中读写功能以及模拟DUT行为的slave module的读写功能全部完善，保证读写时不会出现任何的时序上的错误与丢数据情况，让driver的复用性提高</span></span></p> 
<h3 id="2.1driver%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%EF%BC%9A" style="margin-left:0px;text-align:justify;"><span style="color:#000000;"><strong>2.1driver</strong><strong>的代码部分：</strong></span></h3> 
<h4 id="2.1.1%20driver%E4%B8%AD%E7%9A%84main_phase%E9%98%B6%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A" style="margin-left:0px;text-align:left;"><span style="color:#000000;"><strong>2.1.1 driver中的main_phase</strong><strong>阶段代码如下</strong>：</span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">在main_phase中启动了两个并发线程，第一个forever进程负责不断地get从sequence产生的数据，为了不让sequence中产生的数据在仿真的0ns就全部传入driver的内部Queue中，我们通过sim_addr_q.size()进行判断，一旦driver中该Queue中没有足够的数据可发，我们便让driver通过seq_item_port.get_next_item语句从seuqnce中拿到数据，如果drv中的queue中的trans足够用，那么我们在该时钟沿处则不get数据。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">第二个线程driver则将get到的trans通过do_drive这个任务按照ahb的二级流水的时序要求发送到总线上，<span style="background-color:#ffd900;">同时，我们将hselx信号也引入，因为hselx信号来源于decoder，我们按照组合逻辑的方式驱动该信号即可，不用在每个时钟的上升沿处。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/94/bb/X9URVECh_o.jpg"></span></p> 
<h4 id="%C2%A02.1.2%20get_sim_trans%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%B8%8B%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%86%E8%AF%A5task%E5%86%99%E6%88%90%E6%96%B9%E6%B3%95"> <span style="color:#000000;"><strong>2.1.2</strong> <strong>get_sim_trans</strong><strong>的任务如下，也可以将该task</strong><strong>写成方法</strong></span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">从seq中get到的seq_item将其拆解成信号级，并将每个信号放入一个固定的sim_*_q的queue内。</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/1e/f4/JVk2b7A4_o.jpg"></span></p> 
<h4 id="%C2%A02.1.3%20do_drive%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"> <span style="color:#000000;"><strong>2.1.3 do_drive任务代码如下：</strong></span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">在每一个时钟的上升沿，三个线程的执行<span style="background-color:#ffd900;">顺序如下：judge线程 -&gt; send_wdata线程 -&gt; send_addr_control线程。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">send_addr_control线程负责发送地址和控制信号；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">Send_wdata线程负责发送写数据信号；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">Judge线程负责判断该时刻是否有trans完成，并决定后续的trans是否应该发送；</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/e4/87/4PwL83xo_o.jpg"></p> 
<h4 id="%C2%A02.1.4%20do_drive%E4%B8%AD%E7%9A%84send_addr_control%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A"> <span style="color:#000000;"><strong>2.1.4 do_drive中的send_addr_control</strong><strong>任务代码：</strong></span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">Ahb二级流水最多允许只有两笔未完成的trans，因此让addr_q.size&lt;2时，可以向总线上push数据，每向总线上push一笔trans，addr_q.size+1。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">Haddr_send_ready用于通知线程send_wdata发送数据，因为二级流水，数据相位总是滞后于地址相位周期，只有地址相位发完了数据，数据相位才可以发送。</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/2c/38/j6KtFV0O_o.jpg"></span></p> 
<h4 id="%C2%A02.1.5%20do_drive%E4%B8%AD%E7%9A%84send_wdata%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A"> <span style="color:#000000;"><strong>2.1.5</strong> <strong>do_drive</strong><strong>中的send_wdata</strong><strong>任务代码：</strong></span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">因为seq产生的每一笔trans中都有写数据，然而当hwrite为低时，我们进行读操作，不希望有这笔写数据被放进待完成处理的queue中，因此用hwrite信号进行控制，<span style="background-color:#ffd900;">当发现这笔trans是读操作时，我们将trans中的写数据删掉</span>。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">如果当前trans是写操作，当这笔trans的地址发送完毕后，我们在下个时钟沿将写数据发送出去，并等待hready为高时，将其处理掉。</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/0f/f2/Hq4kuAH0_o.jpg"></span></p> 
<h4 id="%C2%A02.1.6%20do_drive%E4%B8%AD%E7%9A%84judge_trans_finished%E4%BB%BB%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%9A"> <span style="color:#000000;"><strong>2.1.6</strong> <strong>do_drive</strong><strong>中的judge_trans_finished</strong><strong>任务代码：</strong></span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">区分读操作还是写操作，如果hready为高时，完成了一笔trans，我们需要将其从对应的queue中pop出来，这样addr的queue才能继续接受sim_addr_queue中待处理的trans，wdata的queue也才能接受待处理的wdata，并发送到总线上。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">Hready为低，不能完成当前trans，则不应该将该笔trans从queue中pop出来，在下个时钟沿继续处理该trans。</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/d8/32/gIzk7UTC_o.jpg"></span></p> 
<p></p> 
<h3 id="2.2%C2%A0%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%AE%8C%E5%96%84%E6%A8%A1%E6%8B%9FDUT%E8%A1%8C%E4%B8%BA%E7%9A%84Slave%E7%9A%84module%E7%9A%84%E7%BC%96%E5%86%99" style="margin-left:0px;text-align:left;"><span style="color:#000000;"><strong>2.2 </strong><strong>接下来我们完善模拟DUT</strong><strong>行为的Slave</strong><strong>的module</strong><strong>的编写</strong></span></h3> 
<p style="margin-left:0;text-align:left;">Slave在每个时钟的上升沿先判断一笔trans有没有完成，如果没完成，则不从总线上get数据。如果完成了一笔trans，就将从总线上get到的数据从queue中pop出去，然后从总线上get到一笔新trans，之后根据自己产生的ready信号和当前trans的hwrite信号判断下个时钟上升沿要不要发送rdata信号。</p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">Slave的具体代码如下：</span></p> 
<p style="margin-left:0px;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/32/52/DRSdjyTR_o.jpg"></span><img alt="" src="https://images2.imgbox.com/01/9d/BF9o5w68_o.jpg"></p> 
<p> <span style="color:#000000;">当slex信号选中该slave时，执行操作，否则什么也不做。</span></p> 
<h4 id="2.2.1%20Slave%E4%B8%AD%E4%BA%A7%E7%94%9Fhready%E4%BF%A1%E5%8F%B7%EF%BC%9A" style="margin-left:0px;text-align:left;"><span style="color:#000000;"><strong>2.2.1 Slave中产生hready</strong><strong>信号</strong>：</span></h4> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/b6/7b/JrGEB9me_o.jpg"></span></p> 
<h4 id="2.2.2%20Slave%E4%B8%AD%E5%88%A4%E6%96%AD%E4%B8%80%E7%AC%94trans%E6%98%AF%E5%90%A6%E5%AE%8C%E6%88%90%EF%BC%9A"><span style="color:#000000;"><strong>2.2.2 Slave中判断一笔trans</strong><strong>是否完成：</strong></span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">采用与driver类似方法判断一笔trans是否完成</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/f6/c8/1tak9S60_o.jpg"></span></p> 
<h4 id="%C2%A02.2.3%20Slave%E6%8E%A5%E5%8F%97%E6%80%BB%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A"> <span style="color:#000000;"><strong>2.2.3 Slave接受总线上的数据：</strong></span></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">当满足条件时，从总线上接受数据，如果发现一笔trans是读数据，将其记录下来，在执行这笔trans时，我们要发送读信号。每发现一笔读操作，就通过send_rdata_msg记录下来。</span></p> 
<h4 id="%E2%80%8B" style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/cd/7f/wYGpjPTG_o.jpg"></span></h4> 
<h4 id="%C2%A02.2.4%20Slave%E5%8F%91%E9%80%81%E4%B8%80%E7%AC%94%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%9A%C2%A0" style="margin-left:0px;"> <span style="color:#000000;"><strong>2.2.4 Slave发送一笔读数据：</strong></span> </h4> 
<p><span style="color:#000000;">为了简化操作，这里通过urandom随机发送读数据信号</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/74/13/krEwjmDP_o.jpg"></p> 
<h3></h3> 
<h4 id="%C2%A02.2.5%20%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%E9%85%8D%E7%BD%AE%EF%BC%9A"><strong> <span style="color:#000000;">2.2.5 其他组件配置：</span></strong></h4> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">在seq_item中，将hwrite的随机化范围控制在0或者1：</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/4f/68/sSD9sLfJ_o.jpg"></span></p> 
<p> <span style="color:#000000;">在testcase中启动20笔trans：</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/6c/bb/9AQatnKp_o.jpg"></span></p> 
<p> <span style="color:#000000;"><span style="background-color:#ffff00;">至此，完成了slave module</span><span style="background-color:#ffff00;">代码编写；</span></span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h2 id="3.%C2%A0%E7%94%A8makefile%E7%BC%96%E8%AF%91%EF%BC%8CVCS%E4%BB%BF%E7%9C%9F%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C%EF%BC%9A" style="margin-left:0px;text-align:left;"><span style="color:#000000;"><strong><span style="background-color:#ffff00;">3. </span></strong><strong><span style="background-color:#ffff00;">用</span><span style="background-color:#ffff00;">makefile</span></strong><strong><span style="background-color:#ffff00;">编译，</span><span style="background-color:#ffff00;">VCS</span></strong><strong><span style="background-color:#ffff00;">仿真查看结果：</span></strong></span></h2> 
<p></p> 
<p style="margin-left:0;text-align:left;">下面我们就不断地变更seed，并且使用VCS用makefile自动化编译仿真，查看log文件并用VCS查看波形：</p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/35/00/iUxlNC1r_o.jpg"></p> 
<p> <span style="color:#000000;">结果：一共产生了20笔trans都被drv成功地get到了，并且有7笔写操作和13笔读操作。</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/9d/aa/dOcMgHwm_o.jpg"></p> 
<p> <span style="color:#000000;"><span style="background-color:#ffff00;">打印的log</span><span style="background-color:#ffff00;">信息如下</span><span style="background-color:#ffff00;">:</span></span></p> 
<p><span style="color:#000000;"><span style="background-color:#ffff00;"><img alt="" src="https://images2.imgbox.com/e4/fc/4Fbw4y8m_o.jpg"></span></span><img alt="" src="https://images2.imgbox.com/28/bc/UY6vaKv1_o.jpg"></p> 
<p> <span style="color:#000000;"><span style="background-color:#ffff00;">波形如下：</span></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/c4/QQqpDd2K_o.jpg"></p> 
<p> <span style="color:#000000;"><span style="background-color:#ffff00;">我们仔细用log文件对照波形，完全符合规定的时序，没有一点问题。</span></span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong><span style="background-color:#ffff00;">为了确保正确性，更改</span><span style="background-color:#ffff00;">seed</span></strong><strong><span style="background-color:#ffff00;">再跑一遍</span></strong><span style="background-color:#ffff00;">：</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">这次共有12笔读操作，8笔写操作：</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/12/a3/AVxmIcCu_o.jpg"></span></p> 
<p> <span style="color:#000000;">Log文件：</span></p> 
<p style="text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/d7/a9/GrDvaIOq_o.jpg"></span></p> 
<p> <span style="color:#000000;"><span style="background-color:#ffff00;">这里我们发现了一个问题，第三笔trans时候，它的写数据不对</span>，第三笔trans的trans_id是3，地址是trans_id*10为30，数据是trans_id*100为300.但此时的数据是200，原因是前两笔trans是读操作，我们没有把第二笔trans的wdata信号及时删除掉，我们打开driver看看发送数据send_wdata的代码：</span></p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/5e/7b/INqmShLp_o.jpg"></p> 
<p> <span style="color:#000000;">原因就出现在红色画圈部分，这样删掉的方法有些笨重，而且判断不准确，我们换个思路，在接受数据的时候就进行一个判断，如果是读操作，那我们则不要把这笔trans接收过来，这样还可以在程序一开始节省内存空间，一举两得。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;"><span style="background-color:#ffd900;">找到get_sim_trans函数，进行如下修改：</span></span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0px;text-align:center;"><img alt="" src="https://images2.imgbox.com/3f/79/sopybeXi_o.jpg"></p> 
<p> <span style="color:#000000;">随后我们再编译仿真一次，log文件如下：</span></p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/6c/f5/Sz8CJaN6_o.png" width="554"></p> 
<p> <span style="color:#000000;">可以看到，错误被成功纠正了。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">对照波形：没有问题</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/58/e6/MiOSwtPX_o.jpg"></span></p> 
<p> <span style="color:#000000;">继续换seed跑一下，确保正确性：</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">这里有10笔读和10笔写</span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="246" src="https://images2.imgbox.com/35/08/pnVqDaGj_o.png" width="554"></p> 
<p> <span style="color:#000000;">Log文件如下：</span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="274" src="https://images2.imgbox.com/59/85/1GcoD6vD_o.png" width="554"><img alt="" height="186" src="https://images2.imgbox.com/11/b9/zquoOo0H_o.png" width="554"></p> 
<p> <span style="color:#000000;">波形如下：没有任何问题</span></p> 
<p style="margin-left:0px;text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/73/74/qQLy2Nzm_o.jpg"></span></p> 
<p><span style="background-color:#ffd900;"> </span><span style="color:#000000;"><span style="background-color:#ffd900;">综上，我们完成了模拟AHB二级流水的driver的编码，并用自写的模块slv_module进行了验证。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">跑了多个seed，都没有任何问题</span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">综上，完成了AHB-driver最令人头疼的部分。</span></span></strong></p> 
<p style="margin-left:0;text-align:left;">在下一篇博客，我们将完成driver中其他的信号，并完成monitor的代码编写。</p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed16ba0f565c165b43a0902c6b40aa5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">域名系统的解析过程 域名解析多久可以生效</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/925c3ee593dec024e16a63d6edabaa09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle数据库中实现“多行一列”转“一行多列”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>