<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Http通信协议 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Http通信协议" />
<meta property="og:description" content="应用层是 OSI 七层网络模型的第七层，不同类型的网络应用有不同的通信规则，因此应用层协议是多种多样的，比如 DNS、FTP、Telnet、SMTP、HTTP、 等协议都是用于解决其各自的一类问题。
一，Http通信协议的基本原理 http 协议在远程通信场景中的应用还是挺广泛的，包括现在主流的微服务架构的通信都是基于 http 协议。
1，一次http请求的通信流程 我们在浏览器上输入一个网址后，浏览器是如何展示目标网址的内容的？内容是从哪里来的呢？
DNS: （Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务, 用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯
但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从IP 地址反查域名的服务
二，http通信协议的组成 HTTP 协议是基于应用层的协议，并且在传输层使用的 TCP 的可靠性通信协议。既然是协议，那么就应该符合协议的定义：协议是两个需要通过网络通信的程序达成的一种约定，它规定了报文的交换方式和包含的意义，所以，接下来我们来深入去剖析 HTTP 协议的原理和组成。
1，请求URI定位资源 我们在浏览器中输入一个地址，浏览器是如何根据地址去找到服务器对应的资源并做返回的？以及这个地址包含了哪些有价值的信息呢？
URL (Uniform Resource Locator)，统一资源定位符 ，用于描述一个网络上的资源，具体格式是：
URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。
http://www.baidu.com:80/java/index.html?name=aaa
schema://host[:port#]/path/…/?[url-params]#[ query-string]
scheme 指定应用层使用的协议(例如：http, https, ftp)
host HTTP 服务器的 IP 地址或者域名
port# HTTP 服务器的默认端口是 80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/9680521e70ea99f505a429ca016566f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-01T00:55:20+08:00" />
<meta property="article:modified_time" content="2021-03-01T00:55:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Http通信协议</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>应用层是 OSI 七层网络模型的第七层，不同类型的网络应用有不同的通信规则，因此应用层协议是多种多样的，比如 DNS、FTP、Telnet、SMTP、HTTP、 等协议都是用于解决其各自的一类问题。</p> 
<h2><a id="Http_2"></a>一，Http通信协议的基本原理</h2> 
<p>http 协议在远程通信场景中的应用还是挺广泛的，包括现在主流的微服务架构的通信都是基于 http 协议。</p> 
<h3><a id="1http_6"></a>1，一次http请求的通信流程</h3> 
<p>我们在浏览器上输入一个网址后，浏览器是如何展示目标网址的内容的？内容是从哪里来的呢？</p> 
<p><img src="https://images2.imgbox.com/64/89/kQNAIzG0_o.jpg" alt="在这里插入图片描述"></p> 
<p>DNS: （Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务, 用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯</p> 
<p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从IP 地址反查域名的服务</p> 
<h2><a id="http_17"></a>二，http通信协议的组成</h2> 
<p>HTTP 协议是基于应用层的协议，并且在传输层使用的 TCP 的可靠性通信协议。既然是协议，那么就应该符合协议的定义：协议是两个需要通过网络通信的程序达成的一种约定，它规定了报文的交换方式和包含的意义，所以，接下来我们来深入去剖析 HTTP 协议的原理和组成。</p> 
<h3><a id="1URI_21"></a>1，请求URI定位资源</h3> 
<p>我们在浏览器中输入一个地址，浏览器是如何根据地址去找到服务器对应的资源并做返回的？以及这个地址包含了哪些有价值的信息呢？</p> 
<p>URL (Uniform Resource Locator)，统一资源定位符 ，用于描述一个网络上的资源，具体格式是：</p> 
<p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。</p> 
<p>http://www.baidu.com:80/java/index.html?name=aaa<br> schema://host[:port#]/path/…/?[url-params]#[ query-string]</p> 
<p>scheme 指定应用层使用的协议(例如：http, https, ftp)</p> 
<p>host HTTP 服务器的 IP 地址或者域名</p> 
<p>port# HTTP 服务器的默认端口是 80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/</p> 
<p>path 访问资源的路径</p> 
<p>query-string 查询字符串</p> 
<p>/# 片段标识符（使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置））</p> 
<p>通过这个 url 地址，我们就可以读到，当前用户要使用 http 协议访问指定服务器上对应进程中的资源，并且携带了请求参数。</p> 
<h3><a id="2MIME_Type_46"></a>2,MIME Type</h3> 
<p>服务器根据用户请求的资源找到对应的文件以后，会返回一个资源给到客户端浏览器，浏览器会对这个资源解析并且渲染。但是服务器上的资源类型有很多，比如图片类型、视频类型、Js、Css、文本等。浏览器如何识别当前类型做不同的渲染呢？</p> 
<p>MIME Type：是描述消息内容类型的因特网标准，常见的几种类型</p> 
<p>文本文件：text/html,text/plain,text/css,application/xhtml+xml,application/xml</p> 
<p>图片文件：image/jpeg,image/gif,image/png.</p> 
<p>视频文件：video/mpeg,video/quicktime</p> 
<p>我们可以通过两种方式来设置文件的渲染类型，第一种是 Accept，第二种是 Content-Type</p> 
<p>Accept: 表示客户端希望接受的数据类型，即告诉服务器我需要什么媒体类型的数据，此时服务器应该根据 Accept 请求头生产指定媒体类型的数据</p> 
<p>Content-Type: 表 示 发 送 端 发 送 的 实 体 数 据 类 型 ， 比 如 我 们 应 该 写 过 类 似 的 ：resposne.setContentType(“application/json;charset=utf-8”)的代码，表示服务端返回的数据格式是 json。</p> 
<p>如果 Accept 和 Content-Type 不一致，假如说 Accept 要接收的类型是 image/gif，但是服务端返回的数据是 text/html，那么浏览器将会无法解析。</p> 
<h3><a id="3_66"></a>3,如果用户访问一个不存在的地址呢？</h3> 
<p>如果用户访问的地址没问题，或者服务器也能正常解析及处理当前用户的请求，那就能够返回正确的信息给到客户端。但是如果用户访问的地址有问题，或者服务端在解析用户请求以及处理请求逻辑时出现问题，怎么办呢？浏览器应该怎么告诉用户当前是处理失败的呢？</p> 
<p>因此这里就涉及到一个状态码的概念</p> 
<p>状态码的职责是当客户端向服务端发送请求时，描述服务端返回的请求处理结果，通过状态码，浏览器可以知道服务器是正常处理请求还是出现了错误</p> 
<table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>成功状态码</td><td>请求的正常处理完毕</td></tr><tr><td>3xx</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table> 
<p>见得比较多的错误码：</p> 
<p>200：一切正常</p> 
<p>301：永久重定向</p> 
<p>404：请求资源不存在</p> 
<p>500：服务端内部错误</p> 
<p>有了状态码，在用户访问某个网站出现非正常状态时，浏览器就可以很友好的提示用户。</p> 
<h3><a id="4_94"></a>4，告诉服务器端当前请求的意图</h3> 
<p>有了 url，mimetype、状态码， 能够基本满足用户的需求，但是，很多时候一个网站不单纯只是不断从服务端获取资源并做渲染，可能还需要做一些数据的提交、删除等功能。所以浏览器定义了 8 种方法来表示对于不同请求的操作方式，当然最常用的还是 Get 和 Post。</p> 
<p>GET：一般是用于客户端发送一个 URI 地址去获取服务端的资源（一般用于查询操作），Get不支持的传输数据有限制，具体限制由浏览器决定</p> 
<p>POST：一般用户客户端传输一个实体给到服务端，让服务端去保存（一般用于创建操作）</p> 
<p>PUT：向服务器发送数据，一般用于更新数据的操作</p> 
<p>DELETE：客户端发起一个 Delete 请求要求服务端把某个数据删除（一般用于删除操作）</p> 
<p>HEAD:获得报文首部、OPTIONS：询问支持的方法、TRACE：追踪路径、CONNECT：用隧道协议连接代理</p> 
<p>在 REST 架构风格中，有严格规定对于不同的请求类型要设置合适的请求方法。也是避免出现因为乱用导致混乱的问题。</p> 
<p><strong>为什么要定义 REST 这个架构风格？</strong></p> 
<ol><li>随着服务化架构的普及，http 协议的使用频率越来越高</li><li>很多人在错误的使用 http 协议定义接口，比如各种各样的命名，什么 getUserInfoById，deleteById 之类的、有状态和无状态请求混用。</li><li>对于 http 协议本身提供的规则并没有很好的利用</li></ol> 
<p>所以，为了更好的解决这些问题，干脆就定义一套规则，这套规则并没有引入新的东西，无非就是对 http 协议本身的使用做了一些约束，比如说</p> 
<ol><li>REST 是面向资源，每一个 URI 代表一个资源</li><li>强调无状态化，服务器端不能存储来自某个客户的某个请求中的信息，并在该客户的其他请求中使用</li><li>强调 URL 暴露资源时，不要在 URI 中出现动词</li><li>合理的利用 http 状态码、请求方法。</li></ol> 
<h3><a id="5http__123"></a>5，http 协议的完整组成</h3> 
<p>到这里，基本明白了一个 http 协议的组成，接下来简单总结一下,http 协议包含两个报文，一个是请求报文，一个是响应报文</p> 
<h4><a id="1_127"></a>1）请求报文</h4> 
<p>请求报文格式包含三个部分，（起始行、首部字段、主体）</p> 
<p><img src="https://images2.imgbox.com/3b/86/McWGDoiq_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="2_134"></a>2）响应报文</h4> 
<p>响应的报文格式也是一样，分为三部分</p> 
<p><img src="https://images2.imgbox.com/53/75/VdfsPYcR_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="6http_141"></a>6，http协议中的扩展</h3> 
<p>http 协议除了这两种基本组成以外，还有很多比较常见的属性或者配置，</p> 
<h4><a id="1_145"></a>1）如果传输的文件过大怎么办</h4> 
<p>服务器上返回的资源文件比较大，比如有些 js 文件大小可能就有几兆。文件过大就会影响传输的效率，同时也会带来带宽的消耗。怎么办呢？</p> 
<p>1，常见的手段是，对文件进行压缩，减少文件大小。那压缩和解压缩的流程怎么实现呢？</p> 
<p>首先服务端需要能支持文件的压缩功能，其次浏览器能够针对被压缩的文件进行解压缩。浏览器可以指定 Accept-Encoding 来告诉服务器当前支持的编码类型，Accept-Encoding:gzip,deflate，那服务端会根据支持的编码类型，选择合适的类型进行压缩。常见的编码方式有：gzip/deflate</p> 
<p>2，分割传输</p> 
<p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。</p> 
<h4><a id="2_157"></a>2）每次请求都要建立连接吗？</h4> 
<p>在最早的 http 协议中，每进行一次 http 通信，就需要做一次 tcp 的连接。而一次连接需要进行 3 次握手，这种通信方式会增加通信量的开销。</p> 
<p><img src="https://images2.imgbox.com/c9/89/2HEkVCp3_o.jpg" alt="在这里插入图片描述"></p> 
<p>所以在 HTTP/1.1 中改用了持久连接，就是在一次连接建立之后，只要客户端或者服务端没有明确提出断开连接，那么这个 tcp 连接会一直保持连接状态</p> 
<p>持久连接的一个最大的好处是：大大减少了连接的建立以及关闭时延。</p> 
<p>HTTP1.1 中有一个 Transport 段。会携带一个 Connection:Keep-Alive，表示希望将此条连接作为持久连接。</p> 
<p>HTTP/1.1 持久连接在默认情况下是激活的，除非特别指明，否则 HTTP/1.1 假定所有的连接都是持久的，要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显示地添加一个 Connection：close 首部。</p> 
<p>HTTP1.1 客户端加载在收到响应后，除非响应中包含了 Connection：close 首部，不然 HTTP/1.1连接就仍然维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection：close 并不意味这服务器承诺永远将连接保持在打开状态。</p> 
<p>管道化连接: http/1.1 允许在持久连接上使用请求管道。以前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p> 
<p><img src="https://images2.imgbox.com/29/c7/lifx0VU6_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="http_179"></a>三，http协议的特点</h2> 
<h3><a id="1http_181"></a>1，http无状态协议</h3> 
<p>HTTP 协议是无状态的，什么是无状态呢？就是说 HTTP 协议本身不会对请求和响应之间的通信状态做保存。</p> 
<p>但是现在的应用都是有状态的，如果是无状态，那这些应用基本没人用，你想想，访问一个电商网站，先登录，然后去选购商品，当点击一个商品加入购物车以后又提示你登录。这种用户体验根本不会有人去使用。那我们是如何实现带状态的协议呢？</p> 
<h3><a id="2cookie_187"></a>2，客户端支持的cookie</h3> 
<p>Http 协议中引入了 cookie 技术，用来解决 http 协议无状态的问题。通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态；Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p> 
<h3><a id="3_session_191"></a>3，服务端支持的 session</h3> 
<p>服务端是通过什么方式来保存状态的呢？ 在基于 tomcat 这类的 jsp/servlet 容器中，会提供session 这样的机制来保存服务端的对象状态，服务器使用一种类似于散列表的结构来保存信息，当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求是否包含了一个 session 标识- session id；如果已包含一个 session id 则说明以前已经为客户端创建过 session，服务器就按照 sessionid 把这个 session 检索出来使用（如果检索不到，会新建一个）；如果客户端请求不包含 sessionid，则为此客户端创建一个 session 并且生成一个与此 session相关联的 session id， session id 的值是一个既不会重复，又不容易被找到规律的仿造字符串，这个 session id 将会返回给客户端保存。</p> 
<p><img src="https://images2.imgbox.com/38/57/XOSOCIJr_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="4Tomcat____session___198"></a>4，Tomcat 实现 session 的代码逻辑分析</h3> 
<p>以 HttpServletRequest#getSession() 作为切入点，对 Session 的创建过程进行分析</p> 
<p>应 用 程 序 拿 到 的 HttpServletRequest 是org.apache.catalina.connector.RequestFacade(除非某些 Filter 进行了特殊处理)，它是<br> org.apache.catalina.connector.Request 的门面模式。首先，会判断 Request 对象中是否存在 Session，如果存在并且未失效则直接返回，如果不存在 Session，则尝试根据 requestedSessionId 查找 Session，如果存在 Session 的话则直接返回，如果不存在的话，则创建新的 Session，并且把 sessionId 添加到 Cookie 中，后续的请求便会携带该 Cookie，这样便可以根据 Cookie 中的 sessionId 找到原来创建的Session 了。<br> <img src="https://images2.imgbox.com/2b/68/e7tz36F7_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="http_207"></a>四，http协议基本分析</h2> 
<p>由于 HTTP 协议在通信过程中，是基于明文通信，并且底层是基于 TCP/IP 协议进行通信，那么按照 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到拦截和窃取。窃取这个过程其实很简单，通过抓包工具 Wireshark 就可以截获请求和响应的内容。</p> 
<h3><a id="1https___211"></a>1，https 安全传输协议</h3> 
<p>由于 HTTP 协议通信的不安全性，所以人们为了防止信息在传输过程中遭到泄漏或者篡改，,就想出来对传输通道进行加密的方式 https。</p> 
<p>https 是一种加密的超文本传输协议，它与 HTTP 在协议差异在于对数据传输的过程中，https对数据做了完全加密。由于 http 协议或者 https 协议都是处于 TCP 传输层之上，同时网络协议又是一个分层的结构，所以在 tcp 协议层之上增加了一层 SSL（Secure Socket Layer，安全层）或者 TLS（Transport Layer Security） 安全层传输协议组合使用用于构造加密通道。</p> 
<p><img src="https://images2.imgbox.com/7b/43/613IqIO9_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="_https__220"></a>五，逆向推导 https 的设计过程</h2> 
<p>先不去探究 ssl 的实现原理，我们先从设计者的角度去思考如何去建立一个安全的传输通道</p> 
<h3><a id="1_224"></a>1，从第一个消息开始</h3> 
<p>客户端 A 向服务端 B 发送一条消息，这个消息可能会被拦截以及篡改，我们如何做到 A 发送给 B 的数据包，即使被拦截了，也没办法得知消息内容并且也不能查看呢？</p> 
<h3><a id="2_228"></a>2，利用对称加密</h3> 
<p>要做到消息不能被第三方查看以及篡改，那么第一想法就是对内容进行加密，同时，该消息还需要能被服务端进行解密。所以我们可以使用对称加密算法来实现，密钥 S 扮演着加密和解密的角色。在密钥 S 不公开的情况下，就可以保证安全性？</p> 
<p><img src="https://images2.imgbox.com/a7/2d/R3B6tsda_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="3_235"></a>3，没那么简单</h3> 
<p>在互联网世界，通信不会这么简单，也许是这样。</p> 
<p><img src="https://images2.imgbox.com/ec/fb/GeDnuJiq_o.jpg" alt="在这里插入图片描述"></p> 
<p>会存在多个客户端和服务端产生连接，而这个客户端也许是一个潜伏者，如果他也有对称密钥 S，那相当于上面的方案是不可行的？如果服务端和每个客户端通信的时候使用不同的加密算法呢？</p> 
<p><img src="https://images2.imgbox.com/30/e5/s0nDqKuI_o.jpg" alt="在这里插入图片描述"></p> 
<p>似乎能够完美解决问题，然后？密钥如何分配呢？也就是服务端怎么告诉客户端该使用那种对称加密算法呢？解决办法似乎只能通过建立会话以后进行协商了？</p> 
<h3><a id="4_249"></a>4，协商过程又是不安全的</h3> 
<p>协商过程，意味着又是基于一个网络传输的情况下去动态分配密钥，可是这个协商过程又是不安全的，怎么破？</p> 
<h3><a id="5_253"></a>5，非对称加密出马</h3> 
<p>非对称加密算法的特点是：私钥加密后的密文，只要有公钥，都能解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有人。</p> 
<p><img src="https://images2.imgbox.com/1e/0e/4F6eAy8r_o.jpg" alt="在这里插入图片描述"></p> 
<p>这样就可以保证 A/B 向服务器端方向发送的消息是安全的。似乎我们通过非对称加密算法解决了密钥的协商的问题？但是</p> 
<h3><a id="6_262"></a>6，公钥怎么拿</h3> 
<p>使用非对称加密算法，那么如何让 A、B 客户端安全地持有公钥？那么我们逐步思考，有两种我们能想到的方案：</p> 
<ol><li>服务器端将公钥发送给每一个客户端</li><li>服务器端将公钥放到一个远程服务器，客户端可以请求到 （多了一次请求，还得解决公钥放置问题）</li></ol> 
<p>方案一似乎不可行，因为，传输过程又是不安全的？公钥可能会被调包</p> 
<p><img src="https://images2.imgbox.com/9b/60/IBgPG9Q8_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="7_273"></a>7，引入第三方机构</h3> 
<p>到上面这一步，最关键的问题是，客户端如何知道给我公钥的是黄蓉还是小龙女？只能找本人去证实？或者有一个第三者来帮你证实，并且第三者是绝对公正的。所以，引入一个可信任的第三者是一个好的方案</p> 
<p>服务端把需要传递给客户端的公钥，通过第三方机构提供的私钥对公钥内容进行加密后，再传递给客户端？ 通过第三方机构私钥对服务端公钥加密以后的内容，就是一个简陋版本的“数字证书”。这个帧数中包含【服务器公钥】</p> 
<p><img src="https://images2.imgbox.com/57/7d/5HF6QShN_o.jpg" alt="在这里插入图片描述"></p> 
<p>客户端拿到这个证书以后，因为证书是第三方机构使用私钥加密的。客户端必须要有第三方机构提供的公钥才能解密证书。这块又涉及到第三方机构的公钥怎么传输？（假设是先内置在系统中）以及还有一个问题，第三方机构颁发的证书是面向所有用户，不会只针对一家发放。如果不法分子也去申请一个证书呢？</p> 
<h3><a id="8_284"></a>8，如果不法分子也拿到证书？</h3> 
<p>如果不法分子也申请了证书，那它可以对证书进行调包。客户端在这种情况下是无法分辨出收到的是你的证书，还是中间人的。因为不论是中间人的、还是你的证书都能使用第三方机构的公钥进行解密。</p> 
<p><img src="https://images2.imgbox.com/d2/52/4iDhllX7_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="9_291"></a>9，验证证书的有效性</h3> 
<p>事情发展到现在，问题演变成了，客户端如何识别证书的真伪？在现实生活中，要验证一个东西的真伪，绝大部分都是基于编号去验证</p> 
<p><strong>证书上写了如何根据证书的内容生成证书编号。客户端拿到证书后根据证书上的方法自己生成一个证书编号，如果生成的证书编号与证书上的证书编号相同，那么说明这个证书是真实的。</strong></p> 
<p>这块有点类似于 md5 的验证，我们下载一个软件包，都会提供一个 md5 的值，我们可以拿到这个软件包以后通过一个第三方软件去生成一个 md5 值去做比较，是不是一样如果一样表示这个软件包没被篡改过。</p> 
<p>浏览器内置的 CA 公钥可以解密服务端 CA 私钥加密的证书，通过浏览器内置的 CA 证书的证书编号算法对服务端返回的证书编号进行验签。</p> 
<h3><a id="0_301"></a>0，第三方机构的公钥证书存哪里？</h3> 
<p>浏览器和操作系统都会维护一个权威的第三方机构列表（包括他们的公钥）</p> 
<p>因为客户端接收到的证书中会些颁发机构，客户端就根据这个办法机构的值在本地找到响应的公钥</p> 
<p>证书就是 HTTPS 中的数字证书，证书编号就是数字签名，而第三方机构就是数字证书的签发机构（CA）</p> 
<h2><a id="https_309"></a>六，https原理分析</h2> 
<h3><a id="1https_311"></a>1，https证书的申请过程</h3> 
<p>1，服务器上生成 CSR 文件（证书申请文件，内容包括证书公钥、使用的 Hash 签名算法、申请的域名、公司名称、职位等信息）</p> 
<p>2，把 CSR 文件和其他可能的证件上传到 CA 认证机构，CA 机构收到证书申请之后，使用申请中的 Hash 算法，对部分内容进行摘要，然后使用 CA 机构自己的私钥对这段摘要信息进行签名（相当于证书的唯一编号）</p> 
<p>3，然后 CA 机构把签名过的证书通过邮件形式发送到申请者手中</p> 
<p>4，申请者收到证书之后部署到自己的 web 服务器中</p> 
<h3><a id="2_321"></a>2，客户端请求交互流程</h3> 
<ol><li>客户端发起请求(Client Hello 包)</li></ol> 
<p>a) 三次握手，建立 TCP 连接</p> 
<p>b) 支持的协议版本(TLS/SSL)</p> 
<p>c) 客户端生成的随机数 client.random，后续用于生成“对话密钥”</p> 
<p>d) 客户端支持的加密算法</p> 
<p>e) sessionid，用于保持同一个会话（ 如果客户端与服务器费尽周折建立了一个 HTTPS 链接，刚建完就断了，也太可惜 ）</p> 
<ol start="2"><li>服务端收到请求，然后响应（Server Hello）</li></ol> 
<p>a) 确认加密通道协议版本</p> 
<p>b) 服务端生成的随机数 server.random，后续用于生成“对话密钥”</p> 
<p>c) 确认使用的加密算法（用于后续的握手消息进行签名防止篡改）</p> 
<p>d) 服务器证书（CA 机构颁发给服务端的证书）</p> 
<ol start="3"><li>客户端收到证书进行验证<br> a) 验证证书是否是上级 CA 签发的, 在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信</li></ol> 
<p>b) 服务端返回的证书中会包含证书的有效期，可以通过失效日期来验证 证书是否过期</p> 
<p>c) 验证证书是否被吊销了</p> 
<p>d) 前面我们知道 CA 机构在签发证书的时候，都会使用自己的私钥对证书进行签名证书里的签名算法字段 sha256RSA 表示 CA 机构使用 sha256 对证书进行摘要，然后使用 RSA 算法对摘要进行私钥签名，而我们也知道 RSA 算法中，使用私钥签名之后，只有公钥才能进行验签。</p> 
<p>e) 浏览器使用内置在操作系统上的 CA 机构的公钥对服务器的证书进行验签。确定这个证书是不是由正规的机构颁发。验签之后得知 CA 机构使用 sha256 进行证书摘要，然后客户端再使用 sha256 对证书内容进行一次摘要，如果得到的值和服务端返回的证书验签之后的摘要相同，表示证书没有被修改过</p> 
<p>f) 验证通过后，就会显示绿色的安全字样</p> 
<p>g) 客户端生成随机数，验证通过之后，客户端会生成一个随机数 pre-master secret，客户端根据之前的：Client.random + sever.random + pre-master 生成对称密钥然后使用证书中的公钥进行加密，同时利用前面协商好的 HASH 算法,把握手消息取 HASH 值，然后用 随机数加密 “握手消息+握手消息 HASH 值(签名)” 并一起发送给服务端 ( 在这里之所以要取握手消息的 HASH 值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。 )</p> 
<ol start="4"><li>服务端接收随机数</li></ol> 
<p>a) 服务端收到客户端的加密数据以后，用自己的私钥对密文进行解密。然后得到client.random/server.random/pre-master secret, HASH 值，并与传过来的 HASH 值做对比确认是否一致。</p> 
<p>b) 然后用随机密码加密一段握手消息(握手消息+握手消息的 HASH 值 )给客户端</p> 
<ol start="5"><li>客户端接收消息</li></ol> 
<p>a) 客户端用随机数解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，</p> 
<p>b) 之 后 所 有 的 通 信 数 据 将 由 之 前 交 互 过 程 中 生 成 的 pre master secret /client.random/server.random 通过算法得出 session Key，作为后续交互过程中的对称密钥</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/200331dae9b2f4d107e711d96cb97a31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据——Ubuntu docker安装、容器准备、环境准备以及软件安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/072b850ee30fec8faf0b67c3975d9275/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue3.0&#43;ElementPlus&#43;Koa2搭一个全栈后台管理模板项目！！！！！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>