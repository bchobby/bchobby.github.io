<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>(day11) 自学Java——集合进阶(单列集合) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="(day11) 自学Java——集合进阶(单列集合)" />
<meta property="og:description" content="目录
1.集合体系结构
2.Collection集合
（1）迭代器
（2）增强for
（3）lambda表达式
3.List集合
4.数据结构
5.ArrayList集合
6.LinkedList集合
7.泛型深入
8.数据结构（树）
(1)二叉树
(2)平衡二叉树旋转机制
(3)红黑树
9.Set系列集合
(1) HashSet
(2)LinkedHashSet
(3)TreeSet
非原创，为方便后期复习
1.集合体系结构 2.Collection集合 1. List系列集合：添加的元素是有序、可重复、有索引。
（有序：“存”和“取”的顺序一样）
2. Set系列集合：添加的元素是无序、不重复、无索引。
（1）迭代器 （2）增强for （3）lambda表达式 3.List集合 4.数据结构 什么是数据结构？
计算机存储、组织数据的方式。
5.ArrayList集合 6.LinkedList集合 添加“aaa”，在LinkedList里的尾节点是null，所以l=last=null，尾结点last=newNode=0x0011，因为l==null，所以头结点为first=0x0011。
添加“bbb”，l=last=0x0011，尾结点last=newNode=0x0022，不满足l==null，所以l.next=newNode（就是0x0011.next=0x0022）
添加“ccc”，l=last=0x0022，尾结点last=newNode=0x0033，不满足l==null，所以l.next=newNode（就是0x0022.next=0x0033）
迭代器底层原理
7.泛型深入 1.泛型中不能写基本数据类型，因为数据在存入之后会变成Object类型，int无法转Object类型，要写成Integer包装类才可以转Object。
2.存入数据的时候，会检查数据类型，数据进入后会转成Object类型，取出时又强转回一开始的数据类型。
3.指定泛型类型后，可以传入该类类型或者子类类型。比如Animal类型，还可以传cat，dog类型。
4.如果不写泛型，就默认为Object类型。
泛型方法：1.在类名后面定义泛型（所有方法都能用）
2.在方法后面定义泛型（只有本方法能用）
练习：定义一个工具类：ListUtil，类中定义一个静态方法addAll，用来添加多个集合的元素
方式1：public class MyArrayList1 implements List&lt;String&gt;{} 类型可替换
方式2：public class MyArrayList2&lt;E&gt; implements List&lt;E&gt;{}
8.数据结构（树） (1)二叉树 1.普通二叉树，没有规律，只能遍历查找，麻烦。
2.二叉查找树，方便，查找方法，拿数据跟根节点比较，比根节点小/大，就跟左/右子节点比较......
度&lt;=2就是二叉树
普通二叉树，查找效率低，只能遍历。
二叉查找树，效率提升，但是存储时可能会造成左右子树的高度差很大，查询效率也降低。
平衡二叉树，任意节点子树的高度差不能超过1。
(2)平衡二叉树旋转机制 平衡二叉树缺点：添加节点时，旋转次数太多，导致添加节点时间浪费。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/9a00c6c3486f6bf6b63c1075c79d5f65/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-08T21:03:16+08:00" />
<meta property="article:modified_time" content="2023-02-08T21:03:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">(day11) 自学Java——集合进阶(单列集合)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#1.%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" rel="nofollow">1.集合体系结构</a></p> 
<p id="2.Collection%E9%9B%86%E5%90%88-toc" style="margin-left:0px;"><a href="#2.Collection%E9%9B%86%E5%90%88" rel="nofollow">2.Collection集合</a></p> 
<p id="%EF%BC%881%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">（1）迭代器</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%A2%9E%E5%BC%BAfor-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E5%A2%9E%E5%BC%BAfor" rel="nofollow">（2）增强for</a></p> 
<p id="%EF%BC%883%EF%BC%89lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">（3）lambda表达式</a></p> 
<p id="3.List%E9%9B%86%E5%90%88-toc" style="margin-left:0px;"><a href="#3.List%E9%9B%86%E5%90%88" rel="nofollow">3.List集合</a></p> 
<p id="4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">4.数据结构</a></p> 
<p id="5.ArrayList%E9%9B%86%E5%90%88-toc" style="margin-left:0px;"><a href="#5.ArrayList%E9%9B%86%E5%90%88" rel="nofollow">5.ArrayList集合</a></p> 
<p id="6.LinkedList%E9%9B%86%E5%90%88-toc" style="margin-left:0px;"><a href="#6.LinkedList%E9%9B%86%E5%90%88" rel="nofollow">6.LinkedList集合</a></p> 
<p id="7.%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5-toc" style="margin-left:0px;"><a href="#7.%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5" rel="nofollow">7.泛型深入</a></p> 
<p id="8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%A0%91%EF%BC%89-toc" style="margin-left:0px;"><a href="#8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%A0%91%EF%BC%89" rel="nofollow">8.数据结构（树）</a></p> 
<p id="(1)%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#%281%29%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">(1)二叉树</a></p> 
<p id="(2)%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#%282%29%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC%E6%9C%BA%E5%88%B6" rel="nofollow">(2)平衡二叉树旋转机制</a></p> 
<p id="(3)%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:40px;"><a href="#%283%29%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">(3)红黑树</a></p> 
<p id="9.Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88-toc" style="margin-left:0px;"><a href="#9.Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88" rel="nofollow">9.Set系列集合</a></p> 
<p id="(1)%20HashSet-toc" style="margin-left:40px;"><a href="#%281%29%20HashSet" rel="nofollow">(1) HashSet</a></p> 
<p id="11.LinkedHashSet-toc" style="margin-left:40px;"><a href="#11.LinkedHashSet" rel="nofollow">(2)LinkedHashSet</a></p> 
<p id="12.TreeSet-toc" style="margin-left:40px;"><a href="#12.TreeSet" rel="nofollow">(3)TreeSet</a></p> 
<hr id="hr-toc"> 
<p>非原创，为方便后期复习</p> 
<h2 id="1.%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.集合体系结构</h2> 
<p><img alt="" height="722" src="https://images2.imgbox.com/ca/97/tLD0H094_o.png" width="1200"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/2d/31/M97ql9Mz_o.png" width="566"></p> 
<h2 id="2.Collection%E9%9B%86%E5%90%88">2.Collection集合</h2> 
<p><img alt="" height="678" src="https://images2.imgbox.com/35/1b/Y3dwYVMI_o.png" width="1200"></p> 
<blockquote> 
 <p>1. List系列集合：添加的元素是<span style="color:#fe2c24;">有序、可重复、有索引</span>。</p> 
 <p>（有序：“存”和“取”的顺序一样）</p> 
 <p>2. Set系列集合：添加的元素是<span style="color:#fe2c24;">无序、不重复、无索引</span>。</p> 
</blockquote> 
<p><img alt="" height="578" src="https://images2.imgbox.com/e3/27/N8nmRsCD_o.png" width="1200"></p> 
<h3 id="%EF%BC%881%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8">（1）迭代器</h3> 
<p><img alt="" height="612" src="https://images2.imgbox.com/ec/b3/b9q5vRUT_o.png" width="1200"></p> 
<h3 id="%EF%BC%882%EF%BC%89%E5%A2%9E%E5%BC%BAfor">（2）增强for</h3> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="627" src="https://images2.imgbox.com/e1/74/oaQxCpPe_o.png" width="1200"><img alt="" height="618" src="https://images2.imgbox.com/54/96/ncU1ihHD_o.png" width="1145"></h3> 
<h3 id="%EF%BC%883%EF%BC%89lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">（3）lambda表达式</h3> 
<p><img alt="" height="342" src="https://images2.imgbox.com/95/d5/s2bMbDRy_o.png" width="1200"></p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/48/8a/Lha6HrgU_o.png" width="1200"></p> 
<h2 id="3.List%E9%9B%86%E5%90%88">3.List集合</h2> 
<p><img alt="" height="567" src="https://images2.imgbox.com/4d/44/uhP5CWUs_o.png" width="1115"></p> 
<p><img alt="" height="652" src="https://images2.imgbox.com/c6/bc/F9wITgPE_o.png" width="438"></p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/2f/38/8X8IwZiQ_o.png" width="450"></p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/a1/c7/2TYZ2v5Z_o.png" width="562"></p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/62/cd/F2LYBWwW_o.png" width="602"></p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/29/46/XzBeUjDx_o.png" width="1052"></p> 
<p></p> 
<h2 id="4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4.数据结构</h2> 
<blockquote> 
 <p>什么是数据结构？</p> 
 <p>计算机存储、组织数据的方式。</p> 
</blockquote> 
<p><img alt="" height="497" src="https://images2.imgbox.com/c5/1f/mHSijxsu_o.png" width="1200"></p> 
<p><img alt="" height="717" src="https://images2.imgbox.com/80/e0/wTMN5pFs_o.png" width="1200"></p> 
<p><img alt="" height="668" src="https://images2.imgbox.com/44/5d/9HF4SKLA_o.png" width="1200"> <img alt="" height="732" src="https://images2.imgbox.com/c0/56/chEHmHiO_o.png" width="1200"></p> 
<p><img alt="" height="647" src="https://images2.imgbox.com/81/9e/rJMxoZEm_o.png" width="1200"> <img alt="" height="672" src="https://images2.imgbox.com/8b/46/xKwMpADT_o.png" width="1200"></p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/09/c0/0iLZo2cQ_o.png" width="1003"></p> 
<h2 id="5.ArrayList%E9%9B%86%E5%90%88">5.ArrayList集合</h2> 
<p><img alt="" height="663" src="https://images2.imgbox.com/81/ed/SYBx6Gby_o.png" width="1200"></p> 
<p><img alt="" height="638" src="https://images2.imgbox.com/de/6c/WDiokFbC_o.png" width="1200"></p> 
<h2 id="6.LinkedList%E9%9B%86%E5%90%88">6.LinkedList集合</h2> 
<p><img alt="" height="606" src="https://images2.imgbox.com/82/d8/7XhCY8Py_o.png" width="1200"></p> 
<blockquote> 
 <p><img alt="" height="663" src="https://images2.imgbox.com/92/09/e3IzeNpr_o.png" width="1200"></p> 
 <p>添加“aaa”，在LinkedList里的尾节点是null，所以l=last=null，尾结点last=newNode=0x0011，因为l==null，所以头结点为first=0x0011。</p> 
 <p>添加“bbb”，l=last=0x0011，尾结点last=newNode=0x0022，不满足l==null，所以l.next=newNode（就是0x0011.next=0x0022）</p> 
 <p>添加“ccc”，l=last=0x0022，尾结点last=newNode=0x0033，不满足l==null，所以l.next=newNode（就是0x0022.next=0x0033）</p> 
</blockquote> 
<p> 迭代器底层原理<img alt="" height="590" src="https://images2.imgbox.com/af/19/KLyiSo0F_o.png" width="1200"></p> 
<h2 id="7.%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5">7.泛型深入</h2> 
<p><img alt="" height="439" src="https://images2.imgbox.com/f4/2b/tEnobkWQ_o.png" width="700"></p> 
<p> <img alt="" height="172" src="https://images2.imgbox.com/ff/a7/lnIeEIAi_o.png" width="557"></p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/19/68/PBnAohl6_o.png" width="1200"></p> 
<blockquote> 
 <p>1.泛型中不能写基本数据类型，因为数据在存入之后会变成Object类型，int无法转Object类型，要写成Integer包装类才可以转Object。</p> 
 <p>2.存入数据的时候，会检查数据类型，数据进入后会转成Object类型，取出时又强转回一开始的数据类型。</p> 
 <p>3.指定泛型类型后，可以传入该类类型或者子类类型。比如Animal类型，还可以传cat，dog类型。</p> 
 <p>4.如果不写泛型，就默认为Object类型。</p> 
</blockquote> 
<p><img alt="" height="274" src="https://images2.imgbox.com/ba/2d/Wk8dOybU_o.png" width="500"></p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/9e/d6/OS6zaHKI_o.png" width="1200"></p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/34/3a/Ttld1ATt_o.png" width="1200"></p> 
<blockquote> 
 <p>泛型方法：1.在类名后面定义泛型（所有方法都能用）</p> 
 <p>                 2.在方法后面定义泛型（只有本方法能用）</p> 
</blockquote> 
<p><img alt="" height="460" src="https://images2.imgbox.com/9c/f2/tGE9P7qE_o.png" width="1200"></p> 
<p> <span style="color:#fe2c24;">练习：定义一个工具类：ListUtil，类中定义一个静态方法addAll，用来添加多个集合的元素</span></p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/1c/a9/tPbCmqiD_o.png" width="1200"></p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/ed/3b/omzegnGP_o.png" width="1200"></p> 
<blockquote> 
 <p>方式1：public class MyArrayList1 implements List&lt;<span style="color:#fe2c24;">String</span>&gt;{}  类型可替换</p> 
 <p>方式2：public class MyArrayList2&lt;E&gt; implements List&lt;E&gt;{}</p> 
</blockquote> 
<p><img alt="" height="157" src="https://images2.imgbox.com/19/64/hrovQC5C_o.png" width="472"></p> 
<p><img alt="" height="557" src="https://images2.imgbox.com/9e/37/U5ltLlJP_o.png" width="858"></p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/17/f4/yTKOwE10_o.png" width="1200"><img alt="" height="567" src="https://images2.imgbox.com/c5/81/rF6nbuRk_o.png" width="1200"></p> 
<h2 id="8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%A0%91%EF%BC%89">8.数据结构（树）</h2> 
<h3 id="(1)%E4%BA%8C%E5%8F%89%E6%A0%91">(1)二叉树</h3> 
<p><img alt="" height="385" src="https://images2.imgbox.com/a8/fe/wWmIB0Il_o.png" width="600"></p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/80/3a/dJz2c51i_o.png" width="600"></p> 
<p> <img alt="" height="205" src="https://images2.imgbox.com/11/04/hvDCcust_o.png" width="301"></p> 
<p><img alt="" height="648" src="https://images2.imgbox.com/6a/4b/zXNs124J_o.png" width="1200"></p> 
<p><img alt="" height="662" src="https://images2.imgbox.com/56/ab/gweIXGH0_o.png" width="1200"></p> 
<blockquote> 
 <p>1.普通二叉树，没有规律，只能遍历查找，麻烦。</p> 
 <p>2.二叉查找树，方便，查找方法，拿数据跟根节点比较，比根节点小/大，就跟左/右子节点比较......</p> 
</blockquote> 
<p> <img alt="" height="339" src="https://images2.imgbox.com/e5/a5/z9Csqmny_o.png" width="500"></p> 
<p><img alt="" height="730" src="https://images2.imgbox.com/a2/cc/HZhv8RbG_o.png" width="1200"></p> 
<blockquote> 
 <p>度&lt;=2就是二叉树</p> 
 <p>普通二叉树，查找效率低，只能遍历。</p> 
 <p>二叉查找树，效率提升，但是存储时可能会造成左右子树的高度差很大，查询效率也降低。</p> 
 <p>平衡二叉树，<span style="color:#fe2c24;">任意节点</span>子树的高度差不能超过1。</p> 
</blockquote> 
<h3 id="(2)%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC%E6%9C%BA%E5%88%B6">(2)平衡二叉树旋转机制</h3> 
<p><img alt="" height="322" src="https://images2.imgbox.com/a9/e2/MlmDS5pp_o.png" width="700"></p> 
<p><img alt="" height="593" src="https://images2.imgbox.com/76/05/5X3TDY9A_o.png" width="1200"></p> 
<p> <img alt="" height="124" src="https://images2.imgbox.com/7d/ee/dXlSsxjQ_o.png" width="156"></p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/54/02/GDxPqnvM_o.png" width="1200"></p> 
<p> <img alt="" height="214" src="https://images2.imgbox.com/6b/9f/H7tBzRZW_o.png" width="315"></p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/79/da/9LbcbIt5_o.png" width="1200"></p> 
<p> <img alt="" height="196" src="https://images2.imgbox.com/6d/9a/TmYaX99x_o.png" width="185"><img alt="" height="645" src="https://images2.imgbox.com/93/72/DppG1I4t_o.png" width="1200"></p> 
<p><img alt="" height="142" src="https://images2.imgbox.com/45/3e/u0RZ2XZd_o.png" width="230"></p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/58/e8/DFLTIO2p_o.png" width="700"></p> 
<blockquote> 
 <p>平衡二叉树<span style="color:#fe2c24;">缺点</span>：添加节点时，旋转次数太多，导致添加节点时间浪费。</p> 
</blockquote> 
<h3 id="(3)%E7%BA%A2%E9%BB%91%E6%A0%91">(3)红黑树</h3> 
<p><img alt="" height="265" src="https://images2.imgbox.com/7a/ab/hKYXthpg_o.png" width="1051"></p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/de/14/hJuyL3XZ_o.png" width="1200"> <img alt="" height="127" src="https://images2.imgbox.com/a3/67/ruj9XpFI_o.png" width="498"></p> 
<blockquote> 
 <p>添加节点默认红色，效率更高</p> 
</blockquote> 
<h2 id="9.Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88">9.Set系列集合</h2> 
<p><img alt="" height="583" src="https://images2.imgbox.com/8e/99/xebBitQx_o.png" width="1061"></p> 
<p><img alt="" height="581" src="https://images2.imgbox.com/00/d1/1gNMQC6J_o.png" width="1200"> <img alt="" height="462" src="https://images2.imgbox.com/3f/3d/VCIzkkkX_o.png" width="1046"></p> 
<h3 id="(1)%20HashSet">(1) HashSet</h3> 
<p><img alt="" height="573" src="https://images2.imgbox.com/48/ee/WbAeEOm0_o.png" width="1200"></p> 
<p><img alt="" height="83" src="https://images2.imgbox.com/36/f3/FPwDnNIi_o.png" width="416"></p> 
<blockquote> 
 <p>1.加载因子0.75，就是扩容，比如数组长度为16，16*0.75=12，12个位置都存满了就扩容，</p> 
 <p>  扩大2倍，16*2 =32</p> 
 <p>2.<img alt="" height="398" src="https://images2.imgbox.com/42/70/SnXV1Mni_o.png" width="1200"></p> 
 <p>重写是为了使用属性值进行计算，或者比较是否相等。不重写，就是用地址值计算，或比较</p> 
 <p>（用hashcode获得哈希值，哈希值确定数据存储在数组中的位置，用equals比较数据内部属性值是否相同）</p> 
 <p>hashset中存储自定义对象，一定要重写hashcade和equals</p> 
</blockquote> 
<blockquote> 
 <p>创建集合，需要去重，用hashset，不需要就用ArrayList</p> 
</blockquote> 
<p><span style="color:#fe2c24;">练习：创建一个存储学生对象的集合，存储多个学生对象，遍历该集合。</span></p> 
<p><span style="color:#fe2c24;">        要求：学生对象的成员变量值相同，我们就认为是同一个对象。</span></p> 
<pre><code class="language-java">import java.util.HashSet;

public class Test {
    public static void main(String[] args){
        Student s1=new Student("zhangsan",20);
        Student s2=new Student("lisi",23);
        Student s3=new Student("zhaowu",21);
        Student s4=new Student("zhaowu",21);
        HashSet&lt;Student&gt; hs=new HashSet&lt;&gt;();
        System.out.println(hs.add(s1));
        System.out.println(hs.add(s2));
        System.out.println(hs.add(s3));
        System.out.println(hs.add(s4));
        System.out.println(hs);
    }
}</code></pre> 
<h3 id="11.LinkedHashSet">(2)LinkedHashSet</h3> 
<p><img alt="" height="671" src="https://images2.imgbox.com/45/35/J2TKc2RN_o.png" width="1200"></p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/63/d9/XBo5VmV5_o.png" width="1135"></p> 
<h3 id="12.TreeSet">(3)TreeSet</h3> 
<p><img alt="" height="285" src="https://images2.imgbox.com/da/cd/HC6fNDi9_o.png" width="1116"></p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/3e/a0/6nWYYobH_o.png" width="600"></p> 
<p><span style="color:#fe2c24;"> 练习：存储整数并进行排序</span></p> 
<pre><code class="language-java">import java.util.Iterator;
import java.util.TreeSet;

public class Test {
    public static void main(String[] args){
        TreeSet&lt;Integer&gt; ts=new TreeSet&lt;&gt;();
        ts.add(5);
        ts.add(1);
        ts.add(3);
        ts.add(2);
        ts.add(4);
        System.out.println(ts); //结果：[1, 2, 3, 4, 5]
        //迭代器
        Iterator it=ts.iterator();
        while (it.hasNext()){
            Object i = it.next();
            System.out.println(i);
        }
        //增强for
        for (Integer t : ts) {
            System.out.println(t);
        }
        //lambda
        ts.forEach(i-&gt; System.out.println(i));
    }
}</code></pre> 
<p><img alt="" height="645" src="https://images2.imgbox.com/8c/e8/hU9vFvdR_o.png" width="1200"></p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/bf/7b/NXH9a1Ib_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;">练习：TreeSet对象排序练习题<br> 需求：请自行选择比较器排序和自然排序两种方式；<br> 要求：存入四个字符串，“c”，“ab”，“df”，“qwer”<br> 按照长度排序，如果一样长则按照首字母排序</span></p> 
<pre><code class="language-java">import java.util.Comparator;
import java.util.TreeSet;

public class Test {
    public static void main(String[] args){
        TreeSet&lt;String&gt; ts=new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() {
            @Override
            //o1是要添加的数据，o2是已经存在于红黑树的数据
            public int compare(String o1, String o2) {
                int i=o1.length()-o2.length();
                i=i==0?o1.compareTo(o2):i;
                return i;
            }
        });
        ts.add("c");
        ts.add("ab");
        ts.add("df");
        ts.add("qwer");
        System.out.println(ts);//结果：[c, ab, df, qwer]
    }
}</code></pre> 
<p><span style="color:#fe2c24;">练习：需求：创建5个学生对象<br> 属性：(姓名,年龄,语文成绩,数学成绩,英语成绩),<br> 按照总分从高到低输出到控制台<br> 如果总分一样，按照语文成绩排<br> 如果语文一样，按照数学成绩排<br> 如果数学成绩一样，按照英语成绩排<br> 如果英文成绩一样，按照年龄排<br> 如果年龄一样，按照姓名的字母顺序排<br> 如果都一样，认为是同一个学生，不存。</span></p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        Student s1=new Student("zhangsan",18,89,85,88);
        Student s2=new Student("lisi",22,97,65,78);
        Student s3=new Student("wangwu",20,79,99,44);
        Student s4=new Student("zhaoliu",19,69,95,78);
        Student s5=new Student("qianqi",25,79,75,74);
        TreeSet&lt;Student&gt; ts=new TreeSet&lt;&gt;();
        ts.add(s1);
        ts.add(s2);
        ts.add(s3);
        ts.add(s4);
        ts.add(s5);
        for (Student t : ts) {
            System.out.println(t);
        }
    }
}</code></pre> 
<pre><code class="language-java">package study.api;

public class Student implements Comparable&lt;Student&gt;{
    private String name;
    private int age;
    private int chinese;
    private int math;
    private int english;

    public Student() {
    }

    public Student(String name, int age, int chinese, int math, int english) {
        this.name = name;
        this.age = age;
        this.chinese = chinese;
        this.math = math;
        this.english = english;
    }

    /**
     * 获取
     * @return name
     */
    public String getName() {
        return name;
    }

    /**
     * 设置
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * 获取
     * @return age
     */
    public int getAge() {
        return age;
    }

    /**
     * 设置
     * @param age
     */
    public void setAge(int age) {
        this.age = age;
    }

    /**
     * 获取
     * @return chinese
     */
    public int getChinese() {
        return chinese;
    }

    /**
     * 设置
     * @param chinese
     */
    public void setChinese(int chinese) {
        this.chinese = chinese;
    }

    /**
     * 获取
     * @return math
     */
    public int getMath() {
        return math;
    }

    /**
     * 设置
     * @param math
     */
    public void setMath(int math) {
        this.math = math;
    }

    /**
     * 获取
     * @return english
     */
    public int getEnglish() {
        return english;
    }

    /**
     * 设置
     * @param english
     */
    public void setEnglish(int english) {
        this.english = english;
    }

    public String toString() {
        return "Student{name = " + name + ", age = " + age + ", chinese = " + chinese + ", math = " + math + ", english = " + english + "}";
    }

    @Override
    public int compareTo(Student o) {
        int sum1=this.getChinese()+this.getMath()+this.getEnglish();
        int sum2=o.getChinese()+o.getMath()+o.getEnglish();
        int i=sum1-sum2;
        i=i==0?this.getChinese()-o.getChinese():i;
        i=i==0?this.getMath()-o.getMath():i;
        i=i==0?this.getEnglish()-o.getEnglish():i;
        i=i==0?this.getName().compareTo(o.getName()):i;
        return i;
    }

//        如果总分一样，按照语文成绩排
//        如果语文一样，按照数学成绩排
//        如果数学成绩一样，按照英语成绩排
//        如果英文成绩一样，按照年龄排
//        如果年龄一样，按照姓名的字母顺序排
//        如果都一样，认为是同一个学生，不存。
}
</code></pre> 
<p><img alt="" height="672" src="https://images2.imgbox.com/7d/09/9Mm9xtUM_o.png" width="1200"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fef023e4a63a058fe95c9119e10d33d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python数学建模导论1.1 线性代数知识的补充-线性规划方程求解方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19c90e3803a8a20d4d4ee53222c43040/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python数学建模导论1.3非线性规划及其python实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>