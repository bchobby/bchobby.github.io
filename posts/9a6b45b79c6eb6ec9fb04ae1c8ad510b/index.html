<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Filter与Listener（过滤器与监听器） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Filter与Listener（过滤器与监听器）" />
<meta property="og:description" content="1.Filter 1.过滤器概述 过滤器——Filter，它是JavaWeb三大组件之一。另外两个是Servlet和Listener
它可以对web应用中的所有资源进行拦截，并且在拦截之后进行一些特殊的操作
在程序中访问服务器资源时，当一个请求到来，服务器首先判断是否有过滤器与请求资源相关联，如果有，过滤器可以将请求拦截下来，完成一些特定的功能，再由过滤器决定是否交给请求资源。如果没有则像之前那样直接请求资源了。响应也是类似的
过滤器一般用于完成通用的操作，例如：登录验证、统一编码处理、敏感字符过滤等
2.Filter概述 Filter 是一个接口，如果想实现过滤器的功能，必须实现该接口
核心方法
返回值方法名作用voidinit(FilterConfig config)初始化方法voiddoFilter(ServletRequest req,ServletResponse resp,FilterChain chain)对请求资源和响应资源过滤voiddestory()销毁方法 配置方式
注解方式
配置文件 3.FilterChain FilterChain 是一个接口，代表过滤器链对象。由 Servlet 容器提供实现类对象，直接使用即可。
过滤器可以定义多个，就会组成过滤
核心方法
返回值方法名作用voiddoFilter(ServletRequest req,ServletResponse resp)放行方法 如果有多个过滤器，在第一个过滤器中调用下个过滤器，依次类推。直到到达最终访问资源
如果只有一个过滤器，放行时，就会直接到达最终访问资源
4.过滤器的使用 需求说明
通过Filter过滤器解决多个资源写出中文乱码的问题
实现步骤
1.创建一个web项目
2.创建两个Servlet功能类，都向客户端写出中文数据
3.创建一个Filter过滤器实现类，重写doFilter核心方法
4.在方法内部解决中文乱码，并放行
5.部署并启动项目
6.通过浏览器测试
package filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; /* 过滤器基本使用 */ @WebFilter(&#34;/*&#34;) public class FilterDemo01 implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/9a6b45b79c6eb6ec9fb04ae1c8ad510b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-19T17:21:39+08:00" />
<meta property="article:modified_time" content="2023-10-19T17:21:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Filter与Listener（过滤器与监听器）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.Filter</h2> 
<h3>1.过滤器概述</h3> 
<p>过滤器——Filter，它是JavaWeb三大组件之一。另外两个是Servlet和Listener</p> 
<p><strong>它可以对web应用中的所有资源进行拦截，并且在拦截之后进行一些特殊的操作</strong></p> 
<p>在程序中访问服务器资源时，当一个请求到来，服务器首先判断是否有过滤器与请求资源相关联，如果有，过滤器可以将请求拦截下来，完成一些特定的功能，再由过滤器决定是否交给请求资源。如果没有则像之前那样直接请求资源了。响应也是类似的</p> 
<p><strong>过滤器一般用于完成通用的操作</strong>，例如：<strong>登录验证、统一编码处理</strong>、敏感字符过滤等</p> 
<h3>2.Filter概述</h3> 
<p>Filter 是一个接口，如果想实现过滤器的功能，必须实现该接口</p> 
<p><strong>核心方法</strong></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>init(FilterConfig config)</td><td>初始化方法</td></tr><tr><td>void</td><td>doFilter(ServletRequest req,ServletResponse resp,FilterChain chain)</td><td>对请求资源和响应资源过滤</td></tr><tr><td>void</td><td>destory()</td><td>销毁方法</td></tr></tbody></table> 
<p> <strong>配置方式</strong></p> 
<p>        注解方式</p> 
<p>        配置文件 </p> 
<h3>3.FilterChain</h3> 
<p> FilterChain 是一个接口，代表过滤器链对象。由 Servlet 容器提供实现类对象，直接使用即可。</p> 
<p> 过滤器可以定义多个，就会组成过滤</p> 
<p><strong>核心方法</strong></p> 
<p></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>doFilter(ServletRequest req,ServletResponse resp)</td><td>放行方法</td></tr></tbody></table> 
<p>如果有多个过滤器，在第一个过滤器中调用下个过滤器，依次类推。直到到达最终访问资源</p> 
<p>如果只有一个过滤器，放行时，就会直接到达最终访问资源</p> 
<p> <img alt="" height="193" src="https://images2.imgbox.com/7e/28/lAj47WnH_o.png" width="1200"> </p> 
<h3>4.过滤器的使用 </h3> 
<p><strong>需求说明</strong></p> 
<p>通过Filter过滤器解决多个资源写出中文乱码的问题</p> 
<p><strong>实现步骤</strong></p> 
<p>1.创建一个web项目</p> 
<p>2.创建两个Servlet功能类，都向客户端写出中文数据</p> 
<p>3.创建一个Filter过滤器实现类，重写doFilter核心方法</p> 
<p>4.在方法内部解决中文乱码，并放行</p> 
<p>5.部署并启动项目</p> 
<p>6.通过浏览器测试</p> 
<pre><code class="language-java">package filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;
/*
    过滤器基本使用
*/
@WebFilter("/*")
public class FilterDemo01 implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("filterDemo01执行了...");
        //处理乱码
        servletResponse.setContentType("text/html;charset=UTF-8");
        //放行
        filterChain.doFilter(servletRequest,servletResponse);
    }
}
</code></pre> 
<h3>5.过滤器的使用细节</h3> 
<p><strong>配置方式</strong></p> 
<p>         注解方式 @WebFilter(拦截路径)</p> 
<p>         配置文件</p> 
<pre><code class="language-XML">&lt;filter&gt;
    &lt;filter-name&gt;filterDemo01&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.FilterDemo01&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;filterDemo01&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre> 
<p> <strong>多个过滤器使用顺序</strong></p> 
<p>如果有多个过滤器，取决于过滤器映射的顺序</p> 
<p>也就是filter-mapping配置的先后顺序</p> 
<h3>6.过滤器的生命周期</h3> 
<p> 创建（出生）</p> 
<p>当应用加载时实例化对象并执行 init 初始化方法</p> 
<p> 服务（活着）</p> 
<p>对象提供服务的过程，执行 doFilter 方法<br> ​​​​​</p> 
<p>只要应用一直提供服务，对象就一直存在</p> 
<p> 销毁（死亡）</p> 
<p>当应用卸载时或服务器停止时对象销毁。执行 destroy</p> 
<p><strong>Filter的实例对象在内存中也只有一份。所以也是单例的</strong></p> 
<pre><code class="language-java">package filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/*")
public class FilterDemo03 implements Filter {
    //初始化方法
    @Override
    public void init(FilterConfig filterConfig) {
        System.out.println("对象初始化成功了...");
    }

    //提供服务方法
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("filterDemo03执行了...");
        //处理乱码
        servletResponse.setContentType("text/html;charset=UTF-8");
        //放行
        filterChain.doFilter(servletRequest,servletResponse);
    }

    //对象销毁
    @Override
    public void destroy() {
        System.out.println("对象销毁了...");
    }
}

</code></pre> 
<p> web.xml</p> 
<pre><code class="language-XML">&lt;filter&gt;
        &lt;filter-name&gt;filterDemo03&lt;/filter-name&gt;
        &lt;filter-class&gt;filter.FilterDemo03&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;filterDemo03&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre> 
<h3>7.FilterConfig过滤器配置对象</h3> 
<p>FilterConfig 是一个接口。<strong>代表过滤器的配置对象，可以加载一些初始化参数</strong>。与ServletConfig类似</p> 
<p><strong>核心方法</strong></p> 
<p></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String</td><td>getFilterName()</td><td>获取过滤器对象名称</td></tr><tr><td>String</td><td>getInitParameter(String key)</td><td>根据key过去value</td></tr><tr><td>Enumeration</td><td>getInitParameterNames()</td><td>获所有参数的key</td></tr><tr><td>ServletContext</td><td>getServletContext()</td><td>获取应用上下文对象</td></tr></tbody></table> 
<pre><code class="language-java">package filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/*")
public class FilterDemo04 implements Filter {
    //初始化方法
    @Override
    public void init(FilterConfig filterConfig) {

        System.out.println("对象初始化成功了...");
        //获取过滤器名称
        String filterName = filterConfig.getFilterName();
        System.out.println(filterName);
        //根据name获取value
        String username = filterConfig.getInitParameter("username");
        System.out.println(username);
    }

    //提供服务方法
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("filterDemo04执行了...");
        //处理乱码
        servletResponse.setContentType("text/html;charset=UTF-8");
        //放行
        filterChain.doFilter(servletRequest,servletResponse);
    }

    //对象销毁
    @Override
    public void destroy() {
        System.out.println("对象销毁了...");
    }
}

</code></pre> 
<p>web.xml</p> 
<pre><code class="language-XML"> &lt;filter&gt;
        &lt;filter-name&gt;filterDemo04&lt;/filter-name&gt;
        &lt;filter-class&gt;filter.FilterDemo04&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;username&lt;/param-name&gt;
            &lt;param-value&gt;zhangsan&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;filterDemo04&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre> 
<h3>8.过滤器五种拦截行为 </h3> 
<p>Filter 过滤器默认拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，要想使用，就需要我们配置</p> 
<pre><code class="language-XML">&lt;filter&gt;
    &lt;filter-name&gt;filterDemo05&lt;/filter-name&gt;
    &lt;filter-class&gt;Filter.FilterDemo5&lt;/filter-class&gt;
    &lt;!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--&gt;
    &lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;filterDemo05&lt;/filter-name&gt;
    &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;
    &lt;!--过滤请求：默认值。--&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
    &lt;!--过滤全局错误页面：当由服务器调用全局错误页面时，过滤器工作--&gt;
    &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;
    &lt;!--过滤请求转发：当请求转发时，过滤器工作。--&gt;
    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
    &lt;!--过滤请求包含：当请求包含时，过滤器工作。它只能过滤动态包含，jsp的include指令是静态包含，过滤器不会起作用--&gt;
    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
    &lt;!--过滤异步类型，它要求我们在filter标签中配置开启异步支持--&gt;
    &lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre> 
<h2>2.Listener </h2> 
<h3>1.监听器概述</h3> 
<p>观察者设计模式，所有的监听器都是基于观察者设计模式的</p> 
<p><strong>三个组成部分</strong></p> 
<p>事件源：触发事件的对象。</p> 
<p>事件：触发的动作，里面封装了事件源。</p> 
<p>监听器：当事件源触发事件时，要做的事情。一般是一个接口，由使用者来实现。</p> 
<p><strong>监听器：</strong></p> 
<p>在程序当中，我们可以对：对象的创建销毁、域对象中属性的变化、会话相关内容进行监听</p> 
<p>Servlet 规范中共计 8 个监听器，监听器都是以接口形式提供，具体功能需要我们自己来完成</p> 
<h3>2.监听对象的监听器</h3> 
<p><strong>1.ServletContextListener：用于监听 ServletContext 对象的创建和销毁</strong></p> 
<p><strong>核心方法</strong></p> 
<p></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>contextInitialized(ServletContextEvent sce)</td><td>对象创建时执行该方法</td></tr><tr><td>void</td><td>contextDestroyed(ServletContextEvent sce)</td><td>对象销毁时执行该方法</td></tr></tbody></table> 
<p>参数：ServletContextEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 ServletContext</p> 
<p>真正的事件指的是创建或销毁 ServletContext 对象的操作</p> 
<p><strong>2.HttpSessionListener：用于监听 HttpSession 对象的创建和销毁</strong></p> 
<p><strong>核心方法</strong></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>sessionCreated(HttpSessionEvent se)</td><td>对象创建时执行该方法</td></tr><tr><td>void</td><td>sessionDestroyed(HttpSessionEvent se)</td><td>对象销毁时执行该方法</td></tr></tbody></table> 
<p>参数：HttpSessionEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 HttpSession</p> 
<p>真正的事件指的是创建或销毁 HttpSession 对象的操作</p> 
<p><strong>3.ServletRequestListener：用于监听 ServletRequest 对象的创建和销毁</strong></p> 
<p><strong>核心方法</strong></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>requestInitialized(ServletRequestEvent sre)</td><td>对象创建时执行该方法</td></tr><tr><td>void</td><td>requestDestroyed(ServletRequestEvent sre)</td><td>对象销毁时执行该方法</td></tr></tbody></table> 
<p>参数：ServletRequestEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 ServletRequest</p> 
<p>真正的事件指的是创建或销毁 ServletRequest 对象的操作</p> 
<h3>3.监听域对象属性变化的监听器</h3> 
<p><strong>1.ServletContextAttributeListener：用于监听 ServletContext 应用域中属性的变化</strong></p> 
<p><strong>核心方法</strong></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>attributeAdded(ServletContextAttributeEvent scae)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void</td><td>attributeRemoved(ServletContextAttributeEvent scae)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void</td><td>attributeReplaced(ServletContextAttributeEvent scae)</td><td>域中替换属性时执行该方法</td></tr></tbody></table> 
<p>参数：ServletContextAttributeEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 ServletContext</p> 
<p>真正的事件指的是添加、移除、替换应用域中属性的操作</p> 
<p><strong>2.HttpSessionAttributeListener：用于监听 HttpSession 会话域中属性的变化</strong></p> 
<p><strong>核心方法</strong></p> 
<p></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>attributeAdded(ServletSessionBindingEvent se)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void</td><td>attributeRemoved(ServletSessionBindingEvent se)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void</td><td>attributeReplaced(ServletSessionBindingEvent se)</td><td>域中替换属性时执行该方法</td></tr></tbody></table> 
<p>参数：HttpSessionBindingEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 HttpSession</p> 
<p>真正的事件指的是添加、移除、替换会话域中属性的操作</p> 
<p><strong>3.ServletRequestAttributeListener：用于监听 ServletRequest 请求域中属性的变化</strong></p> 
<p><strong>核心方法</strong></p> 
<p></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>attributeAdded(ServletRequestAttributeEvent srae)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void</td><td>attributeRemoved(ServletRequestAttributeEvent srae)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void</td><td>attributeReplaced(ServletRequestAttributeEvent srae)</td><td>域中替换属性时执行该方法</td></tr></tbody></table> 
<p>参数：ServletRequestAttributeEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 ServletRequest</p> 
<p>真正的事件指的是添加、移除、替换请求域中属性的操作</p> 
<h3>4.监听会话相关的感知性监听器</h3> 
<p><strong>1.HttpSessionBindingListener：用于感知对象和会话域绑定的监听器</strong></p> 
<p><strong>核心方法</strong></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>valueBound(HttpSessionBindingEvent event)</td><td>数据添加到会话域中(绑定时)执行该方法</td></tr><tr><td>void</td><td>valueUnbound(HttpSessionBindingEvent event)</td><td>数据从会话域中移除(解绑时)执行该方法</td></tr></tbody></table> 
<p>参数：HttpSessionBindingEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 HttpSession</p> 
<p>真正的事件指的是添加、移除会话域中数据的操作</p> 
<p><strong>2.HttpSessionActivationListener：用于感知会话域中对象钝化和活化的监听器</strong></p> 
<p><strong>核心方法</strong></p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>sessionWillPassivate(HttpSessionEvent se)</td><td>会话域中数据钝化时执行该方法</td></tr><tr><td>void</td><td>sessionDidActivate(HttpSessionEvent se)</td><td>会话域中数据活化时执行该方法</td></tr></tbody></table> 
<p>参数：HttpSessionEvent 代表事件对象</p> 
<p>事件对象中封装了事件源，也就是 HttpSession</p> 
<p>真正的事件指的是会话域中数据钝化、活化的操作</p> 
<h3>5.监听器的使用</h3> 
<p>在实际开发中，我们可以根据具体情况来从这8个监听器中选择使用</p> 
<p>感知型监听器由于无需配置，只需要根据实际需求编写代码</p> 
<h4><strong>ServletContextListener</strong></h4> 
<pre><code class="language-java">package listener;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

/*
    ServletContext对象的创建和销毁的监听器
    //配置监听器：@WebListener
 */
@WebListener
public class ServletContextListenerDemo implements ServletContextListener {
    /*
        ServletContext对象创建的时候执行此方法
     */
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("监听到了对象的创建...");

        //获取对象
        ServletContext servletContext = sce.getServletContext();
        System.out.println(servletContext);

    }

    /*
        ServletContext对象销毁的时候执行此方法
     */
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println("监听到了对象的销毁...");
    }
}
</code></pre> 
<h4><strong>ServletContextAttributeListener</strong></h4> 
<pre><code class="language-java">package listener;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextAttributeEvent;
import javax.servlet.ServletContextAttributeListener;
import javax.servlet.annotation.WebListener;

/*
    应用域对象中的属性变化的监听器
 */
@WebListener
public class ServletContextAttributeListenerDemo implements ServletContextAttributeListener {
    /*
        向应用域对象中添加属性时执行此方法
     */
    @Override
    public void attributeAdded(ServletContextAttributeEvent scae) {
        System.out.println("监听到了属性的添加...");

        //获取应用域对象
        ServletContext servletContext = scae.getServletContext();
        //获取属性
        Object value = servletContext.getAttribute("username");
        System.out.println(value);
    }

    /*
        向应用域对象中替换属性时执行此方法
     */
    @Override
    public void attributeReplaced(ServletContextAttributeEvent scae) {
        System.out.println("监听到了属性的替换...");

        //获取应用域对象
        ServletContext servletContext = scae.getServletContext();
        //获取属性
        Object value = servletContext.getAttribute("username");
        System.out.println(value);
    }

    /*
        向应用域对象中移除属性时执行此方法
     */
    @Override
    public void attributeRemoved(ServletContextAttributeEvent scae) {
        System.out.println("监听到了属性的移除...");

        //获取应用域对象
        ServletContext servletContext = scae.getServletContext();
        //获取属性
        Object value = servletContext.getAttribute("username");
        System.out.println(value);
    }
}

</code></pre> 
<p>修改ServletContextListenerDemo：在contextInitialized中增加</p> 
<pre><code class="language-java">//添加属性
servletContext.setAttribute("username","zhangsan");

//替换属性
servletContext.setAttribute("username","lisi");

//移除属性
servletContext.removeAttribute("username");
</code></pre> 
<p><img alt="" height="515" src="https://images2.imgbox.com/44/44/TjwIEK6Z_o.png" width="708"> <img alt="" height="203" src="https://images2.imgbox.com/40/17/80pjZBsM_o.png" width="474"></p> 
<p><strong>用配置文件方式（第一种为注解方式）</strong></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"&gt;
    &lt;!--配置监听器--&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;listener.ServletContextListenerDemo&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;listener.ServletContextAttributeListenerDemo&lt;/listener-class&gt;
    &lt;/listener&gt;
&lt;/web-app&gt;</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e0a462b3871a6c8109d348f3743ef2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3生成二维码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71b04a0b5ab7e9bace17af40e8e38057/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【CSDN文章代码获取说明】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>