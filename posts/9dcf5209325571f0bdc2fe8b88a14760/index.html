<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringMVC(未完) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringMVC(未完)" />
<meta property="og:description" content="目录
一、SpringMVC简介
1、什么是MVC
2、什么是SpringMVC
3、SpringMVC的特点
二、准备
三、@RequestMapping注解
1、@RequestMapping注解的功能
2、@RequestMapping注解的位置
3、@RequestMapping注解的value属性
4、@RequestMapping注解的method属性
5、@RequestMapping注解的params属性（了解）
6、@RequestMapping注解的headers属性（了解）
7、SpringMVC支持ant风格的路径
8、SpringMVC支持路径中的占位符（重点）
9、get/post的区别！！！！！！！！！！！！！！！！！！！！！！！！
10、一些注意点
四、SpringMVC获取请求参数
1、通过ServletAPI获取
2、通过控制器方法的形参获取请求参数
3、@RequestParam
4、@RequestHeader
5、@CookieValue
6、通过POJO获取请求参数
7、解决获取请求参数的乱码问题
五、域对象共享数据
1、概述
2、使用ServletAPI向request域对象共享数据
3、使用ModelAndView向request域对象共享数据
4、使用Model向request域对象共享数据
5、使用map向request域对象共享数据
6、使用ModelMap向request域对象共享数据
7、Model、ModelMap、Map的关系
8、向session域共享数据
9、向application域共享数据
六、SpringMVC的视图
1、ThymeleafView
2、转发视图
3、重定向视图
4、视图控制器view-controller-在springMVC.xml文件中配置
5、请求转发和重定向的区别
七、RESTful p50/53的源码还没看
1、RESTful简介
2、RESTful的实现
3、DELETE 用来删除资源：
八、HttpMessageConverter
1、@RequestBody-这是注解，标识形参
2、RequestEntity-这是类型
3、@ResponseBody-注解，标识方法
4、SpringMVC处理json
5、注解驱动的作用
6、SpringMVC处理ajax
7、@RestController注解
8、ResponseEntity
九、文件上传和下载
1、文件下载
2、文件上传
十、拦截器
1、拦截器的配置
2、拦截器的三个抽象方法
3、多个拦截器的执行顺序
十一、异常处理器
十二、注解配置SpringMVC
1、创建初始化类，代替web.xml
一、SpringMVC简介 1、什么是MVC M:模型层（model）包括service，dao，pojo" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/9dcf5209325571f0bdc2fe8b88a14760/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-10T14:29:27+08:00" />
<meta property="article:modified_time" content="2022-05-10T14:29:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringMVC(未完)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81SpringMVC%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81SpringMVC%E7%AE%80%E4%BB%8B" rel="nofollow">一、SpringMVC简介</a></p> 
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVC-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVC" rel="nofollow">1、什么是MVC</a></p> 
<p id="2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC" rel="nofollow">2、什么是SpringMVC</a></p> 
<p id="3%E3%80%81SpringMVC%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#3%E3%80%81SpringMVC%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">3、SpringMVC的特点</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%87%86%E5%A4%87-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%87%86%E5%A4%87" rel="nofollow">二、准备</a></p> 
<p id="%E4%B8%89%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3" rel="nofollow">三、@RequestMapping注解</a></p> 
<p id="1%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#1%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8A%9F%E8%83%BD" rel="nofollow">1、@RequestMapping注解的功能</a></p> 
<p id="2%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow">2、@RequestMapping注解的位置</a></p> 
<p id="3%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84value%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#3%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84value%E5%B1%9E%E6%80%A7" rel="nofollow">3、@RequestMapping注解的value属性</a></p> 
<p id="4%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84method%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#4%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84method%E5%B1%9E%E6%80%A7" rel="nofollow">4、@RequestMapping注解的method属性</a></p> 
<p id="5%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84params%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:40px;"><a href="#5%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84params%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">5、@RequestMapping注解的params属性（了解）</a></p> 
<p id="6%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84headers%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:40px;"><a href="#6%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84headers%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">6、@RequestMapping注解的headers属性（了解）</a></p> 
<p id="7%E3%80%81SpringMVC%E6%94%AF%E6%8C%81ant%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84-toc" style="margin-left:40px;"><a href="#7%E3%80%81SpringMVC%E6%94%AF%E6%8C%81ant%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84" rel="nofollow">7、SpringMVC支持ant风格的路径</a></p> 
<p id="8%E3%80%81SpringMVC%E6%94%AF%E6%8C%81%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#8%E3%80%81SpringMVC%E6%94%AF%E6%8C%81%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">8、SpringMVC支持路径中的占位符（重点）</a></p> 
<p id="9%E3%80%81get%2Fpost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81-toc" style="margin-left:40px;"><a href="#9%E3%80%81get%2Fpost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81" rel="nofollow">9、get/post的区别！！！！！！！！！！！！！！！！！！！！！！！！</a></p> 
<p id="10%E3%80%81%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9-toc" style="margin-left:40px;"><a href="#10%E3%80%81%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9" rel="nofollow">10、一些注意点</a></p> 
<p id="%E5%9B%9B%E3%80%81SpringMVC%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81SpringMVC%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0" rel="nofollow">四、SpringMVC获取请求参数</a></p> 
<p id="1%E3%80%81%E9%80%9A%E8%BF%87ServletAPI%E8%8E%B7%E5%8F%96-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%80%9A%E8%BF%87ServletAPI%E8%8E%B7%E5%8F%96" rel="nofollow">1、通过ServletAPI获取</a></p> 
<p id="2%E3%80%81%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0" rel="nofollow">2、通过控制器方法的形参获取请求参数</a></p> 
<p id="3%E3%80%81%40RequestParam-toc" style="margin-left:40px;"><a href="#3%E3%80%81%40RequestParam" rel="nofollow">3、@RequestParam</a></p> 
<p id="4%E3%80%81%40RequestHeader-toc" style="margin-left:40px;"><a href="#4%E3%80%81%40RequestHeader" rel="nofollow">4、@RequestHeader</a></p> 
<p id="5%E3%80%81%40CookieValue-toc" style="margin-left:40px;"><a href="#5%E3%80%81%40CookieValue" rel="nofollow">5、@CookieValue</a></p> 
<p id="6%E3%80%81%E9%80%9A%E8%BF%87POJO%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E9%80%9A%E8%BF%87POJO%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0" rel="nofollow">6、通过POJO获取请求参数</a></p> 
<p id="7%E3%80%81%E8%A7%A3%E5%86%B3%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E8%A7%A3%E5%86%B3%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98" rel="nofollow">7、解决获取请求参数的乱码问题</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">五、域对象共享数据</a></p> 
<p id="1%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow">1、概述</a></p> 
<p id="2%E3%80%81%E4%BD%BF%E7%94%A8ServletAPI%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%BD%BF%E7%94%A8ServletAPI%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">2、使用ServletAPI向request域对象共享数据</a></p> 
<p id="3%E3%80%81%E4%BD%BF%E7%94%A8ModelAndView%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BD%BF%E7%94%A8ModelAndView%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">3、使用ModelAndView向request域对象共享数据</a></p> 
<p id="4%E3%80%81%E4%BD%BF%E7%94%A8Model%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%BD%BF%E7%94%A8Model%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">4、使用Model向request域对象共享数据</a></p> 
<p id="5%E3%80%81%E4%BD%BF%E7%94%A8map%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E4%BD%BF%E7%94%A8map%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">5、使用map向request域对象共享数据</a></p> 
<p id="6%E3%80%81%E4%BD%BF%E7%94%A8ModelMap%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E4%BD%BF%E7%94%A8ModelMap%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">6、使用ModelMap向request域对象共享数据</a></p> 
<p id="7%E3%80%81Model%E3%80%81ModelMap%E3%80%81Map%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#7%E3%80%81Model%E3%80%81ModelMap%E3%80%81Map%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">7、Model、ModelMap、Map的关系</a></p> 
<p id="8%E3%80%81%E5%90%91session%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E5%90%91session%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">8、向session域共享数据</a></p> 
<p id="9%E3%80%81%E5%90%91application%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#9%E3%80%81%E5%90%91application%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">9、向application域共享数据</a></p> 
<p id="%E5%85%AD%E3%80%81SpringMVC%E7%9A%84%E8%A7%86%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81SpringMVC%E7%9A%84%E8%A7%86%E5%9B%BE" rel="nofollow">六、SpringMVC的视图</a></p> 
<p id="1%E3%80%81ThymeleafView-toc" style="margin-left:40px;"><a href="#1%E3%80%81ThymeleafView" rel="nofollow">1、ThymeleafView</a></p> 
<p id="2%E3%80%81%E8%BD%AC%E5%8F%91%E8%A7%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%BD%AC%E5%8F%91%E8%A7%86%E5%9B%BE" rel="nofollow">2、转发视图</a></p> 
<p id="3%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E8%A7%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E8%A7%86%E5%9B%BE" rel="nofollow">3、重定向视图</a></p> 
<p id="4%E3%80%81%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8view-controller-%E5%9C%A8springMVC.xml%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8view-controller-%E5%9C%A8springMVC.xml%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE" rel="nofollow">4、视图控制器view-controller-在springMVC.xml文件中配置</a></p> 
<p id="5%E3%80%81%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">5、请求转发和重定向的区别</a></p> 
<p id="%E4%B8%83%E3%80%81RESTful%20p50%2F53%E7%9A%84%E6%BA%90%E7%A0%81%E8%BF%98%E6%B2%A1%E7%9C%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81RESTful%20p50%2F53%E7%9A%84%E6%BA%90%E7%A0%81%E8%BF%98%E6%B2%A1%E7%9C%8B" rel="nofollow">七、RESTful p50/53的源码还没看</a></p> 
<p id="1%E3%80%81RESTful%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81RESTful%E7%AE%80%E4%BB%8B" rel="nofollow">1、RESTful简介</a></p> 
<p id="2%E3%80%81RESTful%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2%E3%80%81RESTful%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2、RESTful的实现</a></p> 
<p id="3%E3%80%81DELETE%20%E7%94%A8%E6%9D%A5%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3%E3%80%81DELETE%20%E7%94%A8%E6%9D%A5%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90%EF%BC%9A" rel="nofollow">3、DELETE 用来删除资源：</a></p> 
<p id="%E5%85%AB%E3%80%81HttpMessageConverter-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81HttpMessageConverter" rel="nofollow">八、HttpMessageConverter</a></p> 
<p id="1%E3%80%81%40RequestBody-%E8%BF%99%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%A0%87%E8%AF%86%E5%BD%A2%E5%8F%82-toc" style="margin-left:40px;"><a href="#1%E3%80%81%40RequestBody-%E8%BF%99%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%A0%87%E8%AF%86%E5%BD%A2%E5%8F%82" rel="nofollow">1、@RequestBody-这是注解，标识形参</a></p> 
<p id="2%E3%80%81RequestEntity-%E8%BF%99%E6%98%AF%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2%E3%80%81RequestEntity-%E8%BF%99%E6%98%AF%E7%B1%BB%E5%9E%8B" rel="nofollow">2、RequestEntity-这是类型</a></p> 
<p id="3%E3%80%81%40ResponseBody-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%A0%87%E8%AF%86%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3%E3%80%81%40ResponseBody-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%A0%87%E8%AF%86%E6%96%B9%E6%B3%95" rel="nofollow">3、@ResponseBody-注解，标识方法</a></p> 
<p id="4%E3%80%81SpringMVC%E5%A4%84%E7%90%86json-toc" style="margin-left:40px;"><a href="#4%E3%80%81SpringMVC%E5%A4%84%E7%90%86json" rel="nofollow">4、SpringMVC处理json</a></p> 
<p id="5%E3%80%81%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">5、注解驱动的作用</a></p> 
<p id="6%E3%80%81SpringMVC%E5%A4%84%E7%90%86ajax-toc" style="margin-left:40px;"><a href="#6%E3%80%81SpringMVC%E5%A4%84%E7%90%86ajax" rel="nofollow">6、SpringMVC处理ajax</a></p> 
<p id="7%E3%80%81%40RestController%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#7%E3%80%81%40RestController%E6%B3%A8%E8%A7%A3" rel="nofollow">7、@RestController注解</a></p> 
<p id="8%E3%80%81ResponseEntity-toc" style="margin-left:40px;"><a href="#8%E3%80%81ResponseEntity" rel="nofollow">8、ResponseEntity</a></p> 
<p id="%E4%B9%9D%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD" rel="nofollow">九、文件上传和下载</a></p> 
<p id="1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD" rel="nofollow">1、文件下载</a></p> 
<p id="2%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0" rel="nofollow">2、文件上传</a></p> 
<p id="%E5%8D%81%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8" rel="nofollow">十、拦截器</a></p> 
<p id="1%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE" rel="nofollow">1、拦截器的配置</a></p> 
<p id="2%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95" rel="nofollow">2、拦截器的三个抽象方法</a></p> 
<p id="3%E3%80%81%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" rel="nofollow">3、多个拦截器的执行顺序</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8" rel="nofollow">十一、异常处理器</a></p> 
<p id="%E5%8D%81%E4%BA%8C%E3%80%81%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AESpringMVC-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AESpringMVC" rel="nofollow">十二、注解配置SpringMVC</a></p> 
<p id="1%E3%80%81%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%EF%BC%8C%E4%BB%A3%E6%9B%BFweb.xml-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%EF%BC%8C%E4%BB%A3%E6%9B%BFweb.xml" rel="nofollow">1、创建初始化类，代替web.xml</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81SpringMVC%E7%AE%80%E4%BB%8B">一、SpringMVC简介</h2> 
<h3 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVC">1、<span style="color:#fe2c24;">什么是MVC</span></h3> 
<p>M:模型层（model）包括service，dao，pojo</p> 
<p>V:视图层 (view) 包括html，js等</p> 
<p>C:控制层(controller) 就是controller</p> 
<h3 id="2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC">2、什么是SpringMVC</h3> 
<p>        SpringMVC 是 Spring 为<span style="color:#fe2c24;">表述层</span>开发提供的一整套完备的解决方案</p> 
<p>        三层架构分为</p> 
<p>                表述层（或表示层）</p> 
<p>                业务逻辑层</p> 
<p>                数据访问层（或持久层）</p> 
<p>         表述层表示前台页面和后台 servlet</p> 
<h3 id="3%E3%80%81SpringMVC%E7%9A%84%E7%89%B9%E7%82%B9">3、SpringMVC的特点</h3> 
<p>Spring 家族原生产品，与 IOC 容器等基础设施无缝对接</p> 
<p>基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一 处理</p> 
<p>表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案</p> 
<p>代码清新简洁，大幅度提升开发效率</p> 
<p>内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可</p> 
<p>性能卓著，尤其适合现代大型、超大型互联网项目要求</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%87%86%E5%A4%87">二、准备</h2> 
<p>1、引入依赖</p> 
<pre><code class="language-XML">&lt;dependencies&gt;
    &lt;!-- SpringMVC --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- ServletAPI --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring5和Thymeleaf整合包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;
        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;
        &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<p>2、<strong><span style="color:#fe2c24;">配置web.xml——注册SpringMVC的前端控制器DispatcherServlet</span></strong></p> 
<p>有两种方式：</p> 
<p>（1）默认配置方式</p> 
<p>        此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为- servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVCservlet.xml</p> 
<p>（2）<span style="color:#fe2c24;">扩展配置方式（仔细看注解）</span>，如下</p> 
<p>        可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置 SpringMVC前端控制器DispatcherServlet的初始化时间</p> 
<pre><code class="language-XML">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;
        &lt;init-param&gt;
            &lt;!-- contextConfigLocation为固定值 --&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!-- 使用classpath:表示从类路径查找配置文件，就是maven工程中的src/main/resources 和src/main/java 两个文件夹--&gt;
            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--
        作为框架的核心组件，在启动过程中有大量的初始化操作要做
        而这些操作放在第一次请求时才执行会严重影响访问速度
        因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
        --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
        &lt;!--
        &lt;url-pattern&gt;标签中使用/和/*的区别：
        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请
        求
        因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面
        /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写
        法
        --&gt;
    &lt;/servlet-mapping&gt;</code></pre> 
<pre><code class="language-java">@Controller
public class HelloController {

    @RequestMapping(value = "/")
    public String index(){
        return "index";
    }
    @RequestMapping("/hello")
    public String hello(){

        return "hello";
    }

}</code></pre> 
<p><span style="color:#fe2c24;"><strong> ①xmlns:th="http://www.thymeleaf.org"             一定要写</strong></span></p> 
<p><span style="color:#fe2c24;"> ② &lt;a th:href="@{/hello}"&gt;跳转hello.html&lt;/a&gt;   中的 th:href="@{/hello}"    即去找controller中的@RequestMapping("/hello")   他们 是一一对应的</span></p> 
<p>       &lt;a href="/hello.html"&gt;跳转hello&lt;/a&gt;      中&lt;a href="/hello.html"&gt;是绝对路径，指的是http://localhost:8080//hello.html</p> 
<p><span style="color:#fe2c24;"> </span><span style="color:#0d0016;">③注解中@RequestMapping(value = "/") 只有value一个值，可以省略成@RequestMapping("/") </span></p> 
<p><span style="color:#0d0016;">             @RequestMapping(value = "/")  这种写法即是主页</span></p> 
<p><span style="color:#fe2c24;">④WEB-INF中的文件，客户端是无法直接访问的，重定向也不可以，所有要用请求转发</span></p> 
<pre><code class="language-XML">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;INDEX1&lt;/h1&gt;
    &lt;a th:href="@{/hello}"&gt;跳转hello.html&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong>3、总结</strong></span></p> 
<p><strong>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器 DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器， 将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的 控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会 被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视 图所对应页面</strong></p> 
<h2 id="%E4%B8%89%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3"><strong>三、@RequestMapping注解</strong></h2> 
<h3 id="1%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8A%9F%E8%83%BD">1、@RequestMapping注解的功能</h3> 
<p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联 起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p> 
<h3 id="2%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%8D%E7%BD%AE">2、@RequestMapping注解的位置</h3> 
<p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p> 
<p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p> 
<p>如果类和方法上都写了注解</p> 
<pre><code class="language-java">@Controller
@RequestMapping("/test")
public class RequestMappingController {
    //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping
    @RequestMapping("/testRequestMapping")
    public String testRequestMapping(){
        return "success";
    }
}</code></pre> 
<h3 id="3%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84value%E5%B1%9E%E6%80%A7">3、@RequestMapping注解的value属性</h3> 
<p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p> 
<p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求，<span style="color:#fe2c24;">如果是多个请求映射，请求地址只要满足其中一个就可以匹配</span></p> 
<p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p> 
<h3 id="4%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84method%E5%B1%9E%E6%80%A7">4、@RequestMapping注解的method属性</h3> 
<p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p> 
<p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配 多种请求方式的请求，<span style="color:#fe2c24;">如果有多个method属性，那么请求方式只需要满足其中一个就可以</span></p> 
<p><span style="color:#fe2c24;">若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错 405：Request method 'POST' not supported</span></p> 
<p><span style="color:#fe2c24;">派生注解：</span></p> 
<p>@RequestMapping(value = "/test1",method = RequestMethod.POST) 等价于 @PostMapping("/test1")</p> 
<p>@RequestMapping(value = "/test1",method = RequestMethod.GET) 等价于 @GetMapping("/test1")</p> 
<p>@RequestMapping(value = "/test1",method = RequestMethod.PUT) 等价于 @PutMapping("/test1")</p> 
<p>@RequestMapping(value = "/test1",method = RequestMethod.DELETE) 等价于 @DeleteMapping("/test1")</p> 
<h3 id="5%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84params%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">5、@RequestMapping注解的params属性（了解）</h3> 
<p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p> 
<p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数 和请求映射的匹配关系<span style="color:#fe2c24;">，如果数组有多个参数，请求链接所含参数必须满足所以条件</span></p> 
<p>"param"：要求请求映射所匹配的请求必须携带param请求参数</p> 
<p>"!param"：要求请求映射所匹配的请求必须不能携带param请求参数</p> 
<p>"param=value"：要求请求映射所匹配的请求必须携带param请求参数且param=value</p> 
<p>"param!=value"：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p> 
<pre><code class="language-java">@RequestMapping(value = "/test5",params ={"!username"})//请求参数中没有请求参数名为username的参数</code></pre> 
<pre><code class="language-java">@RequestMapping(value = "/test5",params ={"username"})//请求参数中必须有请求参数名为username的参数</code></pre> 
<pre><code class="language-java">//需要满足两个条件：有参数名为username且参数值是admin的参数
//                    有参数名为pwd且参数值是123的参数
@RequestMapping(value = "/test5",params = {"username=admin","pwd=123"})</code></pre> 
<pre><code class="language-java">//需要满足两个条件：有参数名为username且参数值不是admin的参数
//                    有参数名为pwd且参数值是123的参数
@RequestMapping(value = "/test5",params = {"username!=admin","pwd=123"})</code></pre> 
<h3 id="6%E3%80%81%40RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84headers%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">6、@RequestMapping注解的headers属性（了解）</h3> 
<p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p> 
<p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信 息和请求映射的匹配关系</p> 
<p>"header"：要求请求映射所匹配的请求必须携带header请求头信息</p> 
<p>"!header"：要求请求映射所匹配的请求必须不能携带header请求头信息</p> 
<p>"header=value"：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p> 
<p>"header!=value"：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p> 
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面 显示404错误，即资源未找到</p> 
<h3 id="7%E3%80%81SpringMVC%E6%94%AF%E6%8C%81ant%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84">7、SpringMVC支持ant风格的路径</h3> 
<p>？：表示任意的单个字符</p> 
<p>*：表示任意的0个或多个字符</p> 
<p>**：表示任意的一层或多层目录</p> 
<p>注意：在使用**时，只能使用/**/xxx的方式</p> 
<p><span style="color:#fe2c24;">是写在@RequestMapping(value="/xxxxx")的value中的</span></p> 
<pre><code class="language-java">@RequestMapping("/a**d/test6")</code></pre> 
<p>th:href="@{/a/b/c/d/text6}"    是对的</p> 
<p>th:href="@{/afd/b/c/d/text6}"  是错的        在使用**时，只能使用/**/xxx的方式</p> 
<pre><code class="language-java">@RequestMapping("/a?d/test6")</code></pre> 
<p>th:href="@{/abd/text6}"    是对的</p> 
<p>特别地 th:href="@{/a/d/text6}"    和  th:href="@{/a?d/text6}"  是错的</p> 
<h3 id="8%E3%80%81SpringMVC%E6%94%AF%E6%8C%81%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span style="color:#fe2c24;"><strong>8、SpringMVC支持路径中的占位符（重点）</strong></span></h3> 
<p><span style="color:#0d0016;">原始 的的传入参数的方式    </span>/deleteUser?id=1</p> 
<pre><code class="language-XML">&lt;a th:href="@{/deleteUser?id=1}"&gt;&lt;/a&gt;&lt;br&gt;
或者
&lt;a th:href="@{/deleteUser(username='admin')}"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a th:href="@{/deleteUser(id=1)}"&gt;&lt;/a&gt;&lt;br&gt;</code></pre> 
<p> rest方式：/deleteUser/1</p> 
<pre><code class="language-XML">&lt;a th:href="@{/testRest/1/admin}"&gt;&lt;/a&gt;
</code></pre> 
<pre><code class="language-java">@RequestMapping("/testRest/{id}/{username}")
public String testRest(@PathVariable("id") String id, @PathVariable("username") String username){
    System.out.println("id:"+id+",username:"+username);
    return "success";
}
//最终输出的内容为--&gt;id:1,username:admin
</code></pre> 
<p>注意：如果请求映射写成</p> 
<pre><code class="language-java">@RequestMapping("/testRest/{id}/{username}")</code></pre> 
<p>而请求地址写   下面这样都是错的</p> 
<pre><code class="language-XML">&lt;a th:href="@{/testRest}"&gt;&lt;/a&gt;
&lt;a th:href="@{/testRest/}"&gt;&lt;/a&gt;</code></pre> 
<p></p> 
<h3 id="9%E3%80%81get%2Fpost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81"><span style="color:#fe2c24;"><span style="background-color:#be191c;">9、get/post的区别！！！！！！！！！！！！！！！！！！！！！！！！</span></span></h3> 
<p>POST：</p> 
<p>①、参数不会拼接再请求地址后，会放在请求体中，所以post有请求体，get没有</p> 
<p>②、post相对安全</p> 
<p>③、post传输速度相对慢</p> 
<p>④、传输数据量大，可以认为是无限制的</p> 
<p>⑤、文件上传使用post</p> 
<p>GET：</p> 
<p>①、每当使用get请求方式提交参数，请求参数会拼接在请求在请求地址后，用？来拼接，后面是请求参数名=请求参数值&amp;请求参数名=请求参数值。。。</p> 
<p>②、因为会将参数放在地址栏，所以不安全</p> 
<p>③、因为是伴随着地址传输，所以get传输速度快</p> 
<p>④、传输数据量小</p> 
<p>⑤、文件不可能拼接在地址中，如果使用get方式在传文件，地址栏传输的是文件的名称，所以上传文件不适用get</p> 
<h3 id="10%E3%80%81%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9">10、一些注意点</h3> 
<p>1）、@RequestMapping中的method方式对应着各个操作</p> 
<p>get-查找        post-添加        delete-删除        put-修改</p> 
<p>2）超链接，提交表单 默认都是get请求方式</p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81SpringMVC%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0">四、SpringMVC获取请求参数</h2> 
<h3 id="1%E3%80%81%E9%80%9A%E8%BF%87ServletAPI%E8%8E%B7%E5%8F%96">1、通过ServletAPI获取</h3> 
<p>        将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请 求的请求报文的对象</p> 
<p>        注意：①HttpServletRequest request   不是 HttpRequest request</p> 
<p>                       ② 如果有多个同名的参数，比如使用表单中的复选框，使用  request.getParameterValues()来获取请求参数，返回一个数组</p> 
<p>                                ③如果使用占位符传参数，就不能使用servletAPI接收数据，因为占位符传参，不会告诉参数名</p> 
<pre><code class="language-java">@RequestMapping("/testParam")
public String testParam(HttpServletRequest request){
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    System.out.println("username:"+username+",password:"+password);
    return "success";
}
</code></pre> 
<h3 id="2%E3%80%81%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0">2、通过控制器方法的形参获取请求参数</h3> 
<p>①设置和<span style="color:#fe2c24;">请求参数同名的形参</span>，当浏览器发送请求，匹配到请求映射时，在 DispatcherServlet中就会将请求参数赋值给相应的形参</p> 
<pre><code class="language-XML">&lt;a th:href="@{/testParam(username='admin',password=123456)}"&gt;&lt;/a&gt;</code></pre> 
<pre><code class="language-java">@RequestMapping("/testParam")
public String testParam(String username, String password){
    System.out.println("username:"+username+",password:"+password);
    return "success";
}
</code></pre> 
<p>②如果有多个同名参数（一个直接用字符串接受，一个用数组/LIst集合）</p> 
<p>用List 可以直接批量操作  ，比较好,但是需要@RequestParam</p> 
<pre><code class="language-XML">&lt;form th:action="@{/testArr}"&gt;
    用户名:&lt;input type="text" name="username"&gt;&lt;br&gt;
    密码：&lt;input type="password" name="password"&gt;&lt;br&gt;
    兴趣：&lt;input type="checkbox" name="hobby" value="c++"&gt;c++
    &lt;input type="checkbox" name="hobby" value="java"&gt;java
    &lt;input type="checkbox" name="hobby" value="python"&gt;python
    &lt;input type="submit" value="测试使用控制器的形参数组获取请求参数"&gt;&lt;br&gt;
&lt;/form&gt;</code></pre> 
<pre><code class="language-java">@RequestMapping("/testArr")
    public String testArr(String username,String password,String hobby){
        System.out.println("username:"+username);
        System.out.println("password:"+password);
        System.out.println("hobby:"+ hobby);

        return "success";
    }
/*输出
username:18852895554
password:1231
hobby:c++,java,python


*/</code></pre> 
<pre><code class="language-java">@RequestMapping("/testArr")
    public String testArr(String username,String password,String[] hobby){
        System.out.println("username:"+username);
        System.out.println("password:"+password);
        System.out.println("hobby:"+ Arrays.toString(hobby));

        return "success";
    }
/*输出
username:18852895554
password:213
hobby:[c++, java, python]

*/</code></pre> 
<h3 id="3%E3%80%81%40RequestParam">3、@RequestParam</h3> 
<p><strong><span style="color:#fe2c24;">将@RequestParam 的value中的对应的请求参数的值赋值给后面的形参</span></strong></p> 
<p>①@RequestParam是将请求参数和控制器方法的形参创建映射关系</p> 
<p>@RequestParam注解一共有三个属性：</p> 
<p>value：指定为形参赋值的请求参数的参数名</p> 
<p>required：设置是否必须传输此请求参数，默认值为true</p> 
<p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue属性，则页面报错400：Required String parameter 'xxx' is not present；若设置为 false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为 null</p> 
<p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值 为""时，则使用默认值为形参赋值</p> 
<pre><code class="language-XML">&lt;a th:href="@{/testRequestParam(user_name='admin',pwd=123)}"&gt;&lt;/a&gt;
</code></pre> 
<pre><code class="language-java">    @RequestMapping("/testRequestParam")
    public String testRequestParam(@RequestParam("user_name") String username,
                                   Integer pwd){
        System.out.println(username);
        System.out.println(pwd);
        return "success";
    }</code></pre> 
<pre><code class="language-java">//这样就会报错
@RequestMapping("/testRequestParam")
    public String testRequestParam(@RequestParam(value = "username") String username,
                                   Integer pwd){
        System.out.println(username);
        System.out.println(pwd);
        return "success";
    }</code></pre> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;">② @RequestParam的源码</span></p> 
<pre><code class="language-java">@Target({ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RequestParam {
    @AliasFor("name")
    String value() default "";

    @AliasFor("value")
    String name() default "";
    //必须自动装配
    //当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue    属性，则页面报错400：Required String parameter 'xxx' is not present；
    
    boolean required() default true;

    String defaultValue() default "\n\t\t\n\t\t\n\ue000\ue001\ue002\n\t\t\t\t\n";
}</code></pre> 
<p>③、如果设置了defaultValue，就不会报错</p> 
<pre><code class="language-java">    @RequestMapping("/testRequestParam")
    public String testRequestParam(@RequestParam(value = "user_name",defaultValue = "shihao") String username,
                                   Integer pwd){
      
        return "success";
    }</code></pre> 
<p>④、@RequestParam(value = "user_name",required=false) String username</p> 
<p>也不会自动装配，即使没有名字为user_name的参数也不会报错</p> 
<h3 id="4%E3%80%81%40RequestHeader">4、@RequestHeader</h3> 
<p>①、</p> 
<p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p> 
<p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p> 
<p>如果要正常接收，@RequestHeader中value的写法是固定的，只有下面两种，value要么写Host要么host，不能修改</p> 
<pre><code class="language-XML">@RequestHeader(value = Host", required = true) String host</code></pre> 
<pre><code class="language-java">@RequestHeader(value = host", required = true) String host</code></pre> 
<p> ②、如果不设置defaultvalue且required = true，那么传过来的请求地址就必须有请求头</p> 
<h3 id="5%E3%80%81%40CookieValue">5、@CookieValue</h3> 
<p>①、session依赖于cookie，cookie是客户端的会话技术，session是服务器的会话技术</p> 
<p>每次执行getsession的时候，会检测请求报文中是否有cookie，如果没有，就说明这是第一个getsession，就会先创建session对象，放在服务器维护的map集合中，并创建cookie ，key是固定的JSESSIONID，value是随机序列，通过响应报文response headers传给浏览器，以后就都在请求报文中了</p> 
<p>所以使用@CookieValue一定要确保，之前执行过getsession</p> 
<p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p> 
<p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p> 
<h3 id="6%E3%80%81%E9%80%9A%E8%BF%87POJO%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0">6、通过POJO获取请求参数</h3> 
<p>       ①、 可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实 体类中的属性名一致，那么请求参数就会为此属性赋值</p> 
<p>        ②、如果某个属性没有就赋值null</p> 
<p></p> 
<h3 id="7%E3%80%81%E8%A7%A3%E5%86%B3%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98">7、解决获取请求参数的乱码问题</h3> 
<p>①、get方式出现乱码的原因是由Tomcat产生的，解决方法是再在Tomcat的conf文件夹下的server.xml中添加</p> 
<p>②、在web.xml中，设置了dispatcher启动顺序（用&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;），是跟服务器一起启动的，所以需要在服务器中找一个组件，先于servlet启动，服务器有三大组件（监听器，过滤器，servlet），监听器的加载时间最早，然后过滤器，最后servlet</p> 
<p>③、过滤器有三个方法：</p> 
<p>        初始化；</p> 
<p>        执行过滤<img alt="" height="25" src="https://images2.imgbox.com/3e/99/mcrQYSdZ_o.png" width="623"></p> 
<p><strong><span style="color:#fe2c24;">                以后看关于过滤器的源码，有FilterChain参数的就是执行过滤的方法 </span></strong></p> 
<p>        销毁；</p> 
<p>④、过滤器的执行顺序是按&lt;filter-mapping&gt;的部署顺序，所以characterEncodingFilter需要放在第一个</p> 
<p>⑤、解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是 必须在web.xml中进行注册</p> 
<p><span style="color:#fe2c24;"><strong>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</strong></span></p> 
<pre><code class="language-XML">    &lt;filter&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre> 
<p><strong>上面的两个&lt;init-param&gt;是给CharacterEncodingFilter传参</strong></p> 
<p><strong><span style="color:#fe2c24;"> CharacterEncodingFilter源码</span></strong></p> 
<p><strong><span style="color:#fe2c24;">        需要给请求编码和响应编码设置UTF-8就要使两个if里的条件变为true，即forceResponseEncoding=true，encoding有值，request.getCharacterEncoding()默认是null</span></strong></p> 
<pre><code class="language-java">protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String encoding = this.getEncoding();
        if (encoding != null) {
            if (this.isForceRequestEncoding() || request.getCharacterEncoding() == null) {
                request.setCharacterEncoding(encoding);
            }

            if (this.isForceResponseEncoding()) {
                response.setCharacterEncoding(encoding);
            }
        }

        filterChain.doFilter(request, response);
}</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">五、域对象共享数据</h2> 
<h3 id="1%E3%80%81%E6%A6%82%E8%BF%B0">1、概述</h3> 
<p>①、一共有四个域对象：</p> 
<p>servletcontext（application）：范围是服务器的开启到关闭</p> 
<p>session：一次会话指的是<span style="color:#fe2c24;">浏览器的开启到关闭，跟服务器是否关闭无关</span></p> 
<p>                session的钝化：浏览器没关，服务器关闭，此时会话仍在继续，原先存在session上的数据，经过序列化存放在磁盘上</p> 
<p>                                活化：钝化后，服务器重启（此时浏览器没有关闭），将钝化的数据重新读取到session中</p> 
<p>request：范围是一次请求，所以通过请求转发后，仍可以访问request域中的共享数据</p> 
<p>pagecontext：</p> 
<p>②Q:为什么不怎么用servletcontext和pagecontext</p> 
<p>A:一个范围太大，一个范围太小</p> 
<p>③Q:只要能放在request中的数据，也可以放在session/servletcontext中，那为什么还要用request呢？</p> 
<p>A:因为频繁的增删改查，数据一直发生变化，我们每次都要重新获取，使用session/servletcontext就浪费空间，应选择一个能实现功能且范围最小的域对象。</p> 
<p>④、每一个域对象对域对象操作的三个方法：setAttribute，getAttribute，removeAttribute</p> 
<p>⑤、使用域对象servletcontext共享数据，在html中使用${application.id}   获取共享数据</p> 
<p>        使用域对象session共享数据，在html中使用${session.id}   获取共享数据</p> 
<p>        使用域对象servletcontext共享数据，在html中使用${id}   获取共享数据</p> 
<p>⑥、</p> 
<h3 id="2%E3%80%81%E4%BD%BF%E7%94%A8ServletAPI%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">2、使用ServletAPI向request域对象共享数据</h3> 
<pre><code class="language-java">@RequestMapping("/testServletAPI")
public String testServletAPI(HttpServletRequest request){
    request.setAttribute("testScope", "hello,servletAPI");
    return "success";
}
</code></pre> 
<h3 id="3%E3%80%81%E4%BD%BF%E7%94%A8ModelAndView%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">3、使用ModelAndView向request域对象共享数据</h3> 
<p><span style="color:#fe2c24;">返回类型不是String</span></p> 
<pre><code class="language-java">@RequestMapping("/testModelAndView")
public ModelAndView testModelAndView(){
    /**
    * ModelAndView有Model和View的功能
    * Model主要用于向请求域共享数据
    * View主要用于设置视图，实现页面跳转
    */
    ModelAndView mav = new ModelAndView();
    //向请求域共享数据
    mav.addObject("testScope", "hello,ModelAndView");
    //设置视图，实现页面跳转
    mav.setViewName("success");
    return mav;
}
</code></pre> 
<h3 id="4%E3%80%81%E4%BD%BF%E7%94%A8Model%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">4、使用Model向request域对象共享数据</h3> 
<pre><code class="language-java">@RequestMapping("/testModel")
public String testModel(Model model){
    model.addAttribute("testScope", "hello,Model");
    return "success";
}</code></pre> 
<h3 id="5%E3%80%81%E4%BD%BF%E7%94%A8map%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">5、使用map向request域对象共享数据</h3> 
<pre><code class="language-java">@RequestMapping("/testMap")
public String testMap(Map&lt;String, Object&gt; map){
    map.put("testScope", "hello,Map");
    return "success";
}
</code></pre> 
<h3 id="6%E3%80%81%E4%BD%BF%E7%94%A8ModelMap%E5%90%91request%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">6、使用ModelMap向request域对象共享数据</h3> 
<pre><code class="language-java">@RequestMapping("/testModelMap")
public String testModelMap(ModelMap modelMap){
    modelMap.addAttribute("testScope", "hello,ModelMap");
    return "success";
}
</code></pre> 
<h3 id="7%E3%80%81Model%E3%80%81ModelMap%E3%80%81Map%E7%9A%84%E5%85%B3%E7%B3%BB">7、Model、ModelMap、Map的关系</h3> 
<p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p> 
<p></p> 
<h3 id="8%E3%80%81%E5%90%91session%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">8、向session域共享数据</h3> 
<pre><code class="language-java">@RequestMapping("/testSession")
public String testSession(HttpSession session){
    session.setAttribute("testSessionScope", "hello,session");
    return "success";
}</code></pre> 
<h3 id="9%E3%80%81%E5%90%91application%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">9、向application域共享数据</h3> 
<pre><code class="language-java">@RequestMapping("/testApplication")
public String testApplication(HttpSession session){
    ServletContext application = session.getServletContext();
    application.setAttribute("testApplicationScope", "hello,application");
    return "success";
}</code></pre> 
<h2 id="%E5%85%AD%E3%80%81SpringMVC%E7%9A%84%E8%A7%86%E5%9B%BE">六、SpringMVC的视图</h2> 
<h3 id="1%E3%80%81ThymeleafView">1、ThymeleafView</h3> 
<p>当控制器方法中所设置的视图名称<span style="color:#fe2c24;">没有任何前缀</span>时，此时的视图名称会被SpringMVC配置文件中所配置 的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p> 
<h3 id="2%E3%80%81%E8%BD%AC%E5%8F%91%E8%A7%86%E5%9B%BE">2、转发视图</h3> 
<p>当控制器方法中所设置的视图名称以"<span style="color:#fe2c24;">forward:</span>"为前缀时，创建InternalResourceView视图，此时的视 图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部 分作为最终路径通过转发的方式实现跳转</p> 
<h3 id="3%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E8%A7%86%E5%9B%BE">3、重定向视图</h3> 
<p>当控制器方法中所设置的视图名称以"<span style="color:#fe2c24;">redirect:</span>"为前缀时，创建RedirectView视图，此时的视图名称不 会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最 终路径通过重定向的方式实现跳转</p> 
<h3 id="4%E3%80%81%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8view-controller-%E5%9C%A8springMVC.xml%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE">4、视图控制器view-controller-在springMVC.xml文件中配置</h3> 
<p><strong><span style="color:#fe2c24;">当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</span></strong></p> 
<pre><code class="language-XML">&lt;!--
path：设置处理的请求地址
view-name：设置请求地址所对应的视图名称
--&gt;
&lt;mvc:view-controller path="/testView" view-name="success"&gt;&lt;/mvc:view-controller&gt;
&lt;!--当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需
要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：
--&gt;
&lt;mvc:annotation-driven /&gt;</code></pre> 
<h3 id="5%E3%80%81%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#fe2c24;"><strong>5、请求转发和重定向的区别</strong></span></h3> 
<p>请求转发：①“一次”请求（请求是相对于浏览器，实际有两次请求）：第一次发生在浏览器，第二次发生在服务器内部</p> 
<p>                  ②地址栏不会发生变化，始终是第一次请求的地址</p> 
<p>                  ③请求转发后仍可以获取请求域中的共享数据（用的同一个request）</p> 
<p>                  ④请求转发可以访问WEB-INF中的资源</p> 
<p>重定向：    ①两次请求，第一次访问servlet，第二次访问重定向的地址</p> 
<p>                  ②地址栏发生变化，最后的地址是重定向的地址</p> 
<p>                  ③重定向后不可以获取请求域中的共享数据</p> 
<p>                  ④重定向后不可以访问WEB-INF中的资源</p> 
<p></p> 
<p><span style="color:#fe2c24;">**WEB-INF中的资源只允许服务器访问，不允许浏览器直接访问</span></p> 
<h2 id="%E4%B8%83%E3%80%81RESTful%20p50%2F53%E7%9A%84%E6%BA%90%E7%A0%81%E8%BF%98%E6%B2%A1%E7%9C%8B">七、RESTful p50/53的源码还没看</h2> 
<h3 id="1%E3%80%81RESTful%E7%AE%80%E4%BB%8B">1、RESTful简介</h3> 
<p>REST：Representational State Transfer，表现层资源状态转移。</p> 
<p>Representational：表现的，表现层的</p> 
<p>a&gt;资源</p> 
<p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个 可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、 数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端 应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个 资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴 趣的客户端应用，可以通过资源的URI与其进行交互。</p> 
<p>b&gt;资源的表述</p> 
<p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交 换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格 式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p> 
<p>c&gt;状态转移</p> 
<p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资 源的表述，来间接实现操作资源的目的。</p> 
<h3 id="2%E3%80%81RESTful%E7%9A%84%E5%AE%9E%E7%8E%B0">2、RESTful的实现</h3> 
<p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p> 
<p>它们分别对应四种基本操作：</p> 
<p><span style="color:#fe2c24;">GET 用来获取资源，</span></p> 
<p><span style="color:#fe2c24;">POST 用来新建资源，</span></p> 
<p><span style="color:#fe2c24;">PUT 用来更新资源，</span></p> 
<p><span style="color:#fe2c24;">DELETE 用来删除资源。</span></p> 
<p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方 式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p> 
<p>**get和post都是可以直接写的 ，但是put，delete需要特殊写法（原理详见HiddenHttpMethodFilter源码讲解）</p> 
<p>                  超链接是get请求，表单提交可以是get也可以是post</p> 
<p></p> 
<h3 id="3%E3%80%81DELETE%20%E7%94%A8%E6%9D%A5%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90%EF%BC%9A"><span style="color:#fe2c24;">3、DELETE 用来删除资源：</span></h3> 
<p>需要使用请求方式是post，且使用一个hidden的input，设置name="_method" value="delete" <strong><span style="color:#fe2c24;">  固定写法</span></strong><br>       &lt;input type="hidden" name="_method" value="delete"&gt;</p> 
<pre><code class="language-XML"> &lt;table id="dataTable" border="1" cellpadding="0" cellspacing="0" style="text-align:center;"&gt;
      &lt;a @click="deleteEmployee"  th:href="@{|/employee/${employee.id}|}"&gt;delete&lt;/a&gt;
  &lt;/table&gt;

  &lt;form id="deleteForm" method="post"&gt;
      &lt;input type="hidden" name="_method" value="delete"&gt;
  &lt;/form&gt;
  &lt;script type="text/javascript" th:src="@{/static/js/vue.js}"&gt;&lt;/script&gt;
  &lt;script type="text/javascript"&gt;
      var vue = new Vue({
          el:"#dataTable",
          methods:{
              deleteEmployee:function (event) {
                  //根据id获取表单元素
                  var deleteForm = document.getElementById("deleteForm");
                  //将触发点击事件的超链接的href属性赋值给表单的action
                  deleteForm.action = event.target.href;
                  //提交表单
                  deleteForm.submit();
                  //取消超链接的默认行为
                  event.preventDefault();
              }
          }
      });
  &lt;/script&gt;</code></pre> 
<p> <img alt="" height="436" src="https://images2.imgbox.com/d1/66/kERRpff5_o.png" width="267"><span style="color:#fe2c24;"> DELETE涉及到js，每次修改相关操作之后都需要重新进行打包，且需要加上</span></p> 
<pre><code class="language-XML">&lt;!--    静态资源处理--&gt;
    &lt;mvc:default-servlet-handler/&gt;</code></pre> 
<p></p> 
<p>4、<span style="color:#0d0016;">PUT 用来更新资源</span></p> 
<p><span style="color:#0d0016;">同理，&lt;input type="hidden" name="_method" value="put"&gt;！！！</span></p> 
<p><span style="color:#0d0016;">        关于修改内容，如果有的内容不可以修改，就可以使用hidden；</span></p> 
<p><span style="color:#0d0016;">        类型为radio，如何读取呢，使用   th:field="${employee.gender}。</span></p> 
<pre><code class="language-XML">&lt;form th:action="@{/employee}" method="post"&gt;
    &lt;input type="hidden" name="_method" value="put"&gt;
    &lt;input type="hidden" name="id" th:value="${employee.id}"&gt;&lt;/br&gt;
    lastName:&lt;input type="text" name="lastName" th:value="${employee.lastName}"&gt;&lt;/br&gt;
    email:&lt;input type="text" name="email" th:value="${employee.email}"&gt;&lt;/br&gt;
    gender:&lt;input type="radio" name="gender" value="0" th:field="${employee.gender}"&gt;女
           &lt;input type="radio" name="gender" value="1" th:field="${employee.gender}"&gt;男&lt;/br&gt;
    &lt;input type="submit" value="提交修改"&gt;
&lt;/form&gt;</code></pre> 
<h2 id="%E5%85%AB%E3%80%81HttpMessageConverter"><strong>八、HttpMessageConverter</strong></h2> 
<p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报 文</p> 
<p>请求报文是浏览器发给服务器      响应报文是服务器发给浏览器</p> 
<p>--请求的http协议</p> 
<p>    get请求包括 ：请求行，请求头</p> 
<p>   post请求包括：请求行，请求头，<span style="color:#fe2c24;">请求体</span></p> 
<p><span style="color:#0d0016;">--响应的http协议 包括：响应行，响应头，响应体          响应体就是显示在浏览器上的信息</span></p> 
<h3 id="1%E3%80%81%40RequestBody-%E8%BF%99%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%A0%87%E8%AF%86%E5%BD%A2%E5%8F%82">1、@RequestBody-<span style="color:#fe2c24;">这是注解，标识形参</span></h3> 
<p>  作用就是将请求体的值 赋值给它标识的形参 </p> 
<p>                  get请求没有请求体，所以会是null</p> 
<pre><code class="language-XML">&lt;form th:action="@{/testRequestBody}" method="post"&gt;
    用户名：&lt;input type="text" name="username"&gt;&lt;br&gt;
    密码：&lt;input type="password" name="password"&gt;&lt;br&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;
</code></pre> 
<pre><code class="language-java">@RequestMapping("/testRequestBody")
public String testRequestBody(@RequestBody String requestBody){
    System.out.println("requestBody:"+requestBody);//requestBody:username=admin&amp;password=123456
    return "success";
}
</code></pre> 
<p>用法二：标识属性</p> 
<p>用法三：标识Map</p> 
<p><img alt="" height="103" src="https://images2.imgbox.com/15/b6/VZFaDUry_o.png" width="465"></p> 
<p> </p> 
<pre><code class="language-java">    @PostMapping("/login")
    public R&lt;String&gt; login(@RequestBody Map&lt;String,Object&gt; map){
        log.info("map={}",map);//map={phone=18852895554, code=12}
        
        return null;
    }</code></pre> 
<p> </p> 
<h3 id="2%E3%80%81RequestEntity-%E8%BF%99%E6%98%AF%E7%B1%BB%E5%9E%8B">2、RequestEntity-这是类型</h3> 
<p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的 请求报文就会赋值给该形参</p> 
<p>可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p> 
<pre><code class="language-java">@RequestMapping("/testRequestEntity")
public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity){

    System.out.println("requestHeader:"+requestEntity.getHeaders());
    //输出requestBody:username=admin&amp;password=123
    System.out.println("requestBody:"+requestEntity.getBody());
    return "success";
}
</code></pre> 
<p>requestEntity.getBody()的输出和@RequestBody所标识的形参的参数的值是一样的</p> 
<h3 id="3%E3%80%81%40ResponseBody-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%A0%87%E8%AF%86%E6%96%B9%E6%B3%95">3、@ResponseBody-注解，标识方法</h3> 
<p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到 浏览器，<span style="color:#fe2c24;">直接在浏览器显示</span></p> 
<pre><code class="language-java">@RequestMapping("/testResponseBody")
@ResponseBody
public String testResponseBody(){
    return "success";
}
</code></pre> 
<p>浏览器地址是localhost：8080/工程路径/testResponseBody</p> 
<p>结果：浏览器页面显示success 4、SpringMVC处理jso</p> 
<h3 id="4%E3%80%81SpringMVC%E5%A4%84%E7%90%86json"><strong>4、SpringMVC处理json</strong></h3> 
<p><strong>如果我们想使用</strong>@ResponseBody返回一个类，就需要使用json</p> 
<p>①&gt;导入jackson的依赖</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>②在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消 息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格 式的字符串</p> 
<pre><code class="language-XML">&lt;mvc:annotation-driven /&gt;
</code></pre> 
<p> ③在处理器方法上使用@ResponseBody注解进行标识</p> 
<p>④&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p> 
<pre><code class="language-java">@RequestMapping("/testResponseUser")
@ResponseBody
public User testResponseUser(){
    return new User(1001,"admin","123456",23,"男");
}
</code></pre> 
<p> 浏览器的页面中展示的结果： {"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}</p> 
<h3 id="5%E3%80%81%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span style="color:#fe2c24;">5、注解驱动的作用</span></h3> 
<p>①当使用<span style="color:#fe2c24;">mvc:view-controller标签</span>时一定要加入mvc:annotation-driven，不然会使requestMapping失效。<br>     ②当为了处<span style="color:#fe2c24;"><strong>理静态资源</strong></span>问题而加入mvc:default-servlet-<a href="https://so.csdn.net/so/search?q=handler&amp;spm=1001.2101.3001.7020" title="handler">handler</a>时，也一定要加入mvc:annotation-driven，不然requestMapping同样会失效。<br>        ③当处理<span style="color:#fe2c24;">java转变为json对象</span>的时候需要加上mvc:annotation-driven标签</p> 
<h3 id="6%E3%80%81SpringMVC%E5%A4%84%E7%90%86ajax">6、SpringMVC处理ajax</h3> 
<pre><code class="language-XML">&lt;div id="app"&gt;
&lt;a th:href="@{/testAjax}" @click="testAjax"&gt;testAjax&lt;/a&gt;&lt;br&gt;
&lt;/div&gt;
&lt;script type="text/javascript" th:src="@{/static/js/vue.js}"&gt;&lt;/script&gt;
&lt;script type="text/javascript" th:src="@{/static/js/axios.min.js}"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var vue = new Vue({
        el:"#app",
        methods:{
            testAjax:function (event) {
                axios({
                    method:"post",
                    url:event.target.href,
                    params:{
                        username:"admin",
                        password:"123456"
                    }
                }).then(function (response) {
                    alert(response.data);
                });
                event.preventDefault();
            }
        }
    });
&lt;/script&gt;
</code></pre> 
<pre><code class="language-java">@RequestMapping("/testAjax")
@ResponseBody
public String testAjax(String username, String password){
    System.out.println("username:"+username+",password:"+password);
    return "hello,ajax";
}</code></pre> 
<h3 id="7%E3%80%81%40RestController%E6%B3%A8%E8%A7%A3">7、@RestController注解</h3> 
<p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 @Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p> 
<h3 id="8%E3%80%81ResponseEntity">8、ResponseEntity</h3> 
<p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的自定义的响应报文，用于文件的上传和下载</p> 
<h2 id="%E4%B9%9D%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD">九、文件上传和下载</h2> 
<h3 id="1%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">1、文件下载</h3> 
<pre><code class="language-java">    @RequestMapping("/testDown")
    public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws
            IOException {
        @RequestMapping("/testDown")
	public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws
		IOException {
		//获取ServletContext对象
		ServletContext servletContext = session.getServletContext();
		//获取服务器中文件的真实路径
		String realPath = servletContext.getRealPath("/static/img/1.jpg");
		//创建输入流
		InputStream is = new FileInputStream(realPath);
		//创建字节数组   is.available() 字节流的长度
		byte[] bytes = new byte[is.available()];
		//将流读到字节数组中
		is.read(bytes);
		//创建HttpHeaders对象设置响应头信息
		MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();
		//设置要下载方式以及下载文件的名字   "Content-Disposition"是键值对的键  是固定的
		//attachment以附件的形式下载     filename=1.jpg下载的时候默认名字是1.jpg
		headers.add("Content-Disposition", "attachment;filename=1.jpg");
		//设置响应状态码
		HttpStatus statusCode = HttpStatus.OK;
		//创建ResponseEntity对象   bytes是byte数组其实就是响应体  
		ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers,statusCode);
		//关闭输入流
		is.close();
		//responseEntity  其实就是自定义一个响应报文
		return responseEntity;
	}
    </code></pre> 
<h3 id="2%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">2、文件上传</h3> 
<p><span style="color:#fe2c24;">文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data" SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</span> </p> 
<p>因为上传的文件原来是File类型 不能直接转变成MultipartFile类型，所以我们需要配置一个文件解析器</p> 
<p>①、添加依赖：</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>②、在SpringMVC的配置文件中添加配置：</p> 
<pre><code class="language-XML">&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt;
</code></pre> 
<p>MultipartResolver是一个接口，我们要找一个它的实现类。CommonsMultipartResolver就是他的一个实现类，springMVC根据id获取解析器。因为一个接口有很多实现类，只有通过id才能确定那唯一的一个实现类</p> 
<p>③&gt;控制器方法：</p> 
<pre><code class="language-java">@RequestMapping("/testUp")
	public String testUp(MultipartFile photo, HttpSession session) throws IOException {
		//获取上传的文件的文件名
		String fileName = photo.getOriginalFilename();
		//处理文件重名问题
		String hzName = fileName.substring(fileName.lastIndexOf("."));
		fileName = UUID.randomUUID().toString() + hzName;
		//获取服务器中photo目录的路径
		ServletContext servletContext = session.getServletContext();
		//注意这里的photo是个目录，我们没有文件服务器  ，所以只能将文件上传到tomcat服务器
		String photoPath = servletContext.getRealPath("photo");
		//下面四行是表示  如果没有photo这个文件夹  就创建一个
		File file = new File(photoPath);
		if(!file.exists()){
		file.mkdir();
		}
		//--------------------------
		//File.separator 指的是文件分隔符
		String finalPath = photoPath + File.separator + fileName;
		//实现上传功能
		photo.transferTo(new File(finalPath));
		return "success";
	}
</code></pre> 
<p>④、表单</p> 
<pre><code class="language-XML">    &lt;form th:action="@{/testUp}" method="post" enctype="multipart/form-data"&gt;
        头像：&lt;input type="file" name="photo"&gt;&lt;/br&gt;
        &lt;input type="submit" value="提交"&gt;
    &lt;/form&gt;</code></pre> 
<p><span style="color:#fe2c24;">        文件保存在target对应的位置</span></p> 
<h2 id="%E5%8D%81%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8">十、拦截器</h2> 
<h3 id="1%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE">1、拦截器的配置</h3> 
<p>SpringMVC中的拦截器用于拦截控制器方法的执行</p> 
<p>SpringMVC中的拦截器需要实现HandlerInterceptor-<span style="color:#fe2c24;">要写上注解</span></p> 
<pre><code class="language-java">@Component
public class FirstInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle-&gt;");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle");
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion");
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}</code></pre> 
<p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p> 
<p>/*  只表示单层目录       /**可以表示多层目录</p> 
<p>&lt;mvc:exclude-mapping path="/testRequestEntity"/&gt;表示拦截器不会拦截的映射</p> 
<p>&lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;  在IOC容器中寻找拦截器，所以一定要在拦截器中夹注解</p> 
<pre><code class="language-XML">&lt;mvc:interceptor&gt;
    &lt;mvc:mapping path="/**"/&gt;    
    &lt;mvc:exclude-mapping path="/testRequestEntity"/&gt;
    &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;
&lt;/mvc:interceptor&gt;
</code></pre> 
<h3 id="2%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">2、拦截器的三个抽象方法</h3> 
<p>SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行</p> 
<p>preHandle()，其boolean类型的返回值表示是否拦截或放行，返 回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle()</p> 
<p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p> 
<h3 id="3%E3%80%81%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">3、多个拦截器的执行顺序</h3> 
<p>a&gt;若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p> 
<p>b&gt;若某个拦截器的preHandle()返回了false</p> 
<p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false 的拦截器之前的拦截器的afterComplation()会执行</p> 
<p><strong><span style="color:#fe2c24;">详细见DispatherServlet源码中的protected void doDispatch(HttpServletRequest request, HttpServletResponse response)</span></strong></p> 
<p><strong><span style="color:#fe2c24;">                                                  和HandlerExecutionChain源码</span></strong></p> 
<p></p> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8">十一、异常处理器</h2> 
<p>注解写法：（是写在controller文件夹中的，属于控制器）</p> 
<pre><code class="language-java">//@ControllerAdvice将当前类标识为异常处理的组件，是@controller注解的扩展注解
@ControllerAdvice
public class ExceptionController {
    //@ExceptionHandler用于设置所标识方法处理的异常,括号需要的是class类型的数组
    // @ExceptionHandler(value={ArithmeticException.class})
    @ExceptionHandler(ArithmeticException.class)
    //ex表示当前请求处理中出现的异常对象
    public String handleArithmeticException(Exception ex, Model model){
        //ex表示的是异常信息
        model.addAttribute("ex", ex);
        //出现异常就跳转error.html
        return "error";
    }
}
</code></pre> 
<p>写一个测试错误</p> 
<pre><code class="language-java">@RequestMapping("/testException")
    public String testException(){
        int a=10/0;
        return "success";
    }</code></pre> 
<pre><code class="language-XML">&lt;a th:href="@{/testException}"&gt;测试异常处理&lt;/a&gt;</code></pre> 
<p> 在error.html中可以显示错误</p> 
<pre><code class="language-XML">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
error
&lt;div th:text="${ex}"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>结果： </p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/3c/47/2XRFFkVr_o.png" width="547"></p> 
<h2 id="%E5%8D%81%E4%BA%8C%E3%80%81%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AESpringMVC">十二、注解配置SpringMVC</h2> 
<h3 id="1%E3%80%81%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%EF%BC%8C%E4%BB%A3%E6%9B%BFweb.xml">1、创建初始化类，代替web.xml</h3> 
<p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类， 如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为 SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配 置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为 AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了 AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自 动发现它，并用它来配置Servlet上下文。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c337b0b842dfd47e73ab479da18df970/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何把插件提交到WordPress？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5de5ee448a1422d3faa1babad5e58261/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jmeter——生成多样的接口自动化html报告</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>