<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Modern C&#43;&#43;】深入理解左值、右值 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Modern C&#43;&#43;】深入理解左值、右值" />
<meta property="og:description" content="作为C/C&#43;&#43;开发人员，在平时的项目开发过程中，或多或少的听过左值和右值的概念，甚至在编译器报错的时候，遇到过lvalue和rvalue等字样；甚至使用过std::move()，但是不知道其含义。作为多年的C&#43;&#43;开发人员，一直以来，对左值右值的理解没有一个系统的认识，总感觉似懂非懂。今天，借助本文，详细的介绍下这些知识点，并从代码实例的角度去分析什么是左值或者右值，同时，也算是给自己知识点做一个总结。
1背景 作为C&#43;&#43;开发人员，相信我们都写过如下代码：
void fun(int &amp;x) { // } int main() { fun(10); return 0; } 在编译的时候，会提示如下：
error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’
从“int”类型的右值对“int&amp;”类型的非常量引用进行无效初始
其中上述报错中的rvalue就是10，也就是说10就是rvalue，那么到底什么是rvalue，rvalue的意义是什么？这就是本文的目的，通过本文，让你彻底搞清楚什么C&#43;&#43;下的值类别，以及如何区分左值、纯右值和将亡值。
本文的主要内容如下图所示：
2历史 在正式介绍左值和右值之前，我们先介绍下其历史。
编程语言CPL第一次引入了值类别，不过其定义比较简单，即对于赋值运算符，在运算符左边的为左值，在运算符右边的为右值。
C语言遵循与CPL类似的分类法，但是弱化了赋值的作用，C语言中的表达式被分为左值和其它(函数和非对象值)，其中左值被定义为标识一个对象的表达式。不过，C语言中的左值与CPL中的左值区别是，在C语言中lvalue是locator value的简写，因此lvalue对应了一块内存地址。
C&#43;&#43;11之前，左值遵循了C语言的分类法，但与C不同的是，其将非左值表达式统称为右值，函数为左值，并添加了引用能绑定到左值但唯有const的引用能绑定到右值的规则。几种非左值的C表达式在C&#43;&#43;中成为了左值表达式。
自C&#43;&#43;11开始，对值类别又进行了详细分类，在原有左值的基础上增加了纯右值和消亡值，并对以上三种类型通过是否具名(identity)和可移动(moveable)，又增加了glvalue和rvalue两种组合类型，在后面的内容中，会对这几种类型进行详细讲解。
3表达式 C/C&#43;&#43;代码是由标识符、表达式和语句以及一些必要的符号(大括号等)组成。
表达式由按照语言规则排列的运算符，常量和变量组成。一个表达式可以包含一个或多个操作数，零个或多个运算符来计算值。每个表达式都会产生一些值，该值将在赋值运算符的帮助下分配给变量。
在C/C&#43;&#43;中，表达式有很多种，我们常见的有前后缀表达式、条件运算符表达式等。字面值(literal)和变量(variable)是最简单的表达式，函数的返回值也被认为是表达式。
表达式是可求值的，对表达式求值可得到一个结果，这个结果有两个属性:
类型。这个我们很常见，比如int、string、引用或者我们自定义的类。类型确定了表达式可以进行哪些操作。值类别(在下节中会细讲)。 4值类别 在上节中，我们提到表达式是可求值的，而值类别就是求值结果的属性之一。
在C&#43;&#43;11之前，表达式的值分为左值和右值两种，其中右值就是我们理解中的字面值1、true、NULL等。
自C&#43;&#43;11开始，表达式的值分为左值(lvalue, left value)、将亡值(xvalue, expiring value)、纯右值(prvalue, pure ravlue)以及两种混合类别泛左值(glvalue, generalized lvalue)和右值(rvalue, right value)五种。
这五种类别的分类基于表达式的两个特征：
具名(identity):可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址可被移动：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式 结合上述两个特征，对五种表达式值类别进行重新定义：
lvalue:具名且不可被移动xvaue:具名且可被移动prvalue:不具名且可被移动glvalue:具名，lvalue和xvalue都属于glvaluervalue:可被移动的表达式，prvalue和xvalue都属于rvalue
用图表示如下： 从glvalue和rvalue出发，将具名(indentity)和可移动两个特征结合起来，如下图所示：
在上图中，I代表indentity，M代表moveable。以xvalue为例，在上图中xvalue为(I&amp;M)，即代表具名且可移动。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/9e867ab6a3477ca2aa3f78928cb74d03/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-09T10:58:44+08:00" />
<meta property="article:modified_time" content="2022-06-09T10:58:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Modern C&#43;&#43;】深入理解左值、右值</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>作为C/C++开发人员，在平时的项目开发过程中，或多或少的听过左值和右值的概念，甚至在编译器报错的时候，遇到过lvalue和rvalue等字样；甚至使用过std::move()，但是不知道其含义。作为多年的C++开发人员，一直以来，对左值右值的理解没有一个系统的认识，总感觉似懂非懂。今天，借助本文，详细的介绍下这些知识点，并从代码实例的角度去分析什么是左值或者右值，同时，也算是给自己知识点做一个总结。</p> 
</blockquote> 
<h2><a id="1_2"></a>1背景</h2> 
<p>作为C++开发人员，相信我们都写过如下代码：</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在编译的时候，会提示如下：</p> 
<blockquote> 
 <p>error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’<br> 从“int”类型的右值对“int&amp;”类型的非常量引用进行无效初始<br> 其中上述报错中的rvalue就是10，也就是说10就是rvalue，那么到底什么是rvalue，rvalue的意义是什么？这就是本文的目的，通过本文，让你彻底搞清楚什么C++下的值类别，以及如何区分左值、纯右值和将亡值。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/31/28/E1uYhBhz_o.png" alt="在这里插入图片描述"><br> 本文的主要内容如下图所示：<br> <img src="https://images2.imgbox.com/de/0c/sPB79t7G_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_24"></a>2历史</h2> 
<p>在正式介绍左值和右值之前，我们先介绍下其历史。</p> 
<blockquote> 
 <p>编程语言CPL第一次引入了值类别，不过其定义比较简单，即对于赋值运算符，在运算符左边的为左值，在运算符右边的为右值。</p> 
</blockquote> 
<blockquote> 
 <p>C语言遵循与CPL类似的分类法，但是弱化了赋值的作用，C语言中的表达式被分为左值和其它(函数和非对象值)，其中左值被定义为标识一个对象的表达式。不过，C语言中的左值与CPL中的左值区别是，在<code>C语言中lvalue是locator value的简写，因此lvalue对应了一块内存地址。</code></p> 
</blockquote> 
<blockquote> 
 <p>C++11之前，左值遵循了C语言的分类法，但与C不同的是，其将非左值表达式统称为右值，函数为左值，并添加了引用能绑定到左值但唯有const的引用能绑定到右值的规则。几种非左值的C表达式在C++中成为了左值表达式。</p> 
</blockquote> 
<blockquote> 
 <p>自C++11开始，对值类别又进行了详细分类，在原有左值的基础上增加了纯右值和消亡值，并对以上三种类型通过是否具名(identity)和可移动(moveable)，又增加了glvalue和rvalue两种组合类型，在后面的内容中，会对这几种类型进行详细讲解。</p> 
</blockquote> 
<h2><a id="3_36"></a>3表达式</h2> 
<p><code>C/C++代码是由标识符、表达式和语句以及一些必要的符号(大括号等)组成</code>。</p> 
<p>表达式由按照语言规则排列的运算符，常量和变量组成。一个表达式可以包含一个或多个操作数，零个或多个运算符来计算值。每个表达式都会产生一些值，该值将在赋值运算符的帮助下分配给变量。</p> 
<p>在C/C++中，表达式有很多种，我们<b>常见的有前后缀表达式、条件运算符表达式等。字面值(literal)和变量(variable)是最简单的表达式，<code>函数的返回值</code>也被认为是表达式。</b></p> 
<blockquote> 
 <p><code>表达式是可求值的，对表达式求值可得到一个结果，这个结果有两个属性</code>:</p> 
 <ul><li><code>类型</code>。这个我们很常见，比如int、string、引用或者我们自定义的类。类型确定了表达式可以进行哪些操作。</li><li><code>值类别</code>(在下节中会细讲)。</li></ul> 
</blockquote> 
<h2><a id="4_48"></a>4值类别</h2> 
<p>在上节中，我们提到表达式是可求值的，而值类别就是求值结果的属性之一。</p> 
<p>在C++11之前，表达式的值分为左值和右值两种，其中右值就是我们理解中的字面值1、true、NULL等。</p> 
<p><code>自C++11开始，表达式的值分为左值(lvalue, left value)、将亡值(xvalue, expiring value)、纯右值(prvalue, pure ravlue)以及两种混合类别泛左值(glvalue, generalized lvalue)和右值(rvalue, right value)五种</code>。</p> 
<blockquote> 
 <p>这五种类别的分类基于表达式的两个特征：</p> 
 <ul><li><code>具名(identity)</code>:<code>可以确定表达式是否与另一表达式指代同一实体</code>，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址</li><li><code>可被移动</code>：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式</li></ul> 
</blockquote> 
<p>结合上述两个特征，对五种表达式值类别进行重新定义：</p> 
<ul><li>lvalue:具名且不可被移动</li><li>xvaue:具名且可被移动</li><li>prvalue:不具名且可被移动</li><li>glvalue:具名，lvalue和xvalue都属于glvalue</li><li>rvalue:可被移动的表达式，prvalue和xvalue都属于rvalue<br> 用图表示如下：</li></ul> 
<p><img src="https://images2.imgbox.com/43/05/OkseMdsb_o.png" alt="在这里插入图片描述"></p> 
<p>从glvalue和rvalue出发，将具名(indentity)和可移动两个特征结合起来，如下图所示：<br> <img src="https://images2.imgbox.com/1f/cc/h5I8eRtK_o.png" alt="在这里插入图片描述"><br> 在上图中，I代表indentity，M代表moveable。以xvalue为例，在上图中xvalue为(I&amp;M)，即代表具名且可移动。</p> 
<blockquote> 
 <p>对于indentity，有些文章译为有身份的，有些文章译为具名的，本文统一称为具名的。</p> 
</blockquote> 
<h2><a id="5_76"></a>5左值</h2> 
<p>左值(lvalue,left value)，顾名思义就是赋值符号左边的值。准确来说，<code>左值是表达式结束（不一定是赋值表达式）后依然存在的对象</code>。</p> 
<blockquote> 
 <p><code>可以将左值看作是一个关联了名称的内存位置，允许程序的其他部分来访问它</code>。在这里，我们将 “名称” 解释为任何可用于访问内存位置的表达式。所以，如果 arr 是一个数组，那么 arr[1] 和 *(arr+1) 都将被视为相同内存位置的“名称”。</p> 
</blockquote> 
<p><b>左值具有以下特征：</b></p> 
<ul><li><code>可通过取地址运算符获取其地址</code></li><li><code>可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数</code></li><li><code>可以用来初始化左值引用</code>(后面有讲)</li></ul> 
<p><b>那么哪些都是左值呢?</b>查了相关资料，做了些汇总，基本覆盖了所有的类型：</p> 
<ul><li>变量名、函数名以及数据成员名</li><li>返回左值引用的函数调用</li><li>由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)</li><li>解引用表达式*ptr</li><li>前置自增和自减表达式(++a, ++b)</li><li>成员访问（点）运算符的结果</li><li>由指针访问成员（ -&gt; ）运算符的结果</li><li>下标运算符的结果([ ])</li><li>字符串字面值(“abc”)</li></ul> 
<p>为了能够更加清晰地理解左值，我们举例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// a是左值</span>
T<span class="token operator">&amp;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左值</span>
<span class="token operator">++</span>a<span class="token punctuation">;</span><span class="token comment">//左值</span>
<span class="token operator">--</span>a<span class="token punctuation">;</span><span class="token comment">//左值</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//a和b都是左值</span>
<span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">;</span> <span class="token comment">// ptr为左值</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 左值</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// p为左值</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// *p为左值</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
MyClass c<span class="token punctuation">;</span> <span class="token comment">// c为左值</span>
<span class="token string">"abc"</span>
</code></pre> 
<p><code>对于一个表达式，凡是对其取地址（&amp;）操作可以成功的都是左值</code></p> 
<h2><a id="6_119"></a>6纯右值</h2> 
<p>在前面有提过，自C++11开始，纯右值(pvalue, pure ravlue)相当于之前的右值，那么什么是纯右值呢？</p> 
<p><code>字面值或者函数返回的非引用都是纯右值</code>。</p> 
<p><b>以下表达式的值都是纯右值：</b></p> 
<ul><li>字面值(字符串字面值除外)，例如1，‘a’, true等</li><li>返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++</li><li>后置自增和自减表达式(a++, a- -)</li><li>算术表达式</li><li>逻辑表达式</li><li>比较表达式</li><li>取地址表达式</li><li>lambda表达式</li></ul> 
<p>为了加深对右值的理解，下面的例子是常见的纯右值：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
a <span class="token operator">+</span> b<span class="token punctuation">;</span>

a<span class="token operator">++</span><span class="token punctuation">;</span>
b<span class="token operator">--</span><span class="token punctuation">;</span>

a <span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
a <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">;</span>
</code></pre> 
<p><b>纯右值特征：</b></p> 
<ul><li>等同于C++11之前的右值</li><li>不会是多态</li><li>不会是抽象类型或数组</li><li>不会是不完全类型</li></ul> 
<h2><a id="7_162"></a>7将亡值</h2> 
<blockquote> 
 <p><code>将亡值(xvalue, expiring value)</code>，顾名思义即将消亡的值，是C++11新增的跟右值引用相关的表达式，<b>通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。</b></p> 
</blockquote> 
<p>将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。（<code>通过右值引用来续命</code>）。</p> 
<p>xvalue <code>只能通过两种方式来获得</code>，这两种方式都涉及到将一个左值赋给(转化为)一个右值引用：</p> 
<ul><li>返回右值引用的函数的调用表达式,如 static_cast&lt;T&amp;&amp;&gt;(t); 该表达式得到一个 xvalue</li><li>转换为右值引用的转换函数的调用表达式，如：std::move(t)、satic_cast&lt;T&amp;&amp;&gt;(t)</li></ul> 
<p>下面通过几个代码来详细分析什么是将亡值：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在函数fun()中，str是一个局部变量，并在函数结束时候被返回。</p> 
<p>在C++11之前，s = fun();会调用拷贝构造函数，会将整个str复制一份，然后把str销毁。如果str特别大的话，会造成大量额外开销。在这一行中，s是左值，fun()是右值(纯右值)，fun()产生的那个返回值作为一个临时值，一旦str被s复制后，将被销毁，无法获取、也不能修改。</p> 
<p><code>自C++11开始</code>，引入了move语义，编译器会将这部分优化成move操作，即不再是之前的复制操作，而是move。此时，<code>str会被进行隐式右值转换，等价于static_cast&lt;std::string&amp;&amp;&gt;(str)，进而此处的 s 会将 foo 局部返回的值进行移动</code>。</p> 
<p><code>无论是C++11之前的拷贝，还是C++11的move，str在填充(拷贝或者move)给s之后，将被销毁，而被销毁的这个值，就成为将亡值。</code></p> 
<p>将亡值就定义了这样一种行为：具名的临时值、同时又能够被move。</p> 
<h2><a id="8_194"></a>8混合类型</h2> 
<h3><a id="81_195"></a>8.1泛左值</h3> 
<p>泛左值（glvalue, generalized lvalue），又称为广义左值，是具名表达式，对应了一块内存。glvalue有lvalue和xvalue两种形式。</p> 
<p>一个表达式是具名的，则称为glvalue，例子如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

S <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
S s<span class="token punctuation">;</span>
s<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
S<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
S<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">.</span>n<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>在上述代码中：<br> 定义了结构体S和函数fun()<br> 第6行声明了类型为S的变量s，因为其是具名的，所以是glvalue<br> 第七行同上，因为s具名，所以为glvalue<br> 第8行中调用了move函数 ，将左值s转换成xvalue，所以是glvaue<br> 第10行中，fun()是不具名的，是纯右值，所以不是glvalue<br> 第11行中，生成一个不具名的临时变量，是纯右值，所以不是glvalue<br> 第12行中，n具名，所以是glvalue</p> 
</blockquote> 
<p><b>glvalue的特征如下：</b></p> 
<ul><li>可以自动转换成prvalue</li><li>可以是多态的</li><li>可以是不完整类型，如前置声明但未定义的类类型</li></ul> 
<h3><a id="82_228"></a>8.2右值</h3> 
<p>右值(rvalue, right value)是指<code>可以移动的表达式。prvalue和xvalue都是rvalue</code>，具体的示例见下文。</p> 
<p><b>rvalue具有以下特征：</b></p> 
<ul><li>无法对rvalue进行取地址操作。例如：&amp;1，&amp;(a + b)，这些表达式没有意义，也编译不过。</li><li>rvalue不能放在赋值或者组合赋值符号的左边，例如：3 = 5，3 += 5，这些表达式没有意义，也编译不过。</li><li>rvalue可以用来初始化const左值引用（见下文）。例如：const int&amp; a = 1。</li><li>rvalue可以用来初始化右值引用（见下文）。</li><li>rvalue可以影响函数重载：当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const 的左值引用的形参时，右值将被绑定到右值引用的重载之上。</li></ul> 
<h2><a id="9_239"></a>9深入</h2> 
<p>经过前面的内容，我们对左值和右值(纯右值和将亡值)有了一个初步的认识，在本节，我们借助一些例子，来加深对左值和右值的理解。</p> 
<p><b>前置自增(减)是左值，后置自增(减)是纯右值</b></p> 
<p>代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">++</span>i<span class="token punctuation">;</span>
<span class="token operator">--</span>i<span class="token punctuation">;</span>
i<span class="token operator">++</span><span class="token punctuation">;</span>
i<span class="token operator">--</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面代码中，我们定义了一个int类型的变量i，并初始化为0。</p> 
<ul><li>++i的操作是对i加1后再赋值给i，所以++i的结果是具名的，名称就是i，所以++i是左值</li><li>对于i++而言，先将i的值进行拷贝(此处假设拷贝到临时变量ii)，然后再对i加1，最后返回ii(其实不存在的，为了在此表述方便)。所以i++是不具名的，因此不是glvaue，所以i++是右值，又因为不具名，且是右值，所以i++是纯右值</li><li>同理，–i是左值，i–是纯右值</li></ul> 
<p><b>算术表达式是纯右值</b></p> 
<p>代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
x <span class="token operator">+</span> y<span class="token punctuation">;</span>
x <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">;</span>
x <span class="token operator">==</span> y<span class="token punctuation">;</span>
</code></pre> 
<p>在上述代码中，x + y得到的是一个不具名的临时对象，所以x+y是纯右值；而x &amp;&amp; y和x == y得到的是一个bool常量值，要么是true要么是false，所以是纯右值。</p> 
<p><b>解引用是左值，取地址是纯右值</b></p> 
<p>代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token operator">*</span>y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>y<span class="token punctuation">;</span>
</code></pre> 
<p>*y得到的是y指向地址的实际值，所以&amp;(<em>y)是合法的，因此</em>y是左值;对&amp;y操作得到的是一个地址，即一个long值，所以是一个字面值，因此&amp;y是纯右值。</p> 
<p><b>字符串字面值是左值<br> 字符串字面值为左值，这个比较特殊。在前面提到过字面值都是纯右值(字符串字面值除外)，一个很重要的原因，就是可以字符串字面值可以获取地址，</b></p> 
<p>下面代码在编译器中可正常编译且运行：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token string">"abc"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre> 
<p>这是因为C++将字符串字面值实现为char型数组，实实在在地为每个字符都分配了空间并且允许程序员对其进行操作。如果从存储区的概念来理解，那就是字符串字面值存储在常量区。</p> 
<h2><a id="10_294"></a>10引用</h2> 
<p>既然提到了左值右值，就得提一下引用。</p> 
<p>在C++11之前，引用分为左值引用和常量左值引用两种，但是自C++11起，引入了右值引用，也就是说，在<code>C++11中，包含如下3中引用：</code></p> 
<ul><li>左值引用</li><li>常量左值引用(不希望被修改)</li><li>右值引用</li></ul> 
<p>左值引用和常量左值引用，我们很常见，如下代码：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s <span class="token operator">=</span> str<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 错</span>
</code></pre> 
<p>在上述代码中，s是一个左值引用，而a是一个const 左值引用。那么，为什么最后一句int &amp;b = 10;编译器会报错呢？这是因为10是常量，而常量是右值，一个右值怎么能够被左值引用去引用呢。</p> 
<p>那么什么是右值引用呢？右值引用就是引用右值的引用，这不废话嘛😁。</p> 
<p>在C++11中引入了右值引用，因为右值的生命周期很短，右值引用的引入，使得可以延长右值的生命周期。在C++中规定，右值引用是&amp;&amp;即由2个&amp;表示，而左值引用是一个&amp;表示。右值引用的作用是为了绑定右值。</p> 
<p>为了能区分左值引用和右值引用，代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>rb <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// b为左值引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rrb <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 错误，a是左值，右值引用不能绑定左值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rrb1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 正确，1为右值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>rb1 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 错误，i * 2是右值，而rb1位左值引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rrb2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>c1 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre> 
<p>在这里，我们需要特别注意的一点就是右值引用虽然是引用右值，但是其本身是左值，以下代码为例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上述代码中，a是一个右值引用，但是其本身是左值，合适因为：</p> 
<ul><li>a出现在等号(=)的左边</li><li>可以对a取地址</li></ul> 
<p>我们在前面有提到过，一个表达式有两个属性，分别为类型和值类别。本节说的左值引用和右值引用就属于类型,而左值和右值则属于值类别范畴，这个概念很重要，千万不能混淆。</p> 
<p>可能有人会问，除了自己根据规则区分左值引用和右值引用，有没有更快更准确的方式来判断呢？其实，系统提供了API，如下：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>is_lvalue_reference
is_rvalue_reference
  
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>ra <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_lvalue_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_rvalue_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_rvalue_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre> 
<p>输出结果：</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span>
<span class="token number">0</span>
<span class="token number">1</span>
</code></pre> 
<h2><a id="11_366"></a>11参考</h2> 
<p>https://en.cppreference.com/w/cpp/language/value_category https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c https://www.fatalerrors.org/a/left-value-reference-and-right-value-reference-of-c-c-class-and-object.html https://www.bogotobogo.com/cplusplus/C11/4_C11_Rvalue_Lvalue.php https://users.soe.ucsc.edu/~pohl/code/lvalue.htm</p> 
<p>原文 https://mp.weixin.qq.com/s/t76qOUqCDMHvZV4uOngGEw</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/19c6736983f97f80274387c5dc7b93d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">隔离DCDC电源模块和非隔离DCDC电源模块不同之处</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/62f8f169bc108f41ae8eecf53766efbc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">4425 改变数字（模拟）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>