<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试题（有部分答案） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试题（有部分答案）" />
<meta property="og:description" content="面试题（有答案）：
1. String类为什么是final的。
答：主要是为了“效率” 和 “安全性” 的缘故。若 String允许被继承, 由于它的高度被使用率, 可能会降低程序的性能，所以String被定义成final。
2. HashMap的源码，实现原理，底层结构。
3. 说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。
4. 描述一下ArrayList和LinkedList各自实现和区别
5. Java中的队列都有哪些，有什么区别。
6. 反射中，Class.forName和classloader的区别
答：共同点
1. 两者都会将用户指定的类加载到内存中，供用户使用
不同点：
Class.forName方法有要不要初始static变量的参数，而ClassLoader.loadClass()没有；Class.forName的重载方法是静态的，而ClassLoader.loadClass不是。
7. Java7、Java8的新特性(baidu问的,好BT)
8. Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高
答：数组在随机访问数据、随机增加数据、随机删除数据的执行效率上比链表的效率高，数据量越小，两者之间效率的差距越小，数据量越大差距越大。
9. Java内存泄露的问题调查定位：jmap，jstack的使用等等
10. string、stringbuilder、stringbuffer区别
11. hashtable和hashmap的区别
13 .异常的结构，运行时异常和非运行时异常，各举个例子
14. String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” &#43; “c” .他们之间用 == 比较的结果
15. String 类的常用方法
16. Java 的引用类型有哪几种
17. 抽象类和接口的区别
18. java的基础类型和字节大小。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a028f3dd39a44b6bf34e346a6d5b8e2b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-18T17:11:09+08:00" />
<meta property="article:modified_time" content="2017-01-18T17:11:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试题（有部分答案）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 面试题（有答案）：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 1. String类为什么是final的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <a target="_blank" name="OLE_LINK6" style="color:rgb(255,153,0)"></a>答：主要是为了“效率” 和 “安全性” 的缘故。若 String允许被继承, 由于它的高度被使用率, 可能会降低程序的性能，所以String被定义成final。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 2. HashMap的源码，实现原理，底层结构。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 3. 说说你知道的几个<a target="_blank" href="http://lib.csdn.net/base/javase" rel="nofollow noopener noreferrer" class="replace_word" title="Java SE知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">Java</a>集合类：list、set、queue、map实现类咯。。。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 4. 描述一下ArrayList和LinkedList各自实现和区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 5. Java中的队列都有哪些，有什么区别。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 6. 反射中，Class.forName和classloader的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：共同点</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 1. 两者都会将用户指定的类加载到内存中，供用户使用</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 不同点：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Class.forName方法有要不要初始static变量的参数，而<a target="_blank" name="OLE_LINK2" style="color:rgb(255,153,0)">ClassLoader.loadClass</a>()没有；Class.forName的重载方法是静态的，而ClassLoader.loadClass不是。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 7. Java7、Java8的新特性(baidu问的,好BT)</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 8. Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <a target="_blank" name="OLE_LINK7" style="color:rgb(255,153,0)"></a>答：数组在随机访问数据、随机增加数据、随机删除数据的执行效率上比链表的效率高，数据量越小，两者之间效率的差距越小，数据量越大差距越大。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 9. Java内存泄露的问题调查定位：jmap，jstack的使用等等</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 10. string、stringbuilder、stringbuffer区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 11. hashtable和hashmap的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 13 .异常的结构，运行时异常和非运行时异常，各举个例子</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 14. String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 15. String 类的常用方法</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 16. Java 的引用类型有哪几种</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 17. 抽象类和接口的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 18. java的基础类型和字节大小。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 19. Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题（建议熟悉 jdk 源码，才能从容应答）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 20. 如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 21. Hash冲突怎么办？哪些解决散列冲突的方法？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 22. HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 23. rehash</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 24. hashCode() 与 equals() 生成<a target="_blank" href="http://lib.csdn.net/base/datastructure" rel="nofollow noopener noreferrer" class="replace_word" title="算法与数据结构知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">算法</a>、方法怎么重写</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 25. 讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 26. 讲讲NIO。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 27. String 编码UTF-8 和GBK的区别?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 28. 什么时候使用字节流、什么时候使用字符流?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 29. 递归读取文件夹下的文件，代码怎么实现</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 30. session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)">cookie 和session 的区别：</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">考虑到安全应当使用session。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">考虑到减轻服务器性能方面，应当使用COOKIE。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">cookie 和session 的联系：</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">session是通过cookie来工作的</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">session和cookie之间是通过$_COOKIE['PHPSESSID']来联系的，通过$_COOKIE['PHPSESSID']可以知道session的id，从而获取到其他的信息。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">在购物网站中通常将用户加入购物车的商品联通session_id记录到<a target="_blank" href="http://lib.csdn.net/base/mysql" rel="nofollow noopener noreferrer" class="replace_word" title="MySQL知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">数据库</a>中，当用户再次访问是，通过sessionid就可以查找到用户上次加入购物车的商品。因为sessionid是唯一的，记录到数据库中就可以根据这个查找了。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)">生命周期：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(75,75,75)">　Session存储在服务器端，一般为了防止在服务器的内存中（为了高速存取），Sessinon在用户访问第一次访问服务器时创建，</span><span style="color:rgb(255,0,0)">需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session，可调用request.getSession(true)强制生成Session。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong>Session什么时候失效？</strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　1. 服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。Tomcat中Session的默认失效时间为20分钟。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　2. 调用Session的invalidate方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(34,34,34)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(34,34,34)">多个服务部署时session管理</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(34,34,34)">三种方式：</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">1. Session复制，Web服务器之间同步session信息。</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">2. 负载均衡支持会话亲和，相同的会话请求发送给同一个Web服务器。</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">3. Session不存在Web服务器本地，而是放在缓存服务器如<a target="_blank" href="http://lib.csdn.net/base/redis" rel="nofollow noopener noreferrer" class="replace_word" title="Redis知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">Redis</a>上。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 31. servlet的一些相关问题</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 32. webservice相关问题</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 33. jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 34. 无框架下配置web.xml的主要配置内容</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 35. jsp和servlet的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 36. Java的内存模型以及GC算法</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">JVM内存模型中分两大块，一块是 NEW <a target="_blank" name="OLE_LINK24" style="color:rgb(255,153,0)">Generation</a>, 另一块是<a target="_blank" name="OLE_LINK25" style="color:rgb(255,153,0)">Old</a> Generation. 在New Generation中，有一个叫<a target="_blank" name="OLE_LINK26" style="color:rgb(255,153,0)">Eden</a>的空间，主要是用来存放新生的对象，还有两个<a target="_blank" name="OLE_LINK27" style="color:rgb(255,153,0)">Survivor Spaces</a>（from,to）, 它们用来存放每次垃圾回收后存活下来的对象。在Old Generation中，主要存放应用程序中生命周期长的内存对象，还有个<a target="_blank" name="OLE_LINK28" style="color:rgb(255,153,0)">Permanent</a> Generation，主要用来放JVM自己的反射对象，比如类对象和方法对象等。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">在New Generation块中，垃圾回收一般用Copying的算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到Old Generation中去。因此，每次GC后，Eden内存块会被清空。在Old Generation块中，垃圾回收一般用<a target="_blank" name="OLE_LINK29" style="color:rgb(255,153,0)">mark</a>-<a target="_blank" name="OLE_LINK30" style="color:rgb(255,153,0)">compact</a>的算法，速度慢些，但减少内存要求.</span><span style="color:rgb(70,70,70)"><br> </span><span style="color:rgb(70,70,70)">垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收NEW中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">1,out of memory 只发生在jvm对old和perm generation 回收后还不能获足够内存的情况.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">当一个URL被访问时，内存申请过程如下：</span><span style="color:rgb(70,70,70)"><br> </span><span style="color:rgb(70,70,70)">A. JVM会试图为相关Java对象在Eden中初始化一块内存区域</span><span style="color:rgb(70,70,70)"><br> </span><span style="color:rgb(70,70,70)">B. 当Eden空间足够时，内存申请结束。否则到下一步</span><span style="color:rgb(70,70,70)"><br> </span><span style="color:rgb(70,70,70)">C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区</span><span style="color:rgb(70,70,70)"><br> </span><span style="color:rgb(70,70,70)">D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区</span><span style="color:rgb(70,70,70)"><br> </span><span style="color:rgb(70,70,70)">E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级）</span><span style="color:rgb(70,70,70)"><br> </span><span style="color:rgb(70,70,70)">F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">造成full gc的原因:</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">new了很多对象,没有即时在主动释放掉-&gt;Eden内存不够用-&gt;不断把对象往old迁移-&gt;old满了-&gt;full gc</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">full gc 如何预防,:</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">1,使用了缓存</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">      访问有两种,第一种是缓存命中率不高的访问,第二种种是缓存命中率很高的访问.对于第一种情况,就没必要缓存了,缓存反而效果不好,浪费内存,没有提升程序效率还浪费空间,特别是如果这种访问量级别很大的时候还会导致full gc.第二种情况,不得不缓存很多对象,不缓存的话就要调用数据库或者其它是要发生io的,所以这时候要不就是想办法减少缓存对象的大小,例如不缓存没必要缓存的数据,或者合并一些数据减少内存的使用.如果还是不行那就加机器,加内存.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">       </span><span style="color:rgb(255,0,0)">总结:在不影响功能的情况下,缓存对象越小越要,命中率越高越好.低命中率的缓存对象还不如不缓存.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">2,没使用缓存的情况,貌似不会出现full gc的情况,除非内存太小,或者设置不对,程序有漏洞.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 37. jvm性能调优都做了什么</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 38. 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 39. 介绍GC 和GC Root不正常引用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 40. 自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 41. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 42. 数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 43. 老年代中数组的访问方式</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 44. GC 算法，永久代对象如何 GC ， GC 有环怎么处理</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 45. 谁会被 GC ，什么时候 GC</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 46. 如果想不被 GC 怎么办</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 47. 如果想在 GC 中生存 1 次怎么办</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 48. <a target="_blank" href="http://lib.csdn.net/base/javaee" rel="nofollow noopener noreferrer" class="replace_word" title="Java EE知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">hibernate</a>和ibatis的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 49. 讲讲mybatis的连接池。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 50. <a target="_blank" href="http://lib.csdn.net/base/javaee" rel="nofollow noopener noreferrer" class="replace_word" title="Java EE知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">spring</a>框架中需要引用哪些jar包，以及这些jar包的用途</p> 
<table style="color:rgb(0,0,0); font-family:Arial; font-size:14px"><tbody><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.aop-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring的面向切面编程,提供AOP(面向切面编程)实现</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.asm- 3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring独立的asm程序,Spring2.5.6的时候需要asmJar 包3.0.6开始提供他自己独立的asmJar</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.aspects- 3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring提供对AspectJ框架的整合</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.beans-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">S</span><span style="color:rgb(46,46,46)">pringIoC</span><span style="color:rgb(46,46,46)">(依赖注入)的基础实现</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.context.support-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring-context的扩展支持,用于</span><span style="color:rgb(46,46,46)">MVC</span><span style="color:rgb(46,46,46)">方面</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.context-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring提供在</span><span style="color:rgb(46,46,46)">基础IoC功能上的扩展服务</span><span style="color:rgb(46,46,46)">，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI定位、EJB集成、远程访问、缓存以及各种视图层框架的封装等</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.core-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring3.0.6的</span><span style="color:rgb(46,46,46)">核心工具</span><span style="color:rgb(46,46,46)">包</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.expression-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring表达式语言</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.instrument.tomcat-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring3.0.6对Tomcat的连接池的集成</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.instrument-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring3.0.6对服务器的代理接口</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.jdbc-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">对JDBC的简单封装</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.jms-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">为简化JMS API的使用而作的简单封装</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.orm-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">整合第三方的ORM框架，如hibernate,ibatis,jdo，以及 spring的JPA实现</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.oxm-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">Spring 对Object/XMl的映射支持,可以让Java与XML之间来回切换</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.test-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">对Junit等<a target="_blank" href="http://lib.csdn.net/base/softwaretest" rel="nofollow noopener noreferrer" class="replace_word" title="软件测试知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">测试</a>框架的简单封装</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.transaction-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.web.portlet-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">基于protlet的MVC实现</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.web.servlet-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">基于servlet的MVC实现</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.web.struts-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">整合Struts的时候的支持</span></p> </td></tr><tr><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">org.springframework.web-3.0.6.RELEASE</span></p> </td><td> <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="color:rgb(46,46,46)">SpringWeb下的工具包</span></p> </td></tr></tbody></table> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(46,46,46)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(46,46,46)">做Spring还必须依赖第三方包：</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(46,46,46)">① Spring 工程依赖的公共包</span><span style="color:rgb(46,46,46)"><br> </span><span style="color:rgb(46,46,46)">commons-logging-1[1].0.4.jar（只要是做Spring</span><span style="color:rgb(46,46,46)">都需要这个包</span><span style="color:rgb(46,46,46)">，否则工程起不来）</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(46,46,46)">② 使用SpringAOP功能时依赖的包</span><span style="color:rgb(46,46,46)"><br> </span><span style="color:rgb(46,46,46)"> aspectjweaver-1[1].5.3.jar</span><span style="color:rgb(46,46,46)"><br> </span><span style="color:rgb(46,46,46)">aopalliance-1.0.jar  (下载：</span><a target="_blank" href="http://mirrors.ibiblio.org/maven2/aopalliance/aopalliance/1.0/" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(61,107,167)">http://mirrors.ibiblio.org/maven2/aopalliance/aopalliance/1.0/</span></a><span style="color:rgb(46,46,46)">)</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(46,46,46)">③ 使用Spring</span><span style="color:rgb(46,46,46)">JDBC</span><span style="color:rgb(46,46,46)">功能时依赖的包</span><span style="color:rgb(46,46,46)"><br> </span><span style="color:rgb(46,46,46)">commons-dbcp.jar (下载：</span><a target="_blank" href="http://commons.apache.org/dbcp/download_dbcp.cgi" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(61,107,167)">http://commons.apache.org/dbcp/download_dbcp.cgi</span></a><span style="color:rgb(46,46,46)">)</span><span style="color:rgb(46,46,46)"><br> </span><span style="color:rgb(46,46,46)">commons-pool.jar (下载：</span><a target="_blank" href="http://mirrors.ibiblio.org/maven2/commons-pool/commons-pool/" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(15,101,156)">http://mirrors.ibiblio.org/maven2/commons-pool/commons-pool/</span></a><span style="color:rgb(46,46,46)">)</span><span style="color:rgb(46,46,46)"><br> </span><span style="color:rgb(46,46,46)">commons-collections-2.1.1.jar</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 51. springMVC的原理</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="color:rgb(51,51,51)">1. 客户端请求提交到DispatcherServlet</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)">2. 由DispatcherServlet控制器查询一个或多个<a target="_blank" name="OLE_LINK31" style="color:rgb(255,153,0)">Handler</a>Mapping，找到处理请求的Controller</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)">3. DispatcherServlet将请求提交到Controller</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)">4. Controller调用业务逻辑处理后，返回ModelAndView</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)">5. DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(51,51,51)">6. 视图负责将结果显示到客户端</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 52. springMVC注解的意思</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：@Controller <br> @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为<br> <br> 类名称开头字母小写,你也可以自己指定，如下 <br> 方法一： <br> @Controller <br> public class TestController {} <br>  <br> 方法二：            <br> @Controller("tmpController") <br> public class TestController {} <br>  <br> @RequestMapping <br>  <br> 1.@RequestMapping用来定义访问的URL，你可以为整个类定义一个<br> <br> @RequestMapping，或者为每个方法指定一个。 <br> 把@RequestMapping放在类级别上，这可令它与方法级别上的<br> <br> @RequestMapping注解协同工作，取得缩小选择范围的效果。 <br> 例如： <br> @RequestMapping("/test") <br> public class TestController {} <br> 则，该类下的所有访问路径都在/test之下。 <br>  <br> 2.将@RequestMapping用于整个类不是必须的，如果没有配置，所有的方法<br> <br> 的访问路径配置将是完全独立的，没有任何关联。 <br>  <br> 3.完整的参数项为：@RequestMapping(value="",method =<br> <br> {"",""},headers={},params={"",""})，各参数说明如下：<br> value :String[] 设置访问地址 <br> method: RequestMethod[]设置访问方式，字符数组，查看RequestMethod<br> <br> 类，包括GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE,常用<br> <br> RequestMethod.GET，RequestMethod.POST <br> headers:String[] headers一般结合method = RequestMethod.POST使用 <br> params: String[] 访问参数设置，字符数组 例如：userId=id <br>  <br> 4.value的配置还可以采用模版变量的形式 ，例如：@RequestMapping<br> <br> (value="/owners/{ownerId}", method=RequestMethod.GET)，这点将在介<br> <br> 绍@PathVariable中详细说明。 <br>  <br> 5.@RequestMapping params的补充说明，你可以通过设置参数条件来限制<br> <br> 访问地址，例如params="myParam=myValue"表达式，访问地址中参数只有<br> <br> 包含了该规定的值"myParam=myValue"才能匹配得上，类似"myParam"之类<br> <br> 的表达式也是支持的，表示当前请求的地址必须有该参数(参数的值可以是<br> <br> 任意)，"!myParam"之类的表达式表明当前请求的地址不能包含具体指定的<br> <br> 参数"myParam"。 <br>  <br> 6.有一点需要注意的，如果为类定义了访问地址为*.do,*.html之类的，则<br> <br> 在方法级的@RequestMapping，不能再定义value值，否则会报错，例如 <br> Java代码  <br> @RequestMapping("/bbs.do")  <br> public class BbsController {  <br>     @RequestMapping(params = "method=getList")  <br>     public String getList() {  <br>      return "list";  <br>     }  <br> @RequestMapping(value= "/spList")  <br> public String getSpecialList() {  <br>      return "splist";  <br>     }  <br> }  <br>  <br> 如上例：/bbs.do?method=getList 可以访问到方法getList() ；而访<br> <br> 问/bbs.do/spList则会报错. <br>  <br> @PathVariable <br> 1.@PathVariable用于方法中的参数，表示方法参数绑定到地址URL的模板<br> <br> 变量。 <br> 例如： <br> Java代码  <br> @RequestMapping(value="/owners/{ownerId}", <br> <br> method=RequestMethod.GET)  <br> public String findOwner(@PathVariable String ownerId, Model <br> <br> model) {  <br>   Owner owner = ownerService.findOwner(ownerId);    <br>   model.addAttribute("owner", owner);    <br>   return "displayOwner";  <br> }  <br>  <br> 2.@PathVariable用于地址栏使用{xxx}模版变量时使用。 <br> 如果@RequestMapping没有定义类似"/{ownerId}" ，这种变量，则使用在<br> <br> 方法中@PathVariable会报错。 <br>  <br>  <br> @ModelAttribute <br> 1.应用于方法参数,参数可以在页面直接获取，相当于<br> <br> request.setAttribute(,) <br> 2.应用于方法,将任何一个拥有返回值的方法标注上 @ModelAttribute，使<br> <br> 其返回值将会进入到模型对象的属性列表中. <br> 3.应用于方法参数时@ModelAttribute("xx"),须关联到Object的数据类型<br> <br> ，基本数据类型 如：int,String不起作用 <br> 例如： <br> Java代码  <br> @ModelAttribute("items")//&lt;——①向模型对象中添加一个名为items的<br> <br> 属性  <br> public List&lt;String&gt; populateItems() {  <br>         List&lt;String&gt; lists = new ArrayList&lt;String&gt;();  <br>         lists.add("item1");  <br>         lists.add("item2");  <br>         return lists;  <br> }  <br> @RequestMapping(params = "method=listAllBoard")  <br> public String listAllBoard(@ModelAttribute("currUser")User user, <br> <br> ModelMap model) {  <br>         bbtForumService.getAllBoard();  <br>         //&lt;——②在此访问模型中的items属性  <br>         System.out.println("model.items:" + ((List&lt;String&gt;)<br> <br> model.get("items")).size());  <br>         return "listBoard";  <br> }  <br>  <br> 在 ① 处，通过使用 @ModelAttribute 注解，populateItem() 方法将在<br> <br> 任何请求处理方法执行前调用，Spring MVC 会将该方法返回值以“items<br> <br> ”为名放入到隐含的模型对象属性列表中。 <br> 所以在 ② 处，我们就可以通过 ModelMap 入参访问到 items 属性，当执<br> <br> 行 listAllBoard() 请求处理方法时，② 处将在控制台打印<br> <br> 出“model.items:2”的信息。当然我们也可以在请求的视图中访问到模型<br> <br> 对象中的 items 属性。 <br>  <br>  <br> @ResponseBody <br> 这个注解可以直接放在方法上，表示返回类型将会直接作为HTTP响应字节<br> <br> 流输出(不被放置在Model，也不被拦截为视图页面名称)。可以用于ajax。 <br>  <br> @RequestParam <br> @RequestParam是一个可选参数，例如：@RequestParam("id") 注解，所以<br> <br> 它将和URL所带参数 id进行绑定 <br> 如果入参是基本数据类型（如 int、long、float 等），URL 请求参数中<br> <br> 一定要有对应的参数，否则将抛出 <br> <br> org.springframework.web.util.NestedServletException 异常，提示无<br> <br> 法将 null 转换为基本数据类型. <br>  <br> @RequestParam包含3个配置 @RequestParam(required = ,value="", <br> <br> defaultValue = "") <br> required :参数是否必须，boolean类型,可选项，默认为true <br> value: 传递的参数名称，String类型,可选项，如果有值，对应到设置方<br> <br> 法的参数 <br> defaultValue:String类型,参数没有传递时为参数默认指定的值 <br>  <br> @SessionAttributes session管理 <br> Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 <br> <br> session 中，以便下一个请求属对应的 ModelMap 的属性列表中还能访问<br> <br> 到这些属性。这一功能是通过类定义处标注 @SessionAttributes 注解来<br> <br> 实现的。@SessionAttributes 只能声明在类上，而不能声明在方法上。 <br>  <br> 例如 <br>  <br> @SessionAttributes("currUser") // 将ModelMap 中属性名为currUser 的属性 <br> <br> <br> @SessionAttributes({"attr1","attr2"}) <br> @SessionAttributes(types = User.class) <br> @SessionAttributes(types = {User.class,Dept.class}) <br> @SessionAttributes(types = {User.class,Dept.class},value={"attr1","attr2"}) <br> <br>  <br> @CookieValue 获取cookie信息 <br> @RequestHeader 获取请求的头部信息</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 53. spring中beanFactory和ApplicationContext的联系和区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="color:rgb(51,51,51)">1. BeanFactory负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">2. ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">a. 国际化支持</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">b. 资源访问：Resource rs = ctx. getResource(“classpath:config.properties”), “file:c:/config.properties”</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">c. 事件传递：通过实现ApplicationContextAware接口</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 54. spring注入的几种方式（循环注入）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="color:rgb(75,75,75)">1.    接口注入（</span><span style="color:rgb(246,0,0)">不推荐</span><span style="color:rgb(75,75,75)">）</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(75,75,75)">2.    getter，setter方式注入（</span><span style="color:rgb(246,0,0)">比较常用</span><span style="color:rgb(75,75,75)">）</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(75,75,75)">3.    构造器注入（</span><span style="color:rgb(246,0,0)">死的应用</span><span style="color:rgb(75,75,75)">）</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 55. spring如何实现事物管理的</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; background:rgb(243,255,236)"> 答：<span style="color:rgb(51,51,51)">Spring+Hibernate<span style="font-family:宋体">的实质：</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">就是把Hibernate<span style="font-family:宋体">用到的数据源</span>Datasource<span style="font-family:宋体">，</span>Hibernate<span style="font-family:宋体">的</span>SessionFactory<span style="font-family:宋体">实例，事务管理器</span>HibernateTransactionManager<span style="font-family:宋体">，都交给</span>Spring<span style="font-family:宋体">管理。</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">那么再没整合之前Hibernate<span style="font-family:宋体">是如何实现事务管理的呢？</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">通过ServletFilter<span style="font-family:宋体">实现数据库事务的管理，这样就避免了在数据库操作中每次都要进行数据库事务处理。</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">一.<span style="font-family:宋体">事务的</span>4<span style="font-family:宋体">个特性：</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">   原子性：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做，要么全部做。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">   一致性：数据不会因为事务的执行而遭到破坏。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">   隔离性：一个事务的执行，不受其他事务（进程）的干扰。既并发执行的个事务之间互不干扰。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">   持久性：一个事务一旦提交，它对数据库的改变将是永久的。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">二.<span style="font-family:宋体">事务的实现方式：</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">实现方式共有两种：编码方式；声明式事务管理方式。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">基于AOP<span style="font-family:宋体">技术实现的声明式事务管理，实质就是：在方法执行前后进行拦截，然后在目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务。</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">声明式事务管理又有两种方式：基于XML<span style="font-family:宋体">配置文件的方式；另一个是在业务方法上进行</span>@Transactional<span style="font-family:宋体">注解，将事务规则应用到业务逻辑中。</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">三.<span style="font-family:宋体">创建事务的时机：</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">是否需要创建事务，是由事务传播行为控制的。读数据不需要或只为其指定只读事务，而数据的插入，修改，删除就需要事务管理了。</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">一种常见的事务管理配置：事务拦截器TransactionInterceptor<span style="font-family:宋体">和事务自动代理</span>BeanNameAutoProxyCreator<span style="font-family:宋体">相结合的方式</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">&lt;!--<span style="font-family:宋体">定义</span>Hibernate<span style="font-family:宋体">的事务管理器</span>HibernateTransactionManager --&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;bean id="transactionManager" </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">     class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">        &lt;!-- <span style="font-family:宋体">依赖注入上面定义的</span>sessionFactory --&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;/bean&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">&lt;!--<span style="font-family:宋体">定义</span>Spring<span style="font-family:宋体">的事务拦截器</span>TransactionInterceptor --&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;bean id="transactionInterceptor"      class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;!--  <span style="font-family:宋体">依赖注入上面定义的事务管理器</span>transactionManager --&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">        &lt;property name="transactionManager" ref="transactionManager"/&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">      </span><span style="color:rgb(51,51,51)">&lt;!-- <span style="font-family:宋体">定义需要进行事务拦截的方法及所采用的事务控制类型 </span>--&gt;    </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    </span><span style="color:rgb(51,51,51)">&lt;property name="transactionAttributes"&gt;</span><span style="color:rgb(51,51,51)">    </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;props&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;!-- <span style="font-family:宋体">以</span>browse<span style="font-family:宋体">、</span>list<span style="font-family:宋体">、</span>load<span style="font-family:宋体">、</span>get<span style="font-family:宋体">及</span>is<span style="font-family:宋体">开头的所有方法采用只读型事务控制类型 </span>--&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;prop key="browse*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;prop key="list*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;prop key="is*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;!-- <span style="font-family:宋体">所有方法均进行事务控制，如果当前没有事务，则新建一个事务 </span>--&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    </span><span style="color:rgb(51,51,51)">&lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;/props&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;/property&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">&lt;/bean&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">&lt;!-- <span style="font-family:宋体">定义</span>BeanNameAutoProxyCreatorf<span style="font-family:宋体">进行</span>Spring<span style="font-family:宋体">的事务处理</span>--&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;!--  <span style="font-family:宋体">针对指定的</span>bean<span style="font-family:宋体">自动生成业务代理 </span>--&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;property name="beanNames"&gt; </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">            &lt;list&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;adminService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;columnsService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;newsService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;crawlService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;memberLevelService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;memberService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;categoryService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;merService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;cartService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;ordersService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;trafficService&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">            &lt;/list&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;/property&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;!--  <span style="font-family:宋体">这个属性为</span>true<span style="font-family:宋体">时，表示被代理的是目标类本身而不是目标类的接口 </span>--&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;property name="proxyTargetClass"&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    </span><span style="color:rgb(51,51,51)">&lt;value&gt;true&lt;/value&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;/property&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">       &lt;!--  <span style="font-family:宋体">依赖注入上面定义的事务拦截器</span>transactionInterceptor --&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">        &lt;property name="interceptorNames"&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">            &lt;list&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">                &lt;value&gt;transactionInterceptor&lt;/value&gt; </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">            &lt;/list&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">        &lt;/property&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">    &lt;/bean&gt;</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">尤其注意：如下</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">***********************************************************************************************************</span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">【以上的事务拦截器和事务自动代理方式实现原理：像Struts2<span style="font-family:宋体">一样，都是凭借强大的拦截器功能对业务逻辑方法的调用进行拦截，然后又</span>BeanNameAutoProxyCreator<span style="font-family:宋体">自动生成事务代理，最后送事务管理器，统一管理】</span></span><span style="color:rgb(51,51,51)"><br> </span><span style="color:rgb(51,51,51)">***********************************************************************************************************</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 56. springIOC</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 57. spring AOP的原理</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="color:rgb(70,70,70)">下面为spring的主要原理：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">IoC(Inversion of Control)：IoC就是应用本身不依赖对象的创建和维护而是交给外部容器(这里为spring),这要就把应用和对象之间解耦,控制权交给了外部容器。即Don't call me ,I'll call you！所以IoC也称DI(依赖注入)对象的创建和维护依赖于外部容器.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">class UserService{<!-- --></span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">private UserDao userDao = new UserDaoImpl();  //让业务层与数据访问层耦合在一起,不利用以后模块的替换.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">private UserDao userDao_IoC = null;</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">public void SetUserDao(UserDao userDao){<!-- --></span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">this.userDao_IoC = userDao</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">}</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">public void save(User user){<!-- --></span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">userDao.save(user);</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">}</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">}</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">AOP(Aspect Oriented Programming)：面向切面编程。就是把一些贯穿在各个模块之间相同的功能抽象出来,然后封装成一个面。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">AOP一般都是通过代理来实现,利用代理就有目标对象是什么,拦截哪些点(方法),拦截后要做什么。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">JoinPoint(连接点)：被拦截到的点. Advice(通知):拦截JoinPoint之前与之后要做的事。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">PointCut(切入点):对joinPoint进行拦截的定义。Target(目标对象)：代理的目标对象。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">对于异常处理,日志功能,权限的检查,事务等都是贯穿到各个模块之中,因此进行AOP.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">代理技术有面向接口和生成子类.</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">public Object getProxy(final Object targetObj) { </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">Obejct obj = Proxy.newProxyInstance( </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">    targetObj.getClass().getClassLoader(),       //被代理类的类加载器</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">    targetObj.getClass().getInterfaces(),   //被代理类接口的字节码</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">    new InvocationHandler() {   //类似于一个回调函数 代理功能就在里面实现</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">        @Override </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{<!-- --></span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">    try{ </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">beforeAdvice();   //前置通知</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">        method.invoke(targetObj, args);  //拦截的点</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">afterAdvice();    //后置通知</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">    }catch (Exception e) { </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">        exceptionAdvice();   //异常通知</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">    }finally{ </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">                        finalAdvice();   //必须执行通知</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">                    } </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">                   return obj; </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> } </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> }); </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> }</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">还一个用子类实现的同理 要采用CGlib库来实现 JDK6之前未提供,估计JDK以后会提供。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(70,70,70)">这就是spring的2大原理,自如怎么配置,那就要花点时间去学,原理思想掌握了哪些配置方法随便学下就明白了。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 58. hibernate中的1级和2级缓存的使用方式以及区别原理</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （Lazy-Load的理解）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对物理数据源访问的频次，从而提高了应用的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　缓存的介质一般是内存，所以读写速度很快。但如果缓存中存放的数据量非常大时，也会用硬盘作为缓存介质。缓存的实现不仅仅要考虑存储的介质，还要考虑到管理缓存的并发访问和缓存数据的生命周期。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　Hibernate<span style="font-family:宋体">的缓存包括</span>Session<span style="font-family:宋体">的缓存和</span>SessionFactory<span style="font-family:宋体">的缓存，其中</span>SessionFactory<span style="font-family:宋体">的缓存又可以分为两类：内置缓存和外置缓存。</span>Session<span style="font-family:宋体">的缓存是内置的，不能被卸载，也被称为</span>Hibernate<span style="font-family:宋体">的第一级缓存。</span>SessionFactory<span style="font-family:宋体">的内置缓存和</span>Session<span style="font-family:宋体">的缓存在实现方式上比较相似，前者是</span>SessionFactory<span style="font-family:宋体">对象的一些集合属性包含的数据，后者是指</span>Session<span style="font-family:宋体">的一些集合属性包含的数据。</span>SessionFactory<span style="font-family:宋体">的内置缓存中存放了映射元数据和预定义</span>SQL<span style="font-family:宋体">语句，映射元数据是映射文件中数据的拷贝，而预定义</span>SQL<span style="font-family:宋体">语句是在</span>Hibernate<span style="font-family:宋体">初始化阶段根据映射元数据推导出来，</span>SessionFactory<span style="font-family:宋体">的内置缓存是只读的，应用程序不能修改缓存中的映射元数据和预定义</span>SQL<span style="font-family:宋体">语句，因此</span>SessionFactory<span style="font-family:宋体">不需要进行内置缓存与映射文件的同步。</span>SessionFactory<span style="font-family:宋体">的外置缓存是一个可配置的插件。在默认情况下，</span>SessionFactory<span style="font-family:宋体">不会启用这个插件。外置缓存的数据是数据库数据的拷贝，外置缓存的介质可以是内存或者硬盘。</span>SessionFactory<span style="font-family:宋体">的外置缓存也被称为</span>Hibernate<span style="font-family:宋体">的第二级缓存。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　Hibernate<span style="font-family:宋体">的这两级缓存都位于持久化层，存放的都是数据库数据的拷贝，那么它们之间的区别是什么呢？为了理解二者的区别，需要深入理解持久化层的缓存的两个特性：缓存的范围和缓存的并发访问策略。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　持久化层的缓存的范围</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　缓存的范围决定了缓存的生命周期以及可以被谁访问。缓存的范围分为三类。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　1 <span style="font-family:宋体">事务范围：缓存只能被当前事务访问。缓存的生命周期依赖于事务的生命周期，当事务结束时，缓存也就结束生命周期。在此范围下，缓存的介质是内存。事务可以是数据库事务或者应用事务，每个事务都有独自的缓存，缓存内的数据通常采用相互关联的的对象形式。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　2 <span style="font-family:宋体">进程范围：缓存被进程内的所有事务共享。这些事务有可能是并发访问缓存，因此必须对缓存采取必要的事务隔离机制。缓存的生命周期依赖于进程的生命周期，进程结束时，缓存也就结束了生命周期。进程范围的缓存可能会存放大量的数据，所以存放的介质可以是内存或硬盘。缓存内的数据既可以是相互关联的对象形式也可以是对象的松散数据形式。松散的对象数据形式有点类似于对象的序列化数据，但是对象分解为松散的算法比对象序列化的算法要求更快。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　3 <span style="font-family:宋体">集群范围：在集群环境中，缓存被一个机器或者多个机器的进程共享。缓存中的数据被复制到集群环境中的每个进程节点，进程间通过远程通信来保证缓存中的数据的一致性，缓存中的数据通常采用对象的松散数据形式。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　对大多数应用来说，应该慎重地考虑是否需要使用集群范围的缓存，因为访问的速度不一定会比直接访问数据库数据的速度快多少。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　持久化层可以提供多种范围的缓存。如果在事务范围的缓存中没有查到相应的数据，还可以到进程范围或集群范围的缓存内查询，如果还是没有查到，那么只有到数据库中查询。事务范围的缓存是持久化层的第一级缓存，通常它是必需的；进程范围或集群范围的缓存是持久化层的第二级缓存，通常是可选的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　持久化层的缓存的并发访问策略</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　当多个并发的事务同时访问持久化层的缓存的相同数据时，会引起并发问题，必须采用必要的事务隔离措施。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　在进程范围或集群范围的缓存，即第二级缓存，会出现并发问题。因此可以设定以下四种类型的并发访问策略，每一种策略对应一种事务隔离级别。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　事务型：仅仅在受管理环境中适用。它提供了Repeatable Read<span style="font-family:宋体">事务隔离级别。对于经常被读但很少修改的数据，可以采用这种隔离类型，因为它可以防止脏读和不可重复读这类的并发问题。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　读写型：提供了Read Committed<span style="font-family:宋体">事务隔离级别。仅仅在非集群的环境中适用。对于经常被读但很少修改的数据，可以采用这种隔离类型，因为它可以防止脏读这类的并发问题。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　非严格读写型：不保证缓存与数据库中数据的一致性。如果存在两个事务同时访问缓存中相同数据的可能，必须为该数据配置一个很短的数据过期时间，从而尽量避免脏读。对于极少被修改，并且允许偶尔脏读的数据，可以采用这种并发访问策略。 　　只读型：对于从来不会修改的数据，如参考数据，可以使用这种并发访问策略。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　事务型并发访问策略是事务隔离级别最高，只读型的隔离级别最低。事务隔离级别越高，并发性能就越低。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　什么样的数据适合存放到第二级缓存中？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　1<span style="font-family:宋体">、很少被修改的数据</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　2<span style="font-family:宋体">、不是很重要的数据，允许出现偶尔并发的数据</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　3<span style="font-family:宋体">、不会被并发访问的数据</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　4<span style="font-family:宋体">、参考数据</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　不适合存放到第二级缓存的数据？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　1<span style="font-family:宋体">、经常被修改的数据</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　2<span style="font-family:宋体">、财务数据，绝对不允许出现并发</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　3<span style="font-family:宋体">、与其他应用共享的数据。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　Hibernate<span style="font-family:宋体">的二级缓存</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　如前所述，Hibernate<span style="font-family:宋体">提供了两级缓存，第一级是</span>Session<span style="font-family:宋体">的缓存。由于</span>Session<span style="font-family:宋体">对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。第一级缓存是必需的，不允许而且事实上也无法比卸除。在第一级缓存中，持久化类的每个实例都具有唯一的</span>OID<span style="font-family:宋体">。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　第二级缓存是一个可插拔的的缓存插件，它是由SessionFactory<span style="font-family:宋体">负责管理。由于</span>SessionFactory<span style="font-family:宋体">对象的生命周期和应用程序的整个过程对应，因此第二级缓存是进程范围或者集群范围的缓存。这个缓存中存放的对象的松散数据。第二级对象有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。缓存适配器用于把具体的缓存实现软件与</span>Hibernate<span style="font-family:宋体">集成。第二级缓存是可选的，可以在每个类或每个集合的粒度上配置第二级缓存。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　Hibernate<span style="font-family:宋体">的二级缓存策略的一般过程如下：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　1) <span style="font-family:宋体">条件查询的时候，总是发出一条</span>select * from table_name where …. <span style="font-family:宋体">（选择所有字段）这样的</span>SQL<span style="font-family:宋体">语句查询数据库，一次获得所有的数据对象。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　2) <span style="font-family:宋体">把获得的所有数据对象根据</span>ID<span style="font-family:宋体">放入到第二级缓存中。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　3) <span style="font-family:宋体">当</span>Hibernate<span style="font-family:宋体">根据</span>ID<span style="font-family:宋体">访问数据对象的时候，首先从</span>Session<span style="font-family:宋体">一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照</span>ID<span style="font-family:宋体">放入到缓存。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　4) <span style="font-family:宋体">删除、更新、增加数据的时候，同时更新缓存。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　Hibernate<span style="font-family:宋体">的二级缓存策略，是针对于</span>ID<span style="font-family:宋体">查询的缓存策略，对于条件查询则毫无作用。为此，</span>Hibernate<span style="font-family:宋体">提供了针对条件查询的</span>Query<span style="font-family:宋体">缓存。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　Hibernate<span style="font-family:宋体">的</span>Query<span style="font-family:宋体">缓存策略的过程如下：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　1) Hibernate<span style="font-family:宋体">首先根据这些信息组成一个</span>Query Key<span style="font-family:宋体">，</span>Query Key<span style="font-family:宋体">包括条件查询的请求一般信息：</span>SQL, SQL<span style="font-family:宋体">需要的参数，记录范围（起始位置</span>rowStart<span style="font-family:宋体">，最大记录个数</span>maxRows)<span style="font-family:宋体">，等。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　2) Hibernate<span style="font-family:宋体">根据这个</span>Query Key<span style="font-family:宋体">到</span>Query<span style="font-family:宋体">缓存中查找对应的结果列表。如果存在，那么返回这个结果列表；如果不存在，查询数据库，获取结果列表，把整个结果列表根据</span>Query Key<span style="font-family:宋体">放入到</span>Query<span style="font-family:宋体">缓存中。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 　　3) Query Key<span style="font-family:宋体">中的</span>SQL<span style="font-family:宋体">涉及到一些表名，如果这些表的任何数据发生修改、删除、增加等操作，这些相关的</span>Query Key<span style="font-family:宋体">都要从缓存中清空。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(0,176,240); background:rgb(0,255,0)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 59. Hibernate的原理体系<a target="_blank" href="http://lib.csdn.net/base/architecture" rel="nofollow noopener noreferrer" class="replace_word" title="大型网站架构知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">架构</a>，五大核心接口，Hibernate对象的三种状态转换，事务管理。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 60. Java创建线程之后，直接调用start()方法和run()的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 61. 常用的线程池模式以及不同线程池的使用场景</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 62. newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 63. 多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 64. 了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 65. 同步的<a target="_blank" href="http://lib.csdn.net/base/datastructure" rel="nofollow noopener noreferrer" class="replace_word" title="算法与数据结构知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">数据结构</a>，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 66. atomicinteger和<a target="_blank" href="http://www.codeceo.com/article/java-volatile-var.html" rel="nofollow noopener noreferrer" title="Volatile" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(0,0,0)">Volatile</span></a>等线程安全操作的关键字的理解和使用</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 67. 线程间通信，wait和notify</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 68. 定时线程的使用</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 69. 场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 70. 进程和线程的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 71. 什么叫线程安全？举例说明</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 72. 线程的几种状态</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 73. 并发、同步的接口或方法</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 74. HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 75. J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 76. 简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 77. volatile的理解</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 78. 实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 79. http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="color:rgb(255,0,0)">HTTP/1.1</span>规定的 <span style="font-family:Verdana">HTTP </span><span style="font-family:宋体">请求方法有</span><span style="font-family:Verdana">8</span><span style="font-family:宋体">种</span><span style="font-family:Verdana">CONNECT </span><span style="font-family:宋体">、</span><span style="font-family:Verdana">OPTIONS</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">PUT</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">DELETE</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">TRACE</span><span style="font-family:宋体">、</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> GET<span style="font-family:宋体">、</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> HEAD<span style="font-family:宋体">、</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> POST<span style="font-family:宋体">：包含了</span><span style="font-family:Verdana"> </span><span style="color:rgb(255,0,0)">Content-Type</span> <span style="font-family:宋体">和</span><span style="color:rgb(255,0,0)">消息主体编码方式</span>两部分</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong>application/x-www-form-urlencoded</strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 最常见的 <span style="font-family:Verdana">POST </span><span style="font-family:宋体">提交数据的方式了。浏览器的原生 </span><span style="font-family:Verdana">form </span><span style="font-family:宋体">表单，如果不设置 </span><span style="font-family:Verdana">enctype </span><span style="font-family:宋体">属性，那么最终就会以 </span><span style="font-family:Verdana">application/x-www-form-</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> urlencoded <span style="font-family:宋体">方式提交数据</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong>multipart/form-data</strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 使用表单上传文件时，必须让 <span style="font-family:Verdana">form </span><span style="font-family:宋体">的 </span><span style="font-family:Verdana">enctyped </span><span style="font-family:宋体">等于这个值</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(255,0,0)">自己定义新的数据提交方式：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong>application/json</strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 <span style="font-family:Verdana">JSON </span><span style="font-family:宋体">字符串。由于 </span><span style="font-family:Verdana">JSON </span><span style="font-family:宋体">规范的流行，除了低版本 </span><span style="font-family:Verdana">IE </span><span style="font-family:宋体">之外的</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 各大浏览器都原生支持 <span style="font-family:Verdana">JSON.stringify</span><span style="font-family:宋体">，服务端语言也都有处理 </span><span style="font-family:Verdana">JSON </span><span style="font-family:宋体">的函数，使用 </span><span style="font-family:Verdana">JSON </span><span style="font-family:宋体">不会遇上什么麻烦。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> http<span style="font-family:宋体">中，</span><span style="color:rgb(255,0,0)">Get<span style="font-family:宋体">和</span><span style="font-family:Verdana">Post</span></span>的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> GET 被强制服务器支持</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> GET请求发送数据更小</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> GET请求是安全的， 这里的安全指的是在规范的定义下，Get操作不会修改服务器的数据</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> GET请求是幂等的</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> POST请求不能被缓存</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> POST请求相对GET请求是「安全」的，这里所有的「安全」是相对的，因为GET请求有时候会直接反应在浏览器的地址栏，而现在的浏览器大多会记住曾经输入过的URL</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 80. socket通信，以及长连接，分包，连接异常断开的处理。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 81. socket通信模型的使用，AIO和NIO。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 82. socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 83. 同步和异步，阻塞和非阻塞。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 84. OSI七层模型，包括TCP,IP的一些基本知识</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 85. http中，get post的区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 86. 说说http,tcp,udp之间关系和区别。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 87. 说说浏览器访问www.taobao.com，经历了怎样的过程。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 88. HTTP协议、  HTTPS协议，SSL协议及完整交互过程；</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 89. tcp的拥塞，快回传，ip的报文丢弃</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 90. https处理的一个过程，对称加密和非对称加密</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 91. head各个特点和区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 92. 说说浏览器访问www.taobao.com，经历了怎样的过程。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 93. <a target="_blank" href="http://lib.csdn.net/base/mysql" rel="nofollow noopener noreferrer" class="replace_word" title="MySQL知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">MySQL</a>的存储引擎的不同</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="color:rgb(51,51,51)">这个是考虑性能的问题，还有事务的支持，吧 百度一下你就知道 MyISAM、InnoDB、Heap(Memory)、NDB 貌似一般都是使用 <a target="_blank" name="OLE_LINK23" style="color:rgb(255,153,0)">Inno</a>DB的， mysql的存储引擎包括：MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDBCluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎都是非事务安全表。 最常使用的2种存储引擎: 1.Myisam是Mysql的默认存储引擎，当create创建新表时，未指定新表的存储引擎时，默认使用Myisam。每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD(MYData，存储数据)、.MYI(MYIndex，存储索引)。数据文件和索引文件可以放置在不同的目录，平均分布io，获得更快的速度。 2.InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比Myisam的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 94. 单个索引、联合索引、主键索引</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<strong><span style="color:rgb(34,34,34)">Mysql索引概念：</span></strong><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">说说Mysql索引，看到一个很少比如：索引就好比一本书的目录，它会让你更快的找到内容，显然目录（索引）并不是越多越好，假如这本书1000页，有500也是目录，它当然效率低，目录是要占纸张的,而索引是要占磁盘空间的。</span><span style="color:rgb(34,34,34)"><br> </span><strong><span style="color:rgb(34,34,34)">Mysql索引主要有两种结构：</span><span style="color:rgb(55,55,55)">B+树和hash.</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(255,0,0)">hash:</span><span style="color:rgb(34,34,34)">hsah索引在mysql比较少用,他以把数据的索引以hash形式组织起来,因此当查找某一条记录的时候,速度非常快.当时因为是hash结构,每个键只对应一个值,而且是散列的方式分布.所以他并不支持范围查找和排序等功能.</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(255,0,0)">B+树:</span><span style="color:rgb(34,34,34)">b+tree是mysql使用最频繁的一个索引数据结构,数据结构以平衡树的形式来组织,因为是树型结构,所以更适合用来处理排序,范围查找等功能.相对hash索引,B+树在查找单条记录的速度虽然比不上hash索引,但是因为更适合排序等操作,所以他更受用户的欢迎.毕竟不可能只对数据库进行单条记录的操作. </span><span style="color:rgb(34,34,34)"><br> </span><strong><span style="color:rgb(34,34,34)">Mysql常见索引有：</span></strong><span style="color:rgb(34,34,34)">主键索引、唯一索引、普通索引、全文索引、组合索引</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(255,0,0)">PRIMARY KEY（主键索引）</span><span style="color:rgb(34,34,34)">  ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) </span><span style="color:rgb(255,0,0)">UNIQUE(唯一索引)</span><span style="color:rgb(34,34,34)">     ALTER TABLE `table_name` ADD UNIQUE (`column`)</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(255,0,0)">INDEX(普通索引)  </span><span style="color:rgb(34,34,34)">   ALTER TABLE `table_name` ADD INDEX index_name ( `column` ) </span><span style="color:rgb(255,0,0)">FULLTEXT(全文索引)  </span><span style="color:rgb(34,34,34)">    ALTER TABLE `table_name` ADD FULLTEXT ( `column` )</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(255,0,0)">组合索引</span><span style="color:rgb(34,34,34)">   ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` ) </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(34,34,34)">Mysql各种索引区别：</span></strong><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">普通索引：最基本的索引，没有任何限制</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">主键索引：它 是一种特殊的唯一索引，不允许有空值。 </span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。</span><span style="color:rgb(34,34,34)"><br> </span><span style="color:rgb(34,34,34)">组合索引：为了更多的提高mysql效率可建立组合索引，遵循”</span><span style="color:rgb(34,34,34)">最左前缀“<span style="font-family:微软雅黑">原则。</span></span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 95. Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="color:rgb(73,73,73)">当一张的数据达到几百万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">根据个人经验，mysql执行一个sql的过程如下：</span><span style="color:rgb(73,73,73)"><br> </span><span style="color:rgb(73,73,73)">1,接收到sql;2,把sql放到排队队列中 ;3,执行sql;4,返回执行结果。在这个执行过程中最花时间在什么地方呢？第一，是排队等待的时间，第二，sql的执行时间。其实这二个是一回事，等待的同时，肯定有sql在执行。所以我们要缩短sql的执行时间。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">mysql中有一种机制是表锁定和行锁定，为什么要出现这种机制，是为了保证数据的完整性，我举个例子来说吧，如果有二个sql都要修改同一张表的同一条 数据，这个时候怎么办呢，是不是二个sql都可以同时修改这条数据呢？很显然mysql对这种情况的处理是，一种是表锁定（myisam存储引擎），一个 是行锁定（innodb存储引擎）。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完 了，才能对这条数据进行操作。如果数据太多，一次执行的时间太长，等待的时间就越长，这也是我们为什么要分表的原因。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(73,73,73)">二，分表</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(73,73,73)">1，做mysql集群，例如：利用mysql cluster ，mysql proxy，mysql replication，drdb等等</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">有人会问mysql集群，根分表有什么关系吗？虽然它不是实际意义上的分表，但是它启到了分表的作用，做集群的意义是什么呢？为一个数据库减轻负担，说白 了就是减少sql排队队列中的sql的数量，举个例子：有10个sql请求，如果放在一个数据库服务器的排队队列中，他要等很长时间，如果把这10个 sql请求，分配到5个数据库服务器的排队队列中，一个数据库服务器的队列中只有2个，这样等待时间是不是大大的缩短了呢？这已经很明显了。所以我把它列 到了分表的范围以内，我做过一些mysql的集群：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <a target="_blank" href="http://www.xitongwang.com/" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(180,41,46)">linux</span></a><span style="color:rgb(73,73,73)"> mysql proxy 的安装，配置，以及读写分离</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">mysql replication 互为主从的安装及配置，以及数据同步</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(0,51,0)">优点：扩展性好，没有多个分表后的复杂操作（<a target="_blank" href="http://lib.csdn.net/base/php" rel="nofollow noopener noreferrer" class="replace_word" title="PHP知识库" style="color:rgb(223,52,52); text-decoration:none">PHP</a>代码）</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(0,51,0)">缺点：单个表的数据量还是没有变，一次操作所花的时间还是那么多，硬件开销大。</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(73,73,73)">2，预先估计会出现<a target="_blank" href="http://lib.csdn.net/base/hadoop" rel="nofollow noopener noreferrer" class="replace_word" title="Hadoop知识库" style="color:rgb(223,52,52); text-decoration:none">大数据</a>量并且访问频繁的表，将其分为若干个表</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">这种预估大差不差的，论坛里面发表帖子的表，时间长了这张表肯定很大，几十万，几百万都有可能。 聊天室里面信息表，几十个人在一起一聊一个晚上，时间长了，这张表的数据肯定很大。像这样的情况很多。所以这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。以聊天信息表为例：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">我事先建100个这样的表，message_00,message_01,message_02……….message_98,message_99.然 后根据用户的ID来判断这个用户的聊天信息放到哪张表里面，你可以用hash的方式来获得，可以用求余的方式来获得，方法很多，各人想各人的吧。下面用 hash的方法来获得表名：</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">1. </span><span style="color:rgb(73,73,73)">&lt;?php   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">2. </span><span style="color:rgb(73,73,73)">function get_hash_table($table,$userid) {   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">3. </span><span style="color:rgb(73,73,73)"> $str = crc32($userid);   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">4. </span><span style="color:rgb(73,73,73)"> if($str&lt;0){   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">5. </span><span style="color:rgb(73,73,73)"> $hash = "0".substr(abs($str), 0, 1);   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">6. </span><span style="color:rgb(73,73,73)"> }else{   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">7. </span><span style="color:rgb(73,73,73)"> $hash = substr($str, 0, 2);   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">8. </span><span style="color:rgb(73,73,73)"> }   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">9. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">10. </span><span style="color:rgb(73,73,73)"> return $table."_".$hash;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">11. </span><span style="color:rgb(73,73,73)">}   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">12. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">13. </span><span style="color:rgb(73,73,73)">echo get_hash_table('message','user18991');     //结果为message_10   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">14. </span><span style="color:rgb(73,73,73)">echo get_hash_table('message','user34523');    //结果为message_13   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">15. </span><span style="color:rgb(73,73,73)">?&gt;  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">说明一下，上面的这个方法，告诉我们user18991这个用户的消息都记录在message_10这张表里，user34523这个用户的消息都记录在message_13这张表里，读取的时候，只要从各自的表中读取就行了。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(0,51,0)">优点：避免一张表出现几百万条数据，缩短了一条sql的执行时间</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(0,51,0)">缺点：当一种规则确定时，打破这条规则会很麻烦，上面的例子中我用的hash算法是crc32，如果我现在不想用这个算法了，改用md5后，会使同一个用户的消息被存储到不同的表中，这样数据乱套了。扩展性很差。</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(73,73,73)">3，利用merge存储引擎来实现分表</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">我觉得这种方法比较适合，那些没有事先考虑，而已经出现了得，数据查询慢的情况。这个时候如果要把已有的大数据量表分开比较痛苦，最痛苦的事就是改代码， 因为程序里面的sql语句已经写好了，现在一张表要分成几十张表，甚至上百张表，这样sql语句是不是要重写呢？举个例子，我很喜欢举子</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">mysql&gt;show engines;的时候你会发现mrg_myisam其实就是merge。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)"><br> </span><span style="color:rgb(73,73,73)"><br> </span><span style="color:rgb(73,73,73)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">1. </span><span style="color:rgb(73,73,73)">mysql&gt; CREATE TABLE IF NOT EXISTS `user1` (   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">2. </span><span style="color:rgb(73,73,73)"> -&gt;   `id` int(11) NOT NULL AUTO_INCREMENT,   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">3. </span><span style="color:rgb(73,73,73)"> -&gt;   `name` varchar(50) DEFAULT NULL,   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">4. </span><span style="color:rgb(73,73,73)"> -&gt;   `sex` int(1) NOT NULL DEFAULT '0',   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">5. </span><span style="color:rgb(73,73,73)"> -&gt;   PRIMARY KEY (`id`)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">6. </span><span style="color:rgb(73,73,73)"> -&gt; ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">7. </span><span style="color:rgb(73,73,73)">Query OK, 0 rows affected (0.05 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">8. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">9. </span><span style="color:rgb(73,73,73)">mysql&gt; CREATE TABLE IF NOT EXISTS `user2` (   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">10. </span><span style="color:rgb(73,73,73)"> -&gt;   `id` int(11) NOT NULL AUTO_INCREMENT,   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">11. </span><span style="color:rgb(73,73,73)"> -&gt;   `name` varchar(50) DEFAULT NULL,   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">12. </span><span style="color:rgb(73,73,73)"> -&gt;   `sex` int(1) NOT NULL DEFAULT '0',   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">13. </span><span style="color:rgb(73,73,73)"> -&gt;   PRIMARY KEY (`id`)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">14. </span><span style="color:rgb(73,73,73)"> -&gt; ) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">15. </span><span style="color:rgb(73,73,73)">Query OK, 0 rows affected (0.01 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">16. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">17. </span><span style="color:rgb(73,73,73)">mysql&gt; INSERT INTO `user1` (`name`, `sex`) VALUES('张映', 0);   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">18. </span><span style="color:rgb(73,73,73)">Query OK, 1 row affected (0.00 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">19. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">20. </span><span style="color:rgb(73,73,73)">mysql&gt; INSERT INTO `user2` (`name`, `sex`) VALUES('tank', 1);   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">21. </span><span style="color:rgb(73,73,73)">Query OK, 1 row affected (0.00 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">22. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">23. </span><span style="color:rgb(73,73,73)">mysql&gt; CREATE TABLE IF NOT EXISTS `alluser` (   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">24. </span><span style="color:rgb(73,73,73)"> -&gt;   `id` int(11) NOT NULL AUTO_INCREMENT,   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">25. </span><span style="color:rgb(73,73,73)"> -&gt;   `name` varchar(50) DEFAULT NULL,   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">26. </span><span style="color:rgb(73,73,73)"> -&gt;   `sex` int(1) NOT NULL DEFAULT '0',   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">27. </span><span style="color:rgb(73,73,73)"> -&gt;   INDEX(id)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">28. </span><span style="color:rgb(73,73,73)"> -&gt; ) TYPE=MERGE UNION=(user1,user2) INSERT_METHOD=LAST AUTO_INCREMENT=1 ;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">29. </span><span style="color:rgb(73,73,73)">Query OK, 0 rows affected, 1 warning (0.00 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">30. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">31. </span><span style="color:rgb(73,73,73)">mysql&gt; select id,name,sex from alluser;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">32. </span><span style="color:rgb(73,73,73)">+----+--------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">33. </span><span style="color:rgb(73,73,73)">| id | name   | sex |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">34. </span><span style="color:rgb(73,73,73)">+----+--------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">35. </span><span style="color:rgb(73,73,73)">|  1 | 张映 |   0 |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">36. </span><span style="color:rgb(73,73,73)">|  1 | tank   |   1 |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">37. </span><span style="color:rgb(73,73,73)">+----+--------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">38. </span><span style="color:rgb(73,73,73)">2 rows in set (0.00 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">39. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">40. </span><span style="color:rgb(73,73,73)">mysql&gt; INSERT INTO `alluser` (`name`, `sex`) VALUES('tank2', 0);   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">41. </span><span style="color:rgb(73,73,73)">Query OK, 1 row affected (0.00 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">42. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">43. </span><span style="color:rgb(73,73,73)">mysql&gt; select id,name,sex from user2   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">44. </span><span style="color:rgb(73,73,73)"> -&gt; ;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">45. </span><span style="color:rgb(73,73,73)">+----+-------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">46. </span><span style="color:rgb(73,73,73)">| id | name  | sex |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">47. </span><span style="color:rgb(73,73,73)">+----+-------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">48. </span><span style="color:rgb(73,73,73)">|  1 | tank  |   1 |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">49. </span><span style="color:rgb(73,73,73)">|  2 | tank2 |   0 |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">50. </span><span style="color:rgb(73,73,73)">+----+-------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">51. </span><span style="color:rgb(73,73,73)">2 rows in set (0.00 sec)  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)"><br> </span><span style="color:rgb(73,73,73)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">从上面的操作中，我不知道你有没有发现点什么？假如我有一张用户表user，有50W条数据，现在要拆成二张表user1和user2，每张表25W条数据，</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">INSERT INTO user1(user1.id,user1.name,user1.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id &lt;= 250000</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">INSERT INTO user2(user2.id,user2.name,user2.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id &gt; 250000</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">这样我就成功的将一张user表，分成了二个表，这个时候有一个问题，代码中的sql语句怎么办，以前是一张表，现在变成二张表了，代码改动很大，这样给 程序员带来了很大的工作量，有没有好的办法解决这一点呢？办法是把以前的user表备份一下，然后删除掉，上面的操作中我建立了一个alluser表，只 把这个alluser表的表名改成user就行了。但是，不是所有的mysql操作都能用的</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">a，如果你使用 alter table 来把 merge 表变为其它表类型，到底层表的映射就被丢失了。取而代之的，来自底层 myisam 表的行被复制到已更换的表中，该表随后被指定新类型。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">b，网上看到一些说replace不起作用，我试了一下可以起作用的。晕一个先</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)"><br> </span><span style="color:rgb(73,73,73)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">1. </span><span style="color:rgb(73,73,73)">mysql&gt; UPDATE alluser SET sex=REPLACE(sex, 0, 1) where id=2;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">2. </span><span style="color:rgb(73,73,73)">Query OK, 1 row affected (0.00 sec)   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">3. </span><span style="color:rgb(73,73,73)">Rows matched: 1  Changed: 1  Warnings: 0   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">4. </span><span style="color:rgb(73,73,73)">  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">5. </span><span style="color:rgb(73,73,73)">mysql&gt; select * from alluser;   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">6. </span><span style="color:rgb(73,73,73)">+----+--------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">7. </span><span style="color:rgb(73,73,73)">| id | name   | sex |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">8. </span><span style="color:rgb(73,73,73)">+----+--------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">9. </span><span style="color:rgb(73,73,73)">|  1 | 张映 |   0 |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">10. </span><span style="color:rgb(73,73,73)">|  1 | tank   |   1 |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">11. </span><span style="color:rgb(73,73,73)">|  2 | tank2  |   1 |   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">12. </span><span style="color:rgb(73,73,73)">+----+--------+-----+   </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">13. </span><span style="color:rgb(73,73,73)">3 rows in set (0.00 sec)  </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)"><br> </span><span style="color:rgb(73,73,73)"> </span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">c，一个 merge 表不能在整个表上维持 unique 约束。当你执行一个 insert，数据进入第一个或者最后一个 myisam 表（取决于 insert_method 选项的值）。mysql 确保唯一键值在那个 myisam 表里保持唯一，但不是跨集合里所有的表。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">d,当你创建一个 merge 表之时，没有检查去确保底层表的存在以及有相同的机构。当 merge 表被使用之时，mysql 检查每个被映射的表的记录长度是否相等，但这并不十分可靠。如果你从不相似的 myisam 表创建一个 merge 表，你非常有可能撞见奇怪的问题。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <span style="color:rgb(73,73,73)">好困睡觉了，c和d在网上看到的，没有测试，大家试一下吧。</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong><span style="color:rgb(0,51,0)">优点：扩展性好，并且程序代码改动的不是很大</span></strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 96. 分表之后想让一个id多个表是自增的，效率实现</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 答：<span style="font-family:Calibri">auto_increment</span></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 97. MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 98. 写SQL语句。。。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 99. 索引的数据结构，B+树</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 100. 事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 101. 数据库的锁：行锁，表锁；乐观锁，悲观锁</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 102. 数据库事务的几种粒度；</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 103. 关系型和非关系型数据库区别</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 104. 单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 105. 工厂模式、装饰者模式、观察者模式。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 106. 工厂方法模式的优点（低耦合、高内聚，开放封闭原则）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 107. 使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 108. 两个有序数组的合并排序</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 109. 一个数组的倒序</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 110. 计算一个正整数的正平方根</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 111. 说白了就是常见的那些查找、排序算法以及各自的时间复杂度</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 112. 二叉树的遍历算法</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 113. DFS,BFS算法</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 114. 比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 115. 排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 116. 逆波兰计算器</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 117. Hoffman 编码</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 118. 查找树与红黑树</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 119. 有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 120. 高并发情况下，我们系统是如何支撑大量的请求的</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 121. 集群如何同步会话状态</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 122. <a target="_blank" href="http://www.codeceo.com/article/balanced-algorithm.html" rel="nofollow noopener noreferrer" title="负载均衡" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(0,0,0)">负载均衡</span></a>的原理</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 123 .如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 124. 如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 125. 假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 126. 如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 127. 你的项目中使用过缓存机制吗？有没用用户非本地缓存</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 128.常用的<a target="_blank" href="http://lib.csdn.net/base/linux" rel="nofollow noopener noreferrer" class="replace_word" title="Linux知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">Linux</a>下的命令</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t0" style="color:rgb(255,153,0)"></a>129. 什么是spring?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t1" style="color:rgb(255,153,0)"></a>130. 使用Spring框架的好处是什么？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t2" style="color:rgb(255,153,0)"></a>131.  Spring由哪些模块组成?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 以下是Spring 框架的基本模块：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Core module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Bean module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Context module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Expression Language module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § JDBC module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § ORM module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § OXM module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Java Messaging Service(JMS) module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Transaction module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Web module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Web-Servlet module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Web-Struts module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Web-Portlet module</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t3" style="color:rgb(255,153,0)"></a>132. 核心容器（应用上下文) 模块。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t4" style="color:rgb(255,153,0)"></a>133.  BeanFactory – BeanFactory 实现举例。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 最常用的BeanFactory 实现是XmlBeanFactory 类。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t5" style="color:rgb(255,153,0)"></a>134.  XMLBeanFactory </h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t6" style="color:rgb(255,153,0)"></a>135.  解释AOP模块</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> AOP模块用于发给我们的Spring应用做面向切面的开发， 很多支持由AOP联盟提供，这样就确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t7" style="color:rgb(255,153,0)"></a>136.  解释JDBC抽象和DAO模块。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t8" style="color:rgb(255,153,0)"></a>137.  解释对象/关系映射集成模块。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate,JDO和 iBATIS SQL Maps。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t9" style="color:rgb(255,153,0)"></a>138.   解释WEB 模块。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring的WEB模块是构建在application context 模块基础之上，提供一个适合web应用的上下文。这个模块也包括支持多种面向web的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对Jakarta Struts的支持。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t10" style="color:rgb(255,153,0)"></a>139.   Spring配置文件</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t11" style="color:rgb(255,153,0)"></a>140.   什么是Spring IOC 容器？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t12" style="color:rgb(255,153,0)"></a>141.   IOC的优点是什么？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t13" style="color:rgb(255,153,0)"></a>142.  ApplicationContext通常的实现是什么?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>FileSystemXmlApplicationContext ：</strong>此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>ClassPathXmlApplicationContext：</strong>此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>WebXmlApplicationContext：</strong>此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t14" style="color:rgb(255,153,0)"></a>143. Bean 工厂和 Application contexts  有什么区别？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t15" style="color:rgb(255,153,0)"></a>144. 一个Spring的应用看起来象什么？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 一个定义了一些功能的接口。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 这实现包括属性，它的Setter ， getter 方法和函数等。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Spring AOP。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Spring 的XML 配置文件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 使用以上功能的客户端程序。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t16" style="color:rgb(255,153,0)"></a>145. 什么是Spring的依赖注入？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t17" style="color:rgb(255,153,0)"></a>146.  有哪些不同类型的IOC（依赖注入）方式？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>构造器依赖注入：</strong>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>Setter方法注入：</strong>Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t18" style="color:rgb(255,153,0)"></a>147. 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t19" style="color:rgb(255,153,0)"></a>148.什么是Spring beans?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中&lt;bean/&gt; 的形式定义。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t20" style="color:rgb(255,153,0)"></a>149. 一个 Spring Bean 定义 包含什么？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t21" style="color:rgb(255,153,0)"></a>150. 如何给Spring 容器提供配置元数据?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这里有三种重要的方法给Spring 容器提供配置元数据。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> XML配置文件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 基于注解的配置。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 基于java的配置。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t22" style="color:rgb(255,153,0)"></a>151. 你怎样定义类的作用域? </h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 当定义一个&lt;bean&gt; 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t23" style="color:rgb(255,153,0)"></a>152. 解释Spring支持的几种bean的作用域。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring框架支持以下五种bean的作用域：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>singleton : </strong>bean在每个Spring ioc 容器中只有一个实例。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>prototype</strong>：一个bean的定义可以有多个实例。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 缺省的Spring bean 的作用域是Singleton.</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t24" style="color:rgb(255,153,0)"></a>153. Spring框架中的单例bean是线程安全的吗?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 不，Spring框架中的单例bean不是线程安全的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t25" style="color:rgb(255,153,0)"></a>154. 解释Spring框架中bean的生命周期。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Spring容器 从XML 文件中读取bean的定义，并实例化bean。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Spring根据bean的定义填充所有的属性。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 如果bean实现了 DisposableBean，它将调用destroy()方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t26" style="color:rgb(255,153,0)"></a>155.  哪些是重要的bean生命周期方法？ 你能重载它们吗？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown  它是在容器卸载类的时候被调用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> The bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t27" style="color:rgb(255,153,0)"></a>156. 什么是Spring的内部bean？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义inner bean，在Spring 的 基于XML的 配置元数据中，可以在 &lt;property/&gt;或 &lt;constructor-arg/&gt; 元素内使用&lt;bean/&gt; 元素，内部bean通常是匿名的，它们的Scope一般是prototype。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t28" style="color:rgb(255,153,0)"></a>157. 在 Spring中如何注入一个java集合？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring提供以下几种集合的配置元素：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § &lt;list&gt;类型用于注入一列值，允许有相同的值。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § &lt;set&gt; 类型用于注入一组值，不允许有相同的值。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § &lt;map&gt; 类型用于注入一组键值对，键和值都可以为任意类型。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § &lt;props&gt;类型用于注入一组键值对，键和值都只能为String类型。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t29" style="color:rgb(255,153,0)"></a>158. 什么是bean装配? </h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t30" style="color:rgb(255,153,0)"></a>159. 什么是bean的自动装配？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring 容器能够自动装配相互合作的bean，这意味着容器不需要&lt;constructor-arg&gt;和&lt;property&gt;配置，能通过Bean工厂自动处理bean之间的协作。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t31" style="color:rgb(255,153,0)"></a>160. 解释不同方式的自动装配 。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>no</strong>：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>byName：</strong>通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>byType:：</strong>通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>constructor：这个方式类似于</strong>byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong>autodetect：</strong>首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t32" style="color:rgb(255,153,0)"></a>161.自动装配有哪些局限性 ?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 自动装配的局限性是：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>重写</strong>： 你仍需用 &lt;constructor-arg&gt;和 &lt;property&gt; 配置来定义依赖，意味着总要重写自动装配。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>模糊特性：</strong>自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t33" style="color:rgb(255,153,0)"></a>162. 你可以在Spring中注入一个null 和一个空字符串吗？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <strong>可以。</strong></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t34" style="color:rgb(255,153,0)"></a>163. 什么是基于Java的Spring注解配置? 给一些注解的例子.</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t35" style="color:rgb(255,153,0)"></a>164. 什么是基于注解的容器配置?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t36" style="color:rgb(255,153,0)"></a>165. 怎样开启注解装配？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 &lt;context:annotation-config/&gt;元素。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t37" style="color:rgb(255,153,0)"></a>166. @Required  注解</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t38" style="color:rgb(255,153,0)"></a>167. @Autowired 注解</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> @Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t39" style="color:rgb(255,153,0)"></a>168. @Qualifier 注解</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t40" style="color:rgb(255,153,0)"></a>169.在Spring框架中如何更有效地使用JDBC? </h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 使用SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate （例子见这里<a target="_blank" href="http://www.jfox.info/url.php?_src=http://www.jfox.info/69-dao-java-spring-mian-shi-ti-he-da-an&amp;isencode=1&amp;content=dGltZT0xNDMzNzI5MDY2MTgxJnVybD1odHRwJTNBJTJGJTJGZXhhbXBsZXMuamF2YWNvZGVnZWVrcy5jb20lMkZlbnRlcnByaXNlLWphdmElMkZzcHJpbmclMkZqZGJjJTJGc3ByaW5nLWpkYmN0ZW1wbGF0ZS1leGFtcGxlJTJG" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(0,102,204)">here</span></a>）</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t41" style="color:rgb(255,153,0)"></a>170. JdbcTemplate</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t42" style="color:rgb(255,153,0)"></a>171. Spring对DAO的支持</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t43" style="color:rgb(255,153,0)"></a>172.使用Spring通过什么方式访问Hibernate? </h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在Spring中有两种方式访问Hibernate：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 控制反转  Hibernate Template和 Callback。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 继承 HibernateDAOSupport提供一个AOP 拦截器。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t44" style="color:rgb(255,153,0)"></a>173. Spring支持的ORM</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring支持以下ORM：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Hibernate</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § iBatis</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § JPA (Java Persistence API)</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § TopLink</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § JDO (Java Data Objects)</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § OJB</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t45" style="color:rgb(255,153,0)"></a>174.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 配置the Hibernate SessionFactory。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 继承HibernateDaoSupport实现一个DAO。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 在AOP支持的事务中装配。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t46" style="color:rgb(255,153,0)"></a>175. Spring支持的事务管理类型</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring支持两种类型的事务管理：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>声明式事务管理：</strong>这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t47" style="color:rgb(255,153,0)"></a>176. Spring框架的事务管理有哪些优点？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 它为不同的事务API  如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 它支持声明式事务管理。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 它和Spring各种数据访问抽象层很好得集成。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t48" style="color:rgb(255,153,0)"></a>177. 你更倾向用那种事务管理类型？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t49" style="color:rgb(255,153,0)"></a>178.  解释AOP</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t50" style="color:rgb(255,153,0)"></a>179. Aspect 切面</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t51" style="color:rgb(255,153,0)"></a>180. 在Spring AOP 中，关注点和横切关注的区别是什么？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br> 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t52" style="color:rgb(255,153,0)"></a>181. 连接点</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t53" style="color:rgb(255,153,0)"></a>182. 通知</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring切面可以应用五种类型的通知：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>before</strong>：前置通知，在一个方法执行前被调用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>after: </strong>在方法执行之后调用的通知，无论方法执行是否成功。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>after-returning: </strong>仅当方法成功完成后执行的通知。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>after-throwing: </strong>在方法抛出异常退出时执行的通知。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § <strong>around: </strong>在方法执行之前和之后调用的通知。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t54" style="color:rgb(255,153,0)"></a>183. 切点</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t55" style="color:rgb(255,153,0)"></a>184. 什么是引入? </h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 引入允许我们在已存在的类中增加新的方法和属性。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t56" style="color:rgb(255,153,0)"></a>185. 什么是目标对象? </h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t57" style="color:rgb(255,153,0)"></a>186. 什么是代理?</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t58" style="color:rgb(255,153,0)"></a>187. 有几种不同类型的自动代理？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> BeanNameAutoProxyCreator</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> DefaultAdvisorAutoProxyCreator</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Metadata autoproxying</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t59" style="color:rgb(255,153,0)"></a>188. 什么是织入。什么是织入应用的不同点？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 织入可以在编译时，加载时，或运行时完成。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t60" style="color:rgb(255,153,0)"></a>189. 解释基于XML Schema方式的切面实现。</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在这种情况下，切面由常规类以及基于XML的配置实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t61" style="color:rgb(255,153,0)"></a>190. 解释基于注解的切面实现</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t62" style="color:rgb(255,153,0)"></a>191. 什么是Spring的MVC框架？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t63" style="color:rgb(255,153,0)"></a>192. DispatcherServlet</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t64" style="color:rgb(255,153,0)"></a>193. WebApplicationContext</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> WebApplicationContext 继承了ApplicationContext  并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t65" style="color:rgb(255,153,0)"></a>194. 什么是Spring MVC框架的控制器？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t66" style="color:rgb(255,153,0)"></a>195. @Controller 注解</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用Servlet API。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t67" style="color:rgb(255,153,0)"></a>196. @RequestMapping 注解</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 该注解是用来映射一个URL到一个类或一个特定的方处理法上。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 197.求从10到100中能被3或5整除的数的和</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> int sum = 0; for(int i = 10; i &lt;= 100; i++) if( i % 3 == 0 || i % 5 == 0) sum += i; System.out.println(sum);</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 198.将一个字符串逆序，不要使用反转函数</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> String message = \"he saw a racecar\"; StringBuilder rev = new StringBuilder(); for(int i = message.length()-1; i &gt;= 0; i--) rev.append(message.charAt(i)); System.out.println(rev.toString());</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 199.反转一个栈</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> import java.util.*;</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> public class MyProgram extends com.ktbyte.submit.Coder {<!-- --></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     public static void main(String[] args) {<!-- --></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         Stack items = new Stack();</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         items.push(\"he\");      //he is at the bottom of the stack</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         items.push(\"saw\");</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         items.push(\"a\");</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         items.push(\"racecar\");</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         reverseStack(items);   //now he is at the top</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         //print in order pushed:</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         while(items.size()&gt;0) System.out.println(items.pop());</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     }</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     public static  void reverseStack(Stack stack) {<!-- --></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         Queue rev = new LinkedList();</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         while(stack.size()&gt;0) rev.offer(stack.pop());</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">         while(rev.size()&gt;0)   stack.push(rev.poll());</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     }</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> }</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 200.Java集合框架是什么？说出一些集合框架的优点？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）使用核心集合类降低开发成本，而非实现我们自己的集合类。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）随着使用经过严格测试的集合框架类，代码质量会得到提高。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）通过使用JDK附带的集合类，可以降低代码维护成本。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （4）复用性和可操作性。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 201.集合框架中的泛型有什么优点？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 202.Java集合框架的基础接口有哪些？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 203.为何Collection不从Cloneable和Serializable接口继承？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  204.为何Map接口不继承Collection接口？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">   205.Iterator是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">   206.Enumeration和Iterator接口的区别？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 207.为何没有像Iterator.add()这样的方法，向集合中添加元素？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">    语义不明，已知的是，Iterator的协议不能确保迭代的次序。然而要注意，ListIterator没有提供一个add操作，它要确保迭代的顺序。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  208.为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">    它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">   209.Iterater和ListIterator之间有什么区别？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）Iterator只可以向前遍历，而LIstIterator可以双向遍历。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 210.遍历一个List有哪些不同的方式？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;String&gt; strList = new ArrayList&lt;&gt;(); //使用for-each循环 for(String obj : strList){   System.out.println(obj); } //using iterator Iterator&lt;String&gt; it = strList.iterator(); while(it.hasNext()){   String obj = it.next();   System.out.println(obj); }</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 212.通过迭代器fail-fast属性，你明白了什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 213.fail-fast与fail-safe有什么区别？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">    Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  214.在迭代一个集合的时候，如何避免</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">    在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 215.为何Iterator接口没有具体的实现？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">   Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">    216.UnsupportedOperationException是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 217.在Java中，HashMap是如何工作的？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。下面的图片解释了详细内容。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  218.hashCode()和equals()方法有何重要性？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  219.我们能否使用任何类作为Map的key？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）如果类重写了equals()方法，它也应该重写hashCode()方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）如果一个类没有使用equals()，你不应该在hashCode()中使用它。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （4）用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     比如，我有一个类MyKey，在HashMap中使用它。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> //传递给MyKey的name参数被用于equals()和hashCode()中 MyKey key = new MyKey('Pankaj'); //assume hashCode=1234 myHashMap.put(key, 'Value'); // 以下的代码会改变key的hashCode()和equals()值 key.setName('Amit'); //assume new hashCode=7890 //下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null myHashMap.get(new MyKey('Pankaj'));</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     那就是为何String和Integer被作为HashMap的key大量使用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  220.Map接口提供了哪些不同的集合视图？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Map接口提供三个集合视图：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）Set keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 221.HashMap和HashTable有何不同？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）HashMap允许key和value为null，而HashTable不允许。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （4）HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （5）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 222.如何决定选用HashMap还是TreeMap？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  223.ArrayList和Vector有何异同点？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">    ArrayList和Vector在很多时候都很类似。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）两者都是基于索引的，内部由一个数组支持。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）ArrayList和Vector的迭代器实现都是fail-fast的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     以下是ArrayList和Vector的不同点。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）ArrayList比Vector快，它因为有同步，不会过载。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  224.Array和ArrayList有何区别？什么时候更适合用Array？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Array是指定大小的，而ArrayList大小是固定的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）如果你要使用多维数组，使用[][]比List&lt;List&lt;&gt;&gt;更容易。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  225.ArrayList和LinkedList有何区别？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 226.哪些集合类提供对元素的随机访问？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">   ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 227.EnumSet是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 228.哪些集合类是线程安全的？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 229.并发集合类是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 230.BlockingQueue是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 231.队列和栈是什么，列出它们的区别？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Stack是一个扩展自Vector的类，而Queue是一个接口。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 232.Collections类是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 233.Comparable和Comparator接口是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  234.Comparable和Comparator接口有何区别？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 235.我们如何对一组对象进行排序？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">   如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 236.当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 237.我们如何从给定集合那里创建一个synchronized的集合？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 238.集合框架里实现的通用算法有哪些？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     Java集合框架提供常用的算法实现，比如排序和搜索。Collections类包含这些方法实现。大部分算法是操作List的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 239.大写的O是什么？举几个例子？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">     大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 240.与Java集合框架相关的有哪些最好的实践？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> （6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t68" style="color:rgb(255,153,0)"></a>241.什么是线程？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 线程是<a target="_blank" href="http://lib.csdn.net/base/operatingsystem" rel="nofollow noopener noreferrer" class="replace_word" title="操作系统知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">操作系统</a>能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t69" style="color:rgb(255,153,0)"></a>242.线程和进程有什么区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t70" style="color:rgb(255,153,0)"></a>243.如何在Java中实现线程？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t71" style="color:rgb(255,153,0)"></a>244.用Runnable还是Thread？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t72" style="color:rgb(255,153,0)"></a>245.Thread 类中的start() 和 run() 方法有什么区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t73" style="color:rgb(255,153,0)"></a>246.Java中Runnable和Callable有什么不同？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t74" style="color:rgb(255,153,0)"></a>247.Java中CyclicBarrier 和 CountDownLatch有什么不同？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t75" style="color:rgb(255,153,0)"></a>248.Java内存模型是什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 线程内的代码能够按先后顺序执行，这被称为程序次序规则。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 一个线程的所有操作都会在线程终止之前，线程终止规则。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t76" style="color:rgb(255,153,0)"></a>249.Java中的volatile 变量是什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t77" style="color:rgb(255,153,0)"></a>250.什么是线程安全？Vector是一个线程安全类吗？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t78" style="color:rgb(255,153,0)"></a>251.Java中什么是竞态条件？ 举个例子说明。</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t79" style="color:rgb(255,153,0)"></a>252.Java中如何停止一个线程？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后<a target="_blank" href="http://lib.csdn.net/base/java" rel="nofollow noopener noreferrer" class="replace_word" title="Java 知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">Java </a>API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t80" style="color:rgb(255,153,0)"></a>253.一个线程运行时发生异常会怎样？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  简单的说，如果异常没有被捕获该线程将会停止执行。<a target="_blank" name="OLE_LINK185" style="color:rgb(255,153,0)">Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</a></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t81" style="color:rgb(255,153,0)"></a>254.如何在两个线程间共享数据？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程<a target="_blank" href="http://www.jfox.info/url.php?_src=http://www.jfox.info/re-men-java-mian-shi-duo-xian-cheng-mian-shi-ti-wen-da-top-50&amp;isencode=1&amp;content=dGltZT0xNDMzMTI0NDE0MTgzJnVybD1odHRwJTNBJTJGJTJGamF2YXJldmlzaXRlZC5ibG9nc3BvdC5zZyUyRjIwMTMlMkYxMiUyRmludGVyLXRocmVhZC1jb21tdW5pY2F0aW9uLWluLWphdmEtd2FpdC1ub3RpZnktZXhhbXBsZS5odG1s" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(0,102,204)">《Java线程间通信》</span></a>(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t82" style="color:rgb(255,153,0)"></a>255.Java中notify 和 notifyAll有什么区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t83" style="color:rgb(255,153,0)"></a>256.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t84" style="color:rgb(255,153,0)"></a>257.什么是ThreadLocal变量？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t85" style="color:rgb(255,153,0)"></a>258.什么是FutureTask？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t86" style="color:rgb(255,153,0)"></a>259.Java中interrupted 和 isInterruptedd方法的区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用<a target="_blank" href="http://www.jfox.info/url.php?_src=http://www.jfox.info/re-men-java-mian-shi-duo-xian-cheng-mian-shi-ti-wen-da-top-50&amp;isencode=1&amp;content=dGltZT0xNDMzMTI0NDE0MTg1JnVybD1odHRwJTNBJTJGJTJGamF2YTY3LmJsb2dzcG90LmNvbSUyRjIwMTIlMkYxMSUyRndoYXQtaXMtc3RhdGljLWNsYXNzLXZhcmlhYmxlLW1ldGhvZC5odG1s" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(0,102,204)">静态方法</span></a>Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t87" style="color:rgb(255,153,0)"></a>260.为什么wait和notify方法要在同步块中调用？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t88" style="color:rgb(255,153,0)"></a>261.为什么你应该在循环中检查等待条件?</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在<a target="_blank" href="http://www.jfox.info/url.php?_src=http://www.jfox.info/re-men-java-mian-shi-duo-xian-cheng-mian-shi-ti-wen-da-top-50&amp;isencode=1&amp;content=dGltZT0xNDMzMTI0NDE0MTg1JnVybD1odHRwJTNBJTJGJTJGcmVzLmltcG9ydG5ldy5jb20lMkZlY2xpcHNl" rel="nofollow noopener noreferrer" title="Eclipse ImportNew主页" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(0,102,204)">Eclipse</span></a>中创建模板调用wait和notify试一试。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t89" style="color:rgb(255,153,0)"></a>262.Java中的同步集合与并发集合有什么区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t90" style="color:rgb(255,153,0)"></a>263.Java中堆和栈有什么不同？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t91" style="color:rgb(255,153,0)"></a>264.什么是线程池？ 为什么要使用它？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t92" style="color:rgb(255,153,0)"></a>265.如何写代码来解决生产者消费者问题？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t93" style="color:rgb(255,153,0)"></a>266.如何避免死锁？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java多线程中的死锁<br> 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 互斥条件：一个资源每次只能被一个进程使用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t94" style="color:rgb(255,153,0)"></a>267. Java中活锁和死锁有什么区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t95" style="color:rgb(255,153,0)"></a>268. 怎么检测一个线程是否拥有锁？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t96" style="color:rgb(255,153,0)"></a>269. 你如何在Java中获取线程堆栈？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t97" style="color:rgb(255,153,0)"></a>270. JVM中哪个参数是用来控制线程的栈堆栈小的</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题很简单， -Xss参数用来控制线程的堆栈大小。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t98" style="color:rgb(255,153,0)"></a>271. Java中synchronized 和 ReentrantLock 有什么不同？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t99" style="color:rgb(255,153,0)"></a>272. 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t100" style="color:rgb(255,153,0)"></a>273. Thread类中的yield方法有什么作用？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t101" style="color:rgb(255,153,0)"></a>274. Java中ConcurrentHashMap的并发度是什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t102" style="color:rgb(255,153,0)"></a>275. Java中Semaphore是什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t103" style="color:rgb(255,153,0)"></a>276. 如果你提交任务时，线程池队列已满。会时发会生什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t104" style="color:rgb(255,153,0)"></a>277. Java线程池中submit() 和 execute()方法有什么区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t105" style="color:rgb(255,153,0)"></a>278. 什么是阻塞式方法？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t106" style="color:rgb(255,153,0)"></a>279. Swing是线程安全的吗？ 为什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t107" style="color:rgb(255,153,0)"></a>280. Java中invokeAndWait 和 invokeLater有什么区别？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t108" style="color:rgb(255,153,0)"></a>281. Swing API中那些方法是线程安全的？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t109" style="color:rgb(255,153,0)"></a>282. 如何在Java中创建Immutable对象？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t110" style="color:rgb(255,153,0)"></a>283. Java中的ReadWriteLock是什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t111" style="color:rgb(255,153,0)"></a>284. 多线程中的忙循环是什么?</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t112" style="color:rgb(255,153,0)"></a>285. volatile 变量和 atomic 变量有什么不同？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t113" style="color:rgb(255,153,0)"></a>286. 如果同步块内的线程抛出异常会发生什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在<a target="_blank" href="http://www.jfox.info/url.php?_src=http://www.jfox.info/re-men-java-mian-shi-duo-xian-cheng-mian-shi-ti-wen-da-top-50&amp;isencode=1&amp;content=dGltZT0xNDMzMTI0NDE0MTkwJnVybD1odHRwJTNBJTJGJTJGamF2YXJldmlzaXRlZC5ibG9nc3BvdC5jb20lMkYyMDEyJTJGMTElMkZkaWZmZXJlbmNlLWJldHdlZW4tZmluYWwtZmluYWxseS1hbmQtZmluYWxpemUtamF2YS5odG1s" rel="nofollow noopener noreferrer" style="color:rgb(255,153,0); text-decoration:none"><span style="color:rgb(0,102,204)">finally block</span></a>里释放锁实现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t114" style="color:rgb(255,153,0)"></a>287. 单例模式的双检锁是什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t115" style="color:rgb(255,153,0)"></a>288. 如何在Java中创建线程安全的Singleton？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t116" style="color:rgb(255,153,0)"></a>289. 写出3条你遵循的多线程最佳实践</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 给你的线程起个有意义的名字。<br> 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 避免锁定和缩小同步的范围<br> 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 多用同步类少用wait 和 notify<br> 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 多用并发集合少用同步集合<br> 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t117" style="color:rgb(255,153,0)"></a>290. 如何强制启动一个线程？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t118" style="color:rgb(255,153,0)"></a>291. Java中的fork join框架是什么？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t119" style="color:rgb(255,153,0)"></a>292. Java多线程中调用wait() 和 sleep()方法有什么不同？</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 293. JAVA接口和抽象类的区别是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 类可以实现很多个接口，但是只能继承一个抽象类</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 抽象类可以在不提供接口方法实现的情况下实现接口。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> § 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t120" style="color:rgb(255,153,0)"></a>294.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t121" style="color:rgb(255,153,0)"></a>295.是否可以在static环境中访问非static变量？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h2 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t122" style="color:rgb(255,153,0)"></a><span style="background:rgb(0,255,0)">296.</span><span style="background:rgb(0,255,0)">JDK和JRE的区别是什么？</span></h2> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h2 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t123" style="color:rgb(255,153,0)"></a><span style="background:rgb(0,255,0)">297.</span><span style="background:rgb(0,255,0)">什么是Java虚拟机？</span></h2> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 298.Hibernate工作原理及为什么要用？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 原理： 1.读取并解析配置文件 2.读取并解析映射信息，创建SessionFactory 3.打开Session 4.创建事务Transation 5.持久化操作 6.提交事务 7.关闭Session 8.关闭SesstionFactory </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 为什么要用： 1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  299．Hibernate是如何延迟加载? </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 1. Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 2. Hibernate3 提供了属性的延迟加载功能 当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 300．Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系) </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 301.Struts1流程：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 1、客户端浏览器发出HTTP请求。2、根据web.xml配置，该请求被ActionServlet接收。3、根据struts-config.xml配置， ActionServlet先将请求中的参数填充到ActionForm中，然后ActionServlet再将请求发送到Action 进行处理。4、是否验证，需要验证则调用ActionForm的validate方法，验证失败则跳转到input，成功则继续。5、Action从ActionForm获得数据，调用javabean 中的业务方法处理数据。6、Action返回ActionForward对象，跳转到相应JSP页面或Action。7、返回HTTP响应到客户端浏览器。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> MVC设计模式：modal：“模型” 也称业务逻辑，是正真完成任务的代码,相当与JavaBeanview：视图，其实就是显示界面，相当于JSPcontroller：控制器，他控制模型和视图的交互过程，相当于servletstruts1是基于MVC设计模式hibernate是基于ORM对象关系映射 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 302.struts是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> struts1是基于JSP和servlet的一个开源的Web应用框架，使用的是MVC的设计模式struts2是基于webwork技术的框架，是sun和webwork公司联手开发的一个功能非常齐全的框架，struts2和struts1没有任何关系，是一个全新的框架 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 303.spring是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> spring是一个集成了许多第三方框架的大杂烩，其核心技术是IOC（控制反转，也称依赖注入）和AOP（面向切面编程） </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 304.hibernate是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> hibernate是基于ORM对象关系映射（完成对象数据到关系数据映射的机制）实现的,做数据持久化的工具 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 305.JSF是什么？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> JavaServer Face是基于组件的web开发框架，跟sturts差不多的框架 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 306.数据库里面的索引和约束是什么?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 索引是为了提高数据的检索速度，索引是建立在数据表上，根据一个或多个字段建立的约束是为了保持数据的完整性，约束有非空约束，主键约束，外键约束等等。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 307.spring是什么</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这个问题，往往可以通过我们为什么要使用spring这个问题来切入：AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务 （比 如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。 IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反 过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> construction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象（collaborator）。 Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  308.用自己的话简要阐述struts2的执行流程。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。基本简要流程如下：1、客户端浏览器发出HTTP请求。2、根据web.xml配置，该请求被FilterDispatcher接收。3、根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。4、Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。5、Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。6、返回HTTP响应到客户端浏览器。 </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 309. Java中的泛型是什么 ? 使用泛型的好处是什么?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是在各种Java泛型面试中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 310. Java的泛型是如何工作的 ? 什么是类型擦除 ?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List&lt;String&gt;在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更多信息。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 311. 什么是泛型中的限定通配符和非限定通配符 ?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是&lt;? extends T&gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面&lt;?&gt;表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 312. List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List&lt;Integer&gt;或List&lt;Float&gt;。在本段出现的连接中可以找到更多信息。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 313. 如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样:</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> public V put(K key, V value) {<!-- --></p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> return cache.put(key, value);</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 314. Java中如何使用泛型编写带有参数的类?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 315. 编写一段泛型程序来实现LRU缓存?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 316. 你可以把List&lt;String&gt;传递给一个接受List&lt;Object&gt;参数的方法吗？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以List&lt;String&gt;应当可以用在需要List&lt;Object&gt;的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List&lt;Object&gt;可以存储任何类型的对象包括String, Integer等等，而List&lt;String&gt;却只能用来存储Strings。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;Object&gt; objectList;</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;String&gt; stringList;</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> objectList = stringList; //compilation error incompatible types</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 317. Array中可以用泛型吗?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 318. 如何阻止Java中的类型未检查的警告?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 如果你把泛型和原始类型混合起来使用，例如下列代码，Java 5的javac编译器会产生类型未检查的警告，例如</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;String&gt; rawList = new ArrayList()</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 注意: Hello.java使用了未检查或称为不安全的操作;</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这种警告可以使用@SuppressWarnings(“unchecked”)注解来屏蔽。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 319. Java中List&lt;Object&gt;和原始类型List之间的区别?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 原始类型和带参数类型&lt;Object&gt;之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。这道题的考察点在于对泛型中原始类型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List&lt;String&gt;传递给接受List&lt;Object&gt;的方法，因为会产生编译错误。更多详细信息请参阅Java中的泛型是如何工作的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 320. Java中List&lt;?&gt;和List&lt;Object&gt;之间的区别是什么?</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 这道题跟上一道题看起来很像，实质上却完全不同。List&lt;?&gt; 是一个未知类型的List，而List&lt;Object&gt;其实是任意类型的List。你可以把List&lt;String&gt;, List&lt;Integer&gt;赋值给List&lt;?&gt;，却不能把List&lt;String&gt;赋值给List&lt;Object&gt;。     </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;?&gt; listOfAnyType;</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;Object&gt; listOfObject = new ArrayList&lt;Object&gt;();</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;String&gt; listOfString = new ArrayList&lt;String&gt;();</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;Integer&gt; listOfInteger = new ArrayList&lt;Integer&gt;();</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> listOfAnyType = listOfString; //legal</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> listOfAnyType = listOfInteger; //legal</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> listOfObjectType = (List&lt;Object&gt;) listOfString; //compiler error – in-convertible types</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 321. List&lt;String&gt;和原始类型List之间的区别.</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 该题类似于“原始类型和带参数类型之间有什么区别”。带参数类型是类型安全的，而且其类型安全是由编译器保证的，但原始类型List却不是类型安全的。你不能把String之外的任何其它类型的Object存入String类型的List中，而你可以把任何类型的对象存入原始List中。使用泛型的带参数类型你不需要进行类型转换，但是对于原始类型，你则需要进行显式的类型转换。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List listOfRawTypes = new ArrayList();</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> listOfRawTypes.add(“abc”);</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> listOfRawTypes.add(123); //编译器允许这样 – 运行时却会出现异常</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> String item = (String) listOfRawTypes.get(0); //需要显式的类型转换</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> item = (String) listOfRawTypes.get(1); //抛ClassCastException，因为Integer不能被转换为String</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> List&lt;String&gt; listOfString = new ArrayList();</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> listOfString.add(“abcd”);</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> listOfString.add(1234); //编译错误，比在运行时抛异常要好</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> item = listOfString.get(0); //不需要显式的类型转换 – 编译器自动转换</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t124" style="color:rgb(255,153,0)"></a>322. 什么是JDBC，在什么时候会用到它？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t125" style="color:rgb(255,153,0)"></a>323. 有哪些不同类型的JDBC驱动？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 有四类JDBC驱动。和数据库进行交互的Java程序分成两个部分，一部分是JDBC的API，实际工作的驱动则是另一部分。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> A JDBC-ODBC Bridge plus ODBC Driver（类型1）：它使用ODBC驱动连接数据库。需要安装ODBC以便连接数据库，正因为这样，这种方式现在已经基本淘汰了。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> B Native API partly Java technology-enabled driver（类型2）：这种驱动把JDBC调用适配成数据库的本地接口的调用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> C Pure Java Driver for Database Middleware（类型3）：这个驱动把JDBC调用转发给中间件服务器，由它去和不同的数据库进行连接。用这种类型的驱动需要部署中间件服务器。这种方式增加了额外的网络调用，导致性能变差，因此很少使用。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> D Direct-to-Database Pure Java Driver（类型4）：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。不过使用这种方式的话，需要根据不同数据库选用特定的驱动程序，比如OJDBC是<a target="_blank" href="http://lib.csdn.net/base/oracle" rel="nofollow noopener noreferrer" class="replace_word" title="Oracle知识库" style="color:rgb(223,52,52); text-decoration:none; font-weight:bold">Oracle</a>开发的Oracle数据库的驱动，而MySQL Connector/J是MySQL数据库的驱动。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px">  </p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t126" style="color:rgb(255,153,0)"></a>324. JDBC是如何实现Java程序和JDBC驱动的松耦合的？</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 我觉得这是Java核心库里反射机制的最佳实践之一，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6113ec9c785cdf77ad2be3ba578e0091/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Servlet第三篇【request和response简介、response的常见应用】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/048620d49b90d0d3d08b0bfbbdb355cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从零开始学_JavaScript_系列（33）——dom.append()与$.append()</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>