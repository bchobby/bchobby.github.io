<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Treap图文详解、效率分析与拓展应用——清华大学计算机系 郭家宝 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Treap图文详解、效率分析与拓展应用——清华大学计算机系 郭家宝" />
<meta property="og:description" content="先给出我自己的一份Treap的代码——传送门
一、什么是 Treap T r e a p = T r e e &#43; H e a p Treap=Tree&#43;Heap Treap=Tree&#43;Heap T r e a p Treap Treap是一种平衡树
T r e a p Treap Treap发音为[tri:p]
这个单词的构造选取了 T r e e Tree Tree(树)的前两个字符和 H e a p Heap Heap(堆)的后三个字符， T r e a p = T r e e &#43; H e a p Treap=Tree&#43;Heap Treap=Tree&#43;Heap
顾名思义
T r e a p Treap Treap把 B S T BST BST和 H e a p Heap Heap结合了起来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a09e4e7b63b73c5a7163c972c34e6168/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-05T17:21:21+08:00" />
<meta property="article:modified_time" content="2023-03-05T17:21:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Treap图文详解、效率分析与拓展应用——清华大学计算机系 郭家宝</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>先给出我自己的一份Treap的代码——<a href="https://paste.ubuntu.com/p/SxyVGb7hWm/" rel="nofollow">传送门</a></p> 
<h2><a id="_Treap_2"></a>一、什么是 Treap</h2> 
<h6><a id="TreapTreeHeap_3"></a><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
         = 
        
       
         T 
        
       
         r 
        
       
         e 
        
       
         e 
        
       
         + 
        
       
         H 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap=Tree+Heap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">ree</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">He</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span></h6> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>是一种平衡树<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>发音为[tri:p]<br> 这个单词的构造选取了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         e 
        
       
      
        Tree 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">ree</span></span></span></span></span>(树)的前两个字符和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Heap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">He</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>(堆)的后三个字符，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
         = 
        
       
         T 
        
       
         r 
        
       
         e 
        
       
         e 
        
       
         + 
        
       
         H 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap=Tree+Heap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">ree</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">He</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span><br> 顾名思义<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>把<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Heap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">He</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>结合了起来<br> 它和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>一样满足许多优美的性质<br> 而引入堆目的就是为了维护平衡。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>的基础上添加了一个修正值<br> 在满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>性质的基础上<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>节点的修正值还满足最小堆性质<br> 最小堆性质可以被描述为每个子树根节点都小于等于其子节点<br> 于是，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>可以定义为有以下性质的二叉树：</p> 
<ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值，而且它的根节点的修正值小于等于左子树根节点的修正值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值，而且它的根节点的修正值小于等于右子树根节点的修正值；</li><li>它的左、右子树也分别为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>。</li></ol> 
<p>图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         5 
        
       
      
        5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>为一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span><br> <img src="https://images2.imgbox.com/37/c8/FOlqvRay_o.png" alt="在这里插入图片描述"><br> 修正值是节点在插入到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中时随机生成的一个值<br> 它与节点的值无关<br> 下述代码给出了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的一般定义。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Treap_Node</span> <span class="token punctuation">{<!-- --></span>
    Treap_Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">//节点的左右子树的指针</span>
    <span class="token keyword">int</span> value<span class="token punctuation">,</span> fix<span class="token punctuation">;</span> <span class="token comment">//节点的值和修正值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>修正值全部满足最大堆性质也是可以的，在本文的介绍中，修正值全部是满足最小堆性质的。</p> 
<h6><a id="_32"></a>为什么平衡</h6> 
<p>我们发现，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>会遇到不平衡的原因是因为有序的数据会使查找的路径退化成链<br> 而随机的数据使<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>退化的概率是非常小的<br> 在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中，修正值的引入恰恰是使树的结构不仅仅取决于节点的值，还取决于修正值的值<br> 然而修正值的值是随机生成的<br> 出现有序的随机序列是小概率事件<br> 所以<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的结构是趋向于随机平衡的。</p> 
<h2><a id="_Treap_39"></a>二、如何构建 Treap</h2> 
<h6><a id="_40"></a>旋转</h6> 
<p>为了使<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中的节点同时满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>性质和最小堆性质<br> 不可避免地要对其结构进行调整<br> 调整方式被称为旋转<br> 在维护<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的过程中，只有两种旋转<br> 分别是左旋转（简称左旋）和右旋转（简称右旋）<br> 旋转是相对于子树而言的<br> 左旋和右旋的命名体现了旋转的一条性质：<br> <strong>旋转的性质1</strong><br> 左旋一个子树，会把它的根节点旋转到根的左子树位置，同时根节点的右子节点成为子树的根<br> 右旋一个子树，会把它的根节点旋转到根的右子树位置，同时根节点的左子节点成为子树的根<br> 如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>所示，我们可以从图中清晰地看出左旋后的根节点降到了左子树，右旋后根节点降到了右子树<br> 而且仍然满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>性质，于是有：<br> <strong>旋转的性质2</strong><br> 对子树旋转后，子树仍然满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>性质。<br> <img src="https://images2.imgbox.com/5b/90/dZK84puO_o.png" alt="在这里插入图片描述"><br> 利用旋转的两条重要性质<br> 我们可以来改变树的结构<br> 实际上我们恰恰是通过旋转使<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>节点之间满足堆序。<br> 如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         7 
        
       
      
        7 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>所示的左边的一个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>，它仍然满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>性质，但是由于某些原因，节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>和节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>之间不满足最小堆序，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>作为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>的父节点，它的修正值大于左子节点的修正值<br> 我们只有将<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>变成<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>的父节点，才能维护堆序<br> 根据旋转的性质我们可以知道，由于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>的左子节点，为了使<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>成为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>的父节点，我们需要把以<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>为根的子树右旋<br> 右旋后，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>成为了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>的父节点，满足堆序。<br> <img src="https://images2.imgbox.com/90/a3/Ngee1hBx_o.png" alt="在这里插入图片描述"><br> 由此我们可以总结出，旋转的意义在于：<br> 旋转可以使不满足堆序的两个节点通过调整位置，重新满足堆序，而不改变<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>性质。<br> 下述代码给出了两种旋转的实现。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Treap_Left_Rotate</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//左旋 节点指针一定要传递引用</span>
    Treap_Node <span class="token operator">*</span>b <span class="token operator">=</span> a<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span>right <span class="token operator">=</span> b<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    b<span class="token operator">-&gt;</span>left <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Treap_Right_Rotate</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//右旋 节点指针一定要传递引用</span>
    Treap_Node <span class="token operator">*</span>b <span class="token operator">=</span> a<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span>left <span class="token operator">=</span> b<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    b<span class="token operator">-&gt;</span>right <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="_81"></a>遍历和查找</h6> 
<p>像大多数平衡树一样<br> 在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中查找和遍历不会改变<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的结构<br> 所以在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中查找和遍历的方法与基本的二叉查找树完全相同<br> 具体方法参见<a href="https://blog.csdn.net/yandaoqiusheng/article/details/85012327">二叉查找树</a></p> 
<h6><a id="_86"></a>插入</h6> 
<p>在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中插入元素与在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>中插入方法相似<br> 首先找到合适的插入位置<br> 然后建立新的节点，存储元素<br> 但是要注意建立新的节点的过程中<br> 会随机地生成一个修正值<br> 这个值可能会破坏堆序<br> 因此我们要根据需要进行恰当的旋转<br> 具体方法如下：</p> 
<ol><li>从根节点开始插入；</li><li>如果要插入的值小于等于当前节点的值，在当前节点的左子树中插入，插入后如果左子节点的修正值小于当前节点的修正值，对当前节点进行右旋；</li><li>如果要插入的值大于当前节点的值，在当前节点的右子树中插入，插入后如果右子节点的修正值小于当前节点的修正值，对当前节点进行左旋；</li><li>如果当前节点为空节点，在此建立新的节点，该节点的值为要插入的值，左右子树为空，插入成功。</li></ol> 
<p>举例说明<br> 如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         8 
        
       
      
        8 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">8</span></span></span></span></span>，在已知的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中插入值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>的元素<br> 找到插入的位置后，随机生成的修正值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         15 
        
       
      
        15 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">15</span></span></span></span></span>。<br> <img src="https://images2.imgbox.com/e5/15/HdTLaG75_o.png" alt="在这里插入图片描述"><br> 新建的节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>与他的父节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>之间不满足堆序<br> 对以节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>为根的子树左旋，如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         9 
        
       
      
        9 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">9</span></span></span></span></span>。<br> <img src="https://images2.imgbox.com/e3/06/MlQw7Sqi_o.png" alt="在这里插入图片描述"><br> 节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>与其父节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         5 
        
       
      
        5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>仍不满足最小堆序<br> 对以节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         5 
        
       
      
        5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>为根的子树右旋，如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         10 
        
       
      
        10 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">10</span></span></span></span></span><br> <img src="https://images2.imgbox.com/19/63/2kT0CQ4Z_o.png" alt=""><br> 至此，节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>与其父亲<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>满足堆序，调整结束。<br> 在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中插入元素的期望时间是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span><br> 下述代码为在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中插入一个值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         7 
        
       
      
        7 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>的元素。</p> 
<pre><code class="prism language-cpp">Treap_Node <span class="token operator">*</span>root<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Treap_Insert</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span><span class="token operator">&amp;</span>P<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//节点指针一定要传递引用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>P<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//找到位置，建立节点</span>
        P <span class="token operator">=</span> <span class="token keyword">new</span> Treap_Node<span class="token punctuation">;</span>
        P<span class="token operator">-&gt;</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        P<span class="token operator">-&gt;</span>fix<span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成随机的修正值</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;=</span> P<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">Treap_Insert</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>fix <span class="token operator">&lt;</span> P<span class="token operator">-&gt;</span>fix<span class="token punctuation">)</span>
        <span class="token function">Treap_Right_Rotate</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左子节点修正值小于当前节点修正值，右旋当前节点</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">Treap_Insert</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>fix <span class="token operator">&lt;</span> P<span class="token operator">-&gt;</span>fix<span class="token punctuation">)</span>
        <span class="token function">Treap_Left_Rotate</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右子节点修正值小于当前节点修正值，左旋当前节点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Treap_Insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在 Treap 中插入值为 7 的元素</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="_137"></a>删除</h6> 
<p>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>一样，在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中删除元素要考虑多种情况<br> 我们可以按照在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>中删除元素同样的方法来删除<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中的元素<br> 即用它的后继（或前驱）节点的值代替它，然后删除它的后继（或前驱）节点<br> 为了不使<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>向一边偏沉<br> 我们需要随机地选取是用后继还是前驱代替它<br> 并保证两种选择的概率均等<br> 上述方法期望时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span><br> 但是这种方法并没有充分利用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>已有的随机性质<br> 而是重新得随机选取代替节点<br> 我们给出一种更为通用的删除方法，这种方法是基于旋转调整的<br> 首先要在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>树中找到待删除节点的位置，然后分情况讨论：<br> <strong>情况一，该节点为叶节点或链节点，则该节点是可以直接删除的节点</strong><br> 若该节点有非空子节点，用非空子节点代替该节点的，否则用空节点代替该节点，然后删除该节点。<br> <strong>情况二，该节点有两个非空子节点</strong><br> 我们的策略是通过旋转，使该节点变为可以直接删除的节点。如果该节点的左子节点的修正值小于右子节点的修正值，右旋该节点，使该节点降为右子树的根节点，然后访问右子树的根节点，继续讨论；反之，左旋该节点，使该节点降为左子树根节点，然后访问左子树的根节点，继续讨论，知道变成可以直接删除的节点。<br> 下面给一个删除例子：在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中删除值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>的元素<br> 如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         11 
        
       
      
        11 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">11</span></span></span></span></span>，首先在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中找到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>的位置<br> <img src="https://images2.imgbox.com/a4/b0/cGepMyo8_o.png" alt="在这里插入图片描述"><br> 发现节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>有两个子节点，且左子节点的修正值小于右子节点的修正值，需要右旋节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>，如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         12 
        
       
      
        12 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">12</span></span></span></span></span>。<br> <img src="https://images2.imgbox.com/92/d7/Vr9cCVYG_o.png" alt="在这里插入图片描述"><br> 旋转后，节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>仍有两个节点，右子节点修正值较小，于是左旋节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>，如图 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         13 
        
       
      
        13 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">13</span></span></span></span></span>。<br> <img src="https://images2.imgbox.com/de/e1/4Fk1vKdm_o.png" alt="在这里插入图片描述"><br> 此时，节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>只有一个子节点，可以直接删除，用它的左子节点代替它，删除本身，如图<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         14 
        
       
      
        14 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">14</span></span></span></span></span>。<br> <img src="https://images2.imgbox.com/9c/d6/iDgGQf1p_o.png" alt="在这里插入图片描述"><br> 删除的复杂度稍高，但是期望时间仍为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span><br> 但是在程序中更容易实现<br> 下述代码给出了后一种(即上述图例中)的删除方法<br> 在给定的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中删除值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         6 
        
       
      
        6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">6</span></span></span></span></span>的节点。</p> 
<pre><code class="prism language-cpp">BST_Node <span class="token operator">*</span>root<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Treap_Delete</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span><span class="token operator">&amp;</span>P<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//节点指针要传递引用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> P<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//找到要删除的节点 对其删除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>P<span class="token operator">-&gt;</span>right <span class="token operator">or</span> <span class="token operator">!</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//情况一，该节点可以直接被删除</span>
            Treap_Node <span class="token operator">*</span>t <span class="token operator">=</span> P<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> P <span class="token operator">=</span> P<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span> <span class="token comment">//用左子节点代替它</span>
            <span class="token keyword">else</span> P <span class="token operator">=</span> P<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span> <span class="token comment">//用右子节点代替它</span>
            <span class="token keyword">delete</span> t<span class="token punctuation">;</span> <span class="token comment">//删除该节点</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//情况二</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>fix <span class="token operator">&lt;</span> P<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>fix<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//左子节点修正值较小，右旋</span>
                <span class="token function">Treap_Right_Rotate</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">Treap_Delete</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//左子节点修正值较小，左旋</span>
                <span class="token function">Treap_Left_Rotate</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">Treap_Delete</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> P<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span> <span class="token function">Treap_Delete</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在左子树查找要删除的节点</span>
    <span class="token keyword">else</span> <span class="token function">Treap_Delete</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在右子树查找要删除的节点</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">Treap_Delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在Treap中删除值为6的元素</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_Treap_195"></a>三、为什么要用 Treap</h2> 
<h6><a id="Treap_196"></a><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的特点</h6> 
<ol><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>简明易懂<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>只有两种调整方式，左旋和右旋<br> 而且即使没有严密的数学证明和分析<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的构造方法，平衡原理也是不难理解的<br> 只要能够理解<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          B 
         
        
          S 
         
        
          T 
         
        
       
         BST 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>和堆的思想，理解Treap当然不在话下</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>易于编写<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>只需维护一个满足堆序的修正值，修正值一经生成无需修改<br> 相比较其他各种平衡树，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>拥有最少的调整方式，仅仅两种相互对称的旋转<br> 所以<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>当之无愧是最易于编码调试的一种平衡树</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>稳定性佳<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的平衡性虽不如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          A 
         
        
          V 
         
        
          L 
         
        
       
         AVL 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>、红黑树、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          B 
         
        
          T 
         
        
       
         SBT 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">SBT</span></span></span></span></span>等平衡树<br> 但是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>也不会退化，可以保证期望<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          l 
         
        
          o 
         
        
          g 
         
        
          N 
         
        
          ) 
         
        
       
         O(logN) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>的深度<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的稳定性取决于随机数发生器</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>具有严密的数学证明<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>期望<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          l 
         
        
          o 
         
        
          g 
         
        
          N 
         
        
          ) 
         
        
       
         O(logN) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>的深度，是有严密的数学证明的<br> 但这不是本文介绍的重点，大多略去</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>具有良好的实践效果<br> 各种实际应用中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的稳定性表现得相当出色，没有因为任何的构造出的数据而退化<br> 于是在信息学竞赛中，不少选手习惯于使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          r 
         
        
          e 
         
        
          a 
         
        
          p 
         
        
       
         Treap 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>，均取得了不俗的表现。</li></ol> 
<h6><a id="Treap_216"></a><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>与其他平衡树的比较</h6> 
<p><strong>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          B 
         
        
          S 
         
        
          T 
         
        
       
         BST 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>相比：</strong><br> 显而易见的，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>更加容易编程实现<br> 对于完全随机的数据，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>会比<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>更快，因为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>没有旋转等操作<br> 但是在实际的应用中，往往会存在大量有序的数据，这时<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>会退化，而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>仍旧能够保持随机的平衡。<br> <strong>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          p 
         
        
          l 
         
        
          a 
         
        
          y 
         
        
       
         Splay 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>相比：</strong><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
      
        Splay 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>一样，不需要维护任何附加域，比<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>在空间上有节约<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
      
        Splay 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>伸展操作中要用到的旋转相对于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>要稍复杂，编程实现不如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>容易<br> 而且<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
      
        Splay 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>在查找时也会调整结构，这使得<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
      
        Splay 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>灵活性稍有欠缺<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
      
        Splay 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>的查找插入删除等基本操作的时间复杂度为均摊<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>而非期望<br> 可以故意构造出使<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
      
        Splay 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>变得很慢的数据，这在信息学竞赛中是很不利的<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         p 
        
       
         l 
        
       
         a 
        
       
         y 
        
       
      
        Splay 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">Spl</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span></span></span></span>找到了一个时间、空间和编程效率上的平衡点。<br> <strong>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          A 
         
        
          V 
         
        
          L 
         
        
       
         AVL 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>、红黑树相比：</strong><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         V 
        
       
         L 
        
       
      
        AVL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>、红黑树的平衡性是严格的，稳定性表现得十分出色<br> 与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>一样，它们都要维护附加的域(高度、颜色)来实现平衡<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         V 
        
       
         L 
        
       
      
        AVL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>和红黑树在调整的过程中，旋转都是均摊<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        O(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的，而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>要<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span><br> 与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的随机修正值不同，它们维护的附加域要动态的调整，而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的随机修正值一经生成不再改变，这一点使得灵活性不如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span><br> 最重要的是，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         V 
        
       
         L 
        
       
      
        AVL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>和红黑树都是时间效率很高的经典算法，在许多专业的应用领域(如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         T 
        
       
         L 
        
       
      
        STL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">ST</span><span class="mord mathnormal">L</span></span></span></span></span>)有着十分重要的地位。<br> 然而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         V 
        
       
         L 
        
       
      
        AVL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>和红黑树的编程实现的难度要比<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>大得多，正是由于过于复杂的编程，使得它们在信息学竞赛中备受冷落。<br> <strong>与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          B 
         
        
          T 
         
        
       
         SBT 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">SBT</span></span></span></span></span>相比：</strong><br> 作为平衡树中的新秀，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         B 
        
       
         T 
        
       
      
        SBT 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">SBT</span></span></span></span></span>有着能与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         V 
        
       
         L 
        
       
      
        AVL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>和红黑树相媲美的严格平衡性，而实现的难度却远小于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         V 
        
       
         L 
        
       
      
        AVL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>和红黑树<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         B 
        
       
         T 
        
       
      
        SBT 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">SBT</span></span></span></span></span>的平衡附加域是子树的大小，而非其他的“无用”的值<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         B 
        
       
         T 
        
       
      
        SBT 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">SBT</span></span></span></span></span>十分简洁高效，灵活性也很优秀<br> 编程实现的难度要稍大于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span><br> 然而<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         B 
        
       
         T 
        
       
      
        SBT 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">SBT</span></span></span></span></span>没有受到学术界重视，原因是因为它只是在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         V 
        
       
         L 
        
       
      
        AVL 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord mathnormal">L</span></span></span></span></span>的基础上进行常数级的优化，而并没有突破性的进展。<br> 表格<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>为几种平衡树的各种特性的对比。<br> <img src="https://images2.imgbox.com/fb/3c/p2jm133L_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Treap__243"></a>四、Treap 的更多操作与技巧</h2> 
<p>查找、插入、删除是平衡树最基本的三种操作，但是在实际的应用中许多其他的操作都是必要的，而且<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>这种强大的数据结构的功能远远不止此，下面我们要讨论的是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>更多的操作，以及一些技巧。</p> 
<h6><a id="_245"></a>懒惰删除</h6> 
<p>基本的删除操作，比起插入和查找要稍有复杂<br> 有时候，我们不愿意再写一段删除的程序代码，于是采用了懒惰删除（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
         a 
        
       
         z 
        
       
         y 
        
       
      
        lazy 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">zy</span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         e 
        
       
         l 
        
       
         e 
        
       
         t 
        
       
         i 
        
       
         o 
        
       
         n 
        
       
      
        deletion 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></span>）的方法<br> 懒惰删除就是在删除时，仅仅将元素找到后给元素打上“已被删除”的标记，而实际上不把它从平衡树中删除。<br> 这种做法的优点是节约代码量，减少编程时间<br> 但它的缺点也是很严重的：如果插入量和删除量都很大，这种删除方式会在平衡树中留下大量的“废节点”，浪费空间，还影响效率。<br> 而且为了标记节点删除，我们还需要在节点定义中添加一个记录节点是否被删除的域<br> 所以，只有在能够确定平衡树的吞吐量不是很大，或者不同数据的个数有限时，可以使用懒惰删除。</p> 
<h6><a id="_253"></a>查找最值</h6> 
<p>在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         B 
        
       
         S 
        
       
         T 
        
       
      
        BST 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BST</span></span></span></span></span>的删除中，我们需要通过找待删除节点的后继(或前驱)，也就是其右子树的最大值（左子树的最小值）<br> 在平衡树中查找最值也是经常会用到的一种操作，方法很简单。<br> <strong>查找一个子树的最小值</strong>，从子树的根开始访问，如果当前节点左子节点非空，访问当前节点的左子节点<br> 如果当前节点左子节点已经为空，那么当前节点的值就是这个子树的最小值。<br> 同理，<strong>查找一个子树的最大值</strong>，从子树的根开始访问，如果当前节点右子节点非空，访问当前节点的右子节点<br> 如果当前节点右子节点已经为空，那么当前节点的值就是这个子树的最大值。<br> 下述代码为在一个给定的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中查找最大值和最小值的非递归实现</p> 
<pre><code class="prism language-cpp">Treap_Node <span class="token operator">*</span>root<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">Treap_FindMin</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span>P<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> P <span class="token operator">=</span> P<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span><span class="token comment">//如果有左子节点，访问左子节点</span>
    <span class="token keyword">return</span> P<span class="token operator">-&gt;</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">Treap_FindMax</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span>P<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> P <span class="token operator">=</span> P<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span><span class="token comment">//如果有右子节点，访问右子节点</span>
    <span class="token keyword">return</span> P<span class="token operator">-&gt;</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> Min<span class="token punctuation">,</span> Max<span class="token punctuation">;</span>
    Min <span class="token operator">=</span> <span class="token function">Treap_FindMin</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在 Treap 中查找最小值</span>
    Max <span class="token operator">=</span> <span class="token function">Treap_FindMax</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在 Treap 中查找最大值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="_278"></a>前驱与后继</h6> 
<p>求一个元素在平衡树(或子树)中的前驱，定义为查找该元素在平衡树中不大于该元素的最大元素<br> 相似的，求一个元素在平衡树(或子树)中的后继，定义为查找该元素在平衡树中不小于该元素的最小元素。<br> 从定义中看出，求一个元素在平衡树中的前驱和后继，这个元素不一定是平衡树中的值，而且如果这个元素就是平衡树中的值，那么它的前驱与后继一定是它本身<br> 我们给出求前驱的基本思想：<strong>贪心逼近法</strong><br> 在树中查找，一旦遇到一个不大于这个元素的值的节点，更新当前的最优的节点，然后在当前节点的右子树中继续查找，目的是希望能找到一个更接近于这个元素的节点<br> 如果遇到大于这个元素的值的节点，不更新最优值，在当前节点的左子树中继续查找<br> 直到遇到空节点，查找结束，当前最优的节点的值就是要求的前驱<br> 求后继的方法与上述相似，只是要找不小于这个元素的值的节点<br> 下面是具体的算法描述。<br> 求前驱：</p> 
<ol><li>从根节点开始访问，初始化最优节点为空节点；</li><li>如果当前节点的值不大于要求前驱的元素的值，更新最有节点为当前节点，访问当前节点的右子节点；</li><li>如果当前节点的值大于要求前驱的元素的值，访问当前节点的左子节点；</li><li>如果当前节点是空节点，查找结束，最优节点就是要求的前驱。</li></ol> 
<p>求后继：</p> 
<ol><li>从根节点开始访问，初始化最优节点为空节点；</li><li>如果当前节点的值不小于要求前驱的元素的值，更新最有节点为当前节点，访问当前节点的左子节点；</li><li>如果当前节点的值小于要求前驱的元素的值，访问当前节点的右子节点；</li><li>如果当前节点是空节点，查找结束，最优节点就是要求的后继。</li></ol> 
<p>在求前驱和后继的过程中，我们恰恰访问了从根到叶节点的一条完整的路径<br> 由于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的深度是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>的，所以求前驱和后继算法的时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span><br> 下述代码为在一个已知的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中求值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         5 
        
       
      
        5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>的元素前驱和后继</p> 
<pre><code class="prism language-cpp">Treap_Node <span class="token operator">*</span>root<span class="token punctuation">;</span>
<span class="token comment">//访问节点 P，查找 value 的前驱，当前最优节点为 optimal</span>
Treap_Node <span class="token operator">*</span> <span class="token function">Treap_pred</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span>P<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">,</span> Treap_Node <span class="token operator">*</span>optimal<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>P<span class="token punctuation">)</span> <span class="token keyword">return</span> optimal<span class="token punctuation">;</span> <span class="token comment">//访问到空节点，返回最优节点，查找结束</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>value <span class="token operator">&lt;=</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">Treap_pred</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> value<span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//更新最优值，在右子树中继续查找</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">Treap_pred</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> value<span class="token punctuation">,</span> optimal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//左子树中继续查找</span>
<span class="token punctuation">}</span>
<span class="token comment">//访问节点 P，查找 value 的后继，当前最优节点为 optimal</span>
Treap_Node <span class="token operator">*</span> <span class="token function">Treap_succ</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span>P<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">,</span> Treap_Node <span class="token operator">*</span>optimal<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>P<span class="token punctuation">)</span> <span class="token keyword">return</span> optimal<span class="token punctuation">;</span> <span class="token comment">//访问到空节点，返回最优节点，查找结束</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>value <span class="token operator">&gt;=</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">Treap_succ</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> value<span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//更新最优值，在左子树中继续查找</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">Treap_succ</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> value<span class="token punctuation">,</span> optimal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在右子树中继续查找</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Treap_Node <span class="token operator">*</span>pred<span class="token punctuation">,</span> <span class="token operator">*</span>succ<span class="token punctuation">;</span>
    pred <span class="token operator">=</span> <span class="token function">Treap_pred</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//查找 5 在 Treap 中的前驱</span>
    succ <span class="token operator">=</span> <span class="token function">Treap_succ</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//查找 5 在 Treap 中的后继</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>根据前驱和后继的定义，我们还可以以此来查找某个元素与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中所有元素绝对值之差最小元素<br> 如果按照数轴上的点来解释的话，就是求一个点的最近距离点<br> 方法就是分别求出该元素的前驱和后继，比较前驱和后继哪个距离基准点最近。<br> 求前驱、后继和距离最近点是许多算法中经常要用到的操作，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>都能够高效地实现。</p> 
<h6><a id="_328"></a>合并重复节点</h6> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中很可能存在值相同的节点，在某些特殊情况下，重复的节点可能会有很多，但是我们却把它们分别存成一个个节点<br> 我们有一种常数级的优化，把重复的节点合并为一个节点<br> 方法就是在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>节点中增加一个域，记录相同的这个值的个数，称为节点的权值，记为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
         e 
        
       
         i 
        
       
         g 
        
       
         h 
        
       
         t 
        
       
      
        weight 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span><br> 在插入时，如果找到了已存在的相同的值，不必再开辟新的节点，只需把已有的节点的权值增加<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span><br> 删除时，只需把权值减少<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>，如果权值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         0 
        
       
      
        0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>时，才对节点正式删除<br> 这种优化的效果很好，首先是在插入时节省了开辟空间的时间<br> 更好的是在删除时，避免了大量的旋转<br> 当重复的值非常多的时候，这种优化是十分惊人的<br> 下述代码为带重复计数的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>节点的定义</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Treap_Node</span> <span class="token punctuation">{<!-- --></span>
    Treap_Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">//节点的左右子树的指针</span>
    <span class="token keyword">int</span> value<span class="token punctuation">,</span> fix<span class="token punctuation">,</span> weight<span class="token punctuation">;</span> <span class="token comment">//节点的值和修正值，weight 为权值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="Treap_344"></a><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中元素的类型与排序的规则</h6> 
<p>到这里为止，上文中提到的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中元素的类型，我们都默认为了整数型<br> 但实际上类型并没有限制，只要是能够比较大小的类型，例如浮点数型、字符串型，也可以是复合类型(结构类型、对象类型)<br> 假若我们要实现一种多关键字类型排序的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>，我们只需自定义大于、小于、等于运算符的意义(运算符重载)，使它们有确定的大小关系，这样就可以在不修改 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>各种操作代码的基础上实现多关键字类型排序的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span><br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>定义中“左小于中小于右”，仅仅是逻辑上的定义，实际上我们可以以任何有序的规则排序，即使是左大于中大于右，只需要在比较元素大小的函数中修改定义即可<br> 在以上时间复杂度的分析中，我们默认两个元素大小比较时间为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        O(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，但实际上某些复杂的类型间比较大小不是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        O(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的，如字符串，是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         L 
        
       
         ) 
        
       
      
        O(L) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
      
        L 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></span>为字符串长度<br> 平衡树并不适合作为所有数据类型的数据的有序存储容器，因为可能有些类型的两个元素直接相互比较大小是十分耗时的，这个常数时间的消耗是无法忍受的<br> 例如字符串，作为检索字符串的容器，我们更推荐<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         i 
        
       
         e 
        
       
      
        Trie 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span></span></span></span></span>，而不是平衡树<br> 平衡树仅适合做元素间相互比较时间很少的类型的有序存储容器。</p> 
<h6><a id="_353"></a>维护子树大小的必要性</h6> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>是一种排序的数据结构，如果我们想查找第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>小的元素或者询问某个元素在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中从小到大的排名时，我们就必须知道每个子树中节点的个数<br> 我们称以一个子树的所有节点的权值之和，为子树的大小<br> 由于插入、删除、旋转等操作，会使每个子树的大小改变，所以我们必须对子树的大小进行动态的维护。</p> 
<p>对于<strong>旋转</strong>，我们要在旋转后对子节点和根节点分别重新计算其子树的大小。<br> 对于<strong>插入</strong>，新建立的节点的子树大小为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>。在寻找插入的位置时，每经过一个节点，都要先使以它为根的子树的大小增加<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>，再递归进入子树查找。<br> 对于<strong>删除</strong>，在寻找待删除节点，递归返回时要把所有的经过的节点的子树的大小减少<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>。要注意的是，删除之前一定要保证待删除节点存在于 Treap 中。</p> 
<p>下述代码为维护子树大小的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>节点的定义，以及旋转</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Treap_Node</span> <span class="token punctuation">{<!-- --></span>
    Treap_Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">//节点的左右子树的指针</span>
    <span class="token keyword">int</span> value<span class="token punctuation">,</span> fix<span class="token punctuation">,</span> weight<span class="token punctuation">,</span> size<span class="token punctuation">;</span> <span class="token comment">//节点的值，修正值，重复计数，子树大小</span>
    <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> left <span class="token operator">?</span> left<span class="token operator">-&gt;</span>size <span class="token operator">?</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//返回左子树的节点个数</span>
    <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">rsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> right <span class="token operator">?</span> right<span class="token operator">-&gt;</span>size <span class="token operator">?</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//返回右子树的节点个数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Treap_Left_Rotate</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//左旋 节点指针一定要传递引用</span>
    Treap_Node <span class="token operator">*</span>b <span class="token operator">=</span> a<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span>right <span class="token operator">=</span> b<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    b<span class="token operator">-&gt;</span>left <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> a<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    b<span class="token operator">-&gt;</span>size <span class="token operator">=</span> b<span class="token operator">-&gt;</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token operator">-&gt;</span><span class="token function">rsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span>size <span class="token operator">=</span> a<span class="token operator">-&gt;</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token operator">-&gt;</span><span class="token function">rsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Treap_Right_Rotate</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//右旋 节点指针一定要传递引用</span>
    Treap_Node <span class="token operator">*</span>b <span class="token operator">=</span> a<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span>size <span class="token operator">=</span> b<span class="token operator">-&gt;</span><span class="token function">rsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token operator">-&gt;</span><span class="token function">rsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
    b<span class="token operator">-&gt;</span>size <span class="token operator">=</span> b<span class="token operator">-&gt;</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token operator">-&gt;</span>size <span class="token operator">+</span> b<span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span>left <span class="token operator">=</span> b<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    b<span class="token operator">-&gt;</span>right <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> a<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    b<span class="token operator">-&gt;</span>size <span class="token operator">=</span> b<span class="token operator">-&gt;</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token operator">-&gt;</span><span class="token function">rsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
    a<span class="token operator">-&gt;</span>size <span class="token operator">=</span> a<span class="token operator">-&gt;</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token operator">-&gt;</span><span class="token function">rsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="k_391"></a>查找排名第k的元素</h6> 
<p>只有当我们维护以每个节点为根的子树的大小，才能查找排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素<br> 根据<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的一个重要性质，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的子树也是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>，我们可以用分而治之的思想来查找排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素<br> 首先，在一个子树中，根节点的排名取决于其左子树的大小，如果根节点有权值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
         e 
        
       
         i 
        
       
         g 
        
       
         h 
        
       
         t 
        
       
      
        weight 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span>，则根节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span>的排名是一个闭区间<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
      
        A 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>，且<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         = 
        
       
         [ 
        
       
         P 
        
       
         . 
        
       
         l 
        
       
         e 
        
       
         f 
        
       
         t 
        
       
         . 
        
       
         s 
        
       
         i 
        
       
         z 
        
       
         e 
        
       
         + 
        
       
         1 
        
       
         , 
        
       
         P 
        
       
         . 
        
       
         l 
        
       
         e 
        
       
         f 
        
       
         t 
        
       
         . 
        
       
         s 
        
       
         i 
        
       
         z 
        
       
         e 
        
       
         + 
        
       
         P 
        
       
         . 
        
       
         w 
        
       
         e 
        
       
         i 
        
       
         g 
        
       
         h 
        
       
         t 
        
       
         ] 
        
       
      
        A=[P.left.size+1,P.left.size+P.weight] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span></span><br> 根据此，我们可以知道，如果查找排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         ∈ 
        
       
         A 
        
       
      
        k∈A 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>，则要查找的元素就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span>所包含元素<br> 如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         &lt; 
        
       
         A 
        
       
      
        k&lt;A 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>，那么排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素一定在左子树中，且它还一定是左子树的排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素<br> 如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         &gt; 
        
       
         A 
        
       
      
        k&gt;A 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></span>，则排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素一定在右子树中，是右子树排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         − 
        
       
         ( 
        
       
         P 
        
       
         . 
        
       
         l 
        
       
         e 
        
       
         f 
        
       
         t 
        
       
         . 
        
       
         s 
        
       
         i 
        
       
         z 
        
       
         e 
        
       
         + 
        
       
         P 
        
       
         . 
        
       
         w 
        
       
         e 
        
       
         i 
        
       
         g 
        
       
         h 
        
       
         t 
        
       
         ) 
        
       
      
        k-(P.left.size+P.weight) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span>的元素<br> 根据这种策略，我们可以总结出算法<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         12 
        
       
      
        12 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">12</span></span></span></span></span>：</p> 
<ol><li>定义<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          P 
         
        
       
         P 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span>为当前访问的节点，从根节点开始访问，查找排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          k 
         
        
       
         k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素；</li><li>若满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          1 
         
        
          &lt; 
         
        
          = 
         
        
          k 
         
        
          &lt; 
         
        
          = 
         
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          P 
         
        
          . 
         
        
          w 
         
        
          e 
         
        
          i 
         
        
          g 
         
        
          h 
         
        
          t 
         
        
       
         P.left.size+1&lt;=k&lt;=P.left.size+P.weight 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6835em; vertical-align: -0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span>，则当前节点包含的元素就是排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          k 
         
        
       
         k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素；</li><li>若满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          k 
         
        
          &lt; 
         
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          1 
         
        
       
         k&lt;P.left.size+1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>，则在左子树中查找排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          k 
         
        
       
         k 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>的元素；</li><li>若满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          k 
         
        
          &gt; 
         
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          P 
         
        
          . 
         
        
          w 
         
        
          e 
         
        
          i 
         
        
          g 
         
        
          h 
         
        
          t 
         
        
       
         k&gt;P.left.size+P.weight 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7335em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span>，则在右子树中查找排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          k 
         
        
          − 
         
        
          ( 
         
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          P 
         
        
          . 
         
        
          w 
         
        
          e 
         
        
          i 
         
        
          g 
         
        
          h 
         
        
          t 
         
        
          ) 
         
        
       
         k-(P.left.size+P.weight) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span>的元素。</li></ol> 
<p>下述代码为在一个给定的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中查找排名第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         8 
        
       
      
        8 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">8</span></span></span></span></span>的元素。</p> 
<pre><code class="prism language-cpp">Treap_Node <span class="token operator">*</span>root<span class="token punctuation">;</span>
Treap_Node <span class="token operator">*</span> <span class="token function">Treap_Findkth</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span>P<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> P<span class="token punctuation">.</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//左子树中查找排名第 k 的元素</span>
    <span class="token keyword">return</span> <span class="token function">Treap_Findkth</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> P<span class="token punctuation">.</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> P<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token comment">//在右子树中查找排名第 k-(P.lsize() + P.weight)的元素</span>
    <span class="token keyword">return</span> <span class="token function">Treap_Findkth</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token punctuation">(</span>P<span class="token punctuation">.</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> P<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> P<span class="token punctuation">;</span> <span class="token comment">//返回当前节点</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Treap_Node <span class="token operator">*</span>result<span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token function">Treap_Findkth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在 Treap 中查找排名第 8 的元素</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>根据上述算法，我们还可以实现查找逻辑第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>大元素，即查找第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         r 
        
       
         o 
        
       
         o 
        
       
         t 
        
       
         . 
        
       
         s 
        
       
         i 
        
       
         z 
        
       
         e 
        
       
         − 
        
       
         k 
        
       
         + 
        
       
         1 
        
       
         ) 
        
       
      
        (root.size-k+1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>小元素，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
         o 
        
       
         o 
        
       
         t 
        
       
         . 
        
       
         s 
        
       
         i 
        
       
         z 
        
       
         e 
        
       
      
        root.size 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></span>为整个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的大小<br> 甚至我们可以取代专门写的查找最值的算法<br> 由于查找路径必定是一条子树上的路径，长度不会超过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>的深度，所以时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>。</p> 
<h6><a id="_423"></a>求元素的排名</h6> 
<p>我们通过排名可以找到对应元素，也希望求出元素在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中排名，或者成为求元素的秩<br> 我们规定，如果在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中有多个重复的元素，则这个元素的排名为最小的排名<br> 例如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
         , 
        
       
         2 
        
       
         , 
        
       
         4 
        
       
         , 
        
       
         4 
        
       
         , 
        
       
         4 
        
       
         , 
        
       
         6 
        
       
      
        1,2,4,4,4,6 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">6</span></span></span></span></span>中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         4 
        
       
      
        4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>的排名为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span><br> 在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中求元素的排名的方法与查找第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>小的数是很相似的，可以近似认为是互为逆运算。<br> 我们的基本思想是查找要求的元素在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中的位置，且在查找路径中统计出小于要求的元素的节点的总个数，要求的元素的排名就是总个数+<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span><br> 算法为：</p> 
<ol><li>定义<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          P 
         
        
       
         P 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span>为当前访问的节点，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          u 
         
        
          r 
         
        
       
         cur 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>为当前已知的比要求的元素小的元素个数。从根节点开始查找要求的元素，初始化<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          u 
         
        
          r 
         
        
       
         cur 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          0 
         
        
       
         0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>；</li><li>若要求的元素等于当前节点元素，要求的元素的排名为区间<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          [ 
         
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          c 
         
        
          u 
         
        
          r 
         
        
          + 
         
        
          1 
         
        
          , 
         
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          c 
         
        
          u 
         
        
          r 
         
        
          + 
         
        
          w 
         
        
          e 
         
        
          i 
         
        
          g 
         
        
          h 
         
        
          t 
         
        
          ] 
         
        
       
         [P.left.size+cur+1, P.left.size+cur+weight] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span></span>内任意整数；</li><li>若要求的元素小于当前节点元素，在左子树中查找要求的元素的排名；</li><li>若要求的元素大于当前节点元素，更新<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          u 
         
        
          r 
         
        
       
         cur 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          u 
         
        
          r 
         
        
          + 
         
        
          P 
         
        
          . 
         
        
          l 
         
        
          e 
         
        
          f 
         
        
          t 
         
        
          . 
         
        
          s 
         
        
          i 
         
        
          z 
         
        
          e 
         
        
          + 
         
        
          w 
         
        
          e 
         
        
          i 
         
        
          g 
         
        
          h 
         
        
          t 
         
        
       
         cur+P.left.size+weight 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span></span>，在右子树中查找要求的元素的排名。</li></ol> 
<p>下述代码为在一个已知的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中求元素<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         8 
        
       
      
        8 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">8</span></span></span></span></span>的排名。</p> 
<pre><code class="prism language-cpp">Treap_Node <span class="token operator">*</span>root<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">Treap_Rank</span><span class="token punctuation">(</span>Treap_Node <span class="token operator">*</span>P<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//求元素 value 的排名</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> P<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span> P<span class="token operator">-&gt;</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> cur <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//返回元素的排名</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> P<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span> <span class="token comment">//在左子树中查找</span>
    <span class="token keyword">return</span> <span class="token function">Treap_Rank</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> value<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token comment">//在右子树中查找</span>
    <span class="token keyword">return</span> <span class="token function">Treap_Rank</span><span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> value<span class="token punctuation">,</span> cur <span class="token operator">+</span> P<span class="token operator">-&gt;</span><span class="token function">lsize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> rank<span class="token punctuation">;</span>
    rank <span class="token operator">=</span> <span class="token function">Treap_Rank</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在 Treap 中求元素 8 的排名</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="_451"></a>维护附加关键字</h6> 
<p>有时候，我们建立<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>维护的顺序关键字并不是我们主要关心的内容，而要关心的是附加关键字。根据不同目的维护的附加关键字的处理方法也不尽相同，下文仅仅以一个例子介绍附加关键字的处理方法。</p> 
<h6><a id="_453"></a>顺序前缀和</h6> 
<h6><a id="_454"></a>[问题描述]</h6> 
<p>要求维护一个由二元组构成的序列，使序列中每个元素按第一关键字升序排列<br> 操作包括：添加一个新元素，删除一个已有元素，查询这个序列的第二关键字最大前缀和<br> 例如已知的序列<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         1 
        
       
         , 
        
       
         0 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         3 
        
       
         , 
        
       
         − 
        
       
         2 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         4 
        
       
         , 
        
       
         − 
        
       
         3 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         6 
        
       
         , 
        
       
         3 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         7 
        
       
         , 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        {(1,0), (3,-2), (4,-3), (6,3), (7,-1)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> 有如下几项操作：<br> 添加<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         3 
        
       
         , 
        
       
         1 
        
       
         ) 
        
       
      
        (3,1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>入序列，添加<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         1 
        
       
         , 
        
       
         1 
        
       
         ) 
        
       
      
        (1,1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>入序列，从序列中删除<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         4 
        
       
         , 
        
       
         − 
        
       
         3 
        
       
         ) 
        
       
      
        (4,-3) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>，查询最大前缀和<br> 第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>次操作后，序列变成了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         1 
        
       
         , 
        
       
         0 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         3 
        
       
         , 
        
       
         1 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         3 
        
       
         , 
        
       
         − 
        
       
         2 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         4 
        
       
         , 
        
       
         − 
        
       
         3 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         6 
        
       
         , 
        
       
         3 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         7 
        
       
         , 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        {(1,0), (3,1), (3,-2),(4,-3), (6,3), (7,-1)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> 第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         2 
        
       
      
        2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>次操作后，序列变成了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         1 
        
       
         , 
        
       
         1 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         1 
        
       
         , 
        
       
         0 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         3 
        
       
         , 
        
       
         1 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         3 
        
       
         , 
        
       
         − 
        
       
         2 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         4 
        
       
         , 
        
       
         − 
        
       
         3 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         6 
        
       
         , 
        
       
         3 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         7 
        
       
         , 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        {(1,1), (1,0), (3,1), (3,-2), (4,-3), (6,3), (7,-1)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> 第<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>次操作后，序列变成了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
       
         1 
        
       
         , 
        
       
         1 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         1 
        
       
         , 
        
       
         0 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         3 
        
       
         , 
        
       
         1 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         3 
        
       
         , 
        
       
         − 
        
       
         2 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         6 
        
       
         , 
        
       
         3 
        
       
         ) 
        
       
         , 
        
       
         ( 
        
       
         7 
        
       
         , 
        
       
         − 
        
       
         1 
        
       
         ) 
        
       
      
        {(1,1), (1,0), (3,1), (3,-2), (6,3), (7,-1)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> 此时序列的 i 项前缀的和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         = 
        
        
        
          1 
         
        
          , 
         
        
          1 
         
        
          , 
         
        
          2 
         
        
          , 
         
        
          0 
         
        
          , 
         
        
          3 
         
        
          , 
         
        
          2 
         
        
       
      
        S[i]={1,1, 2, 0, 3, 2} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span></span></span></span></span></span><br> 所以序列的最大前缀和是前<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         5 
        
       
      
        5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>项和，值为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>。<br> <strong>解析</strong><br> 由于序列总是要求升序排列，我们可以想到以元素第一关键字升序排列，使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>维护。<br> 由于每次要查询的是第二关键字构成的序列的最大前缀和，我们可以容易想到，对于第一关键字相同的元素，第二关键字大的元素应放在前面。<br> 规定排序的顺序之后，我们要考虑如何维护前<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span>项元素的第二关键字的和(以下简称前 i 项的和)。设每个节点的第一关键字为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
      
        a 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span>，第二关键字为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         b 
        
       
      
        b 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span>，我们要在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>中的节点添加附加域<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         u 
        
       
         m 
        
       
      
        sum 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span></span>，表示以该节点为根的子树中所有元素的第二关键字和，以及附加域<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         a 
        
       
         x 
        
       
      
        max 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span>，表示以该节点为根的子树中所有元素构成的顺序序列最大的前缀和。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         u 
        
       
         m 
        
       
      
        sum 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span></span>值可以像维护子树的大小<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         i 
        
       
         z 
        
       
         e 
        
       
      
        size 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></span>值一样的递归地维护，而且旋转时也要重新计算<br> 而对于节点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span>的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         a 
        
       
         x 
        
       
      
        max 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span>值则要分情况讨论：<br> <strong>情况一</strong>，当前子树最大前缀的结尾在该节点的左子树，此时<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
         . 
        
       
         m 
        
       
         a 
        
       
         x 
        
       
         = 
        
       
         p 
        
       
         . 
        
       
         l 
        
       
         e 
        
       
         f 
        
       
         t 
        
       
         . 
        
       
         m 
        
       
         a 
        
       
         x 
        
       
      
        p.max=p.left.max 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span>；<br> <strong>情况二</strong>，当前子树最大前缀的结尾恰好是该节点，此时<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
         . 
        
       
         m 
        
       
         a 
        
       
         x 
        
       
         = 
        
       
         p 
        
       
         . 
        
       
         l 
        
       
         e 
        
       
         f 
        
       
         t 
        
       
         . 
        
       
         s 
        
       
         u 
        
       
         m 
        
       
         + 
        
       
         p 
        
       
         . 
        
       
         b 
        
       
      
        p.max=p.left.sum+p.b 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">b</span></span></span></span></span>；<br> <strong>情况三</strong>，当前子树最大前缀的结尾在该节点的右子树，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
         . 
        
       
         m 
        
       
         a 
        
       
         x 
        
       
         = 
        
       
         p 
        
       
         . 
        
       
         l 
        
       
         e 
        
       
         f 
        
       
         t 
        
       
         . 
        
       
         s 
        
       
         + 
        
       
         p 
        
       
         . 
        
       
         b 
        
       
         + 
        
       
         p 
        
       
         . 
        
       
         r 
        
       
         i 
        
       
         g 
        
       
         h 
        
       
         t 
        
       
         . 
        
       
         m 
        
       
         a 
        
       
         x 
        
       
      
        p.max=p.left.s+p.b+p.right.max 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span>。<br> 在实际的插入和删除过程中，每次旋转后都要重新计算<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         u 
        
       
         m 
        
       
      
        sum 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span></span>值，然后依次计算旋转后的子节点和根节点的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         a 
        
       
         x 
        
       
      
        max 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span>值<br> 维护好后，每次查询最大前缀和，只需要<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        O(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>的时间。<br> 时刻要记住<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         r 
        
       
         e 
        
       
         a 
        
       
         p 
        
       
      
        Treap 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></span>是一种二叉树结构，它具有良好的分治结构，所以在维护各种具体的附加关键字时，二分或三分递推的思想一般都是解决问题的关键。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1646e4bfc2244d8287f0e3b11f9b9eb4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">论文解析[11] CAT: Cross Attention in Vision Transformer</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0935eb107a753c7d13055bfd4a46b6f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue项目各文件说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>