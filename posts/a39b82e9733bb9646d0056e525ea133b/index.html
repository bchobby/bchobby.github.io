<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈夫曼树（结合王卓老师课程内容） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="哈夫曼树（结合王卓老师课程内容）" />
<meta property="og:description" content="目录
1、哈夫曼树的基本概念
2、哈夫曼树的构造方法
3、哈夫曼树的算法实现
先分析：
第一步：
第二步：
再实现：
第一步 ：
第二步：
4、哈夫曼树编码思想
5、哈夫曼编码的算法实现。 6、文件的编码和译码
7、根据哈夫曼树求哈夫曼编码的完整代码：
8、 以26个英文字母的频率为权构造一棵哈夫曼树：
1、哈夫曼树的基本概念 路径从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。路径长度路径上的分支数目称作路径长度。树的路径长度从树根到每一结点的路径长度之和。结点的带权路径长度从该结点到树根之间俺的路径长度与结点上权值的乘积。树的带权路径长度树中所有叶子结点的带权路径长度之和。（WPL） 2、哈夫曼树的构造方法 ██ 哈夫曼算法口诀：1、构造森林全是根；2、选用两小造新树；3、删除两小添新人；4、重复2、3剩单根。
██ 上面的例子，有四个结点，由哈夫曼算法口诀，先找出两个小的结点，即 c 和 d，由 c 和 d结合造一棵新树 ，即图中蓝色区域，然之后在第一个黑框中重复2、3；即在7，5，6这三个结点里选择另个小的结点，组成一棵树即绿框区域。接着再将7,11，这两个结点结合成一棵树。
✔总结哈夫曼树的特点：
1、哈夫曼树的结点的度数为0或者2，没有度为1的结点。
2、在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树。
3、经过n-1次合并产生n-1个新结点，且n-1个新结点都是具有两个孩子的分支结点。
所以哈夫曼树中共有2n-1个结点，且其所有的分支结点的度均不为1.
3、哈夫曼树的算法实现 先分析： 第一步： 采用顺序储存结构——一维结构数组
（哈夫曼树中共有2n-1个结点，我们不适用0下标，所以定义数组大小为2n）
举个栗子：
有n=8,权值为W={7，19，2，6，32，3，21，10} 构造哈夫曼树。
由上面的哈夫曼算法口诀“构造森林全是根”，所以先将结点的父母和左右子树全置为0.然后将结点1-8的权值先附上。
第二步： 然后口诀里的下一步是“选用两小造新树”，那么我们就在1-8里找权值最小的，也就是2和3，然后我们就把它们结成一个新树，如上右图。第三句口诀是“删除两小添新人”。删除也就是把两个权值小的结点的双亲改为非0. 添新人，也就是把合并两个小的权值作为一个新结点的权值依次存放如数组。在这里例子里，也就是2和3的权值和为5，那就将5存放在9的位置。（完成添新人这一操作） 然后将权值为2和3的结点的双亲改为9. （完成删两小这一操作） 那么这一步的操作就完成了。接下来依次循环。那么最后的哈夫曼树如下：
再实现： 第一步 ： 也就是口诀里的第一步“构造森林全是根”。 上面例子的话就是将结点的父母和左右子树全置为0.然后将结点1-8的权值先附上的这一步。
第二步： 也就是口诀里的2、选用两小造新树；3、删除两小添新人； 即上述例子里的第二步。
红色框框里的Select() 是选择两个权值最小的结点的函数 具体如下：
void Select(HuffmanTree HT,int len,int &amp;s1,int &amp;s2) { int i,min1=0x3f3f3f3f,min2=0x3f3f3f3f;//先赋予最大值 for(i=1;i&lt;=len;i&#43;&#43;) { if(HT[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a39b82e9733bb9646d0056e525ea133b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T20:44:16+08:00" />
<meta property="article:modified_time" content="2023-05-16T20:44:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈夫曼树（结合王卓老师课程内容）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1、哈夫曼树的基本概念</a></p> 
<p id="2%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">2、哈夫曼树的构造方法</a></p> 
<p id="3%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" rel="nofollow">3、哈夫曼树的算法实现</a></p> 
<p id="%E5%85%88%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%85%88%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow">先分析：</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A" rel="nofollow">        第一步：</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A" rel="nofollow">        第二步：</a></p> 
<p id="%E5%86%8D%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%86%8D%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">再实现：</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%B8%80%E6%AD%A5%20%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%B8%80%E6%AD%A5%20%EF%BC%9A" rel="nofollow">        第一步 ：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A" rel="nofollow">        第二步：</a></p> 
<p id="4%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%E6%80%9D%E6%83%B3-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%E6%80%9D%E6%83%B3" rel="nofollow">4、哈夫曼树编码思想</a></p> 
<p id="5%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" rel="nofollow">5、哈夫曼编码的算法实现。 </a></p> 
<p id="6%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81-toc" style="margin-left:0px;"><a href="#6%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81" rel="nofollow">6、文件的编码和译码</a></p> 
<p id="%E6%A0%B9%E6%8D%AE%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%B1%82%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%A0%B9%E6%8D%AE%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%B1%82%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">7、根据哈夫曼树求哈夫曼编码的完整代码：</a></p> 
<p id="%C2%A0%E4%BB%A526%E4%B8%AA%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E9%A2%91%E7%8E%87%E4%B8%BA%E6%9D%83%E6%9E%84%E9%80%A0%E4%B8%80%E6%A3%B5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BB%A526%E4%B8%AA%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E9%A2%91%E7%8E%87%E4%B8%BA%E6%9D%83%E6%9E%84%E9%80%A0%E4%B8%80%E6%A3%B5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%9A" rel="nofollow">8、 以26个英文字母的频率为权构造一棵哈夫曼树：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1、哈夫曼树的基本概念</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td>路径</td><td>从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</td></tr><tr><td>路径长度</td><td>路径上的分支数目称作路径长度。</td></tr><tr><td>树的路径长度</td><td>从树根到每一结点的路径长度之和。</td></tr><tr><td>结点的带权路径长度</td><td>从该结点到树根之间俺的路径长度与结点上权值的乘积。</td></tr><tr><td>树的带权路径长度</td><td>树中所有叶子结点的带权路径长度之和。（WPL）</td></tr></tbody></table> 
<p></p> 
<p></p> 
<h2 id="2%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">2、哈夫曼树的构造方法</h2> 
<p><img alt="" height="813" src="https://images2.imgbox.com/27/e8/I5bElAHn_o.png" width="1200"></p> 
<blockquote> 
 <p>██        <strong> 哈夫曼算法口诀：1、构造森林全是根；2、选用两小造新树；3、删除两小添新人；4、重复2、3剩单根。</strong></p> 
</blockquote> 
<p> <img alt="" height="404" src="https://images2.imgbox.com/b0/59/TsINBitS_o.png" width="1118"></p> 
<blockquote> 
 <p> ██        上面的例子，有四个结点，由哈夫曼算法口诀，先找出两个小的结点，即 c 和 d，由 c 和 d结合造一棵新树 ，即图中蓝色区域，然之后在第一个黑框中重复2、3；即在7，5，6这三个结点里选择另个小的结点，组成一棵树即绿框区域。接着再将7,11，这两个结点结合成一棵树。</p> 
</blockquote> 
<p></p> 
<p><strong>✔总结哈夫曼树的特点：</strong></p> 
<p><strong>1、哈夫曼树的结点的度数为0或者2，没有度为1的结点。</strong></p> 
<p><strong>2、在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树。</strong></p> 
<p><strong>3、经过n-1次合并产生n-1个新结点，且n-1个新结点都是具有两个孩子的分支结点。</strong></p> 
<p><strong>      <span style="color:#be191c;">  所以哈夫曼树中共有2n-1个结点，且其所有的分支结点的度均不为1.</span></strong></p> 
<p></p> 
<p></p> 
<h2 id="3%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">3、哈夫曼树的算法实现</h2> 
<p></p> 
<h3 id="%E5%85%88%E5%88%86%E6%9E%90%EF%BC%9A">先分析：</h3> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A">        第一步：</h4> 
<p><strong>采用顺序储存结构——一维结构数组</strong></p> 
<p><strong>（哈夫曼树中共有2n-1个结点，我们不适用0下标，所以定义数组大小为2n）</strong></p> 
<p><img alt="" height="499" src="https://images2.imgbox.com/74/1f/1DIrb1Q3_o.png" width="875"></p> 
<p></p> 
<p></p> 
<blockquote> 
 <p>举个栗子：</p> 
 <p>        有n=8,权值为W={7，19，2，6，32，3，21，10}        构造哈夫曼树。</p> 
</blockquote> 
<p><img alt="" height="600" src="https://images2.imgbox.com/05/c7/IUI52pXk_o.png" width="320">                   <img alt="" height="240" src="https://images2.imgbox.com/77/71/0ezJdYpB_o.jpg" width="240"> </p> 
<p> <strong>由上面的哈夫曼算法口诀“构造森林全是根”，所以先将结点的父母和左右子树全置为0.然后将结点1-8的权值先附上。</strong></p> 
<p></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A">        第二步：</h4> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="577" src="https://images2.imgbox.com/29/e6/7r9uoZHy_o.png" width="324">        <img alt="" height="134" src="https://images2.imgbox.com/e7/89/9bvzYe5g_o.png" width="230"></h2> 
<p><strong> 然后口诀里的下一步是“选用两小造新树”，那么我们就在1-8里找权值最小的，也就是2和3，然后我们就把它们结成一个新树，如上右图。第三句口诀是“删除两小添新人”。删除也就是把两个权值小的结点的双亲改为非0.   添新人，也就是把合并两个小的权值作为一个新结点的权值依次存放如数组。在这里例子里，也就是2和3的权值和为5，那就将5存放在9的位置。（完成添新人这一操作） 然后将权值为2和3的结点的双亲改为9. （完成删两小这一操作） 那么这一步的操作就完成了。接下来依次循环。那么最后的哈夫曼树如下：</strong></p> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="611" src="https://images2.imgbox.com/2d/c8/v0oxDByj_o.png" width="812"></h2> 
<p></p> 
<h3 id="%E5%86%8D%E5%AE%9E%E7%8E%B0%EF%BC%9A">再实现：</h3> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%AC%AC%E4%B8%80%E6%AD%A5%20%EF%BC%9A">        第一步 ：</h4> 
<p><strong>也就是口诀里的第一步“构造森林全是根”。        上面例子的话就是将结点的父母和左右子树全置为0.然后将结点1-8的权值先附上的这一步。</strong></p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/2e/23/smeafzp8_o.png" width="1018"><img alt="" height="507" src="https://images2.imgbox.com/b9/aa/ZJflBYdT_o.png" width="915"></p> 
<p></p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A">        第二步：</h4> 
<p><strong>也就是口诀里的2、选用两小造新树；3、删除两小添新人；            即上述例子里的第二步。</strong></p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/a6/5b/JIdmOrRo_o.png" width="1046"></p> 
<h4><img alt="" height="514" src="https://images2.imgbox.com/6d/5c/n0HjAz9g_o.png" width="1091"></h4> 
<p></p> 
<p id="%E7%BA%A2%E8%89%B2%E6%A1%86%E6%A1%86%E9%87%8C%E7%9A%84Select()%20%E6%98%AF%E9%80%89%E6%8B%A9%E4%B8%A4%E4%B8%AA%E6%9D%83%E5%80%BC%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BB%93%E7%82%B9%E7%9A%84%E5%87%BD%E6%95%B0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%85%B7%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A"><strong>红色框框里的Select() 是选择两个权值最小的结点的函数        具体如下：</strong></p> 
<pre><code class="language-cpp">void Select(HuffmanTree HT,int len,int &amp;s1,int &amp;s2)
{
	int i,min1=0x3f3f3f3f,min2=0x3f3f3f3f;//先赋予最大值
	for(i=1;i&lt;=len;i++)
	{
		if(HT[i].weight&lt;min1&amp;&amp;HT[i].parent==0)
		{
			min1=HT[i].weight;
			s1=i;
		}	
	}
	int temp=HT[s1].weight;//将原值存放起来，然后先赋予最大值，防止s1被重复选择
	HT[s1].weight=0x3f3f3f3f;
	for(i=1;i&lt;=len;i++)
	{
		if(HT[i].weight&lt;min2&amp;&amp;HT[i].parent==0)
		{
			min2=HT[i].weight;
			s2=i;
		}
	}
	HT[s1].weight=temp;//恢复原来的值
}</code></pre> 
<p></p> 
<p> <strong>哈弗曼树构造算法实现如下：</strong></p> 
<pre><code class="language-cpp">void CreatHuffmanTree(HuffmanTree HT,int n){
    int(n&lt;=1)    return;
    m=2*n-1;
    HT=new HTNode[m+1];
    for(i=1;i&lt;=m;++i){
    HT[i].lch=0;    HT[i].rch=0;    HT[i].parent=0;
    }
    for(i=1;i&lt;=n;++i)    cin&gt;&gt;HT[i].weight;
    for(i=n+1;i&lt;=m;i++){
        Select(HT,i-1,s1,s2);
        HT[s1].parent=i;    HT[s2].parent=i;
        HT[i].lch=s1;    HT[i].rch=s2;
        HT[i].weight=HT[s1].weight + HT[s2].weight;
    }
}</code></pre> 
<p></p> 
<p></p> 
<h2 id="4%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81%E6%80%9D%E6%83%B3">4、哈夫曼树编码思想</h2> 
<p><img alt="" height="448" src="https://images2.imgbox.com/f4/10/dc7zE5f0_o.png" width="895"></p> 
<p>        <strong> 上图的编码方式是等长度的，倘如我们使用这种等长度的编码方式，会使得转换的二进制字符串很长，进而浪费更多的空间。所以我们需要使用一种长度不等的编码，这样可以让待传字符串中出现次数较多的字符采用尽可能短的编码，则转换的二进制字符串便可能减少，以达到减少空间的目的。</strong></p> 
<p></p> 
<p></p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/9a/51/y3Nnj6RO_o.png" width="899"></p> 
<p>      <strong>   上图的这种不等长非前缀编码A-0,B-00,C-1,D-01        虽能达到减少转换的二进制字符串长度，但是有一个很致命的问题——重码，就是0000 可以译为AAAA，也可以是ABA，还可以是BB，即它的译码并不唯一。于是我们在不等长编码的基础上使其为前缀的，前缀编码的意思，在一个编码方案中，任一个编码都不是其他任何编码的前缀。</strong></p> 
<p><strong>        那么什么样的前缀码能使得转换的二进制字符串最短呢？——哈夫曼编码。</strong></p> 
<p></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/c0/d1/WZokmGvZ_o.png" width="956"></p> 
<p>         <strong>其中的重点是将每一个字符出现的频率（即出现的次数）作为权值，构造哈夫曼树，那么就可以达到我们要的目的啦~        </strong></p> 
<blockquote> 
 <p>举个栗子：</p> 
 <p> <img alt="" height="354" src="https://images2.imgbox.com/2a/1a/VWJOUHsi_o.png" width="548"></p> 
 <p> <strong>以字符出现频率为权，构造哈弗曼树如上，然之后<span style="color:#be191c;">左分支为0，右分支为1</span><span style="color:#0d0016;">，标出来如下图：</span></strong></p> 
 <p><img alt="" height="306" src="https://images2.imgbox.com/3b/1f/ZlaqABoK_o.png" width="314"><img alt="" height="187" src="https://images2.imgbox.com/f7/ce/6KNjsAh8_o.png" width="155"></p> 
 <p></p> 
 <p><strong> 那么就可以知道每个字符的编码啦~</strong></p> 
 <p><img alt="" height="143" src="https://images2.imgbox.com/72/42/14dyU4BA_o.png" width="764"></p> 
</blockquote> 
<p></p> 
<p> <img alt="" height="345" src="https://images2.imgbox.com/9c/b1/32Ef7QZa_o.png" width="944"></p> 
<p><strong> 哈夫曼编码的两个性质：</strong></p> 
<p><strong>1、哈夫曼编码使前缀码</strong></p> 
<p><strong>2、哈夫曼编码使最优前缀码</strong></p> 
<p></p> 
<blockquote> 
 <p><strong>再举个栗子：</strong></p> 
 <p> <img alt="" height="178" src="https://images2.imgbox.com/f1/f9/YJyrxcrz_o.png" width="653"></p> 
 <p><strong> 构造哈夫曼树</strong>：</p> 
 <p><img alt="" height="413" src="https://images2.imgbox.com/17/7b/mj2hMJ6c_o.png" width="529"></p> 
 <p></p> 
 <p><img alt="" height="405" src="https://images2.imgbox.com/a9/0d/FrhC1VKg_o.png" width="534"></p> 
 <p></p> 
 <p><img alt="" height="314" src="https://images2.imgbox.com/be/b7/OAQFoHG1_o.png" width="185">                        <img alt="" height="240" src="https://images2.imgbox.com/97/ce/QoCH8NlG_o.gif" width="240"></p> 
 <p></p> 
 <p>所以哈夫曼编码就是这样啦~</p> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<h2 id="5%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">5、哈夫曼编码的算法实现。 </h2> 
<p><strong>由上面栗子所构造的哈夫曼树，我们可以写出下面的结构数组。</strong></p> 
<p><img alt="" height="413" src="https://images2.imgbox.com/d9/84/8hTHXAgr_o.png" width="529"></p> 
<p> <img alt="" height="449" src="https://images2.imgbox.com/28/0c/Z6pxoquA_o.png" width="389"></p> 
<p> <strong>我们通过这个结构数组来进行叶子结点到根的不断回溯。</strong></p> 
<p><strong>       例：字符G的编码回溯如下：先在结构数组里找到字符G，然后找G的根结点也就是8，然后在8里看G对应的7是8的左孩子还是右孩子，这里是左孩子，也就是0，然后看8的根结点，也就是10，8是10的左孩子，所以还是0，.......一直循环下去，然后到12的根结点是13，12是13的右孩子，也就是1.接着我们发现13没有了双亲。所以13就是根。那么循环就结束了。所以最后反过来 字符G的二进制就是10000. （</strong> <strong>我们需要用一个数组来储存所得到的0和1，而且需要从尾巴开始储存。</strong> <strong>）</strong></p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/06/d6/frs3Rjpr_o.png" width="816"></p> 
<pre><code class="language-cpp">void CreatHuffmanCode(HuffmanTree HT,HuffmanCode &amp;HC,int n)
	HC =new char*[n+1];
	cd =new che[n];
	cd[n-1]='\0';
	for(i=1;i&lt;=n;++i){
		start=n-1;c=i;f=HT[i].parent;
		while(f!=0){
			--start;
			if(HT[f].lchild==c)	cd[start]='0';
			else	cd[start]='1';
			c=f;f=HT[f].parent;
		}
		HC[i]=new char[n-start];
		strcpy(HC[i],&amp;cd[start]);
	}
	delete cd;
}</code></pre> 
<p> </p> 
<h2 id="6%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81">6、文件的编码和译码</h2> 
<p><img alt="" height="369" src="https://images2.imgbox.com/62/d0/v03wbMZy_o.png" width="557"><img alt="" height="377" src="https://images2.imgbox.com/d1/04/zTJE58qj_o.png" width="688"></p> 
<blockquote> 
 <p><strong> 举个栗子：</strong></p> 
 <p></p> 
 <p><img alt="" height="373" src="https://images2.imgbox.com/86/7e/FWpi1WWw_o.png" width="672"></p> 
 <p> <strong>构造哈夫曼树：</strong></p> 
 <p><img alt="" height="297" src="https://images2.imgbox.com/8c/bd/LnQvA6Hd_o.png" width="378"></p> 
 <p></p> 
 <p><strong>按照编码解码：</strong></p> 
 <p> <img alt="" height="45" src="https://images2.imgbox.com/c5/07/ruMWLOwL_o.png" width="447"></p> 
 <p> </p> 
</blockquote> 
<p></p> 
<p> </p> 
<h2 id="%E6%A0%B9%E6%8D%AE%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%B1%82%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A">7、根据哈夫曼树求哈夫曼编码的完整代码：</h2> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespace std;
typedef struct
{
	int weight;
	int parent,lchild,rchild;
}HTNode,*HuffmanTree;
typedef char **HuffmanCode;

void Select(HuffmanTree HT,int len,int &amp;s1,int &amp;s2)
{
	int i,min1=0x3f3f3f3f,min2=0x3f3f3f3f;//先赋予最大值
	for(i=1;i&lt;=len;i++)
	{
		if(HT[i].weight&lt;min1&amp;&amp;HT[i].parent==0)
		{
			min1=HT[i].weight;
			s1=i;
		}	
	}
	int temp=HT[s1].weight;//将原值存放起来，然后先赋予最大值，防止s1被重复选择
	HT[s1].weight=0x3f3f3f3f;
	for(i=1;i&lt;=len;i++)
	{
		if(HT[i].weight&lt;min2&amp;&amp;HT[i].parent==0)
		{
			min2=HT[i].weight;
			s2=i;
		}
	}
	HT[s1].weight=temp;//恢复原来的值
}

//用算法5.10构造赫夫曼树
void CreatHuffmanTree(HuffmanTree &amp;HT,int n)
{
	//构造赫夫曼树HT
	int m,s1,s2,i;
	if(n&lt;=1) return;
	m=2*n-1;
	HT=new HTNode[m+1];  		//0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点   
	for(i=1;i&lt;=m;++i)        	//将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0   
	   { HT[i].parent=0;  HT[i].lchild=0;  HT[i].rchild=0; }
	cout&lt;&lt;"请输入叶子结点的权值：\n";
	for(i=1;i&lt;=n;++i)        	//输入前n个单元中叶子结点的权值  
		cin&gt;&gt;HT[i].weight;  
	/*――――――――――初始化工作结束，下面开始创建赫夫曼树――――――――――*/ 
	for(i=n+1;i&lt;=m;++i) 
	{  	//通过n-1次的选择、删除、合并来创建赫夫曼树
		Select(HT,i-1,s1,s2);
		//在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点,
		// 并返回它们在HT中的序号s1和s2
		HT[s1].parent=i; 	
		HT[s2].parent=i;   
		//得到新结点i，从森林中删除s1，s2，将s1和s2的双亲域由0改为i
		HT[i].lchild=s1;   
		HT[i].rchild=s2 ;							//s1,s2分别作为i的左右孩子
		HT[i].weight=HT[s1].weight+HT[s2].weight; 	//i 的权值为左右孩子权值之和
	}												//for
}	
												// CreatHuffmanTree
void CreatHuffmanCode(HuffmanTree HT,HuffmanCode &amp;HC,int n)
{
	//从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中
	int i,start,c,f;
	HC=new char*[n+1];         						//分配n个字符编码的头指针矢量
	char *cd=new char[n];							//分配临时存放编码的动态数组空间
	cd[n-1]='\0';                            		//编码结束符
	for(i=1;i&lt;=n;++i)
	{                      							//逐个字符求赫夫曼编码
		start=n-1;                          		//start开始时指向最后，即编码结束符位置
		c=i; 
		f=HT[i].parent;                 			//f指向结点c的双亲结点
		while(f!=0)
		{                          					//从叶子结点开始向上回溯，直到根结点
			--start;                          		//回溯一次start向前指一个位置
			if(HT[f].lchild==c)  
				cd[start]='0';						//结点c是f的左孩子，则生成代码0
			else 
				cd[start]='1';                 		//结点c是f的右孩子，则生成代码1
			c=f; 
			f=HT[f].parent;             			//继续向上回溯
		}                                  			//求出第i个字符的编码      
		HC[i]=new char[n-start];         			// 为第i 个字符编码分配空间
		strcpy(HC[i], &amp;cd[start]);        			//将求得的编码从临时空间cd复制到HC的当前行中
	}
	delete cd;                            			//释放临时空间
}													// CreatHuffanCode
void show(HuffmanTree HT,HuffmanCode HC,int n)
{
	for(int i=1;i&lt;=sizeof(HC)+1;i++)
		cout&lt;&lt;HT[i].weight&lt;&lt;"编码为"&lt;&lt;HC[i]&lt;&lt;endl;
}
int main()
{
	HuffmanTree HT;
	HuffmanCode HC;
	int n;
	cout&lt;&lt;"请输入叶子结点的个数：\n";
	cin&gt;&gt;n;											//输入赫夫曼树的叶子结点个数
	CreatHuffmanTree(HT,n);
	CreatHuffmanCode(HT,HC,n);
	show(HT,HC,n);
}</code></pre> 
<p> </p> 
<h2 id="%C2%A0%E4%BB%A526%E4%B8%AA%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E9%A2%91%E7%8E%87%E4%B8%BA%E6%9D%83%E6%9E%84%E9%80%A0%E4%B8%80%E6%A3%B5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%9A">8、 以26个英文字母的频率为权构造一棵哈夫曼树：</h2> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
using namespace std;

//哈夫曼树的存储结构
typedef struct
{
    char data;   //存储数据
    int weight;  //结点的权重
    string num;  //存放哈夫曼码
    int parent, lchild, rchild;  //结点的双亲、左孩子、右孩子的下标
} HTNode,*HuffmanTree;

//两个最小结点
typedef struct
{
    int s1;
    int s2;
} MIN;

//选择结点权值最小的两个结点
MIN Select(HuffmanTree HT, int n)
{
    int min, secmin,s1,s2;
    min = 10000;
    secmin = 10000;
    MIN code;
    s1 = 1;
    s2 = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        if (HT[i].parent == 0 &amp;&amp; (HT[i].weight&lt;min))
        {
            min = HT[i].weight;
            s1 = i;
        }
    }
    for (int i = 1; i &lt;= n; i++)
    {
        if (HT[i].parent == 0 &amp;&amp; (HT[i].weight&lt;secmin) &amp;&amp; (i != s1))
        {
            secmin = HT[i].weight;
            s2 = i;
        }
    }
    code.s1 = s1;
    code.s2 = s2;
    return code;

}

//将哈夫曼码存储在结构体num中
void putlorinnum(HuffmanTree &amp;hft, int num)
{
    for(int i = num; i &gt;= 1; i--)
    {
        if(hft[hft[i].parent].parent)
        {
        hft[i].num = hft[hft[i].parent].num + hft[i].num;
        }
    }
}


//创造哈夫曼树
void CreateHuffmanTree(HuffmanTree &amp;HT, int num)
{

    int m;
    m = 2 * num - 1;
    HT = new HTNode[m + 1];   //分配空间
    for (int i = 1; i &lt;= m; i++)   //初始化
    {
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    }
    cout &lt;&lt; "请输入每个数据及其权值：" &lt;&lt; endl;
    for (int i = 1; i &lt;= num; i++)
    {
        cin &gt;&gt; HT[i].weight;
        cin&gt;&gt;HT[i].data;
    }

    for (int i = num + 1; i &lt;= m; i++)  //构建哈夫曼树
    {
        MIN min;
        min=Select(HT,i-1);      //选择二叉树
        HT[min.s1].parent = i;
        HT[min.s2].parent = i;
        HT[i].lchild = min.s1;
        HT[min.s1].num = "0";
        HT[i].rchild = min.s2;
        HT[min.s2].num = "1";
        HT[i].weight = HT[min.s1].weight + HT[min.s2].weight;
        HT[i].data = -1;
    }
    putlorinnum(HT, m);   
    for (int i = 1; i &lt;= m; i++)  //进行每个字符哈夫曼码的输出
    {
        if(HT[i].data != -1)
        {
            cout&lt;&lt;HT[i].data&lt;&lt;" 权重为"&lt;&lt;HT[i].weight&lt;&lt;"  ，哈夫曼码为："&lt;&lt;HT[i].num&lt;&lt;endl;

            cout&lt;&lt;endl;
        }
    }
}

//将一串字符编译成哈夫曼码
void changchartohft(HuffmanTree hft, string s, int m)
{
    string estring;
    for(int i = 0;i &lt;= s.size(); i++)
    {
        for(int x = 1; x &lt;= m; x++)
        {
            if(hft[x].data == s[i])//查找哈夫曼树中相应的字符
            {
                estring = estring + hft[x].num;//哈夫曼码连接起来
                x = m;
            }
        }
    }
    cout&lt;&lt;estring&lt;&lt;endl;
    return;
}



//将一串哈夫曼码解译成一串字符
void changhfttochar(HuffmanTree hft, string s, int m)
{
    string estring;
    int pos = 0, first = 0;
    for(int x = 0; x &lt;= s.size(); x++)
    {
        pos++;
        for(int i = 1; i &lt;= m; i++)
        {
            if(hft[i].num == s.substr(first, pos))//将截取的字符串和哈夫曼中哈夫曼码近行对比
            {
                cout&lt;&lt;hft[i].data;
                first = pos + first;
                pos = 0;
            }
        }
    }
    cout&lt;&lt;endl;
}

int main()
{
    int num;  //结点的个数
    string s1, s2;
    cout &lt;&lt; "请输入哈夫曼树叶子结点的个数：";
    cin &gt;&gt; num;
    //创造哈夫曼树
    HuffmanTree HT;
    CreateHuffmanTree(HT, num);
    
    while(1)//设置一个循环，可以选择性进行某些步骤。
    {
        int q;
        cout&lt;&lt;"----------------------"&lt;&lt;endl;
        cout&lt;&lt;"编译：1"&lt;&lt;endl;
        cout&lt;&lt;"解码：2"&lt;&lt;endl;
        cout&lt;&lt;"(其他按键结束)"&lt;&lt;endl;
        cout&lt;&lt;"输入要进行的操作："&lt;&lt;endl;
        cin&gt;&gt;q;
        
        if(q==1)
        {
                cout&lt;&lt;"输入想要编译的一串字符"&lt;&lt;endl;
                cin&gt;&gt;s1;
                changchartohft(HT, s1, num);
        }
        else if(q==2)
        {
                cout&lt;&lt;"输入想要解码的一串数字"&lt;&lt;endl;
                cin&gt;&gt;s2;
                changhfttochar(HT, s2, num);
        }
        else
            break;
    }
    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51dabee8e2fba51cdf479c9bdee82d6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot结合ip2region</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/344d76e371d4ed2bd63abc069686d3ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Element-UI el-select多选表单校验问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>