<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于进程间通信的学习心得 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于进程间通信的学习心得" />
<meta property="og:description" content="进程：进程是指独立地址空间的指令序列
进程的五种状态：新建，就绪，运行，睡眠，僵死
进程间通信：是不同进程之间进行一些&#34;接触&#34;，这种接触有简单，有复杂。机制不同，复杂度也不同。通信是一个广义上的意义，不仅指大批量数据传送，还包括控制信息的传送，但使用方法是基本相同的。
基本的进程通信机制
1.传统UNIX-IPC机制：信号和管道
2.SystemV的IPC机制：共享内存、信号量和消息队列
3.起源于Unix BSD版本的套结字（Socket）
4.远程过程调用（RPC）
信号：Unix系统中使用的最古老的进程间通讯的方法之一，用于向一个或多个进程发送异步事件的信号。信号可以类比于DOS下的INT或者是Windows下的事件。在有一个信号发生的时候，相应的信号就会发送给相应的进程。
信号机制的实现
1.信号包括待处理信号和被阻塞信号
2.如果产生了一个被阻塞的信号，它一直保留待处理，直到被解除阻塞。
3.系统保存每一个进程如何处理每一种可能的信号的信息。
4.系统判断进程是希望忽略这个信号还是让内核处理。进程通过执行系统调用改变缺省的信号处理。
对信号的处理
1.初始化信号集，只有在信号集里面的信号才会被考虑
2.安装信号处理器。所谓信号处理器，就是指定了一些对信号的处理方法。在安装的时候，一定要对特定的信号赋予正确的信号处理函数。
信号相关函数
int sigaction(int signo, const struct sigaction *act, struct sigaction *oact)；为进程安装信号处理器，struct sigaction数据结构是用来保存信号处理器的相关信息。
int sigemptyset(sigset_t *set)；将信号集合清空。
int sigfillset(sigset_t *set)；将信号集合设置成包含所有的信号，在对信号进行操作以前一定要对信号集进行初始化。
int sigaddset(sigset_t *set, int signo)；向信号集中加入signo对应的新信号。
int sigdelset(sigset_t *set, int signo)；从信号集中删除signo对应的一个信号。
int sigismember(const sigset_t *set, int signo)；判断某个信号是否在信号集中。
int sigprocmask(int how,const sigset_t *set, sigset_t *oset)；设置进程的信号屏蔽码。信号屏蔽码可以用来在某段时间内阻塞一些信号集中的信号。
管道通信：是最古老的Unix IPC工具，一个进程从管道一头写数据，另一个进程从管道另一头读数据，以实现它们之间通信的共享方式，又称pipe文件。由于发送和接收都是利用管道进行通信的，故称为管道通信。通信方式是单向的。管道类型分为：无名管道、命名管道
管道通信的思想
1.发送进程可以源源不断的从pipe一端写入数据流，在规定的pipe文件的最大长度（如4096字节）范围内，每次写入的信息长度是可变的。
2.接收进程在需要时可以从pipe的另一端读出数据，读出单位长度也是可变的。
基本管道调用函数
int do_pipe(int *fd)；创建管道
static int pipe_release(struct inode *inode, int decr, int decw)；管道释放" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a46894de7793d05696c08382ba7d0e35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-03-19T13:50:37+08:00" />
<meta property="article:modified_time" content="2013-03-19T13:50:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于进程间通信的学习心得</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="blog_text" style="padding:0px; margin:0px; font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:14px; line-height:22px; background-color:rgb(249,249,249)"> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">进程：</span>进程是指独立地址空间的指令序列</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">进程的五种状态：</span>新建，就绪，运行，睡眠，僵死</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">进程间通信：</span>是不同进程之间进行一些<span style="padding:0px; margin:0px; font-family:'Times New Roman'">"</span>接触<span style="padding:0px; margin:0px; font-family:'Times New Roman'">"</span>，这种接触有简单，有复杂。机制不同，复杂度也不同。通信是一个广义上的意义，不仅指大批量数据传送，还包括控制信息的传送，但使用方法是基本相同的。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">基本的进程通信机制</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">1.</span>传统<span style="padding:0px; margin:0px; font-family:'Times New Roman'">UNIX-IPC</span>机制：信号和管道</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">2.SystemV</span>的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">IPC</span>机制：共享内存、信号量和消息队列</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">3.</span>起源于<span style="padding:0px; margin:0px; font-family:'Times New Roman'">Unix BSD</span>版本的套结字（<span style="padding:0px; margin:0px; font-family:'Times New Roman'">Socket</span>）</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">4.</span>远程过程调用（<span style="padding:0px; margin:0px; font-family:'Times New Roman'">RPC</span>）</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">信号：</span><span style="padding:0px; margin:0px; font-family:'Times New Roman'">Unix</span>系统中使用的最古老的进程间通讯的方法之一，用于向一个或多个进程发送异步事件的信号。信号可以类比于<span style="padding:0px; margin:0px; font-family:'Times New Roman'">DOS</span>下的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">INT</span>或者是Windows下的事件。在有一个信号发生的时候，相应的信号就会发送给相应的进程。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">信号机制的实现</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">1.</span>信号包括待处理信号和被阻塞信号</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">2.</span>如果产生了一个被阻塞的信号，它一直保留待处理，直到被解除阻塞。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">3.</span>系统保存每一个进程如何处理每一种可能的信号的信息。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">4.</span>系统判断进程是希望忽略这个信号还是让内核处理。进程通过执行系统调用改变缺省的信号处理。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">对信号的处理</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">1.</span>初始化信号集，只有在信号集里面的信号才会被考虑</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">2.</span>安装信号处理器。所谓信号处理器，就是指定了一些对信号的处理方法。在安装的时候，一定要对特定的信号赋予正确的信号处理函数。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">信号相关函数</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int sigaction(int signo, const struct sigaction *act, struct sigaction *oact)</span>；为进程安装信号处理器，<span style="padding:0px; margin:0px; font-family:'Times New Roman'">struct sigaction</span>数据结构是用来保存信号处理器的相关信息。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int sigemptyset(sigset_t *set)</span>；将信号集合清空。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int sigfillset(sigset_t *set)</span>；将信号集合设置成包含所有的信号，在对信号进行操作以前一定要对信号集进行初始化。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int sigaddset(sigset_t *set, int signo)</span>；向信号集中加入<span style="padding:0px; margin:0px; font-family:'Times New Roman'">signo</span>对应的新信号。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int sigdelset(sigset_t *set, int signo)</span>；从信号集中删除<span style="padding:0px; margin:0px; font-family:'Times New Roman'">signo</span>对应的一个信号。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int sigismember(const sigset_t *set, int signo)</span>；判断某个信号是否在信号集中。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int sigprocmask(int how,const sigset_t *set, sigset_t *oset)</span>；设置进程的信号屏蔽码。信号屏蔽码可以用来在某段时间内阻塞一些信号集中的信号。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">管道通信</span>：是最古老的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">Unix IPC</span>工具，一个进程从管道一头写数据，另一个进程从管道另一头读数据，以实现它们之间通信的共享方式，又称<span style="padding:0px; margin:0px; font-family:'Times New Roman'">pipe</span>文件。由于发送和接收都是利用管道进行通信的，故称为管道通信。通信方式是单向的。管道类型分为：无名管道、命名管道</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">管道通信的思想</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">1.</span>发送进程可以源源不断的从<span style="padding:0px; margin:0px; font-family:'Times New Roman'">pipe</span>一端写入数据流，在规定的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">pipe</span>文件的最大长度（如<span style="padding:0px; margin:0px; font-family:'Times New Roman'">4096</span>字节）范围内，每次写入的信息长度是可变的。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">2.</span>接收进程在需要时可以从<span style="padding:0px; margin:0px; font-family:'Times New Roman'">pipe</span>的另一端读出数据，读出单位长度也是可变的。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">基本管道调用函数</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int do_pipe(int *fd)</span>；创建管道</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">static int pipe_release(struct inode *inode, int decr, int decw)</span>；管道释放</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">无名管道<span style="padding:0px; margin:0px; font-family:'Times New Roman'">II</span></span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">显示了每一个<span style="padding:0px; margin:0px; font-family:'Times New Roman'">file</span>数据结构包含了不同的文件操作例程的向量表的指针：一个用于写，另一个从管道中读。这掩盖了和通用的读写普通文件的系统调用的不同。当写进程向管道中写的时候，字节拷贝到了共享的数据页，当从管道中读的时候，字节从共享页中拷贝出来。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">命名管道</span>：又名<span style="padding:0px; margin:0px; font-family:'Times New Roman'">FIFO</span>，它不是临时的对象，而是文件系统中的实体，可以用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">mkfifo</span>命令创建。系统必须处理在写进程打开<span style="padding:0px; margin:0px; font-family:'Times New Roman'">FIFO</span>之前打开<span style="padding:0px; margin:0px; font-family:'Times New Roman'">FIFO</span>读的进程，以及在写进程写数据之前读的进程。它使用和无名管道一样的数据结构和操作。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-family:'Times New Roman'; font-size:13px">   </span><span style="padding:0px; margin:0px; font-family:'Times New Roman'; font-size:13px; color:rgb(255,238,198)"><span style="padding:0px; margin:0px">    </span></span><span style="padding:0px; margin:0px; font-size:13px">（写入端）</span><span style="padding:0px; margin:0px; font-family:'Times New Roman'; font-size:13px; color:rgb(255,238,198)"><span style="padding:0px; margin:0px">[Fd1]</span></span><span style="padding:0px; margin:0px; font-size:13px">→<span style="padding:0px; margin:0px; font-family:'Times New Roman'">pipe(fd)</span>→<span style="padding:0px; margin:0px; font-family:'Times New Roman'">[Fd0]</span>（读出端）</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">信号量：</span>信号量（<span style="padding:0px; margin:0px; font-family:'Times New Roman'">Semaphore)</span>和信号是不同的东西，信号是实现约定的固定的值，而信号量是一个变量记录着某些特定信息，它的使用主要是用来保护共享资源，使得该资源在一个时刻只让一个进程拥有。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">信号量的数据结构</span>：使用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">semid_ds</span>数据结构表达信号量。系统中所有的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">semid_ds</span>数据结构都由<span style="padding:0px; margin:0px; font-family:'Times New Roman'">semary</span>指针向量表指向。每一个信号灯数组中都有<span style="padding:0px; margin:0px; font-family:'Times New Roman'">sem_nsems</span>，通过<span style="padding:0px; margin:0px; font-family:'Times New Roman'">sem_base</span>指向的一个<span style="padding:0px; margin:0px; font-family:'Times New Roman'">sem</span>数据结构来描述</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">信号量机制的实现</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">1.</span>对信号量的操作只有两个：<span style="padding:0px; margin:0px; font-family:'Times New Roman'">P</span>、<span style="padding:0px; margin:0px; font-family:'Times New Roman'">V</span>。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">2.</span>为了在逻辑上便于组织信号量，信号量机制中有一个概念是信号量组。我们在一个信号量组中创建相关的信号量，这样逻辑上清晰也便于管理。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">3.</span>在使用之前同样需要对他们进行初始化：生成或打开信号量组，向其中生成或删除指定的信号量。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">4.</span>一个信号量必须属于一个信号量组，否则不能被系统所使用。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">5.</span>信号量和信号量组是不会被系统所自动清理的，所以在进程退出前，需要及时清理生成的那些信号量。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">信号量的相关函数</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int semget(key_t key, int nsems, int semflg)</span>；创建一个新的信号量组或获取一个已经存在的信号量组。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int semop(int semid, struct sembuf *sop, int nsops)</span>；一次对一个或多个信号量进行操作，用于<span style="padding:0px; margin:0px; font-family:'Times New Roman'">P</span>、<span style="padding:0px; margin:0px; font-family:'Times New Roman'">V</span>操作。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">Int semctl(int sem_id, int semnum, int cmd, union semun arg)</span>；用来获取一些信号量的使用信息或者是来对信号量进行控制。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">共享内存</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">    </span>共享内存是进程通信的一个重要方法，为进程提供了直接通信的手段。<a href="http://hi.baidu.com/andyzcj/blog/item/:;" rel="nofollow noopener noreferrer" target="_self" style="padding:0px; margin:0px; color:rgb(68,102,187); outline:0px"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; color:rgb(255,238,198)">操作系统</span></span></span></a>中一个或多个进程通过同时出现在它们的虚拟地址空间的内存通讯，该虚拟内存被每个共享进程的页表所引用，它们的地址无需相同。进程对共享内存的访问是受控的，信号量等机制实现了共享内存访问的同步</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">共享内存的简单原理</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">每一个新创建的内存区域都用一个<span style="padding:0px; margin:0px; font-family:'Times New Roman'">shmid_ds</span>数据结构来表达。这些数据结构保存在<span style="padding:0px; margin:0px; font-family:'Times New Roman'">shm_segs</span>向量表中。<span style="padding:0px; margin:0px; font-family:'Times New Roman'">Shmid_ds</span>数据结构描述了这个共享内存取有多大、多少个进程在使用它以及共享内存如何映射到它们的地址空间。由共享内存的创建者来控制对于这块内存的访问权限和它的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">key</span>是公开或私有。如果有足够的权限它也可以把共享内存锁定在物理内存中。每一个希望共享这块内存的进程必须通过系统调用粘附（<span style="padding:0px; margin:0px; font-family:'Times New Roman'">attach</span>）到虚拟内存。这为该进程创建了一个新的描述这块共享内存的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_area_struct</span>数据结构。进程可以选择共享内存在它的虚拟地址空间的位置或者由Linux选择一块足够的的空闲区域。这个新的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_area_struct</span>结构放在由<span style="padding:0px; margin:0px; font-family:'Times New Roman'">shmid_ds</span>指向的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_area_struct</span>列表中。通过<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_next_shared</span>和<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_prev_shared</span>把它们连在一起。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">共享内存的基本函数</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int shmget(key_t key,int size,int shmflg)</span>；建立新的共享内存或一个已存在的共享内存描述字</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">void *shmat(int shmid,const void *shmaddr,int shmflg)</span>；将物理共享内存粘附到进程虚拟地址空间</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int shmdt(const void *shmaddr)</span>；进程从其虚拟地址空间分离共享内存</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int shmctl(int shmid,int cmd,struct shmid_ds *buf)</span>；查询及设置一个共享内存</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">共享内存机制的实现</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">在使用一个共享内存之前我们调用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">shmat</span>得到共享内存的开始地址，使用结束以后我们使用</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">shmdt</span>断开这个内存。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">进程通过系统调用粘附到虚拟内存，即创建了一个新的描述这块共享内存的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_area_struct</span>数据结构，这个新的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_area_struct</span>结构放在由<span style="padding:0px; margin:0px; font-family:'Times New Roman'">shmid_ds</span>指向的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_area_struct</span>列表中。通过<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_next_shared</span>和<span style="padding:0px; margin:0px; font-family:'Times New Roman'">vm_prev_shared</span>把它们连在一起。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">虚拟内存在粘附的时候其实并没有创建，而发生在第一个进程试图访问它的时候。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">第一个访问共享内存页的进程使得这一页被创建，而随后访问的其他进程使得此页被加到它们的虚拟地址空间。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">当进程不再需要共享虚拟内存的时候，它们从中分离出来。只要仍旧有其他进程在使用这块内存，这种分离只是影响当前的进程。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">当共享这块内存的最后一个进程从中分离出的时候，共享内存当前在物理内存中的页被释放</span></p> 
</div> 
<br style="padding:0px; margin:0px; font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:14px; line-height:22px; background-color:rgb(249,249,249)"> 
<div id="blog_text" style="padding:0px; margin:0px; font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:14px; line-height:22px; background-color:rgb(249,249,249)"> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px">消息队列：</span>消息队列是比较高级的一种进程间通信方法，实现一个或多个进程间<span style="padding:0px; margin:0px; font-family:'Times New Roman'">message</span>传送，一个消息队列可以被多个进程所共享（<span style="padding:0px; margin:0px; font-family:'Times New Roman'">IPC</span>就是在这个基础上进行的）；如果一个进程的消息太多一个消息队列放不下，也可以用多于一个的消息队列（不过可能管理会比较复杂）。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">消息队列的基本函数</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int msgget(key_t key, int msgflg)</span>；获取一个存在的消息队列的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">ID</span>，或者是根据跟定的权限创建一个消息队列。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int msgctl(int msqid, int cmd, struct msqid_ds *buf)</span>；用来从<span style="padding:0px; margin:0px; font-family:'Times New Roman'">msqid_ds</span>中获取很多消息队列本身的信息。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg)</span>；用于向队列发送消息。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">int msgrcv(int msqid, void *msgp, size_t msgsz, long int msgtyp, intmsgflg)</span>；从队列中接收消息。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">消息队列的实现机制</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">消息队列，是一个队列的结构，队列里面的内容由用户进程自己定义。实际上，队列里面记录的是指向用户自定义结构的指针和结构的大小。要使用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">message queue</span>，首先要通过系统调用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">(msgget)</span>产生一个队列，然后，进程可以用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">msgsnd</span>发送消息到这个队列，消息就是如上所说的结构。别的进程用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">msgrcv</span>读取。消息队列一旦产生，除非明确的删除（某个有权限的进程或者用<span style="padding:0px; margin:0px; font-family:'Times New Roman'">ipcrm</span>命令）或者系统重启。否则，产生的队列会一直保留在系统中。而且，只要有权限，就可以对队列进行操作。消息队列和管道很相似，实际上，管道就是用户消息为<span style="padding:0px; margin:0px; font-family:'Times New Roman'">1</span>个字节的队列。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">消息队列的写进程</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">每一次一个进程试图向写队列写消息，它的有效用户和组的标识符就要和队列的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">ipc_perm</span>数据结构的模式比较。如果进程可以想这个队列写，则消息会从进程的地址空间写到<span style="padding:0px; margin:0px; font-family:'Times New Roman'">msg</span>数据结构，放到消息队列的最后。每一个消息都带有进程间约定的，应用程序指定类型的标记。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">消息队列的读进程</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">从队列中读是一个相似的过程。进程的访问权限一样被检查。一个读进程可以选择是不管消息的类型从队列中读取第一条消息还是选择特殊类型的消息。如果没有符合条件的消息，读进程会被加到消息队列的读等待进程，然后运行调度程序。当一个新的消息写到队列的时候，这个进程会被唤醒，继续运行。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">消息队列的简单流程</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">发送进程<span style="padding:0px; margin:0px; font-family:'Times New Roman'">                             </span>接收流程</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">Send(m)                              Receive(m )</span></span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">   Begin                                 begin</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">   </span>向系统申请一个消息缓冲区<span style="padding:0px; margin:0px; font-family:'Times New Roman'">              P(SM) </span>等待接的消息的个数</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">   P(mutex) </span>使用公用缓冲区<span style="padding:0px; margin:0px; font-family:'Times New Roman'">               P(mutex) </span>使用公用缓冲区</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">   </span>将发送区消息<span style="padding:0px; margin:0px; font-family:'Times New Roman'">m</span>送入新申请的消息缓冲区<span style="padding:0px; margin:0px; font-family:'Times New Roman'">  </span>摘下消息队列中的消息<span style="padding:0px; margin:0px; font-family:'Times New Roman'">m</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">   </span>把消息缓冲区挂入接收进程的消息队列<span style="padding:0px; margin:0px; font-family:'Times New Roman'">     </span>将消息队列<span style="padding:0px; margin:0px; font-family:'Times New Roman'">m</span>从缓冲区复制到接收区</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">   V(mutex)</span>释放缓冲区<span style="padding:0px; margin:0px; font-family:'Times New Roman'">                    </span>释放缓冲区</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">   V(SM)</span>向接收进程发送消息<span style="padding:0px; margin:0px; font-family:'Times New Roman'">              V(mutex) </span>释放公用缓冲区</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">  <span style="padding:0px; margin:0px">End                                     end</span></span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'; font-size:13px">Socket</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">独立于具体协议的网络编程接口；</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">在<span style="padding:0px; margin:0px; font-family:'Times New Roman'">ISO</span>模型中，主要位于会话层和传输层。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">网络编程接口：<span style="padding:0px; margin:0px; font-family:'Times New Roman'">UNIX BSD</span>的套接字（<span style="padding:0px; margin:0px; font-family:'Times New Roman'">socket</span>）、<span style="padding:0px; margin:0px; font-family:'Times New Roman'">UNIX System V</span>的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">TLI</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">BSD Socket</span>（伯克立套接字）是通过标准的<span style="padding:0px; margin:0px; font-family:'Times New Roman'">UNIX</span>文件描述符和<a href="http://hi.baidu.com/andyzcj/blog/item/:;" rel="nofollow noopener noreferrer" target="_self" style="padding:0px; margin:0px; color:rgb(68,102,187); outline:0px"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; color:rgb(255,238,198)">其它</span></span></span></a>程序通讯的一个方法，目前已经被广泛移植到各个平台。</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">Socket</span>的类型</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">流式套接字：提供了一个面向连接，可靠的数据传输服务，数据无差错，无重复地发送且按发送顺序接收．内设流量控制，避免数据流超限；数据被看作是字节流，无长度限制，<span style="padding:0px; margin:0px; font-family:'Times New Roman'">FTP</span>即用此</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">数据报套接字：提供了一个无连接服务．数据包以独立包形式被发送，不提供无差错保证，数据可能丢失或重复，并且接受顺序无序，网络文件系统<span style="padding:0px; margin:0px; font-family:'Times New Roman'">NFS</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">原始套接字（<span style="padding:0px; margin:0px; font-family:'Times New Roman'">SOCK_RAW</span>）：该接口允许对较低层次协议，如<span style="padding:0px; margin:0px; font-family:'Times New Roman'">IP,ICMP</span>直接访问</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-size:13px">基本套接字调用</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">创建套接字<span style="padding:0px; margin:0px; font-family:'Times New Roman'">               socket()</span>；</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">绑定本机端口<span style="padding:0px; margin:0px; font-family:'Times New Roman'">           bind()</span>；</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">建立连接<span style="padding:0px; margin:0px; font-family:'Times New Roman'">                   connect()</span>；</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">接受连接<span style="padding:0px; margin:0px; font-family:'Times New Roman'">                   accept()</span>；</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">监听端口<span style="padding:0px; margin:0px; font-family:'Times New Roman'">                   listen()</span>；</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">数据传输<span style="padding:0px; margin:0px; font-family:'Times New Roman'">                   send(), recv()</span>等</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px">关闭套接字<span style="padding:0px; margin:0px; font-family:'Times New Roman'">               close();</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">Socket</span>相关数据结构</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-family:'Times New Roman'; font-size:13px">struct sockaddr_in</span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">          {<!-- --></span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">                  short int   </span> <span style="padding:0px; margin:0px; font-family:'Times New Roman'">sin_family;    /*</span>通信类型<span style="padding:0px; margin:0px; font-family:'Times New Roman'">*/</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">                  unsigned short int</span> <span style="padding:0px; margin:0px; font-family:'Times New Roman'">sin_port;       /*</span>端口号，网络直接顺序<span style="padding:0px; margin:0px; font-family:'Times New Roman'">*/</span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">                  struct in_addr  </span></span></p> 
 <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:10px"> <span style="padding:0px; margin:0px; font-size:13px"><span style="padding:0px; margin:0px; font-family:'Times New Roman'">         }</span></span></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc95f3347a78b40bcabd8623fd34a2c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hadoop搭建教程之五（Pig安装）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40afb91d7a6f4783d97e160c783ea620/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;中的good函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>