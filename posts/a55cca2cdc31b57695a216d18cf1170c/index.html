<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法刷题总结 (十一) 二叉树 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法刷题总结 (十一) 二叉树" />
<meta property="og:description" content="算法总结11 二叉树 一、二叉树的概念1.1、什么是二叉树？1.2、二叉树的常见类型1.2.1、无数值（1）、满二叉树（2）、完全二叉树 1.2.2、有数值（3）、二叉搜索树（4）、平衡二叉搜索树 1.3、二叉树的存储方式（1）、链式存储方式（2）、顺序存储方式 1.4、二叉树的遍历方式1.5、二叉树的递归遍历（1）、前序遍历（2）、中序遍历（3）、后序遍历 1.6、二叉树的迭代遍历（1）、前序遍历（2）、中序遍历（3）、后序遍历 1.7、二叉树的统一迭代法（1）、前序遍历（2）、中序遍历（3）、后序遍历 1.8、二叉树的层序遍历 二、经典例题2.1、前中后序遍历144.二叉树的前序遍历94.二叉树的中序遍历145.二叉树的后序遍历 2.2、层序遍历102.二叉树的层序遍历107.二叉树的层次遍历II199.二叉树的右视图637.二叉树的层平均值429.N叉树的层序遍历515.在每个 树行中找最大值116.填充每个节点的下一个右侧节点指针117.填充每个节点的下一个右侧节点指针II104.二叉树的最大深度111.二叉树的最小深度 2.3、其他类型617.合并二叉树105. 从前序与中序遍历序列构造二叉树106.从中序与后序遍历序列构造二叉树剑指 Offer 68 - II. 二叉树的最近公共祖先235. 二叉搜索树的最近公共祖先98.验证二叉搜索树652. 寻找重复的子树 2.4、其他经典练习题226.翻转二叉树101. 对称二叉树104.二叉树的最大深度111.二叉树的最小深度222.完全二叉树的节点个数110.平衡二叉树257. 二叉树的所有路径404.左叶子之和513.找树左下角的值112. 路径总和654.最大二叉树700.二叉搜索树中的搜索530.二叉搜索树的最小绝对差501.二叉搜索树中的众数236. 二叉树的最近公共祖先701.二叉搜索树中的插入操作450.删除二叉搜索树中的节点669. 修剪二叉搜索树108.将有序数组转换为二叉搜索树538.把二叉搜索树转换为累加树 一、二叉树的概念 二叉树作为一个基础的数据结构，遍历算法作为一个基础的算法，两者结合当然是经典的组合了。很多题目都会有他的身影，有直接问二叉树的遍历的，有间接问的。比如要你找到树中满足条件的节点，就是间接考察树的遍历，因为你要找到树中满足条件的点，就需要进行遍历。你如果掌握了二叉树的遍历，那么也许其他复杂的树对于你来说也并不遥远了。
1.1、什么是二叉树？ 二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分。
二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个节点 。
总之：二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树
1.2、二叉树的常见类型 1.2.1、无数值 （1）、满二叉树 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
如图所示：
这棵二叉树为满二叉树，也可以说深度为 k k k，有 2 k − 1 2^k-1 2k−1个节点的二叉树。
（2）、完全二叉树 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h h h 层，则该层包含 1 − 2 ( h − 1 ) 1- 2^{(h-1)} 1−2(h−1) 个节点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a55cca2cdc31b57695a216d18cf1170c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-03T19:12:34+08:00" />
<meta property="article:modified_time" content="2023-08-03T19:12:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法刷题总结 (十一) 二叉树</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>算法总结11 二叉树</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、二叉树的概念</a></li><li><ul><li><a href="#11_3" rel="nofollow">1.1、什么是二叉树？</a></li><li><a href="#12_16" rel="nofollow">1.2、二叉树的常见类型</a></li><li><ul><li><a href="#121_20" rel="nofollow">1.2.1、无数值</a></li><li><ul><li><a href="#1_21" rel="nofollow">（1）、满二叉树</a></li><li><a href="#2_30" rel="nofollow">（2）、完全二叉树</a></li></ul> 
    </li><li><a href="#122_37" rel="nofollow">1.2.2、有数值</a></li><li><ul><li><a href="#3_38" rel="nofollow">（3）、二叉搜索树</a></li><li><a href="#4_48" rel="nofollow">（4）、平衡二叉搜索树</a></li></ul> 
   </li></ul> 
   </li><li><a href="#13_58" rel="nofollow">1.3、二叉树的存储方式</a></li><li><ul><li><a href="#1_66" rel="nofollow">（1）、链式存储方式</a></li><li><a href="#2_79" rel="nofollow">（2）、顺序存储方式</a></li></ul> 
   </li><li><a href="#14_89" rel="nofollow">1.4、二叉树的遍历方式</a></li><li><a href="#15_116" rel="nofollow">1.5、二叉树的递归遍历</a></li><li><ul><li><a href="#1_124" rel="nofollow">（1）、前序遍历</a></li><li><a href="#2_165" rel="nofollow">（2）、中序遍历</a></li><li><a href="#3_183" rel="nofollow">（3）、后序遍历</a></li></ul> 
   </li><li><a href="#16_223" rel="nofollow">1.6、二叉树的迭代遍历</a></li><li><ul><li><a href="#1_229" rel="nofollow">（1）、前序遍历</a></li><li><a href="#2_267" rel="nofollow">（2）、中序遍历</a></li><li><a href="#3_304" rel="nofollow">（3）、后序遍历</a></li></ul> 
   </li><li><a href="#17_343" rel="nofollow">1.7、二叉树的统一迭代法</a></li><li><ul><li><a href="#1_349" rel="nofollow">（1）、前序遍历</a></li><li><a href="#2_372" rel="nofollow">（2）、中序遍历</a></li><li><a href="#3_397" rel="nofollow">（3）、后序遍历</a></li></ul> 
   </li><li><a href="#18_423" rel="nofollow">1.8、二叉树的层序遍历</a></li></ul> 
  </li><li><a href="#_485" rel="nofollow">二、经典例题</a></li><li><ul><li><a href="#21_487" rel="nofollow">2.1、前中后序遍历</a></li><li><ul><li><a href="#144_488" rel="nofollow">144.二叉树的前序遍历</a></li><li><a href="#94_503" rel="nofollow">94.二叉树的中序遍历</a></li><li><a href="#145_518" rel="nofollow">145.二叉树的后序遍历</a></li></ul> 
   </li><li><a href="#22_535" rel="nofollow">2.2、层序遍历</a></li><li><ul><li><a href="#102_536" rel="nofollow">102.二叉树的层序遍历</a></li><li><a href="#107II_553" rel="nofollow">107.二叉树的层次遍历II</a></li><li><a href="#199_570" rel="nofollow">199.二叉树的右视图</a></li><li><a href="#637_591" rel="nofollow">637.二叉树的层平均值</a></li><li><a href="#429N_610" rel="nofollow">429.N叉树的层序遍历</a></li><li><a href="#515__626" rel="nofollow">515.在每个 树行中找最大值</a></li><li><a href="#116_643" rel="nofollow">116.填充每个节点的下一个右侧节点指针</a></li><li><a href="#117II_664" rel="nofollow">117.填充每个节点的下一个右侧节点指针II</a></li><li><a href="#104_684" rel="nofollow">104.二叉树的最大深度</a></li><li><a href="#111_716" rel="nofollow">111.二叉树的最小深度</a></li></ul> 
   </li><li><a href="#23_736" rel="nofollow">2.3、其他类型</a></li><li><ul><li><a href="#617_737" rel="nofollow">617.合并二叉树</a></li><li><a href="#105__757" rel="nofollow">105. 从前序与中序遍历序列构造二叉树</a></li><li><a href="#106_783" rel="nofollow">106.从中序与后序遍历序列构造二叉树</a></li><li><a href="#_Offer_68__II__802" rel="nofollow">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></li><li><a href="#235__852" rel="nofollow">235. 二叉搜索树的最近公共祖先</a></li><li><a href="#98_868" rel="nofollow">98.验证二叉搜索树</a></li><li><a href="#652__888" rel="nofollow">652. 寻找重复的子树</a></li></ul> 
   </li><li><a href="#24_914" rel="nofollow">2.4、其他经典练习题</a></li><li><ul><li><a href="#226_916" rel="nofollow">226.翻转二叉树</a></li><li><a href="#101__917" rel="nofollow">101. 对称二叉树</a></li><li><a href="#104_918" rel="nofollow">104.二叉树的最大深度</a></li><li><a href="#111_919" rel="nofollow">111.二叉树的最小深度</a></li><li><a href="#222_920" rel="nofollow">222.完全二叉树的节点个数</a></li><li><a href="#110_921" rel="nofollow">110.平衡二叉树</a></li><li><a href="#257__922" rel="nofollow">257. 二叉树的所有路径</a></li><li><a href="#404_923" rel="nofollow">404.左叶子之和</a></li><li><a href="#513_924" rel="nofollow">513.找树左下角的值</a></li><li><a href="#112__925" rel="nofollow">112. 路径总和</a></li><li><a href="#654_927" rel="nofollow">654.最大二叉树</a></li><li><a href="#700_928" rel="nofollow">700.二叉搜索树中的搜索</a></li><li><a href="#530_929" rel="nofollow">530.二叉搜索树的最小绝对差</a></li><li><a href="#501_930" rel="nofollow">501.二叉搜索树中的众数</a></li><li><a href="#236__931" rel="nofollow">236. 二叉树的最近公共祖先</a></li><li><a href="#701_932" rel="nofollow">701.二叉搜索树中的插入操作</a></li><li><a href="#450_933" rel="nofollow">450.删除二叉搜索树中的节点</a></li><li><a href="#669__934" rel="nofollow">669. 修剪二叉搜索树</a></li><li><a href="#108_935" rel="nofollow">108.将有序数组转换为二叉搜索树</a></li><li><a href="#538_936" rel="nofollow">538.把二叉搜索树转换为累加树</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、二叉树的概念</h2> 
<p>二叉树作为一个基础的数据结构，遍历算法作为一个基础的算法，两者结合当然是经典的组合了。很多题目都会有他的身影，有直接问二叉树的遍历的，有间接问的。比如要你找到树中满足条件的节点，就是间接考察树的遍历，因为你要找到树中满足条件的点，就需要进行遍历。你如果掌握了二叉树的遍历，那么也许其他复杂的树对于你来说也并不遥远了。</p> 
<h3><a id="11_3"></a>1.1、什么是二叉树？</h3> 
<p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分。</p> 
<p>二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个节点 。</p> 
<p>总之：二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树</p> 
<p><img src="https://images2.imgbox.com/a8/af/xxPesHfY_o.gif" alt="请添加图片描述"></p> 
<br> 
<h3><a id="12_16"></a>1.2、二叉树的常见类型</h3> 
<br> 
<h4><a id="121_20"></a>1.2.1、无数值</h4> 
<h5><a id="1_21"></a>（1）、满二叉树</h5> 
<p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p> 
<p>如图所示：<br> <img src="https://images2.imgbox.com/86/63/uDtll2Xi_o.png" alt="在这里插入图片描述"><br> 这棵二叉树为满二叉树，也可以说深度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>，有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          k 
         
        
       
         − 
        
       
         1 
        
       
      
        2^k-1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9324em; vertical-align: -0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>个节点的二叉树。</p> 
<br> 
<h5><a id="2_30"></a>（2）、完全二叉树</h5> 
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
      
        h 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span> 层，则该层包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
         − 
        
        
        
          2 
         
         
         
           ( 
          
         
           h 
          
         
           − 
          
         
           1 
          
         
           ) 
          
         
        
       
      
        1- 2^{(h-1)} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span> 个节点。<br> <img src="https://images2.imgbox.com/97/9b/KbuqH6sh_o.png" alt="在这里插入图片描述"><br> 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</p> 
<br> 
<h4><a id="122_37"></a>1.2.2、有数值</h4> 
<h5><a id="3_38"></a>（3）、二叉搜索树</h5> 
<p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。</p> 
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br> 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br> 它的左、右子树也分别为二叉排序树<br> 下面这两棵树都是搜索树:<br> <img src="https://images2.imgbox.com/32/91/NiteDklR_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_48"></a>（4）、平衡二叉搜索树</h5> 
<p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p> 
<p>如图：<br> <img src="https://images2.imgbox.com/f0/fa/jymxKjTe_o.png" alt="在这里插入图片描述"><br> 最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p> 
<br> 
<h3><a id="13_58"></a>1.3、二叉树的存储方式</h3> 
<table><thead><tr><th>方式一</th><th>方式二</th></tr></thead><tbody><tr><td>链式存储</td><td>顺序存储</td></tr><tr><td>使用指针，通过指针把分布在各个地址的节点串联一起</td><td>使用数组，元素在内存是连续分布的</td></tr></tbody></table> 
<h4><a id="1_66"></a>（1）、链式存储方式</h4> 
<p><img src="https://images2.imgbox.com/df/14/P6W3pwD9_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
         self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
         self<span class="token punctuation">.</span>left <span class="token operator">=</span> left
         self<span class="token punctuation">.</span>right <span class="token operator">=</span> right
</code></pre> 
<p>二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p> 
<br> 
<h4><a id="2_79"></a>（2）、顺序存储方式</h4> 
<p><img src="https://images2.imgbox.com/79/36/HwkcHWVz_o.png" alt="在这里插入图片描述"><br> 用数组来存储二叉树如何遍历的呢？</p> 
<p>如果父节点的数组下标是 i，那么它的左孩子就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         × 
        
       
         2 
        
       
         + 
        
       
         1 
        
       
      
        i \times 2 + 1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7429em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>，右孩子就是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
         × 
        
       
         2 
        
       
         + 
        
       
         2 
        
       
      
        i \times 2 + 2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7429em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>。</p> 
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p> 
<br> 
<h3><a id="14_89"></a>1.4、二叉树的遍历方式</h3> 
<p>二叉树主要有两种遍历方式：</p> 
<table><thead><tr><th>遍历方式</th><th>深度优先遍历</th><th>广度优先遍历</th></tr></thead><tbody><tr><td>解释</td><td>先往深走，遇到叶子节点再往回走</td><td>一层一层的去便利</td></tr><tr><td>实现方法</td><td>前序遍历（递归法，迭代法）、中序遍历（递归法，迭代法）、后序遍历（递归法，迭代法）</td><td>层次遍历（迭代法）</td></tr></tbody></table> 
<p>在深度优先遍历中：有三个顺序，前中后序遍历，这三个顺序很容易搞混，这里有一个技巧去辨识：这里前中后，其实指的就是中间根节点的遍历顺序，只要记住 前中后序指的就是中间节点的位置就可以了。</p> 
<p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式：</p> 
<p>前序遍历：中左右<br> 中序遍历：左中右<br> 后序遍历：左右中</p> 
<p>可以对着如下图，看看自己理解的前后中序有没有问题：<br> <img src="https://images2.imgbox.com/c9/d2/y40JvnQo_o.png" alt="在这里插入图片描述"><br> 最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p> 
<p>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p> 
<p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p> 
<p>这里其实我们又了解了栈与队列的一个应用场景了。</p> 
<br> 
<h3><a id="15_116"></a>1.5、二叉树的递归遍历</h3> 
<p>每次写递归，都按照这三要素来写：</p> 
<table><thead><tr><th>三要素</th><th>过程</th></tr></thead><tbody><tr><td>1. 确定递归函数的参数和返回值</td><td>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</td></tr><tr><td>2. 确定终止条件</td><td>写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</td></tr><tr><td>3. 确定单层递归的逻辑</td><td>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</td></tr></tbody></table> 
<h4><a id="1_124"></a>（1）、前序遍历</h4> 
<p>仅以前序遍历为例：</p> 
<p><strong>1.确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入result来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是空，代码如下：</p> 
<pre><code class="prism language-python"><span class="token comment"># root为遍历的节点，result为存储节点的list</span>
result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre> 
<p><strong>2.确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
	<span class="token keyword">return</span>
</code></pre> 
<p><strong>3.确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</p> 
<pre><code class="prism language-python">result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">//</span> 中
traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">//</span> 左
traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">//</span> 右
</code></pre> 
<p>单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：</p> 
<pre><code class="prism language-python"><span class="token comment"># 前序遍历-递归-LC144_二叉树的前序遍历</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment"># 保存结果</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment"># 前序</span>
            traversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    <span class="token comment"># 左</span>
            traversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>   <span class="token comment"># 右</span>

        traversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="2_165"></a>（2）、中序遍历</h4> 
<p>举一反三，只需要调换一下顺序即可：</p> 
<pre><code class="prism language-python"><span class="token comment"># 中序遍历-递归-LC94_二叉树的中序遍历</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            traversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    <span class="token comment"># 左</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment"># 中序</span>
            traversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>   <span class="token comment"># 右</span>

        traversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="3_183"></a>（3）、后序遍历</h4> 
<p>举一反三，只需要调换一下顺序即可：</p> 
<pre><code class="prism language-python"><span class="token comment"># 后序遍历-递归-LC145_二叉树的后序遍历</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            traversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    <span class="token comment"># 左</span>
            traversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>   <span class="token comment"># 右</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment"># 后序</span>

        traversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<p>链表写法：</p> 
<pre><code class="prism language-python">nums <span class="token operator">=</span><span class="token string">'1 2 3 4 5 6 7'</span>
nums <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root<span class="token operator">&gt;=</span>n<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    a <span class="token operator">=</span> back<span class="token punctuation">(</span>root<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    b <span class="token operator">=</span> back<span class="token punctuation">(</span>root<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>

    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
    
back<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
res
</code></pre> 
<br> 
<h3><a id="16_223"></a>1.6、二叉树的迭代遍历</h3> 
<p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p> 
<p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p> 
<p>此时应该明白用栈也可以是实现二叉树的前后中序遍历了。</p> 
<h4><a id="1_229"></a>（1）、前序遍历</h4> 
<p>我们先看一下前序遍历。</p> 
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p> 
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p> 
<p>动画如下：<br> <img src="https://images2.imgbox.com/3d/e4/wp9F6PZ9_o.gif" alt="请添加图片描述"></p> 
<pre><code class="prism language-python"><span class="token comment"># 前序遍历-迭代-LC144_二叉树的前序遍历</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment"># 根结点为空则返回空列表</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 中结点先处理</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token comment"># 右孩子先入栈</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token comment"># 左孩子后入栈</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<p>此时会发现貌似使用迭代法写出前序遍历并不难，确实不难。</p> 
<p>此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？</p> 
<p>其实还真不行！</p> 
<p>但接下来，再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。</p> 
<h4><a id="2_267"></a>（2）、中序遍历</h4> 
<p>为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：</p> 
<p>1.处理：将元素放进result数组中<br> 2.访问：遍历节点</p> 
<p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</p> 
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p> 
<p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p> 
<p>动画如下：<br> <img src="https://images2.imgbox.com/9a/35/IOWqaqfL_o.gif" alt="请添加图片描述"><br> 中序遍历，可以写出如下代码：</p> 
<pre><code class="prism language-python"><span class="token comment"># 中序遍历-迭代-LC94_二叉树的中序遍历</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 不能提前将root结点加入stack中</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        cur <span class="token operator">=</span> root
        <span class="token keyword">while</span> cur <span class="token keyword">or</span> stack<span class="token punctuation">:</span>
            <span class="token comment"># 先迭代访问最底层的左子树结点</span>
            <span class="token keyword">if</span> cur<span class="token punctuation">:</span>     
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left		
            <span class="token comment"># 到达最左结点后处理栈顶结点    </span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>		
                cur <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token comment"># 取栈顶元素右结点</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right	
        <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="3_304"></a>（3）、后序遍历</h4> 
<p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：<br> <img src="https://images2.imgbox.com/b9/84/F30vuMEw_o.png" alt="在这里插入图片描述"><br> 所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</p> 
<pre><code class="prism language-python"><span class="token comment"># 后序遍历-迭代-LC145_二叉树的后序遍历</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 中结点先处理</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token comment"># 左孩子先入栈</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token comment"># 右孩子后入栈</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token comment"># 将最终的数组翻转</span>
        <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> 
<p><strong>总结：</strong><br> 此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p> 
<p>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</p> 
<p>上面这句话，可能一些同学不太理解，建议自己亲手用迭代法，先写出来前序，再试试能不能写出中序，就能理解了。</p> 
<p>那么问题又来了，难道 二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历 改变代码顺序就可以实现中序 和 后序）？</p> 
<p>当然可以，这种写法，还不是很好理解。</p> 
<br> 
<h3><a id="17_343"></a>1.7、二叉树的统一迭代法</h3> 
<p>前面一节无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。</p> 
<p>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</p> 
<p>如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。</p> 
<h4><a id="1_349"></a>（1）、前序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        st<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> root<span class="token punctuation">:</span>
            st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> st<span class="token punctuation">:</span>
            node <span class="token operator">=</span> st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> <span class="token comment">#右</span>
                    st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> <span class="token comment">#左</span>
                    st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment">#中</span>
                st<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="2_372"></a>（2）、中序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> root<span class="token punctuation">:</span>
            st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> st<span class="token punctuation">:</span>
            node <span class="token operator">=</span> st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> <span class="token comment">#添加右节点（空节点不入栈）</span>
                    st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                
                st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment">#添加中节点</span>
                st<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span> <span class="token comment">#中节点访问过，但是还没有处理，加入空节点做为标记。</span>
                
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> <span class="token comment">#添加左节点（空节点不入栈）</span>
                    st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment">#只有遇到空节点的时候，才将下一个节点放进结果集</span>
                node <span class="token operator">=</span> st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#重新取出栈中元素</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment">#加入到结果集</span>
        <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="3_397"></a>（3）、后序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> root<span class="token punctuation">:</span>
            st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> st<span class="token punctuation">:</span>
            node <span class="token operator">=</span> st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment">#中</span>
                st<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
                
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> <span class="token comment">#右</span>
                    st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> <span class="token comment">#左</span>
                    st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<br> 
<h3><a id="18_423"></a>1.8、二叉树的层序遍历</h3> 
<p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p> 
<p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p> 
<p>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p> 
<p>使用队列实现二叉树广度优先遍历，动画如下：<br> <img src="https://images2.imgbox.com/59/e7/gMoLZosN_o.gif" alt="请添加图片描述"><br> 递归法：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> 
            	<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> depth<span class="token punctuation">:</span> 
            	res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># start the current depth</span>
            res<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment"># fulfil the current depth</span>
            <span class="token keyword">if</span>  root<span class="token punctuation">.</span>left<span class="token punctuation">:</span> 
            	helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># process child nodes for the next depth</span>
            <span class="token keyword">if</span>  root<span class="token punctuation">.</span>right<span class="token punctuation">:</span> 
            	helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<p>迭代法：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""二叉树层序遍历迭代解法"""</span>

    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> results

        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        que <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">while</span> que<span class="token punctuation">:</span>
            size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>que<span class="token punctuation">)</span>
            result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>
                cur <span class="token operator">=</span> que<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    que<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    que<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>result<span class="token punctuation">)</span>

        <span class="token keyword">return</span> results
</code></pre> 
<br> 
<br> 
<h2><a id="_485"></a>二、经典例题</h2> 
<h3><a id="21_487"></a>2.1、前中后序遍历</h3> 
<h4><a id="144_488"></a>144.二叉树的前序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<h4><a id="94_503"></a>94.二叉树的中序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<h4><a id="145_518"></a>145.二叉树的后序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<h3><a id="22_535"></a>2.2、层序遍历</h3> 
<h4><a id="102_536"></a>102.二叉树的层序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<h4><a id="107II_553"></a>107.二叉树的层次遍历II</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrderBottom</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> 
<h4><a id="199_570"></a>199.二叉树的右视图</h4> 
<p>还是先层序遍历，取每一层list的-1值即可。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> r <span class="token keyword">in</span> res<span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="637_591"></a>637.二叉树的层平均值</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> r <span class="token keyword">in</span> res<span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token builtin">len</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> result
</code></pre> 
<h4><a id="429N_610"></a>429.N叉树的层序遍历</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">for</span> tree <span class="token keyword">in</span> cur<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                traversal<span class="token punctuation">(</span>tree<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<h4><a id="515__626"></a>515.在每个 树行中找最大值</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">largestValues</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">max</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> res<span class="token punctuation">]</span>
</code></pre> 
<h4><a id="116_643"></a>116.填充每个节点的下一个右侧节点指针</h4> 
<p>把每个节点存起来，每一层进行连接</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Optional[Node]'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">'Optional[Node]'</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> r <span class="token keyword">in</span> res<span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span>r<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
            r<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span><span class="token boolean">None</span>
        <span class="token keyword">return</span> root
</code></pre> 
<h4><a id="117II_664"></a>117.填充每个节点的下一个右侧节点指针II</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">'Node'</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">==</span>height<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>height<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

        <span class="token keyword">for</span> r <span class="token keyword">in</span> res<span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span>r<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> root
</code></pre> 
<h4><a id="104_684"></a>104.二叉树的最大深度</h4> 
<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/" rel="nofollow">104.二叉树的最大深度</a><br> 按照层序遍历模板解题：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token comment"># 叶子节点为深度</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                <span class="token keyword">nonlocal</span> res
                <span class="token comment"># 要+1，从0开始</span>
                res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<p>正规官方解法：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            left_height <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right_height <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_height<span class="token punctuation">,</span> right_height<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
</code></pre> 
<h4><a id="111_716"></a>111.二叉树的最小深度</h4> 
<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/" rel="nofollow">111.二叉树的最小深度</a></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token comment"># 叶子节点</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                <span class="token keyword">nonlocal</span> res
                res <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> height<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token number">0</span> 
</code></pre> 
<h3><a id="23_736"></a>2.3、其他类型</h3> 
<h4><a id="617_737"></a>617.合并二叉树</h4> 
<p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/" rel="nofollow">617.合并二叉树</a></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> root2<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur1<span class="token punctuation">,</span> cur2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur1 <span class="token keyword">and</span> <span class="token keyword">not</span> cur2<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> cur1 <span class="token keyword">and</span> cur2<span class="token punctuation">:</span>
                cur1<span class="token punctuation">.</span>val<span class="token operator">+=</span>cur2<span class="token punctuation">.</span>val
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur1 <span class="token keyword">and</span> cur2<span class="token punctuation">:</span>
                <span class="token keyword">return</span> cur2
            <span class="token keyword">if</span> cur1 <span class="token keyword">and</span> <span class="token keyword">not</span> cur2<span class="token punctuation">:</span>
                <span class="token keyword">return</span> cur1
            cur1<span class="token punctuation">.</span>left <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>cur2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            cur1<span class="token punctuation">.</span>right <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> cur2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">return</span> cur1
        root1 <span class="token operator">=</span> traversal<span class="token punctuation">(</span>root1<span class="token punctuation">,</span> root2<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root1
</code></pre> 
<h4><a id="105__757"></a>105. 从前序与中序遍历序列构造二叉树</h4> 
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" rel="nofollow">105. 从前序与中序遍历序列构造二叉树</a><br> 同上，寻找递归部分。<br> 前序遍历，根节点永远在头部第一个位置。<br> 中序遍历，根节点通过前序遍历去定位位置，然后左边全部打包当做左子树，右边也同样打包当做右子树。</p> 
<p>通过前序遍历寻找根节点，通过中序遍历接上前面的根节点去划分左右子树，去构造题目要求的源二叉树。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> preorder <span class="token keyword">or</span> <span class="token keyword">not</span> inorder<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            ind <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># 以根节点划分为左右两边</span>
            <span class="token comment"># 前序遍历根在第一个，去掉</span>
            <span class="token comment"># 那么左子树，前序遍历从1到ind+1，中序遍历从头到ind</span>
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> traversal<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>ind<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># 右子树，前序遍历从ind+1到结尾，中序遍历跳过中间root，为ind+1到结尾</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> traversal<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>ind<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span>ind<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> root
        <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span>
</code></pre> 
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/256711/xiong-mao-shua-ti-python3-xian-xu-zhao-gen-hua-fen/" rel="nofollow">参考1</a><br> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2202604/yi-ge-mo-ban-zuo-zhe-ge-tao-lu-by-huan-w-e5tv/" rel="nofollow">参考2</a></p> 
<h4><a id="106_783"></a>106.从中序与后序遍历序列构造二叉树</h4> 
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" rel="nofollow">106.从中序与后序遍历序列构造二叉树</a><br> 该题同上，中序还是一样，后序变成尾部为第一个根节点。其次每次划分的切片进行更改，其余步骤一样。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> inorder <span class="token keyword">or</span> <span class="token keyword">not</span> postorder<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            tree <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            index <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># 左子树，中序遍历到index，后序遍历到index</span>
            tree<span class="token punctuation">.</span>left <span class="token operator">=</span> traversal<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># 右子树，中序遍历从index+1到结尾，除掉index位置的根节点</span>
            <span class="token comment"># 后序遍历从index到-1，除掉-1位置的根节点</span>
            tree<span class="token punctuation">.</span>right <span class="token operator">=</span> traversal<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> tree
        <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_Offer_68__II__802"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" rel="nofollow">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 找不到节点，该树不含有p或q</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token comment"># 根节点为其中一个，则直接返回那个节点</span>
            <span class="token keyword">if</span> cur<span class="token operator">==</span>p <span class="token keyword">or</span> cur<span class="token operator">==</span>q<span class="token punctuation">:</span>
                <span class="token keyword">return</span> cur
            <span class="token comment"># 根据p和q在左右子树状态位置去得出答案</span>
            left <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
            right <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">and</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> left<span class="token punctuation">:</span>
                <span class="token keyword">return</span> right
            <span class="token keyword">if</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> left
            <span class="token comment"># if right and left:</span>
            <span class="token keyword">return</span> cur
        <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
</code></pre> 
<p>简写：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 合并到下面，return cur的cur也是None</span>
            <span class="token comment">#if not cur:</span>
            <span class="token comment">#    return None</span>
            
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur <span class="token keyword">or</span> cur<span class="token operator">==</span>p <span class="token keyword">or</span> cur<span class="token operator">==</span>q<span class="token punctuation">:</span>
                <span class="token keyword">return</span> cur
            
            left <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
            right <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
            <span class="token comment"># 与if not cur重复</span>
            <span class="token comment">#if not left and not right:</span>
            <span class="token comment">#    return None</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> left<span class="token punctuation">:</span>
                <span class="token keyword">return</span> right
            <span class="token keyword">if</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> left
            <span class="token keyword">return</span> cur
        <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
</code></pre> 
<p><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solutions/217281/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" rel="nofollow">参考1</a></p> 
<h4><a id="235__852"></a>235. 二叉搜索树的最近公共祖先</h4> 
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="nofollow">235. 二叉搜索树的最近公共祖先</a><br> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" rel="nofollow">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a><br> 搜索树的节点值是有序的，直接根据值去判断左右树是否有p和q，而不用继续深度遍历到该p和q节点。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>cur<span class="token punctuation">.</span>val <span class="token keyword">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>cur<span class="token punctuation">.</span>val <span class="token keyword">and</span> q<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
            <span class="token keyword">return</span> cur
        <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>root<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>
</code></pre> 
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/1663248/acm-xuan-shou-tu-jie-leetcode-by-rocky04-srcd/" rel="nofollow">参考1</a></p> 
<h4><a id="98_868"></a>98.验证二叉搜索树</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>

        <span class="token keyword">def</span> <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> lower<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> upper<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val<span class="token operator">&lt;=</span>lower <span class="token keyword">or</span> cur<span class="token punctuation">.</span>val<span class="token operator">&gt;=</span>upper<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            
            left <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            right <span class="token operator">=</span> traversal<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">,</span> upper<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">or</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> traversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
</code></pre> 
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/solutions/230256/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/" rel="nofollow">参考1</a><br> <a href="https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/" rel="nofollow">参考2</a></p> 
<h4><a id="652__888"></a>652. 寻找重复的子树</h4> 
<p><a href="https://leetcode.cn/problems/find-duplicate-subtrees/description/" rel="nofollow">652. 寻找重复的子树</a></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findDuplicateSubtrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        st <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token string">""</span>
            left <span class="token operator">=</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            cur <span class="token operator">=</span> <span class="token string">"_"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> cur <span class="token keyword">not</span> <span class="token keyword">in</span> st<span class="token punctuation">:</span>
                st<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                st<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> st<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
            <span class="token keyword">return</span> cur
        
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre> 
<h3><a id="24_914"></a>2.4、其他经典练习题</h3> 
<p><a href="https://leetcode.cn/problems/find-duplicate-subtrees/solutions/1802214/by-meteordream-02lc/" rel="nofollow"></a></p> 
<h4><a id="226_916"></a>226.翻转二叉树</h4> 
<h4><a id="101__917"></a>101. 对称二叉树</h4> 
<h4><a id="104_918"></a>104.二叉树的最大深度</h4> 
<h4><a id="111_919"></a>111.二叉树的最小深度</h4> 
<h4><a id="222_920"></a>222.完全二叉树的节点个数</h4> 
<h4><a id="110_921"></a>110.平衡二叉树</h4> 
<h4><a id="257__922"></a>257. 二叉树的所有路径</h4> 
<h4><a id="404_923"></a>404.左叶子之和</h4> 
<h4><a id="513_924"></a>513.找树左下角的值</h4> 
<h4><a id="112__925"></a>112. 路径总和</h4> 
<h4><a id="654_927"></a>654.最大二叉树</h4> 
<h4><a id="700_928"></a>700.二叉搜索树中的搜索</h4> 
<h4><a id="530_929"></a>530.二叉搜索树的最小绝对差</h4> 
<h4><a id="501_930"></a>501.二叉搜索树中的众数</h4> 
<h4><a id="236__931"></a>236. 二叉树的最近公共祖先</h4> 
<h4><a id="701_932"></a>701.二叉搜索树中的插入操作</h4> 
<h4><a id="450_933"></a>450.删除二叉搜索树中的节点</h4> 
<h4><a id="669__934"></a>669. 修剪二叉搜索树</h4> 
<h4><a id="108_935"></a>108.将有序数组转换为二叉搜索树</h4> 
<h4><a id="538_936"></a>538.把二叉搜索树转换为累加树</h4>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/63616d2b88dfe467b3358eb14c96e9d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">智能电话语音机器人：为企业营销开启新时代</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ab0f4c47c1ff001a2a969a4d46af105/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Electron 开发，报handshake failed； returned -1, SSL error code 1,错误</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>