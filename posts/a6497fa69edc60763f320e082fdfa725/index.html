<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Android】 Firebase登录、FCM、Google Play支付、adbrix、ONEStore、Galaxy Store、Google Install Referrer - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Android】 Firebase登录、FCM、Google Play支付、adbrix、ONEStore、Galaxy Store、Google Install Referrer" />
<meta property="og:description" content="Android SDK接入 最近接了一个韩国的渠道，之前没有接过这些原生的sdk，头大啊。本来也不是搞android开发的，只能强搞了。还是国内的好啊，都给你整合完了。
如有问题，麻烦大佬指教一二，非常感谢。
一.Firebase，FCM，Google Login，fb Login 这里我把Google，Firebase，Facebook相关的都放在一起了，因为这些东西有很多的关联。
以下是官方文档，推荐先看一遍。
Firebase
FCM
Google Login
Facebook Login
1.相应app的build.gradle 顶部加上
// 声明是要使用谷歌服务框架 apply plugin: &#39;com.google.gms.google-services&#39; 在 dependencies 里加上
dependencies { // ========== firebase ========== implementation &#39;com.google.firebase:firebase-auth:20.0.4&#39; // Import the Firebase BoM implementation platform(&#39;com.google.firebase:firebase-bom:28.4.2&#39;) // Declare the dependencies for the Firebase Cloud Messaging and Analytics libraries implementation &#39;com.google.firebase:firebase-analytics&#39; // When using the BoM, you don&#39;t specify versions in Firebase library dependencies implementation &#39;com.google.firebase:firebase-messaging&#39; implementation &#39;com." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a6497fa69edc60763f320e082fdfa725/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-16T16:07:16+08:00" />
<meta property="article:modified_time" content="2023-08-16T16:07:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Android】 Firebase登录、FCM、Google Play支付、adbrix、ONEStore、Galaxy Store、Google Install Referrer</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Android_SDK_0"></a>Android SDK接入</h2> 
<p>最近接了一个韩国的渠道，之前没有接过这些原生的sdk，头大啊。本来也不是搞android开发的，只能强搞了。还是国内的好啊，都给你整合完了。</p> 
<p>如有问题，麻烦大佬指教一二，非常感谢。</p> 
<h2><a id="FirebaseFCMGoogle_Loginfb_Login_5"></a>一.Firebase，FCM，Google Login，fb Login</h2> 
<p>这里我把Google，Firebase，Facebook相关的都放在一起了，因为这些东西有很多的关联。</p> 
<p>以下是官方文档，推荐先看一遍。<br> <a href="https://firebase.google.com/docs/auth/android/start?authuser=0" rel="nofollow">Firebase</a><br> <a href="https://firebase.google.com/docs/cloud-messaging/android/client" rel="nofollow">FCM</a><br> <a href="https://developers.google.com/identity/sign-in/android/start-integrating?authuser=0" rel="nofollow">Google Login</a><br> <a href="https://firebase.google.com/docs/auth/android/google-signin?authuser=0" rel="nofollow">Facebook Login</a></p> 
<h3><a id="1appbuildgradle_14"></a>1.相应app的build.gradle</h3> 
<p>顶部加上</p> 
<pre><code>// 声明是要使用谷歌服务框架
apply plugin: 'com.google.gms.google-services'
</code></pre> 
<p>在 dependencies 里加上</p> 
<pre><code> dependencies {
    // ========== firebase ==========
    implementation 'com.google.firebase:firebase-auth:20.0.4'
    // Import the Firebase BoM
    implementation platform('com.google.firebase:firebase-bom:28.4.2')
    // Declare the dependencies for the Firebase Cloud Messaging and Analytics libraries
    implementation 'com.google.firebase:firebase-analytics'
    // When using the BoM, you don't specify versions in Firebase library dependencies
    implementation 'com.google.firebase:firebase-messaging'
    implementation 'com.google.firebase:firebase-core'

    // ========== google ==========
    // google sign
    implementation 'com.google.android.gms:play-services-auth:19.0.0'
    implementation 'androidx.work:work-runtime:2.5.0'
    implementation 'com.google.android.gms:play-services-analytics-impl:17.0.0'
    // google pay
    def billing_version = "4.0.0"
    implementation "com.android.billingclient:billing:$billing_version"
    // google play
    implementation 'com.google.android.gms:play-services-location:18.0.0'

    // ========== facebook ==========
    // facebook login
    implementation 'com.facebook.android:facebook-login:9.0.0'
	......
}
</code></pre> 
<p>如果出现这个问题，请看完链接内容再继续看文档。<br> <a href="https://blog.csdn.net/zyw0101/article/details/91375106">Error: Cannot fit requested classes in a single dex file</a></p> 
<p>以下都是上面链接的内容：</p> 
<p>项目貌似有点大，已经超过65k个方法。一个dex已经装不下了，需要个多个dex，也就是multidex ，因为Android系统定义总方法数是一个short int，short int 最大值为65536。</p> 
<pre><code>android {
    defaultConfig {
        // 这里添加
        multiDexEnabled true
    }
}
dependencies {
    // 引入multidex库
    implementation 'com.android.support:multidex:1.0.3'
	
	...
	...
}
</code></pre> 
<p>在自定义的 application 中初始化 MultiDex</p> 
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    // 初始化MultiDex
    MultiDex.install(this);
}
</code></pre> 
<h3><a id="2AndroidManifestxml_79"></a>2.AndroidManifest.xml</h3> 
<pre><code>&lt;application
	...
	
    &lt;activity
		...
    &lt;/activity&gt;

    &lt;!-- =================================== facebook =================================== --&gt;
    &lt;meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/facebook_app_id"/&gt;
    
    &lt;activity android:name="com.facebook.FacebookActivity"
        android:configChanges= "keyboard|keyboardHidden|screenLayout|screenSize|orientation"
        android:label="@string/app_name" /&gt;
    &lt;activity android:name="com.facebook.CustomTabActivity" android:exported="true"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.VIEW" /&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
            &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
            &lt;data android:scheme="@string/fb_login_protocol_scheme" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
    &lt;!--
        Firebase
        Firebase Cloud Messaging
    --&gt;
    &lt;service
        android:name="com.???.AppFCMReceiver"
        tools:ignore="Instantiatable"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="com.google.firebase.MESSAGING_EVENT"/&gt;
            &lt;action android:name="com.google.firebase.INSTANCE_ID_EVENT"/&gt;
        &lt;/intent-filter&gt;
    &lt;/service&gt;

    &lt;!-- Set custom default icon. This is used when no icon is set for incoming notification messages.
         See README(https://goo.gl/l4GJaQ) for more. --&gt;
    &lt;meta-data
        android:name="com.google.firebase.messaging.default_notification_icon"
        android:resource="@mipmap/ic_launcher"/&gt;
    &lt;!-- Set color used with incoming notification messages. This is used when no color is set for the incoming
         notification message. See README(https://goo.gl/6BKBk7) for more. --&gt;
    &lt;meta-data
        android:name="com.google.firebase.messaging.default_notification_color"
        android:resource="@mipmap/ic_launcher" /&gt;
    &lt;!-- 自定义通知渠道 --&gt;
    &lt;meta-data
        android:name="com.google.firebase.messaging.default_notification_channel_id"
        android:value="@string/app_notification_channel_id" /&gt;

&lt;/application&gt;

...
...
...


&lt;!--    权限相关    --&gt;

&lt;!--    google pay    --&gt;
&lt;uses-permission android:name="com.android.vending.BILLING" /&gt;
&lt;!--    google  --&gt;
&lt;uses-permission android:name="com.google.android.gms.permission.AD_ID" /&gt;
</code></pre> 
<p>这里的AppFCMReceiver是接收FCM信息用的Java代码，下面会贴出。</p> 
<pre><code>android:name="com.???.AppFCMReceiver"
</code></pre> 
<p>其他没啥好注意的。如过怕有遗漏，最好按官方文档走一遍配置。</p> 
<h3><a id="3AppFirebase_149"></a>3.AppFirebase</h3> 
<pre><code>public class AppFirebase {
    private static final String TAG = "[AppFirebase]";
    public static ???Activity mActivity;

    // firebase
    private FirebaseAuth mAuth;
    private String mGoogleSCId = "";

    // google
    private GoogleSignInClient mGoogleSignInClient;

    // facebook
    private CallbackManager fbCallbackManager;

    public AppFirebase(???Activity m){
        mActivity = m;

        mAuth = FirebaseAuth.getInstance();

        // ======================== facebook ========================
        fbCallbackManager = CallbackManager.Factory.create();

        // ======================== google ========================
        // Configure sign-in to request the user's ID, email address, and basic
        // profile. ID and basic profile are included in DEFAULT_SIGN_IN.
        GoogleSignInOptions gso = new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
                .requestIdToken(mGoogleSCId)
                .requestEmail()
                .build();
        // Build a GoogleSignInClient with the options specified by gso.
        mGoogleSignInClient = GoogleSignIn.getClient(mActivity, gso);

        // ======================== fcm ========================
        //测试用的，正式的时候别打开
        getFCMRegisterTokenTest();

        initSDK();
    }

    //测试用的，获得当前设备的token，填到firebase的那里，就可以专门发送消息了
    private void getFCMRegisterTokenTest(){
        FirebaseMessaging.getInstance().getToken()
                .addOnCompleteListener(new OnCompleteListener&lt;String&gt;() {
                    @Override
                    public void onComplete(@NonNull Task&lt;String&gt; task) {
                        if (!task.isSuccessful()) {
                            Log.w(TAG, "Fetching FCM registration token failed", task.getException());
                            return;
                        }

                        // Get new FCM registration token
                        String token = task.getResult();

                        // Log and toast
                        Log.d(TAG, token.toString());
                        Toast.makeText(mActivity, token.toString(), Toast.LENGTH_SHORT).show();
                    }
                });
    }


    /**
     ======================================================================================
                                        Firebase Login
     ======================================================================================
     **/
    // 登录
    public void onLogin(String channel){
        // 自动登录
        if( checkFirebaseUserAuth() ){
            Log.d(TAG, "auto login!");
            firebaseGetAuthIdToken("login");
            return;
        }

        //google
        if( channel.equals("google") ){
            Log.d(TAG, "start google login");
            //启动登录，在onActivityResult方法回调
            mActivity.startActivityForResult(mGoogleSignInClient.getSignInIntent(), 1001);
            //facebook
        }else if( channel.equals("facebook") ){
            Log.d(TAG, "start facebook login");
            LoginManager.getInstance().logInWithReadPermissions(mActivity, Arrays.asList("email", "public_profile") );
        }
    }

    // google登录回调在这
    public void onActivityResult(int requestCode, int resultCode, Intent data){
        //google登录
        if (requestCode == 1001) {
            Task&lt;GoogleSignInAccount&gt; task = GoogleSignIn.getSignedInAccountFromIntent(data);
            try {
                // Google Sign In was successful, authenticate with Firebase
                GoogleSignInAccount account = task.getResult(ApiException.class);
                if (account != null) {
                    //firebase验证google登录
                    Log.d(TAG, "firebaseAuthWithGoogle:" + account.getId() );
                    firebaseAuthWithGoogle(account.getIdToken() );

                }else{ mActivity.onLoinFailed(); }
            } catch (ApiException e) {
                e.printStackTrace();
                // Google Sign In failed, update UI appropriately
                mActivity.onLoinFailed();
            }
        }

        //fb登录
        if (fbCallbackManager != null) {
            fbCallbackManager.onActivityResult(requestCode, resultCode, data);
        }
    }

    // google -&gt; firebase
    private void firebaseAuthWithGoogle(String token){
        try {
            AuthCredential credential = GoogleAuthProvider.getCredential(token, null);
            mAuth.signInWithCredential(credential)
                    .addOnCompleteListener(mActivity, new OnCompleteListener&lt;AuthResult&gt;() {
                        @Override
                        public void onComplete(@NonNull Task&lt;AuthResult&gt; task) {
                            Log.d(TAG, "");
                            if ( task.isSuccessful() ) {
                                firebaseGetAuthIdToken("login");
                            } else {
                                mActivity.onLoinFailed();
                            }
                        }
                    });

        } catch (Exception e) {
            e.printStackTrace();
            mActivity.onLoinFailed();
        }
    }

    // facebook -&gt; firebase
    private void firebaseAuthWithFacebook(String token) {
//        Log.d(TAG, "firebaseAuthWithFacebook token " + token.toString() );
        try {
            AuthCredential credential = FacebookAuthProvider.getCredential(token);
            mAuth.signInWithCredential(credential)
                    .addOnCompleteListener(mActivity, new OnCompleteListener&lt;AuthResult&gt;() {
                        @Override
                        public void onComplete(@NonNull Task&lt;AuthResult&gt; task) {
                            if ( task.isSuccessful() ) {
                                Log.d(TAG, "firebaseAuthWithFacebook onComplete " + token.toString() );
                                firebaseGetAuthIdToken("login");
                            } else { mActivity.onLoinFailed(); }
                        }
                    });
        } catch (Exception e) {
            e.printStackTrace();
            mActivity.onLoinFailed();
        }
    }

    // 获取用户唯一标识
    private void firebaseGetAuthIdToken(String behavior){
        FirebaseUser user = mAuth.getCurrentUser();
        user.getIdToken(true)
            .addOnCompleteListener(new OnCompleteListener&lt;GetTokenResult&gt;() {
                public void onComplete(@NonNull Task&lt;GetTokenResult&gt; task) {
                    if (task.isSuccessful()) {
                        String idToken = task.getResult().getToken();
                        // 登录
                        if( behavior.equals("login") ){
                            Log.d(TAG, "firebaseLogin idToken:" + idToken.toString() );
                            mActivity.onLoginSuccess(user.getUid().toString(), idToken);
                        }
                    } else {
                        Log.d(TAG, "firebas login fialed msg : " + task.toString() );
                        // 登录
                        if( behavior.equals("login") ){ mActivity.onLoinFailed(); }
                    }
                }
            });
    }

    /**
     * 检查登录状态
     * 如需要自动自动可接入，在授权登录成功后，本地会在一定期限内保存用户信息
     */
    public boolean checkFirebaseUserAuth() {
        FirebaseUser currentUser = mAuth.getCurrentUser();
        if (currentUser != null) {
            return true;
        }

        return false;
    }

    // 登出
    public void onLogout(){
        // google,facebook and so on
        FirebaseAuth.getInstance().signOut();
        // fb
        LoginManager.getInstance().logOut();
        // google
        mGoogleSignInClient.signOut();
    }

    // 删除账户
    public void onDeleteAccount(){
        if(null == mAuth){
            mActivity.onDeleteResult("failed");
            return;
        }

        FirebaseUser user = mAuth.getCurrentUser();
        if(null == user){
            mActivity.onDeleteResult("failed");
            return;
        }

        user.delete()
            .addOnCompleteListener(new OnCompleteListener&lt;Void&gt;() {
                @Override
                public void onComplete(@NonNull Task&lt;Void&gt; task) {
                    if (task.isSuccessful() ) {
                        onLogout();
                        mActivity.onDeleteResult("success");
                    }else{
                        mActivity.onDeleteResult("failed");
                    }
                }
            });
    }

    // 初始化部分功能
    private void initSDK(){
        LoginManager.getInstance().registerCallback(fbCallbackManager, new FacebookCallback&lt;LoginResult&gt;() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                //facebook授权成功，去firebase验证
                if (loginResult != null) {
                    AccessToken accessToken = loginResult.getAccessToken();
                    if (accessToken != null) {
                        String token = accessToken.getToken();
                        firebaseAuthWithFacebook(token);
                    }else{mActivity.onLoinFailed();}
                }else{mActivity.onLoinFailed();}
            }

            @Override
            public void onCancel() {
                Log.d(TAG, "facebook login failed[onCancel] ");
                mActivity.onLoinFailed();
            }

            //授权失败
            @Override
            public void onError(FacebookException error) {
                Log.d(TAG, "facebook login failed[onError] " + error.toString() );
                mActivity.onLoinFailed();
            }
        });
    }
}
</code></pre> 
<h4><a id="aFirebaseGoogleFacebook_410"></a>a.Firebase使用Google和Facebook登录</h4> 
<p>参考文章:<br> <a href="https://blog.csdn.net/hqiong208/article/details/116229383">Android_Google登录和Facebook登录并使用Firebase身份验证</a></p> 
<p>其实就是先从Google/Facebook登录之后，拿到人家的token再去Firebase登录，用Firebase的token登录自己的服务器。</p> 
<h4><a id="bgetFCMRegisterTokenTest_417"></a>b.getFCMRegisterTokenTest()</h4> 
<p>这个方法得到的token，用于在Firebase Cloud Message里用于测试消息的。把本机的token填上，然后点测试就可以直接收到信息。<br> <img src="https://images2.imgbox.com/b0/ce/sGy68x4e_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4Firebase_Cloud_Message_420"></a>4.Firebase Cloud Message</h3> 
<pre><code>public class AppFCMService extends FirebaseMessagingService {
    public static String TAG = "[AppFCMService]";

    public static ???Activity MainActivity;

    // 和token相关
    public static void checkFCMEnabled(){
        if(!MainActivity.canReceivePush){
            Log.d(TAG, "disableFCM");
            // Disable auto init
            FirebaseMessaging.getInstance().setAutoInitEnabled(false);
            new Thread(() -&gt; {
                // Remove InstanceID initiate to unsubscribe all topic
                // TODO: May be a better way to use FirebaseMessaging.getInstance().unsubscribeFromTopic()
                FirebaseMessaging.getInstance().deleteToken();
            }).start();
        }else{
            Log.d(TAG, "enableFCM");
            // Enable FCM via enable Auto-init service which generate new token and receive in FCMService
            FirebaseMessaging.getInstance().setAutoInitEnabled(true);
        }
    }

    @Override
    public void onCreate(){
        Log.d(TAG, "onCreate");
        super.onCreate();
    }

    /**
     * Called when message is received.
     *
     * @param remoteMessage Object representing the message received from Firebase Cloud Messaging.
     */
    // [START receive_message]
    @Override
    public void onMessageReceived(RemoteMessage remoteMessage) {
        Log.d(TAG, "onMessageReceived " + remoteMessage.toString() );

        super.onMessageReceived(remoteMessage);
        // [START_EXCLUDE]
        // There are two types of messages data messages and notification messages. Data messages
        // are handled
        // here in onMessageReceived whether the app is in the foreground or background. Data
        // messages are the type
        // traditionally used with GCM. Notification messages are only received here in
        // onMessageReceived when the app
        // is in the foreground. When the app is in the background an automatically generated
        // notification is displayed.
        // When the user taps on the notification they are returned to the app. Messages
        // containing both notification
        // and data payloads are treated as notification messages. The Firebase console always
        // sends notification
        // messages. For more see: https://firebase.google.com/docs/cloud-messaging/concept-options
        // [END_EXCLUDE]

        // TODO(developer): Handle FCM messages here.
        // Not getting messages here? See why this may be: https://goo.gl/39bRNJ
        Log.d(TAG, "From: " + remoteMessage.getFrom() );

        // Check if message contains a data payload.
        if (remoteMessage.getData().size() &gt; 0) {
            Log.d(TAG, "Message data payload: " + remoteMessage.getData() );

            if (/* Check if data needs to be processed by long running job */ true) {
                // For long-running tasks (10 seconds or more) use WorkManager.
//                scheduleJob();
            } else {
                // Handle message within 10 seconds
//                handleNow();
            }

        }

        // Check if message contains a notification payload.
        if (remoteMessage.getNotification() != null) {
            Log.d(TAG, "Message Notification Body: " + remoteMessage.getNotification().getBody() );
        }

        // Also if you intend on generating your own notifications as a result of a received FCM
        // message, here is where that should be initiated. See sendNotification method below.
        sendNotification( remoteMessage.getNotification() );
    }
    // [END receive_message]
    @Override
    public void onDeletedMessages() {
        super.onDeletedMessages();
    }

    @Override
    public void onMessageSent(String s) {
        super.onMessageSent(s);
    }

    @Override
    public void onSendError(String s, Exception e) {
        super.onSendError(s, e);
    }

    // [START on_new_token]
    /**
     * There are two scenarios when onNewToken is called:
     * 1) When a new token is generated on initial app startup
     * 2) Whenever an existing token is changed
     * Under #2, there are three scenarios when the existing token is changed:
     * A) App is restored to a new device
     * B) User uninstalls/reinstalls the app
     * C) User clears app data
     */
    @Override
    public void onNewToken(String token) {
        Log.d(TAG, "Refreshed token: " + token);
        super.onNewToken(token);

        AppFCMService.checkFCMEnabled();

        // If you want to send messages to this application instance or
        // manage this apps subscriptions on the server side, send the
        // FCM registration token to your app server.
        sendRegistrationToServer(token);
    }
    // [END on_new_token]

    /**
     * Schedule async work using WorkManager.
     */
    private void scheduleJob() {
        // [START dispatch_job]
//        OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(MyWorker.class)
//                .build();
//        WorkManager.getInstance(this).beginWith(work).enqueue();
        // [END dispatch_job]
    }

    /**
     * Handle time allotted to BroadcastReceivers.
     */
    private void handleNow() {
        Log.d(TAG, "Short lived task is done.");
    }

    /**
     * Persist token to third-party servers.
     *
     * Modify this method to associate the user's FCM registration token with any
     * server-side account maintained by your application.
     *
     * @param token The new token.
     */
    private void sendRegistrationToServer(String token) {
        // TODO: Implement this method to send token to your app server.
    }

    /**
     * Create and show a simple notification containing the received FCM message.
     *
     * @param message FCM message body received.
     */
    private void sendNotification(RemoteMessage.Notification message) {
        Log.d(TAG, message.toString());
        NotificationManager notificationManager = (NotificationManager) MainActivity.getSystemService(Context.NOTIFICATION_SERVICE);

        NotificationCompat.Builder builder;
        //Android8.0要求设置通知渠道
        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel("foreground", "foreground", NotificationManager.IMPORTANCE_HIGH);
            channel.setShowBadge(true); //设置是否显示角标
            //设置是否应在锁定屏幕上显示此频道的通知
            channel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);
            //设置渠道描述
            channel.setDescription("foreground");
            notificationManager.createNotificationChannel(channel);
//            createNotificationChannelGroups();
            notificationManager.createNotificationChannelGroup(new NotificationChannelGroup("foreground", "foreground"));
//            setNotificationChannelGroups(channel);
            channel.setGroup("foreground");

            builder = new NotificationCompat.Builder(this, "foreground");
        } else {
            //为了版本兼容 选择V7包下的NotificationCompat进行构造
            builder = new NotificationCompat.Builder(this);
            //setTicker 在5.0以上不显示Ticker属性信息
            builder.setTicker(message.getTicker());
        }

        if(null == builder) return;

        //setContentTitle 通知栏通知的标题
        builder.setContentTitle(message.getTitle());
        //setContentText 通知栏通知的详细内容
        builder.setContentText(message.getBody());
        //setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）
        builder.setAutoCancel(true);
        //setLargeIcon 通知消息上的大图标
        builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));
        //setSmallIcon 通知上面的小图标
        builder.setSmallIcon(R.mipmap.ic_launcher);//小图标
        //创建一个意图
        Intent intent = new Intent(this, MainActivity.getClass());
        PendingIntent pIntent = PendingIntent.getActivity(this, 1001, intent, PendingIntent.FLAG_NO_CREATE);
        //setContentIntent 将意图设置到通知上
        builder.setContentIntent(pIntent);
        builder.setWhen(System.currentTimeMillis());
        //通知默认的声音 震动 呼吸灯
        builder.setDefaults(NotificationCompat.DEFAULT_ALL);
        //构建通知
        Notification notification = builder.build();
//            notification.priority = NotificationManager.IMPORTANCE_MAX;
        //将构建好的通知添加到通知管理器中，执行通知
        notificationManager.notify(0, notification);		
	}
}
</code></pre> 
<p>参考文章：<br> <a href="https://blog.csdn.net/zhyilong/article/details/77127347">Android计入Google FireBase之消息推送</a><br> <a href="https://shoewann0402.github.io/2018/01/08/about-android-o-notification-channels/" rel="nofollow">关于 Android O 通知渠道总结</a></p> 
<p>继承 FirebaseMessagingService 并且实现相关接口。</p> 
<h4><a id="1_640"></a>1.两种通知消息</h4> 
<ul><li> <p>Notification Message 通知消息。FCM Console发送的都是这种消息也就是说</p> 
  <ul><li>当App在后台时，自动弹出到通知栏，我们无法用代码控制。</li><li>当App在前台时，不会自动弹出到通知栏，可以在 onMessageReceived() 收到数据。</li></ul> </li><li> <p>Data Message 数据消息。 不论App在前后台，都只会在 onMessageReceived() 收到数据。</p> </li></ul> 
<h4><a id="2FCM_646"></a>2.开关FCM</h4> 
<p>目前遇到了一个很棘手的问题。运营方想使用 FCM Console 来发送信息，但是FCM Console 发送的都是 Notification Message。</p> 
<ul><li>App在后台时，无法用代码控制。</li><li>FCM属于Android的Service，但是无法使用 stopSelf() 来关闭 FCM 功能。</li><li>调用 onDestory() 会导致程序崩溃。</li></ul> 
<p><strong>后来发现，App在后台时，自动弹出收到的 notification message 和 FirebaseMessagingService 是无关的。所以无论你怎么操作继承于 FirebaseMessagingService 类，都是阻止不了它弹出的。</strong></p> 
<h4><a id="3FCM__655"></a>3.FCM 到底是如何接入的？</h4> 
<p>运营商一直和我说其他开发商也是可以通过 FCM Console 发送消息的。但是 FCM Console 发送的消息属于 Notification Message ，App在后台时，应该是不可控的才对。</p> 
<h5><a id="a_658"></a>a.主题订略</h5> 
<p><a href="https://stackoverflow.com/questions/37511198/firebase-on-android-i-want-to-disable-firebase-notifications-on-android-client" rel="nofollow">Firebase on Android - I want to disable firebase notifications on Android client</a></p> 
<pre><code>    if(!canReceivePush){
        FirebaseMessaging.getInstance().subscribeToTopic(”Android");
    }else{
        FirebaseMessaging.getInstance().unsubscribeFromTopic("Android");
    }
</code></pre> 
<p>通过如上代码，以及 FCM Console 后台的操作<br> <img src="https://images2.imgbox.com/de/35/sGoOFAvb_o.png" alt="在这里插入图片描述"><br> 可以让用户只收到自己想收到的主题信息。</p> 
<p>这种方法有两个问题。</p> 
<h5><a id="btoken_673"></a>b.其实只是和token相关而已</h5> 
<p>也是醉了，害我搞了好久，还一直咨询运营那边。</p> 
<p>官方文档也没有直接告诉你，如何开关。而且它也没有什么开关的代码。并且和 服务无关，真正管理的是它的token。</p> 
<p><a href="https://stackoverflow.com/questions/43193215/firebase-cloud-messaging-handling-logout" rel="nofollow">Firebase Cloud Messaging - Handling logout</a></p> 
<pre><code>    if(关闭FCM服务){
        Log.d(TAG, "disableFCM");
        // Disable auto init
        FirebaseMessaging.getInstance().setAutoInitEnabled(false);
        new Thread(() -&gt; {
            // Remove InstanceID initiate to unsubscribe all topic
            // TODO: May be a better way to use FirebaseMessaging.getInstance().unsubscribeFromTopic()
            FirebaseMessaging.getInstance().deleteToken();
        }).start();
    }else{
        Log.d(TAG, "enableFCM");
        // Enable FCM via enable Auto-init service which generate new token and receive in FCMService
        FirebaseMessaging.getInstance().setAutoInitEnabled(true);
    }
</code></pre> 
<p>最后，非常简单。</p> 
<ul><li> <p>当我们不需要收到FCM的push时</p> <pre><code>  //关闭自动生成，不关闭会自动生成token
   FirebaseMessaging.getInstance().setAutoInitEnabled(false);
   //删除token
   FirebaseMessaging.getInstance().deleteToken();
</code></pre> </li><li> <p>需要收到FCM的push时</p> <pre><code>  //打开自动生成，然后就会自动生成 token ，自动调用 onNewToken()
   FirebaseMessaging.getInstance().setAutoInitEnabled(true);
</code></pre> </li></ul> 
<h5><a id="cFCM_708"></a>c.FCM丰富的功能（拓展部分）</h5> 
<p>FCM其实还要很多很丰富的功能，比如：</p> 
<ul><li>服务器接入他的sdk</li><li>精简的js服务端，不需要自己搞个服务器，可以直接用它的。</li><li>数据分析</li></ul> 
<p>等等。</p> 
<p><a href="https://www.cnblogs.com/ldq2016/p/5216809.html" rel="nofollow">Android service ( 一 ) 三种开启服务方法</a></p> 
<h5><a id="dFirebaseFCMhttpssegmentfaultcoma1190000018978817_718"></a>d.<a href="https://segmentfault.com/a/1190000018978817" rel="nofollow">Firebase-FCM服务端开发</a></h5> 
<p>我查略的官方文档，以及开发商给的文档。都有提及token，以及发送token。</p> 
<pre><code>/**
 * There are two scenarios when onNewToken is called:
 * 1) When a new token is generated on initial app startup
 * 2) Whenever an existing token is changed
 * Under #2, there are three scenarios when the existing token is changed:
 * A) App is restored to a new device
 * B) User uninstalls/reinstalls the app
 * C) User clears app data
 */
@Override
public void onNewToken(String token) {
    Log.d(TAG, "Refreshed token: " + token);
    super.onNewToken(token);

    // If you want to send messages to this application instance or
    // manage this apps subscriptions on the server side, send the
    // FCM registration token to your app server.
    sendRegistrationToServer(token);
}
</code></pre> 
<p>我看了源码，发现。这个token是要我们自己的服务器去收集并实现的。</p> 
<p>我们自己的服务器得实现一套用户设备token表，然后发送消息时，可以屏蔽我们不想发送的设备。</p> 
<p>目前自己还没有使用这种方法。</p> 
<h2><a id="Google_Play__747"></a>二.Google Play 支付(结算)</h2> 
<p>建议先看一遍官方文档。<br> <a href="https://developer.android.com/google/play/billing" rel="nofollow">官方文档</a><br> <a href="https://github.com/android/play-billing-samples">官方DEMO</a></p> 
<p><strong>Google Play分为游戏内购商品和订阅商品。这里只说内购商品的流程。</strong></p> 
<p>在完全不知道Google Play支付的流程下去弄，导致我白花费了很多时间。</p> 
<p>所以我们先从Google Play支付的流程开始看。</p> 
<p>参考文章：</p> 
<h3><a id="1GoogleV3AndroidUnityhttpsblogcsdnnetlinxinfaarticledetails115916000_759"></a>1.<a href="https://blog.csdn.net/linxinfa/article/details/115916000">教你接入Google谷歌支付V3版本，图文讲解（Android、Unity）</a></h3> 
<p>图来自文章中，这张图很清楚了，Google Play支付的流程图，以及该在什么地方处理<br> <img src="https://images2.imgbox.com/36/62/x2suG6l4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2Google_play_Apphttpsgiteecomqiujiayugoogleplaybillingtreemaster_762"></a>2.<a href="https://gitee.com/qiujiayu/google-play-billing/tree/master" rel="nofollow">Google play 支付流程（App内购）</a></h3> 
<p><img src="https://images2.imgbox.com/11/b3/SpfMphKC_o.png" alt="在这里插入图片描述"><br> 图来自文章。可以完全按照这个流程来接入你的Google Play支付。</p> 
<p>其他参考文章：<br> <a href="https://blog.csdn.net/sxk874890728/article/details/103764096">google计费接入，Billing结算库支付</a><br> <a href="https://juejin.cn/post/6844903902941282318" rel="nofollow">Google pay接入流程+无需真正付款</a><br> <a href="https://blog.csdn.net/ZFY11/article/details/107321635">Cocos2dx-Lua游戏接入GooglePlay SDK支付</a><br> <a href="https://www.jianshu.com/p/a53f74430cdf" rel="nofollow">Android集成Google Pay流程以及注意事项</a><br> <a href="https://www.jianshu.com/p/0375402f7a2c" rel="nofollow">Android Google应用内支付（新的集成方式）</a><br> <a href="https://www.jianshu.com/p/76416ebc0db0" rel="nofollow">Google支付和服务端验证</a></p> 
<p><strong>Google Pay 5.0</strong></p> 
<p><a href="https://www.jianshu.com/p/c19c98f10158" rel="nofollow">Google pay5.0版本接入支付和订阅功能</a><br> <a href="https://juejin.cn/post/7110434269155033118" rel="nofollow">Android Google支付接入</a></p> 
<p>部分问题QA:<br> <a href="https://blog.csdn.net/g984160547/article/details/85213947">Google Pay支付遇到的问题</a></p> 
<p>这些都文章讲的都很清楚了，接入过程不多赘述。自己遇到的坑点。</p> 
<h4><a id="1_785"></a>1.消耗以及确认订单</h4> 
<ul><li>不消耗用户就再买此商品就会提示已拥有</li><li>不确认订单三天后就会退款</li></ul> 
<p>这两个步骤请放在服务器确认并发放相应物品的通知后进行，不要在收到Google Play的回传信息时处理，否则用户可能会收不到商品，但又确实花钱了。</p> 
<h4><a id="2_790"></a>2.透传“订单号”</h4> 
<p>为了方便购买，公司的 productId 不是和In-App商品一一对应的，所以我们需要再订单内加上自己内部使用的额订单号。</p> 
<h5><a id="_792"></a>设置订单号</h5> 
<pre><code>// 购买调起时，使用 setObfuscatedAccountId() 设置咱们的订单号
 BillingResult response =
         billingClient.launchBillingFlow(
             mActivity,
             BillingFlowParams
                 .newBuilder()
                 .setSkuDetails(“Google的productId")
                 // 这里本来的意思存放用户信息，类似于国内的透传参数，我这里传的我们的订单号。
                 // 老版本使用DeveloperPayload字段，最新版本中这个字段已不可用了
                 .setObfuscatedAccountId(orderId)
                 .build()
         );
</code></pre> 
<h5><a id="_805"></a>获取订单号</h5> 
<pre><code>purchase.getAccountIdentifiers().getObfuscatedAccountId()
</code></pre> 
<h4><a id="3_808"></a>3.补单</h4> 
<p>得补单。之前一直都不需要客户端操作的，但是这次的要。。。</p> 
<pre><code>   billingClient.queryPurchasesAsync(BillingClient.SkuType.?, new PurchasesResponseListener() {
       @Override
       public void onQueryPurchasesResponse(@NonNull BillingResult billingResult, @NonNull List&lt;Purchase&gt; list) {
           if (billingResult.getResponseCode() == BillingClient.BillingResponseCode.OK &amp;&amp; list != null) {
               Log.d(TAG, "订单:" + list.size() );
               Log.d(TAG, "订单数据:\n" + list.toString() );
               for (Purchase purchase : list) {
                   // Process the result.
               }
           }
       }
   });
</code></pre> 
<p>一般都是用queryPurchasesAsync获取订单的，看到也有用的queryPurchaseHistoryAsync，但是这种获取到的purchase是没有isAcknowledged的。</p> 
<p><a href="https://stackoverflow.com/questions/48457910/querypurchases-vs-querypurchasehistoryasync-in-order-to-restore-functional" rel="nofollow">queryPurchases() vs queryPurchaseHistoryAsync() in order to ‘restore’ functionality?</a></p> 
<p>摘抄自上面的链接：</p> 
<p><em>You should use queryPurchases. That gives you all the current active (non-consumed, non-cancelled, non-expired) purchases for each SKU.</em></p> 
<p><em>queryPurchaseHistoryAsync won’t do what you need because it will only give you a list of the most recent purchases for each SKU. They may have expired, been cancelled or been consumed, and there’s no way to tell. Therefore this response can’t be used to tell what purchases to apply in your app.</em></p> 
<p><em>So far as I can see, the only valid use for queryPurchaseHistoryAsync is to provide a user with a list of their purchase history. It’s a bit of an oddball.</em></p> 
<p><em>Note also: queryPurchases is synchronous so in most cases it needs to be run in some kind of background worker thread. I run mine in an AsyncTask.</em></p> 
<p>每次登录，或者固定间隔调用一次就可以了。</p> 
<h2><a id="Adbrix_841"></a>三.Adbrix</h2> 
<p>一个用于数据收集的sdk，似乎只有韩国那边在用</p> 
<p><a href="https://help.dfinery.io/hc/en-us/articles/360003279994-Adbrix-Integration-Android-Java-" rel="nofollow">官方文档</a></p> 
<h3><a id="1Deeplink__DefferdDeeplink_846"></a>1.Deeplink 和 DefferdDeeplink</h3> 
<p><a href="http://www.woshipm.com/operate/287961.html" rel="nofollow">你知道App推广神技“Deferred Deeplink”吗?</a></p> 
<ul><li> <p>什么是Deeplink?<br> Deeplink是App应用中的深度链接，如果把App看做一个网站，那么Deeplink就是网站中的一个页面，比如产品页面，活动促销页面等。Deeplink在App市场推广运营中有很好的意义:</p> </li><li> <p>什么是Deferred Deeplink?<br> Deferred Deeplink可以看做是Deeplink的一个升级技术，可以翻译为 ”延后深度链接“。</p> <p>如果用户没有安装过推广中的App，如何使用Deeplink技术啊？用户得先去应用商店下载App，然后安装打开App, 这样Deeplink不就没有用了？</p> <p>确实如此，因此Deeplink只针对手机中已经安装过App的用户才有用。而升级版本的Deferred Deeplink却可以解决这个问题：</p> <p>Deferred Deeplink可以先判断用户是否已经安装了App应用，如果没有则先引导至App应用商店中下载App， 在用户安装App后跳转到指定App页面Deeplink中。</p> <p>使用Deeplink的广告商可以在用户点击广告后直接进入指定的Appp, 而没有使用Deeplink的App广告只能在点击后将用户跳转到App首页上。</p> </li></ul> 
<p>以上内容来自文章。</p> 
<p>这个功能不一定得接，看需求。我是没有接的。</p> 
<pre><code>public class AppAdbrix{
    private AppActivity mActivity;

    private static final String TAG = "[AppAdbrix]";

    // 找运营商要
    private static String mAppKey = "";
    private static String mSecretKey = "";

    public AppAdbrix(AppActivity m) {
        mActivity = m;
    }

    public void onCreate() {
        // ======================== adbrix ========================
        AbxActivityHelper.initializeSdk(mActivity, mAppKey, mSecretKey);

//        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {
//            mActivity.registerActivityLifecycleCallbacks(new AbxActivityLifecycleCallbacks());
//        }

        // every 120 seconds upload event data
        AdBrixRm.setEventUploadTimeInterval(AdBrixRm.AdBrixEventUploadTimeInterval.MIN);
        Log.d(TAG, "adbrix sdk version " + AdBrixRm.SDKVersion() );

        AdBrixRm.setLogListener(new AdBrixRm.LogListener() {
            @Override
            public void onPrintLog(int i, String s) {
                Log.d(TAG, "msg " + s);
            }
        });

        AdBrixRm.setLocalPushMessageListener(new AdBrixRm.onTouchLocalPushListener() {
            @Override
            public void onTouchLocalPush(String s) {
                Log.d(TAG, "local push " + s);
            }
        });
    }

    public void onActivityResumed() {
        Log.d(TAG, "resume");
        AdBrixRm.onResume(mActivity);
    }

    public void onActivityPaused() {
        Log.d(TAG, "pause");
        AdBrixRm.onPause();
    }

    public void onActivityDestroyed() {
        Log.d(TAG, "destory");
        AdBrixRm.onDestroy(mActivity);
    }

    /**
     * ==================== 数据统计 ====================
     */
    /* 基础 */
    // 登录登出
    public void onLoginAndLogout(boolean isLogin, String userId){
        if(isLogin){
            // When a user log on, send "user_1234" like the below
            Log.d(TAG, "onLoginAndLogout " + isLogin + " id " + userId);
            AdBrixRm.login(userId);
        }else{
            // When a user log out, send empty("") string
            Log.d(TAG, "onLoginAndLogout " + isLogin);
            AdBrixRm.logout();
        }
    }

    // 支付
    public void onPaySuccess(){
        if(null == goodsInfo) return;

        try {
			// 看文档
//            Log.d(TAG, "adbrix on purchase");
        }catch (JSONException e){
            e.printStackTrace();
        }
    }

    /* 其他检测点 */
    // 完成新手引导
    public void onTutorialCompletion(){	
        try {
        	// 看文档
            AdBrixRm.AttrModel gameAttr = new AdBrixRm.AttrModel()
                    .setAttrs("xx", "");
                    
            AdBrixRm.GameProperties.TutorialComplete gameProperties
                    = new AdBrixRm.GameProperties.TutorialComplete()
                    .setIsSkip(false)
                    .setAttrModel(gameAttr);

            // Tutorial complete API
            AdBrixRm.Game.tutorialComplete(gameProperties);
        }catch (JSONException e){
            e.printStackTrace();
        }
    }

    // 角色生成
    public void onCharacterCreation(){
    	// 看文档
        AdBrixRm.AttrModel gameAttr = new AdBrixRm.AttrModel().setAttrs("xx", xx);

        AdBrixRm.GameProperties.CharacterCreated gameProperties
                = new AdBrixRm.GameProperties.CharacterCreated()
                                             .setAttrModel(gameAttr);

        // Create character API
        AdBrixRm.Game.characterCreated(gameProperties);

//        Log.d(TAG, "adbrix on character creation");
    }

    //角色升级
    public void onLevelUp(){

        try {
        	// 看文档
            int level = Integer.valueOf( json.getString("level") );
            AdBrixRm.AttrModel gameAttr = new AdBrixRm.AttrModel().setAttrs("uid", json.getString("uid") );

            AdBrixRm.GameProperties.LevelAchieved gameProperties
                    = new AdBrixRm.GameProperties.LevelAchieved()
                    .setLevel(level)
                    .setAttrModel(gameAttr);

            // Level Acheived API
            AdBrixRm.Game.levelAchieved(gameProperties);

        }catch (JSONException e){
            e.printStackTrace();
        }
    }
}
</code></pre> 
<ul><li>一些具体的传输数据我没有填，这些都好找，直接看官方文档即可。</li><li>一些比如，充值，角色创建，升级，有专门的API，不用写事件名称。</li></ul> 
<h4><a id="_1011"></a>唯一坑到我的点</h4> 
<pre><code>// 以下是官方文档的示例
if (Build.VERSION.SDK_INT &gt;= 14) {
     registerActivityLifecycleCallbacks(this);
 }
// 以下为我实际使用时，可以通过studio检测的代码
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {
    mActivity.registerActivityLifecycleCallbacks(new AbxActivityLifecycleCallbacks());
}
</code></pre> 
<p>不知道是我的问题，还是官方文档的错误，要求的最低Android版本差了十几版本。<br> 并且执行代码的时候，都顺利通过，并且Logcat啥也没输出，我都不知道到底是什么问题。</p> 
<p>上面的代码，作用就是注册生命周期的回调的时候，调用如下代码即可。</p> 
<p><em>If you are using your own ActivityLifecycleCallback please add following code on “onActivityResumed” , “onActivityPaused”, “onActivityDestroyed”.</em><br> <img src="https://images2.imgbox.com/4d/fd/goBZbBSf_o.png" alt="在这里插入图片描述"><br> 所以，直接在主Activity的这三个生命周期的函数里调用一下就可以了。</p> 
<pre><code>public void onActivityResumed() {
    Log.d(TAG, "resume");
    AdBrixRm.onResume(mActivity);
}

public void onActivityPaused() {
    Log.d(TAG, "pause");
    AdBrixRm.onPause();
}

public void onActivityDestroyed() {
    Log.d(TAG, "destory");
    AdBrixRm.onDestroy(mActivity);
}
</code></pre> 
<p>弄完这个问题项目就正常了，后台也能收到数据了。会有些延迟，过个几分钟看看后台吧。</p> 
<h2><a id="ONEStoreONEStore_1047"></a>四.ONEStore(ONE-Store)</h2> 
<p><a href="https://dev.onestore.co.kr/wiki/ko/doc/%5B%E4%B8%AD%E6%96%87%5D%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/one-store-in-appapi-v6-sdk-v19/one-store-in-app" rel="nofollow">官方文档</a></p> 
<p>ONE-store和Google其实差不多。但是因为ONE-store会自动推送信息给服务端，其实我们是不需要补单的。</p> 
<h3><a id="ONEstoreGoogle_1052"></a>看完ONE-store的官方文档后，重新理解了一遍Google。</h3> 
<p>Google和ONE-store都有消耗型商品和非消耗型商品。</p> 
<ul><li>消耗型商品，需要使用 consumexxx 这种名称的方法进行消耗；</li><li>非消耗型商品，需要使用 acknowledgexxx 这种名称的方法；</li></ul> 
<p>这两种商品，不走下一步，那么会都是坏单，过一段时间应该都会退回费用。</p> 
<p>然而我们怎么判断一个单子是否处理过了呢？用如下代码判断。</p> 
<pre><code>x.isAcknowledged()
// 这个acknowledged，是和非消耗型商品的acknowledge无关的
// 消耗型商品调用 consumeXXX					----&gt; isAcknowledged() 为 true	
// 非消耗型商品调用 acknowledgeXXX			----&gt; isAcknowledged() 为 true	
</code></pre> 
<h3><a id="_1068"></a>透传"订单号"</h3> 
<p>好像就是老版的谷歌</p> 
<h6><a id="_1070"></a>设置订单号</h6> 
<pre><code>PurchaseFlowParams params = PurchaseFlowParams.newBuilder()
        .setProductId(productId)
        .setProductType(ProductType.INAPP)
        .setDeveloperPayload(orderId)
        .build();
</code></pre> 
<h6><a id="_1076"></a>获取订单号</h6> 
<pre><code>purchase.getDeveloperPayload()
</code></pre> 
<h3><a id="PS_1078"></a>PS</h3> 
<p>测的时候，先把ONE-store打开一次，可以正常连上再测试。</p> 
<p>可能是ONE-store App的原因。之前测试的时候，如果不打开一次，那么就会一直连不上ONE-store的服务器，一直报 error code 3</p> 
<h2><a id="Galaxy_StoreSamsung_1083"></a>五.Galaxy Store(Samsung)</h2> 
<p><a href="https://developer.samsung.com/iap/programming-guide/iap-helper-programming.html?lang=zh" rel="nofollow">官方文档</a></p> 
<p><strong>参考文章</strong><br> <a href="https://blog.csdn.net/bai_tt/article/details/109082504">韩国渠道接入三星支付（Android 接入 Samsung in app purchase）</a></p> 
<p>其实和ONE-store一样，还是蛮好接入的，并且都有自己的文档。</p> 
<h3><a id="1IAP6Helper_module__1091"></a>1.IAP6Helper module 无法导入</h3> 
<p>Samsung还是和上面两个挺不一样的。</p> 
<ol><li>下载它的demo</li><li>导入IAP6Helper module<br> <img src="https://images2.imgbox.com/94/c3/yO650Pcl_o.png" alt="在这里插入图片描述"></li><li>添加依赖<img src="https://images2.imgbox.com/e0/45/zZtoDatg_o.png" alt="在这里插入图片描述"><br> 不知道为什么，我添加不进来。。。</li></ol> 
<p>只好走另一个不安全的方法。在settings.gradle里增加工程</p> 
<pre><code>//samsung lib
include ':IAP6Helper'
project(':IAP6Helper').projectDir = new File(settingsDir, 'app/IAP6Helper')
</code></pre> 
<p>然后继续第三步。</p> 
<h3><a id="2_1107"></a>2.无法测试</h3> 
<p>接是接完了，但是无法测试。</p> 
<ol><li>测试机是荣耀，安装Galaxy Store后，本地区/国家不支持。</li><li>模拟器，雷电模拟器，修改了定位和使用adb设置了一些android的属性，也不行。</li></ol> 
<p>学习了一波如何修改Andorid的prop</p> 
<h4><a id="android_1115"></a>修改android的地区码</h4> 
<p>Android内提供了一些prop基础配置<br> 因为Galaxy Store锁区了，所以修改Android的属性数据，来让我们可以进入。</p> 
<p><strong>用的是雷电模拟器</strong></p> 
<p><a href="https://www.jianshu.com/p/d6a19c36df54" rel="nofollow">adb连接雷电模拟器失败</a><br> <a href="https://www.jianshu.com/p/3b4d012165d5" rel="nofollow">adb 如何连接多个设备</a><br> <a href="https://www.cnblogs.com/xbxblog/p/9777397.html" rel="nofollow">adb connect命令连接多个Android设备</a></p> 
<p><a href="https://www.orcode.com/question/611536_ka5b72.html" rel="nofollow">如何更改Android模拟器中的移动国家/地区代码（MCC）？</a><br> <a href="https://blog.csdn.net/sinat_36184075/article/details/80752386">【SIM】MCC(移动国家码)和 MNC(移动网络码)</a></p> 
<p><a href="https://blog.csdn.net/jieffantfyan/article/details/78217736">运营商MCC，MNC大全</a></p> 
<ol><li> <p>雷电模拟器自带了adb，用那个，然后</p> <pre><code> // 已连接会提示已连接
 "./adb" connect 127.0.0.1:5555
</code></pre> </li><li> <p>查看设备</p> <pre><code> C:\Users\????&gt;adb devices
 List of devices attached
 emulator-1111  device
 127.0.0.1:30054 device
</code></pre> </li><li> <p>连接设备，使用它的shell</p> <pre><code> 如果是IP就用IP，设备名称就用设备名称
 adb connect 127.0.0.1:30054
 adb connect emulator-1111
</code></pre> </li><li> <p>查看有哪些prop</p> <pre><code> getprop

 // 会显示如下数据
 ...
 [gsm.network.type]: [LTE]
 [gsm.nitz.time]: [1524141151210]
 [gsm.operator.alpha]: [Android]
 [gsm.operator.iso-country]: [us]
 [gsm.operator.isroaming]: [false]
 [gsm.operator.numeric]: [310260]
 [gsm.sim.operator.alpha]: [Android]
 [gsm.sim.operator.iso-country]: [us]
 [gsm.sim.operator.numeric]: [310260]
 [gsm.sim.state]: [READY]
 [gsm.version.baseband]: [1.0.0.0]
 [gsm.version.ril-impl]: [android reference-ril 1.0]
 ...
</code></pre> </li><li> <p>修改MCC，MNC<br> <img src="https://images2.imgbox.com/9f/af/hjFPpC6H_o.png" alt="在这里插入图片描述"><br> MCC(移动国家码)和 MNC(移动网络码)</p> <pre><code> 比如韩国的：
 MCC是450
 MNC是02-08
 所以他是 45002-45008
 
 // setprop &lt;property name&gt; &lt;new MCC MNC&gt;
 setprop gsm.operator.numeric 45002
 
 // 韩国的缩写是KR，语言是ko
 // 比如咱们是zh-CN，韩国就是ko-KR
 setprop gsm.operator.iso-country KR
</code></pre> </li></ol> 
<h4><a id="_1182"></a>还是得用三星的手机测试才行，其他牌子的手机真不好测。</h4> 
<h3><a id="3_1184"></a>3.代码</h3> 
<p>Galaxy Store的代码相对较少</p> 
<pre><code>    public static String TAG = "xxx";

    private AppActivity mActivity;
    private IapHelper mHelper;

    public AppSamsungPay(AppActivity m){
        mActivity = m;
        mHelper = IapHelper.getInstance(mActivity);

//        mHelper.setOperationMode(HelperDefine.OperationMode.OPERATION_MODE_PRODUCTION)//正式模式
//        mHelper.setOperationMode(HelperDefine.OperationMode.OPERATION_MODE_TEST_FAILURE);//失败模式
        mHelper.setOperationMode(HelperDefine.OperationMode.OPERATION_MODE_TEST);//测试模式
    }

    // 开始购买
    public void onPay(String productId, String orderId){
        //productId为商品id,  orderId为透传字段， false为是否显示dialog
        // orderId里是我需要传的，你自己要传啥问服务端
        mHelper.startPayment(productId, orderId, new OnPaymentListener() {
            @Override
            public void onPayment(ErrorVo _errorVO, PurchaseVo _purchaseVO) {
                if( _errorVO == null) {
                  	// 购买失败调用
                    return;
                }

                //购买成功
                if (_errorVO.getErrorCode() == IapHelper.IAP_ERROR_NONE) {
                    // 购买成功调用
                //购买失败
                }else {
                  // 购买失败调用
              	}

            }
        });
    }

    // 购买完成后的处理(消耗商品)
    public void onConsumePurchase(String purchaseId, String originalJson){
        mHelper.consumePurchasedItems(purchaseId, new OnConsumePurchasedItemsListener() {
            @Override
            public void onConsumePurchasedItems(ErrorVo errorVo, ArrayList&lt;ConsumeVo&gt; arrayList) {
                if(errorVo == null ) {
                    //消耗失败调用
                    return;
                }

                //消耗成功
                if(errorVo.getErrorCode() == IapHelper.IAP_ERROR_NONE){
                    //消耗成功调用
                //消耗失败
                }else{
                	//消耗失败调用
                }
            }
        });
    }

    //补单
    public void onCheckPurchase(){
        mHelper.getOwnedList(IapHelper.PRODUCT_TYPE_ALL, new OnGetOwnedListListener() {
            @Override
            public void onGetOwnedProducts(ErrorVo errorVo, ArrayList&lt;OwnedProductVo&gt; ownedList) {
                if( errorVo == null){
                    //
                    return;
                }

                if (errorVo.getErrorCode() != IapHelper.IAP_ERROR_NONE
                || ownedList == null || ownedList.size() &lt;= 0){
                    //
                    return;
                }

                for (int i = 0; i &lt; ownedList.size(); i++) {
                    OwnedProductVo product = ownedList.get(i);
                    //未消耗（确认）的商品
                    if( product.getIsConsumable() ){
						...
                    }
                }
            }
        });
    }
</code></pre> 
<h3><a id="_1273"></a>透传"订单号"</h3> 
<pre><code>设置透传参数上面已经有写了，这里就写如何获得
product.getPassThroughParam()
</code></pre> 
<h2><a id="Google_installreferrer_1277"></a>六.Google installreferrer</h2> 
<p><a href="https://blog.csdn.net/yangxuan0261/article/details/107524176">android-GooglePlay安装来源追踪PlayInstallReferrer</a></p> 
<pre><code>public class XXXXX{
    public static String TAG = "[XXXXXX]";

    private static final String KEY_UDID = "KEY_UDID";
    private String uuid;

    private AppActivity mActivity;
    private InstallReferrerClient  mReferrerClient;
    private boolean mIsLink = false;

    private String sendUrl = "http://???.php";

    public XXXXXXX(AppActivity m){
        mActivity = m;
        //install refrerrer
        mReferrerClient = InstallReferrerClient.newBuilder(mActivity).build();
    }

    // mReferrerClient 连接到 google play store
    public void link2GooglePlayStore(){
        mReferrerClient.startConnection(new InstallReferrerStateListener() {
            @Override
            public void onInstallReferrerSetupFinished(int responseCode) {
                switch (responseCode) {
                    case InstallReferrerClient.InstallReferrerResponse.OK:
                        // Connection established.
                        Log.d(TAG, "Connection established");
                        mIsLink = true;
                        new Thread(new Runnable(){
                            @Override
                            public void run() {
                                try {
                                    sendInstallReferrerInfo();
                                } catch (RemoteException e) {
                                    e.printStackTrace();
                                }
                            }
                        }).start();
                        break;
                    case InstallReferrerClient.InstallReferrerResponse.FEATURE_NOT_SUPPORTED:
                        // API not available on the current Play Store app.
                        Log.d(TAG, "API not available on the current Play Store app.");
                        stopLink();
                        break;
                    case InstallReferrerClient.InstallReferrerResponse.SERVICE_UNAVAILABLE:
                        // Connection couldn't be established.
                        Log.d(TAG, "Connection couldn't be established.");
                        stopLink();
                        break;
                }
            }

            @Override
            public void onInstallReferrerServiceDisconnected() {
                stopLink();
                // Try to restart the connection on the next request to
                // Google Play by calling the startConnection() method.
            }
        });
    }

    public void testSend(){
        new Thread(new Runnable(){
            @Override
            public void run() {
                try {
                    sendInstallReferrerInfo();
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    // 获取设备信息
    // 从安装引荐来源获取详细信息
    public void sendInstallReferrerInfo() throws RemoteException {
        if(null == mReferrerClient){
            Log.d(TAG, "InstallReferrerClient is not exist.");
            return;
        }

        if(mIsLink == false){
            Log.d(TAG, "InstallReferrerClient is not link.");
            return;
        }

        ReferrerDetails response = mReferrerClient.getInstallReferrer();
//        String referrerUrl = response.getInstallReferrer();
//        long referrerClickTime = response.getReferrerClickTimestampSeconds();
//        long appInstallTime = response.getInstallBeginTimestampSeconds();
//        boolean instantExperienceLaunched = response.getGooglePlayInstantParam();

        try {
            URL url = new URL(sendUrl);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setDoInput(true);
            connection.setUseCaches(false);
            connection.setRequestProperty("Content-Type", "application/json;charset=utf-8");
            connection.connect();

            JsonData jdata = new JsonData();
            // 一般是要这个数据
            jdata.addKV("xxx", response.getInstallReferrer() );
  			// getUniqueDeviceId() 看下面的文章里
            jdata.addKV("deviceId", getUniqueDeviceId() );

            String body = jdata.toString();
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(connection.getOutputStream(), "UTF-8"));
            writer.write(body);
            writer.close();

            int responseCode = connection.getResponseCode();
            if(responseCode == HttpURLConnection.HTTP_OK){
                InputStream inputStream = connection.getInputStream();
//                Log.d(TAG, "inputStream " + inputStream.toString() );
            }
            Log.d(TAG, "sendInstallReferrerInfo success");
        } catch (Exception e) {
            Log.d(TAG, "sendInstallReferrerInfo faild");
            e.printStackTrace();
        }
    }

    // 断开链接
    public void stopLink(){
        mIsLink = false;
        mReferrerClient.endConnection();
    }
</code></pre> 
<h3><a id="1Android_http_1412"></a>1.Android 发送http请求</h3> 
<p><a href="https://blog.csdn.net/xiaoanzi123/article/details/106926188">HttpUrlConnection使用详解</a><br> 上面的网络代码就是从这里找到的，里面很全，不只有 POST 的</p> 
<p><a href="https://blog.csdn.net/qq_29477223/article/details/81027716">[Android开发错误解决]解决android.os.NetworkOnMainThreadException</a><br> <em>在Android 4.0以上，网络连接不能放在主线程上，不然就会报错android.os.NetworkOnMainThreadException。但是4.0下版本可以不会报错。</em></p> 
<p>所以记得，发送请求时，不能直接发送，要新开一个线程。</p> 
<pre><code>new Thread(new Runnable(){
    @Override
    public void run() {
        try {
            //发送网络请求
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
}).start();
</code></pre> 
<h3><a id="2Android_DeviceID_1432"></a>2.获取Android DeviceID</h3> 
<p>我记录在了这里：</p> 
<p><a href="https://blog.csdn.net/qq_28686039/article/details/124454744">【Android】开发 需求&amp;&amp;问题 记录</a></p> 
<h2><a id="_1438"></a>七.一些其他问题记录</h2> 
<ul><li><a href="https://blog.csdn.net/lepaitianshi/article/details/81127345">Facebook KeyHash生成方法</a><br> 这是facebook登录要</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa1178665c61a9bf1eb127fe13bd6430/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows无盘启动技术开发之使用本地镜像文件启动电脑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/22f6a500d79285a1834492222800f0d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql cdc 整库迁移 (mysql to mysql)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>