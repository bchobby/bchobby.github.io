<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C函数调用过程解析(x86-64 ) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C函数调用过程解析(x86-64 )" />
<meta property="og:description" content="C函数调用过程解析(x86-64 ) 函数栈保存了一个函数调用所需的维护信息，一般包括： - 函数的参数和返回值 - 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 - 保存的上下文：包括在函数调用前后需要保持不变的寄存器
下图显示了，在Linux操作系统中一个进程的虚拟地址布局（本图来自 《深入理解计算机系统》），从图中可以看出，栈总是向下增长的， 在x86-64下， 栈顶由栈顶寄存器rsp 进行定位。 栈底有基址寄存器rbp进行定位， 也就是说一个函数的整个活动过程由这两个寄存器划定范围。
1，代码示例： #include &lt;stdio.h&gt; int add(int a, int b) { int c = a &#43; b; return c; } void strcopy(char * dst, char * src){ } int main(int argc, char *argv[]) { int tmp = 10; int tmp1 = 11; char str1[60]; char str2[100]; strcopy(str2, str1); int result = add(2, 3); printf(&#34;result=%d\n&#34;, result); return 0; } 2， 函数调用过程 （x86-64） 编译：gcc -m64 -o test test." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a667e3f32f7e8b16add9095ed10af0e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-12T17:41:47+08:00" />
<meta property="article:modified_time" content="2017-05-12T17:41:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C函数调用过程解析(x86-64 )</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="c函数调用过程解析x86-64">C函数调用过程解析(x86-64 )</h2> 
<p>函数栈保存了一个函数调用所需的维护信息，一般包括： <br> - <strong>函数的参数和返回值</strong> <br> - <strong>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</strong> <br> - <strong>保存的上下文：包括在函数调用前后需要保持不变的寄存器</strong></p> 
<p>下图显示了，在Linux操作系统中一个进程的虚拟地址布局（本图来自 《深入理解计算机系统》），从图中可以看出，栈总是向下增长的， 在x86-64下， 栈顶由栈顶寄存器rsp 进行定位。 栈底有基址寄存器rbp进行定位， 也就是说一个函数的整个活动过程由这两个寄存器划定范围。</p> 
<p><img src="https://images2.imgbox.com/35/3b/WHoWk31W_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="1代码示例">1，代码示例：</h3> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-keyword">int</span> add(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
    <span class="hljs-keyword">int</span> c = a + b;
    <span class="hljs-keyword">return</span> c;
}
<span class="hljs-keyword">void</span> strcopy(<span class="hljs-keyword">char</span> * dst, <span class="hljs-keyword">char</span> * src){
}
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) {
    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> tmp1 = <span class="hljs-number">11</span>;
    <span class="hljs-keyword">char</span>   str1[<span class="hljs-number">60</span>];
    <span class="hljs-keyword">char</span>   str2[<span class="hljs-number">100</span>];

    strcopy(str2, str1);

    <span class="hljs-keyword">int</span> result = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"result=%d\n"</span>, result);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
<h3 id="2-函数调用过程-x86-64">2， 函数调用过程 （x86-64）</h3> 
<p>编译：gcc -m64 -o test test.c <br> 生成汇编：gcc -m64 -S test.c //熟悉INTEL汇编指令格式的，可以指定汇编代码格式 -masm=intel <br> 反汇编 ： objdump -d test &gt; test.dump</p> 
<pre class="prettyprint"><code class="language-assembly hljs avrasm">gdb ./test
(gdb) info b                     <span class="hljs-comment">;将断点设在 _start, 这是程序真正的入口</span>
Num     Type           Disp Enb Address            What
<span class="hljs-number">1</span>       breakpoint     keep <span class="hljs-built_in">y</span>   <span class="hljs-number">0x0000000000400450</span> ../sysdeps/x86_64/elf/start<span class="hljs-preprocessor">.S</span>:<span class="hljs-number">65</span>

(gdb) <span class="hljs-keyword">set</span> disassemble-next-line on  ；打开汇编指令开关， 交替使用n  ni 进行调试

(gdb) info reg 
rax            <span class="hljs-number">0x1c</span> <span class="hljs-number">28</span>                          ；
rbx            <span class="hljs-number">0x0</span>  <span class="hljs-number">0</span>
rcx            <span class="hljs-number">0x7fffffffe1f8</span>   <span class="hljs-number">140737488347640</span>
rdx            <span class="hljs-number">0x7ffff7deb680</span>   <span class="hljs-number">140737351956096</span>
rsi            <span class="hljs-number">0x7ffff7df698f</span>   <span class="hljs-number">140737352001935</span>
rdi            <span class="hljs-number">0x7ffff7ffe208</span>   <span class="hljs-number">140737354129928</span>
rbp            <span class="hljs-number">0x0</span>  <span class="hljs-number">0x0</span>                         ；程序未开始，基址寄存器为<span class="hljs-number">0</span>
rsp            <span class="hljs-number">0x7fffffffe1e0</span>   <span class="hljs-number">0x7fffffffe1e0</span>  ；栈顶寄存器初始值 
<span class="hljs-built_in">r8</span>             <span class="hljs-number">0xb</span>  <span class="hljs-number">11</span>
<span class="hljs-built_in">r9</span>             <span class="hljs-number">0x3</span>  <span class="hljs-number">3</span>
<span class="hljs-built_in">r10</span>            <span class="hljs-number">0x2</span>  <span class="hljs-number">2</span>
<span class="hljs-built_in">r11</span>            <span class="hljs-number">0xd</span>  <span class="hljs-number">13</span>
<span class="hljs-built_in">r12</span>            <span class="hljs-number">0x400450</span> <span class="hljs-number">4195408</span>
<span class="hljs-built_in">r13</span>            <span class="hljs-number">0x7fffffffe1e0</span>   <span class="hljs-number">140737488347616</span>
<span class="hljs-built_in">r14</span>            <span class="hljs-number">0x0</span>  <span class="hljs-number">0</span>
<span class="hljs-built_in">r15</span>            <span class="hljs-number">0x0</span>  <span class="hljs-number">0</span>
rip            <span class="hljs-number">0x400450</span> <span class="hljs-number">0x400450</span> &lt;_start&gt;    ；此时指令寄存器指向_start 开始位置
eflags         <span class="hljs-number">0x202</span>    [ IF ]
cs             <span class="hljs-number">0xe033</span>   <span class="hljs-number">57395</span>
ss             <span class="hljs-number">0xe02b</span>   <span class="hljs-number">57387</span>
ds             <span class="hljs-number">0x0</span>  <span class="hljs-number">0</span>
es             <span class="hljs-number">0x0</span>  <span class="hljs-number">0</span>
fs             <span class="hljs-number">0x0</span>  <span class="hljs-number">0</span>
gs             <span class="hljs-number">0x0</span>  <span class="hljs-number">0</span>
</code></pre> 
<pre class="prettyprint"><code class="language-assembly hljs perl">(gdb) display /i <span class="hljs-variable">$pc</span>     ;用display关注<span class="hljs-variable">$pc</span> 的内容变化， <span class="hljs-variable">$pc</span>为GDB内部变量相当于指令寄存器rip  
(gdb) display <span class="hljs-variable">$rsp</span>       ；利用display关注 <span class="hljs-variable">$rsp</span>  的内容变化
(gdb) display  <span class="hljs-variable">*(</span>char<span class="hljs-variable">*)</span><span class="hljs-variable">$rsp</span>
(gdb) display  <span class="hljs-variable">*(</span>short<span class="hljs-variable">*)</span><span class="hljs-variable">$rsp</span>
(gdb) display  <span class="hljs-variable">*(</span><span class="hljs-keyword">int</span> <span class="hljs-variable">*)</span><span class="hljs-variable">$rsp</span>
</code></pre> 
<pre class="prettyprint"><code class="language-assembly hljs perl">(gdb) disas _start
Dump of assembler code <span class="hljs-keyword">for</span> function _start:
   <span class="hljs-number">0x0000000000400450</span> &lt;+<span class="hljs-number">0</span>&gt;: <span class="hljs-keyword">xor</span>    <span class="hljs-variable">%ebp</span>,<span class="hljs-variable">%ebp</span>  ;异或操作用于清零 ebp=<span class="hljs-number">0</span>
   <span class="hljs-number">0x0000000000400452</span> &lt;+<span class="hljs-number">2</span>&gt;: mov    <span class="hljs-variable">%rdx</span>,<span class="hljs-variable">%r9</span>   ;数据寄存器rdx 内容存入 r9
   <span class="hljs-number">0x0000000000400455</span> &lt;+<span class="hljs-number">5</span>&gt;: <span class="hljs-keyword">pop</span>    <span class="hljs-variable">%rsi</span>       ;rsi=<span class="hljs-number">1</span>  rsp=rsp+<span class="hljs-number">8</span> = <span class="hljs-number">0x7fffffffe1e8</span>
   <span class="hljs-number">0x0000000000400456</span> &lt;+<span class="hljs-number">6</span>&gt;: mov    <span class="hljs-variable">%rsp</span>,<span class="hljs-variable">%rdx</span>  ;将rsp 暂存入 rdx
   <span class="hljs-number">0x0000000000400459</span> &lt;+<span class="hljs-number">9</span>&gt;: <span class="hljs-keyword">and</span>    <span class="hljs-variable">$0</span>xfffffffffffffff<span class="hljs-number">0</span>,<span class="hljs-variable">%rsp</span> ；与操作 使 rsp 按照<span class="hljs-number">16</span>字节对齐  rsp= <span class="hljs-number">0x7fffffffe1e0</span>   note1
   <span class="hljs-number">0x000000000040045d</span> &lt;+<span class="hljs-number">13</span>&gt;:    <span class="hljs-keyword">push</span>   <span class="hljs-variable">%rax</span>   ;rax 进栈，rsp-<span class="hljs-number">8</span> = <span class="hljs-number">0x7fffffffe1d8</span>  （rsp）=<span class="hljs-number">28</span>
   <span class="hljs-number">0x000000000040045e</span> &lt;+<span class="hljs-number">14</span>&gt;:    <span class="hljs-keyword">push</span>   <span class="hljs-variable">%rsp</span>   ;rsp 进栈 保存原栈顶位置  rsp-<span class="hljs-number">8</span>=<span class="hljs-number">0x7fffffffe1d0</span>
   <span class="hljs-number">0x000000000040045f</span> &lt;+<span class="hljs-number">15</span>&gt;:    mov    <span class="hljs-variable">$0</span>x4005a<span class="hljs-number">0</span>,<span class="hljs-variable">%r8</span> ;nm 可见， <span class="hljs-number">0x4005a0</span> 为 __libc_csu_fini会调用_fini，它是留给程序结束时用的
   <span class="hljs-number">0x0000000000400466</span> &lt;+<span class="hljs-number">22</span>&gt;:    mov    <span class="hljs-variable">$0</span>x4005b<span class="hljs-number">0</span>,<span class="hljs-variable">%rcx</span> ;<span class="hljs-number">0x4005b0</span> 为 __libc_csu_init会调用_init
   <span class="hljs-number">0x000000000040046d</span> &lt;+<span class="hljs-number">29</span>&gt;:    mov    <span class="hljs-variable">$0</span>x400556,<span class="hljs-variable">%rdi</span> ;<span class="hljs-number">0x400556</span> 为 main 函数 入口地址
   <span class="hljs-number">0x0000000000400474</span> &lt;+<span class="hljs-number">36</span>&gt;:    callq  <span class="hljs-number">0x400440</span> &lt;__libc_start_main<span class="hljs-variable">@plt</span>&gt; ； 以上三个参数 从右到左 分别存在  r8，rcx，rdi    __libc_start_main 内部不再继续展开
   <span class="hljs-number">0x0000000000400479</span> &lt;+<span class="hljs-number">41</span>&gt;:    hlt    ;使程序停止运行，处理器进入暂停状态，不执行任何操作，不影响标志
   <span class="hljs-number">0x000000000040047a</span> &lt;+<span class="hljs-number">42</span>&gt;:    xchg   <span class="hljs-variable">%ax</span>,<span class="hljs-variable">%ax</span>  ;相当于nop， 空操作
End of assembler <span class="hljs-keyword">dump</span>.
</code></pre> 
<pre class="prettyprint"><code class="language-assembly hljs mel">(gdb) disas main
Dump of assembler code <span class="hljs-keyword">for</span> function main:
   <span class="hljs-number">0x0000000000400564</span> &lt;+<span class="hljs-number">0</span>&gt;: push   <span class="hljs-variable">%rbp</span>             ；上层函数基址入栈
   <span class="hljs-number">0x0000000000400565</span> &lt;+<span class="hljs-number">1</span>&gt;: mov    <span class="hljs-variable">%rsp</span>,<span class="hljs-variable">%rbp</span>            ；将当前栈顶作为main函数的基址  （rsp=rbp=<span class="hljs-number">0x7fffffffe110</span>）
   <span class="hljs-number">0x0000000000400568</span> &lt;+<span class="hljs-number">4</span>&gt;: sub    <span class="hljs-variable">$0</span>xd0,<span class="hljs-variable">%rsp</span>          ；rsp下移<span class="hljs-number">208</span>字节 用于保存寄存器和局部变量  
   <span class="hljs-number">0x000000000040056f</span> &lt;+<span class="hljs-number">11</span>&gt;:    mov    <span class="hljs-variable">%edi</span>,-<span class="hljs-number">0xc4</span>(<span class="hljs-variable">%rbp</span>)     ；把寄存器edi中的值 （<span class="hljs-keyword">int</span> argc）保存在栈帧中 （rbp-<span class="hljs-number">196</span>）。因为寄存器edi接下来要被使用
   <span class="hljs-number">0x0000000000400575</span> &lt;+<span class="hljs-number">17</span>&gt;:    mov    <span class="hljs-variable">%rsi</span>,-<span class="hljs-number">0xd0</span>(<span class="hljs-variable">%rbp</span>)     ；把寄存器rsi中的值（ char <span class="hljs-variable">*argv</span>）保存在栈帧中。 （rbp-<span class="hljs-number">208</span>）
   <span class="hljs-number">0x000000000040057c</span> &lt;+<span class="hljs-number">24</span>&gt;:    movl   <span class="hljs-variable">$0</span>xa,-<span class="hljs-number">0xc</span>(<span class="hljs-variable">%rbp</span>)     ；局部变量tmp 存放于  rbp-<span class="hljs-number">12</span> 位置 ，赋值<span class="hljs-number">10</span>
   <span class="hljs-number">0x0000000000400583</span> &lt;+<span class="hljs-number">31</span>&gt;:    movl   <span class="hljs-variable">$0</span>xb,-<span class="hljs-number">0x8</span>(<span class="hljs-variable">%rbp</span>)     ；局部变量tmp1 存放于  rbp-<span class="hljs-number">8</span> 位置 ，赋值<span class="hljs-number">11</span>
   <span class="hljs-number">0x000000000040058a</span> &lt;+<span class="hljs-number">38</span>&gt;:    lea    -<span class="hljs-number">0x50</span>(<span class="hljs-variable">%rbp</span>),<span class="hljs-variable">%rsi</span>     ；局部变量str1 存放于  rbp-<span class="hljs-number">80</span> 位置 (<span class="hljs-number">12</span>+<span class="hljs-number">60</span>=<span class="hljs-number">76</span> 按<span class="hljs-number">16</span>字节对齐) ， 传入rsi作为strcopy第二个参数
   <span class="hljs-number">0x000000000040058e</span> &lt;+<span class="hljs-number">42</span>&gt;:    lea    -<span class="hljs-number">0xc0</span>(<span class="hljs-variable">%rbp</span>),<span class="hljs-variable">%rdi</span>     ；局部变量str2 存放于  rbp-<span class="hljs-number">192</span> 位置 (<span class="hljs-number">80</span>+<span class="hljs-number">100</span>=<span class="hljs-number">180</span> 按<span class="hljs-number">16</span>字节对齐) ， 传入rdi作为strcopy第二个参数
   <span class="hljs-number">0x0000000000400595</span> &lt;+<span class="hljs-number">49</span>&gt;:    callq  <span class="hljs-number">0x400556</span> &lt;strcopy&gt;   ；调用strcopy
   <span class="hljs-number">0x000000000040059a</span> &lt;+<span class="hljs-number">54</span>&gt;:    mov    <span class="hljs-variable">$0</span>x3,<span class="hljs-variable">%esi</span>           ；第二个参数 <span class="hljs-number">3</span> 存入 esi
   <span class="hljs-number">0x000000000040059f</span> &lt;+<span class="hljs-number">59</span>&gt;:    mov    <span class="hljs-variable">$0</span>x2,<span class="hljs-variable">%edi</span>           ；第一个参数<span class="hljs-number">2</span> 存入 edi
   <span class="hljs-number">0x00000000004005a4</span> &lt;+<span class="hljs-number">64</span>&gt;:    callq  <span class="hljs-number">0x40053c</span> &lt;add&gt;       ；调用 add 函数 ；refer to note2
   <span class="hljs-number">0x00000000004005a9</span> &lt;+<span class="hljs-number">69</span>&gt;:    mov    <span class="hljs-variable">%eax</span>,-<span class="hljs-number">0x4</span>(<span class="hljs-variable">%rbp</span>)      ；将eax中存放的返回值 存入（ rbp-<span class="hljs-number">4</span> ）位置， 局部变量 result
   <span class="hljs-number">0x00000000004005ac</span> &lt;+<span class="hljs-number">72</span>&gt;:    mov    -<span class="hljs-number">0x4</span>(<span class="hljs-variable">%rbp</span>),<span class="hljs-variable">%esi</span>       ；将rbp-<span class="hljs-number">4</span> 位置 的内容 存入 esi 作为 printf 的 第二个参数
   <span class="hljs-number">0x00000000004005af</span> &lt;+<span class="hljs-number">75</span>&gt;:    mov    <span class="hljs-variable">$0</span>x4006c4,<span class="hljs-variable">%edi</span>       ；将 <span class="hljs-string">"result=%d\n"</span>  的地址 存入 edi 作为 printf 的第二个参数（查看数据段内容 readelf -p .rodata test）
   <span class="hljs-number">0x00000000004005b4</span> &lt;+<span class="hljs-number">80</span>&gt;:    mov    <span class="hljs-variable">$0</span>x0,<span class="hljs-variable">%eax</span>           ； eax 清零
   <span class="hljs-number">0x00000000004005b9</span> &lt;+<span class="hljs-number">85</span>&gt;:    callq  <span class="hljs-number">0x400430</span> &lt;printf<span class="hljs-variable">@plt</span>&gt;    ；调用 printf
   <span class="hljs-number">0x00000000004005be</span> &lt;+<span class="hljs-number">90</span>&gt;:    mov    <span class="hljs-variable">$0</span>x0,<span class="hljs-variable">%eax</span>           ；<span class="hljs-number">0</span>传入 eax 作为返回值 
   <span class="hljs-number">0x00000000004005c3</span> &lt;+<span class="hljs-number">95</span>&gt;:    leaveq 
   <span class="hljs-number">0x00000000004005c4</span> &lt;+<span class="hljs-number">96</span>&gt;:    retq   
End of assembler dump.</code></pre> 
<pre class="prettyprint"><code class="language-assembly hljs perl">(gdb) disas add
Dump of assembler code <span class="hljs-keyword">for</span> function add:
   <span class="hljs-number">0x000000000040053c</span> &lt;+<span class="hljs-number">0</span>&gt;: <span class="hljs-keyword">push</span>   <span class="hljs-variable">%rbp</span>             ；main 函数基址进栈
   <span class="hljs-number">0x000000000040053d</span> &lt;+<span class="hljs-number">1</span>&gt;: mov    <span class="hljs-variable">%rsp</span>,<span class="hljs-variable">%rbp</span>            ；将当前栈顶作为add函数的基址  （rsp=rbp=<span class="hljs-number">0x7fffffffe030</span>）
   <span class="hljs-number">0x0000000000400540</span> &lt;+<span class="hljs-number">4</span>&gt;: mov    <span class="hljs-variable">%edi</span>,-<span class="hljs-number">0x14</span>(<span class="hljs-variable">%rbp</span>)      ；第二个参数 b存入 rbp -<span class="hljs-number">20</span>位置
   <span class="hljs-number">0x0000000000400543</span> &lt;+<span class="hljs-number">7</span>&gt;: mov    <span class="hljs-variable">%esi</span>,-<span class="hljs-number">0x18</span>(<span class="hljs-variable">%rbp</span>)      ；第二个参数 b 存入 rbp -<span class="hljs-number">24</span>位置
   <span class="hljs-number">0x0000000000400546</span> &lt;+<span class="hljs-number">10</span>&gt;:    mov    -<span class="hljs-number">0x18</span>(<span class="hljs-variable">%rbp</span>),<span class="hljs-variable">%edx</span>  ；第二个参数 b 传给 edx
   <span class="hljs-number">0x0000000000400549</span> &lt;+<span class="hljs-number">13</span>&gt;:    mov    -<span class="hljs-number">0x14</span>(<span class="hljs-variable">%rbp</span>),<span class="hljs-variable">%eax</span>  ；第二个参数 a 传给 eax
   <span class="hljs-number">0x000000000040054c</span> &lt;+<span class="hljs-number">16</span>&gt;:    add    <span class="hljs-variable">%edx</span>,<span class="hljs-variable">%eax</span>            ；eax=eax+edx
   <span class="hljs-number">0x000000000040054e</span> &lt;+<span class="hljs-number">18</span>&gt;:    mov    <span class="hljs-variable">%eax</span>,-<span class="hljs-number">0x4</span>(<span class="hljs-variable">%rbp</span>)       ；eax 中的值放入  rbp-<span class="hljs-number">4</span> 位置
   <span class="hljs-number">0x0000000000400551</span> &lt;+<span class="hljs-number">21</span>&gt;:    mov    -<span class="hljs-number">0x4</span>(<span class="hljs-variable">%rbp</span>),<span class="hljs-variable">%eax</span>      ；将rbp-<span class="hljs-number">4</span>位置中的内容 存入 eax作为返回值
   <span class="hljs-number">0x0000000000400554</span> &lt;+<span class="hljs-number">24</span>&gt;:    leaveq                  ；refer to note3
   <span class="hljs-number">0x0000000000400555</span> &lt;+<span class="hljs-number">25</span>&gt;:    retq                    ；refer to note4
End of assembler <span class="hljs-keyword">dump</span>.</code></pre> 
<p><strong>note1</strong>：0x0000000000400459 &lt;+9&gt;: and $0xfffffffffffffff0,%rsp <br> 栈的字节对齐，实际是指栈顶指针须是某字节的整数倍。我们都知道栈对齐帮助在尽可能少的内存访问周期内读取数据，不对齐堆栈指针可能导致严重的性能下降。 <br> 但是我不太理解，为什么这里会要求栈顶 16 字节对齐。 <br> 查阅 “ Intel-64 and IA-32 Architectures Software Developer Manuals （<a href="https://software.intel.com/en-us/articles/intel-sdm" rel="nofollow noopener noreferrer" target="_blank">https://software.intel.com/en-us/articles/intel-sdm</a>）” <br> 里面说： 堆栈段的堆栈指针(esp)应在16位（字）或32位（双字）边界上对齐，取决于堆栈段的宽度。当前代码段的段描述符中的D标志设置堆栈段宽度。 <br> 此外，在64位模式下，寄存器E（SP），E（IP）和E（BP）分别被提升为64位，分别被称为RSP，RIP和RBP。一些分段加载指令的形式无效（例如，LDS，POP ES）。PUSH / POP指令使用64位宽度递增/递减堆栈。当段的内容寄存器被推入64位堆栈，指针自动对齐到64位。 <br> 也就是说 x86-64 系统中应该是 8字节对齐才对呀。 </p> 
<p>根据 x86-64 ABI ( <a href="http://refspecs.linuxbase.org/elf/x86_64-abi-0.21.pdf" rel="nofollow noopener noreferrer" target="_blank">http://refspecs.linuxbase.org/elf/x86_64-abi-0.21.pdf</a>) 的描述。 <br> x86-64要求堆栈指针在函数调用时始终为16字节对齐，以允许在数组上进行操作时使用向量化的SSE指令。具有Intel SSE指令集支持的处理器有8个128位的寄存器，每一个寄存器可以存放4个（32位）单精度的浮点数。SSE同时提供了一个指令集，其中的指令可以允许把浮点数加载到这些128位的寄存器之中，这些数就可以在这些寄存器中进行算术逻辑运算，然后把结果放回内存。看起来，这种对浮点数计算进行优化的指令，对一般程序用处不大，但这是标准，gcc遵循标准。</p> 
<p><strong>note2</strong>：0x00000000004005a4 &lt;+64&gt;: callq 0x40053c <br> 调用add函数。add函数调用完之后要返回到callq的下一条指令继续执行，因此callq指令会做两件事： <br> 1）把callq指令的下一条指令地址0x00000000004005a9压栈，同时寄存器rsp的值将减8。 <br> 2）修改程序计数器rip，使其指向add函数的首地址，然后跳转到add函数的开头执行。</p> 
<p><strong>note3</strong>：0x0000000000400554 &lt;+24&gt;: leaveq ： <br> add函数的开头有两条指令（push%rbp；mov %rsp,%rbp），leaveq就是这两条指令的逆操作。分为两步： <br> 1）mov %rbp,%rsp ：把寄存器rbp的值赋给寄存器rsp，让寄存器rsp指向保存main函数栈底的地址 <br> 2）pop %rbp 把寄存器rsp所指向的内存单元值赋值给rbp，这样rbp现在就指向main函数的栈底。同时寄存器rsp加8，此时rsp指向调用函数main的返回地址。</p> 
<p><strong>note4</strong>：0x0000000000400555 &lt;+25&gt;: retq： <br> main函数调用add时需要callq指令，add函数返回时就需要retq指令，它是callq指令的逆操作。同样需要分为两步： <br> 1）把rsp指向调用函数的返回地址赋值给程序计数器rip，同时rsp寄存器加8。 <br> 2）程序返回到rip寄存器所指向的地址继续执行。</p> 
<h3 id="3-函数调用过程总结x86-64">3， 函数调用过程总结（x86-64）</h3> 
<p>整个调用过程和我之前了解的差不多，但是仍有些出入， 以下列入一些我觉得需要注意到的。 <br> 1）x86-64 下，参数可以通过寄存器直接传递，不需要通过压栈传递（当参数变量数量较多时，寄存器无法保存所有变量，这个时候需要通过压栈传递） <br> 手册上说 x86-64下，整数和指针型的参数会从左至右依次保存到rdi，rsi，rdx，rcx，r8，r9中， 浮点型参数会保存到xmm0，xmm1……中, 多余这些寄存器的参数会被保存到栈中. <br> 2）在每个函数的栈帧中，寄存器rbp指向栈底，寄存器rsp指向栈顶，在函数执行过程中rsp随着压栈和出栈操作会发生变化，而rbp却是不变的。 <br> 3）函数返回值是通过eax寄存器传递的， eax 有4字节， 如果返回long，eax放不下，则使用rax返回。 更长更复杂的类型可能会用到rdx 或者 开辟栈空间的方式返回。 <br> 4）局部变量的空间不是一个一个压入栈中的，而是一次性分配好的，所以理解为变量依次入栈是错误的。C语言也没有规定局部变量在内存中的位置， 之前总认为先定义的变量在高地址、后定义的变量在低地址。但从实际例子中看不一定是这样的， 三个int 型变量正好相反。可见局部变量在栈上的位置没有绝对的关系，甚至不一定会出现在栈上。比如声明一个变量，无非是告诉编译器，在栈上给它准备一块空间。先声明的话，就一定会先在栈上为它分配空间吗？举个最简单的栗子，如果根本没被用到，编译器完全可以不为它分配空间。所以这个最终还是取决于编译器的实现。局部变量并不总在栈中，有时出于性能(速度)考虑会存放在寄存器中。数组/结构体型的局部变量通常分配在栈内存中。 <br> 5）观察局部变量的起始地址可以更好的理解 数据对齐的概念。 数据都有nature length，如char=1，short=2，int=4，double=8,。所谓自对齐，指的是该成员的起始位置的内存地址必须是它nature length的整数倍。如int只能以0,4,8这类的地址开始 <br> <img src="https://images2.imgbox.com/0f/81/loq6kU1s_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="4-对比函数调用-ia32">4， 对比函数调用 （IA32）</h3> 
<p>简单对比一下代码在 32位环境下的表现。</p> 
<pre class="prettyprint"><code class="language-assembly hljs mel">(gdb) disas main
Dump of assembler code <span class="hljs-keyword">for</span> function main:
   <span class="hljs-number">0x0804843f</span> &lt;+<span class="hljs-number">0</span>&gt;:     lea    <span class="hljs-number">0x4</span>(<span class="hljs-variable">%esp</span>),<span class="hljs-variable">%ecx</span>        ; esp+<span class="hljs-number">4</span> 暂存入 ecx
   <span class="hljs-number">0x08048443</span> &lt;+<span class="hljs-number">4</span>&gt;: and    <span class="hljs-variable">$0</span>xfffffff0,<span class="hljs-variable">%esp</span>        ；esp 地址按<span class="hljs-number">16</span>字节对齐作为main函数栈顶
   <span class="hljs-number">0x08048446</span> &lt;+<span class="hljs-number">7</span>&gt;: pushl  -<span class="hljs-number">0x4</span>(<span class="hljs-variable">%ecx</span>)         ；ecx-<span class="hljs-number">4</span> 进栈， 保存之前的栈顶  （esp）
   <span class="hljs-number">0x08048449</span> &lt;+<span class="hljs-number">10</span>&gt;:    push   <span class="hljs-variable">%ebp</span>             ；上层函数ebp 进栈
   <span class="hljs-number">0x0804844a</span> &lt;+<span class="hljs-number">11</span>&gt;:    mov    <span class="hljs-variable">%esp</span>,<span class="hljs-variable">%ebp</span>            ；将当前栈顶作为main函数的基址
   <span class="hljs-number">0x0804844c</span> &lt;+<span class="hljs-number">13</span>&gt;:    push   <span class="hljs-variable">%ecx</span>             ；ecx 进栈
   <span class="hljs-number">0x0804844d</span> &lt;+<span class="hljs-number">14</span>&gt;:    sub    <span class="hljs-variable">$0</span>xc4,<span class="hljs-variable">%esp</span>          ；esp=esp - <span class="hljs-number">196</span>
   <span class="hljs-number">0x08048453</span> &lt;+<span class="hljs-number">20</span>&gt;:    movl   <span class="hljs-variable">$0</span>xa,-<span class="hljs-number">0x10</span>(<span class="hljs-variable">%ebp</span>)        ；tmp 存放在 ebp -<span class="hljs-number">16</span>
   <span class="hljs-number">0x0804845a</span> &lt;+<span class="hljs-number">27</span>&gt;:    movl   <span class="hljs-variable">$0</span>xb,-<span class="hljs-number">0xc</span>(<span class="hljs-variable">%ebp</span>)      ；tmp 存放在 ebp - <span class="hljs-number">12</span>
   <span class="hljs-number">0x08048461</span> &lt;+<span class="hljs-number">34</span>&gt;:    lea    -<span class="hljs-number">0x4c</span>(<span class="hljs-variable">%ebp</span>),<span class="hljs-variable">%eax</span>     ；str1 地址存入 eax 
   <span class="hljs-number">0x08048464</span> &lt;+<span class="hljs-number">37</span>&gt;:    mov    <span class="hljs-variable">%eax</span>,<span class="hljs-number">0x4</span>(<span class="hljs-variable">%esp</span>)        ；eax 存入esp+<span class="hljs-number">4</span>  作为第二个参数
   <span class="hljs-number">0x08048468</span> &lt;+<span class="hljs-number">41</span>&gt;:    lea    -<span class="hljs-number">0xb0</span>(<span class="hljs-variable">%ebp</span>),<span class="hljs-variable">%eax</span>     ；str2 地址存入 eax
   <span class="hljs-number">0x0804846e</span> &lt;+<span class="hljs-number">47</span>&gt;:    mov    <span class="hljs-variable">%eax</span>,(<span class="hljs-variable">%esp</span>)          ；eax 存入esp+<span class="hljs-number">4</span>  作为第一个参数
   <span class="hljs-number">0x08048471</span> &lt;+<span class="hljs-number">50</span>&gt;:    call   <span class="hljs-number">0x804843a</span> &lt;strcopy&gt;       ；调用 strcopy
   <span class="hljs-number">0x08048476</span> &lt;+<span class="hljs-number">55</span>&gt;:    movl   <span class="hljs-variable">$0</span>x3,<span class="hljs-number">0x4</span>(<span class="hljs-variable">%esp</span>)             ；参数 <span class="hljs-number">3</span> 存入 esp+<span class="hljs-number">4</span>
   <span class="hljs-number">0x0804847e</span> &lt;+<span class="hljs-number">63</span>&gt;:    movl   <span class="hljs-variable">$0</span>x2,(<span class="hljs-variable">%esp</span>)                   ；参数 <span class="hljs-number">2</span> 存入esp
   <span class="hljs-number">0x08048485</span> &lt;+<span class="hljs-number">70</span>&gt;:    call   <span class="hljs-number">0x8048424</span> &lt;add&gt;             ； 调用add
   <span class="hljs-number">0x0804848a</span> &lt;+<span class="hljs-number">75</span>&gt;:    mov    <span class="hljs-variable">%eax</span>,-<span class="hljs-number">0x8</span>(<span class="hljs-variable">%ebp</span>)
   <span class="hljs-number">0x0804848d</span> &lt;+<span class="hljs-number">78</span>&gt;:    mov    -<span class="hljs-number">0x8</span>(<span class="hljs-variable">%ebp</span>),<span class="hljs-variable">%eax</span>
   <span class="hljs-number">0x08048490</span> &lt;+<span class="hljs-number">81</span>&gt;:    mov    <span class="hljs-variable">%eax</span>,<span class="hljs-number">0x4</span>(<span class="hljs-variable">%esp</span>)
   <span class="hljs-number">0x08048494</span> &lt;+<span class="hljs-number">85</span>&gt;:    movl   <span class="hljs-variable">$0</span>x8048580,(<span class="hljs-variable">%esp</span>)
   <span class="hljs-number">0x0804849b</span> &lt;+<span class="hljs-number">92</span>&gt;:    call   <span class="hljs-number">0x8048340</span> &lt;printf<span class="hljs-variable">@plt</span>&gt;
   <span class="hljs-number">0x080484a0</span> &lt;+<span class="hljs-number">97</span>&gt;:    mov    <span class="hljs-variable">$0</span>x0,<span class="hljs-variable">%eax</span>
   <span class="hljs-number">0x080484a5</span> &lt;+<span class="hljs-number">102</span>&gt;:   add    <span class="hljs-variable">$0</span>xc4,<span class="hljs-variable">%esp</span>
   <span class="hljs-number">0x080484ab</span> &lt;+<span class="hljs-number">108</span>&gt;:   pop    <span class="hljs-variable">%ecx</span>
   <span class="hljs-number">0x080484ac</span> &lt;+<span class="hljs-number">109</span>&gt;:   pop    <span class="hljs-variable">%ebp</span>
   <span class="hljs-number">0x080484ad</span> &lt;+<span class="hljs-number">110</span>&gt;:   lea    -<span class="hljs-number">0x4</span>(<span class="hljs-variable">%ecx</span>),<span class="hljs-variable">%esp</span>
   <span class="hljs-number">0x080484b0</span> &lt;+<span class="hljs-number">113</span>&gt;:   ret  </code></pre> 
<p><strong>总结</strong>： 比较明显的不同是参数的传递方式，IA32上， 原则上参数全部堆放在栈中，参数压栈时从右向左依次压栈，而被调用函数的参数是从栈帧的低地址向高地址去取， 因此可以在函数入口中断后，用 esp+4 取得第一个参数， esp+8取得第二个参数， 以此类推。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27d086e37f2bca63e211ca466246d744/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQLite中的内连接简化技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ef4863b3253baf0fefdeb6dc0b1de61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">css使用checkbox来打造switch开关按钮</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>