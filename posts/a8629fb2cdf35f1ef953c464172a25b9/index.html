<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>flink文档之window操作 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="flink文档之window操作" />
<meta property="og:description" content="文章目录 WindowsWindow 的生命周期分组和非分组Windows (Keyed vs Non-Keyed Windows)窗口分配器(Window Assingers)滚动窗口滑动窗口会话窗口(Session Windows)全局窗口(Global Windows)窗口函数(Window Functions)1、ReduceFunction2、AggregateFunction3、FoldFunction4、ProcessWindowFunction5、ProcessWindowFunction with Incremental Aggregation6、Incremental Window Aggregation with ReduceFunction7、Incremental Window Aggregation with AggregateFunction8、Incremental Window Aggregation with FoldFunction Using per-window state in ProcessWindowFunctionTriggers触发器Fire and Purge 触发和清除Default Triggers of WindowAssigners 窗口分配中的默认触发器内置的和自定义的触发器(Build-in and Custom Triggers)Evictors驱逐器允许延迟(Allowed Lateness)以侧输出来获取延迟数据(Getting Late Data as a Site Output)延迟元素考虑Late elements considerations使用窗口结果Working with window results水印和窗户的互动 Interaction of watermarks and windows连续窗口操作 Consecutive windowed operations使用状态大小的考虑(Useful state size considerations) 初学flink和第一次进行博客编写，决定从文档看起，以及附上从各位博主总结来的内容。主要作用是督促自己养成读文档，记录博客的习惯以及记录下自己在学习、实际生产过程中的心得，记录下来留给需要之时参考，如有错误还请批评指正。 原文： flink 1.7文档 本文多部分引用自 简书上一位大大：写Bug的张小天 Windows Window是无限数据流处理的核心，Window将一个无限的stream拆分成有限大小的桶(buckets)，我们可以在这些桶上做计算操作。本文主要聚焦于在Flink中如何进行窗口操作，以及程序员如何从window提供的功能中获得最大的收益。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a8629fb2cdf35f1ef953c464172a25b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-18T20:13:23+08:00" />
<meta property="article:modified_time" content="2019-03-18T20:13:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">flink文档之window操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><ul><li><a href="#Windows_5" rel="nofollow">Windows</a></li><li><a href="#Window__37" rel="nofollow">Window 的生命周期</a></li><li><a href="#Windows_Keyed_vs_NonKeyed_Windows_42" rel="nofollow">分组和非分组Windows (Keyed vs Non-Keyed Windows)</a></li><li><a href="#Window_Assingers_46" rel="nofollow">窗口分配器(Window Assingers)</a></li><li><a href="#_51" rel="nofollow">滚动窗口</a></li><li><a href="#_78" rel="nofollow">滑动窗口</a></li><li><a href="#Session_Windows_109" rel="nofollow">会话窗口(Session Windows)</a></li><li><a href="#Global_Windows_149" rel="nofollow">全局窗口(Global Windows)</a></li><li><a href="#Window_Functions_161" rel="nofollow">窗口函数(Window Functions)</a></li><li><ul><li><a href="#1ReduceFunction_165" rel="nofollow">1、ReduceFunction</a></li><li><a href="#2AggregateFunction_181" rel="nofollow">2、AggregateFunction</a></li><li><a href="#3FoldFunction_221" rel="nofollow">3、FoldFunction</a></li><li><a href="#4ProcessWindowFunction_239" rel="nofollow">4、ProcessWindowFunction</a></li><li><a href="#5ProcessWindowFunction_with_Incremental_Aggregation_318" rel="nofollow">5、ProcessWindowFunction with Incremental Aggregation</a></li><li><a href="#6Incremental_Window_Aggregation_with_ReduceFunction_322" rel="nofollow">6、Incremental Window Aggregation with ReduceFunction</a></li><li><a href="#7Incremental_Window_Aggregation_with_AggregateFunction_353" rel="nofollow">7、Incremental Window Aggregation with AggregateFunction</a></li><li><a href="#8Incremental_Window_Aggregation_with_FoldFunction_405" rel="nofollow">8、Incremental Window Aggregation with FoldFunction</a></li></ul> 
     </li><li><a href="#Using_perwindow_state_in_ProcessWindowFunction_440" rel="nofollow">Using per-window state in ProcessWindowFunction</a></li><li><a href="#Triggers_470" rel="nofollow">Triggers触发器</a></li><li><a href="#Fire_and_Purge__491" rel="nofollow">Fire and Purge 触发和清除</a></li><li><a href="#Default_Triggers_of_WindowAssigners__496" rel="nofollow">Default Triggers of WindowAssigners 窗口分配中的默认触发器</a></li><li><a href="#Buildin_and_Custom_Triggers_500" rel="nofollow">内置的和自定义的触发器(Build-in and Custom Triggers)</a></li><li><a href="#Evictors_509" rel="nofollow">Evictors驱逐器</a></li><li><a href="#Allowed_Lateness_542" rel="nofollow">允许延迟(Allowed Lateness)</a></li><li><a href="#Getting_Late_Data_as_a_Site_Output_560" rel="nofollow">以侧输出来获取延迟数据(Getting Late Data as a Site Output)</a></li><li><a href="#Late_elements_considerations_578" rel="nofollow">延迟元素考虑Late elements considerations</a></li><li><a href="#Working_with_window_results_581" rel="nofollow">使用窗口结果Working with window results</a></li><li><a href="#_Interaction_of_watermarks_and_windows_583" rel="nofollow">水印和窗户的互动 Interaction of watermarks and windows</a></li><li><a href="#_Consecutive_windowed_operations_590" rel="nofollow">连续窗口操作 Consecutive windowed operations</a></li><li><a href="#Useful_state_size_considerations_606" rel="nofollow">使用状态大小的考虑(Useful state size considerations)</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br>   初学flink和第一次进行博客编写，决定从文档看起，以及附上从各位博主总结来的内容。主要作用是督促自己养成读文档，记录博客的习惯以及记录下自己在学习、实际生产过程中的心得，记录下来留给需要之时参考，如有错误还请批评指正。 
<br> 原文： 
<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html" rel="nofollow">flink 1.7文档</a> 
<br> 本文多部分引用自 
<a href="https://www.jianshu.com/p/a883262241ef" rel="nofollow">简书上一位大大：写Bug的张小天</a> 
<p></p> 
<h5><a id="Windows_5"></a>Windows</h5> 
<p>  Window是无限数据流处理的核心，Window将一个无限的stream拆分成有限大小的桶(buckets)，我们可以在这些桶上做计算操作。本文主要聚焦于在Flink中如何进行窗口操作，以及程序员如何从window提供的功能中获得最大的收益。<br>   窗口化的Flink程序的通用结构如下，第一个代码段中是分组的流（ keyed streams），而第二段是非分组的流（non-keyed）。正如我们所见，唯一的区别是分组的stream调用keyBy(…)和window(…)，而非分组的stream中window()换成了windowAll(…)，这些也将贯穿都这一页的其他部分中。</p> 
<pre><code>Keyed Windows

stream
       .keyBy(...)            &lt;-  根据某字段指定keyBy操作，是是否是一个分组窗口的划分标志
       .window(...)           &lt;-  window assingers 窗口分配
      [.trigger(...)]         &lt;-  窗口触发器
      [.evictor(...)]         &lt;-  窗口驱逐器
      [.allowedLateness(...)]    &lt;-  窗口允许数据最大延迟时间
      [.sideOutputLateData(...)] &lt;-  窗口指定延迟的数据操作
       .reduce/aggregate/fold/apply()  &lt;-  窗口聚合操作（分为两种：增量聚合、全量聚合）
      [.getSideOutput(...)]            &lt;-  optional: "output tag"

</code></pre> 
<pre><code>Non-Keyed Windows

stream
       .windowAll(...)           &lt;-  required: "assigner"
      [.trigger(...)]            &lt;-  optional: "trigger" (else default trigger)
      [.evictor(...)]            &lt;-  optional: "evictor" (else no evictor)
      [.allowedLateness(...)]    &lt;-  optional: "lateness" (else zero)
      [.sideOutputLateData(...)] &lt;-  optional: "output tag" (else no side output for late data)
       .reduce/aggregate/fold/apply()      &lt;-  required: "function"
      [.getSideOutput(...)]      &lt;-  optional: "output tag"

</code></pre> 
<p>在上面的例子中，方括号[]内的命令是可选的，这表明Flink允许你根据最符合你的要求来定义自己的window逻辑。</p> 
<h5><a id="Window__37"></a>Window 的生命周期</h5> 
<p>  简单地说，当一个属于window的元素到达之后这个window就创建了，而当当前时间(事件或者处理时间)为window的创建时间跟用户指定的延迟时间（<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#allowed-lateness" rel="nofollow">allowed lateness</a>）相加时，窗口将被彻底清除。Flink 确保了只清除基于时间的window，其他类型的window不清除，（<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#window-assigners" rel="nofollow">例如:全局window</a>）。例如:对于一个每5分钟创建无覆盖的(即 翻滚窗口)窗口，允许一个1分钟的时延的窗口策略，Flink将会在12:00到12:05这段时间内第一个元素到达时创建窗口，当水印通过12:06时，移除这个窗口。<br>   此外，每个 Window 都有一个Trigger(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#triggers" rel="nofollow">触发器</a>) 和一个附属于 Window 的函数(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#window-functions" rel="nofollow">例如:ProcessWindowFunction, ReduceFunction, AggregateFunction or FoldFunction</a>)。函数里包含了应用于窗口(Window)内容的计算，而Trigger(触发器)则指定了函数在什么条件下可被应用(函数何时被触发),一个触发策略可以是 “当窗口中的元素个数超过4个时” 或者 “当水印达到窗口的边界时”。触发器还可以决定在窗口创建和删除之间的任意时刻清除窗口的内容，这种情况下的清除仅指清除窗口的内容而不是窗口的元数据,也就是说新的数据还是可以被添加到当前的window中。<br>   除了上面的提到之外，你还可以指定一个驱逐器(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#evictors" rel="nofollow">Evictor</a>), Evictor将在触发器触发之后或者在函数被应用之前或者之后，清除窗口中的元素。<br>   接下来我们将更深入的去了解上述的部件，我们从上述片段的主要部分开始(如:Keyed vs Non-Keyed Windows, Window Assigner, 及 Window Function),然后是可选部分。</p> 
<h5><a id="Windows_Keyed_vs_NonKeyed_Windows_42"></a>分组和非分组Windows (Keyed vs Non-Keyed Windows)</h5> 
<p>  首先，第一件事是指定你的数据流是分组的还是未分组的，这个必须在定义 window 之前指定好。使用 keyBy(…) 会将你的无限数据流拆分成逻辑分组的数据流，如果 keyBy(…) 函数不被调用的话，你的数据流将不是分组的。<br>   在分组数据流中，任何正在传入的事件的属性都可以被当做key(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/api_concepts.html#specifying-keys" rel="nofollow">更多详情</a>)，分组数据流将使你的window计算通过多任务并发执行，每一个逻辑分组流在执行中与其他的逻辑分组流是独立进行的，所有具有相同key的元素都将被送到同一个并行度中计算。<br>   在非分组数据流中，你的原始数据流并不会拆分成多个逻辑流并且所有的window逻辑将在一个任务中执行，并发度为1。</p> 
<h5><a id="Window_Assingers_46"></a>窗口分配器(Window Assingers)</h5> 
<p>  指定完你的数据流是分组的还是非分组的之后，接下来你需要定义一个窗口分配器(window assigner)，窗口分配器定义了元素如何分配到窗口中，这是通过在分组数据流中调用window(…)或者非分组数据流中调用windowAll(…)时你选择的窗口分配器(WindowAssigner)来指定的。<br>   一个WindowAssigner负责将每一个到来的元素分配给一个或者多个窗口(window),Flink 提供了一些常用的预定义窗口分配器，即:滚动窗口（ tumbling windows）、滑动窗口（sliding windows）、会话窗口（session windows）和全局窗口（global windows）。你也可以通过继承WindowAssigner类来自定义自己的窗口。所有的内置窗口分配器(除了全局窗口 global window)都是通过时间来分配元素到窗口中的，这个时间要么是处理的时间，要么是事件发生的时间。请看一下我们的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/event_time.html" rel="nofollow">event time</a>部分来了解更多处理时间和事件时间的区别及时间戳(timestamp)和水印(watermark)是如何产生的。<br>   接下来我们将展示Flink的预定义窗口分配器是如何工作的，以及它们在DataStream程序中是如何使用的。接下来我们将展示Flink的预定义窗口分配器是如何工作的，以及它们在DataStream程序中是如何使用的。下图中展示了每个分配器是如何工作的，紫色圆圈代表着数据流中的一个元素，这些元素是通过一些key进行分区(在本例中是 user1,user2,user3), X轴显示的是时间进度。</p> 
<h5><a id="_51"></a>滚动窗口</h5> 
<p>  滚动窗口分配器将每个元素分配的一个指定窗口大小的窗口中，滚动窗口有一个固定的大小，并且不会出现重叠。例如:如果你指定了一个5分钟大小的滚动窗口，当前窗口将被评估并将按下图说明每5分钟创建一个新的窗口。<br> <img src="https://images2.imgbox.com/7e/e3/DjNfwIxI_o.png" alt="创建一个滚动窗口"><br> 下面的代码片段展示了如何使用滚动窗口。</p> 
<pre><code>DataStream&lt;T&gt; input = ...;

// 滚动事件时间窗口( tumbling event-time windows )
input
    .keyBy(&lt;key selector&gt;)
    .window(TumblingEventTimeWindows.of(Time.seconds(5)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);

// 滚动处理时间窗口(tumbling processing-time windows)
input
    .keyBy(&lt;key selector&gt;)
    .window(TumblingProcessingTimeWindows.of(Time.seconds(5)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);

// 每日偏移8小时的滚动事件时间窗口(daily tumbling event-time windows offset by -8 hours. )
input
    .keyBy(&lt;key selector&gt;)
    .window(TumblingEventTimeWindows.of(Time.days(1), Time.hours(-8)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);
    
</code></pre> 
<h5><a id="_78"></a>滑动窗口</h5> 
<p>  滑动窗口分配器将元素分配到固定长度的窗口中，与滚动窗口类似，窗口的大小由窗口大小参数来配置，另一个窗口滑动参数控制滑动窗口开始的频率。因此，滑动窗口如果滑动参数小于滚动参数的话，窗口是可以重叠的，在这种情况下元素会被分配到多个窗口中。<br>   例如，你有10分钟的窗口和5分钟的滑动，那么每个窗口中5分钟的窗口里包含着上个10分钟产生的数据，如下图所示:</p> 
<p><img src="https://images2.imgbox.com/82/7b/8LtXjY9d_o.png" alt="滑动窗口"><br> 下面的代码片段中展示了如何使用滑动窗口:</p> 
<pre><code>DataStream&lt;T&gt; input = ...;

// 滑动事件时间窗口 sliding event-time windows
input
    .keyBy(&lt;key selector&gt;)
    .window(SlidingEventTimeWindows.of(Time.seconds(10), Time.seconds(5)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);

// 滑动处理时间窗口 sliding processing-time windows
input
    .keyBy(&lt;key selector&gt;)
    .window(SlidingProcessingTimeWindows.of(Time.seconds(10), Time.seconds(5)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);

// 偏移8小时的滑动处理时间窗口(sliding processing-time windows offset by -8 hours)
input
    .keyBy(&lt;key selector&gt;)
    .window(SlidingProcessingTimeWindows.of(Time.hours(12), Time.hours(1), Time.hours(-8)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);
    
</code></pre> 
<p>时间间隔可以通过Time.milliseconds(x),Time.seconds(x),Time.minutes(x)等来指定。<br>   正如上述例子所示，滑动窗口分配器也有一个可选的偏移参数来改变窗口的对齐。例如，没有偏移参数，按小时的窗口，有30分钟的滑动，将根据时间纪元来对齐，也就是说你将得到如下的窗口1:00:00.001:59:59.999,1:30:00.0002:29:59.999等。而如果你想改变窗口的对齐，你可以给定一个偏移，如果给定一个15分钟的偏移，你将得到如下的窗口:1:15:00.000~2:14.59.999,　1:45:00.000~2:44:59.999等。时间偏移一个很大的用处是用来调准非0时区的窗口，例如:在中国你需要指定一个8小时的时间偏移。</p> 
<h5><a id="Session_Windows_109"></a>会话窗口(Session Windows)</h5> 
<p>  session窗口分配器通过session活动来对元素进行分组，session窗口跟滚动窗口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况。相反，当它在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关闭。一个session窗口通过一个session间隔来配置，这个session间隔定义了非活跃周期的长度。当这个非活跃周期产生，那么当前的session将关闭并且后续的元素将被分配到新的session窗口中去。</p> 
<p><img src="https://images2.imgbox.com/c5/e9/5J9v1nDs_o.png" alt="会话窗口"><br> 下面的代码片段中展示了如何使用session窗口<br> Java代码:</p> 
<pre><code>DataStream&lt;T&gt; input = ...;

// 事件时间会话窗口(event-time session windows with static gap)
input
    .keyBy(&lt;key selector&gt;)
    .window(EventTimeSessionWindows.withGap(Time.minutes(10)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);
    
// 事件时间会话窗口 event-time session windows with dynamic gap
input
    .keyBy(&lt;key selector&gt;)
    .window(EventTimeSessionWindows.withDynamicGap((element) -&gt; {
        // determine and return session gap
    }))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);

// 处理时间会话窗口 processing-time session windows with static gap
input
    .keyBy(&lt;key selector&gt;)
    .window(ProcessingTimeSessionWindows.withGap(Time.minutes(10)))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);
    
//  处理时间会话窗口 processing-time session windows with dynamic gap
input
    .keyBy(&lt;key selector&gt;)
    .window(ProcessingTimeSessionWindows.withDynamicGap((element) -&gt; {
        // determine and return session gap
    }))
    .&lt;windowed transformation&gt;(&lt;window function&gt;);
    
</code></pre> 
<p>  时间间隔可以通过Time.milliseconds(x),Time.seconds(x),Time.minutes(x)等来指定。注意: 因为session看窗口没有一个固定的开始和结束，他们的评估与滑动窗口和滚动窗口不同。在内部，session操作为每一个到达的元素创建一个新的窗口，并合并间隔时间小于指定非活动间隔（ the defined gap ）的窗口。为了进行合并，session窗口的操作需要指定一个合并触发器(Trigger)和一个合并窗口函数(Window Function),如:ReduceFunction或者WindowFunction(FoldFunction不能合并)。</p> 
<h5><a id="Global_Windows_149"></a>全局窗口(Global Windows)</h5> 
<p>  全局窗口分配器将所有具有相同key的元素分配到同一个全局窗口中，这个窗口模式仅适用于用户还需自定义触发器的情况。否则，由于全局窗口没有一个自然的结尾，无法执行元素的聚合，将不会有计算被执行。下面的代码片段展示了如何使用全局窗口:<br> Java 代码:</p> 
<pre><code>DataStream&lt;T&gt; input = ...;

input
    .keyBy(&lt;key selector&gt;)
    .window(GlobalWindows.create())
    .&lt;windowed transformation&gt;(&lt;window function&gt;);
    
</code></pre> 
<h5><a id="Window_Functions_161"></a>窗口函数(Window Functions)</h5> 
<p>  定义完窗口分配器后，我们还需要为每一个窗口指定我们需要执行的计算，这是窗口函数的责任，当系统决定一个窗口已经准备好执行之后，这个窗口函数将被用来处理窗口中的每一个元素(可能是分组的)。（<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#triggers" rel="nofollow">了解当一个窗口准备好之后，Flink是如何决定的</a>）<br>   window函数可以是ReduceFunction, AggregateFunction, FoldFunction 或者 ProcessWindowFunction中的一个。前面两个更高效一些(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#state%20size" rel="nofollow">State Size 部分</a>),因为在每个窗口中增量地对每一个到达的元素执行聚合操作。一个 ProcessWindowFunction 可以获取一个窗口中的所有元素的一个迭代以及哪个元素属于哪个窗口的额外元信息。<br>   有ProcessWindowFunction的窗口化操作会比其他的操作效率要差一些，因为Flink内部在调用函数之前会将窗口中的所有元素都缓存起来。这个可以通过ProcessWindowFunction和ReduceFunction或者AggregateFunction、FoldFunction结合使用来获取窗口中所有元素的增量聚合和ProcessWindowFunction接收的额外的窗口元数据，接下来我们将看一看每一种变体的示例。</p> 
<h6><a id="1ReduceFunction_165"></a>1、ReduceFunction</h6> 
<p>  ReduceFunction指定了如何通过两个输入的参数进行合并输出一个同类型的参数的过程，Flink使用ReduceFunction来对窗口中的元素进行增量聚合。<br>   一个ReduceFunction 可以通过如下的方式来定义和使用:<br> Java 代码:</p> 
<pre><code>DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;

input
    .keyBy(&lt;key selector&gt;)
    .window(&lt;window assigner&gt;)
    .reduce(new ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt; {
      public Tuple2&lt;String, Long&gt; reduce(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2) {
        return new Tuple2&lt;&gt;(v1.f0, v1.f1 + v2.f1);
      }
    });
</code></pre> 
<h6><a id="2AggregateFunction_181"></a>2、AggregateFunction</h6> 
<p>  AggregateFunction是ReduceFunction的通用版本，有三种类型：输入类型 input type (IN)，累加器类型 accumulator type (ACC)和输出类型 output type (OUT)。输入类型是输入流中元素的类型，AggregateFunction有将一个输入元素添加到累加器（an accumulator）的方法。 该接口还具有用于创建初始累加器的方法，用于将两个累加器合并到一个累加器中以及用于从累加器提取输出（类型OUT）。我们将在下面的示例中看到它的工作原理。<br>   与ReduceFunction相同，当一个窗口的输入元素到达的时，Flink将增量地聚合它们。一个AggregateFunction将以如下方式定义和使用：</p> 
<pre><code>/**
 * The accumulator is used to keep a running sum and a count. The {@code getResult} method
 * computes the average.
 */
private static class AverageAggregate
    implements AggregateFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; {
  @Override
  public Tuple2&lt;Long, Long&gt; createAccumulator() {
    return new Tuple2&lt;&gt;(0L, 0L);
  }

  @Override
  public Tuple2&lt;Long, Long&gt; add(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator) {
    return new Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + 1L);
  }

  @Override
  public Double getResult(Tuple2&lt;Long, Long&gt; accumulator) {
    return ((double) accumulator.f0) / accumulator.f1;
  }

  @Override
  public Tuple2&lt;Long, Long&gt; merge(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b) {
    return new Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);
  }
}

DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;

input
    .keyBy(&lt;key selector&gt;)
    .window(&lt;window assigner&gt;)
    .aggregate(new AverageAggregate());
    
</code></pre> 
<p>上述示例计算了窗口中元素的第二个字段的平均值。</p> 
<h6><a id="3FoldFunction_221"></a>3、FoldFunction</h6> 
<p>  FoldFunction 指定了一个输入元素如何与一个输出类型的元素合并的过程，这个FoldFunction 会被每一个加入到窗口中的元素和当前的输出值增量地调用，第一个元素是与一个预定义的类型为输出类型的初始值合并。<br>   一个FoldFunction可以通过如下的方式定义和调用:</p> 
<pre><code>DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;

input
    .keyBy(&lt;key selector&gt;)
    .window(&lt;window assigner&gt;)
    .fold("", new FoldFunction&lt;Tuple2&lt;String, Long&gt;, String&gt;&gt; {
       public String fold(String acc, Tuple2&lt;String, Long&gt; value) {
         return acc + value.f1;
       }
    });
</code></pre> 
<p>上面例子追加所有输入的长整型到一个空的字符串中。<br> <em><strong>注意：</strong></em> fold()不能应用于回话窗口或者其他可合并的窗口中。</p> 
<h6><a id="4ProcessWindowFunction_239"></a>4、ProcessWindowFunction</h6> 
<p>  ProcessWindowFunction获取包含窗口所有元素的迭代器 Iterable，以及可访问时间和状态信息的Context对象，这使得它能够提供比其他窗口函数更多的灵活性。 这是以性能和资源消耗为代价的，因为元素不能以递增方式聚合，而是需要在内部进行缓冲，直到认为窗口已准备好进行处理。<br>   ProcessWindowFunction的签名（The signature）定义如下:</p> 
<pre><code>public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt; implements Function {

    /**
     * Evaluates the window and outputs none or several elements.
     *
     * @param key The key for which this window is evaluated.
     * @param context The context in which the window is being evaluated.
     * @param elements The elements in the window being evaluated.
     * @param out A collector for emitting elements.
     *
     * @throws Exception The function may throw exceptions to fail the program and trigger recovery.
     */
    public abstract void process(
            KEY key,
            Context context,
            Iterable&lt;IN&gt; elements,
            Collector&lt;OUT&gt; out) throws Exception;

   	/**
   	 * The context holding window metadata.
   	 */
   	public abstract class Context implements java.io.Serializable {
   	    /**
   	     * Returns the window that is being evaluated.
   	     */
   	    public abstract W window();

   	    /** Returns the current processing time. */
   	    public abstract long currentProcessingTime();

   	    /** Returns the current event-time watermark. */
   	    public abstract long currentWatermark();

   	    /**
   	     * State accessor for per-key and per-window state.
   	     *
   	     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt;If you use per-window state you have to ensure that you clean it up
   	     * by implementing {@link ProcessWindowFunction#clear(Context)}.
   	     */
   	    public abstract KeyedStateStore windowState();

   	    /**
   	     * State accessor for per-key global state.
   	     */
   	    public abstract KeyedStateStore globalState();
   	}

}

</code></pre> 
<p>  <em><strong>注：</strong></em> 关键参数是通过为keyBy() 调用指定的KeySelector提取的密钥。 在元组索引键或字符串字段引用的情况下，此键类型始终为元组，你必须手动将其转换为正确大小的元组以提取键字段。<br>   一个ProcessWindowFunction可以通过如下的方式定义和调用:</p> 
<pre><code>DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;

input
  .keyBy(t -&gt; t.f0)
  .timeWindow(Time.minutes(5))
  .process(new MyProcessWindowFunction());

public class MyProcessWindowFunction 
    extends ProcessWindowFunction&lt;Tuple2&lt;String, Long&gt;, String, String, TimeWindow&gt; {

  @Override
  public void process(String key, Context context, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out) {
    long count = 0;
    for (Tuple2&lt;String, Long&gt; in: input) {
      count++;
    }
    out.collect("Window: " + context.window() + "count: " + count);
  }
}
</code></pre> 
<p>  该示例显示了一个ProcessWindowFunction，来计算窗口中的元素。 此外，窗口函数将有关窗口的信息添加到了输出中。<br>   <em><strong>请注意：</strong></em> 使用ProcessWindowFunction进行简单的聚合（例如count）效率非常低。 下一节将介绍如何将ReduceFunction或AggregateFunction与ProcessWindowFunction结合使用，进行增量聚合和获取ProcessWindowFunction中的额外信息。</p> 
<h6><a id="5ProcessWindowFunction_with_Incremental_Aggregation_318"></a>5、ProcessWindowFunction with Incremental Aggregation</h6> 
<p>  ProcessWindowFunction可以与ReduceFunction，AggregateFunction或FoldFunction结合使用，以便在元素到达窗口时增量聚合元素。 当一个窗口关闭时，将为ProcessWindowFunction提供聚合结果。 这允许它在访问ProcessWindowFunction的附加窗口元信息的同时递增地计算窗口。<br>    <em><strong>注意：</strong></em> 您还可以使用旧版WindowFunction而不是ProcessWindowFunction进行增量窗口聚合。</p> 
<h6><a id="6Incremental_Window_Aggregation_with_ReduceFunction_322"></a>6、Incremental Window Aggregation with ReduceFunction</h6> 
<p>  以下示例显示了如何将增量ReduceFunction与ProcessWindowFunction结合以返回窗口中的最小事件以及窗口的开始时间。</p> 
<pre><code>DataStream&lt;SensorReading&gt; input = ...;

input
  .keyBy(&lt;key selector&gt;)
  .timeWindow(&lt;duration&gt;)
  .reduce(new MyReduceFunction(), new MyProcessWindowFunction());

// Function definitions

private static class MyReduceFunction implements ReduceFunction&lt;SensorReading&gt; {

  public SensorReading reduce(SensorReading r1, SensorReading r2) {
      return r1.value() &gt; r2.value() ? r2 : r1;
  }
}

private static class MyProcessWindowFunction
    extends ProcessWindowFunction&lt;SensorReading, Tuple2&lt;Long, SensorReading&gt;, String, TimeWindow&gt; {

  public void process(String key,
                    Context context,
                    Iterable&lt;SensorReading&gt; minReadings,
                    Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out) {
      SensorReading min = minReadings.iterator().next();
      out.collect(new Tuple2&lt;Long, SensorReading&gt;(window.getStart(), min));
  }
}
</code></pre> 
<h6><a id="7Incremental_Window_Aggregation_with_AggregateFunction_353"></a>7、Incremental Window Aggregation with AggregateFunction</h6> 
<p>  以下示例显示了如何将增量AggregateFunction与ProcessWindowFunction结合以计算均值并同时发出键和窗口的平均值。</p> 
<pre><code>DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;

input
  .keyBy(&lt;key selector&gt;)
  .timeWindow(&lt;duration&gt;)
  .aggregate(new AverageAggregate(), new MyProcessWindowFunction());

// Function definitions

/**
 * The accumulator is used to keep a running sum and a count. The {@code getResult} method
 * computes the average.
 */
private static class AverageAggregate
    implements AggregateFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; {
  @Override
  public Tuple2&lt;Long, Long&gt; createAccumulator() {
    return new Tuple2&lt;&gt;(0L, 0L);
  }

  @Override
  public Tuple2&lt;Long, Long&gt; add(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator) {
    return new Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + 1L);
  }

  @Override
  public Double getResult(Tuple2&lt;Long, Long&gt; accumulator) {
    return ((double) accumulator.f0) / accumulator.f1;
  }

  @Override
  public Tuple2&lt;Long, Long&gt; merge(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b) {
    return new Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);
  }
}

private static class MyProcessWindowFunction
    extends ProcessWindowFunction&lt;Double, Tuple2&lt;String, Double&gt;, String, TimeWindow&gt; {

  public void process(String key,
                    Context context,
                    Iterable&lt;Double&gt; averages,
                    Collector&lt;Tuple2&lt;String, Double&gt;&gt; out) {
      Double average = averages.iterator().next();
      out.collect(new Tuple2&lt;&gt;(key, average));
  }
}
</code></pre> 
<h6><a id="8Incremental_Window_Aggregation_with_FoldFunction_405"></a>8、Incremental Window Aggregation with FoldFunction</h6> 
<p>  以下示例显示了如何将增量FoldFunction与ProcessWindowFunction结合以提取窗口中的事件数并返回窗口的键和结束时间。</p> 
<pre><code>DataStream&lt;SensorReading&gt; input = ...;

input
  .keyBy(&lt;key selector&gt;)
  .timeWindow(&lt;duration&gt;)
  .fold(new Tuple3&lt;String, Long, Integer&gt;("",0L, 0), new MyFoldFunction(), new MyProcessWindowFunction())

// Function definitions

private static class MyFoldFunction
    implements FoldFunction&lt;SensorReading, Tuple3&lt;String, Long, Integer&gt; &gt; {

  public Tuple3&lt;String, Long, Integer&gt; fold(Tuple3&lt;String, Long, Integer&gt; acc, SensorReading s) {
      Integer cur = acc.getField(2);
      acc.setField(cur + 1, 2);
      return acc;
  }
}

private static class MyProcessWindowFunction
    extends ProcessWindowFunction&lt;Tuple3&lt;String, Long, Integer&gt;, Tuple3&lt;String, Long, Integer&gt;, String, TimeWindow&gt; {

  public void process(String key,
                    Context context,
                    Iterable&lt;Tuple3&lt;String, Long, Integer&gt;&gt; counts,
                    Collector&lt;Tuple3&lt;String, Long, Integer&gt;&gt; out) {
    Integer count = counts.iterator().next().getField(2);
    out.collect(new Tuple3&lt;String, Long, Integer&gt;(key, context.window().getEnd(),count));
  }
}
</code></pre> 
<h5><a id="Using_perwindow_state_in_ProcessWindowFunction_440"></a>Using per-window state in ProcessWindowFunction</h5> 
<p>  除了访问键控状态keyed state（和任何富函数一样），ProcessWindowFunction还可以使用键控状态，该键控状态的作用域是函数当前正在处理的窗口。 在这种情况下，了解每个窗口的状态（understand what the window that per-window state is referring to）是很重要的。 涉及不同的“窗口”：</p> 
<ul><li>指定窗口操作时定义的窗口：这可能是1小时的翻滚窗口或滑动1小时的2小时滑动窗口。</li><li>给定键的已定义窗口的实际实例：对于user-id xyz，这可能是从12:00到13:00的时间窗口。 这基于窗口定义，并且将基于作业当前正在处理的键的数量以及基于事件落入的时隙而存在许多窗口。</li></ul> 
<p>  每窗口状态与后两者相关联。 这意味着如果我们处理1000个不同键的事件，并且所有这些事件的事件当前都落入[12：00,13：00]时间窗口，那么将有1000个窗口实例，每个窗口实例都有自己的键控每窗口状态。</p> 
<p>  在Context对象上有两个方法，一个process()调用接收到允许访问两种类型的状态：</p> 
<ul><li>globalState(), 它允许访问没有作用于窗口的键控状态。</li><li>windowState(), 它允许访问同样限定在窗口范围内的键控状态。</li></ul> 
<p>  如果你预计同一窗口会发生多次触发，则此功能非常有用，如果迟到的数据延迟触发或者你有自定义触发器进行投机性早期触发时可能会发生这种情况。 在这种情况下，你将存储有关先前触发的信息或每个窗口状态的触发次数。<br>   使用窗口状态时，清除窗口时清除该状态也很重要。 这应该在clear()方法中发生。</p> 
<pre><code>In addition to accessing keyed state (as any rich function can) a ProcessWindowFunction can also use keyed state that is scoped to the window that the function is currently processing. In this context it is important to understand what the window that per-window state is referring to is. There are different “windows” involved:

The window that was defined when specifying the windowed operation: This might be tumbling windows of 1 hour or sliding windows of 2 hours that slide by 1 hour.
An actual instance of a defined window for a given key: This might be time window from 12:00 to 13:00 for user-id xyz. This is based on the window definition and there will be many windows based on the number of keys that the job is currently processing and based on what time slots the events fall into.
Per-window state is tied to the latter of those two. Meaning that if we process events for 1000 different keys and events for all of them currently fall into the [12:00, 13:00) time window then there will be 1000 window instances that each have their own keyed per-window state.

There are two methods on the Context object that a process() invocation receives that allow access two the two types of state:

globalState(), which allows access to keyed state that is not scoped to a window
windowState(), which allows access to keyed state that is also scoped to the window
This feature is helpful if you anticipate multiple firing for the same window, as can happen when you have late firings for data that arrives late or when you have a custom trigger that does speculative early firings. In such a case you would store information about previous firings or the number of firings in per-window state.

When using windowed state it is important to also clean up that state when a window is cleared. This should happen in the clear() method.
</code></pre> 
<h5><a id="Triggers_470"></a>Triggers触发器</h5> 
<p>  触发器决定了一个窗口何时可以被窗口函数处理，每一个窗口分配器都有一个默认的触发器，如果默认的触发器不能满足你的需要，你可以使用触发器trigger(…)指定自定义触发器。<br>   触发器接口有五种方法允许触发器对不同的事件做出反应：</p> 
<ul><li>onElement() 方法作用于每个元素并将之加入到一个窗口中。</li><li>onEventTime() 方法在已注册的事件时间计时器触发时调用。</li><li>onProcessingTime() 方法在一个注册的处理时间器计时器（a registered processing-time timer）触发时调用。</li><li>onMerge() 方法与状态触发器相关，并且当它们的相应窗口合并时合并两个触发器的状态，例如， 使用会话窗口时。</li><li>clear() 方法执行删除相应窗口时所需的任何操作。</li></ul> 
<p>使用以上方法有两点需要注意：</p> 
<p>1）前三个决定如何通过返回TriggerResult来对其调用事件进行操作。 该操作可以是以下之一</p> 
<ul><li>CONTINUE: 什么也不做</li><li>FIRE: 触发计算</li><li>PURGE: 清除窗口中的数据</li><li>FIRE_AND_PURGE: 触发计算并清除窗口中的数据</li></ul> 
<p>2）所有的这些方法可用于注册处理或事件时间计时器以用于将来的操作。</p> 
<h5><a id="Fire_and_Purge__491"></a>Fire and Purge 触发和清除</h5> 
<p>  一旦触发器确定窗口已准备好进行处理，它就会触发，即返回FIRE或FIRE_AND_PURGE。 这是窗口操作发出当前窗口结果的信号。 给定一个带有ProcessWindowFunction的窗口，所有元素都传递给ProcessWindowFunction（可能在将它们传递给驱逐器后）。具有ReduceFunction，AggregateFunction或FoldFunction的窗口只会发出当前聚合的结果。<br>   当触发器触发时，它可以是FIRE或FIRE_AND_PURGE。 当FIRE保留窗口内容时，FIRE_AND_PURGE会删除其内容。 默认情况下，预先实现的触发器只需FIRE而不会清除窗口状态。<br> <em><strong>注意：</strong></em> 清除将简单地删除窗口的内容，并将保留有关窗口和任何触发状态的任何潜在元信息。</p> 
<h5><a id="Default_Triggers_of_WindowAssigners__496"></a>Default Triggers of WindowAssigners 窗口分配中的默认触发器</h5> 
<p>  WindowAssigner的默认触发器适用于许多用例。 例如，所有事件时窗口分配器都将EventTimeTrigger作为默认触发器。 一旦水印通过窗口的末端，该触发器就会触发。<br> <em><strong>注意：</strong></em> GlobalWindow的默认触发器是NeverTrigger，它永远不会触发。 因此，在使用GlobalWindow时，你始终必须定义自定义触发器。<br> <em><strong>注意：</strong></em> 通过使用trigger() 指定触发器，您将覆盖WindowAssigner的默认触发器。 例如，如果为TumblingEventTimeWindows指定CountTrigger，则不会再根据时间进度获取窗口，而只能按count计数。 现在，如果你想根据时间和数量做出反应，你必须编写自己的自定义触发器。</p> 
<h5><a id="Buildin_and_Custom_Triggers_500"></a>内置的和自定义的触发器(Build-in and Custom Triggers)</h5> 
<p>  Flink有一些内置的触发器:</p> 
<ul><li>EventTimeTrigger(前面提到过)触发是根据由水印衡量的事件时间的进度来的</li><li>ProcessingTimeTrigger 根据处理时间来触发</li><li>CountTrigger 一旦窗口中的元素个数超出了给定的限制就会触发</li><li>PurgingTrigger 作为另一个触发器的参数并将它转换成一个清除类型</li></ul> 
<p>如果你想实现一个自定义的触发器，你需要查看一下这个抽象类<a href="https://github.com/apache/flink/blob/master//flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/triggers/Trigger.java">Trigger</a></p> 
<h5><a id="Evictors_509"></a>Evictors驱逐器</h5> 
<p>  Flink的窗口模型允许指定一个除了WindowAssigner和Trigger之外的可选参数Evitor，这个可以通过调用evitor(…)方法(在这篇文档的开头展示过)来实现。这个驱逐器(evitor)可以在触发器触发之前或者之后，或者窗口函数被应用之前清理窗口中的元素。为了达到这个目的，Evitor接口有两个方法:</p> 
<pre><code>/**
 * Optionally evicts elements. Called before windowing function.
 *
 * @param elements The elements currently in the pane.
 * @param size The current number of elements in the pane.
 * @param window The {@link Window}
 * @param evictorContext The context for the Evictor
 */
void evictBefore(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext);

/**
 * Optionally evicts elements. Called after windowing function.
 *  * @param elements The elements currently in the pane.
 * @param size The current number of elements in the pane.
 * @param window The {@link Window}
 * @param evictorContext The context for the Evictor
 */
void evictAfter(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext);
</code></pre> 
<p>  evitorBefore()方法包含了在window function之前被应用的驱逐逻辑，而evitorAfter()方法包含了在window function之后被应用的驱逐逻辑。在window function应用之前被驱逐的元素将不会再被window function处理。<br> Flink有三个预实现的驱逐器，他们是:</p> 
<ul><li>CountEvictor: 在窗口中保持一个用户指定数量的元素，并在窗口的开始处丢弃剩余的其他元素。</li><li>DeltaEvictor: 通过一个DeltaFunction和一个阈值，计算窗口缓存中最近的一个元素和剩余的所有元素的delta值，并清除delta值大于或者等于阈值的元素。</li><li>TimeEvictor: 使用一个interval的毫秒数作为参数，对于一个给定的窗口，它会找出元素中的最大时间戳max_ts，并清除时间戳小于max_tx - interval的元素。</li></ul> 
<p><em><strong>默认情况下:</strong></em> 所有预实现的evitor都是在window function前应用它们的逻辑。<br> <em><strong>注意：</strong></em> 指定一个Evitor要防止预聚合，因为窗口中的所有元素必须得在计算之前传递到驱逐器中。<br> <em><strong>注意：</strong></em> Flink 并不保证窗口中的元素是有序的，所以驱逐器可能从窗口的开始处清除，元素到达的先后不是那么必要。</p> 
<h5><a id="Allowed_Lateness_542"></a>允许延迟(Allowed Lateness)</h5> 
<p>  当处理事件时间的window时，可能会出现元素到达晚了，Flink用来与事件时间联系的水印已经过了元素所属的窗口的最后时间。可以查看事件时间( <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/event_time.html" rel="nofollow">event time</a>)尤其是晚到元素(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/event_time.html#late-elements" rel="nofollow">late elements</a>)来了解Flink如何处理事件时间的讨论。<br>   默认情况下，当水印已经过了窗口的最后时间时晚到的元素会被丢弃。然而，Flink允许为窗口操作指定一个最大允许时延，允许时延指定了元素可以晚到多长时间，默认情况下是0。水印已经过了窗口最后时间后才来的元素，如果还未到窗口最后时间加时延时间，那么元素任然添加到窗口中。如果依赖触发器的使用的话，晚到但是未丢弃的元素可能会导致窗口再次被触发。<br>   为了达到这个目的，Flink将保持窗口的状态直到允许时延的发生，一旦发生，Flink将清除Window，删除window的状态，如Window 生命周期章节中所描述的那样。<br> 默认情况下，允许时延为0，也就是说水印之后到达的元素将被丢弃。你可以按如下方式来指定一个允许时延：</p> 
<p>Java 代码:</p> 
<pre><code>DataStream&lt;T&gt; input = ...;

input
    .keyBy(&lt;key selector&gt;)
    .window(&lt;window assigner&gt;)
    .allowedLateness(&lt;time&gt;)
    .&lt;windowed transformation&gt;(&lt;window function&gt;);
</code></pre> 
<p><em><strong>注意:</strong></em> 当使用GlobalWindows分配器时，没有数据会被认为是延迟的，因为Global Window的最后时间是Long.MAX_VALUE。</p> 
<h5><a id="Getting_Late_Data_as_a_Site_Output_560"></a>以侧输出来获取延迟数据(Getting Late Data as a Site Output)</h5> 
<p>  使用Flink的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/side_output.html" rel="nofollow">侧输出</a>特性，你可以获得一个已经被丢弃的延迟数据流。<br>   首先你需要在窗口化的数据流中调用sideOutputLateData(OutputTag)指定你需要获取延迟数据，然后，你就可以在window 操作的结果中获取到侧输出流了（side-output stream ）。<br> 代码如下：</p> 
<pre><code>final OutputTag&lt;T&gt; lateOutputTag = new OutputTag&lt;T&gt;("late-data"){};

DataStream&lt;T&gt; input = ...;

SingleOutputStreamOperator&lt;T&gt; result = input
    .keyBy(&lt;key selector&gt;)
    .window(&lt;window assigner&gt;)
    .allowedLateness(&lt;time&gt;)
    .sideOutputLateData(lateOutputTag)
    .&lt;windowed transformation&gt;(&lt;window function&gt;);

DataStream&lt;T&gt; lateStream = result.getSideOutput(lateOutputTag);
</code></pre> 
<h5><a id="Late_elements_considerations_578"></a>延迟元素考虑Late elements considerations</h5> 
<p>  当指定一个允许延迟大于0时，window以及window中的内容将会继续保持即使水印已经达到了window的最后时间。在这种情况下，当一个延迟事件到来而未丢弃时，它可能会触发window中的其他触发器。这些触发叫做late firings，因为它们是由延迟事件触发的，并相对于window中第一个触发即主触发而言。对于session window而言，late firing还会进一步导致window的合并，因为它们桥接了两个之前存在差距，而未合并的window。</p> 
<h5><a id="Working_with_window_results_581"></a>使用窗口结果Working with window results</h5> 
<p>  窗口操作的结果同样是一个DataStream，没有关于窗口操作的信息保留在结果元素中，因此如果要保留有关窗口的元信息，则必须在ProcessWindowFunction的结果元素中手动编码该信息。在结果元素上设置的唯一相关信息是元素时间戳。这被设置为已处理窗口的最大允许时间戳，即结束时间戳-1，因为窗口结束时间戳是独占的。请注意，事件时间窗口和处理时间窗口都是如此。即，在窗口化操作元素之后总是具有时间戳，但是这可以是事件时间时间戳或处理时间时间戳。对于处理时间窗口，这没有特别的含义，但对于事件时间窗口，这与水印与窗口交互的方式一起使得能够以相同的窗口大小进行连续的窗口操作。在看了水印如何与窗口交互后，我们将介绍这一点。</p> 
<h5><a id="_Interaction_of_watermarks_and_windows_583"></a>水印和窗户的互动 Interaction of watermarks and windows</h5> 
<p>  当水印到达窗口操作符时，会触发两件事：</p> 
<ul><li>水印触发计算所有窗口，其中最大时间戳（即结束时间戳-1）小于新水印</li><li>水印被转发（按原样）到下游操作</li></ul> 
<p>直观地，水印“超出”任何窗口，一旦接收到该水印时间，将在下游操作中被认为是迟到的。</p> 
<h5><a id="_Consecutive_windowed_operations_590"></a>连续窗口操作 Consecutive windowed operations</h5> 
<p>  如前所述，计算窗口结果的时间戳的方式以及水印与窗口交互的方式允许将连续的窗口操作串联在一起。 当您想要执行两个连续的窗口操作时，这可能很有用，您希望使用不同的键，但仍希望来自同一上游窗口的元素最终位于同一下游窗口中。 考虑这个例子：</p> 
<pre><code>DataStream&lt;Integer&gt; input = ...;

DataStream&lt;Integer&gt; resultsPerKey = input
    .keyBy(&lt;key selector&gt;)
    .window(TumblingEventTimeWindows.of(Time.seconds(5)))
    .reduce(new Summer());

DataStream&lt;Integer&gt; globalResults = resultsPerKey
    .windowAll(TumblingEventTimeWindows.of(Time.seconds(5)))
    .process(new TopKWindowFunction());
</code></pre> 
<p>  在该示例中，来自第一操作的时间窗口[0,5]的结果也将在随后的窗口化操作中以时间窗口[0,5]结束。 这允许计算每个键的和，然后在第二个操作中计算同一窗口内的前k个元素。</p> 
<h5><a id="Useful_state_size_considerations_606"></a>使用状态大小的考虑(Useful state size considerations)</h5> 
<p>  window 可以定义一个很长的周期(例如：一天、一周或者一月)，因此积累了相当大的状态。这里有些规则，当估计你的窗口计算的存储要求时，需要记住。<br> 　　1、Flink会在每个窗口中为每个属于它的元素创建一份备份，鉴于此，滚动窗口保存了每个元素的一个备份，与此相反，滑动窗口会为每个元素创建几个备份，如Window Assigner章节所述。因此，一个窗口大小为1天，滑动大小为1秒的滑动窗口可能就不是个好的策略了。<br> 　　2、FoldFunction和ReduceFunction可以制定reduce的存储需求，因为它们预聚合元素并且每个窗口只保存一个值。相反，只有WindowFunction需要累积所有的元素。<br> 　　3、使用Evitor需要避免任何预聚合操作，因为窗口中的所有元素都需要在应用于计算之前传递到evitor中（<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/operators/windows.html#evictors" rel="nofollow">evitor</a>）</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/686bdae2cf7f6730c12312aac6bb1307/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git log命令常用参数集合</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dde9870b5df67a1fbca0767ff97f2538/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网易 Airtest Project 自动化测试框架学习（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>