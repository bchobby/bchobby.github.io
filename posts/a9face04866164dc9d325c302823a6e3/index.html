<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于MATLAB的车牌识别 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于MATLAB的车牌识别" />
<meta property="og:description" content="目录
车牌识别系统的介绍与展示 车牌定位
1.灰度处理
2.边缘检测 车牌分割
1.图像腐蚀
2.图像平滑
3.移除对象
4.图像切割
车牌识别
1.灰度处理
2.直方图均衡化
3.二值化
4.中值滤波
5.字符识别
车牌识别系统的介绍与展示 车牌识别技术的推广普及对加强道路管理、城市交通事故、违章停车、处理车辆被盗案件、保障社会稳定等方面有非常重大的影响。恰逢今年学习了《数字图像处理》课程，利用一些数字图像处理的知识并借鉴网络上诸多算法开发了一个车牌识别系统，并且借用MATLAB的APP designer平台搭建了一个车牌识别的app。（此app目前对一部分图片可以准确识别，但是其他图片效果一般，正在持续改进中......如有进展，后续会进行更新）
一个完整的车牌号识别系统要完成从图像采集到字符识别输出，过程相当复杂，基本可以分成硬件部分和软件部分，硬件部分包括系统触发、图像采集，软件部分一般包括车牌定位、车牌分割和车牌识别三个部分。本文主要介绍软件处理部分，下面是一个车牌识别后的运行结果图：
车牌定位 1.灰度处理 由于彩色图不易确定车牌边界，将彩色图转换为灰度图以进一步处理图片。这里使用了rgb2gray函数，该函数接收一个rgb图像变量作为参数，返回该图像转换为灰度图后的图像数据，并将该数据赋值给变量I1。
若想得到该灰度图的灰度分布情况，可使用imhist函数画出该灰度图的灰度值分布直方图。（此处不再展示）
%% 灰度处理 img1 = rgb2gray(img); % RGB图像转灰度图像 figure; subplot(1, 2, 1); imshow(img1); title(&#39;灰度图像&#39;); subplot(1, 2, 2); imhist(img1); title(&#39;灰度处理后的灰度直方图&#39;); 2.边缘检测 在将彩色图转换为灰度图后，便可用edge函数识别该图像的边界，edge函数通过使用一阶导数和二阶导数检测亮度的不连续来确定图像的边界，它可以使用Sobel,Prewitt,Roberts,Canny,LoG,零交叉等多种算子，这里使用Roberts算子进行边缘检测。
%% 边缘检测 img4 = edge(img1, &#39;roberts&#39;, 0.15, &#39;both&#39;); figure(&#39;name&#39;,&#39;边缘检测&#39;); imshow(img4); title(&#39;roberts算子边缘检测&#39;); 车牌分割 1.图像腐蚀 由于边缘检测后的图像中无关结构太多，这里需对图像进行腐蚀处理，实现腐蚀处理的函数为imerode，它接收一个图像数据和一个结构子，图像中背景与结构子完全重合的像素点输出值为1，不完全重合的和完全不重合的像素点输出值为0，最后返回使用该结构子腐蚀过后的图像数据，以此实现削减无关结构的目的。
%% 图像腐蚀 se=[1;1;1]; img5 = imerode(img4, se); figure(&#39;name&#39;,&#39;图像腐蚀&#39;); imshow(img5); title(&#39;图像腐蚀后的图像&#39;); 2.图像平滑 腐蚀后的图像结构大多呈分散状分布，不连贯。为了方便之后确认车牌位置，这里需对该图像进行平滑处理，在此我们使用闭操作使车牌平滑，并减小噪音，闭操作可以理解为先膨胀后腐蚀，实现函数为imclose。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/a9face04866164dc9d325c302823a6e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-14T17:42:03+08:00" />
<meta property="article:modified_time" content="2023-06-14T17:42:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于MATLAB的车牌识别</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%B1%95%E7%A4%BA%C2%A0%20%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%B1%95%E7%A4%BA%C2%A0%20%C2%A0" rel="nofollow">车牌识别系统的介绍与展示   </a></p> 
<p id="%E2%80%8B%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%C2%A0-toc" style="margin-left:0px;"></p> 
<p id="%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%C2%A0" rel="nofollow">车牌定位</a></p> 
<p id="1.%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#1.%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86" rel="nofollow">1.灰度处理</a></p> 
<p id="2.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%C2%A0-toc" style="margin-left:80px;"><a href="#2.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%C2%A0" rel="nofollow"> 2.边缘检测 </a></p> 
<p id="2.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%C2%A0-toc" style="margin-left:40px;"><a href="#2.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%C2%A0" rel="nofollow">车牌分割</a></p> 
<p id="1.%E5%9B%BE%E5%83%8F%E8%85%90%E8%9A%80-toc" style="margin-left:80px;"><a href="#1.%E5%9B%BE%E5%83%8F%E8%85%90%E8%9A%80" rel="nofollow">1.图像腐蚀</a></p> 
<p id="2.%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91-toc" style="margin-left:80px;"><a href="#2.%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91" rel="nofollow">2.图像平滑</a></p> 
<p id="3.%E7%A7%BB%E9%99%A4%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#3.%E7%A7%BB%E9%99%A4%E5%AF%B9%E8%B1%A1" rel="nofollow">3.移除对象</a></p> 
<p id="4.%E5%9B%BE%E5%83%8F%E5%88%87%E5%89%B2-toc" style="margin-left:80px;"><a href="#4.%E5%9B%BE%E5%83%8F%E5%88%87%E5%89%B2" rel="nofollow">4.图像切割</a></p> 
<p id="%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB-toc" style="margin-left:40px;"><a href="#%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB" rel="nofollow">车牌识别</a></p> 
<p id="1.%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#1.%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86" rel="nofollow">1.灰度处理</a></p> 
<p id="2.%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96" rel="nofollow">2.直方图均衡化</a></p> 
<p id="3.%E4%BA%8C%E5%80%BC%E5%8C%96-toc" style="margin-left:80px;"><a href="#3.%E4%BA%8C%E5%80%BC%E5%8C%96" rel="nofollow">3.二值化</a></p> 
<p id="4.%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2-toc" style="margin-left:80px;"><a href="#4.%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2" rel="nofollow">4.中值滤波</a></p> 
<p id="5.%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB-toc" style="margin-left:80px;"><a href="#5.%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB" rel="nofollow">5.字符识别</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%B1%95%E7%A4%BA%C2%A0%20%C2%A0">车牌识别系统的介绍与展示   </h3> 
<p>        车牌识别技术的推广普及对加强道路管理、城市交通事故、违章停车、处理车辆被盗案件、保障社会稳定等方面有非常重大的影响。恰逢今年学习了《数字图像处理》课程，利用一些数字图像处理的知识并借鉴网络上诸多算法开发了一个车牌识别系统，并且借用MATLAB的APP designer平台搭建了一个车牌识别的app。（<span style="color:#fe2c24;">此app目前对一部分图片可以准确识别，但是其他图片效果一般，正在持续改进中......如有进展，后续会进行更新</span>）</p> 
<p>        一个完整的车牌号识别系统要完成从图像采集到字符识别输出，过程相当复杂，基本可以分成硬件部分和软件部分，硬件部分包括系统触发、图像采集，软件部分一般包括车牌定位、车牌分割和车牌识别三个部分。本文主要介绍软件处理部分，下面是一个车牌识别后的运行结果图：</p> 
<h2 id="%E2%80%8B%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%C2%A0"></h2> 
<p><img alt="" height="683" src="https://images2.imgbox.com/d5/c4/pxtjezwA_o.png" width="931"></p> 
<p></p> 
<h3 id="%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%C2%A0">车牌定位</h3> 
<h4 id="1.%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86">1.灰度处理</h4> 
<p>        由于彩色图不易确定车牌边界，将彩色图转换为灰度图以进一步处理图片。这里使用了rgb2gray函数，该函数接收一个rgb图像变量作为参数，返回该图像转换为灰度图后的图像数据，并将该数据赋值给变量I1。</p> 
<p>        若想得到该灰度图的灰度分布情况，可使用imhist函数画出该灰度图的灰度值分布直方图。（此处不再展示）</p> 
<pre><code class="language-cs">%% 灰度处理
img1 = rgb2gray(img);    % RGB图像转灰度图像
figure;
subplot(1, 2, 1);
imshow(img1);
title('灰度图像');
subplot(1, 2, 2);
imhist(img1);
title('灰度处理后的灰度直方图');</code></pre> 
<h4 id="2.%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%C2%A0"> 2.边缘检测 </h4> 
<p>        在将彩色图转换为灰度图后，便可用edge函数识别该图像的边界，edge函数通过使用一阶导数和二阶导数检测亮度的不连续来确定图像的边界，它可以使用Sobel,Prewitt,Roberts,Canny,LoG,零交叉等多种算子，这里使用Roberts算子进行边缘检测。</p> 
<pre><code class="language-cs">%% 边缘检测
img4 = edge(img1, 'roberts', 0.15, 'both');
figure('name','边缘检测');
imshow(img4);
title('roberts算子边缘检测');</code></pre> 
<hr> 
<h3>车牌分割</h3> 
<h4 id="1.%E5%9B%BE%E5%83%8F%E8%85%90%E8%9A%80">1.图像腐蚀</h4> 
<p>        由于边缘检测后的图像中无关结构太多，这里需对图像进行腐蚀处理，实现腐蚀处理的函数为imerode，它接收一个图像数据和一个结构子，图像中背景与结构子完全重合的像素点输出值为1，不完全重合的和完全不重合的像素点输出值为0，最后返回使用该结构子腐蚀过后的图像数据，以此实现削减无关结构的目的。</p> 
<pre><code class="language-cs">%% 图像腐蚀
se=[1;1;1];
img5 = imerode(img4, se);
figure('name','图像腐蚀');
imshow(img5);
title('图像腐蚀后的图像');
</code></pre> 
<h4 id="2.%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91">2.图像平滑</h4> 
<p>        腐蚀后的图像结构大多呈分散状分布，不连贯。为了方便之后确认车牌位置，这里需对该图像进行平滑处理，在此我们使用闭操作使车牌平滑，并减小噪音，闭操作可以理解为先膨胀后腐蚀，实现函数为imclose。</p> 
<pre><code class="language-cs">%% 平滑图像
se = strel('rectangle', [30, 30]);
img6 = imclose(img5, se);
figure('name','平滑处理');
imshow(img6);
title('平滑图像的轮廓');</code></pre> 
<h4 id="3.%E7%A7%BB%E9%99%A4%E5%AF%B9%E8%B1%A1">3.移除对象</h4> 
<pre><code class="language-cs">%% 从图像中删除所有少于2200像素8邻接
img7 = bwareaopen(img6, 2200);
figure('name', '移除小对象');
imshow(img7);
title('从图像中移除小对象');</code></pre> 
<h4 id="4.%E5%9B%BE%E5%83%8F%E5%88%87%E5%89%B2">4.图像切割</h4> 
<p>        在经过上面的处理之后，最初要识别的彩色图像已经变成了以车牌为主要结构的二值图像，我们可以对这种主体结构清晰的二值图像进行扫描，进而确定出车牌的位置。<br>         这里确定车牌位置的思路为：<br>         首先使用size函数得到该图像矩阵的行数y和列数x，用zero函数建立一个y行1列的零矩阵blue_Y，然后使用嵌套循环结构遍历该二值图像的每一个像素点，把每行值为1的像素点（也就是蓝色像素点）的数量分别记录在先前创建的矩阵blue_y中。遍历完之后，找出blue_y矩阵中值最大的元素，它所对应的行即为该二值图像中蓝色像素点最多的行，该行可认为是靠近车牌中心的一行。<br>         然后我们以这一行为起点，分别向上向下逐行扫描，当被扫描到的蓝中白色像素点多于某个值时（该值只是一个用于判断的估计值），继续向上（或向下）扫描，直到扫描到某行中的蓝色像素点数量小于估计值时，停止扫描，并记录这一行的行数，该行数即为车牌的上边界（或下边界）。<br>         同理，我们可以用相同的方法确定出车牌的左边界和右边界。</p> 
<p>        然后将原图按照上述方法确定的坐标进行裁剪，即可得到仅有车牌的图像。</p> 
<pre><code class="language-cs">%% 图像切割
[y, x, z] = size(img7);
img8 = double(img7);    % 转成双精度浮点型

% 车牌的蓝色区域
% Y方向
blue_Y = zeros(y, 1);
for i = 1:y
    for j = 1:x
        if(img8(i, j) == 1) % 判断车牌位置区域
            blue_Y(i, 1) = blue_Y(i, 1) + 1;    % 像素点统计
        end
    end
end

% 找到Y坐标的最小值
img_Y1 = 1;
while (blue_Y(img_Y1) &lt; 5) &amp;&amp; (img_Y1 &lt; y)
    img_Y1 = img_Y1 + 1;
end

% 找到Y坐标的最大值
img_Y2 = y;
while (blue_Y(img_Y2) &lt; 5) &amp;&amp; (img_Y2 &gt; img_Y1)
    img_Y2 = img_Y2 - 1;
end

% x方向
blue_X = zeros(1, x);
for j = 1:x
    for i = 1:y
        if(img8(i, j) == 1) % 判断车牌位置区域
            blue_X(1, j) = blue_X(1, j) + 1;
        end
    end
end

% 找到x坐标的最小值
img_X1 = 1;
while (blue_X(1, img_X1) &lt; 5) &amp;&amp; (img_X1 &lt; x)
    img_X1 = img_X1 + 1;
end

% 找到x坐标的最小值
img_X2 = x;
while (blue_X(1, img_X2) &lt; 5) &amp;&amp; (img_X2 &gt; img_X1)
    img_X2 = img_X2 - 1;
end

% 对图像进行裁剪
img9 = img(img_Y1:img_Y2, img_X1:img_X2, :);
figure('name', '定位剪切图像');
imshow(img9);
title('定位剪切后的彩色车牌图像')

% 保存提取出来的车牌图像
% imwrite(img9, '车牌图像.jpg');</code></pre> 
<hr> 
<h3 id="%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB">车牌识别</h3> 
<h4>1.灰度处理</h4> 
<pre><code class="language-cs">% 转换成灰度图像
plate_img1 = rgb2gray(img9);    % RGB图像转灰度图像
figure;
subplot(1, 2, 1);
imshow(plate_img1);
title('灰度图像');
subplot(1, 2, 2);
imhist(plate_img1);
title('灰度处理后的灰度直方图');</code></pre> 
<h4 id="2.%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96">2.直方图均衡化</h4> 
<p>        为了使识别更加准确，我们将上一步得到的直方图使用histeq函数进行均衡化，增强图像的对比度。</p> 
<pre><code class="language-cs">% 直方图均衡化
plate_img2 = histeq(plate_img1);
figure('name', '直方图均衡化');
subplot(1,2,1);
imshow(plate_img2);
title('直方图均衡化的图像');
subplot(1,2,2);
imhist(plate_img2);
title('直方图');</code></pre> 
<h4 id="3.%E4%BA%8C%E5%80%BC%E5%8C%96">3.二值化</h4> 
<p>        为了便于将其中的字符分离，我们将它转换为二值图像</p> 
<pre><code class="language-cs">% 二值化处理
plate_img3 = im2bw(plate_img2, 0.76);
figure('name', '二值化处理');
imshow(plate_img3);
title('车牌二值图像');</code></pre> 
<h4 id="4.%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2">4.中值滤波</h4> 
<p>        在车牌转换为二值图像后，为了使图像中干扰元素减少，我们对其进行中值滤波，以减小图中噪音。</p> 
<pre><code class="language-cs">% 中值滤波
plate_img4 = medfilt2(plate_img3);
figure('name', '中值滤波');
imshow(plate_img4);
title('中值滤波后的图像');
</code></pre> 
<h4 id="5.%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB">5.字符识别</h4> 
<p>        目前用于车牌字符识别的算法主要有基于<span style="color:#fe2c24;">模板匹配</span>的算法以及基于<span style="color:#fe2c24;">人工神经网络（Artificial Neural Networks，ANN）</span>的算法。基于模板匹配的字符识别的基本过程是:首先对待识别字符进行二值化并将其尺寸大小缩放为字符数据库中模板的大小，然后与所有的模板进行匹配，最后选最佳匹配作为结果。用人工神经网络进行字符识别主要有两种方法:一种方法是先对待识别字符进行特征提取，然后用所获得的特征来训练神经网络分类器。识别效果与字符特征的提取有关，而字符特征提取往往比较耗时。因此，字符特征的提取就成为研究的关键。另一种方法则充分利用神经网络的特点，直接把待处理图像输入网络，由网络自动实现特征提取直至识别。</p> 
<p>        模板匹配的主要特点是实现简单，当字符较规整时对字符图像的缺损、污迹干扰适应力强且识别率相当高。综合模板匹配的这些优点我们将其用为车牌字符识别的主要方法。</p> 
<p>        模板匹配是图象识别方法中最具代表性的基本方法之一，它是将从待识别的图象或图象区域f(i,j)中提取的若干特征量与模板T(i,j)相应的特征量逐个进行比较，计算它们之间规格化的互相关量，其中互相关量最大的一个就表示期间相似程度最高，可将图象归于相应的类。也可以计算图象与模板特征量之间的距离，用最小距离法判定所属类。然而，通常情况下用于匹配的图象各自的成像条件存在差异，产生较大的噪声干扰，或图象经预处理和规格化处理后，使得图象的灰度或像素点的位置发生改变。在实际设计模板的时候，是根据各区域形状固有的特点，突出各类似区域之间的差别，并将容易由处理过程引起的噪声和位移等因素都考虑进去，按照一些基于图象不变特性所设计的特征量来构建模板，就可以避免上述问题。</p> 
<p>        此处采用相减的方法来求得字符与模板中哪一个字符最相似，然后找到相似度最大的输出。汽车牌照的字符一般有七个，大部分车牌第一位是汉字，通常代表车辆所属省份，或是军种、警别等有特定含义的字符简称；紧接其后的为字母与数字。车牌字符识别与一般文字识别在于它的字符数有限，汉字共约50多个，大写英文字母26个，数字10个。所以建立字符模板库也极为方便。为了实验方便，结合本次设计所选汽车牌照的特点，只建立了7个汉字26个字母与10个数字的模板。其他模板设计的方法与此相同。</p> 
<p>        首先取字符模板，接着依次取待识别字符与模板进行匹配，将其与模板字符相减，得到的0越多那么就越匹配。把每一幅相减后的图的0值个数保存，然后找数值最大的，即为识别出来的结果。</p> 
<pre><code class="language-cs">%% 字符识别
plate_img5 = my_imsplit(plate_img4);
[m, n] = size(plate_img5);

s = sum(plate_img5);    %sum(x)就是竖向相加，求每列的和，结果是行向量;
j = 1;
k1 = 1;
k2 = 1;
while j ~= n
    while s(j) == 0
        j = j + 1;
    end
    k1 = j;
    while s(j) ~= 0 &amp;&amp; j &lt;= n-1
        j = j + 1;
    end
    k2 = j + 1;
    if k2 - k1 &gt; round(n / 6.5)
        [val, num] = min(sum(plate_img5(:, [k1+5:k2-5])));
        plate_img5(:, k1+num+5) = 0;
    end
end

y1 = 10;
y2 = 0.25;
flag = 0;
word1 = [];
while flag == 0
    [m, n] = size(plate_img5);
    left = 1;
    width = 0;
    while sum(plate_img5(:, width+1)) ~= 0
        width = width + 1;
    end
    if width &lt; y1
        plate_img5(:, [1:width]) = 0;
        plate_img5 = my_imsplit(plate_img5);
    else
        temp = my_imsplit(imcrop(plate_img5, [1,1,width,m]));
        [m, n] = size(temp);
        all = sum(sum(temp));
        two_thirds=sum(sum(temp([round(m/3):2*round(m/3)],:)));
        if two_thirds/all &gt; y2
            flag = 1;
            word1 = temp;
        end
        plate_img5(:, [1:width]) = 0;
        plate_img5 = my_imsplit(plate_img5);
    end
end

figure;
subplot(2,4,1), imshow(plate_img5);

 % 分割出第二个字符
 [word2,plate_img5]=getword(plate_img5);
 subplot(2,4,2), imshow(plate_img5);
 % 分割出第三个字符
 [word3,plate_img5]=getword(plate_img5);
 subplot(2,4,3), imshow(plate_img5);
 % 分割出第四个字符
 [word4,plate_img5]=getword(plate_img5);
 subplot(2,4,4), imshow(plate_img5);
 % 分割出第五个字符
 [word5,plate_img5]=getword(plate_img5);
 subplot(2,3,4), imshow(plate_img5);
 % 分割出第六个字符
 [word6,plate_img5]=getword(plate_img5);
 subplot(2,3,5), imshow(plate_img5);
 % 分割出第七个字符
 [word7,plate_img5]=getword(plate_img5);
 subplot(2,3,6), imshow(plate_img5);

 figure;
 subplot(5,7,1),imshow(word1),title('1');
 subplot(5,7,2),imshow(word2),title('2');
 subplot(5,7,3),imshow(word3),title('3');
 subplot(5,7,4),imshow(word4),title('4');
 subplot(5,7,5),imshow(word5),title('5');
 subplot(5,7,6),imshow(word6),title('6');
 subplot(5,7,7),imshow(word7),title('7');

 word1=imresize(word1,[40 20]);%imresize对图像做缩放处理，常用调用格式为：B=imresize(A,ntimes,method)；其中method可选nearest,bilinear（双线性）,bicubic,box,lanczors2,lanczors3等
 word2=imresize(word2,[40 20]);
 word3=imresize(word3,[40 20]);
 word4=imresize(word4,[40 20]);
 word5=imresize(word5,[40 20]);
 word6=imresize(word6,[40 20]);
 word7=imresize(word7,[40 20]);

 subplot(5,7,15),imshow(word1),title('11');
 subplot(5,7,16),imshow(word2),title('22');
 subplot(5,7,17),imshow(word3),title('33');
 subplot(5,7,18),imshow(word4),title('44');
 subplot(5,7,19),imshow(word5),title('55');
 subplot(5,7,20),imshow(word6),title('66');
 subplot(5,7,21),imshow(word7),title('77');
 
 imwrite(word1,'1.jpg'); % 创建七位车牌字符图像
 imwrite(word2,'2.jpg');
 imwrite(word3,'3.jpg');
 imwrite(word4,'4.jpg');
 imwrite(word5,'5.jpg');
 imwrite(word6,'6.jpg');
 imwrite(word7,'7.jpg');
 
 %% 进行字符识别
 liccode=char(['0':'9' 'A':'Z' '京辽鲁陕苏豫浙贵']);%建立自动识别字符代码表；'京津沪渝港澳吉辽鲁豫冀鄂湘晋青皖苏赣浙闽粤琼台陕甘云川贵黑藏蒙桂新宁'
 % 编号：0-9分别为 1-10;A-Z分别为 11-36;
 % 京  津  沪  渝  港  澳  吉  辽  鲁  豫  冀  鄂  湘  晋  青  皖  苏
 % 赣  浙  闽  粤  琼  台  陕  甘  云  川  贵  黑  藏  蒙  桂  新  宁
 % 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 
 % 60 61 62 63 64 65 66 67 68 69 70
 subBw2 = zeros(40, 20);
 num = 1;   % 车牌位数
 for i = 1:7
    ii = int2str(i);    % 将整型数据转换为字符串型数据
    word = imread([ii,'.jpg']); % 读取之前分割出的字符的图片
    segBw2 = imresize(word, [40,20], 'nearest');    % 调整图片的大小
    segBw2 = im2bw(segBw2, 0.5);    % 图像二值化
    if i == 1   % 字符第一位为汉字，定位汉字所在字段
        kMin = 37;
        kMax = 44;
    elseif i == 2   % 第二位为英文字母，定位字母所在字段
        kMin = 11;
        kMax = 36;
    elseif i &gt;= 3   % 第三位开始就是数字了，定位数字所在字段
        kMin = 1;
        kMax = 36;
    end
    
    l = 1;
    for k = kMin : kMax
        fname = strcat('字符模板\',liccode(k),'.jpg');  % 根据字符库找到图片模板
        samBw2 = imread(fname); % 读取模板库中的图片
        samBw2 = im2bw(samBw2, 0.5);    % 图像二值化
        
        % 将待识别图片与模板图片做差
        for i1 = 1:40
            for j1 = 1:20
                subBw2(i1, j1) = segBw2(i1, j1) - samBw2(i1 ,j1);
            end
        end
        
        % 统计两幅图片不同点的个数，并保存下来
        Dmax = 0;
        for i2 = 1:40
            for j2 = 1:20
                if subBw2(i2, j2) ~= 0
                    Dmax = Dmax + 1;
                end
            end
        end
        error(l) = Dmax;
        l = l + 1;
    end
    
    % 找到图片差别最少的图像
    errorMin = min(error);
    findc = find(error == errorMin);
%     error
%     findc
       
    % 根据字库，对应到识别的字符
    Code(num*2 - 1) = liccode(findc(1) + kMin - 1);
    Code(num*2) = ' ';
    num = num + 1;
    
    
 end
 
 % 显示识别结果
 disp(Code);
 msgbox(Code,'识别出的车牌号');</code></pre> 
<p>        我这里有之前做好的代码（有可视化app）以及配套的项目报告和答辩PPT，需要的请私信我</p> 
<p>写在最后：</p> 
<p>        此系统参考CSDN及网络上诸多算法，我将其进行整合修改和调试，目前运行非常顺畅，对一些图片识别效果很好，<span style="color:#fe2c24;">但是其他图片效果一般，正在持续改进中......</span>若有不当之处，希望大家多多指正！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2d31f1fa22bd1005e22bdf041fef3f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记录一下js中substring方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9488acc4a19e5299b494b0abc71d5898/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">干掉复杂的工具类，Hutool 工具库确实香</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>