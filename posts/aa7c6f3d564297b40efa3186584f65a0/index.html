<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多数据源切换-Druid - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多数据源切换-Druid" />
<meta property="og:description" content="这是实际应用场景中的多数据源切换案例
逻辑思路如下：
1.系统初始化，加载所有数据库中配置的数据源，加载进去spring容器
2.通过两种方法切换数据源：
2.1MultipleDataSource.setDataSourceKey(dataSourceKey);//切换 MultipleDataSource.clearDataSourceKey();//清除当前数据源并且还原到默认数据库 2.2使用@SwitchDataSource(name=&#34;dateSourceKey&#34;)注解
&lt;beans&gt; &lt;-- 配置默认数据源 --&gt; &lt;context:property-placeholder location=&#34;classpath*:jdbc.properties&#34;/&gt; &lt;bean id=&#34;dataSource&#34; class=&#34;com.alibaba.druid.pool.DruidDataSource&#34; init-method=&#34;init&#34; destroy-method=&#34;close&#34;&gt; &lt;property name=&#34;driverClassName&#34; value=&#34;${jdbc.driverClassName}&#34;/&gt; &lt;property name=&#34;url&#34; value=&#34;${jdbc.url}&#34;/&gt; &lt;property name=&#34;username&#34; value=&#34;${jdbc.username}&#34;/&gt; &lt;property name=&#34;password&#34; value=&#34;${jdbc.password}&#34;/&gt; &lt;property name=&#34;minIdle&#34; value=&#34;${rapid.jdbcPool.minPoolSize}&#34;/&gt; &lt;property name=&#34;maxActive&#34; value=&#34;${rapid.jdbcPool.maxPoolSize}&#34;/&gt; &lt;property name=&#34;initialSize&#34; value=&#34;${rapid.jdbcPool.initialPoolSize}&#34;/&gt;&lt;!-- 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时,default=0 --&gt; &lt;property name=&#34;maxWait&#34; value=&#34;${rapid.jdbcPool.maxWait}&#34;/&gt;&lt;!-- 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁 --&gt; &lt;property name=&#34;timeBetweenEvictionRunsMillis&#34; value=&#34;${rapid.jdbcPool.timeBetweenEvictionRunsMillise}&#34;/&gt;&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，毫秒 --&gt; &lt;property name=&#34;minEvictableIdleTimeMillis&#34; value=&#34;${rapid.jdbcPool.minEvictableIdleTimeMillis}&#34;/&gt;&lt;!-- 配置一个连接在池中最小生存的时间，毫秒 --&gt; &lt;!-- 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效 --&gt; &lt;property name=&#34;testWhileIdle&#34; value=&#34;${rapid.jdbcPool.testWhileIdle}&#34;/&gt; &lt;property name=&#34;testOnBorrow&#34; value=&#34;false&#34;/&gt; &lt;property name=&#34;testOnReturn&#34; value=&#34;false&#34;/&gt; &lt;!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/aa7c6f3d564297b40efa3186584f65a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-11T16:15:46+08:00" />
<meta property="article:modified_time" content="2019-01-11T16:15:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多数据源切换-Druid</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这是实际应用场景中的多数据源切换案例</p> 
<p>逻辑思路如下：</p> 
<p>1.系统初始化，加载所有数据库中配置的数据源，加载进去spring容器</p> 
<p>2.通过两种方法切换数据源：</p> 
<pre class="has"><code class="language-html">2.1MultipleDataSource.setDataSourceKey(dataSourceKey);//切换</code></pre> 
<pre class="has"><code class="language-html">MultipleDataSource.clearDataSourceKey();//清除当前数据源并且还原到默认数据库</code></pre> 
<p>2.2使用@SwitchDataSource(name="dateSourceKey")注解</p> 
<p> </p> 
<pre class="has"><code class="language-html"> </code></pre> 
<pre class="has"><code class="language-java">&lt;beans&gt;
    &lt;-- 配置默认数据源 --&gt;
&lt;context:property-placeholder location="classpath*:jdbc.properties"/&gt;

&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;

    &lt;property name="minIdle" value="${rapid.jdbcPool.minPoolSize}"/&gt;
    &lt;property name="maxActive" value="${rapid.jdbcPool.maxPoolSize}"/&gt;
    &lt;property name="initialSize"
              value="${rapid.jdbcPool.initialPoolSize}"/&gt;&lt;!-- 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时,default=0 --&gt;
    &lt;property name="maxWait"
              value="${rapid.jdbcPool.maxWait}"/&gt;&lt;!-- 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁 --&gt;

    &lt;property name="timeBetweenEvictionRunsMillis"
              value="${rapid.jdbcPool.timeBetweenEvictionRunsMillise}"/&gt;&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，毫秒 --&gt;
    &lt;property name="minEvictableIdleTimeMillis"
              value="${rapid.jdbcPool.minEvictableIdleTimeMillis}"/&gt;&lt;!-- 配置一个连接在池中最小生存的时间，毫秒 --&gt;

    &lt;!-- 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效 --&gt;
    &lt;property name="testWhileIdle" value="${rapid.jdbcPool.testWhileIdle}"/&gt;
    &lt;property name="testOnBorrow" value="false"/&gt;
    &lt;property name="testOnReturn" value="false"/&gt;

    &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都无效 --&gt;
    &lt;property name="validationQuery" value="${rapid.jdbcPool.validationQuery}"/&gt;

    &lt;!-- #是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭,default=false --&gt;
    &lt;property name="poolPreparedStatements" value="${rapid.jdbcPool.poolPreparedStatements}"/&gt;
    &lt;!-- #要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。
         #在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 --&gt;
    &lt;property name="maxOpenPreparedStatements" value="${rapid.jdbcPool.maxOpenPreparedStatements}"/&gt;

    &lt;!-- #属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：
         监控统计用的filter:stat
         日志用的filter:log4j
         防御sql注入的filter:wall --&gt;
    &lt;!--&lt;property name="filters" value="stat"/&gt;--&gt;
    &lt;property name="timeBetweenLogStatsMillis"
              value="${rapid.jdbcPool.timeBetweenLogStatsMillis}"/&gt;&lt;!-- 定时把监控数据输出到日志中,毫秒 --&gt;
    &lt;property name="proxyFilters"&gt;
        &lt;list&gt;
            &lt;ref bean="stat-filter"/&gt;
            &lt;ref bean="log-filter"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 多数据源切换 --&gt;
&lt;bean id="multipleDataSource" class="cn.core.persistent.hibernate.datasource.MultipleDataSource"&gt;
        &lt;property name="defaultTargetDataSource" ref="dataSource"/&gt;
        &lt;property name="targetDataSources"&gt;
            &lt;map&gt;
                &lt;entry key="dataSource" value-ref="dataSource"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
&lt;/bean&gt;

    &lt;!-- 多数据源注入 --&gt;
&lt;bean id="loadDataSource" class="cn.core.persistent.hibernate.datasource.LoadDataSource"&gt;
        &lt;property name="baseExtendDao" ref="baseExtendDao"/&gt;
&lt;/bean&gt;
&lt;!-- 声明事务 --&gt;
    &lt;bean id="txManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt;
        &lt;property name="dataSource" ref="multipleDataSource"/&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id="myMethod" expression="execution(* cn.*.service..*.*(..))"/&gt;
        &lt;aop:advisor advice-ref="multipleDataSource" order="1"
                     pointcut="execution(* cn.*.service..*.*(..)) and @annotation(cn.core.persistent.hibernate.datasource.SwitchDataSource)"/&gt;
        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myMethod" order="2"/&gt;
    &lt;/aop:config&gt;

    &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="add*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="append*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="insert*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="save*" propagation="REQUIRED"/&gt;

            &lt;tx:method name="delete*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="remove*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="repair*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="delAndRepair*" propagation="REQUIRED"/&gt;

            &lt;tx:method name="update*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="modify*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="edit*" propagation="REQUIRED"/&gt;

            &lt;tx:method name="init*" propagation="REQUIRED"/&gt;
            &lt;tx:method name="test*" propagation="REQUIRED"
                       rollback-for="Exception"/&gt;&lt;!-- 如果不写 rollback-for它弄死都不给你回滚，这个东西弄了半天 --&gt;

            &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true"/&gt;
            &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt;
            &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt;
            &lt;tx:method name="load*" propagation="SUPPORTS" read-only="true"/&gt;
            &lt;tx:method name="search*" propagation="SUPPORTS" read-only="true"/&gt;

            &lt;!--指定当前方法以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，等我以非事务的状态运行完，再继续原来的事务。查询定义即可 read-only="true"  表示只读--&gt;
            &lt;tx:method name="*" propagation="NOT_SUPPORTED" read-only="true"/&gt;

            &lt;!--&lt;tx:method name="logical*" propagation="REQUIRED" /&gt;&amp;lt;!&amp;ndash; 一般指逻辑删除 &amp;ndash;&amp;gt;--&gt;
            &lt;!--&lt;tx:method name="batch*" propagation="REQUIRED" /&gt;&amp;lt;!&amp;ndash; 批量操作 &amp;ndash;&amp;gt;--&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
&lt;/beans&gt;</code></pre> 
<pre class="has"><code class="language-java">import cn.commons.string.StringUtils;
import cn.core.model.datasource.DataSource;
import cn.core.model.logger.DruidSQLLoggerMonitorAppender;
import cn.core.persistent.hibernate.AbstractHibernateDao;
import cn.core.persistent.hibernate.extend.BaseExtendDao;
import com.alibaba.druid.pool.DruidDataSource;
import org.apache.commons.collections.map.HashedMap;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.util.Assert;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * 多数据源加载
 * @bug [nothing]
 * @see [nothing]
 * @备注:
 */
public class LoadDataSource extends AbstractHibernateDao {
	
	protected final Log logger = LogFactory.getLog(getClass());
	
	private BaseExtendDao baseExtendDao;
	
	/**
	 * 加载数据库内配置的数据源
	 * */
	public List&lt;DataSource&gt; selectDataSourceForDateBase() {
		Session session = null;
		try {
			session = super.getSessionFactory().openSession();
                        //查询数据库中所有数据源数据
			Query query = session.getNamedQuery("DataSource.findAll");
			return query.list();
		} catch (Exception e) {
			
		} finally {
			if (session != null) {
				session.flush();
				session.close();
			}
		}
		
		return new ArrayList();
	}
	
	/**
	 * 创建数据源并注入进 spring 容器
	 * */
	public void buiderDataSourceToSpring(ApplicationContext applicationContext) {
		//加载数据源
		//根据数据源,创建 DruidDataSource.class
		//重新创建多数据源
		List&lt;DataSource&gt; listDataSource = this.selectDataSourceForDateBase();
		
		if (listDataSource.size() &gt; 0) {
                        //默认数据源bean的id
			DruidDataSource druidDataSourceDefault = applicationContext.getBean(SwitchDataSource.master, DruidDataSource.class);
			
			Map&lt;Object, Object&gt; targetDataSources = new HashedMap();
			targetDataSources.put(SwitchDataSource.master, druidDataSourceDefault);//支撑库
			
			//Bean的实例工厂
			DefaultListableBeanFactory dbf = (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext).getBeanFactory();
			
			for (Iterator&lt;DataSource&gt; iterator = listDataSource.iterator(); iterator.hasNext(); ) {
				DataSource ds = iterator.next();
				
				//Bean构建  BeanService.class 要创建的Bean的Class对象
				BeanDefinitionBuilder dataSourceBuider = BeanDefinitionBuilder.genericBeanDefinition(DruidDataSource.class);
				
				//向里面的属性注入值，提供get set方法
				toolBuiderDataSourceToSpring(dataSourceBuider, ds);
				
				dataSourceBuider.setInitMethodName("init");
				dataSourceBuider.setDestroyMethodName("close");
				
				//将实例注册spring容器中 key 等同于 id配置
				dbf.registerBeanDefinition(ds.getDataSourceKey(), dataSourceBuider.getBeanDefinition());
				
				
				DruidDataSource druidDataSource = applicationContext.getBean(ds.getDataSourceKey(), DruidDataSource.class);
				targetDataSources.put(ds.getDataSourceKey(), druidDataSource);
				
				logger.info("加载数据源:名称-&gt;[" + ds.getDataSourceKey() + "],url-&gt;[" + druidDataSource.getUrl() + "],driver-&gt;[" + druidDataSource.getDriverClassName() + "],username-&gt;[" + druidDataSource.getUsername() + "]");
			}
			
			//重构多数据源列表
			MultipleDataSource multipleDataSource = applicationContext.getBean("multipleDataSource", MultipleDataSource.class);
			multipleDataSource.setTargetDataSources(targetDataSources);
			multipleDataSource.afterPropertiesSet();
		}
	}
	
	/**
	 * 数据库配置的数据源注入容器
	 *
	 * @title toolBuiderDataSourceToSpring
	 * @param dataSourceBuider spring 容器注入实例
	 *        ds 数据库配置的数据源
	 * @return
	 * @throws
	 */
	private void toolBuiderDataSourceToSpring(BeanDefinitionBuilder dataSourceBuider, DataSource ds) {
		Assert.notNull(ds, "多数据源注入异常 -&gt; 配置的数据源不能为 null!!");
		Assert.notNull(dataSourceBuider, "多数据源注入异常 -&gt; Spring 容器为 null!!");
		
		Assert.hasText(ds.getDriverClassName(), "多数据源加载异常 -&gt; [" + ds.getDataSourceKey() + "] -&gt; [driverClassName is null]");
		Assert.hasText(ds.getUrl(), "多数据源加载异常 -&gt; [" + ds.getDataSourceKey() + "] -&gt; [url is null]");
		Assert.hasText(ds.getUsername(), "多数据源加载异常 -&gt; [" + ds.getDataSourceKey() + "] -&gt; [username is null]");
		Assert.hasText(ds.getPassword(), "多数据源加载异常 -&gt; [" + ds.getDataSourceKey() + "] -&gt; [password is null]");
		
		dataSourceBuider.addPropertyValue("driverClassName", ds.getDriverClassName());
		dataSourceBuider.addPropertyValue("url", ds.getUrl());
		dataSourceBuider.addPropertyValue("username", ds.getUsername());
		dataSourceBuider.addPropertyValue("password", ds.getPassword());
		
		if (StringUtils.hasText(ds.getConnectPoolProperties())) {
			Map map = StringUtils.parseStringToMap(ds.getConnectPoolProperties(), ",", "=");
			
			if (map.containsKey("minPoolSize")) {//最小连接
				dataSourceBuider.addPropertyValue("minIdle", map.get("minPoolSize"));
			}
			
			if (map.containsKey("maxPoolSize")) {//最大连接
				dataSourceBuider.addPropertyValue("maxActive", map.get("maxPoolSize"));
			}
			
			if (map.containsKey("initialPoolSize")) {//初始连接数
				dataSourceBuider.addPropertyValue("initialSize", map.get("initialPoolSize"));
			}
			
			if (map.containsKey("maxWait")) {//获取连接时最大等待时间
				dataSourceBuider.addPropertyValue("maxWait", map.get("maxWait"));
			}
			
			if (map.containsKey("timeBetweenEvictionRunsMillis")) {//配置间隔多久才进行一次检测，检测需要关闭的空闲连接，毫秒
				dataSourceBuider.addPropertyValue("timeBetweenEvictionRunsMillis", map.get("timeBetweenEvictionRunsMillis"));
			}
			
			if (map.containsKey("minEvictableIdleTimeMillis")) {//配置一个连接在池中最小生存的时间，毫秒
				dataSourceBuider.addPropertyValue("minEvictableIdleTimeMillis", map.get("minEvictableIdleTimeMillis"));
			}
			
			//是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭,default=false
			if (map.containsKey("poolPreparedStatements")) {
				dataSourceBuider.addPropertyValue("poolPreparedStatements", map.get("poolPreparedStatements"));
			}
			
			//#要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。
			//#在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100
			if (map.containsKey("maxOpenPreparedStatements")) {
				dataSourceBuider.addPropertyValue("maxOpenPreparedStatements", map.get("maxOpenPreparedStatements"));
			}
			
			//用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都无效
			if (map.containsKey("validationQuery")) {
				String vq = (String) map.get("validationQuery");
				if (StringUtils.hasText(vq)) {
					dataSourceBuider.addPropertyValue("validationQuery", map.get("validationQuery"));
					
					//建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效
					if (map.containsKey("testWhileIdle")) {
						dataSourceBuider.addPropertyValue("testWhileIdle", map.get("testWhileIdle"));
					}
					
					if (map.containsKey("testOnBorrow")) {
						dataSourceBuider.addPropertyValue("testOnBorrow", map.get("testOnBorrow"));
					}
					
					if (map.containsKey("testOnReturn")) {
						dataSourceBuider.addPropertyValue("testOnReturn", map.get("testOnReturn"));
					}
				}
			}
			
			//是否日志打印
			if (map.containsKey("statementExecutableSqlLogEnable")) {
				boolean isStatementExecutableSqlLogEnable = (Boolean) map.get("statementExecutableSqlLogEnable");
				if (isStatementExecutableSqlLogEnable) {
					DruidSQLLoggerMonitorAppender log4jFilter = new DruidSQLLoggerMonitorAppender();
					log4jFilter.setStatementExecutableSqlLogEnable(true);
					
					if (map.containsKey("serializationCurrentThreadExecutableSqlLogEnable")) {
						log4jFilter.setSerializationCurrentThreadExecutableSqlLogEnable((Boolean) map.get("serializationCurrentThreadExecutableSqlLogEnable"));
					}
					
					List list = new ArrayList();
					list.add(log4jFilter);
					dataSourceBuider.addPropertyValue("proxyFilters", list);
				}
			}
		}
	}
	
	public BaseExtendDao getBaseExtendDao() {
		return baseExtendDao;
	}
	
	public void setBaseExtendDao(BaseExtendDao baseExtendDao) {
		this.baseExtendDao = baseExtendDao;
	}
	
}
</code></pre> 
<pre class="has"><code class="language-java">@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface SwitchDataSource {
	String master = "dataSource";
	
	String dataSourceKey() default SwitchDataSource.master;
	
}</code></pre> 
<pre class="has"><code class="language-java">import cn.commons.string.StringUtils;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.*;

/**
 * 多数据源切换
 * @bug [nothing]
 * @see [nothing]
 * @备注:
 */
public class MultipleDataSource extends AbstractRoutingDataSource implements MethodInterceptor {
	
	//保存当前线程使用的数据源
	private static final ThreadLocal&lt;String&gt; dataSourceKey = new InheritableThreadLocal();
	
	//设置数据源
	public static void setDataSourceKey(String dataSourceName) {
		if (StringUtils.hasText(dataSourceName)) {
			MultipleDataSource.dataSourceKey.set(dataSourceName);
		}
	}
	
	//清除数据源,清除后使用默认的支撑库数据源
	public static void clearDataSourceKey() {
		MultipleDataSource.dataSourceKey.remove();
	}
	
	/**
	 *
	 * sessionFactory 加载数据源扩展方法
	 * 详情请看 AbstractRoutingDataSource.determineTargetDataSource() 方法;
	 * 这是一个扩展,返回的是数据源的名称,也就是 spring 配置的 baenName,通过返回的 beanName未找到数据源会直接使用支撑库做为数据源
	 * */
	@Override
	protected Object determineCurrentLookupKey() {
		//这里返回 null或""  没有关系,在 bean-core.xml 我们注入了默认数据源
		return MultipleDataSource.dataSourceKey.get();
	}
	
	/**
	 * 结合 spring aop 与 annotation 动态切换数据源.
	 * 框架通过 Aop 实现了事务管理,那么数据源的切换与事务控制作用于相同的时候方法上,并且优先于事务控制切换数据源.详细配置请参考 beans-core.xml
	 *
	 * 如何使用:
	 * 在需要切换数据源的service层的方法上,配置注解标签,并指定数据源名称,代码如下:
	 * &lt;code&gt;
	 *  @SwitchDataSource(name="dateSourceKey")
	 *  public List getProducts(){
	 *      ...
	 *  }
	 * &lt;/code&gt;
	 */
	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		Object result = null;
		SwitchDataSource switchDataSource = null;
		
		try {
			switchDataSource = invocation.getMethod().getAnnotation(SwitchDataSource.class);//接口方法定义的注解
			if (switchDataSource == null) {
//				Class[] argsClass = new Class[invocation.getArguments().length];
//				for (int i = 0, j = invocation.getArguments().length; i &lt; j; i++) {
//					argsClass[i] = invocation.getArguments()[i].getClass();
//				}
				
				//上面的获取方式有可能来至于接口,这里尝试在实现类获取注解
//				switchDataSource = invocation.getThis().getClass().getMethod(invocation.getMethod().getName(), argsClass).getAnnotation(SwitchDataSource.class);
				
				// 20170526 修改
				// 在接口中定义方法时,一般的形参都会实现父类或者接口.而实现类传入的实参又会是具体的实现类.所以导致直接使用 getMethod(String name, Class&lt;?&gt;... parameterTypes) 是无法获取方法的.
				
				
				//尝试在实现类获取注解
				String methodName = invocation.getMethod().getName();
				Object[] args = invocation.getArguments();//实际参数;如 arraylist
				
				Method[] methods = invocation.getThis().getClass().getMethods();
				for (int i = 0; i &lt; methods.length; i++) {
					if (methods[i].getName().equals(methodName)) {//方法相同
						
						Class[] typeClasss = methods[i].getParameterTypes();//定义的参数类型;如 list
						if (typeClasss.length == args.length) {//参数数量相等
							
							if (typeClasss.length == 0) {//无参情况
								switchDataSource = methods[i].getAnnotation(SwitchDataSource.class);
								break;
							} else {
								boolean isTrue = false;
								//判断所有的参数的类型是否相同
								for (int j = 0; j &lt; args.length; j++) {
									if (typeClasss[j].isAssignableFrom(args[j].getClass())) {
										isTrue = true;
									} else {
										isTrue = false;
										break;
									}
								}
								
								if (isTrue) {
									switchDataSource = methods[i].getAnnotation(SwitchDataSource.class);
									break;
								}
							}
						}
					}
				}
			}
			
			
			if (switchDataSource != null) {
				MultipleDataSource.setDataSourceKey(switchDataSource.dataSourceKey());
			}
			
			result = invocation.proceed();
		} catch (Exception ex) {
			ex.printStackTrace();
		} finally {
			if (switchDataSource != null) {
				MultipleDataSource.clearDataSourceKey();//还原数据源;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		System.out.println(ArrayList.class.isAssignableFrom(List.class));
	}
}
</code></pre> 
<pre class="has"><code class="language-java">//系统初始化加载数据库中的数据源

import javax.servlet.ServletException;

import cn.core.persistent.hibernate.datasource.LoadDataSource;
import cn.core.persistent.hibernate.datasource.MultipleDataSource;
import org.apache.commons.collections.map.HashedMap;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.web.servlet.DispatcherServlet;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 *
 * 提供框架启动初始化扩展功能,继承 DispatcherServlet 并实现 initFrameworkServlet() 方法,该方法原生提供 spring 扩展
 *
 * 目前提供扩展如下:
 * 1.加载多数据源
 * @类名称：RapidFrameWorkServlet
 */
public class RapidFrameWorkServlet extends DispatcherServlet {
	private static final long serialVersionUID = 1L;
	
	/**
	 * 覆写spring的一个方法用来初始化进而得到初始化参数
	 */
	@Override
	public void initFrameworkServlet() throws ServletException {
		try {
			//加载多数据源
			super.getWebApplicationContext().getBean("loadDataSource", LoadDataSource.class).buiderDataSourceToSpring(super.getWebApplicationContext());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}</code></pre> 
<pre class="has"><code class="language-java">&lt;-- 数据库中数据源对象 --&gt;
CREATE TABLE DATASOURCE
(
  DATASOURCE_GUID          VARCHAR2(32 BYTE),
  DATASOURCE_NAME          VARCHAR2(128 BYTE),
  DATASOURCE_KEY           VARCHAR2(128 BYTE)   NOT NULL,
  DRIVER_CLASS_NAME        VARCHAR2(256 BYTE)   NOT NULL,
  URL                      VARCHAR2(512 BYTE)   NOT NULL,
  USERNAME                 VARCHAR2(128 BYTE)   NOT NULL,
  PASSWORD                 VARCHAR2(128 BYTE)   NOT NULL,
  CONNECT_POOL_PROPERTIES  VARCHAR2(1024 BYTE),
  OPERATOR_ID              VARCHAR2(64 BYTE),
  CREATE_TIME              DATE,
  MODIFY_TIME              DATE,
  RES_ACT_MAP_ID           VARCHAR2(64 BYTE),
  VALID_SIGN               NUMBER
)</code></pre> 
<pre class="has"><code class="language-java">//数据源控制层类，在新增数据源后重新加载容器的数据源
public class DataSourceResource implements ApplicationContextAware {
    
    @Resource
    private IDataSourceService dataSourceService;

    @Resource(name="loadDataSource")
    private LoadDataSource loadDataSource;

    private ApplicationContext applicationContext;

    public void setApplicationContext(ApplicationContext paramApplicationContext) throws BeansException {
        applicationContext=paramApplicationContext;
    }

    /**
     * 添加数据
     * @param dataSourceType
     * @return
     */
    @RequestMapping("/put")
    @ResponseBody
    @RepeatSubmitToken
    public boolean addDataSourceTypeAction(DataSource dataSource){

       boolean flag= dataSourceService.selectDataSourceName(dataSourceType.getDataSourceName());
       if(flag){
           return false;
       }
       boolean isSuccess = dataSourceService.addDataSourceType(dataSource);
       //数据源添加成功后重新加载数据源
       loadDataSource.buiderDataSourceToSpring(applicationContext);
       return isSuccess;
    }
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80503e2d162bff836e9608d823040385/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32进入STOP模式并唤醒实验总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf52e925ff35e5867658e3f3ade1cdb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MQ详解及四大MQ比较</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>