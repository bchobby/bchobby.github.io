<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SQL中的left outer join,inner join,right outer join用法 （左右内连接） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SQL中的left outer join,inner join,right outer join用法 （左右内连接）" />
<meta property="og:description" content="SQL语句中的left outer join,inner join,right outer join用法
left outer join=left join , right outer join=right join, inner join=join.
使用关系代数合并数据 1 关系代数 合并数据集合的理论基础是关系代数，它是由E.F.Codd于1970年提出的。 在关系代数的形式化语言中： 用表、或者数据集合表示关系或者实体。 用行表示元组。 用列表示属性。 关系代数包含以下8个关系运算符 选取――返回满足指定条件的行。
投影――从数据集合中返回指定的列。 笛卡尔积――是关系的乘法，它将分别来自两个数据集合中的行以所有可能的方式进行组合。 并――关系的加法和减法，它可以在行的方向上合并两个表中的数据，就像把一个表垒在另一个表之上一样。
交――返回两个数据集合所共有的行。 差――返回只属于一个数据集合的行。 连接――在水平方向上合并两个表，其方法是：将两个表中在共同数据项上相互匹配的那些行合并起来。 除――返回两个数据集之间的精确匹配。 此外，作为一种实现现代关系代数运算的方法，SQL还提供了： 子查询――类似于连接，但更灵活；在外部查询中，方式可以使用表达式、列表或者数据集合的地方都可以使用子查询的结果。 本章将主要讲述多种类型的连接、简单的和相关的子查询、几种类型的并、关系除以及其他的内容。 2 使用连接 2.1 连接类型 在关系代数中，连接运算是由一个笛卡尔积运算和一个选取运算构成的。首先用笛卡尔积完成对两个数据集合的乘运算，然后对生成的结果集合进行选取运算，确保只把分别来自两个数据集合并且具有重叠部分的行合并在一起。连接的全部意义在于在水平方向上合并两个数据集合（通常是表），并产生一个新的结果集合，其方法是将一个数据源中的行于另一个数据源中和它匹配的行组合成一个新元组。 SQL提供了多种类型的连接方式，它们之间的区别在于：从相互交叠的不同数据集合中选择用于连接的行时所采用的方法不同。 连接类型 定义 内连接 只连接匹配的行 左外连接 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行 右外连接 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行 全外连接 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 (H)(theta)连接 使用等值以外的条件来匹配左、右两个表中的行 交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 在INFORMIX中连接表的查询 如果FROM子句指定了多于一个表引用，则查询会连接来自多个表的行。连接条件指定各列之间（每个表至少一列）进行连接的关系。因为正在比较连接条件中的列，所以它们必须具有一致的数据类型。 SELECT语句的FROM子句可以指定以下几种类型的连接 FROM子句关键字 相应的结果集 CROSS JOIN 笛卡尔乘积（所有可能的行对） INNER JOIN 仅对满足连接条件的CROSS中的列 LEFT OUTER JOIN 一个表满足条件的行，和另一个表的所有行 RIGHT OUTER JOIN 与LEFT相同，但两个表的角色互换 FULL OUTER JOIN LEFT OUTER 和 RIGHT OUTER中所有行的超集 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/abbfe512694727d612ed110f82ccaa09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-12T09:44:36+08:00" />
<meta property="article:modified_time" content="2019-08-12T09:44:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQL中的left outer join,inner join,right outer join用法 （左右内连接）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="font-size:24px;line-height:1.3em;">SQL语句中的left outer join,inner join,right outer join用法</span><br><br><span style="font-size:18px;line-height:1.3em;">left outer join=left join ,   right outer join=right join,     inner join=join.</span><br>使用关系代数合并数据 <br>1 关系代数 <br>合并数据集合的理论基础是关系代数，它是由E.F.Codd于1970年提出的。 <br>在关系代数的形式化语言中： <br>           用表、或者数据集合表示关系或者实体。 <br>           用行表示元组。 <br>           用列表示属性。 <br>关系代数包含以下8个关系运算符 <br>           选取――返回满足指定条件的行。</p> 
 <p>           投影――从数据集合中返回指定的列。 <br>          笛卡尔积――是关系的乘法，它将分别来自两个数据集合中的行以所有可能的方式进行组合。 <br>           并――关系的加法和减法，它可以在行的方向上合并两个表中的数据，就像把一个表垒在另一个表之上一样。</p> 
 <p>           交――返回两个数据集合所共有的行。 <br>          差――返回只属于一个数据集合的行。 <br>          连接――在水平方向上合并两个表，其方法是：将两个表中在共同数据项上相互匹配的那些行合并起来。 <br>          除――返回两个数据集之间的精确匹配。 <br>此外，作为一种实现现代关系代数运算的方法，SQL还提供了： <br>          子查询――类似于连接，但更灵活；在外部查询中，方式可以使用表达式、列表或者数据集合的地方都可以使用子查询的结果。 <br>本章将主要讲述多种类型的连接、简单的和相关的子查询、几种类型的并、关系除以及其他的内容。 <br>2 使用连接 <br>2.1 连接类型 <br>在关系代数中，连接运算是由一个笛卡尔积运算和一个选取运算构成的。首先用笛卡尔积完成对两个数据集合的乘运算，然后对生成的结果集合进行选取运算，确保只把分别来自两个数据集合并且具有重叠部分的行合并在一起。连接的全部意义在于在水平方向上合并两个数据集合（通常是表），并产生一个新的结果集合，其方法是将一个数据源中的行于另一个数据源中和它匹配的行组合成一个新元组。 <br>SQL提供了多种类型的连接方式，它们之间的区别在于：从相互交叠的不同数据集合中选择用于连接的行时所采用的方法不同。 <br>连接类型           定义 <br>内连接           只连接匹配的行 <br>左外连接           包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行 <br>右外连接           包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行 <br>全外连接           包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 <br>(H)(theta)连接           使用等值以外的条件来匹配左、右两个表中的行 <br>交叉连接           生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 <br>在INFORMIX中连接表的查询 <br>如果FROM子句指定了多于一个表引用，则查询会连接来自多个表的行。连接条件指定各列之间（每个表至少一列）进行连接的关系。因为正在比较连接条件中的列，所以它们必须具有一致的数据类型。 <br>SELECT语句的FROM子句可以指定以下几种类型的连接 <br>FROM子句关键字           相应的结果集 <br>CROSS JOIN           笛卡尔乘积（所有可能的行对） <br>INNER JOIN           仅对满足连接条件的CROSS中的列 <br>LEFT OUTER JOIN           一个表满足条件的行，和另一个表的所有行 <br>RIGHT OUTER JOIN           与LEFT相同，但两个表的角色互换 <br>FULL OUTER JOIN         LEFT OUTER 和 RIGHT OUTER中所有行的超集 <br><br>2.2 内连接（Inner Join） <br>内连接是最常见的一种连接，它页被称为普通连接，而E.FCodd最早称之为自然连接。 <br>下面是ANSI SQL－92标准 <br>select * <br>from     t_institution i <br>inner join t_teller t <br>on i.inst_no = t.inst_no <br>where i.inst_no = "5801" <br>其中inner可以省略。 <br>等价于早期的连接语法 <br>select * <br>from t_institution i, t_teller t <br>where i.inst_no = t.inst_no <br>and i.inst_no = "5801" <br><br>2.3 外连接 <br>2.3.1           左外连接(Left Outer Jion) <br>select * <br>from     t_institution i <br>left outer join t_teller t <br>on i.inst_no = t.inst_no <br>其中outer可以省略。 <br>2.3.2           右外连接(Rigt Outer Jion) <br>select * <br>from     t_institution i <br>right outer join t_teller t <br>on i.inst_no = t.inst_no <br>2.3.3           全外连接(Full Outer) <br>全外连接返回参与连接的两个数据集合中的全部数据，无论它们是否具有与之相匹配的行。在功能上，它等价于对这两个数据集合分别进行左外连接和右外连接，然后再使用消去重复行的并操作将上述两个结果集合并为一个结果集。 <br>在现实生活中，参照完整性约束可以减少对于全外连接的使用，一般情况下左外连接就足够了。在数据库中没有利用清晰、规范的约束来防范错误数据情况下，全外连接就变得非常有用了，你可以使用它来清理数据库中的数据。 <br>select * <br>from     t_institution i <br>full outer join t_teller t <br>on i.inst_no = t.inst_no <br>2.3.4           外连接与条件配合使用 <br>当在内连接查询中加入条件是，无论是将它加入到join子句，还是加入到where子句，其效果是完全一样的，但对于外连接情况就不同了。当把条件加入到join子句时，SQL Server、Informix会返回外连接表的全部行，然后使用指定的条件返回第二个表的行。如果将条件放到where子句中，SQL Server将会首先进行连接操作，然后使用where子句对连接后的行进行筛选。下面的两个查询展示了条件放置位子对执行结果的影响： <br>条件在join子句 <br>select * <br>from     t_institution i <br>left outer join t_teller t <br>on i.inst_no = t.inst_no <br>and i.inst_no = “5801” <br>结果是： <br>inst_no       inst_name               inst_no       teller_no     teller_name <br>5801         天河区                 5801         0001         tom <br>5801         天河区                 5801         0002         david <br>5802         越秀区 <br>5803         白云区 <br>条件在where子句 <br>select * <br>from     t_institution i <br>left outer join t_teller t <br>on i.inst_no = t.inst_no <br>where i.inst_no = “5801” <br>结果是： <br>inst_no       inst_name               inst_no       teller_no     teller_name <br>5801         天河区                 5801         0001         tom <br>5801         天河区                 5801         0002         david <br><br>2.4 自身连接 <br>自身连接是指同一个表自己与自己进行连接。这种一元连接通常用于从自反关系（也称作递归关系）中抽取数据。例如人力资源数据库中雇员与老板的关系。 <br>下面例子是在机构表中查找本机构和上级机构的信息。 <br>select s.inst_no superior_inst, s.inst_name sup_inst_name, i.inst_no, i.inst_name <br>from t_institution i <br>join t_institution s <br>on i.superior_inst = s.inst_no <br><br>结果是： <br>superior_inst sup_inst_name           inst_no       inst_name <br>800             广州市                 5801         天河区 <br>800             广州市                 5802         越秀区 <br>800             广州市                 5803         白云区 <br><br>2.5 交叉(无限制) 连接 <br>交叉连接用于对两个源表进行纯关系代数的乘运算。它不使用连接条件来限制结果集合，而是将分别来自两个数据源中的行以所有可能的方式进行组合。数据集合中一的每个行都要与数据集合二中的每一个行分别组成一个新的行。例如，如果第一个数据源中有5个行，而第二个数据源中有4个行，那么在它们之间进行交叉连接就会产生20个行。人们将这种类型的结果集称为笛卡尔乘积。 <br>大多数交叉连接都是由于错误操作而造成的；但是它们却非常适合向数据库中填充例子数据，或者预先创建一些空行以便为程序执行期间所要填充的数据保留空间。 <br>select * <br>from     t_institution i <br>cross join t_teller t <br>在交叉连接中没有on条件子句<br><br><br>Inner Join <br>Inner Join 应该是最常用的 Join 方式, 它只会传回符合 Join 规则的纪录, 还是先来看看语法 <br>Select &lt;要选择的字段&gt; From &lt;主要资料表&gt; <br>&lt;Join 方式&gt; &lt;次要资料表&gt; [On &lt;Join 规则&gt;]<br>Select ProductId, ProductName, Suppliers.SupplierId <br>From Products <br>Inner Join Suppliers <br>Products.Suppliers = Suppliers.SupplierId <br>Inner Join 的主要精神就是 exclusive , 叫它做排他性吧! 就是讲 Join 规则不相符的资料就会被排除掉, <br>譬如讲在 Product 中有一项产品的供货商代码 (SupplierId), 没有出现在 Suppliers 资料表中, 那么这笔记录便会被排除掉 <br>Outer Join <br>这款的 Join 方式是一般人比较少用到的, 甚至有些 SQL 的管理者也从未用过, 这真是一件悲哀的代志, 因为善用 Outer Join 是可以简化一些查询的工作的, 先来看看 Outer Join 的SQL语句和语法 <br>Select &lt;要查询的字段&gt; From &lt;Left 资料表&gt; <br>&lt;Left | Right&gt; [Outer] Join &lt;Right 资料表&gt; On &lt;Join 规则&gt; <br>语法中的 Outer 是可以省略的, 例如你可以用 Left Join 或是 Right Join, 在本质上, Outer Join 是 inclusive, 叫它做包容性吧! 不同于 Inner Join 的排他性, 因此在 Left Outer Join 的查询结果会包含所有 Left 资料表的资料, 颠倒过来讲, Right Outer Join 的查询就会包含所有 Right 资料表的资料<br>总结：inner join是内部连接,outer join是外部接。inner求出的是交集,outer表示某个表的所有行,不管另一个表有没有这一行<br>INNER Join code as the following:<br>Select * from A a, B b where a.categoryID = b.categoryID;<br>equals:<br>Select * from A a inner join B b on a.categoryID = b.categoryID;<br>OUTER Join code as the following<br>select * from A a full(left/right) outer   join B b   on a on a.categoryID = b.categoryID;<br>left/right outer join claus specific   for MSSQL:<br>Select * from A a, B b where a.categoryID   *=     bcategoryID;<br>elect * from A a, B b where a.categoryID       =*   b.categoryID;<br>left/right outer join claus specific for Oracle:<br>Select * from A a, B b where a.categoryID       =   b.categoryID(+);<br>Select * from A a, B b where a.categoryID (+) =   b.categoryID;</p> 
 <p> </p> 
 <p>A final thing worth discussing here is the use of aliases. Aliases aren’t necessarily related to table joins, but they become especially useful (and sometimes necessary) when joining tables, and they assign different (and usually shorter) names for the tables involved. Aliases are necessary when joining a table with itself, in which case you need to assign different aliases for its different instances to differentiate them. The following query returns the same products as the query before, but it uses aliases:</p> 
 <p><br>SELECT p.ProductID, p.Name<br>FROM ProductCategory pc INNER JOIN Product p<br>ON p.ProductID = pc.ProductID<br>WHERE pc.CategoryID = 5</p> 
</div> 
<p>转载于:https://www.cnblogs.com/elock/archive/2009/12/05/1617706.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53cf80a3c2ce08f444d8e7aafc018da3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">两种改进的冒泡排序算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44fb8e67f3dba32db60df079364f1cf8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux下设置IPV6默认路由，ping，路由跟踪</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>