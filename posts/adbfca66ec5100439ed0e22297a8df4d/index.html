<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pthread_create线程创建的过程剖析 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pthread_create线程创建的过程剖析" />
<meta property="og:description" content="概述
在Linux环境下，pthread库提供的pthread_create()API函数，用于创建一个线程。线程创建失败时，它可能会返回ENOMEM或EAGAIN。这篇文章主要讨论线程创建过程中碰到的一些问题和解决方法。
创建线程
首先，本文用的实例代码example.c:
/* example.c*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
void thread(void)
{
int i;
for(i=0;i&lt;3;i&#43;&#43;)
printf(&#34;This is a pthread.\n&#34;);
sleep(30);
}
int main(int argc,char **argv)
{
pthread_t id;
int i,ret;
ret=pthread_create(&amp;id,NULL,(void *) thread,NULL);
if(ret!=0){
printf (&#34;Create pthread error!\n&#34;);
exit (1);
}
for(i=0;i&lt;3;i&#43;&#43;)
printf(&#34;This is the main process.\n&#34;);
pthread_join(id,NULL);
return 0;
}
编译，执行下面命令：
# example.c -lpthread -o example -g
用strace工具跟踪线程创建的过程：
# strace ./example
Strace工具输出：
getrlimit(RLIMIT_STACK, {rlim_cur=10240*1024, rlim_max=RLIM_INFINITY}) = 0 uname({sys=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/adbfca66ec5100439ed0e22297a8df4d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-06-18T16:56:13+08:00" />
<meta property="article:modified_time" content="2012-06-18T16:56:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pthread_create线程创建的过程剖析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><strong><span style="font-family:宋体; font-size:18pt">概述</span></strong></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span style="font-family:宋体; font-size:12pt"><strong>在<span lang="EN-US">Linux</span>环境下，<strong><span lang="EN-US">pthread</span></strong>库提供的</strong></span><em><span lang="EN-US" style="font-family:宋体; font-size:12pt">pthread_create()</span></em><span lang="EN-US" style="font-family:宋体; font-size:12pt"><strong>API</strong></span><span style="font-family:宋体; font-size:12pt"><strong>函数，用于创建一个线程。线程创建失败时，它可能会返回<strong><span lang="EN-US">ENOMEM</span></strong>或<strong><span lang="EN-US">EAGAIN</span></strong>。这篇文章主要讨论线程创建过程中碰到的一些问题和解决方法。</strong></span><span lang="EN-US" style="font-family:宋体; font-size:12pt"></span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><a name="Creation_of_a_thread"></a><strong><span style="font-family:宋体; font-size:18pt">创建线程<span lang="EN-US"></span></span></strong></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">首先，本文用的实例代码<span lang="EN-US">example.c:</span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#ddd9c3; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:NSimSun; color:green; font-size:9.5pt">/* example.c*/</span><span lang="EN-US" style="font-family:NSimSun; font-size:9.5pt"><br> <span style="color:blue">#include</span> <span style="color:#a31515">&lt;stdio.h&gt;</span><br> <span style="color:blue">#include</span> <span style="color:#a31515">&lt;stdlib.h&gt;</span><br> <span style="color:blue">#include</span> <span style="color:#a31515">&lt;unistd.h&gt;</span><br> <span style="color:blue">#include</span> <span style="color:#a31515">&lt;pthread.h&gt;</span><br> <span style="color:blue">void</span> thread(<span style="color:blue">void</span>)<br> {<!-- --><br> <span style="">    </span><span style="color:blue">int</span> i;<br> <span style="">    </span><span style="color:blue">for</span>(i=0;i&lt;3;i++)<br> <span style="">        </span>printf(<span style="color:#a31515">"This is a pthread.\n"</span>);<br> <br> <span style="">    </span>sleep(30);<br> }<br> <br> <span style="color:blue">int</span> main(<span style="color:blue">int</span> argc,<span style="color:blue">char</span> **argv)<br> {<!-- --><br> <span style="">    </span>pthread_t id;<br> <span style="">    </span><span style="color:blue">int</span> i,ret;<br> <span style="">    </span>ret=pthread_create(&amp;id,NULL,(<span style="color:blue">void</span> *) thread,NULL);<br> <span style="">    </span><span style="color:blue">if</span>(ret!=0){<!-- --><br> <span style="">        </span>printf (<span style="color:#a31515">"Create pthread error!\n"</span>);<br> <span style="">        </span>exit (1);<br> <span style="">    </span>}<br> <span style="">    </span><span style="color:blue">for</span>(i=0;i&lt;3;i++)<br> <span style="">        </span>printf(<span style="color:#a31515">"This is the main process.\n"</span>);<br> <span style="">    </span>pthread_join(id,NULL);<br> <span style="">    </span><span style="color:blue">return</span> 0;<br> }</span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">编译，执行下面命令：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#ddd9c3; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span style=""><span style=""><span lang="EN-US" style="font-family:宋体; font-size:12pt"># example.c -lpthread -o example -g</span></span></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">用<span lang="EN-US">strace</span>工具跟踪线程创建的过程：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#eeece1; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span style=""><span style=""><span lang="EN-US" style="font-family:宋体; font-size:12pt"># strace ./example</span></span></span><span lang="EN-US" style="font-family:宋体; font-size:12pt"></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt">Strace</span><span style="font-family:宋体; font-size:12pt">工具输出：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span style=""><span lang="EN-US" style="font-family:宋体; color:red; font-size:12pt">getrlimit</span></span><span lang="EN-US" style="font-family:宋体; font-size:12pt">(RLIMIT_STACK, {rlim_cur=10240*1024, rlim_max=RLIM_INFINITY}) = 0 <br> uname({sys="Linux", node="yjye", ...})<span style="">  </span>= 0 <br> <span style=""><span style="color:red">mmap2</span></span>(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb6d1c000<br> brk(0)<span style="">                            </span><span style="">      </span>= 0x90e0000<br> brk(0x9101000)<span style="">                          </span>= 0x9101000<br> <span style=""><span style="color:red">mprotect</span></span>(0xb6d1c000, 4096, PROT_NONE)<span style="">  </span>= 0 <br> <span style=""><span style="color:red">clone</span></span>(child_stack=0xb771c494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE<br> _PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb771cbd8, {entry_number:6, base_addr:0xb771cb70, limit:1048575, seg_32bi<br> t:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb771cbd8) = 17209<br> fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0</span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">由上表中的输出可以看出创建线程过程中的调用步骤：<span lang="EN-US"></span></span></p> 
 <ul type="disc"><li class="MsoNormal" style="text-align:left; margin:0cm 0cm 0pt"><span style="font-family:宋体; font-size:12pt">通过系统调用<em><span lang="EN-US">getrlimit()</span></em><span lang="EN-US"> </span>获取线程栈的大小<span lang="EN-US">(</span>参数中的<strong><span lang="EN-US">RLIMIT_STACK</span></strong><span lang="EN-US">)</span>，在我的环境里<span lang="EN-US">(CentOS6)</span>，缺省值是<span lang="EN-US">10M</span>。<span lang="EN-US"></span></span></li><li class="MsoNormal" style="text-align:left; margin:0cm 0cm 0pt"><span style="font-family:宋体; font-size:12pt">调用<em><span lang="EN-US">mmap2()</span></em>分配内存，大小为<span lang="EN-US">10489856</span>字节，合<span lang="EN-US">10244K</span>，比栈空间大了<span lang="EN-US">4K</span>。返回<span lang="EN-US">0xb6d1c000</span>。<span lang="EN-US"></span></span></li><li class="MsoNormal" style="text-align:left; margin:0cm 0cm 0pt"><span style="font-family:宋体; font-size:12pt">调用<em><span lang="EN-US">mprotect()</span></em>，设置个内存页的保护区<span lang="EN-US">(</span>大小为<span lang="EN-US">4K)</span>，页面起始地址为<span lang="EN-US">0xb6d1c000</span>。这个页面用于监测栈溢出，如果对这片内存有读写操作，那么将会触发一个<strong><span lang="EN-US">SIGSEGV</span></strong>信号。下面布局图中的红色区域既是。<span lang="EN-US"></span></span></li><li class="MsoNormal" style="text-align:left; margin:0cm 0cm 0pt"><span style="font-family:宋体; font-size:12pt">调用<em><span lang="EN-US">clone()</span></em>创建线程。调用的第一个参数是一个地址：栈底的地址<span lang="EN-US">(</span>这里具体为<span lang="EN-US">0xb771c494)</span>。栈空间的内存使用，是从高位内存开始的。<span lang="EN-US"></span></span></li></ul> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span style="font-family:宋体; font-size:12pt">从<em><span lang="EN-US">/proc/&lt;pid&gt;/smaps</span></em>文件里，我们可以清楚地看到栈内存的映射情况：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; background:#d9d9d9; color:#00b050; font-size:12pt">090e0000-09101000 rw-p 00000000 00:00 0<span style="">         </span>[heap]<br> Size:<span style="">                </span>132 kB<br> Rss:<span style="">                   </span>4 kB<br> Pss:<span style="">                   </span>4 kB<br> Shared_Clean:<span style="">          </span>0 kB<br> Shared_Dirty:<span style="">          </span>0 kB<br> Private_Clean:<span style="">         </span>0 kB<br> Private_Dirty:<span style="">         </span>4 kB<br> Referenced:<span style="">            </span>4 kB<br> Swap:<span style="">                  </span>0 kB<br> KernelPageSize:<span style="">        </span>4 kB<br> MMUPageSize:<span style="">           </span>4 kB<br> </span><span lang="EN-US" style="font-family:宋体; font-size:12pt"><span style="color:#ff0000">b6d1c000-b6d1d000 ---p 00000000 00:00 0    #线程栈溢出监测区域<br> Size:                  4 kB<br> Rss:                   0 kB<br> Pss:                   0 kB<br> Shared_Clean:          0 kB<br> Shared_Dirty:          0 kB<br> Private_Clean:         0 kB<br> Private_Dirty:         0 kB<br> Referenced:            0 kB<br> Swap:                  0 kB<br> KernelPageSize:        4 kB<br> MMUPageSize:           4 kB</span></span><span lang="EN-US" style="font-family:宋体; font-size:12pt"><br> <span style="color:#002060">b6d1d000-b771e000 rw-p 00000000 00:00 0    #线程栈<br> Size:<span style="">              </span>10244 kB<br> Rss:<span style="">                   </span>8 kB<br> Pss:<span style="">                   </span>8 kB<br> Shared_Clean:<span style="">          </span>0 kB<br> Shared_Dirty:<span style="">          </span>0 kB<br> Private_Clean:<span style="">         </span>0 kB<br> Private_Dirty:<span style="">         </span>8 kB<br> Referenced:<span style="">            </span>8 kB<br> Swap:<span style="">                  </span>0 kB<br> KernelPageSize:<span style="">        </span>4 kB<br> MMUPageSize:<span style="">           </span>4 kB</span></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span style="font-family:宋体; font-size:12pt">从上面的映射文件的深蓝色部分中，我们看到，栈的空间总共为<span lang="EN-US">10244Kb</span>，内存段是从<span lang="EN-US" style="color:#002060">b6d1d000</span><span style="color:#002060">到<span lang="EN-US">b771e000</span>。</span>从<span lang="EN-US">strace</span>的输出中，我们看到栈底的地址为<span lang="EN-US">0xb771c494</span>，那么，从<span lang="EN-US">0xb771c494</span>到<span lang="EN-US" style="color:#002060">b771e000</span><span style="color:#002060">这段内存是做什么用的呢？它就是线程的</span><strong><span lang="EN-US">TCB</span></strong><span lang="EN-US" style="color:#002060">(</span><span lang="EN-US">thread's control block<span style="color:#002060">)</span></span><span style="color:#002060">和</span><strong><span lang="EN-US">TLS</span></strong><span style="color:#002060">区域<span lang="EN-US">(</span></span><span lang="EN-US"> thread's local storage<span style="color:#002060">)</span></span><span style="color:#002060">。具体的线程内存空间布局如下：<span lang="EN-US"></span></span></span></p> 
 <p class="MsoNormal" align="center" style="text-align:center; text-indent:24pt; margin:0cm 0cm 12pt"> <img src="https://images2.imgbox.com/5d/e1/yC9rNztv_o.jpg" alt=""><br> </p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"><br> </span><a name="The_2.5_versus_2.8_version_of_the_C"></a><strong><span lang="EN-US" style="font-family:宋体; font-size:18pt">GLIBC2.5</span><span style="font-family:宋体; font-size:18pt">与<span lang="EN-US">2.8</span></span></strong></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"><span style="">    </span></span><span style="font-family:宋体; font-size:12pt">研究<span lang="EN-US">GLIBC2.5</span>和<span lang="EN-US">2.8</span>里的<em><span lang="EN-US">pthread_create()</span></em>相关代码，会发现在<em><span lang="EN-US">mmap()</span></em>调用失败并返回<strong><span lang="EN-US">ENOMEM</span></strong>时，作了点变动，新版里替换了错误码。<span lang="EN-US"></span></span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt">V2.5</span><span style="font-family:宋体; font-size:12pt">相关代码<em><span lang="EN-US">.../nptl/allocatestack.c</span></em>：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">mem = mmap (NULL, size, prot,<br>               MAP_PRIVATE | MAP_ANONYMOUS | ARCH_MAP_FLAGS, -1, 0);<br> <br>       if (__builtin_expect (mem == MAP_FAILED, 0))<br>         {<!-- --><br> #ifdef ARCH_RETRY_MMAP<br>           mem = ARCH_RETRY_MMAP (size);<br>           if (__builtin_expect (mem == MAP_FAILED, 0))<br> #endif<br> <strong><span style="color:red">        return errno;<br> </span></strong>        }</span><span lang="EN-US" style="font-family:宋体; font-size:12pt"></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt">V2.8</span><span style="font-family:宋体; font-size:12pt">里的<em><span lang="EN-US">.../nptl/allocatestack.c</span>：<span lang="EN-US"></span></em></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">mem = mmap (NULL, size, prot,<br>               MAP_PRIVATE | MAP_ANONYMOUS | ARCH_MAP_FLAGS, -1, 0);<br> <br>       if (__builtin_expect (mem == MAP_FAILED, 0))<br>         {<!-- --><br> #ifdef ARCH_RETRY_MMAP<br>           mem = ARCH_RETRY_MMAP (size, prot);<br>           if (__builtin_expect (mem == MAP_FAILED, 0))<br> #endif<br>             {<!-- --><br> <strong><span style="color:red">              if (errno == ENOMEM)<br>                 errno = EAGAIN;<br> <br>               return errno;<br> </span></strong>            }<br>         }</span><span lang="EN-US" style="font-family:宋体; font-size:12pt"></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">如上面的代码片段所示，在<span lang="EN-US">V2.5</span>，简单地将<em><span lang="EN-US">mmap()</span></em>调用结果返回给用户，而在<span lang="EN-US">V2.8</span>里，如果<em><span lang="EN-US">mmap()</span></em>返回<strong><span lang="EN-US">ENOMEM</span></strong>，那么<span lang="EN-US">GLIBC</span>会将错误码改成<strong><span lang="EN-US">EAGAIN</span></strong>再返回。<span lang="EN-US"></span></span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><a name="Why_pthread_create_could_fail_"></a><strong><span style="font-family:宋体; font-size:18pt">为什么<span lang="EN-US">pthread_create()</span>会调用失败<span lang="EN-US">?</span></span></strong></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">随着运行中的线程数量的增大，<em><span lang="EN-US">pthread_create()</span></em>失败的可能性也会增大。因为这会使分配给线程的内存空间<span lang="EN-US">(</span>比如说线程栈<span lang="EN-US">)</span>累积太多，导致<em><span lang="EN-US">mmap()</span></em>系统调用失败。<span lang="EN-US"></span></span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">比如说，<em><span lang="EN-US">/proc/&lt;pid&gt;/smaps</span></em>里有这样一个内存映射片段：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">[...]<br> 7eb3d000-7f33c000 rw-p 7eb3d000 00:00 0<br> Size:               8188 kB<br> Rss:                  12 kB<br> Pss:                  12 kB<br> Shared_Clean:          0 kB<br> Shared_Dirty:          0 kB<br> Private_Clean:         0 kB<br> Private_Dirty:        12 kB<br> Referenced:           12 kB<br> Swap:                  0 kB<br> 7f8f5000-7f90a000 rw-p 7ffeb000 00:00 0          [stack]<br> Size:                 84 kB<br> Rss:                  16 kB<br> Pss:                  16 kB<br> Shared_Clean:          0 kB<br> Shared_Dirty:          0 kB<br> Private_Clean:         0 kB<br> Private_Dirty:        16 kB<br> Referenced:           16 kB<br> Swap:                  0 kB</span><span lang="EN-US" style="font-family:宋体; font-size:12pt"></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 0pt"> <span style="font-family:宋体; font-size:12pt">可用的内存空间是最后一个内存段和</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">[stack]</span><span style="font-family:宋体; font-size:12pt">标签之间的空间：</span><span lang="EN-US" style="font-family:宋体; font-size:12pt">0x7F8F5000 - 0x7F33C000 = 0x5B9000 = 6000640</span><span style="font-family:宋体; font-size:12pt">字节<span lang="EN-US">(</span>也就是<span lang="EN-US">6MB)</span>。按缺省配置，小于一个线程栈的空间<span lang="EN-US">(10MB)</span>。这时再创建线程就要失败。<span lang="EN-US"><br style=""> <br style=""> </span></span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><a name="Solution"></a><strong><span style="font-family:宋体; font-size:18pt">解决方法<span lang="EN-US"></span></span></strong></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"><span style="">   </span></span><span style="font-family:宋体; font-size:12pt">通常情况下，缺省<span lang="EN-US">10M</span>的线程栈空间显然是太大了，所以建议通过调用<em><span lang="EN-US">pthread_attr_setstacksize()</span></em><span lang="EN-US">API</span>来改变线程栈的大小。比如说以下代码片段：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">//-------------------------------------------------------<br> // Name   : create_thd<br> // Usage  : Create a thread<br> // Return : 0, if OK<br> //          -1, if error (errno is set)<br> //-------------------------------------------------------<br> static int create_thd(<br>                     void       *thd_par,  // Thread parameters<br>                     size_t      stack_sz,<br>                     void       *(*entry)(void *),<br>                     pthread_t  *pThreadId // Thread identifier<br>                      )<br> {<!-- --><br> pthread_attr_t      attr;<br> int                 rc = 0;<br> int                 err_sav;<br> <br>   // Check the parameters<br>   if (!pThreadId)<br>   {<!-- --><br>     fprintf(stderr, "NULL thread id\n");<br>     errno = EINVAL;<br>     return -1;<br>   }<br> <br>   memset(&amp;attr, 0, sizeof(attr));<br> <br>   errno = pthread_attr_init(&amp;attr);<br>   if (0 != errno)<br>   {<!-- --><br>     err_sav = errno;<br>     fprintf(stderr, "pthread_attr_init() failed (errno = %d)\n", errno);<br>     errno = err_sav;<br>     return -1;<br>   }<br> <br>   errno = pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);<br>   if (0 != errno)<br>   {<!-- --><br>     err_sav = errno;<br>     fprintf(stderr, "pthread_attr_setscope() failed (errno = %d)\n", errno);<br>     errno = err_sav;<br>     rc = -1;<br>     goto err;<br>   }<br> <br>   errno = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br>   if (0 != errno)<br>   {<!-- --><br>     err_sav = errno;<br>     fprintf(stderr, "pthread_attr_setdetachstate() failed (errno = %d)\n", errno);<br>     errno = err_sav;<br>     rc = -1;<br>     goto err;<br>   }<br> <br> <strong><span style="color:red">  // Set the stack size<br>   errno = pthread_attr_setstacksize(&amp;attr, stack_sz);<br>   if (0 != errno)<br>   {<!-- --><br>     err_sav = errno;<br>     fprintf(stderr, "Error %d on pthread_attr_setstacksize()\n", errno);<br>     errno = err_sav;<br>     rc = -1;<br>     goto err;<br>   }<br> </span></strong><br>   // Thread creation<br>   errno = pthread_create(pThreadId,<br>                          &amp;attr,<br>                          entry,<br>                          thd_par);<br>   if (0 != errno)<br>   {<!-- --><br>     err_sav = errno;<br>     fprintf(stderr, "pthread_create() failed (errno = %m - %d)\n", errno);<br>     errno = err_sav;<br>     rc = -1;<br>     goto err;<br>   }<br> <br>   goto ok;<br> <br> err:<br> <br> ok:<br> <br>   // The following calls will alter errno<br>   err_sav = errno;<br> <br>   errno = pthread_attr_destroy(&amp;attr);<br>   if (0 != errno)<br>   {<!-- --><br>     fprintf(stderr, "pthread_attr_destroy() failed (errno = %d)\n", errno);<br>     rc = -1;<br>   }<br> <br>   errno = err_sav;<br> <br>   return rc;<br> } // create_thd</span><span lang="EN-US" style="font-family:宋体; font-size:12pt"></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 0pt"><a name="Problem_of_symbol_version"></a><strong><span style="font-family:宋体; font-size:18pt">符号版本的链接问题<span lang="EN-US"></span></span></strong></p> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"><span style="">     </span></span><span style="font-family:宋体; font-size:12pt">回到我们前面的示例代码中来，在里面，我们在主进程里直接调用<em><span lang="EN-US">pthread_create()</span></em>函数。我们来看一下它的链接情况：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt">[root@yjye yeyj]# nm example | grep pthread<br> <span style="">         </span>U pthread_create@@<span style="color:red">GLIBC_2.1</span><br> <span style="">         </span>U pthread_join@@<span style="color:red">GLIBC_2.0</span></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span style="font-family:宋体; font-size:12pt">而上次在调试<span lang="EN-US">Freeswitch</span>时，发现配置的栈大小居然不生效，所有子线程全部继承父线程的大小。这是怎么回事呢？<span lang="EN-US">Freeswitch</span>调用的是<span lang="EN-US">apr</span>封装后的接口，那我们看下<span lang="EN-US">apr</span>的链接符号：<span lang="EN-US"></span></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt">[root@yjye .libs]# nm libapr-1.a | grep pthread<br> <span style="">         </span>U pthread_rwlock_destroy<br> <span style="">         </span>U pthread_rwlock_init<br> <span style="">         </span>U pthread_rwlock_rdlock<br> <span style="">         </span>U pthread_rwlock_tryrdlock<br> <span style="">         </span>U pthread_rwlock_trywrlock<br> <span style="">         </span>U pthread_rwlock_unlock<br> <span style="">     </span><span style="">    </span>U pthread_rwlock_wrlock<br> <span style="">         </span>U pthread_mutex_destroy<br> <span style="">         </span>U pthread_mutex_init<br> <span style="">         </span>U pthread_mutex_lock<br> <span style="">         </span>U pthread_mutex_trylock<br> <span style="">         </span>U pthread_mutex_unlock<br> <span style="">         </span>U pthread_mutexattr_destroy<br> <span style="">         </span>U pthread_mutexattr_init<br> <span style="">         </span>U pthread_mutexattr_settype<br> <span style="">         </span>U pthread_cond_broadcast<br> <span style="">         </span>U pthread_cond_destroy<br> <span style="">         </span>U pthread_cond_init<br> <span style="">         </span>U pthread_cond_signal<br> <span style="">         </span>U pthread_cond_timedwait<br> <span style="">         </span>U pthread_cond_wait<br> 00000080 d mutex_proc_pthread_methods<br> 00000a10 t proc_mutex_proc_pthread_acquire<br> 00000990 t proc_mutex_proc_pthread_cleanup<br> 00000a50 t proc_mutex_proc_pthread_create<br> 00000960 t proc_mutex_proc_pthread_release<br> <span style="">         </span>U pthread_mutex_destroy<br> <span style="">         </span>U pthread_mutex_init<br> <span style="">         </span>U pthread_mutex_lock<br> <span style="">         </span>U pthread_mutex_unlock<br> <span style="">         </span>U pthread_mutexattr_destroy<br> <span style="">         </span>U pthread_mutexattr_init<br> <span style="">         </span>U pthread_mutexattr_setprotocol<br> <span style="">         </span>U pthread_mutexattr_setpshared<br> <span style="">         </span>U pthread_mutexattr_setrobust_np<br> <span style="">         </span>U pthread_attr_destroy<br> <span style="">         </span>U pthread_attr_getdetachstate<br> <span style="">         </span>U pthread_attr_init<br> <span style="">         </span>U pthread_attr_setdetachstate<br> <span style="">         </span>U pthread_attr_setguardsize<br> <span style="">         </span>U pthread_attr_setstacksize<br> <span style="">         </span>U pthread_create<br> <span style="">         </span>U pthread_detach<br> <span style="">         </span>U pthread_exit<br> <span style="">         </span>U pthread_join<br> <span style="">         </span>U pthread_once<br> <span style="">         </span>U pthread_self<br> <span style="">         </span>U pthread_sigmask<br> <span style="">         </span>U pthread_getspecific<br> <span style="">         </span>U pthread_key_create<br> <span style="">         </span>U pthread_key_delete<br> <span style="">         </span>U pthread_setspecific</span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span lang="EN-US" style="font-family:宋体; font-size:12pt"><br> </span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt"><span style="">   </span></span><span style="font-family:宋体; font-size:12pt">和前面相比，好像符号后面少了</span><span lang="EN-US" style="font-family:宋体; font-size:12pt">e@@<span style="color:red">GLIBC_2.1</span></span><span style="font-family:宋体; font-size:12pt">或者</span><span lang="EN-US" style="font-family:宋体; font-size:12pt">e@@<span style="color:red">GLIBC_2.0</span></span><span style="font-family:宋体; font-size:12pt">。通过</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">GDB</span><span style="font-family:宋体; font-size:12pt">跟踪，发现最终调用的是</span><span lang="EN-US" style="font-family:宋体; font-size:12pt">pthread_join@@<span style="color:red">GLIBC_2.0</span></span><span style="font-family:宋体; font-size:12pt">。弄出两个版本来了。通过第三库调用</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">pthread</span><span style="font-family:宋体; font-size:12pt">库，经常会出现这种情况。</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt"></span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span style="font-family:宋体; font-size:12pt">我们看</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">2.0</span><span style="font-family:宋体; font-size:12pt">的代码，打开文件</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">…/</span><em><span lang="EN-US" style="font-family:宋体; font-size:12pt">/nptl/pthread_create.c</span></em><span style="font-family:宋体; font-size:12pt">：</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt"></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">int<br> __pthread_create_2_0 (newthread, attr, start_routine, arg)<br>      pthread_t *newthread;<br>      const pthread_attr_t *attr;<br>      void *(*start_routine) (void *);<br>      void *arg;<br> {<!-- --><br>   /* The ATTR attribute is not really of type `pthread_attr_t *'.  It has<br>      the old size and access to the new members might crash the program.<br>      We convert the struct now.  */<br>   struct pthread_attr new_attr;<br> <br>   <strong><span style="color:red">if (attr != NULL)</span></strong><br>     {<!-- --><br>       struct pthread_attr *iattr = (struct pthread_attr *) attr;<br>       size_t ps = __getpagesize ();<br> <br>       /* Copy values from the user-provided attributes.  */<br>       new_attr.schedparam = iattr-&gt;schedparam;<br>       new_attr.schedpolicy = iattr-&gt;schedpolicy;<br>       new_attr.flags = iattr-&gt;flags;<br> <br>       /* Fill in default values for the fields not present in the old<br>      implementation.  */<br>       new_attr.guardsize = ps;<br>       <strong><span style="color:red">new_attr.stackaddr = NULL;<br>       new_attr.stacksize = 0;</span></strong><br>       new_attr.cpuset = NULL;<br> <br>       /* We will pass this value on to the real implementation.  */<br>       attr = (pthread_attr_t *) &amp;new_attr;<br>     }<br> <br>   <strong><span style="color:red">return __pthread_create_2_1 (newthread, attr, start_routine, arg);</span></strong><br> }</span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span lang="EN-US" style="font-family:'Courier New'; font-size:12pt"> </span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span style="font-family:宋体; font-size:12pt">很明显，如果链接到老版本，那么设置栈大小的属性完全被忽略掉了。</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt"></span></p> 
 <p class="MsoNormal" align="left" style="text-align:left; text-indent:24pt; margin:0cm 0cm 12pt"> <span style="font-family:宋体; font-size:12pt">怎么解决这个问题呢？强制指定链接的符号，让它调用</span><strong><span lang="EN-US" style="font-family:宋体; font-size:12pt">GLIBC_2.1</span></strong><span style="font-family:宋体; font-size:12pt">。感谢</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">Linux</span><span style="font-family:宋体; font-size:12pt">提供的系统调用，</span><em><span lang="EN-US" style="font-family:宋体; font-size:12pt">dlvsym()</span></em><span style="font-family:宋体; font-size:12pt">正好可以解决这个问题：</span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt"></span></p> 
 <table class="MsoTableGrid" border="1" cellspacing="0" cellpadding="0" style="border-bottom:medium none; border-left:medium none; border-collapse:collapse; background:#d9d9d9; border-top:medium none; border-right:medium none"><tbody><tr style=""><td width="568" style="border-bottom:windowtext 1pt solid; border-left:windowtext 1pt solid; padding-bottom:0cm; background-color:transparent; padding-left:5.4pt; width:426.1pt; padding-right:5.4pt; border-top:windowtext 1pt solid; border-right:windowtext 1pt solid; padding-top:0cm"> <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt">#include &lt;dlfcn.h&gt;<br> ………<br> <br> </span><span lang="EN-US" style="font-family:'Courier New'; font-size:12pt">typedef int (*lxb_pcreate_t)(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);<br> <br> static lxb_pcreate_t lxb_pthread_create;<br> [...]<br> <span style="">   </span>void *pSym;<br> <br>   // Get the version GLIBC_2.1 of pthread_create() symbol<br>   <strong><span style="color:red">pSym = dlvsym(RTLD_DEFAULT, "pthread_create", "GLIBC_2.1");</span></strong><br>   if (NULL == pSym)<br>   {<!-- --><br>     lxb_pthread_create = pthread_create;<br>   }<br>   else<br>   {<!-- --><br>     lxb_pthread_create = (lxb_pcreate_t)pSym;<br>     if (pSym != (void *)pthread_create)<br>     {<!-- --><br>       LXB_PRINTF("Unexpected version of pthread_create() symbol ==&gt; Forced to GLIBC_2.1\n");<br>     }<br>   }</span><span lang="EN-US" style="font-family:宋体; font-size:12pt"></span></p> </td></tr></tbody></table> 
 <p class="MsoNormal" align="left" style="text-align:left; margin:0cm 0cm 12pt"><span lang="EN-US" style="font-family:宋体; font-size:12pt"> </span></p> 
</div> 
<div> 
 <div> 
  <div> 
   <br> 
  </div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f7c217f13df3d254e61b0b58c04ae51a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Regular DLL(MFC规则DLL)、MFC...Extension DLL(MFC扩展DLL 区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff01c49a090eee24ea37879065a592ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OnContextMenu 响应鼠标右键菜单消息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>