<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于CNN神经网络的手写字符识别实验报告 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于CNN神经网络的手写字符识别实验报告" />
<meta property="og:description" content="作业要求
具体实验内容根据实际情况自拟，可以是传统的BP神经网络，Hopfield神经网络，也可以是深度学习相关内容。
数据集自选，可以是自建数据集，或MNIST，CIFAR10等公开数据集。
实验报告内容包括但不限于：
实验目标和动机，应明确说明输入数据，和网络输出数据；所设计相关网络的基本架构；核心架构的具体实现；网络训练和推理过程及说明；实验结果比对和分析；总结和讨论… 可根据需要自行扩展 评分标准：符合上述内容和格式要求，80分
根据算法原理介绍，算法实现，实验结果分析和讨论情况，加分0-5分；
根据实验结果分析和讨论各种神经网络方法的优缺点，加分0~5分；
讨论不同神经网络参数对性能的影响，并尝试比对，加分0~5分；
有自己观点或体现自身工作量，加分0-10分；
总分不超过100分。
目录
1. 实验目标和动机
2 CNN算法的基本原理
3 LeNet5网络基本架构
4 核心架构的具体实现
5 网络训练和推理过程及说明
6 实验结果对比和分析
6.1 不同神经网络参数对性能的影响
6.1.1 批处理大小
6.1.2 学习率
6.1.3 优化算法
6.1.4 激活函数
6.2 实验结果的分析
7. 各种神经网络方法的优缺点
7.1多层感知机（MLP）
7.2卷积神经网络（CNN）
7.3 循环神经网络（RNN）
7.4 长短期记忆网络（LSTM）和门控循环单元（GRU）
8.总结和讨论
9.附录
1. 实验目标和动机 实验的目标是使用MNIST数据集进行手写字符识别。MNIST数据集包含许多手写数字的图像，每个图像都是28x28像素的灰度图像，表示数字0到9。
实验动机是探索使用卷积神经网络（CNN）进行图像识别任务，并比较不同网络结构和参数配置对性能的影响。
输入数据： 28x28像素的灰度图像
网络输出数据： 预测的数字类别
2 CNN算法的基本原理 CNN是一种专门用于处理图像数据的深度学习模型，其核心原理包括卷积层、池化层和全连接层。
卷积神经网络利用卷积层来提取图像特征。卷积操作通过滑动卷积核在输入图像上提取局部特征，这有助于捕获图像中的边缘、纹理等信息，并保留空间关系。
池化层用于降维和减少特征图的大小，同时保留主要特征。最常见的池化操作是最大池化，它从每个局部区域中选择最大值作为输出，减小了特征图的尺寸并提高了计算效率。
全连接层通常位于网络的顶部，将卷积层和池化层提取的特征映射到输出类别。全连接层通过学习权重参数，将特征映射到每个类别的概率，最终实现图像分类。
激活层采用激活函数，把卷积层输出结果做非线性映射。在卷积层之后使用，以增加网络的表达能力。常见的激活函数包括ReLU（Rectified Linear Unit）、Sigmoid和Tanh等。ReLU是最常用的激活函数，它能够有效缓解梯度消失问题，并加速网络的收敛速度。
Softmax层通常作为网络的最后一层，用于将全连接层的输出转换成各个类别的概率分布。通过对这些概率进行比较，模型可以确定输入图像最可能属于哪个类别。
3 LeNet5网络基本架构 本实验使用CNN的经典模型LeNet5进行手写数字的识别。
LeNet-5的基本结构包括7层网络结构（不含输入层），其中包括2个卷积层、2个降采样层（池化层）、2个全连接层和输出层。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/afc5d9de60031511fd23d1bd0747ff64/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-30T17:02:00+08:00" />
<meta property="article:modified_time" content="2023-12-30T17:02:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于CNN神经网络的手写字符识别实验报告</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>作业要求</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">具体实验内容根据实际情况自拟，可以是传统的BP神经网络，Hopfield神经网络，也可以是深度学习相关内容。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">数据集自选，可以是自建数据集，或MNIST，CIFAR10等公开数据集。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">实验报告内容包括但不限于：</p> 
 <ol><li>实验目标和动机，应明确说明输入数据，和网络输出数据；</li><li>所设计相关网络的基本架构；</li><li>核心架构的具体实现；</li><li>网络训练和推理过程及说明；</li><li>实验结果比对和分析；</li><li>总结和讨论</li><li>… 可根据需要自行扩展</li></ol> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>评分标准：</strong>符合上述内容和格式要求，80分</p> 
 <p style="margin-left:.0001pt;text-align:justify;">          根据算法原理介绍，算法实现，实验结果分析和讨论情况，加分0-5分；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">          根据实验结果分析和讨论各种神经网络方法的优缺点，加分0~5分；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">  讨论不同神经网络参数对性能的影响，并尝试比对，加分0~5分；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">  有自己观点或体现自身工作量，加分0-10分；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">          总分不超过100分。</p> 
</blockquote> 
<blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="1.%20%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%A8%E6%9C%BA-toc" style="margin-left:80px;"><a href="#1.%20%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%A8%E6%9C%BA" rel="nofollow">1. 实验目标和动机</a></p> 
 <p id="2%20CNN%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#2%20CNN%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">2 CNN算法的基本原理</a></p> 
 <p id="3%20LeNet5%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84-toc" style="margin-left:80px;"><a href="#3%20LeNet5%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84" rel="nofollow">3 LeNet5网络基本架构</a></p> 
 <p id="4%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#4%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" rel="nofollow">4 核心架构的具体实现</a></p> 
 <p id="5%20%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E5%8F%8A%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#5%20%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E5%8F%8A%E8%AF%B4%E6%98%8E" rel="nofollow">5 网络训练和推理过程及说明</a></p> 
 <p id="6%20%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%92%8C%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#6%20%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%92%8C%E5%88%86%E6%9E%90" rel="nofollow">6 实验结果对比和分析</a></p> 
 <p id="6.1%20%E4%B8%8D%E5%90%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D-toc" style="margin-left:120px;"><a href="#6.1%20%E4%B8%8D%E5%90%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D" rel="nofollow">6.1 不同神经网络参数对性能的影响</a></p> 
 <p id="6.1.1%20%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%A7%E5%B0%8F-toc" style="margin-left:160px;"><a href="#6.1.1%20%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%A7%E5%B0%8F" rel="nofollow">6.1.1 批处理大小</a></p> 
 <p id="6.1.2%20%E5%AD%A6%E4%B9%A0%E7%8E%87-toc" style="margin-left:160px;"><a href="#6.1.2%20%E5%AD%A6%E4%B9%A0%E7%8E%87" rel="nofollow">6.1.2 学习率</a></p> 
 <p id="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B6.1.3%C2%A0%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-toc" style="margin-left:160px;"><a href="#%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B6.1.3%C2%A0%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95" rel="nofollow">6.1.3 优化算法</a></p> 
 <p id="6.1.4%C2%A0%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#6.1.4%C2%A0%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0" rel="nofollow">6.1.4 激活函数</a></p> 
 <p id="6.2%20%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%86%E6%9E%90-toc" style="margin-left:120px;"><a href="#6.2%20%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%86%E6%9E%90" rel="nofollow">6.2 实验结果的分析</a></p> 
 <p id="7.%20%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#7.%20%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">7. 各种神经网络方法的优缺点</a></p> 
 <p id="7.1%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%EF%BC%88MLP%EF%BC%89-toc" style="margin-left:120px;"><a href="#7.1%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%EF%BC%88MLP%EF%BC%89" rel="nofollow">7.1多层感知机（MLP）</a></p> 
 <p id="7.2%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89-toc" style="margin-left:120px;"><a href="#7.2%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89" rel="nofollow">7.2卷积神经网络（CNN）</a></p> 
 <p id="7.3%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88RNN%EF%BC%89-toc" style="margin-left:120px;"><a href="#7.3%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88RNN%EF%BC%89" rel="nofollow">7.3 循环神经网络（RNN）</a></p> 
 <p id="7.4%20%E9%95%BF%E7%9F%AD%E6%9C%9F%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C%EF%BC%88LSTM%EF%BC%89%E5%92%8C%E9%97%A8%E6%8E%A7%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%85%83%EF%BC%88GRU%EF%BC%89-toc" style="margin-left:120px;"><a href="#7.4%20%E9%95%BF%E7%9F%AD%E6%9C%9F%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C%EF%BC%88LSTM%EF%BC%89%E5%92%8C%E9%97%A8%E6%8E%A7%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%85%83%EF%BC%88GRU%EF%BC%89" rel="nofollow">7.4 长短期记忆网络（LSTM）和门控循环单元（GRU）</a></p> 
 <p id="8.%E6%80%BB%E7%BB%93%E5%92%8C%E8%AE%A8%E8%AE%BA-toc" style="margin-left:80px;"><a href="#8.%E6%80%BB%E7%BB%93%E5%92%8C%E8%AE%A8%E8%AE%BA" rel="nofollow">8.总结和讨论</a></p> 
 <p id="9.%E9%99%84%E5%BD%95-toc" style="margin-left:80px;"><a href="#9.%E9%99%84%E5%BD%95" rel="nofollow">9.附录</a></p> 
</blockquote> 
<h4 id="1.%20%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%A8%E6%9C%BA" style="text-align:justify;"><strong>1. 实验目标和动机</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>实验的目标</strong></strong>是使用MNIST数据集进行手写字符识别。MNIST数据集包含许多手写数字的图像，每个图像都是28x28像素的灰度图像，表示数字0到9。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>实验动机</strong></strong>是探索使用卷积神经网络（CNN）进行图像识别任务，并比较不同网络结构和参数配置对性能的影响。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>输入数据</strong></strong>： 28x28像素的灰度图像</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>网络输出数据</strong></strong>： 预测的数字类别</p> 
<h4 id="2%20CNN%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" style="text-align:justify;"><strong>2 CNN算法的基本原理</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">CNN是一种专门用于处理图像数据的深度学习模型，其核心原理包括卷积层、池化层和全连接层。</p> 
<p style="margin-left:.0001pt;text-align:justify;">卷积神经网络利用<strong><strong>卷积层</strong></strong>来提取图像特征。卷积操作通过滑动卷积核在输入图像上提取局部特征，这有助于捕获图像中的边缘、纹理等信息，并保留空间关系。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>池化层</strong></strong>用于降维和减少特征图的大小，同时保留主要特征。最常见的池化操作是最大池化，它从每个局部区域中选择最大值作为输出，减小了特征图的尺寸并提高了计算效率。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>全连接层</strong></strong>通常位于网络的顶部，将卷积层和池化层提取的特征映射到输出类别。全连接层通过学习权重参数，将特征映射到每个类别的概率，最终实现图像分类。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>激活层</strong></strong>采用激活函数，把卷积层输出结果做非线性映射。在卷积层之后使用，以增加网络的表达能力。常见的激活函数包括ReLU（Rectified Linear Unit）、Sigmoid和Tanh等。ReLU是最常用的激活函数，它能够有效缓解梯度消失问题，并加速网络的收敛速度。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>Softmax层</strong></strong>通常作为网络的最后一层，用于将全连接层的输出转换成各个类别的概率分布。通过对这些概率进行比较，模型可以确定输入图像最可能属于哪个类别。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 id="3%20LeNet5%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84" style="text-align:justify;"><strong>3 LeNet5网络基本架构</strong></h4> 
<p><img alt="" height="374" src="https://images2.imgbox.com/5d/6b/CxXIWMBI_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;">本实验使用CNN的经典模型LeNet5进行手写数字的识别。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>LeNet-5的基本结构</strong></strong>包括7层网络结构（不含输入层），其中包括2个卷积层、2个降采样层（池化层）、2个全连接层和输出层。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1）输入层（Input layer）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">输入层接收大小为28×28 的手写数字图像，其中包括灰度值（0-255）。在本实验中对数据集进行预处理，数据进行了标准化，以加快训练速度和提高模型的准确性。<span style="background-color:#ffff00;">[28,28,1]</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2）卷积层C1（Convolutional layer C1）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">卷积层C1包括6个卷积核，每个卷积核的大小为5×5，步长为1，填充为0。因此，每个卷积核会产生一个大小为28×28的特征图（输出通道数为6）。<span style="background-color:#ffff00;">[28,28,6]</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3）采样层S2（Subsampling layer S2）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">采样层S2采用最大池化（max-pooling）操作，每个窗口的大小为2×2 ，步长为2。因此，每个池化操作会从4个相邻的特征图中选择最大值，产生一个大小为14×14的特征图（输出通道数为6）。<span style="background-color:#ffff00;">[14,14,6]</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4）卷积层C3（Convolutional layer C3）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">卷积层C3包括16个卷积核，每个卷积核的大小为5×5 ，步长为1，填充为0。因此，每个卷积核会产生一个大小为10×10的特征图（输出通道数为16）。<span style="background-color:#ffff00;">[10,10,16]</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>5）采样层S4（Subsampling layer S4）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">采样层S4采用最大池化操作，每个窗口的大小为2×2，步长为2。因此，每个池化操作会从4个相邻的特征图中选择最大值，产生一个大小为5×5的特征图（输出通道数为16）。<span style="background-color:#ffff00;">[5,5,16]</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6）全连接层C5（Fully connected layer C5）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">C5将每个大小为5×5 的特征图拉成一个长度为400的向量，并通过一个带有120个神经元的全连接层进行连接。120是由LeNet-5的设计者根据实验得到的最佳值。<span style="background-color:#ffff00;">[400,]-&gt;[120,]</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7）全连接层F6（Fully connected layer F6）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">全连接层F6将120个神经元连接到84个神经元。<span style="background-color:#ffff00;">[84,]</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8）输出层（Output layer）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">输出层由10个神经元组成，每个神经元对应0-9中的一个数字，并输出最终的分类结果。在训练过程中，使用交叉熵损失函数计算输出层的误差，并通过反向传播算法更新卷积核和全连接层的权重参数。<span style="background-color:#ffff00;">[10,]</span></p> 
<h4 id="4%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" style="text-align:justify;"><strong>4 核心架构的具体实现</strong></h4> 
<pre><code class="language-python"># 构建LeNet-5模型
model = models.Sequential([
    layers.Conv2D(6, kernel_size=(5, 5), strides=(1, 1), activation='relu', input_shape=(28, 28, 1), padding='same'),
    layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2), padding='valid'),
    layers.Conv2D(16, kernel_size=(5, 5), strides=(1, 1), activation='relu', padding='valid'),
    layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2), padding='valid'),
    layers.Flatten(),
    layers.Dense(120, activation='relu'),
    layers.Dense(84, activation='relu'),
    layers.Dense(10, activation='softmax')
])

# 编译模型
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# 训练模型
history = model.fit(train_images, train_labels, epochs=10, batch_size=16, validation_data=(test_images, test_labels))</code></pre> 
<h4 id="5%20%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E5%8F%8A%E8%AF%B4%E6%98%8E" style="text-align:justify;"><strong>5 网络训练和推理过程及说明</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>网络训练过程</strong></strong><strong><strong>：</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fef2f0;">·准备数据: </span>首先需要准备训练数据集和验证数据集。训练数据集通常用来训练模型的参数，验证数据集用来评估模型在训练过程中的性能。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fef2f0;">·构建模型:</span> 定义LeNet5模型的架构，包括输入层、隐藏层、输出层以及它们之间的连接关系。这里通过深度学习框架TensorFlow来实现。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fef2f0;">·定义损失函数和优化器: </span>选择交叉熵作为损失函数和Adam作为优化器。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fef2f0;">·训练模型: </span>将模型与训练数据集进行训练，通过反向传播算法不断优化模型参数，使得模型能够更好地拟合训练数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fef2f0;">·评估模型: </span>使用验证数据集评估训练得到的模型的性能，观察模型在验证集上的表现，并根据评估结果进行调参和优化。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>网络推理过程</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fff5e6;">·准备输入数据: </span>对于需要进行推理的新数据，首先需要进行预处理，使其能够输入到训练好的模型中进行推理。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fff5e6;">·加载模型:</span> 从保存的模型参数中加载训练好的模型。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fff5e6;">·模型推理: </span>将输入数据通过加载的模型进行前向传播，得到模型的输出结果。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fff5e6;">·输出结果</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 id="6%20%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%92%8C%E5%88%86%E6%9E%90" style="text-align:justify;"><strong>6 实验结果对比和分析</strong></h4> 
<h5 id="6.1%20%E4%B8%8D%E5%90%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D" style="text-align:justify;"><strong>6.1 不同神经网络参数对性能的影响</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;">通过对网络模型的不同参数的调整，发现以下几个参数都会对模型的性能产生影响：学习率、优化算法、激活函数、批处理大小。下面是不同的模型参数对模型准确率的影响</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="583" src="https://images2.imgbox.com/91/a2/2XT6zloQ_o.png" width="1107"></p> 
<p style="margin-left:.0001pt;text-align:justify;">上图虽然数据过于多，但是很明显的一点是，当使用随机梯度下降（sgd）最为优化器，sigmoid作为激活函数的时候准确率尤其低，可以发现模型的参数选择非常重要，下面是对不同模型参数的的实验结果比对和研究。</p> 
<h6 id="6.1.1%20%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%A7%E5%B0%8F" style="text-align:justify;"><strong>6.1.1 批处理大小</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;">在本次实验中，我们探究了不同批量大小对LeNet5模型性能的影响。我们使用了批量大小为16、32和64，并记录了每个批量大小下模型在测试集上的准确率。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="635" src="https://images2.imgbox.com/4d/78/XTHNuGf1_o.png" width="1107"></p> 
<p style="margin-left:.0001pt;text-align:justify;">由于有几个点的准确率过于低，使整个折现图不是很直观，于是将上述几个准确率过于低的点去掉，可以得到以下可视化折线图</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="667" src="https://images2.imgbox.com/31/af/RTMMd6BJ_o.png" width="1108"></p> 
<p style="margin-left:.0001pt;text-align:justify;">我们可以明显地观察到，在不同的批量大小下，模型的准确率存在差异。具体来说，批量大小为64时，我们观察到最低的准确率。</p> 
<p style="margin-left:.0001pt;text-align:justify;">一般而言，较大的批量大小可能会降低模型的收敛速度，而较小的批量大小可能导致模型更快地收敛但容易受到数据噪声的影响。这种差异可能是由于不同批量大小下梯度估计的差异所导致。</p> 
<p style="margin-left:.0001pt;text-align:justify;">考虑到模型的性能在不同批量大小下存在明显变化，批量大小的选择在训练深度学习模型时至关重要。然而，并不存在一种适用于所有情况的通用最佳批量大小，因此在选择批量大小时需要综合考虑模型架构、数据集特性和优化器的选择。</p> 
<p style="margin-left:.0001pt;text-align:justify;">综上所述，批量大小作为一个重要的超参数，对于模型的性能具有显著影响。在实践中，我们建议根据具体情况进行实验和验证，以确定最适合的批量大小，从而有效地训练深度学习模型。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h6 id="6.1.2%20%E5%AD%A6%E4%B9%A0%E7%8E%87" style="text-align:justify;"><strong>6.1.2 </strong><strong>学习率</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;">学习率（learning rate）是训练神经网络时一个非常重要的超参数，它决定了模型在每次参数更新时的步长大小。学习率的选择对模型的性能有着直接的影响，过大或过小的学习率都可能导致训练不稳定或性能下降。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果学习率设置过大，可能导致参数更新过大，从而使得模型在参数空间中跳动幅度过大，无法收敛到最优解，甚至可能导致训练过程中出现震荡或不稳定的情况。</p> 
<p style="margin-left:.0001pt;text-align:justify;">相反，如果学习率设置过小，模型参数更新的步长会变得很小，导致训练过程收敛速度缓慢，需要更多的迭代次数才能达到收敛，从而增加训练时间。此外，学习率过小还容易使得模型陷入局部最优解而难以获得全局最优解。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="641" src="https://images2.imgbox.com/45/e6/dTZtYocp_o.png" width="1107"></p> 
<p style="margin-left:.0001pt;text-align:justify;">有6.1.1 可以看出来当batch_size为16时模型性能比较好，下面只可视化batch_size为16时的模型性能</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="635" src="https://images2.imgbox.com/9b/40/uHKbH3MB_o.png" width="1108"></p> 
<p style="margin-left:.0001pt;text-align:justify;">可以看出过大或过小的学习率都可能导致训练不稳定或性能下降。在模型训练时应该选择恰当的学习率。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h6 id="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B6.1.3%C2%A0%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95">​​​​​​​6.1.3 <strong>优化算法</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;">优化算法在训练神经网络时起着至关重要的作用，它决定了模型参数的更新方式和速度。不同的优化算法对模型性能有着直接的影响。</p> 
<p style="margin-left:.0001pt;text-align:justify;">SGD 是最常见的优化算法之一，然而在本实验中，在对MNIST数据集的分类中SGD表现则没有那么良好。</p> 
<p style="margin-left:.0001pt;text-align:justify;">相比其他两个Adam和RMSprop这两个自适应学习率算法，SGD的表现可以说是非常差。</p> 
<p style="margin-left:.0001pt;text-align:justify;">对于 MNIST 这样的任务，Adam 和 RMSprop 这类自适应学习率算法通常能够快速收敛并取得较好的性能。因为这些算法能够自动调整学习率，适应不同特征的分布和参数的尺度，从而更快地收敛到最优解。</p> 
<p style="margin-left:.0001pt;text-align:justify;">综上所述，对于 MNIST 数据集的分类任务，自适应学习率算法（如 Adam 和 RMSprop）通常能够在收敛速度和性能上取得良好的平衡。然而，对于特定的模型架构和超参数设置，不同的优化算法可能会有着不同的表现。</p> 
<h6 id="6.1.4%C2%A0%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0" style="text-align:justify;"><strong>6.1.4 </strong><strong>激活函数</strong></h6> 
<p style="margin-left:.0001pt;text-align:justify;">不同的激活函数（如ReLU、Sigmoid、Tanh等）在网络训练中会对梯度传播和稀疏表示等方面产生不同的影响。实验发现就对MNIST数据集的分类ReLU表现更为好。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="648" src="https://images2.imgbox.com/90/af/VbqLrFvf_o.png" width="1107"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="646" src="https://images2.imgbox.com/92/1c/wQPG0bo7_o.png" width="1107"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="651" src="https://images2.imgbox.com/9f/03/lqkWvsAH_o.png" width="1107"></p> 
<p style="margin-left:.0001pt;text-align:justify;">由上述两个图可以看出SGD（随机梯度下降）与 Sigmoid 激活函数结合导致准确率极为低。尝试分析了一下原因：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1）</strong></strong><strong><strong>梯度消失问题</strong></strong>： Sigmoid 函数具有饱和性，其导数在 0 到 1 之间。在网络的反向传播过程中，当梯度反向传播到较深层时，这种饱和性可能导致梯度消失，使得深层网络参数无法有效地更新，难以学习到复杂的特征表示。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2）<strong><strong>非线性表达受限</strong></strong>： Sigmoid 函数并不是非常适合作为激活函数，因为它只覆盖了一小部分输入范围，导致网络的表达能力受到限制。相比之下，ReLU 或其变体可以更好地处理非线性关系，并且不容易出现梯度消失的问题。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3）<strong><strong>输出分布偏移</strong></strong>： Sigmoid 输出值的范围在 0 到 1 之间，但是在实际应用中，可能需要更广泛的输出分布。特别是对于 MNIST 数据集中的分类问题，期望的输出是 one-hot 编码，即输出节点应该尽可能地接近 0 或 1。Sigmoid 输出的值域不是最理想的，可能导致网络训练困难。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4）<strong><strong>SGD 优化器的限制</strong></strong>： SGD 是一种简单的优化器，可能无法快速收敛到全局最优解。在复杂的模型结构中，SGD 可能会受到局部最小值或者鞍点的影响。</p> 
<h5 id="6.2%20%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%88%86%E6%9E%90" style="text-align:justify;"><strong>6.2 实验结果的分析</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><u><span style="background-color:#ffff00;"><strong><u>通过上述调试参数，最终使用如下参数进行模型的训练和测试,得到实验结果如下：</u></strong></span></u></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">activations = [ 'relu']</p> 
<p style="margin-left:.0001pt;text-align:justify;">learning_rates = [0.001]</p> 
<p style="margin-left:.0001pt;text-align:justify;">optimizers = [ 'adam']</p> 
<p style="margin-left:.0001pt;text-align:justify;">batch_sizes = [16]</p> 
<p style="margin-left:.0001pt;text-align:justify;">epochs = 10</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="898" src="https://images2.imgbox.com/b2/9e/FmHTXc8W_o.png" width="1108"></p> 
<p><img alt="" height="80" src="https://images2.imgbox.com/c6/97/D6auBh7C_o.png" width="916"></p> 
<p style="margin-left:.0001pt;text-align:left;">可视化：</p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="453" src="https://images2.imgbox.com/74/38/F5o3oMg0_o.png" width="1107"></p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/6c/0c/N49sKUPD_o.png" width="1107"></p> 
<p style="margin-left:.0001pt;text-align:left;">可以看出模型预测出错的图片，人眼也很难识别，可见模型的训练还是比较成功的。</p> 
<h4 id="7.%20%E5%90%84%E7%A7%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" style="text-align:justify;"><strong>7. </strong><strong>各种神经网络方法的优缺点</strong></h4> 
<h5 id="7.1%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%EF%BC%88MLP%EF%BC%89" style="text-align:justify;"><strong>7.1</strong><strong>多层感知机（MLP）</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;">优点： ①简单易用，适用于一些简单的分类和回归任务。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②可以进行非线性映射，对一些非线性问题的建模能力较强。</p> 
<p style="margin-left:.0001pt;text-align:justify;">缺点： ①处理图像、语音和自然语言处理等复杂任务的能力有限。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②受限于全连接结构，参数较多，容易过拟合。</p> 
<h5 id="7.2%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89" style="text-align:justify;"><strong>7.2</strong><strong>卷积神经网络（CNN）</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;">优点： ①在图像处理领域表现出色，能够自动提取局部特征。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②参数共享和池化操作减少了模型的参数数量，降低了过拟合风险。</p> 
<p style="margin-left:.0001pt;text-align:justify;">缺点： ①对位置平移和尺度变化敏感，需要大量数据进行训练以获得良好的泛化性能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②不擅长处理序列数据，如文本和时间序列数据。</p> 
<h5 id="7.3%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88RNN%EF%BC%89" style="text-align:justify;"><strong>7.3 </strong><strong>循环神经网络（RNN）</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;">优点： ①适用于处理序列数据，能够捕捉时间上的依赖关系。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②可以处理不定长的输入序列，适用于自然语言处理等任务。</p> 
<p style="margin-left:.0001pt;text-align:justify;">缺点： ①难以捕捉长距离的依赖关系，存在梯度消失和梯度爆炸问题。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②计算效率较低，难以并行化处理。</p> 
<h5 id="7.4%20%E9%95%BF%E7%9F%AD%E6%9C%9F%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C%EF%BC%88LSTM%EF%BC%89%E5%92%8C%E9%97%A8%E6%8E%A7%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%85%83%EF%BC%88GRU%EF%BC%89" style="text-align:justify;"><strong>7.4 </strong><strong>长短期记忆网络（LSTM）和门控循环单元（GRU）</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;">优点： ①解决了传统RNN难以捕捉长距离依赖关系的问题。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②具有记忆单元和门控机制，能够更好地处理长序列任务。</p> 
<p style="margin-left:.0001pt;text-align:justify;">缺点： ①参数较多，需要更多的数据来训练。</p> 
<p style="margin-left:.0001pt;text-align:justify;">②计算成本较高，对硬件要求较高。</p> 
<h4 id="8.%E6%80%BB%E7%BB%93%E5%92%8C%E8%AE%A8%E8%AE%BA" style="text-align:justify;"><strong>8.总结和讨论</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">在MNIST手写字符识别任务中，CNN（例如LeNet-5）模型表现出了较好的性能，能够有效地提取图像特征，获得较高的准确率。</p> 
<p style="margin-left:.0001pt;text-align:justify;">参数调优对模型性能影响显著，如学习率、批处理大小、优化算法和激活函数等。具体调整这些参数能够显著地改变模型的收敛速度和准确率。</p> 
<p style="margin-left:.0001pt;text-align:justify;">不同的优化算法和激活函数对模型性能有重要影响。自适应学习率算法（如Adam、RMSprop）和ReLU激活函数通常能在训练效率和性能上取得较好的平衡。</p> 
<p style="margin-left:.0001pt;text-align:justify;">手写字符识别问题在现代深度学习中仍然是一个重要的研究领域，不同的模型和方法在实际应用中各有优劣。</p> 
<p style="margin-left:.0001pt;text-align:justify;">还有一些对于手写字符识别问题未来的看法和建议：</p> 
<p style="margin-left:.0001pt;text-align:justify;">探索更深层次、更复杂的网络结构，例如ResNet、Inception等，在保持计算效率的同时提高模型性能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">应用更多的数据增强技术和预处理方法，以增加数据集的多样性，提高模型的鲁棒性和泛化能力。</p> 
<p style="margin-left:.0001pt;text-align:justify;">结合迁移学习的方法，利用预训练的模型，在手写字符识别问题上进行fine-tuning。同时，尝试模型融合等集成学习方法，提高模型性能。</p> 
<p style="margin-left:.0001pt;text-align:justify;">随着技术的发展，探索如注意力机制、图神经网络等新技术在手写字符识别中的应用，以提高模型的表达能力。</p> 
<p style="margin-left:.0001pt;text-align:justify;">总体而言，手写字符识别问题仍有许多待解决的挑战，需要进一步的研究和探索新的方法，以应对不同场景下的需求，并不断提升模型性能。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 id="9.%E9%99%84%E5%BD%95" style="text-align:justify;"><strong>9.附录</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">基于LeNet5模型进行MNIST手写数字集的分类，实验完整代码</p> 
<pre><code class="language-python">import tensorflow as tf

from tensorflow.keras import layers, models, datasets

import matplotlib.pyplot as plt



# 加载MNIST数据集

(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()

train_images = train_images.reshape((60000, 28, 28, 1)).astype('float32') / 255

test_images = test_images.reshape((10000, 28, 28, 1)).astype('float32') / 255



# 构建LeNet-5模型

model = models.Sequential([

    layers.Conv2D(6, kernel_size=(5, 5), strides=(1, 1), activation='relu', input_shape=(28, 28, 1), padding='same'),

    layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2), padding='valid'),

    layers.Conv2D(16, kernel_size=(5, 5), strides=(1, 1), activation='relu', padding='valid'),

    layers.AveragePooling2D(pool_size=(2, 2), strides=(2, 2), padding='valid'),

    layers.Flatten(),

    layers.Dense(120, activation='relu'),

    layers.Dense(84, activation='relu'),

    layers.Dense(10, activation='softmax')

])



# 编译模型

model.compile(optimizer='adam',

              loss='sparse_categorical_crossentropy',

              metrics=['accuracy'])



# 训练模型

history = model.fit(train_images, train_labels, epochs=10, batch_size=16, validation_data=(test_images, test_labels))



# 可视化训练过程

plt.plot(history.history['accuracy'], label='accuracy')

plt.plot(history.history['val_accuracy'], label = 'val_accuracy')

plt.xlabel('Epoch')

plt.ylabel('Accuracy')

plt.ylim([0, 1])

plt.legend(loc='lower right')

plt.show()





# 评估模型

test_loss, test_acc = model.evaluate(test_images, test_labels)

print('Test accuracy:', test_acc)



import numpy as np



# 使用训练好的模型对测试集进行预测

predictions = model.predict(test_images)

predicted_labels = np.argmax(predictions, axis=1)



# 找出预测正确和错误的样本

correct_indices = np.where(predicted_labels == test_labels)[0]

incorrect_indices = np.where(predicted_labels != test_labels)[0]



# 输出部分预测错误的样本

plt.figure(figsize=(10, 10))

for i, incorrect_idx in enumerate(incorrect_indices[:25]):

    plt.subplot(5, 5, i + 1)

    plt.imshow(test_images[incorrect_idx].reshape(28, 28), cmap='gray')

    plt.title(f"Predicted: {predicted_labels[incorrect_idx]}, True: {test_labels[incorrect_idx]}")

    plt.axis('off')

plt.tight_layout()

plt.show()



# 输出部分预测正确的样本

plt.figure(figsize=(10, 10))

for i, correct_idx in enumerate(correct_indices[:25]):

    plt.subplot(5, 5, i + 1)

    plt.imshow(test_images[correct_idx].reshape(28, 28), cmap='gray')

    plt.title(f"Predicted: {predicted_labels[correct_idx]}, True: {test_labels[correct_idx]}")

    plt.axis('off')

plt.tight_layout()

plt.show()





# 参数配置实验

activations = ['tanh', 'relu', 'sigmoid']

learning_rates = [0.01, 0.001, 0.0001]

optimizers = ['sgd', 'adam', 'rmsprop']

batch_sizes = [16, 32, 64]

epochs = 3  



results = []



for act in activations:

    for lr in learning_rates:

        for opt in optimizers:

            for batch_size in batch_sizes:

                model = build_lenet5_model(activation=act)

                model.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])

                history = model.fit(train_images, train_labels, batch_size=batch_size, epochs=epochs, validation_data=(test_images, test_labels))

                val_accuracy = history.history['val_accuracy'][-1]  # 获取最终验证准确率

                results.append((act, lr, opt, batch_size, val_accuracy))



import csv





# 将结果保存到CSV文件

filename = 'experiment_results.csv'



with open(filename, mode='w', newline='') as file:

    writer = csv.writer(file)

    writer.writerow(['Activation', 'Learning Rate', 'Optimizer', 'Batch Size', 'Validation Accuracy'])

for result in results:



# 提取结果并进行可视化

labels = [f'{act} LR:{lr} Opt:{opt} Batch:{batch}' for act, lr, opt, batch, _ in results]

accuracy_values = [accuracy for _, _, _, _, accuracy in results]



# 创建条形图

plt.figure(figsize=(15, 8))

plt.bar(labels, accuracy_values, color='skyblue')



# 添加标题和标签

plt.title('Validation Accuracy for Different Hyperparameter Combinations and Batch Sizes')

plt.xlabel('Hyperparameters and Batch Sizes')

plt.ylabel('Validation Accuracy')

plt.xticks(rotation=45, ha='right')

plt.tight_layout()

plt.show()



import csv

import matplotlib.pyplot as plt



# 读取CSV文件数据

filename = 'experiment_results.csv'



with open(filename, mode='r') as file:

    reader = csv.reader(file)

    header = next(reader)  # 读取标题行

    data = [row for row in reader]  # 读取数据行



# 提取数据

batch_sizes = set(row[3] for row in data)

activation_types = set(row[0] for row in data)

learning_rates = set(row[1] for row in data)

optimizers = set(row[2] for row in data)



# 准备数据并过滤性能较差的数据点

batch_size_data = {}

threshold = 0.5  # 设定阈值

for batch_size in batch_sizes:

    accuracies = [float(row[4]) for row in data if row[3] == batch_size and float(row[4]) &gt; threshold]

    batch_size_data[batch_size] = accuracies



# 绘制折线图

plt.figure(figsize=(10, 6))

for batch_size, accuracies in batch_size_data.items():

    # 根据batch_size筛选数据行

    filtered_data = [row for row in data if row[3] == batch_size and float(row[4]) &gt; threshold]

    # 获取当前参数的值作为标签

    labels = [f'{row[0]}, {row[1]}, {row[2]}' for row in filtered_data]

    plt.plot(labels, accuracies, marker='o', label=f'Batch Size: {batch_size}')



# 设置图表属性

plt.title('Model Performance by Different Batch Sizes')

plt.xlabel('Model Parameters')

plt.ylabel('Validation Accuracy')

plt.xticks(rotation=90)  # 旋转X轴标签，以防止重叠

plt.legend()



# 显示图表

plt.tight_layout()

plt.show()</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">Ps：省略了一些重复的代码</p> 
<p style="margin-left:.0001pt;text-align:justify;">文档完成于2023/12/14</p> 
<h5 id="%E7%BC%96%E8%BE%91%E4%BA%8E2023%2F12%2F30" style="margin-left:.0001pt;text-align:justify;">编辑于2023/12/30</h5>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d86f9a44e802b222345a91c8d58703c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python&#43;django高校教材共享管理系统PyCharm 项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae37de117afa54bbb4b6c5c1c3bd9f14/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VIM8 文本实战学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>