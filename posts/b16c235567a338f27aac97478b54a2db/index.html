<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pybind11：python联合c&#43;&#43;编译 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pybind11：python联合c&#43;&#43;编译" />
<meta property="og:description" content="很多时候，单纯用python脚本编译出来的代码，运行速度会比较慢，可以将部分功能改用C&#43;&#43;实现，然后与python联合编译，速度会比较快。
这里使用pybind11库，将C&#43;&#43;代码转换为python可以识别的代码。
pybind11 是一个轻量级的仅标头库，它在 Python 中公开C&#43;&#43;类型，反之亦然，主要用于创建现有C&#43;&#43;代码的 Python 绑定。它的目标和语法类似于David Abrahams的优秀Boost.Python库：通过使用编译时自省推断类型信息来最小化传统扩展模块中的样板代码。
将此库视为 Boost.Python 的小型自包含版本，剥离了与绑定生成无关的所有内容。没有注释，核心头文件只需要~4K行代码，并且依赖于Python（3.6&#43;或PyPy）和C&#43;&#43;标准库。由于一些新的 C&#43;&#43;11 语言功能（特别是：元组、lambda 函数和可变参数模板），这种紧凑的实现成为可能。自创建以来，该库在许多方面都超越了Boost.Python，导致在许多常见情况下的绑定代码大大简化。
1. 获取pybind11 pybind11是 header-only的，因此不需要编译动态链接库，直接解压使用即可。
下载地址：pybind/pybind11 ：https://github.com/pybind/pybind11官方文档：Intro - pybind11 documentation ：https://pybind11.readthedocs.io/en/stable/index.html 下载源码后的文件结构：
. ├── CMakeLists.txt ├── docs ├── include ├── LICENSE ├── MANIFEST.in ├── noxfile.py ├── pybind11 ├── pyproject.toml ├── README.rst ├── SECURITY.md ├── setup.cfg ├── setup.py ├── tests └── tools 可以将下载的文件直接放进工程代码子目录，也可以使用 git submodule 的方法添加子模块
git submodule add https://github.com/pybind/pybind11.git third_party/pybind11-2.11.0 cd third_party/pybind11-2.11.0/ git checkout tags/v2.11.0 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/b16c235567a338f27aac97478b54a2db/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-19T17:08:47+08:00" />
<meta property="article:modified_time" content="2023-10-19T17:08:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pybind11：python联合c&#43;&#43;编译</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>很多时候，单纯用python脚本编译出来的代码，运行速度会比较慢，可以将部分功能改用C++实现，然后与python联合编译，速度会比较快。</p> 
<p>这里使用pybind11库，将C++代码转换为python可以识别的代码。</p> 
<p>pybind11 是一个轻量级的仅标头库，它在 Python 中公开C++类型，反之亦然，主要用于创建现有C++代码的 Python 绑定。它的目标和语法类似于David Abrahams的优秀Boost.Python库：通过使用编译时自省推断类型信息来最小化传统扩展模块中的样板代码。</p> 
<p>将此库视为 Boost.Python 的小型自包含版本，剥离了与绑定生成无关的所有内容。没有注释，核心头文件只需要~4K行代码，并且依赖于Python（3.6+或PyPy）和C++标准库。由于一些新的 C++11 语言功能（特别是：元组、lambda 函数和可变参数模板），这种紧凑的实现成为可能。自创建以来，该库在许多方面都超越了Boost.Python，导致在许多常见情况下的绑定代码大大简化。</p> 
<h3>1. 获取pybind11</h3> 
<p>pybind11是 header-only的，因此不需要编译动态链接库，直接解压使用即可。</p> 
<ul><li><strong>下载地址</strong>：pybind/pybind11 ：https://github.com/pybind/pybind11</li><li><strong>官方文档</strong>：Intro - pybind11 documentation ：https://pybind11.readthedocs.io/en/stable/index.html</li></ul> 
<p>下载源码后的文件结构：</p> 
<pre><code>.
├── CMakeLists.txt
├── docs
├── include
├── LICENSE
├── MANIFEST.in
├── noxfile.py
├── pybind11
├── pyproject.toml
├── README.rst
├── SECURITY.md
├── setup.cfg
├── setup.py
├── tests
└── tools
</code></pre> 
<p>可以将下载的文件直接放进工程代码子目录，也可以使用 git submodule 的方法添加子模块</p> 
<pre><code>git submodule add https://github.com/pybind/pybind11.git third_party/pybind11-2.11.0
cd third_party/pybind11-2.11.0/
git checkout tags/v2.11.0
</code></pre> 
<h3>2. 测试代码</h3> 
<p>randy_pybind11.cpp</p> 
<pre><code class="language-cpp">#include &lt;pybind11/pybind11.h&gt; // pybind11 头文件和命名空间
#include &lt;pybind11/numpy.h&gt;
#include &lt;omp.h&gt;
#include &lt;iostream&gt;

#define STRINGIFY(x) #x
#define MACRO_STRINGIFY(x) STRINGIFY(x)

namespace py = pybind11;

int add(int i, int j)
{
    return i + j;
}

py::array_t&lt;double&gt; add_c(py::array_t&lt;double&gt; arr1, py::array_t&lt;double&gt; arr2) {
    py::buffer_info buf1 = arr1.request(), buf2 = arr2.request();
    if (buf1.shape != buf2.shape)
        throw std::runtime_error("Input shapes must match");
    /* No pointer is passed, so NumPy will allocate the buffer */
    auto result = py::array_t&lt;double&gt;(buf1);
    py::buffer_info buf3 = result.request();
    double* ptr1 = (double*)buf1.ptr,
        * ptr2 = (double*)buf2.ptr,
        * ptr3 = (double*)buf3.ptr;
#pragma omp parallel for
    for (ssize_t idx = 0; idx &lt; buf1.size; idx++)
        ptr3[idx] = ptr1[idx] + ptr2[idx];
    return result;
}


PYBIND11_MODULE(randy_pybind11, m) {
  // 可选，说明这个模块是做什么的
  m.doc() = "Randy pybind11 example plugin";
  // def( "给python调用方法名"， &amp;实际操作的函数， "函数功能说明" ).
  // 其中函数功能说明为可选
  m.def("add", &amp;add, "Adds two numbers");
  m.def("add_c", &amp;add_c, "A function which adds two arrays with c type");
  m.def(
      "subtract", [](int i, int j "") { return i - j; }, R"pbdoc(
        Subtract two numbers

        Some other explanation about the subtract function.
    )pbdoc");

#ifdef VERSION_INFO
  m.attr("__version__") = MACRO_STRINGIFY(VERSION_INFO);
#else
  m.attr("__version__") = "dev";
#endif
}
</code></pre> 
<p><code>PYBIND11_MODULE()</code>宏函数将会创建函数，在<code>Python</code>代码<code>import</code>该函数时会被调用。宏函数的第一个参数为模块名称“randy_pybind11”,第二个参数“m”定义了一个<code>py::module</code>变量。</p> 
<p><code>m.doc</code>是python中要显示的模块信息，通过<code>m.def</code>绑定了2个函数“add”和"add_c",分别实现了整数相加和数组相加。</p> 
<p>使用CMake进行编译，CMakeLists.txt如下：</p> 
<pre><code>cmake_minimum_required(VERSION 2.8.12)

project(randy)

add_definitions(-DVERSION_INFO)

add_subdirectory(./pybind11) // 需要将github上的pybind11源码放到与工程代码同一级目录下

# 此处模块名称randy_pybind11需要与cpp文件名称保持一致
pybind11_add_module(randy_pybind11 randy_pybind11.cpp)
</code></pre> 
<p>编译：</p> 
<pre><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make
</code></pre> 
<p>编译完后，build目录下生成<code>randy_pybind11.cpython-39-x86_64-linux-gnu.so</code>库</p> 
<h4>2.1. 查看模块信息 help(randy_pybind11)</h4> 
<pre><code>&gt;&gt;&gt; import randy_pybind11
&gt;&gt;&gt; help(randy_pybind11)
</code></pre> 
<p>显示的模块信息如下：</p> 
<pre><code>Help on module randy_pybind11:

NAME
    randy_pybind11 - Randy pybind11 example plugin

FUNCTIONS
    add(...) method of builtins.PyCapsule instance
        add(arg0: int, arg1: int) -&gt; int
        
        Adds two numbers
    
    add_c(...) method of builtins.PyCapsule instance
        add_c(arg0: numpy.ndarray[numpy.float64], arg1: numpy.ndarray[numpy.float64]) -&gt; numpy.ndarray[numpy.float64]
        
        A function which adds two arrays with c type
    
    subtract(...) method of builtins.PyCapsule instance
        subtract(arg0: int, arg1: int) -&gt; int
        
        
        Subtract two numbers
        
        Some other explanation about the subtract function.

VERSION
    1

FILE
    /home/qiancj/codes/test/pybind11-test/build/randy_pybind11.cpython-39-x86_64-linux-gnu.so
</code></pre> 
<h4>2.2. python 中引入编译好的so库</h4> 
<pre><code>import sys
sys.path.append("./build")
import numpy as np
import randy_pybind11

def main():
    print("Version: ", randy_pybind11.__version__)
    assert randy_pybind11.__version__ == '1'

    dir(randy_pybind11)
    sum = randy_pybind11.add(2,13)
    print("sum: ", sum)
    sum_c = randy_pybind11.add_c(np.random.randint(60, size=(3, 4, 5)), np.ones((3, 4, 5)))
    print("sum_c: ", sum_c)
    diff = randy_pybind11.subtract(8, 4)
    print("subtract: ", diff)

if __name__ == "__main__":
    main()
</code></pre> 
<p>运行python程序得：</p> 
<pre><code>Version:  1
sum:  15
sum_c:  [[[47. 38. 16. 55. 11.]
  [27. 56. 15. 56. 54.]
  [42. 46.  6. 21. 27.]
  [29. 41. 42. 13.  9.]]

 [[37. 12.  3. 56. 36.]
  [ 1. 51. 51. 31. 35.]
  [33. 22. 10. 44. 39.]
  [58. 27. 20. 14. 59.]]

 [[ 3. 46. 14. 13. 39.]
  [44. 27. 60. 51. 12.]
  [34.  8. 29. 40. 60.]
  [11.  5. 13. 38. 25.]]]

subtract:  4

Process finished with exit code 0
</code></pre> 
<h3>3. 默认参数</h3> 
<p>现在假设要绑定的函数具有默认参数，例如：</p> 
<pre><code>int add(int i = 1, int j = 2) {
    return i + j;
}
</code></pre> 
<p>pybind11 不能自动提取这些默认参数，因为它们并不是函数类型信息的一部分。可以使用 arg 扩展模块使用默认值：</p> 
<pre><code>m.def("add", &amp;add, "A function which adds two numbers",
      py::arg("i") = 1, py::arg("j") = 2);
</code></pre> 
<h3>4. 导出变量</h3> 
<p>要公开C++中的值，相当于使用1个静态变量，可以使用 attr 函数将其注册到模块中，如下所示。</p> 
<p>内置类型和常规对象在指定为属性时会自动转换，并且可以使用函数 <code>py::cast</code> 显式转换。</p> 
<pre><code>PYBIND11_MODULE(sesame, m) {
    m.attr("the_answer") = 213
    py::object randy = py::cast("Randy");
    m.attr("hello") = randy;
}
</code></pre> 
<p>Python中调用：</p> 
<pre><code>import sesame
sesame.the_answer
213
sesame.randy
'Randy'
</code></pre> 
<h3>5. 绑定Numpy数组</h3> 
<p>需要引入头文件<code>&lt;pybind11/numpy.h&gt;</code>，通过<code>pybind11::array_t&lt;T&gt;</code>类可以接收<code>numpy.ndarray</code>数组。</p> 
<p>数组本质上是一块一维的连续内存区域，通过pybind11中的<code>request()</code>函数可以把数组解析成<code>py::buffer_info</code>结构体，buffer_info类型可以公开一个缓冲区视图，它提供对内部数据的快速直接访问。</p> 
<pre><code>struct buffer_info {
    void *ptr = nullptr;          // 指向基础存储的指针
    ssize_t itemsize = 0;         // 单个项目的大小（以字节为单位）
    ssize_t size = 0;             // 条目总数
    std::string format;           // 对于同类缓冲区，应将其设置为 format_descriptor&lt;T&gt;::format()
    ssize_t ndim = 0;             // 尺寸数，即维度
    std::vector&lt;ssize_t&gt; shape;   // 张量的形状（每个维度 1 个条目）
    std::vector&lt;ssize_t&gt; strides; // 相邻条目之间的字节数（对于每个维度）
    bool readonly = false;        // 标志，以指示是否可以将基础存储写入
}
</code></pre> 
<p>需要特别注意strides这个元素代表的是每个维度相邻元素的字节间隔，numpy和C++的数组默认都是行优先存储的</p> 
<p>对于处于同一列相邻行的元素来说，它们在内存上相差了“<code>sizeof(float) * columns</code>”大小，对于同一行相邻列的两个元素，它们在内存上相差了“<code>sizeof(float)</code>”的大小</p> 
<p class="img-center"><img alt="图片" height="545" src="https://images2.imgbox.com/bd/d7/mW2g3s1W_o.png" width="756"></p> 
<p><code>add_c</code>重新实现数组相加，<code>arr.request()</code>解析获得<code>buffer_info</code>对象，通过<code>py::array_t&lt;double&gt;(buffer_info)</code>传入整个buffer_info可以实现<strong>深拷贝（开辟新的内存空间）</strong>重新构造一个完全相同的数组对象，也可以传入一个<code>buffer_info.shape</code>构造形状相同的新数组。</p> 
<p>但是<code>py::array_t</code>的类函数通常比较有限（仅有访问元素\dims\shape\flag\dtype等基础功能），对标numpy中丰富的线性代数操作难以满足</p> 
<p>获取缓冲对象元素的指针<code>buffer.ptr</code>就可以操作元素完成运算，<code>buffer.size</code>是元素的总数，不管数组是多少维度的，其底层表示均是一维数组，可以用一个循环直接遍历所有元素，实现数组元素相加。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="432" src="https://images2.imgbox.com/08/fe/KWfJYYBk_o.png" width="1066"></p> 
<h4>5.1. 直接使用Numpy和Python功能</h4> 
<p>通过<code>py::moudle::attr()</code>就可以实现直接使用Numpy的函数功能，<code>py::moudle::attr()</code>可以链接到当前激活的python环境，直接调用python中相应类型的函数，需要 <code>#include &lt;pybind11/embed.h&gt;</code>。<code>py::module::import()</code>可以将python标准库或当前python环境中定义的对象到C++环境下共同使用，这真正意义上的“<strong>混合编程</strong>”。</p> 
<pre><code>#include &lt;pybind11/pybind11.h&gt;
#include &lt;pybind11/numpy.h&gt;
#include &lt;pybind11/embed.h&gt;
#include &lt;omp.h&gt;
#include &lt;iostream&gt;

namespace py = pybind11;
using namespace py::literals;
py::object np = py::module::import("numpy");


void showarray(py::array_t&lt;double&gt; arr1)
{
    auto local = py::dict();
    py::object amax = arr1.attr("max")();
    py::object shape = arr1.attr("shape");
    py::array_t&lt;double&gt; a1 = np.attr("ones")(std::make_tuple(3, 4, 5),"dtype"_a="double");
    py::print(a1);
    local["arr1"] = arr1;
    auto a2 = py::eval("(arr1==5)",local);
    py::tuple a3 = np.attr("where")(a2);
    int index = a3[0].cast&lt;py::array_t&lt;int&gt;&gt;().at(0);
    py::print(a2);
    py::print(index);
    py::print(shape);
}
</code></pre> 
<p><code>py::object np = py::module::import("numpy")</code> 等价于python中的 <code>import numpy as np</code>，使用格式为</p> 
<pre><code> (py::object变量).attr("python中的函数名")(参数)
</code></pre> 
<p>代码中的等价行为：</p> 
<pre><code>py::object amax = arr1.attr("max")();
py::object shape = arr1.attr("shape");
py::array_t&lt;double&gt; a1 = np.attr("ones")(std::make_tuple(3, 4, 5),"dtype"_a="double");

等价于python中的

arr1.max()
arr1.shape
a1 = np.ones((3,4,5),dtype=double)
</code></pre> 
<p><code>_a</code>是<code>py::literals</code>中的迭代器别名，用来输入python中的Keyword参数，如"<code>dtype _a = double</code>"。</p> 
<p>数组的切片和列表索引特性、布尔数组等python特性无法通过<code>py::moudle::attr()</code>和C++方法给出（<strong>attr()中只能输入函数名，非函数特性则不行</strong>）</p> 
<p>pybind11 提供<code>eval</code>,<code>exec</code>和<code>eval_file</code>函数来直接运行 Python 表达式和语句，如下所示</p> 
<pre><code>#include &lt;pybind11/eval.h&gt;

auto local = py::dict();
local["arr1"] = arr1;
auto a2 = py::eval("(arr1==5)",local);

// Evaluate a sequence of statements
py::exec(
    "print('Hello')\n"
    "print('arr1');",
    local);

// Evaluate the statements in an separate Python file on disk
py::eval_file("script.py", local);
</code></pre> 
<p>local = py::dict() 用来接收和转换python\C++中对应的一组参数，</p> 
<blockquote> 
 <p>py::dict()["python变量名"] = C++变量</p> 
</blockquote> 
<p>py::dict()传入 <code>eval</code>, <code>exec</code>, <code>eval_file</code>时可以接收Python 表达式产生的所有变量，保存变量名为key值，通过下面的语句可以用C++变量接收之。</p> 
<blockquote> 
 <p>C++变量 = py::dict()["python变量名"]</p> 
</blockquote> 
<h3>6. Eigen数组接口</h3> 
<p>pybind11也实现了对Eigen一维和二维数组的直接转换支持，需要包含头文件<code>&lt;pybind11/eigen.h&gt;</code>。</p> 
<h4 style="background-color:transparent;">6.1. Example</h4> 
<p>函数参数和返回值都可以直接使用<code>Eigen::Matrix&lt;T&gt;</code>和<code>Eigen::Array&lt;T&gt;</code>的类型，pybind11会自动转换。</p> 
<pre><code>using namespace Eigen;
MatrixXd add_matrix(MatrixXd matA, MatrixXd matB)
{
    return matA + matB;
}
 
namespace py = pybind11;
PYBIND11_MODULE(add_matrix_moudle, m)
{
    m.doc() = "Matrix add";
    m.def("matrix_add", &amp;add_matrix);
}
</code></pre> 
<p>为了保证内存安全，当普通的Eigen::Matrix对象作为参数和返回值时，pybind11接受 <code>numpy.ndarray</code> 的输入值，将其值复制到临时数组变量，然后用临时变量调用C++函数。即<strong>默认情况下是多进行了一次数组内存拷贝</strong>的，对于计算量很小的矩阵四则运算等操作，这会显著增加函数运行的总时间！</p> 
<p>**使用 <code>Eigen::Ref&lt;MatrixType&gt;</code> 和 <code>Eigen::Map&lt;MatrixType&gt;</code>**，会简单地引用返回的数据，但是须确保这些数据不能在返回前被销毁。</p> 
<p>特别注意，由于 **numpy 和 Eigen 对数据的默认存储顺序不同(Numpy行优先，Eigen列优先)**，需要在创建<code>Eigen::Matrix</code>对象使用<code>Eigen::Rowmajor</code>参数指定为行优先数组，否则转换时有可能会发生内存泄漏导致函数崩溃。</p> 
<p>如果自定义函数中没有使用<code>Eigen::Ref</code> 和 <code>Eigen::Map</code>接收和返回参数，为了避免数组被复制，可以在绑定函数中使用pybind11的<strong>返回值策略</strong> <code>py::return_value_policy::reference_internal</code> 来<strong>返回引用值</strong></p> 
<pre><code>PYBIND11_MODULE(add_mat_moudle, m)
{
    m.doc() = "Matrix add";
    m.def("mat_add_ref", &amp;add_mat, py::return_value_policy::reference_internal);
}
</code></pre> 
<p>稀疏矩阵类型 <code>scipy.sparse.csr_matrix/scipy.sparse.csc_matrix</code> 不支持按引用传递，它们总是被复制按值传递的。</p> 
<h3>7. Class</h3> 
<p>和普通的函数绑定相比，绑定class的时候由<code>m.def</code>转变为了<code>pybind11::class_&lt;class&gt;.def</code>，还需要显式的指定class的构造函数的参数类型。</p> 
<h4>7.1. 最简单的c++类</h4> 
<pre><code>class Student {
    public:
        Student(const std::string &amp;name) : name_(name) { }
        void setName(const std::string &amp;name) { name_ = name; }
        const std::string &amp;getName() const { return name_; }
    private:
        std::string name_;
};


PYBIND11_MODULE(school, m) {
    pybind11::class_&lt;Student&gt;(m, "Student")
        .def(pybind11::init&lt;const std::string &amp;&gt;())
        .def("setName", &amp;Student::setName)
        .def("getName", &amp;Student::getName);
}
</code></pre> 
<p><code>class_</code>为 C++ 类或结构样式的数据结构创建绑定。<code>init()</code> 是一个方便的函数，它将构造函数参数的类型作为模板参数并包装相应的构造函数。</p> 
<p>'Student::name_' 是一个私有的内部变量，只能通过 <code>setter</code> 和 <code>getter</code> 访问。</p> 
<p>通过<code>def_property</code>的定义，我们就可以像访问python的property风格那样访问<code>name_</code>，其实就是通过成员函数访问类的私有变量。</p> 
<p>python中的对象还可以增加动态属性，就是一个class中本没有这个成员，但是直接赋值后也就产生了，这就是动态属性。</p> 
<p>使用<code>pybind11::dynamic_attr()</code>可以实现类似功能，代码如下所示：</p> 
<pre><code>PYBIND11_MODULE(school, m) {
    pybind11::class_&lt;Student&gt;(m, "Student",pybind11::dynamic_attr())
        .def(pybind11::init&lt;const std::string &amp;&gt;())
        .def("setName", &amp;Student::setName)
        .def("getName", &amp;Student::getName)
        .def_property("name_", &amp;Student::getName, &amp;Student::setName);
}
</code></pre> 
<p>运行如下：</p> 
<pre><code>&gt;&gt;&gt; import school
&gt;&gt;&gt; q = school.Student("Randy")
&gt;&gt;&gt; q.age = 7
&gt;&gt;&gt; q.age
7
&gt;&gt;&gt; q.money
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'school.Student' object has no attribute 'money'
&gt;&gt;&gt; q.__dict__
{'age': 7}
</code></pre> 
<p>请注意，具有动态属性的类的运行时开销很小。不仅因为添加了<code>__dict__</code>，还因为必须激活更昂贵的垃圾收集跟踪以解析可能的循环引用。默认情况下，pybind11 类比原生 Python 类更有效。启用动态属性只会使它们相提并论。</p> 
<h5>7.1.1. 绑定lambda表达式</h5> 
<p>我们可以绑定 Lambda 函数将人类可读的摘要返回到名为 <code>__repr__</code> 的特殊方法槽。</p> 
<p>pybind11 支持无状态和有状态 lambda 闭包。无状态闭包是那些将一对空括号 [] 作为捕获对象的闭包。</p> 
<pre><code>py::class_&lt;Pet&gt;(m, "Student")
    .def(py::init&lt;const std::string &amp;&gt;())
    .def("setName", &amp;Pet::setName)
    .def("getName", &amp;Pet::getName)
    .def("__repr__",
        [](const Student &amp;a "") {
            return "&lt;school.Student named '" + a.name_ + "'&gt;";
        }
    );
</code></pre> 
<p>打印摘要：</p> 
<pre><code>print(p)
&lt;school.Student named 'Kim'&gt;
</code></pre> 
<h5>7.1.2. 实例和静态字段</h5> 
<p>可以使用 <code>class_::def_readwrite()</code>方法直接公开 <code>name_</code> 字段。类似的 <code>class_::def_readonly()</code>方法也存在于常量字段。</p> 
<pre><code>py::class_&lt;Pet&gt;(m, "Pet")
    .def(py::init&lt;const std::string &amp;&gt;())
    .def_readwrite("name", &amp;Pet::name)
    // ... remainder ...
</code></pre> 
<p>实际调用：</p> 
<pre><code>&gt;&gt;&gt; p = school.Student("Molly")
&gt;&gt;&gt; p.name
'Molly'
&gt;&gt;&gt; p.name = "Charly"
&gt;&gt;&gt; p.name
'Charly'
</code></pre> 
<p>因为Student::name_为私有成员变量，方法<code>class_::def_property()</code>，<code>class_::def_property_readonly()</code> 用于只读数据，可用于在Python中提供一个类似字段的接口，该接口将透明地调用<code>setter</code>和<code>getter</code>函数：</p> 
<pre><code>py::class_&lt;Pet&gt;(m, "Pet")
    .def(py::init&lt;const std::string &amp;&gt;())
    .def_property("name", &amp;Pet::getName, &amp;Pet::setName)
    // ... remainder ...
</code></pre> 
<h4>7.2. 继承和自动下行转换</h4> 
<p>现在假设该示例由两个具有继承关系的数据结构组成：</p> 
<pre><code>struct Pet {
    Pet(const std::string &amp;name) : name(name) { }
    std::string name;
};

struct Dog : Pet {
    Dog(const std::string &amp;name) : Pet(name) { }
    std::string bark() const { return "woof!"; } // Dog 特有函数
};
</code></pre> 
<p>有两种不同的方法来<strong>指示与pybind11的层次结构关系</strong>：</p> 
<ul><li> <p><strong>将C++基类指定为“<code>class_</code>”的额外模板参数</strong>：</p> </li></ul> 
<pre><code>py::class_&lt;Pet&gt;(m, "Pet")
   .def(py::init&lt;const std::string &amp;&gt;())
   .def_readwrite("name", &amp;Pet::name);

// Method 1: template parameter:
py::class_&lt;Dog, Pet /* &lt;- specify C++ parent type */&gt;(m, "Dog")
    .def(py::init&lt;const std::string &amp;&gt;())
    .def("bark", &amp;Dog::bark);
</code></pre> 
<p>或者，我们也可以为之前绑定的<code>Pet</code> <code>class_</code> 对象赋一个名称，并在绑定<code>Dog</code>类时引用它：</p> 
<pre><code>py::class_&lt;Pet&gt; pet(m, "Pet");
pet.def(py::init&lt;const std::string &amp;&gt;())
   .def_readwrite("name", &amp;Pet::name);

// Method 2: pass parent class_ object:
py::class_&lt;Dog&gt;(m, "Dog", pet /* &lt;- specify Python parent type */)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def("bark", &amp;Dog::bark);
</code></pre> 
<p>在功能方面，这两种方法是等效的。之后，实例将公开两种类型的字段和方法：</p> 
<pre><code>&gt;&gt;&gt; p = example.Dog("Molly")
&gt;&gt;&gt; p.name
'Molly'
&gt;&gt;&gt; p.bark()
'woof!'
</code></pre> 
<p>上面定义的C++类是具有继承关系的常规非多态类型。这反映在 Python 中：</p> 
<pre><code>// Return a base pointer to a derived instance
m.def("pet_store", []( "") { return std::unique_ptr&lt;Pet&gt;(new Dog("Molly")); });
</code></pre> 
<pre><code>&gt;&gt;&gt; p = example.pet_store()
&gt;&gt;&gt; type(p)  # `Dog` instance behind `Pet` pointer
Pet          # no pointer downcasting for regular non-polymorphic types
&gt;&gt;&gt; p.bark()
AttributeError: 'Pet' object has no attribute 'bark'
</code></pre> 
<p>该函数返回了一个<code>Dog</code>实例，但由于它是基指针后面的非多态类型，因此 Python 只能看到“宠物”。在C++中，<strong>仅当一个类型至少有一个虚函数并且 pybind11 将自动识别这一点时，它才被认为是多态的</strong>：</p> 
<pre><code>struct PolymorphicPet {
    virtual ~PolymorphicPet() = default;
};

struct PolymorphicDog : PolymorphicPet {
    std::string bark() const { return "woof!"; }
};

// Same binding code
py::class_&lt;PolymorphicPet&gt;(m, "PolymorphicPet");
py::class_&lt;PolymorphicDog, PolymorphicPet&gt;(m, "PolymorphicDog")
    .def(py::init&lt;&gt;())
    .def("bark", &amp;PolymorphicDog::bark);

// Again, return a base pointer to a derived instance
m.def("pet_store2", []( "") { return std::unique_ptr&lt;PolymorphicPet&gt;(new PolymorphicDog); });
</code></pre> 
<pre><code>&gt;&gt;&gt; p = example.pet_store2()
&gt;&gt;&gt; type(p)
PolymorphicDog  # automatically downcast
&gt;&gt;&gt; p.bark()
'woof!'
</code></pre> 
<p>给定指向多态基的指针，pybind11 自动向下转换到实际派生类型。</p> 
<p>请注意，这<strong>超出了C++中的通常情况</strong>：我们不仅可以访问基的虚函数，还可以获得具体的派生类型，<strong>包括基类型甚至可能不知道的函数和属性</strong>。</p> 
<h3>8. 虚函数</h3> 
<p>假设一个C++类或接口有一个虚函数，我们希望从 Python 中覆盖它（我们将专注于类 <code>Animal</code>; <code>Dog</code> 作为如何使用传统C++代码做到这一点的具体示例给出）。</p> 
<pre><code>class Animal {
public:
    virtual ~Animal() { }
    virtual std::string go(int n_times) = 0;
};

class Dog : public Animal {
public:
    std::string go(int n_times) override {
        std::string result;
        for (int i=0; i&lt;n_times; ++i)
            result += "woof! ";
        return result;
    }
};
</code></pre> 
<p>还有一个普通函数，该函数在任意的<code>Animal</code>实例上调用函数 <code>go()</code>。</p> 
<pre><code>std::string call_go(Animal *animal) {
    return animal-&gt;go(3);
}
</code></pre> 
<p>通常，这些类的绑定代码如下所示：</p> 
<pre><code>PYBIND11_MODULE(example, m) {
    py::class_&lt;Animal&gt;(m, "Animal")
        .def("go", &amp;Animal::go);

    py::class_&lt;Dog, Animal&gt;(m, "Dog")
        .def(py::init&lt;&gt;());

    m.def("call_go", &amp;call_go);
}
</code></pre> 
<p>但是，这些绑定是不可能扩展的：<code>Animal</code>是不可构造的。</p> 
<p>从 Python 中定义一种新型的<code>Animal</code>是可能的，但需要一个定义如下的帮助程序类：</p> 
<pre><code>class PyAnimal : public Animal {
public:
    /* Inherit the constructors */
    using Animal::Animal;

    /* Trampoline (need one for each virtual function) */
    std::string go(int n_times) override {
        PYBIND11_OVERRIDE_PURE(
            std::string, /* Return type */
            Animal,      /* Parent class */
            go,          /* Name of function in C++ (must match Python name) */
            n_times      /* Argument(s) */
        );
    }
};
</code></pre> 
<p>宏<code>PYBIND11_OVERRIDE_PURE</code>应该用于纯虚函数，<code>PYBIND11_OVERRIDE</code>应该用于具有默认实现的函数。还有两个交替宏<code>PYBIND11_OVERRIDE_PURE_NAME</code>和<code>PYBIND11_OVERRIDE_NAME</code>，它们在 <code>Parent</code> 类和函数槽的名称之间采用字符串值名称参数，该参数定义了 Python 中函数的名称。当函数的C++和Python版本具有不同的名称时，这是必需的，例如<code>operator()</code> 与<code>__call__</code>。</p> 
<p>绑定代码还需要一些小的调整（突出显示）：</p> 
<pre><code>PYBIND11_MODULE(example, m) {
    py::class_&lt;Animal, PyAnimal /* &lt;--- trampoline*/&gt;(m, "Animal")
        .def(py::init&lt;&gt;())
        .def("go", &amp;Animal::go);

    py::class_&lt;Dog, Animal&gt;(m, "Dog")
        .def(py::init&lt;&gt;());

    m.def("call_go", &amp;call_go);
}
</code></pre> 
<p>重要的是，pybind11 通过将其指定为 <code>class_</code>的额外模板参数来识别蹦床辅助类。（这也可以与其他模板参数，如自定义持有者类型结合使用;模板类型的顺序无关紧要）。在此之后，我们能够像往常一样定义一个构造函数。</p> 
<p>绑定应该针对实际类进行，而不是针对蹦床帮助程序类。</p> 
<pre><code>py::class_&lt;Animal, PyAnimal /* &lt;--- trampoline*/&gt;(m, "Animal");
    .def(py::init&lt;&gt;())
    .def("go", &amp;PyAnimal::go); /* &lt;--- THIS IS WRONG, use &amp;Animal::go */
</code></pre> 
<p>但是请注意，上述内容足以允许 python 类扩展 Animal，但不能扩展 Dog：需要为继承类提供适当的覆盖支持所需的必要步骤。</p> 
<p>下面的 Python 会话展示了如何覆盖 <code>Animal::go</code> 并通过虚拟方法调用调用它。</p> 
<pre><code>&gt;&gt;&gt; from example import *
&gt;&gt;&gt; d = Dog()
&gt;&gt;&gt; call_go(d)
'woof! woof! woof! '
&gt;&gt;&gt; class Cat(Animal):
...     def go(self, n_times):
...         return "meow! " * n_times
...
&gt;&gt;&gt; c = Cat()
&gt;&gt;&gt; call_go(c)
'meow! meow! meow! '
</code></pre> 
<p>如果要在派生的 Python 类中定义自定义构造函数，则<em>必须</em>确保使用<code>__init__</code>显式调用绑定C++构造函数，<em><strong>无论</strong></em>它是否是默认构造函数。否则，实例C++部分的内存将保持未初始化状态，这通常会使C++实例处于无效状态，并在随后使用C++实例时导致未定义的行为。</p> 
<p>下面是一个示例：</p> 
<pre><code>class Dachshund(Dog):
    def __init__(self, name):
        Dog.__init__(self)  # Without this, a TypeError is raised.
        self.name = name

    def bark(self):
        return "yap!"
</code></pre> 
<p>请注意，应该调用直接的<code>__init__</code>构造函数，并且不应使用 <code>super()</code>。对于简单的线性继承情况， <code>super()</code>可能会起作用，但是一旦你开始混合Python和C++多重继承，由于Python的MRO和C++机制之间的差异，事情就会分崩离析。</p> 
<h4 style="background-color:transparent;">8.1. 结合虚函数和继承</h4> 
<p>将虚拟方法与继承相结合时，需要确保为要允许从派生的 python 类<strong>进行覆盖的每个方法提供覆盖</strong>。例如，假设我们扩展上面的 <code>Animal</code>/<code>Dog</code> 示例，如下所示：</p> 
<pre><code>class Animal {
public:
    virtual std::string go(int n_times) = 0;
    virtual std::string name() { return "unknown"; }
};
class Dog : public Animal {
public:
    std::string go(int n_times) override {
        std::string result;
        for (int i=0; i&lt;n_times; ++i)
            result += bark() + " ";
        return result;
    }
    virtual std::string bark() { return "woof!"; }
};
</code></pre> 
<p><code>Animal</code> 的蹦床类必须，如上一节所述，覆盖<code>go()</code> 和<code>name()</code>，但为了允许 python 代码正确地从<code>Dog</code>继承，我们还需要一个<code>Dog</code>的蹦床类来覆盖添加的<code>bark()</code> 方法  和  从 <code>Animal</code>  继承的 <code>go()</code> 和<code>name()</code>方法（即使<code>Dog</code>没有直接覆盖<code>name()</code>方法）：</p> 
<pre><code>class PyAnimal : public Animal {
public:
    using Animal::Animal; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, Animal, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, Animal, name, ); }
};
class PyDog : public Dog {
public:
    using Dog::Dog; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE(std::string, Dog, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, Dog, name, ); }
    std::string bark() override { PYBIND11_OVERRIDE(std::string, Dog, bark, ); }
};
</code></pre> 
<p>请注意<code>PYBIND11_OVERRIDE</code>调用中的尾随逗号，以 <code>name()</code>和<code>bark()</code>。这些是可移植地为不接受任何参数的函数实现蹦床所必需的。对于采用非零个参数的函数，必须省略尾随逗号。</p> 
<p>从具有虚拟方法的 pybind11 注册类派生的注册类需要类似的蹦床类，<em>即使</em>它没有显式声明或覆盖任何虚拟方法本身：</p> 
<pre><code>class Husky : public Dog {};
class PyHusky : public Husky {
public:
    using Husky::Husky; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, Husky, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, Husky, name, ); }
    std::string bark() override { PYBIND11_OVERRIDE(std::string, Husky, bark, ); }
};
</code></pre> 
<p>但是，有一种技术可用于避免这种重复（这对于具有多个虚拟方法的基类特别有用）。该技术涉及使用模板蹦床类，如下所示：</p> 
<pre><code>template &lt;class AnimalBase = Animal&gt; class PyAnimal : public AnimalBase {
public:
    using AnimalBase::AnimalBase; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, AnimalBase, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, AnimalBase, name, ); }
};
template &lt;class DogBase = Dog&gt; class PyDog : public PyAnimal&lt;DogBase&gt; {
public:
    using PyAnimal&lt;DogBase&gt;::PyAnimal; // Inherit constructors
    // Override PyAnimal's pure virtual go() with a non-pure one:
    std::string go(int n_times) override { PYBIND11_OVERRIDE(std::string, DogBase, go, n_times); }
    std::string bark() override { PYBIND11_OVERRIDE(std::string, DogBase, bark, ); }
};
</code></pre> 
<p>此技术的优点是只需要为每个虚拟方法声明一个蹦床方法和纯虚拟方法重写。</p> 
<p>但是，它确实要求编译器至少生成同样多的方法（如果同时公开纯虚方法和被覆盖的纯虚方法，则可能更多）。</p> 
<p>然后使用以下方法向 pybind11 注册这些类：</p> 
<pre><code>py::class_&lt;Animal, PyAnimal&lt;&gt;&gt; animal(m, "Animal");
py::class_&lt;Dog, Animal, PyDog&lt;&gt;&gt; dog(m, "Dog");
py::class_&lt;Husky, Dog, PyDog&lt;Husky&gt;&gt; husky(m, "Husky");
// ... add animal, dog, husky definitions
</code></pre> 
<p>请注意，<code>Husky</code> 根本不需要专用的蹦床模板类，因为它既没有声明任何新的虚拟方法，也没有提供任何纯虚拟方法实现。</p> 
<p>使用重复虚拟或模板化的蹦床方法，现在可以创建一个继承自 <code>Dog</code>的python类：</p> 
<pre><code>class ShiMin(Dog):
    def bark(self):
        return "yip!"</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9648d86fbe88530c9662a0fcb4d33976/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java虚线程 简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e0a462b3871a6c8109d348f3743ef2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3生成二维码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>