<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker的学习以及使用,利用docker开minecraft服务器 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker的学习以及使用,利用docker开minecraft服务器" />
<meta property="og:description" content="简介 Docker是一个开源的平台，用于开发、交付和运行应用程序。它使用容器技术，允许开发者将应用程序及其依赖项打包到一个轻量级、可移植的容器中。这个容器可以在任何支持Docker的环境中运行，而无需担心环境差异或依赖项冲突。
Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。
下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
安装 Docker Docker Hub
在这上面下载安装包后安装安装时如果勾选WSL2,需要安装好WSL2 Docker优点 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。
更高效的利用系统资源
由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。
更快速的启动时间
传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。
一致的运行环境
开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。
持续交付和部署
对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。
使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。
而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。
更轻松的迁移
由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/b2baf73ee1006f2cf99d538f47ffa8ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-31T15:48:55+08:00" />
<meta property="article:modified_time" content="2023-12-31T15:48:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker的学习以及使用,利用docker开minecraft服务器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_2"></a>简介</h3> 
<p>Docker是一个开源的平台，用于开发、交付和运行应用程序。它使用容器技术，允许开发者将应用程序及其依赖项打包到一个轻量级、可移植的容器中。这个容器可以在任何支持Docker的环境中运行，而无需担心环境差异或依赖项冲突。</p> 
<p>Docker 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/" rel="nofollow">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" rel="nofollow">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="nofollow">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" rel="nofollow">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" rel="nofollow">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" rel="nofollow">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p> 
<p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p> 
<p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p> 
<p><img src="https://images2.imgbox.com/89/40/p1rZG5WT_o.png" alt="传统虚拟化"></p> 
<p><img src="https://images2.imgbox.com/40/d2/rpht1cbI_o.png" alt="Docker"></p> 
<h3><a id="_Docker_16"></a>安装 Docker</h3> 
<p><a href="https://hub.docker.com/" rel="nofollow">Docker Hub</a></p> 
<ol><li>在这上面下载安装包后安装</li><li>安装时如果勾选WSL2,需要安装好WSL2</li></ol> 
<h3><a id="Docker_25"></a>Docker优点</h3> 
<p>作为一种新兴的虚拟化方式，<code>Docker</code> 跟传统的虚拟化方式相比具有众多的优势。</p> 
<p><strong>更高效的利用系统资源</strong></p> 
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p> 
<p><strong>更快速的启动时间</strong></p> 
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p> 
<p><strong>一致的运行环境</strong></p> 
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p> 
<p><strong>持续交付和部署</strong></p> 
<p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps" rel="nofollow">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p> 
<p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <code>Dockerfile</code> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration" rel="nofollow">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery" rel="nofollow">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p> 
<p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p> 
<p><strong>更轻松的迁移</strong></p> 
<p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p> 
<p><strong>更轻松的维护和扩展</strong></p> 
<p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" rel="nofollow">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p> 
<p><strong>对比传统虚拟机总结</strong></p> 
<table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table> 
<h3><a id="_66"></a>基本概念</h3> 
<h4><a id="_68"></a>镜像</h4> 
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、<strong>环境变量</strong>、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p> 
<p><strong>分层存储</strong></p> 
<p>Docker 设计时，充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" rel="nofollow">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成。</p> 
<p>分层存储的特征使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p> 
<h4><a id="_78"></a>容器</h4> 
<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p> 
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="nofollow">命名空间</a>。因此容器可以拥有自己的 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</p> 
<p>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p> 
<h4><a id="_86"></a>数据卷</h4> 
<p>而容器相当于进程并不存储数据,所以数据都存到数据卷中，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p> 
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p> 
<h4><a id="_92"></a>仓库</h4> 
<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> 就是这样的服务。</p> 
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p> 
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" rel="nofollow">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。</p> 
<p>在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。加速器的设置在网上有大量公开资料（<em>Docker 换源</em>）。</p> 
<h3><a id="_104"></a>镜像</h3> 
<p>在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。</p> 
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p> 
<h4><a id="_110"></a>拉取镜像</h4> 
<p><strong>搜索</strong></p> 
<p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p> 
<p>例如以 <code>centos</code> 为关键词进行搜索：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> search centos
NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
centos                                          The official build of CentOS.                   <span class="token number">465</span>       <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
tianon/centos                                   CentOS <span class="token number">5</span> and <span class="token number">6</span>, created using rinse instea<span class="token punctuation">..</span>.   <span class="token number">28</span>
blalor/centos                                   Bare-bones base CentOS <span class="token number">6.5</span> image                <span class="token number">6</span>                    <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
saltstack/centos-6-minimal                                                                      <span class="token number">6</span>                    <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. <span class="token punctuation">..</span>.   <span class="token number">5</span>                    <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
</code></pre> 
<p>下载官方 <code>centos</code> 镜像到本地。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> pull centos
Pulling repository centos
0b443ba03958: Download complete
539c0211cd76: Download complete
511136ea3c5a: Download complete
7064731afe90: Download complete
</code></pre> 
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。</p> 
<h4><a id="_143"></a>推送镜像</h4> 
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p> 
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> tag ubuntu:18.04 username/ubuntu:18.04
$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE
ubuntu                                                   <span class="token number">18.04</span>                  275d79972a86        <span class="token number">6</span> days ago          <span class="token number">94</span>.6MB
username/ubuntu                                          <span class="token number">18.04</span>                  275d79972a86        <span class="token number">6</span> days ago          <span class="token number">94</span>.6MB
$ <span class="token function">docker</span> push username/ubuntu:18.04
$ <span class="token function">docker</span> search username
NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
username/ubuntu
</code></pre> 
<h4><a id="_163"></a>列出镜像</h4> 
<p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        <span class="token number">5</span> days ago          <span class="token number">183</span> MB
nginx                latest              05a60462f8ba        <span class="token number">5</span> days ago          <span class="token number">181</span> MB
mongo                <span class="token number">3.2</span>                 fe9198c04d62        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
<span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>               <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>              00285df0df87        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
ubuntu               <span class="token number">18.04</span>               f753707788c5        <span class="token number">4</span> weeks ago         <span class="token number">127</span> MB
ubuntu               latest              f753707788c5        <span class="token number">4</span> weeks ago         <span class="token number">127</span> MB
</code></pre> 
<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p> 
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p> 
<h5><a id="_182"></a>虚悬镜像</h5> 
<p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>               <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>              00285df0df87        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
</code></pre> 
<p>这类无标签镜像被称为 <strong>虚悬镜像(dangling image)</strong> ，一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> image prune
</code></pre> 
<h4><a id="_198"></a>删除本地镜像</h4> 
<p>比如我们有这么一些镜像：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
centos                      latest              0584b3d2cf6d        <span class="token number">3</span> weeks ago         <span class="token number">196.5</span> MB
redis                       alpine              501ad78535f0        <span class="token number">3</span> weeks ago         <span class="token number">21.03</span> MB
<span class="token function">docker</span>                      latest              cf693ec9b5c7        <span class="token number">3</span> weeks ago         <span class="token number">105.1</span> MB
nginx                       latest              e43d811ce2f4        <span class="token number">5</span> weeks ago         <span class="token number">181.5</span> MB
</code></pre> 
<ul><li>使用ID删除</li></ul> 
<blockquote> 
 <p>ID只要能区分就行了,至少3位,如下删除redis</p> 
</blockquote> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> image <span class="token function">rm</span> <span class="token number">501</span>
</code></pre> 
<ul><li>使用镜像名</li></ul> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> image <span class="token function">rm</span> centos
</code></pre> 
<h3><a id="_227"></a>容器</h3> 
<h4><a id="_229"></a>启动容器</h4> 
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p> 
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p> 
<h5><a id="_235"></a>启动后退出</h5> 
<p>所需要的命令主要为 <code>docker run [Option] &lt;镜像&gt; [CMD]</code>。</p> 
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run ubuntu:18.04 /bin/echo <span class="token string">'Hello world'</span>
Hello world
</code></pre> 
<h5><a id="_246"></a>启动带终端</h5> 
<p><strong>开启终端</strong></p> 
<p>如下, 其中-t表示开启终端,-i表示开启标准输入输出</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-ti</span> ubuntu:18.04 /bin/bash
</code></pre> 
<p><strong>使用终端</strong></p> 
<p>可以在终端输入ps查看进程,可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p> 
<pre><code class="prism language-bash">root@ba267838cc1b:/<span class="token comment"># ps</span>
  PID TTY          TIME CMD
    <span class="token number">1</span> ?        00:00:00 <span class="token function">bash</span>
   <span class="token number">11</span> ?        00:00:00 <span class="token function">ps</span>
</code></pre> 
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p> 
<ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul> 
<h5><a id="_279"></a>启动已终止容器</h5> 
<p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p> 
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p> 
<h4><a id="_285"></a>后台运行</h4> 
<p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。</p> 
<p>此时，可以通过添加 <code>-d</code> 参数来实现。如下</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> ubuntu:18.04 /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do echo hello world; sleep 1; done"</span>
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</code></pre> 
<p>要获取容器的输出信息，可以通过 <code>docker logs</code> 命令。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> logs <span class="token punctuation">[</span>container ID or NAMES<span class="token punctuation">]</span>
hello world
hello world
hello world
<span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span>
</code></pre> 
<h4><a id="_308"></a>查看容器</h4> 
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p> 
<pre><code class="prism language-text">$ docker container ls
CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
77b2dc01fe0f  ubuntu:18.04  /bin/sh -c 'while tr  2 minutes ago  Up 1 minute        agitated_wright
</code></pre> 
<h4><a id="_318"></a>进入容器</h4> 
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p> 
<h5><a id="attach__322"></a><code>attach</code> 命令</h5> 
<p>下面示例如何使用 <code>docker attach</code> 命令。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-dit</span> ubuntu
243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550

$ <span class="token function">docker</span> container <span class="token function">ls</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
243c32535da7        ubuntu:latest       <span class="token string">"/bin/bash"</span>         <span class="token number">18</span> seconds ago      Up <span class="token number">17</span> seconds                           nostalgic_hypatia

$ <span class="token function">docker</span> attach 243c
root@243c32535da7:/<span class="token comment">#</span>
</code></pre> 
<p>如果从这个 stdin 中 exit，会导致容器的停止。</p> 
<h5><a id="exec__340"></a><code>exec</code> 命令</h5> 
<p>同上,查询到id后,就可以exec执行</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 69d1 <span class="token function">bash</span>
root@69d137adef7a:/<span class="token comment">#</span>
</code></pre> 
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p> 
<h4><a id="_351"></a>终止容器</h4> 
<p>除了在上面用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p> 
<p>还可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p> 
<h4><a id="_357"></a>删除容器</h4> 
<p><strong>单次删除</strong></p> 
<p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> container <span class="token function">rm</span>  trusting_newton
trusting_newton
</code></pre> 
<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p> 
<p><strong>清理所有处于终止状态的容器</strong></p> 
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> container prune
</code></pre> 
<h3><a id="_384"></a>数据管理</h3> 
<p><img src="https://images2.imgbox.com/4b/d5/sEPbOjtS_o.png" alt="img"></p> 
<p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p> 
<ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul> 
<h4><a id="_393"></a>数据卷</h4> 
<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p> 
<ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul> 
<blockquote> 
 <p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p> 
</blockquote> 
<h5><a id="_404"></a>创建</h5> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> volume create my-vol
</code></pre> 
<h5><a id="_410"></a>查看</h5> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> volume <span class="token function">ls</span>
<span class="token builtin class-name">local</span>               my-vol
</code></pre> 
<p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> volume inspect my-vol
<span class="token punctuation">[</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>,
        <span class="token string">"Mountpoint"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span>,
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"my-vol"</span>,
        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>,
        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre> 
<h5><a id="_435"></a>启动一个挂载数据卷的容器</h5> 
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p> 
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">--name</span> web <span class="token punctuation">\</span>
    <span class="token parameter variable">--mount</span> <span class="token assign-left variable">source</span><span class="token operator">=</span>my-vol,target<span class="token operator">=</span>/webapp <span class="token punctuation">\</span>
    training/webapp <span class="token punctuation">\</span>
    python app.py
</code></pre> 
<h5><a id="_451"></a>查看具体信息</h5> 
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> inspect web
</code></pre> 
<p><code>数据卷</code> 信息在 “Mounts” Key 下面</p> 
<pre><code class="prism language-json"><span class="token string-property property">"Mounts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token string-property property">"Type"</span><span class="token operator">:</span> <span class="token string">"volume"</span><span class="token punctuation">,</span>
        <span class="token string-property property">"Name"</span><span class="token operator">:</span> <span class="token string">"my-vol"</span><span class="token punctuation">,</span>
        <span class="token string-property property">"Source"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span><span class="token punctuation">,</span>
        <span class="token string-property property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/app"</span><span class="token punctuation">,</span>
        <span class="token string-property property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>
        <span class="token string-property property">"Mode"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
        <span class="token string-property property">"RW"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token string-property property">"Propagation"</span><span class="token operator">:</span> <span class="token string">""</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre> 
<h5><a id="_476"></a>删除</h5> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> volume <span class="token function">rm</span> my-vol
</code></pre> 
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p> 
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> volume prune
</code></pre> 
<h4><a id="_490"></a>挂载主机目录</h4> 
<h5><a id="_492"></a>主机目录作为数据卷</h5> 
<p>使用 <code>--mount type=bind</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">--name</span> web <span class="token punctuation">\</span>
    <span class="token parameter variable">--mount</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span>/src/webapp,target<span class="token operator">=</span>/opt/webapp <span class="token punctuation">\</span>
    training/webapp <span class="token punctuation">\</span>
    python app.py
</code></pre> 
<p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径。</p> 
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">--name</span> web <span class="token punctuation">\</span>
    <span class="token parameter variable">--mount</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span>/src/webapp,target<span class="token operator">=</span>/opt/webapp,readonly <span class="token punctuation">\</span>
    training/webapp <span class="token punctuation">\</span>
    python app.py
</code></pre> 
<p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/opt/webapp</code> 目录新建文件，会显示如下错误</p> 
<pre><code class="prism language-bash">/opt/webapp <span class="token comment"># touch new.txt</span>
touch: new.txt: Read-only <span class="token function">file</span> system
</code></pre> 
<h5><a id="_527"></a>本地主机文件作为数据卷</h5> 
<p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> <span class="token punctuation">\</span>
   <span class="token parameter variable">--mount</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token environment constant">$HOME</span>/.bash_history,target<span class="token operator">=</span>/root/.bash_history <span class="token punctuation">\</span>
   ubuntu:18.04 <span class="token punctuation">\</span>
   <span class="token function">bash</span>

root@2affd44b4667:/<span class="token comment"># history</span>
<span class="token number">1</span>  <span class="token function">ls</span>
<span class="token number">2</span>  diskutil list
</code></pre> 
<p>这样就可以记录在容器输入过的命令了。</p> 
<h3><a id="_546"></a>使用网络</h3> 
<p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p> 
<h4><a id="_550"></a>外部访问容器</h4> 
<p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p> 
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p> 
<p>使用 <code>docker container ls</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> training/webapp python app.py

$ <span class="token function">docker</span> container <span class="token function">ls</span> <span class="token parameter variable">-l</span>
CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES
bc533791f3f5  training/webapp:latest  python app.py <span class="token number">5</span> seconds ago  Up <span class="token number">2</span> seconds  <span class="token number">0.0</span>.0.0:49155-<span class="token operator">&gt;</span><span class="token number">5000</span>/tcp  nostalgic_morse
</code></pre> 
<p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> logs <span class="token parameter variable">-f</span> nostalgic_morse
* Running on http://0.0.0.0:5000/
<span class="token number">10.0</span>.2.2 - - <span class="token punctuation">[</span><span class="token number">23</span>/May/2014 <span class="token number">20</span>:16:31<span class="token punctuation">]</span> <span class="token string">"GET / HTTP/1.1"</span> <span class="token number">200</span> -
<span class="token number">10.0</span>.2.2 - - <span class="token punctuation">[</span><span class="token number">23</span>/May/2014 <span class="token number">20</span>:16:31<span class="token punctuation">]</span> <span class="token string">"GET /favicon.ico HTTP/1.1"</span> <span class="token number">404</span> -
</code></pre> 
<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p> 
<h5><a id="_577"></a>映射所有接口地址</h5> 
<p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 training/webapp python app.py
</code></pre> 
<p>此时默认会绑定本地所有接口上的所有地址。</p> 
<h5><a id="_589"></a>映射到指定地址的指定端口</h5> 
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">127.0</span>.0.1:5000:5000 training/webapp python app.py
</code></pre> 
<h5><a id="_599"></a>映射到指定地址的任意端口</h5> 
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">127.0</span>.0.1::5000 training/webapp python app.py
</code></pre> 
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">127.0</span>.0.1:5000:5000/udp training/webapp python app.py
</code></pre> 
<h5><a id="_617"></a>查看映射端口配置</h5> 
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> port nostalgic_morse <span class="token number">5000</span>
<span class="token number">127.0</span>.0.1:49155.
</code></pre> 
<p>注意：</p> 
<ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul> 
<p>例如</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token punctuation">\</span>
    <span class="token parameter variable">-p</span> <span class="token number">3000</span>:80 <span class="token punctuation">\</span>
    training/webapp <span class="token punctuation">\</span>
    python app.py
</code></pre> 
<h4><a id="_645"></a>容器互联</h4> 
<h5><a id="_647"></a>新建网络</h5> 
<p>下面先创建一个新的 Docker 网络。</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> network create <span class="token parameter variable">-d</span> bridge my-net
</code></pre> 
<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code> <code>host</code>。其中 <code>host</code>网络类型用于将端口直接暴露到宿主机的网络中，<code>overlay</code> 网络类型用于 <code>Swarm mode</code>，在本小节中你可以忽略它。</p> 
<h5><a id="_659"></a>连接容器</h5> 
<p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> busybox1 <span class="token parameter variable">--network</span> my-net busybox <span class="token function">sh</span>
</code></pre> 
<p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--rm</span> <span class="token parameter variable">--name</span> busybox2 <span class="token parameter variable">--network</span> my-net busybox <span class="token function">sh</span>
</code></pre> 
<p>再打开一个新的终端查看容器信息</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> container <span class="token function">ls</span>

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b47060aca56b        busybox             <span class="token string">"sh"</span>                <span class="token number">11</span> minutes ago      Up <span class="token number">11</span> minutes                           busybox2
8720575823ec        busybox             <span class="token string">"sh"</span>                <span class="token number">16</span> minutes ago      Up <span class="token number">16</span> minutes                           busybox1
</code></pre> 
<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p> 
<p>在 <code>busybox1</code> 容器输入以下命令</p> 
<pre><code class="prism language-bash">/ <span class="token comment"># ping busybox2</span>
PING busybox2 <span class="token punctuation">(</span><span class="token number">172.19</span>.0.3<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes
<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.3: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.072</span> ms
<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.3: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.118</span> ms
</code></pre> 
<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p> 
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p> 
<pre><code class="prism language-bash">/ <span class="token comment"># ping busybox1</span>
PING busybox1 <span class="token punctuation">(</span><span class="token number">172.19</span>.0.2<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes
<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.2: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.064</span> ms
<span class="token number">64</span> bytes from <span class="token number">172.19</span>.0.2: <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.143</span> ms
</code></pre> 
<p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p> 
<h5><a id="Docker_Compose_717"></a>Docker Compose</h5> 
<p>如果有多个容器之间需要互相连接，推荐使用 <code>Docker Compose</code>。略。</p> 
<p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p> 
<h3><a id="_725"></a>实战</h3> 
<h4><a id="minecraft_727"></a>minecraft服务器</h4> 
<p>Java 版 Server 镜像：<a href="https://hub.docker.com/r/itzg/minecraft-server" rel="nofollow">itzg/minecraft-server - Docker Image | Docker Hub</a></p> 
<p>进入wsl中,输入以下命令,创建文件夹和获取绝对路径</p> 
<pre><code class="prism language-sh"><span class="token builtin class-name">cd</span> <span class="token comment">#进入当前用户目录</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> minecraft/world1/data <span class="token comment">#用来存世界配置</span>
<span class="token builtin class-name">cd</span> minecraft/world1/data
<span class="token builtin class-name">pwd</span> <span class="token comment">#得到绝对路径 :/home/username/minecraft/world1/data,后面修改配置文件使用</span>
</code></pre> 
<p>然后就是修改配置文件</p> 
<p>我们使用docker compose来批量执行docker命令</p> 
<p>先<a href="https://github.com/itzg/docker-minecraft-server/blob/master/docker-compose.yml">复制</a> 文件内容,内容的解释如下</p> 
<pre><code class="prism language-yml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">mc</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> itzg/minecraft<span class="token punctuation">-</span>server
    <span class="token comment">#使用的镜像,可使用tag指定旧版本</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">EULA</span><span class="token punctuation">:</span> <span class="token string">"true"</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"25565:25565"</span>
     <span class="token comment">#物理机port : 容器机port</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> data<span class="token punctuation">:</span>/data
      <span class="token comment">#物理机路径(绝对路径)/容器机路径</span>
      <span class="token comment">#这里修改前面为上面pwd得到的主机路径</span>
    <span class="token key atrule">stdin_open</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">tty</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped
    <span class="token comment">#关闭了之后自动重开</span>
<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token key atrule">data</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>然后我们</p> 
<pre><code class="prism language-sh"><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>
<span class="token function">vi</span> docker-compose.yml
</code></pre> 
<p>进入后将配置文件复制进去,然后修改物理机路径为前面的绝对路径</p> 
<pre><code class="prism language-sh"><span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span><span class="token comment"># down是关闭服务器</span>
</code></pre> 
<p>然后就会在后台下载docker开始部署</p> 
<p>我们可以<code>docker logs [ID]</code> 查看运行状态,服务器运行成功后</p> 
<p>就可以打开游戏-&gt;多人游戏-&gt;直接连接-&gt;输入<code>localhost:25565</code></p> 
<p><strong>离线模式配置</strong></p> 
<p>如果使用的是离线版,会连接不上,需要我们手动修改配置文件</p> 
<p>先关闭服务器,然后<code>code . </code>用vscode打开当前目录</p> 
<p>然后修改data目录下的server.properties文件的online-mode参数为false</p> 
<blockquote> 
 <p>其他游戏模式这些也可以在这修改</p> 
</blockquote> 
<p>然后就可以启动服务器连接了</p> 
<h3><a id="Dockerfile_803"></a>Dockerfile</h3> 
<p>为了部署我们的应用，我们需要定制一个自己的镜像，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p> 
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p> 
<p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p> 
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p> 
<pre><code class="prism language-bash">$ <span class="token function">mkdir</span> mynginx
$ <span class="token builtin class-name">cd</span> mynginx
$ <span class="token function">touch</span> Dockerfile
</code></pre> 
<p>其内容为：</p> 
<pre><code class="prism language-docker">FROM nginx
RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html
</code></pre> 
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p> 
<h4><a id="FROM__832"></a>FROM 指定基础镜像</h4> 
<p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p> 
<p>在 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" rel="nofollow">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" rel="nofollow"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" rel="nofollow"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" rel="nofollow"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" rel="nofollow"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" rel="nofollow"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" rel="nofollow"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" rel="nofollow"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" rel="nofollow"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" rel="nofollow"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" rel="nofollow"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" rel="nofollow"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" rel="nofollow"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p> 
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" rel="nofollow"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" rel="nofollow"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" rel="nofollow"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" rel="nofollow"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" rel="nofollow"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p> 
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p> 
<pre><code class="prism language-docker">FROM scratch
...
</code></pre> 
<p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p> 
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" rel="nofollow"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" rel="nofollow"><code>etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" rel="nofollow">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p> 
<h4><a id="RUN__853"></a>RUN 执行命令</h4> 
<p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p> 
<ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul> 
<pre><code class="prism language-docker">RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html
</code></pre> 
<ul><li><em>exec</em> 格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code>，这更像是函数调用中的格式。</li></ul> 
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p> 
<pre><code class="prism language-docker">FROM debian:stretch

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make wget
RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
RUN mkdir -p /usr/src/redis
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
</code></pre> 
<p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p> 
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p> 
<p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p> 
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p> 
<pre><code class="prism language-docker">FROM debian:stretch

RUN buildDeps='gcc libc6-dev make wget' \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
    &amp;&amp; mkdir -p /usr/src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;&amp; make -C /usr/src/redis \
    &amp;&amp; make -C /usr/src/redis install \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r /usr/src/redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps
</code></pre> 
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p> 
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p> 
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p> 
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p> 
<h4><a id="COPY__918"></a>COPY 复制文件</h4> 
<p>格式：</p> 
<ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code></li></ul> 
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p> 
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p> 
<pre><code class="prism language-docker">COPY package.json /usr/src/app/
</code></pre> 
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" rel="nofollow"><code>filepath.Match</code></a> 规则，如：</p> 
<pre><code class="prism language-docker">COPY hom* /mydir/
COPY hom?.txt /mydir/
</code></pre> 
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p> 
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p> 
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p> 
<pre><code class="prism language-docker">COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/
</code></pre> 
<h4><a id="CMD__959"></a>CMD 容器启动命令</h4> 
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p> 
<ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></li><li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul> 
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p> 
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p> 
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p> 
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p> 
<pre><code class="prism language-docker">CMD echo $HOME
</code></pre> 
<p>在实际执行中，会将其变更为：</p> 
<pre><code class="prism language-docker">CMD [ "sh", "-c", "echo $HOME" ]
</code></pre> 
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p> 
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p> 
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p> 
<p>一些初学者将 <code>CMD</code> 写为：</p> 
<pre><code class="prism language-docker">CMD service nginx start
</code></pre> 
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p> 
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p> 
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p> 
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p> 
<pre><code class="prism language-docker">CMD ["nginx", "-g", "daemon off;"]
</code></pre> 
<h4><a id="ENTRYPOINT__1017"></a>ENTRYPOINT 入口点</h4> 
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p> 
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p> 
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>ENTRYPOINT<span class="token operator">&gt;</span> <span class="token string">"&lt;CMD&gt;"</span>
</code></pre> 
<p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处么？让我们来看几个场景。</p> 
<h5><a id="_1033"></a>场景一：让镜像变成像命令一样使用</h5> 
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p> 
<pre><code class="prism language-docker">FROM ubuntu:18.04
RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
CMD [ "curl", "-s", "https://ip.cn" ]
</code></pre> 
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run myip
当前 IP：61.148.226.66 来自：北京市 联通
</code></pre> 
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run myip <span class="token parameter variable">-i</span>
docker: Error response from daemon: invalid header field value <span class="token string">"oci runtime error: container_linux.go:247: starting container process caused <span class="token entity" title='\"'>\"</span>exec: <span class="token entity" title="\\">\\</span><span class="token entity" title='\"'>\"</span>-i<span class="token entity" title="\\">\\</span><span class="token entity" title='\"'>\"</span>: executable file not found in <span class="token environment constant">$PATH</span><span class="token entity" title='\"'>\"</span><span class="token entity" title="\n">\n</span>"</span><span class="token builtin class-name">.</span>
</code></pre> 
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s https://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p> 
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run myip <span class="token function">curl</span> <span class="token parameter variable">-s</span> https://ip.cn <span class="token parameter variable">-i</span>
</code></pre> 
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p> 
<pre><code class="prism language-docker">FROM ubuntu:18.04
RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ "curl", "-s", "https://ip.cn" ]
</code></pre> 
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run myip
当前 IP：61.148.226.66 来自：北京市 联通

$ <span class="token function">docker</span> run myip <span class="token parameter variable">-i</span>
HTTP/1.1 <span class="token number">200</span> OK
Server: nginx/1.8.0
Date: Tue, <span class="token number">22</span> Nov <span class="token number">2016</span> 05:12:40 GMT
Content-Type: text/html<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>UTF-8
Vary: Accept-Encoding
X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
X-Cache: MISS from cache-2
X-Cache-Lookup: MISS from cache-2:80
X-Cache: MISS from proxy-2_6
Transfer-Encoding: chunked
Via: <span class="token number">1.1</span> cache-2:80, <span class="token number">1.1</span> proxy-2_6:8006
Connection: keep-alive

当前 IP：61.148.226.66 来自：北京市 联通
</code></pre> 
<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p> 
<h5><a id="_1114"></a>场景二：应用运行前的准备工作</h5> 
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p> 
<p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p> 
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p> 
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p> 
<pre><code class="prism language-docker">FROM alpine:3.4
...
RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis
...
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 6379
CMD [ "redis-server" ]
</code></pre> 
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token punctuation">..</span>.
<span class="token comment"># allow the container to be started with `--user`</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">=</span> <span class="token string">'redis-server'</span> <span class="token parameter variable">-a</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">)</span></span>"</span> <span class="token operator">=</span> <span class="token string">'0'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token function">chown</span> <span class="token parameter variable">-R</span> redis <span class="token builtin class-name">.</span>
  <span class="token builtin class-name">exec</span> su-exec redis <span class="token string">"<span class="token variable">$0</span>"</span> <span class="token string">"<span class="token variable">$@</span>"</span>
<span class="token keyword">fi</span>

<span class="token builtin class-name">exec</span> <span class="token string">"<span class="token variable">$@</span>"</span>
</code></pre> 
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> run <span class="token parameter variable">-it</span> redis <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="ENV__1162"></a>ENV 设置环境变量</h4> 
<p>格式有两种：</p> 
<ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul> 
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p> 
<pre><code class="prism language-Dockerfie">ENV VERSION=1.0 DEBUG=on \
    NAME="Happy Feet"
</code></pre> 
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p> 
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p> 
<pre><code class="prism language-docker">ENV NODE_VERSION 7.2.0

RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \
  &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \
  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
  &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \
  &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \
  &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \
  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs
</code></pre> 
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p> 
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p> 
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p> 
<h4><a id="VOLUME__1202"></a>VOLUME 定义匿名卷</h4> 
<p>格式为：</p> 
<ul><li><code>VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul> 
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p> 
<pre><code class="prism language-docker">VOLUME /data
</code></pre> 
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> mydata:/data xxxx
</code></pre> 
<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p> 
<h4><a id="EXPOSE__1227"></a>EXPOSE 声明端口</h4> 
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p> 
<p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p> 
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p> 
<h4><a id="WORKDIR__1235"></a>WORKDIR 指定工作目录</h4> 
<p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p> 
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p> 
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p> 
<pre><code class="prism language-docker">RUN cd /app
RUN echo "hello" &gt; world.txt
</code></pre> 
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p> 
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p> 
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p> 
<h4><a id="_1256"></a>构建镜像</h4> 
<p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p> 
<p>在 <code>Dockerfile</code> 文件所在目录执行：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> nginx:v3 <span class="token builtin class-name">.</span>
Sending build context to Docker daemon <span class="token number">2.048</span> kB
Step <span class="token number">1</span> <span class="token builtin class-name">:</span> FROM nginx
 ---<span class="token operator">&gt;</span> e43d811ce2f4
Step <span class="token number">2</span> <span class="token builtin class-name">:</span> RUN <span class="token builtin class-name">echo</span> <span class="token string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 9cdc27646c7b
 ---<span class="token operator">&gt;</span> 44aa4490ce2c
Removing intermediate container 9cdc27646c7b
Successfully built 44aa4490ce2c
</code></pre> 
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p> 
<p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> build <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>上下文路径/URL/-<span class="token operator">&gt;</span>
</code></pre> 
<p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p> 
<h4><a id="Context_1288"></a>镜像构建上下文（Context）</h4> 
<p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p> 
<p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" rel="nofollow">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p> 
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p> 
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p> 
<p>如果在 <code>Dockerfile</code> 中这么写：</p> 
<pre><code class="prism language-docker">COPY ./package.json /app/
</code></pre> 
<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p> 
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p> 
<p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p> 
<p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p> 
<pre><code class="prism language-bash">$ <span class="token function">docker</span> build <span class="token parameter variable">-t</span> nginx:v3 <span class="token builtin class-name">.</span>
Sending build context to Docker daemon <span class="token number">2.048</span> kB
<span class="token punctuation">..</span>.
</code></pre> 
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p> 
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p> 
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p> 
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p> 
<p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p> 
<h3><a id="_1332"></a>其他</h3> 
<ul><li><code>Docker</code>官方文档：https://docs.docker.com/</li><li><code>Dockerfie</code> 官方文档：https://docs.docker.com/engine/reference/builder/</li><li><code>Dockerfile</code> 最佳实践文档：https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</li><li><code>Docker</code> 官方镜像 <code>Dockerfile</code>：https://github.com/docker-library/docs</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86200d2b538fc8362b598f69cebd692b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【十一】【C&#43;&#43;\动态规划】1218. 最长定差子序列、873. 最长的斐波那契子序列的长度、1027. 最长等差数列，三道题目深度解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b3e6e061c213feb3dc555f20165714ce/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端八股文（JS篇）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>