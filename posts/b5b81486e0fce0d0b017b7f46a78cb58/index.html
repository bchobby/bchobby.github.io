<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s面试题 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s面试题" />
<meta property="og:description" content="目录
目录
1.K8S介绍
2.让数据持久化
3.K8S存储方案
4.K8S的一些组件和功能
5.你知道哪些K8S方面的资源
6.K8S对资源管理对象的监控
7.K8S监控使用什么 有哪些组件
8.Prometheus 的监控体系
9.pod健康状态的检查和探针的区别
10.集群内、外部的pod怎么访问
11.ingress数据链路怎么走向
12.pod重启策略
13.POD状态
14.POD里有哪些东西
不同node节点pod通讯的过程能讲一下嘛
15.简述Kubernetes 创建一个Pod的主要流程?
16.pod的能达到多少
17.node资源限制
18.用户访问服务的流程
19.k8s添加新的node节点
20.K8S集群网络 21.kube-proxy中使用ipvs与iptables的比较
22.压缩镜像
23.namespace怎么使用 namespace之间怎么协做
24.mq做过哪些运维工作
25.一般怎么部署mq
26.ELK日志收集是怎样的链路
27.日志有哪些操作
Calico插件你们了解过么 里面有哪些模式
1.K8S介绍 Kubernetes是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes能够进行应用的自动化部署和扩缩容。在Kubernetes中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes积累了作为Google生产环境运行工作负载15年的经验，并吸收了来自于社区的最佳想法和实践。Kubernetes经过这几年的快速发展，形成了一个大的生态环境，Google在2014年将Kubernetes作为开源项目。Kubernetes的关键特性包括：
自动化装箱：在不牺牲可用性的条件下，基于容器对资源的要求和约束自动部署容器。同时，为了提高利用率和节省更多资源，将关键和最佳工作量结合在一起。自愈能力：当容器失败时，会对容器进行重启；当所部署的Node节点有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器；直到容器正常运行时，才会对外提供服务。水平扩容：通过简单的命令、用户界面或基于CPU的使用情况，能够对应用进行扩容和缩容。服务发现和负载均衡：开发者不需要使用额外的服务发现机制，就能够基于Kubernetes进行服务发现和负载均衡。自动发布和回滚：Kubernetes能够程序化的发布应用和相关的配置。如果发布有问题，Kubernetes将能够回归发生的变更。保密和配置管理：在不需要重新构建镜像的情况下，可以部署和更新保密和应用配置。存储编排：自动挂接存储系统，这些存储系统可以来自于本地、公共云提供商（例如：GCP和AWS）、网络存储(例如：NFS、iSCSI、Gluster、Ceph、Cinder和Floker等)。 2.让数据持久化 利用NFS-[pv/pvc]实现k8s持久化存储
上面创建了一个pv 挂在了所有的nginx日志目录是有问题的, nginx日志目录应该单独存储,单独存储nginx日志设置:可手动创建多个pvc进行挂在或者进行 volumeClaimTemplates: 自动创建pvc进行挂在。
3.K8S存储方案 pv与pvc
4.K8S的一些组件和功能 etcd:保存了整个集群的状态
APIServer:提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制
controller-manager：负责维护集群核心对象的状态，比如故障检测、自动扩展、滚动更新
scheduler：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上
kubelet：负责维持容器的生命周期，同时也负责Volume和网络的管理
kube-proxy：负责为Server提供cluster内部的服务发现和负载均衡
5.你知道哪些K8S方面的资源 1、创建pod资源
2、ReplicationController资源
3、deployment资源
4、service资源
6.K8S对资源管理对象的监控 metrics-server是集群核心监控数据的聚合器，metrics-server提供了/apis/metrics.k8s.io接口，通过这个接口，用户就可以调用集群的资源使用情况。集群中的节点上的kubelet都内置了cAdvisor服务（专门用于采集集群节点上所有资源情况）。只是cAdvisor缺少了merics-server，merics-server能提供一个统一的api接口。该api接口通过使用k8s中的kube-aggregator代理后端来开启一个访问入口。这个代理程序是集群自动开启的。
Metrics-Server是集群核心监控数据的聚合器，用来替换之前的heapster。 容器相关的 Metrics 主要来自于 kubelet 内置的 cAdvisor 服务，有了Metrics-Server之后，用户就可以通过标准的 Kubernetes API 来访问到这些监控数据。Metrics API 只可以查询当前的度量数据，并不保存历史数据。Metrics API URI 为 /apis/metrics." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/b5b81486e0fce0d0b017b7f46a78cb58/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-12T22:19:50+08:00" />
<meta property="article:modified_time" content="2022-06-12T22:19:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s面试题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="K8S%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#K8S%E4%BB%8B%E7%BB%8D" rel="nofollow">1.K8S介绍</a></p> 
<p id="%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">2.让数据持久化</a></p> 
<p id="3.K8S%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88-toc" style="margin-left:80px;"><a href="#3.K8S%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88" rel="nofollow">3.K8S存储方案</a></p> 
<p id="1.K8S%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#1.K8S%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD" rel="nofollow">4.K8S的一些组件和功能</a></p> 
<p id="2.%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BK8S%E6%96%B9%E9%9D%A2%E7%9A%84%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#2.%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BK8S%E6%96%B9%E9%9D%A2%E7%9A%84%E8%B5%84%E6%BA%90" rel="nofollow">5.你知道哪些K8S方面的资源</a></p> 
<p id="3.K8S%E5%AF%B9%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%91%E6%8E%A7-toc" style="margin-left:80px;"><a href="#3.K8S%E5%AF%B9%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%91%E6%8E%A7" rel="nofollow">6.K8S对资源管理对象的监控</a></p> 
<p id="4.K8S%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%C2%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6-toc" style="margin-left:80px;"><a href="#4.K8S%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%C2%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6" rel="nofollow">7.K8S监控使用什么 有哪些组件</a></p> 
<p id="Prometheus%20%E7%9A%84%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB-toc" style="margin-left:80px;"><a href="#Prometheus%20%E7%9A%84%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB" rel="nofollow">8.Prometheus 的监控体系</a></p> 
<p id="5.pod%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E7%9A%84%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A2%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#5.pod%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E7%9A%84%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A2%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">9.pod健康状态的检查和探针的区别</a></p> 
<p id="3.%E9%9B%86%E7%BE%A4%E5%86%85%E3%80%81%E5%A4%96%E9%83%A8%E7%9A%84pod%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#3.%E9%9B%86%E7%BE%A4%E5%86%85%E3%80%81%E5%A4%96%E9%83%A8%E7%9A%84pod%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE" rel="nofollow">10.集群内、外部的pod怎么访问</a></p> 
<p id="4.ingress%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E5%90%91-toc" style="margin-left:80px;"><a href="#4.ingress%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E5%90%91" rel="nofollow">11.ingress数据链路怎么走向</a></p> 
<p id="5.pod%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#5.pod%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5" rel="nofollow">12.pod重启策略</a></p> 
<p id="6.POD%E7%8A%B6%E6%80%81-toc" style="margin-left:80px;"><a href="#6.POD%E7%8A%B6%E6%80%81" rel="nofollow">13.POD状态</a></p> 
<p id="7.POD%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF-toc" style="margin-left:80px;"><a href="#7.POD%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF" rel="nofollow">14.POD里有哪些东西</a></p> 
<p id="%E4%B8%8D%E5%90%8Cnode%E8%8A%82%E7%82%B9pod%E9%80%9A%E8%AE%AF%E7%9A%84%E8%BF%87%E7%A8%8B%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%98%9B-toc" style="margin-left:80px;"><a href="#%E4%B8%8D%E5%90%8Cnode%E8%8A%82%E7%82%B9pod%E9%80%9A%E8%AE%AF%E7%9A%84%E8%BF%87%E7%A8%8B%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%98%9B" rel="nofollow">不同node节点pod通讯的过程能讲一下嘛</a></p> 
<p id="8.%E7%AE%80%E8%BF%B0Kubernetes%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAPod%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%3F-toc" style="margin-left:80px;"><a href="#8.%E7%AE%80%E8%BF%B0Kubernetes%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAPod%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%3F" rel="nofollow">15.简述Kubernetes 创建一个Pod的主要流程?</a></p> 
<p id="pod%E7%9A%84%E8%83%BD%E8%BE%BE%E5%88%B0%E5%A4%9A%E5%B0%91-toc" style="margin-left:80px;"><a href="#pod%E7%9A%84%E8%83%BD%E8%BE%BE%E5%88%B0%E5%A4%9A%E5%B0%91" rel="nofollow">16.pod的能达到多少</a></p> 
<p id="node%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#node%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6" rel="nofollow">17.node资源限制</a></p> 
<p id="%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B" rel="nofollow">18.用户访问服务的流程</a></p> 
<p id="articleContentId-toc" style="margin-left:80px;"><a href="#articleContentId" rel="nofollow">19.k8s添加新的node节点</a></p> 
<p id="K8S%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%C2%A0-toc" style="margin-left:80px;"><a href="#K8S%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%C2%A0" rel="nofollow">20.K8S集群网络 </a></p> 
<p id="kube-proxy%E4%B8%AD%E4%BD%BF%E7%94%A8ipvs%E4%B8%8Eiptables%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#kube-proxy%E4%B8%AD%E4%BD%BF%E7%94%A8ipvs%E4%B8%8Eiptables%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">21.kube-proxy中使用ipvs与iptables的比较</a></p> 
<p id="%E5%8E%8B%E7%BC%A9%E9%95%9C%E5%83%8F-toc" style="margin-left:80px;"><a href="#%E5%8E%8B%E7%BC%A9%E9%95%9C%E5%83%8F" rel="nofollow">22.压缩镜像</a></p> 
<p id="namespace%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%C2%A0namespace%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E5%8D%8F%E5%81%9A-toc" style="margin-left:80px;"><a href="#namespace%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%C2%A0namespace%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E5%8D%8F%E5%81%9A" rel="nofollow">23.namespace怎么使用 namespace之间怎么协做</a></p> 
<p id="24.mq%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C-toc" style="margin-left:80px;"><a href="#24.mq%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C" rel="nofollow">24.mq做过哪些运维工作</a></p> 
<p id="25.%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2mq-toc" style="margin-left:80px;"><a href="#25.%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2mq" rel="nofollow">25.一般怎么部署mq</a></p> 
<p id="26.ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E9%93%BE%E8%B7%AF-toc" style="margin-left:80px;"><a href="#26.ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E9%93%BE%E8%B7%AF" rel="nofollow">26.ELK日志收集是怎样的链路</a></p> 
<p id="27.%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#27.%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C" rel="nofollow">27.日志有哪些操作</a></p> 
<p id="Calico%E6%8F%92%E4%BB%B6%E4%BD%A0%E4%BB%AC%E4%BA%86%E8%A7%A3%E8%BF%87%E4%B9%88%20%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#Calico%E6%8F%92%E4%BB%B6%E4%BD%A0%E4%BB%AC%E4%BA%86%E8%A7%A3%E8%BF%87%E4%B9%88%20%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F" rel="nofollow">Calico插件你们了解过么 里面有哪些模式</a></p> 
<hr id="hr-toc"> 
<p></p> 
<hr> 
<p></p> 
<h4 id="K8S%E4%BB%8B%E7%BB%8D">1.K8S介绍</h4> 
<p>Kubernetes是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes能够进行应用的自动化部署和扩缩容。在Kubernetes中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes积累了作为Google生产环境运行工作负载15年的经验，并吸收了来自于社区的最佳想法和实践。Kubernetes经过这几年的快速发展，形成了一个大的生态环境，Google在2014年将Kubernetes作为开源项目。Kubernetes的关键特性包括：</p> 
<ul><li>自动化装箱：在不牺牲可用性的条件下，基于容器对资源的要求和约束自动部署容器。同时，为了提高利用率和节省更多资源，将关键和最佳工作量结合在一起。</li><li>自愈能力：当容器失败时，会对容器进行重启；当所部署的Node节点有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器；直到容器正常运行时，才会对外提供服务。</li><li>水平扩容：通过简单的命令、用户界面或基于CPU的使用情况，能够对应用进行扩容和缩容。</li><li>服务发现和负载均衡：开发者不需要使用额外的服务发现机制，就能够基于Kubernetes进行服务发现和负载均衡。</li><li>自动发布和回滚：Kubernetes能够程序化的发布应用和相关的配置。如果发布有问题，Kubernetes将能够回归发生的变更。</li><li>保密和配置管理：在不需要重新构建镜像的情况下，可以部署和更新保密和应用配置。</li><li>存储编排：自动挂接存储系统，这些存储系统可以来自于本地、公共云提供商（例如：GCP和AWS）、网络存储(例如：NFS、iSCSI、Gluster、Ceph、Cinder和Floker等)。</li></ul> 
<h4 id="%E8%AE%A9%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">2.让数据持久化</h4> 
<p>利用NFS-[pv/pvc]实现k8s持久化存储</p> 
<p>上面创建了一个pv 挂在了所有的nginx日志目录是有问题的, nginx日志目录应该单独存储,单独存储nginx日志设置:可手动创建多个pvc进行挂在或者进行 volumeClaimTemplates: 自动创建pvc进行挂在。</p> 
<h4 id="3.K8S%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88">3.K8S存储方案</h4> 
<p><strong>pv与pvc</strong></p> 
<h4 id="1.K8S%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD">4.K8S的一些组件和功能</h4> 
<p>etcd:保存了整个集群的状态<br> APIServer:提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制<br> controller-manager：负责维护集群核心对象的状态，比如故障检测、自动扩展、滚动更新<br> scheduler：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上<br> kubelet：负责维持容器的生命周期，同时也负责Volume和网络的管理<br> kube-proxy：负责为Server提供cluster内部的服务发现和负载均衡</p> 
<h4 id="2.%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BK8S%E6%96%B9%E9%9D%A2%E7%9A%84%E8%B5%84%E6%BA%90">5.你知道哪些K8S方面的资源</h4> 
<p>1、创建pod资源</p> 
<p>2、ReplicationController资源</p> 
<p>3、deployment资源</p> 
<p>4、service资源</p> 
<h4 id="3.K8S%E5%AF%B9%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%91%E6%8E%A7">6.K8S对资源管理对象的监控</h4> 
<p>metrics-server是集群核心监控数据的聚合器，metrics-server提供了/apis/metrics.k8s.io接口，通过这个接口，用户就可以调用集群的资源使用情况。集群中的节点上的kubelet都内置了cAdvisor服务（专门用于采集集群节点上所有资源情况）。只是cAdvisor缺少了merics-server，merics-server能提供一个统一的api接口。该api接口通过使用k8s中的kube-aggregator代理后端来开启一个访问入口。这个代理程序是集群自动开启的。</p> 
<ul><li>Metrics-Server是集群核心监控数据的聚合器，用来替换之前的heapster。</li></ul> 
<ol><li>容器相关的 Metrics 主要来自于 kubelet 内置的 cAdvisor 服务，有了Metrics-Server之后，用户就可以通过标准的 Kubernetes API 来访问到这些监控数据。</li><li>Metrics API 只可以查询当前的度量数据，并不保存历史数据。</li><li>Metrics API URI 为 /apis/metrics.k8s.io/，在 k8s.io/metrics 维护。</li><li>必须部署 metrics-server 才能使用该 API，metrics-server 通过调用 Kubelet Summary API 获取数据。</li></ol> 
<h4 id="4.K8S%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%C2%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6">7.K8S监控使用什么 有哪些组件</h4> 
<p>Prometheus</p> 
<p>Prometheus Server: 普罗米修斯的主服务器,端口号9090<br> NodeEXporter: 负责收集Host硬件信息和操作系统信息，端口号9100<br> cAdvisor:负责收集Host上运行的容器信息,端口号占用8080<br> Grafana：负责展示普罗米修斯监控界面，端口号3000<br> altermanager：等待接收prometheus发过来的告警信息，altermanager再发送给定义的收件人</p> 
<h4 id="Prometheus%20%E7%9A%84%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB">8.Prometheus 的监控体系</h4> 
<p>系统层监控（需要监控的数据）</p> 
<p>CPU、Load、Memory、swap、disk i/o、process 等<br> 网络监控：网络设备、工作负载、网络延迟、丢包率等<br> 中间件及基础设施类监控</p> 
<p>消息中间件：kafka、redis、RocketMQ 等消息代理/中间件<br> WEB 服务器容器：tomcat、weblogic、apache、php、spring 系列<br> 数据库/缓存数据库：MySQL、PostgreSQL、MogoDB、es、redis</p> 
<p><code>应用层监控</code></p> 
<p>用于衡量应用程序代码状态和性能</p> 
<ol><li> <p>白盒监控：自省指标，等待被下载</p> </li><li> <p>黑盒监控：基于探针的监控方式，不会主动干预、影响数据</p> </li><li> <p><code>业务层监控</code></p> </li></ol> 
<p>用于衡量应用程序的价值</p> 
<ol><li> <p>如电商业务的销售量，QPS、dau 日活、转化率等。</p> </li><li> <p>业务接口：登入数量，注册数、订单量、搜索量和支付量。</p> </li></ol> 
<h4 id="5.pod%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E7%9A%84%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A2%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">9.pod健康状态的检查和探针的区别</h4> 
<p>Liveness 和 Readiness</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">LivenessProbe:指示容器是否正在运行，容器存活探针，失败，kublet杀死容器，根据restartPolicy值选择是否重启。如果容器不提供存活探针默认为Success</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">ReadinessProbe:指示容器是否准备好服务请求，若失败断点控制器将从Pod匹配的所有service的端点中删除该Pod的IP地址，初始化完成之前状态默认为Faliure。如果容器不提供就绪探针默认为Success</span></p> 
<h4 id="3.%E9%9B%86%E7%BE%A4%E5%86%85%E3%80%81%E5%A4%96%E9%83%A8%E7%9A%84pod%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE">10.集群内、外部的pod怎么访问</h4> 
<p><img alt="" src="https://images2.imgbox.com/0e/e9/3XxO8XMo_o.png"></p> 
<p>外部 NodePort、LoadBalancer和Ingress</p> 
<p>它们都是将集群外部流量导入到集群内的方式，只是实现方式不同。</p> 
<p>简单理解：绑定域名访问，进行路由规则设定</p> 
<h4 id="4.ingress%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E5%90%91">11.ingress数据链路怎么走向</h4> 
<p>答: Kubernetes的Ingress资源对象，用于将不同URL的访问请求转发到后端不同的<br> Service，以实现HTTP层的业务路由机制。<br> Kubernetes使用了Ingress策略和Ingress Controller，两者结合并实现了一个完整的Ingress负载均衡器。使用Ingress进行负载分发时，Ingress Controller基于Ingress规则将客户端请求直接转发到Service对应的后端Endpoint ( Pod)上，从而跳过kube-proxy的转发功能，kube-proxy不再起作用，全过程为:ingress controller + ingress 规则---&gt; services。<br> 同时当Ingress Controller提供的是对外服务，则实际上实现的是边缘路由器的功能。</p> 
<p>在Kubernetesv 1.1版中添加的Ingress用于从集群外部到集群内部Service的HTTP和HTTPS路由，流量从Internet到Ingress再到Services最后到Pod上，通常情况下，Ingress部署在所有的Node节点上。</p> 
<p>Ingress可以配置提供服务外部访问的URL、负载均衡、终止SSL，并提供基于域名的虚拟主机。但Ingress不会暴露任意端口或协议。</p> 
<h4 id="5.pod%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5">12.pod重启策略</h4> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">1、Pending</span><br><span style="color:#000000;">Pod创建已经提交给k8s，但是因为某种原因不能顺利创建，例如下载镜像慢，调度不成功等</span><br><span style="color:#000000;">故障分析：</span><br><span style="color:#000000;">Pending 说明 Pod 还没有调度到某个 Node 上面。可以通过 kubectl describe pod &lt;pod-name&gt; 命令查看到当前 Pod 的事件，进而判断为什么没有调度。可能的原因包括资源不足，集群内所有的Node都不满足该Pod请求的CPU、内存、GPU等资源</span><br><span style="color:#000000;">2、Running</span><br><span style="color:#000000;">Pod已经绑定到一个节点上了，并且已经创建了所有容器。只是有一个容器正在运行，或者在启动中，这个是属于POD的正常状态</span><br><span style="color:#000000;">3、Waiting</span><br><span style="color:#000000;">容器无法启动，需要检查是否打包了正确的镜像或者是否配置了正确的容器参数</span><br><span style="color:#000000;">故障分析：</span><br><span style="color:#000000;">镜像拉取失败，比如配置了镜像错误、Kubelet无法访问镜像、私有镜像的密钥配置错误、镜像太大，拉取超时等CNI网络错误，一般需要检查 CNI 网络插件的配置，比如无法配置Pod、无法分配IP地址，可以通过通过kubectl describe pod &lt;pod-name&gt;命令查看到当前Pod的事件</span><br><span style="color:#000000;">4、ImagePullBackOff</span><br><span style="color:#000000;">这也是我们测试环境常见的，通常是镜像拉取失败。</span><br><span style="color:#000000;">故障分析：</span><br><span style="color:#000000;">这种情况可以使用 docker pull &lt;image&gt; 来验证镜像是否可以正常拉取。或者docker images | grep &lt;images&gt;查看镜像是否存在（系统有时会因为资源问题自动删除一部分镜像）</span><br><span style="color:#000000;">4、CrashLoopBackOff</span><br><span style="color:#000000;">CrashLoopBackOff状态说明容器曾经启动了，但可能又异常退出了，可能是健康检查失败，容器进程退出等问题</span><br><span style="color:#000000;">故障分析：</span><br><span style="color:#000000;">此时可以先查看一下容器的日志，可以使用kubectl logs kubectl logs --previous这个命令来查看</span><br><span style="color:#000000;">5、Error</span><br><span style="color:#000000;">通常处于Error状态说明Pod启动过程中发生了错误</span><br><span style="color:#000000;">故障分析：</span><br><span style="color:#000000;">依赖的 ConfigMap、Secret 或者 PV 等不存在，请求的资源超过了管理员设置的限制，比如超过了LimitRange等违反集群的安全策略，比如违反了 PodSecurityPolicy等容器无权操作集群内的资源，比如开启RBAC后，需要为ServiceAccount配置角色绑定</span><br><span style="color:#000000;">6、Unkown</span><br><span style="color:#000000;">由于某中原因apiserver无法获取到Pod的状态。通常是由于Master与pod所在的主机失去连接了</span><br><span style="color:#000000;">故障分析：</span><br><span style="color:#000000;">从v1.5开始，Kubernetes不会因为Node失联而删除其上正在运行的Pod，而是将其标记为Terminating或Unknown状态，想要删除这些状态的 Pod 有三种方法</span><br><span style="color:#000000;">1）从集群中删除该Node。使用公有云时，kube-controller-manager 会在VM删除后自动删除对应的Node。而在物理机部署的集群中，需要管理员手动删除 Node（如 kubectl delete node &lt;node-name&gt;。</span><br><span style="color:#000000;">2）Node恢复正常。Kubelet会重新跟kube-apiserver 通信确认这些 Pod 的期待状态，进而再决定删除或者继续运行这些Pod。</span><br><span style="color:#000000;">3）用户强制删除。用户可以执行 kubectl delete pods &lt;pod&gt; --grace-period=0 --force 强制删除 Pod。除非明确知道 Pod 的确处于停止状态（比如 Node 所在 VM 或物理机已经关机），否则不建议使用该方法。特别是 StatefulSet 管理的 Pod，强制删除容易导致脑裂或者数据丢失等问题。</span><br><span style="color:#000000;">7、Evicted</span><br><span style="color:#000000;">出现这种情况，多见于系统内存或硬盘资源不足，可df-h查看docker存储所在目录的资源使用情况，如果百分比大于85%，就要及时清理下资源，尤其是一些大文件、docker镜像。</span><br><span style="color:#000000;">清除状态为Evicted的pod：</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">kubectl get pods | grep Evicted | awk '{print $1}' | xargs kubectl delete pod</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">删除所有状态异常的pod：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">kubectl delete pods $(kubectl get pods | grep -v Running | awk '{print $1}')</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">最后我们整理下，常用的排障命令基本都是一下这些命令</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">kubectl get pod &lt;pod-name&gt; -o yaml 查看 Pod 的配置是否正确</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">kubectl describe pod &lt;pod-name&gt; 查看 Pod 的事件</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">kubectl logs &lt;pod-name&gt; [-c &lt;container-name&gt;] 查看容器日志</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">kubectl exec -it &lt;pod-name&gt;  -- /bin/bash #进入容器查看</span></p> 
<h4 id="6.POD%E7%8A%B6%E6%80%81">13.POD状态</h4> 
<p>Pending: API Server已经创建该Pod，且 Pod内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。<br> Running: Pod内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。<br> Succeeded: Pod内所有容器均成功执行退出，且不会重启。<br> Failed: Pod内所有容器均已退出，但至少有一个容器退出为失败状态。</p> 
<p>Unknown:由于某种原因无法获取该Pod状态，可能由于网络通信不畅导致。</p> 
<h4 id="7.POD%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF">14.POD里有哪些东西</h4> 
<p>Pod 中的容器又能分三类：基础容器（pause）；初始化容器；应用容器。</p> 
<p>基础容器（pause）：给 pod 中的所有应用容器提供网络和存储资源的共享；提供 init 进程。管理整个pod 里的容器组的生命周期<br> 初始化容器（init 容器）：是在应用容器之前完成所有 init 容器的启动，多个init容器是串行启动。每个 - Init容器都必须在下一个Init容器启动之前成功完成启动。<br> 应用容器：提供应用程序业务。并行启动。</p> 
<h4 id="%E4%B8%8D%E5%90%8Cnode%E8%8A%82%E7%82%B9pod%E9%80%9A%E8%AE%AF%E7%9A%84%E8%BF%87%E7%A8%8B%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%98%9B" style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">不同node节点pod通讯的过程能讲一下嘛</span></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">借助于cni（网络） 插件，我们使用的是flannel calico cannel</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">不同节点直接pod通讯</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">首先，定义两个节点 主机A POD-A 主机B POD-B</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">① POD-A首先会发送给docker 0 网桥（网关）</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">② docker 0会转发给flannel0网桥 </span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">PS：详细话术docker 0(网桥会被flannel 0 网桥以钩子函数的方式获取到转发信息)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">③ flannel 0 会转发给flanneld (后台进程)，flanned会到ETCD中查看ETCD维护的路由表条目/信息，确认往哪去发送</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">ETCD-路由表有哪些flanneld需要知道的信息</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">获取到pod-b所在的node节点 ——》主机B(MAC和IP)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">获取到主机A如何到主机B，从哪个物理网卡通过 （宿主机）</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">④ flanned 会在转发给宿主机的物理网卡</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">⑤ 物理网卡会以UDP的方式转发数据包</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">（数据包中除了主机A和主机B的源IP和目标IP之外，还会将POD-A和POD-B的源/目标IP封装在UDP协议之后）</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">主机B接收到</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">① 首先解封装，发现源MAC/IP地址是找自己的（主机MAC/IP地址）</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">② UDP 转发过来，解封装之后，发现了封装在UDP内部的 POD-IP（源/目标）</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">③ 主机B的物理网卡就会发送给flanned进行处理</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">④ 而flanned会查询ETCD中维护的路由表信息，发现是自己的pod(需要确认找的是哪个docker网桥)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">⑤ flanned 会发送给自己的flannel0网桥，flannel网桥再发送给对应的docker (0)网桥</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">⑥ docker 网桥（网关），会把这个数据包发送给对应的POD-B</span></p> 
<h4 id="8.%E7%AE%80%E8%BF%B0Kubernetes%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAPod%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%3F">15.简述Kubernetes 创建一个Pod的主要流程?</h4> 
<p>1.用户通过kubectl命名发起请求。<br> 2.apiserver通过对应的kubeconfig进行认证，认证通过后将yaml中的Pod 信息存到etcd。<br> 3.Controller-Manager通过apiserver的 watch接口发现了Pod信息的更新，执行该资源所依赖的拓扑结构整合，整合后将对应的信息交给apiserver，apiserver写到etcd，此时Pod已经可以被调度了。<br> 4.Scheduler同样通过apiserver的watch接口更新到Pod可以被调度，通过算法给Pod分配节点，并将pod和对应节点绑定的信息交给apiserver，apiserver 写到etcd，然后将Pod交给kubelet。<br> 5.kubelet收到 Pod后，调用CNI接口给Pod创建Pod网络，调用CRI接口去启动容器，调用CSI进行存储卷的挂载。</p> 
<h4 id="pod%E7%9A%84%E8%83%BD%E8%BE%BE%E5%88%B0%E5%A4%9A%E5%B0%91">16.pod的能达到多少</h4> 
<p>一个node有7个</p> 
<h4 id="node%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">17.node资源限制</h4> 
<p>资源的限制类型</p> 
<p>资源类型:<br> • CPU 的单位是核心数，内存的单位是字节。<br> • 一个容器申请0.5个CPU，就相当于申请1个CPU的一半，你也可以加个后缀 m 表示千分之一的概念。比如说100m的CPU，100豪的CPU和0.1个CPU都是一样的。<br> 内存单位：<br> • K、M、G、T、P、E #通常是以1000为换算标准的。<br> • Ki、Mi、Gi、Ti、Pi、Ei #通常是以1024为换算标准的<br>  <a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020" title="内存">内存</a>限制     CPU限制      为namespace设置资源限制</p> 
<h4 id="%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B">18.用户访问服务的流程</h4> 
<p>1.DNS解析：客户端用户从浏览器输入www.baidu.com网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的；<br> 2.TCP连接：通过dns解析拿到ip地址后，就可以通过ip向服务器发送http请求了，因为http是工作在第七层应用层，tcp是工作在第四层传输层，所以发生http请求之前，还会进行tcp的三次握手。<br> 3.发送HTTP请求：http的请求报文，主要包括，请求行，请求头部，空行，请求主体<br> 4.服务器处理请求并返回HTTP报文<br> 5.浏览器解析渲染页面<br> 6.连接结束<br>  </p> 
<h4 id="articleContentId">19.k8s添加新的node节点</h4> 
<p>1、初始化系统</p> 
<p>2、关闭防火墙，SELINUX,关闭SWAP分区，配置IPTABLES,建立对应的目录，添加用户，调整内核参数，安装必要的软件等等</p> 
<p>3、添加docker仓库配置</p> 
<p>4、从原有的<a href="https://so.csdn.net/so/search?q=node&amp;spm=1001.2101.3001.7020" title="node">node</a>节点上拷贝执行文件、服务</p> 
<p>5、在master节点上创建token</p> 
<p>6、master服务器 签证证</p> 
<h4 id="K8S%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%C2%A0">20.K8S集群网络 </h4> 
<p><code>Calico</code> 是一套开源的网络和网络安全方案，用于容器、<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;spm=1001.2101.3001.7020" title="虚拟机">虚拟机</a>、宿主机之前的网络连接，可以用在kubernetes、OpenShift、DockerEE、OpenStrack等PaaS或IaaS平台上。</p> 
<p>Calico 组件概述</p> 
<ul><li><code>Felix</code>：calico的核心组件，运行在每个节点上。主要的功能有<code>接口管理</code>、<code>路由规则</code>、<code>ACL规则</code>和<code>状态报告</code> 
  <ul><li><code>接口管理</code>：Felix为内核编写一些接口信息，以便让内核能正确的处理主机endpoint的流量。特别是主机之间的ARP请求和处理ip转发。</li><li><code>路由规则</code>：Felix负责主机之间路由信息写到linux内核的FIB（Forwarding Information Base）转发信息库，保证数据包可以在主机之间相互转发。</li><li><code>ACL规则</code>：Felix负责将ACL策略写入到linux内核中，保证主机endpoint的为有效流量不能绕过calico的安全措施。</li><li><code>状态报告</code>：Felix负责提供关于网络健康状况的数据。特别是，它报告配置主机时出现的错误和问题。这些数据被写入etcd，使其对网络的其他组件和操作人员可见。</li></ul></li><li><code>Etcd</code>：保证数据一致性的数据库，存储集群中节点的所有路由信息。为保证数据的可靠和容错建议至少三个以上etcd节点。</li><li><code>Orchestrator plugin</code>：协调器插件负责允许kubernetes或OpenStack等原生云平台方便管理Calico，可以通过各自的API来配置Calico网络实现无缝集成。如kubernetes的cni网络插件。</li><li><code>Bird</code>：BGP客户端，Calico在每个节点上的都会部署一个BGP客户端，它的作用是将Felix的路由信息读入内核，并通过BGP协议在集群中分发。当Felix将路由插入到Linux内核FIB中时，BGP客户端将获取这些路由并将它们分发到部署中的其他节点。这可以确保在部署时有效地路由流量。</li><li><code>BGP Router Reflector</code>：大型网络仅仅使用 BGP client 形成 mesh 全网互联的方案就会导致规模限制，所有节点需要 N^2 个连接，为了解决这个规模问题，可以采用 <code>BGP 的 Router Reflector</code> 的方法，使所有 BGP Client 仅与特定 RR 节点互联并做路由同步，从而大大减少连接数。</li><li><code>Calicoctl</code>： calico 命令行管理工具。</li></ul> 
<p>更优的资源利用</p> 
<p>二层网络通讯需要依赖广播消息机制，广播消息的开销与 host 的数量呈指数级增长，Calico 使用的三层路由方法，则完全抑制了二层广播，减少了资源开销。</p> 
<p>另外，二层网络使用 VLAN 隔离技术，天生有 4096 个规格限制，即便可以使用 vxlan 解决，但 vxlan 又带来了隧道开销的新问题。而 Calico 不使用 vlan 或 vxlan 技术，使资源利用率更高。</p> 
<p>可扩展性</p> 
<p>Calico 使用与 Internet 类似的方案，Internet 的网络比任何数据中心都大，Calico 同样天然具有可扩展性。</p> 
<p>简单而更容易 debug</p> 
<p>因为没有隧道，意味着 workloads 之间路径更短更简单，配置更少，在 host 上更容易进行 debug 调试。</p> 
<p>更少的依赖</p> 
<p>Calico 仅依赖三层路由可达。</p> 
<p>可适配性</p> 
<p>Calico 较少的依赖性使它能适配所有 VM、Container、白盒或者混合环境场景。</p> 
<h4 id="kube-proxy%E4%B8%AD%E4%BD%BF%E7%94%A8ipvs%E4%B8%8Eiptables%E7%9A%84%E6%AF%94%E8%BE%83">21.kube-proxy中使用ipvs与iptables的比较</h4> 
<p style="margin-left:5.5pt;text-align:justify;"><span style="color:#333333;">iptables</span><span style="color:#333333;">与</span><span style="color:#333333;">IPVS</span><span style="color:#333333;">都是基于</span><span style="color:#333333;">Netfilter</span><span style="color:#333333;">实现的，但因为定位不同，二者有着本质的差别：</span><span style="color:#333333;">iptables</span><span style="color:#333333;">是为防火墙</span> <span style="color:#333333;">而设计的；</span><span style="color:#333333;">IPVS</span><span style="color:#333333;">则专门用于高性能负载均衡，并使用更高效的数据结构</span><span style="color:#333333;">(Hash</span><span style="color:#333333;">表</span><span style="color:#333333;">)</span><span style="color:#333333;">，允许几乎无限的规模</span> <span style="color:#333333;">扩张。</span></p> 
<p><span style="color:#333333;">与</span><span style="color:#333333;">iptables</span><span style="color:#333333;">相比，</span><span style="color:#333333;">IPVS</span><span style="color:#333333;">拥有以下明显优势：</span> <span style="color:#333333;">为大型集群提供了更好的可扩展性和性能；</span> <span style="color:#333333;">支持比</span><span style="color:#333333;">iptables</span><span style="color:#333333;">更复杂的复制均衡算法</span><span style="color:#333333;">(</span><span style="color:#333333;">最小负载、最少连接、加权等</span><span style="color:#333333;">)</span><span style="color:#333333;">；</span> <span style="color:#333333;">支持服务器健康检查和连接重试等功能；</span> <span style="color:#333333;">可以动态修改</span><span style="color:#333333;">ipset</span><span style="color:#333333;">的集合，即使</span><span style="color:#333333;">iptables</span><span style="color:#333333;">的规则正在使用这个集合。</span></p> 
<h4 id="%E5%8E%8B%E7%BC%A9%E9%95%9C%E5%83%8F">22.压缩镜像</h4> 
<p id="%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%951%EF%BC%9A%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BE%93%E5%87%BA%E7%9A%84%E6%8C%87%E4%BB%A4%E4%B8%A2%E5%85%A5%2Fdev%2Fnull%20%EF%BC%88%E9%9C%80%E8%A6%81%E7%A1%AE%E5%AE%9A%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%89">优化方法1：不需要输出的指令丢入/dev/null （需要确定命令执行的是正确的）</p> 
<p id="%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%952%EF%BC%9A%E5%87%8F%E5%B0%91RUN%E6%9E%84%E5%BB%BA">优化方法2：减少RUN构建</p> 
<p id="%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%953%EF%BC%9A%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA%EF%BC%88%E4%BD%BF%E7%94%A8FROM%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AA%E9%95%9C%E5%83%8F%EF%BC%8C%E5%B0%86%E6%8C%87%E5%AE%9A%E7%9A%84%E9%95%9C%E5%83%8F%E5%81%9A%E4%B8%BA%E5%85%B6%E4%BB%96%E9%95%9C%E5%83%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E7%8E%AF%E5%A2%83%E6%9D%A5%E6%9E%84%E5%BB%BA%EF%BC%89">优化方法3：多阶段构建（使用FROM命令生成多个镜像，将指定的镜像做为其他镜像的基础镜像环境来构建）</p> 
<p id="%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%954%3A%20%E4%BD%BF%E7%94%A8%E6%9B%B4%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84linux%20%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC">优化方法4: 使用更为轻量级的linux 发行版本</p> 
<h4 id="namespace%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%C2%A0namespace%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E5%8D%8F%E5%81%9A">23.namespace怎么使用 namespace之间怎么协做</h4> 
<p>把名字改成自己想要的名字     主机可以自动实现连接</p> 
<h4 id="24.mq%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C">24.mq做过哪些运维工作</h4> 
<p>MQ集群的日常监控          <a href="https://so.csdn.net/so/search?q=zabbix&amp;spm=1001.2101.3001.7020" title="zabbix">zabbix</a>监控MQ集群</p> 
<p>短信报警：<br> 如果MQ集群的<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020" title="队列">队列</a>数量超过100000就会发短信报警；或者MQ的服务出现故障也会发送短信报警</p> 
<p>2:面监控：<br> 登录zabbix监控页面查看是否有报警；</p> 
<p>3:zabbix系统自带的管理页面查看：<br> 使用admin账户登录zabbix系统自带的管理页面</p> 
<p>4:此处的ready就是MQ集群整体所有的未消费消息数量，如果需要看具体那个队列堆积数量比较大</p> 
<p>消息队列的优缺点<br> 优点<br> 上面已经说过了，系统解耦，异步调用，流量削峰。<br> 缺点<br> ①系统可用性降低：系统引入的外部依赖越多，系统要面对的风险越高，拿场景一来说，本来ABCD四个系统配合的好好的，没啥问题，但是你偏要弄个MQ进来插一脚，虽然好处挺多，但是万一MQ挂掉了呢，那样你系统不也就挂掉了。<br> ②系统复杂程度提高：非要加个MQ进来，如何保证没有重复消费呢？如何处理消息丢失的情况？怎么保证消息传递的顺序？问题太多。<br> ③一致性的问题：A系统处理完再传递给MQ就直接返回成功了，用户以为你这个请求成功了，但是，如果在BCD的系统里，BC两个系统写库成功，D系统写库失败了怎么办，这样就导致数据不一致了。<br> 所以。消息队列其实是一套非常复杂的架构，你在享受MQ带来的好处的同时，也要做各种技术方案把MQ带来的一系列的问题解决掉，等一切都做好之后，系统的复杂程度硬生生提高了一个等级。</p> 
<h4 id="25.%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2mq">25.一般怎么部署mq</h4> 
<p>1、下载文件</p> 
<p>2、创建namespace</p> 
<p>3、创建持久化pv</p> 
<p>4、访问测试</p> 
<h4 id="26.ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E9%93%BE%E8%B7%AF">26.ELK日志收集是怎样的链路</h4> 
<ul><li>AppServer 是一个类似于 Nginx、Apache 的集群，其日志信息由 Logstash 来收集</li><li>往往为了减少网络问题所带来的瓶颈，会把 Logstash 服务放入前者的集群内，减少网络的消耗</li><li>Logstash 把收集到的日志数据格式化后输出转存至 ES 数据库内（这是一个将日志进行集中化管理的过程）</li><li>随后，Kibana 对 ES 数据库内格式化后日志数据信息进行索引和存储</li><li>最后，Kibana 把其展示给客户端<br>  </li></ul> 
<h4 id="27.%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">27.日志有哪些操作</h4> 
<p>一.日志查看</p> 
<p>1、进入日志文件所在的文件目录，比如：</p> 
<p>cd /opt/tomcat7/logs<br> 2、通过命令打开日志，分析需求场景打开需要的日志</p> 
<p>比如：</p> 
<p>tail -f catalina.out<br> 3、常用命令一：tail</p> 
<p>比如：</p> 
<p>tail -f test.log (循环查看文件内容)<br> 4、按照行号查询：cat（过滤出关键字附近的日志）</p> 
<p>cat -n test.log |<a href="https://so.csdn.net/so/search?q=grep&amp;spm=1001.2101.3001.7020" title="grep">grep</a> “订单号”<br> 然后使用 head -n 20 查看查询结果里的向前20条记录</p> 
<p>5、按照时间日期查询，（查询出一段时间内的记录）</p> 
<p>sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’ test.log<br> 查看该段时间内的日志</p> 
<p>但是前提是用方法4试一下查询的哪个其实时间是不是存在</p> 
<p>二.日志查找</p> 
<p>1、命令模式下输入“/字符串”，例如“/Section 3”。</p> 
<p>2、如果查找下一个，按“n”即可。</p> 
<p>要自当前光标位置向上搜索，请使用以下命令：</p> 
<p>/pattern Enter</p> 
<p>其中，pattern表示要搜索的特定字符序列。</p> 
<p>要自当前光标位置向下搜索，请使用以下命令：</p> 
<p>?pattern Enter</p> 
<p>三.日志清除</p> 
<p>使用echo命令清空日志文件<br> echo -n “” &gt; /server/tomcat/logs/catalina.out ==&gt;要加上"-n"参数，默认情况下会"\n"，也就是回车符<br> du -h /server/tomcat/logs/catalina.out<br> 使用echo命令清空tomcat日志文件测试实例:<br> [root@zdz ~]# echo -n “” &gt; /server/tomcat/logs/catalina.out<br> [root@zdz ~]# du -h /server/tomcat/logs/catalina.out<br> 0 /server/tomcat/logs/catalina.out</p> 
<h4 id="Calico%E6%8F%92%E4%BB%B6%E4%BD%A0%E4%BB%AC%E4%BA%86%E8%A7%A3%E8%BF%87%E4%B9%88%20%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F" style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">Calico插件你们了解过么 里面有哪些模式</span></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">Cni  ipip模式BGP模式</span></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3684b4ba62a8ad464b5d748b6fc90f0d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TypeScript简介及语言特性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19f983eba429f10d52e2e69f4bb4bc45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringCloud OpenFeign源码详细解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>