<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker Swarm管理 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker Swarm管理" />
<meta property="og:description" content="Docker Swarm管理 本章资源请访问：
https://download.csdn.net/download/weixin_54373617/18740064
技能目标： 了解 Docker Swarm 基本特性
理解 Docker Swarm 基本架构
掌握 Docker Swarm 集群部署
掌握 Docker Swarm 节点管理
掌握 Docker Swarm 服务管理
容器编排部署工具除 Google 推出的 Kubernetes 之外，还有 Docker 发布的 Swarm 与Mesos 推出的 Marathon。本章将从基本概念、工作原理与安装部署及管理等方面介绍Docker 官方推出的 Docker Swarm。
案例一 Docker Swarm 群集部署 Docker 自诞生以来，其容器特性以及镜像特性给 Dev(b编程)Ops(运维) 爱好者带来诸多方便。然而在很长一段时间内，Docker 只能在单机上运行，其跨主机部署、运行与管理能力颇受外界诟病。跨主机能力薄弱，导致 Docker 容器与主机的形成高度耦合，降低了 Docker 容器的灵活性，难以实现容器的迁移、分组等功能。
案例概述 案例前置知识点 Docker Swarm 概述 Docker Swarm 是 Docker 社区提供的基于 Docker 的集群管理调度工具，能够将多台主机构建成一个 Docker 集群，用户通过 API 来管理多个主机上的 Docker，并结合 Overlay 网络实现容器的调度与相互访问。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/b6711f6d89feb9431effe8860be87897/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-28T21:14:42+08:00" />
<meta property="article:modified_time" content="2021-04-28T21:14:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker Swarm管理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Docker_Swarm_0"></a>Docker Swarm管理</h2> 
<p><strong>本章资源请访问：</strong><br> https://download.csdn.net/download/weixin_54373617/18740064</p> 
<h3><a id="_4"></a>技能目标：</h3> 
<ul><li> <p>了解 Docker Swarm 基本特性</p> </li><li> <p>理解 Docker Swarm 基本架构</p> </li><li> <p>掌握 Docker Swarm 集群部署</p> </li><li> <p>掌握 Docker Swarm 节点管理</p> </li><li> <p>掌握 Docker Swarm 服务管理</p> </li></ul> 
<p>容器编排部署工具除 Google 推出的 Kubernetes 之外，还有 Docker 发布的 Swarm 与Mesos 推出的 Marathon。本章将从基本概念、工作原理与安装部署及管理等方面介绍Docker 官方推出的 Docker Swarm。</p> 
<hr> 
<h2><a id="_Docker_Swarm__21"></a>案例一 Docker Swarm 群集部署</h2> 
<p>Docker 自诞生以来，其容器特性以及镜像特性给 Dev(b编程)Ops(运维) 爱好者带来诸多方便。然而在很长一段时间内，Docker 只能在单机上运行，其跨主机部署、运行与管理能力颇受外界诟病。跨主机能力薄弱，导致 Docker 容器与主机的形成高度耦合，降低了 Docker 容器的灵活性，难以实现容器的迁移、分组等功能。</p> 
<h3><a id="_24"></a>案例概述</h3> 
<p><img src="https://images2.imgbox.com/f1/09/aIx8EoYe_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="_28"></a>案例前置知识点</h2> 
<h3><a id="Docker_Swarm__30"></a><strong>Docker Swarm 概述</strong></h3> 
<p>Docker Swarm 是 Docker 社区提供的基于 Docker 的集群管理调度工具，能够将多台主机构建成一个 Docker 集群，用户通过 API 来管理多个主机上的 Docker，并结合 Overlay 网络实现容器的调度与相互访问。<br> <img src="https://images2.imgbox.com/94/83/OMBp9r36_o.png" alt="在这里插入图片描述"><br> <strong>Docker Swarm 默认对外提供两种 API。</strong></p> 
<ul><li>标准的 Docker API：包括 Docker Client、Dokku、Compose、DockerUI、Jenkins 等， 它们可以通过 Swarm 工具与 Docker 集群进行通信；</li><li>集群管理 API：用于集群的管理。</li></ul> 
<p><img src="https://images2.imgbox.com/16/36/Wtrpn3rz_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_42"></a><strong>基本特性</strong></h3> 
<p>Docker 集群管理和编排的特性是通过 SwarmKit 进行构建的， 其中 Swarm 模式是Docker 内置支持的一种默认实现。Docker 1.12 以及更新的版本，都支持 Swarm 模式。用户可以基于 Docker 构建 Swarm 集群，然后就可以将应用服务（Application Service）部署到 Swarm 集群中。</p> 
<p><img src="https://images2.imgbox.com/25/56/H1kob0Xc_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>集群管理集成进 Docker Engin(引擎)</strong>：使用内置的集群管理功能，可以直接通过 Docker CLI(命令行) 命令来创建 Swarm 集群，并部署应用服务，而不需要其它外部软件来创建和管理Swarm 集群。</li><li><strong>去中心化设计</strong>： Swarm 集群中包含管理节点（Manager）和工作节点（Worker）两类， 可以直接基于 Docker Engine 来部署任何类型的节点。在 Swarm 集群运行期间，可以对其作出任何改变，实现对集群的扩容和缩容等，如添加与删除节点。而做这些操作时不需要暂停或重启当前的 Swarm 集群服务。</li><li><strong>声明式服务模型</strong>：在实现的应用栈中，Docker Engine 使用了一种声明的方式，可以定义各种所期望的服务状态。</li><li><strong>缩放</strong>：对于每个服务，可以声明要运行的任务数。向上或向下扩展时，Swarm 集群会通过添加或删除任务来自动调整以维持所需的状态。</li><li><strong>协调预期状态与实际状态的一致性</strong>：管理节点会不断地监控并协调集群的状态，使得Swarm 集群的预期状态和实际状态保持一致。例如启动一个应用服务，指定服务副本为 10，则会启动 10 个 Docker 容器去运行。如果某个工作节点上面运行的 2 个 Docker 容器挂掉了，管理节点会在 Swarm 集群中其它可用的工作节点上创建 2 个服务副本， 使得实际运行的 Docker 容器数保持与预期的 10 个一致。</li><li><strong>多主机网络</strong>：Swarm 集群支持多主机网络，可以为服务指定覆盖网络。管理节点在初始化或更新应用程序时自动为覆盖网络上的容器分配地址。</li><li><strong>服务发现</strong>：管理节点会给 Swarm 集群中每一个服务分配一个唯一的 DNS 名称，对运行中的 Docker 容器进行负载均衡。可以通过 Swarm 内置的 DNS 服务器，查询 Swarm 集群中运行的 Docker 容器状态。</li><li><strong>负载均衡</strong>：在 Swarm 集群中，可以指定如何在各个 Node 之间分发服务容器（Service Container），实现负载均衡。如果想要使用 Swarm 集群外部的负载均衡器，可以将服务容器的端口暴露到外部。</li><li><strong>默认安全</strong>：Swarm 集群中的每个节点都强制执行 TLS 相互身份验证和加密，以保护自身与所有其他节点之间的通信。用户可以选择使用自签名根证书或自定义根 CA 的证书。</li><li><strong>滚动更新</strong>：对于服务需要更新的场景，可以在多个节点上进行增量部署更新，在 Swarm 管理节点使用 Docker CLI 设置一个 delay（延迟）时间间隔，实现多个服务在多个节点上依次进行部署，这样可以非常灵活地控制。如果有一个服务更新失败，则暂停后面 的更新操作，重新回滚到更新之前的版本。</li></ul> 
<h3><a id="_61"></a><strong>关键概念</strong></h3> 
<p>下面是 Docker Swarm 中主要的关键概念。</p> 
<p><strong>节点</strong><br> 每个参与到 Swarm 集群中的 Docker Engine 都称之为一个节点。在单个物理计算机或云服务器上运行一个或多个节点，但是生产环境下的集群部署通常包括分布在多个物理和 云机器上的 Docker 节点。集群中节点主要分为管理节点与工作节点。</p> 
<p>若要将应用程序部署到集群中，则需要将服务定义提交给管理节点。管理节点将被称为 任务的工作单元分派给工作节点。为了维持 Swarm 集群的目标状态，管理节点还将承担编排和集群管理的功能。一旦存在多个管理节点时，会选出一个领导来进行任务编排。</p> 
<p>工作节点用于接收并执行来自管理节点分发的任务。默认情况下，管理节点也是工作节 点，也可以把它配置成只充当管理节点的角色。工作节点将所负责任务的当前状态通知给管 理节点，以便管理节点可以维护每个工作节点的期望状态。</p> 
<p><strong>服务与任务</strong><br> 服务定义了需要在工作节点上执行的任务。它是 Swarm 系统的中心结构，也是用户和 Swarm 交互的主要根源。</p> 
<p>创建服务时，可以指定要使用的容器镜像以及在运行容器中执行的命令。</p> 
<p>在复制服务模型中，Swarm 管理器根据所需状态中设置的比例在节点之间分配特定数量的副本任务。</p> 
<p>任务是 Swarm 集群中最小的调度单位，每个任务都包含一个容器和需要在容器中执行的指令。管理器根据服务中定义的副本数量将任务分配给工作节点。一旦某个任务被分配 到某个节点，就不能再移动到其他节点。它只能在分配的节点上运行或者失败。</p> 
<p><strong>负载均衡</strong><br> 集群管理器使用负载均衡入口来公开对外提供的服务。集群管理器可以自动为<br> PublishedPort（对外发布的端口）分配服务，也可以为服务配置 PublishedPort。部署服务时可以指定任何未使用的端口为服务端口；如果部署服务时未指定端口，Swarm 管理器会为服务自动分配 30000-32767 范围内的端口。</p> 
<p>外部组件（例如云负载均衡器）可以访问集群中任何节点的 PublishedPort 上的服务， 无论该节点当前是否正在运行该服务的任务。集群中的所有节点都将入口连接到正在运行的任务实例。</p> 
<p>Swarm 模式有一个内部 DNS 组件，可以自动为 Swarm 中的每个服务分配一个 DNS条目。集群管理器使用内部负载均衡来根据服务的 DNS 名称在集群内的服务之间分发请求。</p> 
<h3><a id="_90"></a>工作原理</h3> 
<p>在 Swarm 集群中部署镜像创建一个服务时。在一些大的应用上下文环境中需要各种服务配合工作，这样的服务通常称之为微服务。微服务可能是一个 HTTP 服务器、数据库、或者分布式环境中运行的任何其他可执行的程序。</p> 
<p>在创建服务时，可以指定要使用的容器镜像以及容器中要运行的命令。服务还可以定义 下面选项：</p> 
<ul><li> <p>集群要对外服务的端口；</p> </li><li> <p>在集群中用于服务之间相连的 Overlay 网络；</p> </li><li> <p>滚动更新策略；</p> </li><li> <p>集群总运行的副本数量。<br> <img src="https://images2.imgbox.com/1d/27/bBGbxnTz_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<p><strong>下面从以下几个方面具体介绍服务、任务与容器的具体工作方法。</strong></p> 
<p><strong>服务、任务与容器</strong></p> 
<p>当服务部署到集群时，Swarm 管理节点会将服务定义作为服务所需状态。然后将服务调度为一个或多个副本任务。这些任务在集群节点上彼此独立运行。</p> 
<p>容器是一个独立的进程。在 Swarm 集群中，每个任务都会调用一个容器。一旦容器运行，调度程序认为该任务处于运行状态。如果容器健康监测失败或者终止，那么任务也终止。</p> 
<p><strong>任务与调度</strong><br> 任务是集群内调度的原子单位。当创建或者更新服务来声明所需的服务状态时，协调器 通过调度任务来实现所需的状态。</p> 
<p>任务是单向的机制，它通过一系列状态单独进行：分配、准备、运行等操作。如果任务失败，协调器将删除任务与容器，然后根据服务指定的所需状态创建一个新的任务来代替它。</p> 
<p><strong>待处理的服务</strong><br> 配置服务时，若集群中当前没有可用的节点。在这种情况下，也可以成功配置服务，但所配置服务会处于待处理状态（挂起状态）。以下是服务可能处于待处理状态的几个示例。</p> 
<p>如果在集群中所有节点被暂停或耗尽时，创建了一个服务，服务则被挂起，直到节点可 用。实际上，当节点恢复时，第一个可用的节点将会获得所有的任务，这在生产环境中并不是一件好事。</p> 
<ul><li>配置服务时可以为服务预留特定数量的内存。如果集群中没有节点满足所需的内存量， 服务则被挂起，直到有可用的节点运行其任务。如果指定了非常大的内存值（如 500G），任务将永久挂起，除非确实有一个满足该条件的节点。</li><li>配置服务时可以对服务施加约束，并且可能无法在给定时间履行约束，服务则被挂起。</li></ul> 
<p><strong>副本和全局服务</strong></p> 
<p><strong>服务部署分为两种类型：副本服务和全局服务。</strong></p> 
<ul><li> <p>副本服务：指定要运行的相同任务的数量，每个副本都是相同的内容。</p> </li><li> <p>全局服务：是在每个节点上运行一个任务的服务。不需要预先指定任务数量。每当将一个节点添加到集群中，调度器将创建一个任务，并且调度器将任务分配给新加入的节点。 全局服务最好是监控代理、反病毒扫描程序等等想要在集群中每个节点上运行的容器。</p> </li></ul> 
<hr> 
<h2><a id="Docker_Swarm__135"></a>案例一：Docker Swarm 群集部署</h2> 
<h3><a id="_137"></a>案例环境</h3> 
<p><img src="https://images2.imgbox.com/cb/49/nA3tRGtd_o.png" alt="在这里插入图片描述"><br> <strong>案例实验环境的网络拓扑如下图</strong></p> 
<p><img src="https://images2.imgbox.com/d5/a0/lRI60bOo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_143"></a>案例需求</h3> 
<p><strong>本案例的需求如下：</strong></p> 
<p>部署 Docker Swarm 集群，要求集群中包含一个管理节点(manager)和两个工作节点(worker01、worker02)。<br> <img src="https://images2.imgbox.com/fa/1d/ZBf274gl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_151"></a>案例实现思路</h3> 
<p><strong>本案例的实现思路如下：</strong></p> 
<p>（1） 准备 Docker Swarm 部署环境；</p> 
<p>（2） 部署 Docker Swarm 集群。</p> 
<h2><a id="_160"></a>案例一实施</h2> 
<p><strong>在部署 Docker Swarm 之前需要先对服务器进行基础的环境配置。</strong></p> 
<h3><a id="_164"></a>主机配置</h3> 
<p><strong>设置主机名</strong><br> <strong>在三台主机上分别设置相对应的主机名。</strong></p> 
<ul><li> <p><strong>manager节点操作</strong><br> [root@localhost ~]# hostnamectl set-hostname manager<br> [root@localhost ~]# su<br> [root@manager ~]#</p> </li><li> <p>worker1节点操作<br> [root@localhost ~]# hostnamectl set-hostname worker1<br> [root@localhost ~]# su<br> [root@worker1 ~]#</p> </li><li> <p>worker2节点操作<br> [root@localhost ~]# hostnamectl set-hostname worker2<br> [root@localhost ~]# su<br> [root@worker2 ~]#</p> </li></ul> 
<p><strong>所有节点关闭防火墙、Selinux</strong><br> <strong>这里以manager节点为例，其他节点操作相同</strong></p> 
<ul><li>manager节点操作<br> [root@manager ~]# systemctl stop firewalld<br> [root@manager ~]# systemctl disable firewalld<br> [root@manager ~]# vim /etc/selinux/config<br> <img src="https://images2.imgbox.com/bd/47/VIYy9BIh_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>所有主机修改 hosts 文件</strong><br> <strong>以manager为例，其他节点也是相同配置这里就不作演示了</strong></p> 
<ul><li>manager节点操作<br> [root@manager ~]# vim /etc/hosts<br> <img src="https://images2.imgbox.com/f1/ac/spE56kaY_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>添加外网 DNS 服务器</strong><br> 在所有主机上添加外网 DNS 服务器，也可以根据本地的网络环境添加相对应的 DNS服务器。如果没有DNS服务器，就不用添加了。</p> 
<p><strong>下面以 manager 主机为例进行操作。</strong><br> DNS服务器名字 服务器IP<br> [root@manager ~]# echo ”nameserver 223.6.6.6”&gt;&gt; /etc/resolv.conf<br> 修改网卡中配置文件中的DNS地址</p> 
<p>我这里没有DNS服务器，就不添加了</p> 
<p><strong>所有节点安装 Docker</strong><br> <strong>以manager节点为例，其他节点操作相同</strong></p> 
<ul><li>manager节点操作<br> [root@manager ~]# curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br> [root@manager ~]# systemctl start docker<br> [root@manager ~]# systemctl enable docker</li></ul> 
<hr> 
<h2><a id="_Docker_Swarm__219"></a>部署 Docker Swarm 集群</h2> 
<p><strong>安装完 Docker 后，可以使用 docker swarm 命令创建 Docker Swarm 集群。</strong></p> 
<h3><a id="_Docker_Swarm__222"></a><strong>创建 Docker Swarm 集群</strong></h3> 
<p>创建 Docker Swarm 集群命令格式为：</p> 
<p><strong>docker swarm init --advertise-addr (manager节点IP)</strong></p> 
<p>其中：–advertise-addr 选项用于指定 Swarm 集群中管理节点（manager 节点）的 IP 地址，后续工作节点（worker 节点）加入集群时，必须能够访问管理节点的 IP 地址。在manager 主机上，执行如下命令即可创建一个 Swarm 集群。</p> 
<p>[root@manager ~]# docker swarm init --advertise-addr 192.168.10.106<br> <img src="https://images2.imgbox.com/3a/b1/5QfBW6lM_o.png" alt="在这里插入图片描述"><strong>画红线处出现的命令是为了让你复制到工作节点执行的，记得是所有工作节点都要执行，这样工作节点就加入了Swarm群集中了，如下图</strong></p> 
<ul><li>worker1节点操作<br> <img src="https://images2.imgbox.com/2d/4e/lET2mL4w_o.png" alt="在这里插入图片描述"></li><li>worker2节点操作<br> <img src="https://images2.imgbox.com/8a/42/iFTS3ESn_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>注意：如果未看到让worker节点加入群居的命令时，就是前面图片中画线的地方，也可以通过 docker swarm join-token worker 命令重新获取worker节点加入群集的命令，无论是获取管理节点加入swarm群集还是工作节点加入swarm都是在节点manager节点操作</strong></p> 
<p><strong>在manager节点操作：</strong><br> <img src="https://images2.imgbox.com/45/60/hobPU24B_o.png" alt="在这里插入图片描述"></p> 
<p>管理节点加入集群：执行 docker swarm join-token manager 命令，获取管理节点加入到 Swarm 集群的命令。当配置 Swarm 集群的 HA 时可以使用该命令设置多个管理节点。<br> <img src="https://images2.imgbox.com/07/f8/OClSq3RY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_Swarm__245"></a>查看 Swarm 集群的信息</h3> 
<p><strong>manager节点操作</strong><br> 前面命令执行完成后，使用 docker info 命令在管理节点上查看 Swarm 集群的信息，具体操作如下所示。</p> 
<p>[root@manager ~]# docker info<br> Client:<br> Context: default<br> Debug Mode: false<br> Plugins:<br> app: Docker App (Docker Inc., v0.9.1-beta3)<br> buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)<br> scan: Docker Scan (Docker Inc.)</p> 
<p>Server:<br> Containers: 0<br> Running: 0<br> Paused: 0<br> Stopped: 0<br> Images: 0<br> Server Version: 20.10.6<br> Storage Driver: overlay2<br> Backing Filesystem: xfs<br> Supports d_type: true<br> Native Overlay Diff: true<br> userxattr: false<br> Logging Driver: json-file<br> Cgroup Driver: cgroupfs<br> Cgroup Version: 1<br> Plugins:<br> Volume: local<br> Network: bridge host ipvlan macvlan null overlay<br> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog<br> Swarm: active<br> NodeID: x8pjvcgrqrbae3aeu036p43b8<br> Is Manager: true<br> ClusterID: xkam2su60438t54kciovzxd2m<br> Managers: 1<br> Nodes: 3<br> Default Address Pool: 10.0.0.0/8<br> SubnetSize: 24<br> Data Path Port: 4789<br> Orchestration:<br> Task History Retention Limit: 5<br> Raft:<br> Snapshot Interval: 10000<br> Number of Old Snapshots to Retain: 0<br> Heartbeat Tick: 1<br> Election Tick: 10<br> Dispatcher:<br> Heartbeat Period: 5 seconds<br> CA Configuration:<br> Expiry Duration: 3 months<br> Force Rotate: 0<br> Autolock Managers: false<br> Root Rotation In Progress: false<br> Node Address: 192.168.10.106<br> Manager Addresses:<br> 192.168.10.106:2377<br> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc<br> Default Runtime: runc<br> Init Binary: docker-init<br> containerd version: 05f951a3781f4f2c1911b05e61c160e9c30eaa8e<br> runc version: 12644e614e25b05da6fd08a38ffa0cfe1903fdec<br> init version: de40ad0<br> Security Options:<br> seccomp<br> Profile: default<br> Kernel Version: 3.10.0-1160.el7.x86_64<br> Operating System: CentOS Linux 7 (Core)<br> OSType: linux<br> Architecture: x86_64<br> CPUs: 1<br> Total Memory: 972.3MiB<br> Name: manager<br> ID: QC5E:6NTQ:EMNM:LTLL:MVTB:BGER:ONHZ:2IAX:F2R6:YN7B:NG5M:5CWB<br> Docker Root Dir: /var/lib/docker<br> Debug Mode: false<br> Registry: https://index.docker.io/v1/<br> Labels:<br> Experimental: false<br> Insecure Registries:<br> 127.0.0.0/8<br> Live Restore Enabled: false</p> 
<h3><a id="_Swarm___331"></a>查看 Swarm 集群中 所有节点的详细状态信息</h3> 
<p><strong>manager节点操作</strong><br> 使用 docker node ls 命令可以查看 Swarm 集群中全部节点的详细状态信息。<br> <img src="https://images2.imgbox.com/78/40/F5wa2esj_o.png" alt="在这里插入图片描述">leader：领导者，管理者<br> 上图说明了manager节点是这个群集的管理节点</p> 
<p><strong>上面信息中，AVAILABILITY 表示 Swarm Scheduler 是否可以向集群中的某个节点指派任务，对应有如下三种状态：</strong></p> 
<ul><li> <p><strong>Active：集群中该节点可以被指派任务。</strong></p> </li><li> <p><strong>Pause：集群中该节点不可以被指派新的任务，但是其他已经存在的任务保持运行。</strong></p> </li><li> <p><strong>Drain：集群中该节点不可以被指派新的任务，Swarm Scheduler 停掉已经存在的任务， 并将它们调度到可用的节点上。</strong></p> </li></ul> 
<h3><a id="___346"></a>查看某一个 节点 的详细状态信息</h3> 
<p><strong>只可以在管理节点上执行如下命令。</strong></p> 
<p><strong>命令格式如下：</strong></p> 
<p><strong>docker node inspect 节点名</strong></p> 
<p>[root@manager ~]# docker node inspect manager<br> <img src="https://images2.imgbox.com/63/c0/QQx3v490_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/db/f1/mc2PX6b5_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/d5/c3/Pc5Lqyjd_o.png" alt="在这里插入图片描述">上面的查看方法显示的内容太看着不太方便，我们还可以使用下面的命令查看</p> 
<p>docker node inspect --pretty 节点名</p> 
<p>[root@manager ~]# docker node inspect --pretty manager<br> <img src="https://images2.imgbox.com/0a/d7/jjky8goi_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>查看 worker1 节点详细信息：docker node inspect worker1。</p> </li><li> <p>查看 worker2 节点详细信息：docker node inspect worker2。至此，Docker Swarm 集群部署完成。</p> </li></ul> 
<h2><a id="_Docker_Swarm__370"></a>案例二 Docker Swarm 管理</h2> 
<h3><a id="_372"></a>案例概述</h3> 
<p>在企业中，相对于 Docker Swarm 集群的安装部署，更重要的是 Docker Swarm 集群的管理。公司要求云计算工程师可对 Docker Swarm 进行日常管理。<strong>包括不限于节点管理、服务管理、网络管理、数据卷管理等等</strong>，以便对应公司可能提出的各种管理需求。</p> 
<h3><a id="_375"></a>案例前置知识点</h3> 
<p><strong>Docker Swarm 中的节点</strong><br> 运行 Docker 主机时可以自动初始化一个 Swarm 集群，或者加入一个已存在的 Swarm集群，如此运行的 Docker 主机将成为 Swarm 集群中的节(Node)。</p> 
<p>Swarm 集群中的节点分为管理节点和工作节点。</p> 
<p><img src="https://images2.imgbox.com/d1/c9/inUDhrHV_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>管理节点用于 Swarm 集群的管理，负责执行编排和集群管理工作，保持并维护 Swarm 处于期望的状态。Swarm 集群中如果有多个管理节点，就会自动协商并选举出一个leader 执行编排任务；</p> </li><li> <p>工作节点是任务执行节点，管理节点将服务(Service)下发至工作节点执行。管理节点默 认也作为工作节点。</p> </li></ul> 
<p>管理节点与工作节点通过提权和降权命令相互转换角色，大部分 Docker Swarm 命令只能在管理节点执行，但工作节点退出集群的命令则是在工作节点上执行。</p> 
<p><strong>服务和任务</strong><br> <img src="https://images2.imgbox.com/3a/b1/wT2Tzqz9_o.png" alt="在这里插入图片描述"><br> <strong>任务</strong>（<strong>Task</strong>）是 Swarm 集群中最小的调度单位，对应一个单一的容器。</p> 
<p><strong>服务</strong>（<strong>Service</strong>）是指一组任务的集合，服务定义了任务的属性。服务包含两种工作模式：</p> 
<ul><li> <p><strong>副本服务(replicated services)</strong>：按照一定规则在各个工作节点上运行指定个数的任务；</p> </li><li> <p><strong>全局服务(global services)</strong>：每个工作节点上运行一个任务。<br> <img src="https://images2.imgbox.com/5b/d1/t36NIwmq_o.png" alt="在这里插入图片描述">服务的两种模式可以在执行 docker service create 命令创建服务时，通过-mode 参数指定。</p> </li></ul> 
<p>在 Swarm 集群上部署服务，必须在管理节点上进行操作。下图是 Service（服务）、Task（任务）、Container（容器）三者之间的关系。</p> 
<p><img src="https://images2.imgbox.com/43/62/Rh2FCAo0_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/64/c8/PVxR9vHP_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/66/05/I8zk4H3J_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_403"></a>案例需求</h3> 
<p><strong>本案例的需求如下：</strong></p> 
<p>实现 Docker Swarm 日常操作管理，包括：节点管理、服务管理、网络管理、数据卷管理。</p> 
<p>案例实现思路</p> 
<p>本案例的实现思路如下：</p> 
<p>（1） 日常管理 Docker Swarm 节点；</p> 
<p>（2） 创建实现与管理 Docker Swarm 服务。</p> 
<h2><a id="__419"></a>案例二 实施</h2> 
<h3><a id="Docker_Swarm__421"></a>Docker Swarm 节点管理</h3> 
<p><strong>注意：管理节点的操作都是在manager节点进行</strong><br> <img src="https://images2.imgbox.com/1d/b7/GuWVs5q4_o.png" alt="在这里插入图片描述"></p> 
<p>按照对节点的不同操作，通过命令的方式做详细说明。</p> 
<p><strong>节点状态变更管理</strong><br> <img src="https://images2.imgbox.com/9e/e3/jh3tqSxE_o.png" alt="在这里插入图片描述"><br> Swarm 支持设置一组管理节点，通过支持多管理节点实现 HA(高可用)。这些管理节点之间的状态的一致性是非常重要的。在上面提到过，<strong>节点的 AVAILABILITY 有三种状态：Active、Pause、Drain</strong>。对某个节点进行变更，可以将其 AVAILABILITY 值通过 Docker CLI (命令行) 修改为对应的状态。<br> <strong>下面是常见的变更操作：</strong></p> 
<ul><li> <p>设置管理节点只具有管理功能；</p> </li><li> <p>对服务进行停机维护，可以修改 AVAILABILITY 为 Drain 状态；</p> </li><li> <p>暂停一个节点，使该节点就不再接收新的 Task；</p> </li><li> <p>恢复一个不可用或者暂停的节点。</p> </li></ul> 
<p>例如，将管理节点的 AVAILABILITY 值修改为 Drain 状态，使其只具备管理功能，具体操作如下所示。</p> 
<p>[root@manager ~]# docker node update --availability drain manager<br> <img src="https://images2.imgbox.com/f1/99/mXYakqGP_o.png" alt="在这里插入图片描述">从上图可以看出manager节点状态为drain</p> 
<p>如此，管理节点就不能被指派任务，也就是不能部署实际的 Docker 容器来运行服务， 而只是担任管理者的角色。</p> 
<p><strong>添加删除标签元数据</strong></p> 
<p>在生产环境中，可能每个节点的主机配置情况不同，比如：有的适合运行 CPU 密集型应用、有的适合运行 IO 密集型应用。Swarm 支持给每个节点添加标签元数据，根据节点的标签，选择性地调度某个服务部署到期望的一组节点上。<br> <img src="https://images2.imgbox.com/24/f8/Yy90Bdfq_o.png" alt="在这里插入图片描述"><br> [root@manager ~]# docker node update --label-add name=workerone worker1</p> 
<p>[root@manager ~]# docker node inspect worker1<br> 查看 worker01 主机的标签是否添加成功<br> [root@manager ~]# docker node inspect worker1<br> <img src="https://images2.imgbox.com/d2/d5/BAfLnpVf_o.png" alt="在这里插入图片描述">从上图可以看出已经设置成功</p> 
<p><strong>删除标签标签元数据</strong></p> 
<p>docker node update --label-rm 键 节点名</p> 
<p>[root@manager ~]# docker node update --label-rm name worker1<br> <img src="https://images2.imgbox.com/fc/11/5LSCPvn5_o.png" alt="在这里插入图片描述">经过查看可以看到键值已经没有了</p> 
<p><strong>节点提权/降权</strong></p> 
<p>前面提到，在 Swarm 集群中节点分为管理节点与工作节点两种。在实际的生产环境中根据实际需求可更改节点的角色，常见操作有：</p> 
<ul><li> <p>工作节点变为管理节点：提权操作；</p> </li><li> <p>管理节点变为工作节点：降权操作。</p> </li></ul> 
<p>示例：将 worker1 和 worker2 都升级为管理节点，具体操作如下所示。</p> 
<p>[root@manager ~]# docker node promote worker1 worker2<br> Node worker1 promoted to a manager in the swarm.<br> Node worker2 promoted to a manager in the swarm.</p> 
<p><img src="https://images2.imgbox.com/e5/b0/6my4Ruil_o.png" alt="在这里插入图片描述"><br> 示例：对上面已提权的 worker1 和 worker2 执行降权操作，需要执行如下命令。<br> [root@manager ~]# docker node demote worker1 worker2<br> Manager worker1 demoted in the swarm.<br> Manager worker2 demoted in the swarm.<br> <img src="https://images2.imgbox.com/50/0b/HFSmpw6A_o.png" alt="在这里插入图片描述"></p> 
<p><strong>退出 Swarm 集群</strong><br> 如果管理节点想要退出 Swarm 集群， 在管理节点上执行 docker swarm leave 命令， 具体操作如下所示。<br> [root@manager ~]# docker swarm leave</p> 
<p>若群集中还存在其他的Worker Node 时，Manager想强制退出集群，后面跟上 – force<br> [root@manager ~]# docker swarm leave --force</p> 
<p><strong>注意</strong>：管理节点一旦退出Swarm 集群就不能加入集群了，所以这里就不作演示了<br> 如果是在想让管理节点退出Swarm群集可以先把管理节点改为工作节点</p> 
<p>如果工作节点想要退出 Swarm 集群，在工作节点上执行 docker swarm leave<br> 命令，具体操作如下所示。</p> 
<p>[root@worker1 ~]# docker swarm leave</p> 
<p>即使管理节点已经退出 Swarm 集群，执行上述命令也可以使得工作节点退出集群。之后，根据需要，加入到其它新建的 Swarm 集群中。需要注意的是，管理节点退出集群后无法重新加入之前退出的集群；工作节点退出集群后通过 docker swarm join 命令并指定对应的 token 值重新加入集群。</p> 
<h2><a id="Docker_Swarm__508"></a>Docker Swarm 服务管理</h2> 
<p>在 Swarm 模式下使用 Docker，可以实现部署运行服务、服务扩容缩容、删除服务、滚动更新等功能，下面依次进行说明。</p> 
<h3><a id="_511"></a>创建服务</h3> 
<p><strong>使用 docker service create 命令可以创建 Docker 服务。</strong></p> 
<p>示例：从 Docker 镜像 nginx 创建一个名称为 web 的服务，指定服务副本数为 2。具体操作如下所示。</p> 
<p>docker service create --replicas 副本数 --name 服务名称 镜像名</p> 
<p>[root@manager ~]# docker service create --replicas 2 --name web nginx</p> 
<p>–replicas 指定副本数<br> –name 指定名字<br> nginx 这个位置是镜像，这里用的是nginx镜像<br> <img src="https://images2.imgbox.com/c0/2a/HgCbys1h_o.png" alt="在这里插入图片描述"></p> 
<p><strong>也可以添加-p选项，让我们可以访问nginx</strong></p> 
<p>[root@manager ~]# docker service create --replicas 2 --name web -p 4001:80 nginx</p> 
<p>-p：指定宿主机端口映射到容器中的80端口<br> 这样我们就可以访问nginx了<br> <img src="https://images2.imgbox.com/39/52/HzEIjigy_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/34/07/n4AyZRWh_o.png" alt="在这里插入图片描述"><br> 然后我们用浏览器访问worker节点IP+映射到容器中的端口来访问就行了，<br> <img src="https://images2.imgbox.com/e4/9e/XcHnfbLb_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/07/82/kDLeTLr5_o.png" alt="在这里插入图片描述"><strong>这里我的两个worker节点IP都可以访问nginx服务，说明两个副本平均分配到了两台节点上，这里如果你访问manager节点是访问不到的，它的状态是drain 是不运行任何服务的，只是充当一个管理者</strong></p> 
<hr> 
<p><strong>查看部署服务日志</strong><br> -f 实时查看<br> web 指定要查看的服务，这里我指定的是刚才创建的web</p> 
<p>[root@manager ~]# docker service logs -f web</p> 
<p><strong>执行如下命令可查看当前已经部署启动的全部应用服务。</strong></p> 
<p>[root@manager ~]# docker service ls<br> <img src="https://images2.imgbox.com/97/87/Yr9IvZA1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>执行如下命令可以查询指定服务的详细信息。</strong></p> 
<p>[root@manager ~]# docker service ps web<br> <img src="https://images2.imgbox.com/a8/26/wrG3RAbt_o.png" alt="在这里插入图片描述">从上图中可以看出，两个副本分别部署在了连个工作节点上，实现咋负载</p> 
<p>上面信息显示，在 worker01 和 worker02 节点上部署了 Web 应用服务，也包含了它们对应的当前状态信息。</p> 
<p>此时，可以通过执行 docker ps 命令，在工作节点上查看当前启动的Docker 容器。</p> 
<p>worker1节点操作<br> <img src="https://images2.imgbox.com/a9/45/v2b6ZavN_o.png" alt="在这里插入图片描述"><br> worker2节点操作<br> <img src="https://images2.imgbox.com/dd/51/YM4GPcoN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_564"></a><strong>显示服务详细信息</strong></h3> 
<p><strong>manager节点操做</strong><br> 常见服务详细信息有以 JSON 格式显示、易于阅读显示两种显示方式。</p> 
<p>（1） 以 JSON 格式显示</p> 
<p>可以通过下面的命令，以 JSON 格式显示方法 Web 服务的详细信息。<br> [root@manager ~]# docker service inspect web</p> 
<p>（2） 易于阅读显示</p> 
<p>可以通过执行下面命令，以易于阅读方式显示 Web 服务的详细信息</p> 
<p>[root@manager ~]# docker service inspect --pretty web<br> <img src="https://images2.imgbox.com/39/36/h4c5wPrF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_581"></a><strong>服务的扩容缩容</strong></h3> 
<p>当使用服务并涉及到高可用时，可能会有服务的扩容和缩容等操作。服务扩容缩容的命 令格式如下所示，通过 Task 总数确定服务是扩容还是缩容，这个数值可随意变化，0 也是可以的。</p> 
<p>docker service scale 服务名/ID=服务Task总数</p> 
<p>示例：将前面已经部署的 2 个副本的 Web 服务，缩容到 0 个副本，具体操作如下所示。</p> 
<p>进行服务缩容操作时只需要设置副本数小于当前应用服务拥有的副本数即可，大于指定缩容副本数的副本 会被删除。</p> 
<p>[root@manager ~]# docker service scale web=0<br> web scaled to 0<br> overall progress: 0 out of 0 tasks<br> verify: Service converged</p> 
<p>通过 docker service ps web 命令查看服务缩容结果，具体操作如下所示，可以看到已经没有服务了。<br> <img src="https://images2.imgbox.com/17/01/pyWXoU19_o.png" alt="在这里插入图片描述">还可以在worker节点上使用docker ps -a 查看</p> 
<p>根据上述命令结果得知，worker01 节点上有两个 Web 应用服务的副本。进行服务扩容操作时只需要设置副本数大于当前应用服务拥有的副本数即可，小于指定扩容副本数的副本会增加。</p> 
<p>[root@manager ~]# docker service scale web=2<br> <img src="https://images2.imgbox.com/17/ab/SsrY9tsa_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ad/88/6lsLAbkC_o.png" alt="在这里插入图片描述"><br> 可以看到服务又有了</p> 
<h3><a id="_610"></a><strong>删除服务</strong></h3> 
<p>删除服务的命令格式如下所示</p> 
<p>docker service rm 服务名称</p> 
<p>示例：删除集群中所有 Web 应用服务。</p> 
<p>[root@manager ~]# docker service rm web</p> 
<p>[root@manager ~]# docker service ps web<br> no such service: web</p> 
<h3><a id="_625"></a><strong>滚动更新</strong></h3> 
<p>在创建服务时通过–update-delay 选项可以设置容器的更新间隔时间，每次成功部署一个服务，延迟 10 秒钟，然后再更新下一个服务。如果某个服务更新失败，Swarm 的调度器就会暂停本次服务的部署更新。具体操作如下所示。</p> 
<p>首先先创建4个redis服务，现在镜像为redis:3.0.6，然后滚动更新，下图因为我之前部署过一次，worker节点中已经有了镜像，所有过程很快就过去了，如果是没创建的情况下它会一个一个更新的，而且还会有间隔时间。</p> 
<p>[root@manager ~]# docker service create --replicas 4 --name redis --update-delay 10s redis:3.0.6<br> <img src="https://images2.imgbox.com/8a/0e/MVywXuHN_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/56/1e/ImNNxrQK_o.png" alt="在这里插入图片描述"><br> 然后滚动更新镜像(一个一个更新)为redis:3.0.7的<br> [root@manager ~]# docker service update --image redis:3.0.7 redis<br> <img src="https://images2.imgbox.com/89/73/W3aCggMP_o.png" alt="在这里插入图片描述">这里可以看出四个副本是一个一个更新的，而不是一起更新</p> 
<p><img src="https://images2.imgbox.com/ab/72/07Bs5rTy_o.png" alt="在这里插入图片描述">可以看到镜像已经更新成redis:3.0.7了。</p> 
<h3><a id="_Overlay__641"></a>添加自定义 Overlay 网络</h3> 
<p>在 Swarm 集群中使用 Overlay 网络可以连接到一个或多个服务。添加 Overlay 网络需要在管理节点上先创建一个 Overlay 网络，具体操作如下所示。</p> 
<p>创建名为 my-network 的 Overlay 网络 my-network<br> [root@manager ~]# docker network create --driver overlay my-network<br> x4wgio3tcxi4libnjty23b33u</p> 
<p>创建之后，在创建服务时，通过–network 选项指定使用的网络为已存在的 Overlay 网络即可，具体操作如下所示。</p> 
<p>[root@manager ~]# docker service create --replicas 2 --network my-network --name myweb nginx<br> xo2tumc2af6g3n1uqokxthu4f<br> overall progress: 2 out of 2 tasks<br> 1/2: running<br> 2/2: running<br> verify: Service converged</p> 
<p>如果 Swarm 集群中其他节点上的 Docker 容器也使用 my-network 网络，那么处于该Overlay 网络中的所有容器之间都可以进行通信。</p> 
<h3><a id="_662"></a>数据卷创建与应用</h3> 
<p>使用 docker volume create 命令可以创建数据卷，具体操作如下所示。</p> 
<p>docker volume create [数据卷名称]</p> 
<p>创建一个叫product-kgc的数据卷<br> [root@manager ~]# docker volume create product-kgc<br> product-kgc</p> 
<p>查看数据卷<br> [root@manager ~]# docker volume ls<br> DRIVER VOLUME NAME<br> local product-kgc</p> 
<p>应用上述创建的数据卷，具体操作如下所示。</p> 
<p>[root@manager ~]# docker service create --mount type=volume,src=product-kgc,dst=/usr/share/nginx/html --replicas 1 --name kgc-web-1 nginx<br> <img src="https://images2.imgbox.com/b7/71/5LP0Q7Yr_o.png" alt="在这里插入图片描述">src：是创建的宿主机的挂载位置<br> dst：这个指的是副本容器中挂载的位置</p> 
<p><img src="https://images2.imgbox.com/45/0b/xU2mYnn3_o.png" alt="在这里插入图片描述"><br> <strong>查看数据卷的详细信息</strong><br> [root@manager ~]# docker volume inspect product-kgc<br> <img src="https://images2.imgbox.com/fd/ae/MpbMHaA7_o.png" alt="在这里插入图片描述">画红线处是创键的product-kgc挂在卷的位置</p> 
<p>但是这个挂载位置是在哪个节点上呢？manager节点不会有，它的状态为Drain</p> 
<p>我们去worker1上去查看一下<br> <img src="https://images2.imgbox.com/6b/44/4A4fRIy3_o.png" alt="在这里插入图片描述">这里可以看到副本容器中的nginx的网页文件已经同步过来了，而且我也创建了连个文件</p> 
<p>我们进入副本容器看一下<br> 从上面的图中可以看到服务部署在了worker1节点上面<br> <strong>在worker1操作</strong></p> 
<p>列出所有在运行的容器信息<br> <img src="https://images2.imgbox.com/73/4c/wGSJ4d4m_o.png" alt="在这里插入图片描述"><br> [root@worker1 _data]# docker exec -it feec5ee8865e /bin/bash<br> root@feec5ee8865e:/#</p> 
<p>查看到副本容器中是有我在宿主机创建的文件的<br> root@feec5ee8865e:/# cd /usr/share/nginx/html<br> root@feec5ee8865e:/usr/share/nginx/html# ls<br> 1.txt 2.txt 50x.html index.html</p> 
<p>从上面的验证结果得出，在本地数据卷目录下创建几个文件，进入到容器后，找到对应 的目录，数据依然存在。</p> 
<p>数据卷的挂载类型除 volume 之外，还经常使用 bind 类型。具体操作如下所示。<br> [root@manager ~]# mkdir -p /var/vhost/www/aa<br> [root@worker1 ~]# mkdir -p /var/vhost/www/aa<br> [root@worker2 ~]# mkdir -p /var/vhost/www/aa</p> 
<p>创建 2 个 kgc-web-2 服务。<br> [root@manager ~]# docker service create --replicas 2 --mount type=bind,src=/var/vhost/www/aa,dst=/usr/share/nginx/html/ --name kgc-web-2 nginx</p> 
<p>下面命令用于验证数据是否同步。</p> 
<p>[root@worker1 ~]# touch /var/vhost/www/aa/1<br> [root@worker1 ~]# docker ps -a</p> 
<p>[root@worker1 ~]# docker exec -it d5a28f08fbf9 /bin/bash</p> 
<p>root@d5a28f08fbf9:/# ls /usr/share/nginx/html/<br> 1</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54037bc32359fcbce07110b8d36b6e61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux查询所有目录的txt文件,Linux 在指定目录下的所有文件中查找text文本的方法...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fa70f8b0d29c4c33998a38c112d926e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux下unzip解压到指定目录,linux解压缩unzip命令详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>