<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】内排序算法全解析（附C语言代码） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构与算法】内排序算法全解析（附C语言代码）" />
<meta property="og:description" content="导览 0 预备知识0.1 排序的概念0.2 排序的稳定性0.3 内排序与外排序0.4 排序算法的性能0.5 常见排序算法的性能 1 比较排序1.1 插入排序1.1.1 直接插入排序1.1.2 折半插入排序1.1.3 希尔排序 1.2 交换排序1.2.1 冒泡排序1.2.2 快速排序 1.3 选择排序1.3.1 简单选择排序1.3.2 堆排序 1.4 归并排序1.4.1二路归并排序 2 非比较排序2.1 基数排序2.2 计数排序2.3 桶排序 0 预备知识 0.1 排序的概念 排序：将一个记录的无序序列调整成为一个有序序列，使之按关键字递增或递减有序排列的过程。为了提高数据的查找效率，预先排序可以减少获得查找结果的时间。
关键字：对记录进行排序时的依据。
如：可以按学生姓名首字母对学生记录进行排序，也可以按学号对学生记录进行排序。
0.2 排序的稳定性 稳定的排序：如果待排序的记录中存在多个关键字相同的数据，排序后这些具有相同关键字的数据之间的相对次序保持不变。
不稳定的排序：如果待排序的记录中存在多个关键字相同的数据，排序后这些具有相同关键字的数据之间的相对次序发生变化。
0.3 内排序与外排序 内排序：排序过程中，排序数据在内存中处理，不涉及数据的内、外存交换。适用于数据量小的数据。
外排序：排序过程中，涉及数据的内、外存交换。
内排序是外排序的基础。
0.4 排序算法的性能 排序算法的性能由算法的时间和空间确定。
算法时间复杂度：求出算法所有原操作的执行次数T(n)，与算法的执行时间成正比，即可以用T(n)来表示算法的执行时间。算法的时间复杂度一般作为问题规模n的函数，使用T(n)的数量级表示，即
T ( n ) = O ( f ( n ) ) T(n)=O(f(n)) T(n)=O(f(n))
常数阶O(1)：一般一个没有循环（或有循环，但循环次数与问题规模n无关）的算法中原操作执行次数与问题规模n无关，执行时间看成O(1)。如定义变量、赋值、输入输出语句。
线性阶O(n)：一个只有一重循环的算法中原操作执行次数与问题规模n的增长呈现线性增大的关系，执行时间看成O(n)。
其余常用的还有平方阶O(n2)、立方阶O(n3)、对数阶O(log2n)、指数阶O(2n)等。
不同时间复杂度的大小关系：
O ( 1 ) ＜ O ( l o g 2 n ) ＜ O ( n ) ＜ O ( n l o g 2 n ) ＜ O ( n 2 ) ＜ O ( n 3 ) ＜ O ( 2 n ) ＜ O ( n !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/b8d3e3e1d523907667108c0bf0407cda/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-19T12:58:28+08:00" />
<meta property="article:modified_time" content="2021-08-19T12:58:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】内排序算法全解析（附C语言代码）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>导览</h4> 
 <ul><li><a href="#0__1" rel="nofollow">0 预备知识</a></li><li><ul><li><a href="#01__2" rel="nofollow">0.1 排序的概念</a></li><li><a href="#02__7" rel="nofollow">0.2 排序的稳定性</a></li><li><a href="#03__11" rel="nofollow">0.3 内排序与外排序</a></li><li><a href="#04__17" rel="nofollow">0.4 排序算法的性能</a></li><li><a href="#05__30" rel="nofollow">0.5 常见排序算法的性能</a></li></ul> 
  </li><li><a href="#1__186" rel="nofollow">1 比较排序</a></li><li><ul><li><a href="#11__192" rel="nofollow">1.1 插入排序</a></li><li><ul><li><a href="#111__196" rel="nofollow">1.1.1 直接插入排序</a></li><li><a href="#112__227" rel="nofollow">1.1.2 折半插入排序</a></li><li><a href="#113__266" rel="nofollow">1.1.3 希尔排序</a></li></ul> 
   </li><li><a href="#12__308" rel="nofollow">1.2 交换排序</a></li><li><ul><li><a href="#121__311" rel="nofollow">1.2.1 冒泡排序</a></li><li><a href="#122__371" rel="nofollow">1.2.2 快速排序</a></li></ul> 
   </li><li><a href="#13__456" rel="nofollow">1.3 选择排序</a></li><li><ul><li><a href="#131__458" rel="nofollow">1.3.1 简单选择排序</a></li><li><a href="#132__494" rel="nofollow">1.3.2 堆排序</a></li></ul> 
   </li><li><a href="#14__583" rel="nofollow">1.4 归并排序</a></li><li><ul><li><a href="#141_587" rel="nofollow">1.4.1二路归并排序</a></li></ul> 
  </li></ul> 
  </li><li><a href="#2__662" rel="nofollow">2 非比较排序</a></li><li><ul><li><a href="#21__670" rel="nofollow">2.1 基数排序</a></li><li><a href="#22__744" rel="nofollow">2.2 计数排序</a></li><li><a href="#23__805" rel="nofollow">2.3 桶排序</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="0__1"></a>0 预备知识</h2> 
<h3><a id="01__2"></a>0.1 排序的概念</h3> 
<p><strong>排序</strong>：将一个记录的无序序列调整成为一个有序序列，使之按<strong>关键字</strong>递增或递减有序排列的过程。为了提高数据的查找效率，预先排序可以减少获得查找结果的时间。<br> <strong>关键字</strong>：对记录进行排序时的依据。</p> 
<p>如：可以按<em>学生姓名首字母</em>对学生记录进行排序，也可以按<em>学号</em>对学生记录进行排序。</p> 
<h3><a id="02__7"></a>0.2 排序的稳定性</h3> 
<p><strong>稳定的</strong>排序：如果待排序的记录中存在多个关键字相同的数据，排序后这些具有相同关键字的数据之间的相对次序保持不变。<br> <strong>不稳定的</strong>排序：如果待排序的记录中存在多个关键字相同的数据，排序后这些具有相同关键字的数据之间的相对次序发生变化。</p> 
<h3><a id="03__11"></a>0.3 内排序与外排序</h3> 
<p><strong>内排序</strong>：排序过程中，排序数据在内存中处理，不涉及数据的内、外存交换。适用于数据量小的数据。<br> <strong>外排序</strong>：排序过程中，涉及数据的内、外存交换。</p> 
<p><em>内排序是外排序的基础。</em></p> 
<h3><a id="04__17"></a>0.4 排序算法的性能</h3> 
<p>排序算法的性能由算法的时间和空间确定。<br> <strong>算法时间复杂度</strong>：求出算法所有原操作的执行次数T(n)，与算法的执行时间成正比，即可以用T(n)来表示算法的执行时间。算法的时间复杂度一般作为问题规模n的函数，使用T(n)的数量级表示，即<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         T(n)=O(f(n)) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></span><br> <strong>常数阶</strong>O(1)：一般一个没有循环（或有循环，但循环次数与问题规模n无关）的算法中原操作执行次数与问题规模n无关，执行时间看成O(1)。如定义变量、赋值、输入输出语句。<br> <strong>线性阶</strong>O(n)：一个只有一重循环的算法中原操作执行次数与问题规模n的增长呈现线性增大的关系，执行时间看成O(n)。<br> 其余常用的还有<strong>平方阶</strong>O(n<sup>2</sup>)、<strong>立方阶</strong>O(n<sup>3</sup>)、<strong>对数阶</strong>O(log<sub>2</sub>n)、<strong>指数阶</strong>O(2<sup>n</sup>)等。<br> <font color="#ff0000" size="3">不同时间复杂度的大小关系：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           1 
          
         
           ) 
          
         
           ＜ 
          
         
           O 
          
         
           ( 
          
         
           l 
          
         
           o 
          
          
          
            g 
           
          
            2 
           
          
         
           n 
          
         
           ) 
          
         
           ＜ 
          
         
           O 
          
         
           ( 
          
         
           n 
          
         
           ) 
          
         
           ＜ 
          
         
           O 
          
         
           ( 
          
         
           n 
          
         
           l 
          
         
           o 
          
          
          
            g 
           
          
            2 
           
          
         
           n 
          
         
           ) 
          
         
           ＜ 
          
         
           O 
          
         
           ( 
          
          
          
            n 
           
          
            2 
           
          
         
           ) 
          
         
           ＜ 
          
         
           O 
          
         
           ( 
          
          
          
            n 
           
          
            3 
           
          
         
           ) 
          
         
           ＜ 
          
         
           O 
          
         
           ( 
          
          
          
            2 
           
          
            n 
           
          
         
           ) 
          
         
           ＜ 
          
         
           O 
          
         
           ( 
          
         
           n 
          
         
           ! 
          
         
           ) 
          
         
        
          Ο(1)＜Ο(log_2n)＜Ο(n)＜Ο(nlog_2n)＜Ο(n^2)＜Ο(n^3)＜Ο(2^n)＜Ο(n!) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">＜</span><span class="mord">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">＜</span><span class="mord">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">＜</span><span class="mord">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">＜</span><span class="mord">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">＜</span><span class="mord">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">＜</span><span class="mord">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.714392em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">＜</span><span class="mord">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></span></span><br> </font><br> <strong>算法空间复杂度</strong>：对一个算法在运行过程中临时占用的存储空间大小的量度。一般也作为问题规模n的函数，以数量级的形式给出，即<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         S(n)=O(g(n)) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></span></p> 
<h3><a id="05__30"></a>0.5 常见排序算法的性能</h3> 
<table border="0"><tbody><tr><td rowspan="2" colspan="2"> <strong>分类</strong> </td><td rowspan="2"> <strong>算法</strong> </td><td colspan="3"> <strong>时间复杂度</strong> </td><td rowspan="2"> <strong>空间复杂度</strong> </td><td rowspan="2"> <strong>稳定性</strong> </td><td rowspan="2"> <strong>复杂性</strong> </td></tr><tr><td> <strong>最好</strong> </td><td> <strong>最差</strong> </td><td> <strong>平均</strong> </td></tr><tr><td rowspan="8">比较排序</td><td rowspan="3">插入排序</td><td>直接插入排序</td><td>O(n)</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>折半插入排序</td><td>O(n)</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(n)</td><td>O(n<sup>1.5</sup>)</td><td>O(n<sup>1.3</sup>)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td rowspan="2">交换排序</td><td>冒泡排序</td><td>O(n)</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>快速排序</td><td>O(nlog<sub>2</sub>n)</td><td>O(n<sup>2</sup>)</td><td>O(nlog<sub>2</sub>n)</td><td>O(log<sub>2</sub>n)</td><td>不稳定</td><td>较复杂</td></tr><tr><td rowspan="2">选择排序</td><td>简单选择排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>堆排序</td><td>O(nlog<sub>2</sub>n)</td><td>O(nlog<sub>2</sub>n)</td><td>O(nlog<sub>2</sub>n)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td colspan="2">二路归并排序</td><td>O(nlog<sub>2</sub>n)</td><td>O(nlog<sub>2</sub>n)</td><td>O(nlog<sub>2</sub>n)</td><td>O(n)</td><td>稳定</td><td>较复杂</td></tr><tr><td rowspan="3">非比较排序</td><td colspan="2">基数排序</td><td> <p>O(d*(n+r))</p> <p>d是位数，r是基数，</p> <p>n是序列中记录的数目</p> </td><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(r)</td><td>稳定</td><td>较复杂</td></tr><tr><td colspan="2">计数排序</td><td> <p>O(n+k)</p> <p>k是max-min+1，</p> <p>n是序列中记录的数目</p> </td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td><td>较复杂</td></tr><tr><td colspan="2">桶排序</td><td> <p>O(n)</p> <p>n是序列中记录的数目</p> </td><td>O(n<sup>2</sup>)</td><td> <p>O(n+C)</p> <p>C是常数，等于n+n×log<sub>2</sub>n-n×log<sub>2</sub>k，</p> <p>k是桶的个数</p> </td><td>O(k)</td><td>取决于桶内排序算法</td><td>较复杂</td></tr></tbody></table> 
<h2><a id="1__186"></a>1 比较排序</h2> 
<p>基于比较的排序算法主要有两种基本操作：</p> 
<ul><li>比较：关键字之间的比较。</li><li>移动：数据从一个位置移动到另一个位置。</li></ul> 
<h3><a id="11__192"></a>1.1 插入排序</h3> 
<p>插入排序属于减治法的减一技术，即每一趟排序后将问题规模减少1。<br> 基本思想：依次将待排序序列中的每一个记录插入到一个已排好序的序列中。<br> 就像<font color="#0000ff" size="3"><em>打扑克牌时整理分发下来的扑克</em></font>。</p> 
<h4><a id="111__196"></a>1.1.1 直接插入排序</h4> 
<p>排序过程：<br> （1）将整个待排序的记录序列划分成有序区和无序区，初始时有序区为待排序记录序列中的第一个记录，无序区包括所有剩余待排序的记录；<br> （2）将无序区的第一个记录插入到有序区的合适位置，从而使无序区减少一个记录，有序区增加一个记录。<br> （3）重复执行步骤（2），直到无序区中没有记录为止。</p> 
<p>示例：<br> <img src="https://images2.imgbox.com/6e/ff/qPaZQEQW_o.png" alt="在这里插入图片描述"><br> 图示：<br> <img src="https://images2.imgbox.com/0a/d1/TC5asvVr_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//直接插入排序</span>
<span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>				<span class="token comment">//待排序记录序列存储在r[1]~r[n]中</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>					<span class="token comment">//从第2个记录开始执行插入操作</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//temp暂存待插记录，并作为观察哨兵防止寻找插入位置时数组下标越界</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> temp <span class="token operator">&lt;</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>		<span class="token comment">//寻找插入位置</span>
			r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//下一条记录</span>
		r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 算法由两层循环嵌套而成，外层循环执行n-1次，内层循环执行次数取决于第i个记录前有多少个记录大于第i个记录。<br> <strong>最好情况</strong>下，待排序序列为正序，每趟只需要与有序序列最后一个记录比较一次，移动两次记录，则比较次数为n-1，记录的移动次数为2(n-1)。因此，最好情况下直接插入排序的时间复杂度为<strong>O(n)</strong>。<br> <strong>最坏情况</strong>下，待排序序列为倒序，在第i趟插入时，第i个记录必须与前面i-1个记录以及观察哨兵比较，并且比较一次就要做一次记录的移动，则比较次数为∑<sup>n</sup><sub>i=2</sub> i = (n+2)(n-1)/2，记录的移动次数为∑<sup>n</sup><sub>i=2</sub> ( i+1) = (n+4)(n-1)/2。因此，最坏情况下直接插入排序的时间复杂度为<strong>O(n<sup>2</sup>)</strong>。<br> <strong>平均情况</strong>下，待排序序列中各中可能排序的概率相同，在插入第i个记录时平均需要比较有序区中全部记录的一半。则比较次数为∑<sup>n</sup><sub>i=2</sub> i/2 = (n+2)(n-1)/4，移动次数为∑<sup>n</sup><sub>i=2</sub> (i+1)/2 = (n+4)(n-1)/4。因此，平均情况下直接插入排序的时间复杂性为<strong>O(n<sup>2</sup>)</strong>。</p> 
<h4><a id="112__227"></a>1.1.2 折半插入排序</h4> 
<p>直接插入排序中将无序区的开头记录r[i]插入到有序区r[0…i-1]是采用顺序比较的方法。而由于<strong>有序区的记录是有序的</strong>，因此可以采用<strong>折半查找</strong>的方法在r[0…i-1]中找到插入位置，再通过移动记录进行插入，这样对直接插入排序的优化方法，称为折半插入排序。<br> 折半插入排序在插入时利用了二分法的思想。<br> 排序过程：<br> （1）将整个待排序的记录序列划分成有序区和无序区，初始时有序区为待排序记录序列中的第一个记录，无序区包括所有剩余待排序的记录；<br> （2）将无序区的第一个记录r[i]按折半查找的方法插入到有序区中找到的第一个大于r[i]的记录的位置p之后，p及其后记录后移一位，将r[i]插入位置p。如果有序区中没有记录大于r[i]，则将r[i]放到有序区末尾从而使无序区减少一个记录，有序区增加一个记录。<br> （3）重复执行步骤（2），直到无序区中没有记录为止。</p> 
<p>图示：<br> <img src="https://images2.imgbox.com/cc/19/gjP4r9ZL_o.png" alt="在这里插入图片描述"></p> 
<p>C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//折半插入排序</span>
<span class="token keyword">void</span> <span class="token function">BinInsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>		    <span class="token comment">//待排序记录序列存储在r[1]~r[n]中</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>				<span class="token comment">//从第2个记录开始执行插入操作</span>
	<span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> high <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//temp暂存待插记录r[i]，并作为观察哨兵防止寻找插入位置时数组下标越界</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>					<span class="token comment">//在r[low…high]中查找插入的位置</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>			<span class="token comment">//取中间位置</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> r<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>				<span class="token comment">//插入点在左半区</span>
            <span class="token keyword">else</span>
                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>				<span class="token comment">//插入点在右半区</span>
        <span class="token punctuation">}</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>	<span class="token comment">//寻找插入位置high+1</span>
			r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>					<span class="token comment">//下一个记录</span>
		r<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>					<span class="token comment">//在high+1处插入r[i]</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 折半插入排序的记录移动次数与直接插入排序相同，不同的是比较次数。在r[0…i-1]中查找插入r[i]的位置时，折半查找的平均关键字比较次数约为log<sub>2</sub>(i+1)-1，平均移动记录的次数为i/2+2，因此，<strong>平均时间复杂度</strong>为：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            2 
           
          
         
           n 
          
         
        
          ( 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          ( 
         
        
          i 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
          − 
         
        
          1 
         
        
          + 
         
         
         
           i 
          
         
           2 
          
         
        
          + 
         
        
          2 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
         
         
           n 
          
         
           2 
          
         
        
          ) 
         
        
       
         \sum_{i=2}^n(log_2(i+1)-1+\frac{i}{2}+2) = O(n^2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 2.92907em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 2.02252em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.33652em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p> 
<h4><a id="113__266"></a>1.1.3 希尔排序</h4> 
<p>希尔排序又叫减少增量排序，是相较于折半插入排序来说，对直接插入排序的一种更优化的分组插入排序算法。<br> 希尔排序在插入时利用了分治法的思想。<br> <strong>增量</strong>：序列的分组数，通常用d表示。<br> 排序过程：<br> （1）取一个小于序列长度n的第一个增量d<sub>1</sub>（d<sub>1</sub>=n/2），将序列中的全部记录分为d<sub>1</sub>个组，将所有距离为d<sub>1</sub>的倍数的记录放在同一个组中；（希尔排序中增量的取法是每次/2并向下取整，即第二个增量d<sub>2</sub>=⌊d<sub>1</sub>/2⌋，依此类推…）<br> （2）在各个<strong>组内</strong>进行直接插入排序；<br> （3）重复执行步骤（1）（2），直到所取的增量d<sub>t</sub>=1（d<sub>t</sub>&lt;d<sub>t-1</sub>&lt;…&lt;d<sub>2</sub>&lt;d<sub>1</sub>），即最后只剩一个组，所有记录放在同一组进行直接插入排序为止。<br> <font color="#ff0000" size="3"><em>笔试常考：希尔排序每趟不产生有序区，在最后一趟排序结束前，所有记录不一定归位了，但是在希尔排序每趟完成后数据越来越接近有序。</em></font><br> 示例：<br> <img src="https://images2.imgbox.com/23/45/WVg02hp3_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//希尔排序</span>
<span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>					
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> d <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> d <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span>			<span class="token comment">//对增量d赋初值，每次遍历后将其减半		</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> d<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>			<span class="token comment">//对每个分组内的记录使用直接插入排序</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//暂存待插入记录r[i]的值</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> d<span class="token punctuation">;</span>					<span class="token comment">//j在与i相差长度d的同组位置上</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>	<span class="token comment">//如果同组中i处的记录比j处的小</span>
            <span class="token punctuation">{<!-- --></span>
                r<span class="token punctuation">[</span>j<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//将在r[i]前且比temp值大的记录(在j处)后移d位</span>
                j <span class="token operator">=</span> j<span class="token operator">-</span>d<span class="token punctuation">;</span>					<span class="token comment">//避免数组下标越界</span>
            <span class="token punctuation">}</span>
            r<span class="token punctuation">[</span>j<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>					<span class="token comment">//在j+d处插入r[i]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 希尔排序的性能分析取决于增量序列的取法（不同取法最后一个增量必须等于1），因为它的时间是所取增量序列的函数。如果按照上述算法的取法，即d<sub>1</sub>=n/2，d<sub>i+1</sub>=⌊d<sub>i</sub>/2⌋(i≥1)，每次后一个增量是前一个增量的1/2，则经过t=log<sub>2</sub>(n-1)次后d<sub>t</sub>=1。<br> 希尔排序的时间复杂度难以分析，一般认为其<strong>平均时间复杂度</strong>为<strong>O(n<sup>1.3</sup>)</strong>。<br> 当最后一趟增量d=1时，希尔排序与直接插入排序基本一致，为什么希尔排序的时间性能通常要优于直接插入排序呢？<br> ①直接插入排序在初始序列为正序时所需时间最少。希尔排序就是利用这一特性，将序列不断地分组排序而趋于有序。<br> ②当序列长度n较小时，n和n<sup>2</sup>的差别不大，进而直接插入排序的最好时间复杂度O(n)和最坏时间复杂度O(n<sup>2</sup>)差别不大。希尔排序开始时增量d较大，分组较多，每组中记录的数量就相对少，所以对各组组内排序时较快，而后增量d逐渐减小，分组数逐渐减少，各组记录数逐渐增多，但由于此时序列已经接近有序状态，因此使用直接插入排序也较快。<br> 希尔排序中值使用到了i、j、d和temp这4个辅助变量，均与问题规模n无关，因此希尔排序的<strong>空间复杂度</strong>为<strong>O(1)</strong>。<br> 希尔排序时一中不稳定的排序算法。<br> <strong>不稳定的排序算法</strong>：一般情况下，一个排序算法在排序过程中需要以较大的间隔交换记录或者把记录移动一个较大的距离时，称该排序方法是不稳定的（反之则为稳定的），因为这可能会把原来排在前面的记录移动到具有相同关键字的另一个记录的后面。</p> 
<h3><a id="12__308"></a>1.2 交换排序</h3> 
<p>交换排序的基本思想是两两比较待排序记录的关键字，当这两个记录的次序相反时进行交换，直到没有反序的记录为止。</p> 
<h4><a id="121__311"></a>1.2.1 冒泡排序</h4> 
<p>冒泡排序，又叫起泡排序，其基本思想是对无序区中的相邻记录关键字进行两两比较，反序则交换，直到没有反序的记录为止，这就使得关键字最小的记录如气泡一般逐渐往上漂浮直至水面。<br> 冒泡排序使用到的是蛮力法的思想。<br> <font color="#0000ff"><em>每一趟排序后最后的记录都是最大的记录。</em></font><br> 排序过程：<br> （1）将整个待排序序列的记录序列划分为有序区和无序区，初始时有序区为空，无序区包括所有待排序的记录；<br> （2）对无序区从前向后地依次比较相邻记录，若反序则交换，从而使得值较小的记录向前移动，值较大的记录向后移动。<br> （3）重复执行步骤（2），直到无序区中没有反序的记录。<br> 示例：<br> <img src="https://images2.imgbox.com/59/00/CHQLpmuu_o.png" alt="在这里插入图片描述"><br> 图示：<br> <img src="https://images2.imgbox.com/06/ca/PowTzVHH_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//冒泡排序</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>			<span class="token comment">//第一趟冒泡排序的区间是[0,n-1]</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>		<span class="token comment">//每一趟比较前n-1-i个，即已排序好的最后i个不用比较</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 			<span class="token comment">//相邻两个记录反序时，将r[j]和r[j+1]交换</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>有些情况下，在第i趟时已经排好了序，但仍执行后面几趟的比较。实际上，一旦算法中某一趟比较时不出现任何记录交换，则可以结束算法。因此，冒泡排序有一种针对此的优化算法：就是立一个 flag，当在一趟序列遍历中记录没有发生交换，则证明该序列已经有序。<br> 具体C语言代码实现如下：</p> 
<pre><code class="prism language-c"><span class="token comment">//优化的冒泡排序</span>
<span class="token keyword">void</span> <span class="token function">BubbleSortBetter</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>		 	<span class="token comment">//第一趟冒泡排序的区间是[0,n-1]</span>
    <span class="token punctuation">{<!-- --></span>
        bool exchange <span class="token operator">=</span> false<span class="token punctuation">;</span>				<span class="token comment">//置exchange为假</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>		<span class="token comment">//每一趟比较前n-1-i个，即已排序好的最后i个不用比较</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>				<span class="token comment">//相邻两个记录反序时，将r[j]和r[j+1]交换</span>
            <span class="token punctuation">{<!-- --></span>
                exchange <span class="token operator">=</span> true<span class="token punctuation">;</span>			<span class="token comment">//一旦有交换，置exchange为真</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>exchange<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> 				<span class="token comment">//如果没有发生交换，说明序列已经排序好了，则结束算法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>优化的冒泡排序算法分析：<br> 算法的基本语句是比较操作，其执行次数取决于排序的趟数。<br> <strong>最好情况</strong>下，待排序序列为正序，算法只执行一趟，进行了n-1次比较。因此，最好情况下优化的冒泡排序的时间复杂度为<strong>O(n)</strong>。<br> <strong>最坏情况</strong>下，待排序序列为倒序，每趟排序在无序序列中只有一个最大的记录被交换到最终位置，算法执行n-1趟，第i趟排序执行了n-i次比较，则记录的比较次数为∑<sup>n-1</sup><sub>1</sub>(n-i)=n(n-1)/2。因此，最坏情况下冒牌排序的时间复杂度为<strong>O(n<sup>2</sup>)</strong>。<br> <strong>平均情况</strong>下，需要考虑初始序列中逆序的个数。为了确定相邻的两个记录是否需要交换，必须对这两个记录进行比较，因此，初始序列中逆序的个数，也就是记录比较次数的下界。<br> 设a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>是集合{1,2,…,n}的一个排列，如果i&lt;j且a<sub>i</sub>&gt;a<sub>j</sub>，则序偶(a<sub>i</sub>,a<sub>j</sub>)称为改排列的一个逆序。n个记录共有n!种排列，所有排列中逆序的平均个数，就是算法所需平均比较次数的下界。<br> 对于n个记录的所有初始排列，最好情况下，逆序的个数是0；最坏情况下，逆序的个数是n(n-1)/2；其余所有排列，逆序的个数处于最好和最坏之间。Donald Kunth对逆序的分布规律进行了研究，得出了如下的式子：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          m 
         
        
          e 
         
        
          a 
         
        
          n 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           1 
          
          
          
            n 
           
          
            ! 
           
          
         
         
         
           ∑ 
          
          
          
            k 
           
          
            = 
           
          
            20 
           
          
          
          
            n 
           
          
            ( 
           
          
            n 
           
          
            − 
           
          
            1 
           
          
            ) 
           
          
            / 
           
          
            2 
           
          
         
        
          S 
         
        
          ( 
         
        
          k 
         
        
          ) 
         
        
          × 
         
        
          k 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            k 
           
          
            = 
           
          
            1 
           
          
         
           n 
          
         
         
          
          
            k 
           
          
            − 
           
          
            1 
           
          
         
           2 
          
         
        
          = 
         
         
         
           1 
          
         
           4 
          
         
        
          n 
         
        
          ( 
         
        
          n 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
       
         mean(n)=\frac{1}{n!}\sum_{k=20}^{n(n-1)/2}S(k)×k=\sum_{k=1}^n\frac{k-1}{2}=\frac{1}{4}n(n-1) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.26312em; vertical-align: -1.30211em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.96101em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.386em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.30211em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.95351em; vertical-align: -1.30211em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.30211em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.37144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.00744em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">4</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> 因此，平均情况下冒泡排序的时间复杂性为<strong>O(n<sup>2</sup>)</strong>。<br> 在冒泡排序算法中只使用了i、j和temp这3个辅助变量，与问题规模无关。因此，辅助<strong>空间复杂度为O(1)</strong>。</p> 
<h4><a id="122__371"></a>1.2.2 快速排序</h4> 
<p>快速排序是由冒泡排序改进而成的，其基本思想是在待排序的n个元素中任取一条记录（通常为第一条记录）作为基准，将该记录放入适当位置后，数据序列被该记录划分成了两部分。所有关键字比该记录关键字小的记录放置在前一部分，所有关键字比该记录关键字大的记录放置在后一部分，并把该记录排在这两部分的中间（称为该记录归位），这个过程称为一趟快速排序，也即一趟划分。后续对产生的两个部分分别重复上述过程，直至每部分内只有一个记录或空为止。<br> 快速排序用到了分治法的思想。<br> <font color="#ff0000"><em>快速排序由于排序效率在同为O(nlog<sub>2</sub>n)的几种排序方法中效率较高，且其思想分治思想也很实用，因此非常常考！</em></font><br> 排序过程：<br> （1）划分：选定一个记录作为轴值，以轴值为基准将整个序列划分为两个子序列r<sub>1</sub>…r<sub>i-1</sub>和r<sub>i+1</sub>…r<sub>n</sub>，轴值的位置i在划分的过程中确定，并且前一个子序列中的记录均小于或等于轴值，后一个子序列中的记录均大于或等于轴值。<br> （2）求解子问题：分别对划分后每一个子序列递归处理。<br> （3）合并：由于对子序列r<sub>1</sub>…r<sub>i-1</sub>和r<sub>i+1</sub>…r<sub>n</sub>的排序是就地进行的，所以合并不需要执行任何操作。<br> 示例：<br> <img src="https://images2.imgbox.com/00/00/EbKoTUqK_o.png" alt="在这里插入图片描述"></p> 
<p>图示：<br> <img src="https://images2.imgbox.com/66/8b/j8hGHRJN_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//一趟划分</span>
<span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> first<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> first<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//以r[i]为基准</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>					<span class="token comment">//从两端交替向中间扫描，直至i=j为止</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//从右向左扫描，找到一个小于temp的r[j]</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//将r[j]放入r[i]</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&gt;=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//从左向右扫描，找到一个大于temp的r[i]</span>
        	i<span class="token operator">++</span><span class="token punctuation">;</span>	
        r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//将r[i]放入r[j]</span>
    <span class="token punctuation">}</span>
    r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//对r[first..end]中的记录进行快速排序</span>
<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> first<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>						<span class="token comment">//区间内至少存在两个记录的情况</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>first<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//划分成两个区间</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>first<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//对左区间递归快速排序</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//对右区间递归快速排序</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码在写法上分了两个函数来写，下面将两个函数整合成一个：</p> 
<pre><code class="prism language-c"><span class="token comment">//整合的快速排序</span>
<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> first<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">,</span> x <span class="token operator">=</span> r<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//以第一个数为基准</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>							<span class="token comment">//从两端交替向中间扫描，直至i=j为止</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> x<span class="token punctuation">)</span> 			<span class="token comment">//从右向左扫描，找到一个小于基准的r[j]</span>
                j<span class="token operator">--</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
                r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> 			<span class="token comment">//从左向右扫描，找到一个大于等于基准的r[i]</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
                r<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> first<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">//对左区间递归快速排序</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//对右区间递归快速排序</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> <strong>最好情况</strong>下，每次划分对一个记录定位后，该记录的左侧子序列与右侧子序列的长度相同。在具有n个记录的序列中，一次划分需要对整个待划分序列扫描一遍，则所需时间为O(n)。设T(n)是对记录的序列进行排序的时间，每次划分后，正好把待划分区间划分为长度相等的两个子序列，则有：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
          
           
           
             T 
            
           
             ( 
            
           
             n 
            
           
             ) 
            
           
          
         
         
          
           
            
           
             = 
            
           
             2 
            
           
             T 
            
           
             ( 
            
            
            
              n 
             
            
              2 
             
            
           
             ) 
            
           
             + 
            
           
             n 
            
           
             = 
            
           
             2 
            
           
             ( 
            
           
             2 
            
           
             T 
            
           
             ( 
            
            
            
              4 
             
            
              n 
             
            
           
             ) 
            
           
             + 
            
            
            
              n 
             
            
              2 
             
            
           
             ) 
            
           
             + 
            
           
             n 
            
           
             = 
            
           
             4 
            
           
             T 
            
           
             ( 
            
            
            
              n 
             
            
              4 
             
            
           
             ) 
            
           
             + 
            
           
             2 
            
           
             n 
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
           
             = 
            
           
             4 
            
           
             ( 
            
           
             2 
            
           
             T 
            
           
             ( 
            
            
            
              n 
             
            
              8 
             
            
           
             ) 
            
           
             + 
            
            
            
              n 
             
            
              4 
             
            
           
             ) 
            
           
             + 
            
           
             2 
            
           
             n 
            
           
             = 
            
           
             8 
            
           
             T 
            
           
             ( 
            
            
            
              n 
             
            
              8 
             
            
           
             ) 
            
           
             + 
            
           
             3 
            
           
             n 
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
           
             = 
            
           
             . 
            
           
             . 
            
           
             . 
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
           
             = 
            
           
             n 
            
           
             T 
            
           
             ( 
            
           
             1 
            
           
             ) 
            
           
             + 
            
           
             n 
            
           
             l 
            
           
             o 
            
            
            
              g 
             
            
              2 
             
            
           
             n 
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
           
             = 
            
           
             O 
            
           
             ( 
            
           
             n 
            
           
             l 
            
           
             o 
            
            
            
              g 
             
            
              2 
             
            
           
             n 
            
           
             ) 
            
           
          
         
        
       
      
        \begin{aligned} T(n)&amp;=2T(\frac{n}{2})+n=2(2T(\frac{4}{n})+\frac{n}{2})+n=4T(\frac{n}{4})+2n\\ &amp;=4(2T(\frac{n}{8})+\frac{n}{4})+2n=8T(\frac{n}{8})+3n\\ &amp;=...\\ &amp;=nT(1)+nlog_2n\\ &amp;=O(nlog_2n) \end{aligned} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 8.901em; vertical-align: -4.2005em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 4.7005em;"><span class="" style="top: -6.7005em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span class="" style="top: -4.60694em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"></span></span><span class="" style="top: -2.78094em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"></span></span><span class="" style="top: -1.28094em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"></span></span><span class="" style="top: 0.21906em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 4.2005em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 4.7005em;"><span class="" style="top: -6.7005em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">4</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span><span class="" style="top: -4.60694em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">4</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">8</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">4</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">8</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">8</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">3</span><span class="mord mathdefault">n</span></span></span><span class="" style="top: -2.78094em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span><span class="" style="top: -1.28094em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span><span class="" style="top: 0.21906em;"><span class="pstrut" style="height: 3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 4.2005em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span><br> 因此，最好情况下快速排序的时间复杂度为<strong>O(nlog<sub>2</sub>n)</strong>。<br> <strong>最坏情况</strong>下，待排序记录序列为正序或为逆序，每次划分只得到一个比上一次划分少一个记录的子序列（另一个子序列为空）。此时，必须经过n-1次递归调用才能把所有记录定位，而且第i趟划分需要经过n-i次比较才能找到第i个记录的位置，则有：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            1 
           
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
        
          ( 
         
        
          n 
         
        
          − 
         
        
          i 
         
        
          ) 
         
        
          = 
         
         
         
           1 
          
         
           2 
          
         
        
          n 
         
        
          ( 
         
        
          n 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
         
         
           n 
          
         
           2 
          
         
        
          ) 
         
        
       
         \sum_{i=1}^{n-1}(n-i)=\frac{1}{2}n(n-1)=O(n^2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 3.07878em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.00744em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span><br> 因此，最坏情况下快速排序的时间复杂度为<strong>O(n<sup>2</sup>)</strong>。<br> <strong>平均情况</strong>下，设轴值记录的关键码第k小(1≤k≤n)，则有：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           1 
          
         
           n 
          
         
         
         
           ∑ 
          
          
          
            k 
           
          
            = 
           
          
            1 
           
          
         
           n 
          
         
        
          ( 
         
        
          T 
         
        
          ( 
         
        
          n 
         
        
          − 
         
        
          k 
         
        
          ) 
         
        
          + 
         
        
          T 
         
        
          ( 
         
        
          k 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          ) 
         
        
          + 
         
        
          n 
         
        
          = 
         
         
         
           2 
          
         
           n 
          
         
         
         
           ∑ 
          
          
          
            k 
           
          
            = 
           
          
            1 
           
          
         
           n 
          
         
        
          T 
         
        
          ( 
         
        
          k 
         
        
          ) 
         
        
          + 
         
        
          n 
         
        
       
         T(n)=\frac{1}{n}\sum_{k=1}^n(T(n-k)+T(k-1))+n=\frac{2}{n}\sum_{k=1}^nT(k)+n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.95351em; vertical-align: -1.30211em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.30211em;"><span class=""></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.95351em; vertical-align: -1.30211em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.30211em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></span><br> 因此，平均情况下快速排序的时间复杂度为<strong>O(nlog<sub>2</sub>n)</strong>。<br> 由于快速排序是递归执行的，需要用一个栈来存放每一层递归调用的必要信息，其最大容量应与递归调用的深度一致。最好情况下要进行⌊log<sub>2</sub>n⌋次递归调用，栈的深度为O(log<sub>2</sub>n)；最坏情况下，因为要进行n-1次递归调用，栈的深度为O(n)；平均情况下，栈的深度为<strong>O(log<sub>2</sub>n)</strong>。</p> 
<h3><a id="13__456"></a>1.3 选择排序</h3> 
<p>选择排序的基本思想是每一趟从待排序的记录中选择出关键字最小的记录，顺序放在已排好序的子序列的最后，直到全部元素排序完毕。</p> 
<h4><a id="131__458"></a>1.3.1 简单选择排序</h4> 
<p>简单选择排序的基本思想是第i趟排序在无序序列r<sub>i</sub>~ r<sub>n</sub>中找到值最小的记录，并和第i个记录交换作为有序序列的第i个记录。<br> 简单选择排序用到了蛮力法的思想。<br> 排序过程：<br> （1）将整个记录序列划分为有序区和无序区，初始时有序区为空，无序区含有待排序的所有记录；<br> （2）在无序区查找值最小的记录，将它与无序区的第一个记录交换，使得有序区扩展一个记录，同时无序区减少一个记录。<br> （3）不断重复步骤（2），直到无序区只剩下一个记录为止。<br> 示例：<br> <img src="https://images2.imgbox.com/a3/90/uIY2jv5b_o.png" alt="在这里插入图片描述"><br> 图示：<br> <img src="https://images2.imgbox.com/5f/08/HsaLyYyG_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//简单选择排序</span>
<span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>		<span class="token comment">//对n个记录进行n-1趟选择排序</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>	<span class="token comment">//在无序区中查找最小的记录</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> r<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span>
                min <span class="token operator">=</span> j<span class="token punctuation">;</span>				<span class="token comment">//min记下当前找到的最小的记录所在位置</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">!=</span> i<span class="token punctuation">)</span>					<span class="token comment">//如果i不是最小的记录，则交换r[i]与r[min]</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
            r<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 简单选择排序的基本语句是内层循环体中的比较语句（r[j] &lt; r[min]），其执行次数为：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            0 
           
          
          
          
            n 
           
          
            − 
           
          
            2 
           
          
         
         
         
           ∑ 
          
          
          
            j 
           
          
            = 
           
          
            i 
           
          
            + 
           
          
            1 
           
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
        
          1 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            0 
           
          
          
          
            n 
           
          
            − 
           
          
            2 
           
          
         
        
          ( 
         
        
          n 
         
        
          − 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          = 
         
         
          
          
            n 
           
          
            ( 
           
          
            n 
           
          
            − 
           
          
            1 
           
          
            ) 
           
          
         
           2 
          
         
        
          = 
         
        
          O 
         
        
          ( 
         
         
         
           n 
          
         
           2 
          
         
        
          ) 
         
        
       
         \sum_{i=0}^{n-2}\sum_{j=i+1}^{n-1}1=\sum_{i=0}^{n-2}(n-i-1)=\frac{n(n-1)}{2}=O(n^2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 3.21489em; vertical-align: -1.41378em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.41378em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.07878em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.113em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span><br> 因此，对于<strong>任何</strong>待排序记录序列，简单选择排序算法的时间性能都是<strong>O(n<sup>2</sup>)</strong>。<br> 由于简单选择排序算法记录交换次数最多为n-1次，因为外层循环每执行一次，交换记录的语句最多只执行一次。因此，从移动记录的角度说，简单选择排序算法优于许多其他排序算法。</p> 
<h4><a id="132__494"></a>1.3.2 堆排序</h4> 
<p><strong>堆</strong>：满足如下性质的二叉树：<br> 小根堆：每个结点的值都小于或等于其左右孩子结点的值。<br> 大根堆：每个结点的值都大于或等于其左右孩子结点的值。<br> 以结点的层序编号作为下标，将堆用数组存储，则堆对应于一组序列：<br> <img src="https://images2.imgbox.com/90/f9/oNkZDZ35_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e8/6f/KY4FY461_o.png" alt="在这里插入图片描述"><br> 堆排序正是利用堆这种数据结构所设计的一种排序算法，其基本思想是首先将待排序的记录序列构造成一个堆，此时，堆顶记录是堆中所有记录的最大值，将它从堆中移走（通常将堆顶记录和堆中最后一个记录交换），然后将剩余记录再调整成堆，这样又找出了次大的记录，依此类推，直到堆中只有一个记录为止。<br> 堆排序的排序过程与简单选择排序类似，只是挑选最大或最小记录时采用的方法不同，这里<strong>采用大根堆</strong>，每次挑选最大记录归位。挑选最大记录采用的是筛选法。<br> <strong>筛选法</strong>：将一个无序序列调整为堆的过程。<br> 堆排序使用了减治法的思想。<br> 排序过程：<br> （1）将记录序列用筛选法调整为大根堆；<br> （2）将堆顶和堆中最后一个记录交换；<br> （3）不断重复步骤（1）（2），直到堆中只有一个记录为止。<br> 筛选法：<br> （1）将根结点与左右子树的根结点进行比较；<br> （2）若不满足大根堆的条件，则将根结点与左右子树根结点较大者进行交换；<br> （3）重复步骤（1）（2），直到所有子树均为大根堆。<br> 示例：<br> <img src="https://images2.imgbox.com/85/c8/kGLi9H0X_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/da/1a/fWXtt7t6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f3/74/OdlKG6WM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/89/ab/BL2rbK0Z_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4a/9e/ELJPLuSy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a9/73/7HqCSsSr_o.png" alt="在这里插入图片描述"><br> 图示：<br> <img src="https://images2.imgbox.com/7f/b7/3dZTFRVB_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">/** 筛选法
  * k：当前要筛选的结点编号，k的左右子树均是堆
  * n：堆中最后一个记录的编号
  */</span>
<span class="token keyword">void</span> <span class="token function">SiftHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span>							<span class="token comment">//置i为要筛选的结点</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>						<span class="token comment">//置j为i的左孩子</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>						<span class="token comment">//当筛选还没有进行到叶子</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>	<span class="token comment">//比较i的左右孩子，j为较大者</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>					<span class="token comment">//根结点已经大于左右孩子中的较大者</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>							<span class="token comment">//根节点小于左右孩子中的较大者，交换r[i]和r[j]</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            i <span class="token operator">=</span> j<span class="token punctuation">;</span>						<span class="token comment">//被筛结点i位于原来结点j的位置</span>
            j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//堆排序</span>
<span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>		
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>			<span class="token comment">//初始建堆，最后一个分支的下标是(n-1)/2 </span>
    	<span class="token function">SiftHeap</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>		<span class="token comment">//不断移走堆顶，并用筛选法调整堆</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//将堆顶与堆中最后一个记录交换</span>
        r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        r<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token function">SiftHeap</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//只需调整根结点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 筛选算法将根结点与左右子树的根结点进行比较，若不满足堆的条件，则将根结点与左右子树根结点中较大者交换。所以，每比较一次，需要调整的完全二叉树的问题规模就减少一半。因此，筛选法的时间性能为O(log<sub>2</sub>n)。<br> 堆排序的时间主要由建立初始堆和反复重建堆这两部分时间组成，它们都是通过调用筛选算法实现的。<br> 对于高度为k的完全二叉树，调用筛选算法时，其中while循环最多执行k-1次，所以最多进行2(k-1)次关键字比较，最多进行k+1次记录的移动，因此主要以关键字的比较来分析堆排序的时间性能。<br> n个结点的完全二叉树的高度h=⌊log<sub>2</sub>n⌋+1。在建立初始堆时，需要筛选调整的层为h-1 ~ 1层，以第i层中某个结点为根的子树的高度为h-i-1，并且第i层中最多有2<sup>i-1</sup>个结点。设建立初始堆所需要的关键字比较次数最多为T<sub>1</sub>(n)，则有：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           T 
          
         
           1 
          
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            h 
           
          
            − 
           
          
            1 
           
          
         
           1 
          
         
         
         
           2 
          
          
          
            i 
           
          
            − 
           
          
            1 
           
          
         
        
          × 
         
        
          2 
         
        
          ( 
         
        
          h 
         
        
          − 
         
        
          i 
         
        
          + 
         
        
          1 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            h 
           
          
            − 
           
          
            1 
           
          
         
           1 
          
         
         
         
           2 
          
         
           i 
          
         
        
          × 
         
        
          ( 
         
        
          h 
         
        
          − 
         
        
          i 
         
        
          ) 
         
        
       
         T_1(n)=\sum_{i=h-1}^{1}2^{i-1}×2(h-i+1-1)=\sum_{i=h-1}^{1}2^i×(h-i) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.16156em; vertical-align: -1.36044em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.36044em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.874664em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.16156em; vertical-align: -1.36044em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.36044em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.874664em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></span><br> 令j=h-i，当i=h-1时，j=1；当i=1时，j=h-1，所以：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
          
           
            
            
              T 
             
            
              1 
             
            
           
             ( 
            
           
             n 
            
           
             ) 
            
           
          
         
         
          
           
            
           
             = 
            
            
            
              ∑ 
             
             
             
               i 
              
             
               = 
              
             
               h 
              
             
               − 
              
             
               1 
              
             
            
              1 
             
            
            
            
              2 
             
            
              i 
             
            
           
             × 
            
           
             ( 
            
           
             h 
            
           
             − 
            
           
             i 
            
           
             ) 
            
           
             = 
            
            
            
              ∑ 
             
             
             
               j 
              
             
               = 
              
             
               1 
              
             
             
             
               h 
              
             
               − 
              
             
               1 
              
             
            
            
            
              2 
             
             
             
               h 
              
             
               − 
              
             
               j 
              
             
            
           
             × 
            
           
             j 
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
           
             = 
            
            
            
              2 
             
             
             
               h 
              
             
               − 
              
             
               1 
              
             
            
           
             × 
            
           
             1 
            
           
             + 
            
            
            
              2 
             
             
             
               h 
              
             
               − 
              
             
               2 
              
             
            
           
             × 
            
           
             2 
            
           
             + 
            
           
             . 
            
           
             . 
            
           
             . 
            
           
             + 
            
            
            
              2 
             
            
              1 
             
            
           
             × 
            
           
             ( 
            
           
             h 
            
           
             − 
            
           
             1 
            
           
             ) 
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
           
             = 
            
            
            
              2 
             
             
             
               h 
              
             
               − 
              
             
               1 
              
             
            
           
             − 
            
            
            
              2 
             
            
              h 
             
            
           
             − 
            
           
             2 
            
           
             &lt; 
            
            
            
              2 
             
             
             
               ⌊ 
              
             
               l 
              
             
               o 
              
              
              
                g 
               
              
                2 
               
              
             
               n 
              
             
               ⌋ 
              
             
               + 
              
             
               2 
              
             
            
           
             &lt; 
            
           
             4 
            
           
             × 
            
            
            
              2 
             
             
             
               l 
              
             
               o 
              
              
              
                g 
               
              
                2 
               
              
             
               n 
              
             
            
           
             = 
            
           
             4 
            
           
             n 
            
           
          
         
        
       
      
        \begin{aligned} T_1(n)&amp;=\sum_{i=h-1}^{1}2^i×(h-i)=\sum_{j=1}^{h-1}2^{h-j}×j\\ &amp;=2^{h-1}×1+2^{h-2}×2+...+2^1×(h-1)\\ &amp;=2^{h-1}-2^h-2&lt;2^{⌊log_2n⌋+2}&lt;4×2^{log_2n}=4n \end{aligned} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 6.707em; vertical-align: -3.1035em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 3.6035em;"><span class="" style="top: -5.6035em;"><span class="pstrut" style="height: 3.83611em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span class="" style="top: -2.99061em;"><span class="pstrut" style="height: 3.83611em;"></span><span class="mord"></span></span><span class="" style="top: -1.39261em;"><span class="pstrut" style="height: 3.83611em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 3.1035em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 3.6035em;"><span class="" style="top: -5.6035em;"><span class="pstrut" style="height: 3.83611em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.80111em;"><span class="" style="top: -1.84789em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.3em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.36044em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.874664em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.83611em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.41378em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.899108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span></span></span><span class="" style="top: -2.99061em;"><span class="pstrut" style="height: 3.83611em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.899108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.899108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span class="" style="top: -1.39261em;"><span class="pstrut" style="height: 3.83611em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.899108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.899108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.938em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌊</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.317314em;"><span class="" style="top: -2.357em; margin-left: -0.03588em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">⌋</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.899108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.317314em;"><span class="" style="top: -2.357em; margin-left: -0.03588em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">4</span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 3.1035em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span><br> 因此，建立初始堆总共进行的关键字比较次数不超过4n。类似地，设重建堆中对筛选算法的n-1次调用所需的比较总次数为T<sub>2</sub>(n)。其中i从n到2，每次对r[1…i-1]的i-1个结点的完全二叉树进行筛选调整，该树的高度为⌊log<sub>2</sub>(i-1)⌋+1，所以有：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           T 
          
         
           2 
          
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            2 
           
          
         
           n 
          
         
        
          2 
         
        
          × 
         
        
          ( 
         
        
          ⌊ 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          ( 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          ⌋ 
         
        
          + 
         
        
          1 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          = 
         
        
          2 
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            2 
           
          
         
           n 
          
         
        
          ⌊ 
         
        
          l 
         
        
          o 
         
        
          g 
         
        
            
         
        
          2 
         
        
            
         
        
          ( 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ) 
         
        
          ⌋ 
         
        
          &lt; 
         
        
          2 
         
        
          n 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
       
         T_2(n)=\sum_{i=2}^{n}2×(⌊log_2(i-1)⌋+1-1)=2\sum_{i=2}^{n}⌊log~2~(i-1)⌋&lt;2nlog_2n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.92907em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.92907em; vertical-align: -1.27767em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mspace nobreak"> </span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></span></span><br> 所以，堆排序所需关键字的比较总次数为T(n)=T<sub>1</sub>(n)+T<sub>2</sub>(n)=4n+2nlog<sub>2</sub>n=O(nlog<sub>2</sub>n)。<br> 综上，堆排序的<strong>最坏</strong>时间复杂度为<strong>O(nlog<sub>2</sub>n)</strong>。<br> 堆排序的平均时间性能分析较复杂，实验研究表明，它较接近最坏性能。实际上，堆排序和简单选择排序算法一样，其时间性能与初始序列的顺序无关，所以堆排序的<strong>最好、最坏和平均时间复杂度</strong>都是<strong>O(nlog<sub>2</sub>n)</strong>。<br> 由于堆排序建初始堆所需的比较次数较多，所以堆排序不适合记录数较少的序列排序。<br> 堆排序只是用了i、j、temp等辅助变量，其<strong>空间复杂度</strong>为<strong>O(1)</strong>。<br> 堆排序在进行筛选时可能把后面相同关键字的记录调整到前面，所以堆排序是<strong>不稳定的排序算法</strong>。</p> 
<h3><a id="14__583"></a>1.4 归并排序</h3> 
<p>归并排序是多次将两个或两个以上的有序序列合并成一个新的有序序列。最简单的归并是直接将两个有序的子序列合并成一个有序的表，即二路归并。<br> 归并排序使用了分治法的思想。<br> 归并排序按照记录在序列中的位置对序列进行划分，而快速排序按照记录的值对序列进行划分。相较而言，快速排序更加巧妙。</p> 
<h4><a id="141_587"></a>1.4.1二路归并排序</h4> 
<p>二路归并排序的基本思路是将r[0…n-1]看成是n个长度为1的有序序列，然后进行两两归并，得到⌈n/2⌉个长度为2（最后一个有序序列的长度可能为2）的有序序列，再进行两两归并，得到⌈n/4⌉个长度为4（最后一个有序序列的长度可能小于4）的有序序列，依次类推，直到得到一个长度为n的有序序列。<br> <font color="#ff0000" size="3"><em>笔试常考：归并排序每趟产生的有序区只是局部有序的，在最后一趟排序结束前，所有记录不一定归位了。</em></font><br> 排序过程：<br> （1）划分：将待排序序列r<sub>1</sub>,r<sub>2</sub>,…,r<sub>n</sub>划分为两个长度相等的子序列r<sub>1</sub>,…,r<sub>n/2</sub>和r<sub>n/2+1</sub>,…,r<sub>n</sub>；<br> （2）求解子问题：分别对这两个子序列进行排序，得到两个有序子序列；<br> （3）合并：将这两个有序序列合并成一个有序序列。<br> 示例：<br> <img src="https://images2.imgbox.com/c6/1c/VT4uWSRy_o.png" alt="在这里插入图片描述"></p> 
<p>图示：<br> <img src="https://images2.imgbox.com/45/42/tk57s6nd_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//合并算法：合并r[low..high]</span>
<span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> low<span class="token punctuation">;</span>	<span class="token comment">//i、j是r中第一个子序列和第二个子序列的下标；k是r1的下标</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;</span> j <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>			<span class="token comment">//当前半个子序列和后半个子序列都没有处理完时循环</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>				<span class="token comment">//取r[i]和r[j]中较小者放入r1[k]</span>
            r1<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> 
            r1<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>						<span class="token comment">//当前半子序列没处理完</span>
        r1<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//将前半个子序列余下的部分放入r1</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>					<span class="token comment">//当后半个子序列没处理完</span>
        r1<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//将后半个子序列余下的部分放入r1</span>
<span class="token punctuation">}</span>

<span class="token comment">//对r[low]~r[high]进行归并排序</span>
<span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> r1<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>						<span class="token comment">//临时数组r1,假设最多1000个记录</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span>						<span class="token comment">//递归的边界条件，只有一个记录，已经有序</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>			<span class="token comment">//划分为两个子序列</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//求解子问题1：归并排序前半个子序列</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//求解子问题2：归并排序后半个子序列</span>
        <span class="token function">Merge</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>r1<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//合并两个有序子序列，结果保存在数组r1中</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        	r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">//将有序序列放回数组r中</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此处使用的时<strong>自顶向下的递归实现</strong>的二路归并算法，还可以使用自底向上的迭代重写。<br> 算法分析：<br> 设待排序记录个数为n，则执行一趟合并算法的时间复杂性为O(n)，则归并排序算法存在如下递推式：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           { 
          
          
           
            
             
             
               1 
              
             
            
            
             
              
              
                n 
               
              
                = 
               
              
                1 
               
              
             
            
           
           
            
             
              
              
                2 
               
              
                T 
               
              
                ( 
               
               
               
                 n 
                
               
                 2 
                
               
              
                ) 
               
              
                + 
               
              
                n 
               
              
             
            
            
             
              
              
                n 
               
              
                &gt; 
               
              
                1 
               
              
             
            
           
          
         
        
       
         T(n)=\left\{ \begin{array}{lr} 1&amp;n=1\\ 2T(\frac{n}{2})+n &amp; n&gt;1 \end{array} \right. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.40003em; vertical-align: -0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">1</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 该式子满足通用分治递推式（a,b,c和k都是常数）：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           { 
          
          
           
            
             
             
               c 
              
             
            
            
             
              
              
                n 
               
              
                = 
               
              
                1 
               
              
             
            
           
           
            
             
              
              
                a 
               
              
                T 
               
              
                ( 
               
               
               
                 n 
                
               
                 b 
                
               
              
                ) 
               
              
                + 
               
              
                c 
               
               
               
                 n 
                
               
                 k 
                
               
              
             
            
            
             
              
              
                n 
               
              
                &gt; 
               
              
                1 
               
              
             
            
           
          
         
        
       
         T(n)=\left\{ \begin{array}{lr} c&amp;n=1\\ aT(\frac{n}{b})+cn^k &amp; n&gt;1 \end{array} \right. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.40911em; vertical-align: -0.954554em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45455em;"><span class="" style="top: -3.61455em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span><span class="" style="top: -2.40545em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.954554em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45455em;"><span class="" style="top: -3.61455em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">1</span></span></span><span class="" style="top: -2.40545em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.954554em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 该递归式描述了大小为n的原问题分解为若干大小为n/b的子问题，其中a个子问题需要求解，cn<sup>k</sup>是合并子问题的解需要的工作量。<br> 当T(n)是一个非递减函数，且满足通用分治递推式时，则有以下结论成立：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
         
         
           { 
          
          
           
            
             
              
              
                O 
               
              
                ( 
               
               
               
                 n 
                
                
                
                  l 
                 
                
                  o 
                 
                 
                 
                   g 
                  
                 
                   b 
                  
                 
                
                  a 
                 
                
               
              
                ) 
               
              
             
            
            
             
              
              
                a 
               
              
                &gt; 
               
               
               
                 b 
                
               
                 k 
                
               
              
             
            
           
           
            
             
              
              
                O 
               
              
                ( 
               
               
               
                 n 
                
               
                 k 
                
               
              
                l 
               
              
                o 
               
               
               
                 g 
                
               
                 b 
                
               
              
                n 
               
              
                ) 
               
              
             
            
            
             
              
              
                a 
               
              
                = 
               
               
               
                 b 
                
               
                 k 
                
               
              
             
            
           
           
            
             
              
              
                O 
               
              
                ( 
               
               
               
                 n 
                
               
                 k 
                
               
              
                ) 
               
              
             
            
            
             
              
              
                a 
               
              
                &lt; 
               
               
               
                 b 
                
               
                 k 
                
               
              
             
            
           
          
         
        
       
         T(n)=\left\{ \begin{array}{lr} O(n^{log_ba})&amp;a&gt;b^k\\ O(n^klog_bn)&amp;a=b^k \\ O(n^k)&amp;a&lt;b^k \end{array} \right. 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.62732em; vertical-align: -1.56366em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.05002em;"><span class="" style="top: -2.49999em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎩</span></span></span><span class="" style="top: -3.15001em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎨</span></span></span><span class="" style="top: -4.30002em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.55002em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.06366em;"><span class="" style="top: -4.21455em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.34877em; margin-left: -0.03588em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.151229em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span class="" style="top: -3.00545em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span class="" style="top: -1.79634em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.56366em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.06366em;"><span class="" style="top: -4.21455em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.00545em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span><span class="" style="top: -1.79634em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.56366em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 因此可知归并排序算法中，a=2，b=2，c=1，k=1。所以，a=b<sup>k</sup>，对应结论可知：T(n) = O(nlog<sub>2</sub>n)。因此，归并排序算法的<strong>最好、最坏、平均时间复杂性</strong>为<strong>O(nlog<sub>2</sub>n)</strong>。<br> 归并排序需要与待排序记录序列同样数量的存储空间，以便存放归并结果。因此，归并排序的<strong>空间复杂度</strong>为<strong>O(n)</strong>。</p> 
<h2><a id="2__662"></a>2 非比较排序</h2> 
<p>非比较排序不同于比较排序，不像上述的比较排序算法，是基于关键字间的比较，而是使用其他的方法得到排序结果。<br> 非比较排序包括：基数排序、计数排序和桶排序，均是通过分配和收集来实现排序。<br> 这三者在排序时都使用了桶的概念。不同的是对桶的使用方法。<br> <strong>桶</strong>：一组未排序的记录。<br> <strong>基数排序中</strong>桶的使用：根据关键字的每一位数字来分配桶。<br> <strong>计数排序中</strong>桶的使用：每个桶只存储单一关键字。<br> <strong>桶排序中</strong>桶的使用：每个桶存储一定范围的记录。</p> 
<h3><a id="21__670"></a>2.1 基数排序</h3> 
<p>基数排序是通过<strong>分配</strong>和<strong>收集</strong>过程来实现排序，用到了多关键字排序的思想对单关键字进行排序。<br> <strong>位数d</strong>：记录的关键字由d位数字组成。<br> <strong>基数r</strong>：关键字可表示成k<sup>d-1</sup>k<sup>d-2</sup>…k<sup>1</sup>k<sup>0</sup>，其中k<sup>d-1</sup>为最高位，k<sup>0</sup>是最低位，每一位都在0≤k<sup>i</sup>＜r的范围内，r就称为是基数。如对二进制数来说r为2，对十进制数来说r为10。<br> 基数排序有两种，分别是<strong>最低位优先(LSD)<strong>和</strong>最高位优先(MSD)</strong>，其原理相同，这里主要讨论LSD。<br> 在对一个序列排序时采用最低位优先还是最高位优先排序方法是根据序列的特点决定的。如对整数序列递增排序，由于个位数的重要性低于十位数，十位数的重要性低于百位数，一般越重要的位放在越后面排序。因此，个位数属于最低位，所以对于整数序列的递增排序采用最低位优先排序。<br> <strong>最低位优先的排序过程</strong>：<br> 按最低位的值对记录进行排序，在此基础上再按次低位进行排序，依次类推，每一趟都是根据关键字的一位并在前一趟的基础上对所有记录进行排序，直至最高位。<br> <strong>分配</strong>：从低位开始将待排序的记录按照这一位的值分配至编号0到9的桶中。<br> <strong>收集</strong>：将这些桶中已排序的记录依次首位相接，得到新的记录序列。<br> 在执行d趟后，记录序列就有序了。<br> 示例：<br> <img src="https://images2.imgbox.com/9a/25/NOY9OX55_o.png" alt="在这里插入图片描述"><br> 排序过程：<br> （1）获取待排序序列中的最大值，目的是计算出其的最大指数；<br> （2）从指数1开始，根据位数对待排序序列中的记录进行排序；（排序的时候采用的是桶排序。）<br> （3）重复步骤（2），直至最高位。<br> C语言代码：</p> 
<pre><code class="prism language-c"><span class="token comment">//获取长度为n的数组r中的最大值</span>
<span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> max<span class="token punctuation">;</span>
    max <span class="token operator">=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span>
            max <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/** 对数组按照"某个位数"进行排序(桶排序)
 *	exp：指数。对数组r按照该指数进行排序。
 *    	当exp=1表示按照"个位"对数组r进行排序
 *      当exp=10表示按照"十位"对数组r进行排序
 *      当exp=100表示按照"百位"对数组r进行排序
 *    	...
 */</span>
<span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> output<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">//存储"被排序数据"的临时数组</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> buckets<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//将数据出现的次数存储在buckets[]中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        buckets<span class="token punctuation">[</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>exp<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span> <span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">//更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> buckets<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//将数据存储到临时数组output[]中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        output<span class="token punctuation">[</span>buckets<span class="token punctuation">[</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>exp<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span> <span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        buckets<span class="token punctuation">[</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>exp<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span> <span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//将排序好的数据赋值给r[]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> output<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 基数排序</span>
<span class="token keyword">void</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> exp<span class="token punctuation">;</span>    <span class="token comment">//指数。当对数组按个位数进行排序时，exp=1；按十位进行排序时，exp=10；...</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//数组r中的最大值</span>

    <span class="token comment">//从个位开始，对数组r按"指数"进行排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> max<span class="token operator">/</span>exp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token function">CountSort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 在基数排序过程中共进行了d趟的分配和排序。每一趟分配过程需要扫描序列中的所有n个记录，而收集过程取决于桶的个数r，所以一趟的执行时间为O(n+r)。因此基数排序的<strong>时间复杂度</strong>为<strong>O(d(n+r))</strong>。<br> 在基数排序中第一趟排序需要的辅助存储空间为r（创建了r个桶），但以后的各趟都重复使用这些桶，因此基数排序的<strong>空间复杂度</strong>为<strong>O( r )</strong>。<br> <font color="#0000ff"><em>很多博客上面分析的空间复杂度为O(n+r)，这是由于考虑了额外的空间复杂度，基数排序也是内部排序的一种，在装桶时会有O(n)的空间复杂度。</em></font><br> 基数排序后续的排序基于前面的排序，排在后面的记录只能排在前面相同关键字记录的后面，相对位置不会发生改变，因此，基数排序是一种<strong>稳定的排序算法</strong>。</p> 
<h3><a id="22__744"></a>2.2 计数排序</h3> 
<p>计数排序也是一种不基于比较的排序算法，利用牺牲空间换取时间的思想赢得了比所有比较排序算法更快的速度。<br> 计数排序的基本思想是通过对序列中的每个记录进行相应的计数统计，进而通过计数值确定记录的正确位置的排序算法。<br> 计数排序不适用于序列中最大最小值差距过大及序列中记录非整数的情况。<br> 排序过程：<br> （1）获取待排序序列中的最大值与最小值，目的是计算出其要申请的辅助空间；<br> （2）申请辅助空间count，大小为待排序序列中的最大值-最小值+1，并将其初始化为0；<br> （3）对待排序序列中的记录进行出现频次的统计，统计结果对应存入辅助空间count中；<br> （4）对所有的计数累加（从count中的第一个计数开始，每一项和前一项相加），计算得到每个记录在排序后序列中的结束位置；<br> （5）反向填充目标序列，将每个记录i放在新序列的第count(i)项，每放一个记录就将count(i)减去1。<br> 示例：<br> <img src="https://images2.imgbox.com/a5/37/UR9A6VMr_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//找到待排序序列中的最大值</span>
<span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span>
            max <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//找到待排序序列中的最小值</span>
<span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>
            min <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> min<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//计数排序</span>
<span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//（1）找到序列中的最大值和最小值</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token function">getMin</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token comment">//（2）申请辅助空间，并初始化为0 </span>
    <span class="token keyword">int</span> count<span class="token punctuation">[</span>max<span class="token operator">-</span>min<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> output<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//（3)统计各个记录的出现频次，并存储在相应的位置上</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        count<span class="token punctuation">[</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">//（4）根据 count 中的信息，找到各个记录排序后所在位置，回收元素 </span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> max<span class="token operator">-</span>min<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
    	<span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span>
        	r<span class="token punctuation">[</span>c<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span>min<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 在计数排序中，首先遍历了待排序序列，求得最大最小值，时间复杂度为O(n)；接着再次遍历了待排序序列，统计各个记录的出现频次，时间复杂度为O(n)；最后再遍历辅助空间数组count，其大小为k=max-min+1，时间复杂度为O(k)；因此计数排序总的<strong>时间复杂度</strong>为<strong>O(n+k)</strong>。<br> 由于计数排序过程中需要申请一个辅助空间count，用于存放计数结果。因此计数排序的<strong>空间复杂度</strong>为<strong>O(k)</strong>。<br> 计数排序是一种<strong>稳定的排序算法</strong>，因为具有相同值的记录在输出时的相对次序与它们在输入时的相对次序是相同的。</p> 
<h3><a id="23__805"></a>2.3 桶排序</h3> 
<p>桶排序是基数排序和计数排序的升级版，基数排序和计数排序都是基于桶排序的思想实现的。桶排序的基本思想是将待排序序列通过映射函数分配到有限数量的桶中，再对每个桶分别排序，最后收集各桶中的排序结果得到最终的排序结果。<br> 对于桶中记录的排序，选择哪种比较排序算法对于性能的影响至关重要。<br> 为使桶排序更加高效，做到在额外空间充足的情况下，尽量增大桶的数量；使用的映射函数能够将输入的 n 个记录均匀的分配到 k个桶中。<br> 桶排序使用到了分治的思想。<br> 排序过程：<br> （1）设置一个定量的数组当作空桶。<br> （2）遍历待排序序列，将记录一个一个放到对应的桶中。<br> （3）对每个非空的桶进行排序。<br> （4）从非空的桶中把排好序的记录再放回到原来的序列中。<br> 示例：<br> <img src="https://images2.imgbox.com/4c/71/COIEEEtO_o.png" alt="在这里插入图片描述"><br> C语言代码：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//获找到待排序序列中的最大值</span>
<span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span>
            max <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
 
<span class="token comment">//桶排序</span>
<span class="token keyword">void</span> <span class="token function">BucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//找到待排序序列中的最大值 </span>
	<span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//申请空桶，并初始化为0 </span>
    <span class="token keyword">int</span> bucket<span class="token punctuation">[</span>max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    <span class="token comment">//遍历待排序序列，将记录一个一个放到对应的桶中</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   
        bucket<span class="token punctuation">[</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//对每个非空的桶进行排序</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
            r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  			<span class="token comment">//从非空的桶子里把排好序的记录再放回原来的序列中 </span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法分析：<br> 在桶排序中，首先遍历了待排序序列，求得最大值，时间复杂度为O(n)；接着再次遍历了待排序序列，将各个记录放入对应的桶中，时间复杂度为O(n)；然后对各桶中记录进行排序，一般使用快速排序，时间复杂度为O(nlog<sub>2</sub>n)，为使桶排序更加高效，记录能平均得分配到所有桶中，每个桶中有[n/k]个记录；最后再遍历所有有记录的桶，其个数为k=max+1，时间复杂度为O(k)；因此桶排序的<strong>平均时间复杂度</strong>为<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          + 
         
        
          O 
         
        
          ( 
         
        
          k 
         
        
          × 
         
        
          ( 
         
         
         
           n 
          
         
           k 
          
         
        
          ) 
         
        
          × 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          ( 
         
         
         
           n 
          
         
           k 
          
         
        
          ) 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          n 
         
        
          + 
         
        
          n 
         
        
          × 
         
        
          ( 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
          − 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          k 
         
        
          ) 
         
        
          ) 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          n 
         
        
          + 
         
        
          n 
         
        
          × 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
          − 
         
        
          n 
         
        
          × 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          k 
         
        
          ) 
         
        
       
         O(n)+O(k×(\frac{n}{k})×log_2(\frac{n}{k}))=O(n+n×(log_2n-log_2k))=O(n+n×log_2n-n×log_2k) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.79356em; vertical-align: -0.686em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.79356em; vertical-align: -0.686em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.10756em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></span>即O(n+C)。<br> 当n=k时，即极限情况下，每个桶中只有一个记录，桶排序的<strong>最好时间复杂度</strong>是<strong>O(n)</strong>。<br> 当所有的待排序记录都被分配到了同一个桶中，相当于用任意的排序算法都行。因此，桶排序的<strong>最坏时间复杂度</strong>是<strong>O(n<sup>2</sup>)</strong>。（参考其他排序的最坏时间复杂度）<br> 由于桶排序过程中需要申请k个桶，用于存放待排序序列。因此桶排序的<strong>空间复杂度</strong>为<strong>O(k)</strong>。待排序记录分布越均匀，也就是说当记录能够非常均匀地填满所有的桶时，这个空间的利用率是最好的。<br> 桶排序的<strong>稳定性与桶内记录使用的排序算法是否稳定有关</strong>，如果桶内排序算法是稳定的，那么桶排序也是稳定的，反之，则桶排序不是稳定的。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/008a0f95aad5f6d11f7404431c1f2427/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">8-18日报博文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac2c8190ad2c109d165fb2cc950c4ebb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu系统中根目录占用了大量内存后清理步骤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>