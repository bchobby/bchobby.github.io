<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker全解 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker全解" />
<meta property="og:description" content="目录 说明docker简介为什么是docker容器与虚拟机比较容器发展简史传统虚拟机技术容器虚拟化技术 docker能干什么带来技术职级的变化开发/运维（Devops)新一代开发工程师Docker应用场景why docker？docker的优势 docker和dockerHub官网 Docker安装CentOS Docker安装docker查看自己的内核安装阿里云镜像加速永远的HelloWorld Docker的基本组成镜像（image）容器（container）仓库（repository）小总结Docker平台架构图解Docker工作原理整体架构及底层通信原理简述Docker运行的基本流程底层原理（为什么Docker会比VM虚拟机快） Docker常用命令帮助启动类命令镜像命令docker imagesdocker searchdocker pulldocker system df 查看镜像/容器/数据卷所占用的空间docker rmi 删除镜像docker虚悬镜像 容器命令新建&#43;启动容器启动守护式容器（后台服务器）： docker ps列出当前所有正在运行的容器退出容器启动已停止运行的容器docker logs查看容器日志docker top查看容器内运行的进程docker inspect查看容器内部细节（审查容器）docker exec进入正在运行的容器并以命令行交互docker cp从容器内拷贝文件到主机上导入和导出容器 限制资源命令总结 Docker镜像Docker镜像加载原理为什么Docker镜像要采用分层结构Docker镜像commit操作案例 本地镜像发布到阿里云默认的Hub地址本地镜像发布到阿里云流程镜像生成的方法将本地镜像推送到阿里云将阿里云上的镜像下载到本地 本地镜像发布到私有库本地镜像发布到私有库流程 Docker容器数据卷使用特性数据卷案例宿主vs容器之间映射添加容器卷 读写规则映射添加说明卷的集成和共享 Docker常规安装简介安装tomcat安装mysql安装redis docker复杂安装安装mysql主从复制安装redis集群(cluster)主从容错切换迁移案例容错切换迁移主从扩容案例 DockerFile解析DockerFile是什么DockerFile构建过程解析DockerFile内容基础知识Docker执行DockerFile的大致流程小总结DockerFile常用保留字指令小总结自定义镜像mycentosjava8目标编写构建运行 虚悬镜像家庭作业自定义myubuntu Docker网络Docker 网络是什么docker不启动，默认网络情况docker启动后，网络情况常用基本命令All 命令docker network ls查看网络查看网络源数据删除网络创建网络 docker网络的作用（能干嘛）docker网络模式总体介绍容器实例内默认网络IP生产规则案例说明bridge模式案例两两匹配验证Host模式是什么案例 none模式是什么案例 container模式是什么案例 自定义网络案例 Docker平台架构图解Docker轻量级可视化工具Portainerdocker安装 说明 docker全解仅以作者【在读大学生】视角去认识，学习，使用docker，且以使用为主学习底层为辅进行书写，欢迎读者斧正。
docker简介 为什么是docker Docker的出现得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。【docker理念】：解决了运行环境和配置问题的软件容器，方便持续继承并有助于整体发布的容器虚拟化技术。 容器与虚拟机比较 容器发展简史 传统虚拟机技术 虚拟机（virtual machine）就是带环境安装的一种解决方案。
它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。
虚拟机的缺点：
资源占用多冗余步骤多启动慢 容器虚拟化技术 由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：
Linux容器(Linux Containers，缩写为 LXC)
Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。
Linux 容器不是模拟一个完整的操作系统 而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。
容器与虚拟机不同，不需要捆绑一整套操作系统 ，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/b9fb3a7a42bbdfe9b37f5788953997bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-29T20:24:21+08:00" />
<meta property="article:modified_time" content="2023-07-29T20:24:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker全解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">说明</a></li><li><a href="#docker_5" rel="nofollow">docker简介</a></li><li><ul><li><a href="#docker_6" rel="nofollow">为什么是docker</a></li><li><a href="#_10" rel="nofollow">容器与虚拟机比较</a></li><li><ul><li><a href="#_11" rel="nofollow">容器发展简史</a></li><li><a href="#_13" rel="nofollow">传统虚拟机技术</a></li><li><a href="#_23" rel="nofollow">容器虚拟化技术</a></li></ul> 
   </li><li><a href="#docker_37" rel="nofollow">docker能干什么</a></li><li><ul><li><a href="#_38" rel="nofollow">带来技术职级的变化</a></li><li><a href="#Devops_40" rel="nofollow">开发/运维（Devops)新一代开发工程师</a></li><li><a href="#Docker_47" rel="nofollow">Docker应用场景</a></li><li><a href="#why_docker_51" rel="nofollow">why docker？</a></li><li><a href="#docker_53" rel="nofollow">docker的优势</a></li></ul> 
   </li><li><a href="#dockerdockerHub_59" rel="nofollow">docker和dockerHub官网</a></li></ul> 
  </li><li><a href="#Docker_63" rel="nofollow">Docker安装</a></li><li><ul><li><a href="#CentOS_Dockerdocker_64" rel="nofollow">CentOS Docker安装docker</a></li><li><ul><li><a href="#_68" rel="nofollow">查看自己的内核</a></li><li><a href="#_81" rel="nofollow">安装</a></li><li><a href="#_143" rel="nofollow">阿里云镜像加速</a></li><li><a href="#HelloWorld_165" rel="nofollow">永远的HelloWorld</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Docker_171" rel="nofollow">Docker的基本组成</a></li><li><ul><li><a href="#image_172" rel="nofollow">镜像（image）</a></li><li><a href="#container_179" rel="nofollow">容器（container）</a></li><li><a href="#repository_186" rel="nofollow">仓库（repository）</a></li><li><a href="#_197" rel="nofollow">小总结</a></li><li><a href="#Docker_211" rel="nofollow">Docker平台架构图解</a></li><li><a href="#Docker_213" rel="nofollow">Docker工作原理</a></li><li><a href="#_219" rel="nofollow">整体架构及底层通信原理简述</a></li><li><a href="#Docker_222" rel="nofollow">Docker运行的基本流程</a></li><li><a href="#DockerVM_233" rel="nofollow">底层原理（为什么Docker会比VM虚拟机快）</a></li></ul> 
  </li><li><a href="#Docker_245" rel="nofollow">Docker常用命令</a></li><li><ul><li><a href="#_301" rel="nofollow">帮助启动类命令</a></li><li><a href="#_321" rel="nofollow">镜像命令</a></li><li><ul><li><a href="#docker_images_322" rel="nofollow">docker images</a></li><li><a href="#docker_search_346" rel="nofollow">docker search</a></li><li><a href="#docker_pull_359" rel="nofollow">docker pull</a></li><li><a href="#docker_system_df__371" rel="nofollow">docker system df 查看镜像/容器/数据卷所占用的空间</a></li><li><a href="#docker_rmi__377" rel="nofollow">docker rmi 删除镜像</a></li><li><a href="#docker_389" rel="nofollow">docker虚悬镜像</a></li></ul> 
   </li><li><a href="#_392" rel="nofollow">容器命令</a></li><li><ul><li><a href="#_396" rel="nofollow">新建+启动容器</a></li><li><ul><li><a href="#_412" rel="nofollow">启动守护式容器（后台服务器）：</a></li></ul> 
    </li><li><a href="#docker_ps_435" rel="nofollow">docker ps列出当前所有正在运行的容器</a></li><li><a href="#_452" rel="nofollow">退出容器</a></li><li><a href="#_460" rel="nofollow">启动已停止运行的容器</a></li><li><a href="#docker_logs_478" rel="nofollow">docker logs查看容器日志</a></li><li><a href="#docker_top_485" rel="nofollow">docker top查看容器内运行的进程</a></li><li><a href="#docker_inspect_490" rel="nofollow">docker inspect查看容器内部细节（审查容器）</a></li><li><a href="#docker_exec_496" rel="nofollow">docker exec进入正在运行的容器并以命令行交互</a></li><li><a href="#docker_cp_510" rel="nofollow">docker cp从容器内拷贝文件到主机上</a></li><li><a href="#_515" rel="nofollow">导入和导出容器</a></li></ul> 
   </li><li><a href="#_526" rel="nofollow">限制资源命令</a></li><li><a href="#_584" rel="nofollow">总结</a></li></ul> 
  </li><li><a href="#Docker_626" rel="nofollow">Docker镜像</a></li><li><ul><li><a href="#Docker_645" rel="nofollow">Docker镜像加载原理</a></li><li><a href="#Docker_655" rel="nofollow">为什么Docker镜像要采用分层结构</a></li><li><a href="#Dockercommit_666" rel="nofollow">Docker镜像commit操作案例</a></li></ul> 
  </li><li><a href="#_699" rel="nofollow">本地镜像发布到阿里云</a></li><li><ul><li><a href="#Hub_700" rel="nofollow">默认的Hub地址</a></li><li><a href="#_722" rel="nofollow">本地镜像发布到阿里云流程</a></li><li><a href="#_724" rel="nofollow">镜像生成的方法</a></li><li><a href="#_737" rel="nofollow">将本地镜像推送到阿里云</a></li><li><ul><li><a href="#_752" rel="nofollow">将阿里云上的镜像下载到本地</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_760" rel="nofollow">本地镜像发布到私有库</a></li><li><ul><li><a href="#_761" rel="nofollow">本地镜像发布到私有库流程</a></li></ul> 
  </li><li><a href="#Docker_830" rel="nofollow">Docker容器数据卷</a></li><li><ul><li><a href="#_837" rel="nofollow">使用</a></li><li><a href="#_844" rel="nofollow">特性</a></li><li><a href="#_856" rel="nofollow">数据卷案例</a></li><li><ul><li><a href="#vs_857" rel="nofollow">宿主vs容器之间映射添加容器卷</a></li></ul> 
   </li><li><a href="#_876" rel="nofollow">读写规则映射添加说明</a></li><li><a href="#_887" rel="nofollow">卷的集成和共享</a></li></ul> 
  </li><li><a href="#Docker_898" rel="nofollow">Docker常规安装简介</a></li><li><ul><li><a href="#tomcat_899" rel="nofollow">安装tomcat</a></li><li><a href="#mysql_919" rel="nofollow">安装mysql</a></li><li><a href="#redis_964" rel="nofollow">安装redis</a></li></ul> 
  </li><li><a href="#docker_1001" rel="nofollow">docker复杂安装</a></li><li><ul><li><a href="#mysql_1002" rel="nofollow">安装mysql主从复制</a></li><li><a href="#rediscluster_1113" rel="nofollow">安装redis集群(cluster)</a></li><li><ul><li><a href="#_1168" rel="nofollow">主从容错切换迁移案例</a></li><li><a href="#_1184" rel="nofollow">容错切换迁移</a></li><li><a href="#_1209" rel="nofollow">主从扩容案例</a></li></ul> 
  </li></ul> 
  </li><li><a href="#DockerFilehttpsdocsdockercomenginereferencebuilder_1266" rel="nofollow">DockerFile解析</a></li><li><ul><li><a href="#DockerFile_1267" rel="nofollow">DockerFile是什么</a></li><li><a href="#DockerFile_1278" rel="nofollow">DockerFile构建过程解析</a></li><li><ul><li><a href="#DockerFile_1279" rel="nofollow">DockerFile内容基础知识</a></li><li><a href="#DockerDockerFile_1287" rel="nofollow">Docker执行DockerFile的大致流程</a></li><li><a href="#_1296" rel="nofollow">小总结</a></li><li><a href="#DockerFile_1314" rel="nofollow">DockerFile常用保留字指令</a></li><li><a href="#_1445" rel="nofollow">小总结</a></li><li><a href="#mycentosjava8_1447" rel="nofollow">自定义镜像mycentosjava8</a></li><li><ul><li><a href="#_1448" rel="nofollow">目标</a></li><li><a href="#_1451" rel="nofollow">编写</a></li><li><a href="#_1484" rel="nofollow">构建</a></li><li><a href="#_1494" rel="nofollow">运行</a></li></ul> 
    </li><li><a href="#_1501" rel="nofollow">虚悬镜像</a></li><li><a href="#myubuntu_1531" rel="nofollow">家庭作业自定义myubuntu</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Docker_1561" rel="nofollow">Docker网络</a></li><li><ul><li><a href="#Docker__1563" rel="nofollow">Docker 网络是什么</a></li><li><ul><li><a href="#docker_1564" rel="nofollow">docker不启动，默认网络情况</a></li><li><a href="#docker_1578" rel="nofollow">docker启动后，网络情况</a></li><li><a href="#_1581" rel="nofollow">常用基本命令</a></li><li><ul><li><a href="#All__1582" rel="nofollow">All 命令</a></li><li><a href="#docker_network_ls_1584" rel="nofollow">docker network ls查看网络</a></li><li><a href="#_1594" rel="nofollow">查看网络源数据</a></li><li><a href="#_1599" rel="nofollow">删除网络</a></li><li><a href="#_1605" rel="nofollow">创建网络</a></li></ul> 
   </li></ul> 
   </li><li><a href="#docker_1612" rel="nofollow">docker网络的作用（能干嘛）</a></li><li><a href="#docker_1616" rel="nofollow">docker网络模式</a></li><li><ul><li><a href="#_1617" rel="nofollow">总体介绍</a></li><li><a href="#IP_1627" rel="nofollow">容器实例内默认网络IP生产规则</a></li><li><a href="#_1636" rel="nofollow">案例说明</a></li><li><ul><li><a href="#bridge_1637" rel="nofollow">bridge模式</a></li><li><a href="#_1648" rel="nofollow">案例</a></li><li><a href="#_1668" rel="nofollow">两两匹配验证</a></li><li><a href="#Host_1670" rel="nofollow">Host模式</a></li><li><ul><li><a href="#_1671" rel="nofollow">是什么</a></li><li><a href="#_1674" rel="nofollow">案例</a></li></ul> 
     </li><li><a href="#none_1699" rel="nofollow">none模式</a></li><li><ul><li><a href="#_1700" rel="nofollow">是什么</a></li><li><a href="#_1702" rel="nofollow">案例</a></li></ul> 
     </li><li><a href="#container_1708" rel="nofollow">container模式</a></li><li><ul><li><a href="#_1709" rel="nofollow">是什么</a></li><li><a href="#_1715" rel="nofollow">案例</a></li></ul> 
     </li><li><a href="#_1742" rel="nofollow">自定义网络</a></li><li><ul><li><a href="#_1743" rel="nofollow">案例</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#Docker_1782" rel="nofollow">Docker平台架构图解</a></li><li><a href="#DockerPortainer_1798" rel="nofollow">Docker轻量级可视化工具Portainer</a></li><li><ul><li><a href="#docker_1799" rel="nofollow">docker安装</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>说明</h2> 
<p>docker全解仅以作者【在读大学生】视角去认识，学习，使用docker，且以使用为主学习底层为辅进行书写，欢迎读者斧正。</p> 
<h2><a id="docker_5"></a>docker简介</h2> 
<h3><a id="docker_6"></a>为什么是docker</h3> 
<ol><li>Docker的出现得以打破过去「程序即应用」的观念。</li><li>透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</li><li>【docker理念】：解决了运行环境和配置问题的软件容器，方便持续继承并有助于整体发布的容器虚拟化技术。</li></ol> 
<h3><a id="_10"></a>容器与虚拟机比较</h3> 
<h4><a id="_11"></a>容器发展简史</h4> 
<p><img src="https://images2.imgbox.com/73/3b/eub8fDiK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_13"></a>传统虚拟机技术</h4> 
<ol><li> <p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p> </li><li> <p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p> </li><li> <p>虚拟机的缺点：</p> 
  <ol><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ol> </li></ol> 
<h4><a id="_23"></a>容器虚拟化技术</h4> 
<p>由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：</p> 
<p>Linux容器(Linux Containers，缩写为 LXC)</p> 
<p>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p> 
<p>Linux 容器不是模拟一个完整的操作系统 而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。</p> 
<p>容器与虚拟机不同，不需要捆绑一整套操作系统 ，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p> 
<p><img src="https://images2.imgbox.com/14/a6/Kxwadanj_o.png" alt="在这里插入图片描述"><br> <strong>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟 。因此容器要比传统虚拟机更为轻便。 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</strong></p> 
<h3><a id="docker_37"></a>docker能干什么</h3> 
<h4><a id="_38"></a>带来技术职级的变化</h4> 
<p><code>coder -&gt; programmer -&gt; software engineer -&gt; DevOps engineer</code></p> 
<h4><a id="Devops_40"></a>开发/运维（Devops)新一代开发工程师</h4> 
<ul><li>一次构建、随处运行</li><li>更快速的应用交付和部署</li><li>更便捷的升级和扩缩容</li><li>更简单的系统运维</li><li>更高效的计算资源利用</li></ul> 
<h4><a id="Docker_47"></a>Docker应用场景</h4> 
<p><img src="https://images2.imgbox.com/a1/1a/lXwqW4KT_o.png" alt="在这里插入图片描述"><br> Docker 借鉴了集装箱的概念，集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p> 
<h4><a id="why_docker_51"></a>why docker？</h4> 
<p><img src="https://images2.imgbox.com/59/82/4iyH3peY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="docker_53"></a>docker的优势</h4> 
<p><img src="https://images2.imgbox.com/e8/e5/AkQi1tNi_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/60/be/ipDk63mU_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般是几十个</td></tr></tbody></table> 
<h3><a id="dockerdockerHub_59"></a>docker和dockerHub官网</h3> 
<ol><li>docker：<a href="http://www.docker.com" rel="nofollow">docker</a></li><li>dockerHub：<a href="https://hub.docker.com" rel="nofollow">dockerHub</a></li></ol> 
<h2><a id="Docker_63"></a>Docker安装</h2> 
<h3><a id="CentOS_Dockerdocker_64"></a>CentOS Docker安装docker</h3> 
<ol><li>建议安装在linux系统上，以使用最广泛的centos为例。</li><li>Docker运行在CentOS 7（64-bit）上，要求系统为64位，Linux系统内核版本为3.8以上，这里选用Centos7.x。</li></ol> 
<h4><a id="_68"></a>查看自己的内核</h4> 
<p><code>uname</code> 命令用于打印当前系统相关信息（内核版本号，硬件架构，主机名称和操作系统类型等）</p> 
<pre><code class="prism language-bash"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token function">uname</span> - r
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token number">3.10</span>.0-1160.el7.x86_64
</code></pre> 
<p>查看发行版本：</p> 
<pre><code class="prism language-bash"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token function">cat</span> /etc/redhat-release
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> CentOS Linux release <span class="token number">7.9</span>.2009 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_81"></a>安装</h4> 
<p>参考官网：<a href="https://docs.docker.com/engine/install/centos/" rel="nofollow">docker for linux</a></p> 
<ol><li>卸载旧版本docker（如果未安装可以跳过)</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 卸载旧版本docker命令</span>
$ <span class="token function">sudo</span> yum remove <span class="token function">docker</span> docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine		
</code></pre> 
<ol start="2"><li>yum安装gcc相关命令</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># yum安装gcc相关命令</span>
yum <span class="token parameter variable">-y</span> <span class="token function">install</span> gcc
yum <span class="token parameter variable">-y</span> <span class="token function">install</span> gcc-c++
</code></pre> 
<ol start="3"><li>安装 yum-utils 包</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 官网要求</span>
yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils
</code></pre> 
<ol start="4"><li>设置stable镜像仓库</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 推荐使用 使用阿里的 docker 镜像仓库，国外的镜像仓库是比较慢的</span>
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre> 
<ol start="5"><li>更新yum软件包索引</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 更新yum软件包索引</span>
yum makecache fast
</code></pre> 
<ol start="6"><li>安装DOCKER CE 引擎</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 命令</span>
yum <span class="token parameter variable">-y</span> <span class="token function">install</span> docker-ce docker-ce-cli containerd.io
</code></pre> 
<ol start="7"><li>启动docker</li></ol> 
<pre><code class="prism language-go"># 启动命令
systemctl start docker
</code></pre> 
<ol start="8"><li>测试</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 测试</span>
<span class="token function">docker</span> version 

<span class="token function">docker</span> run hello-world
</code></pre> 
<ol start="9"><li>卸载【卸载命令，不是安装步骤里的】</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 卸载命令</span>
systemctl stop <span class="token function">docker</span> 
yum remove docker-ce docker-ce-cli containerd.io
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/docker
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/containerd
</code></pre> 
<h4><a id="_143"></a>阿里云镜像加速</h4> 
<p>地址：<a href="https://cr.console.aliyun.com/cn-wulanchabu/instances/mirrors" rel="nofollow">https://cr.console.aliyun.com/cn-wulanchabu/instances/mirrors</a></p> 
<p>获得加速器地址连接：</p> 
<ol><li>登陆阿里云开发者平台</li><li>点击控制台</li><li>选择容器镜像服务</li><li>获取加速器地址</li><li>粘贴脚本直接执行</li></ol> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/docker
<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'
{
  "registry-mirrors": ["你的专属容器镜像加速地址"]
}
EOF</span>
<span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span>
</code></pre> 
<h4><a id="HelloWorld_165"></a>永远的HelloWorld</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 命令</span>
<span class="token function">docker</span> run hello-world
</code></pre> 
<p><img src="https://images2.imgbox.com/12/ae/VEq5UfBU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Docker_171"></a>Docker的基本组成</h2> 
<h3><a id="image_172"></a>镜像（image）</h3> 
<ol><li> <p>Docker 镜像（Image）就是一个 <strong>只读</strong> 的模板。镜像可以用来创建 Docker 容器， 一个镜像可以创建很多容器 。</p> </li><li> <p>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。</p> </li><li> <p>相当于容器的“源代码”。</p> </li></ol> 
<h3><a id="container_179"></a>容器（container）</h3> 
<ol><li> <p>从面向对象角度：<br> Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境， 容器是用镜像创建的运行实例 。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境 ，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</p> </li><li> <p>从镜像容器角度：<br> <strong>可以把容器看做是一个简易版的</strong> *<strong>Linux*</strong> <strong>环境</strong> （包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p> </li></ol> 
<h3><a id="repository_186"></a>仓库（repository）</h3> 
<ol><li> <p>仓库（Repository）是 集中存放镜像 文件的场所。 类似于github仓库，存放各种git项目的地方；</p> </li><li> <p>Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p> </li><li> <p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p> </li><li> <p>最大的公开仓库是 Docker Hub(https://hub.docker.com/) ，</p> </li><li> <p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</p> </li></ol> 
<h3><a id="_197"></a>小总结</h3> 
<ol><li> <p>需要正确的理解仓库/镜像/容器这几个概念:</p> <p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p> <p>image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p> </li><li> <p>镜像文件 ：image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p> </li><li> <p>容器实例 ：一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器 。</p> </li><li> <p>仓库：就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。</p> </li></ol> 
<h3><a id="Docker_211"></a>Docker平台架构图解</h3> 
<p><img src="https://images2.imgbox.com/fd/5c/KU3iNRQi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Docker_213"></a>Docker工作原理</h3> 
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器 。</p> 
<p>容器，是一个运行时环境，就是我们前面说到的集装箱，可以对比mysql演示对比讲解：</p> 
<p><img src="https://images2.imgbox.com/dd/66/ut72tGYW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_219"></a>整体架构及底层通信原理简述</h3> 
<p>Docker是一个C/S模式的架构，后端是一个松耦合架构，众多模块各司其职</p> 
<h3><a id="Docker_222"></a>Docker运行的基本流程</h3> 
<ol><li>用户是使用Docker Client 与Docker Daemon 建立通信，并发送请求给后者。</li><li>Docker Daemon 作为Docker架构中的主体部分，首先提供Docker Server 的功能时期可以接受 Docker Client的请求。</li><li>Docker Engine 执行Docker内部的一些列工作，每一项工作都是以一个Job的形式的存在。</li><li>Job的运行过程中，当需要容器镜像是，则从Docker Register中下载镜像，并通过镜像管理驱动Graph driver 将下载镜像以Graph的形式存储。</li><li>当需要为Docker创建网络环境时，通过网络驱动Network driver创建并配置Docker容器网络环境。</li><li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。</li><li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体容器进行的操作。</li></ol> 
<p><img src="https://images2.imgbox.com/0e/4d/OR22qAQC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/65/44/Oa2NzW6z_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="DockerVM_233"></a>底层原理（为什么Docker会比VM虚拟机快）</h3> 
<p><img src="https://images2.imgbox.com/0a/b1/WY3k2MRU_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p>docker有着比虚拟机更少的抽象层</p> <p>由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p> </li><li> <p>docker利用的是宿主机的内核,而不需要加载操作系统OS内核</p> <p>当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/df/05/Vmu293Un_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Docker_245"></a>Docker常用命令</h2> 
<pre><code class="prism language-go">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像
build     Build an im from a Docker registry server          # 从当前 Docker registry 退出
logs      Fetch the logs of a container                 # 输出当前容器日志信息
port      Lookup the public<span class="token operator">-</span>facing port which is NAT<span class="token operator">-</span>ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口
pause     Pause all processes within a container        # 暂停容器
ps        List containers                               # 列出容器列表
pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像
push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器
restart   Restart a running container                   # 重启运行的容器
rm        Remove one or more containers                 # 移除一个或者多个容器
rmi       Remove one or more images             # 移除一个或多个镜像<span class="token punctuation">[</span>无容器使用该镜像才可删除，否则需删除相关容器才可继续或 <span class="token operator">-</span>f 强制删除<span class="token punctuation">]</span>
run       Run a command in a <span class="token builtin">new</span> container              # 创建一个新的容器并运行一个命令
save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包<span class="token punctuation">[</span>对应 load<span class="token punctuation">]</span>
search    Search <span class="token keyword">for</span> an image on the Docker Hub         # 在 docker hub 中搜索镜像
start     Start a stopped containers                    # 启动容器
stop      Stop a running containers                     # 停止容器
tag       Tag an image into a repository                # 给源中镜像打标签
top       Lookup the running processes of a container   # 查看容器中运行的进程信息
unpause   Unpause a paused container                    # 取消暂停容器
version   Show the docker version information           # 查看 docker 版本号
wait      Block until a container stops<span class="token punctuation">,</span> then <span class="token builtin">print</span> its exit code   # 截取容器停止时的退出状态值age from a Dockerfile              # 通过 Dockerfile 定制镜像
commit    Create a <span class="token builtin">new</span> image from a container changes   # 提交当前容器为新的镜像
cp        Copy files<span class="token operator">/</span>folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中
create    Create a <span class="token builtin">new</span> container                        # 创建一个新的容器，同 run，但不启动容器
diff      Inspect changes on a containers filesystem   # 查看 docker 容器变化
events    Get <span class="token builtin">real</span> time events from the server          # 从 docker 服务获取容器实时事件
exec      Run a command in an existing container        # 在已存在的容器上运行命令
export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件<span class="token punctuation">[</span>对应 <span class="token keyword">import</span> <span class="token punctuation">]</span>
history   Show the history of an image                  # 展示一个镜像形成历史
images    List images                                   # 列出系统当前镜像
<span class="token keyword">import</span>    Create a <span class="token builtin">new</span> filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像<span class="token punctuation">[</span>对应export<span class="token punctuation">]</span>
info      Display system<span class="token operator">-</span>wide information               # 显示系统相关信息
inspect   Return low<span class="token operator">-</span>level information on a container   # 查看容器详细信息
kill      Kill a running container                      # kill 指定 docker 容器
load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像<span class="token punctuation">[</span>对应 save<span class="token punctuation">]</span>
login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器
logout    Log out
</code></pre> 
<p>大致分类：</p> 
<pre><code class="prism language-go">Docker环境信息   info、version
容器生命周期管理  create、exec、kill、pause、restart、rm、run、start、stop、unpause
镜像仓库命令      login、logout、pull、push、search
镜像管理          build、images、<span class="token keyword">import</span>、load、rmi、save、tag、commit
容器运维操作      attach、export、inspect、port、ps、rename、stats、top、wait、cp、diff、update
容器资源管理      volume、network
系统信息日志      events、history、logs
<span class="token number">1</span><span class="token punctuation">.</span>events打印容器的实时系统事件
<span class="token number">2</span><span class="token punctuation">.</span>history 打印出指定镜像的历史版本信息
<span class="token number">3</span><span class="token punctuation">.</span>logs打印容器中进程的运行日志
</code></pre> 
<h3><a id="_301"></a>帮助启动类命令</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 启动命令</span>
systemctl start <span class="token function">docker</span>
<span class="token comment"># 停止命令</span>
systemctl stop <span class="token function">docker</span>
<span class="token comment"># 重启命令</span>
systemctl restart <span class="token function">docker</span>
<span class="token comment"># 查看docker状态</span>
systemctl status <span class="token function">docker</span>
<span class="token comment"># 开机启动</span>
systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>
<span class="token comment"># 查看 docker 概要信息</span>
<span class="token function">docker</span> info
<span class="token comment"># 查看docker 总体帮助文档</span>
<span class="token function">docker</span> <span class="token parameter variable">--help</span>
<span class="token comment"># 查看docker命令帮助文档：</span>
<span class="token function">docker</span> 具体命令 <span class="token parameter variable">--help</span>
</code></pre> 
<h3><a id="_321"></a>镜像命令</h3> 
<h4><a id="docker_images_322"></a>docker images</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 列出本地主机上的镜像</span>
<span class="token function">docker</span> images 
</code></pre> 
<p><img src="https://images2.imgbox.com/2a/2d/blU7gpQj_o.png" alt="在这里插入图片描述"><br> 各个选项说明:</p> 
<ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签版本号</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul> 
<p>同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，使用 <code>REPOSITORY:TAG</code> 来定义不同的镜像。</p> 
<p><strong>如果你不指定一个镜像的版本标签</strong>，例如你只使用 ubuntu，docker 将默认使用 <code>ubuntu:latest</code> 镜像</p> 
<p>OPTIONS 说明：</p> 
<p>-a : 列出本地所有的镜像（含历史映像层）<br> -q：只显示镜像ID</p> 
<h4><a id="docker_search_346"></a>docker search</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 网站</span>
https://hub.docker.com
<span class="token comment"># 命令</span>
<span class="token function">docker</span> search <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>镜像名字
<span class="token comment"># OPTIONS说明</span>
<span class="token comment"># --limit ：只列出N个镜像，默认25个</span>
<span class="token function">docker</span> search  <span class="token parameter variable">--limit</span> <span class="token number">5</span> redis
</code></pre> 
<p><img src="https://images2.imgbox.com/a9/32/oJpfzYv8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="docker_pull_359"></a>docker pull</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 下载镜像</span>
<span class="token function">docker</span> pull 镜像名字<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span>
<span class="token function">docker</span> pull  镜像名字 

<span class="token comment"># 没有TAG就是最新版本 等价于</span>
<span class="token function">docker</span> pull 镜像名字：latest
<span class="token function">docker</span> pull ubuntu 
</code></pre> 
<p><img src="https://images2.imgbox.com/19/b3/yBv8eLub_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="docker_system_df__371"></a>docker system df 查看镜像/容器/数据卷所占用的空间</h4> 
<pre><code class="prism language-bash"><span class="token function">docker</span> system <span class="token function">df</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ff/d9/AoR5iYAR_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="docker_rmi__377"></a>docker rmi 删除镜像</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 删除单个</span>
<span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> 镜像ID

<span class="token comment"># 删除多个</span>
<span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> 镜像名1:TAG 镜像名2:TAG

<span class="token comment"># 删除全部</span>
<span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token parameter variable">-qa</span><span class="token variable">)</span></span>
</code></pre> 
<h4><a id="docker_389"></a>docker虚悬镜像</h4> 
<p>仓库名称，标签都是的镜像，俗称虚悬镜像dangling image</p> 
<h3><a id="_392"></a>容器命令</h3> 
<p>有镜像才能创建容器，这是根本前提，我目前是在windows系统上开启VM虚拟机安装了一个centos7，又在其上安装了docker，利用docker创建了一个centos7.5的容器。</p> 
<p><img src="https://images2.imgbox.com/20/3e/KfSuHISM_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_396"></a>新建+启动容器</h4> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>OPTIONS说明（常用）：</p> 
<ol><li>–name=“容器新名字” 为容器指定一个名称；</li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</li><li>-i：以交互模式运行容器，通常与 -t 同时使用；</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； 也即 启动交互式容器(前台有伪终端，等待交互)</li><li>-P: 随机 端口映射，大写P</li><li>-p: 指定 端口映射，小写p</li></ol> 
<p><img src="https://images2.imgbox.com/2e/5a/tw6TmSNf_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_412"></a>启动守护式容器（后台服务器）：</h5> 
<p>在大部分的场景下，我们希望docker的服务是在后台运行的，我们可以通过 -d 指定容器的后台运行模式。</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> 容器名
<span class="token comment"># 使用镜像centos:latest以后台模式启动一个容器 </span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> centos 
</code></pre> 
<p>问题：然后docker ps -a 进行查看, 会发现容器已经退出。</p> 
<p>注意：Docker容器后台运行,就必须有一个前台进程，容器运行的命令如果不是那些 一直挂起的命令 （比如运行top，tail），就会自动退出的。</p> 
<p>这个是docker的机制问题,以nginx为例，正常情况下, 配置启动服务只需要启动响应的service即可。例如<code>service nginx start</code>或者<code>systemctl start nginx</code> 这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用, 这样的容器后台启动后,会立即自杀因为他觉得他没事可做了. 所以，最佳的解决方案是, 将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断。</p> 
<pre><code class="prism language-bash"><span class="token comment"># 前台交互式启动</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> redis:6.0.8
<span class="token comment"># 后台交互式启动</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> redis:6.0.8
</code></pre> 
<h4><a id="docker_ps_435"></a>docker ps列出当前所有正在运行的容器</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 列出当前所有正在运行的容器</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>
<span class="token comment"># OPTIONS说明</span>
<span class="token parameter variable">-a</span> <span class="token builtin class-name">:</span> 列出当前所有 正在运行 的容器 + 历史上运行过 的 
<span class="token parameter variable">-l</span> :显示最近创建的容器。 
-n：显示最近n个创建的容器。 
<span class="token parameter variable">-q</span> :静默模式，只显示容器编号。 
</code></pre> 
<p>OPTIONS说明：</p> 
<ol><li>-a : 列出当前所有 正在运行 的容器 + 历史上运行过 的</li><li>-l :显示最近创建的容器。</li><li>-n：显示最近n个创建的容器。</li><li>-q :静默模式，只显示容器编号。</li></ol> 
<h4><a id="_452"></a>退出容器</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 两种退出方式</span>
<span class="token comment"># 1、run进去容器，exit退出，容器停止</span>
<span class="token builtin class-name">exit</span> 
<span class="token comment"># 2、run进去容器，ctrl+p+q退出，容器不停止</span>
ctrl+p+q
</code></pre> 
<h4><a id="_460"></a>启动已停止运行的容器</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 启动已停止运行的容器</span>
<span class="token function">docker</span> start 容器ID或者容器名
<span class="token comment"># 重启容器</span>
<span class="token function">docker</span> restart 容器ID或者容器名
<span class="token comment"># 停止容器</span>
<span class="token function">docker</span> stop 容器ID或者容器名
<span class="token comment"># 强制停止容器</span>
<span class="token function">docker</span> <span class="token function">kill</span> 容器ID或容器名
<span class="token comment"># 删除已停止的容器</span>
<span class="token function">docker</span> <span class="token function">rm</span> 容器ID
<span class="token comment"># 一次性删除多个容器实例</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span>

<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">docker</span> <span class="token function">rm</span>
</code></pre> 
<h4><a id="docker_logs_478"></a>docker logs查看容器日志</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 查看容器日志</span>
<span class="token function">docker</span> logs 容器ID
</code></pre> 
<p><img src="https://images2.imgbox.com/53/d5/cRQZGO20_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="docker_top_485"></a>docker top查看容器内运行的进程</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 查看容器内运行的进程</span>
<span class="token function">docker</span> <span class="token function">top</span> 容器ID
</code></pre> 
<h4><a id="docker_inspect_490"></a>docker inspect查看容器内部细节（审查容器）</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 查看容器内部细节</span>
<span class="token function">docker</span> inspect 容器ID
</code></pre> 
<h4><a id="docker_exec_496"></a>docker exec进入正在运行的容器并以命令行交互</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 进入容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID bashShell
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 16dhh212 <span class="token function">bash</span>

<span class="token comment"># 重新进入</span>
<span class="token function">docker</span> attach 容器ID
</code></pre> 
<p>区别：</p> 
<ol><li>attach 直接进入容器启动命令的终端，不会启动新的进程用exit退出，会导致容器的停止。</li><li>exec 是在容器中打开新的终端，并且可以启动新的进程用exit退出，不会导致容器的停止。</li></ol> 
<h4><a id="docker_cp_510"></a>docker cp从容器内拷贝文件到主机上</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 容器 -&gt; 主机</span>
<span class="token function">docker</span> <span class="token function">cp</span> 容器ID:容器内路径  目的主机路径
</code></pre> 
<h4><a id="_515"></a>导入和导出容器</h4> 
<ol><li>Export 导出容器的内容留作为一个tar归档文件[对应import命令]</li><li>import 从tar 包中的内容创建一个新的文件系统再导入为镜像[对应export]</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 导出</span>
<span class="token function">docker</span> <span class="token builtin class-name">export</span> 容器ID  <span class="token operator">&gt;</span> 文件.tar 

<span class="token comment"># 导入</span>
<span class="token function">cat</span> 文件名.tar  <span class="token operator">|</span> <span class="token function">docker</span>  <span class="token function">import</span>  -镜像用户/镜像名:镜像版本号
</code></pre> 
<h3><a id="_526"></a>限制资源命令</h3> 
<p>Docker提供了多种方式来控制容器的资源占用，包括限制内存和CPU。这些资源限制可以帮助您有效地管理和控制容器，确保它们在运行时不会过度占用系统资源。</p> 
<p>以下是在Docker中控制容器资源的方法：</p> 
<ol><li> <p>限制内存：</p> 
  <ul><li> <p>使用<code>--memory</code>选项：通过在<code>docker run</code>命令中使用<code>--memory</code>选项，可以限制容器可以使用的内存量。例如，限制容器最大使用1GB内存：</p> <pre><code>docker run --memory=1g my_image
</code></pre> </li><li> <p>使用<code>--memory-reservation</code>选项：此选项用于设置容器的内存保留量，确保容器至少能够获得指定数量的内存。例如，设置容器至少保留512MB内存：</p> <pre><code>docker run --memory-reservation=512m my_image
</code></pre> </li></ul> <p>这些选项还可以与<code>--memory-swap</code>和<code>--memory-swappiness</code>等选项结合使用，用于更精细地配置容器的内存限制和交换行为。</p> </li><li> <p>限制CPU：</p> 
  <ul><li> <p>使用<code>--cpus</code>选项：通过在<code>docker run</code>命令中使用<code>--cpus</code>选项，可以限制容器可以使用的CPU核心数。例如，限制容器最多使用2个CPU核心：</p> <pre><code>docker run --cpus=2 my_image
</code></pre> </li><li> <p>使用<code>--cpuset-cpus</code>选项：此选项用于将容器限制在指定的CPU核心上运行。例如，将容器限制在第1和第3个CPU核心上运行：</p> <pre><code>docker run --cpuset-cpus="0,2" my_image
</code></pre> </li></ul> <p>可以根据需要组合使用这些选项，以满足对容器资源控制的不同需求。</p> </li></ol> 
<p>注意：在使用上述资源限制选项时，应根据应用程序的实际需求和系统资源进行调整，以避免过度限制或浪费资源。同时，在使用Docker时，还应注意与宿主系统的资源管理和其他容器之间的资源竞争。如果您需要更复杂的资源管理和调度，可以考虑使用Kubernetes等容器编排平台，它们提供更全面的资源管理和调度功能。</p> 
<p>在Dockerfile 中，不能直接指定容器运行时的资源占用上限，就像Kubernetes的 <code>limits</code> 关键字那样。Dockerfile 是用来定义 Docker 镜像的构建过程的，而资源限制是在运行容器时通过 <code>docker run</code> 命令的选项来配置的。</p> 
<p>在 Dockerfile 中，您可以定义容器的基本配置和环境设置，但不能直接指定容器运行时的资源限制。资源限制通常是在运行容器时使用 <code>docker run</code> 命令的选项，比如 <code>--memory</code> 和 <code>--cpus</code> 来设置的。这些选项在构建镜像时并不会生效。</p> 
<p>示例：<br> 假设您有以下 Dockerfile 来构建一个基于 Python 的应用镜像：</p> 
<pre><code class="prism language-Dockerfile">FROM python:3.8
COPY app.py /app.py
CMD ["python", "/app.py"]
</code></pre> 
<p>在构建镜像时，这个 Dockerfile 将会将 Python 应用程序复制到镜像中，并设置默认的启动命令为运行 Python 应用程序。</p> 
<p>然后，在运行容器时，您可以使用 <code>docker run</code> 命令来设置容器的资源限制，比如：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">--memory</span><span class="token operator">=</span>1g <span class="token parameter variable">--cpus</span><span class="token operator">=</span><span class="token number">2</span> my_image
</code></pre> 
<p>这样就会在运行容器时限制其最大使用 1GB 内存和 2 个 CPU 核心。</p> 
<p>因此，资源限制是在运行容器时指定的，而不是在 Dockerfile 中指定的。如果您需要定义容器的资源限制并将其与镜像一起定义，最好的做法是在容器编排工具（比如 Kubernetes）中定义资源限制，或者在运行容器时使用 <code>docker run</code> 命令来设置资源限制。</p> 
<h3><a id="_584"></a>总结</h3> 
<p><img src="https://images2.imgbox.com/ec/cf/vkiwVtWE_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">attach    Attach to a running container                 <span class="token comment"># 当前 shell 下 attach 连接指定运行镜像 </span>
build     Build an image from a Dockerfile              <span class="token comment"># 通过 Dockerfile 定制镜像 </span>
commit    Create a new image from a container changes   <span class="token comment"># 提交当前容器为新的镜像 </span>
<span class="token function">cp</span>        Copy files/folders from the containers filesystem to the <span class="token function">host</span> path   <span class="token comment">#从容器中拷贝指定文件或者目录到宿主机中 </span>
create    Create a new container                        <span class="token comment"># 创建一个新的容器，同 run，但不启动容器 </span>
<span class="token function">diff</span>      Inspect changes on a container's filesystem   <span class="token comment"># 查看 docker 容器变化 </span>
events    Get real <span class="token function">time</span> events from the server          <span class="token comment"># 从 docker 服务获取容器实时事件 </span>
<span class="token builtin class-name">exec</span>      Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> an existing container        <span class="token comment"># 在已存在的容器上运行命令 </span>
<span class="token builtin class-name">export</span>    Stream the contents of a container as a <span class="token function">tar</span> archive   <span class="token comment"># 导出容器的内容流作为一个 tar 归档文件[对应 import ] </span>
<span class="token function">history</span>   Show the <span class="token function">history</span> of an image                  <span class="token comment"># 展示一个镜像形成历史 </span>
images    List images                                   <span class="token comment"># 列出系统当前镜像 </span>
<span class="token function">import</span>    Create a new filesystem image from the contents of a tarball <span class="token comment"># 从tar包中的内容创建一个新的文件系统映像[对应export] </span>
info      Display system-wide information               <span class="token comment"># 显示系统相关信息 </span>
inspect   Return low-level information on a container   <span class="token comment"># 查看容器详细信息 </span>
<span class="token function">kill</span>      Kill a running container                      <span class="token comment"># kill 指定 docker 容器 </span>
load      Load an image from a <span class="token function">tar</span> archive              <span class="token comment"># 从一个 tar 包中加载一个镜像[对应 save] </span>
login     Register or Login to the <span class="token function">docker</span> registry server    <span class="token comment"># 注册或者登陆一个 docker 源服务器 </span>
<span class="token builtin class-name">logout</span>    Log out from a Docker registry server          <span class="token comment"># 从当前 Docker registry 退出 </span>
logs      Fetch the logs of a container                 <span class="token comment"># 输出当前容器日志信息 </span>
port      Lookup the public-facing port <span class="token function">which</span> is NAT-ed to PRIVATE_PORT    <span class="token comment"># 查看映射端口对应的容器内部源端口 </span>
pause     Pause all processes within a container        <span class="token comment"># 暂停容器 </span>
<span class="token function">ps</span>        List containers                               <span class="token comment"># 列出容器列表 </span>
pull      Pull an image or a repository from the <span class="token function">docker</span> registry server   <span class="token comment"># 从docker镜像源服务器拉取指定镜像或者库镜像 </span>
push      Push an image or a repository to the <span class="token function">docker</span> registry server    <span class="token comment"># 推送指定镜像或者库镜像至docker源服务器 </span>
restart   Restart a running container                   <span class="token comment"># 重启运行的容器 </span>
<span class="token function">rm</span>        Remove one or <span class="token function">more</span> containers                 <span class="token comment"># 移除一个或者多个容器 </span>
rmi       Remove one or <span class="token function">more</span> images       <span class="token comment"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] </span>
run       Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a new container              <span class="token comment"># 创建一个新的容器并运行一个命令 </span>
save      Save an image to a <span class="token function">tar</span> archive                <span class="token comment"># 保存一个镜像为一个 tar 包[对应 load] </span>
search    Search <span class="token keyword">for</span> an image on the Docker Hub         <span class="token comment"># 在 docker hub 中搜索镜像 </span>
start     Start a stopped containers                    <span class="token comment"># 启动容器 </span>
stop      Stop a running containers                     <span class="token comment"># 停止容器 </span>
tag       Tag an image into a repository                <span class="token comment"># 给源中镜像打标签 </span>
<span class="token function">top</span>       Lookup the running processes of a container   <span class="token comment"># 查看容器中运行的进程信息 </span>
unpause   Unpause a paused container                    <span class="token comment"># 取消暂停容器 </span>
version   Show the <span class="token function">docker</span> version information           <span class="token comment"># 查看 docker 版本号 </span>
<span class="token function">wait</span>      Block <span class="token keyword">until</span> a container stops, <span class="token keyword">then</span> print its <span class="token builtin class-name">exit</span> code   <span class="token comment"># 截取容器停止时的退出状态值 </span>
</code></pre> 
<h2><a id="Docker_626"></a>Docker镜像</h2> 
<pre><code class="prism language-bash">【镜像】 
是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，
我们把应用程序和配置依赖打包好形成一个可交付的运行环境<span class="token punctuation">(</span>包括代码、运行时需要的库、环境变量和配置文件等<span class="token punctuation">)</span>，
这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例。

【分层镜像】
以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载 。

【UnionFS（联合文件系统）】
UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统。
它支持对文件系统的修改作为一次提交来一层层的叠加， 同时可以将不同目录挂载到同一个虚拟文件系统下<span class="token punctuation">(</span>unite several directories into a single virtual filesystem<span class="token punctuation">)</span>。
Union 文件系统是 Docker 镜像的基础。 镜像可以通过分层来进行继承 ，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 

特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，
联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 
</code></pre> 
<h3><a id="Docker_645"></a>Docker镜像加载原理</h3> 
<ol><li> <p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫做UnionFS。</p> </li><li> <p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统， 在Docker镜像的最底层是引导文件系统bootfs。 这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p> </li><li> <p>rootfs (root file system) ，在bootfs之上 。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/a9/68/M3OLx31N_o.png" alt="在这里插入图片描述"><br> 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p> 
<h3><a id="Docker_655"></a>为什么Docker镜像要采用分层结构</h3> 
<ol><li> <p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p> </li><li> <p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；<br> 同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p> </li><li> <p>Docker镜像层都是只读的，容器层是可写的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作"容器层"，“容器层"之下的都叫"镜像层”。</p> </li><li> <p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/75/8c/ppA6JSdt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Dockercommit_666"></a>Docker镜像commit操作案例</h3> 
<pre><code class="prism language-bash"><span class="token function">docker</span> commit 提交容器副本使之成为一个新的镜像

<span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">"提交的描述信息"</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">"作者"</span> 容器ID  要创建的目标镜像名:<span class="token punctuation">[</span>标签名<span class="token punctuation">]</span>
</code></pre> 
<ol><li>运行一个乌班图</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull <span class="token parameter variable">-it</span> ubuntu
</code></pre> 
<ol start="2"><li>容器内安装vim</li></ol> 
<pre><code class="prism language-bash"><span class="token function">apt-get</span> update 

<span class="token function">apt-get</span> <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span> 
</code></pre> 
<ol start="3"><li>容器内commit</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">"add vim"</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">"Generalzy"</span> 容器ID  Generalzy/Ubuntu:0.0.1
</code></pre> 
<ol start="4"><li>启动新镜像，可以正常使用vim命令了</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> images
<span class="token comment"># 以bash进去</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> 镜像ID <span class="token function">bash</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/48/76/CMLXgBQR_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_699"></a>本地镜像发布到阿里云</h2> 
<h3><a id="Hub_700"></a>默认的Hub地址</h3> 
<p>Docker 默认从 Docker Hub（hub.docker.com）拉取镜像，这是一个公共的 Docker 镜像注册表。当您使用 docker pull 命令或在 Dockerfile 中指定镜像时，如果未指定其他的镜像仓库地址，Docker 将默认从 Docker Hub 拉取镜像。</p> 
<p>要查看 Docker 的默认镜像仓库地址，可以执行以下命令：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> info
</code></pre> 
<p>查看registery:<br> <img src="https://images2.imgbox.com/22/d4/oEJKPwdq_o.png" alt="在这里插入图片描述"><br> 可以通过编辑 Docker 配置文件（/etc/docker/daemon.json）来自定义默认的镜像仓库。在该配置文件中，可以使用 registry-mirrors 字段来指定镜像仓库的地址，或使用其他配置项来定义镜像源。修改配置文件后，需要重启 Docker 服务使配置生效。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/docker
<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'
{
  "registry-mirrors": ["https://roefefkq.mirror.aliyuncs.com"]
}
EOF</span>
<span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span>
</code></pre> 
<h3><a id="_722"></a>本地镜像发布到阿里云流程</h3> 
<p><img src="https://images2.imgbox.com/05/b9/c6hZQCgC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_724"></a>镜像生成的方法</h3> 
<p>基于当前容器创建一个新的镜像，新功能增强</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> commit <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>容器ID <span class="token punctuation">[</span>REPOSOTORY<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>OPTIONS说明：</p> 
<ol><li> <p>-a :提交的镜像作者；</p> </li><li> <p>-m :提交时的说明文字；</p> </li></ol> 
<h3><a id="_737"></a>将本地镜像推送到阿里云</h3> 
<p><img src="https://images2.imgbox.com/91/7d/kb7bLI6L_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token comment"># 用户名登录</span>
<span class="token function">docker</span> login <span class="token parameter variable">--username</span><span class="token operator">=</span><span class="token variable">${username}</span> registry.cn-hangzhou.aliyuncs.com 
password:

<span class="token comment"># 将镜像ID打标签 标签格式一般为: dockerHub地址/用户名/镜像名:版本号</span>
<span class="token comment"># 等同于将go mod init github.com/Generalzy/项目名</span>
<span class="token function">docker</span> tag cea1bb40441c registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 

<span class="token comment"># 推到dockerHub</span>
<span class="token function">docker</span> push registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 
</code></pre> 
<h4><a id="_752"></a>将阿里云上的镜像下载到本地</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 点名道姓下载刚才自己推上去的镜像</span>
<span class="token function">docker</span> pull registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 
</code></pre> 
<p><img src="https://images2.imgbox.com/51/c9/SWQYwcI1_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_760"></a>本地镜像发布到私有库</h2> 
<h3><a id="_761"></a>本地镜像发布到私有库流程</h3> 
<ol><li> <p>下载镜像Docker Registry</p> <pre><code class="prism language-bash"><span class="token function">docker</span> pull registry  
</code></pre> </li><li> <p>运行私有库Registry，相当于本地有个私有库Docker hub</p> <pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token parameter variable">-v</span> /zzyyuse/myregistry/:/tmp/registry <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true registry 
</code></pre> <p>默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</p> </li><li> <p>从Hub上下载ubuntu镜像到本地并成功运行，原始Ubuntu镜像是不带着ifconfig命令的</p> <pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-ti</span> ubuntu <span class="token function">bash</span>
<span class="token comment"># 安装ifconfig</span>
<span class="token function">apt-get</span> update 
<span class="token function">apt-get</span> <span class="token function">install</span> net-tools 
</code></pre> </li><li> <p>安装完成后，commit我们自己的新镜像</p> <pre><code class="prism language-bash"><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">" 提交的描述信息 "</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">" 作者 "</span> 容器 ID 要创建的目标镜像名 :<span class="token punctuation">[</span> 标签名 <span class="token punctuation">]</span> 
在容器外执行，记得 
<span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">" ifconfig cmd add "</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">" zzyy "</span> a69d7c825c4f zzyyubuntu:1.2 
</code></pre> </li><li> <p>curl验证私服库上有什么镜像</p> <pre><code class="prism language-bash"><span class="token function">curl</span> <span class="token parameter variable">-XGET</span> http://192.168.111.162:5000/v2/_catalog 
</code></pre> </li><li> <p>将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</p> <pre><code class="prism language-bash">按照公式： <span class="token function">docker</span>   tag   镜像:Tag   Host:Port/Repository:Tag 
使用命令 <span class="token function">docker</span> tag 将zzyyubuntu:1.2 这个镜像修改为 你的IP:5000/zzyyubuntu:1.2 

<span class="token function">docker</span> tag  zzyyubuntu:1.2  你的IP:5000/zzyyubuntu:1.2 
</code></pre> </li><li> <p>修改配置文件使之支持http</p> <pre><code class="prism language-bash">vim命令新增如下内容：vim /etc/docker/daemon.json 
<span class="token punctuation">{<!-- --></span>
   <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"阿里云加速镜像"</span><span class="token punctuation">]</span> , 
   <span class="token string">"insecure-registries"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"你的仓库IP:5000"</span><span class="token punctuation">]</span> 
 <span class="token punctuation">}</span> 
</code></pre> <p>docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。</p> </li><li> <p>push推送到私服库</p> <pre><code class="prism language-bash"><span class="token function">docker</span> push 私服IP:5000/zzyyubuntu:1.2 
</code></pre> </li><li> <p>curl验证私服库上有什么镜像</p> <pre><code class="prism language-bash"><span class="token function">curl</span> <span class="token parameter variable">-XGET</span> http://私服IP:5000/v2/_catalog 
</code></pre> </li><li> <p>pull到本地并运行</p> <pre><code class="prism language-bash"><span class="token function">docker</span> pull 你的IP/zzyyubuntu:1.2 
</code></pre> </li></ol> 
<h2><a id="Docker_830"></a>Docker容器数据卷</h2> 
<p>Docker挂载主机目录访问 如果出现<code>cannot open directory .: Permission denied </code></p> 
<p>解决办法：在挂载目录后多加一个<code>--privileged=true</code>参数即可</p> 
<p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为， 在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用<code>--privileged=true</code>命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p> 
<h3><a id="_837"></a>使用</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 将docker容器内的数据保存进宿主机的磁盘中</span>
<span class="token comment"># 运行一个带有容器卷存储功能的容器实例</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /宿主机绝对路径目录:/容器内目录   镜像名
</code></pre> 
<h3><a id="_844"></a>特性</h3> 
<p>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是 持久化的</p> 
<p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。<br> 为了能保存数据在docker中我们使用卷。</p> 
<p>特点：<br> 1：数据卷可在容器之间共享或重用数据<br> 2：卷中的更改可以直接实时生效。<br> 3：数据卷中的更改不会包含在镜像的更新中<br> 4：数据卷的生命周期一直持续到没有容器使用它为止</p> 
<h3><a id="_856"></a>数据卷案例</h3> 
<h4><a id="vs_857"></a>宿主vs容器之间映射添加容器卷</h4> 
<p>直接命令添加：</p> 
<pre><code class="prism language-bash"><span class="token comment"># docker run -it -v /宿主机目录:/容器内目录</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> myu3 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash 
</code></pre> 
<p>查看数据卷是否挂成功：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> inspect 容器ID 
</code></pre> 
<p>容器和宿主机之间数据共享：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>. docker修改，主机同步获得  
<span class="token number">2</span>. 主机修改，docker同步获得 
<span class="token number">3</span>. docker容器stop，主机修改，docker容器重启看数据是否同步。
</code></pre> 
<h3><a id="_876"></a>读写规则映射添加说明</h3> 
<ol><li>读写(默认)</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /宿主机绝对路径目录:/容器内目录:rw  镜像名
</code></pre> 
<ol start="2"><li>只读：容器实例内部被限制，只能读取不能写</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /宿主机绝对路径目录:/容器内目录:ro  镜像名
</code></pre> 
<h3><a id="_887"></a>卷的集成和共享</h3> 
<ol><li>容器1完成和宿主机的映射</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /mydocker/u:/tmp <span class="token parameter variable">--name</span> u1 ubuntu 
</code></pre> 
<ol start="2"><li>容器2集成容器1的卷规则</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true --volumes-from 父类 <span class="token parameter variable">--name</span> u2 ubuntu
</code></pre> 
<h2><a id="Docker_898"></a>Docker常规安装简介</h2> 
<h3><a id="tomcat_899"></a>安装tomcat</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 命令</span>
<span class="token function">docker</span> search tomcat

<span class="token comment"># 命令</span>
<span class="token function">docker</span> pull tomcat

<span class="token comment"># 命令</span>
<span class="token function">docker</span> images tomcat

<span class="token comment"># 命令</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 tomcat
</code></pre> 
<p>可能出现404 的情况，解决：</p> 
<ol><li>可能没有映射端口或者没有关闭防火墙</li><li>进入容器，把webapps.dist 目录换成webapps<br> <img src="https://images2.imgbox.com/1f/bf/jzrGne0M_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="mysql_919"></a>安装mysql</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 命令</span>
<span class="token function">docker</span> search mysql

<span class="token comment"># 命令</span>
<span class="token function">docker</span> pull mysql:5.7

<span class="token comment"># 命令 参考：https://hub.docker.com/_/mysql</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">-d</span> mysql:5.7 

<span class="token comment"># 进入容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID /bin/bash
mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span>
</code></pre> 
<p>实战版：</p> 
<pre><code class="prism language-bash"><span class="token comment">#1、新建mysql容器实例</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /zzyyuse/mysql/log:/var/log/mysql <span class="token parameter variable">-v</span> /zzyyuse/mysql/data:/var/lib/mysql <span class="token parameter variable">-v</span> /zzyyuse/mysql/conf:/etc/mysql/conf.d <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span>  <span class="token parameter variable">--name</span> mysql mysql:5.7 

<span class="token comment">#2、新建my.cnf  通过容器卷同步给MySQL容器实例</span>
<span class="token punctuation">[</span>client<span class="token punctuation">]</span>
<span class="token assign-left variable">default_character_set</span><span class="token operator">=</span>utf8 
<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span> 
collation_server <span class="token operator">=</span> utf8_general_ci 
character_set_server <span class="token operator">=</span> utf8 

<span class="token comment">#3、重新启动mysql容器实例在重新进入并查看字符编码</span>
<span class="token function">docker</span> restart mysql
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysql_bash
show variables like <span class="token string">'character%'</span><span class="token punctuation">;</span>

<span class="token comment">#4、再新建库新建表再插入中文测试</span>
完全正常

<span class="token comment">#5、结论</span>
之前的DB  无效 
修改字符集操作+重启mysql容器实例 
之后的DB  有效，需要新建 
结论： docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据 

<span class="token comment">#6、假如将当前容器实例删除，再重新来一次，之前建的db01实例还有吗？trytry</span>
</code></pre> 
<h3><a id="redis_964"></a>安装redis</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 拉去镜像</span>
<span class="token function">docker</span> pull redis:6.0.8
<span class="token comment"># 查看镜像</span>
<span class="token function">docker</span> images

<span class="token comment"># 启动命令</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 redis:6.0.8
<span class="token comment"># docker ps</span>
<span class="token comment"># 后台启动</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> CONTAINER ID /bin/bash

<span class="token comment"># 在CentOS宿主机下新建目录/app/redis </span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /app/redis

<span class="token comment"># 将一个redis.conf文件模板拷贝进 /app/redis目录下</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /app/redis
<span class="token function">cp</span> /myredis/redis.conf  /app/redis/
<span class="token function">cp</span> /app/redis

<span class="token comment"># /app/redis 目录下修改redis.conf</span>
<span class="token comment"># 修改redis.conf文件 </span>
<span class="token number">1</span>. 开启redis验证   可选 
requirepass <span class="token number">123</span> 
<span class="token number">2</span>. 允许redis外地连接  必须 
<span class="token number">3</span>. 注释掉 <span class="token comment"># bind 127.0.0.1 </span>
<span class="token comment"># 注释daemonize no</span>
将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败
<span class="token comment"># 开启redis数据持久化</span>
appendonly <span class="token function">yes</span>  可选 


<span class="token comment"># 使用redis6.0.8 镜像创建容器(也叫运行镜像)</span>
<span class="token function">docker</span> run  <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 <span class="token parameter variable">--name</span> myr3 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /app/redis/redis.conf:/etc/redis/redis.conf <span class="token parameter variable">-v</span> /app/redis/data:/data <span class="token parameter variable">-d</span> redis:6.0.8 redis-server /etc/redis/redis.conf 
</code></pre> 
<h2><a id="docker_1001"></a>docker复杂安装</h2> 
<h3><a id="mysql_1002"></a>安装mysql主从复制</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 新建主服务器容器实例3307</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">3307</span>:3306 <span class="token parameter variable">--name</span> mysql-master <span class="token punctuation">\</span> 
<span class="token parameter variable">-v</span> /mydata/mysql-master/log:/var/log/mysql <span class="token punctuation">\</span> 
<span class="token parameter variable">-v</span> /mydata/mysql-master/data:/var/lib/mysql <span class="token punctuation">\</span> 
<span class="token parameter variable">-v</span> /mydata/mysql-master/conf:/etc/mysql <span class="token punctuation">\</span> 
<span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root  <span class="token punctuation">\</span> 
<span class="token parameter variable">-d</span> mysql:5.7 

<span class="token comment"># 进入/mydata/mysql-master/conf目录下新建my.cnf</span>
<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span> 
<span class="token comment">## 设置server_id，同一局域网中需要唯一 </span>
<span class="token assign-left variable">server_id</span><span class="token operator">=</span><span class="token number">101</span>  
<span class="token comment">## 指定不需要同步的数据库名称 </span>
binlog-ignore-db<span class="token operator">=</span>mysql   
<span class="token comment">## 开启二进制日志功能 </span>
log-bin<span class="token operator">=</span>mall-mysql-bin   
<span class="token comment">## 设置二进制日志使用内存大小（事务） </span>
<span class="token assign-left variable">binlog_cache_size</span><span class="token operator">=</span>1M   
<span class="token comment">## 设置使用的二进制日志格式（mixed,statement,row） </span>
<span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>mixed   
<span class="token comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。 </span>
<span class="token assign-left variable">expire_logs_days</span><span class="token operator">=</span><span class="token number">7</span>   
<span class="token comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 </span>
<span class="token comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 </span>
<span class="token assign-left variable">slave_skip_errors</span><span class="token operator">=</span><span class="token number">1062</span> 
<span class="token comment">## 设置utf8</span>
collation_server <span class="token operator">=</span> utf8_general_ci 
<span class="token comment">## 设置server字符集</span>
character_set_server <span class="token operator">=</span> utf8 
<span class="token punctuation">[</span>client<span class="token punctuation">]</span>
<span class="token assign-left variable">default_character_set</span><span class="token operator">=</span>utf8 

<span class="token comment"># 修改完配置后重启master实例</span>
<span class="token function">docker</span> restart mysql-master

<span class="token comment"># 进入mysql-master容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysql-master /bin/bash
mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-proot</span>

<span class="token comment"># maser容器实例内创建数据同步用户</span>
<span class="token comment"># 创建同步用户</span>
CREATE <span class="token environment constant">USER</span> <span class="token string">'slave'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'123456'</span><span class="token punctuation">;</span>
<span class="token comment"># 同步用户授权</span>
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="token string">'slave'</span>@<span class="token string">'%'</span><span class="token punctuation">;</span>

<span class="token comment"># 新建从服务容器实例3308</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">3308</span>:3306 <span class="token parameter variable">--name</span> mysql-slave <span class="token punctuation">\</span> 
<span class="token parameter variable">-v</span> /mydata/mysql-slave/log:/var/log/mysql <span class="token punctuation">\</span> 
<span class="token parameter variable">-v</span> /mydata/mysql-slave/data:/var/lib/mysql <span class="token punctuation">\</span> 
<span class="token parameter variable">-v</span> /mydata/mysql-slave/conf:/etc/mysql <span class="token punctuation">\</span> 
<span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root  <span class="token punctuation">\</span> 
<span class="token parameter variable">-d</span> mysql:5.7 

<span class="token comment"># 进入/mydata/mysql-slave/conf目录下新建my.cnf</span>
<span class="token comment"># 添加配置文件</span>
<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span> 
<span class="token comment">## 设置server_id，同一局域网中需要唯一 </span>
<span class="token assign-left variable">server_id</span><span class="token operator">=</span><span class="token number">102</span> 
<span class="token comment">## 指定不需要同步的数据库名称 </span>
binlog-ignore-db<span class="token operator">=</span>mysql   
<span class="token comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用 </span>
log-bin<span class="token operator">=</span>mall-mysql-slave1-bin   
<span class="token comment">## 设置二进制日志使用内存大小（事务） </span>
<span class="token assign-left variable">binlog_cache_size</span><span class="token operator">=</span>1M   
<span class="token comment">## 设置使用的二进制日志格式（mixed,statement,row） </span>
<span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>mixed   
<span class="token comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。 </span>
<span class="token assign-left variable">expire_logs_days</span><span class="token operator">=</span><span class="token number">7</span>   
<span class="token comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 </span>
<span class="token comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 </span>
<span class="token assign-left variable">slave_skip_errors</span><span class="token operator">=</span><span class="token number">1062</span>   
<span class="token comment">## relay_log配置中继日志 </span>
<span class="token assign-left variable">relay_log</span><span class="token operator">=</span>mall-mysql-relay-bin   
<span class="token comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志 </span>
<span class="token assign-left variable">log_slave_updates</span><span class="token operator">=</span><span class="token number">1</span>   
<span class="token comment">## slave设置为只读（具有super权限的用户除外） </span>
<span class="token assign-left variable">read_only</span><span class="token operator">=</span><span class="token number">1</span> 
<span class="token comment">## 设置utf8</span>
collation_server <span class="token operator">=</span> utf8_general_ci 
<span class="token comment">## 设置server字符集</span>
character_set_server <span class="token operator">=</span> utf8 
<span class="token punctuation">[</span>client<span class="token punctuation">]</span>
<span class="token assign-left variable">default_character_set</span><span class="token operator">=</span>utf8 

<span class="token comment"># 修改完配置后重启slave实例</span>
<span class="token function">docker</span> restart mysql-slave

<span class="token comment"># 在主数据库中查看主从同步状态</span>
show master status<span class="token punctuation">;</span>

<span class="token comment"># 进入mysql-slave容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysql-slave /bin/bash
mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-proot</span>

<span class="token comment"># 在从数据库中配置主从复制</span>
change master to <span class="token assign-left variable">master_host</span><span class="token operator">=</span><span class="token string">'宿主机ip'</span>, <span class="token assign-left variable">master_user</span><span class="token operator">=</span><span class="token string">'slave'</span>, <span class="token assign-left variable">master_password</span><span class="token operator">=</span><span class="token string">'123456'</span>, <span class="token assign-left variable">master_port</span><span class="token operator">=</span><span class="token number">3307</span>, <span class="token assign-left variable">master_log_file</span><span class="token operator">=</span><span class="token string">'mall-mysql-bin.000001'</span>, <span class="token assign-left variable">master_log_pos</span><span class="token operator">=</span><span class="token number">617</span>, <span class="token assign-left variable">master_connect_retry</span><span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">;</span> 
</code></pre> 
<p><img src="https://images2.imgbox.com/39/ef/70dIUKsg_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token comment"># 在从数据库中查看主从同步状态</span>
show slave status<span class="token punctuation">\</span>G<span class="token punctuation">;</span>

<span class="token comment"># 在从数据库中开启主从同步</span>
start slave<span class="token punctuation">;</span>
<span class="token comment"># 查看从数据库状态发现已经同步</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4e/fc/kGoYgn4x_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="rediscluster_1113"></a>安装redis集群(cluster)</h3> 
<ol><li>关闭防火墙+启动docker后台服务</li></ol> 
<pre><code class="prism language-bash">systemctl start <span class="token function">docker</span>
</code></pre> 
<ol start="2"><li>新建6个docker容器redis实例</li></ol> 
<pre><code class="prism language-shell"><span class="token comment"># 创建并运行docker容器实例</span>
<span class="token function">docker</span> run 
<span class="token comment"># 容器名字</span>
<span class="token parameter variable">--name</span> redis-node-6
<span class="token comment"># 使用宿主机的IP和端口，默认</span>
<span class="token parameter variable">--net</span> <span class="token function">host</span>
<span class="token comment"># 获取宿主机root用户权限</span>
<span class="token parameter variable">--privileged</span><span class="token operator">=</span>true
<span class="token comment"># 容器卷，宿主机地址:docker内部地址</span>
<span class="token parameter variable">-v</span> /data/redis/share/redis-node-6:/data
<span class="token comment"># redis镜像和版本号</span>
redis:6.0.8
<span class="token comment"># 开启redis集群</span>
--cluster-enabled <span class="token function">yes</span> 
<span class="token comment"># 开启持久化</span>
<span class="token parameter variable">--applendonly</span> <span class="token function">yes</span> 
</code></pre> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-1 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6381</span> 

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-2 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6382</span> 

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-3 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6383</span> 

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-4 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6384</span> 

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-5 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6385</span> 

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-6 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6386</span> 
</code></pre> 
<ol start="3"><li>进入容器redis-node-1并为6台机器构建集群关系</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 进入容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-node-1 /bin/bash
<span class="token comment"># 注意，进入docker容器后才能执行一下命令，且注意自己的真实IP地址 </span>
redis-cli <span class="token parameter variable">--cluster</span> create <span class="token number">192.168</span>.111.147:6381 <span class="token number">192.168</span>.111.147:6382 <span class="token number">192.168</span>.111.147:6383 <span class="token number">192.168</span>.111.147:6384 <span class="token number">192.168</span>.111.147:6385 <span class="token number">192.168</span>.111.147:6386 --cluster-replicas <span class="token number">1</span> 
<span class="token comment"># --cluster-replicas 1 表示为每个master创建一个slave节点 </span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0d/e4/y0XggL8T_o.png" alt="在这里插入图片描述"><br> 4. 连接进入6318作为切入点，查看集群状态<br> <img src="https://images2.imgbox.com/5f/f3/xUbiyvH4_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">redis<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> cluster info

redis<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> cluster nodes
</code></pre> 
<h4><a id="_1168"></a>主从容错切换迁移案例</h4> 
<ol><li>数据读写存储</li></ol> 
<pre><code class="prism language-bash">redis-cli <span class="token parameter variable">-p</span> <span class="token number">6381</span> <span class="token parameter variable">-c</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8e/9b/XSqzxIbE_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>查看集群信息</li></ol> 
<pre><code class="prism language-bash">redis-cli <span class="token parameter variable">--cluster</span> check <span class="token number">192.168</span>.111.147:6381 
</code></pre> 
<p><img src="https://images2.imgbox.com/10/6a/fhkiEsgk_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/bd/83/Is352Hjm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_1184"></a>容错切换迁移</h4> 
<ol><li>主6381和从机切换，先停止主机6381</li></ol> 
<pre><code class="prism language-bash"><span class="token number">6381</span>主机停了，对应的真实从机上位
<span class="token number">6381</span>作为1号主机分配的从机以实际情况为准，具体是几号机器就是几号
</code></pre> 
<ol start="2"><li>再次查看集群信息，6381宕机了，6385上位成为了新的master。<br> <img src="https://images2.imgbox.com/23/31/yTqTFyz2_o.png" alt="在这里插入图片描述"></li><li>先还原之前的3主3从</li></ol> 
<pre><code class="prism language-bash"><span class="token comment"># 先启6381</span>
<span class="token function">docker</span> start redis-node-1
<span class="token comment"># 再停6385 </span>
<span class="token function">docker</span> stop redis-node-5
<span class="token comment"># 再起6385</span>
<span class="token function">docker</span> start redis-node-5
主从机器分配情况一实际情况为准
</code></pre> 
<ol start="4"><li>查看集群状态</li></ol> 
<pre><code class="prism language-bash">redis-cli <span class="token parameter variable">--cluster</span> check 自己IP:6381
</code></pre> 
<h4><a id="_1209"></a>主从扩容案例</h4> 
<ol><li>新建6387、6388两个节点+新建后启动+查看是否8节点</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-7 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6387</span> 

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> redis-node-8 <span class="token parameter variable">--net</span> <span class="token function">host</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> <span class="token parameter variable">--appendonly</span> <span class="token function">yes</span> <span class="token parameter variable">--port</span> <span class="token number">6388</span> 

<span class="token function">docker</span> <span class="token function">ps</span> 
</code></pre> 
<ol start="2"><li>进入6387容器实例内部</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-node-7 /bin/bash
</code></pre> 
<ol start="3"><li>将新增的6387节点(空槽号)作为master节点加入原集群</li></ol> 
<pre><code class="prism language-bash">将新增的6387作为master节点加入集群
redis-cli <span class="token parameter variable">--cluster</span>  add-node  自己实际IP地址: <span class="token number">6387</span>  自己实际IP地址: <span class="token number">6381</span> 
<span class="token number">6387</span> 就是将要作为master新增节点 
<span class="token number">6381</span> 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群 
</code></pre> 
<ol start="4"><li>检查集群情况第1次</li></ol> 
<pre><code class="prism language-bash">redis-cli <span class="token parameter variable">--cluster</span> check 真实ip地址:6381 
<span class="token comment"># 例如</span>
redis-cli <span class="token parameter variable">--cluster</span> check <span class="token number">192.168</span>.111.147:6381 
</code></pre> 
<ol start="5"><li>重新分派槽号</li></ol> 
<pre><code class="prism language-bash">重新分派槽号
命令:redis-cli <span class="token parameter variable">--cluster</span>  reshard  IP地址:端口号 
redis-cli <span class="token parameter variable">--cluster</span> reshard <span class="token number">192.168</span>.111.147:6381 
</code></pre> 
<ol start="6"><li>检查集群情况第2次</li></ol> 
<pre><code class="prism language-bash">redis-cli <span class="token parameter variable">--cluster</span> check 真实ip地址:6381 

为什么6387是3个新的区间，以前的还是连续？
重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387 
</code></pre> 
<ol start="7"><li>为主节点6387分配从节点6388</li></ol> 
<pre><code class="prism language-bash">命令：redis-cli  <span class="token parameter variable">--cluster</span> add-node  ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID

redis-cli <span class="token parameter variable">--cluster</span> add-node <span class="token number">192.168</span>.111.147:6388 <span class="token number">192.168</span>.111.147:6387 --cluster-slave --cluster-master-id e4781f644d4a4e4d4b4d107157b9ba8144631451-------这个是6387的编号，按照自己实际情况 
</code></pre> 
<ol start="8"><li>检查集群情况第3次</li></ol> 
<pre><code class="prism language-bash">redis-cli <span class="token parameter variable">--cluster</span> check <span class="token number">192.168</span>.111.147:6382 
</code></pre> 
<h2><a id="DockerFilehttpsdocsdockercomenginereferencebuilder_1266"></a><a href="https://docs.docker.com/engine/reference/builder/" rel="nofollow">DockerFile</a>解析</h2> 
<h3><a id="DockerFile_1267"></a>DockerFile是什么</h3> 
<p>DockerFile是用来构建Docker镜像的文本文件，是有一条条构建镜像所需的指令和参数构成的脚本。</p> 
<p><img src="https://images2.imgbox.com/24/e7/cUsoCW0p_o.png" alt="在这里插入图片描述"><br> 构建三步骤：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>、编写DockerFile文件
<span class="token number">2</span>、docker build命令构建镜像
<span class="token number">3</span>、docker run 依镜像运行容器实例
</code></pre> 
<h3><a id="DockerFile_1278"></a>DockerFile构建过程解析</h3> 
<h4><a id="DockerFile_1279"></a>DockerFile内容基础知识</h4> 
<pre><code class="prism language-bash"><span class="token number">1</span>. 每条保留字指令都必须为大写字母且后面跟随至少一个参数
<span class="token number">2</span>. 指令按照从上到下，顺序执行
<span class="token number">3</span>. <span class="token comment">#表示注释</span>
<span class="token number">4</span>. 每条指令都会创建一个新的镜像层并对镜像进行提交。
</code></pre> 
<h4><a id="DockerDockerFile_1287"></a>Docker执行DockerFile的大致流程</h4> 
<pre><code class="prism language-bash"><span class="token number">1</span>. docker从技术镜像运行一个容器
<span class="token number">2</span>. 执行一条指令比鞥对容器做出修改
<span class="token number">3</span>. 执行类似docker commit 的操作提交一个新的镜像层
<span class="token number">4</span>. <span class="token function">docker</span> 在基于刚提交的镜像运行一个新容器
<span class="token number">5</span>. 执行dockerfile中的下一条指令直到所有执行执行完成。
</code></pre> 
<h4><a id="_1296"></a>小总结</h4> 
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p> 
<p>Dockerfile是软件的原材料</p> 
<p>Docker镜像是软件的交付品</p> 
<p>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</p> 
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p> 
<p><img src="https://images2.imgbox.com/ad/39/8N00F01W_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p> </li><li> <p>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</p> </li><li> <p>Docker容器，容器是直接提供服务的。</p> </li></ol> 
<h4><a id="DockerFile_1314"></a>DockerFile常用保留字指令</h4> 
<ol><li>参考tomcat8的dockerfile入门</li></ol> 
<p><a href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p> 
<ol start="2"><li>From</li></ol> 
<pre><code class="prism language-bash">基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from
</code></pre> 
<ol start="3"><li>MANINTAINER</li></ol> 
<p>镜像维护者的姓名和邮箱地址</p> 
<ol start="4"><li>Run</li></ol> 
<p>容器构建时需要运行的命令</p> 
<p>两种格式：</p> 
<p>shell格式</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>命令行命令<span class="token operator">&gt;</span>等同于，在终端操作的shell命令
</code></pre> 
<p>exec格式<br> <img src="https://images2.imgbox.com/c6/96/UAYJY1nU_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Qcg8eINY-1677065040444)(images/26.png)]"><br> RUN是在docker build时运行</p> 
<ol start="5"><li>EXPOSE</li></ol> 
<p>当前容器对外暴露出的端口</p> 
<ol start="6"><li>WORKDIR</li></ol> 
<p>指定在创建容器后。终端默认登录的进来工作目录，一个落脚点。</p> 
<ol start="7"><li>USER</li></ol> 
<p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p> 
<ol start="8"><li>ENV</li></ol> 
<p>用来在构建镜像过程中设置环境变量</p> 
<pre><code class="prism language-bash">ENV MY_PATH /usr/mytest 
这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样； 
也可以在其它指令中直接使用这些环境变量， 

比如：WORKDIR <span class="token variable">$MY_PATH</span> 
</code></pre> 
<ol start="9"><li>ADD</li></ol> 
<p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p> 
<ol start="10"><li>COPY</li></ol> 
<p>类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层镜像内的&lt;目标路径&gt;位置</p> 
<pre><code class="prism language-bash">COPY src dest

COPY<span class="token punctuation">[</span><span class="token string">"src"</span>,<span class="token string">"dest"</span><span class="token punctuation">]</span>

<span class="token operator">&lt;</span>src源路径<span class="token operator">&gt;</span>：源文件或源目录

<span class="token operator">&lt;</span>dest目标路径<span class="token operator">&gt;</span>: 容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。
</code></pre> 
<ol start="11"><li>VOLUME</li></ol> 
<p>容器数据卷，用于数据保存和持久化的工作</p> 
<ol start="12"><li>CMD</li></ol> 
<p>指定容器启动后的要干的事情。</p> 
<p>【注意】</p> 
<pre><code class="prism language-bash">Dockerfile 中可以由多个CMD指令，但是只有最后一个生效，CMD会被docker run 之后的参数替换。
</code></pre> 
<p>参考官网Tomcat的dockerfile演示讲解</p> 
<p>官网最后一行命令</p> 
<pre><code class="prism language-bash">EXPOSE <span class="token number">8080</span>
   CMD <span class="token punctuation">[</span><span class="token string">"catalina.sh"</span>,<span class="token string">"run"</span><span class="token punctuation">]</span>
</code></pre> 
<p>我们演示自己的覆盖操作</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080  容器ID /bin/bash
</code></pre> 
<p>他和前面RUN命令的区别</p> 
<pre><code class="prism language-bash">CMD 是在 <span class="token function">docker</span> run 时运行。

RUN 是在docker build 时运行
</code></pre> 
<ol start="13"><li> <p>ENTRYPOINT</p> </li><li> <p>也是用来指定一个容器启动时要运行的命令</p> </li><li> <p>类似于CMD指令，但是ENTRYPOINT不会被docker run 后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。</p> </li><li> <p>命令格式和案例说明</p> </li></ol> 
<pre><code class="prism language-bash">命令格式：ENTRYPOINT<span class="token punctuation">[</span><span class="token string">"&lt;executeable&gt;"</span>,<span class="token string">"&lt;param1&gt;"</span>,<span class="token string">"&lt;param2&gt;"</span>,<span class="token punctuation">..</span>.<span class="token punctuation">]</span>

ENTRYPOINT 可以和CMD一起用，一般是 变参 才会使用 CMD ，这里的CMD等于是在给 ENTRYPOINT 传参。当制定了 ENTRYPOINT 后，CMD的含义就发生了变化，不再是直接运行其命令而是将 CMD 的内容作为参数传递给 ENTRYPOINT 指定，他两个组合会变成<span class="token operator">&lt;</span>ENTRYPOINT<span class="token operator">&gt;</span> <span class="token string">"&lt;CMD&gt;"</span>
案例如下：假设已通过 Dockerfile 构建了 nginx:test 镜像
</code></pre> 
<p><img src="https://images2.imgbox.com/de/05/Pdypj949_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a9/5f/aGqREFOO_o.png" alt="在这里插入图片描述"></p> 
<p>优点：在执行docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p> 
<p>注意：如果Dockerfile 中如果存在多个 ENTRYPOINT 指令，进最后一个生效。</p> 
<h4><a id="_1445"></a>小总结</h4> 
<p><img src="https://images2.imgbox.com/34/07/2RBREswY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="mycentosjava8_1447"></a>自定义镜像mycentosjava8</h4> 
<h5><a id="_1448"></a>目标</h5> 
<p><code>Centos7镜像具备 vim + ifconfig + jdk8</code></p> 
<h5><a id="_1451"></a>编写</h5> 
<pre><code class="prism language-bash"><span class="token comment"># 创建DockerFile</span>
<span class="token function">vim</span> Dockerfile

FROM centos
MAINTAINER zzyy<span class="token operator">&lt;</span>zzyybs@126.com<span class="token operator">&gt;</span> 
  
ENV MYPATH /usr/local 
WORKDIR <span class="token variable">$MYPATH</span> 
  
<span class="token comment">#安装vim编辑器 </span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span> 
<span class="token comment">#安装ifconfig命令查看网络IP </span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> net-tools 
<span class="token comment">#安装java8及lib库 </span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> glibc.i686 
RUN <span class="token function">mkdir</span> /usr/local/java 
<span class="token comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置 </span>
ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/ 
<span class="token comment">#配置java环境变量 </span>
ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 
ENV JRE_HOME <span class="token variable">$JAVA_HOME</span>/jre 
ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar:<span class="token variable">$JRE_HOME</span>/lib:<span class="token variable">$CLASSPATH</span> 
ENV <span class="token environment constant">PATH</span> <span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span> 
  
EXPOSE <span class="token number">80</span> 
 
CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span> 
CMD <span class="token builtin class-name">echo</span> <span class="token string">"success--------------ok"</span> 
CMD /bin/bash 
</code></pre> 
<h5><a id="_1484"></a>构建</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> 新镜像名字: TAG

例如：docker build <span class="token parameter variable">-t</span> centosjava8:1.5 <span class="token builtin class-name">.</span>

【注意】
上面TAG 后面有个空格，有个点
</code></pre> 
<h5><a id="_1494"></a>运行</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> 新镜像名字:TAG

<span class="token function">docker</span> run <span class="token parameter variable">-it</span> centosjava8:1.5 /bin/bash 
</code></pre> 
<h4><a id="_1501"></a>虚悬镜像</h4> 
<p>仓库名，标签都是 <code>&lt;none&gt;</code> 的镜像，俗称<code>dangling image</code></p> 
<p>Dockerfile：</p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> Dockerfile

from ubuntu
CMD <span class="token builtin class-name">echo</span> <span class="token string">" hello world "</span>
</code></pre> 
<p>构建：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> build <span class="token builtin class-name">.</span>
</code></pre> 
<p>查看：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> image <span class="token function">ls</span> <span class="token parameter variable">-f</span> <span class="token assign-left variable">dangling</span><span class="token operator">=</span>true
命令结果如下图：
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/99/54cOUwXu_o.png" alt="在这里插入图片描述"><br> 删除：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> image prune 

虚悬镜像已经市区存在价值，可以删除
</code></pre> 
<h4><a id="myubuntu_1531"></a>家庭作业自定义myubuntu</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 编写</span>
准备编写DockerFile文件
<span class="token function">vim</span> Dockerfile
----------------------
FROM ubuntu
MAINTAINER zzyy<span class="token operator">&lt;</span>zzyybs@126.com<span class="token operator">&gt;</span> 
  
ENV MYPATH /usr/local 
WORKDIR <span class="token variable">$MYPATH</span> 
  
RUN <span class="token function">apt-get</span> update 
RUN <span class="token function">apt-get</span> <span class="token function">install</span> net-tools 
<span class="token comment">#RUN apt-get install -y iproute2 </span>
<span class="token comment">#RUN apt-get install -y inetutils-ping </span>
  
EXPOSE <span class="token number">80</span> 
  
CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span> 
CMD <span class="token builtin class-name">echo</span> <span class="token string">"install inconfig cmd into ubuntu success--------------ok"</span> 
CMD /bin/bash 
------------------------
<span class="token comment"># 构建</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> 新镜像名字:TAG

<span class="token comment">#运行</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> 新镜像名字:TAG
</code></pre> 
<h2><a id="Docker_1561"></a>Docker网络</h2> 
<p><img src="https://images2.imgbox.com/a4/e0/iwcLqJv3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Docker__1563"></a>Docker 网络是什么</h3> 
<h4><a id="docker_1564"></a>docker不启动，默认网络情况</h4> 
<pre><code class="prism language-bash">ens <span class="token number">33</span>
lo
virbr0
</code></pre> 
<p><img src="https://images2.imgbox.com/c2/dc/cxiz9qa1_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">在CentOS7的安装过程中如果有 选择相关虚拟化的的服务安装系统后 ，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡<span class="token punctuation">(</span>virbr0网卡：它还有一个固定的默认IP地址192.168.122.1<span class="token punctuation">)</span>，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。 
  
我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载， 
yum remove libvirt-libs.x86_64 
</code></pre> 
<h4><a id="docker_1578"></a>docker启动后，网络情况</h4> 
<p>查看docker网络模式命令：<br> <img src="https://images2.imgbox.com/fe/66/3HFZhG0y_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_1581"></a>常用基本命令</h4> 
<h5><a id="All__1582"></a>All 命令</h5> 
<p><img src="https://images2.imgbox.com/43/a1/2YQYntmP_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="docker_network_ls_1584"></a>docker network ls查看网络</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> network <span class="token function">ls</span>

NETWORK ID     NAME      DRIVER    SCOPE
a70a0235a0a6   bridge    bridge    <span class="token builtin class-name">local</span>
506e19d542b9   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>
89a9b3fbb5d7   none      null      <span class="token builtin class-name">local</span>
</code></pre> 
<h5><a id="_1594"></a>查看网络源数据</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> network inspect  XXX网络名字
</code></pre> 
<h5><a id="_1599"></a>删除网络</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> network <span class="token function">rm</span> XXX网络名字
</code></pre> 
<h5><a id="_1605"></a>创建网络</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> network create XXX网络名字
</code></pre> 
<p><img src="https://images2.imgbox.com/c5/0c/QR3kYD8g_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="docker_1612"></a>docker网络的作用（能干嘛）</h3> 
<ol><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li></ol> 
<h3><a id="docker_1616"></a>docker网络模式</h3> 
<h4><a id="_1617"></a>总体介绍</h4> 
<pre><code class="prism language-bash">bridge模式：使用--network bridge指定，默认使用docker0

host模式：使用 <span class="token parameter variable">--network</span> host指定

none模式：使用 <span class="token parameter variable">--network</span> none指定

container模式：使用 <span class="token parameter variable">--network</span> container:Name或者容器ID指定
</code></pre> 
<h4><a id="IP_1627"></a>容器实例内默认网络IP生产规则</h4> 
<ol><li>先启动两个ubuntu容器实例<br> <img src="https://images2.imgbox.com/6c/33/8WTjzelQ_o.png" alt="在这里插入图片描述"></li><li><code>docker inspect 容器ID or 容器名字 </code></li></ol> 
<p><img src="https://images2.imgbox.com/01/37/cacl0XPB_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>关闭u2实例，新建u3，查看ip变化<br> <img src="https://images2.imgbox.com/cf/97/D3lTalzY_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="_1636"></a>案例说明</h4> 
<h5><a id="bridge_1637"></a>bridge模式</h5> 
<pre><code class="prism language-bash">Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口的IP 地址和子网掩码， 让主机和容器之间可以通过网桥相互通信。 
  
<span class="token comment"># 查看 bridge 网络的详细信息，并通过 grep 获取名称项 </span>
<span class="token function">docker</span> network inspect bridge <span class="token operator">|</span> <span class="token function">grep</span> name 

<span class="token function">ifconfig</span> 
</code></pre> 
<p><img src="https://images2.imgbox.com/96/dd/3Aa8AwbV_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_1648"></a>案例</h5> 
<pre><code class="prism language-bash"><span class="token number">1</span> Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥<span class="token punctuation">(</span>docker0<span class="token punctuation">)</span>，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。 
 
<span class="token number">2</span> <span class="token function">docker</span> run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0 。在宿主机ifconfig,就可以看到docker0和自己create的network<span class="token punctuation">(</span>后面讲<span class="token punctuation">)</span>eth0，eth1，eth2……代表网卡一，网卡二，网卡三…… ，lo代表127.0.0.1，即localhost ，inet addr用来表示网卡的IP地址 
 
<span class="token number">3</span> 网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。 
   <span class="token number">3.1</span> 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）； 
   <span class="token number">3.2</span> 每个容器实例内部也有一块网卡，每个接口叫eth0； 
   <span class="token number">3.3</span> docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。 
 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。 
</code></pre> 
<p><img src="https://images2.imgbox.com/44/9b/l40BKMxR_o.png" alt="在这里插入图片描述"><br> 【代码】</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080   <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080   <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8
</code></pre> 
<h5><a id="_1668"></a>两两匹配验证</h5> 
<p><img src="https://images2.imgbox.com/25/29/FiTe16g0_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Host_1670"></a>Host模式</h5> 
<h6><a id="_1671"></a>是什么</h6> 
<p>直接使用宿主机的IP地址与外界进行通信，不再需要额外进行NAT转换。</p> 
<h6><a id="_1674"></a>案例</h6> 
<ol><li>说明</li></ol> 
<p>容器将 不会获得 一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。 容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p> 
<ol start="2"><li>代码</li></ol> 
<pre><code class="prism language-bash">警告：
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8083</span>:8080 <span class="token parameter variable">--network</span> <span class="token function">host</span> <span class="token parameter variable">--name</span> tomcat83 billygoo/tomcat8-jdk8

正确：
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--network</span> <span class="token function">host</span> <span class="token parameter variable">--name</span> tomcat83 billygoo/tomcat8-jdk8
</code></pre> 
<ol start="3"><li>无之前的配对显示了，看容器实例内部<br> <img src="https://images2.imgbox.com/b7/d5/wGXTdqZQ_o.png" alt="在这里插入图片描述"></li><li>没有设置-p的端口映射了，如何访问启动的tomcat83？</li></ol> 
<pre><code class="prism language-bash">http://宿主机IP:8080/ 

在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的， 
所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。
</code></pre> 
<h5><a id="none_1699"></a>none模式</h5> 
<h6><a id="_1700"></a>是什么</h6> 
<p>禁用网络功能，只有lo标识（就是127.0.0.1表示本地回环）</p> 
<h6><a id="_1702"></a>案例</h6> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p8084:8080</span> <span class="token parameter variable">--network</span> none <span class="token parameter variable">--name</span> tomcat84 billygoo/tomcat8-jdk8
</code></pre> 
<h5><a id="container_1708"></a>container模式</h5> 
<h6><a id="_1709"></a>是什么</h6> 
<p>container⽹络模式</p> 
<p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p> 
<h6><a id="_1715"></a>案例</h6> 
<p>❎案例1</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8085</span>:8080  <span class="token parameter variable">--name</span> tomcat85 billygoo/tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8086</span>:8080 <span class="token parameter variable">--network</span> container:tomcat85 <span class="token parameter variable">--name</span> tomcat86 billygoo/tomcat8-jdk8

运行结果

docker：Error response from daemon: conflicting optisons: port <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.

<span class="token comment"># 相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突 </span>
</code></pre> 
<p>✅案例2</p> 
<pre><code class="prism language-bash">Alpine操作系统是一个面向安全的轻型 Linux发行版

<span class="token function">docker</span> run <span class="token parameter variable">-it</span>  <span class="token parameter variable">--name</span> alpine1  alpine /bin/sh

<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--network</span> container:alpine1 <span class="token parameter variable">--name</span> alpine2  alpine /bin/sh
</code></pre> 
<p>运行结果，验证共用搭桥：<br> <img src="https://images2.imgbox.com/1b/b6/BeErdylk_o.png" alt="在这里插入图片描述"><br> 假如此时关闭alpine1，再看看alpine2：<br> <img src="https://images2.imgbox.com/c7/ee/7eWnXxfr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_1742"></a>自定义网络</h5> 
<h6><a id="_1743"></a>案例</h6> 
<p>【before】</p> 
<pre><code class="prism language-bash">案例：
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080   <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080   <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8

上述成功启动并用docker exec进入各自容器实例内部
问题：
<span class="token number">1</span>. 按照IP地址ping是OK的
<span class="token number">2</span>. 按照服务名ping结果???
	ping： tocmat82：Name or <span class="token function">service</span> not known
</code></pre> 
<p>【after】</p> 
<pre><code class="prism language-bash">案例
自定义桥接网络,自定义网络默认使用的是桥接网络bridge
</code></pre> 
<p>新建自定义网络：</p> 
<p><img src="https://images2.imgbox.com/3c/df/GhzGMzqo_o.png" alt="在这里插入图片描述"><br> 新建容器加入上一步新建的自定义网络：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--network</span> zzyy_network  <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--network</span> zzyy_network  <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8
</code></pre> 
<p>互相ping测试，</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>、自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）
<span class="token number">2</span>、自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）
<span class="token number">3</span>、自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）
</code></pre> 
<h2><a id="Docker_1782"></a>Docker平台架构图解</h2> 
<pre><code class="prism language-bash">从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。  
  
Docker 运行的基本流程为： 
  
<span class="token number">1</span> 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。 
<span class="token number">2</span> Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。 
<span class="token number">3</span> Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。 
<span class="token number">4</span> Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。 
<span class="token number">5</span> 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。 
<span class="token number">6</span> 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。 
<span class="token number">7</span> Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。
</code></pre> 
<p><img src="https://images2.imgbox.com/8d/5b/bo5IsjAm_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="DockerPortainer_1798"></a>Docker轻量级可视化工具Portainer</h2> 
<h3><a id="docker_1799"></a>docker安装</h3> 
<ol><li>安装</li></ol> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8000</span>:8000 <span class="token parameter variable">-p</span> <span class="token number">9000</span>:9000 <span class="token parameter variable">--name</span> portainer     <span class="token parameter variable">--restart</span><span class="token operator">=</span>always     <span class="token parameter variable">-v</span> /var/run/docker.sock:/var/run/docker.sock     <span class="token parameter variable">-v</span> portainer_data:/data     portainer/portainer 
</code></pre> 
<p>2/ 第一次登录需创建admin，访问地址：xxx.xxx.xxx.xxx:9000</p> 
<pre><code class="prism language-bash">用户名，直接用默认admin 
密码记得8位，随便你写 
</code></pre> 
<ol start="3"><li>设置admin用户和密码后首次登陆</li><li>选择<code>local选项卡</code>后本地docker详细信息展示</li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba095cbc45442b1c8920b189190b3ed3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python的包管理器pip安装经常失败的解决办法：修改pip镜像源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53f28f47316d057ec35eaae201054ef1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">线程交替执行经典问题(生产者和消费者问题）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>