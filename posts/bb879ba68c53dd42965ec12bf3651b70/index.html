<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt布局管理（布局控件） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt布局管理（布局控件）" />
<meta property="og:description" content="实际开发中，一个界面上可能包含十几个控件，手动调整它们的位置既费时又费力。作为一款成熟的 GUI 框架，Qt 提供了很多摆放控件的辅助工具（又称布局管理器或者布局控件），它们可以完成两件事：
自动调整控件的位置，包括控件之间的间距、对齐等；
当用户调整窗口大小时，位于布局管理器内的控件也会随之调整大小，从而保持整个界面的美观。
总之借助布局管理器，我们无需再逐个调整控件的位置和大小，可以将更多的精力放在软件功能的实现上。
Qt 共提供了 5 种布局管理器，每种布局管理器对应一个类，分别是 QVBoxLayout（垂直布局）、QHBoxLayout（水平布局）、QGridLayout（网格布局）、QFormLayout（表单布局）和 QStackedLayout（分组布局），它们的继承关系如下图所示：
图 1 各个布局管理类的继承关系
QVBoxLayout垂直布局 垂直布局指的是将所有控件从上到下（或者从下到上）依次摆放，例如：
图 2 QVBoxLayout垂直布局
图 2 展示了 4 个 QPushButton 按钮利用 QVBoxLayout 垂直布局的效果。实际场景中，QVBoxLayout 中还可以放置其它控件，比如 QLabel 文本框、QLineEdit 单行输入框等。
程序中使用 QVBoxLayout 布局控件，需提前引入&lt;QVBoxLayout&gt;头文件。每个 QVBoxLayout 控件本质都是 QVBoxLayout 类的实例对象，该类提供了两个构造函数，分别是：
QVBoxLayout() QVBoxLayout(QWidget *parent) 创建 QVBoxLayout 控件的同时可以指定父窗口，那么它将作为父窗口中管理其它控件的工具；也可以暂时不指定父窗口，待全部设置完毕后再将其添加到某个窗口中。
QVBoxLayout 类没有新增任何成员方法，它只能使用从父类继承的成员方法，下表给大家罗列了常用的一些：
表 1 QVBoxLayout常用方法
成员方法
功 能
void QBoxLayout::addWidget(QWidget *widget, int stretch = 0, Qt::Alignment alignment = Qt::Alignment())
向布局管理器中添加指定的 widget 控件。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/bb879ba68c53dd42965ec12bf3651b70/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T16:47:44+08:00" />
<meta property="article:modified_time" content="2023-04-21T16:47:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt布局管理（布局控件）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">实际开发中，一个界面上可能包含十几个控件，手动调整它们的位置既费时又费力。作为一款成熟的 GUI 框架，Qt 提供了很多摆放控件的辅助工具（又称布局管理器或者布局控件），它们可以完成两件事：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>自动调整控件的位置，包括控件之间的间距、对齐等；</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>当用户调整窗口大小时，位于布局管理器内的控件也会随之调整大小，从而保持整个界面的美观。</p></li></ul> 
 <p style=""></p> 
 <p style="">总之借助布局管理器，我们无需再逐个调整控件的位置和大小，可以将更多的精力放在软件功能的实现上。</p> 
 <p style=""></p> 
 <p style="">Qt 共提供了 5 种布局管理器，每种布局管理器对应一个类，分别是 QVBoxLayout（垂直布局）、QHBoxLayout（水平布局）、QGridLayout（网格布局）、QFormLayout（表单布局）和 QStackedLayout（分组布局），它们的继承关系如下图所示：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:53.91892%;height:0;"> 
    <img src="https://images2.imgbox.com/18/71/BnW3CRg1_o.gif" style="margin-left:;display:block;width:740px;margin-top:-53.91892%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;"><span class="kdocs-fontSize" style="font-size:9pt;">图 1 各个布局管理类的继承关系</span></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h3>QVBoxLayout垂直布局</h3></li></ol> 
 <p style="">垂直布局指的是将所有控件从上到下（或者从下到上）依次摆放，例如：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:407px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:59.45946%;height:0;"> 
    <img src="https://images2.imgbox.com/fd/89/cQbIyECX_o.gif" style="margin-left:;display:block;width:407px;margin-top:-59.45946%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 2 QVBoxLayout垂直布局</p> 
 <p style="">图 2 展示了 4 个 QPushButton 按钮利用 QVBoxLayout 垂直布局的效果。实际场景中，QVBoxLayout 中还可以放置其它控件，比如 QLabel 文本框、QLineEdit 单行输入框等。</p> 
 <p style=""></p> 
 <p style="">程序中使用 QVBoxLayout 布局控件，需提前引入&lt;QVBoxLayout&gt;头文件。每个 QVBoxLayout 控件本质都是 QVBoxLayout 类的实例对象，该类提供了两个构造函数，分别是：</p> 
 <blockquote class="kdocs-blockquote" style="">
   QVBoxLayout() QVBoxLayout(QWidget *parent) 
 </blockquote> 
 <p style="">创建 QVBoxLayout 控件的同时可以指定父窗口，那么它将作为父窗口中管理其它控件的工具；也可以暂时不指定父窗口，待全部设置完毕后再将其添加到某个窗口中。</p> 
 <p style=""></p> 
 <p style="">QVBoxLayout 类没有新增任何成员方法，它只能使用从父类继承的成员方法，下表给大家罗列了常用的一些：</p> 
 <p style=""></p> 
 <p style="text-align:center;">表 1 QVBoxLayout常用方法</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">成员方法</span></p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">功 能</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:52px;"><p style="">void QBoxLayout::addWidget(QWidget *widget, int stretch = 0, Qt::Alignment alignment = Qt::Alignment())</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:52px;"><p style="">向布局管理器中添加指定的 widget 控件。</p><p style=""></p><p style="">默认情况下，stretch 拉伸系数为 0，表示 widget 控件的尺寸为默认值；alignment 是一个枚举类型参数，默认值也是 0，表示该控件会填满占用的整个空间。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:154px;"><p style="">void QBoxLayout::addStretch(int stretch = 0)</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:154px;"><p style="">添加一个空白行，整个窗口中除了控件占用的区域外，其它区域可以由多个（≥0）空白行分摊，分摊比例取余于各个空白行设置的 stretch 参数的值。</p><p style=""></p><p style="">strech 参数的默认值为 0，表示当窗口很小时，空白行可以不占据窗口空间。当窗口中包含多个 strech 值为 0 的空白行时，它们会平分窗口中的空白区域。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:52px;"><p style="">void QBoxLayout::addSpacing(int size)</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:52px;"><p style="">添加一个 size 大小的固定间距。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:52px;"><p style="">void QLayout::setMargin(int margin)</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:52px;"><p style="">设置布局管理器中所有控件的外边距，上、下、左、右外边距的大小都为 margin。默认情况下，所有方向的外边距为 11 px。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:73px;"><p style="">void QLayout::setContentsMargins(int left, int top, int right, int bottom)</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:73px;"><p style="">设置布局管理器中所有控件的外边距，和 setMargin() 的区别是，此方法可以自定义上、下、左、右外边距的值。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:73px;"><p style="">void QBoxLayout::setDirection(Direction direction)</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:73px;"><p style="">设置布局管理器中控件的布局方向，Direction 是一个枚举类型，对于 QVBoxLayout 布局管理器，direction 参数的值通常选择 QBoxLayout::TopToBottom（从上到下依次摆放）或者 QBoxLayout::BottomToTop（从下到上依次摆放）。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:73px;"><p style="">bool QBoxLayout::setStretchFactor(QWidget *widget, int stretch)</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:73px;"><p style="">设置布局管理器中某个控件的拉伸系数。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:451px;vertical-align:top;height:73px;"><p style="">bool QBoxLayout::setStretchFactor(QLayout *layout, int stretch)</p></td><td class="kdocs-tableCell" style="width:603px;vertical-align:top;height:73px;"><p style="">布局管理器内部可以再放置一个布局管理器，该方法用来设置内部某个布局管理器的拉伸系数。</p></td></tr></tbody></table> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">举个简单的例子：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QLabel&gt;
#include &lt;QVBoxLayout&gt;
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    //创建主窗口
    QWidget widget;
    widget.setWindowTitle("QVBoxLayout垂直布局");
    //创建垂直布局管理器
    QVBoxLayout *layout=new QVBoxLayout;
    //设置布局管理器中所有控件从下往上依次排列
    layout-&gt;setDirection(QBoxLayout::BottomToTop);
   
    //连续创建 3 个文本框，并设置它们的背景和字体大小
    QLabel lab1("Label1");
    lab1.setStyleSheet("QLabel{background:#dddddd;font:20px;}");
    lab1.setAlignment(Qt::AlignCenter);
    QLabel lab2("Label2");
    lab2.setStyleSheet("QLabel{background:#cccccc;font:20px;}");
    lab2.setAlignment(Qt::AlignCenter);
    QLabel lab3("Label3");
    lab3.setStyleSheet("QLabel{background:#ffffff;font:20px;}");
    lab3.setAlignment(Qt::AlignCenter);
   
    //将 3 个文本框和 2 个空白行添加到管理器中，它们的伸缩系数比是 2:1:2:3:3
    layout-&gt;addStretch(2);
    layout-&gt;addWidget(&amp;lab1,1);
    layout-&gt;addWidget(&amp;lab2,2);
    layout-&gt;addWidget(&amp;lab3,3);
    layout-&gt;addStretch(3);
   
    //将布局管理器添加到 widget 窗口中
    widget.setLayout(layout);
    widget.show();
    return a.exec();
}</code></pre> 
 <p style="">程序中做了以下几个操作：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>通过调用 setDirection() 方法，将添加到 QVBoxLayout 管理器中的所有控件（包括空白行）按照从下到上的顺序依次摆放。举个例子，由于 lab1 文本框是第二个添加到管理器中的，因此在最终显示的界面中，lab1 位于倒数第二的位置。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>通过调用 addStrech() 方法，向管理器中先后添加了两个空白行，它们的伸缩系数分别为 2 和 3，因此 widget 窗口中的空白区域会平均分为 5 份，一个空白行占 3 份，另一个占 2 份。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>通过调用 addWidget() 方法，向管理器中先后添加了 3 个文本框，它们的拉伸系数比为 1:2:3，所以当我们拉伸 widget 窗口时，三个文本框的大小（宽度）呈现 1:2:3 的关系。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>通过调用 setLayout() 方法，成功地将 layout 布局管理器添加到了 widget 窗口中。当然，也可以在创建 layout 对象时指定 widget 作为它的父窗口，两种方式是完全等价的。</p></li></ul> 
 <p style=""></p> 
 <p style="">执行结果为：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:599px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:76.46077%;height:0;"> 
    <img src="https://images2.imgbox.com/12/9f/ov0XlI6Y_o.gif" style="margin-left:;display:block;width:599px;margin-top:-76.46077%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;"><span class="kdocs-fontSize" style="font-size:9pt;">图 3 QVBoxLayout 实例演示</span></p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3>QHBoxLayout水平布局</h3></li></ol> 
 <p style="">水平布局指的是将所有控件从左到右（或者从右到左）依次摆放，例如：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:518px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:22.779922%;height:0;"> 
    <img src="https://images2.imgbox.com/8b/bb/KdLy4DZF_o.gif" style="margin-left:;display:block;width:518px;margin-top:-22.779922%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 4 QHBoxLayout水平布局</p> 
 <p style="">使用 QHBoxLayout 水平布局控件，程序中要提前引入&lt;QHBoxLayout&gt;头文件。QHBoxLayout 和 QVBoxLayout 继承自同一个类，它们的用法非常相似，比如 QHBoxLayout 类也提供了两个构造函数：</p> 
 <blockquote class="kdocs-blockquote" style="">
   QHBoxLayout() QHBoxLayout(QWidget *parent) 
 </blockquote> 
 <p style="">QHBoxLayout 类也没有新添任何成员方法，它只能使用从父类继承的成员方法。因此，表 1 中罗列的所有成员方法也同样适用于 QHBoxLayout 对象。</p> 
 <blockquote class="kdocs-blockquote" style="">
   注意，当 QHBoxLayout 对象调用表 1 中的 addStretch() 方法时，表示添加一个空白列。 
 </blockquote> 
 <p style="">举个简单的例子：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QLabel&gt;
#include &lt;QHBoxLayout&gt;
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    //创建主窗口
    QWidget widget;
    widget.setWindowTitle("QHBoxLayout水平布局");
    //创建水平布局管理器
    QHBoxLayout *layout=new QHBoxLayout;
    //设置布局管理器中所有控件的布局方向为从右往左依次排列
    layout-&gt;setDirection(QBoxLayout::RightToLeft);
    //连续创建 3 个文本框，并设置它们的背景和字体大小
    QLabel lab1("Label1");
    lab1.setStyleSheet("QLabel{background:#dddddd;font:20px;}");
    lab1.setAlignment(Qt::AlignCenter);
    QLabel lab2("Label2");
    lab2.setStyleSheet("QLabel{background:#cccccc;font:20px;}");
    lab2.setAlignment(Qt::AlignCenter);
    QLabel lab3("Label3");
    lab3.setStyleSheet("QLabel{background:#ffffff;font:20px;}");
    lab3.setAlignment(Qt::AlignCenter);
    //将 3 个文本框和 2 个空白列添加到管理器中，它们的拉伸系数比是 2:1:2:3:3
    layout-&gt;addStretch(2);
    layout-&gt;addWidget(&amp;lab1,1);
    layout-&gt;addWidget(&amp;lab2,2);
    layout-&gt;addWidget(&amp;lab3,3);
    layout-&gt;addStretch(3);
    //将布局管理器添加到 widget 窗口中
    widget.setLayout(layout);
    widget.show();
    return a.exec();
}</code></pre> 
 <p style="">程序执行结果为：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:532px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:84.96241%;height:0;"> 
    <img src="https://images2.imgbox.com/ef/0a/hf4Cx5Hf_o.gif" style="margin-left:;display:block;width:532px;margin-top:-84.96241%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 5 QHBoxLayout水平布局实例</p> 
 <blockquote class="kdocs-blockquote" style="">
   图 5 中，最左侧和最右侧各添加了一个空白列，它们的伸缩比例为 3:2，即它们的宽度比为 3:2。 
 </blockquote> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3>QGridLayout网格布局</h3></li></ol> 
 <p style="">网格布局又称格栅布局或者表格布局，指的是将一些控件按照行和列排列在窗口上，例如：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:444px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:36.486485%;height:0;"> 
    <img src="https://images2.imgbox.com/4e/d7/4whKvXa1_o.gif" style="margin-left:;display:block;width:444px;margin-top:-36.486485%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 6 QGridLayout网格布局</p> 
 <p style="">QGridLayout 的行标和列标都从 0 开始，例如图 6 中 one 按钮的位置为 (0, 0)，Four 按钮的位置为 (2, 0)。我们可以随意指定 QGridLayout 的行数和列数，各个控件可以随意摆放，必要时某些位置可以空着不用。</p> 
 <p style=""></p> 
 <p style="">使用 QGridLayout 网格控件，程序中需引入&lt;QGridLayout&gt;头文件。每个 QGridLayout 控件都是 QGridLayout 类的一个实例对象，该类提供了两个构造函数，分别是：</p> 
 <blockquote class="kdocs-blockquote" style="">
   QGridLayout(QWidget *parent) QGridLayout() 
 </blockquote> 
 <p style="">QGridLayout 类提供了很多实用的成员方法，常用的如下表所示：</p> 
 <p style="text-align:center;">表 2 QGridLayout常用方法</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">成员方法</span></p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">功 能</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">int QGridLayout::rowCount() const</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">获取网格的行数。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">int QGridLayout::columnCount() const</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">获取网格的列数。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::addWidget(QWidget *widget, int row, int column, Qt::Alignment alignment = Qt::Alignment())</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">将 widget 控件添加到网格中的 (row,column) 位置处，并且可以自定义该控件的对齐方式。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::addWidget(QWidget *widget, int fromRow, int fromColumn, int rowSpan, int columnSpan, Qt::Alignment alignment = Qt::Alignment())</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">将 widget 控件从 (fromRow, fromColumn) 位置开始，跨 rowSpan 行和 ColumnSpan 列添加到网格中，并且可以自定义该控件的对齐方式。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::addLayout(QLayout *layout, int row, int column, Qt::Alignment alignment = Qt::Alignment())</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">向网格中的 (row, column) 位置处添加 layout 布局管理器。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::addLayout(QLayout *layout, int row, int column, int rowSpan, int columnSpan, Qt::Alignment alignment = Qt::Alignment())</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">将 layout 布局管理器从 (row, column) 位置开始，跨 rowSpan 行和 ColumnSpan 列添加到网格中，并且可以自定义该布局控件的对齐方式。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::setColumnStretch(int column, int stretch)</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">给指定的第 column 列设置伸缩系数。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::setRowStretch(int row, int stretch)</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:top;height:52px;"><p style="">给指定的第 row 行设置伸缩系数。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::setColumnMinimumWidth(int column, int minSize)</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:middle;height:52px;"><p style="">设置第 column 列的最小宽度。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:561px;vertical-align:middle;height:52px;"><p style="">void QGridLayout::setRowMinimumHeight(int row, int minSize)</p></td><td class="kdocs-tableCell" style="width:495px;vertical-align:top;height:52px;"><p style="">设置第 row 行的最小宽度。</p></td></tr></tbody></table> 
 </div> 
 <p style="">举个简单的例子：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QLabel&gt;
#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    //创建主窗口
    QWidget widget;
    widget.setWindowTitle("QGridLayout网格布局");
    //创建 4 个按钮和 1 个文本框
    QPushButton *but1 = new QPushButton("but1");
    QPushButton *but2 = new QPushButton("but2");
    QLabel *lab3 = new QLabel("lab");
    lab3-&gt;setStyleSheet("QLabel{background:#dddddd;font:20px;}");
    lab3-&gt;setAlignment(Qt::AlignCenter);
    QPushButton *but3 = new QPushButton("but3");
    QPushButton *but4 = new QPushButton("but4");
    //创建网格布局控件
    QGridLayout *layout = new QGridLayout;
    //向 layout 中添加控件，并指定各个控件的位置
    layout-&gt;addWidget(but1, 0, 0);
    layout-&gt;addWidget(but2, 0, 2);
    layout-&gt;addWidget(lab3, 1, 0, 3, 3);
    layout-&gt;addWidget(but3, 4, 0);
    layout-&gt;addWidget(but4, 4, 2);
    //将 layout 添加到 widget 窗口中
    widget.setLayout(layout);
    widget.show();
    return a.exec();
}</code></pre> 
 <p style="">程序运行结果为：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:532px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:63.721806%;height:0;"> 
    <img src="https://images2.imgbox.com/00/30/hfWpOuZm_o.gif" style="margin-left:;display:block;width:532px;margin-top:-63.721806%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 7 QGridLayout网格布局实例</p> 
 <blockquote class="kdocs-blockquote" style="">
   图 7 中，文本框控件从 (1,0) 位置开始，占据了 3 行 3 列的表格空间。 
 </blockquote> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3>QFormLayout表单布局</h3></li></ol> 
 <p style="">Qt 提供了很多种输入框控件，包括 QLineEdit 单行输入框、QTextEdit 多行输入框等。通常情况下，每个输入框的旁边都会附带一些文字（又称标签），用来提示用户需要输入的信息。例如，图 8 中第一个输入框的标签为 "Name"，提示用户填写自己的姓名。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:503px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:29.423458%;height:0;"> 
    <img src="https://images2.imgbox.com/e5/7f/3VMTqYY2_o.gif" style="margin-left:;display:block;width:503px;margin-top:-29.423458%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 8 QFromLayout表单布局</p> 
 <p style="">生成图 8 这样的界面，实现的方法有很多，例如：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>分别创建 3 个 QLabel 控件和 3 个 QLineEdit 控件，手动指定它们的位置；</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>在 QHBoxLayout 中嵌套 3 个 QVBoxLayout，又或者在 QVBoxLayout 中嵌套 3 个 QHBoxLayout，然后再添加 3 个 QLabel 控件和 3 个 QLineEdit 控件；</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>使用 QGridLayout 创建一个 3 行 2 列的表格，向表格中添加 3 个 QLabel 控件和 3 个 QLineEdit 控件。</p></li></ol> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>使用 QFormLayout 表单布局控件实现。</p></li></ol> 
 <p style="">第 1 种方法最大的弊端在于，各个控件的尺寸都是固定的，不会随着父窗口尺寸的改变而改变。第 2、3、4 种方法都是借助布局控件实现的，各个控件的尺寸可以自动调整，但前两种方法需要手动设置每一列的 strech 拉伸系数，而第 4 种方式不需要。总之对于生成类似图 8 这样的表单窗口，建议大家使用 QFormLayout 控件，因为使用 QFormLayout 编写的代码量最少，开发效率最高。 </p> 
 <p style=""></p> 
 <p style="">QFormLayout 可以容纳很多个输入框以及对应的标签，并将它们从上到下依次排列在界面上（如图 8 所示）。大多数情况下，QFormLayout 底层是用 QGridLayout 网格布局管理器实现的，和后者不同的是，QFormLayout 只包含 2 列（不限制行数），且第一列放置标签，第二列放置输入框。</p> 
 <p style=""></p> 
 <p style="">使用 QFormLayout 布局控件之前，程序中应引入&lt;QFormLayout&gt;头文件。每一个表单布局控件都是 QFormLayout 类的一个实例对象，该类仅提供了一个构造函数：</p> 
 <blockquote class="kdocs-blockquote" style="">
   QFormLayout(QWidget *parent = Q_NULLPTR) 
 </blockquote> 
 <p style="">下表给大家罗列了操作 QFormLayout 对象常用的一些成员方法：</p> 
 <p style="text-align:center;">表 3 QFormLayout常用方法</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">成员方法</span></p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">功 能</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="">void QFormLayout::addRow(QWidget *label, QWidget *field)</p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="">将指定的 field 控件和存储标签的 label 控件添加到表单控件中的末尾。 </p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="">void QFormLayout::addRow(const QString &amp;labelText, QWidget *field)</p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="">将指定的 field 控件和 labelText 标签添加到表单控件的末尾。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="">void QFormLayout::insertRow(int row, const QString &amp;labelText, QWidget *field)</p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="">将指定的 field 控件和 labelText 标签插入到表单控件中指定行的位置。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="">void QFormLayout::removeRow(int row)</p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="">删除表单控件中的指定行。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="">void QFormLayout::removeRow(QWidget *widget)</p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="">删除表单控件中 widget 控件所在的行。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="">void setRowWrapPolicy(RowWrapPolicy policy)</p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="">设置标签的显示格式，默认标签位于控件的左侧。</p><p style=""></p><p style="">RowWrapPolicy 是 QFormLayout 中定义的枚举类型，该类型包含 3 个值：</p> 
      <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>QFormLayout::DontWrapRows：标签始终在输入框的左侧；</p></li></ul> 
      <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>QFormLayout::WrapLongRows：根据输入框的尺寸，标签可能位于输入框的左侧，也可能位于上方；</p></li></ul> 
      <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>QFormLayout::WrapAllRows：标签始终在输入框的上方；</p></li></ul></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:499px;vertical-align:middle;height:52px;"><p style="">void QFormLayout::setSpacing(int spacing)</p></td><td class="kdocs-tableCell" style="width:474px;vertical-align:middle;height:52px;"><p style="">将行间距和列间距设置为 spacing。</p></td></tr></tbody></table> 
 </div> 
 <p style="">举个简单的例子：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QLineEdit&gt;
#include &lt;QFormLayout&gt;
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    //创建主窗口
    QWidget widget;
    widget.setWindowTitle("QFormLayout表单布局");
    //创建 4 个按钮和 1 个文本框
    QFormLayout* layout = new QFormLayout();
    //设置表单中的标签都位于控件的上方
    layout-&gt;setRowWrapPolicy(QFormLayout::WrapAllRows);
    //添加 3 行输入框和标签
    layout-&gt;addRow("Name:",new QLineEdit());
    layout-&gt;addRow("Email:",new QLineEdit());
    layout-&gt;addRow("Adress:",new QLineEdit());
    //设置行间距和列间距为 10
    layout-&gt;setSpacing(10);
    //将 layout 表单添加到 widget 窗口中
    widget.setLayout(layout);
    widget.show();
    return a.exec();
}</code></pre> 
 <p style="">程序运行结果为：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:562px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:40.213524%;height:0;"> 
    <img src="https://images2.imgbox.com/1d/6f/2rwI7sMa_o.gif" style="margin-left:;display:block;width:562px;margin-top:-40.213524%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 9 QFormLayout表单布局实例</p> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3>QStackedLayout分组布局</h3></li></ol> 
 <p style="">QStackedLayout 布局管理器可以容纳多个控件或者窗口，但每次只显示其中的一个。</p> 
 <p style=""></p> 
 <p style="">举个简单的例子，下图中的界面就使用了 QStackedLayout 布局管理器：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:599px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:77.12855%;height:0;"> 
    <img src="https://images2.imgbox.com/8b/70/9R49AA8w_o.gif" style="margin-left:;display:block;width:599px;margin-top:-77.12855%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:center;">图 10 QStackedLayout布局管理器</p> 
 <p style="">整个窗口被一分为二，左侧是 QListWidget 列表控件，右侧是 QStackedLayout 布局管理器。QStackedLayout 中包含 QPushButonn、QLabel 和 QLineEdit 这 3 个控件，但每次只能 3 个控件中的一个。</p> 
 <blockquote class="kdocs-blockquote" style="">
   QStackedLayout 自身无法切换当前显示的控件或窗口，实际应用时通常和 QListWidget 或者 QComboBox 搭配使用。 
 </blockquote> 
 <p style="">使用 QStackedLayout 布局控件，程序中必须先引入&lt;QStackedLayout&gt;头文件。 每个 QStackedLayout 控件都是 QStackedLayout 类的一个实例对象，该类提供有 3 个构造函数，分别是：</p> 
 <blockquote class="kdocs-blockquote" style="">
   QStackedLayout() QStackedLayout(QWidget *parent) QStackedLayout(QLayout *parentLayout) 
 </blockquote> 
 <p style="">借助第二个构造函数，我们可以将 QStackedLayout 添加到指定的 parent 窗口中；借助第三个构造函数，我们可以将 QStackedLayout 嵌入到指定的 parentLayout 布局控件中</p> 
 <blockquote class="kdocs-blockquote" style="">
   本节学习的 5 种布局控件都可以嵌套使用，例如将 QVBoxLayout 放到 QHBoxLayout 内部、将 QGridLayout 放到 QStackedLayout 内部等。 
 </blockquote> 
 <p style="">下表罗列了操作 QStackedLayout 对象常用的一些成员方法：</p> 
 <p style="text-align:center;">表 4 QStackedLayout常用方法</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">成员方法</span></p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">功 能</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style="">int QStackedLayout::addWidget(QWidget *widget)</p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style="">将 widget 控件添加到 QStackedLayout 控件中。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:top;height:52px;"><p style="">int QStackedLayout::insertWidget(int index, QWidget *widget)</p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style="">将 widget 控件插入到 QStackedLayout 控件指定的位置处。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">信号函数</span></p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style=""></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style="">void QStackedLayout::currentChanged(int index)</p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style="">切换当前显示的控件时，会触发此信号，index 为显示的新控件的索引。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style="">void QStackedLayout::widgetRemoved(int index)</p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:top;height:52px;"><p style="">移除某个控件时，会触发此信号，index 为被移除控件的索引。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-bold" style="font-weight:bold;">槽函数</span></p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style=""></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style="">void setCurrentIndex(int index)</p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style="">将第 index 个控件作为要显示的控件。</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:443px;vertical-align:middle;height:52px;"><p style="">void QStackedLayout::setCurrentWidget(QWidget *widget)</p></td><td class="kdocs-tableCell" style="width:470px;vertical-align:middle;height:52px;"><p style="">设置 widget 作为当前要实现的控件。注意，必须保证 widget 存储在 QStackedLayout 控件中。</p></td></tr></tbody></table> 
 </div> 
 <p style="">这里我们以图 10 所示的窗口为例，实现代码如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">    //向主窗口中添加一个水平布局控件
    QHBoxLayout *layout=new QHBoxLayout;

    //创建一个列表
    QListWidget *listWidget = new QListWidget(this);
    listWidget-&gt;setMinimumWidth(150);
    listWidget-&gt;setFont(QFont("宋体",14));
    listWidget-&gt;addItem("QPushButton");
    listWidget-&gt;addItem("QLabel");
    listWidget-&gt;addItem("QLineEdit");

    //新建 3 个窗口，分别放置文本框、按钮和单行输入框
    QWidget *widget1 = new QWidget;
    widget1-&gt;setMinimumSize(400,400);
    QPushButton *but1 = new QPushButton("这是一个按钮",widget1);
    QWidget *widget2 = new QWidget;
    widget2-&gt;setMinimumSize(400,400);
    QLabel *lab1 = new QLabel("这是一个文本框",widget2);
    QWidget *widget3 = new QWidget;
    widget3-&gt;setMinimumSize(400,400);
    QLineEdit *edit = new QLineEdit("这是一个单行输入框",widget3);

    //创建一个分组布局，将 3 个窗口添加到分组控件中
    QStackedLayout *stackedLayout = new QStackedLayout;
    stackedLayout-&gt;addWidget(widget1);
    stackedLayout-&gt;addWidget(widget2);
    stackedLayout-&gt;addWidget(widget3);

    //layout 第一列添加 QListWidget 控件，第二列添加分组布局控件，设置它们的伸缩系数比为 1:4
    layout-&gt;addWidget(listWidget,1);
    layout-&gt;addLayout(stackedLayout,4);
    //将 layout 水平布局控件添加到 widget 窗口中
    this-&gt;setLayout(layout);
    //连接信号和槽，实现当点击列表中的某一项，切换分组布局管理器显示的控件
    QObject::connect(listWidget,&amp;QListWidget::currentRowChanged,stackedLayout,&amp;QStackedLayout::setCurrentIndex);</code></pre> 
 <p style="">此程序中，我们在 QHBoxLayout 水平布局控件内又放置了一个 QStackedLayout 分组布局控件。感兴趣的读者可以编写程序，测试其它布局控件之间嵌套的效果。</p> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3>QSplitter<span class="kdocs-bold" style="font-weight:bold;">分割窗口类</span></h3></li></ol> 
 <p style="">QSplitter类简介</p> 
 <p style="">QSplitter 类实现了一个拆分部件。一个拆分器splitter允许用户通过拖动它们之间的边界来控制子部件的大小。任何数量的部件都可以由单个拆分器splitter控制。QSplitter 的典型用途是创建多个部件并使用 insertWidget()或addWidget()添加它们。</p> 
 <p style="">以下示例将并排显示 QListView、QTreeView 和 QTextEdit，并带有两个分隔：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">    QSplitter *splitter = new QSplitter();
    QListView *listview = new QListView();
    QTreeView *treeview = new QTreeView();
    QTextEdit *textedit = new QTextEdit();
    splitter-&gt;addWidget(listview);
    splitter-&gt;addWidget(treeview);
    splitter-&gt;addWidget(textedit);
    splitter-&gt;setWindowTitle("Splitter Test");
    splitter-&gt;show();</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:29.054054%;height:0;"> 
    <img src="https://images2.imgbox.com/38/fe/UdgSSfVb_o.gif" style="margin-left:;display:block;width:740px;margin-top:-29.054054%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">如果在调用 insertWidget() 或addWidget()时部件已经在 QSplitter 中，它将移动到新位置。 这可用于稍后在拆分器中重新排序部件。 可以使用 indexOf()、widget() 和count()来访问拆分器内的小部件。</p> 
 <p style="">默认的 QSplitter是 水平（并排）布置其子项如上例； 可以使用 setOrientation(Qt::Vertical)将其子项垂直放置。默认情况下，所有部件都可以根据用户的意愿在部件minimumSizeHint()（或minimumSize()）和 maximumSize() 之间或大或小。默认情况下，QSplitter 会动态调整其子项的大小。</p> 
 <p style="">部件之间大小的初始分布是通过将初始大小乘以拉伸因子来确定的。 您还可以使用setSizes()来设置所有部件的大小。 函数 size()返回用户设置的大小。 或者，您可以分别使用saveState()和restoreState() 从 QByteArray 保存和恢复部件的大小。</p> 
 <p style="">当hide()一个子部件时，它的空间将分配给其他子部件。 当您再次 show()它时，它将被恢复。</p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">简单Demo和说明</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">    // 主分割窗口
    // 新建一个 QSplitter 对象 作为主分割窗口，水平分割窗口
    QSplitter *splitterMain = new QSplitter(Qt::Horizontal,nullptr); // 水平布置

    // 新建 一个 QTextEdit 对象  并将其加入 主分割窗口中
    QTextEdit *textLeft = new QTextEdit(QObject::tr("Left Widget"),splitterMain);
//    QTextEdit *textLeft = new QTextEdit(QObject::tr("Left Widget"));
//    splitterMain-&gt;addWidget(textLeft);
    textLeft-&gt;setAlignment(Qt::AlignCenter); // 设置 QTextEdit 对齐方式   AlignCenter 居中对齐

    // 右分割窗口
    QSplitter *splitterRight = new QSplitter(Qt::Vertical,splitterMain); // 垂直布置 其父窗口为 splitterMain
//    QSplitter *splitterRight = new QSplitter(Qt::Vertical);
//    splitterRight-&gt;setParent(splitterMain);

    // 调用 setOpaqueResize 用于设定分割窗口的分割条在拖拽是是否实时更新显示。
    // true 实时显示，false则拖拽时只显示一条灰色的粗线，拖拽到位并释放鼠标后显示分割条。默认 为true
    splitterRight-&gt;setOpaqueResize(false);


    QTextEdit *textTop= new QTextEdit(QObject::tr("Top Widget"),splitterRight);
    textTop-&gt;setAlignment(Qt::AlignCenter);
    QTextEdit *textBottom= new QTextEdit(QObject::tr("Bottom Widget"),splitterRight);
    textBottom-&gt;setAlignment(Qt::AlignCenter);

    splitterMain-&gt;setStretchFactor(1,1);
    splitterMain-&gt;setWindowTitle(QObject::tr("Splitter Test"));
    splitterMain-&gt;show();</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:83.542534%;height:0;"> 
    <img src="https://images2.imgbox.com/90/0f/SOd9RgZt_o.gif" style="margin-left:;display:block;width:717px;margin-top:-83.542534%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">更新位置索引处的部件的大小策略以具有拉伸因子。参数stretch不是有效拉伸系数； 有效拉伸因子是通过取部件的初始大小并将其乘以拉伸来计算的。</p> 
 <p style="">位置索引按插入的先后次序从0起依次编号。在这里setStretchFactor(1,1);中第一个1是位置索引表示第二个插入splitterMain的·部件也就是splitterRight,第二个1表示此控件也就是splitterMain可伸缩控件。也就是当整个对话框的宽度发生改变时，左部分的文件编辑框宽度保持不变，右部分的分割窗口宽度随整个对话框大小的改变进行调整。</p> 
 <ol start="7"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><h3><span class="kdocs-bold" style="font-weight:bold;">QSpacerItem弹簧</span></h3></li></ol> 
 <p style="">QSpacerItem类为布局提供了一个空白区。</p> 
 <p style="">源码：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">QHBoxLayout *pHLayout = new QHBoxLayout();
pHLayout-&gt;addWidget(pButton1);
// 添加空白区宽20px、高20px
pHLayout-&gt;addSpacerItem(new QSpacerItem(20, 20));
pHLayout-&gt;addWidget(pButton2);
// 添加间距10px
pHLayout-&gt;addSpacing(10);
pHLayout-&gt;addWidget(pButton3);
// 添加空白区宽20px、高20px，宽度尽可能的缩小、放大
pHLayout-&gt;addSpacerItem(new QSpacerItem(20, 20, QSizePolicy::Expanding));
pHLayout-&gt;addWidget(pButton4);
pHLayout-&gt;addSpacing(2);
pHLayout-&gt;addWidget(pButton5);

pHLayout-&gt;setSpacing(0);
pHLayout-&gt;setMargin(0);
setLayout(pHLayout);</code></pre> 
 <p style="">我们可以看到，QSpacerItem(int w, int h, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum)可以设置水平、垂直方向的大小调整策略，</p> 
 <p style="">默认为QSizePolicy::Minimum。</p> 
 <p style="">如上，我们构造了两个宽20px、高20px的空白区：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>QSizePolicy::Minimum：空白区不能小于该面积量，但可以在有效空间内放大。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>QSizePolicy::Expanding：空白区会随窗口的放大缩小而放大缩小。</p></li></ul> 
 <p style=""></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c27c76b73ab3e9077d5108639419b04c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">socks5centos7</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c38820fa10736f9ce283df043b344d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【halcon】小技巧，Union1能省时</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>