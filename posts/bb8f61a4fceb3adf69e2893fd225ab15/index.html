<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java——I/O(输入/输出) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java——I/O(输入/输出)" />
<meta property="og:description" content="1、File类 File类中的java.io包是唯一代表磁盘文件本身的对象，能够创建、删除或重命名文件，判断硬盘上某个文件是否存在，查询文件最后修改时间等。
File类的常用的构造方法
1.1 创建File对象
所有的构造方法都需要传入文件的路径。如上图，如果程序只处理一个目录或文件，并且知道该目录或文件的路径，使用第一个构造方法较方便。如果程序处理的是一个公共目录中的若干子目录或文件，那么使用第二个或者第三个构造方法会更方便。
【案例】，
需要注意的是在创建File文件时传入的路径使用了&#34; \\ &#34; ，这是因为在windows中目录符号为反斜线&#34; \ &#34;，但反斜线在java中是特殊字符，表示转义符，所以使用反斜线时，前面应该再添加一个反斜线，即为&#34; \\ &#34;，除此之外，目录符号还可以用正斜线&#34; / &#34;表示，如：src/Hello.java
import java.io.File; public class test{ public static void main (String[] args){ File f = new File(&#34;E:\\Java base\\第七章IO\\a.txt&#34;); //使用绝对路径构造File对象 File f1=new File(&#34;src\\Hello.java&#34;); //使用相对路径构造File对象 System.out.println(f); System.out.println(f1); } } 【运行结果】
1.2 File类的常用方法
File类提供了一系列方法，用于操作其内部封装的路径指向的文件或目录。例如，判断文件或目录是否存在，文件的创建于删除文件等，如下图：
【案例】
import java.io.File; import java.io.IOException; public class test{ public static void main (String[] args)throws IOException{ File f = new File(&#34;E:\\Java base\\第七章IO\\b.txt&#34;); //使用绝对路径构造File对象 if(f." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/bb8f61a4fceb3adf69e2893fd225ab15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-14T16:24:16+08:00" />
<meta property="article:modified_time" content="2022-05-14T16:24:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java——I/O(输入/输出)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1、File类</h4> 
<p>File类中的java.io包是唯一代表磁盘文件本身的对象，能够创建、删除或重命名文件，判断硬盘上某个文件是否存在，查询文件最后修改时间等。</p> 
<p><em>File类的常用的构造方法</em></p> 
<p><img alt="" height="769" src="https://images2.imgbox.com/af/5c/UlTWhzZj_o.png" width="1200"></p> 
<p></p> 
<p><strong>1.1 创建File对象</strong></p> 
<p>所有的构造方法都需要传入文件的路径。如上图，如果程序只处理一个目录或文件，并且知道该目录或文件的路径，使用第一个构造方法较方便。如果程序处理的是一个公共目录中的若干子目录或文件，那么使用第二个或者第三个构造方法会更方便。</p> 
<p>【案例】，</p> 
<p>需要注意的是在创建File文件时传入的路径使用了" \\ " ，这是因为在windows中目录符号为反斜线" \ "，但反斜线在java中是特殊字符，表示转义符，所以使用反斜线时，前面应该再添加一个反斜线，即为" \\ "，除此之外，目录符号还可以用正斜线" / "表示，如：src/Hello.java</p> 
<pre><code class="language-java">import java.io.File;
public class test{
    public static void main (String[] args){
        File f = new File("E:\\Java base\\第七章IO\\a.txt"); //使用绝对路径构造File对象
        File f1=new File("src\\Hello.java"); //使用相对路径构造File对象
        System.out.println(f);
        System.out.println(f1);
    }
}</code></pre> 
<p>【运行结果】</p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/da/24/oJFgif8b_o.png" width="331"></p> 
<p><strong>1.2 File类的常用方法</strong></p> 
<p>File类提供了一系列方法，用于操作其内部封装的路径指向的文件或目录。例如，判断文件或目录是否存在，文件的创建于删除文件等，如下图：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7e/69/GWM3ZULz_o.png" width="1200"> 【案例】</p> 
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
public class test{
    public static void main (String[] args)throws IOException{
        File f = new File("E:\\Java base\\第七章IO\\b.txt"); //使用绝对路径构造File对象
        if(f.exists()){     //如果存在这个文件就删除，否则就创建
            f.delete();
        }else{
            System.out.println(f.createNewFile());
        }
        //在磁盘下创建一层目录，并且在目录下创建文件
        File fileDemo=new File("E:\\Java base\\第七章IO\\hello\\b.txt");
        if(!(fileDemo.getParentFile().exists())){   //判断E:\\Java base\\第七章IO\\hello\目录是否存在
            fileDemo.getParentFile().mkdir();
        }
        if(fileDemo.exists()){      //如果存在这个文件就删除，否则就创建
            fileDemo.delete();
        }else{
            System.out.println(fileDemo.createNewFile());
        }
    }
}</code></pre> 
<p> 【运行结果】</p> 
<p><img alt="" height="69" src="https://images2.imgbox.com/53/43/9nPpJfdW_o.png" width="213"></p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/b4/0a/3KtoztrR_o.png" width="473"></p> 
<p><strong> 1.3 遍历目录下的文件</strong></p> 
<p>File类的list()方法用于遍历指定目录下的所有文件。</p> 
<p>【案例】</p> 
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
public class test{
    public static void main (String[] args)throws IOException{
        //创建File对象
        File f = new File("E:\\Java base\\第七章IO"); 
        if(f.isDirectory()){   //判断File对象对应的目录是否存在
            String[] names=f.list(); //获得目录下的所有文件的文件名
            for (String name:names){
                System.out.println(name); // 输出文件名
            }

        }
    }
}</code></pre> 
<p> 【运行结果】</p> 
<p><img alt="" height="93" src="https://images2.imgbox.com/37/2e/lXjlUiJ4_o.png" width="153"></p> 
<p>下面通过一个案例来演示如何遍历指定目录下所有扩展名为" .java "的文件。</p> 
<pre><code class="language-java">import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
public class test{
    public static void main (String[] args)throws IOException{
        //创建File对象
        File f = new File("E:\\Java base\\第七章IO");
        //创建过滤器对象
        FilenameFilter filter = new FilenameFilter() {
            //实现accept()方法
            public boolean accept (File dir,String name){
                File currFile = new File(dir, name);
                // 如果文件名以.java结尾返回true，否则返回false
                if (currFile.isFile()&amp;&amp;name.endsWith(".java")){
                    return true;
                }else{
                    return false;
                }
            }
        };
        if (f.exists()){  // 判断File对象对应的目录是否存在
            String[] lists=f.list(filter);  //获得过滤后的所有文件名数组
            for(String name:lists){
                System.out.println(name);
            }
        }
    }
}</code></pre> 
<p>【运行结果】</p> 
<p><img alt="" height="79" src="https://images2.imgbox.com/ac/8b/ZvQEI9g1_o.png" width="149"></p> 
<hr> 
<p>前面两个案例演示的都是遍历目录下文件的文件名，有时候在一个目录下，除了文件，还有子目录，如果想得到所有子目录下的File类对象，list()方法显然不能满足要求，这时需要使用FIle类提供的另一种方法listFiles（）。</p> 
<p>listFiles（）方法返回一个File对象数组，当对数组中的元素进行遍历时，如果元素中还有子目录需要遍历，则需要使用递归。</p> 
<p>【案例】</p> 
<p>调用listFiles（）方法把该目录下所有的子目录和文件存到一个File类型的数组fires中，在通过for循环遍历数组files，并对当前遍历的File对象进行判断，如果是目录就重新调用fileDir()方法进行递归，如果是文件就直接打印输出文件的路径，这样就成功遍历了该目录下所有的文件。</p> 
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
public class test{
    public static void main (String[] args)throws IOException{
        File file= 
            new File("E:\\Java base\\第七章IO");
            fileDir(file); //调用FileDir方法
    }
    public static void fileDir(File dir){
        File[] files = dir.listFiles(); //获得表示目录下所有文件的数组
        for (File file :files){     //遍历所有的子目录和文件
            if(file.isDirectory()){ 
                fileDir(file); //如果是目录，递归调用fileDir()
            }
            System.out.println(file.getAbsolutePath()); //输出文件的绝对路径
        }
    }
}</code></pre> 
<p>【运行结果】</p> 
<p>这样就遍历到了所有的文件</p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/dd/16/iB9yq3h8_o.png" width="306"></p> 
<p><strong>1.4 删除文件及目录</strong></p> 
<p>【案例】</p> 
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
public class test{
    public static void main (String[] args)throws IOException{
        File file= new File("E:\\Java base\\第七章IO\\hello");
        if(file.exists()){
            System.out.println(file.delete());
        }
    }
}</code></pre> 
<p>【运行结果】</p> 
<p>运行结果中输出了false，这说明删除文件失败了，原因在于File类的delete()方法只能删除一个指定的文件，如果File对象代表目录，并且目录下包含子目录或者文件，则File类的detele()方法不允许直接删数这个目录。</p> 
<p><img alt="" height="26" src="https://images2.imgbox.com/9a/e6/ysDwE0t7_o.png" width="99"></p> 
<p>这时候我们需要使用递归的方式来进行删除了</p> 
<pre><code class="language-java">import java.io.File;
import java.io.IOException;
public class test{
    public static void main (String[] args)throws IOException{
        File file= new File("E:\\Java base\\第七章IO\\hello");
        deleteDir(file); // 调用deleteDir删除方法
    }
    public static void deleteDir(File dir){
        if (dir.exists()){ //判断传入的File对象是否存在
            File[] files=dir.listFiles();   //得到FIle数组
            for(File file:files){  //遍历所有的子目录和文件
                if(file.isDirectory()){
                deleteDir(file);    //如果是目录，则递归调用deleDir()
                }else{
                //如果是文件，则直接删除
                file.delete();
            }
        }
        // 删除完一个目录里的所有文件后，就删除这个目录
        dir.delete();
    }
}
}</code></pre> 
<p>【运行结果】</p> 
<p>可以发现，该目录已经被删除了。 </p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/07/b6/j9dywcxG_o.png" width="485"></p> 
<h4>2 字节流</h4> 
<p><strong>2.1 字节流的概念</strong></p> 
<p>在程序开发过程中，经常会需要处理设备之间的数据传输，而所有的文件都是以二进制(字节)的形式存在的。为字节的输入/输出(I/O)l流提供了一系列的流。被统称为字节流。根据数据的传输方向可将其分为字节输入流和字节输出流。</p> 
<p>在JDK中，提供了两个抽象类InputStream和OutputStream，他们是字节流的顶级父类，所有的字节输入流都继承自InputStream，所有的字节输出流都继承自OutputStream。 </p> 
<p>在JDK中，InputStream和OutputStream提供了一系列与读写数据相关的方法，如下两图。</p> 
<p><img alt="" height="888" src="https://images2.imgbox.com/63/e2/KiAVGF6E_o.png" width="1200"></p> 
<p>前三个read()方法都是用来读数据的，其中第一个read()方法是从输入流逐个读入字节，而第二个和第三个read()方法则将若干字节以字节数组的形式一次性读入，从而提高读数据的效率。</p> 
<p>在进行I/O流操作时，当前I/O流会占用一定的内存，因此在操作结束之后，应该调用close()方法关闭流，从而释放当前I/O流所占的系统资源。 </p> 
<p><img alt="" height="947" src="https://images2.imgbox.com/f2/53/axcQ0yLm_o.png" width="1200"></p> 
<p> 前三个是重载的write()方法，都用于向输出流写入字节。其中第一个方法逐个写入字节，第二个和第三个方法是将若干个字节以字节数组的形式一次性写入，从而提高写数据的效率。</p> 
<p>flush()方法是用来将当前输出缓存区(通常是字节数组)中的数据强制写入目标设备，这个过程称为刷新。close()方法用来关闭流并释放与当前I/O流相关的系统资源。</p> 
<p>InputStream和OutputStream这两个类虽然提供了一系列与读写数据相关的方法，但是这两个类都是抽象类，不能被实例化，因此针对不同的的功能，InputStream和OutputStream提供了不同的子类，这些子类形成了一个体系结构，如下图</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c7/58/mIl9tlKx_o.jpg" width="1200"></p> 
<p><strong>2.2 InputStream读文件</strong></p> 
<p>InputStream就是JDK提供的基本输入流·。但InputStream并不是接口，而是抽象类，他是所有输入流的父类，FileInputStream是InputStream的子类，它是操作文件的字节输入流，专门用于读取文件中的数据。由于从文件读取数据是重复操作，因此需要通过循环语句来实现数据的持续读取。</p> 
<p>下面通过一个案例来实现字节流对文件数据的读取，首先在java项目的根目录下创建一个文本文件test.txt，在文件中输入内容"itcast"并保存；然后使用字节输入流对象来读取test.txt文本文件。</p> 
<p>【案例】</p> 
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;
public class test{
    public static void main (String[] args)throws IOException{
       //创建一个文件字节输入流
       FileInputStream in = new FileInputStream("test.txt");
       int b = 0;   //定义一个int类型的变量b，记住每次读取的一个字节
       while(true){
           b = in.read(); //变量b记住读取的一个字节
           if(b==-1){   //如果读取的字节为-1，跳出while循环
               break;
           }
           System.out.println(b); //否则将b写出
       }
       in.close();
    }
}</code></pre> 
<p> 【运行结果】</p> 
<p>计算机中的数据都是以字节的形式存在的，每个字符都占一个字节，因此最终结果显示的就是文件"test.txt"中的6个字节所对应的十进制数。</p> 
<pre><code class="language-java">105
116
99
97
115
116</code></pre> 
<p>有的时候文件不存在时控制台会的报错信息会有一个潜在的问题，即如果文件不存在或别的原因导致读取过程中发生了I/O错误，InputStream就无法正常的关闭，资源也无法及时释放，针对这个问题，可以使用try...finally来保证无论是否发生I/O错误InputStream都能够正确关闭。</p> 
<pre><code class="language-java">
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
public class test{
    public static void main (String[] args)throws IOException{
        InputStream input=null;
        try{
       //创建一个文件字节输入流
       FileInputStream in = new FileInputStream("test.txt");
       int b = 0;   //定义一个int类型的变量b，记住每次读取的一个字节
       while(true){
           b = in.read(); //变量b记住读取的一个字节
           if(b==-1){   //如果读取的字节为-1，跳出while循环
               break;
           }
           System.out.println(b); //否则将b写出
       }
    }finally{
        if(input !=null){
            input.close();
        }
    }
}
}</code></pre> 
<p><strong>2.3 OutputStream</strong></p> 
<p>OutputStream是JDK提供的最基本的输出流，也是抽象类，是所有输出流的父类。</p> 
<p>【案例】——如何使用FileOutputStream将数据写入文件</p> 
<pre><code class="language-java">import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
public class Example01 {
    public static void main (String[] args)throws IOException{
        //创建一个文件字节输出流
        OutputStream out = new FileOutputStream("example.txt");
        String str="传智播客";
        byte[] b=str.getBytes();
        for(int i = 0;i&lt;b.length;i++){
            out.write(b[i]);
        }
        out.close();
    } 
}</code></pre> 
<p>【运行结果】</p> 
<p>在目录下会新生成一个文本文件“example.txt”，但是我打开以后是乱码的</p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/b7/1c/hQGjtgOX_o.png" width="261"></p> 
<p> <strong>2.4 文件的复制</strong></p> 
<p>首先在项目里创建两个文件夹source和target，然后在source里存放一个五环之歌.doc</p> 
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
public class Example01 {
    public static void main (String[] args)throws Exception{
        //创建一个字节输入流，用于读取当前目录下source文件夹中的文件
        InputStream in = new FileInputStream("source/五环之歌.doc");
        //创建一个文件字节输出流，用于将读取的数据写入target目录下的文件中
        OutputStream out = new FileOutputStream("target/五环之歌.doc");
        int len; //定义一个int类型的变量len，记住每次读取的一个字节
        //获取复制文件前的系统时间
        long begintime = System.currentTimeMillis();
        while((len = in.read())!=-1){ //读取一个字节并判断是否读到文件末尾
            out.write(len); //将读到的字节写入文件
        }
        // 获取文件复制结束时的系统时间
        long endtime = System.currentTimeMillis();
        System.out.println("复制文件所消耗的时间是："+(endtime-begintime)+"毫秒");
        in.close();
        out.close();
    } </code></pre> 
<p>【运行结果】</p> 
<p>在target中自动生成了一个doc文件 </p> 
<p><img alt="" height="108" src="https://images2.imgbox.com/82/85/5jqh38T8_o.png" width="271"></p> 
<p>并且传输文件的时间为1毫秒</p> 
<p><img alt="" height="43" src="https://images2.imgbox.com/63/0a/RMIT07cn_o.png" width="410"></p> 
<p> 在复制文件时，受计算机性能等方面的影响，会导致复制文件所消耗的时间不确定，上述的文件复制是一个字节一个字节地读写，需要频繁地去操作文件，效率非常低，为了提高效率也可以定义一个字节数组作为缓冲区。在复制文件时，可以一次性读取多个字节的数据，并保存在字节数组中，然后将字节数组中的数据一次性写入文件。</p> 
<p>【案例】</p> 
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
public class Example01 {
    public static void main (String[] args)throws Exception{
        //创建一个字节输入流，用于读取当前目录下source文件夹中的文件
        InputStream in = new FileInputStream("source/五环之歌.doc");
        //创建一个文件字节输出流，用于将读取的数据写入target目录下的文件中
        OutputStream out = new FileOutputStream("target/五环之歌.doc");
        //以下是用缓冲区读写文件
        byte[] buff = new byte[1024]; //定义一个字节数组，作为缓冲区
        // 定义一个int类型的变量len记住读取读入缓冲区的字节数
        int len; 
        //获取复制文件前的系统时间
        long begintime = System.currentTimeMillis();
        while((len = in.read(buff))!=-1){ //读取一个字节并判断是否读到文件末尾
            out.write(buff,0,len); //将读到的字节写入文件
        }
        // 获取文件复制结束时的系统时间
        long endtime = System.currentTimeMillis();
        System.out.println("复制文件所消耗的时间是："+(endtime-begintime)+"毫秒");
        in.close();
        out.close();
    } 
}</code></pre> 
<p>【运行结果】</p> 
<p>同样实现了文件的复制，在复制过程中，使用while循环语句逐渐实现字节文件的复制，每循环一次，从文件读取若干字节填充字节数组，并通过变量len记住读入数组的字节数，然后从数组的第一个字节开始 ，将len个字节依次写入文件，循环往复，当len值为-1的时候，说明已经读到了文化的末尾，循环结束。</p> 
<p><strong>2.5 字节缓冲流</strong> </p> 
<p>I/O提供两个带缓冲的字节流，分别是BufferedInputStream和BufferedOutputStream，他们的构造·方法中分别接收InputStream和OutputStream类型的参数作为对象，在读写数据时提供缓冲功能</p> 
<p><img alt="" height="708" src="https://images2.imgbox.com/d7/80/RN5Yvfdy_o.png" width="1200"></p> 
<p> 下面通过案例学习BufferedInputStream和BufferedOutputStream这两个流的用法。首先在目录下创建一个src.txt的文件，并且随意写入一些内容；然后创建一个类，在类中使用FileOutputStream创建文件des.txt，并使用字节缓冲流对象将文件src.txt中的内容复制到文件des.txt中。</p> 
<pre><code class="language-java">import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class Example01 {
    public static void main (String[] args)throws Exception{
       BufferedInputStream bis = new BufferedInputStream(new FileInputStream("example.txt"));
       BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("des.txt"));
       int len;
       while((len=bis.read())!=-1){
           bos.write(len);
       }
       bis.close();
       bos.close();
    } 
}</code></pre> 
<h4>3. 字符流</h4> 
<p>3.1 字符流定义及基本用法</p> 
<p>同字节流一样，字符流也有两个抽象的顶级父类，分别是Reader和Writer。其中Reader是字符输入流，用于从某个源设备读取字符；Writer是字符输出流，用于向某个目标设备写入字符。Reader和Writer作为字符流的顶级父类，也有许多子类。下面通过一张继承关系图列举Reader和Writer的一些常用子类。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0b/e4/O3GZs4Bm_o.png" width="1200"></p> 
<p> 3.2 字符流操作文件</p> 
<p>在程序开发中，经常需要对文本文件的内容进行读取，如果想从文件中直接读取字符便可以使用字符输入流FileReader，通过此流可以从关联文件中读取一个或一组字符。</p> 
<p>下面通过一个案例来学习如何使用FileReader读取文件的字符</p> 
<p>首先在目录下新建文本文件"test.txt"并在其中输入字符"itcast"。</p> 
<pre><code class="language-java">import java.io.FileReader;

public class Example01 {
    public static void main (String[] args)throws Exception{
        // 创建一个FileReader对象用来读取文件中的字符
       FileReader reader = new FileReader("test.txt");
       int ch;  //定义一个变量用于用于记录读取的字符
       while ((ch=reader.read())!=-1){  //循环判断是否读取到文件的末尾
           System.out.println((char)ch); //不是字符流末尾就转为字符打印
       }
       reader.close(); //关闭文件读取流·，释放资源
    } 
}</code></pre> 
<p>【运行结果】</p> 
<p>实现了读取文件字符的功能，创建了一个FileReader对象与文件关联，接着通过while循环每次从文件中读取一个字符并打印，这样便实现了FIleRead读文件字符的操作。需要注意的是，字符输入流的read()方法返回的是int类型的值</p> 
<p><img alt="" height="126" src="https://images2.imgbox.com/ef/0e/Pmvg4Y5B_o.png" width="297"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44bcb17cc210419eef936b3b7de3f095/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Cloud OpenFeign源码解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/06cb365fa14adfaaa4acf438c3bdc937/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言操作符—左移右移操作符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>