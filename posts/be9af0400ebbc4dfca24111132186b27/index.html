<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>报表fastreport - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="报表fastreport" />
<meta property="og:description" content="https://blog.csdn.net/fjseryi/article/details/12558621
报表fastreport - 麦麦提敏 - 博客园 (cnblogs.com)
本节主要讲述FastReport报表系统的基本概念、基本操作方法、基本控件使用等内容。
基本概念
最主要的概念是FastReport报表的组成方式和控件主要用途，它一般包括以下方面： *页面(Page) --- 默认为Page1
与我们现实中使用的纸张相似。但它不仅仅指的是一张纸，而是用于我们设计报表的容器。打印出来可以是一张纸也可以是多张。页面(Page)可以有多个（你可以新增页面New Page），即可以有多个报表容器。利用这一点，你可以设计出复合报表（Composite Report）。 利用页面设置可以定义大小、方向、边界、打印方式、分栏等参数。这里不再详述，只特别强调分栏的作用。你可以将页面分成多栏，这样打印时数据将按照从上到下，再从左往右的方式显示。这就是我们通常说的分栏报表（Splite Report）。 *区域(Band)
FastReport将整个页面划分成若干个区域。而每个区域有着各自不同的功能，这些功能由FastReport自动加载。一个页面中可以没有区域，也可以只有其中的某些区域，这根据报表的需求而定。放置在页面中的区域有范围，落入区域范围内的控件（例如：TextObject）才具有区域的功能。 重要的区域包括： #报表抬头(ReportTitle)
仅在第一页显示在纸张的上部。一般用于打印报表的标题等信息。
#报表合计(ReprotSummary)
仅显示在所有数据的最后末尾。一般用于打印统计信息等。 #页首(PageHeader)
显示在每页的最上部。通过设置你可以让它置于报表抬头之上或者之下。一般用于打印页眉信息等。 #页脚(PageFooter)
显示在每页的最底部。一般用于打印页序等信息。 #主数据(MasterData)
用于显示数据源的数据，是最重要的区域。在该区域中可以定义连接哪一个数据源，那么该数据源的数据将会按顺序依次将记录打印出。 数据区域还有明细数据(DetailData)等，一共支持6阶数据。利用明细数据可以设计出主从报表、主-细-子细报表等。例如：各类单据的打印报表就是由单据头（主数据）和单据体（明细数据）共同完成的。 在打印时，明细一级的数据是受上一级主数据的控制，因此需要进行相关设置。 #头(Header)
显示在所有数据源的最上部，仅打印一次。一般用于显示相关摘要信息。 #尾(Footer)
显示在所有数据源的最下部，仅打印一次。一般用于显示所有数据的合计信息。 #栏首(ColumnHeader)
显示在每页数据源的上部，它在每页均显示。因此一般用于打印数据源字段的栏目信息。 #栏尾(ColumnHeader)
显示在每页数据源的下部，它在每页均显示。一般可用于统计显示每页数据的页合计信息。 #群组首(GroupHeader)
用于显示分组数据，在每一个分组开始显示。一般可用于显示分组索引数据。例如：将商品档案按商品分类分组显示，在群组首你可以显示商品分类名称。利用群组首可以设计出分组报表，关键是数据源必须按分组索引的字段排序才能达到分组的效果。群组首可以有多个，即可以嵌套使用。 另外，可以设置让分组索引数据在报表预览时显示在左侧的树型列表框(OutLine)中。 #群组尾(GroupFooter)
与群组首一一对应。一般用于显示分组数据的统计信息。 #子(Child)
是一个独立的区域。你可以设置子区域隶属于上述区域中的任何一个。在打印时，打印完父区域后，子区域将会跟随打印。一般可用于打印装饰线、调整高度或者打印子报表(SubReport)。 #重叠(overlay)
该区域内包含的内容将从页的开始位置计算打印，而不受其他功能区域的影响。一般用于无法在其他功能区域打印的内容的显示。 *对话框(DialogPage)
你可以通过设计对话框完成对数据源进行动态控制的目的，这也是设计复杂报表的重要手段。 对话框主要通过各种输入数据控件来接受客户的查询请求，因此可以学习几种主要的控件。 #标签(Label Control) --- 用于显示文字信息。使用Caption属性修改文字信息。 #文本编辑框(Edit Control) --- 用于接收用户录入的文字信息。使用Text属性修改文字信息。 #按钮(Button Control) --- 一般用于确定和取消。使用Caption属性修改文字信息。 #多选框(CheckBox Control) --- 用于用户对条件的选择。使用Checked属性确定是否。 #单选框(RadioButton Control) --- 用于用户对条件的单一选择。使用Checked属性确定是否。 #下拉框(ComboBox Control) --- 用于用户对多个数据列表的选择。使用Text属性修改当前文字信息，使用Items属性填充列表信息。 #时间框(DateEdit Control) --- 用于用户对时间的选择。利用Date属性改变时间。 *文本对象(Text Object)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/be9af0400ebbc4dfca24111132186b27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-29T18:22:25+08:00" />
<meta property="article:modified_time" content="2022-07-29T18:22:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">报表fastreport</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>https://blog.csdn.net/fjseryi/article/details/12558621</p> 
<p><a href="https://www.cnblogs.com/karkash/p/15939992.html" rel="nofollow" title="报表fastreport - 麦麦提敏 - 博客园 (cnblogs.com)">报表fastreport - 麦麦提敏 - 博客园 (cnblogs.com)</a></p> 
<p>本节主要讲述FastReport报表系统的基本概念、基本操作方法、基本控件使用等内容。</p> 
<p>基本概念</p> 
<p>最主要的概念是FastReport报表的组成方式和控件主要用途，它一般包括以下方面： <br> *页面(Page) --- 默认为Page1<br>     与我们现实中使用的纸张相似。但它不仅仅指的是一张纸，而是用于我们设计报表的容器。打印出来可以是一张纸也可以是多张。页面(Page)可以有多个（你可以新增页面New Page），即可以有多个报表容器。利用这一点，你可以设计出复合报表（Composite Report）。 <br> 利用页面设置可以定义大小、方向、边界、打印方式、分栏等参数。这里不再详述，只特别强调分栏的作用。你可以将页面分成多栏，这样打印时数据将按照从上到下，再从左往右的方式显示。这就是我们通常说的分栏报表（Splite Report）。 <br> *区域(Band)<br>     FastReport将整个页面划分成若干个区域。而每个区域有着各自不同的功能，这些功能由FastReport自动加载。一个页面中可以没有区域，也可以只有其中的某些区域，这根据报表的需求而定。放置在页面中的区域有范围，落入区域范围内的控件（例如：TextObject）才具有区域的功能。 <br> 重要的区域包括： <br> #报表抬头(ReportTitle)</p> 
<p>仅在第一页显示在纸张的上部。一般用于打印报表的标题等信息。</p> 
<p>#报表合计(ReprotSummary)<br> 仅显示在所有数据的最后末尾。一般用于打印统计信息等。 <br> #页首(PageHeader)<br> 显示在每页的最上部。通过设置你可以让它置于报表抬头之上或者之下。一般用于打印页眉信息等。 <br> #页脚(PageFooter)<br> 显示在每页的最底部。一般用于打印页序等信息。 <br> #主数据(MasterData)<br> 用于显示数据源的数据，是最重要的区域。在该区域中可以定义连接哪一个数据源，那么该数据源的数据将会按顺序依次将记录打印出。 <br> 数据区域还有明细数据(DetailData)等，一共支持6阶数据。利用明细数据可以设计出主从报表、主-细-子细报表等。例如：各类单据的打印报表就是由单据头（主数据）和单据体（明细数据）共同完成的。 <br> 在打印时，明细一级的数据是受上一级主数据的控制，因此需要进行相关设置。 <br> #头(Header)<br> 显示在所有数据源的最上部，仅打印一次。一般用于显示相关摘要信息。 <br> #尾(Footer)<br> 显示在所有数据源的最下部，仅打印一次。一般用于显示所有数据的合计信息。 <br> #栏首(ColumnHeader)<br> 显示在每页数据源的上部，它在每页均显示。因此一般用于打印数据源字段的栏目信息。 <br> #栏尾(ColumnHeader)<br> 显示在每页数据源的下部，它在每页均显示。一般可用于统计显示每页数据的页合计信息。 <br> #群组首(GroupHeader)<br> 用于显示分组数据，在每一个分组开始显示。一般可用于显示分组索引数据。例如：将商品档案按商品分类分组显示，在群组首你可以显示商品分类名称。利用群组首可以设计出分组报表，关键是数据源必须按分组索引的字段排序才能达到分组的效果。群组首可以有多个，即可以嵌套使用。 <br> 另外，可以设置让分组索引数据在报表预览时显示在左侧的树型列表框(OutLine)中。 <br> #群组尾(GroupFooter)<br> 与群组首一一对应。一般用于显示分组数据的统计信息。 <br> #子(Child)<br> 是一个独立的区域。你可以设置子区域隶属于上述区域中的任何一个。在打印时，打印完父区域后，子区域将会跟随打印。一般可用于打印装饰线、调整高度或者打印子报表(SubReport)。 <br> #重叠(overlay)<br> 该区域内包含的内容将从页的开始位置计算打印，而不受其他功能区域的影响。一般用于无法在其他功能区域打印的内容的显示。 <br> *对话框(DialogPage)<br> 你可以通过设计对话框完成对数据源进行动态控制的目的，这也是设计复杂报表的重要手段。 <br> 对话框主要通过各种输入数据控件来接受客户的查询请求，因此可以学习几种主要的控件。 <br> #标签(Label Control) --- 用于显示文字信息。使用Caption属性修改文字信息。 <br> #文本编辑框(Edit Control) --- 用于接收用户录入的文字信息。使用Text属性修改文字信息。 <br> #按钮(Button Control) --- 一般用于确定和取消。使用Caption属性修改文字信息。 <br> #多选框(CheckBox Control) --- 用于用户对条件的选择。使用Checked属性确定是否。 <br> #单选框(RadioButton Control) --- 用于用户对条件的单一选择。使用Checked属性确定是否。 <br> #下拉框(ComboBox Control) --- 用于用户对多个数据列表的选择。使用Text属性修改当前文字信息，使用Items属性填充列表信息。 <br> #时间框(DateEdit Control) --- 用于用户对时间的选择。利用Date属性改变时间。 </p> 
<p>*文本对象(Text Object)<br> 这是FastReport报表中使用最频繁的控件。可用它完成如下主要功能：</p> 
<ol><li>显示一般文字信息 --- 直接录入即可。</li><li>显示数据字段信息 --- 一般格式：[数据源."字段名称"]。</li><li>显示变量内容 --- 一般格式：[&lt;变量名&gt;]。</li><li>显示装饰线等。</li></ol> 
<p>文本对象可以进行文字对齐、格式转化、文本着色、字体改变、画边框线等许多功能，这与MicrosoftWord中的操作有诸多相同特征。因此这里不再一一赘述。</p> 
<table border="0"><tbody><tr><td> <p>在文本对象中引用数据字段或者变量需要用中括号包含，而且引用变量名时还需要用尖括号包含，这样系统就知道这是一个变量名称而不是其他什么。</p> <p>  </p> </td></tr></tbody></table> 
<p><br><br> *子报表(Subreport Object)<br> 放置子报表后，系统会自动增加一个页面，你可以在此页面上设计需要的报表。系统在打印处理时，先按主报表打印，当碰到子报表时会自动转入子报表的页面进行打印处理，完成后继续执行主报表打印的工作，所以我们又称之为嵌套报表。<br> 设计子报表与主报表基本上相同，唯一的区别是有些功能区域不能在子报表中实现，例如：报表抬头、群组。<br> *交叉报表(DB cross-tab)<br> 又称动态报表，即可以实现横向和纵向都不能确定时的报表。该报表的实现需要数据源按一定规格组织数据方能实现。 <br> *数据感知控件(FIB Query)<br> 利用该控件进行数据源的设计，可以完成设计SQL语句、测试结果、字段别名等工作。</p> 
<table border="0"><tbody><tr><td> <p>在FIBQuery控件的SQL属性对话框中有一个QueryBuilder工具。利用该工具你可以查看到目前数据库中所有的数据表以及数据字段信息。并且可以在工具中利用向导功能(Model)可以更好的完成SQL语句的编制工作，并可以测试结果(Result)。不过这里列出的仅是数据表(Table)，还有视图(View)没有列出。如果需要使用视图或存储过程(Procedure)可以查阅相关资料，FIBQuery同样支持视图和过程。 <br> 在FieldAlias属性中，你还可以将所有数据字段名称修改成中文名称。 <br> 在Master属性中，你可以定义本数据源隶属于另外哪一个数据源（即受哪一个数据源控制）。 <br> 如果你在数据源的SQL语句中定义了变量，那么在Params属性中，你可以设置这些变量的类型和值。</p> </td></tr></tbody></table> 
<p>   </p> 
<p>FastReport报表系统中还包含了一些其他控件，这些控件大部分是用于装饰报表的，比较容易理解，使用起来也比较简单，这里也不再说明了。</p> 
<p>基本操作</p> 
<p>FastReport中的操作与MicrosoftWord中的操作非常相似，不再详述。下面仅对一些常用功能及操作技巧进行提示。 <br> *热键 <br> Arrow --- 在Object之间移动 <br> Del --- 删除一个Object<br> Enter --- 调出选择的Object的编辑器 <br> Shift+Arrow --- 改变Object的尺寸大小 <br> Ctrl+Arrow --- 移动Object的位置 <br> Alt+Arrow --- 移动选择的Object到相邻的Object的旁边并且对齐 <br> *鼠标 <br> Left button --- 选择、移动一个Object，对于多选的一组Object，可以拖动右下角的红点同时改变所选的Object的尺寸大小 <br> Right button --- 调出右键菜单 <br> Shift+left button --- 多选Object<br> Ctrl+left button --- 按住Ctrl键不放用鼠标左键可以拖出一个虚线矩形框，释放鼠标按钮可以将该矩形框内所有Object选中，然后使用left button将选中的Object移动到所需位置 <br> Alt+left button --- 如果针对Text Object使用，将可以直接编辑内容，无需弹出编辑窗</p> 
<p>   </p> 
<p>5.3 报表设计与范例</p> 
<p>根据报表需求的不同，你可以利用多种报表方式完成报表。下面我将结合VBMS中已经实现的报表范例讲述各种报表的设计方法和思路。</p> 
<p>简单报表(Simple list)</p> 
<p>*报表格式 <br> 一般由报表抬头、页首、页脚（或者栏首、栏尾，或者头、尾）、主项数据组成。 <br> *报表范例 <br> #商品档案列表 <br> 步骤如下：</p> 
<ol><li>新建数据源(FIB Components-&gt;FIB Query)，起名tblProduct。（修改Name属性）</li><li>获取所需数据(tblProduct-&gt;SQL)。</li><li>依次添加ReportTitle、PageHeader、MastData、PageFooter区域。</li><li>设置MastData区域连接的数据源-&gt;tblProduct。（双击MastData区域）</li><li>在ReportTitle中添加文本对象，录入报表名称。</li><li>在PageHeader中添加若干文本对象，录入字段中文名称。</li><li>在MastData中添加若干文本对象，并连接该文本对象至对应数据字段。（可以从下拉框中选取）</li><li>在PageFooter中添加文本对象，录入页码。（使用FastReport中的系统变量 [Page]）</li></ol> 
<p>SQL语句:<br> SELECT * FROM TB_PRODUCT;</p> 
<table border="0"><tbody><tr><td> <p>一般报表都是从简单开始构建，然后逐步细化后得出的。因此可以利用FastReport报表中的新建报表向导功能(菜单-&gt;文件-&gt;新建…-&gt;标准报表向导)快速搭建起一个报表的雏形，而且他会自动将各个字段排列整齐，这样可以节约一些时间。 <br> 如果希望在报表抬头打印本公司的名称以及电话等信息，可以使用自定义变量(Custom)中的相关变量，该变量内容为VBMS在参数设置中定义的本公司资料。 <br> 在向PageHeader中添加中文栏目和向MastData中添加数据字段时，你可以直接用鼠标从右侧的数据列表框中拖拽相应字段到相应的区域中。你可以将栏目和字段一起建立，当然数据列表框下方的多选框要打勾。 <br> 可以在PageFooter中添加页码(Page)和总页数(TotalPages)。一般在文本对象中的格式为：共[TotalPages]页第[Page]页。但是需要声明的是，必须将报表设置成两遍报表(Double pass)模式后TotalPages变量才起作用否则为0。这很好理解，当报表引擎(Engine)执行第一遍时并不知道数据将充满几页纸，只有当第一遍完成后才计算得出，因此需要二遍报表才能打印出总的页数。因此两遍报表在FastReport中是一个重要概念，对于某些特殊报表可能会用到。例如：需要将统计的合计值打印在所有明细之前而不是之后。</p> </td></tr></tbody></table> 
<p><br> 技巧： <br>     前面说过，你可以利用字段别名修改英文的字段名称为中文名称，这样对于系统不很熟悉的人也可以看得懂报表。这里介绍另一个方法，使用该方法既可以达到修改中文名称的目的，又可以令报表制作更加快捷。例如还是上面这张商品档案列表。我们可以直接在SQL语句中加入中文别名。 <br> SQL语句：(中文别名需要用双引号包含)<br> SELECT<br> PRODUCTNUMBER AS "商品编号",<br> PRODUCTNAME AS "品名规格",<br> PRODUCTUNIT AS "单位",<br> SELLPRICE AS "零售价"<br> FROM TB_PRODUCT<br> 这样做的好处，一是报表中的数据字段均为中文容易理解，二是在执行上面6、7步骤时，你可以拖拽右侧的数据字段同时建立栏目头和字段，而此时栏目头中也跟随着变成了中文，避免了重新修改成中文的麻烦。当然由于vbms中的报表数量庞大，因此并未采用这种方法。 </p> 
<p>*报表中的变量</p> 
<p>FastReport中的变量分为三种。 <br> #系统变量 <br> 系统定义的一些与报表打印相关的变量，这里介绍几个常用的变量。 <br> Date --- 系统当前日期 <br> Time --- 系统当前时间 <br> TotalPages --- 总页数（必须设置Double pass） <br> Page --- 当前页码 <br> Line --- 当前行序号 <br> Line# --- 也是当前行序号，但区别是在一个新的数据区域(Band)内该变量将重新计数。 <br> #自定义变量(Custom)<br> 自定义变量是由VBMS系统传入到报表系统中的。 <br> #编程(Code)中使用的全局变量 <br> 你可以在Code页的起始处定义一些需要的全局变量。 <br> 例如： <br> var<br> S: string;<br> 这里S就成了一个全局的字符型变量，你可以对它进行赋值、取值。也可以在文本对象中引用它，格式为：[&lt;S&gt;]。 </p> 
<table border="0"><tbody><tr><td> <p>其实在FastReport报表系统中，所有对象诸如页(Page)、区域(Band)、文本对象(TextObject)、对话框控件、数据源字段、系统变量、自定义变量等，你均可以在文本对象中显示他们的值，只是引用他们的方式不同罢了。 <br> 例如：通过文本对象(TextObject)<br> 打印文本编辑框的内容可以引用Text属性，格式：[Edit1.Text]。 <br> 打印公司名称可以引用自定义变量，格式：[CompanyName]。 <br> 打印数据字段值，格式：[tblProduct."商品编号"]。其实数据字段也可以看成变量。 <br> 打印自定义的全局变量，格式：[&lt;S&gt;]。这里S需要用尖括号包含，其实一般情况下对于变量而言均需要用尖括号包含，只是FastReport对于非自定义的变量（不是在Code中定义的）有了一个预先判断，允许省略尖括号而已，你加上尖括号也不会出错。但在编程(Code)中所有变量被引用就一定需要有尖括号。 <br> 特别提醒：在文本对象中打印所有变量都必须用中括号[]将变量包含起来。</p> </td></tr></tbody></table> 
<p></p> 
<p>主从报表（Master Detail）</p> 
<p>*报表格式 <br> 一般由报表抬头、页首、页脚（或者栏首、栏尾，或者头、尾）、主项数据、细项数据组成。 <br> *报表范例 <br> #销售单据列表 <br> 步骤如下：</p> 
<ol><li>新建2个数据源(FIB Components-&gt;FIB Query)，起名tblOrder、tblItem。</li><li>获取所需数据(tblOrder-&gt;SQL、tblItem-&gt;SQL)。</li><li>依次添加ReportTitle、PageHeader、MastData、Header、DetailData、Footer、PageFooter区域。</li><li>设置MastData区域连接的数据源-&gt;tblOrder，DetailData-&gt;tblItem。</li><li>在ReportTitle中添加文本对象，录入报表名称。</li><li>在PageHeader中添加若干文本对象，录入字段中文名称（单据头）。</li><li>在MastData中添加若干文本对象，并连接该文本对象至对应数据字段。</li><li>在Header中添加若干文本对象，录入字段中文名称（单据体）。</li><li>在DetailData中添加若干文本对象，并连接该文本对象至对应数据字段。</li><li>在Footer中添加System Text对象，用于显示金额合计。</li><li>在PageFooter中添加文本对象，录入页码。（使用FastReport中的系统变量 [Page]）</li></ol> 
<p>SQL语句:<br> #tblOrder<br> SELECT * FROM TB_ORDER WHERE ORDERTYPE='销售出库';<br> #tblItem<br> SELECT * FROM TB_ITEM WHERE ORDERID=:ORDERID;</p> 
<table border="0"><tbody><tr><td> <p>主从报表的关键是需要关联主数据源和从数据源。一般情况需要通过以下方式关联： <br> #从数据源的SQL语句中一般需要有用于关联的关键字段（外键）。例如上例中的ORDERID=:ORDERID。前面的ORDERID为tblItem的外键，即明细数据通过ORDERID与某一条主项数据关联。而:ORDERID为一个变量（在SQL语句中使用&lt;冒号+变量名称&gt;表示一个变量）。而一般这个变量的名称（ORDERID）的定义与tblOrder（主项数据）中的主键的名称相同，即变量名称定义为:ORDERID而不是:O或者其他。这样做的目的是系统可以自动进行匹配。 <br> #定义tblItem的属性Master等于tblOrder。这样明细数据就被主项数据所控制了。 <br> #定义tblItem的属性Params中的变量ORDERID的类型为整型（Integer），值为变量&lt;tblOrder."ORDERID"&gt;。当你打开Params时，ORDERID变量已经默认存在了，这是因为你在tblItem的SQL中定义了这个变量的缘故。将来你可能会在一个数据源中定义多个变量，操作方法是相同的。设置值等于&lt;tblOrder."ORDERID"&gt;表示当需要获取:ORDERID变量的值时，将会从主项数据中获取。这样当主项数据的ORDERID发生变化时，明细数据也随之变化。这个值的选取你可以通过按钮(fx)更方便的获取。</p> </td></tr></tbody></table> 
<p><br> *SystemText对象 <br> 该对象与文本对象（TextObject）基本上相同，区别在于使用SystemText可以更加方便的对一个数据集进行求和或者其他的操作。虽然你也可以直接在文本对象（TextObject）中使用求和函数对数据集进行求和，不过使用SystemText可以令你不需要记忆许多函数，因为它帮你做了，基本上它就是一个构建函数向导的工具。当然如果你对FastReport中的函数比较熟悉，完全可以不必使用SystemText而直接使用TextObject更加快捷。 <br> SystemText的用法如下： <br> #放置一个SystemText对象到Footer中，用于对销售明细数据中的金额进行求和。 <br> #系统会立即弹出一个对话向导框。你可以选择三种方式中的一种：系统变量、求和、文本。这里主要将求和，另外两种方式很好理解（系统变量用于打印时间、页码等，而文本与TextObject中一样）。 <br> #选择求和（Ageregate value）。选择函数-&gt;SUM（其他为最大值、最小值、平均值、数量），数据Band-&gt;DetailData1（设置你需要求和的数据区域，这里当然是明细数据），数据库-&gt;tblItem（上一步选择好后，系统自动会设定为该数据区域连接的数据源），下一步你可以从数据字段中选择需要求和的字段（例如：TotalTaxSum）。或者在表达式中构造更为复杂的求和内容（这里暂不讲述）。 <br> #按确定后，SystemText中的文本自动生成为[SUM(&lt;tblDetail."TOTALTAXSUM"&gt;,MasterData2)]。当你再次双击该SystemText，你会发现对话框中系统默认为文本，而文本内容就是上面的内容。由此可见，SystemText其实就是TextObject加上函数向导。 </p> 
<table border="0"><tbody><tr><td> <p>大家如果仔细会发现在求和向导对话框中有两个选项，一个是"计算不可见Band的数据"，一个是"执行总数"。这两个选项是做什么用的呢？ <br> "计算不可见Band的数据"：有时候在报表中我们会对数据源做一些设置，例如满足某些条件的数据不显示出来（例如：维修结算单打印中仅打印自付内容）。那么这个选项可以使得系统在求和时只计算可见的数据。 <br> "执行总数"：我们知道，对于主从报表中明细的求和，例如销售明细中商品的销售金额。该金额是表示本单据的合计。当单据变化时，这个合计值也随之变化。而有些时候，我们可能不希望这样，而是希望有一个值一直在累加合计金额，而不是随着单据的变化这个合计值被重置。那么这个选项可以使得系统一直累计合计值直到最后一张单据。 <br> 上面两个选项对于很多报表是很有用处的。</p> </td></tr></tbody></table> 
<p><br> *SUM函数 <br> 完整定义：SUM(Expr,Band,Flags);<br> Expr：你需要求和的变量或者更加复杂的函数，例如：&lt;tblItem."TOTALTAXSUM"&gt;。 <br> Band：你需要求和的数据区域名称，例如：DetailData1。 <br> Flags：默认为0，可以省略。 <br> 1 --- 计算不可见Band数据 <br> 2 --- 执行总数 <br> 3 --- 1 并且2（计算不可见Band数据 并且 执行总数）</p> 
<p>分组报表（Group）</p> 
<p>*报表格式 <br> 一般由报表抬头、群组首、主项数据、群组尾组成。 <br> *报表范例 <br> #商品档案报表(按商品分类分组)<br> 步骤如下：</p> 
<ol><li>新建1个数据源(FIB Components-&gt;FIB Query)，起名tblProduct。</li><li>获取所需数据(tblProduct-&gt;SQL)。</li><li>依次添加ReportTitle、GroupHeader、MastData、GroupFooter区域。</li><li>设置MastData区域连接的数据源-&gt;tblProduct。</li><li>在ReportTitle中添加文本对象，录入报表名称。</li><li>双击GroupHeader，设置分组条件，选择数据字段tblProduct-&gt;PRODUCTSORT。</li><li>在MastData中添加若干文本对象，并连接该文本对象至对应数据字段。</li><li>在GroupHeader中添加若干文本对象，录入字段中文名称。</li><li>在GoupHeader中添加一个文本对象，录入&lt;tblProduct."PRODUCTSORT"&gt;。用于显示商品分类名称。</li><li>在GroupFooter中添加System Text对象，用于显示合计数。</li><li>在PageFooter中添加文本对象，录入页码。（使用FastReport中的系统变量 [Page]）</li></ol> 
<p>SQL语句:<br> SELECT * FROM TB_PRODUCT ORDER BY PRODUCTSORT;</p> 
<table border="0"><tbody><tr><td> <p>所谓分组报表，就是按某一个字段进行分组显示，该字段具有相同的值的数据记录将被归类显示在一起。例如：上例中将商品档案按照商品分类归类显示。 <br> 要达到分组的目的，其中一个关键是该数据集必须按分组条件排序。即SQL语句中一定要有ORDER BY这样的排序语句，而排序字段就是分组的字段。 <br> 分组是可以多级的，也就是可以嵌套分组。例如：商品档案定义时可能用商品分类表示大类，商品类型表示小类。分组显示时希望按大类包含小类这样嵌套方式显示。那你可以让数据集按ORDER BY PRODUCTSORT,PRODUCTSTYLE这样来排序。排序时，排在前面的字段首先被排序，在相同的条件下，对排在后面的字段再进行排序。同样的这种情况下，你需要增加两个群组首尾，让他们嵌套排列。居于外层的设置分组条件为商品分类，居于内层的设为商品类型。</p> </td></tr></tbody></table> 
<p><br> *分组条件设置中的选项 <br> 在你设置GroupHeader的分组条件时，有以下几个选项，他们的用途如下： <br> #保持与群组在一起 --- 这个选项表示，FastReport报表系统总是试图将一个群组的内容打印在一张纸上而不做分割。例如：有一个群组的内容比较多，而这个群组的开始打印位置居于纸的中部，因此本页将无法将全部该群组的内容显示完毕。那么FastReport将把这个群组打印在新的一页上，这样上页纸的底部将会留出空白。当然如果这个群组在新的一页仍然无法显示完毕，那FastReport就接着显示，不再做其他处理了。 <br> #换页 --- 这个选项与上面这个选项基本概念相同，只是他总是将新的分组内容打印在新的一页上，而不管这个分组的内容有多少。当然这样纸张的空白也更多更浪费。但这种方式对于某些客户来说仍然可能是需要的。 <br> #显示在大纲 --- 如果选择本选项，那么在你预览报表时，你可以使用纲要功能（有一个纲要按钮）。他可以将分组的名称显示在左边的树型框中，这样你可以更加方便的定位到相应的分组。 </p> 
<table border="0"><tbody><tr><td> <p>如果你想预览时总是显示纲要（不需要总是按纲要按钮）。你可以选择左侧Page1中的Report对象，在属性PreviewOptions-&gt;OutlineVisibe设置为True。</p> </td></tr></tbody></table> 
<p><br><br> *Reprint On NewPage<br>     如果你选择GroupHeader区域，然后点击鼠标右键弹出菜单（Context PopupMenu）。你会发现有一个选项Reprint On NewPage，这个在其他区域的右键菜单中是没有的。他是起什么作用呢？ <br>     我们知道，一般分组报表设计时，总是将分组条件和中文字段名称显示在群组首。这样打印时，碰到一个新的分组，FastReport先是打印群组首中的内容，例如：商品分类的名称等。然后再打印该分组的数据。但如果数据较多时不能在一页中显示，那么剩余内容将打印在后面的一页中。这带来一个问题就是，如果独立看待后面一页纸，上面显示的数据我们不知道是属于哪一个商品分类的（分组），必须返回去查看上一页中的群组首才知道。而使用Reprint On NewPage，则FastReport将在新的一页中将群组首中的内容再打印一遍（Reprint）。这样你就可以清楚知道本组数据的归属了。当然这样的话，群组首中的内容将可能会被打印超过一遍，这取决于数据的多少。</p> 
<p>分栏报表</p> 
<p>待续...</p> 
<p>多列报表</p> 
<p>待续...</p> 
<p>子报表</p> 
<p>待续...</p> 
<p>交叉报表</p> 
<p>待续...</p> 
<p>   </p> 
<p>5.4 常用功能及函数</p> 
<p>常用功能</p> 
<p>*报表设置 <br> 什么时候需要两遍报表（Double pass）？ <br> 应用1 用于显示总的页数（TotalPages），例如：页脚显示第1页/共20页。系统第一遍扫描报表时计算出TotalPages，然后第二遍实际生成报表。如果不使用Double pass，则TotalPages返回0。 <br> 应用2 用于将明细项的合计值打印在报表起始位置，而不是在末尾。这需要在第一遍扫描报表时计算出然后在第二遍生成报表时显示在起始位置。 <br> 密码 --- 用于将报表加密，这样在设计或者显示报表时需要输入密码。 <br> *页面设置 <br> 分栏 --- 可以将报表在一张纸上分成若干列来打印，比较利于节省纸张。这与在主项数据的Band中设置多个列（Column）不同，分栏打印顺序是从上往下，然后从左往右。多列打印顺序是从左往右，再从上往下。</p> 
<p>函数</p> 
<p>ListValue --- 根据SQL语句自动填充一个列表的值； <br> procedure ListValue(ASQL: string;AList: TStrings);<br> begin<br> tblList.Close;<br> tblList.SQL.Text := ASQL;<br> tblList.Open;<br> tblList.First;<br> while not tblList.Eof do<br> begin<br> AList.Add(tblList.Fields[0].AsString);<br> tblList.Next;<br> end;<br> end;</p> 
<p>   </p> 
<p>ShowLoginSector --- 登陆分公司列表自动选择，如果不是管理部门则不允许选择； <br> procedure ShowLoginSector(L: TfrxComboBoxControl);<br> var<br> S: string;<br> begin<br> S := VarToStr(Get('LoginSector'));<br> if S = '' then S := '管理部门';<br> L.ItemIndex := L.Items.IndexOf(S);<br> L.Enabled := S = '管理部门';<br> end;</p> 
<p>   </p> 
<p>   </p> 
<p>5.5 报表设计常用技巧</p> 
<p>A 为系统数据源增加自定义数据源，达到扩展数据的目的</p> 
<p>    在VBMS中的报表中心我们可以自己设计数据源然后设计自己需要的报表。其实，我们在其他的模块中一样可以自己设计数据源（原来以为不可以）。 <br> 设计方法与报表中心中是一样的。 <br> 下面我举一个例子： <br> 在客户档案模块中的打印报表中，增加每个客户的对应的车辆资料的显示。 <br> 原报表中已经有了一个系统传入的数据源dsCustomer。 <br> 1.  FIB-&gt;FIB Query，新增一个数据源 dsVehicle。 <br> SQL语句为： <br> SELECT * FROM TB_VEHICLE WHERE CLIENTID=:CLIENTID； <br> 其中:CLIENTID为变量，是随着dsCustomer的变化而变化的。 <br> （注意：如果你希望这个变量由主数据源来控制，则该变量的命名必须与主数据源中的字段名称一致。） <br> 2. 设置dsVehicle的如下属性： <br> Master -&gt; dsCustomer；（设置主数据源） <br> Params -&gt; CLIENTID，数据类型 Integer，值 &lt;dsCustomer."CLIENTID"&gt;<br> （设置参数：设置值时可以选择按钮fx来选择） <br> 3. 插入一个Band（明细数据）。 <br> 设置连接数据库为dsVehicle。然后放入相关的字段（Text Object）。 <br> 4. 鼠标右键设置MastData1的 Print if Detail Empty。目的是如果该客户没有车辆依然需要打印出来。</p> 
<p>总结： <br>     现在，我们既可以在报表中心，也可以在任何位置的打印报表中设计自己的数据源，并且可以将自己的数据源与vbms系统传入的数据源进行关联。这样的应用可以使报表设计更加灵活、更加强大。</p> 
<p>   </p> 
<p>B 为报表增加分组显示功能 <br> 在vbms系统的设计报表功能中，有一个群组头、群组尾的功能。 <br>     如果将群组头和群组尾分别置于主项数据的上面和下面，则可以对该主项数据进行分组统计功能，设置群组头时，系统会询问对哪一个字段进行分组。然后你可以在该群组头上放置一个该字段的TextObject来显示分组内容，在群组尾放置一个用于求和的SystemText。这样就可以按照该字段来分组统计了。 <br> 注意：要让相同组别的记录显示在一起，必须使数据源按该字段排序。因此，在一般报表中，如果你希望按照某个字段来分组统计，必须在打印所在的窗体上点击数据列表的该字段项（即排序，可以正排和逆排），然后再进入打印对话框来打印；如果是在报表中心中设计的报表，则在SQL中必须加上ORDER BY语句来排序。 <br> 另外，在群组头的属性中有一个OutLine，如果等于True。则可以在预览中使用列表导航。</p> 
<p>   </p> 
<p>C 将对话框（DialogForm）中的信息显示在报表中。 <br> 例如：对话框中录入开始日期和结束日期，你希望将该时间范围显示在报表头上。 <br> 方法是，在报表头上加一个Text Object，然后录入[edtBD.Text]；edtBD就是开始日期编辑框的Name，记住要用中括号括起来。其他的类推。 <br> *在对话框中的下拉框中显示一个列表。 <br> 例如，在对话框中你可能需要用一个下拉框让用户选择某一个供应商，下拉框中存储了所有供应商。 <br> 方法是，首先建一个数据源（tblProvider），该数据源返回了所有供应商。在对话框中放一个下拉框（cmbClientName），在对话框的OnShow事件中编写如下代码： <br> tblProvider.Open;<br> tblProvider.First;<br> while not tblProvder.Eof do<br> begin<br> cmbClientName.Items.Add(tblProvider.FieldByName('CLIENTNAME').AsString);<br> tblProvder.Next;<br> end;<br> 该方法通用，只需要替换相应的数据源就可以实现其他的内容。</p> 
<p>   </p> 
<p>D 在分组脚或者栏尾显示多个数据项的合计。 <br> 例如，对于导购人员统计表，有销售金额、项目金额、其他金额三项，我希望在栏尾显示三项的合计值（不是每一项的合计）。 <br> 如果要分别统计每一项的合计，你只需这样。 <br> SUM(&lt;tblBMAccount."SELLSUM"&gt;)就可以统计销售金额了。 <br> 将三项加起来，则写如下代码 <br> SUM(&lt;tblBMAccount."SELLSUM"&gt;+&lt;tblBMAccount."SERVICESUM"&gt;+&lt;tblBMAccount."OTHERSUM"&gt;)</p> 
<p>*这里讲一下一些语法格式。 <br> 取一个字段的格式， <br> 格式：TableName."FieldName"<br> 表名+逗号+字段名，字段名用双引号引起来。</p> 
<p>如果你希望在一个TextObject中显示某一个字段内容， <br> 格式是：[TableName."FieldName"]<br> 用中括号括起来，中间是字段。</p> 
<p>如果该字段内容作为参数参加运算或者作为一个函数的参数，则需要用&lt;&gt;尖括号将字段括起来。 <br> 格式：SUM(&lt;TableName."FieldName"&gt;)<br> 比如：SUM(&lt;tblBMAccount."SELLSUM"&gt;)； <br> 或者 &lt;tblBMAccount."SELLSUM"&gt;+&lt;tblBMAccount."SERVICESUM"&gt;； <br> 同样的，如果希望将他们放在Text Object中显示，还必须加上中括号。 <br> 例如：[SUM(&lt;TableName."FieldName"&gt;)]</p> 
<p>这里关键记住，如果想在TextObject中显示要用[]中括号，要在函数的参数中引用字段或者使用字段进行运算，需要用&lt;&gt;尖括号将字段括起来。</p> 
<p>   </p> 
<p>E 如何将报表底部的合计显示在报表头 <br> 如果直接将合计的TextObject放在主项数据的前面，将不能统计值，因为此时尚未解析出所有数据。 <br> 利用FastReport的两遍报表和临时变量功能实现。 <br> 首先设置该报表为两遍报表（Double Pass）。 <br> 在底部的某一个Band中的OnBeforePrint事件中加入以下代码： <br> 例如： <br> Set(&lt;tblBMAccount."BM"&gt;,SUM(&lt;tblBMAccount."SELLSUM"&gt;+&lt;tblBMAccount."SERVICESUM"&gt;+&lt;tblBMAccount."OTHERSUM"&gt;));<br> 说明：Set是一个函数，他将一个值存入了一个变量中。 <br> Set(var,value)；其中变量var可以利用数据表中的某一个字段，Value是你的合计值。 <br> 在主项数据（MastData）的上面的某一个Band中放一个TextObject（例如：memTotal） <br> 然后在该TextObject的OnBeforePrint事件中加入如下代码： <br> 例如： <br> if Engine.FinalPass then<br> memTotal.Text := Format('%8.2f',[Get(&lt;tblBMAccount."BM"&gt;)]);<br> 说明：Engine是FastReport管理报表的对象，FinalPass表示最后一遍报表。 <br> Get(var)将变量var的值返回。Format是一个格式化数字的函数。</p> 
<p>   </p> 
<p>F 在底部显示多个数据源某个字段的合计值 <br> 例如：将三个明细的合计相加后显示总的合计。 <br> 方法一： <br> 公式如下： <br> [SUM(&lt;dsServiceItem."TOTALTAXSUM"&gt;,MasterData1)+SUM(&lt;dsProductItem."TOTALTAXSUM"&gt;,MasterData2)+SUM(&lt;dsOtherItem."TOTALTAXSUM"&gt;,MasterData3)]</p> 
<p>但有一个问题是，当三个明细不是全部存在时，打印时会发生Variant Operate操作错误。 <br> 我分析该错误产生的的原因是当其中一个明细不存在时，此时SUM后的结果为NULL（空值）而不是0，所以当一个NULL值与其他一个数值相加时会发生上述错误。 <br> 解决的方法是，判断一下：如果SUM后为NULL，则给它赋值0。恰好FastReport中有一个函数IIF(Expression,TureValue,FalseValue);该函数可以通过判断条件，如果条件为True，则返回True值，为False则返回False值。 <br> 所以将上述表达式进行一些改造。 <br> IIF(SUM(&lt;dsServiceItem."TOTALTAXSUM"&gt;,MasterData1)&lt;&gt;null,SUM(&lt;dsServiceItem."TOTALTAXSUM"&gt;,MasterData1),0)<br> 上面这个表达式表示：如果合计值不为空，则返回合计值，否则返回0。</p> 
<p>因此，整个表达式如下： <br> [IIF(SUM(&lt;dsServiceItem."TOTALTAXSUM"&gt;,MasterData1)&lt;&gt;null,SUM(&lt;dsServiceItem."TOTALTAXSUM"&gt;,MasterData1),0)+IIF(SUM(&lt;dsProductItem."TOTALTAXSUM"&gt;,MasterData2)&lt;&gt;null,SUM(&lt;dsProductItem."TOTALTAXSUM"&gt;,MasterData2),0)+IIF(SUM(&lt;dsOtherItem."TOTALTAXSUM"&gt;,MasterData3)&lt;&gt;null,SUM(&lt;dsOtherItem."TOTALTAXSUM"&gt;,MasterData3),0)]</p> 
<p>方法二： <br> 在Code页的最顶部定义三个变量，例如： <br> var<br> V1,V2,V3: Double;</p> 
<p>在每个数据源的主项脚的OnBeforePrint的事件中分别录入： <br> 主项脚1的OnBeforePrint:<br> V1 := SUM(&lt;dsServiceItem."TOTALTAXSUM"&gt;,MasterData1);<br> 主项脚2的OnBeforePrint:<br> V2 := SUM(&lt;dsProductItem."TOTALTAXSUM"&gt;,MasterData2);<br> 主项脚3的OnBeforePrint:<br> V3 := SUM(&lt;dsOtherItem."TOTALTAXSUM"&gt;,MasterData3);</p> 
<p>在需要显示合计的TextObject中使用： <br> [&lt;V1&gt;]或者[&lt;V2&gt;]或者[&lt;V3&gt;]或者[&lt;V1+V2+V3&gt;]即可。</p> 
<p>   </p> 
<p>G 在报表中引入自己的数据源 <br> 有客户需求：希望打印条码时同时打印出商品的品名规格和零售价（或其它商品相关信息），但条码库数据表中没有相应的数据字段。如何进行设计呢？ <br> 其实利用条码库数据表中的商品序号（ProductID），可以自己增加一个数据源（dsBarCodeEx），通过ProductID作为主键来连接数据表TB_BARCODE和TB_PRODUCT，将TB_PRODUCT表中的某些字段引入（根据需要）。 <br> 数据源可能是如下内容： <br> SELECT<br> TB_BARCODE.PRODUCTID,<br> TB_BARCODE.BARCODE,<br> TB_PRODUCT.PRODUCTNUMBER,<br> TB_PRODUCT.PRODUCTNAME,<br> TB_PRODUCT.SELLPRICE<br> FROM<br> TB_BARCODE<br> LEFT JOIN TB_PRODUCT<br> ON TB_PRODUCT.PRODUCTID=TB_BARCODE.PRODUCTID</p> 
<p>这样，你可以利用自己设计的数据源（原来的数据源dsBarCode不去管他）设计出相应的条码打印报表（可以打印零售价等）。</p> 
<p>   </p> 
<p>H 在报表中实现可变数据源 <br> 在报表中可以根据对话框中的条件实时调整数据源中的参数。 <br> 例如：在库存状况表中导出到条码库后（所有商品均导出），有时需要只打印某些商品的条码。你可以设计一个对话框，可以按照商品编号筛选，如果筛选条件为空，则打印所有商品，否则打印筛选出的商品。 <br> 设计数据源如下： <br> SELECT<br> BA.PRODUCTID,<br> BA.BARCODE,<br> PR.PRODUCTNUMBER,<br> PR.PRODUCTNAME,<br> PR.SELLPRICE<br> FROM<br> TB_BARCODE BA<br> LEFT JOIN TB_PRODUCT PR<br> ON PR.PRODUCTID=BA.PRODUCTID<br> WHERE PR.PRODUCTNUMBER = :N</p> 
<p>然后在数据源的Params中设置N的参数。</p> 
<p>此时，如果筛选条件为空，则查询出来的数据也为空。 <br> 这是因为条件 WHERE PR.PRODUCTNUMBER = :N 导致的。 <br> 筛选条件为空时，数据源应该去掉该条件。此时需要根据条件动态调整数据源。</p> 
<p>在btnOK（对话框中的确定按钮）的OnClick事件中加入以下代码： <br> procedure btnOKOnClick(Sender: TfrxComponent);<br> var<br> S: string;<br> begin<br> S := 'SELECT BA.PRODUCTID,BA.BARCODE,PR.PRODUCTNUMBER,PR.PRODUCTNAME,PR.SELLPRICE'+<br> ' FROM TB_BARCODE BA'+<br> ' LEFT JOIN TB_PRODUCT PR'+<br> ' ON PR.PRODUCTID=BA.PRODUCTID';<br> if edtProductNumber.Text&lt;&gt;'' then<br> begin<br> S := S + ' WHERE PR.PRODUCTNUMBER = :N';<br> dsBarCodeEx.ParamByName('N').Value := edtProductNumber.Text;<br> end;<br> dsBarCodeEx.SQL.Text := S;<br> end;<br> 该代码根据筛选条件不同，对数据源的SQL语句进行不同的设置。 <br> 这样就可以达到要求了。</p> 
<p><br> I 在对话框中，显示开始日期和结束日期。 <br> 在DialogPage1的OnShow事件中加入以下代码： <br> 方式1： <br> procedure DialogPage1OnShow(Sender: TfrxComponent);<br> begin<br> edtBD.Text := DateToStr(Date); <br> edtED.Text := DateToStr(Date);<br> end;</p> 
<p>说明： <br> edtBD,edtED为开始日期、结束日期的编辑框。 <br> DateToStr()函数将日期型变量转为字符串。 <br> 现在，开始日期和结束日期默认为今日。</p> 
<p>方式2： <br> procedure DialogPage1OnShow(Sender: TfrxComponent);<br> var<br> Y,M,D: Integer;<br> begin<br> Y := YearOf(Date);<br> M := MonthOf(Date);<br> D := DaysInMonth(Y,M);<br> edtBD.Text := DateToStr(EnCodeDate(Y,M,1));<br> edtED.Text := DateToStr(EnCodeDate(Y,M,D));<br> end;</p> 
<p>说明： <br> YearOf()函数返回某个日期的年份； <br> MonthOf()函数返回某个日期的月份； <br> DaysInMonth()函数返回某月的天数； <br> EnCodeDate()函数将年、月、日整型数转为日期型；</p> 
<p>现在，开始日期为本月的1号，结束日期为本月的最后一天。</p> 
<p>   </p> 
<p>J 在对话框DialogPage1中使用警告框提醒输入相关内容</p> 
<p>例如：你可能需要用户必须录入某些查询内容，否则提醒用户输入。 <br> 在btnOK（确定按钮）的OnClick事件中加入以下代码：</p> 
<p>procedure btnOKOnClick(Sender: TfrxComponent);<br> begin<br> if edtDepotName.Text = '' then<br> begin<br> ShowMessage('请输入仓库!');<br> edtDepotName.SetFocus;<br> DialogPage1.ModalResult := mrNone;<br> Exit;<br> end else<br> DialogPage1.ModalResult := mrOK;<br> end;</p> 
<p>说明： <br> ShowMessage()函数用于显示一条警告信息。 <br> edtDepotName.SetFocus 表示该编辑框获取输入焦点； <br> DialogPage1.ModalResult := mrOK    表示通过； <br> DialogPage1.ModalResult := mrNone  表示不通过；</p> 
<p>   </p> 
<p>K 单据打印中如何实现空表格填满剩余的空行，达到指定的行数。</p> 
<p>在原来的报表基础上，增加一个子Band（Child1），在这个Band上设计空白行。 <br> 可以将Footer1的高度Height设置为0；</p> 
<p>在Code页中录入以下代码：</p> 
<p>var<br> PageLine: Integer;         //在现在页打印到第几行 <br> PageMaxRow: Integer = 8;   //指定的每页固定行数 你可以修改</p> 
<p>//在MasterData1的OnBeforePrint事件中加入以下内容 <br> procedure MasterData1OnBeforePrint(Sender: TfrxComponent);<br> begin<br> PageLine := &lt;Line#&gt; mod PageMaxRow;<br> if (PageLine = 1) and (&lt;Line#&gt; &gt; 1) then<br> Engine.NewPage;<br> end;</p> 
<p>//在Footer1的OnBeforePrint事件中加入以下内容 <br> procedure Footer1OnBeforePrint(Sender: TfrxComponent);<br> var<br> i: Integer;<br> begin<br> i := iif(PageLine=0,PageMaxRow,PageLine);<br> while i &lt; PageMaxRow do<br> begin<br> i := i + 1;<br> Engine.ShowBand(Child1);  //增加一个子Band，在该Band上设计空白的行 <br> end;<br> end;</p> 
<p>   </p> 
<p>L 在报表中使用金额大写 <br> 在FastReport的设计模式下，在Code页中加入以下函数：</p> 
<p>function SumToCaps(const Value : Double): string;<br> const<br> d = '零壹贰叁肆伍陆柒捌玖分角元拾佰仟万拾佰仟亿';<br> var<br> m,k : string;<br> j   : Integer;<br> begin<br> k :='';<br> m :=FloatToStr(int(Value*100));<br> for j:=length(m) downto 1 do<br> k := k+d[(strtoint(m[Length(m)-j+1])+1)*2-1]+<br> d[(strtoint(m[Length(m)-j+1])+1)*2]+d[(10+j)*2-1]+d[(10+j)*2];<br> result := k;<br> end;</p> 
<p>当你需要将一个金额转换为金额大写时可以如下操作： <br> 1、在Code页的开始处定义一个字符串。 <br> Var<br> TOTALSUM_CAPS: string;</p> 
<p>2、在相应的事件（可能是OnBeforePrint）中加入 <br> TOTALSUM_CAPS := SumToCaps(TOTALSUM);<br> 注：这里的TOTALSUM可能是一个变量，也可以是数据源中的字段或者合计值。例如： <br> &lt;tblMaster."TOTALSUM"&gt;或者SUM(&lt;tblMaster."TOTALSUM",MasterData1,1&gt;)。</p> 
<p>3、在需要显示大写金额的TextObject中键入[&lt;TOTALSUM_CAPS&gt;]。</p> 
<p>   </p> 
<p>M 如何隐藏某些主项数据记录</p> 
<p>通常当某个数值为零时，我们不希望这条记录被打印或者显示。 <br> 步骤如下： <br> 1、选择主项数据MastData1的OnBeforePrint时间。 <br> 2、在OnBeforePrint事件中填写代码 <br> if &lt;tblMaster."TotalSum"&gt;=0 then<br> MastData1.Visible := False else<br> MastData1.Visible := True;<br> 其中&lt;tblMaster."TotalSum"&gt;=0是条件，你可以定义为自己的条件。</p> 
<p>   </p> 
<p>N 如何强调某些主项数据的内容 <br> 有时我们希望当满足一定条件时，某些数据的字体或者颜色显示不同，以达到强调的目的。 <br> 步骤如下： <br> 1 选择需要强调的TextObject。 <br> 2 选择工具栏中的强调按钮。 <br> 3 在对话框中录入需要强调时的条件。例如：&lt;tblMasterData."TotalSum"&gt; &gt;= 1000<br> 4 选择强调的字体，颜色。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0821f91196114cde191cc777c022bcc2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">魅族MX4安装Ubuntu Touch 16.04</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64e25e7b6524bd9824b23818fc592035/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql 事务原理详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>