<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#基础语法的学习 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#基础语法的学习" />
<meta property="og:description" content="学习基础 已经学过一门面向对象的语言和C语言基础
本文按找基本介绍,物质,运动,类的顺序进行介绍
.NET 概述 什么是 .NET .NET(dotnet)是微软公司发布的应用程序框架 ,用以减轻软件开发人员的工作 .它包括一系列类库、运行时等内容 .
在生成一个 .NET 程序时 ,代码翻译成微软中间语言 (MSIL, Microsoft Intermediate Language)的可执行文件 .
执行该可执行文件时 ,将启动对应 .NET 框架的“公共语言运行时 (CLR, Common Language Runtime)” ,由该 CLR 将 MSIL 编译为机器码执行 ,称作 JIT 编译 (just-in-time compilation) .
所以,由.net开发的程序的优点
可以跨平台(使用不同的CLR编译)可以通过一些工具,如dnspy,反编译出其源代码轻松实现垃圾回收 (GC, Garbage Collection) .NET历史 .NET Framework: 微软推出的框架名字叫“.NET Framework” ,闭源且只能在 Windows 上运行
.NET Core: 后来,微软拥抱开源与跨平台 ,推出了“.NET Core”框架 ,该框架开源 ,并且支持多种操作系统 ,
.NET: 并且随着 .NET Core 版本的更迭 ,.NET Framework 支持的功能也逐渐向 .NET Core 迁移 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/bf636c52c8f189376a0ed946e61b51d4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-26T03:00:25+08:00" />
<meta property="article:modified_time" content="2023-12-26T03:00:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#基础语法的学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>学习基础</h2> 
<p>已经学过一门面向对象的语言和C语言基础</p> 
<p>本文按找基本介绍,物质,运动,类的顺序进行介绍</p> 
<h2><a id="NET__6"></a>.NET 概述</h2> 
<h3><a id="_NET_8"></a>什么是 .NET</h3> 
<p>.NET(dotnet)是微软公司发布的应用程序框架 ,用以减轻软件开发人员的工作 .它包括一系列类库、运行时等内容 .</p> 
<p>在生成一个 .NET 程序时 ,代码翻译成微软中间语言 (MSIL, Microsoft Intermediate Language)的可执行文件 .</p> 
<p>执行该可执行文件时 ,将启动对应 .NET 框架的“公共语言运行时 (CLR, Common Language Runtime)” ,由该 CLR 将 MSIL 编译为机器码执行 ,称作 <strong>JIT 编译</strong> (just-in-time compilation) .</p> 
<p>所以,由.net开发的程序的优点</p> 
<ol><li>可以跨平台(使用不同的CLR编译)</li><li>可以通过一些工具,如dnspy,反编译出其源代码</li><li>轻松实现垃圾回收 (GC, Garbage Collection)</li></ol> 
<h3><a id="NET_22"></a>.NET历史</h3> 
<p>.NET Framework: 微软推出的框架名字叫“.NET Framework” ,闭源且只能在 Windows 上运行</p> 
<p>.NET Core: 后来,微软拥抱开源与跨平台 ,推出了“.NET Core”框架 ,该框架开源 ,并且支持多种操作系统 ,</p> 
<p>.NET: 并且随着 .NET Core 版本的更迭 ,.NET Framework 支持的功能也逐渐向 .NET Core 迁移 .当 .NET Core 3.1 出现后 ,功能已经接近完备 ,接近甚至超过了 .NET Framework ,微软决定下个版本扔掉 Core ,下个版本直接改名“.NET” ,与 .NET 同名以表明它将是以后 .NET 的主要发展方向 .况且考虑到 .NET Framework 最新版本已经是 4.x ,因此为了防止发生混淆 ,.NET 版本跨过 4.x ,而直接于 2020 年下半年推出 .NET 5 ,并在之后每年推出一个 .NET 版本 .</p> 
<p>版本 : 对于 .NET 来说 ,偶数版本的 .NET为长期支持的 LTS 版本 (Long Term Support) ,支持期限为三年；奇数版本的 .NET为标准支持的 STS 版本 (Standard Term Support) ,支持期限为 18 个月 .</p> 
<p>规范 : 在 .NET Core 出现之前 ,开源社区 (非微软官方)自己创造了一个支持 C# 语言的跨平台运行时 ,称作“mono” .为了便于管理如此繁杂的 .NET 体系 ,微软推出了 .NET Standard 规范 ,作为各个 .NET 运行时遵循的准则 .</p> 
<p>.NET 现在可以支持多种语言或被多种语言进行调用 ,例如 C#、Visual Basic.NET、F#、PowerShell、C++/CLI ,等等 .</p> 
<h3><a id="_C__38"></a>第一个 C# 程序</h3> 
<h4><a id="Main_40"></a>Main方法</h4> 
<p>创建VS控制台程序后,打开 Program.cs ,我们看到下面代码</p> 
<p>一般按找这个规范来编写代码,因为CS开发经常涉及很多源文件,使用命名空间和类</p> 
<p>形成如下良好的编码规范,让我们的程序和思维更清晰</p> 
<pre><code class="prism language-c#">using System;

namespace hello
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
//等价于System.Console.WriteLine("Hello World!"); 
</code></pre> 
<h3><a id="_64"></a>代码规范</h3> 
<h4><a id="_66"></a>单一入口点</h4> 
<p>C#其实可以不要<code>Main</code>方法,但为了我们程序流可追踪,有单一入口.</p> 
<p>所以一般来说 ,习惯上都定义且只定义一个 <code>Main</code> 方法在 <code>Program</code> 类中 .</p> 
<h4><a id="_72"></a>命名</h4> 
<p>大驼峰 : 类名,方法,接口(并且以I开头)</p> 
<p>小驼峰 : 字段(变量名)</p> 
<h2><a id="_78"></a>物质</h2> 
<h3><a id="_80"></a>类型系统</h3> 
<p>C# 是一种面向对象的强类型语言,具有一个庞大的类型系统 .</p> 
<p>C# 中一切类型(除指针类型)均继承自 <code>object</code> (<code>System.Object</code>)类</p> 
<p>C# 的类型分为两种: 值类型和引用(指针)类型 .</p> 
<h4><a id="_88"></a>值类型</h4> 
<p>值类型是一类比较简单的类型,直接在内存栈上或其他内存位置储存数值,都是由<code>System.ValueType</code> 派生而来</p> 
<h5><a id="_92"></a>数值类型</h5> 
<p>,均属于结构类型 ,C# 内置的数值类型有:</p> 
<table><thead><tr><th>C# 类型名称</th><th>范围</th><th>对应的 .NET 类型</th><th>备注</th></tr></thead><tbody><tr><td><code>sbyte</code></td><td>-128 ~ 127</td><td><code>System.SByte</code></td><td>8 位有符号整数</td></tr><tr><td><code>byte</code></td><td>0 ~ 255</td><td><code>System.Byte</code></td><td>8 位无符号整数</td></tr><tr><td><code>short</code></td><td>-32,768 ~ 32,767</td><td><code>System.Int16</code></td><td>16 位有符号整数</td></tr><tr><td><code>ushort</code></td><td>0 ~ 65535</td><td><code>System.UInt16</code></td><td>16 位无符号整数</td></tr><tr><td><code>int</code></td><td>-2,147,483,648 ~ 2,147,483,647</td><td><code>System.Int32</code></td><td>32 位有符号整数</td></tr><tr><td><code>uint</code></td><td>0 ~ 4,294,967,295</td><td><code>System.UInt32</code></td><td>32 位无符号整数</td></tr><tr><td><code>long</code></td><td>—</td><td><code>System.Int64</code></td><td>64 位有符号整数</td></tr><tr><td><code>ulong</code></td><td>0 ~ 18,446,744,073,709,551,615</td><td><code>System.UInt64</code></td><td>64 位无符号整数</td></tr><tr><td><code>nint</code></td><td>取决于平台</td><td><code>System.IntPtr</code></td><td>32 或 64 位有符号整数</td></tr><tr><td><code>nuint</code></td><td>取决于平台</td><td><code>System.UIntPtr</code></td><td>32 或 64 位无符号整数</td></tr><tr><td><code>float</code></td><td>—</td><td><code>System.Single</code></td><td>IEEE754 单精度浮点数</td></tr><tr><td><code>double</code></td><td>—</td><td><code>System.Double</code></td><td>IEEE754 双精度浮点数</td></tr><tr><td><code>decimal</code></td><td>±1.0E-28 ~ ±7.9228E28</td><td><code>System.Decimal</code></td><td>16 个字节小数</td></tr><tr><td><code>bool</code></td><td>true, false</td><td><code>System.Boolean</code></td><td>布尔类型 ,1 字节</td></tr><tr><td><code>char</code></td><td>U+0000 ~ U+FFFF</td><td><code>System.Char</code></td><td>Unicode UTF-16 字符类型；2 字节</td></tr></tbody></table> 
<h5><a id="_114"></a>结构</h5> 
<pre><code class="prism language-c#">public struct Point
{
    public int x;
    public int y;
}
</code></pre> 
<h5><a id="_124"></a>枚举</h5> 
<pre><code class="prism language-c#">public enum Color
{
    Red = 0,
    Blue = 1,
    Yello = 2,
    Purple = 8,
    Black
}
</code></pre> 
<h4><a id="_139"></a>引用类型</h4> 
<p>因为全是对象,而对象包含数据多,在传递时就会消耗大量性能</p> 
<p>所以出现引用,即指向数据的地址</p> 
<p>我们都是直接传递地址,而非实际数据</p> 
<p>当一个数据没有引用时,就会被释放,即垃圾回收</p> 
<h4><a id="_149"></a>数组</h4> 
<p>数组属于引用类型.数组均继承自 <code>System.Array</code> 类 .</p> 
<h5><a id="_153"></a>一维数组</h5> 
<p>定义一个一维数组的最基本形式如下:</p> 
<pre><code class="prism language-c#">// type[] arr = new type[array_size];
int[] arr1 = new int[5];                    // 定义一个长度为 5 的数组 ,每个元素初始值均为默认值 0
int[] arr2 = new int[5] { 1, 2, 3, 4, 5 };  // 定义一个长度为 5 的数组 ,初始值分别为 1, 2, 3, 4, 5
var arr3 = new int[] { 1, 2, 3, 4, 5 };     // 数组的长度可以由编译器自动推导
int[] arr4 = { 1, 2, 3, 4, 5 };             // 简略写法
</code></pre> 
<p>其中 ,各个数组的类型均为 <code>int[]</code> .可以通过 <code>[]</code> 访问其元素 ,<code>Length</code> 获取元素个数:</p> 
<pre><code class="prism language-c#">for (int i = 0; i &lt; arr1.Length; ++i)
{
    Console.WriteLine(arr1[i]);
}
</code></pre> 
<p>也可以使用 <code>foreach</code> 语句遍历:</p> 
<pre><code class="prism language-c#">foreach (var i in arr1)
{
    Console.WriteLine(i);
}
</code></pre> 
<p>注:通过 <code>foreach</code> 是无法修改数组中的元素的 ,只能访问其值 .</p> 
<h5><a id="_185"></a>多维数组</h5> 
<p>C# 可以定义多维的数组 ,以二维数组为例 ,二维数组的类型为 <code>int[,]</code>:</p> 
<pre><code class="prism language-C#">int[,] arr1 = new int[2, 3] { { 1, 2, 3 }, { 5, 4, 9 } };
int[,] arr2 = { { 1, 2, 3 }, { 5, 4, 9 } };
</code></pre> 
<p>通过 <code>Length</code> 获取数组的长度 ,通过 <code>GetLength(n)</code> 获取数组第 <code>n</code> 维的长度:</p> 
<pre><code class="prism language-c#">var arr = new int[,] { { 1, 2, 3 }, { 5, 4, 9 } };
Console.WriteLine($"{arr.Length} {arr.GetLength(0)} {arr.GetLength(1)}");
</code></pre> 
<p>输出:</p> 
<pre><code class="prism language-text">6 2 3
</code></pre> 
<h5><a id="_207"></a>交错数组</h5> 
<p>C# 支持嵌套的数组 ,即数组的每个元素都是一个数组 .这样的数组称为“交错数组” .以一个每个元素都是一维数组的一维交错数组为例 (其他维度的数组类似):</p> 
<pre><code class="prism language-c#">int[][] arr = new int[2][]
   {
        new int[3]{ 1, 2, 3 },
        new int[2]{ 4, 5 }
   };
</code></pre> 
<p>上述定义了一个具有两个元素的交错数组 .</p> 
<p>需要注意的是 ,数组也是引用类型 ,因此交错数组的每个元素都要用 <code>new</code> 产生 ,例如下面的:</p> 
<pre><code class="prism language-c#">int[][] arr = new int[2][];
</code></pre> 
<p>此处 <code>arr</code> 具有两个元素 ,每个元素都是一个 <code>int[]</code> 的引用 .但是由于并没有用 <code>new</code> 为每个元素创建托管对象 ,因此每个引用都是 <code>null</code> ,并没有指向任何数组 .·</p> 
<h2><a id="_233"></a>运动</h2> 
<h3><a id="_235"></a>输入输出</h3> 
<h4><a id="_237"></a>输出</h4> 
<pre><code class="prism language-C#">System.Console.Write("Hello, ");
System.Console.WriteLine("world!");//会自动添加换行
</code></pre> 
<p>格式化输出</p> 
<pre><code class="prism language-c#">int x = 4, y = 5, z = 6;
Console.WriteLine($"z = {z}, x = {x}, y = {y}"); // {n} 代表该处应换成第 n 个参数的值
</code></pre> 
<h4><a id="_251"></a>输入</h4> 
<p>格式化输入</p> 
<pre><code class="prism language-c#">string s = Console.ReadLine();
int x = Convert.ToInt32(Console.ReadLine());
double d = Convert.ToDouble(Console.ReadLine());
</code></pre> 
<h3><a id="_263"></a>运算与控制</h3> 
<h4><a id="null_265"></a>判断null</h4> 
<ul><li> <p><code>?</code> foo不为空则执行方法(就可以不写if来判断了)</p> <pre><code class="prism language-c#">foo?.DoSomething();
</code></pre> </li><li> <p><code>??</code> s为空则输出后者</p> <pre><code class="prism language-c#">Console.WriteLine(s ?? "Null string");
</code></pre> </li><li> <p><code>??=</code> o为空则赋值</p> <pre><code class="prism language-C#">o ??= new object();
</code></pre> </li></ul> 
<h4><a id="_285"></a>控制</h4> 
<ul><li>条件分支:<code>if</code>、<code>switch</code></li><li>循环:<code>while</code>、<code>do...while</code>、<code>for</code>、<code>foreach</code></li><li>分支:<code>goto</code></li></ul> 
<h2><a id="_291"></a>类</h2> 
<h3><a id="_293"></a>基础</h3> 
<h4><a id="_295"></a>访问修饰符</h4> 
<ul><li><code>private</code>: 这个字段只能够被本类所访问</li><li><code>public</code>:这个字段可以被随意访问</li><li><code>protected</code>:这个字段可以被本类及其派生类访问</li><li><code>internal</code>:这个字段可以在本程序集内随意访问</li><li><code>protected internal</code>:既可以被本类及其派生类访问 ,又可以在本程序集内随意访问</li><li><code>private protected</code>:可以被本类及其在<strong>本程序集</strong>内的派生类访问</li></ul> 
<h4><a id="_304"></a>字段(成员变量)</h4> 
<p>一个类可以含有它自己的字段 (field)</p> 
<p>可设置默认值,不设置则为0或null</p> 
<pre><code class="prism language-c#">class Person
{
    private int age=18;
    private string name;
}
</code></pre> 
<h5><a id="this_318"></a>this</h5> 
<p>指向自己的引用</p> 
<h5><a id="_322"></a>静态字段</h5> 
<p>静态字段可以不需要类的实例</p> 
<pre><code class="prism language-c#">class Person
{
    public static int population;
}
</code></pre> 
<pre><code class="prism language-c#">Console.WriteLine(Person.population);
</code></pre> 
<h5><a id="_337"></a>常量字段</h5> 
<p>常量字段与静态字段一样 ,只能通过“类名.字段名”来访问 .</p> 
<pre><code class="prism language-c#">class MathTool
{
    public const double PI = 3.1415926535897932384626;
}
</code></pre> 
<h4><a id="_350"></a>属性</h4> 
<p>为了封装性,字段应该都通过setter和getter获取值</p> 
<p>为了简化这种操作,C#提供了属性的语法</p> 
<p><strong>属性是对字段的封装</strong></p> 
<h5><a id="_358"></a>手动定义</h5> 
<p>如下 ,<code>Age</code> 是一个属性 ,它用于设置和访问 <code>age</code> 字段的值 .</p> 
<pre><code class="prism language-c#">class Person
{
    private int age;
    public int Age
    {
        get { return age; } // 或 get =&gt; age;
        private set { age = value &gt;= 0 ? value : 0; }
    }
    public Person(int age_)
    {
        Age = age_;  // 调用 set 访问器
    }
    public void AddAge()
    {
        ++Age;  // 调用 set 和 get 访问器 ,等价于 Age = Age + 1;
    }
}
</code></pre> 
<h5><a id="_382"></a>自动实现</h5> 
<p>因为这种成对出现,字段其实就没什么写出来的必要了</p> 
<p>C#提供了自动属性的功能,即我们定义属性就行,会隐式生成字段绑定到属性上</p> 
<pre><code class="prism language-c#">class Complex
{
    public double Real { get; set; }
    public double Imag { get; set; }
}
</code></pre> 
<h5><a id="readonly_396"></a>readonly</h5> 
<p>在字段前加上 <code>readonly</code> 修饰符代表该字段只能在构造方法里被赋值 .一旦构造方法里被赋值后 ,便不能再修改它的值:</p> 
<pre><code class="prism language-c#">class WebPage
{
    private readonly string url;
    public WebPage(string url)
    {
        this.url = url;  
    }
    private void Test()
    {
        // url = "http://www.4399.com"; // 编译错误！url 是只读的！
    }
}
</code></pre> 
<h5><a id="init_415"></a>init</h5> 
<p>类似于只读字段,只能在构造函数内设置,属性的也有类似的特性,将 <code>set</code> 改成 <code>init</code> ,就可以达到该目的</p> 
<pre><code class="prism language-c#">class WebPage
{
    public string Url { get; private init; }
    public WebPage(string url)
    {
        Url = url;  
    }
    private void Test()
    {
        // Url = "http://www.4399.com"; // 编译错误！
    }
}
</code></pre> 
<h4><a id="_438"></a>方法(成员函数)</h4> 
<p>与其他语言不同,c#的函数都是封装在类中的</p> 
<p>类内可以含有方法 (method)</p> 
<pre><code class="prism language-c#">class Person
{
    private int age = 0;
    private string name = "Tom";

    public void Print(int n)
    {
        for (int i = 0; i &lt; n; ++i)
        {
            Console.WriteLine($"age: {age}, name: {name}");
        }
    }
}
</code></pre> 
<p>一个类的方法需要用“对象名.方法名”的方式调用 ,例如:</p> 
<pre><code class="prism language-;">var ps = new Person();
ps.Print(2);
</code></pre> 
<h5><a id="_467"></a>静态方法</h5> 
<p>同静态变量,不需要实例化</p> 
<pre><code class="prism language-c#">class MathTool
{
    static public int Add(int x, int y)
    {
        return x + y;
    }
}
</code></pre> 
<pre><code class="prism language-c#">Console.WriteLine(MathTool.Add(3, 5)); // 输出 8
</code></pre> 
<h5><a id="_487"></a>引用传参</h5> 
<p>因为值类型需要通过方法修改值,则可以通过引用传参实现</p> 
<p>方法,在类型前加上ref修饰</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">int</span></span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Before swap: a = </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">a</span><span class="token punctuation">}</span></span><span class="token string">, b = </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">b</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> a<span class="token punctuation">,</span> <span class="token keyword">ref</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"After swap: a = </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">a</span><span class="token punctuation">}</span></span><span class="token string">, b = </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">b</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> y<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">int</span></span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span>
        x <span class="token operator">=</span> y<span class="token punctuation">;</span>
        y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_517"></a>输出参数</h5> 
<p>参数除了以 <code>ref</code> 方式传递外 ,有时我们需要用参数来返回值 .</p> 
<p>这时虽然也可以用 <code>ref</code> 关键字来达到目的 ,但是最好使用 <code>out</code> 关键字 ,用法与 <code>ref</code> 完全相同 .</p> 
<p>只不过使用 <code>out</code> 的时候编译器会进行编译器检查 ,是否真的给该参数赋了值 ,并且不能未经赋值便获取该参数的值 .</p> 
<p>也可以给参数加上 <code>in</code> 关键字修饰以强调该参数是输入参数,知识增加代码可读性.</p> 
<h5><a id="_527"></a>默认参数</h5> 
<p>C# 具有参数缺省值:</p> 
<pre><code class="prism language-c#">class MathTool
{
    static public int Div(int x = 1, int y = 1)
    {
        return x / y;
    }
}
</code></pre> 
<h5><a id="_541"></a>简化函数体</h5> 
<p>如果函数体非常简短 ,可以使用 <code>=&gt;</code> 运算符:</p> 
<pre><code class="prism language-c#">class MathTool
{
    static public int Add(int x, int y) =&gt; x + y;
}
</code></pre> 
<h5><a id="_554"></a>扩展方法</h5> 
<p>C# 可以为一个类定义扩展方法 .即一个类定义好后 ,可以在类外为这个类定义额外的方法 ,被扩展的类需要作为第一个参数 ,并用 <code>this</code> 标识:</p> 
<pre><code class="prism language-c#">static public void Output(this string s, int times)
{
    for (int i = 0; i &lt; times; i++)
    {
        Console.WriteLine(s);
    }
}
</code></pre> 
<p>我们为 <code>string</code> 类定义了一个扩展方法 ,之后我们可以像使用平常的方法一样使用扩展方法:</p> 
<pre><code class="prism language-c#">string s = "Hello";
s.Output(5);
</code></pre> 
<h4><a id="_577"></a>特殊方法</h4> 
<h5><a id="_579"></a>构造方法</h5> 
<p>每个类可以定义构造方法 .构造方法不具有返回值 ,且方法名与类名相同 ,是在一个对象被构造的时候调用的方法 ,由 <code>new</code> 表达式传递参数:</p> 
<pre><code class="prism language-c#">class Person
{
    private int age;
    public Person(int age_)
    {
        age = age_;
    }
}
</code></pre> 
<pre><code class="prism language-c#">Person ps = new Person(4);
</code></pre> 
<h5><a id="_600"></a>析构函数</h5> 
<p>本名终结器 (finalizer) ,是类的一个方法 ,一个类只能有一个终结器 ,且不能继承或重载 ,而是在垃圾回收器在回收该对象的内存的时候调用的 .</p> 
<p>终结器的名字是类名前加上波浪线 <code>~</code> ,例如:</p> 
<pre><code class="prism language-c#">class Foo
{
    ~Foo() // 终结器
    {
        
    }
}
</code></pre> 
<h4><a id="_616"></a>重载</h4> 
<h5><a id="_618"></a>方法的重载</h5> 
<p>一个类里可以定义多个同名方法 ,但是它们的参数列表必须不同 .调用时根据传递的实参决定调用哪个重载方法 .</p> 
<h5><a id="_622"></a>运算符重载</h5> 
<p>一些运算符可以进行重载 ,例如:<code>+</code>、<code>-</code>、<code>*</code>、<code>&amp;</code>、<code>|</code>、<code>true</code>、<code>false</code> ,等等 .方法是将运算符 (设为 <code>op</code>)其定义成方法 <code>operator op</code> .需要注意的是 ,运算符重载只能将运算符重载为<strong>静态方法</strong> ,而不能是非静态方法 ,例如计算向量内积:</p> 
<pre><code class="prism language-c#">namespace Math
{
    public class Vector2
    {
        public double X { get; private set; }
        public double Y { get; private set; }
        public Vector2(double x, double y)
        {
            this.X = x;
            this.Y = y;
        }
        public static double operator*(Vector2 v1, Vector2 v2)
        {
            return v1.X * v2.X + v1.Y * v2.Y;
        }
    }
}
</code></pre> 
<h3><a id="_654"></a>继承</h3> 
<p>C# 继承的语法如下:</p> 
<pre><code class="prism language-c#">public class Base {}
public class Derived : Base {}
</code></pre> 
<p><code>Derived</code> 类继承自基类 <code>Base</code> .如果一个类没有显式继承另一个类 ,那么它默认继承自 <code>object</code> 类 .</p> 
<p>C# 不支持类的多继承 ,即一个类有且仅有一个基类 (<code>object</code> 类除外) .</p> 
<p>在类里可以通过 <code>base</code> 关键字代表它的基类 ,同样构造方法也需要通过 <code>base</code> 关键字来为它的基类提供构造方法的参数 .</p> 
<pre><code class="prism language-c#">class Animal
{
    private string name;
    public Animal(string name)
    {
        this.name = name;
    }
}
class Dog : Animal
{
    public Dog(string name) : base(name) {}
}
</code></pre> 
<h4><a id="_686"></a>密封类</h4> 
<p>密封类用 <code>sealed</code> 标识 .密封类不可再被继承 ,即被声明为 <code>sealed</code> 的类不能再派生任何类 ,例如:</p> 
<pre><code class="prism language-c#">public sealed class Foo {}
</code></pre> 
<h4><a id="is__694"></a><code>is</code> 运算符</h4> 
<p>.NET 支持在运行期进行类型检查 .使用 <code>is</code> 运算符可以检查对象的类型 ,例如:</p> 
<pre><code class="prism language-c#">// 变量声明:
// Animal ani = new Animal("");
// Dog dog = new Dog("");
// Animal ani2 = dog;  // 用 ani2 引用指向 dog 指向的对象
// object o = 1;   // 将整数 1 装箱

Console.WriteLine(ani is Animal);   // True ,ani 是 Animal 类的对象
Console.WriteLine(ani is Dog);      // False ,ani 不是 Dog 类的对象
Console.WriteLine(dog is Animal);   // True ,Animal 是 Dog 类的基类
Console.WriteLine(ani2 is Dog);     // True ,ani2 指向的确实是 Dog 类的对象
Console.WriteLine(o is int);        // True ,拆箱
</code></pre> 
<h3><a id="_714"></a>多态</h3> 
<h4><a id="_716"></a>抽象类</h4> 
<p>即预定义了方法,需要继承后完善,如下的call(),可用abstract和virtual修饰</p> 
<pre><code class="prism language-c#">public abstract class Animal
{
    public abstract void Call();
}

public sealed class Dog : Animal
{
    public override void Call()
    {
        Console.WriteLine("Wang wang!");
    }
}
</code></pre> 
<pre><code class="prism language-c#">Animal ani = new Dog();
ani.Call();                     // 输出 Wang wang
// Animal ani2 = new Animal();  // 编译错误 ,Animal 是抽象类
</code></pre> 
<h4><a id="_743"></a>接口</h4> 
<p>C# 支持接口 (interface),不含字段的类,用interface定义</p> 
<p>着重于数据处理</p> 
<pre><code class="prism language-c#">public interface ICallable
{
    void Call();
}

public class Cat : ICallable
{
    void ICallable.Call()
    {
        Console.WriteLine("Meow");
    }
}
</code></pre> 
<h3><a id="_766"></a>泛型(模板)</h3> 
<p>C# 支持泛型 .可以创建泛型类、泛型方法、泛型接口、泛型委托、泛型记录 ,等等 .</p> 
<p>泛型类和泛型方法的定义方法很简单 ,只需要在类或方法名后使用尖括号 <code>&lt;&gt;</code> 括住泛型的名称即可:</p> 
<pre><code class="prism language-c#">class Point&lt;T&gt;
{
    public T X { get; private set; }
    public T Y { get; private set; }
    public Point(T x, T y)
    {
        this.X = x;
        this.Y = y;
    }
}
</code></pre> 
<pre><code class="prism language-c#">Point&lt;int&gt; pt = new Point(0, 0);
</code></pre> 
<h3><a id="_789"></a>委托</h3> 
<p>委托提供了一种有效的机制来实现调用和事件处理定义、实例化</p> 
<p><strong>自定义</strong></p> 
<p>需要用 <code>delegate</code> 关键字定义一个委托类型 .委托类型的定义格式与方法类似 ,只是在返回值类型前加上 <code>delegate</code> 关键字:</p> 
<pre><code class="prism language-c#">// int Add(int a, int b) =&gt; a + b;  // Add 方法的定义
delegate int BinaryFunctor(int x, int y); 	//定义委托
BinaryFunctor bf = new BinaryFunctor(Add); 	//赋值委托
Console.WriteLine(bf(3, 5)); 			   //使用委托
</code></pre> 
<p><strong>内置委托</strong></p> 
<p>多数情况下 ,我们并不需要自定义委托类型 ,.NET 中已经定义好了一些内置的委托类型:</p> 
<ul><li><code>Action</code> 是返回值为 <code>void</code> 类型的委托 ,泛型参数列表内为参数列表 ,例如 <code>Action</code> 为无参且返回值为 <code>void</code> 的委托、<code>Action&lt;int&gt;</code> 为参数是 <code>int</code> 且返回值为 <code>void</code> 的委托 .<code>Action</code> 最多可以有 16 个参数类型 .</li><li><code>Func</code> 是既有参数又有返回值的委托 .泛型参数列表中最后一个为返回值类型 .例如 <code>Func&lt;int, double&gt;</code> 为参数是 <code>int</code>、返回值是 <code>double</code> 的委托 .<code>Func</code> 最多可达 16 个参数类型和 1 个返回值类型 .</li></ul> 
<p><strong>多播委托</strong></p> 
<p>一个委托不仅可以绑定一个方法 ,还可以绑定多个方法 .这种委托我们称为“多播委托” .</p> 
<p>可以用 <code>+</code> 或 <code>-</code> 来将方法从委托中附加或删除</p> 
<pre><code class="prism language-c#">// static public void Call1() =&gt; Console.WriteLine("Call1");
// static public void Call2() =&gt; Console.WriteLine("Call2");
// static public void Call3() =&gt; Console.WriteLine("Call3");

var caller = new Action(Call1);
caller += Call2;
caller = caller + Call3;
caller.Invoke(); // 等价于 caller();
</code></pre> 
<p><strong>lambda</strong> 表达式</p> 
<p>lambda 表达式可以看成是一个匿名方法 .语法很简单 ,例如一个求和的 lambda 表达式:</p> 
<pre><code class="prism language-c#">(x, y) =&gt; {x + y;
</code></pre> 
<p>lambda 表达式可以直接当作方法赋值给委托 ,例如:</p> 
<pre><code class="prism language-c#">var output = new Action
(
	() =&gt; Console.WriteLine("Hello, world!");
);
var getAddOne = new Func&lt;int, int&gt;(x =&gt; x + 1);
</code></pre> 
<p>lambda 表达式可以自动推导出 <code>Action</code> 或 <code>Func</code> 类型 ,也可以手动指定参数类型和返回值类型 ,因此上述代码可以用以下更简洁的方式写出:</p> 
<pre><code class="prism language-c#">var output = () =&gt;
{
    Console.WriteLine("Hello, world!");
};
var getAddOne = (int x) =&gt; x + 1;
</code></pre> 
<p>以及下面的代码:</p> 
<pre><code class="prism language-c#">var f = object (int x) =&gt; x + 1; // f 是 Func&lt;int, object&gt; 而非 Func&lt;int, int&gt;
</code></pre> 
<h3><a id="_864"></a>事件</h3> 
<p>如捕获键盘输入,这种多可能事件,并对不同事件添加不同方法</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Publisher</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyEventHandler</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyEventHandler</span> MyEvent<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">RaiseEvent</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> message<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        MyEvent<span class="token punctuation">?.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Subscriber</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">HandleEvent</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> message<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Event handled: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">message</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Publisher</span> publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Publisher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Subscriber</span> subscriber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Subscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        publisher<span class="token punctuation">.</span>MyEvent <span class="token operator">+=</span> subscriber<span class="token punctuation">.</span>HandleEvent<span class="token punctuation">;</span>
        
        publisher<span class="token punctuation">.</span><span class="token function">RaiseEvent</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_906"></a>异常处理</h3> 
<p>C# 支持异常处理 .异常处理由一个 <code>try</code> 语句块加上至少一个 <code>catch</code> 或 <code>finally</code> 语句块组成:</p> 
<pre><code class="prism language-c#">try
{
    /*Some code*/
}
/*catch / finally*/
</code></pre> 
<p>举一个简单的例子 ,<code>Exception</code> 是 <code>System</code> 命名空间的一个类 ,是一切异常类的基类 ,抛出的异常也必须从 <code>Exception</code> 类中派生出来 .<code>Message</code> 是该类的虚属性 ,通常储存着异常信息 .</p> 
<pre><code class="prism language-c#">try
{
    /*Some code 1*/
    throw new Exception("Throw an exception!");
    /*Some code 2*/
}
catch (Exception e)
{
    Console.WriteLine(e.Message);
}
</code></pre> 
<p>上述代码中 ,“Some code 1”执行完毕后 ,将会执行 <code>throw</code> 语句 ,实例化一个 <code>Exception</code> 对象 ,并抛出 .然后被下面的 <code>catch</code> 捕获到 ,执行 <code>catch</code> 块内的语句 .</p> 
<p><code>try</code> 块下可能有多个 <code>catch</code> 块 ,则抛出异常时会一次查找下面每个 <code>catch</code> 块所捕获的内容 .如果找到了可以匹配的类型 ,则执行该 <code>catch</code> 块 ,如果没找到则异常向上抛出 .</p> 
<p>单独的一个 <code>catch</code> 可以捕获全部异常 ,单独的一个 <code>throw</code> 可以将捕获的异常再次抛出:</p> 
<pre><code class="prism language-c#">try {}
catch  // 捕获全部异常
{
    Console.WriteLine("Caught");
    throw; // 将捕获到的异常再次抛出
}
</code></pre> 
<p>C# 支持 <code>finally</code> 语句块 ,放在所有 <code>catch</code> 块之后 .无论是否抛出了异常、是否执行了 <code>try</code> 和 <code>catch</code> ,在执行完全部的 <code>try</code> 或 <code>catch</code> 后 ,都将进入 <code>finally</code> 块执行 ,然后再执行其他工作 .因此 <code>finally</code> 块常用于进行一些恢复或清理的工作 .</p> 
<pre><code class="prism language-c#">// var rwlock = new ReaderWriterLockSlim();
rwlock.EnterWriteLock();    // 锁住
try
{
    /* Some code */
}
finally
{
    rwlock.ExitWriteLock();   // 解锁
}
</code></pre> 
<h3><a id="_IDisposable_967"></a>非托管资源与 <code>IDisposable</code></h3> 
<p>有时 ,我们使用的资源并不都是托管的 ,我们需要手动管理这些非托管资源 .例如我们在与一些底层的应用程序接口 (API)进行交互的时候 ,我们必须要考虑资源泄露的问题 .这时候 ,我们可以让类继承 <code>System.IDisposable</code> 接口 ,实现接口中的 <code>Dispose()</code> 方法来达到目的 .</p> 
<pre><code class="prism language-c#">partial class DeviceContext : IDisposable
{
    public void Dispose()
    {
        /*Release resources*/
    }
}
</code></pre> 
<p>之后我们实例化 <code>DiviceContext</code> 时 ,便可以使用 <code>using</code>:</p> 
<pre><code class="prism language-c#">public void Draw()
{
    using var dc = new DeviceContext();
    /*Use dc to draw pictures*/

    // 函数退出前调用 Dispose 方法
}
</code></pre> 
<p>这时 ,编译器会把上述代码展开成下面代码的等效代码:</p> 
<pre><code class="prism language-c#">public void Draw()
{
    DeviceContext? dc = null;
    try
    {
        dc = new DeviceContext();
        /*Use dc to draw pictures*/
    }
    finally { ((IDisposable)dc)?.Dispose(); }
}
</code></pre> 
<p>如果想让资源在函数中释放而不是函数退出时:</p> 
<pre><code class="prism language-c#">public void Draw()
{
    // Do something
    using (var dc = new DeviceContext())
    {
        /* Use dc to draw pictures */

        // 跳出 using 块前调用 Dispose 方法
    }
    // Do something
}
</code></pre> 
<p>这样我们就能有效管控非托管资源 .</p> 
<h2><a id="NET__1034"></a>.NET 数据结构</h2> 
<p>.NET 提供了很多数据结构可供使用:</p> 
<h3><a id="SystemCollections_1038"></a><code>System.Collections</code></h3> 
<p>位于 <code>System.Collections</code> 命名空间中的集合的每个元素都是 <code>object</code> (少数集合如 <code>BitArray</code> 除外) ,这意味着它可以容纳任何类型:</p> 
<ul><li><code>ArrayList</code>:列表 (可变长的数组 ,线性结构)</li><li><code>SortedList</code>:有序列表</li><li><code>Stack</code>:栈</li><li><code>Queue</code>:队列</li><li><code>Hashtable</code>:哈希表 (键值对)</li></ul> 
<h3><a id="SystemCollectionsGeneric_1048"></a><code>System.Collections.Generic</code></h3> 
<p>位于 <code>System.ollections.Generic</code> 命名空间中的集合都是泛型集合 ,其容纳的元素类型由泛型参数决定:</p> 
<ul><li><code>List&lt;T&gt;</code>:列表 (可变长的数组 ,线性结构)</li><li><code>SortedSet&lt;T&gt;</code>:有序列表</li><li><code>SortedList&lt;T&gt;</code>:有序列表 (键值对)</li><li><code>LinkedList&lt;T&gt;</code>:双向链表</li><li><code>Stack&lt;T&gt;</code>:栈</li><li><code>Queue&lt;T&gt;</code>:队列</li><li><code>PriorityQueue&lt;T&gt;</code>:优先级队列</li><li><code>HashSet</code>:哈希集合</li><li><code>Dictionary</code>:字典 (键值对)</li><li><code>SortedDictionary</code>:有序字典 (键值对 ,二叉搜索树)</li></ul> 
<h3><a id="SystemCollectionsConcurrentnt_1063"></a><code>System.Collections.Concurrent</code>nt)</h3> 
<p>位于 <code>System.Collections.Concurrent</code> 命名空间中的集合时并发安全的 ,将在其他文档中进行介绍 .</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e6715b94850276a0c955be226b8fd27/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">web前端项目-七彩夜空烟花【附源码】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/62a259532642d4a239b5142a4c103449/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">交换机端口镜像技术原理与配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>